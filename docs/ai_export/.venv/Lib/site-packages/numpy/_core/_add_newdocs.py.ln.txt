    1: """
    2: This is only meant to add docs to objects defined in C-extension modules.
    3: The purpose is to allow easier editing of the docstrings without
    4: requiring a re-compile.
    5: 
    6: NOTE: Many of the methods of ndarray have corresponding functions.
    7:       If you update these docstrings, please keep also the ones in
    8:       _core/fromnumeric.py, matrixlib/defmatrix.py up-to-date.
    9: 
   10: """
   11: 
   12: from numpy._core.function_base import add_newdoc
   13: from numpy._core.overrides import get_array_function_like_doc  # noqa: F401
   14: 
   15: ###############################################################################
   16: #
   17: # flatiter
   18: #
   19: # flatiter needs a toplevel description
   20: #
   21: ###############################################################################
   22: 
   23: add_newdoc('numpy._core', 'flatiter',
   24:     """
   25:     Flat iterator object to iterate over arrays.
   26: 
   27:     A `flatiter` iterator is returned by ``x.flat`` for any array `x`.
   28:     It allows iterating over the array as if it were a 1-D array,
   29:     either in a for-loop or by calling its `next` method.
   30: 
   31:     Iteration is done in row-major, C-style order (the last
   32:     index varying the fastest). The iterator can also be indexed using
   33:     basic slicing or advanced indexing.
   34: 
   35:     See Also
   36:     --------
   37:     ndarray.flat : Return a flat iterator over an array.
   38:     ndarray.flatten : Returns a flattened copy of an array.
   39: 
   40:     Notes
   41:     -----
   42:     A `flatiter` iterator can not be constructed directly from Python code
   43:     by calling the `flatiter` constructor.
   44: 
   45:     Examples
   46:     --------
   47:     >>> import numpy as np
   48:     >>> x = np.arange(6).reshape(2, 3)
   49:     >>> fl = x.flat
   50:     >>> type(fl)
   51:     <class 'numpy.flatiter'>
   52:     >>> for item in fl:
   53:     ...     print(item)
   54:     ...
   55:     0
   56:     1
   57:     2
   58:     3
   59:     4
   60:     5
   61: 
   62:     >>> fl[2:4]
   63:     array([2, 3])
   64: 
   65:     """)
   66: 
   67: # flatiter attributes
   68: 
   69: add_newdoc('numpy._core', 'flatiter', ('base',
   70:     """
   71:     A reference to the array that is iterated over.
   72: 
   73:     Examples
   74:     --------
   75:     >>> import numpy as np
   76:     >>> x = np.arange(5)
   77:     >>> fl = x.flat
   78:     >>> fl.base is x
   79:     True
   80: 
   81:     """))
   82: 
   83: 
   84: add_newdoc('numpy._core', 'flatiter', ('coords',
   85:     """
   86:     An N-dimensional tuple of current coordinates.
   87: 
   88:     Examples
   89:     --------
   90:     >>> import numpy as np
   91:     >>> x = np.arange(6).reshape(2, 3)
   92:     >>> fl = x.flat
   93:     >>> fl.coords
   94:     (0, 0)
   95:     >>> next(fl)
   96:     0
   97:     >>> fl.coords
   98:     (0, 1)
   99: 
  100:     """))
  101: 
  102: 
  103: add_newdoc('numpy._core', 'flatiter', ('index',
  104:     """
  105:     Current flat index into the array.
  106: 
  107:     Examples
  108:     --------
  109:     >>> import numpy as np
  110:     >>> x = np.arange(6).reshape(2, 3)
  111:     >>> fl = x.flat
  112:     >>> fl.index
  113:     0
  114:     >>> next(fl)
  115:     0
  116:     >>> fl.index
  117:     1
  118: 
  119:     """))
  120: 
  121: # flatiter functions
  122: 
  123: add_newdoc('numpy._core', 'flatiter', ('__array__',
  124:     """__array__(type=None) Get array from iterator
  125: 
  126:     """))
  127: 
  128: 
  129: add_newdoc('numpy._core', 'flatiter', ('copy',
  130:     """
  131:     copy()
  132: 
  133:     Get a copy of the iterator as a 1-D array.
  134: 
  135:     Examples
  136:     --------
  137:     >>> import numpy as np
  138:     >>> x = np.arange(6).reshape(2, 3)
  139:     >>> x
  140:     array([[0, 1, 2],
  141:            [3, 4, 5]])
  142:     >>> fl = x.flat
  143:     >>> fl.copy()
  144:     array([0, 1, 2, 3, 4, 5])
  145: 
  146:     """))
  147: 
  148: 
  149: ###############################################################################
  150: #
  151: # nditer
  152: #
  153: ###############################################################################
  154: 
  155: add_newdoc('numpy._core', 'nditer',
  156:     """
  157:     nditer(op, flags=None, op_flags=None, op_dtypes=None, order='K',
  158:         casting='safe', op_axes=None, itershape=None, buffersize=0)
  159: 
  160:     Efficient multi-dimensional iterator object to iterate over arrays.
  161:     To get started using this object, see the
  162:     :ref:`introductory guide to array iteration <arrays.nditer>`.
  163: 
  164:     Parameters
  165:     ----------
  166:     op : ndarray or sequence of array_like
  167:         The array(s) to iterate over.
  168: 
  169:     flags : sequence of str, optional
  170:           Flags to control the behavior of the iterator.
  171: 
  172:           * ``buffered`` enables buffering when required.
  173:           * ``c_index`` causes a C-order index to be tracked.
  174:           * ``f_index`` causes a Fortran-order index to be tracked.
  175:           * ``multi_index`` causes a multi-index, or a tuple of indices
  176:             with one per iteration dimension, to be tracked.
  177:           * ``common_dtype`` causes all the operands to be converted to
  178:             a common data type, with copying or buffering as necessary.
  179:           * ``copy_if_overlap`` causes the iterator to determine if read
  180:             operands have overlap with write operands, and make temporary
  181:             copies as necessary to avoid overlap. False positives (needless
  182:             copying) are possible in some cases.
  183:           * ``delay_bufalloc`` delays allocation of the buffers until
  184:             a reset() call is made. Allows ``allocate`` operands to
  185:             be initialized before their values are copied into the buffers.
  186:           * ``external_loop`` causes the ``values`` given to be
  187:             one-dimensional arrays with multiple values instead of
  188:             zero-dimensional arrays.
  189:           * ``grow_inner`` allows the ``value`` array sizes to be made
  190:             larger than the buffer size when both ``buffered`` and
  191:             ``external_loop`` is used.
  192:           * ``ranged`` allows the iterator to be restricted to a sub-range
  193:             of the iterindex values.
  194:           * ``refs_ok`` enables iteration of reference types, such as
  195:             object arrays.
  196:           * ``reduce_ok`` enables iteration of ``readwrite`` operands
  197:             which are broadcasted, also known as reduction operands.
  198:           * ``zerosize_ok`` allows `itersize` to be zero.
  199:     op_flags : list of list of str, optional
  200:           This is a list of flags for each operand. At minimum, one of
  201:           ``readonly``, ``readwrite``, or ``writeonly`` must be specified.
  202: 
  203:           * ``readonly`` indicates the operand will only be read from.
  204:           * ``readwrite`` indicates the operand will be read from and written to.
  205:           * ``writeonly`` indicates the operand will only be written to.
  206:           * ``no_broadcast`` prevents the operand from being broadcasted.
  207:           * ``contig`` forces the operand data to be contiguous.
  208:           * ``aligned`` forces the operand data to be aligned.
  209:           * ``nbo`` forces the operand data to be in native byte order.
  210:           * ``copy`` allows a temporary read-only copy if required.
  211:           * ``updateifcopy`` allows a temporary read-write copy if required.
  212:           * ``allocate`` causes the array to be allocated if it is None
  213:             in the ``op`` parameter.
  214:           * ``no_subtype`` prevents an ``allocate`` operand from using a subtype.
  215:           * ``arraymask`` indicates that this operand is the mask to use
  216:             for selecting elements when writing to operands with the
  217:             'writemasked' flag set. The iterator does not enforce this,
  218:             but when writing from a buffer back to the array, it only
  219:             copies those elements indicated by this mask.
  220:           * ``writemasked`` indicates that only elements where the chosen
  221:             ``arraymask`` operand is True will be written to.
  222:           * ``overlap_assume_elementwise`` can be used to mark operands that are
  223:             accessed only in the iterator order, to allow less conservative
  224:             copying when ``copy_if_overlap`` is present.
  225:     op_dtypes : dtype or tuple of dtype(s), optional
  226:         The required data type(s) of the operands. If copying or buffering
  227:         is enabled, the data will be converted to/from their original types.
  228:     order : {'C', 'F', 'A', 'K'}, optional
  229:         Controls the iteration order. 'C' means C order, 'F' means
  230:         Fortran order, 'A' means 'F' order if all the arrays are Fortran
  231:         contiguous, 'C' order otherwise, and 'K' means as close to the
  232:         order the array elements appear in memory as possible. This also
  233:         affects the element memory order of ``allocate`` operands, as they
  234:         are allocated to be compatible with iteration order.
  235:         Default is 'K'.
  236:     casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
  237:         Controls what kind of data casting may occur when making a copy
  238:         or buffering.  Setting this to 'unsafe' is not recommended,
  239:         as it can adversely affect accumulations.
  240: 
  241:         * 'no' means the data types should not be cast at all.
  242:         * 'equiv' means only byte-order changes are allowed.
  243:         * 'safe' means only casts which can preserve values are allowed.
  244:         * 'same_kind' means only safe casts or casts within a kind,
  245:           like float64 to float32, are allowed.
  246:         * 'unsafe' means any data conversions may be done.
  247:     op_axes : list of list of ints, optional
  248:         If provided, is a list of ints or None for each operands.
  249:         The list of axes for an operand is a mapping from the dimensions
  250:         of the iterator to the dimensions of the operand. A value of
  251:         -1 can be placed for entries, causing that dimension to be
  252:         treated as `newaxis`.
  253:     itershape : tuple of ints, optional
  254:         The desired shape of the iterator. This allows ``allocate`` operands
  255:         with a dimension mapped by op_axes not corresponding to a dimension
  256:         of a different operand to get a value not equal to 1 for that
  257:         dimension.
  258:     buffersize : int, optional
  259:         When buffering is enabled, controls the size of the temporary
  260:         buffers. Set to 0 for the default value.
  261: 
  262:     Attributes
  263:     ----------
  264:     dtypes : tuple of dtype(s)
  265:         The data types of the values provided in `value`. This may be
  266:         different from the operand data types if buffering is enabled.
  267:         Valid only before the iterator is closed.
  268:     finished : bool
  269:         Whether the iteration over the operands is finished or not.
  270:     has_delayed_bufalloc : bool
  271:         If True, the iterator was created with the ``delay_bufalloc`` flag,
  272:         and no reset() function was called on it yet.
  273:     has_index : bool
  274:         If True, the iterator was created with either the ``c_index`` or
  275:         the ``f_index`` flag, and the property `index` can be used to
  276:         retrieve it.
  277:     has_multi_index : bool
  278:         If True, the iterator was created with the ``multi_index`` flag,
  279:         and the property `multi_index` can be used to retrieve it.
  280:     index
  281:         When the ``c_index`` or ``f_index`` flag was used, this property
  282:         provides access to the index. Raises a ValueError if accessed
  283:         and ``has_index`` is False.
  284:     iterationneedsapi : bool
  285:         Whether iteration requires access to the Python API, for example
  286:         if one of the operands is an object array.
  287:     iterindex : int
  288:         An index which matches the order of iteration.
  289:     itersize : int
  290:         Size of the iterator.
  291:     itviews
  292:         Structured view(s) of `operands` in memory, matching the reordered
  293:         and optimized iterator access pattern. Valid only before the iterator
  294:         is closed.
  295:     multi_index
  296:         When the ``multi_index`` flag was used, this property
  297:         provides access to the index. Raises a ValueError if accessed
  298:         accessed and ``has_multi_index`` is False.
  299:     ndim : int
  300:         The dimensions of the iterator.
  301:     nop : int
  302:         The number of iterator operands.
  303:     operands : tuple of operand(s)
  304:         The array(s) to be iterated over. Valid only before the iterator is
  305:         closed.
  306:     shape : tuple of ints
  307:         Shape tuple, the shape of the iterator.
  308:     value
  309:         Value of ``operands`` at current iteration. Normally, this is a
  310:         tuple of array scalars, but if the flag ``external_loop`` is used,
  311:         it is a tuple of one dimensional arrays.
  312: 
  313:     Notes
  314:     -----
  315:     `nditer` supersedes `flatiter`.  The iterator implementation behind
  316:     `nditer` is also exposed by the NumPy C API.
  317: 
  318:     The Python exposure supplies two iteration interfaces, one which follows
  319:     the Python iterator protocol, and another which mirrors the C-style
  320:     do-while pattern.  The native Python approach is better in most cases, but
  321:     if you need the coordinates or index of an iterator, use the C-style pattern.
  322: 
  323:     Examples
  324:     --------
  325:     Here is how we might write an ``iter_add`` function, using the
  326:     Python iterator protocol:
  327: 
  328:     >>> import numpy as np
  329: 
  330:     >>> def iter_add_py(x, y, out=None):
  331:     ...     addop = np.add
  332:     ...     it = np.nditer([x, y, out], [],
  333:     ...                 [['readonly'], ['readonly'], ['writeonly','allocate']])
  334:     ...     with it:
  335:     ...         for (a, b, c) in it:
  336:     ...             addop(a, b, out=c)
  337:     ...         return it.operands[2]
  338: 
  339:     Here is the same function, but following the C-style pattern:
  340: 
  341:     >>> def iter_add(x, y, out=None):
  342:     ...    addop = np.add
  343:     ...    it = np.nditer([x, y, out], [],
  344:     ...                [['readonly'], ['readonly'], ['writeonly','allocate']])
  345:     ...    with it:
  346:     ...        while not it.finished:
  347:     ...            addop(it[0], it[1], out=it[2])
  348:     ...            it.iternext()
  349:     ...        return it.operands[2]
  350: 
  351:     Here is an example outer product function:
  352: 
  353:     >>> def outer_it(x, y, out=None):
  354:     ...     mulop = np.multiply
  355:     ...     it = np.nditer([x, y, out], ['external_loop'],
  356:     ...             [['readonly'], ['readonly'], ['writeonly', 'allocate']],
  357:     ...             op_axes=[list(range(x.ndim)) + [-1] * y.ndim,
  358:     ...                      [-1] * x.ndim + list(range(y.ndim)),
  359:     ...                      None])
  360:     ...     with it:
  361:     ...         for (a, b, c) in it:
  362:     ...             mulop(a, b, out=c)
  363:     ...         return it.operands[2]
  364: 
  365:     >>> a = np.arange(2)+1
  366:     >>> b = np.arange(3)+1
  367:     >>> outer_it(a,b)
  368:     array([[1, 2, 3],
  369:            [2, 4, 6]])
  370: 
  371:     Here is an example function which operates like a "lambda" ufunc:
  372: 
  373:     >>> def luf(lamdaexpr, *args, **kwargs):
  374:     ...    '''luf(lambdaexpr, op1, ..., opn, out=None, order='K', casting='safe', buffersize=0)'''
  375:     ...    nargs = len(args)
  376:     ...    op = (kwargs.get('out',None),) + args
  377:     ...    it = np.nditer(op, ['buffered','external_loop'],
  378:     ...            [['writeonly','allocate','no_broadcast']] +
  379:     ...                            [['readonly','nbo','aligned']]*nargs,
  380:     ...            order=kwargs.get('order','K'),
  381:     ...            casting=kwargs.get('casting','safe'),
  382:     ...            buffersize=kwargs.get('buffersize',0))
  383:     ...    while not it.finished:
  384:     ...        it[0] = lamdaexpr(*it[1:])
  385:     ...        it.iternext()
  386:     ...    return it.operands[0]
  387: 
  388:     >>> a = np.arange(5)
  389:     >>> b = np.ones(5)
  390:     >>> luf(lambda i,j:i*i + j/2, a, b)
  391:     array([  0.5,   1.5,   4.5,   9.5,  16.5])
  392: 
  393:     If operand flags ``"writeonly"`` or ``"readwrite"`` are used the
  394:     operands may be views into the original data with the
  395:     `WRITEBACKIFCOPY` flag. In this case `nditer` must be used as a
  396:     context manager or the `nditer.close` method must be called before
  397:     using the result. The temporary data will be written back to the
  398:     original data when the :meth:`~object.__exit__` function is called
  399:     but not before:
  400: 
  401:     >>> a = np.arange(6, dtype='i4')[::-2]
  402:     >>> with np.nditer(a, [],
  403:     ...        [['writeonly', 'updateifcopy']],
  404:     ...        casting='unsafe',
  405:     ...        op_dtypes=[np.dtype('f4')]) as i:
  406:     ...    x = i.operands[0]
  407:     ...    x[:] = [-1, -2, -3]
  408:     ...    # a still unchanged here
  409:     >>> a, x
  410:     (array([-1, -2, -3], dtype=int32), array([-1., -2., -3.], dtype=float32))
  411: 
  412:     It is important to note that once the iterator is exited, dangling
  413:     references (like `x` in the example) may or may not share data with
  414:     the original data `a`. If writeback semantics were active, i.e. if
  415:     `x.base.flags.writebackifcopy` is `True`, then exiting the iterator
  416:     will sever the connection between `x` and `a`, writing to `x` will
  417:     no longer write to `a`. If writeback semantics are not active, then
  418:     `x.data` will still point at some part of `a.data`, and writing to
  419:     one will affect the other.
  420: 
  421:     Context management and the `close` method appeared in version 1.15.0.
  422: 
  423:     """)
  424: 
  425: # nditer methods
  426: 
  427: add_newdoc('numpy._core', 'nditer', ('copy',
  428:     """
  429:     copy()
  430: 
  431:     Get a copy of the iterator in its current state.
  432: 
  433:     Examples
  434:     --------
  435:     >>> import numpy as np
  436:     >>> x = np.arange(10)
  437:     >>> y = x + 1
  438:     >>> it = np.nditer([x, y])
  439:     >>> next(it)
  440:     (array(0), array(1))
  441:     >>> it2 = it.copy()
  442:     >>> next(it2)
  443:     (array(1), array(2))
  444: 
  445:     """))
  446: 
  447: add_newdoc('numpy._core', 'nditer', ('operands',
  448:     """
  449:     operands[`Slice`]
  450: 
  451:     The array(s) to be iterated over. Valid only before the iterator is closed.
  452:     """))
  453: 
  454: add_newdoc('numpy._core', 'nditer', ('debug_print',
  455:     """
  456:     debug_print()
  457: 
  458:     Print the current state of the `nditer` instance and debug info to stdout.
  459: 
  460:     """))
  461: 
  462: add_newdoc('numpy._core', 'nditer', ('enable_external_loop',
  463:     """
  464:     enable_external_loop()
  465: 
  466:     When the "external_loop" was not used during construction, but
  467:     is desired, this modifies the iterator to behave as if the flag
  468:     was specified.
  469: 
  470:     """))
  471: 
  472: add_newdoc('numpy._core', 'nditer', ('iternext',
  473:     """
  474:     iternext()
  475: 
  476:     Check whether iterations are left, and perform a single internal iteration
  477:     without returning the result.  Used in the C-style pattern do-while
  478:     pattern.  For an example, see `nditer`.
  479: 
  480:     Returns
  481:     -------
  482:     iternext : bool
  483:         Whether or not there are iterations left.
  484: 
  485:     """))
  486: 
  487: add_newdoc('numpy._core', 'nditer', ('remove_axis',
  488:     """
  489:     remove_axis(i, /)
  490: 
  491:     Removes axis `i` from the iterator. Requires that the flag "multi_index"
  492:     be enabled.
  493: 
  494:     """))
  495: 
  496: add_newdoc('numpy._core', 'nditer', ('remove_multi_index',
  497:     """
  498:     remove_multi_index()
  499: 
  500:     When the "multi_index" flag was specified, this removes it, allowing
  501:     the internal iteration structure to be optimized further.
  502: 
  503:     """))
  504: 
  505: add_newdoc('numpy._core', 'nditer', ('reset',
  506:     """
  507:     reset()
  508: 
  509:     Reset the iterator to its initial state.
  510: 
  511:     """))
  512: 
  513: add_newdoc('numpy._core', 'nested_iters',
  514:     """
  515:     nested_iters(op, axes, flags=None, op_flags=None, op_dtypes=None, \
  516:     order="K", casting="safe", buffersize=0)
  517: 
  518:     Create nditers for use in nested loops
  519: 
  520:     Create a tuple of `nditer` objects which iterate in nested loops over
  521:     different axes of the op argument. The first iterator is used in the
  522:     outermost loop, the last in the innermost loop. Advancing one will change
  523:     the subsequent iterators to point at its new element.
  524: 
  525:     Parameters
  526:     ----------
  527:     op : ndarray or sequence of array_like
  528:         The array(s) to iterate over.
  529: 
  530:     axes : list of list of int
  531:         Each item is used as an "op_axes" argument to an nditer
  532: 
  533:     flags, op_flags, op_dtypes, order, casting, buffersize (optional)
  534:         See `nditer` parameters of the same name
  535: 
  536:     Returns
  537:     -------
  538:     iters : tuple of nditer
  539:         An nditer for each item in `axes`, outermost first
  540: 
  541:     See Also
  542:     --------
  543:     nditer
  544: 
  545:     Examples
  546:     --------
  547: 
  548:     Basic usage. Note how y is the "flattened" version of
  549:     [a[:, 0, :], a[:, 1, 0], a[:, 2, :]] since we specified
  550:     the first iter's axes as [1]
  551: 
  552:     >>> import numpy as np
  553:     >>> a = np.arange(12).reshape(2, 3, 2)
  554:     >>> i, j = np.nested_iters(a, [[1], [0, 2]], flags=["multi_index"])
  555:     >>> for x in i:
  556:     ...      print(i.multi_index)
  557:     ...      for y in j:
  558:     ...          print('', j.multi_index, y)
  559:     (0,)
  560:      (0, 0) 0
  561:      (0, 1) 1
  562:      (1, 0) 6
  563:      (1, 1) 7
  564:     (1,)
  565:      (0, 0) 2
  566:      (0, 1) 3
  567:      (1, 0) 8
  568:      (1, 1) 9
  569:     (2,)
  570:      (0, 0) 4
  571:      (0, 1) 5
  572:      (1, 0) 10
  573:      (1, 1) 11
  574: 
  575:     """)
  576: 
  577: add_newdoc('numpy._core', 'nditer', ('close',
  578:     """
  579:     close()
  580: 
  581:     Resolve all writeback semantics in writeable operands.
  582: 
  583:     See Also
  584:     --------
  585: 
  586:     :ref:`nditer-context-manager`
  587: 
  588:     """))
  589: 
  590: 
  591: ###############################################################################
  592: #
  593: # broadcast
  594: #
  595: ###############################################################################
  596: 
  597: add_newdoc('numpy._core', 'broadcast',
  598:     """
  599:     Produce an object that mimics broadcasting.
  600: 
  601:     Parameters
  602:     ----------
  603:     in1, in2, ... : array_like
  604:         Input parameters.
  605: 
  606:     Returns
  607:     -------
  608:     b : broadcast object
  609:         Broadcast the input parameters against one another, and
  610:         return an object that encapsulates the result.
  611:         Amongst others, it has ``shape`` and ``nd`` properties, and
  612:         may be used as an iterator.
  613: 
  614:     See Also
  615:     --------
  616:     broadcast_arrays
  617:     broadcast_to
  618:     broadcast_shapes
  619: 
  620:     Examples
  621:     --------
  622: 
  623:     Manually adding two vectors, using broadcasting:
  624: 
  625:     >>> import numpy as np
  626:     >>> x = np.array([[1], [2], [3]])
  627:     >>> y = np.array([4, 5, 6])
  628:     >>> b = np.broadcast(x, y)
  629: 
  630:     >>> out = np.empty(b.shape)
  631:     >>> out.flat = [u+v for (u,v) in b]
  632:     >>> out
  633:     array([[5.,  6.,  7.],
  634:            [6.,  7.,  8.],
  635:            [7.,  8.,  9.]])
  636: 
  637:     Compare against built-in broadcasting:
  638: 
  639:     >>> x + y
  640:     array([[5, 6, 7],
  641:            [6, 7, 8],
  642:            [7, 8, 9]])
  643: 
  644:     """)
  645: 
  646: # attributes
  647: 
  648: add_newdoc('numpy._core', 'broadcast', ('index',
  649:     """
  650:     current index in broadcasted result
  651: 
  652:     Examples
  653:     --------
  654: 
  655:     >>> import numpy as np
  656:     >>> x = np.array([[1], [2], [3]])
  657:     >>> y = np.array([4, 5, 6])
  658:     >>> b = np.broadcast(x, y)
  659:     >>> b.index
  660:     0
  661:     >>> next(b), next(b), next(b)
  662:     ((1, 4), (1, 5), (1, 6))
  663:     >>> b.index
  664:     3
  665: 
  666:     """))
  667: 
  668: add_newdoc('numpy._core', 'broadcast', ('iters',
  669:     """
  670:     tuple of iterators along ``self``'s "components."
  671: 
  672:     Returns a tuple of `numpy.flatiter` objects, one for each "component"
  673:     of ``self``.
  674: 
  675:     See Also
  676:     --------
  677:     numpy.flatiter
  678: 
  679:     Examples
  680:     --------
  681: 
  682:     >>> import numpy as np
  683:     >>> x = np.array([1, 2, 3])
  684:     >>> y = np.array([[4], [5], [6]])
  685:     >>> b = np.broadcast(x, y)
  686:     >>> row, col = b.iters
  687:     >>> next(row), next(col)
  688:     (1, 4)
  689: 
  690:     """))
  691: 
  692: add_newdoc('numpy._core', 'broadcast', ('ndim',
  693:     """
  694:     Number of dimensions of broadcasted result. Alias for `nd`.
  695: 
  696:     Examples
  697:     --------
  698:     >>> import numpy as np
  699:     >>> x = np.array([1, 2, 3])
  700:     >>> y = np.array([[4], [5], [6]])
  701:     >>> b = np.broadcast(x, y)
  702:     >>> b.ndim
  703:     2
  704: 
  705:     """))
  706: 
  707: add_newdoc('numpy._core', 'broadcast', ('nd',
  708:     """
  709:     Number of dimensions of broadcasted result. For code intended for NumPy
  710:     1.12.0 and later the more consistent `ndim` is preferred.
  711: 
  712:     Examples
  713:     --------
  714:     >>> import numpy as np
  715:     >>> x = np.array([1, 2, 3])
  716:     >>> y = np.array([[4], [5], [6]])
  717:     >>> b = np.broadcast(x, y)
  718:     >>> b.nd
  719:     2
  720: 
  721:     """))
  722: 
  723: add_newdoc('numpy._core', 'broadcast', ('numiter',
  724:     """
  725:     Number of iterators possessed by the broadcasted result.
  726: 
  727:     Examples
  728:     --------
  729:     >>> import numpy as np
  730:     >>> x = np.array([1, 2, 3])
  731:     >>> y = np.array([[4], [5], [6]])
  732:     >>> b = np.broadcast(x, y)
  733:     >>> b.numiter
  734:     2
  735: 
  736:     """))
  737: 
  738: add_newdoc('numpy._core', 'broadcast', ('shape',
  739:     """
  740:     Shape of broadcasted result.
  741: 
  742:     Examples
  743:     --------
  744:     >>> import numpy as np
  745:     >>> x = np.array([1, 2, 3])
  746:     >>> y = np.array([[4], [5], [6]])
  747:     >>> b = np.broadcast(x, y)
  748:     >>> b.shape
  749:     (3, 3)
  750: 
  751:     """))
  752: 
  753: add_newdoc('numpy._core', 'broadcast', ('size',
  754:     """
  755:     Total size of broadcasted result.
  756: 
  757:     Examples
  758:     --------
  759:     >>> import numpy as np
  760:     >>> x = np.array([1, 2, 3])
  761:     >>> y = np.array([[4], [5], [6]])
  762:     >>> b = np.broadcast(x, y)
  763:     >>> b.size
  764:     9
  765: 
  766:     """))
  767: 
  768: add_newdoc('numpy._core', 'broadcast', ('reset',
  769:     """
  770:     reset()
  771: 
  772:     Reset the broadcasted result's iterator(s).
  773: 
  774:     Parameters
  775:     ----------
  776:     None
  777: 
  778:     Returns
  779:     -------
  780:     None
  781: 
  782:     Examples
  783:     --------
  784:     >>> import numpy as np
  785:     >>> x = np.array([1, 2, 3])
  786:     >>> y = np.array([[4], [5], [6]])
  787:     >>> b = np.broadcast(x, y)
  788:     >>> b.index
  789:     0
  790:     >>> next(b), next(b), next(b)
  791:     ((1, 4), (2, 4), (3, 4))
  792:     >>> b.index
  793:     3
  794:     >>> b.reset()
  795:     >>> b.index
  796:     0
  797: 
  798:     """))
  799: 
  800: ###############################################################################
  801: #
  802: # numpy functions
  803: #
  804: ###############################################################################
  805: 
  806: add_newdoc('numpy._core.multiarray', 'array',
  807:     """
  808:     array(object, dtype=None, *, copy=True, order='K', subok=False, ndmin=0,
  809:           like=None)
  810: 
  811:     Create an array.
  812: 
  813:     Parameters
  814:     ----------
  815:     object : array_like
  816:         An array, any object exposing the array interface, an object whose
  817:         ``__array__`` method returns an array, or any (nested) sequence.
  818:         If object is a scalar, a 0-dimensional array containing object is
  819:         returned.
  820:     dtype : data-type, optional
  821:         The desired data-type for the array. If not given, NumPy will try to use
  822:         a default ``dtype`` that can represent the values (by applying promotion
  823:         rules when necessary.)
  824:     copy : bool, optional
  825:         If ``True`` (default), then the array data is copied. If ``None``,
  826:         a copy will only be made if ``__array__`` returns a copy, if obj is
  827:         a nested sequence, or if a copy is needed to satisfy any of the other
  828:         requirements (``dtype``, ``order``, etc.). Note that any copy of
  829:         the data is shallow, i.e., for arrays with object dtype, the new
  830:         array will point to the same objects. See Examples for `ndarray.copy`.
  831:         For ``False`` it raises a ``ValueError`` if a copy cannot be avoided.
  832:         Default: ``True``.
  833:     order : {'K', 'A', 'C', 'F'}, optional
  834:         Specify the memory layout of the array. If object is not an array, the
  835:         newly created array will be in C order (row major) unless 'F' is
  836:         specified, in which case it will be in Fortran order (column major).
  837:         If object is an array the following holds.
  838: 
  839:         ===== ========= ===================================================
  840:         order  no copy                     copy=True
  841:         ===== ========= ===================================================
  842:         'K'   unchanged F & C order preserved, otherwise most similar order
  843:         'A'   unchanged F order if input is F and not C, otherwise C order
  844:         'C'   C order   C order
  845:         'F'   F order   F order
  846:         ===== ========= ===================================================
  847: 
  848:         When ``copy=None`` and a copy is made for other reasons, the result is
  849:         the same as if ``copy=True``, with some exceptions for 'A', see the
  850:         Notes section. The default order is 'K'.
  851:     subok : bool, optional
  852:         If True, then sub-classes will be passed-through, otherwise
  853:         the returned array will be forced to be a base-class array (default).
  854:     ndmin : int, optional
  855:         Specifies the minimum number of dimensions that the resulting
  856:         array should have.  Ones will be prepended to the shape as
  857:         needed to meet this requirement.
  858:     ${ARRAY_FUNCTION_LIKE}
  859: 
  860:         .. versionadded:: 1.20.0
  861: 
  862:     Returns
  863:     -------
  864:     out : ndarray
  865:         An array object satisfying the specified requirements.
  866: 
  867:     See Also
  868:     --------
  869:     empty_like : Return an empty array with shape and type of input.
  870:     ones_like : Return an array of ones with shape and type of input.
  871:     zeros_like : Return an array of zeros with shape and type of input.
  872:     full_like : Return a new array with shape of input filled with value.
  873:     empty : Return a new uninitialized array.
  874:     ones : Return a new array setting values to one.
  875:     zeros : Return a new array setting values to zero.
  876:     full : Return a new array of given shape filled with value.
  877:     copy: Return an array copy of the given object.
  878: 
  879: 
  880:     Notes
  881:     -----
  882:     When order is 'A' and ``object`` is an array in neither 'C' nor 'F' order,
  883:     and a copy is forced by a change in dtype, then the order of the result is
  884:     not necessarily 'C' as expected. This is likely a bug.
  885: 
  886:     Examples
  887:     --------
  888:     >>> import numpy as np
  889:     >>> np.array([1, 2, 3])
  890:     array([1, 2, 3])
  891: 
  892:     Upcasting:
  893: 
  894:     >>> np.array([1, 2, 3.0])
  895:     array([ 1.,  2.,  3.])
  896: 
  897:     More than one dimension:
  898: 
  899:     >>> np.array([[1, 2], [3, 4]])
  900:     array([[1, 2],
  901:            [3, 4]])
  902: 
  903:     Minimum dimensions 2:
  904: 
  905:     >>> np.array([1, 2, 3], ndmin=2)
  906:     array([[1, 2, 3]])
  907: 
  908:     Type provided:
  909: 
  910:     >>> np.array([1, 2, 3], dtype=complex)
  911:     array([ 1.+0.j,  2.+0.j,  3.+0.j])
  912: 
  913:     Data-type consisting of more than one element:
  914: 
  915:     >>> x = np.array([(1,2),(3,4)],dtype=[('a','<i4'),('b','<i4')])
  916:     >>> x['a']
  917:     array([1, 3], dtype=int32)
  918: 
  919:     Creating an array from sub-classes:
  920: 
  921:     >>> np.array(np.asmatrix('1 2; 3 4'))
  922:     array([[1, 2],
  923:            [3, 4]])
  924: 
  925:     >>> np.array(np.asmatrix('1 2; 3 4'), subok=True)
  926:     matrix([[1, 2],
  927:             [3, 4]])
  928: 
  929:     """)
  930: 
  931: add_newdoc('numpy._core.multiarray', 'asarray',
  932:     """
  933:     asarray(a, dtype=None, order=None, *, device=None, copy=None, like=None)
  934: 
  935:     Convert the input to an array.
  936: 
  937:     Parameters
  938:     ----------
  939:     a : array_like
  940:         Input data, in any form that can be converted to an array.  This
  941:         includes lists, lists of tuples, tuples, tuples of tuples, tuples
  942:         of lists and ndarrays.
  943:     dtype : data-type, optional
  944:         By default, the data-type is inferred from the input data.
  945:     order : {'C', 'F', 'A', 'K'}, optional
  946:         Memory layout.  'A' and 'K' depend on the order of input array a.
  947:         'C' row-major (C-style),
  948:         'F' column-major (Fortran-style) memory representation.
  949:         'A' (any) means 'F' if `a` is Fortran contiguous, 'C' otherwise
  950:         'K' (keep) preserve input order
  951:         Defaults to 'K'.
  952:     device : str, optional
  953:         The device on which to place the created array. Default: ``None``.
  954:         For Array-API interoperability only, so must be ``"cpu"`` if passed.
  955: 
  956:         .. versionadded:: 2.0.0
  957:     copy : bool, optional
  958:         If ``True``, then the object is copied. If ``None`` then the object is
  959:         copied only if needed, i.e. if ``__array__`` returns a copy, if obj
  960:         is a nested sequence, or if a copy is needed to satisfy any of
  961:         the other requirements (``dtype``, ``order``, etc.).
  962:         For ``False`` it raises a ``ValueError`` if a copy cannot be avoided.
  963:         Default: ``None``.
  964: 
  965:         .. versionadded:: 2.0.0
  966:     ${ARRAY_FUNCTION_LIKE}
  967: 
  968:         .. versionadded:: 1.20.0
  969: 
  970:     Returns
  971:     -------
  972:     out : ndarray
  973:         Array interpretation of ``a``.  No copy is performed if the input
  974:         is already an ndarray with matching dtype and order.  If ``a`` is a
  975:         subclass of ndarray, a base class ndarray is returned.
  976: 
  977:     See Also
  978:     --------
  979:     asanyarray : Similar function which passes through subclasses.
  980:     ascontiguousarray : Convert input to a contiguous array.
  981:     asfortranarray : Convert input to an ndarray with column-major
  982:                      memory order.
  983:     asarray_chkfinite : Similar function which checks input for NaNs and Infs.
  984:     fromiter : Create an array from an iterator.
  985:     fromfunction : Construct an array by executing a function on grid
  986:                    positions.
  987: 
  988:     Examples
  989:     --------
  990:     Convert a list into an array:
  991: 
  992:     >>> a = [1, 2]
  993:     >>> import numpy as np
  994:     >>> np.asarray(a)
  995:     array([1, 2])
  996: 
  997:     Existing arrays are not copied:
  998: 
  999:     >>> a = np.array([1, 2])
 1000:     >>> np.asarray(a) is a
 1001:     True
 1002: 
 1003:     If `dtype` is set, array is copied only if dtype does not match:
 1004: 
 1005:     >>> a = np.array([1, 2], dtype=np.float32)
 1006:     >>> np.shares_memory(np.asarray(a, dtype=np.float32), a)
 1007:     True
 1008:     >>> np.shares_memory(np.asarray(a, dtype=np.float64), a)
 1009:     False
 1010: 
 1011:     Contrary to `asanyarray`, ndarray subclasses are not passed through:
 1012: 
 1013:     >>> issubclass(np.recarray, np.ndarray)
 1014:     True
 1015:     >>> a = np.array([(1., 2), (3., 4)], dtype='f4,i4').view(np.recarray)
 1016:     >>> np.asarray(a) is a
 1017:     False
 1018:     >>> np.asanyarray(a) is a
 1019:     True
 1020: 
 1021:     """)
 1022: 
 1023: add_newdoc('numpy._core.multiarray', 'asanyarray',
 1024:     """
 1025:     asanyarray(a, dtype=None, order=None, *, device=None, copy=None, like=None)
 1026: 
 1027:     Convert the input to an ndarray, but pass ndarray subclasses through.
 1028: 
 1029:     Parameters
 1030:     ----------
 1031:     a : array_like
 1032:         Input data, in any form that can be converted to an array.  This
 1033:         includes scalars, lists, lists of tuples, tuples, tuples of tuples,
 1034:         tuples of lists, and ndarrays.
 1035:     dtype : data-type, optional
 1036:         By default, the data-type is inferred from the input data.
 1037:     order : {'C', 'F', 'A', 'K'}, optional
 1038:         Memory layout.  'A' and 'K' depend on the order of input array a.
 1039:         'C' row-major (C-style),
 1040:         'F' column-major (Fortran-style) memory representation.
 1041:         'A' (any) means 'F' if `a` is Fortran contiguous, 'C' otherwise
 1042:         'K' (keep) preserve input order
 1043:         Defaults to 'C'.
 1044:     device : str, optional
 1045:         The device on which to place the created array. Default: ``None``.
 1046:         For Array-API interoperability only, so must be ``"cpu"`` if passed.
 1047: 
 1048:         .. versionadded:: 2.1.0
 1049: 
 1050:     copy : bool, optional
 1051:         If ``True``, then the object is copied. If ``None`` then the object is
 1052:         copied only if needed, i.e. if ``__array__`` returns a copy, if obj
 1053:         is a nested sequence, or if a copy is needed to satisfy any of
 1054:         the other requirements (``dtype``, ``order``, etc.).
 1055:         For ``False`` it raises a ``ValueError`` if a copy cannot be avoided.
 1056:         Default: ``None``.
 1057: 
 1058:         .. versionadded:: 2.1.0
 1059: 
 1060:     ${ARRAY_FUNCTION_LIKE}
 1061: 
 1062:         .. versionadded:: 1.20.0
 1063: 
 1064:     Returns
 1065:     -------
 1066:     out : ndarray or an ndarray subclass
 1067:         Array interpretation of `a`.  If `a` is an ndarray or a subclass
 1068:         of ndarray, it is returned as-is and no copy is performed.
 1069: 
 1070:     See Also
 1071:     --------
 1072:     asarray : Similar function which always returns ndarrays.
 1073:     ascontiguousarray : Convert input to a contiguous array.
 1074:     asfortranarray : Convert input to an ndarray with column-major
 1075:                      memory order.
 1076:     asarray_chkfinite : Similar function which checks input for NaNs and
 1077:                         Infs.
 1078:     fromiter : Create an array from an iterator.
 1079:     fromfunction : Construct an array by executing a function on grid
 1080:                    positions.
 1081: 
 1082:     Examples
 1083:     --------
 1084:     Convert a list into an array:
 1085: 
 1086:     >>> a = [1, 2]
 1087:     >>> import numpy as np
 1088:     >>> np.asanyarray(a)
 1089:     array([1, 2])
 1090: 
 1091:     Instances of `ndarray` subclasses are passed through as-is:
 1092: 
 1093:     >>> a = np.array([(1., 2), (3., 4)], dtype='f4,i4').view(np.recarray)
 1094:     >>> np.asanyarray(a) is a
 1095:     True
 1096: 
 1097:     """)
 1098: 
 1099: add_newdoc('numpy._core.multiarray', 'ascontiguousarray',
 1100:     """
 1101:     ascontiguousarray(a, dtype=None, *, like=None)
 1102: 
 1103:     Return a contiguous array (ndim >= 1) in memory (C order).
 1104: 
 1105:     Parameters
 1106:     ----------
 1107:     a : array_like
 1108:         Input array.
 1109:     dtype : str or dtype object, optional
 1110:         Data-type of returned array.
 1111:     ${ARRAY_FUNCTION_LIKE}
 1112: 
 1113:         .. versionadded:: 1.20.0
 1114: 
 1115:     Returns
 1116:     -------
 1117:     out : ndarray
 1118:         Contiguous array of same shape and content as `a`, with type `dtype`
 1119:         if specified.
 1120: 
 1121:     See Also
 1122:     --------
 1123:     asfortranarray : Convert input to an ndarray with column-major
 1124:                      memory order.
 1125:     require : Return an ndarray that satisfies requirements.
 1126:     ndarray.flags : Information about the memory layout of the array.
 1127: 
 1128:     Examples
 1129:     --------
 1130:     Starting with a Fortran-contiguous array:
 1131: 
 1132:     >>> import numpy as np
 1133:     >>> x = np.ones((2, 3), order='F')
 1134:     >>> x.flags['F_CONTIGUOUS']
 1135:     True
 1136: 
 1137:     Calling ``ascontiguousarray`` makes a C-contiguous copy:
 1138: 
 1139:     >>> y = np.ascontiguousarray(x)
 1140:     >>> y.flags['C_CONTIGUOUS']
 1141:     True
 1142:     >>> np.may_share_memory(x, y)
 1143:     False
 1144: 
 1145:     Now, starting with a C-contiguous array:
 1146: 
 1147:     >>> x = np.ones((2, 3), order='C')
 1148:     >>> x.flags['C_CONTIGUOUS']
 1149:     True
 1150: 
 1151:     Then, calling ``ascontiguousarray`` returns the same object:
 1152: 
 1153:     >>> y = np.ascontiguousarray(x)
 1154:     >>> x is y
 1155:     True
 1156: 
 1157:     Note: This function returns an array with at least one-dimension (1-d)
 1158:     so it will not preserve 0-d arrays.
 1159: 
 1160:     """)
 1161: 
 1162: add_newdoc('numpy._core.multiarray', 'asfortranarray',
 1163:     """
 1164:     asfortranarray(a, dtype=None, *, like=None)
 1165: 
 1166:     Return an array (ndim >= 1) laid out in Fortran order in memory.
 1167: 
 1168:     Parameters
 1169:     ----------
 1170:     a : array_like
 1171:         Input array.
 1172:     dtype : str or dtype object, optional
 1173:         By default, the data-type is inferred from the input data.
 1174:     ${ARRAY_FUNCTION_LIKE}
 1175: 
 1176:         .. versionadded:: 1.20.0
 1177: 
 1178:     Returns
 1179:     -------
 1180:     out : ndarray
 1181:         The input `a` in Fortran, or column-major, order.
 1182: 
 1183:     See Also
 1184:     --------
 1185:     ascontiguousarray : Convert input to a contiguous (C order) array.
 1186:     asanyarray : Convert input to an ndarray with either row or
 1187:         column-major memory order.
 1188:     require : Return an ndarray that satisfies requirements.
 1189:     ndarray.flags : Information about the memory layout of the array.
 1190: 
 1191:     Examples
 1192:     --------
 1193:     Starting with a C-contiguous array:
 1194: 
 1195:     >>> import numpy as np
 1196:     >>> x = np.ones((2, 3), order='C')
 1197:     >>> x.flags['C_CONTIGUOUS']
 1198:     True
 1199: 
 1200:     Calling ``asfortranarray`` makes a Fortran-contiguous copy:
 1201: 
 1202:     >>> y = np.asfortranarray(x)
 1203:     >>> y.flags['F_CONTIGUOUS']
 1204:     True
 1205:     >>> np.may_share_memory(x, y)
 1206:     False
 1207: 
 1208:     Now, starting with a Fortran-contiguous array:
 1209: 
 1210:     >>> x = np.ones((2, 3), order='F')
 1211:     >>> x.flags['F_CONTIGUOUS']
 1212:     True
 1213: 
 1214:     Then, calling ``asfortranarray`` returns the same object:
 1215: 
 1216:     >>> y = np.asfortranarray(x)
 1217:     >>> x is y
 1218:     True
 1219: 
 1220:     Note: This function returns an array with at least one-dimension (1-d)
 1221:     so it will not preserve 0-d arrays.
 1222: 
 1223:     """)
 1224: 
 1225: add_newdoc('numpy._core.multiarray', 'empty',
 1226:     """
 1227:     empty(shape, dtype=float, order='C', *, device=None, like=None)
 1228: 
 1229:     Return a new array of given shape and type, without initializing entries.
 1230: 
 1231:     Parameters
 1232:     ----------
 1233:     shape : int or tuple of int
 1234:         Shape of the empty array, e.g., ``(2, 3)`` or ``2``.
 1235:     dtype : data-type, optional
 1236:         Desired output data-type for the array, e.g, `numpy.int8`. Default is
 1237:         `numpy.float64`.
 1238:     order : {'C', 'F'}, optional, default: 'C'
 1239:         Whether to store multi-dimensional data in row-major
 1240:         (C-style) or column-major (Fortran-style) order in
 1241:         memory.
 1242:     device : str, optional
 1243:         The device on which to place the created array. Default: ``None``.
 1244:         For Array-API interoperability only, so must be ``"cpu"`` if passed.
 1245: 
 1246:         .. versionadded:: 2.0.0
 1247:     ${ARRAY_FUNCTION_LIKE}
 1248: 
 1249:         .. versionadded:: 1.20.0
 1250: 
 1251:     Returns
 1252:     -------
 1253:     out : ndarray
 1254:         Array of uninitialized (arbitrary) data of the given shape, dtype, and
 1255:         order.  Object arrays will be initialized to None.
 1256: 
 1257:     See Also
 1258:     --------
 1259:     empty_like : Return an empty array with shape and type of input.
 1260:     ones : Return a new array setting values to one.
 1261:     zeros : Return a new array setting values to zero.
 1262:     full : Return a new array of given shape filled with value.
 1263: 
 1264:     Notes
 1265:     -----
 1266:     Unlike other array creation functions (e.g. `zeros`, `ones`, `full`),
 1267:     `empty` does not initialize the values of the array, and may therefore be
 1268:     marginally faster. However, the values stored in the newly allocated array
 1269:     are arbitrary. For reproducible behavior, be sure to set each element of
 1270:     the array before reading.
 1271: 
 1272:     Examples
 1273:     --------
 1274:     >>> import numpy as np
 1275:     >>> np.empty([2, 2])
 1276:     array([[ -9.74499359e+001,   6.69583040e-309],
 1277:            [  2.13182611e-314,   3.06959433e-309]])         #uninitialized
 1278: 
 1279:     >>> np.empty([2, 2], dtype=int)
 1280:     array([[-1073741821, -1067949133],
 1281:            [  496041986,    19249760]])                     #uninitialized
 1282: 
 1283:     """)
 1284: 
 1285: add_newdoc('numpy._core.multiarray', 'scalar',
 1286:     """
 1287:     scalar(dtype, obj)
 1288: 
 1289:     Return a new scalar array of the given type initialized with obj.
 1290: 
 1291:     This function is meant mainly for pickle support. `dtype` must be a
 1292:     valid data-type descriptor. If `dtype` corresponds to an object
 1293:     descriptor, then `obj` can be any object, otherwise `obj` must be a
 1294:     string. If `obj` is not given, it will be interpreted as None for object
 1295:     type and as zeros for all other types.
 1296: 
 1297:     """)
 1298: 
 1299: add_newdoc('numpy._core.multiarray', 'zeros',
 1300:     """
 1301:     zeros(shape, dtype=float, order='C', *, like=None)
 1302: 
 1303:     Return a new array of given shape and type, filled with zeros.
 1304: 
 1305:     Parameters
 1306:     ----------
 1307:     shape : int or tuple of ints
 1308:         Shape of the new array, e.g., ``(2, 3)`` or ``2``.
 1309:     dtype : data-type, optional
 1310:         The desired data-type for the array, e.g., `numpy.int8`.  Default is
 1311:         `numpy.float64`.
 1312:     order : {'C', 'F'}, optional, default: 'C'
 1313:         Whether to store multi-dimensional data in row-major
 1314:         (C-style) or column-major (Fortran-style) order in
 1315:         memory.
 1316:     ${ARRAY_FUNCTION_LIKE}
 1317: 
 1318:         .. versionadded:: 1.20.0
 1319: 
 1320:     Returns
 1321:     -------
 1322:     out : ndarray
 1323:         Array of zeros with the given shape, dtype, and order.
 1324: 
 1325:     See Also
 1326:     --------
 1327:     zeros_like : Return an array of zeros with shape and type of input.
 1328:     empty : Return a new uninitialized array.
 1329:     ones : Return a new array setting values to one.
 1330:     full : Return a new array of given shape filled with value.
 1331: 
 1332:     Examples
 1333:     --------
 1334:     >>> import numpy as np
 1335:     >>> np.zeros(5)
 1336:     array([ 0.,  0.,  0.,  0.,  0.])
 1337: 
 1338:     >>> np.zeros((5,), dtype=int)
 1339:     array([0, 0, 0, 0, 0])
 1340: 
 1341:     >>> np.zeros((2, 1))
 1342:     array([[ 0.],
 1343:            [ 0.]])
 1344: 
 1345:     >>> s = (2,2)
 1346:     >>> np.zeros(s)
 1347:     array([[ 0.,  0.],
 1348:            [ 0.,  0.]])
 1349: 
 1350:     >>> np.zeros((2,), dtype=[('x', 'i4'), ('y', 'i4')]) # custom dtype
 1351:     array([(0, 0), (0, 0)],
 1352:           dtype=[('x', '<i4'), ('y', '<i4')])
 1353: 
 1354:     """)
 1355: 
 1356: add_newdoc('numpy._core.multiarray', 'set_typeDict',
 1357:     """set_typeDict(dict)
 1358: 
 1359:     Set the internal dictionary that can look up an array type using a
 1360:     registered code.
 1361: 
 1362:     """)
 1363: 
 1364: add_newdoc('numpy._core.multiarray', 'fromstring',
 1365:     """
 1366:     fromstring(string, dtype=float, count=-1, *, sep, like=None)
 1367: 
 1368:     A new 1-D array initialized from text data in a string.
 1369: 
 1370:     Parameters
 1371:     ----------
 1372:     string : str
 1373:         A string containing the data.
 1374:     dtype : data-type, optional
 1375:         The data type of the array; default: float.  For binary input data,
 1376:         the data must be in exactly this format. Most builtin numeric types are
 1377:         supported and extension types may be supported.
 1378:     count : int, optional
 1379:         Read this number of `dtype` elements from the data.  If this is
 1380:         negative (the default), the count will be determined from the
 1381:         length of the data.
 1382:     sep : str, optional
 1383:         The string separating numbers in the data; extra whitespace between
 1384:         elements is also ignored.
 1385: 
 1386:         .. deprecated:: 1.14
 1387:             Passing ``sep=''``, the default, is deprecated since it will
 1388:             trigger the deprecated binary mode of this function. This mode
 1389:             interprets `string` as binary bytes, rather than ASCII text with
 1390:             decimal numbers, an operation which is better spelt
 1391:             ``frombuffer(string, dtype, count)``. If `string` contains unicode
 1392:             text, the binary mode of `fromstring` will first encode it into
 1393:             bytes using utf-8, which will not produce sane results.
 1394: 
 1395:     ${ARRAY_FUNCTION_LIKE}
 1396: 
 1397:         .. versionadded:: 1.20.0
 1398: 
 1399:     Returns
 1400:     -------
 1401:     arr : ndarray
 1402:         The constructed array.
 1403: 
 1404:     Raises
 1405:     ------
 1406:     ValueError
 1407:         If the string is not the correct size to satisfy the requested
 1408:         `dtype` and `count`.
 1409: 
 1410:     See Also
 1411:     --------
 1412:     frombuffer, fromfile, fromiter
 1413: 
 1414:     Examples
 1415:     --------
 1416:     >>> import numpy as np
 1417:     >>> np.fromstring('1 2', dtype=int, sep=' ')
 1418:     array([1, 2])
 1419:     >>> np.fromstring('1, 2', dtype=int, sep=',')
 1420:     array([1, 2])
 1421: 
 1422:     """)
 1423: 
 1424: add_newdoc('numpy._core.multiarray', 'compare_chararrays',
 1425:     """
 1426:     compare_chararrays(a1, a2, cmp, rstrip)
 1427: 
 1428:     Performs element-wise comparison of two string arrays using the
 1429:     comparison operator specified by `cmp`.
 1430: 
 1431:     Parameters
 1432:     ----------
 1433:     a1, a2 : array_like
 1434:         Arrays to be compared.
 1435:     cmp : {"<", "<=", "==", ">=", ">", "!="}
 1436:         Type of comparison.
 1437:     rstrip : Boolean
 1438:         If True, the spaces at the end of Strings are removed before the comparison.
 1439: 
 1440:     Returns
 1441:     -------
 1442:     out : ndarray
 1443:         The output array of type Boolean with the same shape as a and b.
 1444: 
 1445:     Raises
 1446:     ------
 1447:     ValueError
 1448:         If `cmp` is not valid.
 1449:     TypeError
 1450:         If at least one of `a` or `b` is a non-string array
 1451: 
 1452:     Examples
 1453:     --------
 1454:     >>> import numpy as np
 1455:     >>> a = np.array(["a", "b", "cde"])
 1456:     >>> b = np.array(["a", "a", "dec"])
 1457:     >>> np.char.compare_chararrays(a, b, ">", True)
 1458:     array([False,  True, False])
 1459: 
 1460:     """)
 1461: 
 1462: add_newdoc('numpy._core.multiarray', 'fromiter',
 1463:     """
 1464:     fromiter(iter, dtype, count=-1, *, like=None)
 1465: 
 1466:     Create a new 1-dimensional array from an iterable object.
 1467: 
 1468:     Parameters
 1469:     ----------
 1470:     iter : iterable object
 1471:         An iterable object providing data for the array.
 1472:     dtype : data-type
 1473:         The data-type of the returned array.
 1474: 
 1475:         .. versionchanged:: 1.23
 1476:             Object and subarray dtypes are now supported (note that the final
 1477:             result is not 1-D for a subarray dtype).
 1478: 
 1479:     count : int, optional
 1480:         The number of items to read from *iterable*.  The default is -1,
 1481:         which means all data is read.
 1482:     ${ARRAY_FUNCTION_LIKE}
 1483: 
 1484:         .. versionadded:: 1.20.0
 1485: 
 1486:     Returns
 1487:     -------
 1488:     out : ndarray
 1489:         The output array.
 1490: 
 1491:     Notes
 1492:     -----
 1493:     Specify `count` to improve performance.  It allows ``fromiter`` to
 1494:     pre-allocate the output array, instead of resizing it on demand.
 1495: 
 1496:     Examples
 1497:     --------
 1498:     >>> import numpy as np
 1499:     >>> iterable = (x*x for x in range(5))
 1500:     >>> np.fromiter(iterable, float)
 1501:     array([  0.,   1.,   4.,   9.,  16.])
 1502: 
 1503:     A carefully constructed subarray dtype will lead to higher dimensional
 1504:     results:
 1505: 
 1506:     >>> iterable = ((x+1, x+2) for x in range(5))
 1507:     >>> np.fromiter(iterable, dtype=np.dtype((int, 2)))
 1508:     array([[1, 2],
 1509:            [2, 3],
 1510:            [3, 4],
 1511:            [4, 5],
 1512:            [5, 6]])
 1513: 
 1514: 
 1515:     """)
 1516: 
 1517: add_newdoc('numpy._core.multiarray', 'fromfile',
 1518:     """
 1519:     fromfile(file, dtype=float, count=-1, sep='', offset=0, *, like=None)
 1520: 
 1521:     Construct an array from data in a text or binary file.
 1522: 
 1523:     A highly efficient way of reading binary data with a known data-type,
 1524:     as well as parsing simply formatted text files.  Data written using the
 1525:     `tofile` method can be read using this function.
 1526: 
 1527:     Parameters
 1528:     ----------
 1529:     file : file or str or Path
 1530:         Open file object or filename.
 1531:     dtype : data-type
 1532:         Data type of the returned array.
 1533:         For binary files, it is used to determine the size and byte-order
 1534:         of the items in the file.
 1535:         Most builtin numeric types are supported and extension types may be supported.
 1536:     count : int
 1537:         Number of items to read. ``-1`` means all items (i.e., the complete
 1538:         file).
 1539:     sep : str
 1540:         Separator between items if file is a text file.
 1541:         Empty ("") separator means the file should be treated as binary.
 1542:         Spaces (" ") in the separator match zero or more whitespace characters.
 1543:         A separator consisting only of spaces must match at least one
 1544:         whitespace.
 1545:     offset : int
 1546:         The offset (in bytes) from the file's current position. Defaults to 0.
 1547:         Only permitted for binary files.
 1548:     ${ARRAY_FUNCTION_LIKE}
 1549: 
 1550:         .. versionadded:: 1.20.0
 1551: 
 1552:     See also
 1553:     --------
 1554:     load, save
 1555:     ndarray.tofile
 1556:     loadtxt : More flexible way of loading data from a text file.
 1557: 
 1558:     Notes
 1559:     -----
 1560:     Do not rely on the combination of `tofile` and `fromfile` for
 1561:     data storage, as the binary files generated are not platform
 1562:     independent.  In particular, no byte-order or data-type information is
 1563:     saved.  Data can be stored in the platform independent ``.npy`` format
 1564:     using `save` and `load` instead.
 1565: 
 1566:     Examples
 1567:     --------
 1568:     Construct an ndarray:
 1569: 
 1570:     >>> import numpy as np
 1571:     >>> dt = np.dtype([('time', [('min', np.int64), ('sec', np.int64)]),
 1572:     ...                ('temp', float)])
 1573:     >>> x = np.zeros((1,), dtype=dt)
 1574:     >>> x['time']['min'] = 10; x['temp'] = 98.25
 1575:     >>> x
 1576:     array([((10, 0), 98.25)],
 1577:           dtype=[('time', [('min', '<i8'), ('sec', '<i8')]), ('temp', '<f8')])
 1578: 
 1579:     Save the raw data to disk:
 1580: 
 1581:     >>> import tempfile
 1582:     >>> fname = tempfile.mkstemp()[1]
 1583:     >>> x.tofile(fname)
 1584: 
 1585:     Read the raw data from disk:
 1586: 
 1587:     >>> np.fromfile(fname, dtype=dt)
 1588:     array([((10, 0), 98.25)],
 1589:           dtype=[('time', [('min', '<i8'), ('sec', '<i8')]), ('temp', '<f8')])
 1590: 
 1591:     The recommended way to store and load data:
 1592: 
 1593:     >>> np.save(fname, x)
 1594:     >>> np.load(fname + '.npy')
 1595:     array([((10, 0), 98.25)],
 1596:           dtype=[('time', [('min', '<i8'), ('sec', '<i8')]), ('temp', '<f8')])
 1597: 
 1598:     """)
 1599: 
 1600: add_newdoc('numpy._core.multiarray', 'frombuffer',
 1601:     """
 1602:     frombuffer(buffer, dtype=float, count=-1, offset=0, *, like=None)
 1603: 
 1604:     Interpret a buffer as a 1-dimensional array.
 1605: 
 1606:     Parameters
 1607:     ----------
 1608:     buffer : buffer_like
 1609:         An object that exposes the buffer interface.
 1610:     dtype : data-type, optional
 1611:         Data-type of the returned array; default: float.
 1612:     count : int, optional
 1613:         Number of items to read. ``-1`` means all data in the buffer.
 1614:     offset : int, optional
 1615:         Start reading the buffer from this offset (in bytes); default: 0.
 1616:     ${ARRAY_FUNCTION_LIKE}
 1617: 
 1618:         .. versionadded:: 1.20.0
 1619: 
 1620:     Returns
 1621:     -------
 1622:     out : ndarray
 1623: 
 1624:     See also
 1625:     --------
 1626:     ndarray.tobytes
 1627:         Inverse of this operation, construct Python bytes from the raw data
 1628:         bytes in the array.
 1629: 
 1630:     Notes
 1631:     -----
 1632:     If the buffer has data that is not in machine byte-order, this should
 1633:     be specified as part of the data-type, e.g.::
 1634: 
 1635:       >>> dt = np.dtype(int)
 1636:       >>> dt = dt.newbyteorder('>')
 1637:       >>> np.frombuffer(buf, dtype=dt) # doctest: +SKIP
 1638: 
 1639:     The data of the resulting array will not be byteswapped, but will be
 1640:     interpreted correctly.
 1641: 
 1642:     This function creates a view into the original object.  This should be safe
 1643:     in general, but it may make sense to copy the result when the original
 1644:     object is mutable or untrusted.
 1645: 
 1646:     Examples
 1647:     --------
 1648:     >>> import numpy as np
 1649:     >>> s = b'hello world'
 1650:     >>> np.frombuffer(s, dtype='S1', count=5, offset=6)
 1651:     array([b'w', b'o', b'r', b'l', b'd'], dtype='|S1')
 1652: 
 1653:     >>> np.frombuffer(b'\\x01\\x02', dtype=np.uint8)
 1654:     array([1, 2], dtype=uint8)
 1655:     >>> np.frombuffer(b'\\x01\\x02\\x03\\x04\\x05', dtype=np.uint8, count=3)
 1656:     array([1, 2, 3], dtype=uint8)
 1657: 
 1658:     """)
 1659: 
 1660: add_newdoc('numpy._core.multiarray', 'from_dlpack',
 1661:     """
 1662:     from_dlpack(x, /, *, device=None, copy=None)
 1663: 
 1664:     Create a NumPy array from an object implementing the ``__dlpack__``
 1665:     protocol. Generally, the returned NumPy array is a view of the input
 1666:     object. See [1]_ and [2]_ for more details.
 1667: 
 1668:     Parameters
 1669:     ----------
 1670:     x : object
 1671:         A Python object that implements the ``__dlpack__`` and
 1672:         ``__dlpack_device__`` methods.
 1673:     device : device, optional
 1674:         Device on which to place the created array. Default: ``None``.
 1675:         Must be ``"cpu"`` if passed which may allow importing an array
 1676:         that is not already CPU available.
 1677:     copy : bool, optional
 1678:         Boolean indicating whether or not to copy the input. If ``True``,
 1679:         the copy will be made. If ``False``, the function will never copy,
 1680:         and will raise ``BufferError`` in case a copy is deemed necessary.
 1681:         Passing it requests a copy from the exporter who may or may not
 1682:         implement the capability.
 1683:         If ``None``, the function will reuse the existing memory buffer if
 1684:         possible and copy otherwise. Default: ``None``.
 1685: 
 1686: 
 1687:     Returns
 1688:     -------
 1689:     out : ndarray
 1690: 
 1691:     References
 1692:     ----------
 1693:     .. [1] Array API documentation,
 1694:        https://data-apis.org/array-api/latest/design_topics/data_interchange.html#syntax-for-data-interchange-with-dlpack
 1695: 
 1696:     .. [2] Python specification for DLPack,
 1697:        https://dmlc.github.io/dlpack/latest/python_spec.html
 1698: 
 1699:     Examples
 1700:     --------
 1701:     >>> import torch  # doctest: +SKIP
 1702:     >>> x = torch.arange(10)  # doctest: +SKIP
 1703:     >>> # create a view of the torch tensor "x" in NumPy
 1704:     >>> y = np.from_dlpack(x)  # doctest: +SKIP
 1705:     """)
 1706: 
 1707: add_newdoc('numpy._core.multiarray', 'correlate',
 1708:     """cross_correlate(a,v, mode=0)""")
 1709: 
 1710: add_newdoc('numpy._core.multiarray', 'arange',
 1711:     """
 1712:     arange([start,] stop[, step,], dtype=None, *, device=None, like=None)
 1713: 
 1714:     Return evenly spaced values within a given interval.
 1715: 
 1716:     ``arange`` can be called with a varying number of positional arguments:
 1717: 
 1718:     * ``arange(stop)``: Values are generated within the half-open interval
 1719:       ``[0, stop)`` (in other words, the interval including `start` but
 1720:       excluding `stop`).
 1721:     * ``arange(start, stop)``: Values are generated within the half-open
 1722:       interval ``[start, stop)``.
 1723:     * ``arange(start, stop, step)`` Values are generated within the half-open
 1724:       interval ``[start, stop)``, with spacing between values given by
 1725:       ``step``.
 1726: 
 1727:     For integer arguments the function is roughly equivalent to the Python
 1728:     built-in :py:class:`range`, but returns an ndarray rather than a ``range``
 1729:     instance.
 1730: 
 1731:     When using a non-integer step, such as 0.1, it is often better to use
 1732:     `numpy.linspace`.
 1733: 
 1734:     See the Warning sections below for more information.
 1735: 
 1736:     Parameters
 1737:     ----------
 1738:     start : integer or real, optional
 1739:         Start of interval.  The interval includes this value.  The default
 1740:         start value is 0.
 1741:     stop : integer or real
 1742:         End of interval.  The interval does not include this value, except
 1743:         in some cases where `step` is not an integer and floating point
 1744:         round-off affects the length of `out`.
 1745:     step : integer or real, optional
 1746:         Spacing between values.  For any output `out`, this is the distance
 1747:         between two adjacent values, ``out[i+1] - out[i]``.  The default
 1748:         step size is 1.  If `step` is specified as a position argument,
 1749:         `start` must also be given.
 1750:     dtype : dtype, optional
 1751:         The type of the output array.  If `dtype` is not given, infer the data
 1752:         type from the other input arguments.
 1753:     device : str, optional
 1754:         The device on which to place the created array. Default: ``None``.
 1755:         For Array-API interoperability only, so must be ``"cpu"`` if passed.
 1756: 
 1757:         .. versionadded:: 2.0.0
 1758:     ${ARRAY_FUNCTION_LIKE}
 1759: 
 1760:         .. versionadded:: 1.20.0
 1761: 
 1762:     Returns
 1763:     -------
 1764:     arange : ndarray
 1765:         Array of evenly spaced values.
 1766: 
 1767:         For floating point arguments, the length of the result is
 1768:         ``ceil((stop - start)/step)``.  Because of floating point overflow,
 1769:         this rule may result in the last element of `out` being greater
 1770:         than `stop`.
 1771: 
 1772:     Warnings
 1773:     --------
 1774:     The length of the output might not be numerically stable.
 1775: 
 1776:     Another stability issue is due to the internal implementation of
 1777:     `numpy.arange`.
 1778:     The actual step value used to populate the array is
 1779:     ``dtype(start + step) - dtype(start)`` and not `step`. Precision loss
 1780:     can occur here, due to casting or due to using floating points when
 1781:     `start` is much larger than `step`. This can lead to unexpected
 1782:     behaviour. For example::
 1783: 
 1784:       >>> np.arange(0, 5, 0.5, dtype=int)
 1785:       array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
 1786:       >>> np.arange(-3, 3, 0.5, dtype=int)
 1787:       array([-3, -2, -1,  0,  1,  2,  3,  4,  5,  6,  7,  8])
 1788: 
 1789:     In such cases, the use of `numpy.linspace` should be preferred.
 1790: 
 1791:     The built-in :py:class:`range` generates :std:doc:`Python built-in integers
 1792:     that have arbitrary size <python:c-api/long>`, while `numpy.arange`
 1793:     produces `numpy.int32` or `numpy.int64` numbers. This may result in
 1794:     incorrect results for large integer values::
 1795: 
 1796:       >>> power = 40
 1797:       >>> modulo = 10000
 1798:       >>> x1 = [(n ** power) % modulo for n in range(8)]
 1799:       >>> x2 = [(n ** power) % modulo for n in np.arange(8)]
 1800:       >>> print(x1)
 1801:       [0, 1, 7776, 8801, 6176, 625, 6576, 4001]  # correct
 1802:       >>> print(x2)
 1803:       [0, 1, 7776, 7185, 0, 5969, 4816, 3361]  # incorrect
 1804: 
 1805:     See Also
 1806:     --------
 1807:     numpy.linspace : Evenly spaced numbers with careful handling of endpoints.
 1808:     numpy.ogrid: Arrays of evenly spaced numbers in N-dimensions.
 1809:     numpy.mgrid: Grid-shaped arrays of evenly spaced numbers in N-dimensions.
 1810:     :ref:`how-to-partition`
 1811: 
 1812:     Examples
 1813:     --------
 1814:     >>> import numpy as np
 1815:     >>> np.arange(3)
 1816:     array([0, 1, 2])
 1817:     >>> np.arange(3.0)
 1818:     array([ 0.,  1.,  2.])
 1819:     >>> np.arange(3,7)
 1820:     array([3, 4, 5, 6])
 1821:     >>> np.arange(3,7,2)
 1822:     array([3, 5])
 1823: 
 1824:     """)
 1825: 
 1826: add_newdoc('numpy._core.multiarray', '_get_ndarray_c_version',
 1827:     """_get_ndarray_c_version()
 1828: 
 1829:     Return the compile time NPY_VERSION (formerly called NDARRAY_VERSION) number.
 1830: 
 1831:     """)
 1832: 
 1833: add_newdoc('numpy._core.multiarray', '_reconstruct',
 1834:     """_reconstruct(subtype, shape, dtype)
 1835: 
 1836:     Construct an empty array. Used by Pickles.
 1837: 
 1838:     """)
 1839: 
 1840: add_newdoc('numpy._core.multiarray', 'promote_types',
 1841:     """
 1842:     promote_types(type1, type2)
 1843: 
 1844:     Returns the data type with the smallest size and smallest scalar
 1845:     kind to which both ``type1`` and ``type2`` may be safely cast.
 1846:     The returned data type is always considered "canonical", this mainly
 1847:     means that the promoted dtype will always be in native byte order.
 1848: 
 1849:     This function is symmetric, but rarely associative.
 1850: 
 1851:     Parameters
 1852:     ----------
 1853:     type1 : dtype or dtype specifier
 1854:         First data type.
 1855:     type2 : dtype or dtype specifier
 1856:         Second data type.
 1857: 
 1858:     Returns
 1859:     -------
 1860:     out : dtype
 1861:         The promoted data type.
 1862: 
 1863:     Notes
 1864:     -----
 1865:     Please see `numpy.result_type` for additional information about promotion.
 1866: 
 1867:     Starting in NumPy 1.9, promote_types function now returns a valid string
 1868:     length when given an integer or float dtype as one argument and a string
 1869:     dtype as another argument. Previously it always returned the input string
 1870:     dtype, even if it wasn't long enough to store the max integer/float value
 1871:     converted to a string.
 1872: 
 1873:     .. versionchanged:: 1.23.0
 1874: 
 1875:     NumPy now supports promotion for more structured dtypes.  It will now
 1876:     remove unnecessary padding from a structure dtype and promote included
 1877:     fields individually.
 1878: 
 1879:     See Also
 1880:     --------
 1881:     result_type, dtype, can_cast
 1882: 
 1883:     Examples
 1884:     --------
 1885:     >>> import numpy as np
 1886:     >>> np.promote_types('f4', 'f8')
 1887:     dtype('float64')
 1888: 
 1889:     >>> np.promote_types('i8', 'f4')
 1890:     dtype('float64')
 1891: 
 1892:     >>> np.promote_types('>i8', '<c8')
 1893:     dtype('complex128')
 1894: 
 1895:     >>> np.promote_types('i4', 'S8')
 1896:     dtype('S11')
 1897: 
 1898:     An example of a non-associative case:
 1899: 
 1900:     >>> p = np.promote_types
 1901:     >>> p('S', p('i1', 'u1'))
 1902:     dtype('S6')
 1903:     >>> p(p('S', 'i1'), 'u1')
 1904:     dtype('S4')
 1905: 
 1906:     """)
 1907: 
 1908: add_newdoc('numpy._core.multiarray', 'c_einsum',
 1909:     """
 1910:     c_einsum(subscripts, *operands, out=None, dtype=None, order='K',
 1911:            casting='safe')
 1912: 
 1913:     *This documentation shadows that of the native python implementation of the `einsum` function,
 1914:     except all references and examples related to the `optimize` argument (v 0.12.0) have been removed.*
 1915: 
 1916:     Evaluates the Einstein summation convention on the operands.
 1917: 
 1918:     Using the Einstein summation convention, many common multi-dimensional,
 1919:     linear algebraic array operations can be represented in a simple fashion.
 1920:     In *implicit* mode `einsum` computes these values.
 1921: 
 1922:     In *explicit* mode, `einsum` provides further flexibility to compute
 1923:     other array operations that might not be considered classical Einstein
 1924:     summation operations, by disabling, or forcing summation over specified
 1925:     subscript labels.
 1926: 
 1927:     See the notes and examples for clarification.
 1928: 
 1929:     Parameters
 1930:     ----------
 1931:     subscripts : str
 1932:         Specifies the subscripts for summation as comma separated list of
 1933:         subscript labels. An implicit (classical Einstein summation)
 1934:         calculation is performed unless the explicit indicator '->' is
 1935:         included as well as subscript labels of the precise output form.
 1936:     operands : list of array_like
 1937:         These are the arrays for the operation.
 1938:     out : ndarray, optional
 1939:         If provided, the calculation is done into this array.
 1940:     dtype : {data-type, None}, optional
 1941:         If provided, forces the calculation to use the data type specified.
 1942:         Note that you may have to also give a more liberal `casting`
 1943:         parameter to allow the conversions. Default is None.
 1944:     order : {'C', 'F', 'A', 'K'}, optional
 1945:         Controls the memory layout of the output. 'C' means it should
 1946:         be C contiguous. 'F' means it should be Fortran contiguous,
 1947:         'A' means it should be 'F' if the inputs are all 'F', 'C' otherwise.
 1948:         'K' means it should be as close to the layout of the inputs as
 1949:         is possible, including arbitrarily permuted axes.
 1950:         Default is 'K'.
 1951:     casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
 1952:         Controls what kind of data casting may occur.  Setting this to
 1953:         'unsafe' is not recommended, as it can adversely affect accumulations.
 1954: 
 1955:           * 'no' means the data types should not be cast at all.
 1956:           * 'equiv' means only byte-order changes are allowed.
 1957:           * 'safe' means only casts which can preserve values are allowed.
 1958:           * 'same_kind' means only safe casts or casts within a kind,
 1959:             like float64 to float32, are allowed.
 1960:           * 'unsafe' means any data conversions may be done.
 1961: 
 1962:         Default is 'safe'.
 1963:     optimize : {False, True, 'greedy', 'optimal'}, optional
 1964:         Controls if intermediate optimization should occur. No optimization
 1965:         will occur if False and True will default to the 'greedy' algorithm.
 1966:         Also accepts an explicit contraction list from the ``np.einsum_path``
 1967:         function. See ``np.einsum_path`` for more details. Defaults to False.
 1968: 
 1969:     Returns
 1970:     -------
 1971:     output : ndarray
 1972:         The calculation based on the Einstein summation convention.
 1973: 
 1974:     See Also
 1975:     --------
 1976:     einsum_path, dot, inner, outer, tensordot, linalg.multi_dot
 1977: 
 1978:     Notes
 1979:     -----
 1980:     The Einstein summation convention can be used to compute
 1981:     many multi-dimensional, linear algebraic array operations. `einsum`
 1982:     provides a succinct way of representing these.
 1983: 
 1984:     A non-exhaustive list of these operations,
 1985:     which can be computed by `einsum`, is shown below along with examples:
 1986: 
 1987:     * Trace of an array, :py:func:`numpy.trace`.
 1988:     * Return a diagonal, :py:func:`numpy.diag`.
 1989:     * Array axis summations, :py:func:`numpy.sum`.
 1990:     * Transpositions and permutations, :py:func:`numpy.transpose`.
 1991:     * Matrix multiplication and dot product, :py:func:`numpy.matmul` :py:func:`numpy.dot`.
 1992:     * Vector inner and outer products, :py:func:`numpy.inner` :py:func:`numpy.outer`.
 1993:     * Broadcasting, element-wise and scalar multiplication, :py:func:`numpy.multiply`.
 1994:     * Tensor contractions, :py:func:`numpy.tensordot`.
 1995:     * Chained array operations, in efficient calculation order, :py:func:`numpy.einsum_path`.
 1996: 
 1997:     The subscripts string is a comma-separated list of subscript labels,
 1998:     where each label refers to a dimension of the corresponding operand.
 1999:     Whenever a label is repeated it is summed, so ``np.einsum('i,i', a, b)``
 2000:     is equivalent to :py:func:`np.inner(a,b) <numpy.inner>`. If a label
 2001:     appears only once, it is not summed, so ``np.einsum('i', a)`` produces a
 2002:     view of ``a`` with no changes. A further example ``np.einsum('ij,jk', a, b)``
 2003:     describes traditional matrix multiplication and is equivalent to
 2004:     :py:func:`np.matmul(a,b) <numpy.matmul>`. Repeated subscript labels in one
 2005:     operand take the diagonal. For example, ``np.einsum('ii', a)`` is equivalent
 2006:     to :py:func:`np.trace(a) <numpy.trace>`.
 2007: 
 2008:     In *implicit mode*, the chosen subscripts are important
 2009:     since the axes of the output are reordered alphabetically.  This
 2010:     means that ``np.einsum('ij', a)`` doesn't affect a 2D array, while
 2011:     ``np.einsum('ji', a)`` takes its transpose. Additionally,
 2012:     ``np.einsum('ij,jk', a, b)`` returns a matrix multiplication, while,
 2013:     ``np.einsum('ij,jh', a, b)`` returns the transpose of the
 2014:     multiplication since subscript 'h' precedes subscript 'i'.
 2015: 
 2016:     In *explicit mode* the output can be directly controlled by
 2017:     specifying output subscript labels.  This requires the
 2018:     identifier '->' as well as the list of output subscript labels.
 2019:     This feature increases the flexibility of the function since
 2020:     summing can be disabled or forced when required. The call
 2021:     ``np.einsum('i->', a)`` is like :py:func:`np.sum(a) <numpy.sum>`
 2022:     if ``a`` is a 1-D array, and ``np.einsum('ii->i', a)``
 2023:     is like :py:func:`np.diag(a) <numpy.diag>` if ``a`` is a square 2-D array.
 2024:     The difference is that `einsum` does not allow broadcasting by default.
 2025:     Additionally ``np.einsum('ij,jh->ih', a, b)`` directly specifies the
 2026:     order of the output subscript labels and therefore returns matrix
 2027:     multiplication, unlike the example above in implicit mode.
 2028: 
 2029:     To enable and control broadcasting, use an ellipsis.  Default
 2030:     NumPy-style broadcasting is done by adding an ellipsis
 2031:     to the left of each term, like ``np.einsum('...ii->...i', a)``.
 2032:     ``np.einsum('...i->...', a)`` is like
 2033:     :py:func:`np.sum(a, axis=-1) <numpy.sum>` for array ``a`` of any shape.
 2034:     To take the trace along the first and last axes,
 2035:     you can do ``np.einsum('i...i', a)``, or to do a matrix-matrix
 2036:     product with the left-most indices instead of rightmost, one can do
 2037:     ``np.einsum('ij...,jk...->ik...', a, b)``.
 2038: 
 2039:     When there is only one operand, no axes are summed, and no output
 2040:     parameter is provided, a view into the operand is returned instead
 2041:     of a new array.  Thus, taking the diagonal as ``np.einsum('ii->i', a)``
 2042:     produces a view (changed in version 1.10.0).
 2043: 
 2044:     `einsum` also provides an alternative way to provide the subscripts
 2045:     and operands as ``einsum(op0, sublist0, op1, sublist1, ..., [sublistout])``.
 2046:     If the output shape is not provided in this format `einsum` will be
 2047:     calculated in implicit mode, otherwise it will be performed explicitly.
 2048:     The examples below have corresponding `einsum` calls with the two
 2049:     parameter methods.
 2050: 
 2051:     Views returned from einsum are now writeable whenever the input array
 2052:     is writeable. For example, ``np.einsum('ijk...->kji...', a)`` will now
 2053:     have the same effect as :py:func:`np.swapaxes(a, 0, 2) <numpy.swapaxes>`
 2054:     and ``np.einsum('ii->i', a)`` will return a writeable view of the diagonal
 2055:     of a 2D array.
 2056: 
 2057:     Examples
 2058:     --------
 2059:     >>> import numpy as np
 2060:     >>> a = np.arange(25).reshape(5,5)
 2061:     >>> b = np.arange(5)
 2062:     >>> c = np.arange(6).reshape(2,3)
 2063: 
 2064:     Trace of a matrix:
 2065: 
 2066:     >>> np.einsum('ii', a)
 2067:     60
 2068:     >>> np.einsum(a, [0,0])
 2069:     60
 2070:     >>> np.trace(a)
 2071:     60
 2072: 
 2073:     Extract the diagonal (requires explicit form):
 2074: 
 2075:     >>> np.einsum('ii->i', a)
 2076:     array([ 0,  6, 12, 18, 24])
 2077:     >>> np.einsum(a, [0,0], [0])
 2078:     array([ 0,  6, 12, 18, 24])
 2079:     >>> np.diag(a)
 2080:     array([ 0,  6, 12, 18, 24])
 2081: 
 2082:     Sum over an axis (requires explicit form):
 2083: 
 2084:     >>> np.einsum('ij->i', a)
 2085:     array([ 10,  35,  60,  85, 110])
 2086:     >>> np.einsum(a, [0,1], [0])
 2087:     array([ 10,  35,  60,  85, 110])
 2088:     >>> np.sum(a, axis=1)
 2089:     array([ 10,  35,  60,  85, 110])
 2090: 
 2091:     For higher dimensional arrays summing a single axis can be done with ellipsis:
 2092: 
 2093:     >>> np.einsum('...j->...', a)
 2094:     array([ 10,  35,  60,  85, 110])
 2095:     >>> np.einsum(a, [Ellipsis,1], [Ellipsis])
 2096:     array([ 10,  35,  60,  85, 110])
 2097: 
 2098:     Compute a matrix transpose, or reorder any number of axes:
 2099: 
 2100:     >>> np.einsum('ji', c)
 2101:     array([[0, 3],
 2102:            [1, 4],
 2103:            [2, 5]])
 2104:     >>> np.einsum('ij->ji', c)
 2105:     array([[0, 3],
 2106:            [1, 4],
 2107:            [2, 5]])
 2108:     >>> np.einsum(c, [1,0])
 2109:     array([[0, 3],
 2110:            [1, 4],
 2111:            [2, 5]])
 2112:     >>> np.transpose(c)
 2113:     array([[0, 3],
 2114:            [1, 4],
 2115:            [2, 5]])
 2116: 
 2117:     Vector inner products:
 2118: 
 2119:     >>> np.einsum('i,i', b, b)
 2120:     30
 2121:     >>> np.einsum(b, [0], b, [0])
 2122:     30
 2123:     >>> np.inner(b,b)
 2124:     30
 2125: 
 2126:     Matrix vector multiplication:
 2127: 
 2128:     >>> np.einsum('ij,j', a, b)
 2129:     array([ 30,  80, 130, 180, 230])
 2130:     >>> np.einsum(a, [0,1], b, [1])
 2131:     array([ 30,  80, 130, 180, 230])
 2132:     >>> np.dot(a, b)
 2133:     array([ 30,  80, 130, 180, 230])
 2134:     >>> np.einsum('...j,j', a, b)
 2135:     array([ 30,  80, 130, 180, 230])
 2136: 
 2137:     Broadcasting and scalar multiplication:
 2138: 
 2139:     >>> np.einsum('..., ...', 3, c)
 2140:     array([[ 0,  3,  6],
 2141:            [ 9, 12, 15]])
 2142:     >>> np.einsum(',ij', 3, c)
 2143:     array([[ 0,  3,  6],
 2144:            [ 9, 12, 15]])
 2145:     >>> np.einsum(3, [Ellipsis], c, [Ellipsis])
 2146:     array([[ 0,  3,  6],
 2147:            [ 9, 12, 15]])
 2148:     >>> np.multiply(3, c)
 2149:     array([[ 0,  3,  6],
 2150:            [ 9, 12, 15]])
 2151: 
 2152:     Vector outer product:
 2153: 
 2154:     >>> np.einsum('i,j', np.arange(2)+1, b)
 2155:     array([[0, 1, 2, 3, 4],
 2156:            [0, 2, 4, 6, 8]])
 2157:     >>> np.einsum(np.arange(2)+1, [0], b, [1])
 2158:     array([[0, 1, 2, 3, 4],
 2159:            [0, 2, 4, 6, 8]])
 2160:     >>> np.outer(np.arange(2)+1, b)
 2161:     array([[0, 1, 2, 3, 4],
 2162:            [0, 2, 4, 6, 8]])
 2163: 
 2164:     Tensor contraction:
 2165: 
 2166:     >>> a = np.arange(60.).reshape(3,4,5)
 2167:     >>> b = np.arange(24.).reshape(4,3,2)
 2168:     >>> np.einsum('ijk,jil->kl', a, b)
 2169:     array([[ 4400.,  4730.],
 2170:            [ 4532.,  4874.],
 2171:            [ 4664.,  5018.],
 2172:            [ 4796.,  5162.],
 2173:            [ 4928.,  5306.]])
 2174:     >>> np.einsum(a, [0,1,2], b, [1,0,3], [2,3])
 2175:     array([[ 4400.,  4730.],
 2176:            [ 4532.,  4874.],
 2177:            [ 4664.,  5018.],
 2178:            [ 4796.,  5162.],
 2179:            [ 4928.,  5306.]])
 2180:     >>> np.tensordot(a,b, axes=([1,0],[0,1]))
 2181:     array([[ 4400.,  4730.],
 2182:            [ 4532.,  4874.],
 2183:            [ 4664.,  5018.],
 2184:            [ 4796.,  5162.],
 2185:            [ 4928.,  5306.]])
 2186: 
 2187:     Writeable returned arrays (since version 1.10.0):
 2188: 
 2189:     >>> a = np.zeros((3, 3))
 2190:     >>> np.einsum('ii->i', a)[:] = 1
 2191:     >>> a
 2192:     array([[ 1.,  0.,  0.],
 2193:            [ 0.,  1.,  0.],
 2194:            [ 0.,  0.,  1.]])
 2195: 
 2196:     Example of ellipsis use:
 2197: 
 2198:     >>> a = np.arange(6).reshape((3,2))
 2199:     >>> b = np.arange(12).reshape((4,3))
 2200:     >>> np.einsum('ki,jk->ij', a, b)
 2201:     array([[10, 28, 46, 64],
 2202:            [13, 40, 67, 94]])
 2203:     >>> np.einsum('ki,...k->i...', a, b)
 2204:     array([[10, 28, 46, 64],
 2205:            [13, 40, 67, 94]])
 2206:     >>> np.einsum('k...,jk', a, b)
 2207:     array([[10, 28, 46, 64],
 2208:            [13, 40, 67, 94]])
 2209: 
 2210:     """)
 2211: 
 2212: 
 2213: ##############################################################################
 2214: #
 2215: # Documentation for ndarray attributes and methods
 2216: #
 2217: ##############################################################################
 2218: 
 2219: 
 2220: ##############################################################################
 2221: #
 2222: # ndarray object
 2223: #
 2224: ##############################################################################
 2225: 
 2226: 
 2227: add_newdoc('numpy._core.multiarray', 'ndarray',
 2228:     """
 2229:     ndarray(shape, dtype=float, buffer=None, offset=0,
 2230:             strides=None, order=None)
 2231: 
 2232:     An array object represents a multidimensional, homogeneous array
 2233:     of fixed-size items.  An associated data-type object describes the
 2234:     format of each element in the array (its byte-order, how many bytes it
 2235:     occupies in memory, whether it is an integer, a floating point number,
 2236:     or something else, etc.)
 2237: 
 2238:     Arrays should be constructed using `array`, `zeros` or `empty` (refer
 2239:     to the See Also section below).  The parameters given here refer to
 2240:     a low-level method (`ndarray(...)`) for instantiating an array.
 2241: 
 2242:     For more information, refer to the `numpy` module and examine the
 2243:     methods and attributes of an array.
 2244: 
 2245:     Parameters
 2246:     ----------
 2247:     (for the __new__ method; see Notes below)
 2248: 
 2249:     shape : tuple of ints
 2250:         Shape of created array.
 2251:     dtype : data-type, optional
 2252:         Any object that can be interpreted as a numpy data type.
 2253:     buffer : object exposing buffer interface, optional
 2254:         Used to fill the array with data.
 2255:     offset : int, optional
 2256:         Offset of array data in buffer.
 2257:     strides : tuple of ints, optional
 2258:         Strides of data in memory.
 2259:     order : {'C', 'F'}, optional
 2260:         Row-major (C-style) or column-major (Fortran-style) order.
 2261: 
 2262:     Attributes
 2263:     ----------
 2264:     T : ndarray
 2265:         Transpose of the array.
 2266:     data : buffer
 2267:         The array's elements, in memory.
 2268:     dtype : dtype object
 2269:         Describes the format of the elements in the array.
 2270:     flags : dict
 2271:         Dictionary containing information related to memory use, e.g.,
 2272:         'C_CONTIGUOUS', 'OWNDATA', 'WRITEABLE', etc.
 2273:     flat : numpy.flatiter object
 2274:         Flattened version of the array as an iterator.  The iterator
 2275:         allows assignments, e.g., ``x.flat = 3`` (See `ndarray.flat` for
 2276:         assignment examples; TODO).
 2277:     imag : ndarray
 2278:         Imaginary part of the array.
 2279:     real : ndarray
 2280:         Real part of the array.
 2281:     size : int
 2282:         Number of elements in the array.
 2283:     itemsize : int
 2284:         The memory use of each array element in bytes.
 2285:     nbytes : int
 2286:         The total number of bytes required to store the array data,
 2287:         i.e., ``itemsize * size``.
 2288:     ndim : int
 2289:         The array's number of dimensions.
 2290:     shape : tuple of ints
 2291:         Shape of the array.
 2292:     strides : tuple of ints
 2293:         The step-size required to move from one element to the next in
 2294:         memory. For example, a contiguous ``(3, 4)`` array of type
 2295:         ``int16`` in C-order has strides ``(8, 2)``.  This implies that
 2296:         to move from element to element in memory requires jumps of 2 bytes.
 2297:         To move from row-to-row, one needs to jump 8 bytes at a time
 2298:         (``2 * 4``).
 2299:     ctypes : ctypes object
 2300:         Class containing properties of the array needed for interaction
 2301:         with ctypes.
 2302:     base : ndarray
 2303:         If the array is a view into another array, that array is its `base`
 2304:         (unless that array is also a view).  The `base` array is where the
 2305:         array data is actually stored.
 2306: 
 2307:     See Also
 2308:     --------
 2309:     array : Construct an array.
 2310:     zeros : Create an array, each element of which is zero.
 2311:     empty : Create an array, but leave its allocated memory unchanged (i.e.,
 2312:             it contains "garbage").
 2313:     dtype : Create a data-type.
 2314:     numpy.typing.NDArray : An ndarray alias :term:`generic <generic type>`
 2315:                            w.r.t. its `dtype.type <numpy.dtype.type>`.
 2316: 
 2317:     Notes
 2318:     -----
 2319:     There are two modes of creating an array using ``__new__``:
 2320: 
 2321:     1. If `buffer` is None, then only `shape`, `dtype`, and `order`
 2322:        are used.
 2323:     2. If `buffer` is an object exposing the buffer interface, then
 2324:        all keywords are interpreted.
 2325: 
 2326:     No ``__init__`` method is needed because the array is fully initialized
 2327:     after the ``__new__`` method.
 2328: 
 2329:     Examples
 2330:     --------
 2331:     These examples illustrate the low-level `ndarray` constructor.  Refer
 2332:     to the `See Also` section above for easier ways of constructing an
 2333:     ndarray.
 2334: 
 2335:     First mode, `buffer` is None:
 2336: 
 2337:     >>> import numpy as np
 2338:     >>> np.ndarray(shape=(2,2), dtype=float, order='F')
 2339:     array([[0.0e+000, 0.0e+000], # random
 2340:            [     nan, 2.5e-323]])
 2341: 
 2342:     Second mode:
 2343: 
 2344:     >>> np.ndarray((2,), buffer=np.array([1,2,3]),
 2345:     ...            offset=np.int_().itemsize,
 2346:     ...            dtype=int) # offset = 1*itemsize, i.e. skip first element
 2347:     array([2, 3])
 2348: 
 2349:     """)
 2350: 
 2351: 
 2352: ##############################################################################
 2353: #
 2354: # ndarray attributes
 2355: #
 2356: ##############################################################################
 2357: 
 2358: 
 2359: add_newdoc('numpy._core.multiarray', 'ndarray', ('__array_interface__',
 2360:     """Array protocol: Python side."""))
 2361: 
 2362: 
 2363: add_newdoc('numpy._core.multiarray', 'ndarray', ('__array_priority__',
 2364:     """Array priority."""))
 2365: 
 2366: 
 2367: add_newdoc('numpy._core.multiarray', 'ndarray', ('__array_struct__',
 2368:     """Array protocol: C-struct side."""))
 2369: 
 2370: add_newdoc('numpy._core.multiarray', 'ndarray', ('__dlpack__',
 2371:     """
 2372:     a.__dlpack__(*, stream=None, max_version=None, dl_device=None, copy=None)
 2373: 
 2374:     DLPack Protocol: Part of the Array API.
 2375: 
 2376:     """))
 2377: 
 2378: add_newdoc('numpy._core.multiarray', 'ndarray', ('__dlpack_device__',
 2379:     """
 2380:     a.__dlpack_device__()
 2381: 
 2382:     DLPack Protocol: Part of the Array API.
 2383: 
 2384:     """))
 2385: 
 2386: add_newdoc('numpy._core.multiarray', 'ndarray', ('base',
 2387:     """
 2388:     Base object if memory is from some other object.
 2389: 
 2390:     Examples
 2391:     --------
 2392:     The base of an array that owns its memory is None:
 2393: 
 2394:     >>> import numpy as np
 2395:     >>> x = np.array([1,2,3,4])
 2396:     >>> x.base is None
 2397:     True
 2398: 
 2399:     Slicing creates a view, whose memory is shared with x:
 2400: 
 2401:     >>> y = x[2:]
 2402:     >>> y.base is x
 2403:     True
 2404: 
 2405:     """))
 2406: 
 2407: 
 2408: add_newdoc('numpy._core.multiarray', 'ndarray', ('ctypes',
 2409:     """
 2410:     An object to simplify the interaction of the array with the ctypes
 2411:     module.
 2412: 
 2413:     This attribute creates an object that makes it easier to use arrays
 2414:     when calling shared libraries with the ctypes module. The returned
 2415:     object has, among others, data, shape, and strides attributes (see
 2416:     Notes below) which themselves return ctypes objects that can be used
 2417:     as arguments to a shared library.
 2418: 
 2419:     Parameters
 2420:     ----------
 2421:     None
 2422: 
 2423:     Returns
 2424:     -------
 2425:     c : Python object
 2426:         Possessing attributes data, shape, strides, etc.
 2427: 
 2428:     See Also
 2429:     --------
 2430:     numpy.ctypeslib
 2431: 
 2432:     Notes
 2433:     -----
 2434:     Below are the public attributes of this object which were documented
 2435:     in "Guide to NumPy" (we have omitted undocumented public attributes,
 2436:     as well as documented private attributes):
 2437: 
 2438:     .. autoattribute:: numpy._core._internal._ctypes.data
 2439:         :noindex:
 2440: 
 2441:     .. autoattribute:: numpy._core._internal._ctypes.shape
 2442:         :noindex:
 2443: 
 2444:     .. autoattribute:: numpy._core._internal._ctypes.strides
 2445:         :noindex:
 2446: 
 2447:     .. automethod:: numpy._core._internal._ctypes.data_as
 2448:         :noindex:
 2449: 
 2450:     .. automethod:: numpy._core._internal._ctypes.shape_as
 2451:         :noindex:
 2452: 
 2453:     .. automethod:: numpy._core._internal._ctypes.strides_as
 2454:         :noindex:
 2455: 
 2456:     If the ctypes module is not available, then the ctypes attribute
 2457:     of array objects still returns something useful, but ctypes objects
 2458:     are not returned and errors may be raised instead. In particular,
 2459:     the object will still have the ``as_parameter`` attribute which will
 2460:     return an integer equal to the data attribute.
 2461: 
 2462:     Examples
 2463:     --------
 2464:     >>> import numpy as np
 2465:     >>> import ctypes
 2466:     >>> x = np.array([[0, 1], [2, 3]], dtype=np.int32)
 2467:     >>> x
 2468:     array([[0, 1],
 2469:            [2, 3]], dtype=int32)
 2470:     >>> x.ctypes.data
 2471:     31962608 # may vary
 2472:     >>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_uint32))
 2473:     <__main__.LP_c_uint object at 0x7ff2fc1fc200> # may vary
 2474:     >>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_uint32)).contents
 2475:     c_uint(0)
 2476:     >>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_uint64)).contents
 2477:     c_ulong(4294967296)
 2478:     >>> x.ctypes.shape
 2479:     <numpy._core._internal.c_long_Array_2 object at 0x7ff2fc1fce60> # may vary
 2480:     >>> x.ctypes.strides
 2481:     <numpy._core._internal.c_long_Array_2 object at 0x7ff2fc1ff320> # may vary
 2482: 
 2483:     """))
 2484: 
 2485: 
 2486: add_newdoc('numpy._core.multiarray', 'ndarray', ('data',
 2487:     """Python buffer object pointing to the start of the array's data."""))
 2488: 
 2489: 
 2490: add_newdoc('numpy._core.multiarray', 'ndarray', ('dtype',
 2491:     """
 2492:     Data-type of the array's elements.
 2493: 
 2494:     .. warning::
 2495: 
 2496:         Setting ``arr.dtype`` is discouraged and may be deprecated in the
 2497:         future.  Setting will replace the ``dtype`` without modifying the
 2498:         memory (see also `ndarray.view` and `ndarray.astype`).
 2499: 
 2500:     Parameters
 2501:     ----------
 2502:     None
 2503: 
 2504:     Returns
 2505:     -------
 2506:     d : numpy dtype object
 2507: 
 2508:     See Also
 2509:     --------
 2510:     ndarray.astype : Cast the values contained in the array to a new data-type.
 2511:     ndarray.view : Create a view of the same data but a different data-type.
 2512:     numpy.dtype
 2513: 
 2514:     Examples
 2515:     --------
 2516:     >>> import numpy as np
 2517:     >>> x = np.arange(4).reshape((2, 2))
 2518:     >>> x
 2519:     array([[0, 1],
 2520:            [2, 3]])
 2521:     >>> x.dtype
 2522:     dtype('int64')   # may vary (OS, bitness)
 2523:     >>> isinstance(x.dtype, np.dtype)
 2524:     True
 2525: 
 2526:     """))
 2527: 
 2528: 
 2529: add_newdoc('numpy._core.multiarray', 'ndarray', ('imag',
 2530:     """
 2531:     The imaginary part of the array.
 2532: 
 2533:     Examples
 2534:     --------
 2535:     >>> import numpy as np
 2536:     >>> x = np.sqrt([1+0j, 0+1j])
 2537:     >>> x.imag
 2538:     array([ 0.        ,  0.70710678])
 2539:     >>> x.imag.dtype
 2540:     dtype('float64')
 2541: 
 2542:     """))
 2543: 
 2544: 
 2545: add_newdoc('numpy._core.multiarray', 'ndarray', ('itemsize',
 2546:     """
 2547:     Length of one array element in bytes.
 2548: 
 2549:     Examples
 2550:     --------
 2551:     >>> import numpy as np
 2552:     >>> x = np.array([1,2,3], dtype=np.float64)
 2553:     >>> x.itemsize
 2554:     8
 2555:     >>> x = np.array([1,2,3], dtype=np.complex128)
 2556:     >>> x.itemsize
 2557:     16
 2558: 
 2559:     """))
 2560: 
 2561: 
 2562: add_newdoc('numpy._core.multiarray', 'ndarray', ('flags',
 2563:     """
 2564:     Information about the memory layout of the array.
 2565: 
 2566:     Attributes
 2567:     ----------
 2568:     C_CONTIGUOUS (C)
 2569:         The data is in a single, C-style contiguous segment.
 2570:     F_CONTIGUOUS (F)
 2571:         The data is in a single, Fortran-style contiguous segment.
 2572:     OWNDATA (O)
 2573:         The array owns the memory it uses or borrows it from another object.
 2574:     WRITEABLE (W)
 2575:         The data area can be written to.  Setting this to False locks
 2576:         the data, making it read-only.  A view (slice, etc.) inherits WRITEABLE
 2577:         from its base array at creation time, but a view of a writeable
 2578:         array may be subsequently locked while the base array remains writeable.
 2579:         (The opposite is not true, in that a view of a locked array may not
 2580:         be made writeable.  However, currently, locking a base object does not
 2581:         lock any views that already reference it, so under that circumstance it
 2582:         is possible to alter the contents of a locked array via a previously
 2583:         created writeable view onto it.)  Attempting to change a non-writeable
 2584:         array raises a RuntimeError exception.
 2585:     ALIGNED (A)
 2586:         The data and all elements are aligned appropriately for the hardware.
 2587:     WRITEBACKIFCOPY (X)
 2588:         This array is a copy of some other array. The C-API function
 2589:         PyArray_ResolveWritebackIfCopy must be called before deallocating
 2590:         to the base array will be updated with the contents of this array.
 2591:     FNC
 2592:         F_CONTIGUOUS and not C_CONTIGUOUS.
 2593:     FORC
 2594:         F_CONTIGUOUS or C_CONTIGUOUS (one-segment test).
 2595:     BEHAVED (B)
 2596:         ALIGNED and WRITEABLE.
 2597:     CARRAY (CA)
 2598:         BEHAVED and C_CONTIGUOUS.
 2599:     FARRAY (FA)
 2600:         BEHAVED and F_CONTIGUOUS and not C_CONTIGUOUS.
 2601: 
 2602:     Notes
 2603:     -----
 2604:     The `flags` object can be accessed dictionary-like (as in ``a.flags['WRITEABLE']``),
 2605:     or by using lowercased attribute names (as in ``a.flags.writeable``). Short flag
 2606:     names are only supported in dictionary access.
 2607: 
 2608:     Only the WRITEBACKIFCOPY, WRITEABLE, and ALIGNED flags can be
 2609:     changed by the user, via direct assignment to the attribute or dictionary
 2610:     entry, or by calling `ndarray.setflags`.
 2611: 
 2612:     The array flags cannot be set arbitrarily:
 2613: 
 2614:     - WRITEBACKIFCOPY can only be set ``False``.
 2615:     - ALIGNED can only be set ``True`` if the data is truly aligned.
 2616:     - WRITEABLE can only be set ``True`` if the array owns its own memory
 2617:       or the ultimate owner of the memory exposes a writeable buffer
 2618:       interface or is a string.
 2619: 
 2620:     Arrays can be both C-style and Fortran-style contiguous simultaneously.
 2621:     This is clear for 1-dimensional arrays, but can also be true for higher
 2622:     dimensional arrays.
 2623: 
 2624:     Even for contiguous arrays a stride for a given dimension
 2625:     ``arr.strides[dim]`` may be *arbitrary* if ``arr.shape[dim] == 1``
 2626:     or the array has no elements.
 2627:     It does *not* generally hold that ``self.strides[-1] == self.itemsize``
 2628:     for C-style contiguous arrays or ``self.strides[0] == self.itemsize`` for
 2629:     Fortran-style contiguous arrays is true.
 2630:     """))
 2631: 
 2632: 
 2633: add_newdoc('numpy._core.multiarray', 'ndarray', ('flat',
 2634:     """
 2635:     A 1-D iterator over the array.
 2636: 
 2637:     This is a `numpy.flatiter` instance, which acts similarly to, but is not
 2638:     a subclass of, Python's built-in iterator object.
 2639: 
 2640:     See Also
 2641:     --------
 2642:     flatten : Return a copy of the array collapsed into one dimension.
 2643: 
 2644:     flatiter
 2645: 
 2646:     Examples
 2647:     --------
 2648:     >>> import numpy as np
 2649:     >>> x = np.arange(1, 7).reshape(2, 3)
 2650:     >>> x
 2651:     array([[1, 2, 3],
 2652:            [4, 5, 6]])
 2653:     >>> x.flat[3]
 2654:     4
 2655:     >>> x.T
 2656:     array([[1, 4],
 2657:            [2, 5],
 2658:            [3, 6]])
 2659:     >>> x.T.flat[3]
 2660:     5
 2661:     >>> type(x.flat)
 2662:     <class 'numpy.flatiter'>
 2663: 
 2664:     An assignment example:
 2665: 
 2666:     >>> x.flat = 3; x
 2667:     array([[3, 3, 3],
 2668:            [3, 3, 3]])
 2669:     >>> x.flat[[1,4]] = 1; x
 2670:     array([[3, 1, 3],
 2671:            [3, 1, 3]])
 2672: 
 2673:     """))
 2674: 
 2675: 
 2676: add_newdoc('numpy._core.multiarray', 'ndarray', ('nbytes',
 2677:     """
 2678:     Total bytes consumed by the elements of the array.
 2679: 
 2680:     Notes
 2681:     -----
 2682:     Does not include memory consumed by non-element attributes of the
 2683:     array object.
 2684: 
 2685:     See Also
 2686:     --------
 2687:     sys.getsizeof
 2688:         Memory consumed by the object itself without parents in case view.
 2689:         This does include memory consumed by non-element attributes.
 2690: 
 2691:     Examples
 2692:     --------
 2693:     >>> import numpy as np
 2694:     >>> x = np.zeros((3,5,2), dtype=np.complex128)
 2695:     >>> x.nbytes
 2696:     480
 2697:     >>> np.prod(x.shape) * x.itemsize
 2698:     480
 2699: 
 2700:     """))
 2701: 
 2702: 
 2703: add_newdoc('numpy._core.multiarray', 'ndarray', ('ndim',
 2704:     """
 2705:     Number of array dimensions.
 2706: 
 2707:     Examples
 2708:     --------
 2709:     >>> import numpy as np
 2710:     >>> x = np.array([1, 2, 3])
 2711:     >>> x.ndim
 2712:     1
 2713:     >>> y = np.zeros((2, 3, 4))
 2714:     >>> y.ndim
 2715:     3
 2716: 
 2717:     """))
 2718: 
 2719: 
 2720: add_newdoc('numpy._core.multiarray', 'ndarray', ('real',
 2721:     """
 2722:     The real part of the array.
 2723: 
 2724:     Examples
 2725:     --------
 2726:     >>> import numpy as np
 2727:     >>> x = np.sqrt([1+0j, 0+1j])
 2728:     >>> x.real
 2729:     array([ 1.        ,  0.70710678])
 2730:     >>> x.real.dtype
 2731:     dtype('float64')
 2732: 
 2733:     See Also
 2734:     --------
 2735:     numpy.real : equivalent function
 2736: 
 2737:     """))
 2738: 
 2739: 
 2740: add_newdoc('numpy._core.multiarray', 'ndarray', ('shape',
 2741:     """
 2742:     Tuple of array dimensions.
 2743: 
 2744:     The shape property is usually used to get the current shape of an array,
 2745:     but may also be used to reshape the array in-place by assigning a tuple of
 2746:     array dimensions to it.  As with `numpy.reshape`, one of the new shape
 2747:     dimensions can be -1, in which case its value is inferred from the size of
 2748:     the array and the remaining dimensions. Reshaping an array in-place will
 2749:     fail if a copy is required.
 2750: 
 2751:     .. warning::
 2752: 
 2753:         Setting ``arr.shape`` is discouraged and may be deprecated in the
 2754:         future.  Using `ndarray.reshape` is the preferred approach.
 2755: 
 2756:     Examples
 2757:     --------
 2758:     >>> import numpy as np
 2759:     >>> x = np.array([1, 2, 3, 4])
 2760:     >>> x.shape
 2761:     (4,)
 2762:     >>> y = np.zeros((2, 3, 4))
 2763:     >>> y.shape
 2764:     (2, 3, 4)
 2765:     >>> y.shape = (3, 8)
 2766:     >>> y
 2767:     array([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],
 2768:            [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],
 2769:            [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])
 2770:     >>> y.shape = (3, 6)
 2771:     Traceback (most recent call last):
 2772:       File "<stdin>", line 1, in <module>
 2773:     ValueError: cannot reshape array of size 24 into shape (3,6)
 2774:     >>> np.zeros((4,2))[::2].shape = (-1,)
 2775:     Traceback (most recent call last):
 2776:       File "<stdin>", line 1, in <module>
 2777:     AttributeError: Incompatible shape for in-place modification. Use
 2778:     `.reshape()` to make a copy with the desired shape.
 2779: 
 2780:     See Also
 2781:     --------
 2782:     numpy.shape : Equivalent getter function.
 2783:     numpy.reshape : Function similar to setting ``shape``.
 2784:     ndarray.reshape : Method similar to setting ``shape``.
 2785: 
 2786:     """))
 2787: 
 2788: 
 2789: add_newdoc('numpy._core.multiarray', 'ndarray', ('size',
 2790:     """
 2791:     Number of elements in the array.
 2792: 
 2793:     Equal to ``np.prod(a.shape)``, i.e., the product of the array's
 2794:     dimensions.
 2795: 
 2796:     Notes
 2797:     -----
 2798:     `a.size` returns a standard arbitrary precision Python integer. This
 2799:     may not be the case with other methods of obtaining the same value
 2800:     (like the suggested ``np.prod(a.shape)``, which returns an instance
 2801:     of ``np.int_``), and may be relevant if the value is used further in
 2802:     calculations that may overflow a fixed size integer type.
 2803: 
 2804:     Examples
 2805:     --------
 2806:     >>> import numpy as np
 2807:     >>> x = np.zeros((3, 5, 2), dtype=np.complex128)
 2808:     >>> x.size
 2809:     30
 2810:     >>> np.prod(x.shape)
 2811:     30
 2812: 
 2813:     """))
 2814: 
 2815: 
 2816: add_newdoc('numpy._core.multiarray', 'ndarray', ('strides',
 2817:     """
 2818:     Tuple of bytes to step in each dimension when traversing an array.
 2819: 
 2820:     The byte offset of element ``(i[0], i[1], ..., i[n])`` in an array `a`
 2821:     is::
 2822: 
 2823:         offset = sum(np.array(i) * a.strides)
 2824: 
 2825:     A more detailed explanation of strides can be found in
 2826:     :ref:`arrays.ndarray`.
 2827: 
 2828:     .. warning::
 2829: 
 2830:         Setting ``arr.strides`` is discouraged and may be deprecated in the
 2831:         future.  `numpy.lib.stride_tricks.as_strided` should be preferred
 2832:         to create a new view of the same data in a safer way.
 2833: 
 2834:     Notes
 2835:     -----
 2836:     Imagine an array of 32-bit integers (each 4 bytes)::
 2837: 
 2838:       x = np.array([[0, 1, 2, 3, 4],
 2839:                     [5, 6, 7, 8, 9]], dtype=np.int32)
 2840: 
 2841:     This array is stored in memory as 40 bytes, one after the other
 2842:     (known as a contiguous block of memory).  The strides of an array tell
 2843:     us how many bytes we have to skip in memory to move to the next position
 2844:     along a certain axis.  For example, we have to skip 4 bytes (1 value) to
 2845:     move to the next column, but 20 bytes (5 values) to get to the same
 2846:     position in the next row.  As such, the strides for the array `x` will be
 2847:     ``(20, 4)``.
 2848: 
 2849:     See Also
 2850:     --------
 2851:     numpy.lib.stride_tricks.as_strided
 2852: 
 2853:     Examples
 2854:     --------
 2855:     >>> import numpy as np
 2856:     >>> y = np.reshape(np.arange(2 * 3 * 4, dtype=np.int32), (2, 3, 4))
 2857:     >>> y
 2858:     array([[[ 0,  1,  2,  3],
 2859:             [ 4,  5,  6,  7],
 2860:             [ 8,  9, 10, 11]],
 2861:            [[12, 13, 14, 15],
 2862:             [16, 17, 18, 19],
 2863:             [20, 21, 22, 23]]], dtype=np.int32)
 2864:     >>> y.strides
 2865:     (48, 16, 4)
 2866:     >>> y[1, 1, 1]
 2867:     np.int32(17)
 2868:     >>> offset = sum(y.strides * np.array((1, 1, 1)))
 2869:     >>> offset // y.itemsize
 2870:     np.int64(17)
 2871: 
 2872:     >>> x = np.reshape(np.arange(5*6*7*8, dtype=np.int32), (5, 6, 7, 8))
 2873:     >>> x = x.transpose(2, 3, 1, 0)
 2874:     >>> x.strides
 2875:     (32, 4, 224, 1344)
 2876:     >>> i = np.array([3, 5, 2, 2], dtype=np.int32)
 2877:     >>> offset = sum(i * x.strides)
 2878:     >>> x[3, 5, 2, 2]
 2879:     np.int32(813)
 2880:     >>> offset // x.itemsize
 2881:     np.int64(813)
 2882: 
 2883:     """))
 2884: 
 2885: 
 2886: add_newdoc('numpy._core.multiarray', 'ndarray', ('T',
 2887:     """
 2888:     View of the transposed array.
 2889: 
 2890:     Same as ``self.transpose()``.
 2891: 
 2892:     Examples
 2893:     --------
 2894:     >>> import numpy as np
 2895:     >>> a = np.array([[1, 2], [3, 4]])
 2896:     >>> a
 2897:     array([[1, 2],
 2898:            [3, 4]])
 2899:     >>> a.T
 2900:     array([[1, 3],
 2901:            [2, 4]])
 2902: 
 2903:     >>> a = np.array([1, 2, 3, 4])
 2904:     >>> a
 2905:     array([1, 2, 3, 4])
 2906:     >>> a.T
 2907:     array([1, 2, 3, 4])
 2908: 
 2909:     See Also
 2910:     --------
 2911:     transpose
 2912: 
 2913:     """))
 2914: 
 2915: 
 2916: add_newdoc('numpy._core.multiarray', 'ndarray', ('mT',
 2917:     """
 2918:     View of the matrix transposed array.
 2919: 
 2920:     The matrix transpose is the transpose of the last two dimensions, even
 2921:     if the array is of higher dimension.
 2922: 
 2923:     .. versionadded:: 2.0
 2924: 
 2925:     Raises
 2926:     ------
 2927:     ValueError
 2928:         If the array is of dimension less than 2.
 2929: 
 2930:     Examples
 2931:     --------
 2932:     >>> import numpy as np
 2933:     >>> a = np.array([[1, 2], [3, 4]])
 2934:     >>> a
 2935:     array([[1, 2],
 2936:            [3, 4]])
 2937:     >>> a.mT
 2938:     array([[1, 3],
 2939:            [2, 4]])
 2940: 
 2941:     >>> a = np.arange(8).reshape((2, 2, 2))
 2942:     >>> a
 2943:     array([[[0, 1],
 2944:             [2, 3]],
 2945:     <BLANKLINE>
 2946:            [[4, 5],
 2947:             [6, 7]]])
 2948:     >>> a.mT
 2949:     array([[[0, 2],
 2950:             [1, 3]],
 2951:     <BLANKLINE>
 2952:            [[4, 6],
 2953:             [5, 7]]])
 2954: 
 2955:     """))
 2956: ##############################################################################
 2957: #
 2958: # ndarray methods
 2959: #
 2960: ##############################################################################
 2961: 
 2962: 
 2963: add_newdoc('numpy._core.multiarray', 'ndarray', ('__array__',
 2964:     """
 2965:     a.__array__([dtype], *, copy=None)
 2966: 
 2967:     For ``dtype`` parameter it returns a new reference to self if
 2968:     ``dtype`` is not given or it matches array's data type.
 2969:     A new array of provided data type is returned if ``dtype``
 2970:     is different from the current data type of the array.
 2971:     For ``copy`` parameter it returns a new reference to self if
 2972:     ``copy=False`` or ``copy=None`` and copying isn't enforced by ``dtype``
 2973:     parameter. The method returns a new array for ``copy=True``, regardless of
 2974:     ``dtype`` parameter.
 2975: 
 2976:     A more detailed explanation of the ``__array__`` interface
 2977:     can be found in :ref:`dunder_array.interface`.
 2978: 
 2979:     """))
 2980: 
 2981: 
 2982: add_newdoc('numpy._core.multiarray', 'ndarray', ('__array_finalize__',
 2983:     """
 2984:     a.__array_finalize__(obj, /)
 2985: 
 2986:     Present so subclasses can call super. Does nothing.
 2987: 
 2988:     """))
 2989: 
 2990: 
 2991: add_newdoc('numpy._core.multiarray', 'ndarray', ('__array_wrap__',
 2992:     """
 2993:     a.__array_wrap__(array[, context], /)
 2994: 
 2995:     Returns a view of `array` with the same type as self.
 2996: 
 2997:     """))
 2998: 
 2999: 
 3000: add_newdoc('numpy._core.multiarray', 'ndarray', ('__copy__',
 3001:     """
 3002:     a.__copy__()
 3003: 
 3004:     Used if :func:`copy.copy` is called on an array. Returns a copy of the array.
 3005: 
 3006:     Equivalent to ``a.copy(order='K')``.
 3007: 
 3008:     """))
 3009: 
 3010: 
 3011: add_newdoc('numpy._core.multiarray', 'ndarray', ('__class_getitem__',
 3012:     """
 3013:     a.__class_getitem__(item, /)
 3014: 
 3015:     Return a parametrized wrapper around the `~numpy.ndarray` type.
 3016: 
 3017:     .. versionadded:: 1.22
 3018: 
 3019:     Returns
 3020:     -------
 3021:     alias : types.GenericAlias
 3022:         A parametrized `~numpy.ndarray` type.
 3023: 
 3024:     Examples
 3025:     --------
 3026:     >>> from typing import Any
 3027:     >>> import numpy as np
 3028: 
 3029:     >>> np.ndarray[Any, np.dtype[np.uint8]]
 3030:     numpy.ndarray[typing.Any, numpy.dtype[numpy.uint8]]
 3031: 
 3032:     See Also
 3033:     --------
 3034:     :pep:`585` : Type hinting generics in standard collections.
 3035:     numpy.typing.NDArray : An ndarray alias :term:`generic <generic type>`
 3036:                         w.r.t. its `dtype.type <numpy.dtype.type>`.
 3037: 
 3038:     """))
 3039: 
 3040: 
 3041: add_newdoc('numpy._core.multiarray', 'ndarray', ('__deepcopy__',
 3042:     """
 3043:     a.__deepcopy__(memo, /)
 3044: 
 3045:     Used if :func:`copy.deepcopy` is called on an array.
 3046: 
 3047:     """))
 3048: 
 3049: 
 3050: add_newdoc('numpy._core.multiarray', 'ndarray', ('__reduce__',
 3051:     """
 3052:     a.__reduce__()
 3053: 
 3054:     For pickling.
 3055: 
 3056:     """))
 3057: 
 3058: 
 3059: add_newdoc('numpy._core.multiarray', 'ndarray', ('__setstate__',
 3060:     """
 3061:     a.__setstate__(state, /)
 3062: 
 3063:     For unpickling.
 3064: 
 3065:     The `state` argument must be a sequence that contains the following
 3066:     elements:
 3067: 
 3068:     Parameters
 3069:     ----------
 3070:     version : int
 3071:         optional pickle version. If omitted defaults to 0.
 3072:     shape : tuple
 3073:     dtype : data-type
 3074:     isFortran : bool
 3075:     rawdata : string or list
 3076:         a binary string with the data (or a list if 'a' is an object array)
 3077: 
 3078:     """))
 3079: 
 3080: 
 3081: add_newdoc('numpy._core.multiarray', 'ndarray', ('all',
 3082:     """
 3083:     a.all(axis=None, out=None, keepdims=False, *, where=True)
 3084: 
 3085:     Returns True if all elements evaluate to True.
 3086: 
 3087:     Refer to `numpy.all` for full documentation.
 3088: 
 3089:     See Also
 3090:     --------
 3091:     numpy.all : equivalent function
 3092: 
 3093:     """))
 3094: 
 3095: 
 3096: add_newdoc('numpy._core.multiarray', 'ndarray', ('any',
 3097:     """
 3098:     a.any(axis=None, out=None, keepdims=False, *, where=True)
 3099: 
 3100:     Returns True if any of the elements of `a` evaluate to True.
 3101: 
 3102:     Refer to `numpy.any` for full documentation.
 3103: 
 3104:     See Also
 3105:     --------
 3106:     numpy.any : equivalent function
 3107: 
 3108:     """))
 3109: 
 3110: 
 3111: add_newdoc('numpy._core.multiarray', 'ndarray', ('argmax',
 3112:     """
 3113:     a.argmax(axis=None, out=None, *, keepdims=False)
 3114: 
 3115:     Return indices of the maximum values along the given axis.
 3116: 
 3117:     Refer to `numpy.argmax` for full documentation.
 3118: 
 3119:     See Also
 3120:     --------
 3121:     numpy.argmax : equivalent function
 3122: 
 3123:     """))
 3124: 
 3125: 
 3126: add_newdoc('numpy._core.multiarray', 'ndarray', ('argmin',
 3127:     """
 3128:     a.argmin(axis=None, out=None, *, keepdims=False)
 3129: 
 3130:     Return indices of the minimum values along the given axis.
 3131: 
 3132:     Refer to `numpy.argmin` for detailed documentation.
 3133: 
 3134:     See Also
 3135:     --------
 3136:     numpy.argmin : equivalent function
 3137: 
 3138:     """))
 3139: 
 3140: 
 3141: add_newdoc('numpy._core.multiarray', 'ndarray', ('argsort',
 3142:     """
 3143:     a.argsort(axis=-1, kind=None, order=None)
 3144: 
 3145:     Returns the indices that would sort this array.
 3146: 
 3147:     Refer to `numpy.argsort` for full documentation.
 3148: 
 3149:     See Also
 3150:     --------
 3151:     numpy.argsort : equivalent function
 3152: 
 3153:     """))
 3154: 
 3155: 
 3156: add_newdoc('numpy._core.multiarray', 'ndarray', ('argpartition',
 3157:     """
 3158:     a.argpartition(kth, axis=-1, kind='introselect', order=None)
 3159: 
 3160:     Returns the indices that would partition this array.
 3161: 
 3162:     Refer to `numpy.argpartition` for full documentation.
 3163: 
 3164:     See Also
 3165:     --------
 3166:     numpy.argpartition : equivalent function
 3167: 
 3168:     """))
 3169: 
 3170: 
 3171: add_newdoc('numpy._core.multiarray', 'ndarray', ('astype',
 3172:     """
 3173:     a.astype(dtype, order='K', casting='unsafe', subok=True, copy=True)
 3174: 
 3175:     Copy of the array, cast to a specified type.
 3176: 
 3177:     Parameters
 3178:     ----------
 3179:     dtype : str or dtype
 3180:         Typecode or data-type to which the array is cast.
 3181:     order : {'C', 'F', 'A', 'K'}, optional
 3182:         Controls the memory layout order of the result.
 3183:         'C' means C order, 'F' means Fortran order, 'A'
 3184:         means 'F' order if all the arrays are Fortran contiguous,
 3185:         'C' order otherwise, and 'K' means as close to the
 3186:         order the array elements appear in memory as possible.
 3187:         Default is 'K'.
 3188:     casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
 3189:         Controls what kind of data casting may occur. Defaults to 'unsafe'
 3190:         for backwards compatibility.
 3191: 
 3192:         * 'no' means the data types should not be cast at all.
 3193:         * 'equiv' means only byte-order changes are allowed.
 3194:         * 'safe' means only casts which can preserve values are allowed.
 3195:         * 'same_kind' means only safe casts or casts within a kind,
 3196:           like float64 to float32, are allowed.
 3197:         * 'unsafe' means any data conversions may be done.
 3198:     subok : bool, optional
 3199:         If True, then sub-classes will be passed-through (default), otherwise
 3200:         the returned array will be forced to be a base-class array.
 3201:     copy : bool, optional
 3202:         By default, astype always returns a newly allocated array. If this
 3203:         is set to false, and the `dtype`, `order`, and `subok`
 3204:         requirements are satisfied, the input array is returned instead
 3205:         of a copy.
 3206: 
 3207:     Returns
 3208:     -------
 3209:     arr_t : ndarray
 3210:         Unless `copy` is False and the other conditions for returning the input
 3211:         array are satisfied (see description for `copy` input parameter), `arr_t`
 3212:         is a new array of the same shape as the input array, with dtype, order
 3213:         given by `dtype`, `order`.
 3214: 
 3215:     Raises
 3216:     ------
 3217:     ComplexWarning
 3218:         When casting from complex to float or int. To avoid this,
 3219:         one should use ``a.real.astype(t)``.
 3220: 
 3221:     Examples
 3222:     --------
 3223:     >>> import numpy as np
 3224:     >>> x = np.array([1, 2, 2.5])
 3225:     >>> x
 3226:     array([1. ,  2. ,  2.5])
 3227: 
 3228:     >>> x.astype(int)
 3229:     array([1, 2, 2])
 3230: 
 3231:     """))
 3232: 
 3233: 
 3234: add_newdoc('numpy._core.multiarray', 'ndarray', ('byteswap',
 3235:     """
 3236:     a.byteswap(inplace=False)
 3237: 
 3238:     Swap the bytes of the array elements
 3239: 
 3240:     Toggle between low-endian and big-endian data representation by
 3241:     returning a byteswapped array, optionally swapped in-place.
 3242:     Arrays of byte-strings are not swapped. The real and imaginary
 3243:     parts of a complex number are swapped individually.
 3244: 
 3245:     Parameters
 3246:     ----------
 3247:     inplace : bool, optional
 3248:         If ``True``, swap bytes in-place, default is ``False``.
 3249: 
 3250:     Returns
 3251:     -------
 3252:     out : ndarray
 3253:         The byteswapped array. If `inplace` is ``True``, this is
 3254:         a view to self.
 3255: 
 3256:     Examples
 3257:     --------
 3258:     >>> import numpy as np
 3259:     >>> A = np.array([1, 256, 8755], dtype=np.int16)
 3260:     >>> list(map(hex, A))
 3261:     ['0x1', '0x100', '0x2233']
 3262:     >>> A.byteswap(inplace=True)
 3263:     array([  256,     1, 13090], dtype=int16)
 3264:     >>> list(map(hex, A))
 3265:     ['0x100', '0x1', '0x3322']
 3266: 
 3267:     Arrays of byte-strings are not swapped
 3268: 
 3269:     >>> A = np.array([b'ceg', b'fac'])
 3270:     >>> A.byteswap()
 3271:     array([b'ceg', b'fac'], dtype='|S3')
 3272: 
 3273:     ``A.view(A.dtype.newbyteorder()).byteswap()`` produces an array with
 3274:     the same values but different representation in memory
 3275: 
 3276:     >>> A = np.array([1, 2, 3],dtype=np.int64)
 3277:     >>> A.view(np.uint8)
 3278:     array([1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,
 3279:            0, 0], dtype=uint8)
 3280:     >>> A.view(A.dtype.newbyteorder()).byteswap(inplace=True)
 3281:     array([1, 2, 3], dtype='>i8')
 3282:     >>> A.view(np.uint8)
 3283:     array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,
 3284:            0, 3], dtype=uint8)
 3285: 
 3286:     """))
 3287: 
 3288: 
 3289: add_newdoc('numpy._core.multiarray', 'ndarray', ('choose',
 3290:     """
 3291:     a.choose(choices, out=None, mode='raise')
 3292: 
 3293:     Use an index array to construct a new array from a set of choices.
 3294: 
 3295:     Refer to `numpy.choose` for full documentation.
 3296: 
 3297:     See Also
 3298:     --------
 3299:     numpy.choose : equivalent function
 3300: 
 3301:     """))
 3302: 
 3303: 
 3304: add_newdoc('numpy._core.multiarray', 'ndarray', ('clip',
 3305:     """
 3306:     a.clip(min=None, max=None, out=None, **kwargs)
 3307: 
 3308:     Return an array whose values are limited to ``[min, max]``.
 3309:     One of max or min must be given.
 3310: 
 3311:     Refer to `numpy.clip` for full documentation.
 3312: 
 3313:     See Also
 3314:     --------
 3315:     numpy.clip : equivalent function
 3316: 
 3317:     """))
 3318: 
 3319: 
 3320: add_newdoc('numpy._core.multiarray', 'ndarray', ('compress',
 3321:     """
 3322:     a.compress(condition, axis=None, out=None)
 3323: 
 3324:     Return selected slices of this array along given axis.
 3325: 
 3326:     Refer to `numpy.compress` for full documentation.
 3327: 
 3328:     See Also
 3329:     --------
 3330:     numpy.compress : equivalent function
 3331: 
 3332:     """))
 3333: 
 3334: 
 3335: add_newdoc('numpy._core.multiarray', 'ndarray', ('conj',
 3336:     """
 3337:     a.conj()
 3338: 
 3339:     Complex-conjugate all elements.
 3340: 
 3341:     Refer to `numpy.conjugate` for full documentation.
 3342: 
 3343:     See Also
 3344:     --------
 3345:     numpy.conjugate : equivalent function
 3346: 
 3347:     """))
 3348: 
 3349: 
 3350: add_newdoc('numpy._core.multiarray', 'ndarray', ('conjugate',
 3351:     """
 3352:     a.conjugate()
 3353: 
 3354:     Return the complex conjugate, element-wise.
 3355: 
 3356:     Refer to `numpy.conjugate` for full documentation.
 3357: 
 3358:     See Also
 3359:     --------
 3360:     numpy.conjugate : equivalent function
 3361: 
 3362:     """))
 3363: 
 3364: 
 3365: add_newdoc('numpy._core.multiarray', 'ndarray', ('copy',
 3366:     """
 3367:     a.copy(order='C')
 3368: 
 3369:     Return a copy of the array.
 3370: 
 3371:     Parameters
 3372:     ----------
 3373:     order : {'C', 'F', 'A', 'K'}, optional
 3374:         Controls the memory layout of the copy. 'C' means C-order,
 3375:         'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,
 3376:         'C' otherwise. 'K' means match the layout of `a` as closely
 3377:         as possible. (Note that this function and :func:`numpy.copy` are very
 3378:         similar but have different default values for their order=
 3379:         arguments, and this function always passes sub-classes through.)
 3380: 
 3381:     See also
 3382:     --------
 3383:     numpy.copy : Similar function with different default behavior
 3384:     numpy.copyto
 3385: 
 3386:     Notes
 3387:     -----
 3388:     This function is the preferred method for creating an array copy.  The
 3389:     function :func:`numpy.copy` is similar, but it defaults to using order 'K',
 3390:     and will not pass sub-classes through by default.
 3391: 
 3392:     Examples
 3393:     --------
 3394:     >>> import numpy as np
 3395:     >>> x = np.array([[1,2,3],[4,5,6]], order='F')
 3396: 
 3397:     >>> y = x.copy()
 3398: 
 3399:     >>> x.fill(0)
 3400: 
 3401:     >>> x
 3402:     array([[0, 0, 0],
 3403:            [0, 0, 0]])
 3404: 
 3405:     >>> y
 3406:     array([[1, 2, 3],
 3407:            [4, 5, 6]])
 3408: 
 3409:     >>> y.flags['C_CONTIGUOUS']
 3410:     True
 3411: 
 3412:     For arrays containing Python objects (e.g. dtype=object),
 3413:     the copy is a shallow one. The new array will contain the
 3414:     same object which may lead to surprises if that object can
 3415:     be modified (is mutable):
 3416: 
 3417:     >>> a = np.array([1, 'm', [2, 3, 4]], dtype=object)
 3418:     >>> b = a.copy()
 3419:     >>> b[2][0] = 10
 3420:     >>> a
 3421:     array([1, 'm', list([10, 3, 4])], dtype=object)
 3422: 
 3423:     To ensure all elements within an ``object`` array are copied,
 3424:     use `copy.deepcopy`:
 3425: 
 3426:     >>> import copy
 3427:     >>> a = np.array([1, 'm', [2, 3, 4]], dtype=object)
 3428:     >>> c = copy.deepcopy(a)
 3429:     >>> c[2][0] = 10
 3430:     >>> c
 3431:     array([1, 'm', list([10, 3, 4])], dtype=object)
 3432:     >>> a
 3433:     array([1, 'm', list([2, 3, 4])], dtype=object)
 3434: 
 3435:     """))
 3436: 
 3437: 
 3438: add_newdoc('numpy._core.multiarray', 'ndarray', ('cumprod',
 3439:     """
 3440:     a.cumprod(axis=None, dtype=None, out=None)
 3441: 
 3442:     Return the cumulative product of the elements along the given axis.
 3443: 
 3444:     Refer to `numpy.cumprod` for full documentation.
 3445: 
 3446:     See Also
 3447:     --------
 3448:     numpy.cumprod : equivalent function
 3449: 
 3450:     """))
 3451: 
 3452: 
 3453: add_newdoc('numpy._core.multiarray', 'ndarray', ('cumsum',
 3454:     """
 3455:     a.cumsum(axis=None, dtype=None, out=None)
 3456: 
 3457:     Return the cumulative sum of the elements along the given axis.
 3458: 
 3459:     Refer to `numpy.cumsum` for full documentation.
 3460: 
 3461:     See Also
 3462:     --------
 3463:     numpy.cumsum : equivalent function
 3464: 
 3465:     """))
 3466: 
 3467: 
 3468: add_newdoc('numpy._core.multiarray', 'ndarray', ('diagonal',
 3469:     """
 3470:     a.diagonal(offset=0, axis1=0, axis2=1)
 3471: 
 3472:     Return specified diagonals. In NumPy 1.9 the returned array is a
 3473:     read-only view instead of a copy as in previous NumPy versions.  In
 3474:     a future version the read-only restriction will be removed.
 3475: 
 3476:     Refer to :func:`numpy.diagonal` for full documentation.
 3477: 
 3478:     See Also
 3479:     --------
 3480:     numpy.diagonal : equivalent function
 3481: 
 3482:     """))
 3483: 
 3484: 
 3485: add_newdoc('numpy._core.multiarray', 'ndarray', ('dot'))
 3486: 
 3487: 
 3488: add_newdoc('numpy._core.multiarray', 'ndarray', ('dump',
 3489:     """
 3490:     a.dump(file)
 3491: 
 3492:     Dump a pickle of the array to the specified file.
 3493:     The array can be read back with pickle.load or numpy.load.
 3494: 
 3495:     Parameters
 3496:     ----------
 3497:     file : str or Path
 3498:         A string naming the dump file.
 3499: 
 3500:     """))
 3501: 
 3502: 
 3503: add_newdoc('numpy._core.multiarray', 'ndarray', ('dumps',
 3504:     """
 3505:     a.dumps()
 3506: 
 3507:     Returns the pickle of the array as a string.
 3508:     pickle.loads will convert the string back to an array.
 3509: 
 3510:     Parameters
 3511:     ----------
 3512:     None
 3513: 
 3514:     """))
 3515: 
 3516: 
 3517: add_newdoc('numpy._core.multiarray', 'ndarray', ('fill',
 3518:     """
 3519:     a.fill(value)
 3520: 
 3521:     Fill the array with a scalar value.
 3522: 
 3523:     Parameters
 3524:     ----------
 3525:     value : scalar
 3526:         All elements of `a` will be assigned this value.
 3527: 
 3528:     Examples
 3529:     --------
 3530:     >>> import numpy as np
 3531:     >>> a = np.array([1, 2])
 3532:     >>> a.fill(0)
 3533:     >>> a
 3534:     array([0, 0])
 3535:     >>> a = np.empty(2)
 3536:     >>> a.fill(1)
 3537:     >>> a
 3538:     array([1.,  1.])
 3539: 
 3540:     Fill expects a scalar value and always behaves the same as assigning
 3541:     to a single array element.  The following is a rare example where this
 3542:     distinction is important:
 3543: 
 3544:     >>> a = np.array([None, None], dtype=object)
 3545:     >>> a[0] = np.array(3)
 3546:     >>> a
 3547:     array([array(3), None], dtype=object)
 3548:     >>> a.fill(np.array(3))
 3549:     >>> a
 3550:     array([array(3), array(3)], dtype=object)
 3551: 
 3552:     Where other forms of assignments will unpack the array being assigned:
 3553: 
 3554:     >>> a[...] = np.array(3)
 3555:     >>> a
 3556:     array([3, 3], dtype=object)
 3557: 
 3558:     """))
 3559: 
 3560: 
 3561: add_newdoc('numpy._core.multiarray', 'ndarray', ('flatten',
 3562:     """
 3563:     a.flatten(order='C')
 3564: 
 3565:     Return a copy of the array collapsed into one dimension.
 3566: 
 3567:     Parameters
 3568:     ----------
 3569:     order : {'C', 'F', 'A', 'K'}, optional
 3570:         'C' means to flatten in row-major (C-style) order.
 3571:         'F' means to flatten in column-major (Fortran-
 3572:         style) order. 'A' means to flatten in column-major
 3573:         order if `a` is Fortran *contiguous* in memory,
 3574:         row-major order otherwise. 'K' means to flatten
 3575:         `a` in the order the elements occur in memory.
 3576:         The default is 'C'.
 3577: 
 3578:     Returns
 3579:     -------
 3580:     y : ndarray
 3581:         A copy of the input array, flattened to one dimension.
 3582: 
 3583:     See Also
 3584:     --------
 3585:     ravel : Return a flattened array.
 3586:     flat : A 1-D flat iterator over the array.
 3587: 
 3588:     Examples
 3589:     --------
 3590:     >>> import numpy as np
 3591:     >>> a = np.array([[1,2], [3,4]])
 3592:     >>> a.flatten()
 3593:     array([1, 2, 3, 4])
 3594:     >>> a.flatten('F')
 3595:     array([1, 3, 2, 4])
 3596: 
 3597:     """))
 3598: 
 3599: 
 3600: add_newdoc('numpy._core.multiarray', 'ndarray', ('getfield',
 3601:     """
 3602:     a.getfield(dtype, offset=0)
 3603: 
 3604:     Returns a field of the given array as a certain type.
 3605: 
 3606:     A field is a view of the array data with a given data-type. The values in
 3607:     the view are determined by the given type and the offset into the current
 3608:     array in bytes. The offset needs to be such that the view dtype fits in the
 3609:     array dtype; for example an array of dtype complex128 has 16-byte elements.
 3610:     If taking a view with a 32-bit integer (4 bytes), the offset needs to be
 3611:     between 0 and 12 bytes.
 3612: 
 3613:     Parameters
 3614:     ----------
 3615:     dtype : str or dtype
 3616:         The data type of the view. The dtype size of the view can not be larger
 3617:         than that of the array itself.
 3618:     offset : int
 3619:         Number of bytes to skip before beginning the element view.
 3620: 
 3621:     Examples
 3622:     --------
 3623:     >>> import numpy as np
 3624:     >>> x = np.diag([1.+1.j]*2)
 3625:     >>> x[1, 1] = 2 + 4.j
 3626:     >>> x
 3627:     array([[1.+1.j,  0.+0.j],
 3628:            [0.+0.j,  2.+4.j]])
 3629:     >>> x.getfield(np.float64)
 3630:     array([[1.,  0.],
 3631:            [0.,  2.]])
 3632: 
 3633:     By choosing an offset of 8 bytes we can select the complex part of the
 3634:     array for our view:
 3635: 
 3636:     >>> x.getfield(np.float64, offset=8)
 3637:     array([[1.,  0.],
 3638:            [0.,  4.]])
 3639: 
 3640:     """))
 3641: 
 3642: 
 3643: add_newdoc('numpy._core.multiarray', 'ndarray', ('item',
 3644:     """
 3645:     a.item(*args)
 3646: 
 3647:     Copy an element of an array to a standard Python scalar and return it.
 3648: 
 3649:     Parameters
 3650:     ----------
 3651:     \\*args : Arguments (variable number and type)
 3652: 
 3653:         * none: in this case, the method only works for arrays
 3654:           with one element (`a.size == 1`), which element is
 3655:           copied into a standard Python scalar object and returned.
 3656: 
 3657:         * int_type: this argument is interpreted as a flat index into
 3658:           the array, specifying which element to copy and return.
 3659: 
 3660:         * tuple of int_types: functions as does a single int_type argument,
 3661:           except that the argument is interpreted as an nd-index into the
 3662:           array.
 3663: 
 3664:     Returns
 3665:     -------
 3666:     z : Standard Python scalar object
 3667:         A copy of the specified element of the array as a suitable
 3668:         Python scalar
 3669: 
 3670:     Notes
 3671:     -----
 3672:     When the data type of `a` is longdouble or clongdouble, item() returns
 3673:     a scalar array object because there is no available Python scalar that
 3674:     would not lose information. Void arrays return a buffer object for item(),
 3675:     unless fields are defined, in which case a tuple is returned.
 3676: 
 3677:     `item` is very similar to a[args], except, instead of an array scalar,
 3678:     a standard Python scalar is returned. This can be useful for speeding up
 3679:     access to elements of the array and doing arithmetic on elements of the
 3680:     array using Python's optimized math.
 3681: 
 3682:     Examples
 3683:     --------
 3684:     >>> import numpy as np
 3685:     >>> np.random.seed(123)
 3686:     >>> x = np.random.randint(9, size=(3, 3))
 3687:     >>> x
 3688:     array([[2, 2, 6],
 3689:            [1, 3, 6],
 3690:            [1, 0, 1]])
 3691:     >>> x.item(3)
 3692:     1
 3693:     >>> x.item(7)
 3694:     0
 3695:     >>> x.item((0, 1))
 3696:     2
 3697:     >>> x.item((2, 2))
 3698:     1
 3699: 
 3700:     For an array with object dtype, elements are returned as-is.
 3701: 
 3702:     >>> a = np.array([np.int64(1)], dtype=object)
 3703:     >>> a.item() #return np.int64
 3704:     np.int64(1)
 3705: 
 3706:     """))
 3707: 
 3708: 
 3709: add_newdoc('numpy._core.multiarray', 'ndarray', ('max',
 3710:     """
 3711:     a.max(axis=None, out=None, keepdims=False, initial=<no value>, where=True)
 3712: 
 3713:     Return the maximum along a given axis.
 3714: 
 3715:     Refer to `numpy.amax` for full documentation.
 3716: 
 3717:     See Also
 3718:     --------
 3719:     numpy.amax : equivalent function
 3720: 
 3721:     """))
 3722: 
 3723: 
 3724: add_newdoc('numpy._core.multiarray', 'ndarray', ('mean',
 3725:     """
 3726:     a.mean(axis=None, dtype=None, out=None, keepdims=False, *, where=True)
 3727: 
 3728:     Returns the average of the array elements along given axis.
 3729: 
 3730:     Refer to `numpy.mean` for full documentation.
 3731: 
 3732:     See Also
 3733:     --------
 3734:     numpy.mean : equivalent function
 3735: 
 3736:     """))
 3737: 
 3738: 
 3739: add_newdoc('numpy._core.multiarray', 'ndarray', ('min',
 3740:     """
 3741:     a.min(axis=None, out=None, keepdims=False, initial=<no value>, where=True)
 3742: 
 3743:     Return the minimum along a given axis.
 3744: 
 3745:     Refer to `numpy.amin` for full documentation.
 3746: 
 3747:     See Also
 3748:     --------
 3749:     numpy.amin : equivalent function
 3750: 
 3751:     """))
 3752: 
 3753: 
 3754: add_newdoc('numpy._core.multiarray', 'ndarray', ('nonzero',
 3755:     """
 3756:     a.nonzero()
 3757: 
 3758:     Return the indices of the elements that are non-zero.
 3759: 
 3760:     Refer to `numpy.nonzero` for full documentation.
 3761: 
 3762:     See Also
 3763:     --------
 3764:     numpy.nonzero : equivalent function
 3765: 
 3766:     """))
 3767: 
 3768: 
 3769: add_newdoc('numpy._core.multiarray', 'ndarray', ('prod',
 3770:     """
 3771:     a.prod(axis=None, dtype=None, out=None, keepdims=False,
 3772:         initial=1, where=True)
 3773: 
 3774:     Return the product of the array elements over the given axis
 3775: 
 3776:     Refer to `numpy.prod` for full documentation.
 3777: 
 3778:     See Also
 3779:     --------
 3780:     numpy.prod : equivalent function
 3781: 
 3782:     """))
 3783: 
 3784: 
 3785: add_newdoc('numpy._core.multiarray', 'ndarray', ('put',
 3786:     """
 3787:     a.put(indices, values, mode='raise')
 3788: 
 3789:     Set ``a.flat[n] = values[n]`` for all `n` in indices.
 3790: 
 3791:     Refer to `numpy.put` for full documentation.
 3792: 
 3793:     See Also
 3794:     --------
 3795:     numpy.put : equivalent function
 3796: 
 3797:     """))
 3798: 
 3799: 
 3800: add_newdoc('numpy._core.multiarray', 'ndarray', ('ravel',
 3801:     """
 3802:     a.ravel([order])
 3803: 
 3804:     Return a flattened array.
 3805: 
 3806:     Refer to `numpy.ravel` for full documentation.
 3807: 
 3808:     See Also
 3809:     --------
 3810:     numpy.ravel : equivalent function
 3811: 
 3812:     ndarray.flat : a flat iterator on the array.
 3813: 
 3814:     """))
 3815: 
 3816: 
 3817: add_newdoc('numpy._core.multiarray', 'ndarray', ('repeat',
 3818:     """
 3819:     a.repeat(repeats, axis=None)
 3820: 
 3821:     Repeat elements of an array.
 3822: 
 3823:     Refer to `numpy.repeat` for full documentation.
 3824: 
 3825:     See Also
 3826:     --------
 3827:     numpy.repeat : equivalent function
 3828: 
 3829:     """))
 3830: 
 3831: 
 3832: add_newdoc('numpy._core.multiarray', 'ndarray', ('reshape',
 3833:     """
 3834:     a.reshape(shape, /, *, order='C', copy=None)
 3835: 
 3836:     Returns an array containing the same data with a new shape.
 3837: 
 3838:     Refer to `numpy.reshape` for full documentation.
 3839: 
 3840:     See Also
 3841:     --------
 3842:     numpy.reshape : equivalent function
 3843: 
 3844:     Notes
 3845:     -----
 3846:     Unlike the free function `numpy.reshape`, this method on `ndarray` allows
 3847:     the elements of the shape parameter to be passed in as separate arguments.
 3848:     For example, ``a.reshape(10, 11)`` is equivalent to
 3849:     ``a.reshape((10, 11))``.
 3850: 
 3851:     """))
 3852: 
 3853: 
 3854: add_newdoc('numpy._core.multiarray', 'ndarray', ('resize',
 3855:     """
 3856:     a.resize(new_shape, refcheck=True)
 3857: 
 3858:     Change shape and size of array in-place.
 3859: 
 3860:     Parameters
 3861:     ----------
 3862:     new_shape : tuple of ints, or `n` ints
 3863:         Shape of resized array.
 3864:     refcheck : bool, optional
 3865:         If False, reference count will not be checked. Default is True.
 3866: 
 3867:     Returns
 3868:     -------
 3869:     None
 3870: 
 3871:     Raises
 3872:     ------
 3873:     ValueError
 3874:         If `a` does not own its own data or references or views to it exist,
 3875:         and the data memory must be changed.
 3876:         PyPy only: will always raise if the data memory must be changed, since
 3877:         there is no reliable way to determine if references or views to it
 3878:         exist.
 3879: 
 3880:     SystemError
 3881:         If the `order` keyword argument is specified. This behaviour is a
 3882:         bug in NumPy.
 3883: 
 3884:     See Also
 3885:     --------
 3886:     resize : Return a new array with the specified shape.
 3887: 
 3888:     Notes
 3889:     -----
 3890:     This reallocates space for the data area if necessary.
 3891: 
 3892:     Only contiguous arrays (data elements consecutive in memory) can be
 3893:     resized.
 3894: 
 3895:     The purpose of the reference count check is to make sure you
 3896:     do not use this array as a buffer for another Python object and then
 3897:     reallocate the memory. However, reference counts can increase in
 3898:     other ways so if you are sure that you have not shared the memory
 3899:     for this array with another Python object, then you may safely set
 3900:     `refcheck` to False.
 3901: 
 3902:     Examples
 3903:     --------
 3904:     Shrinking an array: array is flattened (in the order that the data are
 3905:     stored in memory), resized, and reshaped:
 3906: 
 3907:     >>> import numpy as np
 3908: 
 3909:     >>> a = np.array([[0, 1], [2, 3]], order='C')
 3910:     >>> a.resize((2, 1))
 3911:     >>> a
 3912:     array([[0],
 3913:            [1]])
 3914: 
 3915:     >>> a = np.array([[0, 1], [2, 3]], order='F')
 3916:     >>> a.resize((2, 1))
 3917:     >>> a
 3918:     array([[0],
 3919:            [2]])
 3920: 
 3921:     Enlarging an array: as above, but missing entries are filled with zeros:
 3922: 
 3923:     >>> b = np.array([[0, 1], [2, 3]])
 3924:     >>> b.resize(2, 3) # new_shape parameter doesn't have to be a tuple
 3925:     >>> b
 3926:     array([[0, 1, 2],
 3927:            [3, 0, 0]])
 3928: 
 3929:     Referencing an array prevents resizing...
 3930: 
 3931:     >>> c = a
 3932:     >>> a.resize((1, 1))
 3933:     Traceback (most recent call last):
 3934:     ...
 3935:     ValueError: cannot resize an array that references or is referenced ...
 3936: 
 3937:     Unless `refcheck` is False:
 3938: 
 3939:     >>> a.resize((1, 1), refcheck=False)
 3940:     >>> a
 3941:     array([[0]])
 3942:     >>> c
 3943:     array([[0]])
 3944: 
 3945:     """))
 3946: 
 3947: 
 3948: add_newdoc('numpy._core.multiarray', 'ndarray', ('round',
 3949:     """
 3950:     a.round(decimals=0, out=None)
 3951: 
 3952:     Return `a` with each element rounded to the given number of decimals.
 3953: 
 3954:     Refer to `numpy.around` for full documentation.
 3955: 
 3956:     See Also
 3957:     --------
 3958:     numpy.around : equivalent function
 3959: 
 3960:     """))
 3961: 
 3962: 
 3963: add_newdoc('numpy._core.multiarray', 'ndarray', ('searchsorted',
 3964:     """
 3965:     a.searchsorted(v, side='left', sorter=None)
 3966: 
 3967:     Find indices where elements of v should be inserted in a to maintain order.
 3968: 
 3969:     For full documentation, see `numpy.searchsorted`
 3970: 
 3971:     See Also
 3972:     --------
 3973:     numpy.searchsorted : equivalent function
 3974: 
 3975:     """))
 3976: 
 3977: 
 3978: add_newdoc('numpy._core.multiarray', 'ndarray', ('setfield',
 3979:     """
 3980:     a.setfield(val, dtype, offset=0)
 3981: 
 3982:     Put a value into a specified place in a field defined by a data-type.
 3983: 
 3984:     Place `val` into `a`'s field defined by `dtype` and beginning `offset`
 3985:     bytes into the field.
 3986: 
 3987:     Parameters
 3988:     ----------
 3989:     val : object
 3990:         Value to be placed in field.
 3991:     dtype : dtype object
 3992:         Data-type of the field in which to place `val`.
 3993:     offset : int, optional
 3994:         The number of bytes into the field at which to place `val`.
 3995: 
 3996:     Returns
 3997:     -------
 3998:     None
 3999: 
 4000:     See Also
 4001:     --------
 4002:     getfield
 4003: 
 4004:     Examples
 4005:     --------
 4006:     >>> import numpy as np
 4007:     >>> x = np.eye(3)
 4008:     >>> x.getfield(np.float64)
 4009:     array([[1.,  0.,  0.],
 4010:            [0.,  1.,  0.],
 4011:            [0.,  0.,  1.]])
 4012:     >>> x.setfield(3, np.int32)
 4013:     >>> x.getfield(np.int32)
 4014:     array([[3, 3, 3],
 4015:            [3, 3, 3],
 4016:            [3, 3, 3]], dtype=int32)
 4017:     >>> x
 4018:     array([[1.0e+000, 1.5e-323, 1.5e-323],
 4019:            [1.5e-323, 1.0e+000, 1.5e-323],
 4020:            [1.5e-323, 1.5e-323, 1.0e+000]])
 4021:     >>> x.setfield(np.eye(3), np.int32)
 4022:     >>> x
 4023:     array([[1.,  0.,  0.],
 4024:            [0.,  1.,  0.],
 4025:            [0.,  0.,  1.]])
 4026: 
 4027:     """))
 4028: 
 4029: 
 4030: add_newdoc('numpy._core.multiarray', 'ndarray', ('setflags',
 4031:     """
 4032:     a.setflags(write=None, align=None, uic=None)
 4033: 
 4034:     Set array flags WRITEABLE, ALIGNED, WRITEBACKIFCOPY,
 4035:     respectively.
 4036: 
 4037:     These Boolean-valued flags affect how numpy interprets the memory
 4038:     area used by `a` (see Notes below). The ALIGNED flag can only
 4039:     be set to True if the data is actually aligned according to the type.
 4040:     The WRITEBACKIFCOPY flag can never be set
 4041:     to True. The flag WRITEABLE can only be set to True if the array owns its
 4042:     own memory, or the ultimate owner of the memory exposes a writeable buffer
 4043:     interface, or is a string. (The exception for string is made so that
 4044:     unpickling can be done without copying memory.)
 4045: 
 4046:     Parameters
 4047:     ----------
 4048:     write : bool, optional
 4049:         Describes whether or not `a` can be written to.
 4050:     align : bool, optional
 4051:         Describes whether or not `a` is aligned properly for its type.
 4052:     uic : bool, optional
 4053:         Describes whether or not `a` is a copy of another "base" array.
 4054: 
 4055:     Notes
 4056:     -----
 4057:     Array flags provide information about how the memory area used
 4058:     for the array is to be interpreted. There are 7 Boolean flags
 4059:     in use, only three of which can be changed by the user:
 4060:     WRITEBACKIFCOPY, WRITEABLE, and ALIGNED.
 4061: 
 4062:     WRITEABLE (W) the data area can be written to;
 4063: 
 4064:     ALIGNED (A) the data and strides are aligned appropriately for the hardware
 4065:     (as determined by the compiler);
 4066: 
 4067:     WRITEBACKIFCOPY (X) this array is a copy of some other array (referenced
 4068:     by .base). When the C-API function PyArray_ResolveWritebackIfCopy is
 4069:     called, the base array will be updated with the contents of this array.
 4070: 
 4071:     All flags can be accessed using the single (upper case) letter as well
 4072:     as the full name.
 4073: 
 4074:     Examples
 4075:     --------
 4076:     >>> import numpy as np
 4077:     >>> y = np.array([[3, 1, 7],
 4078:     ...               [2, 0, 0],
 4079:     ...               [8, 5, 9]])
 4080:     >>> y
 4081:     array([[3, 1, 7],
 4082:            [2, 0, 0],
 4083:            [8, 5, 9]])
 4084:     >>> y.flags
 4085:       C_CONTIGUOUS : True
 4086:       F_CONTIGUOUS : False
 4087:       OWNDATA : True
 4088:       WRITEABLE : True
 4089:       ALIGNED : True
 4090:       WRITEBACKIFCOPY : False
 4091:     >>> y.setflags(write=0, align=0)
 4092:     >>> y.flags
 4093:       C_CONTIGUOUS : True
 4094:       F_CONTIGUOUS : False
 4095:       OWNDATA : True
 4096:       WRITEABLE : False
 4097:       ALIGNED : False
 4098:       WRITEBACKIFCOPY : False
 4099:     >>> y.setflags(uic=1)
 4100:     Traceback (most recent call last):
 4101:       File "<stdin>", line 1, in <module>
 4102:     ValueError: cannot set WRITEBACKIFCOPY flag to True
 4103: 
 4104:     """))
 4105: 
 4106: 
 4107: add_newdoc('numpy._core.multiarray', 'ndarray', ('sort',
 4108:     """
 4109:     a.sort(axis=-1, kind=None, order=None)
 4110: 
 4111:     Sort an array in-place. Refer to `numpy.sort` for full documentation.
 4112: 
 4113:     Parameters
 4114:     ----------
 4115:     axis : int, optional
 4116:         Axis along which to sort. Default is -1, which means sort along the
 4117:         last axis.
 4118:     kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional
 4119:         Sorting algorithm. The default is 'quicksort'. Note that both 'stable'
 4120:         and 'mergesort' use timsort under the covers and, in general, the
 4121:         actual implementation will vary with datatype. The 'mergesort' option
 4122:         is retained for backwards compatibility.
 4123:     order : str or list of str, optional
 4124:         When `a` is an array with fields defined, this argument specifies
 4125:         which fields to compare first, second, etc.  A single field can
 4126:         be specified as a string, and not all fields need be specified,
 4127:         but unspecified fields will still be used, in the order in which
 4128:         they come up in the dtype, to break ties.
 4129: 
 4130:     See Also
 4131:     --------
 4132:     numpy.sort : Return a sorted copy of an array.
 4133:     numpy.argsort : Indirect sort.
 4134:     numpy.lexsort : Indirect stable sort on multiple keys.
 4135:     numpy.searchsorted : Find elements in sorted array.
 4136:     numpy.partition: Partial sort.
 4137: 
 4138:     Notes
 4139:     -----
 4140:     See `numpy.sort` for notes on the different sorting algorithms.
 4141: 
 4142:     Examples
 4143:     --------
 4144:     >>> import numpy as np
 4145:     >>> a = np.array([[1,4], [3,1]])
 4146:     >>> a.sort(axis=1)
 4147:     >>> a
 4148:     array([[1, 4],
 4149:            [1, 3]])
 4150:     >>> a.sort(axis=0)
 4151:     >>> a
 4152:     array([[1, 3],
 4153:            [1, 4]])
 4154: 
 4155:     Use the `order` keyword to specify a field to use when sorting a
 4156:     structured array:
 4157: 
 4158:     >>> a = np.array([('a', 2), ('c', 1)], dtype=[('x', 'S1'), ('y', int)])
 4159:     >>> a.sort(order='y')
 4160:     >>> a
 4161:     array([(b'c', 1), (b'a', 2)],
 4162:           dtype=[('x', 'S1'), ('y', '<i8')])
 4163: 
 4164:     """))
 4165: 
 4166: 
 4167: add_newdoc('numpy._core.multiarray', 'ndarray', ('partition',
 4168:     """
 4169:     a.partition(kth, axis=-1, kind='introselect', order=None)
 4170: 
 4171:     Partially sorts the elements in the array in such a way that the value of
 4172:     the element in k-th position is in the position it would be in a sorted
 4173:     array. In the output array, all elements smaller than the k-th element
 4174:     are located to the left of this element and all equal or greater are
 4175:     located to its right. The ordering of the elements in the two partitions
 4176:     on the either side of the k-th element in the output array is undefined.
 4177: 
 4178:     Parameters
 4179:     ----------
 4180:     kth : int or sequence of ints
 4181:         Element index to partition by. The kth element value will be in its
 4182:         final sorted position and all smaller elements will be moved before it
 4183:         and all equal or greater elements behind it.
 4184:         The order of all elements in the partitions is undefined.
 4185:         If provided with a sequence of kth it will partition all elements
 4186:         indexed by kth of them into their sorted position at once.
 4187: 
 4188:         .. deprecated:: 1.22.0
 4189:             Passing booleans as index is deprecated.
 4190:     axis : int, optional
 4191:         Axis along which to sort. Default is -1, which means sort along the
 4192:         last axis.
 4193:     kind : {'introselect'}, optional
 4194:         Selection algorithm. Default is 'introselect'.
 4195:     order : str or list of str, optional
 4196:         When `a` is an array with fields defined, this argument specifies
 4197:         which fields to compare first, second, etc. A single field can
 4198:         be specified as a string, and not all fields need to be specified,
 4199:         but unspecified fields will still be used, in the order in which
 4200:         they come up in the dtype, to break ties.
 4201: 
 4202:     See Also
 4203:     --------
 4204:     numpy.partition : Return a partitioned copy of an array.
 4205:     argpartition : Indirect partition.
 4206:     sort : Full sort.
 4207: 
 4208:     Notes
 4209:     -----
 4210:     See ``np.partition`` for notes on the different algorithms.
 4211: 
 4212:     Examples
 4213:     --------
 4214:     >>> import numpy as np
 4215:     >>> a = np.array([3, 4, 2, 1])
 4216:     >>> a.partition(3)
 4217:     >>> a
 4218:     array([2, 1, 3, 4]) # may vary
 4219: 
 4220:     >>> a.partition((1, 3))
 4221:     >>> a
 4222:     array([1, 2, 3, 4])
 4223:     """))
 4224: 
 4225: 
 4226: add_newdoc('numpy._core.multiarray', 'ndarray', ('squeeze',
 4227:     """
 4228:     a.squeeze(axis=None)
 4229: 
 4230:     Remove axes of length one from `a`.
 4231: 
 4232:     Refer to `numpy.squeeze` for full documentation.
 4233: 
 4234:     See Also
 4235:     --------
 4236:     numpy.squeeze : equivalent function
 4237: 
 4238:     """))
 4239: 
 4240: 
 4241: add_newdoc('numpy._core.multiarray', 'ndarray', ('std',
 4242:     """
 4243:     a.std(axis=None, dtype=None, out=None, ddof=0, keepdims=False, *, where=True)
 4244: 
 4245:     Returns the standard deviation of the array elements along given axis.
 4246: 
 4247:     Refer to `numpy.std` for full documentation.
 4248: 
 4249:     See Also
 4250:     --------
 4251:     numpy.std : equivalent function
 4252: 
 4253:     """))
 4254: 
 4255: 
 4256: add_newdoc('numpy._core.multiarray', 'ndarray', ('sum',
 4257:     """
 4258:     a.sum(axis=None, dtype=None, out=None, keepdims=False, initial=0, where=True)
 4259: 
 4260:     Return the sum of the array elements over the given axis.
 4261: 
 4262:     Refer to `numpy.sum` for full documentation.
 4263: 
 4264:     See Also
 4265:     --------
 4266:     numpy.sum : equivalent function
 4267: 
 4268:     """))
 4269: 
 4270: 
 4271: add_newdoc('numpy._core.multiarray', 'ndarray', ('swapaxes',
 4272:     """
 4273:     a.swapaxes(axis1, axis2)
 4274: 
 4275:     Return a view of the array with `axis1` and `axis2` interchanged.
 4276: 
 4277:     Refer to `numpy.swapaxes` for full documentation.
 4278: 
 4279:     See Also
 4280:     --------
 4281:     numpy.swapaxes : equivalent function
 4282: 
 4283:     """))
 4284: 
 4285: 
 4286: add_newdoc('numpy._core.multiarray', 'ndarray', ('take',
 4287:     """
 4288:     a.take(indices, axis=None, out=None, mode='raise')
 4289: 
 4290:     Return an array formed from the elements of `a` at the given indices.
 4291: 
 4292:     Refer to `numpy.take` for full documentation.
 4293: 
 4294:     See Also
 4295:     --------
 4296:     numpy.take : equivalent function
 4297: 
 4298:     """))
 4299: 
 4300: 
 4301: add_newdoc('numpy._core.multiarray', 'ndarray', ('tofile',
 4302:     """
 4303:     a.tofile(fid, sep="", format="%s")
 4304: 
 4305:     Write array to a file as text or binary (default).
 4306: 
 4307:     Data is always written in 'C' order, independent of the order of `a`.
 4308:     The data produced by this method can be recovered using the function
 4309:     fromfile().
 4310: 
 4311:     Parameters
 4312:     ----------
 4313:     fid : file or str or Path
 4314:         An open file object, or a string containing a filename.
 4315:     sep : str
 4316:         Separator between array items for text output.
 4317:         If "" (empty), a binary file is written, equivalent to
 4318:         ``file.write(a.tobytes())``.
 4319:     format : str
 4320:         Format string for text file output.
 4321:         Each entry in the array is formatted to text by first converting
 4322:         it to the closest Python type, and then using "format" % item.
 4323: 
 4324:     Notes
 4325:     -----
 4326:     This is a convenience function for quick storage of array data.
 4327:     Information on endianness and precision is lost, so this method is not a
 4328:     good choice for files intended to archive data or transport data between
 4329:     machines with different endianness. Some of these problems can be overcome
 4330:     by outputting the data as text files, at the expense of speed and file
 4331:     size.
 4332: 
 4333:     When fid is a file object, array contents are directly written to the
 4334:     file, bypassing the file object's ``write`` method. As a result, tofile
 4335:     cannot be used with files objects supporting compression (e.g., GzipFile)
 4336:     or file-like objects that do not support ``fileno()`` (e.g., BytesIO).
 4337: 
 4338:     """))
 4339: 
 4340: 
 4341: add_newdoc('numpy._core.multiarray', 'ndarray', ('tolist',
 4342:     """
 4343:     a.tolist()
 4344: 
 4345:     Return the array as an ``a.ndim``-levels deep nested list of Python scalars.
 4346: 
 4347:     Return a copy of the array data as a (nested) Python list.
 4348:     Data items are converted to the nearest compatible builtin Python type, via
 4349:     the `~numpy.ndarray.item` function.
 4350: 
 4351:     If ``a.ndim`` is 0, then since the depth of the nested list is 0, it will
 4352:     not be a list at all, but a simple Python scalar.
 4353: 
 4354:     Parameters
 4355:     ----------
 4356:     none
 4357: 
 4358:     Returns
 4359:     -------
 4360:     y : object, or list of object, or list of list of object, or ...
 4361:         The possibly nested list of array elements.
 4362: 
 4363:     Notes
 4364:     -----
 4365:     The array may be recreated via ``a = np.array(a.tolist())``, although this
 4366:     may sometimes lose precision.
 4367: 
 4368:     Examples
 4369:     --------
 4370:     For a 1D array, ``a.tolist()`` is almost the same as ``list(a)``,
 4371:     except that ``tolist`` changes numpy scalars to Python scalars:
 4372: 
 4373:     >>> import numpy as np
 4374:     >>> a = np.uint32([1, 2])
 4375:     >>> a_list = list(a)
 4376:     >>> a_list
 4377:     [np.uint32(1), np.uint32(2)]
 4378:     >>> type(a_list[0])
 4379:     <class 'numpy.uint32'>
 4380:     >>> a_tolist = a.tolist()
 4381:     >>> a_tolist
 4382:     [1, 2]
 4383:     >>> type(a_tolist[0])
 4384:     <class 'int'>
 4385: 
 4386:     Additionally, for a 2D array, ``tolist`` applies recursively:
 4387: 
 4388:     >>> a = np.array([[1, 2], [3, 4]])
 4389:     >>> list(a)
 4390:     [array([1, 2]), array([3, 4])]
 4391:     >>> a.tolist()
 4392:     [[1, 2], [3, 4]]
 4393: 
 4394:     The base case for this recursion is a 0D array:
 4395: 
 4396:     >>> a = np.array(1)
 4397:     >>> list(a)
 4398:     Traceback (most recent call last):
 4399:       ...
 4400:     TypeError: iteration over a 0-d array
 4401:     >>> a.tolist()
 4402:     1
 4403:     """))
 4404: 
 4405: 
 4406: add_newdoc('numpy._core.multiarray', 'ndarray', ('tobytes', """
 4407:     a.tobytes(order='C')
 4408: 
 4409:     Construct Python bytes containing the raw data bytes in the array.
 4410: 
 4411:     Constructs Python bytes showing a copy of the raw contents of
 4412:     data memory. The bytes object is produced in C-order by default.
 4413:     This behavior is controlled by the ``order`` parameter.
 4414: 
 4415:     Parameters
 4416:     ----------
 4417:     order : {'C', 'F', 'A'}, optional
 4418:         Controls the memory layout of the bytes object. 'C' means C-order,
 4419:         'F' means F-order, 'A' (short for *Any*) means 'F' if `a` is
 4420:         Fortran contiguous, 'C' otherwise. Default is 'C'.
 4421: 
 4422:     Returns
 4423:     -------
 4424:     s : bytes
 4425:         Python bytes exhibiting a copy of `a`'s raw data.
 4426: 
 4427:     See also
 4428:     --------
 4429:     frombuffer
 4430:         Inverse of this operation, construct a 1-dimensional array from Python
 4431:         bytes.
 4432: 
 4433:     Examples
 4434:     --------
 4435:     >>> import numpy as np
 4436:     >>> x = np.array([[0, 1], [2, 3]], dtype='<u2')
 4437:     >>> x.tobytes()
 4438:     b'\\x00\\x00\\x01\\x00\\x02\\x00\\x03\\x00'
 4439:     >>> x.tobytes('C') == x.tobytes()
 4440:     True
 4441:     >>> x.tobytes('F')
 4442:     b'\\x00\\x00\\x02\\x00\\x01\\x00\\x03\\x00'
 4443: 
 4444:     """))
 4445: 
 4446: 
 4447: add_newdoc('numpy._core.multiarray', 'ndarray', ('trace',
 4448:     """
 4449:     a.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)
 4450: 
 4451:     Return the sum along diagonals of the array.
 4452: 
 4453:     Refer to `numpy.trace` for full documentation.
 4454: 
 4455:     See Also
 4456:     --------
 4457:     numpy.trace : equivalent function
 4458: 
 4459:     """))
 4460: 
 4461: 
 4462: add_newdoc('numpy._core.multiarray', 'ndarray', ('transpose',
 4463:     """
 4464:     a.transpose(*axes)
 4465: 
 4466:     Returns a view of the array with axes transposed.
 4467: 
 4468:     Refer to `numpy.transpose` for full documentation.
 4469: 
 4470:     Parameters
 4471:     ----------
 4472:     axes : None, tuple of ints, or `n` ints
 4473: 
 4474:      * None or no argument: reverses the order of the axes.
 4475: 
 4476:      * tuple of ints: `i` in the `j`-th place in the tuple means that the
 4477:        array's `i`-th axis becomes the transposed array's `j`-th axis.
 4478: 
 4479:      * `n` ints: same as an n-tuple of the same ints (this form is
 4480:        intended simply as a "convenience" alternative to the tuple form).
 4481: 
 4482:     Returns
 4483:     -------
 4484:     p : ndarray
 4485:         View of the array with its axes suitably permuted.
 4486: 
 4487:     See Also
 4488:     --------
 4489:     transpose : Equivalent function.
 4490:     ndarray.T : Array property returning the array transposed.
 4491:     ndarray.reshape : Give a new shape to an array without changing its data.
 4492: 
 4493:     Examples
 4494:     --------
 4495:     >>> import numpy as np
 4496:     >>> a = np.array([[1, 2], [3, 4]])
 4497:     >>> a
 4498:     array([[1, 2],
 4499:            [3, 4]])
 4500:     >>> a.transpose()
 4501:     array([[1, 3],
 4502:            [2, 4]])
 4503:     >>> a.transpose((1, 0))
 4504:     array([[1, 3],
 4505:            [2, 4]])
 4506:     >>> a.transpose(1, 0)
 4507:     array([[1, 3],
 4508:            [2, 4]])
 4509: 
 4510:     >>> a = np.array([1, 2, 3, 4])
 4511:     >>> a
 4512:     array([1, 2, 3, 4])
 4513:     >>> a.transpose()
 4514:     array([1, 2, 3, 4])
 4515: 
 4516:     """))
 4517: 
 4518: 
 4519: add_newdoc('numpy._core.multiarray', 'ndarray', ('var',
 4520:     """
 4521:     a.var(axis=None, dtype=None, out=None, ddof=0, keepdims=False, *, where=True)
 4522: 
 4523:     Returns the variance of the array elements, along given axis.
 4524: 
 4525:     Refer to `numpy.var` for full documentation.
 4526: 
 4527:     See Also
 4528:     --------
 4529:     numpy.var : equivalent function
 4530: 
 4531:     """))
 4532: 
 4533: 
 4534: add_newdoc('numpy._core.multiarray', 'ndarray', ('view',
 4535:     """
 4536:     a.view([dtype][, type])
 4537: 
 4538:     New view of array with the same data.
 4539: 
 4540:     .. note::
 4541:         Passing None for ``dtype`` is different from omitting the parameter,
 4542:         since the former invokes ``dtype(None)`` which is an alias for
 4543:         ``dtype('float64')``.
 4544: 
 4545:     Parameters
 4546:     ----------
 4547:     dtype : data-type or ndarray sub-class, optional
 4548:         Data-type descriptor of the returned view, e.g., float32 or int16.
 4549:         Omitting it results in the view having the same data-type as `a`.
 4550:         This argument can also be specified as an ndarray sub-class, which
 4551:         then specifies the type of the returned object (this is equivalent to
 4552:         setting the ``type`` parameter).
 4553:     type : Python type, optional
 4554:         Type of the returned view, e.g., ndarray or matrix.  Again, omission
 4555:         of the parameter results in type preservation.
 4556: 
 4557:     Notes
 4558:     -----
 4559:     ``a.view()`` is used two different ways:
 4560: 
 4561:     ``a.view(some_dtype)`` or ``a.view(dtype=some_dtype)`` constructs a view
 4562:     of the array's memory with a different data-type.  This can cause a
 4563:     reinterpretation of the bytes of memory.
 4564: 
 4565:     ``a.view(ndarray_subclass)`` or ``a.view(type=ndarray_subclass)`` just
 4566:     returns an instance of `ndarray_subclass` that looks at the same array
 4567:     (same shape, dtype, etc.)  This does not cause a reinterpretation of the
 4568:     memory.
 4569: 
 4570:     For ``a.view(some_dtype)``, if ``some_dtype`` has a different number of
 4571:     bytes per entry than the previous dtype (for example, converting a regular
 4572:     array to a structured array), then the last axis of ``a`` must be
 4573:     contiguous. This axis will be resized in the result.
 4574: 
 4575:     .. versionchanged:: 1.23.0
 4576:        Only the last axis needs to be contiguous. Previously, the entire array
 4577:        had to be C-contiguous.
 4578: 
 4579:     Examples
 4580:     --------
 4581:     >>> import numpy as np
 4582:     >>> x = np.array([(-1, 2)], dtype=[('a', np.int8), ('b', np.int8)])
 4583: 
 4584:     Viewing array data using a different type and dtype:
 4585: 
 4586:     >>> nonneg = np.dtype([("a", np.uint8), ("b", np.uint8)])
 4587:     >>> y = x.view(dtype=nonneg, type=np.recarray)
 4588:     >>> x["a"]
 4589:     array([-1], dtype=int8)
 4590:     >>> y.a
 4591:     array([255], dtype=uint8)
 4592: 
 4593:     Creating a view on a structured array so it can be used in calculations
 4594: 
 4595:     >>> x = np.array([(1, 2),(3,4)], dtype=[('a', np.int8), ('b', np.int8)])
 4596:     >>> xv = x.view(dtype=np.int8).reshape(-1,2)
 4597:     >>> xv
 4598:     array([[1, 2],
 4599:            [3, 4]], dtype=int8)
 4600:     >>> xv.mean(0)
 4601:     array([2.,  3.])
 4602: 
 4603:     Making changes to the view changes the underlying array
 4604: 
 4605:     >>> xv[0,1] = 20
 4606:     >>> x
 4607:     array([(1, 20), (3,  4)], dtype=[('a', 'i1'), ('b', 'i1')])
 4608: 
 4609:     Using a view to convert an array to a recarray:
 4610: 
 4611:     >>> z = x.view(np.recarray)
 4612:     >>> z.a
 4613:     array([1, 3], dtype=int8)
 4614: 
 4615:     Views share data:
 4616: 
 4617:     >>> x[0] = (9, 10)
 4618:     >>> z[0]
 4619:     np.record((9, 10), dtype=[('a', 'i1'), ('b', 'i1')])
 4620: 
 4621:     Views that change the dtype size (bytes per entry) should normally be
 4622:     avoided on arrays defined by slices, transposes, fortran-ordering, etc.:
 4623: 
 4624:     >>> x = np.array([[1, 2, 3], [4, 5, 6]], dtype=np.int16)
 4625:     >>> y = x[:, ::2]
 4626:     >>> y
 4627:     array([[1, 3],
 4628:            [4, 6]], dtype=int16)
 4629:     >>> y.view(dtype=[('width', np.int16), ('length', np.int16)])
 4630:     Traceback (most recent call last):
 4631:         ...
 4632:     ValueError: To change to a dtype of a different size, the last axis must be contiguous
 4633:     >>> z = y.copy()
 4634:     >>> z.view(dtype=[('width', np.int16), ('length', np.int16)])
 4635:     array([[(1, 3)],
 4636:            [(4, 6)]], dtype=[('width', '<i2'), ('length', '<i2')])
 4637: 
 4638:     However, views that change dtype are totally fine for arrays with a
 4639:     contiguous last axis, even if the rest of the axes are not C-contiguous:
 4640: 
 4641:     >>> x = np.arange(2 * 3 * 4, dtype=np.int8).reshape(2, 3, 4)
 4642:     >>> x.transpose(1, 0, 2).view(np.int16)
 4643:     array([[[ 256,  770],
 4644:             [3340, 3854]],
 4645:     <BLANKLINE>
 4646:            [[1284, 1798],
 4647:             [4368, 4882]],
 4648:     <BLANKLINE>
 4649:            [[2312, 2826],
 4650:             [5396, 5910]]], dtype=int16)
 4651: 
 4652:     """))
 4653: 
 4654: 
 4655: ##############################################################################
 4656: #
 4657: # umath functions
 4658: #
 4659: ##############################################################################
 4660: 
 4661: add_newdoc('numpy._core.umath', 'frompyfunc',
 4662:     """
 4663:     frompyfunc(func, /, nin, nout, *[, identity])
 4664: 
 4665:     Takes an arbitrary Python function and returns a NumPy ufunc.
 4666: 
 4667:     Can be used, for example, to add broadcasting to a built-in Python
 4668:     function (see Examples section).
 4669: 
 4670:     Parameters
 4671:     ----------
 4672:     func : Python function object
 4673:         An arbitrary Python function.
 4674:     nin : int
 4675:         The number of input arguments.
 4676:     nout : int
 4677:         The number of objects returned by `func`.
 4678:     identity : object, optional
 4679:         The value to use for the `~numpy.ufunc.identity` attribute of the resulting
 4680:         object. If specified, this is equivalent to setting the underlying
 4681:         C ``identity`` field to ``PyUFunc_IdentityValue``.
 4682:         If omitted, the identity is set to ``PyUFunc_None``. Note that this is
 4683:         _not_ equivalent to setting the identity to ``None``, which implies the
 4684:         operation is reorderable.
 4685: 
 4686:     Returns
 4687:     -------
 4688:     out : ufunc
 4689:         Returns a NumPy universal function (``ufunc``) object.
 4690: 
 4691:     See Also
 4692:     --------
 4693:     vectorize : Evaluates pyfunc over input arrays using broadcasting rules of numpy.
 4694: 
 4695:     Notes
 4696:     -----
 4697:     The returned ufunc always returns PyObject arrays.
 4698: 
 4699:     Examples
 4700:     --------
 4701:     Use frompyfunc to add broadcasting to the Python function ``oct``:
 4702: 
 4703:     >>> import numpy as np
 4704:     >>> oct_array = np.frompyfunc(oct, 1, 1)
 4705:     >>> oct_array(np.array((10, 30, 100)))
 4706:     array(['0o12', '0o36', '0o144'], dtype=object)
 4707:     >>> np.array((oct(10), oct(30), oct(100))) # for comparison
 4708:     array(['0o12', '0o36', '0o144'], dtype='<U5')
 4709: 
 4710:     """)
 4711: 
 4712: 
 4713: ##############################################################################
 4714: #
 4715: # compiled_base functions
 4716: #
 4717: ##############################################################################
 4718: 
 4719: add_newdoc('numpy._core.multiarray', 'add_docstring',
 4720:     """
 4721:     add_docstring(obj, docstring)
 4722: 
 4723:     Add a docstring to a built-in obj if possible.
 4724:     If the obj already has a docstring raise a RuntimeError
 4725:     If this routine does not know how to add a docstring to the object
 4726:     raise a TypeError
 4727:     """)
 4728: 
 4729: add_newdoc('numpy._core.umath', '_add_newdoc_ufunc',
 4730:     """
 4731:     add_ufunc_docstring(ufunc, new_docstring)
 4732: 
 4733:     Replace the docstring for a ufunc with new_docstring.
 4734:     This method will only work if the current docstring for
 4735:     the ufunc is NULL. (At the C level, i.e. when ufunc->doc is NULL.)
 4736: 
 4737:     Parameters
 4738:     ----------
 4739:     ufunc : numpy.ufunc
 4740:         A ufunc whose current doc is NULL.
 4741:     new_docstring : string
 4742:         The new docstring for the ufunc.
 4743: 
 4744:     Notes
 4745:     -----
 4746:     This method allocates memory for new_docstring on
 4747:     the heap. Technically this creates a memory leak, since this
 4748:     memory will not be reclaimed until the end of the program
 4749:     even if the ufunc itself is removed. However this will only
 4750:     be a problem if the user is repeatedly creating ufuncs with
 4751:     no documentation, adding documentation via add_newdoc_ufunc,
 4752:     and then throwing away the ufunc.
 4753:     """)
 4754: 
 4755: add_newdoc('numpy._core.multiarray', 'get_handler_name',
 4756:     """
 4757:     get_handler_name(a: ndarray) -> str,None
 4758: 
 4759:     Return the name of the memory handler used by `a`. If not provided, return
 4760:     the name of the memory handler that will be used to allocate data for the
 4761:     next `ndarray` in this context. May return None if `a` does not own its
 4762:     memory, in which case you can traverse ``a.base`` for a memory handler.
 4763:     """)
 4764: 
 4765: add_newdoc('numpy._core.multiarray', 'get_handler_version',
 4766:     """
 4767:     get_handler_version(a: ndarray) -> int,None
 4768: 
 4769:     Return the version of the memory handler used by `a`. If not provided,
 4770:     return the version of the memory handler that will be used to allocate data
 4771:     for the next `ndarray` in this context. May return None if `a` does not own
 4772:     its memory, in which case you can traverse ``a.base`` for a memory handler.
 4773:     """)
 4774: 
 4775: add_newdoc('numpy._core._multiarray_umath', '_array_converter',
 4776:     """
 4777:     _array_converter(*array_likes)
 4778: 
 4779:     Helper to convert one or more objects to arrays.  Integrates machinery
 4780:     to deal with the ``result_type`` and ``__array_wrap__``.
 4781: 
 4782:     The reason for this is that e.g. ``result_type`` needs to convert to arrays
 4783:     to find the ``dtype``.  But converting to an array before calling
 4784:     ``result_type`` would incorrectly "forget" whether it was a Python int,
 4785:     float, or complex.
 4786:     """)
 4787: 
 4788: add_newdoc(
 4789:     'numpy._core._multiarray_umath', '_array_converter', ('scalar_input',
 4790:     """
 4791:     A tuple which indicates for each input whether it was a scalar that
 4792:     was coerced to a 0-D array (and was not already an array or something
 4793:     converted via a protocol like ``__array__()``).
 4794:     """))
 4795: 
 4796: add_newdoc('numpy._core._multiarray_umath', '_array_converter', ('as_arrays',
 4797:     """
 4798:     as_arrays(/, subok=True, pyscalars="convert_if_no_array")
 4799: 
 4800:     Return the inputs as arrays or scalars.
 4801: 
 4802:     Parameters
 4803:     ----------
 4804:     subok : True or False, optional
 4805:         Whether array subclasses are preserved.
 4806:     pyscalars : {"convert", "preserve", "convert_if_no_array"}, optional
 4807:         To allow NEP 50 weak promotion later, it may be desirable to preserve
 4808:         Python scalars.  As default, these are preserved unless all inputs
 4809:         are Python scalars.  "convert" enforces an array return.
 4810:     """))
 4811: 
 4812: add_newdoc('numpy._core._multiarray_umath', '_array_converter', ('result_type',
 4813:     """result_type(/, extra_dtype=None, ensure_inexact=False)
 4814: 
 4815:     Find the ``result_type`` just as ``np.result_type`` would, but taking
 4816:     into account that the original inputs (before converting to an array) may
 4817:     have been Python scalars with weak promotion.
 4818: 
 4819:     Parameters
 4820:     ----------
 4821:     extra_dtype : dtype instance or class
 4822:         An additional DType or dtype instance to promote (e.g. could be used
 4823:         to ensure the result precision is at least float32).
 4824:     ensure_inexact : True or False
 4825:         When ``True``, ensures a floating point (or complex) result replacing
 4826:         the ``arr * 1.`` or ``result_type(..., 0.0)`` pattern.
 4827:     """))
 4828: 
 4829: add_newdoc('numpy._core._multiarray_umath', '_array_converter', ('wrap',
 4830:     """
 4831:     wrap(arr, /, to_scalar=None)
 4832: 
 4833:     Call ``__array_wrap__`` on ``arr`` if ``arr`` is not the same subclass
 4834:     as the input the ``__array_wrap__`` method was retrieved from.
 4835: 
 4836:     Parameters
 4837:     ----------
 4838:     arr : ndarray
 4839:         The object to be wrapped. Normally an ndarray or subclass,
 4840:         although for backward compatibility NumPy scalars are also accepted
 4841:         (these will be converted to a NumPy array before being passed on to
 4842:         the ``__array_wrap__`` method).
 4843:     to_scalar : {True, False, None}, optional
 4844:         When ``True`` will convert a 0-d array to a scalar via ``result[()]``
 4845:         (with a fast-path for non-subclasses).  If ``False`` the result should
 4846:         be an array-like (as ``__array_wrap__`` is free to return a non-array).
 4847:         By default (``None``), a scalar is returned if all inputs were scalar.
 4848:     """))
 4849: 
 4850: 
 4851: add_newdoc('numpy._core.multiarray', '_get_madvise_hugepage',
 4852:     """
 4853:     _get_madvise_hugepage() -> bool
 4854: 
 4855:     Get use of ``madvise (2)`` MADV_HUGEPAGE support when
 4856:     allocating the array data. Returns the currently set value.
 4857:     See `global_state` for more information.
 4858:     """)
 4859: 
 4860: add_newdoc('numpy._core.multiarray', '_set_madvise_hugepage',
 4861:     """
 4862:     _set_madvise_hugepage(enabled: bool) -> bool
 4863: 
 4864:     Set  or unset use of ``madvise (2)`` MADV_HUGEPAGE support when
 4865:     allocating the array data. Returns the previously set value.
 4866:     See `global_state` for more information.
 4867:     """)
 4868: 
 4869: 
 4870: ##############################################################################
 4871: #
 4872: # Documentation for ufunc attributes and methods
 4873: #
 4874: ##############################################################################
 4875: 
 4876: 
 4877: ##############################################################################
 4878: #
 4879: # ufunc object
 4880: #
 4881: ##############################################################################
 4882: 
 4883: add_newdoc('numpy._core', 'ufunc',
 4884:     """
 4885:     Functions that operate element by element on whole arrays.
 4886: 
 4887:     To see the documentation for a specific ufunc, use `info`.  For
 4888:     example, ``np.info(np.sin)``.  Because ufuncs are written in C
 4889:     (for speed) and linked into Python with NumPy's ufunc facility,
 4890:     Python's help() function finds this page whenever help() is called
 4891:     on a ufunc.
 4892: 
 4893:     A detailed explanation of ufuncs can be found in the docs for :ref:`ufuncs`.
 4894: 
 4895:     **Calling ufuncs:** ``op(*x[, out], where=True, **kwargs)``
 4896: 
 4897:     Apply `op` to the arguments `*x` elementwise, broadcasting the arguments.
 4898: 
 4899:     The broadcasting rules are:
 4900: 
 4901:     * Dimensions of length 1 may be prepended to either array.
 4902:     * Arrays may be repeated along dimensions of length 1.
 4903: 
 4904:     Parameters
 4905:     ----------
 4906:     *x : array_like
 4907:         Input arrays.
 4908:     out : ndarray, None, ..., or tuple of ndarray and None, optional
 4909:         Location(s) into which the result(s) are stored.
 4910:         If not provided or None, new array(s) are created by the ufunc.
 4911:         If passed as a keyword argument, can be Ellipses (``out=...``) to
 4912:         ensure an array is returned even if the result is 0-dimensional,
 4913:         or a tuple with length equal to the number of outputs (where None
 4914:         can be used for allocation by the ufunc).
 4915: 
 4916:         .. versionadded:: 2.3
 4917:             Support for ``out=...`` was added.
 4918: 
 4919:     where : array_like, optional
 4920:         This condition is broadcast over the input. At locations where the
 4921:         condition is True, the `out` array will be set to the ufunc result.
 4922:         Elsewhere, the `out` array will retain its original value.
 4923:         Note that if an uninitialized `out` array is created via the default
 4924:         ``out=None``, locations within it where the condition is False will
 4925:         remain uninitialized.
 4926:     **kwargs
 4927:         For other keyword-only arguments, see the :ref:`ufunc docs <ufuncs.kwargs>`.
 4928: 
 4929:     Returns
 4930:     -------
 4931:     r : ndarray or tuple of ndarray
 4932:         `r` will have the shape that the arrays in `x` broadcast to; if `out` is
 4933:         provided, it will be returned. If not, `r` will be allocated and
 4934:         may contain uninitialized values. If the function has more than one
 4935:         output, then the result will be a tuple of arrays.
 4936: 
 4937:     """)
 4938: 
 4939: 
 4940: ##############################################################################
 4941: #
 4942: # ufunc attributes
 4943: #
 4944: ##############################################################################
 4945: 
 4946: add_newdoc('numpy._core', 'ufunc', ('identity',
 4947:     """
 4948:     The identity value.
 4949: 
 4950:     Data attribute containing the identity element for the ufunc,
 4951:     if it has one. If it does not, the attribute value is None.
 4952: 
 4953:     Examples
 4954:     --------
 4955:     >>> import numpy as np
 4956:     >>> np.add.identity
 4957:     0
 4958:     >>> np.multiply.identity
 4959:     1
 4960:     >>> print(np.power.identity)
 4961:     None
 4962:     >>> print(np.exp.identity)
 4963:     None
 4964:     """))
 4965: 
 4966: add_newdoc('numpy._core', 'ufunc', ('nargs',
 4967:     """
 4968:     The number of arguments.
 4969: 
 4970:     Data attribute containing the number of arguments the ufunc takes, including
 4971:     optional ones.
 4972: 
 4973:     Notes
 4974:     -----
 4975:     Typically this value will be one more than what you might expect
 4976:     because all ufuncs take  the optional "out" argument.
 4977: 
 4978:     Examples
 4979:     --------
 4980:     >>> import numpy as np
 4981:     >>> np.add.nargs
 4982:     3
 4983:     >>> np.multiply.nargs
 4984:     3
 4985:     >>> np.power.nargs
 4986:     3
 4987:     >>> np.exp.nargs
 4988:     2
 4989:     """))
 4990: 
 4991: add_newdoc('numpy._core', 'ufunc', ('nin',
 4992:     """
 4993:     The number of inputs.
 4994: 
 4995:     Data attribute containing the number of arguments the ufunc treats as input.
 4996: 
 4997:     Examples
 4998:     --------
 4999:     >>> import numpy as np
 5000:     >>> np.add.nin
 5001:     2
 5002:     >>> np.multiply.nin
 5003:     2
 5004:     >>> np.power.nin
 5005:     2
 5006:     >>> np.exp.nin
 5007:     1
 5008:     """))
 5009: 
 5010: add_newdoc('numpy._core', 'ufunc', ('nout',
 5011:     """
 5012:     The number of outputs.
 5013: 
 5014:     Data attribute containing the number of arguments the ufunc treats as output.
 5015: 
 5016:     Notes
 5017:     -----
 5018:     Since all ufuncs can take output arguments, this will always be at least 1.
 5019: 
 5020:     Examples
 5021:     --------
 5022:     >>> import numpy as np
 5023:     >>> np.add.nout
 5024:     1
 5025:     >>> np.multiply.nout
 5026:     1
 5027:     >>> np.power.nout
 5028:     1
 5029:     >>> np.exp.nout
 5030:     1
 5031: 
 5032:     """))
 5033: 
 5034: add_newdoc('numpy._core', 'ufunc', ('ntypes',
 5035:     """
 5036:     The number of types.
 5037: 
 5038:     The number of numerical NumPy types - of which there are 18 total - on which
 5039:     the ufunc can operate.
 5040: 
 5041:     See Also
 5042:     --------
 5043:     numpy.ufunc.types
 5044: 
 5045:     Examples
 5046:     --------
 5047:     >>> import numpy as np
 5048:     >>> np.add.ntypes
 5049:     22
 5050:     >>> np.multiply.ntypes
 5051:     23
 5052:     >>> np.power.ntypes
 5053:     21
 5054:     >>> np.exp.ntypes
 5055:     10
 5056:     >>> np.remainder.ntypes
 5057:     16
 5058: 
 5059:     """))
 5060: 
 5061: add_newdoc('numpy._core', 'ufunc', ('types',
 5062:     """
 5063:     Returns a list with types grouped input->output.
 5064: 
 5065:     Data attribute listing the data-type "Domain-Range" groupings the ufunc can
 5066:     deliver. The data-types are given using the character codes.
 5067: 
 5068:     See Also
 5069:     --------
 5070:     numpy.ufunc.ntypes
 5071: 
 5072:     Examples
 5073:     --------
 5074:     >>> import numpy as np
 5075:     >>> np.add.types
 5076:     ['??->?', 'bb->b', 'BB->B', 'hh->h', 'HH->H', 'ii->i', 'II->I', ...
 5077: 
 5078:     >>> np.power.types
 5079:     ['bb->b', 'BB->B', 'hh->h', 'HH->H', 'ii->i', 'II->I', 'll->l', ...
 5080: 
 5081:     >>> np.exp.types
 5082:     ['e->e', 'f->f', 'd->d', 'f->f', 'd->d', 'g->g', 'F->F', 'D->D', 'G->G', 'O->O']
 5083: 
 5084:     >>> np.remainder.types
 5085:     ['bb->b', 'BB->B', 'hh->h', 'HH->H', 'ii->i', 'II->I', 'll->l', ...
 5086: 
 5087:     """))
 5088: 
 5089: add_newdoc('numpy._core', 'ufunc', ('signature',
 5090:     """
 5091:     Definition of the core elements a generalized ufunc operates on.
 5092: 
 5093:     The signature determines how the dimensions of each input/output array
 5094:     are split into core and loop dimensions:
 5095: 
 5096:     1. Each dimension in the signature is matched to a dimension of the
 5097:        corresponding passed-in array, starting from the end of the shape tuple.
 5098:     2. Core dimensions assigned to the same label in the signature must have
 5099:        exactly matching sizes, no broadcasting is performed.
 5100:     3. The core dimensions are removed from all inputs and the remaining
 5101:        dimensions are broadcast together, defining the loop dimensions.
 5102: 
 5103:     Notes
 5104:     -----
 5105:     Generalized ufuncs are used internally in many linalg functions, and in
 5106:     the testing suite; the examples below are taken from these.
 5107:     For ufuncs that operate on scalars, the signature is None, which is
 5108:     equivalent to '()' for every argument.
 5109: 
 5110:     Examples
 5111:     --------
 5112:     >>> import numpy as np
 5113:     >>> np.linalg._umath_linalg.det.signature
 5114:     '(m,m)->()'
 5115:     >>> np.matmul.signature
 5116:     '(n?,k),(k,m?)->(n?,m?)'
 5117:     >>> np.add.signature is None
 5118:     True  # equivalent to '(),()->()'
 5119:     """))
 5120: 
 5121: ##############################################################################
 5122: #
 5123: # ufunc methods
 5124: #
 5125: ##############################################################################
 5126: 
 5127: add_newdoc('numpy._core', 'ufunc', ('reduce',
 5128:     """
 5129:     reduce(array, axis=0, dtype=None, out=None, keepdims=False, initial=<no value>, where=True)
 5130: 
 5131:     Reduces `array`'s dimension by one, by applying ufunc along one axis.
 5132: 
 5133:     Let :math:`array.shape = (N_0, ..., N_i, ..., N_{M-1})`.  Then
 5134:     :math:`ufunc.reduce(array, axis=i)[k_0, ..,k_{i-1}, k_{i+1}, .., k_{M-1}]` =
 5135:     the result of iterating `j` over :math:`range(N_i)`, cumulatively applying
 5136:     ufunc to each :math:`array[k_0, ..,k_{i-1}, j, k_{i+1}, .., k_{M-1}]`.
 5137:     For a one-dimensional array, reduce produces results equivalent to:
 5138:     ::
 5139: 
 5140:      r = op.identity # op = ufunc
 5141:      for i in range(len(A)):
 5142:        r = op(r, A[i])
 5143:      return r
 5144: 
 5145:     For example, add.reduce() is equivalent to sum().
 5146: 
 5147:     Parameters
 5148:     ----------
 5149:     array : array_like
 5150:         The array to act on.
 5151:     axis : None or int or tuple of ints, optional
 5152:         Axis or axes along which a reduction is performed.
 5153:         The default (`axis` = 0) is perform a reduction over the first
 5154:         dimension of the input array. `axis` may be negative, in
 5155:         which case it counts from the last to the first axis.
 5156: 
 5157:         If this is None, a reduction is performed over all the axes.
 5158:         If this is a tuple of ints, a reduction is performed on multiple
 5159:         axes, instead of a single axis or all the axes as before.
 5160: 
 5161:         For operations which are either not commutative or not associative,
 5162:         doing a reduction over multiple axes is not well-defined. The
 5163:         ufuncs do not currently raise an exception in this case, but will
 5164:         likely do so in the future.
 5165:     dtype : data-type code, optional
 5166:         The data type used to perform the operation. Defaults to that of
 5167:         ``out`` if given, and the data type of ``array`` otherwise (though
 5168:         upcast to conserve precision for some cases, such as
 5169:         ``numpy.add.reduce`` for integer or boolean input).
 5170:     out : ndarray, None, ..., or tuple of ndarray and None, optional
 5171:         Location into which the result is stored.
 5172:         If not provided or None, a freshly-allocated array is returned.
 5173:         If passed as a keyword argument, can be Ellipses (``out=...``) to
 5174:         ensure an array is returned even if the result is 0-dimensional
 5175:         (which is useful especially for object dtype), or a 1-element tuple
 5176:         (latter for consistency with ``ufunc.__call__``).
 5177: 
 5178:         .. versionadded:: 2.3
 5179:             Support for ``out=...`` was added.
 5180: 
 5181:     keepdims : bool, optional
 5182:         If this is set to True, the axes which are reduced are left
 5183:         in the result as dimensions with size one. With this option,
 5184:         the result will broadcast correctly against the original `array`.
 5185:     initial : scalar, optional
 5186:         The value with which to start the reduction.
 5187:         If the ufunc has no identity or the dtype is object, this defaults
 5188:         to None - otherwise it defaults to ufunc.identity.
 5189:         If ``None`` is given, the first element of the reduction is used,
 5190:         and an error is thrown if the reduction is empty.
 5191:     where : array_like of bool, optional
 5192:         A boolean array which is broadcasted to match the dimensions
 5193:         of `array`, and selects elements to include in the reduction. Note
 5194:         that for ufuncs like ``minimum`` that do not have an identity
 5195:         defined, one has to pass in also ``initial``.
 5196: 
 5197:     Returns
 5198:     -------
 5199:     r : ndarray
 5200:         The reduced array. If `out` was supplied, `r` is a reference to it.
 5201: 
 5202:     Examples
 5203:     --------
 5204:     >>> import numpy as np
 5205:     >>> np.multiply.reduce([2,3,5])
 5206:     30
 5207: 
 5208:     A multi-dimensional array example:
 5209: 
 5210:     >>> X = np.arange(8).reshape((2,2,2))
 5211:     >>> X
 5212:     array([[[0, 1],
 5213:             [2, 3]],
 5214:            [[4, 5],
 5215:             [6, 7]]])
 5216:     >>> np.add.reduce(X, 0)
 5217:     array([[ 4,  6],
 5218:            [ 8, 10]])
 5219:     >>> np.add.reduce(X) # confirm: default axis value is 0
 5220:     array([[ 4,  6],
 5221:            [ 8, 10]])
 5222:     >>> np.add.reduce(X, 1)
 5223:     array([[ 2,  4],
 5224:            [10, 12]])
 5225:     >>> np.add.reduce(X, 2)
 5226:     array([[ 1,  5],
 5227:            [ 9, 13]])
 5228: 
 5229:     You can use the ``initial`` keyword argument to initialize the reduction
 5230:     with a different value, and ``where`` to select specific elements to include:
 5231: 
 5232:     >>> np.add.reduce([10], initial=5)
 5233:     15
 5234:     >>> np.add.reduce(np.ones((2, 2, 2)), axis=(0, 2), initial=10)
 5235:     array([14., 14.])
 5236:     >>> a = np.array([10., np.nan, 10])
 5237:     >>> np.add.reduce(a, where=~np.isnan(a))
 5238:     20.0
 5239: 
 5240:     Allows reductions of empty arrays where they would normally fail, i.e.
 5241:     for ufuncs without an identity.
 5242: 
 5243:     >>> np.minimum.reduce([], initial=np.inf)
 5244:     inf
 5245:     >>> np.minimum.reduce([[1., 2.], [3., 4.]], initial=10., where=[True, False])
 5246:     array([ 1., 10.])
 5247:     >>> np.minimum.reduce([])
 5248:     Traceback (most recent call last):
 5249:         ...
 5250:     ValueError: zero-size array to reduction operation minimum which has no identity
 5251:     """))
 5252: 
 5253: add_newdoc('numpy._core', 'ufunc', ('accumulate',
 5254:     """
 5255:     accumulate(array, axis=0, dtype=None, out=None)
 5256: 
 5257:     Accumulate the result of applying the operator to all elements.
 5258: 
 5259:     For a one-dimensional array, accumulate produces results equivalent to::
 5260: 
 5261:       r = np.empty(len(A))
 5262:       t = op.identity        # op = the ufunc being applied to A's  elements
 5263:       for i in range(len(A)):
 5264:           t = op(t, A[i])
 5265:           r[i] = t
 5266:       return r
 5267: 
 5268:     For example, add.accumulate() is equivalent to np.cumsum().
 5269: 
 5270:     For a multi-dimensional array, accumulate is applied along only one
 5271:     axis (axis zero by default; see Examples below) so repeated use is
 5272:     necessary if one wants to accumulate over multiple axes.
 5273: 
 5274:     Parameters
 5275:     ----------
 5276:     array : array_like
 5277:         The array to act on.
 5278:     axis : int, optional
 5279:         The axis along which to apply the accumulation; default is zero.
 5280:     dtype : data-type code, optional
 5281:         The data-type used to represent the intermediate results. Defaults
 5282:         to the data-type of the output array if such is provided, or the
 5283:         data-type of the input array if no output array is provided.
 5284:     out : ndarray, None, or tuple of ndarray and None, optional
 5285:         Location into which the result is stored.
 5286:         If not provided or None, a freshly-allocated array is returned.
 5287:         For consistency with ``ufunc.__call__``, if passed as a keyword
 5288:         argument, can be Ellipses (``out=...``, which has the same effect
 5289:         as None as an array is always returned), or a 1-element tuple.
 5290: 
 5291:     Returns
 5292:     -------
 5293:     r : ndarray
 5294:         The accumulated values. If `out` was supplied, `r` is a reference to
 5295:         `out`.
 5296: 
 5297:     Examples
 5298:     --------
 5299:     1-D array examples:
 5300: 
 5301:     >>> import numpy as np
 5302:     >>> np.add.accumulate([2, 3, 5])
 5303:     array([ 2,  5, 10])
 5304:     >>> np.multiply.accumulate([2, 3, 5])
 5305:     array([ 2,  6, 30])
 5306: 
 5307:     2-D array examples:
 5308: 
 5309:     >>> I = np.eye(2)
 5310:     >>> I
 5311:     array([[1.,  0.],
 5312:            [0.,  1.]])
 5313: 
 5314:     Accumulate along axis 0 (rows), down columns:
 5315: 
 5316:     >>> np.add.accumulate(I, 0)
 5317:     array([[1.,  0.],
 5318:            [1.,  1.]])
 5319:     >>> np.add.accumulate(I) # no axis specified = axis zero
 5320:     array([[1.,  0.],
 5321:            [1.,  1.]])
 5322: 
 5323:     Accumulate along axis 1 (columns), through rows:
 5324: 
 5325:     >>> np.add.accumulate(I, 1)
 5326:     array([[1.,  1.],
 5327:            [0.,  1.]])
 5328: 
 5329:     """))
 5330: 
 5331: add_newdoc('numpy._core', 'ufunc', ('reduceat',
 5332:     """
 5333:     reduceat(array, indices, axis=0, dtype=None, out=None)
 5334: 
 5335:     Performs a (local) reduce with specified slices over a single axis.
 5336: 
 5337:     For i in ``range(len(indices))``, `reduceat` computes
 5338:     ``ufunc.reduce(array[indices[i]:indices[i+1]])``, which becomes the i-th
 5339:     generalized "row" parallel to `axis` in the final result (i.e., in a
 5340:     2-D array, for example, if `axis = 0`, it becomes the i-th row, but if
 5341:     `axis = 1`, it becomes the i-th column).  There are three exceptions to this:
 5342: 
 5343:     * when ``i = len(indices) - 1`` (so for the last index),
 5344:       ``indices[i+1] = array.shape[axis]``.
 5345:     * if ``indices[i] >= indices[i + 1]``, the i-th generalized "row" is
 5346:       simply ``array[indices[i]]``.
 5347:     * if ``indices[i] >= len(array)`` or ``indices[i] < 0``, an error is raised.
 5348: 
 5349:     The shape of the output depends on the size of `indices`, and may be
 5350:     larger than `array` (this happens if ``len(indices) > array.shape[axis]``).
 5351: 
 5352:     Parameters
 5353:     ----------
 5354:     array : array_like
 5355:         The array to act on.
 5356:     indices : array_like
 5357:         Paired indices, comma separated (not colon), specifying slices to
 5358:         reduce.
 5359:     axis : int, optional
 5360:         The axis along which to apply the reduceat.
 5361:     dtype : data-type code, optional
 5362:         The data type used to perform the operation. Defaults to that of
 5363:         ``out`` if given, and the data type of ``array`` otherwise (though
 5364:         upcast to conserve precision for some cases, such as
 5365:         ``numpy.add.reduce`` for integer or boolean input).
 5366:     out : ndarray, None, or tuple of ndarray and None, optional
 5367:         Location into which the result is stored.
 5368:         If not provided or None, a freshly-allocated array is returned.
 5369:         For consistency with ``ufunc.__call__``, if passed as a keyword
 5370:         argument, can be Ellipses (``out=...``, which has the same effect
 5371:         as None as an array is always returned), or a 1-element tuple.
 5372: 
 5373:     Returns
 5374:     -------
 5375:     r : ndarray
 5376:         The reduced values. If `out` was supplied, `r` is a reference to
 5377:         `out`.
 5378: 
 5379:     Notes
 5380:     -----
 5381:     A descriptive example:
 5382: 
 5383:     If `array` is 1-D, the function `ufunc.accumulate(array)` is the same as
 5384:     ``ufunc.reduceat(array, indices)[::2]`` where `indices` is
 5385:     ``range(len(array) - 1)`` with a zero placed
 5386:     in every other element:
 5387:     ``indices = zeros(2 * len(array) - 1)``,
 5388:     ``indices[1::2] = range(1, len(array))``.
 5389: 
 5390:     Don't be fooled by this attribute's name: `reduceat(array)` is not
 5391:     necessarily smaller than `array`.
 5392: 
 5393:     Examples
 5394:     --------
 5395:     To take the running sum of four successive values:
 5396: 
 5397:     >>> import numpy as np
 5398:     >>> np.add.reduceat(np.arange(8),[0,4, 1,5, 2,6, 3,7])[::2]
 5399:     array([ 6, 10, 14, 18])
 5400: 
 5401:     A 2-D example:
 5402: 
 5403:     >>> x = np.linspace(0, 15, 16).reshape(4,4)
 5404:     >>> x
 5405:     array([[ 0.,   1.,   2.,   3.],
 5406:            [ 4.,   5.,   6.,   7.],
 5407:            [ 8.,   9.,  10.,  11.],
 5408:            [12.,  13.,  14.,  15.]])
 5409: 
 5410:     ::
 5411: 
 5412:      # reduce such that the result has the following five rows:
 5413:      # [row1 + row2 + row3]
 5414:      # [row4]
 5415:      # [row2]
 5416:      # [row3]
 5417:      # [row1 + row2 + row3 + row4]
 5418: 
 5419:     >>> np.add.reduceat(x, [0, 3, 1, 2, 0])
 5420:     array([[12.,  15.,  18.,  21.],
 5421:            [12.,  13.,  14.,  15.],
 5422:            [ 4.,   5.,   6.,   7.],
 5423:            [ 8.,   9.,  10.,  11.],
 5424:            [24.,  28.,  32.,  36.]])
 5425: 
 5426:     ::
 5427: 
 5428:      # reduce such that result has the following two columns:
 5429:      # [col1 * col2 * col3, col4]
 5430: 
 5431:     >>> np.multiply.reduceat(x, [0, 3], 1)
 5432:     array([[   0.,     3.],
 5433:            [ 120.,     7.],
 5434:            [ 720.,    11.],
 5435:            [2184.,    15.]])
 5436: 
 5437:     """))
 5438: 
 5439: add_newdoc('numpy._core', 'ufunc', ('outer',
 5440:     r"""
 5441:     outer(A, B, /, **kwargs)
 5442: 
 5443:     Apply the ufunc `op` to all pairs (a, b) with a in `A` and b in `B`.
 5444: 
 5445:     Let ``M = A.ndim``, ``N = B.ndim``. Then the result, `C`, of
 5446:     ``op.outer(A, B)`` is an array of dimension M + N such that:
 5447: 
 5448:     .. math:: C[i_0, ..., i_{M-1}, j_0, ..., j_{N-1}] =
 5449:        op(A[i_0, ..., i_{M-1}], B[j_0, ..., j_{N-1}])
 5450: 
 5451:     For `A` and `B` one-dimensional, this is equivalent to::
 5452: 
 5453:       r = empty(len(A),len(B))
 5454:       for i in range(len(A)):
 5455:           for j in range(len(B)):
 5456:               r[i,j] = op(A[i], B[j])  # op = ufunc in question
 5457: 
 5458:     Parameters
 5459:     ----------
 5460:     A : array_like
 5461:         First array
 5462:     B : array_like
 5463:         Second array
 5464:     kwargs : any
 5465:         Arguments to pass on to the ufunc. Typically `dtype` or `out`.
 5466:         See `ufunc` for a comprehensive overview of all available arguments.
 5467: 
 5468:     Returns
 5469:     -------
 5470:     r : ndarray
 5471:         Output array
 5472: 
 5473:     See Also
 5474:     --------
 5475:     numpy.outer : A less powerful version of ``np.multiply.outer``
 5476:                   that `ravel`\ s all inputs to 1D. This exists
 5477:                   primarily for compatibility with old code.
 5478: 
 5479:     tensordot : ``np.tensordot(a, b, axes=((), ()))`` and
 5480:                 ``np.multiply.outer(a, b)`` behave same for all
 5481:                 dimensions of a and b.
 5482: 
 5483:     Examples
 5484:     --------
 5485:     >>> np.multiply.outer([1, 2, 3], [4, 5, 6])
 5486:     array([[ 4,  5,  6],
 5487:            [ 8, 10, 12],
 5488:            [12, 15, 18]])
 5489: 
 5490:     A multi-dimensional example:
 5491: 
 5492:     >>> A = np.array([[1, 2, 3], [4, 5, 6]])
 5493:     >>> A.shape
 5494:     (2, 3)
 5495:     >>> B = np.array([[1, 2, 3, 4]])
 5496:     >>> B.shape
 5497:     (1, 4)
 5498:     >>> C = np.multiply.outer(A, B)
 5499:     >>> C.shape; C
 5500:     (2, 3, 1, 4)
 5501:     array([[[[ 1,  2,  3,  4]],
 5502:             [[ 2,  4,  6,  8]],
 5503:             [[ 3,  6,  9, 12]]],
 5504:            [[[ 4,  8, 12, 16]],
 5505:             [[ 5, 10, 15, 20]],
 5506:             [[ 6, 12, 18, 24]]]])
 5507: 
 5508:     """))
 5509: 
 5510: add_newdoc('numpy._core', 'ufunc', ('at',
 5511:     """
 5512:     at(a, indices, b=None, /)
 5513: 
 5514:     Performs unbuffered in place operation on operand 'a' for elements
 5515:     specified by 'indices'. For addition ufunc, this method is equivalent to
 5516:     ``a[indices] += b``, except that results are accumulated for elements that
 5517:     are indexed more than once. For example, ``a[[0,0]] += 1`` will only
 5518:     increment the first element once because of buffering, whereas
 5519:     ``add.at(a, [0,0], 1)`` will increment the first element twice.
 5520: 
 5521:     Parameters
 5522:     ----------
 5523:     a : array_like
 5524:         The array to perform in place operation on.
 5525:     indices : array_like or tuple
 5526:         Array like index object or slice object for indexing into first
 5527:         operand. If first operand has multiple dimensions, indices can be a
 5528:         tuple of array like index objects or slice objects.
 5529:     b : array_like
 5530:         Second operand for ufuncs requiring two operands. Operand must be
 5531:         broadcastable over first operand after indexing or slicing.
 5532: 
 5533:     Examples
 5534:     --------
 5535:     Set items 0 and 1 to their negative values:
 5536: 
 5537:     >>> import numpy as np
 5538:     >>> a = np.array([1, 2, 3, 4])
 5539:     >>> np.negative.at(a, [0, 1])
 5540:     >>> a
 5541:     array([-1, -2,  3,  4])
 5542: 
 5543:     Increment items 0 and 1, and increment item 2 twice:
 5544: 
 5545:     >>> a = np.array([1, 2, 3, 4])
 5546:     >>> np.add.at(a, [0, 1, 2, 2], 1)
 5547:     >>> a
 5548:     array([2, 3, 5, 4])
 5549: 
 5550:     Add items 0 and 1 in first array to second array,
 5551:     and store results in first array:
 5552: 
 5553:     >>> a = np.array([1, 2, 3, 4])
 5554:     >>> b = np.array([1, 2])
 5555:     >>> np.add.at(a, [0, 1], b)
 5556:     >>> a
 5557:     array([2, 4, 3, 4])
 5558: 
 5559:     """))
 5560: 
 5561: add_newdoc('numpy._core', 'ufunc', ('resolve_dtypes',
 5562:     """
 5563:     resolve_dtypes(dtypes, *, signature=None, casting=None, reduction=False)
 5564: 
 5565:     Find the dtypes NumPy will use for the operation.  Both input and
 5566:     output dtypes are returned and may differ from those provided.
 5567: 
 5568:     .. note::
 5569: 
 5570:         This function always applies NEP 50 rules since it is not provided
 5571:         any actual values.  The Python types ``int``, ``float``, and
 5572:         ``complex`` thus behave weak and should be passed for "untyped"
 5573:         Python input.
 5574: 
 5575:     Parameters
 5576:     ----------
 5577:     dtypes : tuple of dtypes, None, or literal int, float, complex
 5578:         The input dtypes for each operand.  Output operands can be
 5579:         None, indicating that the dtype must be found.
 5580:     signature : tuple of DTypes or None, optional
 5581:         If given, enforces exact DType (classes) of the specific operand.
 5582:         The ufunc ``dtype`` argument is equivalent to passing a tuple with
 5583:         only output dtypes set.
 5584:     casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
 5585:         The casting mode when casting is necessary.  This is identical to
 5586:         the ufunc call casting modes.
 5587:     reduction : boolean
 5588:         If given, the resolution assumes a reduce operation is happening
 5589:         which slightly changes the promotion and type resolution rules.
 5590:         `dtypes` is usually something like ``(None, np.dtype("i2"), None)``
 5591:         for reductions (first input is also the output).
 5592: 
 5593:         .. note::
 5594: 
 5595:             The default casting mode is "same_kind", however, as of
 5596:             NumPy 1.24, NumPy uses "unsafe" for reductions.
 5597: 
 5598:     Returns
 5599:     -------
 5600:     dtypes : tuple of dtypes
 5601:         The dtypes which NumPy would use for the calculation.  Note that
 5602:         dtypes may not match the passed in ones (casting is necessary).
 5603: 
 5604: 
 5605:     Examples
 5606:     --------
 5607:     This API requires passing dtypes, define them for convenience:
 5608: 
 5609:     >>> import numpy as np
 5610:     >>> int32 = np.dtype("int32")
 5611:     >>> float32 = np.dtype("float32")
 5612: 
 5613:     The typical ufunc call does not pass an output dtype.  `numpy.add` has two
 5614:     inputs and one output, so leave the output as ``None`` (not provided):
 5615: 
 5616:     >>> np.add.resolve_dtypes((int32, float32, None))
 5617:     (dtype('float64'), dtype('float64'), dtype('float64'))
 5618: 
 5619:     The loop found uses "float64" for all operands (including the output), the
 5620:     first input would be cast.
 5621: 
 5622:     ``resolve_dtypes`` supports "weak" handling for Python scalars by passing
 5623:     ``int``, ``float``, or ``complex``:
 5624: 
 5625:     >>> np.add.resolve_dtypes((float32, float, None))
 5626:     (dtype('float32'), dtype('float32'), dtype('float32'))
 5627: 
 5628:     Where the Python ``float`` behaves similar to a Python value ``0.0``
 5629:     in a ufunc call.  (See :ref:`NEP 50 <NEP50>` for details.)
 5630: 
 5631:     """))
 5632: 
 5633: add_newdoc('numpy._core', 'ufunc', ('_resolve_dtypes_and_context',
 5634:     """
 5635:     _resolve_dtypes_and_context(dtypes, *, signature=None, casting=None, reduction=False)
 5636: 
 5637:     See `numpy.ufunc.resolve_dtypes` for parameter information.  This
 5638:     function is considered *unstable*.  You may use it, but the returned
 5639:     information is NumPy version specific and expected to change.
 5640:     Large API/ABI changes are not expected, but a new NumPy version is
 5641:     expected to require updating code using this functionality.
 5642: 
 5643:     This function is designed to be used in conjunction with
 5644:     `numpy.ufunc._get_strided_loop`.  The calls are split to mirror the C API
 5645:     and allow future improvements.
 5646: 
 5647:     Returns
 5648:     -------
 5649:     dtypes : tuple of dtypes
 5650:     call_info :
 5651:         PyCapsule with all necessary information to get access to low level
 5652:         C calls.  See `numpy.ufunc._get_strided_loop` for more information.
 5653: 
 5654:     """))
 5655: 
 5656: add_newdoc('numpy._core', 'ufunc', ('_get_strided_loop',
 5657:     """
 5658:     _get_strided_loop(call_info, /, *, fixed_strides=None)
 5659: 
 5660:     This function fills in the ``call_info`` capsule to include all
 5661:     information necessary to call the low-level strided loop from NumPy.
 5662: 
 5663:     See notes for more information.
 5664: 
 5665:     Parameters
 5666:     ----------
 5667:     call_info : PyCapsule
 5668:         The PyCapsule returned by `numpy.ufunc._resolve_dtypes_and_context`.
 5669:     fixed_strides : tuple of int or None, optional
 5670:         A tuple with fixed byte strides of all input arrays.  NumPy may use
 5671:         this information to find specialized loops, so any call must follow
 5672:         the given stride.  Use ``None`` to indicate that the stride is not
 5673:         known (or not fixed) for all calls.
 5674: 
 5675:     Notes
 5676:     -----
 5677:     Together with `numpy.ufunc._resolve_dtypes_and_context` this function
 5678:     gives low-level access to the NumPy ufunc loops.
 5679:     The first function does general preparation and returns the required
 5680:     information. It returns this as a C capsule with the version specific
 5681:     name ``numpy_1.24_ufunc_call_info``.
 5682:     The NumPy 1.24 ufunc call info capsule has the following layout::
 5683: 
 5684:         typedef struct {
 5685:             PyArrayMethod_StridedLoop *strided_loop;
 5686:             PyArrayMethod_Context *context;
 5687:             NpyAuxData *auxdata;
 5688: 
 5689:             /* Flag information (expected to change) */
 5690:             npy_bool requires_pyapi;  /* GIL is required by loop */
 5691: 
 5692:             /* Loop doesn't set FPE flags; if not set check FPE flags */
 5693:             npy_bool no_floatingpoint_errors;
 5694:         } ufunc_call_info;
 5695: 
 5696:     Note that the first call only fills in the ``context``.  The call to
 5697:     ``_get_strided_loop`` fills in all other data.  The main thing to note is
 5698:     that the new-style loops return 0 on success, -1 on failure.  They are
 5699:     passed context as new first input and ``auxdata`` as (replaced) last.
 5700: 
 5701:     Only the ``strided_loop``signature is considered guaranteed stable
 5702:     for NumPy bug-fix releases.  All other API is tied to the experimental
 5703:     API versioning.
 5704: 
 5705:     The reason for the split call is that cast information is required to
 5706:     decide what the fixed-strides will be.
 5707: 
 5708:     NumPy ties the lifetime of the ``auxdata`` information to the capsule.
 5709: 
 5710:     """))
 5711: 
 5712: 
 5713: ##############################################################################
 5714: #
 5715: # Documentation for dtype attributes and methods
 5716: #
 5717: ##############################################################################
 5718: 
 5719: ##############################################################################
 5720: #
 5721: # dtype object
 5722: #
 5723: ##############################################################################
 5724: 
 5725: add_newdoc('numpy._core.multiarray', 'dtype',
 5726:     """
 5727:     dtype(dtype, align=False, copy=False, [metadata])
 5728: 
 5729:     Create a data type object.
 5730: 
 5731:     A numpy array is homogeneous, and contains elements described by a
 5732:     dtype object. A dtype object can be constructed from different
 5733:     combinations of fundamental numeric types.
 5734: 
 5735:     Parameters
 5736:     ----------
 5737:     dtype
 5738:         Object to be converted to a data type object.
 5739:     align : bool, optional
 5740:         Add padding to the fields to match what a C compiler would output
 5741:         for a similar C-struct. Can be ``True`` only if `obj` is a dictionary
 5742:         or a comma-separated string. If a struct dtype is being created,
 5743:         this also sets a sticky alignment flag ``isalignedstruct``.
 5744:     copy : bool, optional
 5745:         Make a new copy of the data-type object. If ``False``, the result
 5746:         may just be a reference to a built-in data-type object.
 5747:     metadata : dict, optional
 5748:         An optional dictionary with dtype metadata.
 5749: 
 5750:     See also
 5751:     --------
 5752:     result_type
 5753: 
 5754:     Examples
 5755:     --------
 5756:     Using array-scalar type:
 5757: 
 5758:     >>> import numpy as np
 5759:     >>> np.dtype(np.int16)
 5760:     dtype('int16')
 5761: 
 5762:     Structured type, one field name 'f1', containing int16:
 5763: 
 5764:     >>> np.dtype([('f1', np.int16)])
 5765:     dtype([('f1', '<i2')])
 5766: 
 5767:     Structured type, one field named 'f1', in itself containing a structured
 5768:     type with one field:
 5769: 
 5770:     >>> np.dtype([('f1', [('f1', np.int16)])])
 5771:     dtype([('f1', [('f1', '<i2')])])
 5772: 
 5773:     Structured type, two fields: the first field contains an unsigned int, the
 5774:     second an int32:
 5775: 
 5776:     >>> np.dtype([('f1', np.uint64), ('f2', np.int32)])
 5777:     dtype([('f1', '<u8'), ('f2', '<i4')])
 5778: 
 5779:     Using array-protocol type strings:
 5780: 
 5781:     >>> np.dtype([('a','f8'),('b','S10')])
 5782:     dtype([('a', '<f8'), ('b', 'S10')])
 5783: 
 5784:     Using comma-separated field formats.  The shape is (2,3):
 5785: 
 5786:     >>> np.dtype("i4, (2,3)f8")
 5787:     dtype([('f0', '<i4'), ('f1', '<f8', (2, 3))])
 5788: 
 5789:     Using tuples.  ``int`` is a fixed type, 3 the field's shape.  ``void``
 5790:     is a flexible type, here of size 10:
 5791: 
 5792:     >>> np.dtype([('hello',(np.int64,3)),('world',np.void,10)])
 5793:     dtype([('hello', '<i8', (3,)), ('world', 'V10')])
 5794: 
 5795:     Subdivide ``int16`` into 2 ``int8``'s, called x and y.  0 and 1 are
 5796:     the offsets in bytes:
 5797: 
 5798:     >>> np.dtype((np.int16, {'x':(np.int8,0), 'y':(np.int8,1)}))
 5799:     dtype((numpy.int16, [('x', 'i1'), ('y', 'i1')]))
 5800: 
 5801:     Using dictionaries.  Two fields named 'gender' and 'age':
 5802: 
 5803:     >>> np.dtype({'names':['gender','age'], 'formats':['S1',np.uint8]})
 5804:     dtype([('gender', 'S1'), ('age', 'u1')])
 5805: 
 5806:     Offsets in bytes, here 0 and 25:
 5807: 
 5808:     >>> np.dtype({'surname':('S25',0),'age':(np.uint8,25)})
 5809:     dtype([('surname', 'S25'), ('age', 'u1')])
 5810: 
 5811:     """)
 5812: 
 5813: ##############################################################################
 5814: #
 5815: # dtype attributes
 5816: #
 5817: ##############################################################################
 5818: 
 5819: add_newdoc('numpy._core.multiarray', 'dtype', ('alignment',
 5820:     """
 5821:     The required alignment (bytes) of this data-type according to the compiler.
 5822: 
 5823:     More information is available in the C-API section of the manual.
 5824: 
 5825:     Examples
 5826:     --------
 5827: 
 5828:     >>> import numpy as np
 5829:     >>> x = np.dtype('i4')
 5830:     >>> x.alignment
 5831:     4
 5832: 
 5833:     >>> x = np.dtype(float)
 5834:     >>> x.alignment
 5835:     8
 5836: 
 5837:     """))
 5838: 
 5839: add_newdoc('numpy._core.multiarray', 'dtype', ('byteorder',
 5840:     """
 5841:     A character indicating the byte-order of this data-type object.
 5842: 
 5843:     One of:
 5844: 
 5845:     ===  ==============
 5846:     '='  native
 5847:     '<'  little-endian
 5848:     '>'  big-endian
 5849:     '|'  not applicable
 5850:     ===  ==============
 5851: 
 5852:     All built-in data-type objects have byteorder either '=' or '|'.
 5853: 
 5854:     Examples
 5855:     --------
 5856: 
 5857:     >>> import numpy as np
 5858:     >>> dt = np.dtype('i2')
 5859:     >>> dt.byteorder
 5860:     '='
 5861:     >>> # endian is not relevant for 8 bit numbers
 5862:     >>> np.dtype('i1').byteorder
 5863:     '|'
 5864:     >>> # or ASCII strings
 5865:     >>> np.dtype('S2').byteorder
 5866:     '|'
 5867:     >>> # Even if specific code is given, and it is native
 5868:     >>> # '=' is the byteorder
 5869:     >>> import sys
 5870:     >>> sys_is_le = sys.byteorder == 'little'
 5871:     >>> native_code = '<' if sys_is_le else '>'
 5872:     >>> swapped_code = '>' if sys_is_le else '<'
 5873:     >>> dt = np.dtype(native_code + 'i2')
 5874:     >>> dt.byteorder
 5875:     '='
 5876:     >>> # Swapped code shows up as itself
 5877:     >>> dt = np.dtype(swapped_code + 'i2')
 5878:     >>> dt.byteorder == swapped_code
 5879:     True
 5880: 
 5881:     """))
 5882: 
 5883: add_newdoc('numpy._core.multiarray', 'dtype', ('char',
 5884:     """A unique character code for each of the 21 different built-in types.
 5885: 
 5886:     Examples
 5887:     --------
 5888: 
 5889:     >>> import numpy as np
 5890:     >>> x = np.dtype(float)
 5891:     >>> x.char
 5892:     'd'
 5893: 
 5894:     """))
 5895: 
 5896: add_newdoc('numpy._core.multiarray', 'dtype', ('descr',
 5897:     """
 5898:     `__array_interface__` description of the data-type.
 5899: 
 5900:     The format is that required by the 'descr' key in the
 5901:     `__array_interface__` attribute.
 5902: 
 5903:     Warning: This attribute exists specifically for `__array_interface__`,
 5904:     and passing it directly to `numpy.dtype` will not accurately reconstruct
 5905:     some dtypes (e.g., scalar and subarray dtypes).
 5906: 
 5907:     Examples
 5908:     --------
 5909: 
 5910:     >>> import numpy as np
 5911:     >>> x = np.dtype(float)
 5912:     >>> x.descr
 5913:     [('', '<f8')]
 5914: 
 5915:     >>> dt = np.dtype([('name', np.str_, 16), ('grades', np.float64, (2,))])
 5916:     >>> dt.descr
 5917:     [('name', '<U16'), ('grades', '<f8', (2,))]
 5918: 
 5919:     """))
 5920: 
 5921: add_newdoc('numpy._core.multiarray', 'dtype', ('fields',
 5922:     """
 5923:     Dictionary of named fields defined for this data type, or ``None``.
 5924: 
 5925:     The dictionary is indexed by keys that are the names of the fields.
 5926:     Each entry in the dictionary is a tuple fully describing the field::
 5927: 
 5928:       (dtype, offset[, title])
 5929: 
 5930:     Offset is limited to C int, which is signed and usually 32 bits.
 5931:     If present, the optional title can be any object (if it is a string
 5932:     or unicode then it will also be a key in the fields dictionary,
 5933:     otherwise it's meta-data). Notice also that the first two elements
 5934:     of the tuple can be passed directly as arguments to the
 5935:     ``ndarray.getfield`` and ``ndarray.setfield`` methods.
 5936: 
 5937:     See Also
 5938:     --------
 5939:     ndarray.getfield, ndarray.setfield
 5940: 
 5941:     Examples
 5942:     --------
 5943: 
 5944:     >>> import numpy as np
 5945:     >>> dt = np.dtype([('name', np.str_, 16), ('grades', np.float64, (2,))])
 5946:     >>> print(dt.fields)
 5947:     {'name': (dtype('|S16'), 0), 'grades': (dtype(('float64',(2,))), 16)}
 5948: 
 5949:     """))
 5950: 
 5951: add_newdoc('numpy._core.multiarray', 'dtype', ('flags',
 5952:     """
 5953:     Bit-flags describing how this data type is to be interpreted.
 5954: 
 5955:     Bit-masks are in ``numpy._core.multiarray`` as the constants
 5956:     `ITEM_HASOBJECT`, `LIST_PICKLE`, `ITEM_IS_POINTER`, `NEEDS_INIT`,
 5957:     `NEEDS_PYAPI`, `USE_GETITEM`, `USE_SETITEM`. A full explanation
 5958:     of these flags is in C-API documentation; they are largely useful
 5959:     for user-defined data-types.
 5960: 
 5961:     The following example demonstrates that operations on this particular
 5962:     dtype requires Python C-API.
 5963: 
 5964:     Examples
 5965:     --------
 5966: 
 5967:     >>> import numpy as np
 5968:     >>> x = np.dtype([('a', np.int32, 8), ('b', np.float64, 6)])
 5969:     >>> x.flags
 5970:     16
 5971:     >>> np._core.multiarray.NEEDS_PYAPI
 5972:     16
 5973: 
 5974:     """))
 5975: 
 5976: add_newdoc('numpy._core.multiarray', 'dtype', ('hasobject',
 5977:     """
 5978:     Boolean indicating whether this dtype contains any reference-counted
 5979:     objects in any fields or sub-dtypes.
 5980: 
 5981:     Recall that what is actually in the ndarray memory representing
 5982:     the Python object is the memory address of that object (a pointer).
 5983:     Special handling may be required, and this attribute is useful for
 5984:     distinguishing data types that may contain arbitrary Python objects
 5985:     and data-types that won't.
 5986: 
 5987:     """))
 5988: 
 5989: add_newdoc('numpy._core.multiarray', 'dtype', ('isbuiltin',
 5990:     """
 5991:     Integer indicating how this dtype relates to the built-in dtypes.
 5992: 
 5993:     Read-only.
 5994: 
 5995:     =  ========================================================================
 5996:     0  if this is a structured array type, with fields
 5997:     1  if this is a dtype compiled into numpy (such as ints, floats etc)
 5998:     2  if the dtype is for a user-defined numpy type
 5999:        A user-defined type uses the numpy C-API machinery to extend
 6000:        numpy to handle a new array type. See
 6001:        :ref:`user.user-defined-data-types` in the NumPy manual.
 6002:     =  ========================================================================
 6003: 
 6004:     Examples
 6005:     --------
 6006: 
 6007:     >>> import numpy as np
 6008:     >>> dt = np.dtype('i2')
 6009:     >>> dt.isbuiltin
 6010:     1
 6011:     >>> dt = np.dtype('f8')
 6012:     >>> dt.isbuiltin
 6013:     1
 6014:     >>> dt = np.dtype([('field1', 'f8')])
 6015:     >>> dt.isbuiltin
 6016:     0
 6017: 
 6018:     """))
 6019: 
 6020: add_newdoc('numpy._core.multiarray', 'dtype', ('isnative',
 6021:     """
 6022:     Boolean indicating whether the byte order of this dtype is native
 6023:     to the platform.
 6024: 
 6025:     """))
 6026: 
 6027: add_newdoc('numpy._core.multiarray', 'dtype', ('isalignedstruct',
 6028:     """
 6029:     Boolean indicating whether the dtype is a struct which maintains
 6030:     field alignment. This flag is sticky, so when combining multiple
 6031:     structs together, it is preserved and produces new dtypes which
 6032:     are also aligned.
 6033: 
 6034:     """))
 6035: 
 6036: add_newdoc('numpy._core.multiarray', 'dtype', ('itemsize',
 6037:     """
 6038:     The element size of this data-type object.
 6039: 
 6040:     For 18 of the 21 types this number is fixed by the data-type.
 6041:     For the flexible data-types, this number can be anything.
 6042: 
 6043:     Examples
 6044:     --------
 6045: 
 6046:     >>> import numpy as np
 6047:     >>> arr = np.array([[1, 2], [3, 4]])
 6048:     >>> arr.dtype
 6049:     dtype('int64')
 6050:     >>> arr.itemsize
 6051:     8
 6052: 
 6053:     >>> dt = np.dtype([('name', np.str_, 16), ('grades', np.float64, (2,))])
 6054:     >>> dt.itemsize
 6055:     80
 6056: 
 6057:     """))
 6058: 
 6059: add_newdoc('numpy._core.multiarray', 'dtype', ('kind',
 6060:     """
 6061:     A character code (one of 'biufcmMOSTUV') identifying the general kind of data.
 6062: 
 6063:     =  ======================
 6064:     b  boolean
 6065:     i  signed integer
 6066:     u  unsigned integer
 6067:     f  floating-point
 6068:     c  complex floating-point
 6069:     m  timedelta
 6070:     M  datetime
 6071:     O  object
 6072:     S  (byte-)string
 6073:     T  string (StringDType)
 6074:     U  Unicode
 6075:     V  void
 6076:     =  ======================
 6077: 
 6078:     Examples
 6079:     --------
 6080: 
 6081:     >>> import numpy as np
 6082:     >>> dt = np.dtype('i4')
 6083:     >>> dt.kind
 6084:     'i'
 6085:     >>> dt = np.dtype('f8')
 6086:     >>> dt.kind
 6087:     'f'
 6088:     >>> dt = np.dtype([('field1', 'f8')])
 6089:     >>> dt.kind
 6090:     'V'
 6091: 
 6092:     """))
 6093: 
 6094: add_newdoc('numpy._core.multiarray', 'dtype', ('metadata',
 6095:     """
 6096:     Either ``None`` or a readonly dictionary of metadata (mappingproxy).
 6097: 
 6098:     The metadata field can be set using any dictionary at data-type
 6099:     creation. NumPy currently has no uniform approach to propagating
 6100:     metadata; although some array operations preserve it, there is no
 6101:     guarantee that others will.
 6102: 
 6103:     .. warning::
 6104: 
 6105:         Although used in certain projects, this feature was long undocumented
 6106:         and is not well supported. Some aspects of metadata propagation
 6107:         are expected to change in the future.
 6108: 
 6109:     Examples
 6110:     --------
 6111: 
 6112:     >>> import numpy as np
 6113:     >>> dt = np.dtype(float, metadata={"key": "value"})
 6114:     >>> dt.metadata["key"]
 6115:     'value'
 6116:     >>> arr = np.array([1, 2, 3], dtype=dt)
 6117:     >>> arr.dtype.metadata
 6118:     mappingproxy({'key': 'value'})
 6119: 
 6120:     Adding arrays with identical datatypes currently preserves the metadata:
 6121: 
 6122:     >>> (arr + arr).dtype.metadata
 6123:     mappingproxy({'key': 'value'})
 6124: 
 6125:     If the arrays have different dtype metadata, the first one wins:
 6126: 
 6127:     >>> dt2 = np.dtype(float, metadata={"key2": "value2"})
 6128:     >>> arr2 = np.array([3, 2, 1], dtype=dt2)
 6129:     >>> print((arr + arr2).dtype.metadata)
 6130:     {'key': 'value'}
 6131:     """))
 6132: 
 6133: add_newdoc('numpy._core.multiarray', 'dtype', ('name',
 6134:     """
 6135:     A bit-width name for this data-type.
 6136: 
 6137:     Un-sized flexible data-type objects do not have this attribute.
 6138: 
 6139:     Examples
 6140:     --------
 6141: 
 6142:     >>> import numpy as np
 6143:     >>> x = np.dtype(float)
 6144:     >>> x.name
 6145:     'float64'
 6146:     >>> x = np.dtype([('a', np.int32, 8), ('b', np.float64, 6)])
 6147:     >>> x.name
 6148:     'void640'
 6149: 
 6150:     """))
 6151: 
 6152: add_newdoc('numpy._core.multiarray', 'dtype', ('names',
 6153:     """
 6154:     Ordered list of field names, or ``None`` if there are no fields.
 6155: 
 6156:     The names are ordered according to increasing byte offset. This can be
 6157:     used, for example, to walk through all of the named fields in offset order.
 6158: 
 6159:     Examples
 6160:     --------
 6161:     >>> dt = np.dtype([('name', np.str_, 16), ('grades', np.float64, (2,))])
 6162:     >>> dt.names
 6163:     ('name', 'grades')
 6164: 
 6165:     """))
 6166: 
 6167: add_newdoc('numpy._core.multiarray', 'dtype', ('num',
 6168:     """
 6169:     A unique number for each of the 21 different built-in types.
 6170: 
 6171:     These are roughly ordered from least-to-most precision.
 6172: 
 6173:     Examples
 6174:     --------
 6175: 
 6176:     >>> import numpy as np
 6177:     >>> dt = np.dtype(str)
 6178:     >>> dt.num
 6179:     19
 6180: 
 6181:     >>> dt = np.dtype(float)
 6182:     >>> dt.num
 6183:     12
 6184: 
 6185:     """))
 6186: 
 6187: add_newdoc('numpy._core.multiarray', 'dtype', ('shape',
 6188:     """
 6189:     Shape tuple of the sub-array if this data type describes a sub-array,
 6190:     and ``()`` otherwise.
 6191: 
 6192:     Examples
 6193:     --------
 6194: 
 6195:     >>> import numpy as np
 6196:     >>> dt = np.dtype(('i4', 4))
 6197:     >>> dt.shape
 6198:     (4,)
 6199: 
 6200:     >>> dt = np.dtype(('i4', (2, 3)))
 6201:     >>> dt.shape
 6202:     (2, 3)
 6203: 
 6204:     """))
 6205: 
 6206: add_newdoc('numpy._core.multiarray', 'dtype', ('ndim',
 6207:     """
 6208:     Number of dimensions of the sub-array if this data type describes a
 6209:     sub-array, and ``0`` otherwise.
 6210: 
 6211:     Examples
 6212:     --------
 6213:     >>> import numpy as np
 6214:     >>> x = np.dtype(float)
 6215:     >>> x.ndim
 6216:     0
 6217: 
 6218:     >>> x = np.dtype((float, 8))
 6219:     >>> x.ndim
 6220:     1
 6221: 
 6222:     >>> x = np.dtype(('i4', (3, 4)))
 6223:     >>> x.ndim
 6224:     2
 6225: 
 6226:     """))
 6227: 
 6228: add_newdoc('numpy._core.multiarray', 'dtype', ('str',
 6229:     """The array-protocol typestring of this data-type object."""))
 6230: 
 6231: add_newdoc('numpy._core.multiarray', 'dtype', ('subdtype',
 6232:     """
 6233:     Tuple ``(item_dtype, shape)`` if this `dtype` describes a sub-array, and
 6234:     None otherwise.
 6235: 
 6236:     The *shape* is the fixed shape of the sub-array described by this
 6237:     data type, and *item_dtype* the data type of the array.
 6238: 
 6239:     If a field whose dtype object has this attribute is retrieved,
 6240:     then the extra dimensions implied by *shape* are tacked on to
 6241:     the end of the retrieved array.
 6242: 
 6243:     See Also
 6244:     --------
 6245:     dtype.base
 6246: 
 6247:     Examples
 6248:     --------
 6249:     >>> import numpy as np
 6250:     >>> x = np.dtype('8f')
 6251:     >>> x.subdtype
 6252:     (dtype('float32'), (8,))
 6253: 
 6254:     >>> x =  np.dtype('i2')
 6255:     >>> x.subdtype
 6256:     >>>
 6257: 
 6258:     """))
 6259: 
 6260: add_newdoc('numpy._core.multiarray', 'dtype', ('base',
 6261:     """
 6262:     Returns dtype for the base element of the subarrays,
 6263:     regardless of their dimension or shape.
 6264: 
 6265:     See Also
 6266:     --------
 6267:     dtype.subdtype
 6268: 
 6269:     Examples
 6270:     --------
 6271:     >>> import numpy as np
 6272:     >>> x = np.dtype('8f')
 6273:     >>> x.base
 6274:     dtype('float32')
 6275: 
 6276:     >>> x =  np.dtype('i2')
 6277:     >>> x.base
 6278:     dtype('int16')
 6279: 
 6280:     """))
 6281: 
 6282: add_newdoc('numpy._core.multiarray', 'dtype', ('type',
 6283:     """The type object used to instantiate a scalar of this data-type."""))
 6284: 
 6285: ##############################################################################
 6286: #
 6287: # dtype methods
 6288: #
 6289: ##############################################################################
 6290: 
 6291: add_newdoc('numpy._core.multiarray', 'dtype', ('newbyteorder',
 6292:     """
 6293:     newbyteorder(new_order='S', /)
 6294: 
 6295:     Return a new dtype with a different byte order.
 6296: 
 6297:     Changes are also made in all fields and sub-arrays of the data type.
 6298: 
 6299:     Parameters
 6300:     ----------
 6301:     new_order : string, optional
 6302:         Byte order to force; a value from the byte order specifications
 6303:         below.  The default value ('S') results in swapping the current
 6304:         byte order.  `new_order` codes can be any of:
 6305: 
 6306:         * 'S' - swap dtype from current to opposite endian
 6307:         * {'<', 'little'} - little endian
 6308:         * {'>', 'big'} - big endian
 6309:         * {'=', 'native'} - native order
 6310:         * {'|', 'I'} - ignore (no change to byte order)
 6311: 
 6312:     Returns
 6313:     -------
 6314:     new_dtype : dtype
 6315:         New dtype object with the given change to the byte order.
 6316: 
 6317:     Notes
 6318:     -----
 6319:     Changes are also made in all fields and sub-arrays of the data type.
 6320: 
 6321:     Examples
 6322:     --------
 6323:     >>> import sys
 6324:     >>> sys_is_le = sys.byteorder == 'little'
 6325:     >>> native_code = '<' if sys_is_le else '>'
 6326:     >>> swapped_code = '>' if sys_is_le else '<'
 6327:     >>> import numpy as np
 6328:     >>> native_dt = np.dtype(native_code+'i2')
 6329:     >>> swapped_dt = np.dtype(swapped_code+'i2')
 6330:     >>> native_dt.newbyteorder('S') == swapped_dt
 6331:     True
 6332:     >>> native_dt.newbyteorder() == swapped_dt
 6333:     True
 6334:     >>> native_dt == swapped_dt.newbyteorder('S')
 6335:     True
 6336:     >>> native_dt == swapped_dt.newbyteorder('=')
 6337:     True
 6338:     >>> native_dt == swapped_dt.newbyteorder('N')
 6339:     True
 6340:     >>> native_dt == native_dt.newbyteorder('|')
 6341:     True
 6342:     >>> np.dtype('<i2') == native_dt.newbyteorder('<')
 6343:     True
 6344:     >>> np.dtype('<i2') == native_dt.newbyteorder('L')
 6345:     True
 6346:     >>> np.dtype('>i2') == native_dt.newbyteorder('>')
 6347:     True
 6348:     >>> np.dtype('>i2') == native_dt.newbyteorder('B')
 6349:     True
 6350: 
 6351:     """))
 6352: 
 6353: add_newdoc('numpy._core.multiarray', 'dtype', ('__class_getitem__',
 6354:     """
 6355:     __class_getitem__(item, /)
 6356: 
 6357:     Return a parametrized wrapper around the `~numpy.dtype` type.
 6358: 
 6359:     .. versionadded:: 1.22
 6360: 
 6361:     Returns
 6362:     -------
 6363:     alias : types.GenericAlias
 6364:         A parametrized `~numpy.dtype` type.
 6365: 
 6366:     Examples
 6367:     --------
 6368:     >>> import numpy as np
 6369: 
 6370:     >>> np.dtype[np.int64]
 6371:     numpy.dtype[numpy.int64]
 6372: 
 6373:     See Also
 6374:     --------
 6375:     :pep:`585` : Type hinting generics in standard collections.
 6376: 
 6377:     """))
 6378: 
 6379: add_newdoc('numpy._core.multiarray', 'dtype', ('__ge__',
 6380:     """
 6381:     __ge__(value, /)
 6382: 
 6383:     Return ``self >= value``.
 6384: 
 6385:     Equivalent to ``np.can_cast(value, self, casting="safe")``.
 6386: 
 6387:     See Also
 6388:     --------
 6389:     can_cast : Returns True if cast between data types can occur according to
 6390:                the casting rule.
 6391: 
 6392:     """))
 6393: 
 6394: add_newdoc('numpy._core.multiarray', 'dtype', ('__le__',
 6395:     """
 6396:     __le__(value, /)
 6397: 
 6398:     Return ``self <= value``.
 6399: 
 6400:     Equivalent to ``np.can_cast(self, value, casting="safe")``.
 6401: 
 6402:     See Also
 6403:     --------
 6404:     can_cast : Returns True if cast between data types can occur according to
 6405:                the casting rule.
 6406: 
 6407:     """))
 6408: 
 6409: add_newdoc('numpy._core.multiarray', 'dtype', ('__gt__',
 6410:     """
 6411:     __ge__(value, /)
 6412: 
 6413:     Return ``self > value``.
 6414: 
 6415:     Equivalent to
 6416:     ``self != value and np.can_cast(value, self, casting="safe")``.
 6417: 
 6418:     See Also
 6419:     --------
 6420:     can_cast : Returns True if cast between data types can occur according to
 6421:                the casting rule.
 6422: 
 6423:     """))
 6424: 
 6425: add_newdoc('numpy._core.multiarray', 'dtype', ('__lt__',
 6426:     """
 6427:     __lt__(value, /)
 6428: 
 6429:     Return ``self < value``.
 6430: 
 6431:     Equivalent to
 6432:     ``self != value and np.can_cast(self, value, casting="safe")``.
 6433: 
 6434:     See Also
 6435:     --------
 6436:     can_cast : Returns True if cast between data types can occur according to
 6437:                the casting rule.
 6438: 
 6439:     """))
 6440: 
 6441: ##############################################################################
 6442: #
 6443: # Datetime-related Methods
 6444: #
 6445: ##############################################################################
 6446: 
 6447: add_newdoc('numpy._core.multiarray', 'busdaycalendar',
 6448:     """
 6449:     busdaycalendar(weekmask='1111100', holidays=None)
 6450: 
 6451:     A business day calendar object that efficiently stores information
 6452:     defining valid days for the busday family of functions.
 6453: 
 6454:     The default valid days are Monday through Friday ("business days").
 6455:     A busdaycalendar object can be specified with any set of weekly
 6456:     valid days, plus an optional "holiday" dates that always will be invalid.
 6457: 
 6458:     Once a busdaycalendar object is created, the weekmask and holidays
 6459:     cannot be modified.
 6460: 
 6461:     Parameters
 6462:     ----------
 6463:     weekmask : str or array_like of bool, optional
 6464:         A seven-element array indicating which of Monday through Sunday are
 6465:         valid days. May be specified as a length-seven list or array, like
 6466:         [1,1,1,1,1,0,0]; a length-seven string, like '1111100'; or a string
 6467:         like "Mon Tue Wed Thu Fri", made up of 3-character abbreviations for
 6468:         weekdays, optionally separated by white space. Valid abbreviations
 6469:         are: Mon Tue Wed Thu Fri Sat Sun
 6470:     holidays : array_like of datetime64[D], optional
 6471:         An array of dates to consider as invalid dates, no matter which
 6472:         weekday they fall upon.  Holiday dates may be specified in any
 6473:         order, and NaT (not-a-time) dates are ignored.  This list is
 6474:         saved in a normalized form that is suited for fast calculations
 6475:         of valid days.
 6476: 
 6477:     Returns
 6478:     -------
 6479:     out : busdaycalendar
 6480:         A business day calendar object containing the specified
 6481:         weekmask and holidays values.
 6482: 
 6483:     See Also
 6484:     --------
 6485:     is_busday : Returns a boolean array indicating valid days.
 6486:     busday_offset : Applies an offset counted in valid days.
 6487:     busday_count : Counts how many valid days are in a half-open date range.
 6488: 
 6489:     Attributes
 6490:     ----------
 6491:     weekmask : (copy) seven-element array of bool
 6492:     holidays : (copy) sorted array of datetime64[D]
 6493: 
 6494:     Notes
 6495:     -----
 6496:     Once a busdaycalendar object is created, you cannot modify the
 6497:     weekmask or holidays.  The attributes return copies of internal data.
 6498: 
 6499:     Examples
 6500:     --------
 6501:     >>> import numpy as np
 6502:     >>> # Some important days in July
 6503:     ... bdd = np.busdaycalendar(
 6504:     ...             holidays=['2011-07-01', '2011-07-04', '2011-07-17'])
 6505:     >>> # Default is Monday to Friday weekdays
 6506:     ... bdd.weekmask
 6507:     array([ True,  True,  True,  True,  True, False, False])
 6508:     >>> # Any holidays already on the weekend are removed
 6509:     ... bdd.holidays
 6510:     array(['2011-07-01', '2011-07-04'], dtype='datetime64[D]')
 6511:     """)
 6512: 
 6513: add_newdoc('numpy._core.multiarray', 'busdaycalendar', ('weekmask',
 6514:     """A copy of the seven-element boolean mask indicating valid days."""))
 6515: 
 6516: add_newdoc('numpy._core.multiarray', 'busdaycalendar', ('holidays',
 6517:     """A copy of the holiday array indicating additional invalid days."""))
 6518: 
 6519: add_newdoc('numpy._core.multiarray', 'normalize_axis_index',
 6520:     """
 6521:     normalize_axis_index(axis, ndim, msg_prefix=None)
 6522: 
 6523:     Normalizes an axis index, `axis`, such that is a valid positive index into
 6524:     the shape of array with `ndim` dimensions. Raises an AxisError with an
 6525:     appropriate message if this is not possible.
 6526: 
 6527:     Used internally by all axis-checking logic.
 6528: 
 6529:     Parameters
 6530:     ----------
 6531:     axis : int
 6532:         The un-normalized index of the axis. Can be negative
 6533:     ndim : int
 6534:         The number of dimensions of the array that `axis` should be normalized
 6535:         against
 6536:     msg_prefix : str
 6537:         A prefix to put before the message, typically the name of the argument
 6538: 
 6539:     Returns
 6540:     -------
 6541:     normalized_axis : int
 6542:         The normalized axis index, such that `0 <= normalized_axis < ndim`
 6543: 
 6544:     Raises
 6545:     ------
 6546:     AxisError
 6547:         If the axis index is invalid, when `-ndim <= axis < ndim` is false.
 6548: 
 6549:     Examples
 6550:     --------
 6551:     >>> import numpy as np
 6552:     >>> from numpy.lib.array_utils import normalize_axis_index
 6553:     >>> normalize_axis_index(0, ndim=3)
 6554:     0
 6555:     >>> normalize_axis_index(1, ndim=3)
 6556:     1
 6557:     >>> normalize_axis_index(-1, ndim=3)
 6558:     2
 6559: 
 6560:     >>> normalize_axis_index(3, ndim=3)
 6561:     Traceback (most recent call last):
 6562:     ...
 6563:     numpy.exceptions.AxisError: axis 3 is out of bounds for array ...
 6564:     >>> normalize_axis_index(-4, ndim=3, msg_prefix='axes_arg')
 6565:     Traceback (most recent call last):
 6566:     ...
 6567:     numpy.exceptions.AxisError: axes_arg: axis -4 is out of bounds ...
 6568:     """)
 6569: 
 6570: add_newdoc('numpy._core.multiarray', 'datetime_data',
 6571:     """
 6572:     datetime_data(dtype, /)
 6573: 
 6574:     Get information about the step size of a date or time type.
 6575: 
 6576:     The returned tuple can be passed as the second argument of `numpy.datetime64` and
 6577:     `numpy.timedelta64`.
 6578: 
 6579:     Parameters
 6580:     ----------
 6581:     dtype : dtype
 6582:         The dtype object, which must be a `datetime64` or `timedelta64` type.
 6583: 
 6584:     Returns
 6585:     -------
 6586:     unit : str
 6587:         The :ref:`datetime unit <arrays.dtypes.dateunits>` on which this dtype
 6588:         is based.
 6589:     count : int
 6590:         The number of base units in a step.
 6591: 
 6592:     Examples
 6593:     --------
 6594:     >>> import numpy as np
 6595:     >>> dt_25s = np.dtype('timedelta64[25s]')
 6596:     >>> np.datetime_data(dt_25s)
 6597:     ('s', 25)
 6598:     >>> np.array(10, dt_25s).astype('timedelta64[s]')
 6599:     array(250, dtype='timedelta64[s]')
 6600: 
 6601:     The result can be used to construct a datetime that uses the same units
 6602:     as a timedelta
 6603: 
 6604:     >>> np.datetime64('2010', np.datetime_data(dt_25s))
 6605:     np.datetime64('2010-01-01T00:00:00','25s')
 6606:     """)
 6607: 
 6608: 
 6609: ##############################################################################
 6610: #
 6611: # Documentation for `generic` attributes and methods
 6612: #
 6613: ##############################################################################
 6614: 
 6615: add_newdoc('numpy._core.numerictypes', 'generic',
 6616:     """
 6617:     Base class for numpy scalar types.
 6618: 
 6619:     Class from which most (all?) numpy scalar types are derived.  For
 6620:     consistency, exposes the same API as `ndarray`, despite many
 6621:     consequent attributes being either "get-only," or completely irrelevant.
 6622:     This is the class from which it is strongly suggested users should derive
 6623:     custom scalar types.
 6624: 
 6625:     """)
 6626: 
 6627: # Attributes
 6628: 
 6629: def refer_to_array_attribute(attr, method=True):
 6630:     docstring = """
 6631:     Scalar {} identical to the corresponding array attribute.
 6632: 
 6633:     Please see `ndarray.{}`.
 6634:     """
 6635: 
 6636:     return attr, docstring.format("method" if method else "attribute", attr)
 6637: 
 6638: 
 6639: add_newdoc('numpy._core.numerictypes', 'generic',
 6640:            refer_to_array_attribute('T', method=False))
 6641: 
 6642: add_newdoc('numpy._core.numerictypes', 'generic',
 6643:            refer_to_array_attribute('base', method=False))
 6644: 
 6645: add_newdoc('numpy._core.numerictypes', 'generic', ('data',
 6646:     """Pointer to start of data."""))
 6647: 
 6648: add_newdoc('numpy._core.numerictypes', 'generic', ('dtype',
 6649:     """Get array data-descriptor."""))
 6650: 
 6651: add_newdoc('numpy._core.numerictypes', 'generic', ('flags',
 6652:     """The integer value of flags."""))
 6653: 
 6654: add_newdoc('numpy._core.numerictypes', 'generic', ('flat',
 6655:     """A 1-D view of the scalar."""))
 6656: 
 6657: add_newdoc('numpy._core.numerictypes', 'generic', ('imag',
 6658:     """The imaginary part of the scalar."""))
 6659: 
 6660: add_newdoc('numpy._core.numerictypes', 'generic', ('itemsize',
 6661:     """The length of one element in bytes."""))
 6662: 
 6663: add_newdoc('numpy._core.numerictypes', 'generic', ('ndim',
 6664:     """The number of array dimensions."""))
 6665: 
 6666: add_newdoc('numpy._core.numerictypes', 'generic', ('real',
 6667:     """The real part of the scalar."""))
 6668: 
 6669: add_newdoc('numpy._core.numerictypes', 'generic', ('shape',
 6670:     """Tuple of array dimensions."""))
 6671: 
 6672: add_newdoc('numpy._core.numerictypes', 'generic', ('size',
 6673:     """The number of elements in the gentype."""))
 6674: 
 6675: add_newdoc('numpy._core.numerictypes', 'generic', ('strides',
 6676:     """Tuple of bytes steps in each dimension."""))
 6677: 
 6678: # Methods
 6679: 
 6680: add_newdoc('numpy._core.numerictypes', 'generic',
 6681:            refer_to_array_attribute('all'))
 6682: 
 6683: add_newdoc('numpy._core.numerictypes', 'generic',
 6684:            refer_to_array_attribute('any'))
 6685: 
 6686: add_newdoc('numpy._core.numerictypes', 'generic',
 6687:            refer_to_array_attribute('argmax'))
 6688: 
 6689: add_newdoc('numpy._core.numerictypes', 'generic',
 6690:            refer_to_array_attribute('argmin'))
 6691: 
 6692: add_newdoc('numpy._core.numerictypes', 'generic',
 6693:            refer_to_array_attribute('argsort'))
 6694: 
 6695: add_newdoc('numpy._core.numerictypes', 'generic',
 6696:            refer_to_array_attribute('astype'))
 6697: 
 6698: add_newdoc('numpy._core.numerictypes', 'generic',
 6699:            refer_to_array_attribute('byteswap'))
 6700: 
 6701: add_newdoc('numpy._core.numerictypes', 'generic',
 6702:            refer_to_array_attribute('choose'))
 6703: 
 6704: add_newdoc('numpy._core.numerictypes', 'generic',
 6705:            refer_to_array_attribute('clip'))
 6706: 
 6707: add_newdoc('numpy._core.numerictypes', 'generic',
 6708:            refer_to_array_attribute('compress'))
 6709: 
 6710: add_newdoc('numpy._core.numerictypes', 'generic',
 6711:            refer_to_array_attribute('conjugate'))
 6712: 
 6713: add_newdoc('numpy._core.numerictypes', 'generic',
 6714:            refer_to_array_attribute('copy'))
 6715: 
 6716: add_newdoc('numpy._core.numerictypes', 'generic',
 6717:            refer_to_array_attribute('cumprod'))
 6718: 
 6719: add_newdoc('numpy._core.numerictypes', 'generic',
 6720:            refer_to_array_attribute('cumsum'))
 6721: 
 6722: add_newdoc('numpy._core.numerictypes', 'generic',
 6723:            refer_to_array_attribute('diagonal'))
 6724: 
 6725: add_newdoc('numpy._core.numerictypes', 'generic',
 6726:            refer_to_array_attribute('dump'))
 6727: 
 6728: add_newdoc('numpy._core.numerictypes', 'generic',
 6729:            refer_to_array_attribute('dumps'))
 6730: 
 6731: add_newdoc('numpy._core.numerictypes', 'generic',
 6732:            refer_to_array_attribute('fill'))
 6733: 
 6734: add_newdoc('numpy._core.numerictypes', 'generic',
 6735:            refer_to_array_attribute('flatten'))
 6736: 
 6737: add_newdoc('numpy._core.numerictypes', 'generic',
 6738:            refer_to_array_attribute('getfield'))
 6739: 
 6740: add_newdoc('numpy._core.numerictypes', 'generic',
 6741:            refer_to_array_attribute('item'))
 6742: 
 6743: add_newdoc('numpy._core.numerictypes', 'generic',
 6744:            refer_to_array_attribute('max'))
 6745: 
 6746: add_newdoc('numpy._core.numerictypes', 'generic',
 6747:            refer_to_array_attribute('mean'))
 6748: 
 6749: add_newdoc('numpy._core.numerictypes', 'generic',
 6750:            refer_to_array_attribute('min'))
 6751: 
 6752: add_newdoc('numpy._core.numerictypes', 'generic',
 6753:            refer_to_array_attribute('nonzero'))
 6754: 
 6755: add_newdoc('numpy._core.numerictypes', 'generic',
 6756:            refer_to_array_attribute('prod'))
 6757: 
 6758: add_newdoc('numpy._core.numerictypes', 'generic',
 6759:            refer_to_array_attribute('put'))
 6760: 
 6761: add_newdoc('numpy._core.numerictypes', 'generic',
 6762:            refer_to_array_attribute('ravel'))
 6763: 
 6764: add_newdoc('numpy._core.numerictypes', 'generic',
 6765:            refer_to_array_attribute('repeat'))
 6766: 
 6767: add_newdoc('numpy._core.numerictypes', 'generic',
 6768:            refer_to_array_attribute('reshape'))
 6769: 
 6770: add_newdoc('numpy._core.numerictypes', 'generic',
 6771:            refer_to_array_attribute('resize'))
 6772: 
 6773: add_newdoc('numpy._core.numerictypes', 'generic',
 6774:            refer_to_array_attribute('round'))
 6775: 
 6776: add_newdoc('numpy._core.numerictypes', 'generic',
 6777:            refer_to_array_attribute('searchsorted'))
 6778: 
 6779: add_newdoc('numpy._core.numerictypes', 'generic',
 6780:            refer_to_array_attribute('setfield'))
 6781: 
 6782: add_newdoc('numpy._core.numerictypes', 'generic',
 6783:            refer_to_array_attribute('setflags'))
 6784: 
 6785: add_newdoc('numpy._core.numerictypes', 'generic',
 6786:            refer_to_array_attribute('sort'))
 6787: 
 6788: add_newdoc('numpy._core.numerictypes', 'generic',
 6789:            refer_to_array_attribute('squeeze'))
 6790: 
 6791: add_newdoc('numpy._core.numerictypes', 'generic',
 6792:            refer_to_array_attribute('std'))
 6793: 
 6794: add_newdoc('numpy._core.numerictypes', 'generic',
 6795:            refer_to_array_attribute('sum'))
 6796: 
 6797: add_newdoc('numpy._core.numerictypes', 'generic',
 6798:            refer_to_array_attribute('swapaxes'))
 6799: 
 6800: add_newdoc('numpy._core.numerictypes', 'generic',
 6801:            refer_to_array_attribute('take'))
 6802: 
 6803: add_newdoc('numpy._core.numerictypes', 'generic',
 6804:            refer_to_array_attribute('tofile'))
 6805: 
 6806: add_newdoc('numpy._core.numerictypes', 'generic',
 6807:            refer_to_array_attribute('tolist'))
 6808: 
 6809: add_newdoc('numpy._core.numerictypes', 'generic',
 6810:            refer_to_array_attribute('tostring'))
 6811: 
 6812: add_newdoc('numpy._core.numerictypes', 'generic',
 6813:            refer_to_array_attribute('trace'))
 6814: 
 6815: add_newdoc('numpy._core.numerictypes', 'generic',
 6816:            refer_to_array_attribute('transpose'))
 6817: 
 6818: add_newdoc('numpy._core.numerictypes', 'generic',
 6819:            refer_to_array_attribute('var'))
 6820: 
 6821: add_newdoc('numpy._core.numerictypes', 'generic',
 6822:            refer_to_array_attribute('view'))
 6823: 
 6824: add_newdoc('numpy._core.numerictypes', 'number', ('__class_getitem__',
 6825:     """
 6826:     __class_getitem__(item, /)
 6827: 
 6828:     Return a parametrized wrapper around the `~numpy.number` type.
 6829: 
 6830:     .. versionadded:: 1.22
 6831: 
 6832:     Returns
 6833:     -------
 6834:     alias : types.GenericAlias
 6835:         A parametrized `~numpy.number` type.
 6836: 
 6837:     Examples
 6838:     --------
 6839:     >>> from typing import Any
 6840:     >>> import numpy as np
 6841: 
 6842:     >>> np.signedinteger[Any]
 6843:     numpy.signedinteger[typing.Any]
 6844: 
 6845:     See Also
 6846:     --------
 6847:     :pep:`585` : Type hinting generics in standard collections.
 6848: 
 6849:     """))
 6850: 
 6851: ##############################################################################
 6852: #
 6853: # Documentation for scalar type abstract base classes in type hierarchy
 6854: #
 6855: ##############################################################################
 6856: 
 6857: 
 6858: add_newdoc('numpy._core.numerictypes', 'number',
 6859:     """
 6860:     Abstract base class of all numeric scalar types.
 6861: 
 6862:     """)
 6863: 
 6864: add_newdoc('numpy._core.numerictypes', 'integer',
 6865:     """
 6866:     Abstract base class of all integer scalar types.
 6867: 
 6868:     """)
 6869: 
 6870: add_newdoc('numpy._core.numerictypes', 'signedinteger',
 6871:     """
 6872:     Abstract base class of all signed integer scalar types.
 6873: 
 6874:     """)
 6875: 
 6876: add_newdoc('numpy._core.numerictypes', 'unsignedinteger',
 6877:     """
 6878:     Abstract base class of all unsigned integer scalar types.
 6879: 
 6880:     """)
 6881: 
 6882: add_newdoc('numpy._core.numerictypes', 'inexact',
 6883:     """
 6884:     Abstract base class of all numeric scalar types with a (potentially)
 6885:     inexact representation of the values in its range, such as
 6886:     floating-point numbers.
 6887: 
 6888:     """)
 6889: 
 6890: add_newdoc('numpy._core.numerictypes', 'floating',
 6891:     """
 6892:     Abstract base class of all floating-point scalar types.
 6893: 
 6894:     """)
 6895: 
 6896: add_newdoc('numpy._core.numerictypes', 'complexfloating',
 6897:     """
 6898:     Abstract base class of all complex number scalar types that are made up of
 6899:     floating-point numbers.
 6900: 
 6901:     """)
 6902: 
 6903: add_newdoc('numpy._core.numerictypes', 'flexible',
 6904:     """
 6905:     Abstract base class of all scalar types without predefined length.
 6906:     The actual size of these types depends on the specific `numpy.dtype`
 6907:     instantiation.
 6908: 
 6909:     """)
 6910: 
 6911: add_newdoc('numpy._core.numerictypes', 'character',
 6912:     """
 6913:     Abstract base class of all character string scalar types.
 6914: 
 6915:     """)
 6916: 
 6917: add_newdoc('numpy._core.multiarray', 'StringDType',
 6918:     """
 6919:     StringDType(*, na_object=np._NoValue, coerce=True)
 6920: 
 6921:     Create a StringDType instance.
 6922: 
 6923:     StringDType can be used to store UTF-8 encoded variable-width strings in
 6924:     a NumPy array.
 6925: 
 6926:     Parameters
 6927:     ----------
 6928:     na_object : object, optional
 6929:         Object used to represent missing data. If unset, the array will not
 6930:         use a missing data sentinel.
 6931:     coerce : bool, optional
 6932:         Whether or not items in an array-like passed to an array creation
 6933:         function that are neither a str or str subtype should be coerced to
 6934:         str. Defaults to True. If set to False, creating a StringDType
 6935:         array from an array-like containing entries that are not already
 6936:         strings will raise an error.
 6937: 
 6938:     Examples
 6939:     --------
 6940: 
 6941:     >>> import numpy as np
 6942: 
 6943:     >>> from numpy.dtypes import StringDType
 6944:     >>> np.array(["hello", "world"], dtype=StringDType())
 6945:     array(["hello", "world"], dtype=StringDType())
 6946: 
 6947:     >>> arr = np.array(["hello", None, "world"],
 6948:     ...                dtype=StringDType(na_object=None))
 6949:     >>> arr
 6950:     array(["hello", None, "world"], dtype=StringDType(na_object=None))
 6951:     >>> arr[1] is None
 6952:     True
 6953: 
 6954:     >>> arr = np.array(["hello", np.nan, "world"],
 6955:     ...                dtype=StringDType(na_object=np.nan))
 6956:     >>> np.isnan(arr)
 6957:     array([False, True, False])
 6958: 
 6959:     >>> np.array([1.2, object(), "hello world"],
 6960:     ...          dtype=StringDType(coerce=False))
 6961:     Traceback (most recent call last):
 6962:         ...
 6963:     ValueError: StringDType only allows string data when string coercion is disabled.
 6964: 
 6965:     >>> np.array(["hello", "world"], dtype=StringDType(coerce=True))
 6966:     array(["hello", "world"], dtype=StringDType(coerce=True))
 6967:     """)
