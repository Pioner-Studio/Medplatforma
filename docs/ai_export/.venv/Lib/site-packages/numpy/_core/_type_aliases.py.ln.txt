    1: """
    2: Due to compatibility, numpy has a very large number of different naming
    3: conventions for the scalar types (those subclassing from `numpy.generic`).
    4: This file produces a convoluted set of dictionaries mapping names to types,
    5: and sometimes other mappings too.
    6: 
    7: .. data:: allTypes
    8:     A dictionary of names to types that will be exposed as attributes through
    9:     ``np._core.numerictypes.*``
   10: 
   11: .. data:: sctypeDict
   12:     Similar to `allTypes`, but maps a broader set of aliases to their types.
   13: 
   14: .. data:: sctypes
   15:     A dictionary keyed by a "type group" string, providing a list of types
   16:     under that group.
   17: 
   18: """
   19: 
   20: import numpy._core.multiarray as ma
   21: from numpy._core.multiarray import dtype, typeinfo
   22: 
   23: ######################################
   24: # Building `sctypeDict` and `allTypes`
   25: ######################################
   26: 
   27: sctypeDict = {}
   28: allTypes = {}
   29: c_names_dict = {}
   30: 
   31: _abstract_type_names = {
   32:     "generic", "integer", "inexact", "floating", "number",
   33:     "flexible", "character", "complexfloating", "unsignedinteger",
   34:     "signedinteger"
   35: }
   36: 
   37: for _abstract_type_name in _abstract_type_names:
   38:     allTypes[_abstract_type_name] = getattr(ma, _abstract_type_name)
   39: 
   40: for k, v in typeinfo.items():
   41:     if k.startswith("NPY_") and v not in c_names_dict:
   42:         c_names_dict[k[4:]] = v
   43:     else:
   44:         concrete_type = v.type
   45:         allTypes[k] = concrete_type
   46:         sctypeDict[k] = concrete_type
   47: 
   48: _aliases = {
   49:     "double": "float64",
   50:     "cdouble": "complex128",
   51:     "single": "float32",
   52:     "csingle": "complex64",
   53:     "half": "float16",
   54:     "bool_": "bool",
   55:     # Default integer:
   56:     "int_": "intp",
   57:     "uint": "uintp",
   58: }
   59: 
   60: for k, v in _aliases.items():
   61:     sctypeDict[k] = allTypes[v]
   62:     allTypes[k] = allTypes[v]
   63: 
   64: # extra aliases are added only to `sctypeDict`
   65: # to support dtype name access, such as`np.dtype("float")`
   66: _extra_aliases = {
   67:     "float": "float64",
   68:     "complex": "complex128",
   69:     "object": "object_",
   70:     "bytes": "bytes_",
   71:     "a": "bytes_",
   72:     "int": "int_",
   73:     "str": "str_",
   74:     "unicode": "str_",
   75: }
   76: 
   77: for k, v in _extra_aliases.items():
   78:     sctypeDict[k] = allTypes[v]
   79: 
   80: # include extended precision sized aliases
   81: for is_complex, full_name in [(False, "longdouble"), (True, "clongdouble")]:
   82:     longdouble_type: type = allTypes[full_name]
   83: 
   84:     bits: int = dtype(longdouble_type).itemsize * 8
   85:     base_name: str = "complex" if is_complex else "float"
   86:     extended_prec_name: str = f"{base_name}{bits}"
   87:     if extended_prec_name not in allTypes:
   88:         sctypeDict[extended_prec_name] = longdouble_type
   89:         allTypes[extended_prec_name] = longdouble_type
   90: 
   91: 
   92: ####################
   93: # Building `sctypes`
   94: ####################
   95: 
   96: sctypes = {"int": set(), "uint": set(), "float": set(),
   97:            "complex": set(), "others": set()}
   98: 
   99: for type_info in typeinfo.values():
  100:     if type_info.kind in ["M", "m"]:  # exclude timedelta and datetime
  101:         continue
  102: 
  103:     concrete_type = type_info.type
  104: 
  105:     # find proper group for each concrete type
  106:     for type_group, abstract_type in [
  107:         ("int", ma.signedinteger), ("uint", ma.unsignedinteger),
  108:         ("float", ma.floating), ("complex", ma.complexfloating),
  109:         ("others", ma.generic)
  110:     ]:
  111:         if issubclass(concrete_type, abstract_type):
  112:             sctypes[type_group].add(concrete_type)
  113:             break
  114: 
  115: # sort sctype groups by bitsize
  116: for sctype_key in sctypes.keys():
  117:     sctype_list = list(sctypes[sctype_key])
  118:     sctype_list.sort(key=lambda x: dtype(x).itemsize)
  119:     sctypes[sctype_key] = sctype_list
