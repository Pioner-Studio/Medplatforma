    1: import ctypes as ct
    2: import itertools
    3: import pickle
    4: import sys
    5: import warnings
    6: 
    7: import numpy._core._operand_flag_tests as opflag_tests
    8: import numpy._core._rational_tests as _rational_tests
    9: import numpy._core._umath_tests as umt
   10: import pytest
   11: from pytest import param
   12: 
   13: import numpy as np
   14: import numpy._core.umath as ncu
   15: import numpy.linalg._umath_linalg as uml
   16: from numpy.exceptions import AxisError
   17: from numpy.testing import (
   18:     HAS_REFCOUNT,
   19:     IS_PYPY,
   20:     IS_WASM,
   21:     assert_,
   22:     assert_allclose,
   23:     assert_almost_equal,
   24:     assert_array_almost_equal,
   25:     assert_array_equal,
   26:     assert_equal,
   27:     assert_no_warnings,
   28:     assert_raises,
   29:     suppress_warnings,
   30: )
   31: from numpy.testing._private.utils import requires_memory
   32: 
   33: UNARY_UFUNCS = [obj for obj in np._core.umath.__dict__.values()
   34:                     if isinstance(obj, np.ufunc)]
   35: UNARY_OBJECT_UFUNCS = [uf for uf in UNARY_UFUNCS if "O->O" in uf.types]
   36: 
   37: # Remove functions that do not support `floats`
   38: UNARY_OBJECT_UFUNCS.remove(np.bitwise_count)
   39: 
   40: 
   41: class TestUfuncKwargs:
   42:     def test_kwarg_exact(self):
   43:         assert_raises(TypeError, np.add, 1, 2, castingx='safe')
   44:         assert_raises(TypeError, np.add, 1, 2, dtypex=int)
   45:         assert_raises(TypeError, np.add, 1, 2, extobjx=[4096])
   46:         assert_raises(TypeError, np.add, 1, 2, outx=None)
   47:         assert_raises(TypeError, np.add, 1, 2, sigx='ii->i')
   48:         assert_raises(TypeError, np.add, 1, 2, signaturex='ii->i')
   49:         assert_raises(TypeError, np.add, 1, 2, subokx=False)
   50:         assert_raises(TypeError, np.add, 1, 2, wherex=[True])
   51: 
   52:     def test_sig_signature(self):
   53:         assert_raises(TypeError, np.add, 1, 2, sig='ii->i',
   54:                       signature='ii->i')
   55: 
   56:     def test_sig_dtype(self):
   57:         assert_raises(TypeError, np.add, 1, 2, sig='ii->i',
   58:                       dtype=int)
   59:         assert_raises(TypeError, np.add, 1, 2, signature='ii->i',
   60:                       dtype=int)
   61: 
   62:     def test_extobj_removed(self):
   63:         assert_raises(TypeError, np.add, 1, 2, extobj=[4096])
   64: 
   65: 
   66: class TestUfuncGenericLoops:
   67:     """Test generic loops.
   68: 
   69:     The loops to be tested are:
   70: 
   71:         PyUFunc_ff_f_As_dd_d
   72:         PyUFunc_ff_f
   73:         PyUFunc_dd_d
   74:         PyUFunc_gg_g
   75:         PyUFunc_FF_F_As_DD_D
   76:         PyUFunc_DD_D
   77:         PyUFunc_FF_F
   78:         PyUFunc_GG_G
   79:         PyUFunc_OO_O
   80:         PyUFunc_OO_O_method
   81:         PyUFunc_f_f_As_d_d
   82:         PyUFunc_d_d
   83:         PyUFunc_f_f
   84:         PyUFunc_g_g
   85:         PyUFunc_F_F_As_D_D
   86:         PyUFunc_F_F
   87:         PyUFunc_D_D
   88:         PyUFunc_G_G
   89:         PyUFunc_O_O
   90:         PyUFunc_O_O_method
   91:         PyUFunc_On_Om
   92: 
   93:     Where:
   94: 
   95:         f -- float
   96:         d -- double
   97:         g -- long double
   98:         F -- complex float
   99:         D -- complex double
  100:         G -- complex long double
  101:         O -- python object
  102: 
  103:     It is difficult to assure that each of these loops is entered from the
  104:     Python level as the special cased loops are a moving target and the
  105:     corresponding types are architecture dependent. We probably need to
  106:     define C level testing ufuncs to get at them. For the time being, I've
  107:     just looked at the signatures registered in the build directory to find
  108:     relevant functions.
  109: 
  110:     """
  111:     np_dtypes = [
  112:         (np.single, np.single), (np.single, np.double),
  113:         (np.csingle, np.csingle), (np.csingle, np.cdouble),
  114:         (np.double, np.double), (np.longdouble, np.longdouble),
  115:         (np.cdouble, np.cdouble), (np.clongdouble, np.clongdouble)]
  116: 
  117:     @pytest.mark.parametrize('input_dtype,output_dtype', np_dtypes)
  118:     def test_unary_PyUFunc(self, input_dtype, output_dtype, f=np.exp, x=0, y=1):
  119:         xs = np.full(10, input_dtype(x), dtype=output_dtype)
  120:         ys = f(xs)[::2]
  121:         assert_allclose(ys, y)
  122:         assert_equal(ys.dtype, output_dtype)
  123: 
  124:     def f2(x, y):
  125:         return x**y
  126: 
  127:     @pytest.mark.parametrize('input_dtype,output_dtype', np_dtypes)
  128:     def test_binary_PyUFunc(self, input_dtype, output_dtype, f=f2, x=0, y=1):
  129:         xs = np.full(10, input_dtype(x), dtype=output_dtype)
  130:         ys = f(xs, xs)[::2]
  131:         assert_allclose(ys, y)
  132:         assert_equal(ys.dtype, output_dtype)
  133: 
  134:     # class to use in testing object method loops
  135:     class foo:
  136:         def conjugate(self):
  137:             return np.bool(1)
  138: 
  139:         def logical_xor(self, obj):
  140:             return np.bool(1)
  141: 
  142:     def test_unary_PyUFunc_O_O(self):
  143:         x = np.ones(10, dtype=object)
  144:         assert_(np.all(np.abs(x) == 1))
  145: 
  146:     def test_unary_PyUFunc_O_O_method_simple(self, foo=foo):
  147:         x = np.full(10, foo(), dtype=object)
  148:         assert_(np.all(np.conjugate(x) == True))
  149: 
  150:     def test_binary_PyUFunc_OO_O(self):
  151:         x = np.ones(10, dtype=object)
  152:         assert_(np.all(np.add(x, x) == 2))
  153: 
  154:     def test_binary_PyUFunc_OO_O_method(self, foo=foo):
  155:         x = np.full(10, foo(), dtype=object)
  156:         assert_(np.all(np.logical_xor(x, x)))
  157: 
  158:     def test_binary_PyUFunc_On_Om_method(self, foo=foo):
  159:         x = np.full((10, 2, 3), foo(), dtype=object)
  160:         assert_(np.all(np.logical_xor(x, x)))
  161: 
  162:     def test_python_complex_conjugate(self):
  163:         # The conjugate ufunc should fall back to calling the method:
  164:         arr = np.array([1 + 2j, 3 - 4j], dtype="O")
  165:         assert isinstance(arr[0], complex)
  166:         res = np.conjugate(arr)
  167:         assert res.dtype == np.dtype("O")
  168:         assert_array_equal(res, np.array([1 - 2j, 3 + 4j], dtype="O"))
  169: 
  170:     @pytest.mark.parametrize("ufunc", UNARY_OBJECT_UFUNCS)
  171:     def test_unary_PyUFunc_O_O_method_full(self, ufunc):
  172:         """Compare the result of the object loop with non-object one"""
  173:         val = np.float64(np.pi / 4)
  174: 
  175:         class MyFloat(np.float64):
  176:             def __getattr__(self, attr):
  177:                 try:
  178:                     return super().__getattr__(attr)
  179:                 except AttributeError:
  180:                     return lambda: getattr(np._core.umath, attr)(val)
  181: 
  182:         # Use 0-D arrays, to ensure the same element call
  183:         num_arr = np.array(val, dtype=np.float64)
  184:         obj_arr = np.array(MyFloat(val), dtype="O")
  185: 
  186:         with np.errstate(all="raise"):
  187:             try:
  188:                 res_num = ufunc(num_arr)
  189:             except Exception as exc:
  190:                 with assert_raises(type(exc)):
  191:                     ufunc(obj_arr)
  192:             else:
  193:                 res_obj = ufunc(obj_arr)
  194:                 assert_array_almost_equal(res_num.astype("O"), res_obj)
  195: 
  196: 
  197: def _pickleable_module_global():
  198:     pass
  199: 
  200: 
  201: class TestUfunc:
  202:     def test_pickle(self):
  203:         for proto in range(2, pickle.HIGHEST_PROTOCOL + 1):
  204:             assert_(pickle.loads(pickle.dumps(np.sin,
  205:                                               protocol=proto)) is np.sin)
  206: 
  207:             # Check that ufunc not defined in the top level numpy namespace
  208:             # such as numpy._core._rational_tests.test_add can also be pickled
  209:             res = pickle.loads(pickle.dumps(_rational_tests.test_add,
  210:                                             protocol=proto))
  211:             assert_(res is _rational_tests.test_add)
  212: 
  213:     def test_pickle_withstring(self):
  214:         astring = (b"cnumpy.core\n_ufunc_reconstruct\np0\n"
  215:                    b"(S'numpy._core.umath'\np1\nS'cos'\np2\ntp3\nRp4\n.")
  216:         assert_(pickle.loads(astring) is np.cos)
  217: 
  218:     @pytest.mark.skipif(IS_PYPY, reason="'is' check does not work on PyPy")
  219:     def test_pickle_name_is_qualname(self):
  220:         # This tests that a simplification of our ufunc pickle code will
  221:         # lead to allowing qualnames as names.  Future ufuncs should
  222:         # possible add a specific qualname, or a hook into pickling instead
  223:         # (dask+numba may benefit).
  224:         _pickleable_module_global.ufunc = umt._pickleable_module_global_ufunc
  225: 
  226:         obj = pickle.loads(pickle.dumps(_pickleable_module_global.ufunc))
  227:         assert obj is umt._pickleable_module_global_ufunc
  228: 
  229:     def test_reduceat_shifting_sum(self):
  230:         L = 6
  231:         x = np.arange(L)
  232:         idx = np.array(list(zip(np.arange(L - 2), np.arange(L - 2) + 2))).ravel()
  233:         assert_array_equal(np.add.reduceat(x, idx)[::2], [1, 3, 5, 7])
  234: 
  235:     def test_all_ufunc(self):
  236:         """Try to check presence and results of all ufuncs.
  237: 
  238:         The list of ufuncs comes from generate_umath.py and is as follows:
  239: 
  240:         =====  ====  =============  ===============  ========================
  241:         done   args   function        types                notes
  242:         =====  ====  =============  ===============  ========================
  243:         n      1     conjugate      nums + O
  244:         n      1     absolute       nums + O         complex -> real
  245:         n      1     negative       nums + O
  246:         n      1     sign           nums + O         -> int
  247:         n      1     invert         bool + ints + O  flts raise an error
  248:         n      1     degrees        real + M         cmplx raise an error
  249:         n      1     radians        real + M         cmplx raise an error
  250:         n      1     arccos         flts + M
  251:         n      1     arccosh        flts + M
  252:         n      1     arcsin         flts + M
  253:         n      1     arcsinh        flts + M
  254:         n      1     arctan         flts + M
  255:         n      1     arctanh        flts + M
  256:         n      1     cos            flts + M
  257:         n      1     sin            flts + M
  258:         n      1     tan            flts + M
  259:         n      1     cosh           flts + M
  260:         n      1     sinh           flts + M
  261:         n      1     tanh           flts + M
  262:         n      1     exp            flts + M
  263:         n      1     expm1          flts + M
  264:         n      1     log            flts + M
  265:         n      1     log10          flts + M
  266:         n      1     log1p          flts + M
  267:         n      1     sqrt           flts + M         real x < 0 raises error
  268:         n      1     ceil           real + M
  269:         n      1     trunc          real + M
  270:         n      1     floor          real + M
  271:         n      1     fabs           real + M
  272:         n      1     rint           flts + M
  273:         n      1     isnan          flts             -> bool
  274:         n      1     isinf          flts             -> bool
  275:         n      1     isfinite       flts             -> bool
  276:         n      1     signbit        real             -> bool
  277:         n      1     modf           real             -> (frac, int)
  278:         n      1     logical_not    bool + nums + M  -> bool
  279:         n      2     left_shift     ints + O         flts raise an error
  280:         n      2     right_shift    ints + O         flts raise an error
  281:         n      2     add            bool + nums + O  boolean + is ||
  282:         n      2     subtract       bool + nums + O  boolean - is ^
  283:         n      2     multiply       bool + nums + O  boolean * is &
  284:         n      2     divide         nums + O
  285:         n      2     floor_divide   nums + O
  286:         n      2     true_divide    nums + O         bBhH -> f, iIlLqQ -> d
  287:         n      2     fmod           nums + M
  288:         n      2     power          nums + O
  289:         n      2     greater        bool + nums + O  -> bool
  290:         n      2     greater_equal  bool + nums + O  -> bool
  291:         n      2     less           bool + nums + O  -> bool
  292:         n      2     less_equal     bool + nums + O  -> bool
  293:         n      2     equal          bool + nums + O  -> bool
  294:         n      2     not_equal      bool + nums + O  -> bool
  295:         n      2     logical_and    bool + nums + M  -> bool
  296:         n      2     logical_or     bool + nums + M  -> bool
  297:         n      2     logical_xor    bool + nums + M  -> bool
  298:         n      2     maximum        bool + nums + O
  299:         n      2     minimum        bool + nums + O
  300:         n      2     bitwise_and    bool + ints + O  flts raise an error
  301:         n      2     bitwise_or     bool + ints + O  flts raise an error
  302:         n      2     bitwise_xor    bool + ints + O  flts raise an error
  303:         n      2     arctan2        real + M
  304:         n      2     remainder      ints + real + O
  305:         n      2     hypot          real + M
  306:         =====  ====  =============  ===============  ========================
  307: 
  308:         Types other than those listed will be accepted, but they are cast to
  309:         the smallest compatible type for which the function is defined. The
  310:         casting rules are:
  311: 
  312:         bool -> int8 -> float32
  313:         ints -> double
  314: 
  315:         """
  316:         pass
  317: 
  318:     # from include/numpy/ufuncobject.h
  319:     size_inferred = 2
  320:     can_ignore = 4
  321: 
  322:     def test_signature0(self):
  323:         # the arguments to test_signature are: nin, nout, core_signature
  324:         enabled, num_dims, ixs, flags, sizes = umt.test_signature(
  325:             2, 1, "(i),(i)->()")
  326:         assert_equal(enabled, 1)
  327:         assert_equal(num_dims, (1,  1,  0))
  328:         assert_equal(ixs, (0, 0))
  329:         assert_equal(flags, (self.size_inferred,))
  330:         assert_equal(sizes, (-1,))
  331: 
  332:     def test_signature1(self):
  333:         # empty core signature; treat as plain ufunc (with trivial core)
  334:         enabled, num_dims, ixs, flags, sizes = umt.test_signature(
  335:             2, 1, "(),()->()")
  336:         assert_equal(enabled, 0)
  337:         assert_equal(num_dims, (0,  0,  0))
  338:         assert_equal(ixs, ())
  339:         assert_equal(flags, ())
  340:         assert_equal(sizes, ())
  341: 
  342:     def test_signature2(self):
  343:         # more complicated names for variables
  344:         enabled, num_dims, ixs, flags, sizes = umt.test_signature(
  345:             2, 1, "(i1,i2),(J_1)->(_kAB)")
  346:         assert_equal(enabled, 1)
  347:         assert_equal(num_dims, (2, 1, 1))
  348:         assert_equal(ixs, (0, 1, 2, 3))
  349:         assert_equal(flags, (self.size_inferred,) * 4)
  350:         assert_equal(sizes, (-1, -1, -1, -1))
  351: 
  352:     def test_signature3(self):
  353:         enabled, num_dims, ixs, flags, sizes = umt.test_signature(
  354:             2, 1, "(i1, i12),   (J_1)->(i12, i2)")
  355:         assert_equal(enabled, 1)
  356:         assert_equal(num_dims, (2, 1, 2))
  357:         assert_equal(ixs, (0, 1, 2, 1, 3))
  358:         assert_equal(flags, (self.size_inferred,) * 4)
  359:         assert_equal(sizes, (-1, -1, -1, -1))
  360: 
  361:     def test_signature4(self):
  362:         # matrix_multiply signature from _umath_tests
  363:         enabled, num_dims, ixs, flags, sizes = umt.test_signature(
  364:             2, 1, "(n,k),(k,m)->(n,m)")
  365:         assert_equal(enabled, 1)
  366:         assert_equal(num_dims, (2, 2, 2))
  367:         assert_equal(ixs, (0, 1, 1, 2, 0, 2))
  368:         assert_equal(flags, (self.size_inferred,) * 3)
  369:         assert_equal(sizes, (-1, -1, -1))
  370: 
  371:     def test_signature5(self):
  372:         # matmul signature from _umath_tests
  373:         enabled, num_dims, ixs, flags, sizes = umt.test_signature(
  374:             2, 1, "(n?,k),(k,m?)->(n?,m?)")
  375:         assert_equal(enabled, 1)
  376:         assert_equal(num_dims, (2, 2, 2))
  377:         assert_equal(ixs, (0, 1, 1, 2, 0, 2))
  378:         assert_equal(flags, (self.size_inferred | self.can_ignore,
  379:                              self.size_inferred,
  380:                              self.size_inferred | self.can_ignore))
  381:         assert_equal(sizes, (-1, -1, -1))
  382: 
  383:     def test_signature6(self):
  384:         enabled, num_dims, ixs, flags, sizes = umt.test_signature(
  385:             1, 1, "(3)->()")
  386:         assert_equal(enabled, 1)
  387:         assert_equal(num_dims, (1, 0))
  388:         assert_equal(ixs, (0,))
  389:         assert_equal(flags, (0,))
  390:         assert_equal(sizes, (3,))
  391: 
  392:     def test_signature7(self):
  393:         enabled, num_dims, ixs, flags, sizes = umt.test_signature(
  394:             3, 1, "(3),(03,3),(n)->(9)")
  395:         assert_equal(enabled, 1)
  396:         assert_equal(num_dims, (1, 2, 1, 1))
  397:         assert_equal(ixs, (0, 0, 0, 1, 2))
  398:         assert_equal(flags, (0, self.size_inferred, 0))
  399:         assert_equal(sizes, (3, -1, 9))
  400: 
  401:     def test_signature8(self):
  402:         enabled, num_dims, ixs, flags, sizes = umt.test_signature(
  403:             3, 1, "(3?),(3?,3?),(n)->(9)")
  404:         assert_equal(enabled, 1)
  405:         assert_equal(num_dims, (1, 2, 1, 1))
  406:         assert_equal(ixs, (0, 0, 0, 1, 2))
  407:         assert_equal(flags, (self.can_ignore, self.size_inferred, 0))
  408:         assert_equal(sizes, (3, -1, 9))
  409: 
  410:     def test_signature9(self):
  411:         enabled, num_dims, ixs, flags, sizes = umt.test_signature(
  412:             1, 1, "(  3)  -> ( )")
  413:         assert_equal(enabled, 1)
  414:         assert_equal(num_dims, (1, 0))
  415:         assert_equal(ixs, (0,))
  416:         assert_equal(flags, (0,))
  417:         assert_equal(sizes, (3,))
  418: 
  419:     def test_signature10(self):
  420:         enabled, num_dims, ixs, flags, sizes = umt.test_signature(
  421:             3, 1, "( 3? ) , (3? ,  3?) ,(n )-> ( 9)")
  422:         assert_equal(enabled, 1)
  423:         assert_equal(num_dims, (1, 2, 1, 1))
  424:         assert_equal(ixs, (0, 0, 0, 1, 2))
  425:         assert_equal(flags, (self.can_ignore, self.size_inferred, 0))
  426:         assert_equal(sizes, (3, -1, 9))
  427: 
  428:     def test_signature_failure_extra_parenthesis(self):
  429:         with assert_raises(ValueError):
  430:             umt.test_signature(2, 1, "((i)),(i)->()")
  431: 
  432:     def test_signature_failure_mismatching_parenthesis(self):
  433:         with assert_raises(ValueError):
  434:             umt.test_signature(2, 1, "(i),)i(->()")
  435: 
  436:     def test_signature_failure_signature_missing_input_arg(self):
  437:         with assert_raises(ValueError):
  438:             umt.test_signature(2, 1, "(i),->()")
  439: 
  440:     def test_signature_failure_signature_missing_output_arg(self):
  441:         with assert_raises(ValueError):
  442:             umt.test_signature(2, 2, "(i),(i)->()")
  443: 
  444:     def test_get_signature(self):
  445:         assert_equal(np.vecdot.signature, "(n),(n)->()")
  446: 
  447:     def test_forced_sig(self):
  448:         a = 0.5 * np.arange(3, dtype='f8')
  449:         assert_equal(np.add(a, 0.5), [0.5, 1, 1.5])
  450:         with assert_raises(TypeError):
  451:             np.add(a, 0.5, sig='i', casting='unsafe')
  452:         assert_equal(np.add(a, 0.5, sig='ii->i', casting='unsafe'), [0, 0, 1])
  453:         with assert_raises(TypeError):
  454:             np.add(a, 0.5, sig=('i4',), casting='unsafe')
  455:         assert_equal(np.add(a, 0.5, sig=('i4', 'i4', 'i4'),
  456:                                             casting='unsafe'), [0, 0, 1])
  457: 
  458:         b = np.zeros((3,), dtype='f8')
  459:         np.add(a, 0.5, out=b)
  460:         assert_equal(b, [0.5, 1, 1.5])
  461:         b[:] = 0
  462:         with assert_raises(TypeError):
  463:             np.add(a, 0.5, sig='i', out=b, casting='unsafe')
  464:         assert_equal(b, [0, 0, 0])
  465:         np.add(a, 0.5, sig='ii->i', out=b, casting='unsafe')
  466:         assert_equal(b, [0, 0, 1])
  467:         b[:] = 0
  468:         with assert_raises(TypeError):
  469:             np.add(a, 0.5, sig=('i4',), out=b, casting='unsafe')
  470:         assert_equal(b, [0, 0, 0])
  471:         np.add(a, 0.5, sig=('i4', 'i4', 'i4'), out=b, casting='unsafe')
  472:         assert_equal(b, [0, 0, 1])
  473: 
  474:     def test_signature_all_None(self):
  475:         # signature all None, is an acceptable alternative (since 1.21)
  476:         # to not providing a signature.
  477:         res1 = np.add([3], [4], sig=(None, None, None))
  478:         res2 = np.add([3], [4])
  479:         assert_array_equal(res1, res2)
  480:         res1 = np.maximum([3], [4], sig=(None, None, None))
  481:         res2 = np.maximum([3], [4])
  482:         assert_array_equal(res1, res2)
  483: 
  484:         with pytest.raises(TypeError):
  485:             # special case, that would be deprecated anyway, so errors:
  486:             np.add(3, 4, signature=(None,))
  487: 
  488:     def test_signature_dtype_type(self):
  489:         # Since that will be the normal behaviour (past NumPy 1.21)
  490:         # we do support the types already:
  491:         float_dtype = type(np.dtype(np.float64))
  492:         np.add(3, 4, signature=(float_dtype, float_dtype, None))
  493: 
  494:     @pytest.mark.parametrize("get_kwarg", [
  495:             param(lambda dt: {"dtype": dt}, id="dtype"),
  496:             param(lambda dt: {"signature": (dt, None, None)}, id="signature")])
  497:     def test_signature_dtype_instances_allowed(self, get_kwarg):
  498:         # We allow certain dtype instances when there is a clear singleton
  499:         # and the given one is equivalent; mainly for backcompat.
  500:         int64 = np.dtype("int64")
  501:         int64_2 = pickle.loads(pickle.dumps(int64))
  502:         # Relies on pickling behavior, if assert fails just remove test...
  503:         assert int64 is not int64_2
  504: 
  505:         assert np.add(1, 2, **get_kwarg(int64_2)).dtype == int64
  506:         td = np.timedelta64(2, "s")
  507:         assert np.add(td, td, **get_kwarg("m8")).dtype == "m8[s]"
  508: 
  509:         msg = "The `dtype` and `signature` arguments to ufuncs"
  510: 
  511:         with pytest.raises(TypeError, match=msg):
  512:             np.add(3, 5, **get_kwarg(np.dtype("int64").newbyteorder()))
  513:         with pytest.raises(TypeError, match=msg):
  514:             np.add(3, 5, **get_kwarg(np.dtype("m8[ns]")))
  515:         with pytest.raises(TypeError, match=msg):
  516:             np.add(3, 5, **get_kwarg("m8[ns]"))
  517: 
  518:     @pytest.mark.parametrize("casting", ["unsafe", "same_kind", "safe"])
  519:     def test_partial_signature_mismatch(self, casting):
  520:         # If the second argument matches already, no need to specify it:
  521:         res = np.ldexp(np.float32(1.), np.int_(2), dtype="d")
  522:         assert res.dtype == "d"
  523:         res = np.ldexp(np.float32(1.), np.int_(2), signature=(None, None, "d"))
  524:         assert res.dtype == "d"
  525: 
  526:         # ldexp only has a loop for long input as second argument, overriding
  527:         # the output cannot help with that (no matter the casting)
  528:         with pytest.raises(TypeError):
  529:             np.ldexp(1., np.uint64(3), dtype="d")
  530:         with pytest.raises(TypeError):
  531:             np.ldexp(1., np.uint64(3), signature=(None, None, "d"))
  532: 
  533:     def test_partial_signature_mismatch_with_cache(self):
  534:         with pytest.raises(TypeError):
  535:             np.add(np.float16(1), np.uint64(2), sig=("e", "d", None))
  536:         # Ensure e,d->None is in the dispatching cache (double loop)
  537:         np.add(np.float16(1), np.float64(2))
  538:         # The error must still be raised:
  539:         with pytest.raises(TypeError):
  540:             np.add(np.float16(1), np.uint64(2), sig=("e", "d", None))
  541: 
  542:     def test_use_output_signature_for_all_arguments(self):
  543:         # Test that providing only `dtype=` or `signature=(None, None, dtype)`
  544:         # is sufficient if falling back to a homogeneous signature works.
  545:         # In this case, the `intp, intp -> intp` loop is chosen.
  546:         res = np.power(1.5, 2.8, dtype=np.intp, casting="unsafe")
  547:         assert res == 1  # the cast happens first.
  548:         res = np.power(1.5, 2.8, signature=(None, None, np.intp),
  549:                        casting="unsafe")
  550:         assert res == 1
  551:         with pytest.raises(TypeError):
  552:             # the unsafe casting would normally cause errors though:
  553:             np.power(1.5, 2.8, dtype=np.intp)
  554: 
  555:     def test_signature_errors(self):
  556:         with pytest.raises(TypeError,
  557:                     match="the signature object to ufunc must be a string or"):
  558:             np.add(3, 4, signature=123.)  # neither a string nor a tuple
  559: 
  560:         with pytest.raises(ValueError):
  561:             # bad symbols that do not translate to dtypes
  562:             np.add(3, 4, signature="%^->#")
  563: 
  564:         with pytest.raises(ValueError):
  565:             np.add(3, 4, signature=b"ii-i")  # incomplete and byte string
  566: 
  567:         with pytest.raises(ValueError):
  568:             np.add(3, 4, signature="ii>i")  # incomplete string
  569: 
  570:         with pytest.raises(ValueError):
  571:             np.add(3, 4, signature=(None, "f8"))  # bad length
  572: 
  573:         with pytest.raises(UnicodeDecodeError):
  574:             np.add(3, 4, signature=b"\xff\xff->i")
  575: 
  576:     def test_forced_dtype_times(self):
  577:         # Signatures only set the type numbers (not the actual loop dtypes)
  578:         # so using `M` in a signature/dtype should generally work:
  579:         a = np.array(['2010-01-02', '1999-03-14', '1833-03'], dtype='>M8[D]')
  580:         np.maximum(a, a, dtype="M")
  581:         np.maximum.reduce(a, dtype="M")
  582: 
  583:         arr = np.arange(10, dtype="m8[s]")
  584:         np.add(arr, arr, dtype="m")
  585:         np.maximum(arr, arr, dtype="m")
  586: 
  587:     @pytest.mark.parametrize("ufunc", [np.add, np.sqrt])
  588:     def test_cast_safety(self, ufunc):
  589:         """Basic test for the safest casts, because ufuncs inner loops can
  590:         indicate a cast-safety as well (which is normally always "no").
  591:         """
  592:         def call_ufunc(arr, **kwargs):
  593:             return ufunc(*(arr,) * ufunc.nin, **kwargs)
  594: 
  595:         arr = np.array([1., 2., 3.], dtype=np.float32)
  596:         arr_bs = arr.astype(arr.dtype.newbyteorder())
  597:         expected = call_ufunc(arr)
  598:         # Normally, a "no" cast:
  599:         res = call_ufunc(arr, casting="no")
  600:         assert_array_equal(expected, res)
  601:         # Byte-swapping is not allowed with "no" though:
  602:         with pytest.raises(TypeError):
  603:             call_ufunc(arr_bs, casting="no")
  604: 
  605:         # But is allowed with "equiv":
  606:         res = call_ufunc(arr_bs, casting="equiv")
  607:         assert_array_equal(expected, res)
  608: 
  609:         # Casting to float64 is safe, but not equiv:
  610:         with pytest.raises(TypeError):
  611:             call_ufunc(arr_bs, dtype=np.float64, casting="equiv")
  612: 
  613:         # but it is safe cast:
  614:         res = call_ufunc(arr_bs, dtype=np.float64, casting="safe")
  615:         expected = call_ufunc(arr.astype(np.float64))  # upcast
  616:         assert_array_equal(expected, res)
  617: 
  618:     @pytest.mark.parametrize("ufunc", [np.add, np.equal])
  619:     def test_cast_safety_scalar(self, ufunc):
  620:         # We test add and equal, because equal has special scalar handling
  621:         # Note that the "equiv" casting behavior should maybe be considered
  622:         # a current implementation detail.
  623:         with pytest.raises(TypeError):
  624:             # this picks an integer loop, which is not safe
  625:             ufunc(3., 4., dtype=int, casting="safe")
  626: 
  627:         with pytest.raises(TypeError):
  628:             # We accept python float as float64 but not float32 for equiv.
  629:             ufunc(3., 4., dtype="float32", casting="equiv")
  630: 
  631:         # Special case for object and equal (note that equiv implies safe)
  632:         ufunc(3, 4, dtype=object, casting="equiv")
  633:         # Picks a double loop for both, first is equiv, second safe:
  634:         ufunc(np.array([3.]), 3., casting="equiv")
  635:         ufunc(np.array([3.]), 3, casting="safe")
  636:         ufunc(np.array([3]), 3, casting="equiv")
  637: 
  638:     def test_cast_safety_scalar_special(self):
  639:         # We allow this (and it succeeds) via object, although the equiv
  640:         # part may not be important.
  641:         np.equal(np.array([3]), 2**300, casting="equiv")
  642: 
  643:     def test_true_divide(self):
  644:         a = np.array(10)
  645:         b = np.array(20)
  646:         tgt = np.array(0.5)
  647: 
  648:         for tc in 'bhilqBHILQefdgFDG':
  649:             dt = np.dtype(tc)
  650:             aa = a.astype(dt)
  651:             bb = b.astype(dt)
  652: 
  653:             # Check result value and dtype.
  654:             for x, y in itertools.product([aa, -aa], [bb, -bb]):
  655: 
  656:                 # Check with no output type specified
  657:                 if tc in 'FDG':
  658:                     tgt = complex(x) / complex(y)
  659:                 else:
  660:                     tgt = float(x) / float(y)
  661: 
  662:                 res = np.true_divide(x, y)
  663:                 rtol = max(np.finfo(res).resolution, 1e-15)
  664:                 assert_allclose(res, tgt, rtol=rtol)
  665: 
  666:                 if tc in 'bhilqBHILQ':
  667:                     assert_(res.dtype.name == 'float64')
  668:                 else:
  669:                     assert_(res.dtype.name == dt.name)
  670: 
  671:                 # Check with output type specified.  This also checks for the
  672:                 # incorrect casts in issue gh-3484 because the unary '-' does
  673:                 # not change types, even for unsigned types, Hence casts in the
  674:                 # ufunc from signed to unsigned and vice versa will lead to
  675:                 # errors in the values.
  676:                 for tcout in 'bhilqBHILQ':
  677:                     dtout = np.dtype(tcout)
  678:                     assert_raises(TypeError, np.true_divide, x, y, dtype=dtout)
  679: 
  680:                 for tcout in 'efdg':
  681:                     dtout = np.dtype(tcout)
  682:                     if tc in 'FDG':
  683:                         # Casting complex to float is not allowed
  684:                         assert_raises(TypeError, np.true_divide, x, y, dtype=dtout)
  685:                     else:
  686:                         tgt = float(x) / float(y)
  687:                         rtol = max(np.finfo(dtout).resolution, 1e-15)
  688:                         # The value of tiny for double double is NaN
  689:                         with suppress_warnings() as sup:
  690:                             sup.filter(UserWarning)
  691:                             if not np.isnan(np.finfo(dtout).tiny):
  692:                                 atol = max(np.finfo(dtout).tiny, 3e-308)
  693:                             else:
  694:                                 atol = 3e-308
  695:                         # Some test values result in invalid for float16
  696:                         # and the cast to it may overflow to inf.
  697:                         with np.errstate(invalid='ignore', over='ignore'):
  698:                             res = np.true_divide(x, y, dtype=dtout)
  699:                         if not np.isfinite(res) and tcout == 'e':
  700:                             continue
  701:                         assert_allclose(res, tgt, rtol=rtol, atol=atol)
  702:                         assert_(res.dtype.name == dtout.name)
  703: 
  704:                 for tcout in 'FDG':
  705:                     dtout = np.dtype(tcout)
  706:                     tgt = complex(x) / complex(y)
  707:                     rtol = max(np.finfo(dtout).resolution, 1e-15)
  708:                     # The value of tiny for double double is NaN
  709:                     with suppress_warnings() as sup:
  710:                         sup.filter(UserWarning)
  711:                         if not np.isnan(np.finfo(dtout).tiny):
  712:                             atol = max(np.finfo(dtout).tiny, 3e-308)
  713:                         else:
  714:                             atol = 3e-308
  715:                     res = np.true_divide(x, y, dtype=dtout)
  716:                     if not np.isfinite(res):
  717:                         continue
  718:                     assert_allclose(res, tgt, rtol=rtol, atol=atol)
  719:                     assert_(res.dtype.name == dtout.name)
  720: 
  721:         # Check booleans
  722:         a = np.ones((), dtype=np.bool)
  723:         res = np.true_divide(a, a)
  724:         assert_(res == 1.0)
  725:         assert_(res.dtype.name == 'float64')
  726:         res = np.true_divide(~a, a)
  727:         assert_(res == 0.0)
  728:         assert_(res.dtype.name == 'float64')
  729: 
  730:     def test_sum_stability(self):
  731:         a = np.ones(500, dtype=np.float32)
  732:         assert_almost_equal((a / 10.).sum() - a.size / 10., 0, 4)
  733: 
  734:         a = np.ones(500, dtype=np.float64)
  735:         assert_almost_equal((a / 10.).sum() - a.size / 10., 0, 13)
  736: 
  737:     @pytest.mark.skipif(IS_WASM, reason="fp errors don't work in wasm")
  738:     def test_sum(self):
  739:         for dt in (int, np.float16, np.float32, np.float64, np.longdouble):
  740:             for v in (0, 1, 2, 7, 8, 9, 15, 16, 19, 127,
  741:                       128, 1024, 1235):
  742:                 # warning if sum overflows, which it does in float16
  743:                 with warnings.catch_warnings(record=True) as w:
  744:                     warnings.simplefilter("always", RuntimeWarning)
  745: 
  746:                     tgt = dt(v * (v + 1) / 2)
  747:                     overflow = not np.isfinite(tgt)
  748:                     assert_equal(len(w), 1 * overflow)
  749: 
  750:                     d = np.arange(1, v + 1, dtype=dt)
  751: 
  752:                     assert_almost_equal(np.sum(d), tgt)
  753:                     assert_equal(len(w), 2 * overflow)
  754: 
  755:                     assert_almost_equal(np.sum(d[::-1]), tgt)
  756:                     assert_equal(len(w), 3 * overflow)
  757: 
  758:             d = np.ones(500, dtype=dt)
  759:             assert_almost_equal(np.sum(d[::2]), 250.)
  760:             assert_almost_equal(np.sum(d[1::2]), 250.)
  761:             assert_almost_equal(np.sum(d[::3]), 167.)
  762:             assert_almost_equal(np.sum(d[1::3]), 167.)
  763:             assert_almost_equal(np.sum(d[::-2]), 250.)
  764:             assert_almost_equal(np.sum(d[-1::-2]), 250.)
  765:             assert_almost_equal(np.sum(d[::-3]), 167.)
  766:             assert_almost_equal(np.sum(d[-1::-3]), 167.)
  767:             # sum with first reduction entry != 0
  768:             d = np.ones((1,), dtype=dt)
  769:             d += d
  770:             assert_almost_equal(d, 2.)
  771: 
  772:     def test_sum_complex(self):
  773:         for dt in (np.complex64, np.complex128, np.clongdouble):
  774:             for v in (0, 1, 2, 7, 8, 9, 15, 16, 19, 127,
  775:                       128, 1024, 1235):
  776:                 tgt = dt(v * (v + 1) / 2) - dt((v * (v + 1) / 2) * 1j)
  777:                 d = np.empty(v, dtype=dt)
  778:                 d.real = np.arange(1, v + 1)
  779:                 d.imag = -np.arange(1, v + 1)
  780:                 assert_almost_equal(np.sum(d), tgt)
  781:                 assert_almost_equal(np.sum(d[::-1]), tgt)
  782: 
  783:             d = np.ones(500, dtype=dt) + 1j
  784:             assert_almost_equal(np.sum(d[::2]), 250. + 250j)
  785:             assert_almost_equal(np.sum(d[1::2]), 250. + 250j)
  786:             assert_almost_equal(np.sum(d[::3]), 167. + 167j)
  787:             assert_almost_equal(np.sum(d[1::3]), 167. + 167j)
  788:             assert_almost_equal(np.sum(d[::-2]), 250. + 250j)
  789:             assert_almost_equal(np.sum(d[-1::-2]), 250. + 250j)
  790:             assert_almost_equal(np.sum(d[::-3]), 167. + 167j)
  791:             assert_almost_equal(np.sum(d[-1::-3]), 167. + 167j)
  792:             # sum with first reduction entry != 0
  793:             d = np.ones((1,), dtype=dt) + 1j
  794:             d += d
  795:             assert_almost_equal(d, 2. + 2j)
  796: 
  797:     def test_sum_initial(self):
  798:         # Integer, single axis
  799:         assert_equal(np.sum([3], initial=2), 5)
  800: 
  801:         # Floating point
  802:         assert_almost_equal(np.sum([0.2], initial=0.1), 0.3)
  803: 
  804:         # Multiple non-adjacent axes
  805:         assert_equal(np.sum(np.ones((2, 3, 5), dtype=np.int64), axis=(0, 2), initial=2),
  806:                      [12, 12, 12])
  807: 
  808:     def test_sum_where(self):
  809:         # More extensive tests done in test_reduction_with_where.
  810:         assert_equal(np.sum([[1., 2.], [3., 4.]], where=[True, False]), 4.)
  811:         assert_equal(np.sum([[1., 2.], [3., 4.]], axis=0, initial=5.,
  812:                             where=[True, False]), [9., 5.])
  813: 
  814:     def test_vecdot(self):
  815:         arr1 = np.arange(6).reshape((2, 3))
  816:         arr2 = np.arange(3).reshape((1, 3))
  817: 
  818:         actual = np.vecdot(arr1, arr2)
  819:         expected = np.array([5, 14])
  820: 
  821:         assert_array_equal(actual, expected)
  822: 
  823:         actual2 = np.vecdot(arr1.T, arr2.T, axis=-2)
  824:         assert_array_equal(actual2, expected)
  825: 
  826:         actual3 = np.vecdot(arr1.astype("object"), arr2)
  827:         assert_array_equal(actual3, expected.astype("object"))
  828: 
  829:     def test_matvec(self):
  830:         arr1 = np.arange(6).reshape((2, 3))
  831:         arr2 = np.arange(3).reshape((1, 3))
  832: 
  833:         actual = np.matvec(arr1, arr2)
  834:         expected = np.array([[5, 14]])
  835: 
  836:         assert_array_equal(actual, expected)
  837: 
  838:         actual2 = np.matvec(arr1.T, arr2.T, axes=[(-1, -2), -2, -1])
  839:         assert_array_equal(actual2, expected)
  840: 
  841:         actual3 = np.matvec(arr1.astype("object"), arr2)
  842:         assert_array_equal(actual3, expected.astype("object"))
  843: 
  844:     @pytest.mark.parametrize("vec", [
  845:         np.array([[1., 2., 3.], [4., 5., 6.]]),
  846:         np.array([[1., 2j, 3.], [4., 5., 6j]]),
  847:         np.array([[1., 2., 3.], [4., 5., 6.]], dtype=object),
  848:         np.array([[1., 2j, 3.], [4., 5., 6j]], dtype=object)])
  849:     @pytest.mark.parametrize("matrix", [
  850:         None,
  851:         np.array([[1. + 1j, 0.5, -0.5j],
  852:                   [0.25, 2j, 0.],
  853:                   [4., 0., -1j]])])
  854:     def test_vecmatvec_identity(self, matrix, vec):
  855:         """Check that (xвЂ A)x equals xвЂ (Ax)."""
  856:         mat = matrix if matrix is not None else np.eye(3)
  857:         matvec = np.matvec(mat, vec)  # Ax
  858:         vecmat = np.vecmat(vec, mat)  # xвЂ A
  859:         if matrix is None:
  860:             assert_array_equal(matvec, vec)
  861:             assert_array_equal(vecmat.conj(), vec)
  862:         assert_array_equal(matvec, (mat @ vec[..., np.newaxis]).squeeze(-1))
  863:         assert_array_equal(vecmat, (vec[..., np.newaxis].mT.conj()
  864:                                     @ mat).squeeze(-2))
  865:         expected = np.einsum('...i,ij,...j', vec.conj(), mat, vec)
  866:         vec_matvec = (vec.conj() * matvec).sum(-1)
  867:         vecmat_vec = (vecmat * vec).sum(-1)
  868:         assert_array_equal(vec_matvec, expected)
  869:         assert_array_equal(vecmat_vec, expected)
  870: 
  871:     @pytest.mark.parametrize("ufunc, shape1, shape2, conj", [
  872:         (np.vecdot, (3,), (3,), True),
  873:         (np.vecmat, (3,), (3, 1), True),
  874:         (np.matvec, (1, 3), (3,), False),
  875:         (np.matmul, (1, 3), (3, 1), False),
  876:     ])
  877:     def test_vecdot_matvec_vecmat_complex(self, ufunc, shape1, shape2, conj):
  878:         arr1 = np.array([1, 2j, 3])
  879:         arr2 = np.array([1, 2, 3])
  880: 
  881:         actual1 = ufunc(arr1.reshape(shape1), arr2.reshape(shape2))
  882:         expected1 = np.array(((arr1.conj() if conj else arr1) * arr2).sum(),
  883:                              ndmin=min(len(shape1), len(shape2)))
  884:         assert_array_equal(actual1, expected1)
  885:         # This would fail for conj=True, since matmul omits the conjugate.
  886:         if not conj:
  887:             assert_array_equal(arr1.reshape(shape1) @ arr2.reshape(shape2),
  888:                                expected1)
  889: 
  890:         actual2 = ufunc(arr2.reshape(shape1), arr1.reshape(shape2))
  891:         expected2 = np.array(((arr2.conj() if conj else arr2) * arr1).sum(),
  892:                              ndmin=min(len(shape1), len(shape2)))
  893:         assert_array_equal(actual2, expected2)
  894: 
  895:         actual3 = ufunc(arr1.reshape(shape1).astype("object"),
  896:                         arr2.reshape(shape2).astype("object"))
  897:         expected3 = expected1.astype(object)
  898:         assert_array_equal(actual3, expected3)
  899: 
  900:     def test_vecdot_subclass(self):
  901:         class MySubclass(np.ndarray):
  902:             pass
  903: 
  904:         arr1 = np.arange(6).reshape((2, 3)).view(MySubclass)
  905:         arr2 = np.arange(3).reshape((1, 3)).view(MySubclass)
  906:         result = np.vecdot(arr1, arr2)
  907:         assert isinstance(result, MySubclass)
  908: 
  909:     def test_vecdot_object_no_conjugate(self):
  910:         arr = np.array(["1", "2"], dtype=object)
  911:         with pytest.raises(AttributeError, match="conjugate"):
  912:             np.vecdot(arr, arr)
  913: 
  914:     def test_vecdot_object_breaks_outer_loop_on_error(self):
  915:         arr1 = np.ones((3, 3)).astype(object)
  916:         arr2 = arr1.copy()
  917:         arr2[1, 1] = None
  918:         out = np.zeros(3).astype(object)
  919:         with pytest.raises(TypeError, match=r"\*: 'float' and 'NoneType'"):
  920:             np.vecdot(arr1, arr2, out=out)
  921:         assert out[0] == 3
  922:         assert out[1] == out[2] == 0
  923: 
  924:     def test_broadcast(self):
  925:         msg = "broadcast"
  926:         a = np.arange(4).reshape((2, 1, 2))
  927:         b = np.arange(4).reshape((1, 2, 2))
  928:         assert_array_equal(np.vecdot(a, b), np.sum(a * b, axis=-1), err_msg=msg)
  929:         msg = "extend & broadcast loop dimensions"
  930:         b = np.arange(4).reshape((2, 2))
  931:         assert_array_equal(np.vecdot(a, b), np.sum(a * b, axis=-1), err_msg=msg)
  932:         # Broadcast in core dimensions should fail
  933:         a = np.arange(8).reshape((4, 2))
  934:         b = np.arange(4).reshape((4, 1))
  935:         assert_raises(ValueError, np.vecdot, a, b)
  936:         # Extend core dimensions should fail
  937:         a = np.arange(8).reshape((4, 2))
  938:         b = np.array(7)
  939:         assert_raises(ValueError, np.vecdot, a, b)
  940:         # Broadcast should fail
  941:         a = np.arange(2).reshape((2, 1, 1))
  942:         b = np.arange(3).reshape((3, 1, 1))
  943:         assert_raises(ValueError, np.vecdot, a, b)
  944: 
  945:         # Writing to a broadcasted array with overlap should warn, gh-2705
  946:         a = np.arange(2)
  947:         b = np.arange(4).reshape((2, 2))
  948:         u, v = np.broadcast_arrays(a, b)
  949:         assert_equal(u.strides[0], 0)
  950:         x = u + v
  951:         with warnings.catch_warnings(record=True) as w:
  952:             warnings.simplefilter("always")
  953:             u += v
  954:             assert_equal(len(w), 1)
  955:             assert_(x[0, 0] != u[0, 0])
  956: 
  957:         # Output reduction should not be allowed.
  958:         # See gh-15139
  959:         a = np.arange(6).reshape(3, 2)
  960:         b = np.ones(2)
  961:         out = np.empty(())
  962:         assert_raises(ValueError, np.vecdot, a, b, out)
  963:         out2 = np.empty(3)
  964:         c = np.vecdot(a, b, out2)
  965:         assert_(c is out2)
  966: 
  967:     def test_out_broadcasts(self):
  968:         # For ufuncs and gufuncs (not for reductions), we currently allow
  969:         # the output to cause broadcasting of the input arrays.
  970:         # both along dimensions with shape 1 and dimensions which do not
  971:         # exist at all in the inputs.
  972:         arr = np.arange(3).reshape(1, 3)
  973:         out = np.empty((5, 4, 3))
  974:         np.add(arr, arr, out=out)
  975:         assert (out == np.arange(3) * 2).all()
  976: 
  977:         # The same holds for gufuncs (gh-16484)
  978:         np.vecdot(arr, arr, out=out)
  979:         # the result would be just a scalar `5`, but is broadcast fully:
  980:         assert (out == 5).all()
  981: 
  982:     @pytest.mark.parametrize(["arr", "out"], [
  983:                 ([2], np.empty(())),
  984:                 ([1, 2], np.empty(1)),
  985:                 (np.ones((4, 3)), np.empty((4, 1)))],
  986:             ids=["(1,)->()", "(2,)->(1,)", "(4, 3)->(4, 1)"])
  987:     def test_out_broadcast_errors(self, arr, out):
  988:         # Output is (currently) allowed to broadcast inputs, but it cannot be
  989:         # smaller than the actual result.
  990:         with pytest.raises(ValueError, match="non-broadcastable"):
  991:             np.positive(arr, out=out)
  992: 
  993:         with pytest.raises(ValueError, match="non-broadcastable"):
  994:             np.add(np.ones(()), arr, out=out)
  995: 
  996:     def test_type_cast(self):
  997:         msg = "type cast"
  998:         a = np.arange(6, dtype='short').reshape((2, 3))
  999:         assert_array_equal(np.vecdot(a, a), np.sum(a * a, axis=-1),
 1000:                            err_msg=msg)
 1001:         msg = "type cast on one argument"
 1002:         a = np.arange(6).reshape((2, 3))
 1003:         b = a + 0.1
 1004:         assert_array_almost_equal(np.vecdot(a, b), np.sum(a * b, axis=-1),
 1005:                                   err_msg=msg)
 1006: 
 1007:     def test_endian(self):
 1008:         msg = "big endian"
 1009:         a = np.arange(6, dtype='>i4').reshape((2, 3))
 1010:         assert_array_equal(np.vecdot(a, a), np.sum(a * a, axis=-1),
 1011:                            err_msg=msg)
 1012:         msg = "little endian"
 1013:         a = np.arange(6, dtype='<i4').reshape((2, 3))
 1014:         assert_array_equal(np.vecdot(a, a), np.sum(a * a, axis=-1),
 1015:                            err_msg=msg)
 1016: 
 1017:         # Output should always be native-endian
 1018:         Ba = np.arange(1, dtype='>f8')
 1019:         La = np.arange(1, dtype='<f8')
 1020:         assert_equal((Ba + Ba).dtype, np.dtype('f8'))
 1021:         assert_equal((Ba + La).dtype, np.dtype('f8'))
 1022:         assert_equal((La + Ba).dtype, np.dtype('f8'))
 1023:         assert_equal((La + La).dtype, np.dtype('f8'))
 1024: 
 1025:         assert_equal(np.absolute(La).dtype, np.dtype('f8'))
 1026:         assert_equal(np.absolute(Ba).dtype, np.dtype('f8'))
 1027:         assert_equal(np.negative(La).dtype, np.dtype('f8'))
 1028:         assert_equal(np.negative(Ba).dtype, np.dtype('f8'))
 1029: 
 1030:     def test_incontiguous_array(self):
 1031:         msg = "incontiguous memory layout of array"
 1032:         x = np.arange(64).reshape((2, 2, 2, 2, 2, 2))
 1033:         a = x[:, 0, :, 0, :, 0]
 1034:         b = x[:, 1, :, 1, :, 1]
 1035:         a[0, 0, 0] = -1
 1036:         msg2 = "make sure it references to the original array"
 1037:         assert_equal(x[0, 0, 0, 0, 0, 0], -1, err_msg=msg2)
 1038:         assert_array_equal(np.vecdot(a, b), np.sum(a * b, axis=-1), err_msg=msg)
 1039:         x = np.arange(24).reshape(2, 3, 4)
 1040:         a = x.T
 1041:         b = x.T
 1042:         a[0, 0, 0] = -1
 1043:         assert_equal(x[0, 0, 0], -1, err_msg=msg2)
 1044:         assert_array_equal(np.vecdot(a, b), np.sum(a * b, axis=-1), err_msg=msg)
 1045: 
 1046:     def test_output_argument(self):
 1047:         msg = "output argument"
 1048:         a = np.arange(12).reshape((2, 3, 2))
 1049:         b = np.arange(4).reshape((2, 1, 2)) + 1
 1050:         c = np.zeros((2, 3), dtype='int')
 1051:         np.vecdot(a, b, c)
 1052:         assert_array_equal(c, np.sum(a * b, axis=-1), err_msg=msg)
 1053:         c[:] = -1
 1054:         np.vecdot(a, b, out=c)
 1055:         assert_array_equal(c, np.sum(a * b, axis=-1), err_msg=msg)
 1056: 
 1057:         msg = "output argument with type cast"
 1058:         c = np.zeros((2, 3), dtype='int16')
 1059:         np.vecdot(a, b, c)
 1060:         assert_array_equal(c, np.sum(a * b, axis=-1), err_msg=msg)
 1061:         c[:] = -1
 1062:         np.vecdot(a, b, out=c)
 1063:         assert_array_equal(c, np.sum(a * b, axis=-1), err_msg=msg)
 1064: 
 1065:         msg = "output argument with incontiguous layout"
 1066:         c = np.zeros((2, 3, 4), dtype='int16')
 1067:         np.vecdot(a, b, c[..., 0])
 1068:         assert_array_equal(c[..., 0], np.sum(a * b, axis=-1), err_msg=msg)
 1069:         c[:] = -1
 1070:         np.vecdot(a, b, out=c[..., 0])
 1071:         assert_array_equal(c[..., 0], np.sum(a * b, axis=-1), err_msg=msg)
 1072: 
 1073:     @pytest.mark.parametrize("arg", ["array", "scalar", "subclass"])
 1074:     def test_output_ellipsis(self, arg):
 1075:         class subclass(np.ndarray):
 1076:             def __array_wrap__(self, obj, context=None, return_value=None):
 1077:                 return super().__array_wrap__(obj, context, return_value)
 1078: 
 1079:         if arg == "scalar":
 1080:             one = 1
 1081:             expected_type = np.ndarray
 1082:         elif arg == "array":
 1083:             one = np.array(1)
 1084:             expected_type = np.ndarray
 1085:         elif arg == "subclass":
 1086:             one = np.array(1).view(subclass)
 1087:             expected_type = subclass
 1088: 
 1089:         assert type(np.add(one, 2, out=...)) is expected_type
 1090:         assert type(np.add.reduce(one, out=...)) is expected_type
 1091:         res1, res2 = np.divmod(one, 2, out=...)
 1092:         assert type(res1) is type(res2) is expected_type
 1093: 
 1094:     def test_output_ellipsis_errors(self):
 1095:         with pytest.raises(TypeError,
 1096:                 match=r"out=\.\.\. is only allowed as a keyword argument."):
 1097:             np.add(1, 2, ...)
 1098: 
 1099:         with pytest.raises(TypeError,
 1100:                 match=r"out=\.\.\. is only allowed as a keyword argument."):
 1101:             np.add.reduce(1, (), None, ...)
 1102: 
 1103:         with pytest.raises(TypeError,
 1104:                 match=r"must use `\.\.\.` as `out=\.\.\.` and not per-operand/in a tuple"):
 1105:             np.negative(1, out=(...,))
 1106: 
 1107:         with pytest.raises(TypeError,
 1108:                 match=r"must use `\.\.\.` as `out=\.\.\.` and not per-operand/in a tuple"):
 1109:             # We only allow out=... not individual args for now
 1110:             np.divmod(1, 2, out=(np.empty(()), ...))
 1111: 
 1112:         with pytest.raises(TypeError,
 1113:                 match=r"must use `\.\.\.` as `out=\.\.\.` and not per-operand/in a tuple"):
 1114:             np.add.reduce(1, out=(...,))
 1115: 
 1116:     def test_axes_argument(self):
 1117:         # vecdot signature: '(n),(n)->()'
 1118:         a = np.arange(27.).reshape((3, 3, 3))
 1119:         b = np.arange(10., 19.).reshape((3, 1, 3))
 1120:         # basic tests on inputs (outputs tested below with matrix_multiply).
 1121:         c = np.vecdot(a, b)
 1122:         assert_array_equal(c, (a * b).sum(-1))
 1123:         # default
 1124:         c = np.vecdot(a, b, axes=[(-1,), (-1,), ()])
 1125:         assert_array_equal(c, (a * b).sum(-1))
 1126:         # integers ok for single axis.
 1127:         c = np.vecdot(a, b, axes=[-1, -1, ()])
 1128:         assert_array_equal(c, (a * b).sum(-1))
 1129:         # mix fine
 1130:         c = np.vecdot(a, b, axes=[(-1,), -1, ()])
 1131:         assert_array_equal(c, (a * b).sum(-1))
 1132:         # can omit last axis.
 1133:         c = np.vecdot(a, b, axes=[-1, -1])
 1134:         assert_array_equal(c, (a * b).sum(-1))
 1135:         # can pass in other types of integer (with __index__ protocol)
 1136:         c = np.vecdot(a, b, axes=[np.int8(-1), np.array(-1, dtype=np.int32)])
 1137:         assert_array_equal(c, (a * b).sum(-1))
 1138:         # swap some axes
 1139:         c = np.vecdot(a, b, axes=[0, 0])
 1140:         assert_array_equal(c, (a * b).sum(0))
 1141:         c = np.vecdot(a, b, axes=[0, 2])
 1142:         assert_array_equal(c, (a.transpose(1, 2, 0) * b).sum(-1))
 1143:         # Check errors for improperly constructed axes arguments.
 1144:         # should have list.
 1145:         assert_raises(TypeError, np.vecdot, a, b, axes=-1)
 1146:         # needs enough elements
 1147:         assert_raises(ValueError, np.vecdot, a, b, axes=[-1])
 1148:         # should pass in indices.
 1149:         assert_raises(TypeError, np.vecdot, a, b, axes=[-1.0, -1.0])
 1150:         assert_raises(TypeError, np.vecdot, a, b, axes=[(-1.0,), -1])
 1151:         assert_raises(TypeError, np.vecdot, a, b, axes=[None, 1])
 1152:         # cannot pass an index unless there is only one dimension
 1153:         # (output is wrong in this case)
 1154:         assert_raises(AxisError, np.vecdot, a, b, axes=[-1, -1, -1])
 1155:         # or pass in generally the wrong number of axes
 1156:         assert_raises(AxisError, np.vecdot, a, b, axes=[-1, -1, (-1,)])
 1157:         assert_raises(AxisError, np.vecdot, a, b, axes=[-1, (-2, -1), ()])
 1158:         # axes need to have same length.
 1159:         assert_raises(ValueError, np.vecdot, a, b, axes=[0, 1])
 1160: 
 1161:         # matrix_multiply signature: '(m,n),(n,p)->(m,p)'
 1162:         mm = umt.matrix_multiply
 1163:         a = np.arange(12).reshape((2, 3, 2))
 1164:         b = np.arange(8).reshape((2, 2, 2, 1)) + 1
 1165:         # Sanity check.
 1166:         c = mm(a, b)
 1167:         assert_array_equal(c, np.matmul(a, b))
 1168:         # Default axes.
 1169:         c = mm(a, b, axes=[(-2, -1), (-2, -1), (-2, -1)])
 1170:         assert_array_equal(c, np.matmul(a, b))
 1171:         # Default with explicit axes.
 1172:         c = mm(a, b, axes=[(1, 2), (2, 3), (2, 3)])
 1173:         assert_array_equal(c, np.matmul(a, b))
 1174:         # swap some axes.
 1175:         c = mm(a, b, axes=[(0, -1), (1, 2), (-2, -1)])
 1176:         assert_array_equal(c, np.matmul(a.transpose(1, 0, 2),
 1177:                                         b.transpose(0, 3, 1, 2)))
 1178:         # Default with output array.
 1179:         c = np.empty((2, 2, 3, 1))
 1180:         d = mm(a, b, out=c, axes=[(1, 2), (2, 3), (2, 3)])
 1181:         assert_(c is d)
 1182:         assert_array_equal(c, np.matmul(a, b))
 1183:         # Transposed output array
 1184:         c = np.empty((1, 2, 2, 3))
 1185:         d = mm(a, b, out=c, axes=[(-2, -1), (-2, -1), (3, 0)])
 1186:         assert_(c is d)
 1187:         assert_array_equal(c, np.matmul(a, b).transpose(3, 0, 1, 2))
 1188:         # Check errors for improperly constructed axes arguments.
 1189:         # wrong argument
 1190:         assert_raises(TypeError, mm, a, b, axis=1)
 1191:         # axes should be list
 1192:         assert_raises(TypeError, mm, a, b, axes=1)
 1193:         assert_raises(TypeError, mm, a, b, axes=((-2, -1), (-2, -1), (-2, -1)))
 1194:         # list needs to have right length
 1195:         assert_raises(ValueError, mm, a, b, axes=[])
 1196:         assert_raises(ValueError, mm, a, b, axes=[(-2, -1)])
 1197:         # list should not contain None, or lists
 1198:         assert_raises(TypeError, mm, a, b, axes=[None, None, None])
 1199:         assert_raises(TypeError,
 1200:                       mm, a, b, axes=[[-2, -1], [-2, -1], [-2, -1]])
 1201:         assert_raises(TypeError,
 1202:                       mm, a, b, axes=[(-2, -1), (-2, -1), [-2, -1]])
 1203:         assert_raises(TypeError, mm, a, b, axes=[(-2, -1), (-2, -1), None])
 1204:         # single integers are AxisErrors if more are required
 1205:         assert_raises(AxisError, mm, a, b, axes=[-1, -1, -1])
 1206:         assert_raises(AxisError, mm, a, b, axes=[(-2, -1), (-2, -1), -1])
 1207:         # tuples should not have duplicated values
 1208:         assert_raises(ValueError, mm, a, b, axes=[(-2, -1), (-2, -1), (-2, -2)])
 1209:         # arrays should have enough axes.
 1210:         z = np.zeros((2, 2))
 1211:         assert_raises(ValueError, mm, z, z[0])
 1212:         assert_raises(ValueError, mm, z, z, out=z[:, 0])
 1213:         assert_raises(ValueError, mm, z[1], z, axes=[0, 1])
 1214:         assert_raises(ValueError, mm, z, z, out=z[0], axes=[0, 1])
 1215:         # Regular ufuncs should not accept axes.
 1216:         assert_raises(TypeError, np.add, 1., 1., axes=[0])
 1217:         # should be able to deal with bad unrelated kwargs.
 1218:         assert_raises(TypeError, mm, z, z, axes=[0, 1], parrot=True)
 1219: 
 1220:     def test_axis_argument(self):
 1221:         # vecdot signature: '(n),(n)->()'
 1222:         a = np.arange(27.).reshape((3, 3, 3))
 1223:         b = np.arange(10., 19.).reshape((3, 1, 3))
 1224:         c = np.vecdot(a, b)
 1225:         assert_array_equal(c, (a * b).sum(-1))
 1226:         c = np.vecdot(a, b, axis=-1)
 1227:         assert_array_equal(c, (a * b).sum(-1))
 1228:         out = np.zeros_like(c)
 1229:         d = np.vecdot(a, b, axis=-1, out=out)
 1230:         assert_(d is out)
 1231:         assert_array_equal(d, c)
 1232:         c = np.vecdot(a, b, axis=0)
 1233:         assert_array_equal(c, (a * b).sum(0))
 1234:         # Sanity checks on innerwt and cumsum.
 1235:         a = np.arange(6).reshape((2, 3))
 1236:         b = np.arange(10, 16).reshape((2, 3))
 1237:         w = np.arange(20, 26).reshape((2, 3))
 1238:         assert_array_equal(umt.innerwt(a, b, w, axis=0),
 1239:                            np.sum(a * b * w, axis=0))
 1240:         assert_array_equal(umt.cumsum(a, axis=0), np.cumsum(a, axis=0))
 1241:         assert_array_equal(umt.cumsum(a, axis=-1), np.cumsum(a, axis=-1))
 1242:         out = np.empty_like(a)
 1243:         b = umt.cumsum(a, out=out, axis=0)
 1244:         assert_(out is b)
 1245:         assert_array_equal(b, np.cumsum(a, axis=0))
 1246:         b = umt.cumsum(a, out=out, axis=1)
 1247:         assert_(out is b)
 1248:         assert_array_equal(b, np.cumsum(a, axis=-1))
 1249:         # Check errors.
 1250:         # Cannot pass in both axis and axes.
 1251:         assert_raises(TypeError, np.vecdot, a, b, axis=0, axes=[0, 0])
 1252:         # Not an integer.
 1253:         assert_raises(TypeError, np.vecdot, a, b, axis=[0])
 1254:         # more than 1 core dimensions.
 1255:         mm = umt.matrix_multiply
 1256:         assert_raises(TypeError, mm, a, b, axis=1)
 1257:         # Output wrong size in axis.
 1258:         out = np.empty((1, 2, 3), dtype=a.dtype)
 1259:         assert_raises(ValueError, umt.cumsum, a, out=out, axis=0)
 1260:         # Regular ufuncs should not accept axis.
 1261:         assert_raises(TypeError, np.add, 1., 1., axis=0)
 1262: 
 1263:     def test_keepdims_argument(self):
 1264:         # vecdot signature: '(n),(n)->()'
 1265:         a = np.arange(27.).reshape((3, 3, 3))
 1266:         b = np.arange(10., 19.).reshape((3, 1, 3))
 1267:         c = np.vecdot(a, b)
 1268:         assert_array_equal(c, (a * b).sum(-1))
 1269:         c = np.vecdot(a, b, keepdims=False)
 1270:         assert_array_equal(c, (a * b).sum(-1))
 1271:         c = np.vecdot(a, b, keepdims=True)
 1272:         assert_array_equal(c, (a * b).sum(-1, keepdims=True))
 1273:         out = np.zeros_like(c)
 1274:         d = np.vecdot(a, b, keepdims=True, out=out)
 1275:         assert_(d is out)
 1276:         assert_array_equal(d, c)
 1277:         # Now combined with axis and axes.
 1278:         c = np.vecdot(a, b, axis=-1, keepdims=False)
 1279:         assert_array_equal(c, (a * b).sum(-1, keepdims=False))
 1280:         c = np.vecdot(a, b, axis=-1, keepdims=True)
 1281:         assert_array_equal(c, (a * b).sum(-1, keepdims=True))
 1282:         c = np.vecdot(a, b, axis=0, keepdims=False)
 1283:         assert_array_equal(c, (a * b).sum(0, keepdims=False))
 1284:         c = np.vecdot(a, b, axis=0, keepdims=True)
 1285:         assert_array_equal(c, (a * b).sum(0, keepdims=True))
 1286:         c = np.vecdot(a, b, axes=[(-1,), (-1,), ()], keepdims=False)
 1287:         assert_array_equal(c, (a * b).sum(-1))
 1288:         c = np.vecdot(a, b, axes=[(-1,), (-1,), (-1,)], keepdims=True)
 1289:         assert_array_equal(c, (a * b).sum(-1, keepdims=True))
 1290:         c = np.vecdot(a, b, axes=[0, 0], keepdims=False)
 1291:         assert_array_equal(c, (a * b).sum(0))
 1292:         c = np.vecdot(a, b, axes=[0, 0, 0], keepdims=True)
 1293:         assert_array_equal(c, (a * b).sum(0, keepdims=True))
 1294:         c = np.vecdot(a, b, axes=[0, 2], keepdims=False)
 1295:         assert_array_equal(c, (a.transpose(1, 2, 0) * b).sum(-1))
 1296:         c = np.vecdot(a, b, axes=[0, 2], keepdims=True)
 1297:         assert_array_equal(c, (a.transpose(1, 2, 0) * b).sum(-1,
 1298:                                                              keepdims=True))
 1299:         c = np.vecdot(a, b, axes=[0, 2, 2], keepdims=True)
 1300:         assert_array_equal(c, (a.transpose(1, 2, 0) * b).sum(-1,
 1301:                                                              keepdims=True))
 1302:         c = np.vecdot(a, b, axes=[0, 2, 0], keepdims=True)
 1303:         assert_array_equal(c, (a * b.transpose(2, 0, 1)).sum(0, keepdims=True))
 1304:         # Hardly useful, but should work.
 1305:         c = np.vecdot(a, b, axes=[0, 2, 1], keepdims=True)
 1306:         assert_array_equal(c, (a.transpose(1, 0, 2) * b.transpose(0, 2, 1))
 1307:                            .sum(1, keepdims=True))
 1308:         # Check with two core dimensions.
 1309:         a = np.eye(3) * np.arange(4.)[:, np.newaxis, np.newaxis]
 1310:         expected = uml.det(a)
 1311:         c = uml.det(a, keepdims=False)
 1312:         assert_array_equal(c, expected)
 1313:         c = uml.det(a, keepdims=True)
 1314:         assert_array_equal(c, expected[:, np.newaxis, np.newaxis])
 1315:         a = np.eye(3) * np.arange(4.)[:, np.newaxis, np.newaxis]
 1316:         expected_s, expected_l = uml.slogdet(a)
 1317:         cs, cl = uml.slogdet(a, keepdims=False)
 1318:         assert_array_equal(cs, expected_s)
 1319:         assert_array_equal(cl, expected_l)
 1320:         cs, cl = uml.slogdet(a, keepdims=True)
 1321:         assert_array_equal(cs, expected_s[:, np.newaxis, np.newaxis])
 1322:         assert_array_equal(cl, expected_l[:, np.newaxis, np.newaxis])
 1323:         # Sanity check on innerwt.
 1324:         a = np.arange(6).reshape((2, 3))
 1325:         b = np.arange(10, 16).reshape((2, 3))
 1326:         w = np.arange(20, 26).reshape((2, 3))
 1327:         assert_array_equal(umt.innerwt(a, b, w, keepdims=True),
 1328:                            np.sum(a * b * w, axis=-1, keepdims=True))
 1329:         assert_array_equal(umt.innerwt(a, b, w, axis=0, keepdims=True),
 1330:                            np.sum(a * b * w, axis=0, keepdims=True))
 1331:         # Check errors.
 1332:         # Not a boolean
 1333:         assert_raises(TypeError, np.vecdot, a, b, keepdims='true')
 1334:         # More than 1 core dimension, and core output dimensions.
 1335:         mm = umt.matrix_multiply
 1336:         assert_raises(TypeError, mm, a, b, keepdims=True)
 1337:         assert_raises(TypeError, mm, a, b, keepdims=False)
 1338:         # Regular ufuncs should not accept keepdims.
 1339:         assert_raises(TypeError, np.add, 1., 1., keepdims=False)
 1340: 
 1341:     def test_innerwt(self):
 1342:         a = np.arange(6).reshape((2, 3))
 1343:         b = np.arange(10, 16).reshape((2, 3))
 1344:         w = np.arange(20, 26).reshape((2, 3))
 1345:         assert_array_equal(umt.innerwt(a, b, w), np.sum(a * b * w, axis=-1))
 1346:         a = np.arange(100, 124).reshape((2, 3, 4))
 1347:         b = np.arange(200, 224).reshape((2, 3, 4))
 1348:         w = np.arange(300, 324).reshape((2, 3, 4))
 1349:         assert_array_equal(umt.innerwt(a, b, w), np.sum(a * b * w, axis=-1))
 1350: 
 1351:     def test_innerwt_empty(self):
 1352:         """Test generalized ufunc with zero-sized operands"""
 1353:         a = np.array([], dtype='f8')
 1354:         b = np.array([], dtype='f8')
 1355:         w = np.array([], dtype='f8')
 1356:         assert_array_equal(umt.innerwt(a, b, w), np.sum(a * b * w, axis=-1))
 1357: 
 1358:     def test_cross1d(self):
 1359:         """Test with fixed-sized signature."""
 1360:         a = np.eye(3)
 1361:         assert_array_equal(umt.cross1d(a, a), np.zeros((3, 3)))
 1362:         out = np.zeros((3, 3))
 1363:         result = umt.cross1d(a[0], a, out)
 1364:         assert_(result is out)
 1365:         assert_array_equal(result, np.vstack((np.zeros(3), a[2], -a[1])))
 1366:         assert_raises(ValueError, umt.cross1d, np.eye(4), np.eye(4))
 1367:         assert_raises(ValueError, umt.cross1d, a, np.arange(4.))
 1368:         # Wrong output core dimension.
 1369:         assert_raises(ValueError, umt.cross1d, a, np.arange(3.), np.zeros((3, 4)))
 1370:         # Wrong output broadcast dimension (see gh-15139).
 1371:         assert_raises(ValueError, umt.cross1d, a, np.arange(3.), np.zeros(3))
 1372: 
 1373:     def test_can_ignore_signature(self):
 1374:         # Comparing the effects of ? in signature:
 1375:         # matrix_multiply: (m,n),(n,p)->(m,p)    # all must be there.
 1376:         # matmul:        (m?,n),(n,p?)->(m?,p?)  # allow missing m, p.
 1377:         mat = np.arange(12).reshape((2, 3, 2))
 1378:         single_vec = np.arange(2)
 1379:         col_vec = single_vec[:, np.newaxis]
 1380:         col_vec_array = np.arange(8).reshape((2, 2, 2, 1)) + 1
 1381:         # matrix @ single column vector with proper dimension
 1382:         mm_col_vec = umt.matrix_multiply(mat, col_vec)
 1383:         # matmul does the same thing
 1384:         matmul_col_vec = umt.matmul(mat, col_vec)
 1385:         assert_array_equal(matmul_col_vec, mm_col_vec)
 1386:         # matrix @ vector without dimension making it a column vector.
 1387:         # matrix multiply fails -> missing core dim.
 1388:         assert_raises(ValueError, umt.matrix_multiply, mat, single_vec)
 1389:         # matmul mimicker passes, and returns a vector.
 1390:         matmul_col = umt.matmul(mat, single_vec)
 1391:         assert_array_equal(matmul_col, mm_col_vec.squeeze())
 1392:         # Now with a column array: same as for column vector,
 1393:         # broadcasting sensibly.
 1394:         mm_col_vec = umt.matrix_multiply(mat, col_vec_array)
 1395:         matmul_col_vec = umt.matmul(mat, col_vec_array)
 1396:         assert_array_equal(matmul_col_vec, mm_col_vec)
 1397:         # As above, but for row vector
 1398:         single_vec = np.arange(3)
 1399:         row_vec = single_vec[np.newaxis, :]
 1400:         row_vec_array = np.arange(24).reshape((4, 2, 1, 1, 3)) + 1
 1401:         # row vector @ matrix
 1402:         mm_row_vec = umt.matrix_multiply(row_vec, mat)
 1403:         matmul_row_vec = umt.matmul(row_vec, mat)
 1404:         assert_array_equal(matmul_row_vec, mm_row_vec)
 1405:         # single row vector @ matrix
 1406:         assert_raises(ValueError, umt.matrix_multiply, single_vec, mat)
 1407:         matmul_row = umt.matmul(single_vec, mat)
 1408:         assert_array_equal(matmul_row, mm_row_vec.squeeze())
 1409:         # row vector array @ matrix
 1410:         mm_row_vec = umt.matrix_multiply(row_vec_array, mat)
 1411:         matmul_row_vec = umt.matmul(row_vec_array, mat)
 1412:         assert_array_equal(matmul_row_vec, mm_row_vec)
 1413:         # Now for vector combinations
 1414:         # row vector @ column vector
 1415:         col_vec = row_vec.T
 1416:         col_vec_array = row_vec_array.swapaxes(-2, -1)
 1417:         mm_row_col_vec = umt.matrix_multiply(row_vec, col_vec)
 1418:         matmul_row_col_vec = umt.matmul(row_vec, col_vec)
 1419:         assert_array_equal(matmul_row_col_vec, mm_row_col_vec)
 1420:         # single row vector @ single col vector
 1421:         assert_raises(ValueError, umt.matrix_multiply, single_vec, single_vec)
 1422:         matmul_row_col = umt.matmul(single_vec, single_vec)
 1423:         assert_array_equal(matmul_row_col, mm_row_col_vec.squeeze())
 1424:         # row vector array @ matrix
 1425:         mm_row_col_array = umt.matrix_multiply(row_vec_array, col_vec_array)
 1426:         matmul_row_col_array = umt.matmul(row_vec_array, col_vec_array)
 1427:         assert_array_equal(matmul_row_col_array, mm_row_col_array)
 1428:         # Finally, check that things are *not* squeezed if one gives an
 1429:         # output.
 1430:         out = np.zeros_like(mm_row_col_array)
 1431:         out = umt.matrix_multiply(row_vec_array, col_vec_array, out=out)
 1432:         assert_array_equal(out, mm_row_col_array)
 1433:         out[:] = 0
 1434:         out = umt.matmul(row_vec_array, col_vec_array, out=out)
 1435:         assert_array_equal(out, mm_row_col_array)
 1436:         # And check one cannot put missing dimensions back.
 1437:         out = np.zeros_like(mm_row_col_vec)
 1438:         assert_raises(ValueError, umt.matrix_multiply, single_vec, single_vec,
 1439:                       out)
 1440:         # But fine for matmul, since it is just a broadcast.
 1441:         out = umt.matmul(single_vec, single_vec, out)
 1442:         assert_array_equal(out, mm_row_col_vec.squeeze())
 1443: 
 1444:     def test_matrix_multiply(self):
 1445:         self.compare_matrix_multiply_results(np.int64)
 1446:         self.compare_matrix_multiply_results(np.double)
 1447: 
 1448:     def test_matrix_multiply_umath_empty(self):
 1449:         res = umt.matrix_multiply(np.ones((0, 10)), np.ones((10, 0)))
 1450:         assert_array_equal(res, np.zeros((0, 0)))
 1451:         res = umt.matrix_multiply(np.ones((10, 0)), np.ones((0, 10)))
 1452:         assert_array_equal(res, np.zeros((10, 10)))
 1453: 
 1454:     def compare_matrix_multiply_results(self, tp):
 1455:         d1 = np.array(np.random.rand(2, 3, 4), dtype=tp)
 1456:         d2 = np.array(np.random.rand(2, 3, 4), dtype=tp)
 1457:         msg = f"matrix multiply on type {d1.dtype.name}"
 1458: 
 1459:         def permute_n(n):
 1460:             if n == 1:
 1461:                 return ([0],)
 1462:             ret = ()
 1463:             base = permute_n(n - 1)
 1464:             for perm in base:
 1465:                 for i in range(n):
 1466:                     new = perm + [n - 1]
 1467:                     new[n - 1] = new[i]
 1468:                     new[i] = n - 1
 1469:                     ret += (new,)
 1470:             return ret
 1471: 
 1472:         def slice_n(n):
 1473:             if n == 0:
 1474:                 return ((),)
 1475:             ret = ()
 1476:             base = slice_n(n - 1)
 1477:             for sl in base:
 1478:                 ret += (sl + (slice(None),),)
 1479:                 ret += (sl + (slice(0, 1),),)
 1480:             return ret
 1481: 
 1482:         def broadcastable(s1, s2):
 1483:             return s1 == s2 or 1 in {s1, s2}
 1484: 
 1485:         permute_3 = permute_n(3)
 1486:         slice_3 = slice_n(3) + ((slice(None, None, -1),) * 3,)
 1487: 
 1488:         ref = True
 1489:         for p1 in permute_3:
 1490:             for p2 in permute_3:
 1491:                 for s1 in slice_3:
 1492:                     for s2 in slice_3:
 1493:                         a1 = d1.transpose(p1)[s1]
 1494:                         a2 = d2.transpose(p2)[s2]
 1495:                         ref = ref and a1.base is not None
 1496:                         ref = ref and a2.base is not None
 1497:                         if (a1.shape[-1] == a2.shape[-2] and
 1498:                                 broadcastable(a1.shape[0], a2.shape[0])):
 1499:                             assert_array_almost_equal(
 1500:                                 umt.matrix_multiply(a1, a2),
 1501:                                 np.sum(a2[..., np.newaxis].swapaxes(-3, -1) *
 1502:                                        a1[..., np.newaxis, :], axis=-1),
 1503:                                 err_msg=msg + f' {str(a1.shape)} {str(a2.shape)}')
 1504: 
 1505:         assert_equal(ref, True, err_msg="reference check")
 1506: 
 1507:     def test_euclidean_pdist(self):
 1508:         a = np.arange(12, dtype=float).reshape(4, 3)
 1509:         out = np.empty((a.shape[0] * (a.shape[0] - 1) // 2,), dtype=a.dtype)
 1510:         umt.euclidean_pdist(a, out)
 1511:         b = np.sqrt(np.sum((a[:, None] - a)**2, axis=-1))
 1512:         b = b[~np.tri(a.shape[0], dtype=bool)]
 1513:         assert_almost_equal(out, b)
 1514:         # An output array is required to determine p with signature (n,d)->(p)
 1515:         assert_raises(ValueError, umt.euclidean_pdist, a)
 1516: 
 1517:     def test_cumsum(self):
 1518:         a = np.arange(10)
 1519:         result = umt.cumsum(a)
 1520:         assert_array_equal(result, a.cumsum())
 1521: 
 1522:     def test_object_logical(self):
 1523:         a = np.array([3, None, True, False, "test", ""], dtype=object)
 1524:         assert_equal(np.logical_or(a, None),
 1525:                         np.array([x or None for x in a], dtype=object))
 1526:         assert_equal(np.logical_or(a, True),
 1527:                         np.array([x or True for x in a], dtype=object))
 1528:         assert_equal(np.logical_or(a, 12),
 1529:                         np.array([x or 12 for x in a], dtype=object))
 1530:         assert_equal(np.logical_or(a, "blah"),
 1531:                         np.array([x or "blah" for x in a], dtype=object))
 1532: 
 1533:         assert_equal(np.logical_and(a, None),
 1534:                         np.array([x and None for x in a], dtype=object))
 1535:         assert_equal(np.logical_and(a, True),
 1536:                         np.array([x and True for x in a], dtype=object))
 1537:         assert_equal(np.logical_and(a, 12),
 1538:                         np.array([x and 12 for x in a], dtype=object))
 1539:         assert_equal(np.logical_and(a, "blah"),
 1540:                         np.array([x and "blah" for x in a], dtype=object))
 1541: 
 1542:         assert_equal(np.logical_not(a),
 1543:                         np.array([not x for x in a], dtype=object))
 1544: 
 1545:         assert_equal(np.logical_or.reduce(a), 3)
 1546:         assert_equal(np.logical_and.reduce(a), None)
 1547: 
 1548:     def test_object_comparison(self):
 1549:         class HasComparisons:
 1550:             def __eq__(self, other):
 1551:                 return '=='
 1552: 
 1553:         arr0d = np.array(HasComparisons())
 1554:         assert_equal(arr0d == arr0d, True)
 1555:         assert_equal(np.equal(arr0d, arr0d), True)  # normal behavior is a cast
 1556: 
 1557:         arr1d = np.array([HasComparisons()])
 1558:         assert_equal(arr1d == arr1d, np.array([True]))
 1559:         assert_equal(np.equal(arr1d, arr1d), np.array([True]))  # normal behavior is a cast
 1560:         assert_equal(np.equal(arr1d, arr1d, dtype=object), np.array(['==']))
 1561: 
 1562:     def test_object_array_reduction(self):
 1563:         # Reductions on object arrays
 1564:         a = np.array(['a', 'b', 'c'], dtype=object)
 1565:         assert_equal(np.sum(a), 'abc')
 1566:         assert_equal(np.max(a), 'c')
 1567:         assert_equal(np.min(a), 'a')
 1568:         a = np.array([True, False, True], dtype=object)
 1569:         assert_equal(np.sum(a), 2)
 1570:         assert_equal(np.prod(a), 0)
 1571:         assert_equal(np.any(a), True)
 1572:         assert_equal(np.all(a), False)
 1573:         assert_equal(np.max(a), True)
 1574:         assert_equal(np.min(a), False)
 1575:         assert_equal(np.array([[1]], dtype=object).sum(), 1)
 1576:         assert_equal(np.array([[[1, 2]]], dtype=object).sum((0, 1)), [1, 2])
 1577:         assert_equal(np.array([1], dtype=object).sum(initial=1), 2)
 1578:         assert_equal(np.array([[1], [2, 3]], dtype=object)
 1579:                      .sum(initial=[0], where=[False, True]), [0, 2, 3])
 1580: 
 1581:     def test_object_array_accumulate_inplace(self):
 1582:         # Checks that in-place accumulates work, see also gh-7402
 1583:         arr = np.ones(4, dtype=object)
 1584:         arr[:] = [[1] for i in range(4)]
 1585:         # Twice reproduced also for tuples:
 1586:         np.add.accumulate(arr, out=arr)
 1587:         np.add.accumulate(arr, out=arr)
 1588:         assert_array_equal(arr,
 1589:                            np.array([[1] * i for i in [1, 3, 6, 10]], dtype=object),
 1590:                           )
 1591: 
 1592:         # And the same if the axis argument is used
 1593:         arr = np.ones((2, 4), dtype=object)
 1594:         arr[0, :] = [[2] for i in range(4)]
 1595:         np.add.accumulate(arr, out=arr, axis=-1)
 1596:         np.add.accumulate(arr, out=arr, axis=-1)
 1597:         assert_array_equal(arr[0, :],
 1598:                            np.array([[2] * i for i in [1, 3, 6, 10]], dtype=object),
 1599:                           )
 1600: 
 1601:     def test_object_array_accumulate_failure(self):
 1602:         # Typical accumulation on object works as expected:
 1603:         res = np.add.accumulate(np.array([1, 0, 2], dtype=object))
 1604:         assert_array_equal(res, np.array([1, 1, 3], dtype=object))
 1605:         # But errors are propagated from the inner-loop if they occur:
 1606:         with pytest.raises(TypeError):
 1607:             np.add.accumulate([1, None, 2])
 1608: 
 1609:     def test_object_array_reduceat_inplace(self):
 1610:         # Checks that in-place reduceats work, see also gh-7465
 1611:         arr = np.empty(4, dtype=object)
 1612:         arr[:] = [[1] for i in range(4)]
 1613:         out = np.empty(4, dtype=object)
 1614:         out[:] = [[1] for i in range(4)]
 1615:         np.add.reduceat(arr, np.arange(4), out=arr)
 1616:         np.add.reduceat(arr, np.arange(4), out=arr)
 1617:         assert_array_equal(arr, out)
 1618: 
 1619:         # And the same if the axis argument is used
 1620:         arr = np.ones((2, 4), dtype=object)
 1621:         arr[0, :] = [[2] for i in range(4)]
 1622:         out = np.ones((2, 4), dtype=object)
 1623:         out[0, :] = [[2] for i in range(4)]
 1624:         np.add.reduceat(arr, np.arange(4), out=arr, axis=-1)
 1625:         np.add.reduceat(arr, np.arange(4), out=arr, axis=-1)
 1626:         assert_array_equal(arr, out)
 1627: 
 1628:     def test_object_array_reduceat_failure(self):
 1629:         # Reduceat works as expected when no invalid operation occurs (None is
 1630:         # not involved in an operation here)
 1631:         res = np.add.reduceat(np.array([1, None, 2], dtype=object), [1, 2])
 1632:         assert_array_equal(res, np.array([None, 2], dtype=object))
 1633:         # But errors when None would be involved in an operation:
 1634:         with pytest.raises(TypeError):
 1635:             np.add.reduceat([1, None, 2], [0, 2])
 1636: 
 1637:     def test_zerosize_reduction(self):
 1638:         # Test with default dtype and object dtype
 1639:         for a in [[], np.array([], dtype=object)]:
 1640:             assert_equal(np.sum(a), 0)
 1641:             assert_equal(np.prod(a), 1)
 1642:             assert_equal(np.any(a), False)
 1643:             assert_equal(np.all(a), True)
 1644:             assert_raises(ValueError, np.max, a)
 1645:             assert_raises(ValueError, np.min, a)
 1646: 
 1647:     def test_axis_out_of_bounds(self):
 1648:         a = np.array([False, False])
 1649:         assert_raises(AxisError, a.all, axis=1)
 1650:         a = np.array([False, False])
 1651:         assert_raises(AxisError, a.all, axis=-2)
 1652: 
 1653:         a = np.array([False, False])
 1654:         assert_raises(AxisError, a.any, axis=1)
 1655:         a = np.array([False, False])
 1656:         assert_raises(AxisError, a.any, axis=-2)
 1657: 
 1658:     def test_scalar_reduction(self):
 1659:         # The functions 'sum', 'prod', etc allow specifying axis=0
 1660:         # even for scalars
 1661:         assert_equal(np.sum(3, axis=0), 3)
 1662:         assert_equal(np.prod(3.5, axis=0), 3.5)
 1663:         assert_equal(np.any(True, axis=0), True)
 1664:         assert_equal(np.all(False, axis=0), False)
 1665:         assert_equal(np.max(3, axis=0), 3)
 1666:         assert_equal(np.min(2.5, axis=0), 2.5)
 1667: 
 1668:         # Check scalar behaviour for ufuncs without an identity
 1669:         assert_equal(np.power.reduce(3), 3)
 1670: 
 1671:         # Make sure that scalars are coming out from this operation
 1672:         assert_(type(np.prod(np.float32(2.5), axis=0)) is np.float32)
 1673:         assert_(type(np.sum(np.float32(2.5), axis=0)) is np.float32)
 1674:         assert_(type(np.max(np.float32(2.5), axis=0)) is np.float32)
 1675:         assert_(type(np.min(np.float32(2.5), axis=0)) is np.float32)
 1676: 
 1677:         # check if scalars/0-d arrays get cast
 1678:         assert_(type(np.any(0, axis=0)) is np.bool)
 1679: 
 1680:         # assert that 0-d arrays get wrapped
 1681:         class MyArray(np.ndarray):
 1682:             pass
 1683:         a = np.array(1).view(MyArray)
 1684:         assert_(type(np.any(a)) is MyArray)
 1685: 
 1686:     def test_casting_out_param(self):
 1687:         # Test that it's possible to do casts on output
 1688:         a = np.ones((200, 100), np.int64)
 1689:         b = np.ones((200, 100), np.int64)
 1690:         c = np.ones((200, 100), np.float64)
 1691:         np.add(a, b, out=c)
 1692:         assert_equal(c, 2)
 1693: 
 1694:         a = np.zeros(65536)
 1695:         b = np.zeros(65536, dtype=np.float32)
 1696:         np.subtract(a, 0, out=b)
 1697:         assert_equal(b, 0)
 1698: 
 1699:     def test_where_param(self):
 1700:         # Test that the where= ufunc parameter works with regular arrays
 1701:         a = np.arange(7)
 1702:         b = np.ones(7)
 1703:         c = np.zeros(7)
 1704:         np.add(a, b, out=c, where=(a % 2 == 1))
 1705:         assert_equal(c, [0, 2, 0, 4, 0, 6, 0])
 1706: 
 1707:         a = np.arange(4).reshape(2, 2) + 2
 1708:         np.power(a, [2, 3], out=a, where=[[0, 1], [1, 0]])
 1709:         assert_equal(a, [[2, 27], [16, 5]])
 1710:         # Broadcasting the where= parameter
 1711:         np.subtract(a, 2, out=a, where=[True, False])
 1712:         assert_equal(a, [[0, 27], [14, 5]])
 1713: 
 1714:     def test_where_param_buffer_output(self):
 1715:         # This test is temporarily skipped because it requires
 1716:         # adding masking features to the nditer to work properly
 1717: 
 1718:         # With casting on output
 1719:         a = np.ones(10, np.int64)
 1720:         b = np.ones(10, np.int64)
 1721:         c = 1.5 * np.ones(10, np.float64)
 1722:         np.add(a, b, out=c, where=[1, 0, 0, 1, 0, 0, 1, 1, 1, 0])
 1723:         assert_equal(c, [2, 1.5, 1.5, 2, 1.5, 1.5, 2, 2, 2, 1.5])
 1724: 
 1725:     def test_where_param_alloc(self):
 1726:         # With casting and allocated output
 1727:         a = np.array([1], dtype=np.int64)
 1728:         m = np.array([True], dtype=bool)
 1729:         assert_equal(np.sqrt(a, where=m), [1])
 1730: 
 1731:         # No casting and allocated output
 1732:         a = np.array([1], dtype=np.float64)
 1733:         m = np.array([True], dtype=bool)
 1734:         assert_equal(np.sqrt(a, where=m), [1])
 1735: 
 1736:     def test_where_with_broadcasting(self):
 1737:         # See gh-17198
 1738:         a = np.random.random((5000, 4))
 1739:         b = np.random.random((5000, 1))
 1740: 
 1741:         where = a > 0.3
 1742:         out = np.full_like(a, 0)
 1743:         np.less(a, b, where=where, out=out)
 1744:         b_where = np.broadcast_to(b, a.shape)[where]
 1745:         assert_array_equal((a[where] < b_where), out[where].astype(bool))
 1746:         assert not out[~where].any()  # outside mask, out remains all 0
 1747: 
 1748:     @staticmethod
 1749:     def identityless_reduce_arrs():
 1750:         yield np.empty((2, 3, 4), order='C')
 1751:         yield np.empty((2, 3, 4), order='F')
 1752:         # Mixed order (reduce order differs outer)
 1753:         yield np.empty((2, 4, 3), order='C').swapaxes(1, 2)
 1754:         # Reversed order
 1755:         yield np.empty((2, 3, 4), order='C')[::-1, ::-1, ::-1]
 1756:         # Not contiguous
 1757:         yield np.empty((3, 5, 4), order='C').swapaxes(1, 2)[1:, 1:, 1:]
 1758:         # Not contiguous and not aligned
 1759:         a = np.empty((3 * 4 * 5 * 8 + 1,), dtype='i1')
 1760:         a = a[1:].view(dtype='f8')
 1761:         a.shape = (3, 4, 5)
 1762:         a = a[1:, 1:, 1:]
 1763:         yield a
 1764: 
 1765:     @pytest.mark.parametrize("a", identityless_reduce_arrs())
 1766:     @pytest.mark.parametrize("pos", [(1, 0, 0), (0, 1, 0), (0, 0, 1)])
 1767:     def test_identityless_reduction(self, a, pos):
 1768:         # np.minimum.reduce is an identityless reduction
 1769:         a[...] = 1
 1770:         a[pos] = 0
 1771: 
 1772:         for axis in [None, (0, 1), (0, 2), (1, 2), 0, 1, 2, ()]:
 1773:             if axis is None:
 1774:                 axes = np.array([], dtype=np.intp)
 1775:             else:
 1776:                 axes = np.delete(np.arange(a.ndim), axis)
 1777: 
 1778:             expected_pos = tuple(np.array(pos)[axes])
 1779:             expected = np.ones(np.array(a.shape)[axes])
 1780:             expected[expected_pos] = 0
 1781: 
 1782:             res = np.minimum.reduce(a, axis=axis)
 1783:             assert_equal(res, expected, strict=True)
 1784: 
 1785:             res = np.full_like(res, np.nan)
 1786:             np.minimum.reduce(a, axis=axis, out=res)
 1787:             assert_equal(res, expected, strict=True)
 1788: 
 1789:     @requires_memory(6 * 1024**3)
 1790:     @pytest.mark.skipif(sys.maxsize < 2**32,
 1791:             reason="test array too large for 32bit platform")
 1792:     def test_identityless_reduction_huge_array(self):
 1793:         # Regression test for gh-20921 (copying identity incorrectly failed)
 1794:         arr = np.zeros((2, 2**31), 'uint8')
 1795:         arr[:, 0] = [1, 3]
 1796:         arr[:, -1] = [4, 1]
 1797:         res = np.maximum.reduce(arr, axis=0)
 1798:         del arr
 1799:         assert res[0] == 3
 1800:         assert res[-1] == 4
 1801: 
 1802:     def test_reduce_identity_depends_on_loop(self):
 1803:         """
 1804:         The type of the result should always depend on the selected loop, not
 1805:         necessarily the output (only relevant for object arrays).
 1806:         """
 1807:         # For an object loop, the default value 0 with type int is used:
 1808:         assert type(np.add.reduce([], dtype=object)) is int
 1809:         out = np.array(None, dtype=object)
 1810:         # When the loop is float64 but `out` is object this does not happen,
 1811:         # the result is float64 cast to object (which gives Python `float`).
 1812:         np.add.reduce([], out=out, dtype=np.float64)
 1813:         assert type(out[()]) is float
 1814: 
 1815:     def test_initial_reduction(self):
 1816:         # np.minimum.reduce is an identityless reduction
 1817: 
 1818:         # For cases like np.maximum(np.abs(...), initial=0)
 1819:         # More generally, a supremum over non-negative numbers.
 1820:         assert_equal(np.maximum.reduce([], initial=0), 0)
 1821: 
 1822:         # For cases like reduction of an empty array over the reals.
 1823:         assert_equal(np.minimum.reduce([], initial=np.inf), np.inf)
 1824:         assert_equal(np.maximum.reduce([], initial=-np.inf), -np.inf)
 1825: 
 1826:         # Random tests
 1827:         assert_equal(np.minimum.reduce([5], initial=4), 4)
 1828:         assert_equal(np.maximum.reduce([4], initial=5), 5)
 1829:         assert_equal(np.maximum.reduce([5], initial=4), 5)
 1830:         assert_equal(np.minimum.reduce([4], initial=5), 4)
 1831: 
 1832:         # Check initial=None raises ValueError for both types of ufunc reductions
 1833:         assert_raises(ValueError, np.minimum.reduce, [], initial=None)
 1834:         assert_raises(ValueError, np.add.reduce, [], initial=None)
 1835:         # Also in the somewhat special object case:
 1836:         with pytest.raises(ValueError):
 1837:             np.add.reduce([], initial=None, dtype=object)
 1838: 
 1839:         # Check that np._NoValue gives default behavior.
 1840:         assert_equal(np.add.reduce([], initial=np._NoValue), 0)
 1841: 
 1842:         # Check that initial kwarg behaves as intended for dtype=object
 1843:         a = np.array([10], dtype=object)
 1844:         res = np.add.reduce(a, initial=5)
 1845:         assert_equal(res, 15)
 1846: 
 1847:     def test_empty_reduction_and_identity(self):
 1848:         arr = np.zeros((0, 5))
 1849:         # OK, since the reduction itself is *not* empty, the result is
 1850:         assert np.true_divide.reduce(arr, axis=1).shape == (0,)
 1851:         # Not OK, the reduction itself is empty and we have no identity
 1852:         with pytest.raises(ValueError):
 1853:             np.true_divide.reduce(arr, axis=0)
 1854: 
 1855:         # Test that an empty reduction fails also if the result is empty
 1856:         arr = np.zeros((0, 0, 5))
 1857:         with pytest.raises(ValueError):
 1858:             np.true_divide.reduce(arr, axis=1)
 1859: 
 1860:         # Division reduction makes sense with `initial=1` (empty or not):
 1861:         res = np.true_divide.reduce(arr, axis=1, initial=1)
 1862:         assert_array_equal(res, np.ones((0, 5)))
 1863: 
 1864:     @pytest.mark.parametrize('axis', (0, 1, None))
 1865:     @pytest.mark.parametrize('where', (np.array([False, True, True]),
 1866:                                        np.array([[True], [False], [True]]),
 1867:                                        np.array([[True, False, False],
 1868:                                                  [False, True, False],
 1869:                                                  [False, True, True]])))
 1870:     def test_reduction_with_where(self, axis, where):
 1871:         a = np.arange(9.).reshape(3, 3)
 1872:         a_copy = a.copy()
 1873:         a_check = np.zeros_like(a)
 1874:         np.positive(a, out=a_check, where=where)
 1875: 
 1876:         res = np.add.reduce(a, axis=axis, where=where)
 1877:         check = a_check.sum(axis)
 1878:         assert_equal(res, check)
 1879:         # Check we do not overwrite elements of a internally.
 1880:         assert_array_equal(a, a_copy)
 1881: 
 1882:     @pytest.mark.parametrize(('axis', 'where'),
 1883:                              ((0, np.array([True, False, True])),
 1884:                               (1, [True, True, False]),
 1885:                               (None, True)))
 1886:     @pytest.mark.parametrize('initial', (-np.inf, 5.))
 1887:     def test_reduction_with_where_and_initial(self, axis, where, initial):
 1888:         a = np.arange(9.).reshape(3, 3)
 1889:         a_copy = a.copy()
 1890:         a_check = np.full(a.shape, -np.inf)
 1891:         np.positive(a, out=a_check, where=where)
 1892: 
 1893:         res = np.maximum.reduce(a, axis=axis, where=where, initial=initial)
 1894:         check = a_check.max(axis, initial=initial)
 1895:         assert_equal(res, check)
 1896: 
 1897:     def test_reduction_where_initial_needed(self):
 1898:         a = np.arange(9.).reshape(3, 3)
 1899:         m = [False, True, False]
 1900:         assert_raises(ValueError, np.maximum.reduce, a, where=m)
 1901: 
 1902:     def test_identityless_reduction_nonreorderable(self):
 1903:         a = np.array([[8.0, 2.0, 2.0], [1.0, 0.5, 0.25]])
 1904: 
 1905:         res = np.divide.reduce(a, axis=0)
 1906:         assert_equal(res, [8.0, 4.0, 8.0])
 1907: 
 1908:         res = np.divide.reduce(a, axis=1)
 1909:         assert_equal(res, [2.0, 8.0])
 1910: 
 1911:         res = np.divide.reduce(a, axis=())
 1912:         assert_equal(res, a)
 1913: 
 1914:         assert_raises(ValueError, np.divide.reduce, a, axis=(0, 1))
 1915: 
 1916:     def test_reduce_zero_axis(self):
 1917:         # If we have a n x m array and do a reduction with axis=1, then we are
 1918:         # doing n reductions, and each reduction takes an m-element array. For
 1919:         # a reduction operation without an identity, then:
 1920:         #   n > 0, m > 0: fine
 1921:         #   n = 0, m > 0: fine, doing 0 reductions of m-element arrays
 1922:         #   n > 0, m = 0: can't reduce a 0-element array, ValueError
 1923:         #   n = 0, m = 0: can't reduce a 0-element array, ValueError (for
 1924:         #     consistency with the above case)
 1925:         # This test doesn't actually look at return values, it just checks to
 1926:         # make sure that error we get an error in exactly those cases where we
 1927:         # expect one, and assumes the calculations themselves are done
 1928:         # correctly.
 1929: 
 1930:         def ok(f, *args, **kwargs):
 1931:             f(*args, **kwargs)
 1932: 
 1933:         def err(f, *args, **kwargs):
 1934:             assert_raises(ValueError, f, *args, **kwargs)
 1935: 
 1936:         def t(expect, func, n, m):
 1937:             expect(func, np.zeros((n, m)), axis=1)
 1938:             expect(func, np.zeros((m, n)), axis=0)
 1939:             expect(func, np.zeros((n // 2, n // 2, m)), axis=2)
 1940:             expect(func, np.zeros((n // 2, m, n // 2)), axis=1)
 1941:             expect(func, np.zeros((n, m // 2, m // 2)), axis=(1, 2))
 1942:             expect(func, np.zeros((m // 2, n, m // 2)), axis=(0, 2))
 1943:             expect(func, np.zeros((m // 3, m // 3, m // 3,
 1944:                                   n // 2, n // 2)),
 1945:                                  axis=(0, 1, 2))
 1946:             # Check what happens if the inner (resp. outer) dimensions are a
 1947:             # mix of zero and non-zero:
 1948:             expect(func, np.zeros((10, m, n)), axis=(0, 1))
 1949:             expect(func, np.zeros((10, n, m)), axis=(0, 2))
 1950:             expect(func, np.zeros((m, 10, n)), axis=0)
 1951:             expect(func, np.zeros((10, m, n)), axis=1)
 1952:             expect(func, np.zeros((10, n, m)), axis=2)
 1953: 
 1954:         # np.maximum is just an arbitrary ufunc with no reduction identity
 1955:         assert_equal(np.maximum.identity, None)
 1956:         t(ok, np.maximum.reduce, 30, 30)
 1957:         t(ok, np.maximum.reduce, 0, 30)
 1958:         t(err, np.maximum.reduce, 30, 0)
 1959:         t(err, np.maximum.reduce, 0, 0)
 1960:         err(np.maximum.reduce, [])
 1961:         np.maximum.reduce(np.zeros((0, 0)), axis=())
 1962: 
 1963:         # all of the combinations are fine for a reduction that has an
 1964:         # identity
 1965:         t(ok, np.add.reduce, 30, 30)
 1966:         t(ok, np.add.reduce, 0, 30)
 1967:         t(ok, np.add.reduce, 30, 0)
 1968:         t(ok, np.add.reduce, 0, 0)
 1969:         np.add.reduce([])
 1970:         np.add.reduce(np.zeros((0, 0)), axis=())
 1971: 
 1972:         # OTOH, accumulate always makes sense for any combination of n and m,
 1973:         # because it maps an m-element array to an m-element array. These
 1974:         # tests are simpler because accumulate doesn't accept multiple axes.
 1975:         for uf in (np.maximum, np.add):
 1976:             uf.accumulate(np.zeros((30, 0)), axis=0)
 1977:             uf.accumulate(np.zeros((0, 30)), axis=0)
 1978:             uf.accumulate(np.zeros((30, 30)), axis=0)
 1979:             uf.accumulate(np.zeros((0, 0)), axis=0)
 1980: 
 1981:     def test_safe_casting(self):
 1982:         # In old versions of numpy, in-place operations used the 'unsafe'
 1983:         # casting rules. In versions >= 1.10, 'same_kind' is the
 1984:         # default and an exception is raised instead of a warning.
 1985:         # when 'same_kind' is not satisfied.
 1986:         a = np.array([1, 2, 3], dtype=int)
 1987:         # Non-in-place addition is fine
 1988:         assert_array_equal(assert_no_warnings(np.add, a, 1.1),
 1989:                            [2.1, 3.1, 4.1])
 1990:         assert_raises(TypeError, np.add, a, 1.1, out=a)
 1991: 
 1992:         def add_inplace(a, b):
 1993:             a += b
 1994: 
 1995:         assert_raises(TypeError, add_inplace, a, 1.1)
 1996:         # Make sure that explicitly overriding the exception is allowed:
 1997:         assert_no_warnings(np.add, a, 1.1, out=a, casting="unsafe")
 1998:         assert_array_equal(a, [2, 3, 4])
 1999: 
 2000:     def test_ufunc_custom_out(self):
 2001:         # Test ufunc with built in input types and custom output type
 2002: 
 2003:         a = np.array([0, 1, 2], dtype='i8')
 2004:         b = np.array([0, 1, 2], dtype='i8')
 2005:         c = np.empty(3, dtype=_rational_tests.rational)
 2006: 
 2007:         # Output must be specified so numpy knows what
 2008:         # ufunc signature to look for
 2009:         result = _rational_tests.test_add(a, b, c)
 2010:         target = np.array([0, 2, 4], dtype=_rational_tests.rational)
 2011:         assert_equal(result, target)
 2012: 
 2013:         # The new resolution means that we can (usually) find custom loops
 2014:         # as long as they match exactly:
 2015:         result = _rational_tests.test_add(a, b)
 2016:         assert_equal(result, target)
 2017: 
 2018:         # This works even more generally, so long the default common-dtype
 2019:         # promoter works out:
 2020:         result = _rational_tests.test_add(a, b.astype(np.uint16), out=c)
 2021:         assert_equal(result, target)
 2022: 
 2023:         # This scalar path used to go into legacy promotion, but doesn't now:
 2024:         result = _rational_tests.test_add(a, np.uint16(2))
 2025:         target = np.array([2, 3, 4], dtype=_rational_tests.rational)
 2026:         assert_equal(result, target)
 2027: 
 2028:     def test_operand_flags(self):
 2029:         a = np.arange(16, dtype=int).reshape(4, 4)
 2030:         b = np.arange(9, dtype=int).reshape(3, 3)
 2031:         opflag_tests.inplace_add(a[:-1, :-1], b)
 2032:         assert_equal(a, np.array([[0, 2, 4, 3], [7, 9, 11, 7],
 2033:             [14, 16, 18, 11], [12, 13, 14, 15]]))
 2034: 
 2035:         a = np.array(0)
 2036:         opflag_tests.inplace_add(a, 3)
 2037:         assert_equal(a, 3)
 2038:         opflag_tests.inplace_add(a, [3, 4])
 2039:         assert_equal(a, 10)
 2040: 
 2041:     def test_struct_ufunc(self):
 2042:         import numpy._core._struct_ufunc_tests as struct_ufunc
 2043: 
 2044:         a = np.array([(1, 2, 3)], dtype='u8,u8,u8')
 2045:         b = np.array([(1, 2, 3)], dtype='u8,u8,u8')
 2046: 
 2047:         result = struct_ufunc.add_triplet(a, b)
 2048:         assert_equal(result, np.array([(2, 4, 6)], dtype='u8,u8,u8'))
 2049:         assert_raises(RuntimeError, struct_ufunc.register_fail)
 2050: 
 2051:     def test_custom_ufunc(self):
 2052:         a = np.array(
 2053:             [_rational_tests.rational(1, 2),
 2054:              _rational_tests.rational(1, 3),
 2055:              _rational_tests.rational(1, 4)],
 2056:             dtype=_rational_tests.rational)
 2057:         b = np.array(
 2058:             [_rational_tests.rational(1, 2),
 2059:              _rational_tests.rational(1, 3),
 2060:              _rational_tests.rational(1, 4)],
 2061:             dtype=_rational_tests.rational)
 2062: 
 2063:         result = _rational_tests.test_add_rationals(a, b)
 2064:         expected = np.array(
 2065:             [_rational_tests.rational(1),
 2066:              _rational_tests.rational(2, 3),
 2067:              _rational_tests.rational(1, 2)],
 2068:             dtype=_rational_tests.rational)
 2069:         assert_equal(result, expected)
 2070: 
 2071:     def test_custom_ufunc_forced_sig(self):
 2072:         # gh-9351 - looking for a non-first userloop would previously hang
 2073:         with assert_raises(TypeError):
 2074:             np.multiply(_rational_tests.rational(1), 1,
 2075:                         signature=(_rational_tests.rational, int, None))
 2076: 
 2077:     def test_custom_array_like(self):
 2078: 
 2079:         class MyThing:
 2080:             __array_priority__ = 1000
 2081: 
 2082:             rmul_count = 0
 2083:             getitem_count = 0
 2084: 
 2085:             def __init__(self, shape):
 2086:                 self.shape = shape
 2087: 
 2088:             def __len__(self):
 2089:                 return self.shape[0]
 2090: 
 2091:             def __getitem__(self, i):
 2092:                 MyThing.getitem_count += 1
 2093:                 if not isinstance(i, tuple):
 2094:                     i = (i,)
 2095:                 if len(i) > self.ndim:
 2096:                     raise IndexError("boo")
 2097: 
 2098:                 return MyThing(self.shape[len(i):])
 2099: 
 2100:             def __rmul__(self, other):
 2101:                 MyThing.rmul_count += 1
 2102:                 return self
 2103: 
 2104:         np.float64(5) * MyThing((3, 3))
 2105:         assert_(MyThing.rmul_count == 1, MyThing.rmul_count)
 2106:         assert_(MyThing.getitem_count <= 2, MyThing.getitem_count)
 2107: 
 2108:     def test_array_wrap_array_priority(self):
 2109:         class ArrayPriorityBase(np.ndarray):
 2110:             @classmethod
 2111:             def __array_wrap__(cls, array, context=None, return_scalar=False):
 2112:                 return cls
 2113: 
 2114:         class ArrayPriorityMinus0(ArrayPriorityBase):
 2115:             __array_priority__ = 0
 2116: 
 2117:         class ArrayPriorityMinus1000(ArrayPriorityBase):
 2118:             __array_priority__ = -1000
 2119: 
 2120:         class ArrayPriorityMinus1000b(ArrayPriorityBase):
 2121:             __array_priority__ = -1000
 2122: 
 2123:         class ArrayPriorityMinus2000(ArrayPriorityBase):
 2124:             __array_priority__ = -2000
 2125: 
 2126:         x = np.ones(2).view(ArrayPriorityMinus1000)
 2127:         xb = np.ones(2).view(ArrayPriorityMinus1000b)
 2128:         y = np.ones(2).view(ArrayPriorityMinus2000)
 2129: 
 2130:         assert np.add(x, y) is ArrayPriorityMinus1000
 2131:         assert np.add(y, x) is ArrayPriorityMinus1000
 2132:         assert np.add(x, xb) is ArrayPriorityMinus1000
 2133:         assert np.add(xb, x) is ArrayPriorityMinus1000b
 2134:         y_minus0 = np.zeros(2).view(ArrayPriorityMinus0)
 2135:         assert np.add(np.zeros(2), y_minus0) is ArrayPriorityMinus0
 2136:         assert type(np.add(xb, x, np.zeros(2))) is np.ndarray
 2137: 
 2138:     @pytest.mark.parametrize("a", (
 2139:                              np.arange(10, dtype=int),
 2140:                              np.arange(10, dtype=_rational_tests.rational),
 2141:                              ))
 2142:     def test_ufunc_at_basic(self, a):
 2143: 
 2144:         aa = a.copy()
 2145:         np.add.at(aa, [2, 5, 2], 1)
 2146:         assert_equal(aa, [0, 1, 4, 3, 4, 6, 6, 7, 8, 9])
 2147: 
 2148:         with pytest.raises(ValueError):
 2149:             # missing second operand
 2150:             np.add.at(aa, [2, 5, 3])
 2151: 
 2152:         aa = a.copy()
 2153:         np.negative.at(aa, [2, 5, 3])
 2154:         assert_equal(aa, [0, 1, -2, -3, 4, -5, 6, 7, 8, 9])
 2155: 
 2156:         aa = a.copy()
 2157:         b = np.array([100, 100, 100])
 2158:         np.add.at(aa, [2, 5, 2], b)
 2159:         assert_equal(aa, [0, 1, 202, 3, 4, 105, 6, 7, 8, 9])
 2160: 
 2161:         with pytest.raises(ValueError):
 2162:             # extraneous second operand
 2163:             np.negative.at(a, [2, 5, 3], [1, 2, 3])
 2164: 
 2165:         with pytest.raises(ValueError):
 2166:             # second operand cannot be converted to an array
 2167:             np.add.at(a, [2, 5, 3], [[1, 2], 1])
 2168: 
 2169:     # ufuncs with indexed loops for performance in ufunc.at
 2170:     indexed_ufuncs = [np.add, np.subtract, np.multiply, np.floor_divide,
 2171:                       np.maximum, np.minimum, np.fmax, np.fmin]
 2172: 
 2173:     @pytest.mark.parametrize(
 2174:                 "typecode", np.typecodes['AllInteger'] + np.typecodes['Float'])
 2175:     @pytest.mark.parametrize("ufunc", indexed_ufuncs)
 2176:     def test_ufunc_at_inner_loops(self, typecode, ufunc):
 2177:         if ufunc is np.divide and typecode in np.typecodes['AllInteger']:
 2178:             # Avoid divide-by-zero and inf for integer divide
 2179:             a = np.ones(100, dtype=typecode)
 2180:             indx = np.random.randint(100, size=30, dtype=np.intp)
 2181:             vals = np.arange(1, 31, dtype=typecode)
 2182:         else:
 2183:             a = np.ones(1000, dtype=typecode)
 2184:             indx = np.random.randint(1000, size=3000, dtype=np.intp)
 2185:             vals = np.arange(3000, dtype=typecode)
 2186:         atag = a.copy()
 2187:         # Do the calculation twice and compare the answers
 2188:         with warnings.catch_warnings(record=True) as w_at:
 2189:             warnings.simplefilter('always')
 2190:             ufunc.at(a, indx, vals)
 2191:         with warnings.catch_warnings(record=True) as w_loop:
 2192:             warnings.simplefilter('always')
 2193:             for i, v in zip(indx, vals):
 2194:                 # Make sure all the work happens inside the ufunc
 2195:                 # in order to duplicate error/warning handling
 2196:                 ufunc(atag[i], v, out=atag[i:i + 1], casting="unsafe")
 2197:         assert_equal(atag, a)
 2198:         # If w_loop warned, make sure w_at warned as well
 2199:         if len(w_loop) > 0:
 2200:             #
 2201:             assert len(w_at) > 0
 2202:             assert w_at[0].category == w_loop[0].category
 2203:             assert str(w_at[0].message)[:10] == str(w_loop[0].message)[:10]
 2204: 
 2205:     @pytest.mark.parametrize("typecode", np.typecodes['Complex'])
 2206:     @pytest.mark.parametrize("ufunc", [np.add, np.subtract, np.multiply])
 2207:     def test_ufunc_at_inner_loops_complex(self, typecode, ufunc):
 2208:         a = np.ones(10, dtype=typecode)
 2209:         indx = np.concatenate([np.ones(6, dtype=np.intp),
 2210:                                np.full(18, 4, dtype=np.intp)])
 2211:         value = a.dtype.type(1j)
 2212:         ufunc.at(a, indx, value)
 2213:         expected = np.ones_like(a)
 2214:         if ufunc is np.multiply:
 2215:             expected[1] = expected[4] = -1
 2216:         else:
 2217:             expected[1] += 6 * (value if ufunc is np.add else -value)
 2218:             expected[4] += 18 * (value if ufunc is np.add else -value)
 2219: 
 2220:         assert_array_equal(a, expected)
 2221: 
 2222:     def test_ufunc_at_ellipsis(self):
 2223:         # Make sure the indexed loop check does not choke on iters
 2224:         # with subspaces
 2225:         arr = np.zeros(5)
 2226:         np.add.at(arr, slice(None), np.ones(5))
 2227:         assert_array_equal(arr, np.ones(5))
 2228: 
 2229:     def test_ufunc_at_negative(self):
 2230:         arr = np.ones(5, dtype=np.int32)
 2231:         indx = np.arange(5)
 2232:         umt.indexed_negative.at(arr, indx)
 2233:         # If it is [-1, -1, -1, -100, 0] then the regular strided loop was used
 2234:         assert np.all(arr == [-1, -1, -1, -200, -1])
 2235: 
 2236:     def test_ufunc_at_large(self):
 2237:         # issue gh-23457
 2238:         indices = np.zeros(8195, dtype=np.int16)
 2239:         b = np.zeros(8195, dtype=float)
 2240:         b[0] = 10
 2241:         b[1] = 5
 2242:         b[8192:] = 100
 2243:         a = np.zeros(1, dtype=float)
 2244:         np.add.at(a, indices, b)
 2245:         assert a[0] == b.sum()
 2246: 
 2247:     def test_cast_index_fastpath(self):
 2248:         arr = np.zeros(10)
 2249:         values = np.ones(100000)
 2250:         # index must be cast, which may be buffered in chunks:
 2251:         index = np.zeros(len(values), dtype=np.uint8)
 2252:         np.add.at(arr, index, values)
 2253:         assert arr[0] == len(values)
 2254: 
 2255:     @pytest.mark.parametrize("value", [
 2256:         np.ones(1), np.ones(()), np.float64(1.), 1.])
 2257:     def test_ufunc_at_scalar_value_fastpath(self, value):
 2258:         arr = np.zeros(1000)
 2259:         # index must be cast, which may be buffered in chunks:
 2260:         index = np.repeat(np.arange(1000), 2)
 2261:         np.add.at(arr, index, value)
 2262:         assert_array_equal(arr, np.full_like(arr, 2 * value))
 2263: 
 2264:     def test_ufunc_at_multiD(self):
 2265:         a = np.arange(9).reshape(3, 3)
 2266:         b = np.array([[100, 100, 100], [200, 200, 200], [300, 300, 300]])
 2267:         np.add.at(a, (slice(None), [1, 2, 1]), b)
 2268:         assert_equal(a, [[0, 201, 102], [3, 404, 205], [6, 607, 308]])
 2269: 
 2270:         a = np.arange(27).reshape(3, 3, 3)
 2271:         b = np.array([100, 200, 300])
 2272:         np.add.at(a, (slice(None), slice(None), [1, 2, 1]), b)
 2273:         assert_equal(a,
 2274:             [[[0, 401, 202],
 2275:               [3, 404, 205],
 2276:               [6, 407, 208]],
 2277: 
 2278:              [[9, 410, 211],
 2279:               [12, 413, 214],
 2280:               [15, 416, 217]],
 2281: 
 2282:              [[18, 419, 220],
 2283:               [21, 422, 223],
 2284:               [24, 425, 226]]])
 2285: 
 2286:         a = np.arange(9).reshape(3, 3)
 2287:         b = np.array([[100, 100, 100], [200, 200, 200], [300, 300, 300]])
 2288:         np.add.at(a, ([1, 2, 1], slice(None)), b)
 2289:         assert_equal(a, [[0, 1, 2], [403, 404, 405], [206, 207, 208]])
 2290: 
 2291:         a = np.arange(27).reshape(3, 3, 3)
 2292:         b = np.array([100, 200, 300])
 2293:         np.add.at(a, (slice(None), [1, 2, 1], slice(None)), b)
 2294:         assert_equal(a,
 2295:             [[[0,  1,  2],
 2296:               [203, 404, 605],
 2297:               [106, 207, 308]],
 2298: 
 2299:              [[9,  10, 11],
 2300:               [212, 413, 614],
 2301:               [115, 216, 317]],
 2302: 
 2303:              [[18, 19, 20],
 2304:               [221, 422, 623],
 2305:               [124, 225, 326]]])
 2306: 
 2307:         a = np.arange(9).reshape(3, 3)
 2308:         b = np.array([100, 200, 300])
 2309:         np.add.at(a, (0, [1, 2, 1]), b)
 2310:         assert_equal(a, [[0, 401, 202], [3, 4, 5], [6, 7, 8]])
 2311: 
 2312:         a = np.arange(27).reshape(3, 3, 3)
 2313:         b = np.array([100, 200, 300])
 2314:         np.add.at(a, ([1, 2, 1], 0, slice(None)), b)
 2315:         assert_equal(a,
 2316:             [[[0,  1,  2],
 2317:               [3,  4,  5],
 2318:               [6,  7,  8]],
 2319: 
 2320:              [[209, 410, 611],
 2321:               [12,  13, 14],
 2322:               [15,  16, 17]],
 2323: 
 2324:              [[118, 219, 320],
 2325:               [21,  22, 23],
 2326:               [24,  25, 26]]])
 2327: 
 2328:         a = np.arange(27).reshape(3, 3, 3)
 2329:         b = np.array([100, 200, 300])
 2330:         np.add.at(a, (slice(None), slice(None), slice(None)), b)
 2331:         assert_equal(a,
 2332:             [[[100, 201, 302],
 2333:               [103, 204, 305],
 2334:               [106, 207, 308]],
 2335: 
 2336:              [[109, 210, 311],
 2337:               [112, 213, 314],
 2338:               [115, 216, 317]],
 2339: 
 2340:              [[118, 219, 320],
 2341:               [121, 222, 323],
 2342:               [124, 225, 326]]])
 2343: 
 2344:     def test_ufunc_at_0D(self):
 2345:         a = np.array(0)
 2346:         np.add.at(a, (), 1)
 2347:         assert_equal(a, 1)
 2348: 
 2349:         assert_raises(IndexError, np.add.at, a, 0, 1)
 2350:         assert_raises(IndexError, np.add.at, a, [], 1)
 2351: 
 2352:     def test_ufunc_at_dtypes(self):
 2353:         # Test mixed dtypes
 2354:         a = np.arange(10)
 2355:         np.power.at(a, [1, 2, 3, 2], 3.5)
 2356:         assert_equal(a, np.array([0, 1, 4414, 46, 4, 5, 6, 7, 8, 9]))
 2357: 
 2358:     def test_ufunc_at_boolean(self):
 2359:         # Test boolean indexing and boolean ufuncs
 2360:         a = np.arange(10)
 2361:         index = a % 2 == 0
 2362:         np.equal.at(a, index, [0, 2, 4, 6, 8])
 2363:         assert_equal(a, [1, 1, 1, 3, 1, 5, 1, 7, 1, 9])
 2364: 
 2365:         # Test unary operator
 2366:         a = np.arange(10, dtype='u4')
 2367:         np.invert.at(a, [2, 5, 2])
 2368:         assert_equal(a, [0, 1, 2, 3, 4, 5 ^ 0xffffffff, 6, 7, 8, 9])
 2369: 
 2370:     def test_ufunc_at_advanced(self):
 2371:         # Test empty subspace
 2372:         orig = np.arange(4)
 2373:         a = orig[:, None][:, 0:0]
 2374:         np.add.at(a, [0, 1], 3)
 2375:         assert_array_equal(orig, np.arange(4))
 2376: 
 2377:         # Test with swapped byte order
 2378:         index = np.array([1, 2, 1], np.dtype('i').newbyteorder())
 2379:         values = np.array([1, 2, 3, 4], np.dtype('f').newbyteorder())
 2380:         np.add.at(values, index, 3)
 2381:         assert_array_equal(values, [1, 8, 6, 4])
 2382: 
 2383:         # Test exception thrown
 2384:         values = np.array(['a', 1], dtype=object)
 2385:         assert_raises(TypeError, np.add.at, values, [0, 1], 1)
 2386:         assert_array_equal(values, np.array(['a', 1], dtype=object))
 2387: 
 2388:         # Test multiple output ufuncs raise error, gh-5665
 2389:         assert_raises(ValueError, np.modf.at, np.arange(10), [1])
 2390: 
 2391:         # Test maximum
 2392:         a = np.array([1, 2, 3])
 2393:         np.maximum.at(a, [0], 0)
 2394:         assert_equal(a, np.array([1, 2, 3]))
 2395: 
 2396:     @pytest.mark.parametrize("dtype",
 2397:             np.typecodes['AllInteger'] + np.typecodes['Float'])
 2398:     @pytest.mark.parametrize("ufunc",
 2399:             [np.add, np.subtract, np.divide, np.minimum, np.maximum])
 2400:     def test_at_negative_indexes(self, dtype, ufunc):
 2401:         a = np.arange(0, 10).astype(dtype)
 2402:         indxs = np.array([-1, 1, -1, 2]).astype(np.intp)
 2403:         vals = np.array([1, 5, 2, 10], dtype=a.dtype)
 2404: 
 2405:         expected = a.copy()
 2406:         for i, v in zip(indxs, vals):
 2407:             expected[i] = ufunc(expected[i], v)
 2408: 
 2409:         ufunc.at(a, indxs, vals)
 2410:         assert_array_equal(a, expected)
 2411:         assert np.all(indxs == [-1, 1, -1, 2])
 2412: 
 2413:     def test_at_not_none_signature(self):
 2414:         # Test ufuncs with non-trivial signature raise a TypeError
 2415:         a = np.ones((2, 2, 2))
 2416:         b = np.ones((1, 2, 2))
 2417:         assert_raises(TypeError, np.matmul.at, a, [0], b)
 2418: 
 2419:         a = np.array([[[1, 2], [3, 4]]])
 2420:         assert_raises(TypeError, np.linalg._umath_linalg.det.at, a, [0])
 2421: 
 2422:     def test_at_no_loop_for_op(self):
 2423:         # str dtype does not have a ufunc loop for np.add
 2424:         arr = np.ones(10, dtype=str)
 2425:         with pytest.raises(np._core._exceptions._UFuncNoLoopError):
 2426:             np.add.at(arr, [0, 1], [0, 1])
 2427: 
 2428:     def test_at_output_casting(self):
 2429:         arr = np.array([-1])
 2430:         np.equal.at(arr, [0], [0])
 2431:         assert arr[0] == 0
 2432: 
 2433:     def test_at_broadcast_failure(self):
 2434:         arr = np.arange(5)
 2435:         with pytest.raises(ValueError):
 2436:             np.add.at(arr, [0, 1], [1, 2, 3])
 2437: 
 2438:     def test_reduce_arguments(self):
 2439:         f = np.add.reduce
 2440:         d = np.ones((5, 2), dtype=int)
 2441:         o = np.ones((2,), dtype=d.dtype)
 2442:         r = o * 5
 2443:         assert_equal(f(d), r)
 2444:         # a, axis=0, dtype=None, out=None, keepdims=False
 2445:         assert_equal(f(d, axis=0), r)
 2446:         assert_equal(f(d, 0), r)
 2447:         assert_equal(f(d, 0, dtype=None), r)
 2448:         assert_equal(f(d, 0, dtype='i'), r)
 2449:         assert_equal(f(d, 0, 'i'), r)
 2450:         assert_equal(f(d, 0, None), r)
 2451:         assert_equal(f(d, 0, None, out=None), r)
 2452:         assert_equal(f(d, 0, None, out=o), r)
 2453:         assert_equal(f(d, 0, None, o), r)
 2454:         assert_equal(f(d, 0, None, None), r)
 2455:         assert_equal(f(d, 0, None, None, keepdims=False), r)
 2456:         assert_equal(f(d, 0, None, None, True), r.reshape((1,) + r.shape))
 2457:         assert_equal(f(d, 0, None, None, False, 0), r)
 2458:         assert_equal(f(d, 0, None, None, False, initial=0), r)
 2459:         assert_equal(f(d, 0, None, None, False, 0, True), r)
 2460:         assert_equal(f(d, 0, None, None, False, 0, where=True), r)
 2461:         # multiple keywords
 2462:         assert_equal(f(d, axis=0, dtype=None, out=None, keepdims=False), r)
 2463:         assert_equal(f(d, 0, dtype=None, out=None, keepdims=False), r)
 2464:         assert_equal(f(d, 0, None, out=None, keepdims=False), r)
 2465:         assert_equal(f(d, 0, None, out=None, keepdims=False, initial=0,
 2466:                        where=True), r)
 2467: 
 2468:         # too little
 2469:         assert_raises(TypeError, f)
 2470:         # too much
 2471:         assert_raises(TypeError, f, d, 0, None, None, False, 0, True, 1)
 2472:         # invalid axis
 2473:         assert_raises(TypeError, f, d, "invalid")
 2474:         assert_raises(TypeError, f, d, axis="invalid")
 2475:         assert_raises(TypeError, f, d, axis="invalid", dtype=None,
 2476:                       keepdims=True)
 2477:         # invalid dtype
 2478:         assert_raises(TypeError, f, d, 0, "invalid")
 2479:         assert_raises(TypeError, f, d, dtype="invalid")
 2480:         assert_raises(TypeError, f, d, dtype="invalid", out=None)
 2481:         # invalid out
 2482:         assert_raises(TypeError, f, d, 0, None, "invalid")
 2483:         assert_raises(TypeError, f, d, out="invalid")
 2484:         assert_raises(TypeError, f, d, out="invalid", dtype=None)
 2485:         # keepdims boolean, no invalid value
 2486:         # assert_raises(TypeError, f, d, 0, None, None, "invalid")
 2487:         # assert_raises(TypeError, f, d, keepdims="invalid", axis=0, dtype=None)
 2488:         # invalid mix
 2489:         assert_raises(TypeError, f, d, 0, keepdims="invalid", dtype="invalid",
 2490:                      out=None)
 2491: 
 2492:         # invalid keyword
 2493:         assert_raises(TypeError, f, d, axis=0, dtype=None, invalid=0)
 2494:         assert_raises(TypeError, f, d, invalid=0)
 2495:         assert_raises(TypeError, f, d, 0, keepdims=True, invalid="invalid",
 2496:                       out=None)
 2497:         assert_raises(TypeError, f, d, axis=0, dtype=None, keepdims=True,
 2498:                       out=None, invalid=0)
 2499:         assert_raises(TypeError, f, d, axis=0, dtype=None,
 2500:                       out=None, invalid=0)
 2501: 
 2502:     def test_structured_equal(self):
 2503:         # https://github.com/numpy/numpy/issues/4855
 2504: 
 2505:         class MyA(np.ndarray):
 2506:             def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):
 2507:                 return getattr(ufunc, method)(*(input.view(np.ndarray)
 2508:                                               for input in inputs), **kwargs)
 2509:         a = np.arange(12.).reshape(4, 3)
 2510:         ra = a.view(dtype=('f8,f8,f8')).squeeze()
 2511:         mra = ra.view(MyA)
 2512: 
 2513:         target = np.array([True, False, False, False], dtype=bool)
 2514:         assert_equal(np.all(target == (mra == ra[0])), True)
 2515: 
 2516:     def test_scalar_equal(self):
 2517:         # Scalar comparisons should always work, without deprecation warnings.
 2518:         # even when the ufunc fails.
 2519:         a = np.array(0.)
 2520:         b = np.array('a')
 2521:         assert_(a != b)
 2522:         assert_(b != a)
 2523:         assert_(not (a == b))
 2524:         assert_(not (b == a))
 2525: 
 2526:     def test_NotImplemented_not_returned(self):
 2527:         # See gh-5964 and gh-2091. Some of these functions are not operator
 2528:         # related and were fixed for other reasons in the past.
 2529:         binary_funcs = [
 2530:             np.power, np.add, np.subtract, np.multiply, np.divide,
 2531:             np.true_divide, np.floor_divide, np.bitwise_and, np.bitwise_or,
 2532:             np.bitwise_xor, np.left_shift, np.right_shift, np.fmax,
 2533:             np.fmin, np.fmod, np.hypot, np.logaddexp, np.logaddexp2,
 2534:             np.maximum, np.minimum, np.mod,
 2535:             np.greater, np.greater_equal, np.less, np.less_equal,
 2536:             np.equal, np.not_equal]
 2537: 
 2538:         a = np.array('1')
 2539:         b = 1
 2540:         c = np.array([1., 2.])
 2541:         for f in binary_funcs:
 2542:             assert_raises(TypeError, f, a, b)
 2543:             assert_raises(TypeError, f, c, a)
 2544: 
 2545:     @pytest.mark.parametrize("ufunc",
 2546:              [np.logical_and, np.logical_or])  # logical_xor object loop is bad
 2547:     @pytest.mark.parametrize("signature",
 2548:              [(None, None, object), (object, None, None),
 2549:               (None, object, None)])
 2550:     def test_logical_ufuncs_object_signatures(self, ufunc, signature):
 2551:         a = np.array([True, None, False], dtype=object)
 2552:         res = ufunc(a, a, signature=signature)
 2553:         assert res.dtype == object
 2554: 
 2555:     @pytest.mark.parametrize("ufunc",
 2556:             [np.logical_and, np.logical_or, np.logical_xor])
 2557:     @pytest.mark.parametrize("signature",
 2558:                  [(bool, None, object), (object, None, bool),
 2559:                   (None, object, bool)])
 2560:     def test_logical_ufuncs_mixed_object_signatures(self, ufunc, signature):
 2561:         # Most mixed signatures fail (except those with bool out, e.g. `OO->?`)
 2562:         a = np.array([True, None, False])
 2563:         with pytest.raises(TypeError):
 2564:             ufunc(a, a, signature=signature)
 2565: 
 2566:     @pytest.mark.parametrize("ufunc",
 2567:             [np.logical_and, np.logical_or, np.logical_xor])
 2568:     def test_logical_ufuncs_support_anything(self, ufunc):
 2569:         # The logical ufuncs support even input that can't be promoted:
 2570:         a = np.array(b'1', dtype="V3")
 2571:         c = np.array([1., 2.])
 2572:         assert_array_equal(ufunc(a, c), ufunc([True, True], True))
 2573:         assert ufunc.reduce(a) == True
 2574:         # check that the output has no effect:
 2575:         out = np.zeros(2, dtype=np.int32)
 2576:         expected = ufunc([True, True], True).astype(out.dtype)
 2577:         assert_array_equal(ufunc(a, c, out=out), expected)
 2578:         out = np.zeros((), dtype=np.int32)
 2579:         assert ufunc.reduce(a, out=out) == True
 2580:         # Last check, test reduction when out and a match (the complexity here
 2581:         # is that the "i,i->?" may seem right, but should not match.
 2582:         a = np.array([3], dtype="i")
 2583:         out = np.zeros((), dtype=a.dtype)
 2584:         assert ufunc.reduce(a, out=out) == 1
 2585: 
 2586:     @pytest.mark.parametrize("ufunc",
 2587:             [np.logical_and, np.logical_or, np.logical_xor])
 2588:     @pytest.mark.parametrize("dtype", ["S", "U"])
 2589:     @pytest.mark.parametrize("values", [["1", "hi", "0"], ["", ""]])
 2590:     def test_logical_ufuncs_supports_string(self, ufunc, dtype, values):
 2591:         # note that values are either all true or all false
 2592:         arr = np.array(values, dtype=dtype)
 2593:         obj_arr = np.array(values, dtype=object)
 2594:         res = ufunc(arr, arr)
 2595:         expected = ufunc(obj_arr, obj_arr, dtype=bool)
 2596: 
 2597:         assert_array_equal(res, expected)
 2598: 
 2599:         res = ufunc.reduce(arr)
 2600:         expected = ufunc.reduce(obj_arr, dtype=bool)
 2601:         assert_array_equal(res, expected)
 2602: 
 2603:     @pytest.mark.parametrize("ufunc",
 2604:              [np.logical_and, np.logical_or, np.logical_xor])
 2605:     def test_logical_ufuncs_out_cast_check(self, ufunc):
 2606:         a = np.array('1')
 2607:         c = np.array([1., 2.])
 2608:         out = a.copy()
 2609:         with pytest.raises(TypeError):
 2610:             # It would be safe, but not equiv casting:
 2611:             ufunc(a, c, out=out, casting="equiv")
 2612: 
 2613:     def test_reducelike_byteorder_resolution(self):
 2614:         # See gh-20699, byte-order changes need some extra care in the type
 2615:         # resolution to make the following succeed:
 2616:         arr_be = np.arange(10, dtype=">i8")
 2617:         arr_le = np.arange(10, dtype="<i8")
 2618: 
 2619:         assert np.add.reduce(arr_be) == np.add.reduce(arr_le)
 2620:         assert_array_equal(np.add.accumulate(arr_be), np.add.accumulate(arr_le))
 2621:         assert_array_equal(
 2622:             np.add.reduceat(arr_be, [1]), np.add.reduceat(arr_le, [1]))
 2623: 
 2624:     def test_reducelike_out_promotes(self):
 2625:         # Check that the out argument to reductions is considered for
 2626:         # promotion.  See also gh-20455.
 2627:         # Note that these paths could prefer `initial=` in the future and
 2628:         # do not up-cast to the default integer for add and prod
 2629:         arr = np.ones(1000, dtype=np.uint8)
 2630:         out = np.zeros((), dtype=np.uint16)
 2631:         assert np.add.reduce(arr, out=out) == 1000
 2632:         arr[:10] = 2
 2633:         assert np.multiply.reduce(arr, out=out) == 2**10
 2634: 
 2635:         # For legacy dtypes, the signature currently has to be forced if `out=`
 2636:         # is passed.  The two paths below should differ, without `dtype=` the
 2637:         # expected result should be: `np.prod(arr.astype("f8")).astype("f4")`!
 2638:         arr = np.full(5, 2**25 - 1, dtype=np.int64)
 2639: 
 2640:         # float32 and int64 promote to float64:
 2641:         res = np.zeros((), dtype=np.float32)
 2642:         # If `dtype=` is passed, the calculation is forced to float32:
 2643:         single_res = np.zeros((), dtype=np.float32)
 2644:         np.multiply.reduce(arr, out=single_res, dtype=np.float32)
 2645:         assert single_res != res
 2646: 
 2647:     def test_reducelike_output_needs_identical_cast(self):
 2648:         # Checks the case where a simple byte-swap works, mainly tests that
 2649:         # this is not rejected directly.
 2650:         # (interesting because we require descriptor identity in reducelikes).
 2651:         arr = np.ones(20, dtype="f8")
 2652:         out = np.empty((), dtype=arr.dtype.newbyteorder())
 2653:         expected = np.add.reduce(arr)
 2654:         np.add.reduce(arr, out=out)
 2655:         assert_array_equal(expected, out)
 2656:         # Check reduceat:
 2657:         out = np.empty(2, dtype=arr.dtype.newbyteorder())
 2658:         expected = np.add.reduceat(arr, [0, 1])
 2659:         np.add.reduceat(arr, [0, 1], out=out)
 2660:         assert_array_equal(expected, out)
 2661:         # And accumulate:
 2662:         out = np.empty(arr.shape, dtype=arr.dtype.newbyteorder())
 2663:         expected = np.add.accumulate(arr)
 2664:         np.add.accumulate(arr, out=out)
 2665:         assert_array_equal(expected, out)
 2666: 
 2667:     def test_reduce_noncontig_output(self):
 2668:         # Check that reduction deals with non-contiguous output arrays
 2669:         # appropriately.
 2670:         #
 2671:         # gh-8036
 2672: 
 2673:         x = np.arange(7 * 13 * 8, dtype=np.int16).reshape(7, 13, 8)
 2674:         x = x[4:6, 1:11:6, 1:5].transpose(1, 2, 0)
 2675:         y_base = np.arange(4 * 4, dtype=np.int16).reshape(4, 4)
 2676:         y = y_base[::2, :]
 2677: 
 2678:         y_base_copy = y_base.copy()
 2679: 
 2680:         r0 = np.add.reduce(x, out=y.copy(), axis=2)
 2681:         r1 = np.add.reduce(x, out=y, axis=2)
 2682: 
 2683:         # The results should match, and y_base shouldn't get clobbered
 2684:         assert_equal(r0, r1)
 2685:         assert_equal(y_base[1, :], y_base_copy[1, :])
 2686:         assert_equal(y_base[3, :], y_base_copy[3, :])
 2687: 
 2688:     @pytest.mark.parametrize("with_cast", [True, False])
 2689:     def test_reduceat_and_accumulate_out_shape_mismatch(self, with_cast):
 2690:         # Should raise an error mentioning "shape" or "size"
 2691:         arr = np.arange(5)
 2692:         out = np.arange(3)  # definitely wrong shape
 2693:         if with_cast:
 2694:             # If a cast is necessary on the output, we can be sure to use
 2695:             # the generic NpyIter (non-fast) path.
 2696:             out = out.astype(np.float64)
 2697: 
 2698:         with pytest.raises(ValueError, match="(shape|size)"):
 2699:             np.add.reduceat(arr, [0, 3], out=out)
 2700: 
 2701:         with pytest.raises(ValueError, match="(shape|size)"):
 2702:             np.add.accumulate(arr, out=out)
 2703: 
 2704:     @pytest.mark.parametrize('out_shape',
 2705:                              [(), (1,), (3,), (1, 1), (1, 3), (4, 3)])
 2706:     @pytest.mark.parametrize('keepdims', [True, False])
 2707:     @pytest.mark.parametrize('f_reduce', [np.add.reduce, np.minimum.reduce])
 2708:     def test_reduce_wrong_dimension_output(self, f_reduce, keepdims, out_shape):
 2709:         # Test that we're not incorrectly broadcasting dimensions.
 2710:         # See gh-15144 (failed for np.add.reduce previously).
 2711:         a = np.arange(12.).reshape(4, 3)
 2712:         out = np.empty(out_shape, a.dtype)
 2713: 
 2714:         correct_out = f_reduce(a, axis=0, keepdims=keepdims)
 2715:         if out_shape != correct_out.shape:
 2716:             with assert_raises(ValueError):
 2717:                 f_reduce(a, axis=0, out=out, keepdims=keepdims)
 2718:         else:
 2719:             check = f_reduce(a, axis=0, out=out, keepdims=keepdims)
 2720:             assert_(check is out)
 2721:             assert_array_equal(check, correct_out)
 2722: 
 2723:     def test_reduce_output_does_not_broadcast_input(self):
 2724:         # Test that the output shape cannot broadcast an input dimension
 2725:         # (it never can add dimensions, but it might expand an existing one)
 2726:         a = np.ones((1, 10))
 2727:         out_correct = (np.empty((1, 1)))
 2728:         out_incorrect = np.empty((3, 1))
 2729:         np.add.reduce(a, axis=-1, out=out_correct, keepdims=True)
 2730:         np.add.reduce(a, axis=-1, out=out_correct[:, 0], keepdims=False)
 2731:         with assert_raises(ValueError):
 2732:             np.add.reduce(a, axis=-1, out=out_incorrect, keepdims=True)
 2733:         with assert_raises(ValueError):
 2734:             np.add.reduce(a, axis=-1, out=out_incorrect[:, 0], keepdims=False)
 2735: 
 2736:     def test_reduce_output_subclass_ok(self):
 2737:         class MyArr(np.ndarray):
 2738:             pass
 2739: 
 2740:         out = np.empty(())
 2741:         np.add.reduce(np.ones(5), out=out)  # no subclass, all fine
 2742:         out = out.view(MyArr)
 2743:         assert np.add.reduce(np.ones(5), out=out) is out
 2744:         assert type(np.add.reduce(out)) is MyArr
 2745: 
 2746:     def test_no_doc_string(self):
 2747:         # gh-9337
 2748:         assert_('\n' not in umt.inner1d_no_doc.__doc__)
 2749: 
 2750:     def test_invalid_args(self):
 2751:         # gh-7961
 2752:         exc = pytest.raises(TypeError, np.sqrt, None)
 2753:         # minimally check the exception text
 2754:         assert exc.match('loop of ufunc does not support')
 2755: 
 2756:     @pytest.mark.parametrize('nat', [np.datetime64('nat'), np.timedelta64('nat')])
 2757:     def test_nat_is_not_finite(self, nat):
 2758:         try:
 2759:             assert not np.isfinite(nat)
 2760:         except TypeError:
 2761:             pass  # ok, just not implemented
 2762: 
 2763:     @pytest.mark.parametrize('nat', [np.datetime64('nat'), np.timedelta64('nat')])
 2764:     def test_nat_is_nan(self, nat):
 2765:         try:
 2766:             assert np.isnan(nat)
 2767:         except TypeError:
 2768:             pass  # ok, just not implemented
 2769: 
 2770:     @pytest.mark.parametrize('nat', [np.datetime64('nat'), np.timedelta64('nat')])
 2771:     def test_nat_is_not_inf(self, nat):
 2772:         try:
 2773:             assert not np.isinf(nat)
 2774:         except TypeError:
 2775:             pass  # ok, just not implemented
 2776: 
 2777: 
 2778: class TestGUFuncProcessCoreDims:
 2779: 
 2780:     def test_conv1d_full_without_out(self):
 2781:         x = np.arange(5.0)
 2782:         y = np.arange(13.0)
 2783:         w = umt.conv1d_full(x, y)
 2784:         assert_equal(w, np.convolve(x, y, mode='full'))
 2785: 
 2786:     def test_conv1d_full_with_out(self):
 2787:         x = np.arange(5.0)
 2788:         y = np.arange(13.0)
 2789:         out = np.zeros(len(x) + len(y) - 1)
 2790:         umt.conv1d_full(x, y, out=out)
 2791:         assert_equal(out, np.convolve(x, y, mode='full'))
 2792: 
 2793:     def test_conv1d_full_basic_broadcast(self):
 2794:         # x.shape is (3, 6)
 2795:         x = np.array([[1, 3, 0, -10, 2, 2],
 2796:                       [0, -1, 2, 2, 10, 4],
 2797:                       [8, 9, 10, 2, 23, 3]])
 2798:         # y.shape is (2, 1, 7)
 2799:         y = np.array([[[3, 4, 5, 20, 30, 40, 29]],
 2800:                       [[5, 6, 7, 10, 11, 12, -5]]])
 2801:         # result should have shape (2, 3, 12)
 2802:         result = umt.conv1d_full(x, y)
 2803:         assert result.shape == (2, 3, 12)
 2804:         for i in range(2):
 2805:             for j in range(3):
 2806:                 assert_equal(result[i, j], np.convolve(x[j], y[i, 0]))
 2807: 
 2808:     def test_bad_out_shape(self):
 2809:         x = np.ones((1, 2))
 2810:         y = np.ones((2, 3))
 2811:         out = np.zeros((2, 3))  # Not the correct shape.
 2812:         with pytest.raises(ValueError, match=r'does not equal m \+ n - 1'):
 2813:             umt.conv1d_full(x, y, out=out)
 2814: 
 2815:     def test_bad_input_both_inputs_length_zero(self):
 2816:         with pytest.raises(ValueError,
 2817:                            match='both inputs have core dimension 0'):
 2818:             umt.conv1d_full([], [])
 2819: 
 2820: 
 2821: @pytest.mark.parametrize('ufunc', [getattr(np, x) for x in dir(np)
 2822:                                    if isinstance(getattr(np, x), np.ufunc)])
 2823: def test_ufunc_types(ufunc):
 2824:     '''
 2825:     Check all ufuncs that the correct type is returned. Avoid
 2826:     object and boolean types since many operations are not defined for
 2827:     for them.
 2828: 
 2829:     Choose the shape so even dot and matmul will succeed
 2830:     '''
 2831:     for typ in ufunc.types:
 2832:         # types is a list of strings like ii->i
 2833:         if 'O' in typ or '?' in typ:
 2834:             continue
 2835:         inp, out = typ.split('->')
 2836:         args = [np.ones((3, 3), t) for t in inp]
 2837:         with warnings.catch_warnings(record=True):
 2838:             warnings.filterwarnings("always")
 2839:             res = ufunc(*args)
 2840:         if isinstance(res, tuple):
 2841:             outs = tuple(out)
 2842:             assert len(res) == len(outs)
 2843:             for r, t in zip(res, outs):
 2844:                 assert r.dtype == np.dtype(t)
 2845:         else:
 2846:             assert res.dtype == np.dtype(out)
 2847: 
 2848: @pytest.mark.parametrize('ufunc', [getattr(np, x) for x in dir(np)
 2849:                                 if isinstance(getattr(np, x), np.ufunc)])
 2850: def test_ufunc_noncontiguous(ufunc):
 2851:     '''
 2852:     Check that contiguous and non-contiguous calls to ufuncs
 2853:     have the same results for values in range(9)
 2854:     '''
 2855:     for typ in ufunc.types:
 2856:         # types is a list of strings like ii->i
 2857:         if any(set('O?mM') & set(typ)):
 2858:             # bool, object, datetime are too irregular for this simple test
 2859:             continue
 2860:         inp, out = typ.split('->')
 2861:         args_c = [np.empty((6, 6), t) for t in inp]
 2862:         # non contiguous (2, 3 step on the two dimensions)
 2863:         args_n = [np.empty((12, 18), t)[::2, ::3] for t in inp]
 2864:         # alignment != itemsize is possible.  So create an array with such
 2865:         # an odd step manually.
 2866:         args_o = []
 2867:         for t in inp:
 2868:             orig_dt = np.dtype(t)
 2869:             off_dt = f"S{orig_dt.alignment}"  # offset by alignment
 2870:             dtype = np.dtype([("_", off_dt), ("t", orig_dt)], align=False)
 2871:             args_o.append(np.empty((6, 6), dtype=dtype)["t"])
 2872:         for a in args_c + args_n + args_o:
 2873:             a.flat = range(1, 37)
 2874: 
 2875:         with warnings.catch_warnings(record=True):
 2876:             warnings.filterwarnings("always")
 2877:             res_c = ufunc(*args_c)
 2878:             res_n = ufunc(*args_n)
 2879:             res_o = ufunc(*args_o)
 2880:         if len(out) == 1:
 2881:             res_c = (res_c,)
 2882:             res_n = (res_n,)
 2883:             res_o = (res_o,)
 2884:         for c_ar, n_ar, o_ar in zip(res_c, res_n, res_o):
 2885:             dt = c_ar.dtype
 2886:             if np.issubdtype(dt, np.floating):
 2887:                 # for floating point results allow a small fuss in comparisons
 2888:                 # since different algorithms (libm vs. intrinsics) can be used
 2889:                 # for different input strides
 2890:                 res_eps = np.finfo(dt).eps
 2891:                 tol = 3 * res_eps
 2892:                 assert_allclose(res_c, res_n, atol=tol, rtol=tol)
 2893:                 assert_allclose(res_c, res_o, atol=tol, rtol=tol)
 2894:             else:
 2895:                 assert_equal(c_ar, n_ar)
 2896:                 assert_equal(c_ar, o_ar)
 2897: 
 2898: 
 2899: @pytest.mark.parametrize('ufunc', [np.sign, np.equal])
 2900: def test_ufunc_warn_with_nan(ufunc):
 2901:     # issue gh-15127
 2902:     # test that calling certain ufuncs with a non-standard `nan` value does not
 2903:     # emit a warning
 2904:     # `b` holds a 64 bit signaling nan: the most significant bit of the
 2905:     # significand is zero.
 2906:     b = np.array([0x7ff0000000000001], 'i8').view('f8')
 2907:     assert np.isnan(b)
 2908:     if ufunc.nin == 1:
 2909:         ufunc(b)
 2910:     elif ufunc.nin == 2:
 2911:         ufunc(b, b.copy())
 2912:     else:
 2913:         raise ValueError('ufunc with more than 2 inputs')
 2914: 
 2915: 
 2916: @pytest.mark.skipif(not HAS_REFCOUNT, reason="Python lacks refcounts")
 2917: def test_ufunc_out_casterrors():
 2918:     # Tests that casting errors are correctly reported and buffers are
 2919:     # cleared.
 2920:     # The following array can be added to itself as an object array, but
 2921:     # the result cannot be cast to an integer output:
 2922:     value = 123  # relies on python cache (leak-check will still find it)
 2923:     arr = np.array([value] * int(ncu.BUFSIZE * 1.5) +
 2924:                    ["string"] +
 2925:                    [value] * int(1.5 * ncu.BUFSIZE), dtype=object)
 2926:     out = np.ones(len(arr), dtype=np.intp)
 2927: 
 2928:     count = sys.getrefcount(value)
 2929:     with pytest.raises(ValueError):
 2930:         # Output casting failure:
 2931:         np.add(arr, arr, out=out, casting="unsafe")
 2932: 
 2933:     assert count == sys.getrefcount(value)
 2934:     # output is unchanged after the error, this shows that the iteration
 2935:     # was aborted (this is not necessarily defined behaviour)
 2936:     assert out[-1] == 1
 2937: 
 2938:     with pytest.raises(ValueError):
 2939:         # Input casting failure:
 2940:         np.add(arr, arr, out=out, dtype=np.intp, casting="unsafe")
 2941: 
 2942:     assert count == sys.getrefcount(value)
 2943:     # output is unchanged after the error, this shows that the iteration
 2944:     # was aborted (this is not necessarily defined behaviour)
 2945:     assert out[-1] == 1
 2946: 
 2947: 
 2948: @pytest.mark.parametrize("bad_offset", [0, int(ncu.BUFSIZE * 1.5)])
 2949: def test_ufunc_input_casterrors(bad_offset):
 2950:     value = 123
 2951:     arr = np.array([value] * bad_offset +
 2952:                    ["string"] +
 2953:                    [value] * int(1.5 * ncu.BUFSIZE), dtype=object)
 2954:     with pytest.raises(ValueError):
 2955:         # Force cast inputs, but the buffered cast of `arr` to intp fails:
 2956:         np.add(arr, arr, dtype=np.intp, casting="unsafe")
 2957: 
 2958: 
 2959: @pytest.mark.skipif(IS_WASM, reason="fp errors don't work in wasm")
 2960: @pytest.mark.parametrize("bad_offset", [0, int(ncu.BUFSIZE * 1.5)])
 2961: def test_ufunc_input_floatingpoint_error(bad_offset):
 2962:     value = 123
 2963:     arr = np.array([value] * bad_offset +
 2964:                    [np.nan] +
 2965:                    [value] * int(1.5 * ncu.BUFSIZE))
 2966:     with np.errstate(invalid="raise"), pytest.raises(FloatingPointError):
 2967:         # Force cast inputs, but the buffered cast of `arr` to intp fails:
 2968:         np.add(arr, arr, dtype=np.intp, casting="unsafe")
 2969: 
 2970: 
 2971: def test_trivial_loop_invalid_cast():
 2972:     # This tests the fast-path "invalid cast", see gh-19904.
 2973:     with pytest.raises(TypeError,
 2974:             match="cast ufunc 'add' input 0"):
 2975:         # the void dtype definitely cannot cast to double:
 2976:         np.add(np.array(1, "i,i"), 3, signature="dd->d")
 2977: 
 2978: 
 2979: @pytest.mark.skipif(not HAS_REFCOUNT, reason="Python lacks refcounts")
 2980: @pytest.mark.parametrize("offset",
 2981:         [0, ncu.BUFSIZE // 2, int(1.5 * ncu.BUFSIZE)])
 2982: def test_reduce_casterrors(offset):
 2983:     # Test reporting of casting errors in reductions, we test various
 2984:     # offsets to where the casting error will occur, since these may occur
 2985:     # at different places during the reduction procedure. For example
 2986:     # the first item may be special.
 2987:     value = 123  # relies on python cache (leak-check will still find it)
 2988:     arr = np.array([value] * offset +
 2989:                    ["string"] +
 2990:                    [value] * int(1.5 * ncu.BUFSIZE), dtype=object)
 2991:     out = np.array(-1, dtype=np.intp)
 2992: 
 2993:     count = sys.getrefcount(value)
 2994:     with pytest.raises(ValueError, match="invalid literal"):
 2995:         # This is an unsafe cast, but we currently always allow that.
 2996:         # Note that the double loop is picked, but the cast fails.
 2997:         # `initial=None` disables the use of an identity here to test failures
 2998:         # while copying the first values path (not used when identity exists).
 2999:         np.add.reduce(arr, dtype=np.intp, out=out, initial=None)
 3000:     assert count == sys.getrefcount(value)
 3001:     # If an error occurred during casting, the operation is done at most until
 3002:     # the error occurs (the result of which would be `value * offset`) and -1
 3003:     # if the error happened immediately.
 3004:     # This does not define behaviour, the output is invalid and thus undefined
 3005:     assert out[()] < value * offset
 3006: 
 3007: 
 3008: @pytest.mark.skipif(not HAS_REFCOUNT, reason="Python lacks refcounts")
 3009: def test_reduction_no_reference_leak():
 3010:     # Test that the generic reduction does not leak references.
 3011:     # gh-29358
 3012:     arr = np.array([1, 2, 3], dtype=np.int32)
 3013:     count = sys.getrefcount(arr)
 3014: 
 3015:     np.add.reduce(arr, dtype=np.int32, initial=0)
 3016:     assert count == sys.getrefcount(arr)
 3017: 
 3018:     np.add.accumulate(arr, dtype=np.int32)
 3019:     assert count == sys.getrefcount(arr)
 3020: 
 3021:     np.add.reduceat(arr, [0, 1], dtype=np.int32)
 3022:     assert count == sys.getrefcount(arr)
 3023: 
 3024:     # with `out=` the reference count is not changed
 3025:     out = np.empty((), dtype=np.int32)
 3026:     out_count = sys.getrefcount(out)
 3027: 
 3028:     np.add.reduce(arr, dtype=np.int32, out=out, initial=0)
 3029:     assert count == sys.getrefcount(arr)
 3030:     assert out_count == sys.getrefcount(out)
 3031: 
 3032:     out = np.empty(arr.shape, dtype=np.int32)
 3033:     out_count = sys.getrefcount(out)
 3034: 
 3035:     np.add.accumulate(arr, dtype=np.int32, out=out)
 3036:     assert count == sys.getrefcount(arr)
 3037:     assert out_count == sys.getrefcount(out)
 3038: 
 3039:     out = np.empty((2,), dtype=np.int32)
 3040:     out_count = sys.getrefcount(out)
 3041: 
 3042:     np.add.reduceat(arr, [0, 1], dtype=np.int32, out=out)
 3043:     assert count == sys.getrefcount(arr)
 3044:     assert out_count == sys.getrefcount(out)
 3045: 
 3046: 
 3047: def test_object_reduce_cleanup_on_failure():
 3048:     # Test cleanup, including of the initial value (manually provided or not)
 3049:     with pytest.raises(TypeError):
 3050:         np.add.reduce([1, 2, None], initial=4)
 3051: 
 3052:     with pytest.raises(TypeError):
 3053:         np.add.reduce([1, 2, None])
 3054: 
 3055: 
 3056: @pytest.mark.skipif(IS_WASM, reason="fp errors don't work in wasm")
 3057: @pytest.mark.parametrize("method",
 3058:         [np.add.accumulate, np.add.reduce,
 3059:          pytest.param(lambda x: np.add.reduceat(x, [0]), id="reduceat"),
 3060:          pytest.param(lambda x: np.log.at(x, [2]), id="at")])
 3061: def test_ufunc_methods_floaterrors(method):
 3062:     # adding inf and -inf (or log(-inf) creates an invalid float and warns
 3063:     arr = np.array([np.inf, 0, -np.inf])
 3064:     with np.errstate(all="warn"):
 3065:         with pytest.warns(RuntimeWarning, match="invalid value"):
 3066:             method(arr)
 3067: 
 3068:     arr = np.array([np.inf, 0, -np.inf])
 3069:     with np.errstate(all="raise"):
 3070:         with pytest.raises(FloatingPointError):
 3071:             method(arr)
 3072: 
 3073: 
 3074: def _check_neg_zero(value):
 3075:     if value != 0.0:
 3076:         return False
 3077:     if not np.signbit(value.real):
 3078:         return False
 3079:     if value.dtype.kind == "c":
 3080:         return np.signbit(value.imag)
 3081:     return True
 3082: 
 3083: @pytest.mark.parametrize("dtype", np.typecodes["AllFloat"])
 3084: def test_addition_negative_zero(dtype):
 3085:     dtype = np.dtype(dtype)
 3086:     if dtype.kind == "c":
 3087:         neg_zero = dtype.type(complex(-0.0, -0.0))
 3088:     else:
 3089:         neg_zero = dtype.type(-0.0)
 3090: 
 3091:     arr = np.array(neg_zero)
 3092:     arr2 = np.array(neg_zero)
 3093: 
 3094:     assert _check_neg_zero(arr + arr2)
 3095:     # In-place ops may end up on a different path (reduce path) see gh-21211
 3096:     arr += arr2
 3097:     assert _check_neg_zero(arr)
 3098: 
 3099: 
 3100: @pytest.mark.parametrize("dtype", np.typecodes["AllFloat"])
 3101: @pytest.mark.parametrize("use_initial", [True, False])
 3102: def test_addition_reduce_negative_zero(dtype, use_initial):
 3103:     dtype = np.dtype(dtype)
 3104:     if dtype.kind == "c":
 3105:         neg_zero = dtype.type(complex(-0.0, -0.0))
 3106:     else:
 3107:         neg_zero = dtype.type(-0.0)
 3108: 
 3109:     kwargs = {}
 3110:     if use_initial:
 3111:         kwargs["initial"] = neg_zero
 3112:     else:
 3113:         pytest.xfail("-0. propagation in sum currently requires initial")
 3114: 
 3115:     # Test various length, in case SIMD paths or chunking play a role.
 3116:     # 150 extends beyond the pairwise blocksize; probably not important.
 3117:     for i in range(150):
 3118:         arr = np.array([neg_zero] * i, dtype=dtype)
 3119:         res = np.sum(arr, **kwargs)
 3120:         if i > 0 or use_initial:
 3121:             assert _check_neg_zero(res)
 3122:         else:
 3123:             # `sum([])` should probably be 0.0 and not -0.0 like `sum([-0.0])`
 3124:             assert not np.signbit(res.real)
 3125:             assert not np.signbit(res.imag)
 3126: 
 3127: 
 3128: @pytest.mark.parametrize(["dt1", "dt2"],
 3129:         [("S", "U"), ("U", "S"), ("S", "d"), ("S", "V"), ("U", "l")])
 3130: def test_addition_string_types(dt1, dt2):
 3131:     arr1 = np.array([1234234], dtype=dt1)
 3132:     arr2 = np.array([b"423"], dtype=dt2)
 3133:     with pytest.raises(np._core._exceptions.UFuncTypeError) as exc:
 3134:         np.add(arr1, arr2)
 3135: 
 3136: 
 3137: @pytest.mark.parametrize("order1,order2",
 3138:                          [(">", ">"), ("<", "<"), (">", "<"), ("<", ">")])
 3139: def test_addition_unicode_inverse_byte_order(order1, order2):
 3140:     element = 'abcd'
 3141:     arr1 = np.array([element], dtype=f"{order1}U4")
 3142:     arr2 = np.array([element], dtype=f"{order2}U4")
 3143:     result = arr1 + arr2
 3144:     assert result == 2 * element
 3145: 
 3146: 
 3147: @pytest.mark.parametrize("dtype", [np.int8, np.int16, np.int32, np.int64])
 3148: def test_find_non_long_args(dtype):
 3149:     element = 'abcd'
 3150:     start = dtype(0)
 3151:     end = dtype(len(element))
 3152:     arr = np.array([element])
 3153:     result = np._core.umath.find(arr, "a", start, end)
 3154:     assert result.dtype == np.dtype("intp")
 3155:     assert result == 0
 3156: 
 3157: 
 3158: def test_find_access_past_buffer():
 3159:     # This checks that no read past the string buffer occurs in
 3160:     # string_fastsearch.h. The buffer class makes sure this is checked.
 3161:     # To see it in action, you can remove the checks in the buffer and
 3162:     # this test will produce an 'Invalid read' if run under valgrind.
 3163:     arr = np.array([b'abcd', b'ebcd'])
 3164:     result = np._core.umath.find(arr, b'cde', 0, np.iinfo(np.int64).max)
 3165:     assert np.all(result == -1)
 3166: 
 3167: 
 3168: class TestLowlevelAPIAccess:
 3169:     def test_resolve_dtypes_basic(self):
 3170:         # Basic test for dtype resolution:
 3171:         i4 = np.dtype("i4")
 3172:         f4 = np.dtype("f4")
 3173:         f8 = np.dtype("f8")
 3174: 
 3175:         r = np.add.resolve_dtypes((i4, f4, None))
 3176:         assert r == (f8, f8, f8)
 3177: 
 3178:         # Signature uses the same logic to parse as ufunc (less strict)
 3179:         # the following is "same-kind" casting so works:
 3180:         r = np.add.resolve_dtypes((
 3181:                 i4, i4, None), signature=(None, None, "f4"))
 3182:         assert r == (f4, f4, f4)
 3183: 
 3184:         # Check NEP 50 "weak" promotion also:
 3185:         r = np.add.resolve_dtypes((f4, int, None))
 3186:         assert r == (f4, f4, f4)
 3187: 
 3188:         with pytest.raises(TypeError):
 3189:             np.add.resolve_dtypes((i4, f4, None), casting="no")
 3190: 
 3191:     def test_resolve_dtypes_comparison(self):
 3192:         i4 = np.dtype("i4")
 3193:         i8 = np.dtype("i8")
 3194:         b = np.dtype("?")
 3195:         r = np.equal.resolve_dtypes((i4, i8, None))
 3196:         assert r == (i8, i8, b)
 3197: 
 3198:     def test_weird_dtypes(self):
 3199:         S0 = np.dtype("S0")
 3200:         # S0 is often converted by NumPy to S1, but not here:
 3201:         r = np.equal.resolve_dtypes((S0, S0, None))
 3202:         assert r == (S0, S0, np.dtype(bool))
 3203: 
 3204:         # Subarray dtypes are weird and may not work fully, we preserve them
 3205:         # leading to a TypeError (currently no equal loop for void/structured)
 3206:         dts = np.dtype("10i")
 3207:         with pytest.raises(TypeError):
 3208:             np.equal.resolve_dtypes((dts, dts, None))
 3209: 
 3210:     def test_resolve_dtypes_reduction(self):
 3211:         i2 = np.dtype("i2")
 3212:         default_int_ = np.dtype(np.int_)
 3213:         # Check special addition resolution:
 3214:         res = np.add.resolve_dtypes((None, i2, None), reduction=True)
 3215:         assert res == (default_int_, default_int_, default_int_)
 3216: 
 3217:     def test_resolve_dtypes_reduction_no_output(self):
 3218:         i4 = np.dtype("i4")
 3219:         with pytest.raises(TypeError):
 3220:             # May be allowable at some point?
 3221:             np.add.resolve_dtypes((i4, i4, i4), reduction=True)
 3222: 
 3223:     @pytest.mark.parametrize("dtypes", [
 3224:             (np.dtype("i"), np.dtype("i")),
 3225:             (None, np.dtype("i"), np.dtype("f")),
 3226:             (np.dtype("i"), None, np.dtype("f")),
 3227:             ("i4", "i4", None)])
 3228:     def test_resolve_dtypes_errors(self, dtypes):
 3229:         with pytest.raises(TypeError):
 3230:             np.add.resolve_dtypes(dtypes)
 3231: 
 3232:     def test_resolve_dtypes_reduction_errors(self):
 3233:         i2 = np.dtype("i2")
 3234: 
 3235:         with pytest.raises(TypeError):
 3236:             np.add.resolve_dtypes((None, i2, i2))
 3237: 
 3238:         with pytest.raises(TypeError):
 3239:             np.add.signature((None, None, "i4"))
 3240: 
 3241:     @pytest.mark.skipif(not hasattr(ct, "pythonapi"),
 3242:             reason="`ctypes.pythonapi` required for capsule unpacking.")
 3243:     def test_loop_access(self):
 3244:         # This is a basic test for the full strided loop access
 3245:         data_t = ct.c_char_p * 2
 3246:         dim_t = ct.c_ssize_t * 1
 3247:         strides_t = ct.c_ssize_t * 2
 3248:         strided_loop_t = ct.CFUNCTYPE(
 3249:                 ct.c_int, ct.c_void_p, data_t, dim_t, strides_t, ct.c_void_p)
 3250: 
 3251:         class call_info_t(ct.Structure):
 3252:             _fields_ = [
 3253:                 ("strided_loop", strided_loop_t),
 3254:                 ("context", ct.c_void_p),
 3255:                 ("auxdata", ct.c_void_p),
 3256:                 ("requires_pyapi", ct.c_byte),
 3257:                 ("no_floatingpoint_errors", ct.c_byte),
 3258:             ]
 3259: 
 3260:         i4 = np.dtype("i4")
 3261:         dt, call_info_obj = np.negative._resolve_dtypes_and_context((i4, i4))
 3262:         assert dt == (i4, i4)  # can be used without casting
 3263: 
 3264:         # Fill in the rest of the information:
 3265:         np.negative._get_strided_loop(call_info_obj)
 3266: 
 3267:         ct.pythonapi.PyCapsule_GetPointer.restype = ct.c_void_p
 3268:         call_info = ct.pythonapi.PyCapsule_GetPointer(
 3269:                 ct.py_object(call_info_obj),
 3270:                 ct.c_char_p(b"numpy_1.24_ufunc_call_info"))
 3271: 
 3272:         call_info = ct.cast(call_info, ct.POINTER(call_info_t)).contents
 3273: 
 3274:         arr = np.arange(10, dtype=i4)
 3275:         call_info.strided_loop(
 3276:                 call_info.context,
 3277:                 data_t(arr.ctypes.data, arr.ctypes.data),
 3278:                 arr.ctypes.shape,  # is a C-array with 10 here
 3279:                 strides_t(arr.ctypes.strides[0], arr.ctypes.strides[0]),
 3280:                 call_info.auxdata)
 3281: 
 3282:         # We just directly called the negative inner-loop in-place:
 3283:         assert_array_equal(arr, -np.arange(10, dtype=i4))
 3284: 
 3285:     @pytest.mark.parametrize("strides", [1, (1, 2, 3), (1, "2")])
 3286:     def test__get_strided_loop_errors_bad_strides(self, strides):
 3287:         i4 = np.dtype("i4")
 3288:         dt, call_info = np.negative._resolve_dtypes_and_context((i4, i4))
 3289: 
 3290:         with pytest.raises(TypeError, match="fixed_strides.*tuple.*or None"):
 3291:             np.negative._get_strided_loop(call_info, fixed_strides=strides)
 3292: 
 3293:     def test__get_strided_loop_errors_bad_call_info(self):
 3294:         i4 = np.dtype("i4")
 3295:         dt, call_info = np.negative._resolve_dtypes_and_context((i4, i4))
 3296: 
 3297:         with pytest.raises(ValueError, match="PyCapsule"):
 3298:             np.negative._get_strided_loop("not the capsule!")
 3299: 
 3300:         with pytest.raises(TypeError, match=".*incompatible context"):
 3301:             np.add._get_strided_loop(call_info)
 3302: 
 3303:         np.negative._get_strided_loop(call_info)
 3304:         with pytest.raises(TypeError):
 3305:             # cannot call it a second time:
 3306:             np.negative._get_strided_loop(call_info)
 3307: 
 3308:     def test_long_arrays(self):
 3309:         t = np.zeros((1029, 917), dtype=np.single)
 3310:         t[0][0] = 1
 3311:         t[28][414] = 1
 3312:         tc = np.cos(t)
 3313:         assert_equal(tc[0][0], tc[28][414])
