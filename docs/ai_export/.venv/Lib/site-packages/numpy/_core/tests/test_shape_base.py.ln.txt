    1: import sys
    2: 
    3: import pytest
    4: 
    5: import numpy as np
    6: from numpy._core import (
    7:     arange,
    8:     array,
    9:     atleast_1d,
   10:     atleast_2d,
   11:     atleast_3d,
   12:     block,
   13:     concatenate,
   14:     hstack,
   15:     newaxis,
   16:     stack,
   17:     vstack,
   18: )
   19: from numpy._core.shape_base import (
   20:     _block_concatenate,
   21:     _block_dispatcher,
   22:     _block_setup,
   23:     _block_slicing,
   24: )
   25: from numpy.exceptions import AxisError
   26: from numpy.testing import (
   27:     IS_PYPY,
   28:     assert_,
   29:     assert_array_equal,
   30:     assert_equal,
   31:     assert_raises,
   32:     assert_raises_regex,
   33: )
   34: from numpy.testing._private.utils import requires_memory
   35: 
   36: 
   37: class TestAtleast1d:
   38:     def test_0D_array(self):
   39:         a = array(1)
   40:         b = array(2)
   41:         res = [atleast_1d(a), atleast_1d(b)]
   42:         desired = [array([1]), array([2])]
   43:         assert_array_equal(res, desired)
   44: 
   45:     def test_1D_array(self):
   46:         a = array([1, 2])
   47:         b = array([2, 3])
   48:         res = [atleast_1d(a), atleast_1d(b)]
   49:         desired = [array([1, 2]), array([2, 3])]
   50:         assert_array_equal(res, desired)
   51: 
   52:     def test_2D_array(self):
   53:         a = array([[1, 2], [1, 2]])
   54:         b = array([[2, 3], [2, 3]])
   55:         res = [atleast_1d(a), atleast_1d(b)]
   56:         desired = [a, b]
   57:         assert_array_equal(res, desired)
   58: 
   59:     def test_3D_array(self):
   60:         a = array([[1, 2], [1, 2]])
   61:         b = array([[2, 3], [2, 3]])
   62:         a = array([a, a])
   63:         b = array([b, b])
   64:         res = [atleast_1d(a), atleast_1d(b)]
   65:         desired = [a, b]
   66:         assert_array_equal(res, desired)
   67: 
   68:     def test_r1array(self):
   69:         """ Test to make sure equivalent Travis O's r1array function
   70:         """
   71:         assert_(atleast_1d(3).shape == (1,))
   72:         assert_(atleast_1d(3j).shape == (1,))
   73:         assert_(atleast_1d(3.0).shape == (1,))
   74:         assert_(atleast_1d([[2, 3], [4, 5]]).shape == (2, 2))
   75: 
   76: 
   77: class TestAtleast2d:
   78:     def test_0D_array(self):
   79:         a = array(1)
   80:         b = array(2)
   81:         res = [atleast_2d(a), atleast_2d(b)]
   82:         desired = [array([[1]]), array([[2]])]
   83:         assert_array_equal(res, desired)
   84: 
   85:     def test_1D_array(self):
   86:         a = array([1, 2])
   87:         b = array([2, 3])
   88:         res = [atleast_2d(a), atleast_2d(b)]
   89:         desired = [array([[1, 2]]), array([[2, 3]])]
   90:         assert_array_equal(res, desired)
   91: 
   92:     def test_2D_array(self):
   93:         a = array([[1, 2], [1, 2]])
   94:         b = array([[2, 3], [2, 3]])
   95:         res = [atleast_2d(a), atleast_2d(b)]
   96:         desired = [a, b]
   97:         assert_array_equal(res, desired)
   98: 
   99:     def test_3D_array(self):
  100:         a = array([[1, 2], [1, 2]])
  101:         b = array([[2, 3], [2, 3]])
  102:         a = array([a, a])
  103:         b = array([b, b])
  104:         res = [atleast_2d(a), atleast_2d(b)]
  105:         desired = [a, b]
  106:         assert_array_equal(res, desired)
  107: 
  108:     def test_r2array(self):
  109:         """ Test to make sure equivalent Travis O's r2array function
  110:         """
  111:         assert_(atleast_2d(3).shape == (1, 1))
  112:         assert_(atleast_2d([3j, 1]).shape == (1, 2))
  113:         assert_(atleast_2d([[[3, 1], [4, 5]], [[3, 5], [1, 2]]]).shape == (2, 2, 2))
  114: 
  115: 
  116: class TestAtleast3d:
  117:     def test_0D_array(self):
  118:         a = array(1)
  119:         b = array(2)
  120:         res = [atleast_3d(a), atleast_3d(b)]
  121:         desired = [array([[[1]]]), array([[[2]]])]
  122:         assert_array_equal(res, desired)
  123: 
  124:     def test_1D_array(self):
  125:         a = array([1, 2])
  126:         b = array([2, 3])
  127:         res = [atleast_3d(a), atleast_3d(b)]
  128:         desired = [array([[[1], [2]]]), array([[[2], [3]]])]
  129:         assert_array_equal(res, desired)
  130: 
  131:     def test_2D_array(self):
  132:         a = array([[1, 2], [1, 2]])
  133:         b = array([[2, 3], [2, 3]])
  134:         res = [atleast_3d(a), atleast_3d(b)]
  135:         desired = [a[:, :, newaxis], b[:, :, newaxis]]
  136:         assert_array_equal(res, desired)
  137: 
  138:     def test_3D_array(self):
  139:         a = array([[1, 2], [1, 2]])
  140:         b = array([[2, 3], [2, 3]])
  141:         a = array([a, a])
  142:         b = array([b, b])
  143:         res = [atleast_3d(a), atleast_3d(b)]
  144:         desired = [a, b]
  145:         assert_array_equal(res, desired)
  146: 
  147: 
  148: class TestHstack:
  149:     def test_non_iterable(self):
  150:         assert_raises(TypeError, hstack, 1)
  151: 
  152:     def test_empty_input(self):
  153:         assert_raises(ValueError, hstack, ())
  154: 
  155:     def test_0D_array(self):
  156:         a = array(1)
  157:         b = array(2)
  158:         res = hstack([a, b])
  159:         desired = array([1, 2])
  160:         assert_array_equal(res, desired)
  161: 
  162:     def test_1D_array(self):
  163:         a = array([1])
  164:         b = array([2])
  165:         res = hstack([a, b])
  166:         desired = array([1, 2])
  167:         assert_array_equal(res, desired)
  168: 
  169:     def test_2D_array(self):
  170:         a = array([[1], [2]])
  171:         b = array([[1], [2]])
  172:         res = hstack([a, b])
  173:         desired = array([[1, 1], [2, 2]])
  174:         assert_array_equal(res, desired)
  175: 
  176:     def test_generator(self):
  177:         with pytest.raises(TypeError, match="arrays to stack must be"):
  178:             hstack(np.arange(3) for _ in range(2))
  179:         with pytest.raises(TypeError, match="arrays to stack must be"):
  180:             hstack(x for x in np.ones((3, 2)))
  181: 
  182:     def test_casting_and_dtype(self):
  183:         a = np.array([1, 2, 3])
  184:         b = np.array([2.5, 3.5, 4.5])
  185:         res = np.hstack((a, b), casting="unsafe", dtype=np.int64)
  186:         expected_res = np.array([1, 2, 3, 2, 3, 4])
  187:         assert_array_equal(res, expected_res)
  188: 
  189:     def test_casting_and_dtype_type_error(self):
  190:         a = np.array([1, 2, 3])
  191:         b = np.array([2.5, 3.5, 4.5])
  192:         with pytest.raises(TypeError):
  193:             hstack((a, b), casting="safe", dtype=np.int64)
  194: 
  195: 
  196: class TestVstack:
  197:     def test_non_iterable(self):
  198:         assert_raises(TypeError, vstack, 1)
  199: 
  200:     def test_empty_input(self):
  201:         assert_raises(ValueError, vstack, ())
  202: 
  203:     def test_0D_array(self):
  204:         a = array(1)
  205:         b = array(2)
  206:         res = vstack([a, b])
  207:         desired = array([[1], [2]])
  208:         assert_array_equal(res, desired)
  209: 
  210:     def test_1D_array(self):
  211:         a = array([1])
  212:         b = array([2])
  213:         res = vstack([a, b])
  214:         desired = array([[1], [2]])
  215:         assert_array_equal(res, desired)
  216: 
  217:     def test_2D_array(self):
  218:         a = array([[1], [2]])
  219:         b = array([[1], [2]])
  220:         res = vstack([a, b])
  221:         desired = array([[1], [2], [1], [2]])
  222:         assert_array_equal(res, desired)
  223: 
  224:     def test_2D_array2(self):
  225:         a = array([1, 2])
  226:         b = array([1, 2])
  227:         res = vstack([a, b])
  228:         desired = array([[1, 2], [1, 2]])
  229:         assert_array_equal(res, desired)
  230: 
  231:     def test_generator(self):
  232:         with pytest.raises(TypeError, match="arrays to stack must be"):
  233:             vstack(np.arange(3) for _ in range(2))
  234: 
  235:     def test_casting_and_dtype(self):
  236:         a = np.array([1, 2, 3])
  237:         b = np.array([2.5, 3.5, 4.5])
  238:         res = np.vstack((a, b), casting="unsafe", dtype=np.int64)
  239:         expected_res = np.array([[1, 2, 3], [2, 3, 4]])
  240:         assert_array_equal(res, expected_res)
  241: 
  242:     def test_casting_and_dtype_type_error(self):
  243:         a = np.array([1, 2, 3])
  244:         b = np.array([2.5, 3.5, 4.5])
  245:         with pytest.raises(TypeError):
  246:             vstack((a, b), casting="safe", dtype=np.int64)
  247: 
  248: 
  249: class TestConcatenate:
  250:     def test_returns_copy(self):
  251:         a = np.eye(3)
  252:         b = np.concatenate([a])
  253:         b[0, 0] = 2
  254:         assert b[0, 0] != a[0, 0]
  255: 
  256:     def test_exceptions(self):
  257:         # test axis must be in bounds
  258:         for ndim in [1, 2, 3]:
  259:             a = np.ones((1,) * ndim)
  260:             np.concatenate((a, a), axis=0)  # OK
  261:             assert_raises(AxisError, np.concatenate, (a, a), axis=ndim)
  262:             assert_raises(AxisError, np.concatenate, (a, a), axis=-(ndim + 1))
  263: 
  264:         # Scalars cannot be concatenated
  265:         assert_raises(ValueError, concatenate, (0,))
  266:         assert_raises(ValueError, concatenate, (np.array(0),))
  267: 
  268:         # dimensionality must match
  269:         assert_raises_regex(
  270:             ValueError,
  271:             r"all the input arrays must have same number of dimensions, but "
  272:             r"the array at index 0 has 1 dimension\(s\) and the array at "
  273:             r"index 1 has 2 dimension\(s\)",
  274:             np.concatenate, (np.zeros(1), np.zeros((1, 1))))
  275: 
  276:         # test shapes must match except for concatenation axis
  277:         a = np.ones((1, 2, 3))
  278:         b = np.ones((2, 2, 3))
  279:         axis = list(range(3))
  280:         for i in range(3):
  281:             np.concatenate((a, b), axis=axis[0])  # OK
  282:             assert_raises_regex(
  283:                 ValueError,
  284:                 "all the input array dimensions except for the concatenation axis "
  285:                 f"must match exactly, but along dimension {i}, the array at "
  286:                 "index 0 has size 1 and the array at index 1 has size 2",
  287:                 np.concatenate, (a, b), axis=axis[1])
  288:             assert_raises(ValueError, np.concatenate, (a, b), axis=axis[2])
  289:             a = np.moveaxis(a, -1, 0)
  290:             b = np.moveaxis(b, -1, 0)
  291:             axis.append(axis.pop(0))
  292: 
  293:         # No arrays to concatenate raises ValueError
  294:         assert_raises(ValueError, concatenate, ())
  295: 
  296:     @pytest.mark.slow
  297:     @pytest.mark.skipif(sys.maxsize < 2**32, reason="only problematic on 64bit platforms")
  298:     @requires_memory(2 * np.iinfo(np.intc).max)
  299:     def test_huge_list_error(self):
  300:         a = np.array([1])
  301:         max_int = np.iinfo(np.intc).max
  302:         arrs = (a,) * (max_int + 1)
  303:         msg = fr"concatenate\(\) only supports up to {max_int} arrays but got {max_int + 1}."
  304:         with pytest.raises(ValueError, match=msg):
  305:             np.concatenate(arrs)
  306: 
  307:     def test_concatenate_axis_None(self):
  308:         a = np.arange(4, dtype=np.float64).reshape((2, 2))
  309:         b = list(range(3))
  310:         c = ['x']
  311:         r = np.concatenate((a, a), axis=None)
  312:         assert_equal(r.dtype, a.dtype)
  313:         assert_equal(r.ndim, 1)
  314:         r = np.concatenate((a, b), axis=None)
  315:         assert_equal(r.size, a.size + len(b))
  316:         assert_equal(r.dtype, a.dtype)
  317:         r = np.concatenate((a, b, c), axis=None, dtype="U")
  318:         d = array(['0.0', '1.0', '2.0', '3.0',
  319:                    '0', '1', '2', 'x'])
  320:         assert_array_equal(r, d)
  321: 
  322:         out = np.zeros(a.size + len(b))
  323:         r = np.concatenate((a, b), axis=None)
  324:         rout = np.concatenate((a, b), axis=None, out=out)
  325:         assert_(out is rout)
  326:         assert_equal(r, rout)
  327: 
  328:     def test_large_concatenate_axis_None(self):
  329:         # When no axis is given, concatenate uses flattened versions.
  330:         # This also had a bug with many arrays (see gh-5979).
  331:         x = np.arange(1, 100)
  332:         r = np.concatenate(x, None)
  333:         assert_array_equal(x, r)
  334: 
  335:         # Once upon a time, this was the same as `axis=None` now it fails
  336:         # (with an unspecified error, as multiple things are wrong here)
  337:         with pytest.raises(ValueError):
  338:             np.concatenate(x, 100)
  339: 
  340:     def test_concatenate(self):
  341:         # Test concatenate function
  342:         # One sequence returns unmodified (but as array)
  343:         r4 = list(range(4))
  344:         assert_array_equal(concatenate((r4,)), r4)
  345:         # Any sequence
  346:         assert_array_equal(concatenate((tuple(r4),)), r4)
  347:         assert_array_equal(concatenate((array(r4),)), r4)
  348:         # 1D default concatenation
  349:         r3 = list(range(3))
  350:         assert_array_equal(concatenate((r4, r3)), r4 + r3)
  351:         # Mixed sequence types
  352:         assert_array_equal(concatenate((tuple(r4), r3)), r4 + r3)
  353:         assert_array_equal(concatenate((array(r4), r3)), r4 + r3)
  354:         # Explicit axis specification
  355:         assert_array_equal(concatenate((r4, r3), 0), r4 + r3)
  356:         # Including negative
  357:         assert_array_equal(concatenate((r4, r3), -1), r4 + r3)
  358:         # 2D
  359:         a23 = array([[10, 11, 12], [13, 14, 15]])
  360:         a13 = array([[0, 1, 2]])
  361:         res = array([[10, 11, 12], [13, 14, 15], [0, 1, 2]])
  362:         assert_array_equal(concatenate((a23, a13)), res)
  363:         assert_array_equal(concatenate((a23, a13), 0), res)
  364:         assert_array_equal(concatenate((a23.T, a13.T), 1), res.T)
  365:         assert_array_equal(concatenate((a23.T, a13.T), -1), res.T)
  366:         # Arrays much match shape
  367:         assert_raises(ValueError, concatenate, (a23.T, a13.T), 0)
  368:         # 3D
  369:         res = arange(2 * 3 * 7).reshape((2, 3, 7))
  370:         a0 = res[..., :4]
  371:         a1 = res[..., 4:6]
  372:         a2 = res[..., 6:]
  373:         assert_array_equal(concatenate((a0, a1, a2), 2), res)
  374:         assert_array_equal(concatenate((a0, a1, a2), -1), res)
  375:         assert_array_equal(concatenate((a0.T, a1.T, a2.T), 0), res.T)
  376: 
  377:         out = res.copy()
  378:         rout = concatenate((a0, a1, a2), 2, out=out)
  379:         assert_(out is rout)
  380:         assert_equal(res, rout)
  381: 
  382:     @pytest.mark.skipif(IS_PYPY, reason="PYPY handles sq_concat, nb_add differently than cpython")
  383:     def test_operator_concat(self):
  384:         import operator
  385:         a = array([1, 2])
  386:         b = array([3, 4])
  387:         n = [1, 2]
  388:         res = array([1, 2, 3, 4])
  389:         assert_raises(TypeError, operator.concat, a, b)
  390:         assert_raises(TypeError, operator.concat, a, n)
  391:         assert_raises(TypeError, operator.concat, n, a)
  392:         assert_raises(TypeError, operator.concat, a, 1)
  393:         assert_raises(TypeError, operator.concat, 1, a)
  394: 
  395:     def test_bad_out_shape(self):
  396:         a = array([1, 2])
  397:         b = array([3, 4])
  398: 
  399:         assert_raises(ValueError, concatenate, (a, b), out=np.empty(5))
  400:         assert_raises(ValueError, concatenate, (a, b), out=np.empty((4, 1)))
  401:         assert_raises(ValueError, concatenate, (a, b), out=np.empty((1, 4)))
  402:         concatenate((a, b), out=np.empty(4))
  403: 
  404:     @pytest.mark.parametrize("axis", [None, 0])
  405:     @pytest.mark.parametrize("out_dtype", ["c8", "f4", "f8", ">f8", "i8", "S4"])
  406:     @pytest.mark.parametrize("casting",
  407:             ['no', 'equiv', 'safe', 'same_kind', 'unsafe'])
  408:     def test_out_and_dtype(self, axis, out_dtype, casting):
  409:         # Compare usage of `out=out` with `dtype=out.dtype`
  410:         out = np.empty(4, dtype=out_dtype)
  411:         to_concat = (array([1.1, 2.2]), array([3.3, 4.4]))
  412: 
  413:         if not np.can_cast(to_concat[0], out_dtype, casting=casting):
  414:             with assert_raises(TypeError):
  415:                 concatenate(to_concat, out=out, axis=axis, casting=casting)
  416:             with assert_raises(TypeError):
  417:                 concatenate(to_concat, dtype=out.dtype,
  418:                             axis=axis, casting=casting)
  419:         else:
  420:             res_out = concatenate(to_concat, out=out,
  421:                                   axis=axis, casting=casting)
  422:             res_dtype = concatenate(to_concat, dtype=out.dtype,
  423:                                     axis=axis, casting=casting)
  424:             assert res_out is out
  425:             assert_array_equal(out, res_dtype)
  426:             assert res_dtype.dtype == out_dtype
  427: 
  428:         with assert_raises(TypeError):
  429:             concatenate(to_concat, out=out, dtype=out_dtype, axis=axis)
  430: 
  431:     @pytest.mark.parametrize("axis", [None, 0])
  432:     @pytest.mark.parametrize("string_dt", ["S", "U", "S0", "U0"])
  433:     @pytest.mark.parametrize("arrs",
  434:             [([0.],), ([0.], [1]), ([0], ["string"], [1.])])
  435:     def test_dtype_with_promotion(self, arrs, string_dt, axis):
  436:         # Note that U0 and S0 should be deprecated eventually and changed to
  437:         # actually give the empty string result (together with `np.array`)
  438:         res = np.concatenate(arrs, axis=axis, dtype=string_dt, casting="unsafe")
  439:         # The actual dtype should be identical to a cast (of a double array):
  440:         assert res.dtype == np.array(1.).astype(string_dt).dtype
  441: 
  442:     @pytest.mark.parametrize("axis", [None, 0])
  443:     def test_string_dtype_does_not_inspect(self, axis):
  444:         with pytest.raises(TypeError):
  445:             np.concatenate(([None], [1]), dtype="S", axis=axis)
  446:         with pytest.raises(TypeError):
  447:             np.concatenate(([None], [1]), dtype="U", axis=axis)
  448: 
  449:     @pytest.mark.parametrize("axis", [None, 0])
  450:     def test_subarray_error(self, axis):
  451:         with pytest.raises(TypeError, match=".*subarray dtype"):
  452:             np.concatenate(([1], [1]), dtype="(2,)i", axis=axis)
  453: 
  454: 
  455: def test_stack():
  456:     # non-iterable input
  457:     assert_raises(TypeError, stack, 1)
  458: 
  459:     # 0d input
  460:     for input_ in [(1, 2, 3),
  461:                    [np.int32(1), np.int32(2), np.int32(3)],
  462:                    [np.array(1), np.array(2), np.array(3)]]:
  463:         assert_array_equal(stack(input_), [1, 2, 3])
  464:     # 1d input examples
  465:     a = np.array([1, 2, 3])
  466:     b = np.array([4, 5, 6])
  467:     r1 = array([[1, 2, 3], [4, 5, 6]])
  468:     assert_array_equal(np.stack((a, b)), r1)
  469:     assert_array_equal(np.stack((a, b), axis=1), r1.T)
  470:     # all input types
  471:     assert_array_equal(np.stack([a, b]), r1)
  472:     assert_array_equal(np.stack(array([a, b])), r1)
  473:     # all shapes for 1d input
  474:     arrays = [np.random.randn(3) for _ in range(10)]
  475:     axes = [0, 1, -1, -2]
  476:     expected_shapes = [(10, 3), (3, 10), (3, 10), (10, 3)]
  477:     for axis, expected_shape in zip(axes, expected_shapes):
  478:         assert_equal(np.stack(arrays, axis).shape, expected_shape)
  479:     assert_raises_regex(AxisError, 'out of bounds', stack, arrays, axis=2)
  480:     assert_raises_regex(AxisError, 'out of bounds', stack, arrays, axis=-3)
  481:     # all shapes for 2d input
  482:     arrays = [np.random.randn(3, 4) for _ in range(10)]
  483:     axes = [0, 1, 2, -1, -2, -3]
  484:     expected_shapes = [(10, 3, 4), (3, 10, 4), (3, 4, 10),
  485:                        (3, 4, 10), (3, 10, 4), (10, 3, 4)]
  486:     for axis, expected_shape in zip(axes, expected_shapes):
  487:         assert_equal(np.stack(arrays, axis).shape, expected_shape)
  488:     # empty arrays
  489:     assert_(stack([[], [], []]).shape == (3, 0))
  490:     assert_(stack([[], [], []], axis=1).shape == (0, 3))
  491:     # out
  492:     out = np.zeros_like(r1)
  493:     np.stack((a, b), out=out)
  494:     assert_array_equal(out, r1)
  495:     # edge cases
  496:     assert_raises_regex(ValueError, 'need at least one array', stack, [])
  497:     assert_raises_regex(ValueError, 'must have the same shape',
  498:                         stack, [1, np.arange(3)])
  499:     assert_raises_regex(ValueError, 'must have the same shape',
  500:                         stack, [np.arange(3), 1])
  501:     assert_raises_regex(ValueError, 'must have the same shape',
  502:                         stack, [np.arange(3), 1], axis=1)
  503:     assert_raises_regex(ValueError, 'must have the same shape',
  504:                         stack, [np.zeros((3, 3)), np.zeros(3)], axis=1)
  505:     assert_raises_regex(ValueError, 'must have the same shape',
  506:                         stack, [np.arange(2), np.arange(3)])
  507: 
  508:     # do not accept generators
  509:     with pytest.raises(TypeError, match="arrays to stack must be"):
  510:         stack(x for x in range(3))
  511: 
  512:     # casting and dtype test
  513:     a = np.array([1, 2, 3])
  514:     b = np.array([2.5, 3.5, 4.5])
  515:     res = np.stack((a, b), axis=1, casting="unsafe", dtype=np.int64)
  516:     expected_res = np.array([[1, 2], [2, 3], [3, 4]])
  517:     assert_array_equal(res, expected_res)
  518:     # casting and dtype with TypeError
  519:     with assert_raises(TypeError):
  520:         stack((a, b), dtype=np.int64, axis=1, casting="safe")
  521: 
  522: 
  523: def test_unstack():
  524:     a = np.arange(24).reshape((2, 3, 4))
  525: 
  526:     for stacks in [np.unstack(a),
  527:                    np.unstack(a, axis=0),
  528:                    np.unstack(a, axis=-3)]:
  529:         assert isinstance(stacks, tuple)
  530:         assert len(stacks) == 2
  531:         assert_array_equal(stacks[0], a[0])
  532:         assert_array_equal(stacks[1], a[1])
  533: 
  534:     for stacks in [np.unstack(a, axis=1),
  535:                    np.unstack(a, axis=-2)]:
  536:         assert isinstance(stacks, tuple)
  537:         assert len(stacks) == 3
  538:         assert_array_equal(stacks[0], a[:, 0])
  539:         assert_array_equal(stacks[1], a[:, 1])
  540:         assert_array_equal(stacks[2], a[:, 2])
  541: 
  542:     for stacks in [np.unstack(a, axis=2),
  543:                    np.unstack(a, axis=-1)]:
  544:         assert isinstance(stacks, tuple)
  545:         assert len(stacks) == 4
  546:         assert_array_equal(stacks[0], a[:, :, 0])
  547:         assert_array_equal(stacks[1], a[:, :, 1])
  548:         assert_array_equal(stacks[2], a[:, :, 2])
  549:         assert_array_equal(stacks[3], a[:, :, 3])
  550: 
  551:     assert_raises(ValueError, np.unstack, a, axis=3)
  552:     assert_raises(ValueError, np.unstack, a, axis=-4)
  553:     assert_raises(ValueError, np.unstack, np.array(0), axis=0)
  554: 
  555: 
  556: @pytest.mark.parametrize("axis", [0])
  557: @pytest.mark.parametrize("out_dtype", ["c8", "f4", "f8", ">f8", "i8"])
  558: @pytest.mark.parametrize("casting",
  559:                          ['no', 'equiv', 'safe', 'same_kind', 'unsafe'])
  560: def test_stack_out_and_dtype(axis, out_dtype, casting):
  561:     to_concat = (array([1, 2]), array([3, 4]))
  562:     res = array([[1, 2], [3, 4]])
  563:     out = np.zeros_like(res)
  564: 
  565:     if not np.can_cast(to_concat[0], out_dtype, casting=casting):
  566:         with assert_raises(TypeError):
  567:             stack(to_concat, dtype=out_dtype,
  568:                   axis=axis, casting=casting)
  569:     else:
  570:         res_out = stack(to_concat, out=out,
  571:                         axis=axis, casting=casting)
  572:         res_dtype = stack(to_concat, dtype=out_dtype,
  573:                           axis=axis, casting=casting)
  574:         assert res_out is out
  575:         assert_array_equal(out, res_dtype)
  576:         assert res_dtype.dtype == out_dtype
  577: 
  578:     with assert_raises(TypeError):
  579:         stack(to_concat, out=out, dtype=out_dtype, axis=axis)
  580: 
  581: 
  582: class TestBlock:
  583:     @pytest.fixture(params=['block', 'force_concatenate', 'force_slicing'])
  584:     def block(self, request):
  585:         # blocking small arrays and large arrays go through different paths.
  586:         # the algorithm is triggered depending on the number of element
  587:         # copies required.
  588:         # We define a test fixture that forces most tests to go through
  589:         # both code paths.
  590:         # Ultimately, this should be removed if a single algorithm is found
  591:         # to be faster for both small and large arrays.
  592:         def _block_force_concatenate(arrays):
  593:             arrays, list_ndim, result_ndim, _ = _block_setup(arrays)
  594:             return _block_concatenate(arrays, list_ndim, result_ndim)
  595: 
  596:         def _block_force_slicing(arrays):
  597:             arrays, list_ndim, result_ndim, _ = _block_setup(arrays)
  598:             return _block_slicing(arrays, list_ndim, result_ndim)
  599: 
  600:         if request.param == 'force_concatenate':
  601:             return _block_force_concatenate
  602:         elif request.param == 'force_slicing':
  603:             return _block_force_slicing
  604:         elif request.param == 'block':
  605:             return block
  606:         else:
  607:             raise ValueError('Unknown blocking request. There is a typo in the tests.')
  608: 
  609:     def test_returns_copy(self, block):
  610:         a = np.eye(3)
  611:         b = block(a)
  612:         b[0, 0] = 2
  613:         assert b[0, 0] != a[0, 0]
  614: 
  615:     def test_block_total_size_estimate(self, block):
  616:         _, _, _, total_size = _block_setup([1])
  617:         assert total_size == 1
  618: 
  619:         _, _, _, total_size = _block_setup([[1]])
  620:         assert total_size == 1
  621: 
  622:         _, _, _, total_size = _block_setup([[1, 1]])
  623:         assert total_size == 2
  624: 
  625:         _, _, _, total_size = _block_setup([[1], [1]])
  626:         assert total_size == 2
  627: 
  628:         _, _, _, total_size = _block_setup([[1, 2], [3, 4]])
  629:         assert total_size == 4
  630: 
  631:     def test_block_simple_row_wise(self, block):
  632:         a_2d = np.ones((2, 2))
  633:         b_2d = 2 * a_2d
  634:         desired = np.array([[1, 1, 2, 2],
  635:                             [1, 1, 2, 2]])
  636:         result = block([a_2d, b_2d])
  637:         assert_equal(desired, result)
  638: 
  639:     def test_block_simple_column_wise(self, block):
  640:         a_2d = np.ones((2, 2))
  641:         b_2d = 2 * a_2d
  642:         expected = np.array([[1, 1],
  643:                              [1, 1],
  644:                              [2, 2],
  645:                              [2, 2]])
  646:         result = block([[a_2d], [b_2d]])
  647:         assert_equal(expected, result)
  648: 
  649:     def test_block_with_1d_arrays_row_wise(self, block):
  650:         # # # 1-D vectors are treated as row arrays
  651:         a = np.array([1, 2, 3])
  652:         b = np.array([2, 3, 4])
  653:         expected = np.array([1, 2, 3, 2, 3, 4])
  654:         result = block([a, b])
  655:         assert_equal(expected, result)
  656: 
  657:     def test_block_with_1d_arrays_multiple_rows(self, block):
  658:         a = np.array([1, 2, 3])
  659:         b = np.array([2, 3, 4])
  660:         expected = np.array([[1, 2, 3, 2, 3, 4],
  661:                              [1, 2, 3, 2, 3, 4]])
  662:         result = block([[a, b], [a, b]])
  663:         assert_equal(expected, result)
  664: 
  665:     def test_block_with_1d_arrays_column_wise(self, block):
  666:         # # # 1-D vectors are treated as row arrays
  667:         a_1d = np.array([1, 2, 3])
  668:         b_1d = np.array([2, 3, 4])
  669:         expected = np.array([[1, 2, 3],
  670:                              [2, 3, 4]])
  671:         result = block([[a_1d], [b_1d]])
  672:         assert_equal(expected, result)
  673: 
  674:     def test_block_mixed_1d_and_2d(self, block):
  675:         a_2d = np.ones((2, 2))
  676:         b_1d = np.array([2, 2])
  677:         result = block([[a_2d], [b_1d]])
  678:         expected = np.array([[1, 1],
  679:                              [1, 1],
  680:                              [2, 2]])
  681:         assert_equal(expected, result)
  682: 
  683:     def test_block_complicated(self, block):
  684:         # a bit more complicated
  685:         one_2d = np.array([[1, 1, 1]])
  686:         two_2d = np.array([[2, 2, 2]])
  687:         three_2d = np.array([[3, 3, 3, 3, 3, 3]])
  688:         four_1d = np.array([4, 4, 4, 4, 4, 4])
  689:         five_0d = np.array(5)
  690:         six_1d = np.array([6, 6, 6, 6, 6])
  691:         zero_2d = np.zeros((2, 6))
  692: 
  693:         expected = np.array([[1, 1, 1, 2, 2, 2],
  694:                              [3, 3, 3, 3, 3, 3],
  695:                              [4, 4, 4, 4, 4, 4],
  696:                              [5, 6, 6, 6, 6, 6],
  697:                              [0, 0, 0, 0, 0, 0],
  698:                              [0, 0, 0, 0, 0, 0]])
  699: 
  700:         result = block([[one_2d, two_2d],
  701:                         [three_2d],
  702:                         [four_1d],
  703:                         [five_0d, six_1d],
  704:                         [zero_2d]])
  705:         assert_equal(result, expected)
  706: 
  707:     def test_nested(self, block):
  708:         one = np.array([1, 1, 1])
  709:         two = np.array([[2, 2, 2], [2, 2, 2], [2, 2, 2]])
  710:         three = np.array([3, 3, 3])
  711:         four = np.array([4, 4, 4])
  712:         five = np.array(5)
  713:         six = np.array([6, 6, 6, 6, 6])
  714:         zero = np.zeros((2, 6))
  715: 
  716:         result = block([
  717:             [
  718:                 block([
  719:                    [one],
  720:                    [three],
  721:                    [four]
  722:                 ]),
  723:                 two
  724:             ],
  725:             [five, six],
  726:             [zero]
  727:         ])
  728:         expected = np.array([[1, 1, 1, 2, 2, 2],
  729:                              [3, 3, 3, 2, 2, 2],
  730:                              [4, 4, 4, 2, 2, 2],
  731:                              [5, 6, 6, 6, 6, 6],
  732:                              [0, 0, 0, 0, 0, 0],
  733:                              [0, 0, 0, 0, 0, 0]])
  734: 
  735:         assert_equal(result, expected)
  736: 
  737:     def test_3d(self, block):
  738:         a000 = np.ones((2, 2, 2), int) * 1
  739: 
  740:         a100 = np.ones((3, 2, 2), int) * 2
  741:         a010 = np.ones((2, 3, 2), int) * 3
  742:         a001 = np.ones((2, 2, 3), int) * 4
  743: 
  744:         a011 = np.ones((2, 3, 3), int) * 5
  745:         a101 = np.ones((3, 2, 3), int) * 6
  746:         a110 = np.ones((3, 3, 2), int) * 7
  747: 
  748:         a111 = np.ones((3, 3, 3), int) * 8
  749: 
  750:         result = block([
  751:             [
  752:                 [a000, a001],
  753:                 [a010, a011],
  754:             ],
  755:             [
  756:                 [a100, a101],
  757:                 [a110, a111],
  758:             ]
  759:         ])
  760:         expected = array([[[1, 1, 4, 4, 4],
  761:                            [1, 1, 4, 4, 4],
  762:                            [3, 3, 5, 5, 5],
  763:                            [3, 3, 5, 5, 5],
  764:                            [3, 3, 5, 5, 5]],
  765: 
  766:                           [[1, 1, 4, 4, 4],
  767:                            [1, 1, 4, 4, 4],
  768:                            [3, 3, 5, 5, 5],
  769:                            [3, 3, 5, 5, 5],
  770:                            [3, 3, 5, 5, 5]],
  771: 
  772:                           [[2, 2, 6, 6, 6],
  773:                            [2, 2, 6, 6, 6],
  774:                            [7, 7, 8, 8, 8],
  775:                            [7, 7, 8, 8, 8],
  776:                            [7, 7, 8, 8, 8]],
  777: 
  778:                           [[2, 2, 6, 6, 6],
  779:                            [2, 2, 6, 6, 6],
  780:                            [7, 7, 8, 8, 8],
  781:                            [7, 7, 8, 8, 8],
  782:                            [7, 7, 8, 8, 8]],
  783: 
  784:                           [[2, 2, 6, 6, 6],
  785:                            [2, 2, 6, 6, 6],
  786:                            [7, 7, 8, 8, 8],
  787:                            [7, 7, 8, 8, 8],
  788:                            [7, 7, 8, 8, 8]]])
  789: 
  790:         assert_array_equal(result, expected)
  791: 
  792:     def test_block_with_mismatched_shape(self, block):
  793:         a = np.array([0, 0])
  794:         b = np.eye(2)
  795:         assert_raises(ValueError, block, [a, b])
  796:         assert_raises(ValueError, block, [b, a])
  797: 
  798:         to_block = [[np.ones((2, 3)), np.ones((2, 2))],
  799:                     [np.ones((2, 2)), np.ones((2, 2))]]
  800:         assert_raises(ValueError, block, to_block)
  801: 
  802:     def test_no_lists(self, block):
  803:         assert_equal(block(1),         np.array(1))
  804:         assert_equal(block(np.eye(3)), np.eye(3))
  805: 
  806:     def test_invalid_nesting(self, block):
  807:         msg = 'depths are mismatched'
  808:         assert_raises_regex(ValueError, msg, block, [1, [2]])
  809:         assert_raises_regex(ValueError, msg, block, [1, []])
  810:         assert_raises_regex(ValueError, msg, block, [[1], 2])
  811:         assert_raises_regex(ValueError, msg, block, [[], 2])
  812:         assert_raises_regex(ValueError, msg, block, [
  813:             [[1], [2]],
  814:             [[3, 4]],
  815:             [5]  # missing brackets
  816:         ])
  817: 
  818:     def test_empty_lists(self, block):
  819:         assert_raises_regex(ValueError, 'empty', block, [])
  820:         assert_raises_regex(ValueError, 'empty', block, [[]])
  821:         assert_raises_regex(ValueError, 'empty', block, [[1], []])
  822: 
  823:     def test_tuple(self, block):
  824:         assert_raises_regex(TypeError, 'tuple', block, ([1, 2], [3, 4]))
  825:         assert_raises_regex(TypeError, 'tuple', block, [(1, 2), (3, 4)])
  826: 
  827:     def test_different_ndims(self, block):
  828:         a = 1.
  829:         b = 2 * np.ones((1, 2))
  830:         c = 3 * np.ones((1, 1, 3))
  831: 
  832:         result = block([a, b, c])
  833:         expected = np.array([[[1., 2., 2., 3., 3., 3.]]])
  834: 
  835:         assert_equal(result, expected)
  836: 
  837:     def test_different_ndims_depths(self, block):
  838:         a = 1.
  839:         b = 2 * np.ones((1, 2))
  840:         c = 3 * np.ones((1, 2, 3))
  841: 
  842:         result = block([[a, b], [c]])
  843:         expected = np.array([[[1., 2., 2.],
  844:                               [3., 3., 3.],
  845:                               [3., 3., 3.]]])
  846: 
  847:         assert_equal(result, expected)
  848: 
  849:     def test_block_memory_order(self, block):
  850:         # 3D
  851:         arr_c = np.zeros((3,) * 3, order='C')
  852:         arr_f = np.zeros((3,) * 3, order='F')
  853: 
  854:         b_c = [[[arr_c, arr_c],
  855:                 [arr_c, arr_c]],
  856:                [[arr_c, arr_c],
  857:                 [arr_c, arr_c]]]
  858: 
  859:         b_f = [[[arr_f, arr_f],
  860:                 [arr_f, arr_f]],
  861:                [[arr_f, arr_f],
  862:                 [arr_f, arr_f]]]
  863: 
  864:         assert block(b_c).flags['C_CONTIGUOUS']
  865:         assert block(b_f).flags['F_CONTIGUOUS']
  866: 
  867:         arr_c = np.zeros((3, 3), order='C')
  868:         arr_f = np.zeros((3, 3), order='F')
  869:         # 2D
  870:         b_c = [[arr_c, arr_c],
  871:                [arr_c, arr_c]]
  872: 
  873:         b_f = [[arr_f, arr_f],
  874:                [arr_f, arr_f]]
  875: 
  876:         assert block(b_c).flags['C_CONTIGUOUS']
  877:         assert block(b_f).flags['F_CONTIGUOUS']
  878: 
  879: 
  880: def test_block_dispatcher():
  881:     class ArrayLike:
  882:         pass
  883:     a = ArrayLike()
  884:     b = ArrayLike()
  885:     c = ArrayLike()
  886:     assert_equal(list(_block_dispatcher(a)), [a])
  887:     assert_equal(list(_block_dispatcher([a])), [a])
  888:     assert_equal(list(_block_dispatcher([a, b])), [a, b])
  889:     assert_equal(list(_block_dispatcher([[a], [b, [c]]])), [a, b, c])
  890:     # don't recurse into non-lists
  891:     assert_equal(list(_block_dispatcher((a, b))), [(a, b)])
