    1: # Vendored implementation of pandas.NA, adapted from pandas/_libs/missing.pyx
    2: #
    3: # This is vendored to avoid adding pandas as a test dependency.
    4: 
    5: __all__ = ["pd_NA"]
    6: 
    7: import numbers
    8: 
    9: import numpy as np
   10: 
   11: 
   12: def _create_binary_propagating_op(name, is_divmod=False):
   13:     is_cmp = name.strip("_") in ["eq", "ne", "le", "lt", "ge", "gt"]
   14: 
   15:     def method(self, other):
   16:         if (
   17:             other is pd_NA
   18:             or isinstance(other, (str, bytes, numbers.Number, np.bool))
   19:             or (isinstance(other, np.ndarray) and not other.shape)
   20:         ):
   21:             # Need the other.shape clause to handle NumPy scalars,
   22:             # since we do a setitem on `out` below, which
   23:             # won't work for NumPy scalars.
   24:             if is_divmod:
   25:                 return pd_NA, pd_NA
   26:             else:
   27:                 return pd_NA
   28: 
   29:         elif isinstance(other, np.ndarray):
   30:             out = np.empty(other.shape, dtype=object)
   31:             out[:] = pd_NA
   32: 
   33:             if is_divmod:
   34:                 return out, out.copy()
   35:             else:
   36:                 return out
   37: 
   38:         elif is_cmp and isinstance(other, (np.datetime64, np.timedelta64)):
   39:             return pd_NA
   40: 
   41:         elif isinstance(other, np.datetime64):
   42:             if name in ["__sub__", "__rsub__"]:
   43:                 return pd_NA
   44: 
   45:         elif isinstance(other, np.timedelta64):
   46:             if name in ["__sub__", "__rsub__", "__add__", "__radd__"]:
   47:                 return pd_NA
   48: 
   49:         return NotImplemented
   50: 
   51:     method.__name__ = name
   52:     return method
   53: 
   54: 
   55: def _create_unary_propagating_op(name: str):
   56:     def method(self):
   57:         return pd_NA
   58: 
   59:     method.__name__ = name
   60:     return method
   61: 
   62: 
   63: class NAType:
   64:     def __repr__(self) -> str:
   65:         return "<NA>"
   66: 
   67:     def __format__(self, format_spec) -> str:
   68:         try:
   69:             return self.__repr__().__format__(format_spec)
   70:         except ValueError:
   71:             return self.__repr__()
   72: 
   73:     def __bool__(self):
   74:         raise TypeError("boolean value of NA is ambiguous")
   75: 
   76:     def __hash__(self):
   77:         exponent = 31 if is_32bit else 61
   78:         return 2**exponent - 1
   79: 
   80:     def __reduce__(self):
   81:         return "pd_NA"
   82: 
   83:     # Binary arithmetic and comparison ops -> propagate
   84: 
   85:     __add__ = _create_binary_propagating_op("__add__")
   86:     __radd__ = _create_binary_propagating_op("__radd__")
   87:     __sub__ = _create_binary_propagating_op("__sub__")
   88:     __rsub__ = _create_binary_propagating_op("__rsub__")
   89:     __mul__ = _create_binary_propagating_op("__mul__")
   90:     __rmul__ = _create_binary_propagating_op("__rmul__")
   91:     __matmul__ = _create_binary_propagating_op("__matmul__")
   92:     __rmatmul__ = _create_binary_propagating_op("__rmatmul__")
   93:     __truediv__ = _create_binary_propagating_op("__truediv__")
   94:     __rtruediv__ = _create_binary_propagating_op("__rtruediv__")
   95:     __floordiv__ = _create_binary_propagating_op("__floordiv__")
   96:     __rfloordiv__ = _create_binary_propagating_op("__rfloordiv__")
   97:     __mod__ = _create_binary_propagating_op("__mod__")
   98:     __rmod__ = _create_binary_propagating_op("__rmod__")
   99:     __divmod__ = _create_binary_propagating_op("__divmod__", is_divmod=True)
  100:     __rdivmod__ = _create_binary_propagating_op("__rdivmod__", is_divmod=True)
  101:     # __lshift__ and __rshift__ are not implemented
  102: 
  103:     __eq__ = _create_binary_propagating_op("__eq__")
  104:     __ne__ = _create_binary_propagating_op("__ne__")
  105:     __le__ = _create_binary_propagating_op("__le__")
  106:     __lt__ = _create_binary_propagating_op("__lt__")
  107:     __gt__ = _create_binary_propagating_op("__gt__")
  108:     __ge__ = _create_binary_propagating_op("__ge__")
  109: 
  110:     # Unary ops
  111: 
  112:     __neg__ = _create_unary_propagating_op("__neg__")
  113:     __pos__ = _create_unary_propagating_op("__pos__")
  114:     __abs__ = _create_unary_propagating_op("__abs__")
  115:     __invert__ = _create_unary_propagating_op("__invert__")
  116: 
  117:     # pow has special
  118:     def __pow__(self, other):
  119:         if other is pd_NA:
  120:             return pd_NA
  121:         elif isinstance(other, (numbers.Number, np.bool)):
  122:             if other == 0:
  123:                 # returning positive is correct for +/- 0.
  124:                 return type(other)(1)
  125:             else:
  126:                 return pd_NA
  127:         elif util.is_array(other):
  128:             return np.where(other == 0, other.dtype.type(1), pd_NA)
  129: 
  130:         return NotImplemented
  131: 
  132:     def __rpow__(self, other):
  133:         if other is pd_NA:
  134:             return pd_NA
  135:         elif isinstance(other, (numbers.Number, np.bool)):
  136:             if other == 1:
  137:                 return other
  138:             else:
  139:                 return pd_NA
  140:         elif util.is_array(other):
  141:             return np.where(other == 1, other, pd_NA)
  142:         return NotImplemented
  143: 
  144:     # Logical ops using Kleene logic
  145: 
  146:     def __and__(self, other):
  147:         if other is False:
  148:             return False
  149:         elif other is True or other is pd_NA:
  150:             return pd_NA
  151:         return NotImplemented
  152: 
  153:     __rand__ = __and__
  154: 
  155:     def __or__(self, other):
  156:         if other is True:
  157:             return True
  158:         elif other is False or other is pd_NA:
  159:             return pd_NA
  160:         return NotImplemented
  161: 
  162:     __ror__ = __or__
  163: 
  164:     def __xor__(self, other):
  165:         if other is False or other is True or other is pd_NA:
  166:             return pd_NA
  167:         return NotImplemented
  168: 
  169:     __rxor__ = __xor__
  170: 
  171:     __array_priority__ = 1000
  172:     _HANDLED_TYPES = (np.ndarray, numbers.Number, str, np.bool)
  173: 
  174:     def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):
  175:         types = self._HANDLED_TYPES + (NAType,)
  176:         for x in inputs:
  177:             if not isinstance(x, types):
  178:                 return NotImplemented
  179: 
  180:         if method != "__call__":
  181:             raise ValueError(f"ufunc method '{method}' not supported for NA")
  182:         result = maybe_dispatch_ufunc_to_dunder_op(
  183:             self, ufunc, method, *inputs, **kwargs
  184:         )
  185:         if result is NotImplemented:
  186:             # For a NumPy ufunc that's not a binop, like np.logaddexp
  187:             index = next(i for i, x in enumerate(inputs) if x is pd_NA)
  188:             result = np.broadcast_arrays(*inputs)[index]
  189:             if result.ndim == 0:
  190:                 result = result.item()
  191:             if ufunc.nout > 1:
  192:                 result = (pd_NA,) * ufunc.nout
  193: 
  194:         return result
  195: 
  196: 
  197: pd_NA = NAType()
  198: 
  199: 
  200: def get_stringdtype_dtype(na_object, coerce=True):
  201:     # explicit is check for pd_NA because != with pd_NA returns pd_NA
  202:     if na_object is pd_NA or na_object != "unset":
  203:         return np.dtypes.StringDType(na_object=na_object, coerce=coerce)
  204:     else:
  205:         return np.dtypes.StringDType(coerce=coerce)
