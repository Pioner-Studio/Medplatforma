    1: import sys
    2: import sysconfig
    3: 
    4: import pytest
    5: 
    6: import numpy as np
    7: from numpy.testing import IS_EDITABLE, IS_WASM, extbuild
    8: 
    9: 
   10: @pytest.fixture
   11: def get_module(tmp_path):
   12:     """ Some codes to generate data and manage temporary buffers use when
   13:     sharing with numpy via the array interface protocol.
   14:     """
   15:     if sys.platform.startswith('cygwin'):
   16:         pytest.skip('link fails on cygwin')
   17:     if IS_WASM:
   18:         pytest.skip("Can't build module inside Wasm")
   19:     if IS_EDITABLE:
   20:         pytest.skip("Can't build module for editable install")
   21: 
   22:     prologue = '''
   23:         #include <Python.h>
   24:         #define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION
   25:         #include <numpy/arrayobject.h>
   26:         #include <stdio.h>
   27:         #include <math.h>
   28: 
   29:         NPY_NO_EXPORT
   30:         void delete_array_struct(PyObject *cap) {
   31: 
   32:             /* get the array interface structure */
   33:             PyArrayInterface *inter = (PyArrayInterface*)
   34:                 PyCapsule_GetPointer(cap, NULL);
   35: 
   36:             /* get the buffer by which data was shared */
   37:             double *ptr = (double*)PyCapsule_GetContext(cap);
   38: 
   39:             /* for the purposes of the regression test set the elements
   40:                to nan */
   41:             for (npy_intp i = 0; i < inter->shape[0]; ++i)
   42:                 ptr[i] = nan("");
   43: 
   44:             /* free the shared buffer */
   45:             free(ptr);
   46: 
   47:             /* free the array interface structure */
   48:             free(inter->shape);
   49:             free(inter);
   50: 
   51:             fprintf(stderr, "delete_array_struct\\ncap = %ld inter = %ld"
   52:                 " ptr = %ld\\n", (long)cap, (long)inter, (long)ptr);
   53:         }
   54:         '''
   55: 
   56:     functions = [
   57:         ("new_array_struct", "METH_VARARGS", """
   58: 
   59:             long long n_elem = 0;
   60:             double value = 0.0;
   61: 
   62:             if (!PyArg_ParseTuple(args, "Ld", &n_elem, &value)) {
   63:                 Py_RETURN_NONE;
   64:             }
   65: 
   66:             /* allocate and initialize the data to share with numpy */
   67:             long long n_bytes = n_elem*sizeof(double);
   68:             double *data = (double*)malloc(n_bytes);
   69: 
   70:             if (!data) {
   71:                 PyErr_Format(PyExc_MemoryError,
   72:                     "Failed to malloc %lld bytes", n_bytes);
   73: 
   74:                 Py_RETURN_NONE;
   75:             }
   76: 
   77:             for (long long i = 0; i < n_elem; ++i) {
   78:                 data[i] = value;
   79:             }
   80: 
   81:             /* calculate the shape and stride */
   82:             int nd = 1;
   83: 
   84:             npy_intp *ss = (npy_intp*)malloc(2*nd*sizeof(npy_intp));
   85:             npy_intp *shape = ss;
   86:             npy_intp *stride = ss + nd;
   87: 
   88:             shape[0] = n_elem;
   89:             stride[0] = sizeof(double);
   90: 
   91:             /* construct the array interface */
   92:             PyArrayInterface *inter = (PyArrayInterface*)
   93:                 malloc(sizeof(PyArrayInterface));
   94: 
   95:             memset(inter, 0, sizeof(PyArrayInterface));
   96: 
   97:             inter->two = 2;
   98:             inter->nd = nd;
   99:             inter->typekind = 'f';
  100:             inter->itemsize = sizeof(double);
  101:             inter->shape = shape;
  102:             inter->strides = stride;
  103:             inter->data = data;
  104:             inter->flags = NPY_ARRAY_WRITEABLE | NPY_ARRAY_NOTSWAPPED |
  105:                            NPY_ARRAY_ALIGNED | NPY_ARRAY_C_CONTIGUOUS;
  106: 
  107:             /* package into a capsule */
  108:             PyObject *cap = PyCapsule_New(inter, NULL, delete_array_struct);
  109: 
  110:             /* save the pointer to the data */
  111:             PyCapsule_SetContext(cap, data);
  112: 
  113:             fprintf(stderr, "new_array_struct\\ncap = %ld inter = %ld"
  114:                 " ptr = %ld\\n", (long)cap, (long)inter, (long)data);
  115: 
  116:             return cap;
  117:         """)
  118:         ]
  119: 
  120:     more_init = "import_array();"
  121: 
  122:     try:
  123:         import array_interface_testing
  124:         return array_interface_testing
  125:     except ImportError:
  126:         pass
  127: 
  128:     # if it does not exist, build and load it
  129:     if sysconfig.get_platform() == "win-arm64":
  130:         pytest.skip("Meson unable to find MSVC linker on win-arm64")
  131:     return extbuild.build_and_import_extension('array_interface_testing',
  132:                                                functions,
  133:                                                prologue=prologue,
  134:                                                include_dirs=[np.get_include()],
  135:                                                build_dir=tmp_path,
  136:                                                more_init=more_init)
  137: 
  138: 
  139: @pytest.mark.slow
  140: def test_cstruct(get_module):
  141: 
  142:     class data_source:
  143:         """
  144:         This class is for testing the timing of the PyCapsule destructor
  145:         invoked when numpy release its reference to the shared data as part of
  146:         the numpy array interface protocol. If the PyCapsule destructor is
  147:         called early the shared data is freed and invalid memory accesses will
  148:         occur.
  149:         """
  150: 
  151:         def __init__(self, size, value):
  152:             self.size = size
  153:             self.value = value
  154: 
  155:         @property
  156:         def __array_struct__(self):
  157:             return get_module.new_array_struct(self.size, self.value)
  158: 
  159:     # write to the same stream as the C code
  160:     stderr = sys.__stderr__
  161: 
  162:     # used to validate the shared data.
  163:     expected_value = -3.1415
  164:     multiplier = -10000.0
  165: 
  166:     # create some data to share with numpy via the array interface
  167:     # assign the data an expected value.
  168:     stderr.write(' ---- create an object to share data ---- \n')
  169:     buf = data_source(256, expected_value)
  170:     stderr.write(' ---- OK!\n\n')
  171: 
  172:     # share the data
  173:     stderr.write(' ---- share data via the array interface protocol ---- \n')
  174:     arr = np.array(buf, copy=False)
  175:     stderr.write(f'arr.__array_interface___ = {str(arr.__array_interface__)}\n')
  176:     stderr.write(f'arr.base = {str(arr.base)}\n')
  177:     stderr.write(' ---- OK!\n\n')
  178: 
  179:     # release the source of the shared data. this will not release the data
  180:     # that was shared with numpy, that is done in the PyCapsule destructor.
  181:     stderr.write(' ---- destroy the object that shared data ---- \n')
  182:     buf = None
  183:     stderr.write(' ---- OK!\n\n')
  184: 
  185:     # check that we got the expected data. If the PyCapsule destructor we
  186:     # defined was prematurely called then this test will fail because our
  187:     # destructor sets the elements of the array to NaN before free'ing the
  188:     # buffer. Reading the values here may also cause a SEGV
  189:     assert np.allclose(arr, expected_value)
  190: 
  191:     # read the data. If the PyCapsule destructor we defined was prematurely
  192:     # called then reading the values here may cause a SEGV and will be reported
  193:     # as invalid reads by valgrind
  194:     stderr.write(' ---- read shared data ---- \n')
  195:     stderr.write(f'arr = {str(arr)}\n')
  196:     stderr.write(' ---- OK!\n\n')
  197: 
  198:     # write to the shared buffer. If the shared data was prematurely deleted
  199:     # this will may cause a SEGV and valgrind will report invalid writes
  200:     stderr.write(' ---- modify shared data ---- \n')
  201:     arr *= multiplier
  202:     expected_value *= multiplier
  203:     stderr.write(f'arr.__array_interface___ = {str(arr.__array_interface__)}\n')
  204:     stderr.write(f'arr.base = {str(arr.base)}\n')
  205:     stderr.write(' ---- OK!\n\n')
  206: 
  207:     # read the data. If the shared data was prematurely deleted this
  208:     # will may cause a SEGV and valgrind will report invalid reads
  209:     stderr.write(' ---- read modified shared data ---- \n')
  210:     stderr.write(f'arr = {str(arr)}\n')
  211:     stderr.write(' ---- OK!\n\n')
  212: 
  213:     # check that we got the expected data. If the PyCapsule destructor we
  214:     # defined was prematurely called then this test will fail because our
  215:     # destructor sets the elements of the array to NaN before free'ing the
  216:     # buffer. Reading the values here may also cause a SEGV
  217:     assert np.allclose(arr, expected_value)
  218: 
  219:     # free the shared data, the PyCapsule destructor should run here
  220:     stderr.write(' ---- free shared data ---- \n')
  221:     arr = None
  222:     stderr.write(' ---- OK!\n\n')
