    1: import asyncio
    2: import gc
    3: import os
    4: import sys
    5: import sysconfig
    6: import threading
    7: 
    8: import pytest
    9: 
   10: import numpy as np
   11: from numpy._core.multiarray import get_handler_name
   12: from numpy.testing import IS_EDITABLE, IS_WASM, assert_warns, extbuild
   13: 
   14: 
   15: @pytest.fixture
   16: def get_module(tmp_path):
   17:     """ Add a memory policy that returns a false pointer 64 bytes into the
   18:     actual allocation, and fill the prefix with some text. Then check at each
   19:     memory manipulation that the prefix exists, to make sure all alloc/realloc/
   20:     free/calloc go via the functions here.
   21:     """
   22:     if sys.platform.startswith('cygwin'):
   23:         pytest.skip('link fails on cygwin')
   24:     if IS_WASM:
   25:         pytest.skip("Can't build module inside Wasm")
   26:     if IS_EDITABLE:
   27:         pytest.skip("Can't build module for editable install")
   28: 
   29:     functions = [
   30:         ("get_default_policy", "METH_NOARGS", """
   31:              Py_INCREF(PyDataMem_DefaultHandler);
   32:              return PyDataMem_DefaultHandler;
   33:          """),
   34:         ("set_secret_data_policy", "METH_NOARGS", """
   35:              PyObject *secret_data =
   36:                  PyCapsule_New(&secret_data_handler, "mem_handler", NULL);
   37:              if (secret_data == NULL) {
   38:                  return NULL;
   39:              }
   40:              PyObject *old = PyDataMem_SetHandler(secret_data);
   41:              Py_DECREF(secret_data);
   42:              return old;
   43:          """),
   44:         ("set_wrong_capsule_name_data_policy", "METH_NOARGS", """
   45:              PyObject *wrong_name_capsule =
   46:                  PyCapsule_New(&secret_data_handler, "not_mem_handler", NULL);
   47:              if (wrong_name_capsule == NULL) {
   48:                  return NULL;
   49:              }
   50:              PyObject *old = PyDataMem_SetHandler(wrong_name_capsule);
   51:              Py_DECREF(wrong_name_capsule);
   52:              return old;
   53:          """),
   54:         ("set_old_policy", "METH_O", """
   55:              PyObject *old;
   56:              if (args != NULL && PyCapsule_CheckExact(args)) {
   57:                  old = PyDataMem_SetHandler(args);
   58:              }
   59:              else {
   60:                  old = PyDataMem_SetHandler(NULL);
   61:              }
   62:              return old;
   63:          """),
   64:         ("get_array", "METH_NOARGS", """
   65:             char *buf = (char *)malloc(20);
   66:             npy_intp dims[1];
   67:             dims[0] = 20;
   68:             PyArray_Descr *descr =  PyArray_DescrNewFromType(NPY_UINT8);
   69:             return PyArray_NewFromDescr(&PyArray_Type, descr, 1, dims, NULL,
   70:                                         buf, NPY_ARRAY_WRITEABLE, NULL);
   71:          """),
   72:         ("set_own", "METH_O", """
   73:             if (!PyArray_Check(args)) {
   74:                 PyErr_SetString(PyExc_ValueError,
   75:                              "need an ndarray");
   76:                 return NULL;
   77:             }
   78:             PyArray_ENABLEFLAGS((PyArrayObject*)args, NPY_ARRAY_OWNDATA);
   79:             // Maybe try this too?
   80:             // PyArray_BASE(PyArrayObject *)args) = NULL;
   81:             Py_RETURN_NONE;
   82:          """),
   83:         ("get_array_with_base", "METH_NOARGS", """
   84:             char *buf = (char *)malloc(20);
   85:             npy_intp dims[1];
   86:             dims[0] = 20;
   87:             PyArray_Descr *descr =  PyArray_DescrNewFromType(NPY_UINT8);
   88:             PyObject *arr = PyArray_NewFromDescr(&PyArray_Type, descr, 1, dims,
   89:                                                  NULL, buf,
   90:                                                  NPY_ARRAY_WRITEABLE, NULL);
   91:             if (arr == NULL) return NULL;
   92:             PyObject *obj = PyCapsule_New(buf, "buf capsule",
   93:                                           (PyCapsule_Destructor)&warn_on_free);
   94:             if (obj == NULL) {
   95:                 Py_DECREF(arr);
   96:                 return NULL;
   97:             }
   98:             if (PyArray_SetBaseObject((PyArrayObject *)arr, obj) < 0) {
   99:                 Py_DECREF(arr);
  100:                 Py_DECREF(obj);
  101:                 return NULL;
  102:             }
  103:             return arr;
  104: 
  105:          """),
  106:     ]
  107:     prologue = '''
  108:         #define NPY_TARGET_VERSION NPY_1_22_API_VERSION
  109:         #define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION
  110:         #include <numpy/arrayobject.h>
  111:         /*
  112:          * This struct allows the dynamic configuration of the allocator funcs
  113:          * of the `secret_data_allocator`. It is provided here for
  114:          * demonstration purposes, as a valid `ctx` use-case scenario.
  115:          */
  116:         typedef struct {
  117:             void *(*malloc)(size_t);
  118:             void *(*calloc)(size_t, size_t);
  119:             void *(*realloc)(void *, size_t);
  120:             void (*free)(void *);
  121:         } SecretDataAllocatorFuncs;
  122: 
  123:         NPY_NO_EXPORT void *
  124:         shift_alloc(void *ctx, size_t sz) {
  125:             SecretDataAllocatorFuncs *funcs = (SecretDataAllocatorFuncs *)ctx;
  126:             char *real = (char *)funcs->malloc(sz + 64);
  127:             if (real == NULL) {
  128:                 return NULL;
  129:             }
  130:             snprintf(real, 64, "originally allocated %ld", (unsigned long)sz);
  131:             return (void *)(real + 64);
  132:         }
  133:         NPY_NO_EXPORT void *
  134:         shift_zero(void *ctx, size_t sz, size_t cnt) {
  135:             SecretDataAllocatorFuncs *funcs = (SecretDataAllocatorFuncs *)ctx;
  136:             char *real = (char *)funcs->calloc(sz + 64, cnt);
  137:             if (real == NULL) {
  138:                 return NULL;
  139:             }
  140:             snprintf(real, 64, "originally allocated %ld via zero",
  141:                      (unsigned long)sz);
  142:             return (void *)(real + 64);
  143:         }
  144:         NPY_NO_EXPORT void
  145:         shift_free(void *ctx, void * p, npy_uintp sz) {
  146:             SecretDataAllocatorFuncs *funcs = (SecretDataAllocatorFuncs *)ctx;
  147:             if (p == NULL) {
  148:                 return ;
  149:             }
  150:             char *real = (char *)p - 64;
  151:             if (strncmp(real, "originally allocated", 20) != 0) {
  152:                 fprintf(stdout, "uh-oh, unmatched shift_free, "
  153:                         "no appropriate prefix\\n");
  154:                 /* Make C runtime crash by calling free on the wrong address */
  155:                 funcs->free((char *)p + 10);
  156:                 /* funcs->free(real); */
  157:             }
  158:             else {
  159:                 npy_uintp i = (npy_uintp)atoi(real +20);
  160:                 if (i != sz) {
  161:                     fprintf(stderr, "uh-oh, unmatched shift_free"
  162:                             "(ptr, %ld) but allocated %ld\\n", sz, i);
  163:                     /* This happens in some places, only print */
  164:                     funcs->free(real);
  165:                 }
  166:                 else {
  167:                     funcs->free(real);
  168:                 }
  169:             }
  170:         }
  171:         NPY_NO_EXPORT void *
  172:         shift_realloc(void *ctx, void * p, npy_uintp sz) {
  173:             SecretDataAllocatorFuncs *funcs = (SecretDataAllocatorFuncs *)ctx;
  174:             if (p != NULL) {
  175:                 char *real = (char *)p - 64;
  176:                 if (strncmp(real, "originally allocated", 20) != 0) {
  177:                     fprintf(stdout, "uh-oh, unmatched shift_realloc\\n");
  178:                     return realloc(p, sz);
  179:                 }
  180:                 return (void *)((char *)funcs->realloc(real, sz + 64) + 64);
  181:             }
  182:             else {
  183:                 char *real = (char *)funcs->realloc(p, sz + 64);
  184:                 if (real == NULL) {
  185:                     return NULL;
  186:                 }
  187:                 snprintf(real, 64, "originally allocated "
  188:                          "%ld  via realloc", (unsigned long)sz);
  189:                 return (void *)(real + 64);
  190:             }
  191:         }
  192:         /* As an example, we use the standard {m|c|re}alloc/free funcs. */
  193:         static SecretDataAllocatorFuncs secret_data_handler_ctx = {
  194:             malloc,
  195:             calloc,
  196:             realloc,
  197:             free
  198:         };
  199:         static PyDataMem_Handler secret_data_handler = {
  200:             "secret_data_allocator",
  201:             1,
  202:             {
  203:                 &secret_data_handler_ctx, /* ctx */
  204:                 shift_alloc,              /* malloc */
  205:                 shift_zero,               /* calloc */
  206:                 shift_realloc,            /* realloc */
  207:                 shift_free                /* free */
  208:             }
  209:         };
  210:         void warn_on_free(void *capsule) {
  211:             PyErr_WarnEx(PyExc_UserWarning, "in warn_on_free", 1);
  212:             void * obj = PyCapsule_GetPointer(capsule,
  213:                                               PyCapsule_GetName(capsule));
  214:             free(obj);
  215:         };
  216:         '''
  217:     more_init = "import_array();"
  218:     try:
  219:         import mem_policy
  220:         return mem_policy
  221:     except ImportError:
  222:         pass
  223:     # if it does not exist, build and load it
  224:     if sysconfig.get_platform() == "win-arm64":
  225:         pytest.skip("Meson unable to find MSVC linker on win-arm64")
  226:     return extbuild.build_and_import_extension('mem_policy',
  227:                                                functions,
  228:                                                prologue=prologue,
  229:                                                include_dirs=[np.get_include()],
  230:                                                build_dir=tmp_path,
  231:                                                more_init=more_init)
  232: 
  233: 
  234: def test_set_policy(get_module):
  235: 
  236:     get_handler_name = np._core.multiarray.get_handler_name
  237:     get_handler_version = np._core.multiarray.get_handler_version
  238:     orig_policy_name = get_handler_name()
  239: 
  240:     a = np.arange(10).reshape((2, 5))  # a doesn't own its own data
  241:     assert get_handler_name(a) is None
  242:     assert get_handler_version(a) is None
  243:     assert get_handler_name(a.base) == orig_policy_name
  244:     assert get_handler_version(a.base) == 1
  245: 
  246:     orig_policy = get_module.set_secret_data_policy()
  247: 
  248:     b = np.arange(10).reshape((2, 5))  # b doesn't own its own data
  249:     assert get_handler_name(b) is None
  250:     assert get_handler_version(b) is None
  251:     assert get_handler_name(b.base) == 'secret_data_allocator'
  252:     assert get_handler_version(b.base) == 1
  253: 
  254:     if orig_policy_name == 'default_allocator':
  255:         get_module.set_old_policy(None)  # tests PyDataMem_SetHandler(NULL)
  256:         assert get_handler_name() == 'default_allocator'
  257:     else:
  258:         get_module.set_old_policy(orig_policy)
  259:         assert get_handler_name() == orig_policy_name
  260: 
  261:     with pytest.raises(ValueError,
  262:                        match="Capsule must be named 'mem_handler'"):
  263:         get_module.set_wrong_capsule_name_data_policy()
  264: 
  265: 
  266: def test_default_policy_singleton(get_module):
  267:     get_handler_name = np._core.multiarray.get_handler_name
  268: 
  269:     # set the policy to default
  270:     orig_policy = get_module.set_old_policy(None)
  271: 
  272:     assert get_handler_name() == 'default_allocator'
  273: 
  274:     # re-set the policy to default
  275:     def_policy_1 = get_module.set_old_policy(None)
  276: 
  277:     assert get_handler_name() == 'default_allocator'
  278: 
  279:     # set the policy to original
  280:     def_policy_2 = get_module.set_old_policy(orig_policy)
  281: 
  282:     # since default policy is a singleton,
  283:     # these should be the same object
  284:     assert def_policy_1 is def_policy_2 is get_module.get_default_policy()
  285: 
  286: 
  287: def test_policy_propagation(get_module):
  288:     # The memory policy goes hand-in-hand with flags.owndata
  289: 
  290:     class MyArr(np.ndarray):
  291:         pass
  292: 
  293:     get_handler_name = np._core.multiarray.get_handler_name
  294:     orig_policy_name = get_handler_name()
  295:     a = np.arange(10).view(MyArr).reshape((2, 5))
  296:     assert get_handler_name(a) is None
  297:     assert a.flags.owndata is False
  298: 
  299:     assert get_handler_name(a.base) is None
  300:     assert a.base.flags.owndata is False
  301: 
  302:     assert get_handler_name(a.base.base) == orig_policy_name
  303:     assert a.base.base.flags.owndata is True
  304: 
  305: 
  306: async def concurrent_context1(get_module, orig_policy_name, event):
  307:     if orig_policy_name == 'default_allocator':
  308:         get_module.set_secret_data_policy()
  309:         assert get_handler_name() == 'secret_data_allocator'
  310:     else:
  311:         get_module.set_old_policy(None)
  312:         assert get_handler_name() == 'default_allocator'
  313:     event.set()
  314: 
  315: 
  316: async def concurrent_context2(get_module, orig_policy_name, event):
  317:     await event.wait()
  318:     # the policy is not affected by changes in parallel contexts
  319:     assert get_handler_name() == orig_policy_name
  320:     # change policy in the child context
  321:     if orig_policy_name == 'default_allocator':
  322:         get_module.set_secret_data_policy()
  323:         assert get_handler_name() == 'secret_data_allocator'
  324:     else:
  325:         get_module.set_old_policy(None)
  326:         assert get_handler_name() == 'default_allocator'
  327: 
  328: 
  329: async def async_test_context_locality(get_module):
  330:     orig_policy_name = np._core.multiarray.get_handler_name()
  331: 
  332:     event = asyncio.Event()
  333:     # the child contexts inherit the parent policy
  334:     concurrent_task1 = asyncio.create_task(
  335:         concurrent_context1(get_module, orig_policy_name, event))
  336:     concurrent_task2 = asyncio.create_task(
  337:         concurrent_context2(get_module, orig_policy_name, event))
  338:     await concurrent_task1
  339:     await concurrent_task2
  340: 
  341:     # the parent context is not affected by child policy changes
  342:     assert np._core.multiarray.get_handler_name() == orig_policy_name
  343: 
  344: 
  345: def test_context_locality(get_module):
  346:     if (sys.implementation.name == 'pypy'
  347:             and sys.pypy_version_info[:3] < (7, 3, 6)):
  348:         pytest.skip('no context-locality support in PyPy < 7.3.6')
  349:     asyncio.run(async_test_context_locality(get_module))
  350: 
  351: 
  352: def concurrent_thread1(get_module, event):
  353:     get_module.set_secret_data_policy()
  354:     assert np._core.multiarray.get_handler_name() == 'secret_data_allocator'
  355:     event.set()
  356: 
  357: 
  358: def concurrent_thread2(get_module, event):
  359:     event.wait()
  360:     # the policy is not affected by changes in parallel threads
  361:     assert np._core.multiarray.get_handler_name() == 'default_allocator'
  362:     # change policy in the child thread
  363:     get_module.set_secret_data_policy()
  364: 
  365: 
  366: def test_thread_locality(get_module):
  367:     orig_policy_name = np._core.multiarray.get_handler_name()
  368: 
  369:     event = threading.Event()
  370:     # the child threads do not inherit the parent policy
  371:     concurrent_task1 = threading.Thread(target=concurrent_thread1,
  372:                                         args=(get_module, event))
  373:     concurrent_task2 = threading.Thread(target=concurrent_thread2,
  374:                                         args=(get_module, event))
  375:     concurrent_task1.start()
  376:     concurrent_task2.start()
  377:     concurrent_task1.join()
  378:     concurrent_task2.join()
  379: 
  380:     # the parent thread is not affected by child policy changes
  381:     assert np._core.multiarray.get_handler_name() == orig_policy_name
  382: 
  383: 
  384: @pytest.mark.skip(reason="too slow, see gh-23975")
  385: def test_new_policy(get_module):
  386:     a = np.arange(10)
  387:     orig_policy_name = np._core.multiarray.get_handler_name(a)
  388: 
  389:     orig_policy = get_module.set_secret_data_policy()
  390: 
  391:     b = np.arange(10)
  392:     assert np._core.multiarray.get_handler_name(b) == 'secret_data_allocator'
  393: 
  394:     # test array manipulation. This is slow
  395:     if orig_policy_name == 'default_allocator':
  396:         # when the np._core.test tests recurse into this test, the
  397:         # policy will be set so this "if" will be false, preventing
  398:         # infinite recursion
  399:         #
  400:         # if needed, debug this by
  401:         # - running tests with -- -s (to not capture stdout/stderr
  402:         # - setting verbose=2
  403:         # - setting extra_argv=['-vv'] here
  404:         assert np._core.test('full', verbose=1, extra_argv=[])
  405:         # also try the ma tests, the pickling test is quite tricky
  406:         assert np.ma.test('full', verbose=1, extra_argv=[])
  407: 
  408:     get_module.set_old_policy(orig_policy)
  409: 
  410:     c = np.arange(10)
  411:     assert np._core.multiarray.get_handler_name(c) == orig_policy_name
  412: 
  413: 
  414: @pytest.mark.xfail(sys.implementation.name == "pypy",
  415:                    reason=("bad interaction between getenv and "
  416:                            "os.environ inside pytest"))
  417: @pytest.mark.parametrize("policy", ["0", "1", None])
  418: def test_switch_owner(get_module, policy):
  419:     a = get_module.get_array()
  420:     assert np._core.multiarray.get_handler_name(a) is None
  421:     get_module.set_own(a)
  422: 
  423:     if policy is None:
  424:         # See what we expect to be set based on the env variable
  425:         policy = os.getenv("NUMPY_WARN_IF_NO_MEM_POLICY", "0") == "1"
  426:         oldval = None
  427:     else:
  428:         policy = policy == "1"
  429:         oldval = np._core._multiarray_umath._set_numpy_warn_if_no_mem_policy(
  430:             policy)
  431:     try:
  432:         # The policy should be NULL, so we have to assume we can call
  433:         # "free".  A warning is given if the policy == "1"
  434:         if policy:
  435:             with assert_warns(RuntimeWarning) as w:
  436:                 del a
  437:                 gc.collect()
  438:         else:
  439:             del a
  440:             gc.collect()
  441: 
  442:     finally:
  443:         if oldval is not None:
  444:             np._core._multiarray_umath._set_numpy_warn_if_no_mem_policy(oldval)
  445: 
  446: 
  447: def test_owner_is_base(get_module):
  448:     a = get_module.get_array_with_base()
  449:     with pytest.warns(UserWarning, match='warn_on_free'):
  450:         del a
  451:         gc.collect()
  452:         gc.collect()
