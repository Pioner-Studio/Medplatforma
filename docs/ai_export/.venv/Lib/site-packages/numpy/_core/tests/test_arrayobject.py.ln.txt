    1: import pytest
    2: 
    3: import numpy as np
    4: from numpy.testing import assert_array_equal
    5: 
    6: 
    7: def test_matrix_transpose_raises_error_for_1d():
    8:     msg = "matrix transpose with ndim < 2 is undefined"
    9:     arr = np.arange(48)
   10:     with pytest.raises(ValueError, match=msg):
   11:         arr.mT
   12: 
   13: 
   14: def test_matrix_transpose_equals_transpose_2d():
   15:     arr = np.arange(48).reshape((6, 8))
   16:     assert_array_equal(arr.T, arr.mT)
   17: 
   18: 
   19: ARRAY_SHAPES_TO_TEST = (
   20:     (5, 2),
   21:     (5, 2, 3),
   22:     (5, 2, 3, 4),
   23: )
   24: 
   25: 
   26: @pytest.mark.parametrize("shape", ARRAY_SHAPES_TO_TEST)
   27: def test_matrix_transpose_equals_swapaxes(shape):
   28:     num_of_axes = len(shape)
   29:     vec = np.arange(shape[-1])
   30:     arr = np.broadcast_to(vec, shape)
   31:     tgt = np.swapaxes(arr, num_of_axes - 2, num_of_axes - 1)
   32:     mT = arr.mT
   33:     assert_array_equal(tgt, mT)
   34: 
   35: 
   36: class MyArr(np.ndarray):
   37:     def __array_wrap__(self, arr, context=None, return_scalar=None):
   38:         return super().__array_wrap__(arr, context, return_scalar)
   39: 
   40: 
   41: class MyArrNoWrap(np.ndarray):
   42:     pass
   43: 
   44: 
   45: @pytest.mark.parametrize("subclass_self", [np.ndarray, MyArr, MyArrNoWrap])
   46: @pytest.mark.parametrize("subclass_arr", [np.ndarray, MyArr, MyArrNoWrap])
   47: def test_array_wrap(subclass_self, subclass_arr):
   48:     # NumPy should allow `__array_wrap__` to be called on arrays, it's logic
   49:     # is designed in a way that:
   50:     #
   51:     # * Subclasses never return scalars by default (to preserve their
   52:     #   information).  They can choose to if they wish.
   53:     # * NumPy returns scalars, if `return_scalar` is passed as True to allow
   54:     #   manual calls to `arr.__array_wrap__` to do the right thing.
   55:     # * The type of the input should be ignored (it should be a base-class
   56:     #   array, but I am not sure this is guaranteed).
   57: 
   58:     arr = np.arange(3).view(subclass_self)
   59: 
   60:     arr0d = np.array(3, dtype=np.int8).view(subclass_arr)
   61:     # With third argument True, ndarray allows "decay" to scalar.
   62:     # (I don't think NumPy would pass `None`, but it seems clear to support)
   63:     if subclass_self is np.ndarray:
   64:         assert type(arr.__array_wrap__(arr0d, None, True)) is np.int8
   65:     else:
   66:         assert type(arr.__array_wrap__(arr0d, None, True)) is type(arr)
   67: 
   68:     # Otherwise, result should be viewed as the subclass
   69:     assert type(arr.__array_wrap__(arr0d)) is type(arr)
   70:     assert type(arr.__array_wrap__(arr0d, None, None)) is type(arr)
   71:     assert type(arr.__array_wrap__(arr0d, None, False)) is type(arr)
   72: 
   73:     # Non 0-D array can't be converted to scalar, so we ignore that
   74:     arr1d = np.array([3], dtype=np.int8).view(subclass_arr)
   75:     assert type(arr.__array_wrap__(arr1d, None, True)) is type(arr)
