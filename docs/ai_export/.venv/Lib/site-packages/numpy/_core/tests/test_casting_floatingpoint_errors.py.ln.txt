    1: import pytest
    2: from pytest import param
    3: 
    4: import numpy as np
    5: from numpy.testing import IS_WASM
    6: 
    7: 
    8: def values_and_dtypes():
    9:     """
   10:     Generate value+dtype pairs that generate floating point errors during
   11:     casts.  The invalid casts to integers will generate "invalid" value
   12:     warnings, the float casts all generate "overflow".
   13: 
   14:     (The Python int/float paths don't need to get tested in all the same
   15:     situations, but it does not hurt.)
   16:     """
   17:     # Casting to float16:
   18:     yield param(70000, "float16", id="int-to-f2")
   19:     yield param("70000", "float16", id="str-to-f2")
   20:     yield param(70000.0, "float16", id="float-to-f2")
   21:     yield param(np.longdouble(70000.), "float16", id="longdouble-to-f2")
   22:     yield param(np.float64(70000.), "float16", id="double-to-f2")
   23:     yield param(np.float32(70000.), "float16", id="float-to-f2")
   24:     # Casting to float32:
   25:     yield param(10**100, "float32", id="int-to-f4")
   26:     yield param(1e100, "float32", id="float-to-f2")
   27:     yield param(np.longdouble(1e300), "float32", id="longdouble-to-f2")
   28:     yield param(np.float64(1e300), "float32", id="double-to-f2")
   29:     # Casting to float64:
   30:     # If longdouble is double-double, its max can be rounded down to the double
   31:     # max.  So we correct the double spacing (a bit weird, admittedly):
   32:     max_ld = np.finfo(np.longdouble).max
   33:     spacing = np.spacing(np.nextafter(np.finfo("f8").max, 0))
   34:     if max_ld - spacing > np.finfo("f8").max:
   35:         yield param(np.finfo(np.longdouble).max, "float64",
   36:                     id="longdouble-to-f8")
   37: 
   38:     # Cast to complex32:
   39:     yield param(2e300, "complex64", id="float-to-c8")
   40:     yield param(2e300 + 0j, "complex64", id="complex-to-c8")
   41:     yield param(2e300j, "complex64", id="complex-to-c8")
   42:     yield param(np.longdouble(2e300), "complex64", id="longdouble-to-c8")
   43: 
   44:     # Invalid float to integer casts:
   45:     with np.errstate(over="ignore"):
   46:         for to_dt in np.typecodes["AllInteger"]:
   47:             for value in [np.inf, np.nan]:
   48:                 for from_dt in np.typecodes["AllFloat"]:
   49:                     from_dt = np.dtype(from_dt)
   50:                     from_val = from_dt.type(value)
   51: 
   52:                     yield param(from_val, to_dt, id=f"{from_val}-to-{to_dt}")
   53: 
   54: 
   55: def check_operations(dtype, value):
   56:     """
   57:     There are many dedicated paths in NumPy which cast and should check for
   58:     floating point errors which occurred during those casts.
   59:     """
   60:     if dtype.kind != 'i':
   61:         # These assignments use the stricter setitem logic:
   62:         def assignment():
   63:             arr = np.empty(3, dtype=dtype)
   64:             arr[0] = value
   65: 
   66:         yield assignment
   67: 
   68:         def fill():
   69:             arr = np.empty(3, dtype=dtype)
   70:             arr.fill(value)
   71: 
   72:         yield fill
   73: 
   74:     def copyto_scalar():
   75:         arr = np.empty(3, dtype=dtype)
   76:         np.copyto(arr, value, casting="unsafe")
   77: 
   78:     yield copyto_scalar
   79: 
   80:     def copyto():
   81:         arr = np.empty(3, dtype=dtype)
   82:         np.copyto(arr, np.array([value, value, value]), casting="unsafe")
   83: 
   84:     yield copyto
   85: 
   86:     def copyto_scalar_masked():
   87:         arr = np.empty(3, dtype=dtype)
   88:         np.copyto(arr, value, casting="unsafe",
   89:                   where=[True, False, True])
   90: 
   91:     yield copyto_scalar_masked
   92: 
   93:     def copyto_masked():
   94:         arr = np.empty(3, dtype=dtype)
   95:         np.copyto(arr, np.array([value, value, value]), casting="unsafe",
   96:                   where=[True, False, True])
   97: 
   98:     yield copyto_masked
   99: 
  100:     def direct_cast():
  101:         np.array([value, value, value]).astype(dtype)
  102: 
  103:     yield direct_cast
  104: 
  105:     def direct_cast_nd_strided():
  106:         arr = np.full((5, 5, 5), fill_value=value)[:, ::2, :]
  107:         arr.astype(dtype)
  108: 
  109:     yield direct_cast_nd_strided
  110: 
  111:     def boolean_array_assignment():
  112:         arr = np.empty(3, dtype=dtype)
  113:         arr[[True, False, True]] = np.array([value, value])
  114: 
  115:     yield boolean_array_assignment
  116: 
  117:     def integer_array_assignment():
  118:         arr = np.empty(3, dtype=dtype)
  119:         values = np.array([value, value])
  120: 
  121:         arr[[0, 1]] = values
  122: 
  123:     yield integer_array_assignment
  124: 
  125:     def integer_array_assignment_with_subspace():
  126:         arr = np.empty((5, 3), dtype=dtype)
  127:         values = np.array([value, value, value])
  128: 
  129:         arr[[0, 2]] = values
  130: 
  131:     yield integer_array_assignment_with_subspace
  132: 
  133:     def flat_assignment():
  134:         arr = np.empty((3,), dtype=dtype)
  135:         values = np.array([value, value, value])
  136:         arr.flat[:] = values
  137: 
  138:     yield flat_assignment
  139: 
  140: @pytest.mark.skipif(IS_WASM, reason="no wasm fp exception support")
  141: @pytest.mark.parametrize(["value", "dtype"], values_and_dtypes())
  142: @pytest.mark.filterwarnings("ignore::numpy.exceptions.ComplexWarning")
  143: def test_floatingpoint_errors_casting(dtype, value):
  144:     dtype = np.dtype(dtype)
  145:     for operation in check_operations(dtype, value):
  146:         dtype = np.dtype(dtype)
  147: 
  148:         match = "invalid" if dtype.kind in 'iu' else "overflow"
  149:         with pytest.warns(RuntimeWarning, match=match):
  150:             operation()
  151: 
  152:         with np.errstate(all="raise"):
  153:             with pytest.raises(FloatingPointError, match=match):
  154:                 operation()
