    1: """
    2: The tests exercise the casting machinery in a more low-level manner.
    3: The reason is mostly to test a new implementation of the casting machinery.
    4: 
    5: Unlike most tests in NumPy, these are closer to unit-tests rather
    6: than integration tests.
    7: """
    8: 
    9: import ctypes
   10: import enum
   11: import random
   12: import textwrap
   13: 
   14: import pytest
   15: from numpy._core._multiarray_umath import _get_castingimpl as get_castingimpl
   16: 
   17: import numpy as np
   18: from numpy.lib.stride_tricks import as_strided
   19: from numpy.testing import assert_array_equal
   20: 
   21: # Simple skips object, parametric and long double (unsupported by struct)
   22: simple_dtypes = "?bhilqBHILQefdFD"
   23: if np.dtype("l").itemsize != np.dtype("q").itemsize:
   24:     # Remove l and L, the table was generated with 64bit linux in mind.
   25:     simple_dtypes = simple_dtypes.replace("l", "").replace("L", "")
   26: simple_dtypes = [type(np.dtype(c)) for c in simple_dtypes]
   27: 
   28: 
   29: def simple_dtype_instances():
   30:     for dtype_class in simple_dtypes:
   31:         dt = dtype_class()
   32:         yield pytest.param(dt, id=str(dt))
   33:         if dt.byteorder != "|":
   34:             dt = dt.newbyteorder()
   35:             yield pytest.param(dt, id=str(dt))
   36: 
   37: 
   38: def get_expected_stringlength(dtype):
   39:     """Returns the string length when casting the basic dtypes to strings.
   40:     """
   41:     if dtype == np.bool:
   42:         return 5
   43:     if dtype.kind in "iu":
   44:         if dtype.itemsize == 1:
   45:             length = 3
   46:         elif dtype.itemsize == 2:
   47:             length = 5
   48:         elif dtype.itemsize == 4:
   49:             length = 10
   50:         elif dtype.itemsize == 8:
   51:             length = 20
   52:         else:
   53:             raise AssertionError(f"did not find expected length for {dtype}")
   54: 
   55:         if dtype.kind == "i":
   56:             length += 1  # adds one character for the sign
   57: 
   58:         return length
   59: 
   60:     # Note: Can't do dtype comparison for longdouble on windows
   61:     if dtype.char == "g":
   62:         return 48
   63:     elif dtype.char == "G":
   64:         return 48 * 2
   65:     elif dtype.kind == "f":
   66:         return 32  # also for half apparently.
   67:     elif dtype.kind == "c":
   68:         return 32 * 2
   69: 
   70:     raise AssertionError(f"did not find expected length for {dtype}")
   71: 
   72: 
   73: class Casting(enum.IntEnum):
   74:     no = 0
   75:     equiv = 1
   76:     safe = 2
   77:     same_kind = 3
   78:     unsafe = 4
   79: 
   80: 
   81: def _get_cancast_table():
   82:     table = textwrap.dedent("""
   83:         X ? b h i l q B H I L Q e f d g F D G S U V O M m
   84:         ? # = = = = = = = = = = = = = = = = = = = = = . =
   85:         b . # = = = = . . . . . = = = = = = = = = = = . =
   86:         h . ~ # = = = . . . . . ~ = = = = = = = = = = . =
   87:         i . ~ ~ # = = . . . . . ~ ~ = = ~ = = = = = = . =
   88:         l . ~ ~ ~ # # . . . . . ~ ~ = = ~ = = = = = = . =
   89:         q . ~ ~ ~ # # . . . . . ~ ~ = = ~ = = = = = = . =
   90:         B . ~ = = = = # = = = = = = = = = = = = = = = . =
   91:         H . ~ ~ = = = ~ # = = = ~ = = = = = = = = = = . =
   92:         I . ~ ~ ~ = = ~ ~ # = = ~ ~ = = ~ = = = = = = . =
   93:         L . ~ ~ ~ ~ ~ ~ ~ ~ # # ~ ~ = = ~ = = = = = = . ~
   94:         Q . ~ ~ ~ ~ ~ ~ ~ ~ # # ~ ~ = = ~ = = = = = = . ~
   95:         e . . . . . . . . . . . # = = = = = = = = = = . .
   96:         f . . . . . . . . . . . ~ # = = = = = = = = = . .
   97:         d . . . . . . . . . . . ~ ~ # = ~ = = = = = = . .
   98:         g . . . . . . . . . . . ~ ~ ~ # ~ ~ = = = = = . .
   99:         F . . . . . . . . . . . . . . . # = = = = = = . .
  100:         D . . . . . . . . . . . . . . . ~ # = = = = = . .
  101:         G . . . . . . . . . . . . . . . ~ ~ # = = = = . .
  102:         S . . . . . . . . . . . . . . . . . . # = = = . .
  103:         U . . . . . . . . . . . . . . . . . . . # = = . .
  104:         V . . . . . . . . . . . . . . . . . . . . # = . .
  105:         O . . . . . . . . . . . . . . . . . . . . = # . .
  106:         M . . . . . . . . . . . . . . . . . . . . = = # .
  107:         m . . . . . . . . . . . . . . . . . . . . = = . #
  108:         """).strip().split("\n")
  109:     dtypes = [type(np.dtype(c)) for c in table[0][2::2]]
  110: 
  111:     convert_cast = {".": Casting.unsafe, "~": Casting.same_kind,
  112:                     "=": Casting.safe, "#": Casting.equiv,
  113:                     " ": -1}
  114: 
  115:     cancast = {}
  116:     for from_dt, row in zip(dtypes, table[1:]):
  117:         cancast[from_dt] = {}
  118:         for to_dt, c in zip(dtypes, row[2::2]):
  119:             cancast[from_dt][to_dt] = convert_cast[c]
  120: 
  121:     return cancast
  122: 
  123: 
  124: CAST_TABLE = _get_cancast_table()
  125: 
  126: 
  127: class TestChanges:
  128:     """
  129:     These test cases exercise some behaviour changes
  130:     """
  131:     @pytest.mark.parametrize("string", ["S", "U"])
  132:     @pytest.mark.parametrize("floating", ["e", "f", "d", "g"])
  133:     def test_float_to_string(self, floating, string):
  134:         assert np.can_cast(floating, string)
  135:         # 100 is long enough to hold any formatted floating
  136:         assert np.can_cast(floating, f"{string}100")
  137: 
  138:     def test_to_void(self):
  139:         # But in general, we do consider these safe:
  140:         assert np.can_cast("d", "V")
  141:         assert np.can_cast("S20", "V")
  142: 
  143:         # Do not consider it a safe cast if the void is too smaller:
  144:         assert not np.can_cast("d", "V1")
  145:         assert not np.can_cast("S20", "V1")
  146:         assert not np.can_cast("U1", "V1")
  147:         # Structured to unstructured is just like any other:
  148:         assert np.can_cast("d,i", "V", casting="same_kind")
  149:         # Unstructured void to unstructured is actually no cast at all:
  150:         assert np.can_cast("V3", "V", casting="no")
  151:         assert np.can_cast("V0", "V", casting="no")
  152: 
  153: 
  154: class TestCasting:
  155:     size = 1500  # Best larger than NPY_LOWLEVEL_BUFFER_BLOCKSIZE * itemsize
  156: 
  157:     def get_data(self, dtype1, dtype2):
  158:         if dtype2 is None or dtype1.itemsize >= dtype2.itemsize:
  159:             length = self.size // dtype1.itemsize
  160:         else:
  161:             length = self.size // dtype2.itemsize
  162: 
  163:         # Assume that the base array is well enough aligned for all inputs.
  164:         arr1 = np.empty(length, dtype=dtype1)
  165:         assert arr1.flags.c_contiguous
  166:         assert arr1.flags.aligned
  167: 
  168:         values = [random.randrange(-128, 128) for _ in range(length)]
  169: 
  170:         for i, value in enumerate(values):
  171:             # Use item assignment to ensure this is not using casting:
  172:             if value < 0 and dtype1.kind == "u":
  173:                 # Manually rollover unsigned integers (-1 -> int.max)
  174:                 value = value + np.iinfo(dtype1).max + 1
  175:             arr1[i] = value
  176: 
  177:         if dtype2 is None:
  178:             if dtype1.char == "?":
  179:                 values = [bool(v) for v in values]
  180:             return arr1, values
  181: 
  182:         if dtype2.char == "?":
  183:             values = [bool(v) for v in values]
  184: 
  185:         arr2 = np.empty(length, dtype=dtype2)
  186:         assert arr2.flags.c_contiguous
  187:         assert arr2.flags.aligned
  188: 
  189:         for i, value in enumerate(values):
  190:             # Use item assignment to ensure this is not using casting:
  191:             if value < 0 and dtype2.kind == "u":
  192:                 # Manually rollover unsigned integers (-1 -> int.max)
  193:                 value = value + np.iinfo(dtype2).max + 1
  194:             arr2[i] = value
  195: 
  196:         return arr1, arr2, values
  197: 
  198:     def get_data_variation(self, arr1, arr2, aligned=True, contig=True):
  199:         """
  200:         Returns a copy of arr1 that may be non-contiguous or unaligned, and a
  201:         matching array for arr2 (although not a copy).
  202:         """
  203:         if contig:
  204:             stride1 = arr1.dtype.itemsize
  205:             stride2 = arr2.dtype.itemsize
  206:         elif aligned:
  207:             stride1 = 2 * arr1.dtype.itemsize
  208:             stride2 = 2 * arr2.dtype.itemsize
  209:         else:
  210:             stride1 = arr1.dtype.itemsize + 1
  211:             stride2 = arr2.dtype.itemsize + 1
  212: 
  213:         max_size1 = len(arr1) * 3 * arr1.dtype.itemsize + 1
  214:         max_size2 = len(arr2) * 3 * arr2.dtype.itemsize + 1
  215:         from_bytes = np.zeros(max_size1, dtype=np.uint8)
  216:         to_bytes = np.zeros(max_size2, dtype=np.uint8)
  217: 
  218:         # Sanity check that the above is large enough:
  219:         assert stride1 * len(arr1) <= from_bytes.nbytes
  220:         assert stride2 * len(arr2) <= to_bytes.nbytes
  221: 
  222:         if aligned:
  223:             new1 = as_strided(from_bytes[:-1].view(arr1.dtype),
  224:                               arr1.shape, (stride1,))
  225:             new2 = as_strided(to_bytes[:-1].view(arr2.dtype),
  226:                               arr2.shape, (stride2,))
  227:         else:
  228:             new1 = as_strided(from_bytes[1:].view(arr1.dtype),
  229:                               arr1.shape, (stride1,))
  230:             new2 = as_strided(to_bytes[1:].view(arr2.dtype),
  231:                               arr2.shape, (stride2,))
  232: 
  233:         new1[...] = arr1
  234: 
  235:         if not contig:
  236:             # Ensure we did not overwrite bytes that should not be written:
  237:             offset = arr1.dtype.itemsize if aligned else 0
  238:             buf = from_bytes[offset::stride1].tobytes()
  239:             assert buf.count(b"\0") == len(buf)
  240: 
  241:         if contig:
  242:             assert new1.flags.c_contiguous
  243:             assert new2.flags.c_contiguous
  244:         else:
  245:             assert not new1.flags.c_contiguous
  246:             assert not new2.flags.c_contiguous
  247: 
  248:         if aligned:
  249:             assert new1.flags.aligned
  250:             assert new2.flags.aligned
  251:         else:
  252:             assert not new1.flags.aligned or new1.dtype.alignment == 1
  253:             assert not new2.flags.aligned or new2.dtype.alignment == 1
  254: 
  255:         return new1, new2
  256: 
  257:     @pytest.mark.parametrize("from_Dt", simple_dtypes)
  258:     def test_simple_cancast(self, from_Dt):
  259:         for to_Dt in simple_dtypes:
  260:             cast = get_castingimpl(from_Dt, to_Dt)
  261: 
  262:             for from_dt in [from_Dt(), from_Dt().newbyteorder()]:
  263:                 default = cast._resolve_descriptors((from_dt, None))[1][1]
  264:                 assert default == to_Dt()
  265:                 del default
  266: 
  267:                 for to_dt in [to_Dt(), to_Dt().newbyteorder()]:
  268:                     casting, (from_res, to_res), view_off = (
  269:                             cast._resolve_descriptors((from_dt, to_dt)))
  270:                     assert type(from_res) == from_Dt
  271:                     assert type(to_res) == to_Dt
  272:                     if view_off is not None:
  273:                         # If a view is acceptable, this is "no" casting
  274:                         # and byte order must be matching.
  275:                         assert casting == Casting.no
  276:                         # The above table lists this as "equivalent"
  277:                         assert Casting.equiv == CAST_TABLE[from_Dt][to_Dt]
  278:                         # Note that to_res may not be the same as from_dt
  279:                         assert from_res.isnative == to_res.isnative
  280:                     else:
  281:                         if from_Dt == to_Dt:
  282:                             # Note that to_res may not be the same as from_dt
  283:                             assert from_res.isnative != to_res.isnative
  284:                         assert casting == CAST_TABLE[from_Dt][to_Dt]
  285: 
  286:                     if from_Dt is to_Dt:
  287:                         assert from_dt is from_res
  288:                         assert to_dt is to_res
  289: 
  290:     @pytest.mark.filterwarnings("ignore::numpy.exceptions.ComplexWarning")
  291:     @pytest.mark.parametrize("from_dt", simple_dtype_instances())
  292:     def test_simple_direct_casts(self, from_dt):
  293:         """
  294:         This test checks numeric direct casts for dtypes supported also by the
  295:         struct module (plus complex).  It tries to be test a wide range of
  296:         inputs, but skips over possibly undefined behaviour (e.g. int rollover).
  297:         Longdouble and CLongdouble are tested, but only using double precision.
  298: 
  299:         If this test creates issues, it should possibly just be simplified
  300:         or even removed (checking whether unaligned/non-contiguous casts give
  301:         the same results is useful, though).
  302:         """
  303:         for to_dt in simple_dtype_instances():
  304:             to_dt = to_dt.values[0]
  305:             cast = get_castingimpl(type(from_dt), type(to_dt))
  306: 
  307:             casting, (from_res, to_res), view_off = cast._resolve_descriptors(
  308:                 (from_dt, to_dt))
  309: 
  310:             if from_res is not from_dt or to_res is not to_dt:
  311:                 # Do not test this case, it is handled in multiple steps,
  312:                 # each of which should is tested individually.
  313:                 return
  314: 
  315:             safe = casting <= Casting.safe
  316:             del from_res, to_res, casting
  317: 
  318:             arr1, arr2, values = self.get_data(from_dt, to_dt)
  319: 
  320:             cast._simple_strided_call((arr1, arr2))
  321: 
  322:             # Check via python list
  323:             assert arr2.tolist() == values
  324: 
  325:             # Check that the same results are achieved for strided loops
  326:             arr1_o, arr2_o = self.get_data_variation(arr1, arr2, True, False)
  327:             cast._simple_strided_call((arr1_o, arr2_o))
  328: 
  329:             assert_array_equal(arr2_o, arr2)
  330:             assert arr2_o.tobytes() == arr2.tobytes()
  331: 
  332:             # Check if alignment makes a difference, but only if supported
  333:             # and only if the alignment can be wrong
  334:             if ((from_dt.alignment == 1 and to_dt.alignment == 1) or
  335:                     not cast._supports_unaligned):
  336:                 return
  337: 
  338:             arr1_o, arr2_o = self.get_data_variation(arr1, arr2, False, True)
  339:             cast._simple_strided_call((arr1_o, arr2_o))
  340: 
  341:             assert_array_equal(arr2_o, arr2)
  342:             assert arr2_o.tobytes() == arr2.tobytes()
  343: 
  344:             arr1_o, arr2_o = self.get_data_variation(arr1, arr2, False, False)
  345:             cast._simple_strided_call((arr1_o, arr2_o))
  346: 
  347:             assert_array_equal(arr2_o, arr2)
  348:             assert arr2_o.tobytes() == arr2.tobytes()
  349: 
  350:             del arr1_o, arr2_o, cast
  351: 
  352:     @pytest.mark.parametrize("from_Dt", simple_dtypes)
  353:     def test_numeric_to_times(self, from_Dt):
  354:         # We currently only implement contiguous loops, so only need to
  355:         # test those.
  356:         from_dt = from_Dt()
  357: 
  358:         time_dtypes = [np.dtype("M8"), np.dtype("M8[ms]"), np.dtype("M8[4D]"),
  359:                        np.dtype("m8"), np.dtype("m8[ms]"), np.dtype("m8[4D]")]
  360:         for time_dt in time_dtypes:
  361:             cast = get_castingimpl(type(from_dt), type(time_dt))
  362: 
  363:             casting, (from_res, to_res), view_off = cast._resolve_descriptors(
  364:                 (from_dt, time_dt))
  365: 
  366:             assert from_res is from_dt
  367:             assert to_res is time_dt
  368:             del from_res, to_res
  369: 
  370:             assert casting & CAST_TABLE[from_Dt][type(time_dt)]
  371:             assert view_off is None
  372: 
  373:             int64_dt = np.dtype(np.int64)
  374:             arr1, arr2, values = self.get_data(from_dt, int64_dt)
  375:             arr2 = arr2.view(time_dt)
  376:             arr2[...] = np.datetime64("NaT")
  377: 
  378:             if time_dt == np.dtype("M8"):
  379:                 # This is a bit of a strange path, and could probably be removed
  380:                 arr1[-1] = 0  # ensure at least one value is not NaT
  381: 
  382:                 # The cast currently succeeds, but the values are invalid:
  383:                 cast._simple_strided_call((arr1, arr2))
  384:                 with pytest.raises(ValueError):
  385:                     str(arr2[-1])  # e.g. conversion to string fails
  386:                 return
  387: 
  388:             cast._simple_strided_call((arr1, arr2))
  389: 
  390:             assert [int(v) for v in arr2.tolist()] == values
  391: 
  392:             # Check that the same results are achieved for strided loops
  393:             arr1_o, arr2_o = self.get_data_variation(arr1, arr2, True, False)
  394:             cast._simple_strided_call((arr1_o, arr2_o))
  395: 
  396:             assert_array_equal(arr2_o, arr2)
  397:             assert arr2_o.tobytes() == arr2.tobytes()
  398: 
  399:     @pytest.mark.parametrize(
  400:             ["from_dt", "to_dt", "expected_casting", "expected_view_off",
  401:              "nom", "denom"],
  402:             [("M8[ns]", None, Casting.no, 0, 1, 1),
  403:              (str(np.dtype("M8[ns]").newbyteorder()), None,
  404:                   Casting.equiv, None, 1, 1),
  405:              ("M8", "M8[ms]", Casting.safe, 0, 1, 1),
  406:              # should be invalid cast:
  407:              ("M8[ms]", "M8", Casting.unsafe, None, 1, 1),
  408:              ("M8[5ms]", "M8[5ms]", Casting.no, 0, 1, 1),
  409:              ("M8[ns]", "M8[ms]", Casting.same_kind, None, 1, 10**6),
  410:              ("M8[ms]", "M8[ns]", Casting.safe, None, 10**6, 1),
  411:              ("M8[ms]", "M8[7ms]", Casting.same_kind, None, 1, 7),
  412:              ("M8[4D]", "M8[1M]", Casting.same_kind, None, None,
  413:                   # give full values based on NumPy 1.19.x
  414:                   [-2**63, 0, -1, 1314, -1315, 564442610]),
  415:              ("m8[ns]", None, Casting.no, 0, 1, 1),
  416:              (str(np.dtype("m8[ns]").newbyteorder()), None,
  417:                   Casting.equiv, None, 1, 1),
  418:              ("m8", "m8[ms]", Casting.safe, 0, 1, 1),
  419:              # should be invalid cast:
  420:              ("m8[ms]", "m8", Casting.unsafe, None, 1, 1),
  421:              ("m8[5ms]", "m8[5ms]", Casting.no, 0, 1, 1),
  422:              ("m8[ns]", "m8[ms]", Casting.same_kind, None, 1, 10**6),
  423:              ("m8[ms]", "m8[ns]", Casting.safe, None, 10**6, 1),
  424:              ("m8[ms]", "m8[7ms]", Casting.same_kind, None, 1, 7),
  425:              ("m8[4D]", "m8[1M]", Casting.unsafe, None, None,
  426:                   # give full values based on NumPy 1.19.x
  427:                   [-2**63, 0, 0, 1314, -1315, 564442610])])
  428:     def test_time_to_time(self, from_dt, to_dt,
  429:                           expected_casting, expected_view_off,
  430:                           nom, denom):
  431:         from_dt = np.dtype(from_dt)
  432:         if to_dt is not None:
  433:             to_dt = np.dtype(to_dt)
  434: 
  435:         # Test a few values for casting (results generated with NumPy 1.19)
  436:         values = np.array([-2**63, 1, 2**63 - 1, 10000, -10000, 2**32])
  437:         values = values.astype(np.dtype("int64").newbyteorder(from_dt.byteorder))
  438:         assert values.dtype.byteorder == from_dt.byteorder
  439:         assert np.isnat(values.view(from_dt)[0])
  440: 
  441:         DType = type(from_dt)
  442:         cast = get_castingimpl(DType, DType)
  443:         casting, (from_res, to_res), view_off = cast._resolve_descriptors(
  444:                 (from_dt, to_dt))
  445:         assert from_res is from_dt
  446:         assert to_res is to_dt or to_dt is None
  447:         assert casting == expected_casting
  448:         assert view_off == expected_view_off
  449: 
  450:         if nom is not None:
  451:             expected_out = (values * nom // denom).view(to_res)
  452:             expected_out[0] = "NaT"
  453:         else:
  454:             expected_out = np.empty_like(values)
  455:             expected_out[...] = denom
  456:             expected_out = expected_out.view(to_dt)
  457: 
  458:         orig_arr = values.view(from_dt)
  459:         orig_out = np.empty_like(expected_out)
  460: 
  461:         if casting == Casting.unsafe and (to_dt == "m8" or to_dt == "M8"):  # noqa: PLR1714
  462:             # Casting from non-generic to generic units is an error and should
  463:             # probably be reported as an invalid cast earlier.
  464:             with pytest.raises(ValueError):
  465:                 cast._simple_strided_call((orig_arr, orig_out))
  466:             return
  467: 
  468:         for aligned in [True, True]:
  469:             for contig in [True, True]:
  470:                 arr, out = self.get_data_variation(
  471:                         orig_arr, orig_out, aligned, contig)
  472:                 out[...] = 0
  473:                 cast._simple_strided_call((arr, out))
  474:                 assert_array_equal(out.view("int64"), expected_out.view("int64"))
  475: 
  476:     def string_with_modified_length(self, dtype, change_length):
  477:         fact = 1 if dtype.char == "S" else 4
  478:         length = dtype.itemsize // fact + change_length
  479:         return np.dtype(f"{dtype.byteorder}{dtype.char}{length}")
  480: 
  481:     @pytest.mark.parametrize("other_DT", simple_dtypes)
  482:     @pytest.mark.parametrize("string_char", ["S", "U"])
  483:     def test_string_cancast(self, other_DT, string_char):
  484:         fact = 1 if string_char == "S" else 4
  485: 
  486:         string_DT = type(np.dtype(string_char))
  487:         cast = get_castingimpl(other_DT, string_DT)
  488: 
  489:         other_dt = other_DT()
  490:         expected_length = get_expected_stringlength(other_dt)
  491:         string_dt = np.dtype(f"{string_char}{expected_length}")
  492: 
  493:         safety, (res_other_dt, res_dt), view_off = cast._resolve_descriptors(
  494:                 (other_dt, None))
  495:         assert res_dt.itemsize == expected_length * fact
  496:         assert safety == Casting.safe  # we consider to string casts "safe"
  497:         assert view_off is None
  498:         assert isinstance(res_dt, string_DT)
  499: 
  500:         # These casts currently implement changing the string length, so
  501:         # check the cast-safety for too long/fixed string lengths:
  502:         for change_length in [-1, 0, 1]:
  503:             if change_length >= 0:
  504:                 expected_safety = Casting.safe
  505:             else:
  506:                 expected_safety = Casting.same_kind
  507: 
  508:             to_dt = self.string_with_modified_length(string_dt, change_length)
  509:             safety, (_, res_dt), view_off = cast._resolve_descriptors(
  510:                     (other_dt, to_dt))
  511:             assert res_dt is to_dt
  512:             assert safety == expected_safety
  513:             assert view_off is None
  514: 
  515:         # The opposite direction is always considered unsafe:
  516:         cast = get_castingimpl(string_DT, other_DT)
  517: 
  518:         safety, _, view_off = cast._resolve_descriptors((string_dt, other_dt))
  519:         assert safety == Casting.unsafe
  520:         assert view_off is None
  521: 
  522:         cast = get_castingimpl(string_DT, other_DT)
  523:         safety, (_, res_dt), view_off = cast._resolve_descriptors(
  524:             (string_dt, None))
  525:         assert safety == Casting.unsafe
  526:         assert view_off is None
  527:         assert other_dt is res_dt  # returns the singleton for simple dtypes
  528: 
  529:     @pytest.mark.parametrize("string_char", ["S", "U"])
  530:     @pytest.mark.parametrize("other_dt", simple_dtype_instances())
  531:     def test_simple_string_casts_roundtrip(self, other_dt, string_char):
  532:         """
  533:         Tests casts from and to string by checking the roundtripping property.
  534: 
  535:         The test also covers some string to string casts (but not all).
  536: 
  537:         If this test creates issues, it should possibly just be simplified
  538:         or even removed (checking whether unaligned/non-contiguous casts give
  539:         the same results is useful, though).
  540:         """
  541:         string_DT = type(np.dtype(string_char))
  542: 
  543:         cast = get_castingimpl(type(other_dt), string_DT)
  544:         cast_back = get_castingimpl(string_DT, type(other_dt))
  545:         _, (res_other_dt, string_dt), _ = cast._resolve_descriptors(
  546:                 (other_dt, None))
  547: 
  548:         if res_other_dt is not other_dt:
  549:             # do not support non-native byteorder, skip test in that case
  550:             assert other_dt.byteorder != res_other_dt.byteorder
  551:             return
  552: 
  553:         orig_arr, values = self.get_data(other_dt, None)
  554:         str_arr = np.zeros(len(orig_arr), dtype=string_dt)
  555:         string_dt_short = self.string_with_modified_length(string_dt, -1)
  556:         str_arr_short = np.zeros(len(orig_arr), dtype=string_dt_short)
  557:         string_dt_long = self.string_with_modified_length(string_dt, 1)
  558:         str_arr_long = np.zeros(len(orig_arr), dtype=string_dt_long)
  559: 
  560:         assert not cast._supports_unaligned  # if support is added, should test
  561:         assert not cast_back._supports_unaligned
  562: 
  563:         for contig in [True, False]:
  564:             other_arr, str_arr = self.get_data_variation(
  565:                 orig_arr, str_arr, True, contig)
  566:             _, str_arr_short = self.get_data_variation(
  567:                 orig_arr, str_arr_short.copy(), True, contig)
  568:             _, str_arr_long = self.get_data_variation(
  569:                 orig_arr, str_arr_long, True, contig)
  570: 
  571:             cast._simple_strided_call((other_arr, str_arr))
  572: 
  573:             cast._simple_strided_call((other_arr, str_arr_short))
  574:             assert_array_equal(str_arr.astype(string_dt_short), str_arr_short)
  575: 
  576:             cast._simple_strided_call((other_arr, str_arr_long))
  577:             assert_array_equal(str_arr, str_arr_long)
  578: 
  579:             if other_dt.kind == "b":
  580:                 # Booleans do not roundtrip
  581:                 continue
  582: 
  583:             other_arr[...] = 0
  584:             cast_back._simple_strided_call((str_arr, other_arr))
  585:             assert_array_equal(orig_arr, other_arr)
  586: 
  587:             other_arr[...] = 0
  588:             cast_back._simple_strided_call((str_arr_long, other_arr))
  589:             assert_array_equal(orig_arr, other_arr)
  590: 
  591:     @pytest.mark.parametrize("other_dt", ["S8", "<U8", ">U8"])
  592:     @pytest.mark.parametrize("string_char", ["S", "U"])
  593:     def test_string_to_string_cancast(self, other_dt, string_char):
  594:         other_dt = np.dtype(other_dt)
  595: 
  596:         fact = 1 if string_char == "S" else 4
  597:         div = 1 if other_dt.char == "S" else 4
  598: 
  599:         string_DT = type(np.dtype(string_char))
  600:         cast = get_castingimpl(type(other_dt), string_DT)
  601: 
  602:         expected_length = other_dt.itemsize // div
  603:         string_dt = np.dtype(f"{string_char}{expected_length}")
  604: 
  605:         safety, (res_other_dt, res_dt), view_off = cast._resolve_descriptors(
  606:                 (other_dt, None))
  607:         assert res_dt.itemsize == expected_length * fact
  608:         assert isinstance(res_dt, string_DT)
  609: 
  610:         expected_view_off = None
  611:         if other_dt.char == string_char:
  612:             if other_dt.isnative:
  613:                 expected_safety = Casting.no
  614:                 expected_view_off = 0
  615:             else:
  616:                 expected_safety = Casting.equiv
  617:         elif string_char == "U":
  618:             expected_safety = Casting.safe
  619:         else:
  620:             expected_safety = Casting.unsafe
  621: 
  622:         assert view_off == expected_view_off
  623:         assert expected_safety == safety
  624: 
  625:         for change_length in [-1, 0, 1]:
  626:             to_dt = self.string_with_modified_length(string_dt, change_length)
  627:             safety, (_, res_dt), view_off = cast._resolve_descriptors(
  628:                     (other_dt, to_dt))
  629: 
  630:             assert res_dt is to_dt
  631:             if change_length <= 0:
  632:                 assert view_off == expected_view_off
  633:             else:
  634:                 assert view_off is None
  635:             if expected_safety == Casting.unsafe:
  636:                 assert safety == expected_safety
  637:             elif change_length < 0:
  638:                 assert safety == Casting.same_kind
  639:             elif change_length == 0:
  640:                 assert safety == expected_safety
  641:             elif change_length > 0:
  642:                 assert safety == Casting.safe
  643: 
  644:     @pytest.mark.parametrize("order1", [">", "<"])
  645:     @pytest.mark.parametrize("order2", [">", "<"])
  646:     def test_unicode_byteswapped_cast(self, order1, order2):
  647:         # Very specific tests (not using the castingimpl directly)
  648:         # that tests unicode bytedwaps including for unaligned array data.
  649:         dtype1 = np.dtype(f"{order1}U30")
  650:         dtype2 = np.dtype(f"{order2}U30")
  651:         data1 = np.empty(30 * 4 + 1, dtype=np.uint8)[1:].view(dtype1)
  652:         data2 = np.empty(30 * 4 + 1, dtype=np.uint8)[1:].view(dtype2)
  653:         if dtype1.alignment != 1:
  654:             # alignment should always be >1, but skip the check if not
  655:             assert not data1.flags.aligned
  656:             assert not data2.flags.aligned
  657: 
  658:         element = "this is a Гјnicode stringвЂЅ"
  659:         data1[()] = element
  660:         # Test both `data1` and `data1.copy()`  (which should be aligned)
  661:         for data in [data1, data1.copy()]:
  662:             data2[...] = data1
  663:             assert data2[()] == element
  664:             assert data2.copy()[()] == element
  665: 
  666:     def test_void_to_string_special_case(self):
  667:         # Cover a small special case in void to string casting that could
  668:         # probably just as well be turned into an error (compare
  669:         # `test_object_to_parametric_internal_error` below).
  670:         assert np.array([], dtype="V5").astype("S").dtype.itemsize == 5
  671:         assert np.array([], dtype="V5").astype("U").dtype.itemsize == 4 * 5
  672: 
  673:     def test_object_to_parametric_internal_error(self):
  674:         # We reject casting from object to a parametric type, without
  675:         # figuring out the correct instance first.
  676:         object_dtype = type(np.dtype(object))
  677:         other_dtype = type(np.dtype(str))
  678:         cast = get_castingimpl(object_dtype, other_dtype)
  679:         with pytest.raises(TypeError,
  680:                     match="casting from object to the parametric DType"):
  681:             cast._resolve_descriptors((np.dtype("O"), None))
  682: 
  683:     @pytest.mark.parametrize("dtype", simple_dtype_instances())
  684:     def test_object_and_simple_resolution(self, dtype):
  685:         # Simple test to exercise the cast when no instance is specified
  686:         object_dtype = type(np.dtype(object))
  687:         cast = get_castingimpl(object_dtype, type(dtype))
  688: 
  689:         safety, (_, res_dt), view_off = cast._resolve_descriptors(
  690:                 (np.dtype("O"), dtype))
  691:         assert safety == Casting.unsafe
  692:         assert view_off is None
  693:         assert res_dt is dtype
  694: 
  695:         safety, (_, res_dt), view_off = cast._resolve_descriptors(
  696:                 (np.dtype("O"), None))
  697:         assert safety == Casting.unsafe
  698:         assert view_off is None
  699:         assert res_dt == dtype.newbyteorder("=")
  700: 
  701:     @pytest.mark.parametrize("dtype", simple_dtype_instances())
  702:     def test_simple_to_object_resolution(self, dtype):
  703:         # Simple test to exercise the cast when no instance is specified
  704:         object_dtype = type(np.dtype(object))
  705:         cast = get_castingimpl(type(dtype), object_dtype)
  706: 
  707:         safety, (_, res_dt), view_off = cast._resolve_descriptors(
  708:                 (dtype, None))
  709:         assert safety == Casting.safe
  710:         assert view_off is None
  711:         assert res_dt is np.dtype("O")
  712: 
  713:     @pytest.mark.parametrize("casting", ["no", "unsafe"])
  714:     def test_void_and_structured_with_subarray(self, casting):
  715:         # test case corresponding to gh-19325
  716:         dtype = np.dtype([("foo", "<f4", (3, 2))])
  717:         expected = casting == "unsafe"
  718:         assert np.can_cast("V4", dtype, casting=casting) == expected
  719:         assert np.can_cast(dtype, "V4", casting=casting) == expected
  720: 
  721:     @pytest.mark.parametrize(["to_dt", "expected_off"],
  722:             [  # Same as `from_dt` but with both fields shifted:
  723:              (np.dtype({"names": ["a", "b"], "formats": ["i4", "f4"],
  724:                         "offsets": [0, 4]}), 2),
  725:              # Additional change of the names
  726:              (np.dtype({"names": ["b", "a"], "formats": ["i4", "f4"],
  727:                         "offsets": [0, 4]}), 2),
  728:              # Incompatible field offset change
  729:              (np.dtype({"names": ["b", "a"], "formats": ["i4", "f4"],
  730:                         "offsets": [0, 6]}), None)])
  731:     def test_structured_field_offsets(self, to_dt, expected_off):
  732:         # This checks the cast-safety and view offset for swapped and "shifted"
  733:         # fields which are viewable
  734:         from_dt = np.dtype({"names": ["a", "b"],
  735:                             "formats": ["i4", "f4"],
  736:                             "offsets": [2, 6]})
  737:         cast = get_castingimpl(type(from_dt), type(to_dt))
  738:         safety, _, view_off = cast._resolve_descriptors((from_dt, to_dt))
  739:         if from_dt.names == to_dt.names:
  740:             assert safety == Casting.equiv
  741:         else:
  742:             assert safety == Casting.safe
  743:         # Shifting the original data pointer by -2 will align both by
  744:         # effectively adding 2 bytes of spacing before `from_dt`.
  745:         assert view_off == expected_off
  746: 
  747:     @pytest.mark.parametrize(("from_dt", "to_dt", "expected_off"), [
  748:             # Subarray cases:
  749:             ("i", "(1,1)i", 0),
  750:             ("(1,1)i", "i", 0),
  751:             ("(2,1)i", "(2,1)i", 0),
  752:             # field cases (field to field is tested explicitly also):
  753:             # Not considered viewable, because a negative offset would allow
  754:             # may structured dtype to indirectly access invalid memory.
  755:             ("i", {"names": ["a"], "formats": ["i"], "offsets": [2]}, None),
  756:             ({"names": ["a"], "formats": ["i"], "offsets": [2]}, "i", 2),
  757:             # Currently considered not viewable, due to multiple fields
  758:             # even though they overlap (maybe we should not allow that?)
  759:             ("i", {"names": ["a", "b"], "formats": ["i", "i"], "offsets": [2, 2]},
  760:              None),
  761:             # different number of fields can't work, should probably just fail
  762:             # so it never reports "viewable":
  763:             ("i,i", "i,i,i", None),
  764:             # Unstructured void cases:
  765:             ("i4", "V3", 0),  # void smaller or equal
  766:             ("i4", "V4", 0),  # void smaller or equal
  767:             ("i4", "V10", None),  # void is larger (no view)
  768:             ("O", "V4", None),  # currently reject objects for view here.
  769:             ("O", "V8", None),  # currently reject objects for view here.
  770:             ("V4", "V3", 0),
  771:             ("V4", "V4", 0),
  772:             ("V3", "V4", None),
  773:             # Note that currently void-to-other cast goes via byte-strings
  774:             # and is not a "view" based cast like the opposite direction:
  775:             ("V4", "i4", None),
  776:             # completely invalid/impossible cast:
  777:             ("i,i", "i,i,i", None),
  778:         ])
  779:     def test_structured_view_offsets_parametric(
  780:             self, from_dt, to_dt, expected_off):
  781:         # TODO: While this test is fairly thorough, right now, it does not
  782:         # really test some paths that may have nonzero offsets (they don't
  783:         # really exists).
  784:         from_dt = np.dtype(from_dt)
  785:         to_dt = np.dtype(to_dt)
  786:         cast = get_castingimpl(type(from_dt), type(to_dt))
  787:         _, _, view_off = cast._resolve_descriptors((from_dt, to_dt))
  788:         assert view_off == expected_off
  789: 
  790:     @pytest.mark.parametrize("dtype", np.typecodes["All"])
  791:     def test_object_casts_NULL_None_equivalence(self, dtype):
  792:         # None to <other> casts may succeed or fail, but a NULL'ed array must
  793:         # behave the same as one filled with None's.
  794:         arr_normal = np.array([None] * 5)
  795:         arr_NULLs = np.empty_like(arr_normal)
  796:         ctypes.memset(arr_NULLs.ctypes.data, 0, arr_NULLs.nbytes)
  797:         # If the check fails (maybe it should) the test would lose its purpose:
  798:         assert arr_NULLs.tobytes() == b"\x00" * arr_NULLs.nbytes
  799: 
  800:         try:
  801:             expected = arr_normal.astype(dtype)
  802:         except TypeError:
  803:             with pytest.raises(TypeError):
  804:                 arr_NULLs.astype(dtype)
  805:         else:
  806:             assert_array_equal(expected, arr_NULLs.astype(dtype))
  807: 
  808:     @pytest.mark.parametrize("dtype",
  809:             np.typecodes["AllInteger"] + np.typecodes["AllFloat"])
  810:     def test_nonstandard_bool_to_other(self, dtype):
  811:         # simple test for casting bool_ to numeric types, which should not
  812:         # expose the detail that NumPy bools can sometimes take values other
  813:         # than 0 and 1.  See also gh-19514.
  814:         nonstandard_bools = np.array([0, 3, -7], dtype=np.int8).view(bool)
  815:         res = nonstandard_bools.astype(dtype)
  816:         expected = [0, 1, 1]
  817:         assert_array_equal(res, expected)
