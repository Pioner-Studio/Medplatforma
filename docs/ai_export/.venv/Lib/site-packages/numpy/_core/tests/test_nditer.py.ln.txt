    1: import subprocess
    2: import sys
    3: import textwrap
    4: 
    5: import numpy._core._multiarray_tests as _multiarray_tests
    6: import pytest
    7: 
    8: import numpy as np
    9: import numpy._core.umath as ncu
   10: from numpy import all, arange, array, nditer
   11: from numpy.testing import (
   12:     HAS_REFCOUNT,
   13:     IS_WASM,
   14:     assert_,
   15:     assert_array_equal,
   16:     assert_equal,
   17:     assert_raises,
   18:     suppress_warnings,
   19: )
   20: from numpy.testing._private.utils import requires_memory
   21: 
   22: 
   23: def iter_multi_index(i):
   24:     ret = []
   25:     while not i.finished:
   26:         ret.append(i.multi_index)
   27:         i.iternext()
   28:     return ret
   29: 
   30: def iter_indices(i):
   31:     ret = []
   32:     while not i.finished:
   33:         ret.append(i.index)
   34:         i.iternext()
   35:     return ret
   36: 
   37: def iter_iterindices(i):
   38:     ret = []
   39:     while not i.finished:
   40:         ret.append(i.iterindex)
   41:         i.iternext()
   42:     return ret
   43: 
   44: @pytest.mark.skipif(not HAS_REFCOUNT, reason="Python lacks refcounts")
   45: def test_iter_refcount():
   46:     # Make sure the iterator doesn't leak
   47: 
   48:     # Basic
   49:     a = arange(6)
   50:     dt = np.dtype('f4').newbyteorder()
   51:     rc_a = sys.getrefcount(a)
   52:     rc_dt = sys.getrefcount(dt)
   53:     with nditer(a, [],
   54:                 [['readwrite', 'updateifcopy']],
   55:                 casting='unsafe',
   56:                 op_dtypes=[dt]) as it:
   57:         assert_(not it.iterationneedsapi)
   58:         assert_(sys.getrefcount(a) > rc_a)
   59:         assert_(sys.getrefcount(dt) > rc_dt)
   60:     # del 'it'
   61:     it = None
   62:     assert_equal(sys.getrefcount(a), rc_a)
   63:     assert_equal(sys.getrefcount(dt), rc_dt)
   64: 
   65:     # With a copy
   66:     a = arange(6, dtype='f4')
   67:     dt = np.dtype('f4')
   68:     rc_a = sys.getrefcount(a)
   69:     rc_dt = sys.getrefcount(dt)
   70:     it = nditer(a, [],
   71:                 [['readwrite']],
   72:                 op_dtypes=[dt])
   73:     rc2_a = sys.getrefcount(a)
   74:     rc2_dt = sys.getrefcount(dt)
   75:     it2 = it.copy()
   76:     assert_(sys.getrefcount(a) > rc2_a)
   77:     if sys.version_info < (3, 13):
   78:         # np.dtype('f4') is immortal after Python 3.13
   79:         assert_(sys.getrefcount(dt) > rc2_dt)
   80:     it = None
   81:     assert_equal(sys.getrefcount(a), rc2_a)
   82:     assert_equal(sys.getrefcount(dt), rc2_dt)
   83:     it2 = None
   84:     assert_equal(sys.getrefcount(a), rc_a)
   85:     assert_equal(sys.getrefcount(dt), rc_dt)
   86: 
   87: def test_iter_best_order():
   88:     # The iterator should always find the iteration order
   89:     # with increasing memory addresses
   90: 
   91:     # Test the ordering for 1-D to 5-D shapes
   92:     for shape in [(5,), (3, 4), (2, 3, 4), (2, 3, 4, 3), (2, 3, 2, 2, 3)]:
   93:         a = arange(np.prod(shape))
   94:         # Test each combination of positive and negative strides
   95:         for dirs in range(2**len(shape)):
   96:             dirs_index = [slice(None)] * len(shape)
   97:             for bit in range(len(shape)):
   98:                 if ((2**bit) & dirs):
   99:                     dirs_index[bit] = slice(None, None, -1)
  100:             dirs_index = tuple(dirs_index)
  101: 
  102:             aview = a.reshape(shape)[dirs_index]
  103:             # C-order
  104:             i = nditer(aview, [], [['readonly']])
  105:             assert_equal(list(i), a)
  106:             # Fortran-order
  107:             i = nditer(aview.T, [], [['readonly']])
  108:             assert_equal(list(i), a)
  109:             # Other order
  110:             if len(shape) > 2:
  111:                 i = nditer(aview.swapaxes(0, 1), [], [['readonly']])
  112:                 assert_equal(list(i), a)
  113: 
  114: def test_iter_c_order():
  115:     # Test forcing C order
  116: 
  117:     # Test the ordering for 1-D to 5-D shapes
  118:     for shape in [(5,), (3, 4), (2, 3, 4), (2, 3, 4, 3), (2, 3, 2, 2, 3)]:
  119:         a = arange(np.prod(shape))
  120:         # Test each combination of positive and negative strides
  121:         for dirs in range(2**len(shape)):
  122:             dirs_index = [slice(None)] * len(shape)
  123:             for bit in range(len(shape)):
  124:                 if ((2**bit) & dirs):
  125:                     dirs_index[bit] = slice(None, None, -1)
  126:             dirs_index = tuple(dirs_index)
  127: 
  128:             aview = a.reshape(shape)[dirs_index]
  129:             # C-order
  130:             i = nditer(aview, order='C')
  131:             assert_equal(list(i), aview.ravel(order='C'))
  132:             # Fortran-order
  133:             i = nditer(aview.T, order='C')
  134:             assert_equal(list(i), aview.T.ravel(order='C'))
  135:             # Other order
  136:             if len(shape) > 2:
  137:                 i = nditer(aview.swapaxes(0, 1), order='C')
  138:                 assert_equal(list(i),
  139:                                     aview.swapaxes(0, 1).ravel(order='C'))
  140: 
  141: def test_iter_f_order():
  142:     # Test forcing F order
  143: 
  144:     # Test the ordering for 1-D to 5-D shapes
  145:     for shape in [(5,), (3, 4), (2, 3, 4), (2, 3, 4, 3), (2, 3, 2, 2, 3)]:
  146:         a = arange(np.prod(shape))
  147:         # Test each combination of positive and negative strides
  148:         for dirs in range(2**len(shape)):
  149:             dirs_index = [slice(None)] * len(shape)
  150:             for bit in range(len(shape)):
  151:                 if ((2**bit) & dirs):
  152:                     dirs_index[bit] = slice(None, None, -1)
  153:             dirs_index = tuple(dirs_index)
  154: 
  155:             aview = a.reshape(shape)[dirs_index]
  156:             # C-order
  157:             i = nditer(aview, order='F')
  158:             assert_equal(list(i), aview.ravel(order='F'))
  159:             # Fortran-order
  160:             i = nditer(aview.T, order='F')
  161:             assert_equal(list(i), aview.T.ravel(order='F'))
  162:             # Other order
  163:             if len(shape) > 2:
  164:                 i = nditer(aview.swapaxes(0, 1), order='F')
  165:                 assert_equal(list(i),
  166:                                     aview.swapaxes(0, 1).ravel(order='F'))
  167: 
  168: def test_iter_c_or_f_order():
  169:     # Test forcing any contiguous (C or F) order
  170: 
  171:     # Test the ordering for 1-D to 5-D shapes
  172:     for shape in [(5,), (3, 4), (2, 3, 4), (2, 3, 4, 3), (2, 3, 2, 2, 3)]:
  173:         a = arange(np.prod(shape))
  174:         # Test each combination of positive and negative strides
  175:         for dirs in range(2**len(shape)):
  176:             dirs_index = [slice(None)] * len(shape)
  177:             for bit in range(len(shape)):
  178:                 if ((2**bit) & dirs):
  179:                     dirs_index[bit] = slice(None, None, -1)
  180:             dirs_index = tuple(dirs_index)
  181: 
  182:             aview = a.reshape(shape)[dirs_index]
  183:             # C-order
  184:             i = nditer(aview, order='A')
  185:             assert_equal(list(i), aview.ravel(order='A'))
  186:             # Fortran-order
  187:             i = nditer(aview.T, order='A')
  188:             assert_equal(list(i), aview.T.ravel(order='A'))
  189:             # Other order
  190:             if len(shape) > 2:
  191:                 i = nditer(aview.swapaxes(0, 1), order='A')
  192:                 assert_equal(list(i),
  193:                                     aview.swapaxes(0, 1).ravel(order='A'))
  194: 
  195: def test_nditer_multi_index_set():
  196:     # Test the multi_index set
  197:     a = np.arange(6).reshape(2, 3)
  198:     it = np.nditer(a, flags=['multi_index'])
  199: 
  200:     # Removes the iteration on two first elements of a[0]
  201:     it.multi_index = (0, 2,)
  202: 
  203:     assert_equal(list(it), [2, 3, 4, 5])
  204: 
  205: @pytest.mark.skipif(not HAS_REFCOUNT, reason="Python lacks refcounts")
  206: def test_nditer_multi_index_set_refcount():
  207:     # Test if the reference count on index variable is decreased
  208: 
  209:     index = 0
  210:     i = np.nditer(np.array([111, 222, 333, 444]), flags=['multi_index'])
  211: 
  212:     start_count = sys.getrefcount(index)
  213:     i.multi_index = (index,)
  214:     end_count = sys.getrefcount(index)
  215: 
  216:     assert_equal(start_count, end_count)
  217: 
  218: def test_iter_best_order_multi_index_1d():
  219:     # The multi-indices should be correct with any reordering
  220: 
  221:     a = arange(4)
  222:     # 1D order
  223:     i = nditer(a, ['multi_index'], [['readonly']])
  224:     assert_equal(iter_multi_index(i), [(0,), (1,), (2,), (3,)])
  225:     # 1D reversed order
  226:     i = nditer(a[::-1], ['multi_index'], [['readonly']])
  227:     assert_equal(iter_multi_index(i), [(3,), (2,), (1,), (0,)])
  228: 
  229: def test_iter_best_order_multi_index_2d():
  230:     # The multi-indices should be correct with any reordering
  231: 
  232:     a = arange(6)
  233:     # 2D C-order
  234:     i = nditer(a.reshape(2, 3), ['multi_index'], [['readonly']])
  235:     assert_equal(iter_multi_index(i), [(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2)])
  236:     # 2D Fortran-order
  237:     i = nditer(a.reshape(2, 3).copy(order='F'), ['multi_index'], [['readonly']])
  238:     assert_equal(iter_multi_index(i), [(0, 0), (1, 0), (0, 1), (1, 1), (0, 2), (1, 2)])
  239:     # 2D reversed C-order
  240:     i = nditer(a.reshape(2, 3)[::-1], ['multi_index'], [['readonly']])
  241:     assert_equal(iter_multi_index(i), [(1, 0), (1, 1), (1, 2), (0, 0), (0, 1), (0, 2)])
  242:     i = nditer(a.reshape(2, 3)[:, ::-1], ['multi_index'], [['readonly']])
  243:     assert_equal(iter_multi_index(i), [(0, 2), (0, 1), (0, 0), (1, 2), (1, 1), (1, 0)])
  244:     i = nditer(a.reshape(2, 3)[::-1, ::-1], ['multi_index'], [['readonly']])
  245:     assert_equal(iter_multi_index(i), [(1, 2), (1, 1), (1, 0), (0, 2), (0, 1), (0, 0)])
  246:     # 2D reversed Fortran-order
  247:     i = nditer(a.reshape(2, 3).copy(order='F')[::-1], ['multi_index'], [['readonly']])
  248:     assert_equal(iter_multi_index(i), [(1, 0), (0, 0), (1, 1), (0, 1), (1, 2), (0, 2)])
  249:     i = nditer(a.reshape(2, 3).copy(order='F')[:, ::-1],
  250:                                                    ['multi_index'], [['readonly']])
  251:     assert_equal(iter_multi_index(i), [(0, 2), (1, 2), (0, 1), (1, 1), (0, 0), (1, 0)])
  252:     i = nditer(a.reshape(2, 3).copy(order='F')[::-1, ::-1],
  253:                                                    ['multi_index'], [['readonly']])
  254:     assert_equal(iter_multi_index(i), [(1, 2), (0, 2), (1, 1), (0, 1), (1, 0), (0, 0)])
  255: 
  256: def test_iter_best_order_multi_index_3d():
  257:     # The multi-indices should be correct with any reordering
  258: 
  259:     a = arange(12)
  260:     # 3D C-order
  261:     i = nditer(a.reshape(2, 3, 2), ['multi_index'], [['readonly']])
  262:     assert_equal(iter_multi_index(i),
  263:                             [(0, 0, 0), (0, 0, 1), (0, 1, 0), (0, 1, 1), (0, 2, 0), (0, 2, 1),
  264:                              (1, 0, 0), (1, 0, 1), (1, 1, 0), (1, 1, 1), (1, 2, 0), (1, 2, 1)])
  265:     # 3D Fortran-order
  266:     i = nditer(a.reshape(2, 3, 2).copy(order='F'), ['multi_index'], [['readonly']])
  267:     assert_equal(iter_multi_index(i),
  268:                             [(0, 0, 0), (1, 0, 0), (0, 1, 0), (1, 1, 0), (0, 2, 0), (1, 2, 0),
  269:                              (0, 0, 1), (1, 0, 1), (0, 1, 1), (1, 1, 1), (0, 2, 1), (1, 2, 1)])
  270:     # 3D reversed C-order
  271:     i = nditer(a.reshape(2, 3, 2)[::-1], ['multi_index'], [['readonly']])
  272:     assert_equal(iter_multi_index(i),
  273:                             [(1, 0, 0), (1, 0, 1), (1, 1, 0), (1, 1, 1), (1, 2, 0), (1, 2, 1),
  274:                              (0, 0, 0), (0, 0, 1), (0, 1, 0), (0, 1, 1), (0, 2, 0), (0, 2, 1)])
  275:     i = nditer(a.reshape(2, 3, 2)[:, ::-1], ['multi_index'], [['readonly']])
  276:     assert_equal(iter_multi_index(i),
  277:                             [(0, 2, 0), (0, 2, 1), (0, 1, 0), (0, 1, 1), (0, 0, 0), (0, 0, 1),
  278:                              (1, 2, 0), (1, 2, 1), (1, 1, 0), (1, 1, 1), (1, 0, 0), (1, 0, 1)])
  279:     i = nditer(a.reshape(2, 3, 2)[:, :, ::-1], ['multi_index'], [['readonly']])
  280:     assert_equal(iter_multi_index(i),
  281:                             [(0, 0, 1), (0, 0, 0), (0, 1, 1), (0, 1, 0), (0, 2, 1), (0, 2, 0),
  282:                              (1, 0, 1), (1, 0, 0), (1, 1, 1), (1, 1, 0), (1, 2, 1), (1, 2, 0)])
  283:     # 3D reversed Fortran-order
  284:     i = nditer(a.reshape(2, 3, 2).copy(order='F')[::-1],
  285:                                                     ['multi_index'], [['readonly']])
  286:     assert_equal(iter_multi_index(i),
  287:                             [(1, 0, 0), (0, 0, 0), (1, 1, 0), (0, 1, 0), (1, 2, 0), (0, 2, 0),
  288:                              (1, 0, 1), (0, 0, 1), (1, 1, 1), (0, 1, 1), (1, 2, 1), (0, 2, 1)])
  289:     i = nditer(a.reshape(2, 3, 2).copy(order='F')[:, ::-1],
  290:                                                     ['multi_index'], [['readonly']])
  291:     assert_equal(iter_multi_index(i),
  292:                             [(0, 2, 0), (1, 2, 0), (0, 1, 0), (1, 1, 0), (0, 0, 0), (1, 0, 0),
  293:                              (0, 2, 1), (1, 2, 1), (0, 1, 1), (1, 1, 1), (0, 0, 1), (1, 0, 1)])
  294:     i = nditer(a.reshape(2, 3, 2).copy(order='F')[:, :, ::-1],
  295:                                                     ['multi_index'], [['readonly']])
  296:     assert_equal(iter_multi_index(i),
  297:                             [(0, 0, 1), (1, 0, 1), (0, 1, 1), (1, 1, 1), (0, 2, 1), (1, 2, 1),
  298:                              (0, 0, 0), (1, 0, 0), (0, 1, 0), (1, 1, 0), (0, 2, 0), (1, 2, 0)])
  299: 
  300: def test_iter_best_order_c_index_1d():
  301:     # The C index should be correct with any reordering
  302: 
  303:     a = arange(4)
  304:     # 1D order
  305:     i = nditer(a, ['c_index'], [['readonly']])
  306:     assert_equal(iter_indices(i), [0, 1, 2, 3])
  307:     # 1D reversed order
  308:     i = nditer(a[::-1], ['c_index'], [['readonly']])
  309:     assert_equal(iter_indices(i), [3, 2, 1, 0])
  310: 
  311: def test_iter_best_order_c_index_2d():
  312:     # The C index should be correct with any reordering
  313: 
  314:     a = arange(6)
  315:     # 2D C-order
  316:     i = nditer(a.reshape(2, 3), ['c_index'], [['readonly']])
  317:     assert_equal(iter_indices(i), [0, 1, 2, 3, 4, 5])
  318:     # 2D Fortran-order
  319:     i = nditer(a.reshape(2, 3).copy(order='F'),
  320:                                     ['c_index'], [['readonly']])
  321:     assert_equal(iter_indices(i), [0, 3, 1, 4, 2, 5])
  322:     # 2D reversed C-order
  323:     i = nditer(a.reshape(2, 3)[::-1], ['c_index'], [['readonly']])
  324:     assert_equal(iter_indices(i), [3, 4, 5, 0, 1, 2])
  325:     i = nditer(a.reshape(2, 3)[:, ::-1], ['c_index'], [['readonly']])
  326:     assert_equal(iter_indices(i), [2, 1, 0, 5, 4, 3])
  327:     i = nditer(a.reshape(2, 3)[::-1, ::-1], ['c_index'], [['readonly']])
  328:     assert_equal(iter_indices(i), [5, 4, 3, 2, 1, 0])
  329:     # 2D reversed Fortran-order
  330:     i = nditer(a.reshape(2, 3).copy(order='F')[::-1],
  331:                                     ['c_index'], [['readonly']])
  332:     assert_equal(iter_indices(i), [3, 0, 4, 1, 5, 2])
  333:     i = nditer(a.reshape(2, 3).copy(order='F')[:, ::-1],
  334:                                     ['c_index'], [['readonly']])
  335:     assert_equal(iter_indices(i), [2, 5, 1, 4, 0, 3])
  336:     i = nditer(a.reshape(2, 3).copy(order='F')[::-1, ::-1],
  337:                                     ['c_index'], [['readonly']])
  338:     assert_equal(iter_indices(i), [5, 2, 4, 1, 3, 0])
  339: 
  340: def test_iter_best_order_c_index_3d():
  341:     # The C index should be correct with any reordering
  342: 
  343:     a = arange(12)
  344:     # 3D C-order
  345:     i = nditer(a.reshape(2, 3, 2), ['c_index'], [['readonly']])
  346:     assert_equal(iter_indices(i),
  347:                             [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
  348:     # 3D Fortran-order
  349:     i = nditer(a.reshape(2, 3, 2).copy(order='F'),
  350:                                     ['c_index'], [['readonly']])
  351:     assert_equal(iter_indices(i),
  352:                             [0, 6, 2, 8, 4, 10, 1, 7, 3, 9, 5, 11])
  353:     # 3D reversed C-order
  354:     i = nditer(a.reshape(2, 3, 2)[::-1], ['c_index'], [['readonly']])
  355:     assert_equal(iter_indices(i),
  356:                             [6, 7, 8, 9, 10, 11, 0, 1, 2, 3, 4, 5])
  357:     i = nditer(a.reshape(2, 3, 2)[:, ::-1], ['c_index'], [['readonly']])
  358:     assert_equal(iter_indices(i),
  359:                             [4, 5, 2, 3, 0, 1, 10, 11, 8, 9, 6, 7])
  360:     i = nditer(a.reshape(2, 3, 2)[:, :, ::-1], ['c_index'], [['readonly']])
  361:     assert_equal(iter_indices(i),
  362:                             [1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10])
  363:     # 3D reversed Fortran-order
  364:     i = nditer(a.reshape(2, 3, 2).copy(order='F')[::-1],
  365:                                     ['c_index'], [['readonly']])
  366:     assert_equal(iter_indices(i),
  367:                             [6, 0, 8, 2, 10, 4, 7, 1, 9, 3, 11, 5])
  368:     i = nditer(a.reshape(2, 3, 2).copy(order='F')[:, ::-1],
  369:                                     ['c_index'], [['readonly']])
  370:     assert_equal(iter_indices(i),
  371:                             [4, 10, 2, 8, 0, 6, 5, 11, 3, 9, 1, 7])
  372:     i = nditer(a.reshape(2, 3, 2).copy(order='F')[:, :, ::-1],
  373:                                     ['c_index'], [['readonly']])
  374:     assert_equal(iter_indices(i),
  375:                             [1, 7, 3, 9, 5, 11, 0, 6, 2, 8, 4, 10])
  376: 
  377: def test_iter_best_order_f_index_1d():
  378:     # The Fortran index should be correct with any reordering
  379: 
  380:     a = arange(4)
  381:     # 1D order
  382:     i = nditer(a, ['f_index'], [['readonly']])
  383:     assert_equal(iter_indices(i), [0, 1, 2, 3])
  384:     # 1D reversed order
  385:     i = nditer(a[::-1], ['f_index'], [['readonly']])
  386:     assert_equal(iter_indices(i), [3, 2, 1, 0])
  387: 
  388: def test_iter_best_order_f_index_2d():
  389:     # The Fortran index should be correct with any reordering
  390: 
  391:     a = arange(6)
  392:     # 2D C-order
  393:     i = nditer(a.reshape(2, 3), ['f_index'], [['readonly']])
  394:     assert_equal(iter_indices(i), [0, 2, 4, 1, 3, 5])
  395:     # 2D Fortran-order
  396:     i = nditer(a.reshape(2, 3).copy(order='F'),
  397:                                     ['f_index'], [['readonly']])
  398:     assert_equal(iter_indices(i), [0, 1, 2, 3, 4, 5])
  399:     # 2D reversed C-order
  400:     i = nditer(a.reshape(2, 3)[::-1], ['f_index'], [['readonly']])
  401:     assert_equal(iter_indices(i), [1, 3, 5, 0, 2, 4])
  402:     i = nditer(a.reshape(2, 3)[:, ::-1], ['f_index'], [['readonly']])
  403:     assert_equal(iter_indices(i), [4, 2, 0, 5, 3, 1])
  404:     i = nditer(a.reshape(2, 3)[::-1, ::-1], ['f_index'], [['readonly']])
  405:     assert_equal(iter_indices(i), [5, 3, 1, 4, 2, 0])
  406:     # 2D reversed Fortran-order
  407:     i = nditer(a.reshape(2, 3).copy(order='F')[::-1],
  408:                                     ['f_index'], [['readonly']])
  409:     assert_equal(iter_indices(i), [1, 0, 3, 2, 5, 4])
  410:     i = nditer(a.reshape(2, 3).copy(order='F')[:, ::-1],
  411:                                     ['f_index'], [['readonly']])
  412:     assert_equal(iter_indices(i), [4, 5, 2, 3, 0, 1])
  413:     i = nditer(a.reshape(2, 3).copy(order='F')[::-1, ::-1],
  414:                                     ['f_index'], [['readonly']])
  415:     assert_equal(iter_indices(i), [5, 4, 3, 2, 1, 0])
  416: 
  417: def test_iter_best_order_f_index_3d():
  418:     # The Fortran index should be correct with any reordering
  419: 
  420:     a = arange(12)
  421:     # 3D C-order
  422:     i = nditer(a.reshape(2, 3, 2), ['f_index'], [['readonly']])
  423:     assert_equal(iter_indices(i),
  424:                             [0, 6, 2, 8, 4, 10, 1, 7, 3, 9, 5, 11])
  425:     # 3D Fortran-order
  426:     i = nditer(a.reshape(2, 3, 2).copy(order='F'),
  427:                                     ['f_index'], [['readonly']])
  428:     assert_equal(iter_indices(i),
  429:                             [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
  430:     # 3D reversed C-order
  431:     i = nditer(a.reshape(2, 3, 2)[::-1], ['f_index'], [['readonly']])
  432:     assert_equal(iter_indices(i),
  433:                             [1, 7, 3, 9, 5, 11, 0, 6, 2, 8, 4, 10])
  434:     i = nditer(a.reshape(2, 3, 2)[:, ::-1], ['f_index'], [['readonly']])
  435:     assert_equal(iter_indices(i),
  436:                             [4, 10, 2, 8, 0, 6, 5, 11, 3, 9, 1, 7])
  437:     i = nditer(a.reshape(2, 3, 2)[:, :, ::-1], ['f_index'], [['readonly']])
  438:     assert_equal(iter_indices(i),
  439:                             [6, 0, 8, 2, 10, 4, 7, 1, 9, 3, 11, 5])
  440:     # 3D reversed Fortran-order
  441:     i = nditer(a.reshape(2, 3, 2).copy(order='F')[::-1],
  442:                                     ['f_index'], [['readonly']])
  443:     assert_equal(iter_indices(i),
  444:                             [1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10])
  445:     i = nditer(a.reshape(2, 3, 2).copy(order='F')[:, ::-1],
  446:                                     ['f_index'], [['readonly']])
  447:     assert_equal(iter_indices(i),
  448:                             [4, 5, 2, 3, 0, 1, 10, 11, 8, 9, 6, 7])
  449:     i = nditer(a.reshape(2, 3, 2).copy(order='F')[:, :, ::-1],
  450:                                     ['f_index'], [['readonly']])
  451:     assert_equal(iter_indices(i),
  452:                             [6, 7, 8, 9, 10, 11, 0, 1, 2, 3, 4, 5])
  453: 
  454: def test_iter_no_inner_full_coalesce():
  455:     # Check no_inner iterators which coalesce into a single inner loop
  456: 
  457:     for shape in [(5,), (3, 4), (2, 3, 4), (2, 3, 4, 3), (2, 3, 2, 2, 3)]:
  458:         size = np.prod(shape)
  459:         a = arange(size)
  460:         # Test each combination of forward and backwards indexing
  461:         for dirs in range(2**len(shape)):
  462:             dirs_index = [slice(None)] * len(shape)
  463:             for bit in range(len(shape)):
  464:                 if ((2**bit) & dirs):
  465:                     dirs_index[bit] = slice(None, None, -1)
  466:             dirs_index = tuple(dirs_index)
  467: 
  468:             aview = a.reshape(shape)[dirs_index]
  469:             # C-order
  470:             i = nditer(aview, ['external_loop'], [['readonly']])
  471:             assert_equal(i.ndim, 1)
  472:             assert_equal(i[0].shape, (size,))
  473:             # Fortran-order
  474:             i = nditer(aview.T, ['external_loop'], [['readonly']])
  475:             assert_equal(i.ndim, 1)
  476:             assert_equal(i[0].shape, (size,))
  477:             # Other order
  478:             if len(shape) > 2:
  479:                 i = nditer(aview.swapaxes(0, 1),
  480:                                     ['external_loop'], [['readonly']])
  481:                 assert_equal(i.ndim, 1)
  482:                 assert_equal(i[0].shape, (size,))
  483: 
  484: def test_iter_no_inner_dim_coalescing():
  485:     # Check no_inner iterators whose dimensions may not coalesce completely
  486: 
  487:     # Skipping the last element in a dimension prevents coalescing
  488:     # with the next-bigger dimension
  489:     a = arange(24).reshape(2, 3, 4)[:, :, :-1]
  490:     i = nditer(a, ['external_loop'], [['readonly']])
  491:     assert_equal(i.ndim, 2)
  492:     assert_equal(i[0].shape, (3,))
  493:     a = arange(24).reshape(2, 3, 4)[:, :-1, :]
  494:     i = nditer(a, ['external_loop'], [['readonly']])
  495:     assert_equal(i.ndim, 2)
  496:     assert_equal(i[0].shape, (8,))
  497:     a = arange(24).reshape(2, 3, 4)[:-1, :, :]
  498:     i = nditer(a, ['external_loop'], [['readonly']])
  499:     assert_equal(i.ndim, 1)
  500:     assert_equal(i[0].shape, (12,))
  501: 
  502:     # Even with lots of 1-sized dimensions, should still coalesce
  503:     a = arange(24).reshape(1, 1, 2, 1, 1, 3, 1, 1, 4, 1, 1)
  504:     i = nditer(a, ['external_loop'], [['readonly']])
  505:     assert_equal(i.ndim, 1)
  506:     assert_equal(i[0].shape, (24,))
  507: 
  508: def test_iter_dim_coalescing():
  509:     # Check that the correct number of dimensions are coalesced
  510: 
  511:     # Tracking a multi-index disables coalescing
  512:     a = arange(24).reshape(2, 3, 4)
  513:     i = nditer(a, ['multi_index'], [['readonly']])
  514:     assert_equal(i.ndim, 3)
  515: 
  516:     # A tracked index can allow coalescing if it's compatible with the array
  517:     a3d = arange(24).reshape(2, 3, 4)
  518:     i = nditer(a3d, ['c_index'], [['readonly']])
  519:     assert_equal(i.ndim, 1)
  520:     i = nditer(a3d.swapaxes(0, 1), ['c_index'], [['readonly']])
  521:     assert_equal(i.ndim, 3)
  522:     i = nditer(a3d.T, ['c_index'], [['readonly']])
  523:     assert_equal(i.ndim, 3)
  524:     i = nditer(a3d.T, ['f_index'], [['readonly']])
  525:     assert_equal(i.ndim, 1)
  526:     i = nditer(a3d.T.swapaxes(0, 1), ['f_index'], [['readonly']])
  527:     assert_equal(i.ndim, 3)
  528: 
  529:     # When C or F order is forced, coalescing may still occur
  530:     a3d = arange(24).reshape(2, 3, 4)
  531:     i = nditer(a3d, order='C')
  532:     assert_equal(i.ndim, 1)
  533:     i = nditer(a3d.T, order='C')
  534:     assert_equal(i.ndim, 3)
  535:     i = nditer(a3d, order='F')
  536:     assert_equal(i.ndim, 3)
  537:     i = nditer(a3d.T, order='F')
  538:     assert_equal(i.ndim, 1)
  539:     i = nditer(a3d, order='A')
  540:     assert_equal(i.ndim, 1)
  541:     i = nditer(a3d.T, order='A')
  542:     assert_equal(i.ndim, 1)
  543: 
  544: def test_iter_broadcasting():
  545:     # Standard NumPy broadcasting rules
  546: 
  547:     # 1D with scalar
  548:     i = nditer([arange(6), np.int32(2)], ['multi_index'], [['readonly']] * 2)
  549:     assert_equal(i.itersize, 6)
  550:     assert_equal(i.shape, (6,))
  551: 
  552:     # 2D with scalar
  553:     i = nditer([arange(6).reshape(2, 3), np.int32(2)],
  554:                         ['multi_index'], [['readonly']] * 2)
  555:     assert_equal(i.itersize, 6)
  556:     assert_equal(i.shape, (2, 3))
  557:     # 2D with 1D
  558:     i = nditer([arange(6).reshape(2, 3), arange(3)],
  559:                         ['multi_index'], [['readonly']] * 2)
  560:     assert_equal(i.itersize, 6)
  561:     assert_equal(i.shape, (2, 3))
  562:     i = nditer([arange(2).reshape(2, 1), arange(3)],
  563:                         ['multi_index'], [['readonly']] * 2)
  564:     assert_equal(i.itersize, 6)
  565:     assert_equal(i.shape, (2, 3))
  566:     # 2D with 2D
  567:     i = nditer([arange(2).reshape(2, 1), arange(3).reshape(1, 3)],
  568:                         ['multi_index'], [['readonly']] * 2)
  569:     assert_equal(i.itersize, 6)
  570:     assert_equal(i.shape, (2, 3))
  571: 
  572:     # 3D with scalar
  573:     i = nditer([np.int32(2), arange(24).reshape(4, 2, 3)],
  574:                         ['multi_index'], [['readonly']] * 2)
  575:     assert_equal(i.itersize, 24)
  576:     assert_equal(i.shape, (4, 2, 3))
  577:     # 3D with 1D
  578:     i = nditer([arange(3), arange(24).reshape(4, 2, 3)],
  579:                         ['multi_index'], [['readonly']] * 2)
  580:     assert_equal(i.itersize, 24)
  581:     assert_equal(i.shape, (4, 2, 3))
  582:     i = nditer([arange(3), arange(8).reshape(4, 2, 1)],
  583:                         ['multi_index'], [['readonly']] * 2)
  584:     assert_equal(i.itersize, 24)
  585:     assert_equal(i.shape, (4, 2, 3))
  586:     # 3D with 2D
  587:     i = nditer([arange(6).reshape(2, 3), arange(24).reshape(4, 2, 3)],
  588:                         ['multi_index'], [['readonly']] * 2)
  589:     assert_equal(i.itersize, 24)
  590:     assert_equal(i.shape, (4, 2, 3))
  591:     i = nditer([arange(2).reshape(2, 1), arange(24).reshape(4, 2, 3)],
  592:                         ['multi_index'], [['readonly']] * 2)
  593:     assert_equal(i.itersize, 24)
  594:     assert_equal(i.shape, (4, 2, 3))
  595:     i = nditer([arange(3).reshape(1, 3), arange(8).reshape(4, 2, 1)],
  596:                         ['multi_index'], [['readonly']] * 2)
  597:     assert_equal(i.itersize, 24)
  598:     assert_equal(i.shape, (4, 2, 3))
  599:     # 3D with 3D
  600:     i = nditer([arange(2).reshape(1, 2, 1), arange(3).reshape(1, 1, 3),
  601:                         arange(4).reshape(4, 1, 1)],
  602:                         ['multi_index'], [['readonly']] * 3)
  603:     assert_equal(i.itersize, 24)
  604:     assert_equal(i.shape, (4, 2, 3))
  605:     i = nditer([arange(6).reshape(1, 2, 3), arange(4).reshape(4, 1, 1)],
  606:                         ['multi_index'], [['readonly']] * 2)
  607:     assert_equal(i.itersize, 24)
  608:     assert_equal(i.shape, (4, 2, 3))
  609:     i = nditer([arange(24).reshape(4, 2, 3), arange(12).reshape(4, 1, 3)],
  610:                         ['multi_index'], [['readonly']] * 2)
  611:     assert_equal(i.itersize, 24)
  612:     assert_equal(i.shape, (4, 2, 3))
  613: 
  614: def test_iter_itershape():
  615:     # Check that allocated outputs work with a specified shape
  616:     a = np.arange(6, dtype='i2').reshape(2, 3)
  617:     i = nditer([a, None], [], [['readonly'], ['writeonly', 'allocate']],
  618:                             op_axes=[[0, 1, None], None],
  619:                             itershape=(-1, -1, 4))
  620:     assert_equal(i.operands[1].shape, (2, 3, 4))
  621:     assert_equal(i.operands[1].strides, (24, 8, 2))
  622: 
  623:     i = nditer([a.T, None], [], [['readonly'], ['writeonly', 'allocate']],
  624:                             op_axes=[[0, 1, None], None],
  625:                             itershape=(-1, -1, 4))
  626:     assert_equal(i.operands[1].shape, (3, 2, 4))
  627:     assert_equal(i.operands[1].strides, (8, 24, 2))
  628: 
  629:     i = nditer([a.T, None], [], [['readonly'], ['writeonly', 'allocate']],
  630:                             order='F',
  631:                             op_axes=[[0, 1, None], None],
  632:                             itershape=(-1, -1, 4))
  633:     assert_equal(i.operands[1].shape, (3, 2, 4))
  634:     assert_equal(i.operands[1].strides, (2, 6, 12))
  635: 
  636:     # If we specify 1 in the itershape, it shouldn't allow broadcasting
  637:     # of that dimension to a bigger value
  638:     assert_raises(ValueError, nditer, [a, None], [],
  639:                             [['readonly'], ['writeonly', 'allocate']],
  640:                             op_axes=[[0, 1, None], None],
  641:                             itershape=(-1, 1, 4))
  642:     # Test bug that for no op_axes but itershape, they are NULLed correctly
  643:     i = np.nditer([np.ones(2), None, None], itershape=(2,))
  644: 
  645: def test_iter_broadcasting_errors():
  646:     # Check that errors are thrown for bad broadcasting shapes
  647: 
  648:     # 1D with 1D
  649:     assert_raises(ValueError, nditer, [arange(2), arange(3)],
  650:                     [], [['readonly']] * 2)
  651:     # 2D with 1D
  652:     assert_raises(ValueError, nditer,
  653:                     [arange(6).reshape(2, 3), arange(2)],
  654:                     [], [['readonly']] * 2)
  655:     # 2D with 2D
  656:     assert_raises(ValueError, nditer,
  657:                     [arange(6).reshape(2, 3), arange(9).reshape(3, 3)],
  658:                     [], [['readonly']] * 2)
  659:     assert_raises(ValueError, nditer,
  660:                     [arange(6).reshape(2, 3), arange(4).reshape(2, 2)],
  661:                     [], [['readonly']] * 2)
  662:     # 3D with 3D
  663:     assert_raises(ValueError, nditer,
  664:                     [arange(36).reshape(3, 3, 4), arange(24).reshape(2, 3, 4)],
  665:                     [], [['readonly']] * 2)
  666:     assert_raises(ValueError, nditer,
  667:                     [arange(8).reshape(2, 4, 1), arange(24).reshape(2, 3, 4)],
  668:                     [], [['readonly']] * 2)
  669: 
  670:     # Verify that the error message mentions the right shapes
  671:     try:
  672:         nditer([arange(2).reshape(1, 2, 1),
  673:                 arange(3).reshape(1, 3),
  674:                 arange(6).reshape(2, 3)],
  675:                [],
  676:                [['readonly'], ['readonly'], ['writeonly', 'no_broadcast']])
  677:         raise AssertionError('Should have raised a broadcast error')
  678:     except ValueError as e:
  679:         msg = str(e)
  680:         # The message should contain the shape of the 3rd operand
  681:         assert_(msg.find('(2,3)') >= 0,
  682:                 f'Message "{msg}" doesn\'t contain operand shape (2,3)')
  683:         # The message should contain the broadcast shape
  684:         assert_(msg.find('(1,2,3)') >= 0,
  685:                 f'Message "{msg}" doesn\'t contain broadcast shape (1,2,3)')
  686: 
  687:     try:
  688:         nditer([arange(6).reshape(2, 3), arange(2)],
  689:                [],
  690:                [['readonly'], ['readonly']],
  691:                op_axes=[[0, 1], [0, np.newaxis]],
  692:                itershape=(4, 3))
  693:         raise AssertionError('Should have raised a broadcast error')
  694:     except ValueError as e:
  695:         msg = str(e)
  696:         # The message should contain "shape->remappedshape" for each operand
  697:         assert_(msg.find('(2,3)->(2,3)') >= 0,
  698:             f'Message "{msg}" doesn\'t contain operand shape (2,3)->(2,3)')
  699:         assert_(msg.find('(2,)->(2,newaxis)') >= 0,
  700:                 ('Message "%s" doesn\'t contain remapped operand shape'
  701:                 '(2,)->(2,newaxis)') % msg)
  702:         # The message should contain the itershape parameter
  703:         assert_(msg.find('(4,3)') >= 0,
  704:                 f'Message "{msg}" doesn\'t contain itershape parameter (4,3)')
  705: 
  706:     try:
  707:         nditer([np.zeros((2, 1, 1)), np.zeros((2,))],
  708:                [],
  709:                [['writeonly', 'no_broadcast'], ['readonly']])
  710:         raise AssertionError('Should have raised a broadcast error')
  711:     except ValueError as e:
  712:         msg = str(e)
  713:         # The message should contain the shape of the bad operand
  714:         assert_(msg.find('(2,1,1)') >= 0,
  715:             f'Message "{msg}" doesn\'t contain operand shape (2,1,1)')
  716:         # The message should contain the broadcast shape
  717:         assert_(msg.find('(2,1,2)') >= 0,
  718:                 f'Message "{msg}" doesn\'t contain the broadcast shape (2,1,2)')
  719: 
  720: def test_iter_flags_errors():
  721:     # Check that bad combinations of flags produce errors
  722: 
  723:     a = arange(6)
  724: 
  725:     # Not enough operands
  726:     assert_raises(ValueError, nditer, [], [], [])
  727:     # Bad global flag
  728:     assert_raises(ValueError, nditer, [a], ['bad flag'], [['readonly']])
  729:     # Bad op flag
  730:     assert_raises(ValueError, nditer, [a], [], [['readonly', 'bad flag']])
  731:     # Bad order parameter
  732:     assert_raises(ValueError, nditer, [a], [], [['readonly']], order='G')
  733:     # Bad casting parameter
  734:     assert_raises(ValueError, nditer, [a], [], [['readonly']], casting='noon')
  735:     # op_flags must match ops
  736:     assert_raises(ValueError, nditer, [a] * 3, [], [['readonly']] * 2)
  737:     # Cannot track both a C and an F index
  738:     assert_raises(ValueError, nditer, a,
  739:                 ['c_index', 'f_index'], [['readonly']])
  740:     # Inner iteration and multi-indices/indices are incompatible
  741:     assert_raises(ValueError, nditer, a,
  742:                 ['external_loop', 'multi_index'], [['readonly']])
  743:     assert_raises(ValueError, nditer, a,
  744:                 ['external_loop', 'c_index'], [['readonly']])
  745:     assert_raises(ValueError, nditer, a,
  746:                 ['external_loop', 'f_index'], [['readonly']])
  747:     # Must specify exactly one of readwrite/readonly/writeonly per operand
  748:     assert_raises(ValueError, nditer, a, [], [[]])
  749:     assert_raises(ValueError, nditer, a, [], [['readonly', 'writeonly']])
  750:     assert_raises(ValueError, nditer, a, [], [['readonly', 'readwrite']])
  751:     assert_raises(ValueError, nditer, a, [], [['writeonly', 'readwrite']])
  752:     assert_raises(ValueError, nditer, a,
  753:                 [], [['readonly', 'writeonly', 'readwrite']])
  754:     # Python scalars are always readonly
  755:     assert_raises(TypeError, nditer, 1.5, [], [['writeonly']])
  756:     assert_raises(TypeError, nditer, 1.5, [], [['readwrite']])
  757:     # Array scalars are always readonly
  758:     assert_raises(TypeError, nditer, np.int32(1), [], [['writeonly']])
  759:     assert_raises(TypeError, nditer, np.int32(1), [], [['readwrite']])
  760:     # Check readonly array
  761:     a.flags.writeable = False
  762:     assert_raises(ValueError, nditer, a, [], [['writeonly']])
  763:     assert_raises(ValueError, nditer, a, [], [['readwrite']])
  764:     a.flags.writeable = True
  765:     # Multi-indices available only with the multi_index flag
  766:     i = nditer(arange(6), [], [['readonly']])
  767:     assert_raises(ValueError, lambda i: i.multi_index, i)
  768:     # Index available only with an index flag
  769:     assert_raises(ValueError, lambda i: i.index, i)
  770:     # GotoCoords and GotoIndex incompatible with buffering or no_inner
  771: 
  772:     def assign_multi_index(i):
  773:         i.multi_index = (0,)
  774: 
  775:     def assign_index(i):
  776:         i.index = 0
  777: 
  778:     def assign_iterindex(i):
  779:         i.iterindex = 0
  780: 
  781:     def assign_iterrange(i):
  782:         i.iterrange = (0, 1)
  783:     i = nditer(arange(6), ['external_loop'])
  784:     assert_raises(ValueError, assign_multi_index, i)
  785:     assert_raises(ValueError, assign_index, i)
  786:     assert_raises(ValueError, assign_iterindex, i)
  787:     assert_raises(ValueError, assign_iterrange, i)
  788:     i = nditer(arange(6), ['buffered'])
  789:     assert_raises(ValueError, assign_multi_index, i)
  790:     assert_raises(ValueError, assign_index, i)
  791:     assert_raises(ValueError, assign_iterrange, i)
  792:     # Can't iterate if size is zero
  793:     assert_raises(ValueError, nditer, np.array([]))
  794: 
  795: def test_iter_slice():
  796:     a, b, c = np.arange(3), np.arange(3), np.arange(3.)
  797:     i = nditer([a, b, c], [], ['readwrite'])
  798:     with i:
  799:         i[0:2] = (3, 3)
  800:         assert_equal(a, [3, 1, 2])
  801:         assert_equal(b, [3, 1, 2])
  802:         assert_equal(c, [0, 1, 2])
  803:         i[1] = 12
  804:         assert_equal(i[0:2], [3, 12])
  805: 
  806: def test_iter_assign_mapping():
  807:     a = np.arange(24, dtype='f8').reshape(2, 3, 4).T
  808:     it = np.nditer(a, [], [['readwrite', 'updateifcopy']],
  809:                        casting='same_kind', op_dtypes=[np.dtype('f4')])
  810:     with it:
  811:         it.operands[0][...] = 3
  812:         it.operands[0][...] = 14
  813:     assert_equal(a, 14)
  814:     it = np.nditer(a, [], [['readwrite', 'updateifcopy']],
  815:                        casting='same_kind', op_dtypes=[np.dtype('f4')])
  816:     with it:
  817:         x = it.operands[0][-1:1]
  818:         x[...] = 14
  819:         it.operands[0][...] = -1234
  820:     assert_equal(a, -1234)
  821:     # check for no warnings on dealloc
  822:     x = None
  823:     it = None
  824: 
  825: def test_iter_nbo_align_contig():
  826:     # Check that byte order, alignment, and contig changes work
  827: 
  828:     # Byte order change by requesting a specific dtype
  829:     a = np.arange(6, dtype='f4')
  830:     au = a.byteswap()
  831:     au = au.view(au.dtype.newbyteorder())
  832:     assert_(a.dtype.byteorder != au.dtype.byteorder)
  833:     i = nditer(au, [], [['readwrite', 'updateifcopy']],
  834:                         casting='equiv',
  835:                         op_dtypes=[np.dtype('f4')])
  836:     with i:
  837:         # context manager triggers WRITEBACKIFCOPY on i at exit
  838:         assert_equal(i.dtypes[0].byteorder, a.dtype.byteorder)
  839:         assert_equal(i.operands[0].dtype.byteorder, a.dtype.byteorder)
  840:         assert_equal(i.operands[0], a)
  841:         i.operands[0][:] = 2
  842:     assert_equal(au, [2] * 6)
  843:     del i  # should not raise a warning
  844:     # Byte order change by requesting NBO
  845:     a = np.arange(6, dtype='f4')
  846:     au = a.byteswap()
  847:     au = au.view(au.dtype.newbyteorder())
  848:     assert_(a.dtype.byteorder != au.dtype.byteorder)
  849:     with nditer(au, [], [['readwrite', 'updateifcopy', 'nbo']],
  850:                         casting='equiv') as i:
  851:         # context manager triggers UPDATEIFCOPY on i at exit
  852:         assert_equal(i.dtypes[0].byteorder, a.dtype.byteorder)
  853:         assert_equal(i.operands[0].dtype.byteorder, a.dtype.byteorder)
  854:         assert_equal(i.operands[0], a)
  855:         i.operands[0][:] = 12345
  856:         i.operands[0][:] = 2
  857:     assert_equal(au, [2] * 6)
  858: 
  859:     # Unaligned input
  860:     a = np.zeros((6 * 4 + 1,), dtype='i1')[1:]
  861:     a.dtype = 'f4'
  862:     a[:] = np.arange(6, dtype='f4')
  863:     assert_(not a.flags.aligned)
  864:     # Without 'aligned', shouldn't copy
  865:     i = nditer(a, [], [['readonly']])
  866:     assert_(not i.operands[0].flags.aligned)
  867:     assert_equal(i.operands[0], a)
  868:     # With 'aligned', should make a copy
  869:     with nditer(a, [], [['readwrite', 'updateifcopy', 'aligned']]) as i:
  870:         assert_(i.operands[0].flags.aligned)
  871:         # context manager triggers UPDATEIFCOPY on i at exit
  872:         assert_equal(i.operands[0], a)
  873:         i.operands[0][:] = 3
  874:     assert_equal(a, [3] * 6)
  875: 
  876:     # Discontiguous input
  877:     a = arange(12)
  878:     # If it is contiguous, shouldn't copy
  879:     i = nditer(a[:6], [], [['readonly']])
  880:     assert_(i.operands[0].flags.contiguous)
  881:     assert_equal(i.operands[0], a[:6])
  882:     # If it isn't contiguous, should buffer
  883:     i = nditer(a[::2], ['buffered', 'external_loop'],
  884:                         [['readonly', 'contig']],
  885:                         buffersize=10)
  886:     assert_(i[0].flags.contiguous)
  887:     assert_equal(i[0], a[::2])
  888: 
  889: def test_iter_array_cast():
  890:     # Check that arrays are cast as requested
  891: 
  892:     # No cast 'f4' -> 'f4'
  893:     a = np.arange(6, dtype='f4').reshape(2, 3)
  894:     i = nditer(a, [], [['readwrite']], op_dtypes=[np.dtype('f4')])
  895:     with i:
  896:         assert_equal(i.operands[0], a)
  897:         assert_equal(i.operands[0].dtype, np.dtype('f4'))
  898: 
  899:     # Byte-order cast '<f4' -> '>f4'
  900:     a = np.arange(6, dtype='<f4').reshape(2, 3)
  901:     with nditer(a, [], [['readwrite', 'updateifcopy']],
  902:             casting='equiv',
  903:             op_dtypes=[np.dtype('>f4')]) as i:
  904:         assert_equal(i.operands[0], a)
  905:         assert_equal(i.operands[0].dtype, np.dtype('>f4'))
  906: 
  907:     # Safe case 'f4' -> 'f8'
  908:     a = np.arange(24, dtype='f4').reshape(2, 3, 4).swapaxes(1, 2)
  909:     i = nditer(a, [], [['readonly', 'copy']],
  910:             casting='safe',
  911:             op_dtypes=[np.dtype('f8')])
  912:     assert_equal(i.operands[0], a)
  913:     assert_equal(i.operands[0].dtype, np.dtype('f8'))
  914:     # The memory layout of the temporary should match a (a is (48,4,16))
  915:     # except negative strides get flipped to positive strides.
  916:     assert_equal(i.operands[0].strides, (96, 8, 32))
  917:     a = a[::-1, :, ::-1]
  918:     i = nditer(a, [], [['readonly', 'copy']],
  919:             casting='safe',
  920:             op_dtypes=[np.dtype('f8')])
  921:     assert_equal(i.operands[0], a)
  922:     assert_equal(i.operands[0].dtype, np.dtype('f8'))
  923:     assert_equal(i.operands[0].strides, (96, 8, 32))
  924: 
  925:     # Same-kind cast 'f8' -> 'f4' -> 'f8'
  926:     a = np.arange(24, dtype='f8').reshape(2, 3, 4).T
  927:     with nditer(a, [],
  928:             [['readwrite', 'updateifcopy']],
  929:             casting='same_kind',
  930:             op_dtypes=[np.dtype('f4')]) as i:
  931:         assert_equal(i.operands[0], a)
  932:         assert_equal(i.operands[0].dtype, np.dtype('f4'))
  933:         assert_equal(i.operands[0].strides, (4, 16, 48))
  934:         # Check that WRITEBACKIFCOPY is activated at exit
  935:         i.operands[0][2, 1, 1] = -12.5
  936:         assert_(a[2, 1, 1] != -12.5)
  937:     assert_equal(a[2, 1, 1], -12.5)
  938: 
  939:     a = np.arange(6, dtype='i4')[::-2]
  940:     with nditer(a, [],
  941:             [['writeonly', 'updateifcopy']],
  942:             casting='unsafe',
  943:             op_dtypes=[np.dtype('f4')]) as i:
  944:         assert_equal(i.operands[0].dtype, np.dtype('f4'))
  945:         # Even though the stride was negative in 'a', it
  946:         # becomes positive in the temporary
  947:         assert_equal(i.operands[0].strides, (4,))
  948:         i.operands[0][:] = [1, 2, 3]
  949:     assert_equal(a, [1, 2, 3])
  950: 
  951: def test_iter_array_cast_errors():
  952:     # Check that invalid casts are caught
  953: 
  954:     # Need to enable copying for casts to occur
  955:     assert_raises(TypeError, nditer, arange(2, dtype='f4'), [],
  956:                 [['readonly']], op_dtypes=[np.dtype('f8')])
  957:     # Also need to allow casting for casts to occur
  958:     assert_raises(TypeError, nditer, arange(2, dtype='f4'), [],
  959:                 [['readonly', 'copy']], casting='no',
  960:                 op_dtypes=[np.dtype('f8')])
  961:     assert_raises(TypeError, nditer, arange(2, dtype='f4'), [],
  962:                 [['readonly', 'copy']], casting='equiv',
  963:                 op_dtypes=[np.dtype('f8')])
  964:     assert_raises(TypeError, nditer, arange(2, dtype='f8'), [],
  965:                 [['writeonly', 'updateifcopy']],
  966:                 casting='no',
  967:                 op_dtypes=[np.dtype('f4')])
  968:     assert_raises(TypeError, nditer, arange(2, dtype='f8'), [],
  969:                 [['writeonly', 'updateifcopy']],
  970:                 casting='equiv',
  971:                 op_dtypes=[np.dtype('f4')])
  972:     # '<f4' -> '>f4' should not work with casting='no'
  973:     assert_raises(TypeError, nditer, arange(2, dtype='<f4'), [],
  974:                 [['readonly', 'copy']], casting='no',
  975:                 op_dtypes=[np.dtype('>f4')])
  976:     # 'f4' -> 'f8' is a safe cast, but 'f8' -> 'f4' isn't
  977:     assert_raises(TypeError, nditer, arange(2, dtype='f4'), [],
  978:                 [['readwrite', 'updateifcopy']],
  979:                 casting='safe',
  980:                 op_dtypes=[np.dtype('f8')])
  981:     assert_raises(TypeError, nditer, arange(2, dtype='f8'), [],
  982:                 [['readwrite', 'updateifcopy']],
  983:                 casting='safe',
  984:                 op_dtypes=[np.dtype('f4')])
  985:     # 'f4' -> 'i4' is neither a safe nor a same-kind cast
  986:     assert_raises(TypeError, nditer, arange(2, dtype='f4'), [],
  987:                 [['readonly', 'copy']],
  988:                 casting='same_kind',
  989:                 op_dtypes=[np.dtype('i4')])
  990:     assert_raises(TypeError, nditer, arange(2, dtype='i4'), [],
  991:                 [['writeonly', 'updateifcopy']],
  992:                 casting='same_kind',
  993:                 op_dtypes=[np.dtype('f4')])
  994: 
  995: def test_iter_scalar_cast():
  996:     # Check that scalars are cast as requested
  997: 
  998:     # No cast 'f4' -> 'f4'
  999:     i = nditer(np.float32(2.5), [], [['readonly']],
 1000:                     op_dtypes=[np.dtype('f4')])
 1001:     assert_equal(i.dtypes[0], np.dtype('f4'))
 1002:     assert_equal(i.value.dtype, np.dtype('f4'))
 1003:     assert_equal(i.value, 2.5)
 1004:     # Safe cast 'f4' -> 'f8'
 1005:     i = nditer(np.float32(2.5), [],
 1006:                     [['readonly', 'copy']],
 1007:                     casting='safe',
 1008:                     op_dtypes=[np.dtype('f8')])
 1009:     assert_equal(i.dtypes[0], np.dtype('f8'))
 1010:     assert_equal(i.value.dtype, np.dtype('f8'))
 1011:     assert_equal(i.value, 2.5)
 1012:     # Same-kind cast 'f8' -> 'f4'
 1013:     i = nditer(np.float64(2.5), [],
 1014:                     [['readonly', 'copy']],
 1015:                     casting='same_kind',
 1016:                     op_dtypes=[np.dtype('f4')])
 1017:     assert_equal(i.dtypes[0], np.dtype('f4'))
 1018:     assert_equal(i.value.dtype, np.dtype('f4'))
 1019:     assert_equal(i.value, 2.5)
 1020:     # Unsafe cast 'f8' -> 'i4'
 1021:     i = nditer(np.float64(3.0), [],
 1022:                     [['readonly', 'copy']],
 1023:                     casting='unsafe',
 1024:                     op_dtypes=[np.dtype('i4')])
 1025:     assert_equal(i.dtypes[0], np.dtype('i4'))
 1026:     assert_equal(i.value.dtype, np.dtype('i4'))
 1027:     assert_equal(i.value, 3)
 1028:     # Readonly scalars may be cast even without setting COPY or BUFFERED
 1029:     i = nditer(3, [], [['readonly']], op_dtypes=[np.dtype('f8')])
 1030:     assert_equal(i[0].dtype, np.dtype('f8'))
 1031:     assert_equal(i[0], 3.)
 1032: 
 1033: def test_iter_scalar_cast_errors():
 1034:     # Check that invalid casts are caught
 1035: 
 1036:     # Need to allow copying/buffering for write casts of scalars to occur
 1037:     assert_raises(TypeError, nditer, np.float32(2), [],
 1038:                 [['readwrite']], op_dtypes=[np.dtype('f8')])
 1039:     assert_raises(TypeError, nditer, 2.5, [],
 1040:                 [['readwrite']], op_dtypes=[np.dtype('f4')])
 1041:     # 'f8' -> 'f4' isn't a safe cast if the value would overflow
 1042:     assert_raises(TypeError, nditer, np.float64(1e60), [],
 1043:                 [['readonly']],
 1044:                 casting='safe',
 1045:                 op_dtypes=[np.dtype('f4')])
 1046:     # 'f4' -> 'i4' is neither a safe nor a same-kind cast
 1047:     assert_raises(TypeError, nditer, np.float32(2), [],
 1048:                 [['readonly']],
 1049:                 casting='same_kind',
 1050:                 op_dtypes=[np.dtype('i4')])
 1051: 
 1052: def test_iter_object_arrays_basic():
 1053:     # Check that object arrays work
 1054: 
 1055:     obj = {'a': 3, 'b': 'd'}
 1056:     a = np.array([[1, 2, 3], None, obj, None], dtype='O')
 1057:     if HAS_REFCOUNT:
 1058:         rc = sys.getrefcount(obj)
 1059: 
 1060:     # Need to allow references for object arrays
 1061:     assert_raises(TypeError, nditer, a)
 1062:     if HAS_REFCOUNT:
 1063:         assert_equal(sys.getrefcount(obj), rc)
 1064: 
 1065:     i = nditer(a, ['refs_ok'], ['readonly'])
 1066:     vals = [x_[()] for x_ in i]
 1067:     assert_equal(np.array(vals, dtype='O'), a)
 1068:     vals, i, x = [None] * 3
 1069:     if HAS_REFCOUNT:
 1070:         assert_equal(sys.getrefcount(obj), rc)
 1071: 
 1072:     i = nditer(a.reshape(2, 2).T, ['refs_ok', 'buffered'],
 1073:                         ['readonly'], order='C')
 1074:     assert_(i.iterationneedsapi)
 1075:     vals = [x_[()] for x_ in i]
 1076:     assert_equal(np.array(vals, dtype='O'), a.reshape(2, 2).ravel(order='F'))
 1077:     vals, i, x = [None] * 3
 1078:     if HAS_REFCOUNT:
 1079:         assert_equal(sys.getrefcount(obj), rc)
 1080: 
 1081:     i = nditer(a.reshape(2, 2).T, ['refs_ok', 'buffered'],
 1082:                         ['readwrite'], order='C')
 1083:     with i:
 1084:         for x in i:
 1085:             x[...] = None
 1086:         vals, i, x = [None] * 3
 1087:     if HAS_REFCOUNT:
 1088:         assert_(sys.getrefcount(obj) == rc - 1)
 1089:     assert_equal(a, np.array([None] * 4, dtype='O'))
 1090: 
 1091: def test_iter_object_arrays_conversions():
 1092:     # Conversions to/from objects
 1093:     a = np.arange(6, dtype='O')
 1094:     i = nditer(a, ['refs_ok', 'buffered'], ['readwrite'],
 1095:                     casting='unsafe', op_dtypes='i4')
 1096:     with i:
 1097:         for x in i:
 1098:             x[...] += 1
 1099:     assert_equal(a, np.arange(6) + 1)
 1100: 
 1101:     a = np.arange(6, dtype='i4')
 1102:     i = nditer(a, ['refs_ok', 'buffered'], ['readwrite'],
 1103:                     casting='unsafe', op_dtypes='O')
 1104:     with i:
 1105:         for x in i:
 1106:             x[...] += 1
 1107:     assert_equal(a, np.arange(6) + 1)
 1108: 
 1109:     # Non-contiguous object array
 1110:     a = np.zeros((6,), dtype=[('p', 'i1'), ('a', 'O')])
 1111:     a = a['a']
 1112:     a[:] = np.arange(6)
 1113:     i = nditer(a, ['refs_ok', 'buffered'], ['readwrite'],
 1114:                     casting='unsafe', op_dtypes='i4')
 1115:     with i:
 1116:         for x in i:
 1117:             x[...] += 1
 1118:     assert_equal(a, np.arange(6) + 1)
 1119: 
 1120:     # Non-contiguous value array
 1121:     a = np.zeros((6,), dtype=[('p', 'i1'), ('a', 'i4')])
 1122:     a = a['a']
 1123:     a[:] = np.arange(6) + 98172488
 1124:     i = nditer(a, ['refs_ok', 'buffered'], ['readwrite'],
 1125:                     casting='unsafe', op_dtypes='O')
 1126:     with i:
 1127:         ob = i[0][()]
 1128:         if HAS_REFCOUNT:
 1129:             rc = sys.getrefcount(ob)
 1130:         for x in i:
 1131:             x[...] += 1
 1132:         if HAS_REFCOUNT:
 1133:             newrc = sys.getrefcount(ob)
 1134:             assert_(newrc == rc - 1)
 1135:     assert_equal(a, np.arange(6) + 98172489)
 1136: 
 1137: def test_iter_common_dtype():
 1138:     # Check that the iterator finds a common data type correctly
 1139:     # (some checks are somewhat duplicate after adopting NEP 50)
 1140: 
 1141:     i = nditer([array([3], dtype='f4'), array([0], dtype='f8')],
 1142:                     ['common_dtype'],
 1143:                     [['readonly', 'copy']] * 2,
 1144:                     casting='safe')
 1145:     assert_equal(i.dtypes[0], np.dtype('f8'))
 1146:     assert_equal(i.dtypes[1], np.dtype('f8'))
 1147:     i = nditer([array([3], dtype='i4'), array([0], dtype='f4')],
 1148:                     ['common_dtype'],
 1149:                     [['readonly', 'copy']] * 2,
 1150:                     casting='safe')
 1151:     assert_equal(i.dtypes[0], np.dtype('f8'))
 1152:     assert_equal(i.dtypes[1], np.dtype('f8'))
 1153:     i = nditer([array([3], dtype='f4'), array(0, dtype='f8')],
 1154:                     ['common_dtype'],
 1155:                     [['readonly', 'copy']] * 2,
 1156:                     casting='same_kind')
 1157:     assert_equal(i.dtypes[0], np.dtype('f8'))
 1158:     assert_equal(i.dtypes[1], np.dtype('f8'))
 1159:     i = nditer([array([3], dtype='u4'), array(0, dtype='i4')],
 1160:                     ['common_dtype'],
 1161:                     [['readonly', 'copy']] * 2,
 1162:                     casting='safe')
 1163:     assert_equal(i.dtypes[0], np.dtype('i8'))
 1164:     assert_equal(i.dtypes[1], np.dtype('i8'))
 1165:     i = nditer([array([3], dtype='u4'), array(-12, dtype='i4')],
 1166:                     ['common_dtype'],
 1167:                     [['readonly', 'copy']] * 2,
 1168:                     casting='safe')
 1169:     assert_equal(i.dtypes[0], np.dtype('i8'))
 1170:     assert_equal(i.dtypes[1], np.dtype('i8'))
 1171:     i = nditer([array([3], dtype='u4'), array(-12, dtype='i4'),
 1172:                  array([2j], dtype='c8'), array([9], dtype='f8')],
 1173:                     ['common_dtype'],
 1174:                     [['readonly', 'copy']] * 4,
 1175:                     casting='safe')
 1176:     assert_equal(i.dtypes[0], np.dtype('c16'))
 1177:     assert_equal(i.dtypes[1], np.dtype('c16'))
 1178:     assert_equal(i.dtypes[2], np.dtype('c16'))
 1179:     assert_equal(i.dtypes[3], np.dtype('c16'))
 1180:     assert_equal(i.value, (3, -12, 2j, 9))
 1181: 
 1182:     # When allocating outputs, other outputs aren't factored in
 1183:     i = nditer([array([3], dtype='i4'), None, array([2j], dtype='c16')], [],
 1184:                     [['readonly', 'copy'],
 1185:                      ['writeonly', 'allocate'],
 1186:                      ['writeonly']],
 1187:                     casting='safe')
 1188:     assert_equal(i.dtypes[0], np.dtype('i4'))
 1189:     assert_equal(i.dtypes[1], np.dtype('i4'))
 1190:     assert_equal(i.dtypes[2], np.dtype('c16'))
 1191:     # But, if common data types are requested, they are
 1192:     i = nditer([array([3], dtype='i4'), None, array([2j], dtype='c16')],
 1193:                     ['common_dtype'],
 1194:                     [['readonly', 'copy'],
 1195:                      ['writeonly', 'allocate'],
 1196:                      ['writeonly']],
 1197:                     casting='safe')
 1198:     assert_equal(i.dtypes[0], np.dtype('c16'))
 1199:     assert_equal(i.dtypes[1], np.dtype('c16'))
 1200:     assert_equal(i.dtypes[2], np.dtype('c16'))
 1201: 
 1202: def test_iter_copy_if_overlap():
 1203:     # Ensure the iterator makes copies on read/write overlap, if requested
 1204: 
 1205:     # Copy not needed, 1 op
 1206:     for flag in ['readonly', 'writeonly', 'readwrite']:
 1207:         a = arange(10)
 1208:         i = nditer([a], ['copy_if_overlap'], [[flag]])
 1209:         with i:
 1210:             assert_(i.operands[0] is a)
 1211: 
 1212:     # Copy needed, 2 ops, read-write overlap
 1213:     x = arange(10)
 1214:     a = x[1:]
 1215:     b = x[:-1]
 1216:     with nditer([a, b], ['copy_if_overlap'], [['readonly'], ['readwrite']]) as i:
 1217:         assert_(not np.shares_memory(*i.operands))
 1218: 
 1219:     # Copy not needed with elementwise, 2 ops, exactly same arrays
 1220:     x = arange(10)
 1221:     a = x
 1222:     b = x
 1223:     i = nditer([a, b], ['copy_if_overlap'], [['readonly', 'overlap_assume_elementwise'],
 1224:                                              ['readwrite', 'overlap_assume_elementwise']])
 1225:     with i:
 1226:         assert_(i.operands[0] is a and i.operands[1] is b)
 1227:     with nditer([a, b], ['copy_if_overlap'], [['readonly'], ['readwrite']]) as i:
 1228:         assert_(i.operands[0] is a and not np.shares_memory(i.operands[1], b))
 1229: 
 1230:     # Copy not needed, 2 ops, no overlap
 1231:     x = arange(10)
 1232:     a = x[::2]
 1233:     b = x[1::2]
 1234:     i = nditer([a, b], ['copy_if_overlap'], [['readonly'], ['writeonly']])
 1235:     assert_(i.operands[0] is a and i.operands[1] is b)
 1236: 
 1237:     # Copy needed, 2 ops, read-write overlap
 1238:     x = arange(4, dtype=np.int8)
 1239:     a = x[3:]
 1240:     b = x.view(np.int32)[:1]
 1241:     with nditer([a, b], ['copy_if_overlap'], [['readonly'], ['writeonly']]) as i:
 1242:         assert_(not np.shares_memory(*i.operands))
 1243: 
 1244:     # Copy needed, 3 ops, read-write overlap
 1245:     for flag in ['writeonly', 'readwrite']:
 1246:         x = np.ones([10, 10])
 1247:         a = x
 1248:         b = x.T
 1249:         c = x
 1250:         with nditer([a, b, c], ['copy_if_overlap'],
 1251:                    [['readonly'], ['readonly'], [flag]]) as i:
 1252:             a2, b2, c2 = i.operands
 1253:             assert_(not np.shares_memory(a2, c2))
 1254:             assert_(not np.shares_memory(b2, c2))
 1255: 
 1256:     # Copy not needed, 3 ops, read-only overlap
 1257:     x = np.ones([10, 10])
 1258:     a = x
 1259:     b = x.T
 1260:     c = x
 1261:     i = nditer([a, b, c], ['copy_if_overlap'],
 1262:                [['readonly'], ['readonly'], ['readonly']])
 1263:     a2, b2, c2 = i.operands
 1264:     assert_(a is a2)
 1265:     assert_(b is b2)
 1266:     assert_(c is c2)
 1267: 
 1268:     # Copy not needed, 3 ops, read-only overlap
 1269:     x = np.ones([10, 10])
 1270:     a = x
 1271:     b = np.ones([10, 10])
 1272:     c = x.T
 1273:     i = nditer([a, b, c], ['copy_if_overlap'],
 1274:                [['readonly'], ['writeonly'], ['readonly']])
 1275:     a2, b2, c2 = i.operands
 1276:     assert_(a is a2)
 1277:     assert_(b is b2)
 1278:     assert_(c is c2)
 1279: 
 1280:     # Copy not needed, 3 ops, write-only overlap
 1281:     x = np.arange(7)
 1282:     a = x[:3]
 1283:     b = x[3:6]
 1284:     c = x[4:7]
 1285:     i = nditer([a, b, c], ['copy_if_overlap'],
 1286:                [['readonly'], ['writeonly'], ['writeonly']])
 1287:     a2, b2, c2 = i.operands
 1288:     assert_(a is a2)
 1289:     assert_(b is b2)
 1290:     assert_(c is c2)
 1291: 
 1292: def test_iter_op_axes():
 1293:     # Check that custom axes work
 1294: 
 1295:     # Reverse the axes
 1296:     a = arange(6).reshape(2, 3)
 1297:     i = nditer([a, a.T], [], [['readonly']] * 2, op_axes=[[0, 1], [1, 0]])
 1298:     assert_(all([x == y for (x, y) in i]))
 1299:     a = arange(24).reshape(2, 3, 4)
 1300:     i = nditer([a.T, a], [], [['readonly']] * 2, op_axes=[[2, 1, 0], None])
 1301:     assert_(all([x == y for (x, y) in i]))
 1302: 
 1303:     # Broadcast 1D to any dimension
 1304:     a = arange(1, 31).reshape(2, 3, 5)
 1305:     b = arange(1, 3)
 1306:     i = nditer([a, b], [], [['readonly']] * 2, op_axes=[None, [0, -1, -1]])
 1307:     assert_equal([x * y for (x, y) in i], (a * b.reshape(2, 1, 1)).ravel())
 1308:     b = arange(1, 4)
 1309:     i = nditer([a, b], [], [['readonly']] * 2, op_axes=[None, [-1, 0, -1]])
 1310:     assert_equal([x * y for (x, y) in i], (a * b.reshape(1, 3, 1)).ravel())
 1311:     b = arange(1, 6)
 1312:     i = nditer([a, b], [], [['readonly']] * 2,
 1313:                             op_axes=[None, [np.newaxis, np.newaxis, 0]])
 1314:     assert_equal([x * y for (x, y) in i], (a * b.reshape(1, 1, 5)).ravel())
 1315: 
 1316:     # Inner product-style broadcasting
 1317:     a = arange(24).reshape(2, 3, 4)
 1318:     b = arange(40).reshape(5, 2, 4)
 1319:     i = nditer([a, b], ['multi_index'], [['readonly']] * 2,
 1320:                             op_axes=[[0, 1, -1, -1], [-1, -1, 0, 1]])
 1321:     assert_equal(i.shape, (2, 3, 5, 2))
 1322: 
 1323:     # Matrix product-style broadcasting
 1324:     a = arange(12).reshape(3, 4)
 1325:     b = arange(20).reshape(4, 5)
 1326:     i = nditer([a, b], ['multi_index'], [['readonly']] * 2,
 1327:                             op_axes=[[0, -1], [-1, 1]])
 1328:     assert_equal(i.shape, (3, 5))
 1329: 
 1330: def test_iter_op_axes_errors():
 1331:     # Check that custom axes throws errors for bad inputs
 1332: 
 1333:     # Wrong number of items in op_axes
 1334:     a = arange(6).reshape(2, 3)
 1335:     assert_raises(ValueError, nditer, [a, a], [], [['readonly']] * 2,
 1336:                                     op_axes=[[0], [1], [0]])
 1337:     # Out of bounds items in op_axes
 1338:     assert_raises(ValueError, nditer, [a, a], [], [['readonly']] * 2,
 1339:                                     op_axes=[[2, 1], [0, 1]])
 1340:     assert_raises(ValueError, nditer, [a, a], [], [['readonly']] * 2,
 1341:                                     op_axes=[[0, 1], [2, -1]])
 1342:     # Duplicate items in op_axes
 1343:     assert_raises(ValueError, nditer, [a, a], [], [['readonly']] * 2,
 1344:                                     op_axes=[[0, 0], [0, 1]])
 1345:     assert_raises(ValueError, nditer, [a, a], [], [['readonly']] * 2,
 1346:                                     op_axes=[[0, 1], [1, 1]])
 1347: 
 1348:     # Different sized arrays in op_axes
 1349:     assert_raises(ValueError, nditer, [a, a], [], [['readonly']] * 2,
 1350:                                     op_axes=[[0, 1], [0, 1, 0]])
 1351: 
 1352:     # Non-broadcastable dimensions in the result
 1353:     assert_raises(ValueError, nditer, [a, a], [], [['readonly']] * 2,
 1354:                                     op_axes=[[0, 1], [1, 0]])
 1355: 
 1356: def test_iter_copy():
 1357:     # Check that copying the iterator works correctly
 1358:     a = arange(24).reshape(2, 3, 4)
 1359: 
 1360:     # Simple iterator
 1361:     i = nditer(a)
 1362:     j = i.copy()
 1363:     assert_equal([x[()] for x in i], [x[()] for x in j])
 1364: 
 1365:     i.iterindex = 3
 1366:     j = i.copy()
 1367:     assert_equal([x[()] for x in i], [x[()] for x in j])
 1368: 
 1369:     # Buffered iterator
 1370:     i = nditer(a, ['buffered', 'ranged'], order='F', buffersize=3)
 1371:     j = i.copy()
 1372:     assert_equal([x[()] for x in i], [x[()] for x in j])
 1373: 
 1374:     i.iterindex = 3
 1375:     j = i.copy()
 1376:     assert_equal([x[()] for x in i], [x[()] for x in j])
 1377: 
 1378:     i.iterrange = (3, 9)
 1379:     j = i.copy()
 1380:     assert_equal([x[()] for x in i], [x[()] for x in j])
 1381: 
 1382:     i.iterrange = (2, 18)
 1383:     next(i)
 1384:     next(i)
 1385:     j = i.copy()
 1386:     assert_equal([x[()] for x in i], [x[()] for x in j])
 1387: 
 1388:     # Casting iterator
 1389:     with nditer(a, ['buffered'], order='F', casting='unsafe',
 1390:                 op_dtypes='f8', buffersize=5) as i:
 1391:         j = i.copy()
 1392:     assert_equal([x[()] for x in j], a.ravel(order='F'))
 1393: 
 1394:     a = arange(24, dtype='<i4').reshape(2, 3, 4)
 1395:     with nditer(a, ['buffered'], order='F', casting='unsafe',
 1396:                 op_dtypes='>f8', buffersize=5) as i:
 1397:         j = i.copy()
 1398:     assert_equal([x[()] for x in j], a.ravel(order='F'))
 1399: 
 1400: 
 1401: @pytest.mark.parametrize("dtype", np.typecodes["All"])
 1402: @pytest.mark.parametrize("loop_dtype", np.typecodes["All"])
 1403: @pytest.mark.filterwarnings("ignore::numpy.exceptions.ComplexWarning")
 1404: def test_iter_copy_casts(dtype, loop_dtype):
 1405:     # Ensure the dtype is never flexible:
 1406:     if loop_dtype.lower() == "m":
 1407:         loop_dtype = loop_dtype + "[ms]"
 1408:     elif np.dtype(loop_dtype).itemsize == 0:
 1409:         loop_dtype = loop_dtype + "50"
 1410: 
 1411:     # Make things a bit more interesting by requiring a byte-swap as well:
 1412:     arr = np.ones(1000, dtype=np.dtype(dtype).newbyteorder())
 1413:     try:
 1414:         expected = arr.astype(loop_dtype)
 1415:     except Exception:
 1416:         # Some casts are not possible, do not worry about them
 1417:         return
 1418: 
 1419:     it = np.nditer((arr,), ["buffered", "external_loop", "refs_ok"],
 1420:                    op_dtypes=[loop_dtype], casting="unsafe")
 1421: 
 1422:     if np.issubdtype(np.dtype(loop_dtype), np.number):
 1423:         # Casting to strings may be strange, but for simple dtypes do not rely
 1424:         # on the cast being correct:
 1425:         assert_array_equal(expected, np.ones(1000, dtype=loop_dtype))
 1426: 
 1427:     it_copy = it.copy()
 1428:     res = next(it)
 1429:     del it
 1430:     res_copy = next(it_copy)
 1431:     del it_copy
 1432: 
 1433:     assert_array_equal(res, expected)
 1434:     assert_array_equal(res_copy, expected)
 1435: 
 1436: 
 1437: def test_iter_copy_casts_structured():
 1438:     # Test a complicated structured dtype for casting, as it requires
 1439:     # both multiple steps and a more complex casting setup.
 1440:     # Includes a structured -> unstructured (any to object), and many other
 1441:     # casts, which cause this to require all steps in the casting machinery
 1442:     # one level down as well as the iterator copy (which uses NpyAuxData clone)
 1443:     in_dtype = np.dtype([("a", np.dtype("i,")),
 1444:                          ("b", np.dtype(">i,<i,>d,S17,>d,3f,O,i1"))])
 1445:     out_dtype = np.dtype([("a", np.dtype("O")),
 1446:                           ("b", np.dtype(">i,>i,S17,>d,>U3,3d,i1,O"))])
 1447:     arr = np.ones(1000, dtype=in_dtype)
 1448: 
 1449:     it = np.nditer((arr,), ["buffered", "external_loop", "refs_ok"],
 1450:                    op_dtypes=[out_dtype], casting="unsafe")
 1451:     it_copy = it.copy()
 1452: 
 1453:     res1 = next(it)
 1454:     del it
 1455:     res2 = next(it_copy)
 1456:     del it_copy
 1457: 
 1458:     expected = arr["a"].astype(out_dtype["a"])
 1459:     assert_array_equal(res1["a"], expected)
 1460:     assert_array_equal(res2["a"], expected)
 1461: 
 1462:     for field in in_dtype["b"].names:
 1463:         # Note that the .base avoids the subarray field
 1464:         expected = arr["b"][field].astype(out_dtype["b"][field].base)
 1465:         assert_array_equal(res1["b"][field], expected)
 1466:         assert_array_equal(res2["b"][field], expected)
 1467: 
 1468: 
 1469: def test_iter_copy_casts_structured2():
 1470:     # Similar to the above, this is a fairly arcane test to cover internals
 1471:     in_dtype = np.dtype([("a", np.dtype("O,O")),
 1472:                          ("b", np.dtype("5O,3O,(1,)O,(1,)i,(1,)O"))])
 1473:     out_dtype = np.dtype([("a", np.dtype("O")),
 1474:                           ("b", np.dtype("O,3i,4O,4O,4i"))])
 1475: 
 1476:     arr = np.ones(1, dtype=in_dtype)
 1477:     it = np.nditer((arr,), ["buffered", "external_loop", "refs_ok"],
 1478:                    op_dtypes=[out_dtype], casting="unsafe")
 1479:     it_copy = it.copy()
 1480: 
 1481:     res1 = next(it)
 1482:     del it
 1483:     res2 = next(it_copy)
 1484:     del it_copy
 1485: 
 1486:     # Array of two structured scalars:
 1487:     for res in res1, res2:
 1488:         # Cast to tuple by getitem, which may be weird and changeable?:
 1489:         assert isinstance(res["a"][0], tuple)
 1490:         assert res["a"][0] == (1, 1)
 1491: 
 1492:     for res in res1, res2:
 1493:         assert_array_equal(res["b"]["f0"][0], np.ones(5, dtype=object))
 1494:         assert_array_equal(res["b"]["f1"], np.ones((1, 3), dtype="i"))
 1495:         assert res["b"]["f2"].shape == (1, 4)
 1496:         assert_array_equal(res["b"]["f2"][0], np.ones(4, dtype=object))
 1497:         assert_array_equal(res["b"]["f3"][0], np.ones(4, dtype=object))
 1498:         assert_array_equal(res["b"]["f3"][0], np.ones(4, dtype="i"))
 1499: 
 1500: 
 1501: def test_iter_allocate_output_simple():
 1502:     # Check that the iterator will properly allocate outputs
 1503: 
 1504:     # Simple case
 1505:     a = arange(6)
 1506:     i = nditer([a, None], [], [['readonly'], ['writeonly', 'allocate']],
 1507:                         op_dtypes=[None, np.dtype('f4')])
 1508:     assert_equal(i.operands[1].shape, a.shape)
 1509:     assert_equal(i.operands[1].dtype, np.dtype('f4'))
 1510: 
 1511: def test_iter_allocate_output_buffered_readwrite():
 1512:     # Allocated output with buffering + delay_bufalloc
 1513: 
 1514:     a = arange(6)
 1515:     i = nditer([a, None], ['buffered', 'delay_bufalloc'],
 1516:                         [['readonly'], ['allocate', 'readwrite']])
 1517:     with i:
 1518:         i.operands[1][:] = 1
 1519:         i.reset()
 1520:         for x in i:
 1521:             x[1][...] += x[0][...]
 1522:         assert_equal(i.operands[1], a + 1)
 1523: 
 1524: def test_iter_allocate_output_itorder():
 1525:     # The allocated output should match the iteration order
 1526: 
 1527:     # C-order input, best iteration order
 1528:     a = arange(6, dtype='i4').reshape(2, 3)
 1529:     i = nditer([a, None], [], [['readonly'], ['writeonly', 'allocate']],
 1530:                         op_dtypes=[None, np.dtype('f4')])
 1531:     assert_equal(i.operands[1].shape, a.shape)
 1532:     assert_equal(i.operands[1].strides, a.strides)
 1533:     assert_equal(i.operands[1].dtype, np.dtype('f4'))
 1534:     # F-order input, best iteration order
 1535:     a = arange(24, dtype='i4').reshape(2, 3, 4).T
 1536:     i = nditer([a, None], [], [['readonly'], ['writeonly', 'allocate']],
 1537:                         op_dtypes=[None, np.dtype('f4')])
 1538:     assert_equal(i.operands[1].shape, a.shape)
 1539:     assert_equal(i.operands[1].strides, a.strides)
 1540:     assert_equal(i.operands[1].dtype, np.dtype('f4'))
 1541:     # Non-contiguous input, C iteration order
 1542:     a = arange(24, dtype='i4').reshape(2, 3, 4).swapaxes(0, 1)
 1543:     i = nditer([a, None], [],
 1544:                         [['readonly'], ['writeonly', 'allocate']],
 1545:                         order='C',
 1546:                         op_dtypes=[None, np.dtype('f4')])
 1547:     assert_equal(i.operands[1].shape, a.shape)
 1548:     assert_equal(i.operands[1].strides, (32, 16, 4))
 1549:     assert_equal(i.operands[1].dtype, np.dtype('f4'))
 1550: 
 1551: def test_iter_allocate_output_opaxes():
 1552:     # Specifying op_axes should work
 1553: 
 1554:     a = arange(24, dtype='i4').reshape(2, 3, 4)
 1555:     i = nditer([None, a], [], [['writeonly', 'allocate'], ['readonly']],
 1556:                         op_dtypes=[np.dtype('u4'), None],
 1557:                         op_axes=[[1, 2, 0], None])
 1558:     assert_equal(i.operands[0].shape, (4, 2, 3))
 1559:     assert_equal(i.operands[0].strides, (4, 48, 16))
 1560:     assert_equal(i.operands[0].dtype, np.dtype('u4'))
 1561: 
 1562: def test_iter_allocate_output_types_promotion():
 1563:     # Check type promotion of automatic outputs (this was more interesting
 1564:     # before NEP 50...)
 1565: 
 1566:     i = nditer([array([3], dtype='f4'), array([0], dtype='f8'), None], [],
 1567:                     [['readonly']] * 2 + [['writeonly', 'allocate']])
 1568:     assert_equal(i.dtypes[2], np.dtype('f8'))
 1569:     i = nditer([array([3], dtype='i4'), array([0], dtype='f4'), None], [],
 1570:                     [['readonly']] * 2 + [['writeonly', 'allocate']])
 1571:     assert_equal(i.dtypes[2], np.dtype('f8'))
 1572:     i = nditer([array([3], dtype='f4'), array(0, dtype='f8'), None], [],
 1573:                     [['readonly']] * 2 + [['writeonly', 'allocate']])
 1574:     assert_equal(i.dtypes[2], np.dtype('f8'))
 1575:     i = nditer([array([3], dtype='u4'), array(0, dtype='i4'), None], [],
 1576:                     [['readonly']] * 2 + [['writeonly', 'allocate']])
 1577:     assert_equal(i.dtypes[2], np.dtype('i8'))
 1578:     i = nditer([array([3], dtype='u4'), array(-12, dtype='i4'), None], [],
 1579:                     [['readonly']] * 2 + [['writeonly', 'allocate']])
 1580:     assert_equal(i.dtypes[2], np.dtype('i8'))
 1581: 
 1582: def test_iter_allocate_output_types_byte_order():
 1583:     # Verify the rules for byte order changes
 1584: 
 1585:     # When there's just one input, the output type exactly matches
 1586:     a = array([3], dtype='u4')
 1587:     a = a.view(a.dtype.newbyteorder())
 1588:     i = nditer([a, None], [],
 1589:                     [['readonly'], ['writeonly', 'allocate']])
 1590:     assert_equal(i.dtypes[0], i.dtypes[1])
 1591:     # With two or more inputs, the output type is in native byte order
 1592:     i = nditer([a, a, None], [],
 1593:                     [['readonly'], ['readonly'], ['writeonly', 'allocate']])
 1594:     assert_(i.dtypes[0] != i.dtypes[2])
 1595:     assert_equal(i.dtypes[0].newbyteorder('='), i.dtypes[2])
 1596: 
 1597: def test_iter_allocate_output_types_scalar():
 1598:     # If the inputs are all scalars, the output should be a scalar
 1599: 
 1600:     i = nditer([None, 1, 2.3, np.float32(12), np.complex128(3)], [],
 1601:                 [['writeonly', 'allocate']] + [['readonly']] * 4)
 1602:     assert_equal(i.operands[0].dtype, np.dtype('complex128'))
 1603:     assert_equal(i.operands[0].ndim, 0)
 1604: 
 1605: def test_iter_allocate_output_subtype():
 1606:     # Make sure that the subtype with priority wins
 1607:     class MyNDArray(np.ndarray):
 1608:         __array_priority__ = 15
 1609: 
 1610:     # subclass vs ndarray
 1611:     a = np.array([[1, 2], [3, 4]]).view(MyNDArray)
 1612:     b = np.arange(4).reshape(2, 2).T
 1613:     i = nditer([a, b, None], [],
 1614:                [['readonly'], ['readonly'], ['writeonly', 'allocate']])
 1615:     assert_equal(type(a), type(i.operands[2]))
 1616:     assert_(type(b) is not type(i.operands[2]))
 1617:     assert_equal(i.operands[2].shape, (2, 2))
 1618: 
 1619:     # If subtypes are disabled, we should get back an ndarray.
 1620:     i = nditer([a, b, None], [],
 1621:                [['readonly'], ['readonly'],
 1622:                 ['writeonly', 'allocate', 'no_subtype']])
 1623:     assert_equal(type(b), type(i.operands[2]))
 1624:     assert_(type(a) is not type(i.operands[2]))
 1625:     assert_equal(i.operands[2].shape, (2, 2))
 1626: 
 1627: def test_iter_allocate_output_errors():
 1628:     # Check that the iterator will throw errors for bad output allocations
 1629: 
 1630:     # Need an input if no output data type is specified
 1631:     a = arange(6)
 1632:     assert_raises(TypeError, nditer, [a, None], [],
 1633:                         [['writeonly'], ['writeonly', 'allocate']])
 1634:     # Allocated output should be flagged for writing
 1635:     assert_raises(ValueError, nditer, [a, None], [],
 1636:                         [['readonly'], ['allocate', 'readonly']])
 1637:     # Allocated output can't have buffering without delayed bufalloc
 1638:     assert_raises(ValueError, nditer, [a, None], ['buffered'],
 1639:                                             ['allocate', 'readwrite'])
 1640:     # Must specify dtype if there are no inputs (cannot promote existing ones;
 1641:     # maybe this should use the 'f4' here, but it does not historically.)
 1642:     assert_raises(TypeError, nditer, [None, None], [],
 1643:                         [['writeonly', 'allocate'],
 1644:                          ['writeonly', 'allocate']],
 1645:                         op_dtypes=[None, np.dtype('f4')])
 1646:     # If using op_axes, must specify all the axes
 1647:     a = arange(24, dtype='i4').reshape(2, 3, 4)
 1648:     assert_raises(ValueError, nditer, [a, None], [],
 1649:                         [['readonly'], ['writeonly', 'allocate']],
 1650:                         op_dtypes=[None, np.dtype('f4')],
 1651:                         op_axes=[None, [0, np.newaxis, 1]])
 1652:     # If using op_axes, the axes must be within bounds
 1653:     assert_raises(ValueError, nditer, [a, None], [],
 1654:                         [['readonly'], ['writeonly', 'allocate']],
 1655:                         op_dtypes=[None, np.dtype('f4')],
 1656:                         op_axes=[None, [0, 3, 1]])
 1657:     # If using op_axes, there can't be duplicates
 1658:     assert_raises(ValueError, nditer, [a, None], [],
 1659:                         [['readonly'], ['writeonly', 'allocate']],
 1660:                         op_dtypes=[None, np.dtype('f4')],
 1661:                         op_axes=[None, [0, 2, 1, 0]])
 1662:     # Not all axes may be specified if a reduction. If there is a hole
 1663:     # in op_axes, this is an error.
 1664:     a = arange(24, dtype='i4').reshape(2, 3, 4)
 1665:     assert_raises(ValueError, nditer, [a, None], ["reduce_ok"],
 1666:                         [['readonly'], ['readwrite', 'allocate']],
 1667:                         op_dtypes=[None, np.dtype('f4')],
 1668:                         op_axes=[None, [0, np.newaxis, 2]])
 1669: 
 1670: def test_all_allocated():
 1671:     # When no output and no shape is given, `()` is used as shape.
 1672:     i = np.nditer([None], op_dtypes=["int64"])
 1673:     assert i.operands[0].shape == ()
 1674:     assert i.dtypes == (np.dtype("int64"),)
 1675: 
 1676:     i = np.nditer([None], op_dtypes=["int64"], itershape=(2, 3, 4))
 1677:     assert i.operands[0].shape == (2, 3, 4)
 1678: 
 1679: def test_iter_remove_axis():
 1680:     a = arange(24).reshape(2, 3, 4)
 1681: 
 1682:     i = nditer(a, ['multi_index'])
 1683:     i.remove_axis(1)
 1684:     assert_equal(list(i), a[:, 0, :].ravel())
 1685: 
 1686:     a = a[::-1, :, :]
 1687:     i = nditer(a, ['multi_index'])
 1688:     i.remove_axis(0)
 1689:     assert_equal(list(i), a[0, :, :].ravel())
 1690: 
 1691: def test_iter_remove_multi_index_inner_loop():
 1692:     # Check that removing multi-index support works
 1693: 
 1694:     a = arange(24).reshape(2, 3, 4)
 1695: 
 1696:     i = nditer(a, ['multi_index'])
 1697:     assert_equal(i.ndim, 3)
 1698:     assert_equal(i.shape, (2, 3, 4))
 1699:     assert_equal(i.itviews[0].shape, (2, 3, 4))
 1700: 
 1701:     # Removing the multi-index tracking causes all dimensions to coalesce
 1702:     before = list(i)
 1703:     i.remove_multi_index()
 1704:     after = list(i)
 1705: 
 1706:     assert_equal(before, after)
 1707:     assert_equal(i.ndim, 1)
 1708:     assert_raises(ValueError, lambda i: i.shape, i)
 1709:     assert_equal(i.itviews[0].shape, (24,))
 1710: 
 1711:     # Removing the inner loop means there's just one iteration
 1712:     i.reset()
 1713:     assert_equal(i.itersize, 24)
 1714:     assert_equal(i[0].shape, ())
 1715:     i.enable_external_loop()
 1716:     assert_equal(i.itersize, 24)
 1717:     assert_equal(i[0].shape, (24,))
 1718:     assert_equal(i.value, arange(24))
 1719: 
 1720: def test_iter_iterindex():
 1721:     # Make sure iterindex works
 1722: 
 1723:     buffersize = 5
 1724:     a = arange(24).reshape(4, 3, 2)
 1725:     for flags in ([], ['buffered']):
 1726:         i = nditer(a, flags, buffersize=buffersize)
 1727:         assert_equal(iter_iterindices(i), list(range(24)))
 1728:         i.iterindex = 2
 1729:         assert_equal(iter_iterindices(i), list(range(2, 24)))
 1730: 
 1731:         i = nditer(a, flags, order='F', buffersize=buffersize)
 1732:         assert_equal(iter_iterindices(i), list(range(24)))
 1733:         i.iterindex = 5
 1734:         assert_equal(iter_iterindices(i), list(range(5, 24)))
 1735: 
 1736:         i = nditer(a[::-1], flags, order='F', buffersize=buffersize)
 1737:         assert_equal(iter_iterindices(i), list(range(24)))
 1738:         i.iterindex = 9
 1739:         assert_equal(iter_iterindices(i), list(range(9, 24)))
 1740: 
 1741:         i = nditer(a[::-1, ::-1], flags, order='C', buffersize=buffersize)
 1742:         assert_equal(iter_iterindices(i), list(range(24)))
 1743:         i.iterindex = 13
 1744:         assert_equal(iter_iterindices(i), list(range(13, 24)))
 1745: 
 1746:         i = nditer(a[::1, ::-1], flags, buffersize=buffersize)
 1747:         assert_equal(iter_iterindices(i), list(range(24)))
 1748:         i.iterindex = 23
 1749:         assert_equal(iter_iterindices(i), list(range(23, 24)))
 1750:         i.reset()
 1751:         i.iterindex = 2
 1752:         assert_equal(iter_iterindices(i), list(range(2, 24)))
 1753: 
 1754: def test_iter_iterrange():
 1755:     # Make sure getting and resetting the iterrange works
 1756: 
 1757:     buffersize = 5
 1758:     a = arange(24, dtype='i4').reshape(4, 3, 2)
 1759:     a_fort = a.ravel(order='F')
 1760: 
 1761:     i = nditer(a, ['ranged'], ['readonly'], order='F',
 1762:                 buffersize=buffersize)
 1763:     assert_equal(i.iterrange, (0, 24))
 1764:     assert_equal([x[()] for x in i], a_fort)
 1765:     for r in [(0, 24), (1, 2), (3, 24), (5, 5), (0, 20), (23, 24)]:
 1766:         i.iterrange = r
 1767:         assert_equal(i.iterrange, r)
 1768:         assert_equal([x[()] for x in i], a_fort[r[0]:r[1]])
 1769: 
 1770:     i = nditer(a, ['ranged', 'buffered'], ['readonly'], order='F',
 1771:                 op_dtypes='f8', buffersize=buffersize)
 1772:     assert_equal(i.iterrange, (0, 24))
 1773:     assert_equal([x[()] for x in i], a_fort)
 1774:     for r in [(0, 24), (1, 2), (3, 24), (5, 5), (0, 20), (23, 24)]:
 1775:         i.iterrange = r
 1776:         assert_equal(i.iterrange, r)
 1777:         assert_equal([x[()] for x in i], a_fort[r[0]:r[1]])
 1778: 
 1779:     def get_array(i):
 1780:         val = np.array([], dtype='f8')
 1781:         for x in i:
 1782:             val = np.concatenate((val, x))
 1783:         return val
 1784: 
 1785:     i = nditer(a, ['ranged', 'buffered', 'external_loop'],
 1786:                 ['readonly'], order='F',
 1787:                 op_dtypes='f8', buffersize=buffersize)
 1788:     assert_equal(i.iterrange, (0, 24))
 1789:     assert_equal(get_array(i), a_fort)
 1790:     for r in [(0, 24), (1, 2), (3, 24), (5, 5), (0, 20), (23, 24)]:
 1791:         i.iterrange = r
 1792:         assert_equal(i.iterrange, r)
 1793:         assert_equal(get_array(i), a_fort[r[0]:r[1]])
 1794: 
 1795: def test_iter_buffering():
 1796:     # Test buffering with several buffer sizes and types
 1797:     arrays = []
 1798:     # F-order swapped array
 1799:     _tmp = np.arange(24, dtype='c16').reshape(2, 3, 4).T
 1800:     _tmp = _tmp.view(_tmp.dtype.newbyteorder()).byteswap()
 1801:     arrays.append(_tmp)
 1802:     # Contiguous 1-dimensional array
 1803:     arrays.append(np.arange(10, dtype='f4'))
 1804:     # Unaligned array
 1805:     a = np.zeros((4 * 16 + 1,), dtype='i1')[1:]
 1806:     a.dtype = 'i4'
 1807:     a[:] = np.arange(16, dtype='i4')
 1808:     arrays.append(a)
 1809:     # 4-D F-order array
 1810:     arrays.append(np.arange(120, dtype='i4').reshape(5, 3, 2, 4).T)
 1811:     for a in arrays:
 1812:         for buffersize in (1, 2, 3, 5, 8, 11, 16, 1024):
 1813:             vals = []
 1814:             i = nditer(a, ['buffered', 'external_loop'],
 1815:                            [['readonly', 'nbo', 'aligned']],
 1816:                            order='C',
 1817:                            casting='equiv',
 1818:                            buffersize=buffersize)
 1819:             while not i.finished:
 1820:                 assert_(i[0].size <= buffersize)
 1821:                 vals.append(i[0].copy())
 1822:                 i.iternext()
 1823:             assert_equal(np.concatenate(vals), a.ravel(order='C'))
 1824: 
 1825: def test_iter_write_buffering():
 1826:     # Test that buffering of writes is working
 1827: 
 1828:     # F-order swapped array
 1829:     a = np.arange(24).reshape(2, 3, 4).T
 1830:     a = a.view(a.dtype.newbyteorder()).byteswap()
 1831:     i = nditer(a, ['buffered'],
 1832:                    [['readwrite', 'nbo', 'aligned']],
 1833:                    casting='equiv',
 1834:                    order='C',
 1835:                    buffersize=16)
 1836:     x = 0
 1837:     with i:
 1838:         while not i.finished:
 1839:             i[0] = x
 1840:             x += 1
 1841:             i.iternext()
 1842:     assert_equal(a.ravel(order='C'), np.arange(24))
 1843: 
 1844: def test_iter_buffering_delayed_alloc():
 1845:     # Test that delaying buffer allocation works
 1846: 
 1847:     a = np.arange(6)
 1848:     b = np.arange(1, dtype='f4')
 1849:     i = nditer([a, b], ['buffered', 'delay_bufalloc', 'multi_index', 'reduce_ok'],
 1850:                     ['readwrite'],
 1851:                     casting='unsafe',
 1852:                     op_dtypes='f4')
 1853:     assert_(i.has_delayed_bufalloc)
 1854:     assert_raises(ValueError, lambda i: i.multi_index, i)
 1855:     assert_raises(ValueError, lambda i: i[0], i)
 1856:     assert_raises(ValueError, lambda i: i[0:2], i)
 1857: 
 1858:     def assign_iter(i):
 1859:         i[0] = 0
 1860:     assert_raises(ValueError, assign_iter, i)
 1861: 
 1862:     i.reset()
 1863:     assert_(not i.has_delayed_bufalloc)
 1864:     assert_equal(i.multi_index, (0,))
 1865:     with i:
 1866:         assert_equal(i[0], 0)
 1867:         i[1] = 1
 1868:         assert_equal(i[0:2], [0, 1])
 1869:         assert_equal([[x[0][()], x[1][()]] for x in i], list(zip(range(6), [1] * 6)))
 1870: 
 1871: def test_iter_buffered_cast_simple():
 1872:     # Test that buffering can handle a simple cast
 1873: 
 1874:     a = np.arange(10, dtype='f4')
 1875:     i = nditer(a, ['buffered', 'external_loop'],
 1876:                    [['readwrite', 'nbo', 'aligned']],
 1877:                    casting='same_kind',
 1878:                    op_dtypes=[np.dtype('f8')],
 1879:                    buffersize=3)
 1880:     with i:
 1881:         for v in i:
 1882:             v[...] *= 2
 1883: 
 1884:     assert_equal(a, 2 * np.arange(10, dtype='f4'))
 1885: 
 1886: def test_iter_buffered_cast_byteswapped():
 1887:     # Test that buffering can handle a cast which requires swap->cast->swap
 1888: 
 1889:     a = np.arange(10, dtype='f4')
 1890:     a = a.view(a.dtype.newbyteorder()).byteswap()
 1891:     i = nditer(a, ['buffered', 'external_loop'],
 1892:                    [['readwrite', 'nbo', 'aligned']],
 1893:                    casting='same_kind',
 1894:                    op_dtypes=[np.dtype('f8').newbyteorder()],
 1895:                    buffersize=3)
 1896:     with i:
 1897:         for v in i:
 1898:             v[...] *= 2
 1899: 
 1900:     assert_equal(a, 2 * np.arange(10, dtype='f4'))
 1901: 
 1902:     with suppress_warnings() as sup:
 1903:         sup.filter(np.exceptions.ComplexWarning)
 1904: 
 1905:         a = np.arange(10, dtype='f8')
 1906:         a = a.view(a.dtype.newbyteorder()).byteswap()
 1907:         i = nditer(a, ['buffered', 'external_loop'],
 1908:                        [['readwrite', 'nbo', 'aligned']],
 1909:                        casting='unsafe',
 1910:                        op_dtypes=[np.dtype('c8').newbyteorder()],
 1911:                        buffersize=3)
 1912:         with i:
 1913:             for v in i:
 1914:                 v[...] *= 2
 1915: 
 1916:         assert_equal(a, 2 * np.arange(10, dtype='f8'))
 1917: 
 1918: def test_iter_buffered_cast_byteswapped_complex():
 1919:     # Test that buffering can handle a cast which requires swap->cast->copy
 1920: 
 1921:     a = np.arange(10, dtype='c8')
 1922:     a = a.view(a.dtype.newbyteorder()).byteswap()
 1923:     a += 2j
 1924:     i = nditer(a, ['buffered', 'external_loop'],
 1925:                    [['readwrite', 'nbo', 'aligned']],
 1926:                    casting='same_kind',
 1927:                    op_dtypes=[np.dtype('c16')],
 1928:                    buffersize=3)
 1929:     with i:
 1930:         for v in i:
 1931:             v[...] *= 2
 1932:     assert_equal(a, 2 * np.arange(10, dtype='c8') + 4j)
 1933: 
 1934:     a = np.arange(10, dtype='c8')
 1935:     a += 2j
 1936:     i = nditer(a, ['buffered', 'external_loop'],
 1937:                    [['readwrite', 'nbo', 'aligned']],
 1938:                    casting='same_kind',
 1939:                    op_dtypes=[np.dtype('c16').newbyteorder()],
 1940:                    buffersize=3)
 1941:     with i:
 1942:         for v in i:
 1943:             v[...] *= 2
 1944:     assert_equal(a, 2 * np.arange(10, dtype='c8') + 4j)
 1945: 
 1946:     a = np.arange(10, dtype=np.clongdouble)
 1947:     a = a.view(a.dtype.newbyteorder()).byteswap()
 1948:     a += 2j
 1949:     i = nditer(a, ['buffered', 'external_loop'],
 1950:                    [['readwrite', 'nbo', 'aligned']],
 1951:                    casting='same_kind',
 1952:                    op_dtypes=[np.dtype('c16')],
 1953:                    buffersize=3)
 1954:     with i:
 1955:         for v in i:
 1956:             v[...] *= 2
 1957:     assert_equal(a, 2 * np.arange(10, dtype=np.clongdouble) + 4j)
 1958: 
 1959:     a = np.arange(10, dtype=np.longdouble)
 1960:     a = a.view(a.dtype.newbyteorder()).byteswap()
 1961:     i = nditer(a, ['buffered', 'external_loop'],
 1962:                    [['readwrite', 'nbo', 'aligned']],
 1963:                    casting='same_kind',
 1964:                    op_dtypes=[np.dtype('f4')],
 1965:                    buffersize=7)
 1966:     with i:
 1967:         for v in i:
 1968:             v[...] *= 2
 1969:     assert_equal(a, 2 * np.arange(10, dtype=np.longdouble))
 1970: 
 1971: def test_iter_buffered_cast_structured_type():
 1972:     # Tests buffering of structured types
 1973: 
 1974:     # simple -> struct type (duplicates the value)
 1975:     sdt = [('a', 'f4'), ('b', 'i8'), ('c', 'c8', (2, 3)), ('d', 'O')]
 1976:     a = np.arange(3, dtype='f4') + 0.5
 1977:     i = nditer(a, ['buffered', 'refs_ok'], ['readonly'],
 1978:                     casting='unsafe',
 1979:                     op_dtypes=sdt)
 1980:     vals = [np.array(x) for x in i]
 1981:     assert_equal(vals[0]['a'], 0.5)
 1982:     assert_equal(vals[0]['b'], 0)
 1983:     assert_equal(vals[0]['c'], [[(0.5)] * 3] * 2)
 1984:     assert_equal(vals[0]['d'], 0.5)
 1985:     assert_equal(vals[1]['a'], 1.5)
 1986:     assert_equal(vals[1]['b'], 1)
 1987:     assert_equal(vals[1]['c'], [[(1.5)] * 3] * 2)
 1988:     assert_equal(vals[1]['d'], 1.5)
 1989:     assert_equal(vals[0].dtype, np.dtype(sdt))
 1990: 
 1991:     # object -> struct type
 1992:     sdt = [('a', 'f4'), ('b', 'i8'), ('c', 'c8', (2, 3)), ('d', 'O')]
 1993:     a = np.zeros((3,), dtype='O')
 1994:     a[0] = (0.5, 0.5, [[0.5, 0.5, 0.5], [0.5, 0.5, 0.5]], 0.5)
 1995:     a[1] = (1.5, 1.5, [[1.5, 1.5, 1.5], [1.5, 1.5, 1.5]], 1.5)
 1996:     a[2] = (2.5, 2.5, [[2.5, 2.5, 2.5], [2.5, 2.5, 2.5]], 2.5)
 1997:     if HAS_REFCOUNT:
 1998:         rc = sys.getrefcount(a[0])
 1999:     i = nditer(a, ['buffered', 'refs_ok'], ['readonly'],
 2000:                     casting='unsafe',
 2001:                     op_dtypes=sdt)
 2002:     vals = [x.copy() for x in i]
 2003:     assert_equal(vals[0]['a'], 0.5)
 2004:     assert_equal(vals[0]['b'], 0)
 2005:     assert_equal(vals[0]['c'], [[(0.5)] * 3] * 2)
 2006:     assert_equal(vals[0]['d'], 0.5)
 2007:     assert_equal(vals[1]['a'], 1.5)
 2008:     assert_equal(vals[1]['b'], 1)
 2009:     assert_equal(vals[1]['c'], [[(1.5)] * 3] * 2)
 2010:     assert_equal(vals[1]['d'], 1.5)
 2011:     assert_equal(vals[0].dtype, np.dtype(sdt))
 2012:     vals, i, x = [None] * 3
 2013:     if HAS_REFCOUNT:
 2014:         assert_equal(sys.getrefcount(a[0]), rc)
 2015: 
 2016:     # single-field struct type -> simple
 2017:     sdt = [('a', 'f4')]
 2018:     a = np.array([(5.5,), (8,)], dtype=sdt)
 2019:     i = nditer(a, ['buffered', 'refs_ok'], ['readonly'],
 2020:                     casting='unsafe',
 2021:                     op_dtypes='i4')
 2022:     assert_equal([x_[()] for x_ in i], [5, 8])
 2023: 
 2024:     # make sure multi-field struct type -> simple doesn't work
 2025:     sdt = [('a', 'f4'), ('b', 'i8'), ('d', 'O')]
 2026:     a = np.array([(5.5, 7, 'test'), (8, 10, 11)], dtype=sdt)
 2027:     assert_raises(TypeError, lambda: (
 2028:         nditer(a, ['buffered', 'refs_ok'], ['readonly'],
 2029:                casting='unsafe',
 2030:                op_dtypes='i4')))
 2031: 
 2032:     # struct type -> struct type (field-wise copy)
 2033:     sdt1 = [('a', 'f4'), ('b', 'i8'), ('d', 'O')]
 2034:     sdt2 = [('d', 'u2'), ('a', 'O'), ('b', 'f8')]
 2035:     a = np.array([(1, 2, 3), (4, 5, 6)], dtype=sdt1)
 2036:     i = nditer(a, ['buffered', 'refs_ok'], ['readonly'],
 2037:                     casting='unsafe',
 2038:                     op_dtypes=sdt2)
 2039:     assert_equal(i[0].dtype, np.dtype(sdt2))
 2040:     assert_equal([np.array(x_) for x_ in i],
 2041:                  [np.array((1, 2, 3), dtype=sdt2),
 2042:                   np.array((4, 5, 6), dtype=sdt2)])
 2043: 
 2044: 
 2045: def test_iter_buffered_cast_structured_type_failure_with_cleanup():
 2046:     # make sure struct type -> struct type with different
 2047:     # number of fields fails
 2048:     sdt1 = [('a', 'f4'), ('b', 'i8'), ('d', 'O')]
 2049:     sdt2 = [('b', 'O'), ('a', 'f8')]
 2050:     a = np.array([(1, 2, 3), (4, 5, 6)], dtype=sdt1)
 2051: 
 2052:     for intent in ["readwrite", "readonly", "writeonly"]:
 2053:         # This test was initially designed to test an error at a different
 2054:         # place, but will now raise earlier to to the cast not being possible:
 2055:         # `assert np.can_cast(a.dtype, sdt2, casting="unsafe")` fails.
 2056:         # Without a faulty DType, there is probably no reliable
 2057:         # way to get the initial tested behaviour.
 2058:         simple_arr = np.array([1, 2], dtype="i,i")  # requires clean up
 2059:         with pytest.raises(TypeError):
 2060:             nditer((simple_arr, a), ['buffered', 'refs_ok'], [intent, intent],
 2061:                    casting='unsafe', op_dtypes=["f,f", sdt2])
 2062: 
 2063: 
 2064: def test_buffered_cast_error_paths():
 2065:     with pytest.raises(ValueError):
 2066:         # The input is cast into an `S3` buffer
 2067:         np.nditer((np.array("a", dtype="S1"),), op_dtypes=["i"],
 2068:                   casting="unsafe", flags=["buffered"])
 2069: 
 2070:     # The `M8[ns]` is cast into the `S3` output
 2071:     it = np.nditer((np.array(1, dtype="i"),), op_dtypes=["S1"],
 2072:                    op_flags=["writeonly"], casting="unsafe", flags=["buffered"])
 2073:     with pytest.raises(ValueError):
 2074:         with it:
 2075:             buf = next(it)
 2076:             buf[...] = "a"  # cannot be converted to int.
 2077: 
 2078: @pytest.mark.skipif(IS_WASM, reason="Cannot start subprocess")
 2079: @pytest.mark.skipif(not HAS_REFCOUNT, reason="PyPy seems to not hit this.")
 2080: def test_buffered_cast_error_paths_unraisable():
 2081:     # The following gives an unraisable error. Pytest sometimes captures that
 2082:     # (depending python and/or pytest version). So with Python>=3.8 this can
 2083:     # probably be cleaned out in the future to check for
 2084:     # pytest.PytestUnraisableExceptionWarning:
 2085:     code = textwrap.dedent("""
 2086:         import numpy as np
 2087: 
 2088:         it = np.nditer((np.array(1, dtype="i"),), op_dtypes=["S1"],
 2089:                        op_flags=["writeonly"], casting="unsafe", flags=["buffered"])
 2090:         buf = next(it)
 2091:         buf[...] = "a"
 2092:         del buf, it  # Flushing only happens during deallocate right now.
 2093:         """)
 2094:     res = subprocess.check_output([sys.executable, "-c", code],
 2095:                                   stderr=subprocess.STDOUT, text=True)
 2096:     assert "ValueError" in res
 2097: 
 2098: 
 2099: def test_iter_buffered_cast_subarray():
 2100:     # Tests buffering of subarrays
 2101: 
 2102:     # one element -> many (copies it to all)
 2103:     sdt1 = [('a', 'f4')]
 2104:     sdt2 = [('a', 'f8', (3, 2, 2))]
 2105:     a = np.zeros((6,), dtype=sdt1)
 2106:     a['a'] = np.arange(6)
 2107:     i = nditer(a, ['buffered', 'refs_ok'], ['readonly'],
 2108:                     casting='unsafe',
 2109:                     op_dtypes=sdt2)
 2110:     assert_equal(i[0].dtype, np.dtype(sdt2))
 2111:     for x, count in zip(i, list(range(6))):
 2112:         assert_(np.all(x['a'] == count))
 2113: 
 2114:     # one element -> many -> back (copies it to all)
 2115:     sdt1 = [('a', 'O', (1, 1))]
 2116:     sdt2 = [('a', 'O', (3, 2, 2))]
 2117:     a = np.zeros((6,), dtype=sdt1)
 2118:     a['a'][:, 0, 0] = np.arange(6)
 2119:     i = nditer(a, ['buffered', 'refs_ok'], ['readwrite'],
 2120:                     casting='unsafe',
 2121:                     op_dtypes=sdt2)
 2122:     with i:
 2123:         assert_equal(i[0].dtype, np.dtype(sdt2))
 2124:         count = 0
 2125:         for x in i:
 2126:             assert_(np.all(x['a'] == count))
 2127:             x['a'][0] += 2
 2128:             count += 1
 2129:     assert_equal(a['a'], np.arange(6).reshape(6, 1, 1) + 2)
 2130: 
 2131:     # many -> one element -> back (copies just element 0)
 2132:     sdt1 = [('a', 'O', (3, 2, 2))]
 2133:     sdt2 = [('a', 'O', (1,))]
 2134:     a = np.zeros((6,), dtype=sdt1)
 2135:     a['a'][:, 0, 0, 0] = np.arange(6)
 2136:     i = nditer(a, ['buffered', 'refs_ok'], ['readwrite'],
 2137:                     casting='unsafe',
 2138:                     op_dtypes=sdt2)
 2139:     with i:
 2140:         assert_equal(i[0].dtype, np.dtype(sdt2))
 2141:         count = 0
 2142:         for x in i:
 2143:             assert_equal(x['a'], count)
 2144:             x['a'] += 2
 2145:             count += 1
 2146:     assert_equal(a['a'], np.arange(6).reshape(6, 1, 1, 1) * np.ones((1, 3, 2, 2)) + 2)
 2147: 
 2148:     # many -> one element -> back (copies just element 0)
 2149:     sdt1 = [('a', 'f8', (3, 2, 2))]
 2150:     sdt2 = [('a', 'O', (1,))]
 2151:     a = np.zeros((6,), dtype=sdt1)
 2152:     a['a'][:, 0, 0, 0] = np.arange(6)
 2153:     i = nditer(a, ['buffered', 'refs_ok'], ['readonly'],
 2154:                     casting='unsafe',
 2155:                     op_dtypes=sdt2)
 2156:     assert_equal(i[0].dtype, np.dtype(sdt2))
 2157:     count = 0
 2158:     for x in i:
 2159:         assert_equal(x['a'], count)
 2160:         count += 1
 2161: 
 2162:     # many -> one element (copies just element 0)
 2163:     sdt1 = [('a', 'O', (3, 2, 2))]
 2164:     sdt2 = [('a', 'f4', (1,))]
 2165:     a = np.zeros((6,), dtype=sdt1)
 2166:     a['a'][:, 0, 0, 0] = np.arange(6)
 2167:     i = nditer(a, ['buffered', 'refs_ok'], ['readonly'],
 2168:                     casting='unsafe',
 2169:                     op_dtypes=sdt2)
 2170:     assert_equal(i[0].dtype, np.dtype(sdt2))
 2171:     count = 0
 2172:     for x in i:
 2173:         assert_equal(x['a'], count)
 2174:         count += 1
 2175: 
 2176:     # many -> matching shape (straightforward copy)
 2177:     sdt1 = [('a', 'O', (3, 2, 2))]
 2178:     sdt2 = [('a', 'f4', (3, 2, 2))]
 2179:     a = np.zeros((6,), dtype=sdt1)
 2180:     a['a'] = np.arange(6 * 3 * 2 * 2).reshape(6, 3, 2, 2)
 2181:     i = nditer(a, ['buffered', 'refs_ok'], ['readonly'],
 2182:                     casting='unsafe',
 2183:                     op_dtypes=sdt2)
 2184:     assert_equal(i[0].dtype, np.dtype(sdt2))
 2185:     count = 0
 2186:     for x in i:
 2187:         assert_equal(x['a'], a[count]['a'])
 2188:         count += 1
 2189: 
 2190:     # vector -> smaller vector (truncates)
 2191:     sdt1 = [('a', 'f8', (6,))]
 2192:     sdt2 = [('a', 'f4', (2,))]
 2193:     a = np.zeros((6,), dtype=sdt1)
 2194:     a['a'] = np.arange(6 * 6).reshape(6, 6)
 2195:     i = nditer(a, ['buffered', 'refs_ok'], ['readonly'],
 2196:                     casting='unsafe',
 2197:                     op_dtypes=sdt2)
 2198:     assert_equal(i[0].dtype, np.dtype(sdt2))
 2199:     count = 0
 2200:     for x in i:
 2201:         assert_equal(x['a'], a[count]['a'][:2])
 2202:         count += 1
 2203: 
 2204:     # vector -> bigger vector (pads with zeros)
 2205:     sdt1 = [('a', 'f8', (2,))]
 2206:     sdt2 = [('a', 'f4', (6,))]
 2207:     a = np.zeros((6,), dtype=sdt1)
 2208:     a['a'] = np.arange(6 * 2).reshape(6, 2)
 2209:     i = nditer(a, ['buffered', 'refs_ok'], ['readonly'],
 2210:                     casting='unsafe',
 2211:                     op_dtypes=sdt2)
 2212:     assert_equal(i[0].dtype, np.dtype(sdt2))
 2213:     count = 0
 2214:     for x in i:
 2215:         assert_equal(x['a'][:2], a[count]['a'])
 2216:         assert_equal(x['a'][2:], [0, 0, 0, 0])
 2217:         count += 1
 2218: 
 2219:     # vector -> matrix (broadcasts)
 2220:     sdt1 = [('a', 'f8', (2,))]
 2221:     sdt2 = [('a', 'f4', (2, 2))]
 2222:     a = np.zeros((6,), dtype=sdt1)
 2223:     a['a'] = np.arange(6 * 2).reshape(6, 2)
 2224:     i = nditer(a, ['buffered', 'refs_ok'], ['readonly'],
 2225:                     casting='unsafe',
 2226:                     op_dtypes=sdt2)
 2227:     assert_equal(i[0].dtype, np.dtype(sdt2))
 2228:     count = 0
 2229:     for x in i:
 2230:         assert_equal(x['a'][0], a[count]['a'])
 2231:         assert_equal(x['a'][1], a[count]['a'])
 2232:         count += 1
 2233: 
 2234:     # vector -> matrix (broadcasts and zero-pads)
 2235:     sdt1 = [('a', 'f8', (2, 1))]
 2236:     sdt2 = [('a', 'f4', (3, 2))]
 2237:     a = np.zeros((6,), dtype=sdt1)
 2238:     a['a'] = np.arange(6 * 2).reshape(6, 2, 1)
 2239:     i = nditer(a, ['buffered', 'refs_ok'], ['readonly'],
 2240:                     casting='unsafe',
 2241:                     op_dtypes=sdt2)
 2242:     assert_equal(i[0].dtype, np.dtype(sdt2))
 2243:     count = 0
 2244:     for x in i:
 2245:         assert_equal(x['a'][:2, 0], a[count]['a'][:, 0])
 2246:         assert_equal(x['a'][:2, 1], a[count]['a'][:, 0])
 2247:         assert_equal(x['a'][2, :], [0, 0])
 2248:         count += 1
 2249: 
 2250:     # matrix -> matrix (truncates and zero-pads)
 2251:     sdt1 = [('a', 'f8', (2, 3))]
 2252:     sdt2 = [('a', 'f4', (3, 2))]
 2253:     a = np.zeros((6,), dtype=sdt1)
 2254:     a['a'] = np.arange(6 * 2 * 3).reshape(6, 2, 3)
 2255:     i = nditer(a, ['buffered', 'refs_ok'], ['readonly'],
 2256:                     casting='unsafe',
 2257:                     op_dtypes=sdt2)
 2258:     assert_equal(i[0].dtype, np.dtype(sdt2))
 2259:     count = 0
 2260:     for x in i:
 2261:         assert_equal(x['a'][:2, 0], a[count]['a'][:, 0])
 2262:         assert_equal(x['a'][:2, 1], a[count]['a'][:, 1])
 2263:         assert_equal(x['a'][2, :], [0, 0])
 2264:         count += 1
 2265: 
 2266: def test_iter_buffering_badwriteback():
 2267:     # Writing back from a buffer cannot combine elements
 2268: 
 2269:     # a needs write buffering, but had a broadcast dimension
 2270:     a = np.arange(6).reshape(2, 3, 1)
 2271:     b = np.arange(12).reshape(2, 3, 2)
 2272:     assert_raises(ValueError, nditer, [a, b],
 2273:                   ['buffered', 'external_loop'],
 2274:                   [['readwrite'], ['writeonly']],
 2275:                   order='C')
 2276: 
 2277:     # But if a is readonly, it's fine
 2278:     nditer([a, b], ['buffered', 'external_loop'],
 2279:            [['readonly'], ['writeonly']],
 2280:            order='C')
 2281: 
 2282:     # If a has just one element, it's fine too (constant 0 stride, a reduction)
 2283:     a = np.arange(1).reshape(1, 1, 1)
 2284:     nditer([a, b], ['buffered', 'external_loop', 'reduce_ok'],
 2285:            [['readwrite'], ['writeonly']],
 2286:            order='C')
 2287: 
 2288:     # check that it fails on other dimensions too
 2289:     a = np.arange(6).reshape(1, 3, 2)
 2290:     assert_raises(ValueError, nditer, [a, b],
 2291:                   ['buffered', 'external_loop'],
 2292:                   [['readwrite'], ['writeonly']],
 2293:                   order='C')
 2294:     a = np.arange(4).reshape(2, 1, 2)
 2295:     assert_raises(ValueError, nditer, [a, b],
 2296:                   ['buffered', 'external_loop'],
 2297:                   [['readwrite'], ['writeonly']],
 2298:                   order='C')
 2299: 
 2300: def test_iter_buffering_string():
 2301:     # Safe casting disallows shrinking strings
 2302:     a = np.array(['abc', 'a', 'abcd'], dtype=np.bytes_)
 2303:     assert_equal(a.dtype, np.dtype('S4'))
 2304:     assert_raises(TypeError, nditer, a, ['buffered'], ['readonly'],
 2305:                   op_dtypes='S2')
 2306:     i = nditer(a, ['buffered'], ['readonly'], op_dtypes='S6')
 2307:     assert_equal(i[0], b'abc')
 2308:     assert_equal(i[0].dtype, np.dtype('S6'))
 2309: 
 2310:     a = np.array(['abc', 'a', 'abcd'], dtype=np.str_)
 2311:     assert_equal(a.dtype, np.dtype('U4'))
 2312:     assert_raises(TypeError, nditer, a, ['buffered'], ['readonly'],
 2313:                     op_dtypes='U2')
 2314:     i = nditer(a, ['buffered'], ['readonly'], op_dtypes='U6')
 2315:     assert_equal(i[0], 'abc')
 2316:     assert_equal(i[0].dtype, np.dtype('U6'))
 2317: 
 2318: def test_iter_buffering_growinner():
 2319:     # Test that the inner loop grows when no buffering is needed
 2320:     a = np.arange(30)
 2321:     i = nditer(a, ['buffered', 'growinner', 'external_loop'],
 2322:                            buffersize=5)
 2323:     # Should end up with just one inner loop here
 2324:     assert_equal(i[0].size, a.size)
 2325: 
 2326: 
 2327: @pytest.mark.parametrize("read_or_readwrite", ["readonly", "readwrite"])
 2328: def test_iter_contig_flag_reduce_error(read_or_readwrite):
 2329:     # Test that a non-contiguous operand is rejected without buffering.
 2330:     # NOTE: This is true even for a reduction, where we return a 0-stride
 2331:     #       below!
 2332:     with pytest.raises(TypeError, match="Iterator operand required buffering"):
 2333:         it = np.nditer(
 2334:             (np.zeros(()),), flags=["external_loop", "reduce_ok"],
 2335:             op_flags=[(read_or_readwrite, "contig"),], itershape=(10,))
 2336: 
 2337: 
 2338: @pytest.mark.parametrize("arr", [
 2339:         lambda: np.zeros(()),
 2340:         lambda: np.zeros((20, 1))[::20],
 2341:         lambda: np.zeros((1, 20))[:, ::20]
 2342:     ])
 2343: def test_iter_contig_flag_single_operand_strides(arr):
 2344:     """
 2345:     Tests the strides with the contig flag for both broadcast and non-broadcast
 2346:     operands in 3 cases where the logic is needed:
 2347:     1. When everything has a zero stride, the broadcast op needs to repeated
 2348:     2. When the reduce axis is the last axis (first to iterate).
 2349:     3. When the reduce axis is the first axis (last to iterate).
 2350: 
 2351:     NOTE: The semantics of the cast flag are not clearly defined when
 2352:           it comes to reduction.  It is unclear that there are any users.
 2353:     """
 2354:     first_op = np.ones((10, 10))
 2355:     broadcast_op = arr()
 2356:     red_op = arr()
 2357:     # Add a first operand to ensure no axis-reordering and the result shape.
 2358:     iterator = np.nditer(
 2359:         (first_op, broadcast_op, red_op),
 2360:         flags=["external_loop", "reduce_ok", "buffered", "delay_bufalloc"],
 2361:         op_flags=[("readonly", "contig")] * 2 + [("readwrite", "contig")])
 2362: 
 2363:     with iterator:
 2364:         iterator.reset()
 2365:         for f, b, r in iterator:
 2366:             # The first operand is contigouos, we should have a view
 2367:             assert np.shares_memory(f, first_op)
 2368:             # Although broadcast, the second op always has a contiguous stride
 2369:             assert b.strides[0] == 8
 2370:             assert not np.shares_memory(b, broadcast_op)
 2371:             # The reduction has a contiguous stride or a 0 stride
 2372:             if red_op.ndim == 0 or red_op.shape[-1] == 1:
 2373:                 assert r.strides[0] == 0
 2374:             else:
 2375:                 # The stride is 8, although it was not originally:
 2376:                 assert r.strides[0] == 8
 2377:             # If the reduce stride is 0, buffering makes no difference, but we
 2378:             # do it anyway right now:
 2379:             assert not np.shares_memory(r, red_op)
 2380: 
 2381: 
 2382: @pytest.mark.xfail(reason="The contig flag was always buggy.")
 2383: def test_iter_contig_flag_incorrect():
 2384:     # This case does the wrong thing...
 2385:     iterator = np.nditer(
 2386:         (np.ones((10, 10)).T, np.ones((1, 10))),
 2387:         flags=["external_loop", "reduce_ok", "buffered", "delay_bufalloc"],
 2388:         op_flags=[("readonly", "contig")] * 2)
 2389: 
 2390:     with iterator:
 2391:         iterator.reset()
 2392:         for a, b in iterator:
 2393:             # Remove a and b from locals (pytest may want to format them)
 2394:             a, b = a.strides, b.strides
 2395:             assert a == 8
 2396:             assert b == 8  # should be 8 but is 0 due to axis reorder
 2397: 
 2398: 
 2399: @pytest.mark.slow
 2400: def test_iter_buffered_reduce_reuse():
 2401:     # large enough array for all views, including negative strides.
 2402:     a = np.arange(2 * 3**5)[3**5:3**5 + 1]
 2403:     flags = ['buffered', 'delay_bufalloc', 'multi_index', 'reduce_ok', 'refs_ok']
 2404:     op_flags = [('readonly',), ('readwrite', 'allocate')]
 2405:     op_axes_list = [[(0, 1, 2), (0, 1, -1)], [(0, 1, 2), (0, -1, -1)]]
 2406:     # wrong dtype to force buffering
 2407:     op_dtypes = [float, a.dtype]
 2408: 
 2409:     def get_params():
 2410:         for xs in range(-3**2, 3**2 + 1):
 2411:             for ys in range(xs, 3**2 + 1):
 2412:                 for op_axes in op_axes_list:
 2413:                     # last stride is reduced and because of that not
 2414:                     # important for this test, as it is the inner stride.
 2415:                     strides = (xs * a.itemsize, ys * a.itemsize, a.itemsize)
 2416:                     arr = np.lib.stride_tricks.as_strided(a, (3, 3, 3), strides)
 2417: 
 2418:                     for skip in [0, 1]:
 2419:                         yield arr, op_axes, skip
 2420: 
 2421:     for arr, op_axes, skip in get_params():
 2422:         nditer2 = np.nditer([arr.copy(), None],
 2423:                             op_axes=op_axes, flags=flags, op_flags=op_flags,
 2424:                             op_dtypes=op_dtypes)
 2425:         with nditer2:
 2426:             nditer2.operands[-1][...] = 0
 2427:             nditer2.reset()
 2428:             nditer2.iterindex = skip
 2429: 
 2430:             for (a2_in, b2_in) in nditer2:
 2431:                 b2_in += a2_in.astype(np.int_)
 2432: 
 2433:             comp_res = nditer2.operands[-1]
 2434: 
 2435:         for bufsize in range(3**3):
 2436:             nditer1 = np.nditer([arr, None],
 2437:                                 op_axes=op_axes, flags=flags, op_flags=op_flags,
 2438:                                 buffersize=bufsize, op_dtypes=op_dtypes)
 2439:             with nditer1:
 2440:                 nditer1.operands[-1][...] = 0
 2441:                 nditer1.reset()
 2442:                 nditer1.iterindex = skip
 2443: 
 2444:                 for (a1_in, b1_in) in nditer1:
 2445:                     b1_in += a1_in.astype(np.int_)
 2446: 
 2447:                 res = nditer1.operands[-1]
 2448:             assert_array_equal(res, comp_res)
 2449: 
 2450: 
 2451: def test_iter_buffered_reduce_reuse_core():
 2452:     # NumPy re-uses buffers for broadcast operands (as of writing when reading).
 2453:     # Test this even if the offset is manually set at some point during
 2454:     # the iteration.  (not a particularly tricky path)
 2455:     arr = np.empty((1, 6, 4, 1)).reshape(1, 6, 4, 1)[:, ::3, ::2, :]
 2456:     arr[...] = np.arange(arr.size).reshape(arr.shape)
 2457:     # First and last dimension are broadcast dimensions.
 2458:     arr = np.broadcast_to(arr, (100, 2, 2, 2))
 2459: 
 2460:     flags = ['buffered', 'reduce_ok', 'refs_ok', 'multi_index']
 2461:     op_flags = [('readonly',)]
 2462: 
 2463:     buffersize = 100  # small enough to not fit the whole array
 2464:     it = np.nditer(arr, flags=flags, op_flags=op_flags, buffersize=100)
 2465: 
 2466:     # Iterate a bit (this will cause buffering internally)
 2467:     expected = [next(it) for i in range(11)]
 2468:     # Now, manually advance to inside the core (the +1)
 2469:     it.iterindex = 10 * (2 * 2 * 2) + 1
 2470:     result = [next(it) for i in range(10)]
 2471: 
 2472:     assert expected[1:] == result
 2473: 
 2474: 
 2475: def test_iter_no_broadcast():
 2476:     # Test that the no_broadcast flag works
 2477:     a = np.arange(24).reshape(2, 3, 4)
 2478:     b = np.arange(6).reshape(2, 3, 1)
 2479:     c = np.arange(12).reshape(3, 4)
 2480: 
 2481:     nditer([a, b, c], [],
 2482:            [['readonly', 'no_broadcast'],
 2483:             ['readonly'], ['readonly']])
 2484:     assert_raises(ValueError, nditer, [a, b, c], [],
 2485:                   [['readonly'], ['readonly', 'no_broadcast'], ['readonly']])
 2486:     assert_raises(ValueError, nditer, [a, b, c], [],
 2487:                   [['readonly'], ['readonly'], ['readonly', 'no_broadcast']])
 2488: 
 2489: 
 2490: class TestIterNested:
 2491: 
 2492:     def test_basic(self):
 2493:         # Test nested iteration basic usage
 2494:         a = arange(12).reshape(2, 3, 2)
 2495: 
 2496:         i, j = np.nested_iters(a, [[0], [1, 2]])
 2497:         vals = [list(j) for _ in i]
 2498:         assert_equal(vals, [[0, 1, 2, 3, 4, 5], [6, 7, 8, 9, 10, 11]])
 2499: 
 2500:         i, j = np.nested_iters(a, [[0, 1], [2]])
 2501:         vals = [list(j) for _ in i]
 2502:         assert_equal(vals, [[0, 1], [2, 3], [4, 5], [6, 7], [8, 9], [10, 11]])
 2503: 
 2504:         i, j = np.nested_iters(a, [[0, 2], [1]])
 2505:         vals = [list(j) for _ in i]
 2506:         assert_equal(vals, [[0, 2, 4], [1, 3, 5], [6, 8, 10], [7, 9, 11]])
 2507: 
 2508:     def test_reorder(self):
 2509:         # Test nested iteration basic usage
 2510:         a = arange(12).reshape(2, 3, 2)
 2511: 
 2512:         # In 'K' order (default), it gets reordered
 2513:         i, j = np.nested_iters(a, [[0], [2, 1]])
 2514:         vals = [list(j) for _ in i]
 2515:         assert_equal(vals, [[0, 1, 2, 3, 4, 5], [6, 7, 8, 9, 10, 11]])
 2516: 
 2517:         i, j = np.nested_iters(a, [[1, 0], [2]])
 2518:         vals = [list(j) for _ in i]
 2519:         assert_equal(vals, [[0, 1], [2, 3], [4, 5], [6, 7], [8, 9], [10, 11]])
 2520: 
 2521:         i, j = np.nested_iters(a, [[2, 0], [1]])
 2522:         vals = [list(j) for _ in i]
 2523:         assert_equal(vals, [[0, 2, 4], [1, 3, 5], [6, 8, 10], [7, 9, 11]])
 2524: 
 2525:         # In 'C' order, it doesn't
 2526:         i, j = np.nested_iters(a, [[0], [2, 1]], order='C')
 2527:         vals = [list(j) for _ in i]
 2528:         assert_equal(vals, [[0, 2, 4, 1, 3, 5], [6, 8, 10, 7, 9, 11]])
 2529: 
 2530:         i, j = np.nested_iters(a, [[1, 0], [2]], order='C')
 2531:         vals = [list(j) for _ in i]
 2532:         assert_equal(vals, [[0, 1], [6, 7], [2, 3], [8, 9], [4, 5], [10, 11]])
 2533: 
 2534:         i, j = np.nested_iters(a, [[2, 0], [1]], order='C')
 2535:         vals = [list(j) for _ in i]
 2536:         assert_equal(vals, [[0, 2, 4], [6, 8, 10], [1, 3, 5], [7, 9, 11]])
 2537: 
 2538:     def test_flip_axes(self):
 2539:         # Test nested iteration with negative axes
 2540:         a = arange(12).reshape(2, 3, 2)[::-1, ::-1, ::-1]
 2541: 
 2542:         # In 'K' order (default), the axes all get flipped
 2543:         i, j = np.nested_iters(a, [[0], [1, 2]])
 2544:         vals = [list(j) for _ in i]
 2545:         assert_equal(vals, [[0, 1, 2, 3, 4, 5], [6, 7, 8, 9, 10, 11]])
 2546: 
 2547:         i, j = np.nested_iters(a, [[0, 1], [2]])
 2548:         vals = [list(j) for _ in i]
 2549:         assert_equal(vals, [[0, 1], [2, 3], [4, 5], [6, 7], [8, 9], [10, 11]])
 2550: 
 2551:         i, j = np.nested_iters(a, [[0, 2], [1]])
 2552:         vals = [list(j) for _ in i]
 2553:         assert_equal(vals, [[0, 2, 4], [1, 3, 5], [6, 8, 10], [7, 9, 11]])
 2554: 
 2555:         # In 'C' order, flipping axes is disabled
 2556:         i, j = np.nested_iters(a, [[0], [1, 2]], order='C')
 2557:         vals = [list(j) for _ in i]
 2558:         assert_equal(vals, [[11, 10, 9, 8, 7, 6], [5, 4, 3, 2, 1, 0]])
 2559: 
 2560:         i, j = np.nested_iters(a, [[0, 1], [2]], order='C')
 2561:         vals = [list(j) for _ in i]
 2562:         assert_equal(vals, [[11, 10], [9, 8], [7, 6], [5, 4], [3, 2], [1, 0]])
 2563: 
 2564:         i, j = np.nested_iters(a, [[0, 2], [1]], order='C')
 2565:         vals = [list(j) for _ in i]
 2566:         assert_equal(vals, [[11, 9, 7], [10, 8, 6], [5, 3, 1], [4, 2, 0]])
 2567: 
 2568:     def test_broadcast(self):
 2569:         # Test nested iteration with broadcasting
 2570:         a = arange(2).reshape(2, 1)
 2571:         b = arange(3).reshape(1, 3)
 2572: 
 2573:         i, j = np.nested_iters([a, b], [[0], [1]])
 2574:         vals = [list(j) for _ in i]
 2575:         assert_equal(vals, [[[0, 0], [0, 1], [0, 2]], [[1, 0], [1, 1], [1, 2]]])
 2576: 
 2577:         i, j = np.nested_iters([a, b], [[1], [0]])
 2578:         vals = [list(j) for _ in i]
 2579:         assert_equal(vals, [[[0, 0], [1, 0]], [[0, 1], [1, 1]], [[0, 2], [1, 2]]])
 2580: 
 2581:     def test_dtype_copy(self):
 2582:         # Test nested iteration with a copy to change dtype
 2583: 
 2584:         # copy
 2585:         a = arange(6, dtype='i4').reshape(2, 3)
 2586:         i, j = np.nested_iters(a, [[0], [1]],
 2587:                             op_flags=['readonly', 'copy'],
 2588:                             op_dtypes='f8')
 2589:         assert_equal(j[0].dtype, np.dtype('f8'))
 2590:         vals = [list(j) for _ in i]
 2591:         assert_equal(vals, [[0, 1, 2], [3, 4, 5]])
 2592:         vals = None
 2593: 
 2594:         # writebackifcopy - using context manager
 2595:         a = arange(6, dtype='f4').reshape(2, 3)
 2596:         i, j = np.nested_iters(a, [[0], [1]],
 2597:                             op_flags=['readwrite', 'updateifcopy'],
 2598:                             casting='same_kind',
 2599:                             op_dtypes='f8')
 2600:         with i, j:
 2601:             assert_equal(j[0].dtype, np.dtype('f8'))
 2602:             for x in i:
 2603:                 for y in j:
 2604:                     y[...] += 1
 2605:             assert_equal(a, [[0, 1, 2], [3, 4, 5]])
 2606:         assert_equal(a, [[1, 2, 3], [4, 5, 6]])
 2607: 
 2608:         # writebackifcopy - using close()
 2609:         a = arange(6, dtype='f4').reshape(2, 3)
 2610:         i, j = np.nested_iters(a, [[0], [1]],
 2611:                             op_flags=['readwrite', 'updateifcopy'],
 2612:                             casting='same_kind',
 2613:                             op_dtypes='f8')
 2614:         assert_equal(j[0].dtype, np.dtype('f8'))
 2615:         for x in i:
 2616:             for y in j:
 2617:                 y[...] += 1
 2618:         assert_equal(a, [[0, 1, 2], [3, 4, 5]])
 2619:         i.close()
 2620:         j.close()
 2621:         assert_equal(a, [[1, 2, 3], [4, 5, 6]])
 2622: 
 2623:     def test_dtype_buffered(self):
 2624:         # Test nested iteration with buffering to change dtype
 2625: 
 2626:         a = arange(6, dtype='f4').reshape(2, 3)
 2627:         i, j = np.nested_iters(a, [[0], [1]],
 2628:                             flags=['buffered'],
 2629:                             op_flags=['readwrite'],
 2630:                             casting='same_kind',
 2631:                             op_dtypes='f8')
 2632:         assert_equal(j[0].dtype, np.dtype('f8'))
 2633:         for x in i:
 2634:             for y in j:
 2635:                 y[...] += 1
 2636:         assert_equal(a, [[1, 2, 3], [4, 5, 6]])
 2637: 
 2638:     def test_0d(self):
 2639:         a = np.arange(12).reshape(2, 3, 2)
 2640:         i, j = np.nested_iters(a, [[], [1, 0, 2]])
 2641:         vals = [list(j) for _ in i]
 2642:         assert_equal(vals, [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]])
 2643: 
 2644:         i, j = np.nested_iters(a, [[1, 0, 2], []])
 2645:         vals = [list(j) for _ in i]
 2646:         assert_equal(vals, [[0], [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [11]])
 2647: 
 2648:         i, j, k = np.nested_iters(a, [[2, 0], [], [1]])
 2649:         vals = []
 2650:         for x in i:
 2651:             for y in j:
 2652:                 vals.append(list(k))
 2653:         assert_equal(vals, [[0, 2, 4], [1, 3, 5], [6, 8, 10], [7, 9, 11]])
 2654: 
 2655:     def test_iter_nested_iters_dtype_buffered(self):
 2656:         # Test nested iteration with buffering to change dtype
 2657: 
 2658:         a = arange(6, dtype='f4').reshape(2, 3)
 2659:         i, j = np.nested_iters(a, [[0], [1]],
 2660:                             flags=['buffered'],
 2661:                             op_flags=['readwrite'],
 2662:                             casting='same_kind',
 2663:                             op_dtypes='f8')
 2664:         with i, j:
 2665:             assert_equal(j[0].dtype, np.dtype('f8'))
 2666:             for x in i:
 2667:                 for y in j:
 2668:                     y[...] += 1
 2669:         assert_equal(a, [[1, 2, 3], [4, 5, 6]])
 2670: 
 2671: def test_iter_reduction_error():
 2672: 
 2673:     a = np.arange(6)
 2674:     assert_raises(ValueError, nditer, [a, None], [],
 2675:                     [['readonly'], ['readwrite', 'allocate']],
 2676:                     op_axes=[[0], [-1]])
 2677: 
 2678:     a = np.arange(6).reshape(2, 3)
 2679:     assert_raises(ValueError, nditer, [a, None], ['external_loop'],
 2680:                     [['readonly'], ['readwrite', 'allocate']],
 2681:                     op_axes=[[0, 1], [-1, -1]])
 2682: 
 2683: def test_iter_reduction():
 2684:     # Test doing reductions with the iterator
 2685: 
 2686:     a = np.arange(6)
 2687:     i = nditer([a, None], ['reduce_ok'],
 2688:                     [['readonly'], ['readwrite', 'allocate']],
 2689:                     op_axes=[[0], [-1]])
 2690:     # Need to initialize the output operand to the addition unit
 2691:     with i:
 2692:         i.operands[1][...] = 0
 2693:         # Do the reduction
 2694:         for x, y in i:
 2695:             y[...] += x
 2696:         # Since no axes were specified, should have allocated a scalar
 2697:         assert_equal(i.operands[1].ndim, 0)
 2698:         assert_equal(i.operands[1], np.sum(a))
 2699: 
 2700:     a = np.arange(6).reshape(2, 3)
 2701:     i = nditer([a, None], ['reduce_ok', 'external_loop'],
 2702:                     [['readonly'], ['readwrite', 'allocate']],
 2703:                     op_axes=[[0, 1], [-1, -1]])
 2704:     # Need to initialize the output operand to the addition unit
 2705:     with i:
 2706:         i.operands[1][...] = 0
 2707:         # Reduction shape/strides for the output
 2708:         assert_equal(i[1].shape, (6,))
 2709:         assert_equal(i[1].strides, (0,))
 2710:         # Do the reduction
 2711:         for x, y in i:
 2712:             # Use a for loop instead of ``y[...] += x``
 2713:             # (equivalent to ``y[...] = y[...].copy() + x``),
 2714:             # because y has zero strides we use for the reduction
 2715:             for j in range(len(y)):
 2716:                 y[j] += x[j]
 2717:         # Since no axes were specified, should have allocated a scalar
 2718:         assert_equal(i.operands[1].ndim, 0)
 2719:         assert_equal(i.operands[1], np.sum(a))
 2720: 
 2721:     # This is a tricky reduction case for the buffering double loop
 2722:     # to handle
 2723:     a = np.ones((2, 3, 5))
 2724:     it1 = nditer([a, None], ['reduce_ok', 'external_loop'],
 2725:                     [['readonly'], ['readwrite', 'allocate']],
 2726:                     op_axes=[None, [0, -1, 1]])
 2727:     it2 = nditer([a, None], ['reduce_ok', 'external_loop',
 2728:                             'buffered', 'delay_bufalloc'],
 2729:                     [['readonly'], ['readwrite', 'allocate']],
 2730:                     op_axes=[None, [0, -1, 1]], buffersize=10)
 2731:     with it1, it2:
 2732:         it1.operands[1].fill(0)
 2733:         it2.operands[1].fill(0)
 2734:         it2.reset()
 2735:         for x in it1:
 2736:             x[1][...] += x[0]
 2737:         for x in it2:
 2738:             x[1][...] += x[0]
 2739:         assert_equal(it1.operands[1], it2.operands[1])
 2740:         assert_equal(it2.operands[1].sum(), a.size)
 2741: 
 2742: def test_iter_buffering_reduction():
 2743:     # Test doing buffered reductions with the iterator
 2744: 
 2745:     a = np.arange(6)
 2746:     b = np.array(0., dtype='f8').byteswap()
 2747:     b = b.view(b.dtype.newbyteorder())
 2748:     i = nditer([a, b], ['reduce_ok', 'buffered'],
 2749:                     [['readonly'], ['readwrite', 'nbo']],
 2750:                     op_axes=[[0], [-1]])
 2751:     with i:
 2752:         assert_equal(i[1].dtype, np.dtype('f8'))
 2753:         assert_(i[1].dtype != b.dtype)
 2754:         # Do the reduction
 2755:         for x, y in i:
 2756:             y[...] += x
 2757:     # Since no axes were specified, should have allocated a scalar
 2758:     assert_equal(b, np.sum(a))
 2759: 
 2760:     a = np.arange(6).reshape(2, 3)
 2761:     b = np.array([0, 0], dtype='f8').byteswap()
 2762:     b = b.view(b.dtype.newbyteorder())
 2763:     i = nditer([a, b], ['reduce_ok', 'external_loop', 'buffered'],
 2764:                     [['readonly'], ['readwrite', 'nbo']],
 2765:                     op_axes=[[0, 1], [0, -1]])
 2766:     # Reduction shape/strides for the output
 2767:     with i:
 2768:         assert_equal(i[1].shape, (3,))
 2769:         assert_equal(i[1].strides, (0,))
 2770:         # Do the reduction
 2771:         for x, y in i:
 2772:             # Use a for loop instead of ``y[...] += x``
 2773:             # (equivalent to ``y[...] = y[...].copy() + x``),
 2774:             # because y has zero strides we use for the reduction
 2775:             for j in range(len(y)):
 2776:                 y[j] += x[j]
 2777:     assert_equal(b, np.sum(a, axis=1))
 2778: 
 2779:     # Iterator inner double loop was wrong on this one
 2780:     p = np.arange(2) + 1
 2781:     it = np.nditer([p, None],
 2782:             ['delay_bufalloc', 'reduce_ok', 'buffered', 'external_loop'],
 2783:             [['readonly'], ['readwrite', 'allocate']],
 2784:             op_axes=[[-1, 0], [-1, -1]],
 2785:             itershape=(2, 2))
 2786:     with it:
 2787:         it.operands[1].fill(0)
 2788:         it.reset()
 2789:         assert_equal(it[0], [1, 2, 1, 2])
 2790: 
 2791:     # Iterator inner loop should take argument contiguity into account
 2792:     x = np.ones((7, 13, 8), np.int8)[4:6, 1:11:6, 1:5].transpose(1, 2, 0)
 2793:     x[...] = np.arange(x.size).reshape(x.shape)
 2794:     y_base = np.arange(4 * 4, dtype=np.int8).reshape(4, 4)
 2795:     y_base_copy = y_base.copy()
 2796:     y = y_base[::2, :, None]
 2797: 
 2798:     it = np.nditer([y, x],
 2799:                    ['buffered', 'external_loop', 'reduce_ok'],
 2800:                    [['readwrite'], ['readonly']])
 2801:     with it:
 2802:         for a, b in it:
 2803:             a.fill(2)
 2804: 
 2805:     assert_equal(y_base[1::2], y_base_copy[1::2])
 2806:     assert_equal(y_base[::2], 2)
 2807: 
 2808: def test_iter_buffering_reduction_reuse_reduce_loops():
 2809:     # There was a bug triggering reuse of the reduce loop inappropriately,
 2810:     # which caused processing to happen in unnecessarily small chunks
 2811:     # and overran the buffer.
 2812: 
 2813:     a = np.zeros((2, 7))
 2814:     b = np.zeros((1, 7))
 2815:     it = np.nditer([a, b], flags=['reduce_ok', 'external_loop', 'buffered'],
 2816:                     op_flags=[['readonly'], ['readwrite']],
 2817:                     buffersize=5)
 2818: 
 2819:     with it:
 2820:         bufsizes = [x.shape[0] for x, y in it]
 2821:     assert_equal(bufsizes, [5, 2, 5, 2])
 2822:     assert_equal(sum(bufsizes), a.size)
 2823: 
 2824: def test_iter_writemasked_badinput():
 2825:     a = np.zeros((2, 3))
 2826:     b = np.zeros((3,))
 2827:     m = np.array([[True, True, False], [False, True, False]])
 2828:     m2 = np.array([True, True, False])
 2829:     m3 = np.array([0, 1, 1], dtype='u1')
 2830:     mbad1 = np.array([0, 1, 1], dtype='i1')
 2831:     mbad2 = np.array([0, 1, 1], dtype='f4')
 2832: 
 2833:     # Need an 'arraymask' if any operand is 'writemasked'
 2834:     assert_raises(ValueError, nditer, [a, m], [],
 2835:                     [['readwrite', 'writemasked'], ['readonly']])
 2836: 
 2837:     # A 'writemasked' operand must not be readonly
 2838:     assert_raises(ValueError, nditer, [a, m], [],
 2839:                     [['readonly', 'writemasked'], ['readonly', 'arraymask']])
 2840: 
 2841:     # 'writemasked' and 'arraymask' may not be used together
 2842:     assert_raises(ValueError, nditer, [a, m], [],
 2843:                     [['readonly'], ['readwrite', 'arraymask', 'writemasked']])
 2844: 
 2845:     # 'arraymask' may only be specified once
 2846:     assert_raises(ValueError, nditer, [a, m, m2], [],
 2847:                     [['readwrite', 'writemasked'],
 2848:                      ['readonly', 'arraymask'],
 2849:                      ['readonly', 'arraymask']])
 2850: 
 2851:     # An 'arraymask' with nothing 'writemasked' also doesn't make sense
 2852:     assert_raises(ValueError, nditer, [a, m], [],
 2853:                     [['readwrite'], ['readonly', 'arraymask']])
 2854: 
 2855:     # A writemasked reduction requires a similarly smaller mask
 2856:     assert_raises(ValueError, nditer, [a, b, m], ['reduce_ok'],
 2857:                     [['readonly'],
 2858:                      ['readwrite', 'writemasked'],
 2859:                      ['readonly', 'arraymask']])
 2860:     # But this should work with a smaller/equal mask to the reduction operand
 2861:     np.nditer([a, b, m2], ['reduce_ok'],
 2862:                     [['readonly'],
 2863:                      ['readwrite', 'writemasked'],
 2864:                      ['readonly', 'arraymask']])
 2865:     # The arraymask itself cannot be a reduction
 2866:     assert_raises(ValueError, nditer, [a, b, m2], ['reduce_ok'],
 2867:                     [['readonly'],
 2868:                      ['readwrite', 'writemasked'],
 2869:                      ['readwrite', 'arraymask']])
 2870: 
 2871:     # A uint8 mask is ok too
 2872:     np.nditer([a, m3], ['buffered'],
 2873:                     [['readwrite', 'writemasked'],
 2874:                      ['readonly', 'arraymask']],
 2875:                     op_dtypes=['f4', None],
 2876:                     casting='same_kind')
 2877:     # An int8 mask isn't ok
 2878:     assert_raises(TypeError, np.nditer, [a, mbad1], ['buffered'],
 2879:                     [['readwrite', 'writemasked'],
 2880:                      ['readonly', 'arraymask']],
 2881:                     op_dtypes=['f4', None],
 2882:                     casting='same_kind')
 2883:     # A float32 mask isn't ok
 2884:     assert_raises(TypeError, np.nditer, [a, mbad2], ['buffered'],
 2885:                     [['readwrite', 'writemasked'],
 2886:                      ['readonly', 'arraymask']],
 2887:                     op_dtypes=['f4', None],
 2888:                     casting='same_kind')
 2889: 
 2890: 
 2891: def _is_buffered(iterator):
 2892:     try:
 2893:         iterator.itviews
 2894:     except ValueError:
 2895:         return True
 2896:     return False
 2897: 
 2898: @pytest.mark.parametrize("a",
 2899:         [np.zeros((3,), dtype='f8'),
 2900:          np.zeros((9876, 3 * 5), dtype='f8')[::2, :],
 2901:          np.zeros((4, 312, 124, 3), dtype='f8')[::2, :, ::2, :],
 2902:          # Also test with the last dimension strided (so it does not fit if
 2903:          # there is repeated access)
 2904:          np.zeros((9,), dtype='f8')[::3],
 2905:          np.zeros((9876, 3 * 10), dtype='f8')[::2, ::5],
 2906:          np.zeros((4, 312, 124, 3), dtype='f8')[::2, :, ::2, ::-1]])
 2907: def test_iter_writemasked(a):
 2908:     # Note, the slicing above is to ensure that nditer cannot combine multiple
 2909:     # axes into one.  The repetition is just to make things a bit more
 2910:     # interesting.
 2911:     shape = a.shape
 2912:     reps = shape[-1] // 3
 2913:     msk = np.empty(shape, dtype=bool)
 2914:     msk[...] = [True, True, False] * reps
 2915: 
 2916:     # When buffering is unused, 'writemasked' effectively does nothing.
 2917:     # It's up to the user of the iterator to obey the requested semantics.
 2918:     it = np.nditer([a, msk], [],
 2919:                 [['readwrite', 'writemasked'],
 2920:                  ['readonly', 'arraymask']])
 2921:     with it:
 2922:         for x, m in it:
 2923:             x[...] = 1
 2924:     # Because we violated the semantics, all the values became 1
 2925:     assert_equal(a, np.broadcast_to([1, 1, 1] * reps, shape))
 2926: 
 2927:     # Even if buffering is enabled, we still may be accessing the array
 2928:     # directly.
 2929:     it = np.nditer([a, msk], ['buffered'],
 2930:                 [['readwrite', 'writemasked'],
 2931:                  ['readonly', 'arraymask']])
 2932:     # @seberg: I honestly don't currently understand why a "buffered" iterator
 2933:     # would end up not using a buffer for the small array here at least when
 2934:     # "writemasked" is used, that seems confusing...  Check by testing for
 2935:     # actual memory overlap!
 2936:     is_buffered = True
 2937:     with it:
 2938:         for x, m in it:
 2939:             x[...] = 2.5
 2940:             if np.may_share_memory(x, a):
 2941:                 is_buffered = False
 2942: 
 2943:     if not is_buffered:
 2944:         # Because we violated the semantics, all the values became 2.5
 2945:         assert_equal(a, np.broadcast_to([2.5, 2.5, 2.5] * reps, shape))
 2946:     else:
 2947:         # For large sizes, the iterator may be buffered:
 2948:         assert_equal(a, np.broadcast_to([2.5, 2.5, 1] * reps, shape))
 2949:         a[...] = 2.5
 2950: 
 2951:     # If buffering will definitely happening, for instance because of
 2952:     # a cast, only the items selected by the mask will be copied back from
 2953:     # the buffer.
 2954:     it = np.nditer([a, msk], ['buffered'],
 2955:                 [['readwrite', 'writemasked'],
 2956:                  ['readonly', 'arraymask']],
 2957:                 op_dtypes=['i8', None],
 2958:                 casting='unsafe')
 2959:     with it:
 2960:         for x, m in it:
 2961:             x[...] = 3
 2962:     # Even though we violated the semantics, only the selected values
 2963:     # were copied back
 2964:     assert_equal(a, np.broadcast_to([3, 3, 2.5] * reps, shape))
 2965: 
 2966: 
 2967: @pytest.mark.parametrize(["mask", "mask_axes"], [
 2968:         # Allocated operand (only broadcasts with -1)
 2969:         (None, [-1, 0]),
 2970:         # Reduction along the first dimension (with and without op_axes)
 2971:         (np.zeros((1, 4), dtype="bool"), [0, 1]),
 2972:         (np.zeros((1, 4), dtype="bool"), None),
 2973:         # Test 0-D and -1 op_axes
 2974:         (np.zeros(4, dtype="bool"), [-1, 0]),
 2975:         (np.zeros((), dtype="bool"), [-1, -1]),
 2976:         (np.zeros((), dtype="bool"), None)])
 2977: def test_iter_writemasked_broadcast_error(mask, mask_axes):
 2978:     # This assumes that a readwrite mask makes sense. This is likely not the
 2979:     # case and should simply be deprecated.
 2980:     arr = np.zeros((3, 4))
 2981:     itflags = ["reduce_ok"]
 2982:     mask_flags = ["arraymask", "readwrite", "allocate"]
 2983:     a_flags = ["writeonly", "writemasked"]
 2984:     if mask_axes is None:
 2985:         op_axes = None
 2986:     else:
 2987:         op_axes = [mask_axes, [0, 1]]
 2988: 
 2989:     with assert_raises(ValueError):
 2990:         np.nditer((mask, arr), flags=itflags, op_flags=[mask_flags, a_flags],
 2991:                   op_axes=op_axes)
 2992: 
 2993: 
 2994: def test_iter_writemasked_decref():
 2995:     # force casting (to make it interesting) by using a structured dtype.
 2996:     arr = np.arange(10000).astype(">i,O")
 2997:     original = arr.copy()
 2998:     mask = np.random.randint(0, 2, size=10000).astype(bool)
 2999: 
 3000:     it = np.nditer([arr, mask], ['buffered', "refs_ok"],
 3001:                    [['readwrite', 'writemasked'],
 3002:                     ['readonly', 'arraymask']],
 3003:                    op_dtypes=["<i,O", "?"])
 3004:     singleton = object()
 3005:     if HAS_REFCOUNT:
 3006:         count = sys.getrefcount(singleton)
 3007:     for buf, mask_buf in it:
 3008:         buf[...] = (3, singleton)
 3009: 
 3010:     del buf, mask_buf, it   # delete everything to ensure correct cleanup
 3011: 
 3012:     if HAS_REFCOUNT:
 3013:         # The buffer would have included additional items, they must be
 3014:         # cleared correctly:
 3015:         assert sys.getrefcount(singleton) - count == np.count_nonzero(mask)
 3016: 
 3017:     assert_array_equal(arr[~mask], original[~mask])
 3018:     assert (arr[mask] == np.array((3, singleton), arr.dtype)).all()
 3019:     del arr
 3020: 
 3021:     if HAS_REFCOUNT:
 3022:         assert sys.getrefcount(singleton) == count
 3023: 
 3024: 
 3025: def test_iter_non_writable_attribute_deletion():
 3026:     it = np.nditer(np.ones(2))
 3027:     attr = ["value", "shape", "operands", "itviews", "has_delayed_bufalloc",
 3028:             "iterationneedsapi", "has_multi_index", "has_index", "dtypes",
 3029:             "ndim", "nop", "itersize", "finished"]
 3030: 
 3031:     for s in attr:
 3032:         assert_raises(AttributeError, delattr, it, s)
 3033: 
 3034: 
 3035: def test_iter_writable_attribute_deletion():
 3036:     it = np.nditer(np.ones(2))
 3037:     attr = ["multi_index", "index", "iterrange", "iterindex"]
 3038:     for s in attr:
 3039:         assert_raises(AttributeError, delattr, it, s)
 3040: 
 3041: 
 3042: def test_iter_element_deletion():
 3043:     it = np.nditer(np.ones(3))
 3044:     try:
 3045:         del it[1]
 3046:         del it[1:2]
 3047:     except TypeError:
 3048:         pass
 3049:     except Exception:
 3050:         raise AssertionError
 3051: 
 3052: def test_iter_allocated_array_dtypes():
 3053:     # If the dtype of an allocated output has a shape, the shape gets
 3054:     # tacked onto the end of the result.
 3055:     it = np.nditer(([1, 3, 20], None), op_dtypes=[None, ('i4', (2,))])
 3056:     for a, b in it:
 3057:         b[0] = a - 1
 3058:         b[1] = a + 1
 3059:     assert_equal(it.operands[1], [[0, 2], [2, 4], [19, 21]])
 3060: 
 3061:     # Check the same (less sensitive) thing when `op_axes` with -1 is given.
 3062:     it = np.nditer(([[1, 3, 20]], None), op_dtypes=[None, ('i4', (2,))],
 3063:                    flags=["reduce_ok"], op_axes=[None, (-1, 0)])
 3064:     for a, b in it:
 3065:         b[0] = a - 1
 3066:         b[1] = a + 1
 3067:     assert_equal(it.operands[1], [[0, 2], [2, 4], [19, 21]])
 3068: 
 3069:     # Make sure this works for scalars too
 3070:     it = np.nditer((10, 2, None), op_dtypes=[None, None, ('i4', (2, 2))])
 3071:     for a, b, c in it:
 3072:         c[0, 0] = a - b
 3073:         c[0, 1] = a + b
 3074:         c[1, 0] = a * b
 3075:         c[1, 1] = a / b
 3076:     assert_equal(it.operands[2], [[8, 12], [20, 5]])
 3077: 
 3078: 
 3079: def test_0d_iter():
 3080:     # Basic test for iteration of 0-d arrays:
 3081:     i = nditer([2, 3], ['multi_index'], [['readonly']] * 2)
 3082:     assert_equal(i.ndim, 0)
 3083:     assert_equal(next(i), (2, 3))
 3084:     assert_equal(i.multi_index, ())
 3085:     assert_equal(i.iterindex, 0)
 3086:     assert_raises(StopIteration, next, i)
 3087:     # test reset:
 3088:     i.reset()
 3089:     assert_equal(next(i), (2, 3))
 3090:     assert_raises(StopIteration, next, i)
 3091: 
 3092:     # test forcing to 0-d
 3093:     i = nditer(np.arange(5), ['multi_index'], [['readonly']], op_axes=[()])
 3094:     assert_equal(i.ndim, 0)
 3095:     assert_equal(len(i), 1)
 3096: 
 3097:     i = nditer(np.arange(5), ['multi_index'], [['readonly']],
 3098:                op_axes=[()], itershape=())
 3099:     assert_equal(i.ndim, 0)
 3100:     assert_equal(len(i), 1)
 3101: 
 3102:     # passing an itershape alone is not enough, the op_axes are also needed
 3103:     with assert_raises(ValueError):
 3104:         nditer(np.arange(5), ['multi_index'], [['readonly']], itershape=())
 3105: 
 3106:     # Test a more complex buffered casting case (same as another test above)
 3107:     sdt = [('a', 'f4'), ('b', 'i8'), ('c', 'c8', (2, 3)), ('d', 'O')]
 3108:     a = np.array(0.5, dtype='f4')
 3109:     i = nditer(a, ['buffered', 'refs_ok'], ['readonly'],
 3110:                     casting='unsafe', op_dtypes=sdt)
 3111:     vals = next(i)
 3112:     assert_equal(vals['a'], 0.5)
 3113:     assert_equal(vals['b'], 0)
 3114:     assert_equal(vals['c'], [[(0.5)] * 3] * 2)
 3115:     assert_equal(vals['d'], 0.5)
 3116: 
 3117: def test_object_iter_cleanup():
 3118:     # see gh-18450
 3119:     # object arrays can raise a python exception in ufunc inner loops using
 3120:     # nditer, which should cause iteration to stop & cleanup. There were bugs
 3121:     # in the nditer cleanup when decref'ing object arrays.
 3122:     # This test would trigger valgrind "uninitialized read" before the bugfix.
 3123:     assert_raises(TypeError, lambda: np.zeros((17000, 2), dtype='f4') * None)
 3124: 
 3125:     # this more explicit code also triggers the invalid access
 3126:     arr = np.arange(ncu.BUFSIZE * 10).reshape(10, -1).astype(str)
 3127:     oarr = arr.astype(object)
 3128:     oarr[:, -1] = None
 3129:     assert_raises(TypeError, lambda: np.add(oarr[:, ::-1], arr[:, ::-1]))
 3130: 
 3131:     # followup: this tests for a bug introduced in the first pass of gh-18450,
 3132:     # caused by an incorrect fallthrough of the TypeError
 3133:     class T:
 3134:         def __bool__(self):
 3135:             raise TypeError("Ambiguous")
 3136:     assert_raises(TypeError, np.logical_or.reduce,
 3137:                              np.array([T(), T()], dtype='O'))
 3138: 
 3139: def test_object_iter_cleanup_reduce():
 3140:     # Similar as above, but a complex reduction case that was previously
 3141:     # missed (see gh-18810).
 3142:     # The following array is special in that it cannot be flattened:
 3143:     arr = np.array([[None, 1], [-1, -1], [None, 2], [-1, -1]])[::2]
 3144:     with pytest.raises(TypeError):
 3145:         np.sum(arr)
 3146: 
 3147: @pytest.mark.parametrize("arr", [
 3148:         np.ones((8000, 4, 2), dtype=object)[:, ::2, :],
 3149:         np.ones((8000, 4, 2), dtype=object, order="F")[:, ::2, :],
 3150:         np.ones((8000, 4, 2), dtype=object)[:, ::2, :].copy("F")])
 3151: def test_object_iter_cleanup_large_reduce(arr):
 3152:     # More complicated calls are possible for large arrays:
 3153:     out = np.ones(8000, dtype=np.intp)
 3154:     # force casting with `dtype=object`
 3155:     res = np.sum(arr, axis=(1, 2), dtype=object, out=out)
 3156:     assert_array_equal(res, np.full(8000, 4, dtype=object))
 3157: 
 3158: def test_iter_too_large():
 3159:     # The total size of the iterator must not exceed the maximum intp due
 3160:     # to broadcasting. Dividing by 1024 will keep it small enough to
 3161:     # give a legal array.
 3162:     size = np.iinfo(np.intp).max // 1024
 3163:     arr = np.lib.stride_tricks.as_strided(np.zeros(1), (size,), (0,))
 3164:     assert_raises(ValueError, nditer, (arr, arr[:, None]))
 3165:     # test the same for multiindex. That may get more interesting when
 3166:     # removing 0 dimensional axis is allowed (since an iterator can grow then)
 3167:     assert_raises(ValueError, nditer,
 3168:                   (arr, arr[:, None]), flags=['multi_index'])
 3169: 
 3170: 
 3171: def test_iter_too_large_with_multiindex():
 3172:     # When a multi index is being tracked, the error is delayed this
 3173:     # checks the delayed error messages and getting below that by
 3174:     # removing an axis.
 3175:     base_size = 2**10
 3176:     num = 1
 3177:     while base_size**num < np.iinfo(np.intp).max:
 3178:         num += 1
 3179: 
 3180:     shape_template = [1, 1] * num
 3181:     arrays = []
 3182:     for i in range(num):
 3183:         shape = shape_template[:]
 3184:         shape[i * 2] = 2**10
 3185:         arrays.append(np.empty(shape))
 3186:     arrays = tuple(arrays)
 3187: 
 3188:     # arrays are now too large to be broadcast. The different modes test
 3189:     # different nditer functionality with or without GIL.
 3190:     for mode in range(6):
 3191:         with assert_raises(ValueError):
 3192:             _multiarray_tests.test_nditer_too_large(arrays, -1, mode)
 3193:     # but if we do nothing with the nditer, it can be constructed:
 3194:     _multiarray_tests.test_nditer_too_large(arrays, -1, 7)
 3195: 
 3196:     # When an axis is removed, things should work again (half the time):
 3197:     for i in range(num):
 3198:         for mode in range(6):
 3199:             # an axis with size 1024 is removed:
 3200:             _multiarray_tests.test_nditer_too_large(arrays, i * 2, mode)
 3201:             # an axis with size 1 is removed:
 3202:             with assert_raises(ValueError):
 3203:                 _multiarray_tests.test_nditer_too_large(arrays, i * 2 + 1, mode)
 3204: 
 3205: def test_writebacks():
 3206:     a = np.arange(6, dtype='f4')
 3207:     au = a.byteswap()
 3208:     au = au.view(au.dtype.newbyteorder())
 3209:     assert_(a.dtype.byteorder != au.dtype.byteorder)
 3210:     it = nditer(au, [], [['readwrite', 'updateifcopy']],
 3211:                         casting='equiv', op_dtypes=[np.dtype('f4')])
 3212:     with it:
 3213:         it.operands[0][:] = 100
 3214:     assert_equal(au, 100)
 3215:     # do it again, this time raise an error,
 3216:     it = nditer(au, [], [['readwrite', 'updateifcopy']],
 3217:                         casting='equiv', op_dtypes=[np.dtype('f4')])
 3218:     try:
 3219:         with it:
 3220:             assert_equal(au.flags.writeable, False)
 3221:             it.operands[0][:] = 0
 3222:             raise ValueError('exit context manager on exception')
 3223:     except Exception:
 3224:         pass
 3225:     assert_equal(au, 0)
 3226:     assert_equal(au.flags.writeable, True)
 3227:     # cannot reuse i outside context manager
 3228:     assert_raises(ValueError, getattr, it, 'operands')
 3229: 
 3230:     it = nditer(au, [], [['readwrite', 'updateifcopy']],
 3231:                         casting='equiv', op_dtypes=[np.dtype('f4')])
 3232:     with it:
 3233:         x = it.operands[0]
 3234:         x[:] = 6
 3235:         assert_(x.flags.writebackifcopy)
 3236:     assert_equal(au, 6)
 3237:     assert_(not x.flags.writebackifcopy)
 3238:     x[:] = 123  # x.data still valid
 3239:     assert_equal(au, 6)  # but not connected to au
 3240: 
 3241:     it = nditer(au, [],
 3242:                  [['readwrite', 'updateifcopy']],
 3243:                  casting='equiv', op_dtypes=[np.dtype('f4')])
 3244:     # reentering works
 3245:     with it:
 3246:         with it:
 3247:             for x in it:
 3248:                 x[...] = 123
 3249: 
 3250:     it = nditer(au, [],
 3251:                  [['readwrite', 'updateifcopy']],
 3252:                  casting='equiv', op_dtypes=[np.dtype('f4')])
 3253:     # make sure exiting the inner context manager closes the iterator
 3254:     with it:
 3255:         with it:
 3256:             for x in it:
 3257:                 x[...] = 123
 3258:         assert_raises(ValueError, getattr, it, 'operands')
 3259:     # do not crash if original data array is decrefed
 3260:     it = nditer(au, [],
 3261:                  [['readwrite', 'updateifcopy']],
 3262:                  casting='equiv', op_dtypes=[np.dtype('f4')])
 3263:     del au
 3264:     with it:
 3265:         for x in it:
 3266:             x[...] = 123
 3267:     # make sure we cannot reenter the closed iterator
 3268:     enter = it.__enter__
 3269:     assert_raises(RuntimeError, enter)
 3270: 
 3271: def test_close_equivalent():
 3272:     ''' using a context amanger and using nditer.close are equivalent
 3273:     '''
 3274:     def add_close(x, y, out=None):
 3275:         addop = np.add
 3276:         it = np.nditer([x, y, out], [],
 3277:                     [['readonly'], ['readonly'], ['writeonly', 'allocate']])
 3278:         for (a, b, c) in it:
 3279:             addop(a, b, out=c)
 3280:         ret = it.operands[2]
 3281:         it.close()
 3282:         return ret
 3283: 
 3284:     def add_context(x, y, out=None):
 3285:         addop = np.add
 3286:         it = np.nditer([x, y, out], [],
 3287:                     [['readonly'], ['readonly'], ['writeonly', 'allocate']])
 3288:         with it:
 3289:             for (a, b, c) in it:
 3290:                 addop(a, b, out=c)
 3291:             return it.operands[2]
 3292:     z = add_close(range(5), range(5))
 3293:     assert_equal(z, range(0, 10, 2))
 3294:     z = add_context(range(5), range(5))
 3295:     assert_equal(z, range(0, 10, 2))
 3296: 
 3297: def test_close_raises():
 3298:     it = np.nditer(np.arange(3))
 3299:     assert_equal(next(it), 0)
 3300:     it.close()
 3301:     assert_raises(StopIteration, next, it)
 3302:     assert_raises(ValueError, getattr, it, 'operands')
 3303: 
 3304: def test_close_parameters():
 3305:     it = np.nditer(np.arange(3))
 3306:     assert_raises(TypeError, it.close, 1)
 3307: 
 3308: @pytest.mark.skipif(not HAS_REFCOUNT, reason="Python lacks refcounts")
 3309: def test_warn_noclose():
 3310:     a = np.arange(6, dtype='f4')
 3311:     au = a.byteswap()
 3312:     au = au.view(au.dtype.newbyteorder())
 3313:     with suppress_warnings() as sup:
 3314:         sup.record(RuntimeWarning)
 3315:         it = np.nditer(au, [], [['readwrite', 'updateifcopy']],
 3316:                         casting='equiv', op_dtypes=[np.dtype('f4')])
 3317:         del it
 3318:         assert len(sup.log) == 1
 3319: 
 3320: 
 3321: @pytest.mark.parametrize(["in_dtype", "buf_dtype"],
 3322:         [("i", "O"), ("O", "i"),  # most simple cases
 3323:          ("i,O", "O,O"),  # structured partially only copying O
 3324:          ("O,i", "i,O"),  # structured casting to and from O
 3325:          ])
 3326: @pytest.mark.parametrize("steps", [1, 2, 3])
 3327: def test_partial_iteration_cleanup(in_dtype, buf_dtype, steps):
 3328:     """
 3329:     Checks for reference counting leaks during cleanup.  Using explicit
 3330:     reference counts lead to occasional false positives (at least in parallel
 3331:     test setups).  This test now should still test leaks correctly when
 3332:     run e.g. with pytest-valgrind or pytest-leaks
 3333:     """
 3334:     value = 2**30 + 1  # just a random value that Python won't intern
 3335:     arr = np.full(int(ncu.BUFSIZE * 2.5), value).astype(in_dtype)
 3336: 
 3337:     it = np.nditer(arr, op_dtypes=[np.dtype(buf_dtype)],
 3338:             flags=["buffered", "external_loop", "refs_ok"], casting="unsafe")
 3339:     for step in range(steps):
 3340:         # The iteration finishes in 3 steps, the first two are partial
 3341:         next(it)
 3342: 
 3343:     del it  # not necessary, but we test the cleanup
 3344: 
 3345:     # Repeat the test with `iternext`
 3346:     it = np.nditer(arr, op_dtypes=[np.dtype(buf_dtype)],
 3347:                    flags=["buffered", "external_loop", "refs_ok"], casting="unsafe")
 3348:     for step in range(steps):
 3349:         it.iternext()
 3350: 
 3351:     del it  # not necessary, but we test the cleanup
 3352: 
 3353: @pytest.mark.skipif(not HAS_REFCOUNT, reason="Python lacks refcounts")
 3354: @pytest.mark.parametrize(["in_dtype", "buf_dtype"],
 3355:          [("O", "i"),  # most simple cases
 3356:           ("O,i", "i,O"),  # structured casting to and from O
 3357:           ])
 3358: def test_partial_iteration_error(in_dtype, buf_dtype):
 3359:     value = 123  # relies on python cache (leak-check will still find it)
 3360:     arr = np.full(int(ncu.BUFSIZE * 2.5), value).astype(in_dtype)
 3361:     if in_dtype == "O":
 3362:         arr[int(ncu.BUFSIZE * 1.5)] = None
 3363:     else:
 3364:         arr[int(ncu.BUFSIZE * 1.5)]["f0"] = None
 3365: 
 3366:     count = sys.getrefcount(value)
 3367: 
 3368:     it = np.nditer(arr, op_dtypes=[np.dtype(buf_dtype)],
 3369:             flags=["buffered", "external_loop", "refs_ok"], casting="unsafe")
 3370:     with pytest.raises(TypeError):
 3371:         # pytest.raises seems to have issues with the error originating
 3372:         # in the for loop, so manually unravel:
 3373:         next(it)
 3374:         next(it)  # raises TypeError
 3375: 
 3376:     # Repeat the test with `iternext` after resetting, the buffers should
 3377:     # already be cleared from any references, so resetting is sufficient.
 3378:     it.reset()
 3379:     with pytest.raises(TypeError):
 3380:         it.iternext()
 3381:         it.iternext()
 3382: 
 3383:     assert count == sys.getrefcount(value)
 3384: 
 3385: 
 3386: def test_arbitrary_number_of_ops():
 3387:     # 2*16 + 1 is still just a few kiB, so should be fast and easy to deal with
 3388:     # but larger than any small custom integer.
 3389:     ops = [np.arange(10) for a in range(2**16 + 1)]
 3390: 
 3391:     it = np.nditer(ops)
 3392:     for i, vals in enumerate(it):
 3393:         assert all(v == i for v in vals)
 3394: 
 3395: 
 3396: def test_arbitrary_number_of_ops_nested():
 3397:     # 2*16 + 1 is still just a few kiB, so should be fast and easy to deal with
 3398:     # but larger than any small custom integer.
 3399:     ops = [np.arange(10) for a in range(2**16 + 1)]
 3400: 
 3401:     it = np.nested_iters(ops, [[0], []])
 3402:     for i, vals in enumerate(it):
 3403:         assert all(v == i for v in vals)
 3404: 
 3405: 
 3406: @pytest.mark.slow
 3407: @requires_memory(9 * np.iinfo(np.intc).max)
 3408: def test_arbitrary_number_of_ops_error():
 3409:     # A different error may happen for more than integer operands, but that
 3410:     # is too large to test nicely.
 3411:     a = np.ones(1)
 3412:     args = [a] * (np.iinfo(np.intc).max + 1)
 3413:     with pytest.raises(ValueError, match="Too many operands to nditer"):
 3414:         np.nditer(args)
 3415: 
 3416:     with pytest.raises(ValueError, match="Too many operands to nditer"):
 3417:         np.nested_iters(args, [[0], []])
 3418: 
 3419: 
 3420: def test_debug_print(capfd):
 3421:     """
 3422:     Matches the expected output of a debug print with the actual output.
 3423:     Note that the iterator dump should not be considered stable API,
 3424:     this test is mainly to ensure the print does not crash.
 3425: 
 3426:     Currently uses a subprocess to avoid dealing with the C level `printf`s.
 3427:     """
 3428:     # the expected output with all addresses and sizes stripped (they vary
 3429:     # and/or are platform dependent).
 3430:     expected = """
 3431:     ------ BEGIN ITERATOR DUMP ------
 3432:     | Iterator Address:
 3433:     | ItFlags: BUFFER REDUCE
 3434:     | NDim: 2
 3435:     | NOp: 2
 3436:     | IterSize: 50
 3437:     | IterStart: 0
 3438:     | IterEnd: 50
 3439:     | IterIndex: 0
 3440:     | Iterator SizeOf:
 3441:     | BufferData SizeOf:
 3442:     | AxisData SizeOf:
 3443:     |
 3444:     | Perm: 0 1
 3445:     | DTypes:
 3446:     | DTypes: dtype('float64') dtype('int32')
 3447:     | InitDataPtrs:
 3448:     | BaseOffsets: 0 0
 3449:     | Ptrs:
 3450:     | User/buffer ptrs:
 3451:     | Operands:
 3452:     | Operand DTypes: dtype('int64') dtype('float64')
 3453:     | OpItFlags:
 3454:     |   Flags[0]: READ CAST
 3455:     |   Flags[1]: READ WRITE CAST REDUCE
 3456:     |
 3457:     | BufferData:
 3458:     |   BufferSize: 50
 3459:     |   Size: 5
 3460:     |   BufIterEnd: 5
 3461:     |   BUFFER CoreSize: 5
 3462:     |   REDUCE Pos: 0
 3463:     |   REDUCE OuterSize: 10
 3464:     |   REDUCE OuterDim: 1
 3465:     |   Strides: 8 4
 3466:     |   REDUCE Outer Strides: 40 0
 3467:     |   REDUCE Outer Ptrs:
 3468:     |   ReadTransferFn:
 3469:     |   ReadTransferData:
 3470:     |   WriteTransferFn:
 3471:     |   WriteTransferData:
 3472:     |   Buffers:
 3473:     |
 3474:     | AxisData[0]:
 3475:     |   Shape: 5
 3476:     |   Index: 0
 3477:     |   Strides: 16 8
 3478:     | AxisData[1]:
 3479:     |   Shape: 10
 3480:     |   Index: 0
 3481:     |   Strides: 80 0
 3482:     ------- END ITERATOR DUMP -------
 3483:     """.strip().splitlines()
 3484: 
 3485:     arr1 = np.arange(100, dtype=np.int64).reshape(10, 10)[:, ::2]
 3486:     arr2 = np.arange(5.)
 3487:     it = np.nditer((arr1, arr2), op_dtypes=["d", "i4"], casting="unsafe",
 3488:                    flags=["reduce_ok", "buffered"],
 3489:                    op_flags=[["readonly"], ["readwrite"]])
 3490:     it.debug_print()
 3491:     res = capfd.readouterr().out
 3492:     res = res.strip().splitlines()
 3493: 
 3494:     assert len(res) == len(expected)
 3495:     for res_line, expected_line in zip(res, expected):
 3496:         # The actual output may have additional pointers listed that are
 3497:         # stripped from the example output:
 3498:         assert res_line.startswith(expected_line.strip())
