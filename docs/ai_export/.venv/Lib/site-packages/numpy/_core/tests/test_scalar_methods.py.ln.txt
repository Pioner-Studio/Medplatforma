    1: """
    2: Test the scalar constructors, which also do type-coercion
    3: """
    4: import fractions
    5: import platform
    6: import types
    7: from typing import Any
    8: 
    9: import pytest
   10: 
   11: import numpy as np
   12: from numpy._core import sctypes
   13: from numpy.testing import assert_equal, assert_raises
   14: 
   15: 
   16: class TestAsIntegerRatio:
   17:     # derived in part from the cpython test "test_floatasratio"
   18: 
   19:     @pytest.mark.parametrize("ftype", [
   20:         np.half, np.single, np.double, np.longdouble])
   21:     @pytest.mark.parametrize("f, ratio", [
   22:         (0.875, (7, 8)),
   23:         (-0.875, (-7, 8)),
   24:         (0.0, (0, 1)),
   25:         (11.5, (23, 2)),
   26:         ])
   27:     def test_small(self, ftype, f, ratio):
   28:         assert_equal(ftype(f).as_integer_ratio(), ratio)
   29: 
   30:     @pytest.mark.parametrize("ftype", [
   31:         np.half, np.single, np.double, np.longdouble])
   32:     def test_simple_fractions(self, ftype):
   33:         R = fractions.Fraction
   34:         assert_equal(R(0, 1),
   35:                      R(*ftype(0.0).as_integer_ratio()))
   36:         assert_equal(R(5, 2),
   37:                      R(*ftype(2.5).as_integer_ratio()))
   38:         assert_equal(R(1, 2),
   39:                      R(*ftype(0.5).as_integer_ratio()))
   40:         assert_equal(R(-2100, 1),
   41:                      R(*ftype(-2100.0).as_integer_ratio()))
   42: 
   43:     @pytest.mark.parametrize("ftype", [
   44:         np.half, np.single, np.double, np.longdouble])
   45:     def test_errors(self, ftype):
   46:         assert_raises(OverflowError, ftype('inf').as_integer_ratio)
   47:         assert_raises(OverflowError, ftype('-inf').as_integer_ratio)
   48:         assert_raises(ValueError, ftype('nan').as_integer_ratio)
   49: 
   50:     def test_against_known_values(self):
   51:         R = fractions.Fraction
   52:         assert_equal(R(1075, 512),
   53:                      R(*np.half(2.1).as_integer_ratio()))
   54:         assert_equal(R(-1075, 512),
   55:                      R(*np.half(-2.1).as_integer_ratio()))
   56:         assert_equal(R(4404019, 2097152),
   57:                      R(*np.single(2.1).as_integer_ratio()))
   58:         assert_equal(R(-4404019, 2097152),
   59:                      R(*np.single(-2.1).as_integer_ratio()))
   60:         assert_equal(R(4728779608739021, 2251799813685248),
   61:                      R(*np.double(2.1).as_integer_ratio()))
   62:         assert_equal(R(-4728779608739021, 2251799813685248),
   63:                      R(*np.double(-2.1).as_integer_ratio()))
   64:         # longdouble is platform dependent
   65: 
   66:     @pytest.mark.parametrize("ftype, frac_vals, exp_vals", [
   67:         # dtype test cases generated using hypothesis
   68:         # first five generated cases per dtype
   69:         (np.half, [0.0, 0.01154830649280303, 0.31082276347447274,
   70:                    0.527350517124794, 0.8308562335072596],
   71:                   [0, 1, 0, -8, 12]),
   72:         (np.single, [0.0, 0.09248576989263226, 0.8160498218131407,
   73:                      0.17389442853722373, 0.7956044195067877],
   74:                     [0, 12, 10, 17, -26]),
   75:         (np.double, [0.0, 0.031066908499895136, 0.5214135908877832,
   76:                      0.45780736035689296, 0.5906586745934036],
   77:                     [0, -801, 51, 194, -653]),
   78:         pytest.param(
   79:             np.longdouble,
   80:             [0.0, 0.20492557202724854, 0.4277180662199366, 0.9888085019891495,
   81:              0.9620175814461964],
   82:             [0, -7400, 14266, -7822, -8721],
   83:             marks=[
   84:                 pytest.mark.skipif(
   85:                     np.finfo(np.double) == np.finfo(np.longdouble),
   86:                     reason="long double is same as double"),
   87:                 pytest.mark.skipif(
   88:                     platform.machine().startswith("ppc"),
   89:                     reason="IBM double double"),
   90:             ]
   91:         )
   92:     ])
   93:     def test_roundtrip(self, ftype, frac_vals, exp_vals):
   94:         for frac, exp in zip(frac_vals, exp_vals):
   95:             f = np.ldexp(ftype(frac), exp)
   96:             assert f.dtype == ftype
   97:             n, d = f.as_integer_ratio()
   98: 
   99:             try:
  100:                 nf = np.longdouble(n)
  101:                 df = np.longdouble(d)
  102:                 if not np.isfinite(df):
  103:                     raise OverflowError
  104:             except (OverflowError, RuntimeWarning):
  105:                 # the values may not fit in any float type
  106:                 pytest.skip("longdouble too small on this platform")
  107: 
  108:             assert_equal(nf / df, f, f"{n}/{d}")
  109: 
  110: 
  111: class TestIsInteger:
  112:     @pytest.mark.parametrize("str_value", ["inf", "nan"])
  113:     @pytest.mark.parametrize("code", np.typecodes["Float"])
  114:     def test_special(self, code: str, str_value: str) -> None:
  115:         cls = np.dtype(code).type
  116:         value = cls(str_value)
  117:         assert not value.is_integer()
  118: 
  119:     @pytest.mark.parametrize(
  120:         "code", np.typecodes["Float"] + np.typecodes["AllInteger"]
  121:     )
  122:     def test_true(self, code: str) -> None:
  123:         float_array = np.arange(-5, 5).astype(code)
  124:         for value in float_array:
  125:             assert value.is_integer()
  126: 
  127:     @pytest.mark.parametrize("code", np.typecodes["Float"])
  128:     def test_false(self, code: str) -> None:
  129:         float_array = np.arange(-5, 5).astype(code)
  130:         float_array *= 1.1
  131:         for value in float_array:
  132:             if value == 0:
  133:                 continue
  134:             assert not value.is_integer()
  135: 
  136: 
  137: class TestClassGetItem:
  138:     @pytest.mark.parametrize("cls", [
  139:         np.number,
  140:         np.integer,
  141:         np.inexact,
  142:         np.unsignedinteger,
  143:         np.signedinteger,
  144:         np.floating,
  145:     ])
  146:     def test_abc(self, cls: type[np.number]) -> None:
  147:         alias = cls[Any]
  148:         assert isinstance(alias, types.GenericAlias)
  149:         assert alias.__origin__ is cls
  150: 
  151:     def test_abc_complexfloating(self) -> None:
  152:         alias = np.complexfloating[Any, Any]
  153:         assert isinstance(alias, types.GenericAlias)
  154:         assert alias.__origin__ is np.complexfloating
  155: 
  156:     @pytest.mark.parametrize("arg_len", range(4))
  157:     def test_abc_complexfloating_subscript_tuple(self, arg_len: int) -> None:
  158:         arg_tup = (Any,) * arg_len
  159:         if arg_len in (1, 2):
  160:             assert np.complexfloating[arg_tup]
  161:         else:
  162:             match = f"Too {'few' if arg_len == 0 else 'many'} arguments"
  163:             with pytest.raises(TypeError, match=match):
  164:                 np.complexfloating[arg_tup]
  165: 
  166:     @pytest.mark.parametrize("cls", [np.generic, np.flexible, np.character])
  167:     def test_abc_non_numeric(self, cls: type[np.generic]) -> None:
  168:         with pytest.raises(TypeError):
  169:             cls[Any]
  170: 
  171:     @pytest.mark.parametrize("code", np.typecodes["All"])
  172:     def test_concrete(self, code: str) -> None:
  173:         cls = np.dtype(code).type
  174:         with pytest.raises(TypeError):
  175:             cls[Any]
  176: 
  177:     @pytest.mark.parametrize("arg_len", range(4))
  178:     def test_subscript_tuple(self, arg_len: int) -> None:
  179:         arg_tup = (Any,) * arg_len
  180:         if arg_len == 1:
  181:             assert np.number[arg_tup]
  182:         else:
  183:             with pytest.raises(TypeError):
  184:                 np.number[arg_tup]
  185: 
  186:     def test_subscript_scalar(self) -> None:
  187:         assert np.number[Any]
  188: 
  189: 
  190: class TestBitCount:
  191:     # derived in part from the cpython test "test_bit_count"
  192: 
  193:     @pytest.mark.parametrize("itype", sctypes['int'] + sctypes['uint'])
  194:     def test_small(self, itype):
  195:         for a in range(max(np.iinfo(itype).min, 0), 128):
  196:             msg = f"Smoke test for {itype}({a}).bit_count()"
  197:             assert itype(a).bit_count() == a.bit_count(), msg
  198: 
  199:     def test_bit_count(self):
  200:         for exp in [10, 17, 63]:
  201:             a = 2**exp
  202:             assert np.uint64(a).bit_count() == 1
  203:             assert np.uint64(a - 1).bit_count() == exp
  204:             assert np.uint64(a ^ 63).bit_count() == 7
  205:             assert np.uint64((a - 1) ^ 510).bit_count() == exp - 8
  206: 
  207: 
  208: class TestDevice:
  209:     """
  210:     Test scalar.device attribute and scalar.to_device() method.
  211:     """
  212:     scalars = [np.bool(True), np.int64(1), np.uint64(1), np.float64(1.0),
  213:                np.complex128(1 + 1j)]
  214: 
  215:     @pytest.mark.parametrize("scalar", scalars)
  216:     def test_device(self, scalar):
  217:         assert scalar.device == "cpu"
  218: 
  219:     @pytest.mark.parametrize("scalar", scalars)
  220:     def test_to_device(self, scalar):
  221:         assert scalar.to_device("cpu") is scalar
  222: 
  223:     @pytest.mark.parametrize("scalar", scalars)
  224:     def test___array_namespace__(self, scalar):
  225:         assert scalar.__array_namespace__() is np
  226: 
  227: 
  228: @pytest.mark.parametrize("scalar", [np.bool(True), np.int8(1), np.float64(1)])
  229: def test_array_wrap(scalar):
  230:     # Test scalars array wrap as long as it exists.  NumPy itself should
  231:     # probably not use it, so it may not be necessary to keep it around.
  232: 
  233:     arr0d = np.array(3, dtype=np.int8)
  234:     # Third argument not passed, None, or True "decays" to scalar.
  235:     # (I don't think NumPy would pass `None`, but it seems clear to support)
  236:     assert type(scalar.__array_wrap__(arr0d)) is np.int8
  237:     assert type(scalar.__array_wrap__(arr0d, None, None)) is np.int8
  238:     assert type(scalar.__array_wrap__(arr0d, None, True)) is np.int8
  239: 
  240:     # Otherwise, result should be the input
  241:     assert scalar.__array_wrap__(arr0d, None, False) is arr0d
  242: 
  243:     # An old bug.  A non 0-d array cannot be converted to scalar:
  244:     arr1d = np.array([3], dtype=np.int8)
  245:     assert scalar.__array_wrap__(arr1d) is arr1d
  246:     assert scalar.__array_wrap__(arr1d, None, True) is arr1d
