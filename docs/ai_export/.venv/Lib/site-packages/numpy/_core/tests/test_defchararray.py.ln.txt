    1: import pytest
    2: 
    3: import numpy as np
    4: from numpy._core.multiarray import _vec_string
    5: from numpy.testing import (
    6:     assert_,
    7:     assert_array_equal,
    8:     assert_equal,
    9:     assert_raises,
   10:     assert_raises_regex,
   11: )
   12: 
   13: kw_unicode_true = {'unicode': True}  # make 2to3 work properly
   14: kw_unicode_false = {'unicode': False}
   15: 
   16: class TestBasic:
   17:     def test_from_object_array(self):
   18:         A = np.array([['abc', 2],
   19:                       ['long   ', '0123456789']], dtype='O')
   20:         B = np.char.array(A)
   21:         assert_equal(B.dtype.itemsize, 10)
   22:         assert_array_equal(B, [[b'abc', b'2'],
   23:                                [b'long', b'0123456789']])
   24: 
   25:     def test_from_object_array_unicode(self):
   26:         A = np.array([['abc', 'Sigma \u03a3'],
   27:                       ['long   ', '0123456789']], dtype='O')
   28:         assert_raises(ValueError, np.char.array, (A,))
   29:         B = np.char.array(A, **kw_unicode_true)
   30:         assert_equal(B.dtype.itemsize, 10 * np.array('a', 'U').dtype.itemsize)
   31:         assert_array_equal(B, [['abc', 'Sigma \u03a3'],
   32:                                ['long', '0123456789']])
   33: 
   34:     def test_from_string_array(self):
   35:         A = np.array([[b'abc', b'foo'],
   36:                       [b'long   ', b'0123456789']])
   37:         assert_equal(A.dtype.type, np.bytes_)
   38:         B = np.char.array(A)
   39:         assert_array_equal(B, A)
   40:         assert_equal(B.dtype, A.dtype)
   41:         assert_equal(B.shape, A.shape)
   42:         B[0, 0] = 'changed'
   43:         assert_(B[0, 0] != A[0, 0])
   44:         C = np.char.asarray(A)
   45:         assert_array_equal(C, A)
   46:         assert_equal(C.dtype, A.dtype)
   47:         C[0, 0] = 'changed again'
   48:         assert_(C[0, 0] != B[0, 0])
   49:         assert_(C[0, 0] == A[0, 0])
   50: 
   51:     def test_from_unicode_array(self):
   52:         A = np.array([['abc', 'Sigma \u03a3'],
   53:                       ['long   ', '0123456789']])
   54:         assert_equal(A.dtype.type, np.str_)
   55:         B = np.char.array(A)
   56:         assert_array_equal(B, A)
   57:         assert_equal(B.dtype, A.dtype)
   58:         assert_equal(B.shape, A.shape)
   59:         B = np.char.array(A, **kw_unicode_true)
   60:         assert_array_equal(B, A)
   61:         assert_equal(B.dtype, A.dtype)
   62:         assert_equal(B.shape, A.shape)
   63: 
   64:         def fail():
   65:             np.char.array(A, **kw_unicode_false)
   66: 
   67:         assert_raises(UnicodeEncodeError, fail)
   68: 
   69:     def test_unicode_upconvert(self):
   70:         A = np.char.array(['abc'])
   71:         B = np.char.array(['\u03a3'])
   72:         assert_(issubclass((A + B).dtype.type, np.str_))
   73: 
   74:     def test_from_string(self):
   75:         A = np.char.array(b'abc')
   76:         assert_equal(len(A), 1)
   77:         assert_equal(len(A[0]), 3)
   78:         assert_(issubclass(A.dtype.type, np.bytes_))
   79: 
   80:     def test_from_unicode(self):
   81:         A = np.char.array('\u03a3')
   82:         assert_equal(len(A), 1)
   83:         assert_equal(len(A[0]), 1)
   84:         assert_equal(A.itemsize, 4)
   85:         assert_(issubclass(A.dtype.type, np.str_))
   86: 
   87: class TestVecString:
   88:     def test_non_existent_method(self):
   89: 
   90:         def fail():
   91:             _vec_string('a', np.bytes_, 'bogus')
   92: 
   93:         assert_raises(AttributeError, fail)
   94: 
   95:     def test_non_string_array(self):
   96: 
   97:         def fail():
   98:             _vec_string(1, np.bytes_, 'strip')
   99: 
  100:         assert_raises(TypeError, fail)
  101: 
  102:     def test_invalid_args_tuple(self):
  103: 
  104:         def fail():
  105:             _vec_string(['a'], np.bytes_, 'strip', 1)
  106: 
  107:         assert_raises(TypeError, fail)
  108: 
  109:     def test_invalid_type_descr(self):
  110: 
  111:         def fail():
  112:             _vec_string(['a'], 'BOGUS', 'strip')
  113: 
  114:         assert_raises(TypeError, fail)
  115: 
  116:     def test_invalid_function_args(self):
  117: 
  118:         def fail():
  119:             _vec_string(['a'], np.bytes_, 'strip', (1,))
  120: 
  121:         assert_raises(TypeError, fail)
  122: 
  123:     def test_invalid_result_type(self):
  124: 
  125:         def fail():
  126:             _vec_string(['a'], np.int_, 'strip')
  127: 
  128:         assert_raises(TypeError, fail)
  129: 
  130:     def test_broadcast_error(self):
  131: 
  132:         def fail():
  133:             _vec_string([['abc', 'def']], np.int_, 'find', (['a', 'd', 'j'],))
  134: 
  135:         assert_raises(ValueError, fail)
  136: 
  137: 
  138: class TestWhitespace:
  139:     def setup_method(self):
  140:         self.A = np.array([['abc ', '123  '],
  141:                            ['789 ', 'xyz ']]).view(np.char.chararray)
  142:         self.B = np.array([['abc', '123'],
  143:                            ['789', 'xyz']]).view(np.char.chararray)
  144: 
  145:     def test1(self):
  146:         assert_(np.all(self.A == self.B))
  147:         assert_(np.all(self.A >= self.B))
  148:         assert_(np.all(self.A <= self.B))
  149:         assert_(not np.any(self.A > self.B))
  150:         assert_(not np.any(self.A < self.B))
  151:         assert_(not np.any(self.A != self.B))
  152: 
  153: class TestChar:
  154:     def setup_method(self):
  155:         self.A = np.array('abc1', dtype='c').view(np.char.chararray)
  156: 
  157:     def test_it(self):
  158:         assert_equal(self.A.shape, (4,))
  159:         assert_equal(self.A.upper()[:2].tobytes(), b'AB')
  160: 
  161: class TestComparisons:
  162:     def setup_method(self):
  163:         self.A = np.array([['abc', 'abcc', '123'],
  164:                            ['789', 'abc', 'xyz']]).view(np.char.chararray)
  165:         self.B = np.array([['efg', 'efg', '123  '],
  166:                            ['051', 'efgg', 'tuv']]).view(np.char.chararray)
  167: 
  168:     def test_not_equal(self):
  169:         assert_array_equal((self.A != self.B),
  170:                            [[True, True, False], [True, True, True]])
  171: 
  172:     def test_equal(self):
  173:         assert_array_equal((self.A == self.B),
  174:                            [[False, False, True], [False, False, False]])
  175: 
  176:     def test_greater_equal(self):
  177:         assert_array_equal((self.A >= self.B),
  178:                            [[False, False, True], [True, False, True]])
  179: 
  180:     def test_less_equal(self):
  181:         assert_array_equal((self.A <= self.B),
  182:                            [[True, True, True], [False, True, False]])
  183: 
  184:     def test_greater(self):
  185:         assert_array_equal((self.A > self.B),
  186:                            [[False, False, False], [True, False, True]])
  187: 
  188:     def test_less(self):
  189:         assert_array_equal((self.A < self.B),
  190:                            [[True, True, False], [False, True, False]])
  191: 
  192:     def test_type(self):
  193:         out1 = np.char.equal(self.A, self.B)
  194:         out2 = np.char.equal('a', 'a')
  195:         assert_(isinstance(out1, np.ndarray))
  196:         assert_(isinstance(out2, np.ndarray))
  197: 
  198: class TestComparisonsMixed1(TestComparisons):
  199:     """Ticket #1276"""
  200: 
  201:     def setup_method(self):
  202:         TestComparisons.setup_method(self)
  203:         self.B = np.array(
  204:             [['efg', 'efg', '123  '],
  205:              ['051', 'efgg', 'tuv']], np.str_).view(np.char.chararray)
  206: 
  207: class TestComparisonsMixed2(TestComparisons):
  208:     """Ticket #1276"""
  209: 
  210:     def setup_method(self):
  211:         TestComparisons.setup_method(self)
  212:         self.A = np.array(
  213:             [['abc', 'abcc', '123'],
  214:              ['789', 'abc', 'xyz']], np.str_).view(np.char.chararray)
  215: 
  216: class TestInformation:
  217:     def setup_method(self):
  218:         self.A = np.array([[' abc ', ''],
  219:                            ['12345', 'MixedCase'],
  220:                            ['123 \t 345 \0 ', 'UPPER']]) \
  221:                             .view(np.char.chararray)
  222:         self.B = np.array([[' \u03a3 ', ''],
  223:                            ['12345', 'MixedCase'],
  224:                            ['123 \t 345 \0 ', 'UPPER']]) \
  225:                             .view(np.char.chararray)
  226:         # Array with longer strings, > MEMCHR_CUT_OFF in code.
  227:         self.C = (np.array(['ABCDEFGHIJKLMNOPQRSTUVWXYZ',
  228:                             '01234567890123456789012345'])
  229:                   .view(np.char.chararray))
  230: 
  231:     def test_len(self):
  232:         assert_(issubclass(np.char.str_len(self.A).dtype.type, np.integer))
  233:         assert_array_equal(np.char.str_len(self.A), [[5, 0], [5, 9], [12, 5]])
  234:         assert_array_equal(np.char.str_len(self.B), [[3, 0], [5, 9], [12, 5]])
  235: 
  236:     def test_count(self):
  237:         assert_(issubclass(self.A.count('').dtype.type, np.integer))
  238:         assert_array_equal(self.A.count('a'), [[1, 0], [0, 1], [0, 0]])
  239:         assert_array_equal(self.A.count('123'), [[0, 0], [1, 0], [1, 0]])
  240:         # Python doesn't seem to like counting NULL characters
  241:         # assert_array_equal(self.A.count('\0'), [[0, 0], [0, 0], [1, 0]])
  242:         assert_array_equal(self.A.count('a', 0, 2), [[1, 0], [0, 0], [0, 0]])
  243:         assert_array_equal(self.B.count('a'), [[0, 0], [0, 1], [0, 0]])
  244:         assert_array_equal(self.B.count('123'), [[0, 0], [1, 0], [1, 0]])
  245:         # assert_array_equal(self.B.count('\0'), [[0, 0], [0, 0], [1, 0]])
  246: 
  247:     def test_endswith(self):
  248:         assert_(issubclass(self.A.endswith('').dtype.type, np.bool))
  249:         assert_array_equal(self.A.endswith(' '), [[1, 0], [0, 0], [1, 0]])
  250:         assert_array_equal(self.A.endswith('3', 0, 3), [[0, 0], [1, 0], [1, 0]])
  251: 
  252:         def fail():
  253:             self.A.endswith('3', 'fdjk')
  254: 
  255:         assert_raises(TypeError, fail)
  256: 
  257:     @pytest.mark.parametrize(
  258:         "dtype, encode",
  259:         [("U", str),
  260:          ("S", lambda x: x.encode('ascii')),
  261:          ])
  262:     def test_find(self, dtype, encode):
  263:         A = self.A.astype(dtype)
  264:         assert_(issubclass(A.find(encode('a')).dtype.type, np.integer))
  265:         assert_array_equal(A.find(encode('a')),
  266:                            [[1, -1], [-1, 6], [-1, -1]])
  267:         assert_array_equal(A.find(encode('3')),
  268:                            [[-1, -1], [2, -1], [2, -1]])
  269:         assert_array_equal(A.find(encode('a'), 0, 2),
  270:                            [[1, -1], [-1, -1], [-1, -1]])
  271:         assert_array_equal(A.find([encode('1'), encode('P')]),
  272:                            [[-1, -1], [0, -1], [0, 1]])
  273:         C = self.C.astype(dtype)
  274:         assert_array_equal(C.find(encode('M')), [12, -1])
  275: 
  276:     def test_index(self):
  277: 
  278:         def fail():
  279:             self.A.index('a')
  280: 
  281:         assert_raises(ValueError, fail)
  282:         assert_(np.char.index('abcba', 'b') == 1)
  283:         assert_(issubclass(np.char.index('abcba', 'b').dtype.type, np.integer))
  284: 
  285:     def test_isalnum(self):
  286:         assert_(issubclass(self.A.isalnum().dtype.type, np.bool))
  287:         assert_array_equal(self.A.isalnum(), [[False, False], [True, True], [False, True]])
  288: 
  289:     def test_isalpha(self):
  290:         assert_(issubclass(self.A.isalpha().dtype.type, np.bool))
  291:         assert_array_equal(self.A.isalpha(), [[False, False], [False, True], [False, True]])
  292: 
  293:     def test_isdigit(self):
  294:         assert_(issubclass(self.A.isdigit().dtype.type, np.bool))
  295:         assert_array_equal(self.A.isdigit(), [[False, False], [True, False], [False, False]])
  296: 
  297:     def test_islower(self):
  298:         assert_(issubclass(self.A.islower().dtype.type, np.bool))
  299:         assert_array_equal(self.A.islower(), [[True, False], [False, False], [False, False]])
  300: 
  301:     def test_isspace(self):
  302:         assert_(issubclass(self.A.isspace().dtype.type, np.bool))
  303:         assert_array_equal(self.A.isspace(), [[False, False], [False, False], [False, False]])
  304: 
  305:     def test_istitle(self):
  306:         assert_(issubclass(self.A.istitle().dtype.type, np.bool))
  307:         assert_array_equal(self.A.istitle(), [[False, False], [False, False], [False, False]])
  308: 
  309:     def test_isupper(self):
  310:         assert_(issubclass(self.A.isupper().dtype.type, np.bool))
  311:         assert_array_equal(self.A.isupper(), [[False, False], [False, False], [False, True]])
  312: 
  313:     def test_rfind(self):
  314:         assert_(issubclass(self.A.rfind('a').dtype.type, np.integer))
  315:         assert_array_equal(self.A.rfind('a'), [[1, -1], [-1, 6], [-1, -1]])
  316:         assert_array_equal(self.A.rfind('3'), [[-1, -1], [2, -1], [6, -1]])
  317:         assert_array_equal(self.A.rfind('a', 0, 2), [[1, -1], [-1, -1], [-1, -1]])
  318:         assert_array_equal(self.A.rfind(['1', 'P']), [[-1, -1], [0, -1], [0, 2]])
  319: 
  320:     def test_rindex(self):
  321: 
  322:         def fail():
  323:             self.A.rindex('a')
  324: 
  325:         assert_raises(ValueError, fail)
  326:         assert_(np.char.rindex('abcba', 'b') == 3)
  327:         assert_(issubclass(np.char.rindex('abcba', 'b').dtype.type, np.integer))
  328: 
  329:     def test_startswith(self):
  330:         assert_(issubclass(self.A.startswith('').dtype.type, np.bool))
  331:         assert_array_equal(self.A.startswith(' '), [[1, 0], [0, 0], [0, 0]])
  332:         assert_array_equal(self.A.startswith('1', 0, 3), [[0, 0], [1, 0], [1, 0]])
  333: 
  334:         def fail():
  335:             self.A.startswith('3', 'fdjk')
  336: 
  337:         assert_raises(TypeError, fail)
  338: 
  339: 
  340: class TestMethods:
  341:     def setup_method(self):
  342:         self.A = np.array([[' abc ', ''],
  343:                            ['12345', 'MixedCase'],
  344:                            ['123 \t 345 \0 ', 'UPPER']],
  345:                           dtype='S').view(np.char.chararray)
  346:         self.B = np.array([[' \u03a3 ', ''],
  347:                            ['12345', 'MixedCase'],
  348:                            ['123 \t 345 \0 ', 'UPPER']]).view(
  349:                                                             np.char.chararray)
  350: 
  351:     def test_capitalize(self):
  352:         tgt = [[b' abc ', b''],
  353:                [b'12345', b'Mixedcase'],
  354:                [b'123 \t 345 \0 ', b'Upper']]
  355:         assert_(issubclass(self.A.capitalize().dtype.type, np.bytes_))
  356:         assert_array_equal(self.A.capitalize(), tgt)
  357: 
  358:         tgt = [[' \u03c3 ', ''],
  359:                ['12345', 'Mixedcase'],
  360:                ['123 \t 345 \0 ', 'Upper']]
  361:         assert_(issubclass(self.B.capitalize().dtype.type, np.str_))
  362:         assert_array_equal(self.B.capitalize(), tgt)
  363: 
  364:     def test_center(self):
  365:         assert_(issubclass(self.A.center(10).dtype.type, np.bytes_))
  366:         C = self.A.center([10, 20])
  367:         assert_array_equal(np.char.str_len(C), [[10, 20], [10, 20], [12, 20]])
  368: 
  369:         C = self.A.center(20, b'#')
  370:         assert_(np.all(C.startswith(b'#')))
  371:         assert_(np.all(C.endswith(b'#')))
  372: 
  373:         C = np.char.center(b'FOO', [[10, 20], [15, 8]])
  374:         tgt = [[b'   FOO    ', b'        FOO         '],
  375:                [b'      FOO      ', b'  FOO   ']]
  376:         assert_(issubclass(C.dtype.type, np.bytes_))
  377:         assert_array_equal(C, tgt)
  378: 
  379:     def test_decode(self):
  380:         A = np.char.array([b'\\u03a3'])
  381:         assert_(A.decode('unicode-escape')[0] == '\u03a3')
  382: 
  383:     def test_encode(self):
  384:         B = self.B.encode('unicode_escape')
  385:         assert_(B[0][0] == ' \\u03a3 '.encode('latin1'))
  386: 
  387:     def test_expandtabs(self):
  388:         T = self.A.expandtabs()
  389:         assert_(T[2, 0] == b'123      345 \0')
  390: 
  391:     def test_join(self):
  392:         # NOTE: list(b'123') == [49, 50, 51]
  393:         #       so that b','.join(b'123') results to an error on Py3
  394:         A0 = self.A.decode('ascii')
  395: 
  396:         A = np.char.join([',', '#'], A0)
  397:         assert_(issubclass(A.dtype.type, np.str_))
  398:         tgt = np.array([[' ,a,b,c, ', ''],
  399:                         ['1,2,3,4,5', 'M#i#x#e#d#C#a#s#e'],
  400:                         ['1,2,3, ,\t, ,3,4,5, ,\x00, ', 'U#P#P#E#R']])
  401:         assert_array_equal(np.char.join([',', '#'], A0), tgt)
  402: 
  403:     def test_ljust(self):
  404:         assert_(issubclass(self.A.ljust(10).dtype.type, np.bytes_))
  405: 
  406:         C = self.A.ljust([10, 20])
  407:         assert_array_equal(np.char.str_len(C), [[10, 20], [10, 20], [12, 20]])
  408: 
  409:         C = self.A.ljust(20, b'#')
  410:         assert_array_equal(C.startswith(b'#'), [
  411:                 [False, True], [False, False], [False, False]])
  412:         assert_(np.all(C.endswith(b'#')))
  413: 
  414:         C = np.char.ljust(b'FOO', [[10, 20], [15, 8]])
  415:         tgt = [[b'FOO       ', b'FOO                 '],
  416:                [b'FOO            ', b'FOO     ']]
  417:         assert_(issubclass(C.dtype.type, np.bytes_))
  418:         assert_array_equal(C, tgt)
  419: 
  420:     def test_lower(self):
  421:         tgt = [[b' abc ', b''],
  422:                [b'12345', b'mixedcase'],
  423:                [b'123 \t 345 \0 ', b'upper']]
  424:         assert_(issubclass(self.A.lower().dtype.type, np.bytes_))
  425:         assert_array_equal(self.A.lower(), tgt)
  426: 
  427:         tgt = [[' \u03c3 ', ''],
  428:                ['12345', 'mixedcase'],
  429:                ['123 \t 345 \0 ', 'upper']]
  430:         assert_(issubclass(self.B.lower().dtype.type, np.str_))
  431:         assert_array_equal(self.B.lower(), tgt)
  432: 
  433:     def test_lstrip(self):
  434:         tgt = [[b'abc ', b''],
  435:                [b'12345', b'MixedCase'],
  436:                [b'123 \t 345 \0 ', b'UPPER']]
  437:         assert_(issubclass(self.A.lstrip().dtype.type, np.bytes_))
  438:         assert_array_equal(self.A.lstrip(), tgt)
  439: 
  440:         tgt = [[b' abc', b''],
  441:                [b'2345', b'ixedCase'],
  442:                [b'23 \t 345 \x00', b'UPPER']]
  443:         assert_array_equal(self.A.lstrip([b'1', b'M']), tgt)
  444: 
  445:         tgt = [['\u03a3 ', ''],
  446:                ['12345', 'MixedCase'],
  447:                ['123 \t 345 \0 ', 'UPPER']]
  448:         assert_(issubclass(self.B.lstrip().dtype.type, np.str_))
  449:         assert_array_equal(self.B.lstrip(), tgt)
  450: 
  451:     def test_partition(self):
  452:         P = self.A.partition([b'3', b'M'])
  453:         tgt = [[(b' abc ', b'', b''), (b'', b'', b'')],
  454:                [(b'12', b'3', b'45'), (b'', b'M', b'ixedCase')],
  455:                [(b'12', b'3', b' \t 345 \0 '), (b'UPPER', b'', b'')]]
  456:         assert_(issubclass(P.dtype.type, np.bytes_))
  457:         assert_array_equal(P, tgt)
  458: 
  459:     def test_replace(self):
  460:         R = self.A.replace([b'3', b'a'],
  461:                            [b'##########', b'@'])
  462:         tgt = [[b' abc ', b''],
  463:                [b'12##########45', b'MixedC@se'],
  464:                [b'12########## \t ##########45 \x00 ', b'UPPER']]
  465:         assert_(issubclass(R.dtype.type, np.bytes_))
  466:         assert_array_equal(R, tgt)
  467:         # Test special cases that should just return the input array,
  468:         # since replacements are not possible or do nothing.
  469:         S1 = self.A.replace(b'A very long byte string, longer than A', b'')
  470:         assert_array_equal(S1, self.A)
  471:         S2 = self.A.replace(b'', b'')
  472:         assert_array_equal(S2, self.A)
  473:         S3 = self.A.replace(b'3', b'3')
  474:         assert_array_equal(S3, self.A)
  475:         S4 = self.A.replace(b'3', b'', count=0)
  476:         assert_array_equal(S4, self.A)
  477: 
  478:     def test_replace_count_and_size(self):
  479:         a = np.array(['0123456789' * i for i in range(4)]
  480:                      ).view(np.char.chararray)
  481:         r1 = a.replace('5', 'ABCDE')
  482:         assert r1.dtype.itemsize == (3 * 10 + 3 * 4) * 4
  483:         assert_array_equal(r1, np.array(['01234ABCDE6789' * i
  484:                                          for i in range(4)]))
  485:         r2 = a.replace('5', 'ABCDE', count=1)
  486:         assert r2.dtype.itemsize == (3 * 10 + 4) * 4
  487:         r3 = a.replace('5', 'ABCDE', count=0)
  488:         assert r3.dtype.itemsize == a.dtype.itemsize
  489:         assert_array_equal(r3, a)
  490:         # Negative values mean to replace all.
  491:         r4 = a.replace('5', 'ABCDE', count=-1)
  492:         assert r4.dtype.itemsize == (3 * 10 + 3 * 4) * 4
  493:         assert_array_equal(r4, r1)
  494:         # We can do count on an element-by-element basis.
  495:         r5 = a.replace('5', 'ABCDE', count=[-1, -1, -1, 1])
  496:         assert r5.dtype.itemsize == (3 * 10 + 4) * 4
  497:         assert_array_equal(r5, np.array(
  498:             ['01234ABCDE6789' * i for i in range(3)]
  499:             + ['01234ABCDE6789' + '0123456789' * 2]))
  500: 
  501:     def test_replace_broadcasting(self):
  502:         a = np.array('0,0,0').view(np.char.chararray)
  503:         r1 = a.replace('0', '1', count=np.arange(3))
  504:         assert r1.dtype == a.dtype
  505:         assert_array_equal(r1, np.array(['0,0,0', '1,0,0', '1,1,0']))
  506:         r2 = a.replace('0', [['1'], ['2']], count=np.arange(1, 4))
  507:         assert_array_equal(r2, np.array([['1,0,0', '1,1,0', '1,1,1'],
  508:                                          ['2,0,0', '2,2,0', '2,2,2']]))
  509:         r3 = a.replace(['0', '0,0', '0,0,0'], 'X')
  510:         assert_array_equal(r3, np.array(['X,X,X', 'X,0', 'X']))
  511: 
  512:     def test_rjust(self):
  513:         assert_(issubclass(self.A.rjust(10).dtype.type, np.bytes_))
  514: 
  515:         C = self.A.rjust([10, 20])
  516:         assert_array_equal(np.char.str_len(C), [[10, 20], [10, 20], [12, 20]])
  517: 
  518:         C = self.A.rjust(20, b'#')
  519:         assert_(np.all(C.startswith(b'#')))
  520:         assert_array_equal(C.endswith(b'#'),
  521:                            [[False, True], [False, False], [False, False]])
  522: 
  523:         C = np.char.rjust(b'FOO', [[10, 20], [15, 8]])
  524:         tgt = [[b'       FOO', b'                 FOO'],
  525:                [b'            FOO', b'     FOO']]
  526:         assert_(issubclass(C.dtype.type, np.bytes_))
  527:         assert_array_equal(C, tgt)
  528: 
  529:     def test_rpartition(self):
  530:         P = self.A.rpartition([b'3', b'M'])
  531:         tgt = [[(b'', b'', b' abc '), (b'', b'', b'')],
  532:                [(b'12', b'3', b'45'), (b'', b'M', b'ixedCase')],
  533:                [(b'123 \t ', b'3', b'45 \0 '), (b'', b'', b'UPPER')]]
  534:         assert_(issubclass(P.dtype.type, np.bytes_))
  535:         assert_array_equal(P, tgt)
  536: 
  537:     def test_rsplit(self):
  538:         A = self.A.rsplit(b'3')
  539:         tgt = [[[b' abc '], [b'']],
  540:                [[b'12', b'45'], [b'MixedCase']],
  541:                [[b'12', b' \t ', b'45 \x00 '], [b'UPPER']]]
  542:         assert_(issubclass(A.dtype.type, np.object_))
  543:         assert_equal(A.tolist(), tgt)
  544: 
  545:     def test_rstrip(self):
  546:         assert_(issubclass(self.A.rstrip().dtype.type, np.bytes_))
  547: 
  548:         tgt = [[b' abc', b''],
  549:                [b'12345', b'MixedCase'],
  550:                [b'123 \t 345', b'UPPER']]
  551:         assert_array_equal(self.A.rstrip(), tgt)
  552: 
  553:         tgt = [[b' abc ', b''],
  554:                [b'1234', b'MixedCase'],
  555:                [b'123 \t 345 \x00', b'UPP']
  556:                ]
  557:         assert_array_equal(self.A.rstrip([b'5', b'ER']), tgt)
  558: 
  559:         tgt = [[' \u03a3', ''],
  560:                ['12345', 'MixedCase'],
  561:                ['123 \t 345', 'UPPER']]
  562:         assert_(issubclass(self.B.rstrip().dtype.type, np.str_))
  563:         assert_array_equal(self.B.rstrip(), tgt)
  564: 
  565:     def test_strip(self):
  566:         tgt = [[b'abc', b''],
  567:                [b'12345', b'MixedCase'],
  568:                [b'123 \t 345', b'UPPER']]
  569:         assert_(issubclass(self.A.strip().dtype.type, np.bytes_))
  570:         assert_array_equal(self.A.strip(), tgt)
  571: 
  572:         tgt = [[b' abc ', b''],
  573:                [b'234', b'ixedCas'],
  574:                [b'23 \t 345 \x00', b'UPP']]
  575:         assert_array_equal(self.A.strip([b'15', b'EReM']), tgt)
  576: 
  577:         tgt = [['\u03a3', ''],
  578:                ['12345', 'MixedCase'],
  579:                ['123 \t 345', 'UPPER']]
  580:         assert_(issubclass(self.B.strip().dtype.type, np.str_))
  581:         assert_array_equal(self.B.strip(), tgt)
  582: 
  583:     def test_split(self):
  584:         A = self.A.split(b'3')
  585:         tgt = [
  586:                [[b' abc '], [b'']],
  587:                [[b'12', b'45'], [b'MixedCase']],
  588:                [[b'12', b' \t ', b'45 \x00 '], [b'UPPER']]]
  589:         assert_(issubclass(A.dtype.type, np.object_))
  590:         assert_equal(A.tolist(), tgt)
  591: 
  592:     def test_splitlines(self):
  593:         A = np.char.array(['abc\nfds\nwer']).splitlines()
  594:         assert_(issubclass(A.dtype.type, np.object_))
  595:         assert_(A.shape == (1,))
  596:         assert_(len(A[0]) == 3)
  597: 
  598:     def test_swapcase(self):
  599:         tgt = [[b' ABC ', b''],
  600:                [b'12345', b'mIXEDcASE'],
  601:                [b'123 \t 345 \0 ', b'upper']]
  602:         assert_(issubclass(self.A.swapcase().dtype.type, np.bytes_))
  603:         assert_array_equal(self.A.swapcase(), tgt)
  604: 
  605:         tgt = [[' \u03c3 ', ''],
  606:                ['12345', 'mIXEDcASE'],
  607:                ['123 \t 345 \0 ', 'upper']]
  608:         assert_(issubclass(self.B.swapcase().dtype.type, np.str_))
  609:         assert_array_equal(self.B.swapcase(), tgt)
  610: 
  611:     def test_title(self):
  612:         tgt = [[b' Abc ', b''],
  613:                [b'12345', b'Mixedcase'],
  614:                [b'123 \t 345 \0 ', b'Upper']]
  615:         assert_(issubclass(self.A.title().dtype.type, np.bytes_))
  616:         assert_array_equal(self.A.title(), tgt)
  617: 
  618:         tgt = [[' \u03a3 ', ''],
  619:                ['12345', 'Mixedcase'],
  620:                ['123 \t 345 \0 ', 'Upper']]
  621:         assert_(issubclass(self.B.title().dtype.type, np.str_))
  622:         assert_array_equal(self.B.title(), tgt)
  623: 
  624:     def test_upper(self):
  625:         tgt = [[b' ABC ', b''],
  626:                [b'12345', b'MIXEDCASE'],
  627:                [b'123 \t 345 \0 ', b'UPPER']]
  628:         assert_(issubclass(self.A.upper().dtype.type, np.bytes_))
  629:         assert_array_equal(self.A.upper(), tgt)
  630: 
  631:         tgt = [[' \u03a3 ', ''],
  632:                ['12345', 'MIXEDCASE'],
  633:                ['123 \t 345 \0 ', 'UPPER']]
  634:         assert_(issubclass(self.B.upper().dtype.type, np.str_))
  635:         assert_array_equal(self.B.upper(), tgt)
  636: 
  637:     def test_isnumeric(self):
  638: 
  639:         def fail():
  640:             self.A.isnumeric()
  641: 
  642:         assert_raises(TypeError, fail)
  643:         assert_(issubclass(self.B.isnumeric().dtype.type, np.bool))
  644:         assert_array_equal(self.B.isnumeric(), [
  645:                 [False, False], [True, False], [False, False]])
  646: 
  647:     def test_isdecimal(self):
  648: 
  649:         def fail():
  650:             self.A.isdecimal()
  651: 
  652:         assert_raises(TypeError, fail)
  653:         assert_(issubclass(self.B.isdecimal().dtype.type, np.bool))
  654:         assert_array_equal(self.B.isdecimal(), [
  655:                 [False, False], [True, False], [False, False]])
  656: 
  657: 
  658: class TestOperations:
  659:     def setup_method(self):
  660:         self.A = np.array([['abc', '123'],
  661:                            ['789', 'xyz']]).view(np.char.chararray)
  662:         self.B = np.array([['efg', '456'],
  663:                            ['051', 'tuv']]).view(np.char.chararray)
  664: 
  665:     def test_add(self):
  666:         AB = np.array([['abcefg', '123456'],
  667:                        ['789051', 'xyztuv']]).view(np.char.chararray)
  668:         assert_array_equal(AB, (self.A + self.B))
  669:         assert_(len((self.A + self.B)[0][0]) == 6)
  670: 
  671:     def test_radd(self):
  672:         QA = np.array([['qabc', 'q123'],
  673:                        ['q789', 'qxyz']]).view(np.char.chararray)
  674:         assert_array_equal(QA, ('q' + self.A))
  675: 
  676:     def test_mul(self):
  677:         A = self.A
  678:         for r in (2, 3, 5, 7, 197):
  679:             Ar = np.array([[A[0, 0] * r, A[0, 1] * r],
  680:                            [A[1, 0] * r, A[1, 1] * r]]).view(np.char.chararray)
  681: 
  682:             assert_array_equal(Ar, (self.A * r))
  683: 
  684:         for ob in [object(), 'qrs']:
  685:             with assert_raises_regex(ValueError,
  686:                                      'Can only multiply by integers'):
  687:                 A * ob
  688: 
  689:     def test_rmul(self):
  690:         A = self.A
  691:         for r in (2, 3, 5, 7, 197):
  692:             Ar = np.array([[A[0, 0] * r, A[0, 1] * r],
  693:                            [A[1, 0] * r, A[1, 1] * r]]).view(np.char.chararray)
  694:             assert_array_equal(Ar, (r * self.A))
  695: 
  696:         for ob in [object(), 'qrs']:
  697:             with assert_raises_regex(ValueError,
  698:                                      'Can only multiply by integers'):
  699:                 ob * A
  700: 
  701:     def test_mod(self):
  702:         """Ticket #856"""
  703:         F = np.array([['%d', '%f'], ['%s', '%r']]).view(np.char.chararray)
  704:         C = np.array([[3, 7], [19, 1]], dtype=np.int64)
  705:         FC = np.array([['3', '7.000000'],
  706:                        ['19', 'np.int64(1)']]).view(np.char.chararray)
  707:         assert_array_equal(FC, F % C)
  708: 
  709:         A = np.array([['%.3f', '%d'], ['%s', '%r']]).view(np.char.chararray)
  710:         A1 = np.array([['1.000', '1'],
  711:                        ['1', repr(np.array(1)[()])]]).view(np.char.chararray)
  712:         assert_array_equal(A1, (A % 1))
  713: 
  714:         A2 = np.array([['1.000', '2'],
  715:                        ['3', repr(np.array(4)[()])]]).view(np.char.chararray)
  716:         assert_array_equal(A2, (A % [[1, 2], [3, 4]]))
  717: 
  718:     def test_rmod(self):
  719:         assert_(f"{self.A}" == str(self.A))
  720:         assert_(f"{self.A!r}" == repr(self.A))
  721: 
  722:         for ob in [42, object()]:
  723:             with assert_raises_regex(
  724:                     TypeError, "unsupported operand type.* and 'chararray'"):
  725:                 ob % self.A
  726: 
  727:     def test_slice(self):
  728:         """Regression test for https://github.com/numpy/numpy/issues/5982"""
  729: 
  730:         arr = np.array([['abc ', 'def '], ['geh ', 'ijk ']],
  731:                        dtype='S4').view(np.char.chararray)
  732:         sl1 = arr[:]
  733:         assert_array_equal(sl1, arr)
  734:         assert_(sl1.base is arr)
  735:         assert_(sl1.base.base is arr.base)
  736: 
  737:         sl2 = arr[:, :]
  738:         assert_array_equal(sl2, arr)
  739:         assert_(sl2.base is arr)
  740:         assert_(sl2.base.base is arr.base)
  741: 
  742:         assert_(arr[0, 0] == b'abc')
  743: 
  744:     @pytest.mark.parametrize('data', [['plate', '   ', 'shrimp'],
  745:                                       [b'retro', b'  ', b'encabulator']])
  746:     def test_getitem_length_zero_item(self, data):
  747:         # Regression test for gh-26375.
  748:         a = np.char.array(data)
  749:         # a.dtype.type() will be an empty string or bytes instance.
  750:         # The equality test will fail if a[1] has the wrong type
  751:         # or does not have length 0.
  752:         assert_equal(a[1], a.dtype.type())
  753: 
  754: 
  755: class TestMethodsEmptyArray:
  756:     def setup_method(self):
  757:         self.U = np.array([], dtype='U')
  758:         self.S = np.array([], dtype='S')
  759: 
  760:     def test_encode(self):
  761:         res = np.char.encode(self.U)
  762:         assert_array_equal(res, [])
  763:         assert_(res.dtype.char == 'S')
  764: 
  765:     def test_decode(self):
  766:         res = np.char.decode(self.S)
  767:         assert_array_equal(res, [])
  768:         assert_(res.dtype.char == 'U')
  769: 
  770:     def test_decode_with_reshape(self):
  771:         res = np.char.decode(self.S.reshape((1, 0, 1)))
  772:         assert_(res.shape == (1, 0, 1))
  773: 
  774: 
  775: class TestMethodsScalarValues:
  776:     def test_mod(self):
  777:         A = np.array([[' abc ', ''],
  778:                       ['12345', 'MixedCase'],
  779:                       ['123 \t 345 \0 ', 'UPPER']], dtype='S')
  780:         tgt = [[b'123 abc ', b'123'],
  781:                [b'12312345', b'123MixedCase'],
  782:                [b'123123 \t 345 \0 ', b'123UPPER']]
  783:         assert_array_equal(np.char.mod(b"123%s", A), tgt)
  784: 
  785:     def test_decode(self):
  786:         bytestring = b'\x81\xc1\x81\xc1\x81\xc1'
  787:         assert_equal(np.char.decode(bytestring, encoding='cp037'),
  788:                      'aAaAaA')
  789: 
  790:     def test_encode(self):
  791:         unicode = 'aAaAaA'
  792:         assert_equal(np.char.encode(unicode, encoding='cp037'),
  793:                      b'\x81\xc1\x81\xc1\x81\xc1')
  794: 
  795:     def test_expandtabs(self):
  796:         s = "\tone level of indentation\n\t\ttwo levels of indentation"
  797:         assert_equal(
  798:             np.char.expandtabs(s, tabsize=2),
  799:             "  one level of indentation\n    two levels of indentation"
  800:         )
  801: 
  802:     def test_join(self):
  803:         seps = np.array(['-', '_'])
  804:         assert_array_equal(np.char.join(seps, 'hello'),
  805:                            ['h-e-l-l-o', 'h_e_l_l_o'])
  806: 
  807:     def test_partition(self):
  808:         assert_equal(np.char.partition('This string', ' '),
  809:                      ['This', ' ', 'string'])
  810: 
  811:     def test_rpartition(self):
  812:         assert_equal(np.char.rpartition('This string here', ' '),
  813:                      ['This string', ' ', 'here'])
  814: 
  815:     def test_replace(self):
  816:         assert_equal(np.char.replace('Python is good', 'good', 'great'),
  817:                      'Python is great')
  818: 
  819: 
  820: def test_empty_indexing():
  821:     """Regression test for ticket 1948."""
  822:     # Check that indexing a chararray with an empty list/array returns an
  823:     # empty chararray instead of a chararray with a single empty string in it.
  824:     s = np.char.chararray((4,))
  825:     assert_(s[[]].size == 0)
