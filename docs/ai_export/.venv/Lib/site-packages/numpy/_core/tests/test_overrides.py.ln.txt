    1: import inspect
    2: import os
    3: import pickle
    4: import sys
    5: import tempfile
    6: from io import StringIO
    7: from unittest import mock
    8: 
    9: import pytest
   10: 
   11: import numpy as np
   12: from numpy._core.overrides import (
   13:     _get_implementing_args,
   14:     array_function_dispatch,
   15:     verify_matching_signatures,
   16: )
   17: from numpy.testing import assert_, assert_equal, assert_raises, assert_raises_regex
   18: from numpy.testing.overrides import get_overridable_numpy_array_functions
   19: 
   20: 
   21: def _return_not_implemented(self, *args, **kwargs):
   22:     return NotImplemented
   23: 
   24: 
   25: # need to define this at the top level to test pickling
   26: @array_function_dispatch(lambda array: (array,))
   27: def dispatched_one_arg(array):
   28:     """Docstring."""
   29:     return 'original'
   30: 
   31: 
   32: @array_function_dispatch(lambda array1, array2: (array1, array2))
   33: def dispatched_two_arg(array1, array2):
   34:     """Docstring."""
   35:     return 'original'
   36: 
   37: 
   38: class TestGetImplementingArgs:
   39: 
   40:     def test_ndarray(self):
   41:         array = np.array(1)
   42: 
   43:         args = _get_implementing_args([array])
   44:         assert_equal(list(args), [array])
   45: 
   46:         args = _get_implementing_args([array, array])
   47:         assert_equal(list(args), [array])
   48: 
   49:         args = _get_implementing_args([array, 1])
   50:         assert_equal(list(args), [array])
   51: 
   52:         args = _get_implementing_args([1, array])
   53:         assert_equal(list(args), [array])
   54: 
   55:     def test_ndarray_subclasses(self):
   56: 
   57:         class OverrideSub(np.ndarray):
   58:             __array_function__ = _return_not_implemented
   59: 
   60:         class NoOverrideSub(np.ndarray):
   61:             pass
   62: 
   63:         array = np.array(1).view(np.ndarray)
   64:         override_sub = np.array(1).view(OverrideSub)
   65:         no_override_sub = np.array(1).view(NoOverrideSub)
   66: 
   67:         args = _get_implementing_args([array, override_sub])
   68:         assert_equal(list(args), [override_sub, array])
   69: 
   70:         args = _get_implementing_args([array, no_override_sub])
   71:         assert_equal(list(args), [no_override_sub, array])
   72: 
   73:         args = _get_implementing_args(
   74:             [override_sub, no_override_sub])
   75:         assert_equal(list(args), [override_sub, no_override_sub])
   76: 
   77:     def test_ndarray_and_duck_array(self):
   78: 
   79:         class Other:
   80:             __array_function__ = _return_not_implemented
   81: 
   82:         array = np.array(1)
   83:         other = Other()
   84: 
   85:         args = _get_implementing_args([other, array])
   86:         assert_equal(list(args), [other, array])
   87: 
   88:         args = _get_implementing_args([array, other])
   89:         assert_equal(list(args), [array, other])
   90: 
   91:     def test_ndarray_subclass_and_duck_array(self):
   92: 
   93:         class OverrideSub(np.ndarray):
   94:             __array_function__ = _return_not_implemented
   95: 
   96:         class Other:
   97:             __array_function__ = _return_not_implemented
   98: 
   99:         array = np.array(1)
  100:         subarray = np.array(1).view(OverrideSub)
  101:         other = Other()
  102: 
  103:         assert_equal(_get_implementing_args([array, subarray, other]),
  104:                      [subarray, array, other])
  105:         assert_equal(_get_implementing_args([array, other, subarray]),
  106:                      [subarray, array, other])
  107: 
  108:     def test_many_duck_arrays(self):
  109: 
  110:         class A:
  111:             __array_function__ = _return_not_implemented
  112: 
  113:         class B(A):
  114:             __array_function__ = _return_not_implemented
  115: 
  116:         class C(A):
  117:             __array_function__ = _return_not_implemented
  118: 
  119:         class D:
  120:             __array_function__ = _return_not_implemented
  121: 
  122:         a = A()
  123:         b = B()
  124:         c = C()
  125:         d = D()
  126: 
  127:         assert_equal(_get_implementing_args([1]), [])
  128:         assert_equal(_get_implementing_args([a]), [a])
  129:         assert_equal(_get_implementing_args([a, 1]), [a])
  130:         assert_equal(_get_implementing_args([a, a, a]), [a])
  131:         assert_equal(_get_implementing_args([a, d, a]), [a, d])
  132:         assert_equal(_get_implementing_args([a, b]), [b, a])
  133:         assert_equal(_get_implementing_args([b, a]), [b, a])
  134:         assert_equal(_get_implementing_args([a, b, c]), [b, c, a])
  135:         assert_equal(_get_implementing_args([a, c, b]), [c, b, a])
  136: 
  137:     def test_too_many_duck_arrays(self):
  138:         namespace = {'__array_function__': _return_not_implemented}
  139:         types = [type('A' + str(i), (object,), namespace) for i in range(65)]
  140:         relevant_args = [t() for t in types]
  141: 
  142:         actual = _get_implementing_args(relevant_args[:64])
  143:         assert_equal(actual, relevant_args[:64])
  144: 
  145:         with assert_raises_regex(TypeError, 'distinct argument types'):
  146:             _get_implementing_args(relevant_args)
  147: 
  148: 
  149: class TestNDArrayArrayFunction:
  150: 
  151:     def test_method(self):
  152: 
  153:         class Other:
  154:             __array_function__ = _return_not_implemented
  155: 
  156:         class NoOverrideSub(np.ndarray):
  157:             pass
  158: 
  159:         class OverrideSub(np.ndarray):
  160:             __array_function__ = _return_not_implemented
  161: 
  162:         array = np.array([1])
  163:         other = Other()
  164:         no_override_sub = array.view(NoOverrideSub)
  165:         override_sub = array.view(OverrideSub)
  166: 
  167:         result = array.__array_function__(func=dispatched_two_arg,
  168:                                           types=(np.ndarray,),
  169:                                           args=(array, 1.), kwargs={})
  170:         assert_equal(result, 'original')
  171: 
  172:         result = array.__array_function__(func=dispatched_two_arg,
  173:                                           types=(np.ndarray, Other),
  174:                                           args=(array, other), kwargs={})
  175:         assert_(result is NotImplemented)
  176: 
  177:         result = array.__array_function__(func=dispatched_two_arg,
  178:                                           types=(np.ndarray, NoOverrideSub),
  179:                                           args=(array, no_override_sub),
  180:                                           kwargs={})
  181:         assert_equal(result, 'original')
  182: 
  183:         result = array.__array_function__(func=dispatched_two_arg,
  184:                                           types=(np.ndarray, OverrideSub),
  185:                                           args=(array, override_sub),
  186:                                           kwargs={})
  187:         assert_equal(result, 'original')
  188: 
  189:         with assert_raises_regex(TypeError, 'no implementation found'):
  190:             np.concatenate((array, other))
  191: 
  192:         expected = np.concatenate((array, array))
  193:         result = np.concatenate((array, no_override_sub))
  194:         assert_equal(result, expected.view(NoOverrideSub))
  195:         result = np.concatenate((array, override_sub))
  196:         assert_equal(result, expected.view(OverrideSub))
  197: 
  198:     def test_no_wrapper(self):
  199:         # Regular numpy functions have wrappers, but do not presume
  200:         # all functions do (array creation ones do not): check that
  201:         # we just call the function in that case.
  202:         array = np.array(1)
  203:         func = lambda x: x * 2
  204:         result = array.__array_function__(func=func, types=(np.ndarray,),
  205:                                           args=(array,), kwargs={})
  206:         assert_equal(result, array * 2)
  207: 
  208:     def test_wrong_arguments(self):
  209:         # Check our implementation guards against wrong arguments.
  210:         a = np.array([1, 2])
  211:         with pytest.raises(TypeError, match="args must be a tuple"):
  212:             a.__array_function__(np.reshape, (np.ndarray,), a, (2, 1))
  213:         with pytest.raises(TypeError, match="kwargs must be a dict"):
  214:             a.__array_function__(np.reshape, (np.ndarray,), (a,), (2, 1))
  215: 
  216: 
  217: class TestArrayFunctionDispatch:
  218: 
  219:     def test_pickle(self):
  220:         for proto in range(2, pickle.HIGHEST_PROTOCOL + 1):
  221:             roundtripped = pickle.loads(
  222:                     pickle.dumps(dispatched_one_arg, protocol=proto))
  223:             assert_(roundtripped is dispatched_one_arg)
  224: 
  225:     def test_name_and_docstring(self):
  226:         assert_equal(dispatched_one_arg.__name__, 'dispatched_one_arg')
  227:         if sys.flags.optimize < 2:
  228:             assert_equal(dispatched_one_arg.__doc__, 'Docstring.')
  229: 
  230:     def test_interface(self):
  231: 
  232:         class MyArray:
  233:             def __array_function__(self, func, types, args, kwargs):
  234:                 return (self, func, types, args, kwargs)
  235: 
  236:         original = MyArray()
  237:         (obj, func, types, args, kwargs) = dispatched_one_arg(original)
  238:         assert_(obj is original)
  239:         assert_(func is dispatched_one_arg)
  240:         assert_equal(set(types), {MyArray})
  241:         # assert_equal uses the overloaded np.iscomplexobj() internally
  242:         assert_(args == (original,))
  243:         assert_equal(kwargs, {})
  244: 
  245:     def test_not_implemented(self):
  246: 
  247:         class MyArray:
  248:             def __array_function__(self, func, types, args, kwargs):
  249:                 return NotImplemented
  250: 
  251:         array = MyArray()
  252:         with assert_raises_regex(TypeError, 'no implementation found'):
  253:             dispatched_one_arg(array)
  254: 
  255:     def test_where_dispatch(self):
  256: 
  257:         class DuckArray:
  258:             def __array_function__(self, ufunc, method, *inputs, **kwargs):
  259:                 return "overridden"
  260: 
  261:         array = np.array(1)
  262:         duck_array = DuckArray()
  263: 
  264:         result = np.std(array, where=duck_array)
  265: 
  266:         assert_equal(result, "overridden")
  267: 
  268: 
  269: class TestVerifyMatchingSignatures:
  270: 
  271:     def test_verify_matching_signatures(self):
  272: 
  273:         verify_matching_signatures(lambda x: 0, lambda x: 0)
  274:         verify_matching_signatures(lambda x=None: 0, lambda x=None: 0)
  275:         verify_matching_signatures(lambda x=1: 0, lambda x=None: 0)
  276: 
  277:         with assert_raises(RuntimeError):
  278:             verify_matching_signatures(lambda a: 0, lambda b: 0)
  279:         with assert_raises(RuntimeError):
  280:             verify_matching_signatures(lambda x: 0, lambda x=None: 0)
  281:         with assert_raises(RuntimeError):
  282:             verify_matching_signatures(lambda x=None: 0, lambda y=None: 0)
  283:         with assert_raises(RuntimeError):
  284:             verify_matching_signatures(lambda x=1: 0, lambda y=1: 0)
  285: 
  286:     def test_array_function_dispatch(self):
  287: 
  288:         with assert_raises(RuntimeError):
  289:             @array_function_dispatch(lambda x: (x,))
  290:             def f(y):
  291:                 pass
  292: 
  293:         # should not raise
  294:         @array_function_dispatch(lambda x: (x,), verify=False)
  295:         def f(y):
  296:             pass
  297: 
  298: 
  299: def _new_duck_type_and_implements():
  300:     """Create a duck array type and implements functions."""
  301:     HANDLED_FUNCTIONS = {}
  302: 
  303:     class MyArray:
  304:         def __array_function__(self, func, types, args, kwargs):
  305:             if func not in HANDLED_FUNCTIONS:
  306:                 return NotImplemented
  307:             if not all(issubclass(t, MyArray) for t in types):
  308:                 return NotImplemented
  309:             return HANDLED_FUNCTIONS[func](*args, **kwargs)
  310: 
  311:     def implements(numpy_function):
  312:         """Register an __array_function__ implementations."""
  313:         def decorator(func):
  314:             HANDLED_FUNCTIONS[numpy_function] = func
  315:             return func
  316:         return decorator
  317: 
  318:     return (MyArray, implements)
  319: 
  320: 
  321: class TestArrayFunctionImplementation:
  322: 
  323:     def test_one_arg(self):
  324:         MyArray, implements = _new_duck_type_and_implements()
  325: 
  326:         @implements(dispatched_one_arg)
  327:         def _(array):
  328:             return 'myarray'
  329: 
  330:         assert_equal(dispatched_one_arg(1), 'original')
  331:         assert_equal(dispatched_one_arg(MyArray()), 'myarray')
  332: 
  333:     def test_optional_args(self):
  334:         MyArray, implements = _new_duck_type_and_implements()
  335: 
  336:         @array_function_dispatch(lambda array, option=None: (array,))
  337:         def func_with_option(array, option='default'):
  338:             return option
  339: 
  340:         @implements(func_with_option)
  341:         def my_array_func_with_option(array, new_option='myarray'):
  342:             return new_option
  343: 
  344:         # we don't need to implement every option on __array_function__
  345:         # implementations
  346:         assert_equal(func_with_option(1), 'default')
  347:         assert_equal(func_with_option(1, option='extra'), 'extra')
  348:         assert_equal(func_with_option(MyArray()), 'myarray')
  349:         with assert_raises(TypeError):
  350:             func_with_option(MyArray(), option='extra')
  351: 
  352:         # but new options on implementations can't be used
  353:         result = my_array_func_with_option(MyArray(), new_option='yes')
  354:         assert_equal(result, 'yes')
  355:         with assert_raises(TypeError):
  356:             func_with_option(MyArray(), new_option='no')
  357: 
  358:     def test_not_implemented(self):
  359:         MyArray, implements = _new_duck_type_and_implements()
  360: 
  361:         @array_function_dispatch(lambda array: (array,), module='my')
  362:         def func(array):
  363:             return array
  364: 
  365:         array = np.array(1)
  366:         assert_(func(array) is array)
  367:         assert_equal(func.__module__, 'my')
  368: 
  369:         with assert_raises_regex(
  370:                 TypeError, "no implementation found for 'my.func'"):
  371:             func(MyArray())
  372: 
  373:     @pytest.mark.parametrize("name", ["concatenate", "mean", "asarray"])
  374:     def test_signature_error_message_simple(self, name):
  375:         func = getattr(np, name)
  376:         try:
  377:             # all of these functions need an argument:
  378:             func()
  379:         except TypeError as e:
  380:             exc = e
  381: 
  382:         assert exc.args[0].startswith(f"{name}()")
  383: 
  384:     def test_signature_error_message(self):
  385:         # The lambda function will be named "<lambda>", but the TypeError
  386:         # should show the name as "func"
  387:         def _dispatcher():
  388:             return ()
  389: 
  390:         @array_function_dispatch(_dispatcher)
  391:         def func():
  392:             pass
  393: 
  394:         try:
  395:             func._implementation(bad_arg=3)
  396:         except TypeError as e:
  397:             expected_exception = e
  398: 
  399:         try:
  400:             func(bad_arg=3)
  401:             raise AssertionError("must fail")
  402:         except TypeError as exc:
  403:             if exc.args[0].startswith("_dispatcher"):
  404:                 # We replace the qualname currently, but it used `__name__`
  405:                 # (relevant functions have the same name and qualname anyway)
  406:                 pytest.skip("Python version is not using __qualname__ for "
  407:                             "TypeError formatting.")
  408: 
  409:             assert exc.args == expected_exception.args
  410: 
  411:     @pytest.mark.parametrize("value", [234, "this func is not replaced"])
  412:     def test_dispatcher_error(self, value):
  413:         # If the dispatcher raises an error, we must not attempt to mutate it
  414:         error = TypeError(value)
  415: 
  416:         def dispatcher():
  417:             raise error
  418: 
  419:         @array_function_dispatch(dispatcher)
  420:         def func():
  421:             return 3
  422: 
  423:         try:
  424:             func()
  425:             raise AssertionError("must fail")
  426:         except TypeError as exc:
  427:             assert exc is error  # unmodified exception
  428: 
  429:     def test_properties(self):
  430:         # Check that str and repr are sensible
  431:         func = dispatched_two_arg
  432:         assert str(func) == str(func._implementation)
  433:         repr_no_id = repr(func).split("at ")[0]
  434:         repr_no_id_impl = repr(func._implementation).split("at ")[0]
  435:         assert repr_no_id == repr_no_id_impl
  436: 
  437:     @pytest.mark.parametrize("func", [
  438:             lambda x, y: 0,  # no like argument
  439:             lambda like=None: 0,  # not keyword only
  440:             lambda *, like=None, a=3: 0,  # not last (not that it matters)
  441:         ])
  442:     def test_bad_like_sig(self, func):
  443:         # We sanity check the signature, and these should fail.
  444:         with pytest.raises(RuntimeError):
  445:             array_function_dispatch()(func)
  446: 
  447:     def test_bad_like_passing(self):
  448:         # Cover internal sanity check for passing like as first positional arg
  449:         def func(*, like=None):
  450:             pass
  451: 
  452:         func_with_like = array_function_dispatch()(func)
  453:         with pytest.raises(TypeError):
  454:             func_with_like()
  455:         with pytest.raises(TypeError):
  456:             func_with_like(like=234)
  457: 
  458:     def test_too_many_args(self):
  459:         # Mainly a unit-test to increase coverage
  460:         objs = []
  461:         for i in range(80):
  462:             class MyArr:
  463:                 def __array_function__(self, *args, **kwargs):
  464:                     return NotImplemented
  465: 
  466:             objs.append(MyArr())
  467: 
  468:         def _dispatch(*args):
  469:             return args
  470: 
  471:         @array_function_dispatch(_dispatch)
  472:         def func(*args):
  473:             pass
  474: 
  475:         with pytest.raises(TypeError, match="maximum number"):
  476:             func(*objs)
  477: 
  478: 
  479: class TestNDArrayMethods:
  480: 
  481:     def test_repr(self):
  482:         # gh-12162: should still be defined even if __array_function__ doesn't
  483:         # implement np.array_repr()
  484: 
  485:         class MyArray(np.ndarray):
  486:             def __array_function__(*args, **kwargs):
  487:                 return NotImplemented
  488: 
  489:         array = np.array(1).view(MyArray)
  490:         assert_equal(repr(array), 'MyArray(1)')
  491:         assert_equal(str(array), '1')
  492: 
  493: 
  494: class TestNumPyFunctions:
  495: 
  496:     def test_set_module(self):
  497:         assert_equal(np.sum.__module__, 'numpy')
  498:         assert_equal(np.char.equal.__module__, 'numpy.char')
  499:         assert_equal(np.fft.fft.__module__, 'numpy.fft')
  500:         assert_equal(np.linalg.solve.__module__, 'numpy.linalg')
  501: 
  502:     def test_inspect_sum(self):
  503:         signature = inspect.signature(np.sum)
  504:         assert_('axis' in signature.parameters)
  505: 
  506:     def test_override_sum(self):
  507:         MyArray, implements = _new_duck_type_and_implements()
  508: 
  509:         @implements(np.sum)
  510:         def _(array):
  511:             return 'yes'
  512: 
  513:         assert_equal(np.sum(MyArray()), 'yes')
  514: 
  515:     def test_sum_on_mock_array(self):
  516: 
  517:         # We need a proxy for mocks because __array_function__ is only looked
  518:         # up in the class dict
  519:         class ArrayProxy:
  520:             def __init__(self, value):
  521:                 self.value = value
  522: 
  523:             def __array_function__(self, *args, **kwargs):
  524:                 return self.value.__array_function__(*args, **kwargs)
  525: 
  526:             def __array__(self, *args, **kwargs):
  527:                 return self.value.__array__(*args, **kwargs)
  528: 
  529:         proxy = ArrayProxy(mock.Mock(spec=ArrayProxy))
  530:         proxy.value.__array_function__.return_value = 1
  531:         result = np.sum(proxy)
  532:         assert_equal(result, 1)
  533:         proxy.value.__array_function__.assert_called_once_with(
  534:             np.sum, (ArrayProxy,), (proxy,), {})
  535:         proxy.value.__array__.assert_not_called()
  536: 
  537:     def test_sum_forwarding_implementation(self):
  538: 
  539:         class MyArray(np.ndarray):
  540: 
  541:             def sum(self, axis, out):
  542:                 return 'summed'
  543: 
  544:             def __array_function__(self, func, types, args, kwargs):
  545:                 return super().__array_function__(func, types, args, kwargs)
  546: 
  547:         # note: the internal implementation of np.sum() calls the .sum() method
  548:         array = np.array(1).view(MyArray)
  549:         assert_equal(np.sum(array), 'summed')
  550: 
  551: 
  552: class TestArrayLike:
  553:     def setup_method(self):
  554:         class MyArray:
  555:             def __init__(self, function=None):
  556:                 self.function = function
  557: 
  558:             def __array_function__(self, func, types, args, kwargs):
  559:                 assert func is getattr(np, func.__name__)
  560:                 try:
  561:                     my_func = getattr(self, func.__name__)
  562:                 except AttributeError:
  563:                     return NotImplemented
  564:                 return my_func(*args, **kwargs)
  565: 
  566:         self.MyArray = MyArray
  567: 
  568:         class MyNoArrayFunctionArray:
  569:             def __init__(self, function=None):
  570:                 self.function = function
  571: 
  572:         self.MyNoArrayFunctionArray = MyNoArrayFunctionArray
  573: 
  574:         class MySubclass(np.ndarray):
  575:             def __array_function__(self, func, types, args, kwargs):
  576:                 result = super().__array_function__(func, types, args, kwargs)
  577:                 return result.view(self.__class__)
  578: 
  579:         self.MySubclass = MySubclass
  580: 
  581:     def add_method(self, name, arr_class, enable_value_error=False):
  582:         def _definition(*args, **kwargs):
  583:             # Check that `like=` isn't propagated downstream
  584:             assert 'like' not in kwargs
  585: 
  586:             if enable_value_error and 'value_error' in kwargs:
  587:                 raise ValueError
  588: 
  589:             return arr_class(getattr(arr_class, name))
  590:         setattr(arr_class, name, _definition)
  591: 
  592:     def func_args(*args, **kwargs):
  593:         return args, kwargs
  594: 
  595:     def test_array_like_not_implemented(self):
  596:         self.add_method('array', self.MyArray)
  597: 
  598:         ref = self.MyArray.array()
  599: 
  600:         with assert_raises_regex(TypeError, 'no implementation found'):
  601:             array_like = np.asarray(1, like=ref)
  602: 
  603:     _array_tests = [
  604:         ('array', *func_args((1,))),
  605:         ('asarray', *func_args((1,))),
  606:         ('asanyarray', *func_args((1,))),
  607:         ('ascontiguousarray', *func_args((2, 3))),
  608:         ('asfortranarray', *func_args((2, 3))),
  609:         ('require', *func_args((np.arange(6).reshape(2, 3),),
  610:                                requirements=['A', 'F'])),
  611:         ('empty', *func_args((1,))),
  612:         ('full', *func_args((1,), 2)),
  613:         ('ones', *func_args((1,))),
  614:         ('zeros', *func_args((1,))),
  615:         ('arange', *func_args(3)),
  616:         ('frombuffer', *func_args(b'\x00' * 8, dtype=int)),
  617:         ('fromiter', *func_args(range(3), dtype=int)),
  618:         ('fromstring', *func_args('1,2', dtype=int, sep=',')),
  619:         ('loadtxt', *func_args(lambda: StringIO('0 1\n2 3'))),
  620:         ('genfromtxt', *func_args(lambda: StringIO('1,2.1'),
  621:                                   dtype=[('int', 'i8'), ('float', 'f8')],
  622:                                   delimiter=',')),
  623:     ]
  624: 
  625:     def test_nep35_functions_as_array_functions(self,):
  626:         all_array_functions = get_overridable_numpy_array_functions()
  627:         like_array_functions_subset = {
  628:             getattr(np, func_name) for func_name, *_ in self.__class__._array_tests
  629:         }
  630:         assert like_array_functions_subset.issubset(all_array_functions)
  631: 
  632:         nep35_python_functions = {
  633:             np.eye, np.fromfunction, np.full, np.genfromtxt,
  634:             np.identity, np.loadtxt, np.ones, np.require, np.tri,
  635:         }
  636:         assert nep35_python_functions.issubset(all_array_functions)
  637: 
  638:         nep35_C_functions = {
  639:             np.arange, np.array, np.asanyarray, np.asarray,
  640:             np.ascontiguousarray, np.asfortranarray, np.empty,
  641:             np.frombuffer, np.fromfile, np.fromiter, np.fromstring,
  642:             np.zeros,
  643:         }
  644:         assert nep35_C_functions.issubset(all_array_functions)
  645: 
  646:     @pytest.mark.parametrize('function, args, kwargs', _array_tests)
  647:     @pytest.mark.parametrize('numpy_ref', [True, False])
  648:     def test_array_like(self, function, args, kwargs, numpy_ref):
  649:         self.add_method('array', self.MyArray)
  650:         self.add_method(function, self.MyArray)
  651:         np_func = getattr(np, function)
  652:         my_func = getattr(self.MyArray, function)
  653: 
  654:         if numpy_ref is True:
  655:             ref = np.array(1)
  656:         else:
  657:             ref = self.MyArray.array()
  658: 
  659:         like_args = tuple(a() if callable(a) else a for a in args)
  660:         array_like = np_func(*like_args, **kwargs, like=ref)
  661: 
  662:         if numpy_ref is True:
  663:             assert type(array_like) is np.ndarray
  664: 
  665:             np_args = tuple(a() if callable(a) else a for a in args)
  666:             np_arr = np_func(*np_args, **kwargs)
  667: 
  668:             # Special-case np.empty to ensure values match
  669:             if function == "empty":
  670:                 np_arr.fill(1)
  671:                 array_like.fill(1)
  672: 
  673:             assert_equal(array_like, np_arr)
  674:         else:
  675:             assert type(array_like) is self.MyArray
  676:             assert array_like.function is my_func
  677: 
  678:     @pytest.mark.parametrize('function, args, kwargs', _array_tests)
  679:     @pytest.mark.parametrize('ref', [1, [1], "MyNoArrayFunctionArray"])
  680:     def test_no_array_function_like(self, function, args, kwargs, ref):
  681:         self.add_method('array', self.MyNoArrayFunctionArray)
  682:         self.add_method(function, self.MyNoArrayFunctionArray)
  683:         np_func = getattr(np, function)
  684: 
  685:         # Instantiate ref if it's the MyNoArrayFunctionArray class
  686:         if ref == "MyNoArrayFunctionArray":
  687:             ref = self.MyNoArrayFunctionArray.array()
  688: 
  689:         like_args = tuple(a() if callable(a) else a for a in args)
  690: 
  691:         with assert_raises_regex(TypeError,
  692:                 'The `like` argument must be an array-like that implements'):
  693:             np_func(*like_args, **kwargs, like=ref)
  694: 
  695:     @pytest.mark.parametrize('function, args, kwargs', _array_tests)
  696:     def test_subclass(self, function, args, kwargs):
  697:         ref = np.array(1).view(self.MySubclass)
  698:         np_func = getattr(np, function)
  699:         like_args = tuple(a() if callable(a) else a for a in args)
  700:         array_like = np_func(*like_args, **kwargs, like=ref)
  701:         assert type(array_like) is self.MySubclass
  702:         if np_func is np.empty:
  703:             return
  704:         np_args = tuple(a() if callable(a) else a for a in args)
  705:         np_arr = np_func(*np_args, **kwargs)
  706:         assert_equal(array_like.view(np.ndarray), np_arr)
  707: 
  708:     @pytest.mark.parametrize('numpy_ref', [True, False])
  709:     def test_array_like_fromfile(self, numpy_ref):
  710:         self.add_method('array', self.MyArray)
  711:         self.add_method("fromfile", self.MyArray)
  712: 
  713:         if numpy_ref is True:
  714:             ref = np.array(1)
  715:         else:
  716:             ref = self.MyArray.array()
  717: 
  718:         data = np.random.random(5)
  719: 
  720:         with tempfile.TemporaryDirectory() as tmpdir:
  721:             fname = os.path.join(tmpdir, "testfile")
  722:             data.tofile(fname)
  723: 
  724:             array_like = np.fromfile(fname, like=ref)
  725:             if numpy_ref is True:
  726:                 assert type(array_like) is np.ndarray
  727:                 np_res = np.fromfile(fname, like=ref)
  728:                 assert_equal(np_res, data)
  729:                 assert_equal(array_like, np_res)
  730:             else:
  731:                 assert type(array_like) is self.MyArray
  732:                 assert array_like.function is self.MyArray.fromfile
  733: 
  734:     def test_exception_handling(self):
  735:         self.add_method('array', self.MyArray, enable_value_error=True)
  736: 
  737:         ref = self.MyArray.array()
  738: 
  739:         with assert_raises(TypeError):
  740:             # Raises the error about `value_error` being invalid first
  741:             np.array(1, value_error=True, like=ref)
  742: 
  743:     @pytest.mark.parametrize('function, args, kwargs', _array_tests)
  744:     def test_like_as_none(self, function, args, kwargs):
  745:         self.add_method('array', self.MyArray)
  746:         self.add_method(function, self.MyArray)
  747:         np_func = getattr(np, function)
  748: 
  749:         like_args = tuple(a() if callable(a) else a for a in args)
  750:         # required for loadtxt and genfromtxt to init w/o error.
  751:         like_args_exp = tuple(a() if callable(a) else a for a in args)
  752: 
  753:         array_like = np_func(*like_args, **kwargs, like=None)
  754:         expected = np_func(*like_args_exp, **kwargs)
  755:         # Special-case np.empty to ensure values match
  756:         if function == "empty":
  757:             array_like.fill(1)
  758:             expected.fill(1)
  759:         assert_equal(array_like, expected)
  760: 
  761: 
  762: def test_function_like():
  763:     # We provide a `__get__` implementation, make sure it works
  764:     assert type(np.mean) is np._core._multiarray_umath._ArrayFunctionDispatcher
  765: 
  766:     class MyClass:
  767:         def __array__(self, dtype=None, copy=None):
  768:             # valid argument to mean:
  769:             return np.arange(3)
  770: 
  771:         func1 = staticmethod(np.mean)
  772:         func2 = np.mean
  773:         func3 = classmethod(np.mean)
  774: 
  775:     m = MyClass()
  776:     assert m.func1([10]) == 10
  777:     assert m.func2() == 1  # mean of the arange
  778:     with pytest.raises(TypeError, match="unsupported operand type"):
  779:         # Tries to operate on the class
  780:         m.func3()
  781: 
  782:     # Manual binding also works (the above may shortcut):
  783:     bound = np.mean.__get__(m, MyClass)
  784:     assert bound() == 1
  785: 
  786:     bound = np.mean.__get__(None, MyClass)  # unbound actually
  787:     assert bound([10]) == 10
  788: 
  789:     bound = np.mean.__get__(MyClass)  # classmethod
  790:     with pytest.raises(TypeError, match="unsupported operand type"):
  791:         bound()
