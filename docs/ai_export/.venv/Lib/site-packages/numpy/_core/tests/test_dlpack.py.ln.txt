    1: import sys
    2: 
    3: import pytest
    4: 
    5: import numpy as np
    6: from numpy.testing import IS_PYPY, assert_array_equal
    7: 
    8: 
    9: def new_and_old_dlpack():
   10:     yield np.arange(5)
   11: 
   12:     class OldDLPack(np.ndarray):
   13:         # Support only the "old" version
   14:         def __dlpack__(self, stream=None):
   15:             return super().__dlpack__(stream=None)
   16: 
   17:     yield np.arange(5).view(OldDLPack)
   18: 
   19: 
   20: class TestDLPack:
   21:     @pytest.mark.skipif(IS_PYPY, reason="PyPy can't get refcounts.")
   22:     @pytest.mark.parametrize("max_version", [(0, 0), None, (1, 0), (100, 3)])
   23:     def test_dunder_dlpack_refcount(self, max_version):
   24:         x = np.arange(5)
   25:         y = x.__dlpack__(max_version=max_version)
   26:         startcount = sys.getrefcount(x)
   27:         del y
   28:         assert startcount - sys.getrefcount(x) == 1
   29: 
   30:     def test_dunder_dlpack_stream(self):
   31:         x = np.arange(5)
   32:         x.__dlpack__(stream=None)
   33: 
   34:         with pytest.raises(RuntimeError):
   35:             x.__dlpack__(stream=1)
   36: 
   37:     def test_dunder_dlpack_copy(self):
   38:         # Checks the argument parsing of __dlpack__ explicitly.
   39:         # Honoring the flag is tested in the from_dlpack round-tripping test.
   40:         x = np.arange(5)
   41:         x.__dlpack__(copy=True)
   42:         x.__dlpack__(copy=None)
   43:         x.__dlpack__(copy=False)
   44: 
   45:         with pytest.raises(ValueError):
   46:             # NOTE: The copy converter should be stricter, but not just here.
   47:             x.__dlpack__(copy=np.array([1, 2, 3]))
   48: 
   49:     def test_strides_not_multiple_of_itemsize(self):
   50:         dt = np.dtype([('int', np.int32), ('char', np.int8)])
   51:         y = np.zeros((5,), dtype=dt)
   52:         z = y['int']
   53: 
   54:         with pytest.raises(BufferError):
   55:             np.from_dlpack(z)
   56: 
   57:     @pytest.mark.skipif(IS_PYPY, reason="PyPy can't get refcounts.")
   58:     @pytest.mark.parametrize("arr", new_and_old_dlpack())
   59:     def test_from_dlpack_refcount(self, arr):
   60:         arr = arr.copy()
   61:         y = np.from_dlpack(arr)
   62:         startcount = sys.getrefcount(arr)
   63:         del y
   64:         assert startcount - sys.getrefcount(arr) == 1
   65: 
   66:     @pytest.mark.parametrize("dtype", [
   67:         np.bool,
   68:         np.int8, np.int16, np.int32, np.int64,
   69:         np.uint8, np.uint16, np.uint32, np.uint64,
   70:         np.float16, np.float32, np.float64,
   71:         np.complex64, np.complex128
   72:     ])
   73:     @pytest.mark.parametrize("arr", new_and_old_dlpack())
   74:     def test_dtype_passthrough(self, arr, dtype):
   75:         x = arr.astype(dtype)
   76:         y = np.from_dlpack(x)
   77: 
   78:         assert y.dtype == x.dtype
   79:         assert_array_equal(x, y)
   80: 
   81:     def test_invalid_dtype(self):
   82:         x = np.asarray(np.datetime64('2021-05-27'))
   83: 
   84:         with pytest.raises(BufferError):
   85:             np.from_dlpack(x)
   86: 
   87:     def test_invalid_byte_swapping(self):
   88:         dt = np.dtype('=i8').newbyteorder()
   89:         x = np.arange(5, dtype=dt)
   90: 
   91:         with pytest.raises(BufferError):
   92:             np.from_dlpack(x)
   93: 
   94:     def test_non_contiguous(self):
   95:         x = np.arange(25).reshape((5, 5))
   96: 
   97:         y1 = x[0]
   98:         assert_array_equal(y1, np.from_dlpack(y1))
   99: 
  100:         y2 = x[:, 0]
  101:         assert_array_equal(y2, np.from_dlpack(y2))
  102: 
  103:         y3 = x[1, :]
  104:         assert_array_equal(y3, np.from_dlpack(y3))
  105: 
  106:         y4 = x[1]
  107:         assert_array_equal(y4, np.from_dlpack(y4))
  108: 
  109:         y5 = np.diagonal(x).copy()
  110:         assert_array_equal(y5, np.from_dlpack(y5))
  111: 
  112:     @pytest.mark.parametrize("ndim", range(33))
  113:     def test_higher_dims(self, ndim):
  114:         shape = (1,) * ndim
  115:         x = np.zeros(shape, dtype=np.float64)
  116: 
  117:         assert shape == np.from_dlpack(x).shape
  118: 
  119:     def test_dlpack_device(self):
  120:         x = np.arange(5)
  121:         assert x.__dlpack_device__() == (1, 0)
  122:         y = np.from_dlpack(x)
  123:         assert y.__dlpack_device__() == (1, 0)
  124:         z = y[::2]
  125:         assert z.__dlpack_device__() == (1, 0)
  126: 
  127:     def dlpack_deleter_exception(self, max_version):
  128:         x = np.arange(5)
  129:         _ = x.__dlpack__(max_version=max_version)
  130:         raise RuntimeError
  131: 
  132:     @pytest.mark.parametrize("max_version", [None, (1, 0)])
  133:     def test_dlpack_destructor_exception(self, max_version):
  134:         with pytest.raises(RuntimeError):
  135:             self.dlpack_deleter_exception(max_version=max_version)
  136: 
  137:     def test_readonly(self):
  138:         x = np.arange(5)
  139:         x.flags.writeable = False
  140:         # Raises without max_version
  141:         with pytest.raises(BufferError):
  142:             x.__dlpack__()
  143: 
  144:         # But works fine if we try with version
  145:         y = np.from_dlpack(x)
  146:         assert not y.flags.writeable
  147: 
  148:     def test_writeable(self):
  149:         x_new, x_old = new_and_old_dlpack()
  150: 
  151:         # new dlpacks respect writeability
  152:         y = np.from_dlpack(x_new)
  153:         assert y.flags.writeable
  154: 
  155:         # old dlpacks are not writeable for backwards compatibility
  156:         y = np.from_dlpack(x_old)
  157:         assert not y.flags.writeable
  158: 
  159:     def test_ndim0(self):
  160:         x = np.array(1.0)
  161:         y = np.from_dlpack(x)
  162:         assert_array_equal(x, y)
  163: 
  164:     def test_size1dims_arrays(self):
  165:         x = np.ndarray(dtype='f8', shape=(10, 5, 1), strides=(8, 80, 4),
  166:                        buffer=np.ones(1000, dtype=np.uint8), order='F')
  167:         y = np.from_dlpack(x)
  168:         assert_array_equal(x, y)
  169: 
  170:     def test_copy(self):
  171:         x = np.arange(5)
  172: 
  173:         y = np.from_dlpack(x)
  174:         assert np.may_share_memory(x, y)
  175:         y = np.from_dlpack(x, copy=False)
  176:         assert np.may_share_memory(x, y)
  177:         y = np.from_dlpack(x, copy=True)
  178:         assert not np.may_share_memory(x, y)
  179: 
  180:     def test_device(self):
  181:         x = np.arange(5)
  182:         # requesting (1, 0), i.e. CPU device works in both calls:
  183:         x.__dlpack__(dl_device=(1, 0))
  184:         np.from_dlpack(x, device="cpu")
  185:         np.from_dlpack(x, device=None)
  186: 
  187:         with pytest.raises(ValueError):
  188:             x.__dlpack__(dl_device=(10, 0))
  189:         with pytest.raises(ValueError):
  190:             np.from_dlpack(x, device="gpu")
