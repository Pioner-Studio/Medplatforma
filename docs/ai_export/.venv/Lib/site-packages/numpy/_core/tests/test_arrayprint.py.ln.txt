    1: import gc
    2: import sys
    3: import textwrap
    4: 
    5: import pytest
    6: from hypothesis import given
    7: from hypothesis.extra import numpy as hynp
    8: 
    9: import numpy as np
   10: from numpy._core.arrayprint import _typelessdata
   11: from numpy.testing import (
   12:     HAS_REFCOUNT,
   13:     IS_WASM,
   14:     assert_,
   15:     assert_equal,
   16:     assert_raises,
   17:     assert_raises_regex,
   18:     assert_warns,
   19: )
   20: from numpy.testing._private.utils import run_threaded
   21: 
   22: 
   23: class TestArrayRepr:
   24:     def test_nan_inf(self):
   25:         x = np.array([np.nan, np.inf])
   26:         assert_equal(repr(x), 'array([nan, inf])')
   27: 
   28:     def test_subclass(self):
   29:         class sub(np.ndarray):
   30:             pass
   31: 
   32:         # one dimensional
   33:         x1d = np.array([1, 2]).view(sub)
   34:         assert_equal(repr(x1d), 'sub([1, 2])')
   35: 
   36:         # two dimensional
   37:         x2d = np.array([[1, 2], [3, 4]]).view(sub)
   38:         assert_equal(repr(x2d),
   39:             'sub([[1, 2],\n'
   40:             '     [3, 4]])')
   41: 
   42:         # two dimensional with flexible dtype
   43:         xstruct = np.ones((2, 2), dtype=[('a', '<i4')]).view(sub)
   44:         assert_equal(repr(xstruct),
   45:             "sub([[(1,), (1,)],\n"
   46:             "     [(1,), (1,)]], dtype=[('a', '<i4')])"
   47:         )
   48: 
   49:     @pytest.mark.xfail(reason="See gh-10544")
   50:     def test_object_subclass(self):
   51:         class sub(np.ndarray):
   52:             def __new__(cls, inp):
   53:                 obj = np.asarray(inp).view(cls)
   54:                 return obj
   55: 
   56:             def __getitem__(self, ind):
   57:                 ret = super().__getitem__(ind)
   58:                 return sub(ret)
   59: 
   60:         # test that object + subclass is OK:
   61:         x = sub([None, None])
   62:         assert_equal(repr(x), 'sub([None, None], dtype=object)')
   63:         assert_equal(str(x), '[None None]')
   64: 
   65:         x = sub([None, sub([None, None])])
   66:         assert_equal(repr(x),
   67:             'sub([None, sub([None, None], dtype=object)], dtype=object)')
   68:         assert_equal(str(x), '[None sub([None, None], dtype=object)]')
   69: 
   70:     def test_0d_object_subclass(self):
   71:         # make sure that subclasses which return 0ds instead
   72:         # of scalars don't cause infinite recursion in str
   73:         class sub(np.ndarray):
   74:             def __new__(cls, inp):
   75:                 obj = np.asarray(inp).view(cls)
   76:                 return obj
   77: 
   78:             def __getitem__(self, ind):
   79:                 ret = super().__getitem__(ind)
   80:                 return sub(ret)
   81: 
   82:         x = sub(1)
   83:         assert_equal(repr(x), 'sub(1)')
   84:         assert_equal(str(x), '1')
   85: 
   86:         x = sub([1, 1])
   87:         assert_equal(repr(x), 'sub([1, 1])')
   88:         assert_equal(str(x), '[1 1]')
   89: 
   90:         # check it works properly with object arrays too
   91:         x = sub(None)
   92:         assert_equal(repr(x), 'sub(None, dtype=object)')
   93:         assert_equal(str(x), 'None')
   94: 
   95:         # plus recursive object arrays (even depth > 1)
   96:         y = sub(None)
   97:         x[()] = y
   98:         y[()] = x
   99:         assert_equal(repr(x),
  100:             'sub(sub(sub(..., dtype=object), dtype=object), dtype=object)')
  101:         assert_equal(str(x), '...')
  102:         x[()] = 0  # resolve circular references for garbage collector
  103: 
  104:         # nested 0d-subclass-object
  105:         x = sub(None)
  106:         x[()] = sub(None)
  107:         assert_equal(repr(x), 'sub(sub(None, dtype=object), dtype=object)')
  108:         assert_equal(str(x), 'None')
  109: 
  110:         # gh-10663
  111:         class DuckCounter(np.ndarray):
  112:             def __getitem__(self, item):
  113:                 result = super().__getitem__(item)
  114:                 if not isinstance(result, DuckCounter):
  115:                     result = result[...].view(DuckCounter)
  116:                 return result
  117: 
  118:             def to_string(self):
  119:                 return {0: 'zero', 1: 'one', 2: 'two'}.get(self.item(), 'many')
  120: 
  121:             def __str__(self):
  122:                 if self.shape == ():
  123:                     return self.to_string()
  124:                 else:
  125:                     fmt = {'all': lambda x: x.to_string()}
  126:                     return np.array2string(self, formatter=fmt)
  127: 
  128:         dc = np.arange(5).view(DuckCounter)
  129:         assert_equal(str(dc), "[zero one two many many]")
  130:         assert_equal(str(dc[0]), "zero")
  131: 
  132:     def test_self_containing(self):
  133:         arr0d = np.array(None)
  134:         arr0d[()] = arr0d
  135:         assert_equal(repr(arr0d),
  136:             'array(array(..., dtype=object), dtype=object)')
  137:         arr0d[()] = 0  # resolve recursion for garbage collector
  138: 
  139:         arr1d = np.array([None, None])
  140:         arr1d[1] = arr1d
  141:         assert_equal(repr(arr1d),
  142:             'array([None, array(..., dtype=object)], dtype=object)')
  143:         arr1d[1] = 0  # resolve recursion for garbage collector
  144: 
  145:         first = np.array(None)
  146:         second = np.array(None)
  147:         first[()] = second
  148:         second[()] = first
  149:         assert_equal(repr(first),
  150:             'array(array(array(..., dtype=object), dtype=object), dtype=object)')
  151:         first[()] = 0  # resolve circular references for garbage collector
  152: 
  153:     def test_containing_list(self):
  154:         # printing square brackets directly would be ambiguous
  155:         arr1d = np.array([None, None])
  156:         arr1d[0] = [1, 2]
  157:         arr1d[1] = [3]
  158:         assert_equal(repr(arr1d),
  159:             'array([list([1, 2]), list([3])], dtype=object)')
  160: 
  161:     def test_void_scalar_recursion(self):
  162:         # gh-9345
  163:         repr(np.void(b'test'))  # RecursionError ?
  164: 
  165:     def test_fieldless_structured(self):
  166:         # gh-10366
  167:         no_fields = np.dtype([])
  168:         arr_no_fields = np.empty(4, dtype=no_fields)
  169:         assert_equal(repr(arr_no_fields), 'array([(), (), (), ()], dtype=[])')
  170: 
  171: 
  172: class TestComplexArray:
  173:     def test_str(self):
  174:         rvals = [0, 1, -1, np.inf, -np.inf, np.nan]
  175:         cvals = [complex(rp, ip) for rp in rvals for ip in rvals]
  176:         dtypes = [np.complex64, np.cdouble, np.clongdouble]
  177:         actual = [str(np.array([c], dt)) for c in cvals for dt in dtypes]
  178:         wanted = [
  179:             '[0.+0.j]',    '[0.+0.j]',    '[0.+0.j]',
  180:             '[0.+1.j]',    '[0.+1.j]',    '[0.+1.j]',
  181:             '[0.-1.j]',    '[0.-1.j]',    '[0.-1.j]',
  182:             '[0.+infj]',   '[0.+infj]',   '[0.+infj]',
  183:             '[0.-infj]',   '[0.-infj]',   '[0.-infj]',
  184:             '[0.+nanj]',   '[0.+nanj]',   '[0.+nanj]',
  185:             '[1.+0.j]',    '[1.+0.j]',    '[1.+0.j]',
  186:             '[1.+1.j]',    '[1.+1.j]',    '[1.+1.j]',
  187:             '[1.-1.j]',    '[1.-1.j]',    '[1.-1.j]',
  188:             '[1.+infj]',   '[1.+infj]',   '[1.+infj]',
  189:             '[1.-infj]',   '[1.-infj]',   '[1.-infj]',
  190:             '[1.+nanj]',   '[1.+nanj]',   '[1.+nanj]',
  191:             '[-1.+0.j]',   '[-1.+0.j]',   '[-1.+0.j]',
  192:             '[-1.+1.j]',   '[-1.+1.j]',   '[-1.+1.j]',
  193:             '[-1.-1.j]',   '[-1.-1.j]',   '[-1.-1.j]',
  194:             '[-1.+infj]',  '[-1.+infj]',  '[-1.+infj]',
  195:             '[-1.-infj]',  '[-1.-infj]',  '[-1.-infj]',
  196:             '[-1.+nanj]',  '[-1.+nanj]',  '[-1.+nanj]',
  197:             '[inf+0.j]',   '[inf+0.j]',   '[inf+0.j]',
  198:             '[inf+1.j]',   '[inf+1.j]',   '[inf+1.j]',
  199:             '[inf-1.j]',   '[inf-1.j]',   '[inf-1.j]',
  200:             '[inf+infj]',  '[inf+infj]',  '[inf+infj]',
  201:             '[inf-infj]',  '[inf-infj]',  '[inf-infj]',
  202:             '[inf+nanj]',  '[inf+nanj]',  '[inf+nanj]',
  203:             '[-inf+0.j]',  '[-inf+0.j]',  '[-inf+0.j]',
  204:             '[-inf+1.j]',  '[-inf+1.j]',  '[-inf+1.j]',
  205:             '[-inf-1.j]',  '[-inf-1.j]',  '[-inf-1.j]',
  206:             '[-inf+infj]', '[-inf+infj]', '[-inf+infj]',
  207:             '[-inf-infj]', '[-inf-infj]', '[-inf-infj]',
  208:             '[-inf+nanj]', '[-inf+nanj]', '[-inf+nanj]',
  209:             '[nan+0.j]',   '[nan+0.j]',   '[nan+0.j]',
  210:             '[nan+1.j]',   '[nan+1.j]',   '[nan+1.j]',
  211:             '[nan-1.j]',   '[nan-1.j]',   '[nan-1.j]',
  212:             '[nan+infj]',  '[nan+infj]',  '[nan+infj]',
  213:             '[nan-infj]',  '[nan-infj]',  '[nan-infj]',
  214:             '[nan+nanj]',  '[nan+nanj]',  '[nan+nanj]']
  215: 
  216:         for res, val in zip(actual, wanted):
  217:             assert_equal(res, val)
  218: 
  219: class TestArray2String:
  220:     def test_basic(self):
  221:         """Basic test of array2string."""
  222:         a = np.arange(3)
  223:         assert_(np.array2string(a) == '[0 1 2]')
  224:         assert_(np.array2string(a, max_line_width=4, legacy='1.13') == '[0 1\n 2]')
  225:         assert_(np.array2string(a, max_line_width=4) == '[0\n 1\n 2]')
  226: 
  227:     def test_unexpected_kwarg(self):
  228:         # ensure than an appropriate TypeError
  229:         # is raised when array2string receives
  230:         # an unexpected kwarg
  231: 
  232:         with assert_raises_regex(TypeError, 'nonsense'):
  233:             np.array2string(np.array([1, 2, 3]),
  234:                             nonsense=None)
  235: 
  236:     def test_format_function(self):
  237:         """Test custom format function for each element in array."""
  238:         def _format_function(x):
  239:             if np.abs(x) < 1:
  240:                 return '.'
  241:             elif np.abs(x) < 2:
  242:                 return 'o'
  243:             else:
  244:                 return 'O'
  245: 
  246:         x = np.arange(3)
  247:         x_hex = "[0x0 0x1 0x2]"
  248:         x_oct = "[0o0 0o1 0o2]"
  249:         assert_(np.array2string(x, formatter={'all': _format_function}) ==
  250:                 "[. o O]")
  251:         assert_(np.array2string(x, formatter={'int_kind': _format_function}) ==
  252:                 "[. o O]")
  253:         assert_(np.array2string(x, formatter={'all': lambda x: f"{x:.4f}"}) ==
  254:                 "[0.0000 1.0000 2.0000]")
  255:         assert_equal(np.array2string(x, formatter={'int': hex}),
  256:                 x_hex)
  257:         assert_equal(np.array2string(x, formatter={'int': oct}),
  258:                 x_oct)
  259: 
  260:         x = np.arange(3.)
  261:         assert_(np.array2string(x, formatter={'float_kind': lambda x: f"{x:.2f}"}) ==
  262:                 "[0.00 1.00 2.00]")
  263:         assert_(np.array2string(x, formatter={'float': lambda x: f"{x:.2f}"}) ==
  264:                 "[0.00 1.00 2.00]")
  265: 
  266:         s = np.array(['abc', 'def'])
  267:         assert_(np.array2string(s, formatter={'numpystr': lambda s: s * 2}) ==
  268:                 '[abcabc defdef]')
  269: 
  270:     def test_structure_format_mixed(self):
  271:         dt = np.dtype([('name', np.str_, 16), ('grades', np.float64, (2,))])
  272:         x = np.array([('Sarah', (8.0, 7.0)), ('John', (6.0, 7.0))], dtype=dt)
  273:         assert_equal(np.array2string(x),
  274:                 "[('Sarah', [8., 7.]) ('John', [6., 7.])]")
  275: 
  276:         np.set_printoptions(legacy='1.13')
  277:         try:
  278:             # for issue #5692
  279:             A = np.zeros(shape=10, dtype=[("A", "M8[s]")])
  280:             A[5:].fill(np.datetime64('NaT'))
  281:             assert_equal(
  282:                 np.array2string(A),
  283:                 textwrap.dedent("""\
  284:                 [('1970-01-01T00:00:00',) ('1970-01-01T00:00:00',) ('1970-01-01T00:00:00',)
  285:                  ('1970-01-01T00:00:00',) ('1970-01-01T00:00:00',) ('NaT',) ('NaT',)
  286:                  ('NaT',) ('NaT',) ('NaT',)]""")
  287:             )
  288:         finally:
  289:             np.set_printoptions(legacy=False)
  290: 
  291:         # same again, but with non-legacy behavior
  292:         assert_equal(
  293:             np.array2string(A),
  294:             textwrap.dedent("""\
  295:             [('1970-01-01T00:00:00',) ('1970-01-01T00:00:00',)
  296:              ('1970-01-01T00:00:00',) ('1970-01-01T00:00:00',)
  297:              ('1970-01-01T00:00:00',) (                'NaT',)
  298:              (                'NaT',) (                'NaT',)
  299:              (                'NaT',) (                'NaT',)]""")
  300:         )
  301: 
  302:         # and again, with timedeltas
  303:         A = np.full(10, 123456, dtype=[("A", "m8[s]")])
  304:         A[5:].fill(np.datetime64('NaT'))
  305:         assert_equal(
  306:             np.array2string(A),
  307:             textwrap.dedent("""\
  308:             [(123456,) (123456,) (123456,) (123456,) (123456,) ( 'NaT',) ( 'NaT',)
  309:              ( 'NaT',) ( 'NaT',) ( 'NaT',)]""")
  310:         )
  311: 
  312:     def test_structure_format_int(self):
  313:         # See #8160
  314:         struct_int = np.array([([1, -1],), ([123, 1],)],
  315:                 dtype=[('B', 'i4', 2)])
  316:         assert_equal(np.array2string(struct_int),
  317:                 "[([  1,  -1],) ([123,   1],)]")
  318:         struct_2dint = np.array([([[0, 1], [2, 3]],), ([[12, 0], [0, 0]],)],
  319:                 dtype=[('B', 'i4', (2, 2))])
  320:         assert_equal(np.array2string(struct_2dint),
  321:                 "[([[ 0,  1], [ 2,  3]],) ([[12,  0], [ 0,  0]],)]")
  322: 
  323:     def test_structure_format_float(self):
  324:         # See #8172
  325:         array_scalar = np.array(
  326:                 (1., 2.1234567890123456789, 3.), dtype=('f8,f8,f8'))
  327:         assert_equal(np.array2string(array_scalar), "(1., 2.12345679, 3.)")
  328: 
  329:     def test_unstructured_void_repr(self):
  330:         a = np.array([27, 91, 50, 75, 7, 65, 10, 8, 27, 91, 51, 49, 109, 82, 101, 100],
  331:                       dtype='u1').view('V8')
  332:         assert_equal(repr(a[0]),
  333:             r"np.void(b'\x1B\x5B\x32\x4B\x07\x41\x0A\x08')")
  334:         assert_equal(str(a[0]), r"b'\x1B\x5B\x32\x4B\x07\x41\x0A\x08'")
  335:         assert_equal(repr(a),
  336:             r"array([b'\x1B\x5B\x32\x4B\x07\x41\x0A\x08',"
  337:             "\n"
  338:             r"       b'\x1B\x5B\x33\x31\x6D\x52\x65\x64'], dtype='|V8')")
  339: 
  340:         assert_equal(eval(repr(a), vars(np)), a)
  341:         assert_equal(eval(repr(a[0]), {'np': np}), a[0])
  342: 
  343:     def test_edgeitems_kwarg(self):
  344:         # previously the global print options would be taken over the kwarg
  345:         arr = np.zeros(3, int)
  346:         assert_equal(
  347:             np.array2string(arr, edgeitems=1, threshold=0),
  348:             "[0 ... 0]"
  349:         )
  350: 
  351:     def test_summarize_1d(self):
  352:         A = np.arange(1001)
  353:         strA = '[   0    1    2 ...  998  999 1000]'
  354:         assert_equal(str(A), strA)
  355: 
  356:         reprA = 'array([   0,    1,    2, ...,  998,  999, 1000])'
  357:         try:
  358:             np.set_printoptions(legacy='2.1')
  359:             assert_equal(repr(A), reprA)
  360:         finally:
  361:             np.set_printoptions(legacy=False)
  362: 
  363:         assert_equal(repr(A), reprA.replace(')', ', shape=(1001,))'))
  364: 
  365:     def test_summarize_2d(self):
  366:         A = np.arange(1002).reshape(2, 501)
  367:         strA = '[[   0    1    2 ...  498  499  500]\n' \
  368:                ' [ 501  502  503 ...  999 1000 1001]]'
  369:         assert_equal(str(A), strA)
  370: 
  371:         reprA = 'array([[   0,    1,    2, ...,  498,  499,  500],\n' \
  372:                 '       [ 501,  502,  503, ...,  999, 1000, 1001]])'
  373:         try:
  374:             np.set_printoptions(legacy='2.1')
  375:             assert_equal(repr(A), reprA)
  376:         finally:
  377:             np.set_printoptions(legacy=False)
  378: 
  379:         assert_equal(repr(A), reprA.replace(')', ', shape=(2, 501))'))
  380: 
  381:     def test_summarize_2d_dtype(self):
  382:         A = np.arange(1002, dtype='i2').reshape(2, 501)
  383:         strA = '[[   0    1    2 ...  498  499  500]\n' \
  384:                ' [ 501  502  503 ...  999 1000 1001]]'
  385:         assert_equal(str(A), strA)
  386: 
  387:         reprA = ('array([[   0,    1,    2, ...,  498,  499,  500],\n'
  388:                  '       [ 501,  502,  503, ...,  999, 1000, 1001]],\n'
  389:                  '      shape=(2, 501), dtype=int16)')
  390:         assert_equal(repr(A), reprA)
  391: 
  392:     def test_summarize_structure(self):
  393:         A = (np.arange(2002, dtype="<i8").reshape(2, 1001)
  394:              .view([('i', "<i8", (1001,))]))
  395:         strA = ("[[([   0,    1,    2, ...,  998,  999, 1000],)]\n"
  396:                 " [([1001, 1002, 1003, ..., 1999, 2000, 2001],)]]")
  397:         assert_equal(str(A), strA)
  398: 
  399:         reprA = ("array([[([   0,    1,    2, ...,  998,  999, 1000],)],\n"
  400:                  "       [([1001, 1002, 1003, ..., 1999, 2000, 2001],)]],\n"
  401:                  "      dtype=[('i', '<i8', (1001,))])")
  402:         assert_equal(repr(A), reprA)
  403: 
  404:         B = np.ones(2002, dtype=">i8").view([('i', ">i8", (2, 1001))])
  405:         strB = "[([[1, 1, 1, ..., 1, 1, 1], [1, 1, 1, ..., 1, 1, 1]],)]"
  406:         assert_equal(str(B), strB)
  407: 
  408:         reprB = (
  409:             "array([([[1, 1, 1, ..., 1, 1, 1], [1, 1, 1, ..., 1, 1, 1]],)],\n"
  410:             "      dtype=[('i', '>i8', (2, 1001))])"
  411:         )
  412:         assert_equal(repr(B), reprB)
  413: 
  414:         C = (np.arange(22, dtype="<i8").reshape(2, 11)
  415:              .view([('i1', "<i8"), ('i10', "<i8", (10,))]))
  416:         strC = "[[( 0, [ 1, ..., 10])]\n [(11, [12, ..., 21])]]"
  417:         assert_equal(np.array2string(C, threshold=1, edgeitems=1), strC)
  418: 
  419:     def test_linewidth(self):
  420:         a = np.full(6, 1)
  421: 
  422:         def make_str(a, width, **kw):
  423:             return np.array2string(a, separator="", max_line_width=width, **kw)
  424: 
  425:         assert_equal(make_str(a, 8, legacy='1.13'), '[111111]')
  426:         assert_equal(make_str(a, 7, legacy='1.13'), '[111111]')
  427:         assert_equal(make_str(a, 5, legacy='1.13'), '[1111\n'
  428:                                                     ' 11]')
  429: 
  430:         assert_equal(make_str(a, 8), '[111111]')
  431:         assert_equal(make_str(a, 7), '[11111\n'
  432:                                      ' 1]')
  433:         assert_equal(make_str(a, 5), '[111\n'
  434:                                      ' 111]')
  435: 
  436:         b = a[None, None, :]
  437: 
  438:         assert_equal(make_str(b, 12, legacy='1.13'), '[[[111111]]]')
  439:         assert_equal(make_str(b,  9, legacy='1.13'), '[[[111111]]]')
  440:         assert_equal(make_str(b,  8, legacy='1.13'), '[[[11111\n'
  441:                                                      '   1]]]')
  442: 
  443:         assert_equal(make_str(b, 12), '[[[111111]]]')
  444:         assert_equal(make_str(b,  9), '[[[111\n'
  445:                                       '   111]]]')
  446:         assert_equal(make_str(b,  8), '[[[11\n'
  447:                                       '   11\n'
  448:                                       '   11]]]')
  449: 
  450:     def test_wide_element(self):
  451:         a = np.array(['xxxxx'])
  452:         assert_equal(
  453:             np.array2string(a, max_line_width=5),
  454:             "['xxxxx']"
  455:         )
  456:         assert_equal(
  457:             np.array2string(a, max_line_width=5, legacy='1.13'),
  458:             "[ 'xxxxx']"
  459:         )
  460: 
  461:     def test_multiline_repr(self):
  462:         class MultiLine:
  463:             def __repr__(self):
  464:                 return "Line 1\nLine 2"
  465: 
  466:         a = np.array([[None, MultiLine()], [MultiLine(), None]])
  467: 
  468:         assert_equal(
  469:             np.array2string(a),
  470:             '[[None Line 1\n'
  471:             '       Line 2]\n'
  472:             ' [Line 1\n'
  473:             '  Line 2 None]]'
  474:         )
  475:         assert_equal(
  476:             np.array2string(a, max_line_width=5),
  477:             '[[None\n'
  478:             '  Line 1\n'
  479:             '  Line 2]\n'
  480:             ' [Line 1\n'
  481:             '  Line 2\n'
  482:             '  None]]'
  483:         )
  484:         assert_equal(
  485:             repr(a),
  486:             'array([[None, Line 1\n'
  487:             '              Line 2],\n'
  488:             '       [Line 1\n'
  489:             '        Line 2, None]], dtype=object)'
  490:         )
  491: 
  492:         class MultiLineLong:
  493:             def __repr__(self):
  494:                 return "Line 1\nLooooooooooongestLine2\nLongerLine 3"
  495: 
  496:         a = np.array([[None, MultiLineLong()], [MultiLineLong(), None]])
  497:         assert_equal(
  498:             repr(a),
  499:             'array([[None, Line 1\n'
  500:             '              LooooooooooongestLine2\n'
  501:             '              LongerLine 3          ],\n'
  502:             '       [Line 1\n'
  503:             '        LooooooooooongestLine2\n'
  504:             '        LongerLine 3          , None]], dtype=object)'
  505:         )
  506:         assert_equal(
  507:             np.array_repr(a, 20),
  508:             'array([[None,\n'
  509:             '        Line 1\n'
  510:             '        LooooooooooongestLine2\n'
  511:             '        LongerLine 3          ],\n'
  512:             '       [Line 1\n'
  513:             '        LooooooooooongestLine2\n'
  514:             '        LongerLine 3          ,\n'
  515:             '        None]],\n'
  516:             '      dtype=object)'
  517:         )
  518: 
  519:     def test_nested_array_repr(self):
  520:         a = np.empty((2, 2), dtype=object)
  521:         a[0, 0] = np.eye(2)
  522:         a[0, 1] = np.eye(3)
  523:         a[1, 0] = None
  524:         a[1, 1] = np.ones((3, 1))
  525:         assert_equal(
  526:             repr(a),
  527:             'array([[array([[1., 0.],\n'
  528:             '               [0., 1.]]), array([[1., 0., 0.],\n'
  529:             '                                  [0., 1., 0.],\n'
  530:             '                                  [0., 0., 1.]])],\n'
  531:             '       [None, array([[1.],\n'
  532:             '                     [1.],\n'
  533:             '                     [1.]])]], dtype=object)'
  534:         )
  535: 
  536:     @given(hynp.from_dtype(np.dtype("U")))
  537:     def test_any_text(self, text):
  538:         # This test checks that, given any value that can be represented in an
  539:         # array of dtype("U") (i.e. unicode string), ...
  540:         a = np.array([text, text, text])
  541:         # casting a list of them to an array does not e.g. truncate the value
  542:         assert_equal(a[0], text)
  543:         text = text.item()  # use raw python strings for repr below
  544:         # and that np.array2string puts a newline in the expected location
  545:         expected_repr = f"[{text!r} {text!r}\n {text!r}]"
  546:         result = np.array2string(a, max_line_width=len(repr(text)) * 2 + 3)
  547:         assert_equal(result, expected_repr)
  548: 
  549:     @pytest.mark.skipif(not HAS_REFCOUNT, reason="Python lacks refcounts")
  550:     def test_refcount(self):
  551:         # make sure we do not hold references to the array due to a recursive
  552:         # closure (gh-10620)
  553:         gc.disable()
  554:         a = np.arange(2)
  555:         r1 = sys.getrefcount(a)
  556:         np.array2string(a)
  557:         np.array2string(a)
  558:         r2 = sys.getrefcount(a)
  559:         gc.collect()
  560:         gc.enable()
  561:         assert_(r1 == r2)
  562: 
  563:     def test_with_sign(self):
  564:         # mixed negative and positive value array
  565:         a = np.array([-2, 0, 3])
  566:         assert_equal(
  567:             np.array2string(a, sign='+'),
  568:             '[-2 +0 +3]'
  569:         )
  570:         assert_equal(
  571:             np.array2string(a, sign='-'),
  572:             '[-2  0  3]'
  573:         )
  574:         assert_equal(
  575:             np.array2string(a, sign=' '),
  576:             '[-2  0  3]'
  577:         )
  578:         # all non-negative array
  579:         a = np.array([2, 0, 3])
  580:         assert_equal(
  581:             np.array2string(a, sign='+'),
  582:             '[+2 +0 +3]'
  583:         )
  584:         assert_equal(
  585:             np.array2string(a, sign='-'),
  586:             '[2 0 3]'
  587:         )
  588:         assert_equal(
  589:             np.array2string(a, sign=' '),
  590:             '[ 2  0  3]'
  591:         )
  592:         # all negative array
  593:         a = np.array([-2, -1, -3])
  594:         assert_equal(
  595:             np.array2string(a, sign='+'),
  596:             '[-2 -1 -3]'
  597:         )
  598:         assert_equal(
  599:             np.array2string(a, sign='-'),
  600:             '[-2 -1 -3]'
  601:         )
  602:         assert_equal(
  603:             np.array2string(a, sign=' '),
  604:             '[-2 -1 -3]'
  605:         )
  606:         # 2d array mixed negative and positive
  607:         a = np.array([[10, -1, 1, 1], [10, 10, 10, 10]])
  608:         assert_equal(
  609:             np.array2string(a, sign='+'),
  610:             '[[+10  -1  +1  +1]\n [+10 +10 +10 +10]]'
  611:         )
  612:         assert_equal(
  613:             np.array2string(a, sign='-'),
  614:             '[[10 -1  1  1]\n [10 10 10 10]]'
  615:         )
  616:         assert_equal(
  617:             np.array2string(a, sign=' '),
  618:             '[[10 -1  1  1]\n [10 10 10 10]]'
  619:         )
  620:         # 2d array all positive
  621:         a = np.array([[10, 0, 1, 1], [10, 10, 10, 10]])
  622:         assert_equal(
  623:             np.array2string(a, sign='+'),
  624:             '[[+10  +0  +1  +1]\n [+10 +10 +10 +10]]'
  625:         )
  626:         assert_equal(
  627:             np.array2string(a, sign='-'),
  628:             '[[10  0  1  1]\n [10 10 10 10]]'
  629:         )
  630:         assert_equal(
  631:             np.array2string(a, sign=' '),
  632:             '[[ 10   0   1   1]\n [ 10  10  10  10]]'
  633:         )
  634:         # 2d array all negative
  635:         a = np.array([[-10, -1, -1, -1], [-10, -10, -10, -10]])
  636:         assert_equal(
  637:             np.array2string(a, sign='+'),
  638:             '[[-10  -1  -1  -1]\n [-10 -10 -10 -10]]'
  639:         )
  640:         assert_equal(
  641:             np.array2string(a, sign='-'),
  642:             '[[-10  -1  -1  -1]\n [-10 -10 -10 -10]]'
  643:         )
  644:         assert_equal(
  645:             np.array2string(a, sign=' '),
  646:             '[[-10  -1  -1  -1]\n [-10 -10 -10 -10]]'
  647:         )
  648: 
  649: 
  650: class TestPrintOptions:
  651:     """Test getting and setting global print options."""
  652: 
  653:     def setup_method(self):
  654:         self.oldopts = np.get_printoptions()
  655: 
  656:     def teardown_method(self):
  657:         np.set_printoptions(**self.oldopts)
  658: 
  659:     def test_basic(self):
  660:         x = np.array([1.5, 0, 1.234567890])
  661:         assert_equal(repr(x), "array([1.5       , 0.        , 1.23456789])")
  662:         ret = np.set_printoptions(precision=4)
  663:         assert_equal(repr(x), "array([1.5   , 0.    , 1.2346])")
  664:         assert ret is None
  665: 
  666:     def test_precision_zero(self):
  667:         np.set_printoptions(precision=0)
  668:         for values, string in (
  669:                 ([0.], "0."), ([.3], "0."), ([-.3], "-0."), ([.7], "1."),
  670:                 ([1.5], "2."), ([-1.5], "-2."), ([-15.34], "-15."),
  671:                 ([100.], "100."), ([.2, -1, 122.51], "  0.,  -1., 123."),
  672:                 ([0], "0"), ([-12], "-12"), ([complex(.3, -.7)], "0.-1.j")):
  673:             x = np.array(values)
  674:             assert_equal(repr(x), f"array([{string}])")
  675: 
  676:     def test_formatter(self):
  677:         x = np.arange(3)
  678:         np.set_printoptions(formatter={'all': lambda x: str(x - 1)})
  679:         assert_equal(repr(x), "array([-1, 0, 1])")
  680: 
  681:     def test_formatter_reset(self):
  682:         x = np.arange(3)
  683:         np.set_printoptions(formatter={'all': lambda x: str(x - 1)})
  684:         assert_equal(repr(x), "array([-1, 0, 1])")
  685:         np.set_printoptions(formatter={'int': None})
  686:         assert_equal(repr(x), "array([0, 1, 2])")
  687: 
  688:         np.set_printoptions(formatter={'all': lambda x: str(x - 1)})
  689:         assert_equal(repr(x), "array([-1, 0, 1])")
  690:         np.set_printoptions(formatter={'all': None})
  691:         assert_equal(repr(x), "array([0, 1, 2])")
  692: 
  693:         np.set_printoptions(formatter={'int': lambda x: str(x - 1)})
  694:         assert_equal(repr(x), "array([-1, 0, 1])")
  695:         np.set_printoptions(formatter={'int_kind': None})
  696:         assert_equal(repr(x), "array([0, 1, 2])")
  697: 
  698:         x = np.arange(3.)
  699:         np.set_printoptions(formatter={'float': lambda x: str(x - 1)})
  700:         assert_equal(repr(x), "array([-1.0, 0.0, 1.0])")
  701:         np.set_printoptions(formatter={'float_kind': None})
  702:         assert_equal(repr(x), "array([0., 1., 2.])")
  703: 
  704:     def test_override_repr(self):
  705:         x = np.arange(3)
  706:         np.set_printoptions(override_repr=lambda x: "FOO")
  707:         assert_equal(repr(x), "FOO")
  708:         np.set_printoptions(override_repr=None)
  709:         assert_equal(repr(x), "array([0, 1, 2])")
  710: 
  711:         with np.printoptions(override_repr=lambda x: "BAR"):
  712:             assert_equal(repr(x), "BAR")
  713:         assert_equal(repr(x), "array([0, 1, 2])")
  714: 
  715:     def test_0d_arrays(self):
  716:         assert_equal(str(np.array('cafГ©', '<U4')), 'cafГ©')
  717: 
  718:         assert_equal(repr(np.array('cafГ©', '<U4')),
  719:                      "array('cafГ©', dtype='<U4')")
  720:         assert_equal(str(np.array('test', np.str_)), 'test')
  721: 
  722:         a = np.zeros(1, dtype=[('a', '<i4', (3,))])
  723:         assert_equal(str(a[0]), '([0, 0, 0],)')
  724: 
  725:         assert_equal(repr(np.datetime64('2005-02-25')[...]),
  726:                      "array('2005-02-25', dtype='datetime64[D]')")
  727: 
  728:         assert_equal(repr(np.timedelta64('10', 'Y')[...]),
  729:                      "array(10, dtype='timedelta64[Y]')")
  730: 
  731:         # repr of 0d arrays is affected by printoptions
  732:         x = np.array(1)
  733:         np.set_printoptions(formatter={'all': lambda x: "test"})
  734:         assert_equal(repr(x), "array(test)")
  735:         # str is unaffected
  736:         assert_equal(str(x), "1")
  737: 
  738:         # check `style` arg raises
  739:         assert_warns(DeprecationWarning, np.array2string,
  740:                                          np.array(1.), style=repr)
  741:         # but not in legacy mode
  742:         np.array2string(np.array(1.), style=repr, legacy='1.13')
  743:         # gh-10934 style was broken in legacy mode, check it works
  744:         np.array2string(np.array(1.), legacy='1.13')
  745: 
  746:     def test_float_spacing(self):
  747:         x = np.array([1., 2., 3.])
  748:         y = np.array([1., 2., -10.])
  749:         z = np.array([100., 2., -1.])
  750:         w = np.array([-100., 2., 1.])
  751: 
  752:         assert_equal(repr(x), 'array([1., 2., 3.])')
  753:         assert_equal(repr(y), 'array([  1.,   2., -10.])')
  754:         assert_equal(repr(np.array(y[0])), 'array(1.)')
  755:         assert_equal(repr(np.array(y[-1])), 'array(-10.)')
  756:         assert_equal(repr(z), 'array([100.,   2.,  -1.])')
  757:         assert_equal(repr(w), 'array([-100.,    2.,    1.])')
  758: 
  759:         assert_equal(repr(np.array([np.nan, np.inf])), 'array([nan, inf])')
  760:         assert_equal(repr(np.array([np.nan, -np.inf])), 'array([ nan, -inf])')
  761: 
  762:         x = np.array([np.inf, 100000, 1.1234])
  763:         y = np.array([np.inf, 100000, -1.1234])
  764:         z = np.array([np.inf, 1.1234, -1e120])
  765:         np.set_printoptions(precision=2)
  766:         assert_equal(repr(x), 'array([     inf, 1.00e+05, 1.12e+00])')
  767:         assert_equal(repr(y), 'array([      inf,  1.00e+05, -1.12e+00])')
  768:         assert_equal(repr(z), 'array([       inf,  1.12e+000, -1.00e+120])')
  769: 
  770:     def test_bool_spacing(self):
  771:         assert_equal(repr(np.array([True, True])),
  772:                      'array([ True,  True])')
  773:         assert_equal(repr(np.array([True, False])),
  774:                      'array([ True, False])')
  775:         assert_equal(repr(np.array([True])),
  776:                      'array([ True])')
  777:         assert_equal(repr(np.array(True)),
  778:                      'array(True)')
  779:         assert_equal(repr(np.array(False)),
  780:                      'array(False)')
  781: 
  782:     def test_sign_spacing(self):
  783:         a = np.arange(4.)
  784:         b = np.array([1.234e9])
  785:         c = np.array([1.0 + 1.0j, 1.123456789 + 1.123456789j], dtype='c16')
  786: 
  787:         assert_equal(repr(a), 'array([0., 1., 2., 3.])')
  788:         assert_equal(repr(np.array(1.)), 'array(1.)')
  789:         assert_equal(repr(b), 'array([1.234e+09])')
  790:         assert_equal(repr(np.array([0.])), 'array([0.])')
  791:         assert_equal(repr(c),
  792:             "array([1.        +1.j        , 1.12345679+1.12345679j])")
  793:         assert_equal(repr(np.array([0., -0.])), 'array([ 0., -0.])')
  794: 
  795:         np.set_printoptions(sign=' ')
  796:         assert_equal(repr(a), 'array([ 0.,  1.,  2.,  3.])')
  797:         assert_equal(repr(np.array(1.)), 'array( 1.)')
  798:         assert_equal(repr(b), 'array([ 1.234e+09])')
  799:         assert_equal(repr(c),
  800:             "array([ 1.        +1.j        ,  1.12345679+1.12345679j])")
  801:         assert_equal(repr(np.array([0., -0.])), 'array([ 0., -0.])')
  802: 
  803:         np.set_printoptions(sign='+')
  804:         assert_equal(repr(a), 'array([+0., +1., +2., +3.])')
  805:         assert_equal(repr(np.array(1.)), 'array(+1.)')
  806:         assert_equal(repr(b), 'array([+1.234e+09])')
  807:         assert_equal(repr(c),
  808:             "array([+1.        +1.j        , +1.12345679+1.12345679j])")
  809: 
  810:         np.set_printoptions(legacy='1.13')
  811:         assert_equal(repr(a), 'array([ 0.,  1.,  2.,  3.])')
  812:         assert_equal(repr(b),  'array([  1.23400000e+09])')
  813:         assert_equal(repr(-b), 'array([ -1.23400000e+09])')
  814:         assert_equal(repr(np.array(1.)), 'array(1.0)')
  815:         assert_equal(repr(np.array([0.])), 'array([ 0.])')
  816:         assert_equal(repr(c),
  817:             "array([ 1.00000000+1.j        ,  1.12345679+1.12345679j])")
  818:         # gh-10383
  819:         assert_equal(str(np.array([-1., 10])), "[ -1.  10.]")
  820: 
  821:         assert_raises(TypeError, np.set_printoptions, wrongarg=True)
  822: 
  823:     def test_float_overflow_nowarn(self):
  824:         # make sure internal computations in FloatingFormat don't
  825:         # warn about overflow
  826:         repr(np.array([1e4, 0.1], dtype='f2'))
  827: 
  828:     def test_sign_spacing_structured(self):
  829:         a = np.ones(2, dtype='<f,<f')
  830:         assert_equal(repr(a),
  831:             "array([(1., 1.), (1., 1.)], dtype=[('f0', '<f4'), ('f1', '<f4')])")
  832:         assert_equal(repr(a[0]),
  833:             "np.void((1.0, 1.0), dtype=[('f0', '<f4'), ('f1', '<f4')])")
  834: 
  835:     def test_floatmode(self):
  836:         x = np.array([0.6104, 0.922, 0.457, 0.0906, 0.3733, 0.007244,
  837:                       0.5933, 0.947, 0.2383, 0.4226], dtype=np.float16)
  838:         y = np.array([0.2918820979355541, 0.5064172631089138,
  839:                       0.2848750619642916, 0.4342965294660567,
  840:                       0.7326538397312751, 0.3459503329096204,
  841:                       0.0862072768214508, 0.39112753029631175],
  842:                       dtype=np.float64)
  843:         z = np.arange(6, dtype=np.float16) / 10
  844:         c = np.array([1.0 + 1.0j, 1.123456789 + 1.123456789j], dtype='c16')
  845: 
  846:         # also make sure 1e23 is right (is between two fp numbers)
  847:         w = np.array([f'1e{i}' for i in range(25)], dtype=np.float64)
  848:         # note: we construct w from the strings `1eXX` instead of doing
  849:         # `10.**arange(24)` because it turns out the two are not equivalent in
  850:         # python. On some architectures `1e23 != 10.**23`.
  851:         wp = np.array([1.234e1, 1e2, 1e123])
  852: 
  853:         # unique mode
  854:         np.set_printoptions(floatmode='unique')
  855:         assert_equal(repr(x),
  856:             "array([0.6104  , 0.922   , 0.457   , 0.0906  , 0.3733  , 0.007244,\n"
  857:             "       0.5933  , 0.947   , 0.2383  , 0.4226  ], dtype=float16)")
  858:         assert_equal(repr(y),
  859:             "array([0.2918820979355541 , 0.5064172631089138 , 0.2848750619642916 ,\n"
  860:             "       0.4342965294660567 , 0.7326538397312751 , 0.3459503329096204 ,\n"
  861:             "       0.0862072768214508 , 0.39112753029631175])")
  862:         assert_equal(repr(z),
  863:             "array([0. , 0.1, 0.2, 0.3, 0.4, 0.5], dtype=float16)")
  864:         assert_equal(repr(w),
  865:             "array([1.e+00, 1.e+01, 1.e+02, 1.e+03, 1.e+04, 1.e+05, 1.e+06, 1.e+07,\n"
  866:             "       1.e+08, 1.e+09, 1.e+10, 1.e+11, 1.e+12, 1.e+13, 1.e+14, 1.e+15,\n"
  867:             "       1.e+16, 1.e+17, 1.e+18, 1.e+19, 1.e+20, 1.e+21, 1.e+22, 1.e+23,\n"
  868:             "       1.e+24])")
  869:         assert_equal(repr(wp), "array([1.234e+001, 1.000e+002, 1.000e+123])")
  870:         assert_equal(repr(c),
  871:             "array([1.         +1.j         , 1.123456789+1.123456789j])")
  872: 
  873:         # maxprec mode, precision=8
  874:         np.set_printoptions(floatmode='maxprec', precision=8)
  875:         assert_equal(repr(x),
  876:             "array([0.6104  , 0.922   , 0.457   , 0.0906  , 0.3733  , 0.007244,\n"
  877:             "       0.5933  , 0.947   , 0.2383  , 0.4226  ], dtype=float16)")
  878:         assert_equal(repr(y),
  879:             "array([0.2918821 , 0.50641726, 0.28487506, 0.43429653, 0.73265384,\n"
  880:             "       0.34595033, 0.08620728, 0.39112753])")
  881:         assert_equal(repr(z),
  882:             "array([0. , 0.1, 0.2, 0.3, 0.4, 0.5], dtype=float16)")
  883:         assert_equal(repr(w[::5]),
  884:             "array([1.e+00, 1.e+05, 1.e+10, 1.e+15, 1.e+20])")
  885:         assert_equal(repr(wp), "array([1.234e+001, 1.000e+002, 1.000e+123])")
  886:         assert_equal(repr(c),
  887:             "array([1.        +1.j        , 1.12345679+1.12345679j])")
  888: 
  889:         # fixed mode, precision=4
  890:         np.set_printoptions(floatmode='fixed', precision=4)
  891:         assert_equal(repr(x),
  892:             "array([0.6104, 0.9219, 0.4570, 0.0906, 0.3733, 0.0072, 0.5933, 0.9468,\n"
  893:             "       0.2383, 0.4226], dtype=float16)")
  894:         assert_equal(repr(y),
  895:             "array([0.2919, 0.5064, 0.2849, 0.4343, 0.7327, 0.3460, 0.0862, 0.3911])")
  896:         assert_equal(repr(z),
  897:             "array([0.0000, 0.1000, 0.2000, 0.3000, 0.3999, 0.5000], dtype=float16)")
  898:         assert_equal(repr(w[::5]),
  899:             "array([1.0000e+00, 1.0000e+05, 1.0000e+10, 1.0000e+15, 1.0000e+20])")
  900:         assert_equal(repr(wp), "array([1.2340e+001, 1.0000e+002, 1.0000e+123])")
  901:         assert_equal(repr(np.zeros(3)), "array([0.0000, 0.0000, 0.0000])")
  902:         assert_equal(repr(c),
  903:             "array([1.0000+1.0000j, 1.1235+1.1235j])")
  904:         # for larger precision, representation error becomes more apparent:
  905:         np.set_printoptions(floatmode='fixed', precision=8)
  906:         assert_equal(repr(z),
  907:             "array([0.00000000, 0.09997559, 0.19995117, 0.30004883, 0.39990234,\n"
  908:             "       0.50000000], dtype=float16)")
  909: 
  910:         # maxprec_equal  mode, precision=8
  911:         np.set_printoptions(floatmode='maxprec_equal', precision=8)
  912:         assert_equal(repr(x),
  913:             "array([0.610352, 0.921875, 0.457031, 0.090576, 0.373291, 0.007244,\n"
  914:             "       0.593262, 0.946777, 0.238281, 0.422607], dtype=float16)")
  915:         assert_equal(repr(y),
  916:             "array([0.29188210, 0.50641726, 0.28487506, 0.43429653, 0.73265384,\n"
  917:             "       0.34595033, 0.08620728, 0.39112753])")
  918:         assert_equal(repr(z),
  919:             "array([0.0, 0.1, 0.2, 0.3, 0.4, 0.5], dtype=float16)")
  920:         assert_equal(repr(w[::5]),
  921:             "array([1.e+00, 1.e+05, 1.e+10, 1.e+15, 1.e+20])")
  922:         assert_equal(repr(wp), "array([1.234e+001, 1.000e+002, 1.000e+123])")
  923:         assert_equal(repr(c),
  924:             "array([1.00000000+1.00000000j, 1.12345679+1.12345679j])")
  925: 
  926:         # test unique special case (gh-18609)
  927:         a = np.float64.fromhex('-1p-97')
  928:         assert_equal(np.float64(np.array2string(a, floatmode='unique')), a)
  929: 
  930:     test_cases_gh_28679 = [
  931:         (np.half([999, 999]), "[999. 999.]"),
  932:         (np.half([999, 1000]), "[9.99e+02 1.00e+03]"),
  933:         (np.single([999999, 999999]), "[999999. 999999.]"),
  934:         (np.single([999999, -1000000]), "[ 9.99999e+05 -1.00000e+06]"),
  935:         (
  936:             np.complex64([999999 + 999999j, 999999 + 999999j]),
  937:             "[999999.+999999.j 999999.+999999.j]"
  938:         ),
  939:         (
  940:             np.complex64([999999 + 999999j, 999999 + -1000000j]),
  941:             "[999999.+9.99999e+05j 999999.-1.00000e+06j]"
  942:         ),
  943:     ]
  944: 
  945:     @pytest.mark.parametrize("input_array, expected_str", test_cases_gh_28679)
  946:     def test_gh_28679(self, input_array, expected_str):
  947:         # test cutoff to exponent notation for half, single, and complex64
  948:         assert_equal(str(input_array), expected_str)
  949: 
  950:     test_cases_legacy_2_2 = [
  951:         (np.half([1.e3, 1.e4, 65504]), "[ 1000. 10000. 65504.]"),
  952:         (np.single([1.e6, 1.e7]), "[ 1000000. 10000000.]"),
  953:         (np.single([1.e7, 1.e8]), "[1.e+07 1.e+08]"),
  954:     ]
  955: 
  956:     @pytest.mark.parametrize("input_array, expected_str", test_cases_legacy_2_2)
  957:     def test_legacy_2_2_mode(self, input_array, expected_str):
  958:         # test legacy cutoff to exponent notation for half and single
  959:         with np.printoptions(legacy='2.2'):
  960:             assert_equal(str(input_array), expected_str)
  961: 
  962:     @pytest.mark.parametrize("legacy", ['1.13', '1.21', '1.25', '2.1', '2.2'])
  963:     def test_legacy_get_options(self, legacy):
  964:         # test legacy get options works okay
  965:         with np.printoptions(legacy=legacy):
  966:             p_opt = np.get_printoptions()
  967:             assert_equal(p_opt["legacy"], legacy)
  968: 
  969:     def test_legacy_mode_scalars(self):
  970:         # in legacy mode, str of floats get truncated, and complex scalars
  971:         # use * for non-finite imaginary part
  972:         np.set_printoptions(legacy='1.13')
  973:         assert_equal(str(np.float64(1.123456789123456789)), '1.12345678912')
  974:         assert_equal(str(np.complex128(complex(1, np.nan))), '(1+nan*j)')
  975: 
  976:         np.set_printoptions(legacy=False)
  977:         assert_equal(str(np.float64(1.123456789123456789)),
  978:                      '1.1234567891234568')
  979:         assert_equal(str(np.complex128(complex(1, np.nan))), '(1+nanj)')
  980: 
  981:     def test_legacy_stray_comma(self):
  982:         np.set_printoptions(legacy='1.13')
  983:         assert_equal(str(np.arange(10000)), '[   0    1    2 ..., 9997 9998 9999]')
  984: 
  985:         np.set_printoptions(legacy=False)
  986:         assert_equal(str(np.arange(10000)), '[   0    1    2 ... 9997 9998 9999]')
  987: 
  988:     def test_dtype_linewidth_wrapping(self):
  989:         np.set_printoptions(linewidth=75)
  990:         assert_equal(repr(np.arange(10, 20., dtype='f4')),
  991:             "array([10., 11., 12., 13., 14., 15., 16., 17., 18., 19.], dtype=float32)")
  992:         assert_equal(repr(np.arange(10, 23., dtype='f4')), textwrap.dedent("""\
  993:             array([10., 11., 12., 13., 14., 15., 16., 17., 18., 19., 20., 21., 22.],
  994:                   dtype=float32)"""))
  995: 
  996:         styp = '<U4'
  997:         assert_equal(repr(np.ones(3, dtype=styp)),
  998:             f"array(['1', '1', '1'], dtype='{styp}')")
  999:         assert_equal(repr(np.ones(12, dtype=styp)), textwrap.dedent(f"""\
 1000:             array(['1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'],
 1001:                   dtype='{styp}')"""))
 1002: 
 1003:     @pytest.mark.parametrize(
 1004:         ['native'],
 1005:         [
 1006:             ('bool',),
 1007:             ('uint8',),
 1008:             ('uint16',),
 1009:             ('uint32',),
 1010:             ('uint64',),
 1011:             ('int8',),
 1012:             ('int16',),
 1013:             ('int32',),
 1014:             ('int64',),
 1015:             ('float16',),
 1016:             ('float32',),
 1017:             ('float64',),
 1018:             ('U1',),     # 4-byte width string
 1019:         ],
 1020:     )
 1021:     def test_dtype_endianness_repr(self, native):
 1022:         '''
 1023:         there was an issue where
 1024:         repr(array([0], dtype='<u2')) and repr(array([0], dtype='>u2'))
 1025:         both returned the same thing:
 1026:         array([0], dtype=uint16)
 1027:         even though their dtypes have different endianness.
 1028:         '''
 1029:         native_dtype = np.dtype(native)
 1030:         non_native_dtype = native_dtype.newbyteorder()
 1031:         non_native_repr = repr(np.array([1], non_native_dtype))
 1032:         native_repr = repr(np.array([1], native_dtype))
 1033:         # preserve the sensible default of only showing dtype if nonstandard
 1034:         assert ('dtype' in native_repr) ^ (native_dtype in _typelessdata),\
 1035:                 ("an array's repr should show dtype if and only if the type "
 1036:                  'of the array is NOT one of the standard types '
 1037:                  '(e.g., int32, bool, float64).')
 1038:         if non_native_dtype.itemsize > 1:
 1039:             # if the type is >1 byte, the non-native endian version
 1040:             # must show endianness.
 1041:             assert non_native_repr != native_repr
 1042:             assert f"dtype='{non_native_dtype.byteorder}" in non_native_repr
 1043: 
 1044:     def test_linewidth_repr(self):
 1045:         a = np.full(7, fill_value=2)
 1046:         np.set_printoptions(linewidth=17)
 1047:         assert_equal(
 1048:             repr(a),
 1049:             textwrap.dedent("""\
 1050:             array([2, 2, 2,
 1051:                    2, 2, 2,
 1052:                    2])""")
 1053:         )
 1054:         np.set_printoptions(linewidth=17, legacy='1.13')
 1055:         assert_equal(
 1056:             repr(a),
 1057:             textwrap.dedent("""\
 1058:             array([2, 2, 2,
 1059:                    2, 2, 2, 2])""")
 1060:         )
 1061: 
 1062:         a = np.full(8, fill_value=2)
 1063: 
 1064:         np.set_printoptions(linewidth=18, legacy=False)
 1065:         assert_equal(
 1066:             repr(a),
 1067:             textwrap.dedent("""\
 1068:             array([2, 2, 2,
 1069:                    2, 2, 2,
 1070:                    2, 2])""")
 1071:         )
 1072: 
 1073:         np.set_printoptions(linewidth=18, legacy='1.13')
 1074:         assert_equal(
 1075:             repr(a),
 1076:             textwrap.dedent("""\
 1077:             array([2, 2, 2, 2,
 1078:                    2, 2, 2, 2])""")
 1079:         )
 1080: 
 1081:     def test_linewidth_str(self):
 1082:         a = np.full(18, fill_value=2)
 1083:         np.set_printoptions(linewidth=18)
 1084:         assert_equal(
 1085:             str(a),
 1086:             textwrap.dedent("""\
 1087:             [2 2 2 2 2 2 2 2
 1088:              2 2 2 2 2 2 2 2
 1089:              2 2]""")
 1090:         )
 1091:         np.set_printoptions(linewidth=18, legacy='1.13')
 1092:         assert_equal(
 1093:             str(a),
 1094:             textwrap.dedent("""\
 1095:             [2 2 2 2 2 2 2 2 2
 1096:              2 2 2 2 2 2 2 2 2]""")
 1097:         )
 1098: 
 1099:     def test_edgeitems(self):
 1100:         np.set_printoptions(edgeitems=1, threshold=1)
 1101:         a = np.arange(27).reshape((3, 3, 3))
 1102:         assert_equal(
 1103:             repr(a),
 1104:             textwrap.dedent("""\
 1105:             array([[[ 0, ...,  2],
 1106:                     ...,
 1107:                     [ 6, ...,  8]],
 1108: 
 1109:                    ...,
 1110: 
 1111:                    [[18, ..., 20],
 1112:                     ...,
 1113:                     [24, ..., 26]]], shape=(3, 3, 3))""")
 1114:         )
 1115: 
 1116:         b = np.zeros((3, 3, 1, 1))
 1117:         assert_equal(
 1118:             repr(b),
 1119:             textwrap.dedent("""\
 1120:             array([[[[0.]],
 1121: 
 1122:                     ...,
 1123: 
 1124:                     [[0.]]],
 1125: 
 1126: 
 1127:                    ...,
 1128: 
 1129: 
 1130:                    [[[0.]],
 1131: 
 1132:                     ...,
 1133: 
 1134:                     [[0.]]]], shape=(3, 3, 1, 1))""")
 1135:         )
 1136: 
 1137:         # 1.13 had extra trailing spaces, and was missing newlines
 1138:         try:
 1139:             np.set_printoptions(legacy='1.13')
 1140:             assert_equal(repr(a), (
 1141:                 "array([[[ 0, ...,  2],\n"
 1142:                 "        ..., \n"
 1143:                 "        [ 6, ...,  8]],\n"
 1144:                 "\n"
 1145:                 "       ..., \n"
 1146:                 "       [[18, ..., 20],\n"
 1147:                 "        ..., \n"
 1148:                 "        [24, ..., 26]]])")
 1149:             )
 1150:             assert_equal(repr(b), (
 1151:                 "array([[[[ 0.]],\n"
 1152:                 "\n"
 1153:                 "        ..., \n"
 1154:                 "        [[ 0.]]],\n"
 1155:                 "\n"
 1156:                 "\n"
 1157:                 "       ..., \n"
 1158:                 "       [[[ 0.]],\n"
 1159:                 "\n"
 1160:                 "        ..., \n"
 1161:                 "        [[ 0.]]]])")
 1162:             )
 1163:         finally:
 1164:             np.set_printoptions(legacy=False)
 1165: 
 1166:     def test_edgeitems_structured(self):
 1167:         np.set_printoptions(edgeitems=1, threshold=1)
 1168:         A = np.arange(5 * 2 * 3, dtype="<i8").view([('i', "<i8", (5, 2, 3))])
 1169:         reprA = (
 1170:             "array([([[[ 0, ...,  2], [ 3, ...,  5]], ..., "
 1171:             "[[24, ..., 26], [27, ..., 29]]],)],\n"
 1172:             "      dtype=[('i', '<i8', (5, 2, 3))])"
 1173:         )
 1174:         assert_equal(repr(A), reprA)
 1175: 
 1176:     def test_bad_args(self):
 1177:         assert_raises(ValueError, np.set_printoptions, threshold=float('nan'))
 1178:         assert_raises(TypeError, np.set_printoptions, threshold='1')
 1179:         assert_raises(TypeError, np.set_printoptions, threshold=b'1')
 1180: 
 1181:         assert_raises(TypeError, np.set_printoptions, precision='1')
 1182:         assert_raises(TypeError, np.set_printoptions, precision=1.5)
 1183: 
 1184: def test_unicode_object_array():
 1185:     expected = "array(['Г©'], dtype=object)"
 1186:     x = np.array(['\xe9'], dtype=object)
 1187:     assert_equal(repr(x), expected)
 1188: 
 1189: 
 1190: class TestContextManager:
 1191:     def test_ctx_mgr(self):
 1192:         # test that context manager actually works
 1193:         with np.printoptions(precision=2):
 1194:             s = str(np.array([2.0]) / 3)
 1195:         assert_equal(s, '[0.67]')
 1196: 
 1197:     def test_ctx_mgr_restores(self):
 1198:         # test that print options are actually restored
 1199:         opts = np.get_printoptions()
 1200:         with np.printoptions(precision=opts['precision'] - 1,
 1201:                              linewidth=opts['linewidth'] - 4):
 1202:             pass
 1203:         assert_equal(np.get_printoptions(), opts)
 1204: 
 1205:     def test_ctx_mgr_exceptions(self):
 1206:         # test that print options are restored even if an exception is raised
 1207:         opts = np.get_printoptions()
 1208:         try:
 1209:             with np.printoptions(precision=2, linewidth=11):
 1210:                 raise ValueError
 1211:         except ValueError:
 1212:             pass
 1213:         assert_equal(np.get_printoptions(), opts)
 1214: 
 1215:     def test_ctx_mgr_as_smth(self):
 1216:         opts = {"precision": 2}
 1217:         with np.printoptions(**opts) as ctx:
 1218:             saved_opts = ctx.copy()
 1219:         assert_equal({k: saved_opts[k] for k in opts}, opts)
 1220: 
 1221: 
 1222: @pytest.mark.parametrize("dtype", "bhilqpBHILQPefdgFDG")
 1223: @pytest.mark.parametrize("value", [0, 1])
 1224: def test_scalar_repr_numbers(dtype, value):
 1225:     # Test NEP 51 scalar repr (and legacy option) for numeric types
 1226:     dtype = np.dtype(dtype)
 1227:     scalar = np.array(value, dtype=dtype)[()]
 1228:     assert isinstance(scalar, np.generic)
 1229: 
 1230:     string = str(scalar)
 1231:     repr_string = string.strip("()")  # complex may have extra brackets
 1232:     representation = repr(scalar)
 1233:     if dtype.char == "g":
 1234:         assert representation == f"np.longdouble('{repr_string}')"
 1235:     elif dtype.char == 'G':
 1236:         assert representation == f"np.clongdouble('{repr_string}')"
 1237:     else:
 1238:         normalized_name = np.dtype(f"{dtype.kind}{dtype.itemsize}").type.__name__
 1239:         assert representation == f"np.{normalized_name}({repr_string})"
 1240: 
 1241:     with np.printoptions(legacy="1.25"):
 1242:         assert repr(scalar) == string
 1243: 
 1244: 
 1245: @pytest.mark.parametrize("scalar, legacy_repr, representation", [
 1246:         (np.True_, "True", "np.True_"),
 1247:         (np.bytes_(b'a'), "b'a'", "np.bytes_(b'a')"),
 1248:         (np.str_('a'), "'a'", "np.str_('a')"),
 1249:         (np.datetime64("2012"),
 1250:             "numpy.datetime64('2012')", "np.datetime64('2012')"),
 1251:         (np.timedelta64(1), "numpy.timedelta64(1)", "np.timedelta64(1)"),
 1252:         (np.void((True, 2), dtype="?,<i8"),
 1253:             "(True, 2)",
 1254:             "np.void((True, 2), dtype=[('f0', '?'), ('f1', '<i8')])"),
 1255:         (np.void((1, 2), dtype="<f8,>f4"),
 1256:             "(1., 2.)",
 1257:             "np.void((1.0, 2.0), dtype=[('f0', '<f8'), ('f1', '>f4')])"),
 1258:         (np.void(b'a'), r"void(b'\x61')", r"np.void(b'\x61')"),
 1259:     ])
 1260: def test_scalar_repr_special(scalar, legacy_repr, representation):
 1261:     # Test NEP 51 scalar repr (and legacy option) for numeric types
 1262:     assert repr(scalar) == representation
 1263: 
 1264:     with np.printoptions(legacy="1.25"):
 1265:         assert repr(scalar) == legacy_repr
 1266: 
 1267: def test_scalar_void_float_str():
 1268:     # Note that based on this currently we do not print the same as a tuple
 1269:     # would, since the tuple would include the repr() inside for floats, but
 1270:     # we do not do that.
 1271:     scalar = np.void((1.0, 2.0), dtype=[('f0', '<f8'), ('f1', '>f4')])
 1272:     assert str(scalar) == "(1.0, 2.0)"
 1273: 
 1274: @pytest.mark.skipif(IS_WASM, reason="wasm doesn't support asyncio")
 1275: @pytest.mark.skipif(sys.version_info < (3, 11),
 1276:                     reason="asyncio.barrier was added in Python 3.11")
 1277: def test_printoptions_asyncio_safe():
 1278:     asyncio = pytest.importorskip("asyncio")
 1279: 
 1280:     b = asyncio.Barrier(2)
 1281: 
 1282:     async def legacy_113():
 1283:         np.set_printoptions(legacy='1.13', precision=12)
 1284:         await b.wait()
 1285:         po = np.get_printoptions()
 1286:         assert po['legacy'] == '1.13'
 1287:         assert po['precision'] == 12
 1288:         orig_linewidth = po['linewidth']
 1289:         with np.printoptions(linewidth=34, legacy='1.21'):
 1290:             po = np.get_printoptions()
 1291:             assert po['legacy'] == '1.21'
 1292:             assert po['precision'] == 12
 1293:             assert po['linewidth'] == 34
 1294:         po = np.get_printoptions()
 1295:         assert po['linewidth'] == orig_linewidth
 1296:         assert po['legacy'] == '1.13'
 1297:         assert po['precision'] == 12
 1298: 
 1299:     async def legacy_125():
 1300:         np.set_printoptions(legacy='1.25', precision=7)
 1301:         await b.wait()
 1302:         po = np.get_printoptions()
 1303:         assert po['legacy'] == '1.25'
 1304:         assert po['precision'] == 7
 1305:         orig_linewidth = po['linewidth']
 1306:         with np.printoptions(linewidth=6, legacy='1.13'):
 1307:             po = np.get_printoptions()
 1308:             assert po['legacy'] == '1.13'
 1309:             assert po['precision'] == 7
 1310:             assert po['linewidth'] == 6
 1311:         po = np.get_printoptions()
 1312:         assert po['linewidth'] == orig_linewidth
 1313:         assert po['legacy'] == '1.25'
 1314:         assert po['precision'] == 7
 1315: 
 1316:     async def main():
 1317:         await asyncio.gather(legacy_125(), legacy_125())
 1318: 
 1319:     loop = asyncio.new_event_loop()
 1320:     asyncio.run(main())
 1321:     loop.close()
 1322: 
 1323: @pytest.mark.skipif(IS_WASM, reason="wasm doesn't support threads")
 1324: def test_multithreaded_array_printing():
 1325:     # the dragon4 implementation uses a static scratch space for performance
 1326:     # reasons this test makes sure it is set up in a thread-safe manner
 1327: 
 1328:     run_threaded(TestPrintOptions().test_floatmode, 500)
