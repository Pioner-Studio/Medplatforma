    1: import sys
    2: 
    3: import pytest
    4: from numpy._core._rational_tests import rational
    5: 
    6: import numpy as np
    7: import numpy._core.umath as ncu
    8: from numpy.testing import (
    9:     HAS_REFCOUNT,
   10:     assert_,
   11:     assert_array_equal,
   12:     assert_equal,
   13:     assert_raises,
   14:     assert_warns,
   15: )
   16: 
   17: 
   18: def test_array_array():
   19:     tobj = type(object)
   20:     ones11 = np.ones((1, 1), np.float64)
   21:     tndarray = type(ones11)
   22:     # Test is_ndarray
   23:     assert_equal(np.array(ones11, dtype=np.float64), ones11)
   24:     if HAS_REFCOUNT:
   25:         old_refcount = sys.getrefcount(tndarray)
   26:         np.array(ones11)
   27:         assert_equal(old_refcount, sys.getrefcount(tndarray))
   28: 
   29:     # test None
   30:     assert_equal(np.array(None, dtype=np.float64),
   31:                  np.array(np.nan, dtype=np.float64))
   32:     if HAS_REFCOUNT:
   33:         old_refcount = sys.getrefcount(tobj)
   34:         np.array(None, dtype=np.float64)
   35:         assert_equal(old_refcount, sys.getrefcount(tobj))
   36: 
   37:     # test scalar
   38:     assert_equal(np.array(1.0, dtype=np.float64),
   39:                  np.ones((), dtype=np.float64))
   40:     if HAS_REFCOUNT:
   41:         old_refcount = sys.getrefcount(np.float64)
   42:         np.array(np.array(1.0, dtype=np.float64), dtype=np.float64)
   43:         assert_equal(old_refcount, sys.getrefcount(np.float64))
   44: 
   45:     # test string
   46:     S2 = np.dtype((bytes, 2))
   47:     S3 = np.dtype((bytes, 3))
   48:     S5 = np.dtype((bytes, 5))
   49:     assert_equal(np.array(b"1.0", dtype=np.float64),
   50:                  np.ones((), dtype=np.float64))
   51:     assert_equal(np.array(b"1.0").dtype, S3)
   52:     assert_equal(np.array(b"1.0", dtype=bytes).dtype, S3)
   53:     assert_equal(np.array(b"1.0", dtype=S2), np.array(b"1."))
   54:     assert_equal(np.array(b"1", dtype=S5), np.ones((), dtype=S5))
   55: 
   56:     # test string
   57:     U2 = np.dtype((str, 2))
   58:     U3 = np.dtype((str, 3))
   59:     U5 = np.dtype((str, 5))
   60:     assert_equal(np.array("1.0", dtype=np.float64),
   61:                  np.ones((), dtype=np.float64))
   62:     assert_equal(np.array("1.0").dtype, U3)
   63:     assert_equal(np.array("1.0", dtype=str).dtype, U3)
   64:     assert_equal(np.array("1.0", dtype=U2), np.array("1."))
   65:     assert_equal(np.array("1", dtype=U5), np.ones((), dtype=U5))
   66: 
   67:     builtins = getattr(__builtins__, '__dict__', __builtins__)
   68:     assert_(hasattr(builtins, 'get'))
   69: 
   70:     # test memoryview
   71:     dat = np.array(memoryview(b'1.0'), dtype=np.float64)
   72:     assert_equal(dat, [49.0, 46.0, 48.0])
   73:     assert_(dat.dtype.type is np.float64)
   74: 
   75:     dat = np.array(memoryview(b'1.0'))
   76:     assert_equal(dat, [49, 46, 48])
   77:     assert_(dat.dtype.type is np.uint8)
   78: 
   79:     # test array interface
   80:     a = np.array(100.0, dtype=np.float64)
   81:     o = type("o", (object,),
   82:              {"__array_interface__": a.__array_interface__})
   83:     assert_equal(np.array(o, dtype=np.float64), a)
   84: 
   85:     # test array_struct interface
   86:     a = np.array([(1, 4.0, 'Hello'), (2, 6.0, 'World')],
   87:                  dtype=[('f0', int), ('f1', float), ('f2', str)])
   88:     o = type("o", (object,),
   89:              {"__array_struct__": a.__array_struct__})
   90:     # wasn't what I expected... is np.array(o) supposed to equal a ?
   91:     # instead we get a array([...], dtype=">V18")
   92:     assert_equal(bytes(np.array(o).data), bytes(a.data))
   93: 
   94:     # test array
   95:     def custom__array__(self, dtype=None, copy=None):
   96:         return np.array(100.0, dtype=dtype, copy=copy)
   97: 
   98:     o = type("o", (object,), {"__array__": custom__array__})()
   99:     assert_equal(np.array(o, dtype=np.float64), np.array(100.0, np.float64))
  100: 
  101:     # test recursion
  102:     nested = 1.5
  103:     for i in range(ncu.MAXDIMS):
  104:         nested = [nested]
  105: 
  106:     # no error
  107:     np.array(nested)
  108: 
  109:     # Exceeds recursion limit
  110:     assert_raises(ValueError, np.array, [nested], dtype=np.float64)
  111: 
  112:     # Try with lists...
  113:     # float32
  114:     assert_equal(np.array([None] * 10, dtype=np.float32),
  115:                  np.full((10,), np.nan, dtype=np.float32))
  116:     assert_equal(np.array([[None]] * 10, dtype=np.float32),
  117:                  np.full((10, 1), np.nan, dtype=np.float32))
  118:     assert_equal(np.array([[None] * 10], dtype=np.float32),
  119:                  np.full((1, 10), np.nan, dtype=np.float32))
  120:     assert_equal(np.array([[None] * 10] * 10, dtype=np.float32),
  121:                  np.full((10, 10), np.nan, dtype=np.float32))
  122:     # float64
  123:     assert_equal(np.array([None] * 10, dtype=np.float64),
  124:                  np.full((10,), np.nan, dtype=np.float64))
  125:     assert_equal(np.array([[None]] * 10, dtype=np.float64),
  126:                  np.full((10, 1), np.nan, dtype=np.float64))
  127:     assert_equal(np.array([[None] * 10], dtype=np.float64),
  128:                  np.full((1, 10), np.nan, dtype=np.float64))
  129:     assert_equal(np.array([[None] * 10] * 10, dtype=np.float64),
  130:                  np.full((10, 10), np.nan, dtype=np.float64))
  131: 
  132:     assert_equal(np.array([1.0] * 10, dtype=np.float64),
  133:                  np.ones((10,), dtype=np.float64))
  134:     assert_equal(np.array([[1.0]] * 10, dtype=np.float64),
  135:                  np.ones((10, 1), dtype=np.float64))
  136:     assert_equal(np.array([[1.0] * 10], dtype=np.float64),
  137:                  np.ones((1, 10), dtype=np.float64))
  138:     assert_equal(np.array([[1.0] * 10] * 10, dtype=np.float64),
  139:                  np.ones((10, 10), dtype=np.float64))
  140: 
  141:     # Try with tuples
  142:     assert_equal(np.array((None,) * 10, dtype=np.float64),
  143:                  np.full((10,), np.nan, dtype=np.float64))
  144:     assert_equal(np.array([(None,)] * 10, dtype=np.float64),
  145:                  np.full((10, 1), np.nan, dtype=np.float64))
  146:     assert_equal(np.array([(None,) * 10], dtype=np.float64),
  147:                  np.full((1, 10), np.nan, dtype=np.float64))
  148:     assert_equal(np.array([(None,) * 10] * 10, dtype=np.float64),
  149:                  np.full((10, 10), np.nan, dtype=np.float64))
  150: 
  151:     assert_equal(np.array((1.0,) * 10, dtype=np.float64),
  152:                  np.ones((10,), dtype=np.float64))
  153:     assert_equal(np.array([(1.0,)] * 10, dtype=np.float64),
  154:                  np.ones((10, 1), dtype=np.float64))
  155:     assert_equal(np.array([(1.0,) * 10], dtype=np.float64),
  156:                  np.ones((1, 10), dtype=np.float64))
  157:     assert_equal(np.array([(1.0,) * 10] * 10, dtype=np.float64),
  158:                  np.ones((10, 10), dtype=np.float64))
  159: 
  160: @pytest.mark.parametrize("array", [True, False])
  161: def test_array_impossible_casts(array):
  162:     # All builtin types can be forcibly cast, at least theoretically,
  163:     # but user dtypes cannot necessarily.
  164:     rt = rational(1, 2)
  165:     if array:
  166:         rt = np.array(rt)
  167:     with assert_raises(TypeError):
  168:         np.array(rt, dtype="M8")
  169: 
  170: 
  171: def test_array_astype():
  172:     a = np.arange(6, dtype='f4').reshape(2, 3)
  173:     # Default behavior: allows unsafe casts, keeps memory layout,
  174:     #                   always copies.
  175:     b = a.astype('i4')
  176:     assert_equal(a, b)
  177:     assert_equal(b.dtype, np.dtype('i4'))
  178:     assert_equal(a.strides, b.strides)
  179:     b = a.T.astype('i4')
  180:     assert_equal(a.T, b)
  181:     assert_equal(b.dtype, np.dtype('i4'))
  182:     assert_equal(a.T.strides, b.strides)
  183:     b = a.astype('f4')
  184:     assert_equal(a, b)
  185:     assert_(not (a is b))
  186: 
  187:     # copy=False parameter skips a copy
  188:     b = a.astype('f4', copy=False)
  189:     assert_(a is b)
  190: 
  191:     # order parameter allows overriding of the memory layout,
  192:     # forcing a copy if the layout is wrong
  193:     b = a.astype('f4', order='F', copy=False)
  194:     assert_equal(a, b)
  195:     assert_(not (a is b))
  196:     assert_(b.flags.f_contiguous)
  197: 
  198:     b = a.astype('f4', order='C', copy=False)
  199:     assert_equal(a, b)
  200:     assert_(a is b)
  201:     assert_(b.flags.c_contiguous)
  202: 
  203:     # casting parameter allows catching bad casts
  204:     b = a.astype('c8', casting='safe')
  205:     assert_equal(a, b)
  206:     assert_equal(b.dtype, np.dtype('c8'))
  207: 
  208:     assert_raises(TypeError, a.astype, 'i4', casting='safe')
  209: 
  210:     # subok=False passes through a non-subclassed array
  211:     b = a.astype('f4', subok=0, copy=False)
  212:     assert_(a is b)
  213: 
  214:     class MyNDArray(np.ndarray):
  215:         pass
  216: 
  217:     a = np.array([[0, 1, 2], [3, 4, 5]], dtype='f4').view(MyNDArray)
  218: 
  219:     # subok=True passes through a subclass
  220:     b = a.astype('f4', subok=True, copy=False)
  221:     assert_(a is b)
  222: 
  223:     # subok=True is default, and creates a subtype on a cast
  224:     b = a.astype('i4', copy=False)
  225:     assert_equal(a, b)
  226:     assert_equal(type(b), MyNDArray)
  227: 
  228:     # subok=False never returns a subclass
  229:     b = a.astype('f4', subok=False, copy=False)
  230:     assert_equal(a, b)
  231:     assert_(not (a is b))
  232:     assert_(type(b) is not MyNDArray)
  233: 
  234:     # Make sure converting from string object to fixed length string
  235:     # does not truncate.
  236:     a = np.array([b'a' * 100], dtype='O')
  237:     b = a.astype('S')
  238:     assert_equal(a, b)
  239:     assert_equal(b.dtype, np.dtype('S100'))
  240:     a = np.array(['a' * 100], dtype='O')
  241:     b = a.astype('U')
  242:     assert_equal(a, b)
  243:     assert_equal(b.dtype, np.dtype('U100'))
  244: 
  245:     # Same test as above but for strings shorter than 64 characters
  246:     a = np.array([b'a' * 10], dtype='O')
  247:     b = a.astype('S')
  248:     assert_equal(a, b)
  249:     assert_equal(b.dtype, np.dtype('S10'))
  250:     a = np.array(['a' * 10], dtype='O')
  251:     b = a.astype('U')
  252:     assert_equal(a, b)
  253:     assert_equal(b.dtype, np.dtype('U10'))
  254: 
  255:     a = np.array(123456789012345678901234567890, dtype='O').astype('S')
  256:     assert_array_equal(a, np.array(b'1234567890' * 3, dtype='S30'))
  257:     a = np.array(123456789012345678901234567890, dtype='O').astype('U')
  258:     assert_array_equal(a, np.array('1234567890' * 3, dtype='U30'))
  259: 
  260:     a = np.array([123456789012345678901234567890], dtype='O').astype('S')
  261:     assert_array_equal(a, np.array(b'1234567890' * 3, dtype='S30'))
  262:     a = np.array([123456789012345678901234567890], dtype='O').astype('U')
  263:     assert_array_equal(a, np.array('1234567890' * 3, dtype='U30'))
  264: 
  265:     a = np.array(123456789012345678901234567890, dtype='S')
  266:     assert_array_equal(a, np.array(b'1234567890' * 3, dtype='S30'))
  267:     a = np.array(123456789012345678901234567890, dtype='U')
  268:     assert_array_equal(a, np.array('1234567890' * 3, dtype='U30'))
  269: 
  270:     a = np.array('a\u0140', dtype='U')
  271:     b = np.ndarray(buffer=a, dtype='uint32', shape=2)
  272:     assert_(b.size == 2)
  273: 
  274:     a = np.array([1000], dtype='i4')
  275:     assert_raises(TypeError, a.astype, 'S1', casting='safe')
  276: 
  277:     a = np.array(1000, dtype='i4')
  278:     assert_raises(TypeError, a.astype, 'U1', casting='safe')
  279: 
  280:     # gh-24023
  281:     assert_raises(TypeError, a.astype)
  282: 
  283: @pytest.mark.parametrize("dt", ["S", "U"])
  284: def test_array_astype_to_string_discovery_empty(dt):
  285:     # See also gh-19085
  286:     arr = np.array([""], dtype=object)
  287:     # Note, the itemsize is the `0 -> 1` logic, which should change.
  288:     # The important part the test is rather that it does not error.
  289:     assert arr.astype(dt).dtype.itemsize == np.dtype(f"{dt}1").itemsize
  290: 
  291:     # check the same thing for `np.can_cast` (since it accepts arrays)
  292:     assert np.can_cast(arr, dt, casting="unsafe")
  293:     assert not np.can_cast(arr, dt, casting="same_kind")
  294:     # as well as for the object as a descriptor:
  295:     assert np.can_cast("O", dt, casting="unsafe")
  296: 
  297: @pytest.mark.parametrize("dt", ["d", "f", "S13", "U32"])
  298: def test_array_astype_to_void(dt):
  299:     dt = np.dtype(dt)
  300:     arr = np.array([], dtype=dt)
  301:     assert arr.astype("V").dtype.itemsize == dt.itemsize
  302: 
  303: def test_object_array_astype_to_void():
  304:     # This is different to `test_array_astype_to_void` as object arrays
  305:     # are inspected.  The default void is "V8" (8 is the length of double)
  306:     arr = np.array([], dtype="O").astype("V")
  307:     assert arr.dtype == "V8"
  308: 
  309: @pytest.mark.parametrize("t",
  310:     np._core.sctypes['uint'] +
  311:     np._core.sctypes['int'] +
  312:     np._core.sctypes['float']
  313: )
  314: def test_array_astype_warning(t):
  315:     # test ComplexWarning when casting from complex to float or int
  316:     a = np.array(10, dtype=np.complex128)
  317:     assert_warns(np.exceptions.ComplexWarning, a.astype, t)
  318: 
  319: @pytest.mark.parametrize(["dtype", "out_dtype"],
  320:         [(np.bytes_, np.bool),
  321:          (np.str_, np.bool),
  322:          (np.dtype("S10,S9"), np.dtype("?,?")),
  323:          # The following also checks unaligned unicode access:
  324:          (np.dtype("S7,U9"), np.dtype("?,?"))])
  325: def test_string_to_boolean_cast(dtype, out_dtype):
  326:     # Only the last two (empty) strings are falsy (the `\0` is stripped):
  327:     arr = np.array(
  328:             ["10", "10\0\0\0", "0\0\0", "0", "False", " ", "", "\0"],
  329:             dtype=dtype)
  330:     expected = np.array(
  331:             [True, True, True, True, True, True, False, False],
  332:             dtype=out_dtype)
  333:     assert_array_equal(arr.astype(out_dtype), expected)
  334:     # As it's similar, check that nonzero behaves the same (structs are
  335:     # nonzero if all entries are)
  336:     assert_array_equal(np.nonzero(arr), np.nonzero(expected))
  337: 
  338: @pytest.mark.parametrize("str_type", [str, bytes, np.str_])
  339: @pytest.mark.parametrize("scalar_type",
  340:         [np.complex64, np.complex128, np.clongdouble])
  341: def test_string_to_complex_cast(str_type, scalar_type):
  342:     value = scalar_type(b"1+3j")
  343:     assert scalar_type(value) == 1 + 3j
  344:     assert np.array([value], dtype=object).astype(scalar_type)[()] == 1 + 3j
  345:     assert np.array(value).astype(scalar_type)[()] == 1 + 3j
  346:     arr = np.zeros(1, dtype=scalar_type)
  347:     arr[0] = value
  348:     assert arr[0] == 1 + 3j
  349: 
  350: @pytest.mark.parametrize("dtype", np.typecodes["AllFloat"])
  351: def test_none_to_nan_cast(dtype):
  352:     # Note that at the time of writing this test, the scalar constructors
  353:     # reject None
  354:     arr = np.zeros(1, dtype=dtype)
  355:     arr[0] = None
  356:     assert np.isnan(arr)[0]
  357:     assert np.isnan(np.array(None, dtype=dtype))[()]
  358:     assert np.isnan(np.array([None], dtype=dtype))[0]
  359:     assert np.isnan(np.array(None).astype(dtype))[()]
  360: 
  361: def test_copyto_fromscalar():
  362:     a = np.arange(6, dtype='f4').reshape(2, 3)
  363: 
  364:     # Simple copy
  365:     np.copyto(a, 1.5)
  366:     assert_equal(a, 1.5)
  367:     np.copyto(a.T, 2.5)
  368:     assert_equal(a, 2.5)
  369: 
  370:     # Where-masked copy
  371:     mask = np.array([[0, 1, 0], [0, 0, 1]], dtype='?')
  372:     np.copyto(a, 3.5, where=mask)
  373:     assert_equal(a, [[2.5, 3.5, 2.5], [2.5, 2.5, 3.5]])
  374:     mask = np.array([[0, 1], [1, 1], [1, 0]], dtype='?')
  375:     np.copyto(a.T, 4.5, where=mask)
  376:     assert_equal(a, [[2.5, 4.5, 4.5], [4.5, 4.5, 3.5]])
  377: 
  378: def test_copyto():
  379:     a = np.arange(6, dtype='i4').reshape(2, 3)
  380: 
  381:     # Simple copy
  382:     np.copyto(a, [[3, 1, 5], [6, 2, 1]])
  383:     assert_equal(a, [[3, 1, 5], [6, 2, 1]])
  384: 
  385:     # Overlapping copy should work
  386:     np.copyto(a[:, :2], a[::-1, 1::-1])
  387:     assert_equal(a, [[2, 6, 5], [1, 3, 1]])
  388: 
  389:     # Defaults to 'same_kind' casting
  390:     assert_raises(TypeError, np.copyto, a, 1.5)
  391: 
  392:     # Force a copy with 'unsafe' casting, truncating 1.5 to 1
  393:     np.copyto(a, 1.5, casting='unsafe')
  394:     assert_equal(a, 1)
  395: 
  396:     # Copying with a mask
  397:     np.copyto(a, 3, where=[True, False, True])
  398:     assert_equal(a, [[3, 1, 3], [3, 1, 3]])
  399: 
  400:     # Casting rule still applies with a mask
  401:     assert_raises(TypeError, np.copyto, a, 3.5, where=[True, False, True])
  402: 
  403:     # Lists of integer 0's and 1's is ok too
  404:     np.copyto(a, 4.0, casting='unsafe', where=[[0, 1, 1], [1, 0, 0]])
  405:     assert_equal(a, [[3, 4, 4], [4, 1, 3]])
  406: 
  407:     # Overlapping copy with mask should work
  408:     np.copyto(a[:, :2], a[::-1, 1::-1], where=[[0, 1], [1, 1]])
  409:     assert_equal(a, [[3, 4, 4], [4, 3, 3]])
  410: 
  411:     # 'dst' must be an array
  412:     assert_raises(TypeError, np.copyto, [1, 2, 3], [2, 3, 4])
  413: 
  414: 
  415: def test_copyto_cast_safety():
  416:     with pytest.raises(TypeError):
  417:         np.copyto(np.arange(3), 3., casting="safe")
  418: 
  419:     # Can put integer and float scalars safely (and equiv):
  420:     np.copyto(np.arange(3), 3, casting="equiv")
  421:     np.copyto(np.arange(3.), 3., casting="equiv")
  422:     # And also with less precision safely:
  423:     np.copyto(np.arange(3, dtype="uint8"), 3, casting="safe")
  424:     np.copyto(np.arange(3., dtype="float32"), 3., casting="safe")
  425: 
  426:     # But not equiv:
  427:     with pytest.raises(TypeError):
  428:         np.copyto(np.arange(3, dtype="uint8"), 3, casting="equiv")
  429: 
  430:     with pytest.raises(TypeError):
  431:         np.copyto(np.arange(3., dtype="float32"), 3., casting="equiv")
  432: 
  433:     # As a special thing, object is equiv currently:
  434:     np.copyto(np.arange(3, dtype=object), 3, casting="equiv")
  435: 
  436:     # The following raises an overflow error/gives a warning but not
  437:     # type error (due to casting), though:
  438:     with pytest.raises(OverflowError):
  439:         np.copyto(np.arange(3), 2**80, casting="safe")
  440: 
  441:     with pytest.warns(RuntimeWarning):
  442:         np.copyto(np.arange(3, dtype=np.float32), 2e300, casting="safe")
  443: 
  444: 
  445: def test_copyto_permut():
  446:     # test explicit overflow case
  447:     pad = 500
  448:     l = [True] * pad + [True, True, True, True]
  449:     r = np.zeros(len(l) - pad)
  450:     d = np.ones(len(l) - pad)
  451:     mask = np.array(l)[pad:]
  452:     np.copyto(r, d, where=mask[::-1])
  453: 
  454:     # test all permutation of possible masks, 9 should be sufficient for
  455:     # current 4 byte unrolled code
  456:     power = 9
  457:     d = np.ones(power)
  458:     for i in range(2**power):
  459:         r = np.zeros(power)
  460:         l = [(i & x) != 0 for x in range(power)]
  461:         mask = np.array(l)
  462:         np.copyto(r, d, where=mask)
  463:         assert_array_equal(r == 1, l)
  464:         assert_equal(r.sum(), sum(l))
  465: 
  466:         r = np.zeros(power)
  467:         np.copyto(r, d, where=mask[::-1])
  468:         assert_array_equal(r == 1, l[::-1])
  469:         assert_equal(r.sum(), sum(l))
  470: 
  471:         r = np.zeros(power)
  472:         np.copyto(r[::2], d[::2], where=mask[::2])
  473:         assert_array_equal(r[::2] == 1, l[::2])
  474:         assert_equal(r[::2].sum(), sum(l[::2]))
  475: 
  476:         r = np.zeros(power)
  477:         np.copyto(r[::2], d[::2], where=mask[::-2])
  478:         assert_array_equal(r[::2] == 1, l[::-2])
  479:         assert_equal(r[::2].sum(), sum(l[::-2]))
  480: 
  481:         for c in [0xFF, 0x7F, 0x02, 0x10]:
  482:             r = np.zeros(power)
  483:             mask = np.array(l)
  484:             imask = np.array(l).view(np.uint8)
  485:             imask[mask != 0] = c
  486:             np.copyto(r, d, where=mask)
  487:             assert_array_equal(r == 1, l)
  488:             assert_equal(r.sum(), sum(l))
  489: 
  490:     r = np.zeros(power)
  491:     np.copyto(r, d, where=True)
  492:     assert_equal(r.sum(), r.size)
  493:     r = np.ones(power)
  494:     d = np.zeros(power)
  495:     np.copyto(r, d, where=False)
  496:     assert_equal(r.sum(), r.size)
  497: 
  498: def test_copy_order():
  499:     a = np.arange(24).reshape(2, 1, 3, 4)
  500:     b = a.copy(order='F')
  501:     c = np.arange(24).reshape(2, 1, 4, 3).swapaxes(2, 3)
  502: 
  503:     def check_copy_result(x, y, ccontig, fcontig, strides=False):
  504:         assert_(not (x is y))
  505:         assert_equal(x, y)
  506:         assert_equal(res.flags.c_contiguous, ccontig)
  507:         assert_equal(res.flags.f_contiguous, fcontig)
  508: 
  509:     # Validate the initial state of a, b, and c
  510:     assert_(a.flags.c_contiguous)
  511:     assert_(not a.flags.f_contiguous)
  512:     assert_(not b.flags.c_contiguous)
  513:     assert_(b.flags.f_contiguous)
  514:     assert_(not c.flags.c_contiguous)
  515:     assert_(not c.flags.f_contiguous)
  516: 
  517:     # Copy with order='C'
  518:     res = a.copy(order='C')
  519:     check_copy_result(res, a, ccontig=True, fcontig=False, strides=True)
  520:     res = b.copy(order='C')
  521:     check_copy_result(res, b, ccontig=True, fcontig=False, strides=False)
  522:     res = c.copy(order='C')
  523:     check_copy_result(res, c, ccontig=True, fcontig=False, strides=False)
  524:     res = np.copy(a, order='C')
  525:     check_copy_result(res, a, ccontig=True, fcontig=False, strides=True)
  526:     res = np.copy(b, order='C')
  527:     check_copy_result(res, b, ccontig=True, fcontig=False, strides=False)
  528:     res = np.copy(c, order='C')
  529:     check_copy_result(res, c, ccontig=True, fcontig=False, strides=False)
  530: 
  531:     # Copy with order='F'
  532:     res = a.copy(order='F')
  533:     check_copy_result(res, a, ccontig=False, fcontig=True, strides=False)
  534:     res = b.copy(order='F')
  535:     check_copy_result(res, b, ccontig=False, fcontig=True, strides=True)
  536:     res = c.copy(order='F')
  537:     check_copy_result(res, c, ccontig=False, fcontig=True, strides=False)
  538:     res = np.copy(a, order='F')
  539:     check_copy_result(res, a, ccontig=False, fcontig=True, strides=False)
  540:     res = np.copy(b, order='F')
  541:     check_copy_result(res, b, ccontig=False, fcontig=True, strides=True)
  542:     res = np.copy(c, order='F')
  543:     check_copy_result(res, c, ccontig=False, fcontig=True, strides=False)
  544: 
  545:     # Copy with order='K'
  546:     res = a.copy(order='K')
  547:     check_copy_result(res, a, ccontig=True, fcontig=False, strides=True)
  548:     res = b.copy(order='K')
  549:     check_copy_result(res, b, ccontig=False, fcontig=True, strides=True)
  550:     res = c.copy(order='K')
  551:     check_copy_result(res, c, ccontig=False, fcontig=False, strides=True)
  552:     res = np.copy(a, order='K')
  553:     check_copy_result(res, a, ccontig=True, fcontig=False, strides=True)
  554:     res = np.copy(b, order='K')
  555:     check_copy_result(res, b, ccontig=False, fcontig=True, strides=True)
  556:     res = np.copy(c, order='K')
  557:     check_copy_result(res, c, ccontig=False, fcontig=False, strides=True)
  558: 
  559: def test_contiguous_flags():
  560:     a = np.ones((4, 4, 1))[::2, :, :]
  561:     a.strides = a.strides[:2] + (-123,)
  562:     b = np.ones((2, 2, 1, 2, 2)).swapaxes(3, 4)
  563: 
  564:     def check_contig(a, ccontig, fcontig):
  565:         assert_(a.flags.c_contiguous == ccontig)
  566:         assert_(a.flags.f_contiguous == fcontig)
  567: 
  568:     # Check if new arrays are correct:
  569:     check_contig(a, False, False)
  570:     check_contig(b, False, False)
  571:     check_contig(np.empty((2, 2, 0, 2, 2)), True, True)
  572:     check_contig(np.array([[[1], [2]]], order='F'), True, True)
  573:     check_contig(np.empty((2, 2)), True, False)
  574:     check_contig(np.empty((2, 2), order='F'), False, True)
  575: 
  576:     # Check that np.array creates correct contiguous flags:
  577:     check_contig(np.array(a, copy=None), False, False)
  578:     check_contig(np.array(a, copy=None, order='C'), True, False)
  579:     check_contig(np.array(a, ndmin=4, copy=None, order='F'), False, True)
  580: 
  581:     # Check slicing update of flags and :
  582:     check_contig(a[0], True, True)
  583:     check_contig(a[None, ::4, ..., None], True, True)
  584:     check_contig(b[0, 0, ...], False, True)
  585:     check_contig(b[:, :, 0:0, :, :], True, True)
  586: 
  587:     # Test ravel and squeeze.
  588:     check_contig(a.ravel(), True, True)
  589:     check_contig(np.ones((1, 3, 1)).squeeze(), True, True)
  590: 
  591: def test_broadcast_arrays():
  592:     # Test user defined dtypes
  593:     a = np.array([(1, 2, 3)], dtype='u4,u4,u4')
  594:     b = np.array([(1, 2, 3), (4, 5, 6), (7, 8, 9)], dtype='u4,u4,u4')
  595:     result = np.broadcast_arrays(a, b)
  596:     assert_equal(result[0], np.array([(1, 2, 3), (1, 2, 3), (1, 2, 3)], dtype='u4,u4,u4'))
  597:     assert_equal(result[1], np.array([(1, 2, 3), (4, 5, 6), (7, 8, 9)], dtype='u4,u4,u4'))
  598: 
  599: @pytest.mark.parametrize(["shape", "fill_value", "expected_output"],
  600:         [((2, 2), [5.0,  6.0], np.array([[5.0, 6.0], [5.0, 6.0]])),
  601:          ((3, 2), [1.0,  2.0], np.array([[1.0, 2.0], [1.0, 2.0], [1.0,  2.0]]))])
  602: def test_full_from_list(shape, fill_value, expected_output):
  603:     output = np.full(shape, fill_value)
  604:     assert_equal(output, expected_output)
  605: 
  606: def test_astype_copyflag():
  607:     # test the various copyflag options
  608:     arr = np.arange(10, dtype=np.intp)
  609: 
  610:     res_true = arr.astype(np.intp, copy=True)
  611:     assert not np.shares_memory(arr, res_true)
  612: 
  613:     res_false = arr.astype(np.intp, copy=False)
  614:     assert np.shares_memory(arr, res_false)
  615: 
  616:     res_false_float = arr.astype(np.float64, copy=False)
  617:     assert not np.shares_memory(arr, res_false_float)
  618: 
  619:     # _CopyMode enum isn't allowed
  620:     assert_raises(ValueError, arr.astype, np.float64,
  621:                   copy=np._CopyMode.NEVER)
