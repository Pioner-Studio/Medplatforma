    1: import os
    2: import pathlib
    3: import platform
    4: import re
    5: import subprocess
    6: import sys
    7: 
    8: import pytest
    9: from numpy._core._multiarray_umath import (
   10:     __cpu_baseline__,
   11:     __cpu_dispatch__,
   12:     __cpu_features__,
   13: )
   14: 
   15: 
   16: def assert_features_equal(actual, desired, fname):
   17:     __tracebackhide__ = True  # Hide traceback for py.test
   18:     actual, desired = str(actual), str(desired)
   19:     if actual == desired:
   20:         return
   21:     detected = str(__cpu_features__).replace("'", "")
   22:     try:
   23:         with open("/proc/cpuinfo") as fd:
   24:             cpuinfo = fd.read(2048)
   25:     except Exception as err:
   26:         cpuinfo = str(err)
   27: 
   28:     try:
   29:         import subprocess
   30:         auxv = subprocess.check_output(['/bin/true'], env={"LD_SHOW_AUXV": "1"})
   31:         auxv = auxv.decode()
   32:     except Exception as err:
   33:         auxv = str(err)
   34: 
   35:     import textwrap
   36:     error_report = textwrap.indent(
   37: f"""
   38: ###########################################
   39: ### Extra debugging information
   40: ###########################################
   41: -------------------------------------------
   42: --- NumPy Detections
   43: -------------------------------------------
   44: {detected}
   45: -------------------------------------------
   46: --- SYS / CPUINFO
   47: -------------------------------------------
   48: {cpuinfo}....
   49: -------------------------------------------
   50: --- SYS / AUXV
   51: -------------------------------------------
   52: {auxv}
   53: """, prefix='\r')
   54: 
   55:     raise AssertionError((
   56:         "Failure Detection\n"
   57:         " NAME: '%s'\n"
   58:         " ACTUAL: %s\n"
   59:         " DESIRED: %s\n"
   60:         "%s"
   61:     ) % (fname, actual, desired, error_report))
   62: 
   63: def _text_to_list(txt):
   64:     out = txt.strip("][\n").replace("'", "").split(', ')
   65:     return None if out[0] == "" else out
   66: 
   67: class AbstractTest:
   68:     features = []
   69:     features_groups = {}
   70:     features_map = {}
   71:     features_flags = set()
   72: 
   73:     def load_flags(self):
   74:         # a hook
   75:         pass
   76: 
   77:     def test_features(self):
   78:         self.load_flags()
   79:         for gname, features in self.features_groups.items():
   80:             test_features = [self.cpu_have(f) for f in features]
   81:             assert_features_equal(__cpu_features__.get(gname), all(test_features), gname)
   82: 
   83:         for feature_name in self.features:
   84:             cpu_have = self.cpu_have(feature_name)
   85:             npy_have = __cpu_features__.get(feature_name)
   86:             assert_features_equal(npy_have, cpu_have, feature_name)
   87: 
   88:     def cpu_have(self, feature_name):
   89:         map_names = self.features_map.get(feature_name, feature_name)
   90:         if isinstance(map_names, str):
   91:             return map_names in self.features_flags
   92:         return any(f in self.features_flags for f in map_names)
   93: 
   94:     def load_flags_cpuinfo(self, magic_key):
   95:         self.features_flags = self.get_cpuinfo_item(magic_key)
   96: 
   97:     def get_cpuinfo_item(self, magic_key):
   98:         values = set()
   99:         with open('/proc/cpuinfo') as fd:
  100:             for line in fd:
  101:                 if not line.startswith(magic_key):
  102:                     continue
  103:                 flags_value = [s.strip() for s in line.split(':', 1)]
  104:                 if len(flags_value) == 2:
  105:                     values = values.union(flags_value[1].upper().split())
  106:         return values
  107: 
  108:     def load_flags_auxv(self):
  109:         auxv = subprocess.check_output(['/bin/true'], env={"LD_SHOW_AUXV": "1"})
  110:         for at in auxv.split(b'\n'):
  111:             if not at.startswith(b"AT_HWCAP"):
  112:                 continue
  113:             hwcap_value = [s.strip() for s in at.split(b':', 1)]
  114:             if len(hwcap_value) == 2:
  115:                 self.features_flags = self.features_flags.union(
  116:                     hwcap_value[1].upper().decode().split()
  117:                 )
  118: 
  119: @pytest.mark.skipif(
  120:     sys.platform == 'emscripten',
  121:     reason=(
  122:         "The subprocess module is not available on WASM platforms and"
  123:         " therefore this test class cannot be properly executed."
  124:     ),
  125: )
  126: class TestEnvPrivation:
  127:     cwd = pathlib.Path(__file__).parent.resolve()
  128:     env = os.environ.copy()
  129:     _enable = os.environ.pop('NPY_ENABLE_CPU_FEATURES', None)
  130:     _disable = os.environ.pop('NPY_DISABLE_CPU_FEATURES', None)
  131:     SUBPROCESS_ARGS = {"cwd": cwd, "capture_output": True, "text": True, "check": True}
  132:     unavailable_feats = [
  133:         feat for feat in __cpu_dispatch__ if not __cpu_features__[feat]
  134:     ]
  135:     UNAVAILABLE_FEAT = (
  136:         None if len(unavailable_feats) == 0
  137:         else unavailable_feats[0]
  138:     )
  139:     BASELINE_FEAT = None if len(__cpu_baseline__) == 0 else __cpu_baseline__[0]
  140:     SCRIPT = """
  141: def main():
  142:     from numpy._core._multiarray_umath import (
  143:         __cpu_features__,
  144:         __cpu_dispatch__
  145:     )
  146: 
  147:     detected = [feat for feat in __cpu_dispatch__ if __cpu_features__[feat]]
  148:     print(detected)
  149: 
  150: if __name__ == "__main__":
  151:     main()
  152:     """
  153: 
  154:     @pytest.fixture(autouse=True)
  155:     def setup_class(self, tmp_path_factory):
  156:         file = tmp_path_factory.mktemp("runtime_test_script")
  157:         file /= "_runtime_detect.py"
  158:         file.write_text(self.SCRIPT)
  159:         self.file = file
  160: 
  161:     def _run(self):
  162:         return subprocess.run(
  163:             [sys.executable, self.file],
  164:             env=self.env,
  165:             **self.SUBPROCESS_ARGS,
  166:             )
  167: 
  168:     # Helper function mimicking pytest.raises for subprocess call
  169:     def _expect_error(
  170:         self,
  171:         msg,
  172:         err_type,
  173:         no_error_msg="Failed to generate error"
  174:     ):
  175:         try:
  176:             self._run()
  177:         except subprocess.CalledProcessError as e:
  178:             assertion_message = f"Expected: {msg}\nGot: {e.stderr}"
  179:             assert re.search(msg, e.stderr), assertion_message
  180: 
  181:             assertion_message = (
  182:                 f"Expected error of type: {err_type}; see full "
  183:                 f"error:\n{e.stderr}"
  184:             )
  185:             assert re.search(err_type, e.stderr), assertion_message
  186:         else:
  187:             assert False, no_error_msg
  188: 
  189:     def setup_method(self):
  190:         """Ensure that the environment is reset"""
  191:         self.env = os.environ.copy()
  192: 
  193:     def test_runtime_feature_selection(self):
  194:         """
  195:         Ensure that when selecting `NPY_ENABLE_CPU_FEATURES`, only the
  196:         features exactly specified are dispatched.
  197:         """
  198: 
  199:         # Capture runtime-enabled features
  200:         out = self._run()
  201:         non_baseline_features = _text_to_list(out.stdout)
  202: 
  203:         if non_baseline_features is None:
  204:             pytest.skip(
  205:                 "No dispatchable features outside of baseline detected."
  206:             )
  207:         feature = non_baseline_features[0]
  208: 
  209:         # Capture runtime-enabled features when `NPY_ENABLE_CPU_FEATURES` is
  210:         # specified
  211:         self.env['NPY_ENABLE_CPU_FEATURES'] = feature
  212:         out = self._run()
  213:         enabled_features = _text_to_list(out.stdout)
  214: 
  215:         # Ensure that only one feature is enabled, and it is exactly the one
  216:         # specified by `NPY_ENABLE_CPU_FEATURES`
  217:         assert set(enabled_features) == {feature}
  218: 
  219:         if len(non_baseline_features) < 2:
  220:             pytest.skip("Only one non-baseline feature detected.")
  221:         # Capture runtime-enabled features when `NPY_ENABLE_CPU_FEATURES` is
  222:         # specified
  223:         self.env['NPY_ENABLE_CPU_FEATURES'] = ",".join(non_baseline_features)
  224:         out = self._run()
  225:         enabled_features = _text_to_list(out.stdout)
  226: 
  227:         # Ensure that both features are enabled, and they are exactly the ones
  228:         # specified by `NPY_ENABLE_CPU_FEATURES`
  229:         assert set(enabled_features) == set(non_baseline_features)
  230: 
  231:     @pytest.mark.parametrize("enabled, disabled",
  232:     [
  233:         ("feature", "feature"),
  234:         ("feature", "same"),
  235:     ])
  236:     def test_both_enable_disable_set(self, enabled, disabled):
  237:         """
  238:         Ensure that when both environment variables are set then an
  239:         ImportError is thrown
  240:         """
  241:         self.env['NPY_ENABLE_CPU_FEATURES'] = enabled
  242:         self.env['NPY_DISABLE_CPU_FEATURES'] = disabled
  243:         msg = "Both NPY_DISABLE_CPU_FEATURES and NPY_ENABLE_CPU_FEATURES"
  244:         err_type = "ImportError"
  245:         self._expect_error(msg, err_type)
  246: 
  247:     @pytest.mark.skipif(
  248:         not __cpu_dispatch__,
  249:         reason=(
  250:             "NPY_*_CPU_FEATURES only parsed if "
  251:             "`__cpu_dispatch__` is non-empty"
  252:         )
  253:     )
  254:     @pytest.mark.parametrize("action", ["ENABLE", "DISABLE"])
  255:     def test_variable_too_long(self, action):
  256:         """
  257:         Test that an error is thrown if the environment variables are too long
  258:         to be processed. Current limit is 1024, but this may change later.
  259:         """
  260:         MAX_VAR_LENGTH = 1024
  261:         # Actual length is MAX_VAR_LENGTH + 1 due to null-termination
  262:         self.env[f'NPY_{action}_CPU_FEATURES'] = "t" * MAX_VAR_LENGTH
  263:         msg = (
  264:             f"Length of environment variable 'NPY_{action}_CPU_FEATURES' is "
  265:             f"{MAX_VAR_LENGTH + 1}, only {MAX_VAR_LENGTH} accepted"
  266:         )
  267:         err_type = "RuntimeError"
  268:         self._expect_error(msg, err_type)
  269: 
  270:     @pytest.mark.skipif(
  271:         not __cpu_dispatch__,
  272:         reason=(
  273:             "NPY_*_CPU_FEATURES only parsed if "
  274:             "`__cpu_dispatch__` is non-empty"
  275:         )
  276:     )
  277:     def test_impossible_feature_disable(self):
  278:         """
  279:         Test that a RuntimeError is thrown if an impossible feature-disabling
  280:         request is made. This includes disabling a baseline feature.
  281:         """
  282: 
  283:         if self.BASELINE_FEAT is None:
  284:             pytest.skip("There are no unavailable features to test with")
  285:         bad_feature = self.BASELINE_FEAT
  286:         self.env['NPY_DISABLE_CPU_FEATURES'] = bad_feature
  287:         msg = (
  288:             f"You cannot disable CPU feature '{bad_feature}', since it is "
  289:             "part of the baseline optimizations"
  290:         )
  291:         err_type = "RuntimeError"
  292:         self._expect_error(msg, err_type)
  293: 
  294:     def test_impossible_feature_enable(self):
  295:         """
  296:         Test that a RuntimeError is thrown if an impossible feature-enabling
  297:         request is made. This includes enabling a feature not supported by the
  298:         machine, or disabling a baseline optimization.
  299:         """
  300: 
  301:         if self.UNAVAILABLE_FEAT is None:
  302:             pytest.skip("There are no unavailable features to test with")
  303:         bad_feature = self.UNAVAILABLE_FEAT
  304:         self.env['NPY_ENABLE_CPU_FEATURES'] = bad_feature
  305:         msg = (
  306:             f"You cannot enable CPU features \\({bad_feature}\\), since "
  307:             "they are not supported by your machine."
  308:         )
  309:         err_type = "RuntimeError"
  310:         self._expect_error(msg, err_type)
  311: 
  312:         # Ensure that it fails even when providing garbage in addition
  313:         feats = f"{bad_feature}, Foobar"
  314:         self.env['NPY_ENABLE_CPU_FEATURES'] = feats
  315:         msg = (
  316:             f"You cannot enable CPU features \\({bad_feature}\\), since they "
  317:             "are not supported by your machine."
  318:         )
  319:         self._expect_error(msg, err_type)
  320: 
  321:         if self.BASELINE_FEAT is not None:
  322:             # Ensure that only the bad feature gets reported
  323:             feats = f"{bad_feature}, {self.BASELINE_FEAT}"
  324:             self.env['NPY_ENABLE_CPU_FEATURES'] = feats
  325:             msg = (
  326:                 f"You cannot enable CPU features \\({bad_feature}\\), since "
  327:                 "they are not supported by your machine."
  328:             )
  329:             self._expect_error(msg, err_type)
  330: 
  331: 
  332: is_linux = sys.platform.startswith('linux')
  333: is_cygwin = sys.platform.startswith('cygwin')
  334: machine = platform.machine()
  335: is_x86 = re.match(r"^(amd64|x86|i386|i686)", machine, re.IGNORECASE)
  336: @pytest.mark.skipif(
  337:     not (is_linux or is_cygwin) or not is_x86, reason="Only for Linux and x86"
  338: )
  339: class Test_X86_Features(AbstractTest):
  340:     features = [
  341:         "MMX", "SSE", "SSE2", "SSE3", "SSSE3", "SSE41", "POPCNT", "SSE42",
  342:         "AVX", "F16C", "XOP", "FMA4", "FMA3", "AVX2", "AVX512F", "AVX512CD",
  343:         "AVX512ER", "AVX512PF", "AVX5124FMAPS", "AVX5124VNNIW", "AVX512VPOPCNTDQ",
  344:         "AVX512VL", "AVX512BW", "AVX512DQ", "AVX512VNNI", "AVX512IFMA",
  345:         "AVX512VBMI", "AVX512VBMI2", "AVX512BITALG", "AVX512FP16",
  346:     ]
  347:     features_groups = {
  348:         "AVX512_KNL": ["AVX512F", "AVX512CD", "AVX512ER", "AVX512PF"],
  349:         "AVX512_KNM": ["AVX512F", "AVX512CD", "AVX512ER", "AVX512PF", "AVX5124FMAPS",
  350:                       "AVX5124VNNIW", "AVX512VPOPCNTDQ"],
  351:         "AVX512_SKX": ["AVX512F", "AVX512CD", "AVX512BW", "AVX512DQ", "AVX512VL"],
  352:         "AVX512_CLX": ["AVX512F", "AVX512CD", "AVX512BW", "AVX512DQ", "AVX512VL", "AVX512VNNI"],
  353:         "AVX512_CNL": ["AVX512F", "AVX512CD", "AVX512BW", "AVX512DQ", "AVX512VL", "AVX512IFMA",
  354:                       "AVX512VBMI"],
  355:         "AVX512_ICL": ["AVX512F", "AVX512CD", "AVX512BW", "AVX512DQ", "AVX512VL", "AVX512IFMA",
  356:                       "AVX512VBMI", "AVX512VNNI", "AVX512VBMI2", "AVX512BITALG", "AVX512VPOPCNTDQ"],
  357:         "AVX512_SPR": ["AVX512F", "AVX512CD", "AVX512BW", "AVX512DQ",
  358:                       "AVX512VL", "AVX512IFMA", "AVX512VBMI", "AVX512VNNI",
  359:                       "AVX512VBMI2", "AVX512BITALG", "AVX512VPOPCNTDQ",
  360:                       "AVX512FP16"],
  361:     }
  362:     features_map = {
  363:         "SSE3": "PNI", "SSE41": "SSE4_1", "SSE42": "SSE4_2", "FMA3": "FMA",
  364:         "AVX512VNNI": "AVX512_VNNI", "AVX512BITALG": "AVX512_BITALG",
  365:         "AVX512VBMI2": "AVX512_VBMI2", "AVX5124FMAPS": "AVX512_4FMAPS",
  366:         "AVX5124VNNIW": "AVX512_4VNNIW", "AVX512VPOPCNTDQ": "AVX512_VPOPCNTDQ",
  367:         "AVX512FP16": "AVX512_FP16",
  368:     }
  369: 
  370:     def load_flags(self):
  371:         self.load_flags_cpuinfo("flags")
  372: 
  373: 
  374: is_power = re.match(r"^(powerpc|ppc)64", machine, re.IGNORECASE)
  375: @pytest.mark.skipif(not is_linux or not is_power, reason="Only for Linux and Power")
  376: class Test_POWER_Features(AbstractTest):
  377:     features = ["VSX", "VSX2", "VSX3", "VSX4"]
  378:     features_map = {"VSX2": "ARCH_2_07", "VSX3": "ARCH_3_00", "VSX4": "ARCH_3_1"}
  379: 
  380:     def load_flags(self):
  381:         self.load_flags_auxv()
  382: 
  383: 
  384: is_zarch = re.match(r"^(s390x)", machine, re.IGNORECASE)
  385: @pytest.mark.skipif(not is_linux or not is_zarch,
  386:                     reason="Only for Linux and IBM Z")
  387: class Test_ZARCH_Features(AbstractTest):
  388:     features = ["VX", "VXE", "VXE2"]
  389: 
  390:     def load_flags(self):
  391:         self.load_flags_auxv()
  392: 
  393: 
  394: is_arm = re.match(r"^(arm|aarch64)", machine, re.IGNORECASE)
  395: @pytest.mark.skipif(not is_linux or not is_arm, reason="Only for Linux and ARM")
  396: class Test_ARM_Features(AbstractTest):
  397:     features = [
  398:         "SVE", "NEON", "ASIMD", "FPHP", "ASIMDHP", "ASIMDDP", "ASIMDFHM"
  399:     ]
  400:     features_groups = {
  401:         "NEON_FP16":  ["NEON", "HALF"],
  402:         "NEON_VFPV4": ["NEON", "VFPV4"],
  403:     }
  404: 
  405:     def load_flags(self):
  406:         self.load_flags_cpuinfo("Features")
  407:         arch = self.get_cpuinfo_item("CPU architecture")
  408:         # in case of mounting virtual filesystem of aarch64 kernel without linux32
  409:         is_rootfs_v8 = (
  410:             not re.match(r"^armv[0-9]+l$", machine) and
  411:             (int('0' + next(iter(arch))) > 7 if arch else 0)
  412:         )
  413:         if re.match(r"^(aarch64|AARCH64)", machine) or is_rootfs_v8:
  414:             self.features_map = {
  415:                 "NEON": "ASIMD", "HALF": "ASIMD", "VFPV4": "ASIMD"
  416:             }
  417:         else:
  418:             self.features_map = {
  419:                 # ELF auxiliary vector and /proc/cpuinfo on Linux kernel(armv8 aarch32)
  420:                 # doesn't provide information about ASIMD, so we assume that ASIMD is supported
  421:                 # if the kernel reports any one of the following ARM8 features.
  422:                 "ASIMD": ("AES", "SHA1", "SHA2", "PMULL", "CRC32")
  423:             }
  424: 
  425: 
  426: is_loongarch = re.match(r"^(loongarch)", machine, re.IGNORECASE)
  427: @pytest.mark.skipif(not is_linux or not is_loongarch, reason="Only for Linux and LoongArch")
  428: class Test_LOONGARCH_Features(AbstractTest):
  429:     features = ["LSX"]
  430: 
  431:     def load_flags(self):
  432:         self.load_flags_cpuinfo("Features")
