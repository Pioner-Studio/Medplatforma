    1: import operator
    2: import sys
    3: 
    4: import pytest
    5: 
    6: import numpy as np
    7: from numpy.testing import IS_PYPY, assert_array_equal, assert_raises
    8: from numpy.testing._private.utils import requires_memory
    9: 
   10: COMPARISONS = [
   11:     (operator.eq, np.equal, "=="),
   12:     (operator.ne, np.not_equal, "!="),
   13:     (operator.lt, np.less, "<"),
   14:     (operator.le, np.less_equal, "<="),
   15:     (operator.gt, np.greater, ">"),
   16:     (operator.ge, np.greater_equal, ">="),
   17: ]
   18: 
   19: MAX = np.iinfo(np.int64).max
   20: 
   21: IS_PYPY_LT_7_3_16 = IS_PYPY and sys.implementation.version < (7, 3, 16)
   22: 
   23: @pytest.mark.parametrize(["op", "ufunc", "sym"], COMPARISONS)
   24: def test_mixed_string_comparison_ufuncs_fail(op, ufunc, sym):
   25:     arr_string = np.array(["a", "b"], dtype="S")
   26:     arr_unicode = np.array(["a", "c"], dtype="U")
   27: 
   28:     with pytest.raises(TypeError, match="did not contain a loop"):
   29:         ufunc(arr_string, arr_unicode)
   30: 
   31:     with pytest.raises(TypeError, match="did not contain a loop"):
   32:         ufunc(arr_unicode, arr_string)
   33: 
   34: @pytest.mark.parametrize(["op", "ufunc", "sym"], COMPARISONS)
   35: def test_mixed_string_comparisons_ufuncs_with_cast(op, ufunc, sym):
   36:     arr_string = np.array(["a", "b"], dtype="S")
   37:     arr_unicode = np.array(["a", "c"], dtype="U")
   38: 
   39:     # While there is no loop, manual casting is acceptable:
   40:     res1 = ufunc(arr_string, arr_unicode, signature="UU->?", casting="unsafe")
   41:     res2 = ufunc(arr_string, arr_unicode, signature="SS->?", casting="unsafe")
   42: 
   43:     expected = op(arr_string.astype("U"), arr_unicode)
   44:     assert_array_equal(res1, expected)
   45:     assert_array_equal(res2, expected)
   46: 
   47: 
   48: @pytest.mark.parametrize(["op", "ufunc", "sym"], COMPARISONS)
   49: @pytest.mark.parametrize("dtypes", [
   50:         ("S2", "S2"), ("S2", "S10"),
   51:         ("<U1", "<U1"), ("<U1", ">U1"), (">U1", ">U1"),
   52:         ("<U1", "<U10"), ("<U1", ">U10")])
   53: @pytest.mark.parametrize("aligned", [True, False])
   54: def test_string_comparisons(op, ufunc, sym, dtypes, aligned):
   55:     # ensure native byte-order for the first view to stay within unicode range
   56:     native_dt = np.dtype(dtypes[0]).newbyteorder("=")
   57:     arr = np.arange(2**15).view(native_dt).astype(dtypes[0])
   58:     if not aligned:
   59:         # Make `arr` unaligned:
   60:         new = np.zeros(arr.nbytes + 1, dtype=np.uint8)[1:].view(dtypes[0])
   61:         new[...] = arr
   62:         arr = new
   63: 
   64:     arr2 = arr.astype(dtypes[1], copy=True)
   65:     np.random.shuffle(arr2)
   66:     arr[0] = arr2[0]  # make sure one matches
   67: 
   68:     expected = [op(d1, d2) for d1, d2 in zip(arr.tolist(), arr2.tolist())]
   69:     assert_array_equal(op(arr, arr2), expected)
   70:     assert_array_equal(ufunc(arr, arr2), expected)
   71:     assert_array_equal(
   72:         np.char.compare_chararrays(arr, arr2, sym, False), expected
   73:     )
   74: 
   75:     expected = [op(d2, d1) for d1, d2 in zip(arr.tolist(), arr2.tolist())]
   76:     assert_array_equal(op(arr2, arr), expected)
   77:     assert_array_equal(ufunc(arr2, arr), expected)
   78:     assert_array_equal(
   79:         np.char.compare_chararrays(arr2, arr, sym, False), expected
   80:     )
   81: 
   82: 
   83: @pytest.mark.parametrize(["op", "ufunc", "sym"], COMPARISONS)
   84: @pytest.mark.parametrize("dtypes", [
   85:         ("S2", "S2"), ("S2", "S10"), ("<U1", "<U1"), ("<U1", ">U10")])
   86: def test_string_comparisons_empty(op, ufunc, sym, dtypes):
   87:     arr = np.empty((1, 0, 1, 5), dtype=dtypes[0])
   88:     arr2 = np.empty((100, 1, 0, 1), dtype=dtypes[1])
   89: 
   90:     expected = np.empty(np.broadcast_shapes(arr.shape, arr2.shape), dtype=bool)
   91:     assert_array_equal(op(arr, arr2), expected)
   92:     assert_array_equal(ufunc(arr, arr2), expected)
   93:     assert_array_equal(
   94:         np.char.compare_chararrays(arr, arr2, sym, False), expected
   95:     )
   96: 
   97: 
   98: @pytest.mark.parametrize("str_dt", ["S", "U"])
   99: @pytest.mark.parametrize("float_dt", np.typecodes["AllFloat"])
  100: def test_float_to_string_cast(str_dt, float_dt):
  101:     float_dt = np.dtype(float_dt)
  102:     fi = np.finfo(float_dt)
  103:     arr = np.array([np.nan, np.inf, -np.inf, fi.max, fi.min], dtype=float_dt)
  104:     expected = ["nan", "inf", "-inf", str(fi.max), str(fi.min)]
  105:     if float_dt.kind == "c":
  106:         expected = [f"({r}+0j)" for r in expected]
  107: 
  108:     res = arr.astype(str_dt)
  109:     assert_array_equal(res, np.array(expected, dtype=str_dt))
  110: 
  111: 
  112: @pytest.mark.parametrize("str_dt", "US")
  113: @pytest.mark.parametrize("size", [-1, np.iinfo(np.intc).max])
  114: def test_string_size_dtype_errors(str_dt, size):
  115:     if size > 0:
  116:         size = size // np.dtype(f"{str_dt}1").itemsize + 1
  117: 
  118:     with pytest.raises(ValueError):
  119:         np.dtype((str_dt, size))
  120:     with pytest.raises(TypeError):
  121:         np.dtype(f"{str_dt}{size}")
  122: 
  123: 
  124: @pytest.mark.parametrize("str_dt", "US")
  125: def test_string_size_dtype_large_repr(str_dt):
  126:     size = np.iinfo(np.intc).max // np.dtype(f"{str_dt}1").itemsize
  127:     size_str = str(size)
  128: 
  129:     dtype = np.dtype((str_dt, size))
  130:     assert size_str in dtype.str
  131:     assert size_str in str(dtype)
  132:     assert size_str in repr(dtype)
  133: 
  134: 
  135: @pytest.mark.slow
  136: @requires_memory(2 * np.iinfo(np.intc).max)
  137: @pytest.mark.parametrize("str_dt", "US")
  138: def test_large_string_coercion_error(str_dt):
  139:     very_large = np.iinfo(np.intc).max // np.dtype(f"{str_dt}1").itemsize
  140:     try:
  141:         large_string = "A" * (very_large + 1)
  142:     except Exception:
  143:         # We may not be able to create this Python string on 32bit.
  144:         pytest.skip("python failed to create huge string")
  145: 
  146:     class MyStr:
  147:         def __str__(self):
  148:             return large_string
  149: 
  150:     try:
  151:         # TypeError from NumPy, or OverflowError from 32bit Python.
  152:         with pytest.raises((TypeError, OverflowError)):
  153:             np.array([large_string], dtype=str_dt)
  154: 
  155:         # Same as above, but input has to be converted to a string.
  156:         with pytest.raises((TypeError, OverflowError)):
  157:             np.array([MyStr()], dtype=str_dt)
  158:     except MemoryError:
  159:         # Catch memory errors, because `requires_memory` would do so.
  160:         raise AssertionError("Ops should raise before any large allocation.")
  161: 
  162: @pytest.mark.slow
  163: @requires_memory(2 * np.iinfo(np.intc).max)
  164: @pytest.mark.parametrize("str_dt", "US")
  165: def test_large_string_addition_error(str_dt):
  166:     very_large = np.iinfo(np.intc).max // np.dtype(f"{str_dt}1").itemsize
  167: 
  168:     a = np.array(["A" * very_large], dtype=str_dt)
  169:     b = np.array("B", dtype=str_dt)
  170:     try:
  171:         with pytest.raises(TypeError):
  172:             np.add(a, b)
  173:         with pytest.raises(TypeError):
  174:             np.add(a, a)
  175:     except MemoryError:
  176:         # Catch memory errors, because `requires_memory` would do so.
  177:         raise AssertionError("Ops should raise before any large allocation.")
  178: 
  179: 
  180: def test_large_string_cast():
  181:     very_large = np.iinfo(np.intc).max // 4
  182:     # Could be nice to test very large path, but it makes too many huge
  183:     # allocations right now (need non-legacy cast loops for this).
  184:     # a = np.array([], dtype=np.dtype(("S", very_large)))
  185:     # assert a.astype("U").dtype.itemsize == very_large * 4
  186: 
  187:     a = np.array([], dtype=np.dtype(("S", very_large + 1)))
  188:     # It is not perfect but OK if this raises a MemoryError during setup
  189:     # (this happens due clunky code and/or buffer setup.)
  190:     with pytest.raises((TypeError, MemoryError)):
  191:         a.astype("U")
  192: 
  193: 
  194: @pytest.mark.parametrize("dt", ["S", "U", "T"])
  195: class TestMethods:
  196: 
  197:     @pytest.mark.parametrize("in1,in2,out", [
  198:         ("", "", ""),
  199:         ("abc", "abc", "abcabc"),
  200:         ("12345", "12345", "1234512345"),
  201:         ("MixedCase", "MixedCase", "MixedCaseMixedCase"),
  202:         ("12345 \0 ", "12345 \0 ", "12345 \0 12345 \0 "),
  203:         ("UPPER", "UPPER", "UPPERUPPER"),
  204:         (["abc", "def"], ["hello", "world"], ["abchello", "defworld"]),
  205:     ])
  206:     def test_add(self, in1, in2, out, dt):
  207:         in1 = np.array(in1, dtype=dt)
  208:         in2 = np.array(in2, dtype=dt)
  209:         out = np.array(out, dtype=dt)
  210:         assert_array_equal(np.strings.add(in1, in2), out)
  211: 
  212:     @pytest.mark.parametrize("in1,in2,out", [
  213:         ("abc", 3, "abcabcabc"),
  214:         ("abc", 0, ""),
  215:         ("abc", -1, ""),
  216:         (["abc", "def"], [1, 4], ["abc", "defdefdefdef"]),
  217:     ])
  218:     def test_multiply(self, in1, in2, out, dt):
  219:         in1 = np.array(in1, dtype=dt)
  220:         out = np.array(out, dtype=dt)
  221:         assert_array_equal(np.strings.multiply(in1, in2), out)
  222: 
  223:     def test_multiply_raises(self, dt):
  224:         with pytest.raises(TypeError, match="unsupported type"):
  225:             np.strings.multiply(np.array("abc", dtype=dt), 3.14)
  226: 
  227:         with pytest.raises(OverflowError):
  228:             np.strings.multiply(np.array("abc", dtype=dt), sys.maxsize)
  229: 
  230:     def test_inplace_multiply(self, dt):
  231:         arr = np.array(['foo ', 'bar'], dtype=dt)
  232:         arr *= 2
  233:         if dt != "T":
  234:             assert_array_equal(arr, np.array(['foo ', 'barb'], dtype=dt))
  235:         else:
  236:             assert_array_equal(arr, ['foo foo ', 'barbar'])
  237: 
  238:         with pytest.raises(OverflowError):
  239:             arr *= sys.maxsize
  240: 
  241:     @pytest.mark.parametrize("i_dt", [np.int8, np.int16, np.int32,
  242:                                       np.int64, np.int_])
  243:     def test_multiply_integer_dtypes(self, i_dt, dt):
  244:         a = np.array("abc", dtype=dt)
  245:         i = np.array(3, dtype=i_dt)
  246:         res = np.array("abcabcabc", dtype=dt)
  247:         assert_array_equal(np.strings.multiply(a, i), res)
  248: 
  249:     @pytest.mark.parametrize("in_,out", [
  250:         ("", False),
  251:         ("a", True),
  252:         ("A", True),
  253:         ("\n", False),
  254:         ("abc", True),
  255:         ("aBc123", False),
  256:         ("abc\n", False),
  257:         (["abc", "aBc123"], [True, False]),
  258:     ])
  259:     def test_isalpha(self, in_, out, dt):
  260:         in_ = np.array(in_, dtype=dt)
  261:         assert_array_equal(np.strings.isalpha(in_), out)
  262: 
  263:     @pytest.mark.parametrize("in_,out", [
  264:         ('', False),
  265:         ('a', True),
  266:         ('A', True),
  267:         ('\n', False),
  268:         ('123abc456', True),
  269:         ('a1b3c', True),
  270:         ('aBc000 ', False),
  271:         ('abc\n', False),
  272:     ])
  273:     def test_isalnum(self, in_, out, dt):
  274:         in_ = np.array(in_, dtype=dt)
  275:         assert_array_equal(np.strings.isalnum(in_), out)
  276: 
  277:     @pytest.mark.parametrize("in_,out", [
  278:         ("", False),
  279:         ("a", False),
  280:         ("0", True),
  281:         ("012345", True),
  282:         ("012345a", False),
  283:         (["a", "012345"], [False, True]),
  284:     ])
  285:     def test_isdigit(self, in_, out, dt):
  286:         in_ = np.array(in_, dtype=dt)
  287:         assert_array_equal(np.strings.isdigit(in_), out)
  288: 
  289:     @pytest.mark.parametrize("in_,out", [
  290:         ("", False),
  291:         ("a", False),
  292:         ("1", False),
  293:         (" ", True),
  294:         ("\t", True),
  295:         ("\r", True),
  296:         ("\n", True),
  297:         (" \t\r \n", True),
  298:         (" \t\r\na", False),
  299:         (["\t1", " \t\r \n"], [False, True])
  300:     ])
  301:     def test_isspace(self, in_, out, dt):
  302:         in_ = np.array(in_, dtype=dt)
  303:         assert_array_equal(np.strings.isspace(in_), out)
  304: 
  305:     @pytest.mark.parametrize("in_,out", [
  306:         ('', False),
  307:         ('a', True),
  308:         ('A', False),
  309:         ('\n', False),
  310:         ('abc', True),
  311:         ('aBc', False),
  312:         ('abc\n', True),
  313:     ])
  314:     def test_islower(self, in_, out, dt):
  315:         in_ = np.array(in_, dtype=dt)
  316:         assert_array_equal(np.strings.islower(in_), out)
  317: 
  318:     @pytest.mark.parametrize("in_,out", [
  319:         ('', False),
  320:         ('a', False),
  321:         ('A', True),
  322:         ('\n', False),
  323:         ('ABC', True),
  324:         ('AbC', False),
  325:         ('ABC\n', True),
  326:     ])
  327:     def test_isupper(self, in_, out, dt):
  328:         in_ = np.array(in_, dtype=dt)
  329:         assert_array_equal(np.strings.isupper(in_), out)
  330: 
  331:     @pytest.mark.parametrize("in_,out", [
  332:         ('', False),
  333:         ('a', False),
  334:         ('A', True),
  335:         ('\n', False),
  336:         ('A Titlecased Line', True),
  337:         ('A\nTitlecased Line', True),
  338:         ('A Titlecased, Line', True),
  339:         ('Not a capitalized String', False),
  340:         ('Not\ta Titlecase String', False),
  341:         ('Not--a Titlecase String', False),
  342:         ('NOT', False),
  343:     ])
  344:     def test_istitle(self, in_, out, dt):
  345:         in_ = np.array(in_, dtype=dt)
  346:         assert_array_equal(np.strings.istitle(in_), out)
  347: 
  348:     @pytest.mark.parametrize("in_,out", [
  349:         ("", 0),
  350:         ("abc", 3),
  351:         ("12345", 5),
  352:         ("MixedCase", 9),
  353:         ("12345 \x00 ", 8),
  354:         ("UPPER", 5),
  355:         (["abc", "12345 \x00 "], [3, 8]),
  356:     ])
  357:     def test_str_len(self, in_, out, dt):
  358:         in_ = np.array(in_, dtype=dt)
  359:         assert_array_equal(np.strings.str_len(in_), out)
  360: 
  361:     @pytest.mark.parametrize("a,sub,start,end,out", [
  362:         ("abcdefghiabc", "abc", 0, None, 0),
  363:         ("abcdefghiabc", "abc", 1, None, 9),
  364:         ("abcdefghiabc", "def", 4, None, -1),
  365:         ("abc", "", 0, None, 0),
  366:         ("abc", "", 3, None, 3),
  367:         ("abc", "", 4, None, -1),
  368:         ("rrarrrrrrrrra", "a", 0, None, 2),
  369:         ("rrarrrrrrrrra", "a", 4, None, 12),
  370:         ("rrarrrrrrrrra", "a", 4, 6, -1),
  371:         ("", "", 0, None, 0),
  372:         ("", "", 1, 1, -1),
  373:         ("", "", MAX, 0, -1),
  374:         ("", "xx", 0, None, -1),
  375:         ("", "xx", 1, 1, -1),
  376:         ("", "xx", MAX, 0, -1),
  377:         pytest.param(99 * "a" + "b", "b", 0, None, 99,
  378:                      id="99*a+b-b-0-None-99"),
  379:         pytest.param(98 * "a" + "ba", "ba", 0, None, 98,
  380:                      id="98*a+ba-ba-0-None-98"),
  381:         pytest.param(100 * "a", "b", 0, None, -1,
  382:                      id="100*a-b-0-None--1"),
  383:         pytest.param(30000 * "a" + 100 * "b", 100 * "b", 0, None, 30000,
  384:                      id="30000*a+100*b-100*b-0-None-30000"),
  385:         pytest.param(30000 * "a", 100 * "b", 0, None, -1,
  386:                      id="30000*a-100*b-0-None--1"),
  387:         pytest.param(15000 * "a" + 15000 * "b", 15000 * "b", 0, None, 15000,
  388:                      id="15000*a+15000*b-15000*b-0-None-15000"),
  389:         pytest.param(15000 * "a" + 15000 * "b", 15000 * "c", 0, None, -1,
  390:                      id="15000*a+15000*b-15000*c-0-None--1"),
  391:         (["abcdefghiabc", "rrarrrrrrrrra"], ["def", "arr"], [0, 3],
  392:          None, [3, -1]),
  393:         ("AeВўвѓв‚¬ рџЉ" * 2, "рџЉ", 0, None, 6),
  394:         ("AeВўвѓв‚¬ рџЉ" * 2, "рџЉ", 7, None, 13),
  395:         pytest.param("A" * (2 ** 17), r"[\w]+\Z", 0, None, -1,
  396:                      id=r"A*2**17-[\w]+\Z-0-None--1"),
  397:     ])
  398:     def test_find(self, a, sub, start, end, out, dt):
  399:         if "рџЉ" in a and dt == "S":
  400:             pytest.skip("Bytes dtype does not support non-ascii input")
  401:         a = np.array(a, dtype=dt)
  402:         sub = np.array(sub, dtype=dt)
  403:         assert_array_equal(np.strings.find(a, sub, start, end), out)
  404: 
  405:     @pytest.mark.parametrize("a,sub,start,end,out", [
  406:         ("abcdefghiabc", "abc", 0, None, 9),
  407:         ("abcdefghiabc", "", 0, None, 12),
  408:         ("abcdefghiabc", "abcd", 0, None, 0),
  409:         ("abcdefghiabc", "abcz", 0, None, -1),
  410:         ("abc", "", 0, None, 3),
  411:         ("abc", "", 3, None, 3),
  412:         ("abc", "", 4, None, -1),
  413:         ("rrarrrrrrrrra", "a", 0, None, 12),
  414:         ("rrarrrrrrrrra", "a", 4, None, 12),
  415:         ("rrarrrrrrrrra", "a", 4, 6, -1),
  416:         (["abcdefghiabc", "rrarrrrrrrrra"], ["abc", "a"], [0, 0],
  417:          None, [9, 12]),
  418:         ("AeВўвѓв‚¬ рџЉ" * 2, "рџЉ", 0, None, 13),
  419:         ("AeВўвѓв‚¬ рџЉ" * 2, "рџЉ", 0, 7, 6),
  420:     ])
  421:     def test_rfind(self, a, sub, start, end, out, dt):
  422:         if "рџЉ" in a and dt == "S":
  423:             pytest.skip("Bytes dtype does not support non-ascii input")
  424:         a = np.array(a, dtype=dt)
  425:         sub = np.array(sub, dtype=dt)
  426:         assert_array_equal(np.strings.rfind(a, sub, start, end), out)
  427: 
  428:     @pytest.mark.parametrize("a,sub,start,end,out", [
  429:         ("aaa", "a", 0, None, 3),
  430:         ("aaa", "b", 0, None, 0),
  431:         ("aaa", "a", 1, None, 2),
  432:         ("aaa", "a", 10, None, 0),
  433:         ("aaa", "a", -1, None, 1),
  434:         ("aaa", "a", -10, None, 3),
  435:         ("aaa", "a", 0, 1, 1),
  436:         ("aaa", "a", 0, 10, 3),
  437:         ("aaa", "a", 0, -1, 2),
  438:         ("aaa", "a", 0, -10, 0),
  439:         ("aaa", "", 1, None, 3),
  440:         ("aaa", "", 3, None, 1),
  441:         ("aaa", "", 10, None, 0),
  442:         ("aaa", "", -1, None, 2),
  443:         ("aaa", "", -10, None, 4),
  444:         ("aaa", "aaaa", 0, None, 0),
  445:         pytest.param(98 * "a" + "ba", "ba", 0, None, 1,
  446:                      id="98*a+ba-ba-0-None-1"),
  447:         pytest.param(30000 * "a" + 100 * "b", 100 * "b", 0, None, 1,
  448:                      id="30000*a+100*b-100*b-0-None-1"),
  449:         pytest.param(30000 * "a", 100 * "b", 0, None, 0,
  450:                      id="30000*a-100*b-0-None-0"),
  451:         pytest.param(30000 * "a" + 100 * "ab", "ab", 0, None, 100,
  452:                      id="30000*a+100*ab-ab-0-None-100"),
  453:         pytest.param(15000 * "a" + 15000 * "b", 15000 * "b", 0, None, 1,
  454:                      id="15000*a+15000*b-15000*b-0-None-1"),
  455:         pytest.param(15000 * "a" + 15000 * "b", 15000 * "c", 0, None, 0,
  456:                      id="15000*a+15000*b-15000*c-0-None-0"),
  457:         ("", "", 0, None, 1),
  458:         ("", "", 1, 1, 0),
  459:         ("", "", MAX, 0, 0),
  460:         ("", "xx", 0, None, 0),
  461:         ("", "xx", 1, 1, 0),
  462:         ("", "xx", MAX, 0, 0),
  463:         (["aaa", ""], ["a", ""], [0, 0], None, [3, 1]),
  464:         ("AeВўвѓв‚¬ рџЉ" * 100, "рџЉ", 0, None, 100),
  465:     ])
  466:     def test_count(self, a, sub, start, end, out, dt):
  467:         if "рџЉ" in a and dt == "S":
  468:             pytest.skip("Bytes dtype does not support non-ascii input")
  469:         a = np.array(a, dtype=dt)
  470:         sub = np.array(sub, dtype=dt)
  471:         assert_array_equal(np.strings.count(a, sub, start, end), out)
  472: 
  473:     @pytest.mark.parametrize("a,prefix,start,end,out", [
  474:         ("hello", "he", 0, None, True),
  475:         ("hello", "hello", 0, None, True),
  476:         ("hello", "hello world", 0, None, False),
  477:         ("hello", "", 0, None, True),
  478:         ("hello", "ello", 0, None, False),
  479:         ("hello", "ello", 1, None, True),
  480:         ("hello", "o", 4, None, True),
  481:         ("hello", "o", 5, None, False),
  482:         ("hello", "", 5, None, True),
  483:         ("hello", "lo", 6, None, False),
  484:         ("helloworld", "lowo", 3, None, True),
  485:         ("helloworld", "lowo", 3, 7, True),
  486:         ("helloworld", "lowo", 3, 6, False),
  487:         ("", "", 0, 1, True),
  488:         ("", "", 0, 0, True),
  489:         ("", "", 1, 0, False),
  490:         ("hello", "he", 0, -1, True),
  491:         ("hello", "he", -53, -1, True),
  492:         ("hello", "hello", 0, -1, False),
  493:         ("hello", "hello world", -1, -10, False),
  494:         ("hello", "ello", -5, None, False),
  495:         ("hello", "ello", -4, None, True),
  496:         ("hello", "o", -2, None, False),
  497:         ("hello", "o", -1, None, True),
  498:         ("hello", "", -3, -3, True),
  499:         ("hello", "lo", -9, None, False),
  500:         (["hello", ""], ["he", ""], [0, 0], None, [True, True]),
  501:     ])
  502:     def test_startswith(self, a, prefix, start, end, out, dt):
  503:         a = np.array(a, dtype=dt)
  504:         prefix = np.array(prefix, dtype=dt)
  505:         assert_array_equal(np.strings.startswith(a, prefix, start, end), out)
  506: 
  507:     @pytest.mark.parametrize("a,suffix,start,end,out", [
  508:         ("hello", "lo", 0, None, True),
  509:         ("hello", "he", 0, None, False),
  510:         ("hello", "", 0, None, True),
  511:         ("hello", "hello world", 0, None, False),
  512:         ("helloworld", "worl", 0, None, False),
  513:         ("helloworld", "worl", 3, 9, True),
  514:         ("helloworld", "world", 3, 12, True),
  515:         ("helloworld", "lowo", 1, 7, True),
  516:         ("helloworld", "lowo", 2, 7, True),
  517:         ("helloworld", "lowo", 3, 7, True),
  518:         ("helloworld", "lowo", 4, 7, False),
  519:         ("helloworld", "lowo", 3, 8, False),
  520:         ("ab", "ab", 0, 1, False),
  521:         ("ab", "ab", 0, 0, False),
  522:         ("", "", 0, 1, True),
  523:         ("", "", 0, 0, True),
  524:         ("", "", 1, 0, False),
  525:         ("hello", "lo", -2, None, True),
  526:         ("hello", "he", -2, None, False),
  527:         ("hello", "", -3, -3, True),
  528:         ("hello", "hello world", -10, -2, False),
  529:         ("helloworld", "worl", -6, None, False),
  530:         ("helloworld", "worl", -5, -1, True),
  531:         ("helloworld", "worl", -5, 9, True),
  532:         ("helloworld", "world", -7, 12, True),
  533:         ("helloworld", "lowo", -99, -3, True),
  534:         ("helloworld", "lowo", -8, -3, True),
  535:         ("helloworld", "lowo", -7, -3, True),
  536:         ("helloworld", "lowo", 3, -4, False),
  537:         ("helloworld", "lowo", -8, -2, False),
  538:         (["hello", "helloworld"], ["lo", "worl"], [0, -6], None,
  539:          [True, False]),
  540:     ])
  541:     def test_endswith(self, a, suffix, start, end, out, dt):
  542:         a = np.array(a, dtype=dt)
  543:         suffix = np.array(suffix, dtype=dt)
  544:         assert_array_equal(np.strings.endswith(a, suffix, start, end), out)
  545: 
  546:     @pytest.mark.parametrize("a,chars,out", [
  547:         ("", None, ""),
  548:         ("   hello   ", None, "hello   "),
  549:         ("hello", None, "hello"),
  550:         (" \t\n\r\f\vabc \t\n\r\f\v", None, "abc \t\n\r\f\v"),
  551:         (["   hello   ", "hello"], None, ["hello   ", "hello"]),
  552:         ("", "", ""),
  553:         ("", "xyz", ""),
  554:         ("hello", "", "hello"),
  555:         ("xyzzyhelloxyzzy", "xyz", "helloxyzzy"),
  556:         ("hello", "xyz", "hello"),
  557:         ("xyxz", "xyxz", ""),
  558:         ("xyxzx", "x", "yxzx"),
  559:         (["xyzzyhelloxyzzy", "hello"], ["xyz", "xyz"],
  560:          ["helloxyzzy", "hello"]),
  561:         (["ba", "ac", "baa", "bba"], "b", ["a", "ac", "aa", "a"]),
  562:     ])
  563:     def test_lstrip(self, a, chars, out, dt):
  564:         a = np.array(a, dtype=dt)
  565:         out = np.array(out, dtype=dt)
  566:         if chars is not None:
  567:             chars = np.array(chars, dtype=dt)
  568:             assert_array_equal(np.strings.lstrip(a, chars), out)
  569:         else:
  570:             assert_array_equal(np.strings.lstrip(a), out)
  571: 
  572:     @pytest.mark.parametrize("a,chars,out", [
  573:         ("", None, ""),
  574:         ("   hello   ", None, "   hello"),
  575:         ("hello", None, "hello"),
  576:         (" \t\n\r\f\vabc \t\n\r\f\v", None, " \t\n\r\f\vabc"),
  577:         (["   hello   ", "hello"], None, ["   hello", "hello"]),
  578:         ("", "", ""),
  579:         ("", "xyz", ""),
  580:         ("hello", "", "hello"),
  581:         (["hello    ", "abcdefghijklmnop"], None,
  582:          ["hello", "abcdefghijklmnop"]),
  583:         ("xyzzyhelloxyzzy", "xyz", "xyzzyhello"),
  584:         ("hello", "xyz", "hello"),
  585:         ("xyxz", "xyxz", ""),
  586:         ("    ", None, ""),
  587:         ("xyxzx", "x", "xyxz"),
  588:         (["xyzzyhelloxyzzy", "hello"], ["xyz", "xyz"],
  589:          ["xyzzyhello", "hello"]),
  590:         (["ab", "ac", "aab", "abb"], "b", ["a", "ac", "aa", "a"]),
  591:     ])
  592:     def test_rstrip(self, a, chars, out, dt):
  593:         a = np.array(a, dtype=dt)
  594:         out = np.array(out, dtype=dt)
  595:         if chars is not None:
  596:             chars = np.array(chars, dtype=dt)
  597:             assert_array_equal(np.strings.rstrip(a, chars), out)
  598:         else:
  599:             assert_array_equal(np.strings.rstrip(a), out)
  600: 
  601:     @pytest.mark.parametrize("a,chars,out", [
  602:         ("", None, ""),
  603:         ("   hello   ", None, "hello"),
  604:         ("hello", None, "hello"),
  605:         (" \t\n\r\f\vabc \t\n\r\f\v", None, "abc"),
  606:         (["   hello   ", "hello"], None, ["hello", "hello"]),
  607:         ("", "", ""),
  608:         ("", "xyz", ""),
  609:         ("hello", "", "hello"),
  610:         ("xyzzyhelloxyzzy", "xyz", "hello"),
  611:         ("hello", "xyz", "hello"),
  612:         ("xyxz", "xyxz", ""),
  613:         ("xyxzx", "x", "yxz"),
  614:         (["xyzzyhelloxyzzy", "hello"], ["xyz", "xyz"],
  615:          ["hello", "hello"]),
  616:         (["bab", "ac", "baab", "bbabb"], "b", ["a", "ac", "aa", "a"]),
  617:     ])
  618:     def test_strip(self, a, chars, out, dt):
  619:         a = np.array(a, dtype=dt)
  620:         if chars is not None:
  621:             chars = np.array(chars, dtype=dt)
  622:         out = np.array(out, dtype=dt)
  623:         assert_array_equal(np.strings.strip(a, chars), out)
  624: 
  625:     @pytest.mark.parametrize("buf,old,new,count,res", [
  626:         ("", "", "", -1, ""),
  627:         ("", "", "A", -1, "A"),
  628:         ("", "A", "", -1, ""),
  629:         ("", "A", "A", -1, ""),
  630:         ("", "", "", 100, ""),
  631:         ("", "", "A", 100, "A"),
  632:         ("A", "", "", -1, "A"),
  633:         ("A", "", "*", -1, "*A*"),
  634:         ("A", "", "*1", -1, "*1A*1"),
  635:         ("A", "", "*-#", -1, "*-#A*-#"),
  636:         ("AA", "", "*-", -1, "*-A*-A*-"),
  637:         ("AA", "", "*-", -1, "*-A*-A*-"),
  638:         ("AA", "", "*-", 4, "*-A*-A*-"),
  639:         ("AA", "", "*-", 3, "*-A*-A*-"),
  640:         ("AA", "", "*-", 2, "*-A*-A"),
  641:         ("AA", "", "*-", 1, "*-AA"),
  642:         ("AA", "", "*-", 0, "AA"),
  643:         ("A", "A", "", -1, ""),
  644:         ("AAA", "A", "", -1, ""),
  645:         ("AAA", "A", "", -1, ""),
  646:         ("AAA", "A", "", 4, ""),
  647:         ("AAA", "A", "", 3, ""),
  648:         ("AAA", "A", "", 2, "A"),
  649:         ("AAA", "A", "", 1, "AA"),
  650:         ("AAA", "A", "", 0, "AAA"),
  651:         ("AAAAAAAAAA", "A", "", -1, ""),
  652:         ("ABACADA", "A", "", -1, "BCD"),
  653:         ("ABACADA", "A", "", -1, "BCD"),
  654:         ("ABACADA", "A", "", 5, "BCD"),
  655:         ("ABACADA", "A", "", 4, "BCD"),
  656:         ("ABACADA", "A", "", 3, "BCDA"),
  657:         ("ABACADA", "A", "", 2, "BCADA"),
  658:         ("ABACADA", "A", "", 1, "BACADA"),
  659:         ("ABACADA", "A", "", 0, "ABACADA"),
  660:         ("ABCAD", "A", "", -1, "BCD"),
  661:         ("ABCADAA", "A", "", -1, "BCD"),
  662:         ("BCD", "A", "", -1, "BCD"),
  663:         ("*************", "A", "", -1, "*************"),
  664:         ("^" + "A" * 1000 + "^", "A", "", 999, "^A^"),
  665:         ("the", "the", "", -1, ""),
  666:         ("theater", "the", "", -1, "ater"),
  667:         ("thethe", "the", "", -1, ""),
  668:         ("thethethethe", "the", "", -1, ""),
  669:         ("theatheatheathea", "the", "", -1, "aaaa"),
  670:         ("that", "the", "", -1, "that"),
  671:         ("thaet", "the", "", -1, "thaet"),
  672:         ("here and there", "the", "", -1, "here and re"),
  673:         ("here and there and there", "the", "", -1, "here and re and re"),
  674:         ("here and there and there", "the", "", 3, "here and re and re"),
  675:         ("here and there and there", "the", "", 2, "here and re and re"),
  676:         ("here and there and there", "the", "", 1, "here and re and there"),
  677:         ("here and there and there", "the", "", 0, "here and there and there"),
  678:         ("here and there and there", "the", "", -1, "here and re and re"),
  679:         ("abc", "the", "", -1, "abc"),
  680:         ("abcdefg", "the", "", -1, "abcdefg"),
  681:         ("bbobob", "bob", "", -1, "bob"),
  682:         ("bbobobXbbobob", "bob", "", -1, "bobXbob"),
  683:         ("aaaaaaabob", "bob", "", -1, "aaaaaaa"),
  684:         ("aaaaaaa", "bob", "", -1, "aaaaaaa"),
  685:         ("Who goes there?", "o", "o", -1, "Who goes there?"),
  686:         ("Who goes there?", "o", "O", -1, "WhO gOes there?"),
  687:         ("Who goes there?", "o", "O", -1, "WhO gOes there?"),
  688:         ("Who goes there?", "o", "O", 3, "WhO gOes there?"),
  689:         ("Who goes there?", "o", "O", 2, "WhO gOes there?"),
  690:         ("Who goes there?", "o", "O", 1, "WhO goes there?"),
  691:         ("Who goes there?", "o", "O", 0, "Who goes there?"),
  692:         ("Who goes there?", "a", "q", -1, "Who goes there?"),
  693:         ("Who goes there?", "W", "w", -1, "who goes there?"),
  694:         ("WWho goes there?WW", "W", "w", -1, "wwho goes there?ww"),
  695:         ("Who goes there?", "?", "!", -1, "Who goes there!"),
  696:         ("Who goes there??", "?", "!", -1, "Who goes there!!"),
  697:         ("Who goes there?", ".", "!", -1, "Who goes there?"),
  698:         ("This is a tissue", "is", "**", -1, "Th** ** a t**sue"),
  699:         ("This is a tissue", "is", "**", -1, "Th** ** a t**sue"),
  700:         ("This is a tissue", "is", "**", 4, "Th** ** a t**sue"),
  701:         ("This is a tissue", "is", "**", 3, "Th** ** a t**sue"),
  702:         ("This is a tissue", "is", "**", 2, "Th** ** a tissue"),
  703:         ("This is a tissue", "is", "**", 1, "Th** is a tissue"),
  704:         ("This is a tissue", "is", "**", 0, "This is a tissue"),
  705:         ("bobob", "bob", "cob", -1, "cobob"),
  706:         ("bobobXbobobob", "bob", "cob", -1, "cobobXcobocob"),
  707:         ("bobob", "bot", "bot", -1, "bobob"),
  708:         ("Reykjavik", "k", "KK", -1, "ReyKKjaviKK"),
  709:         ("Reykjavik", "k", "KK", -1, "ReyKKjaviKK"),
  710:         ("Reykjavik", "k", "KK", 2, "ReyKKjaviKK"),
  711:         ("Reykjavik", "k", "KK", 1, "ReyKKjavik"),
  712:         ("Reykjavik", "k", "KK", 0, "Reykjavik"),
  713:         ("A.B.C.", ".", "----", -1, "A----B----C----"),
  714:         ("Reykjavik", "q", "KK", -1, "Reykjavik"),
  715:         ("spam, spam, eggs and spam", "spam", "ham", -1,
  716:             "ham, ham, eggs and ham"),
  717:         ("spam, spam, eggs and spam", "spam", "ham", -1,
  718:             "ham, ham, eggs and ham"),
  719:         ("spam, spam, eggs and spam", "spam", "ham", 4,
  720:             "ham, ham, eggs and ham"),
  721:         ("spam, spam, eggs and spam", "spam", "ham", 3,
  722:             "ham, ham, eggs and ham"),
  723:         ("spam, spam, eggs and spam", "spam", "ham", 2,
  724:             "ham, ham, eggs and spam"),
  725:         ("spam, spam, eggs and spam", "spam", "ham", 1,
  726:             "ham, spam, eggs and spam"),
  727:         ("spam, spam, eggs and spam", "spam", "ham", 0,
  728:             "spam, spam, eggs and spam"),
  729:         ("bobobob", "bobob", "bob", -1, "bobob"),
  730:         ("bobobobXbobobob", "bobob", "bob", -1, "bobobXbobob"),
  731:         ("BOBOBOB", "bob", "bobby", -1, "BOBOBOB"),
  732:         ("one!two!three!", "!", "@", 1, "one@two!three!"),
  733:         ("one!two!three!", "!", "", -1, "onetwothree"),
  734:         ("one!two!three!", "!", "@", 2, "one@two@three!"),
  735:         ("one!two!three!", "!", "@", 3, "one@two@three@"),
  736:         ("one!two!three!", "!", "@", 4, "one@two@three@"),
  737:         ("one!two!three!", "!", "@", 0, "one!two!three!"),
  738:         ("one!two!three!", "!", "@", -1, "one@two@three@"),
  739:         ("one!two!three!", "x", "@", -1, "one!two!three!"),
  740:         ("one!two!three!", "x", "@", 2, "one!two!three!"),
  741:         ("abc", "", "-", -1, "-a-b-c-"),
  742:         ("abc", "", "-", 3, "-a-b-c"),
  743:         ("abc", "", "-", 0, "abc"),
  744:         ("abc", "ab", "--", 0, "abc"),
  745:         ("abc", "xy", "--", -1, "abc"),
  746:         (["abbc", "abbd"], "b", "z", [1, 2], ["azbc", "azzd"]),
  747:     ])
  748:     def test_replace(self, buf, old, new, count, res, dt):
  749:         if "рџЉ" in buf and dt == "S":
  750:             pytest.skip("Bytes dtype does not support non-ascii input")
  751:         buf = np.array(buf, dtype=dt)
  752:         old = np.array(old, dtype=dt)
  753:         new = np.array(new, dtype=dt)
  754:         res = np.array(res, dtype=dt)
  755:         assert_array_equal(np.strings.replace(buf, old, new, count), res)
  756: 
  757:     @pytest.mark.parametrize("buf,sub,start,end,res", [
  758:         ("abcdefghiabc", "", 0, None, 0),
  759:         ("abcdefghiabc", "def", 0, None, 3),
  760:         ("abcdefghiabc", "abc", 0, None, 0),
  761:         ("abcdefghiabc", "abc", 1, None, 9),
  762:     ])
  763:     def test_index(self, buf, sub, start, end, res, dt):
  764:         buf = np.array(buf, dtype=dt)
  765:         sub = np.array(sub, dtype=dt)
  766:         assert_array_equal(np.strings.index(buf, sub, start, end), res)
  767: 
  768:     @pytest.mark.parametrize("buf,sub,start,end", [
  769:         ("abcdefghiabc", "hib", 0, None),
  770:         ("abcdefghiab", "abc", 1, None),
  771:         ("abcdefghi", "ghi", 8, None),
  772:         ("abcdefghi", "ghi", -1, None),
  773:         ("rrarrrrrrrrra", "a", 4, 6),
  774:     ])
  775:     def test_index_raises(self, buf, sub, start, end, dt):
  776:         buf = np.array(buf, dtype=dt)
  777:         sub = np.array(sub, dtype=dt)
  778:         with pytest.raises(ValueError, match="substring not found"):
  779:             np.strings.index(buf, sub, start, end)
  780: 
  781:     @pytest.mark.parametrize("buf,sub,start,end,res", [
  782:         ("abcdefghiabc", "", 0, None, 12),
  783:         ("abcdefghiabc", "def", 0, None, 3),
  784:         ("abcdefghiabc", "abc", 0, None, 9),
  785:         ("abcdefghiabc", "abc", 0, -1, 0),
  786:     ])
  787:     def test_rindex(self, buf, sub, start, end, res, dt):
  788:         buf = np.array(buf, dtype=dt)
  789:         sub = np.array(sub, dtype=dt)
  790:         assert_array_equal(np.strings.rindex(buf, sub, start, end), res)
  791: 
  792:     @pytest.mark.parametrize("buf,sub,start,end", [
  793:         ("abcdefghiabc", "hib", 0, None),
  794:         ("defghiabc", "def", 1, None),
  795:         ("defghiabc", "abc", 0, -1),
  796:         ("abcdefghi", "ghi", 0, 8),
  797:         ("abcdefghi", "ghi", 0, -1),
  798:         ("rrarrrrrrrrra", "a", 4, 6),
  799:     ])
  800:     def test_rindex_raises(self, buf, sub, start, end, dt):
  801:         buf = np.array(buf, dtype=dt)
  802:         sub = np.array(sub, dtype=dt)
  803:         with pytest.raises(ValueError, match="substring not found"):
  804:             np.strings.rindex(buf, sub, start, end)
  805: 
  806:     @pytest.mark.parametrize("buf,tabsize,res", [
  807:         ("abc\rab\tdef\ng\thi", 8, "abc\rab      def\ng       hi"),
  808:         ("abc\rab\tdef\ng\thi", 4, "abc\rab  def\ng   hi"),
  809:         ("abc\r\nab\tdef\ng\thi", 8, "abc\r\nab      def\ng       hi"),
  810:         ("abc\r\nab\tdef\ng\thi", 4, "abc\r\nab  def\ng   hi"),
  811:         ("abc\r\nab\r\ndef\ng\r\nhi", 4, "abc\r\nab\r\ndef\ng\r\nhi"),
  812:         (" \ta\n\tb", 1, "  a\n b"),
  813:     ])
  814:     def test_expandtabs(self, buf, tabsize, res, dt):
  815:         buf = np.array(buf, dtype=dt)
  816:         res = np.array(res, dtype=dt)
  817:         assert_array_equal(np.strings.expandtabs(buf, tabsize), res)
  818: 
  819:     def test_expandtabs_raises_overflow(self, dt):
  820:         with pytest.raises(OverflowError, match="new string is too long"):
  821:             np.strings.expandtabs(np.array("\ta\n\tb", dtype=dt), sys.maxsize)
  822:             np.strings.expandtabs(np.array("\ta\n\tb", dtype=dt), 2**61)
  823: 
  824:     FILL_ERROR = "The fill character must be exactly one character long"
  825: 
  826:     def test_center_raises_multiple_character_fill(self, dt):
  827:         buf = np.array("abc", dtype=dt)
  828:         fill = np.array("**", dtype=dt)
  829:         with pytest.raises(TypeError, match=self.FILL_ERROR):
  830:             np.strings.center(buf, 10, fill)
  831: 
  832:     def test_ljust_raises_multiple_character_fill(self, dt):
  833:         buf = np.array("abc", dtype=dt)
  834:         fill = np.array("**", dtype=dt)
  835:         with pytest.raises(TypeError, match=self.FILL_ERROR):
  836:             np.strings.ljust(buf, 10, fill)
  837: 
  838:     def test_rjust_raises_multiple_character_fill(self, dt):
  839:         buf = np.array("abc", dtype=dt)
  840:         fill = np.array("**", dtype=dt)
  841:         with pytest.raises(TypeError, match=self.FILL_ERROR):
  842:             np.strings.rjust(buf, 10, fill)
  843: 
  844:     @pytest.mark.parametrize("buf,width,fillchar,res", [
  845:         ('abc', 10, ' ', '   abc    '),
  846:         ('abc', 6, ' ', ' abc  '),
  847:         ('abc', 3, ' ', 'abc'),
  848:         ('abc', 2, ' ', 'abc'),
  849:         ('abc', -2, ' ', 'abc'),
  850:         ('abc', 10, '*', '***abc****'),
  851:     ])
  852:     def test_center(self, buf, width, fillchar, res, dt):
  853:         buf = np.array(buf, dtype=dt)
  854:         fillchar = np.array(fillchar, dtype=dt)
  855:         res = np.array(res, dtype=dt)
  856:         assert_array_equal(np.strings.center(buf, width, fillchar), res)
  857: 
  858:     @pytest.mark.parametrize("buf,width,fillchar,res", [
  859:         ('abc', 10, ' ', 'abc       '),
  860:         ('abc', 6, ' ', 'abc   '),
  861:         ('abc', 3, ' ', 'abc'),
  862:         ('abc', 2, ' ', 'abc'),
  863:         ('abc', -2, ' ', 'abc'),
  864:         ('abc', 10, '*', 'abc*******'),
  865:     ])
  866:     def test_ljust(self, buf, width, fillchar, res, dt):
  867:         buf = np.array(buf, dtype=dt)
  868:         fillchar = np.array(fillchar, dtype=dt)
  869:         res = np.array(res, dtype=dt)
  870:         assert_array_equal(np.strings.ljust(buf, width, fillchar), res)
  871: 
  872:     @pytest.mark.parametrize("buf,width,fillchar,res", [
  873:         ('abc', 10, ' ', '       abc'),
  874:         ('abc', 6, ' ', '   abc'),
  875:         ('abc', 3, ' ', 'abc'),
  876:         ('abc', 2, ' ', 'abc'),
  877:         ('abc', -2, ' ', 'abc'),
  878:         ('abc', 10, '*', '*******abc'),
  879:     ])
  880:     def test_rjust(self, buf, width, fillchar, res, dt):
  881:         buf = np.array(buf, dtype=dt)
  882:         fillchar = np.array(fillchar, dtype=dt)
  883:         res = np.array(res, dtype=dt)
  884:         assert_array_equal(np.strings.rjust(buf, width, fillchar), res)
  885: 
  886:     @pytest.mark.parametrize("buf,width,res", [
  887:         ('123', 2, '123'),
  888:         ('123', 3, '123'),
  889:         ('0123', 4, '0123'),
  890:         ('+123', 3, '+123'),
  891:         ('+123', 4, '+123'),
  892:         ('+123', 5, '+0123'),
  893:         ('+0123', 5, '+0123'),
  894:         ('-123', 3, '-123'),
  895:         ('-123', 4, '-123'),
  896:         ('-0123', 5, '-0123'),
  897:         ('000', 3, '000'),
  898:         ('34', 1, '34'),
  899:         ('34', -1, '34'),
  900:         ('0034', 4, '0034'),
  901:     ])
  902:     def test_zfill(self, buf, width, res, dt):
  903:         buf = np.array(buf, dtype=dt)
  904:         res = np.array(res, dtype=dt)
  905:         assert_array_equal(np.strings.zfill(buf, width), res)
  906: 
  907:     @pytest.mark.parametrize("buf,sep,res1,res2,res3", [
  908:         ("this is the partition method", "ti", "this is the par",
  909:             "ti", "tion method"),
  910:         ("http://www.python.org", "://", "http", "://", "www.python.org"),
  911:         ("http://www.python.org", "?", "http://www.python.org", "", ""),
  912:         ("http://www.python.org", "http://", "", "http://", "www.python.org"),
  913:         ("http://www.python.org", "org", "http://www.python.", "org", ""),
  914:         ("http://www.python.org", ["://", "?", "http://", "org"],
  915:             ["http", "http://www.python.org", "", "http://www.python."],
  916:             ["://", "", "http://", "org"],
  917:             ["www.python.org", "", "www.python.org", ""]),
  918:         ("mississippi", "ss", "mi", "ss", "issippi"),
  919:         ("mississippi", "i", "m", "i", "ssissippi"),
  920:         ("mississippi", "w", "mississippi", "", ""),
  921:     ])
  922:     def test_partition(self, buf, sep, res1, res2, res3, dt):
  923:         buf = np.array(buf, dtype=dt)
  924:         sep = np.array(sep, dtype=dt)
  925:         res1 = np.array(res1, dtype=dt)
  926:         res2 = np.array(res2, dtype=dt)
  927:         res3 = np.array(res3, dtype=dt)
  928:         act1, act2, act3 = np.strings.partition(buf, sep)
  929:         assert_array_equal(act1, res1)
  930:         assert_array_equal(act2, res2)
  931:         assert_array_equal(act3, res3)
  932:         assert_array_equal(act1 + act2 + act3, buf)
  933: 
  934:     @pytest.mark.parametrize("buf,sep,res1,res2,res3", [
  935:         ("this is the partition method", "ti", "this is the parti",
  936:             "ti", "on method"),
  937:         ("http://www.python.org", "://", "http", "://", "www.python.org"),
  938:         ("http://www.python.org", "?", "", "", "http://www.python.org"),
  939:         ("http://www.python.org", "http://", "", "http://", "www.python.org"),
  940:         ("http://www.python.org", "org", "http://www.python.", "org", ""),
  941:         ("http://www.python.org", ["://", "?", "http://", "org"],
  942:             ["http", "", "", "http://www.python."],
  943:             ["://", "", "http://", "org"],
  944:             ["www.python.org", "http://www.python.org", "www.python.org", ""]),
  945:         ("mississippi", "ss", "missi", "ss", "ippi"),
  946:         ("mississippi", "i", "mississipp", "i", ""),
  947:         ("mississippi", "w", "", "", "mississippi"),
  948:     ])
  949:     def test_rpartition(self, buf, sep, res1, res2, res3, dt):
  950:         buf = np.array(buf, dtype=dt)
  951:         sep = np.array(sep, dtype=dt)
  952:         res1 = np.array(res1, dtype=dt)
  953:         res2 = np.array(res2, dtype=dt)
  954:         res3 = np.array(res3, dtype=dt)
  955:         act1, act2, act3 = np.strings.rpartition(buf, sep)
  956:         assert_array_equal(act1, res1)
  957:         assert_array_equal(act2, res2)
  958:         assert_array_equal(act3, res3)
  959:         assert_array_equal(act1 + act2 + act3, buf)
  960: 
  961:     @pytest.mark.parametrize("args", [
  962:         (None,),
  963:         (0,),
  964:         (1,),
  965:         (3,),
  966:         (5,),
  967:         (6,),  # test index past the end
  968:         (-1,),
  969:         (-3,),
  970:         ([3, 4],),
  971:         ([2, 4],),
  972:         ([-3, 5],),
  973:         ([0, -5],),
  974:         (1, 4),
  975:         (-3, 5),
  976:         (None, -1),
  977:         (0, [4, 2]),
  978:         ([1, 2], [-1, -2]),
  979:         (1, 5, 2),
  980:         (None, None, -1),
  981:         ([0, 6], [-1, 0], [2, -1]),
  982:     ])
  983:     def test_slice(self, args, dt):
  984:         buf = np.array(["hello", "world"], dtype=dt)
  985:         act = np.strings.slice(buf, *args)
  986:         bcast_args = tuple(np.broadcast_to(arg, buf.shape) for arg in args)
  987:         res = np.array([s[slice(*arg)]
  988:                         for s, arg in zip(buf, zip(*bcast_args))],
  989:                        dtype=dt)
  990:         assert_array_equal(act, res)
  991: 
  992:     def test_slice_unsupported(self, dt):
  993:         with pytest.raises(TypeError, match="did not contain a loop"):
  994:             np.strings.slice(np.array([1, 2, 3]), 4)
  995: 
  996:         with pytest.raises(TypeError, match=r"Cannot cast ufunc '_slice' input .* from .* to dtype\('int(64|32)'\)"):
  997:             np.strings.slice(np.array(['foo', 'bar'], dtype=dt), np.array(['foo', 'bar'], dtype=dt))
  998: 
  999:     @pytest.mark.parametrize("int_dt", [np.int8, np.int16, np.int32, np.int64,
 1000:                                         np.uint8, np.uint16, np.uint32, np.uint64])
 1001:     def test_slice_int_type_promotion(self, int_dt, dt):
 1002:         buf = np.array(["hello", "world"], dtype=dt)
 1003: 
 1004:         assert_array_equal(np.strings.slice(buf, int_dt(4)), np.array(["hell", "worl"], dtype=dt))
 1005:         assert_array_equal(np.strings.slice(buf, np.array([4, 4], dtype=int_dt)), np.array(["hell", "worl"], dtype=dt))
 1006: 
 1007:         assert_array_equal(np.strings.slice(buf, int_dt(2), int_dt(4)), np.array(["ll", "rl"], dtype=dt))
 1008:         assert_array_equal(np.strings.slice(buf, np.array([2, 2], dtype=int_dt), np.array([4, 4], dtype=int_dt)), np.array(["ll", "rl"], dtype=dt))
 1009: 
 1010:         assert_array_equal(np.strings.slice(buf, int_dt(0), int_dt(4), int_dt(2)), np.array(["hl", "wr"], dtype=dt))
 1011:         assert_array_equal(np.strings.slice(buf, np.array([0, 0], dtype=int_dt), np.array([4, 4], dtype=int_dt), np.array([2, 2], dtype=int_dt)), np.array(["hl", "wr"], dtype=dt))
 1012: 
 1013: @pytest.mark.parametrize("dt", ["U", "T"])
 1014: class TestMethodsWithUnicode:
 1015:     @pytest.mark.parametrize("in_,out", [
 1016:         ("", False),
 1017:         ("a", False),
 1018:         ("0", True),
 1019:         ("\u2460", False),  # CIRCLED DIGIT 1
 1020:         ("\xbc", False),  # VULGAR FRACTION ONE QUARTER
 1021:         ("\u0660", True),  # ARABIC_INDIC DIGIT ZERO
 1022:         ("012345", True),
 1023:         ("012345a", False),
 1024:         (["0", "a"], [True, False]),
 1025:     ])
 1026:     def test_isdecimal_unicode(self, in_, out, dt):
 1027:         buf = np.array(in_, dtype=dt)
 1028:         assert_array_equal(np.strings.isdecimal(buf), out)
 1029: 
 1030:     @pytest.mark.parametrize("in_,out", [
 1031:         ("", False),
 1032:         ("a", False),
 1033:         ("0", True),
 1034:         ("\u2460", True),  # CIRCLED DIGIT 1
 1035:         ("\xbc", True),  # VULGAR FRACTION ONE QUARTER
 1036:         ("\u0660", True),  # ARABIC_INDIC DIGIT ZERO
 1037:         ("012345", True),
 1038:         ("012345a", False),
 1039:         (["0", "a"], [True, False]),
 1040:     ])
 1041:     def test_isnumeric_unicode(self, in_, out, dt):
 1042:         buf = np.array(in_, dtype=dt)
 1043:         assert_array_equal(np.strings.isnumeric(buf), out)
 1044: 
 1045:     @pytest.mark.parametrize("buf,old,new,count,res", [
 1046:         ("...\u043c......<", "<", "&lt;", -1, "...\u043c......&lt;"),
 1047:         ("AeВўвѓв‚¬ рџЉ" * 2, "A", "B", -1, "BeВўвѓв‚¬ рџЉBeВўвѓв‚¬ рџЉ"),
 1048:         ("AeВўвѓв‚¬ рџЉ" * 2, "рџЉ", "B", -1, "AeВўвѓв‚¬ BAeВўвѓв‚¬ B"),
 1049:     ])
 1050:     def test_replace_unicode(self, buf, old, new, count, res, dt):
 1051:         buf = np.array(buf, dtype=dt)
 1052:         old = np.array(old, dtype=dt)
 1053:         new = np.array(new, dtype=dt)
 1054:         res = np.array(res, dtype=dt)
 1055:         assert_array_equal(np.strings.replace(buf, old, new, count), res)
 1056: 
 1057:     @pytest.mark.parametrize("in_", [
 1058:         '\U00010401',
 1059:         '\U00010427',
 1060:         '\U00010429',
 1061:         '\U0001044E',
 1062:         '\U0001D7F6',
 1063:         '\U00011066',
 1064:         '\U000104A0',
 1065:         pytest.param('\U0001F107', marks=pytest.mark.xfail(
 1066:             sys.platform == 'win32' and IS_PYPY_LT_7_3_16,
 1067:             reason="PYPY bug in Py_UNICODE_ISALNUM",
 1068:             strict=True)),
 1069:     ])
 1070:     def test_isalnum_unicode(self, in_, dt):
 1071:         in_ = np.array(in_, dtype=dt)
 1072:         assert_array_equal(np.strings.isalnum(in_), True)
 1073: 
 1074:     @pytest.mark.parametrize("in_,out", [
 1075:         ('\u1FFc', False),
 1076:         ('\u2167', False),
 1077:         ('\U00010401', False),
 1078:         ('\U00010427', False),
 1079:         ('\U0001F40D', False),
 1080:         ('\U0001F46F', False),
 1081:         ('\u2177', True),
 1082:         pytest.param('\U00010429', True, marks=pytest.mark.xfail(
 1083:             sys.platform == 'win32' and IS_PYPY_LT_7_3_16,
 1084:             reason="PYPY bug in Py_UNICODE_ISLOWER",
 1085:             strict=True)),
 1086:         ('\U0001044E', True),
 1087:     ])
 1088:     def test_islower_unicode(self, in_, out, dt):
 1089:         in_ = np.array(in_, dtype=dt)
 1090:         assert_array_equal(np.strings.islower(in_), out)
 1091: 
 1092:     @pytest.mark.parametrize("in_,out", [
 1093:         ('\u1FFc', False),
 1094:         ('\u2167', True),
 1095:         ('\U00010401', True),
 1096:         ('\U00010427', True),
 1097:         ('\U0001F40D', False),
 1098:         ('\U0001F46F', False),
 1099:         ('\u2177', False),
 1100:         pytest.param('\U00010429', False, marks=pytest.mark.xfail(
 1101:             sys.platform == 'win32' and IS_PYPY_LT_7_3_16,
 1102:             reason="PYPY bug in Py_UNICODE_ISUPPER",
 1103:             strict=True)),
 1104:         ('\U0001044E', False),
 1105:     ])
 1106:     def test_isupper_unicode(self, in_, out, dt):
 1107:         in_ = np.array(in_, dtype=dt)
 1108:         assert_array_equal(np.strings.isupper(in_), out)
 1109: 
 1110:     @pytest.mark.parametrize("in_,out", [
 1111:         ('\u1FFc', True),
 1112:         ('Greek \u1FFcitlecases ...', True),
 1113:         pytest.param('\U00010401\U00010429', True, marks=pytest.mark.xfail(
 1114:             sys.platform == 'win32' and IS_PYPY_LT_7_3_16,
 1115:             reason="PYPY bug in Py_UNICODE_ISISTITLE",
 1116:             strict=True)),
 1117:         ('\U00010427\U0001044E', True),
 1118:         pytest.param('\U00010429', False, marks=pytest.mark.xfail(
 1119:             sys.platform == 'win32' and IS_PYPY_LT_7_3_16,
 1120:             reason="PYPY bug in Py_UNICODE_ISISTITLE",
 1121:             strict=True)),
 1122:         ('\U0001044E', False),
 1123:         ('\U0001F40D', False),
 1124:         ('\U0001F46F', False),
 1125:     ])
 1126:     def test_istitle_unicode(self, in_, out, dt):
 1127:         in_ = np.array(in_, dtype=dt)
 1128:         assert_array_equal(np.strings.istitle(in_), out)
 1129: 
 1130:     @pytest.mark.parametrize("buf,sub,start,end,res", [
 1131:         ("AeВўвѓв‚¬ рџЉ" * 2, "рџЉ", 0, None, 6),
 1132:         ("AeВўвѓв‚¬ рџЉ" * 2, "рџЉ", 7, None, 13),
 1133:     ])
 1134:     def test_index_unicode(self, buf, sub, start, end, res, dt):
 1135:         buf = np.array(buf, dtype=dt)
 1136:         sub = np.array(sub, dtype=dt)
 1137:         assert_array_equal(np.strings.index(buf, sub, start, end), res)
 1138: 
 1139:     def test_index_raises_unicode(self, dt):
 1140:         with pytest.raises(ValueError, match="substring not found"):
 1141:             np.strings.index("AeВўвѓв‚¬ рџЉ", "рџЂ")
 1142: 
 1143:     @pytest.mark.parametrize("buf,res", [
 1144:         ("AeВўвѓв‚¬ \t рџЉ", "AeВўвѓв‚¬    рџЉ"),
 1145:         ("\t\U0001044E", "        \U0001044E"),
 1146:     ])
 1147:     def test_expandtabs(self, buf, res, dt):
 1148:         buf = np.array(buf, dtype=dt)
 1149:         res = np.array(res, dtype=dt)
 1150:         assert_array_equal(np.strings.expandtabs(buf), res)
 1151: 
 1152:     @pytest.mark.parametrize("buf,width,fillchar,res", [
 1153:         ('x', 2, '\U0001044E', 'x\U0001044E'),
 1154:         ('x', 3, '\U0001044E', '\U0001044Ex\U0001044E'),
 1155:         ('x', 4, '\U0001044E', '\U0001044Ex\U0001044E\U0001044E'),
 1156:     ])
 1157:     def test_center(self, buf, width, fillchar, res, dt):
 1158:         buf = np.array(buf, dtype=dt)
 1159:         fillchar = np.array(fillchar, dtype=dt)
 1160:         res = np.array(res, dtype=dt)
 1161:         assert_array_equal(np.strings.center(buf, width, fillchar), res)
 1162: 
 1163:     @pytest.mark.parametrize("buf,width,fillchar,res", [
 1164:         ('x', 2, '\U0001044E', 'x\U0001044E'),
 1165:         ('x', 3, '\U0001044E', 'x\U0001044E\U0001044E'),
 1166:         ('x', 4, '\U0001044E', 'x\U0001044E\U0001044E\U0001044E'),
 1167:     ])
 1168:     def test_ljust(self, buf, width, fillchar, res, dt):
 1169:         buf = np.array(buf, dtype=dt)
 1170:         fillchar = np.array(fillchar, dtype=dt)
 1171:         res = np.array(res, dtype=dt)
 1172:         assert_array_equal(np.strings.ljust(buf, width, fillchar), res)
 1173: 
 1174:     @pytest.mark.parametrize("buf,width,fillchar,res", [
 1175:         ('x', 2, '\U0001044E', '\U0001044Ex'),
 1176:         ('x', 3, '\U0001044E', '\U0001044E\U0001044Ex'),
 1177:         ('x', 4, '\U0001044E', '\U0001044E\U0001044E\U0001044Ex'),
 1178:     ])
 1179:     def test_rjust(self, buf, width, fillchar, res, dt):
 1180:         buf = np.array(buf, dtype=dt)
 1181:         fillchar = np.array(fillchar, dtype=dt)
 1182:         res = np.array(res, dtype=dt)
 1183:         assert_array_equal(np.strings.rjust(buf, width, fillchar), res)
 1184: 
 1185:     @pytest.mark.parametrize("buf,sep,res1,res2,res3", [
 1186:         ("ДЃДЃДЃДЃДЂДЂДЂДЂ", "Д‚", "ДЃДЃДЃДЃДЂДЂДЂДЂ", "", ""),
 1187:         ("ДЃДЃДЃДЃД‚ДЂДЂДЂДЂ", "Д‚", "ДЃДЃДЃДЃ", "Д‚", "ДЂДЂДЂДЂ"),
 1188:         ("ДЃДЃДЃДЃД‚Д‚ДЂДЂДЂДЂ", "Д‚Д‚", "ДЃДЃДЃДЃ", "Д‚Д‚", "ДЂДЂДЂДЂ"),
 1189:         ("рђЊЃрђЊЃрђЊЃрђЊЃрђЊЂрђЊЂрђЊЂрђЊЂ", "рђЊ‚", "рђЊЃрђЊЃрђЊЃрђЊЃрђЊЂрђЊЂрђЊЂрђЊЂ", "", ""),
 1190:         ("рђЊЃрђЊЃрђЊЃрђЊЃрђЊ‚рђЊЂрђЊЂрђЊЂрђЊЂ", "рђЊ‚", "рђЊЃрђЊЃрђЊЃрђЊЃ", "рђЊ‚", "рђЊЂрђЊЂрђЊЂрђЊЂ"),
 1191:         ("рђЊЃрђЊЃрђЊЃрђЊЃрђЊ‚рђЊ‚рђЊЂрђЊЂрђЊЂрђЊЂ", "рђЊ‚рђЊ‚", "рђЊЃрђЊЃрђЊЃрђЊЃ", "рђЊ‚рђЊ‚", "рђЊЂрђЊЂрђЊЂрђЊЂ"),
 1192:         ("рђЊЃрђЊЃрђЊЃрђЊЃрђЊ‚рђЊ‚рђЊ‚рђЊ‚рђЊЂрђЊЂрђЊЂрђЊЂ", "рђЊ‚рђЊ‚рђЊ‚рђЊ‚", "рђЊЃрђЊЃрђЊЃрђЊЃ", "рђЊ‚рђЊ‚рђЊ‚рђЊ‚", "рђЊЂрђЊЂрђЊЂрђЊЂ"),
 1193:     ])
 1194:     def test_partition(self, buf, sep, res1, res2, res3, dt):
 1195:         buf = np.array(buf, dtype=dt)
 1196:         sep = np.array(sep, dtype=dt)
 1197:         res1 = np.array(res1, dtype=dt)
 1198:         res2 = np.array(res2, dtype=dt)
 1199:         res3 = np.array(res3, dtype=dt)
 1200:         act1, act2, act3 = np.strings.partition(buf, sep)
 1201:         assert_array_equal(act1, res1)
 1202:         assert_array_equal(act2, res2)
 1203:         assert_array_equal(act3, res3)
 1204:         assert_array_equal(act1 + act2 + act3, buf)
 1205: 
 1206:     @pytest.mark.parametrize("buf,sep,res1,res2,res3", [
 1207:         ("ДЃДЃДЃДЃДЂДЂДЂДЂ", "Д‚", "", "", "ДЃДЃДЃДЃДЂДЂДЂДЂ"),
 1208:         ("ДЃДЃДЃДЃД‚ДЂДЂДЂДЂ", "Д‚", "ДЃДЃДЃДЃ", "Д‚", "ДЂДЂДЂДЂ"),
 1209:         ("ДЃДЃДЃДЃД‚Д‚ДЂДЂДЂДЂ", "Д‚Д‚", "ДЃДЃДЃДЃ", "Д‚Д‚", "ДЂДЂДЂДЂ"),
 1210:         ("рђЊЃрђЊЃрђЊЃрђЊЃрђЊЂрђЊЂрђЊЂрђЊЂ", "рђЊ‚", "", "", "рђЊЃрђЊЃрђЊЃрђЊЃрђЊЂрђЊЂрђЊЂрђЊЂ"),
 1211:         ("рђЊЃрђЊЃрђЊЃрђЊЃрђЊ‚рђЊЂрђЊЂрђЊЂрђЊЂ", "рђЊ‚", "рђЊЃрђЊЃрђЊЃрђЊЃ", "рђЊ‚", "рђЊЂрђЊЂрђЊЂрђЊЂ"),
 1212:         ("рђЊЃрђЊЃрђЊЃрђЊЃрђЊ‚рђЊ‚рђЊЂрђЊЂрђЊЂрђЊЂ", "рђЊ‚рђЊ‚", "рђЊЃрђЊЃрђЊЃрђЊЃ", "рђЊ‚рђЊ‚", "рђЊЂрђЊЂрђЊЂрђЊЂ"),
 1213:     ])
 1214:     def test_rpartition(self, buf, sep, res1, res2, res3, dt):
 1215:         buf = np.array(buf, dtype=dt)
 1216:         sep = np.array(sep, dtype=dt)
 1217:         res1 = np.array(res1, dtype=dt)
 1218:         res2 = np.array(res2, dtype=dt)
 1219:         res3 = np.array(res3, dtype=dt)
 1220:         act1, act2, act3 = np.strings.rpartition(buf, sep)
 1221:         assert_array_equal(act1, res1)
 1222:         assert_array_equal(act2, res2)
 1223:         assert_array_equal(act3, res3)
 1224:         assert_array_equal(act1 + act2 + act3, buf)
 1225: 
 1226:     @pytest.mark.parametrize("method", ["strip", "lstrip", "rstrip"])
 1227:     @pytest.mark.parametrize(
 1228:         "source,strip",
 1229:         [
 1230:             ("О»Ој", "Ој"),
 1231:             ("О»Ој", "О»"),
 1232:             ("О»" * 5 + "Ој" * 2, "Ој"),
 1233:             ("О»" * 5 + "Ој" * 2, "О»"),
 1234:             ("О»" * 5 + "A" + "Ој" * 2, "ОјО»"),
 1235:             ("О»Ој" * 5, "Ој"),
 1236:             ("О»Ој" * 5, "О»"),
 1237:     ])
 1238:     def test_strip_functions_unicode(self, source, strip, method, dt):
 1239:         src_array = np.array([source], dtype=dt)
 1240: 
 1241:         npy_func = getattr(np.strings, method)
 1242:         py_func = getattr(str, method)
 1243: 
 1244:         expected = np.array([py_func(source, strip)], dtype=dt)
 1245:         actual = npy_func(src_array, strip)
 1246: 
 1247:         assert_array_equal(actual, expected)
 1248: 
 1249:     @pytest.mark.parametrize("args", [
 1250:         (None,),
 1251:         (0,),
 1252:         (1,),
 1253:         (5,),
 1254:         (15,),
 1255:         (22,),
 1256:         (-1,),
 1257:         (-3,),
 1258:         ([3, 4],),
 1259:         ([-5, 5],),
 1260:         ([0, -8],),
 1261:         (1, 12),
 1262:         (-12, 15),
 1263:         (None, -1),
 1264:         (0, [17, 6]),
 1265:         ([1, 2], [-1, -2]),
 1266:         (1, 11, 2),
 1267:         (None, None, -1),
 1268:         ([0, 10], [-1, 0], [2, -1]),
 1269:     ])
 1270:     def test_slice(self, args, dt):
 1271:         buf = np.array(["РџСЂРёРІРµМЃС‚ а¤Ёа¤®а¤ёаҐЌа¤¤аҐ‡ Ч©ЦёЧЃЧњЧ•Ц№Чќ", "рџЂрџѓрџ„рџЃрџ†рџ…рџ¤Јрџ‚рџ™‚рџ™ѓ"],
 1272:                        dtype=dt)
 1273:         act = np.strings.slice(buf, *args)
 1274:         bcast_args = tuple(np.broadcast_to(arg, buf.shape) for arg in args)
 1275:         res = np.array([s[slice(*arg)]
 1276:                         for s, arg in zip(buf, zip(*bcast_args))],
 1277:                        dtype=dt)
 1278:         assert_array_equal(act, res)
 1279: 
 1280: 
 1281: class TestMixedTypeMethods:
 1282:     def test_center(self):
 1283:         buf = np.array("рџЉ", dtype="U")
 1284:         fill = np.array("*", dtype="S")
 1285:         res = np.array("*рџЉ*", dtype="U")
 1286:         assert_array_equal(np.strings.center(buf, 3, fill), res)
 1287: 
 1288:         buf = np.array("s", dtype="S")
 1289:         fill = np.array("*", dtype="U")
 1290:         res = np.array("*s*", dtype="S")
 1291:         assert_array_equal(np.strings.center(buf, 3, fill), res)
 1292: 
 1293:         with pytest.raises(ValueError, match="'ascii' codec can't encode"):
 1294:             buf = np.array("s", dtype="S")
 1295:             fill = np.array("рџЉ", dtype="U")
 1296:             np.strings.center(buf, 3, fill)
 1297: 
 1298:     def test_ljust(self):
 1299:         buf = np.array("рџЉ", dtype="U")
 1300:         fill = np.array("*", dtype="S")
 1301:         res = np.array("рџЉ**", dtype="U")
 1302:         assert_array_equal(np.strings.ljust(buf, 3, fill), res)
 1303: 
 1304:         buf = np.array("s", dtype="S")
 1305:         fill = np.array("*", dtype="U")
 1306:         res = np.array("s**", dtype="S")
 1307:         assert_array_equal(np.strings.ljust(buf, 3, fill), res)
 1308: 
 1309:         with pytest.raises(ValueError, match="'ascii' codec can't encode"):
 1310:             buf = np.array("s", dtype="S")
 1311:             fill = np.array("рџЉ", dtype="U")
 1312:             np.strings.ljust(buf, 3, fill)
 1313: 
 1314:     def test_rjust(self):
 1315:         buf = np.array("рџЉ", dtype="U")
 1316:         fill = np.array("*", dtype="S")
 1317:         res = np.array("**рџЉ", dtype="U")
 1318:         assert_array_equal(np.strings.rjust(buf, 3, fill), res)
 1319: 
 1320:         buf = np.array("s", dtype="S")
 1321:         fill = np.array("*", dtype="U")
 1322:         res = np.array("**s", dtype="S")
 1323:         assert_array_equal(np.strings.rjust(buf, 3, fill), res)
 1324: 
 1325:         with pytest.raises(ValueError, match="'ascii' codec can't encode"):
 1326:             buf = np.array("s", dtype="S")
 1327:             fill = np.array("рџЉ", dtype="U")
 1328:             np.strings.rjust(buf, 3, fill)
 1329: 
 1330: 
 1331: class TestUnicodeOnlyMethodsRaiseWithBytes:
 1332:     def test_isdecimal_raises(self):
 1333:         in_ = np.array(b"1")
 1334:         with assert_raises(TypeError):
 1335:             np.strings.isdecimal(in_)
 1336: 
 1337:     def test_isnumeric_bytes(self):
 1338:         in_ = np.array(b"1")
 1339:         with assert_raises(TypeError):
 1340:             np.strings.isnumeric(in_)
 1341: 
 1342: 
 1343: def check_itemsize(n_elem, dt):
 1344:     if dt == "T":
 1345:         return np.dtype(dt).itemsize
 1346:     if dt == "S":
 1347:         return n_elem
 1348:     if dt == "U":
 1349:         return n_elem * 4
 1350: 
 1351: @pytest.mark.parametrize("dt", ["S", "U", "T"])
 1352: class TestReplaceOnArrays:
 1353: 
 1354:     def test_replace_count_and_size(self, dt):
 1355:         a = np.array(["0123456789" * i for i in range(4)], dtype=dt)
 1356:         r1 = np.strings.replace(a, "5", "ABCDE")
 1357:         assert r1.dtype.itemsize == check_itemsize(3 * 10 + 3 * 4, dt)
 1358:         r1_res = np.array(["01234ABCDE6789" * i for i in range(4)], dtype=dt)
 1359:         assert_array_equal(r1, r1_res)
 1360:         r2 = np.strings.replace(a, "5", "ABCDE", 1)
 1361:         assert r2.dtype.itemsize == check_itemsize(3 * 10 + 4, dt)
 1362:         r3 = np.strings.replace(a, "5", "ABCDE", 0)
 1363:         assert r3.dtype.itemsize == a.dtype.itemsize
 1364:         assert_array_equal(r3, a)
 1365:         # Negative values mean to replace all.
 1366:         r4 = np.strings.replace(a, "5", "ABCDE", -1)
 1367:         assert r4.dtype.itemsize == check_itemsize(3 * 10 + 3 * 4, dt)
 1368:         assert_array_equal(r4, r1)
 1369:         # We can do count on an element-by-element basis.
 1370:         r5 = np.strings.replace(a, "5", "ABCDE", [-1, -1, -1, 1])
 1371:         assert r5.dtype.itemsize == check_itemsize(3 * 10 + 4, dt)
 1372:         assert_array_equal(r5, np.array(
 1373:             ["01234ABCDE6789" * i for i in range(3)]
 1374:             + ["01234ABCDE6789" + "0123456789" * 2], dtype=dt))
 1375: 
 1376:     def test_replace_broadcasting(self, dt):
 1377:         a = np.array("0,0,0", dtype=dt)
 1378:         r1 = np.strings.replace(a, "0", "1", np.arange(3))
 1379:         assert r1.dtype == a.dtype
 1380:         assert_array_equal(r1, np.array(["0,0,0", "1,0,0", "1,1,0"], dtype=dt))
 1381:         r2 = np.strings.replace(a, "0", [["1"], ["2"]], np.arange(1, 4))
 1382:         assert_array_equal(r2, np.array([["1,0,0", "1,1,0", "1,1,1"],
 1383:                                          ["2,0,0", "2,2,0", "2,2,2"]],
 1384:                                         dtype=dt))
 1385:         r3 = np.strings.replace(a, ["0", "0,0", "0,0,0"], "X")
 1386:         assert_array_equal(r3, np.array(["X,X,X", "X,0", "X"], dtype=dt))
 1387: 
 1388: 
 1389: class TestOverride:
 1390:     @classmethod
 1391:     def setup_class(cls):
 1392:         class Override:
 1393: 
 1394:             def __array_function__(self, *args, **kwargs):
 1395:                 return "function"
 1396: 
 1397:             def __array_ufunc__(self, *args, **kwargs):
 1398:                 return "ufunc"
 1399: 
 1400:         cls.override = Override()
 1401: 
 1402:     @pytest.mark.parametrize("func, kwargs", [
 1403:         (np.strings.center, dict(width=10)),
 1404:         (np.strings.capitalize, {}),
 1405:         (np.strings.decode, {}),
 1406:         (np.strings.encode, {}),
 1407:         (np.strings.expandtabs, {}),
 1408:         (np.strings.ljust, dict(width=10)),
 1409:         (np.strings.lower, {}),
 1410:         (np.strings.mod, dict(values=2)),
 1411:         (np.strings.multiply, dict(i=2)),
 1412:         (np.strings.partition, dict(sep="foo")),
 1413:         (np.strings.rjust, dict(width=10)),
 1414:         (np.strings.rpartition, dict(sep="foo")),
 1415:         (np.strings.swapcase, {}),
 1416:         (np.strings.title, {}),
 1417:         (np.strings.translate, dict(table=None)),
 1418:         (np.strings.upper, {}),
 1419:         (np.strings.zfill, dict(width=10)),
 1420:     ])
 1421:     def test_override_function(self, func, kwargs):
 1422:         assert func(self.override, **kwargs) == "function"
 1423: 
 1424:     @pytest.mark.parametrize("func, args, kwargs", [
 1425:         (np.strings.add, (None, ), {}),
 1426:         (np.strings.lstrip, (), {}),
 1427:         (np.strings.rstrip, (), {}),
 1428:         (np.strings.strip, (), {}),
 1429:         (np.strings.equal, (None, ), {}),
 1430:         (np.strings.not_equal, (None, ), {}),
 1431:         (np.strings.greater_equal, (None, ), {}),
 1432:         (np.strings.less_equal, (None, ), {}),
 1433:         (np.strings.greater, (None, ), {}),
 1434:         (np.strings.less, (None, ), {}),
 1435:         (np.strings.count, ("foo", ), {}),
 1436:         (np.strings.endswith, ("foo", ), {}),
 1437:         (np.strings.find, ("foo", ), {}),
 1438:         (np.strings.index, ("foo", ), {}),
 1439:         (np.strings.isalnum, (), {}),
 1440:         (np.strings.isalpha, (), {}),
 1441:         (np.strings.isdecimal, (), {}),
 1442:         (np.strings.isdigit, (), {}),
 1443:         (np.strings.islower, (), {}),
 1444:         (np.strings.isnumeric, (), {}),
 1445:         (np.strings.isspace, (), {}),
 1446:         (np.strings.istitle, (), {}),
 1447:         (np.strings.isupper, (), {}),
 1448:         (np.strings.rfind, ("foo", ), {}),
 1449:         (np.strings.rindex, ("foo", ), {}),
 1450:         (np.strings.startswith, ("foo", ), {}),
 1451:         (np.strings.str_len, (), {}),
 1452:     ])
 1453:     def test_override_ufunc(self, func, args, kwargs):
 1454:         assert func(self.override, *args, **kwargs) == "ufunc"
