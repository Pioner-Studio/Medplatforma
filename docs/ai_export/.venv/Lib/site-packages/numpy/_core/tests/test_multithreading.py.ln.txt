    1: import concurrent.futures
    2: import string
    3: import threading
    4: 
    5: import pytest
    6: 
    7: import numpy as np
    8: from numpy._core import _rational_tests
    9: from numpy.testing import IS_64BIT, IS_WASM
   10: from numpy.testing._private.utils import run_threaded
   11: 
   12: if IS_WASM:
   13:     pytest.skip(allow_module_level=True, reason="no threading support in wasm")
   14: 
   15: 
   16: def test_parallel_randomstate_creation():
   17:     # if the coercion cache is enabled and not thread-safe, creating
   18:     # RandomState instances simultaneously leads to a data race
   19:     def func(seed):
   20:         np.random.RandomState(seed)
   21: 
   22:     run_threaded(func, 500, pass_count=True)
   23: 
   24: 
   25: def test_parallel_ufunc_execution():
   26:     # if the loop data cache or dispatch cache are not thread-safe
   27:     # computing ufuncs simultaneously in multiple threads leads
   28:     # to a data race that causes crashes or spurious exceptions
   29:     def func():
   30:         arr = np.random.random((25,))
   31:         np.isnan(arr)
   32: 
   33:     run_threaded(func, 500)
   34: 
   35:     # see gh-26690
   36:     NUM_THREADS = 50
   37: 
   38:     a = np.ones(1000)
   39: 
   40:     def f(b):
   41:         b.wait()
   42:         return a.sum()
   43: 
   44:     run_threaded(f, NUM_THREADS, pass_barrier=True)
   45: 
   46: 
   47: def test_temp_elision_thread_safety():
   48:     amid = np.ones(50000)
   49:     bmid = np.ones(50000)
   50:     alarge = np.ones(1000000)
   51:     blarge = np.ones(1000000)
   52: 
   53:     def func(count):
   54:         if count % 4 == 0:
   55:             (amid * 2) + bmid
   56:         elif count % 4 == 1:
   57:             (amid + bmid) - 2
   58:         elif count % 4 == 2:
   59:             (alarge * 2) + blarge
   60:         else:
   61:             (alarge + blarge) - 2
   62: 
   63:     run_threaded(func, 100, pass_count=True)
   64: 
   65: 
   66: def test_eigvalsh_thread_safety():
   67:     # if lapack isn't thread safe this will randomly segfault or error
   68:     # see gh-24512
   69:     rng = np.random.RandomState(873699172)
   70:     matrices = (
   71:         rng.random((5, 10, 10, 3, 3)),
   72:         rng.random((5, 10, 10, 3, 3)),
   73:     )
   74: 
   75:     run_threaded(lambda i: np.linalg.eigvalsh(matrices[i]), 2,
   76:                  pass_count=True)
   77: 
   78: 
   79: def test_printoptions_thread_safety():
   80:     # until NumPy 2.1 the printoptions state was stored in globals
   81:     # this verifies that they are now stored in a context variable
   82:     b = threading.Barrier(2)
   83: 
   84:     def legacy_113():
   85:         np.set_printoptions(legacy='1.13', precision=12)
   86:         b.wait()
   87:         po = np.get_printoptions()
   88:         assert po['legacy'] == '1.13'
   89:         assert po['precision'] == 12
   90:         orig_linewidth = po['linewidth']
   91:         with np.printoptions(linewidth=34, legacy='1.21'):
   92:             po = np.get_printoptions()
   93:             assert po['legacy'] == '1.21'
   94:             assert po['precision'] == 12
   95:             assert po['linewidth'] == 34
   96:         po = np.get_printoptions()
   97:         assert po['linewidth'] == orig_linewidth
   98:         assert po['legacy'] == '1.13'
   99:         assert po['precision'] == 12
  100: 
  101:     def legacy_125():
  102:         np.set_printoptions(legacy='1.25', precision=7)
  103:         b.wait()
  104:         po = np.get_printoptions()
  105:         assert po['legacy'] == '1.25'
  106:         assert po['precision'] == 7
  107:         orig_linewidth = po['linewidth']
  108:         with np.printoptions(linewidth=6, legacy='1.13'):
  109:             po = np.get_printoptions()
  110:             assert po['legacy'] == '1.13'
  111:             assert po['precision'] == 7
  112:             assert po['linewidth'] == 6
  113:         po = np.get_printoptions()
  114:         assert po['linewidth'] == orig_linewidth
  115:         assert po['legacy'] == '1.25'
  116:         assert po['precision'] == 7
  117: 
  118:     task1 = threading.Thread(target=legacy_113)
  119:     task2 = threading.Thread(target=legacy_125)
  120: 
  121:     task1.start()
  122:     task2.start()
  123: 
  124: 
  125: def test_parallel_reduction():
  126:     # gh-28041
  127:     NUM_THREADS = 50
  128: 
  129:     x = np.arange(1000)
  130: 
  131:     def closure(b):
  132:         b.wait()
  133:         np.sum(x)
  134: 
  135:     run_threaded(closure, NUM_THREADS, pass_barrier=True)
  136: 
  137: 
  138: def test_parallel_flat_iterator():
  139:     # gh-28042
  140:     x = np.arange(20).reshape(5, 4).T
  141: 
  142:     def closure(b):
  143:         b.wait()
  144:         for _ in range(100):
  145:             list(x.flat)
  146: 
  147:     run_threaded(closure, outer_iterations=100, pass_barrier=True)
  148: 
  149:     # gh-28143
  150:     def prepare_args():
  151:         return [np.arange(10)]
  152: 
  153:     def closure(x, b):
  154:         b.wait()
  155:         for _ in range(100):
  156:             y = np.arange(10)
  157:             y.flat[x] = x
  158: 
  159:     run_threaded(closure, pass_barrier=True, prepare_args=prepare_args)
  160: 
  161: 
  162: def test_multithreaded_repeat():
  163:     x0 = np.arange(10)
  164: 
  165:     def closure(b):
  166:         b.wait()
  167:         for _ in range(100):
  168:             x = np.repeat(x0, 2, axis=0)[::2]
  169: 
  170:     run_threaded(closure, max_workers=10, pass_barrier=True)
  171: 
  172: 
  173: def test_structured_advanced_indexing():
  174:     # Test that copyswap(n) used by integer array indexing is threadsafe
  175:     # for structured datatypes, see gh-15387. This test can behave randomly.
  176: 
  177:     # Create a deeply nested dtype to make a failure more likely:
  178:     dt = np.dtype([("", "f8")])
  179:     dt = np.dtype([("", dt)] * 2)
  180:     dt = np.dtype([("", dt)] * 2)
  181:     # The array should be large enough to likely run into threading issues
  182:     arr = np.random.uniform(size=(6000, 8)).view(dt)[:, 0]
  183: 
  184:     rng = np.random.default_rng()
  185: 
  186:     def func(arr):
  187:         indx = rng.integers(0, len(arr), size=6000, dtype=np.intp)
  188:         arr[indx]
  189: 
  190:     tpe = concurrent.futures.ThreadPoolExecutor(max_workers=8)
  191:     futures = [tpe.submit(func, arr) for _ in range(10)]
  192:     for f in futures:
  193:         f.result()
  194: 
  195:     assert arr.dtype is dt
  196: 
  197: 
  198: def test_structured_threadsafety2():
  199:     # Nonzero (and some other functions) should be threadsafe for
  200:     # structured datatypes, see gh-15387. This test can behave randomly.
  201:     from concurrent.futures import ThreadPoolExecutor
  202: 
  203:     # Create a deeply nested dtype to make a failure more likely:
  204:     dt = np.dtype([("", "f8")])
  205:     dt = np.dtype([("", dt)])
  206:     dt = np.dtype([("", dt)] * 2)
  207:     # The array should be large enough to likely run into threading issues
  208:     arr = np.random.uniform(size=(5000, 4)).view(dt)[:, 0]
  209: 
  210:     def func(arr):
  211:         arr.nonzero()
  212: 
  213:     tpe = ThreadPoolExecutor(max_workers=8)
  214:     futures = [tpe.submit(func, arr) for _ in range(10)]
  215:     for f in futures:
  216:         f.result()
  217: 
  218:     assert arr.dtype is dt
  219: 
  220: 
  221: def test_stringdtype_multithreaded_access_and_mutation(
  222:         dtype, random_string_list):
  223:     # this test uses an RNG and may crash or cause deadlocks if there is a
  224:     # threading bug
  225:     rng = np.random.default_rng(0x4D3D3D3)
  226: 
  227:     chars = list(string.ascii_letters + string.digits)
  228:     chars = np.array(chars, dtype="U1")
  229:     ret = rng.choice(chars, size=100 * 10, replace=True)
  230:     random_string_list = ret.view("U100")
  231: 
  232:     def func(arr):
  233:         rnd = rng.random()
  234:         # either write to random locations in the array, compute a ufunc, or
  235:         # re-initialize the array
  236:         if rnd < 0.25:
  237:             num = np.random.randint(0, arr.size)
  238:             arr[num] = arr[num] + "hello"
  239:         elif rnd < 0.5:
  240:             if rnd < 0.375:
  241:                 np.add(arr, arr)
  242:             else:
  243:                 np.add(arr, arr, out=arr)
  244:         elif rnd < 0.75:
  245:             if rnd < 0.875:
  246:                 np.multiply(arr, np.int64(2))
  247:             else:
  248:                 np.multiply(arr, np.int64(2), out=arr)
  249:         else:
  250:             arr[:] = random_string_list
  251: 
  252:     with concurrent.futures.ThreadPoolExecutor(max_workers=8) as tpe:
  253:         arr = np.array(random_string_list, dtype=dtype)
  254:         futures = [tpe.submit(func, arr) for _ in range(500)]
  255: 
  256:         for f in futures:
  257:             f.result()
  258: 
  259: 
  260: @pytest.mark.skipif(
  261:     not IS_64BIT,
  262:     reason="Sometimes causes failures or crashes due to OOM on 32 bit runners"
  263: )
  264: def test_legacy_usertype_cast_init_thread_safety():
  265:     def closure(b):
  266:         b.wait()
  267:         np.full((10, 10), 1, _rational_tests.rational)
  268: 
  269:     run_threaded(closure, 250, pass_barrier=True)
  270: 
  271: @pytest.mark.parametrize("dtype", [bool, int, float])
  272: def test_nonzero(dtype):
  273:     # See: gh-28361
  274:     #
  275:     # np.nonzero uses np.count_nonzero to determine the size of the output array
  276:     # In a second pass the indices of the non-zero elements are determined, but they can have changed
  277:     #
  278:     # This test triggers a data race which is suppressed in the TSAN CI. The test is to ensure
  279:     # np.nonzero does not generate a segmentation fault
  280:     x = np.random.randint(4, size=100).astype(dtype)
  281: 
  282:     def func(index):
  283:         for _ in range(10):
  284:             if index == 0:
  285:                 x[::2] = np.random.randint(2)
  286:             else:
  287:                 try:
  288:                     _ = np.nonzero(x)
  289:                 except RuntimeError as ex:
  290:                     assert 'number of non-zero array elements changed during function execution' in str(ex)
  291: 
  292:     run_threaded(func, max_workers=10, pass_count=True, outer_iterations=5)
