    1: import platform
    2: 
    3: import pytest
    4: 
    5: import numpy as np
    6: from numpy import float16, float32, float64, uint16
    7: from numpy.testing import IS_WASM, assert_, assert_equal
    8: 
    9: 
   10: def assert_raises_fpe(strmatch, callable, *args, **kwargs):
   11:     try:
   12:         callable(*args, **kwargs)
   13:     except FloatingPointError as exc:
   14:         assert_(str(exc).find(strmatch) >= 0,
   15:                 f"Did not raise floating point {strmatch} error")
   16:     else:
   17:         assert_(False,
   18:                 f"Did not raise floating point {strmatch} error")
   19: 
   20: class TestHalf:
   21:     def setup_method(self):
   22:         # An array of all possible float16 values
   23:         self.all_f16 = np.arange(0x10000, dtype=uint16)
   24:         self.all_f16.dtype = float16
   25: 
   26:         # NaN value can cause an invalid FP exception if HW is being used
   27:         with np.errstate(invalid='ignore'):
   28:             self.all_f32 = np.array(self.all_f16, dtype=float32)
   29:             self.all_f64 = np.array(self.all_f16, dtype=float64)
   30: 
   31:         # An array of all non-NaN float16 values, in sorted order
   32:         self.nonan_f16 = np.concatenate(
   33:                                 (np.arange(0xfc00, 0x7fff, -1, dtype=uint16),
   34:                                  np.arange(0x0000, 0x7c01, 1, dtype=uint16)))
   35:         self.nonan_f16.dtype = float16
   36:         self.nonan_f32 = np.array(self.nonan_f16, dtype=float32)
   37:         self.nonan_f64 = np.array(self.nonan_f16, dtype=float64)
   38: 
   39:         # An array of all finite float16 values, in sorted order
   40:         self.finite_f16 = self.nonan_f16[1:-1]
   41:         self.finite_f32 = self.nonan_f32[1:-1]
   42:         self.finite_f64 = self.nonan_f64[1:-1]
   43: 
   44:     def test_half_conversions(self):
   45:         """Checks that all 16-bit values survive conversion
   46:            to/from 32-bit and 64-bit float"""
   47:         # Because the underlying routines preserve the NaN bits, every
   48:         # value is preserved when converting to/from other floats.
   49: 
   50:         # Convert from float32 back to float16
   51:         with np.errstate(invalid='ignore'):
   52:             b = np.array(self.all_f32, dtype=float16)
   53:         # avoid testing NaNs due to differing bit patterns in Q/S NaNs
   54:         b_nn = b == b
   55:         assert_equal(self.all_f16[b_nn].view(dtype=uint16),
   56:                      b[b_nn].view(dtype=uint16))
   57: 
   58:         # Convert from float64 back to float16
   59:         with np.errstate(invalid='ignore'):
   60:             b = np.array(self.all_f64, dtype=float16)
   61:         b_nn = b == b
   62:         assert_equal(self.all_f16[b_nn].view(dtype=uint16),
   63:                      b[b_nn].view(dtype=uint16))
   64: 
   65:         # Convert float16 to longdouble and back
   66:         # This doesn't necessarily preserve the extra NaN bits,
   67:         # so exclude NaNs.
   68:         a_ld = np.array(self.nonan_f16, dtype=np.longdouble)
   69:         b = np.array(a_ld, dtype=float16)
   70:         assert_equal(self.nonan_f16.view(dtype=uint16),
   71:                      b.view(dtype=uint16))
   72: 
   73:         # Check the range for which all integers can be represented
   74:         i_int = np.arange(-2048, 2049)
   75:         i_f16 = np.array(i_int, dtype=float16)
   76:         j = np.array(i_f16, dtype=int)
   77:         assert_equal(i_int, j)
   78: 
   79:     @pytest.mark.parametrize("string_dt", ["S", "U"])
   80:     def test_half_conversion_to_string(self, string_dt):
   81:         # Currently uses S/U32 (which is sufficient for float32)
   82:         expected_dt = np.dtype(f"{string_dt}32")
   83:         assert np.promote_types(np.float16, string_dt) == expected_dt
   84:         assert np.promote_types(string_dt, np.float16) == expected_dt
   85: 
   86:         arr = np.ones(3, dtype=np.float16).astype(string_dt)
   87:         assert arr.dtype == expected_dt
   88: 
   89:     @pytest.mark.parametrize("string_dt", ["S", "U"])
   90:     def test_half_conversion_from_string(self, string_dt):
   91:         string = np.array("3.1416", dtype=string_dt)
   92:         assert string.astype(np.float16) == np.array(3.1416, dtype=np.float16)
   93: 
   94:     @pytest.mark.parametrize("offset", [None, "up", "down"])
   95:     @pytest.mark.parametrize("shift", [None, "up", "down"])
   96:     @pytest.mark.parametrize("float_t", [np.float32, np.float64])
   97:     def test_half_conversion_rounding(self, float_t, shift, offset):
   98:         # Assumes that round to even is used during casting.
   99:         max_pattern = np.float16(np.finfo(np.float16).max).view(np.uint16)
  100: 
  101:         # Test all (positive) finite numbers, denormals are most interesting
  102:         # however:
  103:         f16s_patterns = np.arange(0, max_pattern + 1, dtype=np.uint16)
  104:         f16s_float = f16s_patterns.view(np.float16).astype(float_t)
  105: 
  106:         # Shift the values by half a bit up or a down (or do not shift),
  107:         if shift == "up":
  108:             f16s_float = 0.5 * (f16s_float[:-1] + f16s_float[1:])[1:]
  109:         elif shift == "down":
  110:             f16s_float = 0.5 * (f16s_float[:-1] + f16s_float[1:])[:-1]
  111:         else:
  112:             f16s_float = f16s_float[1:-1]
  113: 
  114:         # Increase the float by a minimal value:
  115:         if offset == "up":
  116:             f16s_float = np.nextafter(f16s_float, float_t(np.inf))
  117:         elif offset == "down":
  118:             f16s_float = np.nextafter(f16s_float, float_t(-np.inf))
  119: 
  120:         # Convert back to float16 and its bit pattern:
  121:         res_patterns = f16s_float.astype(np.float16).view(np.uint16)
  122: 
  123:         # The above calculation tries the original values, or the exact
  124:         # midpoints between the float16 values. It then further offsets them
  125:         # by as little as possible. If no offset occurs, "round to even"
  126:         # logic will be necessary, an arbitrarily small offset should cause
  127:         # normal up/down rounding always.
  128: 
  129:         # Calculate the expected pattern:
  130:         cmp_patterns = f16s_patterns[1:-1].copy()
  131: 
  132:         if shift == "down" and offset != "up":
  133:             shift_pattern = -1
  134:         elif shift == "up" and offset != "down":
  135:             shift_pattern = 1
  136:         else:
  137:             # There cannot be a shift, either shift is None, so all rounding
  138:             # will go back to original, or shift is reduced by offset too much.
  139:             shift_pattern = 0
  140: 
  141:         # If rounding occurs, is it normal rounding or round to even?
  142:         if offset is None:
  143:             # Round to even occurs, modify only non-even, cast to allow + (-1)
  144:             cmp_patterns[0::2].view(np.int16)[...] += shift_pattern
  145:         else:
  146:             cmp_patterns.view(np.int16)[...] += shift_pattern
  147: 
  148:         assert_equal(res_patterns, cmp_patterns)
  149: 
  150:     @pytest.mark.parametrize(["float_t", "uint_t", "bits"],
  151:                              [(np.float32, np.uint32, 23),
  152:                               (np.float64, np.uint64, 52)])
  153:     def test_half_conversion_denormal_round_even(self, float_t, uint_t, bits):
  154:         # Test specifically that all bits are considered when deciding
  155:         # whether round to even should occur (i.e. no bits are lost at the
  156:         # end. Compare also gh-12721. The most bits can get lost for the
  157:         # smallest denormal:
  158:         smallest_value = np.uint16(1).view(np.float16).astype(float_t)
  159:         assert smallest_value == 2**-24
  160: 
  161:         # Will be rounded to zero based on round to even rule:
  162:         rounded_to_zero = smallest_value / float_t(2)
  163:         assert rounded_to_zero.astype(np.float16) == 0
  164: 
  165:         # The significand will be all 0 for the float_t, test that we do not
  166:         # lose the lower ones of these:
  167:         for i in range(bits):
  168:             # slightly increasing the value should make it round up:
  169:             larger_pattern = rounded_to_zero.view(uint_t) | uint_t(1 << i)
  170:             larger_value = larger_pattern.view(float_t)
  171:             assert larger_value.astype(np.float16) == smallest_value
  172: 
  173:     def test_nans_infs(self):
  174:         with np.errstate(all='ignore'):
  175:             # Check some of the ufuncs
  176:             assert_equal(np.isnan(self.all_f16), np.isnan(self.all_f32))
  177:             assert_equal(np.isinf(self.all_f16), np.isinf(self.all_f32))
  178:             assert_equal(np.isfinite(self.all_f16), np.isfinite(self.all_f32))
  179:             assert_equal(np.signbit(self.all_f16), np.signbit(self.all_f32))
  180:             assert_equal(np.spacing(float16(65504)), np.inf)
  181: 
  182:             # Check comparisons of all values with NaN
  183:             nan = float16(np.nan)
  184: 
  185:             assert_(not (self.all_f16 == nan).any())
  186:             assert_(not (nan == self.all_f16).any())
  187: 
  188:             assert_((self.all_f16 != nan).all())
  189:             assert_((nan != self.all_f16).all())
  190: 
  191:             assert_(not (self.all_f16 < nan).any())
  192:             assert_(not (nan < self.all_f16).any())
  193: 
  194:             assert_(not (self.all_f16 <= nan).any())
  195:             assert_(not (nan <= self.all_f16).any())
  196: 
  197:             assert_(not (self.all_f16 > nan).any())
  198:             assert_(not (nan > self.all_f16).any())
  199: 
  200:             assert_(not (self.all_f16 >= nan).any())
  201:             assert_(not (nan >= self.all_f16).any())
  202: 
  203:     def test_half_values(self):
  204:         """Confirms a small number of known half values"""
  205:         a = np.array([1.0, -1.0,
  206:                       2.0, -2.0,
  207:                       0.0999755859375, 0.333251953125,  # 1/10, 1/3
  208:                       65504, -65504,           # Maximum magnitude
  209:                       2.0**(-14), -2.0**(-14),  # Minimum normal
  210:                       2.0**(-24), -2.0**(-24),  # Minimum subnormal
  211:                       0, -1 / 1e1000,            # Signed zeros
  212:                       np.inf, -np.inf])
  213:         b = np.array([0x3c00, 0xbc00,
  214:                       0x4000, 0xc000,
  215:                       0x2e66, 0x3555,
  216:                       0x7bff, 0xfbff,
  217:                       0x0400, 0x8400,
  218:                       0x0001, 0x8001,
  219:                       0x0000, 0x8000,
  220:                       0x7c00, 0xfc00], dtype=uint16)
  221:         b.dtype = float16
  222:         assert_equal(a, b)
  223: 
  224:     def test_half_rounding(self):
  225:         """Checks that rounding when converting to half is correct"""
  226:         a = np.array([2.0**-25 + 2.0**-35,  # Rounds to minimum subnormal
  227:                       2.0**-25,       # Underflows to zero (nearest even mode)
  228:                       2.0**-26,       # Underflows to zero
  229:                       1.0 + 2.0**-11 + 2.0**-16,  # rounds to 1.0+2**(-10)
  230:                       1.0 + 2.0**-11,   # rounds to 1.0 (nearest even mode)
  231:                       1.0 + 2.0**-12,   # rounds to 1.0
  232:                       65519,          # rounds to 65504
  233:                       65520],         # rounds to inf
  234:                       dtype=float64)
  235:         rounded = [2.0**-24,
  236:                    0.0,
  237:                    0.0,
  238:                    1.0 + 2.0**(-10),
  239:                    1.0,
  240:                    1.0,
  241:                    65504,
  242:                    np.inf]
  243: 
  244:         # Check float64->float16 rounding
  245:         with np.errstate(over="ignore"):
  246:             b = np.array(a, dtype=float16)
  247:         assert_equal(b, rounded)
  248: 
  249:         # Check float32->float16 rounding
  250:         a = np.array(a, dtype=float32)
  251:         with np.errstate(over="ignore"):
  252:             b = np.array(a, dtype=float16)
  253:         assert_equal(b, rounded)
  254: 
  255:     def test_half_correctness(self):
  256:         """Take every finite float16, and check the casting functions with
  257:            a manual conversion."""
  258: 
  259:         # Create an array of all finite float16s
  260:         a_bits = self.finite_f16.view(dtype=uint16)
  261: 
  262:         # Convert to 64-bit float manually
  263:         a_sgn = (-1.0)**((a_bits & 0x8000) >> 15)
  264:         a_exp = np.array((a_bits & 0x7c00) >> 10, dtype=np.int32) - 15
  265:         a_man = (a_bits & 0x03ff) * 2.0**(-10)
  266:         # Implicit bit of normalized floats
  267:         a_man[a_exp != -15] += 1
  268:         # Denormalized exponent is -14
  269:         a_exp[a_exp == -15] = -14
  270: 
  271:         a_manual = a_sgn * a_man * 2.0**a_exp
  272: 
  273:         a32_fail = np.nonzero(self.finite_f32 != a_manual)[0]
  274:         if len(a32_fail) != 0:
  275:             bad_index = a32_fail[0]
  276:             assert_equal(self.finite_f32, a_manual,
  277:                  "First non-equal is half value 0x%x -> %g != %g" %
  278:                             (a_bits[bad_index],
  279:                              self.finite_f32[bad_index],
  280:                              a_manual[bad_index]))
  281: 
  282:         a64_fail = np.nonzero(self.finite_f64 != a_manual)[0]
  283:         if len(a64_fail) != 0:
  284:             bad_index = a64_fail[0]
  285:             assert_equal(self.finite_f64, a_manual,
  286:                  "First non-equal is half value 0x%x -> %g != %g" %
  287:                             (a_bits[bad_index],
  288:                              self.finite_f64[bad_index],
  289:                              a_manual[bad_index]))
  290: 
  291:     def test_half_ordering(self):
  292:         """Make sure comparisons are working right"""
  293: 
  294:         # All non-NaN float16 values in reverse order
  295:         a = self.nonan_f16[::-1].copy()
  296: 
  297:         # 32-bit float copy
  298:         b = np.array(a, dtype=float32)
  299: 
  300:         # Should sort the same
  301:         a.sort()
  302:         b.sort()
  303:         assert_equal(a, b)
  304: 
  305:         # Comparisons should work
  306:         assert_((a[:-1] <= a[1:]).all())
  307:         assert_(not (a[:-1] > a[1:]).any())
  308:         assert_((a[1:] >= a[:-1]).all())
  309:         assert_(not (a[1:] < a[:-1]).any())
  310:         # All != except for +/-0
  311:         assert_equal(np.nonzero(a[:-1] < a[1:])[0].size, a.size - 2)
  312:         assert_equal(np.nonzero(a[1:] > a[:-1])[0].size, a.size - 2)
  313: 
  314:     def test_half_funcs(self):
  315:         """Test the various ArrFuncs"""
  316: 
  317:         # fill
  318:         assert_equal(np.arange(10, dtype=float16),
  319:                      np.arange(10, dtype=float32))
  320: 
  321:         # fillwithscalar
  322:         a = np.zeros((5,), dtype=float16)
  323:         a.fill(1)
  324:         assert_equal(a, np.ones((5,), dtype=float16))
  325: 
  326:         # nonzero and copyswap
  327:         a = np.array([0, 0, -1, -1 / 1e20, 0, 2.0**-24, 7.629e-6], dtype=float16)
  328:         assert_equal(a.nonzero()[0],
  329:                      [2, 5, 6])
  330:         a = a.byteswap()
  331:         a = a.view(a.dtype.newbyteorder())
  332:         assert_equal(a.nonzero()[0],
  333:                      [2, 5, 6])
  334: 
  335:         # dot
  336:         a = np.arange(0, 10, 0.5, dtype=float16)
  337:         b = np.ones((20,), dtype=float16)
  338:         assert_equal(np.dot(a, b),
  339:                      95)
  340: 
  341:         # argmax
  342:         a = np.array([0, -np.inf, -2, 0.5, 12.55, 7.3, 2.1, 12.4], dtype=float16)
  343:         assert_equal(a.argmax(),
  344:                      4)
  345:         a = np.array([0, -np.inf, -2, np.inf, 12.55, np.nan, 2.1, 12.4], dtype=float16)
  346:         assert_equal(a.argmax(),
  347:                      5)
  348: 
  349:         # getitem
  350:         a = np.arange(10, dtype=float16)
  351:         for i in range(10):
  352:             assert_equal(a.item(i), i)
  353: 
  354:     def test_spacing_nextafter(self):
  355:         """Test np.spacing and np.nextafter"""
  356:         # All non-negative finite #'s
  357:         a = np.arange(0x7c00, dtype=uint16)
  358:         hinf = np.array((np.inf,), dtype=float16)
  359:         hnan = np.array((np.nan,), dtype=float16)
  360:         a_f16 = a.view(dtype=float16)
  361: 
  362:         assert_equal(np.spacing(a_f16[:-1]), a_f16[1:] - a_f16[:-1])
  363: 
  364:         assert_equal(np.nextafter(a_f16[:-1], hinf), a_f16[1:])
  365:         assert_equal(np.nextafter(a_f16[0], -hinf), -a_f16[1])
  366:         assert_equal(np.nextafter(a_f16[1:], -hinf), a_f16[:-1])
  367: 
  368:         assert_equal(np.nextafter(hinf, a_f16), a_f16[-1])
  369:         assert_equal(np.nextafter(-hinf, a_f16), -a_f16[-1])
  370: 
  371:         assert_equal(np.nextafter(hinf, hinf), hinf)
  372:         assert_equal(np.nextafter(hinf, -hinf), a_f16[-1])
  373:         assert_equal(np.nextafter(-hinf, hinf), -a_f16[-1])
  374:         assert_equal(np.nextafter(-hinf, -hinf), -hinf)
  375: 
  376:         assert_equal(np.nextafter(a_f16, hnan), hnan[0])
  377:         assert_equal(np.nextafter(hnan, a_f16), hnan[0])
  378: 
  379:         assert_equal(np.nextafter(hnan, hnan), hnan)
  380:         assert_equal(np.nextafter(hinf, hnan), hnan)
  381:         assert_equal(np.nextafter(hnan, hinf), hnan)
  382: 
  383:         # switch to negatives
  384:         a |= 0x8000
  385: 
  386:         assert_equal(np.spacing(a_f16[0]), np.spacing(a_f16[1]))
  387:         assert_equal(np.spacing(a_f16[1:]), a_f16[:-1] - a_f16[1:])
  388: 
  389:         assert_equal(np.nextafter(a_f16[0], hinf), -a_f16[1])
  390:         assert_equal(np.nextafter(a_f16[1:], hinf), a_f16[:-1])
  391:         assert_equal(np.nextafter(a_f16[:-1], -hinf), a_f16[1:])
  392: 
  393:         assert_equal(np.nextafter(hinf, a_f16), -a_f16[-1])
  394:         assert_equal(np.nextafter(-hinf, a_f16), a_f16[-1])
  395: 
  396:         assert_equal(np.nextafter(a_f16, hnan), hnan[0])
  397:         assert_equal(np.nextafter(hnan, a_f16), hnan[0])
  398: 
  399:     def test_half_ufuncs(self):
  400:         """Test the various ufuncs"""
  401: 
  402:         a = np.array([0, 1, 2, 4, 2], dtype=float16)
  403:         b = np.array([-2, 5, 1, 4, 3], dtype=float16)
  404:         c = np.array([0, -1, -np.inf, np.nan, 6], dtype=float16)
  405: 
  406:         assert_equal(np.add(a, b), [-2, 6, 3, 8, 5])
  407:         assert_equal(np.subtract(a, b), [2, -4, 1, 0, -1])
  408:         assert_equal(np.multiply(a, b), [0, 5, 2, 16, 6])
  409:         assert_equal(np.divide(a, b), [0, 0.199951171875, 2, 1, 0.66650390625])
  410: 
  411:         assert_equal(np.equal(a, b), [False, False, False, True, False])
  412:         assert_equal(np.not_equal(a, b), [True, True, True, False, True])
  413:         assert_equal(np.less(a, b), [False, True, False, False, True])
  414:         assert_equal(np.less_equal(a, b), [False, True, False, True, True])
  415:         assert_equal(np.greater(a, b), [True, False, True, False, False])
  416:         assert_equal(np.greater_equal(a, b), [True, False, True, True, False])
  417:         assert_equal(np.logical_and(a, b), [False, True, True, True, True])
  418:         assert_equal(np.logical_or(a, b), [True, True, True, True, True])
  419:         assert_equal(np.logical_xor(a, b), [True, False, False, False, False])
  420:         assert_equal(np.logical_not(a), [True, False, False, False, False])
  421: 
  422:         assert_equal(np.isnan(c), [False, False, False, True, False])
  423:         assert_equal(np.isinf(c), [False, False, True, False, False])
  424:         assert_equal(np.isfinite(c), [True, True, False, False, True])
  425:         assert_equal(np.signbit(b), [True, False, False, False, False])
  426: 
  427:         assert_equal(np.copysign(b, a), [2, 5, 1, 4, 3])
  428: 
  429:         assert_equal(np.maximum(a, b), [0, 5, 2, 4, 3])
  430: 
  431:         x = np.maximum(b, c)
  432:         assert_(np.isnan(x[3]))
  433:         x[3] = 0
  434:         assert_equal(x, [0, 5, 1, 0, 6])
  435: 
  436:         assert_equal(np.minimum(a, b), [-2, 1, 1, 4, 2])
  437: 
  438:         x = np.minimum(b, c)
  439:         assert_(np.isnan(x[3]))
  440:         x[3] = 0
  441:         assert_equal(x, [-2, -1, -np.inf, 0, 3])
  442: 
  443:         assert_equal(np.fmax(a, b), [0, 5, 2, 4, 3])
  444:         assert_equal(np.fmax(b, c), [0, 5, 1, 4, 6])
  445:         assert_equal(np.fmin(a, b), [-2, 1, 1, 4, 2])
  446:         assert_equal(np.fmin(b, c), [-2, -1, -np.inf, 4, 3])
  447: 
  448:         assert_equal(np.floor_divide(a, b), [0, 0, 2, 1, 0])
  449:         assert_equal(np.remainder(a, b), [0, 1, 0, 0, 2])
  450:         assert_equal(np.divmod(a, b), ([0, 0, 2, 1, 0], [0, 1, 0, 0, 2]))
  451:         assert_equal(np.square(b), [4, 25, 1, 16, 9])
  452:         assert_equal(np.reciprocal(b), [-0.5, 0.199951171875, 1, 0.25, 0.333251953125])
  453:         assert_equal(np.ones_like(b), [1, 1, 1, 1, 1])
  454:         assert_equal(np.conjugate(b), b)
  455:         assert_equal(np.absolute(b), [2, 5, 1, 4, 3])
  456:         assert_equal(np.negative(b), [2, -5, -1, -4, -3])
  457:         assert_equal(np.positive(b), b)
  458:         assert_equal(np.sign(b), [-1, 1, 1, 1, 1])
  459:         assert_equal(np.modf(b), ([0, 0, 0, 0, 0], b))
  460:         assert_equal(np.frexp(b), ([-0.5, 0.625, 0.5, 0.5, 0.75], [2, 3, 1, 3, 2]))
  461:         assert_equal(np.ldexp(b, [0, 1, 2, 4, 2]), [-2, 10, 4, 64, 12])
  462: 
  463:     def test_half_coercion(self):
  464:         """Test that half gets coerced properly with the other types"""
  465:         a16 = np.array((1,), dtype=float16)
  466:         a32 = np.array((1,), dtype=float32)
  467:         b16 = float16(1)
  468:         b32 = float32(1)
  469: 
  470:         assert np.power(a16, 2).dtype == float16
  471:         assert np.power(a16, 2.0).dtype == float16
  472:         assert np.power(a16, b16).dtype == float16
  473:         assert np.power(a16, b32).dtype == float32
  474:         assert np.power(a16, a16).dtype == float16
  475:         assert np.power(a16, a32).dtype == float32
  476: 
  477:         assert np.power(b16, 2).dtype == float16
  478:         assert np.power(b16, 2.0).dtype == float16
  479:         assert np.power(b16, b16).dtype, float16
  480:         assert np.power(b16, b32).dtype, float32
  481:         assert np.power(b16, a16).dtype, float16
  482:         assert np.power(b16, a32).dtype, float32
  483: 
  484:         assert np.power(a32, a16).dtype == float32
  485:         assert np.power(a32, b16).dtype == float32
  486:         assert np.power(b32, a16).dtype == float32
  487:         assert np.power(b32, b16).dtype == float32
  488: 
  489:     @pytest.mark.skipif(platform.machine() == "armv5tel",
  490:                         reason="See gh-413.")
  491:     @pytest.mark.skipif(IS_WASM,
  492:                         reason="fp exceptions don't work in wasm.")
  493:     def test_half_fpe(self):
  494:         with np.errstate(all='raise'):
  495:             sx16 = np.array((1e-4,), dtype=float16)
  496:             bx16 = np.array((1e4,), dtype=float16)
  497:             sy16 = float16(1e-4)
  498:             by16 = float16(1e4)
  499: 
  500:             # Underflow errors
  501:             assert_raises_fpe('underflow', lambda a, b: a * b, sx16, sx16)
  502:             assert_raises_fpe('underflow', lambda a, b: a * b, sx16, sy16)
  503:             assert_raises_fpe('underflow', lambda a, b: a * b, sy16, sx16)
  504:             assert_raises_fpe('underflow', lambda a, b: a * b, sy16, sy16)
  505:             assert_raises_fpe('underflow', lambda a, b: a / b, sx16, bx16)
  506:             assert_raises_fpe('underflow', lambda a, b: a / b, sx16, by16)
  507:             assert_raises_fpe('underflow', lambda a, b: a / b, sy16, bx16)
  508:             assert_raises_fpe('underflow', lambda a, b: a / b, sy16, by16)
  509:             assert_raises_fpe('underflow', lambda a, b: a / b,
  510:                                              float16(2.**-14), float16(2**11))
  511:             assert_raises_fpe('underflow', lambda a, b: a / b,
  512:                                              float16(-2.**-14), float16(2**11))
  513:             assert_raises_fpe('underflow', lambda a, b: a / b,
  514:                                              float16(2.**-14 + 2**-24), float16(2))
  515:             assert_raises_fpe('underflow', lambda a, b: a / b,
  516:                                              float16(-2.**-14 - 2**-24), float16(2))
  517:             assert_raises_fpe('underflow', lambda a, b: a / b,
  518:                                              float16(2.**-14 + 2**-23), float16(4))
  519: 
  520:             # Overflow errors
  521:             assert_raises_fpe('overflow', lambda a, b: a * b, bx16, bx16)
  522:             assert_raises_fpe('overflow', lambda a, b: a * b, bx16, by16)
  523:             assert_raises_fpe('overflow', lambda a, b: a * b, by16, bx16)
  524:             assert_raises_fpe('overflow', lambda a, b: a * b, by16, by16)
  525:             assert_raises_fpe('overflow', lambda a, b: a / b, bx16, sx16)
  526:             assert_raises_fpe('overflow', lambda a, b: a / b, bx16, sy16)
  527:             assert_raises_fpe('overflow', lambda a, b: a / b, by16, sx16)
  528:             assert_raises_fpe('overflow', lambda a, b: a / b, by16, sy16)
  529:             assert_raises_fpe('overflow', lambda a, b: a + b,
  530:                                              float16(65504), float16(17))
  531:             assert_raises_fpe('overflow', lambda a, b: a - b,
  532:                                              float16(-65504), float16(17))
  533:             assert_raises_fpe('overflow', np.nextafter, float16(65504), float16(np.inf))
  534:             assert_raises_fpe('overflow', np.nextafter, float16(-65504), float16(-np.inf))
  535:             assert_raises_fpe('overflow', np.spacing, float16(65504))
  536: 
  537:             # Invalid value errors
  538:             assert_raises_fpe('invalid', np.divide, float16(np.inf), float16(np.inf))
  539:             assert_raises_fpe('invalid', np.spacing, float16(np.inf))
  540:             assert_raises_fpe('invalid', np.spacing, float16(np.nan))
  541: 
  542:             # These should not raise
  543:             float16(65472) + float16(32)
  544:             float16(2**-13) / float16(2)
  545:             float16(2**-14) / float16(2**10)
  546:             np.spacing(float16(-65504))
  547:             np.nextafter(float16(65504), float16(-np.inf))
  548:             np.nextafter(float16(-65504), float16(np.inf))
  549:             np.nextafter(float16(np.inf), float16(0))
  550:             np.nextafter(float16(-np.inf), float16(0))
  551:             np.nextafter(float16(0), float16(np.nan))
  552:             np.nextafter(float16(np.nan), float16(0))
  553:             float16(2**-14) / float16(2**10)
  554:             float16(-2**-14) / float16(2**10)
  555:             float16(2**-14 + 2**-23) / float16(2)
  556:             float16(-2**-14 - 2**-23) / float16(2)
  557: 
  558:     def test_half_array_interface(self):
  559:         """Test that half is compatible with __array_interface__"""
  560:         class Dummy:
  561:             pass
  562: 
  563:         a = np.ones((1,), dtype=float16)
  564:         b = Dummy()
  565:         b.__array_interface__ = a.__array_interface__
  566:         c = np.array(b)
  567:         assert_(c.dtype == float16)
  568:         assert_equal(a, c)
