    1: import builtins
    2: import collections.abc
    3: import ctypes
    4: import functools
    5: import gc
    6: import io
    7: import itertools
    8: import mmap
    9: import operator
   10: import os
   11: import pathlib
   12: import pickle
   13: import re
   14: import sys
   15: import tempfile
   16: import warnings
   17: import weakref
   18: from contextlib import contextmanager
   19: 
   20: # Need to test an object that does not fully implement math interface
   21: from datetime import datetime, timedelta
   22: from decimal import Decimal
   23: 
   24: import numpy._core._multiarray_tests as _multiarray_tests
   25: import pytest
   26: from numpy._core._rational_tests import rational
   27: 
   28: import numpy as np
   29: from numpy._core.multiarray import _get_ndarray_c_version, dot
   30: from numpy._core.tests._locales import CommaDecimalPointLocale
   31: from numpy.exceptions import AxisError, ComplexWarning
   32: from numpy.lib.recfunctions import repack_fields
   33: from numpy.testing import (
   34:     BLAS_SUPPORTS_FPE,
   35:     HAS_REFCOUNT,
   36:     IS_64BIT,
   37:     IS_PYPY,
   38:     IS_PYSTON,
   39:     IS_WASM,
   40:     assert_,
   41:     assert_allclose,
   42:     assert_almost_equal,
   43:     assert_array_almost_equal,
   44:     assert_array_compare,
   45:     assert_array_equal,
   46:     assert_array_less,
   47:     assert_equal,
   48:     assert_raises,
   49:     assert_raises_regex,
   50:     assert_warns,
   51:     break_cycles,
   52:     check_support_sve,
   53:     runstring,
   54:     suppress_warnings,
   55:     temppath,
   56: )
   57: from numpy.testing._private.utils import _no_tracing, requires_memory
   58: 
   59: 
   60: def assert_arg_sorted(arr, arg):
   61:     # resulting array should be sorted and arg values should be unique
   62:     assert_equal(arr[arg], np.sort(arr))
   63:     assert_equal(np.sort(arg), np.arange(len(arg)))
   64: 
   65: 
   66: def assert_arr_partitioned(kth, k, arr_part):
   67:     assert_equal(arr_part[k], kth)
   68:     assert_array_compare(operator.__le__, arr_part[:k], kth)
   69:     assert_array_compare(operator.__ge__, arr_part[k:], kth)
   70: 
   71: 
   72: def _aligned_zeros(shape, dtype=float, order="C", align=None):
   73:     """
   74:     Allocate a new ndarray with aligned memory.
   75: 
   76:     The ndarray is guaranteed *not* aligned to twice the requested alignment.
   77:     Eg, if align=4, guarantees it is not aligned to 8. If align=None uses
   78:     dtype.alignment."""
   79:     dtype = np.dtype(dtype)
   80:     if dtype == np.dtype(object):
   81:         # Can't do this, fall back to standard allocation (which
   82:         # should always be sufficiently aligned)
   83:         if align is not None:
   84:             raise ValueError("object array alignment not supported")
   85:         return np.zeros(shape, dtype=dtype, order=order)
   86:     if align is None:
   87:         align = dtype.alignment
   88:     if not hasattr(shape, '__len__'):
   89:         shape = (shape,)
   90:     size = functools.reduce(operator.mul, shape) * dtype.itemsize
   91:     buf = np.empty(size + 2 * align + 1, np.uint8)
   92: 
   93:     ptr = buf.__array_interface__['data'][0]
   94:     offset = ptr % align
   95:     if offset != 0:
   96:         offset = align - offset
   97:     if (ptr % (2 * align)) == 0:
   98:         offset += align
   99: 
  100:     # Note: slices producing 0-size arrays do not necessarily change
  101:     # data pointer --- so we use and allocate size+1
  102:     buf = buf[offset:offset + size + 1][:-1]
  103:     buf.fill(0)
  104:     data = np.ndarray(shape, dtype, buf, order=order)
  105:     return data
  106: 
  107: 
  108: class TestFlags:
  109:     def setup_method(self):
  110:         self.a = np.arange(10)
  111: 
  112:     def test_writeable(self):
  113:         mydict = locals()
  114:         self.a.flags.writeable = False
  115:         assert_raises(ValueError, runstring, 'self.a[0] = 3', mydict)
  116:         self.a.flags.writeable = True
  117:         self.a[0] = 5
  118:         self.a[0] = 0
  119: 
  120:     def test_writeable_any_base(self):
  121:         # Ensure that any base being writeable is sufficient to change flag;
  122:         # this is especially interesting for arrays from an array interface.
  123:         arr = np.arange(10)
  124: 
  125:         class subclass(np.ndarray):
  126:             pass
  127: 
  128:         # Create subclass so base will not be collapsed, this is OK to change
  129:         view1 = arr.view(subclass)
  130:         view2 = view1[...]
  131:         arr.flags.writeable = False
  132:         view2.flags.writeable = False
  133:         view2.flags.writeable = True  # Can be set to True again.
  134: 
  135:         arr = np.arange(10)
  136: 
  137:         class frominterface:
  138:             def __init__(self, arr):
  139:                 self.arr = arr
  140:                 self.__array_interface__ = arr.__array_interface__
  141: 
  142:         view1 = np.asarray(frominterface)
  143:         view2 = view1[...]
  144:         view2.flags.writeable = False
  145:         view2.flags.writeable = True
  146: 
  147:         view1.flags.writeable = False
  148:         view2.flags.writeable = False
  149:         with assert_raises(ValueError):
  150:             # Must assume not writeable, since only base is not:
  151:             view2.flags.writeable = True
  152: 
  153:     def test_writeable_from_readonly(self):
  154:         # gh-9440 - make sure fromstring, from buffer on readonly buffers
  155:         # set writeable False
  156:         data = b'\x00' * 100
  157:         vals = np.frombuffer(data, 'B')
  158:         assert_raises(ValueError, vals.setflags, write=True)
  159:         types = np.dtype([('vals', 'u1'), ('res3', 'S4')])
  160:         values = np._core.records.fromstring(data, types)
  161:         vals = values['vals']
  162:         assert_raises(ValueError, vals.setflags, write=True)
  163: 
  164:     def test_writeable_from_buffer(self):
  165:         data = bytearray(b'\x00' * 100)
  166:         vals = np.frombuffer(data, 'B')
  167:         assert_(vals.flags.writeable)
  168:         vals.setflags(write=False)
  169:         assert_(vals.flags.writeable is False)
  170:         vals.setflags(write=True)
  171:         assert_(vals.flags.writeable)
  172:         types = np.dtype([('vals', 'u1'), ('res3', 'S4')])
  173:         values = np._core.records.fromstring(data, types)
  174:         vals = values['vals']
  175:         assert_(vals.flags.writeable)
  176:         vals.setflags(write=False)
  177:         assert_(vals.flags.writeable is False)
  178:         vals.setflags(write=True)
  179:         assert_(vals.flags.writeable)
  180: 
  181:     @pytest.mark.skipif(IS_PYPY, reason="PyPy always copies")
  182:     def test_writeable_pickle(self):
  183:         import pickle
  184:         # Small arrays will be copied without setting base.
  185:         # See condition for using PyArray_SetBaseObject in
  186:         # array_setstate.
  187:         a = np.arange(1000)
  188:         for v in range(pickle.HIGHEST_PROTOCOL):
  189:             vals = pickle.loads(pickle.dumps(a, v))
  190:             assert_(vals.flags.writeable)
  191:             assert_(isinstance(vals.base, bytes))
  192: 
  193:     def test_writeable_from_c_data(self):
  194:         # Test that the writeable flag can be changed for an array wrapping
  195:         # low level C-data, but not owning its data.
  196:         # Also see that this is deprecated to change from python.
  197:         from numpy._core._multiarray_tests import get_c_wrapping_array
  198: 
  199:         arr_writeable = get_c_wrapping_array(True)
  200:         assert not arr_writeable.flags.owndata
  201:         assert arr_writeable.flags.writeable
  202:         view = arr_writeable[...]
  203: 
  204:         # Toggling the writeable flag works on the view:
  205:         view.flags.writeable = False
  206:         assert not view.flags.writeable
  207:         view.flags.writeable = True
  208:         assert view.flags.writeable
  209:         # Flag can be unset on the arr_writeable:
  210:         arr_writeable.flags.writeable = False
  211: 
  212:         arr_readonly = get_c_wrapping_array(False)
  213:         assert not arr_readonly.flags.owndata
  214:         assert not arr_readonly.flags.writeable
  215: 
  216:         for arr in [arr_writeable, arr_readonly]:
  217:             view = arr[...]
  218:             view.flags.writeable = False  # make sure it is readonly
  219:             arr.flags.writeable = False
  220:             assert not arr.flags.writeable
  221: 
  222:             with assert_raises(ValueError):
  223:                 view.flags.writeable = True
  224: 
  225:             with assert_raises(ValueError):
  226:                 arr.flags.writeable = True
  227: 
  228:     def test_warnonwrite(self):
  229:         a = np.arange(10)
  230:         a.flags._warn_on_write = True
  231:         with warnings.catch_warnings(record=True) as w:
  232:             warnings.filterwarnings('always')
  233:             a[1] = 10
  234:             a[2] = 10
  235:             # only warn once
  236:             assert_(len(w) == 1)
  237: 
  238:     @pytest.mark.parametrize(["flag", "flag_value", "writeable"],
  239:             [("writeable", True, True),
  240:              # Delete _warn_on_write after deprecation and simplify
  241:              # the parameterization:
  242:              ("_warn_on_write", True, False),
  243:              ("writeable", False, False)])
  244:     def test_readonly_flag_protocols(self, flag, flag_value, writeable):
  245:         a = np.arange(10)
  246:         setattr(a.flags, flag, flag_value)
  247: 
  248:         class MyArr:
  249:             __array_struct__ = a.__array_struct__
  250: 
  251:         assert memoryview(a).readonly is not writeable
  252:         assert a.__array_interface__['data'][1] is not writeable
  253:         assert np.asarray(MyArr()).flags.writeable is writeable
  254: 
  255:     def test_otherflags(self):
  256:         assert_equal(self.a.flags.carray, True)
  257:         assert_equal(self.a.flags['C'], True)
  258:         assert_equal(self.a.flags.farray, False)
  259:         assert_equal(self.a.flags.behaved, True)
  260:         assert_equal(self.a.flags.fnc, False)
  261:         assert_equal(self.a.flags.forc, True)
  262:         assert_equal(self.a.flags.owndata, True)
  263:         assert_equal(self.a.flags.writeable, True)
  264:         assert_equal(self.a.flags.aligned, True)
  265:         assert_equal(self.a.flags.writebackifcopy, False)
  266:         assert_equal(self.a.flags['X'], False)
  267:         assert_equal(self.a.flags['WRITEBACKIFCOPY'], False)
  268: 
  269:     def test_string_align(self):
  270:         a = np.zeros(4, dtype=np.dtype('|S4'))
  271:         assert_(a.flags.aligned)
  272:         # not power of two are accessed byte-wise and thus considered aligned
  273:         a = np.zeros(5, dtype=np.dtype('|S4'))
  274:         assert_(a.flags.aligned)
  275: 
  276:     def test_void_align(self):
  277:         a = np.zeros(4, dtype=np.dtype([("a", "i4"), ("b", "i4")]))
  278:         assert_(a.flags.aligned)
  279: 
  280:     @pytest.mark.parametrize("row_size", [5, 1 << 16])
  281:     @pytest.mark.parametrize("row_count", [1, 5])
  282:     @pytest.mark.parametrize("ndmin", [0, 1, 2])
  283:     def test_xcontiguous_load_txt(self, row_size, row_count, ndmin):
  284:         s = io.StringIO('\n'.join(['1.0 ' * row_size] * row_count))
  285:         a = np.loadtxt(s, ndmin=ndmin)
  286: 
  287:         assert a.flags.c_contiguous
  288:         x = [i for i in a.shape if i != 1]
  289:         assert a.flags.f_contiguous == (len(x) <= 1)
  290: 
  291: 
  292: class TestHash:
  293:     # see #3793
  294:     def test_int(self):
  295:         for st, ut, s in [(np.int8, np.uint8, 8),
  296:                           (np.int16, np.uint16, 16),
  297:                           (np.int32, np.uint32, 32),
  298:                           (np.int64, np.uint64, 64)]:
  299:             for i in range(1, s):
  300:                 assert_equal(hash(st(-2**i)), hash(-2**i),
  301:                              err_msg="%r: -2**%d" % (st, i))
  302:                 assert_equal(hash(st(2**(i - 1))), hash(2**(i - 1)),
  303:                              err_msg="%r: 2**%d" % (st, i - 1))
  304:                 assert_equal(hash(st(2**i - 1)), hash(2**i - 1),
  305:                              err_msg="%r: 2**%d - 1" % (st, i))
  306: 
  307:                 i = max(i - 1, 1)
  308:                 assert_equal(hash(ut(2**(i - 1))), hash(2**(i - 1)),
  309:                              err_msg="%r: 2**%d" % (ut, i - 1))
  310:                 assert_equal(hash(ut(2**i - 1)), hash(2**i - 1),
  311:                              err_msg="%r: 2**%d - 1" % (ut, i))
  312: 
  313: 
  314: class TestAttributes:
  315:     def setup_method(self):
  316:         self.one = np.arange(10)
  317:         self.two = np.arange(20).reshape(4, 5)
  318:         self.three = np.arange(60, dtype=np.float64).reshape(2, 5, 6)
  319: 
  320:     def test_attributes(self):
  321:         assert_equal(self.one.shape, (10,))
  322:         assert_equal(self.two.shape, (4, 5))
  323:         assert_equal(self.three.shape, (2, 5, 6))
  324:         self.three.shape = (10, 3, 2)
  325:         assert_equal(self.three.shape, (10, 3, 2))
  326:         self.three.shape = (2, 5, 6)
  327:         assert_equal(self.one.strides, (self.one.itemsize,))
  328:         num = self.two.itemsize
  329:         assert_equal(self.two.strides, (5 * num, num))
  330:         num = self.three.itemsize
  331:         assert_equal(self.three.strides, (30 * num, 6 * num, num))
  332:         assert_equal(self.one.ndim, 1)
  333:         assert_equal(self.two.ndim, 2)
  334:         assert_equal(self.three.ndim, 3)
  335:         num = self.two.itemsize
  336:         assert_equal(self.two.size, 20)
  337:         assert_equal(self.two.nbytes, 20 * num)
  338:         assert_equal(self.two.itemsize, self.two.dtype.itemsize)
  339:         assert_equal(self.two.base, np.arange(20))
  340: 
  341:     def test_dtypeattr(self):
  342:         assert_equal(self.one.dtype, np.dtype(np.int_))
  343:         assert_equal(self.three.dtype, np.dtype(np.float64))
  344:         assert_equal(self.one.dtype.char, np.dtype(int).char)
  345:         assert self.one.dtype.char in "lq"
  346:         assert_equal(self.three.dtype.char, 'd')
  347:         assert_(self.three.dtype.str[0] in '<>')
  348:         assert_equal(self.one.dtype.str[1], 'i')
  349:         assert_equal(self.three.dtype.str[1], 'f')
  350: 
  351:     def test_int_subclassing(self):
  352:         # Regression test for https://github.com/numpy/numpy/pull/3526
  353: 
  354:         numpy_int = np.int_(0)
  355: 
  356:         # int_ doesn't inherit from Python int, because it's not fixed-width
  357:         assert_(not isinstance(numpy_int, int))
  358: 
  359:     def test_stridesattr(self):
  360:         x = self.one
  361: 
  362:         def make_array(size, offset, strides):
  363:             return np.ndarray(size, buffer=x, dtype=int,
  364:                               offset=offset * x.itemsize,
  365:                               strides=strides * x.itemsize)
  366: 
  367:         assert_equal(make_array(4, 4, -1), np.array([4, 3, 2, 1]))
  368:         assert_raises(ValueError, make_array, 4, 4, -2)
  369:         assert_raises(ValueError, make_array, 4, 2, -1)
  370:         assert_raises(ValueError, make_array, 8, 3, 1)
  371:         assert_equal(make_array(8, 3, 0), np.array([3] * 8))
  372:         # Check behavior reported in gh-2503:
  373:         assert_raises(ValueError, make_array, (2, 3), 5, np.array([-2, -3]))
  374:         make_array(0, 0, 10)
  375: 
  376:     def test_set_stridesattr(self):
  377:         x = self.one
  378: 
  379:         def make_array(size, offset, strides):
  380:             try:
  381:                 r = np.ndarray([size], dtype=int, buffer=x,
  382:                                offset=offset * x.itemsize)
  383:             except Exception as e:
  384:                 raise RuntimeError(e)
  385:             r.strides = strides = strides * x.itemsize
  386:             return r
  387: 
  388:         assert_equal(make_array(4, 4, -1), np.array([4, 3, 2, 1]))
  389:         assert_equal(make_array(7, 3, 1), np.array([3, 4, 5, 6, 7, 8, 9]))
  390:         assert_raises(ValueError, make_array, 4, 4, -2)
  391:         assert_raises(ValueError, make_array, 4, 2, -1)
  392:         assert_raises(RuntimeError, make_array, 8, 3, 1)
  393:         # Check that the true extent of the array is used.
  394:         # Test relies on as_strided base not exposing a buffer.
  395:         x = np.lib.stride_tricks.as_strided(np.arange(1), (10, 10), (0, 0))
  396: 
  397:         def set_strides(arr, strides):
  398:             arr.strides = strides
  399: 
  400:         assert_raises(ValueError, set_strides, x, (10 * x.itemsize, x.itemsize))
  401: 
  402:         # Test for offset calculations:
  403:         x = np.lib.stride_tricks.as_strided(np.arange(10, dtype=np.int8)[-1],
  404:                                                     shape=(10,), strides=(-1,))
  405:         assert_raises(ValueError, set_strides, x[::-1], -1)
  406:         a = x[::-1]
  407:         a.strides = 1
  408:         a[::2].strides = 2
  409: 
  410:         # test 0d
  411:         arr_0d = np.array(0)
  412:         arr_0d.strides = ()
  413:         assert_raises(TypeError, set_strides, arr_0d, None)
  414: 
  415:     def test_fill(self):
  416:         for t in "?bhilqpBHILQPfdgFDGO":
  417:             x = np.empty((3, 2, 1), t)
  418:             y = np.empty((3, 2, 1), t)
  419:             x.fill(1)
  420:             y[...] = 1
  421:             assert_equal(x, y)
  422: 
  423:     def test_fill_max_uint64(self):
  424:         x = np.empty((3, 2, 1), dtype=np.uint64)
  425:         y = np.empty((3, 2, 1), dtype=np.uint64)
  426:         value = 2**64 - 1
  427:         y[...] = value
  428:         x.fill(value)
  429:         assert_array_equal(x, y)
  430: 
  431:     def test_fill_struct_array(self):
  432:         # Filling from a scalar
  433:         x = np.array([(0, 0.0), (1, 1.0)], dtype='i4,f8')
  434:         x.fill(x[0])
  435:         assert_equal(x['f1'][1], x['f1'][0])
  436:         # Filling from a tuple that can be converted
  437:         # to a scalar
  438:         x = np.zeros(2, dtype=[('a', 'f8'), ('b', 'i4')])
  439:         x.fill((3.5, -2))
  440:         assert_array_equal(x['a'], [3.5, 3.5])
  441:         assert_array_equal(x['b'], [-2, -2])
  442: 
  443:     def test_fill_readonly(self):
  444:         # gh-22922
  445:         a = np.zeros(11)
  446:         a.setflags(write=False)
  447:         with pytest.raises(ValueError, match=".*read-only"):
  448:             a.fill(0)
  449: 
  450:     def test_fill_subarrays(self):
  451:         # NOTE:
  452:         # This is also a regression test for a crash with PYTHONMALLOC=debug
  453: 
  454:         dtype = np.dtype("2<i8, 2<i8, 2<i8")
  455:         data = ([1, 2], [3, 4], [5, 6])
  456: 
  457:         arr = np.empty(1, dtype=dtype)
  458:         arr.fill(data)
  459: 
  460:         assert_equal(arr, np.array(data, dtype=dtype))
  461: 
  462: 
  463: class TestArrayConstruction:
  464:     def test_array(self):
  465:         d = np.ones(6)
  466:         r = np.array([d, d])
  467:         assert_equal(r, np.ones((2, 6)))
  468: 
  469:         d = np.ones(6)
  470:         tgt = np.ones((2, 6))
  471:         r = np.array([d, d])
  472:         assert_equal(r, tgt)
  473:         tgt[1] = 2
  474:         r = np.array([d, d + 1])
  475:         assert_equal(r, tgt)
  476: 
  477:         d = np.ones(6)
  478:         r = np.array([[d, d]])
  479:         assert_equal(r, np.ones((1, 2, 6)))
  480: 
  481:         d = np.ones(6)
  482:         r = np.array([[d, d], [d, d]])
  483:         assert_equal(r, np.ones((2, 2, 6)))
  484: 
  485:         d = np.ones((6, 6))
  486:         r = np.array([d, d])
  487:         assert_equal(r, np.ones((2, 6, 6)))
  488: 
  489:         d = np.ones((6, ))
  490:         r = np.array([[d, d + 1], d + 2], dtype=object)
  491:         assert_equal(len(r), 2)
  492:         assert_equal(r[0], [d, d + 1])
  493:         assert_equal(r[1], d + 2)
  494: 
  495:         tgt = np.ones((2, 3), dtype=bool)
  496:         tgt[0, 2] = False
  497:         tgt[1, 0:2] = False
  498:         r = np.array([[True, True, False], [False, False, True]])
  499:         assert_equal(r, tgt)
  500:         r = np.array([[True, False], [True, False], [False, True]])
  501:         assert_equal(r, tgt.T)
  502: 
  503:     def test_array_empty(self):
  504:         assert_raises(TypeError, np.array)
  505: 
  506:     def test_0d_array_shape(self):
  507:         assert np.ones(np.array(3)).shape == (3,)
  508: 
  509:     def test_array_copy_false(self):
  510:         d = np.array([1, 2, 3])
  511:         e = np.array(d, copy=False)
  512:         d[1] = 3
  513:         assert_array_equal(e, [1, 3, 3])
  514:         np.array(d, copy=False, order='F')
  515: 
  516:     def test_array_copy_if_needed(self):
  517:         d = np.array([1, 2, 3])
  518:         e = np.array(d, copy=None)
  519:         d[1] = 3
  520:         assert_array_equal(e, [1, 3, 3])
  521:         e = np.array(d, copy=None, order='F')
  522:         d[1] = 4
  523:         assert_array_equal(e, [1, 4, 3])
  524:         e[2] = 7
  525:         assert_array_equal(d, [1, 4, 7])
  526: 
  527:     def test_array_copy_true(self):
  528:         d = np.array([[1, 2, 3], [1, 2, 3]])
  529:         e = np.array(d, copy=True)
  530:         d[0, 1] = 3
  531:         e[0, 2] = -7
  532:         assert_array_equal(e, [[1, 2, -7], [1, 2, 3]])
  533:         assert_array_equal(d, [[1, 3, 3], [1, 2, 3]])
  534:         e = np.array(d, copy=True, order='F')
  535:         d[0, 1] = 5
  536:         e[0, 2] = 7
  537:         assert_array_equal(e, [[1, 3, 7], [1, 2, 3]])
  538:         assert_array_equal(d, [[1, 5, 3], [1, 2, 3]])
  539: 
  540:     def test_array_copy_str(self):
  541:         with pytest.raises(
  542:             ValueError,
  543:             match="strings are not allowed for 'copy' keyword. "
  544:                   "Use True/False/None instead."
  545:         ):
  546:             np.array([1, 2, 3], copy="always")
  547: 
  548:     def test_array_cont(self):
  549:         d = np.ones(10)[::2]
  550:         assert_(np.ascontiguousarray(d).flags.c_contiguous)
  551:         assert_(np.ascontiguousarray(d).flags.f_contiguous)
  552:         assert_(np.asfortranarray(d).flags.c_contiguous)
  553:         assert_(np.asfortranarray(d).flags.f_contiguous)
  554:         d = np.ones((10, 10))[::2, ::2]
  555:         assert_(np.ascontiguousarray(d).flags.c_contiguous)
  556:         assert_(np.asfortranarray(d).flags.f_contiguous)
  557: 
  558:     @pytest.mark.parametrize("func",
  559:             [np.array,
  560:              np.asarray,
  561:              np.asanyarray,
  562:              np.ascontiguousarray,
  563:              np.asfortranarray])
  564:     def test_bad_arguments_error(self, func):
  565:         with pytest.raises(TypeError):
  566:             func(3, dtype="bad dtype")
  567:         with pytest.raises(TypeError):
  568:             func()  # missing arguments
  569:         with pytest.raises(TypeError):
  570:             func(1, 2, 3, 4, 5, 6, 7, 8)  # too many arguments
  571: 
  572:     @pytest.mark.parametrize("func",
  573:             [np.array,
  574:              np.asarray,
  575:              np.asanyarray,
  576:              np.ascontiguousarray,
  577:              np.asfortranarray])
  578:     def test_array_as_keyword(self, func):
  579:         # This should likely be made positional only, but do not change
  580:         # the name accidentally.
  581:         if func is np.array:
  582:             func(object=3)
  583:         else:
  584:             func(a=3)
  585: 
  586: 
  587: class TestAssignment:
  588:     def test_assignment_broadcasting(self):
  589:         a = np.arange(6).reshape(2, 3)
  590: 
  591:         # Broadcasting the input to the output
  592:         a[...] = np.arange(3)
  593:         assert_equal(a, [[0, 1, 2], [0, 1, 2]])
  594:         a[...] = np.arange(2).reshape(2, 1)
  595:         assert_equal(a, [[0, 0, 0], [1, 1, 1]])
  596: 
  597:         # For compatibility with <= 1.5, a limited version of broadcasting
  598:         # the output to the input.
  599:         #
  600:         # This behavior is inconsistent with NumPy broadcasting
  601:         # in general, because it only uses one of the two broadcasting
  602:         # rules (adding a new "1" dimension to the left of the shape),
  603:         # applied to the output instead of an input. In NumPy 2.0, this kind
  604:         # of broadcasting assignment will likely be disallowed.
  605:         a[...] = np.arange(6)[::-1].reshape(1, 2, 3)
  606:         assert_equal(a, [[5, 4, 3], [2, 1, 0]])
  607:         # The other type of broadcasting would require a reduction operation.
  608: 
  609:         def assign(a, b):
  610:             a[...] = b
  611: 
  612:         assert_raises(ValueError, assign, a, np.arange(12).reshape(2, 2, 3))
  613: 
  614:     def test_assignment_errors(self):
  615:         # Address issue #2276
  616:         class C:
  617:             pass
  618:         a = np.zeros(1)
  619: 
  620:         def assign(v):
  621:             a[0] = v
  622: 
  623:         assert_raises((AttributeError, TypeError), assign, C())
  624:         assert_raises(ValueError, assign, [1])
  625: 
  626:     @pytest.mark.filterwarnings(
  627:         "ignore:.*set_string_function.*:DeprecationWarning"
  628:     )
  629:     def test_unicode_assignment(self):
  630:         # gh-5049
  631:         from numpy._core.arrayprint import set_printoptions
  632: 
  633:         @contextmanager
  634:         def inject_str(s):
  635:             """ replace ndarray.__str__ temporarily """
  636:             set_printoptions(formatter={"all": lambda x: s})
  637:             try:
  638:                 yield
  639:             finally:
  640:                 set_printoptions()
  641: 
  642:         a1d = np.array(['test'])
  643:         a0d = np.array('done')
  644:         with inject_str('bad'):
  645:             a1d[0] = a0d  # previously this would invoke __str__
  646:         assert_equal(a1d[0], 'done')
  647: 
  648:         # this would crash for the same reason
  649:         np.array([np.array('\xe5\xe4\xf6')])
  650: 
  651:     def test_stringlike_empty_list(self):
  652:         # gh-8902
  653:         u = np.array(['done'])
  654:         b = np.array([b'done'])
  655: 
  656:         class bad_sequence:
  657:             def __getitem__(self, _, /): pass
  658:             def __len__(self): raise RuntimeError
  659: 
  660:         assert_raises(ValueError, operator.setitem, u, 0, [])
  661:         assert_raises(ValueError, operator.setitem, b, 0, [])
  662: 
  663:         assert_raises(ValueError, operator.setitem, u, 0, bad_sequence())
  664:         assert_raises(ValueError, operator.setitem, b, 0, bad_sequence())
  665: 
  666:     def test_longdouble_assignment(self):
  667:         # only relevant if longdouble is larger than float
  668:         # we're looking for loss of precision
  669: 
  670:         for dtype in (np.longdouble, np.clongdouble):
  671:             # gh-8902
  672:             tinyb = np.nextafter(np.longdouble(0), 1).astype(dtype)
  673:             tinya = np.nextafter(np.longdouble(0), -1).astype(dtype)
  674: 
  675:             # construction
  676:             tiny1d = np.array([tinya])
  677:             assert_equal(tiny1d[0], tinya)
  678: 
  679:             # scalar = scalar
  680:             tiny1d[0] = tinyb
  681:             assert_equal(tiny1d[0], tinyb)
  682: 
  683:             # 0d = scalar
  684:             tiny1d[0, ...] = tinya
  685:             assert_equal(tiny1d[0], tinya)
  686: 
  687:             # 0d = 0d
  688:             tiny1d[0, ...] = tinyb[...]
  689:             assert_equal(tiny1d[0], tinyb)
  690: 
  691:             # scalar = 0d
  692:             tiny1d[0] = tinyb[...]
  693:             assert_equal(tiny1d[0], tinyb)
  694: 
  695:             arr = np.array([np.array(tinya)])
  696:             assert_equal(arr[0], tinya)
  697: 
  698:     def test_cast_to_string(self):
  699:         # cast to str should do "str(scalar)", not "str(scalar.item())"
  700:         # When converting a float to a string via array assignment, we
  701:         # want to ensure that the conversion uses str(scalar) to preserve
  702:         # the expected precision.
  703:         a = np.zeros(1, dtype='S20')
  704:         a[:] = np.array(['1.12345678901234567890'], dtype='f8')
  705:         assert_equal(a[0], b"1.1234567890123457")
  706: 
  707: 
  708: class TestDtypedescr:
  709:     def test_construction(self):
  710:         d1 = np.dtype('i4')
  711:         assert_equal(d1, np.dtype(np.int32))
  712:         d2 = np.dtype('f8')
  713:         assert_equal(d2, np.dtype(np.float64))
  714: 
  715:     def test_byteorders(self):
  716:         assert_(np.dtype('<i4') != np.dtype('>i4'))
  717:         assert_(np.dtype([('a', '<i4')]) != np.dtype([('a', '>i4')]))
  718: 
  719:     def test_structured_non_void(self):
  720:         fields = [('a', '<i2'), ('b', '<i2')]
  721:         dt_int = np.dtype(('i4', fields))
  722:         assert_equal(str(dt_int), "(numpy.int32, [('a', '<i2'), ('b', '<i2')])")
  723: 
  724:         # gh-9821
  725:         arr_int = np.zeros(4, dt_int)
  726:         assert_equal(repr(arr_int),
  727:             "array([0, 0, 0, 0], dtype=(numpy.int32, [('a', '<i2'), ('b', '<i2')]))")
  728: 
  729: 
  730: class TestZeroRank:
  731:     def setup_method(self):
  732:         self.d = np.array(0), np.array('x', object)
  733: 
  734:     def test_ellipsis_subscript(self):
  735:         a, b = self.d
  736:         assert_equal(a[...], 0)
  737:         assert_equal(b[...], 'x')
  738:         assert_(a[...].base is a)  # `a[...] is a` in numpy <1.9.
  739:         assert_(b[...].base is b)  # `b[...] is b` in numpy <1.9.
  740: 
  741:     def test_empty_subscript(self):
  742:         a, b = self.d
  743:         assert_equal(a[()], 0)
  744:         assert_equal(b[()], 'x')
  745:         assert_(type(a[()]) is a.dtype.type)
  746:         assert_(type(b[()]) is str)
  747: 
  748:     def test_invalid_subscript(self):
  749:         a, b = self.d
  750:         assert_raises(IndexError, lambda x: x[0], a)
  751:         assert_raises(IndexError, lambda x: x[0], b)
  752:         assert_raises(IndexError, lambda x: x[np.array([], int)], a)
  753:         assert_raises(IndexError, lambda x: x[np.array([], int)], b)
  754: 
  755:     def test_ellipsis_subscript_assignment(self):
  756:         a, b = self.d
  757:         a[...] = 42
  758:         assert_equal(a, 42)
  759:         b[...] = ''
  760:         assert_equal(b.item(), '')
  761: 
  762:     def test_empty_subscript_assignment(self):
  763:         a, b = self.d
  764:         a[()] = 42
  765:         assert_equal(a, 42)
  766:         b[()] = ''
  767:         assert_equal(b.item(), '')
  768: 
  769:     def test_invalid_subscript_assignment(self):
  770:         a, b = self.d
  771: 
  772:         def assign(x, i, v):
  773:             x[i] = v
  774: 
  775:         assert_raises(IndexError, assign, a, 0, 42)
  776:         assert_raises(IndexError, assign, b, 0, '')
  777:         assert_raises(ValueError, assign, a, (), '')
  778: 
  779:     def test_newaxis(self):
  780:         a, b = self.d
  781:         assert_equal(a[np.newaxis].shape, (1,))
  782:         assert_equal(a[..., np.newaxis].shape, (1,))
  783:         assert_equal(a[np.newaxis, ...].shape, (1,))
  784:         assert_equal(a[..., np.newaxis].shape, (1,))
  785:         assert_equal(a[np.newaxis, ..., np.newaxis].shape, (1, 1))
  786:         assert_equal(a[..., np.newaxis, np.newaxis].shape, (1, 1))
  787:         assert_equal(a[np.newaxis, np.newaxis, ...].shape, (1, 1))
  788:         assert_equal(a[(np.newaxis,) * 10].shape, (1,) * 10)
  789: 
  790:     def test_invalid_newaxis(self):
  791:         a, b = self.d
  792: 
  793:         def subscript(x, i):
  794:             x[i]
  795: 
  796:         assert_raises(IndexError, subscript, a, (np.newaxis, 0))
  797:         assert_raises(IndexError, subscript, a, (np.newaxis,) * 70)
  798: 
  799:     def test_constructor(self):
  800:         x = np.ndarray(())
  801:         x[()] = 5
  802:         assert_equal(x[()], 5)
  803:         y = np.ndarray((), buffer=x)
  804:         y[()] = 6
  805:         assert_equal(x[()], 6)
  806: 
  807:         # strides and shape must be the same length
  808:         with pytest.raises(ValueError):
  809:             np.ndarray((2,), strides=())
  810:         with pytest.raises(ValueError):
  811:             np.ndarray((), strides=(2,))
  812: 
  813:     def test_output(self):
  814:         x = np.array(2)
  815:         assert_raises(ValueError, np.add, x, [1], x)
  816: 
  817:     def test_real_imag(self):
  818:         # contiguity checks are for gh-11245
  819:         x = np.array(1j)
  820:         xr = x.real
  821:         xi = x.imag
  822: 
  823:         assert_equal(xr, np.array(0))
  824:         assert_(type(xr) is np.ndarray)
  825:         assert_equal(xr.flags.contiguous, True)
  826:         assert_equal(xr.flags.f_contiguous, True)
  827: 
  828:         assert_equal(xi, np.array(1))
  829:         assert_(type(xi) is np.ndarray)
  830:         assert_equal(xi.flags.contiguous, True)
  831:         assert_equal(xi.flags.f_contiguous, True)
  832: 
  833: 
  834: class TestScalarIndexing:
  835:     def setup_method(self):
  836:         self.d = np.array([0, 1])[0]
  837: 
  838:     def test_ellipsis_subscript(self):
  839:         a = self.d
  840:         assert_equal(a[...], 0)
  841:         assert_equal(a[...].shape, ())
  842: 
  843:     def test_empty_subscript(self):
  844:         a = self.d
  845:         assert_equal(a[()], 0)
  846:         assert_equal(a[()].shape, ())
  847: 
  848:     def test_invalid_subscript(self):
  849:         a = self.d
  850:         assert_raises(IndexError, lambda x: x[0], a)
  851:         assert_raises(IndexError, lambda x: x[np.array([], int)], a)
  852: 
  853:     def test_invalid_subscript_assignment(self):
  854:         a = self.d
  855: 
  856:         def assign(x, i, v):
  857:             x[i] = v
  858: 
  859:         assert_raises(TypeError, assign, a, 0, 42)
  860: 
  861:     def test_newaxis(self):
  862:         a = self.d
  863:         assert_equal(a[np.newaxis].shape, (1,))
  864:         assert_equal(a[..., np.newaxis].shape, (1,))
  865:         assert_equal(a[np.newaxis, ...].shape, (1,))
  866:         assert_equal(a[..., np.newaxis].shape, (1,))
  867:         assert_equal(a[np.newaxis, ..., np.newaxis].shape, (1, 1))
  868:         assert_equal(a[..., np.newaxis, np.newaxis].shape, (1, 1))
  869:         assert_equal(a[np.newaxis, np.newaxis, ...].shape, (1, 1))
  870:         assert_equal(a[(np.newaxis,) * 10].shape, (1,) * 10)
  871: 
  872:     def test_invalid_newaxis(self):
  873:         a = self.d
  874: 
  875:         def subscript(x, i):
  876:             x[i]
  877: 
  878:         assert_raises(IndexError, subscript, a, (np.newaxis, 0))
  879:         assert_raises(IndexError, subscript, a, (np.newaxis,) * 70)
  880: 
  881:     def test_overlapping_assignment(self):
  882:         # With positive strides
  883:         a = np.arange(4)
  884:         a[:-1] = a[1:]
  885:         assert_equal(a, [1, 2, 3, 3])
  886: 
  887:         a = np.arange(4)
  888:         a[1:] = a[:-1]
  889:         assert_equal(a, [0, 0, 1, 2])
  890: 
  891:         # With positive and negative strides
  892:         a = np.arange(4)
  893:         a[:] = a[::-1]
  894:         assert_equal(a, [3, 2, 1, 0])
  895: 
  896:         a = np.arange(6).reshape(2, 3)
  897:         a[::-1, :] = a[:, ::-1]
  898:         assert_equal(a, [[5, 4, 3], [2, 1, 0]])
  899: 
  900:         a = np.arange(6).reshape(2, 3)
  901:         a[::-1, ::-1] = a[:, ::-1]
  902:         assert_equal(a, [[3, 4, 5], [0, 1, 2]])
  903: 
  904:         # With just one element overlapping
  905:         a = np.arange(5)
  906:         a[:3] = a[2:]
  907:         assert_equal(a, [2, 3, 4, 3, 4])
  908: 
  909:         a = np.arange(5)
  910:         a[2:] = a[:3]
  911:         assert_equal(a, [0, 1, 0, 1, 2])
  912: 
  913:         a = np.arange(5)
  914:         a[2::-1] = a[2:]
  915:         assert_equal(a, [4, 3, 2, 3, 4])
  916: 
  917:         a = np.arange(5)
  918:         a[2:] = a[2::-1]
  919:         assert_equal(a, [0, 1, 2, 1, 0])
  920: 
  921:         a = np.arange(5)
  922:         a[2::-1] = a[:1:-1]
  923:         assert_equal(a, [2, 3, 4, 3, 4])
  924: 
  925:         a = np.arange(5)
  926:         a[:1:-1] = a[2::-1]
  927:         assert_equal(a, [0, 1, 0, 1, 2])
  928: 
  929: 
  930: class TestCreation:
  931:     """
  932:     Test the np.array constructor
  933:     """
  934:     def test_from_attribute(self):
  935:         class x:
  936:             def __array__(self, dtype=None, copy=None):
  937:                 pass
  938: 
  939:         assert_raises(ValueError, np.array, x())
  940: 
  941:     def test_from_string(self):
  942:         types = np.typecodes['AllInteger'] + np.typecodes['Float']
  943:         nstr = ['123', '123']
  944:         result = np.array([123, 123], dtype=int)
  945:         for type in types:
  946:             msg = f'String conversion for {type}'
  947:             assert_equal(np.array(nstr, dtype=type), result, err_msg=msg)
  948: 
  949:     def test_void(self):
  950:         arr = np.array([], dtype='V')
  951:         assert arr.dtype == 'V8'  # current default
  952:         # Same length scalars (those that go to the same void) work:
  953:         arr = np.array([b"1234", b"1234"], dtype="V")
  954:         assert arr.dtype == "V4"
  955: 
  956:         # Promoting different lengths will fail (pre 1.20 this worked)
  957:         # by going via S5 and casting to V5.
  958:         with pytest.raises(TypeError):
  959:             np.array([b"1234", b"12345"], dtype="V")
  960:         with pytest.raises(TypeError):
  961:             np.array([b"12345", b"1234"], dtype="V")
  962: 
  963:         # Check the same for the casting path:
  964:         arr = np.array([b"1234", b"1234"], dtype="O").astype("V")
  965:         assert arr.dtype == "V4"
  966:         with pytest.raises(TypeError):
  967:             np.array([b"1234", b"12345"], dtype="O").astype("V")
  968: 
  969:     @pytest.mark.parametrize("idx",
  970:             [pytest.param(Ellipsis, id="arr"), pytest.param((), id="scalar")])
  971:     def test_structured_void_promotion(self, idx):
  972:         arr = np.array(
  973:             [np.array(1, dtype="i,i")[idx], np.array(2, dtype='i,i')[idx]],
  974:             dtype="V")
  975:         assert_array_equal(arr, np.array([(1, 1), (2, 2)], dtype="i,i"))
  976:         # The following fails to promote the two dtypes, resulting in an error
  977:         with pytest.raises(TypeError):
  978:             np.array(
  979:                 [np.array(1, dtype="i,i")[idx], np.array(2, dtype='i,i,i')[idx]],
  980:                 dtype="V")
  981: 
  982:     def test_too_big_error(self):
  983:         # 45341 is the smallest integer greater than sqrt(2**31 - 1).
  984:         # 3037000500 is the smallest integer greater than sqrt(2**63 - 1).
  985:         # We want to make sure that the square byte array with those dimensions
  986:         # is too big on 32 or 64 bit systems respectively.
  987:         if np.iinfo('intp').max == 2**31 - 1:
  988:             shape = (46341, 46341)
  989:         elif np.iinfo('intp').max == 2**63 - 1:
  990:             shape = (3037000500, 3037000500)
  991:         else:
  992:             return
  993:         assert_raises(ValueError, np.empty, shape, dtype=np.int8)
  994:         assert_raises(ValueError, np.zeros, shape, dtype=np.int8)
  995:         assert_raises(ValueError, np.ones, shape, dtype=np.int8)
  996: 
  997:     @pytest.mark.skipif(not IS_64BIT,
  998:                         reason="malloc may not fail on 32 bit systems")
  999:     def test_malloc_fails(self):
 1000:         # This test is guaranteed to fail due to a too large allocation
 1001:         with assert_raises(np._core._exceptions._ArrayMemoryError):
 1002:             np.empty(np.iinfo(np.intp).max, dtype=np.uint8)
 1003: 
 1004:     def test_zeros(self):
 1005:         types = np.typecodes['AllInteger'] + np.typecodes['AllFloat']
 1006:         for dt in types:
 1007:             d = np.zeros((13,), dtype=dt)
 1008:             assert_equal(np.count_nonzero(d), 0)
 1009:             # true for ieee floats
 1010:             assert_equal(d.sum(), 0)
 1011:             assert_(not d.any())
 1012: 
 1013:             d = np.zeros(2, dtype='(2,4)i4')
 1014:             assert_equal(np.count_nonzero(d), 0)
 1015:             assert_equal(d.sum(), 0)
 1016:             assert_(not d.any())
 1017: 
 1018:             d = np.zeros(2, dtype='4i4')
 1019:             assert_equal(np.count_nonzero(d), 0)
 1020:             assert_equal(d.sum(), 0)
 1021:             assert_(not d.any())
 1022: 
 1023:             d = np.zeros(2, dtype='(2,4)i4, (2,4)i4')
 1024:             assert_equal(np.count_nonzero(d), 0)
 1025: 
 1026:     @pytest.mark.slow
 1027:     def test_zeros_big(self):
 1028:         # test big array as they might be allocated different by the system
 1029:         types = np.typecodes['AllInteger'] + np.typecodes['AllFloat']
 1030:         for dt in types:
 1031:             d = np.zeros((30 * 1024**2,), dtype=dt)
 1032:             assert_(not d.any())
 1033:             # This test can fail on 32-bit systems due to insufficient
 1034:             # contiguous memory. Deallocating the previous array increases the
 1035:             # chance of success.
 1036:             del d
 1037: 
 1038:     def test_zeros_obj(self):
 1039:         # test initialization from PyLong(0)
 1040:         d = np.zeros((13,), dtype=object)
 1041:         assert_array_equal(d, [0] * 13)
 1042:         assert_equal(np.count_nonzero(d), 0)
 1043: 
 1044:     def test_zeros_obj_obj(self):
 1045:         d = np.zeros(10, dtype=[('k', object, 2)])
 1046:         assert_array_equal(d['k'], 0)
 1047: 
 1048:     def test_zeros_like_like_zeros(self):
 1049:         # test zeros_like returns the same as zeros
 1050:         for c in np.typecodes['All']:
 1051:             if c == 'V':
 1052:                 continue
 1053:             d = np.zeros((3, 3), dtype=c)
 1054:             assert_array_equal(np.zeros_like(d), d)
 1055:             assert_equal(np.zeros_like(d).dtype, d.dtype)
 1056:         # explicitly check some special cases
 1057:         d = np.zeros((3, 3), dtype='S5')
 1058:         assert_array_equal(np.zeros_like(d), d)
 1059:         assert_equal(np.zeros_like(d).dtype, d.dtype)
 1060:         d = np.zeros((3, 3), dtype='U5')
 1061:         assert_array_equal(np.zeros_like(d), d)
 1062:         assert_equal(np.zeros_like(d).dtype, d.dtype)
 1063: 
 1064:         d = np.zeros((3, 3), dtype='<i4')
 1065:         assert_array_equal(np.zeros_like(d), d)
 1066:         assert_equal(np.zeros_like(d).dtype, d.dtype)
 1067:         d = np.zeros((3, 3), dtype='>i4')
 1068:         assert_array_equal(np.zeros_like(d), d)
 1069:         assert_equal(np.zeros_like(d).dtype, d.dtype)
 1070: 
 1071:         d = np.zeros((3, 3), dtype='<M8[s]')
 1072:         assert_array_equal(np.zeros_like(d), d)
 1073:         assert_equal(np.zeros_like(d).dtype, d.dtype)
 1074:         d = np.zeros((3, 3), dtype='>M8[s]')
 1075:         assert_array_equal(np.zeros_like(d), d)
 1076:         assert_equal(np.zeros_like(d).dtype, d.dtype)
 1077: 
 1078:         d = np.zeros((3, 3), dtype='f4,f4')
 1079:         assert_array_equal(np.zeros_like(d), d)
 1080:         assert_equal(np.zeros_like(d).dtype, d.dtype)
 1081: 
 1082:     def test_empty_unicode(self):
 1083:         # don't throw decode errors on garbage memory
 1084:         for i in range(5, 100, 5):
 1085:             d = np.empty(i, dtype='U')
 1086:             str(d)
 1087: 
 1088:     def test_sequence_non_homogeneous(self):
 1089:         assert_equal(np.array([4, 2**80]).dtype, object)
 1090:         assert_equal(np.array([4, 2**80, 4]).dtype, object)
 1091:         assert_equal(np.array([2**80, 4]).dtype, object)
 1092:         assert_equal(np.array([2**80] * 3).dtype, object)
 1093:         assert_equal(np.array([[1, 1], [1j, 1j]]).dtype, complex)
 1094:         assert_equal(np.array([[1j, 1j], [1, 1]]).dtype, complex)
 1095:         assert_equal(np.array([[1, 1, 1], [1, 1j, 1.], [1, 1, 1]]).dtype, complex)
 1096: 
 1097:     def test_non_sequence_sequence(self):
 1098:         """Should not segfault.
 1099: 
 1100:         Class Fail breaks the sequence protocol for new style classes, i.e.,
 1101:         those derived from object. Class Map is a mapping type indicated by
 1102:         raising a ValueError. At some point we may raise a warning instead
 1103:         of an error in the Fail case.
 1104: 
 1105:         """
 1106:         class Fail:
 1107:             def __len__(self):
 1108:                 return 1
 1109: 
 1110:             def __getitem__(self, index):
 1111:                 raise ValueError
 1112: 
 1113:         class Map:
 1114:             def __len__(self):
 1115:                 return 1
 1116: 
 1117:             def __getitem__(self, index):
 1118:                 raise KeyError
 1119: 
 1120:         a = np.array([Map()])
 1121:         assert_(a.shape == (1,))
 1122:         assert_(a.dtype == np.dtype(object))
 1123:         assert_raises(ValueError, np.array, [Fail()])
 1124: 
 1125:     def test_no_len_object_type(self):
 1126:         # gh-5100, want object array from iterable object without len()
 1127:         class Point2:
 1128:             def __init__(self):
 1129:                 pass
 1130: 
 1131:             def __getitem__(self, ind):
 1132:                 if ind in [0, 1]:
 1133:                     return ind
 1134:                 else:
 1135:                     raise IndexError
 1136:         d = np.array([Point2(), Point2(), Point2()])
 1137:         assert_equal(d.dtype, np.dtype(object))
 1138: 
 1139:     def test_false_len_sequence(self):
 1140:         # gh-7264, segfault for this example
 1141:         class C:
 1142:             def __getitem__(self, i):
 1143:                 raise IndexError
 1144: 
 1145:             def __len__(self):
 1146:                 return 42
 1147: 
 1148:         a = np.array(C())  # segfault?
 1149:         assert_equal(len(a), 0)
 1150: 
 1151:     def test_false_len_iterable(self):
 1152:         # Special case where a bad __getitem__ makes us fall back on __iter__:
 1153:         class C:
 1154:             def __getitem__(self, x):
 1155:                 raise Exception
 1156: 
 1157:             def __iter__(self):
 1158:                 return iter(())
 1159: 
 1160:             def __len__(self):
 1161:                 return 2
 1162: 
 1163:         a = np.empty(2)
 1164:         with assert_raises(ValueError):
 1165:             a[:] = C()  # Segfault!
 1166: 
 1167:         np.array(C()) == list(C())
 1168: 
 1169:     def test_failed_len_sequence(self):
 1170:         # gh-7393
 1171:         class A:
 1172:             def __init__(self, data):
 1173:                 self._data = data
 1174: 
 1175:             def __getitem__(self, item):
 1176:                 return type(self)(self._data[item])
 1177: 
 1178:             def __len__(self):
 1179:                 return len(self._data)
 1180: 
 1181:         # len(d) should give 3, but len(d[0]) will fail
 1182:         d = A([1, 2, 3])
 1183:         assert_equal(len(np.array(d)), 3)
 1184: 
 1185:     def test_array_too_big(self):
 1186:         # Test that array creation succeeds for arrays addressable by intp
 1187:         # on the byte level and fails for too large arrays.
 1188:         buf = np.zeros(100)
 1189: 
 1190:         max_bytes = np.iinfo(np.intp).max
 1191:         for dtype in ["intp", "S20", "b"]:
 1192:             dtype = np.dtype(dtype)
 1193:             itemsize = dtype.itemsize
 1194: 
 1195:             np.ndarray(buffer=buf, strides=(0,),
 1196:                        shape=(max_bytes // itemsize,), dtype=dtype)
 1197:             assert_raises(ValueError, np.ndarray, buffer=buf, strides=(0,),
 1198:                           shape=(max_bytes // itemsize + 1,), dtype=dtype)
 1199: 
 1200:     def _ragged_creation(self, seq):
 1201:         # without dtype=object, the ragged object raises
 1202:         with pytest.raises(ValueError, match=".*detected shape was"):
 1203:             a = np.array(seq)
 1204: 
 1205:         return np.array(seq, dtype=object)
 1206: 
 1207:     def test_ragged_ndim_object(self):
 1208:         # Lists of mismatching depths are treated as object arrays
 1209:         a = self._ragged_creation([[1], 2, 3])
 1210:         assert_equal(a.shape, (3,))
 1211:         assert_equal(a.dtype, object)
 1212: 
 1213:         a = self._ragged_creation([1, [2], 3])
 1214:         assert_equal(a.shape, (3,))
 1215:         assert_equal(a.dtype, object)
 1216: 
 1217:         a = self._ragged_creation([1, 2, [3]])
 1218:         assert_equal(a.shape, (3,))
 1219:         assert_equal(a.dtype, object)
 1220: 
 1221:     def test_ragged_shape_object(self):
 1222:         # The ragged dimension of a list is turned into an object array
 1223:         a = self._ragged_creation([[1, 1], [2], [3]])
 1224:         assert_equal(a.shape, (3,))
 1225:         assert_equal(a.dtype, object)
 1226: 
 1227:         a = self._ragged_creation([[1], [2, 2], [3]])
 1228:         assert_equal(a.shape, (3,))
 1229:         assert_equal(a.dtype, object)
 1230: 
 1231:         a = self._ragged_creation([[1], [2], [3, 3]])
 1232:         assert a.shape == (3,)
 1233:         assert a.dtype == object
 1234: 
 1235:     def test_array_of_ragged_array(self):
 1236:         outer = np.array([None, None])
 1237:         outer[0] = outer[1] = np.array([1, 2, 3])
 1238:         assert np.array(outer).shape == (2,)
 1239:         assert np.array([outer]).shape == (1, 2)
 1240: 
 1241:         outer_ragged = np.array([None, None])
 1242:         outer_ragged[0] = np.array([1, 2, 3])
 1243:         outer_ragged[1] = np.array([1, 2, 3, 4])
 1244:         # should both of these emit deprecation warnings?
 1245:         assert np.array(outer_ragged).shape == (2,)
 1246:         assert np.array([outer_ragged]).shape == (1, 2,)
 1247: 
 1248:     def test_deep_nonragged_object(self):
 1249:         # None of these should raise, even though they are missing dtype=object
 1250:         a = np.array([[[Decimal(1)]]])
 1251:         a = np.array([1, Decimal(1)])
 1252:         a = np.array([[1], [Decimal(1)]])
 1253: 
 1254:     @pytest.mark.parametrize("dtype", [object, "O,O", "O,(3,)O", "(2,3)O"])
 1255:     @pytest.mark.parametrize("function", [
 1256:             np.ndarray, np.empty,
 1257:             lambda shape, dtype: np.empty_like(np.empty(shape, dtype=dtype))])
 1258:     def test_object_initialized_to_None(self, function, dtype):
 1259:         # NumPy has support for object fields to be NULL (meaning None)
 1260:         # but generally, we should always fill with the proper None, and
 1261:         # downstream may rely on that.  (For fully initialized arrays!)
 1262:         arr = function(3, dtype=dtype)
 1263:         # We expect a fill value of None, which is not NULL:
 1264:         expected = np.array(None).tobytes()
 1265:         expected = expected * (arr.nbytes // len(expected))
 1266:         assert arr.tobytes() == expected
 1267: 
 1268:     @pytest.mark.parametrize("func", [
 1269:         np.array, np.asarray, np.asanyarray, np.ascontiguousarray,
 1270:         np.asfortranarray])
 1271:     def test_creation_from_dtypemeta(self, func):
 1272:         dtype = np.dtype('i')
 1273:         arr1 = func([1, 2, 3], dtype=dtype)
 1274:         arr2 = func([1, 2, 3], dtype=type(dtype))
 1275:         assert_array_equal(arr1, arr2)
 1276:         assert arr2.dtype == dtype
 1277: 
 1278: 
 1279: class TestStructured:
 1280:     def test_subarray_field_access(self):
 1281:         a = np.zeros((3, 5), dtype=[('a', ('i4', (2, 2)))])
 1282:         a['a'] = np.arange(60).reshape(3, 5, 2, 2)
 1283: 
 1284:         # Since the subarray is always in C-order, a transpose
 1285:         # does not swap the subarray:
 1286:         assert_array_equal(a.T['a'], a['a'].transpose(1, 0, 2, 3))
 1287: 
 1288:         # In Fortran order, the subarray gets appended
 1289:         # like in all other cases, not prepended as a special case
 1290:         b = a.copy(order='F')
 1291:         assert_equal(a['a'].shape, b['a'].shape)
 1292:         assert_equal(a.T['a'].shape, a.T.copy()['a'].shape)
 1293: 
 1294:     def test_subarray_comparison(self):
 1295:         # Check that comparisons between record arrays with
 1296:         # multi-dimensional field types work properly
 1297:         a = np.rec.fromrecords(
 1298:             [([1, 2, 3], 'a', [[1, 2], [3, 4]]), ([3, 3, 3], 'b', [[0, 0], [0, 0]])],
 1299:             dtype=[('a', ('f4', 3)), ('b', object), ('c', ('i4', (2, 2)))])
 1300:         b = a.copy()
 1301:         assert_equal(a == b, [True, True])
 1302:         assert_equal(a != b, [False, False])
 1303:         b[1].b = 'c'
 1304:         assert_equal(a == b, [True, False])
 1305:         assert_equal(a != b, [False, True])
 1306:         for i in range(3):
 1307:             b[0].a = a[0].a
 1308:             b[0].a[i] = 5
 1309:             assert_equal(a == b, [False, False])
 1310:             assert_equal(a != b, [True, True])
 1311:         for i in range(2):
 1312:             for j in range(2):
 1313:                 b = a.copy()
 1314:                 b[0].c[i, j] = 10
 1315:                 assert_equal(a == b, [False, True])
 1316:                 assert_equal(a != b, [True, False])
 1317: 
 1318:         # Check that broadcasting with a subarray works, including cases that
 1319:         # require promotion to work:
 1320:         a = np.array([[(0,)], [(1,)]], dtype=[('a', 'f8')])
 1321:         b = np.array([(0,), (0,), (1,)], dtype=[('a', 'f8')])
 1322:         assert_equal(a == b, [[True, True, False], [False, False, True]])
 1323:         assert_equal(b == a, [[True, True, False], [False, False, True]])
 1324:         a = np.array([[(0,)], [(1,)]], dtype=[('a', 'f8', (1,))])
 1325:         b = np.array([(0,), (0,), (1,)], dtype=[('a', 'f8', (1,))])
 1326:         assert_equal(a == b, [[True, True, False], [False, False, True]])
 1327:         assert_equal(b == a, [[True, True, False], [False, False, True]])
 1328:         a = np.array([[([0, 0],)], [([1, 1],)]], dtype=[('a', 'f8', (2,))])
 1329:         b = np.array([([0, 0],), ([0, 1],), ([1, 1],)], dtype=[('a', 'f8', (2,))])
 1330:         assert_equal(a == b, [[True, False, False], [False, False, True]])
 1331:         assert_equal(b == a, [[True, False, False], [False, False, True]])
 1332: 
 1333:         # Check that broadcasting Fortran-style arrays with a subarray work
 1334:         a = np.array([[([0, 0],)], [([1, 1],)]], dtype=[('a', 'f8', (2,))], order='F')
 1335:         b = np.array([([0, 0],), ([0, 1],), ([1, 1],)], dtype=[('a', 'f8', (2,))])
 1336:         assert_equal(a == b, [[True, False, False], [False, False, True]])
 1337:         assert_equal(b == a, [[True, False, False], [False, False, True]])
 1338: 
 1339:         # Check that incompatible sub-array shapes don't result to broadcasting
 1340:         x = np.zeros((1,), dtype=[('a', ('f4', (1, 2))), ('b', 'i1')])
 1341:         y = np.zeros((1,), dtype=[('a', ('f4', (2,))), ('b', 'i1')])
 1342:         # The main importance is that it does not return True:
 1343:         with pytest.raises(TypeError):
 1344:             x == y
 1345: 
 1346:         x = np.zeros((1,), dtype=[('a', ('f4', (2, 1))), ('b', 'i1')])
 1347:         y = np.zeros((1,), dtype=[('a', ('f4', (2,))), ('b', 'i1')])
 1348:         # The main importance is that it does not return True:
 1349:         with pytest.raises(TypeError):
 1350:             x == y
 1351: 
 1352:     def test_empty_structured_array_comparison(self):
 1353:         # Check that comparison works on empty arrays with nontrivially
 1354:         # shaped fields
 1355:         a = np.zeros(0, [('a', '<f8', (1, 1))])
 1356:         assert_equal(a, a)
 1357:         a = np.zeros(0, [('a', '<f8', (1,))])
 1358:         assert_equal(a, a)
 1359:         a = np.zeros((0, 0), [('a', '<f8', (1, 1))])
 1360:         assert_equal(a, a)
 1361:         a = np.zeros((1, 0, 1), [('a', '<f8', (1, 1))])
 1362:         assert_equal(a, a)
 1363: 
 1364:     @pytest.mark.parametrize("op", [operator.eq, operator.ne])
 1365:     def test_structured_array_comparison_bad_broadcasts(self, op):
 1366:         a = np.zeros(3, dtype='i,i')
 1367:         b = np.array([], dtype="i,i")
 1368:         with pytest.raises(ValueError):
 1369:             op(a, b)
 1370: 
 1371:     def test_structured_comparisons_with_promotion(self):
 1372:         # Check that structured arrays can be compared so long as their
 1373:         # dtypes promote fine:
 1374:         a = np.array([(5, 42), (10, 1)], dtype=[('a', '>i8'), ('b', '<f8')])
 1375:         b = np.array([(5, 43), (10, 1)], dtype=[('a', '<i8'), ('b', '>f8')])
 1376:         assert_equal(a == b, [False, True])
 1377:         assert_equal(a != b, [True, False])
 1378: 
 1379:         a = np.array([(5, 42), (10, 1)], dtype=[('a', '>f8'), ('b', '<f8')])
 1380:         b = np.array([(5, 43), (10, 1)], dtype=[('a', '<i8'), ('b', '>i8')])
 1381:         assert_equal(a == b, [False, True])
 1382:         assert_equal(a != b, [True, False])
 1383: 
 1384:         # Including with embedded subarray dtype (although subarray comparison
 1385:         # itself may still be a bit weird and compare the raw data)
 1386:         a = np.array([(5, 42), (10, 1)], dtype=[('a', '10>f8'), ('b', '5<f8')])
 1387:         b = np.array([(5, 43), (10, 1)], dtype=[('a', '10<i8'), ('b', '5>i8')])
 1388:         assert_equal(a == b, [False, True])
 1389:         assert_equal(a != b, [True, False])
 1390: 
 1391:     @pytest.mark.parametrize("op", [
 1392:             operator.eq, lambda x, y: operator.eq(y, x),
 1393:             operator.ne, lambda x, y: operator.ne(y, x)])
 1394:     def test_void_comparison_failures(self, op):
 1395:         # In principle, one could decide to return an array of False for some
 1396:         # if comparisons are impossible.  But right now we return TypeError
 1397:         # when "void" dtype are involved.
 1398:         x = np.zeros(3, dtype=[('a', 'i1')])
 1399:         y = np.zeros(3)
 1400:         # Cannot compare non-structured to structured:
 1401:         with pytest.raises(TypeError):
 1402:             op(x, y)
 1403: 
 1404:         # Added title prevents promotion, but casts are OK:
 1405:         y = np.zeros(3, dtype=[(('title', 'a'), 'i1')])
 1406:         assert np.can_cast(y.dtype, x.dtype)
 1407:         with pytest.raises(TypeError):
 1408:             op(x, y)
 1409: 
 1410:         x = np.zeros(3, dtype="V7")
 1411:         y = np.zeros(3, dtype="V8")
 1412:         with pytest.raises(TypeError):
 1413:             op(x, y)
 1414: 
 1415:     def test_casting(self):
 1416:         # Check that casting a structured array to change its byte order
 1417:         # works
 1418:         a = np.array([(1,)], dtype=[('a', '<i4')])
 1419:         assert_(np.can_cast(a.dtype, [('a', '>i4')], casting='unsafe'))
 1420:         b = a.astype([('a', '>i4')])
 1421:         a_tmp = a.byteswap()
 1422:         a_tmp = a_tmp.view(a_tmp.dtype.newbyteorder())
 1423:         assert_equal(b, a_tmp)
 1424:         assert_equal(a['a'][0], b['a'][0])
 1425: 
 1426:         # Check that equality comparison works on structured arrays if
 1427:         # they are 'equiv'-castable
 1428:         a = np.array([(5, 42), (10, 1)], dtype=[('a', '>i4'), ('b', '<f8')])
 1429:         b = np.array([(5, 42), (10, 1)], dtype=[('a', '<i4'), ('b', '>f8')])
 1430:         assert_(np.can_cast(a.dtype, b.dtype, casting='equiv'))
 1431:         assert_equal(a == b, [True, True])
 1432: 
 1433:         # Check that 'equiv' casting can change byte order
 1434:         assert_(np.can_cast(a.dtype, b.dtype, casting='equiv'))
 1435:         c = a.astype(b.dtype, casting='equiv')
 1436:         assert_equal(a == c, [True, True])
 1437: 
 1438:         # Check that 'safe' casting can change byte order and up-cast
 1439:         # fields
 1440:         t = [('a', '<i8'), ('b', '>f8')]
 1441:         assert_(np.can_cast(a.dtype, t, casting='safe'))
 1442:         c = a.astype(t, casting='safe')
 1443:         assert_equal((c == np.array([(5, 42), (10, 1)], dtype=t)),
 1444:                      [True, True])
 1445: 
 1446:         # Check that 'same_kind' casting can change byte order and
 1447:         # change field widths within a "kind"
 1448:         t = [('a', '<i4'), ('b', '>f4')]
 1449:         assert_(np.can_cast(a.dtype, t, casting='same_kind'))
 1450:         c = a.astype(t, casting='same_kind')
 1451:         assert_equal((c == np.array([(5, 42), (10, 1)], dtype=t)),
 1452:                      [True, True])
 1453: 
 1454:         # Check that casting fails if the casting rule should fail on
 1455:         # any of the fields
 1456:         t = [('a', '>i8'), ('b', '<f4')]
 1457:         assert_(not np.can_cast(a.dtype, t, casting='safe'))
 1458:         assert_raises(TypeError, a.astype, t, casting='safe')
 1459:         t = [('a', '>i2'), ('b', '<f8')]
 1460:         assert_(not np.can_cast(a.dtype, t, casting='equiv'))
 1461:         assert_raises(TypeError, a.astype, t, casting='equiv')
 1462:         t = [('a', '>i8'), ('b', '<i2')]
 1463:         assert_(not np.can_cast(a.dtype, t, casting='same_kind'))
 1464:         assert_raises(TypeError, a.astype, t, casting='same_kind')
 1465:         assert_(not np.can_cast(a.dtype, b.dtype, casting='no'))
 1466:         assert_raises(TypeError, a.astype, b.dtype, casting='no')
 1467: 
 1468:         # Check that non-'unsafe' casting can't change the set of field names
 1469:         for casting in ['no', 'safe', 'equiv', 'same_kind']:
 1470:             t = [('a', '>i4')]
 1471:             assert_(not np.can_cast(a.dtype, t, casting=casting))
 1472:             t = [('a', '>i4'), ('b', '<f8'), ('c', 'i4')]
 1473:             assert_(not np.can_cast(a.dtype, t, casting=casting))
 1474: 
 1475:     def test_objview(self):
 1476:         # https://github.com/numpy/numpy/issues/3286
 1477:         a = np.array([], dtype=[('a', 'f'), ('b', 'f'), ('c', 'O')])
 1478:         a[['a', 'b']]  # TypeError?
 1479: 
 1480:         # https://github.com/numpy/numpy/issues/3253
 1481:         dat2 = np.zeros(3, [('A', 'i'), ('B', '|O')])
 1482:         dat2[['B', 'A']]  # TypeError?
 1483: 
 1484:     def test_setfield(self):
 1485:         # https://github.com/numpy/numpy/issues/3126
 1486:         struct_dt = np.dtype([('elem', 'i4', 5),])
 1487:         dt = np.dtype([('field', 'i4', 10), ('struct', struct_dt)])
 1488:         x = np.zeros(1, dt)
 1489:         x[0]['field'] = np.ones(10, dtype='i4')
 1490:         x[0]['struct'] = np.ones(1, dtype=struct_dt)
 1491:         assert_equal(x[0]['field'], np.ones(10, dtype='i4'))
 1492: 
 1493:     def test_setfield_object(self):
 1494:         # make sure object field assignment with ndarray value
 1495:         # on void scalar mimics setitem behavior
 1496:         b = np.zeros(1, dtype=[('x', 'O')])
 1497:         # next line should work identically to b['x'][0] = np.arange(3)
 1498:         b[0]['x'] = np.arange(3)
 1499:         assert_equal(b[0]['x'], np.arange(3))
 1500: 
 1501:         # check that broadcasting check still works
 1502:         c = np.zeros(1, dtype=[('x', 'O', 5)])
 1503: 
 1504:         def testassign():
 1505:             c[0]['x'] = np.arange(3)
 1506: 
 1507:         assert_raises(ValueError, testassign)
 1508: 
 1509:     def test_zero_width_string(self):
 1510:         # Test for PR #6430 / issues #473, #4955, #2585
 1511: 
 1512:         dt = np.dtype([('I', int), ('S', 'S0')])
 1513: 
 1514:         x = np.zeros(4, dtype=dt)
 1515: 
 1516:         assert_equal(x['S'], [b'', b'', b'', b''])
 1517:         assert_equal(x['S'].itemsize, 0)
 1518: 
 1519:         x['S'] = ['a', 'b', 'c', 'd']
 1520:         assert_equal(x['S'], [b'', b'', b'', b''])
 1521:         assert_equal(x['I'], [0, 0, 0, 0])
 1522: 
 1523:         # Variation on test case from #4955
 1524:         x['S'][x['I'] == 0] = 'hello'
 1525:         assert_equal(x['S'], [b'', b'', b'', b''])
 1526:         assert_equal(x['I'], [0, 0, 0, 0])
 1527: 
 1528:         # Variation on test case from #2585
 1529:         x['S'] = 'A'
 1530:         assert_equal(x['S'], [b'', b'', b'', b''])
 1531:         assert_equal(x['I'], [0, 0, 0, 0])
 1532: 
 1533:         # Allow zero-width dtypes in ndarray constructor
 1534:         y = np.ndarray(4, dtype=x['S'].dtype)
 1535:         assert_equal(y.itemsize, 0)
 1536:         assert_equal(x['S'], y)
 1537: 
 1538:         # More tests for indexing an array with zero-width fields
 1539:         assert_equal(np.zeros(4, dtype=[('a', 'S0,S0'),
 1540:                                         ('b', 'u1')])['a'].itemsize, 0)
 1541:         assert_equal(np.empty(3, dtype='S0,S0').itemsize, 0)
 1542:         assert_equal(np.zeros(4, dtype='S0,u1')['f0'].itemsize, 0)
 1543: 
 1544:         xx = x['S'].reshape((2, 2))
 1545:         assert_equal(xx.itemsize, 0)
 1546:         assert_equal(xx, [[b'', b''], [b'', b'']])
 1547:         # check for no uninitialized memory due to viewing S0 array
 1548:         assert_equal(xx[:].dtype, xx.dtype)
 1549:         assert_array_equal(eval(repr(xx), {"np": np, "array": np.array}), xx)
 1550: 
 1551:         b = io.BytesIO()
 1552:         np.save(b, xx)
 1553: 
 1554:         b.seek(0)
 1555:         yy = np.load(b)
 1556:         assert_equal(yy.itemsize, 0)
 1557:         assert_equal(xx, yy)
 1558: 
 1559:         with temppath(suffix='.npy') as tmp:
 1560:             np.save(tmp, xx)
 1561:             yy = np.load(tmp)
 1562:             assert_equal(yy.itemsize, 0)
 1563:             assert_equal(xx, yy)
 1564: 
 1565:     def test_base_attr(self):
 1566:         a = np.zeros(3, dtype='i4,f4')
 1567:         b = a[0]
 1568:         assert_(b.base is a)
 1569: 
 1570:     def test_assignment(self):
 1571:         def testassign(arr, v):
 1572:             c = arr.copy()
 1573:             c[0] = v  # assign using setitem
 1574:             c[1:] = v  # assign using "dtype_transfer" code paths
 1575:             return c
 1576: 
 1577:         dt = np.dtype([('foo', 'i8'), ('bar', 'i8')])
 1578:         arr = np.ones(2, dt)
 1579:         v1 = np.array([(2, 3)], dtype=[('foo', 'i8'), ('bar', 'i8')])
 1580:         v2 = np.array([(2, 3)], dtype=[('bar', 'i8'), ('foo', 'i8')])
 1581:         v3 = np.array([(2, 3)], dtype=[('bar', 'i8'), ('baz', 'i8')])
 1582:         v4 = np.array([(2,)],  dtype=[('bar', 'i8')])
 1583:         v5 = np.array([(2, 3)], dtype=[('foo', 'f8'), ('bar', 'f8')])
 1584:         w = arr.view({'names': ['bar'], 'formats': ['i8'], 'offsets': [8]})
 1585: 
 1586:         ans = np.array([(2, 3), (2, 3)], dtype=dt)
 1587:         assert_equal(testassign(arr, v1), ans)
 1588:         assert_equal(testassign(arr, v2), ans)
 1589:         assert_equal(testassign(arr, v3), ans)
 1590:         assert_raises(TypeError, lambda: testassign(arr, v4))
 1591:         assert_equal(testassign(arr, v5), ans)
 1592:         w[:] = 4
 1593:         assert_equal(arr, np.array([(1, 4), (1, 4)], dtype=dt))
 1594: 
 1595:         # test field-reordering, assignment by position, and self-assignment
 1596:         a = np.array([(1, 2, 3)],
 1597:                      dtype=[('foo', 'i8'), ('bar', 'i8'), ('baz', 'f4')])
 1598:         a[['foo', 'bar']] = a[['bar', 'foo']]
 1599:         assert_equal(a[0].item(), (2, 1, 3))
 1600: 
 1601:         # test that this works even for 'simple_unaligned' structs
 1602:         # (ie, that PyArray_EquivTypes cares about field order too)
 1603:         a = np.array([(1, 2)], dtype=[('a', 'i4'), ('b', 'i4')])
 1604:         a[['a', 'b']] = a[['b', 'a']]
 1605:         assert_equal(a[0].item(), (2, 1))
 1606: 
 1607:     def test_structuredscalar_indexing(self):
 1608:         # test gh-7262
 1609:         x = np.empty(shape=1, dtype="(2,)3S,(2,)3U")
 1610:         assert_equal(x[["f0", "f1"]][0], x[0][["f0", "f1"]])
 1611:         assert_equal(x[0], x[0][()])
 1612: 
 1613:     def test_multiindex_titles(self):
 1614:         a = np.zeros(4, dtype=[(('a', 'b'), 'i'), ('c', 'i'), ('d', 'i')])
 1615:         assert_raises(KeyError, lambda: a[['a', 'c']])
 1616:         assert_raises(KeyError, lambda: a[['a', 'a']])
 1617:         assert_raises(ValueError, lambda: a[['b', 'b']])  # field exists, but repeated
 1618:         a[['b', 'c']]  # no exception
 1619: 
 1620:     def test_structured_cast_promotion_fieldorder(self):
 1621:         # gh-15494
 1622:         # dtypes with different field names are not promotable
 1623:         A = ("a", "<i8")
 1624:         B = ("b", ">i8")
 1625:         ab = np.array([(1, 2)], dtype=[A, B])
 1626:         ba = np.array([(1, 2)], dtype=[B, A])
 1627:         assert_raises(TypeError, np.concatenate, ab, ba)
 1628:         assert_raises(TypeError, np.result_type, ab.dtype, ba.dtype)
 1629:         assert_raises(TypeError, np.promote_types, ab.dtype, ba.dtype)
 1630: 
 1631:         # dtypes with same field names/order but different memory offsets
 1632:         # and byte-order are promotable to packed nbo.
 1633:         assert_equal(np.promote_types(ab.dtype, ba[['a', 'b']].dtype),
 1634:                      repack_fields(ab.dtype.newbyteorder('N')))
 1635: 
 1636:         # gh-13667
 1637:         # dtypes with different fieldnames but castable field types are castable
 1638:         assert_equal(np.can_cast(ab.dtype, ba.dtype), True)
 1639:         assert_equal(ab.astype(ba.dtype).dtype, ba.dtype)
 1640:         assert_equal(np.can_cast('f8,i8', [('f0', 'f8'), ('f1', 'i8')]), True)
 1641:         assert_equal(np.can_cast('f8,i8', [('f1', 'f8'), ('f0', 'i8')]), True)
 1642:         assert_equal(np.can_cast('f8,i8', [('f1', 'i8'), ('f0', 'f8')]), False)
 1643:         assert_equal(np.can_cast('f8,i8', [('f1', 'i8'), ('f0', 'f8')],
 1644:                                  casting='unsafe'), True)
 1645: 
 1646:         ab[:] = ba  # make sure assignment still works
 1647: 
 1648:         # tests of type-promotion of corresponding fields
 1649:         dt1 = np.dtype([("", "i4")])
 1650:         dt2 = np.dtype([("", "i8")])
 1651:         assert_equal(np.promote_types(dt1, dt2), np.dtype([('f0', 'i8')]))
 1652:         assert_equal(np.promote_types(dt2, dt1), np.dtype([('f0', 'i8')]))
 1653:         assert_raises(TypeError, np.promote_types, dt1, np.dtype([("", "V3")]))
 1654:         assert_equal(np.promote_types('i4,f8', 'i8,f4'),
 1655:                      np.dtype([('f0', 'i8'), ('f1', 'f8')]))
 1656:         # test nested case
 1657:         dt1nest = np.dtype([("", dt1)])
 1658:         dt2nest = np.dtype([("", dt2)])
 1659:         assert_equal(np.promote_types(dt1nest, dt2nest),
 1660:                      np.dtype([('f0', np.dtype([('f0', 'i8')]))]))
 1661: 
 1662:         # note that offsets are lost when promoting:
 1663:         dt = np.dtype({'names': ['x'], 'formats': ['i4'], 'offsets': [8]})
 1664:         a = np.ones(3, dtype=dt)
 1665:         assert_equal(np.concatenate([a, a]).dtype, np.dtype([('x', 'i4')]))
 1666: 
 1667:     @pytest.mark.parametrize("dtype_dict", [
 1668:             {"names": ["a", "b"], "formats": ["i4", "f"], "itemsize": 100},
 1669:             {"names": ["a", "b"], "formats": ["i4", "f"],
 1670:                  "offsets": [0, 12]}])
 1671:     @pytest.mark.parametrize("align", [True, False])
 1672:     def test_structured_promotion_packs(self, dtype_dict, align):
 1673:         # Structured dtypes are packed when promoted (we consider the packed
 1674:         # form to be "canonical"), so tere is no extra padding.
 1675:         dtype = np.dtype(dtype_dict, align=align)
 1676:         # Remove non "canonical" dtype options:
 1677:         dtype_dict.pop("itemsize", None)
 1678:         dtype_dict.pop("offsets", None)
 1679:         expected = np.dtype(dtype_dict, align=align)
 1680: 
 1681:         res = np.promote_types(dtype, dtype)
 1682:         assert res.itemsize == expected.itemsize
 1683:         assert res.fields == expected.fields
 1684: 
 1685:         # But the "expected" one, should just be returned unchanged:
 1686:         res = np.promote_types(expected, expected)
 1687:         assert res is expected
 1688: 
 1689:     def test_structured_asarray_is_view(self):
 1690:         # A scalar viewing an array preserves its view even when creating a
 1691:         # new array. This test documents behaviour, it may not be the best
 1692:         # desired behaviour.
 1693:         arr = np.array([1], dtype="i,i")
 1694:         scalar = arr[0]
 1695:         assert not scalar.flags.owndata  # view into the array
 1696:         assert np.asarray(scalar).base is scalar
 1697:         # But never when a dtype is passed in:
 1698:         assert np.asarray(scalar, dtype=scalar.dtype).base is None
 1699:         # A scalar which owns its data does not have this property.
 1700:         # It is not easy to create one, one method is to use pickle:
 1701:         scalar = pickle.loads(pickle.dumps(scalar))
 1702:         assert scalar.flags.owndata
 1703:         assert np.asarray(scalar).base is None
 1704: 
 1705: class TestBool:
 1706:     def test_test_interning(self):
 1707:         a0 = np.bool(0)
 1708:         b0 = np.bool(False)
 1709:         assert_(a0 is b0)
 1710:         a1 = np.bool(1)
 1711:         b1 = np.bool(True)
 1712:         assert_(a1 is b1)
 1713:         assert_(np.array([True])[0] is a1)
 1714:         assert_(np.array(True)[()] is a1)
 1715: 
 1716:     def test_sum(self):
 1717:         d = np.ones(101, dtype=bool)
 1718:         assert_equal(d.sum(), d.size)
 1719:         assert_equal(d[::2].sum(), d[::2].size)
 1720:         assert_equal(d[::-2].sum(), d[::-2].size)
 1721: 
 1722:         d = np.frombuffer(b'\xff\xff' * 100, dtype=bool)
 1723:         assert_equal(d.sum(), d.size)
 1724:         assert_equal(d[::2].sum(), d[::2].size)
 1725:         assert_equal(d[::-2].sum(), d[::-2].size)
 1726: 
 1727:     def check_count_nonzero(self, power, length):
 1728:         powers = [2 ** i for i in range(length)]
 1729:         for i in range(2**power):
 1730:             l = [(i & x) != 0 for x in powers]
 1731:             a = np.array(l, dtype=bool)
 1732:             c = builtins.sum(l)
 1733:             assert_equal(np.count_nonzero(a), c)
 1734:             av = a.view(np.uint8)
 1735:             av *= 3
 1736:             assert_equal(np.count_nonzero(a), c)
 1737:             av *= 4
 1738:             assert_equal(np.count_nonzero(a), c)
 1739:             av[av != 0] = 0xFF
 1740:             assert_equal(np.count_nonzero(a), c)
 1741: 
 1742:     def test_count_nonzero(self):
 1743:         # check all 12 bit combinations in a length 17 array
 1744:         # covers most cases of the 16 byte unrolled code
 1745:         self.check_count_nonzero(12, 17)
 1746: 
 1747:     @pytest.mark.slow
 1748:     def test_count_nonzero_all(self):
 1749:         # check all combinations in a length 17 array
 1750:         # covers all cases of the 16 byte unrolled code
 1751:         self.check_count_nonzero(17, 17)
 1752: 
 1753:     def test_count_nonzero_unaligned(self):
 1754:         # prevent mistakes as e.g. gh-4060
 1755:         for o in range(7):
 1756:             a = np.zeros((18,), dtype=bool)[o + 1:]
 1757:             a[:o] = True
 1758:             assert_equal(np.count_nonzero(a), builtins.sum(a.tolist()))
 1759:             a = np.ones((18,), dtype=bool)[o + 1:]
 1760:             a[:o] = False
 1761:             assert_equal(np.count_nonzero(a), builtins.sum(a.tolist()))
 1762: 
 1763:     def _test_cast_from_flexible(self, dtype):
 1764:         # empty string -> false
 1765:         for n in range(3):
 1766:             v = np.array(b'', (dtype, n))
 1767:             assert_equal(bool(v), False)
 1768:             assert_equal(bool(v[()]), False)
 1769:             assert_equal(v.astype(bool), False)
 1770:             assert_(isinstance(v.astype(bool), np.ndarray))
 1771:             assert_(v[()].astype(bool) is np.False_)
 1772: 
 1773:         # anything else -> true
 1774:         for n in range(1, 4):
 1775:             for val in [b'a', b'0', b' ']:
 1776:                 v = np.array(val, (dtype, n))
 1777:                 assert_equal(bool(v), True)
 1778:                 assert_equal(bool(v[()]), True)
 1779:                 assert_equal(v.astype(bool), True)
 1780:                 assert_(isinstance(v.astype(bool), np.ndarray))
 1781:                 assert_(v[()].astype(bool) is np.True_)
 1782: 
 1783:     def test_cast_from_void(self):
 1784:         self._test_cast_from_flexible(np.void)
 1785: 
 1786:     @pytest.mark.xfail(reason="See gh-9847")
 1787:     def test_cast_from_unicode(self):
 1788:         self._test_cast_from_flexible(np.str_)
 1789: 
 1790:     @pytest.mark.xfail(reason="See gh-9847")
 1791:     def test_cast_from_bytes(self):
 1792:         self._test_cast_from_flexible(np.bytes_)
 1793: 
 1794: 
 1795: class TestZeroSizeFlexible:
 1796:     @staticmethod
 1797:     def _zeros(shape, dtype=str):
 1798:         dtype = np.dtype(dtype)
 1799:         if dtype == np.void:
 1800:             return np.zeros(shape, dtype=(dtype, 0))
 1801: 
 1802:         # not constructable directly
 1803:         dtype = np.dtype([('x', dtype, 0)])
 1804:         return np.zeros(shape, dtype=dtype)['x']
 1805: 
 1806:     def test_create(self):
 1807:         zs = self._zeros(10, bytes)
 1808:         assert_equal(zs.itemsize, 0)
 1809:         zs = self._zeros(10, np.void)
 1810:         assert_equal(zs.itemsize, 0)
 1811:         zs = self._zeros(10, str)
 1812:         assert_equal(zs.itemsize, 0)
 1813: 
 1814:     def _test_sort_partition(self, name, kinds, **kwargs):
 1815:         # Previously, these would all hang
 1816:         for dt in [bytes, np.void, str]:
 1817:             zs = self._zeros(10, dt)
 1818:             sort_method = getattr(zs, name)
 1819:             sort_func = getattr(np, name)
 1820:             for kind in kinds:
 1821:                 sort_method(kind=kind, **kwargs)
 1822:                 sort_func(zs, kind=kind, **kwargs)
 1823: 
 1824:     def test_sort(self):
 1825:         self._test_sort_partition('sort', kinds='qhs')
 1826: 
 1827:     def test_argsort(self):
 1828:         self._test_sort_partition('argsort', kinds='qhs')
 1829: 
 1830:     def test_partition(self):
 1831:         self._test_sort_partition('partition', kinds=['introselect'], kth=2)
 1832: 
 1833:     def test_argpartition(self):
 1834:         self._test_sort_partition('argpartition', kinds=['introselect'], kth=2)
 1835: 
 1836:     def test_resize(self):
 1837:         # previously an error
 1838:         for dt in [bytes, np.void, str]:
 1839:             zs = self._zeros(10, dt)
 1840:             zs.resize(25)
 1841:             zs.resize((10, 10))
 1842: 
 1843:     def test_view(self):
 1844:         for dt in [bytes, np.void, str]:
 1845:             zs = self._zeros(10, dt)
 1846: 
 1847:             # viewing as itself should be allowed
 1848:             assert_equal(zs.view(dt).dtype, np.dtype(dt))
 1849: 
 1850:             # viewing as any non-empty type gives an empty result
 1851:             assert_equal(zs.view((dt, 1)).shape, (0,))
 1852: 
 1853:     def test_dumps(self):
 1854:         zs = self._zeros(10, int)
 1855:         assert_equal(zs, pickle.loads(zs.dumps()))
 1856: 
 1857:     def test_pickle(self):
 1858:         for proto in range(2, pickle.HIGHEST_PROTOCOL + 1):
 1859:             for dt in [bytes, np.void, str]:
 1860:                 zs = self._zeros(10, dt)
 1861:                 p = pickle.dumps(zs, protocol=proto)
 1862:                 zs2 = pickle.loads(p)
 1863: 
 1864:                 assert_equal(zs.dtype, zs2.dtype)
 1865: 
 1866:     def test_pickle_empty(self):
 1867:         """Checking if an empty array pickled and un-pickled will not cause a
 1868:         segmentation fault"""
 1869:         arr = np.array([]).reshape(999999, 0)
 1870:         pk_dmp = pickle.dumps(arr)
 1871:         pk_load = pickle.loads(pk_dmp)
 1872: 
 1873:         assert pk_load.size == 0
 1874: 
 1875:     @pytest.mark.skipif(pickle.HIGHEST_PROTOCOL < 5,
 1876:                         reason="requires pickle protocol 5")
 1877:     def test_pickle_with_buffercallback(self):
 1878:         array = np.arange(10)
 1879:         buffers = []
 1880:         bytes_string = pickle.dumps(array, buffer_callback=buffers.append,
 1881:                                     protocol=5)
 1882:         array_from_buffer = pickle.loads(bytes_string, buffers=buffers)
 1883:         # when using pickle protocol 5 with buffer callbacks,
 1884:         # array_from_buffer is reconstructed from a buffer holding a view
 1885:         # to the initial array's data, so modifying an element in array
 1886:         # should modify it in array_from_buffer too.
 1887:         array[0] = -1
 1888:         assert array_from_buffer[0] == -1, array_from_buffer[0]
 1889: 
 1890: 
 1891: class TestMethods:
 1892: 
 1893:     sort_kinds = ['quicksort', 'heapsort', 'stable']
 1894: 
 1895:     def test_all_where(self):
 1896:         a = np.array([[True, False, True],
 1897:                       [False, False, False],
 1898:                       [True, True, True]])
 1899:         wh_full = np.array([[True, False, True],
 1900:                             [False, False, False],
 1901:                             [True, False, True]])
 1902:         wh_lower = np.array([[False],
 1903:                              [False],
 1904:                              [True]])
 1905:         for _ax in [0, None]:
 1906:             assert_equal(a.all(axis=_ax, where=wh_lower),
 1907:                         np.all(a[wh_lower[:, 0], :], axis=_ax))
 1908:             assert_equal(np.all(a, axis=_ax, where=wh_lower),
 1909:                          a[wh_lower[:, 0], :].all(axis=_ax))
 1910: 
 1911:         assert_equal(a.all(where=wh_full), True)
 1912:         assert_equal(np.all(a, where=wh_full), True)
 1913:         assert_equal(a.all(where=False), True)
 1914:         assert_equal(np.all(a, where=False), True)
 1915: 
 1916:     def test_any_where(self):
 1917:         a = np.array([[True, False, True],
 1918:                       [False, False, False],
 1919:                       [True, True, True]])
 1920:         wh_full = np.array([[False, True, False],
 1921:                             [True, True, True],
 1922:                             [False, False, False]])
 1923:         wh_middle = np.array([[False],
 1924:                               [True],
 1925:                               [False]])
 1926:         for _ax in [0, None]:
 1927:             assert_equal(a.any(axis=_ax, where=wh_middle),
 1928:                          np.any(a[wh_middle[:, 0], :], axis=_ax))
 1929:             assert_equal(np.any(a, axis=_ax, where=wh_middle),
 1930:                          a[wh_middle[:, 0], :].any(axis=_ax))
 1931:         assert_equal(a.any(where=wh_full), False)
 1932:         assert_equal(np.any(a, where=wh_full), False)
 1933:         assert_equal(a.any(where=False), False)
 1934:         assert_equal(np.any(a, where=False), False)
 1935: 
 1936:     @pytest.mark.parametrize("dtype",
 1937:             ["i8", "U10", "object", "datetime64[ms]"])
 1938:     def test_any_and_all_result_dtype(self, dtype):
 1939:         arr = np.ones(3, dtype=dtype)
 1940:         assert arr.any().dtype == np.bool
 1941:         assert arr.all().dtype == np.bool
 1942: 
 1943:     def test_any_and_all_object_dtype(self):
 1944:         # (seberg) Not sure we should even allow dtype here, but it is.
 1945:         arr = np.ones(3, dtype=object)
 1946:         # keepdims to prevent getting a scalar.
 1947:         assert arr.any(dtype=object, keepdims=True).dtype == object
 1948:         assert arr.all(dtype=object, keepdims=True).dtype == object
 1949: 
 1950:     def test_compress(self):
 1951:         tgt = [[5, 6, 7, 8, 9]]
 1952:         arr = np.arange(10).reshape(2, 5)
 1953:         out = arr.compress([0, 1], axis=0)
 1954:         assert_equal(out, tgt)
 1955: 
 1956:         tgt = [[1, 3], [6, 8]]
 1957:         out = arr.compress([0, 1, 0, 1, 0], axis=1)
 1958:         assert_equal(out, tgt)
 1959: 
 1960:         tgt = [[1], [6]]
 1961:         arr = np.arange(10).reshape(2, 5)
 1962:         out = arr.compress([0, 1], axis=1)
 1963:         assert_equal(out, tgt)
 1964: 
 1965:         arr = np.arange(10).reshape(2, 5)
 1966:         out = arr.compress([0, 1])
 1967:         assert_equal(out, 1)
 1968: 
 1969:     def test_choose(self):
 1970:         x = 2 * np.ones((3,), dtype=int)
 1971:         y = 3 * np.ones((3,), dtype=int)
 1972:         x2 = 2 * np.ones((2, 3), dtype=int)
 1973:         y2 = 3 * np.ones((2, 3), dtype=int)
 1974:         ind = np.array([0, 0, 1])
 1975: 
 1976:         A = ind.choose((x, y))
 1977:         assert_equal(A, [2, 2, 3])
 1978: 
 1979:         A = ind.choose((x2, y2))
 1980:         assert_equal(A, [[2, 2, 3], [2, 2, 3]])
 1981: 
 1982:         A = ind.choose((x, y2))
 1983:         assert_equal(A, [[2, 2, 3], [2, 2, 3]])
 1984: 
 1985:         oned = np.ones(1)
 1986:         # gh-12031, caused SEGFAULT
 1987:         assert_raises(TypeError, oned.choose, np.void(0), [oned])
 1988: 
 1989:         out = np.array(0)
 1990:         ret = np.choose(np.array(1), [10, 20, 30], out=out)
 1991:         assert out is ret
 1992:         assert_equal(out[()], 20)
 1993: 
 1994:         # gh-6272 check overlap on out
 1995:         x = np.arange(5)
 1996:         y = np.choose([0, 0, 0], [x[:3], x[:3], x[:3]], out=x[1:4], mode='wrap')
 1997:         assert_equal(y, np.array([0, 1, 2]))
 1998: 
 1999:         # gh_28206 check fail when out not writeable
 2000:         x = np.arange(3)
 2001:         out = np.zeros(3)
 2002:         out.setflags(write=False)
 2003:         assert_raises(ValueError, np.choose, [0, 1, 2], [x, x, x], out=out)
 2004: 
 2005:     def test_prod(self):
 2006:         ba = [1, 2, 10, 11, 6, 5, 4]
 2007:         ba2 = [[1, 2, 3, 4], [5, 6, 7, 9], [10, 3, 4, 5]]
 2008: 
 2009:         for ctype in [np.int16, np.uint16, np.int32, np.uint32,
 2010:                       np.float32, np.float64, np.complex64, np.complex128]:
 2011:             a = np.array(ba, ctype)
 2012:             a2 = np.array(ba2, ctype)
 2013:             if ctype in ['1', 'b']:
 2014:                 assert_raises(ArithmeticError, a.prod)
 2015:                 assert_raises(ArithmeticError, a2.prod, axis=1)
 2016:             else:
 2017:                 assert_equal(a.prod(axis=0), 26400)
 2018:                 assert_array_equal(a2.prod(axis=0),
 2019:                                    np.array([50, 36, 84, 180], ctype))
 2020:                 assert_array_equal(a2.prod(axis=-1),
 2021:                                    np.array([24, 1890, 600], ctype))
 2022: 
 2023:     @pytest.mark.parametrize('dtype', [None, object])
 2024:     def test_repeat(self, dtype):
 2025:         m = np.array([1, 2, 3, 4, 5, 6], dtype=dtype)
 2026:         m_rect = m.reshape((2, 3))
 2027: 
 2028:         A = m.repeat([1, 3, 2, 1, 1, 2])
 2029:         assert_equal(A, [1, 2, 2, 2, 3,
 2030:                          3, 4, 5, 6, 6])
 2031: 
 2032:         A = m.repeat(2)
 2033:         assert_equal(A, [1, 1, 2, 2, 3, 3,
 2034:                          4, 4, 5, 5, 6, 6])
 2035: 
 2036:         A = m_rect.repeat([2, 1], axis=0)
 2037:         assert_equal(A, [[1, 2, 3],
 2038:                          [1, 2, 3],
 2039:                          [4, 5, 6]])
 2040: 
 2041:         A = m_rect.repeat([1, 3, 2], axis=1)
 2042:         assert_equal(A, [[1, 2, 2, 2, 3, 3],
 2043:                          [4, 5, 5, 5, 6, 6]])
 2044: 
 2045:         A = m_rect.repeat(2, axis=0)
 2046:         assert_equal(A, [[1, 2, 3],
 2047:                          [1, 2, 3],
 2048:                          [4, 5, 6],
 2049:                          [4, 5, 6]])
 2050: 
 2051:         A = m_rect.repeat(2, axis=1)
 2052:         assert_equal(A, [[1, 1, 2, 2, 3, 3],
 2053:                          [4, 4, 5, 5, 6, 6]])
 2054: 
 2055:     def test_reshape(self):
 2056:         arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])
 2057: 
 2058:         tgt = [[1, 2, 3, 4, 5, 6], [7, 8, 9, 10, 11, 12]]
 2059:         assert_equal(arr.reshape(2, 6), tgt)
 2060: 
 2061:         tgt = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]
 2062:         assert_equal(arr.reshape(3, 4), tgt)
 2063: 
 2064:         tgt = [[1, 10, 8, 6], [4, 2, 11, 9], [7, 5, 3, 12]]
 2065:         assert_equal(arr.reshape((3, 4), order='F'), tgt)
 2066: 
 2067:         tgt = [[1, 4, 7, 10], [2, 5, 8, 11], [3, 6, 9, 12]]
 2068:         assert_equal(arr.T.reshape((3, 4), order='C'), tgt)
 2069: 
 2070:     def test_round(self):
 2071:         def check_round(arr, expected, *round_args):
 2072:             assert_equal(arr.round(*round_args), expected)
 2073:             # With output array
 2074:             out = np.zeros_like(arr)
 2075:             res = arr.round(*round_args, out=out)
 2076:             assert_equal(out, expected)
 2077:             assert out is res
 2078: 
 2079:         check_round(np.array([1.2, 1.5]), [1, 2])
 2080:         check_round(np.array(1.5), 2)
 2081:         check_round(np.array([12.2, 15.5]), [10, 20], -1)
 2082:         check_round(np.array([12.15, 15.51]), [12.2, 15.5], 1)
 2083:         # Complex rounding
 2084:         check_round(np.array([4.5 + 1.5j]), [4 + 2j])
 2085:         check_round(np.array([12.5 + 15.5j]), [10 + 20j], -1)
 2086: 
 2087:     def test_squeeze(self):
 2088:         a = np.array([[[1], [2], [3]]])
 2089:         assert_equal(a.squeeze(), [1, 2, 3])
 2090:         assert_equal(a.squeeze(axis=(0,)), [[1], [2], [3]])
 2091:         assert_raises(ValueError, a.squeeze, axis=(1,))
 2092:         assert_equal(a.squeeze(axis=(2,)), [[1, 2, 3]])
 2093: 
 2094:     def test_transpose(self):
 2095:         a = np.array([[1, 2], [3, 4]])
 2096:         assert_equal(a.transpose(), [[1, 3], [2, 4]])
 2097:         assert_raises(ValueError, lambda: a.transpose(0))
 2098:         assert_raises(ValueError, lambda: a.transpose(0, 0))
 2099:         assert_raises(ValueError, lambda: a.transpose(0, 1, 2))
 2100: 
 2101:     def test_sort(self):
 2102:         # test ordering for floats and complex containing nans. It is only
 2103:         # necessary to check the less-than comparison, so sorts that
 2104:         # only follow the insertion sort path are sufficient. We only
 2105:         # test doubles and complex doubles as the logic is the same.
 2106: 
 2107:         # check doubles
 2108:         msg = "Test real sort order with nans"
 2109:         a = np.array([np.nan, 1, 0])
 2110:         b = np.sort(a)
 2111:         assert_equal(b, a[::-1], msg)
 2112:         # check complex
 2113:         msg = "Test complex sort order with nans"
 2114:         a = np.zeros(9, dtype=np.complex128)
 2115:         a.real += [np.nan, np.nan, np.nan, 1, 0, 1, 1, 0, 0]
 2116:         a.imag += [np.nan, 1, 0, np.nan, np.nan, 1, 0, 1, 0]
 2117:         b = np.sort(a)
 2118:         assert_equal(b, a[::-1], msg)
 2119: 
 2120:         with assert_raises_regex(
 2121:             ValueError,
 2122:             "kind` and `stable` parameters can't be provided at the same time"
 2123:         ):
 2124:             np.sort(a, kind="stable", stable=True)
 2125: 
 2126:     # all c scalar sorts use the same code with different types
 2127:     # so it suffices to run a quick check with one type. The number
 2128:     # of sorted items must be greater than ~50 to check the actual
 2129:     # algorithm because quick and merge sort fall over to insertion
 2130:     # sort for small arrays.
 2131: 
 2132:     @pytest.mark.parametrize('dtype', [np.uint8, np.uint16, np.uint32, np.uint64,
 2133:                                        np.float16, np.float32, np.float64,
 2134:                                        np.longdouble])
 2135:     def test_sort_unsigned(self, dtype):
 2136:         a = np.arange(101, dtype=dtype)
 2137:         b = a[::-1].copy()
 2138:         for kind in self.sort_kinds:
 2139:             msg = f"scalar sort, kind={kind}"
 2140:             c = a.copy()
 2141:             c.sort(kind=kind)
 2142:             assert_equal(c, a, msg)
 2143:             c = b.copy()
 2144:             c.sort(kind=kind)
 2145:             assert_equal(c, a, msg)
 2146: 
 2147:     @pytest.mark.parametrize('dtype',
 2148:                              [np.int8, np.int16, np.int32, np.int64, np.float16,
 2149:                               np.float32, np.float64, np.longdouble])
 2150:     def test_sort_signed(self, dtype):
 2151:         a = np.arange(-50, 51, dtype=dtype)
 2152:         b = a[::-1].copy()
 2153:         for kind in self.sort_kinds:
 2154:             msg = f"scalar sort, kind={kind}"
 2155:             c = a.copy()
 2156:             c.sort(kind=kind)
 2157:             assert_equal(c, a, msg)
 2158:             c = b.copy()
 2159:             c.sort(kind=kind)
 2160:             assert_equal(c, a, msg)
 2161: 
 2162:     @pytest.mark.parametrize('dtype', [np.float32, np.float64, np.longdouble])
 2163:     @pytest.mark.parametrize('part', ['real', 'imag'])
 2164:     def test_sort_complex(self, part, dtype):
 2165:         # test complex sorts. These use the same code as the scalars
 2166:         # but the compare function differs.
 2167:         cdtype = {
 2168:             np.single: np.csingle,
 2169:             np.double: np.cdouble,
 2170:             np.longdouble: np.clongdouble,
 2171:         }[dtype]
 2172:         a = np.arange(-50, 51, dtype=dtype)
 2173:         b = a[::-1].copy()
 2174:         ai = (a * (1 + 1j)).astype(cdtype)
 2175:         bi = (b * (1 + 1j)).astype(cdtype)
 2176:         setattr(ai, part, 1)
 2177:         setattr(bi, part, 1)
 2178:         for kind in self.sort_kinds:
 2179:             msg = f"complex sort, {part} part == 1, kind={kind}"
 2180:             c = ai.copy()
 2181:             c.sort(kind=kind)
 2182:             assert_equal(c, ai, msg)
 2183:             c = bi.copy()
 2184:             c.sort(kind=kind)
 2185:             assert_equal(c, ai, msg)
 2186: 
 2187:     def test_sort_complex_byte_swapping(self):
 2188:         # test sorting of complex arrays requiring byte-swapping, gh-5441
 2189:         for endianness in '<>':
 2190:             for dt in np.typecodes['Complex']:
 2191:                 arr = np.array([1 + 3.j, 2 + 2.j, 3 + 1.j], dtype=endianness + dt)
 2192:                 c = arr.copy()
 2193:                 c.sort()
 2194:                 msg = f'byte-swapped complex sort, dtype={dt}'
 2195:                 assert_equal(c, arr, msg)
 2196: 
 2197:     @pytest.mark.parametrize('dtype', [np.bytes_, np.str_])
 2198:     def test_sort_string(self, dtype):
 2199:         # np.array will perform the encoding to bytes for us in the bytes test
 2200:         a = np.array(['aaaaaaaa' + chr(i) for i in range(101)], dtype=dtype)
 2201:         b = a[::-1].copy()
 2202:         for kind in self.sort_kinds:
 2203:             msg = f"kind={kind}"
 2204:             c = a.copy()
 2205:             c.sort(kind=kind)
 2206:             assert_equal(c, a, msg)
 2207:             c = b.copy()
 2208:             c.sort(kind=kind)
 2209:             assert_equal(c, a, msg)
 2210: 
 2211:     def test_sort_object(self):
 2212:         # test object array sorts.
 2213:         a = np.empty((101,), dtype=object)
 2214:         a[:] = list(range(101))
 2215:         b = a[::-1]
 2216:         for kind in ['q', 'h', 'm']:
 2217:             msg = f"kind={kind}"
 2218:             c = a.copy()
 2219:             c.sort(kind=kind)
 2220:             assert_equal(c, a, msg)
 2221:             c = b.copy()
 2222:             c.sort(kind=kind)
 2223:             assert_equal(c, a, msg)
 2224: 
 2225:     @pytest.mark.parametrize("dt", [
 2226:             np.dtype([('f', float), ('i', int)]),
 2227:             np.dtype([('f', float), ('i', object)])])
 2228:     @pytest.mark.parametrize("step", [1, 2])
 2229:     def test_sort_structured(self, dt, step):
 2230:         # test record array sorts.
 2231:         a = np.array([(i, i) for i in range(101 * step)], dtype=dt)
 2232:         b = a[::-1]
 2233:         for kind in ['q', 'h', 'm']:
 2234:             msg = f"kind={kind}"
 2235:             c = a.copy()[::step]
 2236:             indx = c.argsort(kind=kind)
 2237:             c.sort(kind=kind)
 2238:             assert_equal(c, a[::step], msg)
 2239:             assert_equal(a[::step][indx], a[::step], msg)
 2240:             c = b.copy()[::step]
 2241:             indx = c.argsort(kind=kind)
 2242:             c.sort(kind=kind)
 2243:             assert_equal(c, a[step - 1::step], msg)
 2244:             assert_equal(b[::step][indx], a[step - 1::step], msg)
 2245: 
 2246:     @pytest.mark.parametrize('dtype', ['datetime64[D]', 'timedelta64[D]'])
 2247:     def test_sort_time(self, dtype):
 2248:         # test datetime64 and timedelta64 sorts.
 2249:         a = np.arange(0, 101, dtype=dtype)
 2250:         b = a[::-1]
 2251:         for kind in ['q', 'h', 'm']:
 2252:             msg = f"kind={kind}"
 2253:             c = a.copy()
 2254:             c.sort(kind=kind)
 2255:             assert_equal(c, a, msg)
 2256:             c = b.copy()
 2257:             c.sort(kind=kind)
 2258:             assert_equal(c, a, msg)
 2259: 
 2260:     def test_sort_axis(self):
 2261:         # check axis handling. This should be the same for all type
 2262:         # specific sorts, so we only check it for one type and one kind
 2263:         a = np.array([[3, 2], [1, 0]])
 2264:         b = np.array([[1, 0], [3, 2]])
 2265:         c = np.array([[2, 3], [0, 1]])
 2266:         d = a.copy()
 2267:         d.sort(axis=0)
 2268:         assert_equal(d, b, "test sort with axis=0")
 2269:         d = a.copy()
 2270:         d.sort(axis=1)
 2271:         assert_equal(d, c, "test sort with axis=1")
 2272:         d = a.copy()
 2273:         d.sort()
 2274:         assert_equal(d, c, "test sort with default axis")
 2275: 
 2276:     def test_sort_size_0(self):
 2277:         # check axis handling for multidimensional empty arrays
 2278:         a = np.array([])
 2279:         a.shape = (3, 2, 1, 0)
 2280:         for axis in range(-a.ndim, a.ndim):
 2281:             msg = f'test empty array sort with axis={axis}'
 2282:             assert_equal(np.sort(a, axis=axis), a, msg)
 2283:         msg = 'test empty array sort with axis=None'
 2284:         assert_equal(np.sort(a, axis=None), a.ravel(), msg)
 2285: 
 2286:     def test_sort_bad_ordering(self):
 2287:         # test generic class with bogus ordering,
 2288:         # should not segfault.
 2289:         class Boom:
 2290:             def __lt__(self, other):
 2291:                 return True
 2292: 
 2293:         a = np.array([Boom()] * 100, dtype=object)
 2294:         for kind in self.sort_kinds:
 2295:             msg = f"kind={kind}"
 2296:             c = a.copy()
 2297:             c.sort(kind=kind)
 2298:             assert_equal(c, a, msg)
 2299: 
 2300:     def test_void_sort(self):
 2301:         # gh-8210 - previously segfaulted
 2302:         for i in range(4):
 2303:             rand = np.random.randint(256, size=4000, dtype=np.uint8)
 2304:             arr = rand.view('V4')
 2305:             arr[::-1].sort()
 2306: 
 2307:         dt = np.dtype([('val', 'i4', (1,))])
 2308:         for i in range(4):
 2309:             rand = np.random.randint(256, size=4000, dtype=np.uint8)
 2310:             arr = rand.view(dt)
 2311:             arr[::-1].sort()
 2312: 
 2313:     def test_sort_raises(self):
 2314:         # gh-9404
 2315:         arr = np.array([0, datetime.now(), 1], dtype=object)
 2316:         for kind in self.sort_kinds:
 2317:             assert_raises(TypeError, arr.sort, kind=kind)
 2318:         # gh-3879
 2319: 
 2320:         class Raiser:
 2321:             def raises_anything(*args, **kwargs):
 2322:                 raise TypeError("SOMETHING ERRORED")
 2323:             __eq__ = __ne__ = __lt__ = __gt__ = __ge__ = __le__ = raises_anything
 2324:         arr = np.array([[Raiser(), n] for n in range(10)]).reshape(-1)
 2325:         np.random.shuffle(arr)
 2326:         for kind in self.sort_kinds:
 2327:             assert_raises(TypeError, arr.sort, kind=kind)
 2328: 
 2329:     def test_sort_degraded(self):
 2330:         # test degraded dataset would take minutes to run with normal qsort
 2331:         d = np.arange(1000000)
 2332:         do = d.copy()
 2333:         x = d
 2334:         # create a median of 3 killer where each median is the sorted second
 2335:         # last element of the quicksort partition
 2336:         while x.size > 3:
 2337:             mid = x.size // 2
 2338:             x[mid], x[-2] = x[-2], x[mid]
 2339:             x = x[:-2]
 2340: 
 2341:         assert_equal(np.sort(d), do)
 2342:         assert_equal(d[np.argsort(d)], do)
 2343: 
 2344:     def test_copy(self):
 2345:         def assert_fortran(arr):
 2346:             assert_(arr.flags.fortran)
 2347:             assert_(arr.flags.f_contiguous)
 2348:             assert_(not arr.flags.c_contiguous)
 2349: 
 2350:         def assert_c(arr):
 2351:             assert_(not arr.flags.fortran)
 2352:             assert_(not arr.flags.f_contiguous)
 2353:             assert_(arr.flags.c_contiguous)
 2354: 
 2355:         a = np.empty((2, 2), order='F')
 2356:         # Test copying a Fortran array
 2357:         assert_c(a.copy())
 2358:         assert_c(a.copy('C'))
 2359:         assert_fortran(a.copy('F'))
 2360:         assert_fortran(a.copy('A'))
 2361: 
 2362:         # Now test starting with a C array.
 2363:         a = np.empty((2, 2), order='C')
 2364:         assert_c(a.copy())
 2365:         assert_c(a.copy('C'))
 2366:         assert_fortran(a.copy('F'))
 2367:         assert_c(a.copy('A'))
 2368: 
 2369:     @pytest.mark.parametrize("dtype", ['O', np.int32, 'i,O'])
 2370:     def test__deepcopy__(self, dtype):
 2371:         # Force the entry of NULLs into array
 2372:         a = np.empty(4, dtype=dtype)
 2373:         ctypes.memset(a.ctypes.data, 0, a.nbytes)
 2374: 
 2375:         # Ensure no error is raised, see gh-21833
 2376:         b = a.__deepcopy__({})
 2377: 
 2378:         a[0] = 42
 2379:         with pytest.raises(AssertionError):
 2380:             assert_array_equal(a, b)
 2381: 
 2382:     def test__deepcopy__catches_failure(self):
 2383:         class MyObj:
 2384:             def __deepcopy__(self, *args, **kwargs):
 2385:                 raise RuntimeError
 2386: 
 2387:         arr = np.array([1, MyObj(), 3], dtype='O')
 2388:         with pytest.raises(RuntimeError):
 2389:             arr.__deepcopy__({})
 2390: 
 2391:     def test_sort_order(self):
 2392:         # Test sorting an array with fields
 2393:         x1 = np.array([21, 32, 14])
 2394:         x2 = np.array(['my', 'first', 'name'])
 2395:         x3 = np.array([3.1, 4.5, 6.2])
 2396:         r = np.rec.fromarrays([x1, x2, x3], names='id,word,number')
 2397: 
 2398:         r.sort(order=['id'])
 2399:         assert_equal(r.id, np.array([14, 21, 32]))
 2400:         assert_equal(r.word, np.array(['name', 'my', 'first']))
 2401:         assert_equal(r.number, np.array([6.2, 3.1, 4.5]))
 2402: 
 2403:         r.sort(order=['word'])
 2404:         assert_equal(r.id, np.array([32, 21, 14]))
 2405:         assert_equal(r.word, np.array(['first', 'my', 'name']))
 2406:         assert_equal(r.number, np.array([4.5, 3.1, 6.2]))
 2407: 
 2408:         r.sort(order=['number'])
 2409:         assert_equal(r.id, np.array([21, 32, 14]))
 2410:         assert_equal(r.word, np.array(['my', 'first', 'name']))
 2411:         assert_equal(r.number, np.array([3.1, 4.5, 6.2]))
 2412: 
 2413:         assert_raises_regex(ValueError, 'duplicate',
 2414:             lambda: r.sort(order=['id', 'id']))
 2415: 
 2416:         if sys.byteorder == 'little':
 2417:             strtype = '>i2'
 2418:         else:
 2419:             strtype = '<i2'
 2420:         mydtype = [('name', 'U5'), ('col2', strtype)]
 2421:         r = np.array([('a', 1), ('b', 255), ('c', 3), ('d', 258)],
 2422:                      dtype=mydtype)
 2423:         r.sort(order='col2')
 2424:         assert_equal(r['col2'], [1, 3, 255, 258])
 2425:         assert_equal(r, np.array([('a', 1), ('c', 3), ('b', 255), ('d', 258)],
 2426:                                  dtype=mydtype))
 2427: 
 2428:     def test_argsort(self):
 2429:         # all c scalar argsorts use the same code with different types
 2430:         # so it suffices to run a quick check with one type. The number
 2431:         # of sorted items must be greater than ~50 to check the actual
 2432:         # algorithm because quick and merge sort fall over to insertion
 2433:         # sort for small arrays.
 2434: 
 2435:         for dtype in [np.int32, np.uint32, np.float32]:
 2436:             a = np.arange(101, dtype=dtype)
 2437:             b = a[::-1].copy()
 2438:             for kind in self.sort_kinds:
 2439:                 msg = f"scalar argsort, kind={kind}, dtype={dtype}"
 2440:                 assert_equal(a.copy().argsort(kind=kind), a, msg)
 2441:                 assert_equal(b.copy().argsort(kind=kind), b, msg)
 2442: 
 2443:         # test complex argsorts. These use the same code as the scalars
 2444:         # but the compare function differs.
 2445:         ai = a * 1j + 1
 2446:         bi = b * 1j + 1
 2447:         for kind in self.sort_kinds:
 2448:             msg = f"complex argsort, kind={kind}"
 2449:             assert_equal(ai.copy().argsort(kind=kind), a, msg)
 2450:             assert_equal(bi.copy().argsort(kind=kind), b, msg)
 2451:         ai = a + 1j
 2452:         bi = b + 1j
 2453:         for kind in self.sort_kinds:
 2454:             msg = f"complex argsort, kind={kind}"
 2455:             assert_equal(ai.copy().argsort(kind=kind), a, msg)
 2456:             assert_equal(bi.copy().argsort(kind=kind), b, msg)
 2457: 
 2458:         # test argsort of complex arrays requiring byte-swapping, gh-5441
 2459:         for endianness in '<>':
 2460:             for dt in np.typecodes['Complex']:
 2461:                 arr = np.array([1 + 3.j, 2 + 2.j, 3 + 1.j], dtype=endianness + dt)
 2462:                 msg = f'byte-swapped complex argsort, dtype={dt}'
 2463:                 assert_equal(arr.argsort(),
 2464:                              np.arange(len(arr), dtype=np.intp), msg)
 2465: 
 2466:         # test string argsorts.
 2467:         s = 'aaaaaaaa'
 2468:         a = np.array([s + chr(i) for i in range(101)])
 2469:         b = a[::-1].copy()
 2470:         r = np.arange(101)
 2471:         rr = r[::-1]
 2472:         for kind in self.sort_kinds:
 2473:             msg = f"string argsort, kind={kind}"
 2474:             assert_equal(a.copy().argsort(kind=kind), r, msg)
 2475:             assert_equal(b.copy().argsort(kind=kind), rr, msg)
 2476: 
 2477:         # test unicode argsorts.
 2478:         s = 'aaaaaaaa'
 2479:         a = np.array([s + chr(i) for i in range(101)], dtype=np.str_)
 2480:         b = a[::-1]
 2481:         r = np.arange(101)
 2482:         rr = r[::-1]
 2483:         for kind in self.sort_kinds:
 2484:             msg = f"unicode argsort, kind={kind}"
 2485:             assert_equal(a.copy().argsort(kind=kind), r, msg)
 2486:             assert_equal(b.copy().argsort(kind=kind), rr, msg)
 2487: 
 2488:         # test object array argsorts.
 2489:         a = np.empty((101,), dtype=object)
 2490:         a[:] = list(range(101))
 2491:         b = a[::-1]
 2492:         r = np.arange(101)
 2493:         rr = r[::-1]
 2494:         for kind in self.sort_kinds:
 2495:             msg = f"object argsort, kind={kind}"
 2496:             assert_equal(a.copy().argsort(kind=kind), r, msg)
 2497:             assert_equal(b.copy().argsort(kind=kind), rr, msg)
 2498: 
 2499:         # test structured array argsorts.
 2500:         dt = np.dtype([('f', float), ('i', int)])
 2501:         a = np.array([(i, i) for i in range(101)], dtype=dt)
 2502:         b = a[::-1]
 2503:         r = np.arange(101)
 2504:         rr = r[::-1]
 2505:         for kind in self.sort_kinds:
 2506:             msg = f"structured array argsort, kind={kind}"
 2507:             assert_equal(a.copy().argsort(kind=kind), r, msg)
 2508:             assert_equal(b.copy().argsort(kind=kind), rr, msg)
 2509: 
 2510:         # test datetime64 argsorts.
 2511:         a = np.arange(0, 101, dtype='datetime64[D]')
 2512:         b = a[::-1]
 2513:         r = np.arange(101)
 2514:         rr = r[::-1]
 2515:         for kind in ['q', 'h', 'm']:
 2516:             msg = f"datetime64 argsort, kind={kind}"
 2517:             assert_equal(a.copy().argsort(kind=kind), r, msg)
 2518:             assert_equal(b.copy().argsort(kind=kind), rr, msg)
 2519: 
 2520:         # test timedelta64 argsorts.
 2521:         a = np.arange(0, 101, dtype='timedelta64[D]')
 2522:         b = a[::-1]
 2523:         r = np.arange(101)
 2524:         rr = r[::-1]
 2525:         for kind in ['q', 'h', 'm']:
 2526:             msg = f"timedelta64 argsort, kind={kind}"
 2527:             assert_equal(a.copy().argsort(kind=kind), r, msg)
 2528:             assert_equal(b.copy().argsort(kind=kind), rr, msg)
 2529: 
 2530:         # check axis handling. This should be the same for all type
 2531:         # specific argsorts, so we only check it for one type and one kind
 2532:         a = np.array([[3, 2], [1, 0]])
 2533:         b = np.array([[1, 1], [0, 0]])
 2534:         c = np.array([[1, 0], [1, 0]])
 2535:         assert_equal(a.copy().argsort(axis=0), b)
 2536:         assert_equal(a.copy().argsort(axis=1), c)
 2537:         assert_equal(a.copy().argsort(), c)
 2538: 
 2539:         # check axis handling for multidimensional empty arrays
 2540:         a = np.array([])
 2541:         a.shape = (3, 2, 1, 0)
 2542:         for axis in range(-a.ndim, a.ndim):
 2543:             msg = f'test empty array argsort with axis={axis}'
 2544:             assert_equal(np.argsort(a, axis=axis),
 2545:                          np.zeros_like(a, dtype=np.intp), msg)
 2546:         msg = 'test empty array argsort with axis=None'
 2547:         assert_equal(np.argsort(a, axis=None),
 2548:                      np.zeros_like(a.ravel(), dtype=np.intp), msg)
 2549: 
 2550:         # check that stable argsorts are stable
 2551:         r = np.arange(100)
 2552:         # scalars
 2553:         a = np.zeros(100)
 2554:         assert_equal(a.argsort(kind='m'), r)
 2555:         # complex
 2556:         a = np.zeros(100, dtype=complex)
 2557:         assert_equal(a.argsort(kind='m'), r)
 2558:         # string
 2559:         a = np.array(['aaaaaaaaa' for i in range(100)])
 2560:         assert_equal(a.argsort(kind='m'), r)
 2561:         # unicode
 2562:         a = np.array(['aaaaaaaaa' for i in range(100)], dtype=np.str_)
 2563:         assert_equal(a.argsort(kind='m'), r)
 2564: 
 2565:         with assert_raises_regex(
 2566:             ValueError,
 2567:             "kind` and `stable` parameters can't be provided at the same time"
 2568:         ):
 2569:             np.argsort(a, kind="stable", stable=True)
 2570: 
 2571:     def test_sort_unicode_kind(self):
 2572:         d = np.arange(10)
 2573:         k = b'\xc3\xa4'.decode("UTF8")
 2574:         assert_raises(ValueError, d.sort, kind=k)
 2575:         assert_raises(ValueError, d.argsort, kind=k)
 2576: 
 2577:     @pytest.mark.parametrize('a', [
 2578:         np.array([0, 1, np.nan], dtype=np.float16),
 2579:         np.array([0, 1, np.nan], dtype=np.float32),
 2580:         np.array([0, 1, np.nan]),
 2581:     ])
 2582:     def test_searchsorted_floats(self, a):
 2583:         # test for floats arrays containing nans. Explicitly test
 2584:         # half, single, and double precision floats to verify that
 2585:         # the NaN-handling is correct.
 2586:         msg = f"Test real ({a.dtype}) searchsorted with nans, side='l'"
 2587:         b = a.searchsorted(a, side='left')
 2588:         assert_equal(b, np.arange(3), msg)
 2589:         msg = f"Test real ({a.dtype}) searchsorted with nans, side='r'"
 2590:         b = a.searchsorted(a, side='right')
 2591:         assert_equal(b, np.arange(1, 4), msg)
 2592:         # check keyword arguments
 2593:         a.searchsorted(v=1)
 2594:         x = np.array([0, 1, np.nan], dtype='float32')
 2595:         y = np.searchsorted(x, x[-1])
 2596:         assert_equal(y, 2)
 2597: 
 2598:     def test_searchsorted_complex(self):
 2599:         # test for complex arrays containing nans.
 2600:         # The search sorted routines use the compare functions for the
 2601:         # array type, so this checks if that is consistent with the sort
 2602:         # order.
 2603:         # check double complex
 2604:         a = np.zeros(9, dtype=np.complex128)
 2605:         a.real += [0, 0, 1, 1, 0, 1, np.nan, np.nan, np.nan]
 2606:         a.imag += [0, 1, 0, 1, np.nan, np.nan, 0, 1, np.nan]
 2607:         msg = "Test complex searchsorted with nans, side='l'"
 2608:         b = a.searchsorted(a, side='left')
 2609:         assert_equal(b, np.arange(9), msg)
 2610:         msg = "Test complex searchsorted with nans, side='r'"
 2611:         b = a.searchsorted(a, side='right')
 2612:         assert_equal(b, np.arange(1, 10), msg)
 2613:         msg = "Test searchsorted with little endian, side='l'"
 2614:         a = np.array([0, 128], dtype='<i4')
 2615:         b = a.searchsorted(np.array(128, dtype='<i4'))
 2616:         assert_equal(b, 1, msg)
 2617:         msg = "Test searchsorted with big endian, side='l'"
 2618:         a = np.array([0, 128], dtype='>i4')
 2619:         b = a.searchsorted(np.array(128, dtype='>i4'))
 2620:         assert_equal(b, 1, msg)
 2621: 
 2622:     def test_searchsorted_n_elements(self):
 2623:         # Check 0 elements
 2624:         a = np.ones(0)
 2625:         b = a.searchsorted([0, 1, 2], 'left')
 2626:         assert_equal(b, [0, 0, 0])
 2627:         b = a.searchsorted([0, 1, 2], 'right')
 2628:         assert_equal(b, [0, 0, 0])
 2629:         a = np.ones(1)
 2630:         # Check 1 element
 2631:         b = a.searchsorted([0, 1, 2], 'left')
 2632:         assert_equal(b, [0, 0, 1])
 2633:         b = a.searchsorted([0, 1, 2], 'right')
 2634:         assert_equal(b, [0, 1, 1])
 2635:         # Check all elements equal
 2636:         a = np.ones(2)
 2637:         b = a.searchsorted([0, 1, 2], 'left')
 2638:         assert_equal(b, [0, 0, 2])
 2639:         b = a.searchsorted([0, 1, 2], 'right')
 2640:         assert_equal(b, [0, 2, 2])
 2641: 
 2642:     def test_searchsorted_unaligned_array(self):
 2643:         # Test searching unaligned array
 2644:         a = np.arange(10)
 2645:         aligned = np.empty(a.itemsize * a.size + 1, 'uint8')
 2646:         unaligned = aligned[1:].view(a.dtype)
 2647:         unaligned[:] = a
 2648:         # Test searching unaligned array
 2649:         b = unaligned.searchsorted(a, 'left')
 2650:         assert_equal(b, a)
 2651:         b = unaligned.searchsorted(a, 'right')
 2652:         assert_equal(b, a + 1)
 2653:         # Test searching for unaligned keys
 2654:         b = a.searchsorted(unaligned, 'left')
 2655:         assert_equal(b, a)
 2656:         b = a.searchsorted(unaligned, 'right')
 2657:         assert_equal(b, a + 1)
 2658: 
 2659:     def test_searchsorted_resetting(self):
 2660:         # Test smart resetting of binsearch indices
 2661:         a = np.arange(5)
 2662:         b = a.searchsorted([6, 5, 4], 'left')
 2663:         assert_equal(b, [5, 5, 4])
 2664:         b = a.searchsorted([6, 5, 4], 'right')
 2665:         assert_equal(b, [5, 5, 5])
 2666: 
 2667:     def test_searchsorted_type_specific(self):
 2668:         # Test all type specific binary search functions
 2669:         types = ''.join((np.typecodes['AllInteger'], np.typecodes['AllFloat'],
 2670:                          np.typecodes['Datetime'], '?O'))
 2671:         for dt in types:
 2672:             if dt == 'M':
 2673:                 dt = 'M8[D]'
 2674:             if dt == '?':
 2675:                 a = np.arange(2, dtype=dt)
 2676:                 out = np.arange(2)
 2677:             else:
 2678:                 a = np.arange(0, 5, dtype=dt)
 2679:                 out = np.arange(5)
 2680:             b = a.searchsorted(a, 'left')
 2681:             assert_equal(b, out)
 2682:             b = a.searchsorted(a, 'right')
 2683:             assert_equal(b, out + 1)
 2684:             # Test empty array, use a fresh array to get warnings in
 2685:             # valgrind if access happens.
 2686:             e = np.ndarray(shape=0, buffer=b'', dtype=dt)
 2687:             b = e.searchsorted(a, 'left')
 2688:             assert_array_equal(b, np.zeros(len(a), dtype=np.intp))
 2689:             b = a.searchsorted(e, 'left')
 2690:             assert_array_equal(b, np.zeros(0, dtype=np.intp))
 2691: 
 2692:     def test_searchsorted_unicode(self):
 2693:         # Test searchsorted on unicode strings.
 2694: 
 2695:         # 1.6.1 contained a string length miscalculation in
 2696:         # arraytypes.c.src:UNICODE_compare() which manifested as
 2697:         # incorrect/inconsistent results from searchsorted.
 2698:         a = np.array(['P:\\20x_dapi_cy3\\20x_dapi_cy3_20100185_1',
 2699:                       'P:\\20x_dapi_cy3\\20x_dapi_cy3_20100186_1',
 2700:                       'P:\\20x_dapi_cy3\\20x_dapi_cy3_20100187_1',
 2701:                       'P:\\20x_dapi_cy3\\20x_dapi_cy3_20100189_1',
 2702:                       'P:\\20x_dapi_cy3\\20x_dapi_cy3_20100190_1',
 2703:                       'P:\\20x_dapi_cy3\\20x_dapi_cy3_20100191_1',
 2704:                       'P:\\20x_dapi_cy3\\20x_dapi_cy3_20100192_1',
 2705:                       'P:\\20x_dapi_cy3\\20x_dapi_cy3_20100193_1',
 2706:                       'P:\\20x_dapi_cy3\\20x_dapi_cy3_20100194_1',
 2707:                       'P:\\20x_dapi_cy3\\20x_dapi_cy3_20100195_1',
 2708:                       'P:\\20x_dapi_cy3\\20x_dapi_cy3_20100196_1',
 2709:                       'P:\\20x_dapi_cy3\\20x_dapi_cy3_20100197_1',
 2710:                       'P:\\20x_dapi_cy3\\20x_dapi_cy3_20100198_1',
 2711:                       'P:\\20x_dapi_cy3\\20x_dapi_cy3_20100199_1'],
 2712:                      dtype=np.str_)
 2713:         ind = np.arange(len(a))
 2714:         assert_equal([a.searchsorted(v, 'left') for v in a], ind)
 2715:         assert_equal([a.searchsorted(v, 'right') for v in a], ind + 1)
 2716:         assert_equal([a.searchsorted(a[i], 'left') for i in ind], ind)
 2717:         assert_equal([a.searchsorted(a[i], 'right') for i in ind], ind + 1)
 2718: 
 2719:     def test_searchsorted_with_invalid_sorter(self):
 2720:         a = np.array([5, 2, 1, 3, 4])
 2721:         s = np.argsort(a)
 2722:         assert_raises(TypeError, np.searchsorted, a, 0,
 2723:                       sorter=np.array((1, (2, 3)), dtype=object))
 2724:         assert_raises(TypeError, np.searchsorted, a, 0, sorter=[1.1])
 2725:         assert_raises(ValueError, np.searchsorted, a, 0, sorter=[1, 2, 3, 4])
 2726:         assert_raises(ValueError, np.searchsorted, a, 0, sorter=[1, 2, 3, 4, 5, 6])
 2727: 
 2728:         # bounds check
 2729:         assert_raises(ValueError, np.searchsorted, a, 4, sorter=[0, 1, 2, 3, 5])
 2730:         assert_raises(ValueError, np.searchsorted, a, 0, sorter=[-1, 0, 1, 2, 3])
 2731:         assert_raises(ValueError, np.searchsorted, a, 0, sorter=[4, 0, -1, 2, 3])
 2732: 
 2733:     def test_searchsorted_with_sorter(self):
 2734:         a = np.random.rand(300)
 2735:         s = a.argsort()
 2736:         b = np.sort(a)
 2737:         k = np.linspace(0, 1, 20)
 2738:         assert_equal(b.searchsorted(k), a.searchsorted(k, sorter=s))
 2739: 
 2740:         a = np.array([0, 1, 2, 3, 5] * 20)
 2741:         s = a.argsort()
 2742:         k = [0, 1, 2, 3, 5]
 2743:         expected = [0, 20, 40, 60, 80]
 2744:         assert_equal(a.searchsorted(k, side='left', sorter=s), expected)
 2745:         expected = [20, 40, 60, 80, 100]
 2746:         assert_equal(a.searchsorted(k, side='right', sorter=s), expected)
 2747: 
 2748:         # Test searching unaligned array
 2749:         keys = np.arange(10)
 2750:         a = keys.copy()
 2751:         np.random.shuffle(s)
 2752:         s = a.argsort()
 2753:         aligned = np.empty(a.itemsize * a.size + 1, 'uint8')
 2754:         unaligned = aligned[1:].view(a.dtype)
 2755:         # Test searching unaligned array
 2756:         unaligned[:] = a
 2757:         b = unaligned.searchsorted(keys, 'left', s)
 2758:         assert_equal(b, keys)
 2759:         b = unaligned.searchsorted(keys, 'right', s)
 2760:         assert_equal(b, keys + 1)
 2761:         # Test searching for unaligned keys
 2762:         unaligned[:] = keys
 2763:         b = a.searchsorted(unaligned, 'left', s)
 2764:         assert_equal(b, keys)
 2765:         b = a.searchsorted(unaligned, 'right', s)
 2766:         assert_equal(b, keys + 1)
 2767: 
 2768:         # Test all type specific indirect binary search functions
 2769:         types = ''.join((np.typecodes['AllInteger'], np.typecodes['AllFloat'],
 2770:                          np.typecodes['Datetime'], '?O'))
 2771:         for dt in types:
 2772:             if dt == 'M':
 2773:                 dt = 'M8[D]'
 2774:             if dt == '?':
 2775:                 a = np.array([1, 0], dtype=dt)
 2776:                 # We want the sorter array to be of a type that is different
 2777:                 # from np.intp in all platforms, to check for #4698
 2778:                 s = np.array([1, 0], dtype=np.int16)
 2779:                 out = np.array([1, 0])
 2780:             else:
 2781:                 a = np.array([3, 4, 1, 2, 0], dtype=dt)
 2782:                 # We want the sorter array to be of a type that is different
 2783:                 # from np.intp in all platforms, to check for #4698
 2784:                 s = np.array([4, 2, 3, 0, 1], dtype=np.int16)
 2785:                 out = np.array([3, 4, 1, 2, 0], dtype=np.intp)
 2786:             b = a.searchsorted(a, 'left', s)
 2787:             assert_equal(b, out)
 2788:             b = a.searchsorted(a, 'right', s)
 2789:             assert_equal(b, out + 1)
 2790:             # Test empty array, use a fresh array to get warnings in
 2791:             # valgrind if access happens.
 2792:             e = np.ndarray(shape=0, buffer=b'', dtype=dt)
 2793:             b = e.searchsorted(a, 'left', s[:0])
 2794:             assert_array_equal(b, np.zeros(len(a), dtype=np.intp))
 2795:             b = a.searchsorted(e, 'left', s)
 2796:             assert_array_equal(b, np.zeros(0, dtype=np.intp))
 2797: 
 2798:         # Test non-contiguous sorter array
 2799:         a = np.array([3, 4, 1, 2, 0])
 2800:         srt = np.empty((10,), dtype=np.intp)
 2801:         srt[1::2] = -1
 2802:         srt[::2] = [4, 2, 3, 0, 1]
 2803:         s = srt[::2]
 2804:         out = np.array([3, 4, 1, 2, 0], dtype=np.intp)
 2805:         b = a.searchsorted(a, 'left', s)
 2806:         assert_equal(b, out)
 2807:         b = a.searchsorted(a, 'right', s)
 2808:         assert_equal(b, out + 1)
 2809: 
 2810:     def test_searchsorted_return_type(self):
 2811:         # Functions returning indices should always return base ndarrays
 2812:         class A(np.ndarray):
 2813:             pass
 2814:         a = np.arange(5).view(A)
 2815:         b = np.arange(1, 3).view(A)
 2816:         s = np.arange(5).view(A)
 2817:         assert_(not isinstance(a.searchsorted(b, 'left'), A))
 2818:         assert_(not isinstance(a.searchsorted(b, 'right'), A))
 2819:         assert_(not isinstance(a.searchsorted(b, 'left', s), A))
 2820:         assert_(not isinstance(a.searchsorted(b, 'right', s), A))
 2821: 
 2822:     @pytest.mark.parametrize("dtype", np.typecodes["All"])
 2823:     def test_argpartition_out_of_range(self, dtype):
 2824:         # Test out of range values in kth raise an error, gh-5469
 2825:         d = np.arange(10).astype(dtype=dtype)
 2826:         assert_raises(ValueError, d.argpartition, 10)
 2827:         assert_raises(ValueError, d.argpartition, -11)
 2828: 
 2829:     @pytest.mark.parametrize("dtype", np.typecodes["All"])
 2830:     def test_partition_out_of_range(self, dtype):
 2831:         # Test out of range values in kth raise an error, gh-5469
 2832:         d = np.arange(10).astype(dtype=dtype)
 2833:         assert_raises(ValueError, d.partition, 10)
 2834:         assert_raises(ValueError, d.partition, -11)
 2835: 
 2836:     def test_argpartition_integer(self):
 2837:         # Test non-integer values in kth raise an error/
 2838:         d = np.arange(10)
 2839:         assert_raises(TypeError, d.argpartition, 9.)
 2840:         # Test also for generic type argpartition, which uses sorting
 2841:         # and used to not bound check kth
 2842:         d_obj = np.arange(10, dtype=object)
 2843:         assert_raises(TypeError, d_obj.argpartition, 9.)
 2844: 
 2845:     def test_partition_integer(self):
 2846:         # Test out of range values in kth raise an error, gh-5469
 2847:         d = np.arange(10)
 2848:         assert_raises(TypeError, d.partition, 9.)
 2849:         # Test also for generic type partition, which uses sorting
 2850:         # and used to not bound check kth
 2851:         d_obj = np.arange(10, dtype=object)
 2852:         assert_raises(TypeError, d_obj.partition, 9.)
 2853: 
 2854:     @pytest.mark.parametrize("kth_dtype", np.typecodes["AllInteger"])
 2855:     def test_partition_empty_array(self, kth_dtype):
 2856:         # check axis handling for multidimensional empty arrays
 2857:         kth = np.array(0, dtype=kth_dtype)[()]
 2858:         a = np.array([])
 2859:         a.shape = (3, 2, 1, 0)
 2860:         for axis in range(-a.ndim, a.ndim):
 2861:             msg = f'test empty array partition with axis={axis}'
 2862:             assert_equal(np.partition(a, kth, axis=axis), a, msg)
 2863:         msg = 'test empty array partition with axis=None'
 2864:         assert_equal(np.partition(a, kth, axis=None), a.ravel(), msg)
 2865: 
 2866:     @pytest.mark.parametrize("kth_dtype", np.typecodes["AllInteger"])
 2867:     def test_argpartition_empty_array(self, kth_dtype):
 2868:         # check axis handling for multidimensional empty arrays
 2869:         kth = np.array(0, dtype=kth_dtype)[()]
 2870:         a = np.array([])
 2871:         a.shape = (3, 2, 1, 0)
 2872:         for axis in range(-a.ndim, a.ndim):
 2873:             msg = f'test empty array argpartition with axis={axis}'
 2874:             assert_equal(np.partition(a, kth, axis=axis),
 2875:                          np.zeros_like(a, dtype=np.intp), msg)
 2876:         msg = 'test empty array argpartition with axis=None'
 2877:         assert_equal(np.partition(a, kth, axis=None),
 2878:                      np.zeros_like(a.ravel(), dtype=np.intp), msg)
 2879: 
 2880:     def test_partition(self):
 2881:         d = np.arange(10)
 2882:         assert_raises(TypeError, np.partition, d, 2, kind=1)
 2883:         assert_raises(ValueError, np.partition, d, 2, kind="nonsense")
 2884:         assert_raises(ValueError, np.argpartition, d, 2, kind="nonsense")
 2885:         assert_raises(ValueError, d.partition, 2, axis=0, kind="nonsense")
 2886:         assert_raises(ValueError, d.argpartition, 2, axis=0, kind="nonsense")
 2887:         for k in ("introselect",):
 2888:             d = np.array([])
 2889:             assert_array_equal(np.partition(d, 0, kind=k), d)
 2890:             assert_array_equal(np.argpartition(d, 0, kind=k), d)
 2891:             d = np.ones(1)
 2892:             assert_array_equal(np.partition(d, 0, kind=k)[0], d)
 2893:             assert_array_equal(d[np.argpartition(d, 0, kind=k)],
 2894:                                np.partition(d, 0, kind=k))
 2895: 
 2896:             # kth not modified
 2897:             kth = np.array([30, 15, 5])
 2898:             okth = kth.copy()
 2899:             np.partition(np.arange(40), kth)
 2900:             assert_array_equal(kth, okth)
 2901: 
 2902:             for r in ([2, 1], [1, 2], [1, 1]):
 2903:                 d = np.array(r)
 2904:                 tgt = np.sort(d)
 2905:                 assert_array_equal(np.partition(d, 0, kind=k)[0], tgt[0])
 2906:                 assert_array_equal(np.partition(d, 1, kind=k)[1], tgt[1])
 2907:                 self.assert_partitioned(np.partition(d, 0, kind=k), [0])
 2908:                 self.assert_partitioned(d[np.argpartition(d, 0, kind=k)], [0])
 2909:                 self.assert_partitioned(np.partition(d, 1, kind=k), [1])
 2910:                 self.assert_partitioned(d[np.argpartition(d, 1, kind=k)], [1])
 2911:                 for i in range(d.size):
 2912:                     d[i:].partition(0, kind=k)
 2913:                 assert_array_equal(d, tgt)
 2914: 
 2915:             for r in ([3, 2, 1], [1, 2, 3], [2, 1, 3], [2, 3, 1],
 2916:                       [1, 1, 1], [1, 2, 2], [2, 2, 1], [1, 2, 1]):
 2917:                 d = np.array(r)
 2918:                 tgt = np.sort(d)
 2919:                 assert_array_equal(np.partition(d, 0, kind=k)[0], tgt[0])
 2920:                 assert_array_equal(np.partition(d, 1, kind=k)[1], tgt[1])
 2921:                 assert_array_equal(np.partition(d, 2, kind=k)[2], tgt[2])
 2922:                 self.assert_partitioned(np.partition(d, 0, kind=k), [0])
 2923:                 self.assert_partitioned(d[np.argpartition(d, 0, kind=k)], [0])
 2924:                 self.assert_partitioned(np.partition(d, 1, kind=k), [1])
 2925:                 self.assert_partitioned(d[np.argpartition(d, 1, kind=k)], [1])
 2926:                 self.assert_partitioned(np.partition(d, 2, kind=k), [2])
 2927:                 self.assert_partitioned(d[np.argpartition(d, 2, kind=k)], [2])
 2928:                 for i in range(d.size):
 2929:                     d[i:].partition(0, kind=k)
 2930:                 assert_array_equal(d, tgt)
 2931: 
 2932:             d = np.ones(50)
 2933:             assert_array_equal(np.partition(d, 0, kind=k), d)
 2934:             assert_array_equal(d[np.argpartition(d, 0, kind=k)],
 2935:                                np.partition(d, 0, kind=k))
 2936: 
 2937:             # sorted
 2938:             d = np.arange(49)
 2939:             assert_equal(np.partition(d, 5, kind=k)[5], 5)
 2940:             assert_equal(np.partition(d, 15, kind=k)[15], 15)
 2941:             self.assert_partitioned(np.partition(d, 5, kind=k), [5])
 2942:             self.assert_partitioned(d[np.argpartition(d, 5, kind=k)], [5])
 2943:             self.assert_partitioned(np.partition(d, 15, kind=k), [15])
 2944:             self.assert_partitioned(d[np.argpartition(d, 15, kind=k)], [15])
 2945: 
 2946:             # rsorted
 2947:             d = np.arange(47)[::-1]
 2948:             assert_equal(np.partition(d, 6, kind=k)[6], 6)
 2949:             assert_equal(np.partition(d, 16, kind=k)[16], 16)
 2950:             self.assert_partitioned(np.partition(d, 6, kind=k), [6])
 2951:             self.assert_partitioned(d[np.argpartition(d, 6, kind=k)], [6])
 2952:             self.assert_partitioned(np.partition(d, 16, kind=k), [16])
 2953:             self.assert_partitioned(d[np.argpartition(d, 16, kind=k)], [16])
 2954: 
 2955:             assert_array_equal(np.partition(d, -6, kind=k),
 2956:                                np.partition(d, 41, kind=k))
 2957:             assert_array_equal(np.partition(d, -16, kind=k),
 2958:                                np.partition(d, 31, kind=k))
 2959:             self.assert_partitioned(np.partition(d, 41, kind=k), [41])
 2960:             self.assert_partitioned(d[np.argpartition(d, -6, kind=k)], [41])
 2961: 
 2962:             # median of 3 killer, O(n^2) on pure median 3 pivot quickselect
 2963:             # exercises the median of median of 5 code used to keep O(n)
 2964:             d = np.arange(1000000)
 2965:             x = np.roll(d, d.size // 2)
 2966:             mid = x.size // 2 + 1
 2967:             assert_equal(np.partition(x, mid)[mid], mid)
 2968:             d = np.arange(1000001)
 2969:             x = np.roll(d, d.size // 2 + 1)
 2970:             mid = x.size // 2 + 1
 2971:             assert_equal(np.partition(x, mid)[mid], mid)
 2972: 
 2973:             # max
 2974:             d = np.ones(10)
 2975:             d[1] = 4
 2976:             assert_equal(np.partition(d, (2, -1))[-1], 4)
 2977:             assert_equal(np.partition(d, (2, -1))[2], 1)
 2978:             assert_equal(d[np.argpartition(d, (2, -1))][-1], 4)
 2979:             assert_equal(d[np.argpartition(d, (2, -1))][2], 1)
 2980:             d[1] = np.nan
 2981:             assert_(np.isnan(d[np.argpartition(d, (2, -1))][-1]))
 2982:             assert_(np.isnan(np.partition(d, (2, -1))[-1]))
 2983: 
 2984:             # equal elements
 2985:             d = np.arange(47) % 7
 2986:             tgt = np.sort(np.arange(47) % 7)
 2987:             np.random.shuffle(d)
 2988:             for i in range(d.size):
 2989:                 assert_equal(np.partition(d, i, kind=k)[i], tgt[i])
 2990:             self.assert_partitioned(np.partition(d, 6, kind=k), [6])
 2991:             self.assert_partitioned(d[np.argpartition(d, 6, kind=k)], [6])
 2992:             self.assert_partitioned(np.partition(d, 16, kind=k), [16])
 2993:             self.assert_partitioned(d[np.argpartition(d, 16, kind=k)], [16])
 2994:             for i in range(d.size):
 2995:                 d[i:].partition(0, kind=k)
 2996:             assert_array_equal(d, tgt)
 2997: 
 2998:             d = np.array([0, 1, 2, 3, 4, 5, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
 2999:                           7, 7, 7, 7, 7, 9])
 3000:             kth = [0, 3, 19, 20]
 3001:             assert_equal(np.partition(d, kth, kind=k)[kth], (0, 3, 7, 7))
 3002:             assert_equal(d[np.argpartition(d, kth, kind=k)][kth], (0, 3, 7, 7))
 3003: 
 3004:             d = np.array([2, 1])
 3005:             d.partition(0, kind=k)
 3006:             assert_raises(ValueError, d.partition, 2)
 3007:             assert_raises(AxisError, d.partition, 3, axis=1)
 3008:             assert_raises(ValueError, np.partition, d, 2)
 3009:             assert_raises(AxisError, np.partition, d, 2, axis=1)
 3010:             assert_raises(ValueError, d.argpartition, 2)
 3011:             assert_raises(AxisError, d.argpartition, 3, axis=1)
 3012:             assert_raises(ValueError, np.argpartition, d, 2)
 3013:             assert_raises(AxisError, np.argpartition, d, 2, axis=1)
 3014:             d = np.arange(10).reshape((2, 5))
 3015:             d.partition(1, axis=0, kind=k)
 3016:             d.partition(4, axis=1, kind=k)
 3017:             np.partition(d, 1, axis=0, kind=k)
 3018:             np.partition(d, 4, axis=1, kind=k)
 3019:             np.partition(d, 1, axis=None, kind=k)
 3020:             np.partition(d, 9, axis=None, kind=k)
 3021:             d.argpartition(1, axis=0, kind=k)
 3022:             d.argpartition(4, axis=1, kind=k)
 3023:             np.argpartition(d, 1, axis=0, kind=k)
 3024:             np.argpartition(d, 4, axis=1, kind=k)
 3025:             np.argpartition(d, 1, axis=None, kind=k)
 3026:             np.argpartition(d, 9, axis=None, kind=k)
 3027:             assert_raises(ValueError, d.partition, 2, axis=0)
 3028:             assert_raises(ValueError, d.partition, 11, axis=1)
 3029:             assert_raises(TypeError, d.partition, 2, axis=None)
 3030:             assert_raises(ValueError, np.partition, d, 9, axis=1)
 3031:             assert_raises(ValueError, np.partition, d, 11, axis=None)
 3032:             assert_raises(ValueError, d.argpartition, 2, axis=0)
 3033:             assert_raises(ValueError, d.argpartition, 11, axis=1)
 3034:             assert_raises(ValueError, np.argpartition, d, 9, axis=1)
 3035:             assert_raises(ValueError, np.argpartition, d, 11, axis=None)
 3036: 
 3037:             td = [(dt, s) for dt in [np.int32, np.float32, np.complex64]
 3038:                   for s in (9, 16)]
 3039:             for dt, s in td:
 3040:                 aae = assert_array_equal
 3041:                 at = assert_
 3042: 
 3043:                 d = np.arange(s, dtype=dt)
 3044:                 np.random.shuffle(d)
 3045:                 d1 = np.tile(np.arange(s, dtype=dt), (4, 1))
 3046:                 map(np.random.shuffle, d1)
 3047:                 d0 = np.transpose(d1)
 3048:                 for i in range(d.size):
 3049:                     p = np.partition(d, i, kind=k)
 3050:                     assert_equal(p[i], i)
 3051:                     # all before are smaller
 3052:                     assert_array_less(p[:i], p[i])
 3053:                     # all after are larger
 3054:                     assert_array_less(p[i], p[i + 1:])
 3055:                     self.assert_partitioned(p, [i])
 3056:                     self.assert_partitioned(
 3057:                             d[np.argpartition(d, i, kind=k)], [i])
 3058: 
 3059:                     p = np.partition(d1, i, axis=1, kind=k)
 3060:                     parg = d1[np.arange(d1.shape[0])[:, None],
 3061:                             np.argpartition(d1, i, axis=1, kind=k)]
 3062:                     aae(p[:, i], np.array([i] * d1.shape[0], dtype=dt))
 3063:                     # array_less does not seem to work right
 3064:                     at((p[:, :i].T <= p[:, i]).all(),
 3065:                        msg="%d: %r <= %r" % (i, p[:, i], p[:, :i].T))
 3066:                     at((p[:, i + 1:].T > p[:, i]).all(),
 3067:                        msg="%d: %r < %r" % (i, p[:, i], p[:, i + 1:].T))
 3068:                     for row in range(p.shape[0]):
 3069:                         self.assert_partitioned(p[row], [i])
 3070:                         self.assert_partitioned(parg[row], [i])
 3071: 
 3072:                     p = np.partition(d0, i, axis=0, kind=k)
 3073:                     parg = d0[np.argpartition(d0, i, axis=0, kind=k),
 3074:                             np.arange(d0.shape[1])[None, :]]
 3075:                     aae(p[i, :], np.array([i] * d1.shape[0], dtype=dt))
 3076:                     # array_less does not seem to work right
 3077:                     at((p[:i, :] <= p[i, :]).all(),
 3078:                        msg="%d: %r <= %r" % (i, p[i, :], p[:i, :]))
 3079:                     at((p[i + 1:, :] > p[i, :]).all(),
 3080:                        msg="%d: %r < %r" % (i, p[i, :], p[:, i + 1:]))
 3081:                     for col in range(p.shape[1]):
 3082:                         self.assert_partitioned(p[:, col], [i])
 3083:                         self.assert_partitioned(parg[:, col], [i])
 3084: 
 3085:                     # check inplace
 3086:                     dc = d.copy()
 3087:                     dc.partition(i, kind=k)
 3088:                     assert_equal(dc, np.partition(d, i, kind=k))
 3089:                     dc = d0.copy()
 3090:                     dc.partition(i, axis=0, kind=k)
 3091:                     assert_equal(dc, np.partition(d0, i, axis=0, kind=k))
 3092:                     dc = d1.copy()
 3093:                     dc.partition(i, axis=1, kind=k)
 3094:                     assert_equal(dc, np.partition(d1, i, axis=1, kind=k))
 3095: 
 3096:     def assert_partitioned(self, d, kth):
 3097:         prev = 0
 3098:         for k in np.sort(kth):
 3099:             assert_array_compare(operator.__le__, d[prev:k], d[k],
 3100:                     err_msg='kth %d' % k)
 3101:             assert_((d[k:] >= d[k]).all(),
 3102:                     msg="kth %d, %r not greater equal %r" % (k, d[k:], d[k]))
 3103:             prev = k + 1
 3104: 
 3105:     def test_partition_iterative(self):
 3106:         d = np.arange(17)
 3107:         kth = (0, 1, 2, 429, 231)
 3108:         assert_raises(ValueError, d.partition, kth)
 3109:         assert_raises(ValueError, d.argpartition, kth)
 3110:         d = np.arange(10).reshape((2, 5))
 3111:         assert_raises(ValueError, d.partition, kth, axis=0)
 3112:         assert_raises(ValueError, d.partition, kth, axis=1)
 3113:         assert_raises(ValueError, np.partition, d, kth, axis=1)
 3114:         assert_raises(ValueError, np.partition, d, kth, axis=None)
 3115: 
 3116:         d = np.array([3, 4, 2, 1])
 3117:         p = np.partition(d, (0, 3))
 3118:         self.assert_partitioned(p, (0, 3))
 3119:         self.assert_partitioned(d[np.argpartition(d, (0, 3))], (0, 3))
 3120: 
 3121:         assert_array_equal(p, np.partition(d, (-3, -1)))
 3122:         assert_array_equal(p, d[np.argpartition(d, (-3, -1))])
 3123: 
 3124:         d = np.arange(17)
 3125:         np.random.shuffle(d)
 3126:         d.partition(range(d.size))
 3127:         assert_array_equal(np.arange(17), d)
 3128:         np.random.shuffle(d)
 3129:         assert_array_equal(np.arange(17), d[d.argpartition(range(d.size))])
 3130: 
 3131:         # test unsorted kth
 3132:         d = np.arange(17)
 3133:         np.random.shuffle(d)
 3134:         keys = np.array([1, 3, 8, -2])
 3135:         np.random.shuffle(d)
 3136:         p = np.partition(d, keys)
 3137:         self.assert_partitioned(p, keys)
 3138:         p = d[np.argpartition(d, keys)]
 3139:         self.assert_partitioned(p, keys)
 3140:         np.random.shuffle(keys)
 3141:         assert_array_equal(np.partition(d, keys), p)
 3142:         assert_array_equal(d[np.argpartition(d, keys)], p)
 3143: 
 3144:         # equal kth
 3145:         d = np.arange(20)[::-1]
 3146:         self.assert_partitioned(np.partition(d, [5] * 4), [5])
 3147:         self.assert_partitioned(np.partition(d, [5] * 4 + [6, 13]),
 3148:                                 [5] * 4 + [6, 13])
 3149:         self.assert_partitioned(d[np.argpartition(d, [5] * 4)], [5])
 3150:         self.assert_partitioned(d[np.argpartition(d, [5] * 4 + [6, 13])],
 3151:                                 [5] * 4 + [6, 13])
 3152: 
 3153:         d = np.arange(12)
 3154:         np.random.shuffle(d)
 3155:         d1 = np.tile(np.arange(12), (4, 1))
 3156:         map(np.random.shuffle, d1)
 3157:         d0 = np.transpose(d1)
 3158: 
 3159:         kth = (1, 6, 7, -1)
 3160:         p = np.partition(d1, kth, axis=1)
 3161:         pa = d1[np.arange(d1.shape[0])[:, None],
 3162:                 d1.argpartition(kth, axis=1)]
 3163:         assert_array_equal(p, pa)
 3164:         for i in range(d1.shape[0]):
 3165:             self.assert_partitioned(p[i, :], kth)
 3166:         p = np.partition(d0, kth, axis=0)
 3167:         pa = d0[np.argpartition(d0, kth, axis=0),
 3168:                 np.arange(d0.shape[1])[None, :]]
 3169:         assert_array_equal(p, pa)
 3170:         for i in range(d0.shape[1]):
 3171:             self.assert_partitioned(p[:, i], kth)
 3172: 
 3173:     def test_partition_cdtype(self):
 3174:         d = np.array([('Galahad', 1.7, 38), ('Arthur', 1.8, 41),
 3175:                    ('Lancelot', 1.9, 38)],
 3176:                   dtype=[('name', '|S10'), ('height', '<f8'), ('age', '<i4')])
 3177: 
 3178:         tgt = np.sort(d, order=['age', 'height'])
 3179:         assert_array_equal(np.partition(d, range(d.size),
 3180:                                         order=['age', 'height']),
 3181:                            tgt)
 3182:         assert_array_equal(d[np.argpartition(d, range(d.size),
 3183:                                              order=['age', 'height'])],
 3184:                            tgt)
 3185:         for k in range(d.size):
 3186:             assert_equal(np.partition(d, k, order=['age', 'height'])[k],
 3187:                         tgt[k])
 3188:             assert_equal(d[np.argpartition(d, k, order=['age', 'height'])][k],
 3189:                          tgt[k])
 3190: 
 3191:         d = np.array(['Galahad', 'Arthur', 'zebra', 'Lancelot'])
 3192:         tgt = np.sort(d)
 3193:         assert_array_equal(np.partition(d, range(d.size)), tgt)
 3194:         for k in range(d.size):
 3195:             assert_equal(np.partition(d, k)[k], tgt[k])
 3196:             assert_equal(d[np.argpartition(d, k)][k], tgt[k])
 3197: 
 3198:     def test_partition_unicode_kind(self):
 3199:         d = np.arange(10)
 3200:         k = b'\xc3\xa4'.decode("UTF8")
 3201:         assert_raises(ValueError, d.partition, 2, kind=k)
 3202:         assert_raises(ValueError, d.argpartition, 2, kind=k)
 3203: 
 3204:     def test_partition_fuzz(self):
 3205:         # a few rounds of random data testing
 3206:         for j in range(10, 30):
 3207:             for i in range(1, j - 2):
 3208:                 d = np.arange(j)
 3209:                 np.random.shuffle(d)
 3210:                 d = d % np.random.randint(2, 30)
 3211:                 idx = np.random.randint(d.size)
 3212:                 kth = [0, idx, i, i + 1]
 3213:                 tgt = np.sort(d)[kth]
 3214:                 assert_array_equal(np.partition(d, kth)[kth], tgt,
 3215:                                    err_msg=f"data: {d!r}\n kth: {kth!r}")
 3216: 
 3217:     @pytest.mark.parametrize("kth_dtype", np.typecodes["AllInteger"])
 3218:     def test_argpartition_gh5524(self, kth_dtype):
 3219:         #  A test for functionality of argpartition on lists.
 3220:         kth = np.array(1, dtype=kth_dtype)[()]
 3221:         d = [6, 7, 3, 2, 9, 0]
 3222:         p = np.argpartition(d, kth)
 3223:         self.assert_partitioned(np.array(d)[p], [1])
 3224: 
 3225:     def test_flatten(self):
 3226:         x0 = np.array([[1, 2, 3], [4, 5, 6]], np.int32)
 3227:         x1 = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]], np.int32)
 3228:         y0 = np.array([1, 2, 3, 4, 5, 6], np.int32)
 3229:         y0f = np.array([1, 4, 2, 5, 3, 6], np.int32)
 3230:         y1 = np.array([1, 2, 3, 4, 5, 6, 7, 8], np.int32)
 3231:         y1f = np.array([1, 5, 3, 7, 2, 6, 4, 8], np.int32)
 3232:         assert_equal(x0.flatten(), y0)
 3233:         assert_equal(x0.flatten('F'), y0f)
 3234:         assert_equal(x0.flatten('F'), x0.T.flatten())
 3235:         assert_equal(x1.flatten(), y1)
 3236:         assert_equal(x1.flatten('F'), y1f)
 3237:         assert_equal(x1.flatten('F'), x1.T.flatten())
 3238: 
 3239:     @pytest.mark.parametrize('func', (np.dot, np.matmul))
 3240:     def test_arr_mult(self, func):
 3241:         a = np.array([[1, 0], [0, 1]])
 3242:         b = np.array([[0, 1], [1, 0]])
 3243:         c = np.array([[9, 1], [1, -9]])
 3244:         d = np.arange(24).reshape(4, 6)
 3245:         ddt = np.array(
 3246:             [[  55,  145,  235,  325],
 3247:              [ 145,  451,  757, 1063],
 3248:              [ 235,  757, 1279, 1801],
 3249:              [ 325, 1063, 1801, 2539]]
 3250:         )
 3251:         dtd = np.array(
 3252:             [[504, 540, 576, 612, 648, 684],
 3253:              [540, 580, 620, 660, 700, 740],
 3254:              [576, 620, 664, 708, 752, 796],
 3255:              [612, 660, 708, 756, 804, 852],
 3256:              [648, 700, 752, 804, 856, 908],
 3257:              [684, 740, 796, 852, 908, 964]]
 3258:         )
 3259: 
 3260:         # gemm vs syrk optimizations
 3261:         for et in [np.float32, np.float64, np.complex64, np.complex128]:
 3262:             eaf = a.astype(et)
 3263:             assert_equal(func(eaf, eaf), eaf)
 3264:             assert_equal(func(eaf.T, eaf), eaf)
 3265:             assert_equal(func(eaf, eaf.T), eaf)
 3266:             assert_equal(func(eaf.T, eaf.T), eaf)
 3267:             assert_equal(func(eaf.T.copy(), eaf), eaf)
 3268:             assert_equal(func(eaf, eaf.T.copy()), eaf)
 3269:             assert_equal(func(eaf.T.copy(), eaf.T.copy()), eaf)
 3270: 
 3271:         # syrk validations
 3272:         for et in [np.float32, np.float64, np.complex64, np.complex128]:
 3273:             eaf = a.astype(et)
 3274:             ebf = b.astype(et)
 3275:             assert_equal(func(ebf, ebf), eaf)
 3276:             assert_equal(func(ebf.T, ebf), eaf)
 3277:             assert_equal(func(ebf, ebf.T), eaf)
 3278:             assert_equal(func(ebf.T, ebf.T), eaf)
 3279: 
 3280:         # syrk - different shape, stride, and view validations
 3281:         for et in [np.float32, np.float64, np.complex64, np.complex128]:
 3282:             edf = d.astype(et)
 3283:             assert_equal(
 3284:                 func(edf[::-1, :], edf.T),
 3285:                 func(edf[::-1, :].copy(), edf.T.copy())
 3286:             )
 3287:             assert_equal(
 3288:                 func(edf[:, ::-1], edf.T),
 3289:                 func(edf[:, ::-1].copy(), edf.T.copy())
 3290:             )
 3291:             assert_equal(
 3292:                 func(edf, edf[::-1, :].T),
 3293:                 func(edf, edf[::-1, :].T.copy())
 3294:             )
 3295:             assert_equal(
 3296:                 func(edf, edf[:, ::-1].T),
 3297:                 func(edf, edf[:, ::-1].T.copy())
 3298:             )
 3299:             assert_equal(
 3300:                 func(edf[:edf.shape[0] // 2, :], edf[::2, :].T),
 3301:                 func(edf[:edf.shape[0] // 2, :].copy(), edf[::2, :].T.copy())
 3302:             )
 3303:             assert_equal(
 3304:                 func(edf[::2, :], edf[:edf.shape[0] // 2, :].T),
 3305:                 func(edf[::2, :].copy(), edf[:edf.shape[0] // 2, :].T.copy())
 3306:             )
 3307: 
 3308:         # syrk - different shape
 3309:         for et in [np.float32, np.float64, np.complex64, np.complex128]:
 3310:             edf = d.astype(et)
 3311:             eddtf = ddt.astype(et)
 3312:             edtdf = dtd.astype(et)
 3313:             assert_equal(func(edf, edf.T), eddtf)
 3314:             assert_equal(func(edf.T, edf), edtdf)
 3315: 
 3316:     @pytest.mark.parametrize('func', (np.dot, np.matmul))
 3317:     @pytest.mark.parametrize('dtype', 'ifdFD')
 3318:     def test_no_dgemv(self, func, dtype):
 3319:         # check vector arg for contiguous before gemv
 3320:         # gh-12156
 3321:         a = np.arange(8.0, dtype=dtype).reshape(2, 4)
 3322:         b = np.broadcast_to(1., (4, 1))
 3323:         ret1 = func(a, b)
 3324:         ret2 = func(a, b.copy())
 3325:         assert_equal(ret1, ret2)
 3326: 
 3327:         ret1 = func(b.T, a.T)
 3328:         ret2 = func(b.T.copy(), a.T)
 3329:         assert_equal(ret1, ret2)
 3330: 
 3331:         # check for unaligned data
 3332:         dt = np.dtype(dtype)
 3333:         a = np.zeros(8 * dt.itemsize // 2 + 1, dtype='int16')[1:].view(dtype)
 3334:         a = a.reshape(2, 4)
 3335:         b = a[0]
 3336:         # make sure it is not aligned
 3337:         assert_(a.__array_interface__['data'][0] % dt.itemsize != 0)
 3338:         ret1 = func(a, b)
 3339:         ret2 = func(a.copy(), b.copy())
 3340:         assert_equal(ret1, ret2)
 3341: 
 3342:         ret1 = func(b.T, a.T)
 3343:         ret2 = func(b.T.copy(), a.T.copy())
 3344:         assert_equal(ret1, ret2)
 3345: 
 3346:     def test_dot(self):
 3347:         a = np.array([[1, 0], [0, 1]])
 3348:         b = np.array([[0, 1], [1, 0]])
 3349:         c = np.array([[9, 1], [1, -9]])
 3350:         # function versus methods
 3351:         assert_equal(np.dot(a, b), a.dot(b))
 3352:         assert_equal(np.dot(np.dot(a, b), c), a.dot(b).dot(c))
 3353: 
 3354:         # test passing in an output array
 3355:         c = np.zeros_like(a)
 3356:         a.dot(b, c)
 3357:         assert_equal(c, np.dot(a, b))
 3358: 
 3359:         # test keyword args
 3360:         c = np.zeros_like(a)
 3361:         a.dot(b=b, out=c)
 3362:         assert_equal(c, np.dot(a, b))
 3363: 
 3364:     @pytest.mark.parametrize("dtype", [np.half, np.double, np.longdouble])
 3365:     @pytest.mark.skipif(IS_WASM, reason="no wasm fp exception support")
 3366:     def test_dot_errstate(self, dtype):
 3367:         # Some dtypes use BLAS for 'dot' operation and
 3368:         # not all BLAS support floating-point errors.
 3369:         if not BLAS_SUPPORTS_FPE and dtype == np.double:
 3370:             pytest.skip("BLAS does not support FPE")
 3371: 
 3372:         a = np.array([1, 1], dtype=dtype)
 3373:         b = np.array([-np.inf, np.inf], dtype=dtype)
 3374: 
 3375:         with np.errstate(invalid='raise'):
 3376:             # there are two paths, depending on the number of dimensions - test
 3377:             # them both
 3378:             with pytest.raises(FloatingPointError,
 3379:                     match="invalid value encountered in dot"):
 3380:                 np.dot(a, b)
 3381: 
 3382:             # test that fp exceptions are properly cleared
 3383:             np.dot(a, a)
 3384: 
 3385:             with pytest.raises(FloatingPointError,
 3386:                     match="invalid value encountered in dot"):
 3387:                 np.dot(a[np.newaxis, np.newaxis, ...],
 3388:                        b[np.newaxis, ..., np.newaxis])
 3389: 
 3390:             np.dot(a[np.newaxis, np.newaxis, ...],
 3391:                    a[np.newaxis, ..., np.newaxis])
 3392: 
 3393:     def test_dot_type_mismatch(self):
 3394:         c = 1.
 3395:         A = np.array((1, 1), dtype='i,i')
 3396: 
 3397:         assert_raises(TypeError, np.dot, c, A)
 3398:         assert_raises(TypeError, np.dot, A, c)
 3399: 
 3400:     def test_dot_out_mem_overlap(self):
 3401:         np.random.seed(1)
 3402: 
 3403:         # Test BLAS and non-BLAS code paths, including all dtypes
 3404:         # that dot() supports
 3405:         dtypes = [np.dtype(code) for code in np.typecodes['All']
 3406:                   if code not in 'USVM']
 3407:         for dtype in dtypes:
 3408:             a = np.random.rand(3, 3).astype(dtype)
 3409: 
 3410:             # Valid dot() output arrays must be aligned
 3411:             b = _aligned_zeros((3, 3), dtype=dtype)
 3412:             b[...] = np.random.rand(3, 3)
 3413: 
 3414:             y = np.dot(a, b)
 3415:             x = np.dot(a, b, out=b)
 3416:             assert_equal(x, y, err_msg=repr(dtype))
 3417: 
 3418:             # Check invalid output array
 3419:             assert_raises(ValueError, np.dot, a, b, out=b[::2])
 3420:             assert_raises(ValueError, np.dot, a, b, out=b.T)
 3421: 
 3422:     def test_dot_matmul_out(self):
 3423:         # gh-9641
 3424:         class Sub(np.ndarray):
 3425:             pass
 3426:         a = np.ones((2, 2)).view(Sub)
 3427:         b = np.ones((2, 2)).view(Sub)
 3428:         out = np.ones((2, 2))
 3429: 
 3430:         # make sure out can be any ndarray (not only subclass of inputs)
 3431:         np.dot(a, b, out=out)
 3432:         np.matmul(a, b, out=out)
 3433: 
 3434:     def test_dot_matmul_inner_array_casting_fails(self):
 3435: 
 3436:         class A:
 3437:             def __array__(self, *args, **kwargs):
 3438:                 raise NotImplementedError
 3439: 
 3440:         # Don't override the error from calling __array__()
 3441:         assert_raises(NotImplementedError, np.dot, A(), A())
 3442:         assert_raises(NotImplementedError, np.matmul, A(), A())
 3443:         assert_raises(NotImplementedError, np.inner, A(), A())
 3444: 
 3445:     def test_matmul_out(self):
 3446:         # overlapping memory
 3447:         a = np.arange(18).reshape(2, 3, 3)
 3448:         b = np.matmul(a, a)
 3449:         c = np.matmul(a, a, out=a)
 3450:         assert_(c is a)
 3451:         assert_equal(c, b)
 3452:         a = np.arange(18).reshape(2, 3, 3)
 3453:         c = np.matmul(a, a, out=a[::-1, ...])
 3454:         assert_(c.base is a.base)
 3455:         assert_equal(c, b)
 3456: 
 3457:     def test_diagonal(self):
 3458:         a = np.arange(12).reshape((3, 4))
 3459:         assert_equal(a.diagonal(), [0, 5, 10])
 3460:         assert_equal(a.diagonal(0), [0, 5, 10])
 3461:         assert_equal(a.diagonal(1), [1, 6, 11])
 3462:         assert_equal(a.diagonal(-1), [4, 9])
 3463:         assert_raises(AxisError, a.diagonal, axis1=0, axis2=5)
 3464:         assert_raises(AxisError, a.diagonal, axis1=5, axis2=0)
 3465:         assert_raises(AxisError, a.diagonal, axis1=5, axis2=5)
 3466:         assert_raises(ValueError, a.diagonal, axis1=1, axis2=1)
 3467: 
 3468:         b = np.arange(8).reshape((2, 2, 2))
 3469:         assert_equal(b.diagonal(), [[0, 6], [1, 7]])
 3470:         assert_equal(b.diagonal(0), [[0, 6], [1, 7]])
 3471:         assert_equal(b.diagonal(1), [[2], [3]])
 3472:         assert_equal(b.diagonal(-1), [[4], [5]])
 3473:         assert_raises(ValueError, b.diagonal, axis1=0, axis2=0)
 3474:         assert_equal(b.diagonal(0, 1, 2), [[0, 3], [4, 7]])
 3475:         assert_equal(b.diagonal(0, 0, 1), [[0, 6], [1, 7]])
 3476:         assert_equal(b.diagonal(offset=1, axis1=0, axis2=2), [[1], [3]])
 3477:         # Order of axis argument doesn't matter:
 3478:         assert_equal(b.diagonal(0, 2, 1), [[0, 3], [4, 7]])
 3479: 
 3480:     def test_diagonal_view_notwriteable(self):
 3481:         a = np.eye(3).diagonal()
 3482:         assert_(not a.flags.writeable)
 3483:         assert_(not a.flags.owndata)
 3484: 
 3485:         a = np.diagonal(np.eye(3))
 3486:         assert_(not a.flags.writeable)
 3487:         assert_(not a.flags.owndata)
 3488: 
 3489:         a = np.diag(np.eye(3))
 3490:         assert_(not a.flags.writeable)
 3491:         assert_(not a.flags.owndata)
 3492: 
 3493:     def test_diagonal_memleak(self):
 3494:         # Regression test for a bug that crept in at one point
 3495:         a = np.zeros((100, 100))
 3496:         if HAS_REFCOUNT:
 3497:             assert_(sys.getrefcount(a) < 50)
 3498:         for i in range(100):
 3499:             a.diagonal()
 3500:         if HAS_REFCOUNT:
 3501:             assert_(sys.getrefcount(a) < 50)
 3502: 
 3503:     def test_size_zero_memleak(self):
 3504:         # Regression test for issue 9615
 3505:         # Exercises a special-case code path for dot products of length
 3506:         # zero in cblasfuncs (making it is specific to floating dtypes).
 3507:         a = np.array([], dtype=np.float64)
 3508:         x = np.array(2.0)
 3509:         for _ in range(100):
 3510:             np.dot(a, a, out=x)
 3511:         if HAS_REFCOUNT:
 3512:             assert_(sys.getrefcount(x) < 50)
 3513: 
 3514:     def test_trace(self):
 3515:         a = np.arange(12).reshape((3, 4))
 3516:         assert_equal(a.trace(), 15)
 3517:         assert_equal(a.trace(0), 15)
 3518:         assert_equal(a.trace(1), 18)
 3519:         assert_equal(a.trace(-1), 13)
 3520: 
 3521:         b = np.arange(8).reshape((2, 2, 2))
 3522:         assert_equal(b.trace(), [6, 8])
 3523:         assert_equal(b.trace(0), [6, 8])
 3524:         assert_equal(b.trace(1), [2, 3])
 3525:         assert_equal(b.trace(-1), [4, 5])
 3526:         assert_equal(b.trace(0, 0, 1), [6, 8])
 3527:         assert_equal(b.trace(0, 0, 2), [5, 9])
 3528:         assert_equal(b.trace(0, 1, 2), [3, 11])
 3529:         assert_equal(b.trace(offset=1, axis1=0, axis2=2), [1, 3])
 3530: 
 3531:         out = np.array(1)
 3532:         ret = a.trace(out=out)
 3533:         assert ret is out
 3534: 
 3535:     def test_trace_subclass(self):
 3536:         # The class would need to overwrite trace to ensure single-element
 3537:         # output also has the right subclass.
 3538:         class MyArray(np.ndarray):
 3539:             pass
 3540: 
 3541:         b = np.arange(8).reshape((2, 2, 2)).view(MyArray)
 3542:         t = b.trace()
 3543:         assert_(isinstance(t, MyArray))
 3544: 
 3545:     def test_put(self):
 3546:         icodes = np.typecodes['AllInteger']
 3547:         fcodes = np.typecodes['AllFloat']
 3548:         for dt in icodes + fcodes + 'O':
 3549:             tgt = np.array([0, 1, 0, 3, 0, 5], dtype=dt)
 3550: 
 3551:             # test 1-d
 3552:             a = np.zeros(6, dtype=dt)
 3553:             a.put([1, 3, 5], [1, 3, 5])
 3554:             assert_equal(a, tgt)
 3555: 
 3556:             # test 2-d
 3557:             a = np.zeros((2, 3), dtype=dt)
 3558:             a.put([1, 3, 5], [1, 3, 5])
 3559:             assert_equal(a, tgt.reshape(2, 3))
 3560: 
 3561:         for dt in '?':
 3562:             tgt = np.array([False, True, False, True, False, True], dtype=dt)
 3563: 
 3564:             # test 1-d
 3565:             a = np.zeros(6, dtype=dt)
 3566:             a.put([1, 3, 5], [True] * 3)
 3567:             assert_equal(a, tgt)
 3568: 
 3569:             # test 2-d
 3570:             a = np.zeros((2, 3), dtype=dt)
 3571:             a.put([1, 3, 5], [True] * 3)
 3572:             assert_equal(a, tgt.reshape(2, 3))
 3573: 
 3574:         # check must be writeable
 3575:         a = np.zeros(6)
 3576:         a.flags.writeable = False
 3577:         assert_raises(ValueError, a.put, [1, 3, 5], [1, 3, 5])
 3578: 
 3579:         # when calling np.put, make sure a
 3580:         # TypeError is raised if the object
 3581:         # isn't an ndarray
 3582:         bad_array = [1, 2, 3]
 3583:         assert_raises(TypeError, np.put, bad_array, [0, 2], 5)
 3584: 
 3585:         # when calling np.put, make sure an
 3586:         # IndexError is raised if the
 3587:         # array is empty
 3588:         empty_array = np.asarray([])
 3589:         with pytest.raises(IndexError,
 3590:                             match="cannot replace elements of an empty array"):
 3591:             np.put(empty_array, 1, 1, mode="wrap")
 3592:         with pytest.raises(IndexError,
 3593:                             match="cannot replace elements of an empty array"):
 3594:             np.put(empty_array, 1, 1, mode="clip")
 3595: 
 3596:     def test_ravel(self):
 3597:         a = np.array([[0, 1], [2, 3]])
 3598:         assert_equal(a.ravel(), [0, 1, 2, 3])
 3599:         assert_(not a.ravel().flags.owndata)
 3600:         assert_equal(a.ravel('F'), [0, 2, 1, 3])
 3601:         assert_equal(a.ravel(order='C'), [0, 1, 2, 3])
 3602:         assert_equal(a.ravel(order='F'), [0, 2, 1, 3])
 3603:         assert_equal(a.ravel(order='A'), [0, 1, 2, 3])
 3604:         assert_(not a.ravel(order='A').flags.owndata)
 3605:         assert_equal(a.ravel(order='K'), [0, 1, 2, 3])
 3606:         assert_(not a.ravel(order='K').flags.owndata)
 3607:         assert_equal(a.ravel(), a.reshape(-1))
 3608: 
 3609:         a = np.array([[0, 1], [2, 3]], order='F')
 3610:         assert_equal(a.ravel(), [0, 1, 2, 3])
 3611:         assert_equal(a.ravel(order='A'), [0, 2, 1, 3])
 3612:         assert_equal(a.ravel(order='K'), [0, 2, 1, 3])
 3613:         assert_(not a.ravel(order='A').flags.owndata)
 3614:         assert_(not a.ravel(order='K').flags.owndata)
 3615:         assert_equal(a.ravel(), a.reshape(-1))
 3616:         assert_equal(a.ravel(order='A'), a.reshape(-1, order='A'))
 3617: 
 3618:         a = np.array([[0, 1], [2, 3]])[::-1, :]
 3619:         assert_equal(a.ravel(), [2, 3, 0, 1])
 3620:         assert_equal(a.ravel(order='C'), [2, 3, 0, 1])
 3621:         assert_equal(a.ravel(order='F'), [2, 0, 3, 1])
 3622:         assert_equal(a.ravel(order='A'), [2, 3, 0, 1])
 3623:         # 'K' doesn't reverse the axes of negative strides
 3624:         assert_equal(a.ravel(order='K'), [2, 3, 0, 1])
 3625:         assert_(a.ravel(order='K').flags.owndata)
 3626: 
 3627:         # Test simple 1-d copy behaviour:
 3628:         a = np.arange(10)[::2]
 3629:         assert_(a.ravel('K').flags.owndata)
 3630:         assert_(a.ravel('C').flags.owndata)
 3631:         assert_(a.ravel('F').flags.owndata)
 3632: 
 3633:         # Not contiguous and 1-sized axis with non matching stride
 3634:         a = np.arange(2**3 * 2)[::2]
 3635:         a = a.reshape(2, 1, 2, 2).swapaxes(-1, -2)
 3636:         strides = list(a.strides)
 3637:         strides[1] = 123
 3638:         a.strides = strides
 3639:         assert_(a.ravel(order='K').flags.owndata)
 3640:         assert_equal(a.ravel('K'), np.arange(0, 15, 2))
 3641: 
 3642:         # contiguous and 1-sized axis with non matching stride works:
 3643:         a = np.arange(2**3)
 3644:         a = a.reshape(2, 1, 2, 2).swapaxes(-1, -2)
 3645:         strides = list(a.strides)
 3646:         strides[1] = 123
 3647:         a.strides = strides
 3648:         assert_(np.may_share_memory(a.ravel(order='K'), a))
 3649:         assert_equal(a.ravel(order='K'), np.arange(2**3))
 3650: 
 3651:         # Test negative strides (not very interesting since non-contiguous):
 3652:         a = np.arange(4)[::-1].reshape(2, 2)
 3653:         assert_(a.ravel(order='C').flags.owndata)
 3654:         assert_(a.ravel(order='K').flags.owndata)
 3655:         assert_equal(a.ravel('C'), [3, 2, 1, 0])
 3656:         assert_equal(a.ravel('K'), [3, 2, 1, 0])
 3657: 
 3658:         # 1-element tidy strides test:
 3659:         a = np.array([[1]])
 3660:         a.strides = (123, 432)
 3661:         if np.ones(1).strides == (8,):
 3662:             assert_(np.may_share_memory(a.ravel('K'), a))
 3663:             assert_equal(a.ravel('K').strides, (a.dtype.itemsize,))
 3664: 
 3665:         for order in ('C', 'F', 'A', 'K'):
 3666:             # 0-d corner case:
 3667:             a = np.array(0)
 3668:             assert_equal(a.ravel(order), [0])
 3669:             assert_(np.may_share_memory(a.ravel(order), a))
 3670: 
 3671:         # Test that certain non-inplace ravels work right (mostly) for 'K':
 3672:         b = np.arange(2**4 * 2)[::2].reshape(2, 2, 2, 2)
 3673:         a = b[..., ::2]
 3674:         assert_equal(a.ravel('K'), [0, 4, 8, 12, 16, 20, 24, 28])
 3675:         assert_equal(a.ravel('C'), [0, 4, 8, 12, 16, 20, 24, 28])
 3676:         assert_equal(a.ravel('A'), [0, 4, 8, 12, 16, 20, 24, 28])
 3677:         assert_equal(a.ravel('F'), [0, 16, 8, 24, 4, 20, 12, 28])
 3678: 
 3679:         a = b[::2, ...]
 3680:         assert_equal(a.ravel('K'), [0, 2, 4, 6, 8, 10, 12, 14])
 3681:         assert_equal(a.ravel('C'), [0, 2, 4, 6, 8, 10, 12, 14])
 3682:         assert_equal(a.ravel('A'), [0, 2, 4, 6, 8, 10, 12, 14])
 3683:         assert_equal(a.ravel('F'), [0, 8, 4, 12, 2, 10, 6, 14])
 3684: 
 3685:     def test_ravel_subclass(self):
 3686:         class ArraySubclass(np.ndarray):
 3687:             pass
 3688: 
 3689:         a = np.arange(10).view(ArraySubclass)
 3690:         assert_(isinstance(a.ravel('C'), ArraySubclass))
 3691:         assert_(isinstance(a.ravel('F'), ArraySubclass))
 3692:         assert_(isinstance(a.ravel('A'), ArraySubclass))
 3693:         assert_(isinstance(a.ravel('K'), ArraySubclass))
 3694: 
 3695:         a = np.arange(10)[::2].view(ArraySubclass)
 3696:         assert_(isinstance(a.ravel('C'), ArraySubclass))
 3697:         assert_(isinstance(a.ravel('F'), ArraySubclass))
 3698:         assert_(isinstance(a.ravel('A'), ArraySubclass))
 3699:         assert_(isinstance(a.ravel('K'), ArraySubclass))
 3700: 
 3701:     def test_swapaxes(self):
 3702:         a = np.arange(1 * 2 * 3 * 4).reshape(1, 2, 3, 4).copy()
 3703:         idx = np.indices(a.shape)
 3704:         assert_(a.flags['OWNDATA'])
 3705:         b = a.copy()
 3706:         # check exceptions
 3707:         assert_raises(AxisError, a.swapaxes, -5, 0)
 3708:         assert_raises(AxisError, a.swapaxes, 4, 0)
 3709:         assert_raises(AxisError, a.swapaxes, 0, -5)
 3710:         assert_raises(AxisError, a.swapaxes, 0, 4)
 3711: 
 3712:         for i in range(-4, 4):
 3713:             for j in range(-4, 4):
 3714:                 for k, src in enumerate((a, b)):
 3715:                     c = src.swapaxes(i, j)
 3716:                     # check shape
 3717:                     shape = list(src.shape)
 3718:                     shape[i] = src.shape[j]
 3719:                     shape[j] = src.shape[i]
 3720:                     assert_equal(c.shape, shape, str((i, j, k)))
 3721:                     # check array contents
 3722:                     i0, i1, i2, i3 = [dim - 1 for dim in c.shape]
 3723:                     j0, j1, j2, j3 = [dim - 1 for dim in src.shape]
 3724:                     assert_equal(src[idx[j0], idx[j1], idx[j2], idx[j3]],
 3725:                                  c[idx[i0], idx[i1], idx[i2], idx[i3]],
 3726:                                  str((i, j, k)))
 3727:                     # check a view is always returned, gh-5260
 3728:                     assert_(not c.flags['OWNDATA'], str((i, j, k)))
 3729:                     # check on non-contiguous input array
 3730:                     if k == 1:
 3731:                         b = c
 3732: 
 3733:     def test_conjugate(self):
 3734:         a = np.array([1 - 1j, 1 + 1j, 23 + 23.0j])
 3735:         ac = a.conj()
 3736:         assert_equal(a.real, ac.real)
 3737:         assert_equal(a.imag, -ac.imag)
 3738:         assert_equal(ac, a.conjugate())
 3739:         assert_equal(ac, np.conjugate(a))
 3740: 
 3741:         a = np.array([1 - 1j, 1 + 1j, 23 + 23.0j], 'F')
 3742:         ac = a.conj()
 3743:         assert_equal(a.real, ac.real)
 3744:         assert_equal(a.imag, -ac.imag)
 3745:         assert_equal(ac, a.conjugate())
 3746:         assert_equal(ac, np.conjugate(a))
 3747: 
 3748:         a = np.array([1, 2, 3])
 3749:         ac = a.conj()
 3750:         assert_equal(a, ac)
 3751:         assert_equal(ac, a.conjugate())
 3752:         assert_equal(ac, np.conjugate(a))
 3753: 
 3754:         a = np.array([1.0, 2.0, 3.0])
 3755:         ac = a.conj()
 3756:         assert_equal(a, ac)
 3757:         assert_equal(ac, a.conjugate())
 3758:         assert_equal(ac, np.conjugate(a))
 3759: 
 3760:         a = np.array([1 - 1j, 1 + 1j, 1, 2.0], object)
 3761:         ac = a.conj()
 3762:         assert_equal(ac, [k.conjugate() for k in a])
 3763:         assert_equal(ac, a.conjugate())
 3764:         assert_equal(ac, np.conjugate(a))
 3765: 
 3766:         a = np.array([1 - 1j, 1, 2.0, 'f'], object)
 3767:         assert_raises(TypeError, a.conj)
 3768:         assert_raises(TypeError, a.conjugate)
 3769: 
 3770:     def test_conjugate_out(self):
 3771:         # Minimal test for the out argument being passed on correctly
 3772:         # NOTE: The ability to pass `out` is currently undocumented!
 3773:         a = np.array([1 - 1j, 1 + 1j, 23 + 23.0j])
 3774:         out = np.empty_like(a)
 3775:         res = a.conjugate(out)
 3776:         assert res is out
 3777:         assert_array_equal(out, a.conjugate())
 3778: 
 3779:     def test_conjugate_scalar(self):
 3780:         for v in 5, 5j:
 3781:             a = np.array(v)
 3782:             assert a.conjugate() == v.conjugate()
 3783:         for a in (np.array('s'), np.array('2016', 'M'),
 3784:                 np.array((1, 2), [('a', int), ('b', int)])):
 3785:             with pytest.raises(TypeError):
 3786:                 a.conjugate()
 3787: 
 3788:     def test__complex__(self):
 3789:         dtypes = ['i1', 'i2', 'i4', 'i8',
 3790:                   'u1', 'u2', 'u4', 'u8',
 3791:                   'f', 'd', 'g', 'F', 'D', 'G',
 3792:                   '?', 'O']
 3793:         for dt in dtypes:
 3794:             a = np.array(7, dtype=dt)
 3795:             b = np.array([7], dtype=dt)
 3796:             c = np.array([[[[[7]]]]], dtype=dt)
 3797: 
 3798:             msg = f'dtype: {dt}'
 3799:             ap = complex(a)
 3800:             assert_equal(ap, a, msg)
 3801: 
 3802:             with assert_warns(DeprecationWarning):
 3803:                 bp = complex(b)
 3804:             assert_equal(bp, b, msg)
 3805: 
 3806:             with assert_warns(DeprecationWarning):
 3807:                 cp = complex(c)
 3808:             assert_equal(cp, c, msg)
 3809: 
 3810:     def test__complex__should_not_work(self):
 3811:         dtypes = ['i1', 'i2', 'i4', 'i8',
 3812:                   'u1', 'u2', 'u4', 'u8',
 3813:                   'f', 'd', 'g', 'F', 'D', 'G',
 3814:                   '?', 'O']
 3815:         for dt in dtypes:
 3816:             a = np.array([1, 2, 3], dtype=dt)
 3817:             assert_raises(TypeError, complex, a)
 3818: 
 3819:         dt = np.dtype([('a', 'f8'), ('b', 'i1')])
 3820:         b = np.array((1.0, 3), dtype=dt)
 3821:         assert_raises(TypeError, complex, b)
 3822: 
 3823:         c = np.array([(1.0, 3), (2e-3, 7)], dtype=dt)
 3824:         assert_raises(TypeError, complex, c)
 3825: 
 3826:         d = np.array('1+1j')
 3827:         assert_raises(TypeError, complex, d)
 3828: 
 3829:         e = np.array(['1+1j'], 'U')
 3830:         with assert_warns(DeprecationWarning):
 3831:             assert_raises(TypeError, complex, e)
 3832: 
 3833: class TestCequenceMethods:
 3834:     def test_array_contains(self):
 3835:         assert_(4.0 in np.arange(16.).reshape(4, 4))
 3836:         assert_(20.0 not in np.arange(16.).reshape(4, 4))
 3837: 
 3838: class TestBinop:
 3839:     def test_inplace(self):
 3840:         # test refcount 1 inplace conversion
 3841:         assert_array_almost_equal(np.array([0.5]) * np.array([1.0, 2.0]),
 3842:                                   [0.5, 1.0])
 3843: 
 3844:         d = np.array([0.5, 0.5])[::2]
 3845:         assert_array_almost_equal(d * (d * np.array([1.0, 2.0])),
 3846:                                   [0.25, 0.5])
 3847: 
 3848:         a = np.array([0.5])
 3849:         b = np.array([0.5])
 3850:         c = a + b
 3851:         c = a - b
 3852:         c = a * b
 3853:         c = a / b
 3854:         assert_equal(a, b)
 3855:         assert_almost_equal(c, 1.)
 3856: 
 3857:         c = a + b * 2. / b * a - a / b
 3858:         assert_equal(a, b)
 3859:         assert_equal(c, 0.5)
 3860: 
 3861:         # true divide
 3862:         a = np.array([5])
 3863:         b = np.array([3])
 3864:         c = (a * a) / b
 3865: 
 3866:         assert_almost_equal(c, 25 / 3)
 3867:         assert_equal(a, 5)
 3868:         assert_equal(b, 3)
 3869: 
 3870:     # ndarray.__rop__ always calls ufunc
 3871:     # ndarray.__iop__ always calls ufunc
 3872:     # ndarray.__op__, __rop__:
 3873:     #   - defer if other has __array_ufunc__ and it is None
 3874:     #           or other is not a subclass and has higher array priority
 3875:     #   - else, call ufunc
 3876:     @pytest.mark.xfail(IS_PYPY, reason="Bug in pypy3.{9, 10}-v7.3.13, #24862")
 3877:     def test_ufunc_binop_interaction(self):
 3878:         # Python method name (without underscores)
 3879:         #   -> (numpy ufunc, has_in_place_version, preferred_dtype)
 3880:         ops = {
 3881:             'add':      (np.add, True, float),
 3882:             'sub':      (np.subtract, True, float),
 3883:             'mul':      (np.multiply, True, float),
 3884:             'truediv':  (np.true_divide, True, float),
 3885:             'floordiv': (np.floor_divide, True, float),
 3886:             'mod':      (np.remainder, True, float),
 3887:             'divmod':   (np.divmod, False, float),
 3888:             'pow':      (np.power, True, int),
 3889:             'lshift':   (np.left_shift, True, int),
 3890:             'rshift':   (np.right_shift, True, int),
 3891:             'and':      (np.bitwise_and, True, int),
 3892:             'xor':      (np.bitwise_xor, True, int),
 3893:             'or':       (np.bitwise_or, True, int),
 3894:             'matmul':   (np.matmul, True, float),
 3895:             # 'ge':       (np.less_equal, False),
 3896:             # 'gt':       (np.less, False),
 3897:             # 'le':       (np.greater_equal, False),
 3898:             # 'lt':       (np.greater, False),
 3899:             # 'eq':       (np.equal, False),
 3900:             # 'ne':       (np.not_equal, False),
 3901:         }
 3902: 
 3903:         class Coerced(Exception):
 3904:             pass
 3905: 
 3906:         def array_impl(self):
 3907:             raise Coerced
 3908: 
 3909:         def op_impl(self, other):
 3910:             return "forward"
 3911: 
 3912:         def rop_impl(self, other):
 3913:             return "reverse"
 3914: 
 3915:         def iop_impl(self, other):
 3916:             return "in-place"
 3917: 
 3918:         def array_ufunc_impl(self, ufunc, method, *args, **kwargs):
 3919:             return ("__array_ufunc__", ufunc, method, args, kwargs)
 3920: 
 3921:         # Create an object with the given base, in the given module, with a
 3922:         # bunch of placeholder __op__ methods, and optionally a
 3923:         # __array_ufunc__ and __array_priority__.
 3924:         def make_obj(base, array_priority=False, array_ufunc=False,
 3925:                      alleged_module="__main__"):
 3926:             class_namespace = {"__array__": array_impl}
 3927:             if array_priority is not False:
 3928:                 class_namespace["__array_priority__"] = array_priority
 3929:             for op in ops:
 3930:                 class_namespace[f"__{op}__"] = op_impl
 3931:                 class_namespace[f"__r{op}__"] = rop_impl
 3932:                 class_namespace[f"__i{op}__"] = iop_impl
 3933:             if array_ufunc is not False:
 3934:                 class_namespace["__array_ufunc__"] = array_ufunc
 3935:             eval_namespace = {"base": base,
 3936:                               "class_namespace": class_namespace,
 3937:                               "__name__": alleged_module,
 3938:                               }
 3939:             MyType = eval("type('MyType', (base,), class_namespace)",
 3940:                           eval_namespace)
 3941:             if issubclass(MyType, np.ndarray):
 3942:                 # Use this range to avoid special case weirdnesses around
 3943:                 # divide-by-0, pow(x, 2), overflow due to pow(big, big), etc.
 3944:                 return np.arange(3, 7).reshape(2, 2).view(MyType)
 3945:             else:
 3946:                 return MyType()
 3947: 
 3948:         def check(obj, binop_override_expected, ufunc_override_expected,
 3949:                   inplace_override_expected, check_scalar=True):
 3950:             for op, (ufunc, has_inplace, dtype) in ops.items():
 3951:                 err_msg = ('op: %s, ufunc: %s, has_inplace: %s, dtype: %s'
 3952:                            % (op, ufunc, has_inplace, dtype))
 3953:                 check_objs = [np.arange(3, 7, dtype=dtype).reshape(2, 2)]
 3954:                 if check_scalar:
 3955:                     check_objs.append(check_objs[0][0])
 3956:                 for arr in check_objs:
 3957:                     arr_method = getattr(arr, f"__{op}__")
 3958: 
 3959:                     def first_out_arg(result):
 3960:                         if op == "divmod":
 3961:                             assert_(isinstance(result, tuple))
 3962:                             return result[0]
 3963:                         else:
 3964:                             return result
 3965: 
 3966:                     # arr __op__ obj
 3967:                     if binop_override_expected:
 3968:                         assert_equal(arr_method(obj), NotImplemented, err_msg)
 3969:                     elif ufunc_override_expected:
 3970:                         assert_equal(arr_method(obj)[0], "__array_ufunc__",
 3971:                                      err_msg)
 3972:                     elif (isinstance(obj, np.ndarray) and
 3973:                         (type(obj).__array_ufunc__ is
 3974:                          np.ndarray.__array_ufunc__)):
 3975:                         # __array__ gets ignored
 3976:                         res = first_out_arg(arr_method(obj))
 3977:                         assert_(res.__class__ is obj.__class__, err_msg)
 3978:                     else:
 3979:                         assert_raises((TypeError, Coerced),
 3980:                                       arr_method, obj, err_msg=err_msg)
 3981:                     # obj __op__ arr
 3982:                     arr_rmethod = getattr(arr, f"__r{op}__")
 3983:                     if ufunc_override_expected:
 3984:                         res = arr_rmethod(obj)
 3985:                         assert_equal(res[0], "__array_ufunc__",
 3986:                                      err_msg=err_msg)
 3987:                         assert_equal(res[1], ufunc, err_msg=err_msg)
 3988:                     elif (isinstance(obj, np.ndarray) and
 3989:                             (type(obj).__array_ufunc__ is
 3990:                              np.ndarray.__array_ufunc__)):
 3991:                         # __array__ gets ignored
 3992:                         res = first_out_arg(arr_rmethod(obj))
 3993:                         assert_(res.__class__ is obj.__class__, err_msg)
 3994:                     else:
 3995:                         # __array_ufunc__ = "asdf" creates a TypeError
 3996:                         assert_raises((TypeError, Coerced),
 3997:                                       arr_rmethod, obj, err_msg=err_msg)
 3998: 
 3999:                     # arr __iop__ obj
 4000:                     # array scalars don't have in-place operators
 4001:                     if has_inplace and isinstance(arr, np.ndarray):
 4002:                         arr_imethod = getattr(arr, f"__i{op}__")
 4003:                         if inplace_override_expected:
 4004:                             assert_equal(arr_method(obj), NotImplemented,
 4005:                                          err_msg=err_msg)
 4006:                         elif ufunc_override_expected:
 4007:                             res = arr_imethod(obj)
 4008:                             assert_equal(res[0], "__array_ufunc__", err_msg)
 4009:                             assert_equal(res[1], ufunc, err_msg)
 4010:                             assert_(type(res[-1]["out"]) is tuple, err_msg)
 4011:                             assert_(res[-1]["out"][0] is arr, err_msg)
 4012:                         elif (isinstance(obj, np.ndarray) and
 4013:                                 (type(obj).__array_ufunc__ is
 4014:                                 np.ndarray.__array_ufunc__)):
 4015:                             # __array__ gets ignored
 4016:                             assert_(arr_imethod(obj) is arr, err_msg)
 4017:                         else:
 4018:                             assert_raises((TypeError, Coerced),
 4019:                                           arr_imethod, obj,
 4020:                                           err_msg=err_msg)
 4021: 
 4022:                     op_fn = getattr(operator, op, None)
 4023:                     if op_fn is None:
 4024:                         op_fn = getattr(operator, op + "_", None)
 4025:                     if op_fn is None:
 4026:                         op_fn = getattr(builtins, op)
 4027:                     assert_equal(op_fn(obj, arr), "forward", err_msg)
 4028:                     if not isinstance(obj, np.ndarray):
 4029:                         if binop_override_expected:
 4030:                             assert_equal(op_fn(arr, obj), "reverse", err_msg)
 4031:                         elif ufunc_override_expected:
 4032:                             assert_equal(op_fn(arr, obj)[0], "__array_ufunc__",
 4033:                                          err_msg)
 4034:                     if ufunc_override_expected:
 4035:                         assert_equal(ufunc(obj, arr)[0], "__array_ufunc__",
 4036:                                      err_msg)
 4037: 
 4038:         # No array priority, no array_ufunc -> nothing called
 4039:         check(make_obj(object), False, False, False)
 4040:         # Negative array priority, no array_ufunc -> nothing called
 4041:         # (has to be very negative, because scalar priority is -1000000.0)
 4042:         check(make_obj(object, array_priority=-2**30), False, False, False)
 4043:         # Positive array priority, no array_ufunc -> binops and iops only
 4044:         check(make_obj(object, array_priority=1), True, False, True)
 4045:         # ndarray ignores array_priority for ndarray subclasses
 4046:         check(make_obj(np.ndarray, array_priority=1), False, False, False,
 4047:               check_scalar=False)
 4048:         # Positive array_priority and array_ufunc -> array_ufunc only
 4049:         check(make_obj(object, array_priority=1,
 4050:                        array_ufunc=array_ufunc_impl), False, True, False)
 4051:         check(make_obj(np.ndarray, array_priority=1,
 4052:                        array_ufunc=array_ufunc_impl), False, True, False)
 4053:         # array_ufunc set to None -> defer binops only
 4054:         check(make_obj(object, array_ufunc=None), True, False, False)
 4055:         check(make_obj(np.ndarray, array_ufunc=None), True, False, False,
 4056:               check_scalar=False)
 4057: 
 4058:     @pytest.mark.parametrize("priority", [None, "runtime error"])
 4059:     def test_ufunc_binop_bad_array_priority(self, priority):
 4060:         # Mainly checks that this does not crash.  The second array has a lower
 4061:         # priority than -1 ("error value").  If the __radd__ actually exists,
 4062:         # bad things can happen (I think via the scalar paths).
 4063:         # In principle both of these can probably just be errors in the future.
 4064:         class BadPriority:
 4065:             @property
 4066:             def __array_priority__(self):
 4067:                 if priority == "runtime error":
 4068:                     raise RuntimeError("RuntimeError in __array_priority__!")
 4069:                 return priority
 4070: 
 4071:             def __radd__(self, other):
 4072:                 return "result"
 4073: 
 4074:         class LowPriority(np.ndarray):
 4075:             __array_priority__ = -1000
 4076: 
 4077:         # Priority failure uses the same as scalars (smaller -1000).  So the
 4078:         # LowPriority wins with 'result' for each element (inner operation).
 4079:         res = np.arange(3).view(LowPriority) + BadPriority()
 4080:         assert res.shape == (3,)
 4081:         assert res[0] == 'result'
 4082: 
 4083:     @pytest.mark.parametrize("scalar", [
 4084:             np.longdouble(1), np.timedelta64(120, 'm')])
 4085:     @pytest.mark.parametrize("op", [operator.add, operator.xor])
 4086:     def test_scalar_binop_guarantees_ufunc(self, scalar, op):
 4087:         # Test that __array_ufunc__ will always cause ufunc use even when
 4088:         # we have to protect some other calls from recursing (see gh-26904).
 4089:         class SomeClass:
 4090:             def __array_ufunc__(self, ufunc, method, *inputs, **kw):
 4091:                 return "result"
 4092: 
 4093:         assert SomeClass() + scalar == "result"
 4094:         assert scalar + SomeClass() == "result"
 4095: 
 4096:     def test_ufunc_override_normalize_signature(self):
 4097:         # gh-5674
 4098:         class SomeClass:
 4099:             def __array_ufunc__(self, ufunc, method, *inputs, **kw):
 4100:                 return kw
 4101: 
 4102:         a = SomeClass()
 4103:         kw = np.add(a, [1])
 4104:         assert_('sig' not in kw and 'signature' not in kw)
 4105:         kw = np.add(a, [1], sig='ii->i')
 4106:         assert_('sig' not in kw and 'signature' in kw)
 4107:         assert_equal(kw['signature'], 'ii->i')
 4108:         kw = np.add(a, [1], signature='ii->i')
 4109:         assert_('sig' not in kw and 'signature' in kw)
 4110:         assert_equal(kw['signature'], 'ii->i')
 4111: 
 4112:     def test_array_ufunc_index(self):
 4113:         # Check that index is set appropriately, also if only an output
 4114:         # is passed on (latter is another regression tests for github bug 4753)
 4115:         # This also checks implicitly that 'out' is always a tuple.
 4116:         class CheckIndex:
 4117:             def __array_ufunc__(self, ufunc, method, *inputs, **kw):
 4118:                 for i, a in enumerate(inputs):
 4119:                     if a is self:
 4120:                         return i
 4121:                 # calls below mean we must be in an output.
 4122:                 for j, a in enumerate(kw['out']):
 4123:                     if a is self:
 4124:                         return (j,)
 4125: 
 4126:         a = CheckIndex()
 4127:         dummy = np.arange(2.)
 4128:         # 1 input, 1 output
 4129:         assert_equal(np.sin(a), 0)
 4130:         assert_equal(np.sin(dummy, a), (0,))
 4131:         assert_equal(np.sin(dummy, out=a), (0,))
 4132:         assert_equal(np.sin(dummy, out=(a,)), (0,))
 4133:         assert_equal(np.sin(a, a), 0)
 4134:         assert_equal(np.sin(a, out=a), 0)
 4135:         assert_equal(np.sin(a, out=(a,)), 0)
 4136:         # 1 input, 2 outputs
 4137:         assert_equal(np.modf(dummy, a), (0,))
 4138:         assert_equal(np.modf(dummy, None, a), (1,))
 4139:         assert_equal(np.modf(dummy, dummy, a), (1,))
 4140:         assert_equal(np.modf(dummy, out=(a, None)), (0,))
 4141:         assert_equal(np.modf(dummy, out=(a, dummy)), (0,))
 4142:         assert_equal(np.modf(dummy, out=(None, a)), (1,))
 4143:         assert_equal(np.modf(dummy, out=(dummy, a)), (1,))
 4144:         assert_equal(np.modf(a, out=(dummy, a)), 0)
 4145:         with assert_raises(TypeError):
 4146:             # Out argument must be tuple, since there are multiple outputs
 4147:             np.modf(dummy, out=a)
 4148: 
 4149:         assert_raises(ValueError, np.modf, dummy, out=(a,))
 4150: 
 4151:         # 2 inputs, 1 output
 4152:         assert_equal(np.add(a, dummy), 0)
 4153:         assert_equal(np.add(dummy, a), 1)
 4154:         assert_equal(np.add(dummy, dummy, a), (0,))
 4155:         assert_equal(np.add(dummy, a, a), 1)
 4156:         assert_equal(np.add(dummy, dummy, out=a), (0,))
 4157:         assert_equal(np.add(dummy, dummy, out=(a,)), (0,))
 4158:         assert_equal(np.add(a, dummy, out=a), 0)
 4159: 
 4160:     def test_out_override(self):
 4161:         # regression test for github bug 4753
 4162:         class OutClass(np.ndarray):
 4163:             def __array_ufunc__(self, ufunc, method, *inputs, **kw):
 4164:                 if 'out' in kw:
 4165:                     tmp_kw = kw.copy()
 4166:                     tmp_kw.pop('out')
 4167:                     func = getattr(ufunc, method)
 4168:                     kw['out'][0][...] = func(*inputs, **tmp_kw)
 4169: 
 4170:         A = np.array([0]).view(OutClass)
 4171:         B = np.array([5])
 4172:         C = np.array([6])
 4173:         np.multiply(C, B, A)
 4174:         assert_equal(A[0], 30)
 4175:         assert_(isinstance(A, OutClass))
 4176:         A[0] = 0
 4177:         np.multiply(C, B, out=A)
 4178:         assert_equal(A[0], 30)
 4179:         assert_(isinstance(A, OutClass))
 4180: 
 4181:     def test_pow_array_object_dtype(self):
 4182:         # test pow on arrays of object dtype
 4183:         class SomeClass:
 4184:             def __init__(self, num=None):
 4185:                 self.num = num
 4186: 
 4187:             # want to ensure a fast pow path is not taken
 4188:             def __mul__(self, other):
 4189:                 raise AssertionError('__mul__ should not be called')
 4190: 
 4191:             def __truediv__(self, other):
 4192:                 raise AssertionError('__truediv__ should not be called')
 4193: 
 4194:             def __pow__(self, exp):
 4195:                 return SomeClass(num=self.num ** exp)
 4196: 
 4197:             def __eq__(self, other):
 4198:                 if isinstance(other, SomeClass):
 4199:                     return self.num == other.num
 4200: 
 4201:             __rpow__ = __pow__
 4202: 
 4203:         def pow_for(exp, arr):
 4204:             return np.array([x ** exp for x in arr])
 4205: 
 4206:         obj_arr = np.array([SomeClass(1), SomeClass(2), SomeClass(3)])
 4207: 
 4208:         assert_equal(obj_arr ** 0.5, pow_for(0.5, obj_arr))
 4209:         assert_equal(obj_arr ** 0, pow_for(0, obj_arr))
 4210:         assert_equal(obj_arr ** 1, pow_for(1, obj_arr))
 4211:         assert_equal(obj_arr ** -1, pow_for(-1, obj_arr))
 4212:         assert_equal(obj_arr ** 2, pow_for(2, obj_arr))
 4213: 
 4214:     def test_pow_calls_square_structured_dtype(self):
 4215:         # gh-29388
 4216:         dt = np.dtype([('a', 'i4'), ('b', 'i4')])
 4217:         a = np.array([(1, 2), (3, 4)], dtype=dt)
 4218:         with pytest.raises(TypeError, match="ufunc 'square' not supported"):
 4219:             a ** 2
 4220: 
 4221:     def test_pos_array_ufunc_override(self):
 4222:         class A(np.ndarray):
 4223:             def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):
 4224:                 return getattr(ufunc, method)(*[i.view(np.ndarray) for
 4225:                                                 i in inputs], **kwargs)
 4226:         tst = np.array('foo').view(A)
 4227:         with assert_raises(TypeError):
 4228:             +tst
 4229: 
 4230: 
 4231: class TestTemporaryElide:
 4232:     # elision is only triggered on relatively large arrays
 4233: 
 4234:     def test_extension_incref_elide(self):
 4235:         # test extension (e.g. cython) calling PyNumber_* slots without
 4236:         # increasing the reference counts
 4237:         #
 4238:         # def incref_elide(a):
 4239:         #    d = input.copy() # refcount 1
 4240:         #    return d, d + d # PyNumber_Add without increasing refcount
 4241:         from numpy._core._multiarray_tests import incref_elide
 4242:         d = np.ones(100000)
 4243:         orig, res = incref_elide(d)
 4244:         d + d
 4245:         # the return original should not be changed to an inplace operation
 4246:         assert_array_equal(orig, d)
 4247:         assert_array_equal(res, d + d)
 4248: 
 4249:     def test_extension_incref_elide_stack(self):
 4250:         # scanning if the refcount == 1 object is on the python stack to check
 4251:         # that we are called directly from python is flawed as object may still
 4252:         # be above the stack pointer and we have no access to the top of it
 4253:         #
 4254:         # def incref_elide_l(d):
 4255:         #    return l[4] + l[4] # PyNumber_Add without increasing refcount
 4256:         from numpy._core._multiarray_tests import incref_elide_l
 4257:         # padding with 1 makes sure the object on the stack is not overwritten
 4258:         l = [1, 1, 1, 1, np.ones(100000)]
 4259:         res = incref_elide_l(l)
 4260:         # the return original should not be changed to an inplace operation
 4261:         assert_array_equal(l[4], np.ones(100000))
 4262:         assert_array_equal(res, l[4] + l[4])
 4263: 
 4264:     def test_temporary_with_cast(self):
 4265:         # check that we don't elide into a temporary which would need casting
 4266:         d = np.ones(200000, dtype=np.int64)
 4267:         r = ((d + d) + np.array(2**222, dtype='O'))
 4268:         assert_equal(r.dtype, np.dtype('O'))
 4269: 
 4270:         r = ((d + d) / 2)
 4271:         assert_equal(r.dtype, np.dtype('f8'))
 4272: 
 4273:         r = np.true_divide((d + d), 2)
 4274:         assert_equal(r.dtype, np.dtype('f8'))
 4275: 
 4276:         r = ((d + d) / 2.)
 4277:         assert_equal(r.dtype, np.dtype('f8'))
 4278: 
 4279:         r = ((d + d) // 2)
 4280:         assert_equal(r.dtype, np.dtype(np.int64))
 4281: 
 4282:         # commutative elision into the astype result
 4283:         f = np.ones(100000, dtype=np.float32)
 4284:         assert_equal(((f + f) + f.astype(np.float64)).dtype, np.dtype('f8'))
 4285: 
 4286:         # no elision into lower type
 4287:         d = f.astype(np.float64)
 4288:         assert_equal(((f + f) + d).dtype, d.dtype)
 4289:         l = np.ones(100000, dtype=np.longdouble)
 4290:         assert_equal(((d + d) + l).dtype, l.dtype)
 4291: 
 4292:         # test unary abs with different output dtype
 4293:         for dt in (np.complex64, np.complex128, np.clongdouble):
 4294:             c = np.ones(100000, dtype=dt)
 4295:             r = abs(c * 2.0)
 4296:             assert_equal(r.dtype, np.dtype('f%d' % (c.itemsize // 2)))
 4297: 
 4298:     def test_elide_broadcast(self):
 4299:         # test no elision on broadcast to higher dimension
 4300:         # only triggers elision code path in debug mode as triggering it in
 4301:         # normal mode needs 256kb large matching dimension, so a lot of memory
 4302:         d = np.ones((2000, 1), dtype=int)
 4303:         b = np.ones((2000), dtype=bool)
 4304:         r = (1 - d) + b
 4305:         assert_equal(r, 1)
 4306:         assert_equal(r.shape, (2000, 2000))
 4307: 
 4308:     def test_elide_scalar(self):
 4309:         # check inplace op does not create ndarray from scalars
 4310:         a = np.bool()
 4311:         assert_(type(~(a & a)) is np.bool)
 4312: 
 4313:     def test_elide_scalar_readonly(self):
 4314:         # The imaginary part of a real array is readonly. This needs to go
 4315:         # through fast_scalar_power which is only called for powers of
 4316:         # +1, -1, 0, 0.5, and 2, so use 2. Also need valid refcount for
 4317:         # elision which can be gotten for the imaginary part of a real
 4318:         # array. Should not error.
 4319:         a = np.empty(100000, dtype=np.float64)
 4320:         a.imag ** 2
 4321: 
 4322:     def test_elide_readonly(self):
 4323:         # don't try to elide readonly temporaries
 4324:         r = np.asarray(np.broadcast_to(np.zeros(1), 100000).flat) * 0.0
 4325:         assert_equal(r, 0)
 4326: 
 4327:     def test_elide_updateifcopy(self):
 4328:         a = np.ones(2**20)[::2]
 4329:         b = a.flat.__array__() + 1
 4330:         del b
 4331:         assert_equal(a, 1)
 4332: 
 4333: 
 4334: class TestCAPI:
 4335:     def test_IsPythonScalar(self):
 4336:         from numpy._core._multiarray_tests import IsPythonScalar
 4337:         assert_(IsPythonScalar(b'foobar'))
 4338:         assert_(IsPythonScalar(1))
 4339:         assert_(IsPythonScalar(2**80))
 4340:         assert_(IsPythonScalar(2.))
 4341:         assert_(IsPythonScalar("a"))
 4342: 
 4343:     @pytest.mark.parametrize("converter",
 4344:              [_multiarray_tests.run_scalar_intp_converter,
 4345:               _multiarray_tests.run_scalar_intp_from_sequence])
 4346:     def test_intp_sequence_converters(self, converter):
 4347:         # Test simple values (-1 is special for error return paths)
 4348:         assert converter(10) == (10,)
 4349:         assert converter(-1) == (-1,)
 4350:         # A 0-D array looks a bit like a sequence but must take the integer
 4351:         # path:
 4352:         assert converter(np.array(123)) == (123,)
 4353:         # Test simple sequences (intp_from_sequence only supports length 1):
 4354:         assert converter((10,)) == (10,)
 4355:         assert converter(np.array([11])) == (11,)
 4356: 
 4357:     @pytest.mark.parametrize("converter",
 4358:              [_multiarray_tests.run_scalar_intp_converter,
 4359:               _multiarray_tests.run_scalar_intp_from_sequence])
 4360:     @pytest.mark.skipif(IS_PYPY and sys.implementation.version <= (7, 3, 8),
 4361:             reason="PyPy bug in error formatting")
 4362:     def test_intp_sequence_converters_errors(self, converter):
 4363:         with pytest.raises(TypeError,
 4364:                 match="expected a sequence of integers or a single integer, "):
 4365:             converter(object())
 4366:         with pytest.raises(TypeError,
 4367:                 match="expected a sequence of integers or a single integer, "
 4368:                       "got '32.0'"):
 4369:             converter(32.)
 4370:         with pytest.raises(TypeError,
 4371:                 match="'float' object cannot be interpreted as an integer"):
 4372:             converter([32.])
 4373:         with pytest.raises(ValueError,
 4374:                 match="Maximum allowed dimension"):
 4375:             # These converters currently convert overflows to a ValueError
 4376:             converter(2**64)
 4377: 
 4378: 
 4379: class TestSubscripting:
 4380:     def test_test_zero_rank(self):
 4381:         x = np.array([1, 2, 3])
 4382:         assert_(isinstance(x[0], np.int_))
 4383:         assert_(type(x[0, ...]) is np.ndarray)
 4384: 
 4385: 
 4386: class TestPickling:
 4387:     @pytest.mark.skipif(pickle.HIGHEST_PROTOCOL >= 5,
 4388:                         reason=('this tests the error messages when trying to'
 4389:                                 'protocol 5 although it is not available'))
 4390:     def test_correct_protocol5_error_message(self):
 4391:         array = np.arange(10)
 4392: 
 4393:     def test_record_array_with_object_dtype(self):
 4394:         my_object = object()
 4395: 
 4396:         arr_with_object = np.array(
 4397:                 [(my_object, 1, 2.0)],
 4398:                 dtype=[('a', object), ('b', int), ('c', float)])
 4399:         arr_without_object = np.array(
 4400:                 [('xxx', 1, 2.0)],
 4401:                 dtype=[('a', str), ('b', int), ('c', float)])
 4402: 
 4403:         for proto in range(2, pickle.HIGHEST_PROTOCOL + 1):
 4404:             depickled_arr_with_object = pickle.loads(
 4405:                     pickle.dumps(arr_with_object, protocol=proto))
 4406:             depickled_arr_without_object = pickle.loads(
 4407:                     pickle.dumps(arr_without_object, protocol=proto))
 4408: 
 4409:             assert_equal(arr_with_object.dtype,
 4410:                          depickled_arr_with_object.dtype)
 4411:             assert_equal(arr_without_object.dtype,
 4412:                          depickled_arr_without_object.dtype)
 4413: 
 4414:     @pytest.mark.skipif(pickle.HIGHEST_PROTOCOL < 5,
 4415:                         reason="requires pickle protocol 5")
 4416:     def test_f_contiguous_array(self):
 4417:         f_contiguous_array = np.array([[1, 2, 3], [4, 5, 6]], order='F')
 4418:         buffers = []
 4419: 
 4420:         # When using pickle protocol 5, Fortran-contiguous arrays can be
 4421:         # serialized using out-of-band buffers
 4422:         bytes_string = pickle.dumps(f_contiguous_array, protocol=5,
 4423:                                     buffer_callback=buffers.append)
 4424: 
 4425:         assert len(buffers) > 0
 4426: 
 4427:         depickled_f_contiguous_array = pickle.loads(bytes_string,
 4428:                                                     buffers=buffers)
 4429: 
 4430:         assert_equal(f_contiguous_array, depickled_f_contiguous_array)
 4431: 
 4432:     @pytest.mark.skipif(pickle.HIGHEST_PROTOCOL < 5, reason="requires pickle protocol 5")
 4433:     @pytest.mark.parametrize('transposed_contiguous_array',
 4434:         [np.random.default_rng(42).random((2, 3, 4)).transpose((1, 0, 2)),
 4435:          np.random.default_rng(42).random((2, 3, 4, 5)).transpose((1, 3, 0, 2))] +
 4436:         [np.random.default_rng(42).random(np.arange(2, 7)).transpose(np.random.permutation(5)) for _ in range(3)])
 4437:     def test_transposed_contiguous_array(self, transposed_contiguous_array):
 4438:         buffers = []
 4439:         # When using pickle protocol 5, arrays which can be transposed to c_contiguous
 4440:         # can be serialized using out-of-band buffers
 4441:         bytes_string = pickle.dumps(transposed_contiguous_array, protocol=5,
 4442:                                     buffer_callback=buffers.append)
 4443: 
 4444:         assert len(buffers) > 0
 4445: 
 4446:         depickled_transposed_contiguous_array = pickle.loads(bytes_string,
 4447:                                                     buffers=buffers)
 4448: 
 4449:         assert_equal(transposed_contiguous_array, depickled_transposed_contiguous_array)
 4450: 
 4451:     @pytest.mark.skipif(pickle.HIGHEST_PROTOCOL < 5, reason="requires pickle protocol 5")
 4452:     def test_load_legacy_pkl_protocol5(self):
 4453:         # legacy byte strs are dumped in 2.2.1
 4454:         c_contiguous_dumped = b'\x80\x05\x95\x90\x00\x00\x00\x00\x00\x00\x00\x8c\x13numpy._core.numeric\x94\x8c\x0b_frombuffer\x94\x93\x94(\x96\x18\x00\x00\x00\x00\x00\x00\x00\x00\x01\x02\x03\x04\x05\x06\x07\x08\t\n\x0b\x0c\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x94\x8c\x05numpy\x94\x8c\x05dtype\x94\x93\x94\x8c\x02u1\x94\x89\x88\x87\x94R\x94(K\x03\x8c\x01|\x94NNNJ\xff\xff\xff\xffJ\xff\xff\xff\xffK\x00t\x94bK\x03K\x04K\x02\x87\x94\x8c\x01C\x94t\x94R\x94.'  # noqa: E501
 4455:         f_contiguous_dumped = b'\x80\x05\x95\x90\x00\x00\x00\x00\x00\x00\x00\x8c\x13numpy._core.numeric\x94\x8c\x0b_frombuffer\x94\x93\x94(\x96\x18\x00\x00\x00\x00\x00\x00\x00\x00\x01\x02\x03\x04\x05\x06\x07\x08\t\n\x0b\x0c\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x94\x8c\x05numpy\x94\x8c\x05dtype\x94\x93\x94\x8c\x02u1\x94\x89\x88\x87\x94R\x94(K\x03\x8c\x01|\x94NNNJ\xff\xff\xff\xffJ\xff\xff\xff\xffK\x00t\x94bK\x03K\x04K\x02\x87\x94\x8c\x01F\x94t\x94R\x94.'   # noqa: E501
 4456:         transposed_contiguous_dumped = b'\x80\x05\x95\xa5\x00\x00\x00\x00\x00\x00\x00\x8c\x16numpy._core.multiarray\x94\x8c\x0c_reconstruct\x94\x93\x94\x8c\x05numpy\x94\x8c\x07ndarray\x94\x93\x94K\x00\x85\x94C\x01b\x94\x87\x94R\x94(K\x01K\x04K\x03K\x02\x87\x94h\x03\x8c\x05dtype\x94\x93\x94\x8c\x02u1\x94\x89\x88\x87\x94R\x94(K\x03\x8c\x01|\x94NNNJ\xff\xff\xff\xffJ\xff\xff\xff\xffK\x00t\x94b\x89C\x18\x00\x01\x08\t\x10\x11\x02\x03\n\x0b\x12\x13\x04\x05\x0c\r\x14\x15\x06\x07\x0e\x0f\x16\x17\x94t\x94b.'   # noqa: E501
 4457:         no_contiguous_dumped = b'\x80\x05\x95\x91\x00\x00\x00\x00\x00\x00\x00\x8c\x16numpy._core.multiarray\x94\x8c\x0c_reconstruct\x94\x93\x94\x8c\x05numpy\x94\x8c\x07ndarray\x94\x93\x94K\x00\x85\x94C\x01b\x94\x87\x94R\x94(K\x01K\x03K\x02\x86\x94h\x03\x8c\x05dtype\x94\x93\x94\x8c\x02u1\x94\x89\x88\x87\x94R\x94(K\x03\x8c\x01|\x94NNNJ\xff\xff\xff\xffJ\xff\xff\xff\xffK\x00t\x94b\x89C\x06\x00\x01\x04\x05\x08\t\x94t\x94b.'  # noqa: E501
 4458:         x = np.arange(24, dtype='uint8').reshape(3, 4, 2)
 4459:         assert_equal(x, pickle.loads(c_contiguous_dumped))
 4460:         x = np.arange(24, dtype='uint8').reshape(3, 4, 2, order='F')
 4461:         assert_equal(x, pickle.loads(f_contiguous_dumped))
 4462:         x = np.arange(24, dtype='uint8').reshape(3, 4, 2).transpose((1, 0, 2))
 4463:         assert_equal(x, pickle.loads(transposed_contiguous_dumped))
 4464:         x = np.arange(12, dtype='uint8').reshape(3, 4)[:, :2]
 4465:         assert_equal(x, pickle.loads(no_contiguous_dumped))
 4466: 
 4467:     def test_non_contiguous_array(self):
 4468:         non_contiguous_array = np.arange(12).reshape(3, 4)[:, :2]
 4469:         assert not non_contiguous_array.flags.c_contiguous
 4470:         assert not non_contiguous_array.flags.f_contiguous
 4471: 
 4472:         # make sure non-contiguous arrays can be pickled-depickled
 4473:         # using any protocol
 4474:         buffers = []
 4475:         for proto in range(2, pickle.HIGHEST_PROTOCOL + 1):
 4476:             depickled_non_contiguous_array = pickle.loads(
 4477:                     pickle.dumps(non_contiguous_array, protocol=proto,
 4478:                                  buffer_callback=buffers.append if proto >= 5 else None))
 4479: 
 4480:             assert_equal(len(buffers), 0)
 4481:             assert_equal(non_contiguous_array, depickled_non_contiguous_array)
 4482: 
 4483:     def test_roundtrip(self):
 4484:         for proto in range(2, pickle.HIGHEST_PROTOCOL + 1):
 4485:             carray = np.array([[2, 9], [7, 0], [3, 8]])
 4486:             DATA = [
 4487:                 carray,
 4488:                 np.transpose(carray),
 4489:                 np.array([('xxx', 1, 2.0)], dtype=[('a', (str, 3)), ('b', int),
 4490:                                                    ('c', float)])
 4491:             ]
 4492: 
 4493:             refs = [weakref.ref(a) for a in DATA]
 4494:             for a in DATA:
 4495:                 assert_equal(
 4496:                         a, pickle.loads(pickle.dumps(a, protocol=proto)),
 4497:                         err_msg=f"{a!r}")
 4498:             del a, DATA, carray
 4499:             break_cycles()
 4500:             # check for reference leaks (gh-12793)
 4501:             for ref in refs:
 4502:                 assert ref() is None
 4503: 
 4504:     def _loads(self, obj):
 4505:         return pickle.loads(obj, encoding='latin1')
 4506: 
 4507:     # version 0 pickles, using protocol=2 to pickle
 4508:     # version 0 doesn't have a version field
 4509:     def test_version0_int8(self):
 4510:         s = b"\x80\x02cnumpy.core._internal\n_reconstruct\nq\x01cnumpy\nndarray\nq\x02K\x00\x85U\x01b\x87Rq\x03(K\x04\x85cnumpy\ndtype\nq\x04U\x02i1K\x00K\x01\x87Rq\x05(U\x01|NNJ\xff\xff\xff\xffJ\xff\xff\xff\xfftb\x89U\x04\x01\x02\x03\x04tb."
 4511:         a = np.array([1, 2, 3, 4], dtype=np.int8)
 4512:         p = self._loads(s)
 4513:         assert_equal(a, p)
 4514: 
 4515:     def test_version0_float32(self):
 4516:         s = b"\x80\x02cnumpy.core._internal\n_reconstruct\nq\x01cnumpy\nndarray\nq\x02K\x00\x85U\x01b\x87Rq\x03(K\x04\x85cnumpy\ndtype\nq\x04U\x02f4K\x00K\x01\x87Rq\x05(U\x01<NNJ\xff\xff\xff\xffJ\xff\xff\xff\xfftb\x89U\x10\x00\x00\x80?\x00\x00\x00@\x00\x00@@\x00\x00\x80@tb."
 4517:         a = np.array([1.0, 2.0, 3.0, 4.0], dtype=np.float32)
 4518:         p = self._loads(s)
 4519:         assert_equal(a, p)
 4520: 
 4521:     def test_version0_object(self):
 4522:         s = b"\x80\x02cnumpy.core._internal\n_reconstruct\nq\x01cnumpy\nndarray\nq\x02K\x00\x85U\x01b\x87Rq\x03(K\x02\x85cnumpy\ndtype\nq\x04U\x02O8K\x00K\x01\x87Rq\x05(U\x01|NNJ\xff\xff\xff\xffJ\xff\xff\xff\xfftb\x89]q\x06(}q\x07U\x01aK\x01s}q\x08U\x01bK\x02setb."
 4523:         a = np.array([{'a': 1}, {'b': 2}])
 4524:         p = self._loads(s)
 4525:         assert_equal(a, p)
 4526: 
 4527:     # version 1 pickles, using protocol=2 to pickle
 4528:     def test_version1_int8(self):
 4529:         s = b"\x80\x02cnumpy.core._internal\n_reconstruct\nq\x01cnumpy\nndarray\nq\x02K\x00\x85U\x01b\x87Rq\x03(K\x01K\x04\x85cnumpy\ndtype\nq\x04U\x02i1K\x00K\x01\x87Rq\x05(K\x01U\x01|NNJ\xff\xff\xff\xffJ\xff\xff\xff\xfftb\x89U\x04\x01\x02\x03\x04tb."
 4530:         a = np.array([1, 2, 3, 4], dtype=np.int8)
 4531:         p = self._loads(s)
 4532:         assert_equal(a, p)
 4533: 
 4534:     def test_version1_float32(self):
 4535:         s = b"\x80\x02cnumpy.core._internal\n_reconstruct\nq\x01cnumpy\nndarray\nq\x02K\x00\x85U\x01b\x87Rq\x03(K\x01K\x04\x85cnumpy\ndtype\nq\x04U\x02f4K\x00K\x01\x87Rq\x05(K\x01U\x01<NNJ\xff\xff\xff\xffJ\xff\xff\xff\xfftb\x89U\x10\x00\x00\x80?\x00\x00\x00@\x00\x00@@\x00\x00\x80@tb."
 4536:         a = np.array([1.0, 2.0, 3.0, 4.0], dtype=np.float32)
 4537:         p = self._loads(s)
 4538:         assert_equal(a, p)
 4539: 
 4540:     def test_version1_object(self):
 4541:         s = b"\x80\x02cnumpy.core._internal\n_reconstruct\nq\x01cnumpy\nndarray\nq\x02K\x00\x85U\x01b\x87Rq\x03(K\x01K\x02\x85cnumpy\ndtype\nq\x04U\x02O8K\x00K\x01\x87Rq\x05(K\x01U\x01|NNJ\xff\xff\xff\xffJ\xff\xff\xff\xfftb\x89]q\x06(}q\x07U\x01aK\x01s}q\x08U\x01bK\x02setb."
 4542:         a = np.array([{'a': 1}, {'b': 2}])
 4543:         p = self._loads(s)
 4544:         assert_equal(a, p)
 4545: 
 4546:     def test_subarray_int_shape(self):
 4547:         s = b"cnumpy.core.multiarray\n_reconstruct\np0\n(cnumpy\nndarray\np1\n(I0\ntp2\nS'b'\np3\ntp4\nRp5\n(I1\n(I1\ntp6\ncnumpy\ndtype\np7\n(S'V6'\np8\nI0\nI1\ntp9\nRp10\n(I3\nS'|'\np11\nN(S'a'\np12\ng3\ntp13\n(dp14\ng12\n(g7\n(S'V4'\np15\nI0\nI1\ntp16\nRp17\n(I3\nS'|'\np18\n(g7\n(S'i1'\np19\nI0\nI1\ntp20\nRp21\n(I3\nS'|'\np22\nNNNI-1\nI-1\nI0\ntp23\nb(I2\nI2\ntp24\ntp25\nNNI4\nI1\nI0\ntp26\nbI0\ntp27\nsg3\n(g7\n(S'V2'\np28\nI0\nI1\ntp29\nRp30\n(I3\nS'|'\np31\n(g21\nI2\ntp32\nNNI2\nI1\nI0\ntp33\nbI4\ntp34\nsI6\nI1\nI0\ntp35\nbI00\nS'\\x01\\x01\\x01\\x01\\x01\\x02'\np36\ntp37\nb."
 4548:         a = np.array([(1, (1, 2))], dtype=[('a', 'i1', (2, 2)), ('b', 'i1', 2)])
 4549:         p = self._loads(s)
 4550:         assert_equal(a, p)
 4551: 
 4552:     def test_datetime64_byteorder(self):
 4553:         original = np.array([['2015-02-24T00:00:00.000000000']], dtype='datetime64[ns]')
 4554: 
 4555:         original_byte_reversed = original.copy(order='K')
 4556:         original_byte_reversed.dtype = original_byte_reversed.dtype.newbyteorder('S')
 4557:         original_byte_reversed.byteswap(inplace=True)
 4558: 
 4559:         new = pickle.loads(pickle.dumps(original_byte_reversed))
 4560: 
 4561:         assert_equal(original.dtype, new.dtype)
 4562: 
 4563: 
 4564: class TestFancyIndexing:
 4565:     def test_list(self):
 4566:         x = np.ones((1, 1))
 4567:         x[:, [0]] = 2.0
 4568:         assert_array_equal(x, np.array([[2.0]]))
 4569: 
 4570:         x = np.ones((1, 1, 1))
 4571:         x[:, :, [0]] = 2.0
 4572:         assert_array_equal(x, np.array([[[2.0]]]))
 4573: 
 4574:     def test_tuple(self):
 4575:         x = np.ones((1, 1))
 4576:         x[:, (0,)] = 2.0
 4577:         assert_array_equal(x, np.array([[2.0]]))
 4578:         x = np.ones((1, 1, 1))
 4579:         x[:, :, (0,)] = 2.0
 4580:         assert_array_equal(x, np.array([[[2.0]]]))
 4581: 
 4582:     def test_mask(self):
 4583:         x = np.array([1, 2, 3, 4])
 4584:         m = np.array([0, 1, 0, 0], bool)
 4585:         assert_array_equal(x[m], np.array([2]))
 4586: 
 4587:     def test_mask2(self):
 4588:         x = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])
 4589:         m = np.array([0, 1], bool)
 4590:         m2 = np.array([[0, 1, 0, 0], [1, 0, 0, 0]], bool)
 4591:         m3 = np.array([[0, 1, 0, 0], [0, 0, 0, 0]], bool)
 4592:         assert_array_equal(x[m], np.array([[5, 6, 7, 8]]))
 4593:         assert_array_equal(x[m2], np.array([2, 5]))
 4594:         assert_array_equal(x[m3], np.array([2]))
 4595: 
 4596:     def test_assign_mask(self):
 4597:         x = np.array([1, 2, 3, 4])
 4598:         m = np.array([0, 1, 0, 0], bool)
 4599:         x[m] = 5
 4600:         assert_array_equal(x, np.array([1, 5, 3, 4]))
 4601: 
 4602:     def test_assign_mask2(self):
 4603:         xorig = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])
 4604:         m = np.array([0, 1], bool)
 4605:         m2 = np.array([[0, 1, 0, 0], [1, 0, 0, 0]], bool)
 4606:         m3 = np.array([[0, 1, 0, 0], [0, 0, 0, 0]], bool)
 4607:         x = xorig.copy()
 4608:         x[m] = 10
 4609:         assert_array_equal(x, np.array([[1, 2, 3, 4], [10, 10, 10, 10]]))
 4610:         x = xorig.copy()
 4611:         x[m2] = 10
 4612:         assert_array_equal(x, np.array([[1, 10, 3, 4], [10, 6, 7, 8]]))
 4613:         x = xorig.copy()
 4614:         x[m3] = 10
 4615:         assert_array_equal(x, np.array([[1, 10, 3, 4], [5, 6, 7, 8]]))
 4616: 
 4617: 
 4618: class TestStringCompare:
 4619:     def test_string(self):
 4620:         g1 = np.array(["This", "is", "example"])
 4621:         g2 = np.array(["This", "was", "example"])
 4622:         assert_array_equal(g1 == g2, [g1[i] == g2[i] for i in [0, 1, 2]])
 4623:         assert_array_equal(g1 != g2, [g1[i] != g2[i] for i in [0, 1, 2]])
 4624:         assert_array_equal(g1 <= g2, [g1[i] <= g2[i] for i in [0, 1, 2]])
 4625:         assert_array_equal(g1 >= g2, [g1[i] >= g2[i] for i in [0, 1, 2]])
 4626:         assert_array_equal(g1 < g2, [g1[i] < g2[i] for i in [0, 1, 2]])
 4627:         assert_array_equal(g1 > g2, [g1[i] > g2[i] for i in [0, 1, 2]])
 4628: 
 4629:     def test_mixed(self):
 4630:         g1 = np.array(["spam", "spa", "spammer", "and eggs"])
 4631:         g2 = "spam"
 4632:         assert_array_equal(g1 == g2, [x == g2 for x in g1])
 4633:         assert_array_equal(g1 != g2, [x != g2 for x in g1])
 4634:         assert_array_equal(g1 < g2, [x < g2 for x in g1])
 4635:         assert_array_equal(g1 > g2, [x > g2 for x in g1])
 4636:         assert_array_equal(g1 <= g2, [x <= g2 for x in g1])
 4637:         assert_array_equal(g1 >= g2, [x >= g2 for x in g1])
 4638: 
 4639:     def test_unicode(self):
 4640:         g1 = np.array(["This", "is", "example"])
 4641:         g2 = np.array(["This", "was", "example"])
 4642:         assert_array_equal(g1 == g2, [g1[i] == g2[i] for i in [0, 1, 2]])
 4643:         assert_array_equal(g1 != g2, [g1[i] != g2[i] for i in [0, 1, 2]])
 4644:         assert_array_equal(g1 <= g2, [g1[i] <= g2[i] for i in [0, 1, 2]])
 4645:         assert_array_equal(g1 >= g2, [g1[i] >= g2[i] for i in [0, 1, 2]])
 4646:         assert_array_equal(g1 < g2,  [g1[i] < g2[i] for i in [0, 1, 2]])
 4647:         assert_array_equal(g1 > g2,  [g1[i] > g2[i] for i in [0, 1, 2]])
 4648: 
 4649: class TestArgmaxArgminCommon:
 4650: 
 4651:     sizes = [(), (3,), (3, 2), (2, 3),
 4652:              (3, 3), (2, 3, 4), (4, 3, 2),
 4653:              (1, 2, 3, 4), (2, 3, 4, 1),
 4654:              (3, 4, 1, 2), (4, 1, 2, 3),
 4655:              (64,), (128,), (256,)]
 4656: 
 4657:     @pytest.mark.parametrize("size, axis", itertools.chain(*[[(size, axis)
 4658:         for axis in list(range(-len(size), len(size))) + [None]]
 4659:         for size in sizes]))
 4660:     @pytest.mark.parametrize('method', [np.argmax, np.argmin])
 4661:     def test_np_argmin_argmax_keepdims(self, size, axis, method):
 4662: 
 4663:         arr = np.random.normal(size=size)
 4664: 
 4665:         # contiguous arrays
 4666:         if axis is None:
 4667:             new_shape = [1 for _ in range(len(size))]
 4668:         else:
 4669:             new_shape = list(size)
 4670:             new_shape[axis] = 1
 4671:         new_shape = tuple(new_shape)
 4672: 
 4673:         _res_orig = method(arr, axis=axis)
 4674:         res_orig = _res_orig.reshape(new_shape)
 4675:         res = method(arr, axis=axis, keepdims=True)
 4676:         assert_equal(res, res_orig)
 4677:         assert_(res.shape == new_shape)
 4678:         outarray = np.empty(res.shape, dtype=res.dtype)
 4679:         res1 = method(arr, axis=axis, out=outarray,
 4680:                             keepdims=True)
 4681:         assert_(res1 is outarray)
 4682:         assert_equal(res, outarray)
 4683: 
 4684:         if len(size) > 0:
 4685:             wrong_shape = list(new_shape)
 4686:             if axis is not None:
 4687:                 wrong_shape[axis] = 2
 4688:             else:
 4689:                 wrong_shape[0] = 2
 4690:             wrong_outarray = np.empty(wrong_shape, dtype=res.dtype)
 4691:             with pytest.raises(ValueError):
 4692:                 method(arr.T, axis=axis,
 4693:                         out=wrong_outarray, keepdims=True)
 4694: 
 4695:         # non-contiguous arrays
 4696:         if axis is None:
 4697:             new_shape = [1 for _ in range(len(size))]
 4698:         else:
 4699:             new_shape = list(size)[::-1]
 4700:             new_shape[axis] = 1
 4701:         new_shape = tuple(new_shape)
 4702: 
 4703:         _res_orig = method(arr.T, axis=axis)
 4704:         res_orig = _res_orig.reshape(new_shape)
 4705:         res = method(arr.T, axis=axis, keepdims=True)
 4706:         assert_equal(res, res_orig)
 4707:         assert_(res.shape == new_shape)
 4708:         outarray = np.empty(new_shape[::-1], dtype=res.dtype)
 4709:         outarray = outarray.T
 4710:         res1 = method(arr.T, axis=axis, out=outarray,
 4711:                             keepdims=True)
 4712:         assert_(res1 is outarray)
 4713:         assert_equal(res, outarray)
 4714: 
 4715:         if len(size) > 0:
 4716:             # one dimension lesser for non-zero sized
 4717:             # array should raise an error
 4718:             with pytest.raises(ValueError):
 4719:                 method(arr[0], axis=axis,
 4720:                         out=outarray, keepdims=True)
 4721: 
 4722:         if len(size) > 0:
 4723:             wrong_shape = list(new_shape)
 4724:             if axis is not None:
 4725:                 wrong_shape[axis] = 2
 4726:             else:
 4727:                 wrong_shape[0] = 2
 4728:             wrong_outarray = np.empty(wrong_shape, dtype=res.dtype)
 4729:             with pytest.raises(ValueError):
 4730:                 method(arr.T, axis=axis,
 4731:                         out=wrong_outarray, keepdims=True)
 4732: 
 4733:     @pytest.mark.parametrize('method', ['max', 'min'])
 4734:     def test_all(self, method):
 4735:         a = np.random.normal(0, 1, (4, 5, 6, 7, 8))
 4736:         arg_method = getattr(a, 'arg' + method)
 4737:         val_method = getattr(a, method)
 4738:         for i in range(a.ndim):
 4739:             a_maxmin = val_method(i)
 4740:             aarg_maxmin = arg_method(i)
 4741:             axes = list(range(a.ndim))
 4742:             axes.remove(i)
 4743:             assert_(np.all(a_maxmin == aarg_maxmin.choose(
 4744:                                         *a.transpose(i, *axes))))
 4745: 
 4746:     @pytest.mark.parametrize('method', ['argmax', 'argmin'])
 4747:     def test_output_shape(self, method):
 4748:         # see also gh-616
 4749:         a = np.ones((10, 5))
 4750:         arg_method = getattr(a, method)
 4751:         # Check some simple shape mismatches
 4752:         out = np.ones(11, dtype=np.int_)
 4753:         assert_raises(ValueError, arg_method, -1, out)
 4754: 
 4755:         out = np.ones((2, 5), dtype=np.int_)
 4756:         assert_raises(ValueError, arg_method, -1, out)
 4757: 
 4758:         # these could be relaxed possibly (used to allow even the previous)
 4759:         out = np.ones((1, 10), dtype=np.int_)
 4760:         assert_raises(ValueError, arg_method, -1, out)
 4761: 
 4762:         out = np.ones(10, dtype=np.int_)
 4763:         arg_method(-1, out=out)
 4764:         assert_equal(out, arg_method(-1))
 4765: 
 4766:     @pytest.mark.parametrize('ndim', [0, 1])
 4767:     @pytest.mark.parametrize('method', ['argmax', 'argmin'])
 4768:     def test_ret_is_out(self, ndim, method):
 4769:         a = np.ones((4,) + (256,) * ndim)
 4770:         arg_method = getattr(a, method)
 4771:         out = np.empty((256,) * ndim, dtype=np.intp)
 4772:         ret = arg_method(axis=0, out=out)
 4773:         assert ret is out
 4774: 
 4775:     @pytest.mark.parametrize('np_array, method, idx, val',
 4776:         [(np.zeros, 'argmax', 5942, "as"),
 4777:          (np.ones, 'argmin', 6001, "0")])
 4778:     def test_unicode(self, np_array, method, idx, val):
 4779:         d = np_array(6031, dtype='<U9')
 4780:         arg_method = getattr(d, method)
 4781:         d[idx] = val
 4782:         assert_equal(arg_method(), idx)
 4783: 
 4784:     @pytest.mark.parametrize('arr_method, np_method',
 4785:         [('argmax', np.argmax),
 4786:          ('argmin', np.argmin)])
 4787:     def test_np_vs_ndarray(self, arr_method, np_method):
 4788:         # make sure both ndarray.argmax/argmin and
 4789:         # numpy.argmax/argmin support out/axis args
 4790:         a = np.random.normal(size=(2, 3))
 4791:         arg_method = getattr(a, arr_method)
 4792: 
 4793:         # check positional args
 4794:         out1 = np.zeros(2, dtype=int)
 4795:         out2 = np.zeros(2, dtype=int)
 4796:         assert_equal(arg_method(1, out1), np_method(a, 1, out2))
 4797:         assert_equal(out1, out2)
 4798: 
 4799:         # check keyword args
 4800:         out1 = np.zeros(3, dtype=int)
 4801:         out2 = np.zeros(3, dtype=int)
 4802:         assert_equal(arg_method(out=out1, axis=0),
 4803:                      np_method(a, out=out2, axis=0))
 4804:         assert_equal(out1, out2)
 4805: 
 4806:     @pytest.mark.leaks_references(reason="replaces None with NULL.")
 4807:     @pytest.mark.parametrize('method, vals',
 4808:         [('argmax', (10, 30)),
 4809:          ('argmin', (30, 10))])
 4810:     def test_object_with_NULLs(self, method, vals):
 4811:         # See gh-6032
 4812:         a = np.empty(4, dtype='O')
 4813:         arg_method = getattr(a, method)
 4814:         ctypes.memset(a.ctypes.data, 0, a.nbytes)
 4815:         assert_equal(arg_method(), 0)
 4816:         a[3] = vals[0]
 4817:         assert_equal(arg_method(), 3)
 4818:         a[1] = vals[1]
 4819:         assert_equal(arg_method(), 1)
 4820: 
 4821: class TestArgmax:
 4822:     usg_data = [
 4823:         ([1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], 0),
 4824:         ([3, 3, 3, 3,  2,  2,  2,  2], 0),
 4825:         ([0, 1, 2, 3,  4,  5,  6,  7], 7),
 4826:         ([7, 6, 5, 4,  3,  2,  1,  0], 0)
 4827:     ]
 4828:     sg_data = usg_data + [
 4829:         ([1, 2, 3, 4, -4, -3, -2, -1], 3),
 4830:         ([1, 2, 3, 4, -1, -2, -3, -4], 3)
 4831:     ]
 4832:     darr = [(np.array(d[0], dtype=t), d[1]) for d, t in (
 4833:         itertools.product(usg_data, (
 4834:             np.uint8, np.uint16, np.uint32, np.uint64
 4835:         ))
 4836:     )]
 4837:     darr = darr + [(np.array(d[0], dtype=t), d[1]) for d, t in (
 4838:         itertools.product(sg_data, (
 4839:             np.int8, np.int16, np.int32, np.int64, np.float32, np.float64
 4840:         ))
 4841:     )]
 4842:     darr = darr + [(np.array(d[0], dtype=t), d[1]) for d, t in (
 4843:         itertools.product((
 4844:             ([0, 1, 2, 3, np.nan], 4),
 4845:             ([0, 1, 2, np.nan, 3], 3),
 4846:             ([np.nan, 0, 1, 2, 3], 0),
 4847:             ([np.nan, 0, np.nan, 2, 3], 0),
 4848:             # To hit the tail of SIMD multi-level(x4, x1) inner loops
 4849:             # on variant SIMD widths
 4850:             ([1] * (2 * 5 - 1) + [np.nan], 2 * 5 - 1),
 4851:             ([1] * (4 * 5 - 1) + [np.nan], 4 * 5 - 1),
 4852:             ([1] * (8 * 5 - 1) + [np.nan], 8 * 5 - 1),
 4853:             ([1] * (16 * 5 - 1) + [np.nan], 16 * 5 - 1),
 4854:             ([1] * (32 * 5 - 1) + [np.nan], 32 * 5 - 1)
 4855:         ), (
 4856:             np.float32, np.float64
 4857:         ))
 4858:     )]
 4859:     nan_arr = darr + [
 4860:         ([0, 1, 2, 3, complex(0, np.nan)], 4),
 4861:         ([0, 1, 2, 3, complex(np.nan, 0)], 4),
 4862:         ([0, 1, 2, complex(np.nan, 0), 3], 3),
 4863:         ([0, 1, 2, complex(0, np.nan), 3], 3),
 4864:         ([complex(0, np.nan), 0, 1, 2, 3], 0),
 4865:         ([complex(np.nan, np.nan), 0, 1, 2, 3], 0),
 4866:         ([complex(np.nan, 0), complex(np.nan, 2), complex(np.nan, 1)], 0),
 4867:         ([complex(np.nan, np.nan), complex(np.nan, 2), complex(np.nan, 1)], 0),
 4868:         ([complex(np.nan, 0), complex(np.nan, 2), complex(np.nan, np.nan)], 0),
 4869: 
 4870:         ([complex(0, 0), complex(0, 2), complex(0, 1)], 1),
 4871:         ([complex(1, 0), complex(0, 2), complex(0, 1)], 0),
 4872:         ([complex(1, 0), complex(0, 2), complex(1, 1)], 2),
 4873: 
 4874:         ([np.datetime64('1923-04-14T12:43:12'),
 4875:           np.datetime64('1994-06-21T14:43:15'),
 4876:           np.datetime64('2001-10-15T04:10:32'),
 4877:           np.datetime64('1995-11-25T16:02:16'),
 4878:           np.datetime64('2005-01-04T03:14:12'),
 4879:           np.datetime64('2041-12-03T14:05:03')], 5),
 4880:         ([np.datetime64('1935-09-14T04:40:11'),
 4881:           np.datetime64('1949-10-12T12:32:11'),
 4882:           np.datetime64('2010-01-03T05:14:12'),
 4883:           np.datetime64('2015-11-20T12:20:59'),
 4884:           np.datetime64('1932-09-23T10:10:13'),
 4885:           np.datetime64('2014-10-10T03:50:30')], 3),
 4886:         # Assorted tests with NaTs
 4887:         ([np.datetime64('NaT'),
 4888:           np.datetime64('NaT'),
 4889:           np.datetime64('2010-01-03T05:14:12'),
 4890:           np.datetime64('NaT'),
 4891:           np.datetime64('2015-09-23T10:10:13'),
 4892:           np.datetime64('1932-10-10T03:50:30')], 0),
 4893:         ([np.datetime64('2059-03-14T12:43:12'),
 4894:           np.datetime64('1996-09-21T14:43:15'),
 4895:           np.datetime64('NaT'),
 4896:           np.datetime64('2022-12-25T16:02:16'),
 4897:           np.datetime64('1963-10-04T03:14:12'),
 4898:           np.datetime64('2013-05-08T18:15:23')], 2),
 4899:         ([np.timedelta64(2, 's'),
 4900:           np.timedelta64(1, 's'),
 4901:           np.timedelta64('NaT', 's'),
 4902:           np.timedelta64(3, 's')], 2),
 4903:         ([np.timedelta64('NaT', 's')] * 3, 0),
 4904: 
 4905:         ([timedelta(days=5, seconds=14), timedelta(days=2, seconds=35),
 4906:           timedelta(days=-1, seconds=23)], 0),
 4907:         ([timedelta(days=1, seconds=43), timedelta(days=10, seconds=5),
 4908:           timedelta(days=5, seconds=14)], 1),
 4909:         ([timedelta(days=10, seconds=24), timedelta(days=10, seconds=5),
 4910:           timedelta(days=10, seconds=43)], 2),
 4911: 
 4912:         ([False, False, False, False, True], 4),
 4913:         ([False, False, False, True, False], 3),
 4914:         ([True, False, False, False, False], 0),
 4915:         ([True, False, True, False, False], 0),
 4916:     ]
 4917: 
 4918:     @pytest.mark.parametrize('data', nan_arr)
 4919:     def test_combinations(self, data):
 4920:         arr, pos = data
 4921:         with suppress_warnings() as sup:
 4922:             sup.filter(RuntimeWarning,
 4923:                         "invalid value encountered in reduce")
 4924:             val = np.max(arr)
 4925: 
 4926:         assert_equal(np.argmax(arr), pos, err_msg=f"{arr!r}")
 4927:         assert_equal(arr[np.argmax(arr)], val, err_msg=f"{arr!r}")
 4928: 
 4929:         # add padding to test SIMD loops
 4930:         rarr = np.repeat(arr, 129)
 4931:         rpos = pos * 129
 4932:         assert_equal(np.argmax(rarr), rpos, err_msg=f"{rarr!r}")
 4933:         assert_equal(rarr[np.argmax(rarr)], val, err_msg=f"{rarr!r}")
 4934: 
 4935:         padd = np.repeat(np.min(arr), 513)
 4936:         rarr = np.concatenate((arr, padd))
 4937:         rpos = pos
 4938:         assert_equal(np.argmax(rarr), rpos, err_msg=f"{rarr!r}")
 4939:         assert_equal(rarr[np.argmax(rarr)], val, err_msg=f"{rarr!r}")
 4940: 
 4941:     def test_maximum_signed_integers(self):
 4942: 
 4943:         a = np.array([1, 2**7 - 1, -2**7], dtype=np.int8)
 4944:         assert_equal(np.argmax(a), 1)
 4945:         a = a.repeat(129)
 4946:         assert_equal(np.argmax(a), 129)
 4947: 
 4948:         a = np.array([1, 2**15 - 1, -2**15], dtype=np.int16)
 4949:         assert_equal(np.argmax(a), 1)
 4950:         a = a.repeat(129)
 4951:         assert_equal(np.argmax(a), 129)
 4952: 
 4953:         a = np.array([1, 2**31 - 1, -2**31], dtype=np.int32)
 4954:         assert_equal(np.argmax(a), 1)
 4955:         a = a.repeat(129)
 4956:         assert_equal(np.argmax(a), 129)
 4957: 
 4958:         a = np.array([1, 2**63 - 1, -2**63], dtype=np.int64)
 4959:         assert_equal(np.argmax(a), 1)
 4960:         a = a.repeat(129)
 4961:         assert_equal(np.argmax(a), 129)
 4962: 
 4963: class TestArgmin:
 4964:     usg_data = [
 4965:         ([1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], 8),
 4966:         ([3, 3, 3, 3,  2,  2,  2,  2], 4),
 4967:         ([0, 1, 2, 3,  4,  5,  6,  7], 0),
 4968:         ([7, 6, 5, 4,  3,  2,  1,  0], 7)
 4969:     ]
 4970:     sg_data = usg_data + [
 4971:         ([1, 2, 3, 4, -4, -3, -2, -1], 4),
 4972:         ([1, 2, 3, 4, -1, -2, -3, -4], 7)
 4973:     ]
 4974:     darr = [(np.array(d[0], dtype=t), d[1]) for d, t in (
 4975:         itertools.product(usg_data, (
 4976:             np.uint8, np.uint16, np.uint32, np.uint64
 4977:         ))
 4978:     )]
 4979:     darr = darr + [(np.array(d[0], dtype=t), d[1]) for d, t in (
 4980:         itertools.product(sg_data, (
 4981:             np.int8, np.int16, np.int32, np.int64, np.float32, np.float64
 4982:         ))
 4983:     )]
 4984:     darr = darr + [(np.array(d[0], dtype=t), d[1]) for d, t in (
 4985:         itertools.product((
 4986:             ([0, 1, 2, 3, np.nan], 4),
 4987:             ([0, 1, 2, np.nan, 3], 3),
 4988:             ([np.nan, 0, 1, 2, 3], 0),
 4989:             ([np.nan, 0, np.nan, 2, 3], 0),
 4990:             # To hit the tail of SIMD multi-level(x4, x1) inner loops
 4991:             # on variant SIMD widths
 4992:             ([1] * (2 * 5 - 1) + [np.nan], 2 * 5 - 1),
 4993:             ([1] * (4 * 5 - 1) + [np.nan], 4 * 5 - 1),
 4994:             ([1] * (8 * 5 - 1) + [np.nan], 8 * 5 - 1),
 4995:             ([1] * (16 * 5 - 1) + [np.nan], 16 * 5 - 1),
 4996:             ([1] * (32 * 5 - 1) + [np.nan], 32 * 5 - 1)
 4997:         ), (
 4998:             np.float32, np.float64
 4999:         ))
 5000:     )]
 5001:     nan_arr = darr + [
 5002:         ([0, 1, 2, 3, complex(0, np.nan)], 4),
 5003:         ([0, 1, 2, 3, complex(np.nan, 0)], 4),
 5004:         ([0, 1, 2, complex(np.nan, 0), 3], 3),
 5005:         ([0, 1, 2, complex(0, np.nan), 3], 3),
 5006:         ([complex(0, np.nan), 0, 1, 2, 3], 0),
 5007:         ([complex(np.nan, np.nan), 0, 1, 2, 3], 0),
 5008:         ([complex(np.nan, 0), complex(np.nan, 2), complex(np.nan, 1)], 0),
 5009:         ([complex(np.nan, np.nan), complex(np.nan, 2), complex(np.nan, 1)], 0),
 5010:         ([complex(np.nan, 0), complex(np.nan, 2), complex(np.nan, np.nan)], 0),
 5011: 
 5012:         ([complex(0, 0), complex(0, 2), complex(0, 1)], 0),
 5013:         ([complex(1, 0), complex(0, 2), complex(0, 1)], 2),
 5014:         ([complex(1, 0), complex(0, 2), complex(1, 1)], 1),
 5015: 
 5016:         ([np.datetime64('1923-04-14T12:43:12'),
 5017:           np.datetime64('1994-06-21T14:43:15'),
 5018:           np.datetime64('2001-10-15T04:10:32'),
 5019:           np.datetime64('1995-11-25T16:02:16'),
 5020:           np.datetime64('2005-01-04T03:14:12'),
 5021:           np.datetime64('2041-12-03T14:05:03')], 0),
 5022:         ([np.datetime64('1935-09-14T04:40:11'),
 5023:           np.datetime64('1949-10-12T12:32:11'),
 5024:           np.datetime64('2010-01-03T05:14:12'),
 5025:           np.datetime64('2014-11-20T12:20:59'),
 5026:           np.datetime64('2015-09-23T10:10:13'),
 5027:           np.datetime64('1932-10-10T03:50:30')], 5),
 5028:         # Assorted tests with NaTs
 5029:         ([np.datetime64('NaT'),
 5030:           np.datetime64('NaT'),
 5031:           np.datetime64('2010-01-03T05:14:12'),
 5032:           np.datetime64('NaT'),
 5033:           np.datetime64('2015-09-23T10:10:13'),
 5034:           np.datetime64('1932-10-10T03:50:30')], 0),
 5035:         ([np.datetime64('2059-03-14T12:43:12'),
 5036:           np.datetime64('1996-09-21T14:43:15'),
 5037:           np.datetime64('NaT'),
 5038:           np.datetime64('2022-12-25T16:02:16'),
 5039:           np.datetime64('1963-10-04T03:14:12'),
 5040:           np.datetime64('2013-05-08T18:15:23')], 2),
 5041:         ([np.timedelta64(2, 's'),
 5042:           np.timedelta64(1, 's'),
 5043:           np.timedelta64('NaT', 's'),
 5044:           np.timedelta64(3, 's')], 2),
 5045:         ([np.timedelta64('NaT', 's')] * 3, 0),
 5046: 
 5047:         ([timedelta(days=5, seconds=14), timedelta(days=2, seconds=35),
 5048:           timedelta(days=-1, seconds=23)], 2),
 5049:         ([timedelta(days=1, seconds=43), timedelta(days=10, seconds=5),
 5050:           timedelta(days=5, seconds=14)], 0),
 5051:         ([timedelta(days=10, seconds=24), timedelta(days=10, seconds=5),
 5052:           timedelta(days=10, seconds=43)], 1),
 5053: 
 5054:         ([True, True, True, True, False], 4),
 5055:         ([True, True, True, False, True], 3),
 5056:         ([False, True, True, True, True], 0),
 5057:         ([False, True, False, True, True], 0),
 5058:     ]
 5059: 
 5060:     @pytest.mark.parametrize('data', nan_arr)
 5061:     def test_combinations(self, data):
 5062:         arr, pos = data
 5063:         with suppress_warnings() as sup:
 5064:             sup.filter(RuntimeWarning,
 5065:                        "invalid value encountered in reduce")
 5066:             min_val = np.min(arr)
 5067: 
 5068:         assert_equal(np.argmin(arr), pos, err_msg=f"{arr!r}")
 5069:         assert_equal(arr[np.argmin(arr)], min_val, err_msg=f"{arr!r}")
 5070: 
 5071:         # add padding to test SIMD loops
 5072:         rarr = np.repeat(arr, 129)
 5073:         rpos = pos * 129
 5074:         assert_equal(np.argmin(rarr), rpos, err_msg=f"{rarr!r}")
 5075:         assert_equal(rarr[np.argmin(rarr)], min_val, err_msg=f"{rarr!r}")
 5076: 
 5077:         padd = np.repeat(np.max(arr), 513)
 5078:         rarr = np.concatenate((arr, padd))
 5079:         rpos = pos
 5080:         assert_equal(np.argmin(rarr), rpos, err_msg=f"{rarr!r}")
 5081:         assert_equal(rarr[np.argmin(rarr)], min_val, err_msg=f"{rarr!r}")
 5082: 
 5083:     def test_minimum_signed_integers(self):
 5084: 
 5085:         a = np.array([1, -2**7, -2**7 + 1, 2**7 - 1], dtype=np.int8)
 5086:         assert_equal(np.argmin(a), 1)
 5087:         a = a.repeat(129)
 5088:         assert_equal(np.argmin(a), 129)
 5089: 
 5090:         a = np.array([1, -2**15, -2**15 + 1, 2**15 - 1], dtype=np.int16)
 5091:         assert_equal(np.argmin(a), 1)
 5092:         a = a.repeat(129)
 5093:         assert_equal(np.argmin(a), 129)
 5094: 
 5095:         a = np.array([1, -2**31, -2**31 + 1, 2**31 - 1], dtype=np.int32)
 5096:         assert_equal(np.argmin(a), 1)
 5097:         a = a.repeat(129)
 5098:         assert_equal(np.argmin(a), 129)
 5099: 
 5100:         a = np.array([1, -2**63, -2**63 + 1, 2**63 - 1], dtype=np.int64)
 5101:         assert_equal(np.argmin(a), 1)
 5102:         a = a.repeat(129)
 5103:         assert_equal(np.argmin(a), 129)
 5104: 
 5105: class TestMinMax:
 5106: 
 5107:     def test_scalar(self):
 5108:         assert_raises(AxisError, np.amax, 1, 1)
 5109:         assert_raises(AxisError, np.amin, 1, 1)
 5110: 
 5111:         assert_equal(np.amax(1, axis=0), 1)
 5112:         assert_equal(np.amin(1, axis=0), 1)
 5113:         assert_equal(np.amax(1, axis=None), 1)
 5114:         assert_equal(np.amin(1, axis=None), 1)
 5115: 
 5116:     def test_axis(self):
 5117:         assert_raises(AxisError, np.amax, [1, 2, 3], 1000)
 5118:         assert_equal(np.amax([[1, 2, 3]], axis=1), 3)
 5119: 
 5120:     def test_datetime(self):
 5121:         # Do not ignore NaT
 5122:         for dtype in ('m8[s]', 'm8[Y]'):
 5123:             a = np.arange(10).astype(dtype)
 5124:             assert_equal(np.amin(a), a[0])
 5125:             assert_equal(np.amax(a), a[9])
 5126:             a[3] = 'NaT'
 5127:             assert_equal(np.amin(a), a[3])
 5128:             assert_equal(np.amax(a), a[3])
 5129: 
 5130: 
 5131: class TestNewaxis:
 5132:     def test_basic(self):
 5133:         sk = np.array([0, -0.1, 0.1])
 5134:         res = 250 * sk[:, np.newaxis]
 5135:         assert_almost_equal(res.ravel(), 250 * sk)
 5136: 
 5137: 
 5138: class TestClip:
 5139:     def _check_range(self, x, cmin, cmax):
 5140:         assert_(np.all(x >= cmin))
 5141:         assert_(np.all(x <= cmax))
 5142: 
 5143:     def _clip_type(self, type_group, array_max,
 5144:                    clip_min, clip_max, inplace=False,
 5145:                    expected_min=None, expected_max=None):
 5146:         if expected_min is None:
 5147:             expected_min = clip_min
 5148:         if expected_max is None:
 5149:             expected_max = clip_max
 5150: 
 5151:         for T in np._core.sctypes[type_group]:
 5152:             if sys.byteorder == 'little':
 5153:                 byte_orders = ['=', '>']
 5154:             else:
 5155:                 byte_orders = ['<', '=']
 5156: 
 5157:             for byteorder in byte_orders:
 5158:                 dtype = np.dtype(T).newbyteorder(byteorder)
 5159: 
 5160:                 x = (np.random.random(1000) * array_max).astype(dtype)
 5161:                 if inplace:
 5162:                     # The tests that call us pass clip_min and clip_max that
 5163:                     # might not fit in the destination dtype. They were written
 5164:                     # assuming the previous unsafe casting, which now must be
 5165:                     # passed explicitly to avoid a warning.
 5166:                     x.clip(clip_min, clip_max, x, casting='unsafe')
 5167:                 else:
 5168:                     x = x.clip(clip_min, clip_max)
 5169:                     byteorder = '='
 5170: 
 5171:                 if x.dtype.byteorder == '|':
 5172:                     byteorder = '|'
 5173:                 assert_equal(x.dtype.byteorder, byteorder)
 5174:                 self._check_range(x, expected_min, expected_max)
 5175:         return x
 5176: 
 5177:     def test_basic(self):
 5178:         for inplace in [False, True]:
 5179:             self._clip_type(
 5180:                 'float', 1024, -12.8, 100.2, inplace=inplace)
 5181:             self._clip_type(
 5182:                 'float', 1024, 0, 0, inplace=inplace)
 5183: 
 5184:             self._clip_type(
 5185:                 'int', 1024, -120, 100, inplace=inplace)
 5186:             self._clip_type(
 5187:                 'int', 1024, 0, 0, inplace=inplace)
 5188: 
 5189:             self._clip_type(
 5190:                 'uint', 1024, 0, 0, inplace=inplace)
 5191:             self._clip_type(
 5192:                 'uint', 1024, 10, 100, inplace=inplace)
 5193: 
 5194:     @pytest.mark.parametrize("inplace", [False, True])
 5195:     def test_int_out_of_range(self, inplace):
 5196:         # Simple check for out-of-bound integers, also testing the in-place
 5197:         # path.
 5198:         x = (np.random.random(1000) * 255).astype("uint8")
 5199:         out = np.empty_like(x)
 5200:         res = x.clip(-1, 300, out=out if inplace else None)
 5201:         assert res is out or not inplace
 5202:         assert (res == x).all()
 5203: 
 5204:         res = x.clip(-1, 50, out=out if inplace else None)
 5205:         assert res is out or not inplace
 5206:         assert (res <= 50).all()
 5207:         assert (res[x <= 50] == x[x <= 50]).all()
 5208: 
 5209:         res = x.clip(100, 1000, out=out if inplace else None)
 5210:         assert res is out or not inplace
 5211:         assert (res >= 100).all()
 5212:         assert (res[x >= 100] == x[x >= 100]).all()
 5213: 
 5214:     def test_record_array(self):
 5215:         rec = np.array([(-5, 2.0, 3.0), (5.0, 4.0, 3.0)],
 5216:                        dtype=[('x', '<f8'), ('y', '<f8'), ('z', '<f8')])
 5217:         y = rec['x'].clip(-0.3, 0.5)
 5218:         self._check_range(y, -0.3, 0.5)
 5219: 
 5220:     def test_max_or_min(self):
 5221:         val = np.array([0, 1, 2, 3, 4, 5, 6, 7])
 5222:         x = val.clip(3)
 5223:         assert_(np.all(x >= 3))
 5224:         x = val.clip(min=3)
 5225:         assert_(np.all(x >= 3))
 5226:         x = val.clip(max=4)
 5227:         assert_(np.all(x <= 4))
 5228: 
 5229:     def test_nan(self):
 5230:         input_arr = np.array([-2., np.nan, 0.5, 3., 0.25, np.nan])
 5231:         result = input_arr.clip(-1, 1)
 5232:         expected = np.array([-1., np.nan, 0.5, 1., 0.25, np.nan])
 5233:         assert_array_equal(result, expected)
 5234: 
 5235: 
 5236: class TestCompress:
 5237:     def test_axis(self):
 5238:         tgt = [[5, 6, 7, 8, 9]]
 5239:         arr = np.arange(10).reshape(2, 5)
 5240:         out = np.compress([0, 1], arr, axis=0)
 5241:         assert_equal(out, tgt)
 5242: 
 5243:         tgt = [[1, 3], [6, 8]]
 5244:         out = np.compress([0, 1, 0, 1, 0], arr, axis=1)
 5245:         assert_equal(out, tgt)
 5246: 
 5247:     def test_truncate(self):
 5248:         tgt = [[1], [6]]
 5249:         arr = np.arange(10).reshape(2, 5)
 5250:         out = np.compress([0, 1], arr, axis=1)
 5251:         assert_equal(out, tgt)
 5252: 
 5253:     def test_flatten(self):
 5254:         arr = np.arange(10).reshape(2, 5)
 5255:         out = np.compress([0, 1], arr)
 5256:         assert_equal(out, 1)
 5257: 
 5258: 
 5259: class TestPutmask:
 5260:     def tst_basic(self, x, T, mask, val):
 5261:         np.putmask(x, mask, val)
 5262:         assert_equal(x[mask], np.array(val, T))
 5263: 
 5264:     def test_ip_types(self):
 5265:         unchecked_types = [bytes, str, np.void]
 5266: 
 5267:         x = np.random.random(1000) * 100
 5268:         mask = x < 40
 5269: 
 5270:         for val in [-100, 0, 15]:
 5271:             for types in np._core.sctypes.values():
 5272:                 for T in types:
 5273:                     if T not in unchecked_types:
 5274:                         if val < 0 and np.dtype(T).kind == "u":
 5275:                             val = np.iinfo(T).max - 99
 5276:                         self.tst_basic(x.copy().astype(T), T, mask, val)
 5277: 
 5278:             # Also test string of a length which uses an untypical length
 5279:             dt = np.dtype("S3")
 5280:             self.tst_basic(x.astype(dt), dt.type, mask, dt.type(val)[:3])
 5281: 
 5282:     def test_mask_size(self):
 5283:         assert_raises(ValueError, np.putmask, np.array([1, 2, 3]), [True], 5)
 5284: 
 5285:     @pytest.mark.parametrize('dtype', ('>i4', '<i4'))
 5286:     def test_byteorder(self, dtype):
 5287:         x = np.array([1, 2, 3], dtype)
 5288:         np.putmask(x, [True, False, True], -1)
 5289:         assert_array_equal(x, [-1, 2, -1])
 5290: 
 5291:     def test_record_array(self):
 5292:         # Note mixed byteorder.
 5293:         rec = np.array([(-5, 2.0, 3.0), (5.0, 4.0, 3.0)],
 5294:                       dtype=[('x', '<f8'), ('y', '>f8'), ('z', '<f8')])
 5295:         np.putmask(rec['x'], [True, False], 10)
 5296:         assert_array_equal(rec['x'], [10, 5])
 5297:         assert_array_equal(rec['y'], [2, 4])
 5298:         assert_array_equal(rec['z'], [3, 3])
 5299:         np.putmask(rec['y'], [True, False], 11)
 5300:         assert_array_equal(rec['x'], [10, 5])
 5301:         assert_array_equal(rec['y'], [11, 4])
 5302:         assert_array_equal(rec['z'], [3, 3])
 5303: 
 5304:     def test_overlaps(self):
 5305:         # gh-6272 check overlap
 5306:         x = np.array([True, False, True, False])
 5307:         np.putmask(x[1:4], [True, True, True], x[:3])
 5308:         assert_equal(x, np.array([True, True, False, True]))
 5309: 
 5310:         x = np.array([True, False, True, False])
 5311:         np.putmask(x[1:4], x[:3], [True, False, True])
 5312:         assert_equal(x, np.array([True, True, True, True]))
 5313: 
 5314:     def test_writeable(self):
 5315:         a = np.arange(5)
 5316:         a.flags.writeable = False
 5317: 
 5318:         with pytest.raises(ValueError):
 5319:             np.putmask(a, a >= 2, 3)
 5320: 
 5321:     def test_kwargs(self):
 5322:         x = np.array([0, 0])
 5323:         np.putmask(x, [0, 1], [-1, -2])
 5324:         assert_array_equal(x, [0, -2])
 5325: 
 5326:         x = np.array([0, 0])
 5327:         np.putmask(x, mask=[0, 1], values=[-1, -2])
 5328:         assert_array_equal(x, [0, -2])
 5329: 
 5330:         x = np.array([0, 0])
 5331:         np.putmask(x, values=[-1, -2],  mask=[0, 1])
 5332:         assert_array_equal(x, [0, -2])
 5333: 
 5334:         with pytest.raises(TypeError):
 5335:             np.putmask(a=x, values=[-1, -2],  mask=[0, 1])
 5336: 
 5337: 
 5338: class TestTake:
 5339:     def tst_basic(self, x):
 5340:         ind = list(range(x.shape[0]))
 5341:         assert_array_equal(x.take(ind, axis=0), x)
 5342: 
 5343:     def test_ip_types(self):
 5344:         unchecked_types = [bytes, str, np.void]
 5345: 
 5346:         x = np.random.random(24) * 100
 5347:         x.shape = 2, 3, 4
 5348:         for types in np._core.sctypes.values():
 5349:             for T in types:
 5350:                 if T not in unchecked_types:
 5351:                     self.tst_basic(x.copy().astype(T))
 5352: 
 5353:             # Also test string of a length which uses an untypical length
 5354:             self.tst_basic(x.astype("S3"))
 5355: 
 5356:     def test_raise(self):
 5357:         x = np.random.random(24) * 100
 5358:         x.shape = 2, 3, 4
 5359:         assert_raises(IndexError, x.take, [0, 1, 2], axis=0)
 5360:         assert_raises(IndexError, x.take, [-3], axis=0)
 5361:         assert_array_equal(x.take([-1], axis=0)[0], x[1])
 5362: 
 5363:     def test_clip(self):
 5364:         x = np.random.random(24) * 100
 5365:         x.shape = 2, 3, 4
 5366:         assert_array_equal(x.take([-1], axis=0, mode='clip')[0], x[0])
 5367:         assert_array_equal(x.take([2], axis=0, mode='clip')[0], x[1])
 5368: 
 5369:     def test_wrap(self):
 5370:         x = np.random.random(24) * 100
 5371:         x.shape = 2, 3, 4
 5372:         assert_array_equal(x.take([-1], axis=0, mode='wrap')[0], x[1])
 5373:         assert_array_equal(x.take([2], axis=0, mode='wrap')[0], x[0])
 5374:         assert_array_equal(x.take([3], axis=0, mode='wrap')[0], x[1])
 5375: 
 5376:     @pytest.mark.parametrize('dtype', ('>i4', '<i4'))
 5377:     def test_byteorder(self, dtype):
 5378:         x = np.array([1, 2, 3], dtype)
 5379:         assert_array_equal(x.take([0, 2, 1]), [1, 3, 2])
 5380: 
 5381:     def test_record_array(self):
 5382:         # Note mixed byteorder.
 5383:         rec = np.array([(-5, 2.0, 3.0), (5.0, 4.0, 3.0)],
 5384:                       dtype=[('x', '<f8'), ('y', '>f8'), ('z', '<f8')])
 5385:         rec1 = rec.take([1])
 5386:         assert_(rec1['x'] == 5.0 and rec1['y'] == 4.0)
 5387: 
 5388:     def test_out_overlap(self):
 5389:         # gh-6272 check overlap on out
 5390:         x = np.arange(5)
 5391:         y = np.take(x, [1, 2, 3], out=x[2:5], mode='wrap')
 5392:         assert_equal(y, np.array([1, 2, 3]))
 5393: 
 5394:     @pytest.mark.parametrize('shape', [(1, 2), (1,), ()])
 5395:     def test_ret_is_out(self, shape):
 5396:         # 0d arrays should not be an exception to this rule
 5397:         x = np.arange(5)
 5398:         inds = np.zeros(shape, dtype=np.intp)
 5399:         out = np.zeros(shape, dtype=x.dtype)
 5400:         ret = np.take(x, inds, out=out)
 5401:         assert ret is out
 5402: 
 5403: 
 5404: class TestLexsort:
 5405:     @pytest.mark.parametrize('dtype', [
 5406:         np.uint8, np.uint16, np.uint32, np.uint64,
 5407:         np.int8, np.int16, np.int32, np.int64,
 5408:         np.float16, np.float32, np.float64
 5409:     ])
 5410:     def test_basic(self, dtype):
 5411:         a = np.array([1, 2, 1, 3, 1, 5], dtype=dtype)
 5412:         b = np.array([0, 4, 5, 6, 2, 3], dtype=dtype)
 5413:         idx = np.lexsort((b, a))
 5414:         expected_idx = np.array([0, 4, 2, 1, 3, 5])
 5415:         assert_array_equal(idx, expected_idx)
 5416:         assert_array_equal(a[idx], np.sort(a))
 5417: 
 5418:     def test_mixed(self):
 5419:         a = np.array([1, 2, 1, 3, 1, 5])
 5420:         b = np.array([0, 4, 5, 6, 2, 3], dtype='datetime64[D]')
 5421: 
 5422:         idx = np.lexsort((b, a))
 5423:         expected_idx = np.array([0, 4, 2, 1, 3, 5])
 5424:         assert_array_equal(idx, expected_idx)
 5425: 
 5426:     def test_datetime(self):
 5427:         a = np.array([0, 0, 0], dtype='datetime64[D]')
 5428:         b = np.array([2, 1, 0], dtype='datetime64[D]')
 5429:         idx = np.lexsort((b, a))
 5430:         expected_idx = np.array([2, 1, 0])
 5431:         assert_array_equal(idx, expected_idx)
 5432: 
 5433:         a = np.array([0, 0, 0], dtype='timedelta64[D]')
 5434:         b = np.array([2, 1, 0], dtype='timedelta64[D]')
 5435:         idx = np.lexsort((b, a))
 5436:         expected_idx = np.array([2, 1, 0])
 5437:         assert_array_equal(idx, expected_idx)
 5438: 
 5439:     def test_object(self):  # gh-6312
 5440:         a = np.random.choice(10, 1000)
 5441:         b = np.random.choice(['abc', 'xy', 'wz', 'efghi', 'qwst', 'x'], 1000)
 5442: 
 5443:         for u in a, b:
 5444:             left = np.lexsort((u.astype('O'),))
 5445:             right = np.argsort(u, kind='mergesort')
 5446:             assert_array_equal(left, right)
 5447: 
 5448:         for u, v in (a, b), (b, a):
 5449:             idx = np.lexsort((u, v))
 5450:             assert_array_equal(idx, np.lexsort((u.astype('O'), v)))
 5451:             assert_array_equal(idx, np.lexsort((u, v.astype('O'))))
 5452:             u, v = np.array(u, dtype='object'), np.array(v, dtype='object')
 5453:             assert_array_equal(idx, np.lexsort((u, v)))
 5454: 
 5455:     def test_strings(self):  # gh-27984
 5456:         for dtype in "TU":
 5457:             surnames = np.array(['Hertz',    'Galilei', 'Hertz'], dtype=dtype)
 5458:             first_names = np.array(['Heinrich', 'Galileo', 'Gustav'], dtype=dtype)
 5459:             assert_array_equal(np.lexsort((first_names, surnames)), [1, 2, 0])
 5460: 
 5461:     def test_invalid_axis(self):  # gh-7528
 5462:         x = np.linspace(0., 1., 42 * 3).reshape(42, 3)
 5463:         assert_raises(AxisError, np.lexsort, x, axis=2)
 5464: 
 5465: class TestIO:
 5466:     """Test tofile, fromfile, tobytes, and fromstring"""
 5467: 
 5468:     @pytest.fixture()
 5469:     def x(self):
 5470:         shape = (2, 4, 3)
 5471:         rand = np.random.random
 5472:         x = rand(shape) + rand(shape).astype(complex) * 1j
 5473:         x[0, :, 1] = [np.nan, np.inf, -np.inf, np.nan]
 5474:         return x
 5475: 
 5476:     @pytest.fixture(params=["string", "path_obj"])
 5477:     def tmp_filename(self, tmp_path, request):
 5478:         # This fixture covers two cases:
 5479:         # one where the filename is a string and
 5480:         # another where it is a pathlib object
 5481:         filename = tmp_path / "file"
 5482:         if request.param == "string":
 5483:             filename = str(filename)
 5484:         yield filename
 5485: 
 5486:     def test_nofile(self):
 5487:         # this should probably be supported as a file
 5488:         # but for now test for proper errors
 5489:         b = io.BytesIO()
 5490:         assert_raises(OSError, np.fromfile, b, np.uint8, 80)
 5491:         d = np.ones(7)
 5492:         assert_raises(OSError, lambda x: x.tofile(b), d)
 5493: 
 5494:     def test_bool_fromstring(self):
 5495:         v = np.array([True, False, True, False], dtype=np.bool)
 5496:         y = np.fromstring('1 0 -2.3 0.0', sep=' ', dtype=np.bool)
 5497:         assert_array_equal(v, y)
 5498: 
 5499:     def test_uint64_fromstring(self):
 5500:         d = np.fromstring("9923372036854775807 104783749223640",
 5501:                           dtype=np.uint64, sep=' ')
 5502:         e = np.array([9923372036854775807, 104783749223640], dtype=np.uint64)
 5503:         assert_array_equal(d, e)
 5504: 
 5505:     def test_int64_fromstring(self):
 5506:         d = np.fromstring("-25041670086757 104783749223640",
 5507:                           dtype=np.int64, sep=' ')
 5508:         e = np.array([-25041670086757, 104783749223640], dtype=np.int64)
 5509:         assert_array_equal(d, e)
 5510: 
 5511:     def test_fromstring_count0(self):
 5512:         d = np.fromstring("1,2", sep=",", dtype=np.int64, count=0)
 5513:         assert d.shape == (0,)
 5514: 
 5515:     def test_empty_files_text(self, tmp_filename):
 5516:         with open(tmp_filename, 'w') as f:
 5517:             pass
 5518:         y = np.fromfile(tmp_filename)
 5519:         assert_(y.size == 0, "Array not empty")
 5520: 
 5521:     def test_empty_files_binary(self, tmp_filename):
 5522:         with open(tmp_filename, 'wb') as f:
 5523:             pass
 5524:         y = np.fromfile(tmp_filename, sep=" ")
 5525:         assert_(y.size == 0, "Array not empty")
 5526: 
 5527:     def test_roundtrip_file(self, x, tmp_filename):
 5528:         with open(tmp_filename, 'wb') as f:
 5529:             x.tofile(f)
 5530:         # NB. doesn't work with flush+seek, due to use of C stdio
 5531:         with open(tmp_filename, 'rb') as f:
 5532:             y = np.fromfile(f, dtype=x.dtype)
 5533:         assert_array_equal(y, x.flat)
 5534: 
 5535:     def test_roundtrip(self, x, tmp_filename):
 5536:         x.tofile(tmp_filename)
 5537:         y = np.fromfile(tmp_filename, dtype=x.dtype)
 5538:         assert_array_equal(y, x.flat)
 5539: 
 5540:     def test_roundtrip_dump_pathlib(self, x, tmp_filename):
 5541:         p = pathlib.Path(tmp_filename)
 5542:         x.dump(p)
 5543:         y = np.load(p, allow_pickle=True)
 5544:         assert_array_equal(y, x)
 5545: 
 5546:     def test_roundtrip_binary_str(self, x):
 5547:         s = x.tobytes()
 5548:         y = np.frombuffer(s, dtype=x.dtype)
 5549:         assert_array_equal(y, x.flat)
 5550: 
 5551:         s = x.tobytes('F')
 5552:         y = np.frombuffer(s, dtype=x.dtype)
 5553:         assert_array_equal(y, x.flatten('F'))
 5554: 
 5555:     def test_roundtrip_str(self, x):
 5556:         x = x.real.ravel()
 5557:         s = "@".join(map(str, x))
 5558:         y = np.fromstring(s, sep="@")
 5559:         nan_mask = ~np.isfinite(x)
 5560:         assert_array_equal(x[nan_mask], y[nan_mask])
 5561:         assert_array_equal(x[~nan_mask], y[~nan_mask])
 5562: 
 5563:     def test_roundtrip_repr(self, x):
 5564:         x = x.real.ravel()
 5565:         s = "@".join(repr(x)[11:-1] for x in x)
 5566:         y = np.fromstring(s, sep="@")
 5567:         assert_array_equal(x, y)
 5568: 
 5569:     def test_unseekable_fromfile(self, x, tmp_filename):
 5570:         # gh-6246
 5571:         x.tofile(tmp_filename)
 5572: 
 5573:         def fail(*args, **kwargs):
 5574:             raise OSError('Can not tell or seek')
 5575: 
 5576:         with open(tmp_filename, 'rb', buffering=0) as f:
 5577:             f.seek = fail
 5578:             f.tell = fail
 5579:             assert_raises(OSError, np.fromfile, f, dtype=x.dtype)
 5580: 
 5581:     def test_io_open_unbuffered_fromfile(self, x, tmp_filename):
 5582:         # gh-6632
 5583:         x.tofile(tmp_filename)
 5584:         with open(tmp_filename, 'rb', buffering=0) as f:
 5585:             y = np.fromfile(f, dtype=x.dtype)
 5586:             assert_array_equal(y, x.flat)
 5587: 
 5588:     def test_largish_file(self, tmp_filename):
 5589:         # check the fallocate path on files > 16MB
 5590:         d = np.zeros(4 * 1024 ** 2)
 5591:         d.tofile(tmp_filename)
 5592:         assert_equal(os.path.getsize(tmp_filename), d.nbytes)
 5593:         assert_array_equal(d, np.fromfile(tmp_filename))
 5594:         # check offset
 5595:         with open(tmp_filename, "r+b") as f:
 5596:             f.seek(d.nbytes)
 5597:             d.tofile(f)
 5598:             assert_equal(os.path.getsize(tmp_filename), d.nbytes * 2)
 5599:         # check append mode (gh-8329)
 5600:         open(tmp_filename, "w").close()  # delete file contents
 5601:         with open(tmp_filename, "ab") as f:
 5602:             d.tofile(f)
 5603:         assert_array_equal(d, np.fromfile(tmp_filename))
 5604:         with open(tmp_filename, "ab") as f:
 5605:             d.tofile(f)
 5606:         assert_equal(os.path.getsize(tmp_filename), d.nbytes * 2)
 5607: 
 5608:     def test_io_open_buffered_fromfile(self, x, tmp_filename):
 5609:         # gh-6632
 5610:         x.tofile(tmp_filename)
 5611:         with open(tmp_filename, 'rb', buffering=-1) as f:
 5612:             y = np.fromfile(f, dtype=x.dtype)
 5613:         assert_array_equal(y, x.flat)
 5614: 
 5615:     def test_file_position_after_fromfile(self, tmp_filename):
 5616:         # gh-4118
 5617:         sizes = [io.DEFAULT_BUFFER_SIZE // 8,
 5618:                  io.DEFAULT_BUFFER_SIZE,
 5619:                  io.DEFAULT_BUFFER_SIZE * 8]
 5620: 
 5621:         for size in sizes:
 5622:             with open(tmp_filename, 'wb') as f:
 5623:                 f.seek(size - 1)
 5624:                 f.write(b'\0')
 5625: 
 5626:             for mode in ['rb', 'r+b']:
 5627:                 err_msg = "%d %s" % (size, mode)
 5628: 
 5629:                 with open(tmp_filename, mode) as f:
 5630:                     f.read(2)
 5631:                     np.fromfile(f, dtype=np.float64, count=1)
 5632:                     pos = f.tell()
 5633:                 assert_equal(pos, 10, err_msg=err_msg)
 5634: 
 5635:     def test_file_position_after_tofile(self, tmp_filename):
 5636:         # gh-4118
 5637:         sizes = [io.DEFAULT_BUFFER_SIZE // 8,
 5638:                  io.DEFAULT_BUFFER_SIZE,
 5639:                  io.DEFAULT_BUFFER_SIZE * 8]
 5640: 
 5641:         for size in sizes:
 5642:             err_msg = "%d" % (size,)
 5643: 
 5644:             with open(tmp_filename, 'wb') as f:
 5645:                 f.seek(size - 1)
 5646:                 f.write(b'\0')
 5647:                 f.seek(10)
 5648:                 f.write(b'12')
 5649:                 np.array([0], dtype=np.float64).tofile(f)
 5650:                 pos = f.tell()
 5651:             assert_equal(pos, 10 + 2 + 8, err_msg=err_msg)
 5652: 
 5653:             with open(tmp_filename, 'r+b') as f:
 5654:                 f.read(2)
 5655:                 f.seek(0, 1)  # seek between read&write required by ANSI C
 5656:                 np.array([0], dtype=np.float64).tofile(f)
 5657:                 pos = f.tell()
 5658:             assert_equal(pos, 10, err_msg=err_msg)
 5659: 
 5660:     def test_load_object_array_fromfile(self, tmp_filename):
 5661:         # gh-12300
 5662:         with open(tmp_filename, 'w') as f:
 5663:             # Ensure we have a file with consistent contents
 5664:             pass
 5665: 
 5666:         with open(tmp_filename, 'rb') as f:
 5667:             assert_raises_regex(ValueError, "Cannot read into object array",
 5668:                                 np.fromfile, f, dtype=object)
 5669: 
 5670:         assert_raises_regex(ValueError, "Cannot read into object array",
 5671:                             np.fromfile, tmp_filename, dtype=object)
 5672: 
 5673:     def test_fromfile_offset(self, x, tmp_filename):
 5674:         with open(tmp_filename, 'wb') as f:
 5675:             x.tofile(f)
 5676: 
 5677:         with open(tmp_filename, 'rb') as f:
 5678:             y = np.fromfile(f, dtype=x.dtype, offset=0)
 5679:             assert_array_equal(y, x.flat)
 5680: 
 5681:         with open(tmp_filename, 'rb') as f:
 5682:             count_items = len(x.flat) // 8
 5683:             offset_items = len(x.flat) // 4
 5684:             offset_bytes = x.dtype.itemsize * offset_items
 5685:             y = np.fromfile(
 5686:                 f, dtype=x.dtype, count=count_items, offset=offset_bytes
 5687:             )
 5688:             assert_array_equal(
 5689:                 y, x.flat[offset_items:offset_items + count_items]
 5690:             )
 5691: 
 5692:             # subsequent seeks should stack
 5693:             offset_bytes = x.dtype.itemsize
 5694:             z = np.fromfile(f, dtype=x.dtype, offset=offset_bytes)
 5695:             assert_array_equal(z, x.flat[offset_items + count_items + 1:])
 5696: 
 5697:         with open(tmp_filename, 'wb') as f:
 5698:             x.tofile(f, sep=",")
 5699: 
 5700:         with open(tmp_filename, 'rb') as f:
 5701:             assert_raises_regex(
 5702:                     TypeError,
 5703:                     "'offset' argument only permitted for binary files",
 5704:                     np.fromfile, tmp_filename, dtype=x.dtype,
 5705:                     sep=",", offset=1)
 5706: 
 5707:     @pytest.mark.skipif(IS_PYPY, reason="bug in PyPy's PyNumber_AsSsize_t")
 5708:     def test_fromfile_bad_dup(self, x, tmp_filename):
 5709:         def dup_str(fd):
 5710:             return 'abc'
 5711: 
 5712:         def dup_bigint(fd):
 5713:             return 2**68
 5714: 
 5715:         old_dup = os.dup
 5716:         try:
 5717:             with open(tmp_filename, 'wb') as f:
 5718:                 x.tofile(f)
 5719:                 for dup, exc in ((dup_str, TypeError), (dup_bigint, OSError)):
 5720:                     os.dup = dup
 5721:                     assert_raises(exc, np.fromfile, f)
 5722:         finally:
 5723:             os.dup = old_dup
 5724: 
 5725:     def _check_from(self, s, value, filename, **kw):
 5726:         if 'sep' not in kw:
 5727:             y = np.frombuffer(s, **kw)
 5728:         else:
 5729:             y = np.fromstring(s, **kw)
 5730:         assert_array_equal(y, value)
 5731: 
 5732:         with open(filename, 'wb') as f:
 5733:             f.write(s)
 5734:         y = np.fromfile(filename, **kw)
 5735:         assert_array_equal(y, value)
 5736: 
 5737:     @pytest.fixture(params=["period", "comma"])
 5738:     def decimal_sep_localization(self, request):
 5739:         """
 5740:         Including this fixture in a test will automatically
 5741:         execute it with both types of decimal separator.
 5742: 
 5743:         So::
 5744: 
 5745:             def test_decimal(decimal_sep_localization):
 5746:                 pass
 5747: 
 5748:         is equivalent to the following two tests::
 5749: 
 5750:             def test_decimal_period_separator():
 5751:                 pass
 5752: 
 5753:             def test_decimal_comma_separator():
 5754:                 with CommaDecimalPointLocale():
 5755:                     pass
 5756:         """
 5757:         if request.param == "period":
 5758:             yield
 5759:         elif request.param == "comma":
 5760:             with CommaDecimalPointLocale():
 5761:                 yield
 5762:         else:
 5763:             assert False, request.param
 5764: 
 5765:     def test_nan(self, tmp_filename, decimal_sep_localization):
 5766:         self._check_from(
 5767:             b"nan +nan -nan NaN nan(foo) +NaN(BAR) -NAN(q_u_u_x_)",
 5768:             [np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan],
 5769:             tmp_filename,
 5770:             sep=' ')
 5771: 
 5772:     def test_inf(self, tmp_filename, decimal_sep_localization):
 5773:         self._check_from(
 5774:             b"inf +inf -inf infinity -Infinity iNfInItY -inF",
 5775:             [np.inf, np.inf, -np.inf, np.inf, -np.inf, np.inf, -np.inf],
 5776:             tmp_filename,
 5777:             sep=' ')
 5778: 
 5779:     def test_numbers(self, tmp_filename, decimal_sep_localization):
 5780:         self._check_from(
 5781:             b"1.234 -1.234 .3 .3e55 -123133.1231e+133",
 5782:             [1.234, -1.234, .3, .3e55, -123133.1231e+133],
 5783:             tmp_filename,
 5784:             sep=' ')
 5785: 
 5786:     def test_binary(self, tmp_filename):
 5787:         self._check_from(
 5788:             b'\x00\x00\x80?\x00\x00\x00@\x00\x00@@\x00\x00\x80@',
 5789:             np.array([1, 2, 3, 4]),
 5790:             tmp_filename,
 5791:             dtype='<f4')
 5792: 
 5793:     def test_string(self, tmp_filename):
 5794:         self._check_from(b'1,2,3,4', [1., 2., 3., 4.], tmp_filename, sep=',')
 5795: 
 5796:     def test_counted_string(self, tmp_filename, decimal_sep_localization):
 5797:         self._check_from(
 5798:             b'1,2,3,4', [1., 2., 3., 4.], tmp_filename, count=4, sep=',')
 5799:         self._check_from(
 5800:             b'1,2,3,4', [1., 2., 3.], tmp_filename, count=3, sep=',')
 5801:         self._check_from(
 5802:             b'1,2,3,4', [1., 2., 3., 4.], tmp_filename, count=-1, sep=',')
 5803: 
 5804:     def test_string_with_ws(self, tmp_filename):
 5805:         self._check_from(
 5806:             b'1 2  3     4   ', [1, 2, 3, 4], tmp_filename, dtype=int, sep=' ')
 5807: 
 5808:     def test_counted_string_with_ws(self, tmp_filename):
 5809:         self._check_from(
 5810:             b'1 2  3     4   ', [1, 2, 3], tmp_filename, count=3, dtype=int,
 5811:             sep=' ')
 5812: 
 5813:     def test_ascii(self, tmp_filename, decimal_sep_localization):
 5814:         self._check_from(
 5815:             b'1 , 2 , 3 , 4', [1., 2., 3., 4.], tmp_filename, sep=',')
 5816:         self._check_from(
 5817:             b'1,2,3,4', [1., 2., 3., 4.], tmp_filename, dtype=float, sep=',')
 5818: 
 5819:     def test_malformed(self, tmp_filename, decimal_sep_localization):
 5820:         with assert_raises(ValueError):
 5821:             self._check_from(
 5822:                 b'1.234 1,234', [1.234, 1.], tmp_filename, sep=' ')
 5823: 
 5824:     def test_long_sep(self, tmp_filename):
 5825:         self._check_from(
 5826:             b'1_x_3_x_4_x_5', [1, 3, 4, 5], tmp_filename, sep='_x_')
 5827: 
 5828:     def test_dtype(self, tmp_filename):
 5829:         v = np.array([1, 2, 3, 4], dtype=np.int_)
 5830:         self._check_from(b'1,2,3,4', v, tmp_filename, sep=',', dtype=np.int_)
 5831: 
 5832:     def test_dtype_bool(self, tmp_filename):
 5833:         # can't use _check_from because fromstring can't handle True/False
 5834:         v = np.array([True, False, True, False], dtype=np.bool)
 5835:         s = b'1,0,-2.3,0'
 5836:         with open(tmp_filename, 'wb') as f:
 5837:             f.write(s)
 5838:         y = np.fromfile(tmp_filename, sep=',', dtype=np.bool)
 5839:         assert_(y.dtype == '?')
 5840:         assert_array_equal(y, v)
 5841: 
 5842:     def test_tofile_sep(self, tmp_filename, decimal_sep_localization):
 5843:         x = np.array([1.51, 2, 3.51, 4], dtype=float)
 5844:         with open(tmp_filename, 'w') as f:
 5845:             x.tofile(f, sep=',')
 5846:         with open(tmp_filename, 'r') as f:
 5847:             s = f.read()
 5848:         #assert_equal(s, '1.51,2.0,3.51,4.0')
 5849:         y = np.array([float(p) for p in s.split(',')])
 5850:         assert_array_equal(x, y)
 5851: 
 5852:     def test_tofile_format(self, tmp_filename, decimal_sep_localization):
 5853:         x = np.array([1.51, 2, 3.51, 4], dtype=float)
 5854:         with open(tmp_filename, 'w') as f:
 5855:             x.tofile(f, sep=',', format='%.2f')
 5856:         with open(tmp_filename, 'r') as f:
 5857:             s = f.read()
 5858:         assert_equal(s, '1.51,2.00,3.51,4.00')
 5859: 
 5860:     def test_tofile_cleanup(self, tmp_filename):
 5861:         x = np.zeros((10), dtype=object)
 5862:         with open(tmp_filename, 'wb') as f:
 5863:             assert_raises(OSError, lambda: x.tofile(f, sep=''))
 5864:         # Dup-ed file handle should be closed or remove will fail on Windows OS
 5865:         os.remove(tmp_filename)
 5866: 
 5867:         # Also make sure that we close the Python handle
 5868:         assert_raises(OSError, lambda: x.tofile(tmp_filename))
 5869:         os.remove(tmp_filename)
 5870: 
 5871:     def test_fromfile_subarray_binary(self, tmp_filename):
 5872:         # Test subarray dtypes which are absorbed into the shape
 5873:         x = np.arange(24, dtype="i4").reshape(2, 3, 4)
 5874:         x.tofile(tmp_filename)
 5875:         res = np.fromfile(tmp_filename, dtype="(3,4)i4")
 5876:         assert_array_equal(x, res)
 5877: 
 5878:         x_str = x.tobytes()
 5879:         with pytest.raises(ValueError):
 5880:             # binary fromstring raises
 5881:             np.fromstring(x_str, dtype="(3,4)i4")
 5882: 
 5883:     def test_parsing_subarray_unsupported(self, tmp_filename):
 5884:         # We currently do not support parsing subarray dtypes
 5885:         data = "12,42,13," * 50
 5886:         with pytest.raises(ValueError):
 5887:             expected = np.fromstring(data, dtype="(3,)i", sep=",")
 5888: 
 5889:         with open(tmp_filename, "w") as f:
 5890:             f.write(data)
 5891: 
 5892:         with pytest.raises(ValueError):
 5893:             np.fromfile(tmp_filename, dtype="(3,)i", sep=",")
 5894: 
 5895:     def test_read_shorter_than_count_subarray(self, tmp_filename):
 5896:         # Test that requesting more values does not cause any problems
 5897:         # in conjunction with subarray dimensions being absorbed into the
 5898:         # array dimension.
 5899:         expected = np.arange(511 * 10, dtype="i").reshape(-1, 10)
 5900: 
 5901:         binary = expected.tobytes()
 5902:         with pytest.raises(ValueError):
 5903:             np.fromstring(binary, dtype="(10,)i", count=10000)
 5904: 
 5905:         expected.tofile(tmp_filename)
 5906:         res = np.fromfile(tmp_filename, dtype="(10,)i", count=10000)
 5907:         assert_array_equal(res, expected)
 5908: 
 5909: 
 5910: class TestFromBuffer:
 5911:     @pytest.mark.parametrize('byteorder', ['<', '>'])
 5912:     @pytest.mark.parametrize('dtype', [float, int, complex])
 5913:     def test_basic(self, byteorder, dtype):
 5914:         dt = np.dtype(dtype).newbyteorder(byteorder)
 5915:         x = (np.random.random((4, 7)) * 5).astype(dt)
 5916:         buf = x.tobytes()
 5917:         assert_array_equal(np.frombuffer(buf, dtype=dt), x.flat)
 5918: 
 5919:     @pytest.mark.parametrize("obj", [np.arange(10), b"12345678"])
 5920:     def test_array_base(self, obj):
 5921:         # Objects (including NumPy arrays), which do not use the
 5922:         # `release_buffer` slot should be directly used as a base object.
 5923:         # See also gh-21612
 5924:         new = np.frombuffer(obj)
 5925:         assert new.base is obj
 5926: 
 5927:     def test_empty(self):
 5928:         assert_array_equal(np.frombuffer(b''), np.array([]))
 5929: 
 5930:     @pytest.mark.skipif(IS_PYPY,
 5931:             reason="PyPy's memoryview currently does not track exports. See: "
 5932:                    "https://foss.heptapod.net/pypy/pypy/-/issues/3724")
 5933:     def test_mmap_close(self):
 5934:         # The old buffer protocol was not safe for some things that the new
 5935:         # one is.  But `frombuffer` always used the old one for a long time.
 5936:         # Checks that it is safe with the new one (using memoryviews)
 5937:         with tempfile.TemporaryFile(mode='wb') as tmp:
 5938:             tmp.write(b"asdf")
 5939:             tmp.flush()
 5940:             mm = mmap.mmap(tmp.fileno(), 0)
 5941:             arr = np.frombuffer(mm, dtype=np.uint8)
 5942:             with pytest.raises(BufferError):
 5943:                 mm.close()  # cannot close while array uses the buffer
 5944:             del arr
 5945:             mm.close()
 5946: 
 5947: class TestFlat:
 5948:     def setup_method(self):
 5949:         a0 = np.arange(20.0)
 5950:         a = a0.reshape(4, 5)
 5951:         a0.shape = (4, 5)
 5952:         a.flags.writeable = False
 5953:         self.a = a
 5954:         self.b = a[::2, ::2]
 5955:         self.a0 = a0
 5956:         self.b0 = a0[::2, ::2]
 5957: 
 5958:     def test_contiguous(self):
 5959:         testpassed = False
 5960:         try:
 5961:             self.a.flat[12] = 100.0
 5962:         except ValueError:
 5963:             testpassed = True
 5964:         assert_(testpassed)
 5965:         assert_(self.a.flat[12] == 12.0)
 5966: 
 5967:     def test_discontiguous(self):
 5968:         testpassed = False
 5969:         try:
 5970:             self.b.flat[4] = 100.0
 5971:         except ValueError:
 5972:             testpassed = True
 5973:         assert_(testpassed)
 5974:         assert_(self.b.flat[4] == 12.0)
 5975: 
 5976:     def test___array__(self):
 5977:         c = self.a.flat.__array__()
 5978:         d = self.b.flat.__array__()
 5979:         e = self.a0.flat.__array__()
 5980:         f = self.b0.flat.__array__()
 5981: 
 5982:         assert_(c.flags.writeable is False)
 5983:         assert_(d.flags.writeable is False)
 5984:         assert_(e.flags.writeable is True)
 5985:         assert_(f.flags.writeable is False)
 5986:         assert_(c.flags.writebackifcopy is False)
 5987:         assert_(d.flags.writebackifcopy is False)
 5988:         assert_(e.flags.writebackifcopy is False)
 5989:         assert_(f.flags.writebackifcopy is False)
 5990: 
 5991:     @pytest.mark.skipif(not HAS_REFCOUNT, reason="Python lacks refcounts")
 5992:     def test_refcount(self):
 5993:         # includes regression test for reference count error gh-13165
 5994:         inds = [np.intp(0), np.array([True] * self.a.size), np.array([0]), None]
 5995:         indtype = np.dtype(np.intp)
 5996:         rc_indtype = sys.getrefcount(indtype)
 5997:         for ind in inds:
 5998:             rc_ind = sys.getrefcount(ind)
 5999:             for _ in range(100):
 6000:                 try:
 6001:                     self.a.flat[ind]
 6002:                 except IndexError:
 6003:                     pass
 6004:             assert_(abs(sys.getrefcount(ind) - rc_ind) < 50)
 6005:             assert_(abs(sys.getrefcount(indtype) - rc_indtype) < 50)
 6006: 
 6007:     def test_index_getset(self):
 6008:         it = np.arange(10).reshape(2, 1, 5).flat
 6009:         with pytest.raises(AttributeError):
 6010:             it.index = 10
 6011: 
 6012:         for _ in it:
 6013:             pass
 6014:         # Check the value of `.index` is updated correctly (see also gh-19153)
 6015:         # If the type was incorrect, this would show up on big-endian machines
 6016:         assert it.index == it.base.size
 6017: 
 6018:     def test_maxdims(self):
 6019:         # The flat iterator and thus attribute is currently unfortunately
 6020:         # limited to only 32 dimensions (after bumping it to 64 for 2.0)
 6021:         a = np.ones((1,) * 64)
 6022: 
 6023:         with pytest.raises(RuntimeError,
 6024:                 match=".*32 dimensions but the array has 64"):
 6025:             a.flat
 6026: 
 6027: 
 6028: class TestResize:
 6029: 
 6030:     @_no_tracing
 6031:     def test_basic(self):
 6032:         x = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])
 6033:         if IS_PYPY:
 6034:             x.resize((5, 5), refcheck=False)
 6035:         else:
 6036:             x.resize((5, 5))
 6037:         assert_array_equal(x.flat[:9],
 6038:                 np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]]).flat)
 6039:         assert_array_equal(x[9:].flat, 0)
 6040: 
 6041:     def test_check_reference(self):
 6042:         x = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])
 6043:         y = x
 6044:         assert_raises(ValueError, x.resize, (5, 1))
 6045: 
 6046:     @_no_tracing
 6047:     def test_int_shape(self):
 6048:         x = np.eye(3)
 6049:         if IS_PYPY:
 6050:             x.resize(3, refcheck=False)
 6051:         else:
 6052:             x.resize(3)
 6053:         assert_array_equal(x, np.eye(3)[0, :])
 6054: 
 6055:     def test_none_shape(self):
 6056:         x = np.eye(3)
 6057:         x.resize(None)
 6058:         assert_array_equal(x, np.eye(3))
 6059:         x.resize()
 6060:         assert_array_equal(x, np.eye(3))
 6061: 
 6062:     def test_0d_shape(self):
 6063:         # to it multiple times to test it does not break alloc cache gh-9216
 6064:         for i in range(10):
 6065:             x = np.empty((1,))
 6066:             x.resize(())
 6067:             assert_equal(x.shape, ())
 6068:             assert_equal(x.size, 1)
 6069:             x = np.empty(())
 6070:             x.resize((1,))
 6071:             assert_equal(x.shape, (1,))
 6072:             assert_equal(x.size, 1)
 6073: 
 6074:     def test_invalid_arguments(self):
 6075:         assert_raises(TypeError, np.eye(3).resize, 'hi')
 6076:         assert_raises(ValueError, np.eye(3).resize, -1)
 6077:         assert_raises(TypeError, np.eye(3).resize, order=1)
 6078:         assert_raises(TypeError, np.eye(3).resize, refcheck='hi')
 6079: 
 6080:     @_no_tracing
 6081:     def test_freeform_shape(self):
 6082:         x = np.eye(3)
 6083:         if IS_PYPY:
 6084:             x.resize(3, 2, 1, refcheck=False)
 6085:         else:
 6086:             x.resize(3, 2, 1)
 6087:         assert_(x.shape == (3, 2, 1))
 6088: 
 6089:     @_no_tracing
 6090:     def test_zeros_appended(self):
 6091:         x = np.eye(3)
 6092:         if IS_PYPY:
 6093:             x.resize(2, 3, 3, refcheck=False)
 6094:         else:
 6095:             x.resize(2, 3, 3)
 6096:         assert_array_equal(x[0], np.eye(3))
 6097:         assert_array_equal(x[1], np.zeros((3, 3)))
 6098: 
 6099:     @_no_tracing
 6100:     def test_obj_obj(self):
 6101:         # check memory is initialized on resize, gh-4857
 6102:         a = np.ones(10, dtype=[('k', object, 2)])
 6103:         if IS_PYPY:
 6104:             a.resize(15, refcheck=False)
 6105:         else:
 6106:             a.resize(15,)
 6107:         assert_equal(a.shape, (15,))
 6108:         assert_array_equal(a['k'][-5:], 0)
 6109:         assert_array_equal(a['k'][:-5], 1)
 6110: 
 6111:     def test_empty_view(self):
 6112:         # check that sizes containing a zero don't trigger a reallocate for
 6113:         # already empty arrays
 6114:         x = np.zeros((10, 0), int)
 6115:         x_view = x[...]
 6116:         x_view.resize((0, 10))
 6117:         x_view.resize((0, 100))
 6118: 
 6119:     def test_check_weakref(self):
 6120:         x = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])
 6121:         xref = weakref.ref(x)
 6122:         assert_raises(ValueError, x.resize, (5, 1))
 6123: 
 6124: 
 6125: class TestRecord:
 6126:     def test_field_rename(self):
 6127:         dt = np.dtype([('f', float), ('i', int)])
 6128:         dt.names = ['p', 'q']
 6129:         assert_equal(dt.names, ['p', 'q'])
 6130: 
 6131:     def test_multiple_field_name_occurrence(self):
 6132:         def test_dtype_init():
 6133:             np.dtype([("A", "f8"), ("B", "f8"), ("A", "f8")])
 6134: 
 6135:         # Error raised when multiple fields have the same name
 6136:         assert_raises(ValueError, test_dtype_init)
 6137: 
 6138:     def test_bytes_fields(self):
 6139:         # Bytes are not allowed in field names and not recognized in titles
 6140:         # on Py3
 6141:         assert_raises(TypeError, np.dtype, [(b'a', int)])
 6142:         assert_raises(TypeError, np.dtype, [(('b', b'a'), int)])
 6143: 
 6144:         dt = np.dtype([((b'a', 'b'), int)])
 6145:         assert_raises(TypeError, dt.__getitem__, b'a')
 6146: 
 6147:         x = np.array([(1,), (2,), (3,)], dtype=dt)
 6148:         assert_raises(IndexError, x.__getitem__, b'a')
 6149: 
 6150:         y = x[0]
 6151:         assert_raises(IndexError, y.__getitem__, b'a')
 6152: 
 6153:     def test_multiple_field_name_unicode(self):
 6154:         def test_dtype_unicode():
 6155:             np.dtype([("\u20B9", "f8"), ("B", "f8"), ("\u20B9", "f8")])
 6156: 
 6157:         # Error raised when multiple fields have the same name(unicode included)
 6158:         assert_raises(ValueError, test_dtype_unicode)
 6159: 
 6160:     def test_fromarrays_unicode(self):
 6161:         # A single name string provided to fromarrays() is allowed to be unicode
 6162:         x = np._core.records.fromarrays(
 6163:             [[0], [1]], names='a,b', formats='i4,i4')
 6164:         assert_equal(x['a'][0], 0)
 6165:         assert_equal(x['b'][0], 1)
 6166: 
 6167:     def test_unicode_order(self):
 6168:         # Test that we can sort with order as a unicode field name
 6169:         name = 'b'
 6170:         x = np.array([1, 3, 2], dtype=[(name, int)])
 6171:         x.sort(order=name)
 6172:         assert_equal(x['b'], np.array([1, 2, 3]))
 6173: 
 6174:     def test_field_names(self):
 6175:         # Test unicode and 8-bit / byte strings can be used
 6176:         a = np.zeros((1,), dtype=[('f1', 'i4'),
 6177:                                   ('f2', 'i4'),
 6178:                                   ('f3', [('sf1', 'i4')])])
 6179:         # byte string indexing fails gracefully
 6180:         assert_raises(IndexError, a.__setitem__, b'f1', 1)
 6181:         assert_raises(IndexError, a.__getitem__, b'f1')
 6182:         assert_raises(IndexError, a['f1'].__setitem__, b'sf1', 1)
 6183:         assert_raises(IndexError, a['f1'].__getitem__, b'sf1')
 6184:         b = a.copy()
 6185:         fn1 = 'f1'
 6186:         b[fn1] = 1
 6187:         assert_equal(b[fn1], 1)
 6188:         fnn = 'not at all'
 6189:         assert_raises(ValueError, b.__setitem__, fnn, 1)
 6190:         assert_raises(ValueError, b.__getitem__, fnn)
 6191:         b[0][fn1] = 2
 6192:         assert_equal(b[fn1], 2)
 6193:         # Subfield
 6194:         assert_raises(ValueError, b[0].__setitem__, fnn, 1)
 6195:         assert_raises(ValueError, b[0].__getitem__, fnn)
 6196:         # Subfield
 6197:         fn3 = 'f3'
 6198:         sfn1 = 'sf1'
 6199:         b[fn3][sfn1] = 1
 6200:         assert_equal(b[fn3][sfn1], 1)
 6201:         assert_raises(ValueError, b[fn3].__setitem__, fnn, 1)
 6202:         assert_raises(ValueError, b[fn3].__getitem__, fnn)
 6203:         # multiple subfields
 6204:         fn2 = 'f2'
 6205:         b[fn2] = 3
 6206: 
 6207:         assert_equal(b[['f1', 'f2']][0].tolist(), (2, 3))
 6208:         assert_equal(b[['f2', 'f1']][0].tolist(), (3, 2))
 6209:         assert_equal(b[['f1', 'f3']][0].tolist(), (2, (1,)))
 6210: 
 6211:         # non-ascii unicode field indexing is well behaved
 6212:         assert_raises(ValueError, a.__setitem__, '\u03e0', 1)
 6213:         assert_raises(ValueError, a.__getitem__, '\u03e0')
 6214: 
 6215:     def test_record_hash(self):
 6216:         a = np.array([(1, 2), (1, 2)], dtype='i1,i2')
 6217:         a.flags.writeable = False
 6218:         b = np.array([(1, 2), (3, 4)], dtype=[('num1', 'i1'), ('num2', 'i2')])
 6219:         b.flags.writeable = False
 6220:         c = np.array([(1, 2), (3, 4)], dtype='i1,i2')
 6221:         c.flags.writeable = False
 6222:         assert_(hash(a[0]) == hash(a[1]))
 6223:         assert_(hash(a[0]) == hash(b[0]))
 6224:         assert_(hash(a[0]) != hash(b[1]))
 6225:         assert_(hash(c[0]) == hash(a[0]) and c[0] == a[0])
 6226: 
 6227:     def test_record_no_hash(self):
 6228:         a = np.array([(1, 2), (1, 2)], dtype='i1,i2')
 6229:         assert_raises(TypeError, hash, a[0])
 6230: 
 6231:     def test_empty_structure_creation(self):
 6232:         # make sure these do not raise errors (gh-5631)
 6233:         np.array([()], dtype={'names': [], 'formats': [],
 6234:                            'offsets': [], 'itemsize': 12})
 6235:         np.array([(), (), (), (), ()], dtype={'names': [], 'formats': [],
 6236:                                            'offsets': [], 'itemsize': 12})
 6237: 
 6238:     def test_multifield_indexing_view(self):
 6239:         a = np.ones(3, dtype=[('a', 'i4'), ('b', 'f4'), ('c', 'u4')])
 6240:         v = a[['a', 'c']]
 6241:         assert_(v.base is a)
 6242:         assert_(v.dtype == np.dtype({'names': ['a', 'c'],
 6243:                                      'formats': ['i4', 'u4'],
 6244:                                      'offsets': [0, 8]}))
 6245:         v[:] = (4, 5)
 6246:         assert_equal(a[0].item(), (4, 1, 5))
 6247: 
 6248: class TestView:
 6249:     def test_basic(self):
 6250:         x = np.array([(1, 2, 3, 4), (5, 6, 7, 8)],
 6251:                      dtype=[('r', np.int8), ('g', np.int8),
 6252:                             ('b', np.int8), ('a', np.int8)])
 6253:         # We must be specific about the endianness here:
 6254:         y = x.view(dtype='<i4')
 6255:         # ... and again without the keyword.
 6256:         z = x.view('<i4')
 6257:         assert_array_equal(y, z)
 6258:         assert_array_equal(y, [67305985, 134678021])
 6259: 
 6260: 
 6261: def _mean(a, **args):
 6262:     return a.mean(**args)
 6263: 
 6264: 
 6265: def _var(a, **args):
 6266:     return a.var(**args)
 6267: 
 6268: 
 6269: def _std(a, **args):
 6270:     return a.std(**args)
 6271: 
 6272: 
 6273: class TestStats:
 6274: 
 6275:     funcs = [_mean, _var, _std]
 6276: 
 6277:     def setup_method(self):
 6278:         np.random.seed(range(3))
 6279:         self.rmat = np.random.random((4, 5))
 6280:         self.cmat = self.rmat + 1j * self.rmat
 6281:         self.omat = np.array([Decimal(str(r)) for r in self.rmat.flat])
 6282:         self.omat = self.omat.reshape(4, 5)
 6283: 
 6284:     def test_python_type(self):
 6285:         for x in (np.float16(1.), 1, 1., 1 + 0j):
 6286:             assert_equal(np.mean([x]), 1.)
 6287:             assert_equal(np.std([x]), 0.)
 6288:             assert_equal(np.var([x]), 0.)
 6289: 
 6290:     def test_keepdims(self):
 6291:         mat = np.eye(3)
 6292:         for f in self.funcs:
 6293:             for axis in [0, 1]:
 6294:                 res = f(mat, axis=axis, keepdims=True)
 6295:                 assert_(res.ndim == mat.ndim)
 6296:                 assert_(res.shape[axis] == 1)
 6297:             for axis in [None]:
 6298:                 res = f(mat, axis=axis, keepdims=True)
 6299:                 assert_(res.shape == (1, 1))
 6300: 
 6301:     def test_out(self):
 6302:         mat = np.eye(3)
 6303:         for f in self.funcs:
 6304:             out = np.zeros(3)
 6305:             tgt = f(mat, axis=1)
 6306:             res = f(mat, axis=1, out=out)
 6307:             assert_almost_equal(res, out)
 6308:             assert_almost_equal(res, tgt)
 6309:         out = np.empty(2)
 6310:         assert_raises(ValueError, f, mat, axis=1, out=out)
 6311:         out = np.empty((2, 2))
 6312:         assert_raises(ValueError, f, mat, axis=1, out=out)
 6313: 
 6314:     def test_dtype_from_input(self):
 6315: 
 6316:         icodes = np.typecodes['AllInteger']
 6317:         fcodes = np.typecodes['AllFloat']
 6318: 
 6319:         # object type
 6320:         for f in self.funcs:
 6321:             mat = np.array([[Decimal(1)] * 3] * 3)
 6322:             tgt = mat.dtype.type
 6323:             res = f(mat, axis=1).dtype.type
 6324:             assert_(res is tgt)
 6325:             # scalar case
 6326:             res = type(f(mat, axis=None))
 6327:             assert_(res is Decimal)
 6328: 
 6329:         # integer types
 6330:         for f in self.funcs:
 6331:             for c in icodes:
 6332:                 mat = np.eye(3, dtype=c)
 6333:                 tgt = np.float64
 6334:                 res = f(mat, axis=1).dtype.type
 6335:                 assert_(res is tgt)
 6336:                 # scalar case
 6337:                 res = f(mat, axis=None).dtype.type
 6338:                 assert_(res is tgt)
 6339: 
 6340:         # mean for float types
 6341:         for f in [_mean]:
 6342:             for c in fcodes:
 6343:                 mat = np.eye(3, dtype=c)
 6344:                 tgt = mat.dtype.type
 6345:                 res = f(mat, axis=1).dtype.type
 6346:                 assert_(res is tgt)
 6347:                 # scalar case
 6348:                 res = f(mat, axis=None).dtype.type
 6349:                 assert_(res is tgt)
 6350: 
 6351:         # var, std for float types
 6352:         for f in [_var, _std]:
 6353:             for c in fcodes:
 6354:                 mat = np.eye(3, dtype=c)
 6355:                 # deal with complex types
 6356:                 tgt = mat.real.dtype.type
 6357:                 res = f(mat, axis=1).dtype.type
 6358:                 assert_(res is tgt)
 6359:                 # scalar case
 6360:                 res = f(mat, axis=None).dtype.type
 6361:                 assert_(res is tgt)
 6362: 
 6363:     def test_dtype_from_dtype(self):
 6364:         mat = np.eye(3)
 6365: 
 6366:         # stats for integer types
 6367:         # FIXME:
 6368:         # this needs definition as there are lots places along the line
 6369:         # where type casting may take place.
 6370: 
 6371:         # for f in self.funcs:
 6372:         #    for c in np.typecodes['AllInteger']:
 6373:         #        tgt = np.dtype(c).type
 6374:         #        res = f(mat, axis=1, dtype=c).dtype.type
 6375:         #        assert_(res is tgt)
 6376:         #        # scalar case
 6377:         #        res = f(mat, axis=None, dtype=c).dtype.type
 6378:         #        assert_(res is tgt)
 6379: 
 6380:         # stats for float types
 6381:         for f in self.funcs:
 6382:             for c in np.typecodes['AllFloat']:
 6383:                 tgt = np.dtype(c).type
 6384:                 res = f(mat, axis=1, dtype=c).dtype.type
 6385:                 assert_(res is tgt)
 6386:                 # scalar case
 6387:                 res = f(mat, axis=None, dtype=c).dtype.type
 6388:                 assert_(res is tgt)
 6389: 
 6390:     def test_ddof(self):
 6391:         for f in [_var]:
 6392:             for ddof in range(3):
 6393:                 dim = self.rmat.shape[1]
 6394:                 tgt = f(self.rmat, axis=1) * dim
 6395:                 res = f(self.rmat, axis=1, ddof=ddof) * (dim - ddof)
 6396:         for f in [_std]:
 6397:             for ddof in range(3):
 6398:                 dim = self.rmat.shape[1]
 6399:                 tgt = f(self.rmat, axis=1) * np.sqrt(dim)
 6400:                 res = f(self.rmat, axis=1, ddof=ddof) * np.sqrt(dim - ddof)
 6401:                 assert_almost_equal(res, tgt)
 6402:                 assert_almost_equal(res, tgt)
 6403: 
 6404:     def test_ddof_too_big(self):
 6405:         dim = self.rmat.shape[1]
 6406:         for f in [_var, _std]:
 6407:             for ddof in range(dim, dim + 2):
 6408:                 with warnings.catch_warnings(record=True) as w:
 6409:                     warnings.simplefilter('always')
 6410:                     res = f(self.rmat, axis=1, ddof=ddof)
 6411:                     assert_(not (res < 0).any())
 6412:                     assert_(len(w) > 0)
 6413:                     assert_(issubclass(w[0].category, RuntimeWarning))
 6414: 
 6415:     def test_empty(self):
 6416:         A = np.zeros((0, 3))
 6417:         for f in self.funcs:
 6418:             for axis in [0, None]:
 6419:                 with warnings.catch_warnings(record=True) as w:
 6420:                     warnings.simplefilter('always')
 6421:                     assert_(np.isnan(f(A, axis=axis)).all())
 6422:                     assert_(len(w) > 0)
 6423:                     assert_(issubclass(w[0].category, RuntimeWarning))
 6424:             for axis in [1]:
 6425:                 with warnings.catch_warnings(record=True) as w:
 6426:                     warnings.simplefilter('always')
 6427:                     assert_equal(f(A, axis=axis), np.zeros([]))
 6428: 
 6429:     def test_mean_values(self):
 6430:         for mat in [self.rmat, self.cmat, self.omat]:
 6431:             for axis in [0, 1]:
 6432:                 tgt = mat.sum(axis=axis)
 6433:                 res = _mean(mat, axis=axis) * mat.shape[axis]
 6434:                 assert_almost_equal(res, tgt)
 6435:             for axis in [None]:
 6436:                 tgt = mat.sum(axis=axis)
 6437:                 res = _mean(mat, axis=axis) * np.prod(mat.shape)
 6438:                 assert_almost_equal(res, tgt)
 6439: 
 6440:     def test_mean_float16(self):
 6441:         # This fail if the sum inside mean is done in float16 instead
 6442:         # of float32.
 6443:         assert_(_mean(np.ones(100000, dtype='float16')) == 1)
 6444: 
 6445:     def test_mean_axis_error(self):
 6446:         # Ensure that AxisError is raised instead of IndexError when axis is
 6447:         # out of bounds, see gh-15817.
 6448:         with assert_raises(np.exceptions.AxisError):
 6449:             np.arange(10).mean(axis=2)
 6450: 
 6451:     def test_mean_where(self):
 6452:         a = np.arange(16).reshape((4, 4))
 6453:         wh_full = np.array([[False, True, False, True],
 6454:                             [True, False, True, False],
 6455:                             [True, True, False, False],
 6456:                             [False, False, True, True]])
 6457:         wh_partial = np.array([[False],
 6458:                                [True],
 6459:                                [True],
 6460:                                [False]])
 6461:         _cases = [(1, True, [1.5, 5.5, 9.5, 13.5]),
 6462:                   (0, wh_full, [6., 5., 10., 9.]),
 6463:                   (1, wh_full, [2., 5., 8.5, 14.5]),
 6464:                   (0, wh_partial, [6., 7., 8., 9.])]
 6465:         for _ax, _wh, _res in _cases:
 6466:             assert_allclose(a.mean(axis=_ax, where=_wh),
 6467:                             np.array(_res))
 6468:             assert_allclose(np.mean(a, axis=_ax, where=_wh),
 6469:                             np.array(_res))
 6470: 
 6471:         a3d = np.arange(16).reshape((2, 2, 4))
 6472:         _wh_partial = np.array([False, True, True, False])
 6473:         _res = [[1.5, 5.5], [9.5, 13.5]]
 6474:         assert_allclose(a3d.mean(axis=2, where=_wh_partial),
 6475:                         np.array(_res))
 6476:         assert_allclose(np.mean(a3d, axis=2, where=_wh_partial),
 6477:                         np.array(_res))
 6478: 
 6479:         with pytest.warns(RuntimeWarning) as w:
 6480:             assert_allclose(a.mean(axis=1, where=wh_partial),
 6481:                             np.array([np.nan, 5.5, 9.5, np.nan]))
 6482:         with pytest.warns(RuntimeWarning) as w:
 6483:             assert_equal(a.mean(where=False), np.nan)
 6484:         with pytest.warns(RuntimeWarning) as w:
 6485:             assert_equal(np.mean(a, where=False), np.nan)
 6486: 
 6487:     def test_var_values(self):
 6488:         for mat in [self.rmat, self.cmat, self.omat]:
 6489:             for axis in [0, 1, None]:
 6490:                 msqr = _mean(mat * mat.conj(), axis=axis)
 6491:                 mean = _mean(mat, axis=axis)
 6492:                 tgt = msqr - mean * mean.conjugate()
 6493:                 res = _var(mat, axis=axis)
 6494:                 assert_almost_equal(res, tgt)
 6495: 
 6496:     @pytest.mark.parametrize(('complex_dtype', 'ndec'), (
 6497:         ('complex64', 6),
 6498:         ('complex128', 7),
 6499:         ('clongdouble', 7),
 6500:     ))
 6501:     def test_var_complex_values(self, complex_dtype, ndec):
 6502:         # Test fast-paths for every builtin complex type
 6503:         for axis in [0, 1, None]:
 6504:             mat = self.cmat.copy().astype(complex_dtype)
 6505:             msqr = _mean(mat * mat.conj(), axis=axis)
 6506:             mean = _mean(mat, axis=axis)
 6507:             tgt = msqr - mean * mean.conjugate()
 6508:             res = _var(mat, axis=axis)
 6509:             assert_almost_equal(res, tgt, decimal=ndec)
 6510: 
 6511:     def test_var_dimensions(self):
 6512:         # _var paths for complex number introduce additions on views that
 6513:         # increase dimensions. Ensure this generalizes to higher dims
 6514:         mat = np.stack([self.cmat] * 3)
 6515:         for axis in [0, 1, 2, -1, None]:
 6516:             msqr = _mean(mat * mat.conj(), axis=axis)
 6517:             mean = _mean(mat, axis=axis)
 6518:             tgt = msqr - mean * mean.conjugate()
 6519:             res = _var(mat, axis=axis)
 6520:             assert_almost_equal(res, tgt)
 6521: 
 6522:     def test_var_complex_byteorder(self):
 6523:         # Test that var fast-path does not cause failures for complex arrays
 6524:         # with non-native byteorder
 6525:         cmat = self.cmat.copy().astype('complex128')
 6526:         cmat_swapped = cmat.astype(cmat.dtype.newbyteorder())
 6527:         assert_almost_equal(cmat.var(), cmat_swapped.var())
 6528: 
 6529:     def test_var_axis_error(self):
 6530:         # Ensure that AxisError is raised instead of IndexError when axis is
 6531:         # out of bounds, see gh-15817.
 6532:         with assert_raises(np.exceptions.AxisError):
 6533:             np.arange(10).var(axis=2)
 6534: 
 6535:     def test_var_where(self):
 6536:         a = np.arange(25).reshape((5, 5))
 6537:         wh_full = np.array([[False, True, False, True, True],
 6538:                             [True, False, True, True, False],
 6539:                             [True, True, False, False, True],
 6540:                             [False, True, True, False, True],
 6541:                             [True, False, True, True, False]])
 6542:         wh_partial = np.array([[False],
 6543:                                [True],
 6544:                                [True],
 6545:                                [False],
 6546:                                [True]])
 6547:         _cases = [(0, True, [50., 50., 50., 50., 50.]),
 6548:                   (1, True, [2., 2., 2., 2., 2.])]
 6549:         for _ax, _wh, _res in _cases:
 6550:             assert_allclose(a.var(axis=_ax, where=_wh),
 6551:                             np.array(_res))
 6552:             assert_allclose(np.var(a, axis=_ax, where=_wh),
 6553:                             np.array(_res))
 6554: 
 6555:         a3d = np.arange(16).reshape((2, 2, 4))
 6556:         _wh_partial = np.array([False, True, True, False])
 6557:         _res = [[0.25, 0.25], [0.25, 0.25]]
 6558:         assert_allclose(a3d.var(axis=2, where=_wh_partial),
 6559:                         np.array(_res))
 6560:         assert_allclose(np.var(a3d, axis=2, where=_wh_partial),
 6561:                         np.array(_res))
 6562: 
 6563:         assert_allclose(np.var(a, axis=1, where=wh_full),
 6564:                         np.var(a[wh_full].reshape((5, 3)), axis=1))
 6565:         assert_allclose(np.var(a, axis=0, where=wh_partial),
 6566:                         np.var(a[wh_partial[:, 0]], axis=0))
 6567:         with pytest.warns(RuntimeWarning) as w:
 6568:             assert_equal(a.var(where=False), np.nan)
 6569:         with pytest.warns(RuntimeWarning) as w:
 6570:             assert_equal(np.var(a, where=False), np.nan)
 6571: 
 6572:     def test_std_values(self):
 6573:         for mat in [self.rmat, self.cmat, self.omat]:
 6574:             for axis in [0, 1, None]:
 6575:                 tgt = np.sqrt(_var(mat, axis=axis))
 6576:                 res = _std(mat, axis=axis)
 6577:                 assert_almost_equal(res, tgt)
 6578: 
 6579:     def test_std_where(self):
 6580:         a = np.arange(25).reshape((5, 5))[::-1]
 6581:         whf = np.array([[False, True, False, True, True],
 6582:                         [True, False, True, False, True],
 6583:                         [True, True, False, True, False],
 6584:                         [True, False, True, True, False],
 6585:                         [False, True, False, True, True]])
 6586:         whp = np.array([[False],
 6587:                         [False],
 6588:                         [True],
 6589:                         [True],
 6590:                         [False]])
 6591:         _cases = [
 6592:             (0, True, 7.07106781 * np.ones(5)),
 6593:             (1, True, 1.41421356 * np.ones(5)),
 6594:             (0, whf,
 6595:              np.array([4.0824829, 8.16496581, 5., 7.39509973, 8.49836586])),
 6596:             (0, whp, 2.5 * np.ones(5))
 6597:         ]
 6598:         for _ax, _wh, _res in _cases:
 6599:             assert_allclose(a.std(axis=_ax, where=_wh), _res)
 6600:             assert_allclose(np.std(a, axis=_ax, where=_wh), _res)
 6601: 
 6602:         a3d = np.arange(16).reshape((2, 2, 4))
 6603:         _wh_partial = np.array([False, True, True, False])
 6604:         _res = [[0.5, 0.5], [0.5, 0.5]]
 6605:         assert_allclose(a3d.std(axis=2, where=_wh_partial),
 6606:                         np.array(_res))
 6607:         assert_allclose(np.std(a3d, axis=2, where=_wh_partial),
 6608:                         np.array(_res))
 6609: 
 6610:         assert_allclose(a.std(axis=1, where=whf),
 6611:                         np.std(a[whf].reshape((5, 3)), axis=1))
 6612:         assert_allclose(np.std(a, axis=1, where=whf),
 6613:                         (a[whf].reshape((5, 3))).std(axis=1))
 6614:         assert_allclose(a.std(axis=0, where=whp),
 6615:                         np.std(a[whp[:, 0]], axis=0))
 6616:         assert_allclose(np.std(a, axis=0, where=whp),
 6617:                         (a[whp[:, 0]]).std(axis=0))
 6618:         with pytest.warns(RuntimeWarning) as w:
 6619:             assert_equal(a.std(where=False), np.nan)
 6620:         with pytest.warns(RuntimeWarning) as w:
 6621:             assert_equal(np.std(a, where=False), np.nan)
 6622: 
 6623:     def test_subclass(self):
 6624:         class TestArray(np.ndarray):
 6625:             def __new__(cls, data, info):
 6626:                 result = np.array(data)
 6627:                 result = result.view(cls)
 6628:                 result.info = info
 6629:                 return result
 6630: 
 6631:             def __array_finalize__(self, obj):
 6632:                 self.info = getattr(obj, "info", '')
 6633: 
 6634:         dat = TestArray([[1, 2, 3, 4], [5, 6, 7, 8]], 'jubba')
 6635:         res = dat.mean(1)
 6636:         assert_(res.info == dat.info)
 6637:         res = dat.std(1)
 6638:         assert_(res.info == dat.info)
 6639:         res = dat.var(1)
 6640:         assert_(res.info == dat.info)
 6641: 
 6642: 
 6643: class TestVdot:
 6644:     def test_basic(self):
 6645:         dt_numeric = np.typecodes['AllFloat'] + np.typecodes['AllInteger']
 6646:         dt_complex = np.typecodes['Complex']
 6647: 
 6648:         # test real
 6649:         a = np.eye(3)
 6650:         for dt in dt_numeric + 'O':
 6651:             b = a.astype(dt)
 6652:             res = np.vdot(b, b)
 6653:             assert_(np.isscalar(res))
 6654:             assert_equal(np.vdot(b, b), 3)
 6655: 
 6656:         # test complex
 6657:         a = np.eye(3) * 1j
 6658:         for dt in dt_complex + 'O':
 6659:             b = a.astype(dt)
 6660:             res = np.vdot(b, b)
 6661:             assert_(np.isscalar(res))
 6662:             assert_equal(np.vdot(b, b), 3)
 6663: 
 6664:         # test boolean
 6665:         b = np.eye(3, dtype=bool)
 6666:         res = np.vdot(b, b)
 6667:         assert_(np.isscalar(res))
 6668:         assert_equal(np.vdot(b, b), True)
 6669: 
 6670:     def test_vdot_array_order(self):
 6671:         a = np.array([[1, 2], [3, 4]], order='C')
 6672:         b = np.array([[1, 2], [3, 4]], order='F')
 6673:         res = np.vdot(a, a)
 6674: 
 6675:         # integer arrays are exact
 6676:         assert_equal(np.vdot(a, b), res)
 6677:         assert_equal(np.vdot(b, a), res)
 6678:         assert_equal(np.vdot(b, b), res)
 6679: 
 6680:     def test_vdot_uncontiguous(self):
 6681:         for size in [2, 1000]:
 6682:             # Different sizes match different branches in vdot.
 6683:             a = np.zeros((size, 2, 2))
 6684:             b = np.zeros((size, 2, 2))
 6685:             a[:, 0, 0] = np.arange(size)
 6686:             b[:, 0, 0] = np.arange(size) + 1
 6687:             # Make a and b uncontiguous:
 6688:             a = a[..., 0]
 6689:             b = b[..., 0]
 6690: 
 6691:             assert_equal(np.vdot(a, b),
 6692:                          np.vdot(a.flatten(), b.flatten()))
 6693:             assert_equal(np.vdot(a, b.copy()),
 6694:                          np.vdot(a.flatten(), b.flatten()))
 6695:             assert_equal(np.vdot(a.copy(), b),
 6696:                          np.vdot(a.flatten(), b.flatten()))
 6697:             assert_equal(np.vdot(a.copy('F'), b),
 6698:                          np.vdot(a.flatten(), b.flatten()))
 6699:             assert_equal(np.vdot(a, b.copy('F')),
 6700:                          np.vdot(a.flatten(), b.flatten()))
 6701: 
 6702: 
 6703: class TestDot:
 6704:     def setup_method(self):
 6705:         np.random.seed(128)
 6706:         self.A = np.random.rand(4, 2)
 6707:         self.b1 = np.random.rand(2, 1)
 6708:         self.b2 = np.random.rand(2)
 6709:         self.b3 = np.random.rand(1, 2)
 6710:         self.b4 = np.random.rand(4)
 6711:         self.N = 7
 6712: 
 6713:     def test_dotmatmat(self):
 6714:         A = self.A
 6715:         res = np.dot(A.transpose(), A)
 6716:         tgt = np.array([[1.45046013, 0.86323640],
 6717:                         [0.86323640, 0.84934569]])
 6718:         assert_almost_equal(res, tgt, decimal=self.N)
 6719: 
 6720:     def test_dotmatvec(self):
 6721:         A, b1 = self.A, self.b1
 6722:         res = np.dot(A, b1)
 6723:         tgt = np.array([[0.32114320], [0.04889721],
 6724:                         [0.15696029], [0.33612621]])
 6725:         assert_almost_equal(res, tgt, decimal=self.N)
 6726: 
 6727:     def test_dotmatvec2(self):
 6728:         A, b2 = self.A, self.b2
 6729:         res = np.dot(A, b2)
 6730:         tgt = np.array([0.29677940, 0.04518649, 0.14468333, 0.31039293])
 6731:         assert_almost_equal(res, tgt, decimal=self.N)
 6732: 
 6733:     def test_dotvecmat(self):
 6734:         A, b4 = self.A, self.b4
 6735:         res = np.dot(b4, A)
 6736:         tgt = np.array([1.23495091, 1.12222648])
 6737:         assert_almost_equal(res, tgt, decimal=self.N)
 6738: 
 6739:     def test_dotvecmat2(self):
 6740:         b3, A = self.b3, self.A
 6741:         res = np.dot(b3, A.transpose())
 6742:         tgt = np.array([[0.58793804, 0.08957460, 0.30605758, 0.62716383]])
 6743:         assert_almost_equal(res, tgt, decimal=self.N)
 6744: 
 6745:     def test_dotvecmat3(self):
 6746:         A, b4 = self.A, self.b4
 6747:         res = np.dot(A.transpose(), b4)
 6748:         tgt = np.array([1.23495091, 1.12222648])
 6749:         assert_almost_equal(res, tgt, decimal=self.N)
 6750: 
 6751:     def test_dotvecvecouter(self):
 6752:         b1, b3 = self.b1, self.b3
 6753:         res = np.dot(b1, b3)
 6754:         tgt = np.array([[0.20128610, 0.08400440], [0.07190947, 0.03001058]])
 6755:         assert_almost_equal(res, tgt, decimal=self.N)
 6756: 
 6757:     def test_dotvecvecinner(self):
 6758:         b1, b3 = self.b1, self.b3
 6759:         res = np.dot(b3, b1)
 6760:         tgt = np.array([[0.23129668]])
 6761:         assert_almost_equal(res, tgt, decimal=self.N)
 6762: 
 6763:     def test_dotcolumnvect1(self):
 6764:         b1 = np.ones((3, 1))
 6765:         b2 = [5.3]
 6766:         res = np.dot(b1, b2)
 6767:         tgt = np.array([5.3, 5.3, 5.3])
 6768:         assert_almost_equal(res, tgt, decimal=self.N)
 6769: 
 6770:     def test_dotcolumnvect2(self):
 6771:         b1 = np.ones((3, 1)).transpose()
 6772:         b2 = [6.2]
 6773:         res = np.dot(b2, b1)
 6774:         tgt = np.array([6.2, 6.2, 6.2])
 6775:         assert_almost_equal(res, tgt, decimal=self.N)
 6776: 
 6777:     def test_dotvecscalar(self):
 6778:         np.random.seed(100)
 6779:         b1 = np.random.rand(1, 1)
 6780:         b2 = np.random.rand(1, 4)
 6781:         res = np.dot(b1, b2)
 6782:         tgt = np.array([[0.15126730, 0.23068496, 0.45905553, 0.00256425]])
 6783:         assert_almost_equal(res, tgt, decimal=self.N)
 6784: 
 6785:     def test_dotvecscalar2(self):
 6786:         np.random.seed(100)
 6787:         b1 = np.random.rand(4, 1)
 6788:         b2 = np.random.rand(1, 1)
 6789:         res = np.dot(b1, b2)
 6790:         tgt = np.array([[0.00256425], [0.00131359], [0.00200324], [0.00398638]])
 6791:         assert_almost_equal(res, tgt, decimal=self.N)
 6792: 
 6793:     def test_all(self):
 6794:         dims = [(), (1,), (1, 1)]
 6795:         dout = [(), (1,), (1, 1), (1,), (), (1,), (1, 1), (1,), (1, 1)]
 6796:         for dim, (dim1, dim2) in zip(dout, itertools.product(dims, dims)):
 6797:             b1 = np.zeros(dim1)
 6798:             b2 = np.zeros(dim2)
 6799:             res = np.dot(b1, b2)
 6800:             tgt = np.zeros(dim)
 6801:             assert_(res.shape == tgt.shape)
 6802:             assert_almost_equal(res, tgt, decimal=self.N)
 6803: 
 6804:     def test_vecobject(self):
 6805:         class Vec:
 6806:             def __init__(self, sequence=None):
 6807:                 if sequence is None:
 6808:                     sequence = []
 6809:                 self.array = np.array(sequence)
 6810: 
 6811:             def __add__(self, other):
 6812:                 out = Vec()
 6813:                 out.array = self.array + other.array
 6814:                 return out
 6815: 
 6816:             def __sub__(self, other):
 6817:                 out = Vec()
 6818:                 out.array = self.array - other.array
 6819:                 return out
 6820: 
 6821:             def __mul__(self, other):  # with scalar
 6822:                 out = Vec(self.array.copy())
 6823:                 out.array *= other
 6824:                 return out
 6825: 
 6826:             def __rmul__(self, other):
 6827:                 return self * other
 6828: 
 6829:         U_non_cont = np.transpose([[1., 1.], [1., 2.]])
 6830:         U_cont = np.ascontiguousarray(U_non_cont)
 6831:         x = np.array([Vec([1., 0.]), Vec([0., 1.])])
 6832:         zeros = np.array([Vec([0., 0.]), Vec([0., 0.])])
 6833:         zeros_test = np.dot(U_cont, x) - np.dot(U_non_cont, x)
 6834:         assert_equal(zeros[0].array, zeros_test[0].array)
 6835:         assert_equal(zeros[1].array, zeros_test[1].array)
 6836: 
 6837:     def test_dot_2args(self):
 6838: 
 6839:         a = np.array([[1, 2], [3, 4]], dtype=float)
 6840:         b = np.array([[1, 0], [1, 1]], dtype=float)
 6841:         c = np.array([[3, 2], [7, 4]], dtype=float)
 6842: 
 6843:         d = dot(a, b)
 6844:         assert_allclose(c, d)
 6845: 
 6846:     def test_dot_3args(self):
 6847: 
 6848:         np.random.seed(22)
 6849:         f = np.random.random_sample((1024, 16))
 6850:         v = np.random.random_sample((16, 32))
 6851: 
 6852:         r = np.empty((1024, 32))
 6853:         if HAS_REFCOUNT:
 6854:             orig_refcount = sys.getrefcount(r)
 6855:         for i in range(12):
 6856:             dot(f, v, r)
 6857:         if HAS_REFCOUNT:
 6858:             assert_equal(sys.getrefcount(r), orig_refcount)
 6859:         r2 = dot(f, v, out=None)
 6860:         assert_array_equal(r2, r)
 6861:         assert_(r is dot(f, v, out=r))
 6862: 
 6863:         v = v[:, 0].copy()  # v.shape == (16,)
 6864:         r = r[:, 0].copy()  # r.shape == (1024,)
 6865:         r2 = dot(f, v)
 6866:         assert_(r is dot(f, v, r))
 6867:         assert_array_equal(r2, r)
 6868: 
 6869:     def test_dot_3args_errors(self):
 6870: 
 6871:         np.random.seed(22)
 6872:         f = np.random.random_sample((1024, 16))
 6873:         v = np.random.random_sample((16, 32))
 6874: 
 6875:         r = np.empty((1024, 31))
 6876:         assert_raises(ValueError, dot, f, v, r)
 6877: 
 6878:         r = np.empty((1024,))
 6879:         assert_raises(ValueError, dot, f, v, r)
 6880: 
 6881:         r = np.empty((32,))
 6882:         assert_raises(ValueError, dot, f, v, r)
 6883: 
 6884:         r = np.empty((32, 1024))
 6885:         assert_raises(ValueError, dot, f, v, r)
 6886:         assert_raises(ValueError, dot, f, v, r.T)
 6887: 
 6888:         r = np.empty((1024, 64))
 6889:         assert_raises(ValueError, dot, f, v, r[:, ::2])
 6890:         assert_raises(ValueError, dot, f, v, r[:, :32])
 6891: 
 6892:         r = np.empty((1024, 32), dtype=np.float32)
 6893:         assert_raises(ValueError, dot, f, v, r)
 6894: 
 6895:         r = np.empty((1024, 32), dtype=int)
 6896:         assert_raises(ValueError, dot, f, v, r)
 6897: 
 6898:     def test_dot_out_result(self):
 6899:         x = np.ones((), dtype=np.float16)
 6900:         y = np.ones((5,), dtype=np.float16)
 6901:         z = np.zeros((5,), dtype=np.float16)
 6902:         res = x.dot(y, out=z)
 6903:         assert np.array_equal(res, y)
 6904:         assert np.array_equal(z, y)
 6905: 
 6906:     def test_dot_out_aliasing(self):
 6907:         x = np.ones((), dtype=np.float16)
 6908:         y = np.ones((5,), dtype=np.float16)
 6909:         z = np.zeros((5,), dtype=np.float16)
 6910:         res = x.dot(y, out=z)
 6911:         z[0] = 2
 6912:         assert np.array_equal(res, z)
 6913: 
 6914:     def test_dot_array_order(self):
 6915:         a = np.array([[1, 2], [3, 4]], order='C')
 6916:         b = np.array([[1, 2], [3, 4]], order='F')
 6917:         res = np.dot(a, a)
 6918: 
 6919:         # integer arrays are exact
 6920:         assert_equal(np.dot(a, b), res)
 6921:         assert_equal(np.dot(b, a), res)
 6922:         assert_equal(np.dot(b, b), res)
 6923: 
 6924:     def test_accelerate_framework_sgemv_fix(self):
 6925: 
 6926:         def aligned_array(shape, align, dtype, order='C'):
 6927:             d = dtype(0)
 6928:             N = np.prod(shape)
 6929:             tmp = np.zeros(N * d.nbytes + align, dtype=np.uint8)
 6930:             address = tmp.__array_interface__["data"][0]
 6931:             for offset in range(align):
 6932:                 if (address + offset) % align == 0:
 6933:                     break
 6934:             tmp = tmp[offset:offset + N * d.nbytes].view(dtype=dtype)
 6935:             return tmp.reshape(shape, order=order)
 6936: 
 6937:         def as_aligned(arr, align, dtype, order='C'):
 6938:             aligned = aligned_array(arr.shape, align, dtype, order)
 6939:             aligned[:] = arr[:]
 6940:             return aligned
 6941: 
 6942:         def assert_dot_close(A, X, desired):
 6943:             assert_allclose(np.dot(A, X), desired, rtol=1e-5, atol=1e-7)
 6944: 
 6945:         m = aligned_array(100, 15, np.float32)
 6946:         s = aligned_array((100, 100), 15, np.float32)
 6947:         np.dot(s, m)  # this will always segfault if the bug is present
 6948: 
 6949:         testdata = itertools.product((15, 32), (10000,), (200, 89), ('C', 'F'))
 6950:         for align, m, n, a_order in testdata:
 6951:             # Calculation in double precision
 6952:             A_d = np.random.rand(m, n)
 6953:             X_d = np.random.rand(n)
 6954:             desired = np.dot(A_d, X_d)
 6955:             # Calculation with aligned single precision
 6956:             A_f = as_aligned(A_d, align, np.float32, order=a_order)
 6957:             X_f = as_aligned(X_d, align, np.float32)
 6958:             assert_dot_close(A_f, X_f, desired)
 6959:             # Strided A rows
 6960:             A_d_2 = A_d[::2]
 6961:             desired = np.dot(A_d_2, X_d)
 6962:             A_f_2 = A_f[::2]
 6963:             assert_dot_close(A_f_2, X_f, desired)
 6964:             # Strided A columns, strided X vector
 6965:             A_d_22 = A_d_2[:, ::2]
 6966:             X_d_2 = X_d[::2]
 6967:             desired = np.dot(A_d_22, X_d_2)
 6968:             A_f_22 = A_f_2[:, ::2]
 6969:             X_f_2 = X_f[::2]
 6970:             assert_dot_close(A_f_22, X_f_2, desired)
 6971:             # Check the strides are as expected
 6972:             if a_order == 'F':
 6973:                 assert_equal(A_f_22.strides, (8, 8 * m))
 6974:             else:
 6975:                 assert_equal(A_f_22.strides, (8 * n, 8))
 6976:             assert_equal(X_f_2.strides, (8,))
 6977:             # Strides in A rows + cols only
 6978:             X_f_2c = as_aligned(X_f_2, align, np.float32)
 6979:             assert_dot_close(A_f_22, X_f_2c, desired)
 6980:             # Strides just in A cols
 6981:             A_d_12 = A_d[:, ::2]
 6982:             desired = np.dot(A_d_12, X_d_2)
 6983:             A_f_12 = A_f[:, ::2]
 6984:             assert_dot_close(A_f_12, X_f_2c, desired)
 6985:             # Strides in A cols and X
 6986:             assert_dot_close(A_f_12, X_f_2, desired)
 6987: 
 6988:     @pytest.mark.slow
 6989:     @pytest.mark.parametrize("dtype", [np.float64, np.complex128])
 6990:     @requires_memory(free_bytes=18e9)  # complex case needs 18GiB+
 6991:     def test_huge_vectordot(self, dtype):
 6992:         # Large vector multiplications are chunked with 32bit BLAS
 6993:         # Test that the chunking does the right thing, see also gh-22262
 6994:         data = np.ones(2**30 + 100, dtype=dtype)
 6995:         res = np.dot(data, data)
 6996:         assert res == 2**30 + 100
 6997: 
 6998:     def test_dtype_discovery_fails(self):
 6999:         # See gh-14247, error checking was missing for failed dtype discovery
 7000:         class BadObject:
 7001:             def __array__(self, dtype=None, copy=None):
 7002:                 raise TypeError("just this tiny mint leaf")
 7003: 
 7004:         with pytest.raises(TypeError):
 7005:             np.dot(BadObject(), BadObject())
 7006: 
 7007:         with pytest.raises(TypeError):
 7008:             np.dot(3.0, BadObject())
 7009: 
 7010: 
 7011: class MatmulCommon:
 7012:     """Common tests for '@' operator and numpy.matmul.
 7013: 
 7014:     """
 7015:     # Should work with these types. Will want to add
 7016:     # "O" at some point
 7017:     types = "?bhilqBHILQefdgFDGO"
 7018: 
 7019:     def test_exceptions(self):
 7020:         dims = [
 7021:             ((1,), (2,)),            # mismatched vector vector
 7022:             ((2, 1,), (2,)),         # mismatched matrix vector
 7023:             ((2,), (1, 2)),          # mismatched vector matrix
 7024:             ((1, 2), (3, 1)),        # mismatched matrix matrix
 7025:             ((1,), ()),              # vector scalar
 7026:             ((), (1)),               # scalar vector
 7027:             ((1, 1), ()),            # matrix scalar
 7028:             ((), (1, 1)),            # scalar matrix
 7029:             ((2, 2, 1), (3, 1, 2)),  # cannot broadcast
 7030:             ]
 7031: 
 7032:         for dt, (dm1, dm2) in itertools.product(self.types, dims):
 7033:             a = np.ones(dm1, dtype=dt)
 7034:             b = np.ones(dm2, dtype=dt)
 7035:             assert_raises(ValueError, self.matmul, a, b)
 7036: 
 7037:     def test_shapes(self):
 7038:         dims = [
 7039:             ((1, 1), (2, 1, 1)),     # broadcast first argument
 7040:             ((2, 1, 1), (1, 1)),     # broadcast second argument
 7041:             ((2, 1, 1), (2, 1, 1)),  # matrix stack sizes match
 7042:             ]
 7043: 
 7044:         for dt, (dm1, dm2) in itertools.product(self.types, dims):
 7045:             a = np.ones(dm1, dtype=dt)
 7046:             b = np.ones(dm2, dtype=dt)
 7047:             res = self.matmul(a, b)
 7048:             assert_(res.shape == (2, 1, 1))
 7049: 
 7050:         # vector vector returns scalars.
 7051:         for dt in self.types:
 7052:             a = np.ones((2,), dtype=dt)
 7053:             b = np.ones((2,), dtype=dt)
 7054:             c = self.matmul(a, b)
 7055:             assert_(np.array(c).shape == ())
 7056: 
 7057:     def test_result_types(self):
 7058:         mat = np.ones((1, 1))
 7059:         vec = np.ones((1,))
 7060:         for dt in self.types:
 7061:             m = mat.astype(dt)
 7062:             v = vec.astype(dt)
 7063:             for arg in [(m, v), (v, m), (m, m)]:
 7064:                 res = self.matmul(*arg)
 7065:                 assert_(res.dtype == dt)
 7066: 
 7067:             # vector vector returns scalars
 7068:             if dt != "O":
 7069:                 res = self.matmul(v, v)
 7070:                 assert_(type(res) is np.dtype(dt).type)
 7071: 
 7072:     def test_scalar_output(self):
 7073:         vec1 = np.array([2])
 7074:         vec2 = np.array([3, 4]).reshape(1, -1)
 7075:         tgt = np.array([6, 8])
 7076:         for dt in self.types[1:]:
 7077:             v1 = vec1.astype(dt)
 7078:             v2 = vec2.astype(dt)
 7079:             res = self.matmul(v1, v2)
 7080:             assert_equal(res, tgt)
 7081:             res = self.matmul(v2.T, v1)
 7082:             assert_equal(res, tgt)
 7083: 
 7084:         # boolean type
 7085:         vec = np.array([True, True], dtype='?').reshape(1, -1)
 7086:         res = self.matmul(vec[:, 0], vec)
 7087:         assert_equal(res, True)
 7088: 
 7089:     def test_vector_vector_values(self):
 7090:         vec1 = np.array([1, 2])
 7091:         vec2 = np.array([3, 4]).reshape(-1, 1)
 7092:         tgt1 = np.array([11])
 7093:         tgt2 = np.array([[3, 6], [4, 8]])
 7094:         for dt in self.types[1:]:
 7095:             v1 = vec1.astype(dt)
 7096:             v2 = vec2.astype(dt)
 7097:             res = self.matmul(v1, v2)
 7098:             assert_equal(res, tgt1)
 7099:             # no broadcast, we must make v1 into a 2d ndarray
 7100:             res = self.matmul(v2, v1.reshape(1, -1))
 7101:             assert_equal(res, tgt2)
 7102: 
 7103:         # boolean type
 7104:         vec = np.array([True, True], dtype='?')
 7105:         res = self.matmul(vec, vec)
 7106:         assert_equal(res, True)
 7107: 
 7108:     def test_vector_matrix_values(self):
 7109:         vec = np.array([1, 2])
 7110:         mat1 = np.array([[1, 2], [3, 4]])
 7111:         mat2 = np.stack([mat1] * 2, axis=0)
 7112:         tgt1 = np.array([7, 10])
 7113:         tgt2 = np.stack([tgt1] * 2, axis=0)
 7114:         for dt in self.types[1:]:
 7115:             v = vec.astype(dt)
 7116:             m1 = mat1.astype(dt)
 7117:             m2 = mat2.astype(dt)
 7118:             res = self.matmul(v, m1)
 7119:             assert_equal(res, tgt1)
 7120:             res = self.matmul(v, m2)
 7121:             assert_equal(res, tgt2)
 7122: 
 7123:         # boolean type
 7124:         vec = np.array([True, False])
 7125:         mat1 = np.array([[True, False], [False, True]])
 7126:         mat2 = np.stack([mat1] * 2, axis=0)
 7127:         tgt1 = np.array([True, False])
 7128:         tgt2 = np.stack([tgt1] * 2, axis=0)
 7129: 
 7130:         res = self.matmul(vec, mat1)
 7131:         assert_equal(res, tgt1)
 7132:         res = self.matmul(vec, mat2)
 7133:         assert_equal(res, tgt2)
 7134: 
 7135:     def test_matrix_vector_values(self):
 7136:         vec = np.array([1, 2])
 7137:         mat1 = np.array([[1, 2], [3, 4]])
 7138:         mat2 = np.stack([mat1] * 2, axis=0)
 7139:         tgt1 = np.array([5, 11])
 7140:         tgt2 = np.stack([tgt1] * 2, axis=0)
 7141:         for dt in self.types[1:]:
 7142:             v = vec.astype(dt)
 7143:             m1 = mat1.astype(dt)
 7144:             m2 = mat2.astype(dt)
 7145:             res = self.matmul(m1, v)
 7146:             assert_equal(res, tgt1)
 7147:             res = self.matmul(m2, v)
 7148:             assert_equal(res, tgt2)
 7149: 
 7150:         # boolean type
 7151:         vec = np.array([True, False])
 7152:         mat1 = np.array([[True, False], [False, True]])
 7153:         mat2 = np.stack([mat1] * 2, axis=0)
 7154:         tgt1 = np.array([True, False])
 7155:         tgt2 = np.stack([tgt1] * 2, axis=0)
 7156: 
 7157:         res = self.matmul(vec, mat1)
 7158:         assert_equal(res, tgt1)
 7159:         res = self.matmul(vec, mat2)
 7160:         assert_equal(res, tgt2)
 7161: 
 7162:     def test_matrix_matrix_values(self):
 7163:         mat1 = np.array([[1, 2], [3, 4]])
 7164:         mat2 = np.array([[1, 0], [1, 1]])
 7165:         mat12 = np.stack([mat1, mat2], axis=0)
 7166:         mat21 = np.stack([mat2, mat1], axis=0)
 7167:         tgt11 = np.array([[7, 10], [15, 22]])
 7168:         tgt12 = np.array([[3, 2], [7, 4]])
 7169:         tgt21 = np.array([[1, 2], [4, 6]])
 7170:         tgt12_21 = np.stack([tgt12, tgt21], axis=0)
 7171:         tgt11_12 = np.stack((tgt11, tgt12), axis=0)
 7172:         tgt11_21 = np.stack((tgt11, tgt21), axis=0)
 7173:         for dt in self.types[1:]:
 7174:             m1 = mat1.astype(dt)
 7175:             m2 = mat2.astype(dt)
 7176:             m12 = mat12.astype(dt)
 7177:             m21 = mat21.astype(dt)
 7178: 
 7179:             # matrix @ matrix
 7180:             res = self.matmul(m1, m2)
 7181:             assert_equal(res, tgt12)
 7182:             res = self.matmul(m2, m1)
 7183:             assert_equal(res, tgt21)
 7184: 
 7185:             # stacked @ matrix
 7186:             res = self.matmul(m12, m1)
 7187:             assert_equal(res, tgt11_21)
 7188: 
 7189:             # matrix @ stacked
 7190:             res = self.matmul(m1, m12)
 7191:             assert_equal(res, tgt11_12)
 7192: 
 7193:             # stacked @ stacked
 7194:             res = self.matmul(m12, m21)
 7195:             assert_equal(res, tgt12_21)
 7196: 
 7197:         # boolean type
 7198:         m1 = np.array([[1, 1], [0, 0]], dtype=np.bool)
 7199:         m2 = np.array([[1, 0], [1, 1]], dtype=np.bool)
 7200:         m12 = np.stack([m1, m2], axis=0)
 7201:         m21 = np.stack([m2, m1], axis=0)
 7202:         tgt11 = m1
 7203:         tgt12 = m1
 7204:         tgt21 = np.array([[1, 1], [1, 1]], dtype=np.bool)
 7205:         tgt12_21 = np.stack([tgt12, tgt21], axis=0)
 7206:         tgt11_12 = np.stack((tgt11, tgt12), axis=0)
 7207:         tgt11_21 = np.stack((tgt11, tgt21), axis=0)
 7208: 
 7209:         # matrix @ matrix
 7210:         res = self.matmul(m1, m2)
 7211:         assert_equal(res, tgt12)
 7212:         res = self.matmul(m2, m1)
 7213:         assert_equal(res, tgt21)
 7214: 
 7215:         # stacked @ matrix
 7216:         res = self.matmul(m12, m1)
 7217:         assert_equal(res, tgt11_21)
 7218: 
 7219:         # matrix @ stacked
 7220:         res = self.matmul(m1, m12)
 7221:         assert_equal(res, tgt11_12)
 7222: 
 7223:         # stacked @ stacked
 7224:         res = self.matmul(m12, m21)
 7225:         assert_equal(res, tgt12_21)
 7226: 
 7227: 
 7228: class TestMatmul(MatmulCommon):
 7229:     matmul = np.matmul
 7230: 
 7231:     def test_out_arg(self):
 7232:         a = np.ones((5, 2), dtype=float)
 7233:         b = np.array([[1, 3], [5, 7]], dtype=float)
 7234:         tgt = np.dot(a, b)
 7235: 
 7236:         # test as positional argument
 7237:         msg = "out positional argument"
 7238:         out = np.zeros((5, 2), dtype=float)
 7239:         self.matmul(a, b, out)
 7240:         assert_array_equal(out, tgt, err_msg=msg)
 7241: 
 7242:         # test as keyword argument
 7243:         msg = "out keyword argument"
 7244:         out = np.zeros((5, 2), dtype=float)
 7245:         self.matmul(a, b, out=out)
 7246:         assert_array_equal(out, tgt, err_msg=msg)
 7247: 
 7248:         # test out with not allowed type cast (safe casting)
 7249:         msg = "Cannot cast ufunc .* output"
 7250:         out = np.zeros((5, 2), dtype=np.int32)
 7251:         assert_raises_regex(TypeError, msg, self.matmul, a, b, out=out)
 7252: 
 7253:         # test out with type upcast to complex
 7254:         out = np.zeros((5, 2), dtype=np.complex128)
 7255:         c = self.matmul(a, b, out=out)
 7256:         assert_(c is out)
 7257:         with suppress_warnings() as sup:
 7258:             sup.filter(ComplexWarning, '')
 7259:             c = c.astype(tgt.dtype)
 7260:         assert_array_equal(c, tgt)
 7261: 
 7262:     def test_empty_out(self):
 7263:         # Check that the output cannot be broadcast, so that it cannot be
 7264:         # size zero when the outer dimensions (iterator size) has size zero.
 7265:         arr = np.ones((0, 1, 1))
 7266:         out = np.ones((1, 1, 1))
 7267:         assert self.matmul(arr, arr).shape == (0, 1, 1)
 7268: 
 7269:         with pytest.raises(ValueError, match=r"non-broadcastable"):
 7270:             self.matmul(arr, arr, out=out)
 7271: 
 7272:     def test_out_contiguous(self):
 7273:         a = np.ones((5, 2), dtype=float)
 7274:         b = np.array([[1, 3], [5, 7]], dtype=float)
 7275:         v = np.array([1, 3], dtype=float)
 7276:         tgt = np.dot(a, b)
 7277:         tgt_mv = np.dot(a, v)
 7278: 
 7279:         # test out non-contiguous
 7280:         out = np.ones((5, 2, 2), dtype=float)
 7281:         c = self.matmul(a, b, out=out[..., 0])
 7282:         assert c.base is out
 7283:         assert_array_equal(c, tgt)
 7284:         c = self.matmul(a, v, out=out[:, 0, 0])
 7285:         assert_array_equal(c, tgt_mv)
 7286:         c = self.matmul(v, a.T, out=out[:, 0, 0])
 7287:         assert_array_equal(c, tgt_mv)
 7288: 
 7289:         # test out contiguous in only last dim
 7290:         out = np.ones((10, 2), dtype=float)
 7291:         c = self.matmul(a, b, out=out[::2, :])
 7292:         assert_array_equal(c, tgt)
 7293: 
 7294:         # test transposes of out, args
 7295:         out = np.ones((5, 2), dtype=float)
 7296:         c = self.matmul(b.T, a.T, out=out.T)
 7297:         assert_array_equal(out, tgt)
 7298: 
 7299:     m1 = np.arange(15.).reshape(5, 3)
 7300:     m2 = np.arange(21.).reshape(3, 7)
 7301:     m3 = np.arange(30.).reshape(5, 6)[:, ::2]  # non-contiguous
 7302:     vc = np.arange(10.)
 7303:     vr = np.arange(6.)
 7304:     m0 = np.zeros((3, 0))
 7305: 
 7306:     @pytest.mark.parametrize('args', (
 7307:             # matrix-matrix
 7308:             (m1, m2), (m2.T, m1.T), (m2.T.copy(), m1.T), (m2.T, m1.T.copy()),
 7309:             # matrix-matrix-transpose, contiguous and non
 7310:             (m1, m1.T), (m1.T, m1), (m1, m3.T), (m3, m1.T),
 7311:             (m3, m3.T), (m3.T, m3),
 7312:             # matrix-matrix non-contiguous
 7313:             (m3, m2), (m2.T, m3.T), (m2.T.copy(), m3.T),
 7314:             # vector-matrix, matrix-vector, contiguous
 7315:             (m1, vr[:3]), (vc[:5], m1), (m1.T, vc[:5]), (vr[:3], m1.T),
 7316:             # vector-matrix, matrix-vector, vector non-contiguous
 7317:             (m1, vr[::2]), (vc[::2], m1), (m1.T, vc[::2]), (vr[::2], m1.T),
 7318:             # vector-matrix, matrix-vector, matrix non-contiguous
 7319:             (m3, vr[:3]), (vc[:5], m3), (m3.T, vc[:5]), (vr[:3], m3.T),
 7320:             # vector-matrix, matrix-vector, both non-contiguous
 7321:             (m3, vr[::2]), (vc[::2], m3), (m3.T, vc[::2]), (vr[::2], m3.T),
 7322:             # size == 0
 7323:             (m0, m0.T), (m0.T, m0), (m1, m0), (m0.T, m1.T),
 7324:         ))
 7325:     def test_dot_equivalent(self, args):
 7326:         r1 = np.matmul(*args)
 7327:         r2 = np.dot(*args)
 7328:         assert_equal(r1, r2)
 7329: 
 7330:         r3 = np.matmul(args[0].copy(), args[1].copy())
 7331:         assert_equal(r1, r3)
 7332: 
 7333:         # matrix matrix, issue 29164
 7334:         if [len(args[0].shape), len(args[1].shape)] == [2, 2]:
 7335:             out_f = np.zeros((r2.shape[0] * 2, r2.shape[1] * 2), order='F')
 7336:             r4 = np.matmul(*args, out=out_f[::2, ::2])
 7337:             assert_equal(r2, r4)
 7338: 
 7339:     def test_matmul_object(self):
 7340:         import fractions
 7341: 
 7342:         f = np.vectorize(fractions.Fraction)
 7343: 
 7344:         def random_ints():
 7345:             return np.random.randint(1, 1000, size=(10, 3, 3))
 7346:         M1 = f(random_ints(), random_ints())
 7347:         M2 = f(random_ints(), random_ints())
 7348: 
 7349:         M3 = self.matmul(M1, M2)
 7350: 
 7351:         [N1, N2, N3] = [a.astype(float) for a in [M1, M2, M3]]
 7352: 
 7353:         assert_allclose(N3, self.matmul(N1, N2))
 7354: 
 7355:     def test_matmul_object_type_scalar(self):
 7356:         from fractions import Fraction as F
 7357:         v = np.array([F(2, 3), F(5, 7)])
 7358:         res = self.matmul(v, v)
 7359:         assert_(type(res) is F)
 7360: 
 7361:     def test_matmul_empty(self):
 7362:         a = np.empty((3, 0), dtype=object)
 7363:         b = np.empty((0, 3), dtype=object)
 7364:         c = np.zeros((3, 3))
 7365:         assert_array_equal(np.matmul(a, b), c)
 7366: 
 7367:     def test_matmul_exception_multiply(self):
 7368:         # test that matmul fails if `__mul__` is missing
 7369:         class add_not_multiply:
 7370:             def __add__(self, other):
 7371:                 return self
 7372:         a = np.full((3, 3), add_not_multiply())
 7373:         with assert_raises(TypeError):
 7374:             b = np.matmul(a, a)
 7375: 
 7376:     def test_matmul_exception_add(self):
 7377:         # test that matmul fails if `__add__` is missing
 7378:         class multiply_not_add:
 7379:             def __mul__(self, other):
 7380:                 return self
 7381:         a = np.full((3, 3), multiply_not_add())
 7382:         with assert_raises(TypeError):
 7383:             b = np.matmul(a, a)
 7384: 
 7385:     def test_matmul_bool(self):
 7386:         # gh-14439
 7387:         a = np.array([[1, 0], [1, 1]], dtype=bool)
 7388:         assert np.max(a.view(np.uint8)) == 1
 7389:         b = np.matmul(a, a)
 7390:         # matmul with boolean output should always be 0, 1
 7391:         assert np.max(b.view(np.uint8)) == 1
 7392: 
 7393:         rg = np.random.default_rng(np.random.PCG64(43))
 7394:         d = rg.integers(2, size=4 * 5, dtype=np.int8)
 7395:         d = d.reshape(4, 5) > 0
 7396:         out1 = np.matmul(d, d.reshape(5, 4))
 7397:         out2 = np.dot(d, d.reshape(5, 4))
 7398:         assert_equal(out1, out2)
 7399: 
 7400:         c = np.matmul(np.zeros((2, 0), dtype=bool), np.zeros(0, dtype=bool))
 7401:         assert not np.any(c)
 7402: 
 7403: 
 7404: class TestMatmulOperator(MatmulCommon):
 7405:     import operator
 7406:     matmul = operator.matmul
 7407: 
 7408:     def test_array_priority_override(self):
 7409: 
 7410:         class A:
 7411:             __array_priority__ = 1000
 7412: 
 7413:             def __matmul__(self, other):
 7414:                 return "A"
 7415: 
 7416:             def __rmatmul__(self, other):
 7417:                 return "A"
 7418: 
 7419:         a = A()
 7420:         b = np.ones(2)
 7421:         assert_equal(self.matmul(a, b), "A")
 7422:         assert_equal(self.matmul(b, a), "A")
 7423: 
 7424:     def test_matmul_raises(self):
 7425:         assert_raises(TypeError, self.matmul, np.int8(5), np.int8(5))
 7426:         assert_raises(TypeError, self.matmul, np.void(b'abc'), np.void(b'abc'))
 7427:         assert_raises(TypeError, self.matmul, np.arange(10), np.void(b'abc'))
 7428: 
 7429: 
 7430: class TestMatmulInplace:
 7431:     DTYPES = {}
 7432:     for i in MatmulCommon.types:
 7433:         for j in MatmulCommon.types:
 7434:             if np.can_cast(j, i):
 7435:                 DTYPES[f"{i}-{j}"] = (np.dtype(i), np.dtype(j))
 7436: 
 7437:     @pytest.mark.parametrize("dtype1,dtype2", DTYPES.values(), ids=DTYPES)
 7438:     def test_basic(self, dtype1: np.dtype, dtype2: np.dtype) -> None:
 7439:         a = np.arange(10).reshape(5, 2).astype(dtype1)
 7440:         a_id = id(a)
 7441:         b = np.ones((2, 2), dtype=dtype2)
 7442: 
 7443:         ref = a @ b
 7444:         a @= b
 7445: 
 7446:         assert id(a) == a_id
 7447:         assert a.dtype == dtype1
 7448:         assert a.shape == (5, 2)
 7449:         if dtype1.kind in "fc":
 7450:             np.testing.assert_allclose(a, ref)
 7451:         else:
 7452:             np.testing.assert_array_equal(a, ref)
 7453: 
 7454:     SHAPES = {
 7455:         "2d_large": ((10**5, 10), (10, 10)),
 7456:         "3d_large": ((10**4, 10, 10), (1, 10, 10)),
 7457:         "1d": ((3,), (3,)),
 7458:         "2d_1d": ((3, 3), (3,)),
 7459:         "1d_2d": ((3,), (3, 3)),
 7460:         "2d_broadcast": ((3, 3), (3, 1)),
 7461:         "2d_broadcast_reverse": ((1, 3), (3, 3)),
 7462:         "3d_broadcast1": ((3, 3, 3), (1, 3, 1)),
 7463:         "3d_broadcast2": ((3, 3, 3), (1, 3, 3)),
 7464:         "3d_broadcast3": ((3, 3, 3), (3, 3, 1)),
 7465:         "3d_broadcast_reverse1": ((1, 3, 3), (3, 3, 3)),
 7466:         "3d_broadcast_reverse2": ((3, 1, 3), (3, 3, 3)),
 7467:         "3d_broadcast_reverse3": ((1, 1, 3), (3, 3, 3)),
 7468:     }
 7469: 
 7470:     @pytest.mark.parametrize("a_shape,b_shape", SHAPES.values(), ids=SHAPES)
 7471:     def test_shapes(self, a_shape: tuple[int, ...], b_shape: tuple[int, ...]):
 7472:         a_size = np.prod(a_shape)
 7473:         a = np.arange(a_size).reshape(a_shape).astype(np.float64)
 7474:         a_id = id(a)
 7475: 
 7476:         b_size = np.prod(b_shape)
 7477:         b = np.arange(b_size).reshape(b_shape)
 7478: 
 7479:         ref = a @ b
 7480:         if ref.shape != a_shape:
 7481:             with pytest.raises(ValueError):
 7482:                 a @= b
 7483:             return
 7484:         else:
 7485:             a @= b
 7486: 
 7487:         assert id(a) == a_id
 7488:         assert a.dtype.type == np.float64
 7489:         assert a.shape == a_shape
 7490:         np.testing.assert_allclose(a, ref)
 7491: 
 7492: 
 7493: def test_matmul_axes():
 7494:     a = np.arange(3 * 4 * 5).reshape(3, 4, 5)
 7495:     c = np.matmul(a, a, axes=[(-2, -1), (-1, -2), (1, 2)])
 7496:     assert c.shape == (3, 4, 4)
 7497:     d = np.matmul(a, a, axes=[(-2, -1), (-1, -2), (0, 1)])
 7498:     assert d.shape == (4, 4, 3)
 7499:     e = np.swapaxes(d, 0, 2)
 7500:     assert_array_equal(e, c)
 7501:     f = np.matmul(a, np.arange(3), axes=[(1, 0), (0), (0)])
 7502:     assert f.shape == (4, 5)
 7503: 
 7504: 
 7505: class TestInner:
 7506: 
 7507:     def test_inner_type_mismatch(self):
 7508:         c = 1.
 7509:         A = np.array((1, 1), dtype='i,i')
 7510: 
 7511:         assert_raises(TypeError, np.inner, c, A)
 7512:         assert_raises(TypeError, np.inner, A, c)
 7513: 
 7514:     def test_inner_scalar_and_vector(self):
 7515:         for dt in np.typecodes['AllInteger'] + np.typecodes['AllFloat'] + '?':
 7516:             sca = np.array(3, dtype=dt)[()]
 7517:             vec = np.array([1, 2], dtype=dt)
 7518:             desired = np.array([3, 6], dtype=dt)
 7519:             assert_equal(np.inner(vec, sca), desired)
 7520:             assert_equal(np.inner(sca, vec), desired)
 7521: 
 7522:     def test_vecself(self):
 7523:         # Ticket 844.
 7524:         # Inner product of a vector with itself segfaults or give
 7525:         # meaningless result
 7526:         a = np.zeros(shape=(1, 80), dtype=np.float64)
 7527:         p = np.inner(a, a)
 7528:         assert_almost_equal(p, 0, decimal=14)
 7529: 
 7530:     def test_inner_product_with_various_contiguities(self):
 7531:         # github issue 6532
 7532:         for dt in np.typecodes['AllInteger'] + np.typecodes['AllFloat'] + '?':
 7533:             # check an inner product involving a matrix transpose
 7534:             A = np.array([[1, 2], [3, 4]], dtype=dt)
 7535:             B = np.array([[1, 3], [2, 4]], dtype=dt)
 7536:             C = np.array([1, 1], dtype=dt)
 7537:             desired = np.array([4, 6], dtype=dt)
 7538:             assert_equal(np.inner(A.T, C), desired)
 7539:             assert_equal(np.inner(C, A.T), desired)
 7540:             assert_equal(np.inner(B, C), desired)
 7541:             assert_equal(np.inner(C, B), desired)
 7542:             # check a matrix product
 7543:             desired = np.array([[7, 10], [15, 22]], dtype=dt)
 7544:             assert_equal(np.inner(A, B), desired)
 7545:             # check the syrk vs. gemm paths
 7546:             desired = np.array([[5, 11], [11, 25]], dtype=dt)
 7547:             assert_equal(np.inner(A, A), desired)
 7548:             assert_equal(np.inner(A, A.copy()), desired)
 7549:             # check an inner product involving an aliased and reversed view
 7550:             a = np.arange(5).astype(dt)
 7551:             b = a[::-1]
 7552:             desired = np.array(10, dtype=dt).item()
 7553:             assert_equal(np.inner(b, a), desired)
 7554: 
 7555:     def test_3d_tensor(self):
 7556:         for dt in np.typecodes['AllInteger'] + np.typecodes['AllFloat'] + '?':
 7557:             a = np.arange(24).reshape(2, 3, 4).astype(dt)
 7558:             b = np.arange(24, 48).reshape(2, 3, 4).astype(dt)
 7559:             desired = np.array(
 7560:                 [[[[ 158,  182,  206],
 7561:                    [ 230,  254,  278]],
 7562: 
 7563:                   [[ 566,  654,  742],
 7564:                    [ 830,  918, 1006]],
 7565: 
 7566:                   [[ 974, 1126, 1278],
 7567:                    [1430, 1582, 1734]]],
 7568: 
 7569:                  [[[1382, 1598, 1814],
 7570:                    [2030, 2246, 2462]],
 7571: 
 7572:                   [[1790, 2070, 2350],
 7573:                    [2630, 2910, 3190]],
 7574: 
 7575:                   [[2198, 2542, 2886],
 7576:                    [3230, 3574, 3918]]]]
 7577:             ).astype(dt)
 7578:             assert_equal(np.inner(a, b), desired)
 7579:             assert_equal(np.inner(b, a).transpose(2, 3, 0, 1), desired)
 7580: 
 7581: 
 7582: class TestChoose:
 7583:     def setup_method(self):
 7584:         self.x = 2 * np.ones((3,), dtype=int)
 7585:         self.y = 3 * np.ones((3,), dtype=int)
 7586:         self.x2 = 2 * np.ones((2, 3), dtype=int)
 7587:         self.y2 = 3 * np.ones((2, 3), dtype=int)
 7588:         self.ind = [0, 0, 1]
 7589: 
 7590:     def test_basic(self):
 7591:         A = np.choose(self.ind, (self.x, self.y))
 7592:         assert_equal(A, [2, 2, 3])
 7593: 
 7594:     def test_broadcast1(self):
 7595:         A = np.choose(self.ind, (self.x2, self.y2))
 7596:         assert_equal(A, [[2, 2, 3], [2, 2, 3]])
 7597: 
 7598:     def test_broadcast2(self):
 7599:         A = np.choose(self.ind, (self.x, self.y2))
 7600:         assert_equal(A, [[2, 2, 3], [2, 2, 3]])
 7601: 
 7602:     @pytest.mark.parametrize("ops",
 7603:         [(1000, np.array([1], dtype=np.uint8)),
 7604:          (-1, np.array([1], dtype=np.uint8)),
 7605:          (1., np.float32(3)),
 7606:          (1., np.array([3], dtype=np.float32))],)
 7607:     def test_output_dtype(self, ops):
 7608:         expected_dt = np.result_type(*ops)
 7609:         assert np.choose([0], ops).dtype == expected_dt
 7610: 
 7611:     def test_dimension_and_args_limit(self):
 7612:         # Maxdims for the legacy iterator is 32, but the maximum number
 7613:         # of arguments is actually larger (a itself also counts here)
 7614:         a = np.ones((1,) * 32, dtype=np.intp)
 7615:         res = a.choose([0, a] + [2] * 61)
 7616:         with pytest.raises(ValueError,
 7617:                 match="Need at least 0 and at most 64 array objects"):
 7618:             a.choose([0, a] + [2] * 62)
 7619: 
 7620:         assert_array_equal(res, a)
 7621:         # Choose is unfortunately limited to 32 dims as of NumPy 2.0
 7622:         a = np.ones((1,) * 60, dtype=np.intp)
 7623:         with pytest.raises(RuntimeError,
 7624:                 match=".*32 dimensions but the array has 60"):
 7625:             a.choose([a, a])
 7626: 
 7627: 
 7628: class TestRepeat:
 7629:     def setup_method(self):
 7630:         self.m = np.array([1, 2, 3, 4, 5, 6])
 7631:         self.m_rect = self.m.reshape((2, 3))
 7632: 
 7633:     def test_basic(self):
 7634:         A = np.repeat(self.m, [1, 3, 2, 1, 1, 2])
 7635:         assert_equal(A, [1, 2, 2, 2, 3,
 7636:                          3, 4, 5, 6, 6])
 7637: 
 7638:     def test_broadcast1(self):
 7639:         A = np.repeat(self.m, 2)
 7640:         assert_equal(A, [1, 1, 2, 2, 3, 3,
 7641:                          4, 4, 5, 5, 6, 6])
 7642: 
 7643:     def test_axis_spec(self):
 7644:         A = np.repeat(self.m_rect, [2, 1], axis=0)
 7645:         assert_equal(A, [[1, 2, 3],
 7646:                          [1, 2, 3],
 7647:                          [4, 5, 6]])
 7648: 
 7649:         A = np.repeat(self.m_rect, [1, 3, 2], axis=1)
 7650:         assert_equal(A, [[1, 2, 2, 2, 3, 3],
 7651:                          [4, 5, 5, 5, 6, 6]])
 7652: 
 7653:     def test_broadcast2(self):
 7654:         A = np.repeat(self.m_rect, 2, axis=0)
 7655:         assert_equal(A, [[1, 2, 3],
 7656:                          [1, 2, 3],
 7657:                          [4, 5, 6],
 7658:                          [4, 5, 6]])
 7659: 
 7660:         A = np.repeat(self.m_rect, 2, axis=1)
 7661:         assert_equal(A, [[1, 1, 2, 2, 3, 3],
 7662:                          [4, 4, 5, 5, 6, 6]])
 7663: 
 7664: 
 7665: # TODO: test for multidimensional
 7666: NEIGH_MODE = {'zero': 0, 'one': 1, 'constant': 2, 'circular': 3, 'mirror': 4}
 7667: 
 7668: 
 7669: @pytest.mark.parametrize('dt', [float, Decimal], ids=['float', 'object'])
 7670: class TestNeighborhoodIter:
 7671:     # Simple, 2d tests
 7672:     def test_simple2d(self, dt):
 7673:         # Test zero and one padding for simple data type
 7674:         x = np.array([[0, 1], [2, 3]], dtype=dt)
 7675:         r = [np.array([[0, 0, 0], [0, 0, 1]], dtype=dt),
 7676:              np.array([[0, 0, 0], [0, 1, 0]], dtype=dt),
 7677:              np.array([[0, 0, 1], [0, 2, 3]], dtype=dt),
 7678:              np.array([[0, 1, 0], [2, 3, 0]], dtype=dt)]
 7679:         l = _multiarray_tests.test_neighborhood_iterator(
 7680:                 x, [-1, 0, -1, 1], x[0], NEIGH_MODE['zero'])
 7681:         assert_array_equal(l, r)
 7682: 
 7683:         r = [np.array([[1, 1, 1], [1, 0, 1]], dtype=dt),
 7684:              np.array([[1, 1, 1], [0, 1, 1]], dtype=dt),
 7685:              np.array([[1, 0, 1], [1, 2, 3]], dtype=dt),
 7686:              np.array([[0, 1, 1], [2, 3, 1]], dtype=dt)]
 7687:         l = _multiarray_tests.test_neighborhood_iterator(
 7688:                 x, [-1, 0, -1, 1], x[0], NEIGH_MODE['one'])
 7689:         assert_array_equal(l, r)
 7690: 
 7691:         r = [np.array([[4, 4, 4], [4, 0, 1]], dtype=dt),
 7692:              np.array([[4, 4, 4], [0, 1, 4]], dtype=dt),
 7693:              np.array([[4, 0, 1], [4, 2, 3]], dtype=dt),
 7694:              np.array([[0, 1, 4], [2, 3, 4]], dtype=dt)]
 7695:         l = _multiarray_tests.test_neighborhood_iterator(
 7696:                 x, [-1, 0, -1, 1], 4, NEIGH_MODE['constant'])
 7697:         assert_array_equal(l, r)
 7698: 
 7699:         # Test with start in the middle
 7700:         r = [np.array([[4, 0, 1], [4, 2, 3]], dtype=dt),
 7701:              np.array([[0, 1, 4], [2, 3, 4]], dtype=dt)]
 7702:         l = _multiarray_tests.test_neighborhood_iterator(
 7703:                 x, [-1, 0, -1, 1], 4, NEIGH_MODE['constant'], 2)
 7704:         assert_array_equal(l, r)
 7705: 
 7706:     def test_mirror2d(self, dt):
 7707:         x = np.array([[0, 1], [2, 3]], dtype=dt)
 7708:         r = [np.array([[0, 0, 1], [0, 0, 1]], dtype=dt),
 7709:              np.array([[0, 1, 1], [0, 1, 1]], dtype=dt),
 7710:              np.array([[0, 0, 1], [2, 2, 3]], dtype=dt),
 7711:              np.array([[0, 1, 1], [2, 3, 3]], dtype=dt)]
 7712:         l = _multiarray_tests.test_neighborhood_iterator(
 7713:                 x, [-1, 0, -1, 1], x[0], NEIGH_MODE['mirror'])
 7714:         assert_array_equal(l, r)
 7715: 
 7716:     # Simple, 1d tests
 7717:     def test_simple(self, dt):
 7718:         # Test padding with constant values
 7719:         x = np.linspace(1, 5, 5).astype(dt)
 7720:         r = [[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 0]]
 7721:         l = _multiarray_tests.test_neighborhood_iterator(
 7722:                 x, [-1, 1], x[0], NEIGH_MODE['zero'])
 7723:         assert_array_equal(l, r)
 7724: 
 7725:         r = [[1, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 1]]
 7726:         l = _multiarray_tests.test_neighborhood_iterator(
 7727:                 x, [-1, 1], x[0], NEIGH_MODE['one'])
 7728:         assert_array_equal(l, r)
 7729: 
 7730:         r = [[x[4], 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, x[4]]]
 7731:         l = _multiarray_tests.test_neighborhood_iterator(
 7732:                 x, [-1, 1], x[4], NEIGH_MODE['constant'])
 7733:         assert_array_equal(l, r)
 7734: 
 7735:     # Test mirror modes
 7736:     def test_mirror(self, dt):
 7737:         x = np.linspace(1, 5, 5).astype(dt)
 7738:         r = np.array([[2, 1, 1, 2, 3], [1, 1, 2, 3, 4], [1, 2, 3, 4, 5],
 7739:                 [2, 3, 4, 5, 5], [3, 4, 5, 5, 4]], dtype=dt)
 7740:         l = _multiarray_tests.test_neighborhood_iterator(
 7741:                 x, [-2, 2], x[1], NEIGH_MODE['mirror'])
 7742:         assert_([i.dtype == dt for i in l])
 7743:         assert_array_equal(l, r)
 7744: 
 7745:     # Circular mode
 7746:     def test_circular(self, dt):
 7747:         x = np.linspace(1, 5, 5).astype(dt)
 7748:         r = np.array([[4, 5, 1, 2, 3], [5, 1, 2, 3, 4], [1, 2, 3, 4, 5],
 7749:                 [2, 3, 4, 5, 1], [3, 4, 5, 1, 2]], dtype=dt)
 7750:         l = _multiarray_tests.test_neighborhood_iterator(
 7751:                 x, [-2, 2], x[0], NEIGH_MODE['circular'])
 7752:         assert_array_equal(l, r)
 7753: 
 7754: 
 7755: # Test stacking neighborhood iterators
 7756: class TestStackedNeighborhoodIter:
 7757:     # Simple, 1d test: stacking 2 constant-padded neigh iterators
 7758:     def test_simple_const(self):
 7759:         dt = np.float64
 7760:         # Test zero and one padding for simple data type
 7761:         x = np.array([1, 2, 3], dtype=dt)
 7762:         r = [np.array([0], dtype=dt),
 7763:              np.array([0], dtype=dt),
 7764:              np.array([1], dtype=dt),
 7765:              np.array([2], dtype=dt),
 7766:              np.array([3], dtype=dt),
 7767:              np.array([0], dtype=dt),
 7768:              np.array([0], dtype=dt)]
 7769:         l = _multiarray_tests.test_neighborhood_iterator_oob(
 7770:                 x, [-2, 4], NEIGH_MODE['zero'], [0, 0], NEIGH_MODE['zero'])
 7771:         assert_array_equal(l, r)
 7772: 
 7773:         r = [np.array([1, 0, 1], dtype=dt),
 7774:              np.array([0, 1, 2], dtype=dt),
 7775:              np.array([1, 2, 3], dtype=dt),
 7776:              np.array([2, 3, 0], dtype=dt),
 7777:              np.array([3, 0, 1], dtype=dt)]
 7778:         l = _multiarray_tests.test_neighborhood_iterator_oob(
 7779:                 x, [-1, 3], NEIGH_MODE['zero'], [-1, 1], NEIGH_MODE['one'])
 7780:         assert_array_equal(l, r)
 7781: 
 7782:     # 2nd simple, 1d test: stacking 2 neigh iterators, mixing const padding and
 7783:     # mirror padding
 7784:     def test_simple_mirror(self):
 7785:         dt = np.float64
 7786:         # Stacking zero on top of mirror
 7787:         x = np.array([1, 2, 3], dtype=dt)
 7788:         r = [np.array([0, 1, 1], dtype=dt),
 7789:              np.array([1, 1, 2], dtype=dt),
 7790:              np.array([1, 2, 3], dtype=dt),
 7791:              np.array([2, 3, 3], dtype=dt),
 7792:              np.array([3, 3, 0], dtype=dt)]
 7793:         l = _multiarray_tests.test_neighborhood_iterator_oob(
 7794:                 x, [-1, 3], NEIGH_MODE['mirror'], [-1, 1], NEIGH_MODE['zero'])
 7795:         assert_array_equal(l, r)
 7796: 
 7797:         # Stacking mirror on top of zero
 7798:         x = np.array([1, 2, 3], dtype=dt)
 7799:         r = [np.array([1, 0, 0], dtype=dt),
 7800:              np.array([0, 0, 1], dtype=dt),
 7801:              np.array([0, 1, 2], dtype=dt),
 7802:              np.array([1, 2, 3], dtype=dt),
 7803:              np.array([2, 3, 0], dtype=dt)]
 7804:         l = _multiarray_tests.test_neighborhood_iterator_oob(
 7805:                 x, [-1, 3], NEIGH_MODE['zero'], [-2, 0], NEIGH_MODE['mirror'])
 7806:         assert_array_equal(l, r)
 7807: 
 7808:         # Stacking mirror on top of zero: 2nd
 7809:         x = np.array([1, 2, 3], dtype=dt)
 7810:         r = [np.array([0, 1, 2], dtype=dt),
 7811:              np.array([1, 2, 3], dtype=dt),
 7812:              np.array([2, 3, 0], dtype=dt),
 7813:              np.array([3, 0, 0], dtype=dt),
 7814:              np.array([0, 0, 3], dtype=dt)]
 7815:         l = _multiarray_tests.test_neighborhood_iterator_oob(
 7816:                 x, [-1, 3], NEIGH_MODE['zero'], [0, 2], NEIGH_MODE['mirror'])
 7817:         assert_array_equal(l, r)
 7818: 
 7819:         # Stacking mirror on top of zero: 3rd
 7820:         x = np.array([1, 2, 3], dtype=dt)
 7821:         r = [np.array([1, 0, 0, 1, 2], dtype=dt),
 7822:              np.array([0, 0, 1, 2, 3], dtype=dt),
 7823:              np.array([0, 1, 2, 3, 0], dtype=dt),
 7824:              np.array([1, 2, 3, 0, 0], dtype=dt),
 7825:              np.array([2, 3, 0, 0, 3], dtype=dt)]
 7826:         l = _multiarray_tests.test_neighborhood_iterator_oob(
 7827:                 x, [-1, 3], NEIGH_MODE['zero'], [-2, 2], NEIGH_MODE['mirror'])
 7828:         assert_array_equal(l, r)
 7829: 
 7830:     # 3rd simple, 1d test: stacking 2 neigh iterators, mixing const padding and
 7831:     # circular padding
 7832:     def test_simple_circular(self):
 7833:         dt = np.float64
 7834:         # Stacking zero on top of mirror
 7835:         x = np.array([1, 2, 3], dtype=dt)
 7836:         r = [np.array([0, 3, 1], dtype=dt),
 7837:              np.array([3, 1, 2], dtype=dt),
 7838:              np.array([1, 2, 3], dtype=dt),
 7839:              np.array([2, 3, 1], dtype=dt),
 7840:              np.array([3, 1, 0], dtype=dt)]
 7841:         l = _multiarray_tests.test_neighborhood_iterator_oob(
 7842:                 x, [-1, 3], NEIGH_MODE['circular'], [-1, 1], NEIGH_MODE['zero'])
 7843:         assert_array_equal(l, r)
 7844: 
 7845:         # Stacking mirror on top of zero
 7846:         x = np.array([1, 2, 3], dtype=dt)
 7847:         r = [np.array([3, 0, 0], dtype=dt),
 7848:              np.array([0, 0, 1], dtype=dt),
 7849:              np.array([0, 1, 2], dtype=dt),
 7850:              np.array([1, 2, 3], dtype=dt),
 7851:              np.array([2, 3, 0], dtype=dt)]
 7852:         l = _multiarray_tests.test_neighborhood_iterator_oob(
 7853:                 x, [-1, 3], NEIGH_MODE['zero'], [-2, 0], NEIGH_MODE['circular'])
 7854:         assert_array_equal(l, r)
 7855: 
 7856:         # Stacking mirror on top of zero: 2nd
 7857:         x = np.array([1, 2, 3], dtype=dt)
 7858:         r = [np.array([0, 1, 2], dtype=dt),
 7859:              np.array([1, 2, 3], dtype=dt),
 7860:              np.array([2, 3, 0], dtype=dt),
 7861:              np.array([3, 0, 0], dtype=dt),
 7862:              np.array([0, 0, 1], dtype=dt)]
 7863:         l = _multiarray_tests.test_neighborhood_iterator_oob(
 7864:                 x, [-1, 3], NEIGH_MODE['zero'], [0, 2], NEIGH_MODE['circular'])
 7865:         assert_array_equal(l, r)
 7866: 
 7867:         # Stacking mirror on top of zero: 3rd
 7868:         x = np.array([1, 2, 3], dtype=dt)
 7869:         r = [np.array([3, 0, 0, 1, 2], dtype=dt),
 7870:              np.array([0, 0, 1, 2, 3], dtype=dt),
 7871:              np.array([0, 1, 2, 3, 0], dtype=dt),
 7872:              np.array([1, 2, 3, 0, 0], dtype=dt),
 7873:              np.array([2, 3, 0, 0, 1], dtype=dt)]
 7874:         l = _multiarray_tests.test_neighborhood_iterator_oob(
 7875:                 x, [-1, 3], NEIGH_MODE['zero'], [-2, 2], NEIGH_MODE['circular'])
 7876:         assert_array_equal(l, r)
 7877: 
 7878:     # 4th simple, 1d test: stacking 2 neigh iterators, but with lower iterator
 7879:     # being strictly within the array
 7880:     def test_simple_strict_within(self):
 7881:         dt = np.float64
 7882:         # Stacking zero on top of zero, first neighborhood strictly inside the
 7883:         # array
 7884:         x = np.array([1, 2, 3], dtype=dt)
 7885:         r = [np.array([1, 2, 3, 0], dtype=dt)]
 7886:         l = _multiarray_tests.test_neighborhood_iterator_oob(
 7887:                 x, [1, 1], NEIGH_MODE['zero'], [-1, 2], NEIGH_MODE['zero'])
 7888:         assert_array_equal(l, r)
 7889: 
 7890:         # Stacking mirror on top of zero, first neighborhood strictly inside the
 7891:         # array
 7892:         x = np.array([1, 2, 3], dtype=dt)
 7893:         r = [np.array([1, 2, 3, 3], dtype=dt)]
 7894:         l = _multiarray_tests.test_neighborhood_iterator_oob(
 7895:                 x, [1, 1], NEIGH_MODE['zero'], [-1, 2], NEIGH_MODE['mirror'])
 7896:         assert_array_equal(l, r)
 7897: 
 7898:         # Stacking mirror on top of zero, first neighborhood strictly inside the
 7899:         # array
 7900:         x = np.array([1, 2, 3], dtype=dt)
 7901:         r = [np.array([1, 2, 3, 1], dtype=dt)]
 7902:         l = _multiarray_tests.test_neighborhood_iterator_oob(
 7903:                 x, [1, 1], NEIGH_MODE['zero'], [-1, 2], NEIGH_MODE['circular'])
 7904:         assert_array_equal(l, r)
 7905: 
 7906: class TestWarnings:
 7907: 
 7908:     def test_complex_warning(self):
 7909:         x = np.array([1, 2])
 7910:         y = np.array([1 - 2j, 1 + 2j])
 7911: 
 7912:         with warnings.catch_warnings():
 7913:             warnings.simplefilter("error", ComplexWarning)
 7914:             assert_raises(ComplexWarning, x.__setitem__, slice(None), y)
 7915:             assert_equal(x, [1, 2])
 7916: 
 7917: 
 7918: class TestMinScalarType:
 7919: 
 7920:     def test_usigned_shortshort(self):
 7921:         dt = np.min_scalar_type(2**8 - 1)
 7922:         wanted = np.dtype('uint8')
 7923:         assert_equal(wanted, dt)
 7924: 
 7925:     def test_usigned_short(self):
 7926:         dt = np.min_scalar_type(2**16 - 1)
 7927:         wanted = np.dtype('uint16')
 7928:         assert_equal(wanted, dt)
 7929: 
 7930:     def test_usigned_int(self):
 7931:         dt = np.min_scalar_type(2**32 - 1)
 7932:         wanted = np.dtype('uint32')
 7933:         assert_equal(wanted, dt)
 7934: 
 7935:     def test_usigned_longlong(self):
 7936:         dt = np.min_scalar_type(2**63 - 1)
 7937:         wanted = np.dtype('uint64')
 7938:         assert_equal(wanted, dt)
 7939: 
 7940:     def test_object(self):
 7941:         dt = np.min_scalar_type(2**64)
 7942:         wanted = np.dtype('O')
 7943:         assert_equal(wanted, dt)
 7944: 
 7945: 
 7946: from numpy._core._internal import _dtype_from_pep3118
 7947: 
 7948: 
 7949: class TestPEP3118Dtype:
 7950:     def _check(self, spec, wanted):
 7951:         dt = np.dtype(wanted)
 7952:         actual = _dtype_from_pep3118(spec)
 7953:         assert_equal(actual, dt,
 7954:                      err_msg=f"spec {spec!r} != dtype {wanted!r}")
 7955: 
 7956:     def test_native_padding(self):
 7957:         align = np.dtype('i').alignment
 7958:         for j in range(8):
 7959:             if j == 0:
 7960:                 s = 'bi'
 7961:             else:
 7962:                 s = 'b%dxi' % j
 7963:             self._check('@' + s, {'f0': ('i1', 0),
 7964:                                 'f1': ('i', align * (1 + j // align))})
 7965:             self._check('=' + s, {'f0': ('i1', 0),
 7966:                                 'f1': ('i', 1 + j)})
 7967: 
 7968:     def test_native_padding_2(self):
 7969:         # Native padding should work also for structs and sub-arrays
 7970:         self._check('x3T{xi}', {'f0': (({'f0': ('i', 4)}, (3,)), 4)})
 7971:         self._check('^x3T{xi}', {'f0': (({'f0': ('i', 1)}, (3,)), 1)})
 7972: 
 7973:     def test_trailing_padding(self):
 7974:         # Trailing padding should be included, *and*, the item size
 7975:         # should match the alignment if in aligned mode
 7976:         align = np.dtype('i').alignment
 7977:         size = np.dtype('i').itemsize
 7978: 
 7979:         def aligned(n):
 7980:             return align * (1 + (n - 1) // align)
 7981: 
 7982:         base = {"formats": ['i'], "names": ['f0']}
 7983: 
 7984:         self._check('ix',    dict(itemsize=aligned(size + 1), **base))
 7985:         self._check('ixx',   dict(itemsize=aligned(size + 2), **base))
 7986:         self._check('ixxx',  dict(itemsize=aligned(size + 3), **base))
 7987:         self._check('ixxxx', dict(itemsize=aligned(size + 4), **base))
 7988:         self._check('i7x',   dict(itemsize=aligned(size + 7), **base))
 7989: 
 7990:         self._check('^ix',    dict(itemsize=size + 1, **base))
 7991:         self._check('^ixx',   dict(itemsize=size + 2, **base))
 7992:         self._check('^ixxx',  dict(itemsize=size + 3, **base))
 7993:         self._check('^ixxxx', dict(itemsize=size + 4, **base))
 7994:         self._check('^i7x',   dict(itemsize=size + 7, **base))
 7995: 
 7996:     def test_native_padding_3(self):
 7997:         dt = np.dtype(
 7998:                 [('a', 'b'), ('b', 'i'),
 7999:                     ('sub', np.dtype('b,i')), ('c', 'i')],
 8000:                 align=True)
 8001:         self._check("T{b:a:xxxi:b:T{b:f0:=i:f1:}:sub:xxxi:c:}", dt)
 8002: 
 8003:         dt = np.dtype(
 8004:                 [('a', 'b'), ('b', 'i'), ('c', 'b'), ('d', 'b'),
 8005:                     ('e', 'b'), ('sub', np.dtype('b,i', align=True))])
 8006:         self._check("T{b:a:=i:b:b:c:b:d:b:e:T{b:f0:xxxi:f1:}:sub:}", dt)
 8007: 
 8008:     def test_padding_with_array_inside_struct(self):
 8009:         dt = np.dtype(
 8010:                 [('a', 'b'), ('b', 'i'), ('c', 'b', (3,)),
 8011:                     ('d', 'i')],
 8012:                 align=True)
 8013:         self._check("T{b:a:xxxi:b:3b:c:xi:d:}", dt)
 8014: 
 8015:     def test_byteorder_inside_struct(self):
 8016:         # The byte order after @T{=i} should be '=', not '@'.
 8017:         # Check this by noting the absence of native alignment.
 8018:         self._check('@T{^i}xi', {'f0': ({'f0': ('i', 0)}, 0),
 8019:                                  'f1': ('i', 5)})
 8020: 
 8021:     def test_intra_padding(self):
 8022:         # Natively aligned sub-arrays may require some internal padding
 8023:         align = np.dtype('i').alignment
 8024:         size = np.dtype('i').itemsize
 8025: 
 8026:         def aligned(n):
 8027:             return (align * (1 + (n - 1) // align))
 8028: 
 8029:         self._check('(3)T{ix}', ({
 8030:             "names": ['f0'],
 8031:             "formats": ['i'],
 8032:             "offsets": [0],
 8033:             "itemsize": aligned(size + 1)
 8034:         }, (3,)))
 8035: 
 8036:     def test_char_vs_string(self):
 8037:         dt = np.dtype('c')
 8038:         self._check('c', dt)
 8039: 
 8040:         dt = np.dtype([('f0', 'S1', (4,)), ('f1', 'S4')])
 8041:         self._check('4c4s', dt)
 8042: 
 8043:     def test_field_order(self):
 8044:         # gh-9053 - previously, we relied on dictionary key order
 8045:         self._check("(0)I:a:f:b:", [('a', 'I', (0,)), ('b', 'f')])
 8046:         self._check("(0)I:b:f:a:", [('b', 'I', (0,)), ('a', 'f')])
 8047: 
 8048:     def test_unnamed_fields(self):
 8049:         self._check('ii',     [('f0', 'i'), ('f1', 'i')])
 8050:         self._check('ii:f0:', [('f1', 'i'), ('f0', 'i')])
 8051: 
 8052:         self._check('i', 'i')
 8053:         self._check('i:f0:', [('f0', 'i')])
 8054: 
 8055: 
 8056: class TestNewBufferProtocol:
 8057:     """ Test PEP3118 buffers """
 8058: 
 8059:     def _check_roundtrip(self, obj):
 8060:         obj = np.asarray(obj)
 8061:         x = memoryview(obj)
 8062:         y = np.asarray(x)
 8063:         y2 = np.array(x)
 8064:         assert_(not y.flags.owndata)
 8065:         assert_(y2.flags.owndata)
 8066: 
 8067:         assert_equal(y.dtype, obj.dtype)
 8068:         assert_equal(y.shape, obj.shape)
 8069:         assert_array_equal(obj, y)
 8070: 
 8071:         assert_equal(y2.dtype, obj.dtype)
 8072:         assert_equal(y2.shape, obj.shape)
 8073:         assert_array_equal(obj, y2)
 8074: 
 8075:     def test_roundtrip(self):
 8076:         x = np.array([1, 2, 3, 4, 5], dtype='i4')
 8077:         self._check_roundtrip(x)
 8078: 
 8079:         x = np.array([[1, 2], [3, 4]], dtype=np.float64)
 8080:         self._check_roundtrip(x)
 8081: 
 8082:         x = np.zeros((3, 3, 3), dtype=np.float32)[:, 0, :]
 8083:         self._check_roundtrip(x)
 8084: 
 8085:         dt = [('a', 'b'),
 8086:               ('b', 'h'),
 8087:               ('c', 'i'),
 8088:               ('d', 'l'),
 8089:               ('dx', 'q'),
 8090:               ('e', 'B'),
 8091:               ('f', 'H'),
 8092:               ('g', 'I'),
 8093:               ('h', 'L'),
 8094:               ('hx', 'Q'),
 8095:               ('i', np.single),
 8096:               ('j', np.double),
 8097:               ('k', np.longdouble),
 8098:               ('ix', np.csingle),
 8099:               ('jx', np.cdouble),
 8100:               ('kx', np.clongdouble),
 8101:               ('l', 'S4'),
 8102:               ('m', 'U4'),
 8103:               ('n', 'V3'),
 8104:               ('o', '?'),
 8105:               ('p', np.half),
 8106:               ]
 8107:         x = np.array(
 8108:                 [(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 8109:                     b'aaaa', 'bbbb', b'xxx', True, 1.0)],
 8110:                 dtype=dt)
 8111:         self._check_roundtrip(x)
 8112: 
 8113:         x = np.array(([[1, 2], [3, 4]],), dtype=[('a', (int, (2, 2)))])
 8114:         self._check_roundtrip(x)
 8115: 
 8116:         x = np.array([1, 2, 3], dtype='>i2')
 8117:         self._check_roundtrip(x)
 8118: 
 8119:         x = np.array([1, 2, 3], dtype='<i2')
 8120:         self._check_roundtrip(x)
 8121: 
 8122:         x = np.array([1, 2, 3], dtype='>i4')
 8123:         self._check_roundtrip(x)
 8124: 
 8125:         x = np.array([1, 2, 3], dtype='<i4')
 8126:         self._check_roundtrip(x)
 8127: 
 8128:         # check long long can be represented as non-native
 8129:         x = np.array([1, 2, 3], dtype='>q')
 8130:         self._check_roundtrip(x)
 8131: 
 8132:         # Native-only data types can be passed through the buffer interface
 8133:         # only in native byte order
 8134:         if sys.byteorder == 'little':
 8135:             x = np.array([1, 2, 3], dtype='>g')
 8136:             assert_raises(ValueError, self._check_roundtrip, x)
 8137:             x = np.array([1, 2, 3], dtype='<g')
 8138:             self._check_roundtrip(x)
 8139:         else:
 8140:             x = np.array([1, 2, 3], dtype='>g')
 8141:             self._check_roundtrip(x)
 8142:             x = np.array([1, 2, 3], dtype='<g')
 8143:             assert_raises(ValueError, self._check_roundtrip, x)
 8144: 
 8145:     def test_roundtrip_half(self):
 8146:         half_list = [
 8147:             1.0,
 8148:             -2.0,
 8149:             6.5504 * 10**4,  # (max half precision)
 8150:             2**-14,  # ~= 6.10352 * 10**-5 (minimum positive normal)
 8151:             2**-24,  # ~= 5.96046 * 10**-8 (minimum strictly positive subnormal)
 8152:             0.0,
 8153:             -0.0,
 8154:             float('+inf'),
 8155:             float('-inf'),
 8156:             0.333251953125,  # ~= 1/3
 8157:         ]
 8158: 
 8159:         x = np.array(half_list, dtype='>e')
 8160:         self._check_roundtrip(x)
 8161:         x = np.array(half_list, dtype='<e')
 8162:         self._check_roundtrip(x)
 8163: 
 8164:     def test_roundtrip_single_types(self):
 8165:         for typ in np._core.sctypeDict.values():
 8166:             dtype = np.dtype(typ)
 8167: 
 8168:             if dtype.char in 'Mm':
 8169:                 # datetimes cannot be used in buffers
 8170:                 continue
 8171:             if dtype.char == 'V':
 8172:                 # skip void
 8173:                 continue
 8174: 
 8175:             x = np.zeros(4, dtype=dtype)
 8176:             self._check_roundtrip(x)
 8177: 
 8178:             if dtype.char not in 'qQgG':
 8179:                 dt = dtype.newbyteorder('<')
 8180:                 x = np.zeros(4, dtype=dt)
 8181:                 self._check_roundtrip(x)
 8182: 
 8183:                 dt = dtype.newbyteorder('>')
 8184:                 x = np.zeros(4, dtype=dt)
 8185:                 self._check_roundtrip(x)
 8186: 
 8187:     def test_roundtrip_scalar(self):
 8188:         # Issue #4015.
 8189:         self._check_roundtrip(0)
 8190: 
 8191:     def test_invalid_buffer_format(self):
 8192:         # datetime64 cannot be used fully in a buffer yet
 8193:         # Should be fixed in the next Numpy major release
 8194:         dt = np.dtype([('a', 'uint16'), ('b', 'M8[s]')])
 8195:         a = np.empty(3, dt)
 8196:         assert_raises((ValueError, BufferError), memoryview, a)
 8197:         assert_raises((ValueError, BufferError), memoryview, np.array((3), 'M8[D]'))
 8198: 
 8199:     def test_export_simple_1d(self):
 8200:         x = np.array([1, 2, 3, 4, 5], dtype='i')
 8201:         y = memoryview(x)
 8202:         assert_equal(y.format, 'i')
 8203:         assert_equal(y.shape, (5,))
 8204:         assert_equal(y.ndim, 1)
 8205:         assert_equal(y.strides, (4,))
 8206:         assert_equal(y.suboffsets, ())
 8207:         assert_equal(y.itemsize, 4)
 8208: 
 8209:     def test_export_simple_nd(self):
 8210:         x = np.array([[1, 2], [3, 4]], dtype=np.float64)
 8211:         y = memoryview(x)
 8212:         assert_equal(y.format, 'd')
 8213:         assert_equal(y.shape, (2, 2))
 8214:         assert_equal(y.ndim, 2)
 8215:         assert_equal(y.strides, (16, 8))
 8216:         assert_equal(y.suboffsets, ())
 8217:         assert_equal(y.itemsize, 8)
 8218: 
 8219:     def test_export_discontiguous(self):
 8220:         x = np.zeros((3, 3, 3), dtype=np.float32)[:, 0, :]
 8221:         y = memoryview(x)
 8222:         assert_equal(y.format, 'f')
 8223:         assert_equal(y.shape, (3, 3))
 8224:         assert_equal(y.ndim, 2)
 8225:         assert_equal(y.strides, (36, 4))
 8226:         assert_equal(y.suboffsets, ())
 8227:         assert_equal(y.itemsize, 4)
 8228: 
 8229:     def test_export_record(self):
 8230:         dt = [('a', 'b'),
 8231:               ('b', 'h'),
 8232:               ('c', 'i'),
 8233:               ('d', 'l'),
 8234:               ('dx', 'q'),
 8235:               ('e', 'B'),
 8236:               ('f', 'H'),
 8237:               ('g', 'I'),
 8238:               ('h', 'L'),
 8239:               ('hx', 'Q'),
 8240:               ('i', np.single),
 8241:               ('j', np.double),
 8242:               ('k', np.longdouble),
 8243:               ('ix', np.csingle),
 8244:               ('jx', np.cdouble),
 8245:               ('kx', np.clongdouble),
 8246:               ('l', 'S4'),
 8247:               ('m', 'U4'),
 8248:               ('n', 'V3'),
 8249:               ('o', '?'),
 8250:               ('p', np.half),
 8251:               ]
 8252:         x = np.array(
 8253:                 [(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 8254:                     b'aaaa', 'bbbb', b'   ', True, 1.0)],
 8255:                 dtype=dt)
 8256:         y = memoryview(x)
 8257:         assert_equal(y.shape, (1,))
 8258:         assert_equal(y.ndim, 1)
 8259:         assert_equal(y.suboffsets, ())
 8260: 
 8261:         sz = sum(np.dtype(b).itemsize for a, b in dt)
 8262:         if np.dtype('l').itemsize == 4:
 8263:             assert_equal(y.format, 'T{b:a:=h:b:i:c:l:d:q:dx:B:e:@H:f:=I:g:L:h:Q:hx:f:i:d:j:^g:k:=Zf:ix:Zd:jx:^Zg:kx:4s:l:=4w:m:3x:n:?:o:@e:p:}')
 8264:         else:
 8265:             assert_equal(y.format, 'T{b:a:=h:b:i:c:q:d:q:dx:B:e:@H:f:=I:g:Q:h:Q:hx:f:i:d:j:^g:k:=Zf:ix:Zd:jx:^Zg:kx:4s:l:=4w:m:3x:n:?:o:@e:p:}')
 8266:         assert_equal(y.strides, (sz,))
 8267:         assert_equal(y.itemsize, sz)
 8268: 
 8269:     def test_export_subarray(self):
 8270:         x = np.array(([[1, 2], [3, 4]],), dtype=[('a', ('i', (2, 2)))])
 8271:         y = memoryview(x)
 8272:         assert_equal(y.format, 'T{(2,2)i:a:}')
 8273:         assert_equal(y.shape, ())
 8274:         assert_equal(y.ndim, 0)
 8275:         assert_equal(y.strides, ())
 8276:         assert_equal(y.suboffsets, ())
 8277:         assert_equal(y.itemsize, 16)
 8278: 
 8279:     def test_export_endian(self):
 8280:         x = np.array([1, 2, 3], dtype='>i')
 8281:         y = memoryview(x)
 8282:         if sys.byteorder == 'little':
 8283:             assert_equal(y.format, '>i')
 8284:         else:
 8285:             assert_equal(y.format, 'i')
 8286: 
 8287:         x = np.array([1, 2, 3], dtype='<i')
 8288:         y = memoryview(x)
 8289:         if sys.byteorder == 'little':
 8290:             assert_equal(y.format, 'i')
 8291:         else:
 8292:             assert_equal(y.format, '<i')
 8293: 
 8294:     def test_export_flags(self):
 8295:         # Check SIMPLE flag, see also gh-3613 (exception should be BufferError)
 8296:         assert_raises(ValueError,
 8297:                       _multiarray_tests.get_buffer_info,
 8298:                        np.arange(5)[::2], ('SIMPLE',))
 8299: 
 8300:     @pytest.mark.parametrize(["obj", "error"], [
 8301:             pytest.param(np.array([1, 2], dtype=rational), ValueError, id="array"),
 8302:             pytest.param(rational(1, 2), TypeError, id="scalar")])
 8303:     def test_export_and_pickle_user_dtype(self, obj, error):
 8304:         # User dtypes should export successfully when FORMAT was not requested.
 8305:         with pytest.raises(error):
 8306:             _multiarray_tests.get_buffer_info(obj, ("STRIDED_RO", "FORMAT"))
 8307: 
 8308:         _multiarray_tests.get_buffer_info(obj, ("STRIDED_RO",))
 8309: 
 8310:         # This is currently also necessary to implement pickling:
 8311:         pickle_obj = pickle.dumps(obj)
 8312:         res = pickle.loads(pickle_obj)
 8313:         assert_array_equal(res, obj)
 8314: 
 8315:     def test_repr_user_dtype(self):
 8316:         dt = np.dtype(rational)
 8317:         assert_equal(repr(dt), 'dtype(rational)')
 8318: 
 8319:     def test_padding(self):
 8320:         for j in range(8):
 8321:             x = np.array([(1,), (2,)], dtype={'f0': (int, j)})
 8322:             self._check_roundtrip(x)
 8323: 
 8324:     def test_reference_leak(self):
 8325:         if HAS_REFCOUNT:
 8326:             count_1 = sys.getrefcount(np._core._internal)
 8327:         a = np.zeros(4)
 8328:         b = memoryview(a)
 8329:         c = np.asarray(b)
 8330:         if HAS_REFCOUNT:
 8331:             count_2 = sys.getrefcount(np._core._internal)
 8332:             assert_equal(count_1, count_2)
 8333: 
 8334:     def test_padded_struct_array(self):
 8335:         dt1 = np.dtype(
 8336:                 [('a', 'b'), ('b', 'i'), ('sub', np.dtype('b,i')), ('c', 'i')],
 8337:                 align=True)
 8338:         x1 = np.arange(dt1.itemsize, dtype=np.int8).view(dt1)
 8339:         self._check_roundtrip(x1)
 8340: 
 8341:         dt2 = np.dtype(
 8342:                 [('a', 'b'), ('b', 'i'), ('c', 'b', (3,)), ('d', 'i')],
 8343:                 align=True)
 8344:         x2 = np.arange(dt2.itemsize, dtype=np.int8).view(dt2)
 8345:         self._check_roundtrip(x2)
 8346: 
 8347:         dt3 = np.dtype(
 8348:                 [('a', 'b'), ('b', 'i'), ('c', 'b'), ('d', 'b'),
 8349:                     ('e', 'b'), ('sub', np.dtype('b,i', align=True))])
 8350:         x3 = np.arange(dt3.itemsize, dtype=np.int8).view(dt3)
 8351:         self._check_roundtrip(x3)
 8352: 
 8353:     @pytest.mark.valgrind_error(reason="leaks buffer info cache temporarily.")
 8354:     def test_relaxed_strides(self, c=np.ones((1, 10, 10), dtype='i8')):  # noqa: B008
 8355:         # Note: c defined as parameter so that it is persistent and leak
 8356:         # checks will notice gh-16934 (buffer info cache leak).
 8357:         c.strides = (-1, 80, 8)  # strides need to be fixed at export
 8358: 
 8359:         assert_(memoryview(c).strides == (800, 80, 8))
 8360: 
 8361:         # Writing C-contiguous data to a BytesIO buffer should work
 8362:         fd = io.BytesIO()
 8363:         fd.write(c.data)
 8364: 
 8365:         fortran = c.T
 8366:         assert_(memoryview(fortran).strides == (8, 80, 800))
 8367: 
 8368:         arr = np.ones((1, 10))
 8369:         if arr.flags.f_contiguous:
 8370:             shape, strides = _multiarray_tests.get_buffer_info(
 8371:                     arr, ['F_CONTIGUOUS'])
 8372:             assert_(strides[0] == 8)
 8373:             arr = np.ones((10, 1), order='F')
 8374:             shape, strides = _multiarray_tests.get_buffer_info(
 8375:                     arr, ['C_CONTIGUOUS'])
 8376:             assert_(strides[-1] == 8)
 8377: 
 8378:     def test_out_of_order_fields(self):
 8379:         dt = np.dtype({
 8380:             "formats": ['<i4', '<i4'],
 8381:             "names": ['one', 'two'],
 8382:             "offsets": [4, 0],
 8383:             "itemsize": 8
 8384:         })
 8385: 
 8386:         # overlapping fields cannot be represented by PEP3118
 8387:         arr = np.empty(1, dt)
 8388:         with assert_raises(ValueError):
 8389:             memoryview(arr)
 8390: 
 8391:     def test_max_dims(self):
 8392:         a = np.ones((1,) * 32)
 8393:         self._check_roundtrip(a)
 8394: 
 8395:     def test_error_pointer_type(self):
 8396:         # gh-6741
 8397:         m = memoryview(ctypes.pointer(ctypes.c_uint8()))
 8398:         assert_('&' in m.format)
 8399: 
 8400:         assert_raises_regex(
 8401:             ValueError, "format string",
 8402:             np.array, m)
 8403: 
 8404:     def test_error_message_unsupported(self):
 8405:         # wchar has no corresponding numpy type - if this changes in future, we
 8406:         # need a better way to construct an invalid memoryview format.
 8407:         t = ctypes.c_wchar * 4
 8408:         with assert_raises(ValueError) as cm:
 8409:             np.array(t())
 8410: 
 8411:         exc = cm.exception
 8412:         with assert_raises_regex(
 8413:             NotImplementedError,
 8414:             r"Unrepresentable .* 'u' \(UCS-2 strings\)"
 8415:         ):
 8416:             raise exc.__cause__
 8417: 
 8418:     def test_ctypes_integer_via_memoryview(self):
 8419:         # gh-11150, due to bpo-10746
 8420:         for c_integer in {ctypes.c_int, ctypes.c_long, ctypes.c_longlong}:
 8421:             value = c_integer(42)
 8422:             with warnings.catch_warnings(record=True):
 8423:                 warnings.filterwarnings('always', r'.*\bctypes\b', RuntimeWarning)
 8424:                 np.asarray(value)
 8425: 
 8426:     def test_ctypes_struct_via_memoryview(self):
 8427:         # gh-10528
 8428:         class foo(ctypes.Structure):
 8429:             _fields_ = [('a', ctypes.c_uint8), ('b', ctypes.c_uint32)]
 8430:         f = foo(a=1, b=2)
 8431: 
 8432:         with warnings.catch_warnings(record=True):
 8433:             warnings.filterwarnings('always', r'.*\bctypes\b', RuntimeWarning)
 8434:             arr = np.asarray(f)
 8435: 
 8436:         assert_equal(arr['a'], 1)
 8437:         assert_equal(arr['b'], 2)
 8438:         f.a = 3
 8439:         assert_equal(arr['a'], 3)
 8440: 
 8441:     @pytest.mark.parametrize("obj", [np.ones(3), np.ones(1, dtype="i,i")[()]])
 8442:     def test_error_if_stored_buffer_info_is_corrupted(self, obj):
 8443:         """
 8444:         If a user extends a NumPy array before 1.20 and then runs it
 8445:         on NumPy 1.20+. A C-subclassed array might in theory modify
 8446:         the new buffer-info field. This checks that an error is raised
 8447:         if this happens (for buffer export), an error is written on delete.
 8448:         This is a sanity check to help users transition to safe code, it
 8449:         may be deleted at any point.
 8450:         """
 8451:         # corrupt buffer info:
 8452:         _multiarray_tests.corrupt_or_fix_bufferinfo(obj)
 8453:         name = type(obj)
 8454:         with pytest.raises(RuntimeError,
 8455:                     match=f".*{name} appears to be C subclassed"):
 8456:             memoryview(obj)
 8457:         # Fix buffer info again before we delete (or we lose the memory)
 8458:         _multiarray_tests.corrupt_or_fix_bufferinfo(obj)
 8459: 
 8460:     def test_no_suboffsets(self):
 8461:         try:
 8462:             import _testbuffer
 8463:         except ImportError:
 8464:             raise pytest.skip("_testbuffer is not available")
 8465: 
 8466:         for shape in [(2, 3), (2, 3, 4)]:
 8467:             data = list(range(np.prod(shape)))
 8468:             buffer = _testbuffer.ndarray(data, shape, format='i',
 8469:                                          flags=_testbuffer.ND_PIL)
 8470:             msg = "NumPy currently does not support.*suboffsets"
 8471:             with pytest.raises(BufferError, match=msg):
 8472:                 np.asarray(buffer)
 8473:             with pytest.raises(BufferError, match=msg):
 8474:                 np.asarray([buffer])
 8475: 
 8476:             # Also check (unrelated and more limited but similar) frombuffer:
 8477:             with pytest.raises(BufferError):
 8478:                 np.frombuffer(buffer)
 8479: 
 8480: 
 8481: class TestArrayCreationCopyArgument:
 8482: 
 8483:     class RaiseOnBool:
 8484: 
 8485:         def __bool__(self):
 8486:             raise ValueError
 8487: 
 8488:     true_vals = [True, np._CopyMode.ALWAYS, np.True_]
 8489:     if_needed_vals = [None, np._CopyMode.IF_NEEDED]
 8490:     false_vals = [False, np._CopyMode.NEVER, np.False_]
 8491: 
 8492:     def test_scalars(self):
 8493:         # Test both numpy and python scalars
 8494:         for dtype in np.typecodes["All"]:
 8495:             arr = np.zeros((), dtype=dtype)
 8496:             scalar = arr[()]
 8497:             pyscalar = arr.item(0)
 8498: 
 8499:             # Test never-copy raises error:
 8500:             assert_raises(ValueError, np.array, pyscalar,
 8501:                             copy=self.RaiseOnBool())
 8502:             assert_raises(ValueError, _multiarray_tests.npy_ensurenocopy,
 8503:                             [1])
 8504:             for copy in self.false_vals:
 8505:                 assert_raises(ValueError, np.array, scalar, copy=copy)
 8506:                 assert_raises(ValueError, np.array, pyscalar, copy=copy)
 8507:                 # Casting with a dtype (to unsigned integers) can be special:
 8508:                 with pytest.raises(ValueError):
 8509:                     np.array(pyscalar, dtype=np.int64, copy=copy)
 8510: 
 8511:     def test_compatible_cast(self):
 8512: 
 8513:         # Some types are compatible even though they are different, no
 8514:         # copy is necessary for them. This is mostly true for some integers
 8515:         def int_types(byteswap=False):
 8516:             int_types = (np.typecodes["Integer"] +
 8517:                          np.typecodes["UnsignedInteger"])
 8518:             for int_type in int_types:
 8519:                 yield np.dtype(int_type)
 8520:                 if byteswap:
 8521:                     yield np.dtype(int_type).newbyteorder()
 8522: 
 8523:         for int1 in int_types():
 8524:             for int2 in int_types(True):
 8525:                 arr = np.arange(10, dtype=int1)
 8526: 
 8527:                 for copy in self.true_vals:
 8528:                     res = np.array(arr, copy=copy, dtype=int2)
 8529:                     assert res is not arr and res.flags.owndata
 8530:                     assert_array_equal(res, arr)
 8531: 
 8532:                 if int1 == int2:
 8533:                     # Casting is not necessary, base check is sufficient here
 8534:                     for copy in self.if_needed_vals:
 8535:                         res = np.array(arr, copy=copy, dtype=int2)
 8536:                         assert res is arr or res.base is arr
 8537: 
 8538:                     for copy in self.false_vals:
 8539:                         res = np.array(arr, copy=copy, dtype=int2)
 8540:                         assert res is arr or res.base is arr
 8541: 
 8542:                 else:
 8543:                     # Casting is necessary, assert copy works:
 8544:                     for copy in self.if_needed_vals:
 8545:                         res = np.array(arr, copy=copy, dtype=int2)
 8546:                         assert res is not arr and res.flags.owndata
 8547:                         assert_array_equal(res, arr)
 8548: 
 8549:                     assert_raises(ValueError, np.array,
 8550:                                   arr, copy=False,
 8551:                                   dtype=int2)
 8552: 
 8553:     def test_buffer_interface(self):
 8554: 
 8555:         # Buffer interface gives direct memory access (no copy)
 8556:         arr = np.arange(10)
 8557:         view = memoryview(arr)
 8558: 
 8559:         # Checking bases is a bit tricky since numpy creates another
 8560:         # memoryview, so use may_share_memory.
 8561:         for copy in self.true_vals:
 8562:             res = np.array(view, copy=copy)
 8563:             assert not np.may_share_memory(arr, res)
 8564:         for copy in self.false_vals:
 8565:             res = np.array(view, copy=copy)
 8566:             assert np.may_share_memory(arr, res)
 8567:         res = np.array(view, copy=np._CopyMode.NEVER)
 8568:         assert np.may_share_memory(arr, res)
 8569: 
 8570:     def test_array_interfaces(self):
 8571:         base_arr = np.arange(10)
 8572: 
 8573:         # Array interface gives direct memory access (much like a memoryview)
 8574:         class ArrayLike:
 8575:             __array_interface__ = base_arr.__array_interface__
 8576: 
 8577:         arr = ArrayLike()
 8578: 
 8579:         for copy, val in [(True, None), (np._CopyMode.ALWAYS, None),
 8580:                           (False, arr), (np._CopyMode.IF_NEEDED, arr),
 8581:                           (np._CopyMode.NEVER, arr)]:
 8582:             res = np.array(arr, copy=copy)
 8583:             assert res.base is val
 8584: 
 8585:     def test___array__(self):
 8586:         base_arr = np.arange(10)
 8587: 
 8588:         class ArrayLike:
 8589:             def __array__(self, dtype=None, copy=None):
 8590:                 return base_arr
 8591: 
 8592:         arr = ArrayLike()
 8593: 
 8594:         for copy in self.true_vals:
 8595:             res = np.array(arr, copy=copy)
 8596:             assert_array_equal(res, base_arr)
 8597:             # An additional copy is no longer forced by NumPy in this case.
 8598:             # NumPy trusts the ArrayLike made a copy:
 8599:             assert res is base_arr
 8600: 
 8601:         for copy in self.if_needed_vals + self.false_vals:
 8602:             res = np.array(arr, copy=copy)
 8603:             assert_array_equal(res, base_arr)
 8604:             assert res is base_arr  # numpy trusts the ArrayLike
 8605: 
 8606:     def test___array__copy_arg(self):
 8607:         a = np.ones((10, 10), dtype=int)
 8608: 
 8609:         assert np.shares_memory(a, a.__array__())
 8610:         assert not np.shares_memory(a, a.__array__(float))
 8611:         assert not np.shares_memory(a, a.__array__(float, copy=None))
 8612:         assert not np.shares_memory(a, a.__array__(copy=True))
 8613:         assert np.shares_memory(a, a.__array__(copy=None))
 8614:         assert np.shares_memory(a, a.__array__(copy=False))
 8615:         assert np.shares_memory(a, a.__array__(int, copy=False))
 8616:         with pytest.raises(ValueError):
 8617:             np.shares_memory(a, a.__array__(float, copy=False))
 8618: 
 8619:         base_arr = np.arange(10)
 8620: 
 8621:         class ArrayLikeNoCopy:
 8622:             def __array__(self, dtype=None):
 8623:                 return base_arr
 8624: 
 8625:         a = ArrayLikeNoCopy()
 8626: 
 8627:         # explicitly passing copy=None shouldn't raise a warning
 8628:         arr = np.array(a, copy=None)
 8629:         assert_array_equal(arr, base_arr)
 8630:         assert arr is base_arr
 8631: 
 8632:         # As of NumPy 2.1, explicitly passing copy=True does trigger passing
 8633:         # it to __array__ (deprecation warning is triggered).
 8634:         with pytest.warns(DeprecationWarning,
 8635:                           match="__array__.*must implement.*'copy'"):
 8636:             arr = np.array(a, copy=True)
 8637:         assert_array_equal(arr, base_arr)
 8638:         assert arr is not base_arr
 8639: 
 8640:         # And passing copy=False gives a deprecation warning, but also raises
 8641:         # an error:
 8642:         with pytest.warns(DeprecationWarning, match="__array__.*'copy'"):
 8643:             with pytest.raises(ValueError,
 8644:                     match=r"Unable to avoid copy(.|\n)*numpy_2_0_migration_guide.html"):
 8645:                 np.array(a, copy=False)
 8646: 
 8647:     def test___array__copy_once(self):
 8648:         size = 100
 8649:         base_arr = np.zeros((size, size))
 8650:         copy_arr = np.zeros((size, size))
 8651: 
 8652:         class ArrayRandom:
 8653:             def __init__(self):
 8654:                 self.true_passed = False
 8655: 
 8656:             def __array__(self, dtype=None, copy=None):
 8657:                 if copy:
 8658:                     self.true_passed = True
 8659:                     return copy_arr
 8660:                 else:
 8661:                     return base_arr
 8662: 
 8663:         arr_random = ArrayRandom()
 8664:         first_copy = np.array(arr_random, copy=True)
 8665:         assert arr_random.true_passed
 8666:         assert first_copy is copy_arr
 8667: 
 8668:         arr_random = ArrayRandom()
 8669:         no_copy = np.array(arr_random, copy=False)
 8670:         assert not arr_random.true_passed
 8671:         assert no_copy is base_arr
 8672: 
 8673:         arr_random = ArrayRandom()
 8674:         _ = np.array([arr_random], copy=True)
 8675:         assert not arr_random.true_passed
 8676: 
 8677:         arr_random = ArrayRandom()
 8678:         second_copy = np.array(arr_random, copy=True, order="F")
 8679:         assert arr_random.true_passed
 8680:         assert second_copy is not copy_arr
 8681: 
 8682:         arr_random = ArrayRandom()
 8683:         arr = np.ones((size, size))
 8684:         arr[...] = arr_random
 8685:         assert not arr_random.true_passed
 8686:         assert not np.shares_memory(arr, base_arr)
 8687: 
 8688:     @pytest.mark.skipif(not HAS_REFCOUNT, reason="Python lacks refcounts")
 8689:     def test__array__reference_leak(self):
 8690:         class NotAnArray:
 8691:             def __array__(self, dtype=None, copy=None):
 8692:                 raise NotImplementedError
 8693: 
 8694:         x = NotAnArray()
 8695: 
 8696:         refcount = sys.getrefcount(x)
 8697: 
 8698:         try:
 8699:             np.array(x)
 8700:         except NotImplementedError:
 8701:             pass
 8702: 
 8703:         gc.collect()
 8704: 
 8705:         assert refcount == sys.getrefcount(x)
 8706: 
 8707:     @pytest.mark.parametrize(
 8708:             "arr", [np.ones(()), np.arange(81).reshape((9, 9))])
 8709:     @pytest.mark.parametrize("order1", ["C", "F", None])
 8710:     @pytest.mark.parametrize("order2", ["C", "F", "A", "K"])
 8711:     def test_order_mismatch(self, arr, order1, order2):
 8712:         # The order is the main (python side) reason that can cause
 8713:         # a never-copy to fail.
 8714:         # Prepare C-order, F-order and non-contiguous arrays:
 8715:         arr = arr.copy(order1)
 8716:         if order1 == "C":
 8717:             assert arr.flags.c_contiguous
 8718:         elif order1 == "F":
 8719:             assert arr.flags.f_contiguous
 8720:         elif arr.ndim != 0:
 8721:             # Make array non-contiguous
 8722:             arr = arr[::2, ::2]
 8723:             assert not arr.flags.forc
 8724: 
 8725:         # Whether a copy is necessary depends on the order of arr:
 8726:         if order2 == "C":
 8727:             no_copy_necessary = arr.flags.c_contiguous
 8728:         elif order2 == "F":
 8729:             no_copy_necessary = arr.flags.f_contiguous
 8730:         else:
 8731:             # Keeporder and Anyorder are OK with non-contiguous output.
 8732:             # This is not consistent with the `astype` behaviour which
 8733:             # enforces contiguity for "A". It is probably historic from when
 8734:             # "K" did not exist.
 8735:             no_copy_necessary = True
 8736: 
 8737:         # Test it for both the array and a memoryview
 8738:         for view in [arr, memoryview(arr)]:
 8739:             for copy in self.true_vals:
 8740:                 res = np.array(view, copy=copy, order=order2)
 8741:                 assert res is not arr and res.flags.owndata
 8742:                 assert_array_equal(arr, res)
 8743: 
 8744:             if no_copy_necessary:
 8745:                 for copy in self.if_needed_vals + self.false_vals:
 8746:                     res = np.array(view, copy=copy, order=order2)
 8747:                     # res.base.obj refers to the memoryview
 8748:                     if not IS_PYPY:
 8749:                         assert res is arr or res.base.obj is arr
 8750:             else:
 8751:                 for copy in self.if_needed_vals:
 8752:                     res = np.array(arr, copy=copy, order=order2)
 8753:                     assert_array_equal(arr, res)
 8754:                 for copy in self.false_vals:
 8755:                     assert_raises(ValueError, np.array,
 8756:                                   view, copy=copy, order=order2)
 8757: 
 8758:     def test_striding_not_ok(self):
 8759:         arr = np.array([[1, 2, 4], [3, 4, 5]])
 8760:         assert_raises(ValueError, np.array,
 8761:                       arr.T, copy=np._CopyMode.NEVER,
 8762:                       order='C')
 8763:         assert_raises(ValueError, np.array,
 8764:                       arr.T, copy=np._CopyMode.NEVER,
 8765:                       order='C', dtype=np.int64)
 8766:         assert_raises(ValueError, np.array,
 8767:                       arr, copy=np._CopyMode.NEVER,
 8768:                       order='F')
 8769:         assert_raises(ValueError, np.array,
 8770:                       arr, copy=np._CopyMode.NEVER,
 8771:                       order='F', dtype=np.int64)
 8772: 
 8773: 
 8774: class TestArrayAttributeDeletion:
 8775: 
 8776:     def test_multiarray_writable_attributes_deletion(self):
 8777:         # ticket #2046, should not seqfault, raise AttributeError
 8778:         a = np.ones(2)
 8779:         attr = ['shape', 'strides', 'data', 'dtype', 'real', 'imag', 'flat']
 8780:         with suppress_warnings() as sup:
 8781:             sup.filter(DeprecationWarning, "Assigning the 'data' attribute")
 8782:             for s in attr:
 8783:                 assert_raises(AttributeError, delattr, a, s)
 8784: 
 8785:     def test_multiarray_not_writable_attributes_deletion(self):
 8786:         a = np.ones(2)
 8787:         attr = ["ndim", "flags", "itemsize", "size", "nbytes", "base",
 8788:                 "ctypes", "T", "__array_interface__", "__array_struct__",
 8789:                 "__array_priority__", "__array_finalize__"]
 8790:         for s in attr:
 8791:             assert_raises(AttributeError, delattr, a, s)
 8792: 
 8793:     def test_multiarray_flags_writable_attribute_deletion(self):
 8794:         a = np.ones(2).flags
 8795:         attr = ['writebackifcopy', 'updateifcopy', 'aligned', 'writeable']
 8796:         for s in attr:
 8797:             assert_raises(AttributeError, delattr, a, s)
 8798: 
 8799:     def test_multiarray_flags_not_writable_attribute_deletion(self):
 8800:         a = np.ones(2).flags
 8801:         attr = ["contiguous", "c_contiguous", "f_contiguous", "fortran",
 8802:                 "owndata", "fnc", "forc", "behaved", "carray", "farray",
 8803:                 "num"]
 8804:         for s in attr:
 8805:             assert_raises(AttributeError, delattr, a, s)
 8806: 
 8807: 
 8808: class TestArrayInterface:
 8809:     class Foo:
 8810:         def __init__(self, value):
 8811:             self.value = value
 8812:             self.iface = {'typestr': 'f8'}
 8813: 
 8814:         def __float__(self):
 8815:             return float(self.value)
 8816: 
 8817:         @property
 8818:         def __array_interface__(self):
 8819:             return self.iface
 8820: 
 8821:     f = Foo(0.5)
 8822: 
 8823:     @pytest.mark.parametrize('val, iface, expected', [
 8824:         (f, {}, 0.5),
 8825:         ([f], {}, [0.5]),
 8826:         ([f, f], {}, [0.5, 0.5]),
 8827:         (f, {'shape': ()}, 0.5),
 8828:         (f, {'shape': None}, TypeError),
 8829:         (f, {'shape': (1, 1)}, [[0.5]]),
 8830:         (f, {'shape': (2,)}, ValueError),
 8831:         (f, {'strides': ()}, 0.5),
 8832:         (f, {'strides': (2,)}, ValueError),
 8833:         (f, {'strides': 16}, TypeError),
 8834:         ])
 8835:     def test_scalar_interface(self, val, iface, expected):
 8836:         # Test scalar coercion within the array interface
 8837:         self.f.iface = {'typestr': 'f8'}
 8838:         self.f.iface.update(iface)
 8839:         if HAS_REFCOUNT:
 8840:             pre_cnt = sys.getrefcount(np.dtype('f8'))
 8841:         if isinstance(expected, type):
 8842:             assert_raises(expected, np.array, val)
 8843:         else:
 8844:             result = np.array(val)
 8845:             assert_equal(np.array(val), expected)
 8846:             assert result.dtype == 'f8'
 8847:             del result
 8848:         if HAS_REFCOUNT:
 8849:             post_cnt = sys.getrefcount(np.dtype('f8'))
 8850:             assert_equal(pre_cnt, post_cnt)
 8851: 
 8852: def test_interface_no_shape():
 8853:     class ArrayLike:
 8854:         array = np.array(1)
 8855:         __array_interface__ = array.__array_interface__
 8856:     assert_equal(np.array(ArrayLike()), 1)
 8857: 
 8858: 
 8859: def test_interface_no_shape_error():
 8860:     class ArrayLike:
 8861:         __array_interface__ = {"data": None, "typestr": "f8"}
 8862: 
 8863:     with pytest.raises(ValueError, match="Missing __array_interface__ shape"):
 8864:         np.array(ArrayLike())
 8865: 
 8866: 
 8867: def test_array_interface_itemsize():
 8868:     # See gh-6361
 8869:     my_dtype = np.dtype({'names': ['A', 'B'], 'formats': ['f4', 'f4'],
 8870:                          'offsets': [0, 8], 'itemsize': 16})
 8871:     a = np.ones(10, dtype=my_dtype)
 8872:     descr_t = np.dtype(a.__array_interface__['descr'])
 8873:     typestr_t = np.dtype(a.__array_interface__['typestr'])
 8874:     assert_equal(descr_t.itemsize, typestr_t.itemsize)
 8875: 
 8876: 
 8877: def test_array_interface_empty_shape():
 8878:     # See gh-7994
 8879:     arr = np.array([1, 2, 3])
 8880:     interface1 = dict(arr.__array_interface__)
 8881:     interface1['shape'] = ()
 8882: 
 8883:     class DummyArray1:
 8884:         __array_interface__ = interface1
 8885: 
 8886:     # NOTE: Because Py2 str/Py3 bytes supports the buffer interface, setting
 8887:     # the interface data to bytes would invoke the bug this tests for, that
 8888:     # __array_interface__ with shape=() is not allowed if the data is an object
 8889:     # exposing the buffer interface
 8890:     interface2 = dict(interface1)
 8891:     interface2['data'] = arr[0].tobytes()
 8892: 
 8893:     class DummyArray2:
 8894:         __array_interface__ = interface2
 8895: 
 8896:     arr1 = np.asarray(DummyArray1())
 8897:     arr2 = np.asarray(DummyArray2())
 8898:     arr3 = arr[:1].reshape(())
 8899:     assert_equal(arr1, arr2)
 8900:     assert_equal(arr1, arr3)
 8901: 
 8902: def test_array_interface_offset():
 8903:     arr = np.array([1, 2, 3], dtype='int32')
 8904:     interface = dict(arr.__array_interface__)
 8905:     interface['data'] = memoryview(arr)
 8906:     interface['shape'] = (2,)
 8907:     interface['offset'] = 4
 8908: 
 8909:     class DummyArray:
 8910:         __array_interface__ = interface
 8911: 
 8912:     arr1 = np.asarray(DummyArray())
 8913:     assert_equal(arr1, arr[1:])
 8914: 
 8915: def test_array_interface_unicode_typestr():
 8916:     arr = np.array([1, 2, 3], dtype='int32')
 8917:     interface = dict(arr.__array_interface__)
 8918:     interface['typestr'] = '\N{check mark}'
 8919: 
 8920:     class DummyArray:
 8921:         __array_interface__ = interface
 8922: 
 8923:     # should not be UnicodeEncodeError
 8924:     with pytest.raises(TypeError):
 8925:         np.asarray(DummyArray())
 8926: 
 8927: def test_flat_element_deletion():
 8928:     it = np.ones(3).flat
 8929:     try:
 8930:         del it[1]
 8931:         del it[1:2]
 8932:     except TypeError:
 8933:         pass
 8934:     except Exception:
 8935:         raise AssertionError
 8936: 
 8937: 
 8938: def test_scalar_element_deletion():
 8939:     a = np.zeros(2, dtype=[('x', 'int'), ('y', 'int')])
 8940:     assert_raises(ValueError, a[0].__delitem__, 'x')
 8941: 
 8942: 
 8943: class TestAsCArray:
 8944:     def test_1darray(self):
 8945:         array = np.arange(24, dtype=np.double)
 8946:         from_c = _multiarray_tests.test_as_c_array(array, 3)
 8947:         assert_equal(array[3], from_c)
 8948: 
 8949:     def test_2darray(self):
 8950:         array = np.arange(24, dtype=np.double).reshape(3, 8)
 8951:         from_c = _multiarray_tests.test_as_c_array(array, 2, 4)
 8952:         assert_equal(array[2, 4], from_c)
 8953: 
 8954:     def test_3darray(self):
 8955:         array = np.arange(24, dtype=np.double).reshape(2, 3, 4)
 8956:         from_c = _multiarray_tests.test_as_c_array(array, 1, 2, 3)
 8957:         assert_equal(array[1, 2, 3], from_c)
 8958: 
 8959: 
 8960: class TestConversion:
 8961:     def test_array_scalar_relational_operation(self):
 8962:         # All integer
 8963:         for dt1 in np.typecodes['AllInteger']:
 8964:             assert_(1 > np.array(0, dtype=dt1), f"type {dt1} failed")
 8965:             assert_(not 1 < np.array(0, dtype=dt1), f"type {dt1} failed")
 8966: 
 8967:             for dt2 in np.typecodes['AllInteger']:
 8968:                 assert_(np.array(1, dtype=dt1) > np.array(0, dtype=dt2),
 8969:                         f"type {dt1} and {dt2} failed")
 8970:                 assert_(not np.array(1, dtype=dt1) < np.array(0, dtype=dt2),
 8971:                         f"type {dt1} and {dt2} failed")
 8972: 
 8973:         # Unsigned integers
 8974:         for dt1 in 'BHILQP':
 8975:             assert_(-1 < np.array(1, dtype=dt1), f"type {dt1} failed")
 8976:             assert_(not -1 > np.array(1, dtype=dt1), f"type {dt1} failed")
 8977:             assert_(-1 != np.array(1, dtype=dt1), f"type {dt1} failed")
 8978: 
 8979:             # Unsigned vs signed
 8980:             for dt2 in 'bhilqp':
 8981:                 assert_(np.array(1, dtype=dt1) > np.array(-1, dtype=dt2),
 8982:                         f"type {dt1} and {dt2} failed")
 8983:                 assert_(not np.array(1, dtype=dt1) < np.array(-1, dtype=dt2),
 8984:                         f"type {dt1} and {dt2} failed")
 8985:                 assert_(np.array(1, dtype=dt1) != np.array(-1, dtype=dt2),
 8986:                         f"type {dt1} and {dt2} failed")
 8987: 
 8988:         # Signed integers and floats
 8989:         for dt1 in 'bhlqp' + np.typecodes['Float']:
 8990:             assert_(1 > np.array(-1, dtype=dt1), f"type {dt1} failed")
 8991:             assert_(not 1 < np.array(-1, dtype=dt1), f"type {dt1} failed")
 8992:             assert_(-1 == np.array(-1, dtype=dt1), f"type {dt1} failed")
 8993: 
 8994:             for dt2 in 'bhlqp' + np.typecodes['Float']:
 8995:                 assert_(np.array(1, dtype=dt1) > np.array(-1, dtype=dt2),
 8996:                         f"type {dt1} and {dt2} failed")
 8997:                 assert_(not np.array(1, dtype=dt1) < np.array(-1, dtype=dt2),
 8998:                         f"type {dt1} and {dt2} failed")
 8999:                 assert_(np.array(-1, dtype=dt1) == np.array(-1, dtype=dt2),
 9000:                         f"type {dt1} and {dt2} failed")
 9001: 
 9002:     def test_to_bool_scalar(self):
 9003:         assert_equal(bool(np.array([False])), False)
 9004:         assert_equal(bool(np.array([True])), True)
 9005:         assert_equal(bool(np.array([[42]])), True)
 9006: 
 9007:     def test_to_bool_scalar_not_convertible(self):
 9008: 
 9009:         class NotConvertible:
 9010:             def __bool__(self):
 9011:                 raise NotImplementedError
 9012: 
 9013:         assert_raises(NotImplementedError, bool, np.array(NotConvertible()))
 9014:         assert_raises(NotImplementedError, bool, np.array([NotConvertible()]))
 9015:         if IS_PYSTON:
 9016:             pytest.skip("Pyston disables recursion checking")
 9017:         if IS_WASM:
 9018:             pytest.skip("Pyodide/WASM has limited stack size")
 9019: 
 9020:         self_containing = np.array([None])
 9021:         self_containing[0] = self_containing
 9022: 
 9023:         Error = RecursionError
 9024: 
 9025:         assert_raises(Error, bool, self_containing)  # previously stack overflow
 9026:         self_containing[0] = None  # resolve circular reference
 9027: 
 9028:     def test_to_bool_scalar_size_errors(self):
 9029:         with pytest.raises(ValueError, match=".*one element is ambiguous"):
 9030:             bool(np.array([1, 2]))
 9031: 
 9032:         with pytest.raises(ValueError, match=".*empty array is ambiguous"):
 9033:             bool(np.empty((3, 0)))
 9034: 
 9035:         with pytest.raises(ValueError, match=".*empty array is ambiguous"):
 9036:             bool(np.empty((0,)))
 9037: 
 9038:     def test_to_int_scalar(self):
 9039:         # gh-9972 means that these aren't always the same
 9040:         int_funcs = (int, lambda x: x.__int__())
 9041:         for int_func in int_funcs:
 9042:             assert_equal(int_func(np.array(0)), 0)
 9043:             with assert_warns(DeprecationWarning):
 9044:                 assert_equal(int_func(np.array([1])), 1)
 9045:             with assert_warns(DeprecationWarning):
 9046:                 assert_equal(int_func(np.array([[42]])), 42)
 9047:             assert_raises(TypeError, int_func, np.array([1, 2]))
 9048: 
 9049:             # gh-9972
 9050:             assert_equal(4, int_func(np.array('4')))
 9051:             assert_equal(5, int_func(np.bytes_(b'5')))
 9052:             assert_equal(6, int_func(np.str_('6')))
 9053: 
 9054:             class NotConvertible:
 9055:                 def __int__(self):
 9056:                     raise NotImplementedError
 9057:             assert_raises(NotImplementedError,
 9058:                 int_func, np.array(NotConvertible()))
 9059:             with assert_warns(DeprecationWarning):
 9060:                 assert_raises(NotImplementedError,
 9061:                     int_func, np.array([NotConvertible()]))
 9062: 
 9063: 
 9064: class TestWhere:
 9065:     def test_basic(self):
 9066:         dts = [bool, np.int16, np.int32, np.int64, np.double, np.complex128,
 9067:                np.longdouble, np.clongdouble]
 9068:         for dt in dts:
 9069:             c = np.ones(53, dtype=bool)
 9070:             assert_equal(np.where( c, dt(0), dt(1)), dt(0))
 9071:             assert_equal(np.where(~c, dt(0), dt(1)), dt(1))
 9072:             assert_equal(np.where(True, dt(0), dt(1)), dt(0))
 9073:             assert_equal(np.where(False, dt(0), dt(1)), dt(1))
 9074:             d = np.ones_like(c).astype(dt)
 9075:             e = np.zeros_like(d)
 9076:             r = d.astype(dt)
 9077:             c[7] = False
 9078:             r[7] = e[7]
 9079:             assert_equal(np.where(c, e, e), e)
 9080:             assert_equal(np.where(c, d, e), r)
 9081:             assert_equal(np.where(c, d, e[0]), r)
 9082:             assert_equal(np.where(c, d[0], e), r)
 9083:             assert_equal(np.where(c[::2], d[::2], e[::2]), r[::2])
 9084:             assert_equal(np.where(c[1::2], d[1::2], e[1::2]), r[1::2])
 9085:             assert_equal(np.where(c[::3], d[::3], e[::3]), r[::3])
 9086:             assert_equal(np.where(c[1::3], d[1::3], e[1::3]), r[1::3])
 9087:             assert_equal(np.where(c[::-2], d[::-2], e[::-2]), r[::-2])
 9088:             assert_equal(np.where(c[::-3], d[::-3], e[::-3]), r[::-3])
 9089:             assert_equal(np.where(c[1::-3], d[1::-3], e[1::-3]), r[1::-3])
 9090: 
 9091:     @pytest.mark.skipif(IS_WASM, reason="no wasm fp exception support")
 9092:     def test_exotic(self):
 9093:         # object
 9094:         assert_array_equal(np.where(True, None, None), np.array(None))
 9095:         # zero sized
 9096:         m = np.array([], dtype=bool).reshape(0, 3)
 9097:         b = np.array([], dtype=np.float64).reshape(0, 3)
 9098:         assert_array_equal(np.where(m, 0, b), np.array([]).reshape(0, 3))
 9099: 
 9100:         # object cast
 9101:         d = np.array([-1.34, -0.16, -0.54, -0.31, -0.08, -0.95, 0.000, 0.313,
 9102:                       0.547, -0.18, 0.876, 0.236, 1.969, 0.310, 0.699, 1.013,
 9103:                       1.267, 0.229, -1.39, 0.487])
 9104:         nan = float('NaN')
 9105:         e = np.array(['5z', '0l', nan, 'Wz', nan, nan, 'Xq', 'cs', nan, nan,
 9106:                      'QN', nan, nan, 'Fd', nan, nan, 'kp', nan, '36', 'i1'],
 9107:                      dtype=object)
 9108:         m = np.array([0, 0, 1, 0, 1, 1, 0, 0, 1, 1,
 9109:                       0, 1, 1, 0, 1, 1, 0, 1, 0, 0], dtype=bool)
 9110: 
 9111:         r = e[:]
 9112:         r[np.where(m)] = d[np.where(m)]
 9113:         assert_array_equal(np.where(m, d, e), r)
 9114: 
 9115:         r = e[:]
 9116:         r[np.where(~m)] = d[np.where(~m)]
 9117:         assert_array_equal(np.where(m, e, d), r)
 9118: 
 9119:         assert_array_equal(np.where(m, e, e), e)
 9120: 
 9121:         # minimal dtype result with NaN scalar (e.g required by pandas)
 9122:         d = np.array([1., 2.], dtype=np.float32)
 9123:         e = float('NaN')
 9124:         assert_equal(np.where(True, d, e).dtype, np.float32)
 9125:         e = float('Infinity')
 9126:         assert_equal(np.where(True, d, e).dtype, np.float32)
 9127:         e = float('-Infinity')
 9128:         assert_equal(np.where(True, d, e).dtype, np.float32)
 9129:         # With NEP 50 adopted, the float will overflow here:
 9130:         e = 1e150
 9131:         with pytest.warns(RuntimeWarning, match="overflow"):
 9132:             res = np.where(True, d, e)
 9133:         assert res.dtype == np.float32
 9134: 
 9135:     def test_ndim(self):
 9136:         c = [True, False]
 9137:         a = np.zeros((2, 25))
 9138:         b = np.ones((2, 25))
 9139:         r = np.where(np.array(c)[:, np.newaxis], a, b)
 9140:         assert_array_equal(r[0], a[0])
 9141:         assert_array_equal(r[1], b[0])
 9142: 
 9143:         a = a.T
 9144:         b = b.T
 9145:         r = np.where(c, a, b)
 9146:         assert_array_equal(r[:, 0], a[:, 0])
 9147:         assert_array_equal(r[:, 1], b[:, 0])
 9148: 
 9149:     def test_dtype_mix(self):
 9150:         c = np.array([False, True, False, False, False, False, True, False,
 9151:                      False, False, True, False])
 9152:         a = np.uint32(1)
 9153:         b = np.array([5., 0., 3., 2., -1., -4., 0., -10., 10., 1., 0., 3.],
 9154:                       dtype=np.float64)
 9155:         r = np.array([5., 1., 3., 2., -1., -4., 1., -10., 10., 1., 1., 3.],
 9156:                      dtype=np.float64)
 9157:         assert_equal(np.where(c, a, b), r)
 9158: 
 9159:         a = a.astype(np.float32)
 9160:         b = b.astype(np.int64)
 9161:         assert_equal(np.where(c, a, b), r)
 9162: 
 9163:         # non bool mask
 9164:         c = c.astype(int)
 9165:         c[c != 0] = 34242324
 9166:         assert_equal(np.where(c, a, b), r)
 9167:         # invert
 9168:         tmpmask = c != 0
 9169:         c[c == 0] = 41247212
 9170:         c[tmpmask] = 0
 9171:         assert_equal(np.where(c, b, a), r)
 9172: 
 9173:     def test_foreign(self):
 9174:         c = np.array([False, True, False, False, False, False, True, False,
 9175:                      False, False, True, False])
 9176:         r = np.array([5., 1., 3., 2., -1., -4., 1., -10., 10., 1., 1., 3.],
 9177:                      dtype=np.float64)
 9178:         a = np.ones(1, dtype='>i4')
 9179:         b = np.array([5., 0., 3., 2., -1., -4., 0., -10., 10., 1., 0., 3.],
 9180:                      dtype=np.float64)
 9181:         assert_equal(np.where(c, a, b), r)
 9182: 
 9183:         b = b.astype('>f8')
 9184:         assert_equal(np.where(c, a, b), r)
 9185: 
 9186:         a = a.astype('<i4')
 9187:         assert_equal(np.where(c, a, b), r)
 9188: 
 9189:         c = c.astype('>i4')
 9190:         assert_equal(np.where(c, a, b), r)
 9191: 
 9192:     def test_error(self):
 9193:         c = [True, True]
 9194:         a = np.ones((4, 5))
 9195:         b = np.ones((5, 5))
 9196:         assert_raises(ValueError, np.where, c, a, a)
 9197:         assert_raises(ValueError, np.where, c[0], a, b)
 9198: 
 9199:     def test_string(self):
 9200:         # gh-4778 check strings are properly filled with nulls
 9201:         a = np.array("abc")
 9202:         b = np.array("x" * 753)
 9203:         assert_equal(np.where(True, a, b), "abc")
 9204:         assert_equal(np.where(False, b, a), "abc")
 9205: 
 9206:         # check native datatype sized strings
 9207:         a = np.array("abcd")
 9208:         b = np.array("x" * 8)
 9209:         assert_equal(np.where(True, a, b), "abcd")
 9210:         assert_equal(np.where(False, b, a), "abcd")
 9211: 
 9212:     def test_empty_result(self):
 9213:         # pass empty where result through an assignment which reads the data of
 9214:         # empty arrays, error detectable with valgrind, see gh-8922
 9215:         x = np.zeros((1, 1))
 9216:         ibad = np.vstack(np.where(x == 99.))
 9217:         assert_array_equal(ibad,
 9218:                            np.atleast_2d(np.array([[], []], dtype=np.intp)))
 9219: 
 9220:     def test_largedim(self):
 9221:         # invalid read regression gh-9304
 9222:         shape = [10, 2, 3, 4, 5, 6]
 9223:         np.random.seed(2)
 9224:         array = np.random.rand(*shape)
 9225: 
 9226:         for i in range(10):
 9227:             benchmark = array.nonzero()
 9228:             result = array.nonzero()
 9229:             assert_array_equal(benchmark, result)
 9230: 
 9231:     def test_kwargs(self):
 9232:         a = np.zeros(1)
 9233:         with assert_raises(TypeError):
 9234:             np.where(a, x=a, y=a)
 9235: 
 9236: 
 9237: if not IS_PYPY:
 9238:     # sys.getsizeof() is not valid on PyPy
 9239:     class TestSizeOf:
 9240: 
 9241:         def test_empty_array(self):
 9242:             x = np.array([])
 9243:             assert_(sys.getsizeof(x) > 0)
 9244: 
 9245:         def check_array(self, dtype):
 9246:             elem_size = dtype(0).itemsize
 9247: 
 9248:             for length in [10, 50, 100, 500]:
 9249:                 x = np.arange(length, dtype=dtype)
 9250:                 assert_(sys.getsizeof(x) > length * elem_size)
 9251: 
 9252:         def test_array_int32(self):
 9253:             self.check_array(np.int32)
 9254: 
 9255:         def test_array_int64(self):
 9256:             self.check_array(np.int64)
 9257: 
 9258:         def test_array_float32(self):
 9259:             self.check_array(np.float32)
 9260: 
 9261:         def test_array_float64(self):
 9262:             self.check_array(np.float64)
 9263: 
 9264:         def test_view(self):
 9265:             d = np.ones(100)
 9266:             assert_(sys.getsizeof(d[...]) < sys.getsizeof(d))
 9267: 
 9268:         def test_reshape(self):
 9269:             d = np.ones(100)
 9270:             assert_(sys.getsizeof(d) < sys.getsizeof(d.reshape(100, 1, 1).copy()))
 9271: 
 9272:         @_no_tracing
 9273:         def test_resize(self):
 9274:             d = np.ones(100)
 9275:             old = sys.getsizeof(d)
 9276:             d.resize(50)
 9277:             assert_(old > sys.getsizeof(d))
 9278:             d.resize(150)
 9279:             assert_(old < sys.getsizeof(d))
 9280: 
 9281:         @pytest.mark.parametrize("dtype", ["u4,f4", "u4,O"])
 9282:         def test_resize_structured(self, dtype):
 9283:             a = np.array([(0, 0.0) for i in range(5)], dtype=dtype)
 9284:             a.resize(1000)
 9285:             assert_array_equal(a, np.zeros(1000, dtype=dtype))
 9286: 
 9287:         def test_error(self):
 9288:             d = np.ones(100)
 9289:             assert_raises(TypeError, d.__sizeof__, "a")
 9290: 
 9291: 
 9292: class TestHashing:
 9293: 
 9294:     def test_arrays_not_hashable(self):
 9295:         x = np.ones(3)
 9296:         assert_raises(TypeError, hash, x)
 9297: 
 9298:     def test_collections_hashable(self):
 9299:         x = np.array([])
 9300:         assert_(not isinstance(x, collections.abc.Hashable))
 9301: 
 9302: 
 9303: class TestArrayPriority:
 9304:     # This will go away when __array_priority__ is settled, meanwhile
 9305:     # it serves to check unintended changes.
 9306:     op = operator
 9307:     binary_ops = [
 9308:         op.pow, op.add, op.sub, op.mul, op.floordiv, op.truediv, op.mod,
 9309:         op.and_, op.or_, op.xor, op.lshift, op.rshift, op.mod, op.gt,
 9310:         op.ge, op.lt, op.le, op.ne, op.eq
 9311:         ]
 9312: 
 9313:     class Foo(np.ndarray):
 9314:         __array_priority__ = 100.
 9315: 
 9316:         def __new__(cls, *args, **kwargs):
 9317:             return np.array(*args, **kwargs).view(cls)
 9318: 
 9319:     class Bar(np.ndarray):
 9320:         __array_priority__ = 101.
 9321: 
 9322:         def __new__(cls, *args, **kwargs):
 9323:             return np.array(*args, **kwargs).view(cls)
 9324: 
 9325:     class Other:
 9326:         __array_priority__ = 1000.
 9327: 
 9328:         def _all(self, other):
 9329:             return self.__class__()
 9330: 
 9331:         __add__ = __radd__ = _all
 9332:         __sub__ = __rsub__ = _all
 9333:         __mul__ = __rmul__ = _all
 9334:         __pow__ = __rpow__ = _all
 9335:         __mod__ = __rmod__ = _all
 9336:         __truediv__ = __rtruediv__ = _all
 9337:         __floordiv__ = __rfloordiv__ = _all
 9338:         __and__ = __rand__ = _all
 9339:         __xor__ = __rxor__ = _all
 9340:         __or__ = __ror__ = _all
 9341:         __lshift__ = __rlshift__ = _all
 9342:         __rshift__ = __rrshift__ = _all
 9343:         __eq__ = _all
 9344:         __ne__ = _all
 9345:         __gt__ = _all
 9346:         __ge__ = _all
 9347:         __lt__ = _all
 9348:         __le__ = _all
 9349: 
 9350:     def test_ndarray_subclass(self):
 9351:         a = np.array([1, 2])
 9352:         b = self.Bar([1, 2])
 9353:         for f in self.binary_ops:
 9354:             msg = repr(f)
 9355:             assert_(isinstance(f(a, b), self.Bar), msg)
 9356:             assert_(isinstance(f(b, a), self.Bar), msg)
 9357: 
 9358:     def test_ndarray_other(self):
 9359:         a = np.array([1, 2])
 9360:         b = self.Other()
 9361:         for f in self.binary_ops:
 9362:             msg = repr(f)
 9363:             assert_(isinstance(f(a, b), self.Other), msg)
 9364:             assert_(isinstance(f(b, a), self.Other), msg)
 9365: 
 9366:     def test_subclass_subclass(self):
 9367:         a = self.Foo([1, 2])
 9368:         b = self.Bar([1, 2])
 9369:         for f in self.binary_ops:
 9370:             msg = repr(f)
 9371:             assert_(isinstance(f(a, b), self.Bar), msg)
 9372:             assert_(isinstance(f(b, a), self.Bar), msg)
 9373: 
 9374:     def test_subclass_other(self):
 9375:         a = self.Foo([1, 2])
 9376:         b = self.Other()
 9377:         for f in self.binary_ops:
 9378:             msg = repr(f)
 9379:             assert_(isinstance(f(a, b), self.Other), msg)
 9380:             assert_(isinstance(f(b, a), self.Other), msg)
 9381: 
 9382: 
 9383: class TestBytestringArrayNonzero:
 9384: 
 9385:     def test_empty_bstring_array_is_falsey(self):
 9386:         assert_(not np.array([''], dtype=str))
 9387: 
 9388:     def test_whitespace_bstring_array_is_truthy(self):
 9389:         a = np.array(['spam'], dtype=str)
 9390:         a[0] = '  \0\0'
 9391:         assert_(a)
 9392: 
 9393:     def test_all_null_bstring_array_is_falsey(self):
 9394:         a = np.array(['spam'], dtype=str)
 9395:         a[0] = '\0\0\0\0'
 9396:         assert_(not a)
 9397: 
 9398:     def test_null_inside_bstring_array_is_truthy(self):
 9399:         a = np.array(['spam'], dtype=str)
 9400:         a[0] = ' \0 \0'
 9401:         assert_(a)
 9402: 
 9403: 
 9404: class TestUnicodeEncoding:
 9405:     """
 9406:     Tests for encoding related bugs, such as UCS2 vs UCS4, round-tripping
 9407:     issues, etc
 9408:     """
 9409:     def test_round_trip(self):
 9410:         """ Tests that GETITEM, SETITEM, and PyArray_Scalar roundtrip """
 9411:         # gh-15363
 9412:         arr = np.zeros(shape=(), dtype="U1")
 9413:         for i in range(1, sys.maxunicode + 1):
 9414:             expected = chr(i)
 9415:             arr[()] = expected
 9416:             assert arr[()] == expected
 9417:             assert arr.item() == expected
 9418: 
 9419:     def test_assign_scalar(self):
 9420:         # gh-3258
 9421:         l = np.array(['aa', 'bb'])
 9422:         l[:] = np.str_('cc')
 9423:         assert_equal(l, ['cc', 'cc'])
 9424: 
 9425:     def test_fill_scalar(self):
 9426:         # gh-7227
 9427:         l = np.array(['aa', 'bb'])
 9428:         l.fill(np.str_('cc'))
 9429:         assert_equal(l, ['cc', 'cc'])
 9430: 
 9431: 
 9432: class TestUnicodeArrayNonzero:
 9433: 
 9434:     def test_empty_ustring_array_is_falsey(self):
 9435:         assert_(not np.array([''], dtype=np.str_))
 9436: 
 9437:     def test_whitespace_ustring_array_is_truthy(self):
 9438:         a = np.array(['eggs'], dtype=np.str_)
 9439:         a[0] = '  \0\0'
 9440:         assert_(a)
 9441: 
 9442:     def test_all_null_ustring_array_is_falsey(self):
 9443:         a = np.array(['eggs'], dtype=np.str_)
 9444:         a[0] = '\0\0\0\0'
 9445:         assert_(not a)
 9446: 
 9447:     def test_null_inside_ustring_array_is_truthy(self):
 9448:         a = np.array(['eggs'], dtype=np.str_)
 9449:         a[0] = ' \0 \0'
 9450:         assert_(a)
 9451: 
 9452: 
 9453: class TestFormat:
 9454: 
 9455:     def test_0d(self):
 9456:         a = np.array(np.pi)
 9457:         assert_equal(f'{a:0.3g}', '3.14')
 9458:         assert_equal(f'{a[()]:0.3g}', '3.14')
 9459: 
 9460:     def test_1d_no_format(self):
 9461:         a = np.array([np.pi])
 9462:         assert_equal(f'{a}', str(a))
 9463: 
 9464:     def test_1d_format(self):
 9465:         # until gh-5543, ensure that the behaviour matches what it used to be
 9466:         a = np.array([np.pi])
 9467:         assert_raises(TypeError, '{:30}'.format, a)
 9468: 
 9469: 
 9470: from numpy.testing import IS_PYPY
 9471: 
 9472: 
 9473: class TestCTypes:
 9474: 
 9475:     def test_ctypes_is_available(self):
 9476:         test_arr = np.array([[1, 2, 3], [4, 5, 6]])
 9477: 
 9478:         assert_equal(ctypes, test_arr.ctypes._ctypes)
 9479:         assert_equal(tuple(test_arr.ctypes.shape), (2, 3))
 9480: 
 9481:     def test_ctypes_is_not_available(self):
 9482:         from numpy._core import _internal
 9483:         _internal.ctypes = None
 9484:         try:
 9485:             test_arr = np.array([[1, 2, 3], [4, 5, 6]])
 9486: 
 9487:             assert_(isinstance(test_arr.ctypes._ctypes,
 9488:                                _internal._missing_ctypes))
 9489:             assert_equal(tuple(test_arr.ctypes.shape), (2, 3))
 9490:         finally:
 9491:             _internal.ctypes = ctypes
 9492: 
 9493:     def _make_readonly(x):
 9494:         x.flags.writeable = False
 9495:         return x
 9496: 
 9497:     @pytest.mark.parametrize('arr', [
 9498:         np.array([1, 2, 3]),
 9499:         np.array([['one', 'two'], ['three', 'four']]),
 9500:         np.array((1, 2), dtype='i4,i4'),
 9501:         np.zeros((2,), dtype=np.dtype({
 9502:                 "formats": ['<i4', '<i4'],
 9503:                 "names": ['a', 'b'],
 9504:                 "offsets": [0, 2],
 9505:                 "itemsize": 6
 9506:             })
 9507:         ),
 9508:         np.array([None], dtype=object),
 9509:         np.array([]),
 9510:         np.empty((0, 0)),
 9511:         _make_readonly(np.array([1, 2, 3])),
 9512:     ], ids=[
 9513:         '1d',
 9514:         '2d',
 9515:         'structured',
 9516:         'overlapping',
 9517:         'object',
 9518:         'empty',
 9519:         'empty-2d',
 9520:         'readonly'
 9521:     ])
 9522:     def test_ctypes_data_as_holds_reference(self, arr):
 9523:         # gh-9647
 9524:         # create a copy to ensure that pytest does not mess with the refcounts
 9525:         arr = arr.copy()
 9526: 
 9527:         arr_ref = weakref.ref(arr)
 9528: 
 9529:         ctypes_ptr = arr.ctypes.data_as(ctypes.c_void_p)
 9530: 
 9531:         # `ctypes_ptr` should hold onto `arr`
 9532:         del arr
 9533:         break_cycles()
 9534:         assert_(arr_ref() is not None, "ctypes pointer did not hold onto a reference")
 9535: 
 9536:         # but when the `ctypes_ptr` object dies, so should `arr`
 9537:         del ctypes_ptr
 9538:         if IS_PYPY:
 9539:             # Pypy does not recycle arr objects immediately. Trigger gc to
 9540:             # release arr. Cpython uses refcounts. An explicit call to gc
 9541:             # should not be needed here.
 9542:             break_cycles()
 9543:         assert_(arr_ref() is None, "unknowable whether ctypes pointer holds a reference")
 9544: 
 9545:     def test_ctypes_as_parameter_holds_reference(self):
 9546:         arr = np.array([None]).copy()
 9547: 
 9548:         arr_ref = weakref.ref(arr)
 9549: 
 9550:         ctypes_ptr = arr.ctypes._as_parameter_
 9551: 
 9552:         # `ctypes_ptr` should hold onto `arr`
 9553:         del arr
 9554:         break_cycles()
 9555:         assert_(arr_ref() is not None, "ctypes pointer did not hold onto a reference")
 9556: 
 9557:         # but when the `ctypes_ptr` object dies, so should `arr`
 9558:         del ctypes_ptr
 9559:         if IS_PYPY:
 9560:             break_cycles()
 9561:         assert_(arr_ref() is None, "unknowable whether ctypes pointer holds a reference")
 9562: 
 9563: 
 9564: class TestWritebackIfCopy:
 9565:     # all these tests use the WRITEBACKIFCOPY mechanism
 9566:     def test_argmax_with_out(self):
 9567:         mat = np.eye(5)
 9568:         out = np.empty(5, dtype='i2')
 9569:         res = np.argmax(mat, 0, out=out)
 9570:         assert_equal(res, range(5))
 9571: 
 9572:     def test_argmin_with_out(self):
 9573:         mat = -np.eye(5)
 9574:         out = np.empty(5, dtype='i2')
 9575:         res = np.argmin(mat, 0, out=out)
 9576:         assert_equal(res, range(5))
 9577: 
 9578:     def test_insert_noncontiguous(self):
 9579:         a = np.arange(6).reshape(2, 3).T  # force non-c-contiguous
 9580:         # uses arr_insert
 9581:         np.place(a, a > 2, [44, 55])
 9582:         assert_equal(a, np.array([[0, 44], [1, 55], [2, 44]]))
 9583:         # hit one of the failing paths
 9584:         assert_raises(ValueError, np.place, a, a > 20, [])
 9585: 
 9586:     def test_put_noncontiguous(self):
 9587:         a = np.arange(6).reshape(2, 3).T  # force non-c-contiguous
 9588:         np.put(a, [0, 2], [44, 55])
 9589:         assert_equal(a, np.array([[44, 3], [55, 4], [2, 5]]))
 9590: 
 9591:     def test_putmask_noncontiguous(self):
 9592:         a = np.arange(6).reshape(2, 3).T  # force non-c-contiguous
 9593:         # uses arr_putmask
 9594:         np.putmask(a, a > 2, a**2)
 9595:         assert_equal(a, np.array([[0, 9], [1, 16], [2, 25]]))
 9596: 
 9597:     def test_take_mode_raise(self):
 9598:         a = np.arange(6, dtype='int')
 9599:         out = np.empty(2, dtype='int')
 9600:         np.take(a, [0, 2], out=out, mode='raise')
 9601:         assert_equal(out, np.array([0, 2]))
 9602: 
 9603:     def test_choose_mod_raise(self):
 9604:         a = np.array([[1, 0, 1], [0, 1, 0], [1, 0, 1]])
 9605:         out = np.empty((3, 3), dtype='int')
 9606:         choices = [-10, 10]
 9607:         np.choose(a, choices, out=out, mode='raise')
 9608:         assert_equal(out, np.array([[ 10, -10,  10],
 9609:                                     [-10,  10, -10],
 9610:                                     [ 10, -10,  10]]))
 9611: 
 9612:     def test_flatiter__array__(self):
 9613:         a = np.arange(9).reshape(3, 3)
 9614:         b = a.T.flat
 9615:         c = b.__array__()
 9616:         # triggers the WRITEBACKIFCOPY resolution, assuming refcount semantics
 9617:         del c
 9618: 
 9619:     def test_dot_out(self):
 9620:         # if HAVE_CBLAS, will use WRITEBACKIFCOPY
 9621:         a = np.arange(9, dtype=float).reshape(3, 3)
 9622:         b = np.dot(a, a, out=a)
 9623:         assert_equal(b, np.array([[15, 18, 21], [42, 54, 66], [69, 90, 111]]))
 9624: 
 9625:     def test_view_assign(self):
 9626:         from numpy._core._multiarray_tests import (
 9627:             npy_create_writebackifcopy,
 9628:             npy_resolve,
 9629:         )
 9630: 
 9631:         arr = np.arange(9).reshape(3, 3).T
 9632:         arr_wb = npy_create_writebackifcopy(arr)
 9633:         assert_(arr_wb.flags.writebackifcopy)
 9634:         assert_(arr_wb.base is arr)
 9635:         arr_wb[...] = -100
 9636:         npy_resolve(arr_wb)
 9637:         # arr changes after resolve, even though we assigned to arr_wb
 9638:         assert_equal(arr, -100)
 9639:         # after resolve, the two arrays no longer reference each other
 9640:         assert_(arr_wb.ctypes.data != 0)
 9641:         assert_equal(arr_wb.base, None)
 9642:         # assigning to arr_wb does not get transferred to arr
 9643:         arr_wb[...] = 100
 9644:         assert_equal(arr, -100)
 9645: 
 9646:     @pytest.mark.leaks_references(
 9647:             reason="increments self in dealloc; ignore since deprecated path.")
 9648:     def test_dealloc_warning(self):
 9649:         with suppress_warnings() as sup:
 9650:             sup.record(RuntimeWarning)
 9651:             arr = np.arange(9).reshape(3, 3)
 9652:             v = arr.T
 9653:             _multiarray_tests.npy_abuse_writebackifcopy(v)
 9654:             assert len(sup.log) == 1
 9655: 
 9656:     def test_view_discard_refcount(self):
 9657:         from numpy._core._multiarray_tests import (
 9658:             npy_create_writebackifcopy,
 9659:             npy_discard,
 9660:         )
 9661: 
 9662:         arr = np.arange(9).reshape(3, 3).T
 9663:         orig = arr.copy()
 9664:         if HAS_REFCOUNT:
 9665:             arr_cnt = sys.getrefcount(arr)
 9666:         arr_wb = npy_create_writebackifcopy(arr)
 9667:         assert_(arr_wb.flags.writebackifcopy)
 9668:         assert_(arr_wb.base is arr)
 9669:         arr_wb[...] = -100
 9670:         npy_discard(arr_wb)
 9671:         # arr remains unchanged after discard
 9672:         assert_equal(arr, orig)
 9673:         # after discard, the two arrays no longer reference each other
 9674:         assert_(arr_wb.ctypes.data != 0)
 9675:         assert_equal(arr_wb.base, None)
 9676:         if HAS_REFCOUNT:
 9677:             assert_equal(arr_cnt, sys.getrefcount(arr))
 9678:         # assigning to arr_wb does not get transferred to arr
 9679:         arr_wb[...] = 100
 9680:         assert_equal(arr, orig)
 9681: 
 9682: 
 9683: class TestArange:
 9684:     def test_infinite(self):
 9685:         assert_raises_regex(
 9686:             ValueError, "size exceeded",
 9687:             np.arange, 0, np.inf
 9688:         )
 9689: 
 9690:     def test_nan_step(self):
 9691:         assert_raises_regex(
 9692:             ValueError, "cannot compute length",
 9693:             np.arange, 0, 1, np.nan
 9694:         )
 9695: 
 9696:     def test_zero_step(self):
 9697:         assert_raises(ZeroDivisionError, np.arange, 0, 10, 0)
 9698:         assert_raises(ZeroDivisionError, np.arange, 0.0, 10.0, 0.0)
 9699: 
 9700:         # empty range
 9701:         assert_raises(ZeroDivisionError, np.arange, 0, 0, 0)
 9702:         assert_raises(ZeroDivisionError, np.arange, 0.0, 0.0, 0.0)
 9703: 
 9704:     def test_require_range(self):
 9705:         assert_raises(TypeError, np.arange)
 9706:         assert_raises(TypeError, np.arange, step=3)
 9707:         assert_raises(TypeError, np.arange, dtype='int64')
 9708:         assert_raises(TypeError, np.arange, start=4)
 9709: 
 9710:     def test_start_stop_kwarg(self):
 9711:         keyword_stop = np.arange(stop=3)
 9712:         keyword_zerotostop = np.arange(0, stop=3)
 9713:         keyword_start_stop = np.arange(start=3, stop=9)
 9714: 
 9715:         assert len(keyword_stop) == 3
 9716:         assert len(keyword_zerotostop) == 3
 9717:         assert len(keyword_start_stop) == 6
 9718:         assert_array_equal(keyword_stop, keyword_zerotostop)
 9719: 
 9720:     def test_arange_booleans(self):
 9721:         # Arange makes some sense for booleans and works up to length 2.
 9722:         # But it is weird since `arange(2, 4, dtype=bool)` works.
 9723:         # Arguably, much or all of this could be deprecated/removed.
 9724:         res = np.arange(False, dtype=bool)
 9725:         assert_array_equal(res, np.array([], dtype="bool"))
 9726: 
 9727:         res = np.arange(True, dtype="bool")
 9728:         assert_array_equal(res, [False])
 9729: 
 9730:         res = np.arange(2, dtype="bool")
 9731:         assert_array_equal(res, [False, True])
 9732: 
 9733:         # This case is especially weird, but drops out without special case:
 9734:         res = np.arange(6, 8, dtype="bool")
 9735:         assert_array_equal(res, [True, True])
 9736: 
 9737:         with pytest.raises(TypeError):
 9738:             np.arange(3, dtype="bool")
 9739: 
 9740:     @pytest.mark.parametrize("dtype", ["S3", "U", "5i"])
 9741:     def test_rejects_bad_dtypes(self, dtype):
 9742:         dtype = np.dtype(dtype)
 9743:         DType_name = re.escape(str(type(dtype)))
 9744:         with pytest.raises(TypeError,
 9745:                 match=rf"arange\(\) not supported for inputs .* {DType_name}"):
 9746:             np.arange(2, dtype=dtype)
 9747: 
 9748:     def test_rejects_strings(self):
 9749:         # Explicitly test error for strings which may call "b" - "a":
 9750:         DType_name = re.escape(str(type(np.array("a").dtype)))
 9751:         with pytest.raises(TypeError,
 9752:                 match=rf"arange\(\) not supported for inputs .* {DType_name}"):
 9753:             np.arange("a", "b")
 9754: 
 9755:     def test_byteswapped(self):
 9756:         res_be = np.arange(1, 1000, dtype=">i4")
 9757:         res_le = np.arange(1, 1000, dtype="<i4")
 9758:         assert res_be.dtype == ">i4"
 9759:         assert res_le.dtype == "<i4"
 9760:         assert_array_equal(res_le, res_be)
 9761: 
 9762:     @pytest.mark.parametrize("which", [0, 1, 2])
 9763:     def test_error_paths_and_promotion(self, which):
 9764:         args = [0, 1, 2]  # start, stop, and step
 9765:         args[which] = np.float64(2.)  # should ensure float64 output
 9766: 
 9767:         assert np.arange(*args).dtype == np.float64
 9768: 
 9769:         # Cover stranger error path, test only to achieve code coverage!
 9770:         args[which] = [None, []]
 9771:         with pytest.raises(ValueError):
 9772:             # Fails discovering start dtype
 9773:             np.arange(*args)
 9774: 
 9775:     def test_dtype_attribute_ignored(self):
 9776:         # Until 2.3 this would raise a DeprecationWarning
 9777:         class dt:
 9778:             dtype = "f8"
 9779: 
 9780:         class vdt(np.void):
 9781:             dtype = "f,f"
 9782: 
 9783:         assert_raises(ValueError, np.dtype, dt)
 9784:         assert_raises(ValueError, np.dtype, dt())
 9785:         assert_raises(ValueError, np.dtype, vdt)
 9786:         assert_raises(ValueError, np.dtype, vdt(1))
 9787: 
 9788: 
 9789: class TestDTypeCoercionForbidden:
 9790:     forbidden_types = [
 9791:         # The builtin scalar super types:
 9792:         np.generic, np.flexible, np.number,
 9793:         np.inexact, np.floating, np.complexfloating,
 9794:         np.integer, np.unsignedinteger, np.signedinteger,
 9795:         # character is a deprecated S1 special case:
 9796:         np.character,
 9797:     ]
 9798: 
 9799:     def test_dtype_coercion(self):
 9800:         for scalar_type in self.forbidden_types:
 9801:             assert_raises(TypeError, np.dtype, args=(scalar_type,))
 9802: 
 9803:     def test_array_construction(self):
 9804:         for scalar_type in self.forbidden_types:
 9805:             assert_raises(TypeError, np.array, args=([], scalar_type,))
 9806: 
 9807:     def test_not_deprecated(self):
 9808:         # All specific types work
 9809:         for group in np._core.sctypes.values():
 9810:             for scalar_type in group:
 9811:                 np.dtype(scalar_type)
 9812: 
 9813:         for scalar_type in [type, dict, list, tuple]:
 9814:             # Typical python types are coerced to object currently:
 9815:             np.dtype(scalar_type)
 9816: 
 9817: 
 9818: class TestDateTimeCreationTuple:
 9819:     @pytest.mark.parametrize("cls", [np.datetime64, np.timedelta64])
 9820:     def test_dt_tuple(self, cls):
 9821:         # two valid uses - (unit, num) and (unit, num, den, None)
 9822:         cls(1, ('ms', 2))
 9823:         cls(1, ('ms', 2, 1, None))
 9824: 
 9825:         # trying to use the event argument, removed in 1.7.0
 9826:         # it used to be a uint8
 9827:         assert_raises(TypeError, cls, args=(1, ('ms', 2, 'event')))
 9828:         assert_raises(TypeError, cls, args=(1, ('ms', 2, 63)))
 9829:         assert_raises(TypeError, cls, args=(1, ('ms', 2, 1, 'event')))
 9830:         assert_raises(TypeError, cls, args=(1, ('ms', 2, 1, 63)))
 9831: 
 9832: 
 9833: class TestArrayFinalize:
 9834:     """ Tests __array_finalize__ """
 9835: 
 9836:     def test_receives_base(self):
 9837:         # gh-11237
 9838:         class SavesBase(np.ndarray):
 9839:             def __array_finalize__(self, obj):
 9840:                 self.saved_base = self.base
 9841: 
 9842:         a = np.array(1).view(SavesBase)
 9843:         assert_(a.saved_base is a.base)
 9844: 
 9845:     def test_bad_finalize1(self):
 9846:         class BadAttributeArray(np.ndarray):
 9847:             @property
 9848:             def __array_finalize__(self):
 9849:                 raise RuntimeError("boohoo!")
 9850: 
 9851:         with pytest.raises(TypeError, match="not callable"):
 9852:             np.arange(10).view(BadAttributeArray)
 9853: 
 9854:     def test_bad_finalize2(self):
 9855:         class BadAttributeArray(np.ndarray):
 9856:             def __array_finalize__(self):
 9857:                 raise RuntimeError("boohoo!")
 9858: 
 9859:         with pytest.raises(TypeError, match="takes 1 positional"):
 9860:             np.arange(10).view(BadAttributeArray)
 9861: 
 9862:     def test_bad_finalize3(self):
 9863:         class BadAttributeArray(np.ndarray):
 9864:             def __array_finalize__(self, obj):
 9865:                 raise RuntimeError("boohoo!")
 9866: 
 9867:         with pytest.raises(RuntimeError, match="boohoo!"):
 9868:             np.arange(10).view(BadAttributeArray)
 9869: 
 9870:     def test_lifetime_on_error(self):
 9871:         # gh-11237
 9872:         class RaisesInFinalize(np.ndarray):
 9873:             def __array_finalize__(self, obj):
 9874:                 # crash, but keep this object alive
 9875:                 raise Exception(self)
 9876: 
 9877:         # a plain object can't be weakref'd
 9878:         class Dummy:
 9879:             pass
 9880: 
 9881:         # get a weak reference to an object within an array
 9882:         obj_arr = np.array(Dummy())
 9883:         obj_ref = weakref.ref(obj_arr[()])
 9884: 
 9885:         # get an array that crashed in __array_finalize__
 9886:         with assert_raises(Exception) as e:
 9887:             obj_arr.view(RaisesInFinalize)
 9888: 
 9889:         obj_subarray = e.exception.args[0]
 9890:         del e
 9891:         assert_(isinstance(obj_subarray, RaisesInFinalize))
 9892: 
 9893:         # reference should still be held by obj_arr
 9894:         break_cycles()
 9895:         assert_(obj_ref() is not None, "object should not already be dead")
 9896: 
 9897:         del obj_arr
 9898:         break_cycles()
 9899:         assert_(obj_ref() is not None, "obj_arr should not hold the last reference")
 9900: 
 9901:         del obj_subarray
 9902:         break_cycles()
 9903:         assert_(obj_ref() is None, "no references should remain")
 9904: 
 9905:     def test_can_use_super(self):
 9906:         class SuperFinalize(np.ndarray):
 9907:             def __array_finalize__(self, obj):
 9908:                 self.saved_result = super().__array_finalize__(obj)
 9909: 
 9910:         a = np.array(1).view(SuperFinalize)
 9911:         assert_(a.saved_result is None)
 9912: 
 9913: 
 9914: def test_orderconverter_with_nonASCII_unicode_ordering():
 9915:     # gh-7475
 9916:     a = np.arange(5)
 9917:     assert_raises(ValueError, a.flatten, order='\xe2')
 9918: 
 9919: 
 9920: def test_equal_override():
 9921:     # gh-9153: ndarray.__eq__ uses special logic for structured arrays, which
 9922:     # did not respect overrides with __array_priority__ or __array_ufunc__.
 9923:     # The PR fixed this for __array_priority__ and __array_ufunc__ = None.
 9924:     class MyAlwaysEqual:
 9925:         def __eq__(self, other):
 9926:             return "eq"
 9927: 
 9928:         def __ne__(self, other):
 9929:             return "ne"
 9930: 
 9931:     class MyAlwaysEqualOld(MyAlwaysEqual):
 9932:         __array_priority__ = 10000
 9933: 
 9934:     class MyAlwaysEqualNew(MyAlwaysEqual):
 9935:         __array_ufunc__ = None
 9936: 
 9937:     array = np.array([(0, 1), (2, 3)], dtype='i4,i4')
 9938:     for my_always_equal_cls in MyAlwaysEqualOld, MyAlwaysEqualNew:
 9939:         my_always_equal = my_always_equal_cls()
 9940:         assert_equal(my_always_equal == array, 'eq')
 9941:         assert_equal(array == my_always_equal, 'eq')
 9942:         assert_equal(my_always_equal != array, 'ne')
 9943:         assert_equal(array != my_always_equal, 'ne')
 9944: 
 9945: 
 9946: @pytest.mark.parametrize("op", [operator.eq, operator.ne])
 9947: @pytest.mark.parametrize(["dt1", "dt2"], [
 9948:         ([("f", "i")], [("f", "i")]),  # structured comparison (successful)
 9949:         ("M8", "d"),  # impossible comparison: result is all True or False
 9950:         ("d", "d"),  # valid comparison
 9951:         ])
 9952: def test_equal_subclass_no_override(op, dt1, dt2):
 9953:     # Test how the three different possible code-paths deal with subclasses
 9954: 
 9955:     class MyArr(np.ndarray):
 9956:         called_wrap = 0
 9957: 
 9958:         def __array_wrap__(self, new, context=None, return_scalar=False):
 9959:             type(self).called_wrap += 1
 9960:             return super().__array_wrap__(new, context, return_scalar)
 9961: 
 9962:     numpy_arr = np.zeros(5, dtype=dt1)
 9963:     my_arr = np.zeros(5, dtype=dt2).view(MyArr)
 9964: 
 9965:     assert type(op(numpy_arr, my_arr)) is MyArr
 9966:     assert type(op(my_arr, numpy_arr)) is MyArr
 9967:     # We expect 2 calls (more if there were more fields):
 9968:     assert MyArr.called_wrap == 2
 9969: 
 9970: 
 9971: @pytest.mark.parametrize(["dt1", "dt2"], [
 9972:         ("M8[ns]", "d"),
 9973:         ("M8[s]", "l"),
 9974:         ("m8[ns]", "d"),
 9975:         # Missing: ("m8[ns]", "l") as timedelta currently promotes ints
 9976:         ("M8[s]", "m8[s]"),
 9977:         ("S5", "U5"),
 9978:         # Structured/void dtypes have explicit paths not tested here.
 9979: ])
 9980: def test_no_loop_gives_all_true_or_false(dt1, dt2):
 9981:     # Make sure they broadcast to test result shape, use random values, since
 9982:     # the actual value should be ignored
 9983:     arr1 = np.random.randint(5, size=100).astype(dt1)
 9984:     arr2 = np.random.randint(5, size=99)[:, np.newaxis].astype(dt2)
 9985: 
 9986:     res = arr1 == arr2
 9987:     assert res.shape == (99, 100)
 9988:     assert res.dtype == bool
 9989:     assert not res.any()
 9990: 
 9991:     res = arr1 != arr2
 9992:     assert res.shape == (99, 100)
 9993:     assert res.dtype == bool
 9994:     assert res.all()
 9995: 
 9996:     # incompatible shapes raise though
 9997:     arr2 = np.random.randint(5, size=99).astype(dt2)
 9998:     with pytest.raises(ValueError):
 9999:         arr1 == arr2
10000: 
10001:     with pytest.raises(ValueError):
10002:         arr1 != arr2
10003: 
10004:     # Basic test with another operation:
10005:     with pytest.raises(np._core._exceptions._UFuncNoLoopError):
10006:         arr1 > arr2
10007: 
10008: 
10009: @pytest.mark.parametrize("op", [
10010:         operator.eq, operator.ne, operator.le, operator.lt, operator.ge,
10011:         operator.gt])
10012: def test_comparisons_forwards_error(op):
10013:     class NotArray:
10014:         def __array__(self, dtype=None, copy=None):
10015:             raise TypeError("run you fools")
10016: 
10017:     with pytest.raises(TypeError, match="run you fools"):
10018:         op(np.arange(2), NotArray())
10019: 
10020:     with pytest.raises(TypeError, match="run you fools"):
10021:         op(NotArray(), np.arange(2))
10022: 
10023: 
10024: def test_richcompare_scalar_boolean_singleton_return():
10025:     # These are currently guaranteed to be the boolean numpy singletons
10026:     assert (np.array(0) == "a") is np.bool_(False)
10027:     assert (np.array(0) != "a") is np.bool_(True)
10028:     assert (np.int16(0) == "a") is np.bool_(False)
10029:     assert (np.int16(0) != "a") is np.bool_(True)
10030: 
10031: 
10032: @pytest.mark.parametrize("op", [
10033:         operator.eq, operator.ne, operator.le, operator.lt, operator.ge,
10034:         operator.gt])
10035: def test_ragged_comparison_fails(op):
10036:     # This needs to convert the internal array to True/False, which fails:
10037:     a = np.array([1, np.array([1, 2, 3])], dtype=object)
10038:     b = np.array([1, np.array([1, 2, 3])], dtype=object)
10039: 
10040:     with pytest.raises(ValueError, match="The truth value.*ambiguous"):
10041:         op(a, b)
10042: 
10043: 
10044: @pytest.mark.parametrize(
10045:     ["fun", "npfun"],
10046:     [
10047:         (_multiarray_tests.npy_cabs, np.absolute),
10048:         (_multiarray_tests.npy_carg, np.angle)
10049:     ]
10050: )
10051: @pytest.mark.parametrize("x", [1, np.inf, -np.inf, np.nan])
10052: @pytest.mark.parametrize("y", [1, np.inf, -np.inf, np.nan])
10053: @pytest.mark.parametrize("test_dtype", np.complexfloating.__subclasses__())
10054: def test_npymath_complex(fun, npfun, x, y, test_dtype):
10055:     # Smoketest npymath functions
10056:     z = test_dtype(complex(x, y))
10057:     with np.errstate(invalid='ignore'):
10058:         # Fallback implementations may emit a warning for +-inf (see gh-24876):
10059:         #     RuntimeWarning: invalid value encountered in absolute
10060:         got = fun(z)
10061:         expected = npfun(z)
10062:         assert_allclose(got, expected)
10063: 
10064: 
10065: def test_npymath_real():
10066:     # Smoketest npymath functions
10067:     from numpy._core._multiarray_tests import (
10068:         npy_cosh,
10069:         npy_log10,
10070:         npy_sinh,
10071:         npy_tan,
10072:         npy_tanh,
10073:     )
10074: 
10075:     funcs = {npy_log10: np.log10,
10076:              npy_cosh: np.cosh,
10077:              npy_sinh: np.sinh,
10078:              npy_tan: np.tan,
10079:              npy_tanh: np.tanh}
10080:     vals = (1, np.inf, -np.inf, np.nan)
10081:     types = (np.float32, np.float64, np.longdouble)
10082: 
10083:     with np.errstate(all='ignore'):
10084:         for fun, npfun in funcs.items():
10085:             for x, t in itertools.product(vals, types):
10086:                 z = t(x)
10087:                 got = fun(z)
10088:                 expected = npfun(z)
10089:                 assert_allclose(got, expected)
10090: 
10091: def test_uintalignment_and_alignment():
10092:     # alignment code needs to satisfy these requirements:
10093:     #  1. numpy structs match C struct layout
10094:     #  2. ufuncs/casting is safe wrt to aligned access
10095:     #  3. copy code is safe wrt to "uint alidned" access
10096:     #
10097:     # Complex types are the main problem, whose alignment may not be the same
10098:     # as their "uint alignment".
10099:     #
10100:     # This test might only fail on certain platforms, where uint64 alignment is
10101:     # not equal to complex64 alignment. The second 2 tests will only fail
10102:     # for DEBUG=1.
10103: 
10104:     d1 = np.dtype('u1,c8', align=True)
10105:     d2 = np.dtype('u4,c8', align=True)
10106:     d3 = np.dtype({'names': ['a', 'b'], 'formats': ['u1', d1]}, align=True)
10107: 
10108:     assert_equal(np.zeros(1, dtype=d1)['f1'].flags['ALIGNED'], True)
10109:     assert_equal(np.zeros(1, dtype=d2)['f1'].flags['ALIGNED'], True)
10110:     assert_equal(np.zeros(1, dtype='u1,c8')['f1'].flags['ALIGNED'], False)
10111: 
10112:     # check that C struct matches numpy struct size
10113:     s = _multiarray_tests.get_struct_alignments()
10114:     for d, (alignment, size) in zip([d1, d2, d3], s):
10115:         assert_equal(d.alignment, alignment)
10116:         assert_equal(d.itemsize, size)
10117: 
10118:     # check that ufuncs don't complain in debug mode
10119:     # (this is probably OK if the aligned flag is true above)
10120:     src = np.zeros((2, 2), dtype=d1)['f1']  # 4-byte aligned, often
10121:     np.exp(src)  # assert fails?
10122: 
10123:     # check that copy code doesn't complain in debug mode
10124:     dst = np.zeros((2, 2), dtype='c8')
10125:     dst[:, 1] = src[:, 1]  # assert in lowlevel_strided_loops fails?
10126: 
10127: class TestAlignment:
10128:     # adapted from scipy._lib.tests.test__util.test__aligned_zeros
10129:     # Checks that unusual memory alignments don't trip up numpy.
10130: 
10131:     def check(self, shape, dtype, order, align):
10132:         err_msg = repr((shape, dtype, order, align))
10133:         x = _aligned_zeros(shape, dtype, order, align=align)
10134:         if align is None:
10135:             align = np.dtype(dtype).alignment
10136:         assert_equal(x.__array_interface__['data'][0] % align, 0)
10137:         if hasattr(shape, '__len__'):
10138:             assert_equal(x.shape, shape, err_msg)
10139:         else:
10140:             assert_equal(x.shape, (shape,), err_msg)
10141:         assert_equal(x.dtype, dtype)
10142:         if order == "C":
10143:             assert_(x.flags.c_contiguous, err_msg)
10144:         elif order == "F":
10145:             if x.size > 0:
10146:                 assert_(x.flags.f_contiguous, err_msg)
10147:         elif order is None:
10148:             assert_(x.flags.c_contiguous, err_msg)
10149:         else:
10150:             raise ValueError
10151: 
10152:     def test_various_alignments(self):
10153:         for align in [1, 2, 3, 4, 8, 12, 16, 32, 64, None]:
10154:             for n in [0, 1, 3, 11]:
10155:                 for order in ["C", "F", None]:
10156:                     for dtype in list(np.typecodes["All"]) + ['i4,i4,i4']:
10157:                         if dtype == 'O':
10158:                             # object dtype can't be misaligned
10159:                             continue
10160:                         for shape in [n, (1, 2, 3, n)]:
10161:                             self.check(shape, np.dtype(dtype), order, align)
10162: 
10163:     def test_strided_loop_alignments(self):
10164:         # particularly test that complex64 and float128 use right alignment
10165:         # code-paths, since these are particularly problematic. It is useful to
10166:         # turn on USE_DEBUG for this test, so lowlevel-loop asserts are run.
10167:         for align in [1, 2, 4, 8, 12, 16, None]:
10168:             xf64 = _aligned_zeros(3, np.float64)
10169: 
10170:             xc64 = _aligned_zeros(3, np.complex64, align=align)
10171:             xf128 = _aligned_zeros(3, np.longdouble, align=align)
10172: 
10173:             # test casting, both to and from misaligned
10174:             with suppress_warnings() as sup:
10175:                 sup.filter(ComplexWarning, "Casting complex values")
10176:                 xc64.astype('f8')
10177:             xf64.astype(np.complex64)
10178:             test = xc64 + xf64
10179: 
10180:             xf128.astype('f8')
10181:             xf64.astype(np.longdouble)
10182:             test = xf128 + xf64
10183: 
10184:             test = xf128 + xc64
10185: 
10186:             # test copy, both to and from misaligned
10187:             # contig copy
10188:             xf64[:] = xf64.copy()
10189:             xc64[:] = xc64.copy()
10190:             xf128[:] = xf128.copy()
10191:             # strided copy
10192:             xf64[::2] = xf64[::2].copy()
10193:             xc64[::2] = xc64[::2].copy()
10194:             xf128[::2] = xf128[::2].copy()
10195: 
10196: def test_getfield():
10197:     a = np.arange(32, dtype='uint16')
10198:     if sys.byteorder == 'little':
10199:         i = 0
10200:         j = 1
10201:     else:
10202:         i = 1
10203:         j = 0
10204:     b = a.getfield('int8', i)
10205:     assert_equal(b, a)
10206:     b = a.getfield('int8', j)
10207:     assert_equal(b, 0)
10208:     pytest.raises(ValueError, a.getfield, 'uint8', -1)
10209:     pytest.raises(ValueError, a.getfield, 'uint8', 16)
10210:     pytest.raises(ValueError, a.getfield, 'uint64', 0)
10211: 
10212: 
10213: class TestViewDtype:
10214:     """
10215:     Verify that making a view of a non-contiguous array works as expected.
10216:     """
10217:     def test_smaller_dtype_multiple(self):
10218:         # x is non-contiguous
10219:         x = np.arange(10, dtype='<i4')[::2]
10220:         with pytest.raises(ValueError,
10221:                            match='the last axis must be contiguous'):
10222:             x.view('<i2')
10223:         expected = [[0, 0], [2, 0], [4, 0], [6, 0], [8, 0]]
10224:         assert_array_equal(x[:, np.newaxis].view('<i2'), expected)
10225: 
10226:     def test_smaller_dtype_not_multiple(self):
10227:         # x is non-contiguous
10228:         x = np.arange(5, dtype='<i4')[::2]
10229: 
10230:         with pytest.raises(ValueError,
10231:                            match='the last axis must be contiguous'):
10232:             x.view('S3')
10233:         with pytest.raises(ValueError,
10234:                            match='When changing to a smaller dtype'):
10235:             x[:, np.newaxis].view('S3')
10236: 
10237:         # Make sure the problem is because of the dtype size
10238:         expected = [[b''], [b'\x02'], [b'\x04']]
10239:         assert_array_equal(x[:, np.newaxis].view('S4'), expected)
10240: 
10241:     def test_larger_dtype_multiple(self):
10242:         # x is non-contiguous in the first dimension, contiguous in the last
10243:         x = np.arange(20, dtype='<i2').reshape(10, 2)[::2, :]
10244:         expected = np.array([[65536], [327684], [589832],
10245:                              [851980], [1114128]], dtype='<i4')
10246:         assert_array_equal(x.view('<i4'), expected)
10247: 
10248:     def test_larger_dtype_not_multiple(self):
10249:         # x is non-contiguous in the first dimension, contiguous in the last
10250:         x = np.arange(20, dtype='<i2').reshape(10, 2)[::2, :]
10251:         with pytest.raises(ValueError,
10252:                            match='When changing to a larger dtype'):
10253:             x.view('S3')
10254:         # Make sure the problem is because of the dtype size
10255:         expected = [[b'\x00\x00\x01'], [b'\x04\x00\x05'], [b'\x08\x00\t'],
10256:                     [b'\x0c\x00\r'], [b'\x10\x00\x11']]
10257:         assert_array_equal(x.view('S4'), expected)
10258: 
10259:     def test_f_contiguous(self):
10260:         # x is F-contiguous
10261:         x = np.arange(4 * 3, dtype='<i4').reshape(4, 3).T
10262:         with pytest.raises(ValueError,
10263:                            match='the last axis must be contiguous'):
10264:             x.view('<i2')
10265: 
10266:     def test_non_c_contiguous(self):
10267:         # x is contiguous in axis=-1, but not C-contiguous in other axes
10268:         x = np.arange(2 * 3 * 4, dtype='i1').\
10269:                     reshape(2, 3, 4).transpose(1, 0, 2)
10270:         expected = [[[256, 770], [3340, 3854]],
10271:                     [[1284, 1798], [4368, 4882]],
10272:                     [[2312, 2826], [5396, 5910]]]
10273:         assert_array_equal(x.view('<i2'), expected)
10274: 
10275: 
10276: @pytest.mark.xfail(check_support_sve(), reason="gh-22982")
10277: # Test various array sizes that hit different code paths in quicksort-avx512
10278: @pytest.mark.parametrize("N", np.arange(1, 512))
10279: @pytest.mark.parametrize("dtype", ['e', 'f', 'd'])
10280: def test_sort_float(N, dtype):
10281:     # Regular data with nan sprinkled
10282:     np.random.seed(42)
10283:     arr = -0.5 + np.random.sample(N).astype(dtype)
10284:     arr[np.random.choice(arr.shape[0], 3)] = np.nan
10285:     assert_equal(np.sort(arr, kind='quick'), np.sort(arr, kind='heap'))
10286: 
10287:     # (2) with +INF
10288:     infarr = np.inf * np.ones(N, dtype=dtype)
10289:     infarr[np.random.choice(infarr.shape[0], 5)] = -1.0
10290:     assert_equal(np.sort(infarr, kind='quick'), np.sort(infarr, kind='heap'))
10291: 
10292:     # (3) with -INF
10293:     neginfarr = -np.inf * np.ones(N, dtype=dtype)
10294:     neginfarr[np.random.choice(neginfarr.shape[0], 5)] = 1.0
10295:     assert_equal(np.sort(neginfarr, kind='quick'),
10296:                  np.sort(neginfarr, kind='heap'))
10297: 
10298:     # (4) with +/-INF
10299:     infarr = np.inf * np.ones(N, dtype=dtype)
10300:     infarr[np.random.choice(infarr.shape[0], (int)(N / 2))] = -np.inf
10301:     assert_equal(np.sort(infarr, kind='quick'), np.sort(infarr, kind='heap'))
10302: 
10303: def test_sort_float16():
10304:     arr = np.arange(65536, dtype=np.int16)
10305:     temp = np.frombuffer(arr.tobytes(), dtype=np.float16)
10306:     data = np.copy(temp)
10307:     np.random.shuffle(data)
10308:     data_backup = data
10309:     assert_equal(np.sort(data, kind='quick'),
10310:             np.sort(data_backup, kind='heap'))
10311: 
10312: 
10313: @pytest.mark.parametrize("N", np.arange(1, 512))
10314: @pytest.mark.parametrize("dtype", ['h', 'H', 'i', 'I', 'l', 'L'])
10315: def test_sort_int(N, dtype):
10316:     # Random data with MAX and MIN sprinkled
10317:     minv = np.iinfo(dtype).min
10318:     maxv = np.iinfo(dtype).max
10319:     arr = np.random.randint(low=minv, high=maxv - 1, size=N, dtype=dtype)
10320:     arr[np.random.choice(arr.shape[0], 10)] = minv
10321:     arr[np.random.choice(arr.shape[0], 10)] = maxv
10322:     assert_equal(np.sort(arr, kind='quick'), np.sort(arr, kind='heap'))
10323: 
10324: 
10325: def test_sort_uint():
10326:     # Random data with NPY_MAX_UINT32 sprinkled
10327:     rng = np.random.default_rng(42)
10328:     N = 2047
10329:     maxv = np.iinfo(np.uint32).max
10330:     arr = rng.integers(low=0, high=maxv, size=N).astype('uint32')
10331:     arr[np.random.choice(arr.shape[0], 10)] = maxv
10332:     assert_equal(np.sort(arr, kind='quick'), np.sort(arr, kind='heap'))
10333: 
10334: def test_private_get_ndarray_c_version():
10335:     assert isinstance(_get_ndarray_c_version(), int)
10336: 
10337: 
10338: @pytest.mark.parametrize("N", np.arange(1, 512))
10339: @pytest.mark.parametrize("dtype", [np.float32, np.float64])
10340: def test_argsort_float(N, dtype):
10341:     rnd = np.random.RandomState(116112)
10342:     # (1) Regular data with a few nan: doesn't use vectorized sort
10343:     arr = -0.5 + rnd.random(N).astype(dtype)
10344:     arr[rnd.choice(arr.shape[0], 3)] = np.nan
10345:     assert_arg_sorted(arr, np.argsort(arr, kind='quick'))
10346: 
10347:     # (2) Random data with inf at the end of array
10348:     # See: https://github.com/intel/x86-simd-sort/pull/39
10349:     arr = -0.5 + rnd.rand(N).astype(dtype)
10350:     arr[N - 1] = np.inf
10351:     assert_arg_sorted(arr, np.argsort(arr, kind='quick'))
10352: 
10353: 
10354: @pytest.mark.parametrize("N", np.arange(2, 512))
10355: @pytest.mark.parametrize("dtype", [np.int32, np.uint32, np.int64, np.uint64])
10356: def test_argsort_int(N, dtype):
10357:     rnd = np.random.RandomState(1100710816)
10358:     # (1) random data with min and max values
10359:     minv = np.iinfo(dtype).min
10360:     maxv = np.iinfo(dtype).max
10361:     arr = rnd.randint(low=minv, high=maxv, size=N, dtype=dtype)
10362:     i, j = rnd.choice(N, 2, replace=False)
10363:     arr[i] = minv
10364:     arr[j] = maxv
10365:     assert_arg_sorted(arr, np.argsort(arr, kind='quick'))
10366: 
10367:     # (2) random data with max value at the end of array
10368:     # See: https://github.com/intel/x86-simd-sort/pull/39
10369:     arr = rnd.randint(low=minv, high=maxv, size=N, dtype=dtype)
10370:     arr[N - 1] = maxv
10371:     assert_arg_sorted(arr, np.argsort(arr, kind='quick'))
10372: 
10373: # Test large arrays that leverage openMP implementations from x86-simd-sort:
10374: @pytest.mark.parametrize("dtype", [np.float16, np.float32, np.float64])
10375: def test_sort_largearrays(dtype):
10376:     N = 1000000
10377:     rnd = np.random.RandomState(1100710816)
10378:     arr = -0.5 + rnd.random(N).astype(dtype)
10379:     assert_equal(np.sort(arr, kind='quick'), np.sort(arr, kind='heap'))
10380: 
10381: # Test large arrays that leverage openMP implementations from x86-simd-sort:
10382: @pytest.mark.parametrize("dtype", [np.float32, np.float64])
10383: def test_argsort_largearrays(dtype):
10384:     N = 1000000
10385:     rnd = np.random.RandomState(1100710816)
10386:     arr = -0.5 + rnd.random(N).astype(dtype)
10387:     assert_arg_sorted(arr, np.argsort(arr, kind='quick'))
10388: 
10389: @pytest.mark.skipif(not HAS_REFCOUNT, reason="Python lacks refcounts")
10390: def test_gh_22683():
10391:     b = 777.68760986
10392:     a = np.array([b] * 10000, dtype=object)
10393:     refc_start = sys.getrefcount(b)
10394:     np.choose(np.zeros(10000, dtype=int), [a], out=a)
10395:     np.choose(np.zeros(10000, dtype=int), [a], out=a)
10396:     refc_end = sys.getrefcount(b)
10397:     assert refc_end - refc_start < 10
10398: 
10399: 
10400: def test_gh_24459():
10401:     a = np.zeros((50, 3), dtype=np.float64)
10402:     with pytest.raises(TypeError):
10403:         np.choose(a, [3, -1])
10404: 
10405: 
10406: def test_gh_28206():
10407:     a = np.arange(3)
10408:     b = np.ones((3, 3), dtype=np.int64)
10409:     out = np.array([np.nan, np.nan, np.nan])
10410: 
10411:     with warnings.catch_warnings():
10412:         warnings.simplefilter("error", RuntimeWarning)
10413:         np.choose(a, b, out=out)
10414: 
10415: 
10416: @pytest.mark.parametrize("N", np.arange(2, 512))
10417: @pytest.mark.parametrize("dtype", [np.int16, np.uint16,
10418:                         np.int32, np.uint32, np.int64, np.uint64])
10419: def test_partition_int(N, dtype):
10420:     rnd = np.random.RandomState(1100710816)
10421:     # (1) random data with min and max values
10422:     minv = np.iinfo(dtype).min
10423:     maxv = np.iinfo(dtype).max
10424:     arr = rnd.randint(low=minv, high=maxv, size=N, dtype=dtype)
10425:     i, j = rnd.choice(N, 2, replace=False)
10426:     arr[i] = minv
10427:     arr[j] = maxv
10428:     k = rnd.choice(N, 1)[0]
10429:     assert_arr_partitioned(np.sort(arr)[k], k,
10430:             np.partition(arr, k, kind='introselect'))
10431:     assert_arr_partitioned(np.sort(arr)[k], k,
10432:             arr[np.argpartition(arr, k, kind='introselect')])
10433: 
10434:     # (2) random data with max value at the end of array
10435:     arr = rnd.randint(low=minv, high=maxv, size=N, dtype=dtype)
10436:     arr[N - 1] = maxv
10437:     assert_arr_partitioned(np.sort(arr)[k], k,
10438:             np.partition(arr, k, kind='introselect'))
10439:     assert_arr_partitioned(np.sort(arr)[k], k,
10440:             arr[np.argpartition(arr, k, kind='introselect')])
10441: 
10442: 
10443: @pytest.mark.parametrize("N", np.arange(2, 512))
10444: @pytest.mark.parametrize("dtype", [np.float16, np.float32, np.float64])
10445: def test_partition_fp(N, dtype):
10446:     rnd = np.random.RandomState(1100710816)
10447:     arr = -0.5 + rnd.random(N).astype(dtype)
10448:     k = rnd.choice(N, 1)[0]
10449:     assert_arr_partitioned(np.sort(arr)[k], k,
10450:             np.partition(arr, k, kind='introselect'))
10451:     assert_arr_partitioned(np.sort(arr)[k], k,
10452:             arr[np.argpartition(arr, k, kind='introselect')])
10453: 
10454:     # Check that `np.inf < np.nan`
10455:     # This follows np.sort
10456:     arr[0] = np.nan
10457:     arr[1] = np.inf
10458:     o1 = np.partition(arr, -2, kind='introselect')
10459:     o2 = arr[np.argpartition(arr, -2, kind='introselect')]
10460:     for out in [o1, o2]:
10461:         assert_(np.isnan(out[-1]))
10462:         assert_equal(out[-2], np.inf)
10463: 
10464: def test_cannot_assign_data():
10465:     a = np.arange(10)
10466:     b = np.linspace(0, 1, 10)
10467:     with pytest.raises(AttributeError):
10468:         a.data = b.data
10469: 
10470: def test_insufficient_width():
10471:     """
10472:     If a 'width' parameter is passed into ``binary_repr`` that is insufficient
10473:     to represent the number in base 2 (positive) or 2's complement (negative)
10474:     form, the function used to silently ignore the parameter and return a
10475:     representation using the minimal number of bits needed for the form in
10476:     question. Such behavior is now considered unsafe from a user perspective
10477:     and will raise an error.
10478:     """
10479:     with pytest.raises(ValueError):
10480:         np.binary_repr(10, width=2)
10481:     with pytest.raises(ValueError):
10482:         np.binary_repr(-5, width=2)
10483: 
10484: def test_npy_char_raises():
10485:     from numpy._core._multiarray_tests import npy_char_deprecation
10486:     with pytest.raises(ValueError):
10487:         npy_char_deprecation()
10488: 
10489: 
10490: class TestDevice:
10491:     """
10492:     Test arr.device attribute and arr.to_device() method.
10493:     """
10494:     @pytest.mark.parametrize("func, arg", [
10495:         (np.arange, 5),
10496:         (np.empty_like, []),
10497:         (np.zeros, 5),
10498:         (np.empty, (5, 5)),
10499:         (np.asarray, []),
10500:         (np.asanyarray, []),
10501:     ])
10502:     def test_device(self, func, arg):
10503:         arr = func(arg)
10504:         assert arr.device == "cpu"
10505:         arr = func(arg, device=None)
10506:         assert arr.device == "cpu"
10507:         arr = func(arg, device="cpu")
10508:         assert arr.device == "cpu"
10509: 
10510:         with assert_raises_regex(
10511:             ValueError,
10512:             r"Device not understood. Only \"cpu\" is allowed, "
10513:             r"but received: nonsense"
10514:         ):
10515:             func(arg, device="nonsense")
10516: 
10517:         with assert_raises_regex(
10518:             AttributeError,
10519:             r"attribute 'device' of '(numpy.|)ndarray' objects is "
10520:             r"not writable"
10521:         ):
10522:             arr.device = "other"
10523: 
10524:     def test_to_device(self):
10525:         arr = np.arange(5)
10526: 
10527:         assert arr.to_device("cpu") is arr
10528:         with assert_raises_regex(
10529:             ValueError,
10530:             r"The stream argument in to_device\(\) is not supported"
10531:         ):
10532:             arr.to_device("cpu", stream=1)
10533: 
10534: def test_array_interface_excess_dimensions_raises():
10535:     """Regression test for gh-27949: ensure too many dims raises ValueError instead of segfault."""
10536: 
10537:     # Dummy object to hold a custom __array_interface__
10538:     class DummyArray:
10539:         def __init__(self, interface):
10540:             # Attach the array interface dict to mimic an array
10541:             self.__array_interface__ = interface
10542: 
10543:     # Create a base array (scalar) and copy its interface
10544:     base = np.array(42)  # base can be any scalar or array
10545:     interface = dict(base.__array_interface__)
10546: 
10547:     # Modify the shape to exceed NumPy's dimension limit (NPY_MAXDIMS, typically 64)
10548:     interface['shape'] = tuple([1] * 136)  # match the original bug report
10549: 
10550:     dummy = DummyArray(interface)
10551:     # Now, using np.asanyarray on this dummy should trigger a ValueError (not segfault)
10552:     with pytest.raises(ValueError, match="dimensions must be within"):
10553:         np.asanyarray(dummy)
10554: 
10555: @pytest.mark.parametrize("dtype", [np.float32, np.float64, np.uint32, np.complex128])
10556: def test_array_dunder_array_preserves_dtype_on_none(dtype):
10557:     """
10558:     Regression test for: https://github.com/numpy/numpy/issues/27407
10559:     Ensure that __array__(None) returns an array of the same dtype.
10560:     """
10561:     a = np.array([1], dtype=dtype)
10562:     b = a.__array__(None)
10563:     assert_array_equal(a, b, strict=True)
