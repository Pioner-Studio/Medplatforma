    1: import datetime
    2: import pickle
    3: 
    4: import pytest
    5: 
    6: import numpy
    7: import numpy as np
    8: from numpy.testing import (
    9:     IS_WASM,
   10:     assert_,
   11:     assert_array_equal,
   12:     assert_equal,
   13:     assert_raises,
   14:     assert_raises_regex,
   15:     assert_warns,
   16:     suppress_warnings,
   17: )
   18: 
   19: # Use pytz to test out various time zones if available
   20: try:
   21:     from pytz import timezone as tz
   22:     _has_pytz = True
   23: except ImportError:
   24:     _has_pytz = False
   25: 
   26: try:
   27:     RecursionError
   28: except NameError:
   29:     RecursionError = RuntimeError  # python < 3.5
   30: 
   31: 
   32: def _assert_equal_hash(v1, v2):
   33:     assert v1 == v2
   34:     assert hash(v1) == hash(v2)
   35:     assert v2 in {v1}
   36: 
   37: 
   38: class TestDateTime:
   39: 
   40:     def test_string(self):
   41:         msg = "no explicit representation of timezones available for " \
   42:               "np.datetime64"
   43:         with pytest.warns(UserWarning, match=msg):
   44:             np.datetime64('2000-01-01T00+01')
   45: 
   46:     def test_datetime(self):
   47:         msg = "no explicit representation of timezones available for " \
   48:               "np.datetime64"
   49:         with pytest.warns(UserWarning, match=msg):
   50:             t0 = np.datetime64('2023-06-09T12:18:40Z', 'ns')
   51: 
   52:         t0 = np.datetime64('2023-06-09T12:18:40', 'ns')
   53: 
   54:     def test_datetime_dtype_creation(self):
   55:         for unit in ['Y', 'M', 'W', 'D',
   56:                      'h', 'm', 's', 'ms', 'us',
   57:                      'Ојs',  # alias for us
   58:                      'ns', 'ps', 'fs', 'as']:
   59:             dt1 = np.dtype(f'M8[750{unit}]')
   60:             assert_(dt1 == np.dtype(f'datetime64[750{unit}]'))
   61:             dt2 = np.dtype(f'm8[{unit}]')
   62:             assert_(dt2 == np.dtype(f'timedelta64[{unit}]'))
   63: 
   64:         # Generic units shouldn't add [] to the end
   65:         assert_equal(str(np.dtype("M8")), "datetime64")
   66: 
   67:         # Should be possible to specify the endianness
   68:         assert_equal(np.dtype("=M8"), np.dtype("M8"))
   69:         assert_equal(np.dtype("=M8[s]"), np.dtype("M8[s]"))
   70:         assert_(np.dtype(">M8") == np.dtype("M8") or
   71:                 np.dtype("<M8") == np.dtype("M8"))
   72:         assert_(np.dtype(">M8[D]") == np.dtype("M8[D]") or
   73:                 np.dtype("<M8[D]") == np.dtype("M8[D]"))
   74:         assert_(np.dtype(">M8") != np.dtype("<M8"))
   75: 
   76:         assert_equal(np.dtype("=m8"), np.dtype("m8"))
   77:         assert_equal(np.dtype("=m8[s]"), np.dtype("m8[s]"))
   78:         assert_(np.dtype(">m8") == np.dtype("m8") or
   79:                 np.dtype("<m8") == np.dtype("m8"))
   80:         assert_(np.dtype(">m8[D]") == np.dtype("m8[D]") or
   81:                 np.dtype("<m8[D]") == np.dtype("m8[D]"))
   82:         assert_(np.dtype(">m8") != np.dtype("<m8"))
   83: 
   84:         # Check that the parser rejects bad datetime types
   85:         assert_raises(TypeError, np.dtype, 'M8[badunit]')
   86:         assert_raises(TypeError, np.dtype, 'm8[badunit]')
   87:         assert_raises(TypeError, np.dtype, 'M8[YY]')
   88:         assert_raises(TypeError, np.dtype, 'm8[YY]')
   89:         assert_raises(TypeError, np.dtype, 'm4')
   90:         assert_raises(TypeError, np.dtype, 'M7')
   91:         assert_raises(TypeError, np.dtype, 'm7')
   92:         assert_raises(TypeError, np.dtype, 'M16')
   93:         assert_raises(TypeError, np.dtype, 'm16')
   94:         assert_raises(TypeError, np.dtype, 'M8[3000000000ps]')
   95: 
   96:     def test_datetime_casting_rules(self):
   97:         # Cannot cast safely/same_kind between timedelta and datetime
   98:         assert_(not np.can_cast('m8', 'M8', casting='same_kind'))
   99:         assert_(not np.can_cast('M8', 'm8', casting='same_kind'))
  100:         assert_(not np.can_cast('m8', 'M8', casting='safe'))
  101:         assert_(not np.can_cast('M8', 'm8', casting='safe'))
  102: 
  103:         # Can cast safely/same_kind from integer to timedelta
  104:         assert_(np.can_cast('i8', 'm8', casting='same_kind'))
  105:         assert_(np.can_cast('i8', 'm8', casting='safe'))
  106:         assert_(np.can_cast('i4', 'm8', casting='same_kind'))
  107:         assert_(np.can_cast('i4', 'm8', casting='safe'))
  108:         assert_(np.can_cast('u4', 'm8', casting='same_kind'))
  109:         assert_(np.can_cast('u4', 'm8', casting='safe'))
  110: 
  111:         # Cannot cast safely from unsigned integer of the same size, which
  112:         # could overflow
  113:         assert_(np.can_cast('u8', 'm8', casting='same_kind'))
  114:         assert_(not np.can_cast('u8', 'm8', casting='safe'))
  115: 
  116:         # Cannot cast safely/same_kind from float to timedelta
  117:         assert_(not np.can_cast('f4', 'm8', casting='same_kind'))
  118:         assert_(not np.can_cast('f4', 'm8', casting='safe'))
  119: 
  120:         # Cannot cast safely/same_kind from integer to datetime
  121:         assert_(not np.can_cast('i8', 'M8', casting='same_kind'))
  122:         assert_(not np.can_cast('i8', 'M8', casting='safe'))
  123: 
  124:         # Cannot cast safely/same_kind from bool to datetime
  125:         assert_(not np.can_cast('b1', 'M8', casting='same_kind'))
  126:         assert_(not np.can_cast('b1', 'M8', casting='safe'))
  127:         # Can cast safely/same_kind from bool to timedelta
  128:         assert_(np.can_cast('b1', 'm8', casting='same_kind'))
  129:         assert_(np.can_cast('b1', 'm8', casting='safe'))
  130: 
  131:         # Can cast datetime safely from months/years to days
  132:         assert_(np.can_cast('M8[M]', 'M8[D]', casting='safe'))
  133:         assert_(np.can_cast('M8[Y]', 'M8[D]', casting='safe'))
  134:         # Cannot cast timedelta safely from months/years to days
  135:         assert_(not np.can_cast('m8[M]', 'm8[D]', casting='safe'))
  136:         assert_(not np.can_cast('m8[Y]', 'm8[D]', casting='safe'))
  137:         # Can cast datetime same_kind from months/years to days
  138:         assert_(np.can_cast('M8[M]', 'M8[D]', casting='same_kind'))
  139:         assert_(np.can_cast('M8[Y]', 'M8[D]', casting='same_kind'))
  140:         # Can't cast timedelta same_kind from months/years to days
  141:         assert_(not np.can_cast('m8[M]', 'm8[D]', casting='same_kind'))
  142:         assert_(not np.can_cast('m8[Y]', 'm8[D]', casting='same_kind'))
  143:         # Can cast datetime same_kind across the date/time boundary
  144:         assert_(np.can_cast('M8[D]', 'M8[h]', casting='same_kind'))
  145:         # Can cast timedelta same_kind across the date/time boundary
  146:         assert_(np.can_cast('m8[D]', 'm8[h]', casting='same_kind'))
  147:         assert_(np.can_cast('m8[h]', 'm8[D]', casting='same_kind'))
  148: 
  149:         # Cannot cast safely if the integer multiplier doesn't divide
  150:         assert_(not np.can_cast('M8[7h]', 'M8[3h]', casting='safe'))
  151:         assert_(not np.can_cast('M8[3h]', 'M8[6h]', casting='safe'))
  152:         # But can cast same_kind
  153:         assert_(np.can_cast('M8[7h]', 'M8[3h]', casting='same_kind'))
  154:         # Can cast safely if the integer multiplier does divide
  155:         assert_(np.can_cast('M8[6h]', 'M8[3h]', casting='safe'))
  156: 
  157:         # We can always cast types with generic units (corresponding to NaT) to
  158:         # more specific types
  159:         assert_(np.can_cast('m8', 'm8[h]', casting='same_kind'))
  160:         assert_(np.can_cast('m8', 'm8[h]', casting='safe'))
  161:         assert_(np.can_cast('M8', 'M8[h]', casting='same_kind'))
  162:         assert_(np.can_cast('M8', 'M8[h]', casting='safe'))
  163:         # but not the other way around
  164:         assert_(not np.can_cast('m8[h]', 'm8', casting='same_kind'))
  165:         assert_(not np.can_cast('m8[h]', 'm8', casting='safe'))
  166:         assert_(not np.can_cast('M8[h]', 'M8', casting='same_kind'))
  167:         assert_(not np.can_cast('M8[h]', 'M8', casting='safe'))
  168: 
  169:     def test_datetime_prefix_conversions(self):
  170:         # regression tests related to gh-19631;
  171:         # test metric prefixes from seconds down to
  172:         # attoseconds for bidirectional conversions
  173:         smaller_units = ['M8[7000ms]',
  174:                          'M8[2000us]',
  175:                          'M8[1000ns]',
  176:                          'M8[5000ns]',
  177:                          'M8[2000ps]',
  178:                          'M8[9000fs]',
  179:                          'M8[1000as]',
  180:                          'M8[2000000ps]',
  181:                          'M8[1000000as]',
  182:                          'M8[2000000000ps]',
  183:                          'M8[1000000000as]']
  184:         larger_units = ['M8[7s]',
  185:                         'M8[2ms]',
  186:                         'M8[us]',
  187:                         'M8[5us]',
  188:                         'M8[2ns]',
  189:                         'M8[9ps]',
  190:                         'M8[1fs]',
  191:                         'M8[2us]',
  192:                         'M8[1ps]',
  193:                         'M8[2ms]',
  194:                         'M8[1ns]']
  195:         for larger_unit, smaller_unit in zip(larger_units, smaller_units):
  196:             assert np.can_cast(larger_unit, smaller_unit, casting='safe')
  197:             assert np.can_cast(smaller_unit, larger_unit, casting='safe')
  198: 
  199:     @pytest.mark.parametrize("unit", [
  200:         "s", "ms", "us", "ns", "ps", "fs", "as"])
  201:     def test_prohibit_negative_datetime(self, unit):
  202:         with assert_raises(TypeError):
  203:             np.array([1], dtype=f"M8[-1{unit}]")
  204: 
  205:     def test_compare_generic_nat(self):
  206:         # regression tests for gh-6452
  207:         assert_(np.datetime64('NaT') !=
  208:                 np.datetime64('2000') + np.timedelta64('NaT'))
  209:         assert_(np.datetime64('NaT') != np.datetime64('NaT', 'us'))
  210:         assert_(np.datetime64('NaT', 'us') != np.datetime64('NaT'))
  211: 
  212:     @pytest.mark.parametrize("size", [
  213:         3, 21, 217, 1000])
  214:     def test_datetime_nat_argsort_stability(self, size):
  215:         # NaT < NaT should be False internally for
  216:         # sort stability
  217:         expected = np.arange(size)
  218:         arr = np.tile(np.datetime64('NaT'), size)
  219:         assert_equal(np.argsort(arr, kind='mergesort'), expected)
  220: 
  221:     @pytest.mark.parametrize("size", [
  222:         3, 21, 217, 1000])
  223:     def test_timedelta_nat_argsort_stability(self, size):
  224:         # NaT < NaT should be False internally for
  225:         # sort stability
  226:         expected = np.arange(size)
  227:         arr = np.tile(np.timedelta64('NaT'), size)
  228:         assert_equal(np.argsort(arr, kind='mergesort'), expected)
  229: 
  230:     @pytest.mark.parametrize("arr, expected", [
  231:         # the example provided in gh-12629
  232:         (['NaT', 1, 2, 3],
  233:          [1, 2, 3, 'NaT']),
  234:         # multiple NaTs
  235:         (['NaT', 9, 'NaT', -707],
  236:          [-707, 9, 'NaT', 'NaT']),
  237:         # this sort explores another code path for NaT
  238:         ([1, -2, 3, 'NaT'],
  239:          [-2, 1, 3, 'NaT']),
  240:         # 2-D array
  241:         ([[51, -220, 'NaT'],
  242:           [-17, 'NaT', -90]],
  243:          [[-220, 51, 'NaT'],
  244:           [-90, -17, 'NaT']]),
  245:         ])
  246:     @pytest.mark.parametrize("dtype", [
  247:         'M8[ns]', 'M8[us]',
  248:         'm8[ns]', 'm8[us]'])
  249:     def test_datetime_timedelta_sort_nat(self, arr, expected, dtype):
  250:         # fix for gh-12629 and gh-15063; NaT sorting to end of array
  251:         arr = np.array(arr, dtype=dtype)
  252:         expected = np.array(expected, dtype=dtype)
  253:         arr.sort()
  254:         assert_equal(arr, expected)
  255: 
  256:     def test_datetime_scalar_construction(self):
  257:         # Construct with different units
  258:         assert_equal(np.datetime64('1950-03-12', 'D'),
  259:                      np.datetime64('1950-03-12'))
  260:         assert_equal(np.datetime64('1950-03-12T13', 's'),
  261:                      np.datetime64('1950-03-12T13', 'm'))
  262: 
  263:         # Default construction means NaT
  264:         assert_equal(np.datetime64(), np.datetime64('NaT'))
  265: 
  266:         # Some basic strings and repr
  267:         assert_equal(str(np.datetime64('NaT')), 'NaT')
  268:         assert_equal(repr(np.datetime64('NaT')),
  269:                      "np.datetime64('NaT')")
  270:         assert_equal(str(np.datetime64('2011-02')), '2011-02')
  271:         assert_equal(repr(np.datetime64('2011-02')),
  272:                      "np.datetime64('2011-02')")
  273: 
  274:         # None gets constructed as NaT
  275:         assert_equal(np.datetime64(None), np.datetime64('NaT'))
  276: 
  277:         # Default construction of NaT is in generic units
  278:         assert_equal(np.datetime64().dtype, np.dtype('M8'))
  279:         assert_equal(np.datetime64('NaT').dtype, np.dtype('M8'))
  280: 
  281:         # Construction from integers requires a specified unit
  282:         assert_raises(ValueError, np.datetime64, 17)
  283: 
  284:         # When constructing from a scalar or zero-dimensional array,
  285:         # it either keeps the units or you can override them.
  286:         a = np.datetime64('2000-03-18T16', 'h')
  287:         b = np.array('2000-03-18T16', dtype='M8[h]')
  288: 
  289:         assert_equal(a.dtype, np.dtype('M8[h]'))
  290:         assert_equal(b.dtype, np.dtype('M8[h]'))
  291: 
  292:         assert_equal(np.datetime64(a), a)
  293:         assert_equal(np.datetime64(a).dtype, np.dtype('M8[h]'))
  294: 
  295:         assert_equal(np.datetime64(b), a)
  296:         assert_equal(np.datetime64(b).dtype, np.dtype('M8[h]'))
  297: 
  298:         assert_equal(np.datetime64(a, 's'), a)
  299:         assert_equal(np.datetime64(a, 's').dtype, np.dtype('M8[s]'))
  300: 
  301:         assert_equal(np.datetime64(b, 's'), a)
  302:         assert_equal(np.datetime64(b, 's').dtype, np.dtype('M8[s]'))
  303: 
  304:         # Construction from datetime.date
  305:         assert_equal(np.datetime64('1945-03-25'),
  306:                      np.datetime64(datetime.date(1945, 3, 25)))
  307:         assert_equal(np.datetime64('2045-03-25', 'D'),
  308:                      np.datetime64(datetime.date(2045, 3, 25), 'D'))
  309:         # Construction from datetime.datetime
  310:         assert_equal(np.datetime64('1980-01-25T14:36:22.5'),
  311:                      np.datetime64(datetime.datetime(1980, 1, 25,
  312:                                                 14, 36, 22, 500000)))
  313: 
  314:         # Construction with time units from a date is okay
  315:         assert_equal(np.datetime64('1920-03-13', 'h'),
  316:                      np.datetime64('1920-03-13T00'))
  317:         assert_equal(np.datetime64('1920-03', 'm'),
  318:                      np.datetime64('1920-03-01T00:00'))
  319:         assert_equal(np.datetime64('1920', 's'),
  320:                      np.datetime64('1920-01-01T00:00:00'))
  321:         assert_equal(np.datetime64(datetime.date(2045, 3, 25), 'ms'),
  322:                      np.datetime64('2045-03-25T00:00:00.000'))
  323: 
  324:         # Construction with date units from a datetime is also okay
  325:         assert_equal(np.datetime64('1920-03-13T18', 'D'),
  326:                      np.datetime64('1920-03-13'))
  327:         assert_equal(np.datetime64('1920-03-13T18:33:12', 'M'),
  328:                      np.datetime64('1920-03'))
  329:         assert_equal(np.datetime64('1920-03-13T18:33:12.5', 'Y'),
  330:                      np.datetime64('1920'))
  331: 
  332:     def test_datetime_scalar_construction_timezone(self):
  333:         msg = "no explicit representation of timezones available for " \
  334:               "np.datetime64"
  335:         # verify that supplying an explicit timezone works, but is deprecated
  336:         with pytest.warns(UserWarning, match=msg):
  337:             assert_equal(np.datetime64('2000-01-01T00Z'),
  338:                          np.datetime64('2000-01-01T00'))
  339:         with pytest.warns(UserWarning, match=msg):
  340:             assert_equal(np.datetime64('2000-01-01T00-08'),
  341:                          np.datetime64('2000-01-01T08'))
  342: 
  343:     def test_datetime_array_find_type(self):
  344:         dt = np.datetime64('1970-01-01', 'M')
  345:         arr = np.array([dt])
  346:         assert_equal(arr.dtype, np.dtype('M8[M]'))
  347: 
  348:         # at the moment, we don't automatically convert these to datetime64
  349: 
  350:         dt = datetime.date(1970, 1, 1)
  351:         arr = np.array([dt])
  352:         assert_equal(arr.dtype, np.dtype('O'))
  353: 
  354:         dt = datetime.datetime(1970, 1, 1, 12, 30, 40)
  355:         arr = np.array([dt])
  356:         assert_equal(arr.dtype, np.dtype('O'))
  357: 
  358:         # find "supertype" for non-dates and dates
  359: 
  360:         b = np.bool(True)
  361:         dm = np.datetime64('1970-01-01', 'M')
  362:         d = datetime.date(1970, 1, 1)
  363:         dt = datetime.datetime(1970, 1, 1, 12, 30, 40)
  364: 
  365:         arr = np.array([b, dm])
  366:         assert_equal(arr.dtype, np.dtype('O'))
  367: 
  368:         arr = np.array([b, d])
  369:         assert_equal(arr.dtype, np.dtype('O'))
  370: 
  371:         arr = np.array([b, dt])
  372:         assert_equal(arr.dtype, np.dtype('O'))
  373: 
  374:         arr = np.array([d, d]).astype('datetime64')
  375:         assert_equal(arr.dtype, np.dtype('M8[D]'))
  376: 
  377:         arr = np.array([dt, dt]).astype('datetime64')
  378:         assert_equal(arr.dtype, np.dtype('M8[us]'))
  379: 
  380:     @pytest.mark.parametrize("unit", [
  381:     # test all date / time units and use
  382:     # "generic" to select generic unit
  383:     ("Y"), ("M"), ("W"), ("D"), ("h"), ("m"),
  384:     ("s"), ("ms"), ("us"), ("ns"), ("ps"),
  385:     ("fs"), ("as"), ("generic")])
  386:     def test_timedelta_np_int_construction(self, unit):
  387:         # regression test for gh-7617
  388:         if unit != "generic":
  389:             assert_equal(np.timedelta64(np.int64(123), unit),
  390:                          np.timedelta64(123, unit))
  391:         else:
  392:             assert_equal(np.timedelta64(np.int64(123)),
  393:                          np.timedelta64(123))
  394: 
  395:     def test_timedelta_scalar_construction(self):
  396:         # Construct with different units
  397:         assert_equal(np.timedelta64(7, 'D'),
  398:                      np.timedelta64(1, 'W'))
  399:         assert_equal(np.timedelta64(120, 's'),
  400:                      np.timedelta64(2, 'm'))
  401: 
  402:         # Default construction means 0
  403:         assert_equal(np.timedelta64(), np.timedelta64(0))
  404: 
  405:         # None gets constructed as NaT
  406:         assert_equal(np.timedelta64(None), np.timedelta64('NaT'))
  407: 
  408:         # Some basic strings and repr
  409:         assert_equal(str(np.timedelta64('NaT')), 'NaT')
  410:         assert_equal(repr(np.timedelta64('NaT')),
  411:                      "np.timedelta64('NaT')")
  412:         assert_equal(str(np.timedelta64(3, 's')), '3 seconds')
  413:         assert_equal(repr(np.timedelta64(-3, 's')),
  414:                      "np.timedelta64(-3,'s')")
  415:         assert_equal(repr(np.timedelta64(12)),
  416:                      "np.timedelta64(12)")
  417: 
  418:         # Construction from an integer produces generic units
  419:         assert_equal(np.timedelta64(12).dtype, np.dtype('m8'))
  420: 
  421:         # When constructing from a scalar or zero-dimensional array,
  422:         # it either keeps the units or you can override them.
  423:         a = np.timedelta64(2, 'h')
  424:         b = np.array(2, dtype='m8[h]')
  425: 
  426:         assert_equal(a.dtype, np.dtype('m8[h]'))
  427:         assert_equal(b.dtype, np.dtype('m8[h]'))
  428: 
  429:         assert_equal(np.timedelta64(a), a)
  430:         assert_equal(np.timedelta64(a).dtype, np.dtype('m8[h]'))
  431: 
  432:         assert_equal(np.timedelta64(b), a)
  433:         assert_equal(np.timedelta64(b).dtype, np.dtype('m8[h]'))
  434: 
  435:         assert_equal(np.timedelta64(a, 's'), a)
  436:         assert_equal(np.timedelta64(a, 's').dtype, np.dtype('m8[s]'))
  437: 
  438:         assert_equal(np.timedelta64(b, 's'), a)
  439:         assert_equal(np.timedelta64(b, 's').dtype, np.dtype('m8[s]'))
  440: 
  441:         # Construction from datetime.timedelta
  442:         assert_equal(np.timedelta64(5, 'D'),
  443:                      np.timedelta64(datetime.timedelta(days=5)))
  444:         assert_equal(np.timedelta64(102347621, 's'),
  445:                      np.timedelta64(datetime.timedelta(seconds=102347621)))
  446:         assert_equal(np.timedelta64(-10234760000, 'us'),
  447:                      np.timedelta64(datetime.timedelta(
  448:                                             microseconds=-10234760000)))
  449:         assert_equal(np.timedelta64(10234760000, 'us'),
  450:                      np.timedelta64(datetime.timedelta(
  451:                                             microseconds=10234760000)))
  452:         assert_equal(np.timedelta64(1023476, 'ms'),
  453:                      np.timedelta64(datetime.timedelta(milliseconds=1023476)))
  454:         assert_equal(np.timedelta64(10, 'm'),
  455:                      np.timedelta64(datetime.timedelta(minutes=10)))
  456:         assert_equal(np.timedelta64(281, 'h'),
  457:                      np.timedelta64(datetime.timedelta(hours=281)))
  458:         assert_equal(np.timedelta64(28, 'W'),
  459:                      np.timedelta64(datetime.timedelta(weeks=28)))
  460: 
  461:         # Cannot construct across nonlinear time unit boundaries
  462:         a = np.timedelta64(3, 's')
  463:         assert_raises(TypeError, np.timedelta64, a, 'M')
  464:         assert_raises(TypeError, np.timedelta64, a, 'Y')
  465:         a = np.timedelta64(6, 'M')
  466:         assert_raises(TypeError, np.timedelta64, a, 'D')
  467:         assert_raises(TypeError, np.timedelta64, a, 'h')
  468:         a = np.timedelta64(1, 'Y')
  469:         assert_raises(TypeError, np.timedelta64, a, 'D')
  470:         assert_raises(TypeError, np.timedelta64, a, 'm')
  471:         a = datetime.timedelta(seconds=3)
  472:         assert_raises(TypeError, np.timedelta64, a, 'M')
  473:         assert_raises(TypeError, np.timedelta64, a, 'Y')
  474:         a = datetime.timedelta(weeks=3)
  475:         assert_raises(TypeError, np.timedelta64, a, 'M')
  476:         assert_raises(TypeError, np.timedelta64, a, 'Y')
  477:         a = datetime.timedelta()
  478:         assert_raises(TypeError, np.timedelta64, a, 'M')
  479:         assert_raises(TypeError, np.timedelta64, a, 'Y')
  480: 
  481:     def test_timedelta_object_array_conversion(self):
  482:         # Regression test for gh-11096
  483:         inputs = [datetime.timedelta(28),
  484:                   datetime.timedelta(30),
  485:                   datetime.timedelta(31)]
  486:         expected = np.array([28, 30, 31], dtype='timedelta64[D]')
  487:         actual = np.array(inputs, dtype='timedelta64[D]')
  488:         assert_equal(expected, actual)
  489: 
  490:     def test_timedelta_0_dim_object_array_conversion(self):
  491:         # Regression test for gh-11151
  492:         test = np.array(datetime.timedelta(seconds=20))
  493:         actual = test.astype(np.timedelta64)
  494:         # expected value from the array constructor workaround
  495:         # described in above issue
  496:         expected = np.array(datetime.timedelta(seconds=20),
  497:                             np.timedelta64)
  498:         assert_equal(actual, expected)
  499: 
  500:     def test_timedelta_nat_format(self):
  501:         # gh-17552
  502:         assert_equal('NaT', f'{np.timedelta64("nat")}')
  503: 
  504:     def test_timedelta_scalar_construction_units(self):
  505:         # String construction detecting units
  506:         assert_equal(np.datetime64('2010').dtype,
  507:                      np.dtype('M8[Y]'))
  508:         assert_equal(np.datetime64('2010-03').dtype,
  509:                      np.dtype('M8[M]'))
  510:         assert_equal(np.datetime64('2010-03-12').dtype,
  511:                      np.dtype('M8[D]'))
  512:         assert_equal(np.datetime64('2010-03-12T17').dtype,
  513:                      np.dtype('M8[h]'))
  514:         assert_equal(np.datetime64('2010-03-12T17:15').dtype,
  515:                      np.dtype('M8[m]'))
  516:         assert_equal(np.datetime64('2010-03-12T17:15:08').dtype,
  517:                      np.dtype('M8[s]'))
  518: 
  519:         assert_equal(np.datetime64('2010-03-12T17:15:08.1').dtype,
  520:                      np.dtype('M8[ms]'))
  521:         assert_equal(np.datetime64('2010-03-12T17:15:08.12').dtype,
  522:                      np.dtype('M8[ms]'))
  523:         assert_equal(np.datetime64('2010-03-12T17:15:08.123').dtype,
  524:                      np.dtype('M8[ms]'))
  525: 
  526:         assert_equal(np.datetime64('2010-03-12T17:15:08.1234').dtype,
  527:                      np.dtype('M8[us]'))
  528:         assert_equal(np.datetime64('2010-03-12T17:15:08.12345').dtype,
  529:                      np.dtype('M8[us]'))
  530:         assert_equal(np.datetime64('2010-03-12T17:15:08.123456').dtype,
  531:                      np.dtype('M8[us]'))
  532: 
  533:         assert_equal(np.datetime64('1970-01-01T00:00:02.1234567').dtype,
  534:                      np.dtype('M8[ns]'))
  535:         assert_equal(np.datetime64('1970-01-01T00:00:02.12345678').dtype,
  536:                      np.dtype('M8[ns]'))
  537:         assert_equal(np.datetime64('1970-01-01T00:00:02.123456789').dtype,
  538:                      np.dtype('M8[ns]'))
  539: 
  540:         assert_equal(np.datetime64('1970-01-01T00:00:02.1234567890').dtype,
  541:                      np.dtype('M8[ps]'))
  542:         assert_equal(np.datetime64('1970-01-01T00:00:02.12345678901').dtype,
  543:                      np.dtype('M8[ps]'))
  544:         assert_equal(np.datetime64('1970-01-01T00:00:02.123456789012').dtype,
  545:                      np.dtype('M8[ps]'))
  546: 
  547:         assert_equal(np.datetime64(
  548:                      '1970-01-01T00:00:02.1234567890123').dtype,
  549:                      np.dtype('M8[fs]'))
  550:         assert_equal(np.datetime64(
  551:                      '1970-01-01T00:00:02.12345678901234').dtype,
  552:                      np.dtype('M8[fs]'))
  553:         assert_equal(np.datetime64(
  554:                      '1970-01-01T00:00:02.123456789012345').dtype,
  555:                      np.dtype('M8[fs]'))
  556: 
  557:         assert_equal(np.datetime64(
  558:                     '1970-01-01T00:00:02.1234567890123456').dtype,
  559:                      np.dtype('M8[as]'))
  560:         assert_equal(np.datetime64(
  561:                     '1970-01-01T00:00:02.12345678901234567').dtype,
  562:                      np.dtype('M8[as]'))
  563:         assert_equal(np.datetime64(
  564:                     '1970-01-01T00:00:02.123456789012345678').dtype,
  565:                      np.dtype('M8[as]'))
  566: 
  567:         # Python date object
  568:         assert_equal(np.datetime64(datetime.date(2010, 4, 16)).dtype,
  569:                      np.dtype('M8[D]'))
  570: 
  571:         # Python datetime object
  572:         assert_equal(np.datetime64(
  573:                         datetime.datetime(2010, 4, 16, 13, 45, 18)).dtype,
  574:                      np.dtype('M8[us]'))
  575: 
  576:         # 'today' special value
  577:         assert_equal(np.datetime64('today').dtype,
  578:                      np.dtype('M8[D]'))
  579: 
  580:         # 'now' special value
  581:         assert_equal(np.datetime64('now').dtype,
  582:                      np.dtype('M8[s]'))
  583: 
  584:     def test_datetime_nat_casting(self):
  585:         a = np.array('NaT', dtype='M8[D]')
  586:         b = np.datetime64('NaT', '[D]')
  587: 
  588:         # Arrays
  589:         assert_equal(a.astype('M8[s]'), np.array('NaT', dtype='M8[s]'))
  590:         assert_equal(a.astype('M8[ms]'), np.array('NaT', dtype='M8[ms]'))
  591:         assert_equal(a.astype('M8[M]'), np.array('NaT', dtype='M8[M]'))
  592:         assert_equal(a.astype('M8[Y]'), np.array('NaT', dtype='M8[Y]'))
  593:         assert_equal(a.astype('M8[W]'), np.array('NaT', dtype='M8[W]'))
  594: 
  595:         # Scalars -> Scalars
  596:         assert_equal(np.datetime64(b, '[s]'), np.datetime64('NaT', '[s]'))
  597:         assert_equal(np.datetime64(b, '[ms]'), np.datetime64('NaT', '[ms]'))
  598:         assert_equal(np.datetime64(b, '[M]'), np.datetime64('NaT', '[M]'))
  599:         assert_equal(np.datetime64(b, '[Y]'), np.datetime64('NaT', '[Y]'))
  600:         assert_equal(np.datetime64(b, '[W]'), np.datetime64('NaT', '[W]'))
  601: 
  602:         # Arrays -> Scalars
  603:         assert_equal(np.datetime64(a, '[s]'), np.datetime64('NaT', '[s]'))
  604:         assert_equal(np.datetime64(a, '[ms]'), np.datetime64('NaT', '[ms]'))
  605:         assert_equal(np.datetime64(a, '[M]'), np.datetime64('NaT', '[M]'))
  606:         assert_equal(np.datetime64(a, '[Y]'), np.datetime64('NaT', '[Y]'))
  607:         assert_equal(np.datetime64(a, '[W]'), np.datetime64('NaT', '[W]'))
  608: 
  609:         # NaN -> NaT
  610:         nan = np.array([np.nan] * 8 + [0])
  611:         fnan = nan.astype('f')
  612:         lnan = nan.astype('g')
  613:         cnan = nan.astype('D')
  614:         cfnan = nan.astype('F')
  615:         clnan = nan.astype('G')
  616:         hnan = nan.astype(np.half)
  617: 
  618:         nat = np.array([np.datetime64('NaT')] * 8 + [np.datetime64(0, 'D')])
  619:         assert_equal(nan.astype('M8[ns]'), nat)
  620:         assert_equal(fnan.astype('M8[ns]'), nat)
  621:         assert_equal(lnan.astype('M8[ns]'), nat)
  622:         assert_equal(cnan.astype('M8[ns]'), nat)
  623:         assert_equal(cfnan.astype('M8[ns]'), nat)
  624:         assert_equal(clnan.astype('M8[ns]'), nat)
  625:         assert_equal(hnan.astype('M8[ns]'), nat)
  626: 
  627:         nat = np.array([np.timedelta64('NaT')] * 8 + [np.timedelta64(0)])
  628:         assert_equal(nan.astype('timedelta64[ns]'), nat)
  629:         assert_equal(fnan.astype('timedelta64[ns]'), nat)
  630:         assert_equal(lnan.astype('timedelta64[ns]'), nat)
  631:         assert_equal(cnan.astype('timedelta64[ns]'), nat)
  632:         assert_equal(cfnan.astype('timedelta64[ns]'), nat)
  633:         assert_equal(clnan.astype('timedelta64[ns]'), nat)
  634:         assert_equal(hnan.astype('timedelta64[ns]'), nat)
  635: 
  636:     def test_days_creation(self):
  637:         assert_equal(np.array('1599', dtype='M8[D]').astype('i8'),
  638:                 (1600 - 1970) * 365 - (1972 - 1600) / 4 + 3 - 365)
  639:         assert_equal(np.array('1600', dtype='M8[D]').astype('i8'),
  640:                 (1600 - 1970) * 365 - (1972 - 1600) / 4 + 3)
  641:         assert_equal(np.array('1601', dtype='M8[D]').astype('i8'),
  642:                 (1600 - 1970) * 365 - (1972 - 1600) / 4 + 3 + 366)
  643:         assert_equal(np.array('1900', dtype='M8[D]').astype('i8'),
  644:                 (1900 - 1970) * 365 - (1970 - 1900) // 4)
  645:         assert_equal(np.array('1901', dtype='M8[D]').astype('i8'),
  646:                 (1900 - 1970) * 365 - (1970 - 1900) // 4 + 365)
  647:         assert_equal(np.array('1967', dtype='M8[D]').astype('i8'), -3 * 365 - 1)
  648:         assert_equal(np.array('1968', dtype='M8[D]').astype('i8'), -2 * 365 - 1)
  649:         assert_equal(np.array('1969', dtype='M8[D]').astype('i8'), -1 * 365)
  650:         assert_equal(np.array('1970', dtype='M8[D]').astype('i8'), 0 * 365)
  651:         assert_equal(np.array('1971', dtype='M8[D]').astype('i8'), 1 * 365)
  652:         assert_equal(np.array('1972', dtype='M8[D]').astype('i8'), 2 * 365)
  653:         assert_equal(np.array('1973', dtype='M8[D]').astype('i8'), 3 * 365 + 1)
  654:         assert_equal(np.array('1974', dtype='M8[D]').astype('i8'), 4 * 365 + 1)
  655:         assert_equal(np.array('2000', dtype='M8[D]').astype('i8'),
  656:                  (2000 - 1970) * 365 + (2000 - 1972) // 4)
  657:         assert_equal(np.array('2001', dtype='M8[D]').astype('i8'),
  658:                  (2000 - 1970) * 365 + (2000 - 1972) // 4 + 366)
  659:         assert_equal(np.array('2400', dtype='M8[D]').astype('i8'),
  660:                  (2400 - 1970) * 365 + (2400 - 1972) // 4 - 3)
  661:         assert_equal(np.array('2401', dtype='M8[D]').astype('i8'),
  662:                  (2400 - 1970) * 365 + (2400 - 1972) // 4 - 3 + 366)
  663: 
  664:         assert_equal(np.array('1600-02-29', dtype='M8[D]').astype('i8'),
  665:                 (1600 - 1970) * 365 - (1972 - 1600) // 4 + 3 + 31 + 28)
  666:         assert_equal(np.array('1600-03-01', dtype='M8[D]').astype('i8'),
  667:                 (1600 - 1970) * 365 - (1972 - 1600) // 4 + 3 + 31 + 29)
  668:         assert_equal(np.array('2000-02-29', dtype='M8[D]').astype('i8'),
  669:                  (2000 - 1970) * 365 + (2000 - 1972) // 4 + 31 + 28)
  670:         assert_equal(np.array('2000-03-01', dtype='M8[D]').astype('i8'),
  671:                  (2000 - 1970) * 365 + (2000 - 1972) // 4 + 31 + 29)
  672:         assert_equal(np.array('2001-03-22', dtype='M8[D]').astype('i8'),
  673:                  (2000 - 1970) * 365 + (2000 - 1972) // 4 + 366 + 31 + 28 + 21)
  674: 
  675:     def test_days_to_pydate(self):
  676:         assert_equal(np.array('1599', dtype='M8[D]').astype('O'),
  677:                     datetime.date(1599, 1, 1))
  678:         assert_equal(np.array('1600', dtype='M8[D]').astype('O'),
  679:                     datetime.date(1600, 1, 1))
  680:         assert_equal(np.array('1601', dtype='M8[D]').astype('O'),
  681:                     datetime.date(1601, 1, 1))
  682:         assert_equal(np.array('1900', dtype='M8[D]').astype('O'),
  683:                     datetime.date(1900, 1, 1))
  684:         assert_equal(np.array('1901', dtype='M8[D]').astype('O'),
  685:                     datetime.date(1901, 1, 1))
  686:         assert_equal(np.array('2000', dtype='M8[D]').astype('O'),
  687:                     datetime.date(2000, 1, 1))
  688:         assert_equal(np.array('2001', dtype='M8[D]').astype('O'),
  689:                     datetime.date(2001, 1, 1))
  690:         assert_equal(np.array('1600-02-29', dtype='M8[D]').astype('O'),
  691:                     datetime.date(1600, 2, 29))
  692:         assert_equal(np.array('1600-03-01', dtype='M8[D]').astype('O'),
  693:                     datetime.date(1600, 3, 1))
  694:         assert_equal(np.array('2001-03-22', dtype='M8[D]').astype('O'),
  695:                     datetime.date(2001, 3, 22))
  696: 
  697:     def test_dtype_comparison(self):
  698:         assert_(not (np.dtype('M8[us]') == np.dtype('M8[ms]')))
  699:         assert_(np.dtype('M8[us]') != np.dtype('M8[ms]'))
  700:         assert_(np.dtype('M8[2D]') != np.dtype('M8[D]'))
  701:         assert_(np.dtype('M8[D]') != np.dtype('M8[2D]'))
  702: 
  703:     def test_pydatetime_creation(self):
  704:         a = np.array(['1960-03-12', datetime.date(1960, 3, 12)], dtype='M8[D]')
  705:         assert_equal(a[0], a[1])
  706:         a = np.array(['1999-12-31', datetime.date(1999, 12, 31)], dtype='M8[D]')
  707:         assert_equal(a[0], a[1])
  708:         a = np.array(['2000-01-01', datetime.date(2000, 1, 1)], dtype='M8[D]')
  709:         assert_equal(a[0], a[1])
  710:         # Will fail if the date changes during the exact right moment
  711:         a = np.array(['today', datetime.date.today()], dtype='M8[D]')
  712:         assert_equal(a[0], a[1])
  713:         # datetime.datetime.now() returns local time, not UTC
  714:         #a = np.array(['now', datetime.datetime.now()], dtype='M8[s]')
  715:         #assert_equal(a[0], a[1])
  716: 
  717:         # we can give a datetime.date time units
  718:         assert_equal(np.array(datetime.date(1960, 3, 12), dtype='M8[s]'),
  719:                      np.array(np.datetime64('1960-03-12T00:00:00')))
  720: 
  721:     def test_datetime_string_conversion(self):
  722:         a = ['2011-03-16', '1920-01-01', '2013-05-19']
  723:         str_a = np.array(a, dtype='S')
  724:         uni_a = np.array(a, dtype='U')
  725:         dt_a = np.array(a, dtype='M')
  726: 
  727:         # String to datetime
  728:         assert_equal(dt_a, str_a.astype('M'))
  729:         assert_equal(dt_a.dtype, str_a.astype('M').dtype)
  730:         dt_b = np.empty_like(dt_a)
  731:         dt_b[...] = str_a
  732:         assert_equal(dt_a, dt_b)
  733: 
  734:         # Datetime to string
  735:         assert_equal(str_a, dt_a.astype('S0'))
  736:         str_b = np.empty_like(str_a)
  737:         str_b[...] = dt_a
  738:         assert_equal(str_a, str_b)
  739: 
  740:         # Unicode to datetime
  741:         assert_equal(dt_a, uni_a.astype('M'))
  742:         assert_equal(dt_a.dtype, uni_a.astype('M').dtype)
  743:         dt_b = np.empty_like(dt_a)
  744:         dt_b[...] = uni_a
  745:         assert_equal(dt_a, dt_b)
  746: 
  747:         # Datetime to unicode
  748:         assert_equal(uni_a, dt_a.astype('U'))
  749:         uni_b = np.empty_like(uni_a)
  750:         uni_b[...] = dt_a
  751:         assert_equal(uni_a, uni_b)
  752: 
  753:         # Datetime to long string - gh-9712
  754:         assert_equal(str_a, dt_a.astype((np.bytes_, 128)))
  755:         str_b = np.empty(str_a.shape, dtype=(np.bytes_, 128))
  756:         str_b[...] = dt_a
  757:         assert_equal(str_a, str_b)
  758: 
  759:     @pytest.mark.parametrize("time_dtype", ["m8[D]", "M8[Y]"])
  760:     def test_time_byteswapping(self, time_dtype):
  761:         times = np.array(["2017", "NaT"], dtype=time_dtype)
  762:         times_swapped = times.astype(times.dtype.newbyteorder())
  763:         assert_array_equal(times, times_swapped)
  764: 
  765:         unswapped = times_swapped.view(np.dtype("int64").newbyteorder())
  766:         assert_array_equal(unswapped, times.view(np.int64))
  767: 
  768:     @pytest.mark.parametrize(["time1", "time2"],
  769:             [("M8[s]", "M8[D]"), ("m8[s]", "m8[ns]")])
  770:     def test_time_byteswapped_cast(self, time1, time2):
  771:         dtype1 = np.dtype(time1)
  772:         dtype2 = np.dtype(time2)
  773:         times = np.array(["2017", "NaT"], dtype=dtype1)
  774:         expected = times.astype(dtype2)
  775: 
  776:         # Test that every byte-swapping combination also returns the same
  777:         # results (previous tests check that this comparison works fine).
  778:         res = times.astype(dtype1.newbyteorder()).astype(dtype2)
  779:         assert_array_equal(res, expected)
  780:         res = times.astype(dtype2.newbyteorder())
  781:         assert_array_equal(res, expected)
  782:         res = times.astype(dtype1.newbyteorder()).astype(dtype2.newbyteorder())
  783:         assert_array_equal(res, expected)
  784: 
  785:     @pytest.mark.parametrize("time_dtype", ["m8[D]", "M8[Y]"])
  786:     @pytest.mark.parametrize("str_dtype", ["U", "S"])
  787:     def test_datetime_conversions_byteorders(self, str_dtype, time_dtype):
  788:         times = np.array(["2017", "NaT"], dtype=time_dtype)
  789:         # Unfortunately, timedelta does not roundtrip:
  790:         from_strings = np.array(["2017", "NaT"], dtype=str_dtype)
  791:         to_strings = times.astype(str_dtype)  # assume this is correct
  792: 
  793:         # Check that conversion from times to string works if src is swapped:
  794:         times_swapped = times.astype(times.dtype.newbyteorder())
  795:         res = times_swapped.astype(str_dtype)
  796:         assert_array_equal(res, to_strings)
  797:         # And also if both are swapped:
  798:         res = times_swapped.astype(to_strings.dtype.newbyteorder())
  799:         assert_array_equal(res, to_strings)
  800:         # only destination is swapped:
  801:         res = times.astype(to_strings.dtype.newbyteorder())
  802:         assert_array_equal(res, to_strings)
  803: 
  804:         # Check that conversion from string to times works if src is swapped:
  805:         from_strings_swapped = from_strings.astype(
  806:                 from_strings.dtype.newbyteorder())
  807:         res = from_strings_swapped.astype(time_dtype)
  808:         assert_array_equal(res, times)
  809:         # And if both are swapped:
  810:         res = from_strings_swapped.astype(times.dtype.newbyteorder())
  811:         assert_array_equal(res, times)
  812:         # Only destination is swapped:
  813:         res = from_strings.astype(times.dtype.newbyteorder())
  814:         assert_array_equal(res, times)
  815: 
  816:     def test_datetime_array_str(self):
  817:         a = np.array(['2011-03-16', '1920-01-01', '2013-05-19'], dtype='M')
  818:         assert_equal(str(a), "['2011-03-16' '1920-01-01' '2013-05-19']")
  819: 
  820:         a = np.array(['2011-03-16T13:55', '1920-01-01T03:12'], dtype='M')
  821:         assert_equal(np.array2string(a, separator=', ',
  822:                     formatter={'datetime': lambda x:
  823:                             f"'{np.datetime_as_string(x, timezone='UTC')}'"}),
  824:                      "['2011-03-16T13:55Z', '1920-01-01T03:12Z']")
  825: 
  826:         # Check that one NaT doesn't corrupt subsequent entries
  827:         a = np.array(['2010', 'NaT', '2030']).astype('M')
  828:         assert_equal(str(a), "['2010'  'NaT' '2030']")
  829: 
  830:     def test_timedelta_array_str(self):
  831:         a = np.array([-1, 0, 100], dtype='m')
  832:         assert_equal(str(a), "[ -1   0 100]")
  833:         a = np.array(['NaT', 'NaT'], dtype='m')
  834:         assert_equal(str(a), "['NaT' 'NaT']")
  835:         # Check right-alignment with NaTs
  836:         a = np.array([-1, 'NaT', 0], dtype='m')
  837:         assert_equal(str(a), "[   -1 'NaT'     0]")
  838:         a = np.array([-1, 'NaT', 1234567], dtype='m')
  839:         assert_equal(str(a), "[     -1   'NaT' 1234567]")
  840: 
  841:         # Test with other byteorder:
  842:         a = np.array([-1, 'NaT', 1234567], dtype='>m')
  843:         assert_equal(str(a), "[     -1   'NaT' 1234567]")
  844:         a = np.array([-1, 'NaT', 1234567], dtype='<m')
  845:         assert_equal(str(a), "[     -1   'NaT' 1234567]")
  846: 
  847:     def test_pickle(self):
  848:         # Check that pickle roundtripping works
  849:         for proto in range(2, pickle.HIGHEST_PROTOCOL + 1):
  850:             dt = np.dtype('M8[7D]')
  851:             assert_equal(pickle.loads(pickle.dumps(dt, protocol=proto)), dt)
  852:             dt = np.dtype('M8[W]')
  853:             assert_equal(pickle.loads(pickle.dumps(dt, protocol=proto)), dt)
  854:             scalar = np.datetime64('2016-01-01T00:00:00.000000000')
  855:             assert_equal(pickle.loads(pickle.dumps(scalar, protocol=proto)),
  856:                          scalar)
  857:             delta = scalar - np.datetime64('2015-01-01T00:00:00.000000000')
  858:             assert_equal(pickle.loads(pickle.dumps(delta, protocol=proto)),
  859:                          delta)
  860: 
  861:         # Check that loading pickles from 1.6 works
  862:         pkl = b"cnumpy\ndtype\np0\n(S'M8'\np1\nI0\nI1\ntp2\nRp3\n"\
  863:               b"(I4\nS'<'\np4\nNNNI-1\nI-1\nI0\n((dp5\n(S'D'\np6\n"\
  864:               b"I7\nI1\nI1\ntp7\ntp8\ntp9\nb."
  865:         assert_equal(pickle.loads(pkl), np.dtype('<M8[7D]'))
  866:         pkl = b"cnumpy\ndtype\np0\n(S'M8'\np1\nI0\nI1\ntp2\nRp3\n"\
  867:               b"(I4\nS'<'\np4\nNNNI-1\nI-1\nI0\n((dp5\n(S'W'\np6\n"\
  868:               b"I1\nI1\nI1\ntp7\ntp8\ntp9\nb."
  869:         assert_equal(pickle.loads(pkl), np.dtype('<M8[W]'))
  870:         pkl = b"cnumpy\ndtype\np0\n(S'M8'\np1\nI0\nI1\ntp2\nRp3\n"\
  871:               b"(I4\nS'>'\np4\nNNNI-1\nI-1\nI0\n((dp5\n(S'us'\np6\n"\
  872:               b"I1\nI1\nI1\ntp7\ntp8\ntp9\nb."
  873:         assert_equal(pickle.loads(pkl), np.dtype('>M8[us]'))
  874: 
  875:     def test_setstate(self):
  876:         "Verify that datetime dtype __setstate__ can handle bad arguments"
  877:         dt = np.dtype('>M8[us]')
  878:         assert_raises(ValueError, dt.__setstate__, (4, '>', None, None, None, -1, -1, 0, 1))
  879:         assert_(dt.__reduce__()[2] == np.dtype('>M8[us]').__reduce__()[2])
  880:         assert_raises(TypeError, dt.__setstate__, (4, '>', None, None, None, -1, -1, 0, ({}, 'xxx')))
  881:         assert_(dt.__reduce__()[2] == np.dtype('>M8[us]').__reduce__()[2])
  882: 
  883:     def test_dtype_promotion(self):
  884:         # datetime <op> datetime computes the metadata gcd
  885:         # timedelta <op> timedelta computes the metadata gcd
  886:         for mM in ['m', 'M']:
  887:             assert_equal(
  888:                 np.promote_types(np.dtype(mM + '8[2Y]'), np.dtype(mM + '8[2Y]')),
  889:                 np.dtype(mM + '8[2Y]'))
  890:             assert_equal(
  891:                 np.promote_types(np.dtype(mM + '8[12Y]'), np.dtype(mM + '8[15Y]')),
  892:                 np.dtype(mM + '8[3Y]'))
  893:             assert_equal(
  894:                 np.promote_types(np.dtype(mM + '8[62M]'), np.dtype(mM + '8[24M]')),
  895:                 np.dtype(mM + '8[2M]'))
  896:             assert_equal(
  897:                 np.promote_types(np.dtype(mM + '8[1W]'), np.dtype(mM + '8[2D]')),
  898:                 np.dtype(mM + '8[1D]'))
  899:             assert_equal(
  900:                 np.promote_types(np.dtype(mM + '8[W]'), np.dtype(mM + '8[13s]')),
  901:                 np.dtype(mM + '8[s]'))
  902:             assert_equal(
  903:                 np.promote_types(np.dtype(mM + '8[13W]'), np.dtype(mM + '8[49s]')),
  904:                 np.dtype(mM + '8[7s]'))
  905:         # timedelta <op> timedelta raises when there is no reasonable gcd
  906:         assert_raises(TypeError, np.promote_types,
  907:                             np.dtype('m8[Y]'), np.dtype('m8[D]'))
  908:         assert_raises(TypeError, np.promote_types,
  909:                             np.dtype('m8[M]'), np.dtype('m8[W]'))
  910:         # timedelta and float cannot be safely cast with each other
  911:         assert_raises(TypeError, np.promote_types, "float32", "m8")
  912:         assert_raises(TypeError, np.promote_types, "m8", "float32")
  913:         assert_raises(TypeError, np.promote_types, "uint64", "m8")
  914:         assert_raises(TypeError, np.promote_types, "m8", "uint64")
  915: 
  916:         # timedelta <op> timedelta may overflow with big unit ranges
  917:         assert_raises(OverflowError, np.promote_types,
  918:                             np.dtype('m8[W]'), np.dtype('m8[fs]'))
  919:         assert_raises(OverflowError, np.promote_types,
  920:                             np.dtype('m8[s]'), np.dtype('m8[as]'))
  921: 
  922:     def test_cast_overflow(self):
  923:         # gh-4486
  924:         def cast():
  925:             numpy.datetime64("1971-01-01 00:00:00.000000000000000").astype("<M8[D]")
  926:         assert_raises(OverflowError, cast)
  927: 
  928:         def cast2():
  929:             numpy.datetime64("2014").astype("<M8[fs]")
  930:         assert_raises(OverflowError, cast2)
  931: 
  932:     def test_pyobject_roundtrip(self):
  933:         # All datetime types should be able to roundtrip through object
  934:         a = np.array([0, 0, 0, 0, 0, 0, 0, 0, 0,
  935:                       -1020040340, -2942398, -1, 0, 1, 234523453, 1199164176],
  936:                                                         dtype=np.int64)
  937:         # With date units
  938:         for unit in ['M8[D]', 'M8[W]', 'M8[M]', 'M8[Y]']:
  939:             b = a.copy().view(dtype=unit)
  940:             b[0] = '-0001-01-01'
  941:             b[1] = '-0001-12-31'
  942:             b[2] = '0000-01-01'
  943:             b[3] = '0001-01-01'
  944:             b[4] = '1969-12-31'
  945:             b[5] = '1970-01-01'
  946:             b[6] = '9999-12-31'
  947:             b[7] = '10000-01-01'
  948:             b[8] = 'NaT'
  949: 
  950:             assert_equal(b.astype(object).astype(unit), b,
  951:                             f"Error roundtripping unit {unit}")
  952:         # With time units
  953:         for unit in ['M8[as]', 'M8[16fs]', 'M8[ps]', 'M8[us]',
  954:                      'M8[300as]', 'M8[20us]']:
  955:             b = a.copy().view(dtype=unit)
  956:             b[0] = '-0001-01-01T00'
  957:             b[1] = '-0001-12-31T00'
  958:             b[2] = '0000-01-01T00'
  959:             b[3] = '0001-01-01T00'
  960:             b[4] = '1969-12-31T23:59:59.999999'
  961:             b[5] = '1970-01-01T00'
  962:             b[6] = '9999-12-31T23:59:59.999999'
  963:             b[7] = '10000-01-01T00'
  964:             b[8] = 'NaT'
  965: 
  966:             assert_equal(b.astype(object).astype(unit), b,
  967:                             f"Error roundtripping unit {unit}")
  968: 
  969:     def test_month_truncation(self):
  970:         # Make sure that months are truncating correctly
  971:         assert_equal(np.array('1945-03-01', dtype='M8[M]'),
  972:                      np.array('1945-03-31', dtype='M8[M]'))
  973:         assert_equal(np.array('1969-11-01', dtype='M8[M]'),
  974:              np.array('1969-11-30T23:59:59.99999', dtype='M').astype('M8[M]'))
  975:         assert_equal(np.array('1969-12-01', dtype='M8[M]'),
  976:              np.array('1969-12-31T23:59:59.99999', dtype='M').astype('M8[M]'))
  977:         assert_equal(np.array('1970-01-01', dtype='M8[M]'),
  978:              np.array('1970-01-31T23:59:59.99999', dtype='M').astype('M8[M]'))
  979:         assert_equal(np.array('1980-02-01', dtype='M8[M]'),
  980:              np.array('1980-02-29T23:59:59.99999', dtype='M').astype('M8[M]'))
  981: 
  982:     def test_different_unit_comparison(self):
  983:         # Check some years with date units
  984:         for unit1 in ['Y', 'M', 'D']:
  985:             dt1 = np.dtype(f'M8[{unit1}]')
  986:             for unit2 in ['Y', 'M', 'D']:
  987:                 dt2 = np.dtype(f'M8[{unit2}]')
  988:                 assert_equal(np.array('1945', dtype=dt1),
  989:                              np.array('1945', dtype=dt2))
  990:                 assert_equal(np.array('1970', dtype=dt1),
  991:                              np.array('1970', dtype=dt2))
  992:                 assert_equal(np.array('9999', dtype=dt1),
  993:                              np.array('9999', dtype=dt2))
  994:                 assert_equal(np.array('10000', dtype=dt1),
  995:                              np.array('10000-01-01', dtype=dt2))
  996:                 assert_equal(np.datetime64('1945', unit1),
  997:                              np.datetime64('1945', unit2))
  998:                 assert_equal(np.datetime64('1970', unit1),
  999:                              np.datetime64('1970', unit2))
 1000:                 assert_equal(np.datetime64('9999', unit1),
 1001:                              np.datetime64('9999', unit2))
 1002:                 assert_equal(np.datetime64('10000', unit1),
 1003:                              np.datetime64('10000-01-01', unit2))
 1004:         # Check some datetimes with time units
 1005:         for unit1 in ['6h', 'h', 'm', 's', '10ms', 'ms', 'us']:
 1006:             dt1 = np.dtype(f'M8[{unit1}]')
 1007:             for unit2 in ['h', 'm', 's', 'ms', 'us']:
 1008:                 dt2 = np.dtype(f'M8[{unit2}]')
 1009:                 assert_equal(np.array('1945-03-12T18', dtype=dt1),
 1010:                              np.array('1945-03-12T18', dtype=dt2))
 1011:                 assert_equal(np.array('1970-03-12T18', dtype=dt1),
 1012:                              np.array('1970-03-12T18', dtype=dt2))
 1013:                 assert_equal(np.array('9999-03-12T18', dtype=dt1),
 1014:                              np.array('9999-03-12T18', dtype=dt2))
 1015:                 assert_equal(np.array('10000-01-01T00', dtype=dt1),
 1016:                              np.array('10000-01-01T00', dtype=dt2))
 1017:                 assert_equal(np.datetime64('1945-03-12T18', unit1),
 1018:                              np.datetime64('1945-03-12T18', unit2))
 1019:                 assert_equal(np.datetime64('1970-03-12T18', unit1),
 1020:                              np.datetime64('1970-03-12T18', unit2))
 1021:                 assert_equal(np.datetime64('9999-03-12T18', unit1),
 1022:                              np.datetime64('9999-03-12T18', unit2))
 1023:                 assert_equal(np.datetime64('10000-01-01T00', unit1),
 1024:                              np.datetime64('10000-01-01T00', unit2))
 1025:         # Check some days with units that won't overflow
 1026:         for unit1 in ['D', '12h', 'h', 'm', 's', '4s', 'ms', 'us']:
 1027:             dt1 = np.dtype(f'M8[{unit1}]')
 1028:             for unit2 in ['D', 'h', 'm', 's', 'ms', 'us']:
 1029:                 dt2 = np.dtype(f'M8[{unit2}]')
 1030:                 assert_(np.equal(np.array('1932-02-17', dtype='M').astype(dt1),
 1031:                      np.array('1932-02-17T00:00:00', dtype='M').astype(dt2),
 1032:                      casting='unsafe'))
 1033:                 assert_(np.equal(np.array('10000-04-27', dtype='M').astype(dt1),
 1034:                      np.array('10000-04-27T00:00:00', dtype='M').astype(dt2),
 1035:                      casting='unsafe'))
 1036: 
 1037:         # Shouldn't be able to compare datetime and timedelta
 1038:         a = np.array('2012-12-21', dtype='M8[D]')
 1039:         b = np.array(3, dtype='m8[D]')
 1040:         assert_raises(TypeError, np.less, a, b)
 1041:         # not even if "unsafe"
 1042:         assert_raises(TypeError, np.less, a, b, casting='unsafe')
 1043: 
 1044:     def test_datetime_like(self):
 1045:         a = np.array([3], dtype='m8[4D]')
 1046:         b = np.array(['2012-12-21'], dtype='M8[D]')
 1047: 
 1048:         assert_equal(np.ones_like(a).dtype, a.dtype)
 1049:         assert_equal(np.zeros_like(a).dtype, a.dtype)
 1050:         assert_equal(np.empty_like(a).dtype, a.dtype)
 1051:         assert_equal(np.ones_like(b).dtype, b.dtype)
 1052:         assert_equal(np.zeros_like(b).dtype, b.dtype)
 1053:         assert_equal(np.empty_like(b).dtype, b.dtype)
 1054: 
 1055:     def test_datetime_unary(self):
 1056:         for tda, tdb, tdzero, tdone, tdmone in \
 1057:                 [
 1058:                  # One-dimensional arrays
 1059:                  (np.array([3], dtype='m8[D]'),
 1060:                   np.array([-3], dtype='m8[D]'),
 1061:                   np.array([0], dtype='m8[D]'),
 1062:                   np.array([1], dtype='m8[D]'),
 1063:                   np.array([-1], dtype='m8[D]')),
 1064:                  # NumPy scalars
 1065:                  (np.timedelta64(3, '[D]'),
 1066:                   np.timedelta64(-3, '[D]'),
 1067:                   np.timedelta64(0, '[D]'),
 1068:                   np.timedelta64(1, '[D]'),
 1069:                   np.timedelta64(-1, '[D]'))]:
 1070:             # negative ufunc
 1071:             assert_equal(-tdb, tda)
 1072:             assert_equal((-tdb).dtype, tda.dtype)
 1073:             assert_equal(np.negative(tdb), tda)
 1074:             assert_equal(np.negative(tdb).dtype, tda.dtype)
 1075: 
 1076:             # positive ufunc
 1077:             assert_equal(np.positive(tda), tda)
 1078:             assert_equal(np.positive(tda).dtype, tda.dtype)
 1079:             assert_equal(np.positive(tdb), tdb)
 1080:             assert_equal(np.positive(tdb).dtype, tdb.dtype)
 1081: 
 1082:             # absolute ufunc
 1083:             assert_equal(np.absolute(tdb), tda)
 1084:             assert_equal(np.absolute(tdb).dtype, tda.dtype)
 1085: 
 1086:             # sign ufunc
 1087:             assert_equal(np.sign(tda), tdone)
 1088:             assert_equal(np.sign(tdb), tdmone)
 1089:             assert_equal(np.sign(tdzero), tdzero)
 1090:             assert_equal(np.sign(tda).dtype, tda.dtype)
 1091: 
 1092:             # The ufuncs always produce native-endian results
 1093:             assert_
 1094: 
 1095:     def test_datetime_add(self):
 1096:         for dta, dtb, dtc, dtnat, tda, tdb, tdc in \
 1097:                     [
 1098:                      # One-dimensional arrays
 1099:                      (np.array(['2012-12-21'], dtype='M8[D]'),
 1100:                       np.array(['2012-12-24'], dtype='M8[D]'),
 1101:                       np.array(['2012-12-21T11'], dtype='M8[h]'),
 1102:                       np.array(['NaT'], dtype='M8[D]'),
 1103:                       np.array([3], dtype='m8[D]'),
 1104:                       np.array([11], dtype='m8[h]'),
 1105:                       np.array([3 * 24 + 11], dtype='m8[h]')),
 1106:                      # NumPy scalars
 1107:                      (np.datetime64('2012-12-21', '[D]'),
 1108:                       np.datetime64('2012-12-24', '[D]'),
 1109:                       np.datetime64('2012-12-21T11', '[h]'),
 1110:                       np.datetime64('NaT', '[D]'),
 1111:                       np.timedelta64(3, '[D]'),
 1112:                       np.timedelta64(11, '[h]'),
 1113:                       np.timedelta64(3 * 24 + 11, '[h]'))]:
 1114:             # m8 + m8
 1115:             assert_equal(tda + tdb, tdc)
 1116:             assert_equal((tda + tdb).dtype, np.dtype('m8[h]'))
 1117:             # m8 + bool
 1118:             assert_equal(tdb + True, tdb + 1)
 1119:             assert_equal((tdb + True).dtype, np.dtype('m8[h]'))
 1120:             # m8 + int
 1121:             assert_equal(tdb + 3 * 24, tdc)
 1122:             assert_equal((tdb + 3 * 24).dtype, np.dtype('m8[h]'))
 1123:             # bool + m8
 1124:             assert_equal(False + tdb, tdb)
 1125:             assert_equal((False + tdb).dtype, np.dtype('m8[h]'))
 1126:             # int + m8
 1127:             assert_equal(3 * 24 + tdb, tdc)
 1128:             assert_equal((3 * 24 + tdb).dtype, np.dtype('m8[h]'))
 1129:             # M8 + bool
 1130:             assert_equal(dta + True, dta + 1)
 1131:             assert_equal(dtnat + True, dtnat)
 1132:             assert_equal((dta + True).dtype, np.dtype('M8[D]'))
 1133:             # M8 + int
 1134:             assert_equal(dta + 3, dtb)
 1135:             assert_equal(dtnat + 3, dtnat)
 1136:             assert_equal((dta + 3).dtype, np.dtype('M8[D]'))
 1137:             # bool + M8
 1138:             assert_equal(False + dta, dta)
 1139:             assert_equal(False + dtnat, dtnat)
 1140:             assert_equal((False + dta).dtype, np.dtype('M8[D]'))
 1141:             # int + M8
 1142:             assert_equal(3 + dta, dtb)
 1143:             assert_equal(3 + dtnat, dtnat)
 1144:             assert_equal((3 + dta).dtype, np.dtype('M8[D]'))
 1145:             # M8 + m8
 1146:             assert_equal(dta + tda, dtb)
 1147:             assert_equal(dtnat + tda, dtnat)
 1148:             assert_equal((dta + tda).dtype, np.dtype('M8[D]'))
 1149:             # m8 + M8
 1150:             assert_equal(tda + dta, dtb)
 1151:             assert_equal(tda + dtnat, dtnat)
 1152:             assert_equal((tda + dta).dtype, np.dtype('M8[D]'))
 1153: 
 1154:             # In M8 + m8, the result goes to higher precision
 1155:             assert_equal(np.add(dta, tdb, casting='unsafe'), dtc)
 1156:             assert_equal(np.add(dta, tdb, casting='unsafe').dtype,
 1157:                          np.dtype('M8[h]'))
 1158:             assert_equal(np.add(tdb, dta, casting='unsafe'), dtc)
 1159:             assert_equal(np.add(tdb, dta, casting='unsafe').dtype,
 1160:                          np.dtype('M8[h]'))
 1161: 
 1162:             # M8 + M8
 1163:             assert_raises(TypeError, np.add, dta, dtb)
 1164: 
 1165:     def test_datetime_subtract(self):
 1166:         for dta, dtb, dtc, dtd, dte, dtnat, tda, tdb, tdc in \
 1167:                     [
 1168:                      # One-dimensional arrays
 1169:                      (np.array(['2012-12-21'], dtype='M8[D]'),
 1170:                       np.array(['2012-12-24'], dtype='M8[D]'),
 1171:                       np.array(['1940-12-24'], dtype='M8[D]'),
 1172:                       np.array(['1940-12-24T00'], dtype='M8[h]'),
 1173:                       np.array(['1940-12-23T13'], dtype='M8[h]'),
 1174:                       np.array(['NaT'], dtype='M8[D]'),
 1175:                       np.array([3], dtype='m8[D]'),
 1176:                       np.array([11], dtype='m8[h]'),
 1177:                       np.array([3 * 24 - 11], dtype='m8[h]')),
 1178:                      # NumPy scalars
 1179:                      (np.datetime64('2012-12-21', '[D]'),
 1180:                       np.datetime64('2012-12-24', '[D]'),
 1181:                       np.datetime64('1940-12-24', '[D]'),
 1182:                       np.datetime64('1940-12-24T00', '[h]'),
 1183:                       np.datetime64('1940-12-23T13', '[h]'),
 1184:                       np.datetime64('NaT', '[D]'),
 1185:                       np.timedelta64(3, '[D]'),
 1186:                       np.timedelta64(11, '[h]'),
 1187:                       np.timedelta64(3 * 24 - 11, '[h]'))]:
 1188:             # m8 - m8
 1189:             assert_equal(tda - tdb, tdc)
 1190:             assert_equal((tda - tdb).dtype, np.dtype('m8[h]'))
 1191:             assert_equal(tdb - tda, -tdc)
 1192:             assert_equal((tdb - tda).dtype, np.dtype('m8[h]'))
 1193:             # m8 - bool
 1194:             assert_equal(tdc - True, tdc - 1)
 1195:             assert_equal((tdc - True).dtype, np.dtype('m8[h]'))
 1196:             # m8 - int
 1197:             assert_equal(tdc - 3 * 24, -tdb)
 1198:             assert_equal((tdc - 3 * 24).dtype, np.dtype('m8[h]'))
 1199:             # int - m8
 1200:             assert_equal(False - tdb, -tdb)
 1201:             assert_equal((False - tdb).dtype, np.dtype('m8[h]'))
 1202:             # int - m8
 1203:             assert_equal(3 * 24 - tdb, tdc)
 1204:             assert_equal((3 * 24 - tdb).dtype, np.dtype('m8[h]'))
 1205:             # M8 - bool
 1206:             assert_equal(dtb - True, dtb - 1)
 1207:             assert_equal(dtnat - True, dtnat)
 1208:             assert_equal((dtb - True).dtype, np.dtype('M8[D]'))
 1209:             # M8 - int
 1210:             assert_equal(dtb - 3, dta)
 1211:             assert_equal(dtnat - 3, dtnat)
 1212:             assert_equal((dtb - 3).dtype, np.dtype('M8[D]'))
 1213:             # M8 - m8
 1214:             assert_equal(dtb - tda, dta)
 1215:             assert_equal(dtnat - tda, dtnat)
 1216:             assert_equal((dtb - tda).dtype, np.dtype('M8[D]'))
 1217: 
 1218:             # In M8 - m8, the result goes to higher precision
 1219:             assert_equal(np.subtract(dtc, tdb, casting='unsafe'), dte)
 1220:             assert_equal(np.subtract(dtc, tdb, casting='unsafe').dtype,
 1221:                          np.dtype('M8[h]'))
 1222: 
 1223:             # M8 - M8 with different goes to higher precision
 1224:             assert_equal(np.subtract(dtc, dtd, casting='unsafe'),
 1225:                          np.timedelta64(0, 'h'))
 1226:             assert_equal(np.subtract(dtc, dtd, casting='unsafe').dtype,
 1227:                          np.dtype('m8[h]'))
 1228:             assert_equal(np.subtract(dtd, dtc, casting='unsafe'),
 1229:                          np.timedelta64(0, 'h'))
 1230:             assert_equal(np.subtract(dtd, dtc, casting='unsafe').dtype,
 1231:                          np.dtype('m8[h]'))
 1232: 
 1233:             # m8 - M8
 1234:             assert_raises(TypeError, np.subtract, tda, dta)
 1235:             # bool - M8
 1236:             assert_raises(TypeError, np.subtract, False, dta)
 1237:             # int - M8
 1238:             assert_raises(TypeError, np.subtract, 3, dta)
 1239: 
 1240:     def test_datetime_multiply(self):
 1241:         for dta, tda, tdb, tdc in \
 1242:                     [
 1243:                      # One-dimensional arrays
 1244:                      (np.array(['2012-12-21'], dtype='M8[D]'),
 1245:                       np.array([6], dtype='m8[h]'),
 1246:                       np.array([9], dtype='m8[h]'),
 1247:                       np.array([12], dtype='m8[h]')),
 1248:                      # NumPy scalars
 1249:                      (np.datetime64('2012-12-21', '[D]'),
 1250:                       np.timedelta64(6, '[h]'),
 1251:                       np.timedelta64(9, '[h]'),
 1252:                       np.timedelta64(12, '[h]'))]:
 1253:             # m8 * int
 1254:             assert_equal(tda * 2, tdc)
 1255:             assert_equal((tda * 2).dtype, np.dtype('m8[h]'))
 1256:             # int * m8
 1257:             assert_equal(2 * tda, tdc)
 1258:             assert_equal((2 * tda).dtype, np.dtype('m8[h]'))
 1259:             # m8 * float
 1260:             assert_equal(tda * 1.5, tdb)
 1261:             assert_equal((tda * 1.5).dtype, np.dtype('m8[h]'))
 1262:             # float * m8
 1263:             assert_equal(1.5 * tda, tdb)
 1264:             assert_equal((1.5 * tda).dtype, np.dtype('m8[h]'))
 1265: 
 1266:             # m8 * m8
 1267:             assert_raises(TypeError, np.multiply, tda, tdb)
 1268:             # m8 * M8
 1269:             assert_raises(TypeError, np.multiply, dta, tda)
 1270:             # M8 * m8
 1271:             assert_raises(TypeError, np.multiply, tda, dta)
 1272:             # M8 * int
 1273:             assert_raises(TypeError, np.multiply, dta, 2)
 1274:             # int * M8
 1275:             assert_raises(TypeError, np.multiply, 2, dta)
 1276:             # M8 * float
 1277:             assert_raises(TypeError, np.multiply, dta, 1.5)
 1278:             # float * M8
 1279:             assert_raises(TypeError, np.multiply, 1.5, dta)
 1280: 
 1281:         # NaTs
 1282:         with suppress_warnings() as sup:
 1283:             sup.filter(RuntimeWarning, "invalid value encountered in multiply")
 1284:             nat = np.timedelta64('NaT')
 1285: 
 1286:             def check(a, b, res):
 1287:                 assert_equal(a * b, res)
 1288:                 assert_equal(b * a, res)
 1289:             for tp in (int, float):
 1290:                 check(nat, tp(2), nat)
 1291:                 check(nat, tp(0), nat)
 1292:             for f in (float('inf'), float('nan')):
 1293:                 check(np.timedelta64(1), f, nat)
 1294:                 check(np.timedelta64(0), f, nat)
 1295:                 check(nat, f, nat)
 1296: 
 1297:     @pytest.mark.parametrize("op1, op2, exp", [
 1298:         # m8 same units round down
 1299:         (np.timedelta64(7, 's'),
 1300:          np.timedelta64(4, 's'),
 1301:          1),
 1302:         # m8 same units round down with negative
 1303:         (np.timedelta64(7, 's'),
 1304:          np.timedelta64(-4, 's'),
 1305:          -2),
 1306:         # m8 same units negative no round down
 1307:         (np.timedelta64(8, 's'),
 1308:          np.timedelta64(-4, 's'),
 1309:          -2),
 1310:         # m8 different units
 1311:         (np.timedelta64(1, 'm'),
 1312:          np.timedelta64(31, 's'),
 1313:          1),
 1314:         # m8 generic units
 1315:         (np.timedelta64(1890),
 1316:          np.timedelta64(31),
 1317:          60),
 1318:         # Y // M works
 1319:         (np.timedelta64(2, 'Y'),
 1320:          np.timedelta64('13', 'M'),
 1321:          1),
 1322:         # handle 1D arrays
 1323:         (np.array([1, 2, 3], dtype='m8'),
 1324:          np.array([2], dtype='m8'),
 1325:          np.array([0, 1, 1], dtype=np.int64)),
 1326:         ])
 1327:     def test_timedelta_floor_divide(self, op1, op2, exp):
 1328:         assert_equal(op1 // op2, exp)
 1329: 
 1330:     @pytest.mark.skipif(IS_WASM, reason="fp errors don't work in wasm")
 1331:     @pytest.mark.parametrize("op1, op2", [
 1332:         # div by 0
 1333:         (np.timedelta64(10, 'us'),
 1334:          np.timedelta64(0, 'us')),
 1335:         # div with NaT
 1336:         (np.timedelta64('NaT'),
 1337:          np.timedelta64(50, 'us')),
 1338:         # special case for int64 min
 1339:         # in integer floor division
 1340:         (np.timedelta64(np.iinfo(np.int64).min),
 1341:          np.timedelta64(-1)),
 1342:         ])
 1343:     def test_timedelta_floor_div_warnings(self, op1, op2):
 1344:         with assert_warns(RuntimeWarning):
 1345:             actual = op1 // op2
 1346:             assert_equal(actual, 0)
 1347:             assert_equal(actual.dtype, np.int64)
 1348: 
 1349:     @pytest.mark.parametrize("val1, val2", [
 1350:         # the smallest integer that can't be represented
 1351:         # exactly in a double should be preserved if we avoid
 1352:         # casting to double in floordiv operation
 1353:         (9007199254740993, 1),
 1354:         # stress the alternate floordiv code path where
 1355:         # operand signs don't match and remainder isn't 0
 1356:         (9007199254740999, -2),
 1357:         ])
 1358:     def test_timedelta_floor_div_precision(self, val1, val2):
 1359:         op1 = np.timedelta64(val1)
 1360:         op2 = np.timedelta64(val2)
 1361:         actual = op1 // op2
 1362:         # Python reference integer floor
 1363:         expected = val1 // val2
 1364:         assert_equal(actual, expected)
 1365: 
 1366:     @pytest.mark.parametrize("val1, val2", [
 1367:         # years and months sometimes can't be unambiguously
 1368:         # divided for floor division operation
 1369:         (np.timedelta64(7, 'Y'),
 1370:          np.timedelta64(3, 's')),
 1371:         (np.timedelta64(7, 'M'),
 1372:          np.timedelta64(1, 'D')),
 1373:         ])
 1374:     def test_timedelta_floor_div_error(self, val1, val2):
 1375:         with assert_raises_regex(TypeError, "common metadata divisor"):
 1376:             val1 // val2
 1377: 
 1378:     @pytest.mark.parametrize("op1, op2", [
 1379:         # reuse the test cases from floordiv
 1380:         (np.timedelta64(7, 's'),
 1381:          np.timedelta64(4, 's')),
 1382:         # m8 same units round down with negative
 1383:         (np.timedelta64(7, 's'),
 1384:          np.timedelta64(-4, 's')),
 1385:         # m8 same units negative no round down
 1386:         (np.timedelta64(8, 's'),
 1387:          np.timedelta64(-4, 's')),
 1388:         # m8 different units
 1389:         (np.timedelta64(1, 'm'),
 1390:          np.timedelta64(31, 's')),
 1391:         # m8 generic units
 1392:         (np.timedelta64(1890),
 1393:          np.timedelta64(31)),
 1394:         # Y // M works
 1395:         (np.timedelta64(2, 'Y'),
 1396:          np.timedelta64('13', 'M')),
 1397:         # handle 1D arrays
 1398:         (np.array([1, 2, 3], dtype='m8'),
 1399:          np.array([2], dtype='m8')),
 1400:         ])
 1401:     def test_timedelta_divmod(self, op1, op2):
 1402:         expected = (op1 // op2, op1 % op2)
 1403:         assert_equal(divmod(op1, op2), expected)
 1404: 
 1405:     @pytest.mark.parametrize("op1, op2", [
 1406:         # Y and M are incompatible with all units except Y and M
 1407:         (np.timedelta64(1, 'Y'), np.timedelta64(1, 's')),
 1408:         (np.timedelta64(1, 'D'), np.timedelta64(1, 'M')),
 1409:         ])
 1410:     def test_timedelta_divmod_typeerror(self, op1, op2):
 1411:         assert_raises(TypeError, np.divmod, op1, op2)
 1412: 
 1413:     @pytest.mark.skipif(IS_WASM, reason="does not work in wasm")
 1414:     @pytest.mark.parametrize("op1, op2", [
 1415:         # reuse cases from floordiv
 1416:         # div by 0
 1417:         (np.timedelta64(10, 'us'),
 1418:          np.timedelta64(0, 'us')),
 1419:         # div with NaT
 1420:         (np.timedelta64('NaT'),
 1421:          np.timedelta64(50, 'us')),
 1422:         # special case for int64 min
 1423:         # in integer floor division
 1424:         (np.timedelta64(np.iinfo(np.int64).min),
 1425:          np.timedelta64(-1)),
 1426:         ])
 1427:     def test_timedelta_divmod_warnings(self, op1, op2):
 1428:         with assert_warns(RuntimeWarning):
 1429:             expected = (op1 // op2, op1 % op2)
 1430:         with assert_warns(RuntimeWarning):
 1431:             actual = divmod(op1, op2)
 1432:         assert_equal(actual, expected)
 1433: 
 1434:     def test_datetime_divide(self):
 1435:         for dta, tda, tdb, tdc, tdd in \
 1436:                     [
 1437:                      # One-dimensional arrays
 1438:                      (np.array(['2012-12-21'], dtype='M8[D]'),
 1439:                       np.array([6], dtype='m8[h]'),
 1440:                       np.array([9], dtype='m8[h]'),
 1441:                       np.array([12], dtype='m8[h]'),
 1442:                       np.array([6], dtype='m8[m]')),
 1443:                      # NumPy scalars
 1444:                      (np.datetime64('2012-12-21', '[D]'),
 1445:                       np.timedelta64(6, '[h]'),
 1446:                       np.timedelta64(9, '[h]'),
 1447:                       np.timedelta64(12, '[h]'),
 1448:                       np.timedelta64(6, '[m]'))]:
 1449:             # m8 / int
 1450:             assert_equal(tdc / 2, tda)
 1451:             assert_equal((tdc / 2).dtype, np.dtype('m8[h]'))
 1452:             # m8 / float
 1453:             assert_equal(tda / 0.5, tdc)
 1454:             assert_equal((tda / 0.5).dtype, np.dtype('m8[h]'))
 1455:             # m8 / m8
 1456:             assert_equal(tda / tdb, 6 / 9)
 1457:             assert_equal(np.divide(tda, tdb), 6 / 9)
 1458:             assert_equal(np.true_divide(tda, tdb), 6 / 9)
 1459:             assert_equal(tdb / tda, 9 / 6)
 1460:             assert_equal((tda / tdb).dtype, np.dtype('f8'))
 1461:             assert_equal(tda / tdd, 60)
 1462:             assert_equal(tdd / tda, 1 / 60)
 1463: 
 1464:             # int / m8
 1465:             assert_raises(TypeError, np.divide, 2, tdb)
 1466:             # float / m8
 1467:             assert_raises(TypeError, np.divide, 0.5, tdb)
 1468:             # m8 / M8
 1469:             assert_raises(TypeError, np.divide, dta, tda)
 1470:             # M8 / m8
 1471:             assert_raises(TypeError, np.divide, tda, dta)
 1472:             # M8 / int
 1473:             assert_raises(TypeError, np.divide, dta, 2)
 1474:             # int / M8
 1475:             assert_raises(TypeError, np.divide, 2, dta)
 1476:             # M8 / float
 1477:             assert_raises(TypeError, np.divide, dta, 1.5)
 1478:             # float / M8
 1479:             assert_raises(TypeError, np.divide, 1.5, dta)
 1480: 
 1481:         # NaTs
 1482:         with suppress_warnings() as sup:
 1483:             sup.filter(RuntimeWarning,  r".*encountered in divide")
 1484:             nat = np.timedelta64('NaT')
 1485:             for tp in (int, float):
 1486:                 assert_equal(np.timedelta64(1) / tp(0), nat)
 1487:                 assert_equal(np.timedelta64(0) / tp(0), nat)
 1488:                 assert_equal(nat / tp(0), nat)
 1489:                 assert_equal(nat / tp(2), nat)
 1490:             # Division by inf
 1491:             assert_equal(np.timedelta64(1) / float('inf'), np.timedelta64(0))
 1492:             assert_equal(np.timedelta64(0) / float('inf'), np.timedelta64(0))
 1493:             assert_equal(nat / float('inf'), nat)
 1494:             # Division by nan
 1495:             assert_equal(np.timedelta64(1) / float('nan'), nat)
 1496:             assert_equal(np.timedelta64(0) / float('nan'), nat)
 1497:             assert_equal(nat / float('nan'), nat)
 1498: 
 1499:     def test_datetime_compare(self):
 1500:         # Test all the comparison operators
 1501:         a = np.datetime64('2000-03-12T18:00:00.000000')
 1502:         b = np.array(['2000-03-12T18:00:00.000000',
 1503:                       '2000-03-12T17:59:59.999999',
 1504:                       '2000-03-12T18:00:00.000001',
 1505:                       '1970-01-11T12:00:00.909090',
 1506:                       '2016-01-11T12:00:00.909090'],
 1507:                       dtype='datetime64[us]')
 1508:         assert_equal(np.equal(a, b), [1, 0, 0, 0, 0])
 1509:         assert_equal(np.not_equal(a, b), [0, 1, 1, 1, 1])
 1510:         assert_equal(np.less(a, b), [0, 0, 1, 0, 1])
 1511:         assert_equal(np.less_equal(a, b), [1, 0, 1, 0, 1])
 1512:         assert_equal(np.greater(a, b), [0, 1, 0, 1, 0])
 1513:         assert_equal(np.greater_equal(a, b), [1, 1, 0, 1, 0])
 1514: 
 1515:     def test_datetime_compare_nat(self):
 1516:         dt_nat = np.datetime64('NaT', 'D')
 1517:         dt_other = np.datetime64('2000-01-01')
 1518:         td_nat = np.timedelta64('NaT', 'h')
 1519:         td_other = np.timedelta64(1, 'h')
 1520: 
 1521:         for op in [np.equal, np.less, np.less_equal,
 1522:                    np.greater, np.greater_equal]:
 1523:             assert_(not op(dt_nat, dt_nat))
 1524:             assert_(not op(dt_nat, dt_other))
 1525:             assert_(not op(dt_other, dt_nat))
 1526: 
 1527:             assert_(not op(td_nat, td_nat))
 1528:             assert_(not op(td_nat, td_other))
 1529:             assert_(not op(td_other, td_nat))
 1530: 
 1531:         assert_(np.not_equal(dt_nat, dt_nat))
 1532:         assert_(np.not_equal(dt_nat, dt_other))
 1533:         assert_(np.not_equal(dt_other, dt_nat))
 1534: 
 1535:         assert_(np.not_equal(td_nat, td_nat))
 1536:         assert_(np.not_equal(td_nat, td_other))
 1537:         assert_(np.not_equal(td_other, td_nat))
 1538: 
 1539:     def test_datetime_minmax(self):
 1540:         # The metadata of the result should become the GCD
 1541:         # of the operand metadata
 1542:         a = np.array('1999-03-12T13', dtype='M8[2m]')
 1543:         b = np.array('1999-03-12T12', dtype='M8[s]')
 1544:         assert_equal(np.minimum(a, b), b)
 1545:         assert_equal(np.minimum(a, b).dtype, np.dtype('M8[s]'))
 1546:         assert_equal(np.fmin(a, b), b)
 1547:         assert_equal(np.fmin(a, b).dtype, np.dtype('M8[s]'))
 1548:         assert_equal(np.maximum(a, b), a)
 1549:         assert_equal(np.maximum(a, b).dtype, np.dtype('M8[s]'))
 1550:         assert_equal(np.fmax(a, b), a)
 1551:         assert_equal(np.fmax(a, b).dtype, np.dtype('M8[s]'))
 1552:         # Viewed as integers, the comparison is opposite because
 1553:         # of the units chosen
 1554:         assert_equal(np.minimum(a.view('i8'), b.view('i8')), a.view('i8'))
 1555: 
 1556:         # Interaction with NaT
 1557:         a = np.array('1999-03-12T13', dtype='M8[2m]')
 1558:         dtnat = np.array('NaT', dtype='M8[h]')
 1559:         assert_equal(np.minimum(a, dtnat), dtnat)
 1560:         assert_equal(np.minimum(dtnat, a), dtnat)
 1561:         assert_equal(np.maximum(a, dtnat), dtnat)
 1562:         assert_equal(np.maximum(dtnat, a), dtnat)
 1563:         assert_equal(np.fmin(dtnat, a), a)
 1564:         assert_equal(np.fmin(a, dtnat), a)
 1565:         assert_equal(np.fmax(dtnat, a), a)
 1566:         assert_equal(np.fmax(a, dtnat), a)
 1567: 
 1568:         # Also do timedelta
 1569:         a = np.array(3, dtype='m8[h]')
 1570:         b = np.array(3 * 3600 - 3, dtype='m8[s]')
 1571:         assert_equal(np.minimum(a, b), b)
 1572:         assert_equal(np.minimum(a, b).dtype, np.dtype('m8[s]'))
 1573:         assert_equal(np.fmin(a, b), b)
 1574:         assert_equal(np.fmin(a, b).dtype, np.dtype('m8[s]'))
 1575:         assert_equal(np.maximum(a, b), a)
 1576:         assert_equal(np.maximum(a, b).dtype, np.dtype('m8[s]'))
 1577:         assert_equal(np.fmax(a, b), a)
 1578:         assert_equal(np.fmax(a, b).dtype, np.dtype('m8[s]'))
 1579:         # Viewed as integers, the comparison is opposite because
 1580:         # of the units chosen
 1581:         assert_equal(np.minimum(a.view('i8'), b.view('i8')), a.view('i8'))
 1582: 
 1583:         # should raise between datetime and timedelta
 1584:         #
 1585:         # TODO: Allowing unsafe casting by
 1586:         #       default in ufuncs strikes again... :(
 1587:         a = np.array(3, dtype='m8[h]')
 1588:         b = np.array('1999-03-12T12', dtype='M8[s]')
 1589:         #assert_raises(TypeError, np.minimum, a, b)
 1590:         #assert_raises(TypeError, np.maximum, a, b)
 1591:         #assert_raises(TypeError, np.fmin, a, b)
 1592:         #assert_raises(TypeError, np.fmax, a, b)
 1593:         assert_raises(TypeError, np.minimum, a, b, casting='same_kind')
 1594:         assert_raises(TypeError, np.maximum, a, b, casting='same_kind')
 1595:         assert_raises(TypeError, np.fmin, a, b, casting='same_kind')
 1596:         assert_raises(TypeError, np.fmax, a, b, casting='same_kind')
 1597: 
 1598:     def test_hours(self):
 1599:         t = np.ones(3, dtype='M8[s]')
 1600:         t[0] = 60 * 60 * 24 + 60 * 60 * 10
 1601:         assert_(t[0].item().hour == 10)
 1602: 
 1603:     def test_divisor_conversion_year(self):
 1604:         assert_(np.dtype('M8[Y/4]') == np.dtype('M8[3M]'))
 1605:         assert_(np.dtype('M8[Y/13]') == np.dtype('M8[4W]'))
 1606:         assert_(np.dtype('M8[3Y/73]') == np.dtype('M8[15D]'))
 1607: 
 1608:     def test_divisor_conversion_month(self):
 1609:         assert_(np.dtype('M8[M/2]') == np.dtype('M8[2W]'))
 1610:         assert_(np.dtype('M8[M/15]') == np.dtype('M8[2D]'))
 1611:         assert_(np.dtype('M8[3M/40]') == np.dtype('M8[54h]'))
 1612: 
 1613:     def test_divisor_conversion_week(self):
 1614:         assert_(np.dtype('m8[W/7]') == np.dtype('m8[D]'))
 1615:         assert_(np.dtype('m8[3W/14]') == np.dtype('m8[36h]'))
 1616:         assert_(np.dtype('m8[5W/140]') == np.dtype('m8[360m]'))
 1617: 
 1618:     def test_divisor_conversion_day(self):
 1619:         assert_(np.dtype('M8[D/12]') == np.dtype('M8[2h]'))
 1620:         assert_(np.dtype('M8[D/120]') == np.dtype('M8[12m]'))
 1621:         assert_(np.dtype('M8[3D/960]') == np.dtype('M8[270s]'))
 1622: 
 1623:     def test_divisor_conversion_hour(self):
 1624:         assert_(np.dtype('m8[h/30]') == np.dtype('m8[2m]'))
 1625:         assert_(np.dtype('m8[3h/300]') == np.dtype('m8[36s]'))
 1626: 
 1627:     def test_divisor_conversion_minute(self):
 1628:         assert_(np.dtype('m8[m/30]') == np.dtype('m8[2s]'))
 1629:         assert_(np.dtype('m8[3m/300]') == np.dtype('m8[600ms]'))
 1630: 
 1631:     def test_divisor_conversion_second(self):
 1632:         assert_(np.dtype('m8[s/100]') == np.dtype('m8[10ms]'))
 1633:         assert_(np.dtype('m8[3s/10000]') == np.dtype('m8[300us]'))
 1634: 
 1635:     def test_divisor_conversion_fs(self):
 1636:         assert_(np.dtype('M8[fs/100]') == np.dtype('M8[10as]'))
 1637:         assert_raises(ValueError, lambda: np.dtype('M8[3fs/10000]'))
 1638: 
 1639:     def test_divisor_conversion_as(self):
 1640:         assert_raises(ValueError, lambda: np.dtype('M8[as/10]'))
 1641: 
 1642:     def test_string_parser_variants(self):
 1643:         msg = "no explicit representation of timezones available for " \
 1644:               "np.datetime64"
 1645:         # Allow space instead of 'T' between date and time
 1646:         assert_equal(np.array(['1980-02-29T01:02:03'], np.dtype('M8[s]')),
 1647:                      np.array(['1980-02-29 01:02:03'], np.dtype('M8[s]')))
 1648:         # Allow positive years
 1649:         assert_equal(np.array(['+1980-02-29T01:02:03'], np.dtype('M8[s]')),
 1650:                      np.array(['+1980-02-29 01:02:03'], np.dtype('M8[s]')))
 1651:         # Allow negative years
 1652:         assert_equal(np.array(['-1980-02-29T01:02:03'], np.dtype('M8[s]')),
 1653:                      np.array(['-1980-02-29 01:02:03'], np.dtype('M8[s]')))
 1654:         # UTC specifier
 1655:         with pytest.warns(UserWarning, match=msg):
 1656:             assert_equal(
 1657:                 np.array(['+1980-02-29T01:02:03'], np.dtype('M8[s]')),
 1658:                 np.array(['+1980-02-29 01:02:03Z'], np.dtype('M8[s]')))
 1659:         with pytest.warns(UserWarning, match=msg):
 1660:             assert_equal(
 1661:                 np.array(['-1980-02-29T01:02:03'], np.dtype('M8[s]')),
 1662:                 np.array(['-1980-02-29 01:02:03Z'], np.dtype('M8[s]')))
 1663:         # Time zone offset
 1664:         with pytest.warns(UserWarning, match=msg):
 1665:             assert_equal(
 1666:                 np.array(['1980-02-29T02:02:03'], np.dtype('M8[s]')),
 1667:                 np.array(['1980-02-29 00:32:03-0130'], np.dtype('M8[s]')))
 1668:         with pytest.warns(UserWarning, match=msg):
 1669:             assert_equal(
 1670:                 np.array(['1980-02-28T22:32:03'], np.dtype('M8[s]')),
 1671:                 np.array(['1980-02-29 00:02:03+01:30'], np.dtype('M8[s]')))
 1672:         with pytest.warns(UserWarning, match=msg):
 1673:             assert_equal(
 1674:                 np.array(['1980-02-29T02:32:03.506'], np.dtype('M8[s]')),
 1675:                 np.array(['1980-02-29 00:32:03.506-02'], np.dtype('M8[s]')))
 1676:         with pytest.warns(UserWarning, match=msg):
 1677:             assert_equal(np.datetime64('1977-03-02T12:30-0230'),
 1678:                          np.datetime64('1977-03-02T15:00'))
 1679: 
 1680:     def test_string_parser_error_check(self):
 1681:         msg = "no explicit representation of timezones available for " \
 1682:               "np.datetime64"
 1683:         # Arbitrary bad string
 1684:         assert_raises(ValueError, np.array, ['badvalue'], np.dtype('M8[us]'))
 1685:         # Character after year must be '-'
 1686:         assert_raises(ValueError, np.array, ['1980X'], np.dtype('M8[us]'))
 1687:         # Cannot have trailing '-'
 1688:         assert_raises(ValueError, np.array, ['1980-'], np.dtype('M8[us]'))
 1689:         # Month must be in range [1,12]
 1690:         assert_raises(ValueError, np.array, ['1980-00'], np.dtype('M8[us]'))
 1691:         assert_raises(ValueError, np.array, ['1980-13'], np.dtype('M8[us]'))
 1692:         # Month must have two digits
 1693:         assert_raises(ValueError, np.array, ['1980-1'], np.dtype('M8[us]'))
 1694:         assert_raises(ValueError, np.array, ['1980-1-02'], np.dtype('M8[us]'))
 1695:         # 'Mor' is not a valid month
 1696:         assert_raises(ValueError, np.array, ['1980-Mor'], np.dtype('M8[us]'))
 1697:         # Cannot have trailing '-'
 1698:         assert_raises(ValueError, np.array, ['1980-01-'], np.dtype('M8[us]'))
 1699:         # Day must be in range [1,len(month)]
 1700:         assert_raises(ValueError, np.array, ['1980-01-0'], np.dtype('M8[us]'))
 1701:         assert_raises(ValueError, np.array, ['1980-01-00'], np.dtype('M8[us]'))
 1702:         assert_raises(ValueError, np.array, ['1980-01-32'], np.dtype('M8[us]'))
 1703:         assert_raises(ValueError, np.array, ['1979-02-29'], np.dtype('M8[us]'))
 1704:         assert_raises(ValueError, np.array, ['1980-02-30'], np.dtype('M8[us]'))
 1705:         assert_raises(ValueError, np.array, ['1980-03-32'], np.dtype('M8[us]'))
 1706:         assert_raises(ValueError, np.array, ['1980-04-31'], np.dtype('M8[us]'))
 1707:         assert_raises(ValueError, np.array, ['1980-05-32'], np.dtype('M8[us]'))
 1708:         assert_raises(ValueError, np.array, ['1980-06-31'], np.dtype('M8[us]'))
 1709:         assert_raises(ValueError, np.array, ['1980-07-32'], np.dtype('M8[us]'))
 1710:         assert_raises(ValueError, np.array, ['1980-08-32'], np.dtype('M8[us]'))
 1711:         assert_raises(ValueError, np.array, ['1980-09-31'], np.dtype('M8[us]'))
 1712:         assert_raises(ValueError, np.array, ['1980-10-32'], np.dtype('M8[us]'))
 1713:         assert_raises(ValueError, np.array, ['1980-11-31'], np.dtype('M8[us]'))
 1714:         assert_raises(ValueError, np.array, ['1980-12-32'], np.dtype('M8[us]'))
 1715:         # Cannot have trailing characters
 1716:         assert_raises(ValueError, np.array, ['1980-02-03%'],
 1717:                                                         np.dtype('M8[us]'))
 1718:         assert_raises(ValueError, np.array, ['1980-02-03 q'],
 1719:                                                         np.dtype('M8[us]'))
 1720: 
 1721:         # Hours must be in range [0, 23]
 1722:         assert_raises(ValueError, np.array, ['1980-02-03 25'],
 1723:                                                         np.dtype('M8[us]'))
 1724:         assert_raises(ValueError, np.array, ['1980-02-03T25'],
 1725:                                                         np.dtype('M8[us]'))
 1726:         assert_raises(ValueError, np.array, ['1980-02-03 24:01'],
 1727:                                                         np.dtype('M8[us]'))
 1728:         assert_raises(ValueError, np.array, ['1980-02-03T24:01'],
 1729:                                                         np.dtype('M8[us]'))
 1730:         assert_raises(ValueError, np.array, ['1980-02-03 -1'],
 1731:                                                         np.dtype('M8[us]'))
 1732:         # No trailing ':'
 1733:         assert_raises(ValueError, np.array, ['1980-02-03 01:'],
 1734:                                                         np.dtype('M8[us]'))
 1735:         # Minutes must be in range [0, 59]
 1736:         assert_raises(ValueError, np.array, ['1980-02-03 01:-1'],
 1737:                                                         np.dtype('M8[us]'))
 1738:         assert_raises(ValueError, np.array, ['1980-02-03 01:60'],
 1739:                                                         np.dtype('M8[us]'))
 1740:         # No trailing ':'
 1741:         assert_raises(ValueError, np.array, ['1980-02-03 01:60:'],
 1742:                                                         np.dtype('M8[us]'))
 1743:         # Seconds must be in range [0, 59]
 1744:         assert_raises(ValueError, np.array, ['1980-02-03 01:10:-1'],
 1745:                                                         np.dtype('M8[us]'))
 1746:         assert_raises(ValueError, np.array, ['1980-02-03 01:01:60'],
 1747:                                                         np.dtype('M8[us]'))
 1748:         # Timezone offset must within a reasonable range
 1749:         with pytest.warns(UserWarning, match=msg):
 1750:             assert_raises(ValueError, np.array, ['1980-02-03 01:01:00+0661'],
 1751:                                                             np.dtype('M8[us]'))
 1752:         with pytest.warns(UserWarning, match=msg):
 1753:             assert_raises(ValueError, np.array, ['1980-02-03 01:01:00+2500'],
 1754:                                                             np.dtype('M8[us]'))
 1755:         with pytest.warns(UserWarning, match=msg):
 1756:             assert_raises(ValueError, np.array, ['1980-02-03 01:01:00-0070'],
 1757:                                                             np.dtype('M8[us]'))
 1758:         with pytest.warns(UserWarning, match=msg):
 1759:             assert_raises(ValueError, np.array, ['1980-02-03 01:01:00-3000'],
 1760:                                                             np.dtype('M8[us]'))
 1761:         with pytest.warns(UserWarning, match=msg):
 1762:             assert_raises(ValueError, np.array, ['1980-02-03 01:01:00-25:00'],
 1763:                                                             np.dtype('M8[us]'))
 1764: 
 1765:     def test_creation_overflow(self):
 1766:         date = '1980-03-23 20:00:00'
 1767:         timesteps = np.array([date], dtype='datetime64[s]')[0].astype(np.int64)
 1768:         for unit in ['ms', 'us', 'ns']:
 1769:             timesteps *= 1000
 1770:             x = np.array([date], dtype=f'datetime64[{unit}]')
 1771: 
 1772:             assert_equal(timesteps, x[0].astype(np.int64),
 1773:                          err_msg=f'Datetime conversion error for unit {unit}')
 1774: 
 1775:         assert_equal(x[0].astype(np.int64), 322689600000000000)
 1776: 
 1777:         # gh-13062
 1778:         with pytest.raises(OverflowError):
 1779:             np.datetime64(2**64, 'D')
 1780:         with pytest.raises(OverflowError):
 1781:             np.timedelta64(2**64, 'D')
 1782: 
 1783:     def test_datetime_as_string(self):
 1784:         # Check all the units with default string conversion
 1785:         date = '1959-10-13'
 1786:         datetime = '1959-10-13T12:34:56.789012345678901234'
 1787: 
 1788:         assert_equal(np.datetime_as_string(np.datetime64(date, 'Y')),
 1789:                      '1959')
 1790:         assert_equal(np.datetime_as_string(np.datetime64(date, 'M')),
 1791:                      '1959-10')
 1792:         assert_equal(np.datetime_as_string(np.datetime64(date, 'D')),
 1793:                      '1959-10-13')
 1794:         assert_equal(np.datetime_as_string(np.datetime64(datetime, 'h')),
 1795:                      '1959-10-13T12')
 1796:         assert_equal(np.datetime_as_string(np.datetime64(datetime, 'm')),
 1797:                      '1959-10-13T12:34')
 1798:         assert_equal(np.datetime_as_string(np.datetime64(datetime, 's')),
 1799:                      '1959-10-13T12:34:56')
 1800:         assert_equal(np.datetime_as_string(np.datetime64(datetime, 'ms')),
 1801:                      '1959-10-13T12:34:56.789')
 1802:         for us in ['us', 'Ојs', b'us']:  # check non-ascii and bytes too
 1803:             assert_equal(np.datetime_as_string(np.datetime64(datetime, us)),
 1804:                          '1959-10-13T12:34:56.789012')
 1805: 
 1806:         datetime = '1969-12-31T23:34:56.789012345678901234'
 1807: 
 1808:         assert_equal(np.datetime_as_string(np.datetime64(datetime, 'ns')),
 1809:                      '1969-12-31T23:34:56.789012345')
 1810:         assert_equal(np.datetime_as_string(np.datetime64(datetime, 'ps')),
 1811:                      '1969-12-31T23:34:56.789012345678')
 1812:         assert_equal(np.datetime_as_string(np.datetime64(datetime, 'fs')),
 1813:                      '1969-12-31T23:34:56.789012345678901')
 1814: 
 1815:         datetime = '1969-12-31T23:59:57.789012345678901234'
 1816: 
 1817:         assert_equal(np.datetime_as_string(np.datetime64(datetime, 'as')),
 1818:                      datetime)
 1819:         datetime = '1970-01-01T00:34:56.789012345678901234'
 1820: 
 1821:         assert_equal(np.datetime_as_string(np.datetime64(datetime, 'ns')),
 1822:                      '1970-01-01T00:34:56.789012345')
 1823:         assert_equal(np.datetime_as_string(np.datetime64(datetime, 'ps')),
 1824:                      '1970-01-01T00:34:56.789012345678')
 1825:         assert_equal(np.datetime_as_string(np.datetime64(datetime, 'fs')),
 1826:                      '1970-01-01T00:34:56.789012345678901')
 1827: 
 1828:         datetime = '1970-01-01T00:00:05.789012345678901234'
 1829: 
 1830:         assert_equal(np.datetime_as_string(np.datetime64(datetime, 'as')),
 1831:                      datetime)
 1832: 
 1833:         # String conversion with the unit= parameter
 1834:         a = np.datetime64('2032-07-18T12:23:34.123456', 'us')
 1835:         assert_equal(np.datetime_as_string(a, unit='Y', casting='unsafe'),
 1836:                             '2032')
 1837:         assert_equal(np.datetime_as_string(a, unit='M', casting='unsafe'),
 1838:                             '2032-07')
 1839:         assert_equal(np.datetime_as_string(a, unit='W', casting='unsafe'),
 1840:                             '2032-07-18')
 1841:         assert_equal(np.datetime_as_string(a, unit='D', casting='unsafe'),
 1842:                             '2032-07-18')
 1843:         assert_equal(np.datetime_as_string(a, unit='h'), '2032-07-18T12')
 1844:         assert_equal(np.datetime_as_string(a, unit='m'),
 1845:                             '2032-07-18T12:23')
 1846:         assert_equal(np.datetime_as_string(a, unit='s'),
 1847:                             '2032-07-18T12:23:34')
 1848:         assert_equal(np.datetime_as_string(a, unit='ms'),
 1849:                             '2032-07-18T12:23:34.123')
 1850:         assert_equal(np.datetime_as_string(a, unit='us'),
 1851:                             '2032-07-18T12:23:34.123456')
 1852:         assert_equal(np.datetime_as_string(a, unit='ns'),
 1853:                             '2032-07-18T12:23:34.123456000')
 1854:         assert_equal(np.datetime_as_string(a, unit='ps'),
 1855:                             '2032-07-18T12:23:34.123456000000')
 1856:         assert_equal(np.datetime_as_string(a, unit='fs'),
 1857:                             '2032-07-18T12:23:34.123456000000000')
 1858:         assert_equal(np.datetime_as_string(a, unit='as'),
 1859:                             '2032-07-18T12:23:34.123456000000000000')
 1860: 
 1861:         # unit='auto' parameter
 1862:         assert_equal(np.datetime_as_string(
 1863:                 np.datetime64('2032-07-18T12:23:34.123456', 'us'), unit='auto'),
 1864:                 '2032-07-18T12:23:34.123456')
 1865:         assert_equal(np.datetime_as_string(
 1866:                 np.datetime64('2032-07-18T12:23:34.12', 'us'), unit='auto'),
 1867:                 '2032-07-18T12:23:34.120')
 1868:         assert_equal(np.datetime_as_string(
 1869:                 np.datetime64('2032-07-18T12:23:34', 'us'), unit='auto'),
 1870:                 '2032-07-18T12:23:34')
 1871:         assert_equal(np.datetime_as_string(
 1872:                 np.datetime64('2032-07-18T12:23:00', 'us'), unit='auto'),
 1873:                 '2032-07-18T12:23')
 1874:         # 'auto' doesn't split up hour and minute
 1875:         assert_equal(np.datetime_as_string(
 1876:                 np.datetime64('2032-07-18T12:00:00', 'us'), unit='auto'),
 1877:                 '2032-07-18T12:00')
 1878:         assert_equal(np.datetime_as_string(
 1879:                 np.datetime64('2032-07-18T00:00:00', 'us'), unit='auto'),
 1880:                 '2032-07-18')
 1881:         # 'auto' doesn't split up the date
 1882:         assert_equal(np.datetime_as_string(
 1883:                 np.datetime64('2032-07-01T00:00:00', 'us'), unit='auto'),
 1884:                 '2032-07-01')
 1885:         assert_equal(np.datetime_as_string(
 1886:                 np.datetime64('2032-01-01T00:00:00', 'us'), unit='auto'),
 1887:                 '2032-01-01')
 1888: 
 1889:     @pytest.mark.skipif(not _has_pytz, reason="The pytz module is not available.")
 1890:     def test_datetime_as_string_timezone(self):
 1891:         # timezone='local' vs 'UTC'
 1892:         a = np.datetime64('2010-03-15T06:30', 'm')
 1893:         assert_equal(np.datetime_as_string(a),
 1894:                 '2010-03-15T06:30')
 1895:         assert_equal(np.datetime_as_string(a, timezone='naive'),
 1896:                 '2010-03-15T06:30')
 1897:         assert_equal(np.datetime_as_string(a, timezone='UTC'),
 1898:                 '2010-03-15T06:30Z')
 1899:         assert_(np.datetime_as_string(a, timezone='local') !=
 1900:                 '2010-03-15T06:30')
 1901: 
 1902:         b = np.datetime64('2010-02-15T06:30', 'm')
 1903: 
 1904:         assert_equal(np.datetime_as_string(a, timezone=tz('US/Central')),
 1905:                      '2010-03-15T01:30-0500')
 1906:         assert_equal(np.datetime_as_string(a, timezone=tz('US/Eastern')),
 1907:                      '2010-03-15T02:30-0400')
 1908:         assert_equal(np.datetime_as_string(a, timezone=tz('US/Pacific')),
 1909:                      '2010-03-14T23:30-0700')
 1910: 
 1911:         assert_equal(np.datetime_as_string(b, timezone=tz('US/Central')),
 1912:                      '2010-02-15T00:30-0600')
 1913:         assert_equal(np.datetime_as_string(b, timezone=tz('US/Eastern')),
 1914:                      '2010-02-15T01:30-0500')
 1915:         assert_equal(np.datetime_as_string(b, timezone=tz('US/Pacific')),
 1916:                      '2010-02-14T22:30-0800')
 1917: 
 1918:         # Dates to strings with a timezone attached is disabled by default
 1919:         assert_raises(TypeError, np.datetime_as_string, a, unit='D',
 1920:                            timezone=tz('US/Pacific'))
 1921:         # Check that we can print out the date in the specified time zone
 1922:         assert_equal(np.datetime_as_string(a, unit='D',
 1923:                            timezone=tz('US/Pacific'), casting='unsafe'),
 1924:                      '2010-03-14')
 1925:         assert_equal(np.datetime_as_string(b, unit='D',
 1926:                            timezone=tz('US/Central'), casting='unsafe'),
 1927:                      '2010-02-15')
 1928: 
 1929:     def test_datetime_arange(self):
 1930:         # With two datetimes provided as strings
 1931:         a = np.arange('2010-01-05', '2010-01-10', dtype='M8[D]')
 1932:         assert_equal(a.dtype, np.dtype('M8[D]'))
 1933:         assert_equal(a,
 1934:             np.array(['2010-01-05', '2010-01-06', '2010-01-07',
 1935:                       '2010-01-08', '2010-01-09'], dtype='M8[D]'))
 1936: 
 1937:         a = np.arange('1950-02-10', '1950-02-06', -1, dtype='M8[D]')
 1938:         assert_equal(a.dtype, np.dtype('M8[D]'))
 1939:         assert_equal(a,
 1940:             np.array(['1950-02-10', '1950-02-09', '1950-02-08',
 1941:                       '1950-02-07'], dtype='M8[D]'))
 1942: 
 1943:         # Unit should be detected as months here
 1944:         a = np.arange('1969-05', '1970-05', 2, dtype='M8')
 1945:         assert_equal(a.dtype, np.dtype('M8[M]'))
 1946:         assert_equal(a,
 1947:             np.datetime64('1969-05') + np.arange(12, step=2))
 1948: 
 1949:         # datetime, integer|timedelta works as well
 1950:         # produces arange (start, start + stop) in this case
 1951:         a = np.arange('1969', 18, 3, dtype='M8')
 1952:         assert_equal(a.dtype, np.dtype('M8[Y]'))
 1953:         assert_equal(a,
 1954:             np.datetime64('1969') + np.arange(18, step=3))
 1955:         a = np.arange('1969-12-19', 22, np.timedelta64(2), dtype='M8')
 1956:         assert_equal(a.dtype, np.dtype('M8[D]'))
 1957:         assert_equal(a,
 1958:             np.datetime64('1969-12-19') + np.arange(22, step=2))
 1959: 
 1960:         # Step of 0 is disallowed
 1961:         assert_raises(ValueError, np.arange, np.datetime64('today'),
 1962:                                 np.datetime64('today') + 3, 0)
 1963:         # Promotion across nonlinear unit boundaries is disallowed
 1964:         assert_raises(TypeError, np.arange, np.datetime64('2011-03-01', 'D'),
 1965:                                 np.timedelta64(5, 'M'))
 1966:         assert_raises(TypeError, np.arange,
 1967:                                 np.datetime64('2012-02-03T14', 's'),
 1968:                                 np.timedelta64(5, 'Y'))
 1969: 
 1970:     def test_datetime_arange_no_dtype(self):
 1971:         d = np.array('2010-01-04', dtype="M8[D]")
 1972:         assert_equal(np.arange(d, d + 1), d)
 1973:         assert_raises(ValueError, np.arange, d)
 1974: 
 1975:     def test_timedelta_arange(self):
 1976:         a = np.arange(3, 10, dtype='m8')
 1977:         assert_equal(a.dtype, np.dtype('m8'))
 1978:         assert_equal(a, np.timedelta64(0) + np.arange(3, 10))
 1979: 
 1980:         a = np.arange(np.timedelta64(3, 's'), 10, 2, dtype='m8')
 1981:         assert_equal(a.dtype, np.dtype('m8[s]'))
 1982:         assert_equal(a, np.timedelta64(0, 's') + np.arange(3, 10, 2))
 1983: 
 1984:         # Step of 0 is disallowed
 1985:         assert_raises(ValueError, np.arange, np.timedelta64(0),
 1986:                                 np.timedelta64(5), 0)
 1987:         # Promotion across nonlinear unit boundaries is disallowed
 1988:         assert_raises(TypeError, np.arange, np.timedelta64(0, 'D'),
 1989:                                 np.timedelta64(5, 'M'))
 1990:         assert_raises(TypeError, np.arange, np.timedelta64(0, 'Y'),
 1991:                                 np.timedelta64(5, 'D'))
 1992: 
 1993:     @pytest.mark.parametrize("val1, val2, expected", [
 1994:         # case from gh-12092
 1995:         (np.timedelta64(7, 's'),
 1996:          np.timedelta64(3, 's'),
 1997:          np.timedelta64(1, 's')),
 1998:         # negative value cases
 1999:         (np.timedelta64(3, 's'),
 2000:          np.timedelta64(-2, 's'),
 2001:          np.timedelta64(-1, 's')),
 2002:         (np.timedelta64(-3, 's'),
 2003:          np.timedelta64(2, 's'),
 2004:          np.timedelta64(1, 's')),
 2005:         # larger value cases
 2006:         (np.timedelta64(17, 's'),
 2007:          np.timedelta64(22, 's'),
 2008:          np.timedelta64(17, 's')),
 2009:         (np.timedelta64(22, 's'),
 2010:          np.timedelta64(17, 's'),
 2011:          np.timedelta64(5, 's')),
 2012:         # different units
 2013:         (np.timedelta64(1, 'm'),
 2014:          np.timedelta64(57, 's'),
 2015:          np.timedelta64(3, 's')),
 2016:         (np.timedelta64(1, 'us'),
 2017:          np.timedelta64(727, 'ns'),
 2018:          np.timedelta64(273, 'ns')),
 2019:         # NaT is propagated
 2020:         (np.timedelta64('NaT'),
 2021:          np.timedelta64(50, 'ns'),
 2022:          np.timedelta64('NaT')),
 2023:         # Y % M works
 2024:         (np.timedelta64(2, 'Y'),
 2025:          np.timedelta64(22, 'M'),
 2026:          np.timedelta64(2, 'M')),
 2027:         ])
 2028:     def test_timedelta_modulus(self, val1, val2, expected):
 2029:         assert_equal(val1 % val2, expected)
 2030: 
 2031:     @pytest.mark.parametrize("val1, val2", [
 2032:         # years and months sometimes can't be unambiguously
 2033:         # divided for modulus operation
 2034:         (np.timedelta64(7, 'Y'),
 2035:          np.timedelta64(3, 's')),
 2036:         (np.timedelta64(7, 'M'),
 2037:          np.timedelta64(1, 'D')),
 2038:         ])
 2039:     def test_timedelta_modulus_error(self, val1, val2):
 2040:         with assert_raises_regex(TypeError, "common metadata divisor"):
 2041:             val1 % val2
 2042: 
 2043:     @pytest.mark.skipif(IS_WASM, reason="fp errors don't work in wasm")
 2044:     def test_timedelta_modulus_div_by_zero(self):
 2045:         with assert_warns(RuntimeWarning):
 2046:             actual = np.timedelta64(10, 's') % np.timedelta64(0, 's')
 2047:             assert_equal(actual, np.timedelta64('NaT'))
 2048: 
 2049:     @pytest.mark.parametrize("val1, val2", [
 2050:         # cases where one operand is not
 2051:         # timedelta64
 2052:         (np.timedelta64(7, 'Y'),
 2053:          15,),
 2054:         (7.5,
 2055:          np.timedelta64(1, 'D')),
 2056:         ])
 2057:     def test_timedelta_modulus_type_resolution(self, val1, val2):
 2058:         # NOTE: some of the operations may be supported
 2059:         # in the future
 2060:         with assert_raises_regex(TypeError,
 2061:                                  "'remainder' cannot use operands with types"):
 2062:             val1 % val2
 2063: 
 2064:     def test_timedelta_arange_no_dtype(self):
 2065:         d = np.array(5, dtype="m8[D]")
 2066:         assert_equal(np.arange(d, d + 1), d)
 2067:         assert_equal(np.arange(d), np.arange(0, d))
 2068: 
 2069:     def test_datetime_maximum_reduce(self):
 2070:         a = np.array(['2010-01-02', '1999-03-14', '1833-03'], dtype='M8[D]')
 2071:         assert_equal(np.maximum.reduce(a).dtype, np.dtype('M8[D]'))
 2072:         assert_equal(np.maximum.reduce(a),
 2073:                      np.datetime64('2010-01-02'))
 2074: 
 2075:         a = np.array([1, 4, 0, 7, 2], dtype='m8[s]')
 2076:         assert_equal(np.maximum.reduce(a).dtype, np.dtype('m8[s]'))
 2077:         assert_equal(np.maximum.reduce(a),
 2078:                      np.timedelta64(7, 's'))
 2079: 
 2080:     def test_timedelta_correct_mean(self):
 2081:         # test mainly because it worked only via a bug in that allowed:
 2082:         # `timedelta.sum(dtype="f8")` to ignore the dtype request.
 2083:         a = np.arange(1000, dtype="m8[s]")
 2084:         assert_array_equal(a.mean(), a.sum() / len(a))
 2085: 
 2086:     def test_datetime_no_subtract_reducelike(self):
 2087:         # subtracting two datetime64 works, but we cannot reduce it, since
 2088:         # the result of that subtraction will have a different dtype.
 2089:         arr = np.array(["2021-12-02", "2019-05-12"], dtype="M8[ms]")
 2090:         msg = r"the resolved dtypes are not compatible"
 2091: 
 2092:         with pytest.raises(TypeError, match=msg):
 2093:             np.subtract.reduce(arr)
 2094: 
 2095:         with pytest.raises(TypeError, match=msg):
 2096:             np.subtract.accumulate(arr)
 2097: 
 2098:         with pytest.raises(TypeError, match=msg):
 2099:             np.subtract.reduceat(arr, [0])
 2100: 
 2101:     def test_datetime_busday_offset(self):
 2102:         # First Monday in June
 2103:         assert_equal(
 2104:             np.busday_offset('2011-06', 0, roll='forward', weekmask='Mon'),
 2105:             np.datetime64('2011-06-06'))
 2106:         # Last Monday in June
 2107:         assert_equal(
 2108:             np.busday_offset('2011-07', -1, roll='forward', weekmask='Mon'),
 2109:             np.datetime64('2011-06-27'))
 2110:         assert_equal(
 2111:             np.busday_offset('2011-07', -1, roll='forward', weekmask='Mon'),
 2112:             np.datetime64('2011-06-27'))
 2113: 
 2114:         # Default M-F business days, different roll modes
 2115:         assert_equal(np.busday_offset('2010-08', 0, roll='backward'),
 2116:                      np.datetime64('2010-07-30'))
 2117:         assert_equal(np.busday_offset('2010-08', 0, roll='preceding'),
 2118:                      np.datetime64('2010-07-30'))
 2119:         assert_equal(np.busday_offset('2010-08', 0, roll='modifiedpreceding'),
 2120:                      np.datetime64('2010-08-02'))
 2121:         assert_equal(np.busday_offset('2010-08', 0, roll='modifiedfollowing'),
 2122:                      np.datetime64('2010-08-02'))
 2123:         assert_equal(np.busday_offset('2010-08', 0, roll='forward'),
 2124:                      np.datetime64('2010-08-02'))
 2125:         assert_equal(np.busday_offset('2010-08', 0, roll='following'),
 2126:                      np.datetime64('2010-08-02'))
 2127:         assert_equal(np.busday_offset('2010-10-30', 0, roll='following'),
 2128:                      np.datetime64('2010-11-01'))
 2129:         assert_equal(
 2130:                 np.busday_offset('2010-10-30', 0, roll='modifiedfollowing'),
 2131:                 np.datetime64('2010-10-29'))
 2132:         assert_equal(
 2133:                 np.busday_offset('2010-10-30', 0, roll='modifiedpreceding'),
 2134:                 np.datetime64('2010-10-29'))
 2135:         assert_equal(
 2136:                 np.busday_offset('2010-10-16', 0, roll='modifiedfollowing'),
 2137:                 np.datetime64('2010-10-18'))
 2138:         assert_equal(
 2139:                 np.busday_offset('2010-10-16', 0, roll='modifiedpreceding'),
 2140:                 np.datetime64('2010-10-15'))
 2141:         # roll='raise' by default
 2142:         assert_raises(ValueError, np.busday_offset, '2011-06-04', 0)
 2143: 
 2144:         # Bigger offset values
 2145:         assert_equal(np.busday_offset('2006-02-01', 25),
 2146:                      np.datetime64('2006-03-08'))
 2147:         assert_equal(np.busday_offset('2006-03-08', -25),
 2148:                      np.datetime64('2006-02-01'))
 2149:         assert_equal(np.busday_offset('2007-02-25', 11, weekmask='SatSun'),
 2150:                      np.datetime64('2007-04-07'))
 2151:         assert_equal(np.busday_offset('2007-04-07', -11, weekmask='SatSun'),
 2152:                      np.datetime64('2007-02-25'))
 2153: 
 2154:         # NaT values when roll is not raise
 2155:         assert_equal(np.busday_offset(np.datetime64('NaT'), 1, roll='nat'),
 2156:                      np.datetime64('NaT'))
 2157:         assert_equal(np.busday_offset(np.datetime64('NaT'), 1, roll='following'),
 2158:                      np.datetime64('NaT'))
 2159:         assert_equal(np.busday_offset(np.datetime64('NaT'), 1, roll='preceding'),
 2160:                      np.datetime64('NaT'))
 2161: 
 2162:     def test_datetime_busdaycalendar(self):
 2163:         # Check that it removes NaT, duplicates, and weekends
 2164:         # and sorts the result.
 2165:         bdd = np.busdaycalendar(
 2166:             holidays=['NaT', '2011-01-17', '2011-03-06', 'NaT',
 2167:                        '2011-12-26', '2011-05-30', '2011-01-17'])
 2168:         assert_equal(bdd.holidays,
 2169:             np.array(['2011-01-17', '2011-05-30', '2011-12-26'], dtype='M8'))
 2170:         # Default M-F weekmask
 2171:         assert_equal(bdd.weekmask, np.array([1, 1, 1, 1, 1, 0, 0], dtype='?'))
 2172: 
 2173:         # Check string weekmask with varying whitespace.
 2174:         bdd = np.busdaycalendar(weekmask="Sun TueWed  Thu\tFri")
 2175:         assert_equal(bdd.weekmask, np.array([0, 1, 1, 1, 1, 0, 1], dtype='?'))
 2176: 
 2177:         # Check length 7 0/1 string
 2178:         bdd = np.busdaycalendar(weekmask="0011001")
 2179:         assert_equal(bdd.weekmask, np.array([0, 0, 1, 1, 0, 0, 1], dtype='?'))
 2180: 
 2181:         # Check length 7 string weekmask.
 2182:         bdd = np.busdaycalendar(weekmask="Mon Tue")
 2183:         assert_equal(bdd.weekmask, np.array([1, 1, 0, 0, 0, 0, 0], dtype='?'))
 2184: 
 2185:         # All-zeros weekmask should raise
 2186:         assert_raises(ValueError, np.busdaycalendar, weekmask=[0, 0, 0, 0, 0, 0, 0])
 2187:         # weekday names must be correct case
 2188:         assert_raises(ValueError, np.busdaycalendar, weekmask="satsun")
 2189:         # All-zeros weekmask should raise
 2190:         assert_raises(ValueError, np.busdaycalendar, weekmask="")
 2191:         # Invalid weekday name codes should raise
 2192:         assert_raises(ValueError, np.busdaycalendar, weekmask="Mon Tue We")
 2193:         assert_raises(ValueError, np.busdaycalendar, weekmask="Max")
 2194:         assert_raises(ValueError, np.busdaycalendar, weekmask="Monday Tue")
 2195: 
 2196:     def test_datetime_busday_holidays_offset(self):
 2197:         # With exactly one holiday
 2198:         assert_equal(
 2199:             np.busday_offset('2011-11-10', 1, holidays=['2011-11-11']),
 2200:             np.datetime64('2011-11-14'))
 2201:         assert_equal(
 2202:             np.busday_offset('2011-11-04', 5, holidays=['2011-11-11']),
 2203:             np.datetime64('2011-11-14'))
 2204:         assert_equal(
 2205:             np.busday_offset('2011-11-10', 5, holidays=['2011-11-11']),
 2206:             np.datetime64('2011-11-18'))
 2207:         assert_equal(
 2208:             np.busday_offset('2011-11-14', -1, holidays=['2011-11-11']),
 2209:             np.datetime64('2011-11-10'))
 2210:         assert_equal(
 2211:             np.busday_offset('2011-11-18', -5, holidays=['2011-11-11']),
 2212:             np.datetime64('2011-11-10'))
 2213:         assert_equal(
 2214:             np.busday_offset('2011-11-14', -5, holidays=['2011-11-11']),
 2215:             np.datetime64('2011-11-04'))
 2216:         # With the holiday appearing twice
 2217:         assert_equal(
 2218:             np.busday_offset('2011-11-10', 1,
 2219:                 holidays=['2011-11-11', '2011-11-11']),
 2220:             np.datetime64('2011-11-14'))
 2221:         assert_equal(
 2222:             np.busday_offset('2011-11-14', -1,
 2223:                 holidays=['2011-11-11', '2011-11-11']),
 2224:             np.datetime64('2011-11-10'))
 2225:         # With a NaT holiday
 2226:         assert_equal(
 2227:             np.busday_offset('2011-11-10', 1,
 2228:                 holidays=['2011-11-11', 'NaT']),
 2229:             np.datetime64('2011-11-14'))
 2230:         assert_equal(
 2231:             np.busday_offset('2011-11-14', -1,
 2232:                 holidays=['NaT', '2011-11-11']),
 2233:             np.datetime64('2011-11-10'))
 2234:         # With another holiday after
 2235:         assert_equal(
 2236:             np.busday_offset('2011-11-10', 1,
 2237:                 holidays=['2011-11-11', '2011-11-24']),
 2238:             np.datetime64('2011-11-14'))
 2239:         assert_equal(
 2240:             np.busday_offset('2011-11-14', -1,
 2241:                 holidays=['2011-11-11', '2011-11-24']),
 2242:             np.datetime64('2011-11-10'))
 2243:         # With another holiday before
 2244:         assert_equal(
 2245:             np.busday_offset('2011-11-10', 1,
 2246:                 holidays=['2011-10-10', '2011-11-11']),
 2247:             np.datetime64('2011-11-14'))
 2248:         assert_equal(
 2249:             np.busday_offset('2011-11-14', -1,
 2250:                 holidays=['2011-10-10', '2011-11-11']),
 2251:             np.datetime64('2011-11-10'))
 2252:         # With another holiday before and after
 2253:         assert_equal(
 2254:             np.busday_offset('2011-11-10', 1,
 2255:                 holidays=['2011-10-10', '2011-11-11', '2011-11-24']),
 2256:             np.datetime64('2011-11-14'))
 2257:         assert_equal(
 2258:             np.busday_offset('2011-11-14', -1,
 2259:                 holidays=['2011-10-10', '2011-11-11', '2011-11-24']),
 2260:             np.datetime64('2011-11-10'))
 2261: 
 2262:         # A bigger forward jump across more than one week/holiday
 2263:         holidays = ['2011-10-10', '2011-11-11', '2011-11-24',
 2264:                   '2011-12-25', '2011-05-30', '2011-02-21',
 2265:                   '2011-12-26', '2012-01-02']
 2266:         bdd = np.busdaycalendar(weekmask='1111100', holidays=holidays)
 2267:         assert_equal(
 2268:             np.busday_offset('2011-10-03', 4, holidays=holidays),
 2269:             np.busday_offset('2011-10-03', 4))
 2270:         assert_equal(
 2271:             np.busday_offset('2011-10-03', 5, holidays=holidays),
 2272:             np.busday_offset('2011-10-03', 5 + 1))
 2273:         assert_equal(
 2274:             np.busday_offset('2011-10-03', 27, holidays=holidays),
 2275:             np.busday_offset('2011-10-03', 27 + 1))
 2276:         assert_equal(
 2277:             np.busday_offset('2011-10-03', 28, holidays=holidays),
 2278:             np.busday_offset('2011-10-03', 28 + 2))
 2279:         assert_equal(
 2280:             np.busday_offset('2011-10-03', 35, holidays=holidays),
 2281:             np.busday_offset('2011-10-03', 35 + 2))
 2282:         assert_equal(
 2283:             np.busday_offset('2011-10-03', 36, holidays=holidays),
 2284:             np.busday_offset('2011-10-03', 36 + 3))
 2285:         assert_equal(
 2286:             np.busday_offset('2011-10-03', 56, holidays=holidays),
 2287:             np.busday_offset('2011-10-03', 56 + 3))
 2288:         assert_equal(
 2289:             np.busday_offset('2011-10-03', 57, holidays=holidays),
 2290:             np.busday_offset('2011-10-03', 57 + 4))
 2291:         assert_equal(
 2292:             np.busday_offset('2011-10-03', 60, holidays=holidays),
 2293:             np.busday_offset('2011-10-03', 60 + 4))
 2294:         assert_equal(
 2295:             np.busday_offset('2011-10-03', 61, holidays=holidays),
 2296:             np.busday_offset('2011-10-03', 61 + 5))
 2297:         assert_equal(
 2298:             np.busday_offset('2011-10-03', 61, busdaycal=bdd),
 2299:             np.busday_offset('2011-10-03', 61 + 5))
 2300:         # A bigger backward jump across more than one week/holiday
 2301:         assert_equal(
 2302:             np.busday_offset('2012-01-03', -1, holidays=holidays),
 2303:             np.busday_offset('2012-01-03', -1 - 1))
 2304:         assert_equal(
 2305:             np.busday_offset('2012-01-03', -4, holidays=holidays),
 2306:             np.busday_offset('2012-01-03', -4 - 1))
 2307:         assert_equal(
 2308:             np.busday_offset('2012-01-03', -5, holidays=holidays),
 2309:             np.busday_offset('2012-01-03', -5 - 2))
 2310:         assert_equal(
 2311:             np.busday_offset('2012-01-03', -25, holidays=holidays),
 2312:             np.busday_offset('2012-01-03', -25 - 2))
 2313:         assert_equal(
 2314:             np.busday_offset('2012-01-03', -26, holidays=holidays),
 2315:             np.busday_offset('2012-01-03', -26 - 3))
 2316:         assert_equal(
 2317:             np.busday_offset('2012-01-03', -33, holidays=holidays),
 2318:             np.busday_offset('2012-01-03', -33 - 3))
 2319:         assert_equal(
 2320:             np.busday_offset('2012-01-03', -34, holidays=holidays),
 2321:             np.busday_offset('2012-01-03', -34 - 4))
 2322:         assert_equal(
 2323:             np.busday_offset('2012-01-03', -56, holidays=holidays),
 2324:             np.busday_offset('2012-01-03', -56 - 4))
 2325:         assert_equal(
 2326:             np.busday_offset('2012-01-03', -57, holidays=holidays),
 2327:             np.busday_offset('2012-01-03', -57 - 5))
 2328:         assert_equal(
 2329:             np.busday_offset('2012-01-03', -57, busdaycal=bdd),
 2330:             np.busday_offset('2012-01-03', -57 - 5))
 2331: 
 2332:         # Can't supply both a weekmask/holidays and busdaycal
 2333:         assert_raises(ValueError, np.busday_offset, '2012-01-03', -15,
 2334:                         weekmask='1111100', busdaycal=bdd)
 2335:         assert_raises(ValueError, np.busday_offset, '2012-01-03', -15,
 2336:                         holidays=holidays, busdaycal=bdd)
 2337: 
 2338:         # Roll with the holidays
 2339:         assert_equal(
 2340:             np.busday_offset('2011-12-25', 0,
 2341:                 roll='forward', holidays=holidays),
 2342:             np.datetime64('2011-12-27'))
 2343:         assert_equal(
 2344:             np.busday_offset('2011-12-26', 0,
 2345:                 roll='forward', holidays=holidays),
 2346:             np.datetime64('2011-12-27'))
 2347:         assert_equal(
 2348:             np.busday_offset('2011-12-26', 0,
 2349:                 roll='backward', holidays=holidays),
 2350:             np.datetime64('2011-12-23'))
 2351:         assert_equal(
 2352:             np.busday_offset('2012-02-27', 0,
 2353:                 roll='modifiedfollowing',
 2354:                 holidays=['2012-02-27', '2012-02-26', '2012-02-28',
 2355:                           '2012-03-01', '2012-02-29']),
 2356:             np.datetime64('2012-02-24'))
 2357:         assert_equal(
 2358:             np.busday_offset('2012-03-06', 0,
 2359:                 roll='modifiedpreceding',
 2360:                 holidays=['2012-03-02', '2012-03-03', '2012-03-01',
 2361:                           '2012-03-05', '2012-03-07', '2012-03-06']),
 2362:             np.datetime64('2012-03-08'))
 2363: 
 2364:     def test_datetime_busday_holidays_count(self):
 2365:         holidays = ['2011-01-01', '2011-10-10', '2011-11-11', '2011-11-24',
 2366:                     '2011-12-25', '2011-05-30', '2011-02-21', '2011-01-17',
 2367:                     '2011-12-26', '2012-01-02', '2011-02-21', '2011-05-30',
 2368:                     '2011-07-01', '2011-07-04', '2011-09-05', '2011-10-10']
 2369:         bdd = np.busdaycalendar(weekmask='1111100', holidays=holidays)
 2370: 
 2371:         # Validate against busday_offset broadcast against
 2372:         # a range of offsets
 2373:         dates = np.busday_offset('2011-01-01', np.arange(366),
 2374:                         roll='forward', busdaycal=bdd)
 2375:         assert_equal(np.busday_count('2011-01-01', dates, busdaycal=bdd),
 2376:                      np.arange(366))
 2377:         # Returns negative value when reversed
 2378:         # -1 since the '2011-01-01' is not a busday
 2379:         assert_equal(np.busday_count(dates, '2011-01-01', busdaycal=bdd),
 2380:                      -np.arange(366) - 1)
 2381: 
 2382:         # 2011-12-31 is a saturday
 2383:         dates = np.busday_offset('2011-12-31', -np.arange(366),
 2384:                         roll='forward', busdaycal=bdd)
 2385:         # only the first generated date is in the future of 2011-12-31
 2386:         expected = np.arange(366)
 2387:         expected[0] = -1
 2388:         assert_equal(np.busday_count(dates, '2011-12-31', busdaycal=bdd),
 2389:                      expected)
 2390:         # Returns negative value when reversed
 2391:         expected = -np.arange(366) + 1
 2392:         expected[0] = 0
 2393:         assert_equal(np.busday_count('2011-12-31', dates, busdaycal=bdd),
 2394:                      expected)
 2395: 
 2396:         # Can't supply both a weekmask/holidays and busdaycal
 2397:         assert_raises(ValueError, np.busday_offset, '2012-01-03', '2012-02-03',
 2398:                         weekmask='1111100', busdaycal=bdd)
 2399:         assert_raises(ValueError, np.busday_offset, '2012-01-03', '2012-02-03',
 2400:                         holidays=holidays, busdaycal=bdd)
 2401: 
 2402:         # Number of Mondays in March 2011
 2403:         assert_equal(np.busday_count('2011-03', '2011-04', weekmask='Mon'), 4)
 2404:         # Returns negative value when reversed
 2405:         assert_equal(np.busday_count('2011-04', '2011-03', weekmask='Mon'), -4)
 2406: 
 2407:         sunday = np.datetime64('2023-03-05')
 2408:         monday = sunday + 1
 2409:         friday = sunday + 5
 2410:         saturday = sunday + 6
 2411:         assert_equal(np.busday_count(sunday, monday), 0)
 2412:         assert_equal(np.busday_count(monday, sunday), -1)
 2413: 
 2414:         assert_equal(np.busday_count(friday, saturday), 1)
 2415:         assert_equal(np.busday_count(saturday, friday), 0)
 2416: 
 2417:     def test_datetime_is_busday(self):
 2418:         holidays = ['2011-01-01', '2011-10-10', '2011-11-11', '2011-11-24',
 2419:                     '2011-12-25', '2011-05-30', '2011-02-21', '2011-01-17',
 2420:                     '2011-12-26', '2012-01-02', '2011-02-21', '2011-05-30',
 2421:                     '2011-07-01', '2011-07-04', '2011-09-05', '2011-10-10',
 2422:                     'NaT']
 2423:         bdd = np.busdaycalendar(weekmask='1111100', holidays=holidays)
 2424: 
 2425:         # Weekend/weekday tests
 2426:         assert_equal(np.is_busday('2011-01-01'), False)
 2427:         assert_equal(np.is_busday('2011-01-02'), False)
 2428:         assert_equal(np.is_busday('2011-01-03'), True)
 2429: 
 2430:         # All the holidays are not business days
 2431:         assert_equal(np.is_busday(holidays, busdaycal=bdd),
 2432:                      np.zeros(len(holidays), dtype='?'))
 2433: 
 2434:     def test_datetime_y2038(self):
 2435:         msg = "no explicit representation of timezones available for " \
 2436:               "np.datetime64"
 2437:         # Test parsing on either side of the Y2038 boundary
 2438:         a = np.datetime64('2038-01-19T03:14:07')
 2439:         assert_equal(a.view(np.int64), 2**31 - 1)
 2440:         a = np.datetime64('2038-01-19T03:14:08')
 2441:         assert_equal(a.view(np.int64), 2**31)
 2442: 
 2443:         # Test parsing on either side of the Y2038 boundary with
 2444:         # a manually specified timezone offset
 2445:         with pytest.warns(UserWarning, match=msg):
 2446:             a = np.datetime64('2038-01-19T04:14:07+0100')
 2447:             assert_equal(a.view(np.int64), 2**31 - 1)
 2448:         with pytest.warns(UserWarning, match=msg):
 2449:             a = np.datetime64('2038-01-19T04:14:08+0100')
 2450:             assert_equal(a.view(np.int64), 2**31)
 2451: 
 2452:         # Test parsing a date after Y2038
 2453:         a = np.datetime64('2038-01-20T13:21:14')
 2454:         assert_equal(str(a), '2038-01-20T13:21:14')
 2455: 
 2456:     def test_isnat(self):
 2457:         assert_(np.isnat(np.datetime64('NaT', 'ms')))
 2458:         assert_(np.isnat(np.datetime64('NaT', 'ns')))
 2459:         assert_(not np.isnat(np.datetime64('2038-01-19T03:14:07')))
 2460: 
 2461:         assert_(np.isnat(np.timedelta64('NaT', "ms")))
 2462:         assert_(not np.isnat(np.timedelta64(34, "ms")))
 2463: 
 2464:         res = np.array([False, False, True])
 2465:         for unit in ['Y', 'M', 'W', 'D',
 2466:                      'h', 'm', 's', 'ms', 'us',
 2467:                      'ns', 'ps', 'fs', 'as']:
 2468:             arr = np.array([123, -321, "NaT"], dtype=f'<datetime64[{unit}]')
 2469:             assert_equal(np.isnat(arr), res)
 2470:             arr = np.array([123, -321, "NaT"], dtype=f'>datetime64[{unit}]')
 2471:             assert_equal(np.isnat(arr), res)
 2472:             arr = np.array([123, -321, "NaT"], dtype=f'<timedelta64[{unit}]')
 2473:             assert_equal(np.isnat(arr), res)
 2474:             arr = np.array([123, -321, "NaT"], dtype=f'>timedelta64[{unit}]')
 2475:             assert_equal(np.isnat(arr), res)
 2476: 
 2477:     def test_isnat_error(self):
 2478:         # Test that only datetime dtype arrays are accepted
 2479:         for t in np.typecodes["All"]:
 2480:             if t in np.typecodes["Datetime"]:
 2481:                 continue
 2482:             assert_raises(TypeError, np.isnat, np.zeros(10, t))
 2483: 
 2484:     def test_isfinite_scalar(self):
 2485:         assert_(not np.isfinite(np.datetime64('NaT', 'ms')))
 2486:         assert_(not np.isfinite(np.datetime64('NaT', 'ns')))
 2487:         assert_(np.isfinite(np.datetime64('2038-01-19T03:14:07')))
 2488: 
 2489:         assert_(not np.isfinite(np.timedelta64('NaT', "ms")))
 2490:         assert_(np.isfinite(np.timedelta64(34, "ms")))
 2491: 
 2492:     @pytest.mark.parametrize('unit', ['Y', 'M', 'W', 'D', 'h', 'm', 's', 'ms',
 2493:                                       'us', 'ns', 'ps', 'fs', 'as'])
 2494:     @pytest.mark.parametrize('dstr', ['<datetime64[%s]', '>datetime64[%s]',
 2495:                                       '<timedelta64[%s]', '>timedelta64[%s]'])
 2496:     def test_isfinite_isinf_isnan_units(self, unit, dstr):
 2497:         '''check isfinite, isinf, isnan for all units of <M, >M, <m, >m dtypes
 2498:         '''
 2499:         arr_val = [123, -321, "NaT"]
 2500:         arr = np.array(arr_val, dtype=(dstr % unit))
 2501:         pos = np.array([True, True, False])
 2502:         neg = np.array([False, False, True])
 2503:         false = np.array([False, False, False])
 2504:         assert_equal(np.isfinite(arr), pos)
 2505:         assert_equal(np.isinf(arr), false)
 2506:         assert_equal(np.isnan(arr), neg)
 2507: 
 2508:     def test_assert_equal(self):
 2509:         assert_raises(AssertionError, assert_equal,
 2510:                 np.datetime64('nat'), np.timedelta64('nat'))
 2511: 
 2512:     def test_corecursive_input(self):
 2513:         # construct a co-recursive list
 2514:         a, b = [], []
 2515:         a.append(b)
 2516:         b.append(a)
 2517:         obj_arr = np.array([None])
 2518:         obj_arr[0] = a
 2519: 
 2520:         # At some point this caused a stack overflow (gh-11154). Now raises
 2521:         # ValueError since the nested list cannot be converted to a datetime.
 2522:         assert_raises(ValueError, obj_arr.astype, 'M8')
 2523:         assert_raises(ValueError, obj_arr.astype, 'm8')
 2524: 
 2525:     @pytest.mark.parametrize("shape", [(), (1,)])
 2526:     def test_discovery_from_object_array(self, shape):
 2527:         arr = np.array("2020-10-10", dtype=object).reshape(shape)
 2528:         res = np.array("2020-10-10", dtype="M8").reshape(shape)
 2529:         assert res.dtype == np.dtype("M8[D]")
 2530:         assert_equal(arr.astype("M8"), res)
 2531:         arr[...] = np.bytes_("2020-10-10")  # try a numpy string type
 2532:         assert_equal(arr.astype("M8"), res)
 2533:         arr = arr.astype("S")
 2534:         assert_equal(arr.astype("S").astype("M8"), res)
 2535: 
 2536:     @pytest.mark.parametrize("time_unit", [
 2537:         "Y", "M", "W", "D", "h", "m", "s", "ms", "us", "ns", "ps", "fs", "as",
 2538:         # compound units
 2539:         "10D", "2M",
 2540:     ])
 2541:     def test_limit_symmetry(self, time_unit):
 2542:         """
 2543:         Dates should have symmetric limits around the unix epoch at +/-np.int64
 2544:         """
 2545:         epoch = np.datetime64(0, time_unit)
 2546:         latest = np.datetime64(np.iinfo(np.int64).max, time_unit)
 2547:         earliest = np.datetime64(-np.iinfo(np.int64).max, time_unit)
 2548: 
 2549:         # above should not have overflowed
 2550:         assert earliest < epoch < latest
 2551: 
 2552:     @pytest.mark.parametrize("time_unit", [
 2553:         "Y", "M",
 2554:         pytest.param("W", marks=pytest.mark.xfail(reason="gh-13197")),
 2555:         "D", "h", "m",
 2556:         "s", "ms", "us", "ns", "ps", "fs", "as",
 2557:         pytest.param("10D", marks=pytest.mark.xfail(reason="similar to gh-13197")),
 2558:     ])
 2559:     @pytest.mark.parametrize("sign", [-1, 1])
 2560:     def test_limit_str_roundtrip(self, time_unit, sign):
 2561:         """
 2562:         Limits should roundtrip when converted to strings.
 2563: 
 2564:         This tests the conversion to and from npy_datetimestruct.
 2565:         """
 2566:         # TODO: add absolute (gold standard) time span limit strings
 2567:         limit = np.datetime64(np.iinfo(np.int64).max * sign, time_unit)
 2568: 
 2569:         # Convert to string and back. Explicit unit needed since the day and
 2570:         # week reprs are not distinguishable.
 2571:         limit_via_str = np.datetime64(str(limit), time_unit)
 2572:         assert limit_via_str == limit
 2573: 
 2574:     def test_datetime_hash_nat(self):
 2575:         nat1 = np.datetime64()
 2576:         nat2 = np.datetime64()
 2577:         assert nat1 is not nat2
 2578:         assert nat1 != nat2
 2579:         assert hash(nat1) != hash(nat2)
 2580: 
 2581:     @pytest.mark.parametrize('unit', ('Y', 'M', 'W', 'D', 'h', 'm', 's', 'ms', 'us'))
 2582:     def test_datetime_hash_weeks(self, unit):
 2583:         dt = np.datetime64(2348, 'W')  # 2015-01-01
 2584:         dt2 = np.datetime64(dt, unit)
 2585:         _assert_equal_hash(dt, dt2)
 2586: 
 2587:         dt3 = np.datetime64(int(dt2.astype(int)) + 1, unit)
 2588:         assert hash(dt) != hash(dt3)  # doesn't collide
 2589: 
 2590:     @pytest.mark.parametrize('unit', ('h', 'm', 's', 'ms', 'us'))
 2591:     def test_datetime_hash_weeks_vs_pydatetime(self, unit):
 2592:         dt = np.datetime64(2348, 'W')  # 2015-01-01
 2593:         dt2 = np.datetime64(dt, unit)
 2594:         pydt = dt2.astype(datetime.datetime)
 2595:         assert isinstance(pydt, datetime.datetime)
 2596:         _assert_equal_hash(pydt, dt2)
 2597: 
 2598:     @pytest.mark.parametrize('unit', ('Y', 'M', 'W', 'D', 'h', 'm', 's', 'ms', 'us'))
 2599:     def test_datetime_hash_big_negative(self, unit):
 2600:         dt = np.datetime64(-102894, 'W')  # -002-01-01
 2601:         dt2 = np.datetime64(dt, unit)
 2602:         _assert_equal_hash(dt, dt2)
 2603: 
 2604:     # can only go down to "fs" before integer overflow
 2605:     @pytest.mark.parametrize('unit', ('m', 's', 'ms', 'us', 'ns', 'ps', 'fs'))
 2606:     def test_datetime_hash_minutes(self, unit):
 2607:         dt = np.datetime64(3, 'm')
 2608:         dt2 = np.datetime64(dt, unit)
 2609:         _assert_equal_hash(dt, dt2)
 2610: 
 2611:     @pytest.mark.parametrize('unit', ('ns', 'ps', 'fs', 'as'))
 2612:     def test_datetime_hash_ns(self, unit):
 2613:         dt = np.datetime64(3, 'ns')
 2614:         dt2 = np.datetime64(dt, unit)
 2615:         _assert_equal_hash(dt, dt2)
 2616: 
 2617:         dt3 = np.datetime64(int(dt2.astype(int)) + 1, unit)
 2618:         assert hash(dt) != hash(dt3)  # doesn't collide
 2619: 
 2620:     @pytest.mark.parametrize('wk', range(500000, 500010))  # 11552-09-04
 2621:     @pytest.mark.parametrize('unit', ('W', 'D', 'h', 'm', 's', 'ms', 'us'))
 2622:     def test_datetime_hash_big_positive(self, wk, unit):
 2623:         dt = np.datetime64(wk, 'W')
 2624:         dt2 = np.datetime64(dt, unit)
 2625:         _assert_equal_hash(dt, dt2)
 2626: 
 2627:     def test_timedelta_hash_generic(self):
 2628:         assert_raises(ValueError, hash, np.timedelta64(123))  # generic
 2629: 
 2630:     @pytest.mark.parametrize('unit', ('Y', 'M'))
 2631:     def test_timedelta_hash_year_month(self, unit):
 2632:         td = np.timedelta64(45, 'Y')
 2633:         td2 = np.timedelta64(td, unit)
 2634:         _assert_equal_hash(td, td2)
 2635: 
 2636:     @pytest.mark.parametrize('unit', ('W', 'D', 'h', 'm', 's', 'ms', 'us'))
 2637:     def test_timedelta_hash_weeks(self, unit):
 2638:         td = np.timedelta64(10, 'W')
 2639:         td2 = np.timedelta64(td, unit)
 2640:         _assert_equal_hash(td, td2)
 2641: 
 2642:         td3 = np.timedelta64(int(td2.astype(int)) + 1, unit)
 2643:         assert hash(td) != hash(td3)  # doesn't collide
 2644: 
 2645:     @pytest.mark.parametrize('unit', ('W', 'D', 'h', 'm', 's', 'ms', 'us'))
 2646:     def test_timedelta_hash_weeks_vs_pydelta(self, unit):
 2647:         td = np.timedelta64(10, 'W')
 2648:         td2 = np.timedelta64(td, unit)
 2649:         pytd = td2.astype(datetime.timedelta)
 2650:         assert isinstance(pytd, datetime.timedelta)
 2651:         _assert_equal_hash(pytd, td2)
 2652: 
 2653:     @pytest.mark.parametrize('unit', ('ms', 'us', 'ns', 'ps', 'fs', 'as'))
 2654:     def test_timedelta_hash_ms(self, unit):
 2655:         td = np.timedelta64(3, 'ms')
 2656:         td2 = np.timedelta64(td, unit)
 2657:         _assert_equal_hash(td, td2)
 2658: 
 2659:         td3 = np.timedelta64(int(td2.astype(int)) + 1, unit)
 2660:         assert hash(td) != hash(td3)  # doesn't collide
 2661: 
 2662:     @pytest.mark.parametrize('wk', range(500000, 500010))
 2663:     @pytest.mark.parametrize('unit', ('W', 'D', 'h', 'm', 's', 'ms', 'us'))
 2664:     def test_timedelta_hash_big_positive(self, wk, unit):
 2665:         td = np.timedelta64(wk, 'W')
 2666:         td2 = np.timedelta64(td, unit)
 2667:         _assert_equal_hash(td, td2)
 2668: 
 2669: 
 2670: class TestDateTimeData:
 2671: 
 2672:     def test_basic(self):
 2673:         a = np.array(['1980-03-23'], dtype=np.datetime64)
 2674:         assert_equal(np.datetime_data(a.dtype), ('D', 1))
 2675: 
 2676:     def test_bytes(self):
 2677:         # byte units are converted to unicode
 2678:         dt = np.datetime64('2000', (b'ms', 5))
 2679:         assert np.datetime_data(dt.dtype) == ('ms', 5)
 2680: 
 2681:         dt = np.datetime64('2000', b'5ms')
 2682:         assert np.datetime_data(dt.dtype) == ('ms', 5)
 2683: 
 2684:     def test_non_ascii(self):
 2685:         # Ојs is normalized to Ој
 2686:         dt = np.datetime64('2000', ('Ојs', 5))
 2687:         assert np.datetime_data(dt.dtype) == ('us', 5)
 2688: 
 2689:         dt = np.datetime64('2000', '5Ојs')
 2690:         assert np.datetime_data(dt.dtype) == ('us', 5)
 2691: 
 2692: 
 2693: def test_comparisons_return_not_implemented():
 2694:     # GH#17017
 2695: 
 2696:     class custom:
 2697:         __array_priority__ = 10000
 2698: 
 2699:     obj = custom()
 2700: 
 2701:     dt = np.datetime64('2000', 'ns')
 2702:     td = dt - dt
 2703: 
 2704:     for item in [dt, td]:
 2705:         assert item.__eq__(obj) is NotImplemented
 2706:         assert item.__ne__(obj) is NotImplemented
 2707:         assert item.__le__(obj) is NotImplemented
 2708:         assert item.__lt__(obj) is NotImplemented
 2709:         assert item.__ge__(obj) is NotImplemented
 2710:         assert item.__gt__(obj) is NotImplemented
