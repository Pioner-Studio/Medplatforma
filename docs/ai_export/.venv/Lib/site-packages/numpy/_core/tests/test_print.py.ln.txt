    1: import sys
    2: from io import StringIO
    3: 
    4: import pytest
    5: 
    6: import numpy as np
    7: from numpy._core.tests._locales import CommaDecimalPointLocale
    8: from numpy.testing import IS_MUSL, assert_, assert_equal
    9: 
   10: _REF = {np.inf: 'inf', -np.inf: '-inf', np.nan: 'nan'}
   11: 
   12: 
   13: @pytest.mark.parametrize('tp', [np.float32, np.double, np.longdouble])
   14: def test_float_types(tp):
   15:     """ Check formatting.
   16: 
   17:         This is only for the str function, and only for simple types.
   18:         The precision of np.float32 and np.longdouble aren't the same as the
   19:         python float precision.
   20: 
   21:     """
   22:     for x in [0, 1, -1, 1e20]:
   23:         assert_equal(str(tp(x)), str(float(x)),
   24:                      err_msg=f'Failed str formatting for type {tp}')
   25: 
   26:     if tp(1e16).itemsize > 4:
   27:         assert_equal(str(tp(1e16)), str(float('1e16')),
   28:                      err_msg=f'Failed str formatting for type {tp}')
   29:     else:
   30:         ref = '1e+16'
   31:         assert_equal(str(tp(1e16)), ref,
   32:                      err_msg=f'Failed str formatting for type {tp}')
   33: 
   34: 
   35: @pytest.mark.parametrize('tp', [np.float32, np.double, np.longdouble])
   36: def test_nan_inf_float(tp):
   37:     """ Check formatting of nan & inf.
   38: 
   39:         This is only for the str function, and only for simple types.
   40:         The precision of np.float32 and np.longdouble aren't the same as the
   41:         python float precision.
   42: 
   43:     """
   44:     for x in [np.inf, -np.inf, np.nan]:
   45:         assert_equal(str(tp(x)), _REF[x],
   46:                      err_msg=f'Failed str formatting for type {tp}')
   47: 
   48: 
   49: @pytest.mark.parametrize('tp', [np.complex64, np.cdouble, np.clongdouble])
   50: def test_complex_types(tp):
   51:     """Check formatting of complex types.
   52: 
   53:         This is only for the str function, and only for simple types.
   54:         The precision of np.float32 and np.longdouble aren't the same as the
   55:         python float precision.
   56: 
   57:     """
   58:     for x in [0, 1, -1, 1e20]:
   59:         assert_equal(str(tp(x)), str(complex(x)),
   60:                      err_msg=f'Failed str formatting for type {tp}')
   61:         assert_equal(str(tp(x * 1j)), str(complex(x * 1j)),
   62:                      err_msg=f'Failed str formatting for type {tp}')
   63:         assert_equal(str(tp(x + x * 1j)), str(complex(x + x * 1j)),
   64:                      err_msg=f'Failed str formatting for type {tp}')
   65: 
   66:     if tp(1e16).itemsize > 8:
   67:         assert_equal(str(tp(1e16)), str(complex(1e16)),
   68:                      err_msg=f'Failed str formatting for type {tp}')
   69:     else:
   70:         ref = '(1e+16+0j)'
   71:         assert_equal(str(tp(1e16)), ref,
   72:                      err_msg=f'Failed str formatting for type {tp}')
   73: 
   74: 
   75: @pytest.mark.parametrize('dtype', [np.complex64, np.cdouble, np.clongdouble])
   76: def test_complex_inf_nan(dtype):
   77:     """Check inf/nan formatting of complex types."""
   78:     TESTS = {
   79:         complex(np.inf, 0): "(inf+0j)",
   80:         complex(0, np.inf): "infj",
   81:         complex(-np.inf, 0): "(-inf+0j)",
   82:         complex(0, -np.inf): "-infj",
   83:         complex(np.inf, 1): "(inf+1j)",
   84:         complex(1, np.inf): "(1+infj)",
   85:         complex(-np.inf, 1): "(-inf+1j)",
   86:         complex(1, -np.inf): "(1-infj)",
   87:         complex(np.nan, 0): "(nan+0j)",
   88:         complex(0, np.nan): "nanj",
   89:         complex(-np.nan, 0): "(nan+0j)",
   90:         complex(0, -np.nan): "nanj",
   91:         complex(np.nan, 1): "(nan+1j)",
   92:         complex(1, np.nan): "(1+nanj)",
   93:         complex(-np.nan, 1): "(nan+1j)",
   94:         complex(1, -np.nan): "(1+nanj)",
   95:     }
   96:     for c, s in TESTS.items():
   97:         assert_equal(str(dtype(c)), s)
   98: 
   99: 
  100: # print tests
  101: def _test_redirected_print(x, tp, ref=None):
  102:     file = StringIO()
  103:     file_tp = StringIO()
  104:     stdout = sys.stdout
  105:     try:
  106:         sys.stdout = file_tp
  107:         print(tp(x))
  108:         sys.stdout = file
  109:         if ref:
  110:             print(ref)
  111:         else:
  112:             print(x)
  113:     finally:
  114:         sys.stdout = stdout
  115: 
  116:     assert_equal(file.getvalue(), file_tp.getvalue(),
  117:                  err_msg=f'print failed for type{tp}')
  118: 
  119: 
  120: @pytest.mark.parametrize('tp', [np.float32, np.double, np.longdouble])
  121: def test_float_type_print(tp):
  122:     """Check formatting when using print """
  123:     for x in [0, 1, -1, 1e20]:
  124:         _test_redirected_print(float(x), tp)
  125: 
  126:     for x in [np.inf, -np.inf, np.nan]:
  127:         _test_redirected_print(float(x), tp, _REF[x])
  128: 
  129:     if tp(1e16).itemsize > 4:
  130:         _test_redirected_print(1e16, tp)
  131:     else:
  132:         ref = '1e+16'
  133:         _test_redirected_print(1e16, tp, ref)
  134: 
  135: 
  136: @pytest.mark.parametrize('tp', [np.complex64, np.cdouble, np.clongdouble])
  137: def test_complex_type_print(tp):
  138:     """Check formatting when using print """
  139:     # We do not create complex with inf/nan directly because the feature is
  140:     # missing in python < 2.6
  141:     for x in [0, 1, -1, 1e20]:
  142:         _test_redirected_print(complex(x), tp)
  143: 
  144:     if tp(1e16).itemsize > 8:
  145:         _test_redirected_print(complex(1e16), tp)
  146:     else:
  147:         ref = '(1e+16+0j)'
  148:         _test_redirected_print(complex(1e16), tp, ref)
  149: 
  150:     _test_redirected_print(complex(np.inf, 1), tp, '(inf+1j)')
  151:     _test_redirected_print(complex(-np.inf, 1), tp, '(-inf+1j)')
  152:     _test_redirected_print(complex(-np.nan, 1), tp, '(nan+1j)')
  153: 
  154: 
  155: def test_scalar_format():
  156:     """Test the str.format method with NumPy scalar types"""
  157:     tests = [('{0}', True, np.bool),
  158:             ('{0}', False, np.bool),
  159:             ('{0:d}', 130, np.uint8),
  160:             ('{0:d}', 50000, np.uint16),
  161:             ('{0:d}', 3000000000, np.uint32),
  162:             ('{0:d}', 15000000000000000000, np.uint64),
  163:             ('{0:d}', -120, np.int8),
  164:             ('{0:d}', -30000, np.int16),
  165:             ('{0:d}', -2000000000, np.int32),
  166:             ('{0:d}', -7000000000000000000, np.int64),
  167:             ('{0:g}', 1.5, np.float16),
  168:             ('{0:g}', 1.5, np.float32),
  169:             ('{0:g}', 1.5, np.float64),
  170:             ('{0:g}', 1.5, np.longdouble),
  171:             ('{0:g}', 1.5 + 0.5j, np.complex64),
  172:             ('{0:g}', 1.5 + 0.5j, np.complex128),
  173:             ('{0:g}', 1.5 + 0.5j, np.clongdouble)]
  174: 
  175:     for (fmat, val, valtype) in tests:
  176:         try:
  177:             assert_equal(fmat.format(val), fmat.format(valtype(val)),
  178:                     f"failed with val {val}, type {valtype}")
  179:         except ValueError as e:
  180:             assert_(False,
  181:                "format raised exception (fmt='%s', val=%s, type=%s, exc='%s')" %
  182:                             (fmat, repr(val), repr(valtype), str(e)))
  183: 
  184: 
  185: #
  186: # Locale tests: scalar types formatting should be independent of the locale
  187: #
  188: 
  189: class TestCommaDecimalPointLocale(CommaDecimalPointLocale):
  190: 
  191:     def test_locale_single(self):
  192:         assert_equal(str(np.float32(1.2)), str(1.2))
  193: 
  194:     def test_locale_double(self):
  195:         assert_equal(str(np.double(1.2)), str(1.2))
  196: 
  197:     @pytest.mark.skipif(IS_MUSL,
  198:                         reason="test flaky on musllinux")
  199:     def test_locale_longdouble(self):
  200:         assert_equal(str(np.longdouble('1.2')), str(1.2))
