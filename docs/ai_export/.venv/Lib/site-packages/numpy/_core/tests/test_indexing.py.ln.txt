    1: import functools
    2: import operator
    3: import sys
    4: import warnings
    5: from itertools import product
    6: 
    7: import pytest
    8: from numpy._core._multiarray_tests import array_indexing
    9: 
   10: import numpy as np
   11: from numpy.exceptions import ComplexWarning, VisibleDeprecationWarning
   12: from numpy.testing import (
   13:     HAS_REFCOUNT,
   14:     assert_,
   15:     assert_array_equal,
   16:     assert_equal,
   17:     assert_raises,
   18:     assert_raises_regex,
   19:     assert_warns,
   20: )
   21: 
   22: 
   23: class TestIndexing:
   24:     def test_index_no_floats(self):
   25:         a = np.array([[[5]]])
   26: 
   27:         assert_raises(IndexError, lambda: a[0.0])
   28:         assert_raises(IndexError, lambda: a[0, 0.0])
   29:         assert_raises(IndexError, lambda: a[0.0, 0])
   30:         assert_raises(IndexError, lambda: a[0.0, :])
   31:         assert_raises(IndexError, lambda: a[:, 0.0])
   32:         assert_raises(IndexError, lambda: a[:, 0.0, :])
   33:         assert_raises(IndexError, lambda: a[0.0, :, :])
   34:         assert_raises(IndexError, lambda: a[0, 0, 0.0])
   35:         assert_raises(IndexError, lambda: a[0.0, 0, 0])
   36:         assert_raises(IndexError, lambda: a[0, 0.0, 0])
   37:         assert_raises(IndexError, lambda: a[-1.4])
   38:         assert_raises(IndexError, lambda: a[0, -1.4])
   39:         assert_raises(IndexError, lambda: a[-1.4, 0])
   40:         assert_raises(IndexError, lambda: a[-1.4, :])
   41:         assert_raises(IndexError, lambda: a[:, -1.4])
   42:         assert_raises(IndexError, lambda: a[:, -1.4, :])
   43:         assert_raises(IndexError, lambda: a[-1.4, :, :])
   44:         assert_raises(IndexError, lambda: a[0, 0, -1.4])
   45:         assert_raises(IndexError, lambda: a[-1.4, 0, 0])
   46:         assert_raises(IndexError, lambda: a[0, -1.4, 0])
   47:         assert_raises(IndexError, lambda: a[0.0:, 0.0])
   48:         assert_raises(IndexError, lambda: a[0.0:, 0.0, :])
   49: 
   50:     def test_slicing_no_floats(self):
   51:         a = np.array([[5]])
   52: 
   53:         # start as float.
   54:         assert_raises(TypeError, lambda: a[0.0:])
   55:         assert_raises(TypeError, lambda: a[0:, 0.0:2])
   56:         assert_raises(TypeError, lambda: a[0.0::2, :0])
   57:         assert_raises(TypeError, lambda: a[0.0:1:2, :])
   58:         assert_raises(TypeError, lambda: a[:, 0.0:])
   59:         # stop as float.
   60:         assert_raises(TypeError, lambda: a[:0.0])
   61:         assert_raises(TypeError, lambda: a[:0, 1:2.0])
   62:         assert_raises(TypeError, lambda: a[:0.0:2, :0])
   63:         assert_raises(TypeError, lambda: a[:0.0, :])
   64:         assert_raises(TypeError, lambda: a[:, 0:4.0:2])
   65:         # step as float.
   66:         assert_raises(TypeError, lambda: a[::1.0])
   67:         assert_raises(TypeError, lambda: a[0:, :2:2.0])
   68:         assert_raises(TypeError, lambda: a[1::4.0, :0])
   69:         assert_raises(TypeError, lambda: a[::5.0, :])
   70:         assert_raises(TypeError, lambda: a[:, 0:4:2.0])
   71:         # mixed.
   72:         assert_raises(TypeError, lambda: a[1.0:2:2.0])
   73:         assert_raises(TypeError, lambda: a[1.0::2.0])
   74:         assert_raises(TypeError, lambda: a[0:, :2.0:2.0])
   75:         assert_raises(TypeError, lambda: a[1.0:1:4.0, :0])
   76:         assert_raises(TypeError, lambda: a[1.0:5.0:5.0, :])
   77:         assert_raises(TypeError, lambda: a[:, 0.4:4.0:2.0])
   78:         # should still get the DeprecationWarning if step = 0.
   79:         assert_raises(TypeError, lambda: a[::0.0])
   80: 
   81:     def test_index_no_array_to_index(self):
   82:         # No non-scalar arrays.
   83:         a = np.array([[[1]]])
   84: 
   85:         assert_raises(TypeError, lambda: a[a:a:a])
   86: 
   87:     def test_none_index(self):
   88:         # `None` index adds newaxis
   89:         a = np.array([1, 2, 3])
   90:         assert_equal(a[None], a[np.newaxis])
   91:         assert_equal(a[None].ndim, a.ndim + 1)
   92: 
   93:     def test_empty_tuple_index(self):
   94:         # Empty tuple index creates a view
   95:         a = np.array([1, 2, 3])
   96:         assert_equal(a[()], a)
   97:         assert_(a[()].base is a)
   98:         a = np.array(0)
   99:         assert_(isinstance(a[()], np.int_))
  100: 
  101:     def test_void_scalar_empty_tuple(self):
  102:         s = np.zeros((), dtype='V4')
  103:         assert_equal(s[()].dtype, s.dtype)
  104:         assert_equal(s[()], s)
  105:         assert_equal(type(s[...]), np.ndarray)
  106: 
  107:     def test_same_kind_index_casting(self):
  108:         # Indexes should be cast with same-kind and not safe, even if that
  109:         # is somewhat unsafe. So test various different code paths.
  110:         index = np.arange(5)
  111:         u_index = index.astype(np.uintp)
  112:         arr = np.arange(10)
  113: 
  114:         assert_array_equal(arr[index], arr[u_index])
  115:         arr[u_index] = np.arange(5)
  116:         assert_array_equal(arr, np.arange(10))
  117: 
  118:         arr = np.arange(10).reshape(5, 2)
  119:         assert_array_equal(arr[index], arr[u_index])
  120: 
  121:         arr[u_index] = np.arange(5)[:, None]
  122:         assert_array_equal(arr, np.arange(5)[:, None].repeat(2, axis=1))
  123: 
  124:         arr = np.arange(25).reshape(5, 5)
  125:         assert_array_equal(arr[u_index, u_index], arr[index, index])
  126: 
  127:     def test_empty_fancy_index(self):
  128:         # Empty list index creates an empty array
  129:         # with the same dtype (but with weird shape)
  130:         a = np.array([1, 2, 3])
  131:         assert_equal(a[[]], [])
  132:         assert_equal(a[[]].dtype, a.dtype)
  133: 
  134:         b = np.array([], dtype=np.intp)
  135:         assert_equal(a[[]], [])
  136:         assert_equal(a[[]].dtype, a.dtype)
  137: 
  138:         b = np.array([])
  139:         assert_raises(IndexError, a.__getitem__, b)
  140: 
  141:     def test_gh_26542(self):
  142:         a = np.array([0, 1, 2])
  143:         idx = np.array([2, 1, 0])
  144:         a[idx] = a
  145:         expected = np.array([2, 1, 0])
  146:         assert_equal(a, expected)
  147: 
  148:     def test_gh_26542_2d(self):
  149:         a = np.array([[0, 1, 2]])
  150:         idx_row = np.zeros(3, dtype=int)
  151:         idx_col = np.array([2, 1, 0])
  152:         a[idx_row, idx_col] = a
  153:         expected = np.array([[2, 1, 0]])
  154:         assert_equal(a, expected)
  155: 
  156:     def test_gh_26542_index_overlap(self):
  157:         arr = np.arange(100)
  158:         expected_vals = np.copy(arr[:-10])
  159:         arr[10:] = arr[:-10]
  160:         actual_vals = arr[10:]
  161:         assert_equal(actual_vals, expected_vals)
  162: 
  163:     def test_gh_26844(self):
  164:         expected = [0, 1, 3, 3, 3]
  165:         a = np.arange(5)
  166:         a[2:][a[:-2]] = 3
  167:         assert_equal(a, expected)
  168: 
  169:     def test_gh_26844_segfault(self):
  170:         # check for absence of segfault for:
  171:         # https://github.com/numpy/numpy/pull/26958/files#r1854589178
  172:         a = np.arange(5)
  173:         expected = [0, 1, 3, 3, 3]
  174:         a[2:][None, a[:-2]] = 3
  175:         assert_equal(a, expected)
  176: 
  177:     def test_ellipsis_index(self):
  178:         a = np.array([[1, 2, 3],
  179:                       [4, 5, 6],
  180:                       [7, 8, 9]])
  181:         assert_(a[...] is not a)
  182:         assert_equal(a[...], a)
  183:         # `a[...]` was `a` in numpy <1.9.
  184:         assert_(a[...].base is a)
  185: 
  186:         # Slicing with ellipsis can skip an
  187:         # arbitrary number of dimensions
  188:         assert_equal(a[0, ...], a[0])
  189:         assert_equal(a[0, ...], a[0, :])
  190:         assert_equal(a[..., 0], a[:, 0])
  191: 
  192:         # Slicing with ellipsis always results
  193:         # in an array, not a scalar
  194:         assert_equal(a[0, ..., 1], np.array(2))
  195: 
  196:         # Assignment with `(Ellipsis,)` on 0-d arrays
  197:         b = np.array(1)
  198:         b[(Ellipsis,)] = 2
  199:         assert_equal(b, 2)
  200: 
  201:     def test_single_int_index(self):
  202:         # Single integer index selects one row
  203:         a = np.array([[1, 2, 3],
  204:                       [4, 5, 6],
  205:                       [7, 8, 9]])
  206: 
  207:         assert_equal(a[0], [1, 2, 3])
  208:         assert_equal(a[-1], [7, 8, 9])
  209: 
  210:         # Index out of bounds produces IndexError
  211:         assert_raises(IndexError, a.__getitem__, 1 << 30)
  212:         # Index overflow produces IndexError
  213:         assert_raises(IndexError, a.__getitem__, 1 << 64)
  214: 
  215:     def test_single_bool_index(self):
  216:         # Single boolean index
  217:         a = np.array([[1, 2, 3],
  218:                       [4, 5, 6],
  219:                       [7, 8, 9]])
  220: 
  221:         assert_equal(a[np.array(True)], a[None])
  222:         assert_equal(a[np.array(False)], a[None][0:0])
  223: 
  224:     def test_boolean_shape_mismatch(self):
  225:         arr = np.ones((5, 4, 3))
  226: 
  227:         index = np.array([True])
  228:         assert_raises(IndexError, arr.__getitem__, index)
  229: 
  230:         index = np.array([False] * 6)
  231:         assert_raises(IndexError, arr.__getitem__, index)
  232: 
  233:         index = np.zeros((4, 4), dtype=bool)
  234:         assert_raises(IndexError, arr.__getitem__, index)
  235: 
  236:         assert_raises(IndexError, arr.__getitem__, (slice(None), index))
  237: 
  238:     def test_boolean_indexing_onedim(self):
  239:         # Indexing a 2-dimensional array with
  240:         # boolean array of length one
  241:         a = np.array([[0., 0., 0.]])
  242:         b = np.array([True], dtype=bool)
  243:         assert_equal(a[b], a)
  244:         # boolean assignment
  245:         a[b] = 1.
  246:         assert_equal(a, [[1., 1., 1.]])
  247: 
  248:     def test_boolean_assignment_value_mismatch(self):
  249:         # A boolean assignment should fail when the shape of the values
  250:         # cannot be broadcast to the subscription. (see also gh-3458)
  251:         a = np.arange(4)
  252: 
  253:         def f(a, v):
  254:             a[a > -1] = v
  255: 
  256:         assert_raises(ValueError, f, a, [])
  257:         assert_raises(ValueError, f, a, [1, 2, 3])
  258:         assert_raises(ValueError, f, a[:1], [1, 2, 3])
  259: 
  260:     def test_boolean_assignment_needs_api(self):
  261:         # See also gh-7666
  262:         # This caused a segfault on Python 2 due to the GIL not being
  263:         # held when the iterator does not need it, but the transfer function
  264:         # does
  265:         arr = np.zeros(1000)
  266:         indx = np.zeros(1000, dtype=bool)
  267:         indx[:100] = True
  268:         arr[indx] = np.ones(100, dtype=object)
  269: 
  270:         expected = np.zeros(1000)
  271:         expected[:100] = 1
  272:         assert_array_equal(arr, expected)
  273: 
  274:     def test_boolean_indexing_twodim(self):
  275:         # Indexing a 2-dimensional array with
  276:         # 2-dimensional boolean array
  277:         a = np.array([[1, 2, 3],
  278:                       [4, 5, 6],
  279:                       [7, 8, 9]])
  280:         b = np.array([[ True, False, True],
  281:                       [False, True, False],
  282:                       [ True, False, True]])
  283:         assert_equal(a[b], [1, 3, 5, 7, 9])
  284:         assert_equal(a[b[1]], [[4, 5, 6]])
  285:         assert_equal(a[b[0]], a[b[2]])
  286: 
  287:         # boolean assignment
  288:         a[b] = 0
  289:         assert_equal(a, [[0, 2, 0],
  290:                          [4, 0, 6],
  291:                          [0, 8, 0]])
  292: 
  293:     def test_boolean_indexing_list(self):
  294:         # Regression test for #13715. It's a use-after-free bug which the
  295:         # test won't directly catch, but it will show up in valgrind.
  296:         a = np.array([1, 2, 3])
  297:         b = [True, False, True]
  298:         # Two variants of the test because the first takes a fast path
  299:         assert_equal(a[b], [1, 3])
  300:         assert_equal(a[None, b], [[1, 3]])
  301: 
  302:     def test_reverse_strides_and_subspace_bufferinit(self):
  303:         # This tests that the strides are not reversed for simple and
  304:         # subspace fancy indexing.
  305:         a = np.ones(5)
  306:         b = np.zeros(5, dtype=np.intp)[::-1]
  307:         c = np.arange(5)[::-1]
  308: 
  309:         a[b] = c
  310:         # If the strides are not reversed, the 0 in the arange comes last.
  311:         assert_equal(a[0], 0)
  312: 
  313:         # This also tests that the subspace buffer is initialized:
  314:         a = np.ones((5, 2))
  315:         c = np.arange(10).reshape(5, 2)[::-1]
  316:         a[b, :] = c
  317:         assert_equal(a[0], [0, 1])
  318: 
  319:     def test_reversed_strides_result_allocation(self):
  320:         # Test a bug when calculating the output strides for a result array
  321:         # when the subspace size was 1 (and test other cases as well)
  322:         a = np.arange(10)[:, None]
  323:         i = np.arange(10)[::-1]
  324:         assert_array_equal(a[i], a[i.copy('C')])
  325: 
  326:         a = np.arange(20).reshape(-1, 2)
  327: 
  328:     def test_uncontiguous_subspace_assignment(self):
  329:         # During development there was a bug activating a skip logic
  330:         # based on ndim instead of size.
  331:         a = np.full((3, 4, 2), -1)
  332:         b = np.full((3, 4, 2), -1)
  333: 
  334:         a[[0, 1]] = np.arange(2 * 4 * 2).reshape(2, 4, 2).T
  335:         b[[0, 1]] = np.arange(2 * 4 * 2).reshape(2, 4, 2).T.copy()
  336: 
  337:         assert_equal(a, b)
  338: 
  339:     def test_too_many_fancy_indices_special_case(self):
  340:         # Just documents behaviour, this is a small limitation.
  341:         a = np.ones((1,) * 64)  # 64 is NPY_MAXDIMS
  342:         assert_raises(IndexError, a.__getitem__, (np.array([0]),) * 64)
  343: 
  344:     def test_scalar_array_bool(self):
  345:         # NumPy bools can be used as boolean index (python ones as of yet not)
  346:         a = np.array(1)
  347:         assert_equal(a[np.bool(True)], a[np.array(True)])
  348:         assert_equal(a[np.bool(False)], a[np.array(False)])
  349: 
  350:         # After deprecating bools as integers:
  351:         #a = np.array([0,1,2])
  352:         #assert_equal(a[True, :], a[None, :])
  353:         #assert_equal(a[:, True], a[:, None])
  354:         #
  355:         #assert_(not np.may_share_memory(a, a[True, :]))
  356: 
  357:     def test_everything_returns_views(self):
  358:         # Before `...` would return a itself.
  359:         a = np.arange(5)
  360: 
  361:         assert_(a is not a[()])
  362:         assert_(a is not a[...])
  363:         assert_(a is not a[:])
  364: 
  365:     def test_broaderrors_indexing(self):
  366:         a = np.zeros((5, 5))
  367:         assert_raises(IndexError, a.__getitem__, ([0, 1], [0, 1, 2]))
  368:         assert_raises(IndexError, a.__setitem__, ([0, 1], [0, 1, 2]), 0)
  369: 
  370:     def test_trivial_fancy_out_of_bounds(self):
  371:         a = np.zeros(5)
  372:         ind = np.ones(20, dtype=np.intp)
  373:         ind[-1] = 10
  374:         assert_raises(IndexError, a.__getitem__, ind)
  375:         assert_raises(IndexError, a.__setitem__, ind, 0)
  376:         ind = np.ones(20, dtype=np.intp)
  377:         ind[0] = 11
  378:         assert_raises(IndexError, a.__getitem__, ind)
  379:         assert_raises(IndexError, a.__setitem__, ind, 0)
  380: 
  381:     def test_trivial_fancy_not_possible(self):
  382:         # Test that the fast path for trivial assignment is not incorrectly
  383:         # used when the index is not contiguous or 1D, see also gh-11467.
  384:         a = np.arange(6)
  385:         idx = np.arange(6, dtype=np.intp).reshape(2, 1, 3)[:, :, 0]
  386:         assert_array_equal(a[idx], idx)
  387: 
  388:         # this case must not go into the fast path, note that idx is
  389:         # a non-contiguous none 1D array here.
  390:         a[idx] = -1
  391:         res = np.arange(6)
  392:         res[0] = -1
  393:         res[3] = -1
  394:         assert_array_equal(a, res)
  395: 
  396:     def test_nonbaseclass_values(self):
  397:         class SubClass(np.ndarray):
  398:             def __array_finalize__(self, old):
  399:                 # Have array finalize do funny things
  400:                 self.fill(99)
  401: 
  402:         a = np.zeros((5, 5))
  403:         s = a.copy().view(type=SubClass)
  404:         s.fill(1)
  405: 
  406:         a[[0, 1, 2, 3, 4], :] = s
  407:         assert_((a == 1).all())
  408: 
  409:         # Subspace is last, so transposing might want to finalize
  410:         a[:, [0, 1, 2, 3, 4]] = s
  411:         assert_((a == 1).all())
  412: 
  413:         a.fill(0)
  414:         a[...] = s
  415:         assert_((a == 1).all())
  416: 
  417:     def test_array_like_values(self):
  418:         # Similar to the above test, but use a memoryview instead
  419:         a = np.zeros((5, 5))
  420:         s = np.arange(25, dtype=np.float64).reshape(5, 5)
  421: 
  422:         a[[0, 1, 2, 3, 4], :] = memoryview(s)
  423:         assert_array_equal(a, s)
  424: 
  425:         a[:, [0, 1, 2, 3, 4]] = memoryview(s)
  426:         assert_array_equal(a, s)
  427: 
  428:         a[...] = memoryview(s)
  429:         assert_array_equal(a, s)
  430: 
  431:     @pytest.mark.parametrize("writeable", [True, False])
  432:     def test_subclass_writeable(self, writeable):
  433:         d = np.rec.array([('NGC1001', 11), ('NGC1002', 1.), ('NGC1003', 1.)],
  434:                          dtype=[('target', 'S20'), ('V_mag', '>f4')])
  435:         d.flags.writeable = writeable
  436:         # Advanced indexing results are always writeable:
  437:         ind = np.array([False, True, True], dtype=bool)
  438:         assert d[ind].flags.writeable
  439:         ind = np.array([0, 1])
  440:         assert d[ind].flags.writeable
  441:         # Views should be writeable if the original array is:
  442:         assert d[...].flags.writeable == writeable
  443:         assert d[0].flags.writeable == writeable
  444: 
  445:     def test_memory_order(self):
  446:         # This is not necessary to preserve. Memory layouts for
  447:         # more complex indices are not as simple.
  448:         a = np.arange(10)
  449:         b = np.arange(10).reshape(5, 2).T
  450:         assert_(a[b].flags.f_contiguous)
  451: 
  452:         # Takes a different implementation branch:
  453:         a = a.reshape(-1, 1)
  454:         assert_(a[b, 0].flags.f_contiguous)
  455: 
  456:     def test_scalar_return_type(self):
  457:         # Full scalar indices should return scalars and object
  458:         # arrays should not call PyArray_Return on their items
  459:         class Zero:
  460:             # The most basic valid indexing
  461:             def __index__(self):
  462:                 return 0
  463: 
  464:         z = Zero()
  465: 
  466:         class ArrayLike:
  467:             # Simple array, should behave like the array
  468:             def __array__(self, dtype=None, copy=None):
  469:                 return np.array(0)
  470: 
  471:         a = np.zeros(())
  472:         assert_(isinstance(a[()], np.float64))
  473:         a = np.zeros(1)
  474:         assert_(isinstance(a[z], np.float64))
  475:         a = np.zeros((1, 1))
  476:         assert_(isinstance(a[z, np.array(0)], np.float64))
  477:         assert_(isinstance(a[z, ArrayLike()], np.float64))
  478: 
  479:         # And object arrays do not call it too often:
  480:         b = np.array(0)
  481:         a = np.array(0, dtype=object)
  482:         a[()] = b
  483:         assert_(isinstance(a[()], np.ndarray))
  484:         a = np.array([b, None])
  485:         assert_(isinstance(a[z], np.ndarray))
  486:         a = np.array([[b, None]])
  487:         assert_(isinstance(a[z, np.array(0)], np.ndarray))
  488:         assert_(isinstance(a[z, ArrayLike()], np.ndarray))
  489: 
  490:     def test_small_regressions(self):
  491:         # Reference count of intp for index checks
  492:         a = np.array([0])
  493:         if HAS_REFCOUNT:
  494:             refcount = sys.getrefcount(np.dtype(np.intp))
  495:         # item setting always checks indices in separate function:
  496:         a[np.array([0], dtype=np.intp)] = 1
  497:         a[np.array([0], dtype=np.uint8)] = 1
  498:         assert_raises(IndexError, a.__setitem__,
  499:                       np.array([1], dtype=np.intp), 1)
  500:         assert_raises(IndexError, a.__setitem__,
  501:                       np.array([1], dtype=np.uint8), 1)
  502: 
  503:         if HAS_REFCOUNT:
  504:             assert_equal(sys.getrefcount(np.dtype(np.intp)), refcount)
  505: 
  506:     def test_unaligned(self):
  507:         v = (np.zeros(64, dtype=np.int8) + ord('a'))[1:-7]
  508:         d = v.view(np.dtype("S8"))
  509:         # unaligned source
  510:         x = (np.zeros(16, dtype=np.int8) + ord('a'))[1:-7]
  511:         x = x.view(np.dtype("S8"))
  512:         x[...] = np.array("b" * 8, dtype="S")
  513:         b = np.arange(d.size)
  514:         # trivial
  515:         assert_equal(d[b], d)
  516:         d[b] = x
  517:         # nontrivial
  518:         # unaligned index array
  519:         b = np.zeros(d.size + 1).view(np.int8)[1:-(np.intp(0).itemsize - 1)]
  520:         b = b.view(np.intp)[:d.size]
  521:         b[...] = np.arange(d.size)
  522:         assert_equal(d[b.astype(np.int16)], d)
  523:         d[b.astype(np.int16)] = x
  524:         # boolean
  525:         d[b % 2 == 0]
  526:         d[b % 2 == 0] = x[::2]
  527: 
  528:     def test_tuple_subclass(self):
  529:         arr = np.ones((5, 5))
  530: 
  531:         # A tuple subclass should also be an nd-index
  532:         class TupleSubclass(tuple):
  533:             pass
  534:         index = ([1], [1])
  535:         index = TupleSubclass(index)
  536:         assert_(arr[index].shape == (1,))
  537:         # Unlike the non nd-index:
  538:         assert_(arr[index,].shape != (1,))
  539: 
  540:     def test_broken_sequence_not_nd_index(self):
  541:         # See gh-5063:
  542:         # If we have an object which claims to be a sequence, but fails
  543:         # on item getting, this should not be converted to an nd-index (tuple)
  544:         # If this object happens to be a valid index otherwise, it should work
  545:         # This object here is very dubious and probably bad though:
  546:         class SequenceLike:
  547:             def __index__(self):
  548:                 return 0
  549: 
  550:             def __len__(self):
  551:                 return 1
  552: 
  553:             def __getitem__(self, item):
  554:                 raise IndexError('Not possible')
  555: 
  556:         arr = np.arange(10)
  557:         assert_array_equal(arr[SequenceLike()], arr[SequenceLike(),])
  558: 
  559:         # also test that field indexing does not segfault
  560:         # for a similar reason, by indexing a structured array
  561:         arr = np.zeros((1,), dtype=[('f1', 'i8'), ('f2', 'i8')])
  562:         assert_array_equal(arr[SequenceLike()], arr[SequenceLike(),])
  563: 
  564:     def test_indexing_array_weird_strides(self):
  565:         # See also gh-6221
  566:         # the shapes used here come from the issue and create the correct
  567:         # size for the iterator buffering size.
  568:         x = np.ones(10)
  569:         x2 = np.ones((10, 2))
  570:         ind = np.arange(10)[:, None, None, None]
  571:         ind = np.broadcast_to(ind, (10, 55, 4, 4))
  572: 
  573:         # single advanced index case
  574:         assert_array_equal(x[ind], x[ind.copy()])
  575:         # higher dimensional advanced index
  576:         zind = np.zeros(4, dtype=np.intp)
  577:         assert_array_equal(x2[ind, zind], x2[ind.copy(), zind])
  578: 
  579:     def test_indexing_array_negative_strides(self):
  580:         # From gh-8264,
  581:         # core dumps if negative strides are used in iteration
  582:         arro = np.zeros((4, 4))
  583:         arr = arro[::-1, ::-1]
  584: 
  585:         slices = (slice(None), [0, 1, 2, 3])
  586:         arr[slices] = 10
  587:         assert_array_equal(arr, 10.)
  588: 
  589:     def test_character_assignment(self):
  590:         # This is an example a function going through CopyObject which
  591:         # used to have an untested special path for scalars
  592:         # (the character special dtype case, should be deprecated probably)
  593:         arr = np.zeros((1, 5), dtype="c")
  594:         arr[0] = np.str_("asdfg")  # must assign as a sequence
  595:         assert_array_equal(arr[0], np.array("asdfg", dtype="c"))
  596:         assert arr[0, 1] == b"s"  # make sure not all were set to "a" for both
  597: 
  598:     @pytest.mark.parametrize("index",
  599:             [True, False, np.array([0])])
  600:     @pytest.mark.parametrize("num", [64, 80])
  601:     @pytest.mark.parametrize("original_ndim", [1, 64])
  602:     def test_too_many_advanced_indices(self, index, num, original_ndim):
  603:         # These are limitations based on the number of arguments we can process.
  604:         # For `num=32` (and all boolean cases), the result is actually define;
  605:         # but the use of NpyIter (NPY_MAXARGS) limits it for technical reasons.
  606:         arr = np.ones((1,) * original_ndim)
  607:         with pytest.raises(IndexError):
  608:             arr[(index,) * num]
  609:         with pytest.raises(IndexError):
  610:             arr[(index,) * num] = 1.
  611: 
  612:     def test_nontuple_ndindex(self):
  613:         a = np.arange(25).reshape((5, 5))
  614:         assert_equal(a[[0, 1]], np.array([a[0], a[1]]))
  615:         assert_equal(a[[0, 1], [0, 1]], np.array([0, 6]))
  616:         assert_raises(IndexError, a.__getitem__, [slice(None)])
  617: 
  618:     def test_flat_index_on_flatiter(self):
  619:         a = np.arange(9).reshape((3, 3))
  620:         b = np.array([0, 5, 6])
  621:         assert_equal(a.flat[b.flat], np.array([0, 5, 6]))
  622: 
  623:     def test_empty_string_flat_index_on_flatiter(self):
  624:         a = np.arange(9).reshape((3, 3))
  625:         b = np.array([], dtype="S")
  626:         assert_equal(a.flat[b.flat], np.array([]))
  627: 
  628:     def test_nonempty_string_flat_index_on_flatiter(self):
  629:         a = np.arange(9).reshape((3, 3))
  630:         b = np.array(["a"], dtype="S")
  631:         with pytest.raises(IndexError, match="unsupported iterator index"):
  632:             a.flat[b.flat]
  633: 
  634: 
  635: class TestFieldIndexing:
  636:     def test_scalar_return_type(self):
  637:         # Field access on an array should return an array, even if it
  638:         # is 0-d.
  639:         a = np.zeros((), [('a', 'f8')])
  640:         assert_(isinstance(a['a'], np.ndarray))
  641:         assert_(isinstance(a[['a']], np.ndarray))
  642: 
  643: 
  644: class TestBroadcastedAssignments:
  645:     def assign(self, a, ind, val):
  646:         a[ind] = val
  647:         return a
  648: 
  649:     def test_prepending_ones(self):
  650:         a = np.zeros((3, 2))
  651: 
  652:         a[...] = np.ones((1, 3, 2))
  653:         # Fancy with subspace with and without transpose
  654:         a[[0, 1, 2], :] = np.ones((1, 3, 2))
  655:         a[:, [0, 1]] = np.ones((1, 3, 2))
  656:         # Fancy without subspace (with broadcasting)
  657:         a[[[0], [1], [2]], [0, 1]] = np.ones((1, 3, 2))
  658: 
  659:     def test_prepend_not_one(self):
  660:         assign = self.assign
  661:         s_ = np.s_
  662:         a = np.zeros(5)
  663: 
  664:         # Too large and not only ones.
  665:         assert_raises(ValueError, assign, a, s_[...], np.ones((2, 1)))
  666:         assert_raises(ValueError, assign, a, s_[[1, 2, 3],], np.ones((2, 1)))
  667:         assert_raises(ValueError, assign, a, s_[[[1], [2]],], np.ones((2, 2, 1)))
  668: 
  669:     def test_simple_broadcasting_errors(self):
  670:         assign = self.assign
  671:         s_ = np.s_
  672:         a = np.zeros((5, 1))
  673: 
  674:         assert_raises(ValueError, assign, a, s_[...], np.zeros((5, 2)))
  675:         assert_raises(ValueError, assign, a, s_[...], np.zeros((5, 0)))
  676:         assert_raises(ValueError, assign, a, s_[:, [0]], np.zeros((5, 2)))
  677:         assert_raises(ValueError, assign, a, s_[:, [0]], np.zeros((5, 0)))
  678:         assert_raises(ValueError, assign, a, s_[[0], :], np.zeros((2, 1)))
  679: 
  680:     @pytest.mark.parametrize("index", [
  681:             (..., [1, 2], slice(None)),
  682:             ([0, 1], ..., 0),
  683:             (..., [1, 2], [1, 2])])
  684:     def test_broadcast_error_reports_correct_shape(self, index):
  685:         values = np.zeros((100, 100))  # will never broadcast below
  686: 
  687:         arr = np.zeros((3, 4, 5, 6, 7))
  688:         # We currently report without any spaces (could be changed)
  689:         shape_str = str(arr[index].shape).replace(" ", "")
  690: 
  691:         with pytest.raises(ValueError) as e:
  692:             arr[index] = values
  693: 
  694:         assert str(e.value).endswith(shape_str)
  695: 
  696:     def test_index_is_larger(self):
  697:         # Simple case of fancy index broadcasting of the index.
  698:         a = np.zeros((5, 5))
  699:         a[[[0], [1], [2]], [0, 1, 2]] = [2, 3, 4]
  700: 
  701:         assert_((a[:3, :3] == [2, 3, 4]).all())
  702: 
  703:     def test_broadcast_subspace(self):
  704:         a = np.zeros((100, 100))
  705:         v = np.arange(100)[:, None]
  706:         b = np.arange(100)[::-1]
  707:         a[b] = v
  708:         assert_((a[::-1] == v).all())
  709: 
  710: 
  711: class TestSubclasses:
  712:     def test_basic(self):
  713:         # Test that indexing in various ways produces SubClass instances,
  714:         # and that the base is set up correctly: the original subclass
  715:         # instance for views, and a new ndarray for advanced/boolean indexing
  716:         # where a copy was made (latter a regression test for gh-11983).
  717:         class SubClass(np.ndarray):
  718:             pass
  719: 
  720:         a = np.arange(5)
  721:         s = a.view(SubClass)
  722:         s_slice = s[:3]
  723:         assert_(type(s_slice) is SubClass)
  724:         assert_(s_slice.base is s)
  725:         assert_array_equal(s_slice, a[:3])
  726: 
  727:         s_fancy = s[[0, 1, 2]]
  728:         assert_(type(s_fancy) is SubClass)
  729:         assert_(s_fancy.base is not s)
  730:         assert_(type(s_fancy.base) is np.ndarray)
  731:         assert_array_equal(s_fancy, a[[0, 1, 2]])
  732:         assert_array_equal(s_fancy.base, a[[0, 1, 2]])
  733: 
  734:         s_bool = s[s > 0]
  735:         assert_(type(s_bool) is SubClass)
  736:         assert_(s_bool.base is not s)
  737:         assert_(type(s_bool.base) is np.ndarray)
  738:         assert_array_equal(s_bool, a[a > 0])
  739:         assert_array_equal(s_bool.base, a[a > 0])
  740: 
  741:     def test_fancy_on_read_only(self):
  742:         # Test that fancy indexing on read-only SubClass does not make a
  743:         # read-only copy (gh-14132)
  744:         class SubClass(np.ndarray):
  745:             pass
  746: 
  747:         a = np.arange(5)
  748:         s = a.view(SubClass)
  749:         s.flags.writeable = False
  750:         s_fancy = s[[0, 1, 2]]
  751:         assert_(s_fancy.flags.writeable)
  752: 
  753:     def test_finalize_gets_full_info(self):
  754:         # Array finalize should be called on the filled array.
  755:         class SubClass(np.ndarray):
  756:             def __array_finalize__(self, old):
  757:                 self.finalize_status = np.array(self)
  758:                 self.old = old
  759: 
  760:         s = np.arange(10).view(SubClass)
  761:         new_s = s[:3]
  762:         assert_array_equal(new_s.finalize_status, new_s)
  763:         assert_array_equal(new_s.old, s)
  764: 
  765:         new_s = s[[0, 1, 2, 3]]
  766:         assert_array_equal(new_s.finalize_status, new_s)
  767:         assert_array_equal(new_s.old, s)
  768: 
  769:         new_s = s[s > 0]
  770:         assert_array_equal(new_s.finalize_status, new_s)
  771:         assert_array_equal(new_s.old, s)
  772: 
  773: 
  774: class TestFancyIndexingCast:
  775:     def test_boolean_index_cast_assign(self):
  776:         # Setup the boolean index and float arrays.
  777:         shape = (8, 63)
  778:         bool_index = np.zeros(shape).astype(bool)
  779:         bool_index[0, 1] = True
  780:         zero_array = np.zeros(shape)
  781: 
  782:         # Assigning float is fine.
  783:         zero_array[bool_index] = np.array([1])
  784:         assert_equal(zero_array[0, 1], 1)
  785: 
  786:         # Fancy indexing works, although we get a cast warning.
  787:         assert_warns(ComplexWarning,
  788:                      zero_array.__setitem__, ([0], [1]), np.array([2 + 1j]))
  789:         assert_equal(zero_array[0, 1], 2)  # No complex part
  790: 
  791:         # Cast complex to float, throwing away the imaginary portion.
  792:         assert_warns(ComplexWarning,
  793:                      zero_array.__setitem__, bool_index, np.array([1j]))
  794:         assert_equal(zero_array[0, 1], 0)
  795: 
  796: class TestFancyIndexingEquivalence:
  797:     def test_object_assign(self):
  798:         # Check that the field and object special case using copyto is active.
  799:         # The right hand side cannot be converted to an array here.
  800:         a = np.arange(5, dtype=object)
  801:         b = a.copy()
  802:         a[:3] = [1, (1, 2), 3]
  803:         b[[0, 1, 2]] = [1, (1, 2), 3]
  804:         assert_array_equal(a, b)
  805: 
  806:         # test same for subspace fancy indexing
  807:         b = np.arange(5, dtype=object)[None, :]
  808:         b[[0], :3] = [[1, (1, 2), 3]]
  809:         assert_array_equal(a, b[0])
  810: 
  811:         # Check that swapping of axes works.
  812:         # There was a bug that made the later assignment throw a ValueError
  813:         # do to an incorrectly transposed temporary right hand side (gh-5714)
  814:         b = b.T
  815:         b[:3, [0]] = [[1], [(1, 2)], [3]]
  816:         assert_array_equal(a, b[:, 0])
  817: 
  818:         # Another test for the memory order of the subspace
  819:         arr = np.ones((3, 4, 5), dtype=object)
  820:         # Equivalent slicing assignment for comparison
  821:         cmp_arr = arr.copy()
  822:         cmp_arr[:1, ...] = [[[1], [2], [3], [4]]]
  823:         arr[[0], ...] = [[[1], [2], [3], [4]]]
  824:         assert_array_equal(arr, cmp_arr)
  825:         arr = arr.copy('F')
  826:         arr[[0], ...] = [[[1], [2], [3], [4]]]
  827:         assert_array_equal(arr, cmp_arr)
  828: 
  829:     def test_cast_equivalence(self):
  830:         # Yes, normal slicing uses unsafe casting.
  831:         a = np.arange(5)
  832:         b = a.copy()
  833: 
  834:         a[:3] = np.array(['2', '-3', '-1'])
  835:         b[[0, 2, 1]] = np.array(['2', '-1', '-3'])
  836:         assert_array_equal(a, b)
  837: 
  838:         # test the same for subspace fancy indexing
  839:         b = np.arange(5)[None, :]
  840:         b[[0], :3] = np.array([['2', '-3', '-1']])
  841:         assert_array_equal(a, b[0])
  842: 
  843: 
  844: class TestMultiIndexingAutomated:
  845:     """
  846:     These tests use code to mimic the C-Code indexing for selection.
  847: 
  848:     NOTE:
  849: 
  850:         * This still lacks tests for complex item setting.
  851:         * If you change behavior of indexing, you might want to modify
  852:           these tests to try more combinations.
  853:         * Behavior was written to match numpy version 1.8. (though a
  854:           first version matched 1.7.)
  855:         * Only tuple indices are supported by the mimicking code.
  856:           (and tested as of writing this)
  857:         * Error types should match most of the time as long as there
  858:           is only one error. For multiple errors, what gets raised
  859:           will usually not be the same one. They are *not* tested.
  860: 
  861:     Update 2016-11-30: It is probably not worth maintaining this test
  862:     indefinitely and it can be dropped if maintenance becomes a burden.
  863: 
  864:     """
  865: 
  866:     def setup_method(self):
  867:         self.a = np.arange(np.prod([3, 1, 5, 6])).reshape(3, 1, 5, 6)
  868:         self.b = np.empty((3, 0, 5, 6))
  869:         self.complex_indices = ['skip', Ellipsis,
  870:             0,
  871:             # Boolean indices, up to 3-d for some special cases of eating up
  872:             # dimensions, also need to test all False
  873:             np.array([True, False, False]),
  874:             np.array([[True, False], [False, True]]),
  875:             np.array([[[False, False], [False, False]]]),
  876:             # Some slices:
  877:             slice(-5, 5, 2),
  878:             slice(1, 1, 100),
  879:             slice(4, -1, -2),
  880:             slice(None, None, -3),
  881:             # Some Fancy indexes:
  882:             np.empty((0, 1, 1), dtype=np.intp),  # empty and can be broadcast
  883:             np.array([0, 1, -2]),
  884:             np.array([[2], [0], [1]]),
  885:             np.array([[0, -1], [0, 1]], dtype=np.dtype('intp').newbyteorder()),
  886:             np.array([2, -1], dtype=np.int8),
  887:             np.zeros([1] * 31, dtype=int),  # trigger too large array.
  888:             np.array([0., 1.])]  # invalid datatype
  889:         # Some simpler indices that still cover a bit more
  890:         self.simple_indices = [Ellipsis, None, -1, [1], np.array([True]),
  891:                                'skip']
  892:         # Very simple ones to fill the rest:
  893:         self.fill_indices = [slice(None, None), 0]
  894: 
  895:     def _get_multi_index(self, arr, indices):
  896:         """Mimic multi dimensional indexing.
  897: 
  898:         Parameters
  899:         ----------
  900:         arr : ndarray
  901:             Array to be indexed.
  902:         indices : tuple of index objects
  903: 
  904:         Returns
  905:         -------
  906:         out : ndarray
  907:             An array equivalent to the indexing operation (but always a copy).
  908:             `arr[indices]` should be identical.
  909:         no_copy : bool
  910:             Whether the indexing operation requires a copy. If this is `True`,
  911:             `np.may_share_memory(arr, arr[indices])` should be `True` (with
  912:             some exceptions for scalars and possibly 0-d arrays).
  913: 
  914:         Notes
  915:         -----
  916:         While the function may mostly match the errors of normal indexing this
  917:         is generally not the case.
  918:         """
  919:         in_indices = list(indices)
  920:         indices = []
  921:         # if False, this is a fancy or boolean index
  922:         no_copy = True
  923:         # number of fancy/scalar indexes that are not consecutive
  924:         num_fancy = 0
  925:         # number of dimensions indexed by a "fancy" index
  926:         fancy_dim = 0
  927:         # NOTE: This is a funny twist (and probably OK to change).
  928:         # The boolean array has illegal indexes, but this is
  929:         # allowed if the broadcast fancy-indices are 0-sized.
  930:         # This variable is to catch that case.
  931:         error_unless_broadcast_to_empty = False
  932: 
  933:         # We need to handle Ellipsis and make arrays from indices, also
  934:         # check if this is fancy indexing (set no_copy).
  935:         ndim = 0
  936:         ellipsis_pos = None  # define here mostly to replace all but first.
  937:         for i, indx in enumerate(in_indices):
  938:             if indx is None:
  939:                 continue
  940:             if isinstance(indx, np.ndarray) and indx.dtype == bool:
  941:                 no_copy = False
  942:                 if indx.ndim == 0:
  943:                     raise IndexError
  944:                 # boolean indices can have higher dimensions
  945:                 ndim += indx.ndim
  946:                 fancy_dim += indx.ndim
  947:                 continue
  948:             if indx is Ellipsis:
  949:                 if ellipsis_pos is None:
  950:                     ellipsis_pos = i
  951:                     continue  # do not increment ndim counter
  952:                 raise IndexError
  953:             if isinstance(indx, slice):
  954:                 ndim += 1
  955:                 continue
  956:             if not isinstance(indx, np.ndarray):
  957:                 # This could be open for changes in numpy.
  958:                 # numpy should maybe raise an error if casting to intp
  959:                 # is not safe. It rejects np.array([1., 2.]) but not
  960:                 # [1., 2.] as index (same for ie. np.take).
  961:                 # (Note the importance of empty lists if changing this here)
  962:                 try:
  963:                     indx = np.array(indx, dtype=np.intp)
  964:                 except ValueError:
  965:                     raise IndexError
  966:                 in_indices[i] = indx
  967:             elif indx.dtype.kind not in 'bi':
  968:                 raise IndexError('arrays used as indices must be of '
  969:                                  'integer (or boolean) type')
  970:             if indx.ndim != 0:
  971:                 no_copy = False
  972:             ndim += 1
  973:             fancy_dim += 1
  974: 
  975:         if arr.ndim - ndim < 0:
  976:             # we can't take more dimensions then we have, not even for 0-d
  977:             # arrays.  since a[()] makes sense, but not a[(),]. We will
  978:             # raise an error later on, unless a broadcasting error occurs
  979:             # first.
  980:             raise IndexError
  981: 
  982:         if ndim == 0 and None not in in_indices:
  983:             # Well we have no indexes or one Ellipsis. This is legal.
  984:             return arr.copy(), no_copy
  985: 
  986:         if ellipsis_pos is not None:
  987:             in_indices[ellipsis_pos:ellipsis_pos + 1] = ([slice(None, None)] *
  988:                                                        (arr.ndim - ndim))
  989: 
  990:         for ax, indx in enumerate(in_indices):
  991:             if isinstance(indx, slice):
  992:                 # convert to an index array
  993:                 indx = np.arange(*indx.indices(arr.shape[ax]))
  994:                 indices.append(['s', indx])
  995:                 continue
  996:             elif indx is None:
  997:                 # this is like taking a slice with one element from a new axis:
  998:                 indices.append(['n', np.array([0], dtype=np.intp)])
  999:                 arr = arr.reshape(arr.shape[:ax] + (1,) + arr.shape[ax:])
 1000:                 continue
 1001:             if isinstance(indx, np.ndarray) and indx.dtype == bool:
 1002:                 if indx.shape != arr.shape[ax:ax + indx.ndim]:
 1003:                     raise IndexError
 1004: 
 1005:                 try:
 1006:                     flat_indx = np.ravel_multi_index(np.nonzero(indx),
 1007:                                     arr.shape[ax:ax + indx.ndim], mode='raise')
 1008:                 except Exception:
 1009:                     error_unless_broadcast_to_empty = True
 1010:                     # fill with 0s instead, and raise error later
 1011:                     flat_indx = np.array([0] * indx.sum(), dtype=np.intp)
 1012:                 # concatenate axis into a single one:
 1013:                 if indx.ndim != 0:
 1014:                     arr = arr.reshape(arr.shape[:ax]
 1015:                                   + (np.prod(arr.shape[ax:ax + indx.ndim]),)
 1016:                                   + arr.shape[ax + indx.ndim:])
 1017:                     indx = flat_indx
 1018:                 else:
 1019:                     # This could be changed, a 0-d boolean index can
 1020:                     # make sense (even outside the 0-d indexed array case)
 1021:                     # Note that originally this is could be interpreted as
 1022:                     # integer in the full integer special case.
 1023:                     raise IndexError
 1024:             # If the index is a singleton, the bounds check is done
 1025:             # before the broadcasting. This used to be different in <1.9
 1026:             elif indx.ndim == 0 and not (
 1027:                 -arr.shape[ax] <= indx < arr.shape[ax]
 1028:             ):
 1029:                 raise IndexError
 1030:             if indx.ndim == 0:
 1031:                 # The index is a scalar. This used to be two fold, but if
 1032:                 # fancy indexing was active, the check was done later,
 1033:                 # possibly after broadcasting it away (1.7. or earlier).
 1034:                 # Now it is always done.
 1035:                 if indx >= arr.shape[ax] or indx < - arr.shape[ax]:
 1036:                     raise IndexError
 1037:             if (len(indices) > 0 and
 1038:                     indices[-1][0] == 'f' and
 1039:                     ax != ellipsis_pos):
 1040:                 # NOTE: There could still have been a 0-sized Ellipsis
 1041:                 # between them. Checked that with ellipsis_pos.
 1042:                 indices[-1].append(indx)
 1043:             else:
 1044:                 # We have a fancy index that is not after an existing one.
 1045:                 # NOTE: A 0-d array triggers this as well, while one may
 1046:                 # expect it to not trigger it, since a scalar would not be
 1047:                 # considered fancy indexing.
 1048:                 num_fancy += 1
 1049:                 indices.append(['f', indx])
 1050: 
 1051:         if num_fancy > 1 and not no_copy:
 1052:             # We have to flush the fancy indexes left
 1053:             new_indices = indices[:]
 1054:             axes = list(range(arr.ndim))
 1055:             fancy_axes = []
 1056:             new_indices.insert(0, ['f'])
 1057:             ni = 0
 1058:             ai = 0
 1059:             for indx in indices:
 1060:                 ni += 1
 1061:                 if indx[0] == 'f':
 1062:                     new_indices[0].extend(indx[1:])
 1063:                     del new_indices[ni]
 1064:                     ni -= 1
 1065:                     for ax in range(ai, ai + len(indx[1:])):
 1066:                         fancy_axes.append(ax)
 1067:                         axes.remove(ax)
 1068:                 ai += len(indx) - 1  # axis we are at
 1069:             indices = new_indices
 1070:             # and now we need to transpose arr:
 1071:             arr = arr.transpose(*(fancy_axes + axes))
 1072: 
 1073:         # We only have one 'f' index now and arr is transposed accordingly.
 1074:         # Now handle newaxis by reshaping...
 1075:         ax = 0
 1076:         for indx in indices:
 1077:             if indx[0] == 'f':
 1078:                 if len(indx) == 1:
 1079:                     continue
 1080:                 # First of all, reshape arr to combine fancy axes into one:
 1081:                 orig_shape = arr.shape
 1082:                 orig_slice = orig_shape[ax:ax + len(indx[1:])]
 1083:                 arr = arr.reshape(arr.shape[:ax]
 1084:                                     + (np.prod(orig_slice).astype(int),)
 1085:                                     + arr.shape[ax + len(indx[1:]):])
 1086: 
 1087:                 # Check if broadcasting works
 1088:                 res = np.broadcast(*indx[1:])
 1089:                 # unfortunately the indices might be out of bounds. So check
 1090:                 # that first, and use mode='wrap' then. However only if
 1091:                 # there are any indices...
 1092:                 if res.size != 0:
 1093:                     if error_unless_broadcast_to_empty:
 1094:                         raise IndexError
 1095:                     for _indx, _size in zip(indx[1:], orig_slice):
 1096:                         if _indx.size == 0:
 1097:                             continue
 1098:                         if np.any(_indx >= _size) or np.any(_indx < -_size):
 1099:                             raise IndexError
 1100:                 if len(indx[1:]) == len(orig_slice):
 1101:                     if np.prod(orig_slice) == 0:
 1102:                         # Work around for a crash or IndexError with 'wrap'
 1103:                         # in some 0-sized cases.
 1104:                         try:
 1105:                             mi = np.ravel_multi_index(indx[1:], orig_slice,
 1106:                                                       mode='raise')
 1107:                         except Exception:
 1108:                             # This happens with 0-sized orig_slice (sometimes?)
 1109:                             # here it is a ValueError, but indexing gives a:
 1110:                             raise IndexError('invalid index into 0-sized')
 1111:                     else:
 1112:                         mi = np.ravel_multi_index(indx[1:], orig_slice,
 1113:                                                   mode='wrap')
 1114:                 else:
 1115:                     # Maybe never happens...
 1116:                     raise ValueError
 1117:                 arr = arr.take(mi.ravel(), axis=ax)
 1118:                 try:
 1119:                     arr = arr.reshape(arr.shape[:ax]
 1120:                                         + mi.shape
 1121:                                         + arr.shape[ax + 1:])
 1122:                 except ValueError:
 1123:                     # too many dimensions, probably
 1124:                     raise IndexError
 1125:                 ax += mi.ndim
 1126:                 continue
 1127: 
 1128:             # If we are here, we have a 1D array for take:
 1129:             arr = arr.take(indx[1], axis=ax)
 1130:             ax += 1
 1131: 
 1132:         return arr, no_copy
 1133: 
 1134:     def _check_multi_index(self, arr, index):
 1135:         """Check a multi index item getting and simple setting.
 1136: 
 1137:         Parameters
 1138:         ----------
 1139:         arr : ndarray
 1140:             Array to be indexed, must be a reshaped arange.
 1141:         index : tuple of indexing objects
 1142:             Index being tested.
 1143:         """
 1144:         # Test item getting
 1145:         try:
 1146:             mimic_get, no_copy = self._get_multi_index(arr, index)
 1147:         except Exception as e:
 1148:             if HAS_REFCOUNT:
 1149:                 prev_refcount = sys.getrefcount(arr)
 1150:             assert_raises(type(e), arr.__getitem__, index)
 1151:             assert_raises(type(e), arr.__setitem__, index, 0)
 1152:             if HAS_REFCOUNT:
 1153:                 assert_equal(prev_refcount, sys.getrefcount(arr))
 1154:             return
 1155: 
 1156:         self._compare_index_result(arr, index, mimic_get, no_copy)
 1157: 
 1158:     def _check_single_index(self, arr, index):
 1159:         """Check a single index item getting and simple setting.
 1160: 
 1161:         Parameters
 1162:         ----------
 1163:         arr : ndarray
 1164:             Array to be indexed, must be an arange.
 1165:         index : indexing object
 1166:             Index being tested. Must be a single index and not a tuple
 1167:             of indexing objects (see also `_check_multi_index`).
 1168:         """
 1169:         try:
 1170:             mimic_get, no_copy = self._get_multi_index(arr, (index,))
 1171:         except Exception as e:
 1172:             if HAS_REFCOUNT:
 1173:                 prev_refcount = sys.getrefcount(arr)
 1174:             assert_raises(type(e), arr.__getitem__, index)
 1175:             assert_raises(type(e), arr.__setitem__, index, 0)
 1176:             if HAS_REFCOUNT:
 1177:                 assert_equal(prev_refcount, sys.getrefcount(arr))
 1178:             return
 1179: 
 1180:         self._compare_index_result(arr, index, mimic_get, no_copy)
 1181: 
 1182:     def _compare_index_result(self, arr, index, mimic_get, no_copy):
 1183:         """Compare mimicked result to indexing result.
 1184:         """
 1185:         arr = arr.copy()
 1186:         if HAS_REFCOUNT:
 1187:             startcount = sys.getrefcount(arr)
 1188:         indexed_arr = arr[index]
 1189:         assert_array_equal(indexed_arr, mimic_get)
 1190:         # Check if we got a view, unless its a 0-sized or 0-d array.
 1191:         # (then its not a view, and that does not matter)
 1192:         if indexed_arr.size != 0 and indexed_arr.ndim != 0:
 1193:             assert_(np.may_share_memory(indexed_arr, arr) == no_copy)
 1194:             # Check reference count of the original array
 1195:             if HAS_REFCOUNT:
 1196:                 if no_copy:
 1197:                     # refcount increases by one:
 1198:                     assert_equal(sys.getrefcount(arr), startcount + 1)
 1199:                 else:
 1200:                     assert_equal(sys.getrefcount(arr), startcount)
 1201: 
 1202:         # Test non-broadcast setitem:
 1203:         b = arr.copy()
 1204:         b[index] = mimic_get + 1000
 1205:         if b.size == 0:
 1206:             return  # nothing to compare here...
 1207:         if no_copy and indexed_arr.ndim != 0:
 1208:             # change indexed_arr in-place to manipulate original:
 1209:             indexed_arr += 1000
 1210:             assert_array_equal(arr, b)
 1211:             return
 1212:         # Use the fact that the array is originally an arange:
 1213:         arr.flat[indexed_arr.ravel()] += 1000
 1214:         assert_array_equal(arr, b)
 1215: 
 1216:     def test_boolean(self):
 1217:         a = np.array(5)
 1218:         assert_equal(a[np.array(True)], 5)
 1219:         a[np.array(True)] = 1
 1220:         assert_equal(a, 1)
 1221:         # NOTE: This is different from normal broadcasting, as
 1222:         # arr[boolean_array] works like in a multi index. Which means
 1223:         # it is aligned to the left. This is probably correct for
 1224:         # consistency with arr[boolean_array,] also no broadcasting
 1225:         # is done at all
 1226:         self._check_multi_index(
 1227:             self.a, (np.zeros_like(self.a, dtype=bool),))
 1228:         self._check_multi_index(
 1229:             self.a, (np.zeros_like(self.a, dtype=bool)[..., 0],))
 1230:         self._check_multi_index(
 1231:             self.a, (np.zeros_like(self.a, dtype=bool)[None, ...],))
 1232: 
 1233:     def test_multidim(self):
 1234:         # Automatically test combinations with complex indexes on 2nd (or 1st)
 1235:         # spot and the simple ones in one other spot.
 1236:         with warnings.catch_warnings():
 1237:             # This is so that np.array(True) is not accepted in a full integer
 1238:             # index, when running the file separately.
 1239:             warnings.filterwarnings('error', '', DeprecationWarning)
 1240:             warnings.filterwarnings('error', '', VisibleDeprecationWarning)
 1241: 
 1242:             def isskip(idx):
 1243:                 return isinstance(idx, str) and idx == "skip"
 1244: 
 1245:             for simple_pos in [0, 2, 3]:
 1246:                 tocheck = [self.fill_indices, self.complex_indices,
 1247:                            self.fill_indices, self.fill_indices]
 1248:                 tocheck[simple_pos] = self.simple_indices
 1249:                 for index in product(*tocheck):
 1250:                     index = tuple(i for i in index if not isskip(i))
 1251:                     self._check_multi_index(self.a, index)
 1252:                     self._check_multi_index(self.b, index)
 1253: 
 1254:         # Check very simple item getting:
 1255:         self._check_multi_index(self.a, (0, 0, 0, 0))
 1256:         self._check_multi_index(self.b, (0, 0, 0, 0))
 1257:         # Also check (simple cases of) too many indices:
 1258:         assert_raises(IndexError, self.a.__getitem__, (0, 0, 0, 0, 0))
 1259:         assert_raises(IndexError, self.a.__setitem__, (0, 0, 0, 0, 0), 0)
 1260:         assert_raises(IndexError, self.a.__getitem__, (0, 0, [1], 0, 0))
 1261:         assert_raises(IndexError, self.a.__setitem__, (0, 0, [1], 0, 0), 0)
 1262: 
 1263:     def test_1d(self):
 1264:         a = np.arange(10)
 1265:         for index in self.complex_indices:
 1266:             self._check_single_index(a, index)
 1267: 
 1268: class TestFloatNonIntegerArgument:
 1269:     """
 1270:     These test that ``TypeError`` is raised when you try to use
 1271:     non-integers as arguments to for indexing and slicing e.g. ``a[0.0:5]``
 1272:     and ``a[0.5]``, or other functions like ``array.reshape(1., -1)``.
 1273: 
 1274:     """
 1275:     def test_valid_indexing(self):
 1276:         # These should raise no errors.
 1277:         a = np.array([[[5]]])
 1278: 
 1279:         a[np.array([0])]
 1280:         a[[0, 0]]
 1281:         a[:, [0, 0]]
 1282:         a[:, 0, :]
 1283:         a[:, :, :]
 1284: 
 1285:     def test_valid_slicing(self):
 1286:         # These should raise no errors.
 1287:         a = np.array([[[5]]])
 1288: 
 1289:         a[::]
 1290:         a[0:]
 1291:         a[:2]
 1292:         a[0:2]
 1293:         a[::2]
 1294:         a[1::2]
 1295:         a[:2:2]
 1296:         a[1:2:2]
 1297: 
 1298:     def test_non_integer_argument_errors(self):
 1299:         a = np.array([[5]])
 1300: 
 1301:         assert_raises(TypeError, np.reshape, a, (1., 1., -1))
 1302:         assert_raises(TypeError, np.reshape, a, (np.array(1.), -1))
 1303:         assert_raises(TypeError, np.take, a, [0], 1.)
 1304:         assert_raises(TypeError, np.take, a, [0], np.float64(1.))
 1305: 
 1306:     def test_non_integer_sequence_multiplication(self):
 1307:         # NumPy scalar sequence multiply should not work with non-integers
 1308:         def mult(a, b):
 1309:             return a * b
 1310: 
 1311:         assert_raises(TypeError, mult, [1], np.float64(3))
 1312:         # following should be OK
 1313:         mult([1], np.int_(3))
 1314: 
 1315:     def test_reduce_axis_float_index(self):
 1316:         d = np.zeros((3, 3, 3))
 1317:         assert_raises(TypeError, np.min, d, 0.5)
 1318:         assert_raises(TypeError, np.min, d, (0.5, 1))
 1319:         assert_raises(TypeError, np.min, d, (1, 2.2))
 1320:         assert_raises(TypeError, np.min, d, (.2, 1.2))
 1321: 
 1322: 
 1323: class TestBooleanIndexing:
 1324:     # Using a boolean as integer argument/indexing is an error.
 1325:     def test_bool_as_int_argument_errors(self):
 1326:         a = np.array([[[1]]])
 1327: 
 1328:         assert_raises(TypeError, np.reshape, a, (True, -1))
 1329:         assert_raises(TypeError, np.reshape, a, (np.bool(True), -1))
 1330:         # Note that operator.index(np.array(True)) does not work, a boolean
 1331:         # array is thus also deprecated, but not with the same message:
 1332:         assert_raises(TypeError, operator.index, np.array(True))
 1333:         assert_raises(TypeError, operator.index, np.True_)
 1334:         assert_raises(TypeError, np.take, args=(a, [0], False))
 1335: 
 1336:     def test_boolean_indexing_weirdness(self):
 1337:         # Weird boolean indexing things
 1338:         a = np.ones((2, 3, 4))
 1339:         assert a[False, True, ...].shape == (0, 2, 3, 4)
 1340:         assert a[True, [0, 1], True, True, [1], [[2]]].shape == (1, 2)
 1341:         assert_raises(IndexError, lambda: a[False, [0, 1], ...])
 1342: 
 1343:     def test_boolean_indexing_fast_path(self):
 1344:         # These used to either give the wrong error, or incorrectly give no
 1345:         # error.
 1346:         a = np.ones((3, 3))
 1347: 
 1348:         # This used to incorrectly work (and give an array of shape (0,))
 1349:         idx1 = np.array([[False] * 9])
 1350:         assert_raises_regex(IndexError,
 1351:             "boolean index did not match indexed array along axis 0; "
 1352:             "size of axis is 3 but size of corresponding boolean axis is 1",
 1353:             lambda: a[idx1])
 1354: 
 1355:         # This used to incorrectly give a ValueError: operands could not be broadcast together
 1356:         idx2 = np.array([[False] * 8 + [True]])
 1357:         assert_raises_regex(IndexError,
 1358:             "boolean index did not match indexed array along axis 0; "
 1359:             "size of axis is 3 but size of corresponding boolean axis is 1",
 1360:             lambda: a[idx2])
 1361: 
 1362:         # This is the same as it used to be. The above two should work like this.
 1363:         idx3 = np.array([[False] * 10])
 1364:         assert_raises_regex(IndexError,
 1365:             "boolean index did not match indexed array along axis 0; "
 1366:             "size of axis is 3 but size of corresponding boolean axis is 1",
 1367:             lambda: a[idx3])
 1368: 
 1369:         # This used to give ValueError: non-broadcastable operand
 1370:         a = np.ones((1, 1, 2))
 1371:         idx = np.array([[[True], [False]]])
 1372:         assert_raises_regex(IndexError,
 1373:             "boolean index did not match indexed array along axis 1; "
 1374:             "size of axis is 1 but size of corresponding boolean axis is 2",
 1375:             lambda: a[idx])
 1376: 
 1377: 
 1378: class TestArrayToIndexDeprecation:
 1379:     """Creating an index from array not 0-D is an error.
 1380: 
 1381:     """
 1382:     def test_array_to_index_error(self):
 1383:         # so no exception is expected. The raising is effectively tested above.
 1384:         a = np.array([[[1]]])
 1385: 
 1386:         assert_raises(TypeError, operator.index, np.array([1]))
 1387:         assert_raises(TypeError, np.reshape, a, (a, -1))
 1388:         assert_raises(TypeError, np.take, a, [0], a)
 1389: 
 1390: 
 1391: class TestNonIntegerArrayLike:
 1392:     """Tests that array_likes only valid if can safely cast to integer.
 1393: 
 1394:     For instance, lists give IndexError when they cannot be safely cast to
 1395:     an integer.
 1396: 
 1397:     """
 1398:     def test_basic(self):
 1399:         a = np.arange(10)
 1400: 
 1401:         assert_raises(IndexError, a.__getitem__, [0.5, 1.5])
 1402:         assert_raises(IndexError, a.__getitem__, (['1', '2'],))
 1403: 
 1404:         # The following is valid
 1405:         a.__getitem__([])
 1406: 
 1407: 
 1408: class TestMultipleEllipsisError:
 1409:     """An index can only have a single ellipsis.
 1410: 
 1411:     """
 1412:     def test_basic(self):
 1413:         a = np.arange(10)
 1414:         assert_raises(IndexError, lambda: a[..., ...])
 1415:         assert_raises(IndexError, a.__getitem__, ((Ellipsis,) * 2,))
 1416:         assert_raises(IndexError, a.__getitem__, ((Ellipsis,) * 3,))
 1417: 
 1418: 
 1419: class TestCApiAccess:
 1420:     def test_getitem(self):
 1421:         subscript = functools.partial(array_indexing, 0)
 1422: 
 1423:         # 0-d arrays don't work:
 1424:         assert_raises(IndexError, subscript, np.ones(()), 0)
 1425:         # Out of bound values:
 1426:         assert_raises(IndexError, subscript, np.ones(10), 11)
 1427:         assert_raises(IndexError, subscript, np.ones(10), -11)
 1428:         assert_raises(IndexError, subscript, np.ones((10, 10)), 11)
 1429:         assert_raises(IndexError, subscript, np.ones((10, 10)), -11)
 1430: 
 1431:         a = np.arange(10)
 1432:         assert_array_equal(a[4], subscript(a, 4))
 1433:         a = a.reshape(5, 2)
 1434:         assert_array_equal(a[-4], subscript(a, -4))
 1435: 
 1436:     def test_setitem(self):
 1437:         assign = functools.partial(array_indexing, 1)
 1438: 
 1439:         # Deletion is impossible:
 1440:         assert_raises(ValueError, assign, np.ones(10), 0)
 1441:         # 0-d arrays don't work:
 1442:         assert_raises(IndexError, assign, np.ones(()), 0, 0)
 1443:         # Out of bound values:
 1444:         assert_raises(IndexError, assign, np.ones(10), 11, 0)
 1445:         assert_raises(IndexError, assign, np.ones(10), -11, 0)
 1446:         assert_raises(IndexError, assign, np.ones((10, 10)), 11, 0)
 1447:         assert_raises(IndexError, assign, np.ones((10, 10)), -11, 0)
 1448: 
 1449:         a = np.arange(10)
 1450:         assign(a, 4, 10)
 1451:         assert_(a[4] == 10)
 1452: 
 1453:         a = a.reshape(5, 2)
 1454:         assign(a, 4, 10)
 1455:         assert_array_equal(a[-1], [10, 10])
