    1: import copy
    2: import itertools
    3: import os
    4: import pickle
    5: import sys
    6: import tempfile
    7: 
    8: import pytest
    9: 
   10: import numpy as np
   11: from numpy._core.tests._natype import get_stringdtype_dtype as get_dtype
   12: from numpy._core.tests._natype import pd_NA
   13: from numpy.dtypes import StringDType
   14: from numpy.testing import IS_PYPY, assert_array_equal
   15: 
   16: 
   17: @pytest.fixture
   18: def string_list():
   19:     return ["abc", "def", "ghi" * 10, "AВўвѓв‚¬ рџЉ" * 100, "Abc" * 1000, "DEF"]
   20: 
   21: 
   22: # second copy for cast tests to do a cartesian product over dtypes
   23: @pytest.fixture(params=[True, False])
   24: def coerce2(request):
   25:     return request.param
   26: 
   27: 
   28: @pytest.fixture(
   29:     params=["unset", None, pd_NA, np.nan, float("nan"), "__nan__"],
   30:     ids=["unset", "None", "pandas.NA", "np.nan", "float('nan')", "string nan"],
   31: )
   32: def na_object2(request):
   33:     return request.param
   34: 
   35: 
   36: @pytest.fixture()
   37: def dtype2(na_object2, coerce2):
   38:     # explicit is check for pd_NA because != with pd_NA returns pd_NA
   39:     if na_object2 is pd_NA or na_object2 != "unset":
   40:         return StringDType(na_object=na_object2, coerce=coerce2)
   41:     else:
   42:         return StringDType(coerce=coerce2)
   43: 
   44: 
   45: def test_dtype_creation():
   46:     hashes = set()
   47:     dt = StringDType()
   48:     assert not hasattr(dt, "na_object") and dt.coerce is True
   49:     hashes.add(hash(dt))
   50: 
   51:     dt = StringDType(na_object=None)
   52:     assert dt.na_object is None and dt.coerce is True
   53:     hashes.add(hash(dt))
   54: 
   55:     dt = StringDType(coerce=False)
   56:     assert not hasattr(dt, "na_object") and dt.coerce is False
   57:     hashes.add(hash(dt))
   58: 
   59:     dt = StringDType(na_object=None, coerce=False)
   60:     assert dt.na_object is None and dt.coerce is False
   61:     hashes.add(hash(dt))
   62: 
   63:     assert len(hashes) == 4
   64: 
   65:     dt = np.dtype("T")
   66:     assert dt == StringDType()
   67:     assert dt.kind == "T"
   68:     assert dt.char == "T"
   69: 
   70:     hashes.add(hash(dt))
   71:     assert len(hashes) == 4
   72: 
   73: 
   74: def test_dtype_equality(dtype):
   75:     assert dtype == dtype
   76:     for ch in "SU":
   77:         assert dtype != np.dtype(ch)
   78:         assert dtype != np.dtype(f"{ch}8")
   79: 
   80: 
   81: def test_dtype_repr(dtype):
   82:     if not hasattr(dtype, "na_object") and dtype.coerce:
   83:         assert repr(dtype) == "StringDType()"
   84:     elif dtype.coerce:
   85:         assert repr(dtype) == f"StringDType(na_object={dtype.na_object!r})"
   86:     elif not hasattr(dtype, "na_object"):
   87:         assert repr(dtype) == "StringDType(coerce=False)"
   88:     else:
   89:         assert (
   90:             repr(dtype)
   91:             == f"StringDType(na_object={dtype.na_object!r}, coerce=False)"
   92:         )
   93: 
   94: 
   95: def test_create_with_na(dtype):
   96:     if not hasattr(dtype, "na_object"):
   97:         pytest.skip("does not have an na object")
   98:     na_val = dtype.na_object
   99:     string_list = ["hello", na_val, "world"]
  100:     arr = np.array(string_list, dtype=dtype)
  101:     assert str(arr) == "[" + " ".join([repr(s) for s in string_list]) + "]"
  102:     assert arr[1] is dtype.na_object
  103: 
  104: 
  105: @pytest.mark.parametrize("i", list(range(5)))
  106: def test_set_replace_na(i):
  107:     # Test strings of various lengths can be set to NaN and then replaced.
  108:     s_empty = ""
  109:     s_short = "0123456789"
  110:     s_medium = "abcdefghijklmnopqrstuvwxyz"
  111:     s_long = "-=+" * 100
  112:     strings = [s_medium, s_empty, s_short, s_medium, s_long]
  113:     a = np.array(strings, StringDType(na_object=np.nan))
  114:     for s in [a[i], s_medium + s_short, s_short, s_empty, s_long]:
  115:         a[i] = np.nan
  116:         assert np.isnan(a[i])
  117:         a[i] = s
  118:         assert a[i] == s
  119:         assert_array_equal(a, strings[:i] + [s] + strings[i + 1:])
  120: 
  121: 
  122: def test_null_roundtripping():
  123:     data = ["hello\0world", "ABC\0DEF\0\0"]
  124:     arr = np.array(data, dtype="T")
  125:     assert data[0] == arr[0]
  126:     assert data[1] == arr[1]
  127: 
  128: 
  129: def test_string_too_large_error():
  130:     arr = np.array(["a", "b", "c"], dtype=StringDType())
  131:     with pytest.raises(OverflowError):
  132:         arr * (sys.maxsize + 1)
  133: 
  134: 
  135: @pytest.mark.parametrize(
  136:     "data",
  137:     [
  138:         ["abc", "def", "ghi"],
  139:         ["рџ¤Ј", "рџ“µ", "рџ°"],
  140:         ["рџљњ", "рџ™ѓ", "рџѕ"],
  141:         ["рџ№", "рџљ ", "рџљЊ"],
  142:     ],
  143: )
  144: def test_array_creation_utf8(dtype, data):
  145:     arr = np.array(data, dtype=dtype)
  146:     assert str(arr) == "[" + " ".join(["'" + str(d) + "'" for d in data]) + "]"
  147:     assert arr.dtype == dtype
  148: 
  149: 
  150: @pytest.mark.parametrize(
  151:     "data",
  152:     [
  153:         [1, 2, 3],
  154:         [b"abc", b"def", b"ghi"],
  155:         [object, object, object],
  156:     ],
  157: )
  158: def test_scalars_string_conversion(data, dtype):
  159:     try:
  160:         str_vals = [str(d.decode('utf-8')) for d in data]
  161:     except AttributeError:
  162:         str_vals = [str(d) for d in data]
  163:     if dtype.coerce:
  164:         assert_array_equal(
  165:             np.array(data, dtype=dtype),
  166:             np.array(str_vals, dtype=dtype),
  167:         )
  168:     else:
  169:         with pytest.raises(ValueError):
  170:             np.array(data, dtype=dtype)
  171: 
  172: 
  173: @pytest.mark.parametrize(
  174:     ("strings"),
  175:     [
  176:         ["this", "is", "an", "array"],
  177:         ["в‚¬", "", "рџЉ"],
  178:         ["AВўвѓв‚¬ рџЉ", " Aвѓв‚¬ВўрџЉ", "вѓв‚¬рџЉ AВў", "рџЉвѓAВў в‚¬"],
  179:     ],
  180: )
  181: def test_self_casts(dtype, dtype2, strings):
  182:     if hasattr(dtype, "na_object"):
  183:         strings = strings + [dtype.na_object]
  184:     elif hasattr(dtype2, "na_object"):
  185:         strings = strings + [""]
  186:     arr = np.array(strings, dtype=dtype)
  187:     newarr = arr.astype(dtype2)
  188: 
  189:     if hasattr(dtype, "na_object") and not hasattr(dtype2, "na_object"):
  190:         assert newarr[-1] == str(dtype.na_object)
  191:         with pytest.raises(TypeError):
  192:             arr.astype(dtype2, casting="safe")
  193:     elif hasattr(dtype, "na_object") and hasattr(dtype2, "na_object"):
  194:         assert newarr[-1] is dtype2.na_object
  195:         arr.astype(dtype2, casting="safe")
  196:     elif hasattr(dtype2, "na_object"):
  197:         assert newarr[-1] == ""
  198:         arr.astype(dtype2, casting="safe")
  199:     else:
  200:         arr.astype(dtype2, casting="safe")
  201: 
  202:     if hasattr(dtype, "na_object") and hasattr(dtype2, "na_object"):
  203:         na1 = dtype.na_object
  204:         na2 = dtype2.na_object
  205:         if (na1 is not na2 and
  206:              # check for pd_NA first because bool(pd_NA) is an error
  207:              ((na1 is pd_NA or na2 is pd_NA) or
  208:               # the second check is a NaN check, spelled this way
  209:               # to avoid errors from math.isnan and np.isnan
  210:               (na1 != na2 and not (na1 != na1 and na2 != na2)))):
  211:             with pytest.raises(TypeError):
  212:                 arr[:-1] == newarr[:-1]
  213:             return
  214:     assert_array_equal(arr[:-1], newarr[:-1])
  215: 
  216: 
  217: @pytest.mark.parametrize(
  218:     ("strings"),
  219:     [
  220:         ["this", "is", "an", "array"],
  221:         ["в‚¬", "", "рџЉ"],
  222:         ["AВўвѓв‚¬ рџЉ", " Aвѓв‚¬ВўрџЉ", "вѓв‚¬рџЉ AВў", "рџЉвѓAВў в‚¬"],
  223:     ],
  224: )
  225: class TestStringLikeCasts:
  226:     def test_unicode_casts(self, dtype, strings):
  227:         arr = np.array(strings, dtype=np.str_).astype(dtype)
  228:         expected = np.array(strings, dtype=dtype)
  229:         assert_array_equal(arr, expected)
  230: 
  231:         arr_as_U8 = expected.astype("U8")
  232:         assert_array_equal(arr_as_U8, np.array(strings, dtype="U8"))
  233:         assert_array_equal(arr_as_U8.astype(dtype), arr)
  234:         arr_as_U3 = expected.astype("U3")
  235:         assert_array_equal(arr_as_U3, np.array(strings, dtype="U3"))
  236:         assert_array_equal(
  237:             arr_as_U3.astype(dtype),
  238:             np.array([s[:3] for s in strings], dtype=dtype),
  239:         )
  240: 
  241:     def test_void_casts(self, dtype, strings):
  242:         sarr = np.array(strings, dtype=dtype)
  243:         utf8_bytes = [s.encode("utf-8") for s in strings]
  244:         void_dtype = f"V{max(len(s) for s in utf8_bytes)}"
  245:         varr = np.array(utf8_bytes, dtype=void_dtype)
  246:         assert_array_equal(varr, sarr.astype(void_dtype))
  247:         assert_array_equal(varr.astype(dtype), sarr)
  248: 
  249:     def test_bytes_casts(self, dtype, strings):
  250:         sarr = np.array(strings, dtype=dtype)
  251:         try:
  252:             utf8_bytes = [s.encode("ascii") for s in strings]
  253:             bytes_dtype = f"S{max(len(s) for s in utf8_bytes)}"
  254:             barr = np.array(utf8_bytes, dtype=bytes_dtype)
  255:             assert_array_equal(barr, sarr.astype(bytes_dtype))
  256:             assert_array_equal(barr.astype(dtype), sarr)
  257:             if dtype.coerce:
  258:                 barr = np.array(utf8_bytes, dtype=dtype)
  259:                 assert_array_equal(barr, sarr)
  260:                 barr = np.array(utf8_bytes, dtype="O")
  261:                 assert_array_equal(barr.astype(dtype), sarr)
  262:             else:
  263:                 with pytest.raises(ValueError):
  264:                     np.array(utf8_bytes, dtype=dtype)
  265:         except UnicodeEncodeError:
  266:             with pytest.raises(UnicodeEncodeError):
  267:                 sarr.astype("S20")
  268: 
  269: 
  270: def test_additional_unicode_cast(random_string_list, dtype):
  271:     arr = np.array(random_string_list, dtype=dtype)
  272:     # test that this short-circuits correctly
  273:     assert_array_equal(arr, arr.astype(arr.dtype))
  274:     # tests the casts via the comparison promoter
  275:     assert_array_equal(arr, arr.astype(random_string_list.dtype))
  276: 
  277: 
  278: def test_insert_scalar(dtype, string_list):
  279:     """Test that inserting a scalar works."""
  280:     arr = np.array(string_list, dtype=dtype)
  281:     scalar_instance = "what"
  282:     arr[1] = scalar_instance
  283:     assert_array_equal(
  284:         arr,
  285:         np.array(string_list[:1] + ["what"] + string_list[2:], dtype=dtype),
  286:     )
  287: 
  288: 
  289: comparison_operators = [
  290:     np.equal,
  291:     np.not_equal,
  292:     np.greater,
  293:     np.greater_equal,
  294:     np.less,
  295:     np.less_equal,
  296: ]
  297: 
  298: 
  299: @pytest.mark.parametrize("op", comparison_operators)
  300: @pytest.mark.parametrize("o_dtype", [np.str_, object, StringDType()])
  301: def test_comparisons(string_list, dtype, op, o_dtype):
  302:     sarr = np.array(string_list, dtype=dtype)
  303:     oarr = np.array(string_list, dtype=o_dtype)
  304: 
  305:     # test that comparison operators work
  306:     res = op(sarr, sarr)
  307:     ores = op(oarr, oarr)
  308:     # test that promotion works as well
  309:     orres = op(sarr, oarr)
  310:     olres = op(oarr, sarr)
  311: 
  312:     assert_array_equal(res, ores)
  313:     assert_array_equal(res, orres)
  314:     assert_array_equal(res, olres)
  315: 
  316:     # test we get the correct answer for unequal length strings
  317:     sarr2 = np.array([s + "2" for s in string_list], dtype=dtype)
  318:     oarr2 = np.array([s + "2" for s in string_list], dtype=o_dtype)
  319: 
  320:     res = op(sarr, sarr2)
  321:     ores = op(oarr, oarr2)
  322:     olres = op(oarr, sarr2)
  323:     orres = op(sarr, oarr2)
  324: 
  325:     assert_array_equal(res, ores)
  326:     assert_array_equal(res, olres)
  327:     assert_array_equal(res, orres)
  328: 
  329:     res = op(sarr2, sarr)
  330:     ores = op(oarr2, oarr)
  331:     olres = op(oarr2, sarr)
  332:     orres = op(sarr2, oarr)
  333: 
  334:     assert_array_equal(res, ores)
  335:     assert_array_equal(res, olres)
  336:     assert_array_equal(res, orres)
  337: 
  338: 
  339: def test_isnan(dtype, string_list):
  340:     if not hasattr(dtype, "na_object"):
  341:         pytest.skip("no na support")
  342:     sarr = np.array(string_list + [dtype.na_object], dtype=dtype)
  343:     is_nan = isinstance(dtype.na_object, float) and np.isnan(dtype.na_object)
  344:     bool_errors = 0
  345:     try:
  346:         bool(dtype.na_object)
  347:     except TypeError:
  348:         bool_errors = 1
  349:     if is_nan or bool_errors:
  350:         # isnan is only true when na_object is a NaN
  351:         assert_array_equal(
  352:             np.isnan(sarr),
  353:             np.array([0] * len(string_list) + [1], dtype=np.bool),
  354:         )
  355:     else:
  356:         assert not np.any(np.isnan(sarr))
  357: 
  358: 
  359: def test_pickle(dtype, string_list):
  360:     arr = np.array(string_list, dtype=dtype)
  361: 
  362:     with tempfile.NamedTemporaryFile("wb", delete=False) as f:
  363:         pickle.dump([arr, dtype], f)
  364: 
  365:     with open(f.name, "rb") as f:
  366:         res = pickle.load(f)
  367: 
  368:     assert_array_equal(res[0], arr)
  369:     assert res[1] == dtype
  370: 
  371:     os.remove(f.name)
  372: 
  373: 
  374: def test_stdlib_copy(dtype, string_list):
  375:     arr = np.array(string_list, dtype=dtype)
  376: 
  377:     assert_array_equal(copy.copy(arr), arr)
  378:     assert_array_equal(copy.deepcopy(arr), arr)
  379: 
  380: 
  381: @pytest.mark.parametrize(
  382:     "strings",
  383:     [
  384:         ["left", "right", "leftovers", "righty", "up", "down"],
  385:         [
  386:             "left" * 10,
  387:             "right" * 10,
  388:             "leftovers" * 10,
  389:             "righty" * 10,
  390:             "up" * 10,
  391:         ],
  392:         ["рџ¤Јрџ¤Ј", "рџ¤Ј", "рџ“µ", "рџ°"],
  393:         ["рџљњ", "рџ™ѓ", "рџѕ"],
  394:         ["рџ№", "рџљ ", "рџљЊ"],
  395:         ["AВўвѓв‚¬ рџЉ", " Aвѓв‚¬ВўрџЉ", "вѓв‚¬рџЉ AВў", "рџЉвѓAВў в‚¬"],
  396:     ],
  397: )
  398: def test_sort(dtype, strings):
  399:     """Test that sorting matches python's internal sorting."""
  400: 
  401:     def test_sort(strings, arr_sorted):
  402:         arr = np.array(strings, dtype=dtype)
  403:         na_object = getattr(arr.dtype, "na_object", "")
  404:         if na_object is None and None in strings:
  405:             with pytest.raises(
  406:                 ValueError,
  407:                 match="Cannot compare null that is not a nan-like value",
  408:             ):
  409:                 np.argsort(arr)
  410:             argsorted = None
  411:         elif na_object is pd_NA or na_object != '':
  412:             argsorted = None
  413:         else:
  414:             argsorted = np.argsort(arr)
  415:         np.random.default_rng().shuffle(arr)
  416:         if na_object is None and None in strings:
  417:             with pytest.raises(
  418:                 ValueError,
  419:                 match="Cannot compare null that is not a nan-like value",
  420:             ):
  421:                 arr.sort()
  422:         else:
  423:             arr.sort()
  424:             assert np.array_equal(arr, arr_sorted, equal_nan=True)
  425:         if argsorted is not None:
  426:             assert np.array_equal(argsorted, np.argsort(strings))
  427: 
  428:     # make a copy so we don't mutate the lists in the fixture
  429:     strings = strings.copy()
  430:     arr_sorted = np.array(sorted(strings), dtype=dtype)
  431:     test_sort(strings, arr_sorted)
  432: 
  433:     if not hasattr(dtype, "na_object"):
  434:         return
  435: 
  436:     # make sure NAs get sorted to the end of the array and string NAs get
  437:     # sorted like normal strings
  438:     strings.insert(0, dtype.na_object)
  439:     strings.insert(2, dtype.na_object)
  440:     # can't use append because doing that with NA converts
  441:     # the result to object dtype
  442:     if not isinstance(dtype.na_object, str):
  443:         arr_sorted = np.array(
  444:             arr_sorted.tolist() + [dtype.na_object, dtype.na_object],
  445:             dtype=dtype,
  446:         )
  447:     else:
  448:         arr_sorted = np.array(sorted(strings), dtype=dtype)
  449: 
  450:     test_sort(strings, arr_sorted)
  451: 
  452: 
  453: @pytest.mark.parametrize(
  454:     "strings",
  455:     [
  456:         ["AВўвѓв‚¬ рџЉ", " Aвѓв‚¬ВўрџЉ", "вѓв‚¬рџЉ AВў", "рџЉвѓAВў в‚¬"],
  457:         ["AВўвѓв‚¬ рџЉ", "", " ", "пђЂ "],
  458:         ["", "a", "рџё", "ГЎГЎГ°fГЎГ­ГіГҐГ©Г«"],
  459:     ],
  460: )
  461: def test_nonzero(strings, na_object):
  462:     dtype = get_dtype(na_object)
  463:     arr = np.array(strings, dtype=dtype)
  464:     is_nonzero = np.array(
  465:         [i for i, item in enumerate(strings) if len(item) != 0])
  466:     assert_array_equal(arr.nonzero()[0], is_nonzero)
  467: 
  468:     if na_object is not pd_NA and na_object == 'unset':
  469:         return
  470: 
  471:     strings_with_na = np.array(strings + [na_object], dtype=dtype)
  472:     is_nan = np.isnan(np.array([dtype.na_object], dtype=dtype))[0]
  473: 
  474:     if is_nan:
  475:         assert strings_with_na.nonzero()[0][-1] == 4
  476:     else:
  477:         assert strings_with_na.nonzero()[0][-1] == 3
  478: 
  479:     # check that the casting to bool and nonzero give consistent results
  480:     assert_array_equal(strings_with_na[strings_with_na.nonzero()],
  481:                        strings_with_na[strings_with_na.astype(bool)])
  482: 
  483: 
  484: def test_where(string_list, na_object):
  485:     dtype = get_dtype(na_object)
  486:     a = np.array(string_list, dtype=dtype)
  487:     b = a[::-1]
  488:     res = np.where([True, False, True, False, True, False], a, b)
  489:     assert_array_equal(res, [a[0], b[1], a[2], b[3], a[4], b[5]])
  490: 
  491: 
  492: def test_fancy_indexing(string_list):
  493:     sarr = np.array(string_list, dtype="T")
  494:     assert_array_equal(sarr, sarr[np.arange(sarr.shape[0])])
  495: 
  496:     inds = [
  497:         [True, True],
  498:         [0, 1],
  499:         ...,
  500:         np.array([0, 1], dtype='uint8'),
  501:     ]
  502: 
  503:     lops = [
  504:         ['a' * 25, 'b' * 25],
  505:         ['', ''],
  506:         ['hello', 'world'],
  507:         ['hello', 'world' * 25],
  508:     ]
  509: 
  510:     # see gh-27003 and gh-27053
  511:     for ind in inds:
  512:         for lop in lops:
  513:             a = np.array(lop, dtype="T")
  514:             assert_array_equal(a[ind], a)
  515:             rop = ['d' * 25, 'e' * 25]
  516:             for b in [rop, np.array(rop, dtype="T")]:
  517:                 a[ind] = b
  518:                 assert_array_equal(a, b)
  519:                 assert a[0] == 'd' * 25
  520: 
  521:     # see gh-29279
  522:     data = [
  523:         ["AAAAAAAAAAAAAAAAA"],
  524:         ["BBBBBBBBBBBBBBBBBBBBBBBBBBBBB"],
  525:         ["CCCCCCCCCCCCCCCCC"],
  526:         ["DDDDDDDDDDDDDDDDD"],
  527:     ]
  528:     sarr = np.array(data, dtype=np.dtypes.StringDType())
  529:     uarr = np.array(data, dtype="U30")
  530:     for ind in [[0], [1], [2], [3], [[0, 0]], [[1, 1, 3]], [[1, 1]]]:
  531:         assert_array_equal(sarr[ind], uarr[ind])
  532: 
  533: 
  534: def test_creation_functions():
  535:     assert_array_equal(np.zeros(3, dtype="T"), ["", "", ""])
  536:     assert_array_equal(np.empty(3, dtype="T"), ["", "", ""])
  537: 
  538:     assert np.zeros(3, dtype="T")[0] == ""
  539:     assert np.empty(3, dtype="T")[0] == ""
  540: 
  541: 
  542: def test_concatenate(string_list):
  543:     sarr = np.array(string_list, dtype="T")
  544:     sarr_cat = np.array(string_list + string_list, dtype="T")
  545: 
  546:     assert_array_equal(np.concatenate([sarr], axis=0), sarr)
  547: 
  548: 
  549: def test_resize_method(string_list):
  550:     sarr = np.array(string_list, dtype="T")
  551:     if IS_PYPY:
  552:         sarr.resize(len(string_list) + 3, refcheck=False)
  553:     else:
  554:         sarr.resize(len(string_list) + 3)
  555:     assert_array_equal(sarr, np.array(string_list + [''] * 3,  dtype="T"))
  556: 
  557: 
  558: def test_create_with_copy_none(string_list):
  559:     arr = np.array(string_list, dtype=StringDType())
  560:     # create another stringdtype array with an arena that has a different
  561:     # in-memory layout than the first array
  562:     arr_rev = np.array(string_list[::-1], dtype=StringDType())
  563: 
  564:     # this should create a copy and the resulting array
  565:     # shouldn't share an allocator or arena with arr_rev, despite
  566:     # explicitly passing arr_rev.dtype
  567:     arr_copy = np.array(arr, copy=None, dtype=arr_rev.dtype)
  568:     np.testing.assert_array_equal(arr, arr_copy)
  569:     assert arr_copy.base is None
  570: 
  571:     with pytest.raises(ValueError, match="Unable to avoid copy"):
  572:         np.array(arr, copy=False, dtype=arr_rev.dtype)
  573: 
  574:     # because we're using arr's dtype instance, the view is safe
  575:     arr_view = np.array(arr, copy=None, dtype=arr.dtype)
  576:     np.testing.assert_array_equal(arr, arr)
  577:     np.testing.assert_array_equal(arr_view[::-1], arr_rev)
  578:     assert arr_view is arr
  579: 
  580: 
  581: def test_astype_copy_false():
  582:     orig_dt = StringDType()
  583:     arr = np.array(["hello", "world"], dtype=StringDType())
  584:     assert not arr.astype(StringDType(coerce=False), copy=False).dtype.coerce
  585: 
  586:     assert arr.astype(orig_dt, copy=False).dtype is orig_dt
  587: 
  588: @pytest.mark.parametrize(
  589:     "strings",
  590:     [
  591:         ["left", "right", "leftovers", "righty", "up", "down"],
  592:         ["рџ¤Јрџ¤Ј", "рџ¤Ј", "рџ“µ", "рџ°"],
  593:         ["рџљњ", "рџ™ѓ", "рџѕ"],
  594:         ["рџ№", "рџљ ", "рџљЊ"],
  595:         ["AВўвѓв‚¬ рџЉ", " Aвѓв‚¬ВўрџЉ", "вѓв‚¬рџЉ AВў", "рџЉвѓAВў в‚¬"],
  596:     ],
  597: )
  598: def test_argmax(strings):
  599:     """Test that argmax/argmin matches what python calculates."""
  600:     arr = np.array(strings, dtype="T")
  601:     assert np.argmax(arr) == strings.index(max(strings))
  602:     assert np.argmin(arr) == strings.index(min(strings))
  603: 
  604: 
  605: @pytest.mark.parametrize(
  606:     "arrfunc,expected",
  607:     [
  608:         [np.sort, None],
  609:         [np.nonzero, (np.array([], dtype=np.int_),)],
  610:         [np.argmax, 0],
  611:         [np.argmin, 0],
  612:     ],
  613: )
  614: def test_arrfuncs_zeros(arrfunc, expected):
  615:     arr = np.zeros(10, dtype="T")
  616:     result = arrfunc(arr)
  617:     if expected is None:
  618:         expected = arr
  619:     assert_array_equal(result, expected, strict=True)
  620: 
  621: 
  622: @pytest.mark.parametrize(
  623:     ("strings", "cast_answer", "any_answer", "all_answer"),
  624:     [
  625:         [["hello", "world"], [True, True], True, True],
  626:         [["", ""], [False, False], False, False],
  627:         [["hello", ""], [True, False], True, False],
  628:         [["", "world"], [False, True], True, False],
  629:     ],
  630: )
  631: def test_cast_to_bool(strings, cast_answer, any_answer, all_answer):
  632:     sarr = np.array(strings, dtype="T")
  633:     assert_array_equal(sarr.astype("bool"), cast_answer)
  634: 
  635:     assert np.any(sarr) == any_answer
  636:     assert np.all(sarr) == all_answer
  637: 
  638: 
  639: @pytest.mark.parametrize(
  640:     ("strings", "cast_answer"),
  641:     [
  642:         [[True, True], ["True", "True"]],
  643:         [[False, False], ["False", "False"]],
  644:         [[True, False], ["True", "False"]],
  645:         [[False, True], ["False", "True"]],
  646:     ],
  647: )
  648: def test_cast_from_bool(strings, cast_answer):
  649:     barr = np.array(strings, dtype=bool)
  650:     assert_array_equal(barr.astype("T"), np.array(cast_answer, dtype="T"))
  651: 
  652: 
  653: @pytest.mark.parametrize("bitsize", [8, 16, 32, 64])
  654: @pytest.mark.parametrize("signed", [True, False])
  655: def test_sized_integer_casts(bitsize, signed):
  656:     idtype = f"int{bitsize}"
  657:     if signed:
  658:         inp = [-(2**p - 1) for p in reversed(range(bitsize - 1))]
  659:         inp += [2**p - 1 for p in range(1, bitsize - 1)]
  660:     else:
  661:         idtype = "u" + idtype
  662:         inp = [2**p - 1 for p in range(bitsize)]
  663:     ainp = np.array(inp, dtype=idtype)
  664:     assert_array_equal(ainp, ainp.astype("T").astype(idtype))
  665: 
  666:     # safe casting works
  667:     ainp.astype("T", casting="safe")
  668: 
  669:     with pytest.raises(TypeError):
  670:         ainp.astype("T").astype(idtype, casting="safe")
  671: 
  672:     oob = [str(2**bitsize), str(-(2**bitsize))]
  673:     with pytest.raises(OverflowError):
  674:         np.array(oob, dtype="T").astype(idtype)
  675: 
  676:     with pytest.raises(ValueError):
  677:         np.array(["1", np.nan, "3"],
  678:                  dtype=StringDType(na_object=np.nan)).astype(idtype)
  679: 
  680: 
  681: @pytest.mark.parametrize("typename", ["byte", "short", "int", "longlong"])
  682: @pytest.mark.parametrize("signed", ["", "u"])
  683: def test_unsized_integer_casts(typename, signed):
  684:     idtype = f"{signed}{typename}"
  685: 
  686:     inp = [1, 2, 3, 4]
  687:     ainp = np.array(inp, dtype=idtype)
  688:     assert_array_equal(ainp, ainp.astype("T").astype(idtype))
  689: 
  690: 
  691: @pytest.mark.parametrize(
  692:     "typename",
  693:     [
  694:         pytest.param(
  695:             "longdouble",
  696:             marks=pytest.mark.xfail(
  697:                 np.dtypes.LongDoubleDType() != np.dtypes.Float64DType(),
  698:                 reason="numpy lacks an ld2a implementation",
  699:                 strict=True,
  700:             ),
  701:         ),
  702:         "float64",
  703:         "float32",
  704:         "float16",
  705:     ],
  706: )
  707: def test_float_casts(typename):
  708:     inp = [1.1, 2.8, -3.2, 2.7e4]
  709:     ainp = np.array(inp, dtype=typename)
  710:     assert_array_equal(ainp, ainp.astype("T").astype(typename))
  711: 
  712:     inp = [0.1]
  713:     sres = np.array(inp, dtype=typename).astype("T")
  714:     res = sres.astype(typename)
  715:     assert_array_equal(np.array(inp, dtype=typename), res)
  716:     assert sres[0] == "0.1"
  717: 
  718:     if typename == "longdouble":
  719:         # let's not worry about platform-dependent rounding of longdouble
  720:         return
  721: 
  722:     fi = np.finfo(typename)
  723: 
  724:     inp = [1e-324, fi.smallest_subnormal, -1e-324, -fi.smallest_subnormal]
  725:     eres = [0, fi.smallest_subnormal, -0, -fi.smallest_subnormal]
  726:     res = np.array(inp, dtype=typename).astype("T").astype(typename)
  727:     assert_array_equal(eres, res)
  728: 
  729:     inp = [2e308, fi.max, -2e308, fi.min]
  730:     eres = [np.inf, fi.max, -np.inf, fi.min]
  731:     res = np.array(inp, dtype=typename).astype("T").astype(typename)
  732:     assert_array_equal(eres, res)
  733: 
  734: 
  735: def test_float_nan_cast_na_object():
  736:     # gh-28157
  737:     dt = np.dtypes.StringDType(na_object=np.nan)
  738:     arr1 = np.full((1,), fill_value=np.nan, dtype=dt)
  739:     arr2 = np.full_like(arr1, fill_value=np.nan)
  740: 
  741:     assert arr1.item() is np.nan
  742:     assert arr2.item() is np.nan
  743: 
  744:     inp = [1.2, 2.3, np.nan]
  745:     arr = np.array(inp).astype(dt)
  746:     assert arr[2] is np.nan
  747:     assert arr[0] == '1.2'
  748: 
  749: 
  750: @pytest.mark.parametrize(
  751:     "typename",
  752:     [
  753:         "csingle",
  754:         "cdouble",
  755:         pytest.param(
  756:             "clongdouble",
  757:             marks=pytest.mark.xfail(
  758:                 np.dtypes.CLongDoubleDType() != np.dtypes.Complex128DType(),
  759:                 reason="numpy lacks an ld2a implementation",
  760:                 strict=True,
  761:             ),
  762:         ),
  763:     ],
  764: )
  765: def test_cfloat_casts(typename):
  766:     inp = [1.1 + 1.1j, 2.8 + 2.8j, -3.2 - 3.2j, 2.7e4 + 2.7e4j]
  767:     ainp = np.array(inp, dtype=typename)
  768:     assert_array_equal(ainp, ainp.astype("T").astype(typename))
  769: 
  770:     inp = [0.1 + 0.1j]
  771:     sres = np.array(inp, dtype=typename).astype("T")
  772:     res = sres.astype(typename)
  773:     assert_array_equal(np.array(inp, dtype=typename), res)
  774:     assert sres[0] == "(0.1+0.1j)"
  775: 
  776: 
  777: def test_take(string_list):
  778:     sarr = np.array(string_list, dtype="T")
  779:     res = sarr.take(np.arange(len(string_list)))
  780:     assert_array_equal(sarr, res)
  781: 
  782:     # make sure it also works for out
  783:     out = np.empty(len(string_list), dtype="T")
  784:     out[0] = "hello"
  785:     res = sarr.take(np.arange(len(string_list)), out=out)
  786:     assert res is out
  787:     assert_array_equal(sarr, res)
  788: 
  789: 
  790: @pytest.mark.parametrize("use_out", [True, False])
  791: @pytest.mark.parametrize(
  792:     "ufunc_name,func",
  793:     [
  794:         ("min", min),
  795:         ("max", max),
  796:     ],
  797: )
  798: def test_ufuncs_minmax(string_list, ufunc_name, func, use_out):
  799:     """Test that the min/max ufuncs match Python builtin min/max behavior."""
  800:     arr = np.array(string_list, dtype="T")
  801:     uarr = np.array(string_list, dtype=str)
  802:     res = np.array(func(string_list), dtype="T")
  803:     assert_array_equal(getattr(arr, ufunc_name)(), res)
  804: 
  805:     ufunc = getattr(np, ufunc_name + "imum")
  806: 
  807:     if use_out:
  808:         res = ufunc(arr, arr, out=arr)
  809:     else:
  810:         res = ufunc(arr, arr)
  811: 
  812:     assert_array_equal(uarr, res)
  813:     assert_array_equal(getattr(arr, ufunc_name)(), func(string_list))
  814: 
  815: 
  816: def test_max_regression():
  817:     arr = np.array(['y', 'y', 'z'], dtype="T")
  818:     assert arr.max() == 'z'
  819: 
  820: 
  821: @pytest.mark.parametrize("use_out", [True, False])
  822: @pytest.mark.parametrize(
  823:     "other_strings",
  824:     [
  825:         ["abc", "def" * 500, "ghi" * 16, "рџ¤Ј" * 100, "рџ“µ", "рџ°"],
  826:         ["рџљњ", "рџ™ѓ", "рџѕ", "рџ№", "рџљ ", "рџљЊ"],
  827:         ["рџҐ¦", "ВЁ", "вЁЇ", "в€° ", "вЁЊ ", "вЋ¶ "],
  828:     ],
  829: )
  830: def test_ufunc_add(dtype, string_list, other_strings, use_out):
  831:     arr1 = np.array(string_list, dtype=dtype)
  832:     arr2 = np.array(other_strings, dtype=dtype)
  833:     result = np.array([a + b for a, b in zip(arr1, arr2)], dtype=dtype)
  834: 
  835:     if use_out:
  836:         res = np.add(arr1, arr2, out=arr1)
  837:     else:
  838:         res = np.add(arr1, arr2)
  839: 
  840:     assert_array_equal(res, result)
  841: 
  842:     if not hasattr(dtype, "na_object"):
  843:         return
  844: 
  845:     is_nan = isinstance(dtype.na_object, float) and np.isnan(dtype.na_object)
  846:     is_str = isinstance(dtype.na_object, str)
  847:     bool_errors = 0
  848:     try:
  849:         bool(dtype.na_object)
  850:     except TypeError:
  851:         bool_errors = 1
  852: 
  853:     arr1 = np.array([dtype.na_object] + string_list, dtype=dtype)
  854:     arr2 = np.array(other_strings + [dtype.na_object], dtype=dtype)
  855: 
  856:     if is_nan or bool_errors or is_str:
  857:         res = np.add(arr1, arr2)
  858:         assert_array_equal(res[1:-1], arr1[1:-1] + arr2[1:-1])
  859:         if not is_str:
  860:             assert res[0] is dtype.na_object and res[-1] is dtype.na_object
  861:         else:
  862:             assert res[0] == dtype.na_object + arr2[0]
  863:             assert res[-1] == arr1[-1] + dtype.na_object
  864:     else:
  865:         with pytest.raises(ValueError):
  866:             np.add(arr1, arr2)
  867: 
  868: 
  869: def test_ufunc_add_reduce(dtype):
  870:     values = ["a", "this is a long string", "c"]
  871:     arr = np.array(values, dtype=dtype)
  872:     out = np.empty((), dtype=dtype)
  873: 
  874:     expected = np.array("".join(values), dtype=dtype)
  875:     assert_array_equal(np.add.reduce(arr), expected)
  876: 
  877:     np.add.reduce(arr, out=out)
  878:     assert_array_equal(out, expected)
  879: 
  880: 
  881: def test_add_promoter(string_list):
  882:     arr = np.array(string_list, dtype=StringDType())
  883:     lresult = np.array(["hello" + s for s in string_list], dtype=StringDType())
  884:     rresult = np.array([s + "hello" for s in string_list], dtype=StringDType())
  885: 
  886:     for op in ["hello", np.str_("hello"), np.array(["hello"])]:
  887:         assert_array_equal(op + arr, lresult)
  888:         assert_array_equal(arr + op, rresult)
  889: 
  890:     # The promoter should be able to handle things if users pass `dtype=`
  891:     res = np.add("hello", string_list, dtype=StringDType)
  892:     assert res.dtype == StringDType()
  893: 
  894:     # The promoter should not kick in if users override the input,
  895:     # which means arr is cast, this fails because of the unknown length.
  896:     with pytest.raises(TypeError, match="cannot cast dtype"):
  897:         np.add(arr, "add", signature=("U", "U", None), casting="unsafe")
  898: 
  899:     # But it must simply reject the following:
  900:     with pytest.raises(TypeError, match=".*did not contain a loop"):
  901:         np.add(arr, "add", signature=(None, "U", None))
  902: 
  903:     with pytest.raises(TypeError, match=".*did not contain a loop"):
  904:         np.add("a", "b", signature=("U", "U", StringDType))
  905: 
  906: 
  907: def test_add_no_legacy_promote_with_signature():
  908:     # Possibly misplaced, but useful to test with string DType.  We check that
  909:     # if there is clearly no loop found, a stray `dtype=` doesn't break things
  910:     # Regression test for the bad error in gh-26735
  911:     # (If legacy promotion is gone, this can be deleted...)
  912:     with pytest.raises(TypeError, match=".*did not contain a loop"):
  913:         np.add("3", 6, dtype=StringDType)
  914: 
  915: 
  916: def test_add_promoter_reduce():
  917:     # Exact TypeError could change, but ensure StringDtype doesn't match
  918:     with pytest.raises(TypeError, match="the resolved dtypes are not"):
  919:         np.add.reduce(np.array(["a", "b"], dtype="U"))
  920: 
  921:     # On the other hand, using `dtype=T` in the *ufunc* should work.
  922:     np.add.reduce(np.array(["a", "b"], dtype="U"), dtype=np.dtypes.StringDType)
  923: 
  924: 
  925: def test_multiply_reduce():
  926:     # At the time of writing (NumPy 2.0) this is very limited (and rather
  927:     # ridiculous anyway).  But it works and actually makes some sense...
  928:     # (NumPy does not allow non-scalar initial values)
  929:     repeats = np.array([2, 3, 4])
  930:     val = "school-рџљЊ"
  931:     res = np.multiply.reduce(repeats, initial=val, dtype=np.dtypes.StringDType)
  932:     assert res == val * np.prod(repeats)
  933: 
  934: 
  935: def test_multiply_two_string_raises():
  936:     arr = np.array(["hello", "world"], dtype="T")
  937:     with pytest.raises(np._core._exceptions._UFuncNoLoopError):
  938:         np.multiply(arr, arr)
  939: 
  940: 
  941: @pytest.mark.parametrize("use_out", [True, False])
  942: @pytest.mark.parametrize("other", [2, [2, 1, 3, 4, 1, 3]])
  943: @pytest.mark.parametrize(
  944:     "other_dtype",
  945:     [
  946:         None,
  947:         "int8",
  948:         "int16",
  949:         "int32",
  950:         "int64",
  951:         "uint8",
  952:         "uint16",
  953:         "uint32",
  954:         "uint64",
  955:         "short",
  956:         "int",
  957:         "intp",
  958:         "long",
  959:         "longlong",
  960:         "ushort",
  961:         "uint",
  962:         "uintp",
  963:         "ulong",
  964:         "ulonglong",
  965:     ],
  966: )
  967: def test_ufunc_multiply(dtype, string_list, other, other_dtype, use_out):
  968:     """Test the two-argument ufuncs match python builtin behavior."""
  969:     arr = np.array(string_list, dtype=dtype)
  970:     if other_dtype is not None:
  971:         other_dtype = np.dtype(other_dtype)
  972:     try:
  973:         len(other)
  974:         result = [s * o for s, o in zip(string_list, other)]
  975:         other = np.array(other)
  976:         if other_dtype is not None:
  977:             other = other.astype(other_dtype)
  978:     except TypeError:
  979:         if other_dtype is not None:
  980:             other = other_dtype.type(other)
  981:         result = [s * other for s in string_list]
  982: 
  983:     if use_out:
  984:         arr_cache = arr.copy()
  985:         lres = np.multiply(arr, other, out=arr)
  986:         assert_array_equal(lres, result)
  987:         arr[:] = arr_cache
  988:         assert lres is arr
  989:         arr *= other
  990:         assert_array_equal(arr, result)
  991:         arr[:] = arr_cache
  992:         rres = np.multiply(other, arr, out=arr)
  993:         assert rres is arr
  994:         assert_array_equal(rres, result)
  995:     else:
  996:         lres = arr * other
  997:         assert_array_equal(lres, result)
  998:         rres = other * arr
  999:         assert_array_equal(rres, result)
 1000: 
 1001:     if not hasattr(dtype, "na_object"):
 1002:         return
 1003: 
 1004:     is_nan = np.isnan(np.array([dtype.na_object], dtype=dtype))[0]
 1005:     is_str = isinstance(dtype.na_object, str)
 1006:     bool_errors = 0
 1007:     try:
 1008:         bool(dtype.na_object)
 1009:     except TypeError:
 1010:         bool_errors = 1
 1011: 
 1012:     arr = np.array(string_list + [dtype.na_object], dtype=dtype)
 1013: 
 1014:     try:
 1015:         len(other)
 1016:         other = np.append(other, 3)
 1017:         if other_dtype is not None:
 1018:             other = other.astype(other_dtype)
 1019:     except TypeError:
 1020:         pass
 1021: 
 1022:     if is_nan or bool_errors or is_str:
 1023:         for res in [arr * other, other * arr]:
 1024:             assert_array_equal(res[:-1], result)
 1025:             if not is_str:
 1026:                 assert res[-1] is dtype.na_object
 1027:             else:
 1028:                 try:
 1029:                     assert res[-1] == dtype.na_object * other[-1]
 1030:                 except (IndexError, TypeError):
 1031:                     assert res[-1] == dtype.na_object * other
 1032:     else:
 1033:         with pytest.raises(TypeError):
 1034:             arr * other
 1035:         with pytest.raises(TypeError):
 1036:             other * arr
 1037: 
 1038: 
 1039: def test_findlike_promoters():
 1040:     r = "Wally"
 1041:     l = "Where's Wally?"
 1042:     s = np.int32(3)
 1043:     e = np.int8(13)
 1044:     for dtypes in [("T", "U"), ("U", "T")]:
 1045:         for function, answer in [
 1046:             (np.strings.index, 8),
 1047:             (np.strings.endswith, True),
 1048:         ]:
 1049:             assert answer == function(
 1050:                 np.array(l, dtype=dtypes[0]), np.array(r, dtype=dtypes[1]), s, e
 1051:             )
 1052: 
 1053: 
 1054: def test_strip_promoter():
 1055:     arg = ["Hello!!!!", "Hello??!!"]
 1056:     strip_char = "!"
 1057:     answer = ["Hello", "Hello??"]
 1058:     for dtypes in [("T", "U"), ("U", "T")]:
 1059:         result = np.strings.strip(
 1060:             np.array(arg, dtype=dtypes[0]),
 1061:             np.array(strip_char, dtype=dtypes[1])
 1062:         )
 1063:         assert_array_equal(result, answer)
 1064:         assert result.dtype.char == "T"
 1065: 
 1066: 
 1067: def test_replace_promoter():
 1068:     arg = ["Hello, planet!", "planet, Hello!"]
 1069:     old = "planet"
 1070:     new = "world"
 1071:     answer = ["Hello, world!", "world, Hello!"]
 1072:     for dtypes in itertools.product("TU", repeat=3):
 1073:         if dtypes == ("U", "U", "U"):
 1074:             continue
 1075:         answer_arr = np.strings.replace(
 1076:             np.array(arg, dtype=dtypes[0]),
 1077:             np.array(old, dtype=dtypes[1]),
 1078:             np.array(new, dtype=dtypes[2]),
 1079:         )
 1080:         assert_array_equal(answer_arr, answer)
 1081:         assert answer_arr.dtype.char == "T"
 1082: 
 1083: 
 1084: def test_center_promoter():
 1085:     arg = ["Hello", "planet!"]
 1086:     fillchar = "/"
 1087:     for dtypes in [("T", "U"), ("U", "T")]:
 1088:         answer = np.strings.center(
 1089:             np.array(arg, dtype=dtypes[0]), 9, np.array(fillchar, dtype=dtypes[1])
 1090:         )
 1091:         assert_array_equal(answer, ["//Hello//", "/planet!/"])
 1092:         assert answer.dtype.char == "T"
 1093: 
 1094: 
 1095: DATETIME_INPUT = [
 1096:     np.datetime64("1923-04-14T12:43:12"),
 1097:     np.datetime64("1994-06-21T14:43:15"),
 1098:     np.datetime64("2001-10-15T04:10:32"),
 1099:     np.datetime64("NaT"),
 1100:     np.datetime64("1995-11-25T16:02:16"),
 1101:     np.datetime64("2005-01-04T03:14:12"),
 1102:     np.datetime64("2041-12-03T14:05:03"),
 1103: ]
 1104: 
 1105: 
 1106: TIMEDELTA_INPUT = [
 1107:     np.timedelta64(12358, "s"),
 1108:     np.timedelta64(23, "s"),
 1109:     np.timedelta64(74, "s"),
 1110:     np.timedelta64("NaT"),
 1111:     np.timedelta64(23, "s"),
 1112:     np.timedelta64(73, "s"),
 1113:     np.timedelta64(7, "s"),
 1114: ]
 1115: 
 1116: 
 1117: @pytest.mark.parametrize(
 1118:     "input_data, input_dtype",
 1119:     [
 1120:         (DATETIME_INPUT, "M8[s]"),
 1121:         (TIMEDELTA_INPUT, "m8[s]")
 1122:     ]
 1123: )
 1124: def test_datetime_timedelta_cast(dtype, input_data, input_dtype):
 1125: 
 1126:     a = np.array(input_data, dtype=input_dtype)
 1127: 
 1128:     has_na = hasattr(dtype, "na_object")
 1129:     is_str = isinstance(getattr(dtype, "na_object", None), str)
 1130: 
 1131:     if not has_na or is_str:
 1132:         a = np.delete(a, 3)
 1133: 
 1134:     sa = a.astype(dtype)
 1135:     ra = sa.astype(a.dtype)
 1136: 
 1137:     if has_na and not is_str:
 1138:         assert sa[3] is dtype.na_object
 1139:         assert np.isnat(ra[3])
 1140: 
 1141:     assert_array_equal(a, ra)
 1142: 
 1143:     if has_na and not is_str:
 1144:         # don't worry about comparing how NaT is converted
 1145:         sa = np.delete(sa, 3)
 1146:         a = np.delete(a, 3)
 1147: 
 1148:     if input_dtype.startswith("M"):
 1149:         assert_array_equal(sa, a.astype("U"))
 1150:     else:
 1151:         # The timedelta to unicode cast produces strings
 1152:         # that aren't round-trippable and we don't want to
 1153:         # reproduce that behavior in stringdtype
 1154:         assert_array_equal(sa, a.astype("int64").astype("U"))
 1155: 
 1156: 
 1157: def test_nat_casts():
 1158:     s = 'nat'
 1159:     all_nats = itertools.product(*zip(s.upper(), s.lower()))
 1160:     all_nats = list(map(''.join, all_nats))
 1161:     NaT_dt = np.datetime64('NaT')
 1162:     NaT_td = np.timedelta64('NaT')
 1163:     for na_object in [np._NoValue, None, np.nan, 'nat', '']:
 1164:         # numpy treats empty string and all case combinations of 'nat' as NaT
 1165:         dtype = StringDType(na_object=na_object)
 1166:         arr = np.array([''] + all_nats, dtype=dtype)
 1167:         dt_array = arr.astype('M8[s]')
 1168:         td_array = arr.astype('m8[s]')
 1169:         assert_array_equal(dt_array, NaT_dt)
 1170:         assert_array_equal(td_array, NaT_td)
 1171: 
 1172:         if na_object is np._NoValue:
 1173:             output_object = 'NaT'
 1174:         else:
 1175:             output_object = na_object
 1176: 
 1177:         for arr in [dt_array, td_array]:
 1178:             assert_array_equal(
 1179:                 arr.astype(dtype),
 1180:                 np.array([output_object] * arr.size, dtype=dtype))
 1181: 
 1182: 
 1183: def test_nat_conversion():
 1184:     for nat in [np.datetime64("NaT", "s"), np.timedelta64("NaT", "s")]:
 1185:         with pytest.raises(ValueError, match="string coercion is disabled"):
 1186:             np.array(["a", nat], dtype=StringDType(coerce=False))
 1187: 
 1188: 
 1189: def test_growing_strings(dtype):
 1190:     # growing a string leads to a heap allocation, this tests to make sure
 1191:     # we do that bookkeeping correctly for all possible starting cases
 1192:     data = [
 1193:         "hello",  # a short string
 1194:         "abcdefghijklmnopqestuvwxyz",  # a medium heap-allocated string
 1195:         "hello" * 200,  # a long heap-allocated string
 1196:     ]
 1197: 
 1198:     arr = np.array(data, dtype=dtype)
 1199:     uarr = np.array(data, dtype=str)
 1200: 
 1201:     for _ in range(5):
 1202:         arr = arr + arr
 1203:         uarr = uarr + uarr
 1204: 
 1205:     assert_array_equal(arr, uarr)
 1206: 
 1207: 
 1208: def test_assign_medium_strings():
 1209:     # see gh-29261
 1210:     N = 9
 1211:     src = np.array(
 1212:         (
 1213:             ['0' * 256] * 3 + ['0' * 255] + ['0' * 256] + ['0' * 255] +
 1214:             ['0' * 256] * 2 + ['0' * 255]
 1215:         ), dtype='T')
 1216:     dst = np.array(
 1217:         (
 1218:             ['0' * 255] + ['0' * 256] * 2 + ['0' * 255] + ['0' * 256] +
 1219:             ['0' * 255] + [''] * 5
 1220:         ), dtype='T')
 1221: 
 1222:     dst[1:N + 1] = src
 1223:     assert_array_equal(dst[1:N + 1], src)
 1224: 
 1225: 
 1226: UFUNC_TEST_DATA = [
 1227:     "hello" * 10,
 1228:     "AeВўвѓв‚¬ рџЉ" * 20,
 1229:     "entry\nwith\nnewlines",
 1230:     "entry\twith\ttabs",
 1231: ]
 1232: 
 1233: 
 1234: @pytest.fixture
 1235: def string_array(dtype):
 1236:     return np.array(UFUNC_TEST_DATA, dtype=dtype)
 1237: 
 1238: 
 1239: @pytest.fixture
 1240: def unicode_array():
 1241:     return np.array(UFUNC_TEST_DATA, dtype=np.str_)
 1242: 
 1243: 
 1244: NAN_PRESERVING_FUNCTIONS = [
 1245:     "capitalize",
 1246:     "expandtabs",
 1247:     "lower",
 1248:     "lstrip",
 1249:     "rstrip",
 1250:     "splitlines",
 1251:     "strip",
 1252:     "swapcase",
 1253:     "title",
 1254:     "upper",
 1255: ]
 1256: 
 1257: BOOL_OUTPUT_FUNCTIONS = [
 1258:     "isalnum",
 1259:     "isalpha",
 1260:     "isdigit",
 1261:     "islower",
 1262:     "isspace",
 1263:     "istitle",
 1264:     "isupper",
 1265:     "isnumeric",
 1266:     "isdecimal",
 1267: ]
 1268: 
 1269: UNARY_FUNCTIONS = [
 1270:     "str_len",
 1271:     "capitalize",
 1272:     "expandtabs",
 1273:     "isalnum",
 1274:     "isalpha",
 1275:     "isdigit",
 1276:     "islower",
 1277:     "isspace",
 1278:     "istitle",
 1279:     "isupper",
 1280:     "lower",
 1281:     "lstrip",
 1282:     "rstrip",
 1283:     "splitlines",
 1284:     "strip",
 1285:     "swapcase",
 1286:     "title",
 1287:     "upper",
 1288:     "isnumeric",
 1289:     "isdecimal",
 1290:     "isalnum",
 1291:     "islower",
 1292:     "istitle",
 1293:     "isupper",
 1294: ]
 1295: 
 1296: UNIMPLEMENTED_VEC_STRING_FUNCTIONS = [
 1297:     "capitalize",
 1298:     "expandtabs",
 1299:     "lower",
 1300:     "splitlines",
 1301:     "swapcase",
 1302:     "title",
 1303:     "upper",
 1304: ]
 1305: 
 1306: ONLY_IN_NP_CHAR = [
 1307:     "join",
 1308:     "split",
 1309:     "rsplit",
 1310:     "splitlines"
 1311: ]
 1312: 
 1313: 
 1314: @pytest.mark.parametrize("function_name", UNARY_FUNCTIONS)
 1315: def test_unary(string_array, unicode_array, function_name):
 1316:     if function_name in ONLY_IN_NP_CHAR:
 1317:         func = getattr(np.char, function_name)
 1318:     else:
 1319:         func = getattr(np.strings, function_name)
 1320:     dtype = string_array.dtype
 1321:     sres = func(string_array)
 1322:     ures = func(unicode_array)
 1323:     if sres.dtype == StringDType():
 1324:         ures = ures.astype(StringDType())
 1325:     assert_array_equal(sres, ures)
 1326: 
 1327:     if not hasattr(dtype, "na_object"):
 1328:         return
 1329: 
 1330:     is_nan = np.isnan(np.array([dtype.na_object], dtype=dtype))[0]
 1331:     is_str = isinstance(dtype.na_object, str)
 1332:     na_arr = np.insert(string_array, 0, dtype.na_object)
 1333: 
 1334:     if function_name in UNIMPLEMENTED_VEC_STRING_FUNCTIONS:
 1335:         if not is_str:
 1336:             # to avoid these errors we'd need to add NA support to _vec_string
 1337:             with pytest.raises((ValueError, TypeError)):
 1338:                 func(na_arr)
 1339:         elif function_name == "splitlines":
 1340:             assert func(na_arr)[0] == func(dtype.na_object)[()]
 1341:         else:
 1342:             assert func(na_arr)[0] == func(dtype.na_object)
 1343:         return
 1344:     if function_name == "str_len" and not is_str:
 1345:         # str_len always errors for any non-string null, even NA ones because
 1346:         # it has an integer result
 1347:         with pytest.raises(ValueError):
 1348:             func(na_arr)
 1349:         return
 1350:     if function_name in BOOL_OUTPUT_FUNCTIONS:
 1351:         if is_nan:
 1352:             assert func(na_arr)[0] is np.False_
 1353:         elif is_str:
 1354:             assert func(na_arr)[0] == func(dtype.na_object)
 1355:         else:
 1356:             with pytest.raises(ValueError):
 1357:                 func(na_arr)
 1358:         return
 1359:     if not (is_nan or is_str):
 1360:         with pytest.raises(ValueError):
 1361:             func(na_arr)
 1362:         return
 1363:     res = func(na_arr)
 1364:     if is_nan and function_name in NAN_PRESERVING_FUNCTIONS:
 1365:         assert res[0] is dtype.na_object
 1366:     elif is_str:
 1367:         assert res[0] == func(dtype.na_object)
 1368: 
 1369: 
 1370: unicode_bug_fail = pytest.mark.xfail(
 1371:     reason="unicode output width is buggy", strict=True
 1372: )
 1373: 
 1374: # None means that the argument is a string array
 1375: BINARY_FUNCTIONS = [
 1376:     ("add", (None, None)),
 1377:     ("multiply", (None, 2)),
 1378:     ("mod", ("format: %s", None)),
 1379:     ("center", (None, 25)),
 1380:     ("count", (None, "A")),
 1381:     ("encode", (None, "UTF-8")),
 1382:     ("endswith", (None, "lo")),
 1383:     ("find", (None, "A")),
 1384:     ("index", (None, "e")),
 1385:     ("join", ("-", None)),
 1386:     ("ljust", (None, 12)),
 1387:     ("lstrip", (None, "A")),
 1388:     ("partition", (None, "A")),
 1389:     ("replace", (None, "A", "B")),
 1390:     ("rfind", (None, "A")),
 1391:     ("rindex", (None, "e")),
 1392:     ("rjust", (None, 12)),
 1393:     ("rsplit", (None, "A")),
 1394:     ("rstrip", (None, "A")),
 1395:     ("rpartition", (None, "A")),
 1396:     ("split", (None, "A")),
 1397:     ("strip", (None, "A")),
 1398:     ("startswith", (None, "A")),
 1399:     ("zfill", (None, 12)),
 1400: ]
 1401: 
 1402: PASSES_THROUGH_NAN_NULLS = [
 1403:     "add",
 1404:     "center",
 1405:     "ljust",
 1406:     "multiply",
 1407:     "replace",
 1408:     "rjust",
 1409:     "strip",
 1410:     "lstrip",
 1411:     "rstrip",
 1412:     "replace"
 1413:     "zfill",
 1414: ]
 1415: 
 1416: NULLS_ARE_FALSEY = [
 1417:     "startswith",
 1418:     "endswith",
 1419: ]
 1420: 
 1421: NULLS_ALWAYS_ERROR = [
 1422:     "count",
 1423:     "find",
 1424:     "rfind",
 1425: ]
 1426: 
 1427: SUPPORTS_NULLS = (
 1428:     PASSES_THROUGH_NAN_NULLS +
 1429:     NULLS_ARE_FALSEY +
 1430:     NULLS_ALWAYS_ERROR
 1431: )
 1432: 
 1433: 
 1434: def call_func(func, args, array, sanitize=True):
 1435:     if args == (None, None):
 1436:         return func(array, array)
 1437:     if args[0] is None:
 1438:         if sanitize:
 1439:             san_args = tuple(
 1440:                 np.array(arg, dtype=array.dtype) if isinstance(arg, str) else
 1441:                 arg for arg in args[1:]
 1442:             )
 1443:         else:
 1444:             san_args = args[1:]
 1445:         return func(array, *san_args)
 1446:     if args[1] is None:
 1447:         return func(args[0], array)
 1448:     # shouldn't ever happen
 1449:     assert 0
 1450: 
 1451: 
 1452: @pytest.mark.parametrize("function_name, args", BINARY_FUNCTIONS)
 1453: def test_binary(string_array, unicode_array, function_name, args):
 1454:     if function_name in ONLY_IN_NP_CHAR:
 1455:         func = getattr(np.char, function_name)
 1456:     else:
 1457:         func = getattr(np.strings, function_name)
 1458:     sres = call_func(func, args, string_array)
 1459:     ures = call_func(func, args, unicode_array, sanitize=False)
 1460:     if not isinstance(sres, tuple) and sres.dtype == StringDType():
 1461:         ures = ures.astype(StringDType())
 1462:     assert_array_equal(sres, ures)
 1463: 
 1464:     dtype = string_array.dtype
 1465:     if function_name not in SUPPORTS_NULLS or not hasattr(dtype, "na_object"):
 1466:         return
 1467: 
 1468:     na_arr = np.insert(string_array, 0, dtype.na_object)
 1469:     is_nan = np.isnan(np.array([dtype.na_object], dtype=dtype))[0]
 1470:     is_str = isinstance(dtype.na_object, str)
 1471:     should_error = not (is_nan or is_str)
 1472: 
 1473:     if (
 1474:         (function_name in NULLS_ALWAYS_ERROR and not is_str)
 1475:         or (function_name in PASSES_THROUGH_NAN_NULLS and should_error)
 1476:         or (function_name in NULLS_ARE_FALSEY and should_error)
 1477:     ):
 1478:         with pytest.raises((ValueError, TypeError)):
 1479:             call_func(func, args, na_arr)
 1480:         return
 1481: 
 1482:     res = call_func(func, args, na_arr)
 1483: 
 1484:     if is_str:
 1485:         assert res[0] == call_func(func, args, na_arr[:1])
 1486:     elif function_name in NULLS_ARE_FALSEY:
 1487:         assert res[0] is np.False_
 1488:     elif function_name in PASSES_THROUGH_NAN_NULLS:
 1489:         assert res[0] is dtype.na_object
 1490:     else:
 1491:         # shouldn't ever get here
 1492:         assert 0
 1493: 
 1494: 
 1495: @pytest.mark.parametrize("function, expected", [
 1496:     (np.strings.find, [[2, -1], [1, -1]]),
 1497:     (np.strings.startswith, [[False, False], [True, False]])])
 1498: @pytest.mark.parametrize("start, stop", [
 1499:     (1, 4),
 1500:     (np.int8(1), np.int8(4)),
 1501:     (np.array([1, 1], dtype='u2'), np.array([4, 4], dtype='u2'))])
 1502: def test_non_default_start_stop(function, start, stop, expected):
 1503:     a = np.array([["--рџђЌ--", "--рџ¦њ--"],
 1504:                   ["-рџђЌ---", "-рџ¦њ---"]], "T")
 1505:     indx = function(a, "рџђЌ", start, stop)
 1506:     assert_array_equal(indx, expected)
 1507: 
 1508: 
 1509: @pytest.mark.parametrize("count", [2, np.int8(2), np.array([2, 2], 'u2')])
 1510: def test_replace_non_default_repeat(count):
 1511:     a = np.array(["рџђЌ--", "рџ¦њ-рџ¦њ-"], "T")
 1512:     result = np.strings.replace(a, "рџ¦њ-", "рџ¦њвЂ ", count)
 1513:     assert_array_equal(result, np.array(["рџђЌ--", "рџ¦њвЂ рџ¦њвЂ "], "T"))
 1514: 
 1515: 
 1516: def test_strip_ljust_rjust_consistency(string_array, unicode_array):
 1517:     rjs = np.char.rjust(string_array, 1000)
 1518:     rju = np.char.rjust(unicode_array, 1000)
 1519: 
 1520:     ljs = np.char.ljust(string_array, 1000)
 1521:     lju = np.char.ljust(unicode_array, 1000)
 1522: 
 1523:     assert_array_equal(
 1524:         np.char.lstrip(rjs),
 1525:         np.char.lstrip(rju).astype(StringDType()),
 1526:     )
 1527: 
 1528:     assert_array_equal(
 1529:         np.char.rstrip(ljs),
 1530:         np.char.rstrip(lju).astype(StringDType()),
 1531:     )
 1532: 
 1533:     assert_array_equal(
 1534:         np.char.strip(ljs),
 1535:         np.char.strip(lju).astype(StringDType()),
 1536:     )
 1537: 
 1538:     assert_array_equal(
 1539:         np.char.strip(rjs),
 1540:         np.char.strip(rju).astype(StringDType()),
 1541:     )
 1542: 
 1543: 
 1544: def test_unset_na_coercion():
 1545:     # a dtype instance with an unset na object is compatible
 1546:     # with a dtype that has one set
 1547: 
 1548:     # this test uses the "add" and "equal" ufunc but all ufuncs that
 1549:     # accept more than one string argument and produce a string should
 1550:     # behave this way
 1551:     # TODO: generalize to more ufuncs
 1552:     inp = ["hello", "world"]
 1553:     arr = np.array(inp, dtype=StringDType(na_object=None))
 1554:     for op_dtype in [None, StringDType(), StringDType(coerce=False),
 1555:                      StringDType(na_object=None)]:
 1556:         if op_dtype is None:
 1557:             op = "2"
 1558:         else:
 1559:             op = np.array("2", dtype=op_dtype)
 1560:         res = arr + op
 1561:         assert_array_equal(res, ["hello2", "world2"])
 1562: 
 1563:     # dtype instances with distinct explicitly set NA objects are incompatible
 1564:     for op_dtype in [StringDType(na_object=pd_NA), StringDType(na_object="")]:
 1565:         op = np.array("2", dtype=op_dtype)
 1566:         with pytest.raises(TypeError):
 1567:             arr + op
 1568: 
 1569:     # comparisons only consider the na_object
 1570:     for op_dtype in [None, StringDType(), StringDType(coerce=True),
 1571:                      StringDType(na_object=None)]:
 1572:         if op_dtype is None:
 1573:             op = inp
 1574:         else:
 1575:             op = np.array(inp, dtype=op_dtype)
 1576:         assert_array_equal(arr, op)
 1577: 
 1578:     for op_dtype in [StringDType(na_object=pd_NA),
 1579:                      StringDType(na_object=np.nan)]:
 1580:         op = np.array(inp, dtype=op_dtype)
 1581:         with pytest.raises(TypeError):
 1582:             arr == op
 1583: 
 1584: 
 1585: def test_repeat(string_array):
 1586:     res = string_array.repeat(1000)
 1587:     # Create an empty array with expanded dimension, and fill it.  Then,
 1588:     # reshape it to the expected result.
 1589:     expected = np.empty_like(string_array, shape=string_array.shape + (1000,))
 1590:     expected[...] = string_array[:, np.newaxis]
 1591:     expected = expected.reshape(-1)
 1592: 
 1593:     assert_array_equal(res, expected, strict=True)
 1594: 
 1595: 
 1596: @pytest.mark.parametrize("tile", [1, 6, (2, 5)])
 1597: def test_accumulation(string_array, tile):
 1598:     """Accumulation is odd for StringDType but tests dtypes with references.
 1599:     """
 1600:     # Fill with mostly empty strings to not create absurdly big strings
 1601:     arr = np.zeros_like(string_array, shape=(100,))
 1602:     arr[:len(string_array)] = string_array
 1603:     arr[-len(string_array):] = string_array
 1604: 
 1605:     # Bloat size a bit (get above thresholds and test >1 ndim).
 1606:     arr = np.tile(string_array, tile)
 1607: 
 1608:     res = np.add.accumulate(arr, axis=0)
 1609:     res_obj = np.add.accumulate(arr.astype(object), axis=0)
 1610:     assert_array_equal(res, res_obj.astype(arr.dtype), strict=True)
 1611: 
 1612:     if arr.ndim > 1:
 1613:         res = np.add.accumulate(arr, axis=-1)
 1614:         res_obj = np.add.accumulate(arr.astype(object), axis=-1)
 1615: 
 1616:         assert_array_equal(res, res_obj.astype(arr.dtype), strict=True)
 1617: 
 1618: 
 1619: class TestImplementation:
 1620:     """Check that strings are stored in the arena when possible.
 1621: 
 1622:     This tests implementation details, so should be adjusted if
 1623:     the implementation changes.
 1624:     """
 1625: 
 1626:     @classmethod
 1627:     def setup_class(self):
 1628:         self.MISSING = 0x80
 1629:         self.INITIALIZED = 0x40
 1630:         self.OUTSIDE_ARENA = 0x20
 1631:         self.LONG = 0x10
 1632:         self.dtype = StringDType(na_object=np.nan)
 1633:         self.sizeofstr = self.dtype.itemsize
 1634:         sp = self.dtype.itemsize // 2  # pointer size = sizeof(size_t)
 1635:         # Below, size is not strictly correct, since it really uses
 1636:         # 7 (or 3) bytes, but good enough for the tests here.
 1637:         self.view_dtype = np.dtype([
 1638:             ('offset', f'u{sp}'),
 1639:             ('size', f'u{sp // 2}'),
 1640:             ('xsiz', f'V{sp // 2 - 1}'),
 1641:             ('size_and_flags', 'u1'),
 1642:         ] if sys.byteorder == 'little' else [
 1643:             ('size_and_flags', 'u1'),
 1644:             ('xsiz', f'V{sp // 2 - 1}'),
 1645:             ('size', f'u{sp // 2}'),
 1646:             ('offset', f'u{sp}'),
 1647:         ])
 1648:         self.s_empty = ""
 1649:         self.s_short = "01234"
 1650:         self.s_medium = "abcdefghijklmnopqrstuvwxyz"
 1651:         self.s_long = "-=+" * 100
 1652:         self.a = np.array(
 1653:             [self.s_empty, self.s_short, self.s_medium, self.s_long],
 1654:             self.dtype)
 1655: 
 1656:     def get_view(self, a):
 1657:         # Cannot view a StringDType as anything else directly, since
 1658:         # it has references. So, we use a stride trick hack.
 1659:         from numpy.lib._stride_tricks_impl import DummyArray
 1660:         interface = dict(a.__array_interface__)
 1661:         interface['descr'] = self.view_dtype.descr
 1662:         interface['typestr'] = self.view_dtype.str
 1663:         return np.asarray(DummyArray(interface, base=a))
 1664: 
 1665:     def get_flags(self, a):
 1666:         return self.get_view(a)['size_and_flags'] & 0xf0
 1667: 
 1668:     def is_short(self, a):
 1669:         return self.get_flags(a) == self.INITIALIZED | self.OUTSIDE_ARENA
 1670: 
 1671:     def is_on_heap(self, a):
 1672:         return self.get_flags(a) == (self.INITIALIZED
 1673:                                      | self.OUTSIDE_ARENA
 1674:                                      | self.LONG)
 1675: 
 1676:     def is_missing(self, a):
 1677:         return self.get_flags(a) & self.MISSING == self.MISSING
 1678: 
 1679:     def in_arena(self, a):
 1680:         return (self.get_flags(a) & (self.INITIALIZED | self.OUTSIDE_ARENA)
 1681:                 == self.INITIALIZED)
 1682: 
 1683:     def test_setup(self):
 1684:         is_short = self.is_short(self.a)
 1685:         length = np.strings.str_len(self.a)
 1686:         assert_array_equal(is_short, (length > 0) & (length <= 15))
 1687:         assert_array_equal(self.in_arena(self.a), [False, False, True, True])
 1688:         assert_array_equal(self.is_on_heap(self.a), False)
 1689:         assert_array_equal(self.is_missing(self.a), False)
 1690:         view = self.get_view(self.a)
 1691:         sizes = np.where(is_short, view['size_and_flags'] & 0xf,
 1692:                          view['size'])
 1693:         assert_array_equal(sizes, np.strings.str_len(self.a))
 1694:         assert_array_equal(view['xsiz'][2:],
 1695:                            np.void(b'\x00' * (self.sizeofstr // 4 - 1)))
 1696:         # Check that the medium string uses only 1 byte for its length
 1697:         # in the arena, while the long string takes 8 (or 4).
 1698:         offsets = view['offset']
 1699:         assert offsets[2] == 1
 1700:         assert offsets[3] == 1 + len(self.s_medium) + self.sizeofstr // 2
 1701: 
 1702:     def test_empty(self):
 1703:         e = np.empty((3,), self.dtype)
 1704:         assert_array_equal(self.get_flags(e), 0)
 1705:         assert_array_equal(e, "")
 1706: 
 1707:     def test_zeros(self):
 1708:         z = np.zeros((2,), self.dtype)
 1709:         assert_array_equal(self.get_flags(z), 0)
 1710:         assert_array_equal(z, "")
 1711: 
 1712:     def test_copy(self):
 1713:         for c in [self.a.copy(), copy.copy(self.a), copy.deepcopy(self.a)]:
 1714:             assert_array_equal(self.get_flags(c), self.get_flags(self.a))
 1715:             assert_array_equal(c, self.a)
 1716:             offsets = self.get_view(c)['offset']
 1717:             assert offsets[2] == 1
 1718:             assert offsets[3] == 1 + len(self.s_medium) + self.sizeofstr // 2
 1719: 
 1720:     def test_arena_use_with_setting(self):
 1721:         c = np.zeros_like(self.a)
 1722:         assert_array_equal(self.get_flags(c), 0)
 1723:         c[:] = self.a
 1724:         assert_array_equal(self.get_flags(c), self.get_flags(self.a))
 1725:         assert_array_equal(c, self.a)
 1726: 
 1727:     def test_arena_reuse_with_setting(self):
 1728:         c = self.a.copy()
 1729:         c[:] = self.a
 1730:         assert_array_equal(self.get_flags(c), self.get_flags(self.a))
 1731:         assert_array_equal(c, self.a)
 1732: 
 1733:     def test_arena_reuse_after_missing(self):
 1734:         c = self.a.copy()
 1735:         c[:] = np.nan
 1736:         assert np.all(self.is_missing(c))
 1737:         # Replacing with the original strings, the arena should be reused.
 1738:         c[:] = self.a
 1739:         assert_array_equal(self.get_flags(c), self.get_flags(self.a))
 1740:         assert_array_equal(c, self.a)
 1741: 
 1742:     def test_arena_reuse_after_empty(self):
 1743:         c = self.a.copy()
 1744:         c[:] = ""
 1745:         assert_array_equal(c, "")
 1746:         # Replacing with the original strings, the arena should be reused.
 1747:         c[:] = self.a
 1748:         assert_array_equal(self.get_flags(c), self.get_flags(self.a))
 1749:         assert_array_equal(c, self.a)
 1750: 
 1751:     def test_arena_reuse_for_shorter(self):
 1752:         c = self.a.copy()
 1753:         # A string slightly shorter than the shortest in the arena
 1754:         # should be used for all strings in the arena.
 1755:         c[:] = self.s_medium[:-1]
 1756:         assert_array_equal(c, self.s_medium[:-1])
 1757:         # first empty string in original was never initialized, so
 1758:         # filling it in now leaves it initialized inside the arena.
 1759:         # second string started as a short string so it can never live
 1760:         # in the arena.
 1761:         in_arena = np.array([True, False, True, True])
 1762:         assert_array_equal(self.in_arena(c), in_arena)
 1763:         # But when a short string is replaced, it will go on the heap.
 1764:         assert_array_equal(self.is_short(c), False)
 1765:         assert_array_equal(self.is_on_heap(c), ~in_arena)
 1766:         # We can put the originals back, and they'll still fit,
 1767:         # and short strings are back as short strings
 1768:         c[:] = self.a
 1769:         assert_array_equal(c, self.a)
 1770:         assert_array_equal(self.in_arena(c), in_arena)
 1771:         assert_array_equal(self.is_short(c), self.is_short(self.a))
 1772:         assert_array_equal(self.is_on_heap(c), False)
 1773: 
 1774:     def test_arena_reuse_if_possible(self):
 1775:         c = self.a.copy()
 1776:         # A slightly longer string will not fit in the arena for
 1777:         # the medium string, but will fit for the longer one.
 1778:         c[:] = self.s_medium + "В±"
 1779:         assert_array_equal(c, self.s_medium + "В±")
 1780:         in_arena_exp = np.strings.str_len(self.a) >= len(self.s_medium) + 1
 1781:         # first entry started uninitialized and empty, so filling it leaves
 1782:         # it in the arena
 1783:         in_arena_exp[0] = True
 1784:         assert not np.all(in_arena_exp == self.in_arena(self.a))
 1785:         assert_array_equal(self.in_arena(c), in_arena_exp)
 1786:         assert_array_equal(self.is_short(c), False)
 1787:         assert_array_equal(self.is_on_heap(c), ~in_arena_exp)
 1788:         # And once outside arena, it stays outside, since offset is lost.
 1789:         # But short strings are used again.
 1790:         c[:] = self.a
 1791:         is_short_exp = self.is_short(self.a)
 1792:         assert_array_equal(c, self.a)
 1793:         assert_array_equal(self.in_arena(c), in_arena_exp)
 1794:         assert_array_equal(self.is_short(c), is_short_exp)
 1795:         assert_array_equal(self.is_on_heap(c), ~in_arena_exp & ~is_short_exp)
 1796: 
 1797:     def test_arena_no_reuse_after_short(self):
 1798:         c = self.a.copy()
 1799:         # If we replace a string with a short string, it cannot
 1800:         # go into the arena after because the offset is lost.
 1801:         c[:] = self.s_short
 1802:         assert_array_equal(c, self.s_short)
 1803:         assert_array_equal(self.in_arena(c), False)
 1804:         c[:] = self.a
 1805:         assert_array_equal(c, self.a)
 1806:         assert_array_equal(self.in_arena(c), False)
 1807:         assert_array_equal(self.is_on_heap(c), self.in_arena(self.a))
