    1: import platform
    2: import sys
    3: 
    4: # import the c-extension module directly since _arg is not exported via umath
    5: import numpy._core._multiarray_umath as ncu
    6: import pytest
    7: 
    8: import numpy as np
    9: from numpy.testing import (
   10:     assert_almost_equal,
   11:     assert_array_equal,
   12:     assert_array_max_ulp,
   13:     assert_equal,
   14:     assert_raises,
   15: )
   16: 
   17: # TODO: branch cuts (use Pauli code)
   18: # TODO: conj 'symmetry'
   19: # TODO: FPU exceptions
   20: 
   21: # At least on Windows the results of many complex functions are not conforming
   22: # to the C99 standard. See ticket 1574.
   23: # Ditto for Solaris (ticket 1642) and OS X on PowerPC.
   24: # FIXME: this will probably change when we require full C99 compatibility
   25: with np.errstate(all='ignore'):
   26:     functions_seem_flaky = ((np.exp(complex(np.inf, 0)).imag != 0)
   27:                             or (np.log(complex(ncu.NZERO, 0)).imag != np.pi))
   28: # TODO: replace with a check on whether platform-provided C99 funcs are used
   29: xfail_complex_tests = (not sys.platform.startswith('linux') or functions_seem_flaky)
   30: 
   31: # TODO This can be xfail when the generator functions are got rid of.
   32: platform_skip = pytest.mark.skipif(xfail_complex_tests,
   33:                                    reason="Inadequate C99 complex support")
   34: 
   35: 
   36: class TestCexp:
   37:     def test_simple(self):
   38:         check = check_complex_value
   39:         f = np.exp
   40: 
   41:         check(f, 1, 0, np.exp(1), 0, False)
   42:         check(f, 0, 1, np.cos(1), np.sin(1), False)
   43: 
   44:         ref = np.exp(1) * complex(np.cos(1), np.sin(1))
   45:         check(f, 1, 1, ref.real, ref.imag, False)
   46: 
   47:     @platform_skip
   48:     def test_special_values(self):
   49:         # C99: Section G 6.3.1
   50: 
   51:         check = check_complex_value
   52:         f = np.exp
   53: 
   54:         # cexp(+-0 + 0i) is 1 + 0i
   55:         check(f, ncu.PZERO, 0, 1, 0, False)
   56:         check(f, ncu.NZERO, 0, 1, 0, False)
   57: 
   58:         # cexp(x + infi) is nan + nani for finite x and raises 'invalid' FPU
   59:         # exception
   60:         check(f,  1, np.inf, np.nan, np.nan)
   61:         check(f, -1, np.inf, np.nan, np.nan)
   62:         check(f,  0, np.inf, np.nan, np.nan)
   63: 
   64:         # cexp(inf + 0i) is inf + 0i
   65:         check(f,  np.inf, 0, np.inf, 0)
   66: 
   67:         # cexp(-inf + yi) is +0 * (cos(y) + i sin(y)) for finite y
   68:         check(f, -np.inf, 1, ncu.PZERO, ncu.PZERO)
   69:         check(f, -np.inf, 0.75 * np.pi, ncu.NZERO, ncu.PZERO)
   70: 
   71:         # cexp(inf + yi) is +inf * (cos(y) + i sin(y)) for finite y
   72:         check(f,  np.inf, 1, np.inf, np.inf)
   73:         check(f,  np.inf, 0.75 * np.pi, -np.inf, np.inf)
   74: 
   75:         # cexp(-inf + inf i) is +-0 +- 0i (signs unspecified)
   76:         def _check_ninf_inf(dummy):
   77:             msgform = "cexp(-inf, inf) is (%f, %f), expected (+-0, +-0)"
   78:             with np.errstate(invalid='ignore'):
   79:                 z = f(np.array(complex(-np.inf, np.inf)))
   80:                 if z.real != 0 or z.imag != 0:
   81:                     raise AssertionError(msgform % (z.real, z.imag))
   82: 
   83:         _check_ninf_inf(None)
   84: 
   85:         # cexp(inf + inf i) is +-inf + NaNi and raised invalid FPU ex.
   86:         def _check_inf_inf(dummy):
   87:             msgform = "cexp(inf, inf) is (%f, %f), expected (+-inf, nan)"
   88:             with np.errstate(invalid='ignore'):
   89:                 z = f(np.array(complex(np.inf, np.inf)))
   90:                 if not np.isinf(z.real) or not np.isnan(z.imag):
   91:                     raise AssertionError(msgform % (z.real, z.imag))
   92: 
   93:         _check_inf_inf(None)
   94: 
   95:         # cexp(-inf + nan i) is +-0 +- 0i
   96:         def _check_ninf_nan(dummy):
   97:             msgform = "cexp(-inf, nan) is (%f, %f), expected (+-0, +-0)"
   98:             with np.errstate(invalid='ignore'):
   99:                 z = f(np.array(complex(-np.inf, np.nan)))
  100:                 if z.real != 0 or z.imag != 0:
  101:                     raise AssertionError(msgform % (z.real, z.imag))
  102: 
  103:         _check_ninf_nan(None)
  104: 
  105:         # cexp(inf + nan i) is +-inf + nan
  106:         def _check_inf_nan(dummy):
  107:             msgform = "cexp(-inf, nan) is (%f, %f), expected (+-inf, nan)"
  108:             with np.errstate(invalid='ignore'):
  109:                 z = f(np.array(complex(np.inf, np.nan)))
  110:                 if not np.isinf(z.real) or not np.isnan(z.imag):
  111:                     raise AssertionError(msgform % (z.real, z.imag))
  112: 
  113:         _check_inf_nan(None)
  114: 
  115:         # cexp(nan + yi) is nan + nani for y != 0 (optional: raises invalid FPU
  116:         # ex)
  117:         check(f, np.nan, 1, np.nan, np.nan)
  118:         check(f, np.nan, -1, np.nan, np.nan)
  119: 
  120:         check(f, np.nan,  np.inf, np.nan, np.nan)
  121:         check(f, np.nan, -np.inf, np.nan, np.nan)
  122: 
  123:         # cexp(nan + nani) is nan + nani
  124:         check(f, np.nan, np.nan, np.nan, np.nan)
  125: 
  126:     # TODO This can be xfail when the generator functions are got rid of.
  127:     @pytest.mark.skip(reason="cexp(nan + 0I) is wrong on most platforms")
  128:     def test_special_values2(self):
  129:         # XXX: most implementations get it wrong here (including glibc <= 2.10)
  130:         # cexp(nan + 0i) is nan + 0i
  131:         check = check_complex_value
  132:         f = np.exp
  133: 
  134:         check(f, np.nan, 0, np.nan, 0)
  135: 
  136: class TestClog:
  137:     def test_simple(self):
  138:         x = np.array([1 + 0j, 1 + 2j])
  139:         y_r = np.log(np.abs(x)) + 1j * np.angle(x)
  140:         y = np.log(x)
  141:         assert_almost_equal(y, y_r)
  142: 
  143:     @platform_skip
  144:     @pytest.mark.skipif(platform.machine() == "armv5tel", reason="See gh-413.")
  145:     def test_special_values(self):
  146:         xl = []
  147:         yl = []
  148: 
  149:         # From C99 std (Sec 6.3.2)
  150:         # XXX: check exceptions raised
  151:         # --- raise for invalid fails.
  152: 
  153:         # clog(-0 + i0) returns -inf + i pi and raises the 'divide-by-zero'
  154:         # floating-point exception.
  155:         with np.errstate(divide='raise'):
  156:             x = np.array([ncu.NZERO], dtype=complex)
  157:             y = complex(-np.inf, np.pi)
  158:             assert_raises(FloatingPointError, np.log, x)
  159:         with np.errstate(divide='ignore'):
  160:             assert_almost_equal(np.log(x), y)
  161: 
  162:         xl.append(x)
  163:         yl.append(y)
  164: 
  165:         # clog(+0 + i0) returns -inf + i0 and raises the 'divide-by-zero'
  166:         # floating-point exception.
  167:         with np.errstate(divide='raise'):
  168:             x = np.array([0], dtype=complex)
  169:             y = complex(-np.inf, 0)
  170:             assert_raises(FloatingPointError, np.log, x)
  171:         with np.errstate(divide='ignore'):
  172:             assert_almost_equal(np.log(x), y)
  173: 
  174:         xl.append(x)
  175:         yl.append(y)
  176: 
  177:         # clog(x + i inf returns +inf + i pi /2, for finite x.
  178:         x = np.array([complex(1, np.inf)], dtype=complex)
  179:         y = complex(np.inf, 0.5 * np.pi)
  180:         assert_almost_equal(np.log(x), y)
  181:         xl.append(x)
  182:         yl.append(y)
  183: 
  184:         x = np.array([complex(-1, np.inf)], dtype=complex)
  185:         assert_almost_equal(np.log(x), y)
  186:         xl.append(x)
  187:         yl.append(y)
  188: 
  189:         # clog(x + iNaN) returns NaN + iNaN and optionally raises the
  190:         # 'invalid' floating- point exception, for finite x.
  191:         with np.errstate(invalid='raise'):
  192:             x = np.array([complex(1., np.nan)], dtype=complex)
  193:             y = complex(np.nan, np.nan)
  194:             #assert_raises(FloatingPointError, np.log, x)
  195:         with np.errstate(invalid='ignore'):
  196:             assert_almost_equal(np.log(x), y)
  197: 
  198:         xl.append(x)
  199:         yl.append(y)
  200: 
  201:         with np.errstate(invalid='raise'):
  202:             x = np.array([np.inf + 1j * np.nan], dtype=complex)
  203:             #assert_raises(FloatingPointError, np.log, x)
  204:         with np.errstate(invalid='ignore'):
  205:             assert_almost_equal(np.log(x), y)
  206: 
  207:         xl.append(x)
  208:         yl.append(y)
  209: 
  210:         # clog(- inf + iy) returns +inf + ipi , for finite positive-signed y.
  211:         x = np.array([-np.inf + 1j], dtype=complex)
  212:         y = complex(np.inf, np.pi)
  213:         assert_almost_equal(np.log(x), y)
  214:         xl.append(x)
  215:         yl.append(y)
  216: 
  217:         # clog(+ inf + iy) returns +inf + i0, for finite positive-signed y.
  218:         x = np.array([np.inf + 1j], dtype=complex)
  219:         y = complex(np.inf, 0)
  220:         assert_almost_equal(np.log(x), y)
  221:         xl.append(x)
  222:         yl.append(y)
  223: 
  224:         # clog(- inf + i inf) returns +inf + i3pi /4.
  225:         x = np.array([complex(-np.inf, np.inf)], dtype=complex)
  226:         y = complex(np.inf, 0.75 * np.pi)
  227:         assert_almost_equal(np.log(x), y)
  228:         xl.append(x)
  229:         yl.append(y)
  230: 
  231:         # clog(+ inf + i inf) returns +inf + ipi /4.
  232:         x = np.array([complex(np.inf, np.inf)], dtype=complex)
  233:         y = complex(np.inf, 0.25 * np.pi)
  234:         assert_almost_equal(np.log(x), y)
  235:         xl.append(x)
  236:         yl.append(y)
  237: 
  238:         # clog(+/- inf + iNaN) returns +inf + iNaN.
  239:         x = np.array([complex(np.inf, np.nan)], dtype=complex)
  240:         y = complex(np.inf, np.nan)
  241:         assert_almost_equal(np.log(x), y)
  242:         xl.append(x)
  243:         yl.append(y)
  244: 
  245:         x = np.array([complex(-np.inf, np.nan)], dtype=complex)
  246:         assert_almost_equal(np.log(x), y)
  247:         xl.append(x)
  248:         yl.append(y)
  249: 
  250:         # clog(NaN + iy) returns NaN + iNaN and optionally raises the
  251:         # 'invalid' floating-point exception, for finite y.
  252:         x = np.array([complex(np.nan, 1)], dtype=complex)
  253:         y = complex(np.nan, np.nan)
  254:         assert_almost_equal(np.log(x), y)
  255:         xl.append(x)
  256:         yl.append(y)
  257: 
  258:         # clog(NaN + i inf) returns +inf + iNaN.
  259:         x = np.array([complex(np.nan, np.inf)], dtype=complex)
  260:         y = complex(np.inf, np.nan)
  261:         assert_almost_equal(np.log(x), y)
  262:         xl.append(x)
  263:         yl.append(y)
  264: 
  265:         # clog(NaN + iNaN) returns NaN + iNaN.
  266:         x = np.array([complex(np.nan, np.nan)], dtype=complex)
  267:         y = complex(np.nan, np.nan)
  268:         assert_almost_equal(np.log(x), y)
  269:         xl.append(x)
  270:         yl.append(y)
  271: 
  272:         # clog(conj(z)) = conj(clog(z)).
  273:         xa = np.array(xl, dtype=complex)
  274:         ya = np.array(yl, dtype=complex)
  275:         with np.errstate(divide='ignore'):
  276:             for i in range(len(xa)):
  277:                 assert_almost_equal(np.log(xa[i].conj()), ya[i].conj())
  278: 
  279: 
  280: class TestCsqrt:
  281: 
  282:     def test_simple(self):
  283:         # sqrt(1)
  284:         check_complex_value(np.sqrt, 1, 0, 1, 0)
  285: 
  286:         # sqrt(1i)
  287:         rres = 0.5 * np.sqrt(2)
  288:         ires = rres
  289:         check_complex_value(np.sqrt, 0, 1, rres, ires, False)
  290: 
  291:         # sqrt(-1)
  292:         check_complex_value(np.sqrt, -1, 0, 0, 1)
  293: 
  294:     def test_simple_conjugate(self):
  295:         ref = np.conj(np.sqrt(complex(1, 1)))
  296: 
  297:         def f(z):
  298:             return np.sqrt(np.conj(z))
  299: 
  300:         check_complex_value(f, 1, 1, ref.real, ref.imag, False)
  301: 
  302:     #def test_branch_cut(self):
  303:     #    _check_branch_cut(f, -1, 0, 1, -1)
  304: 
  305:     @platform_skip
  306:     def test_special_values(self):
  307:         # C99: Sec G 6.4.2
  308: 
  309:         check = check_complex_value
  310:         f = np.sqrt
  311: 
  312:         # csqrt(+-0 + 0i) is 0 + 0i
  313:         check(f, ncu.PZERO, 0, 0, 0)
  314:         check(f, ncu.NZERO, 0, 0, 0)
  315: 
  316:         # csqrt(x + infi) is inf + infi for any x (including NaN)
  317:         check(f,  1, np.inf, np.inf, np.inf)
  318:         check(f, -1, np.inf, np.inf, np.inf)
  319: 
  320:         check(f, ncu.PZERO, np.inf, np.inf, np.inf)
  321:         check(f, ncu.NZERO, np.inf, np.inf, np.inf)
  322:         check(f,    np.inf, np.inf, np.inf, np.inf)
  323:         check(f,   -np.inf, np.inf, np.inf, np.inf)  # noqa: E221
  324:         check(f,   -np.nan, np.inf, np.inf, np.inf)  # noqa: E221
  325: 
  326:         # csqrt(x + nani) is nan + nani for any finite x
  327:         check(f,  1, np.nan, np.nan, np.nan)
  328:         check(f, -1, np.nan, np.nan, np.nan)
  329:         check(f,  0, np.nan, np.nan, np.nan)
  330: 
  331:         # csqrt(-inf + yi) is +0 + infi for any finite y > 0
  332:         check(f, -np.inf, 1, ncu.PZERO, np.inf)
  333: 
  334:         # csqrt(inf + yi) is +inf + 0i for any finite y > 0
  335:         check(f, np.inf, 1, np.inf, ncu.PZERO)
  336: 
  337:         # csqrt(-inf + nani) is nan +- infi (both +i infi are valid)
  338:         def _check_ninf_nan(dummy):
  339:             msgform = "csqrt(-inf, nan) is (%f, %f), expected (nan, +-inf)"
  340:             z = np.sqrt(np.array(complex(-np.inf, np.nan)))
  341:             # FIXME: ugly workaround for isinf bug.
  342:             with np.errstate(invalid='ignore'):
  343:                 if not (np.isnan(z.real) and np.isinf(z.imag)):
  344:                     raise AssertionError(msgform % (z.real, z.imag))
  345: 
  346:         _check_ninf_nan(None)
  347: 
  348:         # csqrt(+inf + nani) is inf + nani
  349:         check(f, np.inf, np.nan, np.inf, np.nan)
  350: 
  351:         # csqrt(nan + yi) is nan + nani for any finite y (infinite handled in x
  352:         # + nani)
  353:         check(f, np.nan,       0, np.nan, np.nan)
  354:         check(f, np.nan,       1, np.nan, np.nan)
  355:         check(f, np.nan,  np.nan, np.nan, np.nan)
  356: 
  357:         # XXX: check for conj(csqrt(z)) == csqrt(conj(z)) (need to fix branch
  358:         # cuts first)
  359: 
  360: class TestCpow:
  361:     def setup_method(self):
  362:         self.olderr = np.seterr(invalid='ignore')
  363: 
  364:     def teardown_method(self):
  365:         np.seterr(**self.olderr)
  366: 
  367:     def test_simple(self):
  368:         x = np.array([1 + 1j, 0 + 2j, 1 + 2j, np.inf, np.nan])
  369:         y_r = x ** 2
  370:         y = np.power(x, 2)
  371:         assert_almost_equal(y, y_r)
  372: 
  373:     def test_scalar(self):
  374:         x = np.array([1, 1j,         2,  2.5 + .37j, np.inf, np.nan])
  375:         y = np.array([1, 1j, -0.5 + 1.5j, -0.5 + 1.5j,      2,      3])
  376:         lx = list(range(len(x)))
  377: 
  378:         # Hardcode the expected `builtins.complex` values,
  379:         # as complex exponentiation is broken as of bpo-44698
  380:         p_r = [
  381:             1 + 0j,
  382:             0.20787957635076193 + 0j,
  383:             0.35812203996480685 + 0.6097119028618724j,
  384:             0.12659112128185032 + 0.48847676699581527j,
  385:             complex(np.inf, np.nan),
  386:             complex(np.nan, np.nan),
  387:         ]
  388: 
  389:         n_r = [x[i] ** y[i] for i in lx]
  390:         for i in lx:
  391:             assert_almost_equal(n_r[i], p_r[i], err_msg='Loop %d\n' % i)
  392: 
  393:     def test_array(self):
  394:         x = np.array([1, 1j,         2,  2.5 + .37j, np.inf, np.nan])
  395:         y = np.array([1, 1j, -0.5 + 1.5j, -0.5 + 1.5j,      2,      3])
  396:         lx = list(range(len(x)))
  397: 
  398:         # Hardcode the expected `builtins.complex` values,
  399:         # as complex exponentiation is broken as of bpo-44698
  400:         p_r = [
  401:             1 + 0j,
  402:             0.20787957635076193 + 0j,
  403:             0.35812203996480685 + 0.6097119028618724j,
  404:             0.12659112128185032 + 0.48847676699581527j,
  405:             complex(np.inf, np.nan),
  406:             complex(np.nan, np.nan),
  407:         ]
  408: 
  409:         n_r = x ** y
  410:         for i in lx:
  411:             assert_almost_equal(n_r[i], p_r[i], err_msg='Loop %d\n' % i)
  412: 
  413: class TestCabs:
  414:     def setup_method(self):
  415:         self.olderr = np.seterr(invalid='ignore')
  416: 
  417:     def teardown_method(self):
  418:         np.seterr(**self.olderr)
  419: 
  420:     def test_simple(self):
  421:         x = np.array([1 + 1j, 0 + 2j, 1 + 2j, np.inf, np.nan])
  422:         y_r = np.array([np.sqrt(2.), 2, np.sqrt(5), np.inf, np.nan])
  423:         y = np.abs(x)
  424:         assert_almost_equal(y, y_r)
  425: 
  426:     def test_fabs(self):
  427:         # Test that np.abs(x +- 0j) == np.abs(x) (as mandated by C99 for cabs)
  428:         x = np.array([1 + 0j], dtype=complex)
  429:         assert_array_equal(np.abs(x), np.real(x))
  430: 
  431:         x = np.array([complex(1, ncu.NZERO)], dtype=complex)
  432:         assert_array_equal(np.abs(x), np.real(x))
  433: 
  434:         x = np.array([complex(np.inf, ncu.NZERO)], dtype=complex)
  435:         assert_array_equal(np.abs(x), np.real(x))
  436: 
  437:         x = np.array([complex(np.nan, ncu.NZERO)], dtype=complex)
  438:         assert_array_equal(np.abs(x), np.real(x))
  439: 
  440:     def test_cabs_inf_nan(self):
  441:         x, y = [], []
  442: 
  443:         # cabs(+-nan + nani) returns nan
  444:         x.append(np.nan)
  445:         y.append(np.nan)
  446:         check_real_value(np.abs,  np.nan, np.nan, np.nan)
  447: 
  448:         x.append(np.nan)
  449:         y.append(-np.nan)
  450:         check_real_value(np.abs, -np.nan, np.nan, np.nan)
  451: 
  452:         # According to C99 standard, if exactly one of the real/part is inf and
  453:         # the other nan, then cabs should return inf
  454:         x.append(np.inf)
  455:         y.append(np.nan)
  456:         check_real_value(np.abs,  np.inf, np.nan, np.inf)
  457: 
  458:         x.append(-np.inf)
  459:         y.append(np.nan)
  460:         check_real_value(np.abs, -np.inf, np.nan, np.inf)
  461: 
  462:         # cabs(conj(z)) == conj(cabs(z)) (= cabs(z))
  463:         def f(a):
  464:             return np.abs(np.conj(a))
  465: 
  466:         def g(a, b):
  467:             return np.abs(complex(a, b))
  468: 
  469:         xa = np.array(x, dtype=complex)
  470:         assert len(xa) == len(x) == len(y)
  471:         for xi, yi in zip(x, y):
  472:             ref = g(xi, yi)
  473:             check_real_value(f, xi, yi, ref)
  474: 
  475: class TestCarg:
  476:     def test_simple(self):
  477:         check_real_value(ncu._arg, 1, 0, 0, False)
  478:         check_real_value(ncu._arg, 0, 1, 0.5 * np.pi, False)
  479: 
  480:         check_real_value(ncu._arg, 1, 1, 0.25 * np.pi, False)
  481:         check_real_value(ncu._arg, ncu.PZERO, ncu.PZERO, ncu.PZERO)
  482: 
  483:     # TODO This can be xfail when the generator functions are got rid of.
  484:     @pytest.mark.skip(
  485:         reason="Complex arithmetic with signed zero fails on most platforms")
  486:     def test_zero(self):
  487:         # carg(-0 +- 0i) returns +- pi
  488:         check_real_value(ncu._arg, ncu.NZERO, ncu.PZERO,  np.pi, False)
  489:         check_real_value(ncu._arg, ncu.NZERO, ncu.NZERO, -np.pi, False)
  490: 
  491:         # carg(+0 +- 0i) returns +- 0
  492:         check_real_value(ncu._arg, ncu.PZERO, ncu.PZERO, ncu.PZERO)
  493:         check_real_value(ncu._arg, ncu.PZERO, ncu.NZERO, ncu.NZERO)
  494: 
  495:         # carg(x +- 0i) returns +- 0 for x > 0
  496:         check_real_value(ncu._arg, 1, ncu.PZERO, ncu.PZERO, False)
  497:         check_real_value(ncu._arg, 1, ncu.NZERO, ncu.NZERO, False)
  498: 
  499:         # carg(x +- 0i) returns +- pi for x < 0
  500:         check_real_value(ncu._arg, -1, ncu.PZERO,  np.pi, False)
  501:         check_real_value(ncu._arg, -1, ncu.NZERO, -np.pi, False)
  502: 
  503:         # carg(+- 0 + yi) returns pi/2 for y > 0
  504:         check_real_value(ncu._arg, ncu.PZERO, 1, 0.5 * np.pi, False)
  505:         check_real_value(ncu._arg, ncu.NZERO, 1, 0.5 * np.pi, False)
  506: 
  507:         # carg(+- 0 + yi) returns -pi/2 for y < 0
  508:         check_real_value(ncu._arg, ncu.PZERO, -1, 0.5 * np.pi, False)
  509:         check_real_value(ncu._arg, ncu.NZERO, -1, -0.5 * np.pi, False)
  510: 
  511:     #def test_branch_cuts(self):
  512:     #    _check_branch_cut(ncu._arg, -1, 1j, -1, 1)
  513: 
  514:     def test_special_values(self):
  515:         # carg(-np.inf +- yi) returns +-pi for finite y > 0
  516:         check_real_value(ncu._arg, -np.inf,  1,  np.pi, False)
  517:         check_real_value(ncu._arg, -np.inf, -1, -np.pi, False)
  518: 
  519:         # carg(np.inf +- yi) returns +-0 for finite y > 0
  520:         check_real_value(ncu._arg, np.inf,  1, ncu.PZERO, False)
  521:         check_real_value(ncu._arg, np.inf, -1, ncu.NZERO, False)
  522: 
  523:         # carg(x +- np.infi) returns +-pi/2 for finite x
  524:         check_real_value(ncu._arg, 1,  np.inf,  0.5 * np.pi, False)
  525:         check_real_value(ncu._arg, 1, -np.inf, -0.5 * np.pi, False)
  526: 
  527:         # carg(-np.inf +- np.infi) returns +-3pi/4
  528:         check_real_value(ncu._arg, -np.inf,  np.inf,  0.75 * np.pi, False)
  529:         check_real_value(ncu._arg, -np.inf, -np.inf, -0.75 * np.pi, False)
  530: 
  531:         # carg(np.inf +- np.infi) returns +-pi/4
  532:         check_real_value(ncu._arg, np.inf,  np.inf,  0.25 * np.pi, False)
  533:         check_real_value(ncu._arg, np.inf, -np.inf, -0.25 * np.pi, False)
  534: 
  535:         # carg(x + yi) returns np.nan if x or y is nan
  536:         check_real_value(ncu._arg, np.nan,      0, np.nan, False)
  537:         check_real_value(ncu._arg,      0, np.nan, np.nan, False)
  538: 
  539:         check_real_value(ncu._arg, np.nan, np.inf, np.nan, False)
  540:         check_real_value(ncu._arg, np.inf, np.nan, np.nan, False)
  541: 
  542: 
  543: def check_real_value(f, x1, y1, x, exact=True):
  544:     z1 = np.array([complex(x1, y1)])
  545:     if exact:
  546:         assert_equal(f(z1), x)
  547:     else:
  548:         assert_almost_equal(f(z1), x)
  549: 
  550: 
  551: def check_complex_value(f, x1, y1, x2, y2, exact=True):
  552:     z1 = np.array([complex(x1, y1)])
  553:     z2 = complex(x2, y2)
  554:     with np.errstate(invalid='ignore'):
  555:         if exact:
  556:             assert_equal(f(z1), z2)
  557:         else:
  558:             assert_almost_equal(f(z1), z2)
  559: 
  560: class TestSpecialComplexAVX:
  561:     @pytest.mark.parametrize("stride", [-4, -2, -1, 1, 2, 4])
  562:     @pytest.mark.parametrize("astype", [np.complex64, np.complex128])
  563:     def test_array(self, stride, astype):
  564:         arr = np.array([complex(np.nan, np.nan),
  565:                         complex(np.nan, np.inf),
  566:                         complex(np.inf, np.nan),
  567:                         complex(np.inf, np.inf),
  568:                         complex(0.,     np.inf),
  569:                         complex(np.inf, 0.),
  570:                         complex(0.,     0.),
  571:                         complex(0.,     np.nan),
  572:                         complex(np.nan, 0.)], dtype=astype)
  573:         abs_true = np.array([np.nan, np.inf, np.inf, np.inf, np.inf, np.inf, 0., np.nan, np.nan], dtype=arr.real.dtype)
  574:         sq_true = np.array([complex(np.nan,  np.nan),
  575:                             complex(np.nan,  np.nan),
  576:                             complex(np.nan,  np.nan),
  577:                             complex(np.nan,  np.inf),
  578:                             complex(-np.inf, np.nan),
  579:                             complex(np.inf,  np.nan),
  580:                             complex(0.,      0.),
  581:                             complex(np.nan,  np.nan),
  582:                             complex(np.nan,  np.nan)], dtype=astype)
  583:         with np.errstate(invalid='ignore'):
  584:             assert_equal(np.abs(arr[::stride]), abs_true[::stride])
  585:             assert_equal(np.square(arr[::stride]), sq_true[::stride])
  586: 
  587: class TestComplexAbsoluteAVX:
  588:     @pytest.mark.parametrize("arraysize", [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 18, 19])
  589:     @pytest.mark.parametrize("stride", [-4, -3, -2, -1, 1, 2, 3, 4])
  590:     @pytest.mark.parametrize("astype", [np.complex64, np.complex128])
  591:     # test to ensure masking and strides work as intended in the AVX implementation
  592:     def test_array(self, arraysize, stride, astype):
  593:         arr = np.ones(arraysize, dtype=astype)
  594:         abs_true = np.ones(arraysize, dtype=arr.real.dtype)
  595:         assert_equal(np.abs(arr[::stride]), abs_true[::stride])
  596: 
  597: # Testcase taken as is from https://github.com/numpy/numpy/issues/16660
  598: class TestComplexAbsoluteMixedDTypes:
  599:     @pytest.mark.parametrize("stride", [-4, -3, -2, -1, 1, 2, 3, 4])
  600:     @pytest.mark.parametrize("astype", [np.complex64, np.complex128])
  601:     @pytest.mark.parametrize("func", ['abs', 'square', 'conjugate'])
  602:     def test_array(self, stride, astype, func):
  603:         dtype = [('template_id', '<i8'), ('bank_chisq', '<f4'),
  604:                  ('bank_chisq_dof', '<i8'), ('chisq', '<f4'), ('chisq_dof', '<i8'),
  605:                  ('cont_chisq', '<f4'), ('psd_var_val', '<f4'), ('sg_chisq', '<f4'),
  606:                  ('mycomplex', astype), ('time_index', '<i8')]
  607:         vec = np.array([
  608:                 (0, 0., 0, -31.666483, 200, 0., 0.,  1.      ,  3.0 + 4.0j  ,  613090),   # noqa: E203,E501
  609:                 (1, 0., 0, 260.91525 ,  42, 0., 0.,  1.      ,  5.0 + 12.0j ,  787315),   # noqa: E203,E501
  610:                 (1, 0., 0,  52.15155 ,  42, 0., 0.,  1.      ,  8.0 + 15.0j ,  806641),   # noqa: E203,E501
  611:                 (1, 0., 0,  52.430195,  42, 0., 0.,  1.      ,  7.0 + 24.0j , 1363540),   # noqa: E203,E501
  612:                 (2, 0., 0, 304.43646 ,  58, 0., 0.,  1.      ,  20.0 + 21.0j,  787323),   # noqa: E203,E501
  613:                 (3, 0., 0, 299.42108 ,  52, 0., 0.,  1.      ,  12.0 + 35.0j,  787332),   # noqa: E203,E501
  614:                 (4, 0., 0,  39.4836  ,  28, 0., 0.,  9.182192,  9.0 + 40.0j ,  787304),   # noqa: E203,E501
  615:                 (4, 0., 0,  76.83787 ,  28, 0., 0.,  1.      ,  28.0 + 45.0j, 1321869),   # noqa: E203,E501
  616:                 (5, 0., 0, 143.26366 ,  24, 0., 0., 10.996129,  11.0 + 60.0j,  787299)],  # noqa: E203,E501
  617:             dtype=dtype)
  618:         myfunc = getattr(np, func)
  619:         a = vec['mycomplex']
  620:         g = myfunc(a[::stride])
  621: 
  622:         b = vec['mycomplex'].copy()
  623:         h = myfunc(b[::stride])
  624: 
  625:         assert_array_max_ulp(h.real, g.real, 1)
  626:         assert_array_max_ulp(h.imag, g.imag, 1)
