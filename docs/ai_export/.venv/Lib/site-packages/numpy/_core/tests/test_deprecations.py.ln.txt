    1: """
    2: Tests related to deprecation warnings. Also a convenient place
    3: to document how deprecations should eventually be turned into errors.
    4: 
    5: """
    6: import contextlib
    7: import warnings
    8: 
    9: import numpy._core._struct_ufunc_tests as struct_ufunc
   10: import pytest
   11: from numpy._core._multiarray_tests import fromstring_null_term_c_api  # noqa: F401
   12: 
   13: import numpy as np
   14: from numpy.testing import assert_raises, temppath
   15: 
   16: try:
   17:     import pytz  # noqa: F401
   18:     _has_pytz = True
   19: except ImportError:
   20:     _has_pytz = False
   21: 
   22: 
   23: class _DeprecationTestCase:
   24:     # Just as warning: warnings uses re.match, so the start of this message
   25:     # must match.
   26:     message = ''
   27:     warning_cls = DeprecationWarning
   28: 
   29:     def setup_method(self):
   30:         self.warn_ctx = warnings.catch_warnings(record=True)
   31:         self.log = self.warn_ctx.__enter__()
   32: 
   33:         # Do *not* ignore other DeprecationWarnings. Ignoring warnings
   34:         # can give very confusing results because of
   35:         # https://bugs.python.org/issue4180 and it is probably simplest to
   36:         # try to keep the tests cleanly giving only the right warning type.
   37:         # (While checking them set to "error" those are ignored anyway)
   38:         # We still have them show up, because otherwise they would be raised
   39:         warnings.filterwarnings("always", category=self.warning_cls)
   40:         warnings.filterwarnings("always", message=self.message,
   41:                                 category=self.warning_cls)
   42: 
   43:     def teardown_method(self):
   44:         self.warn_ctx.__exit__()
   45: 
   46:     def assert_deprecated(self, function, num=1, ignore_others=False,
   47:                           function_fails=False,
   48:                           exceptions=np._NoValue,
   49:                           args=(), kwargs={}):
   50:         """Test if DeprecationWarnings are given and raised.
   51: 
   52:         This first checks if the function when called gives `num`
   53:         DeprecationWarnings, after that it tries to raise these
   54:         DeprecationWarnings and compares them with `exceptions`.
   55:         The exceptions can be different for cases where this code path
   56:         is simply not anticipated and the exception is replaced.
   57: 
   58:         Parameters
   59:         ----------
   60:         function : callable
   61:             The function to test
   62:         num : int
   63:             Number of DeprecationWarnings to expect. This should normally be 1.
   64:         ignore_others : bool
   65:             Whether warnings of the wrong type should be ignored (note that
   66:             the message is not checked)
   67:         function_fails : bool
   68:             If the function would normally fail, setting this will check for
   69:             warnings inside a try/except block.
   70:         exceptions : Exception or tuple of Exceptions
   71:             Exception to expect when turning the warnings into an error.
   72:             The default checks for DeprecationWarnings. If exceptions is
   73:             empty the function is expected to run successfully.
   74:         args : tuple
   75:             Arguments for `function`
   76:         kwargs : dict
   77:             Keyword arguments for `function`
   78:         """
   79:         __tracebackhide__ = True  # Hide traceback for py.test
   80: 
   81:         # reset the log
   82:         self.log[:] = []
   83: 
   84:         if exceptions is np._NoValue:
   85:             exceptions = (self.warning_cls,)
   86: 
   87:         if function_fails:
   88:             context_manager = contextlib.suppress(Exception)
   89:         else:
   90:             context_manager = contextlib.nullcontext()
   91:         with context_manager:
   92:             function(*args, **kwargs)
   93: 
   94:         # just in case, clear the registry
   95:         num_found = 0
   96:         for warning in self.log:
   97:             if warning.category is self.warning_cls:
   98:                 num_found += 1
   99:             elif not ignore_others:
  100:                 raise AssertionError(
  101:                         "expected %s but got: %s" %
  102:                         (self.warning_cls.__name__, warning.category))
  103:         if num is not None and num_found != num:
  104:             msg = f"{len(self.log)} warnings found but {num} expected."
  105:             lst = [str(w) for w in self.log]
  106:             raise AssertionError("\n".join([msg] + lst))
  107: 
  108:         with warnings.catch_warnings():
  109:             warnings.filterwarnings("error", message=self.message,
  110:                                     category=self.warning_cls)
  111:             try:
  112:                 function(*args, **kwargs)
  113:                 if exceptions != ():
  114:                     raise AssertionError(
  115:                             "No error raised during function call")
  116:             except exceptions:
  117:                 if exceptions == ():
  118:                     raise AssertionError(
  119:                             "Error raised during function call")
  120: 
  121:     def assert_not_deprecated(self, function, args=(), kwargs={}):
  122:         """Test that warnings are not raised.
  123: 
  124:         This is just a shorthand for:
  125: 
  126:         self.assert_deprecated(function, num=0, ignore_others=True,
  127:                         exceptions=tuple(), args=args, kwargs=kwargs)
  128:         """
  129:         self.assert_deprecated(function, num=0, ignore_others=True,
  130:                         exceptions=(), args=args, kwargs=kwargs)
  131: 
  132: 
  133: class _VisibleDeprecationTestCase(_DeprecationTestCase):
  134:     warning_cls = np.exceptions.VisibleDeprecationWarning
  135: 
  136: 
  137: class TestTestDeprecated:
  138:     def test_assert_deprecated(self):
  139:         test_case_instance = _DeprecationTestCase()
  140:         test_case_instance.setup_method()
  141:         assert_raises(AssertionError,
  142:                       test_case_instance.assert_deprecated,
  143:                       lambda: None)
  144: 
  145:         def foo():
  146:             warnings.warn("foo", category=DeprecationWarning, stacklevel=2)
  147: 
  148:         test_case_instance.assert_deprecated(foo)
  149:         test_case_instance.teardown_method()
  150: 
  151: 
  152: class TestBincount(_DeprecationTestCase):
  153:     # 2024-07-29, 2.1.0
  154:     @pytest.mark.parametrize('badlist', [[0.5, 1.2, 1.5],
  155:                                          ['0', '1', '1']])
  156:     def test_bincount_bad_list(self, badlist):
  157:         self.assert_deprecated(lambda: np.bincount(badlist))
  158: 
  159: 
  160: class TestGeneratorSum(_DeprecationTestCase):
  161:     # 2018-02-25, 1.15.0
  162:     def test_generator_sum(self):
  163:         self.assert_deprecated(np.sum, args=((i for i in range(5)),))
  164: 
  165: 
  166: class BuiltInRoundComplexDType(_DeprecationTestCase):
  167:     # 2020-03-31 1.19.0
  168:     deprecated_types = [np.csingle, np.cdouble, np.clongdouble]
  169:     not_deprecated_types = [
  170:         np.int8, np.int16, np.int32, np.int64,
  171:         np.uint8, np.uint16, np.uint32, np.uint64,
  172:         np.float16, np.float32, np.float64,
  173:     ]
  174: 
  175:     def test_deprecated(self):
  176:         for scalar_type in self.deprecated_types:
  177:             scalar = scalar_type(0)
  178:             self.assert_deprecated(round, args=(scalar,))
  179:             self.assert_deprecated(round, args=(scalar, 0))
  180:             self.assert_deprecated(round, args=(scalar,), kwargs={'ndigits': 0})
  181: 
  182:     def test_not_deprecated(self):
  183:         for scalar_type in self.not_deprecated_types:
  184:             scalar = scalar_type(0)
  185:             self.assert_not_deprecated(round, args=(scalar,))
  186:             self.assert_not_deprecated(round, args=(scalar, 0))
  187:             self.assert_not_deprecated(round, args=(scalar,), kwargs={'ndigits': 0})
  188: 
  189: 
  190: class FlatteningConcatenateUnsafeCast(_DeprecationTestCase):
  191:     # NumPy 1.20, 2020-09-03
  192:     message = "concatenate with `axis=None` will use same-kind casting"
  193: 
  194:     def test_deprecated(self):
  195:         self.assert_deprecated(np.concatenate,
  196:                 args=(([0.], [1.]),),
  197:                 kwargs={'axis': None, 'out': np.empty(2, dtype=np.int64)})
  198: 
  199:     def test_not_deprecated(self):
  200:         self.assert_not_deprecated(np.concatenate,
  201:                 args=(([0.], [1.]),),
  202:                 kwargs={'axis': None, 'out': np.empty(2, dtype=np.int64),
  203:                         'casting': "unsafe"})
  204: 
  205:         with assert_raises(TypeError):
  206:             # Tests should notice if the deprecation warning is given first...
  207:             np.concatenate(([0.], [1.]), out=np.empty(2, dtype=np.int64),
  208:                            casting="same_kind")
  209: 
  210: 
  211: class TestCtypesGetter(_DeprecationTestCase):
  212:     # Deprecated 2021-05-18, Numpy 1.21.0
  213:     warning_cls = DeprecationWarning
  214:     ctypes = np.array([1]).ctypes
  215: 
  216:     @pytest.mark.parametrize(
  217:         "name", ["get_data", "get_shape", "get_strides", "get_as_parameter"]
  218:     )
  219:     def test_deprecated(self, name: str) -> None:
  220:         func = getattr(self.ctypes, name)
  221:         self.assert_deprecated(func)
  222: 
  223:     @pytest.mark.parametrize(
  224:         "name", ["data", "shape", "strides", "_as_parameter_"]
  225:     )
  226:     def test_not_deprecated(self, name: str) -> None:
  227:         self.assert_not_deprecated(lambda: getattr(self.ctypes, name))
  228: 
  229: 
  230: class TestMachAr(_DeprecationTestCase):
  231:     # Deprecated 2022-11-22, NumPy 1.25
  232:     warning_cls = DeprecationWarning
  233: 
  234:     def test_deprecated_module(self):
  235:         self.assert_deprecated(lambda: np._core.MachAr)
  236: 
  237: 
  238: class TestQuantileInterpolationDeprecation(_DeprecationTestCase):
  239:     # Deprecated 2021-11-08, NumPy 1.22
  240:     @pytest.mark.parametrize("func",
  241:         [np.percentile, np.quantile, np.nanpercentile, np.nanquantile])
  242:     def test_deprecated(self, func):
  243:         self.assert_deprecated(
  244:             lambda: func([0., 1.], 0., interpolation="linear"))
  245:         self.assert_deprecated(
  246:             lambda: func([0., 1.], 0., interpolation="nearest"))
  247: 
  248:     @pytest.mark.parametrize("func",
  249:             [np.percentile, np.quantile, np.nanpercentile, np.nanquantile])
  250:     def test_both_passed(self, func):
  251:         with warnings.catch_warnings():
  252:             # catch the DeprecationWarning so that it does not raise:
  253:             warnings.simplefilter("always", DeprecationWarning)
  254:             with pytest.raises(TypeError):
  255:                 func([0., 1.], 0., interpolation="nearest", method="nearest")
  256: 
  257: 
  258: class TestScalarConversion(_DeprecationTestCase):
  259:     # 2023-01-02, 1.25.0
  260:     def test_float_conversion(self):
  261:         self.assert_deprecated(float, args=(np.array([3.14]),))
  262: 
  263:     def test_behaviour(self):
  264:         b = np.array([[3.14]])
  265:         c = np.zeros(5)
  266:         with pytest.warns(DeprecationWarning):
  267:             c[0] = b
  268: 
  269: 
  270: class TestPyIntConversion(_DeprecationTestCase):
  271:     message = r".*stop allowing conversion of out-of-bound.*"
  272: 
  273:     @pytest.mark.parametrize("dtype", np.typecodes["AllInteger"])
  274:     def test_deprecated_scalar(self, dtype):
  275:         dtype = np.dtype(dtype)
  276:         info = np.iinfo(dtype)
  277: 
  278:         # Cover the most common creation paths (all end up in the
  279:         # same place):
  280:         def scalar(value, dtype):
  281:             dtype.type(value)
  282: 
  283:         def assign(value, dtype):
  284:             arr = np.array([0, 0, 0], dtype=dtype)
  285:             arr[2] = value
  286: 
  287:         def create(value, dtype):
  288:             np.array([value], dtype=dtype)
  289: 
  290:         for creation_func in [scalar, assign, create]:
  291:             try:
  292:                 self.assert_deprecated(
  293:                         lambda: creation_func(info.min - 1, dtype))
  294:             except OverflowError:
  295:                 pass  # OverflowErrors always happened also before and are OK.
  296: 
  297:             try:
  298:                 self.assert_deprecated(
  299:                         lambda: creation_func(info.max + 1, dtype))
  300:             except OverflowError:
  301:                 pass  # OverflowErrors always happened also before and are OK.
  302: 
  303: 
  304: @pytest.mark.parametrize("name", ["str", "bytes", "object"])
  305: def test_future_scalar_attributes(name):
  306:     # FutureWarning added 2022-11-17, NumPy 1.24,
  307:     assert name not in dir(np)  # we may want to not add them
  308:     with pytest.warns(FutureWarning,
  309:             match=f"In the future .*{name}"):
  310:         assert not hasattr(np, name)
  311: 
  312:     # Unfortunately, they are currently still valid via `np.dtype()`
  313:     np.dtype(name)
  314:     name in np._core.sctypeDict
  315: 
  316: 
  317: # Ignore the above future attribute warning for this test.
  318: @pytest.mark.filterwarnings("ignore:In the future:FutureWarning")
  319: class TestRemovedGlobals:
  320:     # Removed 2023-01-12, NumPy 1.24.0
  321:     # Not a deprecation, but the large error was added to aid those who missed
  322:     # the previous deprecation, and should be removed similarly to one
  323:     # (or faster).
  324:     @pytest.mark.parametrize("name",
  325:             ["object", "float", "complex", "str", "int"])
  326:     def test_attributeerror_includes_info(self, name):
  327:         msg = f".*\n`np.{name}` was a deprecated alias for the builtin"
  328:         with pytest.raises(AttributeError, match=msg):
  329:             getattr(np, name)
  330: 
  331: 
  332: class TestDeprecatedFinfo(_DeprecationTestCase):
  333:     # Deprecated in NumPy 1.25, 2023-01-16
  334:     def test_deprecated_none(self):
  335:         self.assert_deprecated(np.finfo, args=(None,))
  336: 
  337: 
  338: class TestMathAlias(_DeprecationTestCase):
  339:     def test_deprecated_np_lib_math(self):
  340:         self.assert_deprecated(lambda: np.lib.math)
  341: 
  342: 
  343: class TestLibImports(_DeprecationTestCase):
  344:     # Deprecated in Numpy 1.26.0, 2023-09
  345:     def test_lib_functions_deprecation_call(self):
  346:         from numpy import in1d, row_stack, trapz
  347:         from numpy._core.numerictypes import maximum_sctype
  348:         from numpy.lib._function_base_impl import disp
  349:         from numpy.lib._npyio_impl import recfromcsv, recfromtxt
  350:         from numpy.lib._shape_base_impl import get_array_wrap
  351:         from numpy.lib._utils_impl import safe_eval
  352:         from numpy.lib.tests.test_io import TextIO
  353: 
  354:         self.assert_deprecated(lambda: safe_eval("None"))
  355: 
  356:         data_gen = lambda: TextIO('A,B\n0,1\n2,3')
  357:         kwargs = {'delimiter': ",", 'missing_values': "N/A", 'names': True}
  358:         self.assert_deprecated(lambda: recfromcsv(data_gen()))
  359:         self.assert_deprecated(lambda: recfromtxt(data_gen(), **kwargs))
  360: 
  361:         self.assert_deprecated(lambda: disp("test"))
  362:         self.assert_deprecated(get_array_wrap)
  363:         self.assert_deprecated(lambda: maximum_sctype(int))
  364: 
  365:         self.assert_deprecated(lambda: in1d([1], [1]))
  366:         self.assert_deprecated(lambda: row_stack([[]]))
  367:         self.assert_deprecated(lambda: trapz([1], [1]))
  368:         self.assert_deprecated(lambda: np.chararray)
  369: 
  370: 
  371: class TestDeprecatedDTypeAliases(_DeprecationTestCase):
  372: 
  373:     def _check_for_warning(self, func):
  374:         with warnings.catch_warnings(record=True) as caught_warnings:
  375:             func()
  376:         assert len(caught_warnings) == 1
  377:         w = caught_warnings[0]
  378:         assert w.category is DeprecationWarning
  379:         assert "alias 'a' was deprecated in NumPy 2.0" in str(w.message)
  380: 
  381:     def test_a_dtype_alias(self):
  382:         for dtype in ["a", "a10"]:
  383:             f = lambda: np.dtype(dtype)
  384:             self._check_for_warning(f)
  385:             self.assert_deprecated(f)
  386:             f = lambda: np.array(["hello", "world"]).astype("a10")
  387:             self._check_for_warning(f)
  388:             self.assert_deprecated(f)
  389: 
  390: 
  391: class TestDeprecatedArrayWrap(_DeprecationTestCase):
  392:     message = "__array_wrap__.*"
  393: 
  394:     def test_deprecated(self):
  395:         class Test1:
  396:             def __array__(self, dtype=None, copy=None):
  397:                 return np.arange(4)
  398: 
  399:             def __array_wrap__(self, arr, context=None):
  400:                 self.called = True
  401:                 return 'pass context'
  402: 
  403:         class Test2(Test1):
  404:             def __array_wrap__(self, arr):
  405:                 self.called = True
  406:                 return 'pass'
  407: 
  408:         test1 = Test1()
  409:         test2 = Test2()
  410:         self.assert_deprecated(lambda: np.negative(test1))
  411:         assert test1.called
  412:         self.assert_deprecated(lambda: np.negative(test2))
  413:         assert test2.called
  414: 
  415: 
  416: class TestDeprecatedDTypeParenthesizedRepeatCount(_DeprecationTestCase):
  417:     message = "Passing in a parenthesized single number"
  418: 
  419:     @pytest.mark.parametrize("string", ["(2)i,", "(3)3S,", "f,(2)f"])
  420:     def test_parenthesized_repeat_count(self, string):
  421:         self.assert_deprecated(np.dtype, args=(string,))
  422: 
  423: 
  424: class TestDeprecatedSaveFixImports(_DeprecationTestCase):
  425:     # Deprecated in Numpy 2.1, 2024-05
  426:     message = "The 'fix_imports' flag is deprecated and has no effect."
  427: 
  428:     def test_deprecated(self):
  429:         with temppath(suffix='.npy') as path:
  430:             sample_args = (path, np.array(np.zeros((1024, 10))))
  431:             self.assert_not_deprecated(np.save, args=sample_args)
  432:             self.assert_deprecated(np.save, args=sample_args,
  433:                                 kwargs={'fix_imports': True})
  434:             self.assert_deprecated(np.save, args=sample_args,
  435:                                 kwargs={'fix_imports': False})
  436:             for allow_pickle in [True, False]:
  437:                 self.assert_not_deprecated(np.save, args=sample_args,
  438:                                         kwargs={'allow_pickle': allow_pickle})
  439:                 self.assert_deprecated(np.save, args=sample_args,
  440:                                     kwargs={'allow_pickle': allow_pickle,
  441:                                             'fix_imports': True})
  442:                 self.assert_deprecated(np.save, args=sample_args,
  443:                                     kwargs={'allow_pickle': allow_pickle,
  444:                                             'fix_imports': False})
  445: 
  446: 
  447: class TestAddNewdocUFunc(_DeprecationTestCase):
  448:     # Deprecated in Numpy 2.2, 2024-11
  449:     def test_deprecated(self):
  450:         self.assert_deprecated(
  451:             lambda: np._core.umath._add_newdoc_ufunc(
  452:                 struct_ufunc.add_triplet, "new docs"
  453:             )
  454:         )
