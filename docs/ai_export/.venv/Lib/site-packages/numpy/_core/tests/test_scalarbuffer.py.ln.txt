    1: """
    2: Test scalar buffer interface adheres to PEP 3118
    3: """
    4: import pytest
    5: from numpy._core._multiarray_tests import get_buffer_info
    6: from numpy._core._rational_tests import rational
    7: 
    8: import numpy as np
    9: from numpy.testing import assert_, assert_equal, assert_raises
   10: 
   11: # PEP3118 format strings for native (standard alignment and byteorder) types
   12: scalars_and_codes = [
   13:     (np.bool, '?'),
   14:     (np.byte, 'b'),
   15:     (np.short, 'h'),
   16:     (np.intc, 'i'),
   17:     (np.long, 'l'),
   18:     (np.longlong, 'q'),
   19:     (np.ubyte, 'B'),
   20:     (np.ushort, 'H'),
   21:     (np.uintc, 'I'),
   22:     (np.ulong, 'L'),
   23:     (np.ulonglong, 'Q'),
   24:     (np.half, 'e'),
   25:     (np.single, 'f'),
   26:     (np.double, 'd'),
   27:     (np.longdouble, 'g'),
   28:     (np.csingle, 'Zf'),
   29:     (np.cdouble, 'Zd'),
   30:     (np.clongdouble, 'Zg'),
   31: ]
   32: scalars_only, codes_only = zip(*scalars_and_codes)
   33: 
   34: 
   35: class TestScalarPEP3118:
   36: 
   37:     @pytest.mark.parametrize('scalar', scalars_only, ids=codes_only)
   38:     def test_scalar_match_array(self, scalar):
   39:         x = scalar()
   40:         a = np.array([], dtype=np.dtype(scalar))
   41:         mv_x = memoryview(x)
   42:         mv_a = memoryview(a)
   43:         assert_equal(mv_x.format, mv_a.format)
   44: 
   45:     @pytest.mark.parametrize('scalar', scalars_only, ids=codes_only)
   46:     def test_scalar_dim(self, scalar):
   47:         x = scalar()
   48:         mv_x = memoryview(x)
   49:         assert_equal(mv_x.itemsize, np.dtype(scalar).itemsize)
   50:         assert_equal(mv_x.ndim, 0)
   51:         assert_equal(mv_x.shape, ())
   52:         assert_equal(mv_x.strides, ())
   53:         assert_equal(mv_x.suboffsets, ())
   54: 
   55:     @pytest.mark.parametrize('scalar, code', scalars_and_codes, ids=codes_only)
   56:     def test_scalar_code_and_properties(self, scalar, code):
   57:         x = scalar()
   58:         expected = {'strides': (), 'itemsize': x.dtype.itemsize, 'ndim': 0,
   59:                         'shape': (), 'format': code, 'readonly': True}
   60: 
   61:         mv_x = memoryview(x)
   62:         assert self._as_dict(mv_x) == expected
   63: 
   64:     @pytest.mark.parametrize('scalar', scalars_only, ids=codes_only)
   65:     def test_scalar_buffers_readonly(self, scalar):
   66:         x = scalar()
   67:         with pytest.raises(BufferError, match="scalar buffer is readonly"):
   68:             get_buffer_info(x, ["WRITABLE"])
   69: 
   70:     def test_void_scalar_structured_data(self):
   71:         dt = np.dtype([('name', np.str_, 16), ('grades', np.float64, (2,))])
   72:         x = np.array(('ndarray_scalar', (1.2, 3.0)), dtype=dt)[()]
   73:         assert_(isinstance(x, np.void))
   74:         mv_x = memoryview(x)
   75:         expected_size = 16 * np.dtype((np.str_, 1)).itemsize
   76:         expected_size += 2 * np.dtype(np.float64).itemsize
   77:         assert_equal(mv_x.itemsize, expected_size)
   78:         assert_equal(mv_x.ndim, 0)
   79:         assert_equal(mv_x.shape, ())
   80:         assert_equal(mv_x.strides, ())
   81:         assert_equal(mv_x.suboffsets, ())
   82: 
   83:         # check scalar format string against ndarray format string
   84:         a = np.array([('Sarah', (8.0, 7.0)), ('John', (6.0, 7.0))], dtype=dt)
   85:         assert_(isinstance(a, np.ndarray))
   86:         mv_a = memoryview(a)
   87:         assert_equal(mv_x.itemsize, mv_a.itemsize)
   88:         assert_equal(mv_x.format, mv_a.format)
   89: 
   90:         # Check that we do not allow writeable buffer export (technically
   91:         # we could allow it sometimes here...)
   92:         with pytest.raises(BufferError, match="scalar buffer is readonly"):
   93:             get_buffer_info(x, ["WRITABLE"])
   94: 
   95:     def _as_dict(self, m):
   96:         return {'strides': m.strides, 'shape': m.shape, 'itemsize': m.itemsize,
   97:                     'ndim': m.ndim, 'format': m.format, 'readonly': m.readonly}
   98: 
   99:     def test_datetime_memoryview(self):
  100:         # gh-11656
  101:         # Values verified with v1.13.3, shape is not () as in test_scalar_dim
  102: 
  103:         dt1 = np.datetime64('2016-01-01')
  104:         dt2 = np.datetime64('2017-01-01')
  105:         expected = {'strides': (1,), 'itemsize': 1, 'ndim': 1, 'shape': (8,),
  106:                         'format': 'B', 'readonly': True}
  107:         v = memoryview(dt1)
  108:         assert self._as_dict(v) == expected
  109: 
  110:         v = memoryview(dt2 - dt1)
  111:         assert self._as_dict(v) == expected
  112: 
  113:         dt = np.dtype([('a', 'uint16'), ('b', 'M8[s]')])
  114:         a = np.empty(1, dt)
  115:         # Fails to create a PEP 3118 valid buffer
  116:         assert_raises((ValueError, BufferError), memoryview, a[0])
  117: 
  118:         # Check that we do not allow writeable buffer export
  119:         with pytest.raises(BufferError, match="scalar buffer is readonly"):
  120:             get_buffer_info(dt1, ["WRITABLE"])
  121: 
  122:     @pytest.mark.parametrize('s', [
  123:         pytest.param("\x32\x32", id="ascii"),
  124:         pytest.param("\uFE0F\uFE0F", id="basic multilingual"),
  125:         pytest.param("\U0001f4bb\U0001f4bb", id="non-BMP"),
  126:     ])
  127:     def test_str_ucs4(self, s):
  128:         s = np.str_(s)  # only our subclass implements the buffer protocol
  129: 
  130:         # all the same, characters always encode as ucs4
  131:         expected = {'strides': (), 'itemsize': 8, 'ndim': 0, 'shape': (), 'format': '2w',
  132:                         'readonly': True}
  133: 
  134:         v = memoryview(s)
  135:         assert self._as_dict(v) == expected
  136: 
  137:         # integers of the paltform-appropriate endianness
  138:         code_points = np.frombuffer(v, dtype='i4')
  139: 
  140:         assert_equal(code_points, [ord(c) for c in s])
  141: 
  142:         # Check that we do not allow writeable buffer export
  143:         with pytest.raises(BufferError, match="scalar buffer is readonly"):
  144:             get_buffer_info(s, ["WRITABLE"])
  145: 
  146:     def test_user_scalar_fails_buffer(self):
  147:         r = rational(1)
  148:         with assert_raises(TypeError):
  149:             memoryview(r)
  150: 
  151:         # Check that we do not allow writeable buffer export
  152:         with pytest.raises(BufferError, match="scalar buffer is readonly"):
  153:             get_buffer_info(r, ["WRITABLE"])
