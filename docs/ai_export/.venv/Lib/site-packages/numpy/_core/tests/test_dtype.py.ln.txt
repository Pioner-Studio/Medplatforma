    1: import ctypes
    2: import gc
    3: import operator
    4: import pickle
    5: import random
    6: import sys
    7: import types
    8: from itertools import permutations
    9: from typing import Any
   10: 
   11: import hypothesis
   12: import pytest
   13: from hypothesis.extra import numpy as hynp
   14: from numpy._core._multiarray_tests import create_custom_field_dtype
   15: from numpy._core._rational_tests import rational
   16: 
   17: import numpy as np
   18: import numpy.dtypes
   19: from numpy.testing import (
   20:     HAS_REFCOUNT,
   21:     IS_PYSTON,
   22:     IS_WASM,
   23:     assert_,
   24:     assert_array_equal,
   25:     assert_equal,
   26:     assert_raises,
   27: )
   28: 
   29: 
   30: def assert_dtype_equal(a, b):
   31:     assert_equal(a, b)
   32:     assert_equal(hash(a), hash(b),
   33:                  "two equivalent types do not hash to the same value !")
   34: 
   35: def assert_dtype_not_equal(a, b):
   36:     assert_(a != b)
   37:     assert_(hash(a) != hash(b),
   38:             "two different types hash to the same value !")
   39: 
   40: class TestBuiltin:
   41:     @pytest.mark.parametrize('t', [int, float, complex, np.int32, str, object])
   42:     def test_run(self, t):
   43:         """Only test hash runs at all."""
   44:         dt = np.dtype(t)
   45:         hash(dt)
   46: 
   47:     @pytest.mark.parametrize('t', [int, float])
   48:     def test_dtype(self, t):
   49:         # Make sure equivalent byte order char hash the same (e.g. < and = on
   50:         # little endian)
   51:         dt = np.dtype(t)
   52:         dt2 = dt.newbyteorder("<")
   53:         dt3 = dt.newbyteorder(">")
   54:         if dt == dt2:
   55:             assert_(dt.byteorder != dt2.byteorder, "bogus test")
   56:             assert_dtype_equal(dt, dt2)
   57:         else:
   58:             assert_(dt.byteorder != dt3.byteorder, "bogus test")
   59:             assert_dtype_equal(dt, dt3)
   60: 
   61:     def test_equivalent_dtype_hashing(self):
   62:         # Make sure equivalent dtypes with different type num hash equal
   63:         uintp = np.dtype(np.uintp)
   64:         if uintp.itemsize == 4:
   65:             left = uintp
   66:             right = np.dtype(np.uint32)
   67:         else:
   68:             left = uintp
   69:             right = np.dtype(np.ulonglong)
   70:         assert_(left == right)
   71:         assert_(hash(left) == hash(right))
   72: 
   73:     def test_invalid_types(self):
   74:         # Make sure invalid type strings raise an error
   75: 
   76:         assert_raises(TypeError, np.dtype, 'O3')
   77:         assert_raises(TypeError, np.dtype, 'O5')
   78:         assert_raises(TypeError, np.dtype, 'O7')
   79:         assert_raises(TypeError, np.dtype, 'b3')
   80:         assert_raises(TypeError, np.dtype, 'h4')
   81:         assert_raises(TypeError, np.dtype, 'I5')
   82:         assert_raises(TypeError, np.dtype, 'e3')
   83:         assert_raises(TypeError, np.dtype, 'f5')
   84: 
   85:         if np.dtype('g').itemsize == 8 or np.dtype('g').itemsize == 16:
   86:             assert_raises(TypeError, np.dtype, 'g12')
   87:         elif np.dtype('g').itemsize == 12:
   88:             assert_raises(TypeError, np.dtype, 'g16')
   89: 
   90:         if np.dtype('l').itemsize == 8:
   91:             assert_raises(TypeError, np.dtype, 'l4')
   92:             assert_raises(TypeError, np.dtype, 'L4')
   93:         else:
   94:             assert_raises(TypeError, np.dtype, 'l8')
   95:             assert_raises(TypeError, np.dtype, 'L8')
   96: 
   97:         if np.dtype('q').itemsize == 8:
   98:             assert_raises(TypeError, np.dtype, 'q4')
   99:             assert_raises(TypeError, np.dtype, 'Q4')
  100:         else:
  101:             assert_raises(TypeError, np.dtype, 'q8')
  102:             assert_raises(TypeError, np.dtype, 'Q8')
  103: 
  104:         # Make sure negative-sized dtype raises an error
  105:         assert_raises(TypeError, np.dtype, 'S-1')
  106:         assert_raises(TypeError, np.dtype, 'U-1')
  107:         assert_raises(TypeError, np.dtype, 'V-1')
  108: 
  109:     def test_richcompare_invalid_dtype_equality(self):
  110:         # Make sure objects that cannot be converted to valid
  111:         # dtypes results in False/True when compared to valid dtypes.
  112:         # Here 7 cannot be converted to dtype. No exceptions should be raised
  113: 
  114:         assert not np.dtype(np.int32) == 7, "dtype richcompare failed for =="
  115:         assert np.dtype(np.int32) != 7, "dtype richcompare failed for !="
  116: 
  117:     @pytest.mark.parametrize(
  118:         'operation',
  119:         [operator.le, operator.lt, operator.ge, operator.gt])
  120:     def test_richcompare_invalid_dtype_comparison(self, operation):
  121:         # Make sure TypeError is raised for comparison operators
  122:         # for invalid dtypes. Here 7 is an invalid dtype.
  123: 
  124:         with pytest.raises(TypeError):
  125:             operation(np.dtype(np.int32), 7)
  126: 
  127:     @pytest.mark.parametrize("dtype",
  128:              ['Bool', 'Bytes0', 'Complex32', 'Complex64',
  129:               'Datetime64', 'Float16', 'Float32', 'Float64',
  130:               'Int8', 'Int16', 'Int32', 'Int64',
  131:               'Object0', 'Str0', 'Timedelta64',
  132:               'UInt8', 'UInt16', 'Uint32', 'UInt32',
  133:               'Uint64', 'UInt64', 'Void0',
  134:               "Float128", "Complex128"])
  135:     def test_numeric_style_types_are_invalid(self, dtype):
  136:         with assert_raises(TypeError):
  137:             np.dtype(dtype)
  138: 
  139:     def test_expired_dtypes_with_bad_bytesize(self):
  140:         match: str = r".*removed in NumPy 2.0.*"
  141:         with pytest.raises(TypeError, match=match):
  142:             np.dtype("int0")
  143:         with pytest.raises(TypeError, match=match):
  144:             np.dtype("uint0")
  145:         with pytest.raises(TypeError, match=match):
  146:             np.dtype("bool8")
  147:         with pytest.raises(TypeError, match=match):
  148:             np.dtype("bytes0")
  149:         with pytest.raises(TypeError, match=match):
  150:             np.dtype("str0")
  151:         with pytest.raises(TypeError, match=match):
  152:             np.dtype("object0")
  153:         with pytest.raises(TypeError, match=match):
  154:             np.dtype("void0")
  155: 
  156:     @pytest.mark.parametrize(
  157:         'value',
  158:         ['m8', 'M8', 'datetime64', 'timedelta64',
  159:          'i4, (2,3)f8, f4', 'S3, 3u8, (3,4)S10',
  160:          '>f', '<f', '=f', '|f',
  161:         ])
  162:     def test_dtype_bytes_str_equivalence(self, value):
  163:         bytes_value = value.encode('ascii')
  164:         from_bytes = np.dtype(bytes_value)
  165:         from_str = np.dtype(value)
  166:         assert_dtype_equal(from_bytes, from_str)
  167: 
  168:     def test_dtype_from_bytes(self):
  169:         # Empty bytes object
  170:         assert_raises(TypeError, np.dtype, b'')
  171:         # Byte order indicator, but no type
  172:         assert_raises(TypeError, np.dtype, b'|')
  173: 
  174:         # Single character with ordinal < NPY_NTYPES_LEGACY returns
  175:         # type by index into _builtin_descrs
  176:         assert_dtype_equal(np.dtype(bytes([0])), np.dtype('bool'))
  177:         assert_dtype_equal(np.dtype(bytes([17])), np.dtype(object))
  178: 
  179:         # Single character where value is a valid type code
  180:         assert_dtype_equal(np.dtype(b'f'), np.dtype('float32'))
  181: 
  182:         # Bytes with non-ascii values raise errors
  183:         assert_raises(TypeError, np.dtype, b'\xff')
  184:         assert_raises(TypeError, np.dtype, b's\xff')
  185: 
  186:     def test_bad_param(self):
  187:         # Can't give a size that's too small
  188:         assert_raises(ValueError, np.dtype,
  189:                         {'names': ['f0', 'f1'],
  190:                          'formats': ['i4', 'i1'],
  191:                          'offsets': [0, 4],
  192:                          'itemsize': 4})
  193:         # If alignment is enabled, the alignment (4) must divide the itemsize
  194:         assert_raises(ValueError, np.dtype,
  195:                         {'names': ['f0', 'f1'],
  196:                          'formats': ['i4', 'i1'],
  197:                          'offsets': [0, 4],
  198:                          'itemsize': 9}, align=True)
  199:         # If alignment is enabled, the individual fields must be aligned
  200:         assert_raises(ValueError, np.dtype,
  201:                         {'names': ['f0', 'f1'],
  202:                          'formats': ['i1', 'f4'],
  203:                          'offsets': [0, 2]}, align=True)
  204: 
  205:     def test_field_order_equality(self):
  206:         x = np.dtype({'names': ['A', 'B'],
  207:                       'formats': ['i4', 'f4'],
  208:                       'offsets': [0, 4]})
  209:         y = np.dtype({'names': ['B', 'A'],
  210:                       'formats': ['i4', 'f4'],
  211:                       'offsets': [4, 0]})
  212:         assert_equal(x == y, False)
  213:         # This is an safe cast (not equiv) due to the different names:
  214:         assert np.can_cast(x, y, casting="safe")
  215: 
  216:     @pytest.mark.parametrize(
  217:         ["type_char", "char_size", "scalar_type"],
  218:         [["U", 4, np.str_],
  219:          ["S", 1, np.bytes_]])
  220:     def test_create_string_dtypes_directly(
  221:             self, type_char, char_size, scalar_type):
  222:         dtype_class = type(np.dtype(type_char))
  223: 
  224:         dtype = dtype_class(8)
  225:         assert dtype.type is scalar_type
  226:         assert dtype.itemsize == 8 * char_size
  227: 
  228:     def test_create_invalid_string_errors(self):
  229:         one_too_big = np.iinfo(np.intc).max + 1
  230:         with pytest.raises(TypeError):
  231:             type(np.dtype("U"))(one_too_big // 4)
  232: 
  233:         with pytest.raises(TypeError):
  234:             # Code coverage for very large numbers:
  235:             type(np.dtype("U"))(np.iinfo(np.intp).max // 4 + 1)
  236: 
  237:         if one_too_big < sys.maxsize:
  238:             with pytest.raises(TypeError):
  239:                 type(np.dtype("S"))(one_too_big)
  240: 
  241:         with pytest.raises(ValueError):
  242:             type(np.dtype("U"))(-1)
  243: 
  244:         # OverflowError on 32 bit
  245:         with pytest.raises((TypeError, OverflowError)):
  246:             # see gh-26556
  247:             type(np.dtype("S"))(2**61)
  248: 
  249:         with pytest.raises(TypeError):
  250:             np.dtype("S1234hello")
  251: 
  252:     def test_leading_zero_parsing(self):
  253:         dt1 = np.dtype('S010')
  254:         dt2 = np.dtype('S10')
  255: 
  256:         assert dt1 == dt2
  257:         assert repr(dt1) == "dtype('S10')"
  258:         assert dt1.itemsize == 10
  259: 
  260: 
  261: class TestRecord:
  262:     def test_equivalent_record(self):
  263:         """Test whether equivalent record dtypes hash the same."""
  264:         a = np.dtype([('yo', int)])
  265:         b = np.dtype([('yo', int)])
  266:         assert_dtype_equal(a, b)
  267: 
  268:     def test_different_names(self):
  269:         # In theory, they may hash the same (collision) ?
  270:         a = np.dtype([('yo', int)])
  271:         b = np.dtype([('ye', int)])
  272:         assert_dtype_not_equal(a, b)
  273: 
  274:     def test_different_titles(self):
  275:         # In theory, they may hash the same (collision) ?
  276:         a = np.dtype({'names': ['r', 'b'],
  277:                       'formats': ['u1', 'u1'],
  278:                       'titles': ['Red pixel', 'Blue pixel']})
  279:         b = np.dtype({'names': ['r', 'b'],
  280:                       'formats': ['u1', 'u1'],
  281:                       'titles': ['RRed pixel', 'Blue pixel']})
  282:         assert_dtype_not_equal(a, b)
  283: 
  284:     @pytest.mark.skipif(not HAS_REFCOUNT, reason="Python lacks refcounts")
  285:     def test_refcount_dictionary_setting(self):
  286:         names = ["name1"]
  287:         formats = ["f8"]
  288:         titles = ["t1"]
  289:         offsets = [0]
  290:         d = {"names": names, "formats": formats, "titles": titles, "offsets": offsets}
  291:         refcounts = {k: sys.getrefcount(i) for k, i in d.items()}
  292:         np.dtype(d)
  293:         refcounts_new = {k: sys.getrefcount(i) for k, i in d.items()}
  294:         assert refcounts == refcounts_new
  295: 
  296:     def test_mutate(self):
  297:         # Mutating a dtype should reset the cached hash value.
  298:         # NOTE: Mutating should be deprecated, but new API added to replace it.
  299:         a = np.dtype([('yo', int)])
  300:         b = np.dtype([('yo', int)])
  301:         c = np.dtype([('ye', int)])
  302:         assert_dtype_equal(a, b)
  303:         assert_dtype_not_equal(a, c)
  304:         a.names = ['ye']
  305:         assert_dtype_equal(a, c)
  306:         assert_dtype_not_equal(a, b)
  307:         state = b.__reduce__()[2]
  308:         a.__setstate__(state)
  309:         assert_dtype_equal(a, b)
  310:         assert_dtype_not_equal(a, c)
  311: 
  312:     def test_init_simple_structured(self):
  313:         dt1 = np.dtype("i, i")
  314:         assert dt1.names == ("f0", "f1")
  315: 
  316:         dt2 = np.dtype("i,")
  317:         assert dt2.names == ("f0",)
  318: 
  319:     def test_mutate_error(self):
  320:         # NOTE: Mutating should be deprecated, but new API added to replace it.
  321:         a = np.dtype("i,i")
  322: 
  323:         with pytest.raises(ValueError, match="must replace all names at once"):
  324:             a.names = ["f0"]
  325: 
  326:         with pytest.raises(ValueError, match=".*and not string"):
  327:             a.names = ["f0", b"not a unicode name"]
  328: 
  329:     def test_not_lists(self):
  330:         """Test if an appropriate exception is raised when passing bad values to
  331:         the dtype constructor.
  332:         """
  333:         assert_raises(TypeError, np.dtype,
  334:                       {"names": {'A', 'B'}, "formats": ['f8', 'i4']})
  335:         assert_raises(TypeError, np.dtype,
  336:                       {"names": ['A', 'B'], "formats": {'f8', 'i4'}})
  337: 
  338:     def test_aligned_size(self):
  339:         # Check that structured dtypes get padded to an aligned size
  340:         dt = np.dtype('i4, i1', align=True)
  341:         assert_equal(dt.itemsize, 8)
  342:         dt = np.dtype([('f0', 'i4'), ('f1', 'i1')], align=True)
  343:         assert_equal(dt.itemsize, 8)
  344:         dt = np.dtype({'names': ['f0', 'f1'],
  345:                        'formats': ['i4', 'u1'],
  346:                        'offsets': [0, 4]}, align=True)
  347:         assert_equal(dt.itemsize, 8)
  348:         dt = np.dtype({'f0': ('i4', 0), 'f1': ('u1', 4)}, align=True)
  349:         assert_equal(dt.itemsize, 8)
  350:         # Nesting should preserve that alignment
  351:         dt1 = np.dtype([('f0', 'i4'),
  352:                        ('f1', [('f1', 'i1'), ('f2', 'i4'), ('f3', 'i1')]),
  353:                        ('f2', 'i1')], align=True)
  354:         assert_equal(dt1.itemsize, 20)
  355:         dt2 = np.dtype({'names': ['f0', 'f1', 'f2'],
  356:                        'formats': ['i4',
  357:                                   [('f1', 'i1'), ('f2', 'i4'), ('f3', 'i1')],
  358:                                   'i1'],
  359:                        'offsets': [0, 4, 16]}, align=True)
  360:         assert_equal(dt2.itemsize, 20)
  361:         dt3 = np.dtype({'f0': ('i4', 0),
  362:                        'f1': ([('f1', 'i1'), ('f2', 'i4'), ('f3', 'i1')], 4),
  363:                        'f2': ('i1', 16)}, align=True)
  364:         assert_equal(dt3.itemsize, 20)
  365:         assert_equal(dt1, dt2)
  366:         assert_equal(dt2, dt3)
  367:         # Nesting should preserve packing
  368:         dt1 = np.dtype([('f0', 'i4'),
  369:                        ('f1', [('f1', 'i1'), ('f2', 'i4'), ('f3', 'i1')]),
  370:                        ('f2', 'i1')], align=False)
  371:         assert_equal(dt1.itemsize, 11)
  372:         dt2 = np.dtype({'names': ['f0', 'f1', 'f2'],
  373:                        'formats': ['i4',
  374:                                   [('f1', 'i1'), ('f2', 'i4'), ('f3', 'i1')],
  375:                                   'i1'],
  376:                        'offsets': [0, 4, 10]}, align=False)
  377:         assert_equal(dt2.itemsize, 11)
  378:         dt3 = np.dtype({'f0': ('i4', 0),
  379:                        'f1': ([('f1', 'i1'), ('f2', 'i4'), ('f3', 'i1')], 4),
  380:                        'f2': ('i1', 10)}, align=False)
  381:         assert_equal(dt3.itemsize, 11)
  382:         assert_equal(dt1, dt2)
  383:         assert_equal(dt2, dt3)
  384:         # Array of subtype should preserve alignment
  385:         dt1 = np.dtype([('a', '|i1'),
  386:                         ('b', [('f0', '<i2'),
  387:                         ('f1', '<f4')], 2)], align=True)
  388:         assert_equal(dt1.descr, [('a', '|i1'), ('', '|V3'),
  389:                                  ('b', [('f0', '<i2'), ('', '|V2'),
  390:                                  ('f1', '<f4')], (2,))])
  391: 
  392:     def test_empty_struct_alignment(self):
  393:         # Empty dtypes should have an alignment of 1
  394:         dt = np.dtype([], align=True)
  395:         assert_equal(dt.alignment, 1)
  396:         dt = np.dtype([('f0', [])], align=True)
  397:         assert_equal(dt.alignment, 1)
  398:         dt = np.dtype({'names': [],
  399:                        'formats': [],
  400:                        'offsets': []}, align=True)
  401:         assert_equal(dt.alignment, 1)
  402:         dt = np.dtype({'names': ['f0'],
  403:                        'formats': [[]],
  404:                        'offsets': [0]}, align=True)
  405:         assert_equal(dt.alignment, 1)
  406: 
  407:     def test_union_struct(self):
  408:         # Should be able to create union dtypes
  409:         dt = np.dtype({'names': ['f0', 'f1', 'f2'], 'formats': ['<u4', '<u2', '<u2'],
  410:                         'offsets': [0, 0, 2]}, align=True)
  411:         assert_equal(dt.itemsize, 4)
  412:         a = np.array([3], dtype='<u4').view(dt)
  413:         a['f1'] = 10
  414:         a['f2'] = 36
  415:         assert_equal(a['f0'], 10 + 36 * 256 * 256)
  416:         # Should be able to specify fields out of order
  417:         dt = np.dtype({'names': ['f0', 'f1', 'f2'], 'formats': ['<u4', '<u2', '<u2'],
  418:                         'offsets': [4, 0, 2]}, align=True)
  419:         assert_equal(dt.itemsize, 8)
  420:         # field name should not matter: assignment is by position
  421:         dt2 = np.dtype({'names': ['f2', 'f0', 'f1'],
  422:                         'formats': ['<u4', '<u2', '<u2'],
  423:                         'offsets': [4, 0, 2]}, align=True)
  424:         vals = [(0, 1, 2), (3, 2**15 - 1, 4)]
  425:         vals2 = [(0, 1, 2), (3, 2**15 - 1, 4)]
  426:         a = np.array(vals, dt)
  427:         b = np.array(vals2, dt2)
  428:         assert_equal(a.astype(dt2), b)
  429:         assert_equal(b.astype(dt), a)
  430:         assert_equal(a.view(dt2), b)
  431:         assert_equal(b.view(dt), a)
  432:         # Should not be able to overlap objects with other types
  433:         assert_raises(TypeError, np.dtype,
  434:                 {'names': ['f0', 'f1'],
  435:                  'formats': ['O', 'i1'],
  436:                  'offsets': [0, 2]})
  437:         assert_raises(TypeError, np.dtype,
  438:                 {'names': ['f0', 'f1'],
  439:                  'formats': ['i4', 'O'],
  440:                  'offsets': [0, 3]})
  441:         assert_raises(TypeError, np.dtype,
  442:                 {'names': ['f0', 'f1'],
  443:                  'formats': [[('a', 'O')], 'i1'],
  444:                  'offsets': [0, 2]})
  445:         assert_raises(TypeError, np.dtype,
  446:                 {'names': ['f0', 'f1'],
  447:                  'formats': ['i4', [('a', 'O')]],
  448:                  'offsets': [0, 3]})
  449:         # Out of order should still be ok, however
  450:         dt = np.dtype({'names': ['f0', 'f1'],
  451:                        'formats': ['i1', 'O'],
  452:                        'offsets': [np.dtype('intp').itemsize, 0]})
  453: 
  454:     @pytest.mark.parametrize(["obj", "dtype", "expected"],
  455:         [([], ("2f4"), np.empty((0, 2), dtype="f4")),
  456:          (3, "(3,)f4", [3, 3, 3]),
  457:          (np.float64(2), "(2,)f4", [2, 2]),
  458:          ([((0, 1), (1, 2)), ((2,),)], '(2,2)f4', None),
  459:          (["1", "2"], "2i", None)])
  460:     def test_subarray_list(self, obj, dtype, expected):
  461:         dtype = np.dtype(dtype)
  462:         res = np.array(obj, dtype=dtype)
  463: 
  464:         if expected is None:
  465:             # iterate the 1-d list to fill the array
  466:             expected = np.empty(len(obj), dtype=dtype)
  467:             for i in range(len(expected)):
  468:                 expected[i] = obj[i]
  469: 
  470:         assert_array_equal(res, expected)
  471: 
  472:     def test_parenthesized_single_number(self):
  473:         with pytest.raises(TypeError, match="not understood"):
  474:             np.dtype("(2)f4")
  475: 
  476:         # Deprecation also tested in
  477:         # test_deprecations.py::TestDeprecatedDTypeParenthesizedRepeatCount
  478:         # Left here to allow easy conversion to an exception check.
  479:         with pytest.warns(DeprecationWarning,
  480:                           match="parenthesized single number"):
  481:             np.dtype("(2)f4,")
  482: 
  483:     def test_comma_datetime(self):
  484:         dt = np.dtype('M8[D],datetime64[Y],i8')
  485:         assert_equal(dt, np.dtype([('f0', 'M8[D]'),
  486:                                    ('f1', 'datetime64[Y]'),
  487:                                    ('f2', 'i8')]))
  488: 
  489:     def test_from_dictproxy(self):
  490:         # Tests for PR #5920
  491:         dt = np.dtype({'names': ['a', 'b'], 'formats': ['i4', 'f4']})
  492:         assert_dtype_equal(dt, np.dtype(dt.fields))
  493:         dt2 = np.dtype((np.void, dt.fields))
  494:         assert_equal(dt2.fields, dt.fields)
  495: 
  496:     def test_from_dict_with_zero_width_field(self):
  497:         # Regression test for #6430 / #2196
  498:         dt = np.dtype([('val1', np.float32, (0,)), ('val2', int)])
  499:         dt2 = np.dtype({'names': ['val1', 'val2'],
  500:                         'formats': [(np.float32, (0,)), int]})
  501: 
  502:         assert_dtype_equal(dt, dt2)
  503:         assert_equal(dt.fields['val1'][0].itemsize, 0)
  504:         assert_equal(dt.itemsize, dt.fields['val2'][0].itemsize)
  505: 
  506:     def test_bool_commastring(self):
  507:         d = np.dtype('?,?,?')  # raises?
  508:         assert_equal(len(d.names), 3)
  509:         for n in d.names:
  510:             assert_equal(d.fields[n][0], np.dtype('?'))
  511: 
  512:     def test_nonint_offsets(self):
  513:         # gh-8059
  514:         def make_dtype(off):
  515:             return np.dtype({'names': ['A'], 'formats': ['i4'],
  516:                              'offsets': [off]})
  517: 
  518:         assert_raises(TypeError, make_dtype, 'ASD')
  519:         assert_raises(OverflowError, make_dtype, 2**70)
  520:         assert_raises(TypeError, make_dtype, 2.3)
  521:         assert_raises(ValueError, make_dtype, -10)
  522: 
  523:         # no errors here:
  524:         dt = make_dtype(np.uint32(0))
  525:         np.zeros(1, dtype=dt)[0].item()
  526: 
  527:     def test_fields_by_index(self):
  528:         dt = np.dtype([('a', np.int8), ('b', np.float32, 3)])
  529:         assert_dtype_equal(dt[0], np.dtype(np.int8))
  530:         assert_dtype_equal(dt[1], np.dtype((np.float32, 3)))
  531:         assert_dtype_equal(dt[-1], dt[1])
  532:         assert_dtype_equal(dt[-2], dt[0])
  533:         assert_raises(IndexError, lambda: dt[-3])
  534: 
  535:         assert_raises(TypeError, operator.getitem, dt, 3.0)
  536: 
  537:         assert_equal(dt[1], dt[np.int8(1)])
  538: 
  539:     @pytest.mark.parametrize('align_flag', [False, True])
  540:     def test_multifield_index(self, align_flag):
  541:         # indexing with a list produces subfields
  542:         # the align flag should be preserved
  543:         dt = np.dtype([
  544:             (('title', 'col1'), '<U20'), ('A', '<f8'), ('B', '<f8')
  545:         ], align=align_flag)
  546: 
  547:         dt_sub = dt[['B', 'col1']]
  548:         assert_equal(
  549:             dt_sub,
  550:             np.dtype({
  551:                 'names': ['B', 'col1'],
  552:                 'formats': ['<f8', '<U20'],
  553:                 'offsets': [88, 0],
  554:                 'titles': [None, 'title'],
  555:                 'itemsize': 96
  556:             })
  557:         )
  558:         assert_equal(dt_sub.isalignedstruct, align_flag)
  559: 
  560:         dt_sub = dt[['B']]
  561:         assert_equal(
  562:             dt_sub,
  563:             np.dtype({
  564:                 'names': ['B'],
  565:                 'formats': ['<f8'],
  566:                 'offsets': [88],
  567:                 'itemsize': 96
  568:             })
  569:         )
  570:         assert_equal(dt_sub.isalignedstruct, align_flag)
  571: 
  572:         dt_sub = dt[[]]
  573:         assert_equal(
  574:             dt_sub,
  575:             np.dtype({
  576:                 'names': [],
  577:                 'formats': [],
  578:                 'offsets': [],
  579:                 'itemsize': 96
  580:             })
  581:         )
  582:         assert_equal(dt_sub.isalignedstruct, align_flag)
  583: 
  584:         assert_raises(TypeError, operator.getitem, dt, ())
  585:         assert_raises(TypeError, operator.getitem, dt, [1, 2, 3])
  586:         assert_raises(TypeError, operator.getitem, dt, ['col1', 2])
  587:         assert_raises(KeyError, operator.getitem, dt, ['fake'])
  588:         assert_raises(KeyError, operator.getitem, dt, ['title'])
  589:         assert_raises(ValueError, operator.getitem, dt, ['col1', 'col1'])
  590: 
  591:     def test_partial_dict(self):
  592:         # 'names' is missing
  593:         assert_raises(ValueError, np.dtype,
  594:                 {'formats': ['i4', 'i4'], 'f0': ('i4', 0), 'f1': ('i4', 4)})
  595: 
  596:     def test_fieldless_views(self):
  597:         a = np.zeros(2, dtype={'names': [], 'formats': [], 'offsets': [],
  598:                                'itemsize': 8})
  599:         assert_raises(ValueError, a.view, np.dtype([]))
  600: 
  601:         d = np.dtype((np.dtype([]), 10))
  602:         assert_equal(d.shape, (10,))
  603:         assert_equal(d.itemsize, 0)
  604:         assert_equal(d.base, np.dtype([]))
  605: 
  606:         arr = np.fromiter((() for i in range(10)), [])
  607:         assert_equal(arr.dtype, np.dtype([]))
  608:         assert_raises(ValueError, np.frombuffer, b'', dtype=[])
  609:         assert_equal(np.frombuffer(b'', dtype=[], count=2),
  610:                      np.empty(2, dtype=[]))
  611: 
  612:         assert_raises(ValueError, np.dtype, ([], 'f8'))
  613:         assert_raises(ValueError, np.zeros(1, dtype='i4').view, [])
  614: 
  615:         assert_equal(np.zeros(2, dtype=[]) == np.zeros(2, dtype=[]),
  616:                      np.ones(2, dtype=bool))
  617: 
  618:         assert_equal(np.zeros((1, 2), dtype=[]) == a,
  619:                      np.ones((1, 2), dtype=bool))
  620: 
  621:     def test_nonstructured_with_object(self):
  622:         # See gh-23277, the dtype here thinks it contain objects, if the
  623:         # assert about that fails, the test becomes meaningless (which is OK)
  624:         arr = np.recarray((0,), dtype="O")
  625:         assert arr.dtype.names is None  # no fields
  626:         assert arr.dtype.hasobject  # but claims to contain objects
  627:         del arr  # the deletion failed previously.
  628: 
  629: 
  630: class TestSubarray:
  631:     def test_single_subarray(self):
  632:         a = np.dtype((int, (2)))
  633:         b = np.dtype((int, (2,)))
  634:         assert_dtype_equal(a, b)
  635: 
  636:         assert_equal(type(a.subdtype[1]), tuple)
  637:         assert_equal(type(b.subdtype[1]), tuple)
  638: 
  639:     def test_equivalent_record(self):
  640:         """Test whether equivalent subarray dtypes hash the same."""
  641:         a = np.dtype((int, (2, 3)))
  642:         b = np.dtype((int, (2, 3)))
  643:         assert_dtype_equal(a, b)
  644: 
  645:     def test_nonequivalent_record(self):
  646:         """Test whether different subarray dtypes hash differently."""
  647:         a = np.dtype((int, (2, 3)))
  648:         b = np.dtype((int, (3, 2)))
  649:         assert_dtype_not_equal(a, b)
  650: 
  651:         a = np.dtype((int, (2, 3)))
  652:         b = np.dtype((int, (2, 2)))
  653:         assert_dtype_not_equal(a, b)
  654: 
  655:         a = np.dtype((int, (1, 2, 3)))
  656:         b = np.dtype((int, (1, 2)))
  657:         assert_dtype_not_equal(a, b)
  658: 
  659:     def test_shape_equal(self):
  660:         """Test some data types that are equal"""
  661:         assert_dtype_equal(np.dtype('f8'), np.dtype(('f8', ())))
  662:         assert_dtype_equal(np.dtype('(1,)f8'), np.dtype(('f8', 1)))
  663:         assert np.dtype(('f8', 1)).shape == (1,)
  664:         assert_dtype_equal(np.dtype((int, 2)), np.dtype((int, (2,))))
  665:         assert_dtype_equal(np.dtype(('<f4', (3, 2))), np.dtype(('<f4', (3, 2))))
  666:         d = ([('a', 'f4', (1, 2)), ('b', 'f8', (3, 1))], (3, 2))
  667:         assert_dtype_equal(np.dtype(d), np.dtype(d))
  668: 
  669:     def test_shape_simple(self):
  670:         """Test some simple cases that shouldn't be equal"""
  671:         assert_dtype_not_equal(np.dtype('f8'), np.dtype(('f8', (1,))))
  672:         assert_dtype_not_equal(np.dtype(('f8', (1,))), np.dtype(('f8', (1, 1))))
  673:         assert_dtype_not_equal(np.dtype(('f4', (3, 2))), np.dtype(('f4', (2, 3))))
  674: 
  675:     def test_shape_monster(self):
  676:         """Test some more complicated cases that shouldn't be equal"""
  677:         assert_dtype_not_equal(
  678:             np.dtype(([('a', 'f4', (2, 1)), ('b', 'f8', (1, 3))], (2, 2))),
  679:             np.dtype(([('a', 'f4', (1, 2)), ('b', 'f8', (1, 3))], (2, 2))))
  680:         assert_dtype_not_equal(
  681:             np.dtype(([('a', 'f4', (2, 1)), ('b', 'f8', (1, 3))], (2, 2))),
  682:             np.dtype(([('a', 'f4', (2, 1)), ('b', 'i8', (1, 3))], (2, 2))))
  683:         assert_dtype_not_equal(
  684:             np.dtype(([('a', 'f4', (2, 1)), ('b', 'f8', (1, 3))], (2, 2))),
  685:             np.dtype(([('e', 'f8', (1, 3)), ('d', 'f4', (2, 1))], (2, 2))))
  686:         assert_dtype_not_equal(
  687:             np.dtype(([('a', [('a', 'i4', 6)], (2, 1)), ('b', 'f8', (1, 3))], (2, 2))),
  688:             np.dtype(([('a', [('a', 'u4', 6)], (2, 1)), ('b', 'f8', (1, 3))], (2, 2))))
  689: 
  690:     def test_shape_sequence(self):
  691:         # Any sequence of integers should work as shape, but the result
  692:         # should be a tuple (immutable) of base type integers.
  693:         a = np.array([1, 2, 3], dtype=np.int16)
  694:         l = [1, 2, 3]
  695:         # Array gets converted
  696:         dt = np.dtype([('a', 'f4', a)])
  697:         assert_(isinstance(dt['a'].shape, tuple))
  698:         assert_(isinstance(dt['a'].shape[0], int))
  699:         # List gets converted
  700:         dt = np.dtype([('a', 'f4', l)])
  701:         assert_(isinstance(dt['a'].shape, tuple))
  702:         #
  703: 
  704:         class IntLike:
  705:             def __index__(self):
  706:                 return 3
  707: 
  708:             def __int__(self):
  709:                 # (a PyNumber_Check fails without __int__)
  710:                 return 3
  711: 
  712:         dt = np.dtype([('a', 'f4', IntLike())])
  713:         assert_(isinstance(dt['a'].shape, tuple))
  714:         assert_(isinstance(dt['a'].shape[0], int))
  715:         dt = np.dtype([('a', 'f4', (IntLike(),))])
  716:         assert_(isinstance(dt['a'].shape, tuple))
  717:         assert_(isinstance(dt['a'].shape[0], int))
  718: 
  719:     def test_shape_matches_ndim(self):
  720:         dt = np.dtype([('a', 'f4', ())])
  721:         assert_equal(dt['a'].shape, ())
  722:         assert_equal(dt['a'].ndim, 0)
  723: 
  724:         dt = np.dtype([('a', 'f4')])
  725:         assert_equal(dt['a'].shape, ())
  726:         assert_equal(dt['a'].ndim, 0)
  727: 
  728:         dt = np.dtype([('a', 'f4', 4)])
  729:         assert_equal(dt['a'].shape, (4,))
  730:         assert_equal(dt['a'].ndim, 1)
  731: 
  732:         dt = np.dtype([('a', 'f4', (1, 2, 3))])
  733:         assert_equal(dt['a'].shape, (1, 2, 3))
  734:         assert_equal(dt['a'].ndim, 3)
  735: 
  736:     def test_shape_invalid(self):
  737:         # Check that the shape is valid.
  738:         max_int = np.iinfo(np.intc).max
  739:         max_intp = np.iinfo(np.intp).max
  740:         # Too large values (the datatype is part of this)
  741:         assert_raises(ValueError, np.dtype, [('a', 'f4', max_int // 4 + 1)])
  742:         assert_raises(ValueError, np.dtype, [('a', 'f4', max_int + 1)])
  743:         assert_raises(ValueError, np.dtype, [('a', 'f4', (max_int, 2))])
  744:         # Takes a different code path (fails earlier:
  745:         assert_raises(ValueError, np.dtype, [('a', 'f4', max_intp + 1)])
  746:         # Negative values
  747:         assert_raises(ValueError, np.dtype, [('a', 'f4', -1)])
  748:         assert_raises(ValueError, np.dtype, [('a', 'f4', (-1, -1))])
  749: 
  750:     def test_alignment(self):
  751:         # Check that subarrays are aligned
  752:         t1 = np.dtype('(1,)i4', align=True)
  753:         t2 = np.dtype('2i4', align=True)
  754:         assert_equal(t1.alignment, t2.alignment)
  755: 
  756:     def test_aligned_empty(self):
  757:         # Mainly regression test for gh-19696: construction failed completely
  758:         dt = np.dtype([], align=True)
  759:         assert dt == np.dtype([])
  760:         dt = np.dtype({"names": [], "formats": [], "itemsize": 0}, align=True)
  761:         assert dt == np.dtype([])
  762: 
  763:     def test_subarray_base_item(self):
  764:         arr = np.ones(3, dtype=[("f", "i", 3)])
  765:         # Extracting the field "absorbs" the subarray into a view:
  766:         assert arr["f"].base is arr
  767:         # Extract the structured item, and then check the tuple component:
  768:         item = arr.item(0)
  769:         assert type(item) is tuple and len(item) == 1
  770:         assert item[0].base is arr
  771: 
  772:     def test_subarray_cast_copies(self):
  773:         # Older versions of NumPy did NOT copy, but they got the ownership
  774:         # wrong (not actually knowing the correct base!).  Versions since 1.21
  775:         # (I think) crashed fairly reliable.  This defines the correct behavior
  776:         # as a copy.  Keeping the ownership would be possible (but harder)
  777:         arr = np.ones(3, dtype=[("f", "i", 3)])
  778:         cast = arr.astype(object)
  779:         for fields in cast:
  780:             assert type(fields) == tuple and len(fields) == 1
  781:             subarr = fields[0]
  782:             assert subarr.base is None
  783:             assert subarr.flags.owndata
  784: 
  785: 
  786: def iter_struct_object_dtypes():
  787:     """
  788:     Iterates over a few complex dtypes and object pattern which
  789:     fill the array with a given object (defaults to a singleton).
  790: 
  791:     Yields
  792:     ------
  793:     dtype : dtype
  794:     pattern : tuple
  795:         Structured tuple for use with `np.array`.
  796:     count : int
  797:         Number of objects stored in the dtype.
  798:     singleton : object
  799:         A singleton object. The returned pattern is constructed so that
  800:         all objects inside the datatype are set to the singleton.
  801:     """
  802:     obj = object()
  803: 
  804:     dt = np.dtype([('b', 'O', (2, 3))])
  805:     p = ([[obj] * 3] * 2,)
  806:     yield pytest.param(dt, p, 6, obj, id="<subarray>")
  807: 
  808:     dt = np.dtype([('a', 'i4'), ('b', 'O', (2, 3))])
  809:     p = (0, [[obj] * 3] * 2)
  810:     yield pytest.param(dt, p, 6, obj, id="<subarray in field>")
  811: 
  812:     dt = np.dtype([('a', 'i4'),
  813:                    ('b', [('ba', 'O'), ('bb', 'i1')], (2, 3))])
  814:     p = (0, [[(obj, 0)] * 3] * 2)
  815:     yield pytest.param(dt, p, 6, obj, id="<structured subarray 1>")
  816: 
  817:     dt = np.dtype([('a', 'i4'),
  818:                    ('b', [('ba', 'O'), ('bb', 'O')], (2, 3))])
  819:     p = (0, [[(obj, obj)] * 3] * 2)
  820:     yield pytest.param(dt, p, 12, obj, id="<structured subarray 2>")
  821: 
  822: 
  823: @pytest.mark.skipif(
  824:     sys.version_info >= (3, 12),
  825:     reason="Python 3.12 has immortal refcounts, this test will no longer "
  826:            "work. See gh-23986"
  827: )
  828: @pytest.mark.skipif(not HAS_REFCOUNT, reason="Python lacks refcounts")
  829: class TestStructuredObjectRefcounting:
  830:     """These tests cover various uses of complicated structured types which
  831:     include objects and thus require reference counting.
  832:     """
  833:     @pytest.mark.parametrize(['dt', 'pat', 'count', 'singleton'],
  834:                              iter_struct_object_dtypes())
  835:     @pytest.mark.parametrize(["creation_func", "creation_obj"], [
  836:         pytest.param(np.empty, None,
  837:              # None is probably used for too many things
  838:              marks=pytest.mark.skip("unreliable due to python's behaviour")),
  839:         (np.ones, 1),
  840:         (np.zeros, 0)])
  841:     def test_structured_object_create_delete(self, dt, pat, count, singleton,
  842:                                              creation_func, creation_obj):
  843:         """Structured object reference counting in creation and deletion"""
  844:         # The test assumes that 0, 1, and None are singletons.
  845:         gc.collect()
  846:         before = sys.getrefcount(creation_obj)
  847:         arr = creation_func(3, dt)
  848: 
  849:         now = sys.getrefcount(creation_obj)
  850:         assert now - before == count * 3
  851:         del arr
  852:         now = sys.getrefcount(creation_obj)
  853:         assert now == before
  854: 
  855:     @pytest.mark.parametrize(['dt', 'pat', 'count', 'singleton'],
  856:                              iter_struct_object_dtypes())
  857:     def test_structured_object_item_setting(self, dt, pat, count, singleton):
  858:         """Structured object reference counting for simple item setting"""
  859:         one = 1
  860: 
  861:         gc.collect()
  862:         before = sys.getrefcount(singleton)
  863:         arr = np.array([pat] * 3, dt)
  864:         assert sys.getrefcount(singleton) - before == count * 3
  865:         # Fill with `1` and check that it was replaced correctly:
  866:         before2 = sys.getrefcount(one)
  867:         arr[...] = one
  868:         after2 = sys.getrefcount(one)
  869:         assert after2 - before2 == count * 3
  870:         del arr
  871:         gc.collect()
  872:         assert sys.getrefcount(one) == before2
  873:         assert sys.getrefcount(singleton) == before
  874: 
  875:     @pytest.mark.parametrize(['dt', 'pat', 'count', 'singleton'],
  876:                              iter_struct_object_dtypes())
  877:     @pytest.mark.parametrize(
  878:         ['shape', 'index', 'items_changed'],
  879:         [((3,), ([0, 2],), 2),
  880:          ((3, 2), ([0, 2], slice(None)), 4),
  881:          ((3, 2), ([0, 2], [1]), 2),
  882:          ((3,), ([True, False, True]), 2)])
  883:     def test_structured_object_indexing(self, shape, index, items_changed,
  884:                                         dt, pat, count, singleton):
  885:         """Structured object reference counting for advanced indexing."""
  886:         # Use two small negative values (should be singletons, but less likely
  887:         # to run into race-conditions).  This failed in some threaded envs
  888:         # When using 0 and 1.  If it fails again, should remove all explicit
  889:         # checks, and rely on `pytest-leaks` reference count checker only.
  890:         val0 = -4
  891:         val1 = -5
  892: 
  893:         arr = np.full(shape, val0, dt)
  894: 
  895:         gc.collect()
  896:         before_val0 = sys.getrefcount(val0)
  897:         before_val1 = sys.getrefcount(val1)
  898:         # Test item getting:
  899:         part = arr[index]
  900:         after_val0 = sys.getrefcount(val0)
  901:         assert after_val0 - before_val0 == count * items_changed
  902:         del part
  903:         # Test item setting:
  904:         arr[index] = val1
  905:         gc.collect()
  906:         after_val0 = sys.getrefcount(val0)
  907:         after_val1 = sys.getrefcount(val1)
  908:         assert before_val0 - after_val0 == count * items_changed
  909:         assert after_val1 - before_val1 == count * items_changed
  910: 
  911:     @pytest.mark.parametrize(['dt', 'pat', 'count', 'singleton'],
  912:                              iter_struct_object_dtypes())
  913:     def test_structured_object_take_and_repeat(self, dt, pat, count, singleton):
  914:         """Structured object reference counting for specialized functions.
  915:         The older functions such as take and repeat use different code paths
  916:         then item setting (when writing this).
  917:         """
  918:         indices = [0, 1]
  919: 
  920:         arr = np.array([pat] * 3, dt)
  921:         gc.collect()
  922:         before = sys.getrefcount(singleton)
  923:         res = arr.take(indices)
  924:         after = sys.getrefcount(singleton)
  925:         assert after - before == count * 2
  926:         new = res.repeat(10)
  927:         gc.collect()
  928:         after_repeat = sys.getrefcount(singleton)
  929:         assert after_repeat - after == count * 2 * 10
  930: 
  931: 
  932: class TestStructuredDtypeSparseFields:
  933:     """Tests subarray fields which contain sparse dtypes so that
  934:     not all memory is used by the dtype work. Such dtype's should
  935:     leave the underlying memory unchanged.
  936:     """
  937:     dtype = np.dtype([('a', {'names': ['aa', 'ab'], 'formats': ['f', 'f'],
  938:                              'offsets': [0, 4]}, (2, 3))])
  939:     sparse_dtype = np.dtype([('a', {'names': ['ab'], 'formats': ['f'],
  940:                                     'offsets': [4]}, (2, 3))])
  941: 
  942:     def test_sparse_field_assignment(self):
  943:         arr = np.zeros(3, self.dtype)
  944:         sparse_arr = arr.view(self.sparse_dtype)
  945: 
  946:         sparse_arr[...] = np.finfo(np.float32).max
  947:         # dtype is reduced when accessing the field, so shape is (3, 2, 3):
  948:         assert_array_equal(arr["a"]["aa"], np.zeros((3, 2, 3)))
  949: 
  950:     def test_sparse_field_assignment_fancy(self):
  951:         # Fancy assignment goes to the copyswap function for complex types:
  952:         arr = np.zeros(3, self.dtype)
  953:         sparse_arr = arr.view(self.sparse_dtype)
  954: 
  955:         sparse_arr[[0, 1, 2]] = np.finfo(np.float32).max
  956:         # dtype is reduced when accessing the field, so shape is (3, 2, 3):
  957:         assert_array_equal(arr["a"]["aa"], np.zeros((3, 2, 3)))
  958: 
  959: 
  960: class TestMonsterType:
  961:     """Test deeply nested subtypes."""
  962: 
  963:     def test1(self):
  964:         simple1 = np.dtype({'names': ['r', 'b'], 'formats': ['u1', 'u1'],
  965:             'titles': ['Red pixel', 'Blue pixel']})
  966:         a = np.dtype([('yo', int), ('ye', simple1),
  967:             ('yi', np.dtype((int, (3, 2))))])
  968:         b = np.dtype([('yo', int), ('ye', simple1),
  969:             ('yi', np.dtype((int, (3, 2))))])
  970:         assert_dtype_equal(a, b)
  971: 
  972:         c = np.dtype([('yo', int), ('ye', simple1),
  973:             ('yi', np.dtype((a, (3, 2))))])
  974:         d = np.dtype([('yo', int), ('ye', simple1),
  975:             ('yi', np.dtype((a, (3, 2))))])
  976:         assert_dtype_equal(c, d)
  977: 
  978:     @pytest.mark.skipif(IS_PYSTON, reason="Pyston disables recursion checking")
  979:     @pytest.mark.skipif(IS_WASM, reason="Pyodide/WASM has limited stack size")
  980:     def test_list_recursion(self):
  981:         l = []
  982:         l.append(('f', l))
  983:         with pytest.raises(RecursionError):
  984:             np.dtype(l)
  985: 
  986:     @pytest.mark.skipif(IS_PYSTON, reason="Pyston disables recursion checking")
  987:     @pytest.mark.skipif(IS_WASM, reason="Pyodide/WASM has limited stack size")
  988:     def test_tuple_recursion(self):
  989:         d = np.int32
  990:         for i in range(100000):
  991:             d = (d, (1,))
  992:         with pytest.raises(RecursionError):
  993:             np.dtype(d)
  994: 
  995:     @pytest.mark.skipif(IS_PYSTON, reason="Pyston disables recursion checking")
  996:     @pytest.mark.skipif(IS_WASM, reason="Pyodide/WASM has limited stack size")
  997:     def test_dict_recursion(self):
  998:         d = {"names": ['self'], "formats": [None], "offsets": [0]}
  999:         d['formats'][0] = d
 1000:         with pytest.raises(RecursionError):
 1001:             np.dtype(d)
 1002: 
 1003: 
 1004: class TestMetadata:
 1005:     def test_no_metadata(self):
 1006:         d = np.dtype(int)
 1007:         assert_(d.metadata is None)
 1008: 
 1009:     def test_metadata_takes_dict(self):
 1010:         d = np.dtype(int, metadata={'datum': 1})
 1011:         assert_(d.metadata == {'datum': 1})
 1012: 
 1013:     def test_metadata_rejects_nondict(self):
 1014:         assert_raises(TypeError, np.dtype, int, metadata='datum')
 1015:         assert_raises(TypeError, np.dtype, int, metadata=1)
 1016:         assert_raises(TypeError, np.dtype, int, metadata=None)
 1017: 
 1018:     def test_nested_metadata(self):
 1019:         d = np.dtype([('a', np.dtype(int, metadata={'datum': 1}))])
 1020:         assert_(d['a'].metadata == {'datum': 1})
 1021: 
 1022:     def test_base_metadata_copied(self):
 1023:         d = np.dtype((np.void, np.dtype('i4,i4', metadata={'datum': 1})))
 1024:         assert_(d.metadata == {'datum': 1})
 1025: 
 1026: class TestString:
 1027:     def test_complex_dtype_str(self):
 1028:         dt = np.dtype([('top', [('tiles', ('>f4', (64, 64)), (1,)),
 1029:                                 ('rtile', '>f4', (64, 36))], (3,)),
 1030:                        ('bottom', [('bleft', ('>f4', (8, 64)), (1,)),
 1031:                                    ('bright', '>f4', (8, 36))])])
 1032:         assert_equal(str(dt),
 1033:                      "[('top', [('tiles', ('>f4', (64, 64)), (1,)), "
 1034:                      "('rtile', '>f4', (64, 36))], (3,)), "
 1035:                      "('bottom', [('bleft', ('>f4', (8, 64)), (1,)), "
 1036:                      "('bright', '>f4', (8, 36))])]")
 1037: 
 1038:         # If the sticky aligned flag is set to True, it makes the
 1039:         # str() function use a dict representation with an 'aligned' flag
 1040:         dt = np.dtype([('top', [('tiles', ('>f4', (64, 64)), (1,)),
 1041:                                 ('rtile', '>f4', (64, 36))],
 1042:                                 (3,)),
 1043:                        ('bottom', [('bleft', ('>f4', (8, 64)), (1,)),
 1044:                                    ('bright', '>f4', (8, 36))])],
 1045:                        align=True)
 1046:         assert_equal(str(dt),
 1047:                     "{'names': ['top', 'bottom'],"
 1048:                     " 'formats': [([('tiles', ('>f4', (64, 64)), (1,)), "
 1049:                                    "('rtile', '>f4', (64, 36))], (3,)), "
 1050:                                   "[('bleft', ('>f4', (8, 64)), (1,)), "
 1051:                                    "('bright', '>f4', (8, 36))]],"
 1052:                     " 'offsets': [0, 76800],"
 1053:                     " 'itemsize': 80000,"
 1054:                     " 'aligned': True}")
 1055:         with np.printoptions(legacy='1.21'):
 1056:             assert_equal(str(dt),
 1057:                         "{'names':['top','bottom'], "
 1058:                          "'formats':[([('tiles', ('>f4', (64, 64)), (1,)), "
 1059:                                       "('rtile', '>f4', (64, 36))], (3,)),"
 1060:                                      "[('bleft', ('>f4', (8, 64)), (1,)), "
 1061:                                       "('bright', '>f4', (8, 36))]], "
 1062:                          "'offsets':[0,76800], "
 1063:                          "'itemsize':80000, "
 1064:                          "'aligned':True}")
 1065:         assert_equal(np.dtype(eval(str(dt))), dt)
 1066: 
 1067:         dt = np.dtype({'names': ['r', 'g', 'b'], 'formats': ['u1', 'u1', 'u1'],
 1068:                         'offsets': [0, 1, 2],
 1069:                         'titles': ['Red pixel', 'Green pixel', 'Blue pixel']})
 1070:         assert_equal(str(dt),
 1071:                     "[(('Red pixel', 'r'), 'u1'), "
 1072:                     "(('Green pixel', 'g'), 'u1'), "
 1073:                     "(('Blue pixel', 'b'), 'u1')]")
 1074: 
 1075:         dt = np.dtype({'names': ['rgba', 'r', 'g', 'b'],
 1076:                        'formats': ['<u4', 'u1', 'u1', 'u1'],
 1077:                        'offsets': [0, 0, 1, 2],
 1078:                        'titles': ['Color', 'Red pixel',
 1079:                                   'Green pixel', 'Blue pixel']})
 1080:         assert_equal(str(dt),
 1081:                     "{'names': ['rgba', 'r', 'g', 'b'],"
 1082:                     " 'formats': ['<u4', 'u1', 'u1', 'u1'],"
 1083:                     " 'offsets': [0, 0, 1, 2],"
 1084:                     " 'titles': ['Color', 'Red pixel', "
 1085:                                "'Green pixel', 'Blue pixel'],"
 1086:                     " 'itemsize': 4}")
 1087: 
 1088:         dt = np.dtype({'names': ['r', 'b'], 'formats': ['u1', 'u1'],
 1089:                         'offsets': [0, 2],
 1090:                         'titles': ['Red pixel', 'Blue pixel']})
 1091:         assert_equal(str(dt),
 1092:                     "{'names': ['r', 'b'],"
 1093:                     " 'formats': ['u1', 'u1'],"
 1094:                     " 'offsets': [0, 2],"
 1095:                     " 'titles': ['Red pixel', 'Blue pixel'],"
 1096:                     " 'itemsize': 3}")
 1097: 
 1098:         dt = np.dtype([('a', '<m8[D]'), ('b', '<M8[us]')])
 1099:         assert_equal(str(dt),
 1100:                     "[('a', '<m8[D]'), ('b', '<M8[us]')]")
 1101: 
 1102:     def test_repr_structured(self):
 1103:         dt = np.dtype([('top', [('tiles', ('>f4', (64, 64)), (1,)),
 1104:                                 ('rtile', '>f4', (64, 36))], (3,)),
 1105:                        ('bottom', [('bleft', ('>f4', (8, 64)), (1,)),
 1106:                                    ('bright', '>f4', (8, 36))])])
 1107:         assert_equal(repr(dt),
 1108:                      "dtype([('top', [('tiles', ('>f4', (64, 64)), (1,)), "
 1109:                      "('rtile', '>f4', (64, 36))], (3,)), "
 1110:                      "('bottom', [('bleft', ('>f4', (8, 64)), (1,)), "
 1111:                      "('bright', '>f4', (8, 36))])])")
 1112: 
 1113:         dt = np.dtype({'names': ['r', 'g', 'b'], 'formats': ['u1', 'u1', 'u1'],
 1114:                         'offsets': [0, 1, 2],
 1115:                         'titles': ['Red pixel', 'Green pixel', 'Blue pixel']},
 1116:                         align=True)
 1117:         assert_equal(repr(dt),
 1118:                     "dtype([(('Red pixel', 'r'), 'u1'), "
 1119:                     "(('Green pixel', 'g'), 'u1'), "
 1120:                     "(('Blue pixel', 'b'), 'u1')], align=True)")
 1121: 
 1122:     def test_repr_structured_not_packed(self):
 1123:         dt = np.dtype({'names': ['rgba', 'r', 'g', 'b'],
 1124:                        'formats': ['<u4', 'u1', 'u1', 'u1'],
 1125:                        'offsets': [0, 0, 1, 2],
 1126:                        'titles': ['Color', 'Red pixel',
 1127:                                   'Green pixel', 'Blue pixel']}, align=True)
 1128:         assert_equal(repr(dt),
 1129:                     "dtype({'names': ['rgba', 'r', 'g', 'b'],"
 1130:                     " 'formats': ['<u4', 'u1', 'u1', 'u1'],"
 1131:                     " 'offsets': [0, 0, 1, 2],"
 1132:                     " 'titles': ['Color', 'Red pixel', "
 1133:                                 "'Green pixel', 'Blue pixel'],"
 1134:                     " 'itemsize': 4}, align=True)")
 1135: 
 1136:         dt = np.dtype({'names': ['r', 'b'], 'formats': ['u1', 'u1'],
 1137:                         'offsets': [0, 2],
 1138:                         'titles': ['Red pixel', 'Blue pixel'],
 1139:                         'itemsize': 4})
 1140:         assert_equal(repr(dt),
 1141:                     "dtype({'names': ['r', 'b'], "
 1142:                     "'formats': ['u1', 'u1'], "
 1143:                     "'offsets': [0, 2], "
 1144:                     "'titles': ['Red pixel', 'Blue pixel'], "
 1145:                     "'itemsize': 4})")
 1146: 
 1147:     def test_repr_structured_datetime(self):
 1148:         dt = np.dtype([('a', '<M8[D]'), ('b', '<m8[us]')])
 1149:         assert_equal(repr(dt),
 1150:                     "dtype([('a', '<M8[D]'), ('b', '<m8[us]')])")
 1151: 
 1152:     def test_repr_str_subarray(self):
 1153:         dt = np.dtype(('<i2', (1,)))
 1154:         assert_equal(repr(dt), "dtype(('<i2', (1,)))")
 1155:         assert_equal(str(dt), "('<i2', (1,))")
 1156: 
 1157:     def test_base_dtype_with_object_type(self):
 1158:         # Issue gh-2798, should not error.
 1159:         np.array(['a'], dtype="O").astype(("O", [("name", "O")]))
 1160: 
 1161:     def test_empty_string_to_object(self):
 1162:         # Pull request #4722
 1163:         np.array(["", ""]).astype(object)
 1164: 
 1165:     def test_void_subclass_unsized(self):
 1166:         dt = np.dtype(np.record)
 1167:         assert_equal(repr(dt), "dtype('V')")
 1168:         assert_equal(str(dt), '|V0')
 1169:         assert_equal(dt.name, 'record')
 1170: 
 1171:     def test_void_subclass_sized(self):
 1172:         dt = np.dtype((np.record, 2))
 1173:         assert_equal(repr(dt), "dtype('V2')")
 1174:         assert_equal(str(dt), '|V2')
 1175:         assert_equal(dt.name, 'record16')
 1176: 
 1177:     def test_void_subclass_fields(self):
 1178:         dt = np.dtype((np.record, [('a', '<u2')]))
 1179:         assert_equal(repr(dt), "dtype((numpy.record, [('a', '<u2')]))")
 1180:         assert_equal(str(dt), "(numpy.record, [('a', '<u2')])")
 1181:         assert_equal(dt.name, 'record16')
 1182: 
 1183:     def test_custom_dtype_str(self):
 1184:         dt = np.dtypes.StringDType()
 1185:         assert_equal(dt.str, "StringDType()")
 1186: 
 1187: 
 1188: class TestDtypeAttributeDeletion:
 1189: 
 1190:     def test_dtype_non_writable_attributes_deletion(self):
 1191:         dt = np.dtype(np.double)
 1192:         attr = ["subdtype", "descr", "str", "name", "base", "shape",
 1193:                 "isbuiltin", "isnative", "isalignedstruct", "fields",
 1194:                 "metadata", "hasobject"]
 1195: 
 1196:         for s in attr:
 1197:             assert_raises(AttributeError, delattr, dt, s)
 1198: 
 1199:     def test_dtype_writable_attributes_deletion(self):
 1200:         dt = np.dtype(np.double)
 1201:         attr = ["names"]
 1202:         for s in attr:
 1203:             assert_raises(AttributeError, delattr, dt, s)
 1204: 
 1205: 
 1206: class TestDtypeAttributes:
 1207:     def test_descr_has_trailing_void(self):
 1208:         # see gh-6359
 1209:         dtype = np.dtype({
 1210:             'names': ['A', 'B'],
 1211:             'formats': ['f4', 'f4'],
 1212:             'offsets': [0, 8],
 1213:             'itemsize': 16})
 1214:         new_dtype = np.dtype(dtype.descr)
 1215:         assert_equal(new_dtype.itemsize, 16)
 1216: 
 1217:     def test_name_dtype_subclass(self):
 1218:         # Ticket #4357
 1219:         class user_def_subcls(np.void):
 1220:             pass
 1221:         assert_equal(np.dtype(user_def_subcls).name, 'user_def_subcls')
 1222: 
 1223:     def test_zero_stride(self):
 1224:         arr = np.ones(1, dtype="i8")
 1225:         arr = np.broadcast_to(arr, 10)
 1226:         assert arr.strides == (0,)
 1227:         with pytest.raises(ValueError):
 1228:             arr.dtype = "i1"
 1229: 
 1230: class TestDTypeMakeCanonical:
 1231:     def check_canonical(self, dtype, canonical):
 1232:         """
 1233:         Check most properties relevant to "canonical" versions of a dtype,
 1234:         which is mainly native byte order for datatypes supporting this.
 1235: 
 1236:         The main work is checking structured dtypes with fields, where we
 1237:         reproduce most the actual logic used in the C-code.
 1238:         """
 1239:         assert type(dtype) is type(canonical)
 1240: 
 1241:         # a canonical DType should always have equivalent casting (both ways)
 1242:         assert np.can_cast(dtype, canonical, casting="equiv")
 1243:         assert np.can_cast(canonical, dtype, casting="equiv")
 1244:         # a canonical dtype (and its fields) is always native (checks fields):
 1245:         assert canonical.isnative
 1246: 
 1247:         # Check that canonical of canonical is the same (no casting):
 1248:         assert np.result_type(canonical) == canonical
 1249: 
 1250:         if not dtype.names:
 1251:             # The flags currently never change for unstructured dtypes
 1252:             assert dtype.flags == canonical.flags
 1253:             return
 1254: 
 1255:         # Must have all the needs API flag set:
 1256:         assert dtype.flags & 0b10000
 1257: 
 1258:         # Check that the fields are identical (including titles):
 1259:         assert dtype.fields.keys() == canonical.fields.keys()
 1260: 
 1261:         def aligned_offset(offset, alignment):
 1262:             # round up offset:
 1263:             return - (-offset // alignment) * alignment
 1264: 
 1265:         totalsize = 0
 1266:         max_alignment = 1
 1267:         for name in dtype.names:
 1268:             # each field is also canonical:
 1269:             new_field_descr = canonical.fields[name][0]
 1270:             self.check_canonical(dtype.fields[name][0], new_field_descr)
 1271: 
 1272:             # Must have the "inherited" object related flags:
 1273:             expected = 0b11011 & new_field_descr.flags
 1274:             assert (canonical.flags & expected) == expected
 1275: 
 1276:             if canonical.isalignedstruct:
 1277:                 totalsize = aligned_offset(totalsize, new_field_descr.alignment)
 1278:                 max_alignment = max(new_field_descr.alignment, max_alignment)
 1279: 
 1280:             assert canonical.fields[name][1] == totalsize
 1281:             # if a title exists, they must match (otherwise empty tuple):
 1282:             assert dtype.fields[name][2:] == canonical.fields[name][2:]
 1283: 
 1284:             totalsize += new_field_descr.itemsize
 1285: 
 1286:         if canonical.isalignedstruct:
 1287:             totalsize = aligned_offset(totalsize, max_alignment)
 1288:         assert canonical.itemsize == totalsize
 1289:         assert canonical.alignment == max_alignment
 1290: 
 1291:     def test_simple(self):
 1292:         dt = np.dtype(">i4")
 1293:         assert np.result_type(dt).isnative
 1294:         assert np.result_type(dt).num == dt.num
 1295: 
 1296:         # dtype with empty space:
 1297:         struct_dt = np.dtype(">i4,<i1,i8,V3")[["f0", "f2"]]
 1298:         canonical = np.result_type(struct_dt)
 1299:         assert canonical.itemsize == 4 + 8
 1300:         assert canonical.isnative
 1301: 
 1302:         # aligned struct dtype with empty space:
 1303:         struct_dt = np.dtype(">i1,<i4,i8,V3", align=True)[["f0", "f2"]]
 1304:         canonical = np.result_type(struct_dt)
 1305:         assert canonical.isalignedstruct
 1306:         assert canonical.itemsize == np.dtype("i8").alignment + 8
 1307:         assert canonical.isnative
 1308: 
 1309:     def test_object_flag_not_inherited(self):
 1310:         # The following dtype still indicates "object", because its included
 1311:         # in the unaccessible space (maybe this could change at some point):
 1312:         arr = np.ones(3, "i,O,i")[["f0", "f2"]]
 1313:         assert arr.dtype.hasobject
 1314:         canonical_dt = np.result_type(arr.dtype)
 1315:         assert not canonical_dt.hasobject
 1316: 
 1317:     @pytest.mark.slow
 1318:     @hypothesis.given(dtype=hynp.nested_dtypes())
 1319:     def test_make_canonical_hypothesis(self, dtype):
 1320:         canonical = np.result_type(dtype)
 1321:         self.check_canonical(dtype, canonical)
 1322:         # result_type with two arguments should always give identical results:
 1323:         two_arg_result = np.result_type(dtype, dtype)
 1324:         assert np.can_cast(two_arg_result, canonical, casting="no")
 1325: 
 1326:     @pytest.mark.slow
 1327:     @hypothesis.given(
 1328:             dtype=hypothesis.extra.numpy.array_dtypes(
 1329:                 subtype_strategy=hypothesis.extra.numpy.array_dtypes(),
 1330:                 min_size=5, max_size=10, allow_subarrays=True))
 1331:     def test_structured(self, dtype):
 1332:         # Pick 4 of the fields at random.  This will leave empty space in the
 1333:         # dtype (since we do not canonicalize it here).
 1334:         field_subset = random.sample(dtype.names, k=4)
 1335:         dtype_with_empty_space = dtype[field_subset]
 1336:         assert dtype_with_empty_space.itemsize == dtype.itemsize
 1337:         canonicalized = np.result_type(dtype_with_empty_space)
 1338:         self.check_canonical(dtype_with_empty_space, canonicalized)
 1339:         # promotion with two arguments should always give identical results:
 1340:         two_arg_result = np.promote_types(
 1341:                 dtype_with_empty_space, dtype_with_empty_space)
 1342:         assert np.can_cast(two_arg_result, canonicalized, casting="no")
 1343: 
 1344:         # Ensure that we also check aligned struct (check the opposite, in
 1345:         # case hypothesis grows support for `align`.  Then repeat the test:
 1346:         dtype_aligned = np.dtype(dtype.descr, align=not dtype.isalignedstruct)
 1347:         dtype_with_empty_space = dtype_aligned[field_subset]
 1348:         assert dtype_with_empty_space.itemsize == dtype_aligned.itemsize
 1349:         canonicalized = np.result_type(dtype_with_empty_space)
 1350:         self.check_canonical(dtype_with_empty_space, canonicalized)
 1351:         # promotion with two arguments should always give identical results:
 1352:         two_arg_result = np.promote_types(
 1353:             dtype_with_empty_space, dtype_with_empty_space)
 1354:         assert np.can_cast(two_arg_result, canonicalized, casting="no")
 1355: 
 1356: 
 1357: class TestPickling:
 1358: 
 1359:     def check_pickling(self, dtype):
 1360:         for proto in range(pickle.HIGHEST_PROTOCOL + 1):
 1361:             buf = pickle.dumps(dtype, proto)
 1362:             # The dtype pickling itself pickles `np.dtype` if it is pickled
 1363:             # as a singleton `dtype` should be stored in the buffer:
 1364:             assert b"_DType_reconstruct" not in buf
 1365:             assert b"dtype" in buf
 1366:             pickled = pickle.loads(buf)
 1367:             assert_equal(pickled, dtype)
 1368:             assert_equal(pickled.descr, dtype.descr)
 1369:             if dtype.metadata is not None:
 1370:                 assert_equal(pickled.metadata, dtype.metadata)
 1371:             # Check the reconstructed dtype is functional
 1372:             x = np.zeros(3, dtype=dtype)
 1373:             y = np.zeros(3, dtype=pickled)
 1374:             assert_equal(x, y)
 1375:             assert_equal(x[0], y[0])
 1376: 
 1377:     @pytest.mark.parametrize('t', [int, float, complex, np.int32, str, object,
 1378:                                    bool])
 1379:     def test_builtin(self, t):
 1380:         self.check_pickling(np.dtype(t))
 1381: 
 1382:     def test_structured(self):
 1383:         dt = np.dtype(([('a', '>f4', (2, 1)), ('b', '<f8', (1, 3))], (2, 2)))
 1384:         self.check_pickling(dt)
 1385: 
 1386:     def test_structured_aligned(self):
 1387:         dt = np.dtype('i4, i1', align=True)
 1388:         self.check_pickling(dt)
 1389: 
 1390:     def test_structured_unaligned(self):
 1391:         dt = np.dtype('i4, i1', align=False)
 1392:         self.check_pickling(dt)
 1393: 
 1394:     def test_structured_padded(self):
 1395:         dt = np.dtype({
 1396:             'names': ['A', 'B'],
 1397:             'formats': ['f4', 'f4'],
 1398:             'offsets': [0, 8],
 1399:             'itemsize': 16})
 1400:         self.check_pickling(dt)
 1401: 
 1402:     def test_structured_titles(self):
 1403:         dt = np.dtype({'names': ['r', 'b'],
 1404:                        'formats': ['u1', 'u1'],
 1405:                        'titles': ['Red pixel', 'Blue pixel']})
 1406:         self.check_pickling(dt)
 1407: 
 1408:     @pytest.mark.parametrize('base', ['m8', 'M8'])
 1409:     @pytest.mark.parametrize('unit', ['', 'Y', 'M', 'W', 'D', 'h', 'm', 's',
 1410:                                       'ms', 'us', 'ns', 'ps', 'fs', 'as'])
 1411:     def test_datetime(self, base, unit):
 1412:         dt = np.dtype(f'{base}[{unit}]' if unit else base)
 1413:         self.check_pickling(dt)
 1414:         if unit:
 1415:             dt = np.dtype(f'{base}[7{unit}]')
 1416:             self.check_pickling(dt)
 1417: 
 1418:     def test_metadata(self):
 1419:         dt = np.dtype(int, metadata={'datum': 1})
 1420:         self.check_pickling(dt)
 1421: 
 1422:     @pytest.mark.parametrize("DType",
 1423:         [type(np.dtype(t)) for t in np.typecodes['All']] +
 1424:         [type(np.dtype(rational)), np.dtype])
 1425:     def test_pickle_dtype_class(self, DType):
 1426:         # Check that DTypes (the classes/types) roundtrip when pickling
 1427:         for proto in range(pickle.HIGHEST_PROTOCOL + 1):
 1428:             roundtrip_DType = pickle.loads(pickle.dumps(DType, proto))
 1429:             assert roundtrip_DType is DType
 1430: 
 1431:     @pytest.mark.parametrize("dt",
 1432:         [np.dtype(t) for t in np.typecodes['All']] +
 1433:         [np.dtype(rational)])
 1434:     def test_pickle_dtype(self, dt):
 1435:         # Check that dtype instances roundtrip when pickling and that pickling
 1436:         # doesn't change the hash value
 1437:         pre_pickle_hash = hash(dt)
 1438:         for proto in range(pickle.HIGHEST_PROTOCOL + 1):
 1439:             roundtrip_dt = pickle.loads(pickle.dumps(dt, proto))
 1440:             assert roundtrip_dt == dt
 1441:             assert hash(dt) == pre_pickle_hash
 1442: 
 1443: 
 1444: class TestPromotion:
 1445:     """Test cases related to more complex DType promotions.  Further promotion
 1446:     tests are defined in `test_numeric.py`
 1447:     """
 1448:     @pytest.mark.parametrize(["other", "expected"],
 1449:             [(2**16 - 1, np.complex64),
 1450:              (2**32 - 1, np.complex64),
 1451:              (np.float16(2), np.complex64),
 1452:              (np.float32(2), np.complex64),
 1453:              (np.longdouble(2), np.clongdouble),
 1454:              # Base of the double value to sidestep any rounding issues:
 1455:              (np.longdouble(np.nextafter(1.7e308, 0.)), np.clongdouble),
 1456:              # Additionally use "nextafter" so the cast can't round down:
 1457:              (np.longdouble(np.nextafter(1.7e308, np.inf)), np.clongdouble),
 1458:              # repeat for complex scalars:
 1459:              (np.complex64(2), np.complex64),
 1460:              (np.clongdouble(2), np.clongdouble),
 1461:              # Base of the double value to sidestep any rounding issues:
 1462:              (np.clongdouble(np.nextafter(1.7e308, 0.) * 1j), np.clongdouble),
 1463:              # Additionally use "nextafter" so the cast can't round down:
 1464:              (np.clongdouble(np.nextafter(1.7e308, np.inf)), np.clongdouble),
 1465:              ])
 1466:     def test_complex_other_value_based(self, other, expected):
 1467:         # This would change if we modify the value based promotion
 1468:         min_complex = np.dtype(np.complex64)
 1469: 
 1470:         res = np.result_type(other, min_complex)
 1471:         assert res == expected
 1472:         # Check the same for a simple ufunc call that uses the same logic:
 1473:         res = np.minimum(other, np.ones(3, dtype=min_complex)).dtype
 1474:         assert res == expected
 1475: 
 1476:     @pytest.mark.parametrize(["other", "expected"],
 1477:                  [(np.bool, np.complex128),
 1478:                   (np.int64, np.complex128),
 1479:                   (np.float16, np.complex64),
 1480:                   (np.float32, np.complex64),
 1481:                   (np.float64, np.complex128),
 1482:                   (np.longdouble, np.clongdouble),
 1483:                   (np.complex64, np.complex64),
 1484:                   (np.complex128, np.complex128),
 1485:                   (np.clongdouble, np.clongdouble),
 1486:                   ])
 1487:     def test_complex_scalar_value_based(self, other, expected):
 1488:         # This would change if we modify the value based promotion
 1489:         complex_scalar = 1j
 1490: 
 1491:         res = np.result_type(other, complex_scalar)
 1492:         assert res == expected
 1493:         # Check the same for a simple ufunc call that uses the same logic:
 1494:         res = np.minimum(np.ones(3, dtype=other), complex_scalar).dtype
 1495:         assert res == expected
 1496: 
 1497:     def test_complex_pyscalar_promote_rational(self):
 1498:         with pytest.raises(TypeError,
 1499:                 match=r".* no common DType exists for the given inputs"):
 1500:             np.result_type(1j, rational)
 1501: 
 1502:         with pytest.raises(TypeError,
 1503:                 match=r".* no common DType exists for the given inputs"):
 1504:             np.result_type(1j, rational(1, 2))
 1505: 
 1506:     @pytest.mark.parametrize("val", [2, 2**32, 2**63, 2**64, 2 * 100])
 1507:     def test_python_integer_promotion(self, val):
 1508:         # If we only pass scalars (mainly python ones!), NEP 50 means
 1509:         # that we get the default integer
 1510:         expected_dtype = np.dtype(int)  # the default integer
 1511:         assert np.result_type(val, 0) == expected_dtype
 1512:         # With NEP 50, the NumPy scalar wins though:
 1513:         assert np.result_type(val, np.int8(0)) == np.int8
 1514: 
 1515:     @pytest.mark.parametrize(["other", "expected"],
 1516:             [(1, rational), (1., np.float64)])
 1517:     def test_float_int_pyscalar_promote_rational(self, other, expected):
 1518:         # Note that rationals are a bit awkward as they promote with float64
 1519:         # or default ints, but not float16 or uint8/int8 (which looks
 1520:         # inconsistent here).  The new promotion fixed this (partially?)
 1521:         assert np.result_type(other, rational) == expected
 1522:         assert np.result_type(other, rational(1, 2)) == expected
 1523: 
 1524:     @pytest.mark.parametrize(["dtypes", "expected"], [
 1525:              # These promotions are not associative/commutative:
 1526:              ([np.uint16, np.int16, np.float16], np.float32),
 1527:              ([np.uint16, np.int8, np.float16], np.float32),
 1528:              ([np.uint8, np.int16, np.float16], np.float32),
 1529:              # The following promotions are not ambiguous, but cover code
 1530:              # paths of abstract promotion (no particular logic being tested)
 1531:              ([1, 1, np.float64], np.float64),
 1532:              ([1, 1., np.complex128], np.complex128),
 1533:              ([1, 1j, np.float64], np.complex128),
 1534:              ([1., 1., np.int64], np.float64),
 1535:              ([1., 1j, np.float64], np.complex128),
 1536:              ([1j, 1j, np.float64], np.complex128),
 1537:              ([1, True, np.bool], np.int_),
 1538:             ])
 1539:     def test_permutations_do_not_influence_result(self, dtypes, expected):
 1540:         # Tests that most permutations do not influence the result.  In the
 1541:         # above some uint and int combinations promote to a larger integer
 1542:         # type, which would then promote to a larger than necessary float.
 1543:         for perm in permutations(dtypes):
 1544:             assert np.result_type(*perm) == expected
 1545: 
 1546: 
 1547: def test_rational_dtype():
 1548:     # test for bug gh-5719
 1549:     a = np.array([1111], dtype=rational).astype
 1550:     assert_raises(OverflowError, a, 'int8')
 1551: 
 1552:     # test that dtype detection finds user-defined types
 1553:     x = rational(1)
 1554:     assert_equal(np.array([x, x]).dtype, np.dtype(rational))
 1555: 
 1556: 
 1557: def test_dtypes_are_true():
 1558:     # test for gh-6294
 1559:     assert bool(np.dtype('f8'))
 1560:     assert bool(np.dtype('i8'))
 1561:     assert bool(np.dtype([('a', 'i8'), ('b', 'f4')]))
 1562: 
 1563: 
 1564: def test_invalid_dtype_string():
 1565:     # test for gh-10440
 1566:     assert_raises(TypeError, np.dtype, 'f8,i8,[f8,i8]')
 1567:     assert_raises(TypeError, np.dtype, 'Fl\xfcgel')
 1568: 
 1569: 
 1570: def test_keyword_argument():
 1571:     # test for https://github.com/numpy/numpy/pull/16574#issuecomment-642660971
 1572:     assert np.dtype(dtype=np.float64) == np.dtype(np.float64)
 1573: 
 1574: 
 1575: class TestFromDTypeAttribute:
 1576:     def test_simple(self):
 1577:         class dt:
 1578:             dtype = np.dtype("f8")
 1579: 
 1580:         assert np.dtype(dt) == np.float64
 1581:         assert np.dtype(dt()) == np.float64
 1582: 
 1583:     @pytest.mark.skipif(IS_PYSTON, reason="Pyston disables recursion checking")
 1584:     @pytest.mark.skipif(IS_WASM, reason="Pyodide/WASM has limited stack size")
 1585:     def test_recursion(self):
 1586:         class dt:
 1587:             pass
 1588: 
 1589:         dt.dtype = dt
 1590:         with pytest.raises(RecursionError):
 1591:             np.dtype(dt)
 1592: 
 1593:         dt_instance = dt()
 1594:         dt_instance.dtype = dt
 1595:         with pytest.raises(RecursionError):
 1596:             np.dtype(dt_instance)
 1597: 
 1598:     def test_void_subtype(self):
 1599:         class dt(np.void):
 1600:             # This code path is fully untested before, so it is unclear
 1601:             # what this should be useful for. Note that if np.void is used
 1602:             # numpy will think we are deallocating a base type [1.17, 2019-02].
 1603:             dtype = np.dtype("f,f")
 1604: 
 1605:         np.dtype(dt)
 1606:         np.dtype(dt(1))
 1607: 
 1608:     @pytest.mark.skipif(IS_PYSTON, reason="Pyston disables recursion checking")
 1609:     @pytest.mark.skipif(IS_WASM, reason="Pyodide/WASM has limited stack size")
 1610:     def test_void_subtype_recursion(self):
 1611:         class vdt(np.void):
 1612:             pass
 1613: 
 1614:         vdt.dtype = vdt
 1615: 
 1616:         with pytest.raises(RecursionError):
 1617:             np.dtype(vdt)
 1618: 
 1619:         with pytest.raises(RecursionError):
 1620:             np.dtype(vdt(1))
 1621: 
 1622: 
 1623: class TestDTypeClasses:
 1624:     @pytest.mark.parametrize("dtype", list(np.typecodes['All']) + [rational])
 1625:     def test_basic_dtypes_subclass_properties(self, dtype):
 1626:         # Note: Except for the isinstance and type checks, these attributes
 1627:         #       are considered currently private and may change.
 1628:         dtype = np.dtype(dtype)
 1629:         assert isinstance(dtype, np.dtype)
 1630:         assert type(dtype) is not np.dtype
 1631:         if dtype.type.__name__ != "rational":
 1632:             dt_name = type(dtype).__name__.lower().removesuffix("dtype")
 1633:             if dt_name in {"uint", "int"}:
 1634:                 # The scalar names has a `c` attached because "int" is Python
 1635:                 # int and that is long...
 1636:                 dt_name += "c"
 1637:             sc_name = dtype.type.__name__
 1638:             assert dt_name == sc_name.strip("_")
 1639:             assert type(dtype).__module__ == "numpy.dtypes"
 1640: 
 1641:             assert getattr(numpy.dtypes, type(dtype).__name__) is type(dtype)
 1642:         else:
 1643:             assert type(dtype).__name__ == "dtype[rational]"
 1644:             assert type(dtype).__module__ == "numpy"
 1645: 
 1646:         assert not type(dtype)._abstract
 1647: 
 1648:         # the flexible dtypes and datetime/timedelta have additional parameters
 1649:         # which are more than just storage information, these would need to be
 1650:         # given when creating a dtype:
 1651:         parametric = (np.void, np.str_, np.bytes_, np.datetime64, np.timedelta64)
 1652:         if dtype.type not in parametric:
 1653:             assert not type(dtype)._parametric
 1654:             assert type(dtype)() is dtype
 1655:         else:
 1656:             assert type(dtype)._parametric
 1657:             with assert_raises(TypeError):
 1658:                 type(dtype)()
 1659: 
 1660:     def test_dtype_superclass(self):
 1661:         assert type(np.dtype) is not type
 1662:         assert isinstance(np.dtype, type)
 1663: 
 1664:         assert type(np.dtype).__name__ == "_DTypeMeta"
 1665:         assert type(np.dtype).__module__ == "numpy"
 1666:         assert np.dtype._abstract
 1667: 
 1668:     def test_is_numeric(self):
 1669:         all_codes = set(np.typecodes['All'])
 1670:         numeric_codes = set(np.typecodes['AllInteger'] +
 1671:                             np.typecodes['AllFloat'] + '?')
 1672:         non_numeric_codes = all_codes - numeric_codes
 1673: 
 1674:         for code in numeric_codes:
 1675:             assert type(np.dtype(code))._is_numeric
 1676: 
 1677:         for code in non_numeric_codes:
 1678:             assert not type(np.dtype(code))._is_numeric
 1679: 
 1680:     @pytest.mark.parametrize("int_", ["UInt", "Int"])
 1681:     @pytest.mark.parametrize("size", [8, 16, 32, 64])
 1682:     def test_integer_alias_names(self, int_, size):
 1683:         DType = getattr(numpy.dtypes, f"{int_}{size}DType")
 1684:         sctype = getattr(numpy, f"{int_.lower()}{size}")
 1685:         assert DType.type is sctype
 1686:         assert DType.__name__.lower().removesuffix("dtype") == sctype.__name__
 1687: 
 1688:     @pytest.mark.parametrize("name",
 1689:             ["Half", "Float", "Double", "CFloat", "CDouble"])
 1690:     def test_float_alias_names(self, name):
 1691:         with pytest.raises(AttributeError):
 1692:             getattr(numpy.dtypes, name + "DType") is numpy.dtypes.Float16DType
 1693: 
 1694:     def test_scalar_helper_all_dtypes(self):
 1695:         for dtype in np.dtypes.__all__:
 1696:             dt_class = getattr(np.dtypes, dtype)
 1697:             dt = np.dtype(dt_class)
 1698:             if dt.char not in 'OTVM':
 1699:                 assert np._core.multiarray.scalar(dt) == dt.type()
 1700:             elif dt.char == 'V':
 1701:                 assert np._core.multiarray.scalar(dt) == dt.type(b'\x00')
 1702:             elif dt.char == 'M':
 1703:                 # can't do anything with this without generating ValueError
 1704:                 # because 'M' has no units
 1705:                 _ = np._core.multiarray.scalar(dt)
 1706:             else:
 1707:                 with pytest.raises(TypeError):
 1708:                     np._core.multiarray.scalar(dt)
 1709: 
 1710: 
 1711: class TestFromCTypes:
 1712: 
 1713:     @staticmethod
 1714:     def check(ctype, dtype):
 1715:         dtype = np.dtype(dtype)
 1716:         assert np.dtype(ctype) == dtype
 1717:         assert np.dtype(ctype()) == dtype
 1718:         assert ctypes.sizeof(ctype) == dtype.itemsize
 1719: 
 1720:     def test_array(self):
 1721:         c8 = ctypes.c_uint8
 1722:         self.check(     3 * c8,  (np.uint8, (3,)))
 1723:         self.check(     1 * c8,  (np.uint8, (1,)))
 1724:         self.check(     0 * c8,  (np.uint8, (0,)))
 1725:         self.check(1 * (3 * c8), ((np.uint8, (3,)), (1,)))
 1726:         self.check(3 * (1 * c8), ((np.uint8, (1,)), (3,)))
 1727: 
 1728:     def test_padded_structure(self):
 1729:         class PaddedStruct(ctypes.Structure):
 1730:             _fields_ = [
 1731:                 ('a', ctypes.c_uint8),
 1732:                 ('b', ctypes.c_uint16)
 1733:             ]
 1734:         expected = np.dtype([
 1735:             ('a', np.uint8),
 1736:             ('b', np.uint16)
 1737:         ], align=True)
 1738:         self.check(PaddedStruct, expected)
 1739: 
 1740:     def test_bit_fields(self):
 1741:         class BitfieldStruct(ctypes.Structure):
 1742:             _fields_ = [
 1743:                 ('a', ctypes.c_uint8, 7),
 1744:                 ('b', ctypes.c_uint8, 1)
 1745:             ]
 1746:         assert_raises(TypeError, np.dtype, BitfieldStruct)
 1747:         assert_raises(TypeError, np.dtype, BitfieldStruct())
 1748: 
 1749:     def test_pointer(self):
 1750:         p_uint8 = ctypes.POINTER(ctypes.c_uint8)
 1751:         assert_raises(TypeError, np.dtype, p_uint8)
 1752: 
 1753:     def test_size_t(self):
 1754:         assert np.dtype(np.uintp) is np.dtype("N")
 1755:         self.check(ctypes.c_size_t, np.uintp)
 1756: 
 1757:     def test_void_pointer(self):
 1758:         self.check(ctypes.c_void_p, "P")
 1759: 
 1760:     def test_union(self):
 1761:         class Union(ctypes.Union):
 1762:             _fields_ = [
 1763:                 ('a', ctypes.c_uint8),
 1764:                 ('b', ctypes.c_uint16),
 1765:             ]
 1766:         expected = np.dtype({
 1767:             "names": ['a', 'b'],
 1768:             "formats": [np.uint8, np.uint16],
 1769:             "offsets": [0, 0],
 1770:             "itemsize": 2
 1771:         })
 1772:         self.check(Union, expected)
 1773: 
 1774:     def test_union_with_struct_packed(self):
 1775:         class Struct(ctypes.Structure):
 1776:             _pack_ = 1
 1777:             _fields_ = [
 1778:                 ('one', ctypes.c_uint8),
 1779:                 ('two', ctypes.c_uint32)
 1780:             ]
 1781: 
 1782:         class Union(ctypes.Union):
 1783:             _fields_ = [
 1784:                 ('a', ctypes.c_uint8),
 1785:                 ('b', ctypes.c_uint16),
 1786:                 ('c', ctypes.c_uint32),
 1787:                 ('d', Struct),
 1788:             ]
 1789:         expected = np.dtype({
 1790:             "names": ['a', 'b', 'c', 'd'],
 1791:             "formats": ['u1', np.uint16, np.uint32, [('one', 'u1'), ('two', np.uint32)]],
 1792:             "offsets": [0, 0, 0, 0],
 1793:             "itemsize": ctypes.sizeof(Union)
 1794:         })
 1795:         self.check(Union, expected)
 1796: 
 1797:     def test_union_packed(self):
 1798:         class Struct(ctypes.Structure):
 1799:             _fields_ = [
 1800:                 ('one', ctypes.c_uint8),
 1801:                 ('two', ctypes.c_uint32)
 1802:             ]
 1803:             _pack_ = 1
 1804: 
 1805:         class Union(ctypes.Union):
 1806:             _pack_ = 1
 1807:             _fields_ = [
 1808:                 ('a', ctypes.c_uint8),
 1809:                 ('b', ctypes.c_uint16),
 1810:                 ('c', ctypes.c_uint32),
 1811:                 ('d', Struct),
 1812:             ]
 1813:         expected = np.dtype({
 1814:             "names": ['a', 'b', 'c', 'd'],
 1815:             "formats": ['u1', np.uint16, np.uint32, [('one', 'u1'), ('two', np.uint32)]],
 1816:             "offsets": [0, 0, 0, 0],
 1817:             "itemsize": ctypes.sizeof(Union)
 1818:         })
 1819:         self.check(Union, expected)
 1820: 
 1821:     def test_packed_structure(self):
 1822:         class PackedStructure(ctypes.Structure):
 1823:             _pack_ = 1
 1824:             _fields_ = [
 1825:                 ('a', ctypes.c_uint8),
 1826:                 ('b', ctypes.c_uint16)
 1827:             ]
 1828:         expected = np.dtype([
 1829:             ('a', np.uint8),
 1830:             ('b', np.uint16)
 1831:         ])
 1832:         self.check(PackedStructure, expected)
 1833: 
 1834:     def test_large_packed_structure(self):
 1835:         class PackedStructure(ctypes.Structure):
 1836:             _pack_ = 2
 1837:             _fields_ = [
 1838:                 ('a', ctypes.c_uint8),
 1839:                 ('b', ctypes.c_uint16),
 1840:                 ('c', ctypes.c_uint8),
 1841:                 ('d', ctypes.c_uint16),
 1842:                 ('e', ctypes.c_uint32),
 1843:                 ('f', ctypes.c_uint32),
 1844:                 ('g', ctypes.c_uint8)
 1845:                 ]
 1846:         expected = np.dtype({
 1847:             "formats": [np.uint8, np.uint16, np.uint8, np.uint16, np.uint32, np.uint32, np.uint8],
 1848:             "offsets": [0, 2, 4, 6, 8, 12, 16],
 1849:             "names": ['a', 'b', 'c', 'd', 'e', 'f', 'g'],
 1850:             "itemsize": 18})
 1851:         self.check(PackedStructure, expected)
 1852: 
 1853:     def test_big_endian_structure_packed(self):
 1854:         class BigEndStruct(ctypes.BigEndianStructure):
 1855:             _fields_ = [
 1856:                 ('one', ctypes.c_uint8),
 1857:                 ('two', ctypes.c_uint32)
 1858:             ]
 1859:             _pack_ = 1
 1860:         expected = np.dtype([('one', 'u1'), ('two', '>u4')])
 1861:         self.check(BigEndStruct, expected)
 1862: 
 1863:     def test_little_endian_structure_packed(self):
 1864:         class LittleEndStruct(ctypes.LittleEndianStructure):
 1865:             _fields_ = [
 1866:                 ('one', ctypes.c_uint8),
 1867:                 ('two', ctypes.c_uint32)
 1868:             ]
 1869:             _pack_ = 1
 1870:         expected = np.dtype([('one', 'u1'), ('two', '<u4')])
 1871:         self.check(LittleEndStruct, expected)
 1872: 
 1873:     def test_little_endian_structure(self):
 1874:         class PaddedStruct(ctypes.LittleEndianStructure):
 1875:             _fields_ = [
 1876:                 ('a', ctypes.c_uint8),
 1877:                 ('b', ctypes.c_uint16)
 1878:             ]
 1879:         expected = np.dtype([
 1880:             ('a', '<B'),
 1881:             ('b', '<H')
 1882:         ], align=True)
 1883:         self.check(PaddedStruct, expected)
 1884: 
 1885:     def test_big_endian_structure(self):
 1886:         class PaddedStruct(ctypes.BigEndianStructure):
 1887:             _fields_ = [
 1888:                 ('a', ctypes.c_uint8),
 1889:                 ('b', ctypes.c_uint16)
 1890:             ]
 1891:         expected = np.dtype([
 1892:             ('a', '>B'),
 1893:             ('b', '>H')
 1894:         ], align=True)
 1895:         self.check(PaddedStruct, expected)
 1896: 
 1897:     def test_simple_endian_types(self):
 1898:         self.check(ctypes.c_uint16.__ctype_le__, np.dtype('<u2'))
 1899:         self.check(ctypes.c_uint16.__ctype_be__, np.dtype('>u2'))
 1900:         self.check(ctypes.c_uint8.__ctype_le__, np.dtype('u1'))
 1901:         self.check(ctypes.c_uint8.__ctype_be__, np.dtype('u1'))
 1902: 
 1903:     all_types = set(np.typecodes['All'])
 1904:     all_pairs = permutations(all_types, 2)
 1905: 
 1906:     @pytest.mark.parametrize("pair", all_pairs)
 1907:     def test_pairs(self, pair):
 1908:         """
 1909:         Check that np.dtype('x,y') matches [np.dtype('x'), np.dtype('y')]
 1910:         Example: np.dtype('d,I') -> dtype([('f0', '<f8'), ('f1', '<u4')])
 1911:         """
 1912:         # gh-5645: check that np.dtype('i,L') can be used
 1913:         pair_type = np.dtype('{},{}'.format(*pair))
 1914:         expected = np.dtype([('f0', pair[0]), ('f1', pair[1])])
 1915:         assert_equal(pair_type, expected)
 1916: 
 1917: 
 1918: class TestUserDType:
 1919:     @pytest.mark.leaks_references(reason="dynamically creates custom dtype.")
 1920:     def test_custom_structured_dtype(self):
 1921:         class mytype:
 1922:             pass
 1923: 
 1924:         blueprint = np.dtype([("field", object)])
 1925:         dt = create_custom_field_dtype(blueprint, mytype, 0)
 1926:         assert dt.type == mytype
 1927:         # We cannot (currently) *create* this dtype with `np.dtype` because
 1928:         # mytype does not inherit from `np.generic`.  This seems like an
 1929:         # unnecessary restriction, but one that has been around forever:
 1930:         assert np.dtype(mytype) == np.dtype("O")
 1931: 
 1932:         if HAS_REFCOUNT:
 1933:             # Create an array and test that memory gets cleaned up (gh-25949)
 1934:             o = object()
 1935:             startcount = sys.getrefcount(o)
 1936:             a = np.array([o], dtype=dt)
 1937:             del a
 1938:             assert sys.getrefcount(o) == startcount
 1939: 
 1940:     def test_custom_structured_dtype_errors(self):
 1941:         class mytype:
 1942:             pass
 1943: 
 1944:         blueprint = np.dtype([("field", object)])
 1945: 
 1946:         with pytest.raises(ValueError):
 1947:             # Tests what happens if fields are unset during creation
 1948:             # which is currently rejected due to the containing object
 1949:             # (see PyArray_RegisterDataType).
 1950:             create_custom_field_dtype(blueprint, mytype, 1)
 1951: 
 1952:         with pytest.raises(RuntimeError):
 1953:             # Tests that a dtype must have its type field set up to np.dtype
 1954:             # or in this case a builtin instance.
 1955:             create_custom_field_dtype(blueprint, mytype, 2)
 1956: 
 1957: 
 1958: class TestClassGetItem:
 1959:     def test_dtype(self) -> None:
 1960:         alias = np.dtype[Any]
 1961:         assert isinstance(alias, types.GenericAlias)
 1962:         assert alias.__origin__ is np.dtype
 1963: 
 1964:     @pytest.mark.parametrize("code", np.typecodes["All"])
 1965:     def test_dtype_subclass(self, code: str) -> None:
 1966:         cls = type(np.dtype(code))
 1967:         alias = cls[Any]
 1968:         assert isinstance(alias, types.GenericAlias)
 1969:         assert alias.__origin__ is cls
 1970: 
 1971:     @pytest.mark.parametrize("arg_len", range(4))
 1972:     def test_subscript_tuple(self, arg_len: int) -> None:
 1973:         arg_tup = (Any,) * arg_len
 1974:         if arg_len == 1:
 1975:             assert np.dtype[arg_tup]
 1976:         else:
 1977:             with pytest.raises(TypeError):
 1978:                 np.dtype[arg_tup]
 1979: 
 1980:     def test_subscript_scalar(self) -> None:
 1981:         assert np.dtype[Any]
 1982: 
 1983: 
 1984: def test_result_type_integers_and_unitless_timedelta64():
 1985:     # Regression test for gh-20077.  The following call of `result_type`
 1986:     # would cause a seg. fault.
 1987:     td = np.timedelta64(4)
 1988:     result = np.result_type(0, td)
 1989:     assert_dtype_equal(result, td.dtype)
 1990: 
 1991: 
 1992: def test_creating_dtype_with_dtype_class_errors():
 1993:     # Regression test for #25031, calling `np.dtype` with itself segfaulted.
 1994:     with pytest.raises(TypeError, match="Cannot convert np.dtype into a"):
 1995:         np.array(np.ones(10), dtype=np.dtype)
