    1: """ Test functions for limits module.
    2: 
    3: """
    4: import types
    5: import warnings
    6: 
    7: import pytest
    8: 
    9: import numpy as np
   10: from numpy import double, half, longdouble, single
   11: from numpy._core import finfo, iinfo
   12: from numpy._core.getlimits import _discovered_machar, _float_ma
   13: from numpy.testing import assert_, assert_equal, assert_raises
   14: 
   15: ##################################################
   16: 
   17: class TestPythonFloat:
   18:     def test_singleton(self):
   19:         ftype = finfo(float)
   20:         ftype2 = finfo(float)
   21:         assert_equal(id(ftype), id(ftype2))
   22: 
   23: class TestHalf:
   24:     def test_singleton(self):
   25:         ftype = finfo(half)
   26:         ftype2 = finfo(half)
   27:         assert_equal(id(ftype), id(ftype2))
   28: 
   29: class TestSingle:
   30:     def test_singleton(self):
   31:         ftype = finfo(single)
   32:         ftype2 = finfo(single)
   33:         assert_equal(id(ftype), id(ftype2))
   34: 
   35: class TestDouble:
   36:     def test_singleton(self):
   37:         ftype = finfo(double)
   38:         ftype2 = finfo(double)
   39:         assert_equal(id(ftype), id(ftype2))
   40: 
   41: class TestLongdouble:
   42:     def test_singleton(self):
   43:         ftype = finfo(longdouble)
   44:         ftype2 = finfo(longdouble)
   45:         assert_equal(id(ftype), id(ftype2))
   46: 
   47: def assert_finfo_equal(f1, f2):
   48:     # assert two finfo instances have the same attributes
   49:     for attr in ('bits', 'eps', 'epsneg', 'iexp', 'machep',
   50:                  'max', 'maxexp', 'min', 'minexp', 'negep', 'nexp',
   51:                  'nmant', 'precision', 'resolution', 'tiny',
   52:                  'smallest_normal', 'smallest_subnormal'):
   53:         assert_equal(getattr(f1, attr), getattr(f2, attr),
   54:                      f'finfo instances {f1} and {f2} differ on {attr}')
   55: 
   56: def assert_iinfo_equal(i1, i2):
   57:     # assert two iinfo instances have the same attributes
   58:     for attr in ('bits', 'min', 'max'):
   59:         assert_equal(getattr(i1, attr), getattr(i2, attr),
   60:                      f'iinfo instances {i1} and {i2} differ on {attr}')
   61: 
   62: class TestFinfo:
   63:     def test_basic(self):
   64:         dts = list(zip(['f2', 'f4', 'f8', 'c8', 'c16'],
   65:                        [np.float16, np.float32, np.float64, np.complex64,
   66:                         np.complex128]))
   67:         for dt1, dt2 in dts:
   68:             assert_finfo_equal(finfo(dt1), finfo(dt2))
   69: 
   70:         assert_raises(ValueError, finfo, 'i4')
   71: 
   72:     def test_regression_gh23108(self):
   73:         # np.float32(1.0) and np.float64(1.0) have the same hash and are
   74:         # equal under the == operator
   75:         f1 = np.finfo(np.float32(1.0))
   76:         f2 = np.finfo(np.float64(1.0))
   77:         assert f1 != f2
   78: 
   79:     def test_regression_gh23867(self):
   80:         class NonHashableWithDtype:
   81:             __hash__ = None
   82:             dtype = np.dtype('float32')
   83: 
   84:         x = NonHashableWithDtype()
   85:         assert np.finfo(x) == np.finfo(x.dtype)
   86: 
   87: 
   88: class TestIinfo:
   89:     def test_basic(self):
   90:         dts = list(zip(['i1', 'i2', 'i4', 'i8',
   91:                    'u1', 'u2', 'u4', 'u8'],
   92:                   [np.int8, np.int16, np.int32, np.int64,
   93:                    np.uint8, np.uint16, np.uint32, np.uint64]))
   94:         for dt1, dt2 in dts:
   95:             assert_iinfo_equal(iinfo(dt1), iinfo(dt2))
   96: 
   97:         assert_raises(ValueError, iinfo, 'f4')
   98: 
   99:     def test_unsigned_max(self):
  100:         types = np._core.sctypes['uint']
  101:         for T in types:
  102:             with np.errstate(over="ignore"):
  103:                 max_calculated = T(0) - T(1)
  104:             assert_equal(iinfo(T).max, max_calculated)
  105: 
  106: class TestRepr:
  107:     def test_iinfo_repr(self):
  108:         expected = "iinfo(min=-32768, max=32767, dtype=int16)"
  109:         assert_equal(repr(np.iinfo(np.int16)), expected)
  110: 
  111:     def test_finfo_repr(self):
  112:         expected = "finfo(resolution=1e-06, min=-3.4028235e+38,"\
  113:                    " max=3.4028235e+38, dtype=float32)"
  114:         assert_equal(repr(np.finfo(np.float32)), expected)
  115: 
  116: 
  117: def test_instances():
  118:     # Test the finfo and iinfo results on numeric instances agree with
  119:     # the results on the corresponding types
  120: 
  121:     for c in [int, np.int16, np.int32, np.int64]:
  122:         class_iinfo = iinfo(c)
  123:         instance_iinfo = iinfo(c(12))
  124: 
  125:         assert_iinfo_equal(class_iinfo, instance_iinfo)
  126: 
  127:     for c in [float, np.float16, np.float32, np.float64]:
  128:         class_finfo = finfo(c)
  129:         instance_finfo = finfo(c(1.2))
  130:         assert_finfo_equal(class_finfo, instance_finfo)
  131: 
  132:     with pytest.raises(ValueError):
  133:         iinfo(10.)
  134: 
  135:     with pytest.raises(ValueError):
  136:         iinfo('hi')
  137: 
  138:     with pytest.raises(ValueError):
  139:         finfo(np.int64(1))
  140: 
  141: 
  142: def assert_ma_equal(discovered, ma_like):
  143:     # Check MachAr-like objects same as calculated MachAr instances
  144:     for key, value in discovered.__dict__.items():
  145:         assert_equal(value, getattr(ma_like, key))
  146:         if hasattr(value, 'shape'):
  147:             assert_equal(value.shape, getattr(ma_like, key).shape)
  148:             assert_equal(value.dtype, getattr(ma_like, key).dtype)
  149: 
  150: 
  151: def test_known_types():
  152:     # Test we are correctly compiling parameters for known types
  153:     for ftype, ma_like in ((np.float16, _float_ma[16]),
  154:                            (np.float32, _float_ma[32]),
  155:                            (np.float64, _float_ma[64])):
  156:         assert_ma_equal(_discovered_machar(ftype), ma_like)
  157:     # Suppress warning for broken discovery of double double on PPC
  158:     with np.errstate(all='ignore'):
  159:         ld_ma = _discovered_machar(np.longdouble)
  160:     bytes = np.dtype(np.longdouble).itemsize
  161:     if (ld_ma.it, ld_ma.maxexp) == (63, 16384) and bytes in (12, 16):
  162:         # 80-bit extended precision
  163:         assert_ma_equal(ld_ma, _float_ma[80])
  164:     elif (ld_ma.it, ld_ma.maxexp) == (112, 16384) and bytes == 16:
  165:         # IEE 754 128-bit
  166:         assert_ma_equal(ld_ma, _float_ma[128])
  167: 
  168: 
  169: def test_subnormal_warning():
  170:     """Test that the subnormal is zero warning is not being raised."""
  171:     with np.errstate(all='ignore'):
  172:         ld_ma = _discovered_machar(np.longdouble)
  173:     bytes = np.dtype(np.longdouble).itemsize
  174:     with warnings.catch_warnings(record=True) as w:
  175:         warnings.simplefilter('always')
  176:         if (ld_ma.it, ld_ma.maxexp) == (63, 16384) and bytes in (12, 16):
  177:             # 80-bit extended precision
  178:             ld_ma.smallest_subnormal
  179:             assert len(w) == 0
  180:         elif (ld_ma.it, ld_ma.maxexp) == (112, 16384) and bytes == 16:
  181:             # IEE 754 128-bit
  182:             ld_ma.smallest_subnormal
  183:             assert len(w) == 0
  184:         else:
  185:             # Double double
  186:             ld_ma.smallest_subnormal
  187:             # This test may fail on some platforms
  188:             assert len(w) == 0
  189: 
  190: 
  191: def test_plausible_finfo():
  192:     # Assert that finfo returns reasonable results for all types
  193:     for ftype in np._core.sctypes['float'] + np._core.sctypes['complex']:
  194:         info = np.finfo(ftype)
  195:         assert_(info.nmant > 1)
  196:         assert_(info.minexp < -1)
  197:         assert_(info.maxexp > 1)
  198: 
  199: 
  200: class TestRuntimeSubscriptable:
  201:     def test_finfo_generic(self):
  202:         assert isinstance(np.finfo[np.float64], types.GenericAlias)
  203: 
  204:     def test_iinfo_generic(self):
  205:         assert isinstance(np.iinfo[np.int_], types.GenericAlias)
