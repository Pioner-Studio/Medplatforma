    1: 
    2: import numpy as np
    3: from numpy.testing import assert_, assert_array_equal, assert_equal
    4: 
    5: 
    6: def buffer_length(arr):
    7:     if isinstance(arr, str):
    8:         if not arr:
    9:             charmax = 0
   10:         else:
   11:             charmax = max(ord(c) for c in arr)
   12:         if charmax < 256:
   13:             size = 1
   14:         elif charmax < 65536:
   15:             size = 2
   16:         else:
   17:             size = 4
   18:         return size * len(arr)
   19:     v = memoryview(arr)
   20:     if v.shape is None:
   21:         return len(v) * v.itemsize
   22:     else:
   23:         return np.prod(v.shape) * v.itemsize
   24: 
   25: 
   26: # In both cases below we need to make sure that the byte swapped value (as
   27: # UCS4) is still a valid unicode:
   28: # Value that can be represented in UCS2 interpreters
   29: ucs2_value = '\u0900'
   30: # Value that cannot be represented in UCS2 interpreters (but can in UCS4)
   31: ucs4_value = '\U00100900'
   32: 
   33: 
   34: def test_string_cast():
   35:     str_arr = np.array(["1234", "1234\0\0"], dtype='S')
   36:     uni_arr1 = str_arr.astype('>U')
   37:     uni_arr2 = str_arr.astype('<U')
   38: 
   39:     assert_array_equal(str_arr != uni_arr1, np.ones(2, dtype=bool))
   40:     assert_array_equal(uni_arr1 != str_arr, np.ones(2, dtype=bool))
   41:     assert_array_equal(str_arr == uni_arr1, np.zeros(2, dtype=bool))
   42:     assert_array_equal(uni_arr1 == str_arr, np.zeros(2, dtype=bool))
   43: 
   44:     assert_array_equal(uni_arr1, uni_arr2)
   45: 
   46: 
   47: ############################################################
   48: #    Creation tests
   49: ############################################################
   50: 
   51: class CreateZeros:
   52:     """Check the creation of zero-valued arrays"""
   53: 
   54:     def content_check(self, ua, ua_scalar, nbytes):
   55: 
   56:         # Check the length of the unicode base type
   57:         assert_(int(ua.dtype.str[2:]) == self.ulen)
   58:         # Check the length of the data buffer
   59:         assert_(buffer_length(ua) == nbytes)
   60:         # Small check that data in array element is ok
   61:         assert_(ua_scalar == '')
   62:         # Encode to ascii and double check
   63:         assert_(ua_scalar.encode('ascii') == b'')
   64:         # Check buffer lengths for scalars
   65:         assert_(buffer_length(ua_scalar) == 0)
   66: 
   67:     def test_zeros0D(self):
   68:         # Check creation of 0-dimensional objects
   69:         ua = np.zeros((), dtype=f'U{self.ulen}')
   70:         self.content_check(ua, ua[()], 4 * self.ulen)
   71: 
   72:     def test_zerosSD(self):
   73:         # Check creation of single-dimensional objects
   74:         ua = np.zeros((2,), dtype=f'U{self.ulen}')
   75:         self.content_check(ua, ua[0], 4 * self.ulen * 2)
   76:         self.content_check(ua, ua[1], 4 * self.ulen * 2)
   77: 
   78:     def test_zerosMD(self):
   79:         # Check creation of multi-dimensional objects
   80:         ua = np.zeros((2, 3, 4), dtype=f'U{self.ulen}')
   81:         self.content_check(ua, ua[0, 0, 0], 4 * self.ulen * 2 * 3 * 4)
   82:         self.content_check(ua, ua[-1, -1, -1], 4 * self.ulen * 2 * 3 * 4)
   83: 
   84: 
   85: class TestCreateZeros_1(CreateZeros):
   86:     """Check the creation of zero-valued arrays (size 1)"""
   87:     ulen = 1
   88: 
   89: 
   90: class TestCreateZeros_2(CreateZeros):
   91:     """Check the creation of zero-valued arrays (size 2)"""
   92:     ulen = 2
   93: 
   94: 
   95: class TestCreateZeros_1009(CreateZeros):
   96:     """Check the creation of zero-valued arrays (size 1009)"""
   97:     ulen = 1009
   98: 
   99: 
  100: class CreateValues:
  101:     """Check the creation of unicode arrays with values"""
  102: 
  103:     def content_check(self, ua, ua_scalar, nbytes):
  104: 
  105:         # Check the length of the unicode base type
  106:         assert_(int(ua.dtype.str[2:]) == self.ulen)
  107:         # Check the length of the data buffer
  108:         assert_(buffer_length(ua) == nbytes)
  109:         # Small check that data in array element is ok
  110:         assert_(ua_scalar == self.ucs_value * self.ulen)
  111:         # Encode to UTF-8 and double check
  112:         assert_(ua_scalar.encode('utf-8') ==
  113:                         (self.ucs_value * self.ulen).encode('utf-8'))
  114:         # Check buffer lengths for scalars
  115:         if self.ucs_value == ucs4_value:
  116:             # In UCS2, the \U0010FFFF will be represented using a
  117:             # surrogate *pair*
  118:             assert_(buffer_length(ua_scalar) == 2 * 2 * self.ulen)
  119:         else:
  120:             # In UCS2, the \uFFFF will be represented using a
  121:             # regular 2-byte word
  122:             assert_(buffer_length(ua_scalar) == 2 * self.ulen)
  123: 
  124:     def test_values0D(self):
  125:         # Check creation of 0-dimensional objects with values
  126:         ua = np.array(self.ucs_value * self.ulen, dtype=f'U{self.ulen}')
  127:         self.content_check(ua, ua[()], 4 * self.ulen)
  128: 
  129:     def test_valuesSD(self):
  130:         # Check creation of single-dimensional objects with values
  131:         ua = np.array([self.ucs_value * self.ulen] * 2, dtype=f'U{self.ulen}')
  132:         self.content_check(ua, ua[0], 4 * self.ulen * 2)
  133:         self.content_check(ua, ua[1], 4 * self.ulen * 2)
  134: 
  135:     def test_valuesMD(self):
  136:         # Check creation of multi-dimensional objects with values
  137:         ua = np.array([[[self.ucs_value * self.ulen] * 2] * 3] * 4, dtype=f'U{self.ulen}')
  138:         self.content_check(ua, ua[0, 0, 0], 4 * self.ulen * 2 * 3 * 4)
  139:         self.content_check(ua, ua[-1, -1, -1], 4 * self.ulen * 2 * 3 * 4)
  140: 
  141: 
  142: class TestCreateValues_1_UCS2(CreateValues):
  143:     """Check the creation of valued arrays (size 1, UCS2 values)"""
  144:     ulen = 1
  145:     ucs_value = ucs2_value
  146: 
  147: 
  148: class TestCreateValues_1_UCS4(CreateValues):
  149:     """Check the creation of valued arrays (size 1, UCS4 values)"""
  150:     ulen = 1
  151:     ucs_value = ucs4_value
  152: 
  153: 
  154: class TestCreateValues_2_UCS2(CreateValues):
  155:     """Check the creation of valued arrays (size 2, UCS2 values)"""
  156:     ulen = 2
  157:     ucs_value = ucs2_value
  158: 
  159: 
  160: class TestCreateValues_2_UCS4(CreateValues):
  161:     """Check the creation of valued arrays (size 2, UCS4 values)"""
  162:     ulen = 2
  163:     ucs_value = ucs4_value
  164: 
  165: 
  166: class TestCreateValues_1009_UCS2(CreateValues):
  167:     """Check the creation of valued arrays (size 1009, UCS2 values)"""
  168:     ulen = 1009
  169:     ucs_value = ucs2_value
  170: 
  171: 
  172: class TestCreateValues_1009_UCS4(CreateValues):
  173:     """Check the creation of valued arrays (size 1009, UCS4 values)"""
  174:     ulen = 1009
  175:     ucs_value = ucs4_value
  176: 
  177: 
  178: ############################################################
  179: #    Assignment tests
  180: ############################################################
  181: 
  182: class AssignValues:
  183:     """Check the assignment of unicode arrays with values"""
  184: 
  185:     def content_check(self, ua, ua_scalar, nbytes):
  186: 
  187:         # Check the length of the unicode base type
  188:         assert_(int(ua.dtype.str[2:]) == self.ulen)
  189:         # Check the length of the data buffer
  190:         assert_(buffer_length(ua) == nbytes)
  191:         # Small check that data in array element is ok
  192:         assert_(ua_scalar == self.ucs_value * self.ulen)
  193:         # Encode to UTF-8 and double check
  194:         assert_(ua_scalar.encode('utf-8') ==
  195:                         (self.ucs_value * self.ulen).encode('utf-8'))
  196:         # Check buffer lengths for scalars
  197:         if self.ucs_value == ucs4_value:
  198:             # In UCS2, the \U0010FFFF will be represented using a
  199:             # surrogate *pair*
  200:             assert_(buffer_length(ua_scalar) == 2 * 2 * self.ulen)
  201:         else:
  202:             # In UCS2, the \uFFFF will be represented using a
  203:             # regular 2-byte word
  204:             assert_(buffer_length(ua_scalar) == 2 * self.ulen)
  205: 
  206:     def test_values0D(self):
  207:         # Check assignment of 0-dimensional objects with values
  208:         ua = np.zeros((), dtype=f'U{self.ulen}')
  209:         ua[()] = self.ucs_value * self.ulen
  210:         self.content_check(ua, ua[()], 4 * self.ulen)
  211: 
  212:     def test_valuesSD(self):
  213:         # Check assignment of single-dimensional objects with values
  214:         ua = np.zeros((2,), dtype=f'U{self.ulen}')
  215:         ua[0] = self.ucs_value * self.ulen
  216:         self.content_check(ua, ua[0], 4 * self.ulen * 2)
  217:         ua[1] = self.ucs_value * self.ulen
  218:         self.content_check(ua, ua[1], 4 * self.ulen * 2)
  219: 
  220:     def test_valuesMD(self):
  221:         # Check assignment of multi-dimensional objects with values
  222:         ua = np.zeros((2, 3, 4), dtype=f'U{self.ulen}')
  223:         ua[0, 0, 0] = self.ucs_value * self.ulen
  224:         self.content_check(ua, ua[0, 0, 0], 4 * self.ulen * 2 * 3 * 4)
  225:         ua[-1, -1, -1] = self.ucs_value * self.ulen
  226:         self.content_check(ua, ua[-1, -1, -1], 4 * self.ulen * 2 * 3 * 4)
  227: 
  228: 
  229: class TestAssignValues_1_UCS2(AssignValues):
  230:     """Check the assignment of valued arrays (size 1, UCS2 values)"""
  231:     ulen = 1
  232:     ucs_value = ucs2_value
  233: 
  234: 
  235: class TestAssignValues_1_UCS4(AssignValues):
  236:     """Check the assignment of valued arrays (size 1, UCS4 values)"""
  237:     ulen = 1
  238:     ucs_value = ucs4_value
  239: 
  240: 
  241: class TestAssignValues_2_UCS2(AssignValues):
  242:     """Check the assignment of valued arrays (size 2, UCS2 values)"""
  243:     ulen = 2
  244:     ucs_value = ucs2_value
  245: 
  246: 
  247: class TestAssignValues_2_UCS4(AssignValues):
  248:     """Check the assignment of valued arrays (size 2, UCS4 values)"""
  249:     ulen = 2
  250:     ucs_value = ucs4_value
  251: 
  252: 
  253: class TestAssignValues_1009_UCS2(AssignValues):
  254:     """Check the assignment of valued arrays (size 1009, UCS2 values)"""
  255:     ulen = 1009
  256:     ucs_value = ucs2_value
  257: 
  258: 
  259: class TestAssignValues_1009_UCS4(AssignValues):
  260:     """Check the assignment of valued arrays (size 1009, UCS4 values)"""
  261:     ulen = 1009
  262:     ucs_value = ucs4_value
  263: 
  264: 
  265: ############################################################
  266: #    Byteorder tests
  267: ############################################################
  268: 
  269: class ByteorderValues:
  270:     """Check the byteorder of unicode arrays in round-trip conversions"""
  271: 
  272:     def test_values0D(self):
  273:         # Check byteorder of 0-dimensional objects
  274:         ua = np.array(self.ucs_value * self.ulen, dtype=f'U{self.ulen}')
  275:         ua2 = ua.view(ua.dtype.newbyteorder())
  276:         # This changes the interpretation of the data region (but not the
  277:         #  actual data), therefore the returned scalars are not
  278:         #  the same (they are byte-swapped versions of each other).
  279:         assert_(ua[()] != ua2[()])
  280:         ua3 = ua2.view(ua2.dtype.newbyteorder())
  281:         # Arrays must be equal after the round-trip
  282:         assert_equal(ua, ua3)
  283: 
  284:     def test_valuesSD(self):
  285:         # Check byteorder of single-dimensional objects
  286:         ua = np.array([self.ucs_value * self.ulen] * 2, dtype=f'U{self.ulen}')
  287:         ua2 = ua.view(ua.dtype.newbyteorder())
  288:         assert_((ua != ua2).all())
  289:         assert_(ua[-1] != ua2[-1])
  290:         ua3 = ua2.view(ua2.dtype.newbyteorder())
  291:         # Arrays must be equal after the round-trip
  292:         assert_equal(ua, ua3)
  293: 
  294:     def test_valuesMD(self):
  295:         # Check byteorder of multi-dimensional objects
  296:         ua = np.array([[[self.ucs_value * self.ulen] * 2] * 3] * 4,
  297:                       dtype=f'U{self.ulen}')
  298:         ua2 = ua.view(ua.dtype.newbyteorder())
  299:         assert_((ua != ua2).all())
  300:         assert_(ua[-1, -1, -1] != ua2[-1, -1, -1])
  301:         ua3 = ua2.view(ua2.dtype.newbyteorder())
  302:         # Arrays must be equal after the round-trip
  303:         assert_equal(ua, ua3)
  304: 
  305:     def test_values_cast(self):
  306:         # Check byteorder of when casting the array for a strided and
  307:         # contiguous array:
  308:         test1 = np.array([self.ucs_value * self.ulen] * 2, dtype=f'U{self.ulen}')
  309:         test2 = np.repeat(test1, 2)[::2]
  310:         for ua in (test1, test2):
  311:             ua2 = ua.astype(dtype=ua.dtype.newbyteorder())
  312:             assert_((ua == ua2).all())
  313:             assert_(ua[-1] == ua2[-1])
  314:             ua3 = ua2.astype(dtype=ua.dtype)
  315:             # Arrays must be equal after the round-trip
  316:             assert_equal(ua, ua3)
  317: 
  318:     def test_values_updowncast(self):
  319:         # Check byteorder of when casting the array to a longer and shorter
  320:         # string length for strided and contiguous arrays
  321:         test1 = np.array([self.ucs_value * self.ulen] * 2, dtype=f'U{self.ulen}')
  322:         test2 = np.repeat(test1, 2)[::2]
  323:         for ua in (test1, test2):
  324:             # Cast to a longer type with zero padding
  325:             longer_type = np.dtype(f'U{self.ulen + 1}').newbyteorder()
  326:             ua2 = ua.astype(dtype=longer_type)
  327:             assert_((ua == ua2).all())
  328:             assert_(ua[-1] == ua2[-1])
  329:             # Cast back again with truncating:
  330:             ua3 = ua2.astype(dtype=ua.dtype)
  331:             # Arrays must be equal after the round-trip
  332:             assert_equal(ua, ua3)
  333: 
  334: 
  335: class TestByteorder_1_UCS2(ByteorderValues):
  336:     """Check the byteorder in unicode (size 1, UCS2 values)"""
  337:     ulen = 1
  338:     ucs_value = ucs2_value
  339: 
  340: 
  341: class TestByteorder_1_UCS4(ByteorderValues):
  342:     """Check the byteorder in unicode (size 1, UCS4 values)"""
  343:     ulen = 1
  344:     ucs_value = ucs4_value
  345: 
  346: 
  347: class TestByteorder_2_UCS2(ByteorderValues):
  348:     """Check the byteorder in unicode (size 2, UCS2 values)"""
  349:     ulen = 2
  350:     ucs_value = ucs2_value
  351: 
  352: 
  353: class TestByteorder_2_UCS4(ByteorderValues):
  354:     """Check the byteorder in unicode (size 2, UCS4 values)"""
  355:     ulen = 2
  356:     ucs_value = ucs4_value
  357: 
  358: 
  359: class TestByteorder_1009_UCS2(ByteorderValues):
  360:     """Check the byteorder in unicode (size 1009, UCS2 values)"""
  361:     ulen = 1009
  362:     ucs_value = ucs2_value
  363: 
  364: 
  365: class TestByteorder_1009_UCS4(ByteorderValues):
  366:     """Check the byteorder in unicode (size 1009, UCS4 values)"""
  367:     ulen = 1009
  368:     ucs_value = ucs4_value
