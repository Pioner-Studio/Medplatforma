    1: import platform
    2: import warnings
    3: 
    4: import pytest
    5: 
    6: import numpy as np
    7: from numpy._core.tests._locales import CommaDecimalPointLocale
    8: from numpy.testing import (
    9:     IS_MUSL,
   10:     assert_,
   11:     assert_array_equal,
   12:     assert_equal,
   13:     assert_raises,
   14:     temppath,
   15: )
   16: 
   17: LD_INFO = np.finfo(np.longdouble)
   18: longdouble_longer_than_double = (LD_INFO.eps < np.finfo(np.double).eps)
   19: 
   20: 
   21: _o = 1 + LD_INFO.eps
   22: string_to_longdouble_inaccurate = (_o != np.longdouble(str(_o)))
   23: del _o
   24: 
   25: 
   26: def test_scalar_extraction():
   27:     """Confirm that extracting a value doesn't convert to python float"""
   28:     o = 1 + LD_INFO.eps
   29:     a = np.array([o, o, o])
   30:     assert_equal(a[1], o)
   31: 
   32: 
   33: # Conversions string -> long double
   34: 
   35: # 0.1 not exactly representable in base 2 floating point.
   36: repr_precision = len(repr(np.longdouble(0.1)))
   37: # +2 from macro block starting around line 842 in scalartypes.c.src.
   38: 
   39: 
   40: @pytest.mark.skipif(IS_MUSL,
   41:                     reason="test flaky on musllinux")
   42: @pytest.mark.skipif(LD_INFO.precision + 2 >= repr_precision,
   43:                     reason="repr precision not enough to show eps")
   44: def test_str_roundtrip():
   45:     # We will only see eps in repr if within printing precision.
   46:     o = 1 + LD_INFO.eps
   47:     assert_equal(np.longdouble(str(o)), o, f"str was {str(o)}")
   48: 
   49: 
   50: @pytest.mark.skipif(string_to_longdouble_inaccurate, reason="Need strtold_l")
   51: def test_str_roundtrip_bytes():
   52:     o = 1 + LD_INFO.eps
   53:     assert_equal(np.longdouble(str(o).encode("ascii")), o)
   54: 
   55: 
   56: @pytest.mark.skipif(string_to_longdouble_inaccurate, reason="Need strtold_l")
   57: @pytest.mark.parametrize("strtype", (np.str_, np.bytes_, str, bytes))
   58: def test_array_and_stringlike_roundtrip(strtype):
   59:     """
   60:     Test that string representations of long-double roundtrip both
   61:     for array casting and scalar coercion, see also gh-15608.
   62:     """
   63:     o = 1 + LD_INFO.eps
   64: 
   65:     if strtype in (np.bytes_, bytes):
   66:         o_str = strtype(str(o).encode("ascii"))
   67:     else:
   68:         o_str = strtype(str(o))
   69: 
   70:     # Test that `o` is correctly coerced from the string-like
   71:     assert o == np.longdouble(o_str)
   72: 
   73:     # Test that arrays also roundtrip correctly:
   74:     o_strarr = np.asarray([o] * 3, dtype=strtype)
   75:     assert (o == o_strarr.astype(np.longdouble)).all()
   76: 
   77:     # And array coercion and casting to string give the same as scalar repr:
   78:     assert (o_strarr == o_str).all()
   79:     assert (np.asarray([o] * 3).astype(strtype) == o_str).all()
   80: 
   81: 
   82: def test_bogus_string():
   83:     assert_raises(ValueError, np.longdouble, "spam")
   84:     assert_raises(ValueError, np.longdouble, "1.0 flub")
   85: 
   86: 
   87: @pytest.mark.skipif(string_to_longdouble_inaccurate, reason="Need strtold_l")
   88: def test_fromstring():
   89:     o = 1 + LD_INFO.eps
   90:     s = (" " + str(o)) * 5
   91:     a = np.array([o] * 5)
   92:     assert_equal(np.fromstring(s, sep=" ", dtype=np.longdouble), a,
   93:                  err_msg=f"reading '{s}'")
   94: 
   95: 
   96: def test_fromstring_complex():
   97:     for ctype in ["complex", "cdouble"]:
   98:         # Check spacing between separator
   99:         assert_equal(np.fromstring("1, 2 ,  3  ,4", sep=",", dtype=ctype),
  100:                      np.array([1., 2., 3., 4.]))
  101:         # Real component not specified
  102:         assert_equal(np.fromstring("1j, -2j,  3j, 4e1j", sep=",", dtype=ctype),
  103:                      np.array([1.j, -2.j, 3.j, 40.j]))
  104:         # Both components specified
  105:         assert_equal(np.fromstring("1+1j,2-2j, -3+3j,  -4e1+4j", sep=",", dtype=ctype),
  106:                      np.array([1. + 1.j, 2. - 2.j, - 3. + 3.j, - 40. + 4j]))
  107:         # Spaces at wrong places
  108:         with assert_raises(ValueError):
  109:             np.fromstring("1+2 j,3", dtype=ctype, sep=",")
  110:         with assert_raises(ValueError):
  111:             np.fromstring("1+ 2j,3", dtype=ctype, sep=",")
  112:         with assert_raises(ValueError):
  113:             np.fromstring("1 +2j,3", dtype=ctype, sep=",")
  114:         with assert_raises(ValueError):
  115:             np.fromstring("1+j", dtype=ctype, sep=",")
  116:         with assert_raises(ValueError):
  117:             np.fromstring("1+", dtype=ctype, sep=",")
  118:         with assert_raises(ValueError):
  119:             np.fromstring("1j+1", dtype=ctype, sep=",")
  120: 
  121: 
  122: def test_fromstring_bogus():
  123:     with assert_raises(ValueError):
  124:         np.fromstring("1. 2. 3. flop 4.", dtype=float, sep=" ")
  125: 
  126: 
  127: def test_fromstring_empty():
  128:     with assert_raises(ValueError):
  129:         np.fromstring("xxxxx", sep="x")
  130: 
  131: 
  132: def test_fromstring_missing():
  133:     with assert_raises(ValueError):
  134:         np.fromstring("1xx3x4x5x6", sep="x")
  135: 
  136: 
  137: class TestFileBased:
  138: 
  139:     ldbl = 1 + LD_INFO.eps
  140:     tgt = np.array([ldbl] * 5)
  141:     out = ''.join([str(t) + '\n' for t in tgt])
  142: 
  143:     def test_fromfile_bogus(self):
  144:         with temppath() as path:
  145:             with open(path, 'w') as f:
  146:                 f.write("1. 2. 3. flop 4.\n")
  147: 
  148:             with assert_raises(ValueError):
  149:                 np.fromfile(path, dtype=float, sep=" ")
  150: 
  151:     def test_fromfile_complex(self):
  152:         for ctype in ["complex", "cdouble"]:
  153:             # Check spacing between separator and only real component specified
  154:             with temppath() as path:
  155:                 with open(path, 'w') as f:
  156:                     f.write("1, 2 ,  3  ,4\n")
  157: 
  158:                 res = np.fromfile(path, dtype=ctype, sep=",")
  159:             assert_equal(res, np.array([1., 2., 3., 4.]))
  160: 
  161:             # Real component not specified
  162:             with temppath() as path:
  163:                 with open(path, 'w') as f:
  164:                     f.write("1j, -2j,  3j, 4e1j\n")
  165: 
  166:                 res = np.fromfile(path, dtype=ctype, sep=",")
  167:             assert_equal(res, np.array([1.j, -2.j, 3.j, 40.j]))
  168: 
  169:             # Both components specified
  170:             with temppath() as path:
  171:                 with open(path, 'w') as f:
  172:                     f.write("1+1j,2-2j, -3+3j,  -4e1+4j\n")
  173: 
  174:                 res = np.fromfile(path, dtype=ctype, sep=",")
  175:             assert_equal(res, np.array([1. + 1.j, 2. - 2.j, - 3. + 3.j, - 40. + 4j]))
  176: 
  177:             # Spaces at wrong places
  178:             with temppath() as path:
  179:                 with open(path, 'w') as f:
  180:                     f.write("1+2 j,3\n")
  181: 
  182:                 with assert_raises(ValueError):
  183:                     np.fromfile(path, dtype=ctype, sep=",")
  184: 
  185:             # Spaces at wrong places
  186:             with temppath() as path:
  187:                 with open(path, 'w') as f:
  188:                     f.write("1+ 2j,3\n")
  189: 
  190:                 with assert_raises(ValueError):
  191:                     np.fromfile(path, dtype=ctype, sep=",")
  192: 
  193:             # Spaces at wrong places
  194:             with temppath() as path:
  195:                 with open(path, 'w') as f:
  196:                     f.write("1 +2j,3\n")
  197: 
  198:                 with assert_raises(ValueError):
  199:                     np.fromfile(path, dtype=ctype, sep=",")
  200: 
  201:             # Wrong sep
  202:             with temppath() as path:
  203:                 with open(path, 'w') as f:
  204:                     f.write("1+j\n")
  205: 
  206:                 with assert_raises(ValueError):
  207:                     np.fromfile(path, dtype=ctype, sep=",")
  208: 
  209:             # Wrong sep
  210:             with temppath() as path:
  211:                 with open(path, 'w') as f:
  212:                     f.write("1+\n")
  213: 
  214:                 with assert_raises(ValueError):
  215:                     np.fromfile(path, dtype=ctype, sep=",")
  216: 
  217:             # Wrong sep
  218:             with temppath() as path:
  219:                 with open(path, 'w') as f:
  220:                     f.write("1j+1\n")
  221: 
  222:                 with assert_raises(ValueError):
  223:                     np.fromfile(path, dtype=ctype, sep=",")
  224: 
  225:     @pytest.mark.skipif(string_to_longdouble_inaccurate,
  226:                         reason="Need strtold_l")
  227:     def test_fromfile(self):
  228:         with temppath() as path:
  229:             with open(path, 'w') as f:
  230:                 f.write(self.out)
  231:             res = np.fromfile(path, dtype=np.longdouble, sep="\n")
  232:         assert_equal(res, self.tgt)
  233: 
  234:     @pytest.mark.skipif(string_to_longdouble_inaccurate,
  235:                         reason="Need strtold_l")
  236:     def test_genfromtxt(self):
  237:         with temppath() as path:
  238:             with open(path, 'w') as f:
  239:                 f.write(self.out)
  240:             res = np.genfromtxt(path, dtype=np.longdouble)
  241:         assert_equal(res, self.tgt)
  242: 
  243:     @pytest.mark.skipif(string_to_longdouble_inaccurate,
  244:                         reason="Need strtold_l")
  245:     def test_loadtxt(self):
  246:         with temppath() as path:
  247:             with open(path, 'w') as f:
  248:                 f.write(self.out)
  249:             res = np.loadtxt(path, dtype=np.longdouble)
  250:         assert_equal(res, self.tgt)
  251: 
  252:     @pytest.mark.skipif(string_to_longdouble_inaccurate,
  253:                         reason="Need strtold_l")
  254:     def test_tofile_roundtrip(self):
  255:         with temppath() as path:
  256:             self.tgt.tofile(path, sep=" ")
  257:             res = np.fromfile(path, dtype=np.longdouble, sep=" ")
  258:         assert_equal(res, self.tgt)
  259: 
  260: 
  261: # Conversions long double -> string
  262: 
  263: 
  264: def test_str_exact():
  265:     o = 1 + LD_INFO.eps
  266:     assert_(str(o) != '1')
  267: 
  268: 
  269: @pytest.mark.skipif(longdouble_longer_than_double, reason="BUG #2376")
  270: @pytest.mark.skipif(string_to_longdouble_inaccurate,
  271:                     reason="Need strtold_l")
  272: def test_format():
  273:     assert_(f"{1 + LD_INFO.eps:.40g}" != '1')
  274: 
  275: 
  276: @pytest.mark.skipif(longdouble_longer_than_double, reason="BUG #2376")
  277: @pytest.mark.skipif(string_to_longdouble_inaccurate,
  278:                     reason="Need strtold_l")
  279: def test_percent():
  280:     o = 1 + LD_INFO.eps
  281:     assert_(f"{o:.40g}" != '1')
  282: 
  283: 
  284: @pytest.mark.skipif(longdouble_longer_than_double,
  285:                     reason="array repr problem")
  286: @pytest.mark.skipif(string_to_longdouble_inaccurate,
  287:                     reason="Need strtold_l")
  288: def test_array_repr():
  289:     o = 1 + LD_INFO.eps
  290:     a = np.array([o])
  291:     b = np.array([1], dtype=np.longdouble)
  292:     if not np.all(a != b):
  293:         raise ValueError("precision loss creating arrays")
  294:     assert_(repr(a) != repr(b))
  295: 
  296: #
  297: # Locale tests: scalar types formatting should be independent of the locale
  298: #
  299: 
  300: class TestCommaDecimalPointLocale(CommaDecimalPointLocale):
  301: 
  302:     def test_str_roundtrip_foreign(self):
  303:         o = 1.5
  304:         assert_equal(o, np.longdouble(str(o)))
  305: 
  306:     def test_fromstring_foreign_repr(self):
  307:         f = 1.234
  308:         a = np.fromstring(repr(f), dtype=float, sep=" ")
  309:         assert_equal(a[0], f)
  310: 
  311:     def test_fromstring_foreign(self):
  312:         s = "1.234"
  313:         a = np.fromstring(s, dtype=np.longdouble, sep=" ")
  314:         assert_equal(a[0], np.longdouble(s))
  315: 
  316:     def test_fromstring_foreign_sep(self):
  317:         a = np.array([1, 2, 3, 4])
  318:         b = np.fromstring("1,2,3,4,", dtype=np.longdouble, sep=",")
  319:         assert_array_equal(a, b)
  320: 
  321:     def test_fromstring_foreign_value(self):
  322:         with assert_raises(ValueError):
  323:             np.fromstring("1,234", dtype=np.longdouble, sep=" ")
  324: 
  325: 
  326: @pytest.mark.parametrize("int_val", [
  327:     # cases discussed in gh-10723
  328:     # and gh-9968
  329:     2 ** 1024, 0])
  330: def test_longdouble_from_int(int_val):
  331:     # for issue gh-9968
  332:     str_val = str(int_val)
  333:     # we'll expect a RuntimeWarning on platforms
  334:     # with np.longdouble equivalent to np.double
  335:     # for large integer input
  336:     with warnings.catch_warnings(record=True) as w:
  337:         warnings.filterwarnings('always', '', RuntimeWarning)
  338:         # can be inf==inf on some platforms
  339:         assert np.longdouble(int_val) == np.longdouble(str_val)
  340:         # we can't directly compare the int and
  341:         # max longdouble value on all platforms
  342:         if np.allclose(np.finfo(np.longdouble).max,
  343:                        np.finfo(np.double).max) and w:
  344:             assert w[0].category is RuntimeWarning
  345: 
  346: @pytest.mark.parametrize("bool_val", [
  347:     True, False])
  348: def test_longdouble_from_bool(bool_val):
  349:     assert np.longdouble(bool_val) == np.longdouble(int(bool_val))
  350: 
  351: 
  352: @pytest.mark.skipif(
  353:     not (IS_MUSL and platform.machine() == "x86_64"),
  354:     reason="only need to run on musllinux_x86_64"
  355: )
  356: def test_musllinux_x86_64_signature():
  357:     # this test may fail if you're emulating musllinux_x86_64 on a different
  358:     # architecture, but should pass natively.
  359:     known_sigs = [b'\xcd\xcc\xcc\xcc\xcc\xcc\xcc\xcc\xfb\xbf']
  360:     sig = (np.longdouble(-1.0) / np.longdouble(10.0))
  361:     sig = sig.view(sig.dtype.newbyteorder('<')).tobytes()[:10]
  362:     assert sig in known_sigs
  363: 
  364: 
  365: def test_eps_positive():
  366:     # np.finfo('g').eps should be positive on all platforms. If this isn't true
  367:     # then something may have gone wrong with the MachArLike, e.g. if
  368:     # np._core.getlimits._discovered_machar didn't work properly
  369:     assert np.finfo(np.longdouble).eps > 0.
