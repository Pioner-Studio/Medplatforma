    1: """
    2: This file adds basic tests to test the NEP 50 style promotion compatibility
    3: mode.  Most of these test are likely to be simply deleted again once NEP 50
    4: is adopted in the main test suite.  A few may be moved elsewhere.
    5: """
    6: 
    7: import operator
    8: 
    9: import hypothesis
   10: import pytest
   11: from hypothesis import strategies
   12: 
   13: import numpy as np
   14: from numpy.testing import IS_WASM, assert_array_equal
   15: 
   16: 
   17: @pytest.mark.skipif(IS_WASM, reason="wasm doesn't have support for fp errors")
   18: def test_nep50_examples():
   19:     res = np.uint8(1) + 2
   20:     assert res.dtype == np.uint8
   21: 
   22:     res = np.array([1], np.uint8) + np.int64(1)
   23:     assert res.dtype == np.int64
   24: 
   25:     res = np.array([1], np.uint8) + np.array(1, dtype=np.int64)
   26:     assert res.dtype == np.int64
   27: 
   28:     with pytest.warns(RuntimeWarning, match="overflow"):
   29:         res = np.uint8(100) + 200
   30:     assert res.dtype == np.uint8
   31: 
   32:     with pytest.warns(RuntimeWarning, match="overflow"):
   33:         res = np.float32(1) + 3e100
   34: 
   35:     assert np.isinf(res)
   36:     assert res.dtype == np.float32
   37: 
   38:     res = np.array([0.1], np.float32) == np.float64(0.1)
   39:     assert res[0] == False
   40: 
   41:     res = np.array([0.1], np.float32) + np.float64(0.1)
   42:     assert res.dtype == np.float64
   43: 
   44:     res = np.array([1.], np.float32) + np.int64(3)
   45:     assert res.dtype == np.float64
   46: 
   47: 
   48: @pytest.mark.parametrize("dtype", np.typecodes["AllInteger"])
   49: def test_nep50_weak_integers(dtype):
   50:     # Avoids warning (different code path for scalars)
   51:     scalar_type = np.dtype(dtype).type
   52: 
   53:     maxint = int(np.iinfo(dtype).max)
   54: 
   55:     with np.errstate(over="warn"):
   56:         with pytest.warns(RuntimeWarning):
   57:             res = scalar_type(100) + maxint
   58:     assert res.dtype == dtype
   59: 
   60:     # Array operations are not expected to warn, but should give the same
   61:     # result dtype.
   62:     res = np.array(100, dtype=dtype) + maxint
   63:     assert res.dtype == dtype
   64: 
   65: 
   66: @pytest.mark.parametrize("dtype", np.typecodes["AllFloat"])
   67: def test_nep50_weak_integers_with_inexact(dtype):
   68:     # Avoids warning (different code path for scalars)
   69:     scalar_type = np.dtype(dtype).type
   70: 
   71:     too_big_int = int(np.finfo(dtype).max) * 2
   72: 
   73:     if dtype in "dDG":
   74:         # These dtypes currently convert to Python float internally, which
   75:         # raises an OverflowError, while the other dtypes overflow to inf.
   76:         # NOTE: It may make sense to normalize the behavior!
   77:         with pytest.raises(OverflowError):
   78:             scalar_type(1) + too_big_int
   79: 
   80:         with pytest.raises(OverflowError):
   81:             np.array(1, dtype=dtype) + too_big_int
   82:     else:
   83:         # NumPy uses (or used) `int -> string -> longdouble` for the
   84:         # conversion.  But Python may refuse `str(int)` for huge ints.
   85:         # In that case, RuntimeWarning would be correct, but conversion
   86:         # fails earlier (seems to happen on 32bit linux, possibly only debug).
   87:         if dtype in "gG":
   88:             try:
   89:                 str(too_big_int)
   90:             except ValueError:
   91:                 pytest.skip("`huge_int -> string -> longdouble` failed")
   92: 
   93:         # Otherwise, we overflow to infinity:
   94:         with pytest.warns(RuntimeWarning):
   95:             res = scalar_type(1) + too_big_int
   96:         assert res.dtype == dtype
   97:         assert res == np.inf
   98: 
   99:         with pytest.warns(RuntimeWarning):
  100:             # We force the dtype here, since windows may otherwise pick the
  101:             # double instead of the longdouble loop.  That leads to slightly
  102:             # different results (conversion of the int fails as above).
  103:             res = np.add(np.array(1, dtype=dtype), too_big_int, dtype=dtype)
  104:         assert res.dtype == dtype
  105:         assert res == np.inf
  106: 
  107: 
  108: @pytest.mark.parametrize("op", [operator.add, operator.pow])
  109: def test_weak_promotion_scalar_path(op):
  110:     # Some additional paths exercising the weak scalars.
  111: 
  112:     # Integer path:
  113:     res = op(np.uint8(3), 5)
  114:     assert res == op(3, 5)
  115:     assert res.dtype == np.uint8 or res.dtype == bool  # noqa: PLR1714
  116: 
  117:     with pytest.raises(OverflowError):
  118:         op(np.uint8(3), 1000)
  119: 
  120:     # Float path:
  121:     res = op(np.float32(3), 5.)
  122:     assert res == op(3., 5.)
  123:     assert res.dtype == np.float32 or res.dtype == bool  # noqa: PLR1714
  124: 
  125: 
  126: def test_nep50_complex_promotion():
  127:     with pytest.warns(RuntimeWarning, match=".*overflow"):
  128:         res = np.complex64(3) + complex(2**300)
  129: 
  130:     assert type(res) == np.complex64
  131: 
  132: 
  133: def test_nep50_integer_conversion_errors():
  134:     # Implementation for error paths is mostly missing (as of writing)
  135:     with pytest.raises(OverflowError, match=".*uint8"):
  136:         np.array([1], np.uint8) + 300
  137: 
  138:     with pytest.raises(OverflowError, match=".*uint8"):
  139:         np.uint8(1) + 300
  140: 
  141:     # Error message depends on platform (maybe unsigned int or unsigned long)
  142:     with pytest.raises(OverflowError,
  143:             match="Python integer -1 out of bounds for uint8"):
  144:         np.uint8(1) + -1
  145: 
  146: 
  147: def test_nep50_with_axisconcatenator():
  148:     # Concatenate/r_ does not promote, so this has to error:
  149:     with pytest.raises(OverflowError):
  150:         np.r_[np.arange(5, dtype=np.int8), 255]
  151: 
  152: 
  153: @pytest.mark.parametrize("ufunc", [np.add, np.power])
  154: def test_nep50_huge_integers(ufunc):
  155:     # Very large integers are complicated, because they go to uint64 or
  156:     # object dtype.  This tests covers a few possible paths.
  157:     with pytest.raises(OverflowError):
  158:         ufunc(np.int64(0), 2**63)  # 2**63 too large for int64
  159: 
  160:     with pytest.raises(OverflowError):
  161:         ufunc(np.uint64(0), 2**64)  # 2**64 cannot be represented by uint64
  162: 
  163:     # However, 2**63 can be represented by the uint64 (and that is used):
  164:     res = ufunc(np.uint64(1), 2**63)
  165: 
  166:     assert res.dtype == np.uint64
  167:     assert res == ufunc(1, 2**63, dtype=object)
  168: 
  169:     # The following paths fail to warn correctly about the change:
  170:     with pytest.raises(OverflowError):
  171:         ufunc(np.int64(1), 2**63)  # np.array(2**63) would go to uint
  172: 
  173:     with pytest.raises(OverflowError):
  174:         ufunc(np.int64(1), 2**100)  # np.array(2**100) would go to object
  175: 
  176:     # This would go to object and thus a Python float, not a NumPy one:
  177:     res = ufunc(1.0, 2**100)
  178:     assert isinstance(res, np.float64)
  179: 
  180: 
  181: def test_nep50_in_concat_and_choose():
  182:     res = np.concatenate([np.float32(1), 1.], axis=None)
  183:     assert res.dtype == "float32"
  184: 
  185:     res = np.choose(1, [np.float32(1), 1.])
  186:     assert res.dtype == "float32"
  187: 
  188: 
  189: @pytest.mark.parametrize("expected,dtypes,optional_dtypes", [
  190:         (np.float32, [np.float32],
  191:             [np.float16, 0.0, np.uint16, np.int16, np.int8, 0]),
  192:         (np.complex64, [np.float32, 0j],
  193:             [np.float16, 0.0, np.uint16, np.int16, np.int8, 0]),
  194:         (np.float32, [np.int16, np.uint16, np.float16],
  195:             [np.int8, np.uint8, np.float32, 0., 0]),
  196:         (np.int32, [np.int16, np.uint16],
  197:             [np.int8, np.uint8, 0, np.bool]),
  198:         ])
  199: @hypothesis.given(data=strategies.data())
  200: def test_expected_promotion(expected, dtypes, optional_dtypes, data):
  201:     # Sample randomly while ensuring "dtypes" is always present:
  202:     optional = data.draw(strategies.lists(
  203:             strategies.sampled_from(dtypes + optional_dtypes)))
  204:     all_dtypes = dtypes + optional
  205:     dtypes_sample = data.draw(strategies.permutations(all_dtypes))
  206: 
  207:     res = np.result_type(*dtypes_sample)
  208:     assert res == expected
  209: 
  210: 
  211: @pytest.mark.parametrize("sctype",
  212:         [np.int8, np.int16, np.int32, np.int64,
  213:          np.uint8, np.uint16, np.uint32, np.uint64])
  214: @pytest.mark.parametrize("other_val",
  215:         [-2 * 100, -1, 0, 9, 10, 11, 2**63, 2 * 100])
  216: @pytest.mark.parametrize("comp",
  217:         [operator.eq, operator.ne, operator.le, operator.lt,
  218:          operator.ge, operator.gt])
  219: def test_integer_comparison(sctype, other_val, comp):
  220:     # Test that comparisons with integers (especially out-of-bound) ones
  221:     # works correctly.
  222:     val_obj = 10
  223:     val = sctype(val_obj)
  224:     # Check that the scalar behaves the same as the python int:
  225:     assert comp(10, other_val) == comp(val, other_val)
  226:     assert comp(val, other_val) == comp(10, other_val)
  227:     # Except for the result type:
  228:     assert type(comp(val, other_val)) is np.bool
  229: 
  230:     # Check that the integer array and object array behave the same:
  231:     val_obj = np.array([10, 10], dtype=object)
  232:     val = val_obj.astype(sctype)
  233:     assert_array_equal(comp(val_obj, other_val), comp(val, other_val))
  234:     assert_array_equal(comp(other_val, val_obj), comp(other_val, val))
  235: 
  236: 
  237: @pytest.mark.parametrize("arr", [
  238:     np.ones((100, 100), dtype=np.uint8)[::2],  # not trivially iterable
  239:     np.ones(20000, dtype=">u4"),  # cast and >buffersize
  240:     np.ones(100, dtype=">u4"),  # fast path compatible with cast
  241: ])
  242: def test_integer_comparison_with_cast(arr):
  243:     # Similar to above, but mainly test a few cases that cover the slow path
  244:     # the test is limited to unsigned ints and -1 for simplicity.
  245:     res = arr >= -1
  246:     assert_array_equal(res, np.ones_like(arr, dtype=bool))
  247:     res = arr < -1
  248:     assert_array_equal(res, np.zeros_like(arr, dtype=bool))
  249: 
  250: 
  251: @pytest.mark.parametrize("comp",
  252:         [np.equal, np.not_equal, np.less_equal, np.less,
  253:          np.greater_equal, np.greater])
  254: def test_integer_integer_comparison(comp):
  255:     # Test that the NumPy comparison ufuncs work with large Python integers
  256:     assert comp(2**200, -2**200) == comp(2**200, -2**200, dtype=object)
  257: 
  258: 
  259: def create_with_scalar(sctype, value):
  260:     return sctype(value)
  261: 
  262: 
  263: def create_with_array(sctype, value):
  264:     return np.array([value], dtype=sctype)
  265: 
  266: 
  267: @pytest.mark.parametrize("sctype",
  268:         [np.int8, np.int16, np.int32, np.int64,
  269:          np.uint8, np.uint16, np.uint32, np.uint64])
  270: @pytest.mark.parametrize("create", [create_with_scalar, create_with_array])
  271: def test_oob_creation(sctype, create):
  272:     iinfo = np.iinfo(sctype)
  273: 
  274:     with pytest.raises(OverflowError):
  275:         create(sctype, iinfo.min - 1)
  276: 
  277:     with pytest.raises(OverflowError):
  278:         create(sctype, iinfo.max + 1)
  279: 
  280:     with pytest.raises(OverflowError):
  281:         create(sctype, str(iinfo.min - 1))
  282: 
  283:     with pytest.raises(OverflowError):
  284:         create(sctype, str(iinfo.max + 1))
  285: 
  286:     assert create(sctype, iinfo.min) == iinfo.min
  287:     assert create(sctype, iinfo.max) == iinfo.max
