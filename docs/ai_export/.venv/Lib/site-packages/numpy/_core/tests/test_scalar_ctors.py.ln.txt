    1: """
    2: Test the scalar constructors, which also do type-coercion
    3: """
    4: import pytest
    5: 
    6: import numpy as np
    7: from numpy.testing import (
    8:     assert_almost_equal,
    9:     assert_equal,
   10:     assert_warns,
   11: )
   12: 
   13: 
   14: class TestFromString:
   15:     def test_floating(self):
   16:         # Ticket #640, floats from string
   17:         fsingle = np.single('1.234')
   18:         fdouble = np.double('1.234')
   19:         flongdouble = np.longdouble('1.234')
   20:         assert_almost_equal(fsingle, 1.234)
   21:         assert_almost_equal(fdouble, 1.234)
   22:         assert_almost_equal(flongdouble, 1.234)
   23: 
   24:     def test_floating_overflow(self):
   25:         """ Strings containing an unrepresentable float overflow """
   26:         fhalf = np.half('1e10000')
   27:         assert_equal(fhalf, np.inf)
   28:         fsingle = np.single('1e10000')
   29:         assert_equal(fsingle, np.inf)
   30:         fdouble = np.double('1e10000')
   31:         assert_equal(fdouble, np.inf)
   32:         flongdouble = assert_warns(RuntimeWarning, np.longdouble, '1e10000')
   33:         assert_equal(flongdouble, np.inf)
   34: 
   35:         fhalf = np.half('-1e10000')
   36:         assert_equal(fhalf, -np.inf)
   37:         fsingle = np.single('-1e10000')
   38:         assert_equal(fsingle, -np.inf)
   39:         fdouble = np.double('-1e10000')
   40:         assert_equal(fdouble, -np.inf)
   41:         flongdouble = assert_warns(RuntimeWarning, np.longdouble, '-1e10000')
   42:         assert_equal(flongdouble, -np.inf)
   43: 
   44: 
   45: class TestExtraArgs:
   46:     def test_superclass(self):
   47:         # try both positional and keyword arguments
   48:         s = np.str_(b'\\x61', encoding='unicode-escape')
   49:         assert s == 'a'
   50:         s = np.str_(b'\\x61', 'unicode-escape')
   51:         assert s == 'a'
   52: 
   53:         # previously this would return '\\xx'
   54:         with pytest.raises(UnicodeDecodeError):
   55:             np.str_(b'\\xx', encoding='unicode-escape')
   56:         with pytest.raises(UnicodeDecodeError):
   57:             np.str_(b'\\xx', 'unicode-escape')
   58: 
   59:         # superclass fails, but numpy succeeds
   60:         assert np.bytes_(-2) == b'-2'
   61: 
   62:     def test_datetime(self):
   63:         dt = np.datetime64('2000-01', ('M', 2))
   64:         assert np.datetime_data(dt) == ('M', 2)
   65: 
   66:         with pytest.raises(TypeError):
   67:             np.datetime64('2000', garbage=True)
   68: 
   69:     def test_bool(self):
   70:         with pytest.raises(TypeError):
   71:             np.bool(False, garbage=True)
   72: 
   73:     def test_void(self):
   74:         with pytest.raises(TypeError):
   75:             np.void(b'test', garbage=True)
   76: 
   77: 
   78: class TestFromInt:
   79:     def test_intp(self):
   80:         # Ticket #99
   81:         assert_equal(1024, np.intp(1024))
   82: 
   83:     def test_uint64_from_negative(self):
   84:         with pytest.raises(OverflowError):
   85:             np.uint64(-2)
   86: 
   87: 
   88: int_types = [np.byte, np.short, np.intc, np.long, np.longlong]
   89: uint_types = [np.ubyte, np.ushort, np.uintc, np.ulong, np.ulonglong]
   90: float_types = [np.half, np.single, np.double, np.longdouble]
   91: cfloat_types = [np.csingle, np.cdouble, np.clongdouble]
   92: 
   93: 
   94: class TestArrayFromScalar:
   95:     """ gh-15467 and gh-19125 """
   96: 
   97:     def _do_test(self, t1, t2, arg=2):
   98:         if arg is None:
   99:             x = t1()
  100:         elif isinstance(arg, tuple):
  101:             if t1 is np.clongdouble:
  102:                 pytest.xfail("creating a clongdouble from real and "
  103:                              "imaginary parts isn't supported")
  104:             x = t1(*arg)
  105:         else:
  106:             x = t1(arg)
  107:         arr = np.array(x, dtype=t2)
  108:         # type should be preserved exactly
  109:         if t2 is None:
  110:             assert arr.dtype.type is t1
  111:         else:
  112:             assert arr.dtype.type is t2
  113: 
  114:     @pytest.mark.parametrize('t1', int_types + uint_types)
  115:     @pytest.mark.parametrize('t2', int_types + uint_types + [None])
  116:     def test_integers(self, t1, t2):
  117:         return self._do_test(t1, t2)
  118: 
  119:     @pytest.mark.parametrize('t1', float_types)
  120:     @pytest.mark.parametrize('t2', float_types + [None])
  121:     def test_reals(self, t1, t2):
  122:         return self._do_test(t1, t2)
  123: 
  124:     @pytest.mark.parametrize('t1', cfloat_types)
  125:     @pytest.mark.parametrize('t2', cfloat_types + [None])
  126:     @pytest.mark.parametrize('arg', [2, 1 + 3j, (1, 2), None])
  127:     def test_complex(self, t1, t2, arg):
  128:         self._do_test(t1, t2, arg)
  129: 
  130:     @pytest.mark.parametrize('t', cfloat_types)
  131:     def test_complex_errors(self, t):
  132:         with pytest.raises(TypeError):
  133:             t(1j, 1j)
  134:         with pytest.raises(TypeError):
  135:             t(1, None)
  136:         with pytest.raises(TypeError):
  137:             t(None, 1)
  138: 
  139: 
  140: @pytest.mark.parametrize("length",
  141:         [5, np.int8(5), np.array(5, dtype=np.uint16)])
  142: def test_void_via_length(length):
  143:     res = np.void(length)
  144:     assert type(res) is np.void
  145:     assert res.item() == b"\0" * 5
  146:     assert res.dtype == "V5"
  147: 
  148: @pytest.mark.parametrize("bytes_",
  149:         [b"spam", np.array(567.)])
  150: def test_void_from_byteslike(bytes_):
  151:     res = np.void(bytes_)
  152:     expected = bytes(bytes_)
  153:     assert type(res) is np.void
  154:     assert res.item() == expected
  155: 
  156:     # Passing dtype can extend it (this is how filling works)
  157:     res = np.void(bytes_, dtype="V100")
  158:     assert type(res) is np.void
  159:     assert res.item()[:len(expected)] == expected
  160:     assert res.item()[len(expected):] == b"\0" * (res.nbytes - len(expected))
  161:     # As well as shorten:
  162:     res = np.void(bytes_, dtype="V4")
  163:     assert type(res) is np.void
  164:     assert res.item() == expected[:4]
  165: 
  166: def test_void_arraylike_trumps_byteslike():
  167:     # The memoryview is converted as an array-like of shape (18,)
  168:     # rather than a single bytes-like of that length.
  169:     m = memoryview(b"just one mintleaf?")
  170:     res = np.void(m)
  171:     assert type(res) is np.ndarray
  172:     assert res.dtype == "V1"
  173:     assert res.shape == (18,)
  174: 
  175: def test_void_dtype_arg():
  176:     # Basic test for the dtype argument (positional and keyword)
  177:     res = np.void((1, 2), dtype="i,i")
  178:     assert res.item() == (1, 2)
  179:     res = np.void((2, 3), "i,i")
  180:     assert res.item() == (2, 3)
  181: 
  182: @pytest.mark.parametrize("data",
  183:         [5, np.int8(5), np.array(5, dtype=np.uint16)])
  184: def test_void_from_integer_with_dtype(data):
  185:     # The "length" meaning is ignored, rather data is used:
  186:     res = np.void(data, dtype="i,i")
  187:     assert type(res) is np.void
  188:     assert res.dtype == "i,i"
  189:     assert res["f0"] == 5 and res["f1"] == 5
  190: 
  191: def test_void_from_structure():
  192:     dtype = np.dtype([('s', [('f', 'f8'), ('u', 'U1')]), ('i', 'i2')])
  193:     data = np.array(((1., 'a'), 2), dtype=dtype)
  194:     res = np.void(data[()], dtype=dtype)
  195:     assert type(res) is np.void
  196:     assert res.dtype == dtype
  197:     assert res == data[()]
  198: 
  199: def test_void_bad_dtype():
  200:     with pytest.raises(TypeError,
  201:             match="void: descr must be a `void.*int64"):
  202:         np.void(4, dtype="i8")
  203: 
  204:     # Subarray dtype (with shape `(4,)` is rejected):
  205:     with pytest.raises(TypeError,
  206:             match=r"void: descr must be a `void.*\(4,\)"):
  207:         np.void(4, dtype="4i")
