    1: import os
    2: import sys
    3: from ctypes import POINTER, c_double, c_float, c_int, c_longlong, cast, pointer
    4: from os import path
    5: 
    6: import pytest
    7: from numpy._core._multiarray_umath import __cpu_features__
    8: 
    9: import numpy as np
   10: from numpy.testing import assert_array_max_ulp
   11: from numpy.testing._private.utils import _glibc_older_than
   12: 
   13: UNARY_UFUNCS = [obj for obj in np._core.umath.__dict__.values() if
   14:         isinstance(obj, np.ufunc)]
   15: UNARY_OBJECT_UFUNCS = [uf for uf in UNARY_UFUNCS if "O->O" in uf.types]
   16: 
   17: # Remove functions that do not support `floats`
   18: UNARY_OBJECT_UFUNCS.remove(np.invert)
   19: UNARY_OBJECT_UFUNCS.remove(np.bitwise_count)
   20: 
   21: IS_AVX = __cpu_features__.get('AVX512F', False) or \
   22:         (__cpu_features__.get('FMA3', False) and __cpu_features__.get('AVX2', False))
   23: 
   24: IS_AVX512FP16 = __cpu_features__.get('AVX512FP16', False)
   25: 
   26: # only run on linux with AVX, also avoid old glibc (numpy/numpy#20448).
   27: runtest = (sys.platform.startswith('linux')
   28:            and IS_AVX and not _glibc_older_than("2.17"))
   29: platform_skip = pytest.mark.skipif(not runtest,
   30:                                    reason="avoid testing inconsistent platform "
   31:                                    "library implementations")
   32: 
   33: # convert string to hex function taken from:
   34: # https://stackoverflow.com/questions/1592158/convert-hex-to-float #
   35: def convert(s, datatype="np.float32"):
   36:     i = int(s, 16)                   # convert from hex to a Python int
   37:     if (datatype == "np.float64"):
   38:         cp = pointer(c_longlong(i))           # make this into a c long long integer
   39:         fp = cast(cp, POINTER(c_double))  # cast the int pointer to a double pointer
   40:     else:
   41:         cp = pointer(c_int(i))           # make this into a c integer
   42:         fp = cast(cp, POINTER(c_float))  # cast the int pointer to a float pointer
   43: 
   44:     return fp.contents.value         # dereference the pointer, get the float
   45: 
   46: 
   47: str_to_float = np.vectorize(convert)
   48: 
   49: class TestAccuracy:
   50:     @platform_skip
   51:     def test_validate_transcendentals(self):
   52:         with np.errstate(all='ignore'):
   53:             data_dir = path.join(path.dirname(__file__), 'data')
   54:             files = os.listdir(data_dir)
   55:             files = list(filter(lambda f: f.endswith('.csv'), files))
   56:             for filename in files:
   57:                 filepath = path.join(data_dir, filename)
   58:                 with open(filepath) as fid:
   59:                     file_without_comments = (
   60:                         r for r in fid if r[0] not in ('$', '#')
   61:                     )
   62:                     data = np.genfromtxt(file_without_comments,
   63:                                          dtype=('|S39', '|S39', '|S39', int),
   64:                                          names=('type', 'input', 'output', 'ulperr'),
   65:                                          delimiter=',',
   66:                                          skip_header=1)
   67:                     npname = path.splitext(filename)[0].split('-')[3]
   68:                     npfunc = getattr(np, npname)
   69:                     for datatype in np.unique(data['type']):
   70:                         data_subset = data[data['type'] == datatype]
   71:                         inval = np.array(str_to_float(data_subset['input'].astype(str), data_subset['type'].astype(str)), dtype=eval(datatype))
   72:                         outval = np.array(str_to_float(data_subset['output'].astype(str), data_subset['type'].astype(str)), dtype=eval(datatype))
   73:                         perm = np.random.permutation(len(inval))
   74:                         inval = inval[perm]
   75:                         outval = outval[perm]
   76:                         maxulperr = data_subset['ulperr'].max()
   77:                         assert_array_max_ulp(npfunc(inval), outval, maxulperr)
   78: 
   79:     @pytest.mark.skipif(IS_AVX512FP16,
   80:             reason="SVML FP16 have slightly higher ULP errors")
   81:     @pytest.mark.parametrize("ufunc", UNARY_OBJECT_UFUNCS)
   82:     def test_validate_fp16_transcendentals(self, ufunc):
   83:         with np.errstate(all='ignore'):
   84:             arr = np.arange(65536, dtype=np.int16)
   85:             datafp16 = np.frombuffer(arr.tobytes(), dtype=np.float16)
   86:             datafp32 = datafp16.astype(np.float32)
   87:             assert_array_max_ulp(ufunc(datafp16), ufunc(datafp32),
   88:                     maxulp=1, dtype=np.float16)
   89: 
   90:     @pytest.mark.skipif(not IS_AVX512FP16,
   91:                                reason="lower ULP only apply for SVML FP16")
   92:     def test_validate_svml_fp16(self):
   93:         max_ulp_err = {
   94:                 "arccos": 2.54,
   95:                 "arccosh": 2.09,
   96:                 "arcsin": 3.06,
   97:                 "arcsinh": 1.51,
   98:                 "arctan": 2.61,
   99:                 "arctanh": 1.88,
  100:                 "cbrt": 1.57,
  101:                 "cos": 1.43,
  102:                 "cosh": 1.33,
  103:                 "exp2": 1.33,
  104:                 "exp": 1.27,
  105:                 "expm1": 0.53,
  106:                 "log": 1.80,
  107:                 "log10": 1.27,
  108:                 "log1p": 1.88,
  109:                 "log2": 1.80,
  110:                 "sin": 1.88,
  111:                 "sinh": 2.05,
  112:                 "tan": 2.26,
  113:                 "tanh": 3.00,
  114:                 }
  115: 
  116:         with np.errstate(all='ignore'):
  117:             arr = np.arange(65536, dtype=np.int16)
  118:             datafp16 = np.frombuffer(arr.tobytes(), dtype=np.float16)
  119:             datafp32 = datafp16.astype(np.float32)
  120:             for func in max_ulp_err:
  121:                 ufunc = getattr(np, func)
  122:                 ulp = np.ceil(max_ulp_err[func])
  123:                 assert_array_max_ulp(ufunc(datafp16), ufunc(datafp32),
  124:                         maxulp=ulp, dtype=np.float16)
