    1: import itertools
    2: 
    3: import pytest
    4: 
    5: import numpy as np
    6: from numpy.testing import (
    7:     assert_,
    8:     assert_allclose,
    9:     assert_almost_equal,
   10:     assert_array_equal,
   11:     assert_equal,
   12:     assert_raises,
   13:     assert_raises_regex,
   14:     suppress_warnings,
   15: )
   16: 
   17: # Setup for optimize einsum
   18: chars = 'abcdefghij'
   19: sizes = np.array([2, 3, 4, 5, 4, 3, 2, 6, 5, 4, 3])
   20: global_size_dict = dict(zip(chars, sizes))
   21: 
   22: 
   23: class TestEinsum:
   24:     @pytest.mark.parametrize("do_opt", [True, False])
   25:     @pytest.mark.parametrize("einsum_fn", [np.einsum, np.einsum_path])
   26:     def test_einsum_errors(self, do_opt, einsum_fn):
   27:         # Need enough arguments
   28:         assert_raises(ValueError, einsum_fn, optimize=do_opt)
   29:         assert_raises(ValueError, einsum_fn, "", optimize=do_opt)
   30: 
   31:         # subscripts must be a string
   32:         assert_raises(TypeError, einsum_fn, 0, 0, optimize=do_opt)
   33: 
   34:         # issue 4528 revealed a segfault with this call
   35:         assert_raises(TypeError, einsum_fn, *(None,) * 63, optimize=do_opt)
   36: 
   37:         # number of operands must match count in subscripts string
   38:         assert_raises(ValueError, einsum_fn, "", 0, 0, optimize=do_opt)
   39:         assert_raises(ValueError, einsum_fn, ",", 0, [0], [0],
   40:                       optimize=do_opt)
   41:         assert_raises(ValueError, einsum_fn, ",", [0], optimize=do_opt)
   42: 
   43:         # can't have more subscripts than dimensions in the operand
   44:         assert_raises(ValueError, einsum_fn, "i", 0, optimize=do_opt)
   45:         assert_raises(ValueError, einsum_fn, "ij", [0, 0], optimize=do_opt)
   46:         assert_raises(ValueError, einsum_fn, "...i", 0, optimize=do_opt)
   47:         assert_raises(ValueError, einsum_fn, "i...j", [0, 0], optimize=do_opt)
   48:         assert_raises(ValueError, einsum_fn, "i...", 0, optimize=do_opt)
   49:         assert_raises(ValueError, einsum_fn, "ij...", [0, 0], optimize=do_opt)
   50: 
   51:         # invalid ellipsis
   52:         assert_raises(ValueError, einsum_fn, "i..", [0, 0], optimize=do_opt)
   53:         assert_raises(ValueError, einsum_fn, ".i...", [0, 0], optimize=do_opt)
   54:         assert_raises(ValueError, einsum_fn, "j->..j", [0, 0], optimize=do_opt)
   55:         assert_raises(ValueError, einsum_fn, "j->.j...", [0, 0],
   56:                       optimize=do_opt)
   57: 
   58:         # invalid subscript character
   59:         assert_raises(ValueError, einsum_fn, "i%...", [0, 0], optimize=do_opt)
   60:         assert_raises(ValueError, einsum_fn, "...j$", [0, 0], optimize=do_opt)
   61:         assert_raises(ValueError, einsum_fn, "i->&", [0, 0], optimize=do_opt)
   62: 
   63:         # output subscripts must appear in input
   64:         assert_raises(ValueError, einsum_fn, "i->ij", [0, 0], optimize=do_opt)
   65: 
   66:         # output subscripts may only be specified once
   67:         assert_raises(ValueError, einsum_fn, "ij->jij", [[0, 0], [0, 0]],
   68:                       optimize=do_opt)
   69: 
   70:         # dimensions must match when being collapsed
   71:         assert_raises(ValueError, einsum_fn, "ii",
   72:                       np.arange(6).reshape(2, 3), optimize=do_opt)
   73:         assert_raises(ValueError, einsum_fn, "ii->i",
   74:                       np.arange(6).reshape(2, 3), optimize=do_opt)
   75: 
   76:         with assert_raises_regex(ValueError, "'b'"):
   77:             # gh-11221 - 'c' erroneously appeared in the error message
   78:             a = np.ones((3, 3, 4, 5, 6))
   79:             b = np.ones((3, 4, 5))
   80:             einsum_fn('aabcb,abc', a, b)
   81: 
   82:     def test_einsum_sorting_behavior(self):
   83:         # Case 1: 26 dimensions (all lowercase indices)
   84:         n1 = 26
   85:         x1 = np.random.random((1,) * n1)
   86:         path1 = np.einsum_path(x1, range(n1))[1]  # Get einsum path details
   87:         output_indices1 = path1.split("->")[-1].strip()  # Extract output indices
   88:         # Assert indices are only uppercase letters and sorted correctly
   89:         assert all(c.isupper() for c in output_indices1), (
   90:             "Output indices for n=26 should use uppercase letters only: "
   91:             f"{output_indices1}"
   92:         )
   93:         assert_equal(
   94:             output_indices1,
   95:             ''.join(sorted(output_indices1)),
   96:             err_msg=(
   97:                 "Output indices for n=26 are not lexicographically sorted: "
   98:                 f"{output_indices1}"
   99:             )
  100:         )
  101: 
  102:         # Case 2: 27 dimensions (includes uppercase indices)
  103:         n2 = 27
  104:         x2 = np.random.random((1,) * n2)
  105:         path2 = np.einsum_path(x2, range(n2))[1]
  106:         output_indices2 = path2.split("->")[-1].strip()
  107:         # Assert indices include both uppercase and lowercase letters
  108:         assert any(c.islower() for c in output_indices2), (
  109:             "Output indices for n=27 should include uppercase letters: "
  110:             f"{output_indices2}"
  111:         )
  112:         # Assert output indices are sorted uppercase before lowercase
  113:         assert_equal(
  114:             output_indices2,
  115:             ''.join(sorted(output_indices2)),
  116:             err_msg=(
  117:                 "Output indices for n=27 are not lexicographically sorted: "
  118:                 f"{output_indices2}"
  119:             )
  120:         )
  121: 
  122:         # Additional Check: Ensure dimensions correspond correctly to indices
  123:         # Generate expected mapping of dimensions to indices
  124:         expected_indices = [
  125:             chr(i + ord('A')) if i < 26 else chr(i - 26 + ord('a'))
  126:             for i in range(n2)
  127:         ]
  128:         assert_equal(
  129:             output_indices2,
  130:             ''.join(expected_indices),
  131:             err_msg=(
  132:                 "Output indices do not map to the correct dimensions. Expected: "
  133:                 f"{''.join(expected_indices)}, Got: {output_indices2}"
  134:             )
  135:         )
  136: 
  137:     @pytest.mark.parametrize("do_opt", [True, False])
  138:     def test_einsum_specific_errors(self, do_opt):
  139:         # out parameter must be an array
  140:         assert_raises(TypeError, np.einsum, "", 0, out='test',
  141:                       optimize=do_opt)
  142: 
  143:         # order parameter must be a valid order
  144:         assert_raises(ValueError, np.einsum, "", 0, order='W',
  145:                       optimize=do_opt)
  146: 
  147:         # casting parameter must be a valid casting
  148:         assert_raises(ValueError, np.einsum, "", 0, casting='blah',
  149:                       optimize=do_opt)
  150: 
  151:         # dtype parameter must be a valid dtype
  152:         assert_raises(TypeError, np.einsum, "", 0, dtype='bad_data_type',
  153:                       optimize=do_opt)
  154: 
  155:         # other keyword arguments are rejected
  156:         assert_raises(TypeError, np.einsum, "", 0, bad_arg=0, optimize=do_opt)
  157: 
  158:         # broadcasting to new dimensions must be enabled explicitly
  159:         assert_raises(ValueError, np.einsum, "i", np.arange(6).reshape(2, 3),
  160:                       optimize=do_opt)
  161:         assert_raises(ValueError, np.einsum, "i->i", [[0, 1], [0, 1]],
  162:                       out=np.arange(4).reshape(2, 2), optimize=do_opt)
  163: 
  164:         # Check order kwarg, asanyarray allows 1d to pass through
  165:         assert_raises(ValueError, np.einsum, "i->i",
  166:                       np.arange(6).reshape(-1, 1), optimize=do_opt, order='d')
  167: 
  168:     def test_einsum_object_errors(self):
  169:         # Exceptions created by object arithmetic should
  170:         # successfully propagate
  171: 
  172:         class CustomException(Exception):
  173:             pass
  174: 
  175:         class DestructoBox:
  176: 
  177:             def __init__(self, value, destruct):
  178:                 self._val = value
  179:                 self._destruct = destruct
  180: 
  181:             def __add__(self, other):
  182:                 tmp = self._val + other._val
  183:                 if tmp >= self._destruct:
  184:                     raise CustomException
  185:                 else:
  186:                     self._val = tmp
  187:                     return self
  188: 
  189:             def __radd__(self, other):
  190:                 if other == 0:
  191:                     return self
  192:                 else:
  193:                     return self.__add__(other)
  194: 
  195:             def __mul__(self, other):
  196:                 tmp = self._val * other._val
  197:                 if tmp >= self._destruct:
  198:                     raise CustomException
  199:                 else:
  200:                     self._val = tmp
  201:                     return self
  202: 
  203:             def __rmul__(self, other):
  204:                 if other == 0:
  205:                     return self
  206:                 else:
  207:                     return self.__mul__(other)
  208: 
  209:         a = np.array([DestructoBox(i, 5) for i in range(1, 10)],
  210:                      dtype='object').reshape(3, 3)
  211: 
  212:         # raised from unbuffered_loop_nop1_ndim2
  213:         assert_raises(CustomException, np.einsum, "ij->i", a)
  214: 
  215:         # raised from unbuffered_loop_nop1_ndim3
  216:         b = np.array([DestructoBox(i, 100) for i in range(27)],
  217:                      dtype='object').reshape(3, 3, 3)
  218:         assert_raises(CustomException, np.einsum, "i...k->...", b)
  219: 
  220:         # raised from unbuffered_loop_nop2_ndim2
  221:         b = np.array([DestructoBox(i, 55) for i in range(1, 4)],
  222:                      dtype='object')
  223:         assert_raises(CustomException, np.einsum, "ij, j", a, b)
  224: 
  225:         # raised from unbuffered_loop_nop2_ndim3
  226:         assert_raises(CustomException, np.einsum, "ij, jh", a, a)
  227: 
  228:         # raised from PyArray_EinsteinSum
  229:         assert_raises(CustomException, np.einsum, "ij->", a)
  230: 
  231:     def test_einsum_views(self):
  232:         # pass-through
  233:         for do_opt in [True, False]:
  234:             a = np.arange(6)
  235:             a.shape = (2, 3)
  236: 
  237:             b = np.einsum("...", a, optimize=do_opt)
  238:             assert_(b.base is a)
  239: 
  240:             b = np.einsum(a, [Ellipsis], optimize=do_opt)
  241:             assert_(b.base is a)
  242: 
  243:             b = np.einsum("ij", a, optimize=do_opt)
  244:             assert_(b.base is a)
  245:             assert_equal(b, a)
  246: 
  247:             b = np.einsum(a, [0, 1], optimize=do_opt)
  248:             assert_(b.base is a)
  249:             assert_equal(b, a)
  250: 
  251:             # output is writeable whenever input is writeable
  252:             b = np.einsum("...", a, optimize=do_opt)
  253:             assert_(b.flags['WRITEABLE'])
  254:             a.flags['WRITEABLE'] = False
  255:             b = np.einsum("...", a, optimize=do_opt)
  256:             assert_(not b.flags['WRITEABLE'])
  257: 
  258:             # transpose
  259:             a = np.arange(6)
  260:             a.shape = (2, 3)
  261: 
  262:             b = np.einsum("ji", a, optimize=do_opt)
  263:             assert_(b.base is a)
  264:             assert_equal(b, a.T)
  265: 
  266:             b = np.einsum(a, [1, 0], optimize=do_opt)
  267:             assert_(b.base is a)
  268:             assert_equal(b, a.T)
  269: 
  270:             # diagonal
  271:             a = np.arange(9)
  272:             a.shape = (3, 3)
  273: 
  274:             b = np.einsum("ii->i", a, optimize=do_opt)
  275:             assert_(b.base is a)
  276:             assert_equal(b, [a[i, i] for i in range(3)])
  277: 
  278:             b = np.einsum(a, [0, 0], [0], optimize=do_opt)
  279:             assert_(b.base is a)
  280:             assert_equal(b, [a[i, i] for i in range(3)])
  281: 
  282:             # diagonal with various ways of broadcasting an additional dimension
  283:             a = np.arange(27)
  284:             a.shape = (3, 3, 3)
  285: 
  286:             b = np.einsum("...ii->...i", a, optimize=do_opt)
  287:             assert_(b.base is a)
  288:             assert_equal(b, [[x[i, i] for i in range(3)] for x in a])
  289: 
  290:             b = np.einsum(a, [Ellipsis, 0, 0], [Ellipsis, 0], optimize=do_opt)
  291:             assert_(b.base is a)
  292:             assert_equal(b, [[x[i, i] for i in range(3)] for x in a])
  293: 
  294:             b = np.einsum("ii...->...i", a, optimize=do_opt)
  295:             assert_(b.base is a)
  296:             assert_equal(b, [[x[i, i] for i in range(3)]
  297:                              for x in a.transpose(2, 0, 1)])
  298: 
  299:             b = np.einsum(a, [0, 0, Ellipsis], [Ellipsis, 0], optimize=do_opt)
  300:             assert_(b.base is a)
  301:             assert_equal(b, [[x[i, i] for i in range(3)]
  302:                              for x in a.transpose(2, 0, 1)])
  303: 
  304:             b = np.einsum("...ii->i...", a, optimize=do_opt)
  305:             assert_(b.base is a)
  306:             assert_equal(b, [a[:, i, i] for i in range(3)])
  307: 
  308:             b = np.einsum(a, [Ellipsis, 0, 0], [0, Ellipsis], optimize=do_opt)
  309:             assert_(b.base is a)
  310:             assert_equal(b, [a[:, i, i] for i in range(3)])
  311: 
  312:             b = np.einsum("jii->ij", a, optimize=do_opt)
  313:             assert_(b.base is a)
  314:             assert_equal(b, [a[:, i, i] for i in range(3)])
  315: 
  316:             b = np.einsum(a, [1, 0, 0], [0, 1], optimize=do_opt)
  317:             assert_(b.base is a)
  318:             assert_equal(b, [a[:, i, i] for i in range(3)])
  319: 
  320:             b = np.einsum("ii...->i...", a, optimize=do_opt)
  321:             assert_(b.base is a)
  322:             assert_equal(b, [a.transpose(2, 0, 1)[:, i, i] for i in range(3)])
  323: 
  324:             b = np.einsum(a, [0, 0, Ellipsis], [0, Ellipsis], optimize=do_opt)
  325:             assert_(b.base is a)
  326:             assert_equal(b, [a.transpose(2, 0, 1)[:, i, i] for i in range(3)])
  327: 
  328:             b = np.einsum("i...i->i...", a, optimize=do_opt)
  329:             assert_(b.base is a)
  330:             assert_equal(b, [a.transpose(1, 0, 2)[:, i, i] for i in range(3)])
  331: 
  332:             b = np.einsum(a, [0, Ellipsis, 0], [0, Ellipsis], optimize=do_opt)
  333:             assert_(b.base is a)
  334:             assert_equal(b, [a.transpose(1, 0, 2)[:, i, i] for i in range(3)])
  335: 
  336:             b = np.einsum("i...i->...i", a, optimize=do_opt)
  337:             assert_(b.base is a)
  338:             assert_equal(b, [[x[i, i] for i in range(3)]
  339:                              for x in a.transpose(1, 0, 2)])
  340: 
  341:             b = np.einsum(a, [0, Ellipsis, 0], [Ellipsis, 0], optimize=do_opt)
  342:             assert_(b.base is a)
  343:             assert_equal(b, [[x[i, i] for i in range(3)]
  344:                              for x in a.transpose(1, 0, 2)])
  345: 
  346:             # triple diagonal
  347:             a = np.arange(27)
  348:             a.shape = (3, 3, 3)
  349: 
  350:             b = np.einsum("iii->i", a, optimize=do_opt)
  351:             assert_(b.base is a)
  352:             assert_equal(b, [a[i, i, i] for i in range(3)])
  353: 
  354:             b = np.einsum(a, [0, 0, 0], [0], optimize=do_opt)
  355:             assert_(b.base is a)
  356:             assert_equal(b, [a[i, i, i] for i in range(3)])
  357: 
  358:             # swap axes
  359:             a = np.arange(24)
  360:             a.shape = (2, 3, 4)
  361: 
  362:             b = np.einsum("ijk->jik", a, optimize=do_opt)
  363:             assert_(b.base is a)
  364:             assert_equal(b, a.swapaxes(0, 1))
  365: 
  366:             b = np.einsum(a, [0, 1, 2], [1, 0, 2], optimize=do_opt)
  367:             assert_(b.base is a)
  368:             assert_equal(b, a.swapaxes(0, 1))
  369: 
  370:     def check_einsum_sums(self, dtype, do_opt=False):
  371:         dtype = np.dtype(dtype)
  372:         # Check various sums.  Does many sizes to exercise unrolled loops.
  373: 
  374:         # sum(a, axis=-1)
  375:         for n in range(1, 17):
  376:             a = np.arange(n, dtype=dtype)
  377:             b = np.sum(a, axis=-1)
  378:             if hasattr(b, 'astype'):
  379:                 b = b.astype(dtype)
  380:             assert_equal(np.einsum("i->", a, optimize=do_opt), b)
  381:             assert_equal(np.einsum(a, [0], [], optimize=do_opt), b)
  382: 
  383:         for n in range(1, 17):
  384:             a = np.arange(2 * 3 * n, dtype=dtype).reshape(2, 3, n)
  385:             b = np.sum(a, axis=-1)
  386:             if hasattr(b, 'astype'):
  387:                 b = b.astype(dtype)
  388:             assert_equal(np.einsum("...i->...", a, optimize=do_opt), b)
  389:             assert_equal(np.einsum(a, [Ellipsis, 0], [Ellipsis], optimize=do_opt), b)
  390: 
  391:         # sum(a, axis=0)
  392:         for n in range(1, 17):
  393:             a = np.arange(2 * n, dtype=dtype).reshape(2, n)
  394:             b = np.sum(a, axis=0)
  395:             if hasattr(b, 'astype'):
  396:                 b = b.astype(dtype)
  397:             assert_equal(np.einsum("i...->...", a, optimize=do_opt), b)
  398:             assert_equal(np.einsum(a, [0, Ellipsis], [Ellipsis], optimize=do_opt), b)
  399: 
  400:         for n in range(1, 17):
  401:             a = np.arange(2 * 3 * n, dtype=dtype).reshape(2, 3, n)
  402:             b = np.sum(a, axis=0)
  403:             if hasattr(b, 'astype'):
  404:                 b = b.astype(dtype)
  405:             assert_equal(np.einsum("i...->...", a, optimize=do_opt), b)
  406:             assert_equal(np.einsum(a, [0, Ellipsis], [Ellipsis], optimize=do_opt), b)
  407: 
  408:         # trace(a)
  409:         for n in range(1, 17):
  410:             a = np.arange(n * n, dtype=dtype).reshape(n, n)
  411:             b = np.trace(a)
  412:             if hasattr(b, 'astype'):
  413:                 b = b.astype(dtype)
  414:             assert_equal(np.einsum("ii", a, optimize=do_opt), b)
  415:             assert_equal(np.einsum(a, [0, 0], optimize=do_opt), b)
  416: 
  417:             # gh-15961: should accept numpy int64 type in subscript list
  418:             np_array = np.asarray([0, 0])
  419:             assert_equal(np.einsum(a, np_array, optimize=do_opt), b)
  420:             assert_equal(np.einsum(a, list(np_array), optimize=do_opt), b)
  421: 
  422:         # multiply(a, b)
  423:         assert_equal(np.einsum("..., ...", 3, 4), 12)  # scalar case
  424:         for n in range(1, 17):
  425:             a = np.arange(3 * n, dtype=dtype).reshape(3, n)
  426:             b = np.arange(2 * 3 * n, dtype=dtype).reshape(2, 3, n)
  427:             assert_equal(np.einsum("..., ...", a, b, optimize=do_opt),
  428:                          np.multiply(a, b))
  429:             assert_equal(np.einsum(a, [Ellipsis], b, [Ellipsis], optimize=do_opt),
  430:                          np.multiply(a, b))
  431: 
  432:         # inner(a,b)
  433:         for n in range(1, 17):
  434:             a = np.arange(2 * 3 * n, dtype=dtype).reshape(2, 3, n)
  435:             b = np.arange(n, dtype=dtype)
  436:             assert_equal(np.einsum("...i, ...i", a, b, optimize=do_opt), np.inner(a, b))
  437:             assert_equal(np.einsum(a, [Ellipsis, 0], b, [Ellipsis, 0], optimize=do_opt),
  438:                          np.inner(a, b))
  439: 
  440:         for n in range(1, 11):
  441:             a = np.arange(n * 3 * 2, dtype=dtype).reshape(n, 3, 2)
  442:             b = np.arange(n, dtype=dtype)
  443:             assert_equal(np.einsum("i..., i...", a, b, optimize=do_opt),
  444:                          np.inner(a.T, b.T).T)
  445:             assert_equal(np.einsum(a, [0, Ellipsis], b, [0, Ellipsis], optimize=do_opt),
  446:                          np.inner(a.T, b.T).T)
  447: 
  448:         # outer(a,b)
  449:         for n in range(1, 17):
  450:             a = np.arange(3, dtype=dtype) + 1
  451:             b = np.arange(n, dtype=dtype) + 1
  452:             assert_equal(np.einsum("i,j", a, b, optimize=do_opt),
  453:                          np.outer(a, b))
  454:             assert_equal(np.einsum(a, [0], b, [1], optimize=do_opt),
  455:                          np.outer(a, b))
  456: 
  457:         # Suppress the complex warnings for the 'as f8' tests
  458:         with suppress_warnings() as sup:
  459:             sup.filter(np.exceptions.ComplexWarning)
  460: 
  461:             # matvec(a,b) / a.dot(b) where a is matrix, b is vector
  462:             for n in range(1, 17):
  463:                 a = np.arange(4 * n, dtype=dtype).reshape(4, n)
  464:                 b = np.arange(n, dtype=dtype)
  465:                 assert_equal(np.einsum("ij, j", a, b, optimize=do_opt),
  466:                              np.dot(a, b))
  467:                 assert_equal(np.einsum(a, [0, 1], b, [1], optimize=do_opt),
  468:                              np.dot(a, b))
  469: 
  470:                 c = np.arange(4, dtype=dtype)
  471:                 np.einsum("ij,j", a, b, out=c,
  472:                           dtype='f8', casting='unsafe', optimize=do_opt)
  473:                 assert_equal(c,
  474:                              np.dot(a.astype('f8'),
  475:                                     b.astype('f8')).astype(dtype))
  476:                 c[...] = 0
  477:                 np.einsum(a, [0, 1], b, [1], out=c,
  478:                           dtype='f8', casting='unsafe', optimize=do_opt)
  479:                 assert_equal(c,
  480:                              np.dot(a.astype('f8'),
  481:                                     b.astype('f8')).astype(dtype))
  482: 
  483:             for n in range(1, 17):
  484:                 a = np.arange(4 * n, dtype=dtype).reshape(4, n)
  485:                 b = np.arange(n, dtype=dtype)
  486:                 assert_equal(np.einsum("ji,j", a.T, b.T, optimize=do_opt),
  487:                              np.dot(b.T, a.T))
  488:                 assert_equal(np.einsum(a.T, [1, 0], b.T, [1], optimize=do_opt),
  489:                              np.dot(b.T, a.T))
  490: 
  491:                 c = np.arange(4, dtype=dtype)
  492:                 np.einsum("ji,j", a.T, b.T, out=c,
  493:                           dtype='f8', casting='unsafe', optimize=do_opt)
  494:                 assert_equal(c,
  495:                              np.dot(b.T.astype('f8'),
  496:                                     a.T.astype('f8')).astype(dtype))
  497:                 c[...] = 0
  498:                 np.einsum(a.T, [1, 0], b.T, [1], out=c,
  499:                           dtype='f8', casting='unsafe', optimize=do_opt)
  500:                 assert_equal(c,
  501:                              np.dot(b.T.astype('f8'),
  502:                                     a.T.astype('f8')).astype(dtype))
  503: 
  504:             # matmat(a,b) / a.dot(b) where a is matrix, b is matrix
  505:             for n in range(1, 17):
  506:                 if n < 8 or dtype != 'f2':
  507:                     a = np.arange(4 * n, dtype=dtype).reshape(4, n)
  508:                     b = np.arange(n * 6, dtype=dtype).reshape(n, 6)
  509:                     assert_equal(np.einsum("ij,jk", a, b, optimize=do_opt),
  510:                                  np.dot(a, b))
  511:                     assert_equal(np.einsum(a, [0, 1], b, [1, 2], optimize=do_opt),
  512:                                  np.dot(a, b))
  513: 
  514:             for n in range(1, 17):
  515:                 a = np.arange(4 * n, dtype=dtype).reshape(4, n)
  516:                 b = np.arange(n * 6, dtype=dtype).reshape(n, 6)
  517:                 c = np.arange(24, dtype=dtype).reshape(4, 6)
  518:                 np.einsum("ij,jk", a, b, out=c, dtype='f8', casting='unsafe',
  519:                           optimize=do_opt)
  520:                 assert_equal(c,
  521:                              np.dot(a.astype('f8'),
  522:                                     b.astype('f8')).astype(dtype))
  523:                 c[...] = 0
  524:                 np.einsum(a, [0, 1], b, [1, 2], out=c,
  525:                           dtype='f8', casting='unsafe', optimize=do_opt)
  526:                 assert_equal(c,
  527:                              np.dot(a.astype('f8'),
  528:                                     b.astype('f8')).astype(dtype))
  529: 
  530:             # matrix triple product (note this is not currently an efficient
  531:             # way to multiply 3 matrices)
  532:             a = np.arange(12, dtype=dtype).reshape(3, 4)
  533:             b = np.arange(20, dtype=dtype).reshape(4, 5)
  534:             c = np.arange(30, dtype=dtype).reshape(5, 6)
  535:             if dtype != 'f2':
  536:                 assert_equal(np.einsum("ij,jk,kl", a, b, c, optimize=do_opt),
  537:                              a.dot(b).dot(c))
  538:                 assert_equal(np.einsum(a, [0, 1], b, [1, 2], c, [2, 3],
  539:                                        optimize=do_opt), a.dot(b).dot(c))
  540: 
  541:             d = np.arange(18, dtype=dtype).reshape(3, 6)
  542:             np.einsum("ij,jk,kl", a, b, c, out=d,
  543:                       dtype='f8', casting='unsafe', optimize=do_opt)
  544:             tgt = a.astype('f8').dot(b.astype('f8'))
  545:             tgt = tgt.dot(c.astype('f8')).astype(dtype)
  546:             assert_equal(d, tgt)
  547: 
  548:             d[...] = 0
  549:             np.einsum(a, [0, 1], b, [1, 2], c, [2, 3], out=d,
  550:                       dtype='f8', casting='unsafe', optimize=do_opt)
  551:             tgt = a.astype('f8').dot(b.astype('f8'))
  552:             tgt = tgt.dot(c.astype('f8')).astype(dtype)
  553:             assert_equal(d, tgt)
  554: 
  555:             # tensordot(a, b)
  556:             if np.dtype(dtype) != np.dtype('f2'):
  557:                 a = np.arange(60, dtype=dtype).reshape(3, 4, 5)
  558:                 b = np.arange(24, dtype=dtype).reshape(4, 3, 2)
  559:                 assert_equal(np.einsum("ijk, jil -> kl", a, b),
  560:                              np.tensordot(a, b, axes=([1, 0], [0, 1])))
  561:                 assert_equal(np.einsum(a, [0, 1, 2], b, [1, 0, 3], [2, 3]),
  562:                              np.tensordot(a, b, axes=([1, 0], [0, 1])))
  563: 
  564:                 c = np.arange(10, dtype=dtype).reshape(5, 2)
  565:                 np.einsum("ijk,jil->kl", a, b, out=c,
  566:                           dtype='f8', casting='unsafe', optimize=do_opt)
  567:                 assert_equal(c, np.tensordot(a.astype('f8'), b.astype('f8'),
  568:                              axes=([1, 0], [0, 1])).astype(dtype))
  569:                 c[...] = 0
  570:                 np.einsum(a, [0, 1, 2], b, [1, 0, 3], [2, 3], out=c,
  571:                           dtype='f8', casting='unsafe', optimize=do_opt)
  572:                 assert_equal(c, np.tensordot(a.astype('f8'), b.astype('f8'),
  573:                              axes=([1, 0], [0, 1])).astype(dtype))
  574: 
  575:         # logical_and(logical_and(a!=0, b!=0), c!=0)
  576:         neg_val = -2 if dtype.kind != "u" else np.iinfo(dtype).max - 1
  577:         a = np.array([1,   3,   neg_val, 0,  12,  13,   0,   1], dtype=dtype)
  578:         b = np.array([0,   3.5, 0., neg_val,  0,   1,    3,   12], dtype=dtype)
  579:         c = np.array([True, True, False, True, True, False, True, True])
  580: 
  581:         assert_equal(np.einsum("i,i,i->i", a, b, c,
  582:                      dtype='?', casting='unsafe', optimize=do_opt),
  583:                      np.logical_and(np.logical_and(a != 0, b != 0), c != 0))
  584:         assert_equal(np.einsum(a, [0], b, [0], c, [0], [0],
  585:                      dtype='?', casting='unsafe'),
  586:                      np.logical_and(np.logical_and(a != 0, b != 0), c != 0))
  587: 
  588:         a = np.arange(9, dtype=dtype)
  589:         assert_equal(np.einsum(",i->", 3, a), 3 * np.sum(a))
  590:         assert_equal(np.einsum(3, [], a, [0], []), 3 * np.sum(a))
  591:         assert_equal(np.einsum("i,->", a, 3), 3 * np.sum(a))
  592:         assert_equal(np.einsum(a, [0], 3, [], []), 3 * np.sum(a))
  593: 
  594:         # Various stride0, contiguous, and SSE aligned variants
  595:         for n in range(1, 25):
  596:             a = np.arange(n, dtype=dtype)
  597:             if np.dtype(dtype).itemsize > 1:
  598:                 assert_equal(np.einsum("...,...", a, a, optimize=do_opt),
  599:                              np.multiply(a, a))
  600:                 assert_equal(np.einsum("i,i", a, a, optimize=do_opt), np.dot(a, a))
  601:                 assert_equal(np.einsum("i,->i", a, 2, optimize=do_opt), 2 * a)
  602:                 assert_equal(np.einsum(",i->i", 2, a, optimize=do_opt), 2 * a)
  603:                 assert_equal(np.einsum("i,->", a, 2, optimize=do_opt), 2 * np.sum(a))
  604:                 assert_equal(np.einsum(",i->", 2, a, optimize=do_opt), 2 * np.sum(a))
  605: 
  606:                 assert_equal(np.einsum("...,...", a[1:], a[:-1], optimize=do_opt),
  607:                              np.multiply(a[1:], a[:-1]))
  608:                 assert_equal(np.einsum("i,i", a[1:], a[:-1], optimize=do_opt),
  609:                              np.dot(a[1:], a[:-1]))
  610:                 assert_equal(np.einsum("i,->i", a[1:], 2, optimize=do_opt), 2 * a[1:])
  611:                 assert_equal(np.einsum(",i->i", 2, a[1:], optimize=do_opt), 2 * a[1:])
  612:                 assert_equal(np.einsum("i,->", a[1:], 2, optimize=do_opt),
  613:                              2 * np.sum(a[1:]))
  614:                 assert_equal(np.einsum(",i->", 2, a[1:], optimize=do_opt),
  615:                              2 * np.sum(a[1:]))
  616: 
  617:         # An object array, summed as the data type
  618:         a = np.arange(9, dtype=object)
  619: 
  620:         b = np.einsum("i->", a, dtype=dtype, casting='unsafe')
  621:         assert_equal(b, np.sum(a))
  622:         if hasattr(b, "dtype"):
  623:             # Can be a python object when dtype is object
  624:             assert_equal(b.dtype, np.dtype(dtype))
  625: 
  626:         b = np.einsum(a, [0], [], dtype=dtype, casting='unsafe')
  627:         assert_equal(b, np.sum(a))
  628:         if hasattr(b, "dtype"):
  629:             # Can be a python object when dtype is object
  630:             assert_equal(b.dtype, np.dtype(dtype))
  631: 
  632:         # A case which was failing (ticket #1885)
  633:         p = np.arange(2) + 1
  634:         q = np.arange(4).reshape(2, 2) + 3
  635:         r = np.arange(4).reshape(2, 2) + 7
  636:         assert_equal(np.einsum('z,mz,zm->', p, q, r), 253)
  637: 
  638:         # singleton dimensions broadcast (gh-10343)
  639:         p = np.ones((10, 2))
  640:         q = np.ones((1, 2))
  641:         assert_array_equal(np.einsum('ij,ij->j', p, q, optimize=True),
  642:                            np.einsum('ij,ij->j', p, q, optimize=False))
  643:         assert_array_equal(np.einsum('ij,ij->j', p, q, optimize=True),
  644:                            [10.] * 2)
  645: 
  646:         # a blas-compatible contraction broadcasting case which was failing
  647:         # for optimize=True (ticket #10930)
  648:         x = np.array([2., 3.])
  649:         y = np.array([4.])
  650:         assert_array_equal(np.einsum("i, i", x, y, optimize=False), 20.)
  651:         assert_array_equal(np.einsum("i, i", x, y, optimize=True), 20.)
  652: 
  653:         # all-ones array was bypassing bug (ticket #10930)
  654:         p = np.ones((1, 5)) / 2
  655:         q = np.ones((5, 5)) / 2
  656:         for optimize in (True, False):
  657:             assert_array_equal(np.einsum("...ij,...jk->...ik", p, p,
  658:                                          optimize=optimize),
  659:                                np.einsum("...ij,...jk->...ik", p, q,
  660:                                          optimize=optimize))
  661:             assert_array_equal(np.einsum("...ij,...jk->...ik", p, q,
  662:                                          optimize=optimize),
  663:                                np.full((1, 5), 1.25))
  664: 
  665:         # Cases which were failing (gh-10899)
  666:         x = np.eye(2, dtype=dtype)
  667:         y = np.ones(2, dtype=dtype)
  668:         assert_array_equal(np.einsum("ji,i->", x, y, optimize=optimize),
  669:                            [2.])  # contig_contig_outstride0_two
  670:         assert_array_equal(np.einsum("i,ij->", y, x, optimize=optimize),
  671:                            [2.])  # stride0_contig_outstride0_two
  672:         assert_array_equal(np.einsum("ij,i->", x, y, optimize=optimize),
  673:                            [2.])  # contig_stride0_outstride0_two
  674: 
  675:     def test_einsum_sums_int8(self):
  676:         self.check_einsum_sums('i1')
  677: 
  678:     def test_einsum_sums_uint8(self):
  679:         self.check_einsum_sums('u1')
  680: 
  681:     def test_einsum_sums_int16(self):
  682:         self.check_einsum_sums('i2')
  683: 
  684:     def test_einsum_sums_uint16(self):
  685:         self.check_einsum_sums('u2')
  686: 
  687:     def test_einsum_sums_int32(self):
  688:         self.check_einsum_sums('i4')
  689:         self.check_einsum_sums('i4', True)
  690: 
  691:     def test_einsum_sums_uint32(self):
  692:         self.check_einsum_sums('u4')
  693:         self.check_einsum_sums('u4', True)
  694: 
  695:     def test_einsum_sums_int64(self):
  696:         self.check_einsum_sums('i8')
  697: 
  698:     def test_einsum_sums_uint64(self):
  699:         self.check_einsum_sums('u8')
  700: 
  701:     def test_einsum_sums_float16(self):
  702:         self.check_einsum_sums('f2')
  703: 
  704:     def test_einsum_sums_float32(self):
  705:         self.check_einsum_sums('f4')
  706: 
  707:     def test_einsum_sums_float64(self):
  708:         self.check_einsum_sums('f8')
  709:         self.check_einsum_sums('f8', True)
  710: 
  711:     def test_einsum_sums_longdouble(self):
  712:         self.check_einsum_sums(np.longdouble)
  713: 
  714:     def test_einsum_sums_cfloat64(self):
  715:         self.check_einsum_sums('c8')
  716:         self.check_einsum_sums('c8', True)
  717: 
  718:     def test_einsum_sums_cfloat128(self):
  719:         self.check_einsum_sums('c16')
  720: 
  721:     def test_einsum_sums_clongdouble(self):
  722:         self.check_einsum_sums(np.clongdouble)
  723: 
  724:     def test_einsum_sums_object(self):
  725:         self.check_einsum_sums('object')
  726:         self.check_einsum_sums('object', True)
  727: 
  728:     def test_einsum_misc(self):
  729:         # This call used to crash because of a bug in
  730:         # PyArray_AssignZero
  731:         a = np.ones((1, 2))
  732:         b = np.ones((2, 2, 1))
  733:         assert_equal(np.einsum('ij...,j...->i...', a, b), [[[2], [2]]])
  734:         assert_equal(np.einsum('ij...,j...->i...', a, b, optimize=True), [[[2], [2]]])
  735: 
  736:         # Regression test for issue #10369 (test unicode inputs with Python 2)
  737:         assert_equal(np.einsum('ij...,j...->i...', a, b), [[[2], [2]]])
  738:         assert_equal(np.einsum('...i,...i', [1, 2, 3], [2, 3, 4]), 20)
  739:         assert_equal(np.einsum('...i,...i', [1, 2, 3], [2, 3, 4],
  740:                                optimize='greedy'), 20)
  741: 
  742:         # The iterator had an issue with buffering this reduction
  743:         a = np.ones((5, 12, 4, 2, 3), np.int64)
  744:         b = np.ones((5, 12, 11), np.int64)
  745:         assert_equal(np.einsum('ijklm,ijn,ijn->', a, b, b),
  746:                      np.einsum('ijklm,ijn->', a, b))
  747:         assert_equal(np.einsum('ijklm,ijn,ijn->', a, b, b, optimize=True),
  748:                      np.einsum('ijklm,ijn->', a, b, optimize=True))
  749: 
  750:         # Issue #2027, was a problem in the contiguous 3-argument
  751:         # inner loop implementation
  752:         a = np.arange(1, 3)
  753:         b = np.arange(1, 5).reshape(2, 2)
  754:         c = np.arange(1, 9).reshape(4, 2)
  755:         assert_equal(np.einsum('x,yx,zx->xzy', a, b, c),
  756:                      [[[1,  3], [3,  9], [5, 15], [7, 21]],
  757:                      [[8, 16], [16, 32], [24, 48], [32, 64]]])
  758:         assert_equal(np.einsum('x,yx,zx->xzy', a, b, c, optimize=True),
  759:                      [[[1,  3], [3,  9], [5, 15], [7, 21]],
  760:                      [[8, 16], [16, 32], [24, 48], [32, 64]]])
  761: 
  762:         # Ensure explicitly setting out=None does not cause an error
  763:         # see issue gh-15776 and issue gh-15256
  764:         assert_equal(np.einsum('i,j', [1], [2], out=None), [[2]])
  765: 
  766:     def test_object_loop(self):
  767: 
  768:         class Mult:
  769:             def __mul__(self, other):
  770:                 return 42
  771: 
  772:         objMult = np.array([Mult()])
  773:         objNULL = np.ndarray(buffer=b'\0' * np.intp(0).itemsize, shape=1, dtype=object)
  774: 
  775:         with pytest.raises(TypeError):
  776:             np.einsum("i,j", [1], objNULL)
  777:         with pytest.raises(TypeError):
  778:             np.einsum("i,j", objNULL, [1])
  779:         assert np.einsum("i,j", objMult, objMult) == 42
  780: 
  781:     def test_subscript_range(self):
  782:         # Issue #7741, make sure that all letters of Latin alphabet (both uppercase & lowercase) can be used
  783:         # when creating a subscript from arrays
  784:         a = np.ones((2, 3))
  785:         b = np.ones((3, 4))
  786:         np.einsum(a, [0, 20], b, [20, 2], [0, 2], optimize=False)
  787:         np.einsum(a, [0, 27], b, [27, 2], [0, 2], optimize=False)
  788:         np.einsum(a, [0, 51], b, [51, 2], [0, 2], optimize=False)
  789:         assert_raises(ValueError, lambda: np.einsum(a, [0, 52], b, [52, 2], [0, 2], optimize=False))
  790:         assert_raises(ValueError, lambda: np.einsum(a, [-1, 5], b, [5, 2], [-1, 2], optimize=False))
  791: 
  792:     def test_einsum_broadcast(self):
  793:         # Issue #2455 change in handling ellipsis
  794:         # remove the 'middle broadcast' error
  795:         # only use the 'RIGHT' iteration in prepare_op_axes
  796:         # adds auto broadcast on left where it belongs
  797:         # broadcast on right has to be explicit
  798:         # We need to test the optimized parsing as well
  799: 
  800:         A = np.arange(2 * 3 * 4).reshape(2, 3, 4)
  801:         B = np.arange(3)
  802:         ref = np.einsum('ijk,j->ijk', A, B, optimize=False)
  803:         for opt in [True, False]:
  804:             assert_equal(np.einsum('ij...,j...->ij...', A, B, optimize=opt), ref)
  805:             assert_equal(np.einsum('ij...,...j->ij...', A, B, optimize=opt), ref)
  806:             assert_equal(np.einsum('ij...,j->ij...', A, B, optimize=opt), ref)  # used to raise error
  807: 
  808:         A = np.arange(12).reshape((4, 3))
  809:         B = np.arange(6).reshape((3, 2))
  810:         ref = np.einsum('ik,kj->ij', A, B, optimize=False)
  811:         for opt in [True, False]:
  812:             assert_equal(np.einsum('ik...,k...->i...', A, B, optimize=opt), ref)
  813:             assert_equal(np.einsum('ik...,...kj->i...j', A, B, optimize=opt), ref)
  814:             assert_equal(np.einsum('...k,kj', A, B, optimize=opt), ref)  # used to raise error
  815:             assert_equal(np.einsum('ik,k...->i...', A, B, optimize=opt), ref)  # used to raise error
  816: 
  817:         dims = [2, 3, 4, 5]
  818:         a = np.arange(np.prod(dims)).reshape(dims)
  819:         v = np.arange(dims[2])
  820:         ref = np.einsum('ijkl,k->ijl', a, v, optimize=False)
  821:         for opt in [True, False]:
  822:             assert_equal(np.einsum('ijkl,k', a, v, optimize=opt), ref)
  823:             assert_equal(np.einsum('...kl,k', a, v, optimize=opt), ref)  # used to raise error
  824:             assert_equal(np.einsum('...kl,k...', a, v, optimize=opt), ref)
  825: 
  826:         J, K, M = 160, 160, 120
  827:         A = np.arange(J * K * M).reshape(1, 1, 1, J, K, M)
  828:         B = np.arange(J * K * M * 3).reshape(J, K, M, 3)
  829:         ref = np.einsum('...lmn,...lmno->...o', A, B, optimize=False)
  830:         for opt in [True, False]:
  831:             assert_equal(np.einsum('...lmn,lmno->...o', A, B,
  832:                                    optimize=opt), ref)  # used to raise error
  833: 
  834:     def test_einsum_fixedstridebug(self):
  835:         # Issue #4485 obscure einsum bug
  836:         # This case revealed a bug in nditer where it reported a stride
  837:         # as 'fixed' (0) when it was in fact not fixed during processing
  838:         # (0 or 4). The reason for the bug was that the check for a fixed
  839:         # stride was using the information from the 2D inner loop reuse
  840:         # to restrict the iteration dimensions it had to validate to be
  841:         # the same, but that 2D inner loop reuse logic is only triggered
  842:         # during the buffer copying step, and hence it was invalid to
  843:         # rely on those values. The fix is to check all the dimensions
  844:         # of the stride in question, which in the test case reveals that
  845:         # the stride is not fixed.
  846:         #
  847:         # NOTE: This test is triggered by the fact that the default buffersize,
  848:         #       used by einsum, is 8192, and 3*2731 = 8193, is larger than that
  849:         #       and results in a mismatch between the buffering and the
  850:         #       striding for operand A.
  851:         A = np.arange(2 * 3).reshape(2, 3).astype(np.float32)
  852:         B = np.arange(2 * 3 * 2731).reshape(2, 3, 2731).astype(np.int16)
  853:         es = np.einsum('cl, cpx->lpx',  A,  B)
  854:         tp = np.tensordot(A,  B,  axes=(0,  0))
  855:         assert_equal(es,  tp)
  856:         # The following is the original test case from the bug report,
  857:         # made repeatable by changing random arrays to aranges.
  858:         A = np.arange(3 * 3).reshape(3, 3).astype(np.float64)
  859:         B = np.arange(3 * 3 * 64 * 64).reshape(3, 3, 64, 64).astype(np.float32)
  860:         es = np.einsum('cl, cpxy->lpxy',  A, B)
  861:         tp = np.tensordot(A, B,  axes=(0, 0))
  862:         assert_equal(es, tp)
  863: 
  864:     def test_einsum_fixed_collapsingbug(self):
  865:         # Issue #5147.
  866:         # The bug only occurred when output argument of einssum was used.
  867:         x = np.random.normal(0, 1, (5, 5, 5, 5))
  868:         y1 = np.zeros((5, 5))
  869:         np.einsum('aabb->ab', x, out=y1)
  870:         idx = np.arange(5)
  871:         y2 = x[idx[:, None], idx[:, None], idx, idx]
  872:         assert_equal(y1, y2)
  873: 
  874:     def test_einsum_failed_on_p9_and_s390x(self):
  875:         # Issues gh-14692 and gh-12689
  876:         # Bug with signed vs unsigned char errored on power9 and s390x Linux
  877:         tensor = np.random.random_sample((10, 10, 10, 10))
  878:         x = np.einsum('ijij->', tensor)
  879:         y = tensor.trace(axis1=0, axis2=2).trace()
  880:         assert_allclose(x, y)
  881: 
  882:     def test_einsum_all_contig_non_contig_output(self):
  883:         # Issue gh-5907, tests that the all contiguous special case
  884:         # actually checks the contiguity of the output
  885:         x = np.ones((5, 5))
  886:         out = np.ones(10)[::2]
  887:         correct_base = np.ones(10)
  888:         correct_base[::2] = 5
  889:         # Always worked (inner iteration is done with 0-stride):
  890:         np.einsum('mi,mi,mi->m', x, x, x, out=out)
  891:         assert_array_equal(out.base, correct_base)
  892:         # Example 1:
  893:         out = np.ones(10)[::2]
  894:         np.einsum('im,im,im->m', x, x, x, out=out)
  895:         assert_array_equal(out.base, correct_base)
  896:         # Example 2, buffering causes x to be contiguous but
  897:         # special cases do not catch the operation before:
  898:         out = np.ones((2, 2, 2))[..., 0]
  899:         correct_base = np.ones((2, 2, 2))
  900:         correct_base[..., 0] = 2
  901:         x = np.ones((2, 2), np.float32)
  902:         np.einsum('ij,jk->ik', x, x, out=out)
  903:         assert_array_equal(out.base, correct_base)
  904: 
  905:     @pytest.mark.parametrize("dtype",
  906:              np.typecodes["AllFloat"] + np.typecodes["AllInteger"])
  907:     def test_different_paths(self, dtype):
  908:         # Test originally added to cover broken float16 path: gh-20305
  909:         # Likely most are covered elsewhere, at least partially.
  910:         dtype = np.dtype(dtype)
  911:         # Simple test, designed to exercise most specialized code paths,
  912:         # note the +0.5 for floats.  This makes sure we use a float value
  913:         # where the results must be exact.
  914:         arr = (np.arange(7) + 0.5).astype(dtype)
  915:         scalar = np.array(2, dtype=dtype)
  916: 
  917:         # contig -> scalar:
  918:         res = np.einsum('i->', arr)
  919:         assert res == arr.sum()
  920:         # contig, contig -> contig:
  921:         res = np.einsum('i,i->i', arr, arr)
  922:         assert_array_equal(res, arr * arr)
  923:         # noncontig, noncontig -> contig:
  924:         res = np.einsum('i,i->i', arr.repeat(2)[::2], arr.repeat(2)[::2])
  925:         assert_array_equal(res, arr * arr)
  926:         # contig + contig -> scalar
  927:         assert np.einsum('i,i->', arr, arr) == (arr * arr).sum()
  928:         # contig + scalar -> contig (with out)
  929:         out = np.ones(7, dtype=dtype)
  930:         res = np.einsum('i,->i', arr, dtype.type(2), out=out)
  931:         assert_array_equal(res, arr * dtype.type(2))
  932:         # scalar + contig -> contig (with out)
  933:         res = np.einsum(',i->i', scalar, arr)
  934:         assert_array_equal(res, arr * dtype.type(2))
  935:         # scalar + contig -> scalar
  936:         res = np.einsum(',i->', scalar, arr)
  937:         # Use einsum to compare to not have difference due to sum round-offs:
  938:         assert res == np.einsum('i->', scalar * arr)
  939:         # contig + scalar -> scalar
  940:         res = np.einsum('i,->', arr, scalar)
  941:         # Use einsum to compare to not have difference due to sum round-offs:
  942:         assert res == np.einsum('i->', scalar * arr)
  943:         # contig + contig + contig -> scalar
  944:         arr = np.array([0.5, 0.5, 0.25, 4.5, 3.], dtype=dtype)
  945:         res = np.einsum('i,i,i->', arr, arr, arr)
  946:         assert_array_equal(res, (arr * arr * arr).sum())
  947:         # four arrays:
  948:         res = np.einsum('i,i,i,i->', arr, arr, arr, arr)
  949:         assert_array_equal(res, (arr * arr * arr * arr).sum())
  950: 
  951:     def test_small_boolean_arrays(self):
  952:         # See gh-5946.
  953:         # Use array of True embedded in False.
  954:         a = np.zeros((16, 1, 1), dtype=np.bool)[:2]
  955:         a[...] = True
  956:         out = np.zeros((16, 1, 1), dtype=np.bool)[:2]
  957:         tgt = np.ones((2, 1, 1), dtype=np.bool)
  958:         res = np.einsum('...ij,...jk->...ik', a, a, out=out)
  959:         assert_equal(res, tgt)
  960: 
  961:     def test_out_is_res(self):
  962:         a = np.arange(9).reshape(3, 3)
  963:         res = np.einsum('...ij,...jk->...ik', a, a, out=a)
  964:         assert res is a
  965: 
  966:     def optimize_compare(self, subscripts, operands=None):
  967:         # Tests all paths of the optimization function against
  968:         # conventional einsum
  969:         if operands is None:
  970:             args = [subscripts]
  971:             terms = subscripts.split('->')[0].split(',')
  972:             for term in terms:
  973:                 dims = [global_size_dict[x] for x in term]
  974:                 args.append(np.random.rand(*dims))
  975:         else:
  976:             args = [subscripts] + operands
  977: 
  978:         noopt = np.einsum(*args, optimize=False)
  979:         opt = np.einsum(*args, optimize='greedy')
  980:         assert_almost_equal(opt, noopt)
  981:         opt = np.einsum(*args, optimize='optimal')
  982:         assert_almost_equal(opt, noopt)
  983: 
  984:     def test_hadamard_like_products(self):
  985:         # Hadamard outer products
  986:         self.optimize_compare('a,ab,abc->abc')
  987:         self.optimize_compare('a,b,ab->ab')
  988: 
  989:     def test_index_transformations(self):
  990:         # Simple index transformation cases
  991:         self.optimize_compare('ea,fb,gc,hd,abcd->efgh')
  992:         self.optimize_compare('ea,fb,abcd,gc,hd->efgh')
  993:         self.optimize_compare('abcd,ea,fb,gc,hd->efgh')
  994: 
  995:     def test_complex(self):
  996:         # Long test cases
  997:         self.optimize_compare('acdf,jbje,gihb,hfac,gfac,gifabc,hfac')
  998:         self.optimize_compare('acdf,jbje,gihb,hfac,gfac,gifabc,hfac')
  999:         self.optimize_compare('cd,bdhe,aidb,hgca,gc,hgibcd,hgac')
 1000:         self.optimize_compare('abhe,hidj,jgba,hiab,gab')
 1001:         self.optimize_compare('bde,cdh,agdb,hica,ibd,hgicd,hiac')
 1002:         self.optimize_compare('chd,bde,agbc,hiad,hgc,hgi,hiad')
 1003:         self.optimize_compare('chd,bde,agbc,hiad,bdi,cgh,agdb')
 1004:         self.optimize_compare('bdhe,acad,hiab,agac,hibd')
 1005: 
 1006:     def test_collapse(self):
 1007:         # Inner products
 1008:         self.optimize_compare('ab,ab,c->')
 1009:         self.optimize_compare('ab,ab,c->c')
 1010:         self.optimize_compare('ab,ab,cd,cd->')
 1011:         self.optimize_compare('ab,ab,cd,cd->ac')
 1012:         self.optimize_compare('ab,ab,cd,cd->cd')
 1013:         self.optimize_compare('ab,ab,cd,cd,ef,ef->')
 1014: 
 1015:     def test_expand(self):
 1016:         # Outer products
 1017:         self.optimize_compare('ab,cd,ef->abcdef')
 1018:         self.optimize_compare('ab,cd,ef->acdf')
 1019:         self.optimize_compare('ab,cd,de->abcde')
 1020:         self.optimize_compare('ab,cd,de->be')
 1021:         self.optimize_compare('ab,bcd,cd->abcd')
 1022:         self.optimize_compare('ab,bcd,cd->abd')
 1023: 
 1024:     def test_edge_cases(self):
 1025:         # Difficult edge cases for optimization
 1026:         self.optimize_compare('eb,cb,fb->cef')
 1027:         self.optimize_compare('dd,fb,be,cdb->cef')
 1028:         self.optimize_compare('bca,cdb,dbf,afc->')
 1029:         self.optimize_compare('dcc,fce,ea,dbf->ab')
 1030:         self.optimize_compare('fdf,cdd,ccd,afe->ae')
 1031:         self.optimize_compare('abcd,ad')
 1032:         self.optimize_compare('ed,fcd,ff,bcf->be')
 1033:         self.optimize_compare('baa,dcf,af,cde->be')
 1034:         self.optimize_compare('bd,db,eac->ace')
 1035:         self.optimize_compare('fff,fae,bef,def->abd')
 1036:         self.optimize_compare('efc,dbc,acf,fd->abe')
 1037:         self.optimize_compare('ba,ac,da->bcd')
 1038: 
 1039:     def test_inner_product(self):
 1040:         # Inner products
 1041:         self.optimize_compare('ab,ab')
 1042:         self.optimize_compare('ab,ba')
 1043:         self.optimize_compare('abc,abc')
 1044:         self.optimize_compare('abc,bac')
 1045:         self.optimize_compare('abc,cba')
 1046: 
 1047:     def test_random_cases(self):
 1048:         # Randomly built test cases
 1049:         self.optimize_compare('aab,fa,df,ecc->bde')
 1050:         self.optimize_compare('ecb,fef,bad,ed->ac')
 1051:         self.optimize_compare('bcf,bbb,fbf,fc->')
 1052:         self.optimize_compare('bb,ff,be->e')
 1053:         self.optimize_compare('bcb,bb,fc,fff->')
 1054:         self.optimize_compare('fbb,dfd,fc,fc->')
 1055:         self.optimize_compare('afd,ba,cc,dc->bf')
 1056:         self.optimize_compare('adb,bc,fa,cfc->d')
 1057:         self.optimize_compare('bbd,bda,fc,db->acf')
 1058:         self.optimize_compare('dba,ead,cad->bce')
 1059:         self.optimize_compare('aef,fbc,dca->bde')
 1060: 
 1061:     def test_combined_views_mapping(self):
 1062:         # gh-10792
 1063:         a = np.arange(9).reshape(1, 1, 3, 1, 3)
 1064:         b = np.einsum('bbcdc->d', a)
 1065:         assert_equal(b, [12])
 1066: 
 1067:     def test_broadcasting_dot_cases(self):
 1068:         # Ensures broadcasting cases are not mistaken for GEMM
 1069: 
 1070:         a = np.random.rand(1, 5, 4)
 1071:         b = np.random.rand(4, 6)
 1072:         c = np.random.rand(5, 6)
 1073:         d = np.random.rand(10)
 1074: 
 1075:         self.optimize_compare('ijk,kl,jl', operands=[a, b, c])
 1076:         self.optimize_compare('ijk,kl,jl,i->i', operands=[a, b, c, d])
 1077: 
 1078:         e = np.random.rand(1, 1, 5, 4)
 1079:         f = np.random.rand(7, 7)
 1080:         self.optimize_compare('abjk,kl,jl', operands=[e, b, c])
 1081:         self.optimize_compare('abjk,kl,jl,ab->ab', operands=[e, b, c, f])
 1082: 
 1083:         # Edge case found in gh-11308
 1084:         g = np.arange(64).reshape(2, 4, 8)
 1085:         self.optimize_compare('obk,ijk->ioj', operands=[g, g])
 1086: 
 1087:     def test_output_order(self):
 1088:         # Ensure output order is respected for optimize cases, the below
 1089:         # contraction should yield a reshaped tensor view
 1090:         # gh-16415
 1091: 
 1092:         a = np.ones((2, 3, 5), order='F')
 1093:         b = np.ones((4, 3), order='F')
 1094: 
 1095:         for opt in [True, False]:
 1096:             tmp = np.einsum('...ft,mf->...mt', a, b, order='a', optimize=opt)
 1097:             assert_(tmp.flags.f_contiguous)
 1098: 
 1099:             tmp = np.einsum('...ft,mf->...mt', a, b, order='f', optimize=opt)
 1100:             assert_(tmp.flags.f_contiguous)
 1101: 
 1102:             tmp = np.einsum('...ft,mf->...mt', a, b, order='c', optimize=opt)
 1103:             assert_(tmp.flags.c_contiguous)
 1104: 
 1105:             tmp = np.einsum('...ft,mf->...mt', a, b, order='k', optimize=opt)
 1106:             assert_(tmp.flags.c_contiguous is False)
 1107:             assert_(tmp.flags.f_contiguous is False)
 1108: 
 1109:             tmp = np.einsum('...ft,mf->...mt', a, b, optimize=opt)
 1110:             assert_(tmp.flags.c_contiguous is False)
 1111:             assert_(tmp.flags.f_contiguous is False)
 1112: 
 1113:         c = np.ones((4, 3), order='C')
 1114:         for opt in [True, False]:
 1115:             tmp = np.einsum('...ft,mf->...mt', a, c, order='a', optimize=opt)
 1116:             assert_(tmp.flags.c_contiguous)
 1117: 
 1118:         d = np.ones((2, 3, 5), order='C')
 1119:         for opt in [True, False]:
 1120:             tmp = np.einsum('...ft,mf->...mt', d, c, order='a', optimize=opt)
 1121:             assert_(tmp.flags.c_contiguous)
 1122: 
 1123: class TestEinsumPath:
 1124:     def build_operands(self, string, size_dict=global_size_dict):
 1125: 
 1126:         # Builds views based off initial operands
 1127:         operands = [string]
 1128:         terms = string.split('->')[0].split(',')
 1129:         for term in terms:
 1130:             dims = [size_dict[x] for x in term]
 1131:             operands.append(np.random.rand(*dims))
 1132: 
 1133:         return operands
 1134: 
 1135:     def assert_path_equal(self, comp, benchmark):
 1136:         # Checks if list of tuples are equivalent
 1137:         ret = (len(comp) == len(benchmark))
 1138:         assert_(ret)
 1139:         for pos in range(len(comp) - 1):
 1140:             ret &= isinstance(comp[pos + 1], tuple)
 1141:             ret &= (comp[pos + 1] == benchmark[pos + 1])
 1142:         assert_(ret)
 1143: 
 1144:     def test_memory_contraints(self):
 1145:         # Ensure memory constraints are satisfied
 1146: 
 1147:         outer_test = self.build_operands('a,b,c->abc')
 1148: 
 1149:         path, path_str = np.einsum_path(*outer_test, optimize=('greedy', 0))
 1150:         self.assert_path_equal(path, ['einsum_path', (0, 1, 2)])
 1151: 
 1152:         path, path_str = np.einsum_path(*outer_test, optimize=('optimal', 0))
 1153:         self.assert_path_equal(path, ['einsum_path', (0, 1, 2)])
 1154: 
 1155:         long_test = self.build_operands('acdf,jbje,gihb,hfac')
 1156:         path, path_str = np.einsum_path(*long_test, optimize=('greedy', 0))
 1157:         self.assert_path_equal(path, ['einsum_path', (0, 1, 2, 3)])
 1158: 
 1159:         path, path_str = np.einsum_path(*long_test, optimize=('optimal', 0))
 1160:         self.assert_path_equal(path, ['einsum_path', (0, 1, 2, 3)])
 1161: 
 1162:     def test_long_paths(self):
 1163:         # Long complex cases
 1164: 
 1165:         # Long test 1
 1166:         long_test1 = self.build_operands('acdf,jbje,gihb,hfac,gfac,gifabc,hfac')
 1167:         path, path_str = np.einsum_path(*long_test1, optimize='greedy')
 1168:         self.assert_path_equal(path, ['einsum_path',
 1169:                                       (3, 6), (3, 4), (2, 4), (2, 3), (0, 2), (0, 1)])
 1170: 
 1171:         path, path_str = np.einsum_path(*long_test1, optimize='optimal')
 1172:         self.assert_path_equal(path, ['einsum_path',
 1173:                                       (3, 6), (3, 4), (2, 4), (2, 3), (0, 2), (0, 1)])
 1174: 
 1175:         # Long test 2
 1176:         long_test2 = self.build_operands('chd,bde,agbc,hiad,bdi,cgh,agdb')
 1177:         path, path_str = np.einsum_path(*long_test2, optimize='greedy')
 1178:         self.assert_path_equal(path, ['einsum_path',
 1179:                                       (3, 4), (0, 3), (3, 4), (1, 3), (1, 2), (0, 1)])
 1180: 
 1181:         path, path_str = np.einsum_path(*long_test2, optimize='optimal')
 1182:         self.assert_path_equal(path, ['einsum_path',
 1183:                                       (0, 5), (1, 4), (3, 4), (1, 3), (1, 2), (0, 1)])
 1184: 
 1185:     def test_edge_paths(self):
 1186:         # Difficult edge cases
 1187: 
 1188:         # Edge test1
 1189:         edge_test1 = self.build_operands('eb,cb,fb->cef')
 1190:         path, path_str = np.einsum_path(*edge_test1, optimize='greedy')
 1191:         self.assert_path_equal(path, ['einsum_path', (0, 2), (0, 1)])
 1192: 
 1193:         path, path_str = np.einsum_path(*edge_test1, optimize='optimal')
 1194:         self.assert_path_equal(path, ['einsum_path', (0, 2), (0, 1)])
 1195: 
 1196:         # Edge test2
 1197:         edge_test2 = self.build_operands('dd,fb,be,cdb->cef')
 1198:         path, path_str = np.einsum_path(*edge_test2, optimize='greedy')
 1199:         self.assert_path_equal(path, ['einsum_path', (0, 3), (0, 1), (0, 1)])
 1200: 
 1201:         path, path_str = np.einsum_path(*edge_test2, optimize='optimal')
 1202:         self.assert_path_equal(path, ['einsum_path', (0, 3), (0, 1), (0, 1)])
 1203: 
 1204:         # Edge test3
 1205:         edge_test3 = self.build_operands('bca,cdb,dbf,afc->')
 1206:         path, path_str = np.einsum_path(*edge_test3, optimize='greedy')
 1207:         self.assert_path_equal(path, ['einsum_path', (1, 2), (0, 2), (0, 1)])
 1208: 
 1209:         path, path_str = np.einsum_path(*edge_test3, optimize='optimal')
 1210:         self.assert_path_equal(path, ['einsum_path', (1, 2), (0, 2), (0, 1)])
 1211: 
 1212:         # Edge test4
 1213:         edge_test4 = self.build_operands('dcc,fce,ea,dbf->ab')
 1214:         path, path_str = np.einsum_path(*edge_test4, optimize='greedy')
 1215:         self.assert_path_equal(path, ['einsum_path', (1, 2), (0, 1), (0, 1)])
 1216: 
 1217:         path, path_str = np.einsum_path(*edge_test4, optimize='optimal')
 1218:         self.assert_path_equal(path, ['einsum_path', (1, 2), (0, 2), (0, 1)])
 1219: 
 1220:         # Edge test5
 1221:         edge_test4 = self.build_operands('a,ac,ab,ad,cd,bd,bc->',
 1222:                                          size_dict={"a": 20, "b": 20, "c": 20, "d": 20})
 1223:         path, path_str = np.einsum_path(*edge_test4, optimize='greedy')
 1224:         self.assert_path_equal(path, ['einsum_path', (0, 1), (0, 1, 2, 3, 4, 5)])
 1225: 
 1226:         path, path_str = np.einsum_path(*edge_test4, optimize='optimal')
 1227:         self.assert_path_equal(path, ['einsum_path', (0, 1), (0, 1, 2, 3, 4, 5)])
 1228: 
 1229:     def test_path_type_input(self):
 1230:         # Test explicit path handling
 1231:         path_test = self.build_operands('dcc,fce,ea,dbf->ab')
 1232: 
 1233:         path, path_str = np.einsum_path(*path_test, optimize=False)
 1234:         self.assert_path_equal(path, ['einsum_path', (0, 1, 2, 3)])
 1235: 
 1236:         path, path_str = np.einsum_path(*path_test, optimize=True)
 1237:         self.assert_path_equal(path, ['einsum_path', (1, 2), (0, 1), (0, 1)])
 1238: 
 1239:         exp_path = ['einsum_path', (0, 2), (0, 2), (0, 1)]
 1240:         path, path_str = np.einsum_path(*path_test, optimize=exp_path)
 1241:         self.assert_path_equal(path, exp_path)
 1242: 
 1243:         # Double check einsum works on the input path
 1244:         noopt = np.einsum(*path_test, optimize=False)
 1245:         opt = np.einsum(*path_test, optimize=exp_path)
 1246:         assert_almost_equal(noopt, opt)
 1247: 
 1248:     def test_path_type_input_internal_trace(self):
 1249:         # gh-20962
 1250:         path_test = self.build_operands('cab,cdd->ab')
 1251:         exp_path = ['einsum_path', (1,), (0, 1)]
 1252: 
 1253:         path, path_str = np.einsum_path(*path_test, optimize=exp_path)
 1254:         self.assert_path_equal(path, exp_path)
 1255: 
 1256:         # Double check einsum works on the input path
 1257:         noopt = np.einsum(*path_test, optimize=False)
 1258:         opt = np.einsum(*path_test, optimize=exp_path)
 1259:         assert_almost_equal(noopt, opt)
 1260: 
 1261:     def test_path_type_input_invalid(self):
 1262:         path_test = self.build_operands('ab,bc,cd,de->ae')
 1263:         exp_path = ['einsum_path', (2, 3), (0, 1)]
 1264:         assert_raises(RuntimeError, np.einsum, *path_test, optimize=exp_path)
 1265:         assert_raises(
 1266:             RuntimeError, np.einsum_path, *path_test, optimize=exp_path)
 1267: 
 1268:         path_test = self.build_operands('a,a,a->a')
 1269:         exp_path = ['einsum_path', (1,), (0, 1)]
 1270:         assert_raises(RuntimeError, np.einsum, *path_test, optimize=exp_path)
 1271:         assert_raises(
 1272:             RuntimeError, np.einsum_path, *path_test, optimize=exp_path)
 1273: 
 1274:     def test_spaces(self):
 1275:         # gh-10794
 1276:         arr = np.array([[1]])
 1277:         for sp in itertools.product(['', ' '], repeat=4):
 1278:             # no error for any spacing
 1279:             np.einsum('{}...a{}->{}...a{}'.format(*sp), arr)
 1280: 
 1281: def test_overlap():
 1282:     a = np.arange(9, dtype=int).reshape(3, 3)
 1283:     b = np.arange(9, dtype=int).reshape(3, 3)
 1284:     d = np.dot(a, b)
 1285:     # sanity check
 1286:     c = np.einsum('ij,jk->ik', a, b)
 1287:     assert_equal(c, d)
 1288:     # gh-10080, out overlaps one of the operands
 1289:     c = np.einsum('ij,jk->ik', a, b, out=b)
 1290:     assert_equal(c, d)
 1291: 
 1292: def test_einsum_chunking_precision():
 1293:     """Most einsum operations are reductions and until NumPy 2.3 reductions
 1294:     never (or almost never?) used the `GROWINNER` mechanism to increase the
 1295:     inner loop size when no buffers are needed.
 1296:     Because einsum reductions work roughly:
 1297: 
 1298:         def inner(*inputs, out):
 1299:             accumulate = 0
 1300:             for vals in zip(*inputs):
 1301:                 accumulate += prod(vals)
 1302:             out[0] += accumulate
 1303: 
 1304:     Calling the inner-loop more often actually improves accuracy slightly
 1305:     (same effect as pairwise summation but much less).
 1306:     Without adding pairwise summation to the inner-loop it seems best to just
 1307:     not use GROWINNER, a quick tests suggest that is maybe 1% slowdown for
 1308:     the simplest `einsum("i,i->i", x, x)` case.
 1309: 
 1310:     (It is not clear that we should guarantee precision to this extend.)
 1311:     """
 1312:     num = 1_000_000
 1313:     value = 1. + np.finfo(np.float64).eps * 8196
 1314:     res = np.einsum("i->", np.broadcast_to(np.array(value), num)) / num
 1315: 
 1316:     # At with GROWINNER 11 decimals succeed (larger will be less)
 1317:     assert_almost_equal(res, value, decimal=15)
