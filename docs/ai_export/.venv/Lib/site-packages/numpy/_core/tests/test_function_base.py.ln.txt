    1: import platform
    2: import sys
    3: 
    4: import pytest
    5: 
    6: import numpy as np
    7: from numpy import (
    8:     arange,
    9:     array,
   10:     dtype,
   11:     errstate,
   12:     geomspace,
   13:     isnan,
   14:     linspace,
   15:     logspace,
   16:     ndarray,
   17:     nextafter,
   18:     sqrt,
   19:     stack,
   20: )
   21: from numpy._core import sctypes
   22: from numpy._core.function_base import add_newdoc
   23: from numpy.testing import (
   24:     IS_PYPY,
   25:     assert_,
   26:     assert_allclose,
   27:     assert_array_equal,
   28:     assert_equal,
   29:     assert_raises,
   30: )
   31: 
   32: 
   33: def _is_armhf():
   34:     # Check if the current platform is ARMHF (32-bit ARM architecture)
   35:     return platform.machine().startswith('arm') and platform.architecture()[0] == '32bit'
   36: 
   37: class PhysicalQuantity(float):
   38:     def __new__(cls, value):
   39:         return float.__new__(cls, value)
   40: 
   41:     def __add__(self, x):
   42:         assert_(isinstance(x, PhysicalQuantity))
   43:         return PhysicalQuantity(float(x) + float(self))
   44:     __radd__ = __add__
   45: 
   46:     def __sub__(self, x):
   47:         assert_(isinstance(x, PhysicalQuantity))
   48:         return PhysicalQuantity(float(self) - float(x))
   49: 
   50:     def __rsub__(self, x):
   51:         assert_(isinstance(x, PhysicalQuantity))
   52:         return PhysicalQuantity(float(x) - float(self))
   53: 
   54:     def __mul__(self, x):
   55:         return PhysicalQuantity(float(x) * float(self))
   56:     __rmul__ = __mul__
   57: 
   58:     def __truediv__(self, x):
   59:         return PhysicalQuantity(float(self) / float(x))
   60: 
   61:     def __rtruediv__(self, x):
   62:         return PhysicalQuantity(float(x) / float(self))
   63: 
   64: 
   65: class PhysicalQuantity2(ndarray):
   66:     __array_priority__ = 10
   67: 
   68: 
   69: class TestLogspace:
   70: 
   71:     def test_basic(self):
   72:         y = logspace(0, 6)
   73:         assert_(len(y) == 50)
   74:         y = logspace(0, 6, num=100)
   75:         assert_(y[-1] == 10 ** 6)
   76:         y = logspace(0, 6, endpoint=False)
   77:         assert_(y[-1] < 10 ** 6)
   78:         y = logspace(0, 6, num=7)
   79:         assert_array_equal(y, [1, 10, 100, 1e3, 1e4, 1e5, 1e6])
   80: 
   81:     def test_start_stop_array(self):
   82:         start = array([0., 1.])
   83:         stop = array([6., 7.])
   84:         t1 = logspace(start, stop, 6)
   85:         t2 = stack([logspace(_start, _stop, 6)
   86:                     for _start, _stop in zip(start, stop)], axis=1)
   87:         assert_equal(t1, t2)
   88:         t3 = logspace(start, stop[0], 6)
   89:         t4 = stack([logspace(_start, stop[0], 6)
   90:                     for _start in start], axis=1)
   91:         assert_equal(t3, t4)
   92:         t5 = logspace(start, stop, 6, axis=-1)
   93:         assert_equal(t5, t2.T)
   94: 
   95:     @pytest.mark.parametrize("axis", [0, 1, -1])
   96:     def test_base_array(self, axis: int):
   97:         start = 1
   98:         stop = 2
   99:         num = 6
  100:         base = array([1, 2])
  101:         t1 = logspace(start, stop, num=num, base=base, axis=axis)
  102:         t2 = stack(
  103:             [logspace(start, stop, num=num, base=_base) for _base in base],
  104:             axis=(axis + 1) % t1.ndim,
  105:         )
  106:         assert_equal(t1, t2)
  107: 
  108:     @pytest.mark.parametrize("axis", [0, 1, -1])
  109:     def test_stop_base_array(self, axis: int):
  110:         start = 1
  111:         stop = array([2, 3])
  112:         num = 6
  113:         base = array([1, 2])
  114:         t1 = logspace(start, stop, num=num, base=base, axis=axis)
  115:         t2 = stack(
  116:             [logspace(start, _stop, num=num, base=_base)
  117:              for _stop, _base in zip(stop, base)],
  118:             axis=(axis + 1) % t1.ndim,
  119:         )
  120:         assert_equal(t1, t2)
  121: 
  122:     def test_dtype(self):
  123:         y = logspace(0, 6, dtype='float32')
  124:         assert_equal(y.dtype, dtype('float32'))
  125:         y = logspace(0, 6, dtype='float64')
  126:         assert_equal(y.dtype, dtype('float64'))
  127:         y = logspace(0, 6, dtype='int32')
  128:         assert_equal(y.dtype, dtype('int32'))
  129: 
  130:     def test_physical_quantities(self):
  131:         a = PhysicalQuantity(1.0)
  132:         b = PhysicalQuantity(5.0)
  133:         assert_equal(logspace(a, b), logspace(1.0, 5.0))
  134: 
  135:     def test_subclass(self):
  136:         a = array(1).view(PhysicalQuantity2)
  137:         b = array(7).view(PhysicalQuantity2)
  138:         ls = logspace(a, b)
  139:         assert type(ls) is PhysicalQuantity2
  140:         assert_equal(ls, logspace(1.0, 7.0))
  141:         ls = logspace(a, b, 1)
  142:         assert type(ls) is PhysicalQuantity2
  143:         assert_equal(ls, logspace(1.0, 7.0, 1))
  144: 
  145: 
  146: class TestGeomspace:
  147: 
  148:     def test_basic(self):
  149:         y = geomspace(1, 1e6)
  150:         assert_(len(y) == 50)
  151:         y = geomspace(1, 1e6, num=100)
  152:         assert_(y[-1] == 10 ** 6)
  153:         y = geomspace(1, 1e6, endpoint=False)
  154:         assert_(y[-1] < 10 ** 6)
  155:         y = geomspace(1, 1e6, num=7)
  156:         assert_array_equal(y, [1, 10, 100, 1e3, 1e4, 1e5, 1e6])
  157: 
  158:         y = geomspace(8, 2, num=3)
  159:         assert_allclose(y, [8, 4, 2])
  160:         assert_array_equal(y.imag, 0)
  161: 
  162:         y = geomspace(-1, -100, num=3)
  163:         assert_array_equal(y, [-1, -10, -100])
  164:         assert_array_equal(y.imag, 0)
  165: 
  166:         y = geomspace(-100, -1, num=3)
  167:         assert_array_equal(y, [-100, -10, -1])
  168:         assert_array_equal(y.imag, 0)
  169: 
  170:     def test_boundaries_match_start_and_stop_exactly(self):
  171:         # make sure that the boundaries of the returned array exactly
  172:         # equal 'start' and 'stop' - this isn't obvious because
  173:         # np.exp(np.log(x)) isn't necessarily exactly equal to x
  174:         start = 0.3
  175:         stop = 20.3
  176: 
  177:         y = geomspace(start, stop, num=1)
  178:         assert_equal(y[0], start)
  179: 
  180:         y = geomspace(start, stop, num=1, endpoint=False)
  181:         assert_equal(y[0], start)
  182: 
  183:         y = geomspace(start, stop, num=3)
  184:         assert_equal(y[0], start)
  185:         assert_equal(y[-1], stop)
  186: 
  187:         y = geomspace(start, stop, num=3, endpoint=False)
  188:         assert_equal(y[0], start)
  189: 
  190:     def test_nan_interior(self):
  191:         with errstate(invalid='ignore'):
  192:             y = geomspace(-3, 3, num=4)
  193: 
  194:         assert_equal(y[0], -3.0)
  195:         assert_(isnan(y[1:-1]).all())
  196:         assert_equal(y[3], 3.0)
  197: 
  198:         with errstate(invalid='ignore'):
  199:             y = geomspace(-3, 3, num=4, endpoint=False)
  200: 
  201:         assert_equal(y[0], -3.0)
  202:         assert_(isnan(y[1:]).all())
  203: 
  204:     def test_complex(self):
  205:         # Purely imaginary
  206:         y = geomspace(1j, 16j, num=5)
  207:         assert_allclose(y, [1j, 2j, 4j, 8j, 16j])
  208:         assert_array_equal(y.real, 0)
  209: 
  210:         y = geomspace(-4j, -324j, num=5)
  211:         assert_allclose(y, [-4j, -12j, -36j, -108j, -324j])
  212:         assert_array_equal(y.real, 0)
  213: 
  214:         y = geomspace(1 + 1j, 1000 + 1000j, num=4)
  215:         assert_allclose(y, [1 + 1j, 10 + 10j, 100 + 100j, 1000 + 1000j])
  216: 
  217:         y = geomspace(-1 + 1j, -1000 + 1000j, num=4)
  218:         assert_allclose(y, [-1 + 1j, -10 + 10j, -100 + 100j, -1000 + 1000j])
  219: 
  220:         # Logarithmic spirals
  221:         y = geomspace(-1, 1, num=3, dtype=complex)
  222:         assert_allclose(y, [-1, 1j, +1])
  223: 
  224:         y = geomspace(0 + 3j, -3 + 0j, 3)
  225:         assert_allclose(y, [0 + 3j, -3 / sqrt(2) + 3j / sqrt(2), -3 + 0j])
  226:         y = geomspace(0 + 3j, 3 + 0j, 3)
  227:         assert_allclose(y, [0 + 3j, 3 / sqrt(2) + 3j / sqrt(2), 3 + 0j])
  228:         y = geomspace(-3 + 0j, 0 - 3j, 3)
  229:         assert_allclose(y, [-3 + 0j, -3 / sqrt(2) - 3j / sqrt(2), 0 - 3j])
  230:         y = geomspace(0 + 3j, -3 + 0j, 3)
  231:         assert_allclose(y, [0 + 3j, -3 / sqrt(2) + 3j / sqrt(2), -3 + 0j])
  232:         y = geomspace(-2 - 3j, 5 + 7j, 7)
  233:         assert_allclose(y, [-2 - 3j, -0.29058977 - 4.15771027j,
  234:                             2.08885354 - 4.34146838j, 4.58345529 - 3.16355218j,
  235:                             6.41401745 - 0.55233457j, 6.75707386 + 3.11795092j,
  236:                             5 + 7j])
  237: 
  238:         # Type promotion should prevent the -5 from becoming a NaN
  239:         y = geomspace(3j, -5, 2)
  240:         assert_allclose(y, [3j, -5])
  241:         y = geomspace(-5, 3j, 2)
  242:         assert_allclose(y, [-5, 3j])
  243: 
  244:     def test_complex_shortest_path(self):
  245:         # test the shortest logarithmic spiral is used, see gh-25644
  246:         x = 1.2 + 3.4j
  247:         y = np.exp(1j * (np.pi - .1)) * x
  248:         z = np.geomspace(x, y, 5)
  249:         expected = np.array([1.2 + 3.4j, -1.47384 + 3.2905616j,
  250:                         -3.33577588 + 1.36842949j, -3.36011056 - 1.30753855j,
  251:                         -1.53343861 - 3.26321406j])
  252:         np.testing.assert_array_almost_equal(z, expected)
  253: 
  254:     def test_dtype(self):
  255:         y = geomspace(1, 1e6, dtype='float32')
  256:         assert_equal(y.dtype, dtype('float32'))
  257:         y = geomspace(1, 1e6, dtype='float64')
  258:         assert_equal(y.dtype, dtype('float64'))
  259:         y = geomspace(1, 1e6, dtype='int32')
  260:         assert_equal(y.dtype, dtype('int32'))
  261: 
  262:         # Native types
  263:         y = geomspace(1, 1e6, dtype=float)
  264:         assert_equal(y.dtype, dtype('float64'))
  265:         y = geomspace(1, 1e6, dtype=complex)
  266:         assert_equal(y.dtype, dtype('complex128'))
  267: 
  268:     def test_start_stop_array_scalar(self):
  269:         lim1 = array([120, 100], dtype="int8")
  270:         lim2 = array([-120, -100], dtype="int8")
  271:         lim3 = array([1200, 1000], dtype="uint16")
  272:         t1 = geomspace(lim1[0], lim1[1], 5)
  273:         t2 = geomspace(lim2[0], lim2[1], 5)
  274:         t3 = geomspace(lim3[0], lim3[1], 5)
  275:         t4 = geomspace(120.0, 100.0, 5)
  276:         t5 = geomspace(-120.0, -100.0, 5)
  277:         t6 = geomspace(1200.0, 1000.0, 5)
  278: 
  279:         # t3 uses float32, t6 uses float64
  280:         assert_allclose(t1, t4, rtol=1e-2)
  281:         assert_allclose(t2, t5, rtol=1e-2)
  282:         assert_allclose(t3, t6, rtol=1e-5)
  283: 
  284:     def test_start_stop_array(self):
  285:         # Try to use all special cases.
  286:         start = array([1.e0, 32., 1j, -4j, 1 + 1j, -1])
  287:         stop = array([1.e4, 2., 16j, -324j, 10000 + 10000j, 1])
  288:         t1 = geomspace(start, stop, 5)
  289:         t2 = stack([geomspace(_start, _stop, 5)
  290:                     for _start, _stop in zip(start, stop)], axis=1)
  291:         assert_equal(t1, t2)
  292:         t3 = geomspace(start, stop[0], 5)
  293:         t4 = stack([geomspace(_start, stop[0], 5)
  294:                     for _start in start], axis=1)
  295:         assert_equal(t3, t4)
  296:         t5 = geomspace(start, stop, 5, axis=-1)
  297:         assert_equal(t5, t2.T)
  298: 
  299:     def test_physical_quantities(self):
  300:         a = PhysicalQuantity(1.0)
  301:         b = PhysicalQuantity(5.0)
  302:         assert_equal(geomspace(a, b), geomspace(1.0, 5.0))
  303: 
  304:     def test_subclass(self):
  305:         a = array(1).view(PhysicalQuantity2)
  306:         b = array(7).view(PhysicalQuantity2)
  307:         gs = geomspace(a, b)
  308:         assert type(gs) is PhysicalQuantity2
  309:         assert_equal(gs, geomspace(1.0, 7.0))
  310:         gs = geomspace(a, b, 1)
  311:         assert type(gs) is PhysicalQuantity2
  312:         assert_equal(gs, geomspace(1.0, 7.0, 1))
  313: 
  314:     def test_bounds(self):
  315:         assert_raises(ValueError, geomspace, 0, 10)
  316:         assert_raises(ValueError, geomspace, 10, 0)
  317:         assert_raises(ValueError, geomspace, 0, 0)
  318: 
  319: 
  320: class TestLinspace:
  321: 
  322:     def test_basic(self):
  323:         y = linspace(0, 10)
  324:         assert_(len(y) == 50)
  325:         y = linspace(2, 10, num=100)
  326:         assert_(y[-1] == 10)
  327:         y = linspace(2, 10, endpoint=False)
  328:         assert_(y[-1] < 10)
  329:         assert_raises(ValueError, linspace, 0, 10, num=-1)
  330: 
  331:     def test_corner(self):
  332:         y = list(linspace(0, 1, 1))
  333:         assert_(y == [0.0], y)
  334:         assert_raises(TypeError, linspace, 0, 1, num=2.5)
  335: 
  336:     def test_type(self):
  337:         t1 = linspace(0, 1, 0).dtype
  338:         t2 = linspace(0, 1, 1).dtype
  339:         t3 = linspace(0, 1, 2).dtype
  340:         assert_equal(t1, t2)
  341:         assert_equal(t2, t3)
  342: 
  343:     def test_dtype(self):
  344:         y = linspace(0, 6, dtype='float32')
  345:         assert_equal(y.dtype, dtype('float32'))
  346:         y = linspace(0, 6, dtype='float64')
  347:         assert_equal(y.dtype, dtype('float64'))
  348:         y = linspace(0, 6, dtype='int32')
  349:         assert_equal(y.dtype, dtype('int32'))
  350: 
  351:     def test_start_stop_array_scalar(self):
  352:         lim1 = array([-120, 100], dtype="int8")
  353:         lim2 = array([120, -100], dtype="int8")
  354:         lim3 = array([1200, 1000], dtype="uint16")
  355:         t1 = linspace(lim1[0], lim1[1], 5)
  356:         t2 = linspace(lim2[0], lim2[1], 5)
  357:         t3 = linspace(lim3[0], lim3[1], 5)
  358:         t4 = linspace(-120.0, 100.0, 5)
  359:         t5 = linspace(120.0, -100.0, 5)
  360:         t6 = linspace(1200.0, 1000.0, 5)
  361:         assert_equal(t1, t4)
  362:         assert_equal(t2, t5)
  363:         assert_equal(t3, t6)
  364: 
  365:     def test_start_stop_array(self):
  366:         start = array([-120, 120], dtype="int8")
  367:         stop = array([100, -100], dtype="int8")
  368:         t1 = linspace(start, stop, 5)
  369:         t2 = stack([linspace(_start, _stop, 5)
  370:                     for _start, _stop in zip(start, stop)], axis=1)
  371:         assert_equal(t1, t2)
  372:         t3 = linspace(start, stop[0], 5)
  373:         t4 = stack([linspace(_start, stop[0], 5)
  374:                     for _start in start], axis=1)
  375:         assert_equal(t3, t4)
  376:         t5 = linspace(start, stop, 5, axis=-1)
  377:         assert_equal(t5, t2.T)
  378: 
  379:     def test_complex(self):
  380:         lim1 = linspace(1 + 2j, 3 + 4j, 5)
  381:         t1 = array([1.0 + 2.j, 1.5 + 2.5j,  2.0 + 3j, 2.5 + 3.5j, 3.0 + 4j])
  382:         lim2 = linspace(1j, 10, 5)
  383:         t2 = array([0.0 + 1.j, 2.5 + 0.75j, 5.0 + 0.5j, 7.5 + 0.25j, 10.0 + 0j])
  384:         assert_equal(lim1, t1)
  385:         assert_equal(lim2, t2)
  386: 
  387:     def test_physical_quantities(self):
  388:         a = PhysicalQuantity(0.0)
  389:         b = PhysicalQuantity(1.0)
  390:         assert_equal(linspace(a, b), linspace(0.0, 1.0))
  391: 
  392:     def test_subclass(self):
  393:         a = array(0).view(PhysicalQuantity2)
  394:         b = array(1).view(PhysicalQuantity2)
  395:         ls = linspace(a, b)
  396:         assert type(ls) is PhysicalQuantity2
  397:         assert_equal(ls, linspace(0.0, 1.0))
  398:         ls = linspace(a, b, 1)
  399:         assert type(ls) is PhysicalQuantity2
  400:         assert_equal(ls, linspace(0.0, 1.0, 1))
  401: 
  402:     def test_array_interface(self):
  403:         # Regression test for https://github.com/numpy/numpy/pull/6659
  404:         # Ensure that start/stop can be objects that implement
  405:         # __array_interface__ and are convertible to numeric scalars
  406: 
  407:         class Arrayish:
  408:             """
  409:             A generic object that supports the __array_interface__ and hence
  410:             can in principle be converted to a numeric scalar, but is not
  411:             otherwise recognized as numeric, but also happens to support
  412:             multiplication by floats.
  413: 
  414:             Data should be an object that implements the buffer interface,
  415:             and contains at least 4 bytes.
  416:             """
  417: 
  418:             def __init__(self, data):
  419:                 self._data = data
  420: 
  421:             @property
  422:             def __array_interface__(self):
  423:                 return {'shape': (), 'typestr': '<i4', 'data': self._data,
  424:                         'version': 3}
  425: 
  426:             def __mul__(self, other):
  427:                 # For the purposes of this test any multiplication is an
  428:                 # identity operation :)
  429:                 return self
  430: 
  431:         one = Arrayish(array(1, dtype='<i4'))
  432:         five = Arrayish(array(5, dtype='<i4'))
  433: 
  434:         assert_equal(linspace(one, five), linspace(1, 5))
  435: 
  436:     # even when not explicitly enabled via FPSCR register
  437:     @pytest.mark.xfail(_is_armhf(),
  438:                        reason="ARMHF/AArch32 platforms seem to FTZ subnormals")
  439:     def test_denormal_numbers(self):
  440:         # Regression test for gh-5437. Will probably fail when compiled
  441:         # with ICC, which flushes denormals to zero
  442:         for ftype in sctypes['float']:
  443:             stop = nextafter(ftype(0), ftype(1)) * 5  # A denormal number
  444:             assert_(any(linspace(0, stop, 10, endpoint=False, dtype=ftype)))
  445: 
  446:     def test_equivalent_to_arange(self):
  447:         for j in range(1000):
  448:             assert_equal(linspace(0, j, j + 1, dtype=int),
  449:                          arange(j + 1, dtype=int))
  450: 
  451:     def test_retstep(self):
  452:         for num in [0, 1, 2]:
  453:             for ept in [False, True]:
  454:                 y = linspace(0, 1, num, endpoint=ept, retstep=True)
  455:                 assert isinstance(y, tuple) and len(y) == 2
  456:                 if num == 2:
  457:                     y0_expect = [0.0, 1.0] if ept else [0.0, 0.5]
  458:                     assert_array_equal(y[0], y0_expect)
  459:                     assert_equal(y[1], y0_expect[1])
  460:                 elif num == 1 and not ept:
  461:                     assert_array_equal(y[0], [0.0])
  462:                     assert_equal(y[1], 1.0)
  463:                 else:
  464:                     assert_array_equal(y[0], [0.0][:num])
  465:                     assert isnan(y[1])
  466: 
  467:     def test_object(self):
  468:         start = array(1, dtype='O')
  469:         stop = array(2, dtype='O')
  470:         y = linspace(start, stop, 3)
  471:         assert_array_equal(y, array([1., 1.5, 2.]))
  472: 
  473:     def test_round_negative(self):
  474:         y = linspace(-1, 3, num=8, dtype=int)
  475:         t = array([-1, -1, 0, 0, 1, 1, 2, 3], dtype=int)
  476:         assert_array_equal(y, t)
  477: 
  478:     def test_any_step_zero_and_not_mult_inplace(self):
  479:         # any_step_zero is True, _mult_inplace is False
  480:         start = array([0.0, 1.0])
  481:         stop = array([2.0, 1.0])
  482:         y = linspace(start, stop, 3)
  483:         assert_array_equal(y, array([[0.0, 1.0], [1.0, 1.0], [2.0, 1.0]]))
  484: 
  485: 
  486: class TestAdd_newdoc:
  487: 
  488:     @pytest.mark.skipif(sys.flags.optimize == 2, reason="Python running -OO")
  489:     @pytest.mark.xfail(IS_PYPY, reason="PyPy does not modify tp_doc")
  490:     def test_add_doc(self):
  491:         # test that np.add_newdoc did attach a docstring successfully:
  492:         tgt = "Current flat index into the array."
  493:         assert_equal(np._core.flatiter.index.__doc__[:len(tgt)], tgt)
  494:         assert_(len(np._core.ufunc.identity.__doc__) > 300)
  495:         assert_(len(np.lib._index_tricks_impl.mgrid.__doc__) > 300)
  496: 
  497:     @pytest.mark.skipif(sys.flags.optimize == 2, reason="Python running -OO")
  498:     def test_errors_are_ignored(self):
  499:         prev_doc = np._core.flatiter.index.__doc__
  500:         # nothing changed, but error ignored, this should probably
  501:         # give a warning (or even error) in the future.
  502:         add_newdoc("numpy._core", "flatiter", ("index", "bad docstring"))
  503:         assert prev_doc == np._core.flatiter.index.__doc__
