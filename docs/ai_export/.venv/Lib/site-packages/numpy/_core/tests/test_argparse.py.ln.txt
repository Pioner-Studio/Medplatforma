    1: """
    2: Tests for the private NumPy argument parsing functionality.
    3: They mainly exists to ensure good test coverage without having to try the
    4: weirder cases on actual numpy functions but test them in one place.
    5: 
    6: The test function is defined in C to be equivalent to (errors may not always
    7: match exactly, and could be adjusted):
    8: 
    9:     def func(arg1, /, arg2, *, arg3):
   10:         i = integer(arg1)  # reproducing the 'i' parsing in Python.
   11:         return None
   12: """
   13: 
   14: import threading
   15: 
   16: import pytest
   17: from numpy._core._multiarray_tests import (
   18:     argparse_example_function as func,
   19: )
   20: from numpy._core._multiarray_tests import (
   21:     threaded_argparse_example_function as thread_func,
   22: )
   23: 
   24: import numpy as np
   25: from numpy.testing import IS_WASM
   26: 
   27: 
   28: @pytest.mark.skipif(IS_WASM, reason="wasm doesn't have support for threads")
   29: def test_thread_safe_argparse_cache():
   30:     b = threading.Barrier(8)
   31: 
   32:     def call_thread_func():
   33:         b.wait()
   34:         thread_func(arg1=3, arg2=None)
   35: 
   36:     tasks = [threading.Thread(target=call_thread_func) for _ in range(8)]
   37:     [t.start() for t in tasks]
   38:     [t.join() for t in tasks]
   39: 
   40: 
   41: def test_invalid_integers():
   42:     with pytest.raises(TypeError,
   43:             match="integer argument expected, got float"):
   44:         func(1.)
   45:     with pytest.raises(OverflowError):
   46:         func(2**100)
   47: 
   48: 
   49: def test_missing_arguments():
   50:     with pytest.raises(TypeError,
   51:             match="missing required positional argument 0"):
   52:         func()
   53:     with pytest.raises(TypeError,
   54:             match="missing required positional argument 0"):
   55:         func(arg2=1, arg3=4)
   56:     with pytest.raises(TypeError,
   57:             match=r"missing required argument \'arg2\' \(pos 1\)"):
   58:         func(1, arg3=5)
   59: 
   60: 
   61: def test_too_many_positional():
   62:     # the second argument is positional but can be passed as keyword.
   63:     with pytest.raises(TypeError,
   64:             match="takes from 2 to 3 positional arguments but 4 were given"):
   65:         func(1, 2, 3, 4)
   66: 
   67: 
   68: def test_multiple_values():
   69:     with pytest.raises(TypeError,
   70:             match=r"given by name \('arg2'\) and position \(position 1\)"):
   71:         func(1, 2, arg2=3)
   72: 
   73: 
   74: def test_string_fallbacks():
   75:     # We can (currently?) use numpy strings to test the "slow" fallbacks
   76:     # that should normally not be taken due to string interning.
   77:     arg2 = np.str_("arg2")
   78:     missing_arg = np.str_("missing_arg")
   79:     func(1, **{arg2: 3})
   80:     with pytest.raises(TypeError,
   81:             match="got an unexpected keyword argument 'missing_arg'"):
   82:         func(2, **{missing_arg: 3})
   83: 
   84: 
   85: def test_too_many_arguments_method_forwarding():
   86:     # Not directly related to the standard argument parsing, but we sometimes
   87:     # forward methods to Python: arr.mean() calls np._core._methods._mean()
   88:     # This adds code coverage for this `npy_forward_method`.
   89:     arr = np.arange(3)
   90:     args = range(1000)
   91:     with pytest.raises(TypeError):
   92:         arr.mean(*args)
