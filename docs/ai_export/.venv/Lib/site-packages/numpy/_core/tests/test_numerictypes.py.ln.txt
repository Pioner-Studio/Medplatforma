    1: import itertools
    2: import sys
    3: 
    4: import pytest
    5: 
    6: import numpy as np
    7: import numpy._core.numerictypes as nt
    8: from numpy._core.numerictypes import issctype, maximum_sctype, sctype2char, sctypes
    9: from numpy.testing import (
   10:     IS_PYPY,
   11:     assert_,
   12:     assert_equal,
   13:     assert_raises,
   14:     assert_raises_regex,
   15: )
   16: 
   17: # This is the structure of the table used for plain objects:
   18: #
   19: # +-+-+-+
   20: # |x|y|z|
   21: # +-+-+-+
   22: 
   23: # Structure of a plain array description:
   24: Pdescr = [
   25:     ('x', 'i4', (2,)),
   26:     ('y', 'f8', (2, 2)),
   27:     ('z', 'u1')]
   28: 
   29: # A plain list of tuples with values for testing:
   30: PbufferT = [
   31:     # x     y                  z
   32:     ([3, 2], [[6., 4.], [6., 4.]], 8),
   33:     ([4, 3], [[7., 5.], [7., 5.]], 9),
   34:     ]
   35: 
   36: 
   37: # This is the structure of the table used for nested objects (DON'T PANIC!):
   38: #
   39: # +-+---------------------------------+-----+----------+-+-+
   40: # |x|Info                             |color|info      |y|z|
   41: # | +-----+--+----------------+----+--+     +----+-----+ | |
   42: # | |value|y2|Info2           |name|z2|     |Name|Value| | |
   43: # | |     |  +----+-----+--+--+    |  |     |    |     | | |
   44: # | |     |  |name|value|y3|z3|    |  |     |    |     | | |
   45: # +-+-----+--+----+-----+--+--+----+--+-----+----+-----+-+-+
   46: #
   47: 
   48: # The corresponding nested array description:
   49: Ndescr = [
   50:     ('x', 'i4', (2,)),
   51:     ('Info', [
   52:         ('value', 'c16'),
   53:         ('y2', 'f8'),
   54:         ('Info2', [
   55:             ('name', 'S2'),
   56:             ('value', 'c16', (2,)),
   57:             ('y3', 'f8', (2,)),
   58:             ('z3', 'u4', (2,))]),
   59:         ('name', 'S2'),
   60:         ('z2', 'b1')]),
   61:     ('color', 'S2'),
   62:     ('info', [
   63:         ('Name', 'U8'),
   64:         ('Value', 'c16')]),
   65:     ('y', 'f8', (2, 2)),
   66:     ('z', 'u1')]
   67: 
   68: NbufferT = [
   69:     # x     Info                                                color info        y                  z
   70:     #       value y2 Info2                            name z2         Name Value
   71:     #                name   value    y3       z3
   72:     ([3, 2], (6j, 6., (b'nn', [6j, 4j], [6., 4.], [1, 2]), b'NN', True),
   73:      b'cc', ('NN', 6j), [[6., 4.], [6., 4.]], 8),
   74:     ([4, 3], (7j, 7., (b'oo', [7j, 5j], [7., 5.], [2, 1]), b'OO', False),
   75:      b'dd', ('OO', 7j), [[7., 5.], [7., 5.]], 9),
   76:     ]
   77: 
   78: 
   79: byteorder = {'little': '<', 'big': '>'}[sys.byteorder]
   80: 
   81: def normalize_descr(descr):
   82:     "Normalize a description adding the platform byteorder."
   83: 
   84:     out = []
   85:     for item in descr:
   86:         dtype = item[1]
   87:         if isinstance(dtype, str):
   88:             if dtype[0] not in ['|', '<', '>']:
   89:                 onebyte = dtype[1:] == "1"
   90:                 if onebyte or dtype[0] in ['S', 'V', 'b']:
   91:                     dtype = "|" + dtype
   92:                 else:
   93:                     dtype = byteorder + dtype
   94:             if len(item) > 2 and np.prod(item[2]) > 1:
   95:                 nitem = (item[0], dtype, item[2])
   96:             else:
   97:                 nitem = (item[0], dtype)
   98:             out.append(nitem)
   99:         elif isinstance(dtype, list):
  100:             l = normalize_descr(dtype)
  101:             out.append((item[0], l))
  102:         else:
  103:             raise ValueError(f"Expected a str or list and got {type(item)}")
  104:     return out
  105: 
  106: 
  107: ############################################################
  108: #    Creation tests
  109: ############################################################
  110: 
  111: class CreateZeros:
  112:     """Check the creation of heterogeneous arrays zero-valued"""
  113: 
  114:     def test_zeros0D(self):
  115:         """Check creation of 0-dimensional objects"""
  116:         h = np.zeros((), dtype=self._descr)
  117:         assert_(normalize_descr(self._descr) == h.dtype.descr)
  118:         assert_(h.dtype.fields['x'][0].name[:4] == 'void')
  119:         assert_(h.dtype.fields['x'][0].char == 'V')
  120:         assert_(h.dtype.fields['x'][0].type == np.void)
  121:         # A small check that data is ok
  122:         assert_equal(h['z'], np.zeros((), dtype='u1'))
  123: 
  124:     def test_zerosSD(self):
  125:         """Check creation of single-dimensional objects"""
  126:         h = np.zeros((2,), dtype=self._descr)
  127:         assert_(normalize_descr(self._descr) == h.dtype.descr)
  128:         assert_(h.dtype['y'].name[:4] == 'void')
  129:         assert_(h.dtype['y'].char == 'V')
  130:         assert_(h.dtype['y'].type == np.void)
  131:         # A small check that data is ok
  132:         assert_equal(h['z'], np.zeros((2,), dtype='u1'))
  133: 
  134:     def test_zerosMD(self):
  135:         """Check creation of multi-dimensional objects"""
  136:         h = np.zeros((2, 3), dtype=self._descr)
  137:         assert_(normalize_descr(self._descr) == h.dtype.descr)
  138:         assert_(h.dtype['z'].name == 'uint8')
  139:         assert_(h.dtype['z'].char == 'B')
  140:         assert_(h.dtype['z'].type == np.uint8)
  141:         # A small check that data is ok
  142:         assert_equal(h['z'], np.zeros((2, 3), dtype='u1'))
  143: 
  144: 
  145: class TestCreateZerosPlain(CreateZeros):
  146:     """Check the creation of heterogeneous arrays zero-valued (plain)"""
  147:     _descr = Pdescr
  148: 
  149: class TestCreateZerosNested(CreateZeros):
  150:     """Check the creation of heterogeneous arrays zero-valued (nested)"""
  151:     _descr = Ndescr
  152: 
  153: 
  154: class CreateValues:
  155:     """Check the creation of heterogeneous arrays with values"""
  156: 
  157:     def test_tuple(self):
  158:         """Check creation from tuples"""
  159:         h = np.array(self._buffer, dtype=self._descr)
  160:         assert_(normalize_descr(self._descr) == h.dtype.descr)
  161:         if self.multiple_rows:
  162:             assert_(h.shape == (2,))
  163:         else:
  164:             assert_(h.shape == ())
  165: 
  166:     def test_list_of_tuple(self):
  167:         """Check creation from list of tuples"""
  168:         h = np.array([self._buffer], dtype=self._descr)
  169:         assert_(normalize_descr(self._descr) == h.dtype.descr)
  170:         if self.multiple_rows:
  171:             assert_(h.shape == (1, 2))
  172:         else:
  173:             assert_(h.shape == (1,))
  174: 
  175:     def test_list_of_list_of_tuple(self):
  176:         """Check creation from list of list of tuples"""
  177:         h = np.array([[self._buffer]], dtype=self._descr)
  178:         assert_(normalize_descr(self._descr) == h.dtype.descr)
  179:         if self.multiple_rows:
  180:             assert_(h.shape == (1, 1, 2))
  181:         else:
  182:             assert_(h.shape == (1, 1))
  183: 
  184: 
  185: class TestCreateValuesPlainSingle(CreateValues):
  186:     """Check the creation of heterogeneous arrays (plain, single row)"""
  187:     _descr = Pdescr
  188:     multiple_rows = 0
  189:     _buffer = PbufferT[0]
  190: 
  191: class TestCreateValuesPlainMultiple(CreateValues):
  192:     """Check the creation of heterogeneous arrays (plain, multiple rows)"""
  193:     _descr = Pdescr
  194:     multiple_rows = 1
  195:     _buffer = PbufferT
  196: 
  197: class TestCreateValuesNestedSingle(CreateValues):
  198:     """Check the creation of heterogeneous arrays (nested, single row)"""
  199:     _descr = Ndescr
  200:     multiple_rows = 0
  201:     _buffer = NbufferT[0]
  202: 
  203: class TestCreateValuesNestedMultiple(CreateValues):
  204:     """Check the creation of heterogeneous arrays (nested, multiple rows)"""
  205:     _descr = Ndescr
  206:     multiple_rows = 1
  207:     _buffer = NbufferT
  208: 
  209: 
  210: ############################################################
  211: #    Reading tests
  212: ############################################################
  213: 
  214: class ReadValuesPlain:
  215:     """Check the reading of values in heterogeneous arrays (plain)"""
  216: 
  217:     def test_access_fields(self):
  218:         h = np.array(self._buffer, dtype=self._descr)
  219:         if not self.multiple_rows:
  220:             assert_(h.shape == ())
  221:             assert_equal(h['x'], np.array(self._buffer[0], dtype='i4'))
  222:             assert_equal(h['y'], np.array(self._buffer[1], dtype='f8'))
  223:             assert_equal(h['z'], np.array(self._buffer[2], dtype='u1'))
  224:         else:
  225:             assert_(len(h) == 2)
  226:             assert_equal(h['x'], np.array([self._buffer[0][0],
  227:                                              self._buffer[1][0]], dtype='i4'))
  228:             assert_equal(h['y'], np.array([self._buffer[0][1],
  229:                                              self._buffer[1][1]], dtype='f8'))
  230:             assert_equal(h['z'], np.array([self._buffer[0][2],
  231:                                              self._buffer[1][2]], dtype='u1'))
  232: 
  233: 
  234: class TestReadValuesPlainSingle(ReadValuesPlain):
  235:     """Check the creation of heterogeneous arrays (plain, single row)"""
  236:     _descr = Pdescr
  237:     multiple_rows = 0
  238:     _buffer = PbufferT[0]
  239: 
  240: class TestReadValuesPlainMultiple(ReadValuesPlain):
  241:     """Check the values of heterogeneous arrays (plain, multiple rows)"""
  242:     _descr = Pdescr
  243:     multiple_rows = 1
  244:     _buffer = PbufferT
  245: 
  246: class ReadValuesNested:
  247:     """Check the reading of values in heterogeneous arrays (nested)"""
  248: 
  249:     def test_access_top_fields(self):
  250:         """Check reading the top fields of a nested array"""
  251:         h = np.array(self._buffer, dtype=self._descr)
  252:         if not self.multiple_rows:
  253:             assert_(h.shape == ())
  254:             assert_equal(h['x'], np.array(self._buffer[0], dtype='i4'))
  255:             assert_equal(h['y'], np.array(self._buffer[4], dtype='f8'))
  256:             assert_equal(h['z'], np.array(self._buffer[5], dtype='u1'))
  257:         else:
  258:             assert_(len(h) == 2)
  259:             assert_equal(h['x'], np.array([self._buffer[0][0],
  260:                                            self._buffer[1][0]], dtype='i4'))
  261:             assert_equal(h['y'], np.array([self._buffer[0][4],
  262:                                            self._buffer[1][4]], dtype='f8'))
  263:             assert_equal(h['z'], np.array([self._buffer[0][5],
  264:                                            self._buffer[1][5]], dtype='u1'))
  265: 
  266:     def test_nested1_acessors(self):
  267:         """Check reading the nested fields of a nested array (1st level)"""
  268:         h = np.array(self._buffer, dtype=self._descr)
  269:         if not self.multiple_rows:
  270:             assert_equal(h['Info']['value'],
  271:                          np.array(self._buffer[1][0], dtype='c16'))
  272:             assert_equal(h['Info']['y2'],
  273:                          np.array(self._buffer[1][1], dtype='f8'))
  274:             assert_equal(h['info']['Name'],
  275:                          np.array(self._buffer[3][0], dtype='U2'))
  276:             assert_equal(h['info']['Value'],
  277:                          np.array(self._buffer[3][1], dtype='c16'))
  278:         else:
  279:             assert_equal(h['Info']['value'],
  280:                          np.array([self._buffer[0][1][0],
  281:                                 self._buffer[1][1][0]],
  282:                                 dtype='c16'))
  283:             assert_equal(h['Info']['y2'],
  284:                          np.array([self._buffer[0][1][1],
  285:                                 self._buffer[1][1][1]],
  286:                                 dtype='f8'))
  287:             assert_equal(h['info']['Name'],
  288:                          np.array([self._buffer[0][3][0],
  289:                                 self._buffer[1][3][0]],
  290:                                dtype='U2'))
  291:             assert_equal(h['info']['Value'],
  292:                          np.array([self._buffer[0][3][1],
  293:                                 self._buffer[1][3][1]],
  294:                                dtype='c16'))
  295: 
  296:     def test_nested2_acessors(self):
  297:         """Check reading the nested fields of a nested array (2nd level)"""
  298:         h = np.array(self._buffer, dtype=self._descr)
  299:         if not self.multiple_rows:
  300:             assert_equal(h['Info']['Info2']['value'],
  301:                          np.array(self._buffer[1][2][1], dtype='c16'))
  302:             assert_equal(h['Info']['Info2']['z3'],
  303:                          np.array(self._buffer[1][2][3], dtype='u4'))
  304:         else:
  305:             assert_equal(h['Info']['Info2']['value'],
  306:                          np.array([self._buffer[0][1][2][1],
  307:                                 self._buffer[1][1][2][1]],
  308:                                dtype='c16'))
  309:             assert_equal(h['Info']['Info2']['z3'],
  310:                          np.array([self._buffer[0][1][2][3],
  311:                                 self._buffer[1][1][2][3]],
  312:                                dtype='u4'))
  313: 
  314:     def test_nested1_descriptor(self):
  315:         """Check access nested descriptors of a nested array (1st level)"""
  316:         h = np.array(self._buffer, dtype=self._descr)
  317:         assert_(h.dtype['Info']['value'].name == 'complex128')
  318:         assert_(h.dtype['Info']['y2'].name == 'float64')
  319:         assert_(h.dtype['info']['Name'].name == 'str256')
  320:         assert_(h.dtype['info']['Value'].name == 'complex128')
  321: 
  322:     def test_nested2_descriptor(self):
  323:         """Check access nested descriptors of a nested array (2nd level)"""
  324:         h = np.array(self._buffer, dtype=self._descr)
  325:         assert_(h.dtype['Info']['Info2']['value'].name == 'void256')
  326:         assert_(h.dtype['Info']['Info2']['z3'].name == 'void64')
  327: 
  328: 
  329: class TestReadValuesNestedSingle(ReadValuesNested):
  330:     """Check the values of heterogeneous arrays (nested, single row)"""
  331:     _descr = Ndescr
  332:     multiple_rows = False
  333:     _buffer = NbufferT[0]
  334: 
  335: class TestReadValuesNestedMultiple(ReadValuesNested):
  336:     """Check the values of heterogeneous arrays (nested, multiple rows)"""
  337:     _descr = Ndescr
  338:     multiple_rows = True
  339:     _buffer = NbufferT
  340: 
  341: class TestEmptyField:
  342:     def test_assign(self):
  343:         a = np.arange(10, dtype=np.float32)
  344:         a.dtype = [("int",   "<0i4"), ("float", "<2f4")]
  345:         assert_(a['int'].shape == (5, 0))
  346:         assert_(a['float'].shape == (5, 2))
  347: 
  348: 
  349: class TestMultipleFields:
  350:     def setup_method(self):
  351:         self.ary = np.array([(1, 2, 3, 4), (5, 6, 7, 8)], dtype='i4,f4,i2,c8')
  352: 
  353:     def _bad_call(self):
  354:         return self.ary['f0', 'f1']
  355: 
  356:     def test_no_tuple(self):
  357:         assert_raises(IndexError, self._bad_call)
  358: 
  359:     def test_return(self):
  360:         res = self.ary[['f0', 'f2']].tolist()
  361:         assert_(res == [(1, 3), (5, 7)])
  362: 
  363: 
  364: class TestIsSubDType:
  365:     # scalar types can be promoted into dtypes
  366:     wrappers = [np.dtype, lambda x: x]
  367: 
  368:     def test_both_abstract(self):
  369:         assert_(np.issubdtype(np.floating, np.inexact))
  370:         assert_(not np.issubdtype(np.inexact, np.floating))
  371: 
  372:     def test_same(self):
  373:         for cls in (np.float32, np.int32):
  374:             for w1, w2 in itertools.product(self.wrappers, repeat=2):
  375:                 assert_(np.issubdtype(w1(cls), w2(cls)))
  376: 
  377:     def test_subclass(self):
  378:         # note we cannot promote floating to a dtype, as it would turn into a
  379:         # concrete type
  380:         for w in self.wrappers:
  381:             assert_(np.issubdtype(w(np.float32), np.floating))
  382:             assert_(np.issubdtype(w(np.float64), np.floating))
  383: 
  384:     def test_subclass_backwards(self):
  385:         for w in self.wrappers:
  386:             assert_(not np.issubdtype(np.floating, w(np.float32)))
  387:             assert_(not np.issubdtype(np.floating, w(np.float64)))
  388: 
  389:     def test_sibling_class(self):
  390:         for w1, w2 in itertools.product(self.wrappers, repeat=2):
  391:             assert_(not np.issubdtype(w1(np.float32), w2(np.float64)))
  392:             assert_(not np.issubdtype(w1(np.float64), w2(np.float32)))
  393: 
  394:     def test_nondtype_nonscalartype(self):
  395:         # See gh-14619 and gh-9505 which introduced the deprecation to fix
  396:         # this. These tests are directly taken from gh-9505
  397:         assert not np.issubdtype(np.float32, 'float64')
  398:         assert not np.issubdtype(np.float32, 'f8')
  399:         assert not np.issubdtype(np.int32, str)
  400:         assert not np.issubdtype(np.int32, 'int64')
  401:         assert not np.issubdtype(np.str_, 'void')
  402:         # for the following the correct spellings are
  403:         # np.integer, np.floating, or np.complexfloating respectively:
  404:         assert not np.issubdtype(np.int8, int)  # np.int8 is never np.int_
  405:         assert not np.issubdtype(np.float32, float)
  406:         assert not np.issubdtype(np.complex64, complex)
  407:         assert not np.issubdtype(np.float32, "float")
  408:         assert not np.issubdtype(np.float64, "f")
  409: 
  410:         # Test the same for the correct first datatype and abstract one
  411:         # in the case of int, float, complex:
  412:         assert np.issubdtype(np.float64, 'float64')
  413:         assert np.issubdtype(np.float64, 'f8')
  414:         assert np.issubdtype(np.str_, str)
  415:         assert np.issubdtype(np.int64, 'int64')
  416:         assert np.issubdtype(np.void, 'void')
  417:         assert np.issubdtype(np.int8, np.integer)
  418:         assert np.issubdtype(np.float32, np.floating)
  419:         assert np.issubdtype(np.complex64, np.complexfloating)
  420:         assert np.issubdtype(np.float64, "float")
  421:         assert np.issubdtype(np.float32, "f")
  422: 
  423: 
  424: class TestIsDType:
  425:     """
  426:     Check correctness of `np.isdtype`. The test considers different argument
  427:     configurations: `np.isdtype(dtype, k1)` and `np.isdtype(dtype, (k1, k2))`
  428:     with concrete dtypes and dtype groups.
  429:     """
  430:     dtype_group_dict = {
  431:         "signed integer": sctypes["int"],
  432:         "unsigned integer": sctypes["uint"],
  433:         "integral": sctypes["int"] + sctypes["uint"],
  434:         "real floating": sctypes["float"],
  435:         "complex floating": sctypes["complex"],
  436:         "numeric": (
  437:             sctypes["int"] + sctypes["uint"] + sctypes["float"] +
  438:             sctypes["complex"]
  439:         )
  440:     }
  441: 
  442:     @pytest.mark.parametrize(
  443:         "dtype,close_dtype",
  444:         [
  445:             (np.int64, np.int32), (np.uint64, np.uint32),
  446:             (np.float64, np.float32), (np.complex128, np.complex64)
  447:         ]
  448:     )
  449:     @pytest.mark.parametrize(
  450:         "dtype_group",
  451:         [
  452:             None, "signed integer", "unsigned integer", "integral",
  453:             "real floating", "complex floating", "numeric"
  454:         ]
  455:     )
  456:     def test_isdtype(self, dtype, close_dtype, dtype_group):
  457:         # First check if same dtypes return `true` and different ones
  458:         # give `false` (even if they're close in the dtype hierarchy!)
  459:         if dtype_group is None:
  460:             assert np.isdtype(dtype, dtype)
  461:             assert not np.isdtype(dtype, close_dtype)
  462:             assert np.isdtype(dtype, (dtype, close_dtype))
  463: 
  464:         # Check that dtype and a dtype group that it belongs to
  465:         # return `true`, and `false` otherwise.
  466:         elif dtype in self.dtype_group_dict[dtype_group]:
  467:             assert np.isdtype(dtype, dtype_group)
  468:             assert np.isdtype(dtype, (close_dtype, dtype_group))
  469:         else:
  470:             assert not np.isdtype(dtype, dtype_group)
  471: 
  472:     def test_isdtype_invalid_args(self):
  473:         with assert_raises_regex(TypeError, r".*must be a NumPy dtype.*"):
  474:             np.isdtype("int64", np.int64)
  475:         with assert_raises_regex(TypeError, r".*kind argument must.*"):
  476:             np.isdtype(np.int64, 1)
  477:         with assert_raises_regex(ValueError, r".*not a known kind name.*"):
  478:             np.isdtype(np.int64, "int64")
  479: 
  480:     def test_sctypes_complete(self):
  481:         # issue 26439: int32/intc were masking each other on 32-bit builds
  482:         assert np.int32 in sctypes['int']
  483:         assert np.intc in sctypes['int']
  484:         assert np.int64 in sctypes['int']
  485:         assert np.uint32 in sctypes['uint']
  486:         assert np.uintc in sctypes['uint']
  487:         assert np.uint64 in sctypes['uint']
  488: 
  489: class TestSctypeDict:
  490:     def test_longdouble(self):
  491:         assert_(np._core.sctypeDict['float64'] is not np.longdouble)
  492:         assert_(np._core.sctypeDict['complex128'] is not np.clongdouble)
  493: 
  494:     def test_ulong(self):
  495:         assert np._core.sctypeDict['ulong'] is np.ulong
  496:         assert np.dtype(np.ulong) is np.dtype("ulong")
  497:         assert np.dtype(np.ulong).itemsize == np.dtype(np.long).itemsize
  498: 
  499: 
  500: @pytest.mark.filterwarnings("ignore:.*maximum_sctype.*:DeprecationWarning")
  501: class TestMaximumSctype:
  502: 
  503:     # note that parametrizing with sctype['int'] and similar would skip types
  504:     # with the same size (gh-11923)
  505: 
  506:     @pytest.mark.parametrize(
  507:         't', [np.byte, np.short, np.intc, np.long, np.longlong]
  508:     )
  509:     def test_int(self, t):
  510:         assert_equal(maximum_sctype(t), np._core.sctypes['int'][-1])
  511: 
  512:     @pytest.mark.parametrize(
  513:         't', [np.ubyte, np.ushort, np.uintc, np.ulong, np.ulonglong]
  514:     )
  515:     def test_uint(self, t):
  516:         assert_equal(maximum_sctype(t), np._core.sctypes['uint'][-1])
  517: 
  518:     @pytest.mark.parametrize('t', [np.half, np.single, np.double, np.longdouble])
  519:     def test_float(self, t):
  520:         assert_equal(maximum_sctype(t), np._core.sctypes['float'][-1])
  521: 
  522:     @pytest.mark.parametrize('t', [np.csingle, np.cdouble, np.clongdouble])
  523:     def test_complex(self, t):
  524:         assert_equal(maximum_sctype(t), np._core.sctypes['complex'][-1])
  525: 
  526:     @pytest.mark.parametrize('t', [np.bool, np.object_, np.str_, np.bytes_,
  527:                                    np.void])
  528:     def test_other(self, t):
  529:         assert_equal(maximum_sctype(t), t)
  530: 
  531: 
  532: class Test_sctype2char:
  533:     # This function is old enough that we're really just documenting the quirks
  534:     # at this point.
  535: 
  536:     def test_scalar_type(self):
  537:         assert_equal(sctype2char(np.double), 'd')
  538:         assert_equal(sctype2char(np.long), 'l')
  539:         assert_equal(sctype2char(np.int_), np.array(0).dtype.char)
  540:         assert_equal(sctype2char(np.str_), 'U')
  541:         assert_equal(sctype2char(np.bytes_), 'S')
  542: 
  543:     def test_other_type(self):
  544:         assert_equal(sctype2char(float), 'd')
  545:         assert_equal(sctype2char(list), 'O')
  546:         assert_equal(sctype2char(np.ndarray), 'O')
  547: 
  548:     def test_third_party_scalar_type(self):
  549:         from numpy._core._rational_tests import rational
  550:         assert_raises(KeyError, sctype2char, rational)
  551:         assert_raises(KeyError, sctype2char, rational(1))
  552: 
  553:     def test_array_instance(self):
  554:         assert_equal(sctype2char(np.array([1.0, 2.0])), 'd')
  555: 
  556:     def test_abstract_type(self):
  557:         assert_raises(KeyError, sctype2char, np.floating)
  558: 
  559:     def test_non_type(self):
  560:         assert_raises(ValueError, sctype2char, 1)
  561: 
  562: @pytest.mark.parametrize("rep, expected", [
  563:     (np.int32, True),
  564:     (list, False),
  565:     (1.1, False),
  566:     (str, True),
  567:     (np.dtype(np.float64), True),
  568:     (np.dtype((np.int16, (3, 4))), True),
  569:     (np.dtype([('a', np.int8)]), True),
  570:     ])
  571: def test_issctype(rep, expected):
  572:     # ensure proper identification of scalar
  573:     # data-types by issctype()
  574:     actual = issctype(rep)
  575:     assert type(actual) is bool
  576:     assert_equal(actual, expected)
  577: 
  578: 
  579: @pytest.mark.skipif(sys.flags.optimize > 1,
  580:                     reason="no docstrings present to inspect when PYTHONOPTIMIZE/Py_OptimizeFlag > 1")
  581: @pytest.mark.xfail(IS_PYPY,
  582:                    reason="PyPy cannot modify tp_doc after PyType_Ready")
  583: class TestDocStrings:
  584:     def test_platform_dependent_aliases(self):
  585:         if np.int64 is np.int_:
  586:             assert_('int64' in np.int_.__doc__)
  587:         elif np.int64 is np.longlong:
  588:             assert_('int64' in np.longlong.__doc__)
  589: 
  590: 
  591: class TestScalarTypeNames:
  592:     # gh-9799
  593: 
  594:     numeric_types = [
  595:         np.byte, np.short, np.intc, np.long, np.longlong,
  596:         np.ubyte, np.ushort, np.uintc, np.ulong, np.ulonglong,
  597:         np.half, np.single, np.double, np.longdouble,
  598:         np.csingle, np.cdouble, np.clongdouble,
  599:     ]
  600: 
  601:     def test_names_are_unique(self):
  602:         # none of the above may be aliases for each other
  603:         assert len(set(self.numeric_types)) == len(self.numeric_types)
  604: 
  605:         # names must be unique
  606:         names = [t.__name__ for t in self.numeric_types]
  607:         assert len(set(names)) == len(names)
  608: 
  609:     @pytest.mark.parametrize('t', numeric_types)
  610:     def test_names_reflect_attributes(self, t):
  611:         """ Test that names correspond to where the type is under ``np.`` """
  612:         assert getattr(np, t.__name__) is t
  613: 
  614:     @pytest.mark.parametrize('t', numeric_types)
  615:     def test_names_are_undersood_by_dtype(self, t):
  616:         """ Test the dtype constructor maps names back to the type """
  617:         assert np.dtype(t.__name__).type is t
  618: 
  619: 
  620: class TestBoolDefinition:
  621:     def test_bool_definition(self):
  622:         assert nt.bool is np.bool
