    1: """
    2: numerictypes: Define the numeric type objects
    3: 
    4: This module is designed so "from numerictypes import \\*" is safe.
    5: Exported symbols include:
    6: 
    7:   Dictionary with all registered number types (including aliases):
    8:     sctypeDict
    9: 
   10:   Type objects (not all will be available, depends on platform):
   11:       see variable sctypes for which ones you have
   12: 
   13:     Bit-width names
   14: 
   15:     int8 int16 int32 int64
   16:     uint8 uint16 uint32 uint64
   17:     float16 float32 float64 float96 float128
   18:     complex64 complex128 complex192 complex256
   19:     datetime64 timedelta64
   20: 
   21:     c-based names
   22: 
   23:     bool
   24: 
   25:     object_
   26: 
   27:     void, str_
   28: 
   29:     byte, ubyte,
   30:     short, ushort
   31:     intc, uintc,
   32:     intp, uintp,
   33:     int_, uint,
   34:     longlong, ulonglong,
   35: 
   36:     single, csingle,
   37:     double, cdouble,
   38:     longdouble, clongdouble,
   39: 
   40:    As part of the type-hierarchy:    xx -- is bit-width
   41: 
   42:    generic
   43:      +-> bool                                   (kind=b)
   44:      +-> number
   45:      |   +-> integer
   46:      |   |   +-> signedinteger     (intxx)      (kind=i)
   47:      |   |   |     byte
   48:      |   |   |     short
   49:      |   |   |     intc
   50:      |   |   |     intp
   51:      |   |   |     int_
   52:      |   |   |     longlong
   53:      |   |   \\-> unsignedinteger  (uintxx)     (kind=u)
   54:      |   |         ubyte
   55:      |   |         ushort
   56:      |   |         uintc
   57:      |   |         uintp
   58:      |   |         uint
   59:      |   |         ulonglong
   60:      |   +-> inexact
   61:      |       +-> floating          (floatxx)    (kind=f)
   62:      |       |     half
   63:      |       |     single
   64:      |       |     double
   65:      |       |     longdouble
   66:      |       \\-> complexfloating  (complexxx)  (kind=c)
   67:      |             csingle
   68:      |             cdouble
   69:      |             clongdouble
   70:      +-> flexible
   71:      |   +-> character
   72:      |   |     bytes_                           (kind=S)
   73:      |   |     str_                             (kind=U)
   74:      |   |
   75:      |   \\-> void                              (kind=V)
   76:      \\-> object_ (not used much)               (kind=O)
   77: 
   78: """
   79: import numbers
   80: import warnings
   81: 
   82: from numpy._utils import set_module
   83: 
   84: from . import multiarray as ma
   85: from .multiarray import (
   86:     busday_count,
   87:     busday_offset,
   88:     busdaycalendar,
   89:     datetime_as_string,
   90:     datetime_data,
   91:     dtype,
   92:     is_busday,
   93:     ndarray,
   94: )
   95: 
   96: # we add more at the bottom
   97: __all__ = [
   98:     'ScalarType', 'typecodes', 'issubdtype', 'datetime_data',
   99:     'datetime_as_string', 'busday_offset', 'busday_count',
  100:     'is_busday', 'busdaycalendar', 'isdtype'
  101: ]
  102: 
  103: # we don't need all these imports, but we need to keep them for compatibility
  104: # for users using np._core.numerictypes.UPPER_TABLE
  105: # we don't export these for import *, but we do want them accessible
  106: # as numerictypes.bool, etc.
  107: from builtins import bool, bytes, complex, float, int, object, str  # noqa: F401, UP029
  108: 
  109: from ._dtype import _kind_name
  110: from ._string_helpers import (  # noqa: F401
  111:     LOWER_TABLE,
  112:     UPPER_TABLE,
  113:     english_capitalize,
  114:     english_lower,
  115:     english_upper,
  116: )
  117: from ._type_aliases import allTypes, sctypeDict, sctypes
  118: 
  119: # We use this later
  120: generic = allTypes['generic']
  121: 
  122: genericTypeRank = ['bool', 'int8', 'uint8', 'int16', 'uint16',
  123:                    'int32', 'uint32', 'int64', 'uint64',
  124:                    'float16', 'float32', 'float64', 'float96', 'float128',
  125:                    'complex64', 'complex128', 'complex192', 'complex256',
  126:                    'object']
  127: 
  128: @set_module('numpy')
  129: def maximum_sctype(t):
  130:     """
  131:     Return the scalar type of highest precision of the same kind as the input.
  132: 
  133:     .. deprecated:: 2.0
  134:         Use an explicit dtype like int64 or float64 instead.
  135: 
  136:     Parameters
  137:     ----------
  138:     t : dtype or dtype specifier
  139:         The input data type. This can be a `dtype` object or an object that
  140:         is convertible to a `dtype`.
  141: 
  142:     Returns
  143:     -------
  144:     out : dtype
  145:         The highest precision data type of the same kind (`dtype.kind`) as `t`.
  146: 
  147:     See Also
  148:     --------
  149:     obj2sctype, mintypecode, sctype2char
  150:     dtype
  151: 
  152:     Examples
  153:     --------
  154:     >>> from numpy._core.numerictypes import maximum_sctype
  155:     >>> maximum_sctype(int)
  156:     <class 'numpy.int64'>
  157:     >>> maximum_sctype(np.uint8)
  158:     <class 'numpy.uint64'>
  159:     >>> maximum_sctype(complex)
  160:     <class 'numpy.complex256'> # may vary
  161: 
  162:     >>> maximum_sctype(str)
  163:     <class 'numpy.str_'>
  164: 
  165:     >>> maximum_sctype('i2')
  166:     <class 'numpy.int64'>
  167:     >>> maximum_sctype('f4')
  168:     <class 'numpy.float128'> # may vary
  169: 
  170:     """
  171: 
  172:     # Deprecated in NumPy 2.0, 2023-07-11
  173:     warnings.warn(
  174:         "`maximum_sctype` is deprecated. Use an explicit dtype like int64 "
  175:         "or float64 instead. (deprecated in NumPy 2.0)",
  176:         DeprecationWarning,
  177:         stacklevel=2
  178:     )
  179: 
  180:     g = obj2sctype(t)
  181:     if g is None:
  182:         return t
  183:     t = g
  184:     base = _kind_name(dtype(t))
  185:     if base in sctypes:
  186:         return sctypes[base][-1]
  187:     else:
  188:         return t
  189: 
  190: 
  191: @set_module('numpy')
  192: def issctype(rep):
  193:     """
  194:     Determines whether the given object represents a scalar data-type.
  195: 
  196:     Parameters
  197:     ----------
  198:     rep : any
  199:         If `rep` is an instance of a scalar dtype, True is returned. If not,
  200:         False is returned.
  201: 
  202:     Returns
  203:     -------
  204:     out : bool
  205:         Boolean result of check whether `rep` is a scalar dtype.
  206: 
  207:     See Also
  208:     --------
  209:     issubsctype, issubdtype, obj2sctype, sctype2char
  210: 
  211:     Examples
  212:     --------
  213:     >>> from numpy._core.numerictypes import issctype
  214:     >>> issctype(np.int32)
  215:     True
  216:     >>> issctype(list)
  217:     False
  218:     >>> issctype(1.1)
  219:     False
  220: 
  221:     Strings are also a scalar type:
  222: 
  223:     >>> issctype(np.dtype('str'))
  224:     True
  225: 
  226:     """
  227:     if not isinstance(rep, (type, dtype)):
  228:         return False
  229:     try:
  230:         res = obj2sctype(rep)
  231:         if res and res != object_:
  232:             return True
  233:         else:
  234:             return False
  235:     except Exception:
  236:         return False
  237: 
  238: 
  239: def obj2sctype(rep, default=None):
  240:     """
  241:     Return the scalar dtype or NumPy equivalent of Python type of an object.
  242: 
  243:     Parameters
  244:     ----------
  245:     rep : any
  246:         The object of which the type is returned.
  247:     default : any, optional
  248:         If given, this is returned for objects whose types can not be
  249:         determined. If not given, None is returned for those objects.
  250: 
  251:     Returns
  252:     -------
  253:     dtype : dtype or Python type
  254:         The data type of `rep`.
  255: 
  256:     See Also
  257:     --------
  258:     sctype2char, issctype, issubsctype, issubdtype
  259: 
  260:     Examples
  261:     --------
  262:     >>> from numpy._core.numerictypes import obj2sctype
  263:     >>> obj2sctype(np.int32)
  264:     <class 'numpy.int32'>
  265:     >>> obj2sctype(np.array([1., 2.]))
  266:     <class 'numpy.float64'>
  267:     >>> obj2sctype(np.array([1.j]))
  268:     <class 'numpy.complex128'>
  269: 
  270:     >>> obj2sctype(dict)
  271:     <class 'numpy.object_'>
  272:     >>> obj2sctype('string')
  273: 
  274:     >>> obj2sctype(1, default=list)
  275:     <class 'list'>
  276: 
  277:     """
  278:     # prevent abstract classes being upcast
  279:     if isinstance(rep, type) and issubclass(rep, generic):
  280:         return rep
  281:     # extract dtype from arrays
  282:     if isinstance(rep, ndarray):
  283:         return rep.dtype.type
  284:     # fall back on dtype to convert
  285:     try:
  286:         res = dtype(rep)
  287:     except Exception:
  288:         return default
  289:     else:
  290:         return res.type
  291: 
  292: 
  293: @set_module('numpy')
  294: def issubclass_(arg1, arg2):
  295:     """
  296:     Determine if a class is a subclass of a second class.
  297: 
  298:     `issubclass_` is equivalent to the Python built-in ``issubclass``,
  299:     except that it returns False instead of raising a TypeError if one
  300:     of the arguments is not a class.
  301: 
  302:     Parameters
  303:     ----------
  304:     arg1 : class
  305:         Input class. True is returned if `arg1` is a subclass of `arg2`.
  306:     arg2 : class or tuple of classes.
  307:         Input class. If a tuple of classes, True is returned if `arg1` is a
  308:         subclass of any of the tuple elements.
  309: 
  310:     Returns
  311:     -------
  312:     out : bool
  313:         Whether `arg1` is a subclass of `arg2` or not.
  314: 
  315:     See Also
  316:     --------
  317:     issubsctype, issubdtype, issctype
  318: 
  319:     Examples
  320:     --------
  321:     >>> np.issubclass_(np.int32, int)
  322:     False
  323:     >>> np.issubclass_(np.int32, float)
  324:     False
  325:     >>> np.issubclass_(np.float64, float)
  326:     True
  327: 
  328:     """
  329:     try:
  330:         return issubclass(arg1, arg2)
  331:     except TypeError:
  332:         return False
  333: 
  334: 
  335: @set_module('numpy')
  336: def issubsctype(arg1, arg2):
  337:     """
  338:     Determine if the first argument is a subclass of the second argument.
  339: 
  340:     Parameters
  341:     ----------
  342:     arg1, arg2 : dtype or dtype specifier
  343:         Data-types.
  344: 
  345:     Returns
  346:     -------
  347:     out : bool
  348:         The result.
  349: 
  350:     See Also
  351:     --------
  352:     issctype, issubdtype, obj2sctype
  353: 
  354:     Examples
  355:     --------
  356:     >>> from numpy._core import issubsctype
  357:     >>> issubsctype('S8', str)
  358:     False
  359:     >>> issubsctype(np.array([1]), int)
  360:     True
  361:     >>> issubsctype(np.array([1]), float)
  362:     False
  363: 
  364:     """
  365:     return issubclass(obj2sctype(arg1), obj2sctype(arg2))
  366: 
  367: 
  368: class _PreprocessDTypeError(Exception):
  369:     pass
  370: 
  371: 
  372: def _preprocess_dtype(dtype):
  373:     """
  374:     Preprocess dtype argument by:
  375:       1. fetching type from a data type
  376:       2. verifying that types are built-in NumPy dtypes
  377:     """
  378:     if isinstance(dtype, ma.dtype):
  379:         dtype = dtype.type
  380:     if isinstance(dtype, ndarray) or dtype not in allTypes.values():
  381:         raise _PreprocessDTypeError
  382:     return dtype
  383: 
  384: 
  385: @set_module('numpy')
  386: def isdtype(dtype, kind):
  387:     """
  388:     Determine if a provided dtype is of a specified data type ``kind``.
  389: 
  390:     This function only supports built-in NumPy's data types.
  391:     Third-party dtypes are not yet supported.
  392: 
  393:     Parameters
  394:     ----------
  395:     dtype : dtype
  396:         The input dtype.
  397:     kind : dtype or str or tuple of dtypes/strs.
  398:         dtype or dtype kind. Allowed dtype kinds are:
  399:         * ``'bool'`` : boolean kind
  400:         * ``'signed integer'`` : signed integer data types
  401:         * ``'unsigned integer'`` : unsigned integer data types
  402:         * ``'integral'`` : integer data types
  403:         * ``'real floating'`` : real-valued floating-point data types
  404:         * ``'complex floating'`` : complex floating-point data types
  405:         * ``'numeric'`` : numeric data types
  406: 
  407:     Returns
  408:     -------
  409:     out : bool
  410: 
  411:     See Also
  412:     --------
  413:     issubdtype
  414: 
  415:     Examples
  416:     --------
  417:     >>> import numpy as np
  418:     >>> np.isdtype(np.float32, np.float64)
  419:     False
  420:     >>> np.isdtype(np.float32, "real floating")
  421:     True
  422:     >>> np.isdtype(np.complex128, ("real floating", "complex floating"))
  423:     True
  424: 
  425:     """
  426:     try:
  427:         dtype = _preprocess_dtype(dtype)
  428:     except _PreprocessDTypeError:
  429:         raise TypeError(
  430:             "dtype argument must be a NumPy dtype, "
  431:             f"but it is a {type(dtype)}."
  432:         ) from None
  433: 
  434:     input_kinds = kind if isinstance(kind, tuple) else (kind,)
  435: 
  436:     processed_kinds = set()
  437: 
  438:     for kind in input_kinds:
  439:         if kind == "bool":
  440:             processed_kinds.add(allTypes["bool"])
  441:         elif kind == "signed integer":
  442:             processed_kinds.update(sctypes["int"])
  443:         elif kind == "unsigned integer":
  444:             processed_kinds.update(sctypes["uint"])
  445:         elif kind == "integral":
  446:             processed_kinds.update(sctypes["int"] + sctypes["uint"])
  447:         elif kind == "real floating":
  448:             processed_kinds.update(sctypes["float"])
  449:         elif kind == "complex floating":
  450:             processed_kinds.update(sctypes["complex"])
  451:         elif kind == "numeric":
  452:             processed_kinds.update(
  453:                 sctypes["int"] + sctypes["uint"] +
  454:                 sctypes["float"] + sctypes["complex"]
  455:             )
  456:         elif isinstance(kind, str):
  457:             raise ValueError(
  458:                 "kind argument is a string, but"
  459:                 f" {kind!r} is not a known kind name."
  460:             )
  461:         else:
  462:             try:
  463:                 kind = _preprocess_dtype(kind)
  464:             except _PreprocessDTypeError:
  465:                 raise TypeError(
  466:                     "kind argument must be comprised of "
  467:                     "NumPy dtypes or strings only, "
  468:                     f"but is a {type(kind)}."
  469:                 ) from None
  470:             processed_kinds.add(kind)
  471: 
  472:     return dtype in processed_kinds
  473: 
  474: 
  475: @set_module('numpy')
  476: def issubdtype(arg1, arg2):
  477:     r"""
  478:     Returns True if first argument is a typecode lower/equal in type hierarchy.
  479: 
  480:     This is like the builtin :func:`issubclass`, but for `dtype`\ s.
  481: 
  482:     Parameters
  483:     ----------
  484:     arg1, arg2 : dtype_like
  485:         `dtype` or object coercible to one
  486: 
  487:     Returns
  488:     -------
  489:     out : bool
  490: 
  491:     See Also
  492:     --------
  493:     :ref:`arrays.scalars` : Overview of the numpy type hierarchy.
  494: 
  495:     Examples
  496:     --------
  497:     `issubdtype` can be used to check the type of arrays:
  498: 
  499:     >>> ints = np.array([1, 2, 3], dtype=np.int32)
  500:     >>> np.issubdtype(ints.dtype, np.integer)
  501:     True
  502:     >>> np.issubdtype(ints.dtype, np.floating)
  503:     False
  504: 
  505:     >>> floats = np.array([1, 2, 3], dtype=np.float32)
  506:     >>> np.issubdtype(floats.dtype, np.integer)
  507:     False
  508:     >>> np.issubdtype(floats.dtype, np.floating)
  509:     True
  510: 
  511:     Similar types of different sizes are not subdtypes of each other:
  512: 
  513:     >>> np.issubdtype(np.float64, np.float32)
  514:     False
  515:     >>> np.issubdtype(np.float32, np.float64)
  516:     False
  517: 
  518:     but both are subtypes of `floating`:
  519: 
  520:     >>> np.issubdtype(np.float64, np.floating)
  521:     True
  522:     >>> np.issubdtype(np.float32, np.floating)
  523:     True
  524: 
  525:     For convenience, dtype-like objects are allowed too:
  526: 
  527:     >>> np.issubdtype('S1', np.bytes_)
  528:     True
  529:     >>> np.issubdtype('i4', np.signedinteger)
  530:     True
  531: 
  532:     """
  533:     if not issubclass_(arg1, generic):
  534:         arg1 = dtype(arg1).type
  535:     if not issubclass_(arg2, generic):
  536:         arg2 = dtype(arg2).type
  537: 
  538:     return issubclass(arg1, arg2)
  539: 
  540: 
  541: @set_module('numpy')
  542: def sctype2char(sctype):
  543:     """
  544:     Return the string representation of a scalar dtype.
  545: 
  546:     Parameters
  547:     ----------
  548:     sctype : scalar dtype or object
  549:         If a scalar dtype, the corresponding string character is
  550:         returned. If an object, `sctype2char` tries to infer its scalar type
  551:         and then return the corresponding string character.
  552: 
  553:     Returns
  554:     -------
  555:     typechar : str
  556:         The string character corresponding to the scalar type.
  557: 
  558:     Raises
  559:     ------
  560:     ValueError
  561:         If `sctype` is an object for which the type can not be inferred.
  562: 
  563:     See Also
  564:     --------
  565:     obj2sctype, issctype, issubsctype, mintypecode
  566: 
  567:     Examples
  568:     --------
  569:     >>> from numpy._core.numerictypes import sctype2char
  570:     >>> for sctype in [np.int32, np.double, np.cdouble, np.bytes_, np.ndarray]:
  571:     ...     print(sctype2char(sctype))
  572:     l # may vary
  573:     d
  574:     D
  575:     S
  576:     O
  577: 
  578:     >>> x = np.array([1., 2-1.j])
  579:     >>> sctype2char(x)
  580:     'D'
  581:     >>> sctype2char(list)
  582:     'O'
  583: 
  584:     """
  585:     sctype = obj2sctype(sctype)
  586:     if sctype is None:
  587:         raise ValueError("unrecognized type")
  588:     if sctype not in sctypeDict.values():
  589:         # for compatibility
  590:         raise KeyError(sctype)
  591:     return dtype(sctype).char
  592: 
  593: 
  594: def _scalar_type_key(typ):
  595:     """A ``key`` function for `sorted`."""
  596:     dt = dtype(typ)
  597:     return (dt.kind.lower(), dt.itemsize)
  598: 
  599: 
  600: ScalarType = [int, float, complex, bool, bytes, str, memoryview]
  601: ScalarType += sorted(set(sctypeDict.values()), key=_scalar_type_key)
  602: ScalarType = tuple(ScalarType)
  603: 
  604: 
  605: # Now add the types we've determined to this module
  606: for key in allTypes:
  607:     globals()[key] = allTypes[key]
  608:     __all__.append(key)
  609: 
  610: del key
  611: 
  612: typecodes = {'Character': 'c',
  613:              'Integer': 'bhilqnp',
  614:              'UnsignedInteger': 'BHILQNP',
  615:              'Float': 'efdg',
  616:              'Complex': 'FDG',
  617:              'AllInteger': 'bBhHiIlLqQnNpP',
  618:              'AllFloat': 'efdgFDG',
  619:              'Datetime': 'Mm',
  620:              'All': '?bhilqnpBHILQNPefdgFDGSUVOMm'}
  621: 
  622: # backwards compatibility --- deprecated name
  623: # Formal deprecation: Numpy 1.20.0, 2020-10-19 (see numpy/__init__.py)
  624: typeDict = sctypeDict
  625: 
  626: def _register_types():
  627:     numbers.Integral.register(integer)
  628:     numbers.Complex.register(inexact)
  629:     numbers.Real.register(floating)
  630:     numbers.Number.register(number)
  631: 
  632: 
  633: _register_types()
