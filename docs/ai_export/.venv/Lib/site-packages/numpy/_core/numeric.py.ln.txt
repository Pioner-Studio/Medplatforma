    1: import builtins
    2: import functools
    3: import itertools
    4: import math
    5: import numbers
    6: import operator
    7: import sys
    8: import warnings
    9: 
   10: import numpy as np
   11: from numpy.exceptions import AxisError
   12: 
   13: from . import multiarray, numerictypes, overrides, shape_base, umath
   14: from . import numerictypes as nt
   15: from ._ufunc_config import errstate
   16: from .multiarray import (  # noqa: F401
   17:     ALLOW_THREADS,
   18:     BUFSIZE,
   19:     CLIP,
   20:     MAXDIMS,
   21:     MAY_SHARE_BOUNDS,
   22:     MAY_SHARE_EXACT,
   23:     RAISE,
   24:     WRAP,
   25:     arange,
   26:     array,
   27:     asanyarray,
   28:     asarray,
   29:     ascontiguousarray,
   30:     asfortranarray,
   31:     broadcast,
   32:     can_cast,
   33:     concatenate,
   34:     copyto,
   35:     dot,
   36:     dtype,
   37:     empty,
   38:     empty_like,
   39:     flatiter,
   40:     from_dlpack,
   41:     frombuffer,
   42:     fromfile,
   43:     fromiter,
   44:     fromstring,
   45:     inner,
   46:     lexsort,
   47:     matmul,
   48:     may_share_memory,
   49:     min_scalar_type,
   50:     ndarray,
   51:     nditer,
   52:     nested_iters,
   53:     normalize_axis_index,
   54:     promote_types,
   55:     putmask,
   56:     result_type,
   57:     shares_memory,
   58:     vdot,
   59:     vecdot,
   60:     where,
   61:     zeros,
   62: )
   63: from .overrides import finalize_array_function_like, set_module
   64: from .umath import NAN, PINF, invert, multiply, sin
   65: 
   66: bitwise_not = invert
   67: ufunc = type(sin)
   68: newaxis = None
   69: 
   70: array_function_dispatch = functools.partial(
   71:     overrides.array_function_dispatch, module='numpy')
   72: 
   73: 
   74: __all__ = [
   75:     'newaxis', 'ndarray', 'flatiter', 'nditer', 'nested_iters', 'ufunc',
   76:     'arange', 'array', 'asarray', 'asanyarray', 'ascontiguousarray',
   77:     'asfortranarray', 'zeros', 'count_nonzero', 'empty', 'broadcast', 'dtype',
   78:     'fromstring', 'fromfile', 'frombuffer', 'from_dlpack', 'where',
   79:     'argwhere', 'copyto', 'concatenate', 'lexsort', 'astype',
   80:     'can_cast', 'promote_types', 'min_scalar_type',
   81:     'result_type', 'isfortran', 'empty_like', 'zeros_like', 'ones_like',
   82:     'correlate', 'convolve', 'inner', 'dot', 'outer', 'vdot', 'roll',
   83:     'rollaxis', 'moveaxis', 'cross', 'tensordot', 'little_endian',
   84:     'fromiter', 'array_equal', 'array_equiv', 'indices', 'fromfunction',
   85:     'isclose', 'isscalar', 'binary_repr', 'base_repr', 'ones',
   86:     'identity', 'allclose', 'putmask',
   87:     'flatnonzero', 'inf', 'nan', 'False_', 'True_', 'bitwise_not',
   88:     'full', 'full_like', 'matmul', 'vecdot', 'shares_memory',
   89:     'may_share_memory']
   90: 
   91: 
   92: def _zeros_like_dispatcher(
   93:     a, dtype=None, order=None, subok=None, shape=None, *, device=None
   94: ):
   95:     return (a,)
   96: 
   97: 
   98: @array_function_dispatch(_zeros_like_dispatcher)
   99: def zeros_like(
  100:     a, dtype=None, order='K', subok=True, shape=None, *, device=None
  101: ):
  102:     """
  103:     Return an array of zeros with the same shape and type as a given array.
  104: 
  105:     Parameters
  106:     ----------
  107:     a : array_like
  108:         The shape and data-type of `a` define these same attributes of
  109:         the returned array.
  110:     dtype : data-type, optional
  111:         Overrides the data type of the result.
  112:     order : {'C', 'F', 'A', or 'K'}, optional
  113:         Overrides the memory layout of the result. 'C' means C-order,
  114:         'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,
  115:         'C' otherwise. 'K' means match the layout of `a` as closely
  116:         as possible.
  117:     subok : bool, optional.
  118:         If True, then the newly created array will use the sub-class
  119:         type of `a`, otherwise it will be a base-class array. Defaults
  120:         to True.
  121:     shape : int or sequence of ints, optional.
  122:         Overrides the shape of the result. If order='K' and the number of
  123:         dimensions is unchanged, will try to keep order, otherwise,
  124:         order='C' is implied.
  125:     device : str, optional
  126:         The device on which to place the created array. Default: None.
  127:         For Array-API interoperability only, so must be ``"cpu"`` if passed.
  128: 
  129:         .. versionadded:: 2.0.0
  130: 
  131:     Returns
  132:     -------
  133:     out : ndarray
  134:         Array of zeros with the same shape and type as `a`.
  135: 
  136:     See Also
  137:     --------
  138:     empty_like : Return an empty array with shape and type of input.
  139:     ones_like : Return an array of ones with shape and type of input.
  140:     full_like : Return a new array with shape of input filled with value.
  141:     zeros : Return a new array setting values to zero.
  142: 
  143:     Examples
  144:     --------
  145:     >>> import numpy as np
  146:     >>> x = np.arange(6)
  147:     >>> x = x.reshape((2, 3))
  148:     >>> x
  149:     array([[0, 1, 2],
  150:            [3, 4, 5]])
  151:     >>> np.zeros_like(x)
  152:     array([[0, 0, 0],
  153:            [0, 0, 0]])
  154: 
  155:     >>> y = np.arange(3, dtype=float)
  156:     >>> y
  157:     array([0., 1., 2.])
  158:     >>> np.zeros_like(y)
  159:     array([0.,  0.,  0.])
  160: 
  161:     """
  162:     res = empty_like(
  163:         a, dtype=dtype, order=order, subok=subok, shape=shape, device=device
  164:     )
  165:     # needed instead of a 0 to get same result as zeros for string dtypes
  166:     z = zeros(1, dtype=res.dtype)
  167:     multiarray.copyto(res, z, casting='unsafe')
  168:     return res
  169: 
  170: 
  171: @finalize_array_function_like
  172: @set_module('numpy')
  173: def ones(shape, dtype=None, order='C', *, device=None, like=None):
  174:     """
  175:     Return a new array of given shape and type, filled with ones.
  176: 
  177:     Parameters
  178:     ----------
  179:     shape : int or sequence of ints
  180:         Shape of the new array, e.g., ``(2, 3)`` or ``2``.
  181:     dtype : data-type, optional
  182:         The desired data-type for the array, e.g., `numpy.int8`.  Default is
  183:         `numpy.float64`.
  184:     order : {'C', 'F'}, optional, default: C
  185:         Whether to store multi-dimensional data in row-major
  186:         (C-style) or column-major (Fortran-style) order in
  187:         memory.
  188:     device : str, optional
  189:         The device on which to place the created array. Default: None.
  190:         For Array-API interoperability only, so must be ``"cpu"`` if passed.
  191: 
  192:         .. versionadded:: 2.0.0
  193:     ${ARRAY_FUNCTION_LIKE}
  194: 
  195:         .. versionadded:: 1.20.0
  196: 
  197:     Returns
  198:     -------
  199:     out : ndarray
  200:         Array of ones with the given shape, dtype, and order.
  201: 
  202:     See Also
  203:     --------
  204:     ones_like : Return an array of ones with shape and type of input.
  205:     empty : Return a new uninitialized array.
  206:     zeros : Return a new array setting values to zero.
  207:     full : Return a new array of given shape filled with value.
  208: 
  209:     Examples
  210:     --------
  211:     >>> import numpy as np
  212:     >>> np.ones(5)
  213:     array([1., 1., 1., 1., 1.])
  214: 
  215:     >>> np.ones((5,), dtype=int)
  216:     array([1, 1, 1, 1, 1])
  217: 
  218:     >>> np.ones((2, 1))
  219:     array([[1.],
  220:            [1.]])
  221: 
  222:     >>> s = (2,2)
  223:     >>> np.ones(s)
  224:     array([[1.,  1.],
  225:            [1.,  1.]])
  226: 
  227:     """
  228:     if like is not None:
  229:         return _ones_with_like(
  230:             like, shape, dtype=dtype, order=order, device=device
  231:         )
  232: 
  233:     a = empty(shape, dtype, order, device=device)
  234:     multiarray.copyto(a, 1, casting='unsafe')
  235:     return a
  236: 
  237: 
  238: _ones_with_like = array_function_dispatch()(ones)
  239: 
  240: 
  241: def _ones_like_dispatcher(
  242:     a, dtype=None, order=None, subok=None, shape=None, *, device=None
  243: ):
  244:     return (a,)
  245: 
  246: 
  247: @array_function_dispatch(_ones_like_dispatcher)
  248: def ones_like(
  249:     a, dtype=None, order='K', subok=True, shape=None, *, device=None
  250: ):
  251:     """
  252:     Return an array of ones with the same shape and type as a given array.
  253: 
  254:     Parameters
  255:     ----------
  256:     a : array_like
  257:         The shape and data-type of `a` define these same attributes of
  258:         the returned array.
  259:     dtype : data-type, optional
  260:         Overrides the data type of the result.
  261:     order : {'C', 'F', 'A', or 'K'}, optional
  262:         Overrides the memory layout of the result. 'C' means C-order,
  263:         'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,
  264:         'C' otherwise. 'K' means match the layout of `a` as closely
  265:         as possible.
  266:     subok : bool, optional.
  267:         If True, then the newly created array will use the sub-class
  268:         type of `a`, otherwise it will be a base-class array. Defaults
  269:         to True.
  270:     shape : int or sequence of ints, optional.
  271:         Overrides the shape of the result. If order='K' and the number of
  272:         dimensions is unchanged, will try to keep order, otherwise,
  273:         order='C' is implied.
  274:     device : str, optional
  275:         The device on which to place the created array. Default: None.
  276:         For Array-API interoperability only, so must be ``"cpu"`` if passed.
  277: 
  278:         .. versionadded:: 2.0.0
  279: 
  280:     Returns
  281:     -------
  282:     out : ndarray
  283:         Array of ones with the same shape and type as `a`.
  284: 
  285:     See Also
  286:     --------
  287:     empty_like : Return an empty array with shape and type of input.
  288:     zeros_like : Return an array of zeros with shape and type of input.
  289:     full_like : Return a new array with shape of input filled with value.
  290:     ones : Return a new array setting values to one.
  291: 
  292:     Examples
  293:     --------
  294:     >>> import numpy as np
  295:     >>> x = np.arange(6)
  296:     >>> x = x.reshape((2, 3))
  297:     >>> x
  298:     array([[0, 1, 2],
  299:            [3, 4, 5]])
  300:     >>> np.ones_like(x)
  301:     array([[1, 1, 1],
  302:            [1, 1, 1]])
  303: 
  304:     >>> y = np.arange(3, dtype=float)
  305:     >>> y
  306:     array([0., 1., 2.])
  307:     >>> np.ones_like(y)
  308:     array([1.,  1.,  1.])
  309: 
  310:     """
  311:     res = empty_like(
  312:         a, dtype=dtype, order=order, subok=subok, shape=shape, device=device
  313:     )
  314:     multiarray.copyto(res, 1, casting='unsafe')
  315:     return res
  316: 
  317: 
  318: def _full_dispatcher(
  319:     shape, fill_value, dtype=None, order=None, *, device=None, like=None
  320: ):
  321:     return (like,)
  322: 
  323: 
  324: @finalize_array_function_like
  325: @set_module('numpy')
  326: def full(shape, fill_value, dtype=None, order='C', *, device=None, like=None):
  327:     """
  328:     Return a new array of given shape and type, filled with `fill_value`.
  329: 
  330:     Parameters
  331:     ----------
  332:     shape : int or sequence of ints
  333:         Shape of the new array, e.g., ``(2, 3)`` or ``2``.
  334:     fill_value : scalar or array_like
  335:         Fill value.
  336:     dtype : data-type, optional
  337:         The desired data-type for the array  The default, None, means
  338:          ``np.array(fill_value).dtype``.
  339:     order : {'C', 'F'}, optional
  340:         Whether to store multidimensional data in C- or Fortran-contiguous
  341:         (row- or column-wise) order in memory.
  342:     device : str, optional
  343:         The device on which to place the created array. Default: None.
  344:         For Array-API interoperability only, so must be ``"cpu"`` if passed.
  345: 
  346:         .. versionadded:: 2.0.0
  347:     ${ARRAY_FUNCTION_LIKE}
  348: 
  349:         .. versionadded:: 1.20.0
  350: 
  351:     Returns
  352:     -------
  353:     out : ndarray
  354:         Array of `fill_value` with the given shape, dtype, and order.
  355: 
  356:     See Also
  357:     --------
  358:     full_like : Return a new array with shape of input filled with value.
  359:     empty : Return a new uninitialized array.
  360:     ones : Return a new array setting values to one.
  361:     zeros : Return a new array setting values to zero.
  362: 
  363:     Examples
  364:     --------
  365:     >>> import numpy as np
  366:     >>> np.full((2, 2), np.inf)
  367:     array([[inf, inf],
  368:            [inf, inf]])
  369:     >>> np.full((2, 2), 10)
  370:     array([[10, 10],
  371:            [10, 10]])
  372: 
  373:     >>> np.full((2, 2), [1, 2])
  374:     array([[1, 2],
  375:            [1, 2]])
  376: 
  377:     """
  378:     if like is not None:
  379:         return _full_with_like(
  380:             like, shape, fill_value, dtype=dtype, order=order, device=device
  381:         )
  382: 
  383:     if dtype is None:
  384:         fill_value = asarray(fill_value)
  385:         dtype = fill_value.dtype
  386:     a = empty(shape, dtype, order, device=device)
  387:     multiarray.copyto(a, fill_value, casting='unsafe')
  388:     return a
  389: 
  390: 
  391: _full_with_like = array_function_dispatch()(full)
  392: 
  393: 
  394: def _full_like_dispatcher(
  395:     a, fill_value, dtype=None, order=None, subok=None, shape=None,
  396:     *, device=None
  397: ):
  398:     return (a,)
  399: 
  400: 
  401: @array_function_dispatch(_full_like_dispatcher)
  402: def full_like(
  403:     a, fill_value, dtype=None, order='K', subok=True, shape=None,
  404:     *, device=None
  405: ):
  406:     """
  407:     Return a full array with the same shape and type as a given array.
  408: 
  409:     Parameters
  410:     ----------
  411:     a : array_like
  412:         The shape and data-type of `a` define these same attributes of
  413:         the returned array.
  414:     fill_value : array_like
  415:         Fill value.
  416:     dtype : data-type, optional
  417:         Overrides the data type of the result.
  418:     order : {'C', 'F', 'A', or 'K'}, optional
  419:         Overrides the memory layout of the result. 'C' means C-order,
  420:         'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,
  421:         'C' otherwise. 'K' means match the layout of `a` as closely
  422:         as possible.
  423:     subok : bool, optional.
  424:         If True, then the newly created array will use the sub-class
  425:         type of `a`, otherwise it will be a base-class array. Defaults
  426:         to True.
  427:     shape : int or sequence of ints, optional.
  428:         Overrides the shape of the result. If order='K' and the number of
  429:         dimensions is unchanged, will try to keep order, otherwise,
  430:         order='C' is implied.
  431:     device : str, optional
  432:         The device on which to place the created array. Default: None.
  433:         For Array-API interoperability only, so must be ``"cpu"`` if passed.
  434: 
  435:         .. versionadded:: 2.0.0
  436: 
  437:     Returns
  438:     -------
  439:     out : ndarray
  440:         Array of `fill_value` with the same shape and type as `a`.
  441: 
  442:     See Also
  443:     --------
  444:     empty_like : Return an empty array with shape and type of input.
  445:     ones_like : Return an array of ones with shape and type of input.
  446:     zeros_like : Return an array of zeros with shape and type of input.
  447:     full : Return a new array of given shape filled with value.
  448: 
  449:     Examples
  450:     --------
  451:     >>> import numpy as np
  452:     >>> x = np.arange(6, dtype=int)
  453:     >>> np.full_like(x, 1)
  454:     array([1, 1, 1, 1, 1, 1])
  455:     >>> np.full_like(x, 0.1)
  456:     array([0, 0, 0, 0, 0, 0])
  457:     >>> np.full_like(x, 0.1, dtype=np.double)
  458:     array([0.1, 0.1, 0.1, 0.1, 0.1, 0.1])
  459:     >>> np.full_like(x, np.nan, dtype=np.double)
  460:     array([nan, nan, nan, nan, nan, nan])
  461: 
  462:     >>> y = np.arange(6, dtype=np.double)
  463:     >>> np.full_like(y, 0.1)
  464:     array([0.1, 0.1, 0.1, 0.1, 0.1, 0.1])
  465: 
  466:     >>> y = np.zeros([2, 2, 3], dtype=int)
  467:     >>> np.full_like(y, [0, 0, 255])
  468:     array([[[  0,   0, 255],
  469:             [  0,   0, 255]],
  470:            [[  0,   0, 255],
  471:             [  0,   0, 255]]])
  472:     """
  473:     res = empty_like(
  474:         a, dtype=dtype, order=order, subok=subok, shape=shape, device=device
  475:     )
  476:     multiarray.copyto(res, fill_value, casting='unsafe')
  477:     return res
  478: 
  479: 
  480: def _count_nonzero_dispatcher(a, axis=None, *, keepdims=None):
  481:     return (a,)
  482: 
  483: 
  484: @array_function_dispatch(_count_nonzero_dispatcher)
  485: def count_nonzero(a, axis=None, *, keepdims=False):
  486:     """
  487:     Counts the number of non-zero values in the array ``a``.
  488: 
  489:     The word "non-zero" is in reference to the Python 2.x
  490:     built-in method ``__nonzero__()`` (renamed ``__bool__()``
  491:     in Python 3.x) of Python objects that tests an object's
  492:     "truthfulness". For example, any number is considered
  493:     truthful if it is nonzero, whereas any string is considered
  494:     truthful if it is not the empty string. Thus, this function
  495:     (recursively) counts how many elements in ``a`` (and in
  496:     sub-arrays thereof) have their ``__nonzero__()`` or ``__bool__()``
  497:     method evaluated to ``True``.
  498: 
  499:     Parameters
  500:     ----------
  501:     a : array_like
  502:         The array for which to count non-zeros.
  503:     axis : int or tuple, optional
  504:         Axis or tuple of axes along which to count non-zeros.
  505:         Default is None, meaning that non-zeros will be counted
  506:         along a flattened version of ``a``.
  507:     keepdims : bool, optional
  508:         If this is set to True, the axes that are counted are left
  509:         in the result as dimensions with size one. With this option,
  510:         the result will broadcast correctly against the input array.
  511: 
  512:     Returns
  513:     -------
  514:     count : int or array of int
  515:         Number of non-zero values in the array along a given axis.
  516:         Otherwise, the total number of non-zero values in the array
  517:         is returned.
  518: 
  519:     See Also
  520:     --------
  521:     nonzero : Return the coordinates of all the non-zero values.
  522: 
  523:     Examples
  524:     --------
  525:     >>> import numpy as np
  526:     >>> np.count_nonzero(np.eye(4))
  527:     4
  528:     >>> a = np.array([[0, 1, 7, 0],
  529:     ...               [3, 0, 2, 19]])
  530:     >>> np.count_nonzero(a)
  531:     5
  532:     >>> np.count_nonzero(a, axis=0)
  533:     array([1, 1, 2, 1])
  534:     >>> np.count_nonzero(a, axis=1)
  535:     array([2, 3])
  536:     >>> np.count_nonzero(a, axis=1, keepdims=True)
  537:     array([[2],
  538:            [3]])
  539:     """
  540:     if axis is None and not keepdims:
  541:         return multiarray.count_nonzero(a)
  542: 
  543:     a = asanyarray(a)
  544: 
  545:     # TODO: this works around .astype(bool) not working properly (gh-9847)
  546:     if np.issubdtype(a.dtype, np.character):
  547:         a_bool = a != a.dtype.type()
  548:     else:
  549:         a_bool = a.astype(np.bool, copy=False)
  550: 
  551:     return a_bool.sum(axis=axis, dtype=np.intp, keepdims=keepdims)
  552: 
  553: 
  554: @set_module('numpy')
  555: def isfortran(a):
  556:     """
  557:     Check if the array is Fortran contiguous but *not* C contiguous.
  558: 
  559:     This function is obsolete. If you only want to check if an array is Fortran
  560:     contiguous use ``a.flags.f_contiguous`` instead.
  561: 
  562:     Parameters
  563:     ----------
  564:     a : ndarray
  565:         Input array.
  566: 
  567:     Returns
  568:     -------
  569:     isfortran : bool
  570:         Returns True if the array is Fortran contiguous but *not* C contiguous.
  571: 
  572: 
  573:     Examples
  574:     --------
  575: 
  576:     np.array allows to specify whether the array is written in C-contiguous
  577:     order (last index varies the fastest), or FORTRAN-contiguous order in
  578:     memory (first index varies the fastest).
  579: 
  580:     >>> import numpy as np
  581:     >>> a = np.array([[1, 2, 3], [4, 5, 6]], order='C')
  582:     >>> a
  583:     array([[1, 2, 3],
  584:            [4, 5, 6]])
  585:     >>> np.isfortran(a)
  586:     False
  587: 
  588:     >>> b = np.array([[1, 2, 3], [4, 5, 6]], order='F')
  589:     >>> b
  590:     array([[1, 2, 3],
  591:            [4, 5, 6]])
  592:     >>> np.isfortran(b)
  593:     True
  594: 
  595: 
  596:     The transpose of a C-ordered array is a FORTRAN-ordered array.
  597: 
  598:     >>> a = np.array([[1, 2, 3], [4, 5, 6]], order='C')
  599:     >>> a
  600:     array([[1, 2, 3],
  601:            [4, 5, 6]])
  602:     >>> np.isfortran(a)
  603:     False
  604:     >>> b = a.T
  605:     >>> b
  606:     array([[1, 4],
  607:            [2, 5],
  608:            [3, 6]])
  609:     >>> np.isfortran(b)
  610:     True
  611: 
  612:     C-ordered arrays evaluate as False even if they are also FORTRAN-ordered.
  613: 
  614:     >>> np.isfortran(np.array([1, 2], order='F'))
  615:     False
  616: 
  617:     """
  618:     return a.flags.fnc
  619: 
  620: 
  621: def _argwhere_dispatcher(a):
  622:     return (a,)
  623: 
  624: 
  625: @array_function_dispatch(_argwhere_dispatcher)
  626: def argwhere(a):
  627:     """
  628:     Find the indices of array elements that are non-zero, grouped by element.
  629: 
  630:     Parameters
  631:     ----------
  632:     a : array_like
  633:         Input data.
  634: 
  635:     Returns
  636:     -------
  637:     index_array : (N, a.ndim) ndarray
  638:         Indices of elements that are non-zero. Indices are grouped by element.
  639:         This array will have shape ``(N, a.ndim)`` where ``N`` is the number of
  640:         non-zero items.
  641: 
  642:     See Also
  643:     --------
  644:     where, nonzero
  645: 
  646:     Notes
  647:     -----
  648:     ``np.argwhere(a)`` is almost the same as ``np.transpose(np.nonzero(a))``,
  649:     but produces a result of the correct shape for a 0D array.
  650: 
  651:     The output of ``argwhere`` is not suitable for indexing arrays.
  652:     For this purpose use ``nonzero(a)`` instead.
  653: 
  654:     Examples
  655:     --------
  656:     >>> import numpy as np
  657:     >>> x = np.arange(6).reshape(2,3)
  658:     >>> x
  659:     array([[0, 1, 2],
  660:            [3, 4, 5]])
  661:     >>> np.argwhere(x>1)
  662:     array([[0, 2],
  663:            [1, 0],
  664:            [1, 1],
  665:            [1, 2]])
  666: 
  667:     """
  668:     # nonzero does not behave well on 0d, so promote to 1d
  669:     if np.ndim(a) == 0:
  670:         a = shape_base.atleast_1d(a)
  671:         # then remove the added dimension
  672:         return argwhere(a)[:, :0]
  673:     return transpose(nonzero(a))
  674: 
  675: 
  676: def _flatnonzero_dispatcher(a):
  677:     return (a,)
  678: 
  679: 
  680: @array_function_dispatch(_flatnonzero_dispatcher)
  681: def flatnonzero(a):
  682:     """
  683:     Return indices that are non-zero in the flattened version of a.
  684: 
  685:     This is equivalent to ``np.nonzero(np.ravel(a))[0]``.
  686: 
  687:     Parameters
  688:     ----------
  689:     a : array_like
  690:         Input data.
  691: 
  692:     Returns
  693:     -------
  694:     res : ndarray
  695:         Output array, containing the indices of the elements of ``a.ravel()``
  696:         that are non-zero.
  697: 
  698:     See Also
  699:     --------
  700:     nonzero : Return the indices of the non-zero elements of the input array.
  701:     ravel : Return a 1-D array containing the elements of the input array.
  702: 
  703:     Examples
  704:     --------
  705:     >>> import numpy as np
  706:     >>> x = np.arange(-2, 3)
  707:     >>> x
  708:     array([-2, -1,  0,  1,  2])
  709:     >>> np.flatnonzero(x)
  710:     array([0, 1, 3, 4])
  711: 
  712:     Use the indices of the non-zero elements as an index array to extract
  713:     these elements:
  714: 
  715:     >>> x.ravel()[np.flatnonzero(x)]
  716:     array([-2, -1,  1,  2])
  717: 
  718:     """
  719:     return np.nonzero(np.ravel(a))[0]
  720: 
  721: 
  722: def _correlate_dispatcher(a, v, mode=None):
  723:     return (a, v)
  724: 
  725: 
  726: @array_function_dispatch(_correlate_dispatcher)
  727: def correlate(a, v, mode='valid'):
  728:     r"""
  729:     Cross-correlation of two 1-dimensional sequences.
  730: 
  731:     This function computes the correlation as generally defined in signal
  732:     processing texts [1]_:
  733: 
  734:     .. math:: c_k = \sum_n a_{n+k} \cdot \overline{v}_n
  735: 
  736:     with a and v sequences being zero-padded where necessary and
  737:     :math:`\overline v` denoting complex conjugation.
  738: 
  739:     Parameters
  740:     ----------
  741:     a, v : array_like
  742:         Input sequences.
  743:     mode : {'valid', 'same', 'full'}, optional
  744:         Refer to the `convolve` docstring.  Note that the default
  745:         is 'valid', unlike `convolve`, which uses 'full'.
  746: 
  747:     Returns
  748:     -------
  749:     out : ndarray
  750:         Discrete cross-correlation of `a` and `v`.
  751: 
  752:     See Also
  753:     --------
  754:     convolve : Discrete, linear convolution of two one-dimensional sequences.
  755:     scipy.signal.correlate : uses FFT which has superior performance
  756:         on large arrays.
  757: 
  758:     Notes
  759:     -----
  760:     The definition of correlation above is not unique and sometimes
  761:     correlation may be defined differently. Another common definition is [1]_:
  762: 
  763:     .. math:: c'_k = \sum_n a_{n} \cdot \overline{v_{n+k}}
  764: 
  765:     which is related to :math:`c_k` by :math:`c'_k = c_{-k}`.
  766: 
  767:     `numpy.correlate` may perform slowly in large arrays (i.e. n = 1e5)
  768:     because it does not use the FFT to compute the convolution; in that case,
  769:     `scipy.signal.correlate` might be preferable.
  770: 
  771:     References
  772:     ----------
  773:     .. [1] Wikipedia, "Cross-correlation",
  774:            https://en.wikipedia.org/wiki/Cross-correlation
  775: 
  776:     Examples
  777:     --------
  778:     >>> import numpy as np
  779:     >>> np.correlate([1, 2, 3], [0, 1, 0.5])
  780:     array([3.5])
  781:     >>> np.correlate([1, 2, 3], [0, 1, 0.5], "same")
  782:     array([2. ,  3.5,  3. ])
  783:     >>> np.correlate([1, 2, 3], [0, 1, 0.5], "full")
  784:     array([0.5,  2. ,  3.5,  3. ,  0. ])
  785: 
  786:     Using complex sequences:
  787: 
  788:     >>> np.correlate([1+1j, 2, 3-1j], [0, 1, 0.5j], 'full')
  789:     array([ 0.5-0.5j,  1.0+0.j ,  1.5-1.5j,  3.0-1.j ,  0.0+0.j ])
  790: 
  791:     Note that you get the time reversed, complex conjugated result
  792:     (:math:`\overline{c_{-k}}`) when the two input sequences a and v change
  793:     places:
  794: 
  795:     >>> np.correlate([0, 1, 0.5j], [1+1j, 2, 3-1j], 'full')
  796:     array([ 0.0+0.j ,  3.0+1.j ,  1.5+1.5j,  1.0+0.j ,  0.5+0.5j])
  797: 
  798:     """
  799:     return multiarray.correlate2(a, v, mode)
  800: 
  801: 
  802: def _convolve_dispatcher(a, v, mode=None):
  803:     return (a, v)
  804: 
  805: 
  806: @array_function_dispatch(_convolve_dispatcher)
  807: def convolve(a, v, mode='full'):
  808:     """
  809:     Returns the discrete, linear convolution of two one-dimensional sequences.
  810: 
  811:     The convolution operator is often seen in signal processing, where it
  812:     models the effect of a linear time-invariant system on a signal [1]_.  In
  813:     probability theory, the sum of two independent random variables is
  814:     distributed according to the convolution of their individual
  815:     distributions.
  816: 
  817:     If `v` is longer than `a`, the arrays are swapped before computation.
  818: 
  819:     Parameters
  820:     ----------
  821:     a : (N,) array_like
  822:         First one-dimensional input array.
  823:     v : (M,) array_like
  824:         Second one-dimensional input array.
  825:     mode : {'full', 'valid', 'same'}, optional
  826:         'full':
  827:           By default, mode is 'full'.  This returns the convolution
  828:           at each point of overlap, with an output shape of (N+M-1,). At
  829:           the end-points of the convolution, the signals do not overlap
  830:           completely, and boundary effects may be seen.
  831: 
  832:         'same':
  833:           Mode 'same' returns output of length ``max(M, N)``.  Boundary
  834:           effects are still visible.
  835: 
  836:         'valid':
  837:           Mode 'valid' returns output of length
  838:           ``max(M, N) - min(M, N) + 1``.  The convolution product is only given
  839:           for points where the signals overlap completely.  Values outside
  840:           the signal boundary have no effect.
  841: 
  842:     Returns
  843:     -------
  844:     out : ndarray
  845:         Discrete, linear convolution of `a` and `v`.
  846: 
  847:     See Also
  848:     --------
  849:     scipy.signal.fftconvolve : Convolve two arrays using the Fast Fourier
  850:                                Transform.
  851:     scipy.linalg.toeplitz : Used to construct the convolution operator.
  852:     polymul : Polynomial multiplication. Same output as convolve, but also
  853:               accepts poly1d objects as input.
  854: 
  855:     Notes
  856:     -----
  857:     The discrete convolution operation is defined as
  858: 
  859:     .. math:: (a * v)_n = \\sum_{m = -\\infty}^{\\infty} a_m v_{n - m}
  860: 
  861:     It can be shown that a convolution :math:`x(t) * y(t)` in time/space
  862:     is equivalent to the multiplication :math:`X(f) Y(f)` in the Fourier
  863:     domain, after appropriate padding (padding is necessary to prevent
  864:     circular convolution).  Since multiplication is more efficient (faster)
  865:     than convolution, the function `scipy.signal.fftconvolve` exploits the
  866:     FFT to calculate the convolution of large data-sets.
  867: 
  868:     References
  869:     ----------
  870:     .. [1] Wikipedia, "Convolution",
  871:         https://en.wikipedia.org/wiki/Convolution
  872: 
  873:     Examples
  874:     --------
  875:     Note how the convolution operator flips the second array
  876:     before "sliding" the two across one another:
  877: 
  878:     >>> import numpy as np
  879:     >>> np.convolve([1, 2, 3], [0, 1, 0.5])
  880:     array([0. , 1. , 2.5, 4. , 1.5])
  881: 
  882:     Only return the middle values of the convolution.
  883:     Contains boundary effects, where zeros are taken
  884:     into account:
  885: 
  886:     >>> np.convolve([1,2,3],[0,1,0.5], 'same')
  887:     array([1. ,  2.5,  4. ])
  888: 
  889:     The two arrays are of the same length, so there
  890:     is only one position where they completely overlap:
  891: 
  892:     >>> np.convolve([1,2,3],[0,1,0.5], 'valid')
  893:     array([2.5])
  894: 
  895:     """
  896:     a, v = array(a, copy=None, ndmin=1), array(v, copy=None, ndmin=1)
  897:     if (len(v) > len(a)):
  898:         a, v = v, a
  899:     if len(a) == 0:
  900:         raise ValueError('a cannot be empty')
  901:     if len(v) == 0:
  902:         raise ValueError('v cannot be empty')
  903:     return multiarray.correlate(a, v[::-1], mode)
  904: 
  905: 
  906: def _outer_dispatcher(a, b, out=None):
  907:     return (a, b, out)
  908: 
  909: 
  910: @array_function_dispatch(_outer_dispatcher)
  911: def outer(a, b, out=None):
  912:     """
  913:     Compute the outer product of two vectors.
  914: 
  915:     Given two vectors `a` and `b` of length ``M`` and ``N``, respectively,
  916:     the outer product [1]_ is::
  917: 
  918:       [[a_0*b_0  a_0*b_1 ... a_0*b_{N-1} ]
  919:        [a_1*b_0    .
  920:        [ ...          .
  921:        [a_{M-1}*b_0            a_{M-1}*b_{N-1} ]]
  922: 
  923:     Parameters
  924:     ----------
  925:     a : (M,) array_like
  926:         First input vector.  Input is flattened if
  927:         not already 1-dimensional.
  928:     b : (N,) array_like
  929:         Second input vector.  Input is flattened if
  930:         not already 1-dimensional.
  931:     out : (M, N) ndarray, optional
  932:         A location where the result is stored
  933: 
  934:     Returns
  935:     -------
  936:     out : (M, N) ndarray
  937:         ``out[i, j] = a[i] * b[j]``
  938: 
  939:     See also
  940:     --------
  941:     inner
  942:     einsum : ``einsum('i,j->ij', a.ravel(), b.ravel())`` is the equivalent.
  943:     ufunc.outer : A generalization to dimensions other than 1D and other
  944:                   operations. ``np.multiply.outer(a.ravel(), b.ravel())``
  945:                   is the equivalent.
  946:     linalg.outer : An Array API compatible variation of ``np.outer``,
  947:                    which accepts 1-dimensional inputs only.
  948:     tensordot : ``np.tensordot(a.ravel(), b.ravel(), axes=((), ()))``
  949:                 is the equivalent.
  950: 
  951:     References
  952:     ----------
  953:     .. [1] G. H. Golub and C. F. Van Loan, *Matrix Computations*, 3rd
  954:            ed., Baltimore, MD, Johns Hopkins University Press, 1996,
  955:            pg. 8.
  956: 
  957:     Examples
  958:     --------
  959:     Make a (*very* coarse) grid for computing a Mandelbrot set:
  960: 
  961:     >>> import numpy as np
  962:     >>> rl = np.outer(np.ones((5,)), np.linspace(-2, 2, 5))
  963:     >>> rl
  964:     array([[-2., -1.,  0.,  1.,  2.],
  965:            [-2., -1.,  0.,  1.,  2.],
  966:            [-2., -1.,  0.,  1.,  2.],
  967:            [-2., -1.,  0.,  1.,  2.],
  968:            [-2., -1.,  0.,  1.,  2.]])
  969:     >>> im = np.outer(1j*np.linspace(2, -2, 5), np.ones((5,)))
  970:     >>> im
  971:     array([[0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j],
  972:            [0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j],
  973:            [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
  974:            [0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j],
  975:            [0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j]])
  976:     >>> grid = rl + im
  977:     >>> grid
  978:     array([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],
  979:            [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],
  980:            [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],
  981:            [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],
  982:            [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])
  983: 
  984:     An example using a "vector" of letters:
  985: 
  986:     >>> x = np.array(['a', 'b', 'c'], dtype=object)
  987:     >>> np.outer(x, [1, 2, 3])
  988:     array([['a', 'aa', 'aaa'],
  989:            ['b', 'bb', 'bbb'],
  990:            ['c', 'cc', 'ccc']], dtype=object)
  991: 
  992:     """
  993:     a = asarray(a)
  994:     b = asarray(b)
  995:     return multiply(a.ravel()[:, newaxis], b.ravel()[newaxis, :], out)
  996: 
  997: 
  998: def _tensordot_dispatcher(a, b, axes=None):
  999:     return (a, b)
 1000: 
 1001: 
 1002: @array_function_dispatch(_tensordot_dispatcher)
 1003: def tensordot(a, b, axes=2):
 1004:     """
 1005:     Compute tensor dot product along specified axes.
 1006: 
 1007:     Given two tensors, `a` and `b`, and an array_like object containing
 1008:     two array_like objects, ``(a_axes, b_axes)``, sum the products of
 1009:     `a`'s and `b`'s elements (components) over the axes specified by
 1010:     ``a_axes`` and ``b_axes``. The third argument can be a single non-negative
 1011:     integer_like scalar, ``N``; if it is such, then the last ``N`` dimensions
 1012:     of `a` and the first ``N`` dimensions of `b` are summed over.
 1013: 
 1014:     Parameters
 1015:     ----------
 1016:     a, b : array_like
 1017:         Tensors to "dot".
 1018: 
 1019:     axes : int or (2,) array_like
 1020:         * integer_like
 1021:           If an int N, sum over the last N axes of `a` and the first N axes
 1022:           of `b` in order. The sizes of the corresponding axes must match.
 1023:         * (2,) array_like
 1024:           Or, a list of axes to be summed over, first sequence applying to `a`,
 1025:           second to `b`. Both elements array_like must be of the same length.
 1026: 
 1027:     Returns
 1028:     -------
 1029:     output : ndarray
 1030:         The tensor dot product of the input.
 1031: 
 1032:     See Also
 1033:     --------
 1034:     dot, einsum
 1035: 
 1036:     Notes
 1037:     -----
 1038:     Three common use cases are:
 1039:         * ``axes = 0`` : tensor product :math:`a\\otimes b`
 1040:         * ``axes = 1`` : tensor dot product :math:`a\\cdot b`
 1041:         * ``axes = 2`` : (default) tensor double contraction :math:`a:b`
 1042: 
 1043:     When `axes` is integer_like, the sequence of axes for evaluation
 1044:     will be: from the -Nth axis to the -1th axis in `a`,
 1045:     and from the 0th axis to (N-1)th axis in `b`.
 1046:     For example, ``axes = 2`` is the equal to
 1047:     ``axes = [[-2, -1], [0, 1]]``.
 1048:     When N-1 is smaller than 0, or when -N is larger than -1,
 1049:     the element of `a` and `b` are defined as the `axes`.
 1050: 
 1051:     When there is more than one axis to sum over - and they are not the last
 1052:     (first) axes of `a` (`b`) - the argument `axes` should consist of
 1053:     two sequences of the same length, with the first axis to sum over given
 1054:     first in both sequences, the second axis second, and so forth.
 1055:     The calculation can be referred to ``numpy.einsum``.
 1056: 
 1057:     The shape of the result consists of the non-contracted axes of the
 1058:     first tensor, followed by the non-contracted axes of the second.
 1059: 
 1060:     Examples
 1061:     --------
 1062:     An example on integer_like:
 1063: 
 1064:     >>> a_0 = np.array([[1, 2], [3, 4]])
 1065:     >>> b_0 = np.array([[5, 6], [7, 8]])
 1066:     >>> c_0 = np.tensordot(a_0, b_0, axes=0)
 1067:     >>> c_0.shape
 1068:     (2, 2, 2, 2)
 1069:     >>> c_0
 1070:     array([[[[ 5,  6],
 1071:              [ 7,  8]],
 1072:             [[10, 12],
 1073:              [14, 16]]],
 1074:            [[[15, 18],
 1075:              [21, 24]],
 1076:             [[20, 24],
 1077:              [28, 32]]]])
 1078: 
 1079:     An example on array_like:
 1080: 
 1081:     >>> a = np.arange(60.).reshape(3,4,5)
 1082:     >>> b = np.arange(24.).reshape(4,3,2)
 1083:     >>> c = np.tensordot(a,b, axes=([1,0],[0,1]))
 1084:     >>> c.shape
 1085:     (5, 2)
 1086:     >>> c
 1087:     array([[4400., 4730.],
 1088:            [4532., 4874.],
 1089:            [4664., 5018.],
 1090:            [4796., 5162.],
 1091:            [4928., 5306.]])
 1092: 
 1093:     A slower but equivalent way of computing the same...
 1094: 
 1095:     >>> d = np.zeros((5,2))
 1096:     >>> for i in range(5):
 1097:     ...   for j in range(2):
 1098:     ...     for k in range(3):
 1099:     ...       for n in range(4):
 1100:     ...         d[i,j] += a[k,n,i] * b[n,k,j]
 1101:     >>> c == d
 1102:     array([[ True,  True],
 1103:            [ True,  True],
 1104:            [ True,  True],
 1105:            [ True,  True],
 1106:            [ True,  True]])
 1107: 
 1108:     An extended example taking advantage of the overloading of + and \\*:
 1109: 
 1110:     >>> a = np.array(range(1, 9))
 1111:     >>> a.shape = (2, 2, 2)
 1112:     >>> A = np.array(('a', 'b', 'c', 'd'), dtype=object)
 1113:     >>> A.shape = (2, 2)
 1114:     >>> a; A
 1115:     array([[[1, 2],
 1116:             [3, 4]],
 1117:            [[5, 6],
 1118:             [7, 8]]])
 1119:     array([['a', 'b'],
 1120:            ['c', 'd']], dtype=object)
 1121: 
 1122:     >>> np.tensordot(a, A) # third argument default is 2 for double-contraction
 1123:     array(['abbcccdddd', 'aaaaabbbbbbcccccccdddddddd'], dtype=object)
 1124: 
 1125:     >>> np.tensordot(a, A, 1)
 1126:     array([[['acc', 'bdd'],
 1127:             ['aaacccc', 'bbbdddd']],
 1128:            [['aaaaacccccc', 'bbbbbdddddd'],
 1129:             ['aaaaaaacccccccc', 'bbbbbbbdddddddd']]], dtype=object)
 1130: 
 1131:     >>> np.tensordot(a, A, 0) # tensor product (result too long to incl.)
 1132:     array([[[[['a', 'b'],
 1133:               ['c', 'd']],
 1134:               ...
 1135: 
 1136:     >>> np.tensordot(a, A, (0, 1))
 1137:     array([[['abbbbb', 'cddddd'],
 1138:             ['aabbbbbb', 'ccdddddd']],
 1139:            [['aaabbbbbbb', 'cccddddddd'],
 1140:             ['aaaabbbbbbbb', 'ccccdddddddd']]], dtype=object)
 1141: 
 1142:     >>> np.tensordot(a, A, (2, 1))
 1143:     array([[['abb', 'cdd'],
 1144:             ['aaabbbb', 'cccdddd']],
 1145:            [['aaaaabbbbbb', 'cccccdddddd'],
 1146:             ['aaaaaaabbbbbbbb', 'cccccccdddddddd']]], dtype=object)
 1147: 
 1148:     >>> np.tensordot(a, A, ((0, 1), (0, 1)))
 1149:     array(['abbbcccccddddddd', 'aabbbbccccccdddddddd'], dtype=object)
 1150: 
 1151:     >>> np.tensordot(a, A, ((2, 1), (1, 0)))
 1152:     array(['acccbbdddd', 'aaaaacccccccbbbbbbdddddddd'], dtype=object)
 1153: 
 1154:     """
 1155:     try:
 1156:         iter(axes)
 1157:     except Exception:
 1158:         axes_a = list(range(-axes, 0))
 1159:         axes_b = list(range(axes))
 1160:     else:
 1161:         axes_a, axes_b = axes
 1162:     try:
 1163:         na = len(axes_a)
 1164:         axes_a = list(axes_a)
 1165:     except TypeError:
 1166:         axes_a = [axes_a]
 1167:         na = 1
 1168:     try:
 1169:         nb = len(axes_b)
 1170:         axes_b = list(axes_b)
 1171:     except TypeError:
 1172:         axes_b = [axes_b]
 1173:         nb = 1
 1174: 
 1175:     a, b = asarray(a), asarray(b)
 1176:     as_ = a.shape
 1177:     nda = a.ndim
 1178:     bs = b.shape
 1179:     ndb = b.ndim
 1180:     equal = True
 1181:     if na != nb:
 1182:         equal = False
 1183:     else:
 1184:         for k in range(na):
 1185:             if as_[axes_a[k]] != bs[axes_b[k]]:
 1186:                 equal = False
 1187:                 break
 1188:             if axes_a[k] < 0:
 1189:                 axes_a[k] += nda
 1190:             if axes_b[k] < 0:
 1191:                 axes_b[k] += ndb
 1192:     if not equal:
 1193:         raise ValueError("shape-mismatch for sum")
 1194: 
 1195:     # Move the axes to sum over to the end of "a"
 1196:     # and to the front of "b"
 1197:     notin = [k for k in range(nda) if k not in axes_a]
 1198:     newaxes_a = notin + axes_a
 1199:     N2 = math.prod(as_[axis] for axis in axes_a)
 1200:     newshape_a = (math.prod(as_[ax] for ax in notin), N2)
 1201:     olda = [as_[axis] for axis in notin]
 1202: 
 1203:     notin = [k for k in range(ndb) if k not in axes_b]
 1204:     newaxes_b = axes_b + notin
 1205:     N2 = math.prod(bs[axis] for axis in axes_b)
 1206:     newshape_b = (N2, math.prod(bs[ax] for ax in notin))
 1207:     oldb = [bs[axis] for axis in notin]
 1208: 
 1209:     at = a.transpose(newaxes_a).reshape(newshape_a)
 1210:     bt = b.transpose(newaxes_b).reshape(newshape_b)
 1211:     res = dot(at, bt)
 1212:     return res.reshape(olda + oldb)
 1213: 
 1214: 
 1215: def _roll_dispatcher(a, shift, axis=None):
 1216:     return (a,)
 1217: 
 1218: 
 1219: @array_function_dispatch(_roll_dispatcher)
 1220: def roll(a, shift, axis=None):
 1221:     """
 1222:     Roll array elements along a given axis.
 1223: 
 1224:     Elements that roll beyond the last position are re-introduced at
 1225:     the first.
 1226: 
 1227:     Parameters
 1228:     ----------
 1229:     a : array_like
 1230:         Input array.
 1231:     shift : int or tuple of ints
 1232:         The number of places by which elements are shifted.  If a tuple,
 1233:         then `axis` must be a tuple of the same size, and each of the
 1234:         given axes is shifted by the corresponding number.  If an int
 1235:         while `axis` is a tuple of ints, then the same value is used for
 1236:         all given axes.
 1237:     axis : int or tuple of ints, optional
 1238:         Axis or axes along which elements are shifted.  By default, the
 1239:         array is flattened before shifting, after which the original
 1240:         shape is restored.
 1241: 
 1242:     Returns
 1243:     -------
 1244:     res : ndarray
 1245:         Output array, with the same shape as `a`.
 1246: 
 1247:     See Also
 1248:     --------
 1249:     rollaxis : Roll the specified axis backwards, until it lies in a
 1250:                given position.
 1251: 
 1252:     Notes
 1253:     -----
 1254:     Supports rolling over multiple dimensions simultaneously.
 1255: 
 1256:     Examples
 1257:     --------
 1258:     >>> import numpy as np
 1259:     >>> x = np.arange(10)
 1260:     >>> np.roll(x, 2)
 1261:     array([8, 9, 0, 1, 2, 3, 4, 5, 6, 7])
 1262:     >>> np.roll(x, -2)
 1263:     array([2, 3, 4, 5, 6, 7, 8, 9, 0, 1])
 1264: 
 1265:     >>> x2 = np.reshape(x, (2, 5))
 1266:     >>> x2
 1267:     array([[0, 1, 2, 3, 4],
 1268:            [5, 6, 7, 8, 9]])
 1269:     >>> np.roll(x2, 1)
 1270:     array([[9, 0, 1, 2, 3],
 1271:            [4, 5, 6, 7, 8]])
 1272:     >>> np.roll(x2, -1)
 1273:     array([[1, 2, 3, 4, 5],
 1274:            [6, 7, 8, 9, 0]])
 1275:     >>> np.roll(x2, 1, axis=0)
 1276:     array([[5, 6, 7, 8, 9],
 1277:            [0, 1, 2, 3, 4]])
 1278:     >>> np.roll(x2, -1, axis=0)
 1279:     array([[5, 6, 7, 8, 9],
 1280:            [0, 1, 2, 3, 4]])
 1281:     >>> np.roll(x2, 1, axis=1)
 1282:     array([[4, 0, 1, 2, 3],
 1283:            [9, 5, 6, 7, 8]])
 1284:     >>> np.roll(x2, -1, axis=1)
 1285:     array([[1, 2, 3, 4, 0],
 1286:            [6, 7, 8, 9, 5]])
 1287:     >>> np.roll(x2, (1, 1), axis=(1, 0))
 1288:     array([[9, 5, 6, 7, 8],
 1289:            [4, 0, 1, 2, 3]])
 1290:     >>> np.roll(x2, (2, 1), axis=(1, 0))
 1291:     array([[8, 9, 5, 6, 7],
 1292:            [3, 4, 0, 1, 2]])
 1293: 
 1294:     """
 1295:     a = asanyarray(a)
 1296:     if axis is None:
 1297:         return roll(a.ravel(), shift, 0).reshape(a.shape)
 1298: 
 1299:     else:
 1300:         axis = normalize_axis_tuple(axis, a.ndim, allow_duplicate=True)
 1301:         broadcasted = broadcast(shift, axis)
 1302:         if broadcasted.ndim > 1:
 1303:             raise ValueError(
 1304:                 "'shift' and 'axis' should be scalars or 1D sequences")
 1305:         shifts = dict.fromkeys(range(a.ndim), 0)
 1306:         for sh, ax in broadcasted:
 1307:             shifts[ax] += int(sh)
 1308: 
 1309:         rolls = [((slice(None), slice(None)),)] * a.ndim
 1310:         for ax, offset in shifts.items():
 1311:             offset %= a.shape[ax] or 1  # If `a` is empty, nothing matters.
 1312:             if offset:
 1313:                 # (original, result), (original, result)
 1314:                 rolls[ax] = ((slice(None, -offset), slice(offset, None)),
 1315:                              (slice(-offset, None), slice(None, offset)))
 1316: 
 1317:         result = empty_like(a)
 1318:         for indices in itertools.product(*rolls):
 1319:             arr_index, res_index = zip(*indices)
 1320:             result[res_index] = a[arr_index]
 1321: 
 1322:         return result
 1323: 
 1324: 
 1325: def _rollaxis_dispatcher(a, axis, start=None):
 1326:     return (a,)
 1327: 
 1328: 
 1329: @array_function_dispatch(_rollaxis_dispatcher)
 1330: def rollaxis(a, axis, start=0):
 1331:     """
 1332:     Roll the specified axis backwards, until it lies in a given position.
 1333: 
 1334:     This function continues to be supported for backward compatibility, but you
 1335:     should prefer `moveaxis`. The `moveaxis` function was added in NumPy
 1336:     1.11.
 1337: 
 1338:     Parameters
 1339:     ----------
 1340:     a : ndarray
 1341:         Input array.
 1342:     axis : int
 1343:         The axis to be rolled. The positions of the other axes do not
 1344:         change relative to one another.
 1345:     start : int, optional
 1346:         When ``start <= axis``, the axis is rolled back until it lies in
 1347:         this position. When ``start > axis``, the axis is rolled until it
 1348:         lies before this position. The default, 0, results in a "complete"
 1349:         roll. The following table describes how negative values of ``start``
 1350:         are interpreted:
 1351: 
 1352:         .. table::
 1353:            :align: left
 1354: 
 1355:            +-------------------+----------------------+
 1356:            |     ``start``     | Normalized ``start`` |
 1357:            +===================+======================+
 1358:            | ``-(arr.ndim+1)`` | raise ``AxisError``  |
 1359:            +-------------------+----------------------+
 1360:            | ``-arr.ndim``     | 0                    |
 1361:            +-------------------+----------------------+
 1362:            | |vdots|           | |vdots|              |
 1363:            +-------------------+----------------------+
 1364:            | ``-1``            | ``arr.ndim-1``       |
 1365:            +-------------------+----------------------+
 1366:            | ``0``             | ``0``                |
 1367:            +-------------------+----------------------+
 1368:            | |vdots|           | |vdots|              |
 1369:            +-------------------+----------------------+
 1370:            | ``arr.ndim``      | ``arr.ndim``         |
 1371:            +-------------------+----------------------+
 1372:            | ``arr.ndim + 1``  | raise ``AxisError``  |
 1373:            +-------------------+----------------------+
 1374: 
 1375:         .. |vdots|   unicode:: U+22EE .. Vertical Ellipsis
 1376: 
 1377:     Returns
 1378:     -------
 1379:     res : ndarray
 1380:         For NumPy >= 1.10.0 a view of `a` is always returned. For earlier
 1381:         NumPy versions a view of `a` is returned only if the order of the
 1382:         axes is changed, otherwise the input array is returned.
 1383: 
 1384:     See Also
 1385:     --------
 1386:     moveaxis : Move array axes to new positions.
 1387:     roll : Roll the elements of an array by a number of positions along a
 1388:         given axis.
 1389: 
 1390:     Examples
 1391:     --------
 1392:     >>> import numpy as np
 1393:     >>> a = np.ones((3,4,5,6))
 1394:     >>> np.rollaxis(a, 3, 1).shape
 1395:     (3, 6, 4, 5)
 1396:     >>> np.rollaxis(a, 2).shape
 1397:     (5, 3, 4, 6)
 1398:     >>> np.rollaxis(a, 1, 4).shape
 1399:     (3, 5, 6, 4)
 1400: 
 1401:     """
 1402:     n = a.ndim
 1403:     axis = normalize_axis_index(axis, n)
 1404:     if start < 0:
 1405:         start += n
 1406:     msg = "'%s' arg requires %d <= %s < %d, but %d was passed in"
 1407:     if not (0 <= start < n + 1):
 1408:         raise AxisError(msg % ('start', -n, 'start', n + 1, start))
 1409:     if axis < start:
 1410:         # it's been removed
 1411:         start -= 1
 1412:     if axis == start:
 1413:         return a[...]
 1414:     axes = list(range(n))
 1415:     axes.remove(axis)
 1416:     axes.insert(start, axis)
 1417:     return a.transpose(axes)
 1418: 
 1419: 
 1420: @set_module("numpy.lib.array_utils")
 1421: def normalize_axis_tuple(axis, ndim, argname=None, allow_duplicate=False):
 1422:     """
 1423:     Normalizes an axis argument into a tuple of non-negative integer axes.
 1424: 
 1425:     This handles shorthands such as ``1`` and converts them to ``(1,)``,
 1426:     as well as performing the handling of negative indices covered by
 1427:     `normalize_axis_index`.
 1428: 
 1429:     By default, this forbids axes from being specified multiple times.
 1430: 
 1431:     Used internally by multi-axis-checking logic.
 1432: 
 1433:     Parameters
 1434:     ----------
 1435:     axis : int, iterable of int
 1436:         The un-normalized index or indices of the axis.
 1437:     ndim : int
 1438:         The number of dimensions of the array that `axis` should be normalized
 1439:         against.
 1440:     argname : str, optional
 1441:         A prefix to put before the error message, typically the name of the
 1442:         argument.
 1443:     allow_duplicate : bool, optional
 1444:         If False, the default, disallow an axis from being specified twice.
 1445: 
 1446:     Returns
 1447:     -------
 1448:     normalized_axes : tuple of int
 1449:         The normalized axis index, such that `0 <= normalized_axis < ndim`
 1450: 
 1451:     Raises
 1452:     ------
 1453:     AxisError
 1454:         If any axis provided is out of range
 1455:     ValueError
 1456:         If an axis is repeated
 1457: 
 1458:     See also
 1459:     --------
 1460:     normalize_axis_index : normalizing a single scalar axis
 1461:     """
 1462:     # Optimization to speed-up the most common cases.
 1463:     if not isinstance(axis, (tuple, list)):
 1464:         try:
 1465:             axis = [operator.index(axis)]
 1466:         except TypeError:
 1467:             pass
 1468:     # Going via an iterator directly is slower than via list comprehension.
 1469:     axis = tuple(normalize_axis_index(ax, ndim, argname) for ax in axis)
 1470:     if not allow_duplicate and len(set(axis)) != len(axis):
 1471:         if argname:
 1472:             raise ValueError(f'repeated axis in `{argname}` argument')
 1473:         else:
 1474:             raise ValueError('repeated axis')
 1475:     return axis
 1476: 
 1477: 
 1478: def _moveaxis_dispatcher(a, source, destination):
 1479:     return (a,)
 1480: 
 1481: 
 1482: @array_function_dispatch(_moveaxis_dispatcher)
 1483: def moveaxis(a, source, destination):
 1484:     """
 1485:     Move axes of an array to new positions.
 1486: 
 1487:     Other axes remain in their original order.
 1488: 
 1489:     Parameters
 1490:     ----------
 1491:     a : np.ndarray
 1492:         The array whose axes should be reordered.
 1493:     source : int or sequence of int
 1494:         Original positions of the axes to move. These must be unique.
 1495:     destination : int or sequence of int
 1496:         Destination positions for each of the original axes. These must also be
 1497:         unique.
 1498: 
 1499:     Returns
 1500:     -------
 1501:     result : np.ndarray
 1502:         Array with moved axes. This array is a view of the input array.
 1503: 
 1504:     See Also
 1505:     --------
 1506:     transpose : Permute the dimensions of an array.
 1507:     swapaxes : Interchange two axes of an array.
 1508: 
 1509:     Examples
 1510:     --------
 1511:     >>> import numpy as np
 1512:     >>> x = np.zeros((3, 4, 5))
 1513:     >>> np.moveaxis(x, 0, -1).shape
 1514:     (4, 5, 3)
 1515:     >>> np.moveaxis(x, -1, 0).shape
 1516:     (5, 3, 4)
 1517: 
 1518:     These all achieve the same result:
 1519: 
 1520:     >>> np.transpose(x).shape
 1521:     (5, 4, 3)
 1522:     >>> np.swapaxes(x, 0, -1).shape
 1523:     (5, 4, 3)
 1524:     >>> np.moveaxis(x, [0, 1], [-1, -2]).shape
 1525:     (5, 4, 3)
 1526:     >>> np.moveaxis(x, [0, 1, 2], [-1, -2, -3]).shape
 1527:     (5, 4, 3)
 1528: 
 1529:     """
 1530:     try:
 1531:         # allow duck-array types if they define transpose
 1532:         transpose = a.transpose
 1533:     except AttributeError:
 1534:         a = asarray(a)
 1535:         transpose = a.transpose
 1536: 
 1537:     source = normalize_axis_tuple(source, a.ndim, 'source')
 1538:     destination = normalize_axis_tuple(destination, a.ndim, 'destination')
 1539:     if len(source) != len(destination):
 1540:         raise ValueError('`source` and `destination` arguments must have '
 1541:                          'the same number of elements')
 1542: 
 1543:     order = [n for n in range(a.ndim) if n not in source]
 1544: 
 1545:     for dest, src in sorted(zip(destination, source)):
 1546:         order.insert(dest, src)
 1547: 
 1548:     result = transpose(order)
 1549:     return result
 1550: 
 1551: 
 1552: def _cross_dispatcher(a, b, axisa=None, axisb=None, axisc=None, axis=None):
 1553:     return (a, b)
 1554: 
 1555: 
 1556: @array_function_dispatch(_cross_dispatcher)
 1557: def cross(a, b, axisa=-1, axisb=-1, axisc=-1, axis=None):
 1558:     """
 1559:     Return the cross product of two (arrays of) vectors.
 1560: 
 1561:     The cross product of `a` and `b` in :math:`R^3` is a vector perpendicular
 1562:     to both `a` and `b`.  If `a` and `b` are arrays of vectors, the vectors
 1563:     are defined by the last axis of `a` and `b` by default, and these axes
 1564:     can have dimensions 2 or 3.  Where the dimension of either `a` or `b` is
 1565:     2, the third component of the input vector is assumed to be zero and the
 1566:     cross product calculated accordingly.  In cases where both input vectors
 1567:     have dimension 2, the z-component of the cross product is returned.
 1568: 
 1569:     Parameters
 1570:     ----------
 1571:     a : array_like
 1572:         Components of the first vector(s).
 1573:     b : array_like
 1574:         Components of the second vector(s).
 1575:     axisa : int, optional
 1576:         Axis of `a` that defines the vector(s).  By default, the last axis.
 1577:     axisb : int, optional
 1578:         Axis of `b` that defines the vector(s).  By default, the last axis.
 1579:     axisc : int, optional
 1580:         Axis of `c` containing the cross product vector(s).  Ignored if
 1581:         both input vectors have dimension 2, as the return is scalar.
 1582:         By default, the last axis.
 1583:     axis : int, optional
 1584:         If defined, the axis of `a`, `b` and `c` that defines the vector(s)
 1585:         and cross product(s).  Overrides `axisa`, `axisb` and `axisc`.
 1586: 
 1587:     Returns
 1588:     -------
 1589:     c : ndarray
 1590:         Vector cross product(s).
 1591: 
 1592:     Raises
 1593:     ------
 1594:     ValueError
 1595:         When the dimension of the vector(s) in `a` and/or `b` does not
 1596:         equal 2 or 3.
 1597: 
 1598:     See Also
 1599:     --------
 1600:     inner : Inner product
 1601:     outer : Outer product.
 1602:     linalg.cross : An Array API compatible variation of ``np.cross``,
 1603:                    which accepts (arrays of) 3-element vectors only.
 1604:     ix_ : Construct index arrays.
 1605: 
 1606:     Notes
 1607:     -----
 1608:     Supports full broadcasting of the inputs.
 1609: 
 1610:     Dimension-2 input arrays were deprecated in 2.0.0. If you do need this
 1611:     functionality, you can use::
 1612: 
 1613:         def cross2d(x, y):
 1614:             return x[..., 0] * y[..., 1] - x[..., 1] * y[..., 0]
 1615: 
 1616:     Examples
 1617:     --------
 1618:     Vector cross-product.
 1619: 
 1620:     >>> import numpy as np
 1621:     >>> x = [1, 2, 3]
 1622:     >>> y = [4, 5, 6]
 1623:     >>> np.cross(x, y)
 1624:     array([-3,  6, -3])
 1625: 
 1626:     One vector with dimension 2.
 1627: 
 1628:     >>> x = [1, 2]
 1629:     >>> y = [4, 5, 6]
 1630:     >>> np.cross(x, y)
 1631:     array([12, -6, -3])
 1632: 
 1633:     Equivalently:
 1634: 
 1635:     >>> x = [1, 2, 0]
 1636:     >>> y = [4, 5, 6]
 1637:     >>> np.cross(x, y)
 1638:     array([12, -6, -3])
 1639: 
 1640:     Both vectors with dimension 2.
 1641: 
 1642:     >>> x = [1,2]
 1643:     >>> y = [4,5]
 1644:     >>> np.cross(x, y)
 1645:     array(-3)
 1646: 
 1647:     Multiple vector cross-products. Note that the direction of the cross
 1648:     product vector is defined by the *right-hand rule*.
 1649: 
 1650:     >>> x = np.array([[1,2,3], [4,5,6]])
 1651:     >>> y = np.array([[4,5,6], [1,2,3]])
 1652:     >>> np.cross(x, y)
 1653:     array([[-3,  6, -3],
 1654:            [ 3, -6,  3]])
 1655: 
 1656:     The orientation of `c` can be changed using the `axisc` keyword.
 1657: 
 1658:     >>> np.cross(x, y, axisc=0)
 1659:     array([[-3,  3],
 1660:            [ 6, -6],
 1661:            [-3,  3]])
 1662: 
 1663:     Change the vector definition of `x` and `y` using `axisa` and `axisb`.
 1664: 
 1665:     >>> x = np.array([[1,2,3], [4,5,6], [7, 8, 9]])
 1666:     >>> y = np.array([[7, 8, 9], [4,5,6], [1,2,3]])
 1667:     >>> np.cross(x, y)
 1668:     array([[ -6,  12,  -6],
 1669:            [  0,   0,   0],
 1670:            [  6, -12,   6]])
 1671:     >>> np.cross(x, y, axisa=0, axisb=0)
 1672:     array([[-24,  48, -24],
 1673:            [-30,  60, -30],
 1674:            [-36,  72, -36]])
 1675: 
 1676:     """
 1677:     if axis is not None:
 1678:         axisa, axisb, axisc = (axis,) * 3
 1679:     a = asarray(a)
 1680:     b = asarray(b)
 1681: 
 1682:     if (a.ndim < 1) or (b.ndim < 1):
 1683:         raise ValueError("At least one array has zero dimension")
 1684: 
 1685:     # Check axisa and axisb are within bounds
 1686:     axisa = normalize_axis_index(axisa, a.ndim, msg_prefix='axisa')
 1687:     axisb = normalize_axis_index(axisb, b.ndim, msg_prefix='axisb')
 1688: 
 1689:     # Move working axis to the end of the shape
 1690:     a = moveaxis(a, axisa, -1)
 1691:     b = moveaxis(b, axisb, -1)
 1692:     msg = ("incompatible dimensions for cross product\n"
 1693:            "(dimension must be 2 or 3)")
 1694:     if a.shape[-1] not in (2, 3) or b.shape[-1] not in (2, 3):
 1695:         raise ValueError(msg)
 1696:     if a.shape[-1] == 2 or b.shape[-1] == 2:
 1697:         # Deprecated in NumPy 2.0, 2023-09-26
 1698:         warnings.warn(
 1699:             "Arrays of 2-dimensional vectors are deprecated. Use arrays of "
 1700:             "3-dimensional vectors instead. (deprecated in NumPy 2.0)",
 1701:             DeprecationWarning, stacklevel=2
 1702:         )
 1703: 
 1704:     # Create the output array
 1705:     shape = broadcast(a[..., 0], b[..., 0]).shape
 1706:     if a.shape[-1] == 3 or b.shape[-1] == 3:
 1707:         shape += (3,)
 1708:         # Check axisc is within bounds
 1709:         axisc = normalize_axis_index(axisc, len(shape), msg_prefix='axisc')
 1710:     dtype = promote_types(a.dtype, b.dtype)
 1711:     cp = empty(shape, dtype)
 1712: 
 1713:     # recast arrays as dtype
 1714:     a = a.astype(dtype)
 1715:     b = b.astype(dtype)
 1716: 
 1717:     # create local aliases for readability
 1718:     a0 = a[..., 0]
 1719:     a1 = a[..., 1]
 1720:     if a.shape[-1] == 3:
 1721:         a2 = a[..., 2]
 1722:     b0 = b[..., 0]
 1723:     b1 = b[..., 1]
 1724:     if b.shape[-1] == 3:
 1725:         b2 = b[..., 2]
 1726:     if cp.ndim != 0 and cp.shape[-1] == 3:
 1727:         cp0 = cp[..., 0]
 1728:         cp1 = cp[..., 1]
 1729:         cp2 = cp[..., 2]
 1730: 
 1731:     if a.shape[-1] == 2:
 1732:         if b.shape[-1] == 2:
 1733:             # a0 * b1 - a1 * b0
 1734:             multiply(a0, b1, out=cp)
 1735:             cp -= a1 * b0
 1736:             return cp
 1737:         else:
 1738:             assert b.shape[-1] == 3
 1739:             # cp0 = a1 * b2 - 0  (a2 = 0)
 1740:             # cp1 = 0 - a0 * b2  (a2 = 0)
 1741:             # cp2 = a0 * b1 - a1 * b0
 1742:             multiply(a1, b2, out=cp0)
 1743:             multiply(a0, b2, out=cp1)
 1744:             negative(cp1, out=cp1)
 1745:             multiply(a0, b1, out=cp2)
 1746:             cp2 -= a1 * b0
 1747:     else:
 1748:         assert a.shape[-1] == 3
 1749:         if b.shape[-1] == 3:
 1750:             # cp0 = a1 * b2 - a2 * b1
 1751:             # cp1 = a2 * b0 - a0 * b2
 1752:             # cp2 = a0 * b1 - a1 * b0
 1753:             multiply(a1, b2, out=cp0)
 1754:             tmp = np.multiply(a2, b1, out=...)
 1755:             cp0 -= tmp
 1756:             multiply(a2, b0, out=cp1)
 1757:             multiply(a0, b2, out=tmp)
 1758:             cp1 -= tmp
 1759:             multiply(a0, b1, out=cp2)
 1760:             multiply(a1, b0, out=tmp)
 1761:             cp2 -= tmp
 1762:         else:
 1763:             assert b.shape[-1] == 2
 1764:             # cp0 = 0 - a2 * b1  (b2 = 0)
 1765:             # cp1 = a2 * b0 - 0  (b2 = 0)
 1766:             # cp2 = a0 * b1 - a1 * b0
 1767:             multiply(a2, b1, out=cp0)
 1768:             negative(cp0, out=cp0)
 1769:             multiply(a2, b0, out=cp1)
 1770:             multiply(a0, b1, out=cp2)
 1771:             cp2 -= a1 * b0
 1772: 
 1773:     return moveaxis(cp, -1, axisc)
 1774: 
 1775: 
 1776: little_endian = (sys.byteorder == 'little')
 1777: 
 1778: 
 1779: @set_module('numpy')
 1780: def indices(dimensions, dtype=int, sparse=False):
 1781:     """
 1782:     Return an array representing the indices of a grid.
 1783: 
 1784:     Compute an array where the subarrays contain index values 0, 1, ...
 1785:     varying only along the corresponding axis.
 1786: 
 1787:     Parameters
 1788:     ----------
 1789:     dimensions : sequence of ints
 1790:         The shape of the grid.
 1791:     dtype : dtype, optional
 1792:         Data type of the result.
 1793:     sparse : boolean, optional
 1794:         Return a sparse representation of the grid instead of a dense
 1795:         representation. Default is False.
 1796: 
 1797:     Returns
 1798:     -------
 1799:     grid : one ndarray or tuple of ndarrays
 1800:         If sparse is False:
 1801:             Returns one array of grid indices,
 1802:             ``grid.shape = (len(dimensions),) + tuple(dimensions)``.
 1803:         If sparse is True:
 1804:             Returns a tuple of arrays, with
 1805:             ``grid[i].shape = (1, ..., 1, dimensions[i], 1, ..., 1)`` with
 1806:             dimensions[i] in the ith place
 1807: 
 1808:     See Also
 1809:     --------
 1810:     mgrid, ogrid, meshgrid
 1811: 
 1812:     Notes
 1813:     -----
 1814:     The output shape in the dense case is obtained by prepending the number
 1815:     of dimensions in front of the tuple of dimensions, i.e. if `dimensions`
 1816:     is a tuple ``(r0, ..., rN-1)`` of length ``N``, the output shape is
 1817:     ``(N, r0, ..., rN-1)``.
 1818: 
 1819:     The subarrays ``grid[k]`` contains the N-D array of indices along the
 1820:     ``k-th`` axis. Explicitly::
 1821: 
 1822:         grid[k, i0, i1, ..., iN-1] = ik
 1823: 
 1824:     Examples
 1825:     --------
 1826:     >>> import numpy as np
 1827:     >>> grid = np.indices((2, 3))
 1828:     >>> grid.shape
 1829:     (2, 2, 3)
 1830:     >>> grid[0]        # row indices
 1831:     array([[0, 0, 0],
 1832:            [1, 1, 1]])
 1833:     >>> grid[1]        # column indices
 1834:     array([[0, 1, 2],
 1835:            [0, 1, 2]])
 1836: 
 1837:     The indices can be used as an index into an array.
 1838: 
 1839:     >>> x = np.arange(20).reshape(5, 4)
 1840:     >>> row, col = np.indices((2, 3))
 1841:     >>> x[row, col]
 1842:     array([[0, 1, 2],
 1843:            [4, 5, 6]])
 1844: 
 1845:     Note that it would be more straightforward in the above example to
 1846:     extract the required elements directly with ``x[:2, :3]``.
 1847: 
 1848:     If sparse is set to true, the grid will be returned in a sparse
 1849:     representation.
 1850: 
 1851:     >>> i, j = np.indices((2, 3), sparse=True)
 1852:     >>> i.shape
 1853:     (2, 1)
 1854:     >>> j.shape
 1855:     (1, 3)
 1856:     >>> i        # row indices
 1857:     array([[0],
 1858:            [1]])
 1859:     >>> j        # column indices
 1860:     array([[0, 1, 2]])
 1861: 
 1862:     """
 1863:     dimensions = tuple(dimensions)
 1864:     N = len(dimensions)
 1865:     shape = (1,) * N
 1866:     if sparse:
 1867:         res = ()
 1868:     else:
 1869:         res = empty((N,) + dimensions, dtype=dtype)
 1870:     for i, dim in enumerate(dimensions):
 1871:         idx = arange(dim, dtype=dtype).reshape(
 1872:             shape[:i] + (dim,) + shape[i + 1:]
 1873:         )
 1874:         if sparse:
 1875:             res = res + (idx,)
 1876:         else:
 1877:             res[i] = idx
 1878:     return res
 1879: 
 1880: 
 1881: @finalize_array_function_like
 1882: @set_module('numpy')
 1883: def fromfunction(function, shape, *, dtype=float, like=None, **kwargs):
 1884:     """
 1885:     Construct an array by executing a function over each coordinate.
 1886: 
 1887:     The resulting array therefore has a value ``fn(x, y, z)`` at
 1888:     coordinate ``(x, y, z)``.
 1889: 
 1890:     Parameters
 1891:     ----------
 1892:     function : callable
 1893:         The function is called with N parameters, where N is the rank of
 1894:         `shape`.  Each parameter represents the coordinates of the array
 1895:         varying along a specific axis.  For example, if `shape`
 1896:         were ``(2, 2)``, then the parameters would be
 1897:         ``array([[0, 0], [1, 1]])`` and ``array([[0, 1], [0, 1]])``
 1898:     shape : (N,) tuple of ints
 1899:         Shape of the output array, which also determines the shape of
 1900:         the coordinate arrays passed to `function`.
 1901:     dtype : data-type, optional
 1902:         Data-type of the coordinate arrays passed to `function`.
 1903:         By default, `dtype` is float.
 1904:     ${ARRAY_FUNCTION_LIKE}
 1905: 
 1906:         .. versionadded:: 1.20.0
 1907: 
 1908:     Returns
 1909:     -------
 1910:     fromfunction : any
 1911:         The result of the call to `function` is passed back directly.
 1912:         Therefore the shape of `fromfunction` is completely determined by
 1913:         `function`.  If `function` returns a scalar value, the shape of
 1914:         `fromfunction` would not match the `shape` parameter.
 1915: 
 1916:     See Also
 1917:     --------
 1918:     indices, meshgrid
 1919: 
 1920:     Notes
 1921:     -----
 1922:     Keywords other than `dtype` and `like` are passed to `function`.
 1923: 
 1924:     Examples
 1925:     --------
 1926:     >>> import numpy as np
 1927:     >>> np.fromfunction(lambda i, j: i, (2, 2), dtype=float)
 1928:     array([[0., 0.],
 1929:            [1., 1.]])
 1930: 
 1931:     >>> np.fromfunction(lambda i, j: j, (2, 2), dtype=float)
 1932:     array([[0., 1.],
 1933:            [0., 1.]])
 1934: 
 1935:     >>> np.fromfunction(lambda i, j: i == j, (3, 3), dtype=int)
 1936:     array([[ True, False, False],
 1937:            [False,  True, False],
 1938:            [False, False,  True]])
 1939: 
 1940:     >>> np.fromfunction(lambda i, j: i + j, (3, 3), dtype=int)
 1941:     array([[0, 1, 2],
 1942:            [1, 2, 3],
 1943:            [2, 3, 4]])
 1944: 
 1945:     """
 1946:     if like is not None:
 1947:         return _fromfunction_with_like(
 1948:                 like, function, shape, dtype=dtype, **kwargs)
 1949: 
 1950:     args = indices(shape, dtype=dtype)
 1951:     return function(*args, **kwargs)
 1952: 
 1953: 
 1954: _fromfunction_with_like = array_function_dispatch()(fromfunction)
 1955: 
 1956: 
 1957: def _frombuffer(buf, dtype, shape, order, axis_order=None):
 1958:     array = frombuffer(buf, dtype=dtype)
 1959:     if order == 'K' and axis_order is not None:
 1960:         return array.reshape(shape, order='C').transpose(axis_order)
 1961:     return array.reshape(shape, order=order)
 1962: 
 1963: 
 1964: @set_module('numpy')
 1965: def isscalar(element):
 1966:     """
 1967:     Returns True if the type of `element` is a scalar type.
 1968: 
 1969:     Parameters
 1970:     ----------
 1971:     element : any
 1972:         Input argument, can be of any type and shape.
 1973: 
 1974:     Returns
 1975:     -------
 1976:     val : bool
 1977:         True if `element` is a scalar type, False if it is not.
 1978: 
 1979:     See Also
 1980:     --------
 1981:     ndim : Get the number of dimensions of an array
 1982: 
 1983:     Notes
 1984:     -----
 1985:     If you need a stricter way to identify a *numerical* scalar, use
 1986:     ``isinstance(x, numbers.Number)``, as that returns ``False`` for most
 1987:     non-numerical elements such as strings.
 1988: 
 1989:     In most cases ``np.ndim(x) == 0`` should be used instead of this function,
 1990:     as that will also return true for 0d arrays. This is how numpy overloads
 1991:     functions in the style of the ``dx`` arguments to `gradient` and
 1992:     the ``bins`` argument to `histogram`. Some key differences:
 1993: 
 1994:     +------------------------------------+---------------+-------------------+
 1995:     | x                                  |``isscalar(x)``|``np.ndim(x) == 0``|
 1996:     +====================================+===============+===================+
 1997:     | PEP 3141 numeric objects           | ``True``      | ``True``          |
 1998:     | (including builtins)               |               |                   |
 1999:     +------------------------------------+---------------+-------------------+
 2000:     | builtin string and buffer objects  | ``True``      | ``True``          |
 2001:     +------------------------------------+---------------+-------------------+
 2002:     | other builtin objects, like        | ``False``     | ``True``          |
 2003:     | `pathlib.Path`, `Exception`,       |               |                   |
 2004:     | the result of `re.compile`         |               |                   |
 2005:     +------------------------------------+---------------+-------------------+
 2006:     | third-party objects like           | ``False``     | ``True``          |
 2007:     | `matplotlib.figure.Figure`         |               |                   |
 2008:     +------------------------------------+---------------+-------------------+
 2009:     | zero-dimensional numpy arrays      | ``False``     | ``True``          |
 2010:     +------------------------------------+---------------+-------------------+
 2011:     | other numpy arrays                 | ``False``     | ``False``         |
 2012:     +------------------------------------+---------------+-------------------+
 2013:     | `list`, `tuple`, and other         | ``False``     | ``False``         |
 2014:     | sequence objects                   |               |                   |
 2015:     +------------------------------------+---------------+-------------------+
 2016: 
 2017:     Examples
 2018:     --------
 2019:     >>> import numpy as np
 2020: 
 2021:     >>> np.isscalar(3.1)
 2022:     True
 2023: 
 2024:     >>> np.isscalar(np.array(3.1))
 2025:     False
 2026: 
 2027:     >>> np.isscalar([3.1])
 2028:     False
 2029: 
 2030:     >>> np.isscalar(False)
 2031:     True
 2032: 
 2033:     >>> np.isscalar('numpy')
 2034:     True
 2035: 
 2036:     NumPy supports PEP 3141 numbers:
 2037: 
 2038:     >>> from fractions import Fraction
 2039:     >>> np.isscalar(Fraction(5, 17))
 2040:     True
 2041:     >>> from numbers import Number
 2042:     >>> np.isscalar(Number())
 2043:     True
 2044: 
 2045:     """
 2046:     return (isinstance(element, generic)
 2047:             or type(element) in ScalarType
 2048:             or isinstance(element, numbers.Number))
 2049: 
 2050: 
 2051: @set_module('numpy')
 2052: def binary_repr(num, width=None):
 2053:     """
 2054:     Return the binary representation of the input number as a string.
 2055: 
 2056:     For negative numbers, if width is not given, a minus sign is added to the
 2057:     front. If width is given, the two's complement of the number is
 2058:     returned, with respect to that width.
 2059: 
 2060:     In a two's-complement system negative numbers are represented by the two's
 2061:     complement of the absolute value. This is the most common method of
 2062:     representing signed integers on computers [1]_. A N-bit two's-complement
 2063:     system can represent every integer in the range
 2064:     :math:`-2^{N-1}` to :math:`+2^{N-1}-1`.
 2065: 
 2066:     Parameters
 2067:     ----------
 2068:     num : int
 2069:         Only an integer decimal number can be used.
 2070:     width : int, optional
 2071:         The length of the returned string if `num` is positive, or the length
 2072:         of the two's complement if `num` is negative, provided that `width` is
 2073:         at least a sufficient number of bits for `num` to be represented in
 2074:         the designated form. If the `width` value is insufficient, an error is
 2075:         raised.
 2076: 
 2077:     Returns
 2078:     -------
 2079:     bin : str
 2080:         Binary representation of `num` or two's complement of `num`.
 2081: 
 2082:     See Also
 2083:     --------
 2084:     base_repr: Return a string representation of a number in the given base
 2085:                system.
 2086:     bin: Python's built-in binary representation generator of an integer.
 2087: 
 2088:     Notes
 2089:     -----
 2090:     `binary_repr` is equivalent to using `base_repr` with base 2, but about 25x
 2091:     faster.
 2092: 
 2093:     References
 2094:     ----------
 2095:     .. [1] Wikipedia, "Two's complement",
 2096:         https://en.wikipedia.org/wiki/Two's_complement
 2097: 
 2098:     Examples
 2099:     --------
 2100:     >>> import numpy as np
 2101:     >>> np.binary_repr(3)
 2102:     '11'
 2103:     >>> np.binary_repr(-3)
 2104:     '-11'
 2105:     >>> np.binary_repr(3, width=4)
 2106:     '0011'
 2107: 
 2108:     The two's complement is returned when the input number is negative and
 2109:     width is specified:
 2110: 
 2111:     >>> np.binary_repr(-3, width=3)
 2112:     '101'
 2113:     >>> np.binary_repr(-3, width=5)
 2114:     '11101'
 2115: 
 2116:     """
 2117:     def err_if_insufficient(width, binwidth):
 2118:         if width is not None and width < binwidth:
 2119:             raise ValueError(
 2120:                 f"Insufficient bit {width=} provided for {binwidth=}"
 2121:             )
 2122: 
 2123:     # Ensure that num is a Python integer to avoid overflow or unwanted
 2124:     # casts to floating point.
 2125:     num = operator.index(num)
 2126: 
 2127:     if num == 0:
 2128:         return '0' * (width or 1)
 2129: 
 2130:     elif num > 0:
 2131:         binary = f'{num:b}'
 2132:         binwidth = len(binary)
 2133:         outwidth = (binwidth if width is None
 2134:                     else builtins.max(binwidth, width))
 2135:         err_if_insufficient(width, binwidth)
 2136:         return binary.zfill(outwidth)
 2137: 
 2138:     elif width is None:
 2139:         return f'-{-num:b}'
 2140: 
 2141:     else:
 2142:         poswidth = len(f'{-num:b}')
 2143: 
 2144:         # See gh-8679: remove extra digit
 2145:         # for numbers at boundaries.
 2146:         if 2**(poswidth - 1) == -num:
 2147:             poswidth -= 1
 2148: 
 2149:         twocomp = 2**(poswidth + 1) + num
 2150:         binary = f'{twocomp:b}'
 2151:         binwidth = len(binary)
 2152: 
 2153:         outwidth = builtins.max(binwidth, width)
 2154:         err_if_insufficient(width, binwidth)
 2155:         return '1' * (outwidth - binwidth) + binary
 2156: 
 2157: 
 2158: @set_module('numpy')
 2159: def base_repr(number, base=2, padding=0):
 2160:     """
 2161:     Return a string representation of a number in the given base system.
 2162: 
 2163:     Parameters
 2164:     ----------
 2165:     number : int
 2166:         The value to convert. Positive and negative values are handled.
 2167:     base : int, optional
 2168:         Convert `number` to the `base` number system. The valid range is 2-36,
 2169:         the default value is 2.
 2170:     padding : int, optional
 2171:         Number of zeros padded on the left. Default is 0 (no padding).
 2172: 
 2173:     Returns
 2174:     -------
 2175:     out : str
 2176:         String representation of `number` in `base` system.
 2177: 
 2178:     See Also
 2179:     --------
 2180:     binary_repr : Faster version of `base_repr` for base 2.
 2181: 
 2182:     Examples
 2183:     --------
 2184:     >>> import numpy as np
 2185:     >>> np.base_repr(5)
 2186:     '101'
 2187:     >>> np.base_repr(6, 5)
 2188:     '11'
 2189:     >>> np.base_repr(7, base=5, padding=3)
 2190:     '00012'
 2191: 
 2192:     >>> np.base_repr(10, base=16)
 2193:     'A'
 2194:     >>> np.base_repr(32, base=16)
 2195:     '20'
 2196: 
 2197:     """
 2198:     digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'
 2199:     if base > len(digits):
 2200:         raise ValueError("Bases greater than 36 not handled in base_repr.")
 2201:     elif base < 2:
 2202:         raise ValueError("Bases less than 2 not handled in base_repr.")
 2203: 
 2204:     num = abs(int(number))
 2205:     res = []
 2206:     while num:
 2207:         res.append(digits[num % base])
 2208:         num //= base
 2209:     if padding:
 2210:         res.append('0' * padding)
 2211:     if number < 0:
 2212:         res.append('-')
 2213:     return ''.join(reversed(res or '0'))
 2214: 
 2215: 
 2216: # These are all essentially abbreviations
 2217: # These might wind up in a special abbreviations module
 2218: 
 2219: 
 2220: def _maketup(descr, val):
 2221:     dt = dtype(descr)
 2222:     # Place val in all scalar tuples:
 2223:     fields = dt.fields
 2224:     if fields is None:
 2225:         return val
 2226:     else:
 2227:         res = [_maketup(fields[name][0], val) for name in dt.names]
 2228:         return tuple(res)
 2229: 
 2230: 
 2231: @finalize_array_function_like
 2232: @set_module('numpy')
 2233: def identity(n, dtype=None, *, like=None):
 2234:     """
 2235:     Return the identity array.
 2236: 
 2237:     The identity array is a square array with ones on
 2238:     the main diagonal.
 2239: 
 2240:     Parameters
 2241:     ----------
 2242:     n : int
 2243:         Number of rows (and columns) in `n` x `n` output.
 2244:     dtype : data-type, optional
 2245:         Data-type of the output.  Defaults to ``float``.
 2246:     ${ARRAY_FUNCTION_LIKE}
 2247: 
 2248:         .. versionadded:: 1.20.0
 2249: 
 2250:     Returns
 2251:     -------
 2252:     out : ndarray
 2253:         `n` x `n` array with its main diagonal set to one,
 2254:         and all other elements 0.
 2255: 
 2256:     Examples
 2257:     --------
 2258:     >>> import numpy as np
 2259:     >>> np.identity(3)
 2260:     array([[1.,  0.,  0.],
 2261:            [0.,  1.,  0.],
 2262:            [0.,  0.,  1.]])
 2263: 
 2264:     """
 2265:     if like is not None:
 2266:         return _identity_with_like(like, n, dtype=dtype)
 2267: 
 2268:     from numpy import eye
 2269:     return eye(n, dtype=dtype, like=like)
 2270: 
 2271: 
 2272: _identity_with_like = array_function_dispatch()(identity)
 2273: 
 2274: 
 2275: def _allclose_dispatcher(a, b, rtol=None, atol=None, equal_nan=None):
 2276:     return (a, b, rtol, atol)
 2277: 
 2278: 
 2279: @array_function_dispatch(_allclose_dispatcher)
 2280: def allclose(a, b, rtol=1.e-5, atol=1.e-8, equal_nan=False):
 2281:     """
 2282:     Returns True if two arrays are element-wise equal within a tolerance.
 2283: 
 2284:     The tolerance values are positive, typically very small numbers.  The
 2285:     relative difference (`rtol` * abs(`b`)) and the absolute difference
 2286:     `atol` are added together to compare against the absolute difference
 2287:     between `a` and `b`.
 2288: 
 2289:     .. warning:: The default `atol` is not appropriate for comparing numbers
 2290:                  with magnitudes much smaller than one (see Notes).
 2291: 
 2292:     NaNs are treated as equal if they are in the same place and if
 2293:     ``equal_nan=True``.  Infs are treated as equal if they are in the same
 2294:     place and of the same sign in both arrays.
 2295: 
 2296:     Parameters
 2297:     ----------
 2298:     a, b : array_like
 2299:         Input arrays to compare.
 2300:     rtol : array_like
 2301:         The relative tolerance parameter (see Notes).
 2302:     atol : array_like
 2303:         The absolute tolerance parameter (see Notes).
 2304:     equal_nan : bool
 2305:         Whether to compare NaN's as equal.  If True, NaN's in `a` will be
 2306:         considered equal to NaN's in `b` in the output array.
 2307: 
 2308:     Returns
 2309:     -------
 2310:     allclose : bool
 2311:         Returns True if the two arrays are equal within the given
 2312:         tolerance; False otherwise.
 2313: 
 2314:     See Also
 2315:     --------
 2316:     isclose, all, any, equal
 2317: 
 2318:     Notes
 2319:     -----
 2320:     If the following equation is element-wise True, then allclose returns
 2321:     True.::
 2322: 
 2323:      absolute(a - b) <= (atol + rtol * absolute(b))
 2324: 
 2325:     The above equation is not symmetric in `a` and `b`, so that
 2326:     ``allclose(a, b)`` might be different from ``allclose(b, a)`` in
 2327:     some rare cases.
 2328: 
 2329:     The default value of `atol` is not appropriate when the reference value
 2330:     `b` has magnitude smaller than one. For example, it is unlikely that
 2331:     ``a = 1e-9`` and ``b = 2e-9`` should be considered "close", yet
 2332:     ``allclose(1e-9, 2e-9)`` is ``True`` with default settings. Be sure
 2333:     to select `atol` for the use case at hand, especially for defining the
 2334:     threshold below which a non-zero value in `a` will be considered "close"
 2335:     to a very small or zero value in `b`.
 2336: 
 2337:     The comparison of `a` and `b` uses standard broadcasting, which
 2338:     means that `a` and `b` need not have the same shape in order for
 2339:     ``allclose(a, b)`` to evaluate to True.  The same is true for
 2340:     `equal` but not `array_equal`.
 2341: 
 2342:     `allclose` is not defined for non-numeric data types.
 2343:     `bool` is considered a numeric data-type for this purpose.
 2344: 
 2345:     Examples
 2346:     --------
 2347:     >>> import numpy as np
 2348:     >>> np.allclose([1e10,1e-7], [1.00001e10,1e-8])
 2349:     False
 2350: 
 2351:     >>> np.allclose([1e10,1e-8], [1.00001e10,1e-9])
 2352:     True
 2353: 
 2354:     >>> np.allclose([1e10,1e-8], [1.0001e10,1e-9])
 2355:     False
 2356: 
 2357:     >>> np.allclose([1.0, np.nan], [1.0, np.nan])
 2358:     False
 2359: 
 2360:     >>> np.allclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)
 2361:     True
 2362: 
 2363: 
 2364:     """
 2365:     res = all(isclose(a, b, rtol=rtol, atol=atol, equal_nan=equal_nan))
 2366:     return builtins.bool(res)
 2367: 
 2368: 
 2369: def _isclose_dispatcher(a, b, rtol=None, atol=None, equal_nan=None):
 2370:     return (a, b, rtol, atol)
 2371: 
 2372: 
 2373: @array_function_dispatch(_isclose_dispatcher)
 2374: def isclose(a, b, rtol=1.e-5, atol=1.e-8, equal_nan=False):
 2375:     """
 2376:     Returns a boolean array where two arrays are element-wise equal within a
 2377:     tolerance.
 2378: 
 2379:     The tolerance values are positive, typically very small numbers.  The
 2380:     relative difference (`rtol` * abs(`b`)) and the absolute difference
 2381:     `atol` are added together to compare against the absolute difference
 2382:     between `a` and `b`.
 2383: 
 2384:     .. warning:: The default `atol` is not appropriate for comparing numbers
 2385:                  with magnitudes much smaller than one (see Notes).
 2386: 
 2387:     Parameters
 2388:     ----------
 2389:     a, b : array_like
 2390:         Input arrays to compare.
 2391:     rtol : array_like
 2392:         The relative tolerance parameter (see Notes).
 2393:     atol : array_like
 2394:         The absolute tolerance parameter (see Notes).
 2395:     equal_nan : bool
 2396:         Whether to compare NaN's as equal.  If True, NaN's in `a` will be
 2397:         considered equal to NaN's in `b` in the output array.
 2398: 
 2399:     Returns
 2400:     -------
 2401:     y : array_like
 2402:         Returns a boolean array of where `a` and `b` are equal within the
 2403:         given tolerance. If both `a` and `b` are scalars, returns a single
 2404:         boolean value.
 2405: 
 2406:     See Also
 2407:     --------
 2408:     allclose
 2409:     math.isclose
 2410: 
 2411:     Notes
 2412:     -----
 2413:     For finite values, isclose uses the following equation to test whether
 2414:     two floating point values are equivalent.::
 2415: 
 2416:      absolute(a - b) <= (atol + rtol * absolute(b))
 2417: 
 2418:     Unlike the built-in `math.isclose`, the above equation is not symmetric
 2419:     in `a` and `b` -- it assumes `b` is the reference value -- so that
 2420:     `isclose(a, b)` might be different from `isclose(b, a)`.
 2421: 
 2422:     The default value of `atol` is not appropriate when the reference value
 2423:     `b` has magnitude smaller than one. For example, it is unlikely that
 2424:     ``a = 1e-9`` and ``b = 2e-9`` should be considered "close", yet
 2425:     ``isclose(1e-9, 2e-9)`` is ``True`` with default settings. Be sure
 2426:     to select `atol` for the use case at hand, especially for defining the
 2427:     threshold below which a non-zero value in `a` will be considered "close"
 2428:     to a very small or zero value in `b`.
 2429: 
 2430:     `isclose` is not defined for non-numeric data types.
 2431:     :class:`bool` is considered a numeric data-type for this purpose.
 2432: 
 2433:     Examples
 2434:     --------
 2435:     >>> import numpy as np
 2436:     >>> np.isclose([1e10,1e-7], [1.00001e10,1e-8])
 2437:     array([ True, False])
 2438: 
 2439:     >>> np.isclose([1e10,1e-8], [1.00001e10,1e-9])
 2440:     array([ True, True])
 2441: 
 2442:     >>> np.isclose([1e10,1e-8], [1.0001e10,1e-9])
 2443:     array([False,  True])
 2444: 
 2445:     >>> np.isclose([1.0, np.nan], [1.0, np.nan])
 2446:     array([ True, False])
 2447: 
 2448:     >>> np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)
 2449:     array([ True, True])
 2450: 
 2451:     >>> np.isclose([1e-8, 1e-7], [0.0, 0.0])
 2452:     array([ True, False])
 2453: 
 2454:     >>> np.isclose([1e-100, 1e-7], [0.0, 0.0], atol=0.0)
 2455:     array([False, False])
 2456: 
 2457:     >>> np.isclose([1e-10, 1e-10], [1e-20, 0.0])
 2458:     array([ True,  True])
 2459: 
 2460:     >>> np.isclose([1e-10, 1e-10], [1e-20, 0.999999e-10], atol=0.0)
 2461:     array([False,  True])
 2462: 
 2463:     """
 2464:     # Turn all but python scalars into arrays.
 2465:     x, y, atol, rtol = (
 2466:         a if isinstance(a, (int, float, complex)) else asanyarray(a)
 2467:         for a in (a, b, atol, rtol))
 2468: 
 2469:     # Make sure y is an inexact type to avoid bad behavior on abs(MIN_INT).
 2470:     # This will cause casting of x later. Also, make sure to allow subclasses
 2471:     # (e.g., for numpy.ma).
 2472:     # NOTE: We explicitly allow timedelta, which used to work. This could
 2473:     #       possibly be deprecated. See also gh-18286.
 2474:     #       timedelta works if `atol` is an integer or also a timedelta.
 2475:     #       Although, the default tolerances are unlikely to be useful
 2476:     if (dtype := getattr(y, "dtype", None)) is not None and dtype.kind != "m":
 2477:         dt = multiarray.result_type(y, 1.)
 2478:         y = asanyarray(y, dtype=dt)
 2479:     elif isinstance(y, int):
 2480:         y = float(y)
 2481: 
 2482:     # atol and rtol can be arrays
 2483:     if not (np.all(np.isfinite(atol)) and np.all(np.isfinite(rtol))):
 2484:         err_s = np.geterr()["invalid"]
 2485:         err_msg = f"One of rtol or atol is not valid, atol: {atol}, rtol: {rtol}"
 2486: 
 2487:         if err_s == "warn":
 2488:             warnings.warn(err_msg, RuntimeWarning, stacklevel=2)
 2489:         elif err_s == "raise":
 2490:             raise FloatingPointError(err_msg)
 2491:         elif err_s == "print":
 2492:             print(err_msg)
 2493: 
 2494:     with errstate(invalid='ignore'):
 2495: 
 2496:         result = (less_equal(abs(x - y), atol + rtol * abs(y))
 2497:                   & isfinite(y)
 2498:                   | (x == y))
 2499:         if equal_nan:
 2500:             result |= isnan(x) & isnan(y)
 2501: 
 2502:     return result[()]  # Flatten 0d arrays to scalars
 2503: 
 2504: 
 2505: def _array_equal_dispatcher(a1, a2, equal_nan=None):
 2506:     return (a1, a2)
 2507: 
 2508: 
 2509: _no_nan_types = {
 2510:     # should use np.dtype.BoolDType, but as of writing
 2511:     # that fails the reloading test.
 2512:     type(dtype(nt.bool)),
 2513:     type(dtype(nt.int8)),
 2514:     type(dtype(nt.int16)),
 2515:     type(dtype(nt.int32)),
 2516:     type(dtype(nt.int64)),
 2517: }
 2518: 
 2519: 
 2520: def _dtype_cannot_hold_nan(dtype):
 2521:     return type(dtype) in _no_nan_types
 2522: 
 2523: 
 2524: @array_function_dispatch(_array_equal_dispatcher)
 2525: def array_equal(a1, a2, equal_nan=False):
 2526:     """
 2527:     True if two arrays have the same shape and elements, False otherwise.
 2528: 
 2529:     Parameters
 2530:     ----------
 2531:     a1, a2 : array_like
 2532:         Input arrays.
 2533:     equal_nan : bool
 2534:         Whether to compare NaN's as equal. If the dtype of a1 and a2 is
 2535:         complex, values will be considered equal if either the real or the
 2536:         imaginary component of a given value is ``nan``.
 2537: 
 2538:     Returns
 2539:     -------
 2540:     b : bool
 2541:         Returns True if the arrays are equal.
 2542: 
 2543:     See Also
 2544:     --------
 2545:     allclose: Returns True if two arrays are element-wise equal within a
 2546:               tolerance.
 2547:     array_equiv: Returns True if input arrays are shape consistent and all
 2548:                  elements equal.
 2549: 
 2550:     Examples
 2551:     --------
 2552:     >>> import numpy as np
 2553: 
 2554:     >>> np.array_equal([1, 2], [1, 2])
 2555:     True
 2556: 
 2557:     >>> np.array_equal(np.array([1, 2]), np.array([1, 2]))
 2558:     True
 2559: 
 2560:     >>> np.array_equal([1, 2], [1, 2, 3])
 2561:     False
 2562: 
 2563:     >>> np.array_equal([1, 2], [1, 4])
 2564:     False
 2565: 
 2566:     >>> a = np.array([1, np.nan])
 2567:     >>> np.array_equal(a, a)
 2568:     False
 2569: 
 2570:     >>> np.array_equal(a, a, equal_nan=True)
 2571:     True
 2572: 
 2573:     When ``equal_nan`` is True, complex values with nan components are
 2574:     considered equal if either the real *or* the imaginary components are nan.
 2575: 
 2576:     >>> a = np.array([1 + 1j])
 2577:     >>> b = a.copy()
 2578:     >>> a.real = np.nan
 2579:     >>> b.imag = np.nan
 2580:     >>> np.array_equal(a, b, equal_nan=True)
 2581:     True
 2582:     """
 2583:     try:
 2584:         a1, a2 = asarray(a1), asarray(a2)
 2585:     except Exception:
 2586:         return False
 2587:     if a1.shape != a2.shape:
 2588:         return False
 2589:     if not equal_nan:
 2590:         return builtins.bool((asanyarray(a1 == a2)).all())
 2591: 
 2592:     if a1 is a2:
 2593:         # nan will compare equal so an array will compare equal to itself.
 2594:         return True
 2595: 
 2596:     cannot_have_nan = (_dtype_cannot_hold_nan(a1.dtype)
 2597:                        and _dtype_cannot_hold_nan(a2.dtype))
 2598:     if cannot_have_nan:
 2599:         return builtins.bool(asarray(a1 == a2).all())
 2600: 
 2601:     # Handling NaN values if equal_nan is True
 2602:     a1nan, a2nan = isnan(a1), isnan(a2)
 2603:     # NaN's occur at different locations
 2604:     if not (a1nan == a2nan).all():
 2605:         return False
 2606:     # Shapes of a1, a2 and masks are guaranteed to be consistent by this point
 2607:     return builtins.bool((a1[~a1nan] == a2[~a1nan]).all())
 2608: 
 2609: 
 2610: def _array_equiv_dispatcher(a1, a2):
 2611:     return (a1, a2)
 2612: 
 2613: 
 2614: @array_function_dispatch(_array_equiv_dispatcher)
 2615: def array_equiv(a1, a2):
 2616:     """
 2617:     Returns True if input arrays are shape consistent and all elements equal.
 2618: 
 2619:     Shape consistent means they are either the same shape, or one input array
 2620:     can be broadcasted to create the same shape as the other one.
 2621: 
 2622:     Parameters
 2623:     ----------
 2624:     a1, a2 : array_like
 2625:         Input arrays.
 2626: 
 2627:     Returns
 2628:     -------
 2629:     out : bool
 2630:         True if equivalent, False otherwise.
 2631: 
 2632:     Examples
 2633:     --------
 2634:     >>> import numpy as np
 2635:     >>> np.array_equiv([1, 2], [1, 2])
 2636:     True
 2637:     >>> np.array_equiv([1, 2], [1, 3])
 2638:     False
 2639: 
 2640:     Showing the shape equivalence:
 2641: 
 2642:     >>> np.array_equiv([1, 2], [[1, 2], [1, 2]])
 2643:     True
 2644:     >>> np.array_equiv([1, 2], [[1, 2, 1, 2], [1, 2, 1, 2]])
 2645:     False
 2646: 
 2647:     >>> np.array_equiv([1, 2], [[1, 2], [1, 3]])
 2648:     False
 2649: 
 2650:     """
 2651:     try:
 2652:         a1, a2 = asarray(a1), asarray(a2)
 2653:     except Exception:
 2654:         return False
 2655:     try:
 2656:         multiarray.broadcast(a1, a2)
 2657:     except Exception:
 2658:         return False
 2659: 
 2660:     return builtins.bool(asanyarray(a1 == a2).all())
 2661: 
 2662: 
 2663: def _astype_dispatcher(x, dtype, /, *, copy=None, device=None):
 2664:     return (x, dtype)
 2665: 
 2666: 
 2667: @array_function_dispatch(_astype_dispatcher)
 2668: def astype(x, dtype, /, *, copy=True, device=None):
 2669:     """
 2670:     Copies an array to a specified data type.
 2671: 
 2672:     This function is an Array API compatible alternative to
 2673:     `numpy.ndarray.astype`.
 2674: 
 2675:     Parameters
 2676:     ----------
 2677:     x : ndarray
 2678:         Input NumPy array to cast. ``array_likes`` are explicitly not
 2679:         supported here.
 2680:     dtype : dtype
 2681:         Data type of the result.
 2682:     copy : bool, optional
 2683:         Specifies whether to copy an array when the specified dtype matches
 2684:         the data type of the input array ``x``. If ``True``, a newly allocated
 2685:         array must always be returned. If ``False`` and the specified dtype
 2686:         matches the data type of the input array, the input array must be
 2687:         returned; otherwise, a newly allocated array must be returned.
 2688:         Defaults to ``True``.
 2689:     device : str, optional
 2690:         The device on which to place the returned array. Default: None.
 2691:         For Array-API interoperability only, so must be ``"cpu"`` if passed.
 2692: 
 2693:         .. versionadded:: 2.1.0
 2694: 
 2695:     Returns
 2696:     -------
 2697:     out : ndarray
 2698:         An array having the specified data type.
 2699: 
 2700:     See Also
 2701:     --------
 2702:     ndarray.astype
 2703: 
 2704:     Examples
 2705:     --------
 2706:     >>> import numpy as np
 2707:     >>> arr = np.array([1, 2, 3]); arr
 2708:     array([1, 2, 3])
 2709:     >>> np.astype(arr, np.float64)
 2710:     array([1., 2., 3.])
 2711: 
 2712:     Non-copy case:
 2713: 
 2714:     >>> arr = np.array([1, 2, 3])
 2715:     >>> arr_noncpy = np.astype(arr, arr.dtype, copy=False)
 2716:     >>> np.shares_memory(arr, arr_noncpy)
 2717:     True
 2718: 
 2719:     """
 2720:     if not (isinstance(x, np.ndarray) or isscalar(x)):
 2721:         raise TypeError(
 2722:             "Input should be a NumPy array or scalar. "
 2723:             f"It is a {type(x)} instead."
 2724:         )
 2725:     if device is not None and device != "cpu":
 2726:         raise ValueError(
 2727:             'Device not understood. Only "cpu" is allowed, but received:'
 2728:             f' {device}'
 2729:         )
 2730:     return x.astype(dtype, copy=copy)
 2731: 
 2732: 
 2733: inf = PINF
 2734: nan = NAN
 2735: False_ = nt.bool(False)
 2736: True_ = nt.bool(True)
 2737: 
 2738: 
 2739: def extend_all(module):
 2740:     existing = set(__all__)
 2741:     mall = module.__all__
 2742:     for a in mall:
 2743:         if a not in existing:
 2744:             __all__.append(a)
 2745: 
 2746: 
 2747: from . import _asarray, _ufunc_config, arrayprint, fromnumeric
 2748: from ._asarray import *
 2749: from ._ufunc_config import *
 2750: from .arrayprint import *
 2751: from .fromnumeric import *
 2752: from .numerictypes import *
 2753: from .umath import *
 2754: 
 2755: extend_all(fromnumeric)
 2756: extend_all(umath)
 2757: extend_all(numerictypes)
 2758: extend_all(arrayprint)
 2759: extend_all(_asarray)
 2760: extend_all(_ufunc_config)
