    1: """
    2: Array methods which are called by both the C-code for the method
    3: and the Python code for the NumPy-namespace function
    4: 
    5: """
    6: import os
    7: import pickle
    8: import warnings
    9: from contextlib import nullcontext
   10: 
   11: import numpy as np
   12: from numpy._core import multiarray as mu
   13: from numpy._core import numerictypes as nt
   14: from numpy._core import umath as um
   15: from numpy._core.multiarray import asanyarray
   16: from numpy._globals import _NoValue
   17: 
   18: # save those O(100) nanoseconds!
   19: bool_dt = mu.dtype("bool")
   20: umr_maximum = um.maximum.reduce
   21: umr_minimum = um.minimum.reduce
   22: umr_sum = um.add.reduce
   23: umr_prod = um.multiply.reduce
   24: umr_bitwise_count = um.bitwise_count
   25: umr_any = um.logical_or.reduce
   26: umr_all = um.logical_and.reduce
   27: 
   28: # Complex types to -> (2,)float view for fast-path computation in _var()
   29: _complex_to_float = {
   30:     nt.dtype(nt.csingle): nt.dtype(nt.single),
   31:     nt.dtype(nt.cdouble): nt.dtype(nt.double),
   32: }
   33: # Special case for windows: ensure double takes precedence
   34: if nt.dtype(nt.longdouble) != nt.dtype(nt.double):
   35:     _complex_to_float.update({
   36:         nt.dtype(nt.clongdouble): nt.dtype(nt.longdouble),
   37:     })
   38: 
   39: # avoid keyword arguments to speed up parsing, saves about 15%-20% for very
   40: # small reductions
   41: def _amax(a, axis=None, out=None, keepdims=False,
   42:           initial=_NoValue, where=True):
   43:     return umr_maximum(a, axis, None, out, keepdims, initial, where)
   44: 
   45: def _amin(a, axis=None, out=None, keepdims=False,
   46:           initial=_NoValue, where=True):
   47:     return umr_minimum(a, axis, None, out, keepdims, initial, where)
   48: 
   49: def _sum(a, axis=None, dtype=None, out=None, keepdims=False,
   50:          initial=_NoValue, where=True):
   51:     return umr_sum(a, axis, dtype, out, keepdims, initial, where)
   52: 
   53: def _prod(a, axis=None, dtype=None, out=None, keepdims=False,
   54:           initial=_NoValue, where=True):
   55:     return umr_prod(a, axis, dtype, out, keepdims, initial, where)
   56: 
   57: def _any(a, axis=None, dtype=None, out=None, keepdims=False, *, where=True):
   58:     # By default, return a boolean for any and all
   59:     if dtype is None:
   60:         dtype = bool_dt
   61:     # Parsing keyword arguments is currently fairly slow, so avoid it for now
   62:     if where is True:
   63:         return umr_any(a, axis, dtype, out, keepdims)
   64:     return umr_any(a, axis, dtype, out, keepdims, where=where)
   65: 
   66: def _all(a, axis=None, dtype=None, out=None, keepdims=False, *, where=True):
   67:     # By default, return a boolean for any and all
   68:     if dtype is None:
   69:         dtype = bool_dt
   70:     # Parsing keyword arguments is currently fairly slow, so avoid it for now
   71:     if where is True:
   72:         return umr_all(a, axis, dtype, out, keepdims)
   73:     return umr_all(a, axis, dtype, out, keepdims, where=where)
   74: 
   75: def _count_reduce_items(arr, axis, keepdims=False, where=True):
   76:     # fast-path for the default case
   77:     if where is True:
   78:         # no boolean mask given, calculate items according to axis
   79:         if axis is None:
   80:             axis = tuple(range(arr.ndim))
   81:         elif not isinstance(axis, tuple):
   82:             axis = (axis,)
   83:         items = 1
   84:         for ax in axis:
   85:             items *= arr.shape[mu.normalize_axis_index(ax, arr.ndim)]
   86:         items = nt.intp(items)
   87:     else:
   88:         # TODO: Optimize case when `where` is broadcast along a non-reduction
   89:         # axis and full sum is more excessive than needed.
   90: 
   91:         # guarded to protect circular imports
   92:         from numpy.lib._stride_tricks_impl import broadcast_to
   93:         # count True values in (potentially broadcasted) boolean mask
   94:         items = umr_sum(broadcast_to(where, arr.shape), axis, nt.intp, None,
   95:                         keepdims)
   96:     return items
   97: 
   98: def _clip(a, min=None, max=None, out=None, **kwargs):
   99:     if a.dtype.kind in "iu":
  100:         # If min/max is a Python integer, deal with out-of-bound values here.
  101:         # (This enforces NEP 50 rules as no value based promotion is done.)
  102:         if type(min) is int and min <= np.iinfo(a.dtype).min:
  103:             min = None
  104:         if type(max) is int and max >= np.iinfo(a.dtype).max:
  105:             max = None
  106: 
  107:     if min is None and max is None:
  108:         # return identity
  109:         return um.positive(a, out=out, **kwargs)
  110:     elif min is None:
  111:         return um.minimum(a, max, out=out, **kwargs)
  112:     elif max is None:
  113:         return um.maximum(a, min, out=out, **kwargs)
  114:     else:
  115:         return um.clip(a, min, max, out=out, **kwargs)
  116: 
  117: def _mean(a, axis=None, dtype=None, out=None, keepdims=False, *, where=True):
  118:     arr = asanyarray(a)
  119: 
  120:     is_float16_result = False
  121: 
  122:     rcount = _count_reduce_items(arr, axis, keepdims=keepdims, where=where)
  123:     if rcount == 0 if where is True else umr_any(rcount == 0, axis=None):
  124:         warnings.warn("Mean of empty slice.", RuntimeWarning, stacklevel=2)
  125: 
  126:     # Cast bool, unsigned int, and int to float64 by default
  127:     if dtype is None:
  128:         if issubclass(arr.dtype.type, (nt.integer, nt.bool)):
  129:             dtype = mu.dtype('f8')
  130:         elif issubclass(arr.dtype.type, nt.float16):
  131:             dtype = mu.dtype('f4')
  132:             is_float16_result = True
  133: 
  134:     ret = umr_sum(arr, axis, dtype, out, keepdims, where=where)
  135:     if isinstance(ret, mu.ndarray):
  136:         ret = um.true_divide(
  137:                 ret, rcount, out=ret, casting='unsafe', subok=False)
  138:         if is_float16_result and out is None:
  139:             ret = arr.dtype.type(ret)
  140:     elif hasattr(ret, 'dtype'):
  141:         if is_float16_result:
  142:             ret = arr.dtype.type(ret / rcount)
  143:         else:
  144:             ret = ret.dtype.type(ret / rcount)
  145:     else:
  146:         ret = ret / rcount
  147: 
  148:     return ret
  149: 
  150: def _var(a, axis=None, dtype=None, out=None, ddof=0, keepdims=False, *,
  151:          where=True, mean=None):
  152:     arr = asanyarray(a)
  153: 
  154:     rcount = _count_reduce_items(arr, axis, keepdims=keepdims, where=where)
  155:     # Make this warning show up on top.
  156:     if ddof >= rcount if where is True else umr_any(ddof >= rcount, axis=None):
  157:         warnings.warn("Degrees of freedom <= 0 for slice", RuntimeWarning,
  158:                       stacklevel=2)
  159: 
  160:     # Cast bool, unsigned int, and int to float64 by default
  161:     if dtype is None and issubclass(arr.dtype.type, (nt.integer, nt.bool)):
  162:         dtype = mu.dtype('f8')
  163: 
  164:     if mean is not None:
  165:         arrmean = mean
  166:     else:
  167:         # Compute the mean.
  168:         # Note that if dtype is not of inexact type then arraymean will
  169:         # not be either.
  170:         arrmean = umr_sum(arr, axis, dtype, keepdims=True, where=where)
  171:         # The shape of rcount has to match arrmean to not change the shape of
  172:         # out in broadcasting. Otherwise, it cannot be stored back to arrmean.
  173:         if rcount.ndim == 0:
  174:             # fast-path for default case when where is True
  175:             div = rcount
  176:         else:
  177:             # matching rcount to arrmean when where is specified as array
  178:             div = rcount.reshape(arrmean.shape)
  179:         if isinstance(arrmean, mu.ndarray):
  180:             arrmean = um.true_divide(arrmean, div, out=arrmean,
  181:                                      casting='unsafe', subok=False)
  182:         elif hasattr(arrmean, "dtype"):
  183:             arrmean = arrmean.dtype.type(arrmean / rcount)
  184:         else:
  185:             arrmean = arrmean / rcount
  186: 
  187:     # Compute sum of squared deviations from mean
  188:     # Note that x may not be inexact and that we need it to be an array,
  189:     # not a scalar.
  190:     x = asanyarray(arr - arrmean)
  191: 
  192:     if issubclass(arr.dtype.type, (nt.floating, nt.integer)):
  193:         x = um.multiply(x, x, out=x)
  194:     # Fast-paths for built-in complex types
  195:     elif x.dtype in _complex_to_float:
  196:         xv = x.view(dtype=(_complex_to_float[x.dtype], (2,)))
  197:         um.multiply(xv, xv, out=xv)
  198:         x = um.add(xv[..., 0], xv[..., 1], out=x.real).real
  199:     # Most general case; includes handling object arrays containing imaginary
  200:     # numbers and complex types with non-native byteorder
  201:     else:
  202:         x = um.multiply(x, um.conjugate(x), out=x).real
  203: 
  204:     ret = umr_sum(x, axis, dtype, out, keepdims=keepdims, where=where)
  205: 
  206:     # Compute degrees of freedom and make sure it is not negative.
  207:     rcount = um.maximum(rcount - ddof, 0)
  208: 
  209:     # divide by degrees of freedom
  210:     if isinstance(ret, mu.ndarray):
  211:         ret = um.true_divide(
  212:                 ret, rcount, out=ret, casting='unsafe', subok=False)
  213:     elif hasattr(ret, 'dtype'):
  214:         ret = ret.dtype.type(ret / rcount)
  215:     else:
  216:         ret = ret / rcount
  217: 
  218:     return ret
  219: 
  220: def _std(a, axis=None, dtype=None, out=None, ddof=0, keepdims=False, *,
  221:          where=True, mean=None):
  222:     ret = _var(a, axis=axis, dtype=dtype, out=out, ddof=ddof,
  223:                keepdims=keepdims, where=where, mean=mean)
  224: 
  225:     if isinstance(ret, mu.ndarray):
  226:         ret = um.sqrt(ret, out=ret)
  227:     elif hasattr(ret, 'dtype'):
  228:         ret = ret.dtype.type(um.sqrt(ret))
  229:     else:
  230:         ret = um.sqrt(ret)
  231: 
  232:     return ret
  233: 
  234: def _ptp(a, axis=None, out=None, keepdims=False):
  235:     return um.subtract(
  236:         umr_maximum(a, axis, None, out, keepdims),
  237:         umr_minimum(a, axis, None, None, keepdims),
  238:         out
  239:     )
  240: 
  241: def _dump(self, file, protocol=2):
  242:     if hasattr(file, 'write'):
  243:         ctx = nullcontext(file)
  244:     else:
  245:         ctx = open(os.fspath(file), "wb")
  246:     with ctx as f:
  247:         pickle.dump(self, f, protocol=protocol)
  248: 
  249: def _dumps(self, protocol=2):
  250:     return pickle.dumps(self, protocol=protocol)
  251: 
  252: def _bitwise_count(a, out=None, *, where=True, casting='same_kind',
  253:           order='K', dtype=None, subok=True):
  254:     return umr_bitwise_count(a, out, where=where, casting=casting,
  255:             order=order, dtype=dtype, subok=subok)
