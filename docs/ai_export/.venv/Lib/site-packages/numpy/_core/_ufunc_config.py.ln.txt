    1: """
    2: Functions for changing global ufunc configuration
    3: 
    4: This provides helpers which wrap `_get_extobj_dict` and `_make_extobj`, and
    5: `_extobj_contextvar` from umath.
    6: """
    7: import functools
    8: 
    9: from numpy._utils import set_module
   10: 
   11: from .umath import _extobj_contextvar, _get_extobj_dict, _make_extobj
   12: 
   13: __all__ = [
   14:     "seterr", "geterr", "setbufsize", "getbufsize", "seterrcall", "geterrcall",
   15:     "errstate"
   16: ]
   17: 
   18: 
   19: @set_module('numpy')
   20: def seterr(all=None, divide=None, over=None, under=None, invalid=None):
   21:     """
   22:     Set how floating-point errors are handled.
   23: 
   24:     Note that operations on integer scalar types (such as `int16`) are
   25:     handled like floating point, and are affected by these settings.
   26: 
   27:     Parameters
   28:     ----------
   29:     all : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional
   30:         Set treatment for all types of floating-point errors at once:
   31: 
   32:         - ignore: Take no action when the exception occurs.
   33:         - warn: Print a :exc:`RuntimeWarning` (via the Python `warnings`
   34:           module).
   35:         - raise: Raise a :exc:`FloatingPointError`.
   36:         - call: Call a function specified using the `seterrcall` function.
   37:         - print: Print a warning directly to ``stdout``.
   38:         - log: Record error in a Log object specified by `seterrcall`.
   39: 
   40:         The default is not to change the current behavior.
   41:     divide : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional
   42:         Treatment for division by zero.
   43:     over : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional
   44:         Treatment for floating-point overflow.
   45:     under : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional
   46:         Treatment for floating-point underflow.
   47:     invalid : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional
   48:         Treatment for invalid floating-point operation.
   49: 
   50:     Returns
   51:     -------
   52:     old_settings : dict
   53:         Dictionary containing the old settings.
   54: 
   55:     See also
   56:     --------
   57:     seterrcall : Set a callback function for the 'call' mode.
   58:     geterr, geterrcall, errstate
   59: 
   60:     Notes
   61:     -----
   62:     The floating-point exceptions are defined in the IEEE 754 standard [1]_:
   63: 
   64:     - Division by zero: infinite result obtained from finite numbers.
   65:     - Overflow: result too large to be expressed.
   66:     - Underflow: result so close to zero that some precision
   67:       was lost.
   68:     - Invalid operation: result is not an expressible number, typically
   69:       indicates that a NaN was produced.
   70: 
   71:     .. [1] https://en.wikipedia.org/wiki/IEEE_754
   72: 
   73:     Examples
   74:     --------
   75:     >>> import numpy as np
   76:     >>> orig_settings = np.seterr(all='ignore')  # seterr to known value
   77:     >>> np.int16(32000) * np.int16(3)
   78:     np.int16(30464)
   79:     >>> np.seterr(over='raise')
   80:     {'divide': 'ignore', 'over': 'ignore', 'under': 'ignore', 'invalid': 'ignore'}
   81:     >>> old_settings = np.seterr(all='warn', over='raise')
   82:     >>> np.int16(32000) * np.int16(3)
   83:     Traceback (most recent call last):
   84:       File "<stdin>", line 1, in <module>
   85:     FloatingPointError: overflow encountered in scalar multiply
   86: 
   87:     >>> old_settings = np.seterr(all='print')
   88:     >>> np.geterr()
   89:     {'divide': 'print', 'over': 'print', 'under': 'print', 'invalid': 'print'}
   90:     >>> np.int16(32000) * np.int16(3)
   91:     np.int16(30464)
   92:     >>> np.seterr(**orig_settings)  # restore original
   93:     {'divide': 'print', 'over': 'print', 'under': 'print', 'invalid': 'print'}
   94: 
   95:     """
   96: 
   97:     old = _get_extobj_dict()
   98:     # The errstate doesn't include call and bufsize, so pop them:
   99:     old.pop("call", None)
  100:     old.pop("bufsize", None)
  101: 
  102:     extobj = _make_extobj(
  103:             all=all, divide=divide, over=over, under=under, invalid=invalid)
  104:     _extobj_contextvar.set(extobj)
  105:     return old
  106: 
  107: 
  108: @set_module('numpy')
  109: def geterr():
  110:     """
  111:     Get the current way of handling floating-point errors.
  112: 
  113:     Returns
  114:     -------
  115:     res : dict
  116:         A dictionary with keys "divide", "over", "under", and "invalid",
  117:         whose values are from the strings "ignore", "print", "log", "warn",
  118:         "raise", and "call". The keys represent possible floating-point
  119:         exceptions, and the values define how these exceptions are handled.
  120: 
  121:     See Also
  122:     --------
  123:     geterrcall, seterr, seterrcall
  124: 
  125:     Notes
  126:     -----
  127:     For complete documentation of the types of floating-point exceptions and
  128:     treatment options, see `seterr`.
  129: 
  130:     Examples
  131:     --------
  132:     >>> import numpy as np
  133:     >>> np.geterr()
  134:     {'divide': 'warn', 'over': 'warn', 'under': 'ignore', 'invalid': 'warn'}
  135:     >>> np.arange(3.) / np.arange(3.)  # doctest: +SKIP
  136:     array([nan,  1.,  1.])
  137:     RuntimeWarning: invalid value encountered in divide
  138: 
  139:     >>> oldsettings = np.seterr(all='warn', invalid='raise')
  140:     >>> np.geterr()
  141:     {'divide': 'warn', 'over': 'warn', 'under': 'warn', 'invalid': 'raise'}
  142:     >>> np.arange(3.) / np.arange(3.)
  143:     Traceback (most recent call last):
  144:       ...
  145:     FloatingPointError: invalid value encountered in divide
  146:     >>> oldsettings = np.seterr(**oldsettings)  # restore original
  147: 
  148:     """
  149:     res = _get_extobj_dict()
  150:     # The "geterr" doesn't include call and bufsize,:
  151:     res.pop("call", None)
  152:     res.pop("bufsize", None)
  153:     return res
  154: 
  155: 
  156: @set_module('numpy')
  157: def setbufsize(size):
  158:     """
  159:     Set the size of the buffer used in ufuncs.
  160: 
  161:     .. versionchanged:: 2.0
  162:         The scope of setting the buffer is tied to the `numpy.errstate`
  163:         context.  Exiting a ``with errstate():`` will also restore the bufsize.
  164: 
  165:     Parameters
  166:     ----------
  167:     size : int
  168:         Size of buffer.
  169: 
  170:     Returns
  171:     -------
  172:     bufsize : int
  173:         Previous size of ufunc buffer in bytes.
  174: 
  175:     Examples
  176:     --------
  177:     When exiting a `numpy.errstate` context manager the bufsize is restored:
  178: 
  179:     >>> import numpy as np
  180:     >>> with np.errstate():
  181:     ...     np.setbufsize(4096)
  182:     ...     print(np.getbufsize())
  183:     ...
  184:     8192
  185:     4096
  186:     >>> np.getbufsize()
  187:     8192
  188: 
  189:     """
  190:     old = _get_extobj_dict()["bufsize"]
  191:     extobj = _make_extobj(bufsize=size)
  192:     _extobj_contextvar.set(extobj)
  193:     return old
  194: 
  195: 
  196: @set_module('numpy')
  197: def getbufsize():
  198:     """
  199:     Return the size of the buffer used in ufuncs.
  200: 
  201:     Returns
  202:     -------
  203:     getbufsize : int
  204:         Size of ufunc buffer in bytes.
  205: 
  206:     Examples
  207:     --------
  208:     >>> import numpy as np
  209:     >>> np.getbufsize()
  210:     8192
  211: 
  212:     """
  213:     return _get_extobj_dict()["bufsize"]
  214: 
  215: 
  216: @set_module('numpy')
  217: def seterrcall(func):
  218:     """
  219:     Set the floating-point error callback function or log object.
  220: 
  221:     There are two ways to capture floating-point error messages.  The first
  222:     is to set the error-handler to 'call', using `seterr`.  Then, set
  223:     the function to call using this function.
  224: 
  225:     The second is to set the error-handler to 'log', using `seterr`.
  226:     Floating-point errors then trigger a call to the 'write' method of
  227:     the provided object.
  228: 
  229:     Parameters
  230:     ----------
  231:     func : callable f(err, flag) or object with write method
  232:         Function to call upon floating-point errors ('call'-mode) or
  233:         object whose 'write' method is used to log such message ('log'-mode).
  234: 
  235:         The call function takes two arguments. The first is a string describing
  236:         the type of error (such as "divide by zero", "overflow", "underflow",
  237:         or "invalid value"), and the second is the status flag.  The flag is a
  238:         byte, whose four least-significant bits indicate the type of error, one
  239:         of "divide", "over", "under", "invalid"::
  240: 
  241:           [0 0 0 0 divide over under invalid]
  242: 
  243:         In other words, ``flags = divide + 2*over + 4*under + 8*invalid``.
  244: 
  245:         If an object is provided, its write method should take one argument,
  246:         a string.
  247: 
  248:     Returns
  249:     -------
  250:     h : callable, log instance or None
  251:         The old error handler.
  252: 
  253:     See Also
  254:     --------
  255:     seterr, geterr, geterrcall
  256: 
  257:     Examples
  258:     --------
  259:     Callback upon error:
  260: 
  261:     >>> def err_handler(type, flag):
  262:     ...     print("Floating point error (%s), with flag %s" % (type, flag))
  263:     ...
  264: 
  265:     >>> import numpy as np
  266: 
  267:     >>> orig_handler = np.seterrcall(err_handler)
  268:     >>> orig_err = np.seterr(all='call')
  269: 
  270:     >>> np.array([1, 2, 3]) / 0.0
  271:     Floating point error (divide by zero), with flag 1
  272:     array([inf, inf, inf])
  273: 
  274:     >>> np.seterrcall(orig_handler)
  275:     <function err_handler at 0x...>
  276:     >>> np.seterr(**orig_err)
  277:     {'divide': 'call', 'over': 'call', 'under': 'call', 'invalid': 'call'}
  278: 
  279:     Log error message:
  280: 
  281:     >>> class Log:
  282:     ...     def write(self, msg):
  283:     ...         print("LOG: %s" % msg)
  284:     ...
  285: 
  286:     >>> log = Log()
  287:     >>> saved_handler = np.seterrcall(log)
  288:     >>> save_err = np.seterr(all='log')
  289: 
  290:     >>> np.array([1, 2, 3]) / 0.0
  291:     LOG: Warning: divide by zero encountered in divide
  292:     array([inf, inf, inf])
  293: 
  294:     >>> np.seterrcall(orig_handler)
  295:     <numpy.Log object at 0x...>
  296:     >>> np.seterr(**orig_err)
  297:     {'divide': 'log', 'over': 'log', 'under': 'log', 'invalid': 'log'}
  298: 
  299:     """
  300:     old = _get_extobj_dict()["call"]
  301:     extobj = _make_extobj(call=func)
  302:     _extobj_contextvar.set(extobj)
  303:     return old
  304: 
  305: 
  306: @set_module('numpy')
  307: def geterrcall():
  308:     """
  309:     Return the current callback function used on floating-point errors.
  310: 
  311:     When the error handling for a floating-point error (one of "divide",
  312:     "over", "under", or "invalid") is set to 'call' or 'log', the function
  313:     that is called or the log instance that is written to is returned by
  314:     `geterrcall`. This function or log instance has been set with
  315:     `seterrcall`.
  316: 
  317:     Returns
  318:     -------
  319:     errobj : callable, log instance or None
  320:         The current error handler. If no handler was set through `seterrcall`,
  321:         ``None`` is returned.
  322: 
  323:     See Also
  324:     --------
  325:     seterrcall, seterr, geterr
  326: 
  327:     Notes
  328:     -----
  329:     For complete documentation of the types of floating-point exceptions and
  330:     treatment options, see `seterr`.
  331: 
  332:     Examples
  333:     --------
  334:     >>> import numpy as np
  335:     >>> np.geterrcall()  # we did not yet set a handler, returns None
  336: 
  337:     >>> orig_settings = np.seterr(all='call')
  338:     >>> def err_handler(type, flag):
  339:     ...     print("Floating point error (%s), with flag %s" % (type, flag))
  340:     >>> old_handler = np.seterrcall(err_handler)
  341:     >>> np.array([1, 2, 3]) / 0.0
  342:     Floating point error (divide by zero), with flag 1
  343:     array([inf, inf, inf])
  344: 
  345:     >>> cur_handler = np.geterrcall()
  346:     >>> cur_handler is err_handler
  347:     True
  348:     >>> old_settings = np.seterr(**orig_settings)  # restore original
  349:     >>> old_handler = np.seterrcall(None)  # restore original
  350: 
  351:     """
  352:     return _get_extobj_dict()["call"]
  353: 
  354: 
  355: class _unspecified:
  356:     pass
  357: 
  358: 
  359: _Unspecified = _unspecified()
  360: 
  361: 
  362: @set_module('numpy')
  363: class errstate:
  364:     """
  365:     errstate(**kwargs)
  366: 
  367:     Context manager for floating-point error handling.
  368: 
  369:     Using an instance of `errstate` as a context manager allows statements in
  370:     that context to execute with a known error handling behavior. Upon entering
  371:     the context the error handling is set with `seterr` and `seterrcall`, and
  372:     upon exiting it is reset to what it was before.
  373: 
  374:     ..  versionchanged:: 1.17.0
  375:         `errstate` is also usable as a function decorator, saving
  376:         a level of indentation if an entire function is wrapped.
  377: 
  378:     .. versionchanged:: 2.0
  379:         `errstate` is now fully thread and asyncio safe, but may not be
  380:         entered more than once.
  381:         It is not safe to decorate async functions using ``errstate``.
  382: 
  383:     Parameters
  384:     ----------
  385:     kwargs : {divide, over, under, invalid}
  386:         Keyword arguments. The valid keywords are the possible floating-point
  387:         exceptions. Each keyword should have a string value that defines the
  388:         treatment for the particular error. Possible values are
  389:         {'ignore', 'warn', 'raise', 'call', 'print', 'log'}.
  390: 
  391:     See Also
  392:     --------
  393:     seterr, geterr, seterrcall, geterrcall
  394: 
  395:     Notes
  396:     -----
  397:     For complete documentation of the types of floating-point exceptions and
  398:     treatment options, see `seterr`.
  399: 
  400:     Examples
  401:     --------
  402:     >>> import numpy as np
  403:     >>> olderr = np.seterr(all='ignore')  # Set error handling to known state.
  404: 
  405:     >>> np.arange(3) / 0.
  406:     array([nan, inf, inf])
  407:     >>> with np.errstate(divide='ignore'):
  408:     ...     np.arange(3) / 0.
  409:     array([nan, inf, inf])
  410: 
  411:     >>> np.sqrt(-1)
  412:     np.float64(nan)
  413:     >>> with np.errstate(invalid='raise'):
  414:     ...     np.sqrt(-1)
  415:     Traceback (most recent call last):
  416:       File "<stdin>", line 2, in <module>
  417:     FloatingPointError: invalid value encountered in sqrt
  418: 
  419:     Outside the context the error handling behavior has not changed:
  420: 
  421:     >>> np.geterr()
  422:     {'divide': 'ignore', 'over': 'ignore', 'under': 'ignore', 'invalid': 'ignore'}
  423:     >>> olderr = np.seterr(**olderr)  # restore original state
  424: 
  425:     """
  426:     __slots__ = (
  427:         "_all",
  428:         "_call",
  429:         "_divide",
  430:         "_invalid",
  431:         "_over",
  432:         "_token",
  433:         "_under",
  434:     )
  435: 
  436:     def __init__(self, *, call=_Unspecified,
  437:                  all=None, divide=None, over=None, under=None, invalid=None):
  438:         self._token = None
  439:         self._call = call
  440:         self._all = all
  441:         self._divide = divide
  442:         self._over = over
  443:         self._under = under
  444:         self._invalid = invalid
  445: 
  446:     def __enter__(self):
  447:         # Note that __call__ duplicates much of this logic
  448:         if self._token is not None:
  449:             raise TypeError("Cannot enter `np.errstate` twice.")
  450:         if self._call is _Unspecified:
  451:             extobj = _make_extobj(
  452:                     all=self._all, divide=self._divide, over=self._over,
  453:                     under=self._under, invalid=self._invalid)
  454:         else:
  455:             extobj = _make_extobj(
  456:                     call=self._call,
  457:                     all=self._all, divide=self._divide, over=self._over,
  458:                     under=self._under, invalid=self._invalid)
  459: 
  460:         self._token = _extobj_contextvar.set(extobj)
  461: 
  462:     def __exit__(self, *exc_info):
  463:         _extobj_contextvar.reset(self._token)
  464: 
  465:     def __call__(self, func):
  466:         # We need to customize `__call__` compared to `ContextDecorator`
  467:         # because we must store the token per-thread so cannot store it on
  468:         # the instance (we could create a new instance for this).
  469:         # This duplicates the code from `__enter__`.
  470:         @functools.wraps(func)
  471:         def inner(*args, **kwargs):
  472:             if self._call is _Unspecified:
  473:                 extobj = _make_extobj(
  474:                         all=self._all, divide=self._divide, over=self._over,
  475:                         under=self._under, invalid=self._invalid)
  476:             else:
  477:                 extobj = _make_extobj(
  478:                         call=self._call,
  479:                         all=self._all, divide=self._divide, over=self._over,
  480:                         under=self._under, invalid=self._invalid)
  481: 
  482:             _token = _extobj_contextvar.set(extobj)
  483:             try:
  484:                 # Call the original, decorated, function:
  485:                 return func(*args, **kwargs)
  486:             finally:
  487:                 _extobj_contextvar.reset(_token)
  488: 
  489:         return inner
