    1: """
    2: This module contains a set of functions for vectorized string
    3: operations.
    4: """
    5: 
    6: import functools
    7: import sys
    8: 
    9: import numpy as np
   10: from numpy import (
   11:     add,
   12:     equal,
   13:     greater,
   14:     greater_equal,
   15:     less,
   16:     less_equal,
   17:     not_equal,
   18: )
   19: from numpy import (
   20:     multiply as _multiply_ufunc,
   21: )
   22: from numpy._core.multiarray import _vec_string
   23: from numpy._core.overrides import array_function_dispatch, set_module
   24: from numpy._core.umath import (
   25:     _center,
   26:     _expandtabs,
   27:     _expandtabs_length,
   28:     _ljust,
   29:     _lstrip_chars,
   30:     _lstrip_whitespace,
   31:     _partition,
   32:     _partition_index,
   33:     _replace,
   34:     _rjust,
   35:     _rpartition,
   36:     _rpartition_index,
   37:     _rstrip_chars,
   38:     _rstrip_whitespace,
   39:     _slice,
   40:     _strip_chars,
   41:     _strip_whitespace,
   42:     _zfill,
   43:     isalnum,
   44:     isalpha,
   45:     isdecimal,
   46:     isdigit,
   47:     islower,
   48:     isnumeric,
   49:     isspace,
   50:     istitle,
   51:     isupper,
   52:     str_len,
   53: )
   54: from numpy._core.umath import (
   55:     count as _count_ufunc,
   56: )
   57: from numpy._core.umath import (
   58:     endswith as _endswith_ufunc,
   59: )
   60: from numpy._core.umath import (
   61:     find as _find_ufunc,
   62: )
   63: from numpy._core.umath import (
   64:     index as _index_ufunc,
   65: )
   66: from numpy._core.umath import (
   67:     rfind as _rfind_ufunc,
   68: )
   69: from numpy._core.umath import (
   70:     rindex as _rindex_ufunc,
   71: )
   72: from numpy._core.umath import (
   73:     startswith as _startswith_ufunc,
   74: )
   75: 
   76: 
   77: def _override___module__():
   78:     for ufunc in [
   79:         isalnum, isalpha, isdecimal, isdigit, islower, isnumeric, isspace,
   80:         istitle, isupper, str_len,
   81:     ]:
   82:         ufunc.__module__ = "numpy.strings"
   83:         ufunc.__qualname__ = ufunc.__name__
   84: 
   85: 
   86: _override___module__()
   87: 
   88: 
   89: __all__ = [
   90:     # UFuncs
   91:     "equal", "not_equal", "less", "less_equal", "greater", "greater_equal",
   92:     "add", "multiply", "isalpha", "isdigit", "isspace", "isalnum", "islower",
   93:     "isupper", "istitle", "isdecimal", "isnumeric", "str_len", "find",
   94:     "rfind", "index", "rindex", "count", "startswith", "endswith", "lstrip",
   95:     "rstrip", "strip", "replace", "expandtabs", "center", "ljust", "rjust",
   96:     "zfill", "partition", "rpartition", "slice",
   97: 
   98:     # _vec_string - Will gradually become ufuncs as well
   99:     "upper", "lower", "swapcase", "capitalize", "title",
  100: 
  101:     # _vec_string - Will probably not become ufuncs
  102:     "mod", "decode", "encode", "translate",
  103: 
  104:     # Removed from namespace until behavior has been crystallized
  105:     # "join", "split", "rsplit", "splitlines",
  106: ]
  107: 
  108: 
  109: MAX = np.iinfo(np.int64).max
  110: 
  111: array_function_dispatch = functools.partial(
  112:     array_function_dispatch, module='numpy.strings')
  113: 
  114: 
  115: def _get_num_chars(a):
  116:     """
  117:     Helper function that returns the number of characters per field in
  118:     a string or unicode array.  This is to abstract out the fact that
  119:     for a unicode array this is itemsize / 4.
  120:     """
  121:     if issubclass(a.dtype.type, np.str_):
  122:         return a.itemsize // 4
  123:     return a.itemsize
  124: 
  125: 
  126: def _to_bytes_or_str_array(result, output_dtype_like):
  127:     """
  128:     Helper function to cast a result back into an array
  129:     with the appropriate dtype if an object array must be used
  130:     as an intermediary.
  131:     """
  132:     output_dtype_like = np.asarray(output_dtype_like)
  133:     if result.size == 0:
  134:         # Calling asarray & tolist in an empty array would result
  135:         # in losing shape information
  136:         return result.astype(output_dtype_like.dtype)
  137:     ret = np.asarray(result.tolist())
  138:     if isinstance(output_dtype_like.dtype, np.dtypes.StringDType):
  139:         return ret.astype(type(output_dtype_like.dtype))
  140:     return ret.astype(type(output_dtype_like.dtype)(_get_num_chars(ret)))
  141: 
  142: 
  143: def _clean_args(*args):
  144:     """
  145:     Helper function for delegating arguments to Python string
  146:     functions.
  147: 
  148:     Many of the Python string operations that have optional arguments
  149:     do not use 'None' to indicate a default value.  In these cases,
  150:     we need to remove all None arguments, and those following them.
  151:     """
  152:     newargs = []
  153:     for chk in args:
  154:         if chk is None:
  155:             break
  156:         newargs.append(chk)
  157:     return newargs
  158: 
  159: 
  160: def _multiply_dispatcher(a, i):
  161:     return (a,)
  162: 
  163: 
  164: @set_module("numpy.strings")
  165: @array_function_dispatch(_multiply_dispatcher)
  166: def multiply(a, i):
  167:     """
  168:     Return (a * i), that is string multiple concatenation,
  169:     element-wise.
  170: 
  171:     Values in ``i`` of less than 0 are treated as 0 (which yields an
  172:     empty string).
  173: 
  174:     Parameters
  175:     ----------
  176:     a : array_like, with ``StringDType``, ``bytes_`` or ``str_`` dtype
  177: 
  178:     i : array_like, with any integer dtype
  179: 
  180:     Returns
  181:     -------
  182:     out : ndarray
  183:         Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype,
  184:         depending on input types
  185: 
  186:     Examples
  187:     --------
  188:     >>> import numpy as np
  189:     >>> a = np.array(["a", "b", "c"])
  190:     >>> np.strings.multiply(a, 3)
  191:     array(['aaa', 'bbb', 'ccc'], dtype='<U3')
  192:     >>> i = np.array([1, 2, 3])
  193:     >>> np.strings.multiply(a, i)
  194:     array(['a', 'bb', 'ccc'], dtype='<U3')
  195:     >>> np.strings.multiply(np.array(['a']), i)
  196:     array(['a', 'aa', 'aaa'], dtype='<U3')
  197:     >>> a = np.array(['a', 'b', 'c', 'd', 'e', 'f']).reshape((2, 3))
  198:     >>> np.strings.multiply(a, 3)
  199:     array([['aaa', 'bbb', 'ccc'],
  200:            ['ddd', 'eee', 'fff']], dtype='<U3')
  201:     >>> np.strings.multiply(a, i)
  202:     array([['a', 'bb', 'ccc'],
  203:            ['d', 'ee', 'fff']], dtype='<U3')
  204: 
  205:     """
  206:     a = np.asanyarray(a)
  207: 
  208:     i = np.asanyarray(i)
  209:     if not np.issubdtype(i.dtype, np.integer):
  210:         raise TypeError(f"unsupported type {i.dtype} for operand 'i'")
  211:     i = np.maximum(i, 0)
  212: 
  213:     # delegate to stringdtype loops that also do overflow checking
  214:     if a.dtype.char == "T":
  215:         return a * i
  216: 
  217:     a_len = str_len(a)
  218: 
  219:     # Ensure we can do a_len * i without overflow.
  220:     if np.any(a_len > sys.maxsize / np.maximum(i, 1)):
  221:         raise OverflowError("Overflow encountered in string multiply")
  222: 
  223:     buffersizes = a_len * i
  224:     out_dtype = f"{a.dtype.char}{buffersizes.max()}"
  225:     out = np.empty_like(a, shape=buffersizes.shape, dtype=out_dtype)
  226:     return _multiply_ufunc(a, i, out=out)
  227: 
  228: 
  229: def _mod_dispatcher(a, values):
  230:     return (a, values)
  231: 
  232: 
  233: @set_module("numpy.strings")
  234: @array_function_dispatch(_mod_dispatcher)
  235: def mod(a, values):
  236:     """
  237:     Return (a % i), that is pre-Python 2.6 string formatting
  238:     (interpolation), element-wise for a pair of array_likes of str
  239:     or unicode.
  240: 
  241:     Parameters
  242:     ----------
  243:     a : array_like, with `np.bytes_` or `np.str_` dtype
  244: 
  245:     values : array_like of values
  246:        These values will be element-wise interpolated into the string.
  247: 
  248:     Returns
  249:     -------
  250:     out : ndarray
  251:         Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype,
  252:         depending on input types
  253: 
  254:     Examples
  255:     --------
  256:     >>> import numpy as np
  257:     >>> a = np.array(["NumPy is a %s library"])
  258:     >>> np.strings.mod(a, values=["Python"])
  259:     array(['NumPy is a Python library'], dtype='<U25')
  260: 
  261:     >>> a = np.array([b'%d bytes', b'%d bits'])
  262:     >>> values = np.array([8, 64])
  263:     >>> np.strings.mod(a, values)
  264:     array([b'8 bytes', b'64 bits'], dtype='|S7')
  265: 
  266:     """
  267:     return _to_bytes_or_str_array(
  268:         _vec_string(a, np.object_, '__mod__', (values,)), a)
  269: 
  270: 
  271: @set_module("numpy.strings")
  272: def find(a, sub, start=0, end=None):
  273:     """
  274:     For each element, return the lowest index in the string where
  275:     substring ``sub`` is found, such that ``sub`` is contained in the
  276:     range [``start``, ``end``).
  277: 
  278:     Parameters
  279:     ----------
  280:     a : array_like, with ``StringDType``, ``bytes_`` or ``str_`` dtype
  281: 
  282:     sub : array_like, with `np.bytes_` or `np.str_` dtype
  283:         The substring to search for.
  284: 
  285:     start, end : array_like, with any integer dtype
  286:         The range to look in, interpreted as in slice notation.
  287: 
  288:     Returns
  289:     -------
  290:     y : ndarray
  291:         Output array of ints
  292: 
  293:     See Also
  294:     --------
  295:     str.find
  296: 
  297:     Examples
  298:     --------
  299:     >>> import numpy as np
  300:     >>> a = np.array(["NumPy is a Python library"])
  301:     >>> np.strings.find(a, "Python")
  302:     array([11])
  303: 
  304:     """
  305:     end = end if end is not None else MAX
  306:     return _find_ufunc(a, sub, start, end)
  307: 
  308: 
  309: @set_module("numpy.strings")
  310: def rfind(a, sub, start=0, end=None):
  311:     """
  312:     For each element, return the highest index in the string where
  313:     substring ``sub`` is found, such that ``sub`` is contained in the
  314:     range [``start``, ``end``).
  315: 
  316:     Parameters
  317:     ----------
  318:     a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
  319: 
  320:     sub : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
  321:         The substring to search for.
  322: 
  323:     start, end : array_like, with any integer dtype
  324:         The range to look in, interpreted as in slice notation.
  325: 
  326:     Returns
  327:     -------
  328:     y : ndarray
  329:         Output array of ints
  330: 
  331:     See Also
  332:     --------
  333:     str.rfind
  334: 
  335:     Examples
  336:     --------
  337:     >>> import numpy as np
  338:     >>> a = np.array(["Computer Science"])
  339:     >>> np.strings.rfind(a, "Science", start=0, end=None)
  340:     array([9])
  341:     >>> np.strings.rfind(a, "Science", start=0, end=8)
  342:     array([-1])
  343:     >>> b = np.array(["Computer Science", "Science"])
  344:     >>> np.strings.rfind(b, "Science", start=0, end=None)
  345:     array([9, 0])
  346: 
  347:     """
  348:     end = end if end is not None else MAX
  349:     return _rfind_ufunc(a, sub, start, end)
  350: 
  351: 
  352: @set_module("numpy.strings")
  353: def index(a, sub, start=0, end=None):
  354:     """
  355:     Like `find`, but raises :exc:`ValueError` when the substring is not found.
  356: 
  357:     Parameters
  358:     ----------
  359:     a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
  360: 
  361:     sub : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
  362: 
  363:     start, end : array_like, with any integer dtype, optional
  364: 
  365:     Returns
  366:     -------
  367:     out : ndarray
  368:         Output array of ints.
  369: 
  370:     See Also
  371:     --------
  372:     find, str.index
  373: 
  374:     Examples
  375:     --------
  376:     >>> import numpy as np
  377:     >>> a = np.array(["Computer Science"])
  378:     >>> np.strings.index(a, "Science", start=0, end=None)
  379:     array([9])
  380: 
  381:     """
  382:     end = end if end is not None else MAX
  383:     return _index_ufunc(a, sub, start, end)
  384: 
  385: 
  386: @set_module("numpy.strings")
  387: def rindex(a, sub, start=0, end=None):
  388:     """
  389:     Like `rfind`, but raises :exc:`ValueError` when the substring `sub` is
  390:     not found.
  391: 
  392:     Parameters
  393:     ----------
  394:     a : array-like, with `np.bytes_` or `np.str_` dtype
  395: 
  396:     sub : array-like, with `np.bytes_` or `np.str_` dtype
  397: 
  398:     start, end : array-like, with any integer dtype, optional
  399: 
  400:     Returns
  401:     -------
  402:     out : ndarray
  403:         Output array of ints.
  404: 
  405:     See Also
  406:     --------
  407:     rfind, str.rindex
  408: 
  409:     Examples
  410:     --------
  411:     >>> a = np.array(["Computer Science"])
  412:     >>> np.strings.rindex(a, "Science", start=0, end=None)
  413:     array([9])
  414: 
  415:     """
  416:     end = end if end is not None else MAX
  417:     return _rindex_ufunc(a, sub, start, end)
  418: 
  419: 
  420: @set_module("numpy.strings")
  421: def count(a, sub, start=0, end=None):
  422:     """
  423:     Returns an array with the number of non-overlapping occurrences of
  424:     substring ``sub`` in the range [``start``, ``end``).
  425: 
  426:     Parameters
  427:     ----------
  428:     a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
  429: 
  430:     sub : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
  431:        The substring to search for.
  432: 
  433:     start, end : array_like, with any integer dtype
  434:         The range to look in, interpreted as in slice notation.
  435: 
  436:     Returns
  437:     -------
  438:     y : ndarray
  439:         Output array of ints
  440: 
  441:     See Also
  442:     --------
  443:     str.count
  444: 
  445:     Examples
  446:     --------
  447:     >>> import numpy as np
  448:     >>> c = np.array(['aAaAaA', '  aA  ', 'abBABba'])
  449:     >>> c
  450:     array(['aAaAaA', '  aA  ', 'abBABba'], dtype='<U7')
  451:     >>> np.strings.count(c, 'A')
  452:     array([3, 1, 1])
  453:     >>> np.strings.count(c, 'aA')
  454:     array([3, 1, 0])
  455:     >>> np.strings.count(c, 'A', start=1, end=4)
  456:     array([2, 1, 1])
  457:     >>> np.strings.count(c, 'A', start=1, end=3)
  458:     array([1, 0, 0])
  459: 
  460:     """
  461:     end = end if end is not None else MAX
  462:     return _count_ufunc(a, sub, start, end)
  463: 
  464: 
  465: @set_module("numpy.strings")
  466: def startswith(a, prefix, start=0, end=None):
  467:     """
  468:     Returns a boolean array which is `True` where the string element
  469:     in ``a`` starts with ``prefix``, otherwise `False`.
  470: 
  471:     Parameters
  472:     ----------
  473:     a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
  474: 
  475:     prefix : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
  476: 
  477:     start, end : array_like, with any integer dtype
  478:         With ``start``, test beginning at that position. With ``end``,
  479:         stop comparing at that position.
  480: 
  481:     Returns
  482:     -------
  483:     out : ndarray
  484:         Output array of bools
  485: 
  486:     See Also
  487:     --------
  488:     str.startswith
  489: 
  490:     Examples
  491:     --------
  492:     >>> import numpy as np
  493:     >>> s = np.array(['foo', 'bar'])
  494:     >>> s
  495:     array(['foo', 'bar'], dtype='<U3')
  496:     >>> np.strings.startswith(s, 'fo')
  497:     array([True,  False])
  498:     >>> np.strings.startswith(s, 'o', start=1, end=2)
  499:     array([True,  False])
  500: 
  501:     """
  502:     end = end if end is not None else MAX
  503:     return _startswith_ufunc(a, prefix, start, end)
  504: 
  505: 
  506: @set_module("numpy.strings")
  507: def endswith(a, suffix, start=0, end=None):
  508:     """
  509:     Returns a boolean array which is `True` where the string element
  510:     in ``a`` ends with ``suffix``, otherwise `False`.
  511: 
  512:     Parameters
  513:     ----------
  514:     a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
  515: 
  516:     suffix : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
  517: 
  518:     start, end : array_like, with any integer dtype
  519:         With ``start``, test beginning at that position. With ``end``,
  520:         stop comparing at that position.
  521: 
  522:     Returns
  523:     -------
  524:     out : ndarray
  525:         Output array of bools
  526: 
  527:     See Also
  528:     --------
  529:     str.endswith
  530: 
  531:     Examples
  532:     --------
  533:     >>> import numpy as np
  534:     >>> s = np.array(['foo', 'bar'])
  535:     >>> s
  536:     array(['foo', 'bar'], dtype='<U3')
  537:     >>> np.strings.endswith(s, 'ar')
  538:     array([False,  True])
  539:     >>> np.strings.endswith(s, 'a', start=1, end=2)
  540:     array([False,  True])
  541: 
  542:     """
  543:     end = end if end is not None else MAX
  544:     return _endswith_ufunc(a, suffix, start, end)
  545: 
  546: 
  547: def _code_dispatcher(a, encoding=None, errors=None):
  548:     return (a,)
  549: 
  550: 
  551: @set_module("numpy.strings")
  552: @array_function_dispatch(_code_dispatcher)
  553: def decode(a, encoding=None, errors=None):
  554:     r"""
  555:     Calls :meth:`bytes.decode` element-wise.
  556: 
  557:     The set of available codecs comes from the Python standard library,
  558:     and may be extended at runtime.  For more information, see the
  559:     :mod:`codecs` module.
  560: 
  561:     Parameters
  562:     ----------
  563:     a : array_like, with ``bytes_`` dtype
  564: 
  565:     encoding : str, optional
  566:        The name of an encoding
  567: 
  568:     errors : str, optional
  569:        Specifies how to handle encoding errors
  570: 
  571:     Returns
  572:     -------
  573:     out : ndarray
  574: 
  575:     See Also
  576:     --------
  577:     :py:meth:`bytes.decode`
  578: 
  579:     Notes
  580:     -----
  581:     The type of the result will depend on the encoding specified.
  582: 
  583:     Examples
  584:     --------
  585:     >>> import numpy as np
  586:     >>> c = np.array([b'\x81\xc1\x81\xc1\x81\xc1', b'@@\x81\xc1@@',
  587:     ...               b'\x81\x82\xc2\xc1\xc2\x82\x81'])
  588:     >>> c
  589:     array([b'\x81\xc1\x81\xc1\x81\xc1', b'@@\x81\xc1@@',
  590:            b'\x81\x82\xc2\xc1\xc2\x82\x81'], dtype='|S7')
  591:     >>> np.strings.decode(c, encoding='cp037')
  592:     array(['aAaAaA', '  aA  ', 'abBABba'], dtype='<U7')
  593: 
  594:     """
  595:     return _to_bytes_or_str_array(
  596:         _vec_string(a, np.object_, 'decode', _clean_args(encoding, errors)),
  597:         np.str_(''))
  598: 
  599: 
  600: @set_module("numpy.strings")
  601: @array_function_dispatch(_code_dispatcher)
  602: def encode(a, encoding=None, errors=None):
  603:     """
  604:     Calls :meth:`str.encode` element-wise.
  605: 
  606:     The set of available codecs comes from the Python standard library,
  607:     and may be extended at runtime. For more information, see the
  608:     :mod:`codecs` module.
  609: 
  610:     Parameters
  611:     ----------
  612:     a : array_like, with ``StringDType`` or ``str_`` dtype
  613: 
  614:     encoding : str, optional
  615:        The name of an encoding
  616: 
  617:     errors : str, optional
  618:        Specifies how to handle encoding errors
  619: 
  620:     Returns
  621:     -------
  622:     out : ndarray
  623: 
  624:     See Also
  625:     --------
  626:     str.encode
  627: 
  628:     Notes
  629:     -----
  630:     The type of the result will depend on the encoding specified.
  631: 
  632:     Examples
  633:     --------
  634:     >>> import numpy as np
  635:     >>> a = np.array(['aAaAaA', '  aA  ', 'abBABba'])
  636:     >>> np.strings.encode(a, encoding='cp037')
  637:     array([b'\x81\xc1\x81\xc1\x81\xc1', b'@@\x81\xc1@@',
  638:        b'\x81\x82\xc2\xc1\xc2\x82\x81'], dtype='|S7')
  639: 
  640:     """
  641:     return _to_bytes_or_str_array(
  642:         _vec_string(a, np.object_, 'encode', _clean_args(encoding, errors)),
  643:         np.bytes_(b''))
  644: 
  645: 
  646: def _expandtabs_dispatcher(a, tabsize=None):
  647:     return (a,)
  648: 
  649: 
  650: @set_module("numpy.strings")
  651: @array_function_dispatch(_expandtabs_dispatcher)
  652: def expandtabs(a, tabsize=8):
  653:     """
  654:     Return a copy of each string element where all tab characters are
  655:     replaced by one or more spaces.
  656: 
  657:     Calls :meth:`str.expandtabs` element-wise.
  658: 
  659:     Return a copy of each string element where all tab characters are
  660:     replaced by one or more spaces, depending on the current column
  661:     and the given `tabsize`. The column number is reset to zero after
  662:     each newline occurring in the string. This doesn't understand other
  663:     non-printing characters or escape sequences.
  664: 
  665:     Parameters
  666:     ----------
  667:     a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
  668:         Input array
  669:     tabsize : int, optional
  670:         Replace tabs with `tabsize` number of spaces.  If not given defaults
  671:         to 8 spaces.
  672: 
  673:     Returns
  674:     -------
  675:     out : ndarray
  676:         Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype,
  677:         depending on input type
  678: 
  679:     See Also
  680:     --------
  681:     str.expandtabs
  682: 
  683:     Examples
  684:     --------
  685:     >>> import numpy as np
  686:     >>> a = np.array(['\t\tHello\tworld'])
  687:     >>> np.strings.expandtabs(a, tabsize=4)  # doctest: +SKIP
  688:     array(['        Hello   world'], dtype='<U21')  # doctest: +SKIP
  689: 
  690:     """
  691:     a = np.asanyarray(a)
  692:     tabsize = np.asanyarray(tabsize)
  693: 
  694:     if a.dtype.char == "T":
  695:         return _expandtabs(a, tabsize)
  696: 
  697:     buffersizes = _expandtabs_length(a, tabsize)
  698:     out_dtype = f"{a.dtype.char}{buffersizes.max()}"
  699:     out = np.empty_like(a, shape=buffersizes.shape, dtype=out_dtype)
  700:     return _expandtabs(a, tabsize, out=out)
  701: 
  702: 
  703: def _just_dispatcher(a, width, fillchar=None):
  704:     return (a,)
  705: 
  706: 
  707: @set_module("numpy.strings")
  708: @array_function_dispatch(_just_dispatcher)
  709: def center(a, width, fillchar=' '):
  710:     """
  711:     Return a copy of `a` with its elements centered in a string of
  712:     length `width`.
  713: 
  714:     Parameters
  715:     ----------
  716:     a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
  717: 
  718:     width : array_like, with any integer dtype
  719:         The length of the resulting strings, unless ``width < str_len(a)``.
  720:     fillchar : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
  721:         Optional padding character to use (default is space).
  722: 
  723:     Returns
  724:     -------
  725:     out : ndarray
  726:         Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype,
  727:         depending on input types
  728: 
  729:     See Also
  730:     --------
  731:     str.center
  732: 
  733:     Notes
  734:     -----
  735:     While it is possible for ``a`` and ``fillchar`` to have different dtypes,
  736:     passing a non-ASCII character in ``fillchar`` when ``a`` is of dtype "S"
  737:     is not allowed, and a ``ValueError`` is raised.
  738: 
  739:     Examples
  740:     --------
  741:     >>> import numpy as np
  742:     >>> c = np.array(['a1b2','1b2a','b2a1','2a1b']); c
  743:     array(['a1b2', '1b2a', 'b2a1', '2a1b'], dtype='<U4')
  744:     >>> np.strings.center(c, width=9)
  745:     array(['   a1b2  ', '   1b2a  ', '   b2a1  ', '   2a1b  '], dtype='<U9')
  746:     >>> np.strings.center(c, width=9, fillchar='*')
  747:     array(['***a1b2**', '***1b2a**', '***b2a1**', '***2a1b**'], dtype='<U9')
  748:     >>> np.strings.center(c, width=1)
  749:     array(['a1b2', '1b2a', 'b2a1', '2a1b'], dtype='<U4')
  750: 
  751:     """
  752:     width = np.asanyarray(width)
  753: 
  754:     if not np.issubdtype(width.dtype, np.integer):
  755:         raise TypeError(f"unsupported type {width.dtype} for operand 'width'")
  756: 
  757:     a = np.asanyarray(a)
  758:     fillchar = np.asanyarray(fillchar)
  759: 
  760:     if np.any(str_len(fillchar) != 1):
  761:         raise TypeError(
  762:             "The fill character must be exactly one character long")
  763: 
  764:     if np.result_type(a, fillchar).char == "T":
  765:         return _center(a, width, fillchar)
  766: 
  767:     fillchar = fillchar.astype(a.dtype, copy=False)
  768:     width = np.maximum(str_len(a), width)
  769:     out_dtype = f"{a.dtype.char}{width.max()}"
  770:     shape = np.broadcast_shapes(a.shape, width.shape, fillchar.shape)
  771:     out = np.empty_like(a, shape=shape, dtype=out_dtype)
  772: 
  773:     return _center(a, width, fillchar, out=out)
  774: 
  775: 
  776: @set_module("numpy.strings")
  777: @array_function_dispatch(_just_dispatcher)
  778: def ljust(a, width, fillchar=' '):
  779:     """
  780:     Return an array with the elements of `a` left-justified in a
  781:     string of length `width`.
  782: 
  783:     Parameters
  784:     ----------
  785:     a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
  786: 
  787:     width : array_like, with any integer dtype
  788:         The length of the resulting strings, unless ``width < str_len(a)``.
  789:     fillchar : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
  790:         Optional character to use for padding (default is space).
  791: 
  792:     Returns
  793:     -------
  794:     out : ndarray
  795:         Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype,
  796:         depending on input types
  797: 
  798:     See Also
  799:     --------
  800:     str.ljust
  801: 
  802:     Notes
  803:     -----
  804:     While it is possible for ``a`` and ``fillchar`` to have different dtypes,
  805:     passing a non-ASCII character in ``fillchar`` when ``a`` is of dtype "S"
  806:     is not allowed, and a ``ValueError`` is raised.
  807: 
  808:     Examples
  809:     --------
  810:     >>> import numpy as np
  811:     >>> c = np.array(['aAaAaA', '  aA  ', 'abBABba'])
  812:     >>> np.strings.ljust(c, width=3)
  813:     array(['aAaAaA', '  aA  ', 'abBABba'], dtype='<U7')
  814:     >>> np.strings.ljust(c, width=9)
  815:     array(['aAaAaA   ', '  aA     ', 'abBABba  '], dtype='<U9')
  816: 
  817:     """
  818:     width = np.asanyarray(width)
  819:     if not np.issubdtype(width.dtype, np.integer):
  820:         raise TypeError(f"unsupported type {width.dtype} for operand 'width'")
  821: 
  822:     a = np.asanyarray(a)
  823:     fillchar = np.asanyarray(fillchar)
  824: 
  825:     if np.any(str_len(fillchar) != 1):
  826:         raise TypeError(
  827:             "The fill character must be exactly one character long")
  828: 
  829:     if np.result_type(a, fillchar).char == "T":
  830:         return _ljust(a, width, fillchar)
  831: 
  832:     fillchar = fillchar.astype(a.dtype, copy=False)
  833:     width = np.maximum(str_len(a), width)
  834:     shape = np.broadcast_shapes(a.shape, width.shape, fillchar.shape)
  835:     out_dtype = f"{a.dtype.char}{width.max()}"
  836:     out = np.empty_like(a, shape=shape, dtype=out_dtype)
  837: 
  838:     return _ljust(a, width, fillchar, out=out)
  839: 
  840: 
  841: @set_module("numpy.strings")
  842: @array_function_dispatch(_just_dispatcher)
  843: def rjust(a, width, fillchar=' '):
  844:     """
  845:     Return an array with the elements of `a` right-justified in a
  846:     string of length `width`.
  847: 
  848:     Parameters
  849:     ----------
  850:     a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
  851: 
  852:     width : array_like, with any integer dtype
  853:         The length of the resulting strings, unless ``width < str_len(a)``.
  854:     fillchar : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
  855:         Optional padding character to use (default is space).
  856: 
  857:     Returns
  858:     -------
  859:     out : ndarray
  860:         Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype,
  861:         depending on input types
  862: 
  863:     See Also
  864:     --------
  865:     str.rjust
  866: 
  867:     Notes
  868:     -----
  869:     While it is possible for ``a`` and ``fillchar`` to have different dtypes,
  870:     passing a non-ASCII character in ``fillchar`` when ``a`` is of dtype "S"
  871:     is not allowed, and a ``ValueError`` is raised.
  872: 
  873:     Examples
  874:     --------
  875:     >>> import numpy as np
  876:     >>> a = np.array(['aAaAaA', '  aA  ', 'abBABba'])
  877:     >>> np.strings.rjust(a, width=3)
  878:     array(['aAaAaA', '  aA  ', 'abBABba'], dtype='<U7')
  879:     >>> np.strings.rjust(a, width=9)
  880:     array(['   aAaAaA', '     aA  ', '  abBABba'], dtype='<U9')
  881: 
  882:     """
  883:     width = np.asanyarray(width)
  884:     if not np.issubdtype(width.dtype, np.integer):
  885:         raise TypeError(f"unsupported type {width.dtype} for operand 'width'")
  886: 
  887:     a = np.asanyarray(a)
  888:     fillchar = np.asanyarray(fillchar)
  889: 
  890:     if np.any(str_len(fillchar) != 1):
  891:         raise TypeError(
  892:             "The fill character must be exactly one character long")
  893: 
  894:     if np.result_type(a, fillchar).char == "T":
  895:         return _rjust(a, width, fillchar)
  896: 
  897:     fillchar = fillchar.astype(a.dtype, copy=False)
  898:     width = np.maximum(str_len(a), width)
  899:     shape = np.broadcast_shapes(a.shape, width.shape, fillchar.shape)
  900:     out_dtype = f"{a.dtype.char}{width.max()}"
  901:     out = np.empty_like(a, shape=shape, dtype=out_dtype)
  902: 
  903:     return _rjust(a, width, fillchar, out=out)
  904: 
  905: 
  906: def _zfill_dispatcher(a, width):
  907:     return (a,)
  908: 
  909: 
  910: @set_module("numpy.strings")
  911: @array_function_dispatch(_zfill_dispatcher)
  912: def zfill(a, width):
  913:     """
  914:     Return the numeric string left-filled with zeros. A leading
  915:     sign prefix (``+``/``-``) is handled by inserting the padding
  916:     after the sign character rather than before.
  917: 
  918:     Parameters
  919:     ----------
  920:     a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
  921: 
  922:     width : array_like, with any integer dtype
  923:         Width of string to left-fill elements in `a`.
  924: 
  925:     Returns
  926:     -------
  927:     out : ndarray
  928:         Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype,
  929:         depending on input type
  930: 
  931:     See Also
  932:     --------
  933:     str.zfill
  934: 
  935:     Examples
  936:     --------
  937:     >>> import numpy as np
  938:     >>> np.strings.zfill(['1', '-1', '+1'], 3)
  939:     array(['001', '-01', '+01'], dtype='<U3')
  940: 
  941:     """
  942:     width = np.asanyarray(width)
  943:     if not np.issubdtype(width.dtype, np.integer):
  944:         raise TypeError(f"unsupported type {width.dtype} for operand 'width'")
  945: 
  946:     a = np.asanyarray(a)
  947: 
  948:     if a.dtype.char == "T":
  949:         return _zfill(a, width)
  950: 
  951:     width = np.maximum(str_len(a), width)
  952:     shape = np.broadcast_shapes(a.shape, width.shape)
  953:     out_dtype = f"{a.dtype.char}{width.max()}"
  954:     out = np.empty_like(a, shape=shape, dtype=out_dtype)
  955:     return _zfill(a, width, out=out)
  956: 
  957: 
  958: @set_module("numpy.strings")
  959: def lstrip(a, chars=None):
  960:     """
  961:     For each element in `a`, return a copy with the leading characters
  962:     removed.
  963: 
  964:     Parameters
  965:     ----------
  966:     a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
  967:     chars : scalar with the same dtype as ``a``, optional
  968:        The ``chars`` argument is a string specifying the set of
  969:        characters to be removed. If ``None``, the ``chars``
  970:        argument defaults to removing whitespace. The ``chars`` argument
  971:        is not a prefix or suffix; rather, all combinations of its
  972:        values are stripped.
  973: 
  974:     Returns
  975:     -------
  976:     out : ndarray
  977:         Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype,
  978:         depending on input types
  979: 
  980:     See Also
  981:     --------
  982:     str.lstrip
  983: 
  984:     Examples
  985:     --------
  986:     >>> import numpy as np
  987:     >>> c = np.array(['aAaAaA', '  aA  ', 'abBABba'])
  988:     >>> c
  989:     array(['aAaAaA', '  aA  ', 'abBABba'], dtype='<U7')
  990:     # The 'a' variable is unstripped from c[1] because of leading whitespace.
  991:     >>> np.strings.lstrip(c, 'a')
  992:     array(['AaAaA', '  aA  ', 'bBABba'], dtype='<U7')
  993:     >>> np.strings.lstrip(c, 'A') # leaves c unchanged
  994:     array(['aAaAaA', '  aA  ', 'abBABba'], dtype='<U7')
  995:     >>> (np.strings.lstrip(c, ' ') == np.strings.lstrip(c, '')).all()
  996:     np.False_
  997:     >>> (np.strings.lstrip(c, ' ') == np.strings.lstrip(c)).all()
  998:     np.True_
  999: 
 1000:     """
 1001:     if chars is None:
 1002:         return _lstrip_whitespace(a)
 1003:     return _lstrip_chars(a, chars)
 1004: 
 1005: 
 1006: @set_module("numpy.strings")
 1007: def rstrip(a, chars=None):
 1008:     """
 1009:     For each element in `a`, return a copy with the trailing characters
 1010:     removed.
 1011: 
 1012:     Parameters
 1013:     ----------
 1014:     a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
 1015:     chars : scalar with the same dtype as ``a``, optional
 1016:        The ``chars`` argument is a string specifying the set of
 1017:        characters to be removed. If ``None``, the ``chars``
 1018:        argument defaults to removing whitespace. The ``chars`` argument
 1019:        is not a prefix or suffix; rather, all combinations of its
 1020:        values are stripped.
 1021: 
 1022:     Returns
 1023:     -------
 1024:     out : ndarray
 1025:         Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype,
 1026:         depending on input types
 1027: 
 1028:     See Also
 1029:     --------
 1030:     str.rstrip
 1031: 
 1032:     Examples
 1033:     --------
 1034:     >>> import numpy as np
 1035:     >>> c = np.array(['aAaAaA', 'abBABba'])
 1036:     >>> c
 1037:     array(['aAaAaA', 'abBABba'], dtype='<U7')
 1038:     >>> np.strings.rstrip(c, 'a')
 1039:     array(['aAaAaA', 'abBABb'], dtype='<U7')
 1040:     >>> np.strings.rstrip(c, 'A')
 1041:     array(['aAaAa', 'abBABba'], dtype='<U7')
 1042: 
 1043:     """
 1044:     if chars is None:
 1045:         return _rstrip_whitespace(a)
 1046:     return _rstrip_chars(a, chars)
 1047: 
 1048: 
 1049: @set_module("numpy.strings")
 1050: def strip(a, chars=None):
 1051:     """
 1052:     For each element in `a`, return a copy with the leading and
 1053:     trailing characters removed.
 1054: 
 1055:     Parameters
 1056:     ----------
 1057:     a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
 1058:     chars : scalar with the same dtype as ``a``, optional
 1059:        The ``chars`` argument is a string specifying the set of
 1060:        characters to be removed. If ``None``, the ``chars``
 1061:        argument defaults to removing whitespace. The ``chars`` argument
 1062:        is not a prefix or suffix; rather, all combinations of its
 1063:        values are stripped.
 1064: 
 1065:     Returns
 1066:     -------
 1067:     out : ndarray
 1068:         Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype,
 1069:         depending on input types
 1070: 
 1071:     See Also
 1072:     --------
 1073:     str.strip
 1074: 
 1075:     Examples
 1076:     --------
 1077:     >>> import numpy as np
 1078:     >>> c = np.array(['aAaAaA', '  aA  ', 'abBABba'])
 1079:     >>> c
 1080:     array(['aAaAaA', '  aA  ', 'abBABba'], dtype='<U7')
 1081:     >>> np.strings.strip(c)
 1082:     array(['aAaAaA', 'aA', 'abBABba'], dtype='<U7')
 1083:     # 'a' unstripped from c[1] because of leading whitespace.
 1084:     >>> np.strings.strip(c, 'a')
 1085:     array(['AaAaA', '  aA  ', 'bBABb'], dtype='<U7')
 1086:     # 'A' unstripped from c[1] because of trailing whitespace.
 1087:     >>> np.strings.strip(c, 'A')
 1088:     array(['aAaAa', '  aA  ', 'abBABba'], dtype='<U7')
 1089: 
 1090:     """
 1091:     if chars is None:
 1092:         return _strip_whitespace(a)
 1093:     return _strip_chars(a, chars)
 1094: 
 1095: 
 1096: def _unary_op_dispatcher(a):
 1097:     return (a,)
 1098: 
 1099: 
 1100: @set_module("numpy.strings")
 1101: @array_function_dispatch(_unary_op_dispatcher)
 1102: def upper(a):
 1103:     """
 1104:     Return an array with the elements converted to uppercase.
 1105: 
 1106:     Calls :meth:`str.upper` element-wise.
 1107: 
 1108:     For 8-bit strings, this method is locale-dependent.
 1109: 
 1110:     Parameters
 1111:     ----------
 1112:     a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
 1113:         Input array.
 1114: 
 1115:     Returns
 1116:     -------
 1117:     out : ndarray
 1118:         Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype,
 1119:         depending on input types
 1120: 
 1121:     See Also
 1122:     --------
 1123:     str.upper
 1124: 
 1125:     Examples
 1126:     --------
 1127:     >>> import numpy as np
 1128:     >>> c = np.array(['a1b c', '1bca', 'bca1']); c
 1129:     array(['a1b c', '1bca', 'bca1'], dtype='<U5')
 1130:     >>> np.strings.upper(c)
 1131:     array(['A1B C', '1BCA', 'BCA1'], dtype='<U5')
 1132: 
 1133:     """
 1134:     a_arr = np.asarray(a)
 1135:     return _vec_string(a_arr, a_arr.dtype, 'upper')
 1136: 
 1137: 
 1138: @set_module("numpy.strings")
 1139: @array_function_dispatch(_unary_op_dispatcher)
 1140: def lower(a):
 1141:     """
 1142:     Return an array with the elements converted to lowercase.
 1143: 
 1144:     Call :meth:`str.lower` element-wise.
 1145: 
 1146:     For 8-bit strings, this method is locale-dependent.
 1147: 
 1148:     Parameters
 1149:     ----------
 1150:     a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
 1151:         Input array.
 1152: 
 1153:     Returns
 1154:     -------
 1155:     out : ndarray
 1156:         Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype,
 1157:         depending on input types
 1158: 
 1159:     See Also
 1160:     --------
 1161:     str.lower
 1162: 
 1163:     Examples
 1164:     --------
 1165:     >>> import numpy as np
 1166:     >>> c = np.array(['A1B C', '1BCA', 'BCA1']); c
 1167:     array(['A1B C', '1BCA', 'BCA1'], dtype='<U5')
 1168:     >>> np.strings.lower(c)
 1169:     array(['a1b c', '1bca', 'bca1'], dtype='<U5')
 1170: 
 1171:     """
 1172:     a_arr = np.asarray(a)
 1173:     return _vec_string(a_arr, a_arr.dtype, 'lower')
 1174: 
 1175: 
 1176: @set_module("numpy.strings")
 1177: @array_function_dispatch(_unary_op_dispatcher)
 1178: def swapcase(a):
 1179:     """
 1180:     Return element-wise a copy of the string with
 1181:     uppercase characters converted to lowercase and vice versa.
 1182: 
 1183:     Calls :meth:`str.swapcase` element-wise.
 1184: 
 1185:     For 8-bit strings, this method is locale-dependent.
 1186: 
 1187:     Parameters
 1188:     ----------
 1189:     a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
 1190:         Input array.
 1191: 
 1192:     Returns
 1193:     -------
 1194:     out : ndarray
 1195:         Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype,
 1196:         depending on input types
 1197: 
 1198:     See Also
 1199:     --------
 1200:     str.swapcase
 1201: 
 1202:     Examples
 1203:     --------
 1204:     >>> import numpy as np
 1205:     >>> c=np.array(['a1B c','1b Ca','b Ca1','cA1b'],'S5'); c
 1206:     array(['a1B c', '1b Ca', 'b Ca1', 'cA1b'],
 1207:         dtype='|S5')
 1208:     >>> np.strings.swapcase(c)
 1209:     array(['A1b C', '1B cA', 'B cA1', 'Ca1B'],
 1210:         dtype='|S5')
 1211: 
 1212:     """
 1213:     a_arr = np.asarray(a)
 1214:     return _vec_string(a_arr, a_arr.dtype, 'swapcase')
 1215: 
 1216: 
 1217: @set_module("numpy.strings")
 1218: @array_function_dispatch(_unary_op_dispatcher)
 1219: def capitalize(a):
 1220:     """
 1221:     Return a copy of ``a`` with only the first character of each element
 1222:     capitalized.
 1223: 
 1224:     Calls :meth:`str.capitalize` element-wise.
 1225: 
 1226:     For byte strings, this method is locale-dependent.
 1227: 
 1228:     Parameters
 1229:     ----------
 1230:     a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
 1231:         Input array of strings to capitalize.
 1232: 
 1233:     Returns
 1234:     -------
 1235:     out : ndarray
 1236:         Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype,
 1237:         depending on input types
 1238: 
 1239:     See Also
 1240:     --------
 1241:     str.capitalize
 1242: 
 1243:     Examples
 1244:     --------
 1245:     >>> import numpy as np
 1246:     >>> c = np.array(['a1b2','1b2a','b2a1','2a1b'],'S4'); c
 1247:     array(['a1b2', '1b2a', 'b2a1', '2a1b'],
 1248:         dtype='|S4')
 1249:     >>> np.strings.capitalize(c)
 1250:     array(['A1b2', '1b2a', 'B2a1', '2a1b'],
 1251:         dtype='|S4')
 1252: 
 1253:     """
 1254:     a_arr = np.asarray(a)
 1255:     return _vec_string(a_arr, a_arr.dtype, 'capitalize')
 1256: 
 1257: 
 1258: @set_module("numpy.strings")
 1259: @array_function_dispatch(_unary_op_dispatcher)
 1260: def title(a):
 1261:     """
 1262:     Return element-wise title cased version of string or unicode.
 1263: 
 1264:     Title case words start with uppercase characters, all remaining cased
 1265:     characters are lowercase.
 1266: 
 1267:     Calls :meth:`str.title` element-wise.
 1268: 
 1269:     For 8-bit strings, this method is locale-dependent.
 1270: 
 1271:     Parameters
 1272:     ----------
 1273:     a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
 1274:         Input array.
 1275: 
 1276:     Returns
 1277:     -------
 1278:     out : ndarray
 1279:         Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype,
 1280:         depending on input types
 1281: 
 1282:     See Also
 1283:     --------
 1284:     str.title
 1285: 
 1286:     Examples
 1287:     --------
 1288:     >>> import numpy as np
 1289:     >>> c=np.array(['a1b c','1b ca','b ca1','ca1b'],'S5'); c
 1290:     array(['a1b c', '1b ca', 'b ca1', 'ca1b'],
 1291:         dtype='|S5')
 1292:     >>> np.strings.title(c)
 1293:     array(['A1B C', '1B Ca', 'B Ca1', 'Ca1B'],
 1294:         dtype='|S5')
 1295: 
 1296:     """
 1297:     a_arr = np.asarray(a)
 1298:     return _vec_string(a_arr, a_arr.dtype, 'title')
 1299: 
 1300: 
 1301: def _replace_dispatcher(a, old, new, count=None):
 1302:     return (a,)
 1303: 
 1304: 
 1305: @set_module("numpy.strings")
 1306: @array_function_dispatch(_replace_dispatcher)
 1307: def replace(a, old, new, count=-1):
 1308:     """
 1309:     For each element in ``a``, return a copy of the string with
 1310:     occurrences of substring ``old`` replaced by ``new``.
 1311: 
 1312:     Parameters
 1313:     ----------
 1314:     a : array_like, with ``bytes_`` or ``str_`` dtype
 1315: 
 1316:     old, new : array_like, with ``bytes_`` or ``str_`` dtype
 1317: 
 1318:     count : array_like, with ``int_`` dtype
 1319:         If the optional argument ``count`` is given, only the first
 1320:         ``count`` occurrences are replaced.
 1321: 
 1322:     Returns
 1323:     -------
 1324:     out : ndarray
 1325:         Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype,
 1326:         depending on input types
 1327: 
 1328:     See Also
 1329:     --------
 1330:     str.replace
 1331: 
 1332:     Examples
 1333:     --------
 1334:     >>> import numpy as np
 1335:     >>> a = np.array(["That is a mango", "Monkeys eat mangos"])
 1336:     >>> np.strings.replace(a, 'mango', 'banana')
 1337:     array(['That is a banana', 'Monkeys eat bananas'], dtype='<U19')
 1338: 
 1339:     >>> a = np.array(["The dish is fresh", "This is it"])
 1340:     >>> np.strings.replace(a, 'is', 'was')
 1341:     array(['The dwash was fresh', 'Thwas was it'], dtype='<U19')
 1342: 
 1343:     """
 1344:     count = np.asanyarray(count)
 1345:     if not np.issubdtype(count.dtype, np.integer):
 1346:         raise TypeError(f"unsupported type {count.dtype} for operand 'count'")
 1347: 
 1348:     arr = np.asanyarray(a)
 1349:     old_dtype = getattr(old, 'dtype', None)
 1350:     old = np.asanyarray(old)
 1351:     new_dtype = getattr(new, 'dtype', None)
 1352:     new = np.asanyarray(new)
 1353: 
 1354:     if np.result_type(arr, old, new).char == "T":
 1355:         return _replace(arr, old, new, count)
 1356: 
 1357:     a_dt = arr.dtype
 1358:     old = old.astype(old_dtype or a_dt, copy=False)
 1359:     new = new.astype(new_dtype or a_dt, copy=False)
 1360:     max_int64 = np.iinfo(np.int64).max
 1361:     counts = _count_ufunc(arr, old, 0, max_int64)
 1362:     counts = np.where(count < 0, counts, np.minimum(counts, count))
 1363:     buffersizes = str_len(arr) + counts * (str_len(new) - str_len(old))
 1364:     out_dtype = f"{arr.dtype.char}{buffersizes.max()}"
 1365:     out = np.empty_like(arr, shape=buffersizes.shape, dtype=out_dtype)
 1366: 
 1367:     return _replace(arr, old, new, counts, out=out)
 1368: 
 1369: 
 1370: def _join_dispatcher(sep, seq):
 1371:     return (sep, seq)
 1372: 
 1373: 
 1374: @array_function_dispatch(_join_dispatcher)
 1375: def _join(sep, seq):
 1376:     """
 1377:     Return a string which is the concatenation of the strings in the
 1378:     sequence `seq`.
 1379: 
 1380:     Calls :meth:`str.join` element-wise.
 1381: 
 1382:     Parameters
 1383:     ----------
 1384:     sep : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
 1385:     seq : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
 1386: 
 1387:     Returns
 1388:     -------
 1389:     out : ndarray
 1390:         Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype,
 1391:         depending on input types
 1392: 
 1393:     See Also
 1394:     --------
 1395:     str.join
 1396: 
 1397:     Examples
 1398:     --------
 1399:     >>> import numpy as np
 1400:     >>> np.strings.join('-', 'osd')  # doctest: +SKIP
 1401:     array('o-s-d', dtype='<U5')  # doctest: +SKIP
 1402: 
 1403:     >>> np.strings.join(['-', '.'], ['ghc', 'osd'])  # doctest: +SKIP
 1404:     array(['g-h-c', 'o.s.d'], dtype='<U5')  # doctest: +SKIP
 1405: 
 1406:     """
 1407:     return _to_bytes_or_str_array(
 1408:         _vec_string(sep, np.object_, 'join', (seq,)), seq)
 1409: 
 1410: 
 1411: def _split_dispatcher(a, sep=None, maxsplit=None):
 1412:     return (a,)
 1413: 
 1414: 
 1415: @array_function_dispatch(_split_dispatcher)
 1416: def _split(a, sep=None, maxsplit=None):
 1417:     """
 1418:     For each element in `a`, return a list of the words in the
 1419:     string, using `sep` as the delimiter string.
 1420: 
 1421:     Calls :meth:`str.split` element-wise.
 1422: 
 1423:     Parameters
 1424:     ----------
 1425:     a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
 1426: 
 1427:     sep : str or unicode, optional
 1428:        If `sep` is not specified or None, any whitespace string is a
 1429:        separator.
 1430: 
 1431:     maxsplit : int, optional
 1432:         If `maxsplit` is given, at most `maxsplit` splits are done.
 1433: 
 1434:     Returns
 1435:     -------
 1436:     out : ndarray
 1437:         Array of list objects
 1438: 
 1439:     Examples
 1440:     --------
 1441:     >>> import numpy as np
 1442:     >>> x = np.array("Numpy is nice!")
 1443:     >>> np.strings.split(x, " ")  # doctest: +SKIP
 1444:     array(list(['Numpy', 'is', 'nice!']), dtype=object)  # doctest: +SKIP
 1445: 
 1446:     >>> np.strings.split(x, " ", 1)  # doctest: +SKIP
 1447:     array(list(['Numpy', 'is nice!']), dtype=object)  # doctest: +SKIP
 1448: 
 1449:     See Also
 1450:     --------
 1451:     str.split, rsplit
 1452: 
 1453:     """
 1454:     # This will return an array of lists of different sizes, so we
 1455:     # leave it as an object array
 1456:     return _vec_string(
 1457:         a, np.object_, 'split', [sep] + _clean_args(maxsplit))
 1458: 
 1459: 
 1460: @array_function_dispatch(_split_dispatcher)
 1461: def _rsplit(a, sep=None, maxsplit=None):
 1462:     """
 1463:     For each element in `a`, return a list of the words in the
 1464:     string, using `sep` as the delimiter string.
 1465: 
 1466:     Calls :meth:`str.rsplit` element-wise.
 1467: 
 1468:     Except for splitting from the right, `rsplit`
 1469:     behaves like `split`.
 1470: 
 1471:     Parameters
 1472:     ----------
 1473:     a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
 1474: 
 1475:     sep : str or unicode, optional
 1476:         If `sep` is not specified or None, any whitespace string
 1477:         is a separator.
 1478:     maxsplit : int, optional
 1479:         If `maxsplit` is given, at most `maxsplit` splits are done,
 1480:         the rightmost ones.
 1481: 
 1482:     Returns
 1483:     -------
 1484:     out : ndarray
 1485:         Array of list objects
 1486: 
 1487:     See Also
 1488:     --------
 1489:     str.rsplit, split
 1490: 
 1491:     Examples
 1492:     --------
 1493:     >>> import numpy as np
 1494:     >>> a = np.array(['aAaAaA', 'abBABba'])
 1495:     >>> np.strings.rsplit(a, 'A')  # doctest: +SKIP
 1496:     array([list(['a', 'a', 'a', '']),  # doctest: +SKIP
 1497:            list(['abB', 'Bba'])], dtype=object)  # doctest: +SKIP
 1498: 
 1499:     """
 1500:     # This will return an array of lists of different sizes, so we
 1501:     # leave it as an object array
 1502:     return _vec_string(
 1503:         a, np.object_, 'rsplit', [sep] + _clean_args(maxsplit))
 1504: 
 1505: 
 1506: def _splitlines_dispatcher(a, keepends=None):
 1507:     return (a,)
 1508: 
 1509: 
 1510: @array_function_dispatch(_splitlines_dispatcher)
 1511: def _splitlines(a, keepends=None):
 1512:     """
 1513:     For each element in `a`, return a list of the lines in the
 1514:     element, breaking at line boundaries.
 1515: 
 1516:     Calls :meth:`str.splitlines` element-wise.
 1517: 
 1518:     Parameters
 1519:     ----------
 1520:     a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
 1521: 
 1522:     keepends : bool, optional
 1523:         Line breaks are not included in the resulting list unless
 1524:         keepends is given and true.
 1525: 
 1526:     Returns
 1527:     -------
 1528:     out : ndarray
 1529:         Array of list objects
 1530: 
 1531:     See Also
 1532:     --------
 1533:     str.splitlines
 1534: 
 1535:     Examples
 1536:     --------
 1537:     >>> np.char.splitlines("first line\\nsecond line")
 1538:     array(list(['first line', 'second line']), dtype=object)
 1539:     >>> a = np.array(["first\\nsecond", "third\\nfourth"])
 1540:     >>> np.char.splitlines(a)
 1541:     array([list(['first', 'second']), list(['third', 'fourth'])], dtype=object)
 1542: 
 1543:     """
 1544:     return _vec_string(
 1545:         a, np.object_, 'splitlines', _clean_args(keepends))
 1546: 
 1547: 
 1548: def _partition_dispatcher(a, sep):
 1549:     return (a,)
 1550: 
 1551: 
 1552: @set_module("numpy.strings")
 1553: @array_function_dispatch(_partition_dispatcher)
 1554: def partition(a, sep):
 1555:     """
 1556:     Partition each element in ``a`` around ``sep``.
 1557: 
 1558:     For each element in ``a``, split the element at the first
 1559:     occurrence of ``sep``, and return a 3-tuple containing the part
 1560:     before the separator, the separator itself, and the part after
 1561:     the separator. If the separator is not found, the first item of
 1562:     the tuple will contain the whole string, and the second and third
 1563:     ones will be the empty string.
 1564: 
 1565:     Parameters
 1566:     ----------
 1567:     a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
 1568:         Input array
 1569:     sep : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
 1570:         Separator to split each string element in ``a``.
 1571: 
 1572:     Returns
 1573:     -------
 1574:     out : 3-tuple:
 1575:         - array with ``StringDType``, ``bytes_`` or ``str_`` dtype with the
 1576:           part before the separator
 1577:         - array with ``StringDType``, ``bytes_`` or ``str_`` dtype with the
 1578:           separator
 1579:         - array with ``StringDType``, ``bytes_`` or ``str_`` dtype with the
 1580:           part after the separator
 1581: 
 1582:     See Also
 1583:     --------
 1584:     str.partition
 1585: 
 1586:     Examples
 1587:     --------
 1588:     >>> import numpy as np
 1589:     >>> x = np.array(["Numpy is nice!"])
 1590:     >>> np.strings.partition(x, " ")
 1591:     (array(['Numpy'], dtype='<U5'),
 1592:      array([' '], dtype='<U1'),
 1593:      array(['is nice!'], dtype='<U8'))
 1594: 
 1595:     """
 1596:     a = np.asanyarray(a)
 1597:     sep = np.asanyarray(sep)
 1598: 
 1599:     if np.result_type(a, sep).char == "T":
 1600:         return _partition(a, sep)
 1601: 
 1602:     sep = sep.astype(a.dtype, copy=False)
 1603:     pos = _find_ufunc(a, sep, 0, MAX)
 1604:     a_len = str_len(a)
 1605:     sep_len = str_len(sep)
 1606: 
 1607:     not_found = pos < 0
 1608:     buffersizes1 = np.where(not_found, a_len, pos)
 1609:     buffersizes3 = np.where(not_found, 0, a_len - pos - sep_len)
 1610: 
 1611:     out_dtype = ",".join([f"{a.dtype.char}{n}" for n in (
 1612:         buffersizes1.max(),
 1613:         1 if np.all(not_found) else sep_len.max(),
 1614:         buffersizes3.max(),
 1615:     )])
 1616:     shape = np.broadcast_shapes(a.shape, sep.shape)
 1617:     out = np.empty_like(a, shape=shape, dtype=out_dtype)
 1618:     return _partition_index(a, sep, pos, out=(out["f0"], out["f1"], out["f2"]))
 1619: 
 1620: 
 1621: @set_module("numpy.strings")
 1622: @array_function_dispatch(_partition_dispatcher)
 1623: def rpartition(a, sep):
 1624:     """
 1625:     Partition (split) each element around the right-most separator.
 1626: 
 1627:     For each element in ``a``, split the element at the last
 1628:     occurrence of ``sep``, and return a 3-tuple containing the part
 1629:     before the separator, the separator itself, and the part after
 1630:     the separator. If the separator is not found, the third item of
 1631:     the tuple will contain the whole string, and the first and second
 1632:     ones will be the empty string.
 1633: 
 1634:     Parameters
 1635:     ----------
 1636:     a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
 1637:         Input array
 1638:     sep : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
 1639:         Separator to split each string element in ``a``.
 1640: 
 1641:     Returns
 1642:     -------
 1643:     out : 3-tuple:
 1644:         - array with ``StringDType``, ``bytes_`` or ``str_`` dtype with the
 1645:           part before the separator
 1646:         - array with ``StringDType``, ``bytes_`` or ``str_`` dtype with the
 1647:           separator
 1648:         - array with ``StringDType``, ``bytes_`` or ``str_`` dtype with the
 1649:           part after the separator
 1650: 
 1651:     See Also
 1652:     --------
 1653:     str.rpartition
 1654: 
 1655:     Examples
 1656:     --------
 1657:     >>> import numpy as np
 1658:     >>> a = np.array(['aAaAaA', '  aA  ', 'abBABba'])
 1659:     >>> np.strings.rpartition(a, 'A')
 1660:     (array(['aAaAa', '  a', 'abB'], dtype='<U5'),
 1661:      array(['A', 'A', 'A'], dtype='<U1'),
 1662:      array(['', '  ', 'Bba'], dtype='<U3'))
 1663: 
 1664:     """
 1665:     a = np.asanyarray(a)
 1666:     sep = np.asanyarray(sep)
 1667: 
 1668:     if np.result_type(a, sep).char == "T":
 1669:         return _rpartition(a, sep)
 1670: 
 1671:     sep = sep.astype(a.dtype, copy=False)
 1672:     pos = _rfind_ufunc(a, sep, 0, MAX)
 1673:     a_len = str_len(a)
 1674:     sep_len = str_len(sep)
 1675: 
 1676:     not_found = pos < 0
 1677:     buffersizes1 = np.where(not_found, 0, pos)
 1678:     buffersizes3 = np.where(not_found, a_len, a_len - pos - sep_len)
 1679: 
 1680:     out_dtype = ",".join([f"{a.dtype.char}{n}" for n in (
 1681:         buffersizes1.max(),
 1682:         1 if np.all(not_found) else sep_len.max(),
 1683:         buffersizes3.max(),
 1684:     )])
 1685:     shape = np.broadcast_shapes(a.shape, sep.shape)
 1686:     out = np.empty_like(a, shape=shape, dtype=out_dtype)
 1687:     return _rpartition_index(
 1688:         a, sep, pos, out=(out["f0"], out["f1"], out["f2"]))
 1689: 
 1690: 
 1691: def _translate_dispatcher(a, table, deletechars=None):
 1692:     return (a,)
 1693: 
 1694: 
 1695: @set_module("numpy.strings")
 1696: @array_function_dispatch(_translate_dispatcher)
 1697: def translate(a, table, deletechars=None):
 1698:     """
 1699:     For each element in `a`, return a copy of the string where all
 1700:     characters occurring in the optional argument `deletechars` are
 1701:     removed, and the remaining characters have been mapped through the
 1702:     given translation table.
 1703: 
 1704:     Calls :meth:`str.translate` element-wise.
 1705: 
 1706:     Parameters
 1707:     ----------
 1708:     a : array-like, with `np.bytes_` or `np.str_` dtype
 1709: 
 1710:     table : str of length 256
 1711: 
 1712:     deletechars : str
 1713: 
 1714:     Returns
 1715:     -------
 1716:     out : ndarray
 1717:         Output array of str or unicode, depending on input type
 1718: 
 1719:     See Also
 1720:     --------
 1721:     str.translate
 1722: 
 1723:     Examples
 1724:     --------
 1725:     >>> import numpy as np
 1726:     >>> a = np.array(['a1b c', '1bca', 'bca1'])
 1727:     >>> table = a[0].maketrans('abc', '123')
 1728:     >>> deletechars = ' '
 1729:     >>> np.char.translate(a, table, deletechars)
 1730:     array(['112 3', '1231', '2311'], dtype='<U5')
 1731: 
 1732:     """
 1733:     a_arr = np.asarray(a)
 1734:     if issubclass(a_arr.dtype.type, np.str_):
 1735:         return _vec_string(
 1736:             a_arr, a_arr.dtype, 'translate', (table,))
 1737:     else:
 1738:         return _vec_string(
 1739:             a_arr,
 1740:             a_arr.dtype,
 1741:             'translate',
 1742:             [table] + _clean_args(deletechars)
 1743:         )
 1744: 
 1745: @set_module("numpy.strings")
 1746: def slice(a, start=None, stop=None, step=None, /):
 1747:     """
 1748:     Slice the strings in `a` by slices specified by `start`, `stop`, `step`.
 1749:     Like in the regular Python `slice` object, if only `start` is
 1750:     specified then it is interpreted as the `stop`.
 1751: 
 1752:     Parameters
 1753:     ----------
 1754:     a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
 1755:         Input array
 1756: 
 1757:     start : None, an integer or an array of integers
 1758:         The start of the slice, broadcasted to `a`'s shape
 1759: 
 1760:     stop : None, an integer or an array of integers
 1761:         The end of the slice, broadcasted to `a`'s shape
 1762: 
 1763:     step : None, an integer or an array of integers
 1764:         The step for the slice, broadcasted to `a`'s shape
 1765: 
 1766:     Returns
 1767:     -------
 1768:     out : ndarray
 1769:         Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype,
 1770:         depending on input type
 1771: 
 1772:     Examples
 1773:     --------
 1774:     >>> import numpy as np
 1775:     >>> a = np.array(['hello', 'world'])
 1776:     >>> np.strings.slice(a, 2)
 1777:     array(['he', 'wo'], dtype='<U5')
 1778: 
 1779:     >>> np.strings.slice(a, 1, 5, 2)
 1780:     array(['el', 'ol'], dtype='<U5')
 1781: 
 1782:     One can specify different start/stop/step for different array entries:
 1783: 
 1784:     >>> np.strings.slice(a, np.array([1, 2]), np.array([4, 5]))
 1785:     array(['ell', 'rld'], dtype='<U5')
 1786: 
 1787:     Negative slices have the same meaning as in regular Python:
 1788: 
 1789:     >>> b = np.array(['hello world', 'ОіОµО№О± ПѓОїП… ОєПЊПѓОјОµ', 'дЅ еҐЅдё–з•Њ', 'рџ‘‹ рџЊЌ'],
 1790:     ...              dtype=np.dtypes.StringDType())
 1791:     >>> np.strings.slice(b, -2)
 1792:     array(['hello wor', 'ОіОµО№О± ПѓОїП… ОєПЊПѓ', 'дЅ еҐЅ', 'рџ‘‹'], dtype=StringDType())
 1793: 
 1794:     >>> np.strings.slice(b, [3, -10, 2, -3], [-1, -2, -1, 3])
 1795:     array(['lo worl', ' ПѓОїП… ОєПЊПѓ', 'дё–', 'рџ‘‹ рџЊЌ'], dtype=StringDType())
 1796: 
 1797:     >>> np.strings.slice(b, None, None, -1)
 1798:     array(['dlrow olleh', 'ОµОјПѓПЊОє П…ОїПѓ О±О№ОµОі', 'з•Њдё–еҐЅдЅ ', 'рџЊЌ рџ‘‹'],
 1799:           dtype=StringDType())
 1800: 
 1801:     """
 1802:     # Just like in the construction of a regular slice object, if only start
 1803:     # is specified then start will become stop, see logic in slice_new.
 1804:     if stop is None:
 1805:         stop = start
 1806:         start = None
 1807: 
 1808:     # adjust start, stop, step to be integers, see logic in PySlice_Unpack
 1809:     if step is None:
 1810:         step = 1
 1811:     step = np.asanyarray(step)
 1812:     if not np.issubdtype(step.dtype, np.integer):
 1813:         raise TypeError(f"unsupported type {step.dtype} for operand 'step'")
 1814:     if np.any(step == 0):
 1815:         raise ValueError("slice step cannot be zero")
 1816: 
 1817:     if start is None:
 1818:         start = np.where(step < 0, np.iinfo(np.intp).max, 0)
 1819: 
 1820:     if stop is None:
 1821:         stop = np.where(step < 0, np.iinfo(np.intp).min, np.iinfo(np.intp).max)
 1822: 
 1823:     return _slice(a, start, stop, step)
