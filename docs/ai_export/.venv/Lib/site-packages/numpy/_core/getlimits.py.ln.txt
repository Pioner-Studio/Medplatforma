    1: """Machine limits for Float32 and Float64 and (long double) if available...
    2: 
    3: """
    4: __all__ = ['finfo', 'iinfo']
    5: 
    6: import types
    7: import warnings
    8: 
    9: from numpy._utils import set_module
   10: 
   11: from . import numeric
   12: from . import numerictypes as ntypes
   13: from ._machar import MachAr
   14: from .numeric import array, inf, nan
   15: from .umath import exp2, isnan, log10, nextafter
   16: 
   17: 
   18: def _fr0(a):
   19:     """fix rank-0 --> rank-1"""
   20:     if a.ndim == 0:
   21:         a = a.copy()
   22:         a.shape = (1,)
   23:     return a
   24: 
   25: 
   26: def _fr1(a):
   27:     """fix rank > 0 --> rank-0"""
   28:     if a.size == 1:
   29:         a = a.copy()
   30:         a.shape = ()
   31:     return a
   32: 
   33: 
   34: class MachArLike:
   35:     """ Object to simulate MachAr instance """
   36:     def __init__(self, ftype, *, eps, epsneg, huge, tiny,
   37:                  ibeta, smallest_subnormal=None, **kwargs):
   38:         self.params = _MACHAR_PARAMS[ftype]
   39:         self.ftype = ftype
   40:         self.title = self.params['title']
   41:         # Parameter types same as for discovered MachAr object.
   42:         if not smallest_subnormal:
   43:             self._smallest_subnormal = nextafter(
   44:                 self.ftype(0), self.ftype(1), dtype=self.ftype)
   45:         else:
   46:             self._smallest_subnormal = smallest_subnormal
   47:         self.epsilon = self.eps = self._float_to_float(eps)
   48:         self.epsneg = self._float_to_float(epsneg)
   49:         self.xmax = self.huge = self._float_to_float(huge)
   50:         self.xmin = self._float_to_float(tiny)
   51:         self.smallest_normal = self.tiny = self._float_to_float(tiny)
   52:         self.ibeta = self.params['itype'](ibeta)
   53:         self.__dict__.update(kwargs)
   54:         self.precision = int(-log10(self.eps))
   55:         self.resolution = self._float_to_float(
   56:             self._float_conv(10) ** (-self.precision))
   57:         self._str_eps = self._float_to_str(self.eps)
   58:         self._str_epsneg = self._float_to_str(self.epsneg)
   59:         self._str_xmin = self._float_to_str(self.xmin)
   60:         self._str_xmax = self._float_to_str(self.xmax)
   61:         self._str_resolution = self._float_to_str(self.resolution)
   62:         self._str_smallest_normal = self._float_to_str(self.xmin)
   63: 
   64:     @property
   65:     def smallest_subnormal(self):
   66:         """Return the value for the smallest subnormal.
   67: 
   68:         Returns
   69:         -------
   70:         smallest_subnormal : float
   71:             value for the smallest subnormal.
   72: 
   73:         Warns
   74:         -----
   75:         UserWarning
   76:             If the calculated value for the smallest subnormal is zero.
   77:         """
   78:         # Check that the calculated value is not zero, in case it raises a
   79:         # warning.
   80:         value = self._smallest_subnormal
   81:         if self.ftype(0) == value:
   82:             warnings.warn(
   83:                 f'The value of the smallest subnormal for {self.ftype} type is zero.',
   84:                 UserWarning, stacklevel=2)
   85: 
   86:         return self._float_to_float(value)
   87: 
   88:     @property
   89:     def _str_smallest_subnormal(self):
   90:         """Return the string representation of the smallest subnormal."""
   91:         return self._float_to_str(self.smallest_subnormal)
   92: 
   93:     def _float_to_float(self, value):
   94:         """Converts float to float.
   95: 
   96:         Parameters
   97:         ----------
   98:         value : float
   99:             value to be converted.
  100:         """
  101:         return _fr1(self._float_conv(value))
  102: 
  103:     def _float_conv(self, value):
  104:         """Converts float to conv.
  105: 
  106:         Parameters
  107:         ----------
  108:         value : float
  109:             value to be converted.
  110:         """
  111:         return array([value], self.ftype)
  112: 
  113:     def _float_to_str(self, value):
  114:         """Converts float to str.
  115: 
  116:         Parameters
  117:         ----------
  118:         value : float
  119:             value to be converted.
  120:         """
  121:         return self.params['fmt'] % array(_fr0(value)[0], self.ftype)
  122: 
  123: 
  124: _convert_to_float = {
  125:     ntypes.csingle: ntypes.single,
  126:     ntypes.complex128: ntypes.float64,
  127:     ntypes.clongdouble: ntypes.longdouble
  128:     }
  129: 
  130: # Parameters for creating MachAr / MachAr-like objects
  131: _title_fmt = 'numpy {} precision floating point number'
  132: _MACHAR_PARAMS = {
  133:     ntypes.double: {
  134:         'itype': ntypes.int64,
  135:         'fmt': '%24.16e',
  136:         'title': _title_fmt.format('double')},
  137:     ntypes.single: {
  138:         'itype': ntypes.int32,
  139:         'fmt': '%15.7e',
  140:         'title': _title_fmt.format('single')},
  141:     ntypes.longdouble: {
  142:         'itype': ntypes.longlong,
  143:         'fmt': '%s',
  144:         'title': _title_fmt.format('long double')},
  145:     ntypes.half: {
  146:         'itype': ntypes.int16,
  147:         'fmt': '%12.5e',
  148:         'title': _title_fmt.format('half')}}
  149: 
  150: # Key to identify the floating point type.  Key is result of
  151: #
  152: #    ftype = np.longdouble        # or float64, float32, etc.
  153: #    v = (ftype(-1.0) / ftype(10.0))
  154: #    v.view(v.dtype.newbyteorder('<')).tobytes()
  155: #
  156: # Uses division to work around deficiencies in strtold on some platforms.
  157: # See:
  158: # https://perl5.git.perl.org/perl.git/blob/3118d7d684b56cbeb702af874f4326683c45f045:/Configure
  159: 
  160: _KNOWN_TYPES = {}
  161: def _register_type(machar, bytepat):
  162:     _KNOWN_TYPES[bytepat] = machar
  163: 
  164: 
  165: _float_ma = {}
  166: 
  167: 
  168: def _register_known_types():
  169:     # Known parameters for float16
  170:     # See docstring of MachAr class for description of parameters.
  171:     f16 = ntypes.float16
  172:     float16_ma = MachArLike(f16,
  173:                             machep=-10,
  174:                             negep=-11,
  175:                             minexp=-14,
  176:                             maxexp=16,
  177:                             it=10,
  178:                             iexp=5,
  179:                             ibeta=2,
  180:                             irnd=5,
  181:                             ngrd=0,
  182:                             eps=exp2(f16(-10)),
  183:                             epsneg=exp2(f16(-11)),
  184:                             huge=f16(65504),
  185:                             tiny=f16(2 ** -14))
  186:     _register_type(float16_ma, b'f\xae')
  187:     _float_ma[16] = float16_ma
  188: 
  189:     # Known parameters for float32
  190:     f32 = ntypes.float32
  191:     float32_ma = MachArLike(f32,
  192:                             machep=-23,
  193:                             negep=-24,
  194:                             minexp=-126,
  195:                             maxexp=128,
  196:                             it=23,
  197:                             iexp=8,
  198:                             ibeta=2,
  199:                             irnd=5,
  200:                             ngrd=0,
  201:                             eps=exp2(f32(-23)),
  202:                             epsneg=exp2(f32(-24)),
  203:                             huge=f32((1 - 2 ** -24) * 2**128),
  204:                             tiny=exp2(f32(-126)))
  205:     _register_type(float32_ma, b'\xcd\xcc\xcc\xbd')
  206:     _float_ma[32] = float32_ma
  207: 
  208:     # Known parameters for float64
  209:     f64 = ntypes.float64
  210:     epsneg_f64 = 2.0 ** -53.0
  211:     tiny_f64 = 2.0 ** -1022.0
  212:     float64_ma = MachArLike(f64,
  213:                             machep=-52,
  214:                             negep=-53,
  215:                             minexp=-1022,
  216:                             maxexp=1024,
  217:                             it=52,
  218:                             iexp=11,
  219:                             ibeta=2,
  220:                             irnd=5,
  221:                             ngrd=0,
  222:                             eps=2.0 ** -52.0,
  223:                             epsneg=epsneg_f64,
  224:                             huge=(1.0 - epsneg_f64) / tiny_f64 * f64(4),
  225:                             tiny=tiny_f64)
  226:     _register_type(float64_ma, b'\x9a\x99\x99\x99\x99\x99\xb9\xbf')
  227:     _float_ma[64] = float64_ma
  228: 
  229:     # Known parameters for IEEE 754 128-bit binary float
  230:     ld = ntypes.longdouble
  231:     epsneg_f128 = exp2(ld(-113))
  232:     tiny_f128 = exp2(ld(-16382))
  233:     # Ignore runtime error when this is not f128
  234:     with numeric.errstate(all='ignore'):
  235:         huge_f128 = (ld(1) - epsneg_f128) / tiny_f128 * ld(4)
  236:     float128_ma = MachArLike(ld,
  237:                              machep=-112,
  238:                              negep=-113,
  239:                              minexp=-16382,
  240:                              maxexp=16384,
  241:                              it=112,
  242:                              iexp=15,
  243:                              ibeta=2,
  244:                              irnd=5,
  245:                              ngrd=0,
  246:                              eps=exp2(ld(-112)),
  247:                              epsneg=epsneg_f128,
  248:                              huge=huge_f128,
  249:                              tiny=tiny_f128)
  250:     # IEEE 754 128-bit binary float
  251:     _register_type(float128_ma,
  252:         b'\x9a\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\xfb\xbf')
  253:     _float_ma[128] = float128_ma
  254: 
  255:     # Known parameters for float80 (Intel 80-bit extended precision)
  256:     epsneg_f80 = exp2(ld(-64))
  257:     tiny_f80 = exp2(ld(-16382))
  258:     # Ignore runtime error when this is not f80
  259:     with numeric.errstate(all='ignore'):
  260:         huge_f80 = (ld(1) - epsneg_f80) / tiny_f80 * ld(4)
  261:     float80_ma = MachArLike(ld,
  262:                             machep=-63,
  263:                             negep=-64,
  264:                             minexp=-16382,
  265:                             maxexp=16384,
  266:                             it=63,
  267:                             iexp=15,
  268:                             ibeta=2,
  269:                             irnd=5,
  270:                             ngrd=0,
  271:                             eps=exp2(ld(-63)),
  272:                             epsneg=epsneg_f80,
  273:                             huge=huge_f80,
  274:                             tiny=tiny_f80)
  275:     # float80, first 10 bytes containing actual storage
  276:     _register_type(float80_ma, b'\xcd\xcc\xcc\xcc\xcc\xcc\xcc\xcc\xfb\xbf')
  277:     _float_ma[80] = float80_ma
  278: 
  279:     # Guessed / known parameters for double double; see:
  280:     # https://en.wikipedia.org/wiki/Quadruple-precision_floating-point_format#Double-double_arithmetic
  281:     # These numbers have the same exponent range as float64, but extended
  282:     # number of digits in the significand.
  283:     huge_dd = nextafter(ld(inf), ld(0), dtype=ld)
  284:     # As the smallest_normal in double double is so hard to calculate we set
  285:     # it to NaN.
  286:     smallest_normal_dd = nan
  287:     # Leave the same value for the smallest subnormal as double
  288:     smallest_subnormal_dd = ld(nextafter(0., 1.))
  289:     float_dd_ma = MachArLike(ld,
  290:                              machep=-105,
  291:                              negep=-106,
  292:                              minexp=-1022,
  293:                              maxexp=1024,
  294:                              it=105,
  295:                              iexp=11,
  296:                              ibeta=2,
  297:                              irnd=5,
  298:                              ngrd=0,
  299:                              eps=exp2(ld(-105)),
  300:                              epsneg=exp2(ld(-106)),
  301:                              huge=huge_dd,
  302:                              tiny=smallest_normal_dd,
  303:                              smallest_subnormal=smallest_subnormal_dd)
  304:     # double double; low, high order (e.g. PPC 64)
  305:     _register_type(float_dd_ma,
  306:         b'\x9a\x99\x99\x99\x99\x99Y<\x9a\x99\x99\x99\x99\x99\xb9\xbf')
  307:     # double double; high, low order (e.g. PPC 64 le)
  308:     _register_type(float_dd_ma,
  309:         b'\x9a\x99\x99\x99\x99\x99\xb9\xbf\x9a\x99\x99\x99\x99\x99Y<')
  310:     _float_ma['dd'] = float_dd_ma
  311: 
  312: 
  313: def _get_machar(ftype):
  314:     """ Get MachAr instance or MachAr-like instance
  315: 
  316:     Get parameters for floating point type, by first trying signatures of
  317:     various known floating point types, then, if none match, attempting to
  318:     identify parameters by analysis.
  319: 
  320:     Parameters
  321:     ----------
  322:     ftype : class
  323:         Numpy floating point type class (e.g. ``np.float64``)
  324: 
  325:     Returns
  326:     -------
  327:     ma_like : instance of :class:`MachAr` or :class:`MachArLike`
  328:         Object giving floating point parameters for `ftype`.
  329: 
  330:     Warns
  331:     -----
  332:     UserWarning
  333:         If the binary signature of the float type is not in the dictionary of
  334:         known float types.
  335:     """
  336:     params = _MACHAR_PARAMS.get(ftype)
  337:     if params is None:
  338:         raise ValueError(repr(ftype))
  339:     # Detect known / suspected types
  340:     # ftype(-1.0) / ftype(10.0) is better than ftype('-0.1') because stold
  341:     # may be deficient
  342:     key = (ftype(-1.0) / ftype(10.))
  343:     key = key.view(key.dtype.newbyteorder("<")).tobytes()
  344:     ma_like = None
  345:     if ftype == ntypes.longdouble:
  346:         # Could be 80 bit == 10 byte extended precision, where last bytes can
  347:         # be random garbage.
  348:         # Comparing first 10 bytes to pattern first to avoid branching on the
  349:         # random garbage.
  350:         ma_like = _KNOWN_TYPES.get(key[:10])
  351:     if ma_like is None:
  352:         # see if the full key is known.
  353:         ma_like = _KNOWN_TYPES.get(key)
  354:     if ma_like is None and len(key) == 16:
  355:         # machine limits could be f80 masquerading as np.float128,
  356:         # find all keys with length 16 and make new dict, but make the keys
  357:         # only 10 bytes long, the last bytes can be random garbage
  358:         _kt = {k[:10]: v for k, v in _KNOWN_TYPES.items() if len(k) == 16}
  359:         ma_like = _kt.get(key[:10])
  360:     if ma_like is not None:
  361:         return ma_like
  362:     # Fall back to parameter discovery
  363:     warnings.warn(
  364:         f'Signature {key} for {ftype} does not match any known type: '
  365:         'falling back to type probe function.\n'
  366:         'This warnings indicates broken support for the dtype!',
  367:         UserWarning, stacklevel=2)
  368:     return _discovered_machar(ftype)
  369: 
  370: 
  371: def _discovered_machar(ftype):
  372:     """ Create MachAr instance with found information on float types
  373: 
  374:     TODO: MachAr should be retired completely ideally.  We currently only
  375:           ever use it system with broken longdouble (valgrind, WSL).
  376:     """
  377:     params = _MACHAR_PARAMS[ftype]
  378:     return MachAr(lambda v: array([v], ftype),
  379:                   lambda v: _fr0(v.astype(params['itype']))[0],
  380:                   lambda v: array(_fr0(v)[0], ftype),
  381:                   lambda v: params['fmt'] % array(_fr0(v)[0], ftype),
  382:                   params['title'])
  383: 
  384: 
  385: @set_module('numpy')
  386: class finfo:
  387:     """
  388:     finfo(dtype)
  389: 
  390:     Machine limits for floating point types.
  391: 
  392:     Attributes
  393:     ----------
  394:     bits : int
  395:         The number of bits occupied by the type.
  396:     dtype : dtype
  397:         Returns the dtype for which `finfo` returns information. For complex
  398:         input, the returned dtype is the associated ``float*`` dtype for its
  399:         real and complex components.
  400:     eps : float
  401:         The difference between 1.0 and the next smallest representable float
  402:         larger than 1.0. For example, for 64-bit binary floats in the IEEE-754
  403:         standard, ``eps = 2**-52``, approximately 2.22e-16.
  404:     epsneg : float
  405:         The difference between 1.0 and the next smallest representable float
  406:         less than 1.0. For example, for 64-bit binary floats in the IEEE-754
  407:         standard, ``epsneg = 2**-53``, approximately 1.11e-16.
  408:     iexp : int
  409:         The number of bits in the exponent portion of the floating point
  410:         representation.
  411:     machep : int
  412:         The exponent that yields `eps`.
  413:     max : floating point number of the appropriate type
  414:         The largest representable number.
  415:     maxexp : int
  416:         The smallest positive power of the base (2) that causes overflow.
  417:     min : floating point number of the appropriate type
  418:         The smallest representable number, typically ``-max``.
  419:     minexp : int
  420:         The most negative power of the base (2) consistent with there
  421:         being no leading 0's in the mantissa.
  422:     negep : int
  423:         The exponent that yields `epsneg`.
  424:     nexp : int
  425:         The number of bits in the exponent including its sign and bias.
  426:     nmant : int
  427:         The number of bits in the mantissa.
  428:     precision : int
  429:         The approximate number of decimal digits to which this kind of
  430:         float is precise.
  431:     resolution : floating point number of the appropriate type
  432:         The approximate decimal resolution of this type, i.e.,
  433:         ``10**-precision``.
  434:     tiny : float
  435:         An alias for `smallest_normal`, kept for backwards compatibility.
  436:     smallest_normal : float
  437:         The smallest positive floating point number with 1 as leading bit in
  438:         the mantissa following IEEE-754 (see Notes).
  439:     smallest_subnormal : float
  440:         The smallest positive floating point number with 0 as leading bit in
  441:         the mantissa following IEEE-754.
  442: 
  443:     Parameters
  444:     ----------
  445:     dtype : float, dtype, or instance
  446:         Kind of floating point or complex floating point
  447:         data-type about which to get information.
  448: 
  449:     See Also
  450:     --------
  451:     iinfo : The equivalent for integer data types.
  452:     spacing : The distance between a value and the nearest adjacent number
  453:     nextafter : The next floating point value after x1 towards x2
  454: 
  455:     Notes
  456:     -----
  457:     For developers of NumPy: do not instantiate this at the module level.
  458:     The initial calculation of these parameters is expensive and negatively
  459:     impacts import times.  These objects are cached, so calling ``finfo()``
  460:     repeatedly inside your functions is not a problem.
  461: 
  462:     Note that ``smallest_normal`` is not actually the smallest positive
  463:     representable value in a NumPy floating point type. As in the IEEE-754
  464:     standard [1]_, NumPy floating point types make use of subnormal numbers to
  465:     fill the gap between 0 and ``smallest_normal``. However, subnormal numbers
  466:     may have significantly reduced precision [2]_.
  467: 
  468:     This function can also be used for complex data types as well. If used,
  469:     the output will be the same as the corresponding real float type
  470:     (e.g. numpy.finfo(numpy.csingle) is the same as numpy.finfo(numpy.single)).
  471:     However, the output is true for the real and imaginary components.
  472: 
  473:     References
  474:     ----------
  475:     .. [1] IEEE Standard for Floating-Point Arithmetic, IEEE Std 754-2008,
  476:            pp.1-70, 2008, https://doi.org/10.1109/IEEESTD.2008.4610935
  477:     .. [2] Wikipedia, "Denormal Numbers",
  478:            https://en.wikipedia.org/wiki/Denormal_number
  479: 
  480:     Examples
  481:     --------
  482:     >>> import numpy as np
  483:     >>> np.finfo(np.float64).dtype
  484:     dtype('float64')
  485:     >>> np.finfo(np.complex64).dtype
  486:     dtype('float32')
  487: 
  488:     """
  489: 
  490:     _finfo_cache = {}
  491: 
  492:     __class_getitem__ = classmethod(types.GenericAlias)
  493: 
  494:     def __new__(cls, dtype):
  495:         try:
  496:             obj = cls._finfo_cache.get(dtype)  # most common path
  497:             if obj is not None:
  498:                 return obj
  499:         except TypeError:
  500:             pass
  501: 
  502:         if dtype is None:
  503:             # Deprecated in NumPy 1.25, 2023-01-16
  504:             warnings.warn(
  505:                 "finfo() dtype cannot be None. This behavior will "
  506:                 "raise an error in the future. (Deprecated in NumPy 1.25)",
  507:                 DeprecationWarning,
  508:                 stacklevel=2
  509:             )
  510: 
  511:         try:
  512:             dtype = numeric.dtype(dtype)
  513:         except TypeError:
  514:             # In case a float instance was given
  515:             dtype = numeric.dtype(type(dtype))
  516: 
  517:         obj = cls._finfo_cache.get(dtype)
  518:         if obj is not None:
  519:             return obj
  520:         dtypes = [dtype]
  521:         newdtype = ntypes.obj2sctype(dtype)
  522:         if newdtype is not dtype:
  523:             dtypes.append(newdtype)
  524:             dtype = newdtype
  525:         if not issubclass(dtype, numeric.inexact):
  526:             raise ValueError(f"data type {dtype!r} not inexact")
  527:         obj = cls._finfo_cache.get(dtype)
  528:         if obj is not None:
  529:             return obj
  530:         if not issubclass(dtype, numeric.floating):
  531:             newdtype = _convert_to_float[dtype]
  532:             if newdtype is not dtype:
  533:                 # dtype changed, for example from complex128 to float64
  534:                 dtypes.append(newdtype)
  535:                 dtype = newdtype
  536: 
  537:                 obj = cls._finfo_cache.get(dtype, None)
  538:                 if obj is not None:
  539:                     # the original dtype was not in the cache, but the new
  540:                     # dtype is in the cache. we add the original dtypes to
  541:                     # the cache and return the result
  542:                     for dt in dtypes:
  543:                         cls._finfo_cache[dt] = obj
  544:                     return obj
  545:         obj = object.__new__(cls)._init(dtype)
  546:         for dt in dtypes:
  547:             cls._finfo_cache[dt] = obj
  548:         return obj
  549: 
  550:     def _init(self, dtype):
  551:         self.dtype = numeric.dtype(dtype)
  552:         machar = _get_machar(dtype)
  553: 
  554:         for word in ['precision', 'iexp',
  555:                      'maxexp', 'minexp', 'negep',
  556:                      'machep']:
  557:             setattr(self, word, getattr(machar, word))
  558:         for word in ['resolution', 'epsneg', 'smallest_subnormal']:
  559:             setattr(self, word, getattr(machar, word).flat[0])
  560:         self.bits = self.dtype.itemsize * 8
  561:         self.max = machar.huge.flat[0]
  562:         self.min = -self.max
  563:         self.eps = machar.eps.flat[0]
  564:         self.nexp = machar.iexp
  565:         self.nmant = machar.it
  566:         self._machar = machar
  567:         self._str_tiny = machar._str_xmin.strip()
  568:         self._str_max = machar._str_xmax.strip()
  569:         self._str_epsneg = machar._str_epsneg.strip()
  570:         self._str_eps = machar._str_eps.strip()
  571:         self._str_resolution = machar._str_resolution.strip()
  572:         self._str_smallest_normal = machar._str_smallest_normal.strip()
  573:         self._str_smallest_subnormal = machar._str_smallest_subnormal.strip()
  574:         return self
  575: 
  576:     def __str__(self):
  577:         fmt = (
  578:             'Machine parameters for %(dtype)s\n'
  579:             '---------------------------------------------------------------\n'
  580:             'precision = %(precision)3s   resolution = %(_str_resolution)s\n'
  581:             'machep = %(machep)6s   eps =        %(_str_eps)s\n'
  582:             'negep =  %(negep)6s   epsneg =     %(_str_epsneg)s\n'
  583:             'minexp = %(minexp)6s   tiny =       %(_str_tiny)s\n'
  584:             'maxexp = %(maxexp)6s   max =        %(_str_max)s\n'
  585:             'nexp =   %(nexp)6s   min =        -max\n'
  586:             'smallest_normal = %(_str_smallest_normal)s   '
  587:             'smallest_subnormal = %(_str_smallest_subnormal)s\n'
  588:             '---------------------------------------------------------------\n'
  589:             )
  590:         return fmt % self.__dict__
  591: 
  592:     def __repr__(self):
  593:         c = self.__class__.__name__
  594:         d = self.__dict__.copy()
  595:         d['klass'] = c
  596:         return (("%(klass)s(resolution=%(resolution)s, min=-%(_str_max)s,"
  597:                  " max=%(_str_max)s, dtype=%(dtype)s)") % d)
  598: 
  599:     @property
  600:     def smallest_normal(self):
  601:         """Return the value for the smallest normal.
  602: 
  603:         Returns
  604:         -------
  605:         smallest_normal : float
  606:             Value for the smallest normal.
  607: 
  608:         Warns
  609:         -----
  610:         UserWarning
  611:             If the calculated value for the smallest normal is requested for
  612:             double-double.
  613:         """
  614:         # This check is necessary because the value for smallest_normal is
  615:         # platform dependent for longdouble types.
  616:         if isnan(self._machar.smallest_normal.flat[0]):
  617:             warnings.warn(
  618:                 'The value of smallest normal is undefined for double double',
  619:                 UserWarning, stacklevel=2)
  620:         return self._machar.smallest_normal.flat[0]
  621: 
  622:     @property
  623:     def tiny(self):
  624:         """Return the value for tiny, alias of smallest_normal.
  625: 
  626:         Returns
  627:         -------
  628:         tiny : float
  629:             Value for the smallest normal, alias of smallest_normal.
  630: 
  631:         Warns
  632:         -----
  633:         UserWarning
  634:             If the calculated value for the smallest normal is requested for
  635:             double-double.
  636:         """
  637:         return self.smallest_normal
  638: 
  639: 
  640: @set_module('numpy')
  641: class iinfo:
  642:     """
  643:     iinfo(type)
  644: 
  645:     Machine limits for integer types.
  646: 
  647:     Attributes
  648:     ----------
  649:     bits : int
  650:         The number of bits occupied by the type.
  651:     dtype : dtype
  652:         Returns the dtype for which `iinfo` returns information.
  653:     min : int
  654:         The smallest integer expressible by the type.
  655:     max : int
  656:         The largest integer expressible by the type.
  657: 
  658:     Parameters
  659:     ----------
  660:     int_type : integer type, dtype, or instance
  661:         The kind of integer data type to get information about.
  662: 
  663:     See Also
  664:     --------
  665:     finfo : The equivalent for floating point data types.
  666: 
  667:     Examples
  668:     --------
  669:     With types:
  670: 
  671:     >>> import numpy as np
  672:     >>> ii16 = np.iinfo(np.int16)
  673:     >>> ii16.min
  674:     -32768
  675:     >>> ii16.max
  676:     32767
  677:     >>> ii32 = np.iinfo(np.int32)
  678:     >>> ii32.min
  679:     -2147483648
  680:     >>> ii32.max
  681:     2147483647
  682: 
  683:     With instances:
  684: 
  685:     >>> ii32 = np.iinfo(np.int32(10))
  686:     >>> ii32.min
  687:     -2147483648
  688:     >>> ii32.max
  689:     2147483647
  690: 
  691:     """
  692: 
  693:     _min_vals = {}
  694:     _max_vals = {}
  695: 
  696:     __class_getitem__ = classmethod(types.GenericAlias)
  697: 
  698:     def __init__(self, int_type):
  699:         try:
  700:             self.dtype = numeric.dtype(int_type)
  701:         except TypeError:
  702:             self.dtype = numeric.dtype(type(int_type))
  703:         self.kind = self.dtype.kind
  704:         self.bits = self.dtype.itemsize * 8
  705:         self.key = "%s%d" % (self.kind, self.bits)
  706:         if self.kind not in 'iu':
  707:             raise ValueError(f"Invalid integer data type {self.kind!r}.")
  708: 
  709:     @property
  710:     def min(self):
  711:         """Minimum value of given dtype."""
  712:         if self.kind == 'u':
  713:             return 0
  714:         else:
  715:             try:
  716:                 val = iinfo._min_vals[self.key]
  717:             except KeyError:
  718:                 val = int(-(1 << (self.bits - 1)))
  719:                 iinfo._min_vals[self.key] = val
  720:             return val
  721: 
  722:     @property
  723:     def max(self):
  724:         """Maximum value of given dtype."""
  725:         try:
  726:             val = iinfo._max_vals[self.key]
  727:         except KeyError:
  728:             if self.kind == 'u':
  729:                 val = int((1 << self.bits) - 1)
  730:             else:
  731:                 val = int((1 << (self.bits - 1)) - 1)
  732:             iinfo._max_vals[self.key] = val
  733:         return val
  734: 
  735:     def __str__(self):
  736:         """String representation."""
  737:         fmt = (
  738:             'Machine parameters for %(dtype)s\n'
  739:             '---------------------------------------------------------------\n'
  740:             'min = %(min)s\n'
  741:             'max = %(max)s\n'
  742:             '---------------------------------------------------------------\n'
  743:             )
  744:         return fmt % {'dtype': self.dtype, 'min': self.min, 'max': self.max}
  745: 
  746:     def __repr__(self):
  747:         return "%s(min=%s, max=%s, dtype=%s)" % (self.__class__.__name__,
  748:                                     self.min, self.max, self.dtype)
