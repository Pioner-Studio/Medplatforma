    1: """
    2: A place for internal code
    3: 
    4: Some things are more easily handled Python.
    5: 
    6: """
    7: import ast
    8: import math
    9: import re
   10: import sys
   11: import warnings
   12: 
   13: from numpy import _NoValue
   14: from numpy.exceptions import DTypePromotionError
   15: 
   16: from .multiarray import StringDType, array, dtype, promote_types
   17: 
   18: try:
   19:     import ctypes
   20: except ImportError:
   21:     ctypes = None
   22: 
   23: IS_PYPY = sys.implementation.name == 'pypy'
   24: 
   25: if sys.byteorder == 'little':
   26:     _nbo = '<'
   27: else:
   28:     _nbo = '>'
   29: 
   30: def _makenames_list(adict, align):
   31:     allfields = []
   32: 
   33:     for fname, obj in adict.items():
   34:         n = len(obj)
   35:         if not isinstance(obj, tuple) or n not in (2, 3):
   36:             raise ValueError("entry not a 2- or 3- tuple")
   37:         if n > 2 and obj[2] == fname:
   38:             continue
   39:         num = int(obj[1])
   40:         if num < 0:
   41:             raise ValueError("invalid offset.")
   42:         format = dtype(obj[0], align=align)
   43:         if n > 2:
   44:             title = obj[2]
   45:         else:
   46:             title = None
   47:         allfields.append((fname, format, num, title))
   48:     # sort by offsets
   49:     allfields.sort(key=lambda x: x[2])
   50:     names = [x[0] for x in allfields]
   51:     formats = [x[1] for x in allfields]
   52:     offsets = [x[2] for x in allfields]
   53:     titles = [x[3] for x in allfields]
   54: 
   55:     return names, formats, offsets, titles
   56: 
   57: # Called in PyArray_DescrConverter function when
   58: #  a dictionary without "names" and "formats"
   59: #  fields is used as a data-type descriptor.
   60: def _usefields(adict, align):
   61:     try:
   62:         names = adict[-1]
   63:     except KeyError:
   64:         names = None
   65:     if names is None:
   66:         names, formats, offsets, titles = _makenames_list(adict, align)
   67:     else:
   68:         formats = []
   69:         offsets = []
   70:         titles = []
   71:         for name in names:
   72:             res = adict[name]
   73:             formats.append(res[0])
   74:             offsets.append(res[1])
   75:             if len(res) > 2:
   76:                 titles.append(res[2])
   77:             else:
   78:                 titles.append(None)
   79: 
   80:     return dtype({"names": names,
   81:                   "formats": formats,
   82:                   "offsets": offsets,
   83:                   "titles": titles}, align)
   84: 
   85: 
   86: # construct an array_protocol descriptor list
   87: #  from the fields attribute of a descriptor
   88: # This calls itself recursively but should eventually hit
   89: #  a descriptor that has no fields and then return
   90: #  a simple typestring
   91: 
   92: def _array_descr(descriptor):
   93:     fields = descriptor.fields
   94:     if fields is None:
   95:         subdtype = descriptor.subdtype
   96:         if subdtype is None:
   97:             if descriptor.metadata is None:
   98:                 return descriptor.str
   99:             else:
  100:                 new = descriptor.metadata.copy()
  101:                 if new:
  102:                     return (descriptor.str, new)
  103:                 else:
  104:                     return descriptor.str
  105:         else:
  106:             return (_array_descr(subdtype[0]), subdtype[1])
  107: 
  108:     names = descriptor.names
  109:     ordered_fields = [fields[x] + (x,) for x in names]
  110:     result = []
  111:     offset = 0
  112:     for field in ordered_fields:
  113:         if field[1] > offset:
  114:             num = field[1] - offset
  115:             result.append(('', f'|V{num}'))
  116:             offset += num
  117:         elif field[1] < offset:
  118:             raise ValueError(
  119:                 "dtype.descr is not defined for types with overlapping or "
  120:                 "out-of-order fields")
  121:         if len(field) > 3:
  122:             name = (field[2], field[3])
  123:         else:
  124:             name = field[2]
  125:         if field[0].subdtype:
  126:             tup = (name, _array_descr(field[0].subdtype[0]),
  127:                    field[0].subdtype[1])
  128:         else:
  129:             tup = (name, _array_descr(field[0]))
  130:         offset += field[0].itemsize
  131:         result.append(tup)
  132: 
  133:     if descriptor.itemsize > offset:
  134:         num = descriptor.itemsize - offset
  135:         result.append(('', f'|V{num}'))
  136: 
  137:     return result
  138: 
  139: 
  140: # format_re was originally from numarray by J. Todd Miller
  141: 
  142: format_re = re.compile(r'(?P<order1>[<>|=]?)'
  143:                        r'(?P<repeats> *[(]?[ ,0-9]*[)]? *)'
  144:                        r'(?P<order2>[<>|=]?)'
  145:                        r'(?P<dtype>[A-Za-z0-9.?]*(?:\[[a-zA-Z0-9,.]+\])?)')
  146: sep_re = re.compile(r'\s*,\s*')
  147: space_re = re.compile(r'\s+$')
  148: 
  149: # astr is a string (perhaps comma separated)
  150: 
  151: _convorder = {'=': _nbo}
  152: 
  153: def _commastring(astr):
  154:     startindex = 0
  155:     result = []
  156:     islist = False
  157:     while startindex < len(astr):
  158:         mo = format_re.match(astr, pos=startindex)
  159:         try:
  160:             (order1, repeats, order2, dtype) = mo.groups()
  161:         except (TypeError, AttributeError):
  162:             raise ValueError(
  163:                 f'format number {len(result) + 1} of "{astr}" is not recognized'
  164:                 ) from None
  165:         startindex = mo.end()
  166:         # Separator or ending padding
  167:         if startindex < len(astr):
  168:             if space_re.match(astr, pos=startindex):
  169:                 startindex = len(astr)
  170:             else:
  171:                 mo = sep_re.match(astr, pos=startindex)
  172:                 if not mo:
  173:                     raise ValueError(
  174:                         'format number %d of "%s" is not recognized' %
  175:                         (len(result) + 1, astr))
  176:                 startindex = mo.end()
  177:                 islist = True
  178: 
  179:         if order2 == '':
  180:             order = order1
  181:         elif order1 == '':
  182:             order = order2
  183:         else:
  184:             order1 = _convorder.get(order1, order1)
  185:             order2 = _convorder.get(order2, order2)
  186:             if (order1 != order2):
  187:                 raise ValueError(
  188:                     f'inconsistent byte-order specification {order1} and {order2}')
  189:             order = order1
  190: 
  191:         if order in ('|', '=', _nbo):
  192:             order = ''
  193:         dtype = order + dtype
  194:         if repeats == '':
  195:             newitem = dtype
  196:         else:
  197:             if (repeats[0] == "(" and repeats[-1] == ")"
  198:                     and repeats[1:-1].strip() != ""
  199:                     and "," not in repeats):
  200:                 warnings.warn(
  201:                     'Passing in a parenthesized single number for repeats '
  202:                     'is deprecated; pass either a single number or indicate '
  203:                     'a tuple with a comma, like "(2,)".', DeprecationWarning,
  204:                     stacklevel=2)
  205:             newitem = (dtype, ast.literal_eval(repeats))
  206: 
  207:         result.append(newitem)
  208: 
  209:     return result if islist else result[0]
  210: 
  211: class dummy_ctype:
  212: 
  213:     def __init__(self, cls):
  214:         self._cls = cls
  215: 
  216:     def __mul__(self, other):
  217:         return self
  218: 
  219:     def __call__(self, *other):
  220:         return self._cls(other)
  221: 
  222:     def __eq__(self, other):
  223:         return self._cls == other._cls
  224: 
  225:     def __ne__(self, other):
  226:         return self._cls != other._cls
  227: 
  228: def _getintp_ctype():
  229:     val = _getintp_ctype.cache
  230:     if val is not None:
  231:         return val
  232:     if ctypes is None:
  233:         import numpy as np
  234:         val = dummy_ctype(np.intp)
  235:     else:
  236:         char = dtype('n').char
  237:         if char == 'i':
  238:             val = ctypes.c_int
  239:         elif char == 'l':
  240:             val = ctypes.c_long
  241:         elif char == 'q':
  242:             val = ctypes.c_longlong
  243:         else:
  244:             val = ctypes.c_long
  245:     _getintp_ctype.cache = val
  246:     return val
  247: 
  248: 
  249: _getintp_ctype.cache = None
  250: 
  251: # Used for .ctypes attribute of ndarray
  252: 
  253: class _missing_ctypes:
  254:     def cast(self, num, obj):
  255:         return num.value
  256: 
  257:     class c_void_p:
  258:         def __init__(self, ptr):
  259:             self.value = ptr
  260: 
  261: 
  262: class _ctypes:
  263:     def __init__(self, array, ptr=None):
  264:         self._arr = array
  265: 
  266:         if ctypes:
  267:             self._ctypes = ctypes
  268:             self._data = self._ctypes.c_void_p(ptr)
  269:         else:
  270:             # fake a pointer-like object that holds onto the reference
  271:             self._ctypes = _missing_ctypes()
  272:             self._data = self._ctypes.c_void_p(ptr)
  273:             self._data._objects = array
  274: 
  275:         if self._arr.ndim == 0:
  276:             self._zerod = True
  277:         else:
  278:             self._zerod = False
  279: 
  280:     def data_as(self, obj):
  281:         """
  282:         Return the data pointer cast to a particular c-types object.
  283:         For example, calling ``self._as_parameter_`` is equivalent to
  284:         ``self.data_as(ctypes.c_void_p)``. Perhaps you want to use
  285:         the data as a pointer to a ctypes array of floating-point data:
  286:         ``self.data_as(ctypes.POINTER(ctypes.c_double))``.
  287: 
  288:         The returned pointer will keep a reference to the array.
  289:         """
  290:         # _ctypes.cast function causes a circular reference of self._data in
  291:         # self._data._objects. Attributes of self._data cannot be released
  292:         # until gc.collect is called. Make a copy of the pointer first then
  293:         # let it hold the array reference. This is a workaround to circumvent
  294:         # the CPython bug https://bugs.python.org/issue12836.
  295:         ptr = self._ctypes.cast(self._data, obj)
  296:         ptr._arr = self._arr
  297:         return ptr
  298: 
  299:     def shape_as(self, obj):
  300:         """
  301:         Return the shape tuple as an array of some other c-types
  302:         type. For example: ``self.shape_as(ctypes.c_short)``.
  303:         """
  304:         if self._zerod:
  305:             return None
  306:         return (obj * self._arr.ndim)(*self._arr.shape)
  307: 
  308:     def strides_as(self, obj):
  309:         """
  310:         Return the strides tuple as an array of some other
  311:         c-types type. For example: ``self.strides_as(ctypes.c_longlong)``.
  312:         """
  313:         if self._zerod:
  314:             return None
  315:         return (obj * self._arr.ndim)(*self._arr.strides)
  316: 
  317:     @property
  318:     def data(self):
  319:         """
  320:         A pointer to the memory area of the array as a Python integer.
  321:         This memory area may contain data that is not aligned, or not in
  322:         correct byte-order. The memory area may not even be writeable.
  323:         The array flags and data-type of this array should be respected
  324:         when passing this attribute to arbitrary C-code to avoid trouble
  325:         that can include Python crashing. User Beware! The value of this
  326:         attribute is exactly the same as:
  327:         ``self._array_interface_['data'][0]``.
  328: 
  329:         Note that unlike ``data_as``, a reference won't be kept to the array:
  330:         code like ``ctypes.c_void_p((a + b).ctypes.data)`` will result in a
  331:         pointer to a deallocated array, and should be spelt
  332:         ``(a + b).ctypes.data_as(ctypes.c_void_p)``
  333:         """
  334:         return self._data.value
  335: 
  336:     @property
  337:     def shape(self):
  338:         """
  339:         (c_intp*self.ndim): A ctypes array of length self.ndim where
  340:         the basetype is the C-integer corresponding to ``dtype('p')`` on this
  341:         platform (see `~numpy.ctypeslib.c_intp`). This base-type could be
  342:         `ctypes.c_int`, `ctypes.c_long`, or `ctypes.c_longlong` depending on
  343:         the platform. The ctypes array contains the shape of
  344:         the underlying array.
  345:         """
  346:         return self.shape_as(_getintp_ctype())
  347: 
  348:     @property
  349:     def strides(self):
  350:         """
  351:         (c_intp*self.ndim): A ctypes array of length self.ndim where
  352:         the basetype is the same as for the shape attribute. This ctypes
  353:         array contains the strides information from the underlying array.
  354:         This strides information is important for showing how many bytes
  355:         must be jumped to get to the next element in the array.
  356:         """
  357:         return self.strides_as(_getintp_ctype())
  358: 
  359:     @property
  360:     def _as_parameter_(self):
  361:         """
  362:         Overrides the ctypes semi-magic method
  363: 
  364:         Enables `c_func(some_array.ctypes)`
  365:         """
  366:         return self.data_as(ctypes.c_void_p)
  367: 
  368:     # Numpy 1.21.0, 2021-05-18
  369: 
  370:     def get_data(self):
  371:         """Deprecated getter for the `_ctypes.data` property.
  372: 
  373:         .. deprecated:: 1.21
  374:         """
  375:         warnings.warn('"get_data" is deprecated. Use "data" instead',
  376:                       DeprecationWarning, stacklevel=2)
  377:         return self.data
  378: 
  379:     def get_shape(self):
  380:         """Deprecated getter for the `_ctypes.shape` property.
  381: 
  382:         .. deprecated:: 1.21
  383:         """
  384:         warnings.warn('"get_shape" is deprecated. Use "shape" instead',
  385:                       DeprecationWarning, stacklevel=2)
  386:         return self.shape
  387: 
  388:     def get_strides(self):
  389:         """Deprecated getter for the `_ctypes.strides` property.
  390: 
  391:         .. deprecated:: 1.21
  392:         """
  393:         warnings.warn('"get_strides" is deprecated. Use "strides" instead',
  394:                       DeprecationWarning, stacklevel=2)
  395:         return self.strides
  396: 
  397:     def get_as_parameter(self):
  398:         """Deprecated getter for the `_ctypes._as_parameter_` property.
  399: 
  400:         .. deprecated:: 1.21
  401:         """
  402:         warnings.warn(
  403:             '"get_as_parameter" is deprecated. Use "_as_parameter_" instead',
  404:             DeprecationWarning, stacklevel=2,
  405:         )
  406:         return self._as_parameter_
  407: 
  408: 
  409: def _newnames(datatype, order):
  410:     """
  411:     Given a datatype and an order object, return a new names tuple, with the
  412:     order indicated
  413:     """
  414:     oldnames = datatype.names
  415:     nameslist = list(oldnames)
  416:     if isinstance(order, str):
  417:         order = [order]
  418:     seen = set()
  419:     if isinstance(order, (list, tuple)):
  420:         for name in order:
  421:             try:
  422:                 nameslist.remove(name)
  423:             except ValueError:
  424:                 if name in seen:
  425:                     raise ValueError(f"duplicate field name: {name}") from None
  426:                 else:
  427:                     raise ValueError(f"unknown field name: {name}") from None
  428:             seen.add(name)
  429:         return tuple(list(order) + nameslist)
  430:     raise ValueError(f"unsupported order value: {order}")
  431: 
  432: def _copy_fields(ary):
  433:     """Return copy of structured array with padding between fields removed.
  434: 
  435:     Parameters
  436:     ----------
  437:     ary : ndarray
  438:        Structured array from which to remove padding bytes
  439: 
  440:     Returns
  441:     -------
  442:     ary_copy : ndarray
  443:        Copy of ary with padding bytes removed
  444:     """
  445:     dt = ary.dtype
  446:     copy_dtype = {'names': dt.names,
  447:                   'formats': [dt.fields[name][0] for name in dt.names]}
  448:     return array(ary, dtype=copy_dtype, copy=True)
  449: 
  450: def _promote_fields(dt1, dt2):
  451:     """ Perform type promotion for two structured dtypes.
  452: 
  453:     Parameters
  454:     ----------
  455:     dt1 : structured dtype
  456:         First dtype.
  457:     dt2 : structured dtype
  458:         Second dtype.
  459: 
  460:     Returns
  461:     -------
  462:     out : dtype
  463:         The promoted dtype
  464: 
  465:     Notes
  466:     -----
  467:     If one of the inputs is aligned, the result will be.  The titles of
  468:     both descriptors must match (point to the same field).
  469:     """
  470:     # Both must be structured and have the same names in the same order
  471:     if (dt1.names is None or dt2.names is None) or dt1.names != dt2.names:
  472:         raise DTypePromotionError(
  473:                 f"field names `{dt1.names}` and `{dt2.names}` mismatch.")
  474: 
  475:     # if both are identical, we can (maybe!) just return the same dtype.
  476:     identical = dt1 is dt2
  477:     new_fields = []
  478:     for name in dt1.names:
  479:         field1 = dt1.fields[name]
  480:         field2 = dt2.fields[name]
  481:         new_descr = promote_types(field1[0], field2[0])
  482:         identical = identical and new_descr is field1[0]
  483: 
  484:         # Check that the titles match (if given):
  485:         if field1[2:] != field2[2:]:
  486:             raise DTypePromotionError(
  487:                     f"field titles of field '{name}' mismatch")
  488:         if len(field1) == 2:
  489:             new_fields.append((name, new_descr))
  490:         else:
  491:             new_fields.append(((field1[2], name), new_descr))
  492: 
  493:     res = dtype(new_fields, align=dt1.isalignedstruct or dt2.isalignedstruct)
  494: 
  495:     # Might as well preserve identity (and metadata) if the dtype is identical
  496:     # and the itemsize, offsets are also unmodified.  This could probably be
  497:     # sped up, but also probably just be removed entirely.
  498:     if identical and res.itemsize == dt1.itemsize:
  499:         for name in dt1.names:
  500:             if dt1.fields[name][1] != res.fields[name][1]:
  501:                 return res  # the dtype changed.
  502:         return dt1
  503: 
  504:     return res
  505: 
  506: 
  507: def _getfield_is_safe(oldtype, newtype, offset):
  508:     """ Checks safety of getfield for object arrays.
  509: 
  510:     As in _view_is_safe, we need to check that memory containing objects is not
  511:     reinterpreted as a non-object datatype and vice versa.
  512: 
  513:     Parameters
  514:     ----------
  515:     oldtype : data-type
  516:         Data type of the original ndarray.
  517:     newtype : data-type
  518:         Data type of the field being accessed by ndarray.getfield
  519:     offset : int
  520:         Offset of the field being accessed by ndarray.getfield
  521: 
  522:     Raises
  523:     ------
  524:     TypeError
  525:         If the field access is invalid
  526: 
  527:     """
  528:     if newtype.hasobject or oldtype.hasobject:
  529:         if offset == 0 and newtype == oldtype:
  530:             return
  531:         if oldtype.names is not None:
  532:             for name in oldtype.names:
  533:                 if (oldtype.fields[name][1] == offset and
  534:                         oldtype.fields[name][0] == newtype):
  535:                     return
  536:         raise TypeError("Cannot get/set field of an object array")
  537:     return
  538: 
  539: def _view_is_safe(oldtype, newtype):
  540:     """ Checks safety of a view involving object arrays, for example when
  541:     doing::
  542: 
  543:         np.zeros(10, dtype=oldtype).view(newtype)
  544: 
  545:     Parameters
  546:     ----------
  547:     oldtype : data-type
  548:         Data type of original ndarray
  549:     newtype : data-type
  550:         Data type of the view
  551: 
  552:     Raises
  553:     ------
  554:     TypeError
  555:         If the new type is incompatible with the old type.
  556: 
  557:     """
  558: 
  559:     # if the types are equivalent, there is no problem.
  560:     # for example: dtype((np.record, 'i4,i4')) == dtype((np.void, 'i4,i4'))
  561:     if oldtype == newtype:
  562:         return
  563: 
  564:     if newtype.hasobject or oldtype.hasobject:
  565:         raise TypeError("Cannot change data-type for array of references.")
  566:     return
  567: 
  568: 
  569: # Given a string containing a PEP 3118 format specifier,
  570: # construct a NumPy dtype
  571: 
  572: _pep3118_native_map = {
  573:     '?': '?',
  574:     'c': 'S1',
  575:     'b': 'b',
  576:     'B': 'B',
  577:     'h': 'h',
  578:     'H': 'H',
  579:     'i': 'i',
  580:     'I': 'I',
  581:     'l': 'l',
  582:     'L': 'L',
  583:     'q': 'q',
  584:     'Q': 'Q',
  585:     'e': 'e',
  586:     'f': 'f',
  587:     'd': 'd',
  588:     'g': 'g',
  589:     'Zf': 'F',
  590:     'Zd': 'D',
  591:     'Zg': 'G',
  592:     's': 'S',
  593:     'w': 'U',
  594:     'O': 'O',
  595:     'x': 'V',  # padding
  596: }
  597: _pep3118_native_typechars = ''.join(_pep3118_native_map.keys())
  598: 
  599: _pep3118_standard_map = {
  600:     '?': '?',
  601:     'c': 'S1',
  602:     'b': 'b',
  603:     'B': 'B',
  604:     'h': 'i2',
  605:     'H': 'u2',
  606:     'i': 'i4',
  607:     'I': 'u4',
  608:     'l': 'i4',
  609:     'L': 'u4',
  610:     'q': 'i8',
  611:     'Q': 'u8',
  612:     'e': 'f2',
  613:     'f': 'f',
  614:     'd': 'd',
  615:     'Zf': 'F',
  616:     'Zd': 'D',
  617:     's': 'S',
  618:     'w': 'U',
  619:     'O': 'O',
  620:     'x': 'V',  # padding
  621: }
  622: _pep3118_standard_typechars = ''.join(_pep3118_standard_map.keys())
  623: 
  624: _pep3118_unsupported_map = {
  625:     'u': 'UCS-2 strings',
  626:     '&': 'pointers',
  627:     't': 'bitfields',
  628:     'X': 'function pointers',
  629: }
  630: 
  631: class _Stream:
  632:     def __init__(self, s):
  633:         self.s = s
  634:         self.byteorder = '@'
  635: 
  636:     def advance(self, n):
  637:         res = self.s[:n]
  638:         self.s = self.s[n:]
  639:         return res
  640: 
  641:     def consume(self, c):
  642:         if self.s[:len(c)] == c:
  643:             self.advance(len(c))
  644:             return True
  645:         return False
  646: 
  647:     def consume_until(self, c):
  648:         if callable(c):
  649:             i = 0
  650:             while i < len(self.s) and not c(self.s[i]):
  651:                 i = i + 1
  652:             return self.advance(i)
  653:         else:
  654:             i = self.s.index(c)
  655:             res = self.advance(i)
  656:             self.advance(len(c))
  657:             return res
  658: 
  659:     @property
  660:     def next(self):
  661:         return self.s[0]
  662: 
  663:     def __bool__(self):
  664:         return bool(self.s)
  665: 
  666: 
  667: def _dtype_from_pep3118(spec):
  668:     stream = _Stream(spec)
  669:     dtype, align = __dtype_from_pep3118(stream, is_subdtype=False)
  670:     return dtype
  671: 
  672: def __dtype_from_pep3118(stream, is_subdtype):
  673:     field_spec = {
  674:         'names': [],
  675:         'formats': [],
  676:         'offsets': [],
  677:         'itemsize': 0
  678:     }
  679:     offset = 0
  680:     common_alignment = 1
  681:     is_padding = False
  682: 
  683:     # Parse spec
  684:     while stream:
  685:         value = None
  686: 
  687:         # End of structure, bail out to upper level
  688:         if stream.consume('}'):
  689:             break
  690: 
  691:         # Sub-arrays (1)
  692:         shape = None
  693:         if stream.consume('('):
  694:             shape = stream.consume_until(')')
  695:             shape = tuple(map(int, shape.split(',')))
  696: 
  697:         # Byte order
  698:         if stream.next in ('@', '=', '<', '>', '^', '!'):
  699:             byteorder = stream.advance(1)
  700:             if byteorder == '!':
  701:                 byteorder = '>'
  702:             stream.byteorder = byteorder
  703: 
  704:         # Byte order characters also control native vs. standard type sizes
  705:         if stream.byteorder in ('@', '^'):
  706:             type_map = _pep3118_native_map
  707:             type_map_chars = _pep3118_native_typechars
  708:         else:
  709:             type_map = _pep3118_standard_map
  710:             type_map_chars = _pep3118_standard_typechars
  711: 
  712:         # Item sizes
  713:         itemsize_str = stream.consume_until(lambda c: not c.isdigit())
  714:         if itemsize_str:
  715:             itemsize = int(itemsize_str)
  716:         else:
  717:             itemsize = 1
  718: 
  719:         # Data types
  720:         is_padding = False
  721: 
  722:         if stream.consume('T{'):
  723:             value, align = __dtype_from_pep3118(
  724:                 stream, is_subdtype=True)
  725:         elif stream.next in type_map_chars:
  726:             if stream.next == 'Z':
  727:                 typechar = stream.advance(2)
  728:             else:
  729:                 typechar = stream.advance(1)
  730: 
  731:             is_padding = (typechar == 'x')
  732:             dtypechar = type_map[typechar]
  733:             if dtypechar in 'USV':
  734:                 dtypechar += '%d' % itemsize
  735:                 itemsize = 1
  736:             numpy_byteorder = {'@': '=', '^': '='}.get(
  737:                 stream.byteorder, stream.byteorder)
  738:             value = dtype(numpy_byteorder + dtypechar)
  739:             align = value.alignment
  740:         elif stream.next in _pep3118_unsupported_map:
  741:             desc = _pep3118_unsupported_map[stream.next]
  742:             raise NotImplementedError(
  743:                 f"Unrepresentable PEP 3118 data type {stream.next!r} ({desc})")
  744:         else:
  745:             raise ValueError(
  746:                 f"Unknown PEP 3118 data type specifier {stream.s!r}"
  747:             )
  748: 
  749:         #
  750:         # Native alignment may require padding
  751:         #
  752:         # Here we assume that the presence of a '@' character implicitly
  753:         # implies that the start of the array is *already* aligned.
  754:         #
  755:         extra_offset = 0
  756:         if stream.byteorder == '@':
  757:             start_padding = (-offset) % align
  758:             intra_padding = (-value.itemsize) % align
  759: 
  760:             offset += start_padding
  761: 
  762:             if intra_padding != 0:
  763:                 if itemsize > 1 or (shape is not None and _prod(shape) > 1):
  764:                     # Inject internal padding to the end of the sub-item
  765:                     value = _add_trailing_padding(value, intra_padding)
  766:                 else:
  767:                     # We can postpone the injection of internal padding,
  768:                     # as the item appears at most once
  769:                     extra_offset += intra_padding
  770: 
  771:             # Update common alignment
  772:             common_alignment = _lcm(align, common_alignment)
  773: 
  774:         # Convert itemsize to sub-array
  775:         if itemsize != 1:
  776:             value = dtype((value, (itemsize,)))
  777: 
  778:         # Sub-arrays (2)
  779:         if shape is not None:
  780:             value = dtype((value, shape))
  781: 
  782:         # Field name
  783:         if stream.consume(':'):
  784:             name = stream.consume_until(':')
  785:         else:
  786:             name = None
  787: 
  788:         if not (is_padding and name is None):
  789:             if name is not None and name in field_spec['names']:
  790:                 raise RuntimeError(
  791:                     f"Duplicate field name '{name}' in PEP3118 format"
  792:                 )
  793:             field_spec['names'].append(name)
  794:             field_spec['formats'].append(value)
  795:             field_spec['offsets'].append(offset)
  796: 
  797:         offset += value.itemsize
  798:         offset += extra_offset
  799: 
  800:         field_spec['itemsize'] = offset
  801: 
  802:     # extra final padding for aligned types
  803:     if stream.byteorder == '@':
  804:         field_spec['itemsize'] += (-offset) % common_alignment
  805: 
  806:     # Check if this was a simple 1-item type, and unwrap it
  807:     if (field_spec['names'] == [None]
  808:             and field_spec['offsets'][0] == 0
  809:             and field_spec['itemsize'] == field_spec['formats'][0].itemsize
  810:             and not is_subdtype):
  811:         ret = field_spec['formats'][0]
  812:     else:
  813:         _fix_names(field_spec)
  814:         ret = dtype(field_spec)
  815: 
  816:     # Finished
  817:     return ret, common_alignment
  818: 
  819: def _fix_names(field_spec):
  820:     """ Replace names which are None with the next unused f%d name """
  821:     names = field_spec['names']
  822:     for i, name in enumerate(names):
  823:         if name is not None:
  824:             continue
  825: 
  826:         j = 0
  827:         while True:
  828:             name = f'f{j}'
  829:             if name not in names:
  830:                 break
  831:             j = j + 1
  832:         names[i] = name
  833: 
  834: def _add_trailing_padding(value, padding):
  835:     """Inject the specified number of padding bytes at the end of a dtype"""
  836:     if value.fields is None:
  837:         field_spec = {
  838:             'names': ['f0'],
  839:             'formats': [value],
  840:             'offsets': [0],
  841:             'itemsize': value.itemsize
  842:         }
  843:     else:
  844:         fields = value.fields
  845:         names = value.names
  846:         field_spec = {
  847:             'names': names,
  848:             'formats': [fields[name][0] for name in names],
  849:             'offsets': [fields[name][1] for name in names],
  850:             'itemsize': value.itemsize
  851:         }
  852: 
  853:     field_spec['itemsize'] += padding
  854:     return dtype(field_spec)
  855: 
  856: def _prod(a):
  857:     p = 1
  858:     for x in a:
  859:         p *= x
  860:     return p
  861: 
  862: def _gcd(a, b):
  863:     """Calculate the greatest common divisor of a and b"""
  864:     if not (math.isfinite(a) and math.isfinite(b)):
  865:         raise ValueError('Can only find greatest common divisor of '
  866:                          f'finite arguments, found "{a}" and "{b}"')
  867:     while b:
  868:         a, b = b, a % b
  869:     return a
  870: 
  871: def _lcm(a, b):
  872:     return a // _gcd(a, b) * b
  873: 
  874: def array_ufunc_errmsg_formatter(dummy, ufunc, method, *inputs, **kwargs):
  875:     """ Format the error message for when __array_ufunc__ gives up. """
  876:     args_string = ', '.join([f'{arg!r}' for arg in inputs] +
  877:                             [f'{k}={v!r}'
  878:                              for k, v in kwargs.items()])
  879:     args = inputs + kwargs.get('out', ())
  880:     types_string = ', '.join(repr(type(arg).__name__) for arg in args)
  881:     return ('operand type(s) all returned NotImplemented from '
  882:             f'__array_ufunc__({ufunc!r}, {method!r}, {args_string}): {types_string}'
  883:             )
  884: 
  885: 
  886: def array_function_errmsg_formatter(public_api, types):
  887:     """ Format the error message for when __array_ufunc__ gives up. """
  888:     func_name = f'{public_api.__module__}.{public_api.__name__}'
  889:     return (f"no implementation found for '{func_name}' on types that implement "
  890:             f'__array_function__: {list(types)}')
  891: 
  892: 
  893: def _ufunc_doc_signature_formatter(ufunc):
  894:     """
  895:     Builds a signature string which resembles PEP 457
  896: 
  897:     This is used to construct the first line of the docstring
  898:     """
  899: 
  900:     # input arguments are simple
  901:     if ufunc.nin == 1:
  902:         in_args = 'x'
  903:     else:
  904:         in_args = ', '.join(f'x{i + 1}' for i in range(ufunc.nin))
  905: 
  906:     # output arguments are both keyword or positional
  907:     if ufunc.nout == 0:
  908:         out_args = ', /, out=()'
  909:     elif ufunc.nout == 1:
  910:         out_args = ', /, out=None'
  911:     else:
  912:         out_args = '[, {positional}], / [, out={default}]'.format(
  913:             positional=', '.join(
  914:                 f'out{i + 1}' for i in range(ufunc.nout)),
  915:             default=repr((None,) * ufunc.nout)
  916:         )
  917: 
  918:     # keyword only args depend on whether this is a gufunc
  919:     kwargs = (
  920:         ", casting='same_kind'"
  921:         ", order='K'"
  922:         ", dtype=None"
  923:         ", subok=True"
  924:     )
  925: 
  926:     # NOTE: gufuncs may or may not support the `axis` parameter
  927:     if ufunc.signature is None:
  928:         kwargs = f", where=True{kwargs}[, signature]"
  929:     else:
  930:         kwargs += "[, signature, axes, axis]"
  931: 
  932:     # join all the parts together
  933:     return f'{ufunc.__name__}({in_args}{out_args}, *{kwargs})'
  934: 
  935: 
  936: def npy_ctypes_check(cls):
  937:     # determine if a class comes from ctypes, in order to work around
  938:     # a bug in the buffer protocol for those objects, bpo-10746
  939:     try:
  940:         # ctypes class are new-style, so have an __mro__. This probably fails
  941:         # for ctypes classes with multiple inheritance.
  942:         if IS_PYPY:
  943:             # (..., _ctypes.basics._CData, Bufferable, object)
  944:             ctype_base = cls.__mro__[-3]
  945:         else:
  946:             # # (..., _ctypes._CData, object)
  947:             ctype_base = cls.__mro__[-2]
  948:         # right now, they're part of the _ctypes module
  949:         return '_ctypes' in ctype_base.__module__
  950:     except Exception:
  951:         return False
  952: 
  953: # used to handle the _NoValue default argument for na_object
  954: # in the C implementation of the __reduce__ method for stringdtype
  955: def _convert_to_stringdtype_kwargs(coerce, na_object=_NoValue):
  956:     if na_object is _NoValue:
  957:         return StringDType(coerce=coerce)
  958:     return StringDType(coerce=coerce, na_object=na_object)
