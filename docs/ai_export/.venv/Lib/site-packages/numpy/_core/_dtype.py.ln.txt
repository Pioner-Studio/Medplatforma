    1: """
    2: A place for code to be called from the implementation of np.dtype
    3: 
    4: String handling is much easier to do correctly in python.
    5: """
    6: import numpy as np
    7: 
    8: _kind_to_stem = {
    9:     'u': 'uint',
   10:     'i': 'int',
   11:     'c': 'complex',
   12:     'f': 'float',
   13:     'b': 'bool',
   14:     'V': 'void',
   15:     'O': 'object',
   16:     'M': 'datetime',
   17:     'm': 'timedelta',
   18:     'S': 'bytes',
   19:     'U': 'str',
   20: }
   21: 
   22: 
   23: def _kind_name(dtype):
   24:     try:
   25:         return _kind_to_stem[dtype.kind]
   26:     except KeyError as e:
   27:         raise RuntimeError(
   28:             f"internal dtype error, unknown kind {dtype.kind!r}"
   29:         ) from None
   30: 
   31: 
   32: def __str__(dtype):
   33:     if dtype.fields is not None:
   34:         return _struct_str(dtype, include_align=True)
   35:     elif dtype.subdtype:
   36:         return _subarray_str(dtype)
   37:     elif issubclass(dtype.type, np.flexible) or not dtype.isnative:
   38:         return dtype.str
   39:     else:
   40:         return dtype.name
   41: 
   42: 
   43: def __repr__(dtype):
   44:     arg_str = _construction_repr(dtype, include_align=False)
   45:     if dtype.isalignedstruct:
   46:         arg_str = arg_str + ", align=True"
   47:     return f"dtype({arg_str})"
   48: 
   49: 
   50: def _unpack_field(dtype, offset, title=None):
   51:     """
   52:     Helper function to normalize the items in dtype.fields.
   53: 
   54:     Call as:
   55: 
   56:     dtype, offset, title = _unpack_field(*dtype.fields[name])
   57:     """
   58:     return dtype, offset, title
   59: 
   60: 
   61: def _isunsized(dtype):
   62:     # PyDataType_ISUNSIZED
   63:     return dtype.itemsize == 0
   64: 
   65: 
   66: def _construction_repr(dtype, include_align=False, short=False):
   67:     """
   68:     Creates a string repr of the dtype, excluding the 'dtype()' part
   69:     surrounding the object. This object may be a string, a list, or
   70:     a dict depending on the nature of the dtype. This
   71:     is the object passed as the first parameter to the dtype
   72:     constructor, and if no additional constructor parameters are
   73:     given, will reproduce the exact memory layout.
   74: 
   75:     Parameters
   76:     ----------
   77:     short : bool
   78:         If true, this creates a shorter repr using 'kind' and 'itemsize',
   79:         instead of the longer type name.
   80: 
   81:     include_align : bool
   82:         If true, this includes the 'align=True' parameter
   83:         inside the struct dtype construction dict when needed. Use this flag
   84:         if you want a proper repr string without the 'dtype()' part around it.
   85: 
   86:         If false, this does not preserve the
   87:         'align=True' parameter or sticky NPY_ALIGNED_STRUCT flag for
   88:         struct arrays like the regular repr does, because the 'align'
   89:         flag is not part of first dtype constructor parameter. This
   90:         mode is intended for a full 'repr', where the 'align=True' is
   91:         provided as the second parameter.
   92:     """
   93:     if dtype.fields is not None:
   94:         return _struct_str(dtype, include_align=include_align)
   95:     elif dtype.subdtype:
   96:         return _subarray_str(dtype)
   97:     else:
   98:         return _scalar_str(dtype, short=short)
   99: 
  100: 
  101: def _scalar_str(dtype, short):
  102:     byteorder = _byte_order_str(dtype)
  103: 
  104:     if dtype.type == np.bool:
  105:         if short:
  106:             return "'?'"
  107:         else:
  108:             return "'bool'"
  109: 
  110:     elif dtype.type == np.object_:
  111:         # The object reference may be different sizes on different
  112:         # platforms, so it should never include the itemsize here.
  113:         return "'O'"
  114: 
  115:     elif dtype.type == np.bytes_:
  116:         if _isunsized(dtype):
  117:             return "'S'"
  118:         else:
  119:             return "'S%d'" % dtype.itemsize
  120: 
  121:     elif dtype.type == np.str_:
  122:         if _isunsized(dtype):
  123:             return f"'{byteorder}U'"
  124:         else:
  125:             return "'%sU%d'" % (byteorder, dtype.itemsize / 4)
  126: 
  127:     elif dtype.type == str:
  128:         return "'T'"
  129: 
  130:     elif not type(dtype)._legacy:
  131:         return f"'{byteorder}{type(dtype).__name__}{dtype.itemsize * 8}'"
  132: 
  133:     # unlike the other types, subclasses of void are preserved - but
  134:     # historically the repr does not actually reveal the subclass
  135:     elif issubclass(dtype.type, np.void):
  136:         if _isunsized(dtype):
  137:             return "'V'"
  138:         else:
  139:             return "'V%d'" % dtype.itemsize
  140: 
  141:     elif dtype.type == np.datetime64:
  142:         return f"'{byteorder}M8{_datetime_metadata_str(dtype)}'"
  143: 
  144:     elif dtype.type == np.timedelta64:
  145:         return f"'{byteorder}m8{_datetime_metadata_str(dtype)}'"
  146: 
  147:     elif dtype.isbuiltin == 2:
  148:         return dtype.type.__name__
  149: 
  150:     elif np.issubdtype(dtype, np.number):
  151:         # Short repr with endianness, like '<f8'
  152:         if short or dtype.byteorder not in ('=', '|'):
  153:             return "'%s%c%d'" % (byteorder, dtype.kind, dtype.itemsize)
  154: 
  155:         # Longer repr, like 'float64'
  156:         else:
  157:             return "'%s%d'" % (_kind_name(dtype), 8 * dtype.itemsize)
  158: 
  159:     else:
  160:         raise RuntimeError(
  161:             "Internal error: NumPy dtype unrecognized type number")
  162: 
  163: 
  164: def _byte_order_str(dtype):
  165:     """ Normalize byteorder to '<' or '>' """
  166:     # hack to obtain the native and swapped byte order characters
  167:     swapped = np.dtype(int).newbyteorder('S')
  168:     native = swapped.newbyteorder('S')
  169: 
  170:     byteorder = dtype.byteorder
  171:     if byteorder == '=':
  172:         return native.byteorder
  173:     if byteorder == 'S':
  174:         # TODO: this path can never be reached
  175:         return swapped.byteorder
  176:     elif byteorder == '|':
  177:         return ''
  178:     else:
  179:         return byteorder
  180: 
  181: 
  182: def _datetime_metadata_str(dtype):
  183:     # TODO: this duplicates the C metastr_to_unicode functionality
  184:     unit, count = np.datetime_data(dtype)
  185:     if unit == 'generic':
  186:         return ''
  187:     elif count == 1:
  188:         return f'[{unit}]'
  189:     else:
  190:         return f'[{count}{unit}]'
  191: 
  192: 
  193: def _struct_dict_str(dtype, includealignedflag):
  194:     # unpack the fields dictionary into ls
  195:     names = dtype.names
  196:     fld_dtypes = []
  197:     offsets = []
  198:     titles = []
  199:     for name in names:
  200:         fld_dtype, offset, title = _unpack_field(*dtype.fields[name])
  201:         fld_dtypes.append(fld_dtype)
  202:         offsets.append(offset)
  203:         titles.append(title)
  204: 
  205:     # Build up a string to make the dictionary
  206: 
  207:     if np._core.arrayprint._get_legacy_print_mode() <= 121:
  208:         colon = ":"
  209:         fieldsep = ","
  210:     else:
  211:         colon = ": "
  212:         fieldsep = ", "
  213: 
  214:     # First, the names
  215:     ret = "{'names'%s[" % colon
  216:     ret += fieldsep.join(repr(name) for name in names)
  217: 
  218:     # Second, the formats
  219:     ret += f"], 'formats'{colon}["
  220:     ret += fieldsep.join(
  221:         _construction_repr(fld_dtype, short=True) for fld_dtype in fld_dtypes)
  222: 
  223:     # Third, the offsets
  224:     ret += f"], 'offsets'{colon}["
  225:     ret += fieldsep.join("%d" % offset for offset in offsets)
  226: 
  227:     # Fourth, the titles
  228:     if any(title is not None for title in titles):
  229:         ret += f"], 'titles'{colon}["
  230:         ret += fieldsep.join(repr(title) for title in titles)
  231: 
  232:     # Fifth, the itemsize
  233:     ret += "], 'itemsize'%s%d" % (colon, dtype.itemsize)
  234: 
  235:     if (includealignedflag and dtype.isalignedstruct):
  236:         # Finally, the aligned flag
  237:         ret += ", 'aligned'%sTrue}" % colon
  238:     else:
  239:         ret += "}"
  240: 
  241:     return ret
  242: 
  243: 
  244: def _aligned_offset(offset, alignment):
  245:     # round up offset:
  246:     return - (-offset // alignment) * alignment
  247: 
  248: 
  249: def _is_packed(dtype):
  250:     """
  251:     Checks whether the structured data type in 'dtype'
  252:     has a simple layout, where all the fields are in order,
  253:     and follow each other with no alignment padding.
  254: 
  255:     When this returns true, the dtype can be reconstructed
  256:     from a list of the field names and dtypes with no additional
  257:     dtype parameters.
  258: 
  259:     Duplicates the C `is_dtype_struct_simple_unaligned_layout` function.
  260:     """
  261:     align = dtype.isalignedstruct
  262:     max_alignment = 1
  263:     total_offset = 0
  264:     for name in dtype.names:
  265:         fld_dtype, fld_offset, title = _unpack_field(*dtype.fields[name])
  266: 
  267:         if align:
  268:             total_offset = _aligned_offset(total_offset, fld_dtype.alignment)
  269:             max_alignment = max(max_alignment, fld_dtype.alignment)
  270: 
  271:         if fld_offset != total_offset:
  272:             return False
  273:         total_offset += fld_dtype.itemsize
  274: 
  275:     if align:
  276:         total_offset = _aligned_offset(total_offset, max_alignment)
  277: 
  278:     return total_offset == dtype.itemsize
  279: 
  280: 
  281: def _struct_list_str(dtype):
  282:     items = []
  283:     for name in dtype.names:
  284:         fld_dtype, fld_offset, title = _unpack_field(*dtype.fields[name])
  285: 
  286:         item = "("
  287:         if title is not None:
  288:             item += f"({title!r}, {name!r}), "
  289:         else:
  290:             item += f"{name!r}, "
  291:         # Special case subarray handling here
  292:         if fld_dtype.subdtype is not None:
  293:             base, shape = fld_dtype.subdtype
  294:             item += f"{_construction_repr(base, short=True)}, {shape}"
  295:         else:
  296:             item += _construction_repr(fld_dtype, short=True)
  297: 
  298:         item += ")"
  299:         items.append(item)
  300: 
  301:     return "[" + ", ".join(items) + "]"
  302: 
  303: 
  304: def _struct_str(dtype, include_align):
  305:     # The list str representation can't include the 'align=' flag,
  306:     # so if it is requested and the struct has the aligned flag set,
  307:     # we must use the dict str instead.
  308:     if not (include_align and dtype.isalignedstruct) and _is_packed(dtype):
  309:         sub = _struct_list_str(dtype)
  310: 
  311:     else:
  312:         sub = _struct_dict_str(dtype, include_align)
  313: 
  314:     # If the data type isn't the default, void, show it
  315:     if dtype.type != np.void:
  316:         return f"({dtype.type.__module__}.{dtype.type.__name__}, {sub})"
  317:     else:
  318:         return sub
  319: 
  320: 
  321: def _subarray_str(dtype):
  322:     base, shape = dtype.subdtype
  323:     return f"({_construction_repr(base, short=True)}, {shape})"
  324: 
  325: 
  326: def _name_includes_bit_suffix(dtype):
  327:     if dtype.type == np.object_:
  328:         # pointer size varies by system, best to omit it
  329:         return False
  330:     elif dtype.type == np.bool:
  331:         # implied
  332:         return False
  333:     elif dtype.type is None:
  334:         return True
  335:     elif np.issubdtype(dtype, np.flexible) and _isunsized(dtype):
  336:         # unspecified
  337:         return False
  338:     else:
  339:         return True
  340: 
  341: 
  342: def _name_get(dtype):
  343:     # provides dtype.name.__get__, documented as returning a "bit name"
  344: 
  345:     if dtype.isbuiltin == 2:
  346:         # user dtypes don't promise to do anything special
  347:         return dtype.type.__name__
  348: 
  349:     if not type(dtype)._legacy:
  350:         name = type(dtype).__name__
  351: 
  352:     elif issubclass(dtype.type, np.void):
  353:         # historically, void subclasses preserve their name, eg `record64`
  354:         name = dtype.type.__name__
  355:     else:
  356:         name = _kind_name(dtype)
  357: 
  358:     # append bit counts
  359:     if _name_includes_bit_suffix(dtype):
  360:         name += f"{dtype.itemsize * 8}"
  361: 
  362:     # append metadata to datetimes
  363:     if dtype.type in (np.datetime64, np.timedelta64):
  364:         name += _datetime_metadata_str(dtype)
  365: 
  366:     return name
