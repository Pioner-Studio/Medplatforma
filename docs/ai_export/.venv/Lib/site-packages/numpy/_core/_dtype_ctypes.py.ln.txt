    1: """
    2: Conversion from ctypes to dtype.
    3: 
    4: In an ideal world, we could achieve this through the PEP3118 buffer protocol,
    5: something like::
    6: 
    7:     def dtype_from_ctypes_type(t):
    8:         # needed to ensure that the shape of `t` is within memoryview.format
    9:         class DummyStruct(ctypes.Structure):
   10:             _fields_ = [('a', t)]
   11: 
   12:         # empty to avoid memory allocation
   13:         ctype_0 = (DummyStruct * 0)()
   14:         mv = memoryview(ctype_0)
   15: 
   16:         # convert the struct, and slice back out the field
   17:         return _dtype_from_pep3118(mv.format)['a']
   18: 
   19: Unfortunately, this fails because:
   20: 
   21: * ctypes cannot handle length-0 arrays with PEP3118 (bpo-32782)
   22: * PEP3118 cannot represent unions, but both numpy and ctypes can
   23: * ctypes cannot handle big-endian structs with PEP3118 (bpo-32780)
   24: """
   25: 
   26: # We delay-import ctypes for distributions that do not include it.
   27: # While this module is not used unless the user passes in ctypes
   28: # members, it is eagerly imported from numpy/_core/__init__.py.
   29: import numpy as np
   30: 
   31: 
   32: def _from_ctypes_array(t):
   33:     return np.dtype((dtype_from_ctypes_type(t._type_), (t._length_,)))
   34: 
   35: 
   36: def _from_ctypes_structure(t):
   37:     for item in t._fields_:
   38:         if len(item) > 2:
   39:             raise TypeError(
   40:                 "ctypes bitfields have no dtype equivalent")
   41: 
   42:     if hasattr(t, "_pack_"):
   43:         import ctypes
   44:         formats = []
   45:         offsets = []
   46:         names = []
   47:         current_offset = 0
   48:         for fname, ftyp in t._fields_:
   49:             names.append(fname)
   50:             formats.append(dtype_from_ctypes_type(ftyp))
   51:             # Each type has a default offset, this is platform dependent
   52:             # for some types.
   53:             effective_pack = min(t._pack_, ctypes.alignment(ftyp))
   54:             current_offset = (
   55:                 (current_offset + effective_pack - 1) // effective_pack
   56:             ) * effective_pack
   57:             offsets.append(current_offset)
   58:             current_offset += ctypes.sizeof(ftyp)
   59: 
   60:         return np.dtype({
   61:             "formats": formats,
   62:             "offsets": offsets,
   63:             "names": names,
   64:             "itemsize": ctypes.sizeof(t)})
   65:     else:
   66:         fields = []
   67:         for fname, ftyp in t._fields_:
   68:             fields.append((fname, dtype_from_ctypes_type(ftyp)))
   69: 
   70:         # by default, ctypes structs are aligned
   71:         return np.dtype(fields, align=True)
   72: 
   73: 
   74: def _from_ctypes_scalar(t):
   75:     """
   76:     Return the dtype type with endianness included if it's the case
   77:     """
   78:     if getattr(t, '__ctype_be__', None) is t:
   79:         return np.dtype('>' + t._type_)
   80:     elif getattr(t, '__ctype_le__', None) is t:
   81:         return np.dtype('<' + t._type_)
   82:     else:
   83:         return np.dtype(t._type_)
   84: 
   85: 
   86: def _from_ctypes_union(t):
   87:     import ctypes
   88:     formats = []
   89:     offsets = []
   90:     names = []
   91:     for fname, ftyp in t._fields_:
   92:         names.append(fname)
   93:         formats.append(dtype_from_ctypes_type(ftyp))
   94:         offsets.append(0)  # Union fields are offset to 0
   95: 
   96:     return np.dtype({
   97:         "formats": formats,
   98:         "offsets": offsets,
   99:         "names": names,
  100:         "itemsize": ctypes.sizeof(t)})
  101: 
  102: 
  103: def dtype_from_ctypes_type(t):
  104:     """
  105:     Construct a dtype object from a ctypes type
  106:     """
  107:     import _ctypes
  108:     if issubclass(t, _ctypes.Array):
  109:         return _from_ctypes_array(t)
  110:     elif issubclass(t, _ctypes._Pointer):
  111:         raise TypeError("ctypes pointers have no dtype equivalent")
  112:     elif issubclass(t, _ctypes.Structure):
  113:         return _from_ctypes_structure(t)
  114:     elif issubclass(t, _ctypes.Union):
  115:         return _from_ctypes_union(t)
  116:     elif isinstance(getattr(t, '_type_', None), str):
  117:         return _from_ctypes_scalar(t)
  118:     else:
  119:         raise NotImplementedError(
  120:             f"Unknown ctypes type {t.__name__}")
