    1: """Array printing function
    2: 
    3: $Id: arrayprint.py,v 1.9 2005/09/13 13:58:44 teoliphant Exp $
    4: 
    5: """
    6: __all__ = ["array2string", "array_str", "array_repr",
    7:            "set_printoptions", "get_printoptions", "printoptions",
    8:            "format_float_positional", "format_float_scientific"]
    9: __docformat__ = 'restructuredtext'
   10: 
   11: #
   12: # Written by Konrad Hinsen <hinsenk@ere.umontreal.ca>
   13: # last revision: 1996-3-13
   14: # modified by Jim Hugunin 1997-3-3 for repr's and str's (and other details)
   15: # and by Perry Greenfield 2000-4-1 for numarray
   16: # and by Travis Oliphant  2005-8-22 for numpy
   17: 
   18: 
   19: # Note: Both scalartypes.c.src and arrayprint.py implement strs for numpy
   20: # scalars but for different purposes. scalartypes.c.src has str/reprs for when
   21: # the scalar is printed on its own, while arrayprint.py has strs for when
   22: # scalars are printed inside an ndarray. Only the latter strs are currently
   23: # user-customizable.
   24: 
   25: import functools
   26: import numbers
   27: import sys
   28: 
   29: try:
   30:     from _thread import get_ident
   31: except ImportError:
   32:     from _dummy_thread import get_ident
   33: 
   34: import contextlib
   35: import operator
   36: import warnings
   37: 
   38: import numpy as np
   39: 
   40: from . import numerictypes as _nt
   41: from .fromnumeric import any
   42: from .multiarray import (
   43:     array,
   44:     datetime_as_string,
   45:     datetime_data,
   46:     dragon4_positional,
   47:     dragon4_scientific,
   48:     ndarray,
   49: )
   50: from .numeric import asarray, concatenate, errstate
   51: from .numerictypes import complex128, flexible, float64, int_
   52: from .overrides import array_function_dispatch, set_module
   53: from .printoptions import format_options
   54: from .umath import absolute, isfinite, isinf, isnat
   55: 
   56: 
   57: def _make_options_dict(precision=None, threshold=None, edgeitems=None,
   58:                        linewidth=None, suppress=None, nanstr=None, infstr=None,
   59:                        sign=None, formatter=None, floatmode=None, legacy=None,
   60:                        override_repr=None):
   61:     """
   62:     Make a dictionary out of the non-None arguments, plus conversion of
   63:     *legacy* and sanity checks.
   64:     """
   65: 
   66:     options = {k: v for k, v in list(locals().items()) if v is not None}
   67: 
   68:     if suppress is not None:
   69:         options['suppress'] = bool(suppress)
   70: 
   71:     modes = ['fixed', 'unique', 'maxprec', 'maxprec_equal']
   72:     if floatmode not in modes + [None]:
   73:         raise ValueError("floatmode option must be one of " +
   74:                          ", ".join(f'"{m}"' for m in modes))
   75: 
   76:     if sign not in [None, '-', '+', ' ']:
   77:         raise ValueError("sign option must be one of ' ', '+', or '-'")
   78: 
   79:     if legacy is False:
   80:         options['legacy'] = sys.maxsize
   81:     elif legacy == False:  # noqa: E712
   82:         warnings.warn(
   83:             f"Passing `legacy={legacy!r}` is deprecated.",
   84:             FutureWarning, stacklevel=3
   85:         )
   86:         options['legacy'] = sys.maxsize
   87:     elif legacy == '1.13':
   88:         options['legacy'] = 113
   89:     elif legacy == '1.21':
   90:         options['legacy'] = 121
   91:     elif legacy == '1.25':
   92:         options['legacy'] = 125
   93:     elif legacy == '2.1':
   94:         options['legacy'] = 201
   95:     elif legacy == '2.2':
   96:         options['legacy'] = 202
   97:     elif legacy is None:
   98:         pass  # OK, do nothing.
   99:     else:
  100:         warnings.warn(
  101:             "legacy printing option can currently only be '1.13', '1.21', "
  102:             "'1.25', '2.1', '2.2' or `False`", stacklevel=3)
  103: 
  104:     if threshold is not None:
  105:         # forbid the bad threshold arg suggested by stack overflow, gh-12351
  106:         if not isinstance(threshold, numbers.Number):
  107:             raise TypeError("threshold must be numeric")
  108:         if np.isnan(threshold):
  109:             raise ValueError("threshold must be non-NAN, try "
  110:                              "sys.maxsize for untruncated representation")
  111: 
  112:     if precision is not None:
  113:         # forbid the bad precision arg as suggested by issue #18254
  114:         try:
  115:             options['precision'] = operator.index(precision)
  116:         except TypeError as e:
  117:             raise TypeError('precision must be an integer') from e
  118: 
  119:     return options
  120: 
  121: 
  122: @set_module('numpy')
  123: def set_printoptions(precision=None, threshold=None, edgeitems=None,
  124:                      linewidth=None, suppress=None, nanstr=None,
  125:                      infstr=None, formatter=None, sign=None, floatmode=None,
  126:                      *, legacy=None, override_repr=None):
  127:     """
  128:     Set printing options.
  129: 
  130:     These options determine the way floating point numbers, arrays and
  131:     other NumPy objects are displayed.
  132: 
  133:     Parameters
  134:     ----------
  135:     precision : int or None, optional
  136:         Number of digits of precision for floating point output (default 8).
  137:         May be None if `floatmode` is not `fixed`, to print as many digits as
  138:         necessary to uniquely specify the value.
  139:     threshold : int, optional
  140:         Total number of array elements which trigger summarization
  141:         rather than full repr (default 1000).
  142:         To always use the full repr without summarization, pass `sys.maxsize`.
  143:     edgeitems : int, optional
  144:         Number of array items in summary at beginning and end of
  145:         each dimension (default 3).
  146:     linewidth : int, optional
  147:         The number of characters per line for the purpose of inserting
  148:         line breaks (default 75).
  149:     suppress : bool, optional
  150:         If True, always print floating point numbers using fixed point
  151:         notation, in which case numbers equal to zero in the current precision
  152:         will print as zero.  If False, then scientific notation is used when
  153:         absolute value of the smallest number is < 1e-4 or the ratio of the
  154:         maximum absolute value to the minimum is > 1e3. The default is False.
  155:     nanstr : str, optional
  156:         String representation of floating point not-a-number (default nan).
  157:     infstr : str, optional
  158:         String representation of floating point infinity (default inf).
  159:     sign : string, either '-', '+', or ' ', optional
  160:         Controls printing of the sign of floating-point types. If '+', always
  161:         print the sign of positive values. If ' ', always prints a space
  162:         (whitespace character) in the sign position of positive values.  If
  163:         '-', omit the sign character of positive values. (default '-')
  164: 
  165:         .. versionchanged:: 2.0
  166:              The sign parameter can now be an integer type, previously
  167:              types were floating-point types.
  168: 
  169:     formatter : dict of callables, optional
  170:         If not None, the keys should indicate the type(s) that the respective
  171:         formatting function applies to.  Callables should return a string.
  172:         Types that are not specified (by their corresponding keys) are handled
  173:         by the default formatters.  Individual types for which a formatter
  174:         can be set are:
  175: 
  176:         - 'bool'
  177:         - 'int'
  178:         - 'timedelta' : a `numpy.timedelta64`
  179:         - 'datetime' : a `numpy.datetime64`
  180:         - 'float'
  181:         - 'longfloat' : 128-bit floats
  182:         - 'complexfloat'
  183:         - 'longcomplexfloat' : composed of two 128-bit floats
  184:         - 'numpystr' : types `numpy.bytes_` and `numpy.str_`
  185:         - 'object' : `np.object_` arrays
  186: 
  187:         Other keys that can be used to set a group of types at once are:
  188: 
  189:         - 'all' : sets all types
  190:         - 'int_kind' : sets 'int'
  191:         - 'float_kind' : sets 'float' and 'longfloat'
  192:         - 'complex_kind' : sets 'complexfloat' and 'longcomplexfloat'
  193:         - 'str_kind' : sets 'numpystr'
  194:     floatmode : str, optional
  195:         Controls the interpretation of the `precision` option for
  196:         floating-point types. Can take the following values
  197:         (default maxprec_equal):
  198: 
  199:         * 'fixed': Always print exactly `precision` fractional digits,
  200:                 even if this would print more or fewer digits than
  201:                 necessary to specify the value uniquely.
  202:         * 'unique': Print the minimum number of fractional digits necessary
  203:                 to represent each value uniquely. Different elements may
  204:                 have a different number of digits. The value of the
  205:                 `precision` option is ignored.
  206:         * 'maxprec': Print at most `precision` fractional digits, but if
  207:                 an element can be uniquely represented with fewer digits
  208:                 only print it with that many.
  209:         * 'maxprec_equal': Print at most `precision` fractional digits,
  210:                 but if every element in the array can be uniquely
  211:                 represented with an equal number of fewer digits, use that
  212:                 many digits for all elements.
  213:     legacy : string or `False`, optional
  214:         If set to the string ``'1.13'`` enables 1.13 legacy printing mode. This
  215:         approximates numpy 1.13 print output by including a space in the sign
  216:         position of floats and different behavior for 0d arrays. This also
  217:         enables 1.21 legacy printing mode (described below).
  218: 
  219:         If set to the string ``'1.21'`` enables 1.21 legacy printing mode. This
  220:         approximates numpy 1.21 print output of complex structured dtypes
  221:         by not inserting spaces after commas that separate fields and after
  222:         colons.
  223: 
  224:         If set to ``'1.25'`` approximates printing of 1.25 which mainly means
  225:         that numeric scalars are printed without their type information, e.g.
  226:         as ``3.0`` rather than ``np.float64(3.0)``.
  227: 
  228:         If set to ``'2.1'``, shape information is not given when arrays are
  229:         summarized (i.e., multiple elements replaced with ``...``).
  230: 
  231:         If set to ``'2.2'``, the transition to use scientific notation for
  232:         printing ``np.float16`` and ``np.float32`` types may happen later or
  233:         not at all for larger values.
  234: 
  235:         If set to `False`, disables legacy mode.
  236: 
  237:         Unrecognized strings will be ignored with a warning for forward
  238:         compatibility.
  239: 
  240:         .. versionchanged:: 1.22.0
  241:         .. versionchanged:: 2.2
  242: 
  243:     override_repr: callable, optional
  244:         If set a passed function will be used for generating arrays' repr.
  245:         Other options will be ignored.
  246: 
  247:     See Also
  248:     --------
  249:     get_printoptions, printoptions, array2string
  250: 
  251:     Notes
  252:     -----
  253:     `formatter` is always reset with a call to `set_printoptions`.
  254: 
  255:     Use `printoptions` as a context manager to set the values temporarily.
  256: 
  257:     Examples
  258:     --------
  259:     Floating point precision can be set:
  260: 
  261:     >>> import numpy as np
  262:     >>> np.set_printoptions(precision=4)
  263:     >>> np.array([1.123456789])
  264:     [1.1235]
  265: 
  266:     Long arrays can be summarised:
  267: 
  268:     >>> np.set_printoptions(threshold=5)
  269:     >>> np.arange(10)
  270:     array([0, 1, 2, ..., 7, 8, 9], shape=(10,))
  271: 
  272:     Small results can be suppressed:
  273: 
  274:     >>> eps = np.finfo(float).eps
  275:     >>> x = np.arange(4.)
  276:     >>> x**2 - (x + eps)**2
  277:     array([-4.9304e-32, -4.4409e-16,  0.0000e+00,  0.0000e+00])
  278:     >>> np.set_printoptions(suppress=True)
  279:     >>> x**2 - (x + eps)**2
  280:     array([-0., -0.,  0.,  0.])
  281: 
  282:     A custom formatter can be used to display array elements as desired:
  283: 
  284:     >>> np.set_printoptions(formatter={'all':lambda x: 'int: '+str(-x)})
  285:     >>> x = np.arange(3)
  286:     >>> x
  287:     array([int: 0, int: -1, int: -2])
  288:     >>> np.set_printoptions()  # formatter gets reset
  289:     >>> x
  290:     array([0, 1, 2])
  291: 
  292:     To put back the default options, you can use:
  293: 
  294:     >>> np.set_printoptions(edgeitems=3, infstr='inf',
  295:     ... linewidth=75, nanstr='nan', precision=8,
  296:     ... suppress=False, threshold=1000, formatter=None)
  297: 
  298:     Also to temporarily override options, use `printoptions`
  299:     as a context manager:
  300: 
  301:     >>> with np.printoptions(precision=2, suppress=True, threshold=5):
  302:     ...     np.linspace(0, 10, 10)
  303:     array([ 0.  ,  1.11,  2.22, ...,  7.78,  8.89, 10.  ], shape=(10,))
  304: 
  305:     """
  306:     _set_printoptions(precision, threshold, edgeitems, linewidth, suppress,
  307:                       nanstr, infstr, formatter, sign, floatmode,
  308:                       legacy=legacy, override_repr=override_repr)
  309: 
  310: 
  311: def _set_printoptions(precision=None, threshold=None, edgeitems=None,
  312:                       linewidth=None, suppress=None, nanstr=None,
  313:                       infstr=None, formatter=None, sign=None, floatmode=None,
  314:                       *, legacy=None, override_repr=None):
  315:     new_opt = _make_options_dict(precision, threshold, edgeitems, linewidth,
  316:                                  suppress, nanstr, infstr, sign, formatter,
  317:                                  floatmode, legacy)
  318:     # formatter and override_repr are always reset
  319:     new_opt['formatter'] = formatter
  320:     new_opt['override_repr'] = override_repr
  321: 
  322:     updated_opt = format_options.get() | new_opt
  323:     updated_opt.update(new_opt)
  324: 
  325:     if updated_opt['legacy'] == 113:
  326:         updated_opt['sign'] = '-'
  327: 
  328:     return format_options.set(updated_opt)
  329: 
  330: 
  331: @set_module('numpy')
  332: def get_printoptions():
  333:     """
  334:     Return the current print options.
  335: 
  336:     Returns
  337:     -------
  338:     print_opts : dict
  339:         Dictionary of current print options with keys
  340: 
  341:         - precision : int
  342:         - threshold : int
  343:         - edgeitems : int
  344:         - linewidth : int
  345:         - suppress : bool
  346:         - nanstr : str
  347:         - infstr : str
  348:         - sign : str
  349:         - formatter : dict of callables
  350:         - floatmode : str
  351:         - legacy : str or False
  352: 
  353:         For a full description of these options, see `set_printoptions`.
  354: 
  355:     See Also
  356:     --------
  357:     set_printoptions, printoptions
  358: 
  359:     Examples
  360:     --------
  361:     >>> import numpy as np
  362: 
  363:     >>> np.get_printoptions()
  364:     {'edgeitems': 3, 'threshold': 1000, ..., 'override_repr': None}
  365: 
  366:     >>> np.get_printoptions()['linewidth']
  367:     75
  368:     >>> np.set_printoptions(linewidth=100)
  369:     >>> np.get_printoptions()['linewidth']
  370:     100
  371: 
  372:     """
  373:     opts = format_options.get().copy()
  374:     opts['legacy'] = {
  375:         113: '1.13', 121: '1.21', 125: '1.25', 201: '2.1',
  376:         202: '2.2', sys.maxsize: False,
  377:     }[opts['legacy']]
  378:     return opts
  379: 
  380: 
  381: def _get_legacy_print_mode():
  382:     """Return the legacy print mode as an int."""
  383:     return format_options.get()['legacy']
  384: 
  385: 
  386: @set_module('numpy')
  387: @contextlib.contextmanager
  388: def printoptions(*args, **kwargs):
  389:     """Context manager for setting print options.
  390: 
  391:     Set print options for the scope of the `with` block, and restore the old
  392:     options at the end. See `set_printoptions` for the full description of
  393:     available options.
  394: 
  395:     Examples
  396:     --------
  397:     >>> import numpy as np
  398: 
  399:     >>> from numpy.testing import assert_equal
  400:     >>> with np.printoptions(precision=2):
  401:     ...     np.array([2.0]) / 3
  402:     array([0.67])
  403: 
  404:     The `as`-clause of the `with`-statement gives the current print options:
  405: 
  406:     >>> with np.printoptions(precision=2) as opts:
  407:     ...      assert_equal(opts, np.get_printoptions())
  408: 
  409:     See Also
  410:     --------
  411:     set_printoptions, get_printoptions
  412: 
  413:     """
  414:     token = _set_printoptions(*args, **kwargs)
  415: 
  416:     try:
  417:         yield get_printoptions()
  418:     finally:
  419:         format_options.reset(token)
  420: 
  421: 
  422: def _leading_trailing(a, edgeitems, index=()):
  423:     """
  424:     Keep only the N-D corners (leading and trailing edges) of an array.
  425: 
  426:     Should be passed a base-class ndarray, since it makes no guarantees about
  427:     preserving subclasses.
  428:     """
  429:     axis = len(index)
  430:     if axis == a.ndim:
  431:         return a[index]
  432: 
  433:     if a.shape[axis] > 2 * edgeitems:
  434:         return concatenate((
  435:             _leading_trailing(a, edgeitems, index + np.index_exp[:edgeitems]),
  436:             _leading_trailing(a, edgeitems, index + np.index_exp[-edgeitems:])
  437:         ), axis=axis)
  438:     else:
  439:         return _leading_trailing(a, edgeitems, index + np.index_exp[:])
  440: 
  441: 
  442: def _object_format(o):
  443:     """ Object arrays containing lists should be printed unambiguously """
  444:     if type(o) is list:
  445:         fmt = 'list({!r})'
  446:     else:
  447:         fmt = '{!r}'
  448:     return fmt.format(o)
  449: 
  450: def repr_format(x):
  451:     if isinstance(x, (np.str_, np.bytes_)):
  452:         return repr(x.item())
  453:     return repr(x)
  454: 
  455: def str_format(x):
  456:     if isinstance(x, (np.str_, np.bytes_)):
  457:         return str(x.item())
  458:     return str(x)
  459: 
  460: def _get_formatdict(data, *, precision, floatmode, suppress, sign, legacy,
  461:                     formatter, **kwargs):
  462:     # note: extra arguments in kwargs are ignored
  463: 
  464:     # wrapped in lambdas to avoid taking a code path
  465:     # with the wrong type of data
  466:     formatdict = {
  467:         'bool': lambda: BoolFormat(data),
  468:         'int': lambda: IntegerFormat(data, sign),
  469:         'float': lambda: FloatingFormat(
  470:             data, precision, floatmode, suppress, sign, legacy=legacy),
  471:         'longfloat': lambda: FloatingFormat(
  472:             data, precision, floatmode, suppress, sign, legacy=legacy),
  473:         'complexfloat': lambda: ComplexFloatingFormat(
  474:             data, precision, floatmode, suppress, sign, legacy=legacy),
  475:         'longcomplexfloat': lambda: ComplexFloatingFormat(
  476:             data, precision, floatmode, suppress, sign, legacy=legacy),
  477:         'datetime': lambda: DatetimeFormat(data, legacy=legacy),
  478:         'timedelta': lambda: TimedeltaFormat(data),
  479:         'object': lambda: _object_format,
  480:         'void': lambda: str_format,
  481:         'numpystr': lambda: repr_format}
  482: 
  483:     # we need to wrap values in `formatter` in a lambda, so that the interface
  484:     # is the same as the above values.
  485:     def indirect(x):
  486:         return lambda: x
  487: 
  488:     if formatter is not None:
  489:         fkeys = [k for k in formatter.keys() if formatter[k] is not None]
  490:         if 'all' in fkeys:
  491:             for key in formatdict.keys():
  492:                 formatdict[key] = indirect(formatter['all'])
  493:         if 'int_kind' in fkeys:
  494:             for key in ['int']:
  495:                 formatdict[key] = indirect(formatter['int_kind'])
  496:         if 'float_kind' in fkeys:
  497:             for key in ['float', 'longfloat']:
  498:                 formatdict[key] = indirect(formatter['float_kind'])
  499:         if 'complex_kind' in fkeys:
  500:             for key in ['complexfloat', 'longcomplexfloat']:
  501:                 formatdict[key] = indirect(formatter['complex_kind'])
  502:         if 'str_kind' in fkeys:
  503:             formatdict['numpystr'] = indirect(formatter['str_kind'])
  504:         for key in formatdict.keys():
  505:             if key in fkeys:
  506:                 formatdict[key] = indirect(formatter[key])
  507: 
  508:     return formatdict
  509: 
  510: def _get_format_function(data, **options):
  511:     """
  512:     find the right formatting function for the dtype_
  513:     """
  514:     dtype_ = data.dtype
  515:     dtypeobj = dtype_.type
  516:     formatdict = _get_formatdict(data, **options)
  517:     if dtypeobj is None:
  518:         return formatdict["numpystr"]()
  519:     elif issubclass(dtypeobj, _nt.bool):
  520:         return formatdict['bool']()
  521:     elif issubclass(dtypeobj, _nt.integer):
  522:         if issubclass(dtypeobj, _nt.timedelta64):
  523:             return formatdict['timedelta']()
  524:         else:
  525:             return formatdict['int']()
  526:     elif issubclass(dtypeobj, _nt.floating):
  527:         if issubclass(dtypeobj, _nt.longdouble):
  528:             return formatdict['longfloat']()
  529:         else:
  530:             return formatdict['float']()
  531:     elif issubclass(dtypeobj, _nt.complexfloating):
  532:         if issubclass(dtypeobj, _nt.clongdouble):
  533:             return formatdict['longcomplexfloat']()
  534:         else:
  535:             return formatdict['complexfloat']()
  536:     elif issubclass(dtypeobj, (_nt.str_, _nt.bytes_)):
  537:         return formatdict['numpystr']()
  538:     elif issubclass(dtypeobj, _nt.datetime64):
  539:         return formatdict['datetime']()
  540:     elif issubclass(dtypeobj, _nt.object_):
  541:         return formatdict['object']()
  542:     elif issubclass(dtypeobj, _nt.void):
  543:         if dtype_.names is not None:
  544:             return StructuredVoidFormat.from_data(data, **options)
  545:         else:
  546:             return formatdict['void']()
  547:     else:
  548:         return formatdict['numpystr']()
  549: 
  550: 
  551: def _recursive_guard(fillvalue='...'):
  552:     """
  553:     Like the python 3.2 reprlib.recursive_repr, but forwards *args and **kwargs
  554: 
  555:     Decorates a function such that if it calls itself with the same first
  556:     argument, it returns `fillvalue` instead of recursing.
  557: 
  558:     Largely copied from reprlib.recursive_repr
  559:     """
  560: 
  561:     def decorating_function(f):
  562:         repr_running = set()
  563: 
  564:         @functools.wraps(f)
  565:         def wrapper(self, *args, **kwargs):
  566:             key = id(self), get_ident()
  567:             if key in repr_running:
  568:                 return fillvalue
  569:             repr_running.add(key)
  570:             try:
  571:                 return f(self, *args, **kwargs)
  572:             finally:
  573:                 repr_running.discard(key)
  574: 
  575:         return wrapper
  576: 
  577:     return decorating_function
  578: 
  579: 
  580: # gracefully handle recursive calls, when object arrays contain themselves
  581: @_recursive_guard()
  582: def _array2string(a, options, separator=' ', prefix=""):
  583:     # The formatter __init__s in _get_format_function cannot deal with
  584:     # subclasses yet, and we also need to avoid recursion issues in
  585:     # _formatArray with subclasses which return 0d arrays in place of scalars
  586:     data = asarray(a)
  587:     if a.shape == ():
  588:         a = data
  589: 
  590:     if a.size > options['threshold']:
  591:         summary_insert = "..."
  592:         data = _leading_trailing(data, options['edgeitems'])
  593:     else:
  594:         summary_insert = ""
  595: 
  596:     # find the right formatting function for the array
  597:     format_function = _get_format_function(data, **options)
  598: 
  599:     # skip over "["
  600:     next_line_prefix = " "
  601:     # skip over array(
  602:     next_line_prefix += " " * len(prefix)
  603: 
  604:     lst = _formatArray(a, format_function, options['linewidth'],
  605:                        next_line_prefix, separator, options['edgeitems'],
  606:                        summary_insert, options['legacy'])
  607:     return lst
  608: 
  609: 
  610: def _array2string_dispatcher(
  611:         a, max_line_width=None, precision=None,
  612:         suppress_small=None, separator=None, prefix=None,
  613:         style=None, formatter=None, threshold=None,
  614:         edgeitems=None, sign=None, floatmode=None, suffix=None,
  615:         *, legacy=None):
  616:     return (a,)
  617: 
  618: 
  619: @array_function_dispatch(_array2string_dispatcher, module='numpy')
  620: def array2string(a, max_line_width=None, precision=None,
  621:                  suppress_small=None, separator=' ', prefix="",
  622:                  style=np._NoValue, formatter=None, threshold=None,
  623:                  edgeitems=None, sign=None, floatmode=None, suffix="",
  624:                  *, legacy=None):
  625:     """
  626:     Return a string representation of an array.
  627: 
  628:     Parameters
  629:     ----------
  630:     a : ndarray
  631:         Input array.
  632:     max_line_width : int, optional
  633:         Inserts newlines if text is longer than `max_line_width`.
  634:         Defaults to ``numpy.get_printoptions()['linewidth']``.
  635:     precision : int or None, optional
  636:         Floating point precision.
  637:         Defaults to ``numpy.get_printoptions()['precision']``.
  638:     suppress_small : bool, optional
  639:         Represent numbers "very close" to zero as zero; default is False.
  640:         Very close is defined by precision: if the precision is 8, e.g.,
  641:         numbers smaller (in absolute value) than 5e-9 are represented as
  642:         zero.
  643:         Defaults to ``numpy.get_printoptions()['suppress']``.
  644:     separator : str, optional
  645:         Inserted between elements.
  646:     prefix : str, optional
  647:     suffix : str, optional
  648:         The length of the prefix and suffix strings are used to respectively
  649:         align and wrap the output. An array is typically printed as::
  650: 
  651:           prefix + array2string(a) + suffix
  652: 
  653:         The output is left-padded by the length of the prefix string, and
  654:         wrapping is forced at the column ``max_line_width - len(suffix)``.
  655:         It should be noted that the content of prefix and suffix strings are
  656:         not included in the output.
  657:     style : _NoValue, optional
  658:         Has no effect, do not use.
  659: 
  660:         .. deprecated:: 1.14.0
  661:     formatter : dict of callables, optional
  662:         If not None, the keys should indicate the type(s) that the respective
  663:         formatting function applies to.  Callables should return a string.
  664:         Types that are not specified (by their corresponding keys) are handled
  665:         by the default formatters.  Individual types for which a formatter
  666:         can be set are:
  667: 
  668:         - 'bool'
  669:         - 'int'
  670:         - 'timedelta' : a `numpy.timedelta64`
  671:         - 'datetime' : a `numpy.datetime64`
  672:         - 'float'
  673:         - 'longfloat' : 128-bit floats
  674:         - 'complexfloat'
  675:         - 'longcomplexfloat' : composed of two 128-bit floats
  676:         - 'void' : type `numpy.void`
  677:         - 'numpystr' : types `numpy.bytes_` and `numpy.str_`
  678: 
  679:         Other keys that can be used to set a group of types at once are:
  680: 
  681:         - 'all' : sets all types
  682:         - 'int_kind' : sets 'int'
  683:         - 'float_kind' : sets 'float' and 'longfloat'
  684:         - 'complex_kind' : sets 'complexfloat' and 'longcomplexfloat'
  685:         - 'str_kind' : sets 'numpystr'
  686:     threshold : int, optional
  687:         Total number of array elements which trigger summarization
  688:         rather than full repr.
  689:         Defaults to ``numpy.get_printoptions()['threshold']``.
  690:     edgeitems : int, optional
  691:         Number of array items in summary at beginning and end of
  692:         each dimension.
  693:         Defaults to ``numpy.get_printoptions()['edgeitems']``.
  694:     sign : string, either '-', '+', or ' ', optional
  695:         Controls printing of the sign of floating-point types. If '+', always
  696:         print the sign of positive values. If ' ', always prints a space
  697:         (whitespace character) in the sign position of positive values.  If
  698:         '-', omit the sign character of positive values.
  699:         Defaults to ``numpy.get_printoptions()['sign']``.
  700: 
  701:         .. versionchanged:: 2.0
  702:              The sign parameter can now be an integer type, previously
  703:              types were floating-point types.
  704: 
  705:     floatmode : str, optional
  706:         Controls the interpretation of the `precision` option for
  707:         floating-point types.
  708:         Defaults to ``numpy.get_printoptions()['floatmode']``.
  709:         Can take the following values:
  710: 
  711:         - 'fixed': Always print exactly `precision` fractional digits,
  712:           even if this would print more or fewer digits than
  713:           necessary to specify the value uniquely.
  714:         - 'unique': Print the minimum number of fractional digits necessary
  715:           to represent each value uniquely. Different elements may
  716:           have a different number of digits.  The value of the
  717:           `precision` option is ignored.
  718:         - 'maxprec': Print at most `precision` fractional digits, but if
  719:           an element can be uniquely represented with fewer digits
  720:           only print it with that many.
  721:         - 'maxprec_equal': Print at most `precision` fractional digits,
  722:           but if every element in the array can be uniquely
  723:           represented with an equal number of fewer digits, use that
  724:           many digits for all elements.
  725:     legacy : string or `False`, optional
  726:         If set to the string ``'1.13'`` enables 1.13 legacy printing mode. This
  727:         approximates numpy 1.13 print output by including a space in the sign
  728:         position of floats and different behavior for 0d arrays. If set to
  729:         `False`, disables legacy mode. Unrecognized strings will be ignored
  730:         with a warning for forward compatibility.
  731: 
  732:     Returns
  733:     -------
  734:     array_str : str
  735:         String representation of the array.
  736: 
  737:     Raises
  738:     ------
  739:     TypeError
  740:         if a callable in `formatter` does not return a string.
  741: 
  742:     See Also
  743:     --------
  744:     array_str, array_repr, set_printoptions, get_printoptions
  745: 
  746:     Notes
  747:     -----
  748:     If a formatter is specified for a certain type, the `precision` keyword is
  749:     ignored for that type.
  750: 
  751:     This is a very flexible function; `array_repr` and `array_str` are using
  752:     `array2string` internally so keywords with the same name should work
  753:     identically in all three functions.
  754: 
  755:     Examples
  756:     --------
  757:     >>> import numpy as np
  758:     >>> x = np.array([1e-16,1,2,3])
  759:     >>> np.array2string(x, precision=2, separator=',',
  760:     ...                       suppress_small=True)
  761:     '[0.,1.,2.,3.]'
  762: 
  763:     >>> x  = np.arange(3.)
  764:     >>> np.array2string(x, formatter={'float_kind':lambda x: "%.2f" % x})
  765:     '[0.00 1.00 2.00]'
  766: 
  767:     >>> x  = np.arange(3)
  768:     >>> np.array2string(x, formatter={'int':lambda x: hex(x)})
  769:     '[0x0 0x1 0x2]'
  770: 
  771:     """
  772: 
  773:     overrides = _make_options_dict(precision, threshold, edgeitems,
  774:                                    max_line_width, suppress_small, None, None,
  775:                                    sign, formatter, floatmode, legacy)
  776:     options = format_options.get().copy()
  777:     options.update(overrides)
  778: 
  779:     if options['legacy'] <= 113:
  780:         if style is np._NoValue:
  781:             style = repr
  782: 
  783:         if a.shape == () and a.dtype.names is None:
  784:             return style(a.item())
  785:     elif style is not np._NoValue:
  786:         # Deprecation 11-9-2017  v1.14
  787:         warnings.warn("'style' argument is deprecated and no longer functional"
  788:                       " except in 1.13 'legacy' mode",
  789:                       DeprecationWarning, stacklevel=2)
  790: 
  791:     if options['legacy'] > 113:
  792:         options['linewidth'] -= len(suffix)
  793: 
  794:     # treat as a null array if any of shape elements == 0
  795:     if a.size == 0:
  796:         return "[]"
  797: 
  798:     return _array2string(a, options, separator, prefix)
  799: 
  800: 
  801: def _extendLine(s, line, word, line_width, next_line_prefix, legacy):
  802:     needs_wrap = len(line) + len(word) > line_width
  803:     if legacy > 113:
  804:         # don't wrap lines if it won't help
  805:         if len(line) <= len(next_line_prefix):
  806:             needs_wrap = False
  807: 
  808:     if needs_wrap:
  809:         s += line.rstrip() + "\n"
  810:         line = next_line_prefix
  811:     line += word
  812:     return s, line
  813: 
  814: 
  815: def _extendLine_pretty(s, line, word, line_width, next_line_prefix, legacy):
  816:     """
  817:     Extends line with nicely formatted (possibly multi-line) string ``word``.
  818:     """
  819:     words = word.splitlines()
  820:     if len(words) == 1 or legacy <= 113:
  821:         return _extendLine(s, line, word, line_width, next_line_prefix, legacy)
  822: 
  823:     max_word_length = max(len(word) for word in words)
  824:     if (len(line) + max_word_length > line_width and
  825:             len(line) > len(next_line_prefix)):
  826:         s += line.rstrip() + '\n'
  827:         line = next_line_prefix + words[0]
  828:         indent = next_line_prefix
  829:     else:
  830:         indent = len(line) * ' '
  831:         line += words[0]
  832: 
  833:     for word in words[1::]:
  834:         s += line.rstrip() + '\n'
  835:         line = indent + word
  836: 
  837:     suffix_length = max_word_length - len(words[-1])
  838:     line += suffix_length * ' '
  839: 
  840:     return s, line
  841: 
  842: def _formatArray(a, format_function, line_width, next_line_prefix,
  843:                  separator, edge_items, summary_insert, legacy):
  844:     """formatArray is designed for two modes of operation:
  845: 
  846:     1. Full output
  847: 
  848:     2. Summarized output
  849: 
  850:     """
  851:     def recurser(index, hanging_indent, curr_width):
  852:         """
  853:         By using this local function, we don't need to recurse with all the
  854:         arguments. Since this function is not created recursively, the cost is
  855:         not significant
  856:         """
  857:         axis = len(index)
  858:         axes_left = a.ndim - axis
  859: 
  860:         if axes_left == 0:
  861:             return format_function(a[index])
  862: 
  863:         # when recursing, add a space to align with the [ added, and reduce the
  864:         # length of the line by 1
  865:         next_hanging_indent = hanging_indent + ' '
  866:         if legacy <= 113:
  867:             next_width = curr_width
  868:         else:
  869:             next_width = curr_width - len(']')
  870: 
  871:         a_len = a.shape[axis]
  872:         show_summary = summary_insert and 2 * edge_items < a_len
  873:         if show_summary:
  874:             leading_items = edge_items
  875:             trailing_items = edge_items
  876:         else:
  877:             leading_items = 0
  878:             trailing_items = a_len
  879: 
  880:         # stringify the array with the hanging indent on the first line too
  881:         s = ''
  882: 
  883:         # last axis (rows) - wrap elements if they would not fit on one line
  884:         if axes_left == 1:
  885:             # the length up until the beginning of the separator / bracket
  886:             if legacy <= 113:
  887:                 elem_width = curr_width - len(separator.rstrip())
  888:             else:
  889:                 elem_width = curr_width - max(
  890:                     len(separator.rstrip()), len(']')
  891:                 )
  892: 
  893:             line = hanging_indent
  894:             for i in range(leading_items):
  895:                 word = recurser(index + (i,), next_hanging_indent, next_width)
  896:                 s, line = _extendLine_pretty(
  897:                     s, line, word, elem_width, hanging_indent, legacy)
  898:                 line += separator
  899: 
  900:             if show_summary:
  901:                 s, line = _extendLine(
  902:                     s, line, summary_insert, elem_width, hanging_indent, legacy
  903:                 )
  904:                 if legacy <= 113:
  905:                     line += ", "
  906:                 else:
  907:                     line += separator
  908: 
  909:             for i in range(trailing_items, 1, -1):
  910:                 word = recurser(index + (-i,), next_hanging_indent, next_width)
  911:                 s, line = _extendLine_pretty(
  912:                     s, line, word, elem_width, hanging_indent, legacy)
  913:                 line += separator
  914: 
  915:             if legacy <= 113:
  916:                 # width of the separator is not considered on 1.13
  917:                 elem_width = curr_width
  918:             word = recurser(index + (-1,), next_hanging_indent, next_width)
  919:             s, line = _extendLine_pretty(
  920:                 s, line, word, elem_width, hanging_indent, legacy)
  921: 
  922:             s += line
  923: 
  924:         # other axes - insert newlines between rows
  925:         else:
  926:             s = ''
  927:             line_sep = separator.rstrip() + '\n' * (axes_left - 1)
  928: 
  929:             for i in range(leading_items):
  930:                 nested = recurser(
  931:                     index + (i,), next_hanging_indent, next_width
  932:                 )
  933:                 s += hanging_indent + nested + line_sep
  934: 
  935:             if show_summary:
  936:                 if legacy <= 113:
  937:                     # trailing space, fixed nbr of newlines,
  938:                     # and fixed separator
  939:                     s += hanging_indent + summary_insert + ", \n"
  940:                 else:
  941:                     s += hanging_indent + summary_insert + line_sep
  942: 
  943:             for i in range(trailing_items, 1, -1):
  944:                 nested = recurser(index + (-i,), next_hanging_indent,
  945:                                   next_width)
  946:                 s += hanging_indent + nested + line_sep
  947: 
  948:             nested = recurser(index + (-1,), next_hanging_indent, next_width)
  949:             s += hanging_indent + nested
  950: 
  951:         # remove the hanging indent, and wrap in []
  952:         s = '[' + s[len(hanging_indent):] + ']'
  953:         return s
  954: 
  955:     try:
  956:         # invoke the recursive part with an initial index and prefix
  957:         return recurser(index=(),
  958:                         hanging_indent=next_line_prefix,
  959:                         curr_width=line_width)
  960:     finally:
  961:         # recursive closures have a cyclic reference to themselves, which
  962:         # requires gc to collect (gh-10620). To avoid this problem, for
  963:         # performance and PyPy friendliness, we break the cycle:
  964:         recurser = None
  965: 
  966: def _none_or_positive_arg(x, name):
  967:     if x is None:
  968:         return -1
  969:     if x < 0:
  970:         raise ValueError(f"{name} must be >= 0")
  971:     return x
  972: 
  973: class FloatingFormat:
  974:     """ Formatter for subtypes of np.floating """
  975:     def __init__(self, data, precision, floatmode, suppress_small, sign=False,
  976:                  *, legacy=None):
  977:         # for backcompatibility, accept bools
  978:         if isinstance(sign, bool):
  979:             sign = '+' if sign else '-'
  980: 
  981:         self._legacy = legacy
  982:         if self._legacy <= 113:
  983:             # when not 0d, legacy does not support '-'
  984:             if data.shape != () and sign == '-':
  985:                 sign = ' '
  986: 
  987:         self.floatmode = floatmode
  988:         if floatmode == 'unique':
  989:             self.precision = None
  990:         else:
  991:             self.precision = precision
  992: 
  993:         self.precision = _none_or_positive_arg(self.precision, 'precision')
  994: 
  995:         self.suppress_small = suppress_small
  996:         self.sign = sign
  997:         self.exp_format = False
  998:         self.large_exponent = False
  999:         self.fillFormat(data)
 1000: 
 1001:     def fillFormat(self, data):
 1002:         # only the finite values are used to compute the number of digits
 1003:         finite_vals = data[isfinite(data)]
 1004: 
 1005:         # choose exponential mode based on the non-zero finite values:
 1006:         abs_non_zero = absolute(finite_vals[finite_vals != 0])
 1007:         if len(abs_non_zero) != 0:
 1008:             max_val = np.max(abs_non_zero)
 1009:             min_val = np.min(abs_non_zero)
 1010:             if self._legacy <= 202:
 1011:                 exp_cutoff_max = 1.e8
 1012:             else:
 1013:                 # consider data type while deciding the max cutoff for exp format
 1014:                 exp_cutoff_max = 10.**min(8, np.finfo(data.dtype).precision)
 1015:             with errstate(over='ignore'):  # division can overflow
 1016:                 if max_val >= exp_cutoff_max or (not self.suppress_small and
 1017:                         (min_val < 0.0001 or max_val / min_val > 1000.)):
 1018:                     self.exp_format = True
 1019: 
 1020:         # do a first pass of printing all the numbers, to determine sizes
 1021:         if len(finite_vals) == 0:
 1022:             self.pad_left = 0
 1023:             self.pad_right = 0
 1024:             self.trim = '.'
 1025:             self.exp_size = -1
 1026:             self.unique = True
 1027:             self.min_digits = None
 1028:         elif self.exp_format:
 1029:             trim, unique = '.', True
 1030:             if self.floatmode == 'fixed' or self._legacy <= 113:
 1031:                 trim, unique = 'k', False
 1032:             strs = (dragon4_scientific(x, precision=self.precision,
 1033:                                unique=unique, trim=trim, sign=self.sign == '+')
 1034:                     for x in finite_vals)
 1035:             frac_strs, _, exp_strs = zip(*(s.partition('e') for s in strs))
 1036:             int_part, frac_part = zip(*(s.split('.') for s in frac_strs))
 1037:             self.exp_size = max(len(s) for s in exp_strs) - 1
 1038: 
 1039:             self.trim = 'k'
 1040:             self.precision = max(len(s) for s in frac_part)
 1041:             self.min_digits = self.precision
 1042:             self.unique = unique
 1043: 
 1044:             # for back-compat with np 1.13, use 2 spaces & sign and full prec
 1045:             if self._legacy <= 113:
 1046:                 self.pad_left = 3
 1047:             else:
 1048:                 # this should be only 1 or 2. Can be calculated from sign.
 1049:                 self.pad_left = max(len(s) for s in int_part)
 1050:             # pad_right is only needed for nan length calculation
 1051:             self.pad_right = self.exp_size + 2 + self.precision
 1052:         else:
 1053:             trim, unique = '.', True
 1054:             if self.floatmode == 'fixed':
 1055:                 trim, unique = 'k', False
 1056:             strs = (dragon4_positional(x, precision=self.precision,
 1057:                                        fractional=True,
 1058:                                        unique=unique, trim=trim,
 1059:                                        sign=self.sign == '+')
 1060:                     for x in finite_vals)
 1061:             int_part, frac_part = zip(*(s.split('.') for s in strs))
 1062:             if self._legacy <= 113:
 1063:                 self.pad_left = 1 + max(len(s.lstrip('-+')) for s in int_part)
 1064:             else:
 1065:                 self.pad_left = max(len(s) for s in int_part)
 1066:             self.pad_right = max(len(s) for s in frac_part)
 1067:             self.exp_size = -1
 1068:             self.unique = unique
 1069: 
 1070:             if self.floatmode in ['fixed', 'maxprec_equal']:
 1071:                 self.precision = self.min_digits = self.pad_right
 1072:                 self.trim = 'k'
 1073:             else:
 1074:                 self.trim = '.'
 1075:                 self.min_digits = 0
 1076: 
 1077:         if self._legacy > 113:
 1078:             # account for sign = ' ' by adding one to pad_left
 1079:             if self.sign == ' ' and not any(np.signbit(finite_vals)):
 1080:                 self.pad_left += 1
 1081: 
 1082:         # if there are non-finite values, may need to increase pad_left
 1083:         if data.size != finite_vals.size:
 1084:             neginf = self.sign != '-' or any(data[isinf(data)] < 0)
 1085:             offset = self.pad_right + 1  # +1 for decimal pt
 1086:             current_options = format_options.get()
 1087:             self.pad_left = max(
 1088:                 self.pad_left, len(current_options['nanstr']) - offset,
 1089:                 len(current_options['infstr']) + neginf - offset
 1090:             )
 1091: 
 1092:     def __call__(self, x):
 1093:         if not np.isfinite(x):
 1094:             with errstate(invalid='ignore'):
 1095:                 current_options = format_options.get()
 1096:                 if np.isnan(x):
 1097:                     sign = '+' if self.sign == '+' else ''
 1098:                     ret = sign + current_options['nanstr']
 1099:                 else:  # isinf
 1100:                     sign = '-' if x < 0 else '+' if self.sign == '+' else ''
 1101:                     ret = sign + current_options['infstr']
 1102:                 return ' ' * (
 1103:                     self.pad_left + self.pad_right + 1 - len(ret)
 1104:                 ) + ret
 1105: 
 1106:         if self.exp_format:
 1107:             return dragon4_scientific(x,
 1108:                                       precision=self.precision,
 1109:                                       min_digits=self.min_digits,
 1110:                                       unique=self.unique,
 1111:                                       trim=self.trim,
 1112:                                       sign=self.sign == '+',
 1113:                                       pad_left=self.pad_left,
 1114:                                       exp_digits=self.exp_size)
 1115:         else:
 1116:             return dragon4_positional(x,
 1117:                                       precision=self.precision,
 1118:                                       min_digits=self.min_digits,
 1119:                                       unique=self.unique,
 1120:                                       fractional=True,
 1121:                                       trim=self.trim,
 1122:                                       sign=self.sign == '+',
 1123:                                       pad_left=self.pad_left,
 1124:                                       pad_right=self.pad_right)
 1125: 
 1126: 
 1127: @set_module('numpy')
 1128: def format_float_scientific(x, precision=None, unique=True, trim='k',
 1129:                             sign=False, pad_left=None, exp_digits=None,
 1130:                             min_digits=None):
 1131:     """
 1132:     Format a floating-point scalar as a decimal string in scientific notation.
 1133: 
 1134:     Provides control over rounding, trimming and padding. Uses and assumes
 1135:     IEEE unbiased rounding. Uses the "Dragon4" algorithm.
 1136: 
 1137:     Parameters
 1138:     ----------
 1139:     x : python float or numpy floating scalar
 1140:         Value to format.
 1141:     precision : non-negative integer or None, optional
 1142:         Maximum number of digits to print. May be None if `unique` is
 1143:         `True`, but must be an integer if unique is `False`.
 1144:     unique : boolean, optional
 1145:         If `True`, use a digit-generation strategy which gives the shortest
 1146:         representation which uniquely identifies the floating-point number from
 1147:         other values of the same type, by judicious rounding. If `precision`
 1148:         is given fewer digits than necessary can be printed. If `min_digits`
 1149:         is given more can be printed, in which cases the last digit is rounded
 1150:         with unbiased rounding.
 1151:         If `False`, digits are generated as if printing an infinite-precision
 1152:         value and stopping after `precision` digits, rounding the remaining
 1153:         value with unbiased rounding
 1154:     trim : one of 'k', '.', '0', '-', optional
 1155:         Controls post-processing trimming of trailing digits, as follows:
 1156: 
 1157:         * 'k' : keep trailing zeros, keep decimal point (no trimming)
 1158:         * '.' : trim all trailing zeros, leave decimal point
 1159:         * '0' : trim all but the zero before the decimal point. Insert the
 1160:           zero if it is missing.
 1161:         * '-' : trim trailing zeros and any trailing decimal point
 1162:     sign : boolean, optional
 1163:         Whether to show the sign for positive values.
 1164:     pad_left : non-negative integer, optional
 1165:         Pad the left side of the string with whitespace until at least that
 1166:         many characters are to the left of the decimal point.
 1167:     exp_digits : non-negative integer, optional
 1168:         Pad the exponent with zeros until it contains at least this
 1169:         many digits. If omitted, the exponent will be at least 2 digits.
 1170:     min_digits : non-negative integer or None, optional
 1171:         Minimum number of digits to print. This only has an effect for
 1172:         `unique=True`. In that case more digits than necessary to uniquely
 1173:         identify the value may be printed and rounded unbiased.
 1174: 
 1175:         .. versionadded:: 1.21.0
 1176: 
 1177:     Returns
 1178:     -------
 1179:     rep : string
 1180:         The string representation of the floating point value
 1181: 
 1182:     See Also
 1183:     --------
 1184:     format_float_positional
 1185: 
 1186:     Examples
 1187:     --------
 1188:     >>> import numpy as np
 1189:     >>> np.format_float_scientific(np.float32(np.pi))
 1190:     '3.1415927e+00'
 1191:     >>> s = np.float32(1.23e24)
 1192:     >>> np.format_float_scientific(s, unique=False, precision=15)
 1193:     '1.230000071797338e+24'
 1194:     >>> np.format_float_scientific(s, exp_digits=4)
 1195:     '1.23e+0024'
 1196:     """
 1197:     precision = _none_or_positive_arg(precision, 'precision')
 1198:     pad_left = _none_or_positive_arg(pad_left, 'pad_left')
 1199:     exp_digits = _none_or_positive_arg(exp_digits, 'exp_digits')
 1200:     min_digits = _none_or_positive_arg(min_digits, 'min_digits')
 1201:     if min_digits > 0 and precision > 0 and min_digits > precision:
 1202:         raise ValueError("min_digits must be less than or equal to precision")
 1203:     return dragon4_scientific(x, precision=precision, unique=unique,
 1204:                               trim=trim, sign=sign, pad_left=pad_left,
 1205:                               exp_digits=exp_digits, min_digits=min_digits)
 1206: 
 1207: 
 1208: @set_module('numpy')
 1209: def format_float_positional(x, precision=None, unique=True,
 1210:                             fractional=True, trim='k', sign=False,
 1211:                             pad_left=None, pad_right=None, min_digits=None):
 1212:     """
 1213:     Format a floating-point scalar as a decimal string in positional notation.
 1214: 
 1215:     Provides control over rounding, trimming and padding. Uses and assumes
 1216:     IEEE unbiased rounding. Uses the "Dragon4" algorithm.
 1217: 
 1218:     Parameters
 1219:     ----------
 1220:     x : python float or numpy floating scalar
 1221:         Value to format.
 1222:     precision : non-negative integer or None, optional
 1223:         Maximum number of digits to print. May be None if `unique` is
 1224:         `True`, but must be an integer if unique is `False`.
 1225:     unique : boolean, optional
 1226:         If `True`, use a digit-generation strategy which gives the shortest
 1227:         representation which uniquely identifies the floating-point number from
 1228:         other values of the same type, by judicious rounding. If `precision`
 1229:         is given fewer digits than necessary can be printed, or if `min_digits`
 1230:         is given more can be printed, in which cases the last digit is rounded
 1231:         with unbiased rounding.
 1232:         If `False`, digits are generated as if printing an infinite-precision
 1233:         value and stopping after `precision` digits, rounding the remaining
 1234:         value with unbiased rounding
 1235:     fractional : boolean, optional
 1236:         If `True`, the cutoffs of `precision` and `min_digits` refer to the
 1237:         total number of digits after the decimal point, including leading
 1238:         zeros.
 1239:         If `False`, `precision` and `min_digits` refer to the total number of
 1240:         significant digits, before or after the decimal point, ignoring leading
 1241:         zeros.
 1242:     trim : one of 'k', '.', '0', '-', optional
 1243:         Controls post-processing trimming of trailing digits, as follows:
 1244: 
 1245:         * 'k' : keep trailing zeros, keep decimal point (no trimming)
 1246:         * '.' : trim all trailing zeros, leave decimal point
 1247:         * '0' : trim all but the zero before the decimal point. Insert the
 1248:           zero if it is missing.
 1249:         * '-' : trim trailing zeros and any trailing decimal point
 1250:     sign : boolean, optional
 1251:         Whether to show the sign for positive values.
 1252:     pad_left : non-negative integer, optional
 1253:         Pad the left side of the string with whitespace until at least that
 1254:         many characters are to the left of the decimal point.
 1255:     pad_right : non-negative integer, optional
 1256:         Pad the right side of the string with whitespace until at least that
 1257:         many characters are to the right of the decimal point.
 1258:     min_digits : non-negative integer or None, optional
 1259:         Minimum number of digits to print. Only has an effect if `unique=True`
 1260:         in which case additional digits past those necessary to uniquely
 1261:         identify the value may be printed, rounding the last additional digit.
 1262: 
 1263:         .. versionadded:: 1.21.0
 1264: 
 1265:     Returns
 1266:     -------
 1267:     rep : string
 1268:         The string representation of the floating point value
 1269: 
 1270:     See Also
 1271:     --------
 1272:     format_float_scientific
 1273: 
 1274:     Examples
 1275:     --------
 1276:     >>> import numpy as np
 1277:     >>> np.format_float_positional(np.float32(np.pi))
 1278:     '3.1415927'
 1279:     >>> np.format_float_positional(np.float16(np.pi))
 1280:     '3.14'
 1281:     >>> np.format_float_positional(np.float16(0.3))
 1282:     '0.3'
 1283:     >>> np.format_float_positional(np.float16(0.3), unique=False, precision=10)
 1284:     '0.3000488281'
 1285:     """
 1286:     precision = _none_or_positive_arg(precision, 'precision')
 1287:     pad_left = _none_or_positive_arg(pad_left, 'pad_left')
 1288:     pad_right = _none_or_positive_arg(pad_right, 'pad_right')
 1289:     min_digits = _none_or_positive_arg(min_digits, 'min_digits')
 1290:     if not fractional and precision == 0:
 1291:         raise ValueError("precision must be greater than 0 if "
 1292:                          "fractional=False")
 1293:     if min_digits > 0 and precision > 0 and min_digits > precision:
 1294:         raise ValueError("min_digits must be less than or equal to precision")
 1295:     return dragon4_positional(x, precision=precision, unique=unique,
 1296:                               fractional=fractional, trim=trim,
 1297:                               sign=sign, pad_left=pad_left,
 1298:                               pad_right=pad_right, min_digits=min_digits)
 1299: 
 1300: class IntegerFormat:
 1301:     def __init__(self, data, sign='-'):
 1302:         if data.size > 0:
 1303:             data_max = np.max(data)
 1304:             data_min = np.min(data)
 1305:             data_max_str_len = len(str(data_max))
 1306:             if sign == ' ' and data_min < 0:
 1307:                 sign = '-'
 1308:             if data_max >= 0 and sign in "+ ":
 1309:                 data_max_str_len += 1
 1310:             max_str_len = max(data_max_str_len,
 1311:                               len(str(data_min)))
 1312:         else:
 1313:             max_str_len = 0
 1314:         self.format = f'{{:{sign}{max_str_len}d}}'
 1315: 
 1316:     def __call__(self, x):
 1317:         return self.format.format(x)
 1318: 
 1319: class BoolFormat:
 1320:     def __init__(self, data, **kwargs):
 1321:         # add an extra space so " True" and "False" have the same length and
 1322:         # array elements align nicely when printed, except in 0d arrays
 1323:         self.truestr = ' True' if data.shape != () else 'True'
 1324: 
 1325:     def __call__(self, x):
 1326:         return self.truestr if x else "False"
 1327: 
 1328: 
 1329: class ComplexFloatingFormat:
 1330:     """ Formatter for subtypes of np.complexfloating """
 1331:     def __init__(self, x, precision, floatmode, suppress_small,
 1332:                  sign=False, *, legacy=None):
 1333:         # for backcompatibility, accept bools
 1334:         if isinstance(sign, bool):
 1335:             sign = '+' if sign else '-'
 1336: 
 1337:         floatmode_real = floatmode_imag = floatmode
 1338:         if legacy <= 113:
 1339:             floatmode_real = 'maxprec_equal'
 1340:             floatmode_imag = 'maxprec'
 1341: 
 1342:         self.real_format = FloatingFormat(
 1343:             x.real, precision, floatmode_real, suppress_small,
 1344:             sign=sign, legacy=legacy
 1345:         )
 1346:         self.imag_format = FloatingFormat(
 1347:             x.imag, precision, floatmode_imag, suppress_small,
 1348:             sign='+', legacy=legacy
 1349:         )
 1350: 
 1351:     def __call__(self, x):
 1352:         r = self.real_format(x.real)
 1353:         i = self.imag_format(x.imag)
 1354: 
 1355:         # add the 'j' before the terminal whitespace in i
 1356:         sp = len(i.rstrip())
 1357:         i = i[:sp] + 'j' + i[sp:]
 1358: 
 1359:         return r + i
 1360: 
 1361: 
 1362: class _TimelikeFormat:
 1363:     def __init__(self, data):
 1364:         non_nat = data[~isnat(data)]
 1365:         if len(non_nat) > 0:
 1366:             # Max str length of non-NaT elements
 1367:             max_str_len = max(len(self._format_non_nat(np.max(non_nat))),
 1368:                               len(self._format_non_nat(np.min(non_nat))))
 1369:         else:
 1370:             max_str_len = 0
 1371:         if len(non_nat) < data.size:
 1372:             # data contains a NaT
 1373:             max_str_len = max(max_str_len, 5)
 1374:         self._format = f'%{max_str_len}s'
 1375:         self._nat = "'NaT'".rjust(max_str_len)
 1376: 
 1377:     def _format_non_nat(self, x):
 1378:         # override in subclass
 1379:         raise NotImplementedError
 1380: 
 1381:     def __call__(self, x):
 1382:         if isnat(x):
 1383:             return self._nat
 1384:         else:
 1385:             return self._format % self._format_non_nat(x)
 1386: 
 1387: 
 1388: class DatetimeFormat(_TimelikeFormat):
 1389:     def __init__(self, x, unit=None, timezone=None, casting='same_kind',
 1390:                  legacy=False):
 1391:         # Get the unit from the dtype
 1392:         if unit is None:
 1393:             if x.dtype.kind == 'M':
 1394:                 unit = datetime_data(x.dtype)[0]
 1395:             else:
 1396:                 unit = 's'
 1397: 
 1398:         if timezone is None:
 1399:             timezone = 'naive'
 1400:         self.timezone = timezone
 1401:         self.unit = unit
 1402:         self.casting = casting
 1403:         self.legacy = legacy
 1404: 
 1405:         # must be called after the above are configured
 1406:         super().__init__(x)
 1407: 
 1408:     def __call__(self, x):
 1409:         if self.legacy <= 113:
 1410:             return self._format_non_nat(x)
 1411:         return super().__call__(x)
 1412: 
 1413:     def _format_non_nat(self, x):
 1414:         return "'%s'" % datetime_as_string(x,
 1415:                                     unit=self.unit,
 1416:                                     timezone=self.timezone,
 1417:                                     casting=self.casting)
 1418: 
 1419: 
 1420: class TimedeltaFormat(_TimelikeFormat):
 1421:     def _format_non_nat(self, x):
 1422:         return str(x.astype('i8'))
 1423: 
 1424: 
 1425: class SubArrayFormat:
 1426:     def __init__(self, format_function, **options):
 1427:         self.format_function = format_function
 1428:         self.threshold = options['threshold']
 1429:         self.edge_items = options['edgeitems']
 1430: 
 1431:     def __call__(self, a):
 1432:         self.summary_insert = "..." if a.size > self.threshold else ""
 1433:         return self.format_array(a)
 1434: 
 1435:     def format_array(self, a):
 1436:         if np.ndim(a) == 0:
 1437:             return self.format_function(a)
 1438: 
 1439:         if self.summary_insert and a.shape[0] > 2 * self.edge_items:
 1440:             formatted = (
 1441:                 [self.format_array(a_) for a_ in a[:self.edge_items]]
 1442:                 + [self.summary_insert]
 1443:                 + [self.format_array(a_) for a_ in a[-self.edge_items:]]
 1444:             )
 1445:         else:
 1446:             formatted = [self.format_array(a_) for a_ in a]
 1447: 
 1448:         return "[" + ", ".join(formatted) + "]"
 1449: 
 1450: 
 1451: class StructuredVoidFormat:
 1452:     """
 1453:     Formatter for structured np.void objects.
 1454: 
 1455:     This does not work on structured alias types like
 1456:     np.dtype(('i4', 'i2,i2')), as alias scalars lose their field information,
 1457:     and the implementation relies upon np.void.__getitem__.
 1458:     """
 1459:     def __init__(self, format_functions):
 1460:         self.format_functions = format_functions
 1461: 
 1462:     @classmethod
 1463:     def from_data(cls, data, **options):
 1464:         """
 1465:         This is a second way to initialize StructuredVoidFormat,
 1466:         using the raw data as input. Added to avoid changing
 1467:         the signature of __init__.
 1468:         """
 1469:         format_functions = []
 1470:         for field_name in data.dtype.names:
 1471:             format_function = _get_format_function(data[field_name], **options)
 1472:             if data.dtype[field_name].shape != ():
 1473:                 format_function = SubArrayFormat(format_function, **options)
 1474:             format_functions.append(format_function)
 1475:         return cls(format_functions)
 1476: 
 1477:     def __call__(self, x):
 1478:         str_fields = [
 1479:             format_function(field)
 1480:             for field, format_function in zip(x, self.format_functions)
 1481:         ]
 1482:         if len(str_fields) == 1:
 1483:             return f"({str_fields[0]},)"
 1484:         else:
 1485:             return f"({', '.join(str_fields)})"
 1486: 
 1487: 
 1488: def _void_scalar_to_string(x, is_repr=True):
 1489:     """
 1490:     Implements the repr for structured-void scalars. It is called from the
 1491:     scalartypes.c.src code, and is placed here because it uses the elementwise
 1492:     formatters defined above.
 1493:     """
 1494:     options = format_options.get().copy()
 1495: 
 1496:     if options["legacy"] <= 125:
 1497:         return StructuredVoidFormat.from_data(array(x), **options)(x)
 1498: 
 1499:     if options.get('formatter') is None:
 1500:         options['formatter'] = {}
 1501:     options['formatter'].setdefault('float_kind', str)
 1502:     val_repr = StructuredVoidFormat.from_data(array(x), **options)(x)
 1503:     if not is_repr:
 1504:         return val_repr
 1505:     cls = type(x)
 1506:     cls_fqn = cls.__module__.replace("numpy", "np") + "." + cls.__name__
 1507:     void_dtype = np.dtype((np.void, x.dtype))
 1508:     return f"{cls_fqn}({val_repr}, dtype={void_dtype!s})"
 1509: 
 1510: 
 1511: _typelessdata = [int_, float64, complex128, _nt.bool]
 1512: 
 1513: 
 1514: def dtype_is_implied(dtype):
 1515:     """
 1516:     Determine if the given dtype is implied by the representation
 1517:     of its values.
 1518: 
 1519:     Parameters
 1520:     ----------
 1521:     dtype : dtype
 1522:         Data type
 1523: 
 1524:     Returns
 1525:     -------
 1526:     implied : bool
 1527:         True if the dtype is implied by the representation of its values.
 1528: 
 1529:     Examples
 1530:     --------
 1531:     >>> import numpy as np
 1532:     >>> np._core.arrayprint.dtype_is_implied(int)
 1533:     True
 1534:     >>> np.array([1, 2, 3], int)
 1535:     array([1, 2, 3])
 1536:     >>> np._core.arrayprint.dtype_is_implied(np.int8)
 1537:     False
 1538:     >>> np.array([1, 2, 3], np.int8)
 1539:     array([1, 2, 3], dtype=int8)
 1540:     """
 1541:     dtype = np.dtype(dtype)
 1542:     if format_options.get()['legacy'] <= 113 and dtype.type == np.bool:
 1543:         return False
 1544: 
 1545:     # not just void types can be structured, and names are not part of the repr
 1546:     if dtype.names is not None:
 1547:         return False
 1548: 
 1549:     # should care about endianness *unless size is 1* (e.g., int8, bool)
 1550:     if not dtype.isnative:
 1551:         return False
 1552: 
 1553:     return dtype.type in _typelessdata
 1554: 
 1555: 
 1556: def dtype_short_repr(dtype):
 1557:     """
 1558:     Convert a dtype to a short form which evaluates to the same dtype.
 1559: 
 1560:     The intent is roughly that the following holds
 1561: 
 1562:     >>> from numpy import *
 1563:     >>> dt = np.int64([1, 2]).dtype
 1564:     >>> assert eval(dtype_short_repr(dt)) == dt
 1565:     """
 1566:     if type(dtype).__repr__ != np.dtype.__repr__:
 1567:         # TODO: Custom repr for user DTypes, logic should likely move.
 1568:         return repr(dtype)
 1569:     if dtype.names is not None:
 1570:         # structured dtypes give a list or tuple repr
 1571:         return str(dtype)
 1572:     elif issubclass(dtype.type, flexible):
 1573:         # handle these separately so they don't give garbage like str256
 1574:         return f"'{str(dtype)}'"
 1575: 
 1576:     typename = dtype.name
 1577:     if not dtype.isnative:
 1578:         # deal with cases like dtype('<u2') that are identical to an
 1579:         # established dtype (in this case uint16)
 1580:         # except that they have a different endianness.
 1581:         return f"'{str(dtype)}'"
 1582:     # quote typenames which can't be represented as python variable names
 1583:     if typename and not (typename[0].isalpha() and typename.isalnum()):
 1584:         typename = repr(typename)
 1585:     return typename
 1586: 
 1587: 
 1588: def _array_repr_implementation(
 1589:         arr, max_line_width=None, precision=None, suppress_small=None,
 1590:         array2string=array2string):
 1591:     """Internal version of array_repr() that allows overriding array2string."""
 1592:     current_options = format_options.get()
 1593:     override_repr = current_options["override_repr"]
 1594:     if override_repr is not None:
 1595:         return override_repr(arr)
 1596: 
 1597:     if max_line_width is None:
 1598:         max_line_width = current_options['linewidth']
 1599: 
 1600:     if type(arr) is not ndarray:
 1601:         class_name = type(arr).__name__
 1602:     else:
 1603:         class_name = "array"
 1604: 
 1605:     prefix = class_name + "("
 1606:     if (current_options['legacy'] <= 113 and
 1607:             arr.shape == () and not arr.dtype.names):
 1608:         lst = repr(arr.item())
 1609:     else:
 1610:         lst = array2string(arr, max_line_width, precision, suppress_small,
 1611:                            ', ', prefix, suffix=")")
 1612: 
 1613:     # Add dtype and shape information if these cannot be inferred from
 1614:     # the array string.
 1615:     extras = []
 1616:     if ((arr.size == 0 and arr.shape != (0,))
 1617:             or (current_options['legacy'] > 210
 1618:             and arr.size > current_options['threshold'])):
 1619:         extras.append(f"shape={arr.shape}")
 1620:     if not dtype_is_implied(arr.dtype) or arr.size == 0:
 1621:         extras.append(f"dtype={dtype_short_repr(arr.dtype)}")
 1622: 
 1623:     if not extras:
 1624:         return prefix + lst + ")"
 1625: 
 1626:     arr_str = prefix + lst + ","
 1627:     extra_str = ", ".join(extras) + ")"
 1628:     # compute whether we should put extras on a new line: Do so if adding the
 1629:     # extras would extend the last line past max_line_width.
 1630:     # Note: This line gives the correct result even when rfind returns -1.
 1631:     last_line_len = len(arr_str) - (arr_str.rfind('\n') + 1)
 1632:     spacer = " "
 1633:     if current_options['legacy'] <= 113:
 1634:         if issubclass(arr.dtype.type, flexible):
 1635:             spacer = '\n' + ' ' * len(prefix)
 1636:     elif last_line_len + len(extra_str) + 1 > max_line_width:
 1637:         spacer = '\n' + ' ' * len(prefix)
 1638: 
 1639:     return arr_str + spacer + extra_str
 1640: 
 1641: 
 1642: def _array_repr_dispatcher(
 1643:         arr, max_line_width=None, precision=None, suppress_small=None):
 1644:     return (arr,)
 1645: 
 1646: 
 1647: @array_function_dispatch(_array_repr_dispatcher, module='numpy')
 1648: def array_repr(arr, max_line_width=None, precision=None, suppress_small=None):
 1649:     """
 1650:     Return the string representation of an array.
 1651: 
 1652:     Parameters
 1653:     ----------
 1654:     arr : ndarray
 1655:         Input array.
 1656:     max_line_width : int, optional
 1657:         Inserts newlines if text is longer than `max_line_width`.
 1658:         Defaults to ``numpy.get_printoptions()['linewidth']``.
 1659:     precision : int, optional
 1660:         Floating point precision.
 1661:         Defaults to ``numpy.get_printoptions()['precision']``.
 1662:     suppress_small : bool, optional
 1663:         Represent numbers "very close" to zero as zero; default is False.
 1664:         Very close is defined by precision: if the precision is 8, e.g.,
 1665:         numbers smaller (in absolute value) than 5e-9 are represented as
 1666:         zero.
 1667:         Defaults to ``numpy.get_printoptions()['suppress']``.
 1668: 
 1669:     Returns
 1670:     -------
 1671:     string : str
 1672:       The string representation of an array.
 1673: 
 1674:     See Also
 1675:     --------
 1676:     array_str, array2string, set_printoptions
 1677: 
 1678:     Examples
 1679:     --------
 1680:     >>> import numpy as np
 1681:     >>> np.array_repr(np.array([1,2]))
 1682:     'array([1, 2])'
 1683:     >>> np.array_repr(np.ma.array([0.]))
 1684:     'MaskedArray([0.])'
 1685:     >>> np.array_repr(np.array([], np.int32))
 1686:     'array([], dtype=int32)'
 1687: 
 1688:     >>> x = np.array([1e-6, 4e-7, 2, 3])
 1689:     >>> np.array_repr(x, precision=6, suppress_small=True)
 1690:     'array([0.000001,  0.      ,  2.      ,  3.      ])'
 1691: 
 1692:     """
 1693:     return _array_repr_implementation(
 1694:         arr, max_line_width, precision, suppress_small)
 1695: 
 1696: 
 1697: @_recursive_guard()
 1698: def _guarded_repr_or_str(v):
 1699:     if isinstance(v, bytes):
 1700:         return repr(v)
 1701:     return str(v)
 1702: 
 1703: 
 1704: def _array_str_implementation(
 1705:         a, max_line_width=None, precision=None, suppress_small=None,
 1706:         array2string=array2string):
 1707:     """Internal version of array_str() that allows overriding array2string."""
 1708:     if (format_options.get()['legacy'] <= 113 and
 1709:             a.shape == () and not a.dtype.names):
 1710:         return str(a.item())
 1711: 
 1712:     # the str of 0d arrays is a special case: It should appear like a scalar,
 1713:     # so floats are not truncated by `precision`, and strings are not wrapped
 1714:     # in quotes. So we return the str of the scalar value.
 1715:     if a.shape == ():
 1716:         # obtain a scalar and call str on it, avoiding problems for subclasses
 1717:         # for which indexing with () returns a 0d instead of a scalar by using
 1718:         # ndarray's getindex. Also guard against recursive 0d object arrays.
 1719:         return _guarded_repr_or_str(np.ndarray.__getitem__(a, ()))
 1720: 
 1721:     return array2string(a, max_line_width, precision, suppress_small, ' ', "")
 1722: 
 1723: 
 1724: def _array_str_dispatcher(
 1725:         a, max_line_width=None, precision=None, suppress_small=None):
 1726:     return (a,)
 1727: 
 1728: 
 1729: @array_function_dispatch(_array_str_dispatcher, module='numpy')
 1730: def array_str(a, max_line_width=None, precision=None, suppress_small=None):
 1731:     """
 1732:     Return a string representation of the data in an array.
 1733: 
 1734:     The data in the array is returned as a single string.  This function is
 1735:     similar to `array_repr`, the difference being that `array_repr` also
 1736:     returns information on the kind of array and its data type.
 1737: 
 1738:     Parameters
 1739:     ----------
 1740:     a : ndarray
 1741:         Input array.
 1742:     max_line_width : int, optional
 1743:         Inserts newlines if text is longer than `max_line_width`.
 1744:         Defaults to ``numpy.get_printoptions()['linewidth']``.
 1745:     precision : int, optional
 1746:         Floating point precision.
 1747:         Defaults to ``numpy.get_printoptions()['precision']``.
 1748:     suppress_small : bool, optional
 1749:         Represent numbers "very close" to zero as zero; default is False.
 1750:         Very close is defined by precision: if the precision is 8, e.g.,
 1751:         numbers smaller (in absolute value) than 5e-9 are represented as
 1752:         zero.
 1753:         Defaults to ``numpy.get_printoptions()['suppress']``.
 1754: 
 1755:     See Also
 1756:     --------
 1757:     array2string, array_repr, set_printoptions
 1758: 
 1759:     Examples
 1760:     --------
 1761:     >>> import numpy as np
 1762:     >>> np.array_str(np.arange(3))
 1763:     '[0 1 2]'
 1764: 
 1765:     """
 1766:     return _array_str_implementation(
 1767:         a, max_line_width, precision, suppress_small)
 1768: 
 1769: 
 1770: # needed if __array_function__ is disabled
 1771: _array2string_impl = getattr(array2string, '__wrapped__', array2string)
 1772: _default_array_str = functools.partial(_array_str_implementation,
 1773:                                        array2string=_array2string_impl)
 1774: _default_array_repr = functools.partial(_array_repr_implementation,
 1775:                                         array2string=_array2string_impl)
