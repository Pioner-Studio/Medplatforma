    1: """
    2: This file is separate from ``_add_newdocs.py`` so that it can be mocked out by
    3: our sphinx ``conf.py`` during doc builds, where we want to avoid showing
    4: platform-dependent information.
    5: """
    6: import os
    7: import sys
    8: 
    9: from numpy._core import dtype
   10: from numpy._core import numerictypes as _numerictypes
   11: from numpy._core.function_base import add_newdoc
   12: 
   13: ##############################################################################
   14: #
   15: # Documentation for concrete scalar classes
   16: #
   17: ##############################################################################
   18: 
   19: def numeric_type_aliases(aliases):
   20:     def type_aliases_gen():
   21:         for alias, doc in aliases:
   22:             try:
   23:                 alias_type = getattr(_numerictypes, alias)
   24:             except AttributeError:
   25:                 # The set of aliases that actually exist varies between platforms
   26:                 pass
   27:             else:
   28:                 yield (alias_type, alias, doc)
   29:     return list(type_aliases_gen())
   30: 
   31: 
   32: possible_aliases = numeric_type_aliases([
   33:     ('int8', '8-bit signed integer (``-128`` to ``127``)'),
   34:     ('int16', '16-bit signed integer (``-32_768`` to ``32_767``)'),
   35:     ('int32', '32-bit signed integer (``-2_147_483_648`` to ``2_147_483_647``)'),
   36:     ('int64', '64-bit signed integer (``-9_223_372_036_854_775_808`` to ``9_223_372_036_854_775_807``)'),
   37:     ('intp', 'Signed integer large enough to fit pointer, compatible with C ``intptr_t``'),
   38:     ('uint8', '8-bit unsigned integer (``0`` to ``255``)'),
   39:     ('uint16', '16-bit unsigned integer (``0`` to ``65_535``)'),
   40:     ('uint32', '32-bit unsigned integer (``0`` to ``4_294_967_295``)'),
   41:     ('uint64', '64-bit unsigned integer (``0`` to ``18_446_744_073_709_551_615``)'),
   42:     ('uintp', 'Unsigned integer large enough to fit pointer, compatible with C ``uintptr_t``'),
   43:     ('float16', '16-bit-precision floating-point number type: sign bit, 5 bits exponent, 10 bits mantissa'),
   44:     ('float32', '32-bit-precision floating-point number type: sign bit, 8 bits exponent, 23 bits mantissa'),
   45:     ('float64', '64-bit precision floating-point number type: sign bit, 11 bits exponent, 52 bits mantissa'),
   46:     ('float96', '96-bit extended-precision floating-point number type'),
   47:     ('float128', '128-bit extended-precision floating-point number type'),
   48:     ('complex64', 'Complex number type composed of 2 32-bit-precision floating-point numbers'),
   49:     ('complex128', 'Complex number type composed of 2 64-bit-precision floating-point numbers'),
   50:     ('complex192', 'Complex number type composed of 2 96-bit extended-precision floating-point numbers'),
   51:     ('complex256', 'Complex number type composed of 2 128-bit extended-precision floating-point numbers'),
   52:     ])
   53: 
   54: 
   55: def _get_platform_and_machine():
   56:     try:
   57:         system, _, _, _, machine = os.uname()
   58:     except AttributeError:
   59:         system = sys.platform
   60:         if system == 'win32':
   61:             machine = os.environ.get('PROCESSOR_ARCHITEW6432', '') \
   62:                     or os.environ.get('PROCESSOR_ARCHITECTURE', '')
   63:         else:
   64:             machine = 'unknown'
   65:     return system, machine
   66: 
   67: 
   68: _system, _machine = _get_platform_and_machine()
   69: _doc_alias_string = f":Alias on this platform ({_system} {_machine}):"
   70: 
   71: 
   72: def add_newdoc_for_scalar_type(obj, fixed_aliases, doc):
   73:     # note: `:field: value` is rST syntax which renders as field lists.
   74:     o = getattr(_numerictypes, obj)
   75: 
   76:     character_code = dtype(o).char
   77:     canonical_name_doc = "" if obj == o.__name__ else \
   78:                         f":Canonical name: `numpy.{obj}`\n    "
   79:     if fixed_aliases:
   80:         alias_doc = ''.join(f":Alias: `numpy.{alias}`\n    "
   81:                             for alias in fixed_aliases)
   82:     else:
   83:         alias_doc = ''
   84:     alias_doc += ''.join(f"{_doc_alias_string} `numpy.{alias}`: {doc}.\n    "
   85:                          for (alias_type, alias, doc) in possible_aliases if alias_type is o)
   86: 
   87:     docstring = f"""
   88:     {doc.strip()}
   89: 
   90:     :Character code: ``'{character_code}'``
   91:     {canonical_name_doc}{alias_doc}
   92:     """
   93: 
   94:     add_newdoc('numpy._core.numerictypes', obj, docstring)
   95: 
   96: 
   97: _bool_docstring = (
   98:     """
   99:     Boolean type (True or False), stored as a byte.
  100: 
  101:     .. warning::
  102: 
  103:        The :class:`bool` type is not a subclass of the :class:`int_` type
  104:        (the :class:`bool` is not even a number type). This is different
  105:        than Python's default implementation of :class:`bool` as a
  106:        sub-class of :class:`int`.
  107:     """
  108: )
  109: 
  110: add_newdoc_for_scalar_type('bool', [], _bool_docstring)
  111: 
  112: add_newdoc_for_scalar_type('bool_', [], _bool_docstring)
  113: 
  114: add_newdoc_for_scalar_type('byte', [],
  115:     """
  116:     Signed integer type, compatible with C ``char``.
  117:     """)
  118: 
  119: add_newdoc_for_scalar_type('short', [],
  120:     """
  121:     Signed integer type, compatible with C ``short``.
  122:     """)
  123: 
  124: add_newdoc_for_scalar_type('intc', [],
  125:     """
  126:     Signed integer type, compatible with C ``int``.
  127:     """)
  128: 
  129: # TODO: These docs probably need an if to highlight the default rather than
  130: #       the C-types (and be correct).
  131: add_newdoc_for_scalar_type('int_', [],
  132:     """
  133:     Default signed integer type, 64bit on 64bit systems and 32bit on 32bit
  134:     systems.
  135:     """)
  136: 
  137: add_newdoc_for_scalar_type('longlong', [],
  138:     """
  139:     Signed integer type, compatible with C ``long long``.
  140:     """)
  141: 
  142: add_newdoc_for_scalar_type('ubyte', [],
  143:     """
  144:     Unsigned integer type, compatible with C ``unsigned char``.
  145:     """)
  146: 
  147: add_newdoc_for_scalar_type('ushort', [],
  148:     """
  149:     Unsigned integer type, compatible with C ``unsigned short``.
  150:     """)
  151: 
  152: add_newdoc_for_scalar_type('uintc', [],
  153:     """
  154:     Unsigned integer type, compatible with C ``unsigned int``.
  155:     """)
  156: 
  157: add_newdoc_for_scalar_type('uint', [],
  158:     """
  159:     Unsigned signed integer type, 64bit on 64bit systems and 32bit on 32bit
  160:     systems.
  161:     """)
  162: 
  163: add_newdoc_for_scalar_type('ulonglong', [],
  164:     """
  165:     Signed integer type, compatible with C ``unsigned long long``.
  166:     """)
  167: 
  168: add_newdoc_for_scalar_type('half', [],
  169:     """
  170:     Half-precision floating-point number type.
  171:     """)
  172: 
  173: add_newdoc_for_scalar_type('single', [],
  174:     """
  175:     Single-precision floating-point number type, compatible with C ``float``.
  176:     """)
  177: 
  178: add_newdoc_for_scalar_type('double', [],
  179:     """
  180:     Double-precision floating-point number type, compatible with Python
  181:     :class:`float` and C ``double``.
  182:     """)
  183: 
  184: add_newdoc_for_scalar_type('longdouble', [],
  185:     """
  186:     Extended-precision floating-point number type, compatible with C
  187:     ``long double`` but not necessarily with IEEE 754 quadruple-precision.
  188:     """)
  189: 
  190: add_newdoc_for_scalar_type('csingle', [],
  191:     """
  192:     Complex number type composed of two single-precision floating-point
  193:     numbers.
  194:     """)
  195: 
  196: add_newdoc_for_scalar_type('cdouble', [],
  197:     """
  198:     Complex number type composed of two double-precision floating-point
  199:     numbers, compatible with Python :class:`complex`.
  200:     """)
  201: 
  202: add_newdoc_for_scalar_type('clongdouble', [],
  203:     """
  204:     Complex number type composed of two extended-precision floating-point
  205:     numbers.
  206:     """)
  207: 
  208: add_newdoc_for_scalar_type('object_', [],
  209:     """
  210:     Any Python object.
  211:     """)
  212: 
  213: add_newdoc_for_scalar_type('str_', [],
  214:     r"""
  215:     A unicode string.
  216: 
  217:     This type strips trailing null codepoints.
  218: 
  219:     >>> s = np.str_("abc\x00")
  220:     >>> s
  221:     'abc'
  222: 
  223:     Unlike the builtin :class:`str`, this supports the
  224:     :ref:`python:bufferobjects`, exposing its contents as UCS4:
  225: 
  226:     >>> m = memoryview(np.str_("abc"))
  227:     >>> m.format
  228:     '3w'
  229:     >>> m.tobytes()
  230:     b'a\x00\x00\x00b\x00\x00\x00c\x00\x00\x00'
  231:     """)
  232: 
  233: add_newdoc_for_scalar_type('bytes_', [],
  234:     r"""
  235:     A byte string.
  236: 
  237:     When used in arrays, this type strips trailing null bytes.
  238:     """)
  239: 
  240: add_newdoc_for_scalar_type('void', [],
  241:     r"""
  242:     np.void(length_or_data, /, dtype=None)
  243: 
  244:     Create a new structured or unstructured void scalar.
  245: 
  246:     Parameters
  247:     ----------
  248:     length_or_data : int, array-like, bytes-like, object
  249:        One of multiple meanings (see notes).  The length or
  250:        bytes data of an unstructured void.  Or alternatively,
  251:        the data to be stored in the new scalar when `dtype`
  252:        is provided.
  253:        This can be an array-like, in which case an array may
  254:        be returned.
  255:     dtype : dtype, optional
  256:        If provided the dtype of the new scalar.  This dtype must
  257:        be "void" dtype (i.e. a structured or unstructured void,
  258:        see also :ref:`defining-structured-types`).
  259: 
  260:        .. versionadded:: 1.24
  261: 
  262:     Notes
  263:     -----
  264:     For historical reasons and because void scalars can represent both
  265:     arbitrary byte data and structured dtypes, the void constructor
  266:     has three calling conventions:
  267: 
  268:     1. ``np.void(5)`` creates a ``dtype="V5"`` scalar filled with five
  269:        ``\0`` bytes.  The 5 can be a Python or NumPy integer.
  270:     2. ``np.void(b"bytes-like")`` creates a void scalar from the byte string.
  271:        The dtype itemsize will match the byte string length, here ``"V10"``.
  272:     3. When a ``dtype=`` is passed the call is roughly the same as an
  273:        array creation.  However, a void scalar rather than array is returned.
  274: 
  275:     Please see the examples which show all three different conventions.
  276: 
  277:     Examples
  278:     --------
  279:     >>> np.void(5)
  280:     np.void(b'\x00\x00\x00\x00\x00')
  281:     >>> np.void(b'abcd')
  282:     np.void(b'\x61\x62\x63\x64')
  283:     >>> np.void((3.2, b'eggs'), dtype="d,S5")
  284:     np.void((3.2, b'eggs'), dtype=[('f0', '<f8'), ('f1', 'S5')])
  285:     >>> np.void(3, dtype=[('x', np.int8), ('y', np.int8)])
  286:     np.void((3, 3), dtype=[('x', 'i1'), ('y', 'i1')])
  287: 
  288:     """)
  289: 
  290: add_newdoc_for_scalar_type('datetime64', [],
  291:     """
  292:     If created from a 64-bit integer, it represents an offset from
  293:     ``1970-01-01T00:00:00``.
  294:     If created from string, the string can be in ISO 8601 date
  295:     or datetime format.
  296: 
  297:     When parsing a string to create a datetime object, if the string contains
  298:     a trailing timezone (A 'Z' or a timezone offset), the timezone will be
  299:     dropped and a User Warning is given.
  300: 
  301:     Datetime64 objects should be considered to be UTC and therefore have an
  302:     offset of +0000.
  303: 
  304:     >>> np.datetime64(10, 'Y')
  305:     np.datetime64('1980')
  306:     >>> np.datetime64('1980', 'Y')
  307:     np.datetime64('1980')
  308:     >>> np.datetime64(10, 'D')
  309:     np.datetime64('1970-01-11')
  310: 
  311:     See :ref:`arrays.datetime` for more information.
  312:     """)
  313: 
  314: add_newdoc_for_scalar_type('timedelta64', [],
  315:     """
  316:     A timedelta stored as a 64-bit integer.
  317: 
  318:     See :ref:`arrays.datetime` for more information.
  319:     """)
  320: 
  321: add_newdoc('numpy._core.numerictypes', "integer", ('is_integer',
  322:     """
  323:     integer.is_integer() -> bool
  324: 
  325:     Return ``True`` if the number is finite with integral value.
  326: 
  327:     .. versionadded:: 1.22
  328: 
  329:     Examples
  330:     --------
  331:     >>> import numpy as np
  332:     >>> np.int64(-2).is_integer()
  333:     True
  334:     >>> np.uint32(5).is_integer()
  335:     True
  336:     """))
  337: 
  338: # TODO: work out how to put this on the base class, np.floating
  339: for float_name in ('half', 'single', 'double', 'longdouble'):
  340:     add_newdoc('numpy._core.numerictypes', float_name, ('as_integer_ratio',
  341:         f"""
  342:         {float_name}.as_integer_ratio() -> (int, int)
  343: 
  344:         Return a pair of integers, whose ratio is exactly equal to the original
  345:         floating point number, and with a positive denominator.
  346:         Raise `OverflowError` on infinities and a `ValueError` on NaNs.
  347: 
  348:         >>> np.{float_name}(10.0).as_integer_ratio()
  349:         (10, 1)
  350:         >>> np.{float_name}(0.0).as_integer_ratio()
  351:         (0, 1)
  352:         >>> np.{float_name}(-.25).as_integer_ratio()
  353:         (-1, 4)
  354:         """))
  355: 
  356:     add_newdoc('numpy._core.numerictypes', float_name, ('is_integer',
  357:         f"""
  358:         {float_name}.is_integer() -> bool
  359: 
  360:         Return ``True`` if the floating point number is finite with integral
  361:         value, and ``False`` otherwise.
  362: 
  363:         .. versionadded:: 1.22
  364: 
  365:         Examples
  366:         --------
  367:         >>> np.{float_name}(-2.0).is_integer()
  368:         True
  369:         >>> np.{float_name}(3.2).is_integer()
  370:         False
  371:         """))
  372: 
  373: for int_name in ('int8', 'uint8', 'int16', 'uint16', 'int32', 'uint32',
  374:         'int64', 'uint64', 'int64', 'uint64', 'int64', 'uint64'):
  375:     # Add negative examples for signed cases by checking typecode
  376:     add_newdoc('numpy._core.numerictypes', int_name, ('bit_count',
  377:         f"""
  378:         {int_name}.bit_count() -> int
  379: 
  380:         Computes the number of 1-bits in the absolute value of the input.
  381:         Analogous to the builtin `int.bit_count` or ``popcount`` in C++.
  382: 
  383:         Examples
  384:         --------
  385:         >>> np.{int_name}(127).bit_count()
  386:         7""" +
  387:         (f"""
  388:         >>> np.{int_name}(-127).bit_count()
  389:         7
  390:         """ if dtype(int_name).char.islower() else "")))
