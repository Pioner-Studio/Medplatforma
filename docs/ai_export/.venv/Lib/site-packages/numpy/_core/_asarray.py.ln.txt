    1: """
    2: Functions in the ``as*array`` family that promote array-likes into arrays.
    3: 
    4: `require` fits this category despite its name not matching this pattern.
    5: """
    6: from .multiarray import array, asanyarray
    7: from .overrides import (
    8:     array_function_dispatch,
    9:     finalize_array_function_like,
   10:     set_module,
   11: )
   12: 
   13: __all__ = ["require"]
   14: 
   15: 
   16: POSSIBLE_FLAGS = {
   17:     'C': 'C', 'C_CONTIGUOUS': 'C', 'CONTIGUOUS': 'C',
   18:     'F': 'F', 'F_CONTIGUOUS': 'F', 'FORTRAN': 'F',
   19:     'A': 'A', 'ALIGNED': 'A',
   20:     'W': 'W', 'WRITEABLE': 'W',
   21:     'O': 'O', 'OWNDATA': 'O',
   22:     'E': 'E', 'ENSUREARRAY': 'E'
   23: }
   24: 
   25: 
   26: @finalize_array_function_like
   27: @set_module('numpy')
   28: def require(a, dtype=None, requirements=None, *, like=None):
   29:     """
   30:     Return an ndarray of the provided type that satisfies requirements.
   31: 
   32:     This function is useful to be sure that an array with the correct flags
   33:     is returned for passing to compiled code (perhaps through ctypes).
   34: 
   35:     Parameters
   36:     ----------
   37:     a : array_like
   38:        The object to be converted to a type-and-requirement-satisfying array.
   39:     dtype : data-type
   40:        The required data-type. If None preserve the current dtype. If your
   41:        application requires the data to be in native byteorder, include
   42:        a byteorder specification as a part of the dtype specification.
   43:     requirements : str or sequence of str
   44:        The requirements list can be any of the following
   45: 
   46:        * 'F_CONTIGUOUS' ('F') - ensure a Fortran-contiguous array
   47:        * 'C_CONTIGUOUS' ('C') - ensure a C-contiguous array
   48:        * 'ALIGNED' ('A')      - ensure a data-type aligned array
   49:        * 'WRITEABLE' ('W')    - ensure a writable array
   50:        * 'OWNDATA' ('O')      - ensure an array that owns its own data
   51:        * 'ENSUREARRAY', ('E') - ensure a base array, instead of a subclass
   52:     ${ARRAY_FUNCTION_LIKE}
   53: 
   54:         .. versionadded:: 1.20.0
   55: 
   56:     Returns
   57:     -------
   58:     out : ndarray
   59:         Array with specified requirements and type if given.
   60: 
   61:     See Also
   62:     --------
   63:     asarray : Convert input to an ndarray.
   64:     asanyarray : Convert to an ndarray, but pass through ndarray subclasses.
   65:     ascontiguousarray : Convert input to a contiguous array.
   66:     asfortranarray : Convert input to an ndarray with column-major
   67:                      memory order.
   68:     ndarray.flags : Information about the memory layout of the array.
   69: 
   70:     Notes
   71:     -----
   72:     The returned array will be guaranteed to have the listed requirements
   73:     by making a copy if needed.
   74: 
   75:     Examples
   76:     --------
   77:     >>> import numpy as np
   78:     >>> x = np.arange(6).reshape(2,3)
   79:     >>> x.flags
   80:       C_CONTIGUOUS : True
   81:       F_CONTIGUOUS : False
   82:       OWNDATA : False
   83:       WRITEABLE : True
   84:       ALIGNED : True
   85:       WRITEBACKIFCOPY : False
   86: 
   87:     >>> y = np.require(x, dtype=np.float32, requirements=['A', 'O', 'W', 'F'])
   88:     >>> y.flags
   89:       C_CONTIGUOUS : False
   90:       F_CONTIGUOUS : True
   91:       OWNDATA : True
   92:       WRITEABLE : True
   93:       ALIGNED : True
   94:       WRITEBACKIFCOPY : False
   95: 
   96:     """
   97:     if like is not None:
   98:         return _require_with_like(
   99:             like,
  100:             a,
  101:             dtype=dtype,
  102:             requirements=requirements,
  103:         )
  104: 
  105:     if not requirements:
  106:         return asanyarray(a, dtype=dtype)
  107: 
  108:     requirements = {POSSIBLE_FLAGS[x.upper()] for x in requirements}
  109: 
  110:     if 'E' in requirements:
  111:         requirements.remove('E')
  112:         subok = False
  113:     else:
  114:         subok = True
  115: 
  116:     order = 'A'
  117:     if requirements >= {'C', 'F'}:
  118:         raise ValueError('Cannot specify both "C" and "F" order')
  119:     elif 'F' in requirements:
  120:         order = 'F'
  121:         requirements.remove('F')
  122:     elif 'C' in requirements:
  123:         order = 'C'
  124:         requirements.remove('C')
  125: 
  126:     arr = array(a, dtype=dtype, order=order, copy=None, subok=subok)
  127: 
  128:     for prop in requirements:
  129:         if not arr.flags[prop]:
  130:             return arr.copy(order)
  131:     return arr
  132: 
  133: 
  134: _require_with_like = array_function_dispatch()(require)
