    1: """
    2: Machine arithmetic - determine the parameters of the
    3: floating-point arithmetic system
    4: 
    5: Author: Pearu Peterson, September 2003
    6: 
    7: """
    8: __all__ = ['MachAr']
    9: 
   10: from ._ufunc_config import errstate
   11: from .fromnumeric import any
   12: 
   13: # Need to speed this up...especially for longdouble
   14: 
   15: # Deprecated 2021-10-20, NumPy 1.22
   16: class MachAr:
   17:     """
   18:     Diagnosing machine parameters.
   19: 
   20:     Attributes
   21:     ----------
   22:     ibeta : int
   23:         Radix in which numbers are represented.
   24:     it : int
   25:         Number of base-`ibeta` digits in the floating point mantissa M.
   26:     machep : int
   27:         Exponent of the smallest (most negative) power of `ibeta` that,
   28:         added to 1.0, gives something different from 1.0
   29:     eps : float
   30:         Floating-point number ``beta**machep`` (floating point precision)
   31:     negep : int
   32:         Exponent of the smallest power of `ibeta` that, subtracted
   33:         from 1.0, gives something different from 1.0.
   34:     epsneg : float
   35:         Floating-point number ``beta**negep``.
   36:     iexp : int
   37:         Number of bits in the exponent (including its sign and bias).
   38:     minexp : int
   39:         Smallest (most negative) power of `ibeta` consistent with there
   40:         being no leading zeros in the mantissa.
   41:     xmin : float
   42:         Floating-point number ``beta**minexp`` (the smallest [in
   43:         magnitude] positive floating point number with full precision).
   44:     maxexp : int
   45:         Smallest (positive) power of `ibeta` that causes overflow.
   46:     xmax : float
   47:         ``(1-epsneg) * beta**maxexp`` (the largest [in magnitude]
   48:         usable floating value).
   49:     irnd : int
   50:         In ``range(6)``, information on what kind of rounding is done
   51:         in addition, and on how underflow is handled.
   52:     ngrd : int
   53:         Number of 'guard digits' used when truncating the product
   54:         of two mantissas to fit the representation.
   55:     epsilon : float
   56:         Same as `eps`.
   57:     tiny : float
   58:         An alias for `smallest_normal`, kept for backwards compatibility.
   59:     huge : float
   60:         Same as `xmax`.
   61:     precision : float
   62:         ``- int(-log10(eps))``
   63:     resolution : float
   64:         ``- 10**(-precision)``
   65:     smallest_normal : float
   66:         The smallest positive floating point number with 1 as leading bit in
   67:         the mantissa following IEEE-754. Same as `xmin`.
   68:     smallest_subnormal : float
   69:         The smallest positive floating point number with 0 as leading bit in
   70:         the mantissa following IEEE-754.
   71: 
   72:     Parameters
   73:     ----------
   74:     float_conv : function, optional
   75:         Function that converts an integer or integer array to a float
   76:         or float array. Default is `float`.
   77:     int_conv : function, optional
   78:         Function that converts a float or float array to an integer or
   79:         integer array. Default is `int`.
   80:     float_to_float : function, optional
   81:         Function that converts a float array to float. Default is `float`.
   82:         Note that this does not seem to do anything useful in the current
   83:         implementation.
   84:     float_to_str : function, optional
   85:         Function that converts a single float to a string. Default is
   86:         ``lambda v:'%24.16e' %v``.
   87:     title : str, optional
   88:         Title that is printed in the string representation of `MachAr`.
   89: 
   90:     See Also
   91:     --------
   92:     finfo : Machine limits for floating point types.
   93:     iinfo : Machine limits for integer types.
   94: 
   95:     References
   96:     ----------
   97:     .. [1] Press, Teukolsky, Vetterling and Flannery,
   98:            "Numerical Recipes in C++," 2nd ed,
   99:            Cambridge University Press, 2002, p. 31.
  100: 
  101:     """
  102: 
  103:     def __init__(self, float_conv=float, int_conv=int,
  104:                  float_to_float=float,
  105:                  float_to_str=lambda v: f'{v:24.16e}',
  106:                  title='Python floating point number'):
  107:         """
  108: 
  109:         float_conv - convert integer to float (array)
  110:         int_conv   - convert float (array) to integer
  111:         float_to_float - convert float array to float
  112:         float_to_str - convert array float to str
  113:         title        - description of used floating point numbers
  114: 
  115:         """
  116:         # We ignore all errors here because we are purposely triggering
  117:         # underflow to detect the properties of the running arch.
  118:         with errstate(under='ignore'):
  119:             self._do_init(float_conv, int_conv, float_to_float, float_to_str, title)
  120: 
  121:     def _do_init(self, float_conv, int_conv, float_to_float, float_to_str, title):
  122:         max_iterN = 10000
  123:         msg = "Did not converge after %d tries with %s"
  124:         one = float_conv(1)
  125:         two = one + one
  126:         zero = one - one
  127: 
  128:         # Do we really need to do this?  Aren't they 2 and 2.0?
  129:         # Determine ibeta and beta
  130:         a = one
  131:         for _ in range(max_iterN):
  132:             a = a + a
  133:             temp = a + one
  134:             temp1 = temp - a
  135:             if any(temp1 - one != zero):
  136:                 break
  137:         else:
  138:             raise RuntimeError(msg % (_, one.dtype))
  139:         b = one
  140:         for _ in range(max_iterN):
  141:             b = b + b
  142:             temp = a + b
  143:             itemp = int_conv(temp - a)
  144:             if any(itemp != 0):
  145:                 break
  146:         else:
  147:             raise RuntimeError(msg % (_, one.dtype))
  148:         ibeta = itemp
  149:         beta = float_conv(ibeta)
  150: 
  151:         # Determine it and irnd
  152:         it = -1
  153:         b = one
  154:         for _ in range(max_iterN):
  155:             it = it + 1
  156:             b = b * beta
  157:             temp = b + one
  158:             temp1 = temp - b
  159:             if any(temp1 - one != zero):
  160:                 break
  161:         else:
  162:             raise RuntimeError(msg % (_, one.dtype))
  163: 
  164:         betah = beta / two
  165:         a = one
  166:         for _ in range(max_iterN):
  167:             a = a + a
  168:             temp = a + one
  169:             temp1 = temp - a
  170:             if any(temp1 - one != zero):
  171:                 break
  172:         else:
  173:             raise RuntimeError(msg % (_, one.dtype))
  174:         temp = a + betah
  175:         irnd = 0
  176:         if any(temp - a != zero):
  177:             irnd = 1
  178:         tempa = a + beta
  179:         temp = tempa + betah
  180:         if irnd == 0 and any(temp - tempa != zero):
  181:             irnd = 2
  182: 
  183:         # Determine negep and epsneg
  184:         negep = it + 3
  185:         betain = one / beta
  186:         a = one
  187:         for i in range(negep):
  188:             a = a * betain
  189:         b = a
  190:         for _ in range(max_iterN):
  191:             temp = one - a
  192:             if any(temp - one != zero):
  193:                 break
  194:             a = a * beta
  195:             negep = negep - 1
  196:             # Prevent infinite loop on PPC with gcc 4.0:
  197:             if negep < 0:
  198:                 raise RuntimeError("could not determine machine tolerance "
  199:                                    "for 'negep', locals() -> %s" % (locals()))
  200:         else:
  201:             raise RuntimeError(msg % (_, one.dtype))
  202:         negep = -negep
  203:         epsneg = a
  204: 
  205:         # Determine machep and eps
  206:         machep = - it - 3
  207:         a = b
  208: 
  209:         for _ in range(max_iterN):
  210:             temp = one + a
  211:             if any(temp - one != zero):
  212:                 break
  213:             a = a * beta
  214:             machep = machep + 1
  215:         else:
  216:             raise RuntimeError(msg % (_, one.dtype))
  217:         eps = a
  218: 
  219:         # Determine ngrd
  220:         ngrd = 0
  221:         temp = one + eps
  222:         if irnd == 0 and any(temp * one - one != zero):
  223:             ngrd = 1
  224: 
  225:         # Determine iexp
  226:         i = 0
  227:         k = 1
  228:         z = betain
  229:         t = one + eps
  230:         nxres = 0
  231:         for _ in range(max_iterN):
  232:             y = z
  233:             z = y * y
  234:             a = z * one  # Check here for underflow
  235:             temp = z * t
  236:             if any(a + a == zero) or any(abs(z) >= y):
  237:                 break
  238:             temp1 = temp * betain
  239:             if any(temp1 * beta == z):
  240:                 break
  241:             i = i + 1
  242:             k = k + k
  243:         else:
  244:             raise RuntimeError(msg % (_, one.dtype))
  245:         if ibeta != 10:
  246:             iexp = i + 1
  247:             mx = k + k
  248:         else:
  249:             iexp = 2
  250:             iz = ibeta
  251:             while k >= iz:
  252:                 iz = iz * ibeta
  253:                 iexp = iexp + 1
  254:             mx = iz + iz - 1
  255: 
  256:         # Determine minexp and xmin
  257:         for _ in range(max_iterN):
  258:             xmin = y
  259:             y = y * betain
  260:             a = y * one
  261:             temp = y * t
  262:             if any((a + a) != zero) and any(abs(y) < xmin):
  263:                 k = k + 1
  264:                 temp1 = temp * betain
  265:                 if any(temp1 * beta == y) and any(temp != y):
  266:                     nxres = 3
  267:                     xmin = y
  268:                     break
  269:             else:
  270:                 break
  271:         else:
  272:             raise RuntimeError(msg % (_, one.dtype))
  273:         minexp = -k
  274: 
  275:         # Determine maxexp, xmax
  276:         if mx <= k + k - 3 and ibeta != 10:
  277:             mx = mx + mx
  278:             iexp = iexp + 1
  279:         maxexp = mx + minexp
  280:         irnd = irnd + nxres
  281:         if irnd >= 2:
  282:             maxexp = maxexp - 2
  283:         i = maxexp + minexp
  284:         if ibeta == 2 and not i:
  285:             maxexp = maxexp - 1
  286:         if i > 20:
  287:             maxexp = maxexp - 1
  288:         if any(a != y):
  289:             maxexp = maxexp - 2
  290:         xmax = one - epsneg
  291:         if any(xmax * one != xmax):
  292:             xmax = one - beta * epsneg
  293:         xmax = xmax / (xmin * beta * beta * beta)
  294:         i = maxexp + minexp + 3
  295:         for j in range(i):
  296:             if ibeta == 2:
  297:                 xmax = xmax + xmax
  298:             else:
  299:                 xmax = xmax * beta
  300: 
  301:         smallest_subnormal = abs(xmin / beta ** (it))
  302: 
  303:         self.ibeta = ibeta
  304:         self.it = it
  305:         self.negep = negep
  306:         self.epsneg = float_to_float(epsneg)
  307:         self._str_epsneg = float_to_str(epsneg)
  308:         self.machep = machep
  309:         self.eps = float_to_float(eps)
  310:         self._str_eps = float_to_str(eps)
  311:         self.ngrd = ngrd
  312:         self.iexp = iexp
  313:         self.minexp = minexp
  314:         self.xmin = float_to_float(xmin)
  315:         self._str_xmin = float_to_str(xmin)
  316:         self.maxexp = maxexp
  317:         self.xmax = float_to_float(xmax)
  318:         self._str_xmax = float_to_str(xmax)
  319:         self.irnd = irnd
  320: 
  321:         self.title = title
  322:         # Commonly used parameters
  323:         self.epsilon = self.eps
  324:         self.tiny = self.xmin
  325:         self.huge = self.xmax
  326:         self.smallest_normal = self.xmin
  327:         self._str_smallest_normal = float_to_str(self.xmin)
  328:         self.smallest_subnormal = float_to_float(smallest_subnormal)
  329:         self._str_smallest_subnormal = float_to_str(smallest_subnormal)
  330: 
  331:         import math
  332:         self.precision = int(-math.log10(float_to_float(self.eps)))
  333:         ten = two + two + two + two + two
  334:         resolution = ten ** (-self.precision)
  335:         self.resolution = float_to_float(resolution)
  336:         self._str_resolution = float_to_str(resolution)
  337: 
  338:     def __str__(self):
  339:         fmt = (
  340:            'Machine parameters for %(title)s\n'
  341:            '---------------------------------------------------------------------\n'
  342:            'ibeta=%(ibeta)s it=%(it)s iexp=%(iexp)s ngrd=%(ngrd)s irnd=%(irnd)s\n'
  343:            'machep=%(machep)s     eps=%(_str_eps)s (beta**machep == epsilon)\n'
  344:            'negep =%(negep)s  epsneg=%(_str_epsneg)s (beta**epsneg)\n'
  345:            'minexp=%(minexp)s   xmin=%(_str_xmin)s (beta**minexp == tiny)\n'
  346:            'maxexp=%(maxexp)s    xmax=%(_str_xmax)s ((1-epsneg)*beta**maxexp == huge)\n'
  347:            'smallest_normal=%(smallest_normal)s    '
  348:            'smallest_subnormal=%(smallest_subnormal)s\n'
  349:            '---------------------------------------------------------------------\n'
  350:            )
  351:         return fmt % self.__dict__
  352: 
  353: 
  354: if __name__ == '__main__':
  355:     print(MachAr())
