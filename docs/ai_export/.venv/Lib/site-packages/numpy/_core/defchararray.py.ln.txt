    1: """
    2: This module contains a set of functions for vectorized string
    3: operations and methods.
    4: 
    5: .. note::
    6:    The `chararray` class exists for backwards compatibility with
    7:    Numarray, it is not recommended for new development. Starting from numpy
    8:    1.4, if one needs arrays of strings, it is recommended to use arrays of
    9:    `dtype` `object_`, `bytes_` or `str_`, and use the free functions
   10:    in the `numpy.char` module for fast vectorized string operations.
   11: 
   12: Some methods will only be available if the corresponding string method is
   13: available in your version of Python.
   14: 
   15: The preferred alias for `defchararray` is `numpy.char`.
   16: 
   17: """
   18: import functools
   19: 
   20: import numpy as np
   21: from numpy._core import overrides
   22: from numpy._core.multiarray import compare_chararrays
   23: from numpy._core.strings import (
   24:     _join as join,
   25: )
   26: from numpy._core.strings import (
   27:     _rsplit as rsplit,
   28: )
   29: from numpy._core.strings import (
   30:     _split as split,
   31: )
   32: from numpy._core.strings import (
   33:     _splitlines as splitlines,
   34: )
   35: from numpy._utils import set_module
   36: from numpy.strings import *
   37: from numpy.strings import (
   38:     multiply as strings_multiply,
   39: )
   40: from numpy.strings import (
   41:     partition as strings_partition,
   42: )
   43: from numpy.strings import (
   44:     rpartition as strings_rpartition,
   45: )
   46: 
   47: from .numeric import array as narray
   48: from .numeric import asarray as asnarray
   49: from .numeric import ndarray
   50: from .numerictypes import bytes_, character, str_
   51: 
   52: __all__ = [
   53:     'equal', 'not_equal', 'greater_equal', 'less_equal',
   54:     'greater', 'less', 'str_len', 'add', 'multiply', 'mod', 'capitalize',
   55:     'center', 'count', 'decode', 'encode', 'endswith', 'expandtabs',
   56:     'find', 'index', 'isalnum', 'isalpha', 'isdigit', 'islower', 'isspace',
   57:     'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'partition',
   58:     'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit',
   59:     'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase',
   60:     'title', 'translate', 'upper', 'zfill', 'isnumeric', 'isdecimal',
   61:     'array', 'asarray', 'compare_chararrays', 'chararray'
   62:     ]
   63: 
   64: 
   65: array_function_dispatch = functools.partial(
   66:     overrides.array_function_dispatch, module='numpy.char')
   67: 
   68: 
   69: def _binary_op_dispatcher(x1, x2):
   70:     return (x1, x2)
   71: 
   72: 
   73: @array_function_dispatch(_binary_op_dispatcher)
   74: def equal(x1, x2):
   75:     """
   76:     Return (x1 == x2) element-wise.
   77: 
   78:     Unlike `numpy.equal`, this comparison is performed by first
   79:     stripping whitespace characters from the end of the string.  This
   80:     behavior is provided for backward-compatibility with numarray.
   81: 
   82:     Parameters
   83:     ----------
   84:     x1, x2 : array_like of str or unicode
   85:         Input arrays of the same shape.
   86: 
   87:     Returns
   88:     -------
   89:     out : ndarray
   90:         Output array of bools.
   91: 
   92:     Examples
   93:     --------
   94:     >>> import numpy as np
   95:     >>> y = "aa "
   96:     >>> x = "aa"
   97:     >>> np.char.equal(x, y)
   98:     array(True)
   99: 
  100:     See Also
  101:     --------
  102:     not_equal, greater_equal, less_equal, greater, less
  103:     """
  104:     return compare_chararrays(x1, x2, '==', True)
  105: 
  106: 
  107: @array_function_dispatch(_binary_op_dispatcher)
  108: def not_equal(x1, x2):
  109:     """
  110:     Return (x1 != x2) element-wise.
  111: 
  112:     Unlike `numpy.not_equal`, this comparison is performed by first
  113:     stripping whitespace characters from the end of the string.  This
  114:     behavior is provided for backward-compatibility with numarray.
  115: 
  116:     Parameters
  117:     ----------
  118:     x1, x2 : array_like of str or unicode
  119:         Input arrays of the same shape.
  120: 
  121:     Returns
  122:     -------
  123:     out : ndarray
  124:         Output array of bools.
  125: 
  126:     See Also
  127:     --------
  128:     equal, greater_equal, less_equal, greater, less
  129: 
  130:     Examples
  131:     --------
  132:     >>> import numpy as np
  133:     >>> x1 = np.array(['a', 'b', 'c'])
  134:     >>> np.char.not_equal(x1, 'b')
  135:     array([ True, False,  True])
  136: 
  137:     """
  138:     return compare_chararrays(x1, x2, '!=', True)
  139: 
  140: 
  141: @array_function_dispatch(_binary_op_dispatcher)
  142: def greater_equal(x1, x2):
  143:     """
  144:     Return (x1 >= x2) element-wise.
  145: 
  146:     Unlike `numpy.greater_equal`, this comparison is performed by
  147:     first stripping whitespace characters from the end of the string.
  148:     This behavior is provided for backward-compatibility with
  149:     numarray.
  150: 
  151:     Parameters
  152:     ----------
  153:     x1, x2 : array_like of str or unicode
  154:         Input arrays of the same shape.
  155: 
  156:     Returns
  157:     -------
  158:     out : ndarray
  159:         Output array of bools.
  160: 
  161:     See Also
  162:     --------
  163:     equal, not_equal, less_equal, greater, less
  164: 
  165:     Examples
  166:     --------
  167:     >>> import numpy as np
  168:     >>> x1 = np.array(['a', 'b', 'c'])
  169:     >>> np.char.greater_equal(x1, 'b')
  170:     array([False,  True,  True])
  171: 
  172:     """
  173:     return compare_chararrays(x1, x2, '>=', True)
  174: 
  175: 
  176: @array_function_dispatch(_binary_op_dispatcher)
  177: def less_equal(x1, x2):
  178:     """
  179:     Return (x1 <= x2) element-wise.
  180: 
  181:     Unlike `numpy.less_equal`, this comparison is performed by first
  182:     stripping whitespace characters from the end of the string.  This
  183:     behavior is provided for backward-compatibility with numarray.
  184: 
  185:     Parameters
  186:     ----------
  187:     x1, x2 : array_like of str or unicode
  188:         Input arrays of the same shape.
  189: 
  190:     Returns
  191:     -------
  192:     out : ndarray
  193:         Output array of bools.
  194: 
  195:     See Also
  196:     --------
  197:     equal, not_equal, greater_equal, greater, less
  198: 
  199:     Examples
  200:     --------
  201:     >>> import numpy as np
  202:     >>> x1 = np.array(['a', 'b', 'c'])
  203:     >>> np.char.less_equal(x1, 'b')
  204:     array([ True,  True, False])
  205: 
  206:     """
  207:     return compare_chararrays(x1, x2, '<=', True)
  208: 
  209: 
  210: @array_function_dispatch(_binary_op_dispatcher)
  211: def greater(x1, x2):
  212:     """
  213:     Return (x1 > x2) element-wise.
  214: 
  215:     Unlike `numpy.greater`, this comparison is performed by first
  216:     stripping whitespace characters from the end of the string.  This
  217:     behavior is provided for backward-compatibility with numarray.
  218: 
  219:     Parameters
  220:     ----------
  221:     x1, x2 : array_like of str or unicode
  222:         Input arrays of the same shape.
  223: 
  224:     Returns
  225:     -------
  226:     out : ndarray
  227:         Output array of bools.
  228: 
  229:     See Also
  230:     --------
  231:     equal, not_equal, greater_equal, less_equal, less
  232: 
  233:     Examples
  234:     --------
  235:     >>> import numpy as np
  236:     >>> x1 = np.array(['a', 'b', 'c'])
  237:     >>> np.char.greater(x1, 'b')
  238:     array([False, False,  True])
  239: 
  240:     """
  241:     return compare_chararrays(x1, x2, '>', True)
  242: 
  243: 
  244: @array_function_dispatch(_binary_op_dispatcher)
  245: def less(x1, x2):
  246:     """
  247:     Return (x1 < x2) element-wise.
  248: 
  249:     Unlike `numpy.greater`, this comparison is performed by first
  250:     stripping whitespace characters from the end of the string.  This
  251:     behavior is provided for backward-compatibility with numarray.
  252: 
  253:     Parameters
  254:     ----------
  255:     x1, x2 : array_like of str or unicode
  256:         Input arrays of the same shape.
  257: 
  258:     Returns
  259:     -------
  260:     out : ndarray
  261:         Output array of bools.
  262: 
  263:     See Also
  264:     --------
  265:     equal, not_equal, greater_equal, less_equal, greater
  266: 
  267:     Examples
  268:     --------
  269:     >>> import numpy as np
  270:     >>> x1 = np.array(['a', 'b', 'c'])
  271:     >>> np.char.less(x1, 'b')
  272:     array([True, False, False])
  273: 
  274:     """
  275:     return compare_chararrays(x1, x2, '<', True)
  276: 
  277: 
  278: @set_module("numpy.char")
  279: def multiply(a, i):
  280:     """
  281:     Return (a * i), that is string multiple concatenation,
  282:     element-wise.
  283: 
  284:     Values in ``i`` of less than 0 are treated as 0 (which yields an
  285:     empty string).
  286: 
  287:     Parameters
  288:     ----------
  289:     a : array_like, with `np.bytes_` or `np.str_` dtype
  290: 
  291:     i : array_like, with any integer dtype
  292: 
  293:     Returns
  294:     -------
  295:     out : ndarray
  296:         Output array of str or unicode, depending on input types
  297: 
  298:     Notes
  299:     -----
  300:     This is a thin wrapper around np.strings.multiply that raises
  301:     `ValueError` when ``i`` is not an integer. It only
  302:     exists for backwards-compatibility.
  303: 
  304:     Examples
  305:     --------
  306:     >>> import numpy as np
  307:     >>> a = np.array(["a", "b", "c"])
  308:     >>> np.strings.multiply(a, 3)
  309:     array(['aaa', 'bbb', 'ccc'], dtype='<U3')
  310:     >>> i = np.array([1, 2, 3])
  311:     >>> np.strings.multiply(a, i)
  312:     array(['a', 'bb', 'ccc'], dtype='<U3')
  313:     >>> np.strings.multiply(np.array(['a']), i)
  314:     array(['a', 'aa', 'aaa'], dtype='<U3')
  315:     >>> a = np.array(['a', 'b', 'c', 'd', 'e', 'f']).reshape((2, 3))
  316:     >>> np.strings.multiply(a, 3)
  317:     array([['aaa', 'bbb', 'ccc'],
  318:            ['ddd', 'eee', 'fff']], dtype='<U3')
  319:     >>> np.strings.multiply(a, i)
  320:     array([['a', 'bb', 'ccc'],
  321:            ['d', 'ee', 'fff']], dtype='<U3')
  322: 
  323:     """
  324:     try:
  325:         return strings_multiply(a, i)
  326:     except TypeError:
  327:         raise ValueError("Can only multiply by integers")
  328: 
  329: 
  330: @set_module("numpy.char")
  331: def partition(a, sep):
  332:     """
  333:     Partition each element in `a` around `sep`.
  334: 
  335:     Calls :meth:`str.partition` element-wise.
  336: 
  337:     For each element in `a`, split the element as the first
  338:     occurrence of `sep`, and return 3 strings containing the part
  339:     before the separator, the separator itself, and the part after
  340:     the separator. If the separator is not found, return 3 strings
  341:     containing the string itself, followed by two empty strings.
  342: 
  343:     Parameters
  344:     ----------
  345:     a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
  346:         Input array
  347:     sep : {str, unicode}
  348:         Separator to split each string element in `a`.
  349: 
  350:     Returns
  351:     -------
  352:     out : ndarray
  353:         Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype,
  354:         depending on input types. The output array will have an extra
  355:         dimension with 3 elements per input element.
  356: 
  357:     Examples
  358:     --------
  359:     >>> import numpy as np
  360:     >>> x = np.array(["Numpy is nice!"])
  361:     >>> np.char.partition(x, " ")
  362:     array([['Numpy', ' ', 'is nice!']], dtype='<U8')
  363: 
  364:     See Also
  365:     --------
  366:     str.partition
  367: 
  368:     """
  369:     return np.stack(strings_partition(a, sep), axis=-1)
  370: 
  371: 
  372: @set_module("numpy.char")
  373: def rpartition(a, sep):
  374:     """
  375:     Partition (split) each element around the right-most separator.
  376: 
  377:     Calls :meth:`str.rpartition` element-wise.
  378: 
  379:     For each element in `a`, split the element as the last
  380:     occurrence of `sep`, and return 3 strings containing the part
  381:     before the separator, the separator itself, and the part after
  382:     the separator. If the separator is not found, return 3 strings
  383:     containing the string itself, followed by two empty strings.
  384: 
  385:     Parameters
  386:     ----------
  387:     a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype
  388:         Input array
  389:     sep : str or unicode
  390:         Right-most separator to split each element in array.
  391: 
  392:     Returns
  393:     -------
  394:     out : ndarray
  395:         Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype,
  396:         depending on input types. The output array will have an extra
  397:         dimension with 3 elements per input element.
  398: 
  399:     See Also
  400:     --------
  401:     str.rpartition
  402: 
  403:     Examples
  404:     --------
  405:     >>> import numpy as np
  406:     >>> a = np.array(['aAaAaA', '  aA  ', 'abBABba'])
  407:     >>> np.char.rpartition(a, 'A')
  408:     array([['aAaAa', 'A', ''],
  409:        ['  a', 'A', '  '],
  410:        ['abB', 'A', 'Bba']], dtype='<U5')
  411: 
  412:     """
  413:     return np.stack(strings_rpartition(a, sep), axis=-1)
  414: 
  415: 
  416: @set_module("numpy.char")
  417: class chararray(ndarray):
  418:     """
  419:     chararray(shape, itemsize=1, unicode=False, buffer=None, offset=0,
  420:               strides=None, order=None)
  421: 
  422:     Provides a convenient view on arrays of string and unicode values.
  423: 
  424:     .. note::
  425:        The `chararray` class exists for backwards compatibility with
  426:        Numarray, it is not recommended for new development. Starting from numpy
  427:        1.4, if one needs arrays of strings, it is recommended to use arrays of
  428:        `dtype` `~numpy.object_`, `~numpy.bytes_` or `~numpy.str_`, and use
  429:        the free functions in the `numpy.char` module for fast vectorized
  430:        string operations.
  431: 
  432:     Versus a NumPy array of dtype `~numpy.bytes_` or `~numpy.str_`, this
  433:     class adds the following functionality:
  434: 
  435:     1) values automatically have whitespace removed from the end
  436:        when indexed
  437: 
  438:     2) comparison operators automatically remove whitespace from the
  439:        end when comparing values
  440: 
  441:     3) vectorized string operations are provided as methods
  442:        (e.g. `.endswith`) and infix operators (e.g. ``"+", "*", "%"``)
  443: 
  444:     chararrays should be created using `numpy.char.array` or
  445:     `numpy.char.asarray`, rather than this constructor directly.
  446: 
  447:     This constructor creates the array, using `buffer` (with `offset`
  448:     and `strides`) if it is not ``None``. If `buffer` is ``None``, then
  449:     constructs a new array with `strides` in "C order", unless both
  450:     ``len(shape) >= 2`` and ``order='F'``, in which case `strides`
  451:     is in "Fortran order".
  452: 
  453:     Methods
  454:     -------
  455:     astype
  456:     argsort
  457:     copy
  458:     count
  459:     decode
  460:     dump
  461:     dumps
  462:     encode
  463:     endswith
  464:     expandtabs
  465:     fill
  466:     find
  467:     flatten
  468:     getfield
  469:     index
  470:     isalnum
  471:     isalpha
  472:     isdecimal
  473:     isdigit
  474:     islower
  475:     isnumeric
  476:     isspace
  477:     istitle
  478:     isupper
  479:     item
  480:     join
  481:     ljust
  482:     lower
  483:     lstrip
  484:     nonzero
  485:     put
  486:     ravel
  487:     repeat
  488:     replace
  489:     reshape
  490:     resize
  491:     rfind
  492:     rindex
  493:     rjust
  494:     rsplit
  495:     rstrip
  496:     searchsorted
  497:     setfield
  498:     setflags
  499:     sort
  500:     split
  501:     splitlines
  502:     squeeze
  503:     startswith
  504:     strip
  505:     swapaxes
  506:     swapcase
  507:     take
  508:     title
  509:     tofile
  510:     tolist
  511:     tostring
  512:     translate
  513:     transpose
  514:     upper
  515:     view
  516:     zfill
  517: 
  518:     Parameters
  519:     ----------
  520:     shape : tuple
  521:         Shape of the array.
  522:     itemsize : int, optional
  523:         Length of each array element, in number of characters. Default is 1.
  524:     unicode : bool, optional
  525:         Are the array elements of type unicode (True) or string (False).
  526:         Default is False.
  527:     buffer : object exposing the buffer interface or str, optional
  528:         Memory address of the start of the array data.  Default is None,
  529:         in which case a new array is created.
  530:     offset : int, optional
  531:         Fixed stride displacement from the beginning of an axis?
  532:         Default is 0. Needs to be >=0.
  533:     strides : array_like of ints, optional
  534:         Strides for the array (see `~numpy.ndarray.strides` for
  535:         full description). Default is None.
  536:     order : {'C', 'F'}, optional
  537:         The order in which the array data is stored in memory: 'C' ->
  538:         "row major" order (the default), 'F' -> "column major"
  539:         (Fortran) order.
  540: 
  541:     Examples
  542:     --------
  543:     >>> import numpy as np
  544:     >>> charar = np.char.chararray((3, 3))
  545:     >>> charar[:] = 'a'
  546:     >>> charar
  547:     chararray([[b'a', b'a', b'a'],
  548:                [b'a', b'a', b'a'],
  549:                [b'a', b'a', b'a']], dtype='|S1')
  550: 
  551:     >>> charar = np.char.chararray(charar.shape, itemsize=5)
  552:     >>> charar[:] = 'abc'
  553:     >>> charar
  554:     chararray([[b'abc', b'abc', b'abc'],
  555:                [b'abc', b'abc', b'abc'],
  556:                [b'abc', b'abc', b'abc']], dtype='|S5')
  557: 
  558:     """
  559:     def __new__(subtype, shape, itemsize=1, unicode=False, buffer=None,
  560:                 offset=0, strides=None, order='C'):
  561:         if unicode:
  562:             dtype = str_
  563:         else:
  564:             dtype = bytes_
  565: 
  566:         # force itemsize to be a Python int, since using NumPy integer
  567:         # types results in itemsize.itemsize being used as the size of
  568:         # strings in the new array.
  569:         itemsize = int(itemsize)
  570: 
  571:         if isinstance(buffer, str):
  572:             # unicode objects do not have the buffer interface
  573:             filler = buffer
  574:             buffer = None
  575:         else:
  576:             filler = None
  577: 
  578:         if buffer is None:
  579:             self = ndarray.__new__(subtype, shape, (dtype, itemsize),
  580:                                    order=order)
  581:         else:
  582:             self = ndarray.__new__(subtype, shape, (dtype, itemsize),
  583:                                    buffer=buffer,
  584:                                    offset=offset, strides=strides,
  585:                                    order=order)
  586:         if filler is not None:
  587:             self[...] = filler
  588: 
  589:         return self
  590: 
  591:     def __array_wrap__(self, arr, context=None, return_scalar=False):
  592:         # When calling a ufunc (and some other functions), we return a
  593:         # chararray if the ufunc output is a string-like array,
  594:         # or an ndarray otherwise
  595:         if arr.dtype.char in "SUbc":
  596:             return arr.view(type(self))
  597:         return arr
  598: 
  599:     def __array_finalize__(self, obj):
  600:         # The b is a special case because it is used for reconstructing.
  601:         if self.dtype.char not in 'VSUbc':
  602:             raise ValueError("Can only create a chararray from string data.")
  603: 
  604:     def __getitem__(self, obj):
  605:         val = ndarray.__getitem__(self, obj)
  606:         if isinstance(val, character):
  607:             return val.rstrip()
  608:         return val
  609: 
  610:     # IMPLEMENTATION NOTE: Most of the methods of this class are
  611:     # direct delegations to the free functions in this module.
  612:     # However, those that return an array of strings should instead
  613:     # return a chararray, so some extra wrapping is required.
  614: 
  615:     def __eq__(self, other):
  616:         """
  617:         Return (self == other) element-wise.
  618: 
  619:         See Also
  620:         --------
  621:         equal
  622:         """
  623:         return equal(self, other)
  624: 
  625:     def __ne__(self, other):
  626:         """
  627:         Return (self != other) element-wise.
  628: 
  629:         See Also
  630:         --------
  631:         not_equal
  632:         """
  633:         return not_equal(self, other)
  634: 
  635:     def __ge__(self, other):
  636:         """
  637:         Return (self >= other) element-wise.
  638: 
  639:         See Also
  640:         --------
  641:         greater_equal
  642:         """
  643:         return greater_equal(self, other)
  644: 
  645:     def __le__(self, other):
  646:         """
  647:         Return (self <= other) element-wise.
  648: 
  649:         See Also
  650:         --------
  651:         less_equal
  652:         """
  653:         return less_equal(self, other)
  654: 
  655:     def __gt__(self, other):
  656:         """
  657:         Return (self > other) element-wise.
  658: 
  659:         See Also
  660:         --------
  661:         greater
  662:         """
  663:         return greater(self, other)
  664: 
  665:     def __lt__(self, other):
  666:         """
  667:         Return (self < other) element-wise.
  668: 
  669:         See Also
  670:         --------
  671:         less
  672:         """
  673:         return less(self, other)
  674: 
  675:     def __add__(self, other):
  676:         """
  677:         Return (self + other), that is string concatenation,
  678:         element-wise for a pair of array_likes of str or unicode.
  679: 
  680:         See Also
  681:         --------
  682:         add
  683:         """
  684:         return add(self, other)
  685: 
  686:     def __radd__(self, other):
  687:         """
  688:         Return (other + self), that is string concatenation,
  689:         element-wise for a pair of array_likes of `bytes_` or `str_`.
  690: 
  691:         See Also
  692:         --------
  693:         add
  694:         """
  695:         return add(other, self)
  696: 
  697:     def __mul__(self, i):
  698:         """
  699:         Return (self * i), that is string multiple concatenation,
  700:         element-wise.
  701: 
  702:         See Also
  703:         --------
  704:         multiply
  705:         """
  706:         return asarray(multiply(self, i))
  707: 
  708:     def __rmul__(self, i):
  709:         """
  710:         Return (self * i), that is string multiple concatenation,
  711:         element-wise.
  712: 
  713:         See Also
  714:         --------
  715:         multiply
  716:         """
  717:         return asarray(multiply(self, i))
  718: 
  719:     def __mod__(self, i):
  720:         """
  721:         Return (self % i), that is pre-Python 2.6 string formatting
  722:         (interpolation), element-wise for a pair of array_likes of `bytes_`
  723:         or `str_`.
  724: 
  725:         See Also
  726:         --------
  727:         mod
  728:         """
  729:         return asarray(mod(self, i))
  730: 
  731:     def __rmod__(self, other):
  732:         return NotImplemented
  733: 
  734:     def argsort(self, axis=-1, kind=None, order=None):
  735:         """
  736:         Return the indices that sort the array lexicographically.
  737: 
  738:         For full documentation see `numpy.argsort`, for which this method is
  739:         in fact merely a "thin wrapper."
  740: 
  741:         Examples
  742:         --------
  743:         >>> c = np.array(['a1b c', '1b ca', 'b ca1', 'Ca1b'], 'S5')
  744:         >>> c = c.view(np.char.chararray); c
  745:         chararray(['a1b c', '1b ca', 'b ca1', 'Ca1b'],
  746:               dtype='|S5')
  747:         >>> c[c.argsort()]
  748:         chararray(['1b ca', 'Ca1b', 'a1b c', 'b ca1'],
  749:               dtype='|S5')
  750: 
  751:         """
  752:         return self.__array__().argsort(axis, kind, order)
  753:     argsort.__doc__ = ndarray.argsort.__doc__
  754: 
  755:     def capitalize(self):
  756:         """
  757:         Return a copy of `self` with only the first character of each element
  758:         capitalized.
  759: 
  760:         See Also
  761:         --------
  762:         char.capitalize
  763: 
  764:         """
  765:         return asarray(capitalize(self))
  766: 
  767:     def center(self, width, fillchar=' '):
  768:         """
  769:         Return a copy of `self` with its elements centered in a
  770:         string of length `width`.
  771: 
  772:         See Also
  773:         --------
  774:         center
  775:         """
  776:         return asarray(center(self, width, fillchar))
  777: 
  778:     def count(self, sub, start=0, end=None):
  779:         """
  780:         Returns an array with the number of non-overlapping occurrences of
  781:         substring `sub` in the range [`start`, `end`].
  782: 
  783:         See Also
  784:         --------
  785:         char.count
  786: 
  787:         """
  788:         return count(self, sub, start, end)
  789: 
  790:     def decode(self, encoding=None, errors=None):
  791:         """
  792:         Calls ``bytes.decode`` element-wise.
  793: 
  794:         See Also
  795:         --------
  796:         char.decode
  797: 
  798:         """
  799:         return decode(self, encoding, errors)
  800: 
  801:     def encode(self, encoding=None, errors=None):
  802:         """
  803:         Calls :meth:`str.encode` element-wise.
  804: 
  805:         See Also
  806:         --------
  807:         char.encode
  808: 
  809:         """
  810:         return encode(self, encoding, errors)
  811: 
  812:     def endswith(self, suffix, start=0, end=None):
  813:         """
  814:         Returns a boolean array which is `True` where the string element
  815:         in `self` ends with `suffix`, otherwise `False`.
  816: 
  817:         See Also
  818:         --------
  819:         char.endswith
  820: 
  821:         """
  822:         return endswith(self, suffix, start, end)
  823: 
  824:     def expandtabs(self, tabsize=8):
  825:         """
  826:         Return a copy of each string element where all tab characters are
  827:         replaced by one or more spaces.
  828: 
  829:         See Also
  830:         --------
  831:         char.expandtabs
  832: 
  833:         """
  834:         return asarray(expandtabs(self, tabsize))
  835: 
  836:     def find(self, sub, start=0, end=None):
  837:         """
  838:         For each element, return the lowest index in the string where
  839:         substring `sub` is found.
  840: 
  841:         See Also
  842:         --------
  843:         char.find
  844: 
  845:         """
  846:         return find(self, sub, start, end)
  847: 
  848:     def index(self, sub, start=0, end=None):
  849:         """
  850:         Like `find`, but raises :exc:`ValueError` when the substring is not
  851:         found.
  852: 
  853:         See Also
  854:         --------
  855:         char.index
  856: 
  857:         """
  858:         return index(self, sub, start, end)
  859: 
  860:     def isalnum(self):
  861:         """
  862:         Returns true for each element if all characters in the string
  863:         are alphanumeric and there is at least one character, false
  864:         otherwise.
  865: 
  866:         See Also
  867:         --------
  868:         char.isalnum
  869: 
  870:         """
  871:         return isalnum(self)
  872: 
  873:     def isalpha(self):
  874:         """
  875:         Returns true for each element if all characters in the string
  876:         are alphabetic and there is at least one character, false
  877:         otherwise.
  878: 
  879:         See Also
  880:         --------
  881:         char.isalpha
  882: 
  883:         """
  884:         return isalpha(self)
  885: 
  886:     def isdigit(self):
  887:         """
  888:         Returns true for each element if all characters in the string are
  889:         digits and there is at least one character, false otherwise.
  890: 
  891:         See Also
  892:         --------
  893:         char.isdigit
  894: 
  895:         """
  896:         return isdigit(self)
  897: 
  898:     def islower(self):
  899:         """
  900:         Returns true for each element if all cased characters in the
  901:         string are lowercase and there is at least one cased character,
  902:         false otherwise.
  903: 
  904:         See Also
  905:         --------
  906:         char.islower
  907: 
  908:         """
  909:         return islower(self)
  910: 
  911:     def isspace(self):
  912:         """
  913:         Returns true for each element if there are only whitespace
  914:         characters in the string and there is at least one character,
  915:         false otherwise.
  916: 
  917:         See Also
  918:         --------
  919:         char.isspace
  920: 
  921:         """
  922:         return isspace(self)
  923: 
  924:     def istitle(self):
  925:         """
  926:         Returns true for each element if the element is a titlecased
  927:         string and there is at least one character, false otherwise.
  928: 
  929:         See Also
  930:         --------
  931:         char.istitle
  932: 
  933:         """
  934:         return istitle(self)
  935: 
  936:     def isupper(self):
  937:         """
  938:         Returns true for each element if all cased characters in the
  939:         string are uppercase and there is at least one character, false
  940:         otherwise.
  941: 
  942:         See Also
  943:         --------
  944:         char.isupper
  945: 
  946:         """
  947:         return isupper(self)
  948: 
  949:     def join(self, seq):
  950:         """
  951:         Return a string which is the concatenation of the strings in the
  952:         sequence `seq`.
  953: 
  954:         See Also
  955:         --------
  956:         char.join
  957: 
  958:         """
  959:         return join(self, seq)
  960: 
  961:     def ljust(self, width, fillchar=' '):
  962:         """
  963:         Return an array with the elements of `self` left-justified in a
  964:         string of length `width`.
  965: 
  966:         See Also
  967:         --------
  968:         char.ljust
  969: 
  970:         """
  971:         return asarray(ljust(self, width, fillchar))
  972: 
  973:     def lower(self):
  974:         """
  975:         Return an array with the elements of `self` converted to
  976:         lowercase.
  977: 
  978:         See Also
  979:         --------
  980:         char.lower
  981: 
  982:         """
  983:         return asarray(lower(self))
  984: 
  985:     def lstrip(self, chars=None):
  986:         """
  987:         For each element in `self`, return a copy with the leading characters
  988:         removed.
  989: 
  990:         See Also
  991:         --------
  992:         char.lstrip
  993: 
  994:         """
  995:         return lstrip(self, chars)
  996: 
  997:     def partition(self, sep):
  998:         """
  999:         Partition each element in `self` around `sep`.
 1000: 
 1001:         See Also
 1002:         --------
 1003:         partition
 1004:         """
 1005:         return asarray(partition(self, sep))
 1006: 
 1007:     def replace(self, old, new, count=None):
 1008:         """
 1009:         For each element in `self`, return a copy of the string with all
 1010:         occurrences of substring `old` replaced by `new`.
 1011: 
 1012:         See Also
 1013:         --------
 1014:         char.replace
 1015: 
 1016:         """
 1017:         return replace(self, old, new, count if count is not None else -1)
 1018: 
 1019:     def rfind(self, sub, start=0, end=None):
 1020:         """
 1021:         For each element in `self`, return the highest index in the string
 1022:         where substring `sub` is found, such that `sub` is contained
 1023:         within [`start`, `end`].
 1024: 
 1025:         See Also
 1026:         --------
 1027:         char.rfind
 1028: 
 1029:         """
 1030:         return rfind(self, sub, start, end)
 1031: 
 1032:     def rindex(self, sub, start=0, end=None):
 1033:         """
 1034:         Like `rfind`, but raises :exc:`ValueError` when the substring `sub` is
 1035:         not found.
 1036: 
 1037:         See Also
 1038:         --------
 1039:         char.rindex
 1040: 
 1041:         """
 1042:         return rindex(self, sub, start, end)
 1043: 
 1044:     def rjust(self, width, fillchar=' '):
 1045:         """
 1046:         Return an array with the elements of `self`
 1047:         right-justified in a string of length `width`.
 1048: 
 1049:         See Also
 1050:         --------
 1051:         char.rjust
 1052: 
 1053:         """
 1054:         return asarray(rjust(self, width, fillchar))
 1055: 
 1056:     def rpartition(self, sep):
 1057:         """
 1058:         Partition each element in `self` around `sep`.
 1059: 
 1060:         See Also
 1061:         --------
 1062:         rpartition
 1063:         """
 1064:         return asarray(rpartition(self, sep))
 1065: 
 1066:     def rsplit(self, sep=None, maxsplit=None):
 1067:         """
 1068:         For each element in `self`, return a list of the words in
 1069:         the string, using `sep` as the delimiter string.
 1070: 
 1071:         See Also
 1072:         --------
 1073:         char.rsplit
 1074: 
 1075:         """
 1076:         return rsplit(self, sep, maxsplit)
 1077: 
 1078:     def rstrip(self, chars=None):
 1079:         """
 1080:         For each element in `self`, return a copy with the trailing
 1081:         characters removed.
 1082: 
 1083:         See Also
 1084:         --------
 1085:         char.rstrip
 1086: 
 1087:         """
 1088:         return rstrip(self, chars)
 1089: 
 1090:     def split(self, sep=None, maxsplit=None):
 1091:         """
 1092:         For each element in `self`, return a list of the words in the
 1093:         string, using `sep` as the delimiter string.
 1094: 
 1095:         See Also
 1096:         --------
 1097:         char.split
 1098: 
 1099:         """
 1100:         return split(self, sep, maxsplit)
 1101: 
 1102:     def splitlines(self, keepends=None):
 1103:         """
 1104:         For each element in `self`, return a list of the lines in the
 1105:         element, breaking at line boundaries.
 1106: 
 1107:         See Also
 1108:         --------
 1109:         char.splitlines
 1110: 
 1111:         """
 1112:         return splitlines(self, keepends)
 1113: 
 1114:     def startswith(self, prefix, start=0, end=None):
 1115:         """
 1116:         Returns a boolean array which is `True` where the string element
 1117:         in `self` starts with `prefix`, otherwise `False`.
 1118: 
 1119:         See Also
 1120:         --------
 1121:         char.startswith
 1122: 
 1123:         """
 1124:         return startswith(self, prefix, start, end)
 1125: 
 1126:     def strip(self, chars=None):
 1127:         """
 1128:         For each element in `self`, return a copy with the leading and
 1129:         trailing characters removed.
 1130: 
 1131:         See Also
 1132:         --------
 1133:         char.strip
 1134: 
 1135:         """
 1136:         return strip(self, chars)
 1137: 
 1138:     def swapcase(self):
 1139:         """
 1140:         For each element in `self`, return a copy of the string with
 1141:         uppercase characters converted to lowercase and vice versa.
 1142: 
 1143:         See Also
 1144:         --------
 1145:         char.swapcase
 1146: 
 1147:         """
 1148:         return asarray(swapcase(self))
 1149: 
 1150:     def title(self):
 1151:         """
 1152:         For each element in `self`, return a titlecased version of the
 1153:         string: words start with uppercase characters, all remaining cased
 1154:         characters are lowercase.
 1155: 
 1156:         See Also
 1157:         --------
 1158:         char.title
 1159: 
 1160:         """
 1161:         return asarray(title(self))
 1162: 
 1163:     def translate(self, table, deletechars=None):
 1164:         """
 1165:         For each element in `self`, return a copy of the string where
 1166:         all characters occurring in the optional argument
 1167:         `deletechars` are removed, and the remaining characters have
 1168:         been mapped through the given translation table.
 1169: 
 1170:         See Also
 1171:         --------
 1172:         char.translate
 1173: 
 1174:         """
 1175:         return asarray(translate(self, table, deletechars))
 1176: 
 1177:     def upper(self):
 1178:         """
 1179:         Return an array with the elements of `self` converted to
 1180:         uppercase.
 1181: 
 1182:         See Also
 1183:         --------
 1184:         char.upper
 1185: 
 1186:         """
 1187:         return asarray(upper(self))
 1188: 
 1189:     def zfill(self, width):
 1190:         """
 1191:         Return the numeric string left-filled with zeros in a string of
 1192:         length `width`.
 1193: 
 1194:         See Also
 1195:         --------
 1196:         char.zfill
 1197: 
 1198:         """
 1199:         return asarray(zfill(self, width))
 1200: 
 1201:     def isnumeric(self):
 1202:         """
 1203:         For each element in `self`, return True if there are only
 1204:         numeric characters in the element.
 1205: 
 1206:         See Also
 1207:         --------
 1208:         char.isnumeric
 1209: 
 1210:         """
 1211:         return isnumeric(self)
 1212: 
 1213:     def isdecimal(self):
 1214:         """
 1215:         For each element in `self`, return True if there are only
 1216:         decimal characters in the element.
 1217: 
 1218:         See Also
 1219:         --------
 1220:         char.isdecimal
 1221: 
 1222:         """
 1223:         return isdecimal(self)
 1224: 
 1225: 
 1226: @set_module("numpy.char")
 1227: def array(obj, itemsize=None, copy=True, unicode=None, order=None):
 1228:     """
 1229:     Create a `~numpy.char.chararray`.
 1230: 
 1231:     .. note::
 1232:        This class is provided for numarray backward-compatibility.
 1233:        New code (not concerned with numarray compatibility) should use
 1234:        arrays of type `bytes_` or `str_` and use the free functions
 1235:        in :mod:`numpy.char` for fast vectorized string operations instead.
 1236: 
 1237:     Versus a NumPy array of dtype `bytes_` or `str_`, this
 1238:     class adds the following functionality:
 1239: 
 1240:     1) values automatically have whitespace removed from the end
 1241:        when indexed
 1242: 
 1243:     2) comparison operators automatically remove whitespace from the
 1244:        end when comparing values
 1245: 
 1246:     3) vectorized string operations are provided as methods
 1247:        (e.g. `chararray.endswith <numpy.char.chararray.endswith>`)
 1248:        and infix operators (e.g. ``+, *, %``)
 1249: 
 1250:     Parameters
 1251:     ----------
 1252:     obj : array of str or unicode-like
 1253: 
 1254:     itemsize : int, optional
 1255:         `itemsize` is the number of characters per scalar in the
 1256:         resulting array.  If `itemsize` is None, and `obj` is an
 1257:         object array or a Python list, the `itemsize` will be
 1258:         automatically determined.  If `itemsize` is provided and `obj`
 1259:         is of type str or unicode, then the `obj` string will be
 1260:         chunked into `itemsize` pieces.
 1261: 
 1262:     copy : bool, optional
 1263:         If true (default), then the object is copied.  Otherwise, a copy
 1264:         will only be made if ``__array__`` returns a copy, if obj is a
 1265:         nested sequence, or if a copy is needed to satisfy any of the other
 1266:         requirements (`itemsize`, unicode, `order`, etc.).
 1267: 
 1268:     unicode : bool, optional
 1269:         When true, the resulting `~numpy.char.chararray` can contain Unicode
 1270:         characters, when false only 8-bit characters.  If unicode is
 1271:         None and `obj` is one of the following:
 1272: 
 1273:         - a `~numpy.char.chararray`,
 1274:         - an ndarray of type :class:`str_` or :class:`bytes_`
 1275:         - a Python :class:`str` or :class:`bytes` object,
 1276: 
 1277:         then the unicode setting of the output array will be
 1278:         automatically determined.
 1279: 
 1280:     order : {'C', 'F', 'A'}, optional
 1281:         Specify the order of the array.  If order is 'C' (default), then the
 1282:         array will be in C-contiguous order (last-index varies the
 1283:         fastest).  If order is 'F', then the returned array
 1284:         will be in Fortran-contiguous order (first-index varies the
 1285:         fastest).  If order is 'A', then the returned array may
 1286:         be in any order (either C-, Fortran-contiguous, or even
 1287:         discontiguous).
 1288: 
 1289:     Examples
 1290:     --------
 1291: 
 1292:     >>> import numpy as np
 1293:     >>> char_array = np.char.array(['hello', 'world', 'numpy','array'])
 1294:     >>> char_array
 1295:     chararray(['hello', 'world', 'numpy', 'array'], dtype='<U5')
 1296: 
 1297:     """
 1298:     if isinstance(obj, (bytes, str)):
 1299:         if unicode is None:
 1300:             if isinstance(obj, str):
 1301:                 unicode = True
 1302:             else:
 1303:                 unicode = False
 1304: 
 1305:         if itemsize is None:
 1306:             itemsize = len(obj)
 1307:         shape = len(obj) // itemsize
 1308: 
 1309:         return chararray(shape, itemsize=itemsize, unicode=unicode,
 1310:                          buffer=obj, order=order)
 1311: 
 1312:     if isinstance(obj, (list, tuple)):
 1313:         obj = asnarray(obj)
 1314: 
 1315:     if isinstance(obj, ndarray) and issubclass(obj.dtype.type, character):
 1316:         # If we just have a vanilla chararray, create a chararray
 1317:         # view around it.
 1318:         if not isinstance(obj, chararray):
 1319:             obj = obj.view(chararray)
 1320: 
 1321:         if itemsize is None:
 1322:             itemsize = obj.itemsize
 1323:             # itemsize is in 8-bit chars, so for Unicode, we need
 1324:             # to divide by the size of a single Unicode character,
 1325:             # which for NumPy is always 4
 1326:             if issubclass(obj.dtype.type, str_):
 1327:                 itemsize //= 4
 1328: 
 1329:         if unicode is None:
 1330:             if issubclass(obj.dtype.type, str_):
 1331:                 unicode = True
 1332:             else:
 1333:                 unicode = False
 1334: 
 1335:         if unicode:
 1336:             dtype = str_
 1337:         else:
 1338:             dtype = bytes_
 1339: 
 1340:         if order is not None:
 1341:             obj = asnarray(obj, order=order)
 1342:         if (copy or
 1343:                 (itemsize != obj.itemsize) or
 1344:                 (not unicode and isinstance(obj, str_)) or
 1345:                 (unicode and isinstance(obj, bytes_))):
 1346:             obj = obj.astype((dtype, int(itemsize)))
 1347:         return obj
 1348: 
 1349:     if isinstance(obj, ndarray) and issubclass(obj.dtype.type, object):
 1350:         if itemsize is None:
 1351:             # Since no itemsize was specified, convert the input array to
 1352:             # a list so the ndarray constructor will automatically
 1353:             # determine the itemsize for us.
 1354:             obj = obj.tolist()
 1355:             # Fall through to the default case
 1356: 
 1357:     if unicode:
 1358:         dtype = str_
 1359:     else:
 1360:         dtype = bytes_
 1361: 
 1362:     if itemsize is None:
 1363:         val = narray(obj, dtype=dtype, order=order, subok=True)
 1364:     else:
 1365:         val = narray(obj, dtype=(dtype, itemsize), order=order, subok=True)
 1366:     return val.view(chararray)
 1367: 
 1368: 
 1369: @set_module("numpy.char")
 1370: def asarray(obj, itemsize=None, unicode=None, order=None):
 1371:     """
 1372:     Convert the input to a `~numpy.char.chararray`, copying the data only if
 1373:     necessary.
 1374: 
 1375:     Versus a NumPy array of dtype `bytes_` or `str_`, this
 1376:     class adds the following functionality:
 1377: 
 1378:     1) values automatically have whitespace removed from the end
 1379:        when indexed
 1380: 
 1381:     2) comparison operators automatically remove whitespace from the
 1382:        end when comparing values
 1383: 
 1384:     3) vectorized string operations are provided as methods
 1385:        (e.g. `chararray.endswith <numpy.char.chararray.endswith>`)
 1386:        and infix operators (e.g. ``+``, ``*``, ``%``)
 1387: 
 1388:     Parameters
 1389:     ----------
 1390:     obj : array of str or unicode-like
 1391: 
 1392:     itemsize : int, optional
 1393:         `itemsize` is the number of characters per scalar in the
 1394:         resulting array.  If `itemsize` is None, and `obj` is an
 1395:         object array or a Python list, the `itemsize` will be
 1396:         automatically determined.  If `itemsize` is provided and `obj`
 1397:         is of type str or unicode, then the `obj` string will be
 1398:         chunked into `itemsize` pieces.
 1399: 
 1400:     unicode : bool, optional
 1401:         When true, the resulting `~numpy.char.chararray` can contain Unicode
 1402:         characters, when false only 8-bit characters.  If unicode is
 1403:         None and `obj` is one of the following:
 1404: 
 1405:         - a `~numpy.char.chararray`,
 1406:         - an ndarray of type `str_` or `unicode_`
 1407:         - a Python str or unicode object,
 1408: 
 1409:         then the unicode setting of the output array will be
 1410:         automatically determined.
 1411: 
 1412:     order : {'C', 'F'}, optional
 1413:         Specify the order of the array.  If order is 'C' (default), then the
 1414:         array will be in C-contiguous order (last-index varies the
 1415:         fastest).  If order is 'F', then the returned array
 1416:         will be in Fortran-contiguous order (first-index varies the
 1417:         fastest).
 1418: 
 1419:     Examples
 1420:     --------
 1421:     >>> import numpy as np
 1422:     >>> np.char.asarray(['hello', 'world'])
 1423:     chararray(['hello', 'world'], dtype='<U5')
 1424: 
 1425:     """
 1426:     return array(obj, itemsize, copy=False,
 1427:                  unicode=unicode, order=order)
