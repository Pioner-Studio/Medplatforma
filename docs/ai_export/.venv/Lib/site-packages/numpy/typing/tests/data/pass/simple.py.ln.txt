    1: """Simple expression that should pass with mypy."""
    2: import operator
    3: 
    4: import numpy as np
    5: import numpy.typing as npt
    6: from collections.abc import Iterable
    7: 
    8: # Basic checks
    9: array = np.array([1, 2])
   10: 
   11: 
   12: def ndarray_func(x: npt.NDArray[np.float64]) -> npt.NDArray[np.float64]:
   13:     return x
   14: 
   15: 
   16: ndarray_func(np.array([1, 2], dtype=np.float64))
   17: array == 1
   18: array.dtype == float
   19: 
   20: # Dtype construction
   21: np.dtype(float)
   22: np.dtype(np.float64)
   23: np.dtype(None)
   24: np.dtype("float64")
   25: np.dtype(np.dtype(float))
   26: np.dtype(("U", 10))
   27: np.dtype((np.int32, (2, 2)))
   28: # Define the arguments on the previous line to prevent bidirectional
   29: # type inference in mypy from broadening the types.
   30: two_tuples_dtype = [("R", "u1"), ("G", "u1"), ("B", "u1")]
   31: np.dtype(two_tuples_dtype)
   32: 
   33: three_tuples_dtype = [("R", "u1", 2)]
   34: np.dtype(three_tuples_dtype)
   35: 
   36: mixed_tuples_dtype = [("R", "u1"), ("G", np.str_, 1)]
   37: np.dtype(mixed_tuples_dtype)
   38: 
   39: shape_tuple_dtype = [("R", "u1", (2, 2))]
   40: np.dtype(shape_tuple_dtype)
   41: 
   42: shape_like_dtype = [("R", "u1", (2, 2)), ("G", np.str_, 1)]
   43: np.dtype(shape_like_dtype)
   44: 
   45: object_dtype = [("field1", object)]
   46: np.dtype(object_dtype)
   47: 
   48: np.dtype((np.int32, (np.int8, 4)))
   49: 
   50: # Dtype comparison
   51: np.dtype(float) == float
   52: np.dtype(float) != np.float64
   53: np.dtype(float) < None
   54: np.dtype(float) <= "float64"
   55: np.dtype(float) > np.dtype(float)
   56: np.dtype(float) >= np.dtype(("U", 10))
   57: 
   58: # Iteration and indexing
   59: def iterable_func(x: Iterable[object]) -> Iterable[object]:
   60:     return x
   61: 
   62: 
   63: iterable_func(array)
   64: list(array)
   65: iter(array)
   66: zip(array, array)
   67: array[1]
   68: array[:]
   69: array[...]
   70: array[:] = 0
   71: 
   72: array_2d = np.ones((3, 3))
   73: array_2d[:2, :2]
   74: array_2d[:2, :2] = 0
   75: array_2d[..., 0]
   76: array_2d[..., 0] = 2
   77: array_2d[-1, -1] = None
   78: 
   79: array_obj = np.zeros(1, dtype=np.object_)
   80: array_obj[0] = slice(None)
   81: 
   82: # Other special methods
   83: len(array)
   84: str(array)
   85: array_scalar = np.array(1)
   86: int(array_scalar)
   87: float(array_scalar)
   88: complex(array_scalar)
   89: bytes(array_scalar)
   90: operator.index(array_scalar)
   91: bool(array_scalar)
   92: 
   93: # comparisons
   94: array < 1
   95: array <= 1
   96: array == 1
   97: array != 1
   98: array > 1
   99: array >= 1
  100: 1 < array
  101: 1 <= array
  102: 1 == array
  103: 1 != array
  104: 1 > array
  105: 1 >= array
  106: 
  107: # binary arithmetic
  108: array + 1
  109: 1 + array
  110: array += 1
  111: 
  112: array - 1
  113: 1 - array
  114: array -= 1
  115: 
  116: array * 1
  117: 1 * array
  118: array *= 1
  119: 
  120: nonzero_array = np.array([1, 2])
  121: array / 1
  122: 1 / nonzero_array
  123: float_array = np.array([1.0, 2.0])
  124: float_array /= 1
  125: 
  126: array // 1
  127: 1 // nonzero_array
  128: array //= 1
  129: 
  130: array % 1
  131: 1 % nonzero_array
  132: array %= 1
  133: 
  134: divmod(array, 1)
  135: divmod(1, nonzero_array)
  136: 
  137: array ** 1
  138: 1 ** array
  139: array **= 1
  140: 
  141: array << 1
  142: 1 << array
  143: array <<= 1
  144: 
  145: array >> 1
  146: 1 >> array
  147: array >>= 1
  148: 
  149: array & 1
  150: 1 & array
  151: array &= 1
  152: 
  153: array ^ 1
  154: 1 ^ array
  155: array ^= 1
  156: 
  157: array | 1
  158: 1 | array
  159: array |= 1
  160: 
  161: # unary arithmetic
  162: -array
  163: +array
  164: abs(array)
  165: ~array
  166: 
  167: # Other methods
  168: np.array([1, 2]).transpose()
