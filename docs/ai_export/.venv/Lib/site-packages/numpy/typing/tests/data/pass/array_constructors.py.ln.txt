    1: from typing import Any
    2: 
    3: import numpy as np
    4: import numpy.typing as npt
    5: 
    6: class Index:
    7:     def __index__(self) -> int:
    8:         return 0
    9: 
   10: 
   11: class SubClass(npt.NDArray[np.float64]):
   12:     pass
   13: 
   14: 
   15: def func(i: int, j: int, **kwargs: Any) -> SubClass:
   16:     return B
   17: 
   18: 
   19: i8 = np.int64(1)
   20: 
   21: A = np.array([1])
   22: B = A.view(SubClass).copy()
   23: B_stack = np.array([[1], [1]]).view(SubClass)
   24: C = [1]
   25: 
   26: np.ndarray(Index())
   27: np.ndarray([Index()])
   28: 
   29: np.array(1, dtype=float)
   30: np.array(1, copy=None)
   31: np.array(1, order='F')
   32: np.array(1, order=None)
   33: np.array(1, subok=True)
   34: np.array(1, ndmin=3)
   35: np.array(1, str, copy=True, order='C', subok=False, ndmin=2)
   36: 
   37: np.asarray(A)
   38: np.asarray(B)
   39: np.asarray(C)
   40: 
   41: np.asanyarray(A)
   42: np.asanyarray(B)
   43: np.asanyarray(B, dtype=int)
   44: np.asanyarray(C)
   45: 
   46: np.ascontiguousarray(A)
   47: np.ascontiguousarray(B)
   48: np.ascontiguousarray(C)
   49: 
   50: np.asfortranarray(A)
   51: np.asfortranarray(B)
   52: np.asfortranarray(C)
   53: 
   54: np.require(A)
   55: np.require(B)
   56: np.require(B, dtype=int)
   57: np.require(B, requirements=None)
   58: np.require(B, requirements="E")
   59: np.require(B, requirements=["ENSUREARRAY"])
   60: np.require(B, requirements={"F", "E"})
   61: np.require(B, requirements=["C", "OWNDATA"])
   62: np.require(B, requirements="W")
   63: np.require(B, requirements="A")
   64: np.require(C)
   65: 
   66: np.linspace(0, 2)
   67: np.linspace(0.5, [0, 1, 2])
   68: np.linspace([0, 1, 2], 3)
   69: np.linspace(0j, 2)
   70: np.linspace(0, 2, num=10)
   71: np.linspace(0, 2, endpoint=True)
   72: np.linspace(0, 2, retstep=True)
   73: np.linspace(0j, 2j, retstep=True)
   74: np.linspace(0, 2, dtype=bool)
   75: np.linspace([0, 1], [2, 3], axis=Index())
   76: 
   77: np.logspace(0, 2, base=2)
   78: np.logspace(0, 2, base=2)
   79: np.logspace(0, 2, base=[1j, 2j], num=2)
   80: 
   81: np.geomspace(1, 2)
   82: 
   83: np.zeros_like(A)
   84: np.zeros_like(C)
   85: np.zeros_like(B)
   86: np.zeros_like(B, dtype=np.int64)
   87: 
   88: np.ones_like(A)
   89: np.ones_like(C)
   90: np.ones_like(B)
   91: np.ones_like(B, dtype=np.int64)
   92: 
   93: np.empty_like(A)
   94: np.empty_like(C)
   95: np.empty_like(B)
   96: np.empty_like(B, dtype=np.int64)
   97: 
   98: np.full_like(A, i8)
   99: np.full_like(C, i8)
  100: np.full_like(B, i8)
  101: np.full_like(B, i8, dtype=np.int64)
  102: 
  103: np.ones(1)
  104: np.ones([1, 1, 1])
  105: 
  106: np.full(1, i8)
  107: np.full([1, 1, 1], i8)
  108: 
  109: np.indices([1, 2, 3])
  110: np.indices([1, 2, 3], sparse=True)
  111: 
  112: np.fromfunction(func, (3, 5))
  113: 
  114: np.identity(10)
  115: 
  116: np.atleast_1d(C)
  117: np.atleast_1d(A)
  118: np.atleast_1d(C, C)
  119: np.atleast_1d(C, A)
  120: np.atleast_1d(A, A)
  121: 
  122: np.atleast_2d(C)
  123: 
  124: np.atleast_3d(C)
  125: 
  126: np.vstack([C, C])
  127: np.vstack([C, A])
  128: np.vstack([A, A])
  129: 
  130: np.hstack([C, C])
  131: 
  132: np.stack([C, C])
  133: np.stack([C, C], axis=0)
  134: np.stack([C, C], out=B_stack)
  135: 
  136: np.block([[C, C], [C, C]])
  137: np.block(A)
