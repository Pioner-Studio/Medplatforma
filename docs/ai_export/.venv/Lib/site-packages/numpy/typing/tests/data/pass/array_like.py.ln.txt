    1: from __future__ import annotations
    2: 
    3: from typing import TYPE_CHECKING
    4: 
    5: import numpy as np
    6: 
    7: if TYPE_CHECKING:
    8:     from numpy._typing import NDArray, ArrayLike, _SupportsArray
    9: 
   10: x1: ArrayLike = True
   11: x2: ArrayLike = 5
   12: x3: ArrayLike = 1.0
   13: x4: ArrayLike = 1 + 1j
   14: x5: ArrayLike = np.int8(1)
   15: x6: ArrayLike = np.float64(1)
   16: x7: ArrayLike = np.complex128(1)
   17: x8: ArrayLike = np.array([1, 2, 3])
   18: x9: ArrayLike = [1, 2, 3]
   19: x10: ArrayLike = (1, 2, 3)
   20: x11: ArrayLike = "foo"
   21: x12: ArrayLike = memoryview(b'foo')
   22: 
   23: 
   24: class A:
   25:     def __array__(self, dtype: np.dtype | None = None) -> NDArray[np.float64]:
   26:         return np.array([1.0, 2.0, 3.0])
   27: 
   28: 
   29: x13: ArrayLike = A()
   30: 
   31: scalar: _SupportsArray[np.dtype[np.int64]] = np.int64(1)
   32: scalar.__array__()
   33: array: _SupportsArray[np.dtype[np.int_]] = np.array(1)
   34: array.__array__()
   35: 
   36: a: _SupportsArray[np.dtype[np.float64]] = A()
   37: a.__array__()
   38: a.__array__()
   39: 
   40: # Escape hatch for when you mean to make something like an object
   41: # array.
   42: object_array_scalar: object = (i for i in range(10))
   43: np.array(object_array_scalar)
