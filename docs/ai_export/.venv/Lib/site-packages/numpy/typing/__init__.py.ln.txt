    1: """
    2: ============================
    3: Typing (:mod:`numpy.typing`)
    4: ============================
    5: 
    6: .. versionadded:: 1.20
    7: 
    8: Large parts of the NumPy API have :pep:`484`-style type annotations. In
    9: addition a number of type aliases are available to users, most prominently
   10: the two below:
   11: 
   12: - `ArrayLike`: objects that can be converted to arrays
   13: - `DTypeLike`: objects that can be converted to dtypes
   14: 
   15: .. _typing-extensions: https://pypi.org/project/typing-extensions/
   16: 
   17: Mypy plugin
   18: -----------
   19: 
   20: .. versionadded:: 1.21
   21: 
   22: .. automodule:: numpy.typing.mypy_plugin
   23: 
   24: .. currentmodule:: numpy.typing
   25: 
   26: Differences from the runtime NumPy API
   27: --------------------------------------
   28: 
   29: NumPy is very flexible. Trying to describe the full range of
   30: possibilities statically would result in types that are not very
   31: helpful. For that reason, the typed NumPy API is often stricter than
   32: the runtime NumPy API. This section describes some notable
   33: differences.
   34: 
   35: ArrayLike
   36: ~~~~~~~~~
   37: 
   38: The `ArrayLike` type tries to avoid creating object arrays. For
   39: example,
   40: 
   41: .. code-block:: python
   42: 
   43:     >>> np.array(x**2 for x in range(10))
   44:     array(<generator object <genexpr> at ...>, dtype=object)
   45: 
   46: is valid NumPy code which will create a 0-dimensional object
   47: array. Type checkers will complain about the above example when using
   48: the NumPy types however. If you really intended to do the above, then
   49: you can either use a ``# type: ignore`` comment:
   50: 
   51: .. code-block:: python
   52: 
   53:     >>> np.array(x**2 for x in range(10))  # type: ignore
   54: 
   55: or explicitly type the array like object as `~typing.Any`:
   56: 
   57: .. code-block:: python
   58: 
   59:     >>> from typing import Any
   60:     >>> array_like: Any = (x**2 for x in range(10))
   61:     >>> np.array(array_like)
   62:     array(<generator object <genexpr> at ...>, dtype=object)
   63: 
   64: ndarray
   65: ~~~~~~~
   66: 
   67: It's possible to mutate the dtype of an array at runtime. For example,
   68: the following code is valid:
   69: 
   70: .. code-block:: python
   71: 
   72:     >>> x = np.array([1, 2])
   73:     >>> x.dtype = np.bool
   74: 
   75: This sort of mutation is not allowed by the types. Users who want to
   76: write statically typed code should instead use the `numpy.ndarray.view`
   77: method to create a view of the array with a different dtype.
   78: 
   79: DTypeLike
   80: ~~~~~~~~~
   81: 
   82: The `DTypeLike` type tries to avoid creation of dtype objects using
   83: dictionary of fields like below:
   84: 
   85: .. code-block:: python
   86: 
   87:     >>> x = np.dtype({"field1": (float, 1), "field2": (int, 3)})
   88: 
   89: Although this is valid NumPy code, the type checker will complain about it,
   90: since its usage is discouraged.
   91: Please see : :ref:`Data type objects <arrays.dtypes>`
   92: 
   93: Number precision
   94: ~~~~~~~~~~~~~~~~
   95: 
   96: The precision of `numpy.number` subclasses is treated as a invariant generic
   97: parameter (see :class:`~NBitBase`), simplifying the annotating of processes
   98: involving precision-based casting.
   99: 
  100: .. code-block:: python
  101: 
  102:     >>> from typing import TypeVar
  103:     >>> import numpy as np
  104:     >>> import numpy.typing as npt
  105: 
  106:     >>> T = TypeVar("T", bound=npt.NBitBase)
  107:     >>> def func(a: "np.floating[T]", b: "np.floating[T]") -> "np.floating[T]":
  108:     ...     ...
  109: 
  110: Consequently, the likes of `~numpy.float16`, `~numpy.float32` and
  111: `~numpy.float64` are still sub-types of `~numpy.floating`, but, contrary to
  112: runtime, they're not necessarily considered as sub-classes.
  113: 
  114: Timedelta64
  115: ~~~~~~~~~~~
  116: 
  117: The `~numpy.timedelta64` class is not considered a subclass of
  118: `~numpy.signedinteger`, the former only inheriting from `~numpy.generic`
  119: while static type checking.
  120: 
  121: 0D arrays
  122: ~~~~~~~~~
  123: 
  124: During runtime numpy aggressively casts any passed 0D arrays into their
  125: corresponding `~numpy.generic` instance. Until the introduction of shape
  126: typing (see :pep:`646`) it is unfortunately not possible to make the
  127: necessary distinction between 0D and >0D arrays. While thus not strictly
  128: correct, all operations that can potentially perform a 0D-array -> scalar
  129: cast are currently annotated as exclusively returning an `~numpy.ndarray`.
  130: 
  131: If it is known in advance that an operation *will* perform a
  132: 0D-array -> scalar cast, then one can consider manually remedying the
  133: situation with either `typing.cast` or a ``# type: ignore`` comment.
  134: 
  135: Record array dtypes
  136: ~~~~~~~~~~~~~~~~~~~
  137: 
  138: The dtype of `numpy.recarray`, and the :ref:`routines.array-creation.rec`
  139: functions in general, can be specified in one of two ways:
  140: 
  141: * Directly via the ``dtype`` argument.
  142: * With up to five helper arguments that operate via `numpy.rec.format_parser`:
  143:   ``formats``, ``names``, ``titles``, ``aligned`` and ``byteorder``.
  144: 
  145: These two approaches are currently typed as being mutually exclusive,
  146: *i.e.* if ``dtype`` is specified than one may not specify ``formats``.
  147: While this mutual exclusivity is not (strictly) enforced during runtime,
  148: combining both dtype specifiers can lead to unexpected or even downright
  149: buggy behavior.
  150: 
  151: API
  152: ---
  153: 
  154: """
  155: # NOTE: The API section will be appended with additional entries
  156: # further down in this file
  157: 
  158: # pyright: reportDeprecated=false
  159: 
  160: from numpy._typing import ArrayLike, DTypeLike, NBitBase, NDArray
  161: 
  162: __all__ = ["ArrayLike", "DTypeLike", "NBitBase", "NDArray"]
  163: 
  164: 
  165: __DIR = __all__ + [k for k in globals() if k.startswith("__") and k.endswith("__")]
  166: __DIR_SET = frozenset(__DIR)
  167: 
  168: 
  169: def __dir__() -> list[str]:
  170:     return __DIR
  171: 
  172: def __getattr__(name: str):
  173:     if name == "NBitBase":
  174:         import warnings
  175: 
  176:         # Deprecated in NumPy 2.3, 2025-05-01
  177:         warnings.warn(
  178:             "`NBitBase` is deprecated and will be removed from numpy.typing in the "
  179:             "future. Use `@typing.overload` or a `TypeVar` with a scalar-type as upper "
  180:             "bound, instead. (deprecated in NumPy 2.3)",
  181:             DeprecationWarning,
  182:             stacklevel=2,
  183:         )
  184:         return NBitBase
  185: 
  186:     if name in __DIR_SET:
  187:         return globals()[name]
  188: 
  189:     raise AttributeError(f"module {__name__!r} has no attribute {name!r}")
  190: 
  191: 
  192: if __doc__ is not None:
  193:     from numpy._typing._add_docstring import _docstrings
  194:     __doc__ += _docstrings
  195:     __doc__ += '\n.. autoclass:: numpy.typing.NBitBase\n'
  196:     del _docstrings
  197: 
  198: from numpy._pytesttester import PytestTester
  199: 
  200: test = PytestTester(__name__)
  201: del PytestTester
