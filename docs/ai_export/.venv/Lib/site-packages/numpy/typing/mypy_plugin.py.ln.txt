    1: """A mypy_ plugin for managing a number of platform-specific annotations.
    2: Its functionality can be split into three distinct parts:
    3: 
    4: * Assigning the (platform-dependent) precisions of certain `~numpy.number`
    5:   subclasses, including the likes of `~numpy.int_`, `~numpy.intp` and
    6:   `~numpy.longlong`. See the documentation on
    7:   :ref:`scalar types <arrays.scalars.built-in>` for a comprehensive overview
    8:   of the affected classes. Without the plugin the precision of all relevant
    9:   classes will be inferred as `~typing.Any`.
   10: * Removing all extended-precision `~numpy.number` subclasses that are
   11:   unavailable for the platform in question. Most notably this includes the
   12:   likes of `~numpy.float128` and `~numpy.complex256`. Without the plugin *all*
   13:   extended-precision types will, as far as mypy is concerned, be available
   14:   to all platforms.
   15: * Assigning the (platform-dependent) precision of `~numpy.ctypeslib.c_intp`.
   16:   Without the plugin the type will default to `ctypes.c_int64`.
   17: 
   18:   .. versionadded:: 1.22
   19: 
   20: .. deprecated:: 2.3
   21: 
   22: Examples
   23: --------
   24: To enable the plugin, one must add it to their mypy `configuration file`_:
   25: 
   26: .. code-block:: ini
   27: 
   28:     [mypy]
   29:     plugins = numpy.typing.mypy_plugin
   30: 
   31: .. _mypy: https://mypy-lang.org/
   32: .. _configuration file: https://mypy.readthedocs.io/en/stable/config_file.html
   33: 
   34: """
   35: 
   36: from collections.abc import Callable, Iterable
   37: from typing import TYPE_CHECKING, Final, TypeAlias, cast
   38: 
   39: import numpy as np
   40: 
   41: __all__: list[str] = []
   42: 
   43: 
   44: def _get_precision_dict() -> dict[str, str]:
   45:     names = [
   46:         ("_NBitByte", np.byte),
   47:         ("_NBitShort", np.short),
   48:         ("_NBitIntC", np.intc),
   49:         ("_NBitIntP", np.intp),
   50:         ("_NBitInt", np.int_),
   51:         ("_NBitLong", np.long),
   52:         ("_NBitLongLong", np.longlong),
   53: 
   54:         ("_NBitHalf", np.half),
   55:         ("_NBitSingle", np.single),
   56:         ("_NBitDouble", np.double),
   57:         ("_NBitLongDouble", np.longdouble),
   58:     ]
   59:     ret: dict[str, str] = {}
   60:     for name, typ in names:
   61:         n = 8 * np.dtype(typ).itemsize
   62:         ret[f"{_MODULE}._nbit.{name}"] = f"{_MODULE}._nbit_base._{n}Bit"
   63:     return ret
   64: 
   65: 
   66: def _get_extended_precision_list() -> list[str]:
   67:     extended_names = [
   68:         "float96",
   69:         "float128",
   70:         "complex192",
   71:         "complex256",
   72:     ]
   73:     return [i for i in extended_names if hasattr(np, i)]
   74: 
   75: def _get_c_intp_name() -> str:
   76:     # Adapted from `np.core._internal._getintp_ctype`
   77:     return {
   78:         "i": "c_int",
   79:         "l": "c_long",
   80:         "q": "c_longlong",
   81:     }.get(np.dtype("n").char, "c_long")
   82: 
   83: 
   84: _MODULE: Final = "numpy._typing"
   85: 
   86: #: A dictionary mapping type-aliases in `numpy._typing._nbit` to
   87: #: concrete `numpy.typing.NBitBase` subclasses.
   88: _PRECISION_DICT: Final = _get_precision_dict()
   89: 
   90: #: A list with the names of all extended precision `np.number` subclasses.
   91: _EXTENDED_PRECISION_LIST: Final = _get_extended_precision_list()
   92: 
   93: #: The name of the ctypes equivalent of `np.intp`
   94: _C_INTP: Final = _get_c_intp_name()
   95: 
   96: 
   97: try:
   98:     if TYPE_CHECKING:
   99:         from mypy.typeanal import TypeAnalyser
  100: 
  101:     import mypy.types
  102:     from mypy.build import PRI_MED
  103:     from mypy.nodes import ImportFrom, MypyFile, Statement
  104:     from mypy.plugin import AnalyzeTypeContext, Plugin
  105: 
  106: except ModuleNotFoundError as e:
  107: 
  108:     def plugin(version: str) -> type:
  109:         raise e
  110: 
  111: else:
  112: 
  113:     _HookFunc: TypeAlias = Callable[[AnalyzeTypeContext], mypy.types.Type]
  114: 
  115:     def _hook(ctx: AnalyzeTypeContext) -> mypy.types.Type:
  116:         """Replace a type-alias with a concrete ``NBitBase`` subclass."""
  117:         typ, _, api = ctx
  118:         name = typ.name.split(".")[-1]
  119:         name_new = _PRECISION_DICT[f"{_MODULE}._nbit.{name}"]
  120:         return cast("TypeAnalyser", api).named_type(name_new)
  121: 
  122:     def _index(iterable: Iterable[Statement], id: str) -> int:
  123:         """Identify the first ``ImportFrom`` instance the specified `id`."""
  124:         for i, value in enumerate(iterable):
  125:             if getattr(value, "id", None) == id:
  126:                 return i
  127:         raise ValueError("Failed to identify a `ImportFrom` instance "
  128:                          f"with the following id: {id!r}")
  129: 
  130:     def _override_imports(
  131:         file: MypyFile,
  132:         module: str,
  133:         imports: list[tuple[str, str | None]],
  134:     ) -> None:
  135:         """Override the first `module`-based import with new `imports`."""
  136:         # Construct a new `from module import y` statement
  137:         import_obj = ImportFrom(module, 0, names=imports)
  138:         import_obj.is_top_level = True
  139: 
  140:         # Replace the first `module`-based import statement with `import_obj`
  141:         for lst in [file.defs, cast("list[Statement]", file.imports)]:
  142:             i = _index(lst, module)
  143:             lst[i] = import_obj
  144: 
  145:     class _NumpyPlugin(Plugin):
  146:         """A mypy plugin for handling versus numpy-specific typing tasks."""
  147: 
  148:         def get_type_analyze_hook(self, fullname: str) -> _HookFunc | None:
  149:             """Set the precision of platform-specific `numpy.number`
  150:             subclasses.
  151: 
  152:             For example: `numpy.int_`, `numpy.longlong` and `numpy.longdouble`.
  153:             """
  154:             if fullname in _PRECISION_DICT:
  155:                 return _hook
  156:             return None
  157: 
  158:         def get_additional_deps(
  159:             self, file: MypyFile
  160:         ) -> list[tuple[int, str, int]]:
  161:             """Handle all import-based overrides.
  162: 
  163:             * Import platform-specific extended-precision `numpy.number`
  164:               subclasses (*e.g.* `numpy.float96` and `numpy.float128`).
  165:             * Import the appropriate `ctypes` equivalent to `numpy.intp`.
  166: 
  167:             """
  168:             fullname = file.fullname
  169:             if fullname == "numpy":
  170:                 _override_imports(
  171:                     file,
  172:                     f"{_MODULE}._extended_precision",
  173:                     imports=[(v, v) for v in _EXTENDED_PRECISION_LIST],
  174:                 )
  175:             elif fullname == "numpy.ctypeslib":
  176:                 _override_imports(
  177:                     file,
  178:                     "ctypes",
  179:                     imports=[(_C_INTP, "_c_intp")],
  180:                 )
  181:             return [(PRI_MED, fullname, -1)]
  182: 
  183:     def plugin(version: str) -> type:
  184:         import warnings
  185: 
  186:         plugin = "numpy.typing.mypy_plugin"
  187:         # Deprecated 2025-01-10, NumPy 2.3
  188:         warn_msg = (
  189:             f"`{plugin}` is deprecated, and will be removed in a future "
  190:             f"release. Please remove `plugins = {plugin}` in your mypy config."
  191:             f"(deprecated in NumPy 2.3)"
  192:         )
  193:         warnings.warn(warn_msg, DeprecationWarning, stacklevel=3)
  194: 
  195:         return _NumpyPlugin
