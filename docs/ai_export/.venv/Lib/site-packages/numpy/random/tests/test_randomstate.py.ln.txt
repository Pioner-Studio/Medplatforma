    1: import hashlib
    2: import pickle
    3: import sys
    4: import warnings
    5: 
    6: import pytest
    7: 
    8: import numpy as np
    9: from numpy import random
   10: from numpy.random import MT19937, PCG64
   11: from numpy.testing import (
   12:     IS_WASM,
   13:     assert_,
   14:     assert_array_almost_equal,
   15:     assert_array_equal,
   16:     assert_equal,
   17:     assert_no_warnings,
   18:     assert_raises,
   19:     assert_warns,
   20:     suppress_warnings,
   21: )
   22: 
   23: INT_FUNCS = {'binomial': (100.0, 0.6),
   24:              'geometric': (.5,),
   25:              'hypergeometric': (20, 20, 10),
   26:              'logseries': (.5,),
   27:              'multinomial': (20, np.ones(6) / 6.0),
   28:              'negative_binomial': (100, .5),
   29:              'poisson': (10.0,),
   30:              'zipf': (2,),
   31:              }
   32: 
   33: if np.iinfo(np.long).max < 2**32:
   34:     # Windows and some 32-bit platforms, e.g., ARM
   35:     INT_FUNC_HASHES = {'binomial':          '2fbead005fc63942decb5326d36a1f32fe2c9d32c904ee61e46866b88447c263',  # noqa: E501
   36:                        'logseries':         '23ead5dcde35d4cfd4ef2c105e4c3d43304b45dc1b1444b7823b9ee4fa144ebb',  # noqa: E501
   37:                        'geometric':         '0d764db64f5c3bad48c8c33551c13b4d07a1e7b470f77629bef6c985cac76fcf',  # noqa: E501
   38:                        'hypergeometric':    '7b59bf2f1691626c5815cdcd9a49e1dd68697251d4521575219e4d2a1b8b2c67',  # noqa: E501
   39:                        'multinomial':       'd754fa5b92943a38ec07630de92362dd2e02c43577fc147417dc5b9db94ccdd3',  # noqa: E501
   40:                        'negative_binomial': '8eb216f7cb2a63cf55605422845caaff002fddc64a7dc8b2d45acd477a49e824',  # noqa: E501
   41:                        'poisson':           '70c891d76104013ebd6f6bcf30d403a9074b886ff62e4e6b8eb605bf1a4673b7',  # noqa: E501
   42:                        'zipf':              '01f074f97517cd5d21747148ac6ca4074dde7fcb7acbaec0a936606fecacd93f',  # noqa: E501
   43:                        }
   44: else:
   45:     INT_FUNC_HASHES = {'binomial':          '8626dd9d052cb608e93d8868de0a7b347258b199493871a1dc56e2a26cacb112',  # noqa: E501
   46:                        'geometric':         '8edd53d272e49c4fc8fbbe6c7d08d563d62e482921f3131d0a0e068af30f0db9',  # noqa: E501
   47:                        'hypergeometric':    '83496cc4281c77b786c9b7ad88b74d42e01603a55c60577ebab81c3ba8d45657',  # noqa: E501
   48:                        'logseries':         '65878a38747c176bc00e930ebafebb69d4e1e16cd3a704e264ea8f5e24f548db',  # noqa: E501
   49:                        'multinomial':       '7a984ae6dca26fd25374479e118b22f55db0aedccd5a0f2584ceada33db98605',  # noqa: E501
   50:                        'negative_binomial': 'd636d968e6a24ae92ab52fe11c46ac45b0897e98714426764e820a7d77602a61',  # noqa: E501
   51:                        'poisson':           '956552176f77e7c9cb20d0118fc9cf690be488d790ed4b4c4747b965e61b0bb4',  # noqa: E501
   52:                        'zipf':              'f84ba7feffda41e606e20b28dfc0f1ea9964a74574513d4a4cbc98433a8bfa45',  # noqa: E501
   53:                        }
   54: 
   55: 
   56: @pytest.fixture(scope='module', params=INT_FUNCS)
   57: def int_func(request):
   58:     return (request.param, INT_FUNCS[request.param],
   59:             INT_FUNC_HASHES[request.param])
   60: 
   61: 
   62: @pytest.fixture
   63: def restore_singleton_bitgen():
   64:     """Ensures that the singleton bitgen is restored after a test"""
   65:     orig_bitgen = np.random.get_bit_generator()
   66:     yield
   67:     np.random.set_bit_generator(orig_bitgen)
   68: 
   69: 
   70: def assert_mt19937_state_equal(a, b):
   71:     assert_equal(a['bit_generator'], b['bit_generator'])
   72:     assert_array_equal(a['state']['key'], b['state']['key'])
   73:     assert_array_equal(a['state']['pos'], b['state']['pos'])
   74:     assert_equal(a['has_gauss'], b['has_gauss'])
   75:     assert_equal(a['gauss'], b['gauss'])
   76: 
   77: 
   78: class TestSeed:
   79:     def test_scalar(self):
   80:         s = random.RandomState(0)
   81:         assert_equal(s.randint(1000), 684)
   82:         s = random.RandomState(4294967295)
   83:         assert_equal(s.randint(1000), 419)
   84: 
   85:     def test_array(self):
   86:         s = random.RandomState(range(10))
   87:         assert_equal(s.randint(1000), 468)
   88:         s = random.RandomState(np.arange(10))
   89:         assert_equal(s.randint(1000), 468)
   90:         s = random.RandomState([0])
   91:         assert_equal(s.randint(1000), 973)
   92:         s = random.RandomState([4294967295])
   93:         assert_equal(s.randint(1000), 265)
   94: 
   95:     def test_invalid_scalar(self):
   96:         # seed must be an unsigned 32 bit integer
   97:         assert_raises(TypeError, random.RandomState, -0.5)
   98:         assert_raises(ValueError, random.RandomState, -1)
   99: 
  100:     def test_invalid_array(self):
  101:         # seed must be an unsigned 32 bit integer
  102:         assert_raises(TypeError, random.RandomState, [-0.5])
  103:         assert_raises(ValueError, random.RandomState, [-1])
  104:         assert_raises(ValueError, random.RandomState, [4294967296])
  105:         assert_raises(ValueError, random.RandomState, [1, 2, 4294967296])
  106:         assert_raises(ValueError, random.RandomState, [1, -2, 4294967296])
  107: 
  108:     def test_invalid_array_shape(self):
  109:         # gh-9832
  110:         assert_raises(ValueError, random.RandomState, np.array([],
  111:                                                                dtype=np.int64))
  112:         assert_raises(ValueError, random.RandomState, [[1, 2, 3]])
  113:         assert_raises(ValueError, random.RandomState, [[1, 2, 3],
  114:                                                        [4, 5, 6]])
  115: 
  116:     def test_cannot_seed(self):
  117:         rs = random.RandomState(PCG64(0))
  118:         with assert_raises(TypeError):
  119:             rs.seed(1234)
  120: 
  121:     def test_invalid_initialization(self):
  122:         assert_raises(ValueError, random.RandomState, MT19937)
  123: 
  124: 
  125: class TestBinomial:
  126:     def test_n_zero(self):
  127:         # Tests the corner case of n == 0 for the binomial distribution.
  128:         # binomial(0, p) should be zero for any p in [0, 1].
  129:         # This test addresses issue #3480.
  130:         zeros = np.zeros(2, dtype='int')
  131:         for p in [0, .5, 1]:
  132:             assert_(random.binomial(0, p) == 0)
  133:             assert_array_equal(random.binomial(zeros, p), zeros)
  134: 
  135:     def test_p_is_nan(self):
  136:         # Issue #4571.
  137:         assert_raises(ValueError, random.binomial, 1, np.nan)
  138: 
  139: 
  140: class TestMultinomial:
  141:     def test_basic(self):
  142:         random.multinomial(100, [0.2, 0.8])
  143: 
  144:     def test_zero_probability(self):
  145:         random.multinomial(100, [0.2, 0.8, 0.0, 0.0, 0.0])
  146: 
  147:     def test_int_negative_interval(self):
  148:         assert_(-5 <= random.randint(-5, -1) < -1)
  149:         x = random.randint(-5, -1, 5)
  150:         assert_(np.all(-5 <= x))
  151:         assert_(np.all(x < -1))
  152: 
  153:     def test_size(self):
  154:         # gh-3173
  155:         p = [0.5, 0.5]
  156:         assert_equal(random.multinomial(1, p, np.uint32(1)).shape, (1, 2))
  157:         assert_equal(random.multinomial(1, p, np.uint32(1)).shape, (1, 2))
  158:         assert_equal(random.multinomial(1, p, np.uint32(1)).shape, (1, 2))
  159:         assert_equal(random.multinomial(1, p, [2, 2]).shape, (2, 2, 2))
  160:         assert_equal(random.multinomial(1, p, (2, 2)).shape, (2, 2, 2))
  161:         assert_equal(random.multinomial(1, p, np.array((2, 2))).shape,
  162:                      (2, 2, 2))
  163: 
  164:         assert_raises(TypeError, random.multinomial, 1, p,
  165:                       float(1))
  166: 
  167:     def test_invalid_prob(self):
  168:         assert_raises(ValueError, random.multinomial, 100, [1.1, 0.2])
  169:         assert_raises(ValueError, random.multinomial, 100, [-.1, 0.9])
  170: 
  171:     def test_invalid_n(self):
  172:         assert_raises(ValueError, random.multinomial, -1, [0.8, 0.2])
  173: 
  174:     def test_p_non_contiguous(self):
  175:         p = np.arange(15.)
  176:         p /= np.sum(p[1::3])
  177:         pvals = p[1::3]
  178:         random.seed(1432985819)
  179:         non_contig = random.multinomial(100, pvals=pvals)
  180:         random.seed(1432985819)
  181:         contig = random.multinomial(100, pvals=np.ascontiguousarray(pvals))
  182:         assert_array_equal(non_contig, contig)
  183: 
  184:     def test_multinomial_pvals_float32(self):
  185:         x = np.array([9.9e-01, 9.9e-01, 1.0e-09, 1.0e-09, 1.0e-09, 1.0e-09,
  186:                       1.0e-09, 1.0e-09, 1.0e-09, 1.0e-09], dtype=np.float32)
  187:         pvals = x / x.sum()
  188:         match = r"[\w\s]*pvals array is cast to 64-bit floating"
  189:         with pytest.raises(ValueError, match=match):
  190:             random.multinomial(1, pvals)
  191: 
  192:     def test_multinomial_n_float(self):
  193:         # Non-index integer types should gracefully truncate floats
  194:         random.multinomial(100.5, [0.2, 0.8])
  195: 
  196: class TestSetState:
  197:     def setup_method(self):
  198:         self.seed = 1234567890
  199:         self.random_state = random.RandomState(self.seed)
  200:         self.state = self.random_state.get_state()
  201: 
  202:     def test_basic(self):
  203:         old = self.random_state.tomaxint(16)
  204:         self.random_state.set_state(self.state)
  205:         new = self.random_state.tomaxint(16)
  206:         assert_(np.all(old == new))
  207: 
  208:     def test_gaussian_reset(self):
  209:         # Make sure the cached every-other-Gaussian is reset.
  210:         old = self.random_state.standard_normal(size=3)
  211:         self.random_state.set_state(self.state)
  212:         new = self.random_state.standard_normal(size=3)
  213:         assert_(np.all(old == new))
  214: 
  215:     def test_gaussian_reset_in_media_res(self):
  216:         # When the state is saved with a cached Gaussian, make sure the
  217:         # cached Gaussian is restored.
  218: 
  219:         self.random_state.standard_normal()
  220:         state = self.random_state.get_state()
  221:         old = self.random_state.standard_normal(size=3)
  222:         self.random_state.set_state(state)
  223:         new = self.random_state.standard_normal(size=3)
  224:         assert_(np.all(old == new))
  225: 
  226:     def test_backwards_compatibility(self):
  227:         # Make sure we can accept old state tuples that do not have the
  228:         # cached Gaussian value.
  229:         old_state = self.state[:-2]
  230:         x1 = self.random_state.standard_normal(size=16)
  231:         self.random_state.set_state(old_state)
  232:         x2 = self.random_state.standard_normal(size=16)
  233:         self.random_state.set_state(self.state)
  234:         x3 = self.random_state.standard_normal(size=16)
  235:         assert_(np.all(x1 == x2))
  236:         assert_(np.all(x1 == x3))
  237: 
  238:     def test_negative_binomial(self):
  239:         # Ensure that the negative binomial results take floating point
  240:         # arguments without truncation.
  241:         self.random_state.negative_binomial(0.5, 0.5)
  242: 
  243:     def test_get_state_warning(self):
  244:         rs = random.RandomState(PCG64())
  245:         with suppress_warnings() as sup:
  246:             w = sup.record(RuntimeWarning)
  247:             state = rs.get_state()
  248:             assert_(len(w) == 1)
  249:             assert isinstance(state, dict)
  250:             assert state['bit_generator'] == 'PCG64'
  251: 
  252:     def test_invalid_legacy_state_setting(self):
  253:         state = self.random_state.get_state()
  254:         new_state = ('Unknown', ) + state[1:]
  255:         assert_raises(ValueError, self.random_state.set_state, new_state)
  256:         assert_raises(TypeError, self.random_state.set_state,
  257:                       np.array(new_state, dtype=object))
  258:         state = self.random_state.get_state(legacy=False)
  259:         del state['bit_generator']
  260:         assert_raises(ValueError, self.random_state.set_state, state)
  261: 
  262:     def test_pickle(self):
  263:         self.random_state.seed(0)
  264:         self.random_state.random_sample(100)
  265:         self.random_state.standard_normal()
  266:         pickled = self.random_state.get_state(legacy=False)
  267:         assert_equal(pickled['has_gauss'], 1)
  268:         rs_unpick = pickle.loads(pickle.dumps(self.random_state))
  269:         unpickled = rs_unpick.get_state(legacy=False)
  270:         assert_mt19937_state_equal(pickled, unpickled)
  271: 
  272:     def test_state_setting(self):
  273:         attr_state = self.random_state.__getstate__()
  274:         self.random_state.standard_normal()
  275:         self.random_state.__setstate__(attr_state)
  276:         state = self.random_state.get_state(legacy=False)
  277:         assert_mt19937_state_equal(attr_state, state)
  278: 
  279:     def test_repr(self):
  280:         assert repr(self.random_state).startswith('RandomState(MT19937)')
  281: 
  282: 
  283: class TestRandint:
  284: 
  285:     rfunc = random.randint
  286: 
  287:     # valid integer/boolean types
  288:     itype = [np.bool, np.int8, np.uint8, np.int16, np.uint16,
  289:              np.int32, np.uint32, np.int64, np.uint64]
  290: 
  291:     def test_unsupported_type(self):
  292:         assert_raises(TypeError, self.rfunc, 1, dtype=float)
  293: 
  294:     def test_bounds_checking(self):
  295:         for dt in self.itype:
  296:             lbnd = 0 if dt is np.bool else np.iinfo(dt).min
  297:             ubnd = 2 if dt is np.bool else np.iinfo(dt).max + 1
  298:             assert_raises(ValueError, self.rfunc, lbnd - 1, ubnd, dtype=dt)
  299:             assert_raises(ValueError, self.rfunc, lbnd, ubnd + 1, dtype=dt)
  300:             assert_raises(ValueError, self.rfunc, ubnd, lbnd, dtype=dt)
  301:             assert_raises(ValueError, self.rfunc, 1, 0, dtype=dt)
  302: 
  303:     def test_rng_zero_and_extremes(self):
  304:         for dt in self.itype:
  305:             lbnd = 0 if dt is np.bool else np.iinfo(dt).min
  306:             ubnd = 2 if dt is np.bool else np.iinfo(dt).max + 1
  307: 
  308:             tgt = ubnd - 1
  309:             assert_equal(self.rfunc(tgt, tgt + 1, size=1000, dtype=dt), tgt)
  310: 
  311:             tgt = lbnd
  312:             assert_equal(self.rfunc(tgt, tgt + 1, size=1000, dtype=dt), tgt)
  313: 
  314:             tgt = (lbnd + ubnd) // 2
  315:             assert_equal(self.rfunc(tgt, tgt + 1, size=1000, dtype=dt), tgt)
  316: 
  317:     def test_full_range(self):
  318:         # Test for ticket #1690
  319: 
  320:         for dt in self.itype:
  321:             lbnd = 0 if dt is np.bool else np.iinfo(dt).min
  322:             ubnd = 2 if dt is np.bool else np.iinfo(dt).max + 1
  323: 
  324:             try:
  325:                 self.rfunc(lbnd, ubnd, dtype=dt)
  326:             except Exception as e:
  327:                 raise AssertionError("No error should have been raised, "
  328:                                      "but one was with the following "
  329:                                      "message:\n\n%s" % str(e))
  330: 
  331:     def test_in_bounds_fuzz(self):
  332:         # Don't use fixed seed
  333:         random.seed()
  334: 
  335:         for dt in self.itype[1:]:
  336:             for ubnd in [4, 8, 16]:
  337:                 vals = self.rfunc(2, ubnd, size=2**16, dtype=dt)
  338:                 assert_(vals.max() < ubnd)
  339:                 assert_(vals.min() >= 2)
  340: 
  341:         vals = self.rfunc(0, 2, size=2**16, dtype=np.bool)
  342: 
  343:         assert_(vals.max() < 2)
  344:         assert_(vals.min() >= 0)
  345: 
  346:     def test_repeatability(self):
  347:         # We use a sha256 hash of generated sequences of 1000 samples
  348:         # in the range [0, 6) for all but bool, where the range
  349:         # is [0, 2). Hashes are for little endian numbers.
  350:         tgt = {'bool':   '509aea74d792fb931784c4b0135392c65aec64beee12b0cc167548a2c3d31e71',  # noqa: E501
  351:                'int16':  '7b07f1a920e46f6d0fe02314155a2330bcfd7635e708da50e536c5ebb631a7d4',  # noqa: E501
  352:                'int32':  'e577bfed6c935de944424667e3da285012e741892dcb7051a8f1ce68ab05c92f',  # noqa: E501
  353:                'int64':  '0fbead0b06759df2cfb55e43148822d4a1ff953c7eb19a5b08445a63bb64fa9e',  # noqa: E501
  354:                'int8':   '001aac3a5acb935a9b186cbe14a1ca064b8bb2dd0b045d48abeacf74d0203404',  # noqa: E501
  355:                'uint16': '7b07f1a920e46f6d0fe02314155a2330bcfd7635e708da50e536c5ebb631a7d4',  # noqa: E501
  356:                'uint32': 'e577bfed6c935de944424667e3da285012e741892dcb7051a8f1ce68ab05c92f',  # noqa: E501
  357:                'uint64': '0fbead0b06759df2cfb55e43148822d4a1ff953c7eb19a5b08445a63bb64fa9e',  # noqa: E501
  358:                'uint8':  '001aac3a5acb935a9b186cbe14a1ca064b8bb2dd0b045d48abeacf74d0203404'}  # noqa: E501
  359: 
  360:         for dt in self.itype[1:]:
  361:             random.seed(1234)
  362: 
  363:             # view as little endian for hash
  364:             if sys.byteorder == 'little':
  365:                 val = self.rfunc(0, 6, size=1000, dtype=dt)
  366:             else:
  367:                 val = self.rfunc(0, 6, size=1000, dtype=dt).byteswap()
  368: 
  369:             res = hashlib.sha256(val.view(np.int8)).hexdigest()
  370:             assert_(tgt[np.dtype(dt).name] == res)
  371: 
  372:         # bools do not depend on endianness
  373:         random.seed(1234)
  374:         val = self.rfunc(0, 2, size=1000, dtype=bool).view(np.int8)
  375:         res = hashlib.sha256(val).hexdigest()
  376:         assert_(tgt[np.dtype(bool).name] == res)
  377: 
  378:     @pytest.mark.skipif(np.iinfo('l').max < 2**32,
  379:                         reason='Cannot test with 32-bit C long')
  380:     def test_repeatability_32bit_boundary_broadcasting(self):
  381:         desired = np.array([[[3992670689, 2438360420, 2557845020],
  382:                              [4107320065, 4142558326, 3216529513],
  383:                              [1605979228, 2807061240,  665605495]],
  384:                             [[3211410639, 4128781000,  457175120],
  385:                              [1712592594, 1282922662, 3081439808],
  386:                              [3997822960, 2008322436, 1563495165]],
  387:                             [[1398375547, 4269260146,  115316740],
  388:                              [3414372578, 3437564012, 2112038651],
  389:                              [3572980305, 2260248732, 3908238631]],
  390:                             [[2561372503,  223155946, 3127879445],
  391:                              [ 441282060, 3514786552, 2148440361],
  392:                              [1629275283, 3479737011, 3003195987]],
  393:                             [[ 412181688,  940383289, 3047321305],
  394:                              [2978368172,  764731833, 2282559898],
  395:                              [ 105711276,  720447391, 3596512484]]])
  396:         for size in [None, (5, 3, 3)]:
  397:             random.seed(12345)
  398:             x = self.rfunc([[-1], [0], [1]], [2**32 - 1, 2**32, 2**32 + 1],
  399:                            size=size)
  400:             assert_array_equal(x, desired if size is not None else desired[0])
  401: 
  402:     def test_int64_uint64_corner_case(self):
  403:         # When stored in Numpy arrays, `lbnd` is casted
  404:         # as np.int64, and `ubnd` is casted as np.uint64.
  405:         # Checking whether `lbnd` >= `ubnd` used to be
  406:         # done solely via direct comparison, which is incorrect
  407:         # because when Numpy tries to compare both numbers,
  408:         # it casts both to np.float64 because there is
  409:         # no integer superset of np.int64 and np.uint64. However,
  410:         # `ubnd` is too large to be represented in np.float64,
  411:         # causing it be round down to np.iinfo(np.int64).max,
  412:         # leading to a ValueError because `lbnd` now equals
  413:         # the new `ubnd`.
  414: 
  415:         dt = np.int64
  416:         tgt = np.iinfo(np.int64).max
  417:         lbnd = np.int64(np.iinfo(np.int64).max)
  418:         ubnd = np.uint64(np.iinfo(np.int64).max + 1)
  419: 
  420:         # None of these function calls should
  421:         # generate a ValueError now.
  422:         actual = random.randint(lbnd, ubnd, dtype=dt)
  423:         assert_equal(actual, tgt)
  424: 
  425:     def test_respect_dtype_singleton(self):
  426:         # See gh-7203
  427:         for dt in self.itype:
  428:             lbnd = 0 if dt is np.bool else np.iinfo(dt).min
  429:             ubnd = 2 if dt is np.bool else np.iinfo(dt).max + 1
  430: 
  431:             sample = self.rfunc(lbnd, ubnd, dtype=dt)
  432:             assert_equal(sample.dtype, np.dtype(dt))
  433: 
  434:         for dt in (bool, int):
  435:             # The legacy random generation forces the use of "long" on this
  436:             # branch even when the input is `int` and the default dtype
  437:             # for int changed (dtype=int is also the functions default)
  438:             op_dtype = "long" if dt is int else "bool"
  439:             lbnd = 0 if dt is bool else np.iinfo(op_dtype).min
  440:             ubnd = 2 if dt is bool else np.iinfo(op_dtype).max + 1
  441: 
  442:             sample = self.rfunc(lbnd, ubnd, dtype=dt)
  443:             assert_(not hasattr(sample, 'dtype'))
  444:             assert_equal(type(sample), dt)
  445: 
  446: 
  447: class TestRandomDist:
  448:     # Make sure the random distribution returns the correct value for a
  449:     # given seed
  450: 
  451:     def setup_method(self):
  452:         self.seed = 1234567890
  453: 
  454:     def test_rand(self):
  455:         random.seed(self.seed)
  456:         actual = random.rand(3, 2)
  457:         desired = np.array([[0.61879477158567997, 0.59162362775974664],
  458:                             [0.88868358904449662, 0.89165480011560816],
  459:                             [0.4575674820298663, 0.7781880808593471]])
  460:         assert_array_almost_equal(actual, desired, decimal=15)
  461: 
  462:     def test_rand_singleton(self):
  463:         random.seed(self.seed)
  464:         actual = random.rand()
  465:         desired = 0.61879477158567997
  466:         assert_array_almost_equal(actual, desired, decimal=15)
  467: 
  468:     def test_randn(self):
  469:         random.seed(self.seed)
  470:         actual = random.randn(3, 2)
  471:         desired = np.array([[1.34016345771863121, 1.73759122771936081],
  472:                            [1.498988344300628, -0.2286433324536169],
  473:                            [2.031033998682787, 2.17032494605655257]])
  474:         assert_array_almost_equal(actual, desired, decimal=15)
  475: 
  476:         random.seed(self.seed)
  477:         actual = random.randn()
  478:         assert_array_almost_equal(actual, desired[0, 0], decimal=15)
  479: 
  480:     def test_randint(self):
  481:         random.seed(self.seed)
  482:         actual = random.randint(-99, 99, size=(3, 2))
  483:         desired = np.array([[31, 3],
  484:                             [-52, 41],
  485:                             [-48, -66]])
  486:         assert_array_equal(actual, desired)
  487: 
  488:     def test_random_integers(self):
  489:         random.seed(self.seed)
  490:         with suppress_warnings() as sup:
  491:             w = sup.record(DeprecationWarning)
  492:             actual = random.random_integers(-99, 99, size=(3, 2))
  493:             assert_(len(w) == 1)
  494:         desired = np.array([[31, 3],
  495:                             [-52, 41],
  496:                             [-48, -66]])
  497:         assert_array_equal(actual, desired)
  498: 
  499:         random.seed(self.seed)
  500:         with suppress_warnings() as sup:
  501:             w = sup.record(DeprecationWarning)
  502:             actual = random.random_integers(198, size=(3, 2))
  503:             assert_(len(w) == 1)
  504:         assert_array_equal(actual, desired + 100)
  505: 
  506:     def test_tomaxint(self):
  507:         random.seed(self.seed)
  508:         rs = random.RandomState(self.seed)
  509:         actual = rs.tomaxint(size=(3, 2))
  510:         if np.iinfo(np.long).max == 2147483647:
  511:             desired = np.array([[1328851649,  731237375],
  512:                                 [1270502067,  320041495],
  513:                                 [1908433478,  499156889]], dtype=np.int64)
  514:         else:
  515:             desired = np.array([[5707374374421908479, 5456764827585442327],
  516:                                 [8196659375100692377, 8224063923314595285],
  517:                                 [4220315081820346526, 7177518203184491332]],
  518:                                dtype=np.int64)
  519: 
  520:         assert_equal(actual, desired)
  521: 
  522:         rs.seed(self.seed)
  523:         actual = rs.tomaxint()
  524:         assert_equal(actual, desired[0, 0])
  525: 
  526:     def test_random_integers_max_int(self):
  527:         # Tests whether random_integers can generate the
  528:         # maximum allowed Python int that can be converted
  529:         # into a C long. Previous implementations of this
  530:         # method have thrown an OverflowError when attempting
  531:         # to generate this integer.
  532:         with suppress_warnings() as sup:
  533:             w = sup.record(DeprecationWarning)
  534:             actual = random.random_integers(np.iinfo('l').max,
  535:                                             np.iinfo('l').max)
  536:             assert_(len(w) == 1)
  537: 
  538:         desired = np.iinfo('l').max
  539:         assert_equal(actual, desired)
  540:         with suppress_warnings() as sup:
  541:             w = sup.record(DeprecationWarning)
  542:             typer = np.dtype('l').type
  543:             actual = random.random_integers(typer(np.iinfo('l').max),
  544:                                             typer(np.iinfo('l').max))
  545:             assert_(len(w) == 1)
  546:         assert_equal(actual, desired)
  547: 
  548:     def test_random_integers_deprecated(self):
  549:         with warnings.catch_warnings():
  550:             warnings.simplefilter("error", DeprecationWarning)
  551: 
  552:             # DeprecationWarning raised with high == None
  553:             assert_raises(DeprecationWarning,
  554:                           random.random_integers,
  555:                           np.iinfo('l').max)
  556: 
  557:             # DeprecationWarning raised with high != None
  558:             assert_raises(DeprecationWarning,
  559:                           random.random_integers,
  560:                           np.iinfo('l').max, np.iinfo('l').max)
  561: 
  562:     def test_random_sample(self):
  563:         random.seed(self.seed)
  564:         actual = random.random_sample((3, 2))
  565:         desired = np.array([[0.61879477158567997, 0.59162362775974664],
  566:                             [0.88868358904449662, 0.89165480011560816],
  567:                             [0.4575674820298663, 0.7781880808593471]])
  568:         assert_array_almost_equal(actual, desired, decimal=15)
  569: 
  570:         random.seed(self.seed)
  571:         actual = random.random_sample()
  572:         assert_array_almost_equal(actual, desired[0, 0], decimal=15)
  573: 
  574:     def test_choice_uniform_replace(self):
  575:         random.seed(self.seed)
  576:         actual = random.choice(4, 4)
  577:         desired = np.array([2, 3, 2, 3])
  578:         assert_array_equal(actual, desired)
  579: 
  580:     def test_choice_nonuniform_replace(self):
  581:         random.seed(self.seed)
  582:         actual = random.choice(4, 4, p=[0.4, 0.4, 0.1, 0.1])
  583:         desired = np.array([1, 1, 2, 2])
  584:         assert_array_equal(actual, desired)
  585: 
  586:     def test_choice_uniform_noreplace(self):
  587:         random.seed(self.seed)
  588:         actual = random.choice(4, 3, replace=False)
  589:         desired = np.array([0, 1, 3])
  590:         assert_array_equal(actual, desired)
  591: 
  592:     def test_choice_nonuniform_noreplace(self):
  593:         random.seed(self.seed)
  594:         actual = random.choice(4, 3, replace=False, p=[0.1, 0.3, 0.5, 0.1])
  595:         desired = np.array([2, 3, 1])
  596:         assert_array_equal(actual, desired)
  597: 
  598:     def test_choice_noninteger(self):
  599:         random.seed(self.seed)
  600:         actual = random.choice(['a', 'b', 'c', 'd'], 4)
  601:         desired = np.array(['c', 'd', 'c', 'd'])
  602:         assert_array_equal(actual, desired)
  603: 
  604:     def test_choice_exceptions(self):
  605:         sample = random.choice
  606:         assert_raises(ValueError, sample, -1, 3)
  607:         assert_raises(ValueError, sample, 3., 3)
  608:         assert_raises(ValueError, sample, [[1, 2], [3, 4]], 3)
  609:         assert_raises(ValueError, sample, [], 3)
  610:         assert_raises(ValueError, sample, [1, 2, 3, 4], 3,
  611:                       p=[[0.25, 0.25], [0.25, 0.25]])
  612:         assert_raises(ValueError, sample, [1, 2], 3, p=[0.4, 0.4, 0.2])
  613:         assert_raises(ValueError, sample, [1, 2], 3, p=[1.1, -0.1])
  614:         assert_raises(ValueError, sample, [1, 2], 3, p=[0.4, 0.4])
  615:         assert_raises(ValueError, sample, [1, 2, 3], 4, replace=False)
  616:         # gh-13087
  617:         assert_raises(ValueError, sample, [1, 2, 3], -2, replace=False)
  618:         assert_raises(ValueError, sample, [1, 2, 3], (-1,), replace=False)
  619:         assert_raises(ValueError, sample, [1, 2, 3], (-1, 1), replace=False)
  620:         assert_raises(ValueError, sample, [1, 2, 3], 2,
  621:                       replace=False, p=[1, 0, 0])
  622: 
  623:     def test_choice_return_shape(self):
  624:         p = [0.1, 0.9]
  625:         # Check scalar
  626:         assert_(np.isscalar(random.choice(2, replace=True)))
  627:         assert_(np.isscalar(random.choice(2, replace=False)))
  628:         assert_(np.isscalar(random.choice(2, replace=True, p=p)))
  629:         assert_(np.isscalar(random.choice(2, replace=False, p=p)))
  630:         assert_(np.isscalar(random.choice([1, 2], replace=True)))
  631:         assert_(random.choice([None], replace=True) is None)
  632:         a = np.array([1, 2])
  633:         arr = np.empty(1, dtype=object)
  634:         arr[0] = a
  635:         assert_(random.choice(arr, replace=True) is a)
  636: 
  637:         # Check 0-d array
  638:         s = ()
  639:         assert_(not np.isscalar(random.choice(2, s, replace=True)))
  640:         assert_(not np.isscalar(random.choice(2, s, replace=False)))
  641:         assert_(not np.isscalar(random.choice(2, s, replace=True, p=p)))
  642:         assert_(not np.isscalar(random.choice(2, s, replace=False, p=p)))
  643:         assert_(not np.isscalar(random.choice([1, 2], s, replace=True)))
  644:         assert_(random.choice([None], s, replace=True).ndim == 0)
  645:         a = np.array([1, 2])
  646:         arr = np.empty(1, dtype=object)
  647:         arr[0] = a
  648:         assert_(random.choice(arr, s, replace=True).item() is a)
  649: 
  650:         # Check multi dimensional array
  651:         s = (2, 3)
  652:         p = [0.1, 0.1, 0.1, 0.1, 0.4, 0.2]
  653:         assert_equal(random.choice(6, s, replace=True).shape, s)
  654:         assert_equal(random.choice(6, s, replace=False).shape, s)
  655:         assert_equal(random.choice(6, s, replace=True, p=p).shape, s)
  656:         assert_equal(random.choice(6, s, replace=False, p=p).shape, s)
  657:         assert_equal(random.choice(np.arange(6), s, replace=True).shape, s)
  658: 
  659:         # Check zero-size
  660:         assert_equal(random.randint(0, 0, size=(3, 0, 4)).shape, (3, 0, 4))
  661:         assert_equal(random.randint(0, -10, size=0).shape, (0,))
  662:         assert_equal(random.randint(10, 10, size=0).shape, (0,))
  663:         assert_equal(random.choice(0, size=0).shape, (0,))
  664:         assert_equal(random.choice([], size=(0,)).shape, (0,))
  665:         assert_equal(random.choice(['a', 'b'], size=(3, 0, 4)).shape,
  666:                      (3, 0, 4))
  667:         assert_raises(ValueError, random.choice, [], 10)
  668: 
  669:     def test_choice_nan_probabilities(self):
  670:         a = np.array([42, 1, 2])
  671:         p = [None, None, None]
  672:         assert_raises(ValueError, random.choice, a, p=p)
  673: 
  674:     def test_choice_p_non_contiguous(self):
  675:         p = np.ones(10) / 5
  676:         p[1::2] = 3.0
  677:         random.seed(self.seed)
  678:         non_contig = random.choice(5, 3, p=p[::2])
  679:         random.seed(self.seed)
  680:         contig = random.choice(5, 3, p=np.ascontiguousarray(p[::2]))
  681:         assert_array_equal(non_contig, contig)
  682: 
  683:     def test_bytes(self):
  684:         random.seed(self.seed)
  685:         actual = random.bytes(10)
  686:         desired = b'\x82Ui\x9e\xff\x97+Wf\xa5'
  687:         assert_equal(actual, desired)
  688: 
  689:     def test_shuffle(self):
  690:         # Test lists, arrays (of various dtypes), and multidimensional versions
  691:         # of both, c-contiguous or not:
  692:         for conv in [lambda x: np.array([]),
  693:                      lambda x: x,
  694:                      lambda x: np.asarray(x).astype(np.int8),
  695:                      lambda x: np.asarray(x).astype(np.float32),
  696:                      lambda x: np.asarray(x).astype(np.complex64),
  697:                      lambda x: np.asarray(x).astype(object),
  698:                      lambda x: [(i, i) for i in x],
  699:                      lambda x: np.asarray([[i, i] for i in x]),
  700:                      lambda x: np.vstack([x, x]).T,
  701:                      # gh-11442
  702:                      lambda x: (np.asarray([(i, i) for i in x],
  703:                                            [("a", int), ("b", int)])
  704:                                 .view(np.recarray)),
  705:                      # gh-4270
  706:                      lambda x: np.asarray([(i, i) for i in x],
  707:                                           [("a", object, (1,)),
  708:                                            ("b", np.int32, (1,))])]:
  709:             random.seed(self.seed)
  710:             alist = conv([1, 2, 3, 4, 5, 6, 7, 8, 9, 0])
  711:             random.shuffle(alist)
  712:             actual = alist
  713:             desired = conv([0, 1, 9, 6, 2, 4, 5, 8, 7, 3])
  714:             assert_array_equal(actual, desired)
  715: 
  716:     def test_shuffle_masked(self):
  717:         # gh-3263
  718:         a = np.ma.masked_values(np.reshape(range(20), (5, 4)) % 3 - 1, -1)
  719:         b = np.ma.masked_values(np.arange(20) % 3 - 1, -1)
  720:         a_orig = a.copy()
  721:         b_orig = b.copy()
  722:         for i in range(50):
  723:             random.shuffle(a)
  724:             assert_equal(
  725:                 sorted(a.data[~a.mask]), sorted(a_orig.data[~a_orig.mask]))
  726:             random.shuffle(b)
  727:             assert_equal(
  728:                 sorted(b.data[~b.mask]), sorted(b_orig.data[~b_orig.mask]))
  729: 
  730:         def test_shuffle_invalid_objects(self):
  731:             x = np.array(3)
  732:             assert_raises(TypeError, random.shuffle, x)
  733: 
  734:     def test_permutation(self):
  735:         random.seed(self.seed)
  736:         alist = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
  737:         actual = random.permutation(alist)
  738:         desired = [0, 1, 9, 6, 2, 4, 5, 8, 7, 3]
  739:         assert_array_equal(actual, desired)
  740: 
  741:         random.seed(self.seed)
  742:         arr_2d = np.atleast_2d([1, 2, 3, 4, 5, 6, 7, 8, 9, 0]).T
  743:         actual = random.permutation(arr_2d)
  744:         assert_array_equal(actual, np.atleast_2d(desired).T)
  745: 
  746:         random.seed(self.seed)
  747:         bad_x_str = "abcd"
  748:         assert_raises(IndexError, random.permutation, bad_x_str)
  749: 
  750:         random.seed(self.seed)
  751:         bad_x_float = 1.2
  752:         assert_raises(IndexError, random.permutation, bad_x_float)
  753: 
  754:         integer_val = 10
  755:         desired = [9, 0, 8, 5, 1, 3, 4, 7, 6, 2]
  756: 
  757:         random.seed(self.seed)
  758:         actual = random.permutation(integer_val)
  759:         assert_array_equal(actual, desired)
  760: 
  761:     def test_beta(self):
  762:         random.seed(self.seed)
  763:         actual = random.beta(.1, .9, size=(3, 2))
  764:         desired = np.array(
  765:                 [[1.45341850513746058e-02, 5.31297615662868145e-04],
  766:                  [1.85366619058432324e-06, 4.19214516800110563e-03],
  767:                  [1.58405155108498093e-04, 1.26252891949397652e-04]])
  768:         assert_array_almost_equal(actual, desired, decimal=15)
  769: 
  770:     def test_binomial(self):
  771:         random.seed(self.seed)
  772:         actual = random.binomial(100.123, .456, size=(3, 2))
  773:         desired = np.array([[37, 43],
  774:                             [42, 48],
  775:                             [46, 45]])
  776:         assert_array_equal(actual, desired)
  777: 
  778:         random.seed(self.seed)
  779:         actual = random.binomial(100.123, .456)
  780:         desired = 37
  781:         assert_array_equal(actual, desired)
  782: 
  783:     def test_chisquare(self):
  784:         random.seed(self.seed)
  785:         actual = random.chisquare(50, size=(3, 2))
  786:         desired = np.array([[63.87858175501090585, 68.68407748911370447],
  787:                             [65.77116116901505904, 47.09686762438974483],
  788:                             [72.3828403199695174, 74.18408615260374006]])
  789:         assert_array_almost_equal(actual, desired, decimal=13)
  790: 
  791:     def test_dirichlet(self):
  792:         random.seed(self.seed)
  793:         alpha = np.array([51.72840233779265162, 39.74494232180943953])
  794:         actual = random.dirichlet(alpha, size=(3, 2))
  795:         desired = np.array([[[0.54539444573611562, 0.45460555426388438],
  796:                              [0.62345816822039413, 0.37654183177960598]],
  797:                             [[0.55206000085785778, 0.44793999914214233],
  798:                              [0.58964023305154301, 0.41035976694845688]],
  799:                             [[0.59266909280647828, 0.40733090719352177],
  800:                              [0.56974431743975207, 0.43025568256024799]]])
  801:         assert_array_almost_equal(actual, desired, decimal=15)
  802:         bad_alpha = np.array([5.4e-01, -1.0e-16])
  803:         assert_raises(ValueError, random.dirichlet, bad_alpha)
  804: 
  805:         random.seed(self.seed)
  806:         alpha = np.array([51.72840233779265162, 39.74494232180943953])
  807:         actual = random.dirichlet(alpha)
  808:         assert_array_almost_equal(actual, desired[0, 0], decimal=15)
  809: 
  810:     def test_dirichlet_size(self):
  811:         # gh-3173
  812:         p = np.array([51.72840233779265162, 39.74494232180943953])
  813:         assert_equal(random.dirichlet(p, np.uint32(1)).shape, (1, 2))
  814:         assert_equal(random.dirichlet(p, np.uint32(1)).shape, (1, 2))
  815:         assert_equal(random.dirichlet(p, np.uint32(1)).shape, (1, 2))
  816:         assert_equal(random.dirichlet(p, [2, 2]).shape, (2, 2, 2))
  817:         assert_equal(random.dirichlet(p, (2, 2)).shape, (2, 2, 2))
  818:         assert_equal(random.dirichlet(p, np.array((2, 2))).shape, (2, 2, 2))
  819: 
  820:         assert_raises(TypeError, random.dirichlet, p, float(1))
  821: 
  822:     def test_dirichlet_bad_alpha(self):
  823:         # gh-2089
  824:         alpha = np.array([5.4e-01, -1.0e-16])
  825:         assert_raises(ValueError, random.dirichlet, alpha)
  826: 
  827:     def test_dirichlet_alpha_non_contiguous(self):
  828:         a = np.array([51.72840233779265162, -1.0, 39.74494232180943953])
  829:         alpha = a[::2]
  830:         random.seed(self.seed)
  831:         non_contig = random.dirichlet(alpha, size=(3, 2))
  832:         random.seed(self.seed)
  833:         contig = random.dirichlet(np.ascontiguousarray(alpha),
  834:                                   size=(3, 2))
  835:         assert_array_almost_equal(non_contig, contig)
  836: 
  837:     def test_exponential(self):
  838:         random.seed(self.seed)
  839:         actual = random.exponential(1.1234, size=(3, 2))
  840:         desired = np.array([[1.08342649775011624, 1.00607889924557314],
  841:                             [2.46628830085216721, 2.49668106809923884],
  842:                             [0.68717433461363442, 1.69175666993575979]])
  843:         assert_array_almost_equal(actual, desired, decimal=15)
  844: 
  845:     def test_exponential_0(self):
  846:         assert_equal(random.exponential(scale=0), 0)
  847:         assert_raises(ValueError, random.exponential, scale=-0.)
  848: 
  849:     def test_f(self):
  850:         random.seed(self.seed)
  851:         actual = random.f(12, 77, size=(3, 2))
  852:         desired = np.array([[1.21975394418575878, 1.75135759791559775],
  853:                             [1.44803115017146489, 1.22108959480396262],
  854:                             [1.02176975757740629, 1.34431827623300415]])
  855:         assert_array_almost_equal(actual, desired, decimal=15)
  856: 
  857:     def test_gamma(self):
  858:         random.seed(self.seed)
  859:         actual = random.gamma(5, 3, size=(3, 2))
  860:         desired = np.array([[24.60509188649287182, 28.54993563207210627],
  861:                             [26.13476110204064184, 12.56988482927716078],
  862:                             [31.71863275789960568, 33.30143302795922011]])
  863:         assert_array_almost_equal(actual, desired, decimal=14)
  864: 
  865:     def test_gamma_0(self):
  866:         assert_equal(random.gamma(shape=0, scale=0), 0)
  867:         assert_raises(ValueError, random.gamma, shape=-0., scale=-0.)
  868: 
  869:     def test_geometric(self):
  870:         random.seed(self.seed)
  871:         actual = random.geometric(.123456789, size=(3, 2))
  872:         desired = np.array([[8, 7],
  873:                             [17, 17],
  874:                             [5, 12]])
  875:         assert_array_equal(actual, desired)
  876: 
  877:     def test_geometric_exceptions(self):
  878:         assert_raises(ValueError, random.geometric, 1.1)
  879:         assert_raises(ValueError, random.geometric, [1.1] * 10)
  880:         assert_raises(ValueError, random.geometric, -0.1)
  881:         assert_raises(ValueError, random.geometric, [-0.1] * 10)
  882:         with suppress_warnings() as sup:
  883:             sup.record(RuntimeWarning)
  884:             assert_raises(ValueError, random.geometric, np.nan)
  885:             assert_raises(ValueError, random.geometric, [np.nan] * 10)
  886: 
  887:     def test_gumbel(self):
  888:         random.seed(self.seed)
  889:         actual = random.gumbel(loc=.123456789, scale=2.0, size=(3, 2))
  890:         desired = np.array([[0.19591898743416816, 0.34405539668096674],
  891:                             [-1.4492522252274278, -1.47374816298446865],
  892:                             [1.10651090478803416, -0.69535848626236174]])
  893:         assert_array_almost_equal(actual, desired, decimal=15)
  894: 
  895:     def test_gumbel_0(self):
  896:         assert_equal(random.gumbel(scale=0), 0)
  897:         assert_raises(ValueError, random.gumbel, scale=-0.)
  898: 
  899:     def test_hypergeometric(self):
  900:         random.seed(self.seed)
  901:         actual = random.hypergeometric(10.1, 5.5, 14, size=(3, 2))
  902:         desired = np.array([[10, 10],
  903:                             [10, 10],
  904:                             [9, 9]])
  905:         assert_array_equal(actual, desired)
  906: 
  907:         # Test nbad = 0
  908:         actual = random.hypergeometric(5, 0, 3, size=4)
  909:         desired = np.array([3, 3, 3, 3])
  910:         assert_array_equal(actual, desired)
  911: 
  912:         actual = random.hypergeometric(15, 0, 12, size=4)
  913:         desired = np.array([12, 12, 12, 12])
  914:         assert_array_equal(actual, desired)
  915: 
  916:         # Test ngood = 0
  917:         actual = random.hypergeometric(0, 5, 3, size=4)
  918:         desired = np.array([0, 0, 0, 0])
  919:         assert_array_equal(actual, desired)
  920: 
  921:         actual = random.hypergeometric(0, 15, 12, size=4)
  922:         desired = np.array([0, 0, 0, 0])
  923:         assert_array_equal(actual, desired)
  924: 
  925:     def test_laplace(self):
  926:         random.seed(self.seed)
  927:         actual = random.laplace(loc=.123456789, scale=2.0, size=(3, 2))
  928:         desired = np.array([[0.66599721112760157, 0.52829452552221945],
  929:                             [3.12791959514407125, 3.18202813572992005],
  930:                             [-0.05391065675859356, 1.74901336242837324]])
  931:         assert_array_almost_equal(actual, desired, decimal=15)
  932: 
  933:     def test_laplace_0(self):
  934:         assert_equal(random.laplace(scale=0), 0)
  935:         assert_raises(ValueError, random.laplace, scale=-0.)
  936: 
  937:     def test_logistic(self):
  938:         random.seed(self.seed)
  939:         actual = random.logistic(loc=.123456789, scale=2.0, size=(3, 2))
  940:         desired = np.array([[1.09232835305011444, 0.8648196662399954],
  941:                             [4.27818590694950185, 4.33897006346929714],
  942:                             [-0.21682183359214885, 2.63373365386060332]])
  943:         assert_array_almost_equal(actual, desired, decimal=15)
  944: 
  945:     def test_lognormal(self):
  946:         random.seed(self.seed)
  947:         actual = random.lognormal(mean=.123456789, sigma=2.0, size=(3, 2))
  948:         desired = np.array([[16.50698631688883822, 36.54846706092654784],
  949:                             [22.67886599981281748, 0.71617561058995771],
  950:                             [65.72798501792723869, 86.84341601437161273]])
  951:         assert_array_almost_equal(actual, desired, decimal=13)
  952: 
  953:     def test_lognormal_0(self):
  954:         assert_equal(random.lognormal(sigma=0), 1)
  955:         assert_raises(ValueError, random.lognormal, sigma=-0.)
  956: 
  957:     def test_logseries(self):
  958:         random.seed(self.seed)
  959:         actual = random.logseries(p=.923456789, size=(3, 2))
  960:         desired = np.array([[2, 2],
  961:                             [6, 17],
  962:                             [3, 6]])
  963:         assert_array_equal(actual, desired)
  964: 
  965:     def test_logseries_zero(self):
  966:         assert random.logseries(0) == 1
  967: 
  968:     @pytest.mark.parametrize("value", [np.nextafter(0., -1), 1., np.nan, 5.])
  969:     def test_logseries_exceptions(self, value):
  970:         with np.errstate(invalid="ignore"):
  971:             with pytest.raises(ValueError):
  972:                 random.logseries(value)
  973:             with pytest.raises(ValueError):
  974:                 # contiguous path:
  975:                 random.logseries(np.array([value] * 10))
  976:             with pytest.raises(ValueError):
  977:                 # non-contiguous path:
  978:                 random.logseries(np.array([value] * 10)[::2])
  979: 
  980:     def test_multinomial(self):
  981:         random.seed(self.seed)
  982:         actual = random.multinomial(20, [1 / 6.] * 6, size=(3, 2))
  983:         desired = np.array([[[4, 3, 5, 4, 2, 2],
  984:                              [5, 2, 8, 2, 2, 1]],
  985:                             [[3, 4, 3, 6, 0, 4],
  986:                              [2, 1, 4, 3, 6, 4]],
  987:                             [[4, 4, 2, 5, 2, 3],
  988:                              [4, 3, 4, 2, 3, 4]]])
  989:         assert_array_equal(actual, desired)
  990: 
  991:     def test_multivariate_normal(self):
  992:         random.seed(self.seed)
  993:         mean = (.123456789, 10)
  994:         cov = [[1, 0], [0, 1]]
  995:         size = (3, 2)
  996:         actual = random.multivariate_normal(mean, cov, size)
  997:         desired = np.array([[[1.463620246718631, 11.73759122771936],
  998:                              [1.622445133300628, 9.771356667546383]],
  999:                             [[2.154490787682787, 12.170324946056553],
 1000:                              [1.719909438201865, 9.230548443648306]],
 1001:                             [[0.689515026297799, 9.880729819607714],
 1002:                              [-0.023054015651998, 9.201096623542879]]])
 1003: 
 1004:         assert_array_almost_equal(actual, desired, decimal=15)
 1005: 
 1006:         # Check for default size, was raising deprecation warning
 1007:         actual = random.multivariate_normal(mean, cov)
 1008:         desired = np.array([0.895289569463708, 9.17180864067987])
 1009:         assert_array_almost_equal(actual, desired, decimal=15)
 1010: 
 1011:         # Check that non positive-semidefinite covariance warns with
 1012:         # RuntimeWarning
 1013:         mean = [0, 0]
 1014:         cov = [[1, 2], [2, 1]]
 1015:         assert_warns(RuntimeWarning, random.multivariate_normal, mean, cov)
 1016: 
 1017:         # and that it doesn't warn with RuntimeWarning check_valid='ignore'
 1018:         assert_no_warnings(random.multivariate_normal, mean, cov,
 1019:                            check_valid='ignore')
 1020: 
 1021:         # and that it raises with RuntimeWarning check_valid='raises'
 1022:         assert_raises(ValueError, random.multivariate_normal, mean, cov,
 1023:                       check_valid='raise')
 1024: 
 1025:         cov = np.array([[1, 0.1], [0.1, 1]], dtype=np.float32)
 1026:         with suppress_warnings() as sup:
 1027:             random.multivariate_normal(mean, cov)
 1028:             w = sup.record(RuntimeWarning)
 1029:             assert len(w) == 0
 1030: 
 1031:         mu = np.zeros(2)
 1032:         cov = np.eye(2)
 1033:         assert_raises(ValueError, random.multivariate_normal, mean, cov,
 1034:                       check_valid='other')
 1035:         assert_raises(ValueError, random.multivariate_normal,
 1036:                       np.zeros((2, 1, 1)), cov)
 1037:         assert_raises(ValueError, random.multivariate_normal,
 1038:                       mu, np.empty((3, 2)))
 1039:         assert_raises(ValueError, random.multivariate_normal,
 1040:                       mu, np.eye(3))
 1041: 
 1042:     def test_negative_binomial(self):
 1043:         random.seed(self.seed)
 1044:         actual = random.negative_binomial(n=100, p=.12345, size=(3, 2))
 1045:         desired = np.array([[848, 841],
 1046:                             [892, 611],
 1047:                             [779, 647]])
 1048:         assert_array_equal(actual, desired)
 1049: 
 1050:     def test_negative_binomial_exceptions(self):
 1051:         with suppress_warnings() as sup:
 1052:             sup.record(RuntimeWarning)
 1053:             assert_raises(ValueError, random.negative_binomial, 100, np.nan)
 1054:             assert_raises(ValueError, random.negative_binomial, 100,
 1055:                           [np.nan] * 10)
 1056: 
 1057:     def test_noncentral_chisquare(self):
 1058:         random.seed(self.seed)
 1059:         actual = random.noncentral_chisquare(df=5, nonc=5, size=(3, 2))
 1060:         desired = np.array([[23.91905354498517511, 13.35324692733826346],
 1061:                             [31.22452661329736401, 16.60047399466177254],
 1062:                             [5.03461598262724586, 17.94973089023519464]])
 1063:         assert_array_almost_equal(actual, desired, decimal=14)
 1064: 
 1065:         actual = random.noncentral_chisquare(df=.5, nonc=.2, size=(3, 2))
 1066:         desired = np.array([[1.47145377828516666,  0.15052899268012659],
 1067:                             [0.00943803056963588,  1.02647251615666169],
 1068:                             [0.332334982684171,  0.15451287602753125]])
 1069:         assert_array_almost_equal(actual, desired, decimal=14)
 1070: 
 1071:         random.seed(self.seed)
 1072:         actual = random.noncentral_chisquare(df=5, nonc=0, size=(3, 2))
 1073:         desired = np.array([[9.597154162763948, 11.725484450296079],
 1074:                             [10.413711048138335, 3.694475922923986],
 1075:                             [13.484222138963087, 14.377255424602957]])
 1076:         assert_array_almost_equal(actual, desired, decimal=14)
 1077: 
 1078:     def test_noncentral_f(self):
 1079:         random.seed(self.seed)
 1080:         actual = random.noncentral_f(dfnum=5, dfden=2, nonc=1,
 1081:                                      size=(3, 2))
 1082:         desired = np.array([[1.40598099674926669, 0.34207973179285761],
 1083:                             [3.57715069265772545, 7.92632662577829805],
 1084:                             [0.43741599463544162, 1.1774208752428319]])
 1085:         assert_array_almost_equal(actual, desired, decimal=14)
 1086: 
 1087:     def test_noncentral_f_nan(self):
 1088:         random.seed(self.seed)
 1089:         actual = random.noncentral_f(dfnum=5, dfden=2, nonc=np.nan)
 1090:         assert np.isnan(actual)
 1091: 
 1092:     def test_normal(self):
 1093:         random.seed(self.seed)
 1094:         actual = random.normal(loc=.123456789, scale=2.0, size=(3, 2))
 1095:         desired = np.array([[2.80378370443726244, 3.59863924443872163],
 1096:                             [3.121433477601256, -0.33382987590723379],
 1097:                             [4.18552478636557357, 4.46410668111310471]])
 1098:         assert_array_almost_equal(actual, desired, decimal=15)
 1099: 
 1100:     def test_normal_0(self):
 1101:         assert_equal(random.normal(scale=0), 0)
 1102:         assert_raises(ValueError, random.normal, scale=-0.)
 1103: 
 1104:     def test_pareto(self):
 1105:         random.seed(self.seed)
 1106:         actual = random.pareto(a=.123456789, size=(3, 2))
 1107:         desired = np.array(
 1108:                 [[2.46852460439034849e+03, 1.41286880810518346e+03],
 1109:                  [5.28287797029485181e+07, 6.57720981047328785e+07],
 1110:                  [1.40840323350391515e+02, 1.98390255135251704e+05]])
 1111:         # For some reason on 32-bit x86 Ubuntu 12.10 the [1, 0] entry in this
 1112:         # matrix differs by 24 nulps. Discussion:
 1113:         #   https://mail.python.org/pipermail/numpy-discussion/2012-September/063801.html
 1114:         # Consensus is that this is probably some gcc quirk that affects
 1115:         # rounding but not in any important way, so we just use a looser
 1116:         # tolerance on this test:
 1117:         np.testing.assert_array_almost_equal_nulp(actual, desired, nulp=30)
 1118: 
 1119:     def test_poisson(self):
 1120:         random.seed(self.seed)
 1121:         actual = random.poisson(lam=.123456789, size=(3, 2))
 1122:         desired = np.array([[0, 0],
 1123:                             [1, 0],
 1124:                             [0, 0]])
 1125:         assert_array_equal(actual, desired)
 1126: 
 1127:     def test_poisson_exceptions(self):
 1128:         lambig = np.iinfo('l').max
 1129:         lamneg = -1
 1130:         assert_raises(ValueError, random.poisson, lamneg)
 1131:         assert_raises(ValueError, random.poisson, [lamneg] * 10)
 1132:         assert_raises(ValueError, random.poisson, lambig)
 1133:         assert_raises(ValueError, random.poisson, [lambig] * 10)
 1134:         with suppress_warnings() as sup:
 1135:             sup.record(RuntimeWarning)
 1136:             assert_raises(ValueError, random.poisson, np.nan)
 1137:             assert_raises(ValueError, random.poisson, [np.nan] * 10)
 1138: 
 1139:     def test_power(self):
 1140:         random.seed(self.seed)
 1141:         actual = random.power(a=.123456789, size=(3, 2))
 1142:         desired = np.array([[0.02048932883240791, 0.01424192241128213],
 1143:                             [0.38446073748535298, 0.39499689943484395],
 1144:                             [0.00177699707563439, 0.13115505880863756]])
 1145:         assert_array_almost_equal(actual, desired, decimal=15)
 1146: 
 1147:     def test_rayleigh(self):
 1148:         random.seed(self.seed)
 1149:         actual = random.rayleigh(scale=10, size=(3, 2))
 1150:         desired = np.array([[13.8882496494248393, 13.383318339044731],
 1151:                             [20.95413364294492098, 21.08285015800712614],
 1152:                             [11.06066537006854311, 17.35468505778271009]])
 1153:         assert_array_almost_equal(actual, desired, decimal=14)
 1154: 
 1155:     def test_rayleigh_0(self):
 1156:         assert_equal(random.rayleigh(scale=0), 0)
 1157:         assert_raises(ValueError, random.rayleigh, scale=-0.)
 1158: 
 1159:     def test_standard_cauchy(self):
 1160:         random.seed(self.seed)
 1161:         actual = random.standard_cauchy(size=(3, 2))
 1162:         desired = np.array([[0.77127660196445336, -6.55601161955910605],
 1163:                             [0.93582023391158309, -2.07479293013759447],
 1164:                             [-4.74601644297011926, 0.18338989290760804]])
 1165:         assert_array_almost_equal(actual, desired, decimal=15)
 1166: 
 1167:     def test_standard_exponential(self):
 1168:         random.seed(self.seed)
 1169:         actual = random.standard_exponential(size=(3, 2))
 1170:         desired = np.array([[0.96441739162374596, 0.89556604882105506],
 1171:                             [2.1953785836319808, 2.22243285392490542],
 1172:                             [0.6116915921431676, 1.50592546727413201]])
 1173:         assert_array_almost_equal(actual, desired, decimal=15)
 1174: 
 1175:     def test_standard_gamma(self):
 1176:         random.seed(self.seed)
 1177:         actual = random.standard_gamma(shape=3, size=(3, 2))
 1178:         desired = np.array([[5.50841531318455058, 6.62953470301903103],
 1179:                             [5.93988484943779227, 2.31044849402133989],
 1180:                             [7.54838614231317084, 8.012756093271868]])
 1181:         assert_array_almost_equal(actual, desired, decimal=14)
 1182: 
 1183:     def test_standard_gamma_0(self):
 1184:         assert_equal(random.standard_gamma(shape=0), 0)
 1185:         assert_raises(ValueError, random.standard_gamma, shape=-0.)
 1186: 
 1187:     def test_standard_normal(self):
 1188:         random.seed(self.seed)
 1189:         actual = random.standard_normal(size=(3, 2))
 1190:         desired = np.array([[1.34016345771863121, 1.73759122771936081],
 1191:                             [1.498988344300628, -0.2286433324536169],
 1192:                             [2.031033998682787, 2.17032494605655257]])
 1193:         assert_array_almost_equal(actual, desired, decimal=15)
 1194: 
 1195:     def test_randn_singleton(self):
 1196:         random.seed(self.seed)
 1197:         actual = random.randn()
 1198:         desired = np.array(1.34016345771863121)
 1199:         assert_array_almost_equal(actual, desired, decimal=15)
 1200: 
 1201:     def test_standard_t(self):
 1202:         random.seed(self.seed)
 1203:         actual = random.standard_t(df=10, size=(3, 2))
 1204:         desired = np.array([[0.97140611862659965, -0.08830486548450577],
 1205:                             [1.36311143689505321, -0.55317463909867071],
 1206:                             [-0.18473749069684214, 0.61181537341755321]])
 1207:         assert_array_almost_equal(actual, desired, decimal=15)
 1208: 
 1209:     def test_triangular(self):
 1210:         random.seed(self.seed)
 1211:         actual = random.triangular(left=5.12, mode=10.23, right=20.34,
 1212:                                    size=(3, 2))
 1213:         desired = np.array([[12.68117178949215784, 12.4129206149193152],
 1214:                             [16.20131377335158263, 16.25692138747600524],
 1215:                             [11.20400690911820263, 14.4978144835829923]])
 1216:         assert_array_almost_equal(actual, desired, decimal=14)
 1217: 
 1218:     def test_uniform(self):
 1219:         random.seed(self.seed)
 1220:         actual = random.uniform(low=1.23, high=10.54, size=(3, 2))
 1221:         desired = np.array([[6.99097932346268003, 6.73801597444323974],
 1222:                             [9.50364421400426274, 9.53130618907631089],
 1223:                             [5.48995325769805476, 8.47493103280052118]])
 1224:         assert_array_almost_equal(actual, desired, decimal=15)
 1225: 
 1226:     def test_uniform_range_bounds(self):
 1227:         fmin = np.finfo('float').min
 1228:         fmax = np.finfo('float').max
 1229: 
 1230:         func = random.uniform
 1231:         assert_raises(OverflowError, func, -np.inf, 0)
 1232:         assert_raises(OverflowError, func, 0, np.inf)
 1233:         assert_raises(OverflowError, func, fmin, fmax)
 1234:         assert_raises(OverflowError, func, [-np.inf], [0])
 1235:         assert_raises(OverflowError, func, [0], [np.inf])
 1236: 
 1237:         # (fmax / 1e17) - fmin is within range, so this should not throw
 1238:         # account for i386 extended precision DBL_MAX / 1e17 + DBL_MAX >
 1239:         # DBL_MAX by increasing fmin a bit
 1240:         random.uniform(low=np.nextafter(fmin, 1), high=fmax / 1e17)
 1241: 
 1242:     def test_scalar_exception_propagation(self):
 1243:         # Tests that exceptions are correctly propagated in distributions
 1244:         # when called with objects that throw exceptions when converted to
 1245:         # scalars.
 1246:         #
 1247:         # Regression test for gh: 8865
 1248: 
 1249:         class ThrowingFloat(np.ndarray):
 1250:             def __float__(self):
 1251:                 raise TypeError
 1252: 
 1253:         throwing_float = np.array(1.0).view(ThrowingFloat)
 1254:         assert_raises(TypeError, random.uniform, throwing_float,
 1255:                       throwing_float)
 1256: 
 1257:         class ThrowingInteger(np.ndarray):
 1258:             def __int__(self):
 1259:                 raise TypeError
 1260: 
 1261:         throwing_int = np.array(1).view(ThrowingInteger)
 1262:         assert_raises(TypeError, random.hypergeometric, throwing_int, 1, 1)
 1263: 
 1264:     def test_vonmises(self):
 1265:         random.seed(self.seed)
 1266:         actual = random.vonmises(mu=1.23, kappa=1.54, size=(3, 2))
 1267:         desired = np.array([[2.28567572673902042, 2.89163838442285037],
 1268:                             [0.38198375564286025, 2.57638023113890746],
 1269:                             [1.19153771588353052, 1.83509849681825354]])
 1270:         assert_array_almost_equal(actual, desired, decimal=15)
 1271: 
 1272:     def test_vonmises_small(self):
 1273:         # check infinite loop, gh-4720
 1274:         random.seed(self.seed)
 1275:         r = random.vonmises(mu=0., kappa=1.1e-8, size=10**6)
 1276:         assert_(np.isfinite(r).all())
 1277: 
 1278:     def test_vonmises_large(self):
 1279:         # guard against changes in RandomState when Generator is fixed
 1280:         random.seed(self.seed)
 1281:         actual = random.vonmises(mu=0., kappa=1e7, size=3)
 1282:         desired = np.array([4.634253748521111e-04,
 1283:                             3.558873596114509e-04,
 1284:                             -2.337119622577433e-04])
 1285:         assert_array_almost_equal(actual, desired, decimal=8)
 1286: 
 1287:     def test_vonmises_nan(self):
 1288:         random.seed(self.seed)
 1289:         r = random.vonmises(mu=0., kappa=np.nan)
 1290:         assert_(np.isnan(r))
 1291: 
 1292:     def test_wald(self):
 1293:         random.seed(self.seed)
 1294:         actual = random.wald(mean=1.23, scale=1.54, size=(3, 2))
 1295:         desired = np.array([[3.82935265715889983, 5.13125249184285526],
 1296:                             [0.35045403618358717, 1.50832396872003538],
 1297:                             [0.24124319895843183, 0.22031101461955038]])
 1298:         assert_array_almost_equal(actual, desired, decimal=14)
 1299: 
 1300:     def test_weibull(self):
 1301:         random.seed(self.seed)
 1302:         actual = random.weibull(a=1.23, size=(3, 2))
 1303:         desired = np.array([[0.97097342648766727, 0.91422896443565516],
 1304:                             [1.89517770034962929, 1.91414357960479564],
 1305:                             [0.67057783752390987, 1.39494046635066793]])
 1306:         assert_array_almost_equal(actual, desired, decimal=15)
 1307: 
 1308:     def test_weibull_0(self):
 1309:         random.seed(self.seed)
 1310:         assert_equal(random.weibull(a=0, size=12), np.zeros(12))
 1311:         assert_raises(ValueError, random.weibull, a=-0.)
 1312: 
 1313:     def test_zipf(self):
 1314:         random.seed(self.seed)
 1315:         actual = random.zipf(a=1.23, size=(3, 2))
 1316:         desired = np.array([[66, 29],
 1317:                             [1, 1],
 1318:                             [3, 13]])
 1319:         assert_array_equal(actual, desired)
 1320: 
 1321: 
 1322: class TestBroadcast:
 1323:     # tests that functions that broadcast behave
 1324:     # correctly when presented with non-scalar arguments
 1325:     def setup_method(self):
 1326:         self.seed = 123456789
 1327: 
 1328:     def set_seed(self):
 1329:         random.seed(self.seed)
 1330: 
 1331:     def test_uniform(self):
 1332:         low = [0]
 1333:         high = [1]
 1334:         uniform = random.uniform
 1335:         desired = np.array([0.53283302478975902,
 1336:                             0.53413660089041659,
 1337:                             0.50955303552646702])
 1338: 
 1339:         self.set_seed()
 1340:         actual = uniform(low * 3, high)
 1341:         assert_array_almost_equal(actual, desired, decimal=14)
 1342: 
 1343:         self.set_seed()
 1344:         actual = uniform(low, high * 3)
 1345:         assert_array_almost_equal(actual, desired, decimal=14)
 1346: 
 1347:     def test_normal(self):
 1348:         loc = [0]
 1349:         scale = [1]
 1350:         bad_scale = [-1]
 1351:         normal = random.normal
 1352:         desired = np.array([2.2129019979039612,
 1353:                             2.1283977976520019,
 1354:                             1.8417114045748335])
 1355: 
 1356:         self.set_seed()
 1357:         actual = normal(loc * 3, scale)
 1358:         assert_array_almost_equal(actual, desired, decimal=14)
 1359:         assert_raises(ValueError, normal, loc * 3, bad_scale)
 1360: 
 1361:         self.set_seed()
 1362:         actual = normal(loc, scale * 3)
 1363:         assert_array_almost_equal(actual, desired, decimal=14)
 1364:         assert_raises(ValueError, normal, loc, bad_scale * 3)
 1365: 
 1366:     def test_beta(self):
 1367:         a = [1]
 1368:         b = [2]
 1369:         bad_a = [-1]
 1370:         bad_b = [-2]
 1371:         beta = random.beta
 1372:         desired = np.array([0.19843558305989056,
 1373:                             0.075230336409423643,
 1374:                             0.24976865978980844])
 1375: 
 1376:         self.set_seed()
 1377:         actual = beta(a * 3, b)
 1378:         assert_array_almost_equal(actual, desired, decimal=14)
 1379:         assert_raises(ValueError, beta, bad_a * 3, b)
 1380:         assert_raises(ValueError, beta, a * 3, bad_b)
 1381: 
 1382:         self.set_seed()
 1383:         actual = beta(a, b * 3)
 1384:         assert_array_almost_equal(actual, desired, decimal=14)
 1385:         assert_raises(ValueError, beta, bad_a, b * 3)
 1386:         assert_raises(ValueError, beta, a, bad_b * 3)
 1387: 
 1388:     def test_exponential(self):
 1389:         scale = [1]
 1390:         bad_scale = [-1]
 1391:         exponential = random.exponential
 1392:         desired = np.array([0.76106853658845242,
 1393:                             0.76386282278691653,
 1394:                             0.71243813125891797])
 1395: 
 1396:         self.set_seed()
 1397:         actual = exponential(scale * 3)
 1398:         assert_array_almost_equal(actual, desired, decimal=14)
 1399:         assert_raises(ValueError, exponential, bad_scale * 3)
 1400: 
 1401:     def test_standard_gamma(self):
 1402:         shape = [1]
 1403:         bad_shape = [-1]
 1404:         std_gamma = random.standard_gamma
 1405:         desired = np.array([0.76106853658845242,
 1406:                             0.76386282278691653,
 1407:                             0.71243813125891797])
 1408: 
 1409:         self.set_seed()
 1410:         actual = std_gamma(shape * 3)
 1411:         assert_array_almost_equal(actual, desired, decimal=14)
 1412:         assert_raises(ValueError, std_gamma, bad_shape * 3)
 1413: 
 1414:     def test_gamma(self):
 1415:         shape = [1]
 1416:         scale = [2]
 1417:         bad_shape = [-1]
 1418:         bad_scale = [-2]
 1419:         gamma = random.gamma
 1420:         desired = np.array([1.5221370731769048,
 1421:                             1.5277256455738331,
 1422:                             1.4248762625178359])
 1423: 
 1424:         self.set_seed()
 1425:         actual = gamma(shape * 3, scale)
 1426:         assert_array_almost_equal(actual, desired, decimal=14)
 1427:         assert_raises(ValueError, gamma, bad_shape * 3, scale)
 1428:         assert_raises(ValueError, gamma, shape * 3, bad_scale)
 1429: 
 1430:         self.set_seed()
 1431:         actual = gamma(shape, scale * 3)
 1432:         assert_array_almost_equal(actual, desired, decimal=14)
 1433:         assert_raises(ValueError, gamma, bad_shape, scale * 3)
 1434:         assert_raises(ValueError, gamma, shape, bad_scale * 3)
 1435: 
 1436:     def test_f(self):
 1437:         dfnum = [1]
 1438:         dfden = [2]
 1439:         bad_dfnum = [-1]
 1440:         bad_dfden = [-2]
 1441:         f = random.f
 1442:         desired = np.array([0.80038951638264799,
 1443:                             0.86768719635363512,
 1444:                             2.7251095168386801])
 1445: 
 1446:         self.set_seed()
 1447:         actual = f(dfnum * 3, dfden)
 1448:         assert_array_almost_equal(actual, desired, decimal=14)
 1449:         assert_raises(ValueError, f, bad_dfnum * 3, dfden)
 1450:         assert_raises(ValueError, f, dfnum * 3, bad_dfden)
 1451: 
 1452:         self.set_seed()
 1453:         actual = f(dfnum, dfden * 3)
 1454:         assert_array_almost_equal(actual, desired, decimal=14)
 1455:         assert_raises(ValueError, f, bad_dfnum, dfden * 3)
 1456:         assert_raises(ValueError, f, dfnum, bad_dfden * 3)
 1457: 
 1458:     def test_noncentral_f(self):
 1459:         dfnum = [2]
 1460:         dfden = [3]
 1461:         nonc = [4]
 1462:         bad_dfnum = [0]
 1463:         bad_dfden = [-1]
 1464:         bad_nonc = [-2]
 1465:         nonc_f = random.noncentral_f
 1466:         desired = np.array([9.1393943263705211,
 1467:                             13.025456344595602,
 1468:                             8.8018098359100545])
 1469: 
 1470:         self.set_seed()
 1471:         actual = nonc_f(dfnum * 3, dfden, nonc)
 1472:         assert_array_almost_equal(actual, desired, decimal=14)
 1473:         assert np.all(np.isnan(nonc_f(dfnum, dfden, [np.nan] * 3)))
 1474: 
 1475:         assert_raises(ValueError, nonc_f, bad_dfnum * 3, dfden, nonc)
 1476:         assert_raises(ValueError, nonc_f, dfnum * 3, bad_dfden, nonc)
 1477:         assert_raises(ValueError, nonc_f, dfnum * 3, dfden, bad_nonc)
 1478: 
 1479:         self.set_seed()
 1480:         actual = nonc_f(dfnum, dfden * 3, nonc)
 1481:         assert_array_almost_equal(actual, desired, decimal=14)
 1482:         assert_raises(ValueError, nonc_f, bad_dfnum, dfden * 3, nonc)
 1483:         assert_raises(ValueError, nonc_f, dfnum, bad_dfden * 3, nonc)
 1484:         assert_raises(ValueError, nonc_f, dfnum, dfden * 3, bad_nonc)
 1485: 
 1486:         self.set_seed()
 1487:         actual = nonc_f(dfnum, dfden, nonc * 3)
 1488:         assert_array_almost_equal(actual, desired, decimal=14)
 1489:         assert_raises(ValueError, nonc_f, bad_dfnum, dfden, nonc * 3)
 1490:         assert_raises(ValueError, nonc_f, dfnum, bad_dfden, nonc * 3)
 1491:         assert_raises(ValueError, nonc_f, dfnum, dfden, bad_nonc * 3)
 1492: 
 1493:     def test_noncentral_f_small_df(self):
 1494:         self.set_seed()
 1495:         desired = np.array([6.869638627492048, 0.785880199263955])
 1496:         actual = random.noncentral_f(0.9, 0.9, 2, size=2)
 1497:         assert_array_almost_equal(actual, desired, decimal=14)
 1498: 
 1499:     def test_chisquare(self):
 1500:         df = [1]
 1501:         bad_df = [-1]
 1502:         chisquare = random.chisquare
 1503:         desired = np.array([0.57022801133088286,
 1504:                             0.51947702108840776,
 1505:                             0.1320969254923558])
 1506: 
 1507:         self.set_seed()
 1508:         actual = chisquare(df * 3)
 1509:         assert_array_almost_equal(actual, desired, decimal=14)
 1510:         assert_raises(ValueError, chisquare, bad_df * 3)
 1511: 
 1512:     def test_noncentral_chisquare(self):
 1513:         df = [1]
 1514:         nonc = [2]
 1515:         bad_df = [-1]
 1516:         bad_nonc = [-2]
 1517:         nonc_chi = random.noncentral_chisquare
 1518:         desired = np.array([9.0015599467913763,
 1519:                             4.5804135049718742,
 1520:                             6.0872302432834564])
 1521: 
 1522:         self.set_seed()
 1523:         actual = nonc_chi(df * 3, nonc)
 1524:         assert_array_almost_equal(actual, desired, decimal=14)
 1525:         assert_raises(ValueError, nonc_chi, bad_df * 3, nonc)
 1526:         assert_raises(ValueError, nonc_chi, df * 3, bad_nonc)
 1527: 
 1528:         self.set_seed()
 1529:         actual = nonc_chi(df, nonc * 3)
 1530:         assert_array_almost_equal(actual, desired, decimal=14)
 1531:         assert_raises(ValueError, nonc_chi, bad_df, nonc * 3)
 1532:         assert_raises(ValueError, nonc_chi, df, bad_nonc * 3)
 1533: 
 1534:     def test_standard_t(self):
 1535:         df = [1]
 1536:         bad_df = [-1]
 1537:         t = random.standard_t
 1538:         desired = np.array([3.0702872575217643,
 1539:                             5.8560725167361607,
 1540:                             1.0274791436474273])
 1541: 
 1542:         self.set_seed()
 1543:         actual = t(df * 3)
 1544:         assert_array_almost_equal(actual, desired, decimal=14)
 1545:         assert_raises(ValueError, t, bad_df * 3)
 1546:         assert_raises(ValueError, random.standard_t, bad_df * 3)
 1547: 
 1548:     def test_vonmises(self):
 1549:         mu = [2]
 1550:         kappa = [1]
 1551:         bad_kappa = [-1]
 1552:         vonmises = random.vonmises
 1553:         desired = np.array([2.9883443664201312,
 1554:                             -2.7064099483995943,
 1555:                             -1.8672476700665914])
 1556: 
 1557:         self.set_seed()
 1558:         actual = vonmises(mu * 3, kappa)
 1559:         assert_array_almost_equal(actual, desired, decimal=14)
 1560:         assert_raises(ValueError, vonmises, mu * 3, bad_kappa)
 1561: 
 1562:         self.set_seed()
 1563:         actual = vonmises(mu, kappa * 3)
 1564:         assert_array_almost_equal(actual, desired, decimal=14)
 1565:         assert_raises(ValueError, vonmises, mu, bad_kappa * 3)
 1566: 
 1567:     def test_pareto(self):
 1568:         a = [1]
 1569:         bad_a = [-1]
 1570:         pareto = random.pareto
 1571:         desired = np.array([1.1405622680198362,
 1572:                             1.1465519762044529,
 1573:                             1.0389564467453547])
 1574: 
 1575:         self.set_seed()
 1576:         actual = pareto(a * 3)
 1577:         assert_array_almost_equal(actual, desired, decimal=14)
 1578:         assert_raises(ValueError, pareto, bad_a * 3)
 1579:         assert_raises(ValueError, random.pareto, bad_a * 3)
 1580: 
 1581:     def test_weibull(self):
 1582:         a = [1]
 1583:         bad_a = [-1]
 1584:         weibull = random.weibull
 1585:         desired = np.array([0.76106853658845242,
 1586:                             0.76386282278691653,
 1587:                             0.71243813125891797])
 1588: 
 1589:         self.set_seed()
 1590:         actual = weibull(a * 3)
 1591:         assert_array_almost_equal(actual, desired, decimal=14)
 1592:         assert_raises(ValueError, weibull, bad_a * 3)
 1593:         assert_raises(ValueError, random.weibull, bad_a * 3)
 1594: 
 1595:     def test_power(self):
 1596:         a = [1]
 1597:         bad_a = [-1]
 1598:         power = random.power
 1599:         desired = np.array([0.53283302478975902,
 1600:                             0.53413660089041659,
 1601:                             0.50955303552646702])
 1602: 
 1603:         self.set_seed()
 1604:         actual = power(a * 3)
 1605:         assert_array_almost_equal(actual, desired, decimal=14)
 1606:         assert_raises(ValueError, power, bad_a * 3)
 1607:         assert_raises(ValueError, random.power, bad_a * 3)
 1608: 
 1609:     def test_laplace(self):
 1610:         loc = [0]
 1611:         scale = [1]
 1612:         bad_scale = [-1]
 1613:         laplace = random.laplace
 1614:         desired = np.array([0.067921356028507157,
 1615:                             0.070715642226971326,
 1616:                             0.019290950698972624])
 1617: 
 1618:         self.set_seed()
 1619:         actual = laplace(loc * 3, scale)
 1620:         assert_array_almost_equal(actual, desired, decimal=14)
 1621:         assert_raises(ValueError, laplace, loc * 3, bad_scale)
 1622: 
 1623:         self.set_seed()
 1624:         actual = laplace(loc, scale * 3)
 1625:         assert_array_almost_equal(actual, desired, decimal=14)
 1626:         assert_raises(ValueError, laplace, loc, bad_scale * 3)
 1627: 
 1628:     def test_gumbel(self):
 1629:         loc = [0]
 1630:         scale = [1]
 1631:         bad_scale = [-1]
 1632:         gumbel = random.gumbel
 1633:         desired = np.array([0.2730318639556768,
 1634:                             0.26936705726291116,
 1635:                             0.33906220393037939])
 1636: 
 1637:         self.set_seed()
 1638:         actual = gumbel(loc * 3, scale)
 1639:         assert_array_almost_equal(actual, desired, decimal=14)
 1640:         assert_raises(ValueError, gumbel, loc * 3, bad_scale)
 1641: 
 1642:         self.set_seed()
 1643:         actual = gumbel(loc, scale * 3)
 1644:         assert_array_almost_equal(actual, desired, decimal=14)
 1645:         assert_raises(ValueError, gumbel, loc, bad_scale * 3)
 1646: 
 1647:     def test_logistic(self):
 1648:         loc = [0]
 1649:         scale = [1]
 1650:         bad_scale = [-1]
 1651:         logistic = random.logistic
 1652:         desired = np.array([0.13152135837586171,
 1653:                             0.13675915696285773,
 1654:                             0.038216792802833396])
 1655: 
 1656:         self.set_seed()
 1657:         actual = logistic(loc * 3, scale)
 1658:         assert_array_almost_equal(actual, desired, decimal=14)
 1659:         assert_raises(ValueError, logistic, loc * 3, bad_scale)
 1660: 
 1661:         self.set_seed()
 1662:         actual = logistic(loc, scale * 3)
 1663:         assert_array_almost_equal(actual, desired, decimal=14)
 1664:         assert_raises(ValueError, logistic, loc, bad_scale * 3)
 1665:         assert_equal(random.logistic(1.0, 0.0), 1.0)
 1666: 
 1667:     def test_lognormal(self):
 1668:         mean = [0]
 1669:         sigma = [1]
 1670:         bad_sigma = [-1]
 1671:         lognormal = random.lognormal
 1672:         desired = np.array([9.1422086044848427,
 1673:                             8.4013952870126261,
 1674:                             6.3073234116578671])
 1675: 
 1676:         self.set_seed()
 1677:         actual = lognormal(mean * 3, sigma)
 1678:         assert_array_almost_equal(actual, desired, decimal=14)
 1679:         assert_raises(ValueError, lognormal, mean * 3, bad_sigma)
 1680:         assert_raises(ValueError, random.lognormal, mean * 3, bad_sigma)
 1681: 
 1682:         self.set_seed()
 1683:         actual = lognormal(mean, sigma * 3)
 1684:         assert_array_almost_equal(actual, desired, decimal=14)
 1685:         assert_raises(ValueError, lognormal, mean, bad_sigma * 3)
 1686:         assert_raises(ValueError, random.lognormal, mean, bad_sigma * 3)
 1687: 
 1688:     def test_rayleigh(self):
 1689:         scale = [1]
 1690:         bad_scale = [-1]
 1691:         rayleigh = random.rayleigh
 1692:         desired = np.array([1.2337491937897689,
 1693:                             1.2360119924878694,
 1694:                             1.1936818095781789])
 1695: 
 1696:         self.set_seed()
 1697:         actual = rayleigh(scale * 3)
 1698:         assert_array_almost_equal(actual, desired, decimal=14)
 1699:         assert_raises(ValueError, rayleigh, bad_scale * 3)
 1700: 
 1701:     def test_wald(self):
 1702:         mean = [0.5]
 1703:         scale = [1]
 1704:         bad_mean = [0]
 1705:         bad_scale = [-2]
 1706:         wald = random.wald
 1707:         desired = np.array([0.11873681120271318,
 1708:                             0.12450084820795027,
 1709:                             0.9096122728408238])
 1710: 
 1711:         self.set_seed()
 1712:         actual = wald(mean * 3, scale)
 1713:         assert_array_almost_equal(actual, desired, decimal=14)
 1714:         assert_raises(ValueError, wald, bad_mean * 3, scale)
 1715:         assert_raises(ValueError, wald, mean * 3, bad_scale)
 1716:         assert_raises(ValueError, random.wald, bad_mean * 3, scale)
 1717:         assert_raises(ValueError, random.wald, mean * 3, bad_scale)
 1718: 
 1719:         self.set_seed()
 1720:         actual = wald(mean, scale * 3)
 1721:         assert_array_almost_equal(actual, desired, decimal=14)
 1722:         assert_raises(ValueError, wald, bad_mean, scale * 3)
 1723:         assert_raises(ValueError, wald, mean, bad_scale * 3)
 1724:         assert_raises(ValueError, wald, 0.0, 1)
 1725:         assert_raises(ValueError, wald, 0.5, 0.0)
 1726: 
 1727:     def test_triangular(self):
 1728:         left = [1]
 1729:         right = [3]
 1730:         mode = [2]
 1731:         bad_left_one = [3]
 1732:         bad_mode_one = [4]
 1733:         bad_left_two, bad_mode_two = right * 2
 1734:         triangular = random.triangular
 1735:         desired = np.array([2.03339048710429,
 1736:                             2.0347400359389356,
 1737:                             2.0095991069536208])
 1738: 
 1739:         self.set_seed()
 1740:         actual = triangular(left * 3, mode, right)
 1741:         assert_array_almost_equal(actual, desired, decimal=14)
 1742:         assert_raises(ValueError, triangular, bad_left_one * 3, mode, right)
 1743:         assert_raises(ValueError, triangular, left * 3, bad_mode_one, right)
 1744:         assert_raises(ValueError, triangular, bad_left_two * 3, bad_mode_two,
 1745:                       right)
 1746: 
 1747:         self.set_seed()
 1748:         actual = triangular(left, mode * 3, right)
 1749:         assert_array_almost_equal(actual, desired, decimal=14)
 1750:         assert_raises(ValueError, triangular, bad_left_one, mode * 3, right)
 1751:         assert_raises(ValueError, triangular, left, bad_mode_one * 3, right)
 1752:         assert_raises(ValueError, triangular, bad_left_two, bad_mode_two * 3,
 1753:                       right)
 1754: 
 1755:         self.set_seed()
 1756:         actual = triangular(left, mode, right * 3)
 1757:         assert_array_almost_equal(actual, desired, decimal=14)
 1758:         assert_raises(ValueError, triangular, bad_left_one, mode, right * 3)
 1759:         assert_raises(ValueError, triangular, left, bad_mode_one, right * 3)
 1760:         assert_raises(ValueError, triangular, bad_left_two, bad_mode_two,
 1761:                       right * 3)
 1762: 
 1763:         assert_raises(ValueError, triangular, 10., 0., 20.)
 1764:         assert_raises(ValueError, triangular, 10., 25., 20.)
 1765:         assert_raises(ValueError, triangular, 10., 10., 10.)
 1766: 
 1767:     def test_binomial(self):
 1768:         n = [1]
 1769:         p = [0.5]
 1770:         bad_n = [-1]
 1771:         bad_p_one = [-1]
 1772:         bad_p_two = [1.5]
 1773:         binom = random.binomial
 1774:         desired = np.array([1, 1, 1])
 1775: 
 1776:         self.set_seed()
 1777:         actual = binom(n * 3, p)
 1778:         assert_array_equal(actual, desired)
 1779:         assert_raises(ValueError, binom, bad_n * 3, p)
 1780:         assert_raises(ValueError, binom, n * 3, bad_p_one)
 1781:         assert_raises(ValueError, binom, n * 3, bad_p_two)
 1782: 
 1783:         self.set_seed()
 1784:         actual = binom(n, p * 3)
 1785:         assert_array_equal(actual, desired)
 1786:         assert_raises(ValueError, binom, bad_n, p * 3)
 1787:         assert_raises(ValueError, binom, n, bad_p_one * 3)
 1788:         assert_raises(ValueError, binom, n, bad_p_two * 3)
 1789: 
 1790:     def test_negative_binomial(self):
 1791:         n = [1]
 1792:         p = [0.5]
 1793:         bad_n = [-1]
 1794:         bad_p_one = [-1]
 1795:         bad_p_two = [1.5]
 1796:         neg_binom = random.negative_binomial
 1797:         desired = np.array([1, 0, 1])
 1798: 
 1799:         self.set_seed()
 1800:         actual = neg_binom(n * 3, p)
 1801:         assert_array_equal(actual, desired)
 1802:         assert_raises(ValueError, neg_binom, bad_n * 3, p)
 1803:         assert_raises(ValueError, neg_binom, n * 3, bad_p_one)
 1804:         assert_raises(ValueError, neg_binom, n * 3, bad_p_two)
 1805: 
 1806:         self.set_seed()
 1807:         actual = neg_binom(n, p * 3)
 1808:         assert_array_equal(actual, desired)
 1809:         assert_raises(ValueError, neg_binom, bad_n, p * 3)
 1810:         assert_raises(ValueError, neg_binom, n, bad_p_one * 3)
 1811:         assert_raises(ValueError, neg_binom, n, bad_p_two * 3)
 1812: 
 1813:     def test_poisson(self):
 1814:         max_lam = random.RandomState()._poisson_lam_max
 1815: 
 1816:         lam = [1]
 1817:         bad_lam_one = [-1]
 1818:         bad_lam_two = [max_lam * 2]
 1819:         poisson = random.poisson
 1820:         desired = np.array([1, 1, 0])
 1821: 
 1822:         self.set_seed()
 1823:         actual = poisson(lam * 3)
 1824:         assert_array_equal(actual, desired)
 1825:         assert_raises(ValueError, poisson, bad_lam_one * 3)
 1826:         assert_raises(ValueError, poisson, bad_lam_two * 3)
 1827: 
 1828:     def test_zipf(self):
 1829:         a = [2]
 1830:         bad_a = [0]
 1831:         zipf = random.zipf
 1832:         desired = np.array([2, 2, 1])
 1833: 
 1834:         self.set_seed()
 1835:         actual = zipf(a * 3)
 1836:         assert_array_equal(actual, desired)
 1837:         assert_raises(ValueError, zipf, bad_a * 3)
 1838:         with np.errstate(invalid='ignore'):
 1839:             assert_raises(ValueError, zipf, np.nan)
 1840:             assert_raises(ValueError, zipf, [0, 0, np.nan])
 1841: 
 1842:     def test_geometric(self):
 1843:         p = [0.5]
 1844:         bad_p_one = [-1]
 1845:         bad_p_two = [1.5]
 1846:         geom = random.geometric
 1847:         desired = np.array([2, 2, 2])
 1848: 
 1849:         self.set_seed()
 1850:         actual = geom(p * 3)
 1851:         assert_array_equal(actual, desired)
 1852:         assert_raises(ValueError, geom, bad_p_one * 3)
 1853:         assert_raises(ValueError, geom, bad_p_two * 3)
 1854: 
 1855:     def test_hypergeometric(self):
 1856:         ngood = [1]
 1857:         nbad = [2]
 1858:         nsample = [2]
 1859:         bad_ngood = [-1]
 1860:         bad_nbad = [-2]
 1861:         bad_nsample_one = [0]
 1862:         bad_nsample_two = [4]
 1863:         hypergeom = random.hypergeometric
 1864:         desired = np.array([1, 1, 1])
 1865: 
 1866:         self.set_seed()
 1867:         actual = hypergeom(ngood * 3, nbad, nsample)
 1868:         assert_array_equal(actual, desired)
 1869:         assert_raises(ValueError, hypergeom, bad_ngood * 3, nbad, nsample)
 1870:         assert_raises(ValueError, hypergeom, ngood * 3, bad_nbad, nsample)
 1871:         assert_raises(ValueError, hypergeom, ngood * 3, nbad, bad_nsample_one)
 1872:         assert_raises(ValueError, hypergeom, ngood * 3, nbad, bad_nsample_two)
 1873: 
 1874:         self.set_seed()
 1875:         actual = hypergeom(ngood, nbad * 3, nsample)
 1876:         assert_array_equal(actual, desired)
 1877:         assert_raises(ValueError, hypergeom, bad_ngood, nbad * 3, nsample)
 1878:         assert_raises(ValueError, hypergeom, ngood, bad_nbad * 3, nsample)
 1879:         assert_raises(ValueError, hypergeom, ngood, nbad * 3, bad_nsample_one)
 1880:         assert_raises(ValueError, hypergeom, ngood, nbad * 3, bad_nsample_two)
 1881: 
 1882:         self.set_seed()
 1883:         actual = hypergeom(ngood, nbad, nsample * 3)
 1884:         assert_array_equal(actual, desired)
 1885:         assert_raises(ValueError, hypergeom, bad_ngood, nbad, nsample * 3)
 1886:         assert_raises(ValueError, hypergeom, ngood, bad_nbad, nsample * 3)
 1887:         assert_raises(ValueError, hypergeom, ngood, nbad, bad_nsample_one * 3)
 1888:         assert_raises(ValueError, hypergeom, ngood, nbad, bad_nsample_two * 3)
 1889: 
 1890:         assert_raises(ValueError, hypergeom, -1, 10, 20)
 1891:         assert_raises(ValueError, hypergeom, 10, -1, 20)
 1892:         assert_raises(ValueError, hypergeom, 10, 10, 0)
 1893:         assert_raises(ValueError, hypergeom, 10, 10, 25)
 1894: 
 1895:     def test_logseries(self):
 1896:         p = [0.5]
 1897:         bad_p_one = [2]
 1898:         bad_p_two = [-1]
 1899:         logseries = random.logseries
 1900:         desired = np.array([1, 1, 1])
 1901: 
 1902:         self.set_seed()
 1903:         actual = logseries(p * 3)
 1904:         assert_array_equal(actual, desired)
 1905:         assert_raises(ValueError, logseries, bad_p_one * 3)
 1906:         assert_raises(ValueError, logseries, bad_p_two * 3)
 1907: 
 1908: 
 1909: @pytest.mark.skipif(IS_WASM, reason="can't start thread")
 1910: class TestThread:
 1911:     # make sure each state produces the same sequence even in threads
 1912:     def setup_method(self):
 1913:         self.seeds = range(4)
 1914: 
 1915:     def check_function(self, function, sz):
 1916:         from threading import Thread
 1917: 
 1918:         out1 = np.empty((len(self.seeds),) + sz)
 1919:         out2 = np.empty((len(self.seeds),) + sz)
 1920: 
 1921:         # threaded generation
 1922:         t = [Thread(target=function, args=(random.RandomState(s), o))
 1923:              for s, o in zip(self.seeds, out1)]
 1924:         [x.start() for x in t]
 1925:         [x.join() for x in t]
 1926: 
 1927:         # the same serial
 1928:         for s, o in zip(self.seeds, out2):
 1929:             function(random.RandomState(s), o)
 1930: 
 1931:         # these platforms change x87 fpu precision mode in threads
 1932:         if np.intp().dtype.itemsize == 4 and sys.platform == "win32":
 1933:             assert_array_almost_equal(out1, out2)
 1934:         else:
 1935:             assert_array_equal(out1, out2)
 1936: 
 1937:     def test_normal(self):
 1938:         def gen_random(state, out):
 1939:             out[...] = state.normal(size=10000)
 1940: 
 1941:         self.check_function(gen_random, sz=(10000,))
 1942: 
 1943:     def test_exp(self):
 1944:         def gen_random(state, out):
 1945:             out[...] = state.exponential(scale=np.ones((100, 1000)))
 1946: 
 1947:         self.check_function(gen_random, sz=(100, 1000))
 1948: 
 1949:     def test_multinomial(self):
 1950:         def gen_random(state, out):
 1951:             out[...] = state.multinomial(10, [1 / 6.] * 6, size=10000)
 1952: 
 1953:         self.check_function(gen_random, sz=(10000, 6))
 1954: 
 1955: 
 1956: # See Issue #4263
 1957: class TestSingleEltArrayInput:
 1958:     def setup_method(self):
 1959:         self.argOne = np.array([2])
 1960:         self.argTwo = np.array([3])
 1961:         self.argThree = np.array([4])
 1962:         self.tgtShape = (1,)
 1963: 
 1964:     def test_one_arg_funcs(self):
 1965:         funcs = (random.exponential, random.standard_gamma,
 1966:                  random.chisquare, random.standard_t,
 1967:                  random.pareto, random.weibull,
 1968:                  random.power, random.rayleigh,
 1969:                  random.poisson, random.zipf,
 1970:                  random.geometric, random.logseries)
 1971: 
 1972:         probfuncs = (random.geometric, random.logseries)
 1973: 
 1974:         for func in funcs:
 1975:             if func in probfuncs:  # p < 1.0
 1976:                 out = func(np.array([0.5]))
 1977: 
 1978:             else:
 1979:                 out = func(self.argOne)
 1980: 
 1981:             assert_equal(out.shape, self.tgtShape)
 1982: 
 1983:     def test_two_arg_funcs(self):
 1984:         funcs = (random.uniform, random.normal,
 1985:                  random.beta, random.gamma,
 1986:                  random.f, random.noncentral_chisquare,
 1987:                  random.vonmises, random.laplace,
 1988:                  random.gumbel, random.logistic,
 1989:                  random.lognormal, random.wald,
 1990:                  random.binomial, random.negative_binomial)
 1991: 
 1992:         probfuncs = (random.binomial, random.negative_binomial)
 1993: 
 1994:         for func in funcs:
 1995:             if func in probfuncs:  # p <= 1
 1996:                 argTwo = np.array([0.5])
 1997: 
 1998:             else:
 1999:                 argTwo = self.argTwo
 2000: 
 2001:             out = func(self.argOne, argTwo)
 2002:             assert_equal(out.shape, self.tgtShape)
 2003: 
 2004:             out = func(self.argOne[0], argTwo)
 2005:             assert_equal(out.shape, self.tgtShape)
 2006: 
 2007:             out = func(self.argOne, argTwo[0])
 2008:             assert_equal(out.shape, self.tgtShape)
 2009: 
 2010:     def test_three_arg_funcs(self):
 2011:         funcs = [random.noncentral_f, random.triangular,
 2012:                  random.hypergeometric]
 2013: 
 2014:         for func in funcs:
 2015:             out = func(self.argOne, self.argTwo, self.argThree)
 2016:             assert_equal(out.shape, self.tgtShape)
 2017: 
 2018:             out = func(self.argOne[0], self.argTwo, self.argThree)
 2019:             assert_equal(out.shape, self.tgtShape)
 2020: 
 2021:             out = func(self.argOne, self.argTwo[0], self.argThree)
 2022:             assert_equal(out.shape, self.tgtShape)
 2023: 
 2024: 
 2025: # Ensure returned array dtype is correct for platform
 2026: def test_integer_dtype(int_func):
 2027:     random.seed(123456789)
 2028:     fname, args, sha256 = int_func
 2029:     f = getattr(random, fname)
 2030:     actual = f(*args, size=2)
 2031:     assert_(actual.dtype == np.dtype('l'))
 2032: 
 2033: 
 2034: def test_integer_repeat(int_func):
 2035:     random.seed(123456789)
 2036:     fname, args, sha256 = int_func
 2037:     f = getattr(random, fname)
 2038:     val = f(*args, size=1000000)
 2039:     if sys.byteorder != 'little':
 2040:         val = val.byteswap()
 2041:     res = hashlib.sha256(val.view(np.int8)).hexdigest()
 2042:     assert_(res == sha256)
 2043: 
 2044: 
 2045: def test_broadcast_size_error():
 2046:     # GH-16833
 2047:     with pytest.raises(ValueError):
 2048:         random.binomial(1, [0.3, 0.7], size=(2, 1))
 2049:     with pytest.raises(ValueError):
 2050:         random.binomial([1, 2], 0.3, size=(2, 1))
 2051:     with pytest.raises(ValueError):
 2052:         random.binomial([1, 2], [0.3, 0.7], size=(2, 1))
 2053: 
 2054: 
 2055: def test_randomstate_ctor_old_style_pickle():
 2056:     rs = np.random.RandomState(MT19937(0))
 2057:     rs.standard_normal(1)
 2058:     # Directly call reduce which is used in pickling
 2059:     ctor, args, state_a = rs.__reduce__()
 2060:     # Simulate unpickling an old pickle that only has the name
 2061:     assert args[0].__class__.__name__ == "MT19937"
 2062:     b = ctor(*("MT19937",))
 2063:     b.set_state(state_a)
 2064:     state_b = b.get_state(legacy=False)
 2065: 
 2066:     assert_equal(state_a['bit_generator'], state_b['bit_generator'])
 2067:     assert_array_equal(state_a['state']['key'], state_b['state']['key'])
 2068:     assert_array_equal(state_a['state']['pos'], state_b['state']['pos'])
 2069:     assert_equal(state_a['has_gauss'], state_b['has_gauss'])
 2070:     assert_equal(state_a['gauss'], state_b['gauss'])
 2071: 
 2072: 
 2073: def test_hot_swap(restore_singleton_bitgen):
 2074:     # GH 21808
 2075:     def_bg = np.random.default_rng(0)
 2076:     bg = def_bg.bit_generator
 2077:     np.random.set_bit_generator(bg)
 2078:     assert isinstance(np.random.mtrand._rand._bit_generator, type(bg))
 2079: 
 2080:     second_bg = np.random.get_bit_generator()
 2081:     assert bg is second_bg
 2082: 
 2083: 
 2084: def test_seed_alt_bit_gen(restore_singleton_bitgen):
 2085:     # GH 21808
 2086:     bg = PCG64(0)
 2087:     np.random.set_bit_generator(bg)
 2088:     state = np.random.get_state(legacy=False)
 2089:     np.random.seed(1)
 2090:     new_state = np.random.get_state(legacy=False)
 2091:     print(state)
 2092:     print(new_state)
 2093:     assert state["bit_generator"] == "PCG64"
 2094:     assert state["state"]["state"] != new_state["state"]["state"]
 2095:     assert state["state"]["inc"] != new_state["state"]["inc"]
 2096: 
 2097: 
 2098: def test_state_error_alt_bit_gen(restore_singleton_bitgen):
 2099:     # GH 21808
 2100:     state = np.random.get_state()
 2101:     bg = PCG64(0)
 2102:     np.random.set_bit_generator(bg)
 2103:     with pytest.raises(ValueError, match="state must be for a PCG64"):
 2104:         np.random.set_state(state)
 2105: 
 2106: 
 2107: def test_swap_worked(restore_singleton_bitgen):
 2108:     # GH 21808
 2109:     np.random.seed(98765)
 2110:     vals = np.random.randint(0, 2 ** 30, 10)
 2111:     bg = PCG64(0)
 2112:     state = bg.state
 2113:     np.random.set_bit_generator(bg)
 2114:     state_direct = np.random.get_state(legacy=False)
 2115:     for field in state:
 2116:         assert state[field] == state_direct[field]
 2117:     np.random.seed(98765)
 2118:     pcg_vals = np.random.randint(0, 2 ** 30, 10)
 2119:     assert not np.all(vals == pcg_vals)
 2120:     new_state = bg.state
 2121:     assert new_state["state"]["state"] != state["state"]["state"]
 2122:     assert new_state["state"]["inc"] == new_state["state"]["inc"]
 2123: 
 2124: 
 2125: def test_swapped_singleton_against_direct(restore_singleton_bitgen):
 2126:     np.random.set_bit_generator(PCG64(98765))
 2127:     singleton_vals = np.random.randint(0, 2 ** 30, 10)
 2128:     rg = np.random.RandomState(PCG64(98765))
 2129:     non_singleton_vals = rg.randint(0, 2 ** 30, 10)
 2130:     assert_equal(non_singleton_vals, singleton_vals)
