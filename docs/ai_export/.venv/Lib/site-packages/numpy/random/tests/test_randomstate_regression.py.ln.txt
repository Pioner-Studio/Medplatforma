    1: import sys
    2: 
    3: import pytest
    4: 
    5: import numpy as np
    6: from numpy import random
    7: from numpy.testing import (
    8:     assert_,
    9:     assert_array_equal,
   10:     assert_raises,
   11: )
   12: 
   13: 
   14: class TestRegression:
   15: 
   16:     def test_VonMises_range(self):
   17:         # Make sure generated random variables are in [-pi, pi].
   18:         # Regression test for ticket #986.
   19:         for mu in np.linspace(-7., 7., 5):
   20:             r = random.vonmises(mu, 1, 50)
   21:             assert_(np.all(r > -np.pi) and np.all(r <= np.pi))
   22: 
   23:     def test_hypergeometric_range(self):
   24:         # Test for ticket #921
   25:         assert_(np.all(random.hypergeometric(3, 18, 11, size=10) < 4))
   26:         assert_(np.all(random.hypergeometric(18, 3, 11, size=10) > 0))
   27: 
   28:         # Test for ticket #5623
   29:         args = [
   30:             (2**20 - 2, 2**20 - 2, 2**20 - 2),  # Check for 32-bit systems
   31:         ]
   32:         is_64bits = sys.maxsize > 2**32
   33:         if is_64bits and sys.platform != 'win32':
   34:             # Check for 64-bit systems
   35:             args.append((2**40 - 2, 2**40 - 2, 2**40 - 2))
   36:         for arg in args:
   37:             assert_(random.hypergeometric(*arg) > 0)
   38: 
   39:     def test_logseries_convergence(self):
   40:         # Test for ticket #923
   41:         N = 1000
   42:         random.seed(0)
   43:         rvsn = random.logseries(0.8, size=N)
   44:         # these two frequency counts should be close to theoretical
   45:         # numbers with this large sample
   46:         # theoretical large N result is 0.49706795
   47:         freq = np.sum(rvsn == 1) / N
   48:         msg = f'Frequency was {freq:f}, should be > 0.45'
   49:         assert_(freq > 0.45, msg)
   50:         # theoretical large N result is 0.19882718
   51:         freq = np.sum(rvsn == 2) / N
   52:         msg = f'Frequency was {freq:f}, should be < 0.23'
   53:         assert_(freq < 0.23, msg)
   54: 
   55:     def test_shuffle_mixed_dimension(self):
   56:         # Test for trac ticket #2074
   57:         for t in [[1, 2, 3, None],
   58:                   [(1, 1), (2, 2), (3, 3), None],
   59:                   [1, (2, 2), (3, 3), None],
   60:                   [(1, 1), 2, 3, None]]:
   61:             random.seed(12345)
   62:             shuffled = list(t)
   63:             random.shuffle(shuffled)
   64:             expected = np.array([t[0], t[3], t[1], t[2]], dtype=object)
   65:             assert_array_equal(np.array(shuffled, dtype=object), expected)
   66: 
   67:     def test_call_within_randomstate(self):
   68:         # Check that custom RandomState does not call into global state
   69:         m = random.RandomState()
   70:         res = np.array([0, 8, 7, 2, 1, 9, 4, 7, 0, 3])
   71:         for i in range(3):
   72:             random.seed(i)
   73:             m.seed(4321)
   74:             # If m.state is not honored, the result will change
   75:             assert_array_equal(m.choice(10, size=10, p=np.ones(10) / 10.), res)
   76: 
   77:     def test_multivariate_normal_size_types(self):
   78:         # Test for multivariate_normal issue with 'size' argument.
   79:         # Check that the multivariate_normal size argument can be a
   80:         # numpy integer.
   81:         random.multivariate_normal([0], [[0]], size=1)
   82:         random.multivariate_normal([0], [[0]], size=np.int_(1))
   83:         random.multivariate_normal([0], [[0]], size=np.int64(1))
   84: 
   85:     def test_beta_small_parameters(self):
   86:         # Test that beta with small a and b parameters does not produce
   87:         # NaNs due to roundoff errors causing 0 / 0, gh-5851
   88:         random.seed(1234567890)
   89:         x = random.beta(0.0001, 0.0001, size=100)
   90:         assert_(not np.any(np.isnan(x)), 'Nans in random.beta')
   91: 
   92:     def test_choice_sum_of_probs_tolerance(self):
   93:         # The sum of probs should be 1.0 with some tolerance.
   94:         # For low precision dtypes the tolerance was too tight.
   95:         # See numpy github issue 6123.
   96:         random.seed(1234)
   97:         a = [1, 2, 3]
   98:         counts = [4, 4, 2]
   99:         for dt in np.float16, np.float32, np.float64:
  100:             probs = np.array(counts, dtype=dt) / sum(counts)
  101:             c = random.choice(a, p=probs)
  102:             assert_(c in a)
  103:             assert_raises(ValueError, random.choice, a, p=probs * 0.9)
  104: 
  105:     def test_shuffle_of_array_of_different_length_strings(self):
  106:         # Test that permuting an array of different length strings
  107:         # will not cause a segfault on garbage collection
  108:         # Tests gh-7710
  109:         random.seed(1234)
  110: 
  111:         a = np.array(['a', 'a' * 1000])
  112: 
  113:         for _ in range(100):
  114:             random.shuffle(a)
  115: 
  116:         # Force Garbage Collection - should not segfault.
  117:         import gc
  118:         gc.collect()
  119: 
  120:     def test_shuffle_of_array_of_objects(self):
  121:         # Test that permuting an array of objects will not cause
  122:         # a segfault on garbage collection.
  123:         # See gh-7719
  124:         random.seed(1234)
  125:         a = np.array([np.arange(1), np.arange(4)], dtype=object)
  126: 
  127:         for _ in range(1000):
  128:             random.shuffle(a)
  129: 
  130:         # Force Garbage Collection - should not segfault.
  131:         import gc
  132:         gc.collect()
  133: 
  134:     def test_permutation_subclass(self):
  135:         class N(np.ndarray):
  136:             pass
  137: 
  138:         random.seed(1)
  139:         orig = np.arange(3).view(N)
  140:         perm = random.permutation(orig)
  141:         assert_array_equal(perm, np.array([0, 2, 1]))
  142:         assert_array_equal(orig, np.arange(3).view(N))
  143: 
  144:         class M:
  145:             a = np.arange(5)
  146: 
  147:             def __array__(self, dtype=None, copy=None):
  148:                 return self.a
  149: 
  150:         random.seed(1)
  151:         m = M()
  152:         perm = random.permutation(m)
  153:         assert_array_equal(perm, np.array([2, 1, 4, 0, 3]))
  154:         assert_array_equal(m.__array__(), np.arange(5))
  155: 
  156:     def test_warns_byteorder(self):
  157:         # GH 13159
  158:         other_byteord_dt = '<i4' if sys.byteorder == 'big' else '>i4'
  159:         with pytest.deprecated_call(match='non-native byteorder is not'):
  160:             random.randint(0, 200, size=10, dtype=other_byteord_dt)
  161: 
  162:     def test_named_argument_initialization(self):
  163:         # GH 13669
  164:         rs1 = np.random.RandomState(123456789)
  165:         rs2 = np.random.RandomState(seed=123456789)
  166:         assert rs1.randint(0, 100) == rs2.randint(0, 100)
  167: 
  168:     def test_choice_retun_dtype(self):
  169:         # GH 9867, now long since the NumPy default changed.
  170:         c = np.random.choice(10, p=[.1] * 10, size=2)
  171:         assert c.dtype == np.dtype(np.long)
  172:         c = np.random.choice(10, p=[.1] * 10, replace=False, size=2)
  173:         assert c.dtype == np.dtype(np.long)
  174:         c = np.random.choice(10, size=2)
  175:         assert c.dtype == np.dtype(np.long)
  176:         c = np.random.choice(10, replace=False, size=2)
  177:         assert c.dtype == np.dtype(np.long)
  178: 
  179:     @pytest.mark.skipif(np.iinfo('l').max < 2**32,
  180:                         reason='Cannot test with 32-bit C long')
  181:     def test_randint_117(self):
  182:         # GH 14189
  183:         random.seed(0)
  184:         expected = np.array([2357136044, 2546248239, 3071714933, 3626093760,
  185:                              2588848963, 3684848379, 2340255427, 3638918503,
  186:                              1819583497, 2678185683], dtype='int64')
  187:         actual = random.randint(2**32, size=10)
  188:         assert_array_equal(actual, expected)
  189: 
  190:     def test_p_zero_stream(self):
  191:         # Regression test for gh-14522.  Ensure that future versions
  192:         # generate the same variates as version 1.16.
  193:         np.random.seed(12345)
  194:         assert_array_equal(random.binomial(1, [0, 0.25, 0.5, 0.75, 1]),
  195:                            [0, 0, 0, 1, 1])
  196: 
  197:     def test_n_zero_stream(self):
  198:         # Regression test for gh-14522.  Ensure that future versions
  199:         # generate the same variates as version 1.16.
  200:         np.random.seed(8675309)
  201:         expected = np.array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  202:                              [3, 4, 2, 3, 3, 1, 5, 3, 1, 3]])
  203:         assert_array_equal(random.binomial([[0], [10]], 0.25, size=(2, 10)),
  204:                            expected)
  205: 
  206: 
  207: def test_multinomial_empty():
  208:     # gh-20483
  209:     # Ensure that empty p-vals are correctly handled
  210:     assert random.multinomial(10, []).shape == (0,)
  211:     assert random.multinomial(3, [], size=(7, 5, 3)).shape == (7, 5, 3, 0)
  212: 
  213: 
  214: def test_multinomial_1d_pval():
  215:     # gh-20483
  216:     with pytest.raises(TypeError, match="pvals must be a 1-d"):
  217:         random.multinomial(10, 0.3)
