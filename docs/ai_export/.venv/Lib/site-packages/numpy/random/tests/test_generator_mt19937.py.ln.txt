    1: import hashlib
    2: import os.path
    3: import sys
    4: 
    5: import pytest
    6: 
    7: import numpy as np
    8: from numpy.exceptions import AxisError
    9: from numpy.linalg import LinAlgError
   10: from numpy.random import MT19937, Generator, RandomState, SeedSequence
   11: from numpy.testing import (
   12:     IS_WASM,
   13:     assert_,
   14:     assert_allclose,
   15:     assert_array_almost_equal,
   16:     assert_array_equal,
   17:     assert_equal,
   18:     assert_no_warnings,
   19:     assert_raises,
   20:     assert_warns,
   21:     suppress_warnings,
   22: )
   23: 
   24: random = Generator(MT19937())
   25: 
   26: JUMP_TEST_DATA = [
   27:     {
   28:         "seed": 0,
   29:         "steps": 10,
   30:         "initial": {"key_sha256": "bb1636883c2707b51c5b7fc26c6927af4430f2e0785a8c7bc886337f919f9edf", "pos": 9},    # noqa: E501
   31:         "jumped":  {"key_sha256": "ff682ac12bb140f2d72fba8d3506cf4e46817a0db27aae1683867629031d8d55", "pos": 598},  # noqa: E501
   32:     },
   33:     {
   34:         "seed": 384908324,
   35:         "steps": 312,
   36:         "initial": {"key_sha256": "16b791a1e04886ccbbb4d448d6ff791267dc458ae599475d08d5cced29d11614", "pos": 311},  # noqa: E501
   37:         "jumped":  {"key_sha256": "a0110a2cf23b56be0feaed8f787a7fc84bef0cb5623003d75b26bdfa1c18002c", "pos": 276},  # noqa: E501
   38:     },
   39:     {
   40:         "seed": [839438204, 980239840, 859048019, 821],
   41:         "steps": 511,
   42:         "initial": {"key_sha256": "d306cf01314d51bd37892d874308200951a35265ede54d200f1e065004c3e9ea", "pos": 510},  # noqa: E501
   43:         "jumped":  {"key_sha256": "0e00ab449f01a5195a83b4aee0dfbc2ce8d46466a640b92e33977d2e42f777f8", "pos": 475},  # noqa: E501
   44:     },
   45: ]
   46: 
   47: 
   48: @pytest.fixture(scope='module', params=[True, False])
   49: def endpoint(request):
   50:     return request.param
   51: 
   52: 
   53: class TestSeed:
   54:     def test_scalar(self):
   55:         s = Generator(MT19937(0))
   56:         assert_equal(s.integers(1000), 479)
   57:         s = Generator(MT19937(4294967295))
   58:         assert_equal(s.integers(1000), 324)
   59: 
   60:     def test_array(self):
   61:         s = Generator(MT19937(range(10)))
   62:         assert_equal(s.integers(1000), 465)
   63:         s = Generator(MT19937(np.arange(10)))
   64:         assert_equal(s.integers(1000), 465)
   65:         s = Generator(MT19937([0]))
   66:         assert_equal(s.integers(1000), 479)
   67:         s = Generator(MT19937([4294967295]))
   68:         assert_equal(s.integers(1000), 324)
   69: 
   70:     def test_seedsequence(self):
   71:         s = MT19937(SeedSequence(0))
   72:         assert_equal(s.random_raw(1), 2058676884)
   73: 
   74:     def test_invalid_scalar(self):
   75:         # seed must be an unsigned 32 bit integer
   76:         assert_raises(TypeError, MT19937, -0.5)
   77:         assert_raises(ValueError, MT19937, -1)
   78: 
   79:     def test_invalid_array(self):
   80:         # seed must be an unsigned integer
   81:         assert_raises(TypeError, MT19937, [-0.5])
   82:         assert_raises(ValueError, MT19937, [-1])
   83:         assert_raises(ValueError, MT19937, [1, -2, 4294967296])
   84: 
   85:     def test_noninstantized_bitgen(self):
   86:         assert_raises(ValueError, Generator, MT19937)
   87: 
   88: 
   89: class TestBinomial:
   90:     def test_n_zero(self):
   91:         # Tests the corner case of n == 0 for the binomial distribution.
   92:         # binomial(0, p) should be zero for any p in [0, 1].
   93:         # This test addresses issue #3480.
   94:         zeros = np.zeros(2, dtype='int')
   95:         for p in [0, .5, 1]:
   96:             assert_(random.binomial(0, p) == 0)
   97:             assert_array_equal(random.binomial(zeros, p), zeros)
   98: 
   99:     def test_p_is_nan(self):
  100:         # Issue #4571.
  101:         assert_raises(ValueError, random.binomial, 1, np.nan)
  102: 
  103: 
  104: class TestMultinomial:
  105:     def test_basic(self):
  106:         random.multinomial(100, [0.2, 0.8])
  107: 
  108:     def test_zero_probability(self):
  109:         random.multinomial(100, [0.2, 0.8, 0.0, 0.0, 0.0])
  110: 
  111:     def test_int_negative_interval(self):
  112:         assert_(-5 <= random.integers(-5, -1) < -1)
  113:         x = random.integers(-5, -1, 5)
  114:         assert_(np.all(-5 <= x))
  115:         assert_(np.all(x < -1))
  116: 
  117:     def test_size(self):
  118:         # gh-3173
  119:         p = [0.5, 0.5]
  120:         assert_equal(random.multinomial(1, p, np.uint32(1)).shape, (1, 2))
  121:         assert_equal(random.multinomial(1, p, np.uint32(1)).shape, (1, 2))
  122:         assert_equal(random.multinomial(1, p, np.uint32(1)).shape, (1, 2))
  123:         assert_equal(random.multinomial(1, p, [2, 2]).shape, (2, 2, 2))
  124:         assert_equal(random.multinomial(1, p, (2, 2)).shape, (2, 2, 2))
  125:         assert_equal(random.multinomial(1, p, np.array((2, 2))).shape,
  126:                      (2, 2, 2))
  127: 
  128:         assert_raises(TypeError, random.multinomial, 1, p,
  129:                       float(1))
  130: 
  131:     def test_invalid_prob(self):
  132:         assert_raises(ValueError, random.multinomial, 100, [1.1, 0.2])
  133:         assert_raises(ValueError, random.multinomial, 100, [-.1, 0.9])
  134: 
  135:     def test_invalid_n(self):
  136:         assert_raises(ValueError, random.multinomial, -1, [0.8, 0.2])
  137:         assert_raises(ValueError, random.multinomial, [-1] * 10, [0.8, 0.2])
  138: 
  139:     def test_p_non_contiguous(self):
  140:         p = np.arange(15.)
  141:         p /= np.sum(p[1::3])
  142:         pvals = p[1::3]
  143:         random = Generator(MT19937(1432985819))
  144:         non_contig = random.multinomial(100, pvals=pvals)
  145:         random = Generator(MT19937(1432985819))
  146:         contig = random.multinomial(100, pvals=np.ascontiguousarray(pvals))
  147:         assert_array_equal(non_contig, contig)
  148: 
  149:     def test_multinomial_pvals_float32(self):
  150:         x = np.array([9.9e-01, 9.9e-01, 1.0e-09, 1.0e-09, 1.0e-09, 1.0e-09,
  151:                       1.0e-09, 1.0e-09, 1.0e-09, 1.0e-09], dtype=np.float32)
  152:         pvals = x / x.sum()
  153:         random = Generator(MT19937(1432985819))
  154:         match = r"[\w\s]*pvals array is cast to 64-bit floating"
  155:         with pytest.raises(ValueError, match=match):
  156:             random.multinomial(1, pvals)
  157: 
  158: 
  159: class TestMultivariateHypergeometric:
  160: 
  161:     def setup_method(self):
  162:         self.seed = 8675309
  163: 
  164:     def test_argument_validation(self):
  165:         # Error cases...
  166: 
  167:         # `colors` must be a 1-d sequence
  168:         assert_raises(ValueError, random.multivariate_hypergeometric,
  169:                       10, 4)
  170: 
  171:         # Negative nsample
  172:         assert_raises(ValueError, random.multivariate_hypergeometric,
  173:                       [2, 3, 4], -1)
  174: 
  175:         # Negative color
  176:         assert_raises(ValueError, random.multivariate_hypergeometric,
  177:                       [-1, 2, 3], 2)
  178: 
  179:         # nsample exceeds sum(colors)
  180:         assert_raises(ValueError, random.multivariate_hypergeometric,
  181:                       [2, 3, 4], 10)
  182: 
  183:         # nsample exceeds sum(colors) (edge case of empty colors)
  184:         assert_raises(ValueError, random.multivariate_hypergeometric,
  185:                       [], 1)
  186: 
  187:         # Validation errors associated with very large values in colors.
  188:         assert_raises(ValueError, random.multivariate_hypergeometric,
  189:                       [999999999, 101], 5, 1, 'marginals')
  190: 
  191:         int64_info = np.iinfo(np.int64)
  192:         max_int64 = int64_info.max
  193:         max_int64_index = max_int64 // int64_info.dtype.itemsize
  194:         assert_raises(ValueError, random.multivariate_hypergeometric,
  195:                       [max_int64_index - 100, 101], 5, 1, 'count')
  196: 
  197:     @pytest.mark.parametrize('method', ['count', 'marginals'])
  198:     def test_edge_cases(self, method):
  199:         # Set the seed, but in fact, all the results in this test are
  200:         # deterministic, so we don't really need this.
  201:         random = Generator(MT19937(self.seed))
  202: 
  203:         x = random.multivariate_hypergeometric([0, 0, 0], 0, method=method)
  204:         assert_array_equal(x, [0, 0, 0])
  205: 
  206:         x = random.multivariate_hypergeometric([], 0, method=method)
  207:         assert_array_equal(x, [])
  208: 
  209:         x = random.multivariate_hypergeometric([], 0, size=1, method=method)
  210:         assert_array_equal(x, np.empty((1, 0), dtype=np.int64))
  211: 
  212:         x = random.multivariate_hypergeometric([1, 2, 3], 0, method=method)
  213:         assert_array_equal(x, [0, 0, 0])
  214: 
  215:         x = random.multivariate_hypergeometric([9, 0, 0], 3, method=method)
  216:         assert_array_equal(x, [3, 0, 0])
  217: 
  218:         colors = [1, 1, 0, 1, 1]
  219:         x = random.multivariate_hypergeometric(colors, sum(colors),
  220:                                                method=method)
  221:         assert_array_equal(x, colors)
  222: 
  223:         x = random.multivariate_hypergeometric([3, 4, 5], 12, size=3,
  224:                                                method=method)
  225:         assert_array_equal(x, [[3, 4, 5]] * 3)
  226: 
  227:     # Cases for nsample:
  228:     #     nsample < 10
  229:     #     10 <= nsample < colors.sum()/2
  230:     #     colors.sum()/2 < nsample < colors.sum() - 10
  231:     #     colors.sum() - 10 < nsample < colors.sum()
  232:     @pytest.mark.parametrize('nsample', [8, 25, 45, 55])
  233:     @pytest.mark.parametrize('method', ['count', 'marginals'])
  234:     @pytest.mark.parametrize('size', [5, (2, 3), 150000])
  235:     def test_typical_cases(self, nsample, method, size):
  236:         random = Generator(MT19937(self.seed))
  237: 
  238:         colors = np.array([10, 5, 20, 25])
  239:         sample = random.multivariate_hypergeometric(colors, nsample, size,
  240:                                                     method=method)
  241:         if isinstance(size, int):
  242:             expected_shape = (size,) + colors.shape
  243:         else:
  244:             expected_shape = size + colors.shape
  245:         assert_equal(sample.shape, expected_shape)
  246:         assert_((sample >= 0).all())
  247:         assert_((sample <= colors).all())
  248:         assert_array_equal(sample.sum(axis=-1),
  249:                            np.full(size, fill_value=nsample, dtype=int))
  250:         if isinstance(size, int) and size >= 100000:
  251:             # This sample is large enough to compare its mean to
  252:             # the expected values.
  253:             assert_allclose(sample.mean(axis=0),
  254:                             nsample * colors / colors.sum(),
  255:                             rtol=1e-3, atol=0.005)
  256: 
  257:     def test_repeatability1(self):
  258:         random = Generator(MT19937(self.seed))
  259:         sample = random.multivariate_hypergeometric([3, 4, 5], 5, size=5,
  260:                                                     method='count')
  261:         expected = np.array([[2, 1, 2],
  262:                              [2, 1, 2],
  263:                              [1, 1, 3],
  264:                              [2, 0, 3],
  265:                              [2, 1, 2]])
  266:         assert_array_equal(sample, expected)
  267: 
  268:     def test_repeatability2(self):
  269:         random = Generator(MT19937(self.seed))
  270:         sample = random.multivariate_hypergeometric([20, 30, 50], 50,
  271:                                                     size=5,
  272:                                                     method='marginals')
  273:         expected = np.array([[ 9, 17, 24],
  274:                              [ 7, 13, 30],
  275:                              [ 9, 15, 26],
  276:                              [ 9, 17, 24],
  277:                              [12, 14, 24]])
  278:         assert_array_equal(sample, expected)
  279: 
  280:     def test_repeatability3(self):
  281:         random = Generator(MT19937(self.seed))
  282:         sample = random.multivariate_hypergeometric([20, 30, 50], 12,
  283:                                                     size=5,
  284:                                                     method='marginals')
  285:         expected = np.array([[2, 3, 7],
  286:                              [5, 3, 4],
  287:                              [2, 5, 5],
  288:                              [5, 3, 4],
  289:                              [1, 5, 6]])
  290:         assert_array_equal(sample, expected)
  291: 
  292: 
  293: class TestSetState:
  294:     def setup_method(self):
  295:         self.seed = 1234567890
  296:         self.rg = Generator(MT19937(self.seed))
  297:         self.bit_generator = self.rg.bit_generator
  298:         self.state = self.bit_generator.state
  299:         self.legacy_state = (self.state['bit_generator'],
  300:                              self.state['state']['key'],
  301:                              self.state['state']['pos'])
  302: 
  303:     def test_gaussian_reset(self):
  304:         # Make sure the cached every-other-Gaussian is reset.
  305:         old = self.rg.standard_normal(size=3)
  306:         self.bit_generator.state = self.state
  307:         new = self.rg.standard_normal(size=3)
  308:         assert_(np.all(old == new))
  309: 
  310:     def test_gaussian_reset_in_media_res(self):
  311:         # When the state is saved with a cached Gaussian, make sure the
  312:         # cached Gaussian is restored.
  313: 
  314:         self.rg.standard_normal()
  315:         state = self.bit_generator.state
  316:         old = self.rg.standard_normal(size=3)
  317:         self.bit_generator.state = state
  318:         new = self.rg.standard_normal(size=3)
  319:         assert_(np.all(old == new))
  320: 
  321:     def test_negative_binomial(self):
  322:         # Ensure that the negative binomial results take floating point
  323:         # arguments without truncation.
  324:         self.rg.negative_binomial(0.5, 0.5)
  325: 
  326: 
  327: class TestIntegers:
  328:     rfunc = random.integers
  329: 
  330:     # valid integer/boolean types
  331:     itype = [bool, np.int8, np.uint8, np.int16, np.uint16,
  332:              np.int32, np.uint32, np.int64, np.uint64]
  333: 
  334:     def test_unsupported_type(self, endpoint):
  335:         assert_raises(TypeError, self.rfunc, 1, endpoint=endpoint, dtype=float)
  336: 
  337:     def test_bounds_checking(self, endpoint):
  338:         for dt in self.itype:
  339:             lbnd = 0 if dt is bool else np.iinfo(dt).min
  340:             ubnd = 2 if dt is bool else np.iinfo(dt).max + 1
  341:             ubnd = ubnd - 1 if endpoint else ubnd
  342:             assert_raises(ValueError, self.rfunc, lbnd - 1, ubnd,
  343:                           endpoint=endpoint, dtype=dt)
  344:             assert_raises(ValueError, self.rfunc, lbnd, ubnd + 1,
  345:                           endpoint=endpoint, dtype=dt)
  346:             assert_raises(ValueError, self.rfunc, ubnd, lbnd,
  347:                           endpoint=endpoint, dtype=dt)
  348:             assert_raises(ValueError, self.rfunc, 1, 0, endpoint=endpoint,
  349:                           dtype=dt)
  350: 
  351:             assert_raises(ValueError, self.rfunc, [lbnd - 1], ubnd,
  352:                           endpoint=endpoint, dtype=dt)
  353:             assert_raises(ValueError, self.rfunc, [lbnd], [ubnd + 1],
  354:                           endpoint=endpoint, dtype=dt)
  355:             assert_raises(ValueError, self.rfunc, [ubnd], [lbnd],
  356:                           endpoint=endpoint, dtype=dt)
  357:             assert_raises(ValueError, self.rfunc, 1, [0],
  358:                           endpoint=endpoint, dtype=dt)
  359:             assert_raises(ValueError, self.rfunc, [ubnd + 1], [ubnd],
  360:                           endpoint=endpoint, dtype=dt)
  361: 
  362:     def test_bounds_checking_array(self, endpoint):
  363:         for dt in self.itype:
  364:             lbnd = 0 if dt is bool else np.iinfo(dt).min
  365:             ubnd = 2 if dt is bool else np.iinfo(dt).max + (not endpoint)
  366: 
  367:             assert_raises(ValueError, self.rfunc, [lbnd - 1] * 2, [ubnd] * 2,
  368:                           endpoint=endpoint, dtype=dt)
  369:             assert_raises(ValueError, self.rfunc, [lbnd] * 2,
  370:                           [ubnd + 1] * 2, endpoint=endpoint, dtype=dt)
  371:             assert_raises(ValueError, self.rfunc, ubnd, [lbnd] * 2,
  372:                           endpoint=endpoint, dtype=dt)
  373:             assert_raises(ValueError, self.rfunc, [1] * 2, 0,
  374:                           endpoint=endpoint, dtype=dt)
  375: 
  376:     def test_rng_zero_and_extremes(self, endpoint):
  377:         for dt in self.itype:
  378:             lbnd = 0 if dt is bool else np.iinfo(dt).min
  379:             ubnd = 2 if dt is bool else np.iinfo(dt).max + 1
  380:             ubnd = ubnd - 1 if endpoint else ubnd
  381:             is_open = not endpoint
  382: 
  383:             tgt = ubnd - 1
  384:             assert_equal(self.rfunc(tgt, tgt + is_open, size=1000,
  385:                                     endpoint=endpoint, dtype=dt), tgt)
  386:             assert_equal(self.rfunc([tgt], tgt + is_open, size=1000,
  387:                                     endpoint=endpoint, dtype=dt), tgt)
  388: 
  389:             tgt = lbnd
  390:             assert_equal(self.rfunc(tgt, tgt + is_open, size=1000,
  391:                                     endpoint=endpoint, dtype=dt), tgt)
  392:             assert_equal(self.rfunc(tgt, [tgt + is_open], size=1000,
  393:                                     endpoint=endpoint, dtype=dt), tgt)
  394: 
  395:             tgt = (lbnd + ubnd) // 2
  396:             assert_equal(self.rfunc(tgt, tgt + is_open, size=1000,
  397:                                     endpoint=endpoint, dtype=dt), tgt)
  398:             assert_equal(self.rfunc([tgt], [tgt + is_open],
  399:                                     size=1000, endpoint=endpoint, dtype=dt),
  400:                          tgt)
  401: 
  402:     def test_rng_zero_and_extremes_array(self, endpoint):
  403:         size = 1000
  404:         for dt in self.itype:
  405:             lbnd = 0 if dt is bool else np.iinfo(dt).min
  406:             ubnd = 2 if dt is bool else np.iinfo(dt).max + 1
  407:             ubnd = ubnd - 1 if endpoint else ubnd
  408: 
  409:             tgt = ubnd - 1
  410:             assert_equal(self.rfunc([tgt], [tgt + 1],
  411:                                     size=size, dtype=dt), tgt)
  412:             assert_equal(self.rfunc(
  413:                 [tgt] * size, [tgt + 1] * size, dtype=dt), tgt)
  414:             assert_equal(self.rfunc(
  415:                 [tgt] * size, [tgt + 1] * size, size=size, dtype=dt), tgt)
  416: 
  417:             tgt = lbnd
  418:             assert_equal(self.rfunc([tgt], [tgt + 1],
  419:                                     size=size, dtype=dt), tgt)
  420:             assert_equal(self.rfunc(
  421:                 [tgt] * size, [tgt + 1] * size, dtype=dt), tgt)
  422:             assert_equal(self.rfunc(
  423:                 [tgt] * size, [tgt + 1] * size, size=size, dtype=dt), tgt)
  424: 
  425:             tgt = (lbnd + ubnd) // 2
  426:             assert_equal(self.rfunc([tgt], [tgt + 1],
  427:                                     size=size, dtype=dt), tgt)
  428:             assert_equal(self.rfunc(
  429:                 [tgt] * size, [tgt + 1] * size, dtype=dt), tgt)
  430:             assert_equal(self.rfunc(
  431:                 [tgt] * size, [tgt + 1] * size, size=size, dtype=dt), tgt)
  432: 
  433:     def test_full_range(self, endpoint):
  434:         # Test for ticket #1690
  435: 
  436:         for dt in self.itype:
  437:             lbnd = 0 if dt is bool else np.iinfo(dt).min
  438:             ubnd = 2 if dt is bool else np.iinfo(dt).max + 1
  439:             ubnd = ubnd - 1 if endpoint else ubnd
  440: 
  441:             try:
  442:                 self.rfunc(lbnd, ubnd, endpoint=endpoint, dtype=dt)
  443:             except Exception as e:
  444:                 raise AssertionError("No error should have been raised, "
  445:                                      "but one was with the following "
  446:                                      "message:\n\n%s" % str(e))
  447: 
  448:     def test_full_range_array(self, endpoint):
  449:         # Test for ticket #1690
  450: 
  451:         for dt in self.itype:
  452:             lbnd = 0 if dt is bool else np.iinfo(dt).min
  453:             ubnd = 2 if dt is bool else np.iinfo(dt).max + 1
  454:             ubnd = ubnd - 1 if endpoint else ubnd
  455: 
  456:             try:
  457:                 self.rfunc([lbnd] * 2, [ubnd], endpoint=endpoint, dtype=dt)
  458:             except Exception as e:
  459:                 raise AssertionError("No error should have been raised, "
  460:                                      "but one was with the following "
  461:                                      "message:\n\n%s" % str(e))
  462: 
  463:     def test_in_bounds_fuzz(self, endpoint):
  464:         # Don't use fixed seed
  465:         random = Generator(MT19937())
  466: 
  467:         for dt in self.itype[1:]:
  468:             for ubnd in [4, 8, 16]:
  469:                 vals = self.rfunc(2, ubnd - endpoint, size=2 ** 16,
  470:                                   endpoint=endpoint, dtype=dt)
  471:                 assert_(vals.max() < ubnd)
  472:                 assert_(vals.min() >= 2)
  473: 
  474:         vals = self.rfunc(0, 2 - endpoint, size=2 ** 16, endpoint=endpoint,
  475:                           dtype=bool)
  476:         assert_(vals.max() < 2)
  477:         assert_(vals.min() >= 0)
  478: 
  479:     def test_scalar_array_equiv(self, endpoint):
  480:         for dt in self.itype:
  481:             lbnd = 0 if dt is bool else np.iinfo(dt).min
  482:             ubnd = 2 if dt is bool else np.iinfo(dt).max + 1
  483:             ubnd = ubnd - 1 if endpoint else ubnd
  484: 
  485:             size = 1000
  486:             random = Generator(MT19937(1234))
  487:             scalar = random.integers(lbnd, ubnd, size=size, endpoint=endpoint,
  488:                                 dtype=dt)
  489: 
  490:             random = Generator(MT19937(1234))
  491:             scalar_array = random.integers([lbnd], [ubnd], size=size,
  492:                                       endpoint=endpoint, dtype=dt)
  493: 
  494:             random = Generator(MT19937(1234))
  495:             array = random.integers([lbnd] * size, [ubnd] *
  496:                                size, size=size, endpoint=endpoint, dtype=dt)
  497:             assert_array_equal(scalar, scalar_array)
  498:             assert_array_equal(scalar, array)
  499: 
  500:     def test_repeatability(self, endpoint):
  501:         # We use a sha256 hash of generated sequences of 1000 samples
  502:         # in the range [0, 6) for all but bool, where the range
  503:         # is [0, 2). Hashes are for little endian numbers.
  504:         tgt = {'bool':   '053594a9b82d656f967c54869bc6970aa0358cf94ad469c81478459c6a90eee3',  # noqa: E501
  505:                'int16':  '54de9072b6ee9ff7f20b58329556a46a447a8a29d67db51201bf88baa6e4e5d4',  # noqa: E501
  506:                'int32':  'd3a0d5efb04542b25ac712e50d21f39ac30f312a5052e9bbb1ad3baa791ac84b',  # noqa: E501
  507:                'int64':  '14e224389ac4580bfbdccb5697d6190b496f91227cf67df60989de3d546389b1',  # noqa: E501
  508:                'int8':   '0e203226ff3fbbd1580f15da4621e5f7164d0d8d6b51696dd42d004ece2cbec1',  # noqa: E501
  509:                'uint16': '54de9072b6ee9ff7f20b58329556a46a447a8a29d67db51201bf88baa6e4e5d4',  # noqa: E501
  510:                'uint32': 'd3a0d5efb04542b25ac712e50d21f39ac30f312a5052e9bbb1ad3baa791ac84b',  # noqa: E501
  511:                'uint64': '14e224389ac4580bfbdccb5697d6190b496f91227cf67df60989de3d546389b1',  # noqa: E501
  512:                'uint8':  '0e203226ff3fbbd1580f15da4621e5f7164d0d8d6b51696dd42d004ece2cbec1'}  # noqa: E501
  513: 
  514:         for dt in self.itype[1:]:
  515:             random = Generator(MT19937(1234))
  516: 
  517:             # view as little endian for hash
  518:             if sys.byteorder == 'little':
  519:                 val = random.integers(0, 6 - endpoint, size=1000, endpoint=endpoint,
  520:                                  dtype=dt)
  521:             else:
  522:                 val = random.integers(0, 6 - endpoint, size=1000, endpoint=endpoint,
  523:                                  dtype=dt).byteswap()
  524: 
  525:             res = hashlib.sha256(val).hexdigest()
  526:             assert_(tgt[np.dtype(dt).name] == res)
  527: 
  528:         # bools do not depend on endianness
  529:         random = Generator(MT19937(1234))
  530:         val = random.integers(0, 2 - endpoint, size=1000, endpoint=endpoint,
  531:                          dtype=bool).view(np.int8)
  532:         res = hashlib.sha256(val).hexdigest()
  533:         assert_(tgt[np.dtype(bool).name] == res)
  534: 
  535:     def test_repeatability_broadcasting(self, endpoint):
  536:         for dt in self.itype:
  537:             lbnd = 0 if dt in (bool, np.bool) else np.iinfo(dt).min
  538:             ubnd = 2 if dt in (bool, np.bool) else np.iinfo(dt).max + 1
  539:             ubnd = ubnd - 1 if endpoint else ubnd
  540: 
  541:             # view as little endian for hash
  542:             random = Generator(MT19937(1234))
  543:             val = random.integers(lbnd, ubnd, size=1000, endpoint=endpoint,
  544:                              dtype=dt)
  545: 
  546:             random = Generator(MT19937(1234))
  547:             val_bc = random.integers([lbnd] * 1000, ubnd, endpoint=endpoint,
  548:                                 dtype=dt)
  549: 
  550:             assert_array_equal(val, val_bc)
  551: 
  552:             random = Generator(MT19937(1234))
  553:             val_bc = random.integers([lbnd] * 1000, [ubnd] * 1000,
  554:                                 endpoint=endpoint, dtype=dt)
  555: 
  556:             assert_array_equal(val, val_bc)
  557: 
  558:     @pytest.mark.parametrize(
  559:         'bound, expected',
  560:         [(2**32 - 1, np.array([517043486, 1364798665, 1733884389, 1353720612,
  561:                                3769704066, 1170797179, 4108474671])),
  562:          (2**32, np.array([517043487, 1364798666, 1733884390, 1353720613,
  563:                            3769704067, 1170797180, 4108474672])),
  564:          (2**32 + 1, np.array([517043487, 1733884390, 3769704068, 4108474673,
  565:                                1831631863, 1215661561, 3869512430]))]
  566:     )
  567:     def test_repeatability_32bit_boundary(self, bound, expected):
  568:         for size in [None, len(expected)]:
  569:             random = Generator(MT19937(1234))
  570:             x = random.integers(bound, size=size)
  571:             assert_equal(x, expected if size is not None else expected[0])
  572: 
  573:     def test_repeatability_32bit_boundary_broadcasting(self):
  574:         desired = np.array([[[1622936284, 3620788691, 1659384060],
  575:                              [1417365545,  760222891, 1909653332],
  576:                              [3788118662,  660249498, 4092002593]],
  577:                             [[3625610153, 2979601262, 3844162757],
  578:                              [ 685800658,  120261497, 2694012896],
  579:                              [1207779440, 1586594375, 3854335050]],
  580:                             [[3004074748, 2310761796, 3012642217],
  581:                              [2067714190, 2786677879, 1363865881],
  582:                              [ 791663441, 1867303284, 2169727960]],
  583:                             [[1939603804, 1250951100,  298950036],
  584:                              [1040128489, 3791912209, 3317053765],
  585:                              [3155528714,   61360675, 2305155588]],
  586:                             [[ 817688762, 1335621943, 3288952434],
  587:                              [1770890872, 1102951817, 1957607470],
  588:                              [3099996017,  798043451,   48334215]]])
  589:         for size in [None, (5, 3, 3)]:
  590:             random = Generator(MT19937(12345))
  591:             x = random.integers([[-1], [0], [1]],
  592:                                 [2**32 - 1, 2**32, 2**32 + 1],
  593:                                 size=size)
  594:             assert_array_equal(x, desired if size is not None else desired[0])
  595: 
  596:     def test_int64_uint64_broadcast_exceptions(self, endpoint):
  597:         configs = {np.uint64: ((0, 2**65), (-1, 2**62), (10, 9), (0, 0)),
  598:                    np.int64: ((0, 2**64), (-(2**64), 2**62), (10, 9), (0, 0),
  599:                               (-2**63 - 1, -2**63 - 1))}
  600:         for dtype in configs:
  601:             for config in configs[dtype]:
  602:                 low, high = config
  603:                 high = high - endpoint
  604:                 low_a = np.array([[low] * 10])
  605:                 high_a = np.array([high] * 10)
  606:                 assert_raises(ValueError, random.integers, low, high,
  607:                               endpoint=endpoint, dtype=dtype)
  608:                 assert_raises(ValueError, random.integers, low_a, high,
  609:                               endpoint=endpoint, dtype=dtype)
  610:                 assert_raises(ValueError, random.integers, low, high_a,
  611:                               endpoint=endpoint, dtype=dtype)
  612:                 assert_raises(ValueError, random.integers, low_a, high_a,
  613:                               endpoint=endpoint, dtype=dtype)
  614: 
  615:                 low_o = np.array([[low] * 10], dtype=object)
  616:                 high_o = np.array([high] * 10, dtype=object)
  617:                 assert_raises(ValueError, random.integers, low_o, high,
  618:                               endpoint=endpoint, dtype=dtype)
  619:                 assert_raises(ValueError, random.integers, low, high_o,
  620:                               endpoint=endpoint, dtype=dtype)
  621:                 assert_raises(ValueError, random.integers, low_o, high_o,
  622:                               endpoint=endpoint, dtype=dtype)
  623: 
  624:     def test_int64_uint64_corner_case(self, endpoint):
  625:         # When stored in Numpy arrays, `lbnd` is casted
  626:         # as np.int64, and `ubnd` is casted as np.uint64.
  627:         # Checking whether `lbnd` >= `ubnd` used to be
  628:         # done solely via direct comparison, which is incorrect
  629:         # because when Numpy tries to compare both numbers,
  630:         # it casts both to np.float64 because there is
  631:         # no integer superset of np.int64 and np.uint64. However,
  632:         # `ubnd` is too large to be represented in np.float64,
  633:         # causing it be round down to np.iinfo(np.int64).max,
  634:         # leading to a ValueError because `lbnd` now equals
  635:         # the new `ubnd`.
  636: 
  637:         dt = np.int64
  638:         tgt = np.iinfo(np.int64).max
  639:         lbnd = np.int64(np.iinfo(np.int64).max)
  640:         ubnd = np.uint64(np.iinfo(np.int64).max + 1 - endpoint)
  641: 
  642:         # None of these function calls should
  643:         # generate a ValueError now.
  644:         actual = random.integers(lbnd, ubnd, endpoint=endpoint, dtype=dt)
  645:         assert_equal(actual, tgt)
  646: 
  647:     def test_respect_dtype_singleton(self, endpoint):
  648:         # See gh-7203
  649:         for dt in self.itype:
  650:             lbnd = 0 if dt is bool else np.iinfo(dt).min
  651:             ubnd = 2 if dt is bool else np.iinfo(dt).max + 1
  652:             ubnd = ubnd - 1 if endpoint else ubnd
  653:             dt = np.bool if dt is bool else dt
  654: 
  655:             sample = self.rfunc(lbnd, ubnd, endpoint=endpoint, dtype=dt)
  656:             assert_equal(sample.dtype, dt)
  657: 
  658:         for dt in (bool, int):
  659:             lbnd = 0 if dt is bool else np.iinfo(dt).min
  660:             ubnd = 2 if dt is bool else np.iinfo(dt).max + 1
  661:             ubnd = ubnd - 1 if endpoint else ubnd
  662: 
  663:             # gh-7284: Ensure that we get Python data types
  664:             sample = self.rfunc(lbnd, ubnd, endpoint=endpoint, dtype=dt)
  665:             assert not hasattr(sample, 'dtype')
  666:             assert_equal(type(sample), dt)
  667: 
  668:     def test_respect_dtype_array(self, endpoint):
  669:         # See gh-7203
  670:         for dt in self.itype:
  671:             lbnd = 0 if dt is bool else np.iinfo(dt).min
  672:             ubnd = 2 if dt is bool else np.iinfo(dt).max + 1
  673:             ubnd = ubnd - 1 if endpoint else ubnd
  674:             dt = np.bool if dt is bool else dt
  675: 
  676:             sample = self.rfunc([lbnd], [ubnd], endpoint=endpoint, dtype=dt)
  677:             assert_equal(sample.dtype, dt)
  678:             sample = self.rfunc([lbnd] * 2, [ubnd] * 2, endpoint=endpoint,
  679:                                 dtype=dt)
  680:             assert_equal(sample.dtype, dt)
  681: 
  682:     def test_zero_size(self, endpoint):
  683:         # See gh-7203
  684:         for dt in self.itype:
  685:             sample = self.rfunc(0, 0, (3, 0, 4), endpoint=endpoint, dtype=dt)
  686:             assert sample.shape == (3, 0, 4)
  687:             assert sample.dtype == dt
  688:             assert self.rfunc(0, -10, 0, endpoint=endpoint,
  689:                               dtype=dt).shape == (0,)
  690:             assert_equal(random.integers(0, 0, size=(3, 0, 4)).shape,
  691:                          (3, 0, 4))
  692:             assert_equal(random.integers(0, -10, size=0).shape, (0,))
  693:             assert_equal(random.integers(10, 10, size=0).shape, (0,))
  694: 
  695:     def test_error_byteorder(self):
  696:         other_byteord_dt = '<i4' if sys.byteorder == 'big' else '>i4'
  697:         with pytest.raises(ValueError):
  698:             random.integers(0, 200, size=10, dtype=other_byteord_dt)
  699: 
  700:     # chi2max is the maximum acceptable chi-squared value.
  701:     @pytest.mark.slow
  702:     @pytest.mark.parametrize('sample_size,high,dtype,chi2max',
  703:         [(5000000, 5, np.int8, 125.0),          # p-value ~4.6e-25
  704:          (5000000, 7, np.uint8, 150.0),         # p-value ~7.7e-30
  705:          (10000000, 2500, np.int16, 3300.0),    # p-value ~3.0e-25
  706:          (50000000, 5000, np.uint16, 6500.0),   # p-value ~3.5e-25
  707:         ])
  708:     def test_integers_small_dtype_chisquared(self, sample_size, high,
  709:                                              dtype, chi2max):
  710:         # Regression test for gh-14774.
  711:         samples = random.integers(high, size=sample_size, dtype=dtype)
  712: 
  713:         values, counts = np.unique(samples, return_counts=True)
  714:         expected = sample_size / high
  715:         chi2 = ((counts - expected)**2 / expected).sum()
  716:         assert chi2 < chi2max
  717: 
  718: 
  719: class TestRandomDist:
  720:     # Make sure the random distribution returns the correct value for a
  721:     # given seed
  722: 
  723:     def setup_method(self):
  724:         self.seed = 1234567890
  725: 
  726:     def test_integers(self):
  727:         random = Generator(MT19937(self.seed))
  728:         actual = random.integers(-99, 99, size=(3, 2))
  729:         desired = np.array([[-80, -56], [41, 37], [-83, -16]])
  730:         assert_array_equal(actual, desired)
  731: 
  732:     def test_integers_masked(self):
  733:         # Test masked rejection sampling algorithm to generate array of
  734:         # uint32 in an interval.
  735:         random = Generator(MT19937(self.seed))
  736:         actual = random.integers(0, 99, size=(3, 2), dtype=np.uint32)
  737:         desired = np.array([[9, 21], [70, 68], [8, 41]], dtype=np.uint32)
  738:         assert_array_equal(actual, desired)
  739: 
  740:     def test_integers_closed(self):
  741:         random = Generator(MT19937(self.seed))
  742:         actual = random.integers(-99, 99, size=(3, 2), endpoint=True)
  743:         desired = np.array([[-80, -56], [41, 38], [-83, -15]])
  744:         assert_array_equal(actual, desired)
  745: 
  746:     def test_integers_max_int(self):
  747:         # Tests whether integers with closed=True can generate the
  748:         # maximum allowed Python int that can be converted
  749:         # into a C long. Previous implementations of this
  750:         # method have thrown an OverflowError when attempting
  751:         # to generate this integer.
  752:         actual = random.integers(np.iinfo('l').max, np.iinfo('l').max,
  753:                                  endpoint=True)
  754: 
  755:         desired = np.iinfo('l').max
  756:         assert_equal(actual, desired)
  757: 
  758:     def test_random(self):
  759:         random = Generator(MT19937(self.seed))
  760:         actual = random.random((3, 2))
  761:         desired = np.array([[0.096999199829214, 0.707517457682192],
  762:                             [0.084364834598269, 0.767731206553125],
  763:                             [0.665069021359413, 0.715487190596693]])
  764:         assert_array_almost_equal(actual, desired, decimal=15)
  765: 
  766:         random = Generator(MT19937(self.seed))
  767:         actual = random.random()
  768:         assert_array_almost_equal(actual, desired[0, 0], decimal=15)
  769: 
  770:     def test_random_float(self):
  771:         random = Generator(MT19937(self.seed))
  772:         actual = random.random((3, 2))
  773:         desired = np.array([[0.0969992 , 0.70751746],  # noqa: E203
  774:                             [0.08436483, 0.76773121],
  775:                             [0.66506902, 0.71548719]])
  776:         assert_array_almost_equal(actual, desired, decimal=7)
  777: 
  778:     def test_random_float_scalar(self):
  779:         random = Generator(MT19937(self.seed))
  780:         actual = random.random(dtype=np.float32)
  781:         desired = 0.0969992
  782:         assert_array_almost_equal(actual, desired, decimal=7)
  783: 
  784:     @pytest.mark.parametrize('dtype, uint_view_type',
  785:                              [(np.float32, np.uint32),
  786:                               (np.float64, np.uint64)])
  787:     def test_random_distribution_of_lsb(self, dtype, uint_view_type):
  788:         random = Generator(MT19937(self.seed))
  789:         sample = random.random(100000, dtype=dtype)
  790:         num_ones_in_lsb = np.count_nonzero(sample.view(uint_view_type) & 1)
  791:         # The probability of a 1 in the least significant bit is 0.25.
  792:         # With a sample size of 100000, the probability that num_ones_in_lsb
  793:         # is outside the following range is less than 5e-11.
  794:         assert 24100 < num_ones_in_lsb < 25900
  795: 
  796:     def test_random_unsupported_type(self):
  797:         assert_raises(TypeError, random.random, dtype='int32')
  798: 
  799:     def test_choice_uniform_replace(self):
  800:         random = Generator(MT19937(self.seed))
  801:         actual = random.choice(4, 4)
  802:         desired = np.array([0, 0, 2, 2], dtype=np.int64)
  803:         assert_array_equal(actual, desired)
  804: 
  805:     def test_choice_nonuniform_replace(self):
  806:         random = Generator(MT19937(self.seed))
  807:         actual = random.choice(4, 4, p=[0.4, 0.4, 0.1, 0.1])
  808:         desired = np.array([0, 1, 0, 1], dtype=np.int64)
  809:         assert_array_equal(actual, desired)
  810: 
  811:     def test_choice_uniform_noreplace(self):
  812:         random = Generator(MT19937(self.seed))
  813:         actual = random.choice(4, 3, replace=False)
  814:         desired = np.array([2, 0, 3], dtype=np.int64)
  815:         assert_array_equal(actual, desired)
  816:         actual = random.choice(4, 4, replace=False, shuffle=False)
  817:         desired = np.arange(4, dtype=np.int64)
  818:         assert_array_equal(actual, desired)
  819: 
  820:     def test_choice_nonuniform_noreplace(self):
  821:         random = Generator(MT19937(self.seed))
  822:         actual = random.choice(4, 3, replace=False, p=[0.1, 0.3, 0.5, 0.1])
  823:         desired = np.array([0, 2, 3], dtype=np.int64)
  824:         assert_array_equal(actual, desired)
  825: 
  826:     def test_choice_noninteger(self):
  827:         random = Generator(MT19937(self.seed))
  828:         actual = random.choice(['a', 'b', 'c', 'd'], 4)
  829:         desired = np.array(['a', 'a', 'c', 'c'])
  830:         assert_array_equal(actual, desired)
  831: 
  832:     def test_choice_multidimensional_default_axis(self):
  833:         random = Generator(MT19937(self.seed))
  834:         actual = random.choice([[0, 1], [2, 3], [4, 5], [6, 7]], 3)
  835:         desired = np.array([[0, 1], [0, 1], [4, 5]])
  836:         assert_array_equal(actual, desired)
  837: 
  838:     def test_choice_multidimensional_custom_axis(self):
  839:         random = Generator(MT19937(self.seed))
  840:         actual = random.choice([[0, 1], [2, 3], [4, 5], [6, 7]], 1, axis=1)
  841:         desired = np.array([[0], [2], [4], [6]])
  842:         assert_array_equal(actual, desired)
  843: 
  844:     def test_choice_exceptions(self):
  845:         sample = random.choice
  846:         assert_raises(ValueError, sample, -1, 3)
  847:         assert_raises(ValueError, sample, 3., 3)
  848:         assert_raises(ValueError, sample, [], 3)
  849:         assert_raises(ValueError, sample, [1, 2, 3, 4], 3,
  850:                       p=[[0.25, 0.25], [0.25, 0.25]])
  851:         assert_raises(ValueError, sample, [1, 2], 3, p=[0.4, 0.4, 0.2])
  852:         assert_raises(ValueError, sample, [1, 2], 3, p=[1.1, -0.1])
  853:         assert_raises(ValueError, sample, [1, 2], 3, p=[0.4, 0.4])
  854:         assert_raises(ValueError, sample, [1, 2, 3], 4, replace=False)
  855:         # gh-13087
  856:         assert_raises(ValueError, sample, [1, 2, 3], -2, replace=False)
  857:         assert_raises(ValueError, sample, [1, 2, 3], (-1,), replace=False)
  858:         assert_raises(ValueError, sample, [1, 2, 3], (-1, 1), replace=False)
  859:         assert_raises(ValueError, sample, [1, 2, 3], 2,
  860:                       replace=False, p=[1, 0, 0])
  861: 
  862:     def test_choice_return_shape(self):
  863:         p = [0.1, 0.9]
  864:         # Check scalar
  865:         assert_(np.isscalar(random.choice(2, replace=True)))
  866:         assert_(np.isscalar(random.choice(2, replace=False)))
  867:         assert_(np.isscalar(random.choice(2, replace=True, p=p)))
  868:         assert_(np.isscalar(random.choice(2, replace=False, p=p)))
  869:         assert_(np.isscalar(random.choice([1, 2], replace=True)))
  870:         assert_(random.choice([None], replace=True) is None)
  871:         a = np.array([1, 2])
  872:         arr = np.empty(1, dtype=object)
  873:         arr[0] = a
  874:         assert_(random.choice(arr, replace=True) is a)
  875: 
  876:         # Check 0-d array
  877:         s = ()
  878:         assert_(not np.isscalar(random.choice(2, s, replace=True)))
  879:         assert_(not np.isscalar(random.choice(2, s, replace=False)))
  880:         assert_(not np.isscalar(random.choice(2, s, replace=True, p=p)))
  881:         assert_(not np.isscalar(random.choice(2, s, replace=False, p=p)))
  882:         assert_(not np.isscalar(random.choice([1, 2], s, replace=True)))
  883:         assert_(random.choice([None], s, replace=True).ndim == 0)
  884:         a = np.array([1, 2])
  885:         arr = np.empty(1, dtype=object)
  886:         arr[0] = a
  887:         assert_(random.choice(arr, s, replace=True).item() is a)
  888: 
  889:         # Check multi dimensional array
  890:         s = (2, 3)
  891:         p = [0.1, 0.1, 0.1, 0.1, 0.4, 0.2]
  892:         assert_equal(random.choice(6, s, replace=True).shape, s)
  893:         assert_equal(random.choice(6, s, replace=False).shape, s)
  894:         assert_equal(random.choice(6, s, replace=True, p=p).shape, s)
  895:         assert_equal(random.choice(6, s, replace=False, p=p).shape, s)
  896:         assert_equal(random.choice(np.arange(6), s, replace=True).shape, s)
  897: 
  898:         # Check zero-size
  899:         assert_equal(random.integers(0, 0, size=(3, 0, 4)).shape, (3, 0, 4))
  900:         assert_equal(random.integers(0, -10, size=0).shape, (0,))
  901:         assert_equal(random.integers(10, 10, size=0).shape, (0,))
  902:         assert_equal(random.choice(0, size=0).shape, (0,))
  903:         assert_equal(random.choice([], size=(0,)).shape, (0,))
  904:         assert_equal(random.choice(['a', 'b'], size=(3, 0, 4)).shape,
  905:                      (3, 0, 4))
  906:         assert_raises(ValueError, random.choice, [], 10)
  907: 
  908:     def test_choice_nan_probabilities(self):
  909:         a = np.array([42, 1, 2])
  910:         p = [None, None, None]
  911:         assert_raises(ValueError, random.choice, a, p=p)
  912: 
  913:     def test_choice_p_non_contiguous(self):
  914:         p = np.ones(10) / 5
  915:         p[1::2] = 3.0
  916:         random = Generator(MT19937(self.seed))
  917:         non_contig = random.choice(5, 3, p=p[::2])
  918:         random = Generator(MT19937(self.seed))
  919:         contig = random.choice(5, 3, p=np.ascontiguousarray(p[::2]))
  920:         assert_array_equal(non_contig, contig)
  921: 
  922:     def test_choice_return_type(self):
  923:         # gh 9867
  924:         p = np.ones(4) / 4.
  925:         actual = random.choice(4, 2)
  926:         assert actual.dtype == np.int64
  927:         actual = random.choice(4, 2, replace=False)
  928:         assert actual.dtype == np.int64
  929:         actual = random.choice(4, 2, p=p)
  930:         assert actual.dtype == np.int64
  931:         actual = random.choice(4, 2, p=p, replace=False)
  932:         assert actual.dtype == np.int64
  933: 
  934:     def test_choice_large_sample(self):
  935:         choice_hash = '4266599d12bfcfb815213303432341c06b4349f5455890446578877bb322e222'
  936:         random = Generator(MT19937(self.seed))
  937:         actual = random.choice(10000, 5000, replace=False)
  938:         if sys.byteorder != 'little':
  939:             actual = actual.byteswap()
  940:         res = hashlib.sha256(actual.view(np.int8)).hexdigest()
  941:         assert_(choice_hash == res)
  942: 
  943:     def test_choice_array_size_empty_tuple(self):
  944:         random = Generator(MT19937(self.seed))
  945:         assert_array_equal(random.choice([1, 2, 3], size=()), np.array(1),
  946:                            strict=True)
  947:         assert_array_equal(random.choice([[1, 2, 3]], size=()), [1, 2, 3])
  948:         assert_array_equal(random.choice([[1]], size=()), [1], strict=True)
  949:         assert_array_equal(random.choice([[1]], size=(), axis=1), [1],
  950:                            strict=True)
  951: 
  952:     def test_bytes(self):
  953:         random = Generator(MT19937(self.seed))
  954:         actual = random.bytes(10)
  955:         desired = b'\x86\xf0\xd4\x18\xe1\x81\t8%\xdd'
  956:         assert_equal(actual, desired)
  957: 
  958:     def test_shuffle(self):
  959:         # Test lists, arrays (of various dtypes), and multidimensional versions
  960:         # of both, c-contiguous or not:
  961:         for conv in [lambda x: np.array([]),
  962:                      lambda x: x,
  963:                      lambda x: np.asarray(x).astype(np.int8),
  964:                      lambda x: np.asarray(x).astype(np.float32),
  965:                      lambda x: np.asarray(x).astype(np.complex64),
  966:                      lambda x: np.asarray(x).astype(object),
  967:                      lambda x: [(i, i) for i in x],
  968:                      lambda x: np.asarray([[i, i] for i in x]),
  969:                      lambda x: np.vstack([x, x]).T,
  970:                      # gh-11442
  971:                      lambda x: (np.asarray([(i, i) for i in x],
  972:                                            [("a", int), ("b", int)])
  973:                                 .view(np.recarray)),
  974:                      # gh-4270
  975:                      lambda x: np.asarray([(i, i) for i in x],
  976:                                           [("a", object, (1,)),
  977:                                            ("b", np.int32, (1,))])]:
  978:             random = Generator(MT19937(self.seed))
  979:             alist = conv([1, 2, 3, 4, 5, 6, 7, 8, 9, 0])
  980:             random.shuffle(alist)
  981:             actual = alist
  982:             desired = conv([4, 1, 9, 8, 0, 5, 3, 6, 2, 7])
  983:             assert_array_equal(actual, desired)
  984: 
  985:     def test_shuffle_custom_axis(self):
  986:         random = Generator(MT19937(self.seed))
  987:         actual = np.arange(16).reshape((4, 4))
  988:         random.shuffle(actual, axis=1)
  989:         desired = np.array([[ 0,  3,  1,  2],
  990:                             [ 4,  7,  5,  6],
  991:                             [ 8, 11,  9, 10],
  992:                             [12, 15, 13, 14]])
  993:         assert_array_equal(actual, desired)
  994:         random = Generator(MT19937(self.seed))
  995:         actual = np.arange(16).reshape((4, 4))
  996:         random.shuffle(actual, axis=-1)
  997:         assert_array_equal(actual, desired)
  998: 
  999:     def test_shuffle_custom_axis_empty(self):
 1000:         random = Generator(MT19937(self.seed))
 1001:         desired = np.array([]).reshape((0, 6))
 1002:         for axis in (0, 1):
 1003:             actual = np.array([]).reshape((0, 6))
 1004:             random.shuffle(actual, axis=axis)
 1005:             assert_array_equal(actual, desired)
 1006: 
 1007:     def test_shuffle_axis_nonsquare(self):
 1008:         y1 = np.arange(20).reshape(2, 10)
 1009:         y2 = y1.copy()
 1010:         random = Generator(MT19937(self.seed))
 1011:         random.shuffle(y1, axis=1)
 1012:         random = Generator(MT19937(self.seed))
 1013:         random.shuffle(y2.T)
 1014:         assert_array_equal(y1, y2)
 1015: 
 1016:     def test_shuffle_masked(self):
 1017:         # gh-3263
 1018:         a = np.ma.masked_values(np.reshape(range(20), (5, 4)) % 3 - 1, -1)
 1019:         b = np.ma.masked_values(np.arange(20) % 3 - 1, -1)
 1020:         a_orig = a.copy()
 1021:         b_orig = b.copy()
 1022:         for i in range(50):
 1023:             random.shuffle(a)
 1024:             assert_equal(
 1025:                 sorted(a.data[~a.mask]), sorted(a_orig.data[~a_orig.mask]))
 1026:             random.shuffle(b)
 1027:             assert_equal(
 1028:                 sorted(b.data[~b.mask]), sorted(b_orig.data[~b_orig.mask]))
 1029: 
 1030:     def test_shuffle_exceptions(self):
 1031:         random = Generator(MT19937(self.seed))
 1032:         arr = np.arange(10)
 1033:         assert_raises(AxisError, random.shuffle, arr, 1)
 1034:         arr = np.arange(9).reshape((3, 3))
 1035:         assert_raises(AxisError, random.shuffle, arr, 3)
 1036:         assert_raises(TypeError, random.shuffle, arr, slice(1, 2, None))
 1037:         arr = [[1, 2, 3], [4, 5, 6]]
 1038:         assert_raises(NotImplementedError, random.shuffle, arr, 1)
 1039: 
 1040:         arr = np.array(3)
 1041:         assert_raises(TypeError, random.shuffle, arr)
 1042:         arr = np.ones((3, 2))
 1043:         assert_raises(AxisError, random.shuffle, arr, 2)
 1044: 
 1045:     def test_shuffle_not_writeable(self):
 1046:         random = Generator(MT19937(self.seed))
 1047:         a = np.zeros(5)
 1048:         a.flags.writeable = False
 1049:         with pytest.raises(ValueError, match='read-only'):
 1050:             random.shuffle(a)
 1051: 
 1052:     def test_permutation(self):
 1053:         random = Generator(MT19937(self.seed))
 1054:         alist = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
 1055:         actual = random.permutation(alist)
 1056:         desired = [4, 1, 9, 8, 0, 5, 3, 6, 2, 7]
 1057:         assert_array_equal(actual, desired)
 1058: 
 1059:         random = Generator(MT19937(self.seed))
 1060:         arr_2d = np.atleast_2d([1, 2, 3, 4, 5, 6, 7, 8, 9, 0]).T
 1061:         actual = random.permutation(arr_2d)
 1062:         assert_array_equal(actual, np.atleast_2d(desired).T)
 1063: 
 1064:         bad_x_str = "abcd"
 1065:         assert_raises(AxisError, random.permutation, bad_x_str)
 1066: 
 1067:         bad_x_float = 1.2
 1068:         assert_raises(AxisError, random.permutation, bad_x_float)
 1069: 
 1070:         random = Generator(MT19937(self.seed))
 1071:         integer_val = 10
 1072:         desired = [3, 0, 8, 7, 9, 4, 2, 5, 1, 6]
 1073: 
 1074:         actual = random.permutation(integer_val)
 1075:         assert_array_equal(actual, desired)
 1076: 
 1077:     def test_permutation_custom_axis(self):
 1078:         a = np.arange(16).reshape((4, 4))
 1079:         desired = np.array([[ 0,  3,  1,  2],
 1080:                             [ 4,  7,  5,  6],
 1081:                             [ 8, 11,  9, 10],
 1082:                             [12, 15, 13, 14]])
 1083:         random = Generator(MT19937(self.seed))
 1084:         actual = random.permutation(a, axis=1)
 1085:         assert_array_equal(actual, desired)
 1086:         random = Generator(MT19937(self.seed))
 1087:         actual = random.permutation(a, axis=-1)
 1088:         assert_array_equal(actual, desired)
 1089: 
 1090:     def test_permutation_exceptions(self):
 1091:         random = Generator(MT19937(self.seed))
 1092:         arr = np.arange(10)
 1093:         assert_raises(AxisError, random.permutation, arr, 1)
 1094:         arr = np.arange(9).reshape((3, 3))
 1095:         assert_raises(AxisError, random.permutation, arr, 3)
 1096:         assert_raises(TypeError, random.permutation, arr, slice(1, 2, None))
 1097: 
 1098:     @pytest.mark.parametrize("dtype", [int, object])
 1099:     @pytest.mark.parametrize("axis, expected",
 1100:                              [(None, np.array([[3, 7, 0, 9, 10, 11],
 1101:                                                [8, 4, 2, 5,  1,  6]])),
 1102:                               (0, np.array([[6, 1, 2, 9, 10, 11],
 1103:                                             [0, 7, 8, 3,  4,  5]])),
 1104:                               (1, np.array([[ 5, 3,  4, 0, 2, 1],
 1105:                                             [11, 9, 10, 6, 8, 7]]))])
 1106:     def test_permuted(self, dtype, axis, expected):
 1107:         random = Generator(MT19937(self.seed))
 1108:         x = np.arange(12).reshape(2, 6).astype(dtype)
 1109:         random.permuted(x, axis=axis, out=x)
 1110:         assert_array_equal(x, expected)
 1111: 
 1112:         random = Generator(MT19937(self.seed))
 1113:         x = np.arange(12).reshape(2, 6).astype(dtype)
 1114:         y = random.permuted(x, axis=axis)
 1115:         assert y.dtype == dtype
 1116:         assert_array_equal(y, expected)
 1117: 
 1118:     def test_permuted_with_strides(self):
 1119:         random = Generator(MT19937(self.seed))
 1120:         x0 = np.arange(22).reshape(2, 11)
 1121:         x1 = x0.copy()
 1122:         x = x0[:, ::3]
 1123:         y = random.permuted(x, axis=1, out=x)
 1124:         expected = np.array([[0, 9, 3, 6],
 1125:                              [14, 20, 11, 17]])
 1126:         assert_array_equal(y, expected)
 1127:         x1[:, ::3] = expected
 1128:         # Verify that the original x0 was modified in-place as expected.
 1129:         assert_array_equal(x1, x0)
 1130: 
 1131:     def test_permuted_empty(self):
 1132:         y = random.permuted([])
 1133:         assert_array_equal(y, [])
 1134: 
 1135:     @pytest.mark.parametrize('outshape', [(2, 3), 5])
 1136:     def test_permuted_out_with_wrong_shape(self, outshape):
 1137:         a = np.array([1, 2, 3])
 1138:         out = np.zeros(outshape, dtype=a.dtype)
 1139:         with pytest.raises(ValueError, match='same shape'):
 1140:             random.permuted(a, out=out)
 1141: 
 1142:     def test_permuted_out_with_wrong_type(self):
 1143:         out = np.zeros((3, 5), dtype=np.int32)
 1144:         x = np.ones((3, 5))
 1145:         with pytest.raises(TypeError, match='Cannot cast'):
 1146:             random.permuted(x, axis=1, out=out)
 1147: 
 1148:     def test_permuted_not_writeable(self):
 1149:         x = np.zeros((2, 5))
 1150:         x.flags.writeable = False
 1151:         with pytest.raises(ValueError, match='read-only'):
 1152:             random.permuted(x, axis=1, out=x)
 1153: 
 1154:     def test_beta(self):
 1155:         random = Generator(MT19937(self.seed))
 1156:         actual = random.beta(.1, .9, size=(3, 2))
 1157:         desired = np.array(
 1158:             [[1.083029353267698e-10, 2.449965303168024e-11],
 1159:              [2.397085162969853e-02, 3.590779671820755e-08],
 1160:              [2.830254190078299e-04, 1.744709918330393e-01]])
 1161:         assert_array_almost_equal(actual, desired, decimal=15)
 1162: 
 1163:     def test_binomial(self):
 1164:         random = Generator(MT19937(self.seed))
 1165:         actual = random.binomial(100.123, .456, size=(3, 2))
 1166:         desired = np.array([[42, 41],
 1167:                             [42, 48],
 1168:                             [44, 50]])
 1169:         assert_array_equal(actual, desired)
 1170: 
 1171:         random = Generator(MT19937(self.seed))
 1172:         actual = random.binomial(100.123, .456)
 1173:         desired = 42
 1174:         assert_array_equal(actual, desired)
 1175: 
 1176:     def test_chisquare(self):
 1177:         random = Generator(MT19937(self.seed))
 1178:         actual = random.chisquare(50, size=(3, 2))
 1179:         desired = np.array([[32.9850547060149, 39.0219480493301],
 1180:                             [56.2006134779419, 57.3474165711485],
 1181:                             [55.4243733880198, 55.4209797925213]])
 1182:         assert_array_almost_equal(actual, desired, decimal=13)
 1183: 
 1184:     def test_dirichlet(self):
 1185:         random = Generator(MT19937(self.seed))
 1186:         alpha = np.array([51.72840233779265162, 39.74494232180943953])
 1187:         actual = random.dirichlet(alpha, size=(3, 2))
 1188:         desired = np.array([[[0.5439892869558927,  0.45601071304410745],
 1189:                              [0.5588917345860708,  0.4411082654139292 ]],  # noqa: E202
 1190:                             [[0.5632074165063435,  0.43679258349365657],
 1191:                              [0.54862581112627,    0.45137418887373015]],
 1192:                             [[0.49961831357047226, 0.5003816864295278 ],  # noqa: E202
 1193:                              [0.52374806183482,    0.47625193816517997]]])
 1194:         assert_array_almost_equal(actual, desired, decimal=15)
 1195:         bad_alpha = np.array([5.4e-01, -1.0e-16])
 1196:         assert_raises(ValueError, random.dirichlet, bad_alpha)
 1197: 
 1198:         random = Generator(MT19937(self.seed))
 1199:         alpha = np.array([51.72840233779265162, 39.74494232180943953])
 1200:         actual = random.dirichlet(alpha)
 1201:         assert_array_almost_equal(actual, desired[0, 0], decimal=15)
 1202: 
 1203:     def test_dirichlet_size(self):
 1204:         # gh-3173
 1205:         p = np.array([51.72840233779265162, 39.74494232180943953])
 1206:         assert_equal(random.dirichlet(p, np.uint32(1)).shape, (1, 2))
 1207:         assert_equal(random.dirichlet(p, np.uint32(1)).shape, (1, 2))
 1208:         assert_equal(random.dirichlet(p, np.uint32(1)).shape, (1, 2))
 1209:         assert_equal(random.dirichlet(p, [2, 2]).shape, (2, 2, 2))
 1210:         assert_equal(random.dirichlet(p, (2, 2)).shape, (2, 2, 2))
 1211:         assert_equal(random.dirichlet(p, np.array((2, 2))).shape, (2, 2, 2))
 1212: 
 1213:         assert_raises(TypeError, random.dirichlet, p, float(1))
 1214: 
 1215:     def test_dirichlet_bad_alpha(self):
 1216:         # gh-2089
 1217:         alpha = np.array([5.4e-01, -1.0e-16])
 1218:         assert_raises(ValueError, random.dirichlet, alpha)
 1219: 
 1220:         # gh-15876
 1221:         assert_raises(ValueError, random.dirichlet, [[5, 1]])
 1222:         assert_raises(ValueError, random.dirichlet, [[5], [1]])
 1223:         assert_raises(ValueError, random.dirichlet, [[[5], [1]], [[1], [5]]])
 1224:         assert_raises(ValueError, random.dirichlet, np.array([[5, 1], [1, 5]]))
 1225: 
 1226:     def test_dirichlet_alpha_non_contiguous(self):
 1227:         a = np.array([51.72840233779265162, -1.0, 39.74494232180943953])
 1228:         alpha = a[::2]
 1229:         random = Generator(MT19937(self.seed))
 1230:         non_contig = random.dirichlet(alpha, size=(3, 2))
 1231:         random = Generator(MT19937(self.seed))
 1232:         contig = random.dirichlet(np.ascontiguousarray(alpha),
 1233:                                   size=(3, 2))
 1234:         assert_array_almost_equal(non_contig, contig)
 1235: 
 1236:     def test_dirichlet_small_alpha(self):
 1237:         eps = 1.0e-9  # 1.0e-10 -> runtime x 10; 1e-11 -> runtime x 200, etc.
 1238:         alpha = eps * np.array([1., 1.0e-3])
 1239:         random = Generator(MT19937(self.seed))
 1240:         actual = random.dirichlet(alpha, size=(3, 2))
 1241:         expected = np.array([
 1242:             [[1., 0.],
 1243:              [1., 0.]],
 1244:             [[1., 0.],
 1245:              [1., 0.]],
 1246:             [[1., 0.],
 1247:              [1., 0.]]
 1248:         ])
 1249:         assert_array_almost_equal(actual, expected, decimal=15)
 1250: 
 1251:     @pytest.mark.slow
 1252:     def test_dirichlet_moderately_small_alpha(self):
 1253:         # Use alpha.max() < 0.1 to trigger stick breaking code path
 1254:         alpha = np.array([0.02, 0.04, 0.03])
 1255:         exact_mean = alpha / alpha.sum()
 1256:         random = Generator(MT19937(self.seed))
 1257:         sample = random.dirichlet(alpha, size=20000000)
 1258:         sample_mean = sample.mean(axis=0)
 1259:         assert_allclose(sample_mean, exact_mean, rtol=1e-3)
 1260: 
 1261:     # This set of parameters includes inputs with alpha.max() >= 0.1 and
 1262:     # alpha.max() < 0.1 to exercise both generation methods within the
 1263:     # dirichlet code.
 1264:     @pytest.mark.parametrize(
 1265:         'alpha',
 1266:         [[5, 9, 0, 8],
 1267:          [0.5, 0, 0, 0],
 1268:          [1, 5, 0, 0, 1.5, 0, 0, 0],
 1269:          [0.01, 0.03, 0, 0.005],
 1270:          [1e-5, 0, 0, 0],
 1271:          [0.002, 0.015, 0, 0, 0.04, 0, 0, 0],
 1272:          [0.0],
 1273:          [0, 0, 0]],
 1274:     )
 1275:     def test_dirichlet_multiple_zeros_in_alpha(self, alpha):
 1276:         alpha = np.array(alpha)
 1277:         y = random.dirichlet(alpha)
 1278:         assert_equal(y[alpha == 0], 0.0)
 1279: 
 1280:     def test_exponential(self):
 1281:         random = Generator(MT19937(self.seed))
 1282:         actual = random.exponential(1.1234, size=(3, 2))
 1283:         desired = np.array([[0.098845481066258, 1.560752510746964],
 1284:                             [0.075730916041636, 1.769098974710777],
 1285:                             [1.488602544592235, 2.49684815275751 ]])  # noqa: E202
 1286:         assert_array_almost_equal(actual, desired, decimal=15)
 1287: 
 1288:     def test_exponential_0(self):
 1289:         assert_equal(random.exponential(scale=0), 0)
 1290:         assert_raises(ValueError, random.exponential, scale=-0.)
 1291: 
 1292:     def test_f(self):
 1293:         random = Generator(MT19937(self.seed))
 1294:         actual = random.f(12, 77, size=(3, 2))
 1295:         desired = np.array([[0.461720027077085, 1.100441958872451],
 1296:                             [1.100337455217484, 0.91421736740018 ],  # noqa: E202
 1297:                             [0.500811891303113, 0.826802454552058]])
 1298:         assert_array_almost_equal(actual, desired, decimal=15)
 1299: 
 1300:     def test_gamma(self):
 1301:         random = Generator(MT19937(self.seed))
 1302:         actual = random.gamma(5, 3, size=(3, 2))
 1303:         desired = np.array([[ 5.03850858902096,  7.9228656732049 ],  # noqa: E202
 1304:                             [18.73983605132985, 19.57961681699238],
 1305:                             [18.17897755150825, 18.17653912505234]])
 1306:         assert_array_almost_equal(actual, desired, decimal=14)
 1307: 
 1308:     def test_gamma_0(self):
 1309:         assert_equal(random.gamma(shape=0, scale=0), 0)
 1310:         assert_raises(ValueError, random.gamma, shape=-0., scale=-0.)
 1311: 
 1312:     def test_geometric(self):
 1313:         random = Generator(MT19937(self.seed))
 1314:         actual = random.geometric(.123456789, size=(3, 2))
 1315:         desired = np.array([[1, 11],
 1316:                             [1, 12],
 1317:                             [11, 17]])
 1318:         assert_array_equal(actual, desired)
 1319: 
 1320:     def test_geometric_exceptions(self):
 1321:         assert_raises(ValueError, random.geometric, 1.1)
 1322:         assert_raises(ValueError, random.geometric, [1.1] * 10)
 1323:         assert_raises(ValueError, random.geometric, -0.1)
 1324:         assert_raises(ValueError, random.geometric, [-0.1] * 10)
 1325:         with np.errstate(invalid='ignore'):
 1326:             assert_raises(ValueError, random.geometric, np.nan)
 1327:             assert_raises(ValueError, random.geometric, [np.nan] * 10)
 1328: 
 1329:     def test_gumbel(self):
 1330:         random = Generator(MT19937(self.seed))
 1331:         actual = random.gumbel(loc=.123456789, scale=2.0, size=(3, 2))
 1332:         desired = np.array([[ 4.688397515056245, -0.289514845417841],
 1333:                             [ 4.981176042584683, -0.633224272589149],
 1334:                             [-0.055915275687488, -0.333962478257953]])
 1335:         assert_array_almost_equal(actual, desired, decimal=15)
 1336: 
 1337:     def test_gumbel_0(self):
 1338:         assert_equal(random.gumbel(scale=0), 0)
 1339:         assert_raises(ValueError, random.gumbel, scale=-0.)
 1340: 
 1341:     def test_hypergeometric(self):
 1342:         random = Generator(MT19937(self.seed))
 1343:         actual = random.hypergeometric(10.1, 5.5, 14, size=(3, 2))
 1344:         desired = np.array([[ 9, 9],
 1345:                             [ 9, 9],
 1346:                             [10, 9]])
 1347:         assert_array_equal(actual, desired)
 1348: 
 1349:         # Test nbad = 0
 1350:         actual = random.hypergeometric(5, 0, 3, size=4)
 1351:         desired = np.array([3, 3, 3, 3])
 1352:         assert_array_equal(actual, desired)
 1353: 
 1354:         actual = random.hypergeometric(15, 0, 12, size=4)
 1355:         desired = np.array([12, 12, 12, 12])
 1356:         assert_array_equal(actual, desired)
 1357: 
 1358:         # Test ngood = 0
 1359:         actual = random.hypergeometric(0, 5, 3, size=4)
 1360:         desired = np.array([0, 0, 0, 0])
 1361:         assert_array_equal(actual, desired)
 1362: 
 1363:         actual = random.hypergeometric(0, 15, 12, size=4)
 1364:         desired = np.array([0, 0, 0, 0])
 1365:         assert_array_equal(actual, desired)
 1366: 
 1367:     def test_laplace(self):
 1368:         random = Generator(MT19937(self.seed))
 1369:         actual = random.laplace(loc=.123456789, scale=2.0, size=(3, 2))
 1370:         desired = np.array([[-3.156353949272393,  1.195863024830054],
 1371:                             [-3.435458081645966,  1.656882398925444],
 1372:                             [ 0.924824032467446,  1.251116432209336]])
 1373:         assert_array_almost_equal(actual, desired, decimal=15)
 1374: 
 1375:     def test_laplace_0(self):
 1376:         assert_equal(random.laplace(scale=0), 0)
 1377:         assert_raises(ValueError, random.laplace, scale=-0.)
 1378: 
 1379:     def test_logistic(self):
 1380:         random = Generator(MT19937(self.seed))
 1381:         actual = random.logistic(loc=.123456789, scale=2.0, size=(3, 2))
 1382:         desired = np.array([[-4.338584631510999,  1.890171436749954],
 1383:                             [-4.64547787337966 ,  2.514545562919217],  # noqa: E203
 1384:                             [ 1.495389489198666,  1.967827627577474]])
 1385:         assert_array_almost_equal(actual, desired, decimal=15)
 1386: 
 1387:     def test_lognormal(self):
 1388:         random = Generator(MT19937(self.seed))
 1389:         actual = random.lognormal(mean=.123456789, sigma=2.0, size=(3, 2))
 1390:         desired = np.array([[ 0.0268252166335, 13.9534486483053],
 1391:                             [ 0.1204014788936,  2.2422077497792],
 1392:                             [ 4.2484199496128, 12.0093343977523]])
 1393:         assert_array_almost_equal(actual, desired, decimal=13)
 1394: 
 1395:     def test_lognormal_0(self):
 1396:         assert_equal(random.lognormal(sigma=0), 1)
 1397:         assert_raises(ValueError, random.lognormal, sigma=-0.)
 1398: 
 1399:     def test_logseries(self):
 1400:         random = Generator(MT19937(self.seed))
 1401:         actual = random.logseries(p=.923456789, size=(3, 2))
 1402:         desired = np.array([[14, 17],
 1403:                             [3, 18],
 1404:                             [5, 1]])
 1405:         assert_array_equal(actual, desired)
 1406: 
 1407:     def test_logseries_zero(self):
 1408:         random = Generator(MT19937(self.seed))
 1409:         assert random.logseries(0) == 1
 1410: 
 1411:     @pytest.mark.parametrize("value", [np.nextafter(0., -1), 1., np.nan, 5.])
 1412:     def test_logseries_exceptions(self, value):
 1413:         random = Generator(MT19937(self.seed))
 1414:         with np.errstate(invalid="ignore"):
 1415:             with pytest.raises(ValueError):
 1416:                 random.logseries(value)
 1417:             with pytest.raises(ValueError):
 1418:                 # contiguous path:
 1419:                 random.logseries(np.array([value] * 10))
 1420:             with pytest.raises(ValueError):
 1421:                 # non-contiguous path:
 1422:                 random.logseries(np.array([value] * 10)[::2])
 1423: 
 1424:     def test_multinomial(self):
 1425:         random = Generator(MT19937(self.seed))
 1426:         actual = random.multinomial(20, [1 / 6.] * 6, size=(3, 2))
 1427:         desired = np.array([[[1, 5, 1, 6, 4, 3],
 1428:                              [4, 2, 6, 2, 4, 2]],
 1429:                             [[5, 3, 2, 6, 3, 1],
 1430:                              [4, 4, 0, 2, 3, 7]],
 1431:                             [[6, 3, 1, 5, 3, 2],
 1432:                              [5, 5, 3, 1, 2, 4]]])
 1433:         assert_array_equal(actual, desired)
 1434: 
 1435:     @pytest.mark.skipif(IS_WASM, reason="fp errors don't work in wasm")
 1436:     @pytest.mark.parametrize("method", ["svd", "eigh", "cholesky"])
 1437:     def test_multivariate_normal(self, method):
 1438:         random = Generator(MT19937(self.seed))
 1439:         mean = (.123456789, 10)
 1440:         cov = [[1, 0], [0, 1]]
 1441:         size = (3, 2)
 1442:         actual = random.multivariate_normal(mean, cov, size, method=method)
 1443:         desired = np.array([[[-1.747478062846581,  11.25613495182354 ],  # noqa: E202
 1444:                              [-0.9967333370066214, 10.342002097029821]],
 1445:                             [[ 0.7850019631242964, 11.181113712443013],
 1446:                              [ 0.8901349653255224,  8.873825399642492]],
 1447:                             [[ 0.7130260107430003,  9.551628690083056],
 1448:                              [ 0.7127098726541128, 11.991709234143173]]])
 1449: 
 1450:         assert_array_almost_equal(actual, desired, decimal=15)
 1451: 
 1452:         # Check for default size, was raising deprecation warning
 1453:         actual = random.multivariate_normal(mean, cov, method=method)
 1454:         desired = np.array([0.233278563284287, 9.424140804347195])
 1455:         assert_array_almost_equal(actual, desired, decimal=15)
 1456:         # Check that non symmetric covariance input raises exception when
 1457:         # check_valid='raises' if using default svd method.
 1458:         mean = [0, 0]
 1459:         cov = [[1, 2], [1, 2]]
 1460:         assert_raises(ValueError, random.multivariate_normal, mean, cov,
 1461:                       check_valid='raise')
 1462: 
 1463:         # Check that non positive-semidefinite covariance warns with
 1464:         # RuntimeWarning
 1465:         cov = [[1, 2], [2, 1]]
 1466:         assert_warns(RuntimeWarning, random.multivariate_normal, mean, cov)
 1467:         assert_warns(RuntimeWarning, random.multivariate_normal, mean, cov,
 1468:                      method='eigh')
 1469:         assert_raises(LinAlgError, random.multivariate_normal, mean, cov,
 1470:                       method='cholesky')
 1471: 
 1472:         # and that it doesn't warn with RuntimeWarning check_valid='ignore'
 1473:         assert_no_warnings(random.multivariate_normal, mean, cov,
 1474:                            check_valid='ignore')
 1475: 
 1476:         # and that it raises with RuntimeWarning check_valid='raises'
 1477:         assert_raises(ValueError, random.multivariate_normal, mean, cov,
 1478:                       check_valid='raise')
 1479:         assert_raises(ValueError, random.multivariate_normal, mean, cov,
 1480:                       check_valid='raise', method='eigh')
 1481: 
 1482:         # check degenerate samples from singular covariance matrix
 1483:         cov = [[1, 1], [1, 1]]
 1484:         if method in ('svd', 'eigh'):
 1485:             samples = random.multivariate_normal(mean, cov, size=(3, 2),
 1486:                                                  method=method)
 1487:             assert_array_almost_equal(samples[..., 0], samples[..., 1],
 1488:                                       decimal=6)
 1489:         else:
 1490:             assert_raises(LinAlgError, random.multivariate_normal, mean, cov,
 1491:                           method='cholesky')
 1492: 
 1493:         cov = np.array([[1, 0.1], [0.1, 1]], dtype=np.float32)
 1494:         with suppress_warnings() as sup:
 1495:             random.multivariate_normal(mean, cov, method=method)
 1496:             w = sup.record(RuntimeWarning)
 1497:             assert len(w) == 0
 1498: 
 1499:         mu = np.zeros(2)
 1500:         cov = np.eye(2)
 1501:         assert_raises(ValueError, random.multivariate_normal, mean, cov,
 1502:                       check_valid='other')
 1503:         assert_raises(ValueError, random.multivariate_normal,
 1504:                       np.zeros((2, 1, 1)), cov)
 1505:         assert_raises(ValueError, random.multivariate_normal,
 1506:                       mu, np.empty((3, 2)))
 1507:         assert_raises(ValueError, random.multivariate_normal,
 1508:                       mu, np.eye(3))
 1509: 
 1510:     @pytest.mark.parametrize('mean, cov', [([0], [[1 + 1j]]), ([0j], [[1]])])
 1511:     def test_multivariate_normal_disallow_complex(self, mean, cov):
 1512:         random = Generator(MT19937(self.seed))
 1513:         with pytest.raises(TypeError, match="must not be complex"):
 1514:             random.multivariate_normal(mean, cov)
 1515: 
 1516:     @pytest.mark.parametrize("method", ["svd", "eigh", "cholesky"])
 1517:     def test_multivariate_normal_basic_stats(self, method):
 1518:         random = Generator(MT19937(self.seed))
 1519:         n_s = 1000
 1520:         mean = np.array([1, 2])
 1521:         cov = np.array([[2, 1], [1, 2]])
 1522:         s = random.multivariate_normal(mean, cov, size=(n_s,), method=method)
 1523:         s_center = s - mean
 1524:         cov_emp = (s_center.T @ s_center) / (n_s - 1)
 1525:         # these are pretty loose and are only designed to detect major errors
 1526:         assert np.all(np.abs(s_center.mean(-2)) < 0.1)
 1527:         assert np.all(np.abs(cov_emp - cov) < 0.2)
 1528: 
 1529:     def test_negative_binomial(self):
 1530:         random = Generator(MT19937(self.seed))
 1531:         actual = random.negative_binomial(n=100, p=.12345, size=(3, 2))
 1532:         desired = np.array([[543, 727],
 1533:                             [775, 760],
 1534:                             [600, 674]])
 1535:         assert_array_equal(actual, desired)
 1536: 
 1537:     def test_negative_binomial_exceptions(self):
 1538:         with np.errstate(invalid='ignore'):
 1539:             assert_raises(ValueError, random.negative_binomial, 100, np.nan)
 1540:             assert_raises(ValueError, random.negative_binomial, 100,
 1541:                           [np.nan] * 10)
 1542: 
 1543:     def test_negative_binomial_p0_exception(self):
 1544:         # Verify that p=0 raises an exception.
 1545:         with assert_raises(ValueError):
 1546:             x = random.negative_binomial(1, 0)
 1547: 
 1548:     def test_negative_binomial_invalid_p_n_combination(self):
 1549:         # Verify that values of p and n that would result in an overflow
 1550:         # or infinite loop raise an exception.
 1551:         with np.errstate(invalid='ignore'):
 1552:             assert_raises(ValueError, random.negative_binomial, 2**62, 0.1)
 1553:             assert_raises(ValueError, random.negative_binomial, [2**62], [0.1])
 1554: 
 1555:     def test_noncentral_chisquare(self):
 1556:         random = Generator(MT19937(self.seed))
 1557:         actual = random.noncentral_chisquare(df=5, nonc=5, size=(3, 2))
 1558:         desired = np.array([[ 1.70561552362133, 15.97378184942111],
 1559:                             [13.71483425173724, 20.17859633310629],
 1560:                             [11.3615477156643 ,  3.67891108738029]])  # noqa: E203
 1561:         assert_array_almost_equal(actual, desired, decimal=14)
 1562: 
 1563:         actual = random.noncentral_chisquare(df=.5, nonc=.2, size=(3, 2))
 1564:         desired = np.array([[9.41427665607629e-04, 1.70473157518850e-04],
 1565:                             [1.14554372041263e+00, 1.38187755933435e-03],
 1566:                             [1.90659181905387e+00, 1.21772577941822e+00]])
 1567:         assert_array_almost_equal(actual, desired, decimal=14)
 1568: 
 1569:         random = Generator(MT19937(self.seed))
 1570:         actual = random.noncentral_chisquare(df=5, nonc=0, size=(3, 2))
 1571:         desired = np.array([[0.82947954590419, 1.80139670767078],
 1572:                             [6.58720057417794, 7.00491463609814],
 1573:                             [6.31101879073157, 6.30982307753005]])
 1574:         assert_array_almost_equal(actual, desired, decimal=14)
 1575: 
 1576:     def test_noncentral_f(self):
 1577:         random = Generator(MT19937(self.seed))
 1578:         actual = random.noncentral_f(dfnum=5, dfden=2, nonc=1,
 1579:                                      size=(3, 2))
 1580:         desired = np.array([[0.060310671139  , 0.23866058175939],  # noqa: E203
 1581:                             [0.86860246709073, 0.2668510459738 ],  # noqa: E202
 1582:                             [0.23375780078364, 1.88922102885943]])
 1583:         assert_array_almost_equal(actual, desired, decimal=14)
 1584: 
 1585:     def test_noncentral_f_nan(self):
 1586:         random = Generator(MT19937(self.seed))
 1587:         actual = random.noncentral_f(dfnum=5, dfden=2, nonc=np.nan)
 1588:         assert np.isnan(actual)
 1589: 
 1590:     def test_normal(self):
 1591:         random = Generator(MT19937(self.seed))
 1592:         actual = random.normal(loc=.123456789, scale=2.0, size=(3, 2))
 1593:         desired = np.array([[-3.618412914693162,  2.635726692647081],
 1594:                             [-2.116923463013243,  0.807460983059643],
 1595:                             [ 1.446547137248593,  2.485684213886024]])
 1596:         assert_array_almost_equal(actual, desired, decimal=15)
 1597: 
 1598:     def test_normal_0(self):
 1599:         assert_equal(random.normal(scale=0), 0)
 1600:         assert_raises(ValueError, random.normal, scale=-0.)
 1601: 
 1602:     def test_pareto(self):
 1603:         random = Generator(MT19937(self.seed))
 1604:         actual = random.pareto(a=.123456789, size=(3, 2))
 1605:         desired = np.array([[1.0394926776069018e+00, 7.7142534343505773e+04],
 1606:                             [7.2640150889064703e-01, 3.4650454783825594e+05],
 1607:                             [4.5852344481994740e+04, 6.5851383009539105e+07]])
 1608:         # For some reason on 32-bit x86 Ubuntu 12.10 the [1, 0] entry in this
 1609:         # matrix differs by 24 nulps. Discussion:
 1610:         #   https://mail.python.org/pipermail/numpy-discussion/2012-September/063801.html
 1611:         # Consensus is that this is probably some gcc quirk that affects
 1612:         # rounding but not in any important way, so we just use a looser
 1613:         # tolerance on this test:
 1614:         np.testing.assert_array_almost_equal_nulp(actual, desired, nulp=30)
 1615: 
 1616:     def test_poisson(self):
 1617:         random = Generator(MT19937(self.seed))
 1618:         actual = random.poisson(lam=.123456789, size=(3, 2))
 1619:         desired = np.array([[0, 0],
 1620:                             [0, 0],
 1621:                             [0, 0]])
 1622:         assert_array_equal(actual, desired)
 1623: 
 1624:     def test_poisson_exceptions(self):
 1625:         lambig = np.iinfo('int64').max
 1626:         lamneg = -1
 1627:         assert_raises(ValueError, random.poisson, lamneg)
 1628:         assert_raises(ValueError, random.poisson, [lamneg] * 10)
 1629:         assert_raises(ValueError, random.poisson, lambig)
 1630:         assert_raises(ValueError, random.poisson, [lambig] * 10)
 1631:         with np.errstate(invalid='ignore'):
 1632:             assert_raises(ValueError, random.poisson, np.nan)
 1633:             assert_raises(ValueError, random.poisson, [np.nan] * 10)
 1634: 
 1635:     def test_power(self):
 1636:         random = Generator(MT19937(self.seed))
 1637:         actual = random.power(a=.123456789, size=(3, 2))
 1638:         desired = np.array([[1.977857368842754e-09, 9.806792196620341e-02],
 1639:                             [2.482442984543471e-10, 1.527108843266079e-01],
 1640:                             [8.188283434244285e-02, 3.950547209346948e-01]])
 1641:         assert_array_almost_equal(actual, desired, decimal=15)
 1642: 
 1643:     def test_rayleigh(self):
 1644:         random = Generator(MT19937(self.seed))
 1645:         actual = random.rayleigh(scale=10, size=(3, 2))
 1646:         desired = np.array([[4.19494429102666, 16.66920198906598],
 1647:                             [3.67184544902662, 17.74695521962917],
 1648:                             [16.27935397855501, 21.08355560691792]])
 1649:         assert_array_almost_equal(actual, desired, decimal=14)
 1650: 
 1651:     def test_rayleigh_0(self):
 1652:         assert_equal(random.rayleigh(scale=0), 0)
 1653:         assert_raises(ValueError, random.rayleigh, scale=-0.)
 1654: 
 1655:     def test_standard_cauchy(self):
 1656:         random = Generator(MT19937(self.seed))
 1657:         actual = random.standard_cauchy(size=(3, 2))
 1658:         desired = np.array([[-1.489437778266206, -3.275389641569784],
 1659:                             [ 0.560102864910406, -0.680780916282552],
 1660:                             [-1.314912905226277,  0.295852965660225]])
 1661:         assert_array_almost_equal(actual, desired, decimal=15)
 1662: 
 1663:     def test_standard_exponential(self):
 1664:         random = Generator(MT19937(self.seed))
 1665:         actual = random.standard_exponential(size=(3, 2), method='inv')
 1666:         desired = np.array([[0.102031839440643, 1.229350298474972],
 1667:                             [0.088137284693098, 1.459859985522667],
 1668:                             [1.093830802293668, 1.256977002164613]])
 1669:         assert_array_almost_equal(actual, desired, decimal=15)
 1670: 
 1671:     def test_standard_expoential_type_error(self):
 1672:         assert_raises(TypeError, random.standard_exponential, dtype=np.int32)
 1673: 
 1674:     def test_standard_gamma(self):
 1675:         random = Generator(MT19937(self.seed))
 1676:         actual = random.standard_gamma(shape=3, size=(3, 2))
 1677:         desired = np.array([[0.62970724056362, 1.22379851271008],
 1678:                             [3.899412530884  , 4.12479964250139],  # noqa: E203
 1679:                             [3.74994102464584, 3.74929307690815]])
 1680:         assert_array_almost_equal(actual, desired, decimal=14)
 1681: 
 1682:     def test_standard_gammma_scalar_float(self):
 1683:         random = Generator(MT19937(self.seed))
 1684:         actual = random.standard_gamma(3, dtype=np.float32)
 1685:         desired = 2.9242148399353027
 1686:         assert_array_almost_equal(actual, desired, decimal=6)
 1687: 
 1688:     def test_standard_gamma_float(self):
 1689:         random = Generator(MT19937(self.seed))
 1690:         actual = random.standard_gamma(shape=3, size=(3, 2))
 1691:         desired = np.array([[0.62971, 1.2238],
 1692:                             [3.89941, 4.1248],
 1693:                             [3.74994, 3.74929]])
 1694:         assert_array_almost_equal(actual, desired, decimal=5)
 1695: 
 1696:     def test_standard_gammma_float_out(self):
 1697:         actual = np.zeros((3, 2), dtype=np.float32)
 1698:         random = Generator(MT19937(self.seed))
 1699:         random.standard_gamma(10.0, out=actual, dtype=np.float32)
 1700:         desired = np.array([[10.14987,  7.87012],
 1701:                              [ 9.46284, 12.56832],
 1702:                              [13.82495,  7.81533]], dtype=np.float32)
 1703:         assert_array_almost_equal(actual, desired, decimal=5)
 1704: 
 1705:         random = Generator(MT19937(self.seed))
 1706:         random.standard_gamma(10.0, out=actual, size=(3, 2), dtype=np.float32)
 1707:         assert_array_almost_equal(actual, desired, decimal=5)
 1708: 
 1709:     def test_standard_gamma_unknown_type(self):
 1710:         assert_raises(TypeError, random.standard_gamma, 1.,
 1711:                       dtype='int32')
 1712: 
 1713:     def test_out_size_mismatch(self):
 1714:         out = np.zeros(10)
 1715:         assert_raises(ValueError, random.standard_gamma, 10.0, size=20,
 1716:                       out=out)
 1717:         assert_raises(ValueError, random.standard_gamma, 10.0, size=(10, 1),
 1718:                       out=out)
 1719: 
 1720:     def test_standard_gamma_0(self):
 1721:         assert_equal(random.standard_gamma(shape=0), 0)
 1722:         assert_raises(ValueError, random.standard_gamma, shape=-0.)
 1723: 
 1724:     def test_standard_normal(self):
 1725:         random = Generator(MT19937(self.seed))
 1726:         actual = random.standard_normal(size=(3, 2))
 1727:         desired = np.array([[-1.870934851846581,  1.25613495182354 ],  # noqa: E202
 1728:                             [-1.120190126006621,  0.342002097029821],
 1729:                             [ 0.661545174124296,  1.181113712443012]])
 1730:         assert_array_almost_equal(actual, desired, decimal=15)
 1731: 
 1732:     def test_standard_normal_unsupported_type(self):
 1733:         assert_raises(TypeError, random.standard_normal, dtype=np.int32)
 1734: 
 1735:     def test_standard_t(self):
 1736:         random = Generator(MT19937(self.seed))
 1737:         actual = random.standard_t(df=10, size=(3, 2))
 1738:         desired = np.array([[-1.484666193042647,  0.30597891831161],
 1739:                             [ 1.056684299648085, -0.407312602088507],
 1740:                             [ 0.130704414281157, -2.038053410490321]])
 1741:         assert_array_almost_equal(actual, desired, decimal=15)
 1742: 
 1743:     def test_triangular(self):
 1744:         random = Generator(MT19937(self.seed))
 1745:         actual = random.triangular(left=5.12, mode=10.23, right=20.34,
 1746:                                    size=(3, 2))
 1747:         desired = np.array([[ 7.86664070590917, 13.6313848513185 ],  # noqa: E202
 1748:                             [ 7.68152445215983, 14.36169131136546],
 1749:                             [13.16105603911429, 13.72341621856971]])
 1750:         assert_array_almost_equal(actual, desired, decimal=14)
 1751: 
 1752:     def test_uniform(self):
 1753:         random = Generator(MT19937(self.seed))
 1754:         actual = random.uniform(low=1.23, high=10.54, size=(3, 2))
 1755:         desired = np.array([[2.13306255040998 , 7.816987531021207],  # noqa: E203
 1756:                             [2.015436610109887, 8.377577533009589],
 1757:                             [7.421792588856135, 7.891185744455209]])
 1758:         assert_array_almost_equal(actual, desired, decimal=15)
 1759: 
 1760:     def test_uniform_range_bounds(self):
 1761:         fmin = np.finfo('float').min
 1762:         fmax = np.finfo('float').max
 1763: 
 1764:         func = random.uniform
 1765:         assert_raises(OverflowError, func, -np.inf, 0)
 1766:         assert_raises(OverflowError, func, 0, np.inf)
 1767:         assert_raises(OverflowError, func, fmin, fmax)
 1768:         assert_raises(OverflowError, func, [-np.inf], [0])
 1769:         assert_raises(OverflowError, func, [0], [np.inf])
 1770: 
 1771:         # (fmax / 1e17) - fmin is within range, so this should not throw
 1772:         # account for i386 extended precision DBL_MAX / 1e17 + DBL_MAX >
 1773:         # DBL_MAX by increasing fmin a bit
 1774:         random.uniform(low=np.nextafter(fmin, 1), high=fmax / 1e17)
 1775: 
 1776:     def test_uniform_zero_range(self):
 1777:         func = random.uniform
 1778:         result = func(1.5, 1.5)
 1779:         assert_allclose(result, 1.5)
 1780:         result = func([0.0, np.pi], [0.0, np.pi])
 1781:         assert_allclose(result, [0.0, np.pi])
 1782:         result = func([[2145.12], [2145.12]], [2145.12, 2145.12])
 1783:         assert_allclose(result, 2145.12 + np.zeros((2, 2)))
 1784: 
 1785:     def test_uniform_neg_range(self):
 1786:         func = random.uniform
 1787:         assert_raises(ValueError, func, 2, 1)
 1788:         assert_raises(ValueError, func,  [1, 2], [1, 1])
 1789:         assert_raises(ValueError, func,  [[0, 1], [2, 3]], 2)
 1790: 
 1791:     def test_scalar_exception_propagation(self):
 1792:         # Tests that exceptions are correctly propagated in distributions
 1793:         # when called with objects that throw exceptions when converted to
 1794:         # scalars.
 1795:         #
 1796:         # Regression test for gh: 8865
 1797: 
 1798:         class ThrowingFloat(np.ndarray):
 1799:             def __float__(self):
 1800:                 raise TypeError
 1801: 
 1802:         throwing_float = np.array(1.0).view(ThrowingFloat)
 1803:         assert_raises(TypeError, random.uniform, throwing_float,
 1804:                       throwing_float)
 1805: 
 1806:         class ThrowingInteger(np.ndarray):
 1807:             def __int__(self):
 1808:                 raise TypeError
 1809: 
 1810:         throwing_int = np.array(1).view(ThrowingInteger)
 1811:         assert_raises(TypeError, random.hypergeometric, throwing_int, 1, 1)
 1812: 
 1813:     def test_vonmises(self):
 1814:         random = Generator(MT19937(self.seed))
 1815:         actual = random.vonmises(mu=1.23, kappa=1.54, size=(3, 2))
 1816:         desired = np.array([[ 1.107972248690106,  2.841536476232361],
 1817:                             [ 1.832602376042457,  1.945511926976032],
 1818:                             [-0.260147475776542,  2.058047492231698]])
 1819:         assert_array_almost_equal(actual, desired, decimal=15)
 1820: 
 1821:     def test_vonmises_small(self):
 1822:         # check infinite loop, gh-4720
 1823:         random = Generator(MT19937(self.seed))
 1824:         r = random.vonmises(mu=0., kappa=1.1e-8, size=10**6)
 1825:         assert_(np.isfinite(r).all())
 1826: 
 1827:     def test_vonmises_nan(self):
 1828:         random = Generator(MT19937(self.seed))
 1829:         r = random.vonmises(mu=0., kappa=np.nan)
 1830:         assert_(np.isnan(r))
 1831: 
 1832:     @pytest.mark.parametrize("kappa", [1e4, 1e15])
 1833:     def test_vonmises_large_kappa(self, kappa):
 1834:         random = Generator(MT19937(self.seed))
 1835:         rs = RandomState(random.bit_generator)
 1836:         state = random.bit_generator.state
 1837: 
 1838:         random_state_vals = rs.vonmises(0, kappa, size=10)
 1839:         random.bit_generator.state = state
 1840:         gen_vals = random.vonmises(0, kappa, size=10)
 1841:         if kappa < 1e6:
 1842:             assert_allclose(random_state_vals, gen_vals)
 1843:         else:
 1844:             assert np.all(random_state_vals != gen_vals)
 1845: 
 1846:     @pytest.mark.parametrize("mu", [-7., -np.pi, -3.1, np.pi, 3.2])
 1847:     @pytest.mark.parametrize("kappa", [1e-9, 1e-6, 1, 1e3, 1e15])
 1848:     def test_vonmises_large_kappa_range(self, mu, kappa):
 1849:         random = Generator(MT19937(self.seed))
 1850:         r = random.vonmises(mu, kappa, 50)
 1851:         assert_(np.all(r > -np.pi) and np.all(r <= np.pi))
 1852: 
 1853:     def test_wald(self):
 1854:         random = Generator(MT19937(self.seed))
 1855:         actual = random.wald(mean=1.23, scale=1.54, size=(3, 2))
 1856:         desired = np.array([[0.26871721804551, 3.2233942732115 ],  # noqa: E202
 1857:                             [2.20328374987066, 2.40958405189353],
 1858:                             [2.07093587449261, 0.73073890064369]])
 1859:         assert_array_almost_equal(actual, desired, decimal=14)
 1860: 
 1861:     def test_weibull(self):
 1862:         random = Generator(MT19937(self.seed))
 1863:         actual = random.weibull(a=1.23, size=(3, 2))
 1864:         desired = np.array([[0.138613914769468, 1.306463419753191],
 1865:                             [0.111623365934763, 1.446570494646721],
 1866:                             [1.257145775276011, 1.914247725027957]])
 1867:         assert_array_almost_equal(actual, desired, decimal=15)
 1868: 
 1869:     def test_weibull_0(self):
 1870:         random = Generator(MT19937(self.seed))
 1871:         assert_equal(random.weibull(a=0, size=12), np.zeros(12))
 1872:         assert_raises(ValueError, random.weibull, a=-0.)
 1873: 
 1874:     def test_zipf(self):
 1875:         random = Generator(MT19937(self.seed))
 1876:         actual = random.zipf(a=1.23, size=(3, 2))
 1877:         desired = np.array([[  1,   1],
 1878:                             [ 10, 867],
 1879:                             [354,   2]])
 1880:         assert_array_equal(actual, desired)
 1881: 
 1882: 
 1883: class TestBroadcast:
 1884:     # tests that functions that broadcast behave
 1885:     # correctly when presented with non-scalar arguments
 1886:     def setup_method(self):
 1887:         self.seed = 123456789
 1888: 
 1889:     def test_uniform(self):
 1890:         random = Generator(MT19937(self.seed))
 1891:         low = [0]
 1892:         high = [1]
 1893:         uniform = random.uniform
 1894:         desired = np.array([0.16693771389729, 0.19635129550675, 0.75563050964095])
 1895: 
 1896:         random = Generator(MT19937(self.seed))
 1897:         actual = random.uniform(low * 3, high)
 1898:         assert_array_almost_equal(actual, desired, decimal=14)
 1899: 
 1900:         random = Generator(MT19937(self.seed))
 1901:         actual = random.uniform(low, high * 3)
 1902:         assert_array_almost_equal(actual, desired, decimal=14)
 1903: 
 1904:     def test_normal(self):
 1905:         loc = [0]
 1906:         scale = [1]
 1907:         bad_scale = [-1]
 1908:         random = Generator(MT19937(self.seed))
 1909:         desired = np.array([-0.38736406738527, 0.79594375042255, 0.0197076236097])
 1910: 
 1911:         random = Generator(MT19937(self.seed))
 1912:         actual = random.normal(loc * 3, scale)
 1913:         assert_array_almost_equal(actual, desired, decimal=14)
 1914:         assert_raises(ValueError, random.normal, loc * 3, bad_scale)
 1915: 
 1916:         random = Generator(MT19937(self.seed))
 1917:         normal = random.normal
 1918:         actual = normal(loc, scale * 3)
 1919:         assert_array_almost_equal(actual, desired, decimal=14)
 1920:         assert_raises(ValueError, normal, loc, bad_scale * 3)
 1921: 
 1922:     def test_beta(self):
 1923:         a = [1]
 1924:         b = [2]
 1925:         bad_a = [-1]
 1926:         bad_b = [-2]
 1927:         desired = np.array([0.18719338682602, 0.73234824491364, 0.17928615186455])
 1928: 
 1929:         random = Generator(MT19937(self.seed))
 1930:         beta = random.beta
 1931:         actual = beta(a * 3, b)
 1932:         assert_array_almost_equal(actual, desired, decimal=14)
 1933:         assert_raises(ValueError, beta, bad_a * 3, b)
 1934:         assert_raises(ValueError, beta, a * 3, bad_b)
 1935: 
 1936:         random = Generator(MT19937(self.seed))
 1937:         actual = random.beta(a, b * 3)
 1938:         assert_array_almost_equal(actual, desired, decimal=14)
 1939: 
 1940:     def test_exponential(self):
 1941:         scale = [1]
 1942:         bad_scale = [-1]
 1943:         desired = np.array([0.67245993212806, 0.21380495318094, 0.7177848928629])
 1944: 
 1945:         random = Generator(MT19937(self.seed))
 1946:         actual = random.exponential(scale * 3)
 1947:         assert_array_almost_equal(actual, desired, decimal=14)
 1948:         assert_raises(ValueError, random.exponential, bad_scale * 3)
 1949: 
 1950:     def test_standard_gamma(self):
 1951:         shape = [1]
 1952:         bad_shape = [-1]
 1953:         desired = np.array([0.67245993212806, 0.21380495318094, 0.7177848928629])
 1954: 
 1955:         random = Generator(MT19937(self.seed))
 1956:         std_gamma = random.standard_gamma
 1957:         actual = std_gamma(shape * 3)
 1958:         assert_array_almost_equal(actual, desired, decimal=14)
 1959:         assert_raises(ValueError, std_gamma, bad_shape * 3)
 1960: 
 1961:     def test_gamma(self):
 1962:         shape = [1]
 1963:         scale = [2]
 1964:         bad_shape = [-1]
 1965:         bad_scale = [-2]
 1966:         desired = np.array([1.34491986425611, 0.42760990636187, 1.4355697857258])
 1967: 
 1968:         random = Generator(MT19937(self.seed))
 1969:         gamma = random.gamma
 1970:         actual = gamma(shape * 3, scale)
 1971:         assert_array_almost_equal(actual, desired, decimal=14)
 1972:         assert_raises(ValueError, gamma, bad_shape * 3, scale)
 1973:         assert_raises(ValueError, gamma, shape * 3, bad_scale)
 1974: 
 1975:         random = Generator(MT19937(self.seed))
 1976:         gamma = random.gamma
 1977:         actual = gamma(shape, scale * 3)
 1978:         assert_array_almost_equal(actual, desired, decimal=14)
 1979:         assert_raises(ValueError, gamma, bad_shape, scale * 3)
 1980:         assert_raises(ValueError, gamma, shape, bad_scale * 3)
 1981: 
 1982:     def test_f(self):
 1983:         dfnum = [1]
 1984:         dfden = [2]
 1985:         bad_dfnum = [-1]
 1986:         bad_dfden = [-2]
 1987:         desired = np.array([0.07765056244107, 7.72951397913186, 0.05786093891763])
 1988: 
 1989:         random = Generator(MT19937(self.seed))
 1990:         f = random.f
 1991:         actual = f(dfnum * 3, dfden)
 1992:         assert_array_almost_equal(actual, desired, decimal=14)
 1993:         assert_raises(ValueError, f, bad_dfnum * 3, dfden)
 1994:         assert_raises(ValueError, f, dfnum * 3, bad_dfden)
 1995: 
 1996:         random = Generator(MT19937(self.seed))
 1997:         f = random.f
 1998:         actual = f(dfnum, dfden * 3)
 1999:         assert_array_almost_equal(actual, desired, decimal=14)
 2000:         assert_raises(ValueError, f, bad_dfnum, dfden * 3)
 2001:         assert_raises(ValueError, f, dfnum, bad_dfden * 3)
 2002: 
 2003:     def test_noncentral_f(self):
 2004:         dfnum = [2]
 2005:         dfden = [3]
 2006:         nonc = [4]
 2007:         bad_dfnum = [0]
 2008:         bad_dfden = [-1]
 2009:         bad_nonc = [-2]
 2010:         desired = np.array([2.02434240411421, 12.91838601070124, 1.24395160354629])
 2011: 
 2012:         random = Generator(MT19937(self.seed))
 2013:         nonc_f = random.noncentral_f
 2014:         actual = nonc_f(dfnum * 3, dfden, nonc)
 2015:         assert_array_almost_equal(actual, desired, decimal=14)
 2016:         assert np.all(np.isnan(nonc_f(dfnum, dfden, [np.nan] * 3)))
 2017: 
 2018:         assert_raises(ValueError, nonc_f, bad_dfnum * 3, dfden, nonc)
 2019:         assert_raises(ValueError, nonc_f, dfnum * 3, bad_dfden, nonc)
 2020:         assert_raises(ValueError, nonc_f, dfnum * 3, dfden, bad_nonc)
 2021: 
 2022:         random = Generator(MT19937(self.seed))
 2023:         nonc_f = random.noncentral_f
 2024:         actual = nonc_f(dfnum, dfden * 3, nonc)
 2025:         assert_array_almost_equal(actual, desired, decimal=14)
 2026:         assert_raises(ValueError, nonc_f, bad_dfnum, dfden * 3, nonc)
 2027:         assert_raises(ValueError, nonc_f, dfnum, bad_dfden * 3, nonc)
 2028:         assert_raises(ValueError, nonc_f, dfnum, dfden * 3, bad_nonc)
 2029: 
 2030:         random = Generator(MT19937(self.seed))
 2031:         nonc_f = random.noncentral_f
 2032:         actual = nonc_f(dfnum, dfden, nonc * 3)
 2033:         assert_array_almost_equal(actual, desired, decimal=14)
 2034:         assert_raises(ValueError, nonc_f, bad_dfnum, dfden, nonc * 3)
 2035:         assert_raises(ValueError, nonc_f, dfnum, bad_dfden, nonc * 3)
 2036:         assert_raises(ValueError, nonc_f, dfnum, dfden, bad_nonc * 3)
 2037: 
 2038:     def test_noncentral_f_small_df(self):
 2039:         random = Generator(MT19937(self.seed))
 2040:         desired = np.array([0.04714867120827, 0.1239390327694])
 2041:         actual = random.noncentral_f(0.9, 0.9, 2, size=2)
 2042:         assert_array_almost_equal(actual, desired, decimal=14)
 2043: 
 2044:     def test_chisquare(self):
 2045:         df = [1]
 2046:         bad_df = [-1]
 2047:         desired = np.array([0.05573640064251, 1.47220224353539, 2.9469379318589])
 2048: 
 2049:         random = Generator(MT19937(self.seed))
 2050:         actual = random.chisquare(df * 3)
 2051:         assert_array_almost_equal(actual, desired, decimal=14)
 2052:         assert_raises(ValueError, random.chisquare, bad_df * 3)
 2053: 
 2054:     def test_noncentral_chisquare(self):
 2055:         df = [1]
 2056:         nonc = [2]
 2057:         bad_df = [-1]
 2058:         bad_nonc = [-2]
 2059:         desired = np.array([0.07710766249436, 5.27829115110304, 0.630732147399])
 2060: 
 2061:         random = Generator(MT19937(self.seed))
 2062:         nonc_chi = random.noncentral_chisquare
 2063:         actual = nonc_chi(df * 3, nonc)
 2064:         assert_array_almost_equal(actual, desired, decimal=14)
 2065:         assert_raises(ValueError, nonc_chi, bad_df * 3, nonc)
 2066:         assert_raises(ValueError, nonc_chi, df * 3, bad_nonc)
 2067: 
 2068:         random = Generator(MT19937(self.seed))
 2069:         nonc_chi = random.noncentral_chisquare
 2070:         actual = nonc_chi(df, nonc * 3)
 2071:         assert_array_almost_equal(actual, desired, decimal=14)
 2072:         assert_raises(ValueError, nonc_chi, bad_df, nonc * 3)
 2073:         assert_raises(ValueError, nonc_chi, df, bad_nonc * 3)
 2074: 
 2075:     def test_standard_t(self):
 2076:         df = [1]
 2077:         bad_df = [-1]
 2078:         desired = np.array([-1.39498829447098, -1.23058658835223, 0.17207021065983])
 2079: 
 2080:         random = Generator(MT19937(self.seed))
 2081:         actual = random.standard_t(df * 3)
 2082:         assert_array_almost_equal(actual, desired, decimal=14)
 2083:         assert_raises(ValueError, random.standard_t, bad_df * 3)
 2084: 
 2085:     def test_vonmises(self):
 2086:         mu = [2]
 2087:         kappa = [1]
 2088:         bad_kappa = [-1]
 2089:         desired = np.array([2.25935584988528, 2.23326261461399, -2.84152146503326])
 2090: 
 2091:         random = Generator(MT19937(self.seed))
 2092:         actual = random.vonmises(mu * 3, kappa)
 2093:         assert_array_almost_equal(actual, desired, decimal=14)
 2094:         assert_raises(ValueError, random.vonmises, mu * 3, bad_kappa)
 2095: 
 2096:         random = Generator(MT19937(self.seed))
 2097:         actual = random.vonmises(mu, kappa * 3)
 2098:         assert_array_almost_equal(actual, desired, decimal=14)
 2099:         assert_raises(ValueError, random.vonmises, mu, bad_kappa * 3)
 2100: 
 2101:     def test_pareto(self):
 2102:         a = [1]
 2103:         bad_a = [-1]
 2104:         desired = np.array([0.95905052946317, 0.2383810889437, 1.04988745750013])
 2105: 
 2106:         random = Generator(MT19937(self.seed))
 2107:         actual = random.pareto(a * 3)
 2108:         assert_array_almost_equal(actual, desired, decimal=14)
 2109:         assert_raises(ValueError, random.pareto, bad_a * 3)
 2110: 
 2111:     def test_weibull(self):
 2112:         a = [1]
 2113:         bad_a = [-1]
 2114:         desired = np.array([0.67245993212806, 0.21380495318094, 0.7177848928629])
 2115: 
 2116:         random = Generator(MT19937(self.seed))
 2117:         actual = random.weibull(a * 3)
 2118:         assert_array_almost_equal(actual, desired, decimal=14)
 2119:         assert_raises(ValueError, random.weibull, bad_a * 3)
 2120: 
 2121:     def test_power(self):
 2122:         a = [1]
 2123:         bad_a = [-1]
 2124:         desired = np.array([0.48954864361052, 0.19249412888486, 0.51216834058807])
 2125: 
 2126:         random = Generator(MT19937(self.seed))
 2127:         actual = random.power(a * 3)
 2128:         assert_array_almost_equal(actual, desired, decimal=14)
 2129:         assert_raises(ValueError, random.power, bad_a * 3)
 2130: 
 2131:     def test_laplace(self):
 2132:         loc = [0]
 2133:         scale = [1]
 2134:         bad_scale = [-1]
 2135:         desired = np.array([-1.09698732625119, -0.93470271947368, 0.71592671378202])
 2136: 
 2137:         random = Generator(MT19937(self.seed))
 2138:         laplace = random.laplace
 2139:         actual = laplace(loc * 3, scale)
 2140:         assert_array_almost_equal(actual, desired, decimal=14)
 2141:         assert_raises(ValueError, laplace, loc * 3, bad_scale)
 2142: 
 2143:         random = Generator(MT19937(self.seed))
 2144:         laplace = random.laplace
 2145:         actual = laplace(loc, scale * 3)
 2146:         assert_array_almost_equal(actual, desired, decimal=14)
 2147:         assert_raises(ValueError, laplace, loc, bad_scale * 3)
 2148: 
 2149:     def test_gumbel(self):
 2150:         loc = [0]
 2151:         scale = [1]
 2152:         bad_scale = [-1]
 2153:         desired = np.array([1.70020068231762, 1.52054354273631, -0.34293267607081])
 2154: 
 2155:         random = Generator(MT19937(self.seed))
 2156:         gumbel = random.gumbel
 2157:         actual = gumbel(loc * 3, scale)
 2158:         assert_array_almost_equal(actual, desired, decimal=14)
 2159:         assert_raises(ValueError, gumbel, loc * 3, bad_scale)
 2160: 
 2161:         random = Generator(MT19937(self.seed))
 2162:         gumbel = random.gumbel
 2163:         actual = gumbel(loc, scale * 3)
 2164:         assert_array_almost_equal(actual, desired, decimal=14)
 2165:         assert_raises(ValueError, gumbel, loc, bad_scale * 3)
 2166: 
 2167:     def test_logistic(self):
 2168:         loc = [0]
 2169:         scale = [1]
 2170:         bad_scale = [-1]
 2171:         desired = np.array([-1.607487640433, -1.40925686003678, 1.12887112820397])
 2172: 
 2173:         random = Generator(MT19937(self.seed))
 2174:         actual = random.logistic(loc * 3, scale)
 2175:         assert_array_almost_equal(actual, desired, decimal=14)
 2176:         assert_raises(ValueError, random.logistic, loc * 3, bad_scale)
 2177: 
 2178:         random = Generator(MT19937(self.seed))
 2179:         actual = random.logistic(loc, scale * 3)
 2180:         assert_array_almost_equal(actual, desired, decimal=14)
 2181:         assert_raises(ValueError, random.logistic, loc, bad_scale * 3)
 2182:         assert_equal(random.logistic(1.0, 0.0), 1.0)
 2183: 
 2184:     def test_lognormal(self):
 2185:         mean = [0]
 2186:         sigma = [1]
 2187:         bad_sigma = [-1]
 2188:         desired = np.array([0.67884390500697, 2.21653186290321, 1.01990310084276])
 2189: 
 2190:         random = Generator(MT19937(self.seed))
 2191:         lognormal = random.lognormal
 2192:         actual = lognormal(mean * 3, sigma)
 2193:         assert_array_almost_equal(actual, desired, decimal=14)
 2194:         assert_raises(ValueError, lognormal, mean * 3, bad_sigma)
 2195: 
 2196:         random = Generator(MT19937(self.seed))
 2197:         actual = random.lognormal(mean, sigma * 3)
 2198:         assert_raises(ValueError, random.lognormal, mean, bad_sigma * 3)
 2199: 
 2200:     def test_rayleigh(self):
 2201:         scale = [1]
 2202:         bad_scale = [-1]
 2203:         desired = np.array(
 2204:             [1.1597068009872629,
 2205:              0.6539188836253857,
 2206:              1.1981526554349398]
 2207:         )
 2208: 
 2209:         random = Generator(MT19937(self.seed))
 2210:         actual = random.rayleigh(scale * 3)
 2211:         assert_array_almost_equal(actual, desired, decimal=14)
 2212:         assert_raises(ValueError, random.rayleigh, bad_scale * 3)
 2213: 
 2214:     def test_wald(self):
 2215:         mean = [0.5]
 2216:         scale = [1]
 2217:         bad_mean = [0]
 2218:         bad_scale = [-2]
 2219:         desired = np.array([0.38052407392905, 0.50701641508592, 0.484935249864])
 2220: 
 2221:         random = Generator(MT19937(self.seed))
 2222:         actual = random.wald(mean * 3, scale)
 2223:         assert_array_almost_equal(actual, desired, decimal=14)
 2224:         assert_raises(ValueError, random.wald, bad_mean * 3, scale)
 2225:         assert_raises(ValueError, random.wald, mean * 3, bad_scale)
 2226: 
 2227:         random = Generator(MT19937(self.seed))
 2228:         actual = random.wald(mean, scale * 3)
 2229:         assert_array_almost_equal(actual, desired, decimal=14)
 2230:         assert_raises(ValueError, random.wald, bad_mean, scale * 3)
 2231:         assert_raises(ValueError, random.wald, mean, bad_scale * 3)
 2232: 
 2233:     def test_triangular(self):
 2234:         left = [1]
 2235:         right = [3]
 2236:         mode = [2]
 2237:         bad_left_one = [3]
 2238:         bad_mode_one = [4]
 2239:         bad_left_two, bad_mode_two = right * 2
 2240:         desired = np.array([1.57781954604754, 1.62665986867957, 2.30090130831326])
 2241: 
 2242:         random = Generator(MT19937(self.seed))
 2243:         triangular = random.triangular
 2244:         actual = triangular(left * 3, mode, right)
 2245:         assert_array_almost_equal(actual, desired, decimal=14)
 2246:         assert_raises(ValueError, triangular, bad_left_one * 3, mode, right)
 2247:         assert_raises(ValueError, triangular, left * 3, bad_mode_one, right)
 2248:         assert_raises(ValueError, triangular, bad_left_two * 3, bad_mode_two,
 2249:                       right)
 2250: 
 2251:         random = Generator(MT19937(self.seed))
 2252:         triangular = random.triangular
 2253:         actual = triangular(left, mode * 3, right)
 2254:         assert_array_almost_equal(actual, desired, decimal=14)
 2255:         assert_raises(ValueError, triangular, bad_left_one, mode * 3, right)
 2256:         assert_raises(ValueError, triangular, left, bad_mode_one * 3, right)
 2257:         assert_raises(ValueError, triangular, bad_left_two, bad_mode_two * 3,
 2258:                       right)
 2259: 
 2260:         random = Generator(MT19937(self.seed))
 2261:         triangular = random.triangular
 2262:         actual = triangular(left, mode, right * 3)
 2263:         assert_array_almost_equal(actual, desired, decimal=14)
 2264:         assert_raises(ValueError, triangular, bad_left_one, mode, right * 3)
 2265:         assert_raises(ValueError, triangular, left, bad_mode_one, right * 3)
 2266:         assert_raises(ValueError, triangular, bad_left_two, bad_mode_two,
 2267:                       right * 3)
 2268: 
 2269:         assert_raises(ValueError, triangular, 10., 0., 20.)
 2270:         assert_raises(ValueError, triangular, 10., 25., 20.)
 2271:         assert_raises(ValueError, triangular, 10., 10., 10.)
 2272: 
 2273:     def test_binomial(self):
 2274:         n = [1]
 2275:         p = [0.5]
 2276:         bad_n = [-1]
 2277:         bad_p_one = [-1]
 2278:         bad_p_two = [1.5]
 2279:         desired = np.array([0, 0, 1])
 2280: 
 2281:         random = Generator(MT19937(self.seed))
 2282:         binom = random.binomial
 2283:         actual = binom(n * 3, p)
 2284:         assert_array_equal(actual, desired)
 2285:         assert_raises(ValueError, binom, bad_n * 3, p)
 2286:         assert_raises(ValueError, binom, n * 3, bad_p_one)
 2287:         assert_raises(ValueError, binom, n * 3, bad_p_two)
 2288: 
 2289:         random = Generator(MT19937(self.seed))
 2290:         actual = random.binomial(n, p * 3)
 2291:         assert_array_equal(actual, desired)
 2292:         assert_raises(ValueError, binom, bad_n, p * 3)
 2293:         assert_raises(ValueError, binom, n, bad_p_one * 3)
 2294:         assert_raises(ValueError, binom, n, bad_p_two * 3)
 2295: 
 2296:     def test_negative_binomial(self):
 2297:         n = [1]
 2298:         p = [0.5]
 2299:         bad_n = [-1]
 2300:         bad_p_one = [-1]
 2301:         bad_p_two = [1.5]
 2302:         desired = np.array([0, 2, 1], dtype=np.int64)
 2303: 
 2304:         random = Generator(MT19937(self.seed))
 2305:         neg_binom = random.negative_binomial
 2306:         actual = neg_binom(n * 3, p)
 2307:         assert_array_equal(actual, desired)
 2308:         assert_raises(ValueError, neg_binom, bad_n * 3, p)
 2309:         assert_raises(ValueError, neg_binom, n * 3, bad_p_one)
 2310:         assert_raises(ValueError, neg_binom, n * 3, bad_p_two)
 2311: 
 2312:         random = Generator(MT19937(self.seed))
 2313:         neg_binom = random.negative_binomial
 2314:         actual = neg_binom(n, p * 3)
 2315:         assert_array_equal(actual, desired)
 2316:         assert_raises(ValueError, neg_binom, bad_n, p * 3)
 2317:         assert_raises(ValueError, neg_binom, n, bad_p_one * 3)
 2318:         assert_raises(ValueError, neg_binom, n, bad_p_two * 3)
 2319: 
 2320:     def test_poisson(self):
 2321: 
 2322:         lam = [1]
 2323:         bad_lam_one = [-1]
 2324:         desired = np.array([0, 0, 3])
 2325: 
 2326:         random = Generator(MT19937(self.seed))
 2327:         max_lam = random._poisson_lam_max
 2328:         bad_lam_two = [max_lam * 2]
 2329:         poisson = random.poisson
 2330:         actual = poisson(lam * 3)
 2331:         assert_array_equal(actual, desired)
 2332:         assert_raises(ValueError, poisson, bad_lam_one * 3)
 2333:         assert_raises(ValueError, poisson, bad_lam_two * 3)
 2334: 
 2335:     def test_zipf(self):
 2336:         a = [2]
 2337:         bad_a = [0]
 2338:         desired = np.array([1, 8, 1])
 2339: 
 2340:         random = Generator(MT19937(self.seed))
 2341:         zipf = random.zipf
 2342:         actual = zipf(a * 3)
 2343:         assert_array_equal(actual, desired)
 2344:         assert_raises(ValueError, zipf, bad_a * 3)
 2345:         with np.errstate(invalid='ignore'):
 2346:             assert_raises(ValueError, zipf, np.nan)
 2347:             assert_raises(ValueError, zipf, [0, 0, np.nan])
 2348: 
 2349:     def test_geometric(self):
 2350:         p = [0.5]
 2351:         bad_p_one = [-1]
 2352:         bad_p_two = [1.5]
 2353:         desired = np.array([1, 1, 3])
 2354: 
 2355:         random = Generator(MT19937(self.seed))
 2356:         geometric = random.geometric
 2357:         actual = geometric(p * 3)
 2358:         assert_array_equal(actual, desired)
 2359:         assert_raises(ValueError, geometric, bad_p_one * 3)
 2360:         assert_raises(ValueError, geometric, bad_p_two * 3)
 2361: 
 2362:     def test_hypergeometric(self):
 2363:         ngood = [1]
 2364:         nbad = [2]
 2365:         nsample = [2]
 2366:         bad_ngood = [-1]
 2367:         bad_nbad = [-2]
 2368:         bad_nsample_one = [-1]
 2369:         bad_nsample_two = [4]
 2370:         desired = np.array([0, 0, 1])
 2371: 
 2372:         random = Generator(MT19937(self.seed))
 2373:         actual = random.hypergeometric(ngood * 3, nbad, nsample)
 2374:         assert_array_equal(actual, desired)
 2375:         assert_raises(ValueError, random.hypergeometric, bad_ngood * 3, nbad, nsample)
 2376:         assert_raises(ValueError, random.hypergeometric, ngood * 3, bad_nbad, nsample)
 2377:         assert_raises(ValueError, random.hypergeometric, ngood * 3, nbad, bad_nsample_one)  # noqa: E501
 2378:         assert_raises(ValueError, random.hypergeometric, ngood * 3, nbad, bad_nsample_two)  # noqa: E501
 2379: 
 2380:         random = Generator(MT19937(self.seed))
 2381:         actual = random.hypergeometric(ngood, nbad * 3, nsample)
 2382:         assert_array_equal(actual, desired)
 2383:         assert_raises(ValueError, random.hypergeometric, bad_ngood, nbad * 3, nsample)
 2384:         assert_raises(ValueError, random.hypergeometric, ngood, bad_nbad * 3, nsample)
 2385:         assert_raises(ValueError, random.hypergeometric, ngood, nbad * 3, bad_nsample_one)  # noqa: E501
 2386:         assert_raises(ValueError, random.hypergeometric, ngood, nbad * 3, bad_nsample_two)  # noqa: E501
 2387: 
 2388:         random = Generator(MT19937(self.seed))
 2389:         hypergeom = random.hypergeometric
 2390:         actual = hypergeom(ngood, nbad, nsample * 3)
 2391:         assert_array_equal(actual, desired)
 2392:         assert_raises(ValueError, hypergeom, bad_ngood, nbad, nsample * 3)
 2393:         assert_raises(ValueError, hypergeom, ngood, bad_nbad, nsample * 3)
 2394:         assert_raises(ValueError, hypergeom, ngood, nbad, bad_nsample_one * 3)
 2395:         assert_raises(ValueError, hypergeom, ngood, nbad, bad_nsample_two * 3)
 2396: 
 2397:         assert_raises(ValueError, hypergeom, -1, 10, 20)
 2398:         assert_raises(ValueError, hypergeom, 10, -1, 20)
 2399:         assert_raises(ValueError, hypergeom, 10, 10, -1)
 2400:         assert_raises(ValueError, hypergeom, 10, 10, 25)
 2401: 
 2402:         # ValueError for arguments that are too big.
 2403:         assert_raises(ValueError, hypergeom, 2**30, 10, 20)
 2404:         assert_raises(ValueError, hypergeom, 999, 2**31, 50)
 2405:         assert_raises(ValueError, hypergeom, 999, [2**29, 2**30], 1000)
 2406: 
 2407:     def test_logseries(self):
 2408:         p = [0.5]
 2409:         bad_p_one = [2]
 2410:         bad_p_two = [-1]
 2411:         desired = np.array([1, 1, 1])
 2412: 
 2413:         random = Generator(MT19937(self.seed))
 2414:         logseries = random.logseries
 2415:         actual = logseries(p * 3)
 2416:         assert_array_equal(actual, desired)
 2417:         assert_raises(ValueError, logseries, bad_p_one * 3)
 2418:         assert_raises(ValueError, logseries, bad_p_two * 3)
 2419: 
 2420:     def test_multinomial(self):
 2421:         random = Generator(MT19937(self.seed))
 2422:         actual = random.multinomial([5, 20], [1 / 6.] * 6, size=(3, 2))
 2423:         desired = np.array([[[0, 0, 2, 1, 2, 0],
 2424:                              [2, 3, 6, 4, 2, 3]],
 2425:                             [[1, 0, 1, 0, 2, 1],
 2426:                              [7, 2, 2, 1, 4, 4]],
 2427:                             [[0, 2, 0, 1, 2, 0],
 2428:                              [3, 2, 3, 3, 4, 5]]], dtype=np.int64)
 2429:         assert_array_equal(actual, desired)
 2430: 
 2431:         random = Generator(MT19937(self.seed))
 2432:         actual = random.multinomial([5, 20], [1 / 6.] * 6)
 2433:         desired = np.array([[0, 0, 2, 1, 2, 0],
 2434:                             [2, 3, 6, 4, 2, 3]], dtype=np.int64)
 2435:         assert_array_equal(actual, desired)
 2436: 
 2437:         random = Generator(MT19937(self.seed))
 2438:         actual = random.multinomial([5, 20], [[1 / 6.] * 6] * 2)
 2439:         desired = np.array([[0, 0, 2, 1, 2, 0],
 2440:                             [2, 3, 6, 4, 2, 3]], dtype=np.int64)
 2441:         assert_array_equal(actual, desired)
 2442: 
 2443:         random = Generator(MT19937(self.seed))
 2444:         actual = random.multinomial([[5], [20]], [[1 / 6.] * 6] * 2)
 2445:         desired = np.array([[[0, 0, 2, 1, 2, 0],
 2446:                              [0, 0, 2, 1, 1, 1]],
 2447:                             [[4, 2, 3, 3, 5, 3],
 2448:                              [7, 2, 2, 1, 4, 4]]], dtype=np.int64)
 2449:         assert_array_equal(actual, desired)
 2450: 
 2451:     @pytest.mark.parametrize("n", [10,
 2452:                                    np.array([10, 10]),
 2453:                                    np.array([[[10]], [[10]]])
 2454:                                    ]
 2455:                              )
 2456:     def test_multinomial_pval_broadcast(self, n):
 2457:         random = Generator(MT19937(self.seed))
 2458:         pvals = np.array([1 / 4] * 4)
 2459:         actual = random.multinomial(n, pvals)
 2460:         n_shape = () if isinstance(n, int) else n.shape
 2461:         expected_shape = n_shape + (4,)
 2462:         assert actual.shape == expected_shape
 2463:         pvals = np.vstack([pvals, pvals])
 2464:         actual = random.multinomial(n, pvals)
 2465:         expected_shape = np.broadcast_shapes(n_shape, pvals.shape[:-1]) + (4,)
 2466:         assert actual.shape == expected_shape
 2467: 
 2468:         pvals = np.vstack([[pvals], [pvals]])
 2469:         actual = random.multinomial(n, pvals)
 2470:         expected_shape = np.broadcast_shapes(n_shape, pvals.shape[:-1])
 2471:         assert actual.shape == expected_shape + (4,)
 2472:         actual = random.multinomial(n, pvals, size=(3, 2) + expected_shape)
 2473:         assert actual.shape == (3, 2) + expected_shape + (4,)
 2474: 
 2475:         with pytest.raises(ValueError):
 2476:             # Ensure that size is not broadcast
 2477:             actual = random.multinomial(n, pvals, size=(1,) * 6)
 2478: 
 2479:     def test_invalid_pvals_broadcast(self):
 2480:         random = Generator(MT19937(self.seed))
 2481:         pvals = [[1 / 6] * 6, [1 / 4] * 6]
 2482:         assert_raises(ValueError, random.multinomial, 1, pvals)
 2483:         assert_raises(ValueError, random.multinomial, 6, 0.5)
 2484: 
 2485:     def test_empty_outputs(self):
 2486:         random = Generator(MT19937(self.seed))
 2487:         actual = random.multinomial(np.empty((10, 0, 6), "i8"), [1 / 6] * 6)
 2488:         assert actual.shape == (10, 0, 6, 6)
 2489:         actual = random.multinomial(12, np.empty((10, 0, 10)))
 2490:         assert actual.shape == (10, 0, 10)
 2491:         actual = random.multinomial(np.empty((3, 0, 7), "i8"),
 2492:                                     np.empty((3, 0, 7, 4)))
 2493:         assert actual.shape == (3, 0, 7, 4)
 2494: 
 2495: 
 2496: @pytest.mark.skipif(IS_WASM, reason="can't start thread")
 2497: class TestThread:
 2498:     # make sure each state produces the same sequence even in threads
 2499:     def setup_method(self):
 2500:         self.seeds = range(4)
 2501: 
 2502:     def check_function(self, function, sz):
 2503:         from threading import Thread
 2504: 
 2505:         out1 = np.empty((len(self.seeds),) + sz)
 2506:         out2 = np.empty((len(self.seeds),) + sz)
 2507: 
 2508:         # threaded generation
 2509:         t = [Thread(target=function, args=(Generator(MT19937(s)), o))
 2510:              for s, o in zip(self.seeds, out1)]
 2511:         [x.start() for x in t]
 2512:         [x.join() for x in t]
 2513: 
 2514:         # the same serial
 2515:         for s, o in zip(self.seeds, out2):
 2516:             function(Generator(MT19937(s)), o)
 2517: 
 2518:         # these platforms change x87 fpu precision mode in threads
 2519:         if np.intp().dtype.itemsize == 4 and sys.platform == "win32":
 2520:             assert_array_almost_equal(out1, out2)
 2521:         else:
 2522:             assert_array_equal(out1, out2)
 2523: 
 2524:     def test_normal(self):
 2525:         def gen_random(state, out):
 2526:             out[...] = state.normal(size=10000)
 2527: 
 2528:         self.check_function(gen_random, sz=(10000,))
 2529: 
 2530:     def test_exp(self):
 2531:         def gen_random(state, out):
 2532:             out[...] = state.exponential(scale=np.ones((100, 1000)))
 2533: 
 2534:         self.check_function(gen_random, sz=(100, 1000))
 2535: 
 2536:     def test_multinomial(self):
 2537:         def gen_random(state, out):
 2538:             out[...] = state.multinomial(10, [1 / 6.] * 6, size=10000)
 2539: 
 2540:         self.check_function(gen_random, sz=(10000, 6))
 2541: 
 2542: 
 2543: # See Issue #4263
 2544: class TestSingleEltArrayInput:
 2545:     def setup_method(self):
 2546:         self.argOne = np.array([2])
 2547:         self.argTwo = np.array([3])
 2548:         self.argThree = np.array([4])
 2549:         self.tgtShape = (1,)
 2550: 
 2551:     def test_one_arg_funcs(self):
 2552:         funcs = (random.exponential, random.standard_gamma,
 2553:                  random.chisquare, random.standard_t,
 2554:                  random.pareto, random.weibull,
 2555:                  random.power, random.rayleigh,
 2556:                  random.poisson, random.zipf,
 2557:                  random.geometric, random.logseries)
 2558: 
 2559:         probfuncs = (random.geometric, random.logseries)
 2560: 
 2561:         for func in funcs:
 2562:             if func in probfuncs:  # p < 1.0
 2563:                 out = func(np.array([0.5]))
 2564: 
 2565:             else:
 2566:                 out = func(self.argOne)
 2567: 
 2568:             assert_equal(out.shape, self.tgtShape)
 2569: 
 2570:     def test_two_arg_funcs(self):
 2571:         funcs = (random.uniform, random.normal,
 2572:                  random.beta, random.gamma,
 2573:                  random.f, random.noncentral_chisquare,
 2574:                  random.vonmises, random.laplace,
 2575:                  random.gumbel, random.logistic,
 2576:                  random.lognormal, random.wald,
 2577:                  random.binomial, random.negative_binomial)
 2578: 
 2579:         probfuncs = (random.binomial, random.negative_binomial)
 2580: 
 2581:         for func in funcs:
 2582:             if func in probfuncs:  # p <= 1
 2583:                 argTwo = np.array([0.5])
 2584: 
 2585:             else:
 2586:                 argTwo = self.argTwo
 2587: 
 2588:             out = func(self.argOne, argTwo)
 2589:             assert_equal(out.shape, self.tgtShape)
 2590: 
 2591:             out = func(self.argOne[0], argTwo)
 2592:             assert_equal(out.shape, self.tgtShape)
 2593: 
 2594:             out = func(self.argOne, argTwo[0])
 2595:             assert_equal(out.shape, self.tgtShape)
 2596: 
 2597:     def test_integers(self, endpoint):
 2598:         itype = [np.bool, np.int8, np.uint8, np.int16, np.uint16,
 2599:                  np.int32, np.uint32, np.int64, np.uint64]
 2600:         func = random.integers
 2601:         high = np.array([1])
 2602:         low = np.array([0])
 2603: 
 2604:         for dt in itype:
 2605:             out = func(low, high, endpoint=endpoint, dtype=dt)
 2606:             assert_equal(out.shape, self.tgtShape)
 2607: 
 2608:             out = func(low[0], high, endpoint=endpoint, dtype=dt)
 2609:             assert_equal(out.shape, self.tgtShape)
 2610: 
 2611:             out = func(low, high[0], endpoint=endpoint, dtype=dt)
 2612:             assert_equal(out.shape, self.tgtShape)
 2613: 
 2614:     def test_three_arg_funcs(self):
 2615:         funcs = [random.noncentral_f, random.triangular,
 2616:                  random.hypergeometric]
 2617: 
 2618:         for func in funcs:
 2619:             out = func(self.argOne, self.argTwo, self.argThree)
 2620:             assert_equal(out.shape, self.tgtShape)
 2621: 
 2622:             out = func(self.argOne[0], self.argTwo, self.argThree)
 2623:             assert_equal(out.shape, self.tgtShape)
 2624: 
 2625:             out = func(self.argOne, self.argTwo[0], self.argThree)
 2626:             assert_equal(out.shape, self.tgtShape)
 2627: 
 2628: 
 2629: @pytest.mark.parametrize("config", JUMP_TEST_DATA)
 2630: def test_jumped(config):
 2631:     # Each config contains the initial seed, a number of raw steps
 2632:     # the sha256 hashes of the initial and the final states' keys and
 2633:     # the position of the initial and the final state.
 2634:     # These were produced using the original C implementation.
 2635:     seed = config["seed"]
 2636:     steps = config["steps"]
 2637: 
 2638:     mt19937 = MT19937(seed)
 2639:     # Burn step
 2640:     mt19937.random_raw(steps)
 2641:     key = mt19937.state["state"]["key"]
 2642:     if sys.byteorder == 'big':
 2643:         key = key.byteswap()
 2644:     sha256 = hashlib.sha256(key)
 2645:     assert mt19937.state["state"]["pos"] == config["initial"]["pos"]
 2646:     assert sha256.hexdigest() == config["initial"]["key_sha256"]
 2647: 
 2648:     jumped = mt19937.jumped()
 2649:     key = jumped.state["state"]["key"]
 2650:     if sys.byteorder == 'big':
 2651:         key = key.byteswap()
 2652:     sha256 = hashlib.sha256(key)
 2653:     assert jumped.state["state"]["pos"] == config["jumped"]["pos"]
 2654:     assert sha256.hexdigest() == config["jumped"]["key_sha256"]
 2655: 
 2656: 
 2657: def test_broadcast_size_error():
 2658:     mu = np.ones(3)
 2659:     sigma = np.ones((4, 3))
 2660:     size = (10, 4, 2)
 2661:     assert random.normal(mu, sigma, size=(5, 4, 3)).shape == (5, 4, 3)
 2662:     with pytest.raises(ValueError):
 2663:         random.normal(mu, sigma, size=size)
 2664:     with pytest.raises(ValueError):
 2665:         random.normal(mu, sigma, size=(1, 3))
 2666:     with pytest.raises(ValueError):
 2667:         random.normal(mu, sigma, size=(4, 1, 1))
 2668:     # 1 arg
 2669:     shape = np.ones((4, 3))
 2670:     with pytest.raises(ValueError):
 2671:         random.standard_gamma(shape, size=size)
 2672:     with pytest.raises(ValueError):
 2673:         random.standard_gamma(shape, size=(3,))
 2674:     with pytest.raises(ValueError):
 2675:         random.standard_gamma(shape, size=3)
 2676:     # Check out
 2677:     out = np.empty(size)
 2678:     with pytest.raises(ValueError):
 2679:         random.standard_gamma(shape, out=out)
 2680: 
 2681:     # 2 arg
 2682:     with pytest.raises(ValueError):
 2683:         random.binomial(1, [0.3, 0.7], size=(2, 1))
 2684:     with pytest.raises(ValueError):
 2685:         random.binomial([1, 2], 0.3, size=(2, 1))
 2686:     with pytest.raises(ValueError):
 2687:         random.binomial([1, 2], [0.3, 0.7], size=(2, 1))
 2688:     with pytest.raises(ValueError):
 2689:         random.multinomial([2, 2], [.3, .7], size=(2, 1))
 2690: 
 2691:     # 3 arg
 2692:     a = random.chisquare(5, size=3)
 2693:     b = random.chisquare(5, size=(4, 3))
 2694:     c = random.chisquare(5, size=(5, 4, 3))
 2695:     assert random.noncentral_f(a, b, c).shape == (5, 4, 3)
 2696:     with pytest.raises(ValueError, match=r"Output size \(6, 5, 1, 1\) is"):
 2697:         random.noncentral_f(a, b, c, size=(6, 5, 1, 1))
 2698: 
 2699: 
 2700: def test_broadcast_size_scalar():
 2701:     mu = np.ones(3)
 2702:     sigma = np.ones(3)
 2703:     random.normal(mu, sigma, size=3)
 2704:     with pytest.raises(ValueError):
 2705:         random.normal(mu, sigma, size=2)
 2706: 
 2707: 
 2708: def test_ragged_shuffle():
 2709:     # GH 18142
 2710:     seq = [[], [], 1]
 2711:     gen = Generator(MT19937(0))
 2712:     assert_no_warnings(gen.shuffle, seq)
 2713:     assert seq == [1, [], []]
 2714: 
 2715: 
 2716: @pytest.mark.parametrize("high", [-2, [-2]])
 2717: @pytest.mark.parametrize("endpoint", [True, False])
 2718: def test_single_arg_integer_exception(high, endpoint):
 2719:     # GH 14333
 2720:     gen = Generator(MT19937(0))
 2721:     msg = 'high < 0' if endpoint else 'high <= 0'
 2722:     with pytest.raises(ValueError, match=msg):
 2723:         gen.integers(high, endpoint=endpoint)
 2724:     msg = 'low > high' if endpoint else 'low >= high'
 2725:     with pytest.raises(ValueError, match=msg):
 2726:         gen.integers(-1, high, endpoint=endpoint)
 2727:     with pytest.raises(ValueError, match=msg):
 2728:         gen.integers([-1], high, endpoint=endpoint)
 2729: 
 2730: 
 2731: @pytest.mark.parametrize("dtype", ["f4", "f8"])
 2732: def test_c_contig_req_out(dtype):
 2733:     # GH 18704
 2734:     out = np.empty((2, 3), order="F", dtype=dtype)
 2735:     shape = [1, 2, 3]
 2736:     with pytest.raises(ValueError, match="Supplied output array"):
 2737:         random.standard_gamma(shape, out=out, dtype=dtype)
 2738:     with pytest.raises(ValueError, match="Supplied output array"):
 2739:         random.standard_gamma(shape, out=out, size=out.shape, dtype=dtype)
 2740: 
 2741: 
 2742: @pytest.mark.parametrize("dtype", ["f4", "f8"])
 2743: @pytest.mark.parametrize("order", ["F", "C"])
 2744: @pytest.mark.parametrize("dist", [random.standard_normal, random.random])
 2745: def test_contig_req_out(dist, order, dtype):
 2746:     # GH 18704
 2747:     out = np.empty((2, 3), dtype=dtype, order=order)
 2748:     variates = dist(out=out, dtype=dtype)
 2749:     assert variates is out
 2750:     variates = dist(out=out, dtype=dtype, size=out.shape)
 2751:     assert variates is out
 2752: 
 2753: 
 2754: def test_generator_ctor_old_style_pickle():
 2755:     rg = np.random.Generator(np.random.PCG64DXSM(0))
 2756:     rg.standard_normal(1)
 2757:     # Directly call reduce which is used in pickling
 2758:     ctor, (bit_gen, ), _ = rg.__reduce__()
 2759:     # Simulate unpickling an old pickle that only has the name
 2760:     assert bit_gen.__class__.__name__ == "PCG64DXSM"
 2761:     print(ctor)
 2762:     b = ctor(*("PCG64DXSM",))
 2763:     print(b)
 2764:     b.bit_generator.state = bit_gen.state
 2765:     state_b = b.bit_generator.state
 2766:     assert bit_gen.state == state_b
 2767: 
 2768: 
 2769: def test_pickle_preserves_seed_sequence():
 2770:     # GH 26234
 2771:     # Add explicit test that bit generators preserve seed sequences
 2772:     import pickle
 2773: 
 2774:     rg = np.random.Generator(np.random.PCG64DXSM(20240411))
 2775:     ss = rg.bit_generator.seed_seq
 2776:     rg_plk = pickle.loads(pickle.dumps(rg))
 2777:     ss_plk = rg_plk.bit_generator.seed_seq
 2778:     assert_equal(ss.state, ss_plk.state)
 2779:     assert_equal(ss.pool, ss_plk.pool)
 2780: 
 2781:     rg.bit_generator.seed_seq.spawn(10)
 2782:     rg_plk = pickle.loads(pickle.dumps(rg))
 2783:     ss_plk = rg_plk.bit_generator.seed_seq
 2784:     assert_equal(ss.state, ss_plk.state)
 2785: 
 2786: 
 2787: @pytest.mark.parametrize("version", [121, 126])
 2788: def test_legacy_pickle(version):
 2789:     # Pickling format was changes in 1.22.x and in 2.0.x
 2790:     import gzip
 2791:     import pickle
 2792: 
 2793:     base_path = os.path.split(os.path.abspath(__file__))[0]
 2794:     pkl_file = os.path.join(
 2795:         base_path, "data", f"generator_pcg64_np{version}.pkl.gz"
 2796:     )
 2797:     with gzip.open(pkl_file) as gz:
 2798:         rg = pickle.load(gz)
 2799:     state = rg.bit_generator.state['state']
 2800: 
 2801:     assert isinstance(rg, Generator)
 2802:     assert isinstance(rg.bit_generator, np.random.PCG64)
 2803:     assert state['state'] == 35399562948360463058890781895381311971
 2804:     assert state['inc'] == 87136372517582989555478159403783844777
