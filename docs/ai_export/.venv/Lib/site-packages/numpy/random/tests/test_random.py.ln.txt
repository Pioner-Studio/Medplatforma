    1: import sys
    2: import warnings
    3: 
    4: import pytest
    5: 
    6: import numpy as np
    7: from numpy import random
    8: from numpy.testing import (
    9:     IS_WASM,
   10:     assert_,
   11:     assert_array_almost_equal,
   12:     assert_array_equal,
   13:     assert_equal,
   14:     assert_no_warnings,
   15:     assert_raises,
   16:     assert_warns,
   17:     suppress_warnings,
   18: )
   19: 
   20: 
   21: class TestSeed:
   22:     def test_scalar(self):
   23:         s = np.random.RandomState(0)
   24:         assert_equal(s.randint(1000), 684)
   25:         s = np.random.RandomState(4294967295)
   26:         assert_equal(s.randint(1000), 419)
   27: 
   28:     def test_array(self):
   29:         s = np.random.RandomState(range(10))
   30:         assert_equal(s.randint(1000), 468)
   31:         s = np.random.RandomState(np.arange(10))
   32:         assert_equal(s.randint(1000), 468)
   33:         s = np.random.RandomState([0])
   34:         assert_equal(s.randint(1000), 973)
   35:         s = np.random.RandomState([4294967295])
   36:         assert_equal(s.randint(1000), 265)
   37: 
   38:     def test_invalid_scalar(self):
   39:         # seed must be an unsigned 32 bit integer
   40:         assert_raises(TypeError, np.random.RandomState, -0.5)
   41:         assert_raises(ValueError, np.random.RandomState, -1)
   42: 
   43:     def test_invalid_array(self):
   44:         # seed must be an unsigned 32 bit integer
   45:         assert_raises(TypeError, np.random.RandomState, [-0.5])
   46:         assert_raises(ValueError, np.random.RandomState, [-1])
   47:         assert_raises(ValueError, np.random.RandomState, [4294967296])
   48:         assert_raises(ValueError, np.random.RandomState, [1, 2, 4294967296])
   49:         assert_raises(ValueError, np.random.RandomState, [1, -2, 4294967296])
   50: 
   51:     def test_invalid_array_shape(self):
   52:         # gh-9832
   53:         assert_raises(ValueError, np.random.RandomState,
   54:                       np.array([], dtype=np.int64))
   55:         assert_raises(ValueError, np.random.RandomState, [[1, 2, 3]])
   56:         assert_raises(ValueError, np.random.RandomState, [[1, 2, 3],
   57:                                                           [4, 5, 6]])
   58: 
   59: 
   60: class TestBinomial:
   61:     def test_n_zero(self):
   62:         # Tests the corner case of n == 0 for the binomial distribution.
   63:         # binomial(0, p) should be zero for any p in [0, 1].
   64:         # This test addresses issue #3480.
   65:         zeros = np.zeros(2, dtype='int')
   66:         for p in [0, .5, 1]:
   67:             assert_(random.binomial(0, p) == 0)
   68:             assert_array_equal(random.binomial(zeros, p), zeros)
   69: 
   70:     def test_p_is_nan(self):
   71:         # Issue #4571.
   72:         assert_raises(ValueError, random.binomial, 1, np.nan)
   73: 
   74: 
   75: class TestMultinomial:
   76:     def test_basic(self):
   77:         random.multinomial(100, [0.2, 0.8])
   78: 
   79:     def test_zero_probability(self):
   80:         random.multinomial(100, [0.2, 0.8, 0.0, 0.0, 0.0])
   81: 
   82:     def test_int_negative_interval(self):
   83:         assert_(-5 <= random.randint(-5, -1) < -1)
   84:         x = random.randint(-5, -1, 5)
   85:         assert_(np.all(-5 <= x))
   86:         assert_(np.all(x < -1))
   87: 
   88:     def test_size(self):
   89:         # gh-3173
   90:         p = [0.5, 0.5]
   91:         assert_equal(np.random.multinomial(1, p, np.uint32(1)).shape, (1, 2))
   92:         assert_equal(np.random.multinomial(1, p, np.uint32(1)).shape, (1, 2))
   93:         assert_equal(np.random.multinomial(1, p, np.uint32(1)).shape, (1, 2))
   94:         assert_equal(np.random.multinomial(1, p, [2, 2]).shape, (2, 2, 2))
   95:         assert_equal(np.random.multinomial(1, p, (2, 2)).shape, (2, 2, 2))
   96:         assert_equal(np.random.multinomial(1, p, np.array((2, 2))).shape,
   97:                      (2, 2, 2))
   98: 
   99:         assert_raises(TypeError, np.random.multinomial, 1, p,
  100:                       float(1))
  101: 
  102:     def test_multidimensional_pvals(self):
  103:         assert_raises(ValueError, np.random.multinomial, 10, [[0, 1]])
  104:         assert_raises(ValueError, np.random.multinomial, 10, [[0], [1]])
  105:         assert_raises(ValueError, np.random.multinomial, 10, [[[0], [1]], [[1], [0]]])
  106:         assert_raises(ValueError, np.random.multinomial, 10, np.array([[0, 1], [1, 0]]))
  107: 
  108: 
  109: class TestSetState:
  110:     def setup_method(self):
  111:         self.seed = 1234567890
  112:         self.prng = random.RandomState(self.seed)
  113:         self.state = self.prng.get_state()
  114: 
  115:     def test_basic(self):
  116:         old = self.prng.tomaxint(16)
  117:         self.prng.set_state(self.state)
  118:         new = self.prng.tomaxint(16)
  119:         assert_(np.all(old == new))
  120: 
  121:     def test_gaussian_reset(self):
  122:         # Make sure the cached every-other-Gaussian is reset.
  123:         old = self.prng.standard_normal(size=3)
  124:         self.prng.set_state(self.state)
  125:         new = self.prng.standard_normal(size=3)
  126:         assert_(np.all(old == new))
  127: 
  128:     def test_gaussian_reset_in_media_res(self):
  129:         # When the state is saved with a cached Gaussian, make sure the
  130:         # cached Gaussian is restored.
  131: 
  132:         self.prng.standard_normal()
  133:         state = self.prng.get_state()
  134:         old = self.prng.standard_normal(size=3)
  135:         self.prng.set_state(state)
  136:         new = self.prng.standard_normal(size=3)
  137:         assert_(np.all(old == new))
  138: 
  139:     def test_backwards_compatibility(self):
  140:         # Make sure we can accept old state tuples that do not have the
  141:         # cached Gaussian value.
  142:         old_state = self.state[:-2]
  143:         x1 = self.prng.standard_normal(size=16)
  144:         self.prng.set_state(old_state)
  145:         x2 = self.prng.standard_normal(size=16)
  146:         self.prng.set_state(self.state)
  147:         x3 = self.prng.standard_normal(size=16)
  148:         assert_(np.all(x1 == x2))
  149:         assert_(np.all(x1 == x3))
  150: 
  151:     def test_negative_binomial(self):
  152:         # Ensure that the negative binomial results take floating point
  153:         # arguments without truncation.
  154:         self.prng.negative_binomial(0.5, 0.5)
  155: 
  156:     def test_set_invalid_state(self):
  157:         # gh-25402
  158:         with pytest.raises(IndexError):
  159:             self.prng.set_state(())
  160: 
  161: 
  162: class TestRandint:
  163: 
  164:     rfunc = np.random.randint
  165: 
  166:     # valid integer/boolean types
  167:     itype = [np.bool, np.int8, np.uint8, np.int16, np.uint16,
  168:              np.int32, np.uint32, np.int64, np.uint64]
  169: 
  170:     def test_unsupported_type(self):
  171:         assert_raises(TypeError, self.rfunc, 1, dtype=float)
  172: 
  173:     def test_bounds_checking(self):
  174:         for dt in self.itype:
  175:             lbnd = 0 if dt is np.bool else np.iinfo(dt).min
  176:             ubnd = 2 if dt is np.bool else np.iinfo(dt).max + 1
  177:             assert_raises(ValueError, self.rfunc, lbnd - 1, ubnd, dtype=dt)
  178:             assert_raises(ValueError, self.rfunc, lbnd, ubnd + 1, dtype=dt)
  179:             assert_raises(ValueError, self.rfunc, ubnd, lbnd, dtype=dt)
  180:             assert_raises(ValueError, self.rfunc, 1, 0, dtype=dt)
  181: 
  182:     def test_rng_zero_and_extremes(self):
  183:         for dt in self.itype:
  184:             lbnd = 0 if dt is np.bool else np.iinfo(dt).min
  185:             ubnd = 2 if dt is np.bool else np.iinfo(dt).max + 1
  186: 
  187:             tgt = ubnd - 1
  188:             assert_equal(self.rfunc(tgt, tgt + 1, size=1000, dtype=dt), tgt)
  189: 
  190:             tgt = lbnd
  191:             assert_equal(self.rfunc(tgt, tgt + 1, size=1000, dtype=dt), tgt)
  192: 
  193:             tgt = (lbnd + ubnd) // 2
  194:             assert_equal(self.rfunc(tgt, tgt + 1, size=1000, dtype=dt), tgt)
  195: 
  196:     def test_full_range(self):
  197:         # Test for ticket #1690
  198: 
  199:         for dt in self.itype:
  200:             lbnd = 0 if dt is np.bool else np.iinfo(dt).min
  201:             ubnd = 2 if dt is np.bool else np.iinfo(dt).max + 1
  202: 
  203:             try:
  204:                 self.rfunc(lbnd, ubnd, dtype=dt)
  205:             except Exception as e:
  206:                 raise AssertionError("No error should have been raised, "
  207:                                      "but one was with the following "
  208:                                      "message:\n\n%s" % str(e))
  209: 
  210:     def test_in_bounds_fuzz(self):
  211:         # Don't use fixed seed
  212:         np.random.seed()
  213: 
  214:         for dt in self.itype[1:]:
  215:             for ubnd in [4, 8, 16]:
  216:                 vals = self.rfunc(2, ubnd, size=2**16, dtype=dt)
  217:                 assert_(vals.max() < ubnd)
  218:                 assert_(vals.min() >= 2)
  219: 
  220:         vals = self.rfunc(0, 2, size=2**16, dtype=np.bool)
  221: 
  222:         assert_(vals.max() < 2)
  223:         assert_(vals.min() >= 0)
  224: 
  225:     def test_repeatability(self):
  226:         import hashlib
  227:         # We use a sha256 hash of generated sequences of 1000 samples
  228:         # in the range [0, 6) for all but bool, where the range
  229:         # is [0, 2). Hashes are for little endian numbers.
  230:         tgt = {'bool':   '509aea74d792fb931784c4b0135392c65aec64beee12b0cc167548a2c3d31e71',  # noqa: E501
  231:                'int16':  '7b07f1a920e46f6d0fe02314155a2330bcfd7635e708da50e536c5ebb631a7d4',  # noqa: E501
  232:                'int32':  'e577bfed6c935de944424667e3da285012e741892dcb7051a8f1ce68ab05c92f',  # noqa: E501
  233:                'int64':  '0fbead0b06759df2cfb55e43148822d4a1ff953c7eb19a5b08445a63bb64fa9e',  # noqa: E501
  234:                'int8':   '001aac3a5acb935a9b186cbe14a1ca064b8bb2dd0b045d48abeacf74d0203404',  # noqa: E501
  235:                'uint16': '7b07f1a920e46f6d0fe02314155a2330bcfd7635e708da50e536c5ebb631a7d4',  # noqa: E501
  236:                'uint32': 'e577bfed6c935de944424667e3da285012e741892dcb7051a8f1ce68ab05c92f',  # noqa: E501
  237:                'uint64': '0fbead0b06759df2cfb55e43148822d4a1ff953c7eb19a5b08445a63bb64fa9e',  # noqa: E501
  238:                'uint8':  '001aac3a5acb935a9b186cbe14a1ca064b8bb2dd0b045d48abeacf74d0203404'}  # noqa: E501
  239: 
  240:         for dt in self.itype[1:]:
  241:             np.random.seed(1234)
  242: 
  243:             # view as little endian for hash
  244:             if sys.byteorder == 'little':
  245:                 val = self.rfunc(0, 6, size=1000, dtype=dt)
  246:             else:
  247:                 val = self.rfunc(0, 6, size=1000, dtype=dt).byteswap()
  248: 
  249:             res = hashlib.sha256(val.view(np.int8)).hexdigest()
  250:             assert_(tgt[np.dtype(dt).name] == res)
  251: 
  252:         # bools do not depend on endianness
  253:         np.random.seed(1234)
  254:         val = self.rfunc(0, 2, size=1000, dtype=bool).view(np.int8)
  255:         res = hashlib.sha256(val).hexdigest()
  256:         assert_(tgt[np.dtype(bool).name] == res)
  257: 
  258:     def test_int64_uint64_corner_case(self):
  259:         # When stored in Numpy arrays, `lbnd` is casted
  260:         # as np.int64, and `ubnd` is casted as np.uint64.
  261:         # Checking whether `lbnd` >= `ubnd` used to be
  262:         # done solely via direct comparison, which is incorrect
  263:         # because when Numpy tries to compare both numbers,
  264:         # it casts both to np.float64 because there is
  265:         # no integer superset of np.int64 and np.uint64. However,
  266:         # `ubnd` is too large to be represented in np.float64,
  267:         # causing it be round down to np.iinfo(np.int64).max,
  268:         # leading to a ValueError because `lbnd` now equals
  269:         # the new `ubnd`.
  270: 
  271:         dt = np.int64
  272:         tgt = np.iinfo(np.int64).max
  273:         lbnd = np.int64(np.iinfo(np.int64).max)
  274:         ubnd = np.uint64(np.iinfo(np.int64).max + 1)
  275: 
  276:         # None of these function calls should
  277:         # generate a ValueError now.
  278:         actual = np.random.randint(lbnd, ubnd, dtype=dt)
  279:         assert_equal(actual, tgt)
  280: 
  281:     def test_respect_dtype_singleton(self):
  282:         # See gh-7203
  283:         for dt in self.itype:
  284:             lbnd = 0 if dt is np.bool else np.iinfo(dt).min
  285:             ubnd = 2 if dt is np.bool else np.iinfo(dt).max + 1
  286: 
  287:             sample = self.rfunc(lbnd, ubnd, dtype=dt)
  288:             assert_equal(sample.dtype, np.dtype(dt))
  289: 
  290:         for dt in (bool, int):
  291:             # The legacy rng uses "long" as the default integer:
  292:             lbnd = 0 if dt is bool else np.iinfo("long").min
  293:             ubnd = 2 if dt is bool else np.iinfo("long").max + 1
  294: 
  295:             # gh-7284: Ensure that we get Python data types
  296:             sample = self.rfunc(lbnd, ubnd, dtype=dt)
  297:             assert_(not hasattr(sample, 'dtype'))
  298:             assert_equal(type(sample), dt)
  299: 
  300: 
  301: class TestRandomDist:
  302:     # Make sure the random distribution returns the correct value for a
  303:     # given seed
  304: 
  305:     def setup_method(self):
  306:         self.seed = 1234567890
  307: 
  308:     def test_rand(self):
  309:         np.random.seed(self.seed)
  310:         actual = np.random.rand(3, 2)
  311:         desired = np.array([[0.61879477158567997, 0.59162362775974664],
  312:                             [0.88868358904449662, 0.89165480011560816],
  313:                             [0.4575674820298663, 0.7781880808593471]])
  314:         assert_array_almost_equal(actual, desired, decimal=15)
  315: 
  316:     def test_randn(self):
  317:         np.random.seed(self.seed)
  318:         actual = np.random.randn(3, 2)
  319:         desired = np.array([[1.34016345771863121, 1.73759122771936081],
  320:                            [1.498988344300628, -0.2286433324536169],
  321:                            [2.031033998682787, 2.17032494605655257]])
  322:         assert_array_almost_equal(actual, desired, decimal=15)
  323: 
  324:     def test_randint(self):
  325:         np.random.seed(self.seed)
  326:         actual = np.random.randint(-99, 99, size=(3, 2))
  327:         desired = np.array([[31, 3],
  328:                             [-52, 41],
  329:                             [-48, -66]])
  330:         assert_array_equal(actual, desired)
  331: 
  332:     def test_random_integers(self):
  333:         np.random.seed(self.seed)
  334:         with suppress_warnings() as sup:
  335:             w = sup.record(DeprecationWarning)
  336:             actual = np.random.random_integers(-99, 99, size=(3, 2))
  337:             assert_(len(w) == 1)
  338:         desired = np.array([[31, 3],
  339:                             [-52, 41],
  340:                             [-48, -66]])
  341:         assert_array_equal(actual, desired)
  342: 
  343:     def test_random_integers_max_int(self):
  344:         # Tests whether random_integers can generate the
  345:         # maximum allowed Python int that can be converted
  346:         # into a C long. Previous implementations of this
  347:         # method have thrown an OverflowError when attempting
  348:         # to generate this integer.
  349:         with suppress_warnings() as sup:
  350:             w = sup.record(DeprecationWarning)
  351:             actual = np.random.random_integers(np.iinfo('l').max,
  352:                                                np.iinfo('l').max)
  353:             assert_(len(w) == 1)
  354: 
  355:         desired = np.iinfo('l').max
  356:         assert_equal(actual, desired)
  357: 
  358:     def test_random_integers_deprecated(self):
  359:         with warnings.catch_warnings():
  360:             warnings.simplefilter("error", DeprecationWarning)
  361: 
  362:             # DeprecationWarning raised with high == None
  363:             assert_raises(DeprecationWarning,
  364:                           np.random.random_integers,
  365:                           np.iinfo('l').max)
  366: 
  367:             # DeprecationWarning raised with high != None
  368:             assert_raises(DeprecationWarning,
  369:                           np.random.random_integers,
  370:                           np.iinfo('l').max, np.iinfo('l').max)
  371: 
  372:     def test_random(self):
  373:         np.random.seed(self.seed)
  374:         actual = np.random.random((3, 2))
  375:         desired = np.array([[0.61879477158567997, 0.59162362775974664],
  376:                             [0.88868358904449662, 0.89165480011560816],
  377:                             [0.4575674820298663, 0.7781880808593471]])
  378:         assert_array_almost_equal(actual, desired, decimal=15)
  379: 
  380:     def test_choice_uniform_replace(self):
  381:         np.random.seed(self.seed)
  382:         actual = np.random.choice(4, 4)
  383:         desired = np.array([2, 3, 2, 3])
  384:         assert_array_equal(actual, desired)
  385: 
  386:     def test_choice_nonuniform_replace(self):
  387:         np.random.seed(self.seed)
  388:         actual = np.random.choice(4, 4, p=[0.4, 0.4, 0.1, 0.1])
  389:         desired = np.array([1, 1, 2, 2])
  390:         assert_array_equal(actual, desired)
  391: 
  392:     def test_choice_uniform_noreplace(self):
  393:         np.random.seed(self.seed)
  394:         actual = np.random.choice(4, 3, replace=False)
  395:         desired = np.array([0, 1, 3])
  396:         assert_array_equal(actual, desired)
  397: 
  398:     def test_choice_nonuniform_noreplace(self):
  399:         np.random.seed(self.seed)
  400:         actual = np.random.choice(4, 3, replace=False,
  401:                                   p=[0.1, 0.3, 0.5, 0.1])
  402:         desired = np.array([2, 3, 1])
  403:         assert_array_equal(actual, desired)
  404: 
  405:     def test_choice_noninteger(self):
  406:         np.random.seed(self.seed)
  407:         actual = np.random.choice(['a', 'b', 'c', 'd'], 4)
  408:         desired = np.array(['c', 'd', 'c', 'd'])
  409:         assert_array_equal(actual, desired)
  410: 
  411:     def test_choice_exceptions(self):
  412:         sample = np.random.choice
  413:         assert_raises(ValueError, sample, -1, 3)
  414:         assert_raises(ValueError, sample, 3., 3)
  415:         assert_raises(ValueError, sample, [[1, 2], [3, 4]], 3)
  416:         assert_raises(ValueError, sample, [], 3)
  417:         assert_raises(ValueError, sample, [1, 2, 3, 4], 3,
  418:                       p=[[0.25, 0.25], [0.25, 0.25]])
  419:         assert_raises(ValueError, sample, [1, 2], 3, p=[0.4, 0.4, 0.2])
  420:         assert_raises(ValueError, sample, [1, 2], 3, p=[1.1, -0.1])
  421:         assert_raises(ValueError, sample, [1, 2], 3, p=[0.4, 0.4])
  422:         assert_raises(ValueError, sample, [1, 2, 3], 4, replace=False)
  423:         # gh-13087
  424:         assert_raises(ValueError, sample, [1, 2, 3], -2, replace=False)
  425:         assert_raises(ValueError, sample, [1, 2, 3], (-1,), replace=False)
  426:         assert_raises(ValueError, sample, [1, 2, 3], (-1, 1), replace=False)
  427:         assert_raises(ValueError, sample, [1, 2, 3], 2,
  428:                       replace=False, p=[1, 0, 0])
  429: 
  430:     def test_choice_return_shape(self):
  431:         p = [0.1, 0.9]
  432:         # Check scalar
  433:         assert_(np.isscalar(np.random.choice(2, replace=True)))
  434:         assert_(np.isscalar(np.random.choice(2, replace=False)))
  435:         assert_(np.isscalar(np.random.choice(2, replace=True, p=p)))
  436:         assert_(np.isscalar(np.random.choice(2, replace=False, p=p)))
  437:         assert_(np.isscalar(np.random.choice([1, 2], replace=True)))
  438:         assert_(np.random.choice([None], replace=True) is None)
  439:         a = np.array([1, 2])
  440:         arr = np.empty(1, dtype=object)
  441:         arr[0] = a
  442:         assert_(np.random.choice(arr, replace=True) is a)
  443: 
  444:         # Check 0-d array
  445:         s = ()
  446:         assert_(not np.isscalar(np.random.choice(2, s, replace=True)))
  447:         assert_(not np.isscalar(np.random.choice(2, s, replace=False)))
  448:         assert_(not np.isscalar(np.random.choice(2, s, replace=True, p=p)))
  449:         assert_(not np.isscalar(np.random.choice(2, s, replace=False, p=p)))
  450:         assert_(not np.isscalar(np.random.choice([1, 2], s, replace=True)))
  451:         assert_(np.random.choice([None], s, replace=True).ndim == 0)
  452:         a = np.array([1, 2])
  453:         arr = np.empty(1, dtype=object)
  454:         arr[0] = a
  455:         assert_(np.random.choice(arr, s, replace=True).item() is a)
  456: 
  457:         # Check multi dimensional array
  458:         s = (2, 3)
  459:         p = [0.1, 0.1, 0.1, 0.1, 0.4, 0.2]
  460:         assert_equal(np.random.choice(6, s, replace=True).shape, s)
  461:         assert_equal(np.random.choice(6, s, replace=False).shape, s)
  462:         assert_equal(np.random.choice(6, s, replace=True, p=p).shape, s)
  463:         assert_equal(np.random.choice(6, s, replace=False, p=p).shape, s)
  464:         assert_equal(np.random.choice(np.arange(6), s, replace=True).shape, s)
  465: 
  466:         # Check zero-size
  467:         assert_equal(np.random.randint(0, 0, size=(3, 0, 4)).shape, (3, 0, 4))
  468:         assert_equal(np.random.randint(0, -10, size=0).shape, (0,))
  469:         assert_equal(np.random.randint(10, 10, size=0).shape, (0,))
  470:         assert_equal(np.random.choice(0, size=0).shape, (0,))
  471:         assert_equal(np.random.choice([], size=(0,)).shape, (0,))
  472:         assert_equal(np.random.choice(['a', 'b'], size=(3, 0, 4)).shape,
  473:                      (3, 0, 4))
  474:         assert_raises(ValueError, np.random.choice, [], 10)
  475: 
  476:     def test_choice_nan_probabilities(self):
  477:         a = np.array([42, 1, 2])
  478:         p = [None, None, None]
  479:         assert_raises(ValueError, np.random.choice, a, p=p)
  480: 
  481:     def test_bytes(self):
  482:         np.random.seed(self.seed)
  483:         actual = np.random.bytes(10)
  484:         desired = b'\x82Ui\x9e\xff\x97+Wf\xa5'
  485:         assert_equal(actual, desired)
  486: 
  487:     def test_shuffle(self):
  488:         # Test lists, arrays (of various dtypes), and multidimensional versions
  489:         # of both, c-contiguous or not:
  490:         for conv in [lambda x: np.array([]),
  491:                      lambda x: x,
  492:                      lambda x: np.asarray(x).astype(np.int8),
  493:                      lambda x: np.asarray(x).astype(np.float32),
  494:                      lambda x: np.asarray(x).astype(np.complex64),
  495:                      lambda x: np.asarray(x).astype(object),
  496:                      lambda x: [(i, i) for i in x],
  497:                      lambda x: np.asarray([[i, i] for i in x]),
  498:                      lambda x: np.vstack([x, x]).T,
  499:                      # gh-11442
  500:                      lambda x: (np.asarray([(i, i) for i in x],
  501:                                            [("a", int), ("b", int)])
  502:                                 .view(np.recarray)),
  503:                      # gh-4270
  504:                      lambda x: np.asarray([(i, i) for i in x],
  505:                                           [("a", object), ("b", np.int32)])]:
  506:             np.random.seed(self.seed)
  507:             alist = conv([1, 2, 3, 4, 5, 6, 7, 8, 9, 0])
  508:             np.random.shuffle(alist)
  509:             actual = alist
  510:             desired = conv([0, 1, 9, 6, 2, 4, 5, 8, 7, 3])
  511:             assert_array_equal(actual, desired)
  512: 
  513:     def test_shuffle_masked(self):
  514:         # gh-3263
  515:         a = np.ma.masked_values(np.reshape(range(20), (5, 4)) % 3 - 1, -1)
  516:         b = np.ma.masked_values(np.arange(20) % 3 - 1, -1)
  517:         a_orig = a.copy()
  518:         b_orig = b.copy()
  519:         for i in range(50):
  520:             np.random.shuffle(a)
  521:             assert_equal(
  522:                 sorted(a.data[~a.mask]), sorted(a_orig.data[~a_orig.mask]))
  523:             np.random.shuffle(b)
  524:             assert_equal(
  525:                 sorted(b.data[~b.mask]), sorted(b_orig.data[~b_orig.mask]))
  526: 
  527:     @pytest.mark.parametrize("random",
  528:             [np.random, np.random.RandomState(), np.random.default_rng()])
  529:     def test_shuffle_untyped_warning(self, random):
  530:         # Create a dict works like a sequence but isn't one
  531:         values = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6}
  532:         with pytest.warns(UserWarning,
  533:                 match="you are shuffling a 'dict' object") as rec:
  534:             random.shuffle(values)
  535:         assert "test_random" in rec[0].filename
  536: 
  537:     @pytest.mark.parametrize("random",
  538:         [np.random, np.random.RandomState(), np.random.default_rng()])
  539:     @pytest.mark.parametrize("use_array_like", [True, False])
  540:     def test_shuffle_no_object_unpacking(self, random, use_array_like):
  541:         class MyArr(np.ndarray):
  542:             pass
  543: 
  544:         items = [
  545:             None, np.array([3]), np.float64(3), np.array(10), np.float64(7)
  546:         ]
  547:         arr = np.array(items, dtype=object)
  548:         item_ids = {id(i) for i in items}
  549:         if use_array_like:
  550:             arr = arr.view(MyArr)
  551: 
  552:         # The array was created fine, and did not modify any objects:
  553:         assert all(id(i) in item_ids for i in arr)
  554: 
  555:         if use_array_like and not isinstance(random, np.random.Generator):
  556:             # The old API gives incorrect results, but warns about it.
  557:             with pytest.warns(UserWarning,
  558:                     match="Shuffling a one dimensional array.*"):
  559:                 random.shuffle(arr)
  560:         else:
  561:             random.shuffle(arr)
  562:             assert all(id(i) in item_ids for i in arr)
  563: 
  564:     def test_shuffle_memoryview(self):
  565:         # gh-18273
  566:         # allow graceful handling of memoryviews
  567:         # (treat the same as arrays)
  568:         np.random.seed(self.seed)
  569:         a = np.arange(5).data
  570:         np.random.shuffle(a)
  571:         assert_equal(np.asarray(a), [0, 1, 4, 3, 2])
  572:         rng = np.random.RandomState(self.seed)
  573:         rng.shuffle(a)
  574:         assert_equal(np.asarray(a), [0, 1, 2, 3, 4])
  575:         rng = np.random.default_rng(self.seed)
  576:         rng.shuffle(a)
  577:         assert_equal(np.asarray(a), [4, 1, 0, 3, 2])
  578: 
  579:     def test_shuffle_not_writeable(self):
  580:         a = np.zeros(3)
  581:         a.flags.writeable = False
  582:         with pytest.raises(ValueError, match='read-only'):
  583:             np.random.shuffle(a)
  584: 
  585:     def test_beta(self):
  586:         np.random.seed(self.seed)
  587:         actual = np.random.beta(.1, .9, size=(3, 2))
  588:         desired = np.array(
  589:                 [[1.45341850513746058e-02, 5.31297615662868145e-04],
  590:                  [1.85366619058432324e-06, 4.19214516800110563e-03],
  591:                  [1.58405155108498093e-04, 1.26252891949397652e-04]])
  592:         assert_array_almost_equal(actual, desired, decimal=15)
  593: 
  594:     def test_binomial(self):
  595:         np.random.seed(self.seed)
  596:         actual = np.random.binomial(100, .456, size=(3, 2))
  597:         desired = np.array([[37, 43],
  598:                             [42, 48],
  599:                             [46, 45]])
  600:         assert_array_equal(actual, desired)
  601: 
  602:     def test_chisquare(self):
  603:         np.random.seed(self.seed)
  604:         actual = np.random.chisquare(50, size=(3, 2))
  605:         desired = np.array([[63.87858175501090585, 68.68407748911370447],
  606:                             [65.77116116901505904, 47.09686762438974483],
  607:                             [72.3828403199695174, 74.18408615260374006]])
  608:         assert_array_almost_equal(actual, desired, decimal=13)
  609: 
  610:     def test_dirichlet(self):
  611:         np.random.seed(self.seed)
  612:         alpha = np.array([51.72840233779265162, 39.74494232180943953])
  613:         actual = np.random.mtrand.dirichlet(alpha, size=(3, 2))
  614:         desired = np.array([[[0.54539444573611562, 0.45460555426388438],
  615:                              [0.62345816822039413, 0.37654183177960598]],
  616:                             [[0.55206000085785778, 0.44793999914214233],
  617:                              [0.58964023305154301, 0.41035976694845688]],
  618:                             [[0.59266909280647828, 0.40733090719352177],
  619:                              [0.56974431743975207, 0.43025568256024799]]])
  620:         assert_array_almost_equal(actual, desired, decimal=15)
  621: 
  622:     def test_dirichlet_size(self):
  623:         # gh-3173
  624:         p = np.array([51.72840233779265162, 39.74494232180943953])
  625:         assert_equal(np.random.dirichlet(p, np.uint32(1)).shape, (1, 2))
  626:         assert_equal(np.random.dirichlet(p, np.uint32(1)).shape, (1, 2))
  627:         assert_equal(np.random.dirichlet(p, np.uint32(1)).shape, (1, 2))
  628:         assert_equal(np.random.dirichlet(p, [2, 2]).shape, (2, 2, 2))
  629:         assert_equal(np.random.dirichlet(p, (2, 2)).shape, (2, 2, 2))
  630:         assert_equal(np.random.dirichlet(p, np.array((2, 2))).shape, (2, 2, 2))
  631: 
  632:         assert_raises(TypeError, np.random.dirichlet, p, float(1))
  633: 
  634:     def test_dirichlet_bad_alpha(self):
  635:         # gh-2089
  636:         alpha = np.array([5.4e-01, -1.0e-16])
  637:         assert_raises(ValueError, np.random.mtrand.dirichlet, alpha)
  638: 
  639:         # gh-15876
  640:         assert_raises(ValueError, random.dirichlet, [[5, 1]])
  641:         assert_raises(ValueError, random.dirichlet, [[5], [1]])
  642:         assert_raises(ValueError, random.dirichlet, [[[5], [1]], [[1], [5]]])
  643:         assert_raises(ValueError, random.dirichlet, np.array([[5, 1], [1, 5]]))
  644: 
  645:     def test_exponential(self):
  646:         np.random.seed(self.seed)
  647:         actual = np.random.exponential(1.1234, size=(3, 2))
  648:         desired = np.array([[1.08342649775011624, 1.00607889924557314],
  649:                             [2.46628830085216721, 2.49668106809923884],
  650:                             [0.68717433461363442, 1.69175666993575979]])
  651:         assert_array_almost_equal(actual, desired, decimal=15)
  652: 
  653:     def test_exponential_0(self):
  654:         assert_equal(np.random.exponential(scale=0), 0)
  655:         assert_raises(ValueError, np.random.exponential, scale=-0.)
  656: 
  657:     def test_f(self):
  658:         np.random.seed(self.seed)
  659:         actual = np.random.f(12, 77, size=(3, 2))
  660:         desired = np.array([[1.21975394418575878, 1.75135759791559775],
  661:                             [1.44803115017146489, 1.22108959480396262],
  662:                             [1.02176975757740629, 1.34431827623300415]])
  663:         assert_array_almost_equal(actual, desired, decimal=15)
  664: 
  665:     def test_gamma(self):
  666:         np.random.seed(self.seed)
  667:         actual = np.random.gamma(5, 3, size=(3, 2))
  668:         desired = np.array([[24.60509188649287182, 28.54993563207210627],
  669:                             [26.13476110204064184, 12.56988482927716078],
  670:                             [31.71863275789960568, 33.30143302795922011]])
  671:         assert_array_almost_equal(actual, desired, decimal=14)
  672: 
  673:     def test_gamma_0(self):
  674:         assert_equal(np.random.gamma(shape=0, scale=0), 0)
  675:         assert_raises(ValueError, np.random.gamma, shape=-0., scale=-0.)
  676: 
  677:     def test_geometric(self):
  678:         np.random.seed(self.seed)
  679:         actual = np.random.geometric(.123456789, size=(3, 2))
  680:         desired = np.array([[8, 7],
  681:                             [17, 17],
  682:                             [5, 12]])
  683:         assert_array_equal(actual, desired)
  684: 
  685:     def test_gumbel(self):
  686:         np.random.seed(self.seed)
  687:         actual = np.random.gumbel(loc=.123456789, scale=2.0, size=(3, 2))
  688:         desired = np.array([[0.19591898743416816, 0.34405539668096674],
  689:                             [-1.4492522252274278, -1.47374816298446865],
  690:                             [1.10651090478803416, -0.69535848626236174]])
  691:         assert_array_almost_equal(actual, desired, decimal=15)
  692: 
  693:     def test_gumbel_0(self):
  694:         assert_equal(np.random.gumbel(scale=0), 0)
  695:         assert_raises(ValueError, np.random.gumbel, scale=-0.)
  696: 
  697:     def test_hypergeometric(self):
  698:         np.random.seed(self.seed)
  699:         actual = np.random.hypergeometric(10, 5, 14, size=(3, 2))
  700:         desired = np.array([[10, 10],
  701:                             [10, 10],
  702:                             [9, 9]])
  703:         assert_array_equal(actual, desired)
  704: 
  705:         # Test nbad = 0
  706:         actual = np.random.hypergeometric(5, 0, 3, size=4)
  707:         desired = np.array([3, 3, 3, 3])
  708:         assert_array_equal(actual, desired)
  709: 
  710:         actual = np.random.hypergeometric(15, 0, 12, size=4)
  711:         desired = np.array([12, 12, 12, 12])
  712:         assert_array_equal(actual, desired)
  713: 
  714:         # Test ngood = 0
  715:         actual = np.random.hypergeometric(0, 5, 3, size=4)
  716:         desired = np.array([0, 0, 0, 0])
  717:         assert_array_equal(actual, desired)
  718: 
  719:         actual = np.random.hypergeometric(0, 15, 12, size=4)
  720:         desired = np.array([0, 0, 0, 0])
  721:         assert_array_equal(actual, desired)
  722: 
  723:     def test_laplace(self):
  724:         np.random.seed(self.seed)
  725:         actual = np.random.laplace(loc=.123456789, scale=2.0, size=(3, 2))
  726:         desired = np.array([[0.66599721112760157, 0.52829452552221945],
  727:                             [3.12791959514407125, 3.18202813572992005],
  728:                             [-0.05391065675859356, 1.74901336242837324]])
  729:         assert_array_almost_equal(actual, desired, decimal=15)
  730: 
  731:     def test_laplace_0(self):
  732:         assert_equal(np.random.laplace(scale=0), 0)
  733:         assert_raises(ValueError, np.random.laplace, scale=-0.)
  734: 
  735:     def test_logistic(self):
  736:         np.random.seed(self.seed)
  737:         actual = np.random.logistic(loc=.123456789, scale=2.0, size=(3, 2))
  738:         desired = np.array([[1.09232835305011444, 0.8648196662399954],
  739:                             [4.27818590694950185, 4.33897006346929714],
  740:                             [-0.21682183359214885, 2.63373365386060332]])
  741:         assert_array_almost_equal(actual, desired, decimal=15)
  742: 
  743:     def test_lognormal(self):
  744:         np.random.seed(self.seed)
  745:         actual = np.random.lognormal(mean=.123456789, sigma=2.0, size=(3, 2))
  746:         desired = np.array([[16.50698631688883822, 36.54846706092654784],
  747:                             [22.67886599981281748, 0.71617561058995771],
  748:                             [65.72798501792723869, 86.84341601437161273]])
  749:         assert_array_almost_equal(actual, desired, decimal=13)
  750: 
  751:     def test_lognormal_0(self):
  752:         assert_equal(np.random.lognormal(sigma=0), 1)
  753:         assert_raises(ValueError, np.random.lognormal, sigma=-0.)
  754: 
  755:     def test_logseries(self):
  756:         np.random.seed(self.seed)
  757:         actual = np.random.logseries(p=.923456789, size=(3, 2))
  758:         desired = np.array([[2, 2],
  759:                             [6, 17],
  760:                             [3, 6]])
  761:         assert_array_equal(actual, desired)
  762: 
  763:     def test_multinomial(self):
  764:         np.random.seed(self.seed)
  765:         actual = np.random.multinomial(20, [1 / 6.] * 6, size=(3, 2))
  766:         desired = np.array([[[4, 3, 5, 4, 2, 2],
  767:                              [5, 2, 8, 2, 2, 1]],
  768:                             [[3, 4, 3, 6, 0, 4],
  769:                              [2, 1, 4, 3, 6, 4]],
  770:                             [[4, 4, 2, 5, 2, 3],
  771:                              [4, 3, 4, 2, 3, 4]]])
  772:         assert_array_equal(actual, desired)
  773: 
  774:     def test_multivariate_normal(self):
  775:         np.random.seed(self.seed)
  776:         mean = (.123456789, 10)
  777:         cov = [[1, 0], [0, 1]]
  778:         size = (3, 2)
  779:         actual = np.random.multivariate_normal(mean, cov, size)
  780:         desired = np.array([[[1.463620246718631, 11.73759122771936],
  781:                              [1.622445133300628, 9.771356667546383]],
  782:                             [[2.154490787682787, 12.170324946056553],
  783:                              [1.719909438201865, 9.230548443648306]],
  784:                             [[0.689515026297799, 9.880729819607714],
  785:                              [-0.023054015651998, 9.201096623542879]]])
  786: 
  787:         assert_array_almost_equal(actual, desired, decimal=15)
  788: 
  789:         # Check for default size, was raising deprecation warning
  790:         actual = np.random.multivariate_normal(mean, cov)
  791:         desired = np.array([0.895289569463708, 9.17180864067987])
  792:         assert_array_almost_equal(actual, desired, decimal=15)
  793: 
  794:         # Check that non positive-semidefinite covariance warns with
  795:         # RuntimeWarning
  796:         mean = [0, 0]
  797:         cov = [[1, 2], [2, 1]]
  798:         assert_warns(RuntimeWarning, np.random.multivariate_normal, mean, cov)
  799: 
  800:         # and that it doesn't warn with RuntimeWarning check_valid='ignore'
  801:         assert_no_warnings(np.random.multivariate_normal, mean, cov,
  802:                            check_valid='ignore')
  803: 
  804:         # and that it raises with RuntimeWarning check_valid='raises'
  805:         assert_raises(ValueError, np.random.multivariate_normal, mean, cov,
  806:                       check_valid='raise')
  807: 
  808:         cov = np.array([[1, 0.1], [0.1, 1]], dtype=np.float32)
  809:         with suppress_warnings() as sup:
  810:             np.random.multivariate_normal(mean, cov)
  811:             w = sup.record(RuntimeWarning)
  812:             assert len(w) == 0
  813: 
  814:     def test_negative_binomial(self):
  815:         np.random.seed(self.seed)
  816:         actual = np.random.negative_binomial(n=100, p=.12345, size=(3, 2))
  817:         desired = np.array([[848, 841],
  818:                             [892, 611],
  819:                             [779, 647]])
  820:         assert_array_equal(actual, desired)
  821: 
  822:     def test_noncentral_chisquare(self):
  823:         np.random.seed(self.seed)
  824:         actual = np.random.noncentral_chisquare(df=5, nonc=5, size=(3, 2))
  825:         desired = np.array([[23.91905354498517511, 13.35324692733826346],
  826:                             [31.22452661329736401, 16.60047399466177254],
  827:                             [5.03461598262724586, 17.94973089023519464]])
  828:         assert_array_almost_equal(actual, desired, decimal=14)
  829: 
  830:         actual = np.random.noncentral_chisquare(df=.5, nonc=.2, size=(3, 2))
  831:         desired = np.array([[1.47145377828516666,  0.15052899268012659],
  832:                             [0.00943803056963588,  1.02647251615666169],
  833:                             [0.332334982684171,  0.15451287602753125]])
  834:         assert_array_almost_equal(actual, desired, decimal=14)
  835: 
  836:         np.random.seed(self.seed)
  837:         actual = np.random.noncentral_chisquare(df=5, nonc=0, size=(3, 2))
  838:         desired = np.array([[9.597154162763948, 11.725484450296079],
  839:                             [10.413711048138335, 3.694475922923986],
  840:                             [13.484222138963087, 14.377255424602957]])
  841:         assert_array_almost_equal(actual, desired, decimal=14)
  842: 
  843:     def test_noncentral_f(self):
  844:         np.random.seed(self.seed)
  845:         actual = np.random.noncentral_f(dfnum=5, dfden=2, nonc=1,
  846:                                         size=(3, 2))
  847:         desired = np.array([[1.40598099674926669, 0.34207973179285761],
  848:                             [3.57715069265772545, 7.92632662577829805],
  849:                             [0.43741599463544162, 1.1774208752428319]])
  850:         assert_array_almost_equal(actual, desired, decimal=14)
  851: 
  852:     def test_normal(self):
  853:         np.random.seed(self.seed)
  854:         actual = np.random.normal(loc=.123456789, scale=2.0, size=(3, 2))
  855:         desired = np.array([[2.80378370443726244, 3.59863924443872163],
  856:                             [3.121433477601256, -0.33382987590723379],
  857:                             [4.18552478636557357, 4.46410668111310471]])
  858:         assert_array_almost_equal(actual, desired, decimal=15)
  859: 
  860:     def test_normal_0(self):
  861:         assert_equal(np.random.normal(scale=0), 0)
  862:         assert_raises(ValueError, np.random.normal, scale=-0.)
  863: 
  864:     def test_pareto(self):
  865:         np.random.seed(self.seed)
  866:         actual = np.random.pareto(a=.123456789, size=(3, 2))
  867:         desired = np.array(
  868:                 [[2.46852460439034849e+03, 1.41286880810518346e+03],
  869:                  [5.28287797029485181e+07, 6.57720981047328785e+07],
  870:                  [1.40840323350391515e+02, 1.98390255135251704e+05]])
  871:         # For some reason on 32-bit x86 Ubuntu 12.10 the [1, 0] entry in this
  872:         # matrix differs by 24 nulps. Discussion:
  873:         #   https://mail.python.org/pipermail/numpy-discussion/2012-September/063801.html
  874:         # Consensus is that this is probably some gcc quirk that affects
  875:         # rounding but not in any important way, so we just use a looser
  876:         # tolerance on this test:
  877:         np.testing.assert_array_almost_equal_nulp(actual, desired, nulp=30)
  878: 
  879:     def test_poisson(self):
  880:         np.random.seed(self.seed)
  881:         actual = np.random.poisson(lam=.123456789, size=(3, 2))
  882:         desired = np.array([[0, 0],
  883:                             [1, 0],
  884:                             [0, 0]])
  885:         assert_array_equal(actual, desired)
  886: 
  887:     def test_poisson_exceptions(self):
  888:         lambig = np.iinfo('l').max
  889:         lamneg = -1
  890:         assert_raises(ValueError, np.random.poisson, lamneg)
  891:         assert_raises(ValueError, np.random.poisson, [lamneg] * 10)
  892:         assert_raises(ValueError, np.random.poisson, lambig)
  893:         assert_raises(ValueError, np.random.poisson, [lambig] * 10)
  894: 
  895:     def test_power(self):
  896:         np.random.seed(self.seed)
  897:         actual = np.random.power(a=.123456789, size=(3, 2))
  898:         desired = np.array([[0.02048932883240791, 0.01424192241128213],
  899:                             [0.38446073748535298, 0.39499689943484395],
  900:                             [0.00177699707563439, 0.13115505880863756]])
  901:         assert_array_almost_equal(actual, desired, decimal=15)
  902: 
  903:     def test_rayleigh(self):
  904:         np.random.seed(self.seed)
  905:         actual = np.random.rayleigh(scale=10, size=(3, 2))
  906:         desired = np.array([[13.8882496494248393, 13.383318339044731],
  907:                             [20.95413364294492098, 21.08285015800712614],
  908:                             [11.06066537006854311, 17.35468505778271009]])
  909:         assert_array_almost_equal(actual, desired, decimal=14)
  910: 
  911:     def test_rayleigh_0(self):
  912:         assert_equal(np.random.rayleigh(scale=0), 0)
  913:         assert_raises(ValueError, np.random.rayleigh, scale=-0.)
  914: 
  915:     def test_standard_cauchy(self):
  916:         np.random.seed(self.seed)
  917:         actual = np.random.standard_cauchy(size=(3, 2))
  918:         desired = np.array([[0.77127660196445336, -6.55601161955910605],
  919:                             [0.93582023391158309, -2.07479293013759447],
  920:                             [-4.74601644297011926, 0.18338989290760804]])
  921:         assert_array_almost_equal(actual, desired, decimal=15)
  922: 
  923:     def test_standard_exponential(self):
  924:         np.random.seed(self.seed)
  925:         actual = np.random.standard_exponential(size=(3, 2))
  926:         desired = np.array([[0.96441739162374596, 0.89556604882105506],
  927:                             [2.1953785836319808, 2.22243285392490542],
  928:                             [0.6116915921431676, 1.50592546727413201]])
  929:         assert_array_almost_equal(actual, desired, decimal=15)
  930: 
  931:     def test_standard_gamma(self):
  932:         np.random.seed(self.seed)
  933:         actual = np.random.standard_gamma(shape=3, size=(3, 2))
  934:         desired = np.array([[5.50841531318455058, 6.62953470301903103],
  935:                             [5.93988484943779227, 2.31044849402133989],
  936:                             [7.54838614231317084, 8.012756093271868]])
  937:         assert_array_almost_equal(actual, desired, decimal=14)
  938: 
  939:     def test_standard_gamma_0(self):
  940:         assert_equal(np.random.standard_gamma(shape=0), 0)
  941:         assert_raises(ValueError, np.random.standard_gamma, shape=-0.)
  942: 
  943:     def test_standard_normal(self):
  944:         np.random.seed(self.seed)
  945:         actual = np.random.standard_normal(size=(3, 2))
  946:         desired = np.array([[1.34016345771863121, 1.73759122771936081],
  947:                             [1.498988344300628, -0.2286433324536169],
  948:                             [2.031033998682787, 2.17032494605655257]])
  949:         assert_array_almost_equal(actual, desired, decimal=15)
  950: 
  951:     def test_standard_t(self):
  952:         np.random.seed(self.seed)
  953:         actual = np.random.standard_t(df=10, size=(3, 2))
  954:         desired = np.array([[0.97140611862659965, -0.08830486548450577],
  955:                             [1.36311143689505321, -0.55317463909867071],
  956:                             [-0.18473749069684214, 0.61181537341755321]])
  957:         assert_array_almost_equal(actual, desired, decimal=15)
  958: 
  959:     def test_triangular(self):
  960:         np.random.seed(self.seed)
  961:         actual = np.random.triangular(left=5.12, mode=10.23, right=20.34,
  962:                                       size=(3, 2))
  963:         desired = np.array([[12.68117178949215784, 12.4129206149193152],
  964:                             [16.20131377335158263, 16.25692138747600524],
  965:                             [11.20400690911820263, 14.4978144835829923]])
  966:         assert_array_almost_equal(actual, desired, decimal=14)
  967: 
  968:     def test_uniform(self):
  969:         np.random.seed(self.seed)
  970:         actual = np.random.uniform(low=1.23, high=10.54, size=(3, 2))
  971:         desired = np.array([[6.99097932346268003, 6.73801597444323974],
  972:                             [9.50364421400426274, 9.53130618907631089],
  973:                             [5.48995325769805476, 8.47493103280052118]])
  974:         assert_array_almost_equal(actual, desired, decimal=15)
  975: 
  976:     def test_uniform_range_bounds(self):
  977:         fmin = np.finfo('float').min
  978:         fmax = np.finfo('float').max
  979: 
  980:         func = np.random.uniform
  981:         assert_raises(OverflowError, func, -np.inf, 0)
  982:         assert_raises(OverflowError, func,  0,      np.inf)
  983:         assert_raises(OverflowError, func,  fmin,   fmax)
  984:         assert_raises(OverflowError, func, [-np.inf], [0])
  985:         assert_raises(OverflowError, func, [0], [np.inf])
  986: 
  987:         # (fmax / 1e17) - fmin is within range, so this should not throw
  988:         # account for i386 extended precision DBL_MAX / 1e17 + DBL_MAX >
  989:         # DBL_MAX by increasing fmin a bit
  990:         np.random.uniform(low=np.nextafter(fmin, 1), high=fmax / 1e17)
  991: 
  992:     def test_scalar_exception_propagation(self):
  993:         # Tests that exceptions are correctly propagated in distributions
  994:         # when called with objects that throw exceptions when converted to
  995:         # scalars.
  996:         #
  997:         # Regression test for gh: 8865
  998: 
  999:         class ThrowingFloat(np.ndarray):
 1000:             def __float__(self):
 1001:                 raise TypeError
 1002: 
 1003:         throwing_float = np.array(1.0).view(ThrowingFloat)
 1004:         assert_raises(TypeError, np.random.uniform, throwing_float,
 1005:                       throwing_float)
 1006: 
 1007:         class ThrowingInteger(np.ndarray):
 1008:             def __int__(self):
 1009:                 raise TypeError
 1010: 
 1011:             __index__ = __int__
 1012: 
 1013:         throwing_int = np.array(1).view(ThrowingInteger)
 1014:         assert_raises(TypeError, np.random.hypergeometric, throwing_int, 1, 1)
 1015: 
 1016:     def test_vonmises(self):
 1017:         np.random.seed(self.seed)
 1018:         actual = np.random.vonmises(mu=1.23, kappa=1.54, size=(3, 2))
 1019:         desired = np.array([[2.28567572673902042, 2.89163838442285037],
 1020:                             [0.38198375564286025, 2.57638023113890746],
 1021:                             [1.19153771588353052, 1.83509849681825354]])
 1022:         assert_array_almost_equal(actual, desired, decimal=15)
 1023: 
 1024:     def test_vonmises_small(self):
 1025:         # check infinite loop, gh-4720
 1026:         np.random.seed(self.seed)
 1027:         r = np.random.vonmises(mu=0., kappa=1.1e-8, size=10**6)
 1028:         np.testing.assert_(np.isfinite(r).all())
 1029: 
 1030:     def test_wald(self):
 1031:         np.random.seed(self.seed)
 1032:         actual = np.random.wald(mean=1.23, scale=1.54, size=(3, 2))
 1033:         desired = np.array([[3.82935265715889983, 5.13125249184285526],
 1034:                             [0.35045403618358717, 1.50832396872003538],
 1035:                             [0.24124319895843183, 0.22031101461955038]])
 1036:         assert_array_almost_equal(actual, desired, decimal=14)
 1037: 
 1038:     def test_weibull(self):
 1039:         np.random.seed(self.seed)
 1040:         actual = np.random.weibull(a=1.23, size=(3, 2))
 1041:         desired = np.array([[0.97097342648766727, 0.91422896443565516],
 1042:                             [1.89517770034962929, 1.91414357960479564],
 1043:                             [0.67057783752390987, 1.39494046635066793]])
 1044:         assert_array_almost_equal(actual, desired, decimal=15)
 1045: 
 1046:     def test_weibull_0(self):
 1047:         np.random.seed(self.seed)
 1048:         assert_equal(np.random.weibull(a=0, size=12), np.zeros(12))
 1049:         assert_raises(ValueError, np.random.weibull, a=-0.)
 1050: 
 1051:     def test_zipf(self):
 1052:         np.random.seed(self.seed)
 1053:         actual = np.random.zipf(a=1.23, size=(3, 2))
 1054:         desired = np.array([[66, 29],
 1055:                             [1, 1],
 1056:                             [3, 13]])
 1057:         assert_array_equal(actual, desired)
 1058: 
 1059: 
 1060: class TestBroadcast:
 1061:     # tests that functions that broadcast behave
 1062:     # correctly when presented with non-scalar arguments
 1063:     def setup_method(self):
 1064:         self.seed = 123456789
 1065: 
 1066:     def setSeed(self):
 1067:         np.random.seed(self.seed)
 1068: 
 1069:     # TODO: Include test for randint once it can broadcast
 1070:     # Can steal the test written in PR #6938
 1071: 
 1072:     def test_uniform(self):
 1073:         low = [0]
 1074:         high = [1]
 1075:         uniform = np.random.uniform
 1076:         desired = np.array([0.53283302478975902,
 1077:                             0.53413660089041659,
 1078:                             0.50955303552646702])
 1079: 
 1080:         self.setSeed()
 1081:         actual = uniform(low * 3, high)
 1082:         assert_array_almost_equal(actual, desired, decimal=14)
 1083: 
 1084:         self.setSeed()
 1085:         actual = uniform(low, high * 3)
 1086:         assert_array_almost_equal(actual, desired, decimal=14)
 1087: 
 1088:     def test_normal(self):
 1089:         loc = [0]
 1090:         scale = [1]
 1091:         bad_scale = [-1]
 1092:         normal = np.random.normal
 1093:         desired = np.array([2.2129019979039612,
 1094:                             2.1283977976520019,
 1095:                             1.8417114045748335])
 1096: 
 1097:         self.setSeed()
 1098:         actual = normal(loc * 3, scale)
 1099:         assert_array_almost_equal(actual, desired, decimal=14)
 1100:         assert_raises(ValueError, normal, loc * 3, bad_scale)
 1101: 
 1102:         self.setSeed()
 1103:         actual = normal(loc, scale * 3)
 1104:         assert_array_almost_equal(actual, desired, decimal=14)
 1105:         assert_raises(ValueError, normal, loc, bad_scale * 3)
 1106: 
 1107:     def test_beta(self):
 1108:         a = [1]
 1109:         b = [2]
 1110:         bad_a = [-1]
 1111:         bad_b = [-2]
 1112:         beta = np.random.beta
 1113:         desired = np.array([0.19843558305989056,
 1114:                             0.075230336409423643,
 1115:                             0.24976865978980844])
 1116: 
 1117:         self.setSeed()
 1118:         actual = beta(a * 3, b)
 1119:         assert_array_almost_equal(actual, desired, decimal=14)
 1120:         assert_raises(ValueError, beta, bad_a * 3, b)
 1121:         assert_raises(ValueError, beta, a * 3, bad_b)
 1122: 
 1123:         self.setSeed()
 1124:         actual = beta(a, b * 3)
 1125:         assert_array_almost_equal(actual, desired, decimal=14)
 1126:         assert_raises(ValueError, beta, bad_a, b * 3)
 1127:         assert_raises(ValueError, beta, a, bad_b * 3)
 1128: 
 1129:     def test_exponential(self):
 1130:         scale = [1]
 1131:         bad_scale = [-1]
 1132:         exponential = np.random.exponential
 1133:         desired = np.array([0.76106853658845242,
 1134:                             0.76386282278691653,
 1135:                             0.71243813125891797])
 1136: 
 1137:         self.setSeed()
 1138:         actual = exponential(scale * 3)
 1139:         assert_array_almost_equal(actual, desired, decimal=14)
 1140:         assert_raises(ValueError, exponential, bad_scale * 3)
 1141: 
 1142:     def test_standard_gamma(self):
 1143:         shape = [1]
 1144:         bad_shape = [-1]
 1145:         std_gamma = np.random.standard_gamma
 1146:         desired = np.array([0.76106853658845242,
 1147:                             0.76386282278691653,
 1148:                             0.71243813125891797])
 1149: 
 1150:         self.setSeed()
 1151:         actual = std_gamma(shape * 3)
 1152:         assert_array_almost_equal(actual, desired, decimal=14)
 1153:         assert_raises(ValueError, std_gamma, bad_shape * 3)
 1154: 
 1155:     def test_gamma(self):
 1156:         shape = [1]
 1157:         scale = [2]
 1158:         bad_shape = [-1]
 1159:         bad_scale = [-2]
 1160:         gamma = np.random.gamma
 1161:         desired = np.array([1.5221370731769048,
 1162:                             1.5277256455738331,
 1163:                             1.4248762625178359])
 1164: 
 1165:         self.setSeed()
 1166:         actual = gamma(shape * 3, scale)
 1167:         assert_array_almost_equal(actual, desired, decimal=14)
 1168:         assert_raises(ValueError, gamma, bad_shape * 3, scale)
 1169:         assert_raises(ValueError, gamma, shape * 3, bad_scale)
 1170: 
 1171:         self.setSeed()
 1172:         actual = gamma(shape, scale * 3)
 1173:         assert_array_almost_equal(actual, desired, decimal=14)
 1174:         assert_raises(ValueError, gamma, bad_shape, scale * 3)
 1175:         assert_raises(ValueError, gamma, shape, bad_scale * 3)
 1176: 
 1177:     def test_f(self):
 1178:         dfnum = [1]
 1179:         dfden = [2]
 1180:         bad_dfnum = [-1]
 1181:         bad_dfden = [-2]
 1182:         f = np.random.f
 1183:         desired = np.array([0.80038951638264799,
 1184:                             0.86768719635363512,
 1185:                             2.7251095168386801])
 1186: 
 1187:         self.setSeed()
 1188:         actual = f(dfnum * 3, dfden)
 1189:         assert_array_almost_equal(actual, desired, decimal=14)
 1190:         assert_raises(ValueError, f, bad_dfnum * 3, dfden)
 1191:         assert_raises(ValueError, f, dfnum * 3, bad_dfden)
 1192: 
 1193:         self.setSeed()
 1194:         actual = f(dfnum, dfden * 3)
 1195:         assert_array_almost_equal(actual, desired, decimal=14)
 1196:         assert_raises(ValueError, f, bad_dfnum, dfden * 3)
 1197:         assert_raises(ValueError, f, dfnum, bad_dfden * 3)
 1198: 
 1199:     def test_noncentral_f(self):
 1200:         dfnum = [2]
 1201:         dfden = [3]
 1202:         nonc = [4]
 1203:         bad_dfnum = [0]
 1204:         bad_dfden = [-1]
 1205:         bad_nonc = [-2]
 1206:         nonc_f = np.random.noncentral_f
 1207:         desired = np.array([9.1393943263705211,
 1208:                             13.025456344595602,
 1209:                             8.8018098359100545])
 1210: 
 1211:         self.setSeed()
 1212:         actual = nonc_f(dfnum * 3, dfden, nonc)
 1213:         assert_array_almost_equal(actual, desired, decimal=14)
 1214:         assert_raises(ValueError, nonc_f, bad_dfnum * 3, dfden, nonc)
 1215:         assert_raises(ValueError, nonc_f, dfnum * 3, bad_dfden, nonc)
 1216:         assert_raises(ValueError, nonc_f, dfnum * 3, dfden, bad_nonc)
 1217: 
 1218:         self.setSeed()
 1219:         actual = nonc_f(dfnum, dfden * 3, nonc)
 1220:         assert_array_almost_equal(actual, desired, decimal=14)
 1221:         assert_raises(ValueError, nonc_f, bad_dfnum, dfden * 3, nonc)
 1222:         assert_raises(ValueError, nonc_f, dfnum, bad_dfden * 3, nonc)
 1223:         assert_raises(ValueError, nonc_f, dfnum, dfden * 3, bad_nonc)
 1224: 
 1225:         self.setSeed()
 1226:         actual = nonc_f(dfnum, dfden, nonc * 3)
 1227:         assert_array_almost_equal(actual, desired, decimal=14)
 1228:         assert_raises(ValueError, nonc_f, bad_dfnum, dfden, nonc * 3)
 1229:         assert_raises(ValueError, nonc_f, dfnum, bad_dfden, nonc * 3)
 1230:         assert_raises(ValueError, nonc_f, dfnum, dfden, bad_nonc * 3)
 1231: 
 1232:     def test_noncentral_f_small_df(self):
 1233:         self.setSeed()
 1234:         desired = np.array([6.869638627492048, 0.785880199263955])
 1235:         actual = np.random.noncentral_f(0.9, 0.9, 2, size=2)
 1236:         assert_array_almost_equal(actual, desired, decimal=14)
 1237: 
 1238:     def test_chisquare(self):
 1239:         df = [1]
 1240:         bad_df = [-1]
 1241:         chisquare = np.random.chisquare
 1242:         desired = np.array([0.57022801133088286,
 1243:                             0.51947702108840776,
 1244:                             0.1320969254923558])
 1245: 
 1246:         self.setSeed()
 1247:         actual = chisquare(df * 3)
 1248:         assert_array_almost_equal(actual, desired, decimal=14)
 1249:         assert_raises(ValueError, chisquare, bad_df * 3)
 1250: 
 1251:     def test_noncentral_chisquare(self):
 1252:         df = [1]
 1253:         nonc = [2]
 1254:         bad_df = [-1]
 1255:         bad_nonc = [-2]
 1256:         nonc_chi = np.random.noncentral_chisquare
 1257:         desired = np.array([9.0015599467913763,
 1258:                             4.5804135049718742,
 1259:                             6.0872302432834564])
 1260: 
 1261:         self.setSeed()
 1262:         actual = nonc_chi(df * 3, nonc)
 1263:         assert_array_almost_equal(actual, desired, decimal=14)
 1264:         assert_raises(ValueError, nonc_chi, bad_df * 3, nonc)
 1265:         assert_raises(ValueError, nonc_chi, df * 3, bad_nonc)
 1266: 
 1267:         self.setSeed()
 1268:         actual = nonc_chi(df, nonc * 3)
 1269:         assert_array_almost_equal(actual, desired, decimal=14)
 1270:         assert_raises(ValueError, nonc_chi, bad_df, nonc * 3)
 1271:         assert_raises(ValueError, nonc_chi, df, bad_nonc * 3)
 1272: 
 1273:     def test_standard_t(self):
 1274:         df = [1]
 1275:         bad_df = [-1]
 1276:         t = np.random.standard_t
 1277:         desired = np.array([3.0702872575217643,
 1278:                             5.8560725167361607,
 1279:                             1.0274791436474273])
 1280: 
 1281:         self.setSeed()
 1282:         actual = t(df * 3)
 1283:         assert_array_almost_equal(actual, desired, decimal=14)
 1284:         assert_raises(ValueError, t, bad_df * 3)
 1285: 
 1286:     def test_vonmises(self):
 1287:         mu = [2]
 1288:         kappa = [1]
 1289:         bad_kappa = [-1]
 1290:         vonmises = np.random.vonmises
 1291:         desired = np.array([2.9883443664201312,
 1292:                             -2.7064099483995943,
 1293:                             -1.8672476700665914])
 1294: 
 1295:         self.setSeed()
 1296:         actual = vonmises(mu * 3, kappa)
 1297:         assert_array_almost_equal(actual, desired, decimal=14)
 1298:         assert_raises(ValueError, vonmises, mu * 3, bad_kappa)
 1299: 
 1300:         self.setSeed()
 1301:         actual = vonmises(mu, kappa * 3)
 1302:         assert_array_almost_equal(actual, desired, decimal=14)
 1303:         assert_raises(ValueError, vonmises, mu, bad_kappa * 3)
 1304: 
 1305:     def test_pareto(self):
 1306:         a = [1]
 1307:         bad_a = [-1]
 1308:         pareto = np.random.pareto
 1309:         desired = np.array([1.1405622680198362,
 1310:                             1.1465519762044529,
 1311:                             1.0389564467453547])
 1312: 
 1313:         self.setSeed()
 1314:         actual = pareto(a * 3)
 1315:         assert_array_almost_equal(actual, desired, decimal=14)
 1316:         assert_raises(ValueError, pareto, bad_a * 3)
 1317: 
 1318:     def test_weibull(self):
 1319:         a = [1]
 1320:         bad_a = [-1]
 1321:         weibull = np.random.weibull
 1322:         desired = np.array([0.76106853658845242,
 1323:                             0.76386282278691653,
 1324:                             0.71243813125891797])
 1325: 
 1326:         self.setSeed()
 1327:         actual = weibull(a * 3)
 1328:         assert_array_almost_equal(actual, desired, decimal=14)
 1329:         assert_raises(ValueError, weibull, bad_a * 3)
 1330: 
 1331:     def test_power(self):
 1332:         a = [1]
 1333:         bad_a = [-1]
 1334:         power = np.random.power
 1335:         desired = np.array([0.53283302478975902,
 1336:                             0.53413660089041659,
 1337:                             0.50955303552646702])
 1338: 
 1339:         self.setSeed()
 1340:         actual = power(a * 3)
 1341:         assert_array_almost_equal(actual, desired, decimal=14)
 1342:         assert_raises(ValueError, power, bad_a * 3)
 1343: 
 1344:     def test_laplace(self):
 1345:         loc = [0]
 1346:         scale = [1]
 1347:         bad_scale = [-1]
 1348:         laplace = np.random.laplace
 1349:         desired = np.array([0.067921356028507157,
 1350:                             0.070715642226971326,
 1351:                             0.019290950698972624])
 1352: 
 1353:         self.setSeed()
 1354:         actual = laplace(loc * 3, scale)
 1355:         assert_array_almost_equal(actual, desired, decimal=14)
 1356:         assert_raises(ValueError, laplace, loc * 3, bad_scale)
 1357: 
 1358:         self.setSeed()
 1359:         actual = laplace(loc, scale * 3)
 1360:         assert_array_almost_equal(actual, desired, decimal=14)
 1361:         assert_raises(ValueError, laplace, loc, bad_scale * 3)
 1362: 
 1363:     def test_gumbel(self):
 1364:         loc = [0]
 1365:         scale = [1]
 1366:         bad_scale = [-1]
 1367:         gumbel = np.random.gumbel
 1368:         desired = np.array([0.2730318639556768,
 1369:                             0.26936705726291116,
 1370:                             0.33906220393037939])
 1371: 
 1372:         self.setSeed()
 1373:         actual = gumbel(loc * 3, scale)
 1374:         assert_array_almost_equal(actual, desired, decimal=14)
 1375:         assert_raises(ValueError, gumbel, loc * 3, bad_scale)
 1376: 
 1377:         self.setSeed()
 1378:         actual = gumbel(loc, scale * 3)
 1379:         assert_array_almost_equal(actual, desired, decimal=14)
 1380:         assert_raises(ValueError, gumbel, loc, bad_scale * 3)
 1381: 
 1382:     def test_logistic(self):
 1383:         loc = [0]
 1384:         scale = [1]
 1385:         bad_scale = [-1]
 1386:         logistic = np.random.logistic
 1387:         desired = np.array([0.13152135837586171,
 1388:                             0.13675915696285773,
 1389:                             0.038216792802833396])
 1390: 
 1391:         self.setSeed()
 1392:         actual = logistic(loc * 3, scale)
 1393:         assert_array_almost_equal(actual, desired, decimal=14)
 1394:         assert_raises(ValueError, logistic, loc * 3, bad_scale)
 1395: 
 1396:         self.setSeed()
 1397:         actual = logistic(loc, scale * 3)
 1398:         assert_array_almost_equal(actual, desired, decimal=14)
 1399:         assert_raises(ValueError, logistic, loc, bad_scale * 3)
 1400: 
 1401:     def test_lognormal(self):
 1402:         mean = [0]
 1403:         sigma = [1]
 1404:         bad_sigma = [-1]
 1405:         lognormal = np.random.lognormal
 1406:         desired = np.array([9.1422086044848427,
 1407:                             8.4013952870126261,
 1408:                             6.3073234116578671])
 1409: 
 1410:         self.setSeed()
 1411:         actual = lognormal(mean * 3, sigma)
 1412:         assert_array_almost_equal(actual, desired, decimal=14)
 1413:         assert_raises(ValueError, lognormal, mean * 3, bad_sigma)
 1414: 
 1415:         self.setSeed()
 1416:         actual = lognormal(mean, sigma * 3)
 1417:         assert_array_almost_equal(actual, desired, decimal=14)
 1418:         assert_raises(ValueError, lognormal, mean, bad_sigma * 3)
 1419: 
 1420:     def test_rayleigh(self):
 1421:         scale = [1]
 1422:         bad_scale = [-1]
 1423:         rayleigh = np.random.rayleigh
 1424:         desired = np.array([1.2337491937897689,
 1425:                             1.2360119924878694,
 1426:                             1.1936818095781789])
 1427: 
 1428:         self.setSeed()
 1429:         actual = rayleigh(scale * 3)
 1430:         assert_array_almost_equal(actual, desired, decimal=14)
 1431:         assert_raises(ValueError, rayleigh, bad_scale * 3)
 1432: 
 1433:     def test_wald(self):
 1434:         mean = [0.5]
 1435:         scale = [1]
 1436:         bad_mean = [0]
 1437:         bad_scale = [-2]
 1438:         wald = np.random.wald
 1439:         desired = np.array([0.11873681120271318,
 1440:                             0.12450084820795027,
 1441:                             0.9096122728408238])
 1442: 
 1443:         self.setSeed()
 1444:         actual = wald(mean * 3, scale)
 1445:         assert_array_almost_equal(actual, desired, decimal=14)
 1446:         assert_raises(ValueError, wald, bad_mean * 3, scale)
 1447:         assert_raises(ValueError, wald, mean * 3, bad_scale)
 1448: 
 1449:         self.setSeed()
 1450:         actual = wald(mean, scale * 3)
 1451:         assert_array_almost_equal(actual, desired, decimal=14)
 1452:         assert_raises(ValueError, wald, bad_mean, scale * 3)
 1453:         assert_raises(ValueError, wald, mean, bad_scale * 3)
 1454:         assert_raises(ValueError, wald, 0.0, 1)
 1455:         assert_raises(ValueError, wald, 0.5, 0.0)
 1456: 
 1457:     def test_triangular(self):
 1458:         left = [1]
 1459:         right = [3]
 1460:         mode = [2]
 1461:         bad_left_one = [3]
 1462:         bad_mode_one = [4]
 1463:         bad_left_two, bad_mode_two = right * 2
 1464:         triangular = np.random.triangular
 1465:         desired = np.array([2.03339048710429,
 1466:                             2.0347400359389356,
 1467:                             2.0095991069536208])
 1468: 
 1469:         self.setSeed()
 1470:         actual = triangular(left * 3, mode, right)
 1471:         assert_array_almost_equal(actual, desired, decimal=14)
 1472:         assert_raises(ValueError, triangular, bad_left_one * 3, mode, right)
 1473:         assert_raises(ValueError, triangular, left * 3, bad_mode_one, right)
 1474:         assert_raises(ValueError, triangular, bad_left_two * 3, bad_mode_two,
 1475:                       right)
 1476: 
 1477:         self.setSeed()
 1478:         actual = triangular(left, mode * 3, right)
 1479:         assert_array_almost_equal(actual, desired, decimal=14)
 1480:         assert_raises(ValueError, triangular, bad_left_one, mode * 3, right)
 1481:         assert_raises(ValueError, triangular, left, bad_mode_one * 3, right)
 1482:         assert_raises(ValueError, triangular, bad_left_two, bad_mode_two * 3,
 1483:                       right)
 1484: 
 1485:         self.setSeed()
 1486:         actual = triangular(left, mode, right * 3)
 1487:         assert_array_almost_equal(actual, desired, decimal=14)
 1488:         assert_raises(ValueError, triangular, bad_left_one, mode, right * 3)
 1489:         assert_raises(ValueError, triangular, left, bad_mode_one, right * 3)
 1490:         assert_raises(ValueError, triangular, bad_left_two, bad_mode_two,
 1491:                       right * 3)
 1492: 
 1493:     def test_binomial(self):
 1494:         n = [1]
 1495:         p = [0.5]
 1496:         bad_n = [-1]
 1497:         bad_p_one = [-1]
 1498:         bad_p_two = [1.5]
 1499:         binom = np.random.binomial
 1500:         desired = np.array([1, 1, 1])
 1501: 
 1502:         self.setSeed()
 1503:         actual = binom(n * 3, p)
 1504:         assert_array_equal(actual, desired)
 1505:         assert_raises(ValueError, binom, bad_n * 3, p)
 1506:         assert_raises(ValueError, binom, n * 3, bad_p_one)
 1507:         assert_raises(ValueError, binom, n * 3, bad_p_two)
 1508: 
 1509:         self.setSeed()
 1510:         actual = binom(n, p * 3)
 1511:         assert_array_equal(actual, desired)
 1512:         assert_raises(ValueError, binom, bad_n, p * 3)
 1513:         assert_raises(ValueError, binom, n, bad_p_one * 3)
 1514:         assert_raises(ValueError, binom, n, bad_p_two * 3)
 1515: 
 1516:     def test_negative_binomial(self):
 1517:         n = [1]
 1518:         p = [0.5]
 1519:         bad_n = [-1]
 1520:         bad_p_one = [-1]
 1521:         bad_p_two = [1.5]
 1522:         neg_binom = np.random.negative_binomial
 1523:         desired = np.array([1, 0, 1])
 1524: 
 1525:         self.setSeed()
 1526:         actual = neg_binom(n * 3, p)
 1527:         assert_array_equal(actual, desired)
 1528:         assert_raises(ValueError, neg_binom, bad_n * 3, p)
 1529:         assert_raises(ValueError, neg_binom, n * 3, bad_p_one)
 1530:         assert_raises(ValueError, neg_binom, n * 3, bad_p_two)
 1531: 
 1532:         self.setSeed()
 1533:         actual = neg_binom(n, p * 3)
 1534:         assert_array_equal(actual, desired)
 1535:         assert_raises(ValueError, neg_binom, bad_n, p * 3)
 1536:         assert_raises(ValueError, neg_binom, n, bad_p_one * 3)
 1537:         assert_raises(ValueError, neg_binom, n, bad_p_two * 3)
 1538: 
 1539:     def test_poisson(self):
 1540:         max_lam = np.random.RandomState()._poisson_lam_max
 1541: 
 1542:         lam = [1]
 1543:         bad_lam_one = [-1]
 1544:         bad_lam_two = [max_lam * 2]
 1545:         poisson = np.random.poisson
 1546:         desired = np.array([1, 1, 0])
 1547: 
 1548:         self.setSeed()
 1549:         actual = poisson(lam * 3)
 1550:         assert_array_equal(actual, desired)
 1551:         assert_raises(ValueError, poisson, bad_lam_one * 3)
 1552:         assert_raises(ValueError, poisson, bad_lam_two * 3)
 1553: 
 1554:     def test_zipf(self):
 1555:         a = [2]
 1556:         bad_a = [0]
 1557:         zipf = np.random.zipf
 1558:         desired = np.array([2, 2, 1])
 1559: 
 1560:         self.setSeed()
 1561:         actual = zipf(a * 3)
 1562:         assert_array_equal(actual, desired)
 1563:         assert_raises(ValueError, zipf, bad_a * 3)
 1564:         with np.errstate(invalid='ignore'):
 1565:             assert_raises(ValueError, zipf, np.nan)
 1566:             assert_raises(ValueError, zipf, [0, 0, np.nan])
 1567: 
 1568:     def test_geometric(self):
 1569:         p = [0.5]
 1570:         bad_p_one = [-1]
 1571:         bad_p_two = [1.5]
 1572:         geom = np.random.geometric
 1573:         desired = np.array([2, 2, 2])
 1574: 
 1575:         self.setSeed()
 1576:         actual = geom(p * 3)
 1577:         assert_array_equal(actual, desired)
 1578:         assert_raises(ValueError, geom, bad_p_one * 3)
 1579:         assert_raises(ValueError, geom, bad_p_two * 3)
 1580: 
 1581:     def test_hypergeometric(self):
 1582:         ngood = [1]
 1583:         nbad = [2]
 1584:         nsample = [2]
 1585:         bad_ngood = [-1]
 1586:         bad_nbad = [-2]
 1587:         bad_nsample_one = [0]
 1588:         bad_nsample_two = [4]
 1589:         hypergeom = np.random.hypergeometric
 1590:         desired = np.array([1, 1, 1])
 1591: 
 1592:         self.setSeed()
 1593:         actual = hypergeom(ngood * 3, nbad, nsample)
 1594:         assert_array_equal(actual, desired)
 1595:         assert_raises(ValueError, hypergeom, bad_ngood * 3, nbad, nsample)
 1596:         assert_raises(ValueError, hypergeom, ngood * 3, bad_nbad, nsample)
 1597:         assert_raises(ValueError, hypergeom, ngood * 3, nbad, bad_nsample_one)
 1598:         assert_raises(ValueError, hypergeom, ngood * 3, nbad, bad_nsample_two)
 1599: 
 1600:         self.setSeed()
 1601:         actual = hypergeom(ngood, nbad * 3, nsample)
 1602:         assert_array_equal(actual, desired)
 1603:         assert_raises(ValueError, hypergeom, bad_ngood, nbad * 3, nsample)
 1604:         assert_raises(ValueError, hypergeom, ngood, bad_nbad * 3, nsample)
 1605:         assert_raises(ValueError, hypergeom, ngood, nbad * 3, bad_nsample_one)
 1606:         assert_raises(ValueError, hypergeom, ngood, nbad * 3, bad_nsample_two)
 1607: 
 1608:         self.setSeed()
 1609:         actual = hypergeom(ngood, nbad, nsample * 3)
 1610:         assert_array_equal(actual, desired)
 1611:         assert_raises(ValueError, hypergeom, bad_ngood, nbad, nsample * 3)
 1612:         assert_raises(ValueError, hypergeom, ngood, bad_nbad, nsample * 3)
 1613:         assert_raises(ValueError, hypergeom, ngood, nbad, bad_nsample_one * 3)
 1614:         assert_raises(ValueError, hypergeom, ngood, nbad, bad_nsample_two * 3)
 1615: 
 1616:     def test_logseries(self):
 1617:         p = [0.5]
 1618:         bad_p_one = [2]
 1619:         bad_p_two = [-1]
 1620:         logseries = np.random.logseries
 1621:         desired = np.array([1, 1, 1])
 1622: 
 1623:         self.setSeed()
 1624:         actual = logseries(p * 3)
 1625:         assert_array_equal(actual, desired)
 1626:         assert_raises(ValueError, logseries, bad_p_one * 3)
 1627:         assert_raises(ValueError, logseries, bad_p_two * 3)
 1628: 
 1629: 
 1630: @pytest.mark.skipif(IS_WASM, reason="can't start thread")
 1631: class TestThread:
 1632:     # make sure each state produces the same sequence even in threads
 1633:     def setup_method(self):
 1634:         self.seeds = range(4)
 1635: 
 1636:     def check_function(self, function, sz):
 1637:         from threading import Thread
 1638: 
 1639:         out1 = np.empty((len(self.seeds),) + sz)
 1640:         out2 = np.empty((len(self.seeds),) + sz)
 1641: 
 1642:         # threaded generation
 1643:         t = [Thread(target=function, args=(np.random.RandomState(s), o))
 1644:              for s, o in zip(self.seeds, out1)]
 1645:         [x.start() for x in t]
 1646:         [x.join() for x in t]
 1647: 
 1648:         # the same serial
 1649:         for s, o in zip(self.seeds, out2):
 1650:             function(np.random.RandomState(s), o)
 1651: 
 1652:         # these platforms change x87 fpu precision mode in threads
 1653:         if np.intp().dtype.itemsize == 4 and sys.platform == "win32":
 1654:             assert_array_almost_equal(out1, out2)
 1655:         else:
 1656:             assert_array_equal(out1, out2)
 1657: 
 1658:     def test_normal(self):
 1659:         def gen_random(state, out):
 1660:             out[...] = state.normal(size=10000)
 1661:         self.check_function(gen_random, sz=(10000,))
 1662: 
 1663:     def test_exp(self):
 1664:         def gen_random(state, out):
 1665:             out[...] = state.exponential(scale=np.ones((100, 1000)))
 1666:         self.check_function(gen_random, sz=(100, 1000))
 1667: 
 1668:     def test_multinomial(self):
 1669:         def gen_random(state, out):
 1670:             out[...] = state.multinomial(10, [1 / 6.] * 6, size=10000)
 1671:         self.check_function(gen_random, sz=(10000, 6))
 1672: 
 1673: 
 1674: # See Issue #4263
 1675: class TestSingleEltArrayInput:
 1676:     def setup_method(self):
 1677:         self.argOne = np.array([2])
 1678:         self.argTwo = np.array([3])
 1679:         self.argThree = np.array([4])
 1680:         self.tgtShape = (1,)
 1681: 
 1682:     def test_one_arg_funcs(self):
 1683:         funcs = (np.random.exponential, np.random.standard_gamma,
 1684:                  np.random.chisquare, np.random.standard_t,
 1685:                  np.random.pareto, np.random.weibull,
 1686:                  np.random.power, np.random.rayleigh,
 1687:                  np.random.poisson, np.random.zipf,
 1688:                  np.random.geometric, np.random.logseries)
 1689: 
 1690:         probfuncs = (np.random.geometric, np.random.logseries)
 1691: 
 1692:         for func in funcs:
 1693:             if func in probfuncs:  # p < 1.0
 1694:                 out = func(np.array([0.5]))
 1695: 
 1696:             else:
 1697:                 out = func(self.argOne)
 1698: 
 1699:             assert_equal(out.shape, self.tgtShape)
 1700: 
 1701:     def test_two_arg_funcs(self):
 1702:         funcs = (np.random.uniform, np.random.normal,
 1703:                  np.random.beta, np.random.gamma,
 1704:                  np.random.f, np.random.noncentral_chisquare,
 1705:                  np.random.vonmises, np.random.laplace,
 1706:                  np.random.gumbel, np.random.logistic,
 1707:                  np.random.lognormal, np.random.wald,
 1708:                  np.random.binomial, np.random.negative_binomial)
 1709: 
 1710:         probfuncs = (np.random.binomial, np.random.negative_binomial)
 1711: 
 1712:         for func in funcs:
 1713:             if func in probfuncs:  # p <= 1
 1714:                 argTwo = np.array([0.5])
 1715: 
 1716:             else:
 1717:                 argTwo = self.argTwo
 1718: 
 1719:             out = func(self.argOne, argTwo)
 1720:             assert_equal(out.shape, self.tgtShape)
 1721: 
 1722:             out = func(self.argOne[0], argTwo)
 1723:             assert_equal(out.shape, self.tgtShape)
 1724: 
 1725:             out = func(self.argOne, argTwo[0])
 1726:             assert_equal(out.shape, self.tgtShape)
 1727: 
 1728:     def test_randint(self):
 1729:         itype = [bool, np.int8, np.uint8, np.int16, np.uint16,
 1730:                  np.int32, np.uint32, np.int64, np.uint64]
 1731:         func = np.random.randint
 1732:         high = np.array([1])
 1733:         low = np.array([0])
 1734: 
 1735:         for dt in itype:
 1736:             out = func(low, high, dtype=dt)
 1737:             assert_equal(out.shape, self.tgtShape)
 1738: 
 1739:             out = func(low[0], high, dtype=dt)
 1740:             assert_equal(out.shape, self.tgtShape)
 1741: 
 1742:             out = func(low, high[0], dtype=dt)
 1743:             assert_equal(out.shape, self.tgtShape)
 1744: 
 1745:     def test_three_arg_funcs(self):
 1746:         funcs = [np.random.noncentral_f, np.random.triangular,
 1747:                  np.random.hypergeometric]
 1748: 
 1749:         for func in funcs:
 1750:             out = func(self.argOne, self.argTwo, self.argThree)
 1751:             assert_equal(out.shape, self.tgtShape)
 1752: 
 1753:             out = func(self.argOne[0], self.argTwo, self.argThree)
 1754:             assert_equal(out.shape, self.tgtShape)
 1755: 
 1756:             out = func(self.argOne, self.argTwo[0], self.argThree)
 1757:             assert_equal(out.shape, self.tgtShape)
