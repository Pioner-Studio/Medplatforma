    1: import pickle
    2: from functools import partial
    3: 
    4: import pytest
    5: 
    6: import numpy as np
    7: from numpy.random import MT19937, PCG64, PCG64DXSM, SFC64, Generator, Philox
    8: from numpy.testing import assert_, assert_array_equal, assert_equal
    9: 
   10: 
   11: @pytest.fixture(scope='module',
   12:                 params=(np.bool, np.int8, np.int16, np.int32, np.int64,
   13:                         np.uint8, np.uint16, np.uint32, np.uint64))
   14: def dtype(request):
   15:     return request.param
   16: 
   17: 
   18: def params_0(f):
   19:     val = f()
   20:     assert_(np.isscalar(val))
   21:     val = f(10)
   22:     assert_(val.shape == (10,))
   23:     val = f((10, 10))
   24:     assert_(val.shape == (10, 10))
   25:     val = f((10, 10, 10))
   26:     assert_(val.shape == (10, 10, 10))
   27:     val = f(size=(5, 5))
   28:     assert_(val.shape == (5, 5))
   29: 
   30: 
   31: def params_1(f, bounded=False):
   32:     a = 5.0
   33:     b = np.arange(2.0, 12.0)
   34:     c = np.arange(2.0, 102.0).reshape((10, 10))
   35:     d = np.arange(2.0, 1002.0).reshape((10, 10, 10))
   36:     e = np.array([2.0, 3.0])
   37:     g = np.arange(2.0, 12.0).reshape((1, 10, 1))
   38:     if bounded:
   39:         a = 0.5
   40:         b = b / (1.5 * b.max())
   41:         c = c / (1.5 * c.max())
   42:         d = d / (1.5 * d.max())
   43:         e = e / (1.5 * e.max())
   44:         g = g / (1.5 * g.max())
   45: 
   46:     # Scalar
   47:     f(a)
   48:     # Scalar - size
   49:     f(a, size=(10, 10))
   50:     # 1d
   51:     f(b)
   52:     # 2d
   53:     f(c)
   54:     # 3d
   55:     f(d)
   56:     # 1d size
   57:     f(b, size=10)
   58:     # 2d - size - broadcast
   59:     f(e, size=(10, 2))
   60:     # 3d - size
   61:     f(g, size=(10, 10, 10))
   62: 
   63: 
   64: def comp_state(state1, state2):
   65:     identical = True
   66:     if isinstance(state1, dict):
   67:         for key in state1:
   68:             identical &= comp_state(state1[key], state2[key])
   69:     elif type(state1) != type(state2):
   70:         identical &= type(state1) == type(state2)
   71:     elif (isinstance(state1, (list, tuple, np.ndarray)) and isinstance(
   72:             state2, (list, tuple, np.ndarray))):
   73:         for s1, s2 in zip(state1, state2):
   74:             identical &= comp_state(s1, s2)
   75:     else:
   76:         identical &= state1 == state2
   77:     return identical
   78: 
   79: 
   80: def warmup(rg, n=None):
   81:     if n is None:
   82:         n = 11 + np.random.randint(0, 20)
   83:     rg.standard_normal(n)
   84:     rg.standard_normal(n)
   85:     rg.standard_normal(n, dtype=np.float32)
   86:     rg.standard_normal(n, dtype=np.float32)
   87:     rg.integers(0, 2 ** 24, n, dtype=np.uint64)
   88:     rg.integers(0, 2 ** 48, n, dtype=np.uint64)
   89:     rg.standard_gamma(11.0, n)
   90:     rg.standard_gamma(11.0, n, dtype=np.float32)
   91:     rg.random(n, dtype=np.float64)
   92:     rg.random(n, dtype=np.float32)
   93: 
   94: 
   95: class RNG:
   96:     @classmethod
   97:     def setup_class(cls):
   98:         # Overridden in test classes. Place holder to silence IDE noise
   99:         cls.bit_generator = PCG64
  100:         cls.advance = None
  101:         cls.seed = [12345]
  102:         cls.rg = Generator(cls.bit_generator(*cls.seed))
  103:         cls.initial_state = cls.rg.bit_generator.state
  104:         cls.seed_vector_bits = 64
  105:         cls._extra_setup()
  106: 
  107:     @classmethod
  108:     def _extra_setup(cls):
  109:         cls.vec_1d = np.arange(2.0, 102.0)
  110:         cls.vec_2d = np.arange(2.0, 102.0)[None, :]
  111:         cls.mat = np.arange(2.0, 102.0, 0.01).reshape((100, 100))
  112:         cls.seed_error = TypeError
  113: 
  114:     def _reset_state(self):
  115:         self.rg.bit_generator.state = self.initial_state
  116: 
  117:     def test_init(self):
  118:         rg = Generator(self.bit_generator())
  119:         state = rg.bit_generator.state
  120:         rg.standard_normal(1)
  121:         rg.standard_normal(1)
  122:         rg.bit_generator.state = state
  123:         new_state = rg.bit_generator.state
  124:         assert_(comp_state(state, new_state))
  125: 
  126:     def test_advance(self):
  127:         state = self.rg.bit_generator.state
  128:         if hasattr(self.rg.bit_generator, 'advance'):
  129:             self.rg.bit_generator.advance(self.advance)
  130:             assert_(not comp_state(state, self.rg.bit_generator.state))
  131:         else:
  132:             bitgen_name = self.rg.bit_generator.__class__.__name__
  133:             pytest.skip(f'Advance is not supported by {bitgen_name}')
  134: 
  135:     def test_jump(self):
  136:         state = self.rg.bit_generator.state
  137:         if hasattr(self.rg.bit_generator, 'jumped'):
  138:             bit_gen2 = self.rg.bit_generator.jumped()
  139:             jumped_state = bit_gen2.state
  140:             assert_(not comp_state(state, jumped_state))
  141:             self.rg.random(2 * 3 * 5 * 7 * 11 * 13 * 17)
  142:             self.rg.bit_generator.state = state
  143:             bit_gen3 = self.rg.bit_generator.jumped()
  144:             rejumped_state = bit_gen3.state
  145:             assert_(comp_state(jumped_state, rejumped_state))
  146:         else:
  147:             bitgen_name = self.rg.bit_generator.__class__.__name__
  148:             if bitgen_name not in ('SFC64',):
  149:                 raise AttributeError(f'no "jumped" in {bitgen_name}')
  150:             pytest.skip(f'Jump is not supported by {bitgen_name}')
  151: 
  152:     def test_uniform(self):
  153:         r = self.rg.uniform(-1.0, 0.0, size=10)
  154:         assert_(len(r) == 10)
  155:         assert_((r > -1).all())
  156:         assert_((r <= 0).all())
  157: 
  158:     def test_uniform_array(self):
  159:         r = self.rg.uniform(np.array([-1.0] * 10), 0.0, size=10)
  160:         assert_(len(r) == 10)
  161:         assert_((r > -1).all())
  162:         assert_((r <= 0).all())
  163:         r = self.rg.uniform(np.array([-1.0] * 10),
  164:                             np.array([0.0] * 10), size=10)
  165:         assert_(len(r) == 10)
  166:         assert_((r > -1).all())
  167:         assert_((r <= 0).all())
  168:         r = self.rg.uniform(-1.0, np.array([0.0] * 10), size=10)
  169:         assert_(len(r) == 10)
  170:         assert_((r > -1).all())
  171:         assert_((r <= 0).all())
  172: 
  173:     def test_random(self):
  174:         assert_(len(self.rg.random(10)) == 10)
  175:         params_0(self.rg.random)
  176: 
  177:     def test_standard_normal_zig(self):
  178:         assert_(len(self.rg.standard_normal(10)) == 10)
  179: 
  180:     def test_standard_normal(self):
  181:         assert_(len(self.rg.standard_normal(10)) == 10)
  182:         params_0(self.rg.standard_normal)
  183: 
  184:     def test_standard_gamma(self):
  185:         assert_(len(self.rg.standard_gamma(10, 10)) == 10)
  186:         assert_(len(self.rg.standard_gamma(np.array([10] * 10), 10)) == 10)
  187:         params_1(self.rg.standard_gamma)
  188: 
  189:     def test_standard_exponential(self):
  190:         assert_(len(self.rg.standard_exponential(10)) == 10)
  191:         params_0(self.rg.standard_exponential)
  192: 
  193:     def test_standard_exponential_float(self):
  194:         randoms = self.rg.standard_exponential(10, dtype='float32')
  195:         assert_(len(randoms) == 10)
  196:         assert randoms.dtype == np.float32
  197:         params_0(partial(self.rg.standard_exponential, dtype='float32'))
  198: 
  199:     def test_standard_exponential_float_log(self):
  200:         randoms = self.rg.standard_exponential(10, dtype='float32',
  201:                                                method='inv')
  202:         assert_(len(randoms) == 10)
  203:         assert randoms.dtype == np.float32
  204:         params_0(partial(self.rg.standard_exponential, dtype='float32',
  205:                          method='inv'))
  206: 
  207:     def test_standard_cauchy(self):
  208:         assert_(len(self.rg.standard_cauchy(10)) == 10)
  209:         params_0(self.rg.standard_cauchy)
  210: 
  211:     def test_standard_t(self):
  212:         assert_(len(self.rg.standard_t(10, 10)) == 10)
  213:         params_1(self.rg.standard_t)
  214: 
  215:     def test_binomial(self):
  216:         assert_(self.rg.binomial(10, .5) >= 0)
  217:         assert_(self.rg.binomial(1000, .5) >= 0)
  218: 
  219:     def test_reset_state(self):
  220:         state = self.rg.bit_generator.state
  221:         int_1 = self.rg.integers(2**31)
  222:         self.rg.bit_generator.state = state
  223:         int_2 = self.rg.integers(2**31)
  224:         assert_(int_1 == int_2)
  225: 
  226:     def test_entropy_init(self):
  227:         rg = Generator(self.bit_generator())
  228:         rg2 = Generator(self.bit_generator())
  229:         assert_(not comp_state(rg.bit_generator.state,
  230:                                rg2.bit_generator.state))
  231: 
  232:     def test_seed(self):
  233:         rg = Generator(self.bit_generator(*self.seed))
  234:         rg2 = Generator(self.bit_generator(*self.seed))
  235:         rg.random()
  236:         rg2.random()
  237:         assert_(comp_state(rg.bit_generator.state, rg2.bit_generator.state))
  238: 
  239:     def test_reset_state_gauss(self):
  240:         rg = Generator(self.bit_generator(*self.seed))
  241:         rg.standard_normal()
  242:         state = rg.bit_generator.state
  243:         n1 = rg.standard_normal(size=10)
  244:         rg2 = Generator(self.bit_generator())
  245:         rg2.bit_generator.state = state
  246:         n2 = rg2.standard_normal(size=10)
  247:         assert_array_equal(n1, n2)
  248: 
  249:     def test_reset_state_uint32(self):
  250:         rg = Generator(self.bit_generator(*self.seed))
  251:         rg.integers(0, 2 ** 24, 120, dtype=np.uint32)
  252:         state = rg.bit_generator.state
  253:         n1 = rg.integers(0, 2 ** 24, 10, dtype=np.uint32)
  254:         rg2 = Generator(self.bit_generator())
  255:         rg2.bit_generator.state = state
  256:         n2 = rg2.integers(0, 2 ** 24, 10, dtype=np.uint32)
  257:         assert_array_equal(n1, n2)
  258: 
  259:     def test_reset_state_float(self):
  260:         rg = Generator(self.bit_generator(*self.seed))
  261:         rg.random(dtype='float32')
  262:         state = rg.bit_generator.state
  263:         n1 = rg.random(size=10, dtype='float32')
  264:         rg2 = Generator(self.bit_generator())
  265:         rg2.bit_generator.state = state
  266:         n2 = rg2.random(size=10, dtype='float32')
  267:         assert_((n1 == n2).all())
  268: 
  269:     def test_shuffle(self):
  270:         original = np.arange(200, 0, -1)
  271:         permuted = self.rg.permutation(original)
  272:         assert_((original != permuted).any())
  273: 
  274:     def test_permutation(self):
  275:         original = np.arange(200, 0, -1)
  276:         permuted = self.rg.permutation(original)
  277:         assert_((original != permuted).any())
  278: 
  279:     def test_beta(self):
  280:         vals = self.rg.beta(2.0, 2.0, 10)
  281:         assert_(len(vals) == 10)
  282:         vals = self.rg.beta(np.array([2.0] * 10), 2.0)
  283:         assert_(len(vals) == 10)
  284:         vals = self.rg.beta(2.0, np.array([2.0] * 10))
  285:         assert_(len(vals) == 10)
  286:         vals = self.rg.beta(np.array([2.0] * 10), np.array([2.0] * 10))
  287:         assert_(len(vals) == 10)
  288:         vals = self.rg.beta(np.array([2.0] * 10), np.array([[2.0]] * 10))
  289:         assert_(vals.shape == (10, 10))
  290: 
  291:     def test_bytes(self):
  292:         vals = self.rg.bytes(10)
  293:         assert_(len(vals) == 10)
  294: 
  295:     def test_chisquare(self):
  296:         vals = self.rg.chisquare(2.0, 10)
  297:         assert_(len(vals) == 10)
  298:         params_1(self.rg.chisquare)
  299: 
  300:     def test_exponential(self):
  301:         vals = self.rg.exponential(2.0, 10)
  302:         assert_(len(vals) == 10)
  303:         params_1(self.rg.exponential)
  304: 
  305:     def test_f(self):
  306:         vals = self.rg.f(3, 1000, 10)
  307:         assert_(len(vals) == 10)
  308: 
  309:     def test_gamma(self):
  310:         vals = self.rg.gamma(3, 2, 10)
  311:         assert_(len(vals) == 10)
  312: 
  313:     def test_geometric(self):
  314:         vals = self.rg.geometric(0.5, 10)
  315:         assert_(len(vals) == 10)
  316:         params_1(self.rg.exponential, bounded=True)
  317: 
  318:     def test_gumbel(self):
  319:         vals = self.rg.gumbel(2.0, 2.0, 10)
  320:         assert_(len(vals) == 10)
  321: 
  322:     def test_laplace(self):
  323:         vals = self.rg.laplace(2.0, 2.0, 10)
  324:         assert_(len(vals) == 10)
  325: 
  326:     def test_logitic(self):
  327:         vals = self.rg.logistic(2.0, 2.0, 10)
  328:         assert_(len(vals) == 10)
  329: 
  330:     def test_logseries(self):
  331:         vals = self.rg.logseries(0.5, 10)
  332:         assert_(len(vals) == 10)
  333: 
  334:     def test_negative_binomial(self):
  335:         vals = self.rg.negative_binomial(10, 0.2, 10)
  336:         assert_(len(vals) == 10)
  337: 
  338:     def test_noncentral_chisquare(self):
  339:         vals = self.rg.noncentral_chisquare(10, 2, 10)
  340:         assert_(len(vals) == 10)
  341: 
  342:     def test_noncentral_f(self):
  343:         vals = self.rg.noncentral_f(3, 1000, 2, 10)
  344:         assert_(len(vals) == 10)
  345:         vals = self.rg.noncentral_f(np.array([3] * 10), 1000, 2)
  346:         assert_(len(vals) == 10)
  347:         vals = self.rg.noncentral_f(3, np.array([1000] * 10), 2)
  348:         assert_(len(vals) == 10)
  349:         vals = self.rg.noncentral_f(3, 1000, np.array([2] * 10))
  350:         assert_(len(vals) == 10)
  351: 
  352:     def test_normal(self):
  353:         vals = self.rg.normal(10, 0.2, 10)
  354:         assert_(len(vals) == 10)
  355: 
  356:     def test_pareto(self):
  357:         vals = self.rg.pareto(3.0, 10)
  358:         assert_(len(vals) == 10)
  359: 
  360:     def test_poisson(self):
  361:         vals = self.rg.poisson(10, 10)
  362:         assert_(len(vals) == 10)
  363:         vals = self.rg.poisson(np.array([10] * 10))
  364:         assert_(len(vals) == 10)
  365:         params_1(self.rg.poisson)
  366: 
  367:     def test_power(self):
  368:         vals = self.rg.power(0.2, 10)
  369:         assert_(len(vals) == 10)
  370: 
  371:     def test_integers(self):
  372:         vals = self.rg.integers(10, 20, 10)
  373:         assert_(len(vals) == 10)
  374: 
  375:     def test_rayleigh(self):
  376:         vals = self.rg.rayleigh(0.2, 10)
  377:         assert_(len(vals) == 10)
  378:         params_1(self.rg.rayleigh, bounded=True)
  379: 
  380:     def test_vonmises(self):
  381:         vals = self.rg.vonmises(10, 0.2, 10)
  382:         assert_(len(vals) == 10)
  383: 
  384:     def test_wald(self):
  385:         vals = self.rg.wald(1.0, 1.0, 10)
  386:         assert_(len(vals) == 10)
  387: 
  388:     def test_weibull(self):
  389:         vals = self.rg.weibull(1.0, 10)
  390:         assert_(len(vals) == 10)
  391: 
  392:     def test_zipf(self):
  393:         vals = self.rg.zipf(10, 10)
  394:         assert_(len(vals) == 10)
  395:         vals = self.rg.zipf(self.vec_1d)
  396:         assert_(len(vals) == 100)
  397:         vals = self.rg.zipf(self.vec_2d)
  398:         assert_(vals.shape == (1, 100))
  399:         vals = self.rg.zipf(self.mat)
  400:         assert_(vals.shape == (100, 100))
  401: 
  402:     def test_hypergeometric(self):
  403:         vals = self.rg.hypergeometric(25, 25, 20)
  404:         assert_(np.isscalar(vals))
  405:         vals = self.rg.hypergeometric(np.array([25] * 10), 25, 20)
  406:         assert_(vals.shape == (10,))
  407: 
  408:     def test_triangular(self):
  409:         vals = self.rg.triangular(-5, 0, 5)
  410:         assert_(np.isscalar(vals))
  411:         vals = self.rg.triangular(-5, np.array([0] * 10), 5)
  412:         assert_(vals.shape == (10,))
  413: 
  414:     def test_multivariate_normal(self):
  415:         mean = [0, 0]
  416:         cov = [[1, 0], [0, 100]]  # diagonal covariance
  417:         x = self.rg.multivariate_normal(mean, cov, 5000)
  418:         assert_(x.shape == (5000, 2))
  419:         x_zig = self.rg.multivariate_normal(mean, cov, 5000)
  420:         assert_(x.shape == (5000, 2))
  421:         x_inv = self.rg.multivariate_normal(mean, cov, 5000)
  422:         assert_(x.shape == (5000, 2))
  423:         assert_((x_zig != x_inv).any())
  424: 
  425:     def test_multinomial(self):
  426:         vals = self.rg.multinomial(100, [1.0 / 3, 2.0 / 3])
  427:         assert_(vals.shape == (2,))
  428:         vals = self.rg.multinomial(100, [1.0 / 3, 2.0 / 3], size=10)
  429:         assert_(vals.shape == (10, 2))
  430: 
  431:     def test_dirichlet(self):
  432:         s = self.rg.dirichlet((10, 5, 3), 20)
  433:         assert_(s.shape == (20, 3))
  434: 
  435:     def test_pickle(self):
  436:         pick = pickle.dumps(self.rg)
  437:         unpick = pickle.loads(pick)
  438:         assert_(type(self.rg) == type(unpick))
  439:         assert_(comp_state(self.rg.bit_generator.state,
  440:                            unpick.bit_generator.state))
  441: 
  442:         pick = pickle.dumps(self.rg)
  443:         unpick = pickle.loads(pick)
  444:         assert_(type(self.rg) == type(unpick))
  445:         assert_(comp_state(self.rg.bit_generator.state,
  446:                            unpick.bit_generator.state))
  447: 
  448:     def test_seed_array(self):
  449:         if self.seed_vector_bits is None:
  450:             bitgen_name = self.bit_generator.__name__
  451:             pytest.skip(f'Vector seeding is not supported by {bitgen_name}')
  452: 
  453:         if self.seed_vector_bits == 32:
  454:             dtype = np.uint32
  455:         else:
  456:             dtype = np.uint64
  457:         seed = np.array([1], dtype=dtype)
  458:         bg = self.bit_generator(seed)
  459:         state1 = bg.state
  460:         bg = self.bit_generator(1)
  461:         state2 = bg.state
  462:         assert_(comp_state(state1, state2))
  463: 
  464:         seed = np.arange(4, dtype=dtype)
  465:         bg = self.bit_generator(seed)
  466:         state1 = bg.state
  467:         bg = self.bit_generator(seed[0])
  468:         state2 = bg.state
  469:         assert_(not comp_state(state1, state2))
  470: 
  471:         seed = np.arange(1500, dtype=dtype)
  472:         bg = self.bit_generator(seed)
  473:         state1 = bg.state
  474:         bg = self.bit_generator(seed[0])
  475:         state2 = bg.state
  476:         assert_(not comp_state(state1, state2))
  477: 
  478:         seed = 2 ** np.mod(np.arange(1500, dtype=dtype),
  479:                            self.seed_vector_bits - 1) + 1
  480:         bg = self.bit_generator(seed)
  481:         state1 = bg.state
  482:         bg = self.bit_generator(seed[0])
  483:         state2 = bg.state
  484:         assert_(not comp_state(state1, state2))
  485: 
  486:     def test_uniform_float(self):
  487:         rg = Generator(self.bit_generator(12345))
  488:         warmup(rg)
  489:         state = rg.bit_generator.state
  490:         r1 = rg.random(11, dtype=np.float32)
  491:         rg2 = Generator(self.bit_generator())
  492:         warmup(rg2)
  493:         rg2.bit_generator.state = state
  494:         r2 = rg2.random(11, dtype=np.float32)
  495:         assert_array_equal(r1, r2)
  496:         assert_equal(r1.dtype, np.float32)
  497:         assert_(comp_state(rg.bit_generator.state, rg2.bit_generator.state))
  498: 
  499:     def test_gamma_floats(self):
  500:         rg = Generator(self.bit_generator())
  501:         warmup(rg)
  502:         state = rg.bit_generator.state
  503:         r1 = rg.standard_gamma(4.0, 11, dtype=np.float32)
  504:         rg2 = Generator(self.bit_generator())
  505:         warmup(rg2)
  506:         rg2.bit_generator.state = state
  507:         r2 = rg2.standard_gamma(4.0, 11, dtype=np.float32)
  508:         assert_array_equal(r1, r2)
  509:         assert_equal(r1.dtype, np.float32)
  510:         assert_(comp_state(rg.bit_generator.state, rg2.bit_generator.state))
  511: 
  512:     def test_normal_floats(self):
  513:         rg = Generator(self.bit_generator())
  514:         warmup(rg)
  515:         state = rg.bit_generator.state
  516:         r1 = rg.standard_normal(11, dtype=np.float32)
  517:         rg2 = Generator(self.bit_generator())
  518:         warmup(rg2)
  519:         rg2.bit_generator.state = state
  520:         r2 = rg2.standard_normal(11, dtype=np.float32)
  521:         assert_array_equal(r1, r2)
  522:         assert_equal(r1.dtype, np.float32)
  523:         assert_(comp_state(rg.bit_generator.state, rg2.bit_generator.state))
  524: 
  525:     def test_normal_zig_floats(self):
  526:         rg = Generator(self.bit_generator())
  527:         warmup(rg)
  528:         state = rg.bit_generator.state
  529:         r1 = rg.standard_normal(11, dtype=np.float32)
  530:         rg2 = Generator(self.bit_generator())
  531:         warmup(rg2)
  532:         rg2.bit_generator.state = state
  533:         r2 = rg2.standard_normal(11, dtype=np.float32)
  534:         assert_array_equal(r1, r2)
  535:         assert_equal(r1.dtype, np.float32)
  536:         assert_(comp_state(rg.bit_generator.state, rg2.bit_generator.state))
  537: 
  538:     def test_output_fill(self):
  539:         rg = self.rg
  540:         state = rg.bit_generator.state
  541:         size = (31, 7, 97)
  542:         existing = np.empty(size)
  543:         rg.bit_generator.state = state
  544:         rg.standard_normal(out=existing)
  545:         rg.bit_generator.state = state
  546:         direct = rg.standard_normal(size=size)
  547:         assert_equal(direct, existing)
  548: 
  549:         sized = np.empty(size)
  550:         rg.bit_generator.state = state
  551:         rg.standard_normal(out=sized, size=sized.shape)
  552: 
  553:         existing = np.empty(size, dtype=np.float32)
  554:         rg.bit_generator.state = state
  555:         rg.standard_normal(out=existing, dtype=np.float32)
  556:         rg.bit_generator.state = state
  557:         direct = rg.standard_normal(size=size, dtype=np.float32)
  558:         assert_equal(direct, existing)
  559: 
  560:     def test_output_filling_uniform(self):
  561:         rg = self.rg
  562:         state = rg.bit_generator.state
  563:         size = (31, 7, 97)
  564:         existing = np.empty(size)
  565:         rg.bit_generator.state = state
  566:         rg.random(out=existing)
  567:         rg.bit_generator.state = state
  568:         direct = rg.random(size=size)
  569:         assert_equal(direct, existing)
  570: 
  571:         existing = np.empty(size, dtype=np.float32)
  572:         rg.bit_generator.state = state
  573:         rg.random(out=existing, dtype=np.float32)
  574:         rg.bit_generator.state = state
  575:         direct = rg.random(size=size, dtype=np.float32)
  576:         assert_equal(direct, existing)
  577: 
  578:     def test_output_filling_exponential(self):
  579:         rg = self.rg
  580:         state = rg.bit_generator.state
  581:         size = (31, 7, 97)
  582:         existing = np.empty(size)
  583:         rg.bit_generator.state = state
  584:         rg.standard_exponential(out=existing)
  585:         rg.bit_generator.state = state
  586:         direct = rg.standard_exponential(size=size)
  587:         assert_equal(direct, existing)
  588: 
  589:         existing = np.empty(size, dtype=np.float32)
  590:         rg.bit_generator.state = state
  591:         rg.standard_exponential(out=existing, dtype=np.float32)
  592:         rg.bit_generator.state = state
  593:         direct = rg.standard_exponential(size=size, dtype=np.float32)
  594:         assert_equal(direct, existing)
  595: 
  596:     def test_output_filling_gamma(self):
  597:         rg = self.rg
  598:         state = rg.bit_generator.state
  599:         size = (31, 7, 97)
  600:         existing = np.zeros(size)
  601:         rg.bit_generator.state = state
  602:         rg.standard_gamma(1.0, out=existing)
  603:         rg.bit_generator.state = state
  604:         direct = rg.standard_gamma(1.0, size=size)
  605:         assert_equal(direct, existing)
  606: 
  607:         existing = np.zeros(size, dtype=np.float32)
  608:         rg.bit_generator.state = state
  609:         rg.standard_gamma(1.0, out=existing, dtype=np.float32)
  610:         rg.bit_generator.state = state
  611:         direct = rg.standard_gamma(1.0, size=size, dtype=np.float32)
  612:         assert_equal(direct, existing)
  613: 
  614:     def test_output_filling_gamma_broadcast(self):
  615:         rg = self.rg
  616:         state = rg.bit_generator.state
  617:         size = (31, 7, 97)
  618:         mu = np.arange(97.0) + 1.0
  619:         existing = np.zeros(size)
  620:         rg.bit_generator.state = state
  621:         rg.standard_gamma(mu, out=existing)
  622:         rg.bit_generator.state = state
  623:         direct = rg.standard_gamma(mu, size=size)
  624:         assert_equal(direct, existing)
  625: 
  626:         existing = np.zeros(size, dtype=np.float32)
  627:         rg.bit_generator.state = state
  628:         rg.standard_gamma(mu, out=existing, dtype=np.float32)
  629:         rg.bit_generator.state = state
  630:         direct = rg.standard_gamma(mu, size=size, dtype=np.float32)
  631:         assert_equal(direct, existing)
  632: 
  633:     def test_output_fill_error(self):
  634:         rg = self.rg
  635:         size = (31, 7, 97)
  636:         existing = np.empty(size)
  637:         with pytest.raises(TypeError):
  638:             rg.standard_normal(out=existing, dtype=np.float32)
  639:         with pytest.raises(ValueError):
  640:             rg.standard_normal(out=existing[::3])
  641:         existing = np.empty(size, dtype=np.float32)
  642:         with pytest.raises(TypeError):
  643:             rg.standard_normal(out=existing, dtype=np.float64)
  644: 
  645:         existing = np.zeros(size, dtype=np.float32)
  646:         with pytest.raises(TypeError):
  647:             rg.standard_gamma(1.0, out=existing, dtype=np.float64)
  648:         with pytest.raises(ValueError):
  649:             rg.standard_gamma(1.0, out=existing[::3], dtype=np.float32)
  650:         existing = np.zeros(size, dtype=np.float64)
  651:         with pytest.raises(TypeError):
  652:             rg.standard_gamma(1.0, out=existing, dtype=np.float32)
  653:         with pytest.raises(ValueError):
  654:             rg.standard_gamma(1.0, out=existing[::3])
  655: 
  656:     def test_integers_broadcast(self, dtype):
  657:         if dtype == np.bool:
  658:             upper = 2
  659:             lower = 0
  660:         else:
  661:             info = np.iinfo(dtype)
  662:             upper = int(info.max) + 1
  663:             lower = info.min
  664:         self._reset_state()
  665:         a = self.rg.integers(lower, [upper] * 10, dtype=dtype)
  666:         self._reset_state()
  667:         b = self.rg.integers([lower] * 10, upper, dtype=dtype)
  668:         assert_equal(a, b)
  669:         self._reset_state()
  670:         c = self.rg.integers(lower, upper, size=10, dtype=dtype)
  671:         assert_equal(a, c)
  672:         self._reset_state()
  673:         d = self.rg.integers(np.array(
  674:             [lower] * 10), np.array([upper], dtype=object), size=10,
  675:             dtype=dtype)
  676:         assert_equal(a, d)
  677:         self._reset_state()
  678:         e = self.rg.integers(
  679:             np.array([lower] * 10), np.array([upper] * 10), size=10,
  680:             dtype=dtype)
  681:         assert_equal(a, e)
  682: 
  683:         self._reset_state()
  684:         a = self.rg.integers(0, upper, size=10, dtype=dtype)
  685:         self._reset_state()
  686:         b = self.rg.integers([upper] * 10, dtype=dtype)
  687:         assert_equal(a, b)
  688: 
  689:     def test_integers_numpy(self, dtype):
  690:         high = np.array([1])
  691:         low = np.array([0])
  692: 
  693:         out = self.rg.integers(low, high, dtype=dtype)
  694:         assert out.shape == (1,)
  695: 
  696:         out = self.rg.integers(low[0], high, dtype=dtype)
  697:         assert out.shape == (1,)
  698: 
  699:         out = self.rg.integers(low, high[0], dtype=dtype)
  700:         assert out.shape == (1,)
  701: 
  702:     def test_integers_broadcast_errors(self, dtype):
  703:         if dtype == np.bool:
  704:             upper = 2
  705:             lower = 0
  706:         else:
  707:             info = np.iinfo(dtype)
  708:             upper = int(info.max) + 1
  709:             lower = info.min
  710:         with pytest.raises(ValueError):
  711:             self.rg.integers(lower, [upper + 1] * 10, dtype=dtype)
  712:         with pytest.raises(ValueError):
  713:             self.rg.integers(lower - 1, [upper] * 10, dtype=dtype)
  714:         with pytest.raises(ValueError):
  715:             self.rg.integers([lower - 1], [upper] * 10, dtype=dtype)
  716:         with pytest.raises(ValueError):
  717:             self.rg.integers([0], [0], dtype=dtype)
  718: 
  719: 
  720: class TestMT19937(RNG):
  721:     @classmethod
  722:     def setup_class(cls):
  723:         cls.bit_generator = MT19937
  724:         cls.advance = None
  725:         cls.seed = [2 ** 21 + 2 ** 16 + 2 ** 5 + 1]
  726:         cls.rg = Generator(cls.bit_generator(*cls.seed))
  727:         cls.initial_state = cls.rg.bit_generator.state
  728:         cls.seed_vector_bits = 32
  729:         cls._extra_setup()
  730:         cls.seed_error = ValueError
  731: 
  732:     def test_numpy_state(self):
  733:         nprg = np.random.RandomState()
  734:         nprg.standard_normal(99)
  735:         state = nprg.get_state()
  736:         self.rg.bit_generator.state = state
  737:         state2 = self.rg.bit_generator.state
  738:         assert_((state[1] == state2['state']['key']).all())
  739:         assert_(state[2] == state2['state']['pos'])
  740: 
  741: 
  742: class TestPhilox(RNG):
  743:     @classmethod
  744:     def setup_class(cls):
  745:         cls.bit_generator = Philox
  746:         cls.advance = 2**63 + 2**31 + 2**15 + 1
  747:         cls.seed = [12345]
  748:         cls.rg = Generator(cls.bit_generator(*cls.seed))
  749:         cls.initial_state = cls.rg.bit_generator.state
  750:         cls.seed_vector_bits = 64
  751:         cls._extra_setup()
  752: 
  753: 
  754: class TestSFC64(RNG):
  755:     @classmethod
  756:     def setup_class(cls):
  757:         cls.bit_generator = SFC64
  758:         cls.advance = None
  759:         cls.seed = [12345]
  760:         cls.rg = Generator(cls.bit_generator(*cls.seed))
  761:         cls.initial_state = cls.rg.bit_generator.state
  762:         cls.seed_vector_bits = 192
  763:         cls._extra_setup()
  764: 
  765: 
  766: class TestPCG64(RNG):
  767:     @classmethod
  768:     def setup_class(cls):
  769:         cls.bit_generator = PCG64
  770:         cls.advance = 2**63 + 2**31 + 2**15 + 1
  771:         cls.seed = [12345]
  772:         cls.rg = Generator(cls.bit_generator(*cls.seed))
  773:         cls.initial_state = cls.rg.bit_generator.state
  774:         cls.seed_vector_bits = 64
  775:         cls._extra_setup()
  776: 
  777: 
  778: class TestPCG64DXSM(RNG):
  779:     @classmethod
  780:     def setup_class(cls):
  781:         cls.bit_generator = PCG64DXSM
  782:         cls.advance = 2**63 + 2**31 + 2**15 + 1
  783:         cls.seed = [12345]
  784:         cls.rg = Generator(cls.bit_generator(*cls.seed))
  785:         cls.initial_state = cls.rg.bit_generator.state
  786:         cls.seed_vector_bits = 64
  787:         cls._extra_setup()
  788: 
  789: 
  790: class TestDefaultRNG(RNG):
  791:     @classmethod
  792:     def setup_class(cls):
  793:         # This will duplicate some tests that directly instantiate a fresh
  794:         # Generator(), but that's okay.
  795:         cls.bit_generator = PCG64
  796:         cls.advance = 2**63 + 2**31 + 2**15 + 1
  797:         cls.seed = [12345]
  798:         cls.rg = np.random.default_rng(*cls.seed)
  799:         cls.initial_state = cls.rg.bit_generator.state
  800:         cls.seed_vector_bits = 64
  801:         cls._extra_setup()
  802: 
  803:     def test_default_is_pcg64(self):
  804:         # In order to change the default BitGenerator, we'll go through
  805:         # a deprecation cycle to move to a different function.
  806:         assert_(isinstance(self.rg.bit_generator, PCG64))
  807: 
  808:     def test_seed(self):
  809:         np.random.default_rng()
  810:         np.random.default_rng(None)
  811:         np.random.default_rng(12345)
  812:         np.random.default_rng(0)
  813:         np.random.default_rng(43660444402423911716352051725018508569)
  814:         np.random.default_rng([43660444402423911716352051725018508569,
  815:                                279705150948142787361475340226491943209])
  816:         with pytest.raises(ValueError):
  817:             np.random.default_rng(-1)
  818:         with pytest.raises(ValueError):
  819:             np.random.default_rng([12345, -1])
