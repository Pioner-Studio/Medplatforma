    1: import sys
    2: 
    3: import numpy as np
    4: from numpy import random
    5: from numpy.testing import (
    6:     assert_,
    7:     assert_array_equal,
    8:     assert_raises,
    9: )
   10: 
   11: 
   12: class TestRegression:
   13: 
   14:     def test_VonMises_range(self):
   15:         # Make sure generated random variables are in [-pi, pi].
   16:         # Regression test for ticket #986.
   17:         for mu in np.linspace(-7., 7., 5):
   18:             r = random.mtrand.vonmises(mu, 1, 50)
   19:             assert_(np.all(r > -np.pi) and np.all(r <= np.pi))
   20: 
   21:     def test_hypergeometric_range(self):
   22:         # Test for ticket #921
   23:         assert_(np.all(np.random.hypergeometric(3, 18, 11, size=10) < 4))
   24:         assert_(np.all(np.random.hypergeometric(18, 3, 11, size=10) > 0))
   25: 
   26:         # Test for ticket #5623
   27:         args = [
   28:             (2**20 - 2, 2**20 - 2, 2**20 - 2),  # Check for 32-bit systems
   29:         ]
   30:         is_64bits = sys.maxsize > 2**32
   31:         if is_64bits and sys.platform != 'win32':
   32:             # Check for 64-bit systems
   33:             args.append((2**40 - 2, 2**40 - 2, 2**40 - 2))
   34:         for arg in args:
   35:             assert_(np.random.hypergeometric(*arg) > 0)
   36: 
   37:     def test_logseries_convergence(self):
   38:         # Test for ticket #923
   39:         N = 1000
   40:         np.random.seed(0)
   41:         rvsn = np.random.logseries(0.8, size=N)
   42:         # these two frequency counts should be close to theoretical
   43:         # numbers with this large sample
   44:         # theoretical large N result is 0.49706795
   45:         freq = np.sum(rvsn == 1) / N
   46:         msg = f'Frequency was {freq:f}, should be > 0.45'
   47:         assert_(freq > 0.45, msg)
   48:         # theoretical large N result is 0.19882718
   49:         freq = np.sum(rvsn == 2) / N
   50:         msg = f'Frequency was {freq:f}, should be < 0.23'
   51:         assert_(freq < 0.23, msg)
   52: 
   53:     def test_shuffle_mixed_dimension(self):
   54:         # Test for trac ticket #2074
   55:         for t in [[1, 2, 3, None],
   56:                   [(1, 1), (2, 2), (3, 3), None],
   57:                   [1, (2, 2), (3, 3), None],
   58:                   [(1, 1), 2, 3, None]]:
   59:             np.random.seed(12345)
   60:             shuffled = list(t)
   61:             random.shuffle(shuffled)
   62:             expected = np.array([t[0], t[3], t[1], t[2]], dtype=object)
   63:             assert_array_equal(np.array(shuffled, dtype=object), expected)
   64: 
   65:     def test_call_within_randomstate(self):
   66:         # Check that custom RandomState does not call into global state
   67:         m = np.random.RandomState()
   68:         res = np.array([0, 8, 7, 2, 1, 9, 4, 7, 0, 3])
   69:         for i in range(3):
   70:             np.random.seed(i)
   71:             m.seed(4321)
   72:             # If m.state is not honored, the result will change
   73:             assert_array_equal(m.choice(10, size=10, p=np.ones(10) / 10.), res)
   74: 
   75:     def test_multivariate_normal_size_types(self):
   76:         # Test for multivariate_normal issue with 'size' argument.
   77:         # Check that the multivariate_normal size argument can be a
   78:         # numpy integer.
   79:         np.random.multivariate_normal([0], [[0]], size=1)
   80:         np.random.multivariate_normal([0], [[0]], size=np.int_(1))
   81:         np.random.multivariate_normal([0], [[0]], size=np.int64(1))
   82: 
   83:     def test_beta_small_parameters(self):
   84:         # Test that beta with small a and b parameters does not produce
   85:         # NaNs due to roundoff errors causing 0 / 0, gh-5851
   86:         np.random.seed(1234567890)
   87:         x = np.random.beta(0.0001, 0.0001, size=100)
   88:         assert_(not np.any(np.isnan(x)), 'Nans in np.random.beta')
   89: 
   90:     def test_choice_sum_of_probs_tolerance(self):
   91:         # The sum of probs should be 1.0 with some tolerance.
   92:         # For low precision dtypes the tolerance was too tight.
   93:         # See numpy github issue 6123.
   94:         np.random.seed(1234)
   95:         a = [1, 2, 3]
   96:         counts = [4, 4, 2]
   97:         for dt in np.float16, np.float32, np.float64:
   98:             probs = np.array(counts, dtype=dt) / sum(counts)
   99:             c = np.random.choice(a, p=probs)
  100:             assert_(c in a)
  101:             assert_raises(ValueError, np.random.choice, a, p=probs * 0.9)
  102: 
  103:     def test_shuffle_of_array_of_different_length_strings(self):
  104:         # Test that permuting an array of different length strings
  105:         # will not cause a segfault on garbage collection
  106:         # Tests gh-7710
  107:         np.random.seed(1234)
  108: 
  109:         a = np.array(['a', 'a' * 1000])
  110: 
  111:         for _ in range(100):
  112:             np.random.shuffle(a)
  113: 
  114:         # Force Garbage Collection - should not segfault.
  115:         import gc
  116:         gc.collect()
  117: 
  118:     def test_shuffle_of_array_of_objects(self):
  119:         # Test that permuting an array of objects will not cause
  120:         # a segfault on garbage collection.
  121:         # See gh-7719
  122:         np.random.seed(1234)
  123:         a = np.array([np.arange(1), np.arange(4)], dtype=object)
  124: 
  125:         for _ in range(1000):
  126:             np.random.shuffle(a)
  127: 
  128:         # Force Garbage Collection - should not segfault.
  129:         import gc
  130:         gc.collect()
  131: 
  132:     def test_permutation_subclass(self):
  133:         class N(np.ndarray):
  134:             pass
  135: 
  136:         np.random.seed(1)
  137:         orig = np.arange(3).view(N)
  138:         perm = np.random.permutation(orig)
  139:         assert_array_equal(perm, np.array([0, 2, 1]))
  140:         assert_array_equal(orig, np.arange(3).view(N))
  141: 
  142:         class M:
  143:             a = np.arange(5)
  144: 
  145:             def __array__(self, dtype=None, copy=None):
  146:                 return self.a
  147: 
  148:         np.random.seed(1)
  149:         m = M()
  150:         perm = np.random.permutation(m)
  151:         assert_array_equal(perm, np.array([2, 1, 4, 0, 3]))
  152:         assert_array_equal(m.__array__(), np.arange(5))
