    1: r"""
    2: Building the required library in this example requires a source distribution
    3: of NumPy or clone of the NumPy git repository since distributions.c is not
    4: included in binary distributions.
    5: 
    6: On *nix, execute in numpy/random/src/distributions
    7: 
    8: export ${PYTHON_VERSION}=3.8 # Python version
    9: export PYTHON_INCLUDE=#path to Python's include folder, usually \
   10:     ${PYTHON_HOME}/include/python${PYTHON_VERSION}m
   11: export NUMPY_INCLUDE=#path to numpy's include folder, usually \
   12:     ${PYTHON_HOME}/lib/python${PYTHON_VERSION}/site-packages/numpy/_core/include
   13: gcc -shared -o libdistributions.so -fPIC distributions.c \
   14:     -I${NUMPY_INCLUDE} -I${PYTHON_INCLUDE}
   15: mv libdistributions.so ../../_examples/numba/
   16: 
   17: On Windows
   18: 
   19: rem PYTHON_HOME and PYTHON_VERSION are setup dependent, this is an example
   20: set PYTHON_HOME=c:\Anaconda
   21: set PYTHON_VERSION=38
   22: cl.exe /LD .\distributions.c -DDLL_EXPORT \
   23:     -I%PYTHON_HOME%\lib\site-packages\numpy\_core\include \
   24:     -I%PYTHON_HOME%\include %PYTHON_HOME%\libs\python%PYTHON_VERSION%.lib
   25: move distributions.dll ../../_examples/numba/
   26: """
   27: import os
   28: 
   29: import numba as nb
   30: from cffi import FFI
   31: 
   32: import numpy as np
   33: from numpy.random import PCG64
   34: 
   35: ffi = FFI()
   36: if os.path.exists('./distributions.dll'):
   37:     lib = ffi.dlopen('./distributions.dll')
   38: elif os.path.exists('./libdistributions.so'):
   39:     lib = ffi.dlopen('./libdistributions.so')
   40: else:
   41:     raise RuntimeError('Required DLL/so file was not found.')
   42: 
   43: ffi.cdef("""
   44: double random_standard_normal(void *bitgen_state);
   45: """)
   46: x = PCG64()
   47: xffi = x.cffi
   48: bit_generator = xffi.bit_generator
   49: 
   50: random_standard_normal = lib.random_standard_normal
   51: 
   52: 
   53: def normals(n, bit_generator):
   54:     out = np.empty(n)
   55:     for i in range(n):
   56:         out[i] = random_standard_normal(bit_generator)
   57:     return out
   58: 
   59: 
   60: normalsj = nb.jit(normals, nopython=True)
   61: 
   62: # Numba requires a memory address for void *
   63: # Can also get address from x.ctypes.bit_generator.value
   64: bit_generator_address = int(ffi.cast('uintptr_t', bit_generator))
   65: 
   66: norm = normalsj(1000, bit_generator_address)
   67: print(norm[:12])
