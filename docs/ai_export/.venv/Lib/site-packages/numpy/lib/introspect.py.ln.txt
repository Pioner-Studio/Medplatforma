    1: """
    2: Introspection helper functions.
    3: """
    4: 
    5: __all__ = ['opt_func_info']
    6: 
    7: 
    8: def opt_func_info(func_name=None, signature=None):
    9:     """
   10:     Returns a dictionary containing the currently supported CPU dispatched
   11:     features for all optimized functions.
   12: 
   13:     Parameters
   14:     ----------
   15:     func_name : str (optional)
   16:         Regular expression to filter by function name.
   17: 
   18:     signature : str (optional)
   19:         Regular expression to filter by data type.
   20: 
   21:     Returns
   22:     -------
   23:     dict
   24:         A dictionary where keys are optimized function names and values are
   25:         nested dictionaries indicating supported targets based on data types.
   26: 
   27:     Examples
   28:     --------
   29:     Retrieve dispatch information for functions named 'add' or 'sub' and
   30:     data types 'float64' or 'float32':
   31: 
   32:     >>> import numpy as np
   33:     >>> dict = np.lib.introspect.opt_func_info(
   34:     ...     func_name="add|abs", signature="float64|complex64"
   35:     ... )
   36:     >>> import json
   37:     >>> print(json.dumps(dict, indent=2))
   38:         {
   39:           "absolute": {
   40:             "dd": {
   41:               "current": "SSE41",
   42:               "available": "SSE41 baseline(SSE SSE2 SSE3)"
   43:             },
   44:             "Ff": {
   45:               "current": "FMA3__AVX2",
   46:               "available": "AVX512F FMA3__AVX2 baseline(SSE SSE2 SSE3)"
   47:             },
   48:             "Dd": {
   49:               "current": "FMA3__AVX2",
   50:               "available": "AVX512F FMA3__AVX2 baseline(SSE SSE2 SSE3)"
   51:             }
   52:           },
   53:           "add": {
   54:             "ddd": {
   55:               "current": "FMA3__AVX2",
   56:               "available": "FMA3__AVX2 baseline(SSE SSE2 SSE3)"
   57:             },
   58:             "FFF": {
   59:               "current": "FMA3__AVX2",
   60:               "available": "FMA3__AVX2 baseline(SSE SSE2 SSE3)"
   61:             }
   62:           }
   63:         }
   64: 
   65:     """
   66:     import re
   67: 
   68:     from numpy._core._multiarray_umath import __cpu_targets_info__ as targets
   69:     from numpy._core._multiarray_umath import dtype
   70: 
   71:     if func_name is not None:
   72:         func_pattern = re.compile(func_name)
   73:         matching_funcs = {
   74:             k: v for k, v in targets.items()
   75:             if func_pattern.search(k)
   76:         }
   77:     else:
   78:         matching_funcs = targets
   79: 
   80:     if signature is not None:
   81:         sig_pattern = re.compile(signature)
   82:         matching_sigs = {}
   83:         for k, v in matching_funcs.items():
   84:             matching_chars = {}
   85:             for chars, targets in v.items():
   86:                 if any(
   87:                     sig_pattern.search(c) or sig_pattern.search(dtype(c).name)
   88:                     for c in chars
   89:                 ):
   90:                     matching_chars[chars] = targets
   91:             if matching_chars:
   92:                 matching_sigs[k] = matching_chars
   93:     else:
   94:         matching_sigs = matching_funcs
   95:     return matching_sigs
