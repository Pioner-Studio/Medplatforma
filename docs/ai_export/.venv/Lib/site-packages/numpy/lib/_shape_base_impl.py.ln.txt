    1: import functools
    2: import warnings
    3: 
    4: import numpy._core.numeric as _nx
    5: from numpy._core import atleast_3d, overrides, vstack
    6: from numpy._core._multiarray_umath import _array_converter
    7: from numpy._core.fromnumeric import reshape, transpose
    8: from numpy._core.multiarray import normalize_axis_index
    9: from numpy._core.numeric import (
   10:     array,
   11:     asanyarray,
   12:     asarray,
   13:     normalize_axis_tuple,
   14:     zeros,
   15:     zeros_like,
   16: )
   17: from numpy._core.overrides import set_module
   18: from numpy._core.shape_base import _arrays_for_stack_dispatcher
   19: from numpy.lib._index_tricks_impl import ndindex
   20: from numpy.matrixlib.defmatrix import matrix  # this raises all the right alarm bells
   21: 
   22: __all__ = [
   23:     'column_stack', 'row_stack', 'dstack', 'array_split', 'split',
   24:     'hsplit', 'vsplit', 'dsplit', 'apply_over_axes', 'expand_dims',
   25:     'apply_along_axis', 'kron', 'tile', 'take_along_axis',
   26:     'put_along_axis'
   27:     ]
   28: 
   29: 
   30: array_function_dispatch = functools.partial(
   31:     overrides.array_function_dispatch, module='numpy')
   32: 
   33: 
   34: def _make_along_axis_idx(arr_shape, indices, axis):
   35:     # compute dimensions to iterate over
   36:     if not _nx.issubdtype(indices.dtype, _nx.integer):
   37:         raise IndexError('`indices` must be an integer array')
   38:     if len(arr_shape) != indices.ndim:
   39:         raise ValueError(
   40:             "`indices` and `arr` must have the same number of dimensions")
   41:     shape_ones = (1,) * indices.ndim
   42:     dest_dims = list(range(axis)) + [None] + list(range(axis + 1, indices.ndim))
   43: 
   44:     # build a fancy index, consisting of orthogonal aranges, with the
   45:     # requested index inserted at the right location
   46:     fancy_index = []
   47:     for dim, n in zip(dest_dims, arr_shape):
   48:         if dim is None:
   49:             fancy_index.append(indices)
   50:         else:
   51:             ind_shape = shape_ones[:dim] + (-1,) + shape_ones[dim + 1:]
   52:             fancy_index.append(_nx.arange(n).reshape(ind_shape))
   53: 
   54:     return tuple(fancy_index)
   55: 
   56: 
   57: def _take_along_axis_dispatcher(arr, indices, axis=None):
   58:     return (arr, indices)
   59: 
   60: 
   61: @array_function_dispatch(_take_along_axis_dispatcher)
   62: def take_along_axis(arr, indices, axis=-1):
   63:     """
   64:     Take values from the input array by matching 1d index and data slices.
   65: 
   66:     This iterates over matching 1d slices oriented along the specified axis in
   67:     the index and data arrays, and uses the former to look up values in the
   68:     latter. These slices can be different lengths.
   69: 
   70:     Functions returning an index along an axis, like `argsort` and
   71:     `argpartition`, produce suitable indices for this function.
   72: 
   73:     Parameters
   74:     ----------
   75:     arr : ndarray (Ni..., M, Nk...)
   76:         Source array
   77:     indices : ndarray (Ni..., J, Nk...)
   78:         Indices to take along each 1d slice of ``arr``. This must match the
   79:         dimension of ``arr``, but dimensions Ni and Nj only need to broadcast
   80:         against ``arr``.
   81:     axis : int or None, optional
   82:         The axis to take 1d slices along. If axis is None, the input array is
   83:         treated as if it had first been flattened to 1d, for consistency with
   84:         `sort` and `argsort`.
   85: 
   86:         .. versionchanged:: 2.3
   87:             The default value is now ``-1``.
   88: 
   89:     Returns
   90:     -------
   91:     out: ndarray (Ni..., J, Nk...)
   92:         The indexed result.
   93: 
   94:     Notes
   95:     -----
   96:     This is equivalent to (but faster than) the following use of `ndindex` and
   97:     `s_`, which sets each of ``ii`` and ``kk`` to a tuple of indices::
   98: 
   99:         Ni, M, Nk = a.shape[:axis], a.shape[axis], a.shape[axis+1:]
  100:         J = indices.shape[axis]  # Need not equal M
  101:         out = np.empty(Ni + (J,) + Nk)
  102: 
  103:         for ii in ndindex(Ni):
  104:             for kk in ndindex(Nk):
  105:                 a_1d       = a      [ii + s_[:,] + kk]
  106:                 indices_1d = indices[ii + s_[:,] + kk]
  107:                 out_1d     = out    [ii + s_[:,] + kk]
  108:                 for j in range(J):
  109:                     out_1d[j] = a_1d[indices_1d[j]]
  110: 
  111:     Equivalently, eliminating the inner loop, the last two lines would be::
  112: 
  113:                 out_1d[:] = a_1d[indices_1d]
  114: 
  115:     See Also
  116:     --------
  117:     take : Take along an axis, using the same indices for every 1d slice
  118:     put_along_axis :
  119:         Put values into the destination array by matching 1d index and data slices
  120: 
  121:     Examples
  122:     --------
  123:     >>> import numpy as np
  124: 
  125:     For this sample array
  126: 
  127:     >>> a = np.array([[10, 30, 20], [60, 40, 50]])
  128: 
  129:     We can sort either by using sort directly, or argsort and this function
  130: 
  131:     >>> np.sort(a, axis=1)
  132:     array([[10, 20, 30],
  133:            [40, 50, 60]])
  134:     >>> ai = np.argsort(a, axis=1)
  135:     >>> ai
  136:     array([[0, 2, 1],
  137:            [1, 2, 0]])
  138:     >>> np.take_along_axis(a, ai, axis=1)
  139:     array([[10, 20, 30],
  140:            [40, 50, 60]])
  141: 
  142:     The same works for max and min, if you maintain the trivial dimension
  143:     with ``keepdims``:
  144: 
  145:     >>> np.max(a, axis=1, keepdims=True)
  146:     array([[30],
  147:            [60]])
  148:     >>> ai = np.argmax(a, axis=1, keepdims=True)
  149:     >>> ai
  150:     array([[1],
  151:            [0]])
  152:     >>> np.take_along_axis(a, ai, axis=1)
  153:     array([[30],
  154:            [60]])
  155: 
  156:     If we want to get the max and min at the same time, we can stack the
  157:     indices first
  158: 
  159:     >>> ai_min = np.argmin(a, axis=1, keepdims=True)
  160:     >>> ai_max = np.argmax(a, axis=1, keepdims=True)
  161:     >>> ai = np.concatenate([ai_min, ai_max], axis=1)
  162:     >>> ai
  163:     array([[0, 1],
  164:            [1, 0]])
  165:     >>> np.take_along_axis(a, ai, axis=1)
  166:     array([[10, 30],
  167:            [40, 60]])
  168:     """
  169:     # normalize inputs
  170:     if axis is None:
  171:         if indices.ndim != 1:
  172:             raise ValueError(
  173:                 'when axis=None, `indices` must have a single dimension.')
  174:         arr = arr.flat
  175:         arr_shape = (len(arr),)  # flatiter has no .shape
  176:         axis = 0
  177:     else:
  178:         axis = normalize_axis_index(axis, arr.ndim)
  179:         arr_shape = arr.shape
  180: 
  181:     # use the fancy index
  182:     return arr[_make_along_axis_idx(arr_shape, indices, axis)]
  183: 
  184: 
  185: def _put_along_axis_dispatcher(arr, indices, values, axis):
  186:     return (arr, indices, values)
  187: 
  188: 
  189: @array_function_dispatch(_put_along_axis_dispatcher)
  190: def put_along_axis(arr, indices, values, axis):
  191:     """
  192:     Put values into the destination array by matching 1d index and data slices.
  193: 
  194:     This iterates over matching 1d slices oriented along the specified axis in
  195:     the index and data arrays, and uses the former to place values into the
  196:     latter. These slices can be different lengths.
  197: 
  198:     Functions returning an index along an axis, like `argsort` and
  199:     `argpartition`, produce suitable indices for this function.
  200: 
  201:     Parameters
  202:     ----------
  203:     arr : ndarray (Ni..., M, Nk...)
  204:         Destination array.
  205:     indices : ndarray (Ni..., J, Nk...)
  206:         Indices to change along each 1d slice of `arr`. This must match the
  207:         dimension of arr, but dimensions in Ni and Nj may be 1 to broadcast
  208:         against `arr`.
  209:     values : array_like (Ni..., J, Nk...)
  210:         values to insert at those indices. Its shape and dimension are
  211:         broadcast to match that of `indices`.
  212:     axis : int
  213:         The axis to take 1d slices along. If axis is None, the destination
  214:         array is treated as if a flattened 1d view had been created of it.
  215: 
  216:     Notes
  217:     -----
  218:     This is equivalent to (but faster than) the following use of `ndindex` and
  219:     `s_`, which sets each of ``ii`` and ``kk`` to a tuple of indices::
  220: 
  221:         Ni, M, Nk = a.shape[:axis], a.shape[axis], a.shape[axis+1:]
  222:         J = indices.shape[axis]  # Need not equal M
  223: 
  224:         for ii in ndindex(Ni):
  225:             for kk in ndindex(Nk):
  226:                 a_1d       = a      [ii + s_[:,] + kk]
  227:                 indices_1d = indices[ii + s_[:,] + kk]
  228:                 values_1d  = values [ii + s_[:,] + kk]
  229:                 for j in range(J):
  230:                     a_1d[indices_1d[j]] = values_1d[j]
  231: 
  232:     Equivalently, eliminating the inner loop, the last two lines would be::
  233: 
  234:                 a_1d[indices_1d] = values_1d
  235: 
  236:     See Also
  237:     --------
  238:     take_along_axis :
  239:         Take values from the input array by matching 1d index and data slices
  240: 
  241:     Examples
  242:     --------
  243:     >>> import numpy as np
  244: 
  245:     For this sample array
  246: 
  247:     >>> a = np.array([[10, 30, 20], [60, 40, 50]])
  248: 
  249:     We can replace the maximum values with:
  250: 
  251:     >>> ai = np.argmax(a, axis=1, keepdims=True)
  252:     >>> ai
  253:     array([[1],
  254:            [0]])
  255:     >>> np.put_along_axis(a, ai, 99, axis=1)
  256:     >>> a
  257:     array([[10, 99, 20],
  258:            [99, 40, 50]])
  259: 
  260:     """
  261:     # normalize inputs
  262:     if axis is None:
  263:         if indices.ndim != 1:
  264:             raise ValueError(
  265:                 'when axis=None, `indices` must have a single dimension.')
  266:         arr = arr.flat
  267:         axis = 0
  268:         arr_shape = (len(arr),)  # flatiter has no .shape
  269:     else:
  270:         axis = normalize_axis_index(axis, arr.ndim)
  271:         arr_shape = arr.shape
  272: 
  273:     # use the fancy index
  274:     arr[_make_along_axis_idx(arr_shape, indices, axis)] = values
  275: 
  276: 
  277: def _apply_along_axis_dispatcher(func1d, axis, arr, *args, **kwargs):
  278:     return (arr,)
  279: 
  280: 
  281: @array_function_dispatch(_apply_along_axis_dispatcher)
  282: def apply_along_axis(func1d, axis, arr, *args, **kwargs):
  283:     """
  284:     Apply a function to 1-D slices along the given axis.
  285: 
  286:     Execute `func1d(a, *args, **kwargs)` where `func1d` operates on 1-D arrays
  287:     and `a` is a 1-D slice of `arr` along `axis`.
  288: 
  289:     This is equivalent to (but faster than) the following use of `ndindex` and
  290:     `s_`, which sets each of ``ii``, ``jj``, and ``kk`` to a tuple of indices::
  291: 
  292:         Ni, Nk = a.shape[:axis], a.shape[axis+1:]
  293:         for ii in ndindex(Ni):
  294:             for kk in ndindex(Nk):
  295:                 f = func1d(arr[ii + s_[:,] + kk])
  296:                 Nj = f.shape
  297:                 for jj in ndindex(Nj):
  298:                     out[ii + jj + kk] = f[jj]
  299: 
  300:     Equivalently, eliminating the inner loop, this can be expressed as::
  301: 
  302:         Ni, Nk = a.shape[:axis], a.shape[axis+1:]
  303:         for ii in ndindex(Ni):
  304:             for kk in ndindex(Nk):
  305:                 out[ii + s_[...,] + kk] = func1d(arr[ii + s_[:,] + kk])
  306: 
  307:     Parameters
  308:     ----------
  309:     func1d : function (M,) -> (Nj...)
  310:         This function should accept 1-D arrays. It is applied to 1-D
  311:         slices of `arr` along the specified axis.
  312:     axis : integer
  313:         Axis along which `arr` is sliced.
  314:     arr : ndarray (Ni..., M, Nk...)
  315:         Input array.
  316:     args : any
  317:         Additional arguments to `func1d`.
  318:     kwargs : any
  319:         Additional named arguments to `func1d`.
  320: 
  321:     Returns
  322:     -------
  323:     out : ndarray  (Ni..., Nj..., Nk...)
  324:         The output array. The shape of `out` is identical to the shape of
  325:         `arr`, except along the `axis` dimension. This axis is removed, and
  326:         replaced with new dimensions equal to the shape of the return value
  327:         of `func1d`. So if `func1d` returns a scalar `out` will have one
  328:         fewer dimensions than `arr`.
  329: 
  330:     See Also
  331:     --------
  332:     apply_over_axes : Apply a function repeatedly over multiple axes.
  333: 
  334:     Examples
  335:     --------
  336:     >>> import numpy as np
  337:     >>> def my_func(a):
  338:     ...     \"\"\"Average first and last element of a 1-D array\"\"\"
  339:     ...     return (a[0] + a[-1]) * 0.5
  340:     >>> b = np.array([[1,2,3], [4,5,6], [7,8,9]])
  341:     >>> np.apply_along_axis(my_func, 0, b)
  342:     array([4., 5., 6.])
  343:     >>> np.apply_along_axis(my_func, 1, b)
  344:     array([2.,  5.,  8.])
  345: 
  346:     For a function that returns a 1D array, the number of dimensions in
  347:     `outarr` is the same as `arr`.
  348: 
  349:     >>> b = np.array([[8,1,7], [4,3,9], [5,2,6]])
  350:     >>> np.apply_along_axis(sorted, 1, b)
  351:     array([[1, 7, 8],
  352:            [3, 4, 9],
  353:            [2, 5, 6]])
  354: 
  355:     For a function that returns a higher dimensional array, those dimensions
  356:     are inserted in place of the `axis` dimension.
  357: 
  358:     >>> b = np.array([[1,2,3], [4,5,6], [7,8,9]])
  359:     >>> np.apply_along_axis(np.diag, -1, b)
  360:     array([[[1, 0, 0],
  361:             [0, 2, 0],
  362:             [0, 0, 3]],
  363:            [[4, 0, 0],
  364:             [0, 5, 0],
  365:             [0, 0, 6]],
  366:            [[7, 0, 0],
  367:             [0, 8, 0],
  368:             [0, 0, 9]]])
  369:     """
  370:     # handle negative axes
  371:     conv = _array_converter(arr)
  372:     arr = conv[0]
  373: 
  374:     nd = arr.ndim
  375:     axis = normalize_axis_index(axis, nd)
  376: 
  377:     # arr, with the iteration axis at the end
  378:     in_dims = list(range(nd))
  379:     inarr_view = transpose(arr, in_dims[:axis] + in_dims[axis + 1:] + [axis])
  380: 
  381:     # compute indices for the iteration axes, and append a trailing ellipsis to
  382:     # prevent 0d arrays decaying to scalars, which fixes gh-8642
  383:     inds = ndindex(inarr_view.shape[:-1])
  384:     inds = (ind + (Ellipsis,) for ind in inds)
  385: 
  386:     # invoke the function on the first item
  387:     try:
  388:         ind0 = next(inds)
  389:     except StopIteration:
  390:         raise ValueError(
  391:             'Cannot apply_along_axis when any iteration dimensions are 0'
  392:         ) from None
  393:     res = asanyarray(func1d(inarr_view[ind0], *args, **kwargs))
  394: 
  395:     # build a buffer for storing evaluations of func1d.
  396:     # remove the requested axis, and add the new ones on the end.
  397:     # laid out so that each write is contiguous.
  398:     # for a tuple index inds, buff[inds] = func1d(inarr_view[inds])
  399:     if not isinstance(res, matrix):
  400:         buff = zeros_like(res, shape=inarr_view.shape[:-1] + res.shape)
  401:     else:
  402:         # Matrices are nasty with reshaping, so do not preserve them here.
  403:         buff = zeros(inarr_view.shape[:-1] + res.shape, dtype=res.dtype)
  404: 
  405:     # permutation of axes such that out = buff.transpose(buff_permute)
  406:     buff_dims = list(range(buff.ndim))
  407:     buff_permute = (
  408:         buff_dims[0 : axis] +
  409:         buff_dims[buff.ndim - res.ndim : buff.ndim] +
  410:         buff_dims[axis : buff.ndim - res.ndim]
  411:     )
  412: 
  413:     # save the first result, then compute and save all remaining results
  414:     buff[ind0] = res
  415:     for ind in inds:
  416:         buff[ind] = asanyarray(func1d(inarr_view[ind], *args, **kwargs))
  417: 
  418:     res = transpose(buff, buff_permute)
  419:     return conv.wrap(res)
  420: 
  421: 
  422: def _apply_over_axes_dispatcher(func, a, axes):
  423:     return (a,)
  424: 
  425: 
  426: @array_function_dispatch(_apply_over_axes_dispatcher)
  427: def apply_over_axes(func, a, axes):
  428:     """
  429:     Apply a function repeatedly over multiple axes.
  430: 
  431:     `func` is called as `res = func(a, axis)`, where `axis` is the first
  432:     element of `axes`.  The result `res` of the function call must have
  433:     either the same dimensions as `a` or one less dimension.  If `res`
  434:     has one less dimension than `a`, a dimension is inserted before
  435:     `axis`.  The call to `func` is then repeated for each axis in `axes`,
  436:     with `res` as the first argument.
  437: 
  438:     Parameters
  439:     ----------
  440:     func : function
  441:         This function must take two arguments, `func(a, axis)`.
  442:     a : array_like
  443:         Input array.
  444:     axes : array_like
  445:         Axes over which `func` is applied; the elements must be integers.
  446: 
  447:     Returns
  448:     -------
  449:     apply_over_axis : ndarray
  450:         The output array.  The number of dimensions is the same as `a`,
  451:         but the shape can be different.  This depends on whether `func`
  452:         changes the shape of its output with respect to its input.
  453: 
  454:     See Also
  455:     --------
  456:     apply_along_axis :
  457:         Apply a function to 1-D slices of an array along the given axis.
  458: 
  459:     Notes
  460:     -----
  461:     This function is equivalent to tuple axis arguments to reorderable ufuncs
  462:     with keepdims=True. Tuple axis arguments to ufuncs have been available since
  463:     version 1.7.0.
  464: 
  465:     Examples
  466:     --------
  467:     >>> import numpy as np
  468:     >>> a = np.arange(24).reshape(2,3,4)
  469:     >>> a
  470:     array([[[ 0,  1,  2,  3],
  471:             [ 4,  5,  6,  7],
  472:             [ 8,  9, 10, 11]],
  473:            [[12, 13, 14, 15],
  474:             [16, 17, 18, 19],
  475:             [20, 21, 22, 23]]])
  476: 
  477:     Sum over axes 0 and 2. The result has same number of dimensions
  478:     as the original array:
  479: 
  480:     >>> np.apply_over_axes(np.sum, a, [0,2])
  481:     array([[[ 60],
  482:             [ 92],
  483:             [124]]])
  484: 
  485:     Tuple axis arguments to ufuncs are equivalent:
  486: 
  487:     >>> np.sum(a, axis=(0,2), keepdims=True)
  488:     array([[[ 60],
  489:             [ 92],
  490:             [124]]])
  491: 
  492:     """
  493:     val = asarray(a)
  494:     N = a.ndim
  495:     if array(axes).ndim == 0:
  496:         axes = (axes,)
  497:     for axis in axes:
  498:         if axis < 0:
  499:             axis = N + axis
  500:         args = (val, axis)
  501:         res = func(*args)
  502:         if res.ndim == val.ndim:
  503:             val = res
  504:         else:
  505:             res = expand_dims(res, axis)
  506:             if res.ndim == val.ndim:
  507:                 val = res
  508:             else:
  509:                 raise ValueError("function is not returning "
  510:                                  "an array of the correct shape")
  511:     return val
  512: 
  513: 
  514: def _expand_dims_dispatcher(a, axis):
  515:     return (a,)
  516: 
  517: 
  518: @array_function_dispatch(_expand_dims_dispatcher)
  519: def expand_dims(a, axis):
  520:     """
  521:     Expand the shape of an array.
  522: 
  523:     Insert a new axis that will appear at the `axis` position in the expanded
  524:     array shape.
  525: 
  526:     Parameters
  527:     ----------
  528:     a : array_like
  529:         Input array.
  530:     axis : int or tuple of ints
  531:         Position in the expanded axes where the new axis (or axes) is placed.
  532: 
  533:         .. deprecated:: 1.13.0
  534:             Passing an axis where ``axis > a.ndim`` will be treated as
  535:             ``axis == a.ndim``, and passing ``axis < -a.ndim - 1`` will
  536:             be treated as ``axis == 0``. This behavior is deprecated.
  537: 
  538:     Returns
  539:     -------
  540:     result : ndarray
  541:         View of `a` with the number of dimensions increased.
  542: 
  543:     See Also
  544:     --------
  545:     squeeze : The inverse operation, removing singleton dimensions
  546:     reshape : Insert, remove, and combine dimensions, and resize existing ones
  547:     atleast_1d, atleast_2d, atleast_3d
  548: 
  549:     Examples
  550:     --------
  551:     >>> import numpy as np
  552:     >>> x = np.array([1, 2])
  553:     >>> x.shape
  554:     (2,)
  555: 
  556:     The following is equivalent to ``x[np.newaxis, :]`` or ``x[np.newaxis]``:
  557: 
  558:     >>> y = np.expand_dims(x, axis=0)
  559:     >>> y
  560:     array([[1, 2]])
  561:     >>> y.shape
  562:     (1, 2)
  563: 
  564:     The following is equivalent to ``x[:, np.newaxis]``:
  565: 
  566:     >>> y = np.expand_dims(x, axis=1)
  567:     >>> y
  568:     array([[1],
  569:            [2]])
  570:     >>> y.shape
  571:     (2, 1)
  572: 
  573:     ``axis`` may also be a tuple:
  574: 
  575:     >>> y = np.expand_dims(x, axis=(0, 1))
  576:     >>> y
  577:     array([[[1, 2]]])
  578: 
  579:     >>> y = np.expand_dims(x, axis=(2, 0))
  580:     >>> y
  581:     array([[[1],
  582:             [2]]])
  583: 
  584:     Note that some examples may use ``None`` instead of ``np.newaxis``.  These
  585:     are the same objects:
  586: 
  587:     >>> np.newaxis is None
  588:     True
  589: 
  590:     """
  591:     if isinstance(a, matrix):
  592:         a = asarray(a)
  593:     else:
  594:         a = asanyarray(a)
  595: 
  596:     if not isinstance(axis, (tuple, list)):
  597:         axis = (axis,)
  598: 
  599:     out_ndim = len(axis) + a.ndim
  600:     axis = normalize_axis_tuple(axis, out_ndim)
  601: 
  602:     shape_it = iter(a.shape)
  603:     shape = [1 if ax in axis else next(shape_it) for ax in range(out_ndim)]
  604: 
  605:     return a.reshape(shape)
  606: 
  607: 
  608: # NOTE: Remove once deprecation period passes
  609: @set_module("numpy")
  610: def row_stack(tup, *, dtype=None, casting="same_kind"):
  611:     # Deprecated in NumPy 2.0, 2023-08-18
  612:     warnings.warn(
  613:         "`row_stack` alias is deprecated. "
  614:         "Use `np.vstack` directly.",
  615:         DeprecationWarning,
  616:         stacklevel=2
  617:     )
  618:     return vstack(tup, dtype=dtype, casting=casting)
  619: 
  620: 
  621: row_stack.__doc__ = vstack.__doc__
  622: 
  623: 
  624: def _column_stack_dispatcher(tup):
  625:     return _arrays_for_stack_dispatcher(tup)
  626: 
  627: 
  628: @array_function_dispatch(_column_stack_dispatcher)
  629: def column_stack(tup):
  630:     """
  631:     Stack 1-D arrays as columns into a 2-D array.
  632: 
  633:     Take a sequence of 1-D arrays and stack them as columns
  634:     to make a single 2-D array. 2-D arrays are stacked as-is,
  635:     just like with `hstack`.  1-D arrays are turned into 2-D columns
  636:     first.
  637: 
  638:     Parameters
  639:     ----------
  640:     tup : sequence of 1-D or 2-D arrays.
  641:         Arrays to stack. All of them must have the same first dimension.
  642: 
  643:     Returns
  644:     -------
  645:     stacked : 2-D array
  646:         The array formed by stacking the given arrays.
  647: 
  648:     See Also
  649:     --------
  650:     stack, hstack, vstack, concatenate
  651: 
  652:     Examples
  653:     --------
  654:     >>> import numpy as np
  655:     >>> a = np.array((1,2,3))
  656:     >>> b = np.array((2,3,4))
  657:     >>> np.column_stack((a,b))
  658:     array([[1, 2],
  659:            [2, 3],
  660:            [3, 4]])
  661: 
  662:     """
  663:     arrays = []
  664:     for v in tup:
  665:         arr = asanyarray(v)
  666:         if arr.ndim < 2:
  667:             arr = array(arr, copy=None, subok=True, ndmin=2).T
  668:         arrays.append(arr)
  669:     return _nx.concatenate(arrays, 1)
  670: 
  671: 
  672: def _dstack_dispatcher(tup):
  673:     return _arrays_for_stack_dispatcher(tup)
  674: 
  675: 
  676: @array_function_dispatch(_dstack_dispatcher)
  677: def dstack(tup):
  678:     """
  679:     Stack arrays in sequence depth wise (along third axis).
  680: 
  681:     This is equivalent to concatenation along the third axis after 2-D arrays
  682:     of shape `(M,N)` have been reshaped to `(M,N,1)` and 1-D arrays of shape
  683:     `(N,)` have been reshaped to `(1,N,1)`. Rebuilds arrays divided by
  684:     `dsplit`.
  685: 
  686:     This function makes most sense for arrays with up to 3 dimensions. For
  687:     instance, for pixel-data with a height (first axis), width (second axis),
  688:     and r/g/b channels (third axis). The functions `concatenate`, `stack` and
  689:     `block` provide more general stacking and concatenation operations.
  690: 
  691:     Parameters
  692:     ----------
  693:     tup : sequence of arrays
  694:         The arrays must have the same shape along all but the third axis.
  695:         1-D or 2-D arrays must have the same shape.
  696: 
  697:     Returns
  698:     -------
  699:     stacked : ndarray
  700:         The array formed by stacking the given arrays, will be at least 3-D.
  701: 
  702:     See Also
  703:     --------
  704:     concatenate : Join a sequence of arrays along an existing axis.
  705:     stack : Join a sequence of arrays along a new axis.
  706:     block : Assemble an nd-array from nested lists of blocks.
  707:     vstack : Stack arrays in sequence vertically (row wise).
  708:     hstack : Stack arrays in sequence horizontally (column wise).
  709:     column_stack : Stack 1-D arrays as columns into a 2-D array.
  710:     dsplit : Split array along third axis.
  711: 
  712:     Examples
  713:     --------
  714:     >>> import numpy as np
  715:     >>> a = np.array((1,2,3))
  716:     >>> b = np.array((2,3,4))
  717:     >>> np.dstack((a,b))
  718:     array([[[1, 2],
  719:             [2, 3],
  720:             [3, 4]]])
  721: 
  722:     >>> a = np.array([[1],[2],[3]])
  723:     >>> b = np.array([[2],[3],[4]])
  724:     >>> np.dstack((a,b))
  725:     array([[[1, 2]],
  726:            [[2, 3]],
  727:            [[3, 4]]])
  728: 
  729:     """
  730:     arrs = atleast_3d(*tup)
  731:     if not isinstance(arrs, tuple):
  732:         arrs = (arrs,)
  733:     return _nx.concatenate(arrs, 2)
  734: 
  735: 
  736: def _replace_zero_by_x_arrays(sub_arys):
  737:     for i in range(len(sub_arys)):
  738:         if _nx.ndim(sub_arys[i]) == 0:
  739:             sub_arys[i] = _nx.empty(0, dtype=sub_arys[i].dtype)
  740:         elif _nx.sometrue(_nx.equal(_nx.shape(sub_arys[i]), 0)):
  741:             sub_arys[i] = _nx.empty(0, dtype=sub_arys[i].dtype)
  742:     return sub_arys
  743: 
  744: 
  745: def _array_split_dispatcher(ary, indices_or_sections, axis=None):
  746:     return (ary, indices_or_sections)
  747: 
  748: 
  749: @array_function_dispatch(_array_split_dispatcher)
  750: def array_split(ary, indices_or_sections, axis=0):
  751:     """
  752:     Split an array into multiple sub-arrays.
  753: 
  754:     Please refer to the ``split`` documentation.  The only difference
  755:     between these functions is that ``array_split`` allows
  756:     `indices_or_sections` to be an integer that does *not* equally
  757:     divide the axis. For an array of length l that should be split
  758:     into n sections, it returns l % n sub-arrays of size l//n + 1
  759:     and the rest of size l//n.
  760: 
  761:     See Also
  762:     --------
  763:     split : Split array into multiple sub-arrays of equal size.
  764: 
  765:     Examples
  766:     --------
  767:     >>> import numpy as np
  768:     >>> x = np.arange(8.0)
  769:     >>> np.array_split(x, 3)
  770:     [array([0.,  1.,  2.]), array([3.,  4.,  5.]), array([6.,  7.])]
  771: 
  772:     >>> x = np.arange(9)
  773:     >>> np.array_split(x, 4)
  774:     [array([0, 1, 2]), array([3, 4]), array([5, 6]), array([7, 8])]
  775: 
  776:     """
  777:     try:
  778:         Ntotal = ary.shape[axis]
  779:     except AttributeError:
  780:         Ntotal = len(ary)
  781:     try:
  782:         # handle array case.
  783:         Nsections = len(indices_or_sections) + 1
  784:         div_points = [0] + list(indices_or_sections) + [Ntotal]
  785:     except TypeError:
  786:         # indices_or_sections is a scalar, not an array.
  787:         Nsections = int(indices_or_sections)
  788:         if Nsections <= 0:
  789:             raise ValueError('number sections must be larger than 0.') from None
  790:         Neach_section, extras = divmod(Ntotal, Nsections)
  791:         section_sizes = ([0] +
  792:                          extras * [Neach_section + 1] +
  793:                          (Nsections - extras) * [Neach_section])
  794:         div_points = _nx.array(section_sizes, dtype=_nx.intp).cumsum()
  795: 
  796:     sub_arys = []
  797:     sary = _nx.swapaxes(ary, axis, 0)
  798:     for i in range(Nsections):
  799:         st = div_points[i]
  800:         end = div_points[i + 1]
  801:         sub_arys.append(_nx.swapaxes(sary[st:end], axis, 0))
  802: 
  803:     return sub_arys
  804: 
  805: 
  806: def _split_dispatcher(ary, indices_or_sections, axis=None):
  807:     return (ary, indices_or_sections)
  808: 
  809: 
  810: @array_function_dispatch(_split_dispatcher)
  811: def split(ary, indices_or_sections, axis=0):
  812:     """
  813:     Split an array into multiple sub-arrays as views into `ary`.
  814: 
  815:     Parameters
  816:     ----------
  817:     ary : ndarray
  818:         Array to be divided into sub-arrays.
  819:     indices_or_sections : int or 1-D array
  820:         If `indices_or_sections` is an integer, N, the array will be divided
  821:         into N equal arrays along `axis`.  If such a split is not possible,
  822:         an error is raised.
  823: 
  824:         If `indices_or_sections` is a 1-D array of sorted integers, the entries
  825:         indicate where along `axis` the array is split.  For example,
  826:         ``[2, 3]`` would, for ``axis=0``, result in
  827: 
  828:         - ary[:2]
  829:         - ary[2:3]
  830:         - ary[3:]
  831: 
  832:         If an index exceeds the dimension of the array along `axis`,
  833:         an empty sub-array is returned correspondingly.
  834:     axis : int, optional
  835:         The axis along which to split, default is 0.
  836: 
  837:     Returns
  838:     -------
  839:     sub-arrays : list of ndarrays
  840:         A list of sub-arrays as views into `ary`.
  841: 
  842:     Raises
  843:     ------
  844:     ValueError
  845:         If `indices_or_sections` is given as an integer, but
  846:         a split does not result in equal division.
  847: 
  848:     See Also
  849:     --------
  850:     array_split : Split an array into multiple sub-arrays of equal or
  851:                   near-equal size.  Does not raise an exception if
  852:                   an equal division cannot be made.
  853:     hsplit : Split array into multiple sub-arrays horizontally (column-wise).
  854:     vsplit : Split array into multiple sub-arrays vertically (row wise).
  855:     dsplit : Split array into multiple sub-arrays along the 3rd axis (depth).
  856:     concatenate : Join a sequence of arrays along an existing axis.
  857:     stack : Join a sequence of arrays along a new axis.
  858:     hstack : Stack arrays in sequence horizontally (column wise).
  859:     vstack : Stack arrays in sequence vertically (row wise).
  860:     dstack : Stack arrays in sequence depth wise (along third dimension).
  861: 
  862:     Examples
  863:     --------
  864:     >>> import numpy as np
  865:     >>> x = np.arange(9.0)
  866:     >>> np.split(x, 3)
  867:     [array([0.,  1.,  2.]), array([3.,  4.,  5.]), array([6.,  7.,  8.])]
  868: 
  869:     >>> x = np.arange(8.0)
  870:     >>> np.split(x, [3, 5, 6, 10])
  871:     [array([0.,  1.,  2.]),
  872:      array([3.,  4.]),
  873:      array([5.]),
  874:      array([6.,  7.]),
  875:      array([], dtype=float64)]
  876: 
  877:     """
  878:     try:
  879:         len(indices_or_sections)
  880:     except TypeError:
  881:         sections = indices_or_sections
  882:         N = ary.shape[axis]
  883:         if N % sections:
  884:             raise ValueError(
  885:                 'array split does not result in an equal division') from None
  886:     return array_split(ary, indices_or_sections, axis)
  887: 
  888: 
  889: def _hvdsplit_dispatcher(ary, indices_or_sections):
  890:     return (ary, indices_or_sections)
  891: 
  892: 
  893: @array_function_dispatch(_hvdsplit_dispatcher)
  894: def hsplit(ary, indices_or_sections):
  895:     """
  896:     Split an array into multiple sub-arrays horizontally (column-wise).
  897: 
  898:     Please refer to the `split` documentation.  `hsplit` is equivalent
  899:     to `split` with ``axis=1``, the array is always split along the second
  900:     axis except for 1-D arrays, where it is split at ``axis=0``.
  901: 
  902:     See Also
  903:     --------
  904:     split : Split an array into multiple sub-arrays of equal size.
  905: 
  906:     Examples
  907:     --------
  908:     >>> import numpy as np
  909:     >>> x = np.arange(16.0).reshape(4, 4)
  910:     >>> x
  911:     array([[ 0.,   1.,   2.,   3.],
  912:            [ 4.,   5.,   6.,   7.],
  913:            [ 8.,   9.,  10.,  11.],
  914:            [12.,  13.,  14.,  15.]])
  915:     >>> np.hsplit(x, 2)
  916:     [array([[  0.,   1.],
  917:            [  4.,   5.],
  918:            [  8.,   9.],
  919:            [12.,  13.]]),
  920:      array([[  2.,   3.],
  921:            [  6.,   7.],
  922:            [10.,  11.],
  923:            [14.,  15.]])]
  924:     >>> np.hsplit(x, np.array([3, 6]))
  925:     [array([[ 0.,   1.,   2.],
  926:            [ 4.,   5.,   6.],
  927:            [ 8.,   9.,  10.],
  928:            [12.,  13.,  14.]]),
  929:      array([[ 3.],
  930:            [ 7.],
  931:            [11.],
  932:            [15.]]),
  933:      array([], shape=(4, 0), dtype=float64)]
  934: 
  935:     With a higher dimensional array the split is still along the second axis.
  936: 
  937:     >>> x = np.arange(8.0).reshape(2, 2, 2)
  938:     >>> x
  939:     array([[[0.,  1.],
  940:             [2.,  3.]],
  941:            [[4.,  5.],
  942:             [6.,  7.]]])
  943:     >>> np.hsplit(x, 2)
  944:     [array([[[0.,  1.]],
  945:            [[4.,  5.]]]),
  946:      array([[[2.,  3.]],
  947:            [[6.,  7.]]])]
  948: 
  949:     With a 1-D array, the split is along axis 0.
  950: 
  951:     >>> x = np.array([0, 1, 2, 3, 4, 5])
  952:     >>> np.hsplit(x, 2)
  953:     [array([0, 1, 2]), array([3, 4, 5])]
  954: 
  955:     """
  956:     if _nx.ndim(ary) == 0:
  957:         raise ValueError('hsplit only works on arrays of 1 or more dimensions')
  958:     if ary.ndim > 1:
  959:         return split(ary, indices_or_sections, 1)
  960:     else:
  961:         return split(ary, indices_or_sections, 0)
  962: 
  963: 
  964: @array_function_dispatch(_hvdsplit_dispatcher)
  965: def vsplit(ary, indices_or_sections):
  966:     """
  967:     Split an array into multiple sub-arrays vertically (row-wise).
  968: 
  969:     Please refer to the ``split`` documentation.  ``vsplit`` is equivalent
  970:     to ``split`` with `axis=0` (default), the array is always split along the
  971:     first axis regardless of the array dimension.
  972: 
  973:     See Also
  974:     --------
  975:     split : Split an array into multiple sub-arrays of equal size.
  976: 
  977:     Examples
  978:     --------
  979:     >>> import numpy as np
  980:     >>> x = np.arange(16.0).reshape(4, 4)
  981:     >>> x
  982:     array([[ 0.,   1.,   2.,   3.],
  983:            [ 4.,   5.,   6.,   7.],
  984:            [ 8.,   9.,  10.,  11.],
  985:            [12.,  13.,  14.,  15.]])
  986:     >>> np.vsplit(x, 2)
  987:     [array([[0., 1., 2., 3.],
  988:             [4., 5., 6., 7.]]),
  989:      array([[ 8.,  9., 10., 11.],
  990:             [12., 13., 14., 15.]])]
  991:     >>> np.vsplit(x, np.array([3, 6]))
  992:     [array([[ 0.,  1.,  2.,  3.],
  993:             [ 4.,  5.,  6.,  7.],
  994:             [ 8.,  9., 10., 11.]]),
  995:      array([[12., 13., 14., 15.]]),
  996:      array([], shape=(0, 4), dtype=float64)]
  997: 
  998:     With a higher dimensional array the split is still along the first axis.
  999: 
 1000:     >>> x = np.arange(8.0).reshape(2, 2, 2)
 1001:     >>> x
 1002:     array([[[0.,  1.],
 1003:             [2.,  3.]],
 1004:            [[4.,  5.],
 1005:             [6.,  7.]]])
 1006:     >>> np.vsplit(x, 2)
 1007:     [array([[[0., 1.],
 1008:              [2., 3.]]]),
 1009:      array([[[4., 5.],
 1010:              [6., 7.]]])]
 1011: 
 1012:     """
 1013:     if _nx.ndim(ary) < 2:
 1014:         raise ValueError('vsplit only works on arrays of 2 or more dimensions')
 1015:     return split(ary, indices_or_sections, 0)
 1016: 
 1017: 
 1018: @array_function_dispatch(_hvdsplit_dispatcher)
 1019: def dsplit(ary, indices_or_sections):
 1020:     """
 1021:     Split array into multiple sub-arrays along the 3rd axis (depth).
 1022: 
 1023:     Please refer to the `split` documentation.  `dsplit` is equivalent
 1024:     to `split` with ``axis=2``, the array is always split along the third
 1025:     axis provided the array dimension is greater than or equal to 3.
 1026: 
 1027:     See Also
 1028:     --------
 1029:     split : Split an array into multiple sub-arrays of equal size.
 1030: 
 1031:     Examples
 1032:     --------
 1033:     >>> import numpy as np
 1034:     >>> x = np.arange(16.0).reshape(2, 2, 4)
 1035:     >>> x
 1036:     array([[[ 0.,   1.,   2.,   3.],
 1037:             [ 4.,   5.,   6.,   7.]],
 1038:            [[ 8.,   9.,  10.,  11.],
 1039:             [12.,  13.,  14.,  15.]]])
 1040:     >>> np.dsplit(x, 2)
 1041:     [array([[[ 0.,  1.],
 1042:             [ 4.,  5.]],
 1043:            [[ 8.,  9.],
 1044:             [12., 13.]]]), array([[[ 2.,  3.],
 1045:             [ 6.,  7.]],
 1046:            [[10., 11.],
 1047:             [14., 15.]]])]
 1048:     >>> np.dsplit(x, np.array([3, 6]))
 1049:     [array([[[ 0.,   1.,   2.],
 1050:             [ 4.,   5.,   6.]],
 1051:            [[ 8.,   9.,  10.],
 1052:             [12.,  13.,  14.]]]),
 1053:      array([[[ 3.],
 1054:             [ 7.]],
 1055:            [[11.],
 1056:             [15.]]]),
 1057:     array([], shape=(2, 2, 0), dtype=float64)]
 1058:     """
 1059:     if _nx.ndim(ary) < 3:
 1060:         raise ValueError('dsplit only works on arrays of 3 or more dimensions')
 1061:     return split(ary, indices_or_sections, 2)
 1062: 
 1063: 
 1064: def get_array_wrap(*args):
 1065:     """Find the wrapper for the array with the highest priority.
 1066: 
 1067:     In case of ties, leftmost wins. If no wrapper is found, return None.
 1068: 
 1069:     .. deprecated:: 2.0
 1070:     """
 1071: 
 1072:     # Deprecated in NumPy 2.0, 2023-07-11
 1073:     warnings.warn(
 1074:         "`get_array_wrap` is deprecated. "
 1075:         "(deprecated in NumPy 2.0)",
 1076:         DeprecationWarning,
 1077:         stacklevel=2
 1078:     )
 1079: 
 1080:     wrappers = sorted((getattr(x, '__array_priority__', 0), -i,
 1081:                  x.__array_wrap__) for i, x in enumerate(args)
 1082:                                    if hasattr(x, '__array_wrap__'))
 1083:     if wrappers:
 1084:         return wrappers[-1][-1]
 1085:     return None
 1086: 
 1087: 
 1088: def _kron_dispatcher(a, b):
 1089:     return (a, b)
 1090: 
 1091: 
 1092: @array_function_dispatch(_kron_dispatcher)
 1093: def kron(a, b):
 1094:     """
 1095:     Kronecker product of two arrays.
 1096: 
 1097:     Computes the Kronecker product, a composite array made of blocks of the
 1098:     second array scaled by the first.
 1099: 
 1100:     Parameters
 1101:     ----------
 1102:     a, b : array_like
 1103: 
 1104:     Returns
 1105:     -------
 1106:     out : ndarray
 1107: 
 1108:     See Also
 1109:     --------
 1110:     outer : The outer product
 1111: 
 1112:     Notes
 1113:     -----
 1114:     The function assumes that the number of dimensions of `a` and `b`
 1115:     are the same, if necessary prepending the smallest with ones.
 1116:     If ``a.shape = (r0,r1,..,rN)`` and ``b.shape = (s0,s1,...,sN)``,
 1117:     the Kronecker product has shape ``(r0*s0, r1*s1, ..., rN*SN)``.
 1118:     The elements are products of elements from `a` and `b`, organized
 1119:     explicitly by::
 1120: 
 1121:         kron(a,b)[k0,k1,...,kN] = a[i0,i1,...,iN] * b[j0,j1,...,jN]
 1122: 
 1123:     where::
 1124: 
 1125:         kt = it * st + jt,  t = 0,...,N
 1126: 
 1127:     In the common 2-D case (N=1), the block structure can be visualized::
 1128: 
 1129:         [[ a[0,0]*b,   a[0,1]*b,  ... , a[0,-1]*b  ],
 1130:          [  ...                              ...   ],
 1131:          [ a[-1,0]*b,  a[-1,1]*b, ... , a[-1,-1]*b ]]
 1132: 
 1133: 
 1134:     Examples
 1135:     --------
 1136:     >>> import numpy as np
 1137:     >>> np.kron([1,10,100], [5,6,7])
 1138:     array([  5,   6,   7, ..., 500, 600, 700])
 1139:     >>> np.kron([5,6,7], [1,10,100])
 1140:     array([  5,  50, 500, ...,   7,  70, 700])
 1141: 
 1142:     >>> np.kron(np.eye(2), np.ones((2,2)))
 1143:     array([[1.,  1.,  0.,  0.],
 1144:            [1.,  1.,  0.,  0.],
 1145:            [0.,  0.,  1.,  1.],
 1146:            [0.,  0.,  1.,  1.]])
 1147: 
 1148:     >>> a = np.arange(100).reshape((2,5,2,5))
 1149:     >>> b = np.arange(24).reshape((2,3,4))
 1150:     >>> c = np.kron(a,b)
 1151:     >>> c.shape
 1152:     (2, 10, 6, 20)
 1153:     >>> I = (1,3,0,2)
 1154:     >>> J = (0,2,1)
 1155:     >>> J1 = (0,) + J             # extend to ndim=4
 1156:     >>> S1 = (1,) + b.shape
 1157:     >>> K = tuple(np.array(I) * np.array(S1) + np.array(J1))
 1158:     >>> c[K] == a[I]*b[J]
 1159:     True
 1160: 
 1161:     """
 1162:     # Working:
 1163:     # 1. Equalise the shapes by prepending smaller array with 1s
 1164:     # 2. Expand shapes of both the arrays by adding new axes at
 1165:     #    odd positions for 1st array and even positions for 2nd
 1166:     # 3. Compute the product of the modified array
 1167:     # 4. The inner most array elements now contain the rows of
 1168:     #    the Kronecker product
 1169:     # 5. Reshape the result to kron's shape, which is same as
 1170:     #    product of shapes of the two arrays.
 1171:     b = asanyarray(b)
 1172:     a = array(a, copy=None, subok=True, ndmin=b.ndim)
 1173:     is_any_mat = isinstance(a, matrix) or isinstance(b, matrix)
 1174:     ndb, nda = b.ndim, a.ndim
 1175:     nd = max(ndb, nda)
 1176: 
 1177:     if (nda == 0 or ndb == 0):
 1178:         return _nx.multiply(a, b)
 1179: 
 1180:     as_ = a.shape
 1181:     bs = b.shape
 1182:     if not a.flags.contiguous:
 1183:         a = reshape(a, as_)
 1184:     if not b.flags.contiguous:
 1185:         b = reshape(b, bs)
 1186: 
 1187:     # Equalise the shapes by prepending smaller one with 1s
 1188:     as_ = (1,) * max(0, ndb - nda) + as_
 1189:     bs = (1,) * max(0, nda - ndb) + bs
 1190: 
 1191:     # Insert empty dimensions
 1192:     a_arr = expand_dims(a, axis=tuple(range(ndb - nda)))
 1193:     b_arr = expand_dims(b, axis=tuple(range(nda - ndb)))
 1194: 
 1195:     # Compute the product
 1196:     a_arr = expand_dims(a_arr, axis=tuple(range(1, nd * 2, 2)))
 1197:     b_arr = expand_dims(b_arr, axis=tuple(range(0, nd * 2, 2)))
 1198:     # In case of `mat`, convert result to `array`
 1199:     result = _nx.multiply(a_arr, b_arr, subok=(not is_any_mat))
 1200: 
 1201:     # Reshape back
 1202:     result = result.reshape(_nx.multiply(as_, bs))
 1203: 
 1204:     return result if not is_any_mat else matrix(result, copy=False)
 1205: 
 1206: 
 1207: def _tile_dispatcher(A, reps):
 1208:     return (A, reps)
 1209: 
 1210: 
 1211: @array_function_dispatch(_tile_dispatcher)
 1212: def tile(A, reps):
 1213:     """
 1214:     Construct an array by repeating A the number of times given by reps.
 1215: 
 1216:     If `reps` has length ``d``, the result will have dimension of
 1217:     ``max(d, A.ndim)``.
 1218: 
 1219:     If ``A.ndim < d``, `A` is promoted to be d-dimensional by prepending new
 1220:     axes. So a shape (3,) array is promoted to (1, 3) for 2-D replication,
 1221:     or shape (1, 1, 3) for 3-D replication. If this is not the desired
 1222:     behavior, promote `A` to d-dimensions manually before calling this
 1223:     function.
 1224: 
 1225:     If ``A.ndim > d``, `reps` is promoted to `A`.ndim by prepending 1's to it.
 1226:     Thus for an `A` of shape (2, 3, 4, 5), a `reps` of (2, 2) is treated as
 1227:     (1, 1, 2, 2).
 1228: 
 1229:     Note : Although tile may be used for broadcasting, it is strongly
 1230:     recommended to use numpy's broadcasting operations and functions.
 1231: 
 1232:     Parameters
 1233:     ----------
 1234:     A : array_like
 1235:         The input array.
 1236:     reps : array_like
 1237:         The number of repetitions of `A` along each axis.
 1238: 
 1239:     Returns
 1240:     -------
 1241:     c : ndarray
 1242:         The tiled output array.
 1243: 
 1244:     See Also
 1245:     --------
 1246:     repeat : Repeat elements of an array.
 1247:     broadcast_to : Broadcast an array to a new shape
 1248: 
 1249:     Examples
 1250:     --------
 1251:     >>> import numpy as np
 1252:     >>> a = np.array([0, 1, 2])
 1253:     >>> np.tile(a, 2)
 1254:     array([0, 1, 2, 0, 1, 2])
 1255:     >>> np.tile(a, (2, 2))
 1256:     array([[0, 1, 2, 0, 1, 2],
 1257:            [0, 1, 2, 0, 1, 2]])
 1258:     >>> np.tile(a, (2, 1, 2))
 1259:     array([[[0, 1, 2, 0, 1, 2]],
 1260:            [[0, 1, 2, 0, 1, 2]]])
 1261: 
 1262:     >>> b = np.array([[1, 2], [3, 4]])
 1263:     >>> np.tile(b, 2)
 1264:     array([[1, 2, 1, 2],
 1265:            [3, 4, 3, 4]])
 1266:     >>> np.tile(b, (2, 1))
 1267:     array([[1, 2],
 1268:            [3, 4],
 1269:            [1, 2],
 1270:            [3, 4]])
 1271: 
 1272:     >>> c = np.array([1,2,3,4])
 1273:     >>> np.tile(c,(4,1))
 1274:     array([[1, 2, 3, 4],
 1275:            [1, 2, 3, 4],
 1276:            [1, 2, 3, 4],
 1277:            [1, 2, 3, 4]])
 1278:     """
 1279:     try:
 1280:         tup = tuple(reps)
 1281:     except TypeError:
 1282:         tup = (reps,)
 1283:     d = len(tup)
 1284:     if all(x == 1 for x in tup) and isinstance(A, _nx.ndarray):
 1285:         # Fixes the problem that the function does not make a copy if A is a
 1286:         # numpy array and the repetitions are 1 in all dimensions
 1287:         return _nx.array(A, copy=True, subok=True, ndmin=d)
 1288:     else:
 1289:         # Note that no copy of zero-sized arrays is made. However since they
 1290:         # have no data there is no risk of an inadvertent overwrite.
 1291:         c = _nx.array(A, copy=None, subok=True, ndmin=d)
 1292:     if (d < c.ndim):
 1293:         tup = (1,) * (c.ndim - d) + tup
 1294:     shape_out = tuple(s * t for s, t in zip(c.shape, tup))
 1295:     n = c.size
 1296:     if n > 0:
 1297:         for dim_in, nrep in zip(c.shape, tup):
 1298:             if nrep != 1:
 1299:                 c = c.reshape(-1, n).repeat(nrep, 0)
 1300:             n //= dim_in
 1301:     return c.reshape(shape_out)
