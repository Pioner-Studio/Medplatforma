    1: """
    2: Container class for backward compatibility with NumArray.
    3: 
    4: The user_array.container class exists for backward compatibility with NumArray
    5: and is not meant to be used in new code. If you need to create an array
    6: container class, we recommend either creating a class that wraps an ndarray
    7: or subclasses ndarray.
    8: 
    9: """
   10: from numpy._core import (
   11:     absolute,
   12:     add,
   13:     arange,
   14:     array,
   15:     asarray,
   16:     bitwise_and,
   17:     bitwise_or,
   18:     bitwise_xor,
   19:     divide,
   20:     equal,
   21:     greater,
   22:     greater_equal,
   23:     invert,
   24:     left_shift,
   25:     less,
   26:     less_equal,
   27:     multiply,
   28:     not_equal,
   29:     power,
   30:     remainder,
   31:     reshape,
   32:     right_shift,
   33:     shape,
   34:     sin,
   35:     sqrt,
   36:     subtract,
   37:     transpose,
   38: )
   39: from numpy._core.overrides import set_module
   40: 
   41: 
   42: @set_module("numpy.lib.user_array")
   43: class container:
   44:     """
   45:     container(data, dtype=None, copy=True)
   46: 
   47:     Standard container-class for easy multiple-inheritance.
   48: 
   49:     Methods
   50:     -------
   51:     copy
   52:     byteswap
   53:     astype
   54: 
   55:     """
   56:     def __init__(self, data, dtype=None, copy=True):
   57:         self.array = array(data, dtype, copy=copy)
   58: 
   59:     def __repr__(self):
   60:         if self.ndim > 0:
   61:             return self.__class__.__name__ + repr(self.array)[len("array"):]
   62:         else:
   63:             return self.__class__.__name__ + "(" + repr(self.array) + ")"
   64: 
   65:     def __array__(self, t=None):
   66:         if t:
   67:             return self.array.astype(t)
   68:         return self.array
   69: 
   70:     # Array as sequence
   71:     def __len__(self):
   72:         return len(self.array)
   73: 
   74:     def __getitem__(self, index):
   75:         return self._rc(self.array[index])
   76: 
   77:     def __setitem__(self, index, value):
   78:         self.array[index] = asarray(value, self.dtype)
   79: 
   80:     def __abs__(self):
   81:         return self._rc(absolute(self.array))
   82: 
   83:     def __neg__(self):
   84:         return self._rc(-self.array)
   85: 
   86:     def __add__(self, other):
   87:         return self._rc(self.array + asarray(other))
   88: 
   89:     __radd__ = __add__
   90: 
   91:     def __iadd__(self, other):
   92:         add(self.array, other, self.array)
   93:         return self
   94: 
   95:     def __sub__(self, other):
   96:         return self._rc(self.array - asarray(other))
   97: 
   98:     def __rsub__(self, other):
   99:         return self._rc(asarray(other) - self.array)
  100: 
  101:     def __isub__(self, other):
  102:         subtract(self.array, other, self.array)
  103:         return self
  104: 
  105:     def __mul__(self, other):
  106:         return self._rc(multiply(self.array, asarray(other)))
  107: 
  108:     __rmul__ = __mul__
  109: 
  110:     def __imul__(self, other):
  111:         multiply(self.array, other, self.array)
  112:         return self
  113: 
  114:     def __mod__(self, other):
  115:         return self._rc(remainder(self.array, other))
  116: 
  117:     def __rmod__(self, other):
  118:         return self._rc(remainder(other, self.array))
  119: 
  120:     def __imod__(self, other):
  121:         remainder(self.array, other, self.array)
  122:         return self
  123: 
  124:     def __divmod__(self, other):
  125:         return (self._rc(divide(self.array, other)),
  126:                 self._rc(remainder(self.array, other)))
  127: 
  128:     def __rdivmod__(self, other):
  129:         return (self._rc(divide(other, self.array)),
  130:                 self._rc(remainder(other, self.array)))
  131: 
  132:     def __pow__(self, other):
  133:         return self._rc(power(self.array, asarray(other)))
  134: 
  135:     def __rpow__(self, other):
  136:         return self._rc(power(asarray(other), self.array))
  137: 
  138:     def __ipow__(self, other):
  139:         power(self.array, other, self.array)
  140:         return self
  141: 
  142:     def __lshift__(self, other):
  143:         return self._rc(left_shift(self.array, other))
  144: 
  145:     def __rshift__(self, other):
  146:         return self._rc(right_shift(self.array, other))
  147: 
  148:     def __rlshift__(self, other):
  149:         return self._rc(left_shift(other, self.array))
  150: 
  151:     def __rrshift__(self, other):
  152:         return self._rc(right_shift(other, self.array))
  153: 
  154:     def __ilshift__(self, other):
  155:         left_shift(self.array, other, self.array)
  156:         return self
  157: 
  158:     def __irshift__(self, other):
  159:         right_shift(self.array, other, self.array)
  160:         return self
  161: 
  162:     def __and__(self, other):
  163:         return self._rc(bitwise_and(self.array, other))
  164: 
  165:     def __rand__(self, other):
  166:         return self._rc(bitwise_and(other, self.array))
  167: 
  168:     def __iand__(self, other):
  169:         bitwise_and(self.array, other, self.array)
  170:         return self
  171: 
  172:     def __xor__(self, other):
  173:         return self._rc(bitwise_xor(self.array, other))
  174: 
  175:     def __rxor__(self, other):
  176:         return self._rc(bitwise_xor(other, self.array))
  177: 
  178:     def __ixor__(self, other):
  179:         bitwise_xor(self.array, other, self.array)
  180:         return self
  181: 
  182:     def __or__(self, other):
  183:         return self._rc(bitwise_or(self.array, other))
  184: 
  185:     def __ror__(self, other):
  186:         return self._rc(bitwise_or(other, self.array))
  187: 
  188:     def __ior__(self, other):
  189:         bitwise_or(self.array, other, self.array)
  190:         return self
  191: 
  192:     def __pos__(self):
  193:         return self._rc(self.array)
  194: 
  195:     def __invert__(self):
  196:         return self._rc(invert(self.array))
  197: 
  198:     def _scalarfunc(self, func):
  199:         if self.ndim == 0:
  200:             return func(self[0])
  201:         else:
  202:             raise TypeError(
  203:                 "only rank-0 arrays can be converted to Python scalars.")
  204: 
  205:     def __complex__(self):
  206:         return self._scalarfunc(complex)
  207: 
  208:     def __float__(self):
  209:         return self._scalarfunc(float)
  210: 
  211:     def __int__(self):
  212:         return self._scalarfunc(int)
  213: 
  214:     def __hex__(self):
  215:         return self._scalarfunc(hex)
  216: 
  217:     def __oct__(self):
  218:         return self._scalarfunc(oct)
  219: 
  220:     def __lt__(self, other):
  221:         return self._rc(less(self.array, other))
  222: 
  223:     def __le__(self, other):
  224:         return self._rc(less_equal(self.array, other))
  225: 
  226:     def __eq__(self, other):
  227:         return self._rc(equal(self.array, other))
  228: 
  229:     def __ne__(self, other):
  230:         return self._rc(not_equal(self.array, other))
  231: 
  232:     def __gt__(self, other):
  233:         return self._rc(greater(self.array, other))
  234: 
  235:     def __ge__(self, other):
  236:         return self._rc(greater_equal(self.array, other))
  237: 
  238:     def copy(self):
  239:         ""
  240:         return self._rc(self.array.copy())
  241: 
  242:     def tobytes(self):
  243:         ""
  244:         return self.array.tobytes()
  245: 
  246:     def byteswap(self):
  247:         ""
  248:         return self._rc(self.array.byteswap())
  249: 
  250:     def astype(self, typecode):
  251:         ""
  252:         return self._rc(self.array.astype(typecode))
  253: 
  254:     def _rc(self, a):
  255:         if len(shape(a)) == 0:
  256:             return a
  257:         else:
  258:             return self.__class__(a)
  259: 
  260:     def __array_wrap__(self, *args):
  261:         return self.__class__(args[0])
  262: 
  263:     def __setattr__(self, attr, value):
  264:         if attr == 'array':
  265:             object.__setattr__(self, attr, value)
  266:             return
  267:         try:
  268:             self.array.__setattr__(attr, value)
  269:         except AttributeError:
  270:             object.__setattr__(self, attr, value)
  271: 
  272:     # Only called after other approaches fail.
  273:     def __getattr__(self, attr):
  274:         if (attr == 'array'):
  275:             return object.__getattribute__(self, attr)
  276:         return self.array.__getattribute__(attr)
  277: 
  278: 
  279: #############################################################
  280: # Test of class container
  281: #############################################################
  282: if __name__ == '__main__':
  283:     temp = reshape(arange(10000), (100, 100))
  284: 
  285:     ua = container(temp)
  286:     # new object created begin test
  287:     print(dir(ua))
  288:     print(shape(ua), ua.shape)  # I have changed Numeric.py
  289: 
  290:     ua_small = ua[:3, :5]
  291:     print(ua_small)
  292:     # this did not change ua[0,0], which is not normal behavior
  293:     ua_small[0, 0] = 10
  294:     print(ua_small[0, 0], ua[0, 0])
  295:     print(sin(ua_small) / 3. * 6. + sqrt(ua_small ** 2))
  296:     print(less(ua_small, 103), type(less(ua_small, 103)))
  297:     print(type(ua_small * reshape(arange(15), shape(ua_small))))
  298:     print(reshape(ua_small, (5, 3)))
  299:     print(transpose(ua_small))
