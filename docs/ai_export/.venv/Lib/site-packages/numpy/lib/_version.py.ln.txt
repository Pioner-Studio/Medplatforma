    1: """Utility to compare (NumPy) version strings.
    2: 
    3: The NumpyVersion class allows properly comparing numpy version strings.
    4: The LooseVersion and StrictVersion classes that distutils provides don't
    5: work; they don't recognize anything like alpha/beta/rc/dev versions.
    6: 
    7: """
    8: import re
    9: 
   10: __all__ = ['NumpyVersion']
   11: 
   12: 
   13: class NumpyVersion:
   14:     """Parse and compare numpy version strings.
   15: 
   16:     NumPy has the following versioning scheme (numbers given are examples; they
   17:     can be > 9 in principle):
   18: 
   19:     - Released version: '1.8.0', '1.8.1', etc.
   20:     - Alpha: '1.8.0a1', '1.8.0a2', etc.
   21:     - Beta: '1.8.0b1', '1.8.0b2', etc.
   22:     - Release candidates: '1.8.0rc1', '1.8.0rc2', etc.
   23:     - Development versions: '1.8.0.dev-f1234afa' (git commit hash appended)
   24:     - Development versions after a1: '1.8.0a1.dev-f1234afa',
   25:                                      '1.8.0b2.dev-f1234afa',
   26:                                      '1.8.1rc1.dev-f1234afa', etc.
   27:     - Development versions (no git hash available): '1.8.0.dev-Unknown'
   28: 
   29:     Comparing needs to be done against a valid version string or other
   30:     `NumpyVersion` instance. Note that all development versions of the same
   31:     (pre-)release compare equal.
   32: 
   33:     Parameters
   34:     ----------
   35:     vstring : str
   36:         NumPy version string (``np.__version__``).
   37: 
   38:     Examples
   39:     --------
   40:     >>> from numpy.lib import NumpyVersion
   41:     >>> if NumpyVersion(np.__version__) < '1.7.0':
   42:     ...     print('skip')
   43:     >>> # skip
   44: 
   45:     >>> NumpyVersion('1.7')  # raises ValueError, add ".0"
   46:     Traceback (most recent call last):
   47:         ...
   48:     ValueError: Not a valid numpy version string
   49: 
   50:     """
   51: 
   52:     __module__ = "numpy.lib"
   53: 
   54:     def __init__(self, vstring):
   55:         self.vstring = vstring
   56:         ver_main = re.match(r'\d+\.\d+\.\d+', vstring)
   57:         if not ver_main:
   58:             raise ValueError("Not a valid numpy version string")
   59: 
   60:         self.version = ver_main.group()
   61:         self.major, self.minor, self.bugfix = [int(x) for x in
   62:             self.version.split('.')]
   63:         if len(vstring) == ver_main.end():
   64:             self.pre_release = 'final'
   65:         else:
   66:             alpha = re.match(r'a\d', vstring[ver_main.end():])
   67:             beta = re.match(r'b\d', vstring[ver_main.end():])
   68:             rc = re.match(r'rc\d', vstring[ver_main.end():])
   69:             pre_rel = [m for m in [alpha, beta, rc] if m is not None]
   70:             if pre_rel:
   71:                 self.pre_release = pre_rel[0].group()
   72:             else:
   73:                 self.pre_release = ''
   74: 
   75:         self.is_devversion = bool(re.search(r'.dev', vstring))
   76: 
   77:     def _compare_version(self, other):
   78:         """Compare major.minor.bugfix"""
   79:         if self.major == other.major:
   80:             if self.minor == other.minor:
   81:                 if self.bugfix == other.bugfix:
   82:                     vercmp = 0
   83:                 elif self.bugfix > other.bugfix:
   84:                     vercmp = 1
   85:                 else:
   86:                     vercmp = -1
   87:             elif self.minor > other.minor:
   88:                 vercmp = 1
   89:             else:
   90:                 vercmp = -1
   91:         elif self.major > other.major:
   92:             vercmp = 1
   93:         else:
   94:             vercmp = -1
   95: 
   96:         return vercmp
   97: 
   98:     def _compare_pre_release(self, other):
   99:         """Compare alpha/beta/rc/final."""
  100:         if self.pre_release == other.pre_release:
  101:             vercmp = 0
  102:         elif self.pre_release == 'final':
  103:             vercmp = 1
  104:         elif other.pre_release == 'final':
  105:             vercmp = -1
  106:         elif self.pre_release > other.pre_release:
  107:             vercmp = 1
  108:         else:
  109:             vercmp = -1
  110: 
  111:         return vercmp
  112: 
  113:     def _compare(self, other):
  114:         if not isinstance(other, (str, NumpyVersion)):
  115:             raise ValueError("Invalid object to compare with NumpyVersion.")
  116: 
  117:         if isinstance(other, str):
  118:             other = NumpyVersion(other)
  119: 
  120:         vercmp = self._compare_version(other)
  121:         if vercmp == 0:
  122:             # Same x.y.z version, check for alpha/beta/rc
  123:             vercmp = self._compare_pre_release(other)
  124:             if vercmp == 0:
  125:                 # Same version and same pre-release, check if dev version
  126:                 if self.is_devversion is other.is_devversion:
  127:                     vercmp = 0
  128:                 elif self.is_devversion:
  129:                     vercmp = -1
  130:                 else:
  131:                     vercmp = 1
  132: 
  133:         return vercmp
  134: 
  135:     def __lt__(self, other):
  136:         return self._compare(other) < 0
  137: 
  138:     def __le__(self, other):
  139:         return self._compare(other) <= 0
  140: 
  141:     def __eq__(self, other):
  142:         return self._compare(other) == 0
  143: 
  144:     def __ne__(self, other):
  145:         return self._compare(other) != 0
  146: 
  147:     def __gt__(self, other):
  148:         return self._compare(other) > 0
  149: 
  150:     def __ge__(self, other):
  151:         return self._compare(other) >= 0
  152: 
  153:     def __repr__(self):
  154:         return f"NumpyVersion({self.vstring})"
