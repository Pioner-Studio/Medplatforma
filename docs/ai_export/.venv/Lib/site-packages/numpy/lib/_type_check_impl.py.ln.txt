    1: """Automatically adapted for numpy Sep 19, 2005 by convertcode.py
    2: 
    3: """
    4: import functools
    5: 
    6: __all__ = ['iscomplexobj', 'isrealobj', 'imag', 'iscomplex',
    7:            'isreal', 'nan_to_num', 'real', 'real_if_close',
    8:            'typename', 'mintypecode',
    9:            'common_type']
   10: 
   11: import numpy._core.numeric as _nx
   12: from numpy._core import getlimits, overrides
   13: from numpy._core.numeric import asanyarray, asarray, isnan, zeros
   14: from numpy._utils import set_module
   15: 
   16: from ._ufunclike_impl import isneginf, isposinf
   17: 
   18: array_function_dispatch = functools.partial(
   19:     overrides.array_function_dispatch, module='numpy')
   20: 
   21: 
   22: _typecodes_by_elsize = 'GDFgdfQqLlIiHhBb?'
   23: 
   24: 
   25: @set_module('numpy')
   26: def mintypecode(typechars, typeset='GDFgdf', default='d'):
   27:     """
   28:     Return the character for the minimum-size type to which given types can
   29:     be safely cast.
   30: 
   31:     The returned type character must represent the smallest size dtype such
   32:     that an array of the returned type can handle the data from an array of
   33:     all types in `typechars` (or if `typechars` is an array, then its
   34:     dtype.char).
   35: 
   36:     Parameters
   37:     ----------
   38:     typechars : list of str or array_like
   39:         If a list of strings, each string should represent a dtype.
   40:         If array_like, the character representation of the array dtype is used.
   41:     typeset : str or list of str, optional
   42:         The set of characters that the returned character is chosen from.
   43:         The default set is 'GDFgdf'.
   44:     default : str, optional
   45:         The default character, this is returned if none of the characters in
   46:         `typechars` matches a character in `typeset`.
   47: 
   48:     Returns
   49:     -------
   50:     typechar : str
   51:         The character representing the minimum-size type that was found.
   52: 
   53:     See Also
   54:     --------
   55:     dtype
   56: 
   57:     Examples
   58:     --------
   59:     >>> import numpy as np
   60:     >>> np.mintypecode(['d', 'f', 'S'])
   61:     'd'
   62:     >>> x = np.array([1.1, 2-3.j])
   63:     >>> np.mintypecode(x)
   64:     'D'
   65: 
   66:     >>> np.mintypecode('abceh', default='G')
   67:     'G'
   68: 
   69:     """
   70:     typecodes = ((isinstance(t, str) and t) or asarray(t).dtype.char
   71:                  for t in typechars)
   72:     intersection = {t for t in typecodes if t in typeset}
   73:     if not intersection:
   74:         return default
   75:     if 'F' in intersection and 'd' in intersection:
   76:         return 'D'
   77:     return min(intersection, key=_typecodes_by_elsize.index)
   78: 
   79: 
   80: def _real_dispatcher(val):
   81:     return (val,)
   82: 
   83: 
   84: @array_function_dispatch(_real_dispatcher)
   85: def real(val):
   86:     """
   87:     Return the real part of the complex argument.
   88: 
   89:     Parameters
   90:     ----------
   91:     val : array_like
   92:         Input array.
   93: 
   94:     Returns
   95:     -------
   96:     out : ndarray or scalar
   97:         The real component of the complex argument. If `val` is real, the type
   98:         of `val` is used for the output.  If `val` has complex elements, the
   99:         returned type is float.
  100: 
  101:     See Also
  102:     --------
  103:     real_if_close, imag, angle
  104: 
  105:     Examples
  106:     --------
  107:     >>> import numpy as np
  108:     >>> a = np.array([1+2j, 3+4j, 5+6j])
  109:     >>> a.real
  110:     array([1.,  3.,  5.])
  111:     >>> a.real = 9
  112:     >>> a
  113:     array([9.+2.j,  9.+4.j,  9.+6.j])
  114:     >>> a.real = np.array([9, 8, 7])
  115:     >>> a
  116:     array([9.+2.j,  8.+4.j,  7.+6.j])
  117:     >>> np.real(1 + 1j)
  118:     1.0
  119: 
  120:     """
  121:     try:
  122:         return val.real
  123:     except AttributeError:
  124:         return asanyarray(val).real
  125: 
  126: 
  127: def _imag_dispatcher(val):
  128:     return (val,)
  129: 
  130: 
  131: @array_function_dispatch(_imag_dispatcher)
  132: def imag(val):
  133:     """
  134:     Return the imaginary part of the complex argument.
  135: 
  136:     Parameters
  137:     ----------
  138:     val : array_like
  139:         Input array.
  140: 
  141:     Returns
  142:     -------
  143:     out : ndarray or scalar
  144:         The imaginary component of the complex argument. If `val` is real,
  145:         the type of `val` is used for the output.  If `val` has complex
  146:         elements, the returned type is float.
  147: 
  148:     See Also
  149:     --------
  150:     real, angle, real_if_close
  151: 
  152:     Examples
  153:     --------
  154:     >>> import numpy as np
  155:     >>> a = np.array([1+2j, 3+4j, 5+6j])
  156:     >>> a.imag
  157:     array([2.,  4.,  6.])
  158:     >>> a.imag = np.array([8, 10, 12])
  159:     >>> a
  160:     array([1. +8.j,  3.+10.j,  5.+12.j])
  161:     >>> np.imag(1 + 1j)
  162:     1.0
  163: 
  164:     """
  165:     try:
  166:         return val.imag
  167:     except AttributeError:
  168:         return asanyarray(val).imag
  169: 
  170: 
  171: def _is_type_dispatcher(x):
  172:     return (x,)
  173: 
  174: 
  175: @array_function_dispatch(_is_type_dispatcher)
  176: def iscomplex(x):
  177:     """
  178:     Returns a bool array, where True if input element is complex.
  179: 
  180:     What is tested is whether the input has a non-zero imaginary part, not if
  181:     the input type is complex.
  182: 
  183:     Parameters
  184:     ----------
  185:     x : array_like
  186:         Input array.
  187: 
  188:     Returns
  189:     -------
  190:     out : ndarray of bools
  191:         Output array.
  192: 
  193:     See Also
  194:     --------
  195:     isreal
  196:     iscomplexobj : Return True if x is a complex type or an array of complex
  197:                    numbers.
  198: 
  199:     Examples
  200:     --------
  201:     >>> import numpy as np
  202:     >>> np.iscomplex([1+1j, 1+0j, 4.5, 3, 2, 2j])
  203:     array([ True, False, False, False, False,  True])
  204: 
  205:     """
  206:     ax = asanyarray(x)
  207:     if issubclass(ax.dtype.type, _nx.complexfloating):
  208:         return ax.imag != 0
  209:     res = zeros(ax.shape, bool)
  210:     return res[()]   # convert to scalar if needed
  211: 
  212: 
  213: @array_function_dispatch(_is_type_dispatcher)
  214: def isreal(x):
  215:     """
  216:     Returns a bool array, where True if input element is real.
  217: 
  218:     If element has complex type with zero imaginary part, the return value
  219:     for that element is True.
  220: 
  221:     Parameters
  222:     ----------
  223:     x : array_like
  224:         Input array.
  225: 
  226:     Returns
  227:     -------
  228:     out : ndarray, bool
  229:         Boolean array of same shape as `x`.
  230: 
  231:     Notes
  232:     -----
  233:     `isreal` may behave unexpectedly for string or object arrays (see examples)
  234: 
  235:     See Also
  236:     --------
  237:     iscomplex
  238:     isrealobj : Return True if x is not a complex type.
  239: 
  240:     Examples
  241:     --------
  242:     >>> import numpy as np
  243:     >>> a = np.array([1+1j, 1+0j, 4.5, 3, 2, 2j], dtype=complex)
  244:     >>> np.isreal(a)
  245:     array([False,  True,  True,  True,  True, False])
  246: 
  247:     The function does not work on string arrays.
  248: 
  249:     >>> a = np.array([2j, "a"], dtype="U")
  250:     >>> np.isreal(a)  # Warns about non-elementwise comparison
  251:     False
  252: 
  253:     Returns True for all elements in input array of ``dtype=object`` even if
  254:     any of the elements is complex.
  255: 
  256:     >>> a = np.array([1, "2", 3+4j], dtype=object)
  257:     >>> np.isreal(a)
  258:     array([ True,  True,  True])
  259: 
  260:     isreal should not be used with object arrays
  261: 
  262:     >>> a = np.array([1+2j, 2+1j], dtype=object)
  263:     >>> np.isreal(a)
  264:     array([ True,  True])
  265: 
  266:     """
  267:     return imag(x) == 0
  268: 
  269: 
  270: @array_function_dispatch(_is_type_dispatcher)
  271: def iscomplexobj(x):
  272:     """
  273:     Check for a complex type or an array of complex numbers.
  274: 
  275:     The type of the input is checked, not the value. Even if the input
  276:     has an imaginary part equal to zero, `iscomplexobj` evaluates to True.
  277: 
  278:     Parameters
  279:     ----------
  280:     x : any
  281:         The input can be of any type and shape.
  282: 
  283:     Returns
  284:     -------
  285:     iscomplexobj : bool
  286:         The return value, True if `x` is of a complex type or has at least
  287:         one complex element.
  288: 
  289:     See Also
  290:     --------
  291:     isrealobj, iscomplex
  292: 
  293:     Examples
  294:     --------
  295:     >>> import numpy as np
  296:     >>> np.iscomplexobj(1)
  297:     False
  298:     >>> np.iscomplexobj(1+0j)
  299:     True
  300:     >>> np.iscomplexobj([3, 1+0j, True])
  301:     True
  302: 
  303:     """
  304:     try:
  305:         dtype = x.dtype
  306:         type_ = dtype.type
  307:     except AttributeError:
  308:         type_ = asarray(x).dtype.type
  309:     return issubclass(type_, _nx.complexfloating)
  310: 
  311: 
  312: @array_function_dispatch(_is_type_dispatcher)
  313: def isrealobj(x):
  314:     """
  315:     Return True if x is a not complex type or an array of complex numbers.
  316: 
  317:     The type of the input is checked, not the value. So even if the input
  318:     has an imaginary part equal to zero, `isrealobj` evaluates to False
  319:     if the data type is complex.
  320: 
  321:     Parameters
  322:     ----------
  323:     x : any
  324:         The input can be of any type and shape.
  325: 
  326:     Returns
  327:     -------
  328:     y : bool
  329:         The return value, False if `x` is of a complex type.
  330: 
  331:     See Also
  332:     --------
  333:     iscomplexobj, isreal
  334: 
  335:     Notes
  336:     -----
  337:     The function is only meant for arrays with numerical values but it
  338:     accepts all other objects. Since it assumes array input, the return
  339:     value of other objects may be True.
  340: 
  341:     >>> np.isrealobj('A string')
  342:     True
  343:     >>> np.isrealobj(False)
  344:     True
  345:     >>> np.isrealobj(None)
  346:     True
  347: 
  348:     Examples
  349:     --------
  350:     >>> import numpy as np
  351:     >>> np.isrealobj(1)
  352:     True
  353:     >>> np.isrealobj(1+0j)
  354:     False
  355:     >>> np.isrealobj([3, 1+0j, True])
  356:     False
  357: 
  358:     """
  359:     return not iscomplexobj(x)
  360: 
  361: #-----------------------------------------------------------------------------
  362: 
  363: def _getmaxmin(t):
  364:     from numpy._core import getlimits
  365:     f = getlimits.finfo(t)
  366:     return f.max, f.min
  367: 
  368: 
  369: def _nan_to_num_dispatcher(x, copy=None, nan=None, posinf=None, neginf=None):
  370:     return (x,)
  371: 
  372: 
  373: @array_function_dispatch(_nan_to_num_dispatcher)
  374: def nan_to_num(x, copy=True, nan=0.0, posinf=None, neginf=None):
  375:     """
  376:     Replace NaN with zero and infinity with large finite numbers (default
  377:     behaviour) or with the numbers defined by the user using the `nan`,
  378:     `posinf` and/or `neginf` keywords.
  379: 
  380:     If `x` is inexact, NaN is replaced by zero or by the user defined value in
  381:     `nan` keyword, infinity is replaced by the largest finite floating point
  382:     values representable by ``x.dtype`` or by the user defined value in
  383:     `posinf` keyword and -infinity is replaced by the most negative finite
  384:     floating point values representable by ``x.dtype`` or by the user defined
  385:     value in `neginf` keyword.
  386: 
  387:     For complex dtypes, the above is applied to each of the real and
  388:     imaginary components of `x` separately.
  389: 
  390:     If `x` is not inexact, then no replacements are made.
  391: 
  392:     Parameters
  393:     ----------
  394:     x : scalar or array_like
  395:         Input data.
  396:     copy : bool, optional
  397:         Whether to create a copy of `x` (True) or to replace values
  398:         in-place (False). The in-place operation only occurs if
  399:         casting to an array does not require a copy.
  400:         Default is True.
  401:     nan : int, float, optional
  402:         Value to be used to fill NaN values. If no value is passed
  403:         then NaN values will be replaced with 0.0.
  404:     posinf : int, float, optional
  405:         Value to be used to fill positive infinity values. If no value is
  406:         passed then positive infinity values will be replaced with a very
  407:         large number.
  408:     neginf : int, float, optional
  409:         Value to be used to fill negative infinity values. If no value is
  410:         passed then negative infinity values will be replaced with a very
  411:         small (or negative) number.
  412: 
  413:     Returns
  414:     -------
  415:     out : ndarray
  416:         `x`, with the non-finite values replaced. If `copy` is False, this may
  417:         be `x` itself.
  418: 
  419:     See Also
  420:     --------
  421:     isinf : Shows which elements are positive or negative infinity.
  422:     isneginf : Shows which elements are negative infinity.
  423:     isposinf : Shows which elements are positive infinity.
  424:     isnan : Shows which elements are Not a Number (NaN).
  425:     isfinite : Shows which elements are finite (not NaN, not infinity)
  426: 
  427:     Notes
  428:     -----
  429:     NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
  430:     (IEEE 754). This means that Not a Number is not equivalent to infinity.
  431: 
  432:     Examples
  433:     --------
  434:     >>> import numpy as np
  435:     >>> np.nan_to_num(np.inf)
  436:     1.7976931348623157e+308
  437:     >>> np.nan_to_num(-np.inf)
  438:     -1.7976931348623157e+308
  439:     >>> np.nan_to_num(np.nan)
  440:     0.0
  441:     >>> x = np.array([np.inf, -np.inf, np.nan, -128, 128])
  442:     >>> np.nan_to_num(x)
  443:     array([ 1.79769313e+308, -1.79769313e+308,  0.00000000e+000, # may vary
  444:            -1.28000000e+002,  1.28000000e+002])
  445:     >>> np.nan_to_num(x, nan=-9999, posinf=33333333, neginf=33333333)
  446:     array([ 3.3333333e+07,  3.3333333e+07, -9.9990000e+03,
  447:            -1.2800000e+02,  1.2800000e+02])
  448:     >>> y = np.array([complex(np.inf, np.nan), np.nan, complex(np.nan, np.inf)])
  449:     array([  1.79769313e+308,  -1.79769313e+308,   0.00000000e+000, # may vary
  450:          -1.28000000e+002,   1.28000000e+002])
  451:     >>> np.nan_to_num(y)
  452:     array([  1.79769313e+308 +0.00000000e+000j, # may vary
  453:              0.00000000e+000 +0.00000000e+000j,
  454:              0.00000000e+000 +1.79769313e+308j])
  455:     >>> np.nan_to_num(y, nan=111111, posinf=222222)
  456:     array([222222.+111111.j, 111111.     +0.j, 111111.+222222.j])
  457:     """
  458:     x = _nx.array(x, subok=True, copy=copy)
  459:     xtype = x.dtype.type
  460: 
  461:     isscalar = (x.ndim == 0)
  462: 
  463:     if not issubclass(xtype, _nx.inexact):
  464:         return x[()] if isscalar else x
  465: 
  466:     iscomplex = issubclass(xtype, _nx.complexfloating)
  467: 
  468:     dest = (x.real, x.imag) if iscomplex else (x,)
  469:     maxf, minf = _getmaxmin(x.real.dtype)
  470:     if posinf is not None:
  471:         maxf = posinf
  472:     if neginf is not None:
  473:         minf = neginf
  474:     for d in dest:
  475:         idx_nan = isnan(d)
  476:         idx_posinf = isposinf(d)
  477:         idx_neginf = isneginf(d)
  478:         _nx.copyto(d, nan, where=idx_nan)
  479:         _nx.copyto(d, maxf, where=idx_posinf)
  480:         _nx.copyto(d, minf, where=idx_neginf)
  481:     return x[()] if isscalar else x
  482: 
  483: #-----------------------------------------------------------------------------
  484: 
  485: def _real_if_close_dispatcher(a, tol=None):
  486:     return (a,)
  487: 
  488: 
  489: @array_function_dispatch(_real_if_close_dispatcher)
  490: def real_if_close(a, tol=100):
  491:     """
  492:     If input is complex with all imaginary parts close to zero, return
  493:     real parts.
  494: 
  495:     "Close to zero" is defined as `tol` * (machine epsilon of the type for
  496:     `a`).
  497: 
  498:     Parameters
  499:     ----------
  500:     a : array_like
  501:         Input array.
  502:     tol : float
  503:         Tolerance in machine epsilons for the complex part of the elements
  504:         in the array. If the tolerance is <=1, then the absolute tolerance
  505:         is used.
  506: 
  507:     Returns
  508:     -------
  509:     out : ndarray
  510:         If `a` is real, the type of `a` is used for the output.  If `a`
  511:         has complex elements, the returned type is float.
  512: 
  513:     See Also
  514:     --------
  515:     real, imag, angle
  516: 
  517:     Notes
  518:     -----
  519:     Machine epsilon varies from machine to machine and between data types
  520:     but Python floats on most platforms have a machine epsilon equal to
  521:     2.2204460492503131e-16.  You can use 'np.finfo(float).eps' to print
  522:     out the machine epsilon for floats.
  523: 
  524:     Examples
  525:     --------
  526:     >>> import numpy as np
  527:     >>> np.finfo(float).eps
  528:     2.2204460492503131e-16 # may vary
  529: 
  530:     >>> np.real_if_close([2.1 + 4e-14j, 5.2 + 3e-15j], tol=1000)
  531:     array([2.1, 5.2])
  532:     >>> np.real_if_close([2.1 + 4e-13j, 5.2 + 3e-15j], tol=1000)
  533:     array([2.1+4.e-13j, 5.2 + 3e-15j])
  534: 
  535:     """
  536:     a = asanyarray(a)
  537:     type_ = a.dtype.type
  538:     if not issubclass(type_, _nx.complexfloating):
  539:         return a
  540:     if tol > 1:
  541:         f = getlimits.finfo(type_)
  542:         tol = f.eps * tol
  543:     if _nx.all(_nx.absolute(a.imag) < tol):
  544:         a = a.real
  545:     return a
  546: 
  547: 
  548: #-----------------------------------------------------------------------------
  549: 
  550: _namefromtype = {'S1': 'character',
  551:                  '?': 'bool',
  552:                  'b': 'signed char',
  553:                  'B': 'unsigned char',
  554:                  'h': 'short',
  555:                  'H': 'unsigned short',
  556:                  'i': 'integer',
  557:                  'I': 'unsigned integer',
  558:                  'l': 'long integer',
  559:                  'L': 'unsigned long integer',
  560:                  'q': 'long long integer',
  561:                  'Q': 'unsigned long long integer',
  562:                  'f': 'single precision',
  563:                  'd': 'double precision',
  564:                  'g': 'long precision',
  565:                  'F': 'complex single precision',
  566:                  'D': 'complex double precision',
  567:                  'G': 'complex long double precision',
  568:                  'S': 'string',
  569:                  'U': 'unicode',
  570:                  'V': 'void',
  571:                  'O': 'object'
  572:                  }
  573: 
  574: @set_module('numpy')
  575: def typename(char):
  576:     """
  577:     Return a description for the given data type code.
  578: 
  579:     Parameters
  580:     ----------
  581:     char : str
  582:         Data type code.
  583: 
  584:     Returns
  585:     -------
  586:     out : str
  587:         Description of the input data type code.
  588: 
  589:     See Also
  590:     --------
  591:     dtype
  592: 
  593:     Examples
  594:     --------
  595:     >>> import numpy as np
  596:     >>> typechars = ['S1', '?', 'B', 'D', 'G', 'F', 'I', 'H', 'L', 'O', 'Q',
  597:     ...              'S', 'U', 'V', 'b', 'd', 'g', 'f', 'i', 'h', 'l', 'q']
  598:     >>> for typechar in typechars:
  599:     ...     print(typechar, ' : ', np.typename(typechar))
  600:     ...
  601:     S1  :  character
  602:     ?  :  bool
  603:     B  :  unsigned char
  604:     D  :  complex double precision
  605:     G  :  complex long double precision
  606:     F  :  complex single precision
  607:     I  :  unsigned integer
  608:     H  :  unsigned short
  609:     L  :  unsigned long integer
  610:     O  :  object
  611:     Q  :  unsigned long long integer
  612:     S  :  string
  613:     U  :  unicode
  614:     V  :  void
  615:     b  :  signed char
  616:     d  :  double precision
  617:     g  :  long precision
  618:     f  :  single precision
  619:     i  :  integer
  620:     h  :  short
  621:     l  :  long integer
  622:     q  :  long long integer
  623: 
  624:     """
  625:     return _namefromtype[char]
  626: 
  627: #-----------------------------------------------------------------------------
  628: 
  629: 
  630: #determine the "minimum common type" for a group of arrays.
  631: array_type = [[_nx.float16, _nx.float32, _nx.float64, _nx.longdouble],
  632:               [None, _nx.complex64, _nx.complex128, _nx.clongdouble]]
  633: array_precision = {_nx.float16: 0,
  634:                    _nx.float32: 1,
  635:                    _nx.float64: 2,
  636:                    _nx.longdouble: 3,
  637:                    _nx.complex64: 1,
  638:                    _nx.complex128: 2,
  639:                    _nx.clongdouble: 3}
  640: 
  641: 
  642: def _common_type_dispatcher(*arrays):
  643:     return arrays
  644: 
  645: 
  646: @array_function_dispatch(_common_type_dispatcher)
  647: def common_type(*arrays):
  648:     """
  649:     Return a scalar type which is common to the input arrays.
  650: 
  651:     The return type will always be an inexact (i.e. floating point) scalar
  652:     type, even if all the arrays are integer arrays. If one of the inputs is
  653:     an integer array, the minimum precision type that is returned is a
  654:     64-bit floating point dtype.
  655: 
  656:     All input arrays except int64 and uint64 can be safely cast to the
  657:     returned dtype without loss of information.
  658: 
  659:     Parameters
  660:     ----------
  661:     array1, array2, ... : ndarrays
  662:         Input arrays.
  663: 
  664:     Returns
  665:     -------
  666:     out : data type code
  667:         Data type code.
  668: 
  669:     See Also
  670:     --------
  671:     dtype, mintypecode
  672: 
  673:     Examples
  674:     --------
  675:     >>> np.common_type(np.arange(2, dtype=np.float32))
  676:     <class 'numpy.float32'>
  677:     >>> np.common_type(np.arange(2, dtype=np.float32), np.arange(2))
  678:     <class 'numpy.float64'>
  679:     >>> np.common_type(np.arange(4), np.array([45, 6.j]), np.array([45.0]))
  680:     <class 'numpy.complex128'>
  681: 
  682:     """
  683:     is_complex = False
  684:     precision = 0
  685:     for a in arrays:
  686:         t = a.dtype.type
  687:         if iscomplexobj(a):
  688:             is_complex = True
  689:         if issubclass(t, _nx.integer):
  690:             p = 2  # array_precision[_nx.double]
  691:         else:
  692:             p = array_precision.get(t)
  693:             if p is None:
  694:                 raise TypeError("can't get common type for non-numeric array")
  695:         precision = max(precision, p)
  696:     if is_complex:
  697:         return array_type[1][precision]
  698:     else:
  699:         return array_type[0][precision]
