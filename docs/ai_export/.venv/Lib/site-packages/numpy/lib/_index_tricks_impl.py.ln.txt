    1: import functools
    2: import math
    3: import sys
    4: import warnings
    5: 
    6: import numpy as np
    7: import numpy._core.numeric as _nx
    8: import numpy.matrixlib as matrixlib
    9: from numpy._core import linspace, overrides
   10: from numpy._core.multiarray import ravel_multi_index, unravel_index
   11: from numpy._core.numeric import ScalarType, array
   12: from numpy._core.numerictypes import issubdtype
   13: from numpy._utils import set_module
   14: from numpy.lib._function_base_impl import diff
   15: from numpy.lib.stride_tricks import as_strided
   16: 
   17: array_function_dispatch = functools.partial(
   18:     overrides.array_function_dispatch, module='numpy')
   19: 
   20: 
   21: __all__ = [
   22:     'ravel_multi_index', 'unravel_index', 'mgrid', 'ogrid', 'r_', 'c_',
   23:     's_', 'index_exp', 'ix_', 'ndenumerate', 'ndindex', 'fill_diagonal',
   24:     'diag_indices', 'diag_indices_from'
   25: ]
   26: 
   27: 
   28: def _ix__dispatcher(*args):
   29:     return args
   30: 
   31: 
   32: @array_function_dispatch(_ix__dispatcher)
   33: def ix_(*args):
   34:     """
   35:     Construct an open mesh from multiple sequences.
   36: 
   37:     This function takes N 1-D sequences and returns N outputs with N
   38:     dimensions each, such that the shape is 1 in all but one dimension
   39:     and the dimension with the non-unit shape value cycles through all
   40:     N dimensions.
   41: 
   42:     Using `ix_` one can quickly construct index arrays that will index
   43:     the cross product. ``a[np.ix_([1,3],[2,5])]`` returns the array
   44:     ``[[a[1,2] a[1,5]], [a[3,2] a[3,5]]]``.
   45: 
   46:     Parameters
   47:     ----------
   48:     args : 1-D sequences
   49:         Each sequence should be of integer or boolean type.
   50:         Boolean sequences will be interpreted as boolean masks for the
   51:         corresponding dimension (equivalent to passing in
   52:         ``np.nonzero(boolean_sequence)``).
   53: 
   54:     Returns
   55:     -------
   56:     out : tuple of ndarrays
   57:         N arrays with N dimensions each, with N the number of input
   58:         sequences. Together these arrays form an open mesh.
   59: 
   60:     See Also
   61:     --------
   62:     ogrid, mgrid, meshgrid
   63: 
   64:     Examples
   65:     --------
   66:     >>> import numpy as np
   67:     >>> a = np.arange(10).reshape(2, 5)
   68:     >>> a
   69:     array([[0, 1, 2, 3, 4],
   70:            [5, 6, 7, 8, 9]])
   71:     >>> ixgrid = np.ix_([0, 1], [2, 4])
   72:     >>> ixgrid
   73:     (array([[0],
   74:            [1]]), array([[2, 4]]))
   75:     >>> ixgrid[0].shape, ixgrid[1].shape
   76:     ((2, 1), (1, 2))
   77:     >>> a[ixgrid]
   78:     array([[2, 4],
   79:            [7, 9]])
   80: 
   81:     >>> ixgrid = np.ix_([True, True], [2, 4])
   82:     >>> a[ixgrid]
   83:     array([[2, 4],
   84:            [7, 9]])
   85:     >>> ixgrid = np.ix_([True, True], [False, False, True, False, True])
   86:     >>> a[ixgrid]
   87:     array([[2, 4],
   88:            [7, 9]])
   89: 
   90:     """
   91:     out = []
   92:     nd = len(args)
   93:     for k, new in enumerate(args):
   94:         if not isinstance(new, _nx.ndarray):
   95:             new = np.asarray(new)
   96:             if new.size == 0:
   97:                 # Explicitly type empty arrays to avoid float default
   98:                 new = new.astype(_nx.intp)
   99:         if new.ndim != 1:
  100:             raise ValueError("Cross index must be 1 dimensional")
  101:         if issubdtype(new.dtype, _nx.bool):
  102:             new, = new.nonzero()
  103:         new = new.reshape((1,) * k + (new.size,) + (1,) * (nd - k - 1))
  104:         out.append(new)
  105:     return tuple(out)
  106: 
  107: 
  108: class nd_grid:
  109:     """
  110:     Construct a multi-dimensional "meshgrid".
  111: 
  112:     ``grid = nd_grid()`` creates an instance which will return a mesh-grid
  113:     when indexed.  The dimension and number of the output arrays are equal
  114:     to the number of indexing dimensions.  If the step length is not a
  115:     complex number, then the stop is not inclusive.
  116: 
  117:     However, if the step length is a **complex number** (e.g. 5j), then the
  118:     integer part of its magnitude is interpreted as specifying the
  119:     number of points to create between the start and stop values, where
  120:     the stop value **is inclusive**.
  121: 
  122:     If instantiated with an argument of ``sparse=True``, the mesh-grid is
  123:     open (or not fleshed out) so that only one-dimension of each returned
  124:     argument is greater than 1.
  125: 
  126:     Parameters
  127:     ----------
  128:     sparse : bool, optional
  129:         Whether the grid is sparse or not. Default is False.
  130: 
  131:     Notes
  132:     -----
  133:     Two instances of `nd_grid` are made available in the NumPy namespace,
  134:     `mgrid` and `ogrid`, approximately defined as::
  135: 
  136:         mgrid = nd_grid(sparse=False)
  137:         ogrid = nd_grid(sparse=True)
  138: 
  139:     Users should use these pre-defined instances instead of using `nd_grid`
  140:     directly.
  141:     """
  142:     __slots__ = ('sparse',)
  143: 
  144:     def __init__(self, sparse=False):
  145:         self.sparse = sparse
  146: 
  147:     def __getitem__(self, key):
  148:         try:
  149:             size = []
  150:             # Mimic the behavior of `np.arange` and use a data type
  151:             # which is at least as large as `np.int_`
  152:             num_list = [0]
  153:             for k in range(len(key)):
  154:                 step = key[k].step
  155:                 start = key[k].start
  156:                 stop = key[k].stop
  157:                 if start is None:
  158:                     start = 0
  159:                 if step is None:
  160:                     step = 1
  161:                 if isinstance(step, (_nx.complexfloating, complex)):
  162:                     step = abs(step)
  163:                     size.append(int(step))
  164:                 else:
  165:                     size.append(
  166:                         math.ceil((stop - start) / step))
  167:                 num_list += [start, stop, step]
  168:             typ = _nx.result_type(*num_list)
  169:             if self.sparse:
  170:                 nn = [_nx.arange(_x, dtype=_t)
  171:                       for _x, _t in zip(size, (typ,) * len(size))]
  172:             else:
  173:                 nn = _nx.indices(size, typ)
  174:             for k, kk in enumerate(key):
  175:                 step = kk.step
  176:                 start = kk.start
  177:                 if start is None:
  178:                     start = 0
  179:                 if step is None:
  180:                     step = 1
  181:                 if isinstance(step, (_nx.complexfloating, complex)):
  182:                     step = int(abs(step))
  183:                     if step != 1:
  184:                         step = (kk.stop - start) / float(step - 1)
  185:                 nn[k] = (nn[k] * step + start)
  186:             if self.sparse:
  187:                 slobj = [_nx.newaxis] * len(size)
  188:                 for k in range(len(size)):
  189:                     slobj[k] = slice(None, None)
  190:                     nn[k] = nn[k][tuple(slobj)]
  191:                     slobj[k] = _nx.newaxis
  192:                 return tuple(nn)  # ogrid -> tuple of arrays
  193:             return nn  # mgrid -> ndarray
  194:         except (IndexError, TypeError):
  195:             step = key.step
  196:             stop = key.stop
  197:             start = key.start
  198:             if start is None:
  199:                 start = 0
  200:             if isinstance(step, (_nx.complexfloating, complex)):
  201:                 # Prevent the (potential) creation of integer arrays
  202:                 step_float = abs(step)
  203:                 step = length = int(step_float)
  204:                 if step != 1:
  205:                     step = (key.stop - start) / float(step - 1)
  206:                 typ = _nx.result_type(start, stop, step_float)
  207:                 return _nx.arange(0, length, 1, dtype=typ) * step + start
  208:             else:
  209:                 return _nx.arange(start, stop, step)
  210: 
  211: 
  212: class MGridClass(nd_grid):
  213:     """
  214:     An instance which returns a dense multi-dimensional "meshgrid".
  215: 
  216:     An instance which returns a dense (or fleshed out) mesh-grid
  217:     when indexed, so that each returned argument has the same shape.
  218:     The dimensions and number of the output arrays are equal to the
  219:     number of indexing dimensions.  If the step length is not a complex
  220:     number, then the stop is not inclusive.
  221: 
  222:     However, if the step length is a **complex number** (e.g. 5j), then
  223:     the integer part of its magnitude is interpreted as specifying the
  224:     number of points to create between the start and stop values, where
  225:     the stop value **is inclusive**.
  226: 
  227:     Returns
  228:     -------
  229:     mesh-grid : ndarray
  230:         A single array, containing a set of `ndarray`\\ s all of the same
  231:         dimensions. stacked along the first axis.
  232: 
  233:     See Also
  234:     --------
  235:     ogrid : like `mgrid` but returns open (not fleshed out) mesh grids
  236:     meshgrid: return coordinate matrices from coordinate vectors
  237:     r_ : array concatenator
  238:     :ref:`how-to-partition`
  239: 
  240:     Examples
  241:     --------
  242:     >>> import numpy as np
  243:     >>> np.mgrid[0:5, 0:5]
  244:     array([[[0, 0, 0, 0, 0],
  245:             [1, 1, 1, 1, 1],
  246:             [2, 2, 2, 2, 2],
  247:             [3, 3, 3, 3, 3],
  248:             [4, 4, 4, 4, 4]],
  249:            [[0, 1, 2, 3, 4],
  250:             [0, 1, 2, 3, 4],
  251:             [0, 1, 2, 3, 4],
  252:             [0, 1, 2, 3, 4],
  253:             [0, 1, 2, 3, 4]]])
  254:     >>> np.mgrid[-1:1:5j]
  255:     array([-1. , -0.5,  0. ,  0.5,  1. ])
  256: 
  257:     >>> np.mgrid[0:4].shape
  258:     (4,)
  259:     >>> np.mgrid[0:4, 0:5].shape
  260:     (2, 4, 5)
  261:     >>> np.mgrid[0:4, 0:5, 0:6].shape
  262:     (3, 4, 5, 6)
  263: 
  264:     """
  265:     __slots__ = ()
  266: 
  267:     def __init__(self):
  268:         super().__init__(sparse=False)
  269: 
  270: 
  271: mgrid = MGridClass()
  272: 
  273: 
  274: class OGridClass(nd_grid):
  275:     """
  276:     An instance which returns an open multi-dimensional "meshgrid".
  277: 
  278:     An instance which returns an open (i.e. not fleshed out) mesh-grid
  279:     when indexed, so that only one dimension of each returned array is
  280:     greater than 1.  The dimension and number of the output arrays are
  281:     equal to the number of indexing dimensions.  If the step length is
  282:     not a complex number, then the stop is not inclusive.
  283: 
  284:     However, if the step length is a **complex number** (e.g. 5j), then
  285:     the integer part of its magnitude is interpreted as specifying the
  286:     number of points to create between the start and stop values, where
  287:     the stop value **is inclusive**.
  288: 
  289:     Returns
  290:     -------
  291:     mesh-grid : ndarray or tuple of ndarrays
  292:         If the input is a single slice, returns an array.
  293:         If the input is multiple slices, returns a tuple of arrays, with
  294:         only one dimension not equal to 1.
  295: 
  296:     See Also
  297:     --------
  298:     mgrid : like `ogrid` but returns dense (or fleshed out) mesh grids
  299:     meshgrid: return coordinate matrices from coordinate vectors
  300:     r_ : array concatenator
  301:     :ref:`how-to-partition`
  302: 
  303:     Examples
  304:     --------
  305:     >>> from numpy import ogrid
  306:     >>> ogrid[-1:1:5j]
  307:     array([-1. , -0.5,  0. ,  0.5,  1. ])
  308:     >>> ogrid[0:5, 0:5]
  309:     (array([[0],
  310:             [1],
  311:             [2],
  312:             [3],
  313:             [4]]),
  314:      array([[0, 1, 2, 3, 4]]))
  315: 
  316:     """
  317:     __slots__ = ()
  318: 
  319:     def __init__(self):
  320:         super().__init__(sparse=True)
  321: 
  322: 
  323: ogrid = OGridClass()
  324: 
  325: 
  326: class AxisConcatenator:
  327:     """
  328:     Translates slice objects to concatenation along an axis.
  329: 
  330:     For detailed documentation on usage, see `r_`.
  331:     """
  332:     __slots__ = ('axis', 'matrix', 'ndmin', 'trans1d')
  333: 
  334:     # allow ma.mr_ to override this
  335:     concatenate = staticmethod(_nx.concatenate)
  336:     makemat = staticmethod(matrixlib.matrix)
  337: 
  338:     def __init__(self, axis=0, matrix=False, ndmin=1, trans1d=-1):
  339:         self.axis = axis
  340:         self.matrix = matrix
  341:         self.trans1d = trans1d
  342:         self.ndmin = ndmin
  343: 
  344:     def __getitem__(self, key):
  345:         # handle matrix builder syntax
  346:         if isinstance(key, str):
  347:             frame = sys._getframe().f_back
  348:             mymat = matrixlib.bmat(key, frame.f_globals, frame.f_locals)
  349:             return mymat
  350: 
  351:         if not isinstance(key, tuple):
  352:             key = (key,)
  353: 
  354:         # copy attributes, since they can be overridden in the first argument
  355:         trans1d = self.trans1d
  356:         ndmin = self.ndmin
  357:         matrix = self.matrix
  358:         axis = self.axis
  359: 
  360:         objs = []
  361:         # dtypes or scalars for weak scalar handling in result_type
  362:         result_type_objs = []
  363: 
  364:         for k, item in enumerate(key):
  365:             scalar = False
  366:             if isinstance(item, slice):
  367:                 step = item.step
  368:                 start = item.start
  369:                 stop = item.stop
  370:                 if start is None:
  371:                     start = 0
  372:                 if step is None:
  373:                     step = 1
  374:                 if isinstance(step, (_nx.complexfloating, complex)):
  375:                     size = int(abs(step))
  376:                     newobj = linspace(start, stop, num=size)
  377:                 else:
  378:                     newobj = _nx.arange(start, stop, step)
  379:                 if ndmin > 1:
  380:                     newobj = array(newobj, copy=None, ndmin=ndmin)
  381:                     if trans1d != -1:
  382:                         newobj = newobj.swapaxes(-1, trans1d)
  383:             elif isinstance(item, str):
  384:                 if k != 0:
  385:                     raise ValueError("special directives must be the "
  386:                                      "first entry.")
  387:                 if item in ('r', 'c'):
  388:                     matrix = True
  389:                     col = (item == 'c')
  390:                     continue
  391:                 if ',' in item:
  392:                     vec = item.split(',')
  393:                     try:
  394:                         axis, ndmin = [int(x) for x in vec[:2]]
  395:                         if len(vec) == 3:
  396:                             trans1d = int(vec[2])
  397:                         continue
  398:                     except Exception as e:
  399:                         raise ValueError(
  400:                             f"unknown special directive {item!r}"
  401:                         ) from e
  402:                 try:
  403:                     axis = int(item)
  404:                     continue
  405:                 except (ValueError, TypeError) as e:
  406:                     raise ValueError("unknown special directive") from e
  407:             elif type(item) in ScalarType:
  408:                 scalar = True
  409:                 newobj = item
  410:             else:
  411:                 item_ndim = np.ndim(item)
  412:                 newobj = array(item, copy=None, subok=True, ndmin=ndmin)
  413:                 if trans1d != -1 and item_ndim < ndmin:
  414:                     k2 = ndmin - item_ndim
  415:                     k1 = trans1d
  416:                     if k1 < 0:
  417:                         k1 += k2 + 1
  418:                     defaxes = list(range(ndmin))
  419:                     axes = defaxes[:k1] + defaxes[k2:] + defaxes[k1:k2]
  420:                     newobj = newobj.transpose(axes)
  421: 
  422:             objs.append(newobj)
  423:             if scalar:
  424:                 result_type_objs.append(item)
  425:             else:
  426:                 result_type_objs.append(newobj.dtype)
  427: 
  428:         # Ensure that scalars won't up-cast unless warranted, for 0, drops
  429:         # through to error in concatenate.
  430:         if len(result_type_objs) != 0:
  431:             final_dtype = _nx.result_type(*result_type_objs)
  432:             # concatenate could do cast, but that can be overridden:
  433:             objs = [array(obj, copy=None, subok=True,
  434:                           ndmin=ndmin, dtype=final_dtype) for obj in objs]
  435: 
  436:         res = self.concatenate(tuple(objs), axis=axis)
  437: 
  438:         if matrix:
  439:             oldndim = res.ndim
  440:             res = self.makemat(res)
  441:             if oldndim == 1 and col:
  442:                 res = res.T
  443:         return res
  444: 
  445:     def __len__(self):
  446:         return 0
  447: 
  448: # separate classes are used here instead of just making r_ = concatenator(0),
  449: # etc. because otherwise we couldn't get the doc string to come out right
  450: # in help(r_)
  451: 
  452: 
  453: class RClass(AxisConcatenator):
  454:     """
  455:     Translates slice objects to concatenation along the first axis.
  456: 
  457:     This is a simple way to build up arrays quickly. There are two use cases.
  458: 
  459:     1. If the index expression contains comma separated arrays, then stack
  460:        them along their first axis.
  461:     2. If the index expression contains slice notation or scalars then create
  462:        a 1-D array with a range indicated by the slice notation.
  463: 
  464:     If slice notation is used, the syntax ``start:stop:step`` is equivalent
  465:     to ``np.arange(start, stop, step)`` inside of the brackets. However, if
  466:     ``step`` is an imaginary number (i.e. 100j) then its integer portion is
  467:     interpreted as a number-of-points desired and the start and stop are
  468:     inclusive. In other words ``start:stop:stepj`` is interpreted as
  469:     ``np.linspace(start, stop, step, endpoint=1)`` inside of the brackets.
  470:     After expansion of slice notation, all comma separated sequences are
  471:     concatenated together.
  472: 
  473:     Optional character strings placed as the first element of the index
  474:     expression can be used to change the output. The strings 'r' or 'c' result
  475:     in matrix output. If the result is 1-D and 'r' is specified a 1 x N (row)
  476:     matrix is produced. If the result is 1-D and 'c' is specified, then a N x 1
  477:     (column) matrix is produced. If the result is 2-D then both provide the
  478:     same matrix result.
  479: 
  480:     A string integer specifies which axis to stack multiple comma separated
  481:     arrays along. A string of two comma-separated integers allows indication
  482:     of the minimum number of dimensions to force each entry into as the
  483:     second integer (the axis to concatenate along is still the first integer).
  484: 
  485:     A string with three comma-separated integers allows specification of the
  486:     axis to concatenate along, the minimum number of dimensions to force the
  487:     entries to, and which axis should contain the start of the arrays which
  488:     are less than the specified number of dimensions. In other words the third
  489:     integer allows you to specify where the 1's should be placed in the shape
  490:     of the arrays that have their shapes upgraded. By default, they are placed
  491:     in the front of the shape tuple. The third argument allows you to specify
  492:     where the start of the array should be instead. Thus, a third argument of
  493:     '0' would place the 1's at the end of the array shape. Negative integers
  494:     specify where in the new shape tuple the last dimension of upgraded arrays
  495:     should be placed, so the default is '-1'.
  496: 
  497:     Parameters
  498:     ----------
  499:     Not a function, so takes no parameters
  500: 
  501: 
  502:     Returns
  503:     -------
  504:     A concatenated ndarray or matrix.
  505: 
  506:     See Also
  507:     --------
  508:     concatenate : Join a sequence of arrays along an existing axis.
  509:     c_ : Translates slice objects to concatenation along the second axis.
  510: 
  511:     Examples
  512:     --------
  513:     >>> import numpy as np
  514:     >>> np.r_[np.array([1,2,3]), 0, 0, np.array([4,5,6])]
  515:     array([1, 2, 3, ..., 4, 5, 6])
  516:     >>> np.r_[-1:1:6j, [0]*3, 5, 6]
  517:     array([-1. , -0.6, -0.2,  0.2,  0.6,  1. ,  0. ,  0. ,  0. ,  5. ,  6. ])
  518: 
  519:     String integers specify the axis to concatenate along or the minimum
  520:     number of dimensions to force entries into.
  521: 
  522:     >>> a = np.array([[0, 1, 2], [3, 4, 5]])
  523:     >>> np.r_['-1', a, a] # concatenate along last axis
  524:     array([[0, 1, 2, 0, 1, 2],
  525:            [3, 4, 5, 3, 4, 5]])
  526:     >>> np.r_['0,2', [1,2,3], [4,5,6]] # concatenate along first axis, dim>=2
  527:     array([[1, 2, 3],
  528:            [4, 5, 6]])
  529: 
  530:     >>> np.r_['0,2,0', [1,2,3], [4,5,6]]
  531:     array([[1],
  532:            [2],
  533:            [3],
  534:            [4],
  535:            [5],
  536:            [6]])
  537:     >>> np.r_['1,2,0', [1,2,3], [4,5,6]]
  538:     array([[1, 4],
  539:            [2, 5],
  540:            [3, 6]])
  541: 
  542:     Using 'r' or 'c' as a first string argument creates a matrix.
  543: 
  544:     >>> np.r_['r',[1,2,3], [4,5,6]]
  545:     matrix([[1, 2, 3, 4, 5, 6]])
  546: 
  547:     """
  548:     __slots__ = ()
  549: 
  550:     def __init__(self):
  551:         AxisConcatenator.__init__(self, 0)
  552: 
  553: 
  554: r_ = RClass()
  555: 
  556: 
  557: class CClass(AxisConcatenator):
  558:     """
  559:     Translates slice objects to concatenation along the second axis.
  560: 
  561:     This is short-hand for ``np.r_['-1,2,0', index expression]``, which is
  562:     useful because of its common occurrence. In particular, arrays will be
  563:     stacked along their last axis after being upgraded to at least 2-D with
  564:     1's post-pended to the shape (column vectors made out of 1-D arrays).
  565: 
  566:     See Also
  567:     --------
  568:     column_stack : Stack 1-D arrays as columns into a 2-D array.
  569:     r_ : For more detailed documentation.
  570: 
  571:     Examples
  572:     --------
  573:     >>> import numpy as np
  574:     >>> np.c_[np.array([1,2,3]), np.array([4,5,6])]
  575:     array([[1, 4],
  576:            [2, 5],
  577:            [3, 6]])
  578:     >>> np.c_[np.array([[1,2,3]]), 0, 0, np.array([[4,5,6]])]
  579:     array([[1, 2, 3, ..., 4, 5, 6]])
  580: 
  581:     """
  582:     __slots__ = ()
  583: 
  584:     def __init__(self):
  585:         AxisConcatenator.__init__(self, -1, ndmin=2, trans1d=0)
  586: 
  587: 
  588: c_ = CClass()
  589: 
  590: 
  591: @set_module('numpy')
  592: class ndenumerate:
  593:     """
  594:     Multidimensional index iterator.
  595: 
  596:     Return an iterator yielding pairs of array coordinates and values.
  597: 
  598:     Parameters
  599:     ----------
  600:     arr : ndarray
  601:       Input array.
  602: 
  603:     See Also
  604:     --------
  605:     ndindex, flatiter
  606: 
  607:     Examples
  608:     --------
  609:     >>> import numpy as np
  610:     >>> a = np.array([[1, 2], [3, 4]])
  611:     >>> for index, x in np.ndenumerate(a):
  612:     ...     print(index, x)
  613:     (0, 0) 1
  614:     (0, 1) 2
  615:     (1, 0) 3
  616:     (1, 1) 4
  617: 
  618:     """
  619: 
  620:     def __init__(self, arr):
  621:         self.iter = np.asarray(arr).flat
  622: 
  623:     def __next__(self):
  624:         """
  625:         Standard iterator method, returns the index tuple and array value.
  626: 
  627:         Returns
  628:         -------
  629:         coords : tuple of ints
  630:             The indices of the current iteration.
  631:         val : scalar
  632:             The array element of the current iteration.
  633: 
  634:         """
  635:         return self.iter.coords, next(self.iter)
  636: 
  637:     def __iter__(self):
  638:         return self
  639: 
  640: 
  641: @set_module('numpy')
  642: class ndindex:
  643:     """
  644:     An N-dimensional iterator object to index arrays.
  645: 
  646:     Given the shape of an array, an `ndindex` instance iterates over
  647:     the N-dimensional index of the array. At each iteration a tuple
  648:     of indices is returned, the last dimension is iterated over first.
  649: 
  650:     Parameters
  651:     ----------
  652:     shape : ints, or a single tuple of ints
  653:         The size of each dimension of the array can be passed as
  654:         individual parameters or as the elements of a tuple.
  655: 
  656:     See Also
  657:     --------
  658:     ndenumerate, flatiter
  659: 
  660:     Examples
  661:     --------
  662:     >>> import numpy as np
  663: 
  664:     Dimensions as individual arguments
  665: 
  666:     >>> for index in np.ndindex(3, 2, 1):
  667:     ...     print(index)
  668:     (0, 0, 0)
  669:     (0, 1, 0)
  670:     (1, 0, 0)
  671:     (1, 1, 0)
  672:     (2, 0, 0)
  673:     (2, 1, 0)
  674: 
  675:     Same dimensions - but in a tuple ``(3, 2, 1)``
  676: 
  677:     >>> for index in np.ndindex((3, 2, 1)):
  678:     ...     print(index)
  679:     (0, 0, 0)
  680:     (0, 1, 0)
  681:     (1, 0, 0)
  682:     (1, 1, 0)
  683:     (2, 0, 0)
  684:     (2, 1, 0)
  685: 
  686:     """
  687: 
  688:     def __init__(self, *shape):
  689:         if len(shape) == 1 and isinstance(shape[0], tuple):
  690:             shape = shape[0]
  691:         x = as_strided(_nx.zeros(1), shape=shape,
  692:                        strides=_nx.zeros_like(shape))
  693:         self._it = _nx.nditer(x, flags=['multi_index', 'zerosize_ok'],
  694:                               order='C')
  695: 
  696:     def __iter__(self):
  697:         return self
  698: 
  699:     def ndincr(self):
  700:         """
  701:         Increment the multi-dimensional index by one.
  702: 
  703:         This method is for backward compatibility only: do not use.
  704: 
  705:         .. deprecated:: 1.20.0
  706:             This method has been advised against since numpy 1.8.0, but only
  707:             started emitting DeprecationWarning as of this version.
  708:         """
  709:         # NumPy 1.20.0, 2020-09-08
  710:         warnings.warn(
  711:             "`ndindex.ndincr()` is deprecated, use `next(ndindex)` instead",
  712:             DeprecationWarning, stacklevel=2)
  713:         next(self)
  714: 
  715:     def __next__(self):
  716:         """
  717:         Standard iterator method, updates the index and returns the index
  718:         tuple.
  719: 
  720:         Returns
  721:         -------
  722:         val : tuple of ints
  723:             Returns a tuple containing the indices of the current
  724:             iteration.
  725: 
  726:         """
  727:         next(self._it)
  728:         return self._it.multi_index
  729: 
  730: 
  731: # You can do all this with slice() plus a few special objects,
  732: # but there's a lot to remember. This version is simpler because
  733: # it uses the standard array indexing syntax.
  734: #
  735: # Written by Konrad Hinsen <hinsen@cnrs-orleans.fr>
  736: # last revision: 1999-7-23
  737: #
  738: # Cosmetic changes by T. Oliphant 2001
  739: #
  740: #
  741: 
  742: class IndexExpression:
  743:     """
  744:     A nicer way to build up index tuples for arrays.
  745: 
  746:     .. note::
  747:        Use one of the two predefined instances ``index_exp`` or `s_`
  748:        rather than directly using `IndexExpression`.
  749: 
  750:     For any index combination, including slicing and axis insertion,
  751:     ``a[indices]`` is the same as ``a[np.index_exp[indices]]`` for any
  752:     array `a`. However, ``np.index_exp[indices]`` can be used anywhere
  753:     in Python code and returns a tuple of slice objects that can be
  754:     used in the construction of complex index expressions.
  755: 
  756:     Parameters
  757:     ----------
  758:     maketuple : bool
  759:         If True, always returns a tuple.
  760: 
  761:     See Also
  762:     --------
  763:     s_ : Predefined instance without tuple conversion:
  764:        `s_ = IndexExpression(maketuple=False)`.
  765:        The ``index_exp`` is another predefined instance that
  766:        always returns a tuple:
  767:        `index_exp = IndexExpression(maketuple=True)`.
  768: 
  769:     Notes
  770:     -----
  771:     You can do all this with :class:`slice` plus a few special objects,
  772:     but there's a lot to remember and this version is simpler because
  773:     it uses the standard array indexing syntax.
  774: 
  775:     Examples
  776:     --------
  777:     >>> import numpy as np
  778:     >>> np.s_[2::2]
  779:     slice(2, None, 2)
  780:     >>> np.index_exp[2::2]
  781:     (slice(2, None, 2),)
  782: 
  783:     >>> np.array([0, 1, 2, 3, 4])[np.s_[2::2]]
  784:     array([2, 4])
  785: 
  786:     """
  787:     __slots__ = ('maketuple',)
  788: 
  789:     def __init__(self, maketuple):
  790:         self.maketuple = maketuple
  791: 
  792:     def __getitem__(self, item):
  793:         if self.maketuple and not isinstance(item, tuple):
  794:             return (item,)
  795:         else:
  796:             return item
  797: 
  798: 
  799: index_exp = IndexExpression(maketuple=True)
  800: s_ = IndexExpression(maketuple=False)
  801: 
  802: # End contribution from Konrad.
  803: 
  804: 
  805: # The following functions complement those in twodim_base, but are
  806: # applicable to N-dimensions.
  807: 
  808: 
  809: def _fill_diagonal_dispatcher(a, val, wrap=None):
  810:     return (a,)
  811: 
  812: 
  813: @array_function_dispatch(_fill_diagonal_dispatcher)
  814: def fill_diagonal(a, val, wrap=False):
  815:     """Fill the main diagonal of the given array of any dimensionality.
  816: 
  817:     For an array `a` with ``a.ndim >= 2``, the diagonal is the list of
  818:     values ``a[i, ..., i]`` with indices ``i`` all identical.  This function
  819:     modifies the input array in-place without returning a value.
  820: 
  821:     Parameters
  822:     ----------
  823:     a : array, at least 2-D.
  824:       Array whose diagonal is to be filled in-place.
  825:     val : scalar or array_like
  826:       Value(s) to write on the diagonal. If `val` is scalar, the value is
  827:       written along the diagonal. If array-like, the flattened `val` is
  828:       written along the diagonal, repeating if necessary to fill all
  829:       diagonal entries.
  830: 
  831:     wrap : bool
  832:       For tall matrices in NumPy version up to 1.6.2, the
  833:       diagonal "wrapped" after N columns. You can have this behavior
  834:       with this option. This affects only tall matrices.
  835: 
  836:     See also
  837:     --------
  838:     diag_indices, diag_indices_from
  839: 
  840:     Notes
  841:     -----
  842:     This functionality can be obtained via `diag_indices`, but internally
  843:     this version uses a much faster implementation that never constructs the
  844:     indices and uses simple slicing.
  845: 
  846:     Examples
  847:     --------
  848:     >>> import numpy as np
  849:     >>> a = np.zeros((3, 3), int)
  850:     >>> np.fill_diagonal(a, 5)
  851:     >>> a
  852:     array([[5, 0, 0],
  853:            [0, 5, 0],
  854:            [0, 0, 5]])
  855: 
  856:     The same function can operate on a 4-D array:
  857: 
  858:     >>> a = np.zeros((3, 3, 3, 3), int)
  859:     >>> np.fill_diagonal(a, 4)
  860: 
  861:     We only show a few blocks for clarity:
  862: 
  863:     >>> a[0, 0]
  864:     array([[4, 0, 0],
  865:            [0, 0, 0],
  866:            [0, 0, 0]])
  867:     >>> a[1, 1]
  868:     array([[0, 0, 0],
  869:            [0, 4, 0],
  870:            [0, 0, 0]])
  871:     >>> a[2, 2]
  872:     array([[0, 0, 0],
  873:            [0, 0, 0],
  874:            [0, 0, 4]])
  875: 
  876:     The wrap option affects only tall matrices:
  877: 
  878:     >>> # tall matrices no wrap
  879:     >>> a = np.zeros((5, 3), int)
  880:     >>> np.fill_diagonal(a, 4)
  881:     >>> a
  882:     array([[4, 0, 0],
  883:            [0, 4, 0],
  884:            [0, 0, 4],
  885:            [0, 0, 0],
  886:            [0, 0, 0]])
  887: 
  888:     >>> # tall matrices wrap
  889:     >>> a = np.zeros((5, 3), int)
  890:     >>> np.fill_diagonal(a, 4, wrap=True)
  891:     >>> a
  892:     array([[4, 0, 0],
  893:            [0, 4, 0],
  894:            [0, 0, 4],
  895:            [0, 0, 0],
  896:            [4, 0, 0]])
  897: 
  898:     >>> # wide matrices
  899:     >>> a = np.zeros((3, 5), int)
  900:     >>> np.fill_diagonal(a, 4, wrap=True)
  901:     >>> a
  902:     array([[4, 0, 0, 0, 0],
  903:            [0, 4, 0, 0, 0],
  904:            [0, 0, 4, 0, 0]])
  905: 
  906:     The anti-diagonal can be filled by reversing the order of elements
  907:     using either `numpy.flipud` or `numpy.fliplr`.
  908: 
  909:     >>> a = np.zeros((3, 3), int);
  910:     >>> np.fill_diagonal(np.fliplr(a), [1,2,3])  # Horizontal flip
  911:     >>> a
  912:     array([[0, 0, 1],
  913:            [0, 2, 0],
  914:            [3, 0, 0]])
  915:     >>> np.fill_diagonal(np.flipud(a), [1,2,3])  # Vertical flip
  916:     >>> a
  917:     array([[0, 0, 3],
  918:            [0, 2, 0],
  919:            [1, 0, 0]])
  920: 
  921:     Note that the order in which the diagonal is filled varies depending
  922:     on the flip function.
  923:     """
  924:     if a.ndim < 2:
  925:         raise ValueError("array must be at least 2-d")
  926:     end = None
  927:     if a.ndim == 2:
  928:         # Explicit, fast formula for the common case.  For 2-d arrays, we
  929:         # accept rectangular ones.
  930:         step = a.shape[1] + 1
  931:         # This is needed to don't have tall matrix have the diagonal wrap.
  932:         if not wrap:
  933:             end = a.shape[1] * a.shape[1]
  934:     else:
  935:         # For more than d=2, the strided formula is only valid for arrays with
  936:         # all dimensions equal, so we check first.
  937:         if not np.all(diff(a.shape) == 0):
  938:             raise ValueError("All dimensions of input must be of equal length")
  939:         step = 1 + (np.cumprod(a.shape[:-1])).sum()
  940: 
  941:     # Write the value out into the diagonal.
  942:     a.flat[:end:step] = val
  943: 
  944: 
  945: @set_module('numpy')
  946: def diag_indices(n, ndim=2):
  947:     """
  948:     Return the indices to access the main diagonal of an array.
  949: 
  950:     This returns a tuple of indices that can be used to access the main
  951:     diagonal of an array `a` with ``a.ndim >= 2`` dimensions and shape
  952:     (n, n, ..., n). For ``a.ndim = 2`` this is the usual diagonal, for
  953:     ``a.ndim > 2`` this is the set of indices to access ``a[i, i, ..., i]``
  954:     for ``i = [0..n-1]``.
  955: 
  956:     Parameters
  957:     ----------
  958:     n : int
  959:       The size, along each dimension, of the arrays for which the returned
  960:       indices can be used.
  961: 
  962:     ndim : int, optional
  963:       The number of dimensions.
  964: 
  965:     See Also
  966:     --------
  967:     diag_indices_from
  968: 
  969:     Examples
  970:     --------
  971:     >>> import numpy as np
  972: 
  973:     Create a set of indices to access the diagonal of a (4, 4) array:
  974: 
  975:     >>> di = np.diag_indices(4)
  976:     >>> di
  977:     (array([0, 1, 2, 3]), array([0, 1, 2, 3]))
  978:     >>> a = np.arange(16).reshape(4, 4)
  979:     >>> a
  980:     array([[ 0,  1,  2,  3],
  981:            [ 4,  5,  6,  7],
  982:            [ 8,  9, 10, 11],
  983:            [12, 13, 14, 15]])
  984:     >>> a[di] = 100
  985:     >>> a
  986:     array([[100,   1,   2,   3],
  987:            [  4, 100,   6,   7],
  988:            [  8,   9, 100,  11],
  989:            [ 12,  13,  14, 100]])
  990: 
  991:     Now, we create indices to manipulate a 3-D array:
  992: 
  993:     >>> d3 = np.diag_indices(2, 3)
  994:     >>> d3
  995:     (array([0, 1]), array([0, 1]), array([0, 1]))
  996: 
  997:     And use it to set the diagonal of an array of zeros to 1:
  998: 
  999:     >>> a = np.zeros((2, 2, 2), dtype=int)
 1000:     >>> a[d3] = 1
 1001:     >>> a
 1002:     array([[[1, 0],
 1003:             [0, 0]],
 1004:            [[0, 0],
 1005:             [0, 1]]])
 1006: 
 1007:     """
 1008:     idx = np.arange(n)
 1009:     return (idx,) * ndim
 1010: 
 1011: 
 1012: def _diag_indices_from(arr):
 1013:     return (arr,)
 1014: 
 1015: 
 1016: @array_function_dispatch(_diag_indices_from)
 1017: def diag_indices_from(arr):
 1018:     """
 1019:     Return the indices to access the main diagonal of an n-dimensional array.
 1020: 
 1021:     See `diag_indices` for full details.
 1022: 
 1023:     Parameters
 1024:     ----------
 1025:     arr : array, at least 2-D
 1026: 
 1027:     See Also
 1028:     --------
 1029:     diag_indices
 1030: 
 1031:     Examples
 1032:     --------
 1033:     >>> import numpy as np
 1034: 
 1035:     Create a 4 by 4 array.
 1036: 
 1037:     >>> a = np.arange(16).reshape(4, 4)
 1038:     >>> a
 1039:     array([[ 0,  1,  2,  3],
 1040:            [ 4,  5,  6,  7],
 1041:            [ 8,  9, 10, 11],
 1042:            [12, 13, 14, 15]])
 1043: 
 1044:     Get the indices of the diagonal elements.
 1045: 
 1046:     >>> di = np.diag_indices_from(a)
 1047:     >>> di
 1048:     (array([0, 1, 2, 3]), array([0, 1, 2, 3]))
 1049: 
 1050:     >>> a[di]
 1051:     array([ 0,  5, 10, 15])
 1052: 
 1053:     This is simply syntactic sugar for diag_indices.
 1054: 
 1055:     >>> np.diag_indices(a.shape[0])
 1056:     (array([0, 1, 2, 3]), array([0, 1, 2, 3]))
 1057: 
 1058:     """
 1059: 
 1060:     if not arr.ndim >= 2:
 1061:         raise ValueError("input array must be at least 2-d")
 1062:     # For more than d=2, the strided formula is only valid for arrays with
 1063:     # all dimensions equal, so we check first.
 1064:     if not np.all(diff(arr.shape) == 0):
 1065:         raise ValueError("All dimensions of input must be of equal length")
 1066: 
 1067:     return diag_indices(arr.shape[0], arr.ndim)
