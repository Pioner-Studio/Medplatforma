    1: """
    2: The arraypad module contains a group of functions to pad values onto the edges
    3: of an n-dimensional array.
    4: 
    5: """
    6: import numpy as np
    7: from numpy._core.overrides import array_function_dispatch
    8: from numpy.lib._index_tricks_impl import ndindex
    9: 
   10: __all__ = ['pad']
   11: 
   12: 
   13: ###############################################################################
   14: # Private utility functions.
   15: 
   16: 
   17: def _round_if_needed(arr, dtype):
   18:     """
   19:     Rounds arr inplace if destination dtype is integer.
   20: 
   21:     Parameters
   22:     ----------
   23:     arr : ndarray
   24:         Input array.
   25:     dtype : dtype
   26:         The dtype of the destination array.
   27:     """
   28:     if np.issubdtype(dtype, np.integer):
   29:         arr.round(out=arr)
   30: 
   31: 
   32: def _slice_at_axis(sl, axis):
   33:     """
   34:     Construct tuple of slices to slice an array in the given dimension.
   35: 
   36:     Parameters
   37:     ----------
   38:     sl : slice
   39:         The slice for the given dimension.
   40:     axis : int
   41:         The axis to which `sl` is applied. All other dimensions are left
   42:         "unsliced".
   43: 
   44:     Returns
   45:     -------
   46:     sl : tuple of slices
   47:         A tuple with slices matching `shape` in length.
   48: 
   49:     Examples
   50:     --------
   51:     >>> np._slice_at_axis(slice(None, 3, -1), 1)
   52:     (slice(None, None, None), slice(None, 3, -1), (...,))
   53:     """
   54:     return (slice(None),) * axis + (sl,) + (...,)
   55: 
   56: 
   57: def _view_roi(array, original_area_slice, axis):
   58:     """
   59:     Get a view of the current region of interest during iterative padding.
   60: 
   61:     When padding multiple dimensions iteratively corner values are
   62:     unnecessarily overwritten multiple times. This function reduces the
   63:     working area for the first dimensions so that corners are excluded.
   64: 
   65:     Parameters
   66:     ----------
   67:     array : ndarray
   68:         The array with the region of interest.
   69:     original_area_slice : tuple of slices
   70:         Denotes the area with original values of the unpadded array.
   71:     axis : int
   72:         The currently padded dimension assuming that `axis` is padded before
   73:         `axis` + 1.
   74: 
   75:     Returns
   76:     -------
   77:     roi : ndarray
   78:         The region of interest of the original `array`.
   79:     """
   80:     axis += 1
   81:     sl = (slice(None),) * axis + original_area_slice[axis:]
   82:     return array[sl]
   83: 
   84: 
   85: def _pad_simple(array, pad_width, fill_value=None):
   86:     """
   87:     Pad array on all sides with either a single value or undefined values.
   88: 
   89:     Parameters
   90:     ----------
   91:     array : ndarray
   92:         Array to grow.
   93:     pad_width : sequence of tuple[int, int]
   94:         Pad width on both sides for each dimension in `arr`.
   95:     fill_value : scalar, optional
   96:         If provided the padded area is filled with this value, otherwise
   97:         the pad area left undefined.
   98: 
   99:     Returns
  100:     -------
  101:     padded : ndarray
  102:         The padded array with the same dtype as`array`. Its order will default
  103:         to C-style if `array` is not F-contiguous.
  104:     original_area_slice : tuple
  105:         A tuple of slices pointing to the area of the original array.
  106:     """
  107:     # Allocate grown array
  108:     new_shape = tuple(
  109:         left + size + right
  110:         for size, (left, right) in zip(array.shape, pad_width)
  111:     )
  112:     order = 'F' if array.flags.fnc else 'C'  # Fortran and not also C-order
  113:     padded = np.empty(new_shape, dtype=array.dtype, order=order)
  114: 
  115:     if fill_value is not None:
  116:         padded.fill(fill_value)
  117: 
  118:     # Copy old array into correct space
  119:     original_area_slice = tuple(
  120:         slice(left, left + size)
  121:         for size, (left, right) in zip(array.shape, pad_width)
  122:     )
  123:     padded[original_area_slice] = array
  124: 
  125:     return padded, original_area_slice
  126: 
  127: 
  128: def _set_pad_area(padded, axis, width_pair, value_pair):
  129:     """
  130:     Set empty-padded area in given dimension.
  131: 
  132:     Parameters
  133:     ----------
  134:     padded : ndarray
  135:         Array with the pad area which is modified inplace.
  136:     axis : int
  137:         Dimension with the pad area to set.
  138:     width_pair : (int, int)
  139:         Pair of widths that mark the pad area on both sides in the given
  140:         dimension.
  141:     value_pair : tuple of scalars or ndarrays
  142:         Values inserted into the pad area on each side. It must match or be
  143:         broadcastable to the shape of `arr`.
  144:     """
  145:     left_slice = _slice_at_axis(slice(None, width_pair[0]), axis)
  146:     padded[left_slice] = value_pair[0]
  147: 
  148:     right_slice = _slice_at_axis(
  149:         slice(padded.shape[axis] - width_pair[1], None), axis)
  150:     padded[right_slice] = value_pair[1]
  151: 
  152: 
  153: def _get_edges(padded, axis, width_pair):
  154:     """
  155:     Retrieve edge values from empty-padded array in given dimension.
  156: 
  157:     Parameters
  158:     ----------
  159:     padded : ndarray
  160:         Empty-padded array.
  161:     axis : int
  162:         Dimension in which the edges are considered.
  163:     width_pair : (int, int)
  164:         Pair of widths that mark the pad area on both sides in the given
  165:         dimension.
  166: 
  167:     Returns
  168:     -------
  169:     left_edge, right_edge : ndarray
  170:         Edge values of the valid area in `padded` in the given dimension. Its
  171:         shape will always match `padded` except for the dimension given by
  172:         `axis` which will have a length of 1.
  173:     """
  174:     left_index = width_pair[0]
  175:     left_slice = _slice_at_axis(slice(left_index, left_index + 1), axis)
  176:     left_edge = padded[left_slice]
  177: 
  178:     right_index = padded.shape[axis] - width_pair[1]
  179:     right_slice = _slice_at_axis(slice(right_index - 1, right_index), axis)
  180:     right_edge = padded[right_slice]
  181: 
  182:     return left_edge, right_edge
  183: 
  184: 
  185: def _get_linear_ramps(padded, axis, width_pair, end_value_pair):
  186:     """
  187:     Construct linear ramps for empty-padded array in given dimension.
  188: 
  189:     Parameters
  190:     ----------
  191:     padded : ndarray
  192:         Empty-padded array.
  193:     axis : int
  194:         Dimension in which the ramps are constructed.
  195:     width_pair : (int, int)
  196:         Pair of widths that mark the pad area on both sides in the given
  197:         dimension.
  198:     end_value_pair : (scalar, scalar)
  199:         End values for the linear ramps which form the edge of the fully padded
  200:         array. These values are included in the linear ramps.
  201: 
  202:     Returns
  203:     -------
  204:     left_ramp, right_ramp : ndarray
  205:         Linear ramps to set on both sides of `padded`.
  206:     """
  207:     edge_pair = _get_edges(padded, axis, width_pair)
  208: 
  209:     left_ramp, right_ramp = (
  210:         np.linspace(
  211:             start=end_value,
  212:             stop=edge.squeeze(axis),  # Dimension is replaced by linspace
  213:             num=width,
  214:             endpoint=False,
  215:             dtype=padded.dtype,
  216:             axis=axis
  217:         )
  218:         for end_value, edge, width in zip(
  219:             end_value_pair, edge_pair, width_pair
  220:         )
  221:     )
  222: 
  223:     # Reverse linear space in appropriate dimension
  224:     right_ramp = right_ramp[_slice_at_axis(slice(None, None, -1), axis)]
  225: 
  226:     return left_ramp, right_ramp
  227: 
  228: 
  229: def _get_stats(padded, axis, width_pair, length_pair, stat_func):
  230:     """
  231:     Calculate statistic for the empty-padded array in given dimension.
  232: 
  233:     Parameters
  234:     ----------
  235:     padded : ndarray
  236:         Empty-padded array.
  237:     axis : int
  238:         Dimension in which the statistic is calculated.
  239:     width_pair : (int, int)
  240:         Pair of widths that mark the pad area on both sides in the given
  241:         dimension.
  242:     length_pair : 2-element sequence of None or int
  243:         Gives the number of values in valid area from each side that is
  244:         taken into account when calculating the statistic. If None the entire
  245:         valid area in `padded` is considered.
  246:     stat_func : function
  247:         Function to compute statistic. The expected signature is
  248:         ``stat_func(x: ndarray, axis: int, keepdims: bool) -> ndarray``.
  249: 
  250:     Returns
  251:     -------
  252:     left_stat, right_stat : ndarray
  253:         Calculated statistic for both sides of `padded`.
  254:     """
  255:     # Calculate indices of the edges of the area with original values
  256:     left_index = width_pair[0]
  257:     right_index = padded.shape[axis] - width_pair[1]
  258:     # as well as its length
  259:     max_length = right_index - left_index
  260: 
  261:     # Limit stat_lengths to max_length
  262:     left_length, right_length = length_pair
  263:     if left_length is None or max_length < left_length:
  264:         left_length = max_length
  265:     if right_length is None or max_length < right_length:
  266:         right_length = max_length
  267: 
  268:     if (left_length == 0 or right_length == 0) \
  269:             and stat_func in {np.amax, np.amin}:
  270:         # amax and amin can't operate on an empty array,
  271:         # raise a more descriptive warning here instead of the default one
  272:         raise ValueError("stat_length of 0 yields no value for padding")
  273: 
  274:     # Calculate statistic for the left side
  275:     left_slice = _slice_at_axis(
  276:         slice(left_index, left_index + left_length), axis)
  277:     left_chunk = padded[left_slice]
  278:     left_stat = stat_func(left_chunk, axis=axis, keepdims=True)
  279:     _round_if_needed(left_stat, padded.dtype)
  280: 
  281:     if left_length == right_length == max_length:
  282:         # return early as right_stat must be identical to left_stat
  283:         return left_stat, left_stat
  284: 
  285:     # Calculate statistic for the right side
  286:     right_slice = _slice_at_axis(
  287:         slice(right_index - right_length, right_index), axis)
  288:     right_chunk = padded[right_slice]
  289:     right_stat = stat_func(right_chunk, axis=axis, keepdims=True)
  290:     _round_if_needed(right_stat, padded.dtype)
  291: 
  292:     return left_stat, right_stat
  293: 
  294: 
  295: def _set_reflect_both(padded, axis, width_pair, method,
  296:                       original_period, include_edge=False):
  297:     """
  298:     Pad `axis` of `arr` with reflection.
  299: 
  300:     Parameters
  301:     ----------
  302:     padded : ndarray
  303:         Input array of arbitrary shape.
  304:     axis : int
  305:         Axis along which to pad `arr`.
  306:     width_pair : (int, int)
  307:         Pair of widths that mark the pad area on both sides in the given
  308:         dimension.
  309:     method : str
  310:         Controls method of reflection; options are 'even' or 'odd'.
  311:     original_period : int
  312:         Original length of data on `axis` of `arr`.
  313:     include_edge : bool
  314:         If true, edge value is included in reflection, otherwise the edge
  315:         value forms the symmetric axis to the reflection.
  316: 
  317:     Returns
  318:     -------
  319:     pad_amt : tuple of ints, length 2
  320:         New index positions of padding to do along the `axis`. If these are
  321:         both 0, padding is done in this dimension.
  322:     """
  323:     left_pad, right_pad = width_pair
  324:     old_length = padded.shape[axis] - right_pad - left_pad
  325: 
  326:     if include_edge:
  327:         # Avoid wrapping with only a subset of the original area
  328:         # by ensuring period can only be a multiple of the original
  329:         # area's length.
  330:         old_length = old_length // original_period * original_period
  331:         # Edge is included, we need to offset the pad amount by 1
  332:         edge_offset = 1
  333:     else:
  334:         # Avoid wrapping with only a subset of the original area
  335:         # by ensuring period can only be a multiple of the original
  336:         # area's length.
  337:         old_length = ((old_length - 1) // (original_period - 1)
  338:             * (original_period - 1) + 1)
  339:         edge_offset = 0  # Edge is not included, no need to offset pad amount
  340:         old_length -= 1  # but must be omitted from the chunk
  341: 
  342:     if left_pad > 0:
  343:         # Pad with reflected values on left side:
  344:         # First limit chunk size which can't be larger than pad area
  345:         chunk_length = min(old_length, left_pad)
  346:         # Slice right to left, stop on or next to edge, start relative to stop
  347:         stop = left_pad - edge_offset
  348:         start = stop + chunk_length
  349:         left_slice = _slice_at_axis(slice(start, stop, -1), axis)
  350:         left_chunk = padded[left_slice]
  351: 
  352:         if method == "odd":
  353:             # Negate chunk and align with edge
  354:             edge_slice = _slice_at_axis(slice(left_pad, left_pad + 1), axis)
  355:             left_chunk = 2 * padded[edge_slice] - left_chunk
  356: 
  357:         # Insert chunk into padded area
  358:         start = left_pad - chunk_length
  359:         stop = left_pad
  360:         pad_area = _slice_at_axis(slice(start, stop), axis)
  361:         padded[pad_area] = left_chunk
  362:         # Adjust pointer to left edge for next iteration
  363:         left_pad -= chunk_length
  364: 
  365:     if right_pad > 0:
  366:         # Pad with reflected values on right side:
  367:         # First limit chunk size which can't be larger than pad area
  368:         chunk_length = min(old_length, right_pad)
  369:         # Slice right to left, start on or next to edge, stop relative to start
  370:         start = -right_pad + edge_offset - 2
  371:         stop = start - chunk_length
  372:         right_slice = _slice_at_axis(slice(start, stop, -1), axis)
  373:         right_chunk = padded[right_slice]
  374: 
  375:         if method == "odd":
  376:             # Negate chunk and align with edge
  377:             edge_slice = _slice_at_axis(
  378:                 slice(-right_pad - 1, -right_pad), axis)
  379:             right_chunk = 2 * padded[edge_slice] - right_chunk
  380: 
  381:         # Insert chunk into padded area
  382:         start = padded.shape[axis] - right_pad
  383:         stop = start + chunk_length
  384:         pad_area = _slice_at_axis(slice(start, stop), axis)
  385:         padded[pad_area] = right_chunk
  386:         # Adjust pointer to right edge for next iteration
  387:         right_pad -= chunk_length
  388: 
  389:     return left_pad, right_pad
  390: 
  391: 
  392: def _set_wrap_both(padded, axis, width_pair, original_period):
  393:     """
  394:     Pad `axis` of `arr` with wrapped values.
  395: 
  396:     Parameters
  397:     ----------
  398:     padded : ndarray
  399:         Input array of arbitrary shape.
  400:     axis : int
  401:         Axis along which to pad `arr`.
  402:     width_pair : (int, int)
  403:         Pair of widths that mark the pad area on both sides in the given
  404:         dimension.
  405:     original_period : int
  406:         Original length of data on `axis` of `arr`.
  407: 
  408:     Returns
  409:     -------
  410:     pad_amt : tuple of ints, length 2
  411:         New index positions of padding to do along the `axis`. If these are
  412:         both 0, padding is done in this dimension.
  413:     """
  414:     left_pad, right_pad = width_pair
  415:     period = padded.shape[axis] - right_pad - left_pad
  416:     # Avoid wrapping with only a subset of the original area by ensuring period
  417:     # can only be a multiple of the original area's length.
  418:     period = period // original_period * original_period
  419: 
  420:     # If the current dimension of `arr` doesn't contain enough valid values
  421:     # (not part of the undefined pad area) we need to pad multiple times.
  422:     # Each time the pad area shrinks on both sides which is communicated with
  423:     # these variables.
  424:     new_left_pad = 0
  425:     new_right_pad = 0
  426: 
  427:     if left_pad > 0:
  428:         # Pad with wrapped values on left side
  429:         # First slice chunk from left side of the non-pad area.
  430:         # Use min(period, left_pad) to ensure that chunk is not larger than
  431:         # pad area.
  432:         slice_end = left_pad + period
  433:         slice_start = slice_end - min(period, left_pad)
  434:         right_slice = _slice_at_axis(slice(slice_start, slice_end), axis)
  435:         right_chunk = padded[right_slice]
  436: 
  437:         if left_pad > period:
  438:             # Chunk is smaller than pad area
  439:             pad_area = _slice_at_axis(slice(left_pad - period, left_pad), axis)
  440:             new_left_pad = left_pad - period
  441:         else:
  442:             # Chunk matches pad area
  443:             pad_area = _slice_at_axis(slice(None, left_pad), axis)
  444:         padded[pad_area] = right_chunk
  445: 
  446:     if right_pad > 0:
  447:         # Pad with wrapped values on right side
  448:         # First slice chunk from right side of the non-pad area.
  449:         # Use min(period, right_pad) to ensure that chunk is not larger than
  450:         # pad area.
  451:         slice_start = -right_pad - period
  452:         slice_end = slice_start + min(period, right_pad)
  453:         left_slice = _slice_at_axis(slice(slice_start, slice_end), axis)
  454:         left_chunk = padded[left_slice]
  455: 
  456:         if right_pad > period:
  457:             # Chunk is smaller than pad area
  458:             pad_area = _slice_at_axis(
  459:                 slice(-right_pad, -right_pad + period), axis)
  460:             new_right_pad = right_pad - period
  461:         else:
  462:             # Chunk matches pad area
  463:             pad_area = _slice_at_axis(slice(-right_pad, None), axis)
  464:         padded[pad_area] = left_chunk
  465: 
  466:     return new_left_pad, new_right_pad
  467: 
  468: 
  469: def _as_pairs(x, ndim, as_index=False):
  470:     """
  471:     Broadcast `x` to an array with the shape (`ndim`, 2).
  472: 
  473:     A helper function for `pad` that prepares and validates arguments like
  474:     `pad_width` for iteration in pairs.
  475: 
  476:     Parameters
  477:     ----------
  478:     x : {None, scalar, array-like}
  479:         The object to broadcast to the shape (`ndim`, 2).
  480:     ndim : int
  481:         Number of pairs the broadcasted `x` will have.
  482:     as_index : bool, optional
  483:         If `x` is not None, try to round each element of `x` to an integer
  484:         (dtype `np.intp`) and ensure every element is positive.
  485: 
  486:     Returns
  487:     -------
  488:     pairs : nested iterables, shape (`ndim`, 2)
  489:         The broadcasted version of `x`.
  490: 
  491:     Raises
  492:     ------
  493:     ValueError
  494:         If `as_index` is True and `x` contains negative elements.
  495:         Or if `x` is not broadcastable to the shape (`ndim`, 2).
  496:     """
  497:     if x is None:
  498:         # Pass through None as a special case, otherwise np.round(x) fails
  499:         # with an AttributeError
  500:         return ((None, None),) * ndim
  501: 
  502:     x = np.array(x)
  503:     if as_index:
  504:         x = np.round(x).astype(np.intp, copy=False)
  505: 
  506:     if x.ndim < 3:
  507:         # Optimization: Possibly use faster paths for cases where `x` has
  508:         # only 1 or 2 elements. `np.broadcast_to` could handle these as well
  509:         # but is currently slower
  510: 
  511:         if x.size == 1:
  512:             # x was supplied as a single value
  513:             x = x.ravel()  # Ensure x[0] works for x.ndim == 0, 1, 2
  514:             if as_index and x < 0:
  515:                 raise ValueError("index can't contain negative values")
  516:             return ((x[0], x[0]),) * ndim
  517: 
  518:         if x.size == 2 and x.shape != (2, 1):
  519:             # x was supplied with a single value for each side
  520:             # but except case when each dimension has a single value
  521:             # which should be broadcasted to a pair,
  522:             # e.g. [[1], [2]] -> [[1, 1], [2, 2]] not [[1, 2], [1, 2]]
  523:             x = x.ravel()  # Ensure x[0], x[1] works
  524:             if as_index and (x[0] < 0 or x[1] < 0):
  525:                 raise ValueError("index can't contain negative values")
  526:             return ((x[0], x[1]),) * ndim
  527: 
  528:     if as_index and x.min() < 0:
  529:         raise ValueError("index can't contain negative values")
  530: 
  531:     # Converting the array with `tolist` seems to improve performance
  532:     # when iterating and indexing the result (see usage in `pad`)
  533:     return np.broadcast_to(x, (ndim, 2)).tolist()
  534: 
  535: 
  536: def _pad_dispatcher(array, pad_width, mode=None, **kwargs):
  537:     return (array,)
  538: 
  539: 
  540: ###############################################################################
  541: # Public functions
  542: 
  543: 
  544: @array_function_dispatch(_pad_dispatcher, module='numpy')
  545: def pad(array, pad_width, mode='constant', **kwargs):
  546:     """
  547:     Pad an array.
  548: 
  549:     Parameters
  550:     ----------
  551:     array : array_like of rank N
  552:         The array to pad.
  553:     pad_width : {sequence, array_like, int}
  554:         Number of values padded to the edges of each axis.
  555:         ``((before_1, after_1), ... (before_N, after_N))`` unique pad widths
  556:         for each axis.
  557:         ``(before, after)`` or ``((before, after),)`` yields same before
  558:         and after pad for each axis.
  559:         ``(pad,)`` or ``int`` is a shortcut for before = after = pad width
  560:         for all axes.
  561:     mode : str or function, optional
  562:         One of the following string values or a user supplied function.
  563: 
  564:         'constant' (default)
  565:             Pads with a constant value.
  566:         'edge'
  567:             Pads with the edge values of array.
  568:         'linear_ramp'
  569:             Pads with the linear ramp between end_value and the
  570:             array edge value.
  571:         'maximum'
  572:             Pads with the maximum value of all or part of the
  573:             vector along each axis.
  574:         'mean'
  575:             Pads with the mean value of all or part of the
  576:             vector along each axis.
  577:         'median'
  578:             Pads with the median value of all or part of the
  579:             vector along each axis.
  580:         'minimum'
  581:             Pads with the minimum value of all or part of the
  582:             vector along each axis.
  583:         'reflect'
  584:             Pads with the reflection of the vector mirrored on
  585:             the first and last values of the vector along each
  586:             axis.
  587:         'symmetric'
  588:             Pads with the reflection of the vector mirrored
  589:             along the edge of the array.
  590:         'wrap'
  591:             Pads with the wrap of the vector along the axis.
  592:             The first values are used to pad the end and the
  593:             end values are used to pad the beginning.
  594:         'empty'
  595:             Pads with undefined values.
  596: 
  597:         <function>
  598:             Padding function, see Notes.
  599:     stat_length : sequence or int, optional
  600:         Used in 'maximum', 'mean', 'median', and 'minimum'.  Number of
  601:         values at edge of each axis used to calculate the statistic value.
  602: 
  603:         ``((before_1, after_1), ... (before_N, after_N))`` unique statistic
  604:         lengths for each axis.
  605: 
  606:         ``(before, after)`` or ``((before, after),)`` yields same before
  607:         and after statistic lengths for each axis.
  608: 
  609:         ``(stat_length,)`` or ``int`` is a shortcut for
  610:         ``before = after = statistic`` length for all axes.
  611: 
  612:         Default is ``None``, to use the entire axis.
  613:     constant_values : sequence or scalar, optional
  614:         Used in 'constant'.  The values to set the padded values for each
  615:         axis.
  616: 
  617:         ``((before_1, after_1), ... (before_N, after_N))`` unique pad constants
  618:         for each axis.
  619: 
  620:         ``(before, after)`` or ``((before, after),)`` yields same before
  621:         and after constants for each axis.
  622: 
  623:         ``(constant,)`` or ``constant`` is a shortcut for
  624:         ``before = after = constant`` for all axes.
  625: 
  626:         Default is 0.
  627:     end_values : sequence or scalar, optional
  628:         Used in 'linear_ramp'.  The values used for the ending value of the
  629:         linear_ramp and that will form the edge of the padded array.
  630: 
  631:         ``((before_1, after_1), ... (before_N, after_N))`` unique end values
  632:         for each axis.
  633: 
  634:         ``(before, after)`` or ``((before, after),)`` yields same before
  635:         and after end values for each axis.
  636: 
  637:         ``(constant,)`` or ``constant`` is a shortcut for
  638:         ``before = after = constant`` for all axes.
  639: 
  640:         Default is 0.
  641:     reflect_type : {'even', 'odd'}, optional
  642:         Used in 'reflect', and 'symmetric'.  The 'even' style is the
  643:         default with an unaltered reflection around the edge value.  For
  644:         the 'odd' style, the extended part of the array is created by
  645:         subtracting the reflected values from two times the edge value.
  646: 
  647:     Returns
  648:     -------
  649:     pad : ndarray
  650:         Padded array of rank equal to `array` with shape increased
  651:         according to `pad_width`.
  652: 
  653:     Notes
  654:     -----
  655:     For an array with rank greater than 1, some of the padding of later
  656:     axes is calculated from padding of previous axes.  This is easiest to
  657:     think about with a rank 2 array where the corners of the padded array
  658:     are calculated by using padded values from the first axis.
  659: 
  660:     The padding function, if used, should modify a rank 1 array in-place. It
  661:     has the following signature::
  662: 
  663:         padding_func(vector, iaxis_pad_width, iaxis, kwargs)
  664: 
  665:     where
  666: 
  667:     vector : ndarray
  668:         A rank 1 array already padded with zeros.  Padded values are
  669:         vector[:iaxis_pad_width[0]] and vector[-iaxis_pad_width[1]:].
  670:     iaxis_pad_width : tuple
  671:         A 2-tuple of ints, iaxis_pad_width[0] represents the number of
  672:         values padded at the beginning of vector where
  673:         iaxis_pad_width[1] represents the number of values padded at
  674:         the end of vector.
  675:     iaxis : int
  676:         The axis currently being calculated.
  677:     kwargs : dict
  678:         Any keyword arguments the function requires.
  679: 
  680:     Examples
  681:     --------
  682:     >>> import numpy as np
  683:     >>> a = [1, 2, 3, 4, 5]
  684:     >>> np.pad(a, (2, 3), 'constant', constant_values=(4, 6))
  685:     array([4, 4, 1, ..., 6, 6, 6])
  686: 
  687:     >>> np.pad(a, (2, 3), 'edge')
  688:     array([1, 1, 1, ..., 5, 5, 5])
  689: 
  690:     >>> np.pad(a, (2, 3), 'linear_ramp', end_values=(5, -4))
  691:     array([ 5,  3,  1,  2,  3,  4,  5,  2, -1, -4])
  692: 
  693:     >>> np.pad(a, (2,), 'maximum')
  694:     array([5, 5, 1, 2, 3, 4, 5, 5, 5])
  695: 
  696:     >>> np.pad(a, (2,), 'mean')
  697:     array([3, 3, 1, 2, 3, 4, 5, 3, 3])
  698: 
  699:     >>> np.pad(a, (2,), 'median')
  700:     array([3, 3, 1, 2, 3, 4, 5, 3, 3])
  701: 
  702:     >>> a = [[1, 2], [3, 4]]
  703:     >>> np.pad(a, ((3, 2), (2, 3)), 'minimum')
  704:     array([[1, 1, 1, 2, 1, 1, 1],
  705:            [1, 1, 1, 2, 1, 1, 1],
  706:            [1, 1, 1, 2, 1, 1, 1],
  707:            [1, 1, 1, 2, 1, 1, 1],
  708:            [3, 3, 3, 4, 3, 3, 3],
  709:            [1, 1, 1, 2, 1, 1, 1],
  710:            [1, 1, 1, 2, 1, 1, 1]])
  711: 
  712:     >>> a = [1, 2, 3, 4, 5]
  713:     >>> np.pad(a, (2, 3), 'reflect')
  714:     array([3, 2, 1, 2, 3, 4, 5, 4, 3, 2])
  715: 
  716:     >>> np.pad(a, (2, 3), 'reflect', reflect_type='odd')
  717:     array([-1,  0,  1,  2,  3,  4,  5,  6,  7,  8])
  718: 
  719:     >>> np.pad(a, (2, 3), 'symmetric')
  720:     array([2, 1, 1, 2, 3, 4, 5, 5, 4, 3])
  721: 
  722:     >>> np.pad(a, (2, 3), 'symmetric', reflect_type='odd')
  723:     array([0, 1, 1, 2, 3, 4, 5, 5, 6, 7])
  724: 
  725:     >>> np.pad(a, (2, 3), 'wrap')
  726:     array([4, 5, 1, 2, 3, 4, 5, 1, 2, 3])
  727: 
  728:     >>> def pad_with(vector, pad_width, iaxis, kwargs):
  729:     ...     pad_value = kwargs.get('padder', 10)
  730:     ...     vector[:pad_width[0]] = pad_value
  731:     ...     vector[-pad_width[1]:] = pad_value
  732:     >>> a = np.arange(6)
  733:     >>> a = a.reshape((2, 3))
  734:     >>> np.pad(a, 2, pad_with)
  735:     array([[10, 10, 10, 10, 10, 10, 10],
  736:            [10, 10, 10, 10, 10, 10, 10],
  737:            [10, 10,  0,  1,  2, 10, 10],
  738:            [10, 10,  3,  4,  5, 10, 10],
  739:            [10, 10, 10, 10, 10, 10, 10],
  740:            [10, 10, 10, 10, 10, 10, 10]])
  741:     >>> np.pad(a, 2, pad_with, padder=100)
  742:     array([[100, 100, 100, 100, 100, 100, 100],
  743:            [100, 100, 100, 100, 100, 100, 100],
  744:            [100, 100,   0,   1,   2, 100, 100],
  745:            [100, 100,   3,   4,   5, 100, 100],
  746:            [100, 100, 100, 100, 100, 100, 100],
  747:            [100, 100, 100, 100, 100, 100, 100]])
  748:     """
  749:     array = np.asarray(array)
  750:     pad_width = np.asarray(pad_width)
  751: 
  752:     if not pad_width.dtype.kind == 'i':
  753:         raise TypeError('`pad_width` must be of integral type.')
  754: 
  755:     # Broadcast to shape (array.ndim, 2)
  756:     pad_width = _as_pairs(pad_width, array.ndim, as_index=True)
  757: 
  758:     if callable(mode):
  759:         # Old behavior: Use user-supplied function with np.apply_along_axis
  760:         function = mode
  761:         # Create a new zero padded array
  762:         padded, _ = _pad_simple(array, pad_width, fill_value=0)
  763:         # And apply along each axis
  764: 
  765:         for axis in range(padded.ndim):
  766:             # Iterate using ndindex as in apply_along_axis, but assuming that
  767:             # function operates inplace on the padded array.
  768: 
  769:             # view with the iteration axis at the end
  770:             view = np.moveaxis(padded, axis, -1)
  771: 
  772:             # compute indices for the iteration axes, and append a trailing
  773:             # ellipsis to prevent 0d arrays decaying to scalars (gh-8642)
  774:             inds = ndindex(view.shape[:-1])
  775:             inds = (ind + (Ellipsis,) for ind in inds)
  776:             for ind in inds:
  777:                 function(view[ind], pad_width[axis], axis, kwargs)
  778: 
  779:         return padded
  780: 
  781:     # Make sure that no unsupported keywords were passed for the current mode
  782:     allowed_kwargs = {
  783:         'empty': [], 'edge': [], 'wrap': [],
  784:         'constant': ['constant_values'],
  785:         'linear_ramp': ['end_values'],
  786:         'maximum': ['stat_length'],
  787:         'mean': ['stat_length'],
  788:         'median': ['stat_length'],
  789:         'minimum': ['stat_length'],
  790:         'reflect': ['reflect_type'],
  791:         'symmetric': ['reflect_type'],
  792:     }
  793:     try:
  794:         unsupported_kwargs = set(kwargs) - set(allowed_kwargs[mode])
  795:     except KeyError:
  796:         raise ValueError(f"mode '{mode}' is not supported") from None
  797:     if unsupported_kwargs:
  798:         raise ValueError("unsupported keyword arguments for mode "
  799:                          f"'{mode}': {unsupported_kwargs}")
  800: 
  801:     stat_functions = {"maximum": np.amax, "minimum": np.amin,
  802:                       "mean": np.mean, "median": np.median}
  803: 
  804:     # Create array with final shape and original values
  805:     # (padded area is undefined)
  806:     padded, original_area_slice = _pad_simple(array, pad_width)
  807:     # And prepare iteration over all dimensions
  808:     # (zipping may be more readable than using enumerate)
  809:     axes = range(padded.ndim)
  810: 
  811:     if mode == "constant":
  812:         values = kwargs.get("constant_values", 0)
  813:         values = _as_pairs(values, padded.ndim)
  814:         for axis, width_pair, value_pair in zip(axes, pad_width, values):
  815:             roi = _view_roi(padded, original_area_slice, axis)
  816:             _set_pad_area(roi, axis, width_pair, value_pair)
  817: 
  818:     elif mode == "empty":
  819:         pass  # Do nothing as _pad_simple already returned the correct result
  820: 
  821:     elif array.size == 0:
  822:         # Only modes "constant" and "empty" can extend empty axes, all other
  823:         # modes depend on `array` not being empty
  824:         # -> ensure every empty axis is only "padded with 0"
  825:         for axis, width_pair in zip(axes, pad_width):
  826:             if array.shape[axis] == 0 and any(width_pair):
  827:                 raise ValueError(
  828:                     f"can't extend empty axis {axis} using modes other than "
  829:                     "'constant' or 'empty'"
  830:                 )
  831:         # passed, don't need to do anything more as _pad_simple already
  832:         # returned the correct result
  833: 
  834:     elif mode == "edge":
  835:         for axis, width_pair in zip(axes, pad_width):
  836:             roi = _view_roi(padded, original_area_slice, axis)
  837:             edge_pair = _get_edges(roi, axis, width_pair)
  838:             _set_pad_area(roi, axis, width_pair, edge_pair)
  839: 
  840:     elif mode == "linear_ramp":
  841:         end_values = kwargs.get("end_values", 0)
  842:         end_values = _as_pairs(end_values, padded.ndim)
  843:         for axis, width_pair, value_pair in zip(axes, pad_width, end_values):
  844:             roi = _view_roi(padded, original_area_slice, axis)
  845:             ramp_pair = _get_linear_ramps(roi, axis, width_pair, value_pair)
  846:             _set_pad_area(roi, axis, width_pair, ramp_pair)
  847: 
  848:     elif mode in stat_functions:
  849:         func = stat_functions[mode]
  850:         length = kwargs.get("stat_length")
  851:         length = _as_pairs(length, padded.ndim, as_index=True)
  852:         for axis, width_pair, length_pair in zip(axes, pad_width, length):
  853:             roi = _view_roi(padded, original_area_slice, axis)
  854:             stat_pair = _get_stats(roi, axis, width_pair, length_pair, func)
  855:             _set_pad_area(roi, axis, width_pair, stat_pair)
  856: 
  857:     elif mode in {"reflect", "symmetric"}:
  858:         method = kwargs.get("reflect_type", "even")
  859:         include_edge = mode == "symmetric"
  860:         for axis, (left_index, right_index) in zip(axes, pad_width):
  861:             if array.shape[axis] == 1 and (left_index > 0 or right_index > 0):
  862:                 # Extending singleton dimension for 'reflect' is legacy
  863:                 # behavior; it really should raise an error.
  864:                 edge_pair = _get_edges(padded, axis, (left_index, right_index))
  865:                 _set_pad_area(
  866:                     padded, axis, (left_index, right_index), edge_pair)
  867:                 continue
  868: 
  869:             roi = _view_roi(padded, original_area_slice, axis)
  870:             while left_index > 0 or right_index > 0:
  871:                 # Iteratively pad until dimension is filled with reflected
  872:                 # values. This is necessary if the pad area is larger than
  873:                 # the length of the original values in the current dimension.
  874:                 left_index, right_index = _set_reflect_both(
  875:                     roi, axis, (left_index, right_index),
  876:                     method, array.shape[axis], include_edge
  877:                 )
  878: 
  879:     elif mode == "wrap":
  880:         for axis, (left_index, right_index) in zip(axes, pad_width):
  881:             roi = _view_roi(padded, original_area_slice, axis)
  882:             original_period = padded.shape[axis] - right_index - left_index
  883:             while left_index > 0 or right_index > 0:
  884:                 # Iteratively pad until dimension is filled with wrapped
  885:                 # values. This is necessary if the pad area is larger than
  886:                 # the length of the original values in the current dimension.
  887:                 left_index, right_index = _set_wrap_both(
  888:                     roi, axis, (left_index, right_index), original_period)
  889: 
  890:     return padded
