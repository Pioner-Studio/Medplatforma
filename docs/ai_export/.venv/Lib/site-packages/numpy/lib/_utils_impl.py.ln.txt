    1: import functools
    2: import os
    3: import platform
    4: import sys
    5: import textwrap
    6: import types
    7: import warnings
    8: 
    9: import numpy as np
   10: from numpy._core import ndarray
   11: from numpy._utils import set_module
   12: 
   13: __all__ = [
   14:     'get_include', 'info', 'show_runtime'
   15: ]
   16: 
   17: 
   18: @set_module('numpy')
   19: def show_runtime():
   20:     """
   21:     Print information about various resources in the system
   22:     including available intrinsic support and BLAS/LAPACK library
   23:     in use
   24: 
   25:     .. versionadded:: 1.24.0
   26: 
   27:     See Also
   28:     --------
   29:     show_config : Show libraries in the system on which NumPy was built.
   30: 
   31:     Notes
   32:     -----
   33:     1. Information is derived with the help of `threadpoolctl <https://pypi.org/project/threadpoolctl/>`_
   34:        library if available.
   35:     2. SIMD related information is derived from ``__cpu_features__``,
   36:        ``__cpu_baseline__`` and ``__cpu_dispatch__``
   37: 
   38:     """
   39:     from pprint import pprint
   40: 
   41:     from numpy._core._multiarray_umath import (
   42:         __cpu_baseline__,
   43:         __cpu_dispatch__,
   44:         __cpu_features__,
   45:     )
   46:     config_found = [{
   47:         "numpy_version": np.__version__,
   48:         "python": sys.version,
   49:         "uname": platform.uname(),
   50:         }]
   51:     features_found, features_not_found = [], []
   52:     for feature in __cpu_dispatch__:
   53:         if __cpu_features__[feature]:
   54:             features_found.append(feature)
   55:         else:
   56:             features_not_found.append(feature)
   57:     config_found.append({
   58:         "simd_extensions": {
   59:             "baseline": __cpu_baseline__,
   60:             "found": features_found,
   61:             "not_found": features_not_found
   62:         }
   63:     })
   64:     try:
   65:         from threadpoolctl import threadpool_info
   66:         config_found.extend(threadpool_info())
   67:     except ImportError:
   68:         print("WARNING: `threadpoolctl` not found in system!"
   69:               " Install it by `pip install threadpoolctl`."
   70:               " Once installed, try `np.show_runtime` again"
   71:               " for more detailed build information")
   72:     pprint(config_found)
   73: 
   74: 
   75: @set_module('numpy')
   76: def get_include():
   77:     """
   78:     Return the directory that contains the NumPy \\*.h header files.
   79: 
   80:     Extension modules that need to compile against NumPy may need to use this
   81:     function to locate the appropriate include directory.
   82: 
   83:     Notes
   84:     -----
   85:     When using ``setuptools``, for example in ``setup.py``::
   86: 
   87:         import numpy as np
   88:         ...
   89:         Extension('extension_name', ...
   90:                   include_dirs=[np.get_include()])
   91:         ...
   92: 
   93:     Note that a CLI tool ``numpy-config`` was introduced in NumPy 2.0, using
   94:     that is likely preferred for build systems other than ``setuptools``::
   95: 
   96:         $ numpy-config --cflags
   97:         -I/path/to/site-packages/numpy/_core/include
   98: 
   99:         # Or rely on pkg-config:
  100:         $ export PKG_CONFIG_PATH=$(numpy-config --pkgconfigdir)
  101:         $ pkg-config --cflags
  102:         -I/path/to/site-packages/numpy/_core/include
  103: 
  104:     Examples
  105:     --------
  106:     >>> np.get_include()
  107:     '.../site-packages/numpy/core/include'  # may vary
  108: 
  109:     """
  110:     import numpy
  111:     if numpy.show_config is None:
  112:         # running from numpy source directory
  113:         d = os.path.join(os.path.dirname(numpy.__file__), '_core', 'include')
  114:     else:
  115:         # using installed numpy core headers
  116:         import numpy._core as _core
  117:         d = os.path.join(os.path.dirname(_core.__file__), 'include')
  118:     return d
  119: 
  120: 
  121: class _Deprecate:
  122:     """
  123:     Decorator class to deprecate old functions.
  124: 
  125:     Refer to `deprecate` for details.
  126: 
  127:     See Also
  128:     --------
  129:     deprecate
  130: 
  131:     """
  132: 
  133:     def __init__(self, old_name=None, new_name=None, message=None):
  134:         self.old_name = old_name
  135:         self.new_name = new_name
  136:         self.message = message
  137: 
  138:     def __call__(self, func, *args, **kwargs):
  139:         """
  140:         Decorator call.  Refer to ``decorate``.
  141: 
  142:         """
  143:         old_name = self.old_name
  144:         new_name = self.new_name
  145:         message = self.message
  146: 
  147:         if old_name is None:
  148:             old_name = func.__name__
  149:         if new_name is None:
  150:             depdoc = f"`{old_name}` is deprecated!"
  151:         else:
  152:             depdoc = f"`{old_name}` is deprecated, use `{new_name}` instead!"
  153: 
  154:         if message is not None:
  155:             depdoc += "\n" + message
  156: 
  157:         @functools.wraps(func)
  158:         def newfunc(*args, **kwds):
  159:             warnings.warn(depdoc, DeprecationWarning, stacklevel=2)
  160:             return func(*args, **kwds)
  161: 
  162:         newfunc.__name__ = old_name
  163:         doc = func.__doc__
  164:         if doc is None:
  165:             doc = depdoc
  166:         else:
  167:             lines = doc.expandtabs().split('\n')
  168:             indent = _get_indent(lines[1:])
  169:             if lines[0].lstrip():
  170:                 # Indent the original first line to let inspect.cleandoc()
  171:                 # dedent the docstring despite the deprecation notice.
  172:                 doc = indent * ' ' + doc
  173:             else:
  174:                 # Remove the same leading blank lines as cleandoc() would.
  175:                 skip = len(lines[0]) + 1
  176:                 for line in lines[1:]:
  177:                     if len(line) > indent:
  178:                         break
  179:                     skip += len(line) + 1
  180:                 doc = doc[skip:]
  181:             depdoc = textwrap.indent(depdoc, ' ' * indent)
  182:             doc = f'{depdoc}\n\n{doc}'
  183:         newfunc.__doc__ = doc
  184: 
  185:         return newfunc
  186: 
  187: 
  188: def _get_indent(lines):
  189:     """
  190:     Determines the leading whitespace that could be removed from all the lines.
  191:     """
  192:     indent = sys.maxsize
  193:     for line in lines:
  194:         content = len(line.lstrip())
  195:         if content:
  196:             indent = min(indent, len(line) - content)
  197:     if indent == sys.maxsize:
  198:         indent = 0
  199:     return indent
  200: 
  201: 
  202: def deprecate(*args, **kwargs):
  203:     """
  204:     Issues a DeprecationWarning, adds warning to `old_name`'s
  205:     docstring, rebinds ``old_name.__name__`` and returns the new
  206:     function object.
  207: 
  208:     This function may also be used as a decorator.
  209: 
  210:     .. deprecated:: 2.0
  211:         Use `~warnings.warn` with :exc:`DeprecationWarning` instead.
  212: 
  213:     Parameters
  214:     ----------
  215:     func : function
  216:         The function to be deprecated.
  217:     old_name : str, optional
  218:         The name of the function to be deprecated. Default is None, in
  219:         which case the name of `func` is used.
  220:     new_name : str, optional
  221:         The new name for the function. Default is None, in which case the
  222:         deprecation message is that `old_name` is deprecated. If given, the
  223:         deprecation message is that `old_name` is deprecated and `new_name`
  224:         should be used instead.
  225:     message : str, optional
  226:         Additional explanation of the deprecation.  Displayed in the
  227:         docstring after the warning.
  228: 
  229:     Returns
  230:     -------
  231:     old_func : function
  232:         The deprecated function.
  233: 
  234:     Examples
  235:     --------
  236:     Note that ``olduint`` returns a value after printing Deprecation
  237:     Warning:
  238: 
  239:     >>> olduint = np.lib.utils.deprecate(np.uint)
  240:     DeprecationWarning: `uint64` is deprecated! # may vary
  241:     >>> olduint(6)
  242:     6
  243: 
  244:     """
  245:     # Deprecate may be run as a function or as a decorator
  246:     # If run as a function, we initialise the decorator class
  247:     # and execute its __call__ method.
  248: 
  249:     # Deprecated in NumPy 2.0, 2023-07-11
  250:     warnings.warn(
  251:         "`deprecate` is deprecated, "
  252:         "use `warn` with `DeprecationWarning` instead. "
  253:         "(deprecated in NumPy 2.0)",
  254:         DeprecationWarning,
  255:         stacklevel=2
  256:     )
  257: 
  258:     if args:
  259:         fn = args[0]
  260:         args = args[1:]
  261: 
  262:         return _Deprecate(*args, **kwargs)(fn)
  263:     else:
  264:         return _Deprecate(*args, **kwargs)
  265: 
  266: 
  267: def deprecate_with_doc(msg):
  268:     """
  269:     Deprecates a function and includes the deprecation in its docstring.
  270: 
  271:     .. deprecated:: 2.0
  272:         Use `~warnings.warn` with :exc:`DeprecationWarning` instead.
  273: 
  274:     This function is used as a decorator. It returns an object that can be
  275:     used to issue a DeprecationWarning, by passing the to-be decorated
  276:     function as argument, this adds warning to the to-be decorated function's
  277:     docstring and returns the new function object.
  278: 
  279:     See Also
  280:     --------
  281:     deprecate : Decorate a function such that it issues a
  282:                 :exc:`DeprecationWarning`
  283: 
  284:     Parameters
  285:     ----------
  286:     msg : str
  287:         Additional explanation of the deprecation. Displayed in the
  288:         docstring after the warning.
  289: 
  290:     Returns
  291:     -------
  292:     obj : object
  293: 
  294:     """
  295: 
  296:     # Deprecated in NumPy 2.0, 2023-07-11
  297:     warnings.warn(
  298:         "`deprecate` is deprecated, "
  299:         "use `warn` with `DeprecationWarning` instead. "
  300:         "(deprecated in NumPy 2.0)",
  301:         DeprecationWarning,
  302:         stacklevel=2
  303:     )
  304: 
  305:     return _Deprecate(message=msg)
  306: 
  307: 
  308: #-----------------------------------------------------------------------------
  309: 
  310: 
  311: # NOTE:  pydoc defines a help function which works similarly to this
  312: #  except it uses a pager to take over the screen.
  313: 
  314: # combine name and arguments and split to multiple lines of width
  315: # characters.  End lines on a comma and begin argument list indented with
  316: # the rest of the arguments.
  317: def _split_line(name, arguments, width):
  318:     firstwidth = len(name)
  319:     k = firstwidth
  320:     newstr = name
  321:     sepstr = ", "
  322:     arglist = arguments.split(sepstr)
  323:     for argument in arglist:
  324:         if k == firstwidth:
  325:             addstr = ""
  326:         else:
  327:             addstr = sepstr
  328:         k = k + len(argument) + len(addstr)
  329:         if k > width:
  330:             k = firstwidth + 1 + len(argument)
  331:             newstr = newstr + ",\n" + " " * (firstwidth + 2) + argument
  332:         else:
  333:             newstr = newstr + addstr + argument
  334:     return newstr
  335: 
  336: 
  337: _namedict = None
  338: _dictlist = None
  339: 
  340: # Traverse all module directories underneath globals
  341: # to see if something is defined
  342: def _makenamedict(module='numpy'):
  343:     module = __import__(module, globals(), locals(), [])
  344:     thedict = {module.__name__: module.__dict__}
  345:     dictlist = [module.__name__]
  346:     totraverse = [module.__dict__]
  347:     while True:
  348:         if len(totraverse) == 0:
  349:             break
  350:         thisdict = totraverse.pop(0)
  351:         for x in thisdict.keys():
  352:             if isinstance(thisdict[x], types.ModuleType):
  353:                 modname = thisdict[x].__name__
  354:                 if modname not in dictlist:
  355:                     moddict = thisdict[x].__dict__
  356:                     dictlist.append(modname)
  357:                     totraverse.append(moddict)
  358:                     thedict[modname] = moddict
  359:     return thedict, dictlist
  360: 
  361: 
  362: def _info(obj, output=None):
  363:     """Provide information about ndarray obj.
  364: 
  365:     Parameters
  366:     ----------
  367:     obj : ndarray
  368:         Must be ndarray, not checked.
  369:     output
  370:         Where printed output goes.
  371: 
  372:     Notes
  373:     -----
  374:     Copied over from the numarray module prior to its removal.
  375:     Adapted somewhat as only numpy is an option now.
  376: 
  377:     Called by info.
  378: 
  379:     """
  380:     extra = ""
  381:     tic = ""
  382:     bp = lambda x: x
  383:     cls = getattr(obj, '__class__', type(obj))
  384:     nm = getattr(cls, '__name__', cls)
  385:     strides = obj.strides
  386:     endian = obj.dtype.byteorder
  387: 
  388:     if output is None:
  389:         output = sys.stdout
  390: 
  391:     print("class: ", nm, file=output)
  392:     print("shape: ", obj.shape, file=output)
  393:     print("strides: ", strides, file=output)
  394:     print("itemsize: ", obj.itemsize, file=output)
  395:     print("aligned: ", bp(obj.flags.aligned), file=output)
  396:     print("contiguous: ", bp(obj.flags.contiguous), file=output)
  397:     print("fortran: ", obj.flags.fortran, file=output)
  398:     print(
  399:         f"data pointer: {hex(obj.ctypes._as_parameter_.value)}{extra}",
  400:         file=output
  401:         )
  402:     print("byteorder: ", end=' ', file=output)
  403:     if endian in ['|', '=']:
  404:         print(f"{tic}{sys.byteorder}{tic}", file=output)
  405:         byteswap = False
  406:     elif endian == '>':
  407:         print(f"{tic}big{tic}", file=output)
  408:         byteswap = sys.byteorder != "big"
  409:     else:
  410:         print(f"{tic}little{tic}", file=output)
  411:         byteswap = sys.byteorder != "little"
  412:     print("byteswap: ", bp(byteswap), file=output)
  413:     print(f"type: {obj.dtype}", file=output)
  414: 
  415: 
  416: @set_module('numpy')
  417: def info(object=None, maxwidth=76, output=None, toplevel='numpy'):
  418:     """
  419:     Get help information for an array, function, class, or module.
  420: 
  421:     Parameters
  422:     ----------
  423:     object : object or str, optional
  424:         Input object or name to get information about. If `object` is
  425:         an `ndarray` instance, information about the array is printed.
  426:         If `object` is a numpy object, its docstring is given. If it is
  427:         a string, available modules are searched for matching objects.
  428:         If None, information about `info` itself is returned.
  429:     maxwidth : int, optional
  430:         Printing width.
  431:     output : file like object, optional
  432:         File like object that the output is written to, default is
  433:         ``None``, in which case ``sys.stdout`` will be used.
  434:         The object has to be opened in 'w' or 'a' mode.
  435:     toplevel : str, optional
  436:         Start search at this level.
  437: 
  438:     Notes
  439:     -----
  440:     When used interactively with an object, ``np.info(obj)`` is equivalent
  441:     to ``help(obj)`` on the Python prompt or ``obj?`` on the IPython
  442:     prompt.
  443: 
  444:     Examples
  445:     --------
  446:     >>> np.info(np.polyval) # doctest: +SKIP
  447:        polyval(p, x)
  448:          Evaluate the polynomial p at x.
  449:          ...
  450: 
  451:     When using a string for `object` it is possible to get multiple results.
  452: 
  453:     >>> np.info('fft') # doctest: +SKIP
  454:          *** Found in numpy ***
  455:     Core FFT routines
  456:     ...
  457:          *** Found in numpy.fft ***
  458:      fft(a, n=None, axis=-1)
  459:     ...
  460:          *** Repeat reference found in numpy.fft.fftpack ***
  461:          *** Total of 3 references found. ***
  462: 
  463:     When the argument is an array, information about the array is printed.
  464: 
  465:     >>> a = np.array([[1 + 2j, 3, -4], [-5j, 6, 0]], dtype=np.complex64)
  466:     >>> np.info(a)
  467:     class:  ndarray
  468:     shape:  (2, 3)
  469:     strides:  (24, 8)
  470:     itemsize:  8
  471:     aligned:  True
  472:     contiguous:  True
  473:     fortran:  False
  474:     data pointer: 0x562b6e0d2860  # may vary
  475:     byteorder:  little
  476:     byteswap:  False
  477:     type: complex64
  478: 
  479:     """
  480:     global _namedict, _dictlist
  481:     # Local import to speed up numpy's import time.
  482:     import inspect
  483:     import pydoc
  484: 
  485:     if (hasattr(object, '_ppimport_importer') or
  486:            hasattr(object, '_ppimport_module')):
  487:         object = object._ppimport_module
  488:     elif hasattr(object, '_ppimport_attr'):
  489:         object = object._ppimport_attr
  490: 
  491:     if output is None:
  492:         output = sys.stdout
  493: 
  494:     if object is None:
  495:         info(info)
  496:     elif isinstance(object, ndarray):
  497:         _info(object, output=output)
  498:     elif isinstance(object, str):
  499:         if _namedict is None:
  500:             _namedict, _dictlist = _makenamedict(toplevel)
  501:         numfound = 0
  502:         objlist = []
  503:         for namestr in _dictlist:
  504:             try:
  505:                 obj = _namedict[namestr][object]
  506:                 if id(obj) in objlist:
  507:                     print(f"\n     *** Repeat reference found in {namestr} *** ",
  508:                           file=output
  509:                           )
  510:                 else:
  511:                     objlist.append(id(obj))
  512:                     print(f"     *** Found in {namestr} ***", file=output)
  513:                     info(obj)
  514:                     print("-" * maxwidth, file=output)
  515:                 numfound += 1
  516:             except KeyError:
  517:                 pass
  518:         if numfound == 0:
  519:             print(f"Help for {object} not found.", file=output)
  520:         else:
  521:             print("\n     "
  522:                   "*** Total of %d references found. ***" % numfound,
  523:                   file=output
  524:                   )
  525: 
  526:     elif inspect.isfunction(object) or inspect.ismethod(object):
  527:         name = object.__name__
  528:         try:
  529:             arguments = str(inspect.signature(object))
  530:         except Exception:
  531:             arguments = "()"
  532: 
  533:         if len(name + arguments) > maxwidth:
  534:             argstr = _split_line(name, arguments, maxwidth)
  535:         else:
  536:             argstr = name + arguments
  537: 
  538:         print(" " + argstr + "\n", file=output)
  539:         print(inspect.getdoc(object), file=output)
  540: 
  541:     elif inspect.isclass(object):
  542:         name = object.__name__
  543:         try:
  544:             arguments = str(inspect.signature(object))
  545:         except Exception:
  546:             arguments = "()"
  547: 
  548:         if len(name + arguments) > maxwidth:
  549:             argstr = _split_line(name, arguments, maxwidth)
  550:         else:
  551:             argstr = name + arguments
  552: 
  553:         print(" " + argstr + "\n", file=output)
  554:         doc1 = inspect.getdoc(object)
  555:         if doc1 is None:
  556:             if hasattr(object, '__init__'):
  557:                 print(inspect.getdoc(object.__init__), file=output)
  558:         else:
  559:             print(inspect.getdoc(object), file=output)
  560: 
  561:         methods = pydoc.allmethods(object)
  562: 
  563:         public_methods = [meth for meth in methods if meth[0] != '_']
  564:         if public_methods:
  565:             print("\n\nMethods:\n", file=output)
  566:             for meth in public_methods:
  567:                 thisobj = getattr(object, meth, None)
  568:                 if thisobj is not None:
  569:                     methstr, other = pydoc.splitdoc(
  570:                             inspect.getdoc(thisobj) or "None"
  571:                             )
  572:                 print(f"  {meth}  --  {methstr}", file=output)
  573: 
  574:     elif hasattr(object, '__doc__'):
  575:         print(inspect.getdoc(object), file=output)
  576: 
  577: 
  578: def safe_eval(source):
  579:     """
  580:     Protected string evaluation.
  581: 
  582:     .. deprecated:: 2.0
  583:         Use `ast.literal_eval` instead.
  584: 
  585:     Evaluate a string containing a Python literal expression without
  586:     allowing the execution of arbitrary non-literal code.
  587: 
  588:     .. warning::
  589: 
  590:         This function is identical to :py:meth:`ast.literal_eval` and
  591:         has the same security implications.  It may not always be safe
  592:         to evaluate large input strings.
  593: 
  594:     Parameters
  595:     ----------
  596:     source : str
  597:         The string to evaluate.
  598: 
  599:     Returns
  600:     -------
  601:     obj : object
  602:        The result of evaluating `source`.
  603: 
  604:     Raises
  605:     ------
  606:     SyntaxError
  607:         If the code has invalid Python syntax, or if it contains
  608:         non-literal code.
  609: 
  610:     Examples
  611:     --------
  612:     >>> np.safe_eval('1')
  613:     1
  614:     >>> np.safe_eval('[1, 2, 3]')
  615:     [1, 2, 3]
  616:     >>> np.safe_eval('{"foo": ("bar", 10.0)}')
  617:     {'foo': ('bar', 10.0)}
  618: 
  619:     >>> np.safe_eval('import os')
  620:     Traceback (most recent call last):
  621:       ...
  622:     SyntaxError: invalid syntax
  623: 
  624:     >>> np.safe_eval('open("/home/user/.ssh/id_dsa").read()')
  625:     Traceback (most recent call last):
  626:       ...
  627:     ValueError: malformed node or string: <_ast.Call object at 0x...>
  628: 
  629:     """
  630: 
  631:     # Deprecated in NumPy 2.0, 2023-07-11
  632:     warnings.warn(
  633:         "`safe_eval` is deprecated. Use `ast.literal_eval` instead. "
  634:         "Be aware of security implications, such as memory exhaustion "
  635:         "based attacks (deprecated in NumPy 2.0)",
  636:         DeprecationWarning,
  637:         stacklevel=2
  638:     )
  639: 
  640:     # Local import to speed up numpy's import time.
  641:     import ast
  642:     return ast.literal_eval(source)
  643: 
  644: 
  645: def _median_nancheck(data, result, axis):
  646:     """
  647:     Utility function to check median result from data for NaN values at the end
  648:     and return NaN in that case. Input result can also be a MaskedArray.
  649: 
  650:     Parameters
  651:     ----------
  652:     data : array
  653:         Sorted input data to median function
  654:     result : Array or MaskedArray
  655:         Result of median function.
  656:     axis : int
  657:         Axis along which the median was computed.
  658: 
  659:     Returns
  660:     -------
  661:     result : scalar or ndarray
  662:         Median or NaN in axes which contained NaN in the input.  If the input
  663:         was an array, NaN will be inserted in-place.  If a scalar, either the
  664:         input itself or a scalar NaN.
  665:     """
  666:     if data.size == 0:
  667:         return result
  668:     potential_nans = data.take(-1, axis=axis)
  669:     n = np.isnan(potential_nans)
  670:     # masked NaN values are ok, although for masked the copyto may fail for
  671:     # unmasked ones (this was always broken) when the result is a scalar.
  672:     if np.ma.isMaskedArray(n):
  673:         n = n.filled(False)
  674: 
  675:     if not n.any():
  676:         return result
  677: 
  678:     # Without given output, it is possible that the current result is a
  679:     # numpy scalar, which is not writeable.  If so, just return nan.
  680:     if isinstance(result, np.generic):
  681:         return potential_nans
  682: 
  683:     # Otherwise copy NaNs (if there are any)
  684:     np.copyto(result, potential_nans, where=n)
  685:     return result
  686: 
  687: def _opt_info():
  688:     """
  689:     Returns a string containing the CPU features supported
  690:     by the current build.
  691: 
  692:     The format of the string can be explained as follows:
  693:         - Dispatched features supported by the running machine end with `*`.
  694:         - Dispatched features not supported by the running machine
  695:           end with `?`.
  696:         - Remaining features represent the baseline.
  697: 
  698:     Returns:
  699:         str: A formatted string indicating the supported CPU features.
  700:     """
  701:     from numpy._core._multiarray_umath import (
  702:         __cpu_baseline__,
  703:         __cpu_dispatch__,
  704:         __cpu_features__,
  705:     )
  706: 
  707:     if len(__cpu_baseline__) == 0 and len(__cpu_dispatch__) == 0:
  708:         return ''
  709: 
  710:     enabled_features = ' '.join(__cpu_baseline__)
  711:     for feature in __cpu_dispatch__:
  712:         if __cpu_features__[feature]:
  713:             enabled_features += f" {feature}*"
  714:         else:
  715:             enabled_features += f" {feature}?"
  716: 
  717:     return enabled_features
  718: 
  719: def drop_metadata(dtype, /):
  720:     """
  721:     Returns the dtype unchanged if it contained no metadata or a copy of the
  722:     dtype if it (or any of its structure dtypes) contained metadata.
  723: 
  724:     This utility is used by `np.save` and `np.savez` to drop metadata before
  725:     saving.
  726: 
  727:     .. note::
  728: 
  729:         Due to its limitation this function may move to a more appropriate
  730:         home or change in the future and is considered semi-public API only.
  731: 
  732:     .. warning::
  733: 
  734:         This function does not preserve more strange things like record dtypes
  735:         and user dtypes may simply return the wrong thing.  If you need to be
  736:         sure about the latter, check the result with:
  737:         ``np.can_cast(new_dtype, dtype, casting="no")``.
  738: 
  739:     """
  740:     if dtype.fields is not None:
  741:         found_metadata = dtype.metadata is not None
  742: 
  743:         names = []
  744:         formats = []
  745:         offsets = []
  746:         titles = []
  747:         for name, field in dtype.fields.items():
  748:             field_dt = drop_metadata(field[0])
  749:             if field_dt is not field[0]:
  750:                 found_metadata = True
  751: 
  752:             names.append(name)
  753:             formats.append(field_dt)
  754:             offsets.append(field[1])
  755:             titles.append(None if len(field) < 3 else field[2])
  756: 
  757:         if not found_metadata:
  758:             return dtype
  759: 
  760:         structure = {
  761:             'names': names, 'formats': formats, 'offsets': offsets, 'titles': titles,
  762:             'itemsize': dtype.itemsize}
  763: 
  764:         # NOTE: Could pass (dtype.type, structure) to preserve record dtypes...
  765:         return np.dtype(structure, align=dtype.isalignedstruct)
  766:     elif dtype.subdtype is not None:
  767:         # subarray dtype
  768:         subdtype, shape = dtype.subdtype
  769:         new_subdtype = drop_metadata(subdtype)
  770:         if dtype.metadata is None and new_subdtype is subdtype:
  771:             return dtype
  772: 
  773:         return np.dtype((new_subdtype, shape))
  774:     else:
  775:         # Normal unstructured dtype
  776:         if dtype.metadata is None:
  777:             return dtype
  778:         # Note that `dt.str` doesn't round-trip e.g. for user-dtypes.
  779:         return np.dtype(dtype.str)
