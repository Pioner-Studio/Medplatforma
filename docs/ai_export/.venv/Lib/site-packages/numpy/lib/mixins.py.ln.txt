    1: """
    2: Mixin classes for custom array types that don't inherit from ndarray.
    3: """
    4: 
    5: __all__ = ['NDArrayOperatorsMixin']
    6: 
    7: 
    8: def _disables_array_ufunc(obj):
    9:     """True when __array_ufunc__ is set to None."""
   10:     try:
   11:         return obj.__array_ufunc__ is None
   12:     except AttributeError:
   13:         return False
   14: 
   15: 
   16: def _binary_method(ufunc, name):
   17:     """Implement a forward binary method with a ufunc, e.g., __add__."""
   18:     def func(self, other):
   19:         if _disables_array_ufunc(other):
   20:             return NotImplemented
   21:         return ufunc(self, other)
   22:     func.__name__ = f'__{name}__'
   23:     return func
   24: 
   25: 
   26: def _reflected_binary_method(ufunc, name):
   27:     """Implement a reflected binary method with a ufunc, e.g., __radd__."""
   28:     def func(self, other):
   29:         if _disables_array_ufunc(other):
   30:             return NotImplemented
   31:         return ufunc(other, self)
   32:     func.__name__ = f'__r{name}__'
   33:     return func
   34: 
   35: 
   36: def _inplace_binary_method(ufunc, name):
   37:     """Implement an in-place binary method with a ufunc, e.g., __iadd__."""
   38:     def func(self, other):
   39:         return ufunc(self, other, out=(self,))
   40:     func.__name__ = f'__i{name}__'
   41:     return func
   42: 
   43: 
   44: def _numeric_methods(ufunc, name):
   45:     """Implement forward, reflected and inplace binary methods with a ufunc."""
   46:     return (_binary_method(ufunc, name),
   47:             _reflected_binary_method(ufunc, name),
   48:             _inplace_binary_method(ufunc, name))
   49: 
   50: 
   51: def _unary_method(ufunc, name):
   52:     """Implement a unary special method with a ufunc."""
   53:     def func(self):
   54:         return ufunc(self)
   55:     func.__name__ = f'__{name}__'
   56:     return func
   57: 
   58: 
   59: class NDArrayOperatorsMixin:
   60:     """Mixin defining all operator special methods using __array_ufunc__.
   61: 
   62:     This class implements the special methods for almost all of Python's
   63:     builtin operators defined in the `operator` module, including comparisons
   64:     (``==``, ``>``, etc.) and arithmetic (``+``, ``*``, ``-``, etc.), by
   65:     deferring to the ``__array_ufunc__`` method, which subclasses must
   66:     implement.
   67: 
   68:     It is useful for writing classes that do not inherit from `numpy.ndarray`,
   69:     but that should support arithmetic and numpy universal functions like
   70:     arrays as described in :external+neps:doc:`nep-0013-ufunc-overrides`.
   71: 
   72:     As an trivial example, consider this implementation of an ``ArrayLike``
   73:     class that simply wraps a NumPy array and ensures that the result of any
   74:     arithmetic operation is also an ``ArrayLike`` object:
   75: 
   76:         >>> import numbers
   77:         >>> class ArrayLike(np.lib.mixins.NDArrayOperatorsMixin):
   78:         ...     def __init__(self, value):
   79:         ...         self.value = np.asarray(value)
   80:         ...
   81:         ...     # One might also consider adding the built-in list type to this
   82:         ...     # list, to support operations like np.add(array_like, list)
   83:         ...     _HANDLED_TYPES = (np.ndarray, numbers.Number)
   84:         ...
   85:         ...     def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):
   86:         ...         out = kwargs.get('out', ())
   87:         ...         for x in inputs + out:
   88:         ...             # Only support operations with instances of
   89:         ...             # _HANDLED_TYPES. Use ArrayLike instead of type(self)
   90:         ...             # for isinstance to allow subclasses that don't
   91:         ...             # override __array_ufunc__ to handle ArrayLike objects.
   92:         ...             if not isinstance(
   93:         ...                 x, self._HANDLED_TYPES + (ArrayLike,)
   94:         ...             ):
   95:         ...                 return NotImplemented
   96:         ...
   97:         ...         # Defer to the implementation of the ufunc
   98:         ...         # on unwrapped values.
   99:         ...         inputs = tuple(x.value if isinstance(x, ArrayLike) else x
  100:         ...                     for x in inputs)
  101:         ...         if out:
  102:         ...             kwargs['out'] = tuple(
  103:         ...                 x.value if isinstance(x, ArrayLike) else x
  104:         ...                 for x in out)
  105:         ...         result = getattr(ufunc, method)(*inputs, **kwargs)
  106:         ...
  107:         ...         if type(result) is tuple:
  108:         ...             # multiple return values
  109:         ...             return tuple(type(self)(x) for x in result)
  110:         ...         elif method == 'at':
  111:         ...             # no return value
  112:         ...             return None
  113:         ...         else:
  114:         ...             # one return value
  115:         ...             return type(self)(result)
  116:         ...
  117:         ...     def __repr__(self):
  118:         ...         return '%s(%r)' % (type(self).__name__, self.value)
  119: 
  120:     In interactions between ``ArrayLike`` objects and numbers or numpy arrays,
  121:     the result is always another ``ArrayLike``:
  122: 
  123:         >>> x = ArrayLike([1, 2, 3])
  124:         >>> x - 1
  125:         ArrayLike(array([0, 1, 2]))
  126:         >>> 1 - x
  127:         ArrayLike(array([ 0, -1, -2]))
  128:         >>> np.arange(3) - x
  129:         ArrayLike(array([-1, -1, -1]))
  130:         >>> x - np.arange(3)
  131:         ArrayLike(array([1, 1, 1]))
  132: 
  133:     Note that unlike ``numpy.ndarray``, ``ArrayLike`` does not allow operations
  134:     with arbitrary, unrecognized types. This ensures that interactions with
  135:     ArrayLike preserve a well-defined casting hierarchy.
  136: 
  137:     """
  138:     from numpy._core import umath as um
  139: 
  140:     __slots__ = ()
  141:     # Like np.ndarray, this mixin class implements "Option 1" from the ufunc
  142:     # overrides NEP.
  143: 
  144:     # comparisons don't have reflected and in-place versions
  145:     __lt__ = _binary_method(um.less, 'lt')
  146:     __le__ = _binary_method(um.less_equal, 'le')
  147:     __eq__ = _binary_method(um.equal, 'eq')
  148:     __ne__ = _binary_method(um.not_equal, 'ne')
  149:     __gt__ = _binary_method(um.greater, 'gt')
  150:     __ge__ = _binary_method(um.greater_equal, 'ge')
  151: 
  152:     # numeric methods
  153:     __add__, __radd__, __iadd__ = _numeric_methods(um.add, 'add')
  154:     __sub__, __rsub__, __isub__ = _numeric_methods(um.subtract, 'sub')
  155:     __mul__, __rmul__, __imul__ = _numeric_methods(um.multiply, 'mul')
  156:     __matmul__, __rmatmul__, __imatmul__ = _numeric_methods(
  157:         um.matmul, 'matmul')
  158:     __truediv__, __rtruediv__, __itruediv__ = _numeric_methods(
  159:         um.true_divide, 'truediv')
  160:     __floordiv__, __rfloordiv__, __ifloordiv__ = _numeric_methods(
  161:         um.floor_divide, 'floordiv')
  162:     __mod__, __rmod__, __imod__ = _numeric_methods(um.remainder, 'mod')
  163:     __divmod__ = _binary_method(um.divmod, 'divmod')
  164:     __rdivmod__ = _reflected_binary_method(um.divmod, 'divmod')
  165:     # __idivmod__ does not exist
  166:     # TODO: handle the optional third argument for __pow__?
  167:     __pow__, __rpow__, __ipow__ = _numeric_methods(um.power, 'pow')
  168:     __lshift__, __rlshift__, __ilshift__ = _numeric_methods(
  169:         um.left_shift, 'lshift')
  170:     __rshift__, __rrshift__, __irshift__ = _numeric_methods(
  171:         um.right_shift, 'rshift')
  172:     __and__, __rand__, __iand__ = _numeric_methods(um.bitwise_and, 'and')
  173:     __xor__, __rxor__, __ixor__ = _numeric_methods(um.bitwise_xor, 'xor')
  174:     __or__, __ror__, __ior__ = _numeric_methods(um.bitwise_or, 'or')
  175: 
  176:     # unary methods
  177:     __neg__ = _unary_method(um.negative, 'neg')
  178:     __pos__ = _unary_method(um.positive, 'pos')
  179:     __abs__ = _unary_method(um.absolute, 'abs')
  180:     __invert__ = _unary_method(um.invert, 'invert')
