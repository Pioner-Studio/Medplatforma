    1: import pytest
    2: 
    3: import numpy as np
    4: from numpy._core._rational_tests import rational
    5: from numpy.lib._stride_tricks_impl import (
    6:     _broadcast_shape,
    7:     as_strided,
    8:     broadcast_arrays,
    9:     broadcast_shapes,
   10:     broadcast_to,
   11:     sliding_window_view,
   12: )
   13: from numpy.testing import (
   14:     assert_,
   15:     assert_array_equal,
   16:     assert_equal,
   17:     assert_raises,
   18:     assert_raises_regex,
   19:     assert_warns,
   20: )
   21: 
   22: 
   23: def assert_shapes_correct(input_shapes, expected_shape):
   24:     # Broadcast a list of arrays with the given input shapes and check the
   25:     # common output shape.
   26: 
   27:     inarrays = [np.zeros(s) for s in input_shapes]
   28:     outarrays = broadcast_arrays(*inarrays)
   29:     outshapes = [a.shape for a in outarrays]
   30:     expected = [expected_shape] * len(inarrays)
   31:     assert_equal(outshapes, expected)
   32: 
   33: 
   34: def assert_incompatible_shapes_raise(input_shapes):
   35:     # Broadcast a list of arrays with the given (incompatible) input shapes
   36:     # and check that they raise a ValueError.
   37: 
   38:     inarrays = [np.zeros(s) for s in input_shapes]
   39:     assert_raises(ValueError, broadcast_arrays, *inarrays)
   40: 
   41: 
   42: def assert_same_as_ufunc(shape0, shape1, transposed=False, flipped=False):
   43:     # Broadcast two shapes against each other and check that the data layout
   44:     # is the same as if a ufunc did the broadcasting.
   45: 
   46:     x0 = np.zeros(shape0, dtype=int)
   47:     # Note that multiply.reduce's identity element is 1.0, so when shape1==(),
   48:     # this gives the desired n==1.
   49:     n = int(np.multiply.reduce(shape1))
   50:     x1 = np.arange(n).reshape(shape1)
   51:     if transposed:
   52:         x0 = x0.T
   53:         x1 = x1.T
   54:     if flipped:
   55:         x0 = x0[::-1]
   56:         x1 = x1[::-1]
   57:     # Use the add ufunc to do the broadcasting. Since we're adding 0s to x1, the
   58:     # result should be exactly the same as the broadcasted view of x1.
   59:     y = x0 + x1
   60:     b0, b1 = broadcast_arrays(x0, x1)
   61:     assert_array_equal(y, b1)
   62: 
   63: 
   64: def test_same():
   65:     x = np.arange(10)
   66:     y = np.arange(10)
   67:     bx, by = broadcast_arrays(x, y)
   68:     assert_array_equal(x, bx)
   69:     assert_array_equal(y, by)
   70: 
   71: def test_broadcast_kwargs():
   72:     # ensure that a TypeError is appropriately raised when
   73:     # np.broadcast_arrays() is called with any keyword
   74:     # argument other than 'subok'
   75:     x = np.arange(10)
   76:     y = np.arange(10)
   77: 
   78:     with assert_raises_regex(TypeError, 'got an unexpected keyword'):
   79:         broadcast_arrays(x, y, dtype='float64')
   80: 
   81: 
   82: def test_one_off():
   83:     x = np.array([[1, 2, 3]])
   84:     y = np.array([[1], [2], [3]])
   85:     bx, by = broadcast_arrays(x, y)
   86:     bx0 = np.array([[1, 2, 3], [1, 2, 3], [1, 2, 3]])
   87:     by0 = bx0.T
   88:     assert_array_equal(bx0, bx)
   89:     assert_array_equal(by0, by)
   90: 
   91: 
   92: def test_same_input_shapes():
   93:     # Check that the final shape is just the input shape.
   94: 
   95:     data = [
   96:         (),
   97:         (1,),
   98:         (3,),
   99:         (0, 1),
  100:         (0, 3),
  101:         (1, 0),
  102:         (3, 0),
  103:         (1, 3),
  104:         (3, 1),
  105:         (3, 3),
  106:     ]
  107:     for shape in data:
  108:         input_shapes = [shape]
  109:         # Single input.
  110:         assert_shapes_correct(input_shapes, shape)
  111:         # Double input.
  112:         input_shapes2 = [shape, shape]
  113:         assert_shapes_correct(input_shapes2, shape)
  114:         # Triple input.
  115:         input_shapes3 = [shape, shape, shape]
  116:         assert_shapes_correct(input_shapes3, shape)
  117: 
  118: 
  119: def test_two_compatible_by_ones_input_shapes():
  120:     # Check that two different input shapes of the same length, but some have
  121:     # ones, broadcast to the correct shape.
  122: 
  123:     data = [
  124:         [[(1,), (3,)], (3,)],
  125:         [[(1, 3), (3, 3)], (3, 3)],
  126:         [[(3, 1), (3, 3)], (3, 3)],
  127:         [[(1, 3), (3, 1)], (3, 3)],
  128:         [[(1, 1), (3, 3)], (3, 3)],
  129:         [[(1, 1), (1, 3)], (1, 3)],
  130:         [[(1, 1), (3, 1)], (3, 1)],
  131:         [[(1, 0), (0, 0)], (0, 0)],
  132:         [[(0, 1), (0, 0)], (0, 0)],
  133:         [[(1, 0), (0, 1)], (0, 0)],
  134:         [[(1, 1), (0, 0)], (0, 0)],
  135:         [[(1, 1), (1, 0)], (1, 0)],
  136:         [[(1, 1), (0, 1)], (0, 1)],
  137:     ]
  138:     for input_shapes, expected_shape in data:
  139:         assert_shapes_correct(input_shapes, expected_shape)
  140:         # Reverse the input shapes since broadcasting should be symmetric.
  141:         assert_shapes_correct(input_shapes[::-1], expected_shape)
  142: 
  143: 
  144: def test_two_compatible_by_prepending_ones_input_shapes():
  145:     # Check that two different input shapes (of different lengths) broadcast
  146:     # to the correct shape.
  147: 
  148:     data = [
  149:         [[(), (3,)], (3,)],
  150:         [[(3,), (3, 3)], (3, 3)],
  151:         [[(3,), (3, 1)], (3, 3)],
  152:         [[(1,), (3, 3)], (3, 3)],
  153:         [[(), (3, 3)], (3, 3)],
  154:         [[(1, 1), (3,)], (1, 3)],
  155:         [[(1,), (3, 1)], (3, 1)],
  156:         [[(1,), (1, 3)], (1, 3)],
  157:         [[(), (1, 3)], (1, 3)],
  158:         [[(), (3, 1)], (3, 1)],
  159:         [[(), (0,)], (0,)],
  160:         [[(0,), (0, 0)], (0, 0)],
  161:         [[(0,), (0, 1)], (0, 0)],
  162:         [[(1,), (0, 0)], (0, 0)],
  163:         [[(), (0, 0)], (0, 0)],
  164:         [[(1, 1), (0,)], (1, 0)],
  165:         [[(1,), (0, 1)], (0, 1)],
  166:         [[(1,), (1, 0)], (1, 0)],
  167:         [[(), (1, 0)], (1, 0)],
  168:         [[(), (0, 1)], (0, 1)],
  169:     ]
  170:     for input_shapes, expected_shape in data:
  171:         assert_shapes_correct(input_shapes, expected_shape)
  172:         # Reverse the input shapes since broadcasting should be symmetric.
  173:         assert_shapes_correct(input_shapes[::-1], expected_shape)
  174: 
  175: 
  176: def test_incompatible_shapes_raise_valueerror():
  177:     # Check that a ValueError is raised for incompatible shapes.
  178: 
  179:     data = [
  180:         [(3,), (4,)],
  181:         [(2, 3), (2,)],
  182:         [(3,), (3,), (4,)],
  183:         [(1, 3, 4), (2, 3, 3)],
  184:     ]
  185:     for input_shapes in data:
  186:         assert_incompatible_shapes_raise(input_shapes)
  187:         # Reverse the input shapes since broadcasting should be symmetric.
  188:         assert_incompatible_shapes_raise(input_shapes[::-1])
  189: 
  190: 
  191: def test_same_as_ufunc():
  192:     # Check that the data layout is the same as if a ufunc did the operation.
  193: 
  194:     data = [
  195:         [[(1,), (3,)], (3,)],
  196:         [[(1, 3), (3, 3)], (3, 3)],
  197:         [[(3, 1), (3, 3)], (3, 3)],
  198:         [[(1, 3), (3, 1)], (3, 3)],
  199:         [[(1, 1), (3, 3)], (3, 3)],
  200:         [[(1, 1), (1, 3)], (1, 3)],
  201:         [[(1, 1), (3, 1)], (3, 1)],
  202:         [[(1, 0), (0, 0)], (0, 0)],
  203:         [[(0, 1), (0, 0)], (0, 0)],
  204:         [[(1, 0), (0, 1)], (0, 0)],
  205:         [[(1, 1), (0, 0)], (0, 0)],
  206:         [[(1, 1), (1, 0)], (1, 0)],
  207:         [[(1, 1), (0, 1)], (0, 1)],
  208:         [[(), (3,)], (3,)],
  209:         [[(3,), (3, 3)], (3, 3)],
  210:         [[(3,), (3, 1)], (3, 3)],
  211:         [[(1,), (3, 3)], (3, 3)],
  212:         [[(), (3, 3)], (3, 3)],
  213:         [[(1, 1), (3,)], (1, 3)],
  214:         [[(1,), (3, 1)], (3, 1)],
  215:         [[(1,), (1, 3)], (1, 3)],
  216:         [[(), (1, 3)], (1, 3)],
  217:         [[(), (3, 1)], (3, 1)],
  218:         [[(), (0,)], (0,)],
  219:         [[(0,), (0, 0)], (0, 0)],
  220:         [[(0,), (0, 1)], (0, 0)],
  221:         [[(1,), (0, 0)], (0, 0)],
  222:         [[(), (0, 0)], (0, 0)],
  223:         [[(1, 1), (0,)], (1, 0)],
  224:         [[(1,), (0, 1)], (0, 1)],
  225:         [[(1,), (1, 0)], (1, 0)],
  226:         [[(), (1, 0)], (1, 0)],
  227:         [[(), (0, 1)], (0, 1)],
  228:     ]
  229:     for input_shapes, expected_shape in data:
  230:         assert_same_as_ufunc(input_shapes[0], input_shapes[1],
  231:                              f"Shapes: {input_shapes[0]} {input_shapes[1]}")
  232:         # Reverse the input shapes since broadcasting should be symmetric.
  233:         assert_same_as_ufunc(input_shapes[1], input_shapes[0])
  234:         # Try them transposed, too.
  235:         assert_same_as_ufunc(input_shapes[0], input_shapes[1], True)
  236:         # ... and flipped for non-rank-0 inputs in order to test negative
  237:         # strides.
  238:         if () not in input_shapes:
  239:             assert_same_as_ufunc(input_shapes[0], input_shapes[1], False, True)
  240:             assert_same_as_ufunc(input_shapes[0], input_shapes[1], True, True)
  241: 
  242: 
  243: def test_broadcast_to_succeeds():
  244:     data = [
  245:         [np.array(0), (0,), np.array(0)],
  246:         [np.array(0), (1,), np.zeros(1)],
  247:         [np.array(0), (3,), np.zeros(3)],
  248:         [np.ones(1), (1,), np.ones(1)],
  249:         [np.ones(1), (2,), np.ones(2)],
  250:         [np.ones(1), (1, 2, 3), np.ones((1, 2, 3))],
  251:         [np.arange(3), (3,), np.arange(3)],
  252:         [np.arange(3), (1, 3), np.arange(3).reshape(1, -1)],
  253:         [np.arange(3), (2, 3), np.array([[0, 1, 2], [0, 1, 2]])],
  254:         # test if shape is not a tuple
  255:         [np.ones(0), 0, np.ones(0)],
  256:         [np.ones(1), 1, np.ones(1)],
  257:         [np.ones(1), 2, np.ones(2)],
  258:         # these cases with size 0 are strange, but they reproduce the behavior
  259:         # of broadcasting with ufuncs (see test_same_as_ufunc above)
  260:         [np.ones(1), (0,), np.ones(0)],
  261:         [np.ones((1, 2)), (0, 2), np.ones((0, 2))],
  262:         [np.ones((2, 1)), (2, 0), np.ones((2, 0))],
  263:     ]
  264:     for input_array, shape, expected in data:
  265:         actual = broadcast_to(input_array, shape)
  266:         assert_array_equal(expected, actual)
  267: 
  268: 
  269: def test_broadcast_to_raises():
  270:     data = [
  271:         [(0,), ()],
  272:         [(1,), ()],
  273:         [(3,), ()],
  274:         [(3,), (1,)],
  275:         [(3,), (2,)],
  276:         [(3,), (4,)],
  277:         [(1, 2), (2, 1)],
  278:         [(1, 1), (1,)],
  279:         [(1,), -1],
  280:         [(1,), (-1,)],
  281:         [(1, 2), (-1, 2)],
  282:     ]
  283:     for orig_shape, target_shape in data:
  284:         arr = np.zeros(orig_shape)
  285:         assert_raises(ValueError, lambda: broadcast_to(arr, target_shape))
  286: 
  287: 
  288: def test_broadcast_shape():
  289:     # tests internal _broadcast_shape
  290:     # _broadcast_shape is already exercised indirectly by broadcast_arrays
  291:     # _broadcast_shape is also exercised by the public broadcast_shapes function
  292:     assert_equal(_broadcast_shape(), ())
  293:     assert_equal(_broadcast_shape([1, 2]), (2,))
  294:     assert_equal(_broadcast_shape(np.ones((1, 1))), (1, 1))
  295:     assert_equal(_broadcast_shape(np.ones((1, 1)), np.ones((3, 4))), (3, 4))
  296:     assert_equal(_broadcast_shape(*([np.ones((1, 2))] * 32)), (1, 2))
  297:     assert_equal(_broadcast_shape(*([np.ones((1, 2))] * 100)), (1, 2))
  298: 
  299:     # regression tests for gh-5862
  300:     assert_equal(_broadcast_shape(*([np.ones(2)] * 32 + [1])), (2,))
  301:     bad_args = [np.ones(2)] * 32 + [np.ones(3)] * 32
  302:     assert_raises(ValueError, lambda: _broadcast_shape(*bad_args))
  303: 
  304: 
  305: def test_broadcast_shapes_succeeds():
  306:     # tests public broadcast_shapes
  307:     data = [
  308:         [[], ()],
  309:         [[()], ()],
  310:         [[(7,)], (7,)],
  311:         [[(1, 2), (2,)], (1, 2)],
  312:         [[(1, 1)], (1, 1)],
  313:         [[(1, 1), (3, 4)], (3, 4)],
  314:         [[(6, 7), (5, 6, 1), (7,), (5, 1, 7)], (5, 6, 7)],
  315:         [[(5, 6, 1)], (5, 6, 1)],
  316:         [[(1, 3), (3, 1)], (3, 3)],
  317:         [[(1, 0), (0, 0)], (0, 0)],
  318:         [[(0, 1), (0, 0)], (0, 0)],
  319:         [[(1, 0), (0, 1)], (0, 0)],
  320:         [[(1, 1), (0, 0)], (0, 0)],
  321:         [[(1, 1), (1, 0)], (1, 0)],
  322:         [[(1, 1), (0, 1)], (0, 1)],
  323:         [[(), (0,)], (0,)],
  324:         [[(0,), (0, 0)], (0, 0)],
  325:         [[(0,), (0, 1)], (0, 0)],
  326:         [[(1,), (0, 0)], (0, 0)],
  327:         [[(), (0, 0)], (0, 0)],
  328:         [[(1, 1), (0,)], (1, 0)],
  329:         [[(1,), (0, 1)], (0, 1)],
  330:         [[(1,), (1, 0)], (1, 0)],
  331:         [[(), (1, 0)], (1, 0)],
  332:         [[(), (0, 1)], (0, 1)],
  333:         [[(1,), (3,)], (3,)],
  334:         [[2, (3, 2)], (3, 2)],
  335:     ]
  336:     for input_shapes, target_shape in data:
  337:         assert_equal(broadcast_shapes(*input_shapes), target_shape)
  338: 
  339:     assert_equal(broadcast_shapes(*([(1, 2)] * 32)), (1, 2))
  340:     assert_equal(broadcast_shapes(*([(1, 2)] * 100)), (1, 2))
  341: 
  342:     # regression tests for gh-5862
  343:     assert_equal(broadcast_shapes(*([(2,)] * 32)), (2,))
  344: 
  345: 
  346: def test_broadcast_shapes_raises():
  347:     # tests public broadcast_shapes
  348:     data = [
  349:         [(3,), (4,)],
  350:         [(2, 3), (2,)],
  351:         [(3,), (3,), (4,)],
  352:         [(1, 3, 4), (2, 3, 3)],
  353:         [(1, 2), (3, 1), (3, 2), (10, 5)],
  354:         [2, (2, 3)],
  355:     ]
  356:     for input_shapes in data:
  357:         assert_raises(ValueError, lambda: broadcast_shapes(*input_shapes))
  358: 
  359:     bad_args = [(2,)] * 32 + [(3,)] * 32
  360:     assert_raises(ValueError, lambda: broadcast_shapes(*bad_args))
  361: 
  362: 
  363: def test_as_strided():
  364:     a = np.array([None])
  365:     a_view = as_strided(a)
  366:     expected = np.array([None])
  367:     assert_array_equal(a_view, np.array([None]))
  368: 
  369:     a = np.array([1, 2, 3, 4])
  370:     a_view = as_strided(a, shape=(2,), strides=(2 * a.itemsize,))
  371:     expected = np.array([1, 3])
  372:     assert_array_equal(a_view, expected)
  373: 
  374:     a = np.array([1, 2, 3, 4])
  375:     a_view = as_strided(a, shape=(3, 4), strides=(0, 1 * a.itemsize))
  376:     expected = np.array([[1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4]])
  377:     assert_array_equal(a_view, expected)
  378: 
  379:     # Regression test for gh-5081
  380:     dt = np.dtype([('num', 'i4'), ('obj', 'O')])
  381:     a = np.empty((4,), dtype=dt)
  382:     a['num'] = np.arange(1, 5)
  383:     a_view = as_strided(a, shape=(3, 4), strides=(0, a.itemsize))
  384:     expected_num = [[1, 2, 3, 4]] * 3
  385:     expected_obj = [[None] * 4] * 3
  386:     assert_equal(a_view.dtype, dt)
  387:     assert_array_equal(expected_num, a_view['num'])
  388:     assert_array_equal(expected_obj, a_view['obj'])
  389: 
  390:     # Make sure that void types without fields are kept unchanged
  391:     a = np.empty((4,), dtype='V4')
  392:     a_view = as_strided(a, shape=(3, 4), strides=(0, a.itemsize))
  393:     assert_equal(a.dtype, a_view.dtype)
  394: 
  395:     # Make sure that the only type that could fail is properly handled
  396:     dt = np.dtype({'names': [''], 'formats': ['V4']})
  397:     a = np.empty((4,), dtype=dt)
  398:     a_view = as_strided(a, shape=(3, 4), strides=(0, a.itemsize))
  399:     assert_equal(a.dtype, a_view.dtype)
  400: 
  401:     # Custom dtypes should not be lost (gh-9161)
  402:     r = [rational(i) for i in range(4)]
  403:     a = np.array(r, dtype=rational)
  404:     a_view = as_strided(a, shape=(3, 4), strides=(0, a.itemsize))
  405:     assert_equal(a.dtype, a_view.dtype)
  406:     assert_array_equal([r] * 3, a_view)
  407: 
  408: 
  409: class TestSlidingWindowView:
  410:     def test_1d(self):
  411:         arr = np.arange(5)
  412:         arr_view = sliding_window_view(arr, 2)
  413:         expected = np.array([[0, 1],
  414:                              [1, 2],
  415:                              [2, 3],
  416:                              [3, 4]])
  417:         assert_array_equal(arr_view, expected)
  418: 
  419:     def test_2d(self):
  420:         i, j = np.ogrid[:3, :4]
  421:         arr = 10 * i + j
  422:         shape = (2, 2)
  423:         arr_view = sliding_window_view(arr, shape)
  424:         expected = np.array([[[[0, 1], [10, 11]],
  425:                               [[1, 2], [11, 12]],
  426:                               [[2, 3], [12, 13]]],
  427:                              [[[10, 11], [20, 21]],
  428:                               [[11, 12], [21, 22]],
  429:                               [[12, 13], [22, 23]]]])
  430:         assert_array_equal(arr_view, expected)
  431: 
  432:     def test_2d_with_axis(self):
  433:         i, j = np.ogrid[:3, :4]
  434:         arr = 10 * i + j
  435:         arr_view = sliding_window_view(arr, 3, 0)
  436:         expected = np.array([[[0, 10, 20],
  437:                               [1, 11, 21],
  438:                               [2, 12, 22],
  439:                               [3, 13, 23]]])
  440:         assert_array_equal(arr_view, expected)
  441: 
  442:     def test_2d_repeated_axis(self):
  443:         i, j = np.ogrid[:3, :4]
  444:         arr = 10 * i + j
  445:         arr_view = sliding_window_view(arr, (2, 3), (1, 1))
  446:         expected = np.array([[[[0, 1, 2],
  447:                                [1, 2, 3]]],
  448:                              [[[10, 11, 12],
  449:                                [11, 12, 13]]],
  450:                              [[[20, 21, 22],
  451:                                [21, 22, 23]]]])
  452:         assert_array_equal(arr_view, expected)
  453: 
  454:     def test_2d_without_axis(self):
  455:         i, j = np.ogrid[:4, :4]
  456:         arr = 10 * i + j
  457:         shape = (2, 3)
  458:         arr_view = sliding_window_view(arr, shape)
  459:         expected = np.array([[[[0, 1, 2], [10, 11, 12]],
  460:                               [[1, 2, 3], [11, 12, 13]]],
  461:                              [[[10, 11, 12], [20, 21, 22]],
  462:                               [[11, 12, 13], [21, 22, 23]]],
  463:                              [[[20, 21, 22], [30, 31, 32]],
  464:                               [[21, 22, 23], [31, 32, 33]]]])
  465:         assert_array_equal(arr_view, expected)
  466: 
  467:     def test_errors(self):
  468:         i, j = np.ogrid[:4, :4]
  469:         arr = 10 * i + j
  470:         with pytest.raises(ValueError, match='cannot contain negative values'):
  471:             sliding_window_view(arr, (-1, 3))
  472:         with pytest.raises(
  473:                 ValueError,
  474:                 match='must provide window_shape for all dimensions of `x`'):
  475:             sliding_window_view(arr, (1,))
  476:         with pytest.raises(
  477:                 ValueError,
  478:                 match='Must provide matching length window_shape and axis'):
  479:             sliding_window_view(arr, (1, 3, 4), axis=(0, 1))
  480:         with pytest.raises(
  481:                 ValueError,
  482:                 match='window shape cannot be larger than input array'):
  483:             sliding_window_view(arr, (5, 5))
  484: 
  485:     def test_writeable(self):
  486:         arr = np.arange(5)
  487:         view = sliding_window_view(arr, 2, writeable=False)
  488:         assert_(not view.flags.writeable)
  489:         with pytest.raises(
  490:                 ValueError,
  491:                 match='assignment destination is read-only'):
  492:             view[0, 0] = 3
  493:         view = sliding_window_view(arr, 2, writeable=True)
  494:         assert_(view.flags.writeable)
  495:         view[0, 1] = 3
  496:         assert_array_equal(arr, np.array([0, 3, 2, 3, 4]))
  497: 
  498:     def test_subok(self):
  499:         class MyArray(np.ndarray):
  500:             pass
  501: 
  502:         arr = np.arange(5).view(MyArray)
  503:         assert_(not isinstance(sliding_window_view(arr, 2,
  504:                                                    subok=False),
  505:                                MyArray))
  506:         assert_(isinstance(sliding_window_view(arr, 2, subok=True), MyArray))
  507:         # Default behavior
  508:         assert_(not isinstance(sliding_window_view(arr, 2), MyArray))
  509: 
  510: 
  511: def as_strided_writeable():
  512:     arr = np.ones(10)
  513:     view = as_strided(arr, writeable=False)
  514:     assert_(not view.flags.writeable)
  515: 
  516:     # Check that writeable also is fine:
  517:     view = as_strided(arr, writeable=True)
  518:     assert_(view.flags.writeable)
  519:     view[...] = 3
  520:     assert_array_equal(arr, np.full_like(arr, 3))
  521: 
  522:     # Test that things do not break down for readonly:
  523:     arr.flags.writeable = False
  524:     view = as_strided(arr, writeable=False)
  525:     view = as_strided(arr, writeable=True)
  526:     assert_(not view.flags.writeable)
  527: 
  528: 
  529: class VerySimpleSubClass(np.ndarray):
  530:     def __new__(cls, *args, **kwargs):
  531:         return np.array(*args, subok=True, **kwargs).view(cls)
  532: 
  533: 
  534: class SimpleSubClass(VerySimpleSubClass):
  535:     def __new__(cls, *args, **kwargs):
  536:         self = np.array(*args, subok=True, **kwargs).view(cls)
  537:         self.info = 'simple'
  538:         return self
  539: 
  540:     def __array_finalize__(self, obj):
  541:         self.info = getattr(obj, 'info', '') + ' finalized'
  542: 
  543: 
  544: def test_subclasses():
  545:     # test that subclass is preserved only if subok=True
  546:     a = VerySimpleSubClass([1, 2, 3, 4])
  547:     assert_(type(a) is VerySimpleSubClass)
  548:     a_view = as_strided(a, shape=(2,), strides=(2 * a.itemsize,))
  549:     assert_(type(a_view) is np.ndarray)
  550:     a_view = as_strided(a, shape=(2,), strides=(2 * a.itemsize,), subok=True)
  551:     assert_(type(a_view) is VerySimpleSubClass)
  552:     # test that if a subclass has __array_finalize__, it is used
  553:     a = SimpleSubClass([1, 2, 3, 4])
  554:     a_view = as_strided(a, shape=(2,), strides=(2 * a.itemsize,), subok=True)
  555:     assert_(type(a_view) is SimpleSubClass)
  556:     assert_(a_view.info == 'simple finalized')
  557: 
  558:     # similar tests for broadcast_arrays
  559:     b = np.arange(len(a)).reshape(-1, 1)
  560:     a_view, b_view = broadcast_arrays(a, b)
  561:     assert_(type(a_view) is np.ndarray)
  562:     assert_(type(b_view) is np.ndarray)
  563:     assert_(a_view.shape == b_view.shape)
  564:     a_view, b_view = broadcast_arrays(a, b, subok=True)
  565:     assert_(type(a_view) is SimpleSubClass)
  566:     assert_(a_view.info == 'simple finalized')
  567:     assert_(type(b_view) is np.ndarray)
  568:     assert_(a_view.shape == b_view.shape)
  569: 
  570:     # and for broadcast_to
  571:     shape = (2, 4)
  572:     a_view = broadcast_to(a, shape)
  573:     assert_(type(a_view) is np.ndarray)
  574:     assert_(a_view.shape == shape)
  575:     a_view = broadcast_to(a, shape, subok=True)
  576:     assert_(type(a_view) is SimpleSubClass)
  577:     assert_(a_view.info == 'simple finalized')
  578:     assert_(a_view.shape == shape)
  579: 
  580: 
  581: def test_writeable():
  582:     # broadcast_to should return a readonly array
  583:     original = np.array([1, 2, 3])
  584:     result = broadcast_to(original, (2, 3))
  585:     assert_equal(result.flags.writeable, False)
  586:     assert_raises(ValueError, result.__setitem__, slice(None), 0)
  587: 
  588:     # but the result of broadcast_arrays needs to be writeable, to
  589:     # preserve backwards compatibility
  590:     test_cases = [((False,), broadcast_arrays(original,)),
  591:                   ((True, False), broadcast_arrays(0, original))]
  592:     for is_broadcast, results in test_cases:
  593:         for array_is_broadcast, result in zip(is_broadcast, results):
  594:             # This will change to False in a future version
  595:             if array_is_broadcast:
  596:                 with assert_warns(FutureWarning):
  597:                     assert_equal(result.flags.writeable, True)
  598:                 with assert_warns(DeprecationWarning):
  599:                     result[:] = 0
  600:                 # Warning not emitted, writing to the array resets it
  601:                 assert_equal(result.flags.writeable, True)
  602:             else:
  603:                 # No warning:
  604:                 assert_equal(result.flags.writeable, True)
  605: 
  606:     for results in [broadcast_arrays(original),
  607:                     broadcast_arrays(0, original)]:
  608:         for result in results:
  609:             # resets the warn_on_write DeprecationWarning
  610:             result.flags.writeable = True
  611:             # check: no warning emitted
  612:             assert_equal(result.flags.writeable, True)
  613:             result[:] = 0
  614: 
  615:     # keep readonly input readonly
  616:     original.flags.writeable = False
  617:     _, result = broadcast_arrays(0, original)
  618:     assert_equal(result.flags.writeable, False)
  619: 
  620:     # regression test for GH6491
  621:     shape = (2,)
  622:     strides = [0]
  623:     tricky_array = as_strided(np.array(0), shape, strides)
  624:     other = np.zeros((1,))
  625:     first, second = broadcast_arrays(tricky_array, other)
  626:     assert_(first.shape == second.shape)
  627: 
  628: 
  629: def test_writeable_memoryview():
  630:     # The result of broadcast_arrays exports as a non-writeable memoryview
  631:     # because otherwise there is no good way to opt in to the new behaviour
  632:     # (i.e. you would need to set writeable to False explicitly).
  633:     # See gh-13929.
  634:     original = np.array([1, 2, 3])
  635: 
  636:     test_cases = [((False, ), broadcast_arrays(original,)),
  637:                   ((True, False), broadcast_arrays(0, original))]
  638:     for is_broadcast, results in test_cases:
  639:         for array_is_broadcast, result in zip(is_broadcast, results):
  640:             # This will change to False in a future version
  641:             if array_is_broadcast:
  642:                 # memoryview(result, writable=True) will give warning but cannot
  643:                 # be tested using the python API.
  644:                 assert memoryview(result).readonly
  645:             else:
  646:                 assert not memoryview(result).readonly
  647: 
  648: 
  649: def test_reference_types():
  650:     input_array = np.array('a', dtype=object)
  651:     expected = np.array(['a'] * 3, dtype=object)
  652:     actual = broadcast_to(input_array, (3,))
  653:     assert_array_equal(expected, actual)
  654: 
  655:     actual, _ = broadcast_arrays(input_array, np.ones(3))
  656:     assert_array_equal(expected, actual)
