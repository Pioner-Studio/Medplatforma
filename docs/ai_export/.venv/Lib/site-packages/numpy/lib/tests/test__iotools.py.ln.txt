    1: import time
    2: from datetime import date
    3: 
    4: import numpy as np
    5: from numpy.lib._iotools import (
    6:     LineSplitter,
    7:     NameValidator,
    8:     StringConverter,
    9:     easy_dtype,
   10:     flatten_dtype,
   11:     has_nested_fields,
   12: )
   13: from numpy.testing import (
   14:     assert_,
   15:     assert_allclose,
   16:     assert_equal,
   17:     assert_raises,
   18: )
   19: 
   20: 
   21: class TestLineSplitter:
   22:     "Tests the LineSplitter class."
   23: 
   24:     def test_no_delimiter(self):
   25:         "Test LineSplitter w/o delimiter"
   26:         strg = " 1 2 3 4  5 # test"
   27:         test = LineSplitter()(strg)
   28:         assert_equal(test, ['1', '2', '3', '4', '5'])
   29:         test = LineSplitter('')(strg)
   30:         assert_equal(test, ['1', '2', '3', '4', '5'])
   31: 
   32:     def test_space_delimiter(self):
   33:         "Test space delimiter"
   34:         strg = " 1 2 3 4  5 # test"
   35:         test = LineSplitter(' ')(strg)
   36:         assert_equal(test, ['1', '2', '3', '4', '', '5'])
   37:         test = LineSplitter('  ')(strg)
   38:         assert_equal(test, ['1 2 3 4', '5'])
   39: 
   40:     def test_tab_delimiter(self):
   41:         "Test tab delimiter"
   42:         strg = " 1\t 2\t 3\t 4\t 5  6"
   43:         test = LineSplitter('\t')(strg)
   44:         assert_equal(test, ['1', '2', '3', '4', '5  6'])
   45:         strg = " 1  2\t 3  4\t 5  6"
   46:         test = LineSplitter('\t')(strg)
   47:         assert_equal(test, ['1  2', '3  4', '5  6'])
   48: 
   49:     def test_other_delimiter(self):
   50:         "Test LineSplitter on delimiter"
   51:         strg = "1,2,3,4,,5"
   52:         test = LineSplitter(',')(strg)
   53:         assert_equal(test, ['1', '2', '3', '4', '', '5'])
   54:         #
   55:         strg = " 1,2,3,4,,5 # test"
   56:         test = LineSplitter(',')(strg)
   57:         assert_equal(test, ['1', '2', '3', '4', '', '5'])
   58: 
   59:         # gh-11028 bytes comment/delimiters should get encoded
   60:         strg = b" 1,2,3,4,,5 % test"
   61:         test = LineSplitter(delimiter=b',', comments=b'%')(strg)
   62:         assert_equal(test, ['1', '2', '3', '4', '', '5'])
   63: 
   64:     def test_constant_fixed_width(self):
   65:         "Test LineSplitter w/ fixed-width fields"
   66:         strg = "  1  2  3  4     5   # test"
   67:         test = LineSplitter(3)(strg)
   68:         assert_equal(test, ['1', '2', '3', '4', '', '5', ''])
   69:         #
   70:         strg = "  1     3  4  5  6# test"
   71:         test = LineSplitter(20)(strg)
   72:         assert_equal(test, ['1     3  4  5  6'])
   73:         #
   74:         strg = "  1     3  4  5  6# test"
   75:         test = LineSplitter(30)(strg)
   76:         assert_equal(test, ['1     3  4  5  6'])
   77: 
   78:     def test_variable_fixed_width(self):
   79:         strg = "  1     3  4  5  6# test"
   80:         test = LineSplitter((3, 6, 6, 3))(strg)
   81:         assert_equal(test, ['1', '3', '4  5', '6'])
   82:         #
   83:         strg = "  1     3  4  5  6# test"
   84:         test = LineSplitter((6, 6, 9))(strg)
   85:         assert_equal(test, ['1', '3  4', '5  6'])
   86: 
   87: # -----------------------------------------------------------------------------
   88: 
   89: 
   90: class TestNameValidator:
   91: 
   92:     def test_case_sensitivity(self):
   93:         "Test case sensitivity"
   94:         names = ['A', 'a', 'b', 'c']
   95:         test = NameValidator().validate(names)
   96:         assert_equal(test, ['A', 'a', 'b', 'c'])
   97:         test = NameValidator(case_sensitive=False).validate(names)
   98:         assert_equal(test, ['A', 'A_1', 'B', 'C'])
   99:         test = NameValidator(case_sensitive='upper').validate(names)
  100:         assert_equal(test, ['A', 'A_1', 'B', 'C'])
  101:         test = NameValidator(case_sensitive='lower').validate(names)
  102:         assert_equal(test, ['a', 'a_1', 'b', 'c'])
  103: 
  104:         # check exceptions
  105:         assert_raises(ValueError, NameValidator, case_sensitive='foobar')
  106: 
  107:     def test_excludelist(self):
  108:         "Test excludelist"
  109:         names = ['dates', 'data', 'Other Data', 'mask']
  110:         validator = NameValidator(excludelist=['dates', 'data', 'mask'])
  111:         test = validator.validate(names)
  112:         assert_equal(test, ['dates_', 'data_', 'Other_Data', 'mask_'])
  113: 
  114:     def test_missing_names(self):
  115:         "Test validate missing names"
  116:         namelist = ('a', 'b', 'c')
  117:         validator = NameValidator()
  118:         assert_equal(validator(namelist), ['a', 'b', 'c'])
  119:         namelist = ('', 'b', 'c')
  120:         assert_equal(validator(namelist), ['f0', 'b', 'c'])
  121:         namelist = ('a', 'b', '')
  122:         assert_equal(validator(namelist), ['a', 'b', 'f0'])
  123:         namelist = ('', 'f0', '')
  124:         assert_equal(validator(namelist), ['f1', 'f0', 'f2'])
  125: 
  126:     def test_validate_nb_names(self):
  127:         "Test validate nb names"
  128:         namelist = ('a', 'b', 'c')
  129:         validator = NameValidator()
  130:         assert_equal(validator(namelist, nbfields=1), ('a',))
  131:         assert_equal(validator(namelist, nbfields=5, defaultfmt="g%i"),
  132:                      ['a', 'b', 'c', 'g0', 'g1'])
  133: 
  134:     def test_validate_wo_names(self):
  135:         "Test validate no names"
  136:         namelist = None
  137:         validator = NameValidator()
  138:         assert_(validator(namelist) is None)
  139:         assert_equal(validator(namelist, nbfields=3), ['f0', 'f1', 'f2'])
  140: 
  141: # -----------------------------------------------------------------------------
  142: 
  143: 
  144: def _bytes_to_date(s):
  145:     return date(*time.strptime(s, "%Y-%m-%d")[:3])
  146: 
  147: 
  148: class TestStringConverter:
  149:     "Test StringConverter"
  150: 
  151:     def test_creation(self):
  152:         "Test creation of a StringConverter"
  153:         converter = StringConverter(int, -99999)
  154:         assert_equal(converter._status, 1)
  155:         assert_equal(converter.default, -99999)
  156: 
  157:     def test_upgrade(self):
  158:         "Tests the upgrade method."
  159: 
  160:         converter = StringConverter()
  161:         assert_equal(converter._status, 0)
  162: 
  163:         # test int
  164:         assert_equal(converter.upgrade('0'), 0)
  165:         assert_equal(converter._status, 1)
  166: 
  167:         # On systems where long defaults to 32-bit, the statuses will be
  168:         # offset by one, so we check for this here.
  169:         import numpy._core.numeric as nx
  170:         status_offset = int(nx.dtype(nx.int_).itemsize < nx.dtype(nx.int64).itemsize)
  171: 
  172:         # test int > 2**32
  173:         assert_equal(converter.upgrade('17179869184'), 17179869184)
  174:         assert_equal(converter._status, 1 + status_offset)
  175: 
  176:         # test float
  177:         assert_allclose(converter.upgrade('0.'), 0.0)
  178:         assert_equal(converter._status, 2 + status_offset)
  179: 
  180:         # test complex
  181:         assert_equal(converter.upgrade('0j'), complex('0j'))
  182:         assert_equal(converter._status, 3 + status_offset)
  183: 
  184:         # test str
  185:         # note that the longdouble type has been skipped, so the
  186:         # _status increases by 2. Everything should succeed with
  187:         # unicode conversion (8).
  188:         for s in ['a', b'a']:
  189:             res = converter.upgrade(s)
  190:             assert_(type(res) is str)
  191:             assert_equal(res, 'a')
  192:             assert_equal(converter._status, 8 + status_offset)
  193: 
  194:     def test_missing(self):
  195:         "Tests the use of missing values."
  196:         converter = StringConverter(missing_values=('missing',
  197:                                                     'missed'))
  198:         converter.upgrade('0')
  199:         assert_equal(converter('0'), 0)
  200:         assert_equal(converter(''), converter.default)
  201:         assert_equal(converter('missing'), converter.default)
  202:         assert_equal(converter('missed'), converter.default)
  203:         try:
  204:             converter('miss')
  205:         except ValueError:
  206:             pass
  207: 
  208:     def test_upgrademapper(self):
  209:         "Tests updatemapper"
  210:         dateparser = _bytes_to_date
  211:         _original_mapper = StringConverter._mapper[:]
  212:         try:
  213:             StringConverter.upgrade_mapper(dateparser, date(2000, 1, 1))
  214:             convert = StringConverter(dateparser, date(2000, 1, 1))
  215:             test = convert('2001-01-01')
  216:             assert_equal(test, date(2001, 1, 1))
  217:             test = convert('2009-01-01')
  218:             assert_equal(test, date(2009, 1, 1))
  219:             test = convert('')
  220:             assert_equal(test, date(2000, 1, 1))
  221:         finally:
  222:             StringConverter._mapper = _original_mapper
  223: 
  224:     def test_string_to_object(self):
  225:         "Make sure that string-to-object functions are properly recognized"
  226:         old_mapper = StringConverter._mapper[:]  # copy of list
  227:         conv = StringConverter(_bytes_to_date)
  228:         assert_equal(conv._mapper, old_mapper)
  229:         assert_(hasattr(conv, 'default'))
  230: 
  231:     def test_keep_default(self):
  232:         "Make sure we don't lose an explicit default"
  233:         converter = StringConverter(None, missing_values='',
  234:                                     default=-999)
  235:         converter.upgrade('3.14159265')
  236:         assert_equal(converter.default, -999)
  237:         assert_equal(converter.type, np.dtype(float))
  238:         #
  239:         converter = StringConverter(
  240:             None, missing_values='', default=0)
  241:         converter.upgrade('3.14159265')
  242:         assert_equal(converter.default, 0)
  243:         assert_equal(converter.type, np.dtype(float))
  244: 
  245:     def test_keep_default_zero(self):
  246:         "Check that we don't lose a default of 0"
  247:         converter = StringConverter(int, default=0,
  248:                                     missing_values="N/A")
  249:         assert_equal(converter.default, 0)
  250: 
  251:     def test_keep_missing_values(self):
  252:         "Check that we're not losing missing values"
  253:         converter = StringConverter(int, default=0,
  254:                                     missing_values="N/A")
  255:         assert_equal(
  256:             converter.missing_values, {'', 'N/A'})
  257: 
  258:     def test_int64_dtype(self):
  259:         "Check that int64 integer types can be specified"
  260:         converter = StringConverter(np.int64, default=0)
  261:         val = "-9223372036854775807"
  262:         assert_(converter(val) == -9223372036854775807)
  263:         val = "9223372036854775807"
  264:         assert_(converter(val) == 9223372036854775807)
  265: 
  266:     def test_uint64_dtype(self):
  267:         "Check that uint64 integer types can be specified"
  268:         converter = StringConverter(np.uint64, default=0)
  269:         val = "9223372043271415339"
  270:         assert_(converter(val) == 9223372043271415339)
  271: 
  272: 
  273: class TestMiscFunctions:
  274: 
  275:     def test_has_nested_dtype(self):
  276:         "Test has_nested_dtype"
  277:         ndtype = np.dtype(float)
  278:         assert_equal(has_nested_fields(ndtype), False)
  279:         ndtype = np.dtype([('A', '|S3'), ('B', float)])
  280:         assert_equal(has_nested_fields(ndtype), False)
  281:         ndtype = np.dtype([('A', int), ('B', [('BA', float), ('BB', '|S1')])])
  282:         assert_equal(has_nested_fields(ndtype), True)
  283: 
  284:     def test_easy_dtype(self):
  285:         "Test ndtype on dtypes"
  286:         # Simple case
  287:         ndtype = float
  288:         assert_equal(easy_dtype(ndtype), np.dtype(float))
  289:         # As string w/o names
  290:         ndtype = "i4, f8"
  291:         assert_equal(easy_dtype(ndtype),
  292:                      np.dtype([('f0', "i4"), ('f1', "f8")]))
  293:         # As string w/o names but different default format
  294:         assert_equal(easy_dtype(ndtype, defaultfmt="field_%03i"),
  295:                      np.dtype([('field_000', "i4"), ('field_001', "f8")]))
  296:         # As string w/ names
  297:         ndtype = "i4, f8"
  298:         assert_equal(easy_dtype(ndtype, names="a, b"),
  299:                      np.dtype([('a', "i4"), ('b', "f8")]))
  300:         # As string w/ names (too many)
  301:         ndtype = "i4, f8"
  302:         assert_equal(easy_dtype(ndtype, names="a, b, c"),
  303:                      np.dtype([('a', "i4"), ('b', "f8")]))
  304:         # As string w/ names (not enough)
  305:         ndtype = "i4, f8"
  306:         assert_equal(easy_dtype(ndtype, names=", b"),
  307:                      np.dtype([('f0', "i4"), ('b', "f8")]))
  308:         # ... (with different default format)
  309:         assert_equal(easy_dtype(ndtype, names="a", defaultfmt="f%02i"),
  310:                      np.dtype([('a', "i4"), ('f00', "f8")]))
  311:         # As list of tuples w/o names
  312:         ndtype = [('A', int), ('B', float)]
  313:         assert_equal(easy_dtype(ndtype), np.dtype([('A', int), ('B', float)]))
  314:         # As list of tuples w/ names
  315:         assert_equal(easy_dtype(ndtype, names="a,b"),
  316:                      np.dtype([('a', int), ('b', float)]))
  317:         # As list of tuples w/ not enough names
  318:         assert_equal(easy_dtype(ndtype, names="a"),
  319:                      np.dtype([('a', int), ('f0', float)]))
  320:         # As list of tuples w/ too many names
  321:         assert_equal(easy_dtype(ndtype, names="a,b,c"),
  322:                      np.dtype([('a', int), ('b', float)]))
  323:         # As list of types w/o names
  324:         ndtype = (int, float, float)
  325:         assert_equal(easy_dtype(ndtype),
  326:                      np.dtype([('f0', int), ('f1', float), ('f2', float)]))
  327:         # As list of types w names
  328:         ndtype = (int, float, float)
  329:         assert_equal(easy_dtype(ndtype, names="a, b, c"),
  330:                      np.dtype([('a', int), ('b', float), ('c', float)]))
  331:         # As simple dtype w/ names
  332:         ndtype = np.dtype(float)
  333:         assert_equal(easy_dtype(ndtype, names="a, b, c"),
  334:                      np.dtype([(_, float) for _ in ('a', 'b', 'c')]))
  335:         # As simple dtype w/o names (but multiple fields)
  336:         ndtype = np.dtype(float)
  337:         assert_equal(
  338:             easy_dtype(ndtype, names=['', '', ''], defaultfmt="f%02i"),
  339:             np.dtype([(_, float) for _ in ('f00', 'f01', 'f02')]))
  340: 
  341:     def test_flatten_dtype(self):
  342:         "Testing flatten_dtype"
  343:         # Standard dtype
  344:         dt = np.dtype([("a", "f8"), ("b", "f8")])
  345:         dt_flat = flatten_dtype(dt)
  346:         assert_equal(dt_flat, [float, float])
  347:         # Recursive dtype
  348:         dt = np.dtype([("a", [("aa", '|S1'), ("ab", '|S2')]), ("b", int)])
  349:         dt_flat = flatten_dtype(dt)
  350:         assert_equal(dt_flat, [np.dtype('|S1'), np.dtype('|S2'), int])
  351:         # dtype with shaped fields
  352:         dt = np.dtype([("a", (float, 2)), ("b", (int, 3))])
  353:         dt_flat = flatten_dtype(dt)
  354:         assert_equal(dt_flat, [float, int])
  355:         dt_flat = flatten_dtype(dt, True)
  356:         assert_equal(dt_flat, [float] * 2 + [int] * 3)
  357:         # dtype w/ titles
  358:         dt = np.dtype([(("a", "A"), "f8"), (("b", "B"), "f8")])
  359:         dt_flat = flatten_dtype(dt)
  360:         assert_equal(dt_flat, [float, float])
