    1: import os
    2: import urllib.request as urllib_request
    3: from shutil import rmtree
    4: from tempfile import NamedTemporaryFile, mkdtemp, mkstemp
    5: from urllib.error import URLError
    6: from urllib.parse import urlparse
    7: 
    8: import pytest
    9: 
   10: import numpy.lib._datasource as datasource
   11: from numpy.testing import assert_, assert_equal, assert_raises
   12: 
   13: 
   14: def urlopen_stub(url, data=None):
   15:     '''Stub to replace urlopen for testing.'''
   16:     if url == valid_httpurl():
   17:         tmpfile = NamedTemporaryFile(prefix='urltmp_')
   18:         return tmpfile
   19:     else:
   20:         raise URLError('Name or service not known')
   21: 
   22: 
   23: # setup and teardown
   24: old_urlopen = None
   25: 
   26: 
   27: def setup_module():
   28:     global old_urlopen
   29: 
   30:     old_urlopen = urllib_request.urlopen
   31:     urllib_request.urlopen = urlopen_stub
   32: 
   33: 
   34: def teardown_module():
   35:     urllib_request.urlopen = old_urlopen
   36: 
   37: 
   38: # A valid website for more robust testing
   39: http_path = 'http://www.google.com/'
   40: http_file = 'index.html'
   41: 
   42: http_fakepath = 'http://fake.abc.web/site/'
   43: http_fakefile = 'fake.txt'
   44: 
   45: malicious_files = ['/etc/shadow', '../../shadow',
   46:                    '..\\system.dat', 'c:\\windows\\system.dat']
   47: 
   48: magic_line = b'three is the magic number'
   49: 
   50: 
   51: # Utility functions used by many tests
   52: def valid_textfile(filedir):
   53:     # Generate and return a valid temporary file.
   54:     fd, path = mkstemp(suffix='.txt', prefix='dstmp_', dir=filedir, text=True)
   55:     os.close(fd)
   56:     return path
   57: 
   58: 
   59: def invalid_textfile(filedir):
   60:     # Generate and return an invalid filename.
   61:     fd, path = mkstemp(suffix='.txt', prefix='dstmp_', dir=filedir)
   62:     os.close(fd)
   63:     os.remove(path)
   64:     return path
   65: 
   66: 
   67: def valid_httpurl():
   68:     return http_path + http_file
   69: 
   70: 
   71: def invalid_httpurl():
   72:     return http_fakepath + http_fakefile
   73: 
   74: 
   75: def valid_baseurl():
   76:     return http_path
   77: 
   78: 
   79: def invalid_baseurl():
   80:     return http_fakepath
   81: 
   82: 
   83: def valid_httpfile():
   84:     return http_file
   85: 
   86: 
   87: def invalid_httpfile():
   88:     return http_fakefile
   89: 
   90: 
   91: class TestDataSourceOpen:
   92:     def setup_method(self):
   93:         self.tmpdir = mkdtemp()
   94:         self.ds = datasource.DataSource(self.tmpdir)
   95: 
   96:     def teardown_method(self):
   97:         rmtree(self.tmpdir)
   98:         del self.ds
   99: 
  100:     def test_ValidHTTP(self):
  101:         fh = self.ds.open(valid_httpurl())
  102:         assert_(fh)
  103:         fh.close()
  104: 
  105:     def test_InvalidHTTP(self):
  106:         url = invalid_httpurl()
  107:         assert_raises(OSError, self.ds.open, url)
  108:         try:
  109:             self.ds.open(url)
  110:         except OSError as e:
  111:             # Regression test for bug fixed in r4342.
  112:             assert_(e.errno is None)
  113: 
  114:     def test_InvalidHTTPCacheURLError(self):
  115:         assert_raises(URLError, self.ds._cache, invalid_httpurl())
  116: 
  117:     def test_ValidFile(self):
  118:         local_file = valid_textfile(self.tmpdir)
  119:         fh = self.ds.open(local_file)
  120:         assert_(fh)
  121:         fh.close()
  122: 
  123:     def test_InvalidFile(self):
  124:         invalid_file = invalid_textfile(self.tmpdir)
  125:         assert_raises(OSError, self.ds.open, invalid_file)
  126: 
  127:     def test_ValidGzipFile(self):
  128:         try:
  129:             import gzip
  130:         except ImportError:
  131:             # We don't have the gzip capabilities to test.
  132:             pytest.skip()
  133:         # Test datasource's internal file_opener for Gzip files.
  134:         filepath = os.path.join(self.tmpdir, 'foobar.txt.gz')
  135:         fp = gzip.open(filepath, 'w')
  136:         fp.write(magic_line)
  137:         fp.close()
  138:         fp = self.ds.open(filepath)
  139:         result = fp.readline()
  140:         fp.close()
  141:         assert_equal(magic_line, result)
  142: 
  143:     def test_ValidBz2File(self):
  144:         try:
  145:             import bz2
  146:         except ImportError:
  147:             # We don't have the bz2 capabilities to test.
  148:             pytest.skip()
  149:         # Test datasource's internal file_opener for BZip2 files.
  150:         filepath = os.path.join(self.tmpdir, 'foobar.txt.bz2')
  151:         fp = bz2.BZ2File(filepath, 'w')
  152:         fp.write(magic_line)
  153:         fp.close()
  154:         fp = self.ds.open(filepath)
  155:         result = fp.readline()
  156:         fp.close()
  157:         assert_equal(magic_line, result)
  158: 
  159: 
  160: class TestDataSourceExists:
  161:     def setup_method(self):
  162:         self.tmpdir = mkdtemp()
  163:         self.ds = datasource.DataSource(self.tmpdir)
  164: 
  165:     def teardown_method(self):
  166:         rmtree(self.tmpdir)
  167:         del self.ds
  168: 
  169:     def test_ValidHTTP(self):
  170:         assert_(self.ds.exists(valid_httpurl()))
  171: 
  172:     def test_InvalidHTTP(self):
  173:         assert_equal(self.ds.exists(invalid_httpurl()), False)
  174: 
  175:     def test_ValidFile(self):
  176:         # Test valid file in destpath
  177:         tmpfile = valid_textfile(self.tmpdir)
  178:         assert_(self.ds.exists(tmpfile))
  179:         # Test valid local file not in destpath
  180:         localdir = mkdtemp()
  181:         tmpfile = valid_textfile(localdir)
  182:         assert_(self.ds.exists(tmpfile))
  183:         rmtree(localdir)
  184: 
  185:     def test_InvalidFile(self):
  186:         tmpfile = invalid_textfile(self.tmpdir)
  187:         assert_equal(self.ds.exists(tmpfile), False)
  188: 
  189: 
  190: class TestDataSourceAbspath:
  191:     def setup_method(self):
  192:         self.tmpdir = os.path.abspath(mkdtemp())
  193:         self.ds = datasource.DataSource(self.tmpdir)
  194: 
  195:     def teardown_method(self):
  196:         rmtree(self.tmpdir)
  197:         del self.ds
  198: 
  199:     def test_ValidHTTP(self):
  200:         scheme, netloc, upath, pms, qry, frg = urlparse(valid_httpurl())
  201:         local_path = os.path.join(self.tmpdir, netloc,
  202:                                   upath.strip(os.sep).strip('/'))
  203:         assert_equal(local_path, self.ds.abspath(valid_httpurl()))
  204: 
  205:     def test_ValidFile(self):
  206:         tmpfile = valid_textfile(self.tmpdir)
  207:         tmpfilename = os.path.split(tmpfile)[-1]
  208:         # Test with filename only
  209:         assert_equal(tmpfile, self.ds.abspath(tmpfilename))
  210:         # Test filename with complete path
  211:         assert_equal(tmpfile, self.ds.abspath(tmpfile))
  212: 
  213:     def test_InvalidHTTP(self):
  214:         scheme, netloc, upath, pms, qry, frg = urlparse(invalid_httpurl())
  215:         invalidhttp = os.path.join(self.tmpdir, netloc,
  216:                                    upath.strip(os.sep).strip('/'))
  217:         assert_(invalidhttp != self.ds.abspath(valid_httpurl()))
  218: 
  219:     def test_InvalidFile(self):
  220:         invalidfile = valid_textfile(self.tmpdir)
  221:         tmpfile = valid_textfile(self.tmpdir)
  222:         tmpfilename = os.path.split(tmpfile)[-1]
  223:         # Test with filename only
  224:         assert_(invalidfile != self.ds.abspath(tmpfilename))
  225:         # Test filename with complete path
  226:         assert_(invalidfile != self.ds.abspath(tmpfile))
  227: 
  228:     def test_sandboxing(self):
  229:         tmpfile = valid_textfile(self.tmpdir)
  230:         tmpfilename = os.path.split(tmpfile)[-1]
  231: 
  232:         tmp_path = lambda x: os.path.abspath(self.ds.abspath(x))
  233: 
  234:         assert_(tmp_path(valid_httpurl()).startswith(self.tmpdir))
  235:         assert_(tmp_path(invalid_httpurl()).startswith(self.tmpdir))
  236:         assert_(tmp_path(tmpfile).startswith(self.tmpdir))
  237:         assert_(tmp_path(tmpfilename).startswith(self.tmpdir))
  238:         for fn in malicious_files:
  239:             assert_(tmp_path(http_path + fn).startswith(self.tmpdir))
  240:             assert_(tmp_path(fn).startswith(self.tmpdir))
  241: 
  242:     def test_windows_os_sep(self):
  243:         orig_os_sep = os.sep
  244:         try:
  245:             os.sep = '\\'
  246:             self.test_ValidHTTP()
  247:             self.test_ValidFile()
  248:             self.test_InvalidHTTP()
  249:             self.test_InvalidFile()
  250:             self.test_sandboxing()
  251:         finally:
  252:             os.sep = orig_os_sep
  253: 
  254: 
  255: class TestRepositoryAbspath:
  256:     def setup_method(self):
  257:         self.tmpdir = os.path.abspath(mkdtemp())
  258:         self.repos = datasource.Repository(valid_baseurl(), self.tmpdir)
  259: 
  260:     def teardown_method(self):
  261:         rmtree(self.tmpdir)
  262:         del self.repos
  263: 
  264:     def test_ValidHTTP(self):
  265:         scheme, netloc, upath, pms, qry, frg = urlparse(valid_httpurl())
  266:         local_path = os.path.join(self.repos._destpath, netloc,
  267:                                   upath.strip(os.sep).strip('/'))
  268:         filepath = self.repos.abspath(valid_httpfile())
  269:         assert_equal(local_path, filepath)
  270: 
  271:     def test_sandboxing(self):
  272:         tmp_path = lambda x: os.path.abspath(self.repos.abspath(x))
  273:         assert_(tmp_path(valid_httpfile()).startswith(self.tmpdir))
  274:         for fn in malicious_files:
  275:             assert_(tmp_path(http_path + fn).startswith(self.tmpdir))
  276:             assert_(tmp_path(fn).startswith(self.tmpdir))
  277: 
  278:     def test_windows_os_sep(self):
  279:         orig_os_sep = os.sep
  280:         try:
  281:             os.sep = '\\'
  282:             self.test_ValidHTTP()
  283:             self.test_sandboxing()
  284:         finally:
  285:             os.sep = orig_os_sep
  286: 
  287: 
  288: class TestRepositoryExists:
  289:     def setup_method(self):
  290:         self.tmpdir = mkdtemp()
  291:         self.repos = datasource.Repository(valid_baseurl(), self.tmpdir)
  292: 
  293:     def teardown_method(self):
  294:         rmtree(self.tmpdir)
  295:         del self.repos
  296: 
  297:     def test_ValidFile(self):
  298:         # Create local temp file
  299:         tmpfile = valid_textfile(self.tmpdir)
  300:         assert_(self.repos.exists(tmpfile))
  301: 
  302:     def test_InvalidFile(self):
  303:         tmpfile = invalid_textfile(self.tmpdir)
  304:         assert_equal(self.repos.exists(tmpfile), False)
  305: 
  306:     def test_RemoveHTTPFile(self):
  307:         assert_(self.repos.exists(valid_httpurl()))
  308: 
  309:     def test_CachedHTTPFile(self):
  310:         localfile = valid_httpurl()
  311:         # Create a locally cached temp file with an URL based
  312:         # directory structure.  This is similar to what Repository.open
  313:         # would do.
  314:         scheme, netloc, upath, pms, qry, frg = urlparse(localfile)
  315:         local_path = os.path.join(self.repos._destpath, netloc)
  316:         os.mkdir(local_path, 0o0700)
  317:         tmpfile = valid_textfile(local_path)
  318:         assert_(self.repos.exists(tmpfile))
  319: 
  320: 
  321: class TestOpenFunc:
  322:     def setup_method(self):
  323:         self.tmpdir = mkdtemp()
  324: 
  325:     def teardown_method(self):
  326:         rmtree(self.tmpdir)
  327: 
  328:     def test_DataSourceOpen(self):
  329:         local_file = valid_textfile(self.tmpdir)
  330:         # Test case where destpath is passed in
  331:         fp = datasource.open(local_file, destpath=self.tmpdir)
  332:         assert_(fp)
  333:         fp.close()
  334:         # Test case where default destpath is used
  335:         fp = datasource.open(local_file)
  336:         assert_(fp)
  337:         fp.close()
  338: 
  339: def test_del_attr_handling():
  340:     # DataSource __del__ can be called
  341:     # even if __init__ fails when the
  342:     # Exception object is caught by the
  343:     # caller as happens in refguide_check
  344:     # is_deprecated() function
  345: 
  346:     ds = datasource.DataSource()
  347:     # simulate failed __init__ by removing key attribute
  348:     # produced within __init__ and expected by __del__
  349:     del ds._istmpdest
  350:     # should not raise an AttributeError if __del__
  351:     # gracefully handles failed __init__:
  352:     ds.__del__()
