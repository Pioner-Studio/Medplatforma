    1: import pytest
    2: 
    3: import numpy as np
    4: import numpy.polynomial.polynomial as poly
    5: from numpy.testing import (
    6:     assert_,
    7:     assert_allclose,
    8:     assert_almost_equal,
    9:     assert_array_almost_equal,
   10:     assert_array_equal,
   11:     assert_equal,
   12:     assert_raises,
   13: )
   14: 
   15: # `poly1d` has some support for `np.bool` and `np.timedelta64`,
   16: # but it is limited and they are therefore excluded here
   17: TYPE_CODES = np.typecodes["AllInteger"] + np.typecodes["AllFloat"] + "O"
   18: 
   19: 
   20: class TestPolynomial:
   21:     def test_poly1d_str_and_repr(self):
   22:         p = np.poly1d([1., 2, 3])
   23:         assert_equal(repr(p), 'poly1d([1., 2., 3.])')
   24:         assert_equal(str(p),
   25:                      '   2\n'
   26:                      '1 x + 2 x + 3')
   27: 
   28:         q = np.poly1d([3., 2, 1])
   29:         assert_equal(repr(q), 'poly1d([3., 2., 1.])')
   30:         assert_equal(str(q),
   31:                      '   2\n'
   32:                      '3 x + 2 x + 1')
   33: 
   34:         r = np.poly1d([1.89999 + 2j, -3j, -5.12345678, 2 + 1j])
   35:         assert_equal(str(r),
   36:                      '            3      2\n'
   37:                      '(1.9 + 2j) x - 3j x - 5.123 x + (2 + 1j)')
   38: 
   39:         assert_equal(str(np.poly1d([-3, -2, -1])),
   40:                      '    2\n'
   41:                      '-3 x - 2 x - 1')
   42: 
   43:     def test_poly1d_resolution(self):
   44:         p = np.poly1d([1., 2, 3])
   45:         q = np.poly1d([3., 2, 1])
   46:         assert_equal(p(0), 3.0)
   47:         assert_equal(p(5), 38.0)
   48:         assert_equal(q(0), 1.0)
   49:         assert_equal(q(5), 86.0)
   50: 
   51:     def test_poly1d_math(self):
   52:         # here we use some simple coeffs to make calculations easier
   53:         p = np.poly1d([1., 2, 4])
   54:         q = np.poly1d([4., 2, 1])
   55:         assert_equal(p / q, (np.poly1d([0.25]), np.poly1d([1.5, 3.75])))
   56:         assert_equal(p.integ(), np.poly1d([1 / 3, 1., 4., 0.]))
   57:         assert_equal(p.integ(1), np.poly1d([1 / 3, 1., 4., 0.]))
   58: 
   59:         p = np.poly1d([1., 2, 3])
   60:         q = np.poly1d([3., 2, 1])
   61:         assert_equal(p * q, np.poly1d([3., 8., 14., 8., 3.]))
   62:         assert_equal(p + q, np.poly1d([4., 4., 4.]))
   63:         assert_equal(p - q, np.poly1d([-2., 0., 2.]))
   64:         assert_equal(p ** 4, np.poly1d([1., 8., 36., 104., 214., 312., 324., 216., 81.]))
   65:         assert_equal(p(q), np.poly1d([9., 12., 16., 8., 6.]))
   66:         assert_equal(q(p), np.poly1d([3., 12., 32., 40., 34.]))
   67:         assert_equal(p.deriv(), np.poly1d([2., 2.]))
   68:         assert_equal(p.deriv(2), np.poly1d([2.]))
   69:         assert_equal(np.polydiv(np.poly1d([1, 0, -1]), np.poly1d([1, 1])),
   70:                      (np.poly1d([1., -1.]), np.poly1d([0.])))
   71: 
   72:     @pytest.mark.parametrize("type_code", TYPE_CODES)
   73:     def test_poly1d_misc(self, type_code: str) -> None:
   74:         dtype = np.dtype(type_code)
   75:         ar = np.array([1, 2, 3], dtype=dtype)
   76:         p = np.poly1d(ar)
   77: 
   78:         # `__eq__`
   79:         assert_equal(np.asarray(p), ar)
   80:         assert_equal(np.asarray(p).dtype, dtype)
   81:         assert_equal(len(p), 2)
   82: 
   83:         # `__getitem__`
   84:         comparison_dct = {-1: 0, 0: 3, 1: 2, 2: 1, 3: 0}
   85:         for index, ref in comparison_dct.items():
   86:             scalar = p[index]
   87:             assert_equal(scalar, ref)
   88:             if dtype == np.object_:
   89:                 assert isinstance(scalar, int)
   90:             else:
   91:                 assert_equal(scalar.dtype, dtype)
   92: 
   93:     def test_poly1d_variable_arg(self):
   94:         q = np.poly1d([1., 2, 3], variable='y')
   95:         assert_equal(str(q),
   96:                      '   2\n'
   97:                      '1 y + 2 y + 3')
   98:         q = np.poly1d([1., 2, 3], variable='lambda')
   99:         assert_equal(str(q),
  100:                      '        2\n'
  101:                      '1 lambda + 2 lambda + 3')
  102: 
  103:     def test_poly(self):
  104:         assert_array_almost_equal(np.poly([3, -np.sqrt(2), np.sqrt(2)]),
  105:                                   [1, -3, -2, 6])
  106: 
  107:         # From matlab docs
  108:         A = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]
  109:         assert_array_almost_equal(np.poly(A), [1, -6, -72, -27])
  110: 
  111:         # Should produce real output for perfect conjugates
  112:         assert_(np.isrealobj(np.poly([+1.082j, +2.613j, -2.613j, -1.082j])))
  113:         assert_(np.isrealobj(np.poly([0 + 1j, -0 + -1j, 1 + 2j,
  114:                                       1 - 2j, 1. + 3.5j, 1 - 3.5j])))
  115:         assert_(np.isrealobj(np.poly([1j, -1j, 1 + 2j, 1 - 2j, 1 + 3j, 1 - 3.j])))
  116:         assert_(np.isrealobj(np.poly([1j, -1j, 1 + 2j, 1 - 2j])))
  117:         assert_(np.isrealobj(np.poly([1j, -1j, 2j, -2j])))
  118:         assert_(np.isrealobj(np.poly([1j, -1j])))
  119:         assert_(np.isrealobj(np.poly([1, -1])))
  120: 
  121:         assert_(np.iscomplexobj(np.poly([1j, -1.0000001j])))
  122: 
  123:         np.random.seed(42)
  124:         a = np.random.randn(100) + 1j * np.random.randn(100)
  125:         assert_(np.isrealobj(np.poly(np.concatenate((a, np.conjugate(a))))))
  126: 
  127:     def test_roots(self):
  128:         assert_array_equal(np.roots([1, 0, 0]), [0, 0])
  129: 
  130:         # Testing for larger root values
  131:         for i in np.logspace(10, 25, num=1000, base=10):
  132:             tgt = np.array([-1, 1, i])
  133:             res = np.sort(np.roots(poly.polyfromroots(tgt)[::-1]))
  134:             assert_almost_equal(res, tgt, 14 - int(np.log10(i)))    # Adapting the expected precision according to the root value, to take into account numerical calculation error
  135: 
  136:         for i in np.logspace(10, 25, num=1000, base=10):
  137:             tgt = np.array([-1, 1.01, i])
  138:             res = np.sort(np.roots(poly.polyfromroots(tgt)[::-1]))
  139:             assert_almost_equal(res, tgt, 14 - int(np.log10(i)))    # Adapting the expected precision according to the root value, to take into account numerical calculation error
  140: 
  141:     def test_str_leading_zeros(self):
  142:         p = np.poly1d([4, 3, 2, 1])
  143:         p[3] = 0
  144:         assert_equal(str(p),
  145:                      "   2\n"
  146:                      "3 x + 2 x + 1")
  147: 
  148:         p = np.poly1d([1, 2])
  149:         p[0] = 0
  150:         p[1] = 0
  151:         assert_equal(str(p), " \n0")
  152: 
  153:     def test_polyfit(self):
  154:         c = np.array([3., 2., 1.])
  155:         x = np.linspace(0, 2, 7)
  156:         y = np.polyval(c, x)
  157:         err = [1, -1, 1, -1, 1, -1, 1]
  158:         weights = np.arange(8, 1, -1)**2 / 7.0
  159: 
  160:         # Check exception when too few points for variance estimate. Note that
  161:         # the estimate requires the number of data points to exceed
  162:         # degree + 1
  163:         assert_raises(ValueError, np.polyfit,
  164:                       [1], [1], deg=0, cov=True)
  165: 
  166:         # check 1D case
  167:         m, cov = np.polyfit(x, y + err, 2, cov=True)
  168:         est = [3.8571, 0.2857, 1.619]
  169:         assert_almost_equal(est, m, decimal=4)
  170:         val0 = [[ 1.4694, -2.9388,  0.8163],
  171:                 [-2.9388,  6.3673, -2.1224],
  172:                 [ 0.8163, -2.1224,  1.161 ]]  # noqa: E202
  173:         assert_almost_equal(val0, cov, decimal=4)
  174: 
  175:         m2, cov2 = np.polyfit(x, y + err, 2, w=weights, cov=True)
  176:         assert_almost_equal([4.8927, -1.0177, 1.7768], m2, decimal=4)
  177:         val = [[ 4.3964, -5.0052,  0.4878],
  178:                [-5.0052,  6.8067, -0.9089],
  179:                [ 0.4878, -0.9089,  0.3337]]
  180:         assert_almost_equal(val, cov2, decimal=4)
  181: 
  182:         m3, cov3 = np.polyfit(x, y + err, 2, w=weights, cov="unscaled")
  183:         assert_almost_equal([4.8927, -1.0177, 1.7768], m3, decimal=4)
  184:         val = [[ 0.1473, -0.1677,  0.0163],
  185:                [-0.1677,  0.228 , -0.0304],  # noqa: E203
  186:                [ 0.0163, -0.0304,  0.0112]]
  187:         assert_almost_equal(val, cov3, decimal=4)
  188: 
  189:         # check 2D (n,1) case
  190:         y = y[:, np.newaxis]
  191:         c = c[:, np.newaxis]
  192:         assert_almost_equal(c, np.polyfit(x, y, 2))
  193:         # check 2D (n,2) case
  194:         yy = np.concatenate((y, y), axis=1)
  195:         cc = np.concatenate((c, c), axis=1)
  196:         assert_almost_equal(cc, np.polyfit(x, yy, 2))
  197: 
  198:         m, cov = np.polyfit(x, yy + np.array(err)[:, np.newaxis], 2, cov=True)
  199:         assert_almost_equal(est, m[:, 0], decimal=4)
  200:         assert_almost_equal(est, m[:, 1], decimal=4)
  201:         assert_almost_equal(val0, cov[:, :, 0], decimal=4)
  202:         assert_almost_equal(val0, cov[:, :, 1], decimal=4)
  203: 
  204:         # check order 1 (deg=0) case, were the analytic results are simple
  205:         np.random.seed(123)
  206:         y = np.random.normal(size=(4, 10000))
  207:         mean, cov = np.polyfit(np.zeros(y.shape[0]), y, deg=0, cov=True)
  208:         # Should get sigma_mean = sigma/sqrt(N) = 1./sqrt(4) = 0.5.
  209:         assert_allclose(mean.std(), 0.5, atol=0.01)
  210:         assert_allclose(np.sqrt(cov.mean()), 0.5, atol=0.01)
  211:         # Without scaling, since reduced chi2 is 1, the result should be the same.
  212:         mean, cov = np.polyfit(np.zeros(y.shape[0]), y, w=np.ones(y.shape[0]),
  213:                                deg=0, cov="unscaled")
  214:         assert_allclose(mean.std(), 0.5, atol=0.01)
  215:         assert_almost_equal(np.sqrt(cov.mean()), 0.5)
  216:         # If we estimate our errors wrong, no change with scaling:
  217:         w = np.full(y.shape[0], 1. / 0.5)
  218:         mean, cov = np.polyfit(np.zeros(y.shape[0]), y, w=w, deg=0, cov=True)
  219:         assert_allclose(mean.std(), 0.5, atol=0.01)
  220:         assert_allclose(np.sqrt(cov.mean()), 0.5, atol=0.01)
  221:         # But if we do not scale, our estimate for the error in the mean will
  222:         # differ.
  223:         mean, cov = np.polyfit(np.zeros(y.shape[0]), y, w=w, deg=0, cov="unscaled")
  224:         assert_allclose(mean.std(), 0.5, atol=0.01)
  225:         assert_almost_equal(np.sqrt(cov.mean()), 0.25)
  226: 
  227:     def test_objects(self):
  228:         from decimal import Decimal
  229:         p = np.poly1d([Decimal('4.0'), Decimal('3.0'), Decimal('2.0')])
  230:         p2 = p * Decimal('1.333333333333333')
  231:         assert_(p2[1] == Decimal("3.9999999999999990"))
  232:         p2 = p.deriv()
  233:         assert_(p2[1] == Decimal('8.0'))
  234:         p2 = p.integ()
  235:         assert_(p2[3] == Decimal("1.333333333333333333333333333"))
  236:         assert_(p2[2] == Decimal('1.5'))
  237:         assert_(np.issubdtype(p2.coeffs.dtype, np.object_))
  238:         p = np.poly([Decimal(1), Decimal(2)])
  239:         assert_equal(np.poly([Decimal(1), Decimal(2)]),
  240:                      [1, Decimal(-3), Decimal(2)])
  241: 
  242:     def test_complex(self):
  243:         p = np.poly1d([3j, 2j, 1j])
  244:         p2 = p.integ()
  245:         assert_((p2.coeffs == [1j, 1j, 1j, 0]).all())
  246:         p2 = p.deriv()
  247:         assert_((p2.coeffs == [6j, 2j]).all())
  248: 
  249:     def test_integ_coeffs(self):
  250:         p = np.poly1d([3, 2, 1])
  251:         p2 = p.integ(3, k=[9, 7, 6])
  252:         assert_(
  253:             (p2.coeffs == [1 / 4. / 5., 1 / 3. / 4., 1 / 2. / 3., 9 / 1. / 2., 7, 6]).all())
  254: 
  255:     def test_zero_dims(self):
  256:         try:
  257:             np.poly(np.zeros((0, 0)))
  258:         except ValueError:
  259:             pass
  260: 
  261:     def test_poly_int_overflow(self):
  262:         """
  263:         Regression test for gh-5096.
  264:         """
  265:         v = np.arange(1, 21)
  266:         assert_almost_equal(np.poly(v), np.poly(np.diag(v)))
  267: 
  268:     def test_zero_poly_dtype(self):
  269:         """
  270:         Regression test for gh-16354.
  271:         """
  272:         z = np.array([0, 0, 0])
  273:         p = np.poly1d(z.astype(np.int64))
  274:         assert_equal(p.coeffs.dtype, np.int64)
  275: 
  276:         p = np.poly1d(z.astype(np.float32))
  277:         assert_equal(p.coeffs.dtype, np.float32)
  278: 
  279:         p = np.poly1d(z.astype(np.complex64))
  280:         assert_equal(p.coeffs.dtype, np.complex64)
  281: 
  282:     def test_poly_eq(self):
  283:         p = np.poly1d([1, 2, 3])
  284:         p2 = np.poly1d([1, 2, 4])
  285:         assert_equal(p == None, False)  # noqa: E711
  286:         assert_equal(p != None, True)  # noqa: E711
  287:         assert_equal(p == p, True)
  288:         assert_equal(p == p2, False)
  289:         assert_equal(p != p2, True)
  290: 
  291:     def test_polydiv(self):
  292:         b = np.poly1d([2, 6, 6, 1])
  293:         a = np.poly1d([-1j, (1 + 2j), -(2 + 1j), 1])
  294:         q, r = np.polydiv(b, a)
  295:         assert_equal(q.coeffs.dtype, np.complex128)
  296:         assert_equal(r.coeffs.dtype, np.complex128)
  297:         assert_equal(q * a + r, b)
  298: 
  299:         c = [1, 2, 3]
  300:         d = np.poly1d([1, 2, 3])
  301:         s, t = np.polydiv(c, d)
  302:         assert isinstance(s, np.poly1d)
  303:         assert isinstance(t, np.poly1d)
  304:         u, v = np.polydiv(d, c)
  305:         assert isinstance(u, np.poly1d)
  306:         assert isinstance(v, np.poly1d)
  307: 
  308:     def test_poly_coeffs_mutable(self):
  309:         """ Coefficients should be modifiable """
  310:         p = np.poly1d([1, 2, 3])
  311: 
  312:         p.coeffs += 1
  313:         assert_equal(p.coeffs, [2, 3, 4])
  314: 
  315:         p.coeffs[2] += 10
  316:         assert_equal(p.coeffs, [2, 3, 14])
  317: 
  318:         # this never used to be allowed - let's not add features to deprecated
  319:         # APIs
  320:         assert_raises(AttributeError, setattr, p, 'coeffs', np.array(1))
