    1: # doctest
    2: r''' Test the .npy file format.
    3: 
    4: Set up:
    5: 
    6:     >>> import sys
    7:     >>> from io import BytesIO
    8:     >>> from numpy.lib import format
    9:     >>>
   10:     >>> scalars = [
   11:     ...     np.uint8,
   12:     ...     np.int8,
   13:     ...     np.uint16,
   14:     ...     np.int16,
   15:     ...     np.uint32,
   16:     ...     np.int32,
   17:     ...     np.uint64,
   18:     ...     np.int64,
   19:     ...     np.float32,
   20:     ...     np.float64,
   21:     ...     np.complex64,
   22:     ...     np.complex128,
   23:     ...     object,
   24:     ... ]
   25:     >>>
   26:     >>> basic_arrays = []
   27:     >>>
   28:     >>> for scalar in scalars:
   29:     ...     for endian in '<>':
   30:     ...         dtype = np.dtype(scalar).newbyteorder(endian)
   31:     ...         basic = np.arange(15).astype(dtype)
   32:     ...         basic_arrays.extend([
   33:     ...             np.array([], dtype=dtype),
   34:     ...             np.array(10, dtype=dtype),
   35:     ...             basic,
   36:     ...             basic.reshape((3,5)),
   37:     ...             basic.reshape((3,5)).T,
   38:     ...             basic.reshape((3,5))[::-1,::2],
   39:     ...         ])
   40:     ...
   41:     >>>
   42:     >>> Pdescr = [
   43:     ...     ('x', 'i4', (2,)),
   44:     ...     ('y', 'f8', (2, 2)),
   45:     ...     ('z', 'u1')]
   46:     >>>
   47:     >>>
   48:     >>> PbufferT = [
   49:     ...     ([3,2], [[6.,4.],[6.,4.]], 8),
   50:     ...     ([4,3], [[7.,5.],[7.,5.]], 9),
   51:     ...     ]
   52:     >>>
   53:     >>>
   54:     >>> Ndescr = [
   55:     ...     ('x', 'i4', (2,)),
   56:     ...     ('Info', [
   57:     ...         ('value', 'c16'),
   58:     ...         ('y2', 'f8'),
   59:     ...         ('Info2', [
   60:     ...             ('name', 'S2'),
   61:     ...             ('value', 'c16', (2,)),
   62:     ...             ('y3', 'f8', (2,)),
   63:     ...             ('z3', 'u4', (2,))]),
   64:     ...         ('name', 'S2'),
   65:     ...         ('z2', 'b1')]),
   66:     ...     ('color', 'S2'),
   67:     ...     ('info', [
   68:     ...         ('Name', 'U8'),
   69:     ...         ('Value', 'c16')]),
   70:     ...     ('y', 'f8', (2, 2)),
   71:     ...     ('z', 'u1')]
   72:     >>>
   73:     >>>
   74:     >>> NbufferT = [
   75:     ...     ([3,2], (6j, 6., ('nn', [6j,4j], [6.,4.], [1,2]), 'NN', True), 'cc', ('NN', 6j), [[6.,4.],[6.,4.]], 8),
   76:     ...     ([4,3], (7j, 7., ('oo', [7j,5j], [7.,5.], [2,1]), 'OO', False), 'dd', ('OO', 7j), [[7.,5.],[7.,5.]], 9),
   77:     ...     ]
   78:     >>>
   79:     >>>
   80:     >>> record_arrays = [
   81:     ...     np.array(PbufferT, dtype=np.dtype(Pdescr).newbyteorder('<')),
   82:     ...     np.array(NbufferT, dtype=np.dtype(Ndescr).newbyteorder('<')),
   83:     ...     np.array(PbufferT, dtype=np.dtype(Pdescr).newbyteorder('>')),
   84:     ...     np.array(NbufferT, dtype=np.dtype(Ndescr).newbyteorder('>')),
   85:     ... ]
   86: 
   87: Test the magic string writing.
   88: 
   89:     >>> format.magic(1, 0)
   90:     '\x93NUMPY\x01\x00'
   91:     >>> format.magic(0, 0)
   92:     '\x93NUMPY\x00\x00'
   93:     >>> format.magic(255, 255)
   94:     '\x93NUMPY\xff\xff'
   95:     >>> format.magic(2, 5)
   96:     '\x93NUMPY\x02\x05'
   97: 
   98: Test the magic string reading.
   99: 
  100:     >>> format.read_magic(BytesIO(format.magic(1, 0)))
  101:     (1, 0)
  102:     >>> format.read_magic(BytesIO(format.magic(0, 0)))
  103:     (0, 0)
  104:     >>> format.read_magic(BytesIO(format.magic(255, 255)))
  105:     (255, 255)
  106:     >>> format.read_magic(BytesIO(format.magic(2, 5)))
  107:     (2, 5)
  108: 
  109: Test the header writing.
  110: 
  111:     >>> for arr in basic_arrays + record_arrays:
  112:     ...     f = BytesIO()
  113:     ...     format.write_array_header_1_0(f, arr)   # XXX: arr is not a dict, items gets called on it
  114:     ...     print(repr(f.getvalue()))
  115:     ...
  116:     "F\x00{'descr': '|u1', 'fortran_order': False, 'shape': (0,)}              \n"
  117:     "F\x00{'descr': '|u1', 'fortran_order': False, 'shape': ()}                \n"
  118:     "F\x00{'descr': '|u1', 'fortran_order': False, 'shape': (15,)}             \n"
  119:     "F\x00{'descr': '|u1', 'fortran_order': False, 'shape': (3, 5)}            \n"
  120:     "F\x00{'descr': '|u1', 'fortran_order': True, 'shape': (5, 3)}             \n"
  121:     "F\x00{'descr': '|u1', 'fortran_order': False, 'shape': (3, 3)}            \n"
  122:     "F\x00{'descr': '|u1', 'fortran_order': False, 'shape': (0,)}              \n"
  123:     "F\x00{'descr': '|u1', 'fortran_order': False, 'shape': ()}                \n"
  124:     "F\x00{'descr': '|u1', 'fortran_order': False, 'shape': (15,)}             \n"
  125:     "F\x00{'descr': '|u1', 'fortran_order': False, 'shape': (3, 5)}            \n"
  126:     "F\x00{'descr': '|u1', 'fortran_order': True, 'shape': (5, 3)}             \n"
  127:     "F\x00{'descr': '|u1', 'fortran_order': False, 'shape': (3, 3)}            \n"
  128:     "F\x00{'descr': '|i1', 'fortran_order': False, 'shape': (0,)}              \n"
  129:     "F\x00{'descr': '|i1', 'fortran_order': False, 'shape': ()}                \n"
  130:     "F\x00{'descr': '|i1', 'fortran_order': False, 'shape': (15,)}             \n"
  131:     "F\x00{'descr': '|i1', 'fortran_order': False, 'shape': (3, 5)}            \n"
  132:     "F\x00{'descr': '|i1', 'fortran_order': True, 'shape': (5, 3)}             \n"
  133:     "F\x00{'descr': '|i1', 'fortran_order': False, 'shape': (3, 3)}            \n"
  134:     "F\x00{'descr': '|i1', 'fortran_order': False, 'shape': (0,)}              \n"
  135:     "F\x00{'descr': '|i1', 'fortran_order': False, 'shape': ()}                \n"
  136:     "F\x00{'descr': '|i1', 'fortran_order': False, 'shape': (15,)}             \n"
  137:     "F\x00{'descr': '|i1', 'fortran_order': False, 'shape': (3, 5)}            \n"
  138:     "F\x00{'descr': '|i1', 'fortran_order': True, 'shape': (5, 3)}             \n"
  139:     "F\x00{'descr': '|i1', 'fortran_order': False, 'shape': (3, 3)}            \n"
  140:     "F\x00{'descr': '<u2', 'fortran_order': False, 'shape': (0,)}              \n"
  141:     "F\x00{'descr': '<u2', 'fortran_order': False, 'shape': ()}                \n"
  142:     "F\x00{'descr': '<u2', 'fortran_order': False, 'shape': (15,)}             \n"
  143:     "F\x00{'descr': '<u2', 'fortran_order': False, 'shape': (3, 5)}            \n"
  144:     "F\x00{'descr': '<u2', 'fortran_order': True, 'shape': (5, 3)}             \n"
  145:     "F\x00{'descr': '<u2', 'fortran_order': False, 'shape': (3, 3)}            \n"
  146:     "F\x00{'descr': '>u2', 'fortran_order': False, 'shape': (0,)}              \n"
  147:     "F\x00{'descr': '>u2', 'fortran_order': False, 'shape': ()}                \n"
  148:     "F\x00{'descr': '>u2', 'fortran_order': False, 'shape': (15,)}             \n"
  149:     "F\x00{'descr': '>u2', 'fortran_order': False, 'shape': (3, 5)}            \n"
  150:     "F\x00{'descr': '>u2', 'fortran_order': True, 'shape': (5, 3)}             \n"
  151:     "F\x00{'descr': '>u2', 'fortran_order': False, 'shape': (3, 3)}            \n"
  152:     "F\x00{'descr': '<i2', 'fortran_order': False, 'shape': (0,)}              \n"
  153:     "F\x00{'descr': '<i2', 'fortran_order': False, 'shape': ()}                \n"
  154:     "F\x00{'descr': '<i2', 'fortran_order': False, 'shape': (15,)}             \n"
  155:     "F\x00{'descr': '<i2', 'fortran_order': False, 'shape': (3, 5)}            \n"
  156:     "F\x00{'descr': '<i2', 'fortran_order': True, 'shape': (5, 3)}             \n"
  157:     "F\x00{'descr': '<i2', 'fortran_order': False, 'shape': (3, 3)}            \n"
  158:     "F\x00{'descr': '>i2', 'fortran_order': False, 'shape': (0,)}              \n"
  159:     "F\x00{'descr': '>i2', 'fortran_order': False, 'shape': ()}                \n"
  160:     "F\x00{'descr': '>i2', 'fortran_order': False, 'shape': (15,)}             \n"
  161:     "F\x00{'descr': '>i2', 'fortran_order': False, 'shape': (3, 5)}            \n"
  162:     "F\x00{'descr': '>i2', 'fortran_order': True, 'shape': (5, 3)}             \n"
  163:     "F\x00{'descr': '>i2', 'fortran_order': False, 'shape': (3, 3)}            \n"
  164:     "F\x00{'descr': '<u4', 'fortran_order': False, 'shape': (0,)}              \n"
  165:     "F\x00{'descr': '<u4', 'fortran_order': False, 'shape': ()}                \n"
  166:     "F\x00{'descr': '<u4', 'fortran_order': False, 'shape': (15,)}             \n"
  167:     "F\x00{'descr': '<u4', 'fortran_order': False, 'shape': (3, 5)}            \n"
  168:     "F\x00{'descr': '<u4', 'fortran_order': True, 'shape': (5, 3)}             \n"
  169:     "F\x00{'descr': '<u4', 'fortran_order': False, 'shape': (3, 3)}            \n"
  170:     "F\x00{'descr': '>u4', 'fortran_order': False, 'shape': (0,)}              \n"
  171:     "F\x00{'descr': '>u4', 'fortran_order': False, 'shape': ()}                \n"
  172:     "F\x00{'descr': '>u4', 'fortran_order': False, 'shape': (15,)}             \n"
  173:     "F\x00{'descr': '>u4', 'fortran_order': False, 'shape': (3, 5)}            \n"
  174:     "F\x00{'descr': '>u4', 'fortran_order': True, 'shape': (5, 3)}             \n"
  175:     "F\x00{'descr': '>u4', 'fortran_order': False, 'shape': (3, 3)}            \n"
  176:     "F\x00{'descr': '<i4', 'fortran_order': False, 'shape': (0,)}              \n"
  177:     "F\x00{'descr': '<i4', 'fortran_order': False, 'shape': ()}                \n"
  178:     "F\x00{'descr': '<i4', 'fortran_order': False, 'shape': (15,)}             \n"
  179:     "F\x00{'descr': '<i4', 'fortran_order': False, 'shape': (3, 5)}            \n"
  180:     "F\x00{'descr': '<i4', 'fortran_order': True, 'shape': (5, 3)}             \n"
  181:     "F\x00{'descr': '<i4', 'fortran_order': False, 'shape': (3, 3)}            \n"
  182:     "F\x00{'descr': '>i4', 'fortran_order': False, 'shape': (0,)}              \n"
  183:     "F\x00{'descr': '>i4', 'fortran_order': False, 'shape': ()}                \n"
  184:     "F\x00{'descr': '>i4', 'fortran_order': False, 'shape': (15,)}             \n"
  185:     "F\x00{'descr': '>i4', 'fortran_order': False, 'shape': (3, 5)}            \n"
  186:     "F\x00{'descr': '>i4', 'fortran_order': True, 'shape': (5, 3)}             \n"
  187:     "F\x00{'descr': '>i4', 'fortran_order': False, 'shape': (3, 3)}            \n"
  188:     "F\x00{'descr': '<u8', 'fortran_order': False, 'shape': (0,)}              \n"
  189:     "F\x00{'descr': '<u8', 'fortran_order': False, 'shape': ()}                \n"
  190:     "F\x00{'descr': '<u8', 'fortran_order': False, 'shape': (15,)}             \n"
  191:     "F\x00{'descr': '<u8', 'fortran_order': False, 'shape': (3, 5)}            \n"
  192:     "F\x00{'descr': '<u8', 'fortran_order': True, 'shape': (5, 3)}             \n"
  193:     "F\x00{'descr': '<u8', 'fortran_order': False, 'shape': (3, 3)}            \n"
  194:     "F\x00{'descr': '>u8', 'fortran_order': False, 'shape': (0,)}              \n"
  195:     "F\x00{'descr': '>u8', 'fortran_order': False, 'shape': ()}                \n"
  196:     "F\x00{'descr': '>u8', 'fortran_order': False, 'shape': (15,)}             \n"
  197:     "F\x00{'descr': '>u8', 'fortran_order': False, 'shape': (3, 5)}            \n"
  198:     "F\x00{'descr': '>u8', 'fortran_order': True, 'shape': (5, 3)}             \n"
  199:     "F\x00{'descr': '>u8', 'fortran_order': False, 'shape': (3, 3)}            \n"
  200:     "F\x00{'descr': '<i8', 'fortran_order': False, 'shape': (0,)}              \n"
  201:     "F\x00{'descr': '<i8', 'fortran_order': False, 'shape': ()}                \n"
  202:     "F\x00{'descr': '<i8', 'fortran_order': False, 'shape': (15,)}             \n"
  203:     "F\x00{'descr': '<i8', 'fortran_order': False, 'shape': (3, 5)}            \n"
  204:     "F\x00{'descr': '<i8', 'fortran_order': True, 'shape': (5, 3)}             \n"
  205:     "F\x00{'descr': '<i8', 'fortran_order': False, 'shape': (3, 3)}            \n"
  206:     "F\x00{'descr': '>i8', 'fortran_order': False, 'shape': (0,)}              \n"
  207:     "F\x00{'descr': '>i8', 'fortran_order': False, 'shape': ()}                \n"
  208:     "F\x00{'descr': '>i8', 'fortran_order': False, 'shape': (15,)}             \n"
  209:     "F\x00{'descr': '>i8', 'fortran_order': False, 'shape': (3, 5)}            \n"
  210:     "F\x00{'descr': '>i8', 'fortran_order': True, 'shape': (5, 3)}             \n"
  211:     "F\x00{'descr': '>i8', 'fortran_order': False, 'shape': (3, 3)}            \n"
  212:     "F\x00{'descr': '<f4', 'fortran_order': False, 'shape': (0,)}              \n"
  213:     "F\x00{'descr': '<f4', 'fortran_order': False, 'shape': ()}                \n"
  214:     "F\x00{'descr': '<f4', 'fortran_order': False, 'shape': (15,)}             \n"
  215:     "F\x00{'descr': '<f4', 'fortran_order': False, 'shape': (3, 5)}            \n"
  216:     "F\x00{'descr': '<f4', 'fortran_order': True, 'shape': (5, 3)}             \n"
  217:     "F\x00{'descr': '<f4', 'fortran_order': False, 'shape': (3, 3)}            \n"
  218:     "F\x00{'descr': '>f4', 'fortran_order': False, 'shape': (0,)}              \n"
  219:     "F\x00{'descr': '>f4', 'fortran_order': False, 'shape': ()}                \n"
  220:     "F\x00{'descr': '>f4', 'fortran_order': False, 'shape': (15,)}             \n"
  221:     "F\x00{'descr': '>f4', 'fortran_order': False, 'shape': (3, 5)}            \n"
  222:     "F\x00{'descr': '>f4', 'fortran_order': True, 'shape': (5, 3)}             \n"
  223:     "F\x00{'descr': '>f4', 'fortran_order': False, 'shape': (3, 3)}            \n"
  224:     "F\x00{'descr': '<f8', 'fortran_order': False, 'shape': (0,)}              \n"
  225:     "F\x00{'descr': '<f8', 'fortran_order': False, 'shape': ()}                \n"
  226:     "F\x00{'descr': '<f8', 'fortran_order': False, 'shape': (15,)}             \n"
  227:     "F\x00{'descr': '<f8', 'fortran_order': False, 'shape': (3, 5)}            \n"
  228:     "F\x00{'descr': '<f8', 'fortran_order': True, 'shape': (5, 3)}             \n"
  229:     "F\x00{'descr': '<f8', 'fortran_order': False, 'shape': (3, 3)}            \n"
  230:     "F\x00{'descr': '>f8', 'fortran_order': False, 'shape': (0,)}              \n"
  231:     "F\x00{'descr': '>f8', 'fortran_order': False, 'shape': ()}                \n"
  232:     "F\x00{'descr': '>f8', 'fortran_order': False, 'shape': (15,)}             \n"
  233:     "F\x00{'descr': '>f8', 'fortran_order': False, 'shape': (3, 5)}            \n"
  234:     "F\x00{'descr': '>f8', 'fortran_order': True, 'shape': (5, 3)}             \n"
  235:     "F\x00{'descr': '>f8', 'fortran_order': False, 'shape': (3, 3)}            \n"
  236:     "F\x00{'descr': '<c8', 'fortran_order': False, 'shape': (0,)}              \n"
  237:     "F\x00{'descr': '<c8', 'fortran_order': False, 'shape': ()}                \n"
  238:     "F\x00{'descr': '<c8', 'fortran_order': False, 'shape': (15,)}             \n"
  239:     "F\x00{'descr': '<c8', 'fortran_order': False, 'shape': (3, 5)}            \n"
  240:     "F\x00{'descr': '<c8', 'fortran_order': True, 'shape': (5, 3)}             \n"
  241:     "F\x00{'descr': '<c8', 'fortran_order': False, 'shape': (3, 3)}            \n"
  242:     "F\x00{'descr': '>c8', 'fortran_order': False, 'shape': (0,)}              \n"
  243:     "F\x00{'descr': '>c8', 'fortran_order': False, 'shape': ()}                \n"
  244:     "F\x00{'descr': '>c8', 'fortran_order': False, 'shape': (15,)}             \n"
  245:     "F\x00{'descr': '>c8', 'fortran_order': False, 'shape': (3, 5)}            \n"
  246:     "F\x00{'descr': '>c8', 'fortran_order': True, 'shape': (5, 3)}             \n"
  247:     "F\x00{'descr': '>c8', 'fortran_order': False, 'shape': (3, 3)}            \n"
  248:     "F\x00{'descr': '<c16', 'fortran_order': False, 'shape': (0,)}             \n"
  249:     "F\x00{'descr': '<c16', 'fortran_order': False, 'shape': ()}               \n"
  250:     "F\x00{'descr': '<c16', 'fortran_order': False, 'shape': (15,)}            \n"
  251:     "F\x00{'descr': '<c16', 'fortran_order': False, 'shape': (3, 5)}           \n"
  252:     "F\x00{'descr': '<c16', 'fortran_order': True, 'shape': (5, 3)}            \n"
  253:     "F\x00{'descr': '<c16', 'fortran_order': False, 'shape': (3, 3)}           \n"
  254:     "F\x00{'descr': '>c16', 'fortran_order': False, 'shape': (0,)}             \n"
  255:     "F\x00{'descr': '>c16', 'fortran_order': False, 'shape': ()}               \n"
  256:     "F\x00{'descr': '>c16', 'fortran_order': False, 'shape': (15,)}            \n"
  257:     "F\x00{'descr': '>c16', 'fortran_order': False, 'shape': (3, 5)}           \n"
  258:     "F\x00{'descr': '>c16', 'fortran_order': True, 'shape': (5, 3)}            \n"
  259:     "F\x00{'descr': '>c16', 'fortran_order': False, 'shape': (3, 3)}           \n"
  260:     "F\x00{'descr': 'O', 'fortran_order': False, 'shape': (0,)}              \n"
  261:     "F\x00{'descr': 'O', 'fortran_order': False, 'shape': ()}                \n"
  262:     "F\x00{'descr': 'O', 'fortran_order': False, 'shape': (15,)}             \n"
  263:     "F\x00{'descr': 'O', 'fortran_order': False, 'shape': (3, 5)}            \n"
  264:     "F\x00{'descr': 'O', 'fortran_order': True, 'shape': (5, 3)}             \n"
  265:     "F\x00{'descr': 'O', 'fortran_order': False, 'shape': (3, 3)}            \n"
  266:     "F\x00{'descr': 'O', 'fortran_order': False, 'shape': (0,)}              \n"
  267:     "F\x00{'descr': 'O', 'fortran_order': False, 'shape': ()}                \n"
  268:     "F\x00{'descr': 'O', 'fortran_order': False, 'shape': (15,)}             \n"
  269:     "F\x00{'descr': 'O', 'fortran_order': False, 'shape': (3, 5)}            \n"
  270:     "F\x00{'descr': 'O', 'fortran_order': True, 'shape': (5, 3)}             \n"
  271:     "F\x00{'descr': 'O', 'fortran_order': False, 'shape': (3, 3)}            \n"
  272:     "v\x00{'descr': [('x', '<i4', (2,)), ('y', '<f8', (2, 2)), ('z', '|u1')],\n 'fortran_order': False,\n 'shape': (2,)}         \n"
  273:     "\x16\x02{'descr': [('x', '<i4', (2,)),\n           ('Info',\n            [('value', '<c16'),\n             ('y2', '<f8'),\n             ('Info2',\n              [('name', '|S2'),\n               ('value', '<c16', (2,)),\n               ('y3', '<f8', (2,)),\n               ('z3', '<u4', (2,))]),\n             ('name', '|S2'),\n             ('z2', '|b1')]),\n           ('color', '|S2'),\n           ('info', [('Name', '<U8'), ('Value', '<c16')]),\n           ('y', '<f8', (2, 2)),\n           ('z', '|u1')],\n 'fortran_order': False,\n 'shape': (2,)}      \n"
  274:     "v\x00{'descr': [('x', '>i4', (2,)), ('y', '>f8', (2, 2)), ('z', '|u1')],\n 'fortran_order': False,\n 'shape': (2,)}         \n"
  275:     "\x16\x02{'descr': [('x', '>i4', (2,)),\n           ('Info',\n            [('value', '>c16'),\n             ('y2', '>f8'),\n             ('Info2',\n              [('name', '|S2'),\n               ('value', '>c16', (2,)),\n               ('y3', '>f8', (2,)),\n               ('z3', '>u4', (2,))]),\n             ('name', '|S2'),\n             ('z2', '|b1')]),\n           ('color', '|S2'),\n           ('info', [('Name', '>U8'), ('Value', '>c16')]),\n           ('y', '>f8', (2, 2)),\n           ('z', '|u1')],\n 'fortran_order': False,\n 'shape': (2,)}      \n"
  276: '''
  277: import os
  278: import sys
  279: import warnings
  280: from io import BytesIO
  281: 
  282: import pytest
  283: 
  284: import numpy as np
  285: from numpy.lib import format
  286: from numpy.testing import (
  287:     IS_64BIT,
  288:     IS_PYPY,
  289:     IS_WASM,
  290:     assert_,
  291:     assert_array_equal,
  292:     assert_raises,
  293:     assert_raises_regex,
  294:     assert_warns,
  295: )
  296: from numpy.testing._private.utils import requires_memory
  297: 
  298: # Generate some basic arrays to test with.
  299: scalars = [
  300:     np.uint8,
  301:     np.int8,
  302:     np.uint16,
  303:     np.int16,
  304:     np.uint32,
  305:     np.int32,
  306:     np.uint64,
  307:     np.int64,
  308:     np.float32,
  309:     np.float64,
  310:     np.complex64,
  311:     np.complex128,
  312:     object,
  313: ]
  314: basic_arrays = []
  315: for scalar in scalars:
  316:     for endian in '<>':
  317:         dtype = np.dtype(scalar).newbyteorder(endian)
  318:         basic = np.arange(1500).astype(dtype)
  319:         basic_arrays.extend([
  320:             # Empty
  321:             np.array([], dtype=dtype),
  322:             # Rank-0
  323:             np.array(10, dtype=dtype),
  324:             # 1-D
  325:             basic,
  326:             # 2-D C-contiguous
  327:             basic.reshape((30, 50)),
  328:             # 2-D F-contiguous
  329:             basic.reshape((30, 50)).T,
  330:             # 2-D non-contiguous
  331:             basic.reshape((30, 50))[::-1, ::2],
  332:         ])
  333: 
  334: # More complicated record arrays.
  335: # This is the structure of the table used for plain objects:
  336: #
  337: # +-+-+-+
  338: # |x|y|z|
  339: # +-+-+-+
  340: 
  341: # Structure of a plain array description:
  342: Pdescr = [
  343:     ('x', 'i4', (2,)),
  344:     ('y', 'f8', (2, 2)),
  345:     ('z', 'u1')]
  346: 
  347: # A plain list of tuples with values for testing:
  348: PbufferT = [
  349:     # x     y                  z
  350:     ([3, 2], [[6., 4.], [6., 4.]], 8),
  351:     ([4, 3], [[7., 5.], [7., 5.]], 9),
  352:     ]
  353: 
  354: 
  355: # This is the structure of the table used for nested objects (DON'T PANIC!):
  356: #
  357: # +-+---------------------------------+-----+----------+-+-+
  358: # |x|Info                             |color|info      |y|z|
  359: # | +-----+--+----------------+----+--+     +----+-----+ | |
  360: # | |value|y2|Info2           |name|z2|     |Name|Value| | |
  361: # | |     |  +----+-----+--+--+    |  |     |    |     | | |
  362: # | |     |  |name|value|y3|z3|    |  |     |    |     | | |
  363: # +-+-----+--+----+-----+--+--+----+--+-----+----+-----+-+-+
  364: #
  365: 
  366: # The corresponding nested array description:
  367: Ndescr = [
  368:     ('x', 'i4', (2,)),
  369:     ('Info', [
  370:         ('value', 'c16'),
  371:         ('y2', 'f8'),
  372:         ('Info2', [
  373:             ('name', 'S2'),
  374:             ('value', 'c16', (2,)),
  375:             ('y3', 'f8', (2,)),
  376:             ('z3', 'u4', (2,))]),
  377:         ('name', 'S2'),
  378:         ('z2', 'b1')]),
  379:     ('color', 'S2'),
  380:     ('info', [
  381:         ('Name', 'U8'),
  382:         ('Value', 'c16')]),
  383:     ('y', 'f8', (2, 2)),
  384:     ('z', 'u1')]
  385: 
  386: NbufferT = [
  387:     # x     Info                                                color info        y                  z
  388:     #       value y2 Info2                            name z2         Name Value
  389:     #                name   value    y3       z3
  390:     ([3, 2], (6j, 6., ('nn', [6j, 4j], [6., 4.], [1, 2]), 'NN', True),
  391:      'cc', ('NN', 6j), [[6., 4.], [6., 4.]], 8),
  392:     ([4, 3], (7j, 7., ('oo', [7j, 5j], [7., 5.], [2, 1]), 'OO', False),
  393:      'dd', ('OO', 7j), [[7., 5.], [7., 5.]], 9),
  394:     ]
  395: 
  396: record_arrays = [
  397:     np.array(PbufferT, dtype=np.dtype(Pdescr).newbyteorder('<')),
  398:     np.array(NbufferT, dtype=np.dtype(Ndescr).newbyteorder('<')),
  399:     np.array(PbufferT, dtype=np.dtype(Pdescr).newbyteorder('>')),
  400:     np.array(NbufferT, dtype=np.dtype(Ndescr).newbyteorder('>')),
  401:     np.zeros(1, dtype=[('c', ('<f8', (5,)), (2,))])
  402: ]
  403: 
  404: 
  405: # BytesIO that reads a random number of bytes at a time
  406: class BytesIOSRandomSize(BytesIO):
  407:     def read(self, size=None):
  408:         import random
  409:         size = random.randint(1, size)
  410:         return super().read(size)
  411: 
  412: 
  413: def roundtrip(arr):
  414:     f = BytesIO()
  415:     format.write_array(f, arr)
  416:     f2 = BytesIO(f.getvalue())
  417:     arr2 = format.read_array(f2, allow_pickle=True)
  418:     return arr2
  419: 
  420: 
  421: def roundtrip_randsize(arr):
  422:     f = BytesIO()
  423:     format.write_array(f, arr)
  424:     f2 = BytesIOSRandomSize(f.getvalue())
  425:     arr2 = format.read_array(f2)
  426:     return arr2
  427: 
  428: 
  429: def roundtrip_truncated(arr):
  430:     f = BytesIO()
  431:     format.write_array(f, arr)
  432:     # BytesIO is one byte short
  433:     f2 = BytesIO(f.getvalue()[0:-1])
  434:     arr2 = format.read_array(f2)
  435:     return arr2
  436: 
  437: def assert_equal_(o1, o2):
  438:     assert_(o1 == o2)
  439: 
  440: 
  441: def test_roundtrip():
  442:     for arr in basic_arrays + record_arrays:
  443:         arr2 = roundtrip(arr)
  444:         assert_array_equal(arr, arr2)
  445: 
  446: 
  447: def test_roundtrip_randsize():
  448:     for arr in basic_arrays + record_arrays:
  449:         if arr.dtype != object:
  450:             arr2 = roundtrip_randsize(arr)
  451:             assert_array_equal(arr, arr2)
  452: 
  453: 
  454: def test_roundtrip_truncated():
  455:     for arr in basic_arrays:
  456:         if arr.dtype != object:
  457:             assert_raises(ValueError, roundtrip_truncated, arr)
  458: 
  459: def test_file_truncated(tmp_path):
  460:     path = tmp_path / "a.npy"
  461:     for arr in basic_arrays:
  462:         if arr.dtype != object:
  463:             with open(path, 'wb') as f:
  464:                 format.write_array(f, arr)
  465:             # truncate the file by one byte
  466:             with open(path, 'rb+') as f:
  467:                 f.seek(-1, os.SEEK_END)
  468:                 f.truncate()
  469:             with open(path, 'rb') as f:
  470:                 with pytest.raises(
  471:                     ValueError,
  472:                     match=(
  473:                         r"EOF: reading array header, "
  474:                         r"expected (\d+) bytes got (\d+)"
  475:                     ) if arr.size == 0 else (
  476:                         r"Failed to read all data for array\. "
  477:                         r"Expected \(.*?\) = (\d+) elements, "
  478:                         r"could only read (\d+) elements\. "
  479:                         r"\(file seems not fully written\?\)"
  480:                     )
  481:                 ):
  482:                     _ = format.read_array(f)
  483: 
  484: def test_long_str():
  485:     # check items larger than internal buffer size, gh-4027
  486:     long_str_arr = np.ones(1, dtype=np.dtype((str, format.BUFFER_SIZE + 1)))
  487:     long_str_arr2 = roundtrip(long_str_arr)
  488:     assert_array_equal(long_str_arr, long_str_arr2)
  489: 
  490: 
  491: @pytest.mark.skipif(IS_WASM, reason="memmap doesn't work correctly")
  492: @pytest.mark.slow
  493: def test_memmap_roundtrip(tmpdir):
  494:     for i, arr in enumerate(basic_arrays + record_arrays):
  495:         if arr.dtype.hasobject:
  496:             # Skip these since they can't be mmap'ed.
  497:             continue
  498:         # Write it out normally and through mmap.
  499:         nfn = os.path.join(tmpdir, f'normal{i}.npy')
  500:         mfn = os.path.join(tmpdir, f'memmap{i}.npy')
  501:         with open(nfn, 'wb') as fp:
  502:             format.write_array(fp, arr)
  503: 
  504:         fortran_order = (
  505:             arr.flags.f_contiguous and not arr.flags.c_contiguous)
  506:         ma = format.open_memmap(mfn, mode='w+', dtype=arr.dtype,
  507:                                 shape=arr.shape, fortran_order=fortran_order)
  508:         ma[...] = arr
  509:         ma.flush()
  510: 
  511:         # Check that both of these files' contents are the same.
  512:         with open(nfn, 'rb') as fp:
  513:             normal_bytes = fp.read()
  514:         with open(mfn, 'rb') as fp:
  515:             memmap_bytes = fp.read()
  516:         assert_equal_(normal_bytes, memmap_bytes)
  517: 
  518:         # Check that reading the file using memmap works.
  519:         ma = format.open_memmap(nfn, mode='r')
  520:         ma.flush()
  521: 
  522: 
  523: def test_compressed_roundtrip(tmpdir):
  524:     arr = np.random.rand(200, 200)
  525:     npz_file = os.path.join(tmpdir, 'compressed.npz')
  526:     np.savez_compressed(npz_file, arr=arr)
  527:     with np.load(npz_file) as npz:
  528:         arr1 = npz['arr']
  529:     assert_array_equal(arr, arr1)
  530: 
  531: 
  532: # aligned
  533: dt1 = np.dtype('i1, i4, i1', align=True)
  534: # non-aligned, explicit offsets
  535: dt2 = np.dtype({'names': ['a', 'b'], 'formats': ['i4', 'i4'],
  536:                 'offsets': [1, 6]})
  537: # nested struct-in-struct
  538: dt3 = np.dtype({'names': ['c', 'd'], 'formats': ['i4', dt2]})
  539: # field with '' name
  540: dt4 = np.dtype({'names': ['a', '', 'b'], 'formats': ['i4'] * 3})
  541: # titles
  542: dt5 = np.dtype({'names': ['a', 'b'], 'formats': ['i4', 'i4'],
  543:                 'offsets': [1, 6], 'titles': ['aa', 'bb']})
  544: # empty
  545: dt6 = np.dtype({'names': [], 'formats': [], 'itemsize': 8})
  546: 
  547: @pytest.mark.parametrize("dt", [dt1, dt2, dt3, dt4, dt5, dt6])
  548: def test_load_padded_dtype(tmpdir, dt):
  549:     arr = np.zeros(3, dt)
  550:     for i in range(3):
  551:         arr[i] = i + 5
  552:     npz_file = os.path.join(tmpdir, 'aligned.npz')
  553:     np.savez(npz_file, arr=arr)
  554:     with np.load(npz_file) as npz:
  555:         arr1 = npz['arr']
  556:     assert_array_equal(arr, arr1)
  557: 
  558: 
  559: @pytest.mark.skipif(sys.version_info >= (3, 12), reason="see gh-23988")
  560: @pytest.mark.xfail(IS_WASM, reason="Emscripten NODEFS has a buggy dup")
  561: def test_python2_python3_interoperability():
  562:     fname = 'win64python2.npy'
  563:     path = os.path.join(os.path.dirname(__file__), 'data', fname)
  564:     with pytest.warns(UserWarning, match="Reading.*this warning\\."):
  565:         data = np.load(path)
  566:     assert_array_equal(data, np.ones(2))
  567: 
  568: 
  569: def test_pickle_python2_python3():
  570:     # Test that loading object arrays saved on Python 2 works both on
  571:     # Python 2 and Python 3 and vice versa
  572:     data_dir = os.path.join(os.path.dirname(__file__), 'data')
  573: 
  574:     expected = np.array([None, range, '\u512a\u826f',
  575:                          b'\xe4\xb8\x8d\xe8\x89\xaf'],
  576:                         dtype=object)
  577: 
  578:     for fname in ['py2-np0-objarr.npy', 'py2-objarr.npy', 'py2-objarr.npz',
  579:                   'py3-objarr.npy', 'py3-objarr.npz']:
  580:         path = os.path.join(data_dir, fname)
  581: 
  582:         for encoding in ['bytes', 'latin1']:
  583:             data_f = np.load(path, allow_pickle=True, encoding=encoding)
  584:             if fname.endswith('.npz'):
  585:                 data = data_f['x']
  586:                 data_f.close()
  587:             else:
  588:                 data = data_f
  589: 
  590:             if encoding == 'latin1' and fname.startswith('py2'):
  591:                 assert_(isinstance(data[3], str))
  592:                 assert_array_equal(data[:-1], expected[:-1])
  593:                 # mojibake occurs
  594:                 assert_array_equal(data[-1].encode(encoding), expected[-1])
  595:             else:
  596:                 assert_(isinstance(data[3], bytes))
  597:                 assert_array_equal(data, expected)
  598: 
  599:         if fname.startswith('py2'):
  600:             if fname.endswith('.npz'):
  601:                 data = np.load(path, allow_pickle=True)
  602:                 assert_raises(UnicodeError, data.__getitem__, 'x')
  603:                 data.close()
  604:                 data = np.load(path, allow_pickle=True, fix_imports=False,
  605:                                encoding='latin1')
  606:                 assert_raises(ImportError, data.__getitem__, 'x')
  607:                 data.close()
  608:             else:
  609:                 assert_raises(UnicodeError, np.load, path,
  610:                               allow_pickle=True)
  611:                 assert_raises(ImportError, np.load, path,
  612:                               allow_pickle=True, fix_imports=False,
  613:                               encoding='latin1')
  614: 
  615: 
  616: def test_pickle_disallow(tmpdir):
  617:     data_dir = os.path.join(os.path.dirname(__file__), 'data')
  618: 
  619:     path = os.path.join(data_dir, 'py2-objarr.npy')
  620:     assert_raises(ValueError, np.load, path,
  621:                   allow_pickle=False, encoding='latin1')
  622: 
  623:     path = os.path.join(data_dir, 'py2-objarr.npz')
  624:     with np.load(path, allow_pickle=False, encoding='latin1') as f:
  625:         assert_raises(ValueError, f.__getitem__, 'x')
  626: 
  627:     path = os.path.join(tmpdir, 'pickle-disabled.npy')
  628:     assert_raises(ValueError, np.save, path, np.array([None], dtype=object),
  629:                   allow_pickle=False)
  630: 
  631: @pytest.mark.parametrize('dt', [
  632:     np.dtype(np.dtype([('a', np.int8),
  633:                        ('b', np.int16),
  634:                        ('c', np.int32),
  635:                       ], align=True),
  636:              (3,)),
  637:     np.dtype([('x', np.dtype({'names': ['a', 'b'],
  638:                               'formats': ['i1', 'i1'],
  639:                               'offsets': [0, 4],
  640:                               'itemsize': 8,
  641:                              },
  642:                     (3,)),
  643:                (4,),
  644:              )]),
  645:     np.dtype([('x',
  646:                    ('<f8', (5,)),
  647:                    (2,),
  648:                )]),
  649:     np.dtype([('x', np.dtype((
  650:         np.dtype((
  651:             np.dtype({'names': ['a', 'b'],
  652:                       'formats': ['i1', 'i1'],
  653:                       'offsets': [0, 4],
  654:                       'itemsize': 8}),
  655:             (3,)
  656:             )),
  657:         (4,)
  658:         )))
  659:         ]),
  660:     np.dtype([
  661:         ('a', np.dtype((
  662:             np.dtype((
  663:                 np.dtype((
  664:                     np.dtype([
  665:                         ('a', int),
  666:                         ('b', np.dtype({'names': ['a', 'b'],
  667:                                         'formats': ['i1', 'i1'],
  668:                                         'offsets': [0, 4],
  669:                                         'itemsize': 8})),
  670:                     ]),
  671:                     (3,),
  672:                 )),
  673:                 (4,),
  674:             )),
  675:             (5,),
  676:         )))
  677:         ]),
  678:     ])
  679: def test_descr_to_dtype(dt):
  680:     dt1 = format.descr_to_dtype(dt.descr)
  681:     assert_equal_(dt1, dt)
  682:     arr1 = np.zeros(3, dt)
  683:     arr2 = roundtrip(arr1)
  684:     assert_array_equal(arr1, arr2)
  685: 
  686: def test_version_2_0():
  687:     f = BytesIO()
  688:     # requires more than 2 byte for header
  689:     dt = [(("%d" % i) * 100, float) for i in range(500)]
  690:     d = np.ones(1000, dtype=dt)
  691: 
  692:     format.write_array(f, d, version=(2, 0))
  693:     with warnings.catch_warnings(record=True) as w:
  694:         warnings.filterwarnings('always', '', UserWarning)
  695:         format.write_array(f, d)
  696:         assert_(w[0].category is UserWarning)
  697: 
  698:     # check alignment of data portion
  699:     f.seek(0)
  700:     header = f.readline()
  701:     assert_(len(header) % format.ARRAY_ALIGN == 0)
  702: 
  703:     f.seek(0)
  704:     n = format.read_array(f, max_header_size=200000)
  705:     assert_array_equal(d, n)
  706: 
  707:     # 1.0 requested but data cannot be saved this way
  708:     assert_raises(ValueError, format.write_array, f, d, (1, 0))
  709: 
  710: 
  711: @pytest.mark.skipif(IS_WASM, reason="memmap doesn't work correctly")
  712: def test_version_2_0_memmap(tmpdir):
  713:     # requires more than 2 byte for header
  714:     dt = [(("%d" % i) * 100, float) for i in range(500)]
  715:     d = np.ones(1000, dtype=dt)
  716:     tf1 = os.path.join(tmpdir, 'version2_01.npy')
  717:     tf2 = os.path.join(tmpdir, 'version2_02.npy')
  718: 
  719:     # 1.0 requested but data cannot be saved this way
  720:     assert_raises(ValueError, format.open_memmap, tf1, mode='w+', dtype=d.dtype,
  721:                             shape=d.shape, version=(1, 0))
  722: 
  723:     ma = format.open_memmap(tf1, mode='w+', dtype=d.dtype,
  724:                             shape=d.shape, version=(2, 0))
  725:     ma[...] = d
  726:     ma.flush()
  727:     ma = format.open_memmap(tf1, mode='r', max_header_size=200000)
  728:     assert_array_equal(ma, d)
  729: 
  730:     with warnings.catch_warnings(record=True) as w:
  731:         warnings.filterwarnings('always', '', UserWarning)
  732:         ma = format.open_memmap(tf2, mode='w+', dtype=d.dtype,
  733:                                 shape=d.shape, version=None)
  734:         assert_(w[0].category is UserWarning)
  735:         ma[...] = d
  736:         ma.flush()
  737: 
  738:     ma = format.open_memmap(tf2, mode='r', max_header_size=200000)
  739: 
  740:     assert_array_equal(ma, d)
  741: 
  742: @pytest.mark.parametrize("mmap_mode", ["r", None])
  743: def test_huge_header(tmpdir, mmap_mode):
  744:     f = os.path.join(tmpdir, 'large_header.npy')
  745:     arr = np.array(1, dtype="i," * 10000 + "i")
  746: 
  747:     with pytest.warns(UserWarning, match=".*format 2.0"):
  748:         np.save(f, arr)
  749: 
  750:     with pytest.raises(ValueError, match="Header.*large"):
  751:         np.load(f, mmap_mode=mmap_mode)
  752: 
  753:     with pytest.raises(ValueError, match="Header.*large"):
  754:         np.load(f, mmap_mode=mmap_mode, max_header_size=20000)
  755: 
  756:     res = np.load(f, mmap_mode=mmap_mode, allow_pickle=True)
  757:     assert_array_equal(res, arr)
  758: 
  759:     res = np.load(f, mmap_mode=mmap_mode, max_header_size=180000)
  760:     assert_array_equal(res, arr)
  761: 
  762: def test_huge_header_npz(tmpdir):
  763:     f = os.path.join(tmpdir, 'large_header.npz')
  764:     arr = np.array(1, dtype="i," * 10000 + "i")
  765: 
  766:     with pytest.warns(UserWarning, match=".*format 2.0"):
  767:         np.savez(f, arr=arr)
  768: 
  769:     # Only getting the array from the file actually reads it
  770:     with pytest.raises(ValueError, match="Header.*large"):
  771:         np.load(f)["arr"]
  772: 
  773:     with pytest.raises(ValueError, match="Header.*large"):
  774:         np.load(f, max_header_size=20000)["arr"]
  775: 
  776:     res = np.load(f, allow_pickle=True)["arr"]
  777:     assert_array_equal(res, arr)
  778: 
  779:     res = np.load(f, max_header_size=180000)["arr"]
  780:     assert_array_equal(res, arr)
  781: 
  782: def test_write_version():
  783:     f = BytesIO()
  784:     arr = np.arange(1)
  785:     # These should pass.
  786:     format.write_array(f, arr, version=(1, 0))
  787:     format.write_array(f, arr)
  788: 
  789:     format.write_array(f, arr, version=None)
  790:     format.write_array(f, arr)
  791: 
  792:     format.write_array(f, arr, version=(2, 0))
  793:     format.write_array(f, arr)
  794: 
  795:     # These should all fail.
  796:     bad_versions = [
  797:         (1, 1),
  798:         (0, 0),
  799:         (0, 1),
  800:         (2, 2),
  801:         (255, 255),
  802:     ]
  803:     for version in bad_versions:
  804:         with assert_raises_regex(ValueError,
  805:                                  'we only support format version.*'):
  806:             format.write_array(f, arr, version=version)
  807: 
  808: 
  809: bad_version_magic = [
  810:     b'\x93NUMPY\x01\x01',
  811:     b'\x93NUMPY\x00\x00',
  812:     b'\x93NUMPY\x00\x01',
  813:     b'\x93NUMPY\x02\x00',
  814:     b'\x93NUMPY\x02\x02',
  815:     b'\x93NUMPY\xff\xff',
  816: ]
  817: malformed_magic = [
  818:     b'\x92NUMPY\x01\x00',
  819:     b'\x00NUMPY\x01\x00',
  820:     b'\x93numpy\x01\x00',
  821:     b'\x93MATLB\x01\x00',
  822:     b'\x93NUMPY\x01',
  823:     b'\x93NUMPY',
  824:     b'',
  825: ]
  826: 
  827: def test_read_magic():
  828:     s1 = BytesIO()
  829:     s2 = BytesIO()
  830: 
  831:     arr = np.ones((3, 6), dtype=float)
  832: 
  833:     format.write_array(s1, arr, version=(1, 0))
  834:     format.write_array(s2, arr, version=(2, 0))
  835: 
  836:     s1.seek(0)
  837:     s2.seek(0)
  838: 
  839:     version1 = format.read_magic(s1)
  840:     version2 = format.read_magic(s2)
  841: 
  842:     assert_(version1 == (1, 0))
  843:     assert_(version2 == (2, 0))
  844: 
  845:     assert_(s1.tell() == format.MAGIC_LEN)
  846:     assert_(s2.tell() == format.MAGIC_LEN)
  847: 
  848: def test_read_magic_bad_magic():
  849:     for magic in malformed_magic:
  850:         f = BytesIO(magic)
  851:         assert_raises(ValueError, format.read_array, f)
  852: 
  853: 
  854: def test_read_version_1_0_bad_magic():
  855:     for magic in bad_version_magic + malformed_magic:
  856:         f = BytesIO(magic)
  857:         assert_raises(ValueError, format.read_array, f)
  858: 
  859: 
  860: def test_bad_magic_args():
  861:     assert_raises(ValueError, format.magic, -1, 1)
  862:     assert_raises(ValueError, format.magic, 256, 1)
  863:     assert_raises(ValueError, format.magic, 1, -1)
  864:     assert_raises(ValueError, format.magic, 1, 256)
  865: 
  866: 
  867: def test_large_header():
  868:     s = BytesIO()
  869:     d = {'shape': (), 'fortran_order': False, 'descr': '<i8'}
  870:     format.write_array_header_1_0(s, d)
  871: 
  872:     s = BytesIO()
  873:     d['descr'] = [('x' * 256 * 256, '<i8')]
  874:     assert_raises(ValueError, format.write_array_header_1_0, s, d)
  875: 
  876: 
  877: def test_read_array_header_1_0():
  878:     s = BytesIO()
  879: 
  880:     arr = np.ones((3, 6), dtype=float)
  881:     format.write_array(s, arr, version=(1, 0))
  882: 
  883:     s.seek(format.MAGIC_LEN)
  884:     shape, fortran, dtype = format.read_array_header_1_0(s)
  885: 
  886:     assert_(s.tell() % format.ARRAY_ALIGN == 0)
  887:     assert_((shape, fortran, dtype) == ((3, 6), False, float))
  888: 
  889: 
  890: def test_read_array_header_2_0():
  891:     s = BytesIO()
  892: 
  893:     arr = np.ones((3, 6), dtype=float)
  894:     format.write_array(s, arr, version=(2, 0))
  895: 
  896:     s.seek(format.MAGIC_LEN)
  897:     shape, fortran, dtype = format.read_array_header_2_0(s)
  898: 
  899:     assert_(s.tell() % format.ARRAY_ALIGN == 0)
  900:     assert_((shape, fortran, dtype) == ((3, 6), False, float))
  901: 
  902: 
  903: def test_bad_header():
  904:     # header of length less than 2 should fail
  905:     s = BytesIO()
  906:     assert_raises(ValueError, format.read_array_header_1_0, s)
  907:     s = BytesIO(b'1')
  908:     assert_raises(ValueError, format.read_array_header_1_0, s)
  909: 
  910:     # header shorter than indicated size should fail
  911:     s = BytesIO(b'\x01\x00')
  912:     assert_raises(ValueError, format.read_array_header_1_0, s)
  913: 
  914:     # headers without the exact keys required should fail
  915:     # d = {"shape": (1, 2),
  916:     #      "descr": "x"}
  917:     s = BytesIO(
  918:         b"\x93NUMPY\x01\x006\x00{'descr': 'x', 'shape': (1, 2), }"
  919:         b"                    \n"
  920:     )
  921:     assert_raises(ValueError, format.read_array_header_1_0, s)
  922: 
  923:     d = {"shape": (1, 2),
  924:          "fortran_order": False,
  925:          "descr": "x",
  926:          "extrakey": -1}
  927:     s = BytesIO()
  928:     format.write_array_header_1_0(s, d)
  929:     assert_raises(ValueError, format.read_array_header_1_0, s)
  930: 
  931: 
  932: def test_large_file_support(tmpdir):
  933:     if (sys.platform == 'win32' or sys.platform == 'cygwin'):
  934:         pytest.skip("Unknown if Windows has sparse filesystems")
  935:     # try creating a large sparse file
  936:     tf_name = os.path.join(tmpdir, 'sparse_file')
  937:     try:
  938:         # seek past end would work too, but linux truncate somewhat
  939:         # increases the chances that we have a sparse filesystem and can
  940:         # avoid actually writing 5GB
  941:         import subprocess as sp
  942:         sp.check_call(["truncate", "-s", "5368709120", tf_name])
  943:     except Exception:
  944:         pytest.skip("Could not create 5GB large file")
  945:     # write a small array to the end
  946:     with open(tf_name, "wb") as f:
  947:         f.seek(5368709120)
  948:         d = np.arange(5)
  949:         np.save(f, d)
  950:     # read it back
  951:     with open(tf_name, "rb") as f:
  952:         f.seek(5368709120)
  953:         r = np.load(f)
  954:     assert_array_equal(r, d)
  955: 
  956: 
  957: @pytest.mark.skipif(IS_PYPY, reason="flaky on PyPy")
  958: @pytest.mark.skipif(not IS_64BIT, reason="test requires 64-bit system")
  959: @pytest.mark.slow
  960: @requires_memory(free_bytes=2 * 2**30)
  961: def test_large_archive(tmpdir):
  962:     # Regression test for product of saving arrays with dimensions of array
  963:     # having a product that doesn't fit in int32.  See gh-7598 for details.
  964:     shape = (2**30, 2)
  965:     try:
  966:         a = np.empty(shape, dtype=np.uint8)
  967:     except MemoryError:
  968:         pytest.skip("Could not create large file")
  969: 
  970:     fname = os.path.join(tmpdir, "large_archive")
  971: 
  972:     with open(fname, "wb") as f:
  973:         np.savez(f, arr=a)
  974: 
  975:     del a
  976: 
  977:     with open(fname, "rb") as f:
  978:         new_a = np.load(f)["arr"]
  979: 
  980:     assert new_a.shape == shape
  981: 
  982: 
  983: def test_empty_npz(tmpdir):
  984:     # Test for gh-9989
  985:     fname = os.path.join(tmpdir, "nothing.npz")
  986:     np.savez(fname)
  987:     with np.load(fname) as nps:
  988:         pass
  989: 
  990: 
  991: def test_unicode_field_names(tmpdir):
  992:     # gh-7391
  993:     arr = np.array([
  994:         (1, 3),
  995:         (1, 2),
  996:         (1, 3),
  997:         (1, 2)
  998:     ], dtype=[
  999:         ('int', int),
 1000:         ('\N{CJK UNIFIED IDEOGRAPH-6574}\N{CJK UNIFIED IDEOGRAPH-5F62}', int)
 1001:     ])
 1002:     fname = os.path.join(tmpdir, "unicode.npy")
 1003:     with open(fname, 'wb') as f:
 1004:         format.write_array(f, arr, version=(3, 0))
 1005:     with open(fname, 'rb') as f:
 1006:         arr2 = format.read_array(f)
 1007:     assert_array_equal(arr, arr2)
 1008: 
 1009:     # notifies the user that 3.0 is selected
 1010:     with open(fname, 'wb') as f:
 1011:         with assert_warns(UserWarning):
 1012:             format.write_array(f, arr, version=None)
 1013: 
 1014: def test_header_growth_axis():
 1015:     for is_fortran_array, dtype_space, expected_header_length in [
 1016:         [False, 22, 128], [False, 23, 192], [True, 23, 128], [True, 24, 192]
 1017:     ]:
 1018:         for size in [10**i for i in range(format.GROWTH_AXIS_MAX_DIGITS)]:
 1019:             fp = BytesIO()
 1020:             format.write_array_header_1_0(fp, {
 1021:                 'shape': (2, size) if is_fortran_array else (size, 2),
 1022:                 'fortran_order': is_fortran_array,
 1023:                 'descr': np.dtype([(' ' * dtype_space, int)])
 1024:             })
 1025: 
 1026:             assert len(fp.getvalue()) == expected_header_length
 1027: 
 1028: @pytest.mark.parametrize('dt', [
 1029:     np.dtype({'names': ['a', 'b'], 'formats':  [float, np.dtype('S3',
 1030:                  metadata={'some': 'stuff'})]}),
 1031:     np.dtype(int, metadata={'some': 'stuff'}),
 1032:     np.dtype([('subarray', (int, (2,)))], metadata={'some': 'stuff'}),
 1033:     # recursive: metadata on the field of a dtype
 1034:     np.dtype({'names': ['a', 'b'], 'formats': [
 1035:         float, np.dtype({'names': ['c'], 'formats': [np.dtype(int, metadata={})]})
 1036:     ]}),
 1037:     ])
 1038: @pytest.mark.skipif(IS_PYPY and sys.implementation.version <= (7, 3, 8),
 1039:         reason="PyPy bug in error formatting")
 1040: def test_metadata_dtype(dt):
 1041:     # gh-14142
 1042:     arr = np.ones(10, dtype=dt)
 1043:     buf = BytesIO()
 1044:     with assert_warns(UserWarning):
 1045:         np.save(buf, arr)
 1046:     buf.seek(0)
 1047: 
 1048:     # Loading should work (metadata was stripped):
 1049:     arr2 = np.load(buf)
 1050:     # BUG: assert_array_equal does not check metadata
 1051:     from numpy.lib._utils_impl import drop_metadata
 1052:     assert_array_equal(arr, arr2)
 1053:     assert drop_metadata(arr.dtype) is not arr.dtype
 1054:     assert drop_metadata(arr2.dtype) is arr2.dtype
