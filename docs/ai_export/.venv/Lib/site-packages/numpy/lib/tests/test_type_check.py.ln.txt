    1: import numpy as np
    2: from numpy import (
    3:     common_type,
    4:     iscomplex,
    5:     iscomplexobj,
    6:     isneginf,
    7:     isposinf,
    8:     isreal,
    9:     isrealobj,
   10:     mintypecode,
   11:     nan_to_num,
   12:     real_if_close,
   13: )
   14: from numpy.testing import assert_, assert_array_equal, assert_equal
   15: 
   16: 
   17: def assert_all(x):
   18:     assert_(np.all(x), x)
   19: 
   20: 
   21: class TestCommonType:
   22:     def test_basic(self):
   23:         ai32 = np.array([[1, 2], [3, 4]], dtype=np.int32)
   24:         af16 = np.array([[1, 2], [3, 4]], dtype=np.float16)
   25:         af32 = np.array([[1, 2], [3, 4]], dtype=np.float32)
   26:         af64 = np.array([[1, 2], [3, 4]], dtype=np.float64)
   27:         acs = np.array([[1 + 5j, 2 + 6j], [3 + 7j, 4 + 8j]], dtype=np.complex64)
   28:         acd = np.array([[1 + 5j, 2 + 6j], [3 + 7j, 4 + 8j]], dtype=np.complex128)
   29:         assert_(common_type(ai32) == np.float64)
   30:         assert_(common_type(af16) == np.float16)
   31:         assert_(common_type(af32) == np.float32)
   32:         assert_(common_type(af64) == np.float64)
   33:         assert_(common_type(acs) == np.complex64)
   34:         assert_(common_type(acd) == np.complex128)
   35: 
   36: 
   37: class TestMintypecode:
   38: 
   39:     def test_default_1(self):
   40:         for itype in '1bcsuwil':
   41:             assert_equal(mintypecode(itype), 'd')
   42:         assert_equal(mintypecode('f'), 'f')
   43:         assert_equal(mintypecode('d'), 'd')
   44:         assert_equal(mintypecode('F'), 'F')
   45:         assert_equal(mintypecode('D'), 'D')
   46: 
   47:     def test_default_2(self):
   48:         for itype in '1bcsuwil':
   49:             assert_equal(mintypecode(itype + 'f'), 'f')
   50:             assert_equal(mintypecode(itype + 'd'), 'd')
   51:             assert_equal(mintypecode(itype + 'F'), 'F')
   52:             assert_equal(mintypecode(itype + 'D'), 'D')
   53:         assert_equal(mintypecode('ff'), 'f')
   54:         assert_equal(mintypecode('fd'), 'd')
   55:         assert_equal(mintypecode('fF'), 'F')
   56:         assert_equal(mintypecode('fD'), 'D')
   57:         assert_equal(mintypecode('df'), 'd')
   58:         assert_equal(mintypecode('dd'), 'd')
   59:         #assert_equal(mintypecode('dF',savespace=1),'F')
   60:         assert_equal(mintypecode('dF'), 'D')
   61:         assert_equal(mintypecode('dD'), 'D')
   62:         assert_equal(mintypecode('Ff'), 'F')
   63:         #assert_equal(mintypecode('Fd',savespace=1),'F')
   64:         assert_equal(mintypecode('Fd'), 'D')
   65:         assert_equal(mintypecode('FF'), 'F')
   66:         assert_equal(mintypecode('FD'), 'D')
   67:         assert_equal(mintypecode('Df'), 'D')
   68:         assert_equal(mintypecode('Dd'), 'D')
   69:         assert_equal(mintypecode('DF'), 'D')
   70:         assert_equal(mintypecode('DD'), 'D')
   71: 
   72:     def test_default_3(self):
   73:         assert_equal(mintypecode('fdF'), 'D')
   74:         #assert_equal(mintypecode('fdF',savespace=1),'F')
   75:         assert_equal(mintypecode('fdD'), 'D')
   76:         assert_equal(mintypecode('fFD'), 'D')
   77:         assert_equal(mintypecode('dFD'), 'D')
   78: 
   79:         assert_equal(mintypecode('ifd'), 'd')
   80:         assert_equal(mintypecode('ifF'), 'F')
   81:         assert_equal(mintypecode('ifD'), 'D')
   82:         assert_equal(mintypecode('idF'), 'D')
   83:         #assert_equal(mintypecode('idF',savespace=1),'F')
   84:         assert_equal(mintypecode('idD'), 'D')
   85: 
   86: 
   87: class TestIsscalar:
   88: 
   89:     def test_basic(self):
   90:         assert_(np.isscalar(3))
   91:         assert_(not np.isscalar([3]))
   92:         assert_(not np.isscalar((3,)))
   93:         assert_(np.isscalar(3j))
   94:         assert_(np.isscalar(4.0))
   95: 
   96: 
   97: class TestReal:
   98: 
   99:     def test_real(self):
  100:         y = np.random.rand(10,)
  101:         assert_array_equal(y, np.real(y))
  102: 
  103:         y = np.array(1)
  104:         out = np.real(y)
  105:         assert_array_equal(y, out)
  106:         assert_(isinstance(out, np.ndarray))
  107: 
  108:         y = 1
  109:         out = np.real(y)
  110:         assert_equal(y, out)
  111:         assert_(not isinstance(out, np.ndarray))
  112: 
  113:     def test_cmplx(self):
  114:         y = np.random.rand(10,) + 1j * np.random.rand(10,)
  115:         assert_array_equal(y.real, np.real(y))
  116: 
  117:         y = np.array(1 + 1j)
  118:         out = np.real(y)
  119:         assert_array_equal(y.real, out)
  120:         assert_(isinstance(out, np.ndarray))
  121: 
  122:         y = 1 + 1j
  123:         out = np.real(y)
  124:         assert_equal(1.0, out)
  125:         assert_(not isinstance(out, np.ndarray))
  126: 
  127: 
  128: class TestImag:
  129: 
  130:     def test_real(self):
  131:         y = np.random.rand(10,)
  132:         assert_array_equal(0, np.imag(y))
  133: 
  134:         y = np.array(1)
  135:         out = np.imag(y)
  136:         assert_array_equal(0, out)
  137:         assert_(isinstance(out, np.ndarray))
  138: 
  139:         y = 1
  140:         out = np.imag(y)
  141:         assert_equal(0, out)
  142:         assert_(not isinstance(out, np.ndarray))
  143: 
  144:     def test_cmplx(self):
  145:         y = np.random.rand(10,) + 1j * np.random.rand(10,)
  146:         assert_array_equal(y.imag, np.imag(y))
  147: 
  148:         y = np.array(1 + 1j)
  149:         out = np.imag(y)
  150:         assert_array_equal(y.imag, out)
  151:         assert_(isinstance(out, np.ndarray))
  152: 
  153:         y = 1 + 1j
  154:         out = np.imag(y)
  155:         assert_equal(1.0, out)
  156:         assert_(not isinstance(out, np.ndarray))
  157: 
  158: 
  159: class TestIscomplex:
  160: 
  161:     def test_fail(self):
  162:         z = np.array([-1, 0, 1])
  163:         res = iscomplex(z)
  164:         assert_(not np.any(res, axis=0))
  165: 
  166:     def test_pass(self):
  167:         z = np.array([-1j, 1, 0])
  168:         res = iscomplex(z)
  169:         assert_array_equal(res, [1, 0, 0])
  170: 
  171: 
  172: class TestIsreal:
  173: 
  174:     def test_pass(self):
  175:         z = np.array([-1, 0, 1j])
  176:         res = isreal(z)
  177:         assert_array_equal(res, [1, 1, 0])
  178: 
  179:     def test_fail(self):
  180:         z = np.array([-1j, 1, 0])
  181:         res = isreal(z)
  182:         assert_array_equal(res, [0, 1, 1])
  183: 
  184: 
  185: class TestIscomplexobj:
  186: 
  187:     def test_basic(self):
  188:         z = np.array([-1, 0, 1])
  189:         assert_(not iscomplexobj(z))
  190:         z = np.array([-1j, 0, -1])
  191:         assert_(iscomplexobj(z))
  192: 
  193:     def test_scalar(self):
  194:         assert_(not iscomplexobj(1.0))
  195:         assert_(iscomplexobj(1 + 0j))
  196: 
  197:     def test_list(self):
  198:         assert_(iscomplexobj([3, 1 + 0j, True]))
  199:         assert_(not iscomplexobj([3, 1, True]))
  200: 
  201:     def test_duck(self):
  202:         class DummyComplexArray:
  203:             @property
  204:             def dtype(self):
  205:                 return np.dtype(complex)
  206:         dummy = DummyComplexArray()
  207:         assert_(iscomplexobj(dummy))
  208: 
  209:     def test_pandas_duck(self):
  210:         # This tests a custom np.dtype duck-typed class, such as used by pandas
  211:         # (pandas.core.dtypes)
  212:         class PdComplex(np.complex128):
  213:             pass
  214: 
  215:         class PdDtype:
  216:             name = 'category'
  217:             names = None
  218:             type = PdComplex
  219:             kind = 'c'
  220:             str = '<c16'
  221:             base = np.dtype('complex128')
  222: 
  223:         class DummyPd:
  224:             @property
  225:             def dtype(self):
  226:                 return PdDtype
  227:         dummy = DummyPd()
  228:         assert_(iscomplexobj(dummy))
  229: 
  230:     def test_custom_dtype_duck(self):
  231:         class MyArray(list):
  232:             @property
  233:             def dtype(self):
  234:                 return complex
  235: 
  236:         a = MyArray([1 + 0j, 2 + 0j, 3 + 0j])
  237:         assert_(iscomplexobj(a))
  238: 
  239: 
  240: class TestIsrealobj:
  241:     def test_basic(self):
  242:         z = np.array([-1, 0, 1])
  243:         assert_(isrealobj(z))
  244:         z = np.array([-1j, 0, -1])
  245:         assert_(not isrealobj(z))
  246: 
  247: 
  248: class TestIsnan:
  249: 
  250:     def test_goodvalues(self):
  251:         z = np.array((-1., 0., 1.))
  252:         res = np.isnan(z) == 0
  253:         assert_all(np.all(res, axis=0))
  254: 
  255:     def test_posinf(self):
  256:         with np.errstate(divide='ignore'):
  257:             assert_all(np.isnan(np.array((1.,)) / 0.) == 0)
  258: 
  259:     def test_neginf(self):
  260:         with np.errstate(divide='ignore'):
  261:             assert_all(np.isnan(np.array((-1.,)) / 0.) == 0)
  262: 
  263:     def test_ind(self):
  264:         with np.errstate(divide='ignore', invalid='ignore'):
  265:             assert_all(np.isnan(np.array((0.,)) / 0.) == 1)
  266: 
  267:     def test_integer(self):
  268:         assert_all(np.isnan(1) == 0)
  269: 
  270:     def test_complex(self):
  271:         assert_all(np.isnan(1 + 1j) == 0)
  272: 
  273:     def test_complex1(self):
  274:         with np.errstate(divide='ignore', invalid='ignore'):
  275:             assert_all(np.isnan(np.array(0 + 0j) / 0.) == 1)
  276: 
  277: 
  278: class TestIsfinite:
  279:     # Fixme, wrong place, isfinite now ufunc
  280: 
  281:     def test_goodvalues(self):
  282:         z = np.array((-1., 0., 1.))
  283:         res = np.isfinite(z) == 1
  284:         assert_all(np.all(res, axis=0))
  285: 
  286:     def test_posinf(self):
  287:         with np.errstate(divide='ignore', invalid='ignore'):
  288:             assert_all(np.isfinite(np.array((1.,)) / 0.) == 0)
  289: 
  290:     def test_neginf(self):
  291:         with np.errstate(divide='ignore', invalid='ignore'):
  292:             assert_all(np.isfinite(np.array((-1.,)) / 0.) == 0)
  293: 
  294:     def test_ind(self):
  295:         with np.errstate(divide='ignore', invalid='ignore'):
  296:             assert_all(np.isfinite(np.array((0.,)) / 0.) == 0)
  297: 
  298:     def test_integer(self):
  299:         assert_all(np.isfinite(1) == 1)
  300: 
  301:     def test_complex(self):
  302:         assert_all(np.isfinite(1 + 1j) == 1)
  303: 
  304:     def test_complex1(self):
  305:         with np.errstate(divide='ignore', invalid='ignore'):
  306:             assert_all(np.isfinite(np.array(1 + 1j) / 0.) == 0)
  307: 
  308: 
  309: class TestIsinf:
  310:     # Fixme, wrong place, isinf now ufunc
  311: 
  312:     def test_goodvalues(self):
  313:         z = np.array((-1., 0., 1.))
  314:         res = np.isinf(z) == 0
  315:         assert_all(np.all(res, axis=0))
  316: 
  317:     def test_posinf(self):
  318:         with np.errstate(divide='ignore', invalid='ignore'):
  319:             assert_all(np.isinf(np.array((1.,)) / 0.) == 1)
  320: 
  321:     def test_posinf_scalar(self):
  322:         with np.errstate(divide='ignore', invalid='ignore'):
  323:             assert_all(np.isinf(np.array(1.,) / 0.) == 1)
  324: 
  325:     def test_neginf(self):
  326:         with np.errstate(divide='ignore', invalid='ignore'):
  327:             assert_all(np.isinf(np.array((-1.,)) / 0.) == 1)
  328: 
  329:     def test_neginf_scalar(self):
  330:         with np.errstate(divide='ignore', invalid='ignore'):
  331:             assert_all(np.isinf(np.array(-1.) / 0.) == 1)
  332: 
  333:     def test_ind(self):
  334:         with np.errstate(divide='ignore', invalid='ignore'):
  335:             assert_all(np.isinf(np.array((0.,)) / 0.) == 0)
  336: 
  337: 
  338: class TestIsposinf:
  339: 
  340:     def test_generic(self):
  341:         with np.errstate(divide='ignore', invalid='ignore'):
  342:             vals = isposinf(np.array((-1., 0, 1)) / 0.)
  343:         assert_(vals[0] == 0)
  344:         assert_(vals[1] == 0)
  345:         assert_(vals[2] == 1)
  346: 
  347: 
  348: class TestIsneginf:
  349: 
  350:     def test_generic(self):
  351:         with np.errstate(divide='ignore', invalid='ignore'):
  352:             vals = isneginf(np.array((-1., 0, 1)) / 0.)
  353:         assert_(vals[0] == 1)
  354:         assert_(vals[1] == 0)
  355:         assert_(vals[2] == 0)
  356: 
  357: 
  358: class TestNanToNum:
  359: 
  360:     def test_generic(self):
  361:         with np.errstate(divide='ignore', invalid='ignore'):
  362:             vals = nan_to_num(np.array((-1., 0, 1)) / 0.)
  363:         assert_all(vals[0] < -1e10) and assert_all(np.isfinite(vals[0]))
  364:         assert_(vals[1] == 0)
  365:         assert_all(vals[2] > 1e10) and assert_all(np.isfinite(vals[2]))
  366:         assert_equal(type(vals), np.ndarray)
  367: 
  368:         # perform the same tests but with nan, posinf and neginf keywords
  369:         with np.errstate(divide='ignore', invalid='ignore'):
  370:             vals = nan_to_num(np.array((-1., 0, 1)) / 0.,
  371:                               nan=10, posinf=20, neginf=30)
  372:         assert_equal(vals, [30, 10, 20])
  373:         assert_all(np.isfinite(vals[[0, 2]]))
  374:         assert_equal(type(vals), np.ndarray)
  375: 
  376:         # perform the same test but in-place
  377:         with np.errstate(divide='ignore', invalid='ignore'):
  378:             vals = np.array((-1., 0, 1)) / 0.
  379:         result = nan_to_num(vals, copy=False)
  380: 
  381:         assert_(result is vals)
  382:         assert_all(vals[0] < -1e10) and assert_all(np.isfinite(vals[0]))
  383:         assert_(vals[1] == 0)
  384:         assert_all(vals[2] > 1e10) and assert_all(np.isfinite(vals[2]))
  385:         assert_equal(type(vals), np.ndarray)
  386: 
  387:         # perform the same test but in-place
  388:         with np.errstate(divide='ignore', invalid='ignore'):
  389:             vals = np.array((-1., 0, 1)) / 0.
  390:         result = nan_to_num(vals, copy=False, nan=10, posinf=20, neginf=30)
  391: 
  392:         assert_(result is vals)
  393:         assert_equal(vals, [30, 10, 20])
  394:         assert_all(np.isfinite(vals[[0, 2]]))
  395:         assert_equal(type(vals), np.ndarray)
  396: 
  397:     def test_array(self):
  398:         vals = nan_to_num([1])
  399:         assert_array_equal(vals, np.array([1], int))
  400:         assert_equal(type(vals), np.ndarray)
  401:         vals = nan_to_num([1], nan=10, posinf=20, neginf=30)
  402:         assert_array_equal(vals, np.array([1], int))
  403:         assert_equal(type(vals), np.ndarray)
  404: 
  405:     def test_integer(self):
  406:         vals = nan_to_num(1)
  407:         assert_all(vals == 1)
  408:         assert_equal(type(vals), np.int_)
  409:         vals = nan_to_num(1, nan=10, posinf=20, neginf=30)
  410:         assert_all(vals == 1)
  411:         assert_equal(type(vals), np.int_)
  412: 
  413:     def test_float(self):
  414:         vals = nan_to_num(1.0)
  415:         assert_all(vals == 1.0)
  416:         assert_equal(type(vals), np.float64)
  417:         vals = nan_to_num(1.1, nan=10, posinf=20, neginf=30)
  418:         assert_all(vals == 1.1)
  419:         assert_equal(type(vals), np.float64)
  420: 
  421:     def test_complex_good(self):
  422:         vals = nan_to_num(1 + 1j)
  423:         assert_all(vals == 1 + 1j)
  424:         assert_equal(type(vals), np.complex128)
  425:         vals = nan_to_num(1 + 1j, nan=10, posinf=20, neginf=30)
  426:         assert_all(vals == 1 + 1j)
  427:         assert_equal(type(vals), np.complex128)
  428: 
  429:     def test_complex_bad(self):
  430:         with np.errstate(divide='ignore', invalid='ignore'):
  431:             v = 1 + 1j
  432:             v += np.array(0 + 1.j) / 0.
  433:         vals = nan_to_num(v)
  434:         # !! This is actually (unexpectedly) zero
  435:         assert_all(np.isfinite(vals))
  436:         assert_equal(type(vals), np.complex128)
  437: 
  438:     def test_complex_bad2(self):
  439:         with np.errstate(divide='ignore', invalid='ignore'):
  440:             v = 1 + 1j
  441:             v += np.array(-1 + 1.j) / 0.
  442:         vals = nan_to_num(v)
  443:         assert_all(np.isfinite(vals))
  444:         assert_equal(type(vals), np.complex128)
  445:         # Fixme
  446:         #assert_all(vals.imag > 1e10)  and assert_all(np.isfinite(vals))
  447:         # !! This is actually (unexpectedly) positive
  448:         # !! inf.  Comment out for now, and see if it
  449:         # !! changes
  450:         #assert_all(vals.real < -1e10) and assert_all(np.isfinite(vals))
  451: 
  452:     def test_do_not_rewrite_previous_keyword(self):
  453:         # This is done to test that when, for instance, nan=np.inf then these
  454:         # values are not rewritten by posinf keyword to the posinf value.
  455:         with np.errstate(divide='ignore', invalid='ignore'):
  456:             vals = nan_to_num(np.array((-1., 0, 1)) / 0., nan=np.inf, posinf=999)
  457:         assert_all(np.isfinite(vals[[0, 2]]))
  458:         assert_all(vals[0] < -1e10)
  459:         assert_equal(vals[[1, 2]], [np.inf, 999])
  460:         assert_equal(type(vals), np.ndarray)
  461: 
  462: 
  463: class TestRealIfClose:
  464: 
  465:     def test_basic(self):
  466:         a = np.random.rand(10)
  467:         b = real_if_close(a + 1e-15j)
  468:         assert_all(isrealobj(b))
  469:         assert_array_equal(a, b)
  470:         b = real_if_close(a + 1e-7j)
  471:         assert_all(iscomplexobj(b))
  472:         b = real_if_close(a + 1e-7j, tol=1e-6)
  473:         assert_all(isrealobj(b))
