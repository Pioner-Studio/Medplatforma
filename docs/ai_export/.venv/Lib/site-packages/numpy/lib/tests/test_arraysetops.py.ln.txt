    1: """Test functions for 1D array set operations.
    2: 
    3: """
    4: import pytest
    5: 
    6: import numpy as np
    7: from numpy import ediff1d, intersect1d, isin, setdiff1d, setxor1d, union1d, unique
    8: from numpy.exceptions import AxisError
    9: from numpy.testing import (
   10:     assert_array_equal,
   11:     assert_equal,
   12:     assert_raises,
   13:     assert_raises_regex,
   14: )
   15: 
   16: 
   17: class TestSetOps:
   18: 
   19:     def test_intersect1d(self):
   20:         # unique inputs
   21:         a = np.array([5, 7, 1, 2])
   22:         b = np.array([2, 4, 3, 1, 5])
   23: 
   24:         ec = np.array([1, 2, 5])
   25:         c = intersect1d(a, b, assume_unique=True)
   26:         assert_array_equal(c, ec)
   27: 
   28:         # non-unique inputs
   29:         a = np.array([5, 5, 7, 1, 2])
   30:         b = np.array([2, 1, 4, 3, 3, 1, 5])
   31: 
   32:         ed = np.array([1, 2, 5])
   33:         c = intersect1d(a, b)
   34:         assert_array_equal(c, ed)
   35:         assert_array_equal([], intersect1d([], []))
   36: 
   37:     def test_intersect1d_array_like(self):
   38:         # See gh-11772
   39:         class Test:
   40:             def __array__(self, dtype=None, copy=None):
   41:                 return np.arange(3)
   42: 
   43:         a = Test()
   44:         res = intersect1d(a, a)
   45:         assert_array_equal(res, a)
   46:         res = intersect1d([1, 2, 3], [1, 2, 3])
   47:         assert_array_equal(res, [1, 2, 3])
   48: 
   49:     def test_intersect1d_indices(self):
   50:         # unique inputs
   51:         a = np.array([1, 2, 3, 4])
   52:         b = np.array([2, 1, 4, 6])
   53:         c, i1, i2 = intersect1d(a, b, assume_unique=True, return_indices=True)
   54:         ee = np.array([1, 2, 4])
   55:         assert_array_equal(c, ee)
   56:         assert_array_equal(a[i1], ee)
   57:         assert_array_equal(b[i2], ee)
   58: 
   59:         # non-unique inputs
   60:         a = np.array([1, 2, 2, 3, 4, 3, 2])
   61:         b = np.array([1, 8, 4, 2, 2, 3, 2, 3])
   62:         c, i1, i2 = intersect1d(a, b, return_indices=True)
   63:         ef = np.array([1, 2, 3, 4])
   64:         assert_array_equal(c, ef)
   65:         assert_array_equal(a[i1], ef)
   66:         assert_array_equal(b[i2], ef)
   67: 
   68:         # non1d, unique inputs
   69:         a = np.array([[2, 4, 5, 6], [7, 8, 1, 15]])
   70:         b = np.array([[3, 2, 7, 6], [10, 12, 8, 9]])
   71:         c, i1, i2 = intersect1d(a, b, assume_unique=True, return_indices=True)
   72:         ui1 = np.unravel_index(i1, a.shape)
   73:         ui2 = np.unravel_index(i2, b.shape)
   74:         ea = np.array([2, 6, 7, 8])
   75:         assert_array_equal(ea, a[ui1])
   76:         assert_array_equal(ea, b[ui2])
   77: 
   78:         # non1d, not assumed to be uniqueinputs
   79:         a = np.array([[2, 4, 5, 6, 6], [4, 7, 8, 7, 2]])
   80:         b = np.array([[3, 2, 7, 7], [10, 12, 8, 7]])
   81:         c, i1, i2 = intersect1d(a, b, return_indices=True)
   82:         ui1 = np.unravel_index(i1, a.shape)
   83:         ui2 = np.unravel_index(i2, b.shape)
   84:         ea = np.array([2, 7, 8])
   85:         assert_array_equal(ea, a[ui1])
   86:         assert_array_equal(ea, b[ui2])
   87: 
   88:     def test_setxor1d(self):
   89:         a = np.array([5, 7, 1, 2])
   90:         b = np.array([2, 4, 3, 1, 5])
   91: 
   92:         ec = np.array([3, 4, 7])
   93:         c = setxor1d(a, b)
   94:         assert_array_equal(c, ec)
   95: 
   96:         a = np.array([1, 2, 3])
   97:         b = np.array([6, 5, 4])
   98: 
   99:         ec = np.array([1, 2, 3, 4, 5, 6])
  100:         c = setxor1d(a, b)
  101:         assert_array_equal(c, ec)
  102: 
  103:         a = np.array([1, 8, 2, 3])
  104:         b = np.array([6, 5, 4, 8])
  105: 
  106:         ec = np.array([1, 2, 3, 4, 5, 6])
  107:         c = setxor1d(a, b)
  108:         assert_array_equal(c, ec)
  109: 
  110:         assert_array_equal([], setxor1d([], []))
  111: 
  112:     def test_setxor1d_unique(self):
  113:         a = np.array([1, 8, 2, 3])
  114:         b = np.array([6, 5, 4, 8])
  115: 
  116:         ec = np.array([1, 2, 3, 4, 5, 6])
  117:         c = setxor1d(a, b, assume_unique=True)
  118:         assert_array_equal(c, ec)
  119: 
  120:         a = np.array([[1], [8], [2], [3]])
  121:         b = np.array([[6, 5], [4, 8]])
  122: 
  123:         ec = np.array([1, 2, 3, 4, 5, 6])
  124:         c = setxor1d(a, b, assume_unique=True)
  125:         assert_array_equal(c, ec)
  126: 
  127:     def test_ediff1d(self):
  128:         zero_elem = np.array([])
  129:         one_elem = np.array([1])
  130:         two_elem = np.array([1, 2])
  131: 
  132:         assert_array_equal([], ediff1d(zero_elem))
  133:         assert_array_equal([0], ediff1d(zero_elem, to_begin=0))
  134:         assert_array_equal([0], ediff1d(zero_elem, to_end=0))
  135:         assert_array_equal([-1, 0], ediff1d(zero_elem, to_begin=-1, to_end=0))
  136:         assert_array_equal([], ediff1d(one_elem))
  137:         assert_array_equal([1], ediff1d(two_elem))
  138:         assert_array_equal([7, 1, 9], ediff1d(two_elem, to_begin=7, to_end=9))
  139:         assert_array_equal([5, 6, 1, 7, 8],
  140:                            ediff1d(two_elem, to_begin=[5, 6], to_end=[7, 8]))
  141:         assert_array_equal([1, 9], ediff1d(two_elem, to_end=9))
  142:         assert_array_equal([1, 7, 8], ediff1d(two_elem, to_end=[7, 8]))
  143:         assert_array_equal([7, 1], ediff1d(two_elem, to_begin=7))
  144:         assert_array_equal([5, 6, 1], ediff1d(two_elem, to_begin=[5, 6]))
  145: 
  146:     @pytest.mark.parametrize("ary, prepend, append, expected", [
  147:         # should fail because trying to cast
  148:         # np.nan standard floating point value
  149:         # into an integer array:
  150:         (np.array([1, 2, 3], dtype=np.int64),
  151:          None,
  152:          np.nan,
  153:          'to_end'),
  154:         # should fail because attempting
  155:         # to downcast to int type:
  156:         (np.array([1, 2, 3], dtype=np.int64),
  157:          np.array([5, 7, 2], dtype=np.float32),
  158:          None,
  159:          'to_begin'),
  160:         # should fail because attempting to cast
  161:         # two special floating point values
  162:         # to integers (on both sides of ary),
  163:         # `to_begin` is in the error message as the impl checks this first:
  164:         (np.array([1., 3., 9.], dtype=np.int8),
  165:          np.nan,
  166:          np.nan,
  167:          'to_begin'),
  168:          ])
  169:     def test_ediff1d_forbidden_type_casts(self, ary, prepend, append, expected):
  170:         # verify resolution of gh-11490
  171: 
  172:         # specifically, raise an appropriate
  173:         # Exception when attempting to append or
  174:         # prepend with an incompatible type
  175:         msg = f'dtype of `{expected}` must be compatible'
  176:         with assert_raises_regex(TypeError, msg):
  177:             ediff1d(ary=ary,
  178:                     to_end=append,
  179:                     to_begin=prepend)
  180: 
  181:     @pytest.mark.parametrize(
  182:         "ary,prepend,append,expected",
  183:         [
  184:          (np.array([1, 2, 3], dtype=np.int16),
  185:           2**16,  # will be cast to int16 under same kind rule.
  186:           2**16 + 4,
  187:           np.array([0, 1, 1, 4], dtype=np.int16)),
  188:          (np.array([1, 2, 3], dtype=np.float32),
  189:           np.array([5], dtype=np.float64),
  190:           None,
  191:           np.array([5, 1, 1], dtype=np.float32)),
  192:          (np.array([1, 2, 3], dtype=np.int32),
  193:           0,
  194:           0,
  195:           np.array([0, 1, 1, 0], dtype=np.int32)),
  196:          (np.array([1, 2, 3], dtype=np.int64),
  197:           3,
  198:           -9,
  199:           np.array([3, 1, 1, -9], dtype=np.int64)),
  200:         ]
  201:     )
  202:     def test_ediff1d_scalar_handling(self,
  203:                                      ary,
  204:                                      prepend,
  205:                                      append,
  206:                                      expected):
  207:         # maintain backwards-compatibility
  208:         # of scalar prepend / append behavior
  209:         # in ediff1d following fix for gh-11490
  210:         actual = np.ediff1d(ary=ary,
  211:                             to_end=append,
  212:                             to_begin=prepend)
  213:         assert_equal(actual, expected)
  214:         assert actual.dtype == expected.dtype
  215: 
  216:     @pytest.mark.parametrize("kind", [None, "sort", "table"])
  217:     def test_isin(self, kind):
  218:         def _isin_slow(a, b):
  219:             b = np.asarray(b).flatten().tolist()
  220:             return a in b
  221:         isin_slow = np.vectorize(_isin_slow, otypes=[bool], excluded={1})
  222: 
  223:         def assert_isin_equal(a, b):
  224:             x = isin(a, b, kind=kind)
  225:             y = isin_slow(a, b)
  226:             assert_array_equal(x, y)
  227: 
  228:         # multidimensional arrays in both arguments
  229:         a = np.arange(24).reshape([2, 3, 4])
  230:         b = np.array([[10, 20, 30], [0, 1, 3], [11, 22, 33]])
  231:         assert_isin_equal(a, b)
  232: 
  233:         # array-likes as both arguments
  234:         c = [(9, 8), (7, 6)]
  235:         d = (9, 7)
  236:         assert_isin_equal(c, d)
  237: 
  238:         # zero-d array:
  239:         f = np.array(3)
  240:         assert_isin_equal(f, b)
  241:         assert_isin_equal(a, f)
  242:         assert_isin_equal(f, f)
  243: 
  244:         # scalar:
  245:         assert_isin_equal(5, b)
  246:         assert_isin_equal(a, 6)
  247:         assert_isin_equal(5, 6)
  248: 
  249:         # empty array-like:
  250:         if kind != "table":
  251:             # An empty list will become float64,
  252:             # which is invalid for kind="table"
  253:             x = []
  254:             assert_isin_equal(x, b)
  255:             assert_isin_equal(a, x)
  256:             assert_isin_equal(x, x)
  257: 
  258:         # empty array with various types:
  259:         for dtype in [bool, np.int64, np.float64]:
  260:             if kind == "table" and dtype == np.float64:
  261:                 continue
  262: 
  263:             if dtype in {np.int64, np.float64}:
  264:                 ar = np.array([10, 20, 30], dtype=dtype)
  265:             elif dtype in {bool}:
  266:                 ar = np.array([True, False, False])
  267: 
  268:             empty_array = np.array([], dtype=dtype)
  269: 
  270:             assert_isin_equal(empty_array, ar)
  271:             assert_isin_equal(ar, empty_array)
  272:             assert_isin_equal(empty_array, empty_array)
  273: 
  274:     @pytest.mark.parametrize("kind", [None, "sort", "table"])
  275:     def test_isin_additional(self, kind):
  276:         # we use two different sizes for the b array here to test the
  277:         # two different paths in isin().
  278:         for mult in (1, 10):
  279:             # One check without np.array to make sure lists are handled correct
  280:             a = [5, 7, 1, 2]
  281:             b = [2, 4, 3, 1, 5] * mult
  282:             ec = np.array([True, False, True, True])
  283:             c = isin(a, b, assume_unique=True, kind=kind)
  284:             assert_array_equal(c, ec)
  285: 
  286:             a[0] = 8
  287:             ec = np.array([False, False, True, True])
  288:             c = isin(a, b, assume_unique=True, kind=kind)
  289:             assert_array_equal(c, ec)
  290: 
  291:             a[0], a[3] = 4, 8
  292:             ec = np.array([True, False, True, False])
  293:             c = isin(a, b, assume_unique=True, kind=kind)
  294:             assert_array_equal(c, ec)
  295: 
  296:             a = np.array([5, 4, 5, 3, 4, 4, 3, 4, 3, 5, 2, 1, 5, 5])
  297:             b = [2, 3, 4] * mult
  298:             ec = [False, True, False, True, True, True, True, True, True,
  299:                   False, True, False, False, False]
  300:             c = isin(a, b, kind=kind)
  301:             assert_array_equal(c, ec)
  302: 
  303:             b = b + [5, 5, 4] * mult
  304:             ec = [True, True, True, True, True, True, True, True, True, True,
  305:                   True, False, True, True]
  306:             c = isin(a, b, kind=kind)
  307:             assert_array_equal(c, ec)
  308: 
  309:             a = np.array([5, 7, 1, 2])
  310:             b = np.array([2, 4, 3, 1, 5] * mult)
  311:             ec = np.array([True, False, True, True])
  312:             c = isin(a, b, kind=kind)
  313:             assert_array_equal(c, ec)
  314: 
  315:             a = np.array([5, 7, 1, 1, 2])
  316:             b = np.array([2, 4, 3, 3, 1, 5] * mult)
  317:             ec = np.array([True, False, True, True, True])
  318:             c = isin(a, b, kind=kind)
  319:             assert_array_equal(c, ec)
  320: 
  321:             a = np.array([5, 5])
  322:             b = np.array([2, 2] * mult)
  323:             ec = np.array([False, False])
  324:             c = isin(a, b, kind=kind)
  325:             assert_array_equal(c, ec)
  326: 
  327:         a = np.array([5])
  328:         b = np.array([2])
  329:         ec = np.array([False])
  330:         c = isin(a, b, kind=kind)
  331:         assert_array_equal(c, ec)
  332: 
  333:         if kind in {None, "sort"}:
  334:             assert_array_equal(isin([], [], kind=kind), [])
  335: 
  336:     def test_isin_char_array(self):
  337:         a = np.array(['a', 'b', 'c', 'd', 'e', 'c', 'e', 'b'])
  338:         b = np.array(['a', 'c'])
  339: 
  340:         ec = np.array([True, False, True, False, False, True, False, False])
  341:         c = isin(a, b)
  342: 
  343:         assert_array_equal(c, ec)
  344: 
  345:     @pytest.mark.parametrize("kind", [None, "sort", "table"])
  346:     def test_isin_invert(self, kind):
  347:         "Test isin's invert parameter"
  348:         # We use two different sizes for the b array here to test the
  349:         # two different paths in isin().
  350:         for mult in (1, 10):
  351:             a = np.array([5, 4, 5, 3, 4, 4, 3, 4, 3, 5, 2, 1, 5, 5])
  352:             b = [2, 3, 4] * mult
  353:             assert_array_equal(np.invert(isin(a, b, kind=kind)),
  354:                                isin(a, b, invert=True, kind=kind))
  355: 
  356:         # float:
  357:         if kind in {None, "sort"}:
  358:             for mult in (1, 10):
  359:                 a = np.array([5, 4, 5, 3, 4, 4, 3, 4, 3, 5, 2, 1, 5, 5],
  360:                             dtype=np.float32)
  361:                 b = [2, 3, 4] * mult
  362:                 b = np.array(b, dtype=np.float32)
  363:                 assert_array_equal(np.invert(isin(a, b, kind=kind)),
  364:                                    isin(a, b, invert=True, kind=kind))
  365: 
  366:     def test_isin_hit_alternate_algorithm(self):
  367:         """Hit the standard isin code with integers"""
  368:         # Need extreme range to hit standard code
  369:         # This hits it without the use of kind='table'
  370:         a = np.array([5, 4, 5, 3, 4, 4, 1e9], dtype=np.int64)
  371:         b = np.array([2, 3, 4, 1e9], dtype=np.int64)
  372:         expected = np.array([0, 1, 0, 1, 1, 1, 1], dtype=bool)
  373:         assert_array_equal(expected, isin(a, b))
  374:         assert_array_equal(np.invert(expected), isin(a, b, invert=True))
  375: 
  376:         a = np.array([5, 7, 1, 2], dtype=np.int64)
  377:         b = np.array([2, 4, 3, 1, 5, 1e9], dtype=np.int64)
  378:         ec = np.array([True, False, True, True])
  379:         c = isin(a, b, assume_unique=True)
  380:         assert_array_equal(c, ec)
  381: 
  382:     @pytest.mark.parametrize("kind", [None, "sort", "table"])
  383:     def test_isin_boolean(self, kind):
  384:         """Test that isin works for boolean input"""
  385:         a = np.array([True, False])
  386:         b = np.array([False, False, False])
  387:         expected = np.array([False, True])
  388:         assert_array_equal(expected,
  389:                            isin(a, b, kind=kind))
  390:         assert_array_equal(np.invert(expected),
  391:                            isin(a, b, invert=True, kind=kind))
  392: 
  393:     @pytest.mark.parametrize("kind", [None, "sort"])
  394:     def test_isin_timedelta(self, kind):
  395:         """Test that isin works for timedelta input"""
  396:         rstate = np.random.RandomState(0)
  397:         a = rstate.randint(0, 100, size=10)
  398:         b = rstate.randint(0, 100, size=10)
  399:         truth = isin(a, b)
  400:         a_timedelta = a.astype("timedelta64[s]")
  401:         b_timedelta = b.astype("timedelta64[s]")
  402:         assert_array_equal(truth, isin(a_timedelta, b_timedelta, kind=kind))
  403: 
  404:     def test_isin_table_timedelta_fails(self):
  405:         a = np.array([0, 1, 2], dtype="timedelta64[s]")
  406:         b = a
  407:         # Make sure it raises a value error:
  408:         with pytest.raises(ValueError):
  409:             isin(a, b, kind="table")
  410: 
  411:     @pytest.mark.parametrize(
  412:         "dtype1,dtype2",
  413:         [
  414:             (np.int8, np.int16),
  415:             (np.int16, np.int8),
  416:             (np.uint8, np.uint16),
  417:             (np.uint16, np.uint8),
  418:             (np.uint8, np.int16),
  419:             (np.int16, np.uint8),
  420:             (np.uint64, np.int64),
  421:         ]
  422:     )
  423:     @pytest.mark.parametrize("kind", [None, "sort", "table"])
  424:     def test_isin_mixed_dtype(self, dtype1, dtype2, kind):
  425:         """Test that isin works as expected for mixed dtype input."""
  426:         is_dtype2_signed = np.issubdtype(dtype2, np.signedinteger)
  427:         ar1 = np.array([0, 0, 1, 1], dtype=dtype1)
  428: 
  429:         if is_dtype2_signed:
  430:             ar2 = np.array([-128, 0, 127], dtype=dtype2)
  431:         else:
  432:             ar2 = np.array([127, 0, 255], dtype=dtype2)
  433: 
  434:         expected = np.array([True, True, False, False])
  435: 
  436:         expect_failure = kind == "table" and (
  437:             dtype1 == np.int16 and dtype2 == np.int8)
  438: 
  439:         if expect_failure:
  440:             with pytest.raises(RuntimeError, match="exceed the maximum"):
  441:                 isin(ar1, ar2, kind=kind)
  442:         else:
  443:             assert_array_equal(isin(ar1, ar2, kind=kind), expected)
  444: 
  445:     @pytest.mark.parametrize("data", [
  446:         np.array([2**63, 2**63 + 1], dtype=np.uint64),
  447:         np.array([-2**62, -2**62 - 1], dtype=np.int64),
  448:     ])
  449:     @pytest.mark.parametrize("kind", [None, "sort", "table"])
  450:     def test_isin_mixed_huge_vals(self, kind, data):
  451:         """Test values outside intp range (negative ones if 32bit system)"""
  452:         query = data[1]
  453:         res = np.isin(data, query, kind=kind)
  454:         assert_array_equal(res, [False, True])
  455:         # Also check that nothing weird happens for values can't possibly
  456:         # in range.
  457:         data = data.astype(np.int32)  # clearly different values
  458:         res = np.isin(data, query, kind=kind)
  459:         assert_array_equal(res, [False, False])
  460: 
  461:     @pytest.mark.parametrize("kind", [None, "sort", "table"])
  462:     def test_isin_mixed_boolean(self, kind):
  463:         """Test that isin works as expected for bool/int input."""
  464:         for dtype in np.typecodes["AllInteger"]:
  465:             a = np.array([True, False, False], dtype=bool)
  466:             b = np.array([0, 0, 0, 0], dtype=dtype)
  467:             expected = np.array([False, True, True], dtype=bool)
  468:             assert_array_equal(isin(a, b, kind=kind), expected)
  469: 
  470:             a, b = b, a
  471:             expected = np.array([True, True, True, True], dtype=bool)
  472:             assert_array_equal(isin(a, b, kind=kind), expected)
  473: 
  474:     def test_isin_first_array_is_object(self):
  475:         ar1 = [None]
  476:         ar2 = np.array([1] * 10)
  477:         expected = np.array([False])
  478:         result = np.isin(ar1, ar2)
  479:         assert_array_equal(result, expected)
  480: 
  481:     def test_isin_second_array_is_object(self):
  482:         ar1 = 1
  483:         ar2 = np.array([None] * 10)
  484:         expected = np.array([False])
  485:         result = np.isin(ar1, ar2)
  486:         assert_array_equal(result, expected)
  487: 
  488:     def test_isin_both_arrays_are_object(self):
  489:         ar1 = [None]
  490:         ar2 = np.array([None] * 10)
  491:         expected = np.array([True])
  492:         result = np.isin(ar1, ar2)
  493:         assert_array_equal(result, expected)
  494: 
  495:     def test_isin_both_arrays_have_structured_dtype(self):
  496:         # Test arrays of a structured data type containing an integer field
  497:         # and a field of dtype `object` allowing for arbitrary Python objects
  498:         dt = np.dtype([('field1', int), ('field2', object)])
  499:         ar1 = np.array([(1, None)], dtype=dt)
  500:         ar2 = np.array([(1, None)] * 10, dtype=dt)
  501:         expected = np.array([True])
  502:         result = np.isin(ar1, ar2)
  503:         assert_array_equal(result, expected)
  504: 
  505:     def test_isin_with_arrays_containing_tuples(self):
  506:         ar1 = np.array([(1,), 2], dtype=object)
  507:         ar2 = np.array([(1,), 2], dtype=object)
  508:         expected = np.array([True, True])
  509:         result = np.isin(ar1, ar2)
  510:         assert_array_equal(result, expected)
  511:         result = np.isin(ar1, ar2, invert=True)
  512:         assert_array_equal(result, np.invert(expected))
  513: 
  514:         # An integer is added at the end of the array to make sure
  515:         # that the array builder will create the array with tuples
  516:         # and after it's created the integer is removed.
  517:         # There's a bug in the array constructor that doesn't handle
  518:         # tuples properly and adding the integer fixes that.
  519:         ar1 = np.array([(1,), (2, 1), 1], dtype=object)
  520:         ar1 = ar1[:-1]
  521:         ar2 = np.array([(1,), (2, 1), 1], dtype=object)
  522:         ar2 = ar2[:-1]
  523:         expected = np.array([True, True])
  524:         result = np.isin(ar1, ar2)
  525:         assert_array_equal(result, expected)
  526:         result = np.isin(ar1, ar2, invert=True)
  527:         assert_array_equal(result, np.invert(expected))
  528: 
  529:         ar1 = np.array([(1,), (2, 3), 1], dtype=object)
  530:         ar1 = ar1[:-1]
  531:         ar2 = np.array([(1,), 2], dtype=object)
  532:         expected = np.array([True, False])
  533:         result = np.isin(ar1, ar2)
  534:         assert_array_equal(result, expected)
  535:         result = np.isin(ar1, ar2, invert=True)
  536:         assert_array_equal(result, np.invert(expected))
  537: 
  538:     def test_isin_errors(self):
  539:         """Test that isin raises expected errors."""
  540: 
  541:         # Error 1: `kind` is not one of 'sort' 'table' or None.
  542:         ar1 = np.array([1, 2, 3, 4, 5])
  543:         ar2 = np.array([2, 4, 6, 8, 10])
  544:         assert_raises(ValueError, isin, ar1, ar2, kind='quicksort')
  545: 
  546:         # Error 2: `kind="table"` does not work for non-integral arrays.
  547:         obj_ar1 = np.array([1, 'a', 3, 'b', 5], dtype=object)
  548:         obj_ar2 = np.array([1, 'a', 3, 'b', 5], dtype=object)
  549:         assert_raises(ValueError, isin, obj_ar1, obj_ar2, kind='table')
  550: 
  551:         for dtype in [np.int32, np.int64]:
  552:             ar1 = np.array([-1, 2, 3, 4, 5], dtype=dtype)
  553:             # The range of this array will overflow:
  554:             overflow_ar2 = np.array([-1, np.iinfo(dtype).max], dtype=dtype)
  555: 
  556:             # Error 3: `kind="table"` will trigger a runtime error
  557:             #  if there is an integer overflow expected when computing the
  558:             #  range of ar2
  559:             assert_raises(
  560:                 RuntimeError,
  561:                 isin, ar1, overflow_ar2, kind='table'
  562:             )
  563: 
  564:             # Non-error: `kind=None` will *not* trigger a runtime error
  565:             #  if there is an integer overflow, it will switch to
  566:             #  the `sort` algorithm.
  567:             result = np.isin(ar1, overflow_ar2, kind=None)
  568:             assert_array_equal(result, [True] + [False] * 4)
  569:             result = np.isin(ar1, overflow_ar2, kind='sort')
  570:             assert_array_equal(result, [True] + [False] * 4)
  571: 
  572:     def test_union1d(self):
  573:         a = np.array([5, 4, 7, 1, 2])
  574:         b = np.array([2, 4, 3, 3, 2, 1, 5])
  575: 
  576:         ec = np.array([1, 2, 3, 4, 5, 7])
  577:         c = union1d(a, b)
  578:         assert_array_equal(c, ec)
  579: 
  580:         # Tests gh-10340, arguments to union1d should be
  581:         # flattened if they are not already 1D
  582:         x = np.array([[0, 1, 2], [3, 4, 5]])
  583:         y = np.array([0, 1, 2, 3, 4])
  584:         ez = np.array([0, 1, 2, 3, 4, 5])
  585:         z = union1d(x, y)
  586:         assert_array_equal(z, ez)
  587: 
  588:         assert_array_equal([], union1d([], []))
  589: 
  590:     def test_setdiff1d(self):
  591:         a = np.array([6, 5, 4, 7, 1, 2, 7, 4])
  592:         b = np.array([2, 4, 3, 3, 2, 1, 5])
  593: 
  594:         ec = np.array([6, 7])
  595:         c = setdiff1d(a, b)
  596:         assert_array_equal(c, ec)
  597: 
  598:         a = np.arange(21)
  599:         b = np.arange(19)
  600:         ec = np.array([19, 20])
  601:         c = setdiff1d(a, b)
  602:         assert_array_equal(c, ec)
  603: 
  604:         assert_array_equal([], setdiff1d([], []))
  605:         a = np.array((), np.uint32)
  606:         assert_equal(setdiff1d(a, []).dtype, np.uint32)
  607: 
  608:     def test_setdiff1d_unique(self):
  609:         a = np.array([3, 2, 1])
  610:         b = np.array([7, 5, 2])
  611:         expected = np.array([3, 1])
  612:         actual = setdiff1d(a, b, assume_unique=True)
  613:         assert_equal(actual, expected)
  614: 
  615:     def test_setdiff1d_char_array(self):
  616:         a = np.array(['a', 'b', 'c'])
  617:         b = np.array(['a', 'b', 's'])
  618:         assert_array_equal(setdiff1d(a, b), np.array(['c']))
  619: 
  620:     def test_manyways(self):
  621:         a = np.array([5, 7, 1, 2, 8])
  622:         b = np.array([9, 8, 2, 4, 3, 1, 5])
  623: 
  624:         c1 = setxor1d(a, b)
  625:         aux1 = intersect1d(a, b)
  626:         aux2 = union1d(a, b)
  627:         c2 = setdiff1d(aux2, aux1)
  628:         assert_array_equal(c1, c2)
  629: 
  630: 
  631: class TestUnique:
  632: 
  633:     def check_all(self, a, b, i1, i2, c, dt):
  634:         base_msg = 'check {0} failed for type {1}'
  635: 
  636:         msg = base_msg.format('values', dt)
  637:         v = unique(a)
  638:         assert_array_equal(v, b, msg)
  639:         assert type(v) == type(b)
  640: 
  641:         msg = base_msg.format('return_index', dt)
  642:         v, j = unique(a, True, False, False)
  643:         assert_array_equal(v, b, msg)
  644:         assert_array_equal(j, i1, msg)
  645:         assert type(v) == type(b)
  646: 
  647:         msg = base_msg.format('return_inverse', dt)
  648:         v, j = unique(a, False, True, False)
  649:         assert_array_equal(v, b, msg)
  650:         assert_array_equal(j, i2, msg)
  651:         assert type(v) == type(b)
  652: 
  653:         msg = base_msg.format('return_counts', dt)
  654:         v, j = unique(a, False, False, True)
  655:         assert_array_equal(v, b, msg)
  656:         assert_array_equal(j, c, msg)
  657:         assert type(v) == type(b)
  658: 
  659:         msg = base_msg.format('return_index and return_inverse', dt)
  660:         v, j1, j2 = unique(a, True, True, False)
  661:         assert_array_equal(v, b, msg)
  662:         assert_array_equal(j1, i1, msg)
  663:         assert_array_equal(j2, i2, msg)
  664:         assert type(v) == type(b)
  665: 
  666:         msg = base_msg.format('return_index and return_counts', dt)
  667:         v, j1, j2 = unique(a, True, False, True)
  668:         assert_array_equal(v, b, msg)
  669:         assert_array_equal(j1, i1, msg)
  670:         assert_array_equal(j2, c, msg)
  671:         assert type(v) == type(b)
  672: 
  673:         msg = base_msg.format('return_inverse and return_counts', dt)
  674:         v, j1, j2 = unique(a, False, True, True)
  675:         assert_array_equal(v, b, msg)
  676:         assert_array_equal(j1, i2, msg)
  677:         assert_array_equal(j2, c, msg)
  678:         assert type(v) == type(b)
  679: 
  680:         msg = base_msg.format(('return_index, return_inverse '
  681:                                 'and return_counts'), dt)
  682:         v, j1, j2, j3 = unique(a, True, True, True)
  683:         assert_array_equal(v, b, msg)
  684:         assert_array_equal(j1, i1, msg)
  685:         assert_array_equal(j2, i2, msg)
  686:         assert_array_equal(j3, c, msg)
  687:         assert type(v) == type(b)
  688: 
  689:     def get_types(self):
  690:         types = []
  691:         types.extend(np.typecodes['AllInteger'])
  692:         types.extend(np.typecodes['AllFloat'])
  693:         types.append('datetime64[D]')
  694:         types.append('timedelta64[D]')
  695:         return types
  696: 
  697:     def test_unique_1d(self):
  698: 
  699:         a = [5, 7, 1, 2, 1, 5, 7] * 10
  700:         b = [1, 2, 5, 7]
  701:         i1 = [2, 3, 0, 1]
  702:         i2 = [2, 3, 0, 1, 0, 2, 3] * 10
  703:         c = np.multiply([2, 1, 2, 2], 10)
  704: 
  705:         # test for numeric arrays
  706:         types = self.get_types()
  707:         for dt in types:
  708:             aa = np.array(a, dt)
  709:             bb = np.array(b, dt)
  710:             self.check_all(aa, bb, i1, i2, c, dt)
  711: 
  712:         # test for object arrays
  713:         dt = 'O'
  714:         aa = np.empty(len(a), dt)
  715:         aa[:] = a
  716:         bb = np.empty(len(b), dt)
  717:         bb[:] = b
  718:         self.check_all(aa, bb, i1, i2, c, dt)
  719: 
  720:         # test for structured arrays
  721:         dt = [('', 'i'), ('', 'i')]
  722:         aa = np.array(list(zip(a, a)), dt)
  723:         bb = np.array(list(zip(b, b)), dt)
  724:         self.check_all(aa, bb, i1, i2, c, dt)
  725: 
  726:         # test for ticket #2799
  727:         aa = [1. + 0.j, 1 - 1.j, 1]
  728:         assert_array_equal(np.unique(aa), [1. - 1.j, 1. + 0.j])
  729: 
  730:         # test for ticket #4785
  731:         a = [(1, 2), (1, 2), (2, 3)]
  732:         unq = [1, 2, 3]
  733:         inv = [[0, 1], [0, 1], [1, 2]]
  734:         a1 = unique(a)
  735:         assert_array_equal(a1, unq)
  736:         a2, a2_inv = unique(a, return_inverse=True)
  737:         assert_array_equal(a2, unq)
  738:         assert_array_equal(a2_inv, inv)
  739: 
  740:         # test for chararrays with return_inverse (gh-5099)
  741:         a = np.char.chararray(5)
  742:         a[...] = ''
  743:         a2, a2_inv = np.unique(a, return_inverse=True)
  744:         assert_array_equal(a2_inv, np.zeros(5))
  745: 
  746:         # test for ticket #9137
  747:         a = []
  748:         a1_idx = np.unique(a, return_index=True)[1]
  749:         a2_inv = np.unique(a, return_inverse=True)[1]
  750:         a3_idx, a3_inv = np.unique(a, return_index=True,
  751:                                    return_inverse=True)[1:]
  752:         assert_equal(a1_idx.dtype, np.intp)
  753:         assert_equal(a2_inv.dtype, np.intp)
  754:         assert_equal(a3_idx.dtype, np.intp)
  755:         assert_equal(a3_inv.dtype, np.intp)
  756: 
  757:         # test for ticket 2111 - float
  758:         a = [2.0, np.nan, 1.0, np.nan]
  759:         ua = [1.0, 2.0, np.nan]
  760:         ua_idx = [2, 0, 1]
  761:         ua_inv = [1, 2, 0, 2]
  762:         ua_cnt = [1, 1, 2]
  763:         assert_equal(np.unique(a), ua)
  764:         assert_equal(np.unique(a, return_index=True), (ua, ua_idx))
  765:         assert_equal(np.unique(a, return_inverse=True), (ua, ua_inv))
  766:         assert_equal(np.unique(a, return_counts=True), (ua, ua_cnt))
  767: 
  768:         # test for ticket 2111 - complex
  769:         a = [2.0 - 1j, np.nan, 1.0 + 1j, complex(0.0, np.nan), complex(1.0, np.nan)]
  770:         ua = [1.0 + 1j, 2.0 - 1j, complex(0.0, np.nan)]
  771:         ua_idx = [2, 0, 3]
  772:         ua_inv = [1, 2, 0, 2, 2]
  773:         ua_cnt = [1, 1, 3]
  774:         assert_equal(np.unique(a), ua)
  775:         assert_equal(np.unique(a, return_index=True), (ua, ua_idx))
  776:         assert_equal(np.unique(a, return_inverse=True), (ua, ua_inv))
  777:         assert_equal(np.unique(a, return_counts=True), (ua, ua_cnt))
  778: 
  779:         # test for ticket 2111 - datetime64
  780:         nat = np.datetime64('nat')
  781:         a = [np.datetime64('2020-12-26'), nat, np.datetime64('2020-12-24'), nat]
  782:         ua = [np.datetime64('2020-12-24'), np.datetime64('2020-12-26'), nat]
  783:         ua_idx = [2, 0, 1]
  784:         ua_inv = [1, 2, 0, 2]
  785:         ua_cnt = [1, 1, 2]
  786:         assert_equal(np.unique(a), ua)
  787:         assert_equal(np.unique(a, return_index=True), (ua, ua_idx))
  788:         assert_equal(np.unique(a, return_inverse=True), (ua, ua_inv))
  789:         assert_equal(np.unique(a, return_counts=True), (ua, ua_cnt))
  790: 
  791:         # test for ticket 2111 - timedelta
  792:         nat = np.timedelta64('nat')
  793:         a = [np.timedelta64(1, 'D'), nat, np.timedelta64(1, 'h'), nat]
  794:         ua = [np.timedelta64(1, 'h'), np.timedelta64(1, 'D'), nat]
  795:         ua_idx = [2, 0, 1]
  796:         ua_inv = [1, 2, 0, 2]
  797:         ua_cnt = [1, 1, 2]
  798:         assert_equal(np.unique(a), ua)
  799:         assert_equal(np.unique(a, return_index=True), (ua, ua_idx))
  800:         assert_equal(np.unique(a, return_inverse=True), (ua, ua_inv))
  801:         assert_equal(np.unique(a, return_counts=True), (ua, ua_cnt))
  802: 
  803:         # test for gh-19300
  804:         all_nans = [np.nan] * 4
  805:         ua = [np.nan]
  806:         ua_idx = [0]
  807:         ua_inv = [0, 0, 0, 0]
  808:         ua_cnt = [4]
  809:         assert_equal(np.unique(all_nans), ua)
  810:         assert_equal(np.unique(all_nans, return_index=True), (ua, ua_idx))
  811:         assert_equal(np.unique(all_nans, return_inverse=True), (ua, ua_inv))
  812:         assert_equal(np.unique(all_nans, return_counts=True), (ua, ua_cnt))
  813: 
  814:     def test_unique_zero_sized(self):
  815:         # test for zero-sized arrays
  816:         for dt in self.get_types():
  817:             a = np.array([], dt)
  818:             b = np.array([], dt)
  819:             i1 = np.array([], np.int64)
  820:             i2 = np.array([], np.int64)
  821:             c = np.array([], np.int64)
  822:             self.check_all(a, b, i1, i2, c, dt)
  823: 
  824:     def test_unique_subclass(self):
  825:         class Subclass(np.ndarray):
  826:             pass
  827: 
  828:         i1 = [2, 3, 0, 1]
  829:         i2 = [2, 3, 0, 1, 0, 2, 3] * 10
  830:         c = np.multiply([2, 1, 2, 2], 10)
  831: 
  832:         # test for numeric arrays
  833:         types = self.get_types()
  834:         for dt in types:
  835:             a = np.array([5, 7, 1, 2, 1, 5, 7] * 10, dtype=dt)
  836:             b = np.array([1, 2, 5, 7], dtype=dt)
  837:             aa = Subclass(a.shape, dtype=dt, buffer=a)
  838:             bb = Subclass(b.shape, dtype=dt, buffer=b)
  839:             self.check_all(aa, bb, i1, i2, c, dt)
  840: 
  841:     @pytest.mark.parametrize("arg", ["return_index", "return_inverse", "return_counts"])
  842:     def test_unsupported_hash_based(self, arg):
  843:         """These currently never use the hash-based solution.  However,
  844:         it seems easier to just allow it.
  845: 
  846:         When the hash-based solution is added, this test should fail and be
  847:         replaced with something more comprehensive.
  848:         """
  849:         a = np.array([1, 5, 2, 3, 4, 8, 199, 1, 3, 5])
  850: 
  851:         res_not_sorted = np.unique([1, 1], sorted=False, **{arg: True})
  852:         res_sorted = np.unique([1, 1], sorted=True, **{arg: True})
  853:         # The following should fail without first sorting `res_not_sorted`.
  854:         for arr, expected in zip(res_not_sorted, res_sorted):
  855:             assert_array_equal(arr, expected)
  856: 
  857:     def test_unique_axis_errors(self):
  858:         assert_raises(TypeError, self._run_axis_tests, object)
  859:         assert_raises(TypeError, self._run_axis_tests,
  860:                       [('a', int), ('b', object)])
  861: 
  862:         assert_raises(AxisError, unique, np.arange(10), axis=2)
  863:         assert_raises(AxisError, unique, np.arange(10), axis=-2)
  864: 
  865:     def test_unique_axis_list(self):
  866:         msg = "Unique failed on list of lists"
  867:         inp = [[0, 1, 0], [0, 1, 0]]
  868:         inp_arr = np.asarray(inp)
  869:         assert_array_equal(unique(inp, axis=0), unique(inp_arr, axis=0), msg)
  870:         assert_array_equal(unique(inp, axis=1), unique(inp_arr, axis=1), msg)
  871: 
  872:     def test_unique_axis(self):
  873:         types = []
  874:         types.extend(np.typecodes['AllInteger'])
  875:         types.extend(np.typecodes['AllFloat'])
  876:         types.append('datetime64[D]')
  877:         types.append('timedelta64[D]')
  878:         types.append([('a', int), ('b', int)])
  879:         types.append([('a', int), ('b', float)])
  880: 
  881:         for dtype in types:
  882:             self._run_axis_tests(dtype)
  883: 
  884:         msg = 'Non-bitwise-equal booleans test failed'
  885:         data = np.arange(10, dtype=np.uint8).reshape(-1, 2).view(bool)
  886:         result = np.array([[False, True], [True, True]], dtype=bool)
  887:         assert_array_equal(unique(data, axis=0), result, msg)
  888: 
  889:         msg = 'Negative zero equality test failed'
  890:         data = np.array([[-0.0, 0.0], [0.0, -0.0], [-0.0, 0.0], [0.0, -0.0]])
  891:         result = np.array([[-0.0, 0.0]])
  892:         assert_array_equal(unique(data, axis=0), result, msg)
  893: 
  894:     @pytest.mark.parametrize("axis", [0, -1])
  895:     def test_unique_1d_with_axis(self, axis):
  896:         x = np.array([4, 3, 2, 3, 2, 1, 2, 2])
  897:         uniq = unique(x, axis=axis)
  898:         assert_array_equal(uniq, [1, 2, 3, 4])
  899: 
  900:     @pytest.mark.parametrize("axis", [None, 0, -1])
  901:     def test_unique_inverse_with_axis(self, axis):
  902:         x = np.array([[4, 4, 3], [2, 2, 1], [2, 2, 1], [4, 4, 3]])
  903:         uniq, inv = unique(x, return_inverse=True, axis=axis)
  904:         assert_equal(inv.ndim, x.ndim if axis is None else 1)
  905:         assert_array_equal(x, np.take(uniq, inv, axis=axis))
  906: 
  907:     def test_unique_axis_zeros(self):
  908:         # issue 15559
  909:         single_zero = np.empty(shape=(2, 0), dtype=np.int8)
  910:         uniq, idx, inv, cnt = unique(single_zero, axis=0, return_index=True,
  911:                                      return_inverse=True, return_counts=True)
  912: 
  913:         # there's 1 element of shape (0,) along axis 0
  914:         assert_equal(uniq.dtype, single_zero.dtype)
  915:         assert_array_equal(uniq, np.empty(shape=(1, 0)))
  916:         assert_array_equal(idx, np.array([0]))
  917:         assert_array_equal(inv, np.array([0, 0]))
  918:         assert_array_equal(cnt, np.array([2]))
  919: 
  920:         # there's 0 elements of shape (2,) along axis 1
  921:         uniq, idx, inv, cnt = unique(single_zero, axis=1, return_index=True,
  922:                                      return_inverse=True, return_counts=True)
  923: 
  924:         assert_equal(uniq.dtype, single_zero.dtype)
  925:         assert_array_equal(uniq, np.empty(shape=(2, 0)))
  926:         assert_array_equal(idx, np.array([]))
  927:         assert_array_equal(inv, np.array([]))
  928:         assert_array_equal(cnt, np.array([]))
  929: 
  930:         # test a "complicated" shape
  931:         shape = (0, 2, 0, 3, 0, 4, 0)
  932:         multiple_zeros = np.empty(shape=shape)
  933:         for axis in range(len(shape)):
  934:             expected_shape = list(shape)
  935:             if shape[axis] == 0:
  936:                 expected_shape[axis] = 0
  937:             else:
  938:                 expected_shape[axis] = 1
  939: 
  940:             assert_array_equal(unique(multiple_zeros, axis=axis),
  941:                                np.empty(shape=expected_shape))
  942: 
  943:     def test_unique_masked(self):
  944:         # issue 8664
  945:         x = np.array([64, 0, 1, 2, 3, 63, 63, 0, 0, 0, 1, 2, 0, 63, 0],
  946:                      dtype='uint8')
  947:         y = np.ma.masked_equal(x, 0)
  948: 
  949:         v = np.unique(y)
  950:         v2, i, c = np.unique(y, return_index=True, return_counts=True)
  951: 
  952:         msg = 'Unique returned different results when asked for index'
  953:         assert_array_equal(v.data, v2.data, msg)
  954:         assert_array_equal(v.mask, v2.mask, msg)
  955: 
  956:     def test_unique_sort_order_with_axis(self):
  957:         # These tests fail if sorting along axis is done by treating subarrays
  958:         # as unsigned byte strings.  See gh-10495.
  959:         fmt = "sort order incorrect for integer type '%s'"
  960:         for dt in 'bhilq':
  961:             a = np.array([[-1], [0]], dt)
  962:             b = np.unique(a, axis=0)
  963:             assert_array_equal(a, b, fmt % dt)
  964: 
  965:     def _run_axis_tests(self, dtype):
  966:         data = np.array([[0, 1, 0, 0],
  967:                          [1, 0, 0, 0],
  968:                          [0, 1, 0, 0],
  969:                          [1, 0, 0, 0]]).astype(dtype)
  970: 
  971:         msg = 'Unique with 1d array and axis=0 failed'
  972:         result = np.array([0, 1])
  973:         assert_array_equal(unique(data), result.astype(dtype), msg)
  974: 
  975:         msg = 'Unique with 2d array and axis=0 failed'
  976:         result = np.array([[0, 1, 0, 0], [1, 0, 0, 0]])
  977:         assert_array_equal(unique(data, axis=0), result.astype(dtype), msg)
  978: 
  979:         msg = 'Unique with 2d array and axis=1 failed'
  980:         result = np.array([[0, 0, 1], [0, 1, 0], [0, 0, 1], [0, 1, 0]])
  981:         assert_array_equal(unique(data, axis=1), result.astype(dtype), msg)
  982: 
  983:         msg = 'Unique with 3d array and axis=2 failed'
  984:         data3d = np.array([[[1, 1],
  985:                             [1, 0]],
  986:                            [[0, 1],
  987:                             [0, 0]]]).astype(dtype)
  988:         result = np.take(data3d, [1, 0], axis=2)
  989:         assert_array_equal(unique(data3d, axis=2), result, msg)
  990: 
  991:         uniq, idx, inv, cnt = unique(data, axis=0, return_index=True,
  992:                                      return_inverse=True, return_counts=True)
  993:         msg = "Unique's return_index=True failed with axis=0"
  994:         assert_array_equal(data[idx], uniq, msg)
  995:         msg = "Unique's return_inverse=True failed with axis=0"
  996:         assert_array_equal(np.take(uniq, inv, axis=0), data)
  997:         msg = "Unique's return_counts=True failed with axis=0"
  998:         assert_array_equal(cnt, np.array([2, 2]), msg)
  999: 
 1000:         uniq, idx, inv, cnt = unique(data, axis=1, return_index=True,
 1001:                                      return_inverse=True, return_counts=True)
 1002:         msg = "Unique's return_index=True failed with axis=1"
 1003:         assert_array_equal(data[:, idx], uniq)
 1004:         msg = "Unique's return_inverse=True failed with axis=1"
 1005:         assert_array_equal(np.take(uniq, inv, axis=1), data)
 1006:         msg = "Unique's return_counts=True failed with axis=1"
 1007:         assert_array_equal(cnt, np.array([2, 1, 1]), msg)
 1008: 
 1009:     def test_unique_nanequals(self):
 1010:         # issue 20326
 1011:         a = np.array([1, 1, np.nan, np.nan, np.nan])
 1012:         unq = np.unique(a)
 1013:         not_unq = np.unique(a, equal_nan=False)
 1014:         assert_array_equal(unq, np.array([1, np.nan]))
 1015:         assert_array_equal(not_unq, np.array([1, np.nan, np.nan, np.nan]))
 1016: 
 1017:     def test_unique_array_api_functions(self):
 1018:         arr = np.array([np.nan, 1, 4, 1, 3, 4, np.nan, 5, 1])
 1019: 
 1020:         for res_unique_array_api, res_unique in [
 1021:             (
 1022:                 np.unique_values(arr),
 1023:                 np.unique(arr, equal_nan=False)
 1024:             ),
 1025:             (
 1026:                 np.unique_counts(arr),
 1027:                 np.unique(arr, return_counts=True, equal_nan=False)
 1028:             ),
 1029:             (
 1030:                 np.unique_inverse(arr),
 1031:                 np.unique(arr, return_inverse=True, equal_nan=False)
 1032:             ),
 1033:             (
 1034:                 np.unique_all(arr),
 1035:                 np.unique(
 1036:                     arr,
 1037:                     return_index=True,
 1038:                     return_inverse=True,
 1039:                     return_counts=True,
 1040:                     equal_nan=False
 1041:                 )
 1042:             )
 1043:         ]:
 1044:             assert len(res_unique_array_api) == len(res_unique)
 1045:             for actual, expected in zip(res_unique_array_api, res_unique):
 1046:                 assert_array_equal(actual, expected)
 1047: 
 1048:     def test_unique_inverse_shape(self):
 1049:         # Regression test for https://github.com/numpy/numpy/issues/25552
 1050:         arr = np.array([[1, 2, 3], [2, 3, 1]])
 1051:         expected_values, expected_inverse = np.unique(arr, return_inverse=True)
 1052:         expected_inverse = expected_inverse.reshape(arr.shape)
 1053:         for func in np.unique_inverse, np.unique_all:
 1054:             result = func(arr)
 1055:             assert_array_equal(expected_values, result.values)
 1056:             assert_array_equal(expected_inverse, result.inverse_indices)
 1057:             assert_array_equal(arr, result.values[result.inverse_indices])
 1058: 
 1059:     @pytest.mark.parametrize(
 1060:         'data',
 1061:         [[[1, 1, 1],
 1062:           [1, 1, 1]],
 1063:          [1, 3, 2],
 1064:          1],
 1065:     )
 1066:     @pytest.mark.parametrize('transpose', [False, True])
 1067:     @pytest.mark.parametrize('dtype', [np.int32, np.float64])
 1068:     def test_unique_with_matrix(self, data, transpose, dtype):
 1069:         mat = np.matrix(data).astype(dtype)
 1070:         if transpose:
 1071:             mat = mat.T
 1072:         u = np.unique(mat)
 1073:         expected = np.unique(np.asarray(mat))
 1074:         assert_array_equal(u, expected, strict=True)
