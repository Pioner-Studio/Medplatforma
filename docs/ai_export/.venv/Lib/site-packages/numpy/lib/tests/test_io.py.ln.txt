    1: import gc
    2: import gzip
    3: import locale
    4: import os
    5: import re
    6: import sys
    7: import threading
    8: import time
    9: import warnings
   10: import zipfile
   11: from ctypes import c_bool
   12: from datetime import datetime
   13: from io import BytesIO, StringIO
   14: from multiprocessing import Value, get_context
   15: from pathlib import Path
   16: from tempfile import NamedTemporaryFile
   17: 
   18: import pytest
   19: 
   20: import numpy as np
   21: import numpy.ma as ma
   22: from numpy._utils import asbytes
   23: from numpy.exceptions import VisibleDeprecationWarning
   24: from numpy.lib import _npyio_impl
   25: from numpy.lib._iotools import ConversionWarning, ConverterError
   26: from numpy.lib._npyio_impl import recfromcsv, recfromtxt
   27: from numpy.ma.testutils import assert_equal
   28: from numpy.testing import (
   29:     HAS_REFCOUNT,
   30:     IS_PYPY,
   31:     IS_WASM,
   32:     assert_,
   33:     assert_allclose,
   34:     assert_array_equal,
   35:     assert_no_gc_cycles,
   36:     assert_no_warnings,
   37:     assert_raises,
   38:     assert_raises_regex,
   39:     assert_warns,
   40:     break_cycles,
   41:     suppress_warnings,
   42:     tempdir,
   43:     temppath,
   44: )
   45: from numpy.testing._private.utils import requires_memory
   46: 
   47: 
   48: class TextIO(BytesIO):
   49:     """Helper IO class.
   50: 
   51:     Writes encode strings to bytes if needed, reads return bytes.
   52:     This makes it easier to emulate files opened in binary mode
   53:     without needing to explicitly convert strings to bytes in
   54:     setting up the test data.
   55: 
   56:     """
   57:     def __init__(self, s=""):
   58:         BytesIO.__init__(self, asbytes(s))
   59: 
   60:     def write(self, s):
   61:         BytesIO.write(self, asbytes(s))
   62: 
   63:     def writelines(self, lines):
   64:         BytesIO.writelines(self, [asbytes(s) for s in lines])
   65: 
   66: 
   67: IS_64BIT = sys.maxsize > 2**32
   68: try:
   69:     import bz2
   70:     HAS_BZ2 = True
   71: except ImportError:
   72:     HAS_BZ2 = False
   73: try:
   74:     import lzma
   75:     HAS_LZMA = True
   76: except ImportError:
   77:     HAS_LZMA = False
   78: 
   79: 
   80: def strptime(s, fmt=None):
   81:     """
   82:     This function is available in the datetime module only from Python >=
   83:     2.5.
   84: 
   85:     """
   86:     if isinstance(s, bytes):
   87:         s = s.decode("latin1")
   88:     return datetime(*time.strptime(s, fmt)[:3])
   89: 
   90: 
   91: class RoundtripTest:
   92:     def roundtrip(self, save_func, *args, **kwargs):
   93:         """
   94:         save_func : callable
   95:             Function used to save arrays to file.
   96:         file_on_disk : bool
   97:             If true, store the file on disk, instead of in a
   98:             string buffer.
   99:         save_kwds : dict
  100:             Parameters passed to `save_func`.
  101:         load_kwds : dict
  102:             Parameters passed to `numpy.load`.
  103:         args : tuple of arrays
  104:             Arrays stored to file.
  105: 
  106:         """
  107:         save_kwds = kwargs.get('save_kwds', {})
  108:         load_kwds = kwargs.get('load_kwds', {"allow_pickle": True})
  109:         file_on_disk = kwargs.get('file_on_disk', False)
  110: 
  111:         if file_on_disk:
  112:             target_file = NamedTemporaryFile(delete=False)
  113:             load_file = target_file.name
  114:         else:
  115:             target_file = BytesIO()
  116:             load_file = target_file
  117: 
  118:         try:
  119:             arr = args
  120: 
  121:             save_func(target_file, *arr, **save_kwds)
  122:             target_file.flush()
  123:             target_file.seek(0)
  124: 
  125:             if sys.platform == 'win32' and not isinstance(target_file, BytesIO):
  126:                 target_file.close()
  127: 
  128:             arr_reloaded = np.load(load_file, **load_kwds)
  129: 
  130:             self.arr = arr
  131:             self.arr_reloaded = arr_reloaded
  132:         finally:
  133:             if not isinstance(target_file, BytesIO):
  134:                 target_file.close()
  135:                 # holds an open file descriptor so it can't be deleted on win
  136:                 if 'arr_reloaded' in locals():
  137:                     if not isinstance(arr_reloaded, np.lib.npyio.NpzFile):
  138:                         os.remove(target_file.name)
  139: 
  140:     def check_roundtrips(self, a):
  141:         self.roundtrip(a)
  142:         self.roundtrip(a, file_on_disk=True)
  143:         self.roundtrip(np.asfortranarray(a))
  144:         self.roundtrip(np.asfortranarray(a), file_on_disk=True)
  145:         if a.shape[0] > 1:
  146:             # neither C nor Fortran contiguous for 2D arrays or more
  147:             self.roundtrip(np.asfortranarray(a)[1:])
  148:             self.roundtrip(np.asfortranarray(a)[1:], file_on_disk=True)
  149: 
  150:     def test_array(self):
  151:         a = np.array([], float)
  152:         self.check_roundtrips(a)
  153: 
  154:         a = np.array([[1, 2], [3, 4]], float)
  155:         self.check_roundtrips(a)
  156: 
  157:         a = np.array([[1, 2], [3, 4]], int)
  158:         self.check_roundtrips(a)
  159: 
  160:         a = np.array([[1 + 5j, 2 + 6j], [3 + 7j, 4 + 8j]], dtype=np.csingle)
  161:         self.check_roundtrips(a)
  162: 
  163:         a = np.array([[1 + 5j, 2 + 6j], [3 + 7j, 4 + 8j]], dtype=np.cdouble)
  164:         self.check_roundtrips(a)
  165: 
  166:     def test_array_object(self):
  167:         a = np.array([], object)
  168:         self.check_roundtrips(a)
  169: 
  170:         a = np.array([[1, 2], [3, 4]], object)
  171:         self.check_roundtrips(a)
  172: 
  173:     def test_1D(self):
  174:         a = np.array([1, 2, 3, 4], int)
  175:         self.roundtrip(a)
  176: 
  177:     @pytest.mark.skipif(sys.platform == 'win32', reason="Fails on Win32")
  178:     def test_mmap(self):
  179:         a = np.array([[1, 2.5], [4, 7.3]])
  180:         self.roundtrip(a, file_on_disk=True, load_kwds={'mmap_mode': 'r'})
  181: 
  182:         a = np.asfortranarray([[1, 2.5], [4, 7.3]])
  183:         self.roundtrip(a, file_on_disk=True, load_kwds={'mmap_mode': 'r'})
  184: 
  185:     def test_record(self):
  186:         a = np.array([(1, 2), (3, 4)], dtype=[('x', 'i4'), ('y', 'i4')])
  187:         self.check_roundtrips(a)
  188: 
  189:     @pytest.mark.slow
  190:     def test_format_2_0(self):
  191:         dt = [(("%d" % i) * 100, float) for i in range(500)]
  192:         a = np.ones(1000, dtype=dt)
  193:         with warnings.catch_warnings(record=True):
  194:             warnings.filterwarnings('always', '', UserWarning)
  195:             self.check_roundtrips(a)
  196: 
  197: 
  198: class TestSaveLoad(RoundtripTest):
  199:     def roundtrip(self, *args, **kwargs):
  200:         RoundtripTest.roundtrip(self, np.save, *args, **kwargs)
  201:         assert_equal(self.arr[0], self.arr_reloaded)
  202:         assert_equal(self.arr[0].dtype, self.arr_reloaded.dtype)
  203:         assert_equal(self.arr[0].flags.fnc, self.arr_reloaded.flags.fnc)
  204: 
  205: 
  206: class TestSavezLoad(RoundtripTest):
  207:     def roundtrip(self, *args, **kwargs):
  208:         RoundtripTest.roundtrip(self, np.savez, *args, **kwargs)
  209:         try:
  210:             for n, arr in enumerate(self.arr):
  211:                 reloaded = self.arr_reloaded['arr_%d' % n]
  212:                 assert_equal(arr, reloaded)
  213:                 assert_equal(arr.dtype, reloaded.dtype)
  214:                 assert_equal(arr.flags.fnc, reloaded.flags.fnc)
  215:         finally:
  216:             # delete tempfile, must be done here on windows
  217:             if self.arr_reloaded.fid:
  218:                 self.arr_reloaded.fid.close()
  219:                 os.remove(self.arr_reloaded.fid.name)
  220: 
  221:     def test_load_non_npy(self):
  222:         """Test loading non-.npy files and name mapping in .npz."""
  223:         with temppath(prefix="numpy_test_npz_load_non_npy_", suffix=".npz") as tmp:
  224:             with zipfile.ZipFile(tmp, "w") as npz:
  225:                 with npz.open("test1.npy", "w") as out_file:
  226:                     np.save(out_file, np.arange(10))
  227:                 with npz.open("test2", "w") as out_file:
  228:                     np.save(out_file, np.arange(10))
  229:                 with npz.open("metadata", "w") as out_file:
  230:                     out_file.write(b"Name: Test")
  231:             with np.load(tmp) as npz:
  232:                 assert len(npz["test1"]) == 10
  233:                 assert len(npz["test1.npy"]) == 10
  234:                 assert len(npz["test2"]) == 10
  235:                 assert npz["metadata"] == b"Name: Test"
  236: 
  237:     @pytest.mark.skipif(IS_PYPY, reason="Hangs on PyPy")
  238:     @pytest.mark.skipif(not IS_64BIT, reason="Needs 64bit platform")
  239:     @pytest.mark.slow
  240:     def test_big_arrays(self):
  241:         L = (1 << 31) + 100000
  242:         a = np.empty(L, dtype=np.uint8)
  243:         with temppath(prefix="numpy_test_big_arrays_", suffix=".npz") as tmp:
  244:             np.savez(tmp, a=a)
  245:             del a
  246:             npfile = np.load(tmp)
  247:             a = npfile['a']  # Should succeed
  248:             npfile.close()
  249: 
  250:     def test_multiple_arrays(self):
  251:         a = np.array([[1, 2], [3, 4]], float)
  252:         b = np.array([[1 + 2j, 2 + 7j], [3 - 6j, 4 + 12j]], complex)
  253:         self.roundtrip(a, b)
  254: 
  255:     def test_named_arrays(self):
  256:         a = np.array([[1, 2], [3, 4]], float)
  257:         b = np.array([[1 + 2j, 2 + 7j], [3 - 6j, 4 + 12j]], complex)
  258:         c = BytesIO()
  259:         np.savez(c, file_a=a, file_b=b)
  260:         c.seek(0)
  261:         l = np.load(c)
  262:         assert_equal(a, l['file_a'])
  263:         assert_equal(b, l['file_b'])
  264: 
  265:     def test_tuple_getitem_raises(self):
  266:         # gh-23748
  267:         a = np.array([1, 2, 3])
  268:         f = BytesIO()
  269:         np.savez(f, a=a)
  270:         f.seek(0)
  271:         l = np.load(f)
  272:         with pytest.raises(KeyError, match="(1, 2)"):
  273:             l[1, 2]
  274: 
  275:     def test_BagObj(self):
  276:         a = np.array([[1, 2], [3, 4]], float)
  277:         b = np.array([[1 + 2j, 2 + 7j], [3 - 6j, 4 + 12j]], complex)
  278:         c = BytesIO()
  279:         np.savez(c, file_a=a, file_b=b)
  280:         c.seek(0)
  281:         l = np.load(c)
  282:         assert_equal(sorted(dir(l.f)), ['file_a', 'file_b'])
  283:         assert_equal(a, l.f.file_a)
  284:         assert_equal(b, l.f.file_b)
  285: 
  286:     @pytest.mark.skipif(IS_WASM, reason="Cannot start thread")
  287:     def test_savez_filename_clashes(self):
  288:         # Test that issue #852 is fixed
  289:         # and savez functions in multithreaded environment
  290: 
  291:         def writer(error_list):
  292:             with temppath(suffix='.npz') as tmp:
  293:                 arr = np.random.randn(500, 500)
  294:                 try:
  295:                     np.savez(tmp, arr=arr)
  296:                 except OSError as err:
  297:                     error_list.append(err)
  298: 
  299:         errors = []
  300:         threads = [threading.Thread(target=writer, args=(errors,))
  301:                    for j in range(3)]
  302:         for t in threads:
  303:             t.start()
  304:         for t in threads:
  305:             t.join()
  306: 
  307:         if errors:
  308:             raise AssertionError(errors)
  309: 
  310:     def test_not_closing_opened_fid(self):
  311:         # Test that issue #2178 is fixed:
  312:         # verify could seek on 'loaded' file
  313:         with temppath(suffix='.npz') as tmp:
  314:             with open(tmp, 'wb') as fp:
  315:                 np.savez(fp, data='LOVELY LOAD')
  316:             with open(tmp, 'rb', 10000) as fp:
  317:                 fp.seek(0)
  318:                 assert_(not fp.closed)
  319:                 np.load(fp)['data']
  320:                 # fp must not get closed by .load
  321:                 assert_(not fp.closed)
  322:                 fp.seek(0)
  323:                 assert_(not fp.closed)
  324: 
  325:     @pytest.mark.slow_pypy
  326:     def test_closing_fid(self):
  327:         # Test that issue #1517 (too many opened files) remains closed
  328:         # It might be a "weak" test since failed to get triggered on
  329:         # e.g. Debian sid of 2012 Jul 05 but was reported to
  330:         # trigger the failure on Ubuntu 10.04:
  331:         # http://projects.scipy.org/numpy/ticket/1517#comment:2
  332:         with temppath(suffix='.npz') as tmp:
  333:             np.savez(tmp, data='LOVELY LOAD')
  334:             # We need to check if the garbage collector can properly close
  335:             # numpy npz file returned by np.load when their reference count
  336:             # goes to zero.  Python running in debug mode raises a
  337:             # ResourceWarning when file closing is left to the garbage
  338:             # collector, so we catch the warnings.
  339:             with suppress_warnings() as sup:
  340:                 sup.filter(ResourceWarning)  # TODO: specify exact message
  341:                 for i in range(1, 1025):
  342:                     try:
  343:                         np.load(tmp)["data"]
  344:                     except Exception as e:
  345:                         msg = f"Failed to load data from a file: {e}"
  346:                         raise AssertionError(msg)
  347:                     finally:
  348:                         if IS_PYPY:
  349:                             gc.collect()
  350: 
  351:     def test_closing_zipfile_after_load(self):
  352:         # Check that zipfile owns file and can close it.  This needs to
  353:         # pass a file name to load for the test. On windows failure will
  354:         # cause a second error will be raised when the attempt to remove
  355:         # the open file is made.
  356:         prefix = 'numpy_test_closing_zipfile_after_load_'
  357:         with temppath(suffix='.npz', prefix=prefix) as tmp:
  358:             np.savez(tmp, lab='place holder')
  359:             data = np.load(tmp)
  360:             fp = data.zip.fp
  361:             data.close()
  362:             assert_(fp.closed)
  363: 
  364:     @pytest.mark.parametrize("count, expected_repr", [
  365:         (1, "NpzFile {fname!r} with keys: arr_0"),
  366:         (5, "NpzFile {fname!r} with keys: arr_0, arr_1, arr_2, arr_3, arr_4"),
  367:         # _MAX_REPR_ARRAY_COUNT is 5, so files with more than 5 keys are
  368:         # expected to end in '...'
  369:         (6, "NpzFile {fname!r} with keys: arr_0, arr_1, arr_2, arr_3, arr_4..."),
  370:     ])
  371:     def test_repr_lists_keys(self, count, expected_repr):
  372:         a = np.array([[1, 2], [3, 4]], float)
  373:         with temppath(suffix='.npz') as tmp:
  374:             np.savez(tmp, *[a] * count)
  375:             l = np.load(tmp)
  376:             assert repr(l) == expected_repr.format(fname=tmp)
  377:             l.close()
  378: 
  379: 
  380: class TestSaveTxt:
  381:     def test_array(self):
  382:         a = np.array([[1, 2], [3, 4]], float)
  383:         fmt = "%.18e"
  384:         c = BytesIO()
  385:         np.savetxt(c, a, fmt=fmt)
  386:         c.seek(0)
  387:         assert_equal(c.readlines(),
  388:                      [asbytes((fmt + ' ' + fmt + '\n') % (1, 2)),
  389:                       asbytes((fmt + ' ' + fmt + '\n') % (3, 4))])
  390: 
  391:         a = np.array([[1, 2], [3, 4]], int)
  392:         c = BytesIO()
  393:         np.savetxt(c, a, fmt='%d')
  394:         c.seek(0)
  395:         assert_equal(c.readlines(), [b'1 2\n', b'3 4\n'])
  396: 
  397:     def test_1D(self):
  398:         a = np.array([1, 2, 3, 4], int)
  399:         c = BytesIO()
  400:         np.savetxt(c, a, fmt='%d')
  401:         c.seek(0)
  402:         lines = c.readlines()
  403:         assert_equal(lines, [b'1\n', b'2\n', b'3\n', b'4\n'])
  404: 
  405:     def test_0D_3D(self):
  406:         c = BytesIO()
  407:         assert_raises(ValueError, np.savetxt, c, np.array(1))
  408:         assert_raises(ValueError, np.savetxt, c, np.array([[[1], [2]]]))
  409: 
  410:     def test_structured(self):
  411:         a = np.array([(1, 2), (3, 4)], dtype=[('x', 'i4'), ('y', 'i4')])
  412:         c = BytesIO()
  413:         np.savetxt(c, a, fmt='%d')
  414:         c.seek(0)
  415:         assert_equal(c.readlines(), [b'1 2\n', b'3 4\n'])
  416: 
  417:     def test_structured_padded(self):
  418:         # gh-13297
  419:         a = np.array([(1, 2, 3), (4, 5, 6)], dtype=[
  420:             ('foo', 'i4'), ('bar', 'i4'), ('baz', 'i4')
  421:         ])
  422:         c = BytesIO()
  423:         np.savetxt(c, a[['foo', 'baz']], fmt='%d')
  424:         c.seek(0)
  425:         assert_equal(c.readlines(), [b'1 3\n', b'4 6\n'])
  426: 
  427:     def test_multifield_view(self):
  428:         a = np.ones(1, dtype=[('x', 'i4'), ('y', 'i4'), ('z', 'f4')])
  429:         v = a[['x', 'z']]
  430:         with temppath(suffix='.npy') as path:
  431:             path = Path(path)
  432:             np.save(path, v)
  433:             data = np.load(path)
  434:             assert_array_equal(data, v)
  435: 
  436:     def test_delimiter(self):
  437:         a = np.array([[1., 2.], [3., 4.]])
  438:         c = BytesIO()
  439:         np.savetxt(c, a, delimiter=',', fmt='%d')
  440:         c.seek(0)
  441:         assert_equal(c.readlines(), [b'1,2\n', b'3,4\n'])
  442: 
  443:     def test_format(self):
  444:         a = np.array([(1, 2), (3, 4)])
  445:         c = BytesIO()
  446:         # Sequence of formats
  447:         np.savetxt(c, a, fmt=['%02d', '%3.1f'])
  448:         c.seek(0)
  449:         assert_equal(c.readlines(), [b'01 2.0\n', b'03 4.0\n'])
  450: 
  451:         # A single multiformat string
  452:         c = BytesIO()
  453:         np.savetxt(c, a, fmt='%02d : %3.1f')
  454:         c.seek(0)
  455:         lines = c.readlines()
  456:         assert_equal(lines, [b'01 : 2.0\n', b'03 : 4.0\n'])
  457: 
  458:         # Specify delimiter, should be overridden
  459:         c = BytesIO()
  460:         np.savetxt(c, a, fmt='%02d : %3.1f', delimiter=',')
  461:         c.seek(0)
  462:         lines = c.readlines()
  463:         assert_equal(lines, [b'01 : 2.0\n', b'03 : 4.0\n'])
  464: 
  465:         # Bad fmt, should raise a ValueError
  466:         c = BytesIO()
  467:         assert_raises(ValueError, np.savetxt, c, a, fmt=99)
  468: 
  469:     def test_header_footer(self):
  470:         # Test the functionality of the header and footer keyword argument.
  471: 
  472:         c = BytesIO()
  473:         a = np.array([(1, 2), (3, 4)], dtype=int)
  474:         test_header_footer = 'Test header / footer'
  475:         # Test the header keyword argument
  476:         np.savetxt(c, a, fmt='%1d', header=test_header_footer)
  477:         c.seek(0)
  478:         assert_equal(c.read(),
  479:                      asbytes('# ' + test_header_footer + '\n1 2\n3 4\n'))
  480:         # Test the footer keyword argument
  481:         c = BytesIO()
  482:         np.savetxt(c, a, fmt='%1d', footer=test_header_footer)
  483:         c.seek(0)
  484:         assert_equal(c.read(),
  485:                      asbytes('1 2\n3 4\n# ' + test_header_footer + '\n'))
  486:         # Test the commentstr keyword argument used on the header
  487:         c = BytesIO()
  488:         commentstr = '% '
  489:         np.savetxt(c, a, fmt='%1d',
  490:                    header=test_header_footer, comments=commentstr)
  491:         c.seek(0)
  492:         assert_equal(c.read(),
  493:                      asbytes(commentstr + test_header_footer + '\n' + '1 2\n3 4\n'))
  494:         # Test the commentstr keyword argument used on the footer
  495:         c = BytesIO()
  496:         commentstr = '% '
  497:         np.savetxt(c, a, fmt='%1d',
  498:                    footer=test_header_footer, comments=commentstr)
  499:         c.seek(0)
  500:         assert_equal(c.read(),
  501:                      asbytes('1 2\n3 4\n' + commentstr + test_header_footer + '\n'))
  502: 
  503:     @pytest.mark.parametrize("filename_type", [Path, str])
  504:     def test_file_roundtrip(self, filename_type):
  505:         with temppath() as name:
  506:             a = np.array([(1, 2), (3, 4)])
  507:             np.savetxt(filename_type(name), a)
  508:             b = np.loadtxt(filename_type(name))
  509:             assert_array_equal(a, b)
  510: 
  511:     def test_complex_arrays(self):
  512:         ncols = 2
  513:         nrows = 2
  514:         a = np.zeros((ncols, nrows), dtype=np.complex128)
  515:         re = np.pi
  516:         im = np.e
  517:         a[:] = re + 1.0j * im
  518: 
  519:         # One format only
  520:         c = BytesIO()
  521:         np.savetxt(c, a, fmt=' %+.3e')
  522:         c.seek(0)
  523:         lines = c.readlines()
  524:         assert_equal(
  525:             lines,
  526:             [b' ( +3.142e+00+ +2.718e+00j)  ( +3.142e+00+ +2.718e+00j)\n',
  527:              b' ( +3.142e+00+ +2.718e+00j)  ( +3.142e+00+ +2.718e+00j)\n'])
  528: 
  529:         # One format for each real and imaginary part
  530:         c = BytesIO()
  531:         np.savetxt(c, a, fmt='  %+.3e' * 2 * ncols)
  532:         c.seek(0)
  533:         lines = c.readlines()
  534:         assert_equal(
  535:             lines,
  536:             [b'  +3.142e+00  +2.718e+00  +3.142e+00  +2.718e+00\n',
  537:              b'  +3.142e+00  +2.718e+00  +3.142e+00  +2.718e+00\n'])
  538: 
  539:         # One format for each complex number
  540:         c = BytesIO()
  541:         np.savetxt(c, a, fmt=['(%.3e%+.3ej)'] * ncols)
  542:         c.seek(0)
  543:         lines = c.readlines()
  544:         assert_equal(
  545:             lines,
  546:             [b'(3.142e+00+2.718e+00j) (3.142e+00+2.718e+00j)\n',
  547:              b'(3.142e+00+2.718e+00j) (3.142e+00+2.718e+00j)\n'])
  548: 
  549:     def test_complex_negative_exponent(self):
  550:         # Previous to 1.15, some formats generated x+-yj, gh 7895
  551:         ncols = 2
  552:         nrows = 2
  553:         a = np.zeros((ncols, nrows), dtype=np.complex128)
  554:         re = np.pi
  555:         im = np.e
  556:         a[:] = re - 1.0j * im
  557:         c = BytesIO()
  558:         np.savetxt(c, a, fmt='%.3e')
  559:         c.seek(0)
  560:         lines = c.readlines()
  561:         assert_equal(
  562:             lines,
  563:             [b' (3.142e+00-2.718e+00j)  (3.142e+00-2.718e+00j)\n',
  564:              b' (3.142e+00-2.718e+00j)  (3.142e+00-2.718e+00j)\n'])
  565: 
  566:     def test_custom_writer(self):
  567: 
  568:         class CustomWriter(list):
  569:             def write(self, text):
  570:                 self.extend(text.split(b'\n'))
  571: 
  572:         w = CustomWriter()
  573:         a = np.array([(1, 2), (3, 4)])
  574:         np.savetxt(w, a)
  575:         b = np.loadtxt(w)
  576:         assert_array_equal(a, b)
  577: 
  578:     def test_unicode(self):
  579:         utf8 = b'\xcf\x96'.decode('UTF-8')
  580:         a = np.array([utf8], dtype=np.str_)
  581:         with tempdir() as tmpdir:
  582:             # set encoding as on windows it may not be unicode even on py3
  583:             np.savetxt(os.path.join(tmpdir, 'test.csv'), a, fmt=['%s'],
  584:                        encoding='UTF-8')
  585: 
  586:     def test_unicode_roundtrip(self):
  587:         utf8 = b'\xcf\x96'.decode('UTF-8')
  588:         a = np.array([utf8], dtype=np.str_)
  589:         # our gz wrapper support encoding
  590:         suffixes = ['', '.gz']
  591:         if HAS_BZ2:
  592:             suffixes.append('.bz2')
  593:         if HAS_LZMA:
  594:             suffixes.extend(['.xz', '.lzma'])
  595:         with tempdir() as tmpdir:
  596:             for suffix in suffixes:
  597:                 np.savetxt(os.path.join(tmpdir, 'test.csv' + suffix), a,
  598:                            fmt=['%s'], encoding='UTF-16-LE')
  599:                 b = np.loadtxt(os.path.join(tmpdir, 'test.csv' + suffix),
  600:                                encoding='UTF-16-LE', dtype=np.str_)
  601:                 assert_array_equal(a, b)
  602: 
  603:     def test_unicode_bytestream(self):
  604:         utf8 = b'\xcf\x96'.decode('UTF-8')
  605:         a = np.array([utf8], dtype=np.str_)
  606:         s = BytesIO()
  607:         np.savetxt(s, a, fmt=['%s'], encoding='UTF-8')
  608:         s.seek(0)
  609:         assert_equal(s.read().decode('UTF-8'), utf8 + '\n')
  610: 
  611:     def test_unicode_stringstream(self):
  612:         utf8 = b'\xcf\x96'.decode('UTF-8')
  613:         a = np.array([utf8], dtype=np.str_)
  614:         s = StringIO()
  615:         np.savetxt(s, a, fmt=['%s'], encoding='UTF-8')
  616:         s.seek(0)
  617:         assert_equal(s.read(), utf8 + '\n')
  618: 
  619:     @pytest.mark.parametrize("iotype", [StringIO, BytesIO])
  620:     def test_unicode_and_bytes_fmt(self, iotype):
  621:         # string type of fmt should not matter, see also gh-4053
  622:         a = np.array([1.])
  623:         s = iotype()
  624:         np.savetxt(s, a, fmt="%f")
  625:         s.seek(0)
  626:         if iotype is StringIO:
  627:             assert_equal(s.read(), "%f\n" % 1.)
  628:         else:
  629:             assert_equal(s.read(), b"%f\n" % 1.)
  630: 
  631:     @pytest.mark.skipif(sys.platform == 'win32', reason="files>4GB may not work")
  632:     @pytest.mark.slow
  633:     @requires_memory(free_bytes=7e9)
  634:     def test_large_zip(self):
  635:         def check_large_zip(memoryerror_raised):
  636:             memoryerror_raised.value = False
  637:             try:
  638:                 # The test takes at least 6GB of memory, writes a file larger
  639:                 # than 4GB. This tests the ``allowZip64`` kwarg to ``zipfile``
  640:                 test_data = np.asarray([np.random.rand(
  641:                                         np.random.randint(50, 100), 4)
  642:                                         for i in range(800000)], dtype=object)
  643:                 with tempdir() as tmpdir:
  644:                     np.savez(os.path.join(tmpdir, 'test.npz'),
  645:                              test_data=test_data)
  646:             except MemoryError:
  647:                 memoryerror_raised.value = True
  648:                 raise
  649:         # run in a subprocess to ensure memory is released on PyPy, see gh-15775
  650:         # Use an object in shared memory to re-raise the MemoryError exception
  651:         # in our process if needed, see gh-16889
  652:         memoryerror_raised = Value(c_bool)
  653: 
  654:         # Since Python 3.8, the default start method for multiprocessing has
  655:         # been changed from 'fork' to 'spawn' on macOS, causing inconsistency
  656:         # on memory sharing model, leading to failed test for check_large_zip
  657:         ctx = get_context('fork')
  658:         p = ctx.Process(target=check_large_zip, args=(memoryerror_raised,))
  659:         p.start()
  660:         p.join()
  661:         if memoryerror_raised.value:
  662:             raise MemoryError("Child process raised a MemoryError exception")
  663:         # -9 indicates a SIGKILL, probably an OOM.
  664:         if p.exitcode == -9:
  665:             pytest.xfail("subprocess got a SIGKILL, apparently free memory was not sufficient")
  666:         assert p.exitcode == 0
  667: 
  668: class LoadTxtBase:
  669:     def check_compressed(self, fopen, suffixes):
  670:         # Test that we can load data from a compressed file
  671:         wanted = np.arange(6).reshape((2, 3))
  672:         linesep = ('\n', '\r\n', '\r')
  673:         for sep in linesep:
  674:             data = '0 1 2' + sep + '3 4 5'
  675:             for suffix in suffixes:
  676:                 with temppath(suffix=suffix) as name:
  677:                     with fopen(name, mode='wt', encoding='UTF-32-LE') as f:
  678:                         f.write(data)
  679:                     res = self.loadfunc(name, encoding='UTF-32-LE')
  680:                     assert_array_equal(res, wanted)
  681:                     with fopen(name, "rt",  encoding='UTF-32-LE') as f:
  682:                         res = self.loadfunc(f)
  683:                     assert_array_equal(res, wanted)
  684: 
  685:     def test_compressed_gzip(self):
  686:         self.check_compressed(gzip.open, ('.gz',))
  687: 
  688:     @pytest.mark.skipif(not HAS_BZ2, reason="Needs bz2")
  689:     def test_compressed_bz2(self):
  690:         self.check_compressed(bz2.open, ('.bz2',))
  691: 
  692:     @pytest.mark.skipif(not HAS_LZMA, reason="Needs lzma")
  693:     def test_compressed_lzma(self):
  694:         self.check_compressed(lzma.open, ('.xz', '.lzma'))
  695: 
  696:     def test_encoding(self):
  697:         with temppath() as path:
  698:             with open(path, "wb") as f:
  699:                 f.write('0.\n1.\n2.'.encode("UTF-16"))
  700:             x = self.loadfunc(path, encoding="UTF-16")
  701:             assert_array_equal(x, [0., 1., 2.])
  702: 
  703:     def test_stringload(self):
  704:         # umlaute
  705:         nonascii = b'\xc3\xb6\xc3\xbc\xc3\xb6'.decode("UTF-8")
  706:         with temppath() as path:
  707:             with open(path, "wb") as f:
  708:                 f.write(nonascii.encode("UTF-16"))
  709:             x = self.loadfunc(path, encoding="UTF-16", dtype=np.str_)
  710:             assert_array_equal(x, nonascii)
  711: 
  712:     def test_binary_decode(self):
  713:         utf16 = b'\xff\xfeh\x04 \x00i\x04 \x00j\x04'
  714:         v = self.loadfunc(BytesIO(utf16), dtype=np.str_, encoding='UTF-16')
  715:         assert_array_equal(v, np.array(utf16.decode('UTF-16').split()))
  716: 
  717:     def test_converters_decode(self):
  718:         # test converters that decode strings
  719:         c = TextIO()
  720:         c.write(b'\xcf\x96')
  721:         c.seek(0)
  722:         x = self.loadfunc(c, dtype=np.str_, encoding="bytes",
  723:                           converters={0: lambda x: x.decode('UTF-8')})
  724:         a = np.array([b'\xcf\x96'.decode('UTF-8')])
  725:         assert_array_equal(x, a)
  726: 
  727:     def test_converters_nodecode(self):
  728:         # test native string converters enabled by setting an encoding
  729:         utf8 = b'\xcf\x96'.decode('UTF-8')
  730:         with temppath() as path:
  731:             with open(path, 'wt', encoding='UTF-8') as f:
  732:                 f.write(utf8)
  733:             x = self.loadfunc(path, dtype=np.str_,
  734:                               converters={0: lambda x: x + 't'},
  735:                               encoding='UTF-8')
  736:             a = np.array([utf8 + 't'])
  737:             assert_array_equal(x, a)
  738: 
  739: 
  740: class TestLoadTxt(LoadTxtBase):
  741:     loadfunc = staticmethod(np.loadtxt)
  742: 
  743:     def setup_method(self):
  744:         # lower chunksize for testing
  745:         self.orig_chunk = _npyio_impl._loadtxt_chunksize
  746:         _npyio_impl._loadtxt_chunksize = 1
  747: 
  748:     def teardown_method(self):
  749:         _npyio_impl._loadtxt_chunksize = self.orig_chunk
  750: 
  751:     def test_record(self):
  752:         c = TextIO()
  753:         c.write('1 2\n3 4')
  754:         c.seek(0)
  755:         x = np.loadtxt(c, dtype=[('x', np.int32), ('y', np.int32)])
  756:         a = np.array([(1, 2), (3, 4)], dtype=[('x', 'i4'), ('y', 'i4')])
  757:         assert_array_equal(x, a)
  758: 
  759:         d = TextIO()
  760:         d.write('M 64 75.0\nF 25 60.0')
  761:         d.seek(0)
  762:         mydescriptor = {'names': ('gender', 'age', 'weight'),
  763:                         'formats': ('S1', 'i4', 'f4')}
  764:         b = np.array([('M', 64.0, 75.0),
  765:                       ('F', 25.0, 60.0)], dtype=mydescriptor)
  766:         y = np.loadtxt(d, dtype=mydescriptor)
  767:         assert_array_equal(y, b)
  768: 
  769:     def test_array(self):
  770:         c = TextIO()
  771:         c.write('1 2\n3 4')
  772: 
  773:         c.seek(0)
  774:         x = np.loadtxt(c, dtype=int)
  775:         a = np.array([[1, 2], [3, 4]], int)
  776:         assert_array_equal(x, a)
  777: 
  778:         c.seek(0)
  779:         x = np.loadtxt(c, dtype=float)
  780:         a = np.array([[1, 2], [3, 4]], float)
  781:         assert_array_equal(x, a)
  782: 
  783:     def test_1D(self):
  784:         c = TextIO()
  785:         c.write('1\n2\n3\n4\n')
  786:         c.seek(0)
  787:         x = np.loadtxt(c, dtype=int)
  788:         a = np.array([1, 2, 3, 4], int)
  789:         assert_array_equal(x, a)
  790: 
  791:         c = TextIO()
  792:         c.write('1,2,3,4\n')
  793:         c.seek(0)
  794:         x = np.loadtxt(c, dtype=int, delimiter=',')
  795:         a = np.array([1, 2, 3, 4], int)
  796:         assert_array_equal(x, a)
  797: 
  798:     def test_missing(self):
  799:         c = TextIO()
  800:         c.write('1,2,3,,5\n')
  801:         c.seek(0)
  802:         x = np.loadtxt(c, dtype=int, delimiter=',',
  803:                        converters={3: lambda s: int(s or - 999)})
  804:         a = np.array([1, 2, 3, -999, 5], int)
  805:         assert_array_equal(x, a)
  806: 
  807:     def test_converters_with_usecols(self):
  808:         c = TextIO()
  809:         c.write('1,2,3,,5\n6,7,8,9,10\n')
  810:         c.seek(0)
  811:         x = np.loadtxt(c, dtype=int, delimiter=',',
  812:                        converters={3: lambda s: int(s or - 999)},
  813:                        usecols=(1, 3,))
  814:         a = np.array([[2, -999], [7, 9]], int)
  815:         assert_array_equal(x, a)
  816: 
  817:     def test_comments_unicode(self):
  818:         c = TextIO()
  819:         c.write('# comment\n1,2,3,5\n')
  820:         c.seek(0)
  821:         x = np.loadtxt(c, dtype=int, delimiter=',',
  822:                        comments='#')
  823:         a = np.array([1, 2, 3, 5], int)
  824:         assert_array_equal(x, a)
  825: 
  826:     def test_comments_byte(self):
  827:         c = TextIO()
  828:         c.write('# comment\n1,2,3,5\n')
  829:         c.seek(0)
  830:         x = np.loadtxt(c, dtype=int, delimiter=',',
  831:                        comments=b'#')
  832:         a = np.array([1, 2, 3, 5], int)
  833:         assert_array_equal(x, a)
  834: 
  835:     def test_comments_multiple(self):
  836:         c = TextIO()
  837:         c.write('# comment\n1,2,3\n@ comment2\n4,5,6 // comment3')
  838:         c.seek(0)
  839:         x = np.loadtxt(c, dtype=int, delimiter=',',
  840:                        comments=['#', '@', '//'])
  841:         a = np.array([[1, 2, 3], [4, 5, 6]], int)
  842:         assert_array_equal(x, a)
  843: 
  844:     @pytest.mark.skipif(IS_PYPY and sys.implementation.version <= (7, 3, 8),
  845:                         reason="PyPy bug in error formatting")
  846:     def test_comments_multi_chars(self):
  847:         c = TextIO()
  848:         c.write('/* comment\n1,2,3,5\n')
  849:         c.seek(0)
  850:         x = np.loadtxt(c, dtype=int, delimiter=',',
  851:                        comments='/*')
  852:         a = np.array([1, 2, 3, 5], int)
  853:         assert_array_equal(x, a)
  854: 
  855:         # Check that '/*' is not transformed to ['/', '*']
  856:         c = TextIO()
  857:         c.write('*/ comment\n1,2,3,5\n')
  858:         c.seek(0)
  859:         assert_raises(ValueError, np.loadtxt, c, dtype=int, delimiter=',',
  860:                       comments='/*')
  861: 
  862:     def test_skiprows(self):
  863:         c = TextIO()
  864:         c.write('comment\n1,2,3,5\n')
  865:         c.seek(0)
  866:         x = np.loadtxt(c, dtype=int, delimiter=',',
  867:                        skiprows=1)
  868:         a = np.array([1, 2, 3, 5], int)
  869:         assert_array_equal(x, a)
  870: 
  871:         c = TextIO()
  872:         c.write('# comment\n1,2,3,5\n')
  873:         c.seek(0)
  874:         x = np.loadtxt(c, dtype=int, delimiter=',',
  875:                        skiprows=1)
  876:         a = np.array([1, 2, 3, 5], int)
  877:         assert_array_equal(x, a)
  878: 
  879:     def test_usecols(self):
  880:         a = np.array([[1, 2], [3, 4]], float)
  881:         c = BytesIO()
  882:         np.savetxt(c, a)
  883:         c.seek(0)
  884:         x = np.loadtxt(c, dtype=float, usecols=(1,))
  885:         assert_array_equal(x, a[:, 1])
  886: 
  887:         a = np.array([[1, 2, 3], [3, 4, 5]], float)
  888:         c = BytesIO()
  889:         np.savetxt(c, a)
  890:         c.seek(0)
  891:         x = np.loadtxt(c, dtype=float, usecols=(1, 2))
  892:         assert_array_equal(x, a[:, 1:])
  893: 
  894:         # Testing with arrays instead of tuples.
  895:         c.seek(0)
  896:         x = np.loadtxt(c, dtype=float, usecols=np.array([1, 2]))
  897:         assert_array_equal(x, a[:, 1:])
  898: 
  899:         # Testing with an integer instead of a sequence
  900:         for int_type in [int, np.int8, np.int16,
  901:                          np.int32, np.int64, np.uint8, np.uint16,
  902:                          np.uint32, np.uint64]:
  903:             to_read = int_type(1)
  904:             c.seek(0)
  905:             x = np.loadtxt(c, dtype=float, usecols=to_read)
  906:             assert_array_equal(x, a[:, 1])
  907: 
  908:         # Testing with some crazy custom integer type
  909:         class CrazyInt:
  910:             def __index__(self):
  911:                 return 1
  912: 
  913:         crazy_int = CrazyInt()
  914:         c.seek(0)
  915:         x = np.loadtxt(c, dtype=float, usecols=crazy_int)
  916:         assert_array_equal(x, a[:, 1])
  917: 
  918:         c.seek(0)
  919:         x = np.loadtxt(c, dtype=float, usecols=(crazy_int,))
  920:         assert_array_equal(x, a[:, 1])
  921: 
  922:         # Checking with dtypes defined converters.
  923:         data = '''JOE 70.1 25.3
  924:                 BOB 60.5 27.9
  925:                 '''
  926:         c = TextIO(data)
  927:         names = ['stid', 'temp']
  928:         dtypes = ['S4', 'f8']
  929:         arr = np.loadtxt(c, usecols=(0, 2), dtype=list(zip(names, dtypes)))
  930:         assert_equal(arr['stid'], [b"JOE", b"BOB"])
  931:         assert_equal(arr['temp'], [25.3, 27.9])
  932: 
  933:         # Testing non-ints in usecols
  934:         c.seek(0)
  935:         bogus_idx = 1.5
  936:         assert_raises_regex(
  937:             TypeError,
  938:             f'^usecols must be.*{type(bogus_idx).__name__}',
  939:             np.loadtxt, c, usecols=bogus_idx
  940:             )
  941: 
  942:         assert_raises_regex(
  943:             TypeError,
  944:             f'^usecols must be.*{type(bogus_idx).__name__}',
  945:             np.loadtxt, c, usecols=[0, bogus_idx, 0]
  946:             )
  947: 
  948:     def test_bad_usecols(self):
  949:         with pytest.raises(OverflowError):
  950:             np.loadtxt(["1\n"], usecols=[2**64], delimiter=",")
  951:         with pytest.raises((ValueError, OverflowError)):
  952:             # Overflow error on 32bit platforms
  953:             np.loadtxt(["1\n"], usecols=[2**62], delimiter=",")
  954:         with pytest.raises(TypeError,
  955:                 match="If a structured dtype .*. But 1 usecols were given and "
  956:                       "the number of fields is 3."):
  957:             np.loadtxt(["1,1\n"], dtype="i,2i", usecols=[0], delimiter=",")
  958: 
  959:     def test_fancy_dtype(self):
  960:         c = TextIO()
  961:         c.write('1,2,3.0\n4,5,6.0\n')
  962:         c.seek(0)
  963:         dt = np.dtype([('x', int), ('y', [('t', int), ('s', float)])])
  964:         x = np.loadtxt(c, dtype=dt, delimiter=',')
  965:         a = np.array([(1, (2, 3.0)), (4, (5, 6.0))], dt)
  966:         assert_array_equal(x, a)
  967: 
  968:     def test_shaped_dtype(self):
  969:         c = TextIO("aaaa  1.0  8.0  1 2 3 4 5 6")
  970:         dt = np.dtype([('name', 'S4'), ('x', float), ('y', float),
  971:                        ('block', int, (2, 3))])
  972:         x = np.loadtxt(c, dtype=dt)
  973:         a = np.array([('aaaa', 1.0, 8.0, [[1, 2, 3], [4, 5, 6]])],
  974:                      dtype=dt)
  975:         assert_array_equal(x, a)
  976: 
  977:     def test_3d_shaped_dtype(self):
  978:         c = TextIO("aaaa  1.0  8.0  1 2 3 4 5 6 7 8 9 10 11 12")
  979:         dt = np.dtype([('name', 'S4'), ('x', float), ('y', float),
  980:                        ('block', int, (2, 2, 3))])
  981:         x = np.loadtxt(c, dtype=dt)
  982:         a = np.array([('aaaa', 1.0, 8.0,
  983:                        [[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])],
  984:                      dtype=dt)
  985:         assert_array_equal(x, a)
  986: 
  987:     def test_str_dtype(self):
  988:         # see gh-8033
  989:         c = ["str1", "str2"]
  990: 
  991:         for dt in (str, np.bytes_):
  992:             a = np.array(["str1", "str2"], dtype=dt)
  993:             x = np.loadtxt(c, dtype=dt)
  994:             assert_array_equal(x, a)
  995: 
  996:     def test_empty_file(self):
  997:         with pytest.warns(UserWarning, match="input contained no data"):
  998:             c = TextIO()
  999:             x = np.loadtxt(c)
 1000:             assert_equal(x.shape, (0,))
 1001:             x = np.loadtxt(c, dtype=np.int64)
 1002:             assert_equal(x.shape, (0,))
 1003:             assert_(x.dtype == np.int64)
 1004: 
 1005:     def test_unused_converter(self):
 1006:         c = TextIO()
 1007:         c.writelines(['1 21\n', '3 42\n'])
 1008:         c.seek(0)
 1009:         data = np.loadtxt(c, usecols=(1,),
 1010:                           converters={0: lambda s: int(s, 16)})
 1011:         assert_array_equal(data, [21, 42])
 1012: 
 1013:         c.seek(0)
 1014:         data = np.loadtxt(c, usecols=(1,),
 1015:                           converters={1: lambda s: int(s, 16)})
 1016:         assert_array_equal(data, [33, 66])
 1017: 
 1018:     def test_dtype_with_object(self):
 1019:         # Test using an explicit dtype with an object
 1020:         data = """ 1; 2001-01-01
 1021:                    2; 2002-01-31 """
 1022:         ndtype = [('idx', int), ('code', object)]
 1023:         func = lambda s: strptime(s.strip(), "%Y-%m-%d")
 1024:         converters = {1: func}
 1025:         test = np.loadtxt(TextIO(data), delimiter=";", dtype=ndtype,
 1026:                           converters=converters)
 1027:         control = np.array(
 1028:             [(1, datetime(2001, 1, 1)), (2, datetime(2002, 1, 31))],
 1029:             dtype=ndtype)
 1030:         assert_equal(test, control)
 1031: 
 1032:     def test_uint64_type(self):
 1033:         tgt = (9223372043271415339, 9223372043271415853)
 1034:         c = TextIO()
 1035:         c.write("%s %s" % tgt)
 1036:         c.seek(0)
 1037:         res = np.loadtxt(c, dtype=np.uint64)
 1038:         assert_equal(res, tgt)
 1039: 
 1040:     def test_int64_type(self):
 1041:         tgt = (-9223372036854775807, 9223372036854775807)
 1042:         c = TextIO()
 1043:         c.write("%s %s" % tgt)
 1044:         c.seek(0)
 1045:         res = np.loadtxt(c, dtype=np.int64)
 1046:         assert_equal(res, tgt)
 1047: 
 1048:     def test_from_float_hex(self):
 1049:         # IEEE doubles and floats only, otherwise the float32
 1050:         # conversion may fail.
 1051:         tgt = np.logspace(-10, 10, 5).astype(np.float32)
 1052:         tgt = np.hstack((tgt, -tgt)).astype(float)
 1053:         inp = '\n'.join(map(float.hex, tgt))
 1054:         c = TextIO()
 1055:         c.write(inp)
 1056:         for dt in [float, np.float32]:
 1057:             c.seek(0)
 1058:             res = np.loadtxt(
 1059:                 c, dtype=dt, converters=float.fromhex, encoding="latin1")
 1060:             assert_equal(res, tgt, err_msg=f"{dt}")
 1061: 
 1062:     @pytest.mark.skipif(IS_PYPY and sys.implementation.version <= (7, 3, 8),
 1063:                         reason="PyPy bug in error formatting")
 1064:     def test_default_float_converter_no_default_hex_conversion(self):
 1065:         """
 1066:         Ensure that fromhex is only used for values with the correct prefix and
 1067:         is not called by default. Regression test related to gh-19598.
 1068:         """
 1069:         c = TextIO("a b c")
 1070:         with pytest.raises(ValueError,
 1071:                 match=".*convert string 'a' to float64 at row 0, column 1"):
 1072:             np.loadtxt(c)
 1073: 
 1074:     @pytest.mark.skipif(IS_PYPY and sys.implementation.version <= (7, 3, 8),
 1075:                         reason="PyPy bug in error formatting")
 1076:     def test_default_float_converter_exception(self):
 1077:         """
 1078:         Ensure that the exception message raised during failed floating point
 1079:         conversion is correct. Regression test related to gh-19598.
 1080:         """
 1081:         c = TextIO("qrs tuv")  # Invalid values for default float converter
 1082:         with pytest.raises(ValueError,
 1083:                 match="could not convert string 'qrs' to float64"):
 1084:             np.loadtxt(c)
 1085: 
 1086:     def test_from_complex(self):
 1087:         tgt = (complex(1, 1), complex(1, -1))
 1088:         c = TextIO()
 1089:         c.write("%s %s" % tgt)
 1090:         c.seek(0)
 1091:         res = np.loadtxt(c, dtype=complex)
 1092:         assert_equal(res, tgt)
 1093: 
 1094:     def test_complex_misformatted(self):
 1095:         # test for backward compatibility
 1096:         # some complex formats used to generate x+-yj
 1097:         a = np.zeros((2, 2), dtype=np.complex128)
 1098:         re = np.pi
 1099:         im = np.e
 1100:         a[:] = re - 1.0j * im
 1101:         c = BytesIO()
 1102:         np.savetxt(c, a, fmt='%.16e')
 1103:         c.seek(0)
 1104:         txt = c.read()
 1105:         c.seek(0)
 1106:         # misformat the sign on the imaginary part, gh 7895
 1107:         txt_bad = txt.replace(b'e+00-', b'e00+-')
 1108:         assert_(txt_bad != txt)
 1109:         c.write(txt_bad)
 1110:         c.seek(0)
 1111:         res = np.loadtxt(c, dtype=complex)
 1112:         assert_equal(res, a)
 1113: 
 1114:     def test_universal_newline(self):
 1115:         with temppath() as name:
 1116:             with open(name, 'w') as f:
 1117:                 f.write('1 21\r3 42\r')
 1118:             data = np.loadtxt(name)
 1119:         assert_array_equal(data, [[1, 21], [3, 42]])
 1120: 
 1121:     def test_empty_field_after_tab(self):
 1122:         c = TextIO()
 1123:         c.write('1 \t2 \t3\tstart \n4\t5\t6\t  \n7\t8\t9.5\t')
 1124:         c.seek(0)
 1125:         dt = {'names': ('x', 'y', 'z', 'comment'),
 1126:               'formats': ('<i4', '<i4', '<f4', '|S8')}
 1127:         x = np.loadtxt(c, dtype=dt, delimiter='\t')
 1128:         a = np.array([b'start ', b'  ', b''])
 1129:         assert_array_equal(x['comment'], a)
 1130: 
 1131:     def test_unpack_structured(self):
 1132:         txt = TextIO("M 21 72\nF 35 58")
 1133:         dt = {'names': ('a', 'b', 'c'), 'formats': ('|S1', '<i4', '<f4')}
 1134:         a, b, c = np.loadtxt(txt, dtype=dt, unpack=True)
 1135:         assert_(a.dtype.str == '|S1')
 1136:         assert_(b.dtype.str == '<i4')
 1137:         assert_(c.dtype.str == '<f4')
 1138:         assert_array_equal(a, np.array([b'M', b'F']))
 1139:         assert_array_equal(b, np.array([21, 35]))
 1140:         assert_array_equal(c, np.array([72.,  58.]))
 1141: 
 1142:     def test_ndmin_keyword(self):
 1143:         c = TextIO()
 1144:         c.write('1,2,3\n4,5,6')
 1145:         c.seek(0)
 1146:         assert_raises(ValueError, np.loadtxt, c, ndmin=3)
 1147:         c.seek(0)
 1148:         assert_raises(ValueError, np.loadtxt, c, ndmin=1.5)
 1149:         c.seek(0)
 1150:         x = np.loadtxt(c, dtype=int, delimiter=',', ndmin=1)
 1151:         a = np.array([[1, 2, 3], [4, 5, 6]])
 1152:         assert_array_equal(x, a)
 1153: 
 1154:         d = TextIO()
 1155:         d.write('0,1,2')
 1156:         d.seek(0)
 1157:         x = np.loadtxt(d, dtype=int, delimiter=',', ndmin=2)
 1158:         assert_(x.shape == (1, 3))
 1159:         d.seek(0)
 1160:         x = np.loadtxt(d, dtype=int, delimiter=',', ndmin=1)
 1161:         assert_(x.shape == (3,))
 1162:         d.seek(0)
 1163:         x = np.loadtxt(d, dtype=int, delimiter=',', ndmin=0)
 1164:         assert_(x.shape == (3,))
 1165: 
 1166:         e = TextIO()
 1167:         e.write('0\n1\n2')
 1168:         e.seek(0)
 1169:         x = np.loadtxt(e, dtype=int, delimiter=',', ndmin=2)
 1170:         assert_(x.shape == (3, 1))
 1171:         e.seek(0)
 1172:         x = np.loadtxt(e, dtype=int, delimiter=',', ndmin=1)
 1173:         assert_(x.shape == (3,))
 1174:         e.seek(0)
 1175:         x = np.loadtxt(e, dtype=int, delimiter=',', ndmin=0)
 1176:         assert_(x.shape == (3,))
 1177: 
 1178:         # Test ndmin kw with empty file.
 1179:         with pytest.warns(UserWarning, match="input contained no data"):
 1180:             f = TextIO()
 1181:             assert_(np.loadtxt(f, ndmin=2).shape == (0, 1,))
 1182:             assert_(np.loadtxt(f, ndmin=1).shape == (0,))
 1183: 
 1184:     def test_generator_source(self):
 1185:         def count():
 1186:             for i in range(10):
 1187:                 yield "%d" % i
 1188: 
 1189:         res = np.loadtxt(count())
 1190:         assert_array_equal(res, np.arange(10))
 1191: 
 1192:     def test_bad_line(self):
 1193:         c = TextIO()
 1194:         c.write('1 2 3\n4 5 6\n2 3')
 1195:         c.seek(0)
 1196: 
 1197:         # Check for exception and that exception contains line number
 1198:         assert_raises_regex(ValueError, "3", np.loadtxt, c)
 1199: 
 1200:     def test_none_as_string(self):
 1201:         # gh-5155, None should work as string when format demands it
 1202:         c = TextIO()
 1203:         c.write('100,foo,200\n300,None,400')
 1204:         c.seek(0)
 1205:         dt = np.dtype([('x', int), ('a', 'S10'), ('y', int)])
 1206:         np.loadtxt(c, delimiter=',', dtype=dt, comments=None)  # Should succeed
 1207: 
 1208:     @pytest.mark.skipif(locale.getpreferredencoding() == 'ANSI_X3.4-1968',
 1209:                         reason="Wrong preferred encoding")
 1210:     def test_binary_load(self):
 1211:         butf8 = b"5,6,7,\xc3\x95scarscar\r\n15,2,3,hello\r\n"\
 1212:                 b"20,2,3,\xc3\x95scar\r\n"
 1213:         sutf8 = butf8.decode("UTF-8").replace("\r", "").splitlines()
 1214:         with temppath() as path:
 1215:             with open(path, "wb") as f:
 1216:                 f.write(butf8)
 1217:             with open(path, "rb") as f:
 1218:                 x = np.loadtxt(f, encoding="UTF-8", dtype=np.str_)
 1219:             assert_array_equal(x, sutf8)
 1220:             # test broken latin1 conversion people now rely on
 1221:             with open(path, "rb") as f:
 1222:                 x = np.loadtxt(f, encoding="UTF-8", dtype="S")
 1223:             x = [b'5,6,7,\xc3\x95scarscar', b'15,2,3,hello', b'20,2,3,\xc3\x95scar']
 1224:             assert_array_equal(x, np.array(x, dtype="S"))
 1225: 
 1226:     def test_max_rows(self):
 1227:         c = TextIO()
 1228:         c.write('1,2,3,5\n4,5,7,8\n2,1,4,5')
 1229:         c.seek(0)
 1230:         x = np.loadtxt(c, dtype=int, delimiter=',',
 1231:                        max_rows=1)
 1232:         a = np.array([1, 2, 3, 5], int)
 1233:         assert_array_equal(x, a)
 1234: 
 1235:     def test_max_rows_with_skiprows(self):
 1236:         c = TextIO()
 1237:         c.write('comments\n1,2,3,5\n4,5,7,8\n2,1,4,5')
 1238:         c.seek(0)
 1239:         x = np.loadtxt(c, dtype=int, delimiter=',',
 1240:                        skiprows=1, max_rows=1)
 1241:         a = np.array([1, 2, 3, 5], int)
 1242:         assert_array_equal(x, a)
 1243: 
 1244:         c = TextIO()
 1245:         c.write('comment\n1,2,3,5\n4,5,7,8\n2,1,4,5')
 1246:         c.seek(0)
 1247:         x = np.loadtxt(c, dtype=int, delimiter=',',
 1248:                        skiprows=1, max_rows=2)
 1249:         a = np.array([[1, 2, 3, 5], [4, 5, 7, 8]], int)
 1250:         assert_array_equal(x, a)
 1251: 
 1252:     def test_max_rows_with_read_continuation(self):
 1253:         c = TextIO()
 1254:         c.write('1,2,3,5\n4,5,7,8\n2,1,4,5')
 1255:         c.seek(0)
 1256:         x = np.loadtxt(c, dtype=int, delimiter=',',
 1257:                        max_rows=2)
 1258:         a = np.array([[1, 2, 3, 5], [4, 5, 7, 8]], int)
 1259:         assert_array_equal(x, a)
 1260:         # test continuation
 1261:         x = np.loadtxt(c, dtype=int, delimiter=',')
 1262:         a = np.array([2, 1, 4, 5], int)
 1263:         assert_array_equal(x, a)
 1264: 
 1265:     def test_max_rows_larger(self):
 1266:         #test max_rows > num rows
 1267:         c = TextIO()
 1268:         c.write('comment\n1,2,3,5\n4,5,7,8\n2,1,4,5')
 1269:         c.seek(0)
 1270:         x = np.loadtxt(c, dtype=int, delimiter=',',
 1271:                        skiprows=1, max_rows=6)
 1272:         a = np.array([[1, 2, 3, 5], [4, 5, 7, 8], [2, 1, 4, 5]], int)
 1273:         assert_array_equal(x, a)
 1274: 
 1275:     @pytest.mark.parametrize(["skip", "data"], [
 1276:             (1, ["ignored\n", "1,2\n", "\n", "3,4\n"]),
 1277:             # "Bad" lines that do not end in newlines:
 1278:             (1, ["ignored", "1,2", "", "3,4"]),
 1279:             (1, StringIO("ignored\n1,2\n\n3,4")),
 1280:             # Same as above, but do not skip any lines:
 1281:             (0, ["-1,0\n", "1,2\n", "\n", "3,4\n"]),
 1282:             (0, ["-1,0", "1,2", "", "3,4"]),
 1283:             (0, StringIO("-1,0\n1,2\n\n3,4"))])
 1284:     def test_max_rows_empty_lines(self, skip, data):
 1285:         with pytest.warns(UserWarning,
 1286:                     match=f"Input line 3.*max_rows={3 - skip}"):
 1287:             res = np.loadtxt(data, dtype=int, skiprows=skip, delimiter=",",
 1288:                              max_rows=3 - skip)
 1289:             assert_array_equal(res, [[-1, 0], [1, 2], [3, 4]][skip:])
 1290: 
 1291:         if isinstance(data, StringIO):
 1292:             data.seek(0)
 1293: 
 1294:         with warnings.catch_warnings():
 1295:             warnings.simplefilter("error", UserWarning)
 1296:             with pytest.raises(UserWarning):
 1297:                 np.loadtxt(data, dtype=int, skiprows=skip, delimiter=",",
 1298:                            max_rows=3 - skip)
 1299: 
 1300: class Testfromregex:
 1301:     def test_record(self):
 1302:         c = TextIO()
 1303:         c.write('1.312 foo\n1.534 bar\n4.444 qux')
 1304:         c.seek(0)
 1305: 
 1306:         dt = [('num', np.float64), ('val', 'S3')]
 1307:         x = np.fromregex(c, r"([0-9.]+)\s+(...)", dt)
 1308:         a = np.array([(1.312, 'foo'), (1.534, 'bar'), (4.444, 'qux')],
 1309:                      dtype=dt)
 1310:         assert_array_equal(x, a)
 1311: 
 1312:     def test_record_2(self):
 1313:         c = TextIO()
 1314:         c.write('1312 foo\n1534 bar\n4444 qux')
 1315:         c.seek(0)
 1316: 
 1317:         dt = [('num', np.int32), ('val', 'S3')]
 1318:         x = np.fromregex(c, r"(\d+)\s+(...)", dt)
 1319:         a = np.array([(1312, 'foo'), (1534, 'bar'), (4444, 'qux')],
 1320:                      dtype=dt)
 1321:         assert_array_equal(x, a)
 1322: 
 1323:     def test_record_3(self):
 1324:         c = TextIO()
 1325:         c.write('1312 foo\n1534 bar\n4444 qux')
 1326:         c.seek(0)
 1327: 
 1328:         dt = [('num', np.float64)]
 1329:         x = np.fromregex(c, r"(\d+)\s+...", dt)
 1330:         a = np.array([(1312,), (1534,), (4444,)], dtype=dt)
 1331:         assert_array_equal(x, a)
 1332: 
 1333:     @pytest.mark.parametrize("path_type", [str, Path])
 1334:     def test_record_unicode(self, path_type):
 1335:         utf8 = b'\xcf\x96'
 1336:         with temppath() as str_path:
 1337:             path = path_type(str_path)
 1338:             with open(path, 'wb') as f:
 1339:                 f.write(b'1.312 foo' + utf8 + b' \n1.534 bar\n4.444 qux')
 1340: 
 1341:             dt = [('num', np.float64), ('val', 'U4')]
 1342:             x = np.fromregex(path, r"(?u)([0-9.]+)\s+(\w+)", dt, encoding='UTF-8')
 1343:             a = np.array([(1.312, 'foo' + utf8.decode('UTF-8')), (1.534, 'bar'),
 1344:                            (4.444, 'qux')], dtype=dt)
 1345:             assert_array_equal(x, a)
 1346: 
 1347:             regexp = re.compile(r"([0-9.]+)\s+(\w+)", re.UNICODE)
 1348:             x = np.fromregex(path, regexp, dt, encoding='UTF-8')
 1349:             assert_array_equal(x, a)
 1350: 
 1351:     def test_compiled_bytes(self):
 1352:         regexp = re.compile(br'(\d)')
 1353:         c = BytesIO(b'123')
 1354:         dt = [('num', np.float64)]
 1355:         a = np.array([1, 2, 3], dtype=dt)
 1356:         x = np.fromregex(c, regexp, dt)
 1357:         assert_array_equal(x, a)
 1358: 
 1359:     def test_bad_dtype_not_structured(self):
 1360:         regexp = re.compile(br'(\d)')
 1361:         c = BytesIO(b'123')
 1362:         with pytest.raises(TypeError, match='structured datatype'):
 1363:             np.fromregex(c, regexp, dtype=np.float64)
 1364: 
 1365: 
 1366: #####--------------------------------------------------------------------------
 1367: 
 1368: 
 1369: class TestFromTxt(LoadTxtBase):
 1370:     loadfunc = staticmethod(np.genfromtxt)
 1371: 
 1372:     def test_record(self):
 1373:         # Test w/ explicit dtype
 1374:         data = TextIO('1 2\n3 4')
 1375:         test = np.genfromtxt(data, dtype=[('x', np.int32), ('y', np.int32)])
 1376:         control = np.array([(1, 2), (3, 4)], dtype=[('x', 'i4'), ('y', 'i4')])
 1377:         assert_equal(test, control)
 1378:         #
 1379:         data = TextIO('M 64.0 75.0\nF 25.0 60.0')
 1380:         descriptor = {'names': ('gender', 'age', 'weight'),
 1381:                       'formats': ('S1', 'i4', 'f4')}
 1382:         control = np.array([('M', 64.0, 75.0), ('F', 25.0, 60.0)],
 1383:                            dtype=descriptor)
 1384:         test = np.genfromtxt(data, dtype=descriptor)
 1385:         assert_equal(test, control)
 1386: 
 1387:     def test_array(self):
 1388:         # Test outputting a standard ndarray
 1389:         data = TextIO('1 2\n3 4')
 1390:         control = np.array([[1, 2], [3, 4]], dtype=int)
 1391:         test = np.genfromtxt(data, dtype=int)
 1392:         assert_array_equal(test, control)
 1393:         #
 1394:         data.seek(0)
 1395:         control = np.array([[1, 2], [3, 4]], dtype=float)
 1396:         test = np.loadtxt(data, dtype=float)
 1397:         assert_array_equal(test, control)
 1398: 
 1399:     def test_1D(self):
 1400:         # Test squeezing to 1D
 1401:         control = np.array([1, 2, 3, 4], int)
 1402:         #
 1403:         data = TextIO('1\n2\n3\n4\n')
 1404:         test = np.genfromtxt(data, dtype=int)
 1405:         assert_array_equal(test, control)
 1406:         #
 1407:         data = TextIO('1,2,3,4\n')
 1408:         test = np.genfromtxt(data, dtype=int, delimiter=',')
 1409:         assert_array_equal(test, control)
 1410: 
 1411:     def test_comments(self):
 1412:         # Test the stripping of comments
 1413:         control = np.array([1, 2, 3, 5], int)
 1414:         # Comment on its own line
 1415:         data = TextIO('# comment\n1,2,3,5\n')
 1416:         test = np.genfromtxt(data, dtype=int, delimiter=',', comments='#')
 1417:         assert_equal(test, control)
 1418:         # Comment at the end of a line
 1419:         data = TextIO('1,2,3,5# comment\n')
 1420:         test = np.genfromtxt(data, dtype=int, delimiter=',', comments='#')
 1421:         assert_equal(test, control)
 1422: 
 1423:     def test_skiprows(self):
 1424:         # Test row skipping
 1425:         control = np.array([1, 2, 3, 5], int)
 1426:         kwargs = {"dtype": int, "delimiter": ','}
 1427:         #
 1428:         data = TextIO('comment\n1,2,3,5\n')
 1429:         test = np.genfromtxt(data, skip_header=1, **kwargs)
 1430:         assert_equal(test, control)
 1431:         #
 1432:         data = TextIO('# comment\n1,2,3,5\n')
 1433:         test = np.loadtxt(data, skiprows=1, **kwargs)
 1434:         assert_equal(test, control)
 1435: 
 1436:     def test_skip_footer(self):
 1437:         data = [f"# {i}" for i in range(1, 6)]
 1438:         data.append("A, B, C")
 1439:         data.extend([f"{i},{i:3.1f},{i:03d}" for i in range(51)])
 1440:         data[-1] = "99,99"
 1441:         kwargs = {"delimiter": ",", "names": True, "skip_header": 5, "skip_footer": 10}
 1442:         test = np.genfromtxt(TextIO("\n".join(data)), **kwargs)
 1443:         ctrl = np.array([(f"{i:f}", f"{i:f}", f"{i:f}") for i in range(41)],
 1444:                         dtype=[(_, float) for _ in "ABC"])
 1445:         assert_equal(test, ctrl)
 1446: 
 1447:     def test_skip_footer_with_invalid(self):
 1448:         with suppress_warnings() as sup:
 1449:             sup.filter(ConversionWarning)
 1450:             basestr = '1 1\n2 2\n3 3\n4 4\n5  \n6  \n7  \n'
 1451:             # Footer too small to get rid of all invalid values
 1452:             assert_raises(ValueError, np.genfromtxt,
 1453:                           TextIO(basestr), skip_footer=1)
 1454:     #        except ValueError:
 1455:     #            pass
 1456:             a = np.genfromtxt(
 1457:                 TextIO(basestr), skip_footer=1, invalid_raise=False)
 1458:             assert_equal(a, np.array([[1., 1.], [2., 2.], [3., 3.], [4., 4.]]))
 1459:             #
 1460:             a = np.genfromtxt(TextIO(basestr), skip_footer=3)
 1461:             assert_equal(a, np.array([[1., 1.], [2., 2.], [3., 3.], [4., 4.]]))
 1462:             #
 1463:             basestr = '1 1\n2  \n3 3\n4 4\n5  \n6 6\n7 7\n'
 1464:             a = np.genfromtxt(
 1465:                 TextIO(basestr), skip_footer=1, invalid_raise=False)
 1466:             assert_equal(a, np.array([[1., 1.], [3., 3.], [4., 4.], [6., 6.]]))
 1467:             a = np.genfromtxt(
 1468:                 TextIO(basestr), skip_footer=3, invalid_raise=False)
 1469:             assert_equal(a, np.array([[1., 1.], [3., 3.], [4., 4.]]))
 1470: 
 1471:     def test_header(self):
 1472:         # Test retrieving a header
 1473:         data = TextIO('gender age weight\nM 64.0 75.0\nF 25.0 60.0')
 1474:         with warnings.catch_warnings(record=True) as w:
 1475:             warnings.filterwarnings('always', '', VisibleDeprecationWarning)
 1476:             test = np.genfromtxt(data, dtype=None, names=True,
 1477:                                  encoding='bytes')
 1478:             assert_(w[0].category is VisibleDeprecationWarning)
 1479:         control = {'gender': np.array([b'M', b'F']),
 1480:                    'age': np.array([64.0, 25.0]),
 1481:                    'weight': np.array([75.0, 60.0])}
 1482:         assert_equal(test['gender'], control['gender'])
 1483:         assert_equal(test['age'], control['age'])
 1484:         assert_equal(test['weight'], control['weight'])
 1485: 
 1486:     def test_auto_dtype(self):
 1487:         # Test the automatic definition of the output dtype
 1488:         data = TextIO('A 64 75.0 3+4j True\nBCD 25 60.0 5+6j False')
 1489:         with warnings.catch_warnings(record=True) as w:
 1490:             warnings.filterwarnings('always', '', VisibleDeprecationWarning)
 1491:             test = np.genfromtxt(data, dtype=None, encoding='bytes')
 1492:             assert_(w[0].category is VisibleDeprecationWarning)
 1493:         control = [np.array([b'A', b'BCD']),
 1494:                    np.array([64, 25]),
 1495:                    np.array([75.0, 60.0]),
 1496:                    np.array([3 + 4j, 5 + 6j]),
 1497:                    np.array([True, False]), ]
 1498:         assert_equal(test.dtype.names, ['f0', 'f1', 'f2', 'f3', 'f4'])
 1499:         for (i, ctrl) in enumerate(control):
 1500:             assert_equal(test[f'f{i}'], ctrl)
 1501: 
 1502:     def test_auto_dtype_uniform(self):
 1503:         # Tests whether the output dtype can be uniformized
 1504:         data = TextIO('1 2 3 4\n5 6 7 8\n')
 1505:         test = np.genfromtxt(data, dtype=None)
 1506:         control = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])
 1507:         assert_equal(test, control)
 1508: 
 1509:     def test_fancy_dtype(self):
 1510:         # Check that a nested dtype isn't MIA
 1511:         data = TextIO('1,2,3.0\n4,5,6.0\n')
 1512:         fancydtype = np.dtype([('x', int), ('y', [('t', int), ('s', float)])])
 1513:         test = np.genfromtxt(data, dtype=fancydtype, delimiter=',')
 1514:         control = np.array([(1, (2, 3.0)), (4, (5, 6.0))], dtype=fancydtype)
 1515:         assert_equal(test, control)
 1516: 
 1517:     def test_names_overwrite(self):
 1518:         # Test overwriting the names of the dtype
 1519:         descriptor = {'names': ('g', 'a', 'w'),
 1520:                       'formats': ('S1', 'i4', 'f4')}
 1521:         data = TextIO(b'M 64.0 75.0\nF 25.0 60.0')
 1522:         names = ('gender', 'age', 'weight')
 1523:         test = np.genfromtxt(data, dtype=descriptor, names=names)
 1524:         descriptor['names'] = names
 1525:         control = np.array([('M', 64.0, 75.0),
 1526:                             ('F', 25.0, 60.0)], dtype=descriptor)
 1527:         assert_equal(test, control)
 1528: 
 1529:     def test_bad_fname(self):
 1530:         with pytest.raises(TypeError, match='fname must be a string,'):
 1531:             np.genfromtxt(123)
 1532: 
 1533:     def test_commented_header(self):
 1534:         # Check that names can be retrieved even if the line is commented out.
 1535:         data = TextIO("""
 1536: #gender age weight
 1537: M   21  72.100000
 1538: F   35  58.330000
 1539: M   33  21.99
 1540:         """)
 1541:         # The # is part of the first name and should be deleted automatically.
 1542:         with warnings.catch_warnings(record=True) as w:
 1543:             warnings.filterwarnings('always', '', VisibleDeprecationWarning)
 1544:             test = np.genfromtxt(data, names=True, dtype=None,
 1545:                                  encoding="bytes")
 1546:             assert_(w[0].category is VisibleDeprecationWarning)
 1547:         ctrl = np.array([('M', 21, 72.1), ('F', 35, 58.33), ('M', 33, 21.99)],
 1548:                         dtype=[('gender', '|S1'), ('age', int), ('weight', float)])
 1549:         assert_equal(test, ctrl)
 1550:         # Ditto, but we should get rid of the first element
 1551:         data = TextIO(b"""
 1552: # gender age weight
 1553: M   21  72.100000
 1554: F   35  58.330000
 1555: M   33  21.99
 1556:         """)
 1557:         with warnings.catch_warnings(record=True) as w:
 1558:             warnings.filterwarnings('always', '', VisibleDeprecationWarning)
 1559:             test = np.genfromtxt(data, names=True, dtype=None,
 1560:                                  encoding="bytes")
 1561:             assert_(w[0].category is VisibleDeprecationWarning)
 1562:         assert_equal(test, ctrl)
 1563: 
 1564:     def test_names_and_comments_none(self):
 1565:         # Tests case when names is true but comments is None (gh-10780)
 1566:         data = TextIO('col1 col2\n 1 2\n 3 4')
 1567:         test = np.genfromtxt(data, dtype=(int, int), comments=None, names=True)
 1568:         control = np.array([(1, 2), (3, 4)], dtype=[('col1', int), ('col2', int)])
 1569:         assert_equal(test, control)
 1570: 
 1571:     def test_file_is_closed_on_error(self):
 1572:         # gh-13200
 1573:         with tempdir() as tmpdir:
 1574:             fpath = os.path.join(tmpdir, "test.csv")
 1575:             with open(fpath, "wb") as f:
 1576:                 f.write('\N{GREEK PI SYMBOL}'.encode())
 1577: 
 1578:             # ResourceWarnings are emitted from a destructor, so won't be
 1579:             # detected by regular propagation to errors.
 1580:             with assert_no_warnings():
 1581:                 with pytest.raises(UnicodeDecodeError):
 1582:                     np.genfromtxt(fpath, encoding="ascii")
 1583: 
 1584:     def test_autonames_and_usecols(self):
 1585:         # Tests names and usecols
 1586:         data = TextIO('A B C D\n aaaa 121 45 9.1')
 1587:         with warnings.catch_warnings(record=True) as w:
 1588:             warnings.filterwarnings('always', '', VisibleDeprecationWarning)
 1589:             test = np.genfromtxt(data, usecols=('A', 'C', 'D'),
 1590:                                 names=True, dtype=None, encoding="bytes")
 1591:             assert_(w[0].category is VisibleDeprecationWarning)
 1592:         control = np.array(('aaaa', 45, 9.1),
 1593:                            dtype=[('A', '|S4'), ('C', int), ('D', float)])
 1594:         assert_equal(test, control)
 1595: 
 1596:     def test_converters_with_usecols(self):
 1597:         # Test the combination user-defined converters and usecol
 1598:         data = TextIO('1,2,3,,5\n6,7,8,9,10\n')
 1599:         test = np.genfromtxt(data, dtype=int, delimiter=',',
 1600:                             converters={3: lambda s: int(s or - 999)},
 1601:                             usecols=(1, 3,))
 1602:         control = np.array([[2, -999], [7, 9]], int)
 1603:         assert_equal(test, control)
 1604: 
 1605:     def test_converters_with_usecols_and_names(self):
 1606:         # Tests names and usecols
 1607:         data = TextIO('A B C D\n aaaa 121 45 9.1')
 1608:         with warnings.catch_warnings(record=True) as w:
 1609:             warnings.filterwarnings('always', '', VisibleDeprecationWarning)
 1610:             test = np.genfromtxt(data, usecols=('A', 'C', 'D'), names=True,
 1611:                                 dtype=None, encoding="bytes",
 1612:                                 converters={'C': lambda s: 2 * int(s)})
 1613:             assert_(w[0].category is VisibleDeprecationWarning)
 1614:         control = np.array(('aaaa', 90, 9.1),
 1615:                            dtype=[('A', '|S4'), ('C', int), ('D', float)])
 1616:         assert_equal(test, control)
 1617: 
 1618:     def test_converters_cornercases(self):
 1619:         # Test the conversion to datetime.
 1620:         converter = {
 1621:             'date': lambda s: strptime(s, '%Y-%m-%d %H:%M:%SZ')}
 1622:         data = TextIO('2009-02-03 12:00:00Z, 72214.0')
 1623:         test = np.genfromtxt(data, delimiter=',', dtype=None,
 1624:                             names=['date', 'stid'], converters=converter)
 1625:         control = np.array((datetime(2009, 2, 3), 72214.),
 1626:                            dtype=[('date', np.object_), ('stid', float)])
 1627:         assert_equal(test, control)
 1628: 
 1629:     def test_converters_cornercases2(self):
 1630:         # Test the conversion to datetime64.
 1631:         converter = {
 1632:             'date': lambda s: np.datetime64(strptime(s, '%Y-%m-%d %H:%M:%SZ'))}
 1633:         data = TextIO('2009-02-03 12:00:00Z, 72214.0')
 1634:         test = np.genfromtxt(data, delimiter=',', dtype=None,
 1635:                             names=['date', 'stid'], converters=converter)
 1636:         control = np.array((datetime(2009, 2, 3), 72214.),
 1637:                            dtype=[('date', 'datetime64[us]'), ('stid', float)])
 1638:         assert_equal(test, control)
 1639: 
 1640:     def test_unused_converter(self):
 1641:         # Test whether unused converters are forgotten
 1642:         data = TextIO("1 21\n  3 42\n")
 1643:         test = np.genfromtxt(data, usecols=(1,),
 1644:                             converters={0: lambda s: int(s, 16)})
 1645:         assert_equal(test, [21, 42])
 1646:         #
 1647:         data.seek(0)
 1648:         test = np.genfromtxt(data, usecols=(1,),
 1649:                             converters={1: lambda s: int(s, 16)})
 1650:         assert_equal(test, [33, 66])
 1651: 
 1652:     def test_invalid_converter(self):
 1653:         strip_rand = lambda x: float((b'r' in x.lower() and x.split()[-1]) or
 1654:                                      ((b'r' not in x.lower() and x.strip()) or 0.0))
 1655:         strip_per = lambda x: float((b'%' in x.lower() and x.split()[0]) or
 1656:                                     ((b'%' not in x.lower() and x.strip()) or 0.0))
 1657:         s = TextIO("D01N01,10/1/2003 ,1 %,R 75,400,600\r\n"
 1658:                    "L24U05,12/5/2003, 2 %,1,300, 150.5\r\n"
 1659:                    "D02N03,10/10/2004,R 1,,7,145.55")
 1660:         kwargs = {
 1661:             "converters": {2: strip_per, 3: strip_rand}, "delimiter": ",",
 1662:             "dtype": None, "encoding": "bytes"}
 1663:         assert_raises(ConverterError, np.genfromtxt, s, **kwargs)
 1664: 
 1665:     def test_tricky_converter_bug1666(self):
 1666:         # Test some corner cases
 1667:         s = TextIO('q1,2\nq3,4')
 1668:         cnv = lambda s: float(s[1:])
 1669:         test = np.genfromtxt(s, delimiter=',', converters={0: cnv})
 1670:         control = np.array([[1., 2.], [3., 4.]])
 1671:         assert_equal(test, control)
 1672: 
 1673:     def test_dtype_with_converters(self):
 1674:         dstr = "2009; 23; 46"
 1675:         test = np.genfromtxt(TextIO(dstr,),
 1676:                             delimiter=";", dtype=float, converters={0: bytes})
 1677:         control = np.array([('2009', 23., 46)],
 1678:                            dtype=[('f0', '|S4'), ('f1', float), ('f2', float)])
 1679:         assert_equal(test, control)
 1680:         test = np.genfromtxt(TextIO(dstr,),
 1681:                             delimiter=";", dtype=float, converters={0: float})
 1682:         control = np.array([2009., 23., 46],)
 1683:         assert_equal(test, control)
 1684: 
 1685:     @pytest.mark.filterwarnings("ignore:.*recfromcsv.*:DeprecationWarning")
 1686:     def test_dtype_with_converters_and_usecols(self):
 1687:         dstr = "1,5,-1,1:1\n2,8,-1,1:n\n3,3,-2,m:n\n"
 1688:         dmap = {'1:1': 0, '1:n': 1, 'm:1': 2, 'm:n': 3}
 1689:         dtyp = [('e1', 'i4'), ('e2', 'i4'), ('e3', 'i2'), ('n', 'i1')]
 1690:         conv = {0: int, 1: int, 2: int, 3: lambda r: dmap[r.decode()]}
 1691:         test = recfromcsv(TextIO(dstr,), dtype=dtyp, delimiter=',',
 1692:                           names=None, converters=conv, encoding="bytes")
 1693:         control = np.rec.array([(1, 5, -1, 0), (2, 8, -1, 1), (3, 3, -2, 3)], dtype=dtyp)
 1694:         assert_equal(test, control)
 1695:         dtyp = [('e1', 'i4'), ('e2', 'i4'), ('n', 'i1')]
 1696:         test = recfromcsv(TextIO(dstr,), dtype=dtyp, delimiter=',',
 1697:                           usecols=(0, 1, 3), names=None, converters=conv,
 1698:                           encoding="bytes")
 1699:         control = np.rec.array([(1, 5, 0), (2, 8, 1), (3, 3, 3)], dtype=dtyp)
 1700:         assert_equal(test, control)
 1701: 
 1702:     def test_dtype_with_object(self):
 1703:         # Test using an explicit dtype with an object
 1704:         data = """ 1; 2001-01-01
 1705:                    2; 2002-01-31 """
 1706:         ndtype = [('idx', int), ('code', object)]
 1707:         func = lambda s: strptime(s.strip(), "%Y-%m-%d")
 1708:         converters = {1: func}
 1709:         test = np.genfromtxt(TextIO(data), delimiter=";", dtype=ndtype,
 1710:                              converters=converters)
 1711:         control = np.array(
 1712:             [(1, datetime(2001, 1, 1)), (2, datetime(2002, 1, 31))],
 1713:             dtype=ndtype)
 1714:         assert_equal(test, control)
 1715: 
 1716:         ndtype = [('nest', [('idx', int), ('code', object)])]
 1717:         with assert_raises_regex(NotImplementedError,
 1718:                                  'Nested fields.* not supported.*'):
 1719:             test = np.genfromtxt(TextIO(data), delimiter=";",
 1720:                                  dtype=ndtype, converters=converters)
 1721: 
 1722:         # nested but empty fields also aren't supported
 1723:         ndtype = [('idx', int), ('code', object), ('nest', [])]
 1724:         with assert_raises_regex(NotImplementedError,
 1725:                                  'Nested fields.* not supported.*'):
 1726:             test = np.genfromtxt(TextIO(data), delimiter=";",
 1727:                                  dtype=ndtype, converters=converters)
 1728: 
 1729:     def test_dtype_with_object_no_converter(self):
 1730:         # Object without a converter uses bytes:
 1731:         parsed = np.genfromtxt(TextIO("1"), dtype=object)
 1732:         assert parsed[()] == b"1"
 1733:         parsed = np.genfromtxt(TextIO("string"), dtype=object)
 1734:         assert parsed[()] == b"string"
 1735: 
 1736:     def test_userconverters_with_explicit_dtype(self):
 1737:         # Test user_converters w/ explicit (standard) dtype
 1738:         data = TextIO('skip,skip,2001-01-01,1.0,skip')
 1739:         test = np.genfromtxt(data, delimiter=",", names=None, dtype=float,
 1740:                              usecols=(2, 3), converters={2: bytes})
 1741:         control = np.array([('2001-01-01', 1.)],
 1742:                            dtype=[('', '|S10'), ('', float)])
 1743:         assert_equal(test, control)
 1744: 
 1745:     def test_utf8_userconverters_with_explicit_dtype(self):
 1746:         utf8 = b'\xcf\x96'
 1747:         with temppath() as path:
 1748:             with open(path, 'wb') as f:
 1749:                 f.write(b'skip,skip,2001-01-01' + utf8 + b',1.0,skip')
 1750:             test = np.genfromtxt(path, delimiter=",", names=None, dtype=float,
 1751:                                  usecols=(2, 3), converters={2: str},
 1752:                                  encoding='UTF-8')
 1753:         control = np.array([('2001-01-01' + utf8.decode('UTF-8'), 1.)],
 1754:                            dtype=[('', '|U11'), ('', float)])
 1755:         assert_equal(test, control)
 1756: 
 1757:     def test_spacedelimiter(self):
 1758:         # Test space delimiter
 1759:         data = TextIO("1  2  3  4   5\n6  7  8  9  10")
 1760:         test = np.genfromtxt(data)
 1761:         control = np.array([[1., 2., 3., 4., 5.],
 1762:                             [6., 7., 8., 9., 10.]])
 1763:         assert_equal(test, control)
 1764: 
 1765:     def test_integer_delimiter(self):
 1766:         # Test using an integer for delimiter
 1767:         data = "  1  2  3\n  4  5 67\n890123  4"
 1768:         test = np.genfromtxt(TextIO(data), delimiter=3)
 1769:         control = np.array([[1, 2, 3], [4, 5, 67], [890, 123, 4]])
 1770:         assert_equal(test, control)
 1771: 
 1772:     def test_missing(self):
 1773:         data = TextIO('1,2,3,,5\n')
 1774:         test = np.genfromtxt(data, dtype=int, delimiter=',',
 1775:                             converters={3: lambda s: int(s or - 999)})
 1776:         control = np.array([1, 2, 3, -999, 5], int)
 1777:         assert_equal(test, control)
 1778: 
 1779:     def test_missing_with_tabs(self):
 1780:         # Test w/ a delimiter tab
 1781:         txt = "1\t2\t3\n\t2\t\n1\t\t3"
 1782:         test = np.genfromtxt(TextIO(txt), delimiter="\t",
 1783:                              usemask=True,)
 1784:         ctrl_d = np.array([(1, 2, 3), (np.nan, 2, np.nan), (1, np.nan, 3)],)
 1785:         ctrl_m = np.array([(0, 0, 0), (1, 0, 1), (0, 1, 0)], dtype=bool)
 1786:         assert_equal(test.data, ctrl_d)
 1787:         assert_equal(test.mask, ctrl_m)
 1788: 
 1789:     def test_usecols(self):
 1790:         # Test the selection of columns
 1791:         # Select 1 column
 1792:         control = np.array([[1, 2], [3, 4]], float)
 1793:         data = TextIO()
 1794:         np.savetxt(data, control)
 1795:         data.seek(0)
 1796:         test = np.genfromtxt(data, dtype=float, usecols=(1,))
 1797:         assert_equal(test, control[:, 1])
 1798:         #
 1799:         control = np.array([[1, 2, 3], [3, 4, 5]], float)
 1800:         data = TextIO()
 1801:         np.savetxt(data, control)
 1802:         data.seek(0)
 1803:         test = np.genfromtxt(data, dtype=float, usecols=(1, 2))
 1804:         assert_equal(test, control[:, 1:])
 1805:         # Testing with arrays instead of tuples.
 1806:         data.seek(0)
 1807:         test = np.genfromtxt(data, dtype=float, usecols=np.array([1, 2]))
 1808:         assert_equal(test, control[:, 1:])
 1809: 
 1810:     def test_usecols_as_css(self):
 1811:         # Test giving usecols with a comma-separated string
 1812:         data = "1 2 3\n4 5 6"
 1813:         test = np.genfromtxt(TextIO(data),
 1814:                              names="a, b, c", usecols="a, c")
 1815:         ctrl = np.array([(1, 3), (4, 6)], dtype=[(_, float) for _ in "ac"])
 1816:         assert_equal(test, ctrl)
 1817: 
 1818:     def test_usecols_with_structured_dtype(self):
 1819:         # Test usecols with an explicit structured dtype
 1820:         data = TextIO("JOE 70.1 25.3\nBOB 60.5 27.9")
 1821:         names = ['stid', 'temp']
 1822:         dtypes = ['S4', 'f8']
 1823:         test = np.genfromtxt(
 1824:             data, usecols=(0, 2), dtype=list(zip(names, dtypes)))
 1825:         assert_equal(test['stid'], [b"JOE", b"BOB"])
 1826:         assert_equal(test['temp'], [25.3, 27.9])
 1827: 
 1828:     def test_usecols_with_integer(self):
 1829:         # Test usecols with an integer
 1830:         test = np.genfromtxt(TextIO(b"1 2 3\n4 5 6"), usecols=0)
 1831:         assert_equal(test, np.array([1., 4.]))
 1832: 
 1833:     def test_usecols_with_named_columns(self):
 1834:         # Test usecols with named columns
 1835:         ctrl = np.array([(1, 3), (4, 6)], dtype=[('a', float), ('c', float)])
 1836:         data = "1 2 3\n4 5 6"
 1837:         kwargs = {"names": "a, b, c"}
 1838:         test = np.genfromtxt(TextIO(data), usecols=(0, -1), **kwargs)
 1839:         assert_equal(test, ctrl)
 1840:         test = np.genfromtxt(TextIO(data),
 1841:                              usecols=('a', 'c'), **kwargs)
 1842:         assert_equal(test, ctrl)
 1843: 
 1844:     def test_empty_file(self):
 1845:         # Test that an empty file raises the proper warning.
 1846:         with suppress_warnings() as sup:
 1847:             sup.filter(message="genfromtxt: Empty input file:")
 1848:             data = TextIO()
 1849:             test = np.genfromtxt(data)
 1850:             assert_equal(test, np.array([]))
 1851: 
 1852:             # when skip_header > 0
 1853:             test = np.genfromtxt(data, skip_header=1)
 1854:             assert_equal(test, np.array([]))
 1855: 
 1856:     def test_fancy_dtype_alt(self):
 1857:         # Check that a nested dtype isn't MIA
 1858:         data = TextIO('1,2,3.0\n4,5,6.0\n')
 1859:         fancydtype = np.dtype([('x', int), ('y', [('t', int), ('s', float)])])
 1860:         test = np.genfromtxt(data, dtype=fancydtype, delimiter=',', usemask=True)
 1861:         control = ma.array([(1, (2, 3.0)), (4, (5, 6.0))], dtype=fancydtype)
 1862:         assert_equal(test, control)
 1863: 
 1864:     def test_shaped_dtype(self):
 1865:         c = TextIO("aaaa  1.0  8.0  1 2 3 4 5 6")
 1866:         dt = np.dtype([('name', 'S4'), ('x', float), ('y', float),
 1867:                        ('block', int, (2, 3))])
 1868:         x = np.genfromtxt(c, dtype=dt)
 1869:         a = np.array([('aaaa', 1.0, 8.0, [[1, 2, 3], [4, 5, 6]])],
 1870:                      dtype=dt)
 1871:         assert_array_equal(x, a)
 1872: 
 1873:     def test_withmissing(self):
 1874:         data = TextIO('A,B\n0,1\n2,N/A')
 1875:         kwargs = {"delimiter": ",", "missing_values": "N/A", "names": True}
 1876:         test = np.genfromtxt(data, dtype=None, usemask=True, **kwargs)
 1877:         control = ma.array([(0, 1), (2, -1)],
 1878:                            mask=[(False, False), (False, True)],
 1879:                            dtype=[('A', int), ('B', int)])
 1880:         assert_equal(test, control)
 1881:         assert_equal(test.mask, control.mask)
 1882:         #
 1883:         data.seek(0)
 1884:         test = np.genfromtxt(data, usemask=True, **kwargs)
 1885:         control = ma.array([(0, 1), (2, -1)],
 1886:                            mask=[(False, False), (False, True)],
 1887:                            dtype=[('A', float), ('B', float)])
 1888:         assert_equal(test, control)
 1889:         assert_equal(test.mask, control.mask)
 1890: 
 1891:     def test_user_missing_values(self):
 1892:         data = "A, B, C\n0, 0., 0j\n1, N/A, 1j\n-9, 2.2, N/A\n3, -99, 3j"
 1893:         basekwargs = {"dtype": None, "delimiter": ",", "names": True}
 1894:         mdtype = [('A', int), ('B', float), ('C', complex)]
 1895:         #
 1896:         test = np.genfromtxt(TextIO(data), missing_values="N/A",
 1897:                             **basekwargs)
 1898:         control = ma.array([(0, 0.0, 0j), (1, -999, 1j),
 1899:                             (-9, 2.2, -999j), (3, -99, 3j)],
 1900:                            mask=[(0, 0, 0), (0, 1, 0), (0, 0, 1), (0, 0, 0)],
 1901:                            dtype=mdtype)
 1902:         assert_equal(test, control)
 1903:         #
 1904:         basekwargs['dtype'] = mdtype
 1905:         test = np.genfromtxt(TextIO(data),
 1906:                             missing_values={0: -9, 1: -99, 2: -999j}, usemask=True, **basekwargs)
 1907:         control = ma.array([(0, 0.0, 0j), (1, -999, 1j),
 1908:                             (-9, 2.2, -999j), (3, -99, 3j)],
 1909:                            mask=[(0, 0, 0), (0, 1, 0), (1, 0, 1), (0, 1, 0)],
 1910:                            dtype=mdtype)
 1911:         assert_equal(test, control)
 1912:         #
 1913:         test = np.genfromtxt(TextIO(data),
 1914:                             missing_values={0: -9, 'B': -99, 'C': -999j},
 1915:                             usemask=True,
 1916:                             **basekwargs)
 1917:         control = ma.array([(0, 0.0, 0j), (1, -999, 1j),
 1918:                             (-9, 2.2, -999j), (3, -99, 3j)],
 1919:                            mask=[(0, 0, 0), (0, 1, 0), (1, 0, 1), (0, 1, 0)],
 1920:                            dtype=mdtype)
 1921:         assert_equal(test, control)
 1922: 
 1923:     def test_user_filling_values(self):
 1924:         # Test with missing and filling values
 1925:         ctrl = np.array([(0, 3), (4, -999)], dtype=[('a', int), ('b', int)])
 1926:         data = "N/A, 2, 3\n4, ,???"
 1927:         kwargs = {"delimiter": ",",
 1928:                       "dtype": int,
 1929:                       "names": "a,b,c",
 1930:                       "missing_values": {0: "N/A", 'b': " ", 2: "???"},
 1931:                       "filling_values": {0: 0, 'b': 0, 2: -999}}
 1932:         test = np.genfromtxt(TextIO(data), **kwargs)
 1933:         ctrl = np.array([(0, 2, 3), (4, 0, -999)],
 1934:                         dtype=[(_, int) for _ in "abc"])
 1935:         assert_equal(test, ctrl)
 1936:         #
 1937:         test = np.genfromtxt(TextIO(data), usecols=(0, -1), **kwargs)
 1938:         ctrl = np.array([(0, 3), (4, -999)], dtype=[(_, int) for _ in "ac"])
 1939:         assert_equal(test, ctrl)
 1940: 
 1941:         data2 = "1,2,*,4\n5,*,7,8\n"
 1942:         test = np.genfromtxt(TextIO(data2), delimiter=',', dtype=int,
 1943:                              missing_values="*", filling_values=0)
 1944:         ctrl = np.array([[1, 2, 0, 4], [5, 0, 7, 8]])
 1945:         assert_equal(test, ctrl)
 1946:         test = np.genfromtxt(TextIO(data2), delimiter=',', dtype=int,
 1947:                              missing_values="*", filling_values=-1)
 1948:         ctrl = np.array([[1, 2, -1, 4], [5, -1, 7, 8]])
 1949:         assert_equal(test, ctrl)
 1950: 
 1951:     def test_withmissing_float(self):
 1952:         data = TextIO('A,B\n0,1.5\n2,-999.00')
 1953:         test = np.genfromtxt(data, dtype=None, delimiter=',',
 1954:                             missing_values='-999.0', names=True, usemask=True)
 1955:         control = ma.array([(0, 1.5), (2, -1.)],
 1956:                            mask=[(False, False), (False, True)],
 1957:                            dtype=[('A', int), ('B', float)])
 1958:         assert_equal(test, control)
 1959:         assert_equal(test.mask, control.mask)
 1960: 
 1961:     def test_with_masked_column_uniform(self):
 1962:         # Test masked column
 1963:         data = TextIO('1 2 3\n4 5 6\n')
 1964:         test = np.genfromtxt(data, dtype=None,
 1965:                              missing_values='2,5', usemask=True)
 1966:         control = ma.array([[1, 2, 3], [4, 5, 6]], mask=[[0, 1, 0], [0, 1, 0]])
 1967:         assert_equal(test, control)
 1968: 
 1969:     def test_with_masked_column_various(self):
 1970:         # Test masked column
 1971:         data = TextIO('True 2 3\nFalse 5 6\n')
 1972:         test = np.genfromtxt(data, dtype=None,
 1973:                              missing_values='2,5', usemask=True)
 1974:         control = ma.array([(1, 2, 3), (0, 5, 6)],
 1975:                            mask=[(0, 1, 0), (0, 1, 0)],
 1976:                            dtype=[('f0', bool), ('f1', bool), ('f2', int)])
 1977:         assert_equal(test, control)
 1978: 
 1979:     def test_invalid_raise(self):
 1980:         # Test invalid raise
 1981:         data = ["1, 1, 1, 1, 1"] * 50
 1982:         for i in range(5):
 1983:             data[10 * i] = "2, 2, 2, 2 2"
 1984:         data.insert(0, "a, b, c, d, e")
 1985:         mdata = TextIO("\n".join(data))
 1986: 
 1987:         kwargs = {"delimiter": ",", "dtype": None, "names": True}
 1988: 
 1989:         def f():
 1990:             return np.genfromtxt(mdata, invalid_raise=False, **kwargs)
 1991:         mtest = assert_warns(ConversionWarning, f)
 1992:         assert_equal(len(mtest), 45)
 1993:         assert_equal(mtest, np.ones(45, dtype=[(_, int) for _ in 'abcde']))
 1994:         #
 1995:         mdata.seek(0)
 1996:         assert_raises(ValueError, np.genfromtxt, mdata,
 1997:                       delimiter=",", names=True)
 1998: 
 1999:     def test_invalid_raise_with_usecols(self):
 2000:         # Test invalid_raise with usecols
 2001:         data = ["1, 1, 1, 1, 1"] * 50
 2002:         for i in range(5):
 2003:             data[10 * i] = "2, 2, 2, 2 2"
 2004:         data.insert(0, "a, b, c, d, e")
 2005:         mdata = TextIO("\n".join(data))
 2006: 
 2007:         kwargs = {"delimiter": ",", "dtype": None, "names": True,
 2008:                       "invalid_raise": False}
 2009: 
 2010:         def f():
 2011:             return np.genfromtxt(mdata, usecols=(0, 4), **kwargs)
 2012:         mtest = assert_warns(ConversionWarning, f)
 2013:         assert_equal(len(mtest), 45)
 2014:         assert_equal(mtest, np.ones(45, dtype=[(_, int) for _ in 'ae']))
 2015:         #
 2016:         mdata.seek(0)
 2017:         mtest = np.genfromtxt(mdata, usecols=(0, 1), **kwargs)
 2018:         assert_equal(len(mtest), 50)
 2019:         control = np.ones(50, dtype=[(_, int) for _ in 'ab'])
 2020:         control[[10 * _ for _ in range(5)]] = (2, 2)
 2021:         assert_equal(mtest, control)
 2022: 
 2023:     def test_inconsistent_dtype(self):
 2024:         # Test inconsistent dtype
 2025:         data = ["1, 1, 1, 1, -1.1"] * 50
 2026:         mdata = TextIO("\n".join(data))
 2027: 
 2028:         converters = {4: lambda x: f"({x.decode()})"}
 2029:         kwargs = {"delimiter": ",", "converters": converters,
 2030:                       "dtype": [(_, int) for _ in 'abcde'], "encoding": "bytes"}
 2031:         assert_raises(ValueError, np.genfromtxt, mdata, **kwargs)
 2032: 
 2033:     def test_default_field_format(self):
 2034:         # Test default format
 2035:         data = "0, 1, 2.3\n4, 5, 6.7"
 2036:         mtest = np.genfromtxt(TextIO(data),
 2037:                              delimiter=",", dtype=None, defaultfmt="f%02i")
 2038:         ctrl = np.array([(0, 1, 2.3), (4, 5, 6.7)],
 2039:                         dtype=[("f00", int), ("f01", int), ("f02", float)])
 2040:         assert_equal(mtest, ctrl)
 2041: 
 2042:     def test_single_dtype_wo_names(self):
 2043:         # Test single dtype w/o names
 2044:         data = "0, 1, 2.3\n4, 5, 6.7"
 2045:         mtest = np.genfromtxt(TextIO(data),
 2046:                              delimiter=",", dtype=float, defaultfmt="f%02i")
 2047:         ctrl = np.array([[0., 1., 2.3], [4., 5., 6.7]], dtype=float)
 2048:         assert_equal(mtest, ctrl)
 2049: 
 2050:     def test_single_dtype_w_explicit_names(self):
 2051:         # Test single dtype w explicit names
 2052:         data = "0, 1, 2.3\n4, 5, 6.7"
 2053:         mtest = np.genfromtxt(TextIO(data),
 2054:                              delimiter=",", dtype=float, names="a, b, c")
 2055:         ctrl = np.array([(0., 1., 2.3), (4., 5., 6.7)],
 2056:                         dtype=[(_, float) for _ in "abc"])
 2057:         assert_equal(mtest, ctrl)
 2058: 
 2059:     def test_single_dtype_w_implicit_names(self):
 2060:         # Test single dtype w implicit names
 2061:         data = "a, b, c\n0, 1, 2.3\n4, 5, 6.7"
 2062:         mtest = np.genfromtxt(TextIO(data),
 2063:                              delimiter=",", dtype=float, names=True)
 2064:         ctrl = np.array([(0., 1., 2.3), (4., 5., 6.7)],
 2065:                         dtype=[(_, float) for _ in "abc"])
 2066:         assert_equal(mtest, ctrl)
 2067: 
 2068:     def test_easy_structured_dtype(self):
 2069:         # Test easy structured dtype
 2070:         data = "0, 1, 2.3\n4, 5, 6.7"
 2071:         mtest = np.genfromtxt(TextIO(data), delimiter=",",
 2072:                              dtype=(int, float, float), defaultfmt="f_%02i")
 2073:         ctrl = np.array([(0, 1., 2.3), (4, 5., 6.7)],
 2074:                         dtype=[("f_00", int), ("f_01", float), ("f_02", float)])
 2075:         assert_equal(mtest, ctrl)
 2076: 
 2077:     def test_autostrip(self):
 2078:         # Test autostrip
 2079:         data = "01/01/2003  , 1.3,   abcde"
 2080:         kwargs = {"delimiter": ",", "dtype": None, "encoding": "bytes"}
 2081:         with warnings.catch_warnings(record=True) as w:
 2082:             warnings.filterwarnings('always', '', VisibleDeprecationWarning)
 2083:             mtest = np.genfromtxt(TextIO(data), **kwargs)
 2084:             assert_(w[0].category is VisibleDeprecationWarning)
 2085:         ctrl = np.array([('01/01/2003  ', 1.3, '   abcde')],
 2086:                         dtype=[('f0', '|S12'), ('f1', float), ('f2', '|S8')])
 2087:         assert_equal(mtest, ctrl)
 2088:         with warnings.catch_warnings(record=True) as w:
 2089:             warnings.filterwarnings('always', '', VisibleDeprecationWarning)
 2090:             mtest = np.genfromtxt(TextIO(data), autostrip=True, **kwargs)
 2091:             assert_(w[0].category is VisibleDeprecationWarning)
 2092:         ctrl = np.array([('01/01/2003', 1.3, 'abcde')],
 2093:                         dtype=[('f0', '|S10'), ('f1', float), ('f2', '|S5')])
 2094:         assert_equal(mtest, ctrl)
 2095: 
 2096:     def test_replace_space(self):
 2097:         # Test the 'replace_space' option
 2098:         txt = "A.A, B (B), C:C\n1, 2, 3.14"
 2099:         # Test default: replace ' ' by '_' and delete non-alphanum chars
 2100:         test = np.genfromtxt(TextIO(txt),
 2101:                              delimiter=",", names=True, dtype=None)
 2102:         ctrl_dtype = [("AA", int), ("B_B", int), ("CC", float)]
 2103:         ctrl = np.array((1, 2, 3.14), dtype=ctrl_dtype)
 2104:         assert_equal(test, ctrl)
 2105:         # Test: no replace, no delete
 2106:         test = np.genfromtxt(TextIO(txt),
 2107:                              delimiter=",", names=True, dtype=None,
 2108:                              replace_space='', deletechars='')
 2109:         ctrl_dtype = [("A.A", int), ("B (B)", int), ("C:C", float)]
 2110:         ctrl = np.array((1, 2, 3.14), dtype=ctrl_dtype)
 2111:         assert_equal(test, ctrl)
 2112:         # Test: no delete (spaces are replaced by _)
 2113:         test = np.genfromtxt(TextIO(txt),
 2114:                              delimiter=",", names=True, dtype=None,
 2115:                              deletechars='')
 2116:         ctrl_dtype = [("A.A", int), ("B_(B)", int), ("C:C", float)]
 2117:         ctrl = np.array((1, 2, 3.14), dtype=ctrl_dtype)
 2118:         assert_equal(test, ctrl)
 2119: 
 2120:     def test_replace_space_known_dtype(self):
 2121:         # Test the 'replace_space' (and related) options when dtype != None
 2122:         txt = "A.A, B (B), C:C\n1, 2, 3"
 2123:         # Test default: replace ' ' by '_' and delete non-alphanum chars
 2124:         test = np.genfromtxt(TextIO(txt),
 2125:                              delimiter=",", names=True, dtype=int)
 2126:         ctrl_dtype = [("AA", int), ("B_B", int), ("CC", int)]
 2127:         ctrl = np.array((1, 2, 3), dtype=ctrl_dtype)
 2128:         assert_equal(test, ctrl)
 2129:         # Test: no replace, no delete
 2130:         test = np.genfromtxt(TextIO(txt),
 2131:                              delimiter=",", names=True, dtype=int,
 2132:                              replace_space='', deletechars='')
 2133:         ctrl_dtype = [("A.A", int), ("B (B)", int), ("C:C", int)]
 2134:         ctrl = np.array((1, 2, 3), dtype=ctrl_dtype)
 2135:         assert_equal(test, ctrl)
 2136:         # Test: no delete (spaces are replaced by _)
 2137:         test = np.genfromtxt(TextIO(txt),
 2138:                              delimiter=",", names=True, dtype=int,
 2139:                              deletechars='')
 2140:         ctrl_dtype = [("A.A", int), ("B_(B)", int), ("C:C", int)]
 2141:         ctrl = np.array((1, 2, 3), dtype=ctrl_dtype)
 2142:         assert_equal(test, ctrl)
 2143: 
 2144:     def test_incomplete_names(self):
 2145:         # Test w/ incomplete names
 2146:         data = "A,,C\n0,1,2\n3,4,5"
 2147:         kwargs = {"delimiter": ",", "names": True}
 2148:         # w/ dtype=None
 2149:         ctrl = np.array([(0, 1, 2), (3, 4, 5)],
 2150:                         dtype=[(_, int) for _ in ('A', 'f0', 'C')])
 2151:         test = np.genfromtxt(TextIO(data), dtype=None, **kwargs)
 2152:         assert_equal(test, ctrl)
 2153:         # w/ default dtype
 2154:         ctrl = np.array([(0, 1, 2), (3, 4, 5)],
 2155:                         dtype=[(_, float) for _ in ('A', 'f0', 'C')])
 2156:         test = np.genfromtxt(TextIO(data), **kwargs)
 2157: 
 2158:     def test_names_auto_completion(self):
 2159:         # Make sure that names are properly completed
 2160:         data = "1 2 3\n 4 5 6"
 2161:         test = np.genfromtxt(TextIO(data),
 2162:                              dtype=(int, float, int), names="a")
 2163:         ctrl = np.array([(1, 2, 3), (4, 5, 6)],
 2164:                         dtype=[('a', int), ('f0', float), ('f1', int)])
 2165:         assert_equal(test, ctrl)
 2166: 
 2167:     def test_names_with_usecols_bug1636(self):
 2168:         # Make sure we pick up the right names w/ usecols
 2169:         data = "A,B,C,D,E\n0,1,2,3,4\n0,1,2,3,4\n0,1,2,3,4"
 2170:         ctrl_names = ("A", "C", "E")
 2171:         test = np.genfromtxt(TextIO(data),
 2172:                              dtype=(int, int, int), delimiter=",",
 2173:                              usecols=(0, 2, 4), names=True)
 2174:         assert_equal(test.dtype.names, ctrl_names)
 2175:         #
 2176:         test = np.genfromtxt(TextIO(data),
 2177:                              dtype=(int, int, int), delimiter=",",
 2178:                              usecols=("A", "C", "E"), names=True)
 2179:         assert_equal(test.dtype.names, ctrl_names)
 2180:         #
 2181:         test = np.genfromtxt(TextIO(data),
 2182:                              dtype=int, delimiter=",",
 2183:                              usecols=("A", "C", "E"), names=True)
 2184:         assert_equal(test.dtype.names, ctrl_names)
 2185: 
 2186:     def test_fixed_width_names(self):
 2187:         # Test fix-width w/ names
 2188:         data = "    A    B   C\n    0    1 2.3\n   45   67   9."
 2189:         kwargs = {"delimiter": (5, 5, 4), "names": True, "dtype": None}
 2190:         ctrl = np.array([(0, 1, 2.3), (45, 67, 9.)],
 2191:                         dtype=[('A', int), ('B', int), ('C', float)])
 2192:         test = np.genfromtxt(TextIO(data), **kwargs)
 2193:         assert_equal(test, ctrl)
 2194:         #
 2195:         kwargs = {"delimiter": 5, "names": True, "dtype": None}
 2196:         ctrl = np.array([(0, 1, 2.3), (45, 67, 9.)],
 2197:                         dtype=[('A', int), ('B', int), ('C', float)])
 2198:         test = np.genfromtxt(TextIO(data), **kwargs)
 2199:         assert_equal(test, ctrl)
 2200: 
 2201:     def test_filling_values(self):
 2202:         # Test missing values
 2203:         data = b"1, 2, 3\n1, , 5\n0, 6, \n"
 2204:         kwargs = {"delimiter": ",", "dtype": None, "filling_values": -999}
 2205:         ctrl = np.array([[1, 2, 3], [1, -999, 5], [0, 6, -999]], dtype=int)
 2206:         test = np.genfromtxt(TextIO(data), **kwargs)
 2207:         assert_equal(test, ctrl)
 2208: 
 2209:     def test_comments_is_none(self):
 2210:         # Github issue 329 (None was previously being converted to 'None').
 2211:         with warnings.catch_warnings(record=True) as w:
 2212:             warnings.filterwarnings('always', '', VisibleDeprecationWarning)
 2213:             test = np.genfromtxt(TextIO("test1,testNonetherestofthedata"),
 2214:                                  dtype=None, comments=None, delimiter=',',
 2215:                                  encoding="bytes")
 2216:             assert_(w[0].category is VisibleDeprecationWarning)
 2217:         assert_equal(test[1], b'testNonetherestofthedata')
 2218:         with warnings.catch_warnings(record=True) as w:
 2219:             warnings.filterwarnings('always', '', VisibleDeprecationWarning)
 2220:             test = np.genfromtxt(TextIO("test1, testNonetherestofthedata"),
 2221:                                  dtype=None, comments=None, delimiter=',',
 2222:                                  encoding="bytes")
 2223:             assert_(w[0].category is VisibleDeprecationWarning)
 2224:         assert_equal(test[1], b' testNonetherestofthedata')
 2225: 
 2226:     def test_latin1(self):
 2227:         latin1 = b'\xf6\xfc\xf6'
 2228:         norm = b"norm1,norm2,norm3\n"
 2229:         enc = b"test1,testNonethe" + latin1 + b",test3\n"
 2230:         s = norm + enc + norm
 2231:         with warnings.catch_warnings(record=True) as w:
 2232:             warnings.filterwarnings('always', '', VisibleDeprecationWarning)
 2233:             test = np.genfromtxt(TextIO(s),
 2234:                                  dtype=None, comments=None, delimiter=',',
 2235:                                  encoding="bytes")
 2236:             assert_(w[0].category is VisibleDeprecationWarning)
 2237:         assert_equal(test[1, 0], b"test1")
 2238:         assert_equal(test[1, 1], b"testNonethe" + latin1)
 2239:         assert_equal(test[1, 2], b"test3")
 2240:         test = np.genfromtxt(TextIO(s),
 2241:                              dtype=None, comments=None, delimiter=',',
 2242:                              encoding='latin1')
 2243:         assert_equal(test[1, 0], "test1")
 2244:         assert_equal(test[1, 1], "testNonethe" + latin1.decode('latin1'))
 2245:         assert_equal(test[1, 2], "test3")
 2246: 
 2247:         with warnings.catch_warnings(record=True) as w:
 2248:             warnings.filterwarnings('always', '', VisibleDeprecationWarning)
 2249:             test = np.genfromtxt(TextIO(b"0,testNonethe" + latin1),
 2250:                                  dtype=None, comments=None, delimiter=',',
 2251:                                  encoding="bytes")
 2252:             assert_(w[0].category is VisibleDeprecationWarning)
 2253:         assert_equal(test['f0'], 0)
 2254:         assert_equal(test['f1'], b"testNonethe" + latin1)
 2255: 
 2256:     def test_binary_decode_autodtype(self):
 2257:         utf16 = b'\xff\xfeh\x04 \x00i\x04 \x00j\x04'
 2258:         v = self.loadfunc(BytesIO(utf16), dtype=None, encoding='UTF-16')
 2259:         assert_array_equal(v, np.array(utf16.decode('UTF-16').split()))
 2260: 
 2261:     def test_utf8_byte_encoding(self):
 2262:         utf8 = b"\xcf\x96"
 2263:         norm = b"norm1,norm2,norm3\n"
 2264:         enc = b"test1,testNonethe" + utf8 + b",test3\n"
 2265:         s = norm + enc + norm
 2266:         with warnings.catch_warnings(record=True) as w:
 2267:             warnings.filterwarnings('always', '', VisibleDeprecationWarning)
 2268:             test = np.genfromtxt(TextIO(s),
 2269:                                  dtype=None, comments=None, delimiter=',',
 2270:                                  encoding="bytes")
 2271:             assert_(w[0].category is VisibleDeprecationWarning)
 2272:         ctl = np.array([
 2273:                  [b'norm1', b'norm2', b'norm3'],
 2274:                  [b'test1', b'testNonethe' + utf8, b'test3'],
 2275:                  [b'norm1', b'norm2', b'norm3']])
 2276:         assert_array_equal(test, ctl)
 2277: 
 2278:     def test_utf8_file(self):
 2279:         utf8 = b"\xcf\x96"
 2280:         with temppath() as path:
 2281:             with open(path, "wb") as f:
 2282:                 f.write((b"test1,testNonethe" + utf8 + b",test3\n") * 2)
 2283:             test = np.genfromtxt(path, dtype=None, comments=None,
 2284:                                  delimiter=',', encoding="UTF-8")
 2285:             ctl = np.array([
 2286:                      ["test1", "testNonethe" + utf8.decode("UTF-8"), "test3"],
 2287:                      ["test1", "testNonethe" + utf8.decode("UTF-8"), "test3"]],
 2288:                      dtype=np.str_)
 2289:             assert_array_equal(test, ctl)
 2290: 
 2291:             # test a mixed dtype
 2292:             with open(path, "wb") as f:
 2293:                 f.write(b"0,testNonethe" + utf8)
 2294:             test = np.genfromtxt(path, dtype=None, comments=None,
 2295:                                  delimiter=',', encoding="UTF-8")
 2296:             assert_equal(test['f0'], 0)
 2297:             assert_equal(test['f1'], "testNonethe" + utf8.decode("UTF-8"))
 2298: 
 2299:     def test_utf8_file_nodtype_unicode(self):
 2300:         # bytes encoding with non-latin1 -> unicode upcast
 2301:         utf8 = '\u03d6'
 2302:         latin1 = '\xf6\xfc\xf6'
 2303: 
 2304:         # skip test if cannot encode utf8 test string with preferred
 2305:         # encoding. The preferred encoding is assumed to be the default
 2306:         # encoding of open. Will need to change this for PyTest, maybe
 2307:         # using pytest.mark.xfail(raises=***).
 2308:         try:
 2309:             encoding = locale.getpreferredencoding()
 2310:             utf8.encode(encoding)
 2311:         except (UnicodeError, ImportError):
 2312:             pytest.skip('Skipping test_utf8_file_nodtype_unicode, '
 2313:                         'unable to encode utf8 in preferred encoding')
 2314: 
 2315:         with temppath() as path:
 2316:             with open(path, "wt") as f:
 2317:                 f.write("norm1,norm2,norm3\n")
 2318:                 f.write("norm1," + latin1 + ",norm3\n")
 2319:                 f.write("test1,testNonethe" + utf8 + ",test3\n")
 2320:             with warnings.catch_warnings(record=True) as w:
 2321:                 warnings.filterwarnings('always', '',
 2322:                                         VisibleDeprecationWarning)
 2323:                 test = np.genfromtxt(path, dtype=None, comments=None,
 2324:                                      delimiter=',', encoding="bytes")
 2325:                 # Check for warning when encoding not specified.
 2326:                 assert_(w[0].category is VisibleDeprecationWarning)
 2327:             ctl = np.array([
 2328:                      ["norm1", "norm2", "norm3"],
 2329:                      ["norm1", latin1, "norm3"],
 2330:                      ["test1", "testNonethe" + utf8, "test3"]],
 2331:                      dtype=np.str_)
 2332:             assert_array_equal(test, ctl)
 2333: 
 2334:     @pytest.mark.filterwarnings("ignore:.*recfromtxt.*:DeprecationWarning")
 2335:     def test_recfromtxt(self):
 2336:         #
 2337:         data = TextIO('A,B\n0,1\n2,3')
 2338:         kwargs = {"delimiter": ",", "missing_values": "N/A", "names": True}
 2339:         test = recfromtxt(data, **kwargs)
 2340:         control = np.array([(0, 1), (2, 3)],
 2341:                            dtype=[('A', int), ('B', int)])
 2342:         assert_(isinstance(test, np.recarray))
 2343:         assert_equal(test, control)
 2344:         #
 2345:         data = TextIO('A,B\n0,1\n2,N/A')
 2346:         test = recfromtxt(data, dtype=None, usemask=True, **kwargs)
 2347:         control = ma.array([(0, 1), (2, -1)],
 2348:                            mask=[(False, False), (False, True)],
 2349:                            dtype=[('A', int), ('B', int)])
 2350:         assert_equal(test, control)
 2351:         assert_equal(test.mask, control.mask)
 2352:         assert_equal(test.A, [0, 2])
 2353: 
 2354:     @pytest.mark.filterwarnings("ignore:.*recfromcsv.*:DeprecationWarning")
 2355:     def test_recfromcsv(self):
 2356:         #
 2357:         data = TextIO('A,B\n0,1\n2,3')
 2358:         kwargs = {"missing_values": "N/A", "names": True, "case_sensitive": True,
 2359:                       "encoding": "bytes"}
 2360:         test = recfromcsv(data, dtype=None, **kwargs)
 2361:         control = np.array([(0, 1), (2, 3)],
 2362:                            dtype=[('A', int), ('B', int)])
 2363:         assert_(isinstance(test, np.recarray))
 2364:         assert_equal(test, control)
 2365:         #
 2366:         data = TextIO('A,B\n0,1\n2,N/A')
 2367:         test = recfromcsv(data, dtype=None, usemask=True, **kwargs)
 2368:         control = ma.array([(0, 1), (2, -1)],
 2369:                            mask=[(False, False), (False, True)],
 2370:                            dtype=[('A', int), ('B', int)])
 2371:         assert_equal(test, control)
 2372:         assert_equal(test.mask, control.mask)
 2373:         assert_equal(test.A, [0, 2])
 2374:         #
 2375:         data = TextIO('A,B\n0,1\n2,3')
 2376:         test = recfromcsv(data, missing_values='N/A',)
 2377:         control = np.array([(0, 1), (2, 3)],
 2378:                            dtype=[('a', int), ('b', int)])
 2379:         assert_(isinstance(test, np.recarray))
 2380:         assert_equal(test, control)
 2381:         #
 2382:         data = TextIO('A,B\n0,1\n2,3')
 2383:         dtype = [('a', int), ('b', float)]
 2384:         test = recfromcsv(data, missing_values='N/A', dtype=dtype)
 2385:         control = np.array([(0, 1), (2, 3)],
 2386:                            dtype=dtype)
 2387:         assert_(isinstance(test, np.recarray))
 2388:         assert_equal(test, control)
 2389: 
 2390:         # gh-10394
 2391:         data = TextIO('color\n"red"\n"blue"')
 2392:         test = recfromcsv(data, converters={0: lambda x: x.strip('\"')})
 2393:         control = np.array([('red',), ('blue',)], dtype=[('color', (str, 4))])
 2394:         assert_equal(test.dtype, control.dtype)
 2395:         assert_equal(test, control)
 2396: 
 2397:     def test_max_rows(self):
 2398:         # Test the `max_rows` keyword argument.
 2399:         data = '1 2\n3 4\n5 6\n7 8\n9 10\n'
 2400:         txt = TextIO(data)
 2401:         a1 = np.genfromtxt(txt, max_rows=3)
 2402:         a2 = np.genfromtxt(txt)
 2403:         assert_equal(a1, [[1, 2], [3, 4], [5, 6]])
 2404:         assert_equal(a2, [[7, 8], [9, 10]])
 2405: 
 2406:         # max_rows must be at least 1.
 2407:         assert_raises(ValueError, np.genfromtxt, TextIO(data), max_rows=0)
 2408: 
 2409:         # An input with several invalid rows.
 2410:         data = '1 1\n2 2\n0 \n3 3\n4 4\n5  \n6  \n7  \n'
 2411: 
 2412:         test = np.genfromtxt(TextIO(data), max_rows=2)
 2413:         control = np.array([[1., 1.], [2., 2.]])
 2414:         assert_equal(test, control)
 2415: 
 2416:         # Test keywords conflict
 2417:         assert_raises(ValueError, np.genfromtxt, TextIO(data), skip_footer=1,
 2418:                       max_rows=4)
 2419: 
 2420:         # Test with invalid value
 2421:         assert_raises(ValueError, np.genfromtxt, TextIO(data), max_rows=4)
 2422: 
 2423:         # Test with invalid not raise
 2424:         with suppress_warnings() as sup:
 2425:             sup.filter(ConversionWarning)
 2426: 
 2427:             test = np.genfromtxt(TextIO(data), max_rows=4, invalid_raise=False)
 2428:             control = np.array([[1., 1.], [2., 2.], [3., 3.], [4., 4.]])
 2429:             assert_equal(test, control)
 2430: 
 2431:             test = np.genfromtxt(TextIO(data), max_rows=5, invalid_raise=False)
 2432:             control = np.array([[1., 1.], [2., 2.], [3., 3.], [4., 4.]])
 2433:             assert_equal(test, control)
 2434: 
 2435:         # Structured array with field names.
 2436:         data = 'a b\n#c d\n1 1\n2 2\n#0 \n3 3\n4 4\n5  5\n'
 2437: 
 2438:         # Test with header, names and comments
 2439:         txt = TextIO(data)
 2440:         test = np.genfromtxt(txt, skip_header=1, max_rows=3, names=True)
 2441:         control = np.array([(1.0, 1.0), (2.0, 2.0), (3.0, 3.0)],
 2442:                       dtype=[('c', '<f8'), ('d', '<f8')])
 2443:         assert_equal(test, control)
 2444:         # To continue reading the same "file", don't use skip_header or
 2445:         # names, and use the previously determined dtype.
 2446:         test = np.genfromtxt(txt, max_rows=None, dtype=test.dtype)
 2447:         control = np.array([(4.0, 4.0), (5.0, 5.0)],
 2448:                       dtype=[('c', '<f8'), ('d', '<f8')])
 2449:         assert_equal(test, control)
 2450: 
 2451:     def test_gft_using_filename(self):
 2452:         # Test that we can load data from a filename as well as a file
 2453:         # object
 2454:         tgt = np.arange(6).reshape((2, 3))
 2455:         linesep = ('\n', '\r\n', '\r')
 2456: 
 2457:         for sep in linesep:
 2458:             data = '0 1 2' + sep + '3 4 5'
 2459:             with temppath() as name:
 2460:                 with open(name, 'w') as f:
 2461:                     f.write(data)
 2462:                 res = np.genfromtxt(name)
 2463:             assert_array_equal(res, tgt)
 2464: 
 2465:     def test_gft_from_gzip(self):
 2466:         # Test that we can load data from a gzipped file
 2467:         wanted = np.arange(6).reshape((2, 3))
 2468:         linesep = ('\n', '\r\n', '\r')
 2469: 
 2470:         for sep in linesep:
 2471:             data = '0 1 2' + sep + '3 4 5'
 2472:             s = BytesIO()
 2473:             with gzip.GzipFile(fileobj=s, mode='w') as g:
 2474:                 g.write(asbytes(data))
 2475: 
 2476:             with temppath(suffix='.gz2') as name:
 2477:                 with open(name, 'w') as f:
 2478:                     f.write(data)
 2479:                 assert_array_equal(np.genfromtxt(name), wanted)
 2480: 
 2481:     def test_gft_using_generator(self):
 2482:         # gft doesn't work with unicode.
 2483:         def count():
 2484:             for i in range(10):
 2485:                 yield asbytes("%d" % i)
 2486: 
 2487:         res = np.genfromtxt(count())
 2488:         assert_array_equal(res, np.arange(10))
 2489: 
 2490:     def test_auto_dtype_largeint(self):
 2491:         # Regression test for numpy/numpy#5635 whereby large integers could
 2492:         # cause OverflowErrors.
 2493: 
 2494:         # Test the automatic definition of the output dtype
 2495:         #
 2496:         # 2**66 = 73786976294838206464 => should convert to float
 2497:         # 2**34 = 17179869184 => should convert to int64
 2498:         # 2**10 = 1024 => should convert to int (int32 on 32-bit systems,
 2499:         #                 int64 on 64-bit systems)
 2500: 
 2501:         data = TextIO('73786976294838206464 17179869184 1024')
 2502: 
 2503:         test = np.genfromtxt(data, dtype=None)
 2504: 
 2505:         assert_equal(test.dtype.names, ['f0', 'f1', 'f2'])
 2506: 
 2507:         assert_(test.dtype['f0'] == float)
 2508:         assert_(test.dtype['f1'] == np.int64)
 2509:         assert_(test.dtype['f2'] == np.int_)
 2510: 
 2511:         assert_allclose(test['f0'], 73786976294838206464.)
 2512:         assert_equal(test['f1'], 17179869184)
 2513:         assert_equal(test['f2'], 1024)
 2514: 
 2515:     def test_unpack_float_data(self):
 2516:         txt = TextIO("1,2,3\n4,5,6\n7,8,9\n0.0,1.0,2.0")
 2517:         a, b, c = np.loadtxt(txt, delimiter=",", unpack=True)
 2518:         assert_array_equal(a, np.array([1.0, 4.0, 7.0, 0.0]))
 2519:         assert_array_equal(b, np.array([2.0, 5.0, 8.0, 1.0]))
 2520:         assert_array_equal(c, np.array([3.0, 6.0, 9.0, 2.0]))
 2521: 
 2522:     def test_unpack_structured(self):
 2523:         # Regression test for gh-4341
 2524:         # Unpacking should work on structured arrays
 2525:         txt = TextIO("M 21 72\nF 35 58")
 2526:         dt = {'names': ('a', 'b', 'c'), 'formats': ('S1', 'i4', 'f4')}
 2527:         a, b, c = np.genfromtxt(txt, dtype=dt, unpack=True)
 2528:         assert_equal(a.dtype, np.dtype('S1'))
 2529:         assert_equal(b.dtype, np.dtype('i4'))
 2530:         assert_equal(c.dtype, np.dtype('f4'))
 2531:         assert_array_equal(a, np.array([b'M', b'F']))
 2532:         assert_array_equal(b, np.array([21, 35]))
 2533:         assert_array_equal(c, np.array([72.,  58.]))
 2534: 
 2535:     def test_unpack_auto_dtype(self):
 2536:         # Regression test for gh-4341
 2537:         # Unpacking should work when dtype=None
 2538:         txt = TextIO("M 21 72.\nF 35 58.")
 2539:         expected = (np.array(["M", "F"]), np.array([21, 35]), np.array([72., 58.]))
 2540:         test = np.genfromtxt(txt, dtype=None, unpack=True, encoding="utf-8")
 2541:         for arr, result in zip(expected, test):
 2542:             assert_array_equal(arr, result)
 2543:             assert_equal(arr.dtype, result.dtype)
 2544: 
 2545:     def test_unpack_single_name(self):
 2546:         # Regression test for gh-4341
 2547:         # Unpacking should work when structured dtype has only one field
 2548:         txt = TextIO("21\n35")
 2549:         dt = {'names': ('a',), 'formats': ('i4',)}
 2550:         expected = np.array([21, 35], dtype=np.int32)
 2551:         test = np.genfromtxt(txt, dtype=dt, unpack=True)
 2552:         assert_array_equal(expected, test)
 2553:         assert_equal(expected.dtype, test.dtype)
 2554: 
 2555:     def test_squeeze_scalar(self):
 2556:         # Regression test for gh-4341
 2557:         # Unpacking a scalar should give zero-dim output,
 2558:         # even if dtype is structured
 2559:         txt = TextIO("1")
 2560:         dt = {'names': ('a',), 'formats': ('i4',)}
 2561:         expected = np.array((1,), dtype=np.int32)
 2562:         test = np.genfromtxt(txt, dtype=dt, unpack=True)
 2563:         assert_array_equal(expected, test)
 2564:         assert_equal((), test.shape)
 2565:         assert_equal(expected.dtype, test.dtype)
 2566: 
 2567:     @pytest.mark.parametrize("ndim", [0, 1, 2])
 2568:     def test_ndmin_keyword(self, ndim: int):
 2569:         # lets have the same behaviour of ndmin as loadtxt
 2570:         # as they should be the same for non-missing values
 2571:         txt = "42"
 2572: 
 2573:         a = np.loadtxt(StringIO(txt), ndmin=ndim)
 2574:         b = np.genfromtxt(StringIO(txt), ndmin=ndim)
 2575: 
 2576:         assert_array_equal(a, b)
 2577: 
 2578: 
 2579: class TestPathUsage:
 2580:     # Test that pathlib.Path can be used
 2581:     def test_loadtxt(self):
 2582:         with temppath(suffix='.txt') as path:
 2583:             path = Path(path)
 2584:             a = np.array([[1.1, 2], [3, 4]])
 2585:             np.savetxt(path, a)
 2586:             x = np.loadtxt(path)
 2587:             assert_array_equal(x, a)
 2588: 
 2589:     def test_save_load(self):
 2590:         # Test that pathlib.Path instances can be used with save.
 2591:         with temppath(suffix='.npy') as path:
 2592:             path = Path(path)
 2593:             a = np.array([[1, 2], [3, 4]], int)
 2594:             np.save(path, a)
 2595:             data = np.load(path)
 2596:             assert_array_equal(data, a)
 2597: 
 2598:     def test_save_load_memmap(self):
 2599:         # Test that pathlib.Path instances can be loaded mem-mapped.
 2600:         with temppath(suffix='.npy') as path:
 2601:             path = Path(path)
 2602:             a = np.array([[1, 2], [3, 4]], int)
 2603:             np.save(path, a)
 2604:             data = np.load(path, mmap_mode='r')
 2605:             assert_array_equal(data, a)
 2606:             # close the mem-mapped file
 2607:             del data
 2608:             if IS_PYPY:
 2609:                 break_cycles()
 2610:                 break_cycles()
 2611: 
 2612:     @pytest.mark.xfail(IS_WASM, reason="memmap doesn't work correctly")
 2613:     @pytest.mark.parametrize("filename_type", [Path, str])
 2614:     def test_save_load_memmap_readwrite(self, filename_type):
 2615:         with temppath(suffix='.npy') as path:
 2616:             path = filename_type(path)
 2617:             a = np.array([[1, 2], [3, 4]], int)
 2618:             np.save(path, a)
 2619:             b = np.load(path, mmap_mode='r+')
 2620:             a[0][0] = 5
 2621:             b[0][0] = 5
 2622:             del b  # closes the file
 2623:             if IS_PYPY:
 2624:                 break_cycles()
 2625:                 break_cycles()
 2626:             data = np.load(path)
 2627:             assert_array_equal(data, a)
 2628: 
 2629:     @pytest.mark.parametrize("filename_type", [Path, str])
 2630:     def test_savez_load(self, filename_type):
 2631:         with temppath(suffix='.npz') as path:
 2632:             path = filename_type(path)
 2633:             np.savez(path, lab='place holder')
 2634:             with np.load(path) as data:
 2635:                 assert_array_equal(data['lab'], 'place holder')
 2636: 
 2637:     @pytest.mark.parametrize("filename_type", [Path, str])
 2638:     def test_savez_compressed_load(self, filename_type):
 2639:         with temppath(suffix='.npz') as path:
 2640:             path = filename_type(path)
 2641:             np.savez_compressed(path, lab='place holder')
 2642:             data = np.load(path)
 2643:             assert_array_equal(data['lab'], 'place holder')
 2644:             data.close()
 2645: 
 2646:     @pytest.mark.parametrize("filename_type", [Path, str])
 2647:     def test_genfromtxt(self, filename_type):
 2648:         with temppath(suffix='.txt') as path:
 2649:             path = filename_type(path)
 2650:             a = np.array([(1, 2), (3, 4)])
 2651:             np.savetxt(path, a)
 2652:             data = np.genfromtxt(path)
 2653:             assert_array_equal(a, data)
 2654: 
 2655:     @pytest.mark.parametrize("filename_type", [Path, str])
 2656:     @pytest.mark.filterwarnings("ignore:.*recfromtxt.*:DeprecationWarning")
 2657:     def test_recfromtxt(self, filename_type):
 2658:         with temppath(suffix='.txt') as path:
 2659:             path = filename_type(path)
 2660:             with open(path, 'w') as f:
 2661:                 f.write('A,B\n0,1\n2,3')
 2662: 
 2663:             kwargs = {"delimiter": ",", "missing_values": "N/A", "names": True}
 2664:             test = recfromtxt(path, **kwargs)
 2665:             control = np.array([(0, 1), (2, 3)],
 2666:                                dtype=[('A', int), ('B', int)])
 2667:             assert_(isinstance(test, np.recarray))
 2668:             assert_equal(test, control)
 2669: 
 2670:     @pytest.mark.parametrize("filename_type", [Path, str])
 2671:     @pytest.mark.filterwarnings("ignore:.*recfromcsv.*:DeprecationWarning")
 2672:     def test_recfromcsv(self, filename_type):
 2673:         with temppath(suffix='.txt') as path:
 2674:             path = filename_type(path)
 2675:             with open(path, 'w') as f:
 2676:                 f.write('A,B\n0,1\n2,3')
 2677: 
 2678:             kwargs = {
 2679:                 "missing_values": "N/A", "names": True, "case_sensitive": True
 2680:             }
 2681:             test = recfromcsv(path, dtype=None, **kwargs)
 2682:             control = np.array([(0, 1), (2, 3)],
 2683:                                dtype=[('A', int), ('B', int)])
 2684:             assert_(isinstance(test, np.recarray))
 2685:             assert_equal(test, control)
 2686: 
 2687: 
 2688: def test_gzip_load():
 2689:     a = np.random.random((5, 5))
 2690: 
 2691:     s = BytesIO()
 2692:     f = gzip.GzipFile(fileobj=s, mode="w")
 2693: 
 2694:     np.save(f, a)
 2695:     f.close()
 2696:     s.seek(0)
 2697: 
 2698:     f = gzip.GzipFile(fileobj=s, mode="r")
 2699:     assert_array_equal(np.load(f), a)
 2700: 
 2701: 
 2702: # These next two classes encode the minimal API needed to save()/load() arrays.
 2703: # The `test_ducktyping` ensures they work correctly
 2704: class JustWriter:
 2705:     def __init__(self, base):
 2706:         self.base = base
 2707: 
 2708:     def write(self, s):
 2709:         return self.base.write(s)
 2710: 
 2711:     def flush(self):
 2712:         return self.base.flush()
 2713: 
 2714: class JustReader:
 2715:     def __init__(self, base):
 2716:         self.base = base
 2717: 
 2718:     def read(self, n):
 2719:         return self.base.read(n)
 2720: 
 2721:     def seek(self, off, whence=0):
 2722:         return self.base.seek(off, whence)
 2723: 
 2724: 
 2725: def test_ducktyping():
 2726:     a = np.random.random((5, 5))
 2727: 
 2728:     s = BytesIO()
 2729:     f = JustWriter(s)
 2730: 
 2731:     np.save(f, a)
 2732:     f.flush()
 2733:     s.seek(0)
 2734: 
 2735:     f = JustReader(s)
 2736:     assert_array_equal(np.load(f), a)
 2737: 
 2738: 
 2739: def test_gzip_loadtxt():
 2740:     # Thanks to another windows brokenness, we can't use
 2741:     # NamedTemporaryFile: a file created from this function cannot be
 2742:     # reopened by another open call. So we first put the gzipped string
 2743:     # of the test reference array, write it to a securely opened file,
 2744:     # which is then read from by the loadtxt function
 2745:     s = BytesIO()
 2746:     g = gzip.GzipFile(fileobj=s, mode='w')
 2747:     g.write(b'1 2 3\n')
 2748:     g.close()
 2749: 
 2750:     s.seek(0)
 2751:     with temppath(suffix='.gz') as name:
 2752:         with open(name, 'wb') as f:
 2753:             f.write(s.read())
 2754:         res = np.loadtxt(name)
 2755:     s.close()
 2756: 
 2757:     assert_array_equal(res, [1, 2, 3])
 2758: 
 2759: 
 2760: def test_gzip_loadtxt_from_string():
 2761:     s = BytesIO()
 2762:     f = gzip.GzipFile(fileobj=s, mode="w")
 2763:     f.write(b'1 2 3\n')
 2764:     f.close()
 2765:     s.seek(0)
 2766: 
 2767:     f = gzip.GzipFile(fileobj=s, mode="r")
 2768:     assert_array_equal(np.loadtxt(f), [1, 2, 3])
 2769: 
 2770: 
 2771: def test_npzfile_dict():
 2772:     s = BytesIO()
 2773:     x = np.zeros((3, 3))
 2774:     y = np.zeros((3, 3))
 2775: 
 2776:     np.savez(s, x=x, y=y)
 2777:     s.seek(0)
 2778: 
 2779:     z = np.load(s)
 2780: 
 2781:     assert_('x' in z)
 2782:     assert_('y' in z)
 2783:     assert_('x' in z.keys())
 2784:     assert_('y' in z.keys())
 2785: 
 2786:     for f, a in z.items():
 2787:         assert_(f in ['x', 'y'])
 2788:         assert_equal(a.shape, (3, 3))
 2789: 
 2790:     for a in z.values():
 2791:         assert_equal(a.shape, (3, 3))
 2792: 
 2793:     assert_(len(z.items()) == 2)
 2794: 
 2795:     for f in z:
 2796:         assert_(f in ['x', 'y'])
 2797: 
 2798:     assert_('x' in z.keys())
 2799:     assert (z.get('x') == z['x']).all()
 2800: 
 2801: 
 2802: @pytest.mark.skipif(not HAS_REFCOUNT, reason="Python lacks refcounts")
 2803: def test_load_refcount():
 2804:     # Check that objects returned by np.load are directly freed based on
 2805:     # their refcount, rather than needing the gc to collect them.
 2806: 
 2807:     f = BytesIO()
 2808:     np.savez(f, [1, 2, 3])
 2809:     f.seek(0)
 2810: 
 2811:     with assert_no_gc_cycles():
 2812:         np.load(f)
 2813: 
 2814:     f.seek(0)
 2815:     dt = [("a", 'u1', 2), ("b", 'u1', 2)]
 2816:     with assert_no_gc_cycles():
 2817:         x = np.loadtxt(TextIO("0 1 2 3"), dtype=dt)
 2818:         assert_equal(x, np.array([((0, 1), (2, 3))], dtype=dt))
 2819: 
 2820: 
 2821: def test_load_multiple_arrays_until_eof():
 2822:     f = BytesIO()
 2823:     np.save(f, 1)
 2824:     np.save(f, 2)
 2825:     f.seek(0)
 2826:     out1 = np.load(f)
 2827:     assert out1 == 1
 2828:     out2 = np.load(f)
 2829:     assert out2 == 2
 2830:     with pytest.raises(EOFError):
 2831:         np.load(f)
 2832: 
 2833: 
 2834: def test_savez_nopickle():
 2835:     obj_array = np.array([1, 'hello'], dtype=object)
 2836:     with temppath(suffix='.npz') as tmp:
 2837:         np.savez(tmp, obj_array)
 2838: 
 2839:     with temppath(suffix='.npz') as tmp:
 2840:         with pytest.raises(ValueError, match="Object arrays cannot be saved when.*"):
 2841:             np.savez(tmp, obj_array, allow_pickle=False)
 2842: 
 2843:     with temppath(suffix='.npz') as tmp:
 2844:         np.savez_compressed(tmp, obj_array)
 2845: 
 2846:     with temppath(suffix='.npz') as tmp:
 2847:         with pytest.raises(ValueError, match="Object arrays cannot be saved when.*"):
 2848:             np.savez_compressed(tmp, obj_array, allow_pickle=False)
