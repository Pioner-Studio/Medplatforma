    1: import pytest
    2: 
    3: import numpy as np
    4: from numpy.lib._index_tricks_impl import (
    5:     c_,
    6:     diag_indices,
    7:     diag_indices_from,
    8:     fill_diagonal,
    9:     index_exp,
   10:     ix_,
   11:     mgrid,
   12:     ndenumerate,
   13:     ndindex,
   14:     ogrid,
   15:     r_,
   16:     s_,
   17: )
   18: from numpy.testing import (
   19:     assert_,
   20:     assert_almost_equal,
   21:     assert_array_almost_equal,
   22:     assert_array_equal,
   23:     assert_equal,
   24:     assert_raises,
   25:     assert_raises_regex,
   26: )
   27: 
   28: 
   29: class TestRavelUnravelIndex:
   30:     def test_basic(self):
   31:         assert_equal(np.unravel_index(2, (2, 2)), (1, 0))
   32: 
   33:         # test that new shape argument works properly
   34:         assert_equal(np.unravel_index(indices=2,
   35:                                       shape=(2, 2)),
   36:                                       (1, 0))
   37: 
   38:         # test that an invalid second keyword argument
   39:         # is properly handled, including the old name `dims`.
   40:         with assert_raises(TypeError):
   41:             np.unravel_index(indices=2, hape=(2, 2))
   42: 
   43:         with assert_raises(TypeError):
   44:             np.unravel_index(2, hape=(2, 2))
   45: 
   46:         with assert_raises(TypeError):
   47:             np.unravel_index(254, ims=(17, 94))
   48: 
   49:         with assert_raises(TypeError):
   50:             np.unravel_index(254, dims=(17, 94))
   51: 
   52:         assert_equal(np.ravel_multi_index((1, 0), (2, 2)), 2)
   53:         assert_equal(np.unravel_index(254, (17, 94)), (2, 66))
   54:         assert_equal(np.ravel_multi_index((2, 66), (17, 94)), 254)
   55:         assert_raises(ValueError, np.unravel_index, -1, (2, 2))
   56:         assert_raises(TypeError, np.unravel_index, 0.5, (2, 2))
   57:         assert_raises(ValueError, np.unravel_index, 4, (2, 2))
   58:         assert_raises(ValueError, np.ravel_multi_index, (-3, 1), (2, 2))
   59:         assert_raises(ValueError, np.ravel_multi_index, (2, 1), (2, 2))
   60:         assert_raises(ValueError, np.ravel_multi_index, (0, -3), (2, 2))
   61:         assert_raises(ValueError, np.ravel_multi_index, (0, 2), (2, 2))
   62:         assert_raises(TypeError, np.ravel_multi_index, (0.1, 0.), (2, 2))
   63: 
   64:         assert_equal(np.unravel_index((2 * 3 + 1) * 6 + 4, (4, 3, 6)), [2, 1, 4])
   65:         assert_equal(
   66:             np.ravel_multi_index([2, 1, 4], (4, 3, 6)), (2 * 3 + 1) * 6 + 4)
   67: 
   68:         arr = np.array([[3, 6, 6], [4, 5, 1]])
   69:         assert_equal(np.ravel_multi_index(arr, (7, 6)), [22, 41, 37])
   70:         assert_equal(
   71:             np.ravel_multi_index(arr, (7, 6), order='F'), [31, 41, 13])
   72:         assert_equal(
   73:             np.ravel_multi_index(arr, (4, 6), mode='clip'), [22, 23, 19])
   74:         assert_equal(np.ravel_multi_index(arr, (4, 4), mode=('clip', 'wrap')),
   75:                      [12, 13, 13])
   76:         assert_equal(np.ravel_multi_index((3, 1, 4, 1), (6, 7, 8, 9)), 1621)
   77: 
   78:         assert_equal(np.unravel_index(np.array([22, 41, 37]), (7, 6)),
   79:                      [[3, 6, 6], [4, 5, 1]])
   80:         assert_equal(
   81:             np.unravel_index(np.array([31, 41, 13]), (7, 6), order='F'),
   82:             [[3, 6, 6], [4, 5, 1]])
   83:         assert_equal(np.unravel_index(1621, (6, 7, 8, 9)), [3, 1, 4, 1])
   84: 
   85:     def test_empty_indices(self):
   86:         msg1 = 'indices must be integral: the provided empty sequence was'
   87:         msg2 = 'only int indices permitted'
   88:         assert_raises_regex(TypeError, msg1, np.unravel_index, [], (10, 3, 5))
   89:         assert_raises_regex(TypeError, msg1, np.unravel_index, (), (10, 3, 5))
   90:         assert_raises_regex(TypeError, msg2, np.unravel_index, np.array([]),
   91:                             (10, 3, 5))
   92:         assert_equal(np.unravel_index(np.array([], dtype=int), (10, 3, 5)),
   93:                      [[], [], []])
   94:         assert_raises_regex(TypeError, msg1, np.ravel_multi_index, ([], []),
   95:                             (10, 3))
   96:         assert_raises_regex(TypeError, msg1, np.ravel_multi_index, ([], ['abc']),
   97:                             (10, 3))
   98:         assert_raises_regex(TypeError, msg2, np.ravel_multi_index,
   99:                     (np.array([]), np.array([])), (5, 3))
  100:         assert_equal(np.ravel_multi_index(
  101:                 (np.array([], dtype=int), np.array([], dtype=int)), (5, 3)), [])
  102:         assert_equal(np.ravel_multi_index(np.array([[], []], dtype=int),
  103:                      (5, 3)), [])
  104: 
  105:     def test_big_indices(self):
  106:         # ravel_multi_index for big indices (issue #7546)
  107:         if np.intp == np.int64:
  108:             arr = ([1, 29], [3, 5], [3, 117], [19, 2],
  109:                    [2379, 1284], [2, 2], [0, 1])
  110:             assert_equal(
  111:                 np.ravel_multi_index(arr, (41, 7, 120, 36, 2706, 8, 6)),
  112:                 [5627771580, 117259570957])
  113: 
  114:         # test unravel_index for big indices (issue #9538)
  115:         assert_raises(ValueError, np.unravel_index, 1, (2**32 - 1, 2**31 + 1))
  116: 
  117:         # test overflow checking for too big array (issue #7546)
  118:         dummy_arr = ([0], [0])
  119:         half_max = np.iinfo(np.intp).max // 2
  120:         assert_equal(
  121:             np.ravel_multi_index(dummy_arr, (half_max, 2)), [0])
  122:         assert_raises(ValueError,
  123:             np.ravel_multi_index, dummy_arr, (half_max + 1, 2))
  124:         assert_equal(
  125:             np.ravel_multi_index(dummy_arr, (half_max, 2), order='F'), [0])
  126:         assert_raises(ValueError,
  127:             np.ravel_multi_index, dummy_arr, (half_max + 1, 2), order='F')
  128: 
  129:     def test_dtypes(self):
  130:         # Test with different data types
  131:         for dtype in [np.int16, np.uint16, np.int32,
  132:                       np.uint32, np.int64, np.uint64]:
  133:             coords = np.array(
  134:                 [[1, 0, 1, 2, 3, 4], [1, 6, 1, 3, 2, 0]], dtype=dtype)
  135:             shape = (5, 8)
  136:             uncoords = 8 * coords[0] + coords[1]
  137:             assert_equal(np.ravel_multi_index(coords, shape), uncoords)
  138:             assert_equal(coords, np.unravel_index(uncoords, shape))
  139:             uncoords = coords[0] + 5 * coords[1]
  140:             assert_equal(
  141:                 np.ravel_multi_index(coords, shape, order='F'), uncoords)
  142:             assert_equal(coords, np.unravel_index(uncoords, shape, order='F'))
  143: 
  144:             coords = np.array(
  145:                 [[1, 0, 1, 2, 3, 4], [1, 6, 1, 3, 2, 0], [1, 3, 1, 0, 9, 5]],
  146:                 dtype=dtype)
  147:             shape = (5, 8, 10)
  148:             uncoords = 10 * (8 * coords[0] + coords[1]) + coords[2]
  149:             assert_equal(np.ravel_multi_index(coords, shape), uncoords)
  150:             assert_equal(coords, np.unravel_index(uncoords, shape))
  151:             uncoords = coords[0] + 5 * (coords[1] + 8 * coords[2])
  152:             assert_equal(
  153:                 np.ravel_multi_index(coords, shape, order='F'), uncoords)
  154:             assert_equal(coords, np.unravel_index(uncoords, shape, order='F'))
  155: 
  156:     def test_clipmodes(self):
  157:         # Test clipmodes
  158:         assert_equal(
  159:             np.ravel_multi_index([5, 1, -1, 2], (4, 3, 7, 12), mode='wrap'),
  160:             np.ravel_multi_index([1, 1, 6, 2], (4, 3, 7, 12)))
  161:         assert_equal(np.ravel_multi_index([5, 1, -1, 2], (4, 3, 7, 12),
  162:                                           mode=(
  163:                                               'wrap', 'raise', 'clip', 'raise')),
  164:                      np.ravel_multi_index([1, 1, 0, 2], (4, 3, 7, 12)))
  165:         assert_raises(
  166:             ValueError, np.ravel_multi_index, [5, 1, -1, 2], (4, 3, 7, 12))
  167: 
  168:     def test_writeability(self):
  169:         # gh-7269
  170:         x, y = np.unravel_index([1, 2, 3], (4, 5))
  171:         assert_(x.flags.writeable)
  172:         assert_(y.flags.writeable)
  173: 
  174:     def test_0d(self):
  175:         # gh-580
  176:         x = np.unravel_index(0, ())
  177:         assert_equal(x, ())
  178: 
  179:         assert_raises_regex(ValueError, "0d array", np.unravel_index, [0], ())
  180:         assert_raises_regex(
  181:             ValueError, "out of bounds", np.unravel_index, [1], ())
  182: 
  183:     @pytest.mark.parametrize("mode", ["clip", "wrap", "raise"])
  184:     def test_empty_array_ravel(self, mode):
  185:         res = np.ravel_multi_index(
  186:                     np.zeros((3, 0), dtype=np.intp), (2, 1, 0), mode=mode)
  187:         assert res.shape == (0,)
  188: 
  189:         with assert_raises(ValueError):
  190:             np.ravel_multi_index(
  191:                     np.zeros((3, 1), dtype=np.intp), (2, 1, 0), mode=mode)
  192: 
  193:     def test_empty_array_unravel(self):
  194:         res = np.unravel_index(np.zeros(0, dtype=np.intp), (2, 1, 0))
  195:         # res is a tuple of three empty arrays
  196:         assert len(res) == 3
  197:         assert all(a.shape == (0,) for a in res)
  198: 
  199:         with assert_raises(ValueError):
  200:             np.unravel_index([1], (2, 1, 0))
  201: 
  202: class TestGrid:
  203:     def test_basic(self):
  204:         a = mgrid[-1:1:10j]
  205:         b = mgrid[-1:1:0.1]
  206:         assert_(a.shape == (10,))
  207:         assert_(b.shape == (20,))
  208:         assert_(a[0] == -1)
  209:         assert_almost_equal(a[-1], 1)
  210:         assert_(b[0] == -1)
  211:         assert_almost_equal(b[1] - b[0], 0.1, 11)
  212:         assert_almost_equal(b[-1], b[0] + 19 * 0.1, 11)
  213:         assert_almost_equal(a[1] - a[0], 2.0 / 9.0, 11)
  214: 
  215:     def test_linspace_equivalence(self):
  216:         y, st = np.linspace(2, 10, retstep=True)
  217:         assert_almost_equal(st, 8 / 49.0)
  218:         assert_array_almost_equal(y, mgrid[2:10:50j], 13)
  219: 
  220:     def test_nd(self):
  221:         c = mgrid[-1:1:10j, -2:2:10j]
  222:         d = mgrid[-1:1:0.1, -2:2:0.2]
  223:         assert_(c.shape == (2, 10, 10))
  224:         assert_(d.shape == (2, 20, 20))
  225:         assert_array_equal(c[0][0, :], -np.ones(10, 'd'))
  226:         assert_array_equal(c[1][:, 0], -2 * np.ones(10, 'd'))
  227:         assert_array_almost_equal(c[0][-1, :], np.ones(10, 'd'), 11)
  228:         assert_array_almost_equal(c[1][:, -1], 2 * np.ones(10, 'd'), 11)
  229:         assert_array_almost_equal(d[0, 1, :] - d[0, 0, :],
  230:                                   0.1 * np.ones(20, 'd'), 11)
  231:         assert_array_almost_equal(d[1, :, 1] - d[1, :, 0],
  232:                                   0.2 * np.ones(20, 'd'), 11)
  233: 
  234:     def test_sparse(self):
  235:         grid_full = mgrid[-1:1:10j, -2:2:10j]
  236:         grid_sparse = ogrid[-1:1:10j, -2:2:10j]
  237: 
  238:         # sparse grids can be made dense by broadcasting
  239:         grid_broadcast = np.broadcast_arrays(*grid_sparse)
  240:         for f, b in zip(grid_full, grid_broadcast):
  241:             assert_equal(f, b)
  242: 
  243:     @pytest.mark.parametrize("start, stop, step, expected", [
  244:         (None, 10, 10j, (200, 10)),
  245:         (-10, 20, None, (1800, 30)),
  246:         ])
  247:     def test_mgrid_size_none_handling(self, start, stop, step, expected):
  248:         # regression test None value handling for
  249:         # start and step values used by mgrid;
  250:         # internally, this aims to cover previously
  251:         # unexplored code paths in nd_grid()
  252:         grid = mgrid[start:stop:step, start:stop:step]
  253:         # need a smaller grid to explore one of the
  254:         # untested code paths
  255:         grid_small = mgrid[start:stop:step]
  256:         assert_equal(grid.size, expected[0])
  257:         assert_equal(grid_small.size, expected[1])
  258: 
  259:     def test_accepts_npfloating(self):
  260:         # regression test for #16466
  261:         grid64 = mgrid[0.1:0.33:0.1, ]
  262:         grid32 = mgrid[np.float32(0.1):np.float32(0.33):np.float32(0.1), ]
  263:         assert_array_almost_equal(grid64, grid32)
  264:         # At some point this was float64, but NEP 50 changed it:
  265:         assert grid32.dtype == np.float32
  266:         assert grid64.dtype == np.float64
  267: 
  268:         # different code path for single slice
  269:         grid64 = mgrid[0.1:0.33:0.1]
  270:         grid32 = mgrid[np.float32(0.1):np.float32(0.33):np.float32(0.1)]
  271:         assert_(grid32.dtype == np.float64)
  272:         assert_array_almost_equal(grid64, grid32)
  273: 
  274:     def test_accepts_longdouble(self):
  275:         # regression tests for #16945
  276:         grid64 = mgrid[0.1:0.33:0.1, ]
  277:         grid128 = mgrid[
  278:             np.longdouble(0.1):np.longdouble(0.33):np.longdouble(0.1),
  279:         ]
  280:         assert_(grid128.dtype == np.longdouble)
  281:         assert_array_almost_equal(grid64, grid128)
  282: 
  283:         grid128c_a = mgrid[0:np.longdouble(1):3.4j]
  284:         grid128c_b = mgrid[0:np.longdouble(1):3.4j, ]
  285:         assert_(grid128c_a.dtype == grid128c_b.dtype == np.longdouble)
  286:         assert_array_equal(grid128c_a, grid128c_b[0])
  287: 
  288:         # different code path for single slice
  289:         grid64 = mgrid[0.1:0.33:0.1]
  290:         grid128 = mgrid[
  291:             np.longdouble(0.1):np.longdouble(0.33):np.longdouble(0.1)
  292:         ]
  293:         assert_(grid128.dtype == np.longdouble)
  294:         assert_array_almost_equal(grid64, grid128)
  295: 
  296:     def test_accepts_npcomplexfloating(self):
  297:         # Related to #16466
  298:         assert_array_almost_equal(
  299:             mgrid[0.1:0.3:3j, ], mgrid[0.1:0.3:np.complex64(3j), ]
  300:         )
  301: 
  302:         # different code path for single slice
  303:         assert_array_almost_equal(
  304:             mgrid[0.1:0.3:3j], mgrid[0.1:0.3:np.complex64(3j)]
  305:         )
  306: 
  307:         # Related to #16945
  308:         grid64_a = mgrid[0.1:0.3:3.3j]
  309:         grid64_b = mgrid[0.1:0.3:3.3j, ][0]
  310:         assert_(grid64_a.dtype == grid64_b.dtype == np.float64)
  311:         assert_array_equal(grid64_a, grid64_b)
  312: 
  313:         grid128_a = mgrid[0.1:0.3:np.clongdouble(3.3j)]
  314:         grid128_b = mgrid[0.1:0.3:np.clongdouble(3.3j), ][0]
  315:         assert_(grid128_a.dtype == grid128_b.dtype == np.longdouble)
  316:         assert_array_equal(grid64_a, grid64_b)
  317: 
  318: 
  319: class TestConcatenator:
  320:     def test_1d(self):
  321:         assert_array_equal(r_[1, 2, 3, 4, 5, 6], np.array([1, 2, 3, 4, 5, 6]))
  322:         b = np.ones(5)
  323:         c = r_[b, 0, 0, b]
  324:         assert_array_equal(c, [1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1])
  325: 
  326:     def test_mixed_type(self):
  327:         g = r_[10.1, 1:10]
  328:         assert_(g.dtype == 'f8')
  329: 
  330:     def test_more_mixed_type(self):
  331:         g = r_[-10.1, np.array([1]), np.array([2, 3, 4]), 10.0]
  332:         assert_(g.dtype == 'f8')
  333: 
  334:     def test_complex_step(self):
  335:         # Regression test for #12262
  336:         g = r_[0:36:100j]
  337:         assert_(g.shape == (100,))
  338: 
  339:         # Related to #16466
  340:         g = r_[0:36:np.complex64(100j)]
  341:         assert_(g.shape == (100,))
  342: 
  343:     def test_2d(self):
  344:         b = np.random.rand(5, 5)
  345:         c = np.random.rand(5, 5)
  346:         d = r_['1', b, c]  # append columns
  347:         assert_(d.shape == (5, 10))
  348:         assert_array_equal(d[:, :5], b)
  349:         assert_array_equal(d[:, 5:], c)
  350:         d = r_[b, c]
  351:         assert_(d.shape == (10, 5))
  352:         assert_array_equal(d[:5, :], b)
  353:         assert_array_equal(d[5:, :], c)
  354: 
  355:     def test_0d(self):
  356:         assert_equal(r_[0, np.array(1), 2], [0, 1, 2])
  357:         assert_equal(r_[[0, 1, 2], np.array(3)], [0, 1, 2, 3])
  358:         assert_equal(r_[np.array(0), [1, 2, 3]], [0, 1, 2, 3])
  359: 
  360: 
  361: class TestNdenumerate:
  362:     def test_basic(self):
  363:         a = np.array([[1, 2], [3, 4]])
  364:         assert_equal(list(ndenumerate(a)),
  365:                      [((0, 0), 1), ((0, 1), 2), ((1, 0), 3), ((1, 1), 4)])
  366: 
  367: 
  368: class TestIndexExpression:
  369:     def test_regression_1(self):
  370:         # ticket #1196
  371:         a = np.arange(2)
  372:         assert_equal(a[:-1], a[s_[:-1]])
  373:         assert_equal(a[:-1], a[index_exp[:-1]])
  374: 
  375:     def test_simple_1(self):
  376:         a = np.random.rand(4, 5, 6)
  377: 
  378:         assert_equal(a[:, :3, [1, 2]], a[index_exp[:, :3, [1, 2]]])
  379:         assert_equal(a[:, :3, [1, 2]], a[s_[:, :3, [1, 2]]])
  380: 
  381: 
  382: class TestIx_:
  383:     def test_regression_1(self):
  384:         # Test empty untyped inputs create outputs of indexing type, gh-5804
  385:         a, = np.ix_(range(0))
  386:         assert_equal(a.dtype, np.intp)
  387: 
  388:         a, = np.ix_([])
  389:         assert_equal(a.dtype, np.intp)
  390: 
  391:         # but if the type is specified, don't change it
  392:         a, = np.ix_(np.array([], dtype=np.float32))
  393:         assert_equal(a.dtype, np.float32)
  394: 
  395:     def test_shape_and_dtype(self):
  396:         sizes = (4, 5, 3, 2)
  397:         # Test both lists and arrays
  398:         for func in (range, np.arange):
  399:             arrays = np.ix_(*[func(sz) for sz in sizes])
  400:             for k, (a, sz) in enumerate(zip(arrays, sizes)):
  401:                 assert_equal(a.shape[k], sz)
  402:                 assert_(all(sh == 1 for j, sh in enumerate(a.shape) if j != k))
  403:                 assert_(np.issubdtype(a.dtype, np.integer))
  404: 
  405:     def test_bool(self):
  406:         bool_a = [True, False, True, True]
  407:         int_a, = np.nonzero(bool_a)
  408:         assert_equal(np.ix_(bool_a)[0], int_a)
  409: 
  410:     def test_1d_only(self):
  411:         idx2d = [[1, 2, 3], [4, 5, 6]]
  412:         assert_raises(ValueError, np.ix_, idx2d)
  413: 
  414:     def test_repeated_input(self):
  415:         length_of_vector = 5
  416:         x = np.arange(length_of_vector)
  417:         out = ix_(x, x)
  418:         assert_equal(out[0].shape, (length_of_vector, 1))
  419:         assert_equal(out[1].shape, (1, length_of_vector))
  420:         # check that input shape is not modified
  421:         assert_equal(x.shape, (length_of_vector,))
  422: 
  423: 
  424: def test_c_():
  425:     a = c_[np.array([[1, 2, 3]]), 0, 0, np.array([[4, 5, 6]])]
  426:     assert_equal(a, [[1, 2, 3, 0, 0, 4, 5, 6]])
  427: 
  428: 
  429: class TestFillDiagonal:
  430:     def test_basic(self):
  431:         a = np.zeros((3, 3), int)
  432:         fill_diagonal(a, 5)
  433:         assert_array_equal(
  434:             a, np.array([[5, 0, 0],
  435:                          [0, 5, 0],
  436:                          [0, 0, 5]])
  437:             )
  438: 
  439:     def test_tall_matrix(self):
  440:         a = np.zeros((10, 3), int)
  441:         fill_diagonal(a, 5)
  442:         assert_array_equal(
  443:             a, np.array([[5, 0, 0],
  444:                          [0, 5, 0],
  445:                          [0, 0, 5],
  446:                          [0, 0, 0],
  447:                          [0, 0, 0],
  448:                          [0, 0, 0],
  449:                          [0, 0, 0],
  450:                          [0, 0, 0],
  451:                          [0, 0, 0],
  452:                          [0, 0, 0]])
  453:             )
  454: 
  455:     def test_tall_matrix_wrap(self):
  456:         a = np.zeros((10, 3), int)
  457:         fill_diagonal(a, 5, True)
  458:         assert_array_equal(
  459:             a, np.array([[5, 0, 0],
  460:                          [0, 5, 0],
  461:                          [0, 0, 5],
  462:                          [0, 0, 0],
  463:                          [5, 0, 0],
  464:                          [0, 5, 0],
  465:                          [0, 0, 5],
  466:                          [0, 0, 0],
  467:                          [5, 0, 0],
  468:                          [0, 5, 0]])
  469:             )
  470: 
  471:     def test_wide_matrix(self):
  472:         a = np.zeros((3, 10), int)
  473:         fill_diagonal(a, 5)
  474:         assert_array_equal(
  475:             a, np.array([[5, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  476:                          [0, 5, 0, 0, 0, 0, 0, 0, 0, 0],
  477:                          [0, 0, 5, 0, 0, 0, 0, 0, 0, 0]])
  478:             )
  479: 
  480:     def test_operate_4d_array(self):
  481:         a = np.zeros((3, 3, 3, 3), int)
  482:         fill_diagonal(a, 4)
  483:         i = np.array([0, 1, 2])
  484:         assert_equal(np.where(a != 0), (i, i, i, i))
  485: 
  486:     def test_low_dim_handling(self):
  487:         # raise error with low dimensionality
  488:         a = np.zeros(3, int)
  489:         with assert_raises_regex(ValueError, "at least 2-d"):
  490:             fill_diagonal(a, 5)
  491: 
  492:     def test_hetero_shape_handling(self):
  493:         # raise error with high dimensionality and
  494:         # shape mismatch
  495:         a = np.zeros((3, 3, 7, 3), int)
  496:         with assert_raises_regex(ValueError, "equal length"):
  497:             fill_diagonal(a, 2)
  498: 
  499: 
  500: def test_diag_indices():
  501:     di = diag_indices(4)
  502:     a = np.array([[1, 2, 3, 4],
  503:                   [5, 6, 7, 8],
  504:                   [9, 10, 11, 12],
  505:                   [13, 14, 15, 16]])
  506:     a[di] = 100
  507:     assert_array_equal(
  508:         a, np.array([[100, 2, 3, 4],
  509:                      [5, 100, 7, 8],
  510:                      [9, 10, 100, 12],
  511:                      [13, 14, 15, 100]])
  512:         )
  513: 
  514:     # Now, we create indices to manipulate a 3-d array:
  515:     d3 = diag_indices(2, 3)
  516: 
  517:     # And use it to set the diagonal of a zeros array to 1:
  518:     a = np.zeros((2, 2, 2), int)
  519:     a[d3] = 1
  520:     assert_array_equal(
  521:         a, np.array([[[1, 0],
  522:                       [0, 0]],
  523:                      [[0, 0],
  524:                       [0, 1]]])
  525:         )
  526: 
  527: 
  528: class TestDiagIndicesFrom:
  529: 
  530:     def test_diag_indices_from(self):
  531:         x = np.random.random((4, 4))
  532:         r, c = diag_indices_from(x)
  533:         assert_array_equal(r, np.arange(4))
  534:         assert_array_equal(c, np.arange(4))
  535: 
  536:     def test_error_small_input(self):
  537:         x = np.ones(7)
  538:         with assert_raises_regex(ValueError, "at least 2-d"):
  539:             diag_indices_from(x)
  540: 
  541:     def test_error_shape_mismatch(self):
  542:         x = np.zeros((3, 3, 2, 3), int)
  543:         with assert_raises_regex(ValueError, "equal length"):
  544:             diag_indices_from(x)
  545: 
  546: 
  547: def test_ndindex():
  548:     x = list(ndindex(1, 2, 3))
  549:     expected = [ix for ix, e in ndenumerate(np.zeros((1, 2, 3)))]
  550:     assert_array_equal(x, expected)
  551: 
  552:     x = list(ndindex((1, 2, 3)))
  553:     assert_array_equal(x, expected)
  554: 
  555:     # Test use of scalars and tuples
  556:     x = list(ndindex((3,)))
  557:     assert_array_equal(x, list(ndindex(3)))
  558: 
  559:     # Make sure size argument is optional
  560:     x = list(ndindex())
  561:     assert_equal(x, [()])
  562: 
  563:     x = list(ndindex(()))
  564:     assert_equal(x, [()])
  565: 
  566:     # Make sure 0-sized ndindex works correctly
  567:     x = list(ndindex(*[0]))
  568:     assert_equal(x, [])
