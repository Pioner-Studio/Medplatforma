    1: import pytest
    2: 
    3: import numpy as np
    4: from numpy import histogram, histogram_bin_edges, histogramdd
    5: from numpy.testing import (
    6:     assert_,
    7:     assert_allclose,
    8:     assert_almost_equal,
    9:     assert_array_almost_equal,
   10:     assert_array_equal,
   11:     assert_array_max_ulp,
   12:     assert_equal,
   13:     assert_raises,
   14:     assert_raises_regex,
   15:     suppress_warnings,
   16: )
   17: 
   18: 
   19: class TestHistogram:
   20: 
   21:     def setup_method(self):
   22:         pass
   23: 
   24:     def teardown_method(self):
   25:         pass
   26: 
   27:     def test_simple(self):
   28:         n = 100
   29:         v = np.random.rand(n)
   30:         (a, b) = histogram(v)
   31:         # check if the sum of the bins equals the number of samples
   32:         assert_equal(np.sum(a, axis=0), n)
   33:         # check that the bin counts are evenly spaced when the data is from
   34:         # a linear function
   35:         (a, b) = histogram(np.linspace(0, 10, 100))
   36:         assert_array_equal(a, 10)
   37: 
   38:     def test_one_bin(self):
   39:         # Ticket 632
   40:         hist, edges = histogram([1, 2, 3, 4], [1, 2])
   41:         assert_array_equal(hist, [2, ])
   42:         assert_array_equal(edges, [1, 2])
   43:         assert_raises(ValueError, histogram, [1, 2], bins=0)
   44:         h, e = histogram([1, 2], bins=1)
   45:         assert_equal(h, np.array([2]))
   46:         assert_allclose(e, np.array([1., 2.]))
   47: 
   48:     def test_density(self):
   49:         # Check that the integral of the density equals 1.
   50:         n = 100
   51:         v = np.random.rand(n)
   52:         a, b = histogram(v, density=True)
   53:         area = np.sum(a * np.diff(b))
   54:         assert_almost_equal(area, 1)
   55: 
   56:         # Check with non-constant bin widths
   57:         v = np.arange(10)
   58:         bins = [0, 1, 3, 6, 10]
   59:         a, b = histogram(v, bins, density=True)
   60:         assert_array_equal(a, .1)
   61:         assert_equal(np.sum(a * np.diff(b)), 1)
   62: 
   63:         # Test that passing False works too
   64:         a, b = histogram(v, bins, density=False)
   65:         assert_array_equal(a, [1, 2, 3, 4])
   66: 
   67:         # Variable bin widths are especially useful to deal with
   68:         # infinities.
   69:         v = np.arange(10)
   70:         bins = [0, 1, 3, 6, np.inf]
   71:         a, b = histogram(v, bins, density=True)
   72:         assert_array_equal(a, [.1, .1, .1, 0.])
   73: 
   74:         # Taken from a bug report from N. Becker on the numpy-discussion
   75:         # mailing list Aug. 6, 2010.
   76:         counts, dmy = np.histogram(
   77:             [1, 2, 3, 4], [0.5, 1.5, np.inf], density=True)
   78:         assert_equal(counts, [.25, 0])
   79: 
   80:     def test_outliers(self):
   81:         # Check that outliers are not tallied
   82:         a = np.arange(10) + .5
   83: 
   84:         # Lower outliers
   85:         h, b = histogram(a, range=[0, 9])
   86:         assert_equal(h.sum(), 9)
   87: 
   88:         # Upper outliers
   89:         h, b = histogram(a, range=[1, 10])
   90:         assert_equal(h.sum(), 9)
   91: 
   92:         # Normalization
   93:         h, b = histogram(a, range=[1, 9], density=True)
   94:         assert_almost_equal((h * np.diff(b)).sum(), 1, decimal=15)
   95: 
   96:         # Weights
   97:         w = np.arange(10) + .5
   98:         h, b = histogram(a, range=[1, 9], weights=w, density=True)
   99:         assert_equal((h * np.diff(b)).sum(), 1)
  100: 
  101:         h, b = histogram(a, bins=8, range=[1, 9], weights=w)
  102:         assert_equal(h, w[1:-1])
  103: 
  104:     def test_arr_weights_mismatch(self):
  105:         a = np.arange(10) + .5
  106:         w = np.arange(11) + .5
  107:         with assert_raises_regex(ValueError, "same shape as"):
  108:             h, b = histogram(a, range=[1, 9], weights=w, density=True)
  109: 
  110:     def test_type(self):
  111:         # Check the type of the returned histogram
  112:         a = np.arange(10) + .5
  113:         h, b = histogram(a)
  114:         assert_(np.issubdtype(h.dtype, np.integer))
  115: 
  116:         h, b = histogram(a, density=True)
  117:         assert_(np.issubdtype(h.dtype, np.floating))
  118: 
  119:         h, b = histogram(a, weights=np.ones(10, int))
  120:         assert_(np.issubdtype(h.dtype, np.integer))
  121: 
  122:         h, b = histogram(a, weights=np.ones(10, float))
  123:         assert_(np.issubdtype(h.dtype, np.floating))
  124: 
  125:     def test_f32_rounding(self):
  126:         # gh-4799, check that the rounding of the edges works with float32
  127:         x = np.array([276.318359, -69.593948, 21.329449], dtype=np.float32)
  128:         y = np.array([5005.689453, 4481.327637, 6010.369629], dtype=np.float32)
  129:         counts_hist, xedges, yedges = np.histogram2d(x, y, bins=100)
  130:         assert_equal(counts_hist.sum(), 3.)
  131: 
  132:     def test_bool_conversion(self):
  133:         # gh-12107
  134:         # Reference integer histogram
  135:         a = np.array([1, 1, 0], dtype=np.uint8)
  136:         int_hist, int_edges = np.histogram(a)
  137: 
  138:         # Should raise an warning on booleans
  139:         # Ensure that the histograms are equivalent, need to suppress
  140:         # the warnings to get the actual outputs
  141:         with suppress_warnings() as sup:
  142:             rec = sup.record(RuntimeWarning, 'Converting input from .*')
  143:             hist, edges = np.histogram([True, True, False])
  144:             # A warning should be issued
  145:             assert_equal(len(rec), 1)
  146:             assert_array_equal(hist, int_hist)
  147:             assert_array_equal(edges, int_edges)
  148: 
  149:     def test_weights(self):
  150:         v = np.random.rand(100)
  151:         w = np.ones(100) * 5
  152:         a, b = histogram(v)
  153:         na, nb = histogram(v, density=True)
  154:         wa, wb = histogram(v, weights=w)
  155:         nwa, nwb = histogram(v, weights=w, density=True)
  156:         assert_array_almost_equal(a * 5, wa)
  157:         assert_array_almost_equal(na, nwa)
  158: 
  159:         # Check weights are properly applied.
  160:         v = np.linspace(0, 10, 10)
  161:         w = np.concatenate((np.zeros(5), np.ones(5)))
  162:         wa, wb = histogram(v, bins=np.arange(11), weights=w)
  163:         assert_array_almost_equal(wa, w)
  164: 
  165:         # Check with integer weights
  166:         wa, wb = histogram([1, 2, 2, 4], bins=4, weights=[4, 3, 2, 1])
  167:         assert_array_equal(wa, [4, 5, 0, 1])
  168:         wa, wb = histogram(
  169:             [1, 2, 2, 4], bins=4, weights=[4, 3, 2, 1], density=True)
  170:         assert_array_almost_equal(wa, np.array([4, 5, 0, 1]) / 10. / 3. * 4)
  171: 
  172:         # Check weights with non-uniform bin widths
  173:         a, b = histogram(
  174:             np.arange(9), [0, 1, 3, 6, 10],
  175:             weights=[2, 1, 1, 1, 1, 1, 1, 1, 1], density=True)
  176:         assert_almost_equal(a, [.2, .1, .1, .075])
  177: 
  178:     def test_exotic_weights(self):
  179: 
  180:         # Test the use of weights that are not integer or floats, but e.g.
  181:         # complex numbers or object types.
  182: 
  183:         # Complex weights
  184:         values = np.array([1.3, 2.5, 2.3])
  185:         weights = np.array([1, -1, 2]) + 1j * np.array([2, 1, 2])
  186: 
  187:         # Check with custom bins
  188:         wa, wb = histogram(values, bins=[0, 2, 3], weights=weights)
  189:         assert_array_almost_equal(wa, np.array([1, 1]) + 1j * np.array([2, 3]))
  190: 
  191:         # Check with even bins
  192:         wa, wb = histogram(values, bins=2, range=[1, 3], weights=weights)
  193:         assert_array_almost_equal(wa, np.array([1, 1]) + 1j * np.array([2, 3]))
  194: 
  195:         # Decimal weights
  196:         from decimal import Decimal
  197:         values = np.array([1.3, 2.5, 2.3])
  198:         weights = np.array([Decimal(1), Decimal(2), Decimal(3)])
  199: 
  200:         # Check with custom bins
  201:         wa, wb = histogram(values, bins=[0, 2, 3], weights=weights)
  202:         assert_array_almost_equal(wa, [Decimal(1), Decimal(5)])
  203: 
  204:         # Check with even bins
  205:         wa, wb = histogram(values, bins=2, range=[1, 3], weights=weights)
  206:         assert_array_almost_equal(wa, [Decimal(1), Decimal(5)])
  207: 
  208:     def test_no_side_effects(self):
  209:         # This is a regression test that ensures that values passed to
  210:         # ``histogram`` are unchanged.
  211:         values = np.array([1.3, 2.5, 2.3])
  212:         np.histogram(values, range=[-10, 10], bins=100)
  213:         assert_array_almost_equal(values, [1.3, 2.5, 2.3])
  214: 
  215:     def test_empty(self):
  216:         a, b = histogram([], bins=([0, 1]))
  217:         assert_array_equal(a, np.array([0]))
  218:         assert_array_equal(b, np.array([0, 1]))
  219: 
  220:     def test_error_binnum_type(self):
  221:         # Tests if right Error is raised if bins argument is float
  222:         vals = np.linspace(0.0, 1.0, num=100)
  223:         histogram(vals, 5)
  224:         assert_raises(TypeError, histogram, vals, 2.4)
  225: 
  226:     def test_finite_range(self):
  227:         # Normal ranges should be fine
  228:         vals = np.linspace(0.0, 1.0, num=100)
  229:         histogram(vals, range=[0.25, 0.75])
  230:         assert_raises(ValueError, histogram, vals, range=[np.nan, 0.75])
  231:         assert_raises(ValueError, histogram, vals, range=[0.25, np.inf])
  232: 
  233:     def test_invalid_range(self):
  234:         # start of range must be < end of range
  235:         vals = np.linspace(0.0, 1.0, num=100)
  236:         with assert_raises_regex(ValueError, "max must be larger than"):
  237:             np.histogram(vals, range=[0.1, 0.01])
  238: 
  239:     def test_bin_edge_cases(self):
  240:         # Ensure that floating-point computations correctly place edge cases.
  241:         arr = np.array([337, 404, 739, 806, 1007, 1811, 2012])
  242:         hist, edges = np.histogram(arr, bins=8296, range=(2, 2280))
  243:         mask = hist > 0
  244:         left_edges = edges[:-1][mask]
  245:         right_edges = edges[1:][mask]
  246:         for x, left, right in zip(arr, left_edges, right_edges):
  247:             assert_(x >= left)
  248:             assert_(x < right)
  249: 
  250:     def test_last_bin_inclusive_range(self):
  251:         arr = np.array([0.,  0.,  0.,  1.,  2.,  3.,  3.,  4.,  5.])
  252:         hist, edges = np.histogram(arr, bins=30, range=(-0.5, 5))
  253:         assert_equal(hist[-1], 1)
  254: 
  255:     def test_bin_array_dims(self):
  256:         # gracefully handle bins object > 1 dimension
  257:         vals = np.linspace(0.0, 1.0, num=100)
  258:         bins = np.array([[0, 0.5], [0.6, 1.0]])
  259:         with assert_raises_regex(ValueError, "must be 1d"):
  260:             np.histogram(vals, bins=bins)
  261: 
  262:     def test_unsigned_monotonicity_check(self):
  263:         # Ensures ValueError is raised if bins not increasing monotonically
  264:         # when bins contain unsigned values (see #9222)
  265:         arr = np.array([2])
  266:         bins = np.array([1, 3, 1], dtype='uint64')
  267:         with assert_raises(ValueError):
  268:             hist, edges = np.histogram(arr, bins=bins)
  269: 
  270:     def test_object_array_of_0d(self):
  271:         # gh-7864
  272:         assert_raises(ValueError,
  273:             histogram, [np.array(0.4) for i in range(10)] + [-np.inf])
  274:         assert_raises(ValueError,
  275:             histogram, [np.array(0.4) for i in range(10)] + [np.inf])
  276: 
  277:         # these should not crash
  278:         np.histogram([np.array(0.5) for i in range(10)] + [.500000000000002])
  279:         np.histogram([np.array(0.5) for i in range(10)] + [.5])
  280: 
  281:     def test_some_nan_values(self):
  282:         # gh-7503
  283:         one_nan = np.array([0, 1, np.nan])
  284:         all_nan = np.array([np.nan, np.nan])
  285: 
  286:         # the internal comparisons with NaN give warnings
  287:         sup = suppress_warnings()
  288:         sup.filter(RuntimeWarning)
  289:         with sup:
  290:             # can't infer range with nan
  291:             assert_raises(ValueError, histogram, one_nan, bins='auto')
  292:             assert_raises(ValueError, histogram, all_nan, bins='auto')
  293: 
  294:             # explicit range solves the problem
  295:             h, b = histogram(one_nan, bins='auto', range=(0, 1))
  296:             assert_equal(h.sum(), 2)  # nan is not counted
  297:             h, b = histogram(all_nan, bins='auto', range=(0, 1))
  298:             assert_equal(h.sum(), 0)  # nan is not counted
  299: 
  300:             # as does an explicit set of bins
  301:             h, b = histogram(one_nan, bins=[0, 1])
  302:             assert_equal(h.sum(), 2)  # nan is not counted
  303:             h, b = histogram(all_nan, bins=[0, 1])
  304:             assert_equal(h.sum(), 0)  # nan is not counted
  305: 
  306:     def test_datetime(self):
  307:         begin = np.datetime64('2000-01-01', 'D')
  308:         offsets = np.array([0, 0, 1, 1, 2, 3, 5, 10, 20])
  309:         bins = np.array([0, 2, 7, 20])
  310:         dates = begin + offsets
  311:         date_bins = begin + bins
  312: 
  313:         td = np.dtype('timedelta64[D]')
  314: 
  315:         # Results should be the same for integer offsets or datetime values.
  316:         # For now, only explicit bins are supported, since linspace does not
  317:         # work on datetimes or timedeltas
  318:         d_count, d_edge = histogram(dates, bins=date_bins)
  319:         t_count, t_edge = histogram(offsets.astype(td), bins=bins.astype(td))
  320:         i_count, i_edge = histogram(offsets, bins=bins)
  321: 
  322:         assert_equal(d_count, i_count)
  323:         assert_equal(t_count, i_count)
  324: 
  325:         assert_equal((d_edge - begin).astype(int), i_edge)
  326:         assert_equal(t_edge.astype(int), i_edge)
  327: 
  328:         assert_equal(d_edge.dtype, dates.dtype)
  329:         assert_equal(t_edge.dtype, td)
  330: 
  331:     def do_signed_overflow_bounds(self, dtype):
  332:         exponent = 8 * np.dtype(dtype).itemsize - 1
  333:         arr = np.array([-2**exponent + 4, 2**exponent - 4], dtype=dtype)
  334:         hist, e = histogram(arr, bins=2)
  335:         assert_equal(e, [-2**exponent + 4, 0, 2**exponent - 4])
  336:         assert_equal(hist, [1, 1])
  337: 
  338:     def test_signed_overflow_bounds(self):
  339:         self.do_signed_overflow_bounds(np.byte)
  340:         self.do_signed_overflow_bounds(np.short)
  341:         self.do_signed_overflow_bounds(np.intc)
  342:         self.do_signed_overflow_bounds(np.int_)
  343:         self.do_signed_overflow_bounds(np.longlong)
  344: 
  345:     def do_precision_lower_bound(self, float_small, float_large):
  346:         eps = np.finfo(float_large).eps
  347: 
  348:         arr = np.array([1.0], float_small)
  349:         range = np.array([1.0 + eps, 2.0], float_large)
  350: 
  351:         # test is looking for behavior when the bounds change between dtypes
  352:         if range.astype(float_small)[0] != 1:
  353:             return
  354: 
  355:         # previously crashed
  356:         count, x_loc = np.histogram(arr, bins=1, range=range)
  357:         assert_equal(count, [0])
  358:         assert_equal(x_loc.dtype, float_large)
  359: 
  360:     def do_precision_upper_bound(self, float_small, float_large):
  361:         eps = np.finfo(float_large).eps
  362: 
  363:         arr = np.array([1.0], float_small)
  364:         range = np.array([0.0, 1.0 - eps], float_large)
  365: 
  366:         # test is looking for behavior when the bounds change between dtypes
  367:         if range.astype(float_small)[-1] != 1:
  368:             return
  369: 
  370:         # previously crashed
  371:         count, x_loc = np.histogram(arr, bins=1, range=range)
  372:         assert_equal(count, [0])
  373: 
  374:         assert_equal(x_loc.dtype, float_large)
  375: 
  376:     def do_precision(self, float_small, float_large):
  377:         self.do_precision_lower_bound(float_small, float_large)
  378:         self.do_precision_upper_bound(float_small, float_large)
  379: 
  380:     def test_precision(self):
  381:         # not looping results in a useful stack trace upon failure
  382:         self.do_precision(np.half, np.single)
  383:         self.do_precision(np.half, np.double)
  384:         self.do_precision(np.half, np.longdouble)
  385:         self.do_precision(np.single, np.double)
  386:         self.do_precision(np.single, np.longdouble)
  387:         self.do_precision(np.double, np.longdouble)
  388: 
  389:     def test_histogram_bin_edges(self):
  390:         hist, e = histogram([1, 2, 3, 4], [1, 2])
  391:         edges = histogram_bin_edges([1, 2, 3, 4], [1, 2])
  392:         assert_array_equal(edges, e)
  393: 
  394:         arr = np.array([0.,  0.,  0.,  1.,  2.,  3.,  3.,  4.,  5.])
  395:         hist, e = histogram(arr, bins=30, range=(-0.5, 5))
  396:         edges = histogram_bin_edges(arr, bins=30, range=(-0.5, 5))
  397:         assert_array_equal(edges, e)
  398: 
  399:         hist, e = histogram(arr, bins='auto', range=(0, 1))
  400:         edges = histogram_bin_edges(arr, bins='auto', range=(0, 1))
  401:         assert_array_equal(edges, e)
  402: 
  403:     def test_small_value_range(self):
  404:         arr = np.array([1, 1 + 2e-16] * 10)
  405:         with pytest.raises(ValueError, match="Too many bins for data range"):
  406:             histogram(arr, bins=10)
  407: 
  408:     # @requires_memory(free_bytes=1e10)
  409:     # @pytest.mark.slow
  410:     @pytest.mark.skip(reason="Bad memory reports lead to OOM in ci testing")
  411:     def test_big_arrays(self):
  412:         sample = np.zeros([100000000, 3])
  413:         xbins = 400
  414:         ybins = 400
  415:         zbins = np.arange(16000)
  416:         hist = np.histogramdd(sample=sample, bins=(xbins, ybins, zbins))
  417:         assert_equal(type(hist), type((1, 2)))
  418: 
  419:     def test_gh_23110(self):
  420:         hist, e = np.histogram(np.array([-0.9e-308], dtype='>f8'),
  421:                                bins=2,
  422:                                range=(-1e-308, -2e-313))
  423:         expected_hist = np.array([1, 0])
  424:         assert_array_equal(hist, expected_hist)
  425: 
  426:     def test_gh_28400(self):
  427:         e = 1 + 1e-12
  428:         Z = [0, 1, 1, 1, 1, 1, e, e, e, e, e, e, 2]
  429:         counts, edges = np.histogram(Z, bins="auto")
  430:         assert len(counts) < 10
  431:         assert edges[0] == Z[0]
  432:         assert edges[-1] == Z[-1]
  433: 
  434: class TestHistogramOptimBinNums:
  435:     """
  436:     Provide test coverage when using provided estimators for optimal number of
  437:     bins
  438:     """
  439: 
  440:     def test_empty(self):
  441:         estimator_list = ['fd', 'scott', 'rice', 'sturges',
  442:                           'doane', 'sqrt', 'auto', 'stone']
  443:         # check it can deal with empty data
  444:         for estimator in estimator_list:
  445:             a, b = histogram([], bins=estimator)
  446:             assert_array_equal(a, np.array([0]))
  447:             assert_array_equal(b, np.array([0, 1]))
  448: 
  449:     def test_simple(self):
  450:         """
  451:         Straightforward testing with a mixture of linspace data (for
  452:         consistency). All test values have been precomputed and the values
  453:         shouldn't change
  454:         """
  455:         # Some basic sanity checking, with some fixed data.
  456:         # Checking for the correct number of bins
  457:         basic_test = {50:   {'fd': 4,  'scott': 4,  'rice': 8,  'sturges': 7,
  458:                              'doane': 8, 'sqrt': 8, 'auto': 7, 'stone': 2},
  459:                       500:  {'fd': 8,  'scott': 8,  'rice': 16, 'sturges': 10,
  460:                              'doane': 12, 'sqrt': 23, 'auto': 10, 'stone': 9},
  461:                       5000: {'fd': 17, 'scott': 17, 'rice': 35, 'sturges': 14,
  462:                              'doane': 17, 'sqrt': 71, 'auto': 17, 'stone': 20}}
  463: 
  464:         for testlen, expectedResults in basic_test.items():
  465:             # Create some sort of non uniform data to test with
  466:             # (2 peak uniform mixture)
  467:             x1 = np.linspace(-10, -1, testlen // 5 * 2)
  468:             x2 = np.linspace(1, 10, testlen // 5 * 3)
  469:             x = np.concatenate((x1, x2))
  470:             for estimator, numbins in expectedResults.items():
  471:                 a, b = np.histogram(x, estimator)
  472:                 assert_equal(len(a), numbins, err_msg=f"For the {estimator} estimator "
  473:                              f"with datasize of {testlen}")
  474: 
  475:     def test_small(self):
  476:         """
  477:         Smaller datasets have the potential to cause issues with the data
  478:         adaptive methods, especially the FD method. All bin numbers have been
  479:         precalculated.
  480:         """
  481:         small_dat = {1: {'fd': 1, 'scott': 1, 'rice': 1, 'sturges': 1,
  482:                          'doane': 1, 'sqrt': 1, 'stone': 1},
  483:                      2: {'fd': 2, 'scott': 1, 'rice': 3, 'sturges': 2,
  484:                          'doane': 1, 'sqrt': 2, 'stone': 1},
  485:                      3: {'fd': 2, 'scott': 2, 'rice': 3, 'sturges': 3,
  486:                          'doane': 3, 'sqrt': 2, 'stone': 1}}
  487: 
  488:         for testlen, expectedResults in small_dat.items():
  489:             testdat = np.arange(testlen).astype(float)
  490:             for estimator, expbins in expectedResults.items():
  491:                 a, b = np.histogram(testdat, estimator)
  492:                 assert_equal(len(a), expbins, err_msg=f"For the {estimator} estimator "
  493:                              f"with datasize of {testlen}")
  494: 
  495:     def test_incorrect_methods(self):
  496:         """
  497:         Check a Value Error is thrown when an unknown string is passed in
  498:         """
  499:         check_list = ['mad', 'freeman', 'histograms', 'IQR']
  500:         for estimator in check_list:
  501:             assert_raises(ValueError, histogram, [1, 2, 3], estimator)
  502: 
  503:     def test_novariance(self):
  504:         """
  505:         Check that methods handle no variance in data
  506:         Primarily for Scott and FD as the SD and IQR are both 0 in this case
  507:         """
  508:         novar_dataset = np.ones(100)
  509:         novar_resultdict = {'fd': 1, 'scott': 1, 'rice': 1, 'sturges': 1,
  510:                             'doane': 1, 'sqrt': 1, 'auto': 1, 'stone': 1}
  511: 
  512:         for estimator, numbins in novar_resultdict.items():
  513:             a, b = np.histogram(novar_dataset, estimator)
  514:             assert_equal(len(a), numbins,
  515:                          err_msg=f"{estimator} estimator, No Variance test")
  516: 
  517:     def test_limited_variance(self):
  518:         """
  519:         Check when IQR is 0, but variance exists, we return a reasonable value.
  520:         """
  521:         lim_var_data = np.ones(1000)
  522:         lim_var_data[:3] = 0
  523:         lim_var_data[-4:] = 100
  524: 
  525:         edges_auto = histogram_bin_edges(lim_var_data, 'auto')
  526:         assert_equal(edges_auto[0], 0)
  527:         assert_equal(edges_auto[-1], 100.)
  528:         assert len(edges_auto) < 100
  529: 
  530:         edges_fd = histogram_bin_edges(lim_var_data, 'fd')
  531:         assert_equal(edges_fd, np.array([0, 100]))
  532: 
  533:         edges_sturges = histogram_bin_edges(lim_var_data, 'sturges')
  534:         assert_equal(edges_sturges, np.linspace(0, 100, 12))
  535: 
  536:     def test_outlier(self):
  537:         """
  538:         Check the FD, Scott and Doane with outliers.
  539: 
  540:         The FD estimates a smaller binwidth since it's less affected by
  541:         outliers. Since the range is so (artificially) large, this means more
  542:         bins, most of which will be empty, but the data of interest usually is
  543:         unaffected. The Scott estimator is more affected and returns fewer bins,
  544:         despite most of the variance being in one area of the data. The Doane
  545:         estimator lies somewhere between the other two.
  546:         """
  547:         xcenter = np.linspace(-10, 10, 50)
  548:         outlier_dataset = np.hstack((np.linspace(-110, -100, 5), xcenter))
  549: 
  550:         outlier_resultdict = {'fd': 21, 'scott': 5, 'doane': 11, 'stone': 6}
  551: 
  552:         for estimator, numbins in outlier_resultdict.items():
  553:             a, b = np.histogram(outlier_dataset, estimator)
  554:             assert_equal(len(a), numbins)
  555: 
  556:     def test_scott_vs_stone(self):
  557:         """Verify that Scott's rule and Stone's rule converges for normally distributed data"""
  558: 
  559:         def nbins_ratio(seed, size):
  560:             rng = np.random.RandomState(seed)
  561:             x = rng.normal(loc=0, scale=2, size=size)
  562:             a, b = len(np.histogram(x, 'stone')[0]), len(np.histogram(x, 'scott')[0])
  563:             return a / (a + b)
  564: 
  565:         ll = [[nbins_ratio(seed, size) for size in np.geomspace(start=10, stop=100, num=4).round().astype(int)]
  566:               for seed in range(10)]
  567: 
  568:         # the average difference between the two methods decreases as the dataset size increases.
  569:         avg = abs(np.mean(ll, axis=0) - 0.5)
  570:         assert_almost_equal(avg, [0.15, 0.09, 0.08, 0.03], decimal=2)
  571: 
  572:     def test_simple_range(self):
  573:         """
  574:         Straightforward testing with a mixture of linspace data (for
  575:         consistency). Adding in a 3rd mixture that will then be
  576:         completely ignored. All test values have been precomputed and
  577:         the shouldn't change.
  578:         """
  579:         # some basic sanity checking, with some fixed data.
  580:         # Checking for the correct number of bins
  581:         basic_test = {
  582:                       50:   {'fd': 8,  'scott': 8,  'rice': 15,
  583:                              'sturges': 14, 'auto': 14, 'stone': 8},
  584:                       500:  {'fd': 15, 'scott': 16, 'rice': 32,
  585:                              'sturges': 20, 'auto': 20, 'stone': 80},
  586:                       5000: {'fd': 33, 'scott': 33, 'rice': 69,
  587:                              'sturges': 27, 'auto': 33, 'stone': 80}
  588:                      }
  589: 
  590:         for testlen, expectedResults in basic_test.items():
  591:             # create some sort of non uniform data to test with
  592:             # (3 peak uniform mixture)
  593:             x1 = np.linspace(-10, -1, testlen // 5 * 2)
  594:             x2 = np.linspace(1, 10, testlen // 5 * 3)
  595:             x3 = np.linspace(-100, -50, testlen)
  596:             x = np.hstack((x1, x2, x3))
  597:             for estimator, numbins in expectedResults.items():
  598:                 a, b = np.histogram(x, estimator, range=(-20, 20))
  599:                 msg = f"For the {estimator} estimator"
  600:                 msg += f" with datasize of {testlen}"
  601:                 assert_equal(len(a), numbins, err_msg=msg)
  602: 
  603:     @pytest.mark.parametrize("bins", ['auto', 'fd', 'doane', 'scott',
  604:                                       'stone', 'rice', 'sturges'])
  605:     def test_signed_integer_data(self, bins):
  606:         # Regression test for gh-14379.
  607:         a = np.array([-2, 0, 127], dtype=np.int8)
  608:         hist, edges = np.histogram(a, bins=bins)
  609:         hist32, edges32 = np.histogram(a.astype(np.int32), bins=bins)
  610:         assert_array_equal(hist, hist32)
  611:         assert_array_equal(edges, edges32)
  612: 
  613:     @pytest.mark.parametrize("bins", ['auto', 'fd', 'doane', 'scott',
  614:                                       'stone', 'rice', 'sturges'])
  615:     def test_integer(self, bins):
  616:         """
  617:         Test that bin width for integer data is at least 1.
  618:         """
  619:         with suppress_warnings() as sup:
  620:             if bins == 'stone':
  621:                 sup.filter(RuntimeWarning)
  622:             assert_equal(
  623:                 np.histogram_bin_edges(np.tile(np.arange(9), 1000), bins),
  624:                 np.arange(9))
  625: 
  626:     def test_integer_non_auto(self):
  627:         """
  628:         Test that the bin-width>=1 requirement *only* applies to auto binning.
  629:         """
  630:         assert_equal(
  631:             np.histogram_bin_edges(np.tile(np.arange(9), 1000), 16),
  632:             np.arange(17) / 2)
  633:         assert_equal(
  634:             np.histogram_bin_edges(np.tile(np.arange(9), 1000), [.1, .2]),
  635:             [.1, .2])
  636: 
  637:     def test_simple_weighted(self):
  638:         """
  639:         Check that weighted data raises a TypeError
  640:         """
  641:         estimator_list = ['fd', 'scott', 'rice', 'sturges', 'auto']
  642:         for estimator in estimator_list:
  643:             assert_raises(TypeError, histogram, [1, 2, 3],
  644:                           estimator, weights=[1, 2, 3])
  645: 
  646: 
  647: class TestHistogramdd:
  648: 
  649:     def test_simple(self):
  650:         x = np.array([[-.5, .5, 1.5], [-.5, 1.5, 2.5], [-.5, 2.5, .5],
  651:                       [.5,  .5, 1.5], [.5,  1.5, 2.5], [.5,  2.5, 2.5]])
  652:         H, edges = histogramdd(x, (2, 3, 3),
  653:                                range=[[-1, 1], [0, 3], [0, 3]])
  654:         answer = np.array([[[0, 1, 0], [0, 0, 1], [1, 0, 0]],
  655:                            [[0, 1, 0], [0, 0, 1], [0, 0, 1]]])
  656:         assert_array_equal(H, answer)
  657: 
  658:         # Check normalization
  659:         ed = [[-2, 0, 2], [0, 1, 2, 3], [0, 1, 2, 3]]
  660:         H, edges = histogramdd(x, bins=ed, density=True)
  661:         assert_(np.all(H == answer / 12.))
  662: 
  663:         # Check that H has the correct shape.
  664:         H, edges = histogramdd(x, (2, 3, 4),
  665:                                range=[[-1, 1], [0, 3], [0, 4]],
  666:                                density=True)
  667:         answer = np.array([[[0, 1, 0, 0], [0, 0, 1, 0], [1, 0, 0, 0]],
  668:                            [[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 1, 0]]])
  669:         assert_array_almost_equal(H, answer / 6., 4)
  670:         # Check that a sequence of arrays is accepted and H has the correct
  671:         # shape.
  672:         z = [np.squeeze(y) for y in np.split(x, 3, axis=1)]
  673:         H, edges = histogramdd(
  674:             z, bins=(4, 3, 2), range=[[-2, 2], [0, 3], [0, 2]])
  675:         answer = np.array([[[0, 0], [0, 0], [0, 0]],
  676:                            [[0, 1], [0, 0], [1, 0]],
  677:                            [[0, 1], [0, 0], [0, 0]],
  678:                            [[0, 0], [0, 0], [0, 0]]])
  679:         assert_array_equal(H, answer)
  680: 
  681:         Z = np.zeros((5, 5, 5))
  682:         Z[list(range(5)), list(range(5)), list(range(5))] = 1.
  683:         H, edges = histogramdd([np.arange(5), np.arange(5), np.arange(5)], 5)
  684:         assert_array_equal(H, Z)
  685: 
  686:     def test_shape_3d(self):
  687:         # All possible permutations for bins of different lengths in 3D.
  688:         bins = ((5, 4, 6), (6, 4, 5), (5, 6, 4), (4, 6, 5), (6, 5, 4),
  689:                 (4, 5, 6))
  690:         r = np.random.rand(10, 3)
  691:         for b in bins:
  692:             H, edges = histogramdd(r, b)
  693:             assert_(H.shape == b)
  694: 
  695:     def test_shape_4d(self):
  696:         # All possible permutations for bins of different lengths in 4D.
  697:         bins = ((7, 4, 5, 6), (4, 5, 7, 6), (5, 6, 4, 7), (7, 6, 5, 4),
  698:                 (5, 7, 6, 4), (4, 6, 7, 5), (6, 5, 7, 4), (7, 5, 4, 6),
  699:                 (7, 4, 6, 5), (6, 4, 7, 5), (6, 7, 5, 4), (4, 6, 5, 7),
  700:                 (4, 7, 5, 6), (5, 4, 6, 7), (5, 7, 4, 6), (6, 7, 4, 5),
  701:                 (6, 5, 4, 7), (4, 7, 6, 5), (4, 5, 6, 7), (7, 6, 4, 5),
  702:                 (5, 4, 7, 6), (5, 6, 7, 4), (6, 4, 5, 7), (7, 5, 6, 4))
  703: 
  704:         r = np.random.rand(10, 4)
  705:         for b in bins:
  706:             H, edges = histogramdd(r, b)
  707:             assert_(H.shape == b)
  708: 
  709:     def test_weights(self):
  710:         v = np.random.rand(100, 2)
  711:         hist, edges = histogramdd(v)
  712:         n_hist, edges = histogramdd(v, density=True)
  713:         w_hist, edges = histogramdd(v, weights=np.ones(100))
  714:         assert_array_equal(w_hist, hist)
  715:         w_hist, edges = histogramdd(v, weights=np.ones(100) * 2, density=True)
  716:         assert_array_equal(w_hist, n_hist)
  717:         w_hist, edges = histogramdd(v, weights=np.ones(100, int) * 2)
  718:         assert_array_equal(w_hist, 2 * hist)
  719: 
  720:     def test_identical_samples(self):
  721:         x = np.zeros((10, 2), int)
  722:         hist, edges = histogramdd(x, bins=2)
  723:         assert_array_equal(edges[0], np.array([-0.5, 0., 0.5]))
  724: 
  725:     def test_empty(self):
  726:         a, b = histogramdd([[], []], bins=([0, 1], [0, 1]))
  727:         assert_array_max_ulp(a, np.array([[0.]]))
  728:         a, b = np.histogramdd([[], [], []], bins=2)
  729:         assert_array_max_ulp(a, np.zeros((2, 2, 2)))
  730: 
  731:     def test_bins_errors(self):
  732:         # There are two ways to specify bins. Check for the right errors
  733:         # when mixing those.
  734:         x = np.arange(8).reshape(2, 4)
  735:         assert_raises(ValueError, np.histogramdd, x, bins=[-1, 2, 4, 5])
  736:         assert_raises(ValueError, np.histogramdd, x, bins=[1, 0.99, 1, 1])
  737:         assert_raises(
  738:             ValueError, np.histogramdd, x, bins=[1, 1, 1, [1, 2, 3, -3]])
  739:         assert_(np.histogramdd(x, bins=[1, 1, 1, [1, 2, 3, 4]]))
  740: 
  741:     def test_inf_edges(self):
  742:         # Test using +/-inf bin edges works. See #1788.
  743:         with np.errstate(invalid='ignore'):
  744:             x = np.arange(6).reshape(3, 2)
  745:             expected = np.array([[1, 0], [0, 1], [0, 1]])
  746:             h, e = np.histogramdd(x, bins=[3, [-np.inf, 2, 10]])
  747:             assert_allclose(h, expected)
  748:             h, e = np.histogramdd(x, bins=[3, np.array([-1, 2, np.inf])])
  749:             assert_allclose(h, expected)
  750:             h, e = np.histogramdd(x, bins=[3, [-np.inf, 3, np.inf]])
  751:             assert_allclose(h, expected)
  752: 
  753:     def test_rightmost_binedge(self):
  754:         # Test event very close to rightmost binedge. See Github issue #4266
  755:         x = [0.9999999995]
  756:         bins = [[0., 0.5, 1.0]]
  757:         hist, _ = histogramdd(x, bins=bins)
  758:         assert_(hist[0] == 0.0)
  759:         assert_(hist[1] == 1.)
  760:         x = [1.0]
  761:         bins = [[0., 0.5, 1.0]]
  762:         hist, _ = histogramdd(x, bins=bins)
  763:         assert_(hist[0] == 0.0)
  764:         assert_(hist[1] == 1.)
  765:         x = [1.0000000001]
  766:         bins = [[0., 0.5, 1.0]]
  767:         hist, _ = histogramdd(x, bins=bins)
  768:         assert_(hist[0] == 0.0)
  769:         assert_(hist[1] == 0.0)
  770:         x = [1.0001]
  771:         bins = [[0., 0.5, 1.0]]
  772:         hist, _ = histogramdd(x, bins=bins)
  773:         assert_(hist[0] == 0.0)
  774:         assert_(hist[1] == 0.0)
  775: 
  776:     def test_finite_range(self):
  777:         vals = np.random.random((100, 3))
  778:         histogramdd(vals, range=[[0.0, 1.0], [0.25, 0.75], [0.25, 0.5]])
  779:         assert_raises(ValueError, histogramdd, vals,
  780:                       range=[[0.0, 1.0], [0.25, 0.75], [0.25, np.inf]])
  781:         assert_raises(ValueError, histogramdd, vals,
  782:                       range=[[0.0, 1.0], [np.nan, 0.75], [0.25, 0.5]])
  783: 
  784:     def test_equal_edges(self):
  785:         """ Test that adjacent entries in an edge array can be equal """
  786:         x = np.array([0, 1, 2])
  787:         y = np.array([0, 1, 2])
  788:         x_edges = np.array([0, 2, 2])
  789:         y_edges = 1
  790:         hist, edges = histogramdd((x, y), bins=(x_edges, y_edges))
  791: 
  792:         hist_expected = np.array([
  793:             [2.],
  794:             [1.],  # x == 2 falls in the final bin
  795:         ])
  796:         assert_equal(hist, hist_expected)
  797: 
  798:     def test_edge_dtype(self):
  799:         """ Test that if an edge array is input, its type is preserved """
  800:         x = np.array([0, 10, 20])
  801:         y = x / 10
  802:         x_edges = np.array([0, 5, 15, 20])
  803:         y_edges = x_edges / 10
  804:         hist, edges = histogramdd((x, y), bins=(x_edges, y_edges))
  805: 
  806:         assert_equal(edges[0].dtype, x_edges.dtype)
  807:         assert_equal(edges[1].dtype, y_edges.dtype)
  808: 
  809:     def test_large_integers(self):
  810:         big = 2**60  # Too large to represent with a full precision float
  811: 
  812:         x = np.array([0], np.int64)
  813:         x_edges = np.array([-1, +1], np.int64)
  814:         y = big + x
  815:         y_edges = big + x_edges
  816: 
  817:         hist, edges = histogramdd((x, y), bins=(x_edges, y_edges))
  818: 
  819:         assert_equal(hist[0, 0], 1)
  820: 
  821:     def test_density_non_uniform_2d(self):
  822:         # Defines the following grid:
  823:         #
  824:         #    0 2     8
  825:         #   0+-+-----+
  826:         #    + |     +
  827:         #    + |     +
  828:         #   6+-+-----+
  829:         #   8+-+-----+
  830:         x_edges = np.array([0, 2, 8])
  831:         y_edges = np.array([0, 6, 8])
  832:         relative_areas = np.array([
  833:             [3, 9],
  834:             [1, 3]])
  835: 
  836:         # ensure the number of points in each region is proportional to its area
  837:         x = np.array([1] + [1] * 3 + [7] * 3 + [7] * 9)
  838:         y = np.array([7] + [1] * 3 + [7] * 3 + [1] * 9)
  839: 
  840:         # sanity check that the above worked as intended
  841:         hist, edges = histogramdd((y, x), bins=(y_edges, x_edges))
  842:         assert_equal(hist, relative_areas)
  843: 
  844:         # resulting histogram should be uniform, since counts and areas are proportional
  845:         hist, edges = histogramdd((y, x), bins=(y_edges, x_edges), density=True)
  846:         assert_equal(hist, 1 / (8 * 8))
  847: 
  848:     def test_density_non_uniform_1d(self):
  849:         # compare to histogram to show the results are the same
  850:         v = np.arange(10)
  851:         bins = np.array([0, 1, 3, 6, 10])
  852:         hist, edges = histogram(v, bins, density=True)
  853:         hist_dd, edges_dd = histogramdd((v,), (bins,), density=True)
  854:         assert_equal(hist, hist_dd)
  855:         assert_equal(edges, edges_dd[0])
