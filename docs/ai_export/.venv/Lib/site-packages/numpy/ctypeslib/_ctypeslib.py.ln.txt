    1: """
    2: ============================
    3: ``ctypes`` Utility Functions
    4: ============================
    5: 
    6: See Also
    7: --------
    8: load_library : Load a C library.
    9: ndpointer : Array restype/argtype with verification.
   10: as_ctypes : Create a ctypes array from an ndarray.
   11: as_array : Create an ndarray from a ctypes array.
   12: 
   13: References
   14: ----------
   15: .. [1] "SciPy Cookbook: ctypes", https://scipy-cookbook.readthedocs.io/items/Ctypes.html
   16: 
   17: Examples
   18: --------
   19: Load the C library:
   20: 
   21: >>> _lib = np.ctypeslib.load_library('libmystuff', '.')     #doctest: +SKIP
   22: 
   23: Our result type, an ndarray that must be of type double, be 1-dimensional
   24: and is C-contiguous in memory:
   25: 
   26: >>> array_1d_double = np.ctypeslib.ndpointer(
   27: ...                          dtype=np.double,
   28: ...                          ndim=1, flags='CONTIGUOUS')    #doctest: +SKIP
   29: 
   30: Our C-function typically takes an array and updates its values
   31: in-place.  For example::
   32: 
   33:     void foo_func(double* x, int length)
   34:     {
   35:         int i;
   36:         for (i = 0; i < length; i++) {
   37:             x[i] = i*i;
   38:         }
   39:     }
   40: 
   41: We wrap it using:
   42: 
   43: >>> _lib.foo_func.restype = None                      #doctest: +SKIP
   44: >>> _lib.foo_func.argtypes = [array_1d_double, c_int] #doctest: +SKIP
   45: 
   46: Then, we're ready to call ``foo_func``:
   47: 
   48: >>> out = np.empty(15, dtype=np.double)
   49: >>> _lib.foo_func(out, len(out))                #doctest: +SKIP
   50: 
   51: """
   52: __all__ = ['load_library', 'ndpointer', 'c_intp', 'as_ctypes', 'as_array',
   53:            'as_ctypes_type']
   54: 
   55: import os
   56: 
   57: import numpy as np
   58: import numpy._core.multiarray as mu
   59: from numpy._utils import set_module
   60: 
   61: try:
   62:     import ctypes
   63: except ImportError:
   64:     ctypes = None
   65: 
   66: if ctypes is None:
   67:     @set_module("numpy.ctypeslib")
   68:     def _dummy(*args, **kwds):
   69:         """
   70:         Dummy object that raises an ImportError if ctypes is not available.
   71: 
   72:         Raises
   73:         ------
   74:         ImportError
   75:             If ctypes is not available.
   76: 
   77:         """
   78:         raise ImportError("ctypes is not available.")
   79:     load_library = _dummy
   80:     as_ctypes = _dummy
   81:     as_ctypes_type = _dummy
   82:     as_array = _dummy
   83:     ndpointer = _dummy
   84:     from numpy import intp as c_intp
   85:     _ndptr_base = object
   86: else:
   87:     import numpy._core._internal as nic
   88:     c_intp = nic._getintp_ctype()
   89:     del nic
   90:     _ndptr_base = ctypes.c_void_p
   91: 
   92:     # Adapted from Albert Strasheim
   93:     @set_module("numpy.ctypeslib")
   94:     def load_library(libname, loader_path):
   95:         """
   96:         It is possible to load a library using
   97: 
   98:         >>> lib = ctypes.cdll[<full_path_name>] # doctest: +SKIP
   99: 
  100:         But there are cross-platform considerations, such as library file extensions,
  101:         plus the fact Windows will just load the first library it finds with that name.
  102:         NumPy supplies the load_library function as a convenience.
  103: 
  104:         .. versionchanged:: 1.20.0
  105:             Allow libname and loader_path to take any
  106:             :term:`python:path-like object`.
  107: 
  108:         Parameters
  109:         ----------
  110:         libname : path-like
  111:             Name of the library, which can have 'lib' as a prefix,
  112:             but without an extension.
  113:         loader_path : path-like
  114:             Where the library can be found.
  115: 
  116:         Returns
  117:         -------
  118:         ctypes.cdll[libpath] : library object
  119:            A ctypes library object
  120: 
  121:         Raises
  122:         ------
  123:         OSError
  124:             If there is no library with the expected extension, or the
  125:             library is defective and cannot be loaded.
  126:         """
  127:         # Convert path-like objects into strings
  128:         libname = os.fsdecode(libname)
  129:         loader_path = os.fsdecode(loader_path)
  130: 
  131:         ext = os.path.splitext(libname)[1]
  132:         if not ext:
  133:             import sys
  134:             import sysconfig
  135:             # Try to load library with platform-specific name, otherwise
  136:             # default to libname.[so|dll|dylib].  Sometimes, these files are
  137:             # built erroneously on non-linux platforms.
  138:             base_ext = ".so"
  139:             if sys.platform.startswith("darwin"):
  140:                 base_ext = ".dylib"
  141:             elif sys.platform.startswith("win"):
  142:                 base_ext = ".dll"
  143:             libname_ext = [libname + base_ext]
  144:             so_ext = sysconfig.get_config_var("EXT_SUFFIX")
  145:             if not so_ext == base_ext:
  146:                 libname_ext.insert(0, libname + so_ext)
  147:         else:
  148:             libname_ext = [libname]
  149: 
  150:         loader_path = os.path.abspath(loader_path)
  151:         if not os.path.isdir(loader_path):
  152:             libdir = os.path.dirname(loader_path)
  153:         else:
  154:             libdir = loader_path
  155: 
  156:         for ln in libname_ext:
  157:             libpath = os.path.join(libdir, ln)
  158:             if os.path.exists(libpath):
  159:                 try:
  160:                     return ctypes.cdll[libpath]
  161:                 except OSError:
  162:                     # defective lib file
  163:                     raise
  164:         # if no successful return in the libname_ext loop:
  165:         raise OSError("no file with expected extension")
  166: 
  167: 
  168: def _num_fromflags(flaglist):
  169:     num = 0
  170:     for val in flaglist:
  171:         num += mu._flagdict[val]
  172:     return num
  173: 
  174: 
  175: _flagnames = ['C_CONTIGUOUS', 'F_CONTIGUOUS', 'ALIGNED', 'WRITEABLE',
  176:               'OWNDATA', 'WRITEBACKIFCOPY']
  177: def _flags_fromnum(num):
  178:     res = []
  179:     for key in _flagnames:
  180:         value = mu._flagdict[key]
  181:         if (num & value):
  182:             res.append(key)
  183:     return res
  184: 
  185: 
  186: class _ndptr(_ndptr_base):
  187:     @classmethod
  188:     def from_param(cls, obj):
  189:         if not isinstance(obj, np.ndarray):
  190:             raise TypeError("argument must be an ndarray")
  191:         if cls._dtype_ is not None \
  192:                and obj.dtype != cls._dtype_:
  193:             raise TypeError(f"array must have data type {cls._dtype_}")
  194:         if cls._ndim_ is not None \
  195:                and obj.ndim != cls._ndim_:
  196:             raise TypeError("array must have %d dimension(s)" % cls._ndim_)
  197:         if cls._shape_ is not None \
  198:                and obj.shape != cls._shape_:
  199:             raise TypeError(f"array must have shape {str(cls._shape_)}")
  200:         if cls._flags_ is not None \
  201:                and ((obj.flags.num & cls._flags_) != cls._flags_):
  202:             raise TypeError(f"array must have flags {_flags_fromnum(cls._flags_)}")
  203:         return obj.ctypes
  204: 
  205: 
  206: class _concrete_ndptr(_ndptr):
  207:     """
  208:     Like _ndptr, but with `_shape_` and `_dtype_` specified.
  209: 
  210:     Notably, this means the pointer has enough information to reconstruct
  211:     the array, which is not generally true.
  212:     """
  213:     def _check_retval_(self):
  214:         """
  215:         This method is called when this class is used as the .restype
  216:         attribute for a shared-library function, to automatically wrap the
  217:         pointer into an array.
  218:         """
  219:         return self.contents
  220: 
  221:     @property
  222:     def contents(self):
  223:         """
  224:         Get an ndarray viewing the data pointed to by this pointer.
  225: 
  226:         This mirrors the `contents` attribute of a normal ctypes pointer
  227:         """
  228:         full_dtype = np.dtype((self._dtype_, self._shape_))
  229:         full_ctype = ctypes.c_char * full_dtype.itemsize
  230:         buffer = ctypes.cast(self, ctypes.POINTER(full_ctype)).contents
  231:         return np.frombuffer(buffer, dtype=full_dtype).squeeze(axis=0)
  232: 
  233: 
  234: # Factory for an array-checking class with from_param defined for
  235: # use with ctypes argtypes mechanism
  236: _pointer_type_cache = {}
  237: 
  238: @set_module("numpy.ctypeslib")
  239: def ndpointer(dtype=None, ndim=None, shape=None, flags=None):
  240:     """
  241:     Array-checking restype/argtypes.
  242: 
  243:     An ndpointer instance is used to describe an ndarray in restypes
  244:     and argtypes specifications.  This approach is more flexible than
  245:     using, for example, ``POINTER(c_double)``, since several restrictions
  246:     can be specified, which are verified upon calling the ctypes function.
  247:     These include data type, number of dimensions, shape and flags.  If a
  248:     given array does not satisfy the specified restrictions,
  249:     a ``TypeError`` is raised.
  250: 
  251:     Parameters
  252:     ----------
  253:     dtype : data-type, optional
  254:         Array data-type.
  255:     ndim : int, optional
  256:         Number of array dimensions.
  257:     shape : tuple of ints, optional
  258:         Array shape.
  259:     flags : str or tuple of str
  260:         Array flags; may be one or more of:
  261: 
  262:         - C_CONTIGUOUS / C / CONTIGUOUS
  263:         - F_CONTIGUOUS / F / FORTRAN
  264:         - OWNDATA / O
  265:         - WRITEABLE / W
  266:         - ALIGNED / A
  267:         - WRITEBACKIFCOPY / X
  268: 
  269:     Returns
  270:     -------
  271:     klass : ndpointer type object
  272:         A type object, which is an ``_ndtpr`` instance containing
  273:         dtype, ndim, shape and flags information.
  274: 
  275:     Raises
  276:     ------
  277:     TypeError
  278:         If a given array does not satisfy the specified restrictions.
  279: 
  280:     Examples
  281:     --------
  282:     >>> clib.somefunc.argtypes = [np.ctypeslib.ndpointer(dtype=np.float64,
  283:     ...                                                  ndim=1,
  284:     ...                                                  flags='C_CONTIGUOUS')]
  285:     ... #doctest: +SKIP
  286:     >>> clib.somefunc(np.array([1, 2, 3], dtype=np.float64))
  287:     ... #doctest: +SKIP
  288: 
  289:     """
  290: 
  291:     # normalize dtype to dtype | None
  292:     if dtype is not None:
  293:         dtype = np.dtype(dtype)
  294: 
  295:     # normalize flags to int | None
  296:     num = None
  297:     if flags is not None:
  298:         if isinstance(flags, str):
  299:             flags = flags.split(',')
  300:         elif isinstance(flags, (int, np.integer)):
  301:             num = flags
  302:             flags = _flags_fromnum(num)
  303:         elif isinstance(flags, mu.flagsobj):
  304:             num = flags.num
  305:             flags = _flags_fromnum(num)
  306:         if num is None:
  307:             try:
  308:                 flags = [x.strip().upper() for x in flags]
  309:             except Exception as e:
  310:                 raise TypeError("invalid flags specification") from e
  311:             num = _num_fromflags(flags)
  312: 
  313:     # normalize shape to tuple | None
  314:     if shape is not None:
  315:         try:
  316:             shape = tuple(shape)
  317:         except TypeError:
  318:             # single integer -> 1-tuple
  319:             shape = (shape,)
  320: 
  321:     cache_key = (dtype, ndim, shape, num)
  322: 
  323:     try:
  324:         return _pointer_type_cache[cache_key]
  325:     except KeyError:
  326:         pass
  327: 
  328:     # produce a name for the new type
  329:     if dtype is None:
  330:         name = 'any'
  331:     elif dtype.names is not None:
  332:         name = str(id(dtype))
  333:     else:
  334:         name = dtype.str
  335:     if ndim is not None:
  336:         name += "_%dd" % ndim
  337:     if shape is not None:
  338:         name += "_" + "x".join(str(x) for x in shape)
  339:     if flags is not None:
  340:         name += "_" + "_".join(flags)
  341: 
  342:     if dtype is not None and shape is not None:
  343:         base = _concrete_ndptr
  344:     else:
  345:         base = _ndptr
  346: 
  347:     klass = type(f"ndpointer_{name}", (base,),
  348:                  {"_dtype_": dtype,
  349:                   "_shape_": shape,
  350:                   "_ndim_": ndim,
  351:                   "_flags_": num})
  352:     _pointer_type_cache[cache_key] = klass
  353:     return klass
  354: 
  355: 
  356: if ctypes is not None:
  357:     def _ctype_ndarray(element_type, shape):
  358:         """ Create an ndarray of the given element type and shape """
  359:         for dim in shape[::-1]:
  360:             element_type = dim * element_type
  361:             # prevent the type name include np.ctypeslib
  362:             element_type.__module__ = None
  363:         return element_type
  364: 
  365:     def _get_scalar_type_map():
  366:         """
  367:         Return a dictionary mapping native endian scalar dtype to ctypes types
  368:         """
  369:         ct = ctypes
  370:         simple_types = [
  371:             ct.c_byte, ct.c_short, ct.c_int, ct.c_long, ct.c_longlong,
  372:             ct.c_ubyte, ct.c_ushort, ct.c_uint, ct.c_ulong, ct.c_ulonglong,
  373:             ct.c_float, ct.c_double,
  374:             ct.c_bool,
  375:         ]
  376:         return {np.dtype(ctype): ctype for ctype in simple_types}
  377: 
  378:     _scalar_type_map = _get_scalar_type_map()
  379: 
  380:     def _ctype_from_dtype_scalar(dtype):
  381:         # swapping twice ensure that `=` is promoted to <, >, or |
  382:         dtype_with_endian = dtype.newbyteorder('S').newbyteorder('S')
  383:         dtype_native = dtype.newbyteorder('=')
  384:         try:
  385:             ctype = _scalar_type_map[dtype_native]
  386:         except KeyError as e:
  387:             raise NotImplementedError(
  388:                 f"Converting {dtype!r} to a ctypes type"
  389:             ) from None
  390: 
  391:         if dtype_with_endian.byteorder == '>':
  392:             ctype = ctype.__ctype_be__
  393:         elif dtype_with_endian.byteorder == '<':
  394:             ctype = ctype.__ctype_le__
  395: 
  396:         return ctype
  397: 
  398:     def _ctype_from_dtype_subarray(dtype):
  399:         element_dtype, shape = dtype.subdtype
  400:         ctype = _ctype_from_dtype(element_dtype)
  401:         return _ctype_ndarray(ctype, shape)
  402: 
  403:     def _ctype_from_dtype_structured(dtype):
  404:         # extract offsets of each field
  405:         field_data = []
  406:         for name in dtype.names:
  407:             field_dtype, offset = dtype.fields[name][:2]
  408:             field_data.append((offset, name, _ctype_from_dtype(field_dtype)))
  409: 
  410:         # ctypes doesn't care about field order
  411:         field_data = sorted(field_data, key=lambda f: f[0])
  412: 
  413:         if len(field_data) > 1 and all(offset == 0 for offset, _, _ in field_data):
  414:             # union, if multiple fields all at address 0
  415:             size = 0
  416:             _fields_ = []
  417:             for offset, name, ctype in field_data:
  418:                 _fields_.append((name, ctype))
  419:                 size = max(size, ctypes.sizeof(ctype))
  420: 
  421:             # pad to the right size
  422:             if dtype.itemsize != size:
  423:                 _fields_.append(('', ctypes.c_char * dtype.itemsize))
  424: 
  425:             # we inserted manual padding, so always `_pack_`
  426:             return type('union', (ctypes.Union,), {
  427:                 '_fields_': _fields_,
  428:                 '_pack_': 1,
  429:                 '__module__': None,
  430:             })
  431:         else:
  432:             last_offset = 0
  433:             _fields_ = []
  434:             for offset, name, ctype in field_data:
  435:                 padding = offset - last_offset
  436:                 if padding < 0:
  437:                     raise NotImplementedError("Overlapping fields")
  438:                 if padding > 0:
  439:                     _fields_.append(('', ctypes.c_char * padding))
  440: 
  441:                 _fields_.append((name, ctype))
  442:                 last_offset = offset + ctypes.sizeof(ctype)
  443: 
  444:             padding = dtype.itemsize - last_offset
  445:             if padding > 0:
  446:                 _fields_.append(('', ctypes.c_char * padding))
  447: 
  448:             # we inserted manual padding, so always `_pack_`
  449:             return type('struct', (ctypes.Structure,), {
  450:                 '_fields_': _fields_,
  451:                 '_pack_': 1,
  452:                 '__module__': None,
  453:             })
  454: 
  455:     def _ctype_from_dtype(dtype):
  456:         if dtype.fields is not None:
  457:             return _ctype_from_dtype_structured(dtype)
  458:         elif dtype.subdtype is not None:
  459:             return _ctype_from_dtype_subarray(dtype)
  460:         else:
  461:             return _ctype_from_dtype_scalar(dtype)
  462: 
  463:     @set_module("numpy.ctypeslib")
  464:     def as_ctypes_type(dtype):
  465:         r"""
  466:         Convert a dtype into a ctypes type.
  467: 
  468:         Parameters
  469:         ----------
  470:         dtype : dtype
  471:             The dtype to convert
  472: 
  473:         Returns
  474:         -------
  475:         ctype
  476:             A ctype scalar, union, array, or struct
  477: 
  478:         Raises
  479:         ------
  480:         NotImplementedError
  481:             If the conversion is not possible
  482: 
  483:         Notes
  484:         -----
  485:         This function does not losslessly round-trip in either direction.
  486: 
  487:         ``np.dtype(as_ctypes_type(dt))`` will:
  488: 
  489:         - insert padding fields
  490:         - reorder fields to be sorted by offset
  491:         - discard field titles
  492: 
  493:         ``as_ctypes_type(np.dtype(ctype))`` will:
  494: 
  495:         - discard the class names of `ctypes.Structure`\ s and
  496:           `ctypes.Union`\ s
  497:         - convert single-element `ctypes.Union`\ s into single-element
  498:           `ctypes.Structure`\ s
  499:         - insert padding fields
  500: 
  501:         Examples
  502:         --------
  503:         Converting a simple dtype:
  504: 
  505:         >>> dt = np.dtype('int8')
  506:         >>> ctype = np.ctypeslib.as_ctypes_type(dt)
  507:         >>> ctype
  508:         <class 'ctypes.c_byte'>
  509: 
  510:         Converting a structured dtype:
  511: 
  512:         >>> dt = np.dtype([('x', 'i4'), ('y', 'f4')])
  513:         >>> ctype = np.ctypeslib.as_ctypes_type(dt)
  514:         >>> ctype
  515:         <class 'struct'>
  516: 
  517:         """
  518:         return _ctype_from_dtype(np.dtype(dtype))
  519: 
  520:     @set_module("numpy.ctypeslib")
  521:     def as_array(obj, shape=None):
  522:         """
  523:         Create a numpy array from a ctypes array or POINTER.
  524: 
  525:         The numpy array shares the memory with the ctypes object.
  526: 
  527:         The shape parameter must be given if converting from a ctypes POINTER.
  528:         The shape parameter is ignored if converting from a ctypes array
  529: 
  530:         Examples
  531:         --------
  532:         Converting a ctypes integer array:
  533: 
  534:         >>> import ctypes
  535:         >>> ctypes_array = (ctypes.c_int * 5)(0, 1, 2, 3, 4)
  536:         >>> np_array = np.ctypeslib.as_array(ctypes_array)
  537:         >>> np_array
  538:         array([0, 1, 2, 3, 4], dtype=int32)
  539: 
  540:         Converting a ctypes POINTER:
  541: 
  542:         >>> import ctypes
  543:         >>> buffer = (ctypes.c_int * 5)(0, 1, 2, 3, 4)
  544:         >>> pointer = ctypes.cast(buffer, ctypes.POINTER(ctypes.c_int))
  545:         >>> np_array = np.ctypeslib.as_array(pointer, (5,))
  546:         >>> np_array
  547:         array([0, 1, 2, 3, 4], dtype=int32)
  548: 
  549:         """
  550:         if isinstance(obj, ctypes._Pointer):
  551:             # convert pointers to an array of the desired shape
  552:             if shape is None:
  553:                 raise TypeError(
  554:                     'as_array() requires a shape argument when called on a '
  555:                     'pointer')
  556:             p_arr_type = ctypes.POINTER(_ctype_ndarray(obj._type_, shape))
  557:             obj = ctypes.cast(obj, p_arr_type).contents
  558: 
  559:         return np.asarray(obj)
  560: 
  561:     @set_module("numpy.ctypeslib")
  562:     def as_ctypes(obj):
  563:         """
  564:         Create and return a ctypes object from a numpy array.  Actually
  565:         anything that exposes the __array_interface__ is accepted.
  566: 
  567:         Examples
  568:         --------
  569:         Create ctypes object from inferred int ``np.array``:
  570: 
  571:         >>> inferred_int_array = np.array([1, 2, 3])
  572:         >>> c_int_array = np.ctypeslib.as_ctypes(inferred_int_array)
  573:         >>> type(c_int_array)
  574:         <class 'c_long_Array_3'>
  575:         >>> c_int_array[:]
  576:         [1, 2, 3]
  577: 
  578:         Create ctypes object from explicit 8 bit unsigned int ``np.array`` :
  579: 
  580:         >>> exp_int_array = np.array([1, 2, 3], dtype=np.uint8)
  581:         >>> c_int_array = np.ctypeslib.as_ctypes(exp_int_array)
  582:         >>> type(c_int_array)
  583:         <class 'c_ubyte_Array_3'>
  584:         >>> c_int_array[:]
  585:         [1, 2, 3]
  586: 
  587:         """
  588:         ai = obj.__array_interface__
  589:         if ai["strides"]:
  590:             raise TypeError("strided arrays not supported")
  591:         if ai["version"] != 3:
  592:             raise TypeError("only __array_interface__ version 3 supported")
  593:         addr, readonly = ai["data"]
  594:         if readonly:
  595:             raise TypeError("readonly arrays unsupported")
  596: 
  597:         # can't use `_dtype((ai["typestr"], ai["shape"]))` here, as it overflows
  598:         # dtype.itemsize (gh-14214)
  599:         ctype_scalar = as_ctypes_type(ai["typestr"])
  600:         result_type = _ctype_ndarray(ctype_scalar, ai["shape"])
  601:         result = result_type.from_address(addr)
  602:         result.__keep = obj
  603:         return result
