    1: """
    2: Discrete Fourier Transforms
    3: 
    4: Routines in this module:
    5: 
    6: fft(a, n=None, axis=-1, norm="backward")
    7: ifft(a, n=None, axis=-1, norm="backward")
    8: rfft(a, n=None, axis=-1, norm="backward")
    9: irfft(a, n=None, axis=-1, norm="backward")
   10: hfft(a, n=None, axis=-1, norm="backward")
   11: ihfft(a, n=None, axis=-1, norm="backward")
   12: fftn(a, s=None, axes=None, norm="backward")
   13: ifftn(a, s=None, axes=None, norm="backward")
   14: rfftn(a, s=None, axes=None, norm="backward")
   15: irfftn(a, s=None, axes=None, norm="backward")
   16: fft2(a, s=None, axes=(-2,-1), norm="backward")
   17: ifft2(a, s=None, axes=(-2, -1), norm="backward")
   18: rfft2(a, s=None, axes=(-2,-1), norm="backward")
   19: irfft2(a, s=None, axes=(-2, -1), norm="backward")
   20: 
   21: i = inverse transform
   22: r = transform of purely real data
   23: h = Hermite transform
   24: n = n-dimensional transform
   25: 2 = 2-dimensional transform
   26: (Note: 2D routines are just nD routines with different default
   27: behavior.)
   28: 
   29: """
   30: __all__ = ['fft', 'ifft', 'rfft', 'irfft', 'hfft', 'ihfft', 'rfftn',
   31:            'irfftn', 'rfft2', 'irfft2', 'fft2', 'ifft2', 'fftn', 'ifftn']
   32: 
   33: import functools
   34: import warnings
   35: 
   36: from numpy._core import (
   37:     asarray,
   38:     conjugate,
   39:     empty_like,
   40:     overrides,
   41:     reciprocal,
   42:     result_type,
   43:     sqrt,
   44:     take,
   45: )
   46: from numpy.lib.array_utils import normalize_axis_index
   47: 
   48: from . import _pocketfft_umath as pfu
   49: 
   50: array_function_dispatch = functools.partial(
   51:     overrides.array_function_dispatch, module='numpy.fft')
   52: 
   53: 
   54: # `inv_norm` is a float by which the result of the transform needs to be
   55: # divided. This replaces the original, more intuitive 'fct` parameter to avoid
   56: # divisions by zero (or alternatively additional checks) in the case of
   57: # zero-length axes during its computation.
   58: def _raw_fft(a, n, axis, is_real, is_forward, norm, out=None):
   59:     if n < 1:
   60:         raise ValueError(f"Invalid number of FFT data points ({n}) specified.")
   61: 
   62:     # Calculate the normalization factor, passing in the array dtype to
   63:     # avoid precision loss in the possible sqrt or reciprocal.
   64:     if not is_forward:
   65:         norm = _swap_direction(norm)
   66: 
   67:     real_dtype = result_type(a.real.dtype, 1.0)
   68:     if norm is None or norm == "backward":
   69:         fct = 1
   70:     elif norm == "ortho":
   71:         fct = reciprocal(sqrt(n, dtype=real_dtype))
   72:     elif norm == "forward":
   73:         fct = reciprocal(n, dtype=real_dtype)
   74:     else:
   75:         raise ValueError(f'Invalid norm value {norm}; should be "backward",'
   76:                          '"ortho" or "forward".')
   77: 
   78:     n_out = n
   79:     if is_real:
   80:         if is_forward:
   81:             ufunc = pfu.rfft_n_even if n % 2 == 0 else pfu.rfft_n_odd
   82:             n_out = n // 2 + 1
   83:         else:
   84:             ufunc = pfu.irfft
   85:     else:
   86:         ufunc = pfu.fft if is_forward else pfu.ifft
   87: 
   88:     axis = normalize_axis_index(axis, a.ndim)
   89: 
   90:     if out is None:
   91:         if is_real and not is_forward:  # irfft, complex in, real output.
   92:             out_dtype = real_dtype
   93:         else:  # Others, complex output.
   94:             out_dtype = result_type(a.dtype, 1j)
   95:         out = empty_like(a, shape=a.shape[:axis] + (n_out,) + a.shape[axis + 1:],
   96:                          dtype=out_dtype)
   97:     elif ((shape := getattr(out, "shape", None)) is not None
   98:           and (len(shape) != a.ndim or shape[axis] != n_out)):
   99:         raise ValueError("output array has wrong shape.")
  100: 
  101:     return ufunc(a, fct, axes=[(axis,), (), (axis,)], out=out)
  102: 
  103: 
  104: _SWAP_DIRECTION_MAP = {"backward": "forward", None: "forward",
  105:                        "ortho": "ortho", "forward": "backward"}
  106: 
  107: 
  108: def _swap_direction(norm):
  109:     try:
  110:         return _SWAP_DIRECTION_MAP[norm]
  111:     except KeyError:
  112:         raise ValueError(f'Invalid norm value {norm}; should be "backward", '
  113:                          '"ortho" or "forward".') from None
  114: 
  115: 
  116: def _fft_dispatcher(a, n=None, axis=None, norm=None, out=None):
  117:     return (a, out)
  118: 
  119: 
  120: @array_function_dispatch(_fft_dispatcher)
  121: def fft(a, n=None, axis=-1, norm=None, out=None):
  122:     """
  123:     Compute the one-dimensional discrete Fourier Transform.
  124: 
  125:     This function computes the one-dimensional *n*-point discrete Fourier
  126:     Transform (DFT) with the efficient Fast Fourier Transform (FFT)
  127:     algorithm [CT].
  128: 
  129:     Parameters
  130:     ----------
  131:     a : array_like
  132:         Input array, can be complex.
  133:     n : int, optional
  134:         Length of the transformed axis of the output.
  135:         If `n` is smaller than the length of the input, the input is cropped.
  136:         If it is larger, the input is padded with zeros.  If `n` is not given,
  137:         the length of the input along the axis specified by `axis` is used.
  138:     axis : int, optional
  139:         Axis over which to compute the FFT.  If not given, the last axis is
  140:         used.
  141:     norm : {"backward", "ortho", "forward"}, optional
  142:         Normalization mode (see `numpy.fft`). Default is "backward".
  143:         Indicates which direction of the forward/backward pair of transforms
  144:         is scaled and with what normalization factor.
  145: 
  146:         .. versionadded:: 1.20.0
  147: 
  148:             The "backward", "forward" values were added.
  149:     out : complex ndarray, optional
  150:         If provided, the result will be placed in this array. It should be
  151:         of the appropriate shape and dtype.
  152: 
  153:         .. versionadded:: 2.0.0
  154: 
  155:     Returns
  156:     -------
  157:     out : complex ndarray
  158:         The truncated or zero-padded input, transformed along the axis
  159:         indicated by `axis`, or the last one if `axis` is not specified.
  160: 
  161:     Raises
  162:     ------
  163:     IndexError
  164:         If `axis` is not a valid axis of `a`.
  165: 
  166:     See Also
  167:     --------
  168:     numpy.fft : for definition of the DFT and conventions used.
  169:     ifft : The inverse of `fft`.
  170:     fft2 : The two-dimensional FFT.
  171:     fftn : The *n*-dimensional FFT.
  172:     rfftn : The *n*-dimensional FFT of real input.
  173:     fftfreq : Frequency bins for given FFT parameters.
  174: 
  175:     Notes
  176:     -----
  177:     FFT (Fast Fourier Transform) refers to a way the discrete Fourier
  178:     Transform (DFT) can be calculated efficiently, by using symmetries in the
  179:     calculated terms.  The symmetry is highest when `n` is a power of 2, and
  180:     the transform is therefore most efficient for these sizes.
  181: 
  182:     The DFT is defined, with the conventions used in this implementation, in
  183:     the documentation for the `numpy.fft` module.
  184: 
  185:     References
  186:     ----------
  187:     .. [CT] Cooley, James W., and John W. Tukey, 1965, "An algorithm for the
  188:             machine calculation of complex Fourier series," *Math. Comput.*
  189:             19: 297-301.
  190: 
  191:     Examples
  192:     --------
  193:     >>> import numpy as np
  194:     >>> np.fft.fft(np.exp(2j * np.pi * np.arange(8) / 8))
  195:     array([-2.33486982e-16+1.14423775e-17j,  8.00000000e+00-1.25557246e-15j,
  196:             2.33486982e-16+2.33486982e-16j,  0.00000000e+00+1.22464680e-16j,
  197:            -1.14423775e-17+2.33486982e-16j,  0.00000000e+00+5.20784380e-16j,
  198:             1.14423775e-17+1.14423775e-17j,  0.00000000e+00+1.22464680e-16j])
  199: 
  200:     In this example, real input has an FFT which is Hermitian, i.e., symmetric
  201:     in the real part and anti-symmetric in the imaginary part, as described in
  202:     the `numpy.fft` documentation:
  203: 
  204:     >>> import matplotlib.pyplot as plt
  205:     >>> t = np.arange(256)
  206:     >>> sp = np.fft.fft(np.sin(t))
  207:     >>> freq = np.fft.fftfreq(t.shape[-1])
  208:     >>> _ = plt.plot(freq, sp.real, freq, sp.imag)
  209:     >>> plt.show()
  210: 
  211:     """
  212:     a = asarray(a)
  213:     if n is None:
  214:         n = a.shape[axis]
  215:     output = _raw_fft(a, n, axis, False, True, norm, out)
  216:     return output
  217: 
  218: 
  219: @array_function_dispatch(_fft_dispatcher)
  220: def ifft(a, n=None, axis=-1, norm=None, out=None):
  221:     """
  222:     Compute the one-dimensional inverse discrete Fourier Transform.
  223: 
  224:     This function computes the inverse of the one-dimensional *n*-point
  225:     discrete Fourier transform computed by `fft`.  In other words,
  226:     ``ifft(fft(a)) == a`` to within numerical accuracy.
  227:     For a general description of the algorithm and definitions,
  228:     see `numpy.fft`.
  229: 
  230:     The input should be ordered in the same way as is returned by `fft`,
  231:     i.e.,
  232: 
  233:     * ``a[0]`` should contain the zero frequency term,
  234:     * ``a[1:n//2]`` should contain the positive-frequency terms,
  235:     * ``a[n//2 + 1:]`` should contain the negative-frequency terms, in
  236:       increasing order starting from the most negative frequency.
  237: 
  238:     For an even number of input points, ``A[n//2]`` represents the sum of
  239:     the values at the positive and negative Nyquist frequencies, as the two
  240:     are aliased together. See `numpy.fft` for details.
  241: 
  242:     Parameters
  243:     ----------
  244:     a : array_like
  245:         Input array, can be complex.
  246:     n : int, optional
  247:         Length of the transformed axis of the output.
  248:         If `n` is smaller than the length of the input, the input is cropped.
  249:         If it is larger, the input is padded with zeros.  If `n` is not given,
  250:         the length of the input along the axis specified by `axis` is used.
  251:         See notes about padding issues.
  252:     axis : int, optional
  253:         Axis over which to compute the inverse DFT.  If not given, the last
  254:         axis is used.
  255:     norm : {"backward", "ortho", "forward"}, optional
  256:         Normalization mode (see `numpy.fft`). Default is "backward".
  257:         Indicates which direction of the forward/backward pair of transforms
  258:         is scaled and with what normalization factor.
  259: 
  260:         .. versionadded:: 1.20.0
  261: 
  262:             The "backward", "forward" values were added.
  263: 
  264:     out : complex ndarray, optional
  265:         If provided, the result will be placed in this array. It should be
  266:         of the appropriate shape and dtype.
  267: 
  268:         .. versionadded:: 2.0.0
  269: 
  270:     Returns
  271:     -------
  272:     out : complex ndarray
  273:         The truncated or zero-padded input, transformed along the axis
  274:         indicated by `axis`, or the last one if `axis` is not specified.
  275: 
  276:     Raises
  277:     ------
  278:     IndexError
  279:         If `axis` is not a valid axis of `a`.
  280: 
  281:     See Also
  282:     --------
  283:     numpy.fft : An introduction, with definitions and general explanations.
  284:     fft : The one-dimensional (forward) FFT, of which `ifft` is the inverse
  285:     ifft2 : The two-dimensional inverse FFT.
  286:     ifftn : The n-dimensional inverse FFT.
  287: 
  288:     Notes
  289:     -----
  290:     If the input parameter `n` is larger than the size of the input, the input
  291:     is padded by appending zeros at the end.  Even though this is the common
  292:     approach, it might lead to surprising results.  If a different padding is
  293:     desired, it must be performed before calling `ifft`.
  294: 
  295:     Examples
  296:     --------
  297:     >>> import numpy as np
  298:     >>> np.fft.ifft([0, 4, 0, 0])
  299:     array([ 1.+0.j,  0.+1.j, -1.+0.j,  0.-1.j]) # may vary
  300: 
  301:     Create and plot a band-limited signal with random phases:
  302: 
  303:     >>> import matplotlib.pyplot as plt
  304:     >>> t = np.arange(400)
  305:     >>> n = np.zeros((400,), dtype=complex)
  306:     >>> n[40:60] = np.exp(1j*np.random.uniform(0, 2*np.pi, (20,)))
  307:     >>> s = np.fft.ifft(n)
  308:     >>> plt.plot(t, s.real, label='real')
  309:     [<matplotlib.lines.Line2D object at ...>]
  310:     >>> plt.plot(t, s.imag, '--', label='imaginary')
  311:     [<matplotlib.lines.Line2D object at ...>]
  312:     >>> plt.legend()
  313:     <matplotlib.legend.Legend object at ...>
  314:     >>> plt.show()
  315: 
  316:     """
  317:     a = asarray(a)
  318:     if n is None:
  319:         n = a.shape[axis]
  320:     output = _raw_fft(a, n, axis, False, False, norm, out=out)
  321:     return output
  322: 
  323: 
  324: @array_function_dispatch(_fft_dispatcher)
  325: def rfft(a, n=None, axis=-1, norm=None, out=None):
  326:     """
  327:     Compute the one-dimensional discrete Fourier Transform for real input.
  328: 
  329:     This function computes the one-dimensional *n*-point discrete Fourier
  330:     Transform (DFT) of a real-valued array by means of an efficient algorithm
  331:     called the Fast Fourier Transform (FFT).
  332: 
  333:     Parameters
  334:     ----------
  335:     a : array_like
  336:         Input array
  337:     n : int, optional
  338:         Number of points along transformation axis in the input to use.
  339:         If `n` is smaller than the length of the input, the input is cropped.
  340:         If it is larger, the input is padded with zeros. If `n` is not given,
  341:         the length of the input along the axis specified by `axis` is used.
  342:     axis : int, optional
  343:         Axis over which to compute the FFT. If not given, the last axis is
  344:         used.
  345:     norm : {"backward", "ortho", "forward"}, optional
  346:         Normalization mode (see `numpy.fft`). Default is "backward".
  347:         Indicates which direction of the forward/backward pair of transforms
  348:         is scaled and with what normalization factor.
  349: 
  350:         .. versionadded:: 1.20.0
  351: 
  352:             The "backward", "forward" values were added.
  353: 
  354:     out : complex ndarray, optional
  355:         If provided, the result will be placed in this array. It should be
  356:         of the appropriate shape and dtype.
  357: 
  358:         .. versionadded:: 2.0.0
  359: 
  360:     Returns
  361:     -------
  362:     out : complex ndarray
  363:         The truncated or zero-padded input, transformed along the axis
  364:         indicated by `axis`, or the last one if `axis` is not specified.
  365:         If `n` is even, the length of the transformed axis is ``(n/2)+1``.
  366:         If `n` is odd, the length is ``(n+1)/2``.
  367: 
  368:     Raises
  369:     ------
  370:     IndexError
  371:         If `axis` is not a valid axis of `a`.
  372: 
  373:     See Also
  374:     --------
  375:     numpy.fft : For definition of the DFT and conventions used.
  376:     irfft : The inverse of `rfft`.
  377:     fft : The one-dimensional FFT of general (complex) input.
  378:     fftn : The *n*-dimensional FFT.
  379:     rfftn : The *n*-dimensional FFT of real input.
  380: 
  381:     Notes
  382:     -----
  383:     When the DFT is computed for purely real input, the output is
  384:     Hermitian-symmetric, i.e. the negative frequency terms are just the complex
  385:     conjugates of the corresponding positive-frequency terms, and the
  386:     negative-frequency terms are therefore redundant.  This function does not
  387:     compute the negative frequency terms, and the length of the transformed
  388:     axis of the output is therefore ``n//2 + 1``.
  389: 
  390:     When ``A = rfft(a)`` and fs is the sampling frequency, ``A[0]`` contains
  391:     the zero-frequency term 0*fs, which is real due to Hermitian symmetry.
  392: 
  393:     If `n` is even, ``A[-1]`` contains the term representing both positive
  394:     and negative Nyquist frequency (+fs/2 and -fs/2), and must also be purely
  395:     real. If `n` is odd, there is no term at fs/2; ``A[-1]`` contains
  396:     the largest positive frequency (fs/2*(n-1)/n), and is complex in the
  397:     general case.
  398: 
  399:     If the input `a` contains an imaginary part, it is silently discarded.
  400: 
  401:     Examples
  402:     --------
  403:     >>> import numpy as np
  404:     >>> np.fft.fft([0, 1, 0, 0])
  405:     array([ 1.+0.j,  0.-1.j, -1.+0.j,  0.+1.j]) # may vary
  406:     >>> np.fft.rfft([0, 1, 0, 0])
  407:     array([ 1.+0.j,  0.-1.j, -1.+0.j]) # may vary
  408: 
  409:     Notice how the final element of the `fft` output is the complex conjugate
  410:     of the second element, for real input. For `rfft`, this symmetry is
  411:     exploited to compute only the non-negative frequency terms.
  412: 
  413:     """
  414:     a = asarray(a)
  415:     if n is None:
  416:         n = a.shape[axis]
  417:     output = _raw_fft(a, n, axis, True, True, norm, out=out)
  418:     return output
  419: 
  420: 
  421: @array_function_dispatch(_fft_dispatcher)
  422: def irfft(a, n=None, axis=-1, norm=None, out=None):
  423:     """
  424:     Computes the inverse of `rfft`.
  425: 
  426:     This function computes the inverse of the one-dimensional *n*-point
  427:     discrete Fourier Transform of real input computed by `rfft`.
  428:     In other words, ``irfft(rfft(a), len(a)) == a`` to within numerical
  429:     accuracy. (See Notes below for why ``len(a)`` is necessary here.)
  430: 
  431:     The input is expected to be in the form returned by `rfft`, i.e. the
  432:     real zero-frequency term followed by the complex positive frequency terms
  433:     in order of increasing frequency.  Since the discrete Fourier Transform of
  434:     real input is Hermitian-symmetric, the negative frequency terms are taken
  435:     to be the complex conjugates of the corresponding positive frequency terms.
  436: 
  437:     Parameters
  438:     ----------
  439:     a : array_like
  440:         The input array.
  441:     n : int, optional
  442:         Length of the transformed axis of the output.
  443:         For `n` output points, ``n//2+1`` input points are necessary.  If the
  444:         input is longer than this, it is cropped.  If it is shorter than this,
  445:         it is padded with zeros.  If `n` is not given, it is taken to be
  446:         ``2*(m-1)`` where ``m`` is the length of the input along the axis
  447:         specified by `axis`.
  448:     axis : int, optional
  449:         Axis over which to compute the inverse FFT. If not given, the last
  450:         axis is used.
  451:     norm : {"backward", "ortho", "forward"}, optional
  452:         Normalization mode (see `numpy.fft`). Default is "backward".
  453:         Indicates which direction of the forward/backward pair of transforms
  454:         is scaled and with what normalization factor.
  455: 
  456:         .. versionadded:: 1.20.0
  457: 
  458:             The "backward", "forward" values were added.
  459: 
  460:     out : ndarray, optional
  461:         If provided, the result will be placed in this array. It should be
  462:         of the appropriate shape and dtype.
  463: 
  464:         .. versionadded:: 2.0.0
  465: 
  466:     Returns
  467:     -------
  468:     out : ndarray
  469:         The truncated or zero-padded input, transformed along the axis
  470:         indicated by `axis`, or the last one if `axis` is not specified.
  471:         The length of the transformed axis is `n`, or, if `n` is not given,
  472:         ``2*(m-1)`` where ``m`` is the length of the transformed axis of the
  473:         input. To get an odd number of output points, `n` must be specified.
  474: 
  475:     Raises
  476:     ------
  477:     IndexError
  478:         If `axis` is not a valid axis of `a`.
  479: 
  480:     See Also
  481:     --------
  482:     numpy.fft : For definition of the DFT and conventions used.
  483:     rfft : The one-dimensional FFT of real input, of which `irfft` is inverse.
  484:     fft : The one-dimensional FFT.
  485:     irfft2 : The inverse of the two-dimensional FFT of real input.
  486:     irfftn : The inverse of the *n*-dimensional FFT of real input.
  487: 
  488:     Notes
  489:     -----
  490:     Returns the real valued `n`-point inverse discrete Fourier transform
  491:     of `a`, where `a` contains the non-negative frequency terms of a
  492:     Hermitian-symmetric sequence. `n` is the length of the result, not the
  493:     input.
  494: 
  495:     If you specify an `n` such that `a` must be zero-padded or truncated, the
  496:     extra/removed values will be added/removed at high frequencies. One can
  497:     thus resample a series to `m` points via Fourier interpolation by:
  498:     ``a_resamp = irfft(rfft(a), m)``.
  499: 
  500:     The correct interpretation of the hermitian input depends on the length of
  501:     the original data, as given by `n`. This is because each input shape could
  502:     correspond to either an odd or even length signal. By default, `irfft`
  503:     assumes an even output length which puts the last entry at the Nyquist
  504:     frequency; aliasing with its symmetric counterpart. By Hermitian symmetry,
  505:     the value is thus treated as purely real. To avoid losing information, the
  506:     correct length of the real input **must** be given.
  507: 
  508:     Examples
  509:     --------
  510:     >>> import numpy as np
  511:     >>> np.fft.ifft([1, -1j, -1, 1j])
  512:     array([0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j]) # may vary
  513:     >>> np.fft.irfft([1, -1j, -1])
  514:     array([0.,  1.,  0.,  0.])
  515: 
  516:     Notice how the last term in the input to the ordinary `ifft` is the
  517:     complex conjugate of the second term, and the output has zero imaginary
  518:     part everywhere.  When calling `irfft`, the negative frequencies are not
  519:     specified, and the output array is purely real.
  520: 
  521:     """
  522:     a = asarray(a)
  523:     if n is None:
  524:         n = (a.shape[axis] - 1) * 2
  525:     output = _raw_fft(a, n, axis, True, False, norm, out=out)
  526:     return output
  527: 
  528: 
  529: @array_function_dispatch(_fft_dispatcher)
  530: def hfft(a, n=None, axis=-1, norm=None, out=None):
  531:     """
  532:     Compute the FFT of a signal that has Hermitian symmetry, i.e., a real
  533:     spectrum.
  534: 
  535:     Parameters
  536:     ----------
  537:     a : array_like
  538:         The input array.
  539:     n : int, optional
  540:         Length of the transformed axis of the output. For `n` output
  541:         points, ``n//2 + 1`` input points are necessary.  If the input is
  542:         longer than this, it is cropped.  If it is shorter than this, it is
  543:         padded with zeros.  If `n` is not given, it is taken to be ``2*(m-1)``
  544:         where ``m`` is the length of the input along the axis specified by
  545:         `axis`.
  546:     axis : int, optional
  547:         Axis over which to compute the FFT. If not given, the last
  548:         axis is used.
  549:     norm : {"backward", "ortho", "forward"}, optional
  550:         Normalization mode (see `numpy.fft`). Default is "backward".
  551:         Indicates which direction of the forward/backward pair of transforms
  552:         is scaled and with what normalization factor.
  553: 
  554:         .. versionadded:: 1.20.0
  555: 
  556:             The "backward", "forward" values were added.
  557: 
  558:     out : ndarray, optional
  559:         If provided, the result will be placed in this array. It should be
  560:         of the appropriate shape and dtype.
  561: 
  562:         .. versionadded:: 2.0.0
  563: 
  564:     Returns
  565:     -------
  566:     out : ndarray
  567:         The truncated or zero-padded input, transformed along the axis
  568:         indicated by `axis`, or the last one if `axis` is not specified.
  569:         The length of the transformed axis is `n`, or, if `n` is not given,
  570:         ``2*m - 2`` where ``m`` is the length of the transformed axis of
  571:         the input. To get an odd number of output points, `n` must be
  572:         specified, for instance as ``2*m - 1`` in the typical case,
  573: 
  574:     Raises
  575:     ------
  576:     IndexError
  577:         If `axis` is not a valid axis of `a`.
  578: 
  579:     See also
  580:     --------
  581:     rfft : Compute the one-dimensional FFT for real input.
  582:     ihfft : The inverse of `hfft`.
  583: 
  584:     Notes
  585:     -----
  586:     `hfft`/`ihfft` are a pair analogous to `rfft`/`irfft`, but for the
  587:     opposite case: here the signal has Hermitian symmetry in the time
  588:     domain and is real in the frequency domain. So here it's `hfft` for
  589:     which you must supply the length of the result if it is to be odd.
  590: 
  591:     * even: ``ihfft(hfft(a, 2*len(a) - 2)) == a``, within roundoff error,
  592:     * odd: ``ihfft(hfft(a, 2*len(a) - 1)) == a``, within roundoff error.
  593: 
  594:     The correct interpretation of the hermitian input depends on the length of
  595:     the original data, as given by `n`. This is because each input shape could
  596:     correspond to either an odd or even length signal. By default, `hfft`
  597:     assumes an even output length which puts the last entry at the Nyquist
  598:     frequency; aliasing with its symmetric counterpart. By Hermitian symmetry,
  599:     the value is thus treated as purely real. To avoid losing information, the
  600:     shape of the full signal **must** be given.
  601: 
  602:     Examples
  603:     --------
  604:     >>> import numpy as np
  605:     >>> signal = np.array([1, 2, 3, 4, 3, 2])
  606:     >>> np.fft.fft(signal)
  607:     array([15.+0.j,  -4.+0.j,   0.+0.j,  -1.-0.j,   0.+0.j,  -4.+0.j]) # may vary
  608:     >>> np.fft.hfft(signal[:4]) # Input first half of signal
  609:     array([15.,  -4.,   0.,  -1.,   0.,  -4.])
  610:     >>> np.fft.hfft(signal, 6)  # Input entire signal and truncate
  611:     array([15.,  -4.,   0.,  -1.,   0.,  -4.])
  612: 
  613: 
  614:     >>> signal = np.array([[1, 1.j], [-1.j, 2]])
  615:     >>> np.conj(signal.T) - signal   # check Hermitian symmetry
  616:     array([[ 0.-0.j,  -0.+0.j], # may vary
  617:            [ 0.+0.j,  0.-0.j]])
  618:     >>> freq_spectrum = np.fft.hfft(signal)
  619:     >>> freq_spectrum
  620:     array([[ 1.,  1.],
  621:            [ 2., -2.]])
  622: 
  623:     """
  624:     a = asarray(a)
  625:     if n is None:
  626:         n = (a.shape[axis] - 1) * 2
  627:     new_norm = _swap_direction(norm)
  628:     output = irfft(conjugate(a), n, axis, norm=new_norm, out=None)
  629:     return output
  630: 
  631: 
  632: @array_function_dispatch(_fft_dispatcher)
  633: def ihfft(a, n=None, axis=-1, norm=None, out=None):
  634:     """
  635:     Compute the inverse FFT of a signal that has Hermitian symmetry.
  636: 
  637:     Parameters
  638:     ----------
  639:     a : array_like
  640:         Input array.
  641:     n : int, optional
  642:         Length of the inverse FFT, the number of points along
  643:         transformation axis in the input to use.  If `n` is smaller than
  644:         the length of the input, the input is cropped.  If it is larger,
  645:         the input is padded with zeros. If `n` is not given, the length of
  646:         the input along the axis specified by `axis` is used.
  647:     axis : int, optional
  648:         Axis over which to compute the inverse FFT. If not given, the last
  649:         axis is used.
  650:     norm : {"backward", "ortho", "forward"}, optional
  651:         Normalization mode (see `numpy.fft`). Default is "backward".
  652:         Indicates which direction of the forward/backward pair of transforms
  653:         is scaled and with what normalization factor.
  654: 
  655:         .. versionadded:: 1.20.0
  656: 
  657:             The "backward", "forward" values were added.
  658: 
  659:     out : complex ndarray, optional
  660:         If provided, the result will be placed in this array. It should be
  661:         of the appropriate shape and dtype.
  662: 
  663:         .. versionadded:: 2.0.0
  664: 
  665:     Returns
  666:     -------
  667:     out : complex ndarray
  668:         The truncated or zero-padded input, transformed along the axis
  669:         indicated by `axis`, or the last one if `axis` is not specified.
  670:         The length of the transformed axis is ``n//2 + 1``.
  671: 
  672:     See also
  673:     --------
  674:     hfft, irfft
  675: 
  676:     Notes
  677:     -----
  678:     `hfft`/`ihfft` are a pair analogous to `rfft`/`irfft`, but for the
  679:     opposite case: here the signal has Hermitian symmetry in the time
  680:     domain and is real in the frequency domain. So here it's `hfft` for
  681:     which you must supply the length of the result if it is to be odd:
  682: 
  683:     * even: ``ihfft(hfft(a, 2*len(a) - 2)) == a``, within roundoff error,
  684:     * odd: ``ihfft(hfft(a, 2*len(a) - 1)) == a``, within roundoff error.
  685: 
  686:     Examples
  687:     --------
  688:     >>> import numpy as np
  689:     >>> spectrum = np.array([ 15, -4, 0, -1, 0, -4])
  690:     >>> np.fft.ifft(spectrum)
  691:     array([1.+0.j,  2.+0.j,  3.+0.j,  4.+0.j,  3.+0.j,  2.+0.j]) # may vary
  692:     >>> np.fft.ihfft(spectrum)
  693:     array([ 1.-0.j,  2.-0.j,  3.-0.j,  4.-0.j]) # may vary
  694: 
  695:     """
  696:     a = asarray(a)
  697:     if n is None:
  698:         n = a.shape[axis]
  699:     new_norm = _swap_direction(norm)
  700:     out = rfft(a, n, axis, norm=new_norm, out=out)
  701:     return conjugate(out, out=out)
  702: 
  703: 
  704: def _cook_nd_args(a, s=None, axes=None, invreal=0):
  705:     if s is None:
  706:         shapeless = True
  707:         if axes is None:
  708:             s = list(a.shape)
  709:         else:
  710:             s = take(a.shape, axes)
  711:     else:
  712:         shapeless = False
  713:     s = list(s)
  714:     if axes is None:
  715:         if not shapeless:
  716:             msg = ("`axes` should not be `None` if `s` is not `None` "
  717:                    "(Deprecated in NumPy 2.0). In a future version of NumPy, "
  718:                    "this will raise an error and `s[i]` will correspond to "
  719:                    "the size along the transformed axis specified by "
  720:                    "`axes[i]`. To retain current behaviour, pass a sequence "
  721:                    "[0, ..., k-1] to `axes` for an array of dimension k.")
  722:             warnings.warn(msg, DeprecationWarning, stacklevel=3)
  723:         axes = list(range(-len(s), 0))
  724:     if len(s) != len(axes):
  725:         raise ValueError("Shape and axes have different lengths.")
  726:     if invreal and shapeless:
  727:         s[-1] = (a.shape[axes[-1]] - 1) * 2
  728:     if None in s:
  729:         msg = ("Passing an array containing `None` values to `s` is "
  730:                "deprecated in NumPy 2.0 and will raise an error in "
  731:                "a future version of NumPy. To use the default behaviour "
  732:                "of the corresponding 1-D transform, pass the value matching "
  733:                "the default for its `n` parameter. To use the default "
  734:                "behaviour for every axis, the `s` argument can be omitted.")
  735:         warnings.warn(msg, DeprecationWarning, stacklevel=3)
  736:     # use the whole input array along axis `i` if `s[i] == -1`
  737:     s = [a.shape[_a] if _s == -1 else _s for _s, _a in zip(s, axes)]
  738:     return s, axes
  739: 
  740: 
  741: def _raw_fftnd(a, s=None, axes=None, function=fft, norm=None, out=None):
  742:     a = asarray(a)
  743:     s, axes = _cook_nd_args(a, s, axes)
  744:     itl = list(range(len(axes)))
  745:     itl.reverse()
  746:     for ii in itl:
  747:         a = function(a, n=s[ii], axis=axes[ii], norm=norm, out=out)
  748:     return a
  749: 
  750: 
  751: def _fftn_dispatcher(a, s=None, axes=None, norm=None, out=None):
  752:     return (a, out)
  753: 
  754: 
  755: @array_function_dispatch(_fftn_dispatcher)
  756: def fftn(a, s=None, axes=None, norm=None, out=None):
  757:     """
  758:     Compute the N-dimensional discrete Fourier Transform.
  759: 
  760:     This function computes the *N*-dimensional discrete Fourier Transform over
  761:     any number of axes in an *M*-dimensional array by means of the Fast Fourier
  762:     Transform (FFT).
  763: 
  764:     Parameters
  765:     ----------
  766:     a : array_like
  767:         Input array, can be complex.
  768:     s : sequence of ints, optional
  769:         Shape (length of each transformed axis) of the output
  770:         (``s[0]`` refers to axis 0, ``s[1]`` to axis 1, etc.).
  771:         This corresponds to ``n`` for ``fft(x, n)``.
  772:         Along any axis, if the given shape is smaller than that of the input,
  773:         the input is cropped. If it is larger, the input is padded with zeros.
  774: 
  775:         .. versionchanged:: 2.0
  776: 
  777:             If it is ``-1``, the whole input is used (no padding/trimming).
  778: 
  779:         If `s` is not given, the shape of the input along the axes specified
  780:         by `axes` is used.
  781: 
  782:         .. deprecated:: 2.0
  783: 
  784:             If `s` is not ``None``, `axes` must not be ``None`` either.
  785: 
  786:         .. deprecated:: 2.0
  787: 
  788:             `s` must contain only ``int`` s, not ``None`` values. ``None``
  789:             values currently mean that the default value for ``n`` is used
  790:             in the corresponding 1-D transform, but this behaviour is
  791:             deprecated.
  792: 
  793:     axes : sequence of ints, optional
  794:         Axes over which to compute the FFT.  If not given, the last ``len(s)``
  795:         axes are used, or all axes if `s` is also not specified.
  796:         Repeated indices in `axes` means that the transform over that axis is
  797:         performed multiple times.
  798: 
  799:         .. deprecated:: 2.0
  800: 
  801:             If `s` is specified, the corresponding `axes` to be transformed
  802:             must be explicitly specified too.
  803: 
  804:     norm : {"backward", "ortho", "forward"}, optional
  805:         Normalization mode (see `numpy.fft`). Default is "backward".
  806:         Indicates which direction of the forward/backward pair of transforms
  807:         is scaled and with what normalization factor.
  808: 
  809:         .. versionadded:: 1.20.0
  810: 
  811:             The "backward", "forward" values were added.
  812: 
  813:     out : complex ndarray, optional
  814:         If provided, the result will be placed in this array. It should be
  815:         of the appropriate shape and dtype for all axes (and hence is
  816:         incompatible with passing in all but the trivial ``s``).
  817: 
  818:         .. versionadded:: 2.0.0
  819: 
  820:     Returns
  821:     -------
  822:     out : complex ndarray
  823:         The truncated or zero-padded input, transformed along the axes
  824:         indicated by `axes`, or by a combination of `s` and `a`,
  825:         as explained in the parameters section above.
  826: 
  827:     Raises
  828:     ------
  829:     ValueError
  830:         If `s` and `axes` have different length.
  831:     IndexError
  832:         If an element of `axes` is larger than than the number of axes of `a`.
  833: 
  834:     See Also
  835:     --------
  836:     numpy.fft : Overall view of discrete Fourier transforms, with definitions
  837:         and conventions used.
  838:     ifftn : The inverse of `fftn`, the inverse *n*-dimensional FFT.
  839:     fft : The one-dimensional FFT, with definitions and conventions used.
  840:     rfftn : The *n*-dimensional FFT of real input.
  841:     fft2 : The two-dimensional FFT.
  842:     fftshift : Shifts zero-frequency terms to centre of array
  843: 
  844:     Notes
  845:     -----
  846:     The output, analogously to `fft`, contains the term for zero frequency in
  847:     the low-order corner of all axes, the positive frequency terms in the
  848:     first half of all axes, the term for the Nyquist frequency in the middle
  849:     of all axes and the negative frequency terms in the second half of all
  850:     axes, in order of decreasingly negative frequency.
  851: 
  852:     See `numpy.fft` for details, definitions and conventions used.
  853: 
  854:     Examples
  855:     --------
  856:     >>> import numpy as np
  857:     >>> a = np.mgrid[:3, :3, :3][0]
  858:     >>> np.fft.fftn(a, axes=(1, 2))
  859:     array([[[ 0.+0.j,   0.+0.j,   0.+0.j], # may vary
  860:             [ 0.+0.j,   0.+0.j,   0.+0.j],
  861:             [ 0.+0.j,   0.+0.j,   0.+0.j]],
  862:            [[ 9.+0.j,   0.+0.j,   0.+0.j],
  863:             [ 0.+0.j,   0.+0.j,   0.+0.j],
  864:             [ 0.+0.j,   0.+0.j,   0.+0.j]],
  865:            [[18.+0.j,   0.+0.j,   0.+0.j],
  866:             [ 0.+0.j,   0.+0.j,   0.+0.j],
  867:             [ 0.+0.j,   0.+0.j,   0.+0.j]]])
  868:     >>> np.fft.fftn(a, (2, 2), axes=(0, 1))
  869:     array([[[ 2.+0.j,  2.+0.j,  2.+0.j], # may vary
  870:             [ 0.+0.j,  0.+0.j,  0.+0.j]],
  871:            [[-2.+0.j, -2.+0.j, -2.+0.j],
  872:             [ 0.+0.j,  0.+0.j,  0.+0.j]]])
  873: 
  874:     >>> import matplotlib.pyplot as plt
  875:     >>> [X, Y] = np.meshgrid(2 * np.pi * np.arange(200) / 12,
  876:     ...                      2 * np.pi * np.arange(200) / 34)
  877:     >>> S = np.sin(X) + np.cos(Y) + np.random.uniform(0, 1, X.shape)
  878:     >>> FS = np.fft.fftn(S)
  879:     >>> plt.imshow(np.log(np.abs(np.fft.fftshift(FS))**2))
  880:     <matplotlib.image.AxesImage object at 0x...>
  881:     >>> plt.show()
  882: 
  883:     """
  884:     return _raw_fftnd(a, s, axes, fft, norm, out=out)
  885: 
  886: 
  887: @array_function_dispatch(_fftn_dispatcher)
  888: def ifftn(a, s=None, axes=None, norm=None, out=None):
  889:     """
  890:     Compute the N-dimensional inverse discrete Fourier Transform.
  891: 
  892:     This function computes the inverse of the N-dimensional discrete
  893:     Fourier Transform over any number of axes in an M-dimensional array by
  894:     means of the Fast Fourier Transform (FFT).  In other words,
  895:     ``ifftn(fftn(a)) == a`` to within numerical accuracy.
  896:     For a description of the definitions and conventions used, see `numpy.fft`.
  897: 
  898:     The input, analogously to `ifft`, should be ordered in the same way as is
  899:     returned by `fftn`, i.e. it should have the term for zero frequency
  900:     in all axes in the low-order corner, the positive frequency terms in the
  901:     first half of all axes, the term for the Nyquist frequency in the middle
  902:     of all axes and the negative frequency terms in the second half of all
  903:     axes, in order of decreasingly negative frequency.
  904: 
  905:     Parameters
  906:     ----------
  907:     a : array_like
  908:         Input array, can be complex.
  909:     s : sequence of ints, optional
  910:         Shape (length of each transformed axis) of the output
  911:         (``s[0]`` refers to axis 0, ``s[1]`` to axis 1, etc.).
  912:         This corresponds to ``n`` for ``ifft(x, n)``.
  913:         Along any axis, if the given shape is smaller than that of the input,
  914:         the input is cropped. If it is larger, the input is padded with zeros.
  915: 
  916:         .. versionchanged:: 2.0
  917: 
  918:             If it is ``-1``, the whole input is used (no padding/trimming).
  919: 
  920:         If `s` is not given, the shape of the input along the axes specified
  921:         by `axes` is used. See notes for issue on `ifft` zero padding.
  922: 
  923:         .. deprecated:: 2.0
  924: 
  925:             If `s` is not ``None``, `axes` must not be ``None`` either.
  926: 
  927:         .. deprecated:: 2.0
  928: 
  929:             `s` must contain only ``int`` s, not ``None`` values. ``None``
  930:             values currently mean that the default value for ``n`` is used
  931:             in the corresponding 1-D transform, but this behaviour is
  932:             deprecated.
  933: 
  934:     axes : sequence of ints, optional
  935:         Axes over which to compute the IFFT.  If not given, the last ``len(s)``
  936:         axes are used, or all axes if `s` is also not specified.
  937:         Repeated indices in `axes` means that the inverse transform over that
  938:         axis is performed multiple times.
  939: 
  940:         .. deprecated:: 2.0
  941: 
  942:             If `s` is specified, the corresponding `axes` to be transformed
  943:             must be explicitly specified too.
  944: 
  945:     norm : {"backward", "ortho", "forward"}, optional
  946:         Normalization mode (see `numpy.fft`). Default is "backward".
  947:         Indicates which direction of the forward/backward pair of transforms
  948:         is scaled and with what normalization factor.
  949: 
  950:         .. versionadded:: 1.20.0
  951: 
  952:             The "backward", "forward" values were added.
  953: 
  954:     out : complex ndarray, optional
  955:         If provided, the result will be placed in this array. It should be
  956:         of the appropriate shape and dtype for all axes (and hence is
  957:         incompatible with passing in all but the trivial ``s``).
  958: 
  959:         .. versionadded:: 2.0.0
  960: 
  961:     Returns
  962:     -------
  963:     out : complex ndarray
  964:         The truncated or zero-padded input, transformed along the axes
  965:         indicated by `axes`, or by a combination of `s` or `a`,
  966:         as explained in the parameters section above.
  967: 
  968:     Raises
  969:     ------
  970:     ValueError
  971:         If `s` and `axes` have different length.
  972:     IndexError
  973:         If an element of `axes` is larger than than the number of axes of `a`.
  974: 
  975:     See Also
  976:     --------
  977:     numpy.fft : Overall view of discrete Fourier transforms, with definitions
  978:          and conventions used.
  979:     fftn : The forward *n*-dimensional FFT, of which `ifftn` is the inverse.
  980:     ifft : The one-dimensional inverse FFT.
  981:     ifft2 : The two-dimensional inverse FFT.
  982:     ifftshift : Undoes `fftshift`, shifts zero-frequency terms to beginning
  983:         of array.
  984: 
  985:     Notes
  986:     -----
  987:     See `numpy.fft` for definitions and conventions used.
  988: 
  989:     Zero-padding, analogously with `ifft`, is performed by appending zeros to
  990:     the input along the specified dimension.  Although this is the common
  991:     approach, it might lead to surprising results.  If another form of zero
  992:     padding is desired, it must be performed before `ifftn` is called.
  993: 
  994:     Examples
  995:     --------
  996:     >>> import numpy as np
  997:     >>> a = np.eye(4)
  998:     >>> np.fft.ifftn(np.fft.fftn(a, axes=(0,)), axes=(1,))
  999:     array([[1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j], # may vary
 1000:            [0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j],
 1001:            [0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],
 1002:            [0.+0.j,  0.+0.j,  0.+0.j,  1.+0.j]])
 1003: 
 1004: 
 1005:     Create and plot an image with band-limited frequency content:
 1006: 
 1007:     >>> import matplotlib.pyplot as plt
 1008:     >>> n = np.zeros((200,200), dtype=complex)
 1009:     >>> n[60:80, 20:40] = np.exp(1j*np.random.uniform(0, 2*np.pi, (20, 20)))
 1010:     >>> im = np.fft.ifftn(n).real
 1011:     >>> plt.imshow(im)
 1012:     <matplotlib.image.AxesImage object at 0x...>
 1013:     >>> plt.show()
 1014: 
 1015:     """
 1016:     return _raw_fftnd(a, s, axes, ifft, norm, out=out)
 1017: 
 1018: 
 1019: @array_function_dispatch(_fftn_dispatcher)
 1020: def fft2(a, s=None, axes=(-2, -1), norm=None, out=None):
 1021:     """
 1022:     Compute the 2-dimensional discrete Fourier Transform.
 1023: 
 1024:     This function computes the *n*-dimensional discrete Fourier Transform
 1025:     over any axes in an *M*-dimensional array by means of the
 1026:     Fast Fourier Transform (FFT).  By default, the transform is computed over
 1027:     the last two axes of the input array, i.e., a 2-dimensional FFT.
 1028: 
 1029:     Parameters
 1030:     ----------
 1031:     a : array_like
 1032:         Input array, can be complex
 1033:     s : sequence of ints, optional
 1034:         Shape (length of each transformed axis) of the output
 1035:         (``s[0]`` refers to axis 0, ``s[1]`` to axis 1, etc.).
 1036:         This corresponds to ``n`` for ``fft(x, n)``.
 1037:         Along each axis, if the given shape is smaller than that of the input,
 1038:         the input is cropped. If it is larger, the input is padded with zeros.
 1039: 
 1040:         .. versionchanged:: 2.0
 1041: 
 1042:             If it is ``-1``, the whole input is used (no padding/trimming).
 1043: 
 1044:         If `s` is not given, the shape of the input along the axes specified
 1045:         by `axes` is used.
 1046: 
 1047:         .. deprecated:: 2.0
 1048: 
 1049:             If `s` is not ``None``, `axes` must not be ``None`` either.
 1050: 
 1051:         .. deprecated:: 2.0
 1052: 
 1053:             `s` must contain only ``int`` s, not ``None`` values. ``None``
 1054:             values currently mean that the default value for ``n`` is used
 1055:             in the corresponding 1-D transform, but this behaviour is
 1056:             deprecated.
 1057: 
 1058:     axes : sequence of ints, optional
 1059:         Axes over which to compute the FFT.  If not given, the last two
 1060:         axes are used.  A repeated index in `axes` means the transform over
 1061:         that axis is performed multiple times.  A one-element sequence means
 1062:         that a one-dimensional FFT is performed. Default: ``(-2, -1)``.
 1063: 
 1064:         .. deprecated:: 2.0
 1065: 
 1066:             If `s` is specified, the corresponding `axes` to be transformed
 1067:             must not be ``None``.
 1068: 
 1069:     norm : {"backward", "ortho", "forward"}, optional
 1070:         Normalization mode (see `numpy.fft`). Default is "backward".
 1071:         Indicates which direction of the forward/backward pair of transforms
 1072:         is scaled and with what normalization factor.
 1073: 
 1074:         .. versionadded:: 1.20.0
 1075: 
 1076:             The "backward", "forward" values were added.
 1077: 
 1078:     out : complex ndarray, optional
 1079:         If provided, the result will be placed in this array. It should be
 1080:         of the appropriate shape and dtype for all axes (and hence only the
 1081:         last axis can have ``s`` not equal to the shape at that axis).
 1082: 
 1083:         .. versionadded:: 2.0.0
 1084: 
 1085:     Returns
 1086:     -------
 1087:     out : complex ndarray
 1088:         The truncated or zero-padded input, transformed along the axes
 1089:         indicated by `axes`, or the last two axes if `axes` is not given.
 1090: 
 1091:     Raises
 1092:     ------
 1093:     ValueError
 1094:         If `s` and `axes` have different length, or `axes` not given and
 1095:         ``len(s) != 2``.
 1096:     IndexError
 1097:         If an element of `axes` is larger than than the number of axes of `a`.
 1098: 
 1099:     See Also
 1100:     --------
 1101:     numpy.fft : Overall view of discrete Fourier transforms, with definitions
 1102:          and conventions used.
 1103:     ifft2 : The inverse two-dimensional FFT.
 1104:     fft : The one-dimensional FFT.
 1105:     fftn : The *n*-dimensional FFT.
 1106:     fftshift : Shifts zero-frequency terms to the center of the array.
 1107:         For two-dimensional input, swaps first and third quadrants, and second
 1108:         and fourth quadrants.
 1109: 
 1110:     Notes
 1111:     -----
 1112:     `fft2` is just `fftn` with a different default for `axes`.
 1113: 
 1114:     The output, analogously to `fft`, contains the term for zero frequency in
 1115:     the low-order corner of the transformed axes, the positive frequency terms
 1116:     in the first half of these axes, the term for the Nyquist frequency in the
 1117:     middle of the axes and the negative frequency terms in the second half of
 1118:     the axes, in order of decreasingly negative frequency.
 1119: 
 1120:     See `fftn` for details and a plotting example, and `numpy.fft` for
 1121:     definitions and conventions used.
 1122: 
 1123: 
 1124:     Examples
 1125:     --------
 1126:     >>> import numpy as np
 1127:     >>> a = np.mgrid[:5, :5][0]
 1128:     >>> np.fft.fft2(a)
 1129:     array([[ 50.  +0.j        ,   0.  +0.j        ,   0.  +0.j        , # may vary
 1130:               0.  +0.j        ,   0.  +0.j        ],
 1131:            [-12.5+17.20477401j,   0.  +0.j        ,   0.  +0.j        ,
 1132:               0.  +0.j        ,   0.  +0.j        ],
 1133:            [-12.5 +4.0614962j ,   0.  +0.j        ,   0.  +0.j        ,
 1134:               0.  +0.j        ,   0.  +0.j        ],
 1135:            [-12.5 -4.0614962j ,   0.  +0.j        ,   0.  +0.j        ,
 1136:               0.  +0.j        ,   0.  +0.j        ],
 1137:            [-12.5-17.20477401j,   0.  +0.j        ,   0.  +0.j        ,
 1138:               0.  +0.j        ,   0.  +0.j        ]])
 1139: 
 1140:     """
 1141:     return _raw_fftnd(a, s, axes, fft, norm, out=out)
 1142: 
 1143: 
 1144: @array_function_dispatch(_fftn_dispatcher)
 1145: def ifft2(a, s=None, axes=(-2, -1), norm=None, out=None):
 1146:     """
 1147:     Compute the 2-dimensional inverse discrete Fourier Transform.
 1148: 
 1149:     This function computes the inverse of the 2-dimensional discrete Fourier
 1150:     Transform over any number of axes in an M-dimensional array by means of
 1151:     the Fast Fourier Transform (FFT).  In other words, ``ifft2(fft2(a)) == a``
 1152:     to within numerical accuracy.  By default, the inverse transform is
 1153:     computed over the last two axes of the input array.
 1154: 
 1155:     The input, analogously to `ifft`, should be ordered in the same way as is
 1156:     returned by `fft2`, i.e. it should have the term for zero frequency
 1157:     in the low-order corner of the two axes, the positive frequency terms in
 1158:     the first half of these axes, the term for the Nyquist frequency in the
 1159:     middle of the axes and the negative frequency terms in the second half of
 1160:     both axes, in order of decreasingly negative frequency.
 1161: 
 1162:     Parameters
 1163:     ----------
 1164:     a : array_like
 1165:         Input array, can be complex.
 1166:     s : sequence of ints, optional
 1167:         Shape (length of each axis) of the output (``s[0]`` refers to axis 0,
 1168:         ``s[1]`` to axis 1, etc.).  This corresponds to `n` for ``ifft(x, n)``.
 1169:         Along each axis, if the given shape is smaller than that of the input,
 1170:         the input is cropped. If it is larger, the input is padded with zeros.
 1171: 
 1172:         .. versionchanged:: 2.0
 1173: 
 1174:             If it is ``-1``, the whole input is used (no padding/trimming).
 1175: 
 1176:         If `s` is not given, the shape of the input along the axes specified
 1177:         by `axes` is used.  See notes for issue on `ifft` zero padding.
 1178: 
 1179:         .. deprecated:: 2.0
 1180: 
 1181:             If `s` is not ``None``, `axes` must not be ``None`` either.
 1182: 
 1183:         .. deprecated:: 2.0
 1184: 
 1185:             `s` must contain only ``int`` s, not ``None`` values. ``None``
 1186:             values currently mean that the default value for ``n`` is used
 1187:             in the corresponding 1-D transform, but this behaviour is
 1188:             deprecated.
 1189: 
 1190:     axes : sequence of ints, optional
 1191:         Axes over which to compute the FFT.  If not given, the last two
 1192:         axes are used.  A repeated index in `axes` means the transform over
 1193:         that axis is performed multiple times.  A one-element sequence means
 1194:         that a one-dimensional FFT is performed. Default: ``(-2, -1)``.
 1195: 
 1196:         .. deprecated:: 2.0
 1197: 
 1198:             If `s` is specified, the corresponding `axes` to be transformed
 1199:             must not be ``None``.
 1200: 
 1201:     norm : {"backward", "ortho", "forward"}, optional
 1202:         Normalization mode (see `numpy.fft`). Default is "backward".
 1203:         Indicates which direction of the forward/backward pair of transforms
 1204:         is scaled and with what normalization factor.
 1205: 
 1206:         .. versionadded:: 1.20.0
 1207: 
 1208:             The "backward", "forward" values were added.
 1209: 
 1210:     out : complex ndarray, optional
 1211:         If provided, the result will be placed in this array. It should be
 1212:         of the appropriate shape and dtype for all axes (and hence is
 1213:         incompatible with passing in all but the trivial ``s``).
 1214: 
 1215:         .. versionadded:: 2.0.0
 1216: 
 1217:     Returns
 1218:     -------
 1219:     out : complex ndarray
 1220:         The truncated or zero-padded input, transformed along the axes
 1221:         indicated by `axes`, or the last two axes if `axes` is not given.
 1222: 
 1223:     Raises
 1224:     ------
 1225:     ValueError
 1226:         If `s` and `axes` have different length, or `axes` not given and
 1227:         ``len(s) != 2``.
 1228:     IndexError
 1229:         If an element of `axes` is larger than than the number of axes of `a`.
 1230: 
 1231:     See Also
 1232:     --------
 1233:     numpy.fft : Overall view of discrete Fourier transforms, with definitions
 1234:          and conventions used.
 1235:     fft2 : The forward 2-dimensional FFT, of which `ifft2` is the inverse.
 1236:     ifftn : The inverse of the *n*-dimensional FFT.
 1237:     fft : The one-dimensional FFT.
 1238:     ifft : The one-dimensional inverse FFT.
 1239: 
 1240:     Notes
 1241:     -----
 1242:     `ifft2` is just `ifftn` with a different default for `axes`.
 1243: 
 1244:     See `ifftn` for details and a plotting example, and `numpy.fft` for
 1245:     definition and conventions used.
 1246: 
 1247:     Zero-padding, analogously with `ifft`, is performed by appending zeros to
 1248:     the input along the specified dimension.  Although this is the common
 1249:     approach, it might lead to surprising results.  If another form of zero
 1250:     padding is desired, it must be performed before `ifft2` is called.
 1251: 
 1252:     Examples
 1253:     --------
 1254:     >>> import numpy as np
 1255:     >>> a = 4 * np.eye(4)
 1256:     >>> np.fft.ifft2(a)
 1257:     array([[1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j], # may vary
 1258:            [0.+0.j,  0.+0.j,  0.+0.j,  1.+0.j],
 1259:            [0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],
 1260:            [0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j]])
 1261: 
 1262:     """
 1263:     return _raw_fftnd(a, s, axes, ifft, norm, out=None)
 1264: 
 1265: 
 1266: @array_function_dispatch(_fftn_dispatcher)
 1267: def rfftn(a, s=None, axes=None, norm=None, out=None):
 1268:     """
 1269:     Compute the N-dimensional discrete Fourier Transform for real input.
 1270: 
 1271:     This function computes the N-dimensional discrete Fourier Transform over
 1272:     any number of axes in an M-dimensional real array by means of the Fast
 1273:     Fourier Transform (FFT).  By default, all axes are transformed, with the
 1274:     real transform performed over the last axis, while the remaining
 1275:     transforms are complex.
 1276: 
 1277:     Parameters
 1278:     ----------
 1279:     a : array_like
 1280:         Input array, taken to be real.
 1281:     s : sequence of ints, optional
 1282:         Shape (length along each transformed axis) to use from the input.
 1283:         (``s[0]`` refers to axis 0, ``s[1]`` to axis 1, etc.).
 1284:         The final element of `s` corresponds to `n` for ``rfft(x, n)``, while
 1285:         for the remaining axes, it corresponds to `n` for ``fft(x, n)``.
 1286:         Along any axis, if the given shape is smaller than that of the input,
 1287:         the input is cropped. If it is larger, the input is padded with zeros.
 1288: 
 1289:         .. versionchanged:: 2.0
 1290: 
 1291:             If it is ``-1``, the whole input is used (no padding/trimming).
 1292: 
 1293:         If `s` is not given, the shape of the input along the axes specified
 1294:         by `axes` is used.
 1295: 
 1296:         .. deprecated:: 2.0
 1297: 
 1298:             If `s` is not ``None``, `axes` must not be ``None`` either.
 1299: 
 1300:         .. deprecated:: 2.0
 1301: 
 1302:             `s` must contain only ``int`` s, not ``None`` values. ``None``
 1303:             values currently mean that the default value for ``n`` is used
 1304:             in the corresponding 1-D transform, but this behaviour is
 1305:             deprecated.
 1306: 
 1307:     axes : sequence of ints, optional
 1308:         Axes over which to compute the FFT.  If not given, the last ``len(s)``
 1309:         axes are used, or all axes if `s` is also not specified.
 1310: 
 1311:         .. deprecated:: 2.0
 1312: 
 1313:             If `s` is specified, the corresponding `axes` to be transformed
 1314:             must be explicitly specified too.
 1315: 
 1316:     norm : {"backward", "ortho", "forward"}, optional
 1317:         Normalization mode (see `numpy.fft`). Default is "backward".
 1318:         Indicates which direction of the forward/backward pair of transforms
 1319:         is scaled and with what normalization factor.
 1320: 
 1321:         .. versionadded:: 1.20.0
 1322: 
 1323:             The "backward", "forward" values were added.
 1324: 
 1325:     out : complex ndarray, optional
 1326:         If provided, the result will be placed in this array. It should be
 1327:         of the appropriate shape and dtype for all axes (and hence is
 1328:         incompatible with passing in all but the trivial ``s``).
 1329: 
 1330:         .. versionadded:: 2.0.0
 1331: 
 1332:     Returns
 1333:     -------
 1334:     out : complex ndarray
 1335:         The truncated or zero-padded input, transformed along the axes
 1336:         indicated by `axes`, or by a combination of `s` and `a`,
 1337:         as explained in the parameters section above.
 1338:         The length of the last axis transformed will be ``s[-1]//2+1``,
 1339:         while the remaining transformed axes will have lengths according to
 1340:         `s`, or unchanged from the input.
 1341: 
 1342:     Raises
 1343:     ------
 1344:     ValueError
 1345:         If `s` and `axes` have different length.
 1346:     IndexError
 1347:         If an element of `axes` is larger than than the number of axes of `a`.
 1348: 
 1349:     See Also
 1350:     --------
 1351:     irfftn : The inverse of `rfftn`, i.e. the inverse of the n-dimensional FFT
 1352:          of real input.
 1353:     fft : The one-dimensional FFT, with definitions and conventions used.
 1354:     rfft : The one-dimensional FFT of real input.
 1355:     fftn : The n-dimensional FFT.
 1356:     rfft2 : The two-dimensional FFT of real input.
 1357: 
 1358:     Notes
 1359:     -----
 1360:     The transform for real input is performed over the last transformation
 1361:     axis, as by `rfft`, then the transform over the remaining axes is
 1362:     performed as by `fftn`.  The order of the output is as for `rfft` for the
 1363:     final transformation axis, and as for `fftn` for the remaining
 1364:     transformation axes.
 1365: 
 1366:     See `fft` for details, definitions and conventions used.
 1367: 
 1368:     Examples
 1369:     --------
 1370:     >>> import numpy as np
 1371:     >>> a = np.ones((2, 2, 2))
 1372:     >>> np.fft.rfftn(a)
 1373:     array([[[8.+0.j,  0.+0.j], # may vary
 1374:             [0.+0.j,  0.+0.j]],
 1375:            [[0.+0.j,  0.+0.j],
 1376:             [0.+0.j,  0.+0.j]]])
 1377: 
 1378:     >>> np.fft.rfftn(a, axes=(2, 0))
 1379:     array([[[4.+0.j,  0.+0.j], # may vary
 1380:             [4.+0.j,  0.+0.j]],
 1381:            [[0.+0.j,  0.+0.j],
 1382:             [0.+0.j,  0.+0.j]]])
 1383: 
 1384:     """
 1385:     a = asarray(a)
 1386:     s, axes = _cook_nd_args(a, s, axes)
 1387:     a = rfft(a, s[-1], axes[-1], norm, out=out)
 1388:     for ii in range(len(axes) - 2, -1, -1):
 1389:         a = fft(a, s[ii], axes[ii], norm, out=out)
 1390:     return a
 1391: 
 1392: 
 1393: @array_function_dispatch(_fftn_dispatcher)
 1394: def rfft2(a, s=None, axes=(-2, -1), norm=None, out=None):
 1395:     """
 1396:     Compute the 2-dimensional FFT of a real array.
 1397: 
 1398:     Parameters
 1399:     ----------
 1400:     a : array
 1401:         Input array, taken to be real.
 1402:     s : sequence of ints, optional
 1403:         Shape of the FFT.
 1404: 
 1405:         .. versionchanged:: 2.0
 1406: 
 1407:             If it is ``-1``, the whole input is used (no padding/trimming).
 1408: 
 1409:         .. deprecated:: 2.0
 1410: 
 1411:             If `s` is not ``None``, `axes` must not be ``None`` either.
 1412: 
 1413:         .. deprecated:: 2.0
 1414: 
 1415:             `s` must contain only ``int`` s, not ``None`` values. ``None``
 1416:             values currently mean that the default value for ``n`` is used
 1417:             in the corresponding 1-D transform, but this behaviour is
 1418:             deprecated.
 1419: 
 1420:     axes : sequence of ints, optional
 1421:         Axes over which to compute the FFT. Default: ``(-2, -1)``.
 1422: 
 1423:         .. deprecated:: 2.0
 1424: 
 1425:             If `s` is specified, the corresponding `axes` to be transformed
 1426:             must not be ``None``.
 1427: 
 1428:     norm : {"backward", "ortho", "forward"}, optional
 1429:         Normalization mode (see `numpy.fft`). Default is "backward".
 1430:         Indicates which direction of the forward/backward pair of transforms
 1431:         is scaled and with what normalization factor.
 1432: 
 1433:         .. versionadded:: 1.20.0
 1434: 
 1435:             The "backward", "forward" values were added.
 1436: 
 1437:     out : complex ndarray, optional
 1438:         If provided, the result will be placed in this array. It should be
 1439:         of the appropriate shape and dtype for the last inverse transform.
 1440:         incompatible with passing in all but the trivial ``s``).
 1441: 
 1442:         .. versionadded:: 2.0.0
 1443: 
 1444:     Returns
 1445:     -------
 1446:     out : ndarray
 1447:         The result of the real 2-D FFT.
 1448: 
 1449:     See Also
 1450:     --------
 1451:     rfftn : Compute the N-dimensional discrete Fourier Transform for real
 1452:             input.
 1453: 
 1454:     Notes
 1455:     -----
 1456:     This is really just `rfftn` with different default behavior.
 1457:     For more details see `rfftn`.
 1458: 
 1459:     Examples
 1460:     --------
 1461:     >>> import numpy as np
 1462:     >>> a = np.mgrid[:5, :5][0]
 1463:     >>> np.fft.rfft2(a)
 1464:     array([[ 50.  +0.j        ,   0.  +0.j        ,   0.  +0.j        ],
 1465:            [-12.5+17.20477401j,   0.  +0.j        ,   0.  +0.j        ],
 1466:            [-12.5 +4.0614962j ,   0.  +0.j        ,   0.  +0.j        ],
 1467:            [-12.5 -4.0614962j ,   0.  +0.j        ,   0.  +0.j        ],
 1468:            [-12.5-17.20477401j,   0.  +0.j        ,   0.  +0.j        ]])
 1469:     """
 1470:     return rfftn(a, s, axes, norm, out=out)
 1471: 
 1472: 
 1473: @array_function_dispatch(_fftn_dispatcher)
 1474: def irfftn(a, s=None, axes=None, norm=None, out=None):
 1475:     """
 1476:     Computes the inverse of `rfftn`.
 1477: 
 1478:     This function computes the inverse of the N-dimensional discrete
 1479:     Fourier Transform for real input over any number of axes in an
 1480:     M-dimensional array by means of the Fast Fourier Transform (FFT).  In
 1481:     other words, ``irfftn(rfftn(a), a.shape) == a`` to within numerical
 1482:     accuracy. (The ``a.shape`` is necessary like ``len(a)`` is for `irfft`,
 1483:     and for the same reason.)
 1484: 
 1485:     The input should be ordered in the same way as is returned by `rfftn`,
 1486:     i.e. as for `irfft` for the final transformation axis, and as for `ifftn`
 1487:     along all the other axes.
 1488: 
 1489:     Parameters
 1490:     ----------
 1491:     a : array_like
 1492:         Input array.
 1493:     s : sequence of ints, optional
 1494:         Shape (length of each transformed axis) of the output
 1495:         (``s[0]`` refers to axis 0, ``s[1]`` to axis 1, etc.). `s` is also the
 1496:         number of input points used along this axis, except for the last axis,
 1497:         where ``s[-1]//2+1`` points of the input are used.
 1498:         Along any axis, if the shape indicated by `s` is smaller than that of
 1499:         the input, the input is cropped.  If it is larger, the input is padded
 1500:         with zeros.
 1501: 
 1502:         .. versionchanged:: 2.0
 1503: 
 1504:             If it is ``-1``, the whole input is used (no padding/trimming).
 1505: 
 1506:         If `s` is not given, the shape of the input along the axes
 1507:         specified by axes is used. Except for the last axis which is taken to
 1508:         be ``2*(m-1)`` where ``m`` is the length of the input along that axis.
 1509: 
 1510:         .. deprecated:: 2.0
 1511: 
 1512:             If `s` is not ``None``, `axes` must not be ``None`` either.
 1513: 
 1514:         .. deprecated:: 2.0
 1515: 
 1516:             `s` must contain only ``int`` s, not ``None`` values. ``None``
 1517:             values currently mean that the default value for ``n`` is used
 1518:             in the corresponding 1-D transform, but this behaviour is
 1519:             deprecated.
 1520: 
 1521:     axes : sequence of ints, optional
 1522:         Axes over which to compute the inverse FFT. If not given, the last
 1523:         `len(s)` axes are used, or all axes if `s` is also not specified.
 1524:         Repeated indices in `axes` means that the inverse transform over that
 1525:         axis is performed multiple times.
 1526: 
 1527:         .. deprecated:: 2.0
 1528: 
 1529:             If `s` is specified, the corresponding `axes` to be transformed
 1530:             must be explicitly specified too.
 1531: 
 1532:     norm : {"backward", "ortho", "forward"}, optional
 1533:         Normalization mode (see `numpy.fft`). Default is "backward".
 1534:         Indicates which direction of the forward/backward pair of transforms
 1535:         is scaled and with what normalization factor.
 1536: 
 1537:         .. versionadded:: 1.20.0
 1538: 
 1539:             The "backward", "forward" values were added.
 1540: 
 1541:     out : ndarray, optional
 1542:         If provided, the result will be placed in this array. It should be
 1543:         of the appropriate shape and dtype for the last transformation.
 1544: 
 1545:         .. versionadded:: 2.0.0
 1546: 
 1547:     Returns
 1548:     -------
 1549:     out : ndarray
 1550:         The truncated or zero-padded input, transformed along the axes
 1551:         indicated by `axes`, or by a combination of `s` or `a`,
 1552:         as explained in the parameters section above.
 1553:         The length of each transformed axis is as given by the corresponding
 1554:         element of `s`, or the length of the input in every axis except for the
 1555:         last one if `s` is not given.  In the final transformed axis the length
 1556:         of the output when `s` is not given is ``2*(m-1)`` where ``m`` is the
 1557:         length of the final transformed axis of the input.  To get an odd
 1558:         number of output points in the final axis, `s` must be specified.
 1559: 
 1560:     Raises
 1561:     ------
 1562:     ValueError
 1563:         If `s` and `axes` have different length.
 1564:     IndexError
 1565:         If an element of `axes` is larger than than the number of axes of `a`.
 1566: 
 1567:     See Also
 1568:     --------
 1569:     rfftn : The forward n-dimensional FFT of real input,
 1570:             of which `ifftn` is the inverse.
 1571:     fft : The one-dimensional FFT, with definitions and conventions used.
 1572:     irfft : The inverse of the one-dimensional FFT of real input.
 1573:     irfft2 : The inverse of the two-dimensional FFT of real input.
 1574: 
 1575:     Notes
 1576:     -----
 1577:     See `fft` for definitions and conventions used.
 1578: 
 1579:     See `rfft` for definitions and conventions used for real input.
 1580: 
 1581:     The correct interpretation of the hermitian input depends on the shape of
 1582:     the original data, as given by `s`. This is because each input shape could
 1583:     correspond to either an odd or even length signal. By default, `irfftn`
 1584:     assumes an even output length which puts the last entry at the Nyquist
 1585:     frequency; aliasing with its symmetric counterpart. When performing the
 1586:     final complex to real transform, the last value is thus treated as purely
 1587:     real. To avoid losing information, the correct shape of the real input
 1588:     **must** be given.
 1589: 
 1590:     Examples
 1591:     --------
 1592:     >>> import numpy as np
 1593:     >>> a = np.zeros((3, 2, 2))
 1594:     >>> a[0, 0, 0] = 3 * 2 * 2
 1595:     >>> np.fft.irfftn(a)
 1596:     array([[[1.,  1.],
 1597:             [1.,  1.]],
 1598:            [[1.,  1.],
 1599:             [1.,  1.]],
 1600:            [[1.,  1.],
 1601:             [1.,  1.]]])
 1602: 
 1603:     """
 1604:     a = asarray(a)
 1605:     s, axes = _cook_nd_args(a, s, axes, invreal=1)
 1606:     for ii in range(len(axes) - 1):
 1607:         a = ifft(a, s[ii], axes[ii], norm)
 1608:     a = irfft(a, s[-1], axes[-1], norm, out=out)
 1609:     return a
 1610: 
 1611: 
 1612: @array_function_dispatch(_fftn_dispatcher)
 1613: def irfft2(a, s=None, axes=(-2, -1), norm=None, out=None):
 1614:     """
 1615:     Computes the inverse of `rfft2`.
 1616: 
 1617:     Parameters
 1618:     ----------
 1619:     a : array_like
 1620:         The input array
 1621:     s : sequence of ints, optional
 1622:         Shape of the real output to the inverse FFT.
 1623: 
 1624:         .. versionchanged:: 2.0
 1625: 
 1626:             If it is ``-1``, the whole input is used (no padding/trimming).
 1627: 
 1628:         .. deprecated:: 2.0
 1629: 
 1630:             If `s` is not ``None``, `axes` must not be ``None`` either.
 1631: 
 1632:         .. deprecated:: 2.0
 1633: 
 1634:             `s` must contain only ``int`` s, not ``None`` values. ``None``
 1635:             values currently mean that the default value for ``n`` is used
 1636:             in the corresponding 1-D transform, but this behaviour is
 1637:             deprecated.
 1638: 
 1639:     axes : sequence of ints, optional
 1640:         The axes over which to compute the inverse fft.
 1641:         Default: ``(-2, -1)``, the last two axes.
 1642: 
 1643:         .. deprecated:: 2.0
 1644: 
 1645:             If `s` is specified, the corresponding `axes` to be transformed
 1646:             must not be ``None``.
 1647: 
 1648:     norm : {"backward", "ortho", "forward"}, optional
 1649:         Normalization mode (see `numpy.fft`). Default is "backward".
 1650:         Indicates which direction of the forward/backward pair of transforms
 1651:         is scaled and with what normalization factor.
 1652: 
 1653:         .. versionadded:: 1.20.0
 1654: 
 1655:             The "backward", "forward" values were added.
 1656: 
 1657:     out : ndarray, optional
 1658:         If provided, the result will be placed in this array. It should be
 1659:         of the appropriate shape and dtype for the last transformation.
 1660: 
 1661:         .. versionadded:: 2.0.0
 1662: 
 1663:     Returns
 1664:     -------
 1665:     out : ndarray
 1666:         The result of the inverse real 2-D FFT.
 1667: 
 1668:     See Also
 1669:     --------
 1670:     rfft2 : The forward two-dimensional FFT of real input,
 1671:             of which `irfft2` is the inverse.
 1672:     rfft : The one-dimensional FFT for real input.
 1673:     irfft : The inverse of the one-dimensional FFT of real input.
 1674:     irfftn : Compute the inverse of the N-dimensional FFT of real input.
 1675: 
 1676:     Notes
 1677:     -----
 1678:     This is really `irfftn` with different defaults.
 1679:     For more details see `irfftn`.
 1680: 
 1681:     Examples
 1682:     --------
 1683:     >>> import numpy as np
 1684:     >>> a = np.mgrid[:5, :5][0]
 1685:     >>> A = np.fft.rfft2(a)
 1686:     >>> np.fft.irfft2(A, s=a.shape)
 1687:     array([[0., 0., 0., 0., 0.],
 1688:            [1., 1., 1., 1., 1.],
 1689:            [2., 2., 2., 2., 2.],
 1690:            [3., 3., 3., 3., 3.],
 1691:            [4., 4., 4., 4., 4.]])
 1692:     """
 1693:     return irfftn(a, s, axes, norm, out=None)
