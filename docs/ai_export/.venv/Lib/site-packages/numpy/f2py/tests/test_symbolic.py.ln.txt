    1: import pytest
    2: 
    3: from numpy.f2py.symbolic import (
    4:     ArithOp,
    5:     Expr,
    6:     Language,
    7:     Op,
    8:     as_apply,
    9:     as_array,
   10:     as_complex,
   11:     as_deref,
   12:     as_eq,
   13:     as_expr,
   14:     as_factors,
   15:     as_ge,
   16:     as_gt,
   17:     as_le,
   18:     as_lt,
   19:     as_ne,
   20:     as_number,
   21:     as_numer_denom,
   22:     as_ref,
   23:     as_string,
   24:     as_symbol,
   25:     as_terms,
   26:     as_ternary,
   27:     eliminate_quotes,
   28:     fromstring,
   29:     insert_quotes,
   30:     normalize,
   31: )
   32: 
   33: from . import util
   34: 
   35: 
   36: class TestSymbolic(util.F2PyTest):
   37:     def test_eliminate_quotes(self):
   38:         def worker(s):
   39:             r, d = eliminate_quotes(s)
   40:             s1 = insert_quotes(r, d)
   41:             assert s1 == s
   42: 
   43:         for kind in ["", "mykind_"]:
   44:             worker(kind + '"1234" // "ABCD"')
   45:             worker(kind + '"1234" // ' + kind + '"ABCD"')
   46:             worker(kind + "\"1234\" // 'ABCD'")
   47:             worker(kind + '"1234" // ' + kind + "'ABCD'")
   48:             worker(kind + '"1\\"2\'AB\'34"')
   49:             worker("a = " + kind + "'1\\'2\"AB\"34'")
   50: 
   51:     def test_sanity(self):
   52:         x = as_symbol("x")
   53:         y = as_symbol("y")
   54:         z = as_symbol("z")
   55: 
   56:         assert x.op == Op.SYMBOL
   57:         assert repr(x) == "Expr(Op.SYMBOL, 'x')"
   58:         assert x == x
   59:         assert x != y
   60:         assert hash(x) is not None
   61: 
   62:         n = as_number(123)
   63:         m = as_number(456)
   64:         assert n.op == Op.INTEGER
   65:         assert repr(n) == "Expr(Op.INTEGER, (123, 4))"
   66:         assert n == n
   67:         assert n != m
   68:         assert hash(n) is not None
   69: 
   70:         fn = as_number(12.3)
   71:         fm = as_number(45.6)
   72:         assert fn.op == Op.REAL
   73:         assert repr(fn) == "Expr(Op.REAL, (12.3, 4))"
   74:         assert fn == fn
   75:         assert fn != fm
   76:         assert hash(fn) is not None
   77: 
   78:         c = as_complex(1, 2)
   79:         c2 = as_complex(3, 4)
   80:         assert c.op == Op.COMPLEX
   81:         assert repr(c) == ("Expr(Op.COMPLEX, (Expr(Op.INTEGER, (1, 4)),"
   82:                            " Expr(Op.INTEGER, (2, 4))))")
   83:         assert c == c
   84:         assert c != c2
   85:         assert hash(c) is not None
   86: 
   87:         s = as_string("'123'")
   88:         s2 = as_string('"ABC"')
   89:         assert s.op == Op.STRING
   90:         assert repr(s) == "Expr(Op.STRING, (\"'123'\", 1))", repr(s)
   91:         assert s == s
   92:         assert s != s2
   93: 
   94:         a = as_array((n, m))
   95:         b = as_array((n, ))
   96:         assert a.op == Op.ARRAY
   97:         assert repr(a) == ("Expr(Op.ARRAY, (Expr(Op.INTEGER, (123, 4)),"
   98:                            " Expr(Op.INTEGER, (456, 4))))")
   99:         assert a == a
  100:         assert a != b
  101: 
  102:         t = as_terms(x)
  103:         u = as_terms(y)
  104:         assert t.op == Op.TERMS
  105:         assert repr(t) == "Expr(Op.TERMS, {Expr(Op.SYMBOL, 'x'): 1})"
  106:         assert t == t
  107:         assert t != u
  108:         assert hash(t) is not None
  109: 
  110:         v = as_factors(x)
  111:         w = as_factors(y)
  112:         assert v.op == Op.FACTORS
  113:         assert repr(v) == "Expr(Op.FACTORS, {Expr(Op.SYMBOL, 'x'): 1})"
  114:         assert v == v
  115:         assert w != v
  116:         assert hash(v) is not None
  117: 
  118:         t = as_ternary(x, y, z)
  119:         u = as_ternary(x, z, y)
  120:         assert t.op == Op.TERNARY
  121:         assert t == t
  122:         assert t != u
  123:         assert hash(t) is not None
  124: 
  125:         e = as_eq(x, y)
  126:         f = as_lt(x, y)
  127:         assert e.op == Op.RELATIONAL
  128:         assert e == e
  129:         assert e != f
  130:         assert hash(e) is not None
  131: 
  132:     def test_tostring_fortran(self):
  133:         x = as_symbol("x")
  134:         y = as_symbol("y")
  135:         z = as_symbol("z")
  136:         n = as_number(123)
  137:         m = as_number(456)
  138:         a = as_array((n, m))
  139:         c = as_complex(n, m)
  140: 
  141:         assert str(x) == "x"
  142:         assert str(n) == "123"
  143:         assert str(a) == "[123, 456]"
  144:         assert str(c) == "(123, 456)"
  145: 
  146:         assert str(Expr(Op.TERMS, {x: 1})) == "x"
  147:         assert str(Expr(Op.TERMS, {x: 2})) == "2 * x"
  148:         assert str(Expr(Op.TERMS, {x: -1})) == "-x"
  149:         assert str(Expr(Op.TERMS, {x: -2})) == "-2 * x"
  150:         assert str(Expr(Op.TERMS, {x: 1, y: 1})) == "x + y"
  151:         assert str(Expr(Op.TERMS, {x: -1, y: -1})) == "-x - y"
  152:         assert str(Expr(Op.TERMS, {x: 2, y: 3})) == "2 * x + 3 * y"
  153:         assert str(Expr(Op.TERMS, {x: -2, y: 3})) == "-2 * x + 3 * y"
  154:         assert str(Expr(Op.TERMS, {x: 2, y: -3})) == "2 * x - 3 * y"
  155: 
  156:         assert str(Expr(Op.FACTORS, {x: 1})) == "x"
  157:         assert str(Expr(Op.FACTORS, {x: 2})) == "x ** 2"
  158:         assert str(Expr(Op.FACTORS, {x: -1})) == "x ** -1"
  159:         assert str(Expr(Op.FACTORS, {x: -2})) == "x ** -2"
  160:         assert str(Expr(Op.FACTORS, {x: 1, y: 1})) == "x * y"
  161:         assert str(Expr(Op.FACTORS, {x: 2, y: 3})) == "x ** 2 * y ** 3"
  162: 
  163:         v = Expr(Op.FACTORS, {x: 2, Expr(Op.TERMS, {x: 1, y: 1}): 3})
  164:         assert str(v) == "x ** 2 * (x + y) ** 3", str(v)
  165:         v = Expr(Op.FACTORS, {x: 2, Expr(Op.FACTORS, {x: 1, y: 1}): 3})
  166:         assert str(v) == "x ** 2 * (x * y) ** 3", str(v)
  167: 
  168:         assert str(Expr(Op.APPLY, ("f", (), {}))) == "f()"
  169:         assert str(Expr(Op.APPLY, ("f", (x, ), {}))) == "f(x)"
  170:         assert str(Expr(Op.APPLY, ("f", (x, y), {}))) == "f(x, y)"
  171:         assert str(Expr(Op.INDEXING, ("f", x))) == "f[x]"
  172: 
  173:         assert str(as_ternary(x, y, z)) == "merge(y, z, x)"
  174:         assert str(as_eq(x, y)) == "x .eq. y"
  175:         assert str(as_ne(x, y)) == "x .ne. y"
  176:         assert str(as_lt(x, y)) == "x .lt. y"
  177:         assert str(as_le(x, y)) == "x .le. y"
  178:         assert str(as_gt(x, y)) == "x .gt. y"
  179:         assert str(as_ge(x, y)) == "x .ge. y"
  180: 
  181:     def test_tostring_c(self):
  182:         language = Language.C
  183:         x = as_symbol("x")
  184:         y = as_symbol("y")
  185:         z = as_symbol("z")
  186:         n = as_number(123)
  187: 
  188:         assert Expr(Op.FACTORS, {x: 2}).tostring(language=language) == "x * x"
  189:         assert (Expr(Op.FACTORS, {
  190:             x + y: 2
  191:         }).tostring(language=language) == "(x + y) * (x + y)")
  192:         assert Expr(Op.FACTORS, {
  193:             x: 12
  194:         }).tostring(language=language) == "pow(x, 12)"
  195: 
  196:         assert as_apply(ArithOp.DIV, x,
  197:                         y).tostring(language=language) == "x / y"
  198:         assert (as_apply(ArithOp.DIV, x,
  199:                          x + y).tostring(language=language) == "x / (x + y)")
  200:         assert (as_apply(ArithOp.DIV, x - y, x +
  201:                          y).tostring(language=language) == "(x - y) / (x + y)")
  202:         assert (x + (x - y) / (x + y) +
  203:                 n).tostring(language=language) == "123 + x + (x - y) / (x + y)"
  204: 
  205:         assert as_ternary(x, y, z).tostring(language=language) == "(x?y:z)"
  206:         assert as_eq(x, y).tostring(language=language) == "x == y"
  207:         assert as_ne(x, y).tostring(language=language) == "x != y"
  208:         assert as_lt(x, y).tostring(language=language) == "x < y"
  209:         assert as_le(x, y).tostring(language=language) == "x <= y"
  210:         assert as_gt(x, y).tostring(language=language) == "x > y"
  211:         assert as_ge(x, y).tostring(language=language) == "x >= y"
  212: 
  213:     def test_operations(self):
  214:         x = as_symbol("x")
  215:         y = as_symbol("y")
  216:         z = as_symbol("z")
  217: 
  218:         assert x + x == Expr(Op.TERMS, {x: 2})
  219:         assert x - x == Expr(Op.INTEGER, (0, 4))
  220:         assert x + y == Expr(Op.TERMS, {x: 1, y: 1})
  221:         assert x - y == Expr(Op.TERMS, {x: 1, y: -1})
  222:         assert x * x == Expr(Op.FACTORS, {x: 2})
  223:         assert x * y == Expr(Op.FACTORS, {x: 1, y: 1})
  224: 
  225:         assert +x == x
  226:         assert -x == Expr(Op.TERMS, {x: -1}), repr(-x)
  227:         assert 2 * x == Expr(Op.TERMS, {x: 2})
  228:         assert 2 + x == Expr(Op.TERMS, {x: 1, as_number(1): 2})
  229:         assert 2 * x + 3 * y == Expr(Op.TERMS, {x: 2, y: 3})
  230:         assert (x + y) * 2 == Expr(Op.TERMS, {x: 2, y: 2})
  231: 
  232:         assert x**2 == Expr(Op.FACTORS, {x: 2})
  233:         assert (x + y)**2 == Expr(
  234:             Op.TERMS,
  235:             {
  236:                 Expr(Op.FACTORS, {x: 2}): 1,
  237:                 Expr(Op.FACTORS, {y: 2}): 1,
  238:                 Expr(Op.FACTORS, {
  239:                     x: 1,
  240:                     y: 1
  241:                 }): 2,
  242:             },
  243:         )
  244:         assert (x + y) * x == x**2 + x * y
  245:         assert (x + y)**2 == x**2 + 2 * x * y + y**2
  246:         assert (x + y)**2 + (x - y)**2 == 2 * x**2 + 2 * y**2
  247:         assert (x + y) * z == x * z + y * z
  248:         assert z * (x + y) == x * z + y * z
  249: 
  250:         assert (x / 2) == as_apply(ArithOp.DIV, x, as_number(2))
  251:         assert (2 * x / 2) == x
  252:         assert (3 * x / 2) == as_apply(ArithOp.DIV, 3 * x, as_number(2))
  253:         assert (4 * x / 2) == 2 * x
  254:         assert (5 * x / 2) == as_apply(ArithOp.DIV, 5 * x, as_number(2))
  255:         assert (6 * x / 2) == 3 * x
  256:         assert ((3 * 5) * x / 6) == as_apply(ArithOp.DIV, 5 * x, as_number(2))
  257:         assert (30 * x**2 * y**4 / (24 * x**3 * y**3)) == as_apply(
  258:             ArithOp.DIV, 5 * y, 4 * x)
  259:         assert ((15 * x / 6) / 5) == as_apply(ArithOp.DIV, x,
  260:                                               as_number(2)), (15 * x / 6) / 5
  261:         assert (x / (5 / x)) == as_apply(ArithOp.DIV, x**2, as_number(5))
  262: 
  263:         assert (x / 2.0) == Expr(Op.TERMS, {x: 0.5})
  264: 
  265:         s = as_string('"ABC"')
  266:         t = as_string('"123"')
  267: 
  268:         assert s // t == Expr(Op.STRING, ('"ABC123"', 1))
  269:         assert s // x == Expr(Op.CONCAT, (s, x))
  270:         assert x // s == Expr(Op.CONCAT, (x, s))
  271: 
  272:         c = as_complex(1.0, 2.0)
  273:         assert -c == as_complex(-1.0, -2.0)
  274:         assert c + c == as_expr((1 + 2j) * 2)
  275:         assert c * c == as_expr((1 + 2j)**2)
  276: 
  277:     def test_substitute(self):
  278:         x = as_symbol("x")
  279:         y = as_symbol("y")
  280:         z = as_symbol("z")
  281:         a = as_array((x, y))
  282: 
  283:         assert x.substitute({x: y}) == y
  284:         assert (x + y).substitute({x: z}) == y + z
  285:         assert (x * y).substitute({x: z}) == y * z
  286:         assert (x**4).substitute({x: z}) == z**4
  287:         assert (x / y).substitute({x: z}) == z / y
  288:         assert x.substitute({x: y + z}) == y + z
  289:         assert a.substitute({x: y + z}) == as_array((y + z, y))
  290: 
  291:         assert as_ternary(x, y,
  292:                           z).substitute({x: y + z}) == as_ternary(y + z, y, z)
  293:         assert as_eq(x, y).substitute({x: y + z}) == as_eq(y + z, y)
  294: 
  295:     def test_fromstring(self):
  296: 
  297:         x = as_symbol("x")
  298:         y = as_symbol("y")
  299:         z = as_symbol("z")
  300:         f = as_symbol("f")
  301:         s = as_string('"ABC"')
  302:         t = as_string('"123"')
  303:         a = as_array((x, y))
  304: 
  305:         assert fromstring("x") == x
  306:         assert fromstring("+ x") == x
  307:         assert fromstring("-  x") == -x
  308:         assert fromstring("x + y") == x + y
  309:         assert fromstring("x + 1") == x + 1
  310:         assert fromstring("x * y") == x * y
  311:         assert fromstring("x * 2") == x * 2
  312:         assert fromstring("x / y") == x / y
  313:         assert fromstring("x ** 2", language=Language.Python) == x**2
  314:         assert fromstring("x ** 2 ** 3", language=Language.Python) == x**2**3
  315:         assert fromstring("(x + y) * z") == (x + y) * z
  316: 
  317:         assert fromstring("f(x)") == f(x)
  318:         assert fromstring("f(x,y)") == f(x, y)
  319:         assert fromstring("f[x]") == f[x]
  320:         assert fromstring("f[x][y]") == f[x][y]
  321: 
  322:         assert fromstring('"ABC"') == s
  323:         assert (normalize(
  324:             fromstring('"ABC" // "123" ',
  325:                        language=Language.Fortran)) == s // t)
  326:         assert fromstring('f("ABC")') == f(s)
  327:         assert fromstring('MYSTRKIND_"ABC"') == as_string('"ABC"', "MYSTRKIND")
  328: 
  329:         assert fromstring("(/x, y/)") == a, fromstring("(/x, y/)")
  330:         assert fromstring("f((/x, y/))") == f(a)
  331:         assert fromstring("(/(x+y)*z/)") == as_array(((x + y) * z, ))
  332: 
  333:         assert fromstring("123") == as_number(123)
  334:         assert fromstring("123_2") == as_number(123, 2)
  335:         assert fromstring("123_myintkind") == as_number(123, "myintkind")
  336: 
  337:         assert fromstring("123.0") == as_number(123.0, 4)
  338:         assert fromstring("123.0_4") == as_number(123.0, 4)
  339:         assert fromstring("123.0_8") == as_number(123.0, 8)
  340:         assert fromstring("123.0e0") == as_number(123.0, 4)
  341:         assert fromstring("123.0d0") == as_number(123.0, 8)
  342:         assert fromstring("123d0") == as_number(123.0, 8)
  343:         assert fromstring("123e-0") == as_number(123.0, 4)
  344:         assert fromstring("123d+0") == as_number(123.0, 8)
  345:         assert fromstring("123.0_myrealkind") == as_number(123.0, "myrealkind")
  346:         assert fromstring("3E4") == as_number(30000.0, 4)
  347: 
  348:         assert fromstring("(1, 2)") == as_complex(1, 2)
  349:         assert fromstring("(1e2, PI)") == as_complex(as_number(100.0),
  350:                                                      as_symbol("PI"))
  351: 
  352:         assert fromstring("[1, 2]") == as_array((as_number(1), as_number(2)))
  353: 
  354:         assert fromstring("POINT(x, y=1)") == as_apply(as_symbol("POINT"),
  355:                                                        x,
  356:                                                        y=as_number(1))
  357:         assert fromstring(
  358:             'PERSON(name="John", age=50, shape=(/34, 23/))') == as_apply(
  359:                 as_symbol("PERSON"),
  360:                 name=as_string('"John"'),
  361:                 age=as_number(50),
  362:                 shape=as_array((as_number(34), as_number(23))),
  363:             )
  364: 
  365:         assert fromstring("x?y:z") == as_ternary(x, y, z)
  366: 
  367:         assert fromstring("*x") == as_deref(x)
  368:         assert fromstring("**x") == as_deref(as_deref(x))
  369:         assert fromstring("&x") == as_ref(x)
  370:         assert fromstring("(*x) * (*y)") == as_deref(x) * as_deref(y)
  371:         assert fromstring("(*x) * *y") == as_deref(x) * as_deref(y)
  372:         assert fromstring("*x * *y") == as_deref(x) * as_deref(y)
  373:         assert fromstring("*x**y") == as_deref(x) * as_deref(y)
  374: 
  375:         assert fromstring("x == y") == as_eq(x, y)
  376:         assert fromstring("x != y") == as_ne(x, y)
  377:         assert fromstring("x < y") == as_lt(x, y)
  378:         assert fromstring("x > y") == as_gt(x, y)
  379:         assert fromstring("x <= y") == as_le(x, y)
  380:         assert fromstring("x >= y") == as_ge(x, y)
  381: 
  382:         assert fromstring("x .eq. y", language=Language.Fortran) == as_eq(x, y)
  383:         assert fromstring("x .ne. y", language=Language.Fortran) == as_ne(x, y)
  384:         assert fromstring("x .lt. y", language=Language.Fortran) == as_lt(x, y)
  385:         assert fromstring("x .gt. y", language=Language.Fortran) == as_gt(x, y)
  386:         assert fromstring("x .le. y", language=Language.Fortran) == as_le(x, y)
  387:         assert fromstring("x .ge. y", language=Language.Fortran) == as_ge(x, y)
  388: 
  389:     def test_traverse(self):
  390:         x = as_symbol("x")
  391:         y = as_symbol("y")
  392:         z = as_symbol("z")
  393:         f = as_symbol("f")
  394: 
  395:         # Use traverse to substitute a symbol
  396:         def replace_visit(s, r=z):
  397:             if s == x:
  398:                 return r
  399: 
  400:         assert x.traverse(replace_visit) == z
  401:         assert y.traverse(replace_visit) == y
  402:         assert z.traverse(replace_visit) == z
  403:         assert (f(y)).traverse(replace_visit) == f(y)
  404:         assert (f(x)).traverse(replace_visit) == f(z)
  405:         assert (f[y]).traverse(replace_visit) == f[y]
  406:         assert (f[z]).traverse(replace_visit) == f[z]
  407:         assert (x + y + z).traverse(replace_visit) == (2 * z + y)
  408:         assert (x +
  409:                 f(y, x - z)).traverse(replace_visit) == (z +
  410:                                                          f(y, as_number(0)))
  411:         assert as_eq(x, y).traverse(replace_visit) == as_eq(z, y)
  412: 
  413:         # Use traverse to collect symbols, method 1
  414:         function_symbols = set()
  415:         symbols = set()
  416: 
  417:         def collect_symbols(s):
  418:             if s.op is Op.APPLY:
  419:                 oper = s.data[0]
  420:                 function_symbols.add(oper)
  421:                 if oper in symbols:
  422:                     symbols.remove(oper)
  423:             elif s.op is Op.SYMBOL and s not in function_symbols:
  424:                 symbols.add(s)
  425: 
  426:         (x + f(y, x - z)).traverse(collect_symbols)
  427:         assert function_symbols == {f}
  428:         assert symbols == {x, y, z}
  429: 
  430:         # Use traverse to collect symbols, method 2
  431:         def collect_symbols2(expr, symbols):
  432:             if expr.op is Op.SYMBOL:
  433:                 symbols.add(expr)
  434: 
  435:         symbols = set()
  436:         (x + f(y, x - z)).traverse(collect_symbols2, symbols)
  437:         assert symbols == {x, y, z, f}
  438: 
  439:         # Use traverse to partially collect symbols
  440:         def collect_symbols3(expr, symbols):
  441:             if expr.op is Op.APPLY:
  442:                 # skip traversing function calls
  443:                 return expr
  444:             if expr.op is Op.SYMBOL:
  445:                 symbols.add(expr)
  446: 
  447:         symbols = set()
  448:         (x + f(y, x - z)).traverse(collect_symbols3, symbols)
  449:         assert symbols == {x}
  450: 
  451:     def test_linear_solve(self):
  452:         x = as_symbol("x")
  453:         y = as_symbol("y")
  454:         z = as_symbol("z")
  455: 
  456:         assert x.linear_solve(x) == (as_number(1), as_number(0))
  457:         assert (x + 1).linear_solve(x) == (as_number(1), as_number(1))
  458:         assert (2 * x).linear_solve(x) == (as_number(2), as_number(0))
  459:         assert (2 * x + 3).linear_solve(x) == (as_number(2), as_number(3))
  460:         assert as_number(3).linear_solve(x) == (as_number(0), as_number(3))
  461:         assert y.linear_solve(x) == (as_number(0), y)
  462:         assert (y * z).linear_solve(x) == (as_number(0), y * z)
  463: 
  464:         assert (x + y).linear_solve(x) == (as_number(1), y)
  465:         assert (z * x + y).linear_solve(x) == (z, y)
  466:         assert ((z + y) * x + y).linear_solve(x) == (z + y, y)
  467:         assert (z * y * x + y).linear_solve(x) == (z * y, y)
  468: 
  469:         pytest.raises(RuntimeError, lambda: (x * x).linear_solve(x))
  470: 
  471:     def test_as_numer_denom(self):
  472:         x = as_symbol("x")
  473:         y = as_symbol("y")
  474:         n = as_number(123)
  475: 
  476:         assert as_numer_denom(x) == (x, as_number(1))
  477:         assert as_numer_denom(x / n) == (x, n)
  478:         assert as_numer_denom(n / x) == (n, x)
  479:         assert as_numer_denom(x / y) == (x, y)
  480:         assert as_numer_denom(x * y) == (x * y, as_number(1))
  481:         assert as_numer_denom(n + x / y) == (x + n * y, y)
  482:         assert as_numer_denom(n + x / (y - x / n)) == (y * n**2, y * n - x)
  483: 
  484:     def test_polynomial_atoms(self):
  485:         x = as_symbol("x")
  486:         y = as_symbol("y")
  487:         n = as_number(123)
  488: 
  489:         assert x.polynomial_atoms() == {x}
  490:         assert n.polynomial_atoms() == set()
  491:         assert (y[x]).polynomial_atoms() == {y[x]}
  492:         assert (y(x)).polynomial_atoms() == {y(x)}
  493:         assert (y(x) + x).polynomial_atoms() == {y(x), x}
  494:         assert (y(x) * x[y]).polynomial_atoms() == {y(x), x[y]}
  495:         assert (y(x)**x).polynomial_atoms() == {y(x)}
