    1: import contextlib
    2: import importlib
    3: import io
    4: import textwrap
    5: import time
    6: 
    7: import pytest
    8: 
    9: import numpy as np
   10: from numpy.f2py import crackfortran
   11: from numpy.f2py.crackfortran import markinnerspaces, nameargspattern
   12: 
   13: from . import util
   14: 
   15: 
   16: class TestNoSpace(util.F2PyTest):
   17:     # issue gh-15035: add handling for endsubroutine, endfunction with no space
   18:     # between "end" and the block name
   19:     sources = [util.getpath("tests", "src", "crackfortran", "gh15035.f")]
   20: 
   21:     def test_module(self):
   22:         k = np.array([1, 2, 3], dtype=np.float64)
   23:         w = np.array([1, 2, 3], dtype=np.float64)
   24:         self.module.subb(k)
   25:         assert np.allclose(k, w + 1)
   26:         self.module.subc([w, k])
   27:         assert np.allclose(k, w + 1)
   28:         assert self.module.t0("23") == b"2"
   29: 
   30: 
   31: class TestPublicPrivate:
   32:     def test_defaultPrivate(self):
   33:         fpath = util.getpath("tests", "src", "crackfortran", "privatemod.f90")
   34:         mod = crackfortran.crackfortran([str(fpath)])
   35:         assert len(mod) == 1
   36:         mod = mod[0]
   37:         assert "private" in mod["vars"]["a"]["attrspec"]
   38:         assert "public" not in mod["vars"]["a"]["attrspec"]
   39:         assert "private" in mod["vars"]["b"]["attrspec"]
   40:         assert "public" not in mod["vars"]["b"]["attrspec"]
   41:         assert "private" not in mod["vars"]["seta"]["attrspec"]
   42:         assert "public" in mod["vars"]["seta"]["attrspec"]
   43: 
   44:     def test_defaultPublic(self, tmp_path):
   45:         fpath = util.getpath("tests", "src", "crackfortran", "publicmod.f90")
   46:         mod = crackfortran.crackfortran([str(fpath)])
   47:         assert len(mod) == 1
   48:         mod = mod[0]
   49:         assert "private" in mod["vars"]["a"]["attrspec"]
   50:         assert "public" not in mod["vars"]["a"]["attrspec"]
   51:         assert "private" not in mod["vars"]["seta"]["attrspec"]
   52:         assert "public" in mod["vars"]["seta"]["attrspec"]
   53: 
   54:     def test_access_type(self, tmp_path):
   55:         fpath = util.getpath("tests", "src", "crackfortran", "accesstype.f90")
   56:         mod = crackfortran.crackfortran([str(fpath)])
   57:         assert len(mod) == 1
   58:         tt = mod[0]['vars']
   59:         assert set(tt['a']['attrspec']) == {'private', 'bind(c)'}
   60:         assert set(tt['b_']['attrspec']) == {'public', 'bind(c)'}
   61:         assert set(tt['c']['attrspec']) == {'public'}
   62: 
   63:     def test_nowrap_private_proceedures(self, tmp_path):
   64:         fpath = util.getpath("tests", "src", "crackfortran", "gh23879.f90")
   65:         mod = crackfortran.crackfortran([str(fpath)])
   66:         assert len(mod) == 1
   67:         pyf = crackfortran.crack2fortran(mod)
   68:         assert 'bar' not in pyf
   69: 
   70: class TestModuleProcedure:
   71:     def test_moduleOperators(self, tmp_path):
   72:         fpath = util.getpath("tests", "src", "crackfortran", "operators.f90")
   73:         mod = crackfortran.crackfortran([str(fpath)])
   74:         assert len(mod) == 1
   75:         mod = mod[0]
   76:         assert "body" in mod and len(mod["body"]) == 9
   77:         assert mod["body"][1]["name"] == "operator(.item.)"
   78:         assert "implementedby" in mod["body"][1]
   79:         assert mod["body"][1]["implementedby"] == \
   80:             ["item_int", "item_real"]
   81:         assert mod["body"][2]["name"] == "operator(==)"
   82:         assert "implementedby" in mod["body"][2]
   83:         assert mod["body"][2]["implementedby"] == ["items_are_equal"]
   84:         assert mod["body"][3]["name"] == "assignment(=)"
   85:         assert "implementedby" in mod["body"][3]
   86:         assert mod["body"][3]["implementedby"] == \
   87:             ["get_int", "get_real"]
   88: 
   89:     def test_notPublicPrivate(self, tmp_path):
   90:         fpath = util.getpath("tests", "src", "crackfortran", "pubprivmod.f90")
   91:         mod = crackfortran.crackfortran([str(fpath)])
   92:         assert len(mod) == 1
   93:         mod = mod[0]
   94:         assert mod['vars']['a']['attrspec'] == ['private', ]
   95:         assert mod['vars']['b']['attrspec'] == ['public', ]
   96:         assert mod['vars']['seta']['attrspec'] == ['public', ]
   97: 
   98: 
   99: class TestExternal(util.F2PyTest):
  100:     # issue gh-17859: add external attribute support
  101:     sources = [util.getpath("tests", "src", "crackfortran", "gh17859.f")]
  102: 
  103:     def test_external_as_statement(self):
  104:         def incr(x):
  105:             return x + 123
  106: 
  107:         r = self.module.external_as_statement(incr)
  108:         assert r == 123
  109: 
  110:     def test_external_as_attribute(self):
  111:         def incr(x):
  112:             return x + 123
  113: 
  114:         r = self.module.external_as_attribute(incr)
  115:         assert r == 123
  116: 
  117: 
  118: class TestCrackFortran(util.F2PyTest):
  119:     # gh-2848: commented lines between parameters in subroutine parameter lists
  120:     sources = [util.getpath("tests", "src", "crackfortran", "gh2848.f90"),
  121:                util.getpath("tests", "src", "crackfortran", "common_with_division.f")
  122:               ]
  123: 
  124:     def test_gh2848(self):
  125:         r = self.module.gh2848(1, 2)
  126:         assert r == (1, 2)
  127: 
  128:     def test_common_with_division(self):
  129:         assert len(self.module.mortmp.ctmp) == 11
  130: 
  131: class TestMarkinnerspaces:
  132:     # gh-14118: markinnerspaces does not handle multiple quotations
  133: 
  134:     def test_do_not_touch_normal_spaces(self):
  135:         test_list = ["a ", " a", "a b c", "'abcdefghij'"]
  136:         for i in test_list:
  137:             assert markinnerspaces(i) == i
  138: 
  139:     def test_one_relevant_space(self):
  140:         assert markinnerspaces("a 'b c' \\' \\'") == "a 'b@_@c' \\' \\'"
  141:         assert markinnerspaces(r'a "b c" \" \"') == r'a "b@_@c" \" \"'
  142: 
  143:     def test_ignore_inner_quotes(self):
  144:         assert markinnerspaces("a 'b c\" \" d' e") == "a 'b@_@c\"@_@\"@_@d' e"
  145:         assert markinnerspaces("a \"b c' ' d\" e") == "a \"b@_@c'@_@'@_@d\" e"
  146: 
  147:     def test_multiple_relevant_spaces(self):
  148:         assert markinnerspaces("a 'b c' 'd e'") == "a 'b@_@c' 'd@_@e'"
  149:         assert markinnerspaces(r'a "b c" "d e"') == r'a "b@_@c" "d@_@e"'
  150: 
  151: 
  152: class TestDimSpec(util.F2PyTest):
  153:     """This test suite tests various expressions that are used as dimension
  154:     specifications.
  155: 
  156:     There exists two usage cases where analyzing dimensions
  157:     specifications are important.
  158: 
  159:     In the first case, the size of output arrays must be defined based
  160:     on the inputs to a Fortran function. Because Fortran supports
  161:     arbitrary bases for indexing, for instance, `arr(lower:upper)`,
  162:     f2py has to evaluate an expression `upper - lower + 1` where
  163:     `lower` and `upper` are arbitrary expressions of input parameters.
  164:     The evaluation is performed in C, so f2py has to translate Fortran
  165:     expressions to valid C expressions (an alternative approach is
  166:     that a developer specifies the corresponding C expressions in a
  167:     .pyf file).
  168: 
  169:     In the second case, when user provides an input array with a given
  170:     size but some hidden parameters used in dimensions specifications
  171:     need to be determined based on the input array size. This is a
  172:     harder problem because f2py has to solve the inverse problem: find
  173:     a parameter `p` such that `upper(p) - lower(p) + 1` equals to the
  174:     size of input array. In the case when this equation cannot be
  175:     solved (e.g. because the input array size is wrong), raise an
  176:     error before calling the Fortran function (that otherwise would
  177:     likely crash Python process when the size of input arrays is
  178:     wrong). f2py currently supports this case only when the equation
  179:     is linear with respect to unknown parameter.
  180: 
  181:     """
  182: 
  183:     suffix = ".f90"
  184: 
  185:     code_template = textwrap.dedent("""
  186:       function get_arr_size_{count}(a, n) result (length)
  187:         integer, intent(in) :: n
  188:         integer, dimension({dimspec}), intent(out) :: a
  189:         integer length
  190:         length = size(a)
  191:       end function
  192: 
  193:       subroutine get_inv_arr_size_{count}(a, n)
  194:         integer :: n
  195:         ! the value of n is computed in f2py wrapper
  196:         !f2py intent(out) n
  197:         integer, dimension({dimspec}), intent(in) :: a
  198:         if (a({first}).gt.0) then
  199:           ! print*, "a=", a
  200:         endif
  201:       end subroutine
  202:     """)
  203: 
  204:     linear_dimspecs = [
  205:         "n", "2*n", "2:n", "n/2", "5 - n/2", "3*n:20", "n*(n+1):n*(n+5)",
  206:         "2*n, n"
  207:     ]
  208:     nonlinear_dimspecs = ["2*n:3*n*n+2*n"]
  209:     all_dimspecs = linear_dimspecs + nonlinear_dimspecs
  210: 
  211:     code = ""
  212:     for count, dimspec in enumerate(all_dimspecs):
  213:         lst = [(d.split(":")[0] if ":" in d else "1") for d in dimspec.split(',')]
  214:         code += code_template.format(
  215:             count=count,
  216:             dimspec=dimspec,
  217:             first=", ".join(lst),
  218:         )
  219: 
  220:     @pytest.mark.parametrize("dimspec", all_dimspecs)
  221:     @pytest.mark.slow
  222:     def test_array_size(self, dimspec):
  223: 
  224:         count = self.all_dimspecs.index(dimspec)
  225:         get_arr_size = getattr(self.module, f"get_arr_size_{count}")
  226: 
  227:         for n in [1, 2, 3, 4, 5]:
  228:             sz, a = get_arr_size(n)
  229:             assert a.size == sz
  230: 
  231:     @pytest.mark.parametrize("dimspec", all_dimspecs)
  232:     def test_inv_array_size(self, dimspec):
  233: 
  234:         count = self.all_dimspecs.index(dimspec)
  235:         get_arr_size = getattr(self.module, f"get_arr_size_{count}")
  236:         get_inv_arr_size = getattr(self.module, f"get_inv_arr_size_{count}")
  237: 
  238:         for n in [1, 2, 3, 4, 5]:
  239:             sz, a = get_arr_size(n)
  240:             if dimspec in self.nonlinear_dimspecs:
  241:                 # one must specify n as input, the call we'll ensure
  242:                 # that a and n are compatible:
  243:                 n1 = get_inv_arr_size(a, n)
  244:             else:
  245:                 # in case of linear dependence, n can be determined
  246:                 # from the shape of a:
  247:                 n1 = get_inv_arr_size(a)
  248:             # n1 may be different from n (for instance, when `a` size
  249:             # is a function of some `n` fraction) but it must produce
  250:             # the same sized array
  251:             sz1, _ = get_arr_size(n1)
  252:             assert sz == sz1, (n, n1, sz, sz1)
  253: 
  254: 
  255: class TestModuleDeclaration:
  256:     def test_dependencies(self, tmp_path):
  257:         fpath = util.getpath("tests", "src", "crackfortran", "foo_deps.f90")
  258:         mod = crackfortran.crackfortran([str(fpath)])
  259:         assert len(mod) == 1
  260:         assert mod[0]["vars"]["abar"]["="] == "bar('abar')"
  261: 
  262: 
  263: class TestEval(util.F2PyTest):
  264:     def test_eval_scalar(self):
  265:         eval_scalar = crackfortran._eval_scalar
  266: 
  267:         assert eval_scalar('123', {}) == '123'
  268:         assert eval_scalar('12 + 3', {}) == '15'
  269:         assert eval_scalar('a + b', {"a": 1, "b": 2}) == '3'
  270:         assert eval_scalar('"123"', {}) == "'123'"
  271: 
  272: 
  273: class TestFortranReader(util.F2PyTest):
  274:     @pytest.mark.parametrize("encoding",
  275:                              ['ascii', 'utf-8', 'utf-16', 'utf-32'])
  276:     def test_input_encoding(self, tmp_path, encoding):
  277:         # gh-635
  278:         f_path = tmp_path / f"input_with_{encoding}_encoding.f90"
  279:         with f_path.open('w', encoding=encoding) as ff:
  280:             ff.write("""
  281:                      subroutine foo()
  282:                      end subroutine foo
  283:                      """)
  284:         mod = crackfortran.crackfortran([str(f_path)])
  285:         assert mod[0]['name'] == 'foo'
  286: 
  287: 
  288: @pytest.mark.slow
  289: class TestUnicodeComment(util.F2PyTest):
  290:     sources = [util.getpath("tests", "src", "crackfortran", "unicode_comment.f90")]
  291: 
  292:     @pytest.mark.skipif(
  293:         (importlib.util.find_spec("charset_normalizer") is None),
  294:         reason="test requires charset_normalizer which is not installed",
  295:     )
  296:     def test_encoding_comment(self):
  297:         self.module.foo(3)
  298: 
  299: 
  300: class TestNameArgsPatternBacktracking:
  301:     @pytest.mark.parametrize(
  302:         ['adversary'],
  303:         [
  304:             ('@)@bind@(@',),
  305:             ('@)@bind                         @(@',),
  306:             ('@)@bind foo bar baz@(@',)
  307:         ]
  308:     )
  309:     def test_nameargspattern_backtracking(self, adversary):
  310:         '''address ReDOS vulnerability:
  311:         https://github.com/numpy/numpy/issues/23338'''
  312:         trials_per_batch = 12
  313:         batches_per_regex = 4
  314:         start_reps, end_reps = 15, 25
  315:         for ii in range(start_reps, end_reps):
  316:             repeated_adversary = adversary * ii
  317:             # test times in small batches.
  318:             # this gives us more chances to catch a bad regex
  319:             # while still catching it before too long if it is bad
  320:             for _ in range(batches_per_regex):
  321:                 times = []
  322:                 for _ in range(trials_per_batch):
  323:                     t0 = time.perf_counter()
  324:                     mtch = nameargspattern.search(repeated_adversary)
  325:                     times.append(time.perf_counter() - t0)
  326:                 # our pattern should be much faster than 0.2s per search
  327:                 # it's unlikely that a bad regex will pass even on fast CPUs
  328:                 assert np.median(times) < 0.2
  329:             assert not mtch
  330:             # if the adversary is capped with @)@, it becomes acceptable
  331:             # according to the old version of the regex.
  332:             # that should still be true.
  333:             good_version_of_adversary = repeated_adversary + '@)@'
  334:             assert nameargspattern.search(good_version_of_adversary)
  335: 
  336: class TestFunctionReturn(util.F2PyTest):
  337:     sources = [util.getpath("tests", "src", "crackfortran", "gh23598.f90")]
  338: 
  339:     @pytest.mark.slow
  340:     def test_function_rettype(self):
  341:         # gh-23598
  342:         assert self.module.intproduct(3, 4) == 12
  343: 
  344: 
  345: class TestFortranGroupCounters(util.F2PyTest):
  346:     def test_end_if_comment(self):
  347:         # gh-23533
  348:         fpath = util.getpath("tests", "src", "crackfortran", "gh23533.f")
  349:         try:
  350:             crackfortran.crackfortran([str(fpath)])
  351:         except Exception as exc:
  352:             assert False, f"'crackfortran.crackfortran' raised an exception {exc}"
  353: 
  354: 
  355: class TestF77CommonBlockReader:
  356:     def test_gh22648(self, tmp_path):
  357:         fpath = util.getpath("tests", "src", "crackfortran", "gh22648.pyf")
  358:         with contextlib.redirect_stdout(io.StringIO()) as stdout_f2py:
  359:             mod = crackfortran.crackfortran([str(fpath)])
  360:         assert "Mismatch" not in stdout_f2py.getvalue()
  361: 
  362: class TestParamEval:
  363:     # issue gh-11612, array parameter parsing
  364:     def test_param_eval_nested(self):
  365:         v = '(/3.14, 4./)'
  366:         g_params = {"kind": crackfortran._kind_func,
  367:                 "selected_int_kind": crackfortran._selected_int_kind_func,
  368:                 "selected_real_kind": crackfortran._selected_real_kind_func}
  369:         params = {'dp': 8, 'intparamarray': {1: 3, 2: 5},
  370:                   'nested': {1: 1, 2: 2, 3: 3}}
  371:         dimspec = '(2)'
  372:         ret = crackfortran.param_eval(v, g_params, params, dimspec=dimspec)
  373:         assert ret == {1: 3.14, 2: 4.0}
  374: 
  375:     def test_param_eval_nonstandard_range(self):
  376:         v = '(/ 6, 3, 1 /)'
  377:         g_params = {"kind": crackfortran._kind_func,
  378:                 "selected_int_kind": crackfortran._selected_int_kind_func,
  379:                 "selected_real_kind": crackfortran._selected_real_kind_func}
  380:         params = {}
  381:         dimspec = '(-1:1)'
  382:         ret = crackfortran.param_eval(v, g_params, params, dimspec=dimspec)
  383:         assert ret == {-1: 6, 0: 3, 1: 1}
  384: 
  385:     def test_param_eval_empty_range(self):
  386:         v = '6'
  387:         g_params = {"kind": crackfortran._kind_func,
  388:                 "selected_int_kind": crackfortran._selected_int_kind_func,
  389:                 "selected_real_kind": crackfortran._selected_real_kind_func}
  390:         params = {}
  391:         dimspec = ''
  392:         pytest.raises(ValueError, crackfortran.param_eval, v, g_params, params,
  393:                       dimspec=dimspec)
  394: 
  395:     def test_param_eval_non_array_param(self):
  396:         v = '3.14_dp'
  397:         g_params = {"kind": crackfortran._kind_func,
  398:                 "selected_int_kind": crackfortran._selected_int_kind_func,
  399:                 "selected_real_kind": crackfortran._selected_real_kind_func}
  400:         params = {}
  401:         ret = crackfortran.param_eval(v, g_params, params, dimspec=None)
  402:         assert ret == '3.14_dp'
  403: 
  404:     def test_param_eval_too_many_dims(self):
  405:         v = 'reshape((/ (i, i=1, 250) /), (/5, 10, 5/))'
  406:         g_params = {"kind": crackfortran._kind_func,
  407:                 "selected_int_kind": crackfortran._selected_int_kind_func,
  408:                 "selected_real_kind": crackfortran._selected_real_kind_func}
  409:         params = {}
  410:         dimspec = '(0:4, 3:12, 5)'
  411:         pytest.raises(ValueError, crackfortran.param_eval, v, g_params, params,
  412:                       dimspec=dimspec)
  413: 
  414: @pytest.mark.slow
  415: class TestLowerF2PYDirective(util.F2PyTest):
  416:     sources = [util.getpath("tests", "src", "crackfortran", "gh27697.f90")]
  417:     options = ['--lower']
  418: 
  419:     def test_no_lower_fail(self):
  420:         with pytest.raises(ValueError, match='aborting directly') as exc:
  421:             self.module.utils.my_abort('aborting directly')
