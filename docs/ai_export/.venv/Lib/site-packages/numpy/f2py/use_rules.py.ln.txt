    1: """
    2: Build 'use others module data' mechanism for f2py2e.
    3: 
    4: Copyright 1999 -- 2011 Pearu Peterson all rights reserved.
    5: Copyright 2011 -- present NumPy Developers.
    6: Permission to use, modify, and distribute this software is given under the
    7: terms of the NumPy License.
    8: 
    9: NO WARRANTY IS EXPRESSED OR IMPLIED.  USE AT YOUR OWN RISK.
   10: """
   11: __version__ = "$Revision: 1.3 $"[10:-1]
   12: 
   13: f2py_version = 'See `f2py -v`'
   14: 
   15: 
   16: from .auxfuncs import applyrules, dictappend, gentitle, hasnote, outmess
   17: 
   18: usemodule_rules = {
   19:     'body': """
   20: #begintitle#
   21: static char doc_#apiname#[] = \"\\\nVariable wrapper signature:\\n\\
   22: \t #name# = get_#name#()\\n\\
   23: Arguments:\\n\\
   24: #docstr#\";
   25: extern F_MODFUNC(#usemodulename#,#USEMODULENAME#,#realname#,#REALNAME#);
   26: static PyObject *#apiname#(PyObject *capi_self, PyObject *capi_args) {
   27: /*#decl#*/
   28: \tif (!PyArg_ParseTuple(capi_args, \"\")) goto capi_fail;
   29: printf(\"c: %d\\n\",F_MODFUNC(#usemodulename#,#USEMODULENAME#,#realname#,#REALNAME#));
   30: \treturn Py_BuildValue(\"\");
   31: capi_fail:
   32: \treturn NULL;
   33: }
   34: """,
   35:     'method': '\t{\"get_#name#\",#apiname#,METH_VARARGS|METH_KEYWORDS,doc_#apiname#},',
   36:     'need': ['F_MODFUNC']
   37: }
   38: 
   39: ################
   40: 
   41: 
   42: def buildusevars(m, r):
   43:     ret = {}
   44:     outmess(
   45:         f"\t\tBuilding use variable hooks for module \"{m['name']}\" (feature only for F90/F95)...\n")
   46:     varsmap = {}
   47:     revmap = {}
   48:     if 'map' in r:
   49:         for k in r['map'].keys():
   50:             if r['map'][k] in revmap:
   51:                 outmess('\t\t\tVariable "%s<=%s" is already mapped by "%s". Skipping.\n' % (
   52:                     r['map'][k], k, revmap[r['map'][k]]))
   53:             else:
   54:                 revmap[r['map'][k]] = k
   55:     if r.get('only'):
   56:         for v in r['map'].keys():
   57:             if r['map'][v] in m['vars']:
   58: 
   59:                 if revmap[r['map'][v]] == v:
   60:                     varsmap[v] = r['map'][v]
   61:                 else:
   62:                     outmess(f"\t\t\tIgnoring map \"{v}=>{r['map'][v]}\". See above.\n")
   63:             else:
   64:                 outmess(
   65:                     f"\t\t\tNo definition for variable \"{v}=>{r['map'][v]}\". Skipping.\n")
   66:     else:
   67:         for v in m['vars'].keys():
   68:             varsmap[v] = revmap.get(v, v)
   69:     for v in varsmap.keys():
   70:         ret = dictappend(ret, buildusevar(v, varsmap[v], m['vars'], m['name']))
   71:     return ret
   72: 
   73: 
   74: def buildusevar(name, realname, vars, usemodulename):
   75:     outmess('\t\t\tConstructing wrapper function for variable "%s=>%s"...\n' % (
   76:         name, realname))
   77:     ret = {}
   78:     vrd = {'name': name,
   79:            'realname': realname,
   80:            'REALNAME': realname.upper(),
   81:            'usemodulename': usemodulename,
   82:            'USEMODULENAME': usemodulename.upper(),
   83:            'texname': name.replace('_', '\\_'),
   84:            'begintitle': gentitle(f'{name}=>{realname}'),
   85:            'endtitle': gentitle(f'end of {name}=>{realname}'),
   86:            'apiname': f'#modulename#_use_{realname}_from_{usemodulename}'
   87:            }
   88:     nummap = {0: 'Ro', 1: 'Ri', 2: 'Rii', 3: 'Riii', 4: 'Riv',
   89:               5: 'Rv', 6: 'Rvi', 7: 'Rvii', 8: 'Rviii', 9: 'Rix'}
   90:     vrd['texnamename'] = name
   91:     for i in nummap.keys():
   92:         vrd['texnamename'] = vrd['texnamename'].replace(repr(i), nummap[i])
   93:     if hasnote(vars[realname]):
   94:         vrd['note'] = vars[realname]['note']
   95:     rd = dictappend({}, vrd)
   96: 
   97:     print(name, realname, vars[realname])
   98:     ret = applyrules(usemodule_rules, rd)
   99:     return ret
