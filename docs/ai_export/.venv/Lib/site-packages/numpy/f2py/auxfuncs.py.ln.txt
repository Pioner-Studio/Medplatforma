    1: """
    2: Auxiliary functions for f2py2e.
    3: 
    4: Copyright 1999 -- 2011 Pearu Peterson all rights reserved.
    5: Copyright 2011 -- present NumPy Developers.
    6: Permission to use, modify, and distribute this software is given under the
    7: terms of the NumPy (BSD style) LICENSE.
    8: 
    9: NO WARRANTY IS EXPRESSED OR IMPLIED.  USE AT YOUR OWN RISK.
   10: """
   11: import pprint
   12: import re
   13: import sys
   14: import types
   15: from functools import reduce
   16: 
   17: from . import __version__, cfuncs
   18: from .cfuncs import errmess
   19: 
   20: __all__ = [
   21:     'applyrules', 'debugcapi', 'dictappend', 'errmess', 'gentitle',
   22:     'getargs2', 'getcallprotoargument', 'getcallstatement',
   23:     'getfortranname', 'getpymethoddef', 'getrestdoc', 'getusercode',
   24:     'getusercode1', 'getdimension', 'hasbody', 'hascallstatement', 'hascommon',
   25:     'hasexternals', 'hasinitvalue', 'hasnote', 'hasresultnote',
   26:     'isallocatable', 'isarray', 'isarrayofstrings',
   27:     'ischaracter', 'ischaracterarray', 'ischaracter_or_characterarray',
   28:     'iscomplex', 'iscstyledirective',
   29:     'iscomplexarray', 'iscomplexfunction', 'iscomplexfunction_warn',
   30:     'isdouble', 'isdummyroutine', 'isexternal', 'isfunction',
   31:     'isfunction_wrap', 'isint1', 'isint1array', 'isinteger', 'isintent_aux',
   32:     'isintent_c', 'isintent_callback', 'isintent_copy', 'isintent_dict',
   33:     'isintent_hide', 'isintent_in', 'isintent_inout', 'isintent_inplace',
   34:     'isintent_nothide', 'isintent_out', 'isintent_overwrite', 'islogical',
   35:     'islogicalfunction', 'islong_complex', 'islong_double',
   36:     'islong_doublefunction', 'islong_long', 'islong_longfunction',
   37:     'ismodule', 'ismoduleroutine', 'isoptional', 'isprivate', 'isvariable',
   38:     'isrequired', 'isroutine', 'isscalar', 'issigned_long_longarray',
   39:     'isstring', 'isstringarray', 'isstring_or_stringarray', 'isstringfunction',
   40:     'issubroutine', 'get_f2py_modulename', 'issubroutine_wrap', 'isthreadsafe',
   41:     'isunsigned', 'isunsigned_char', 'isunsigned_chararray',
   42:     'isunsigned_long_long', 'isunsigned_long_longarray', 'isunsigned_short',
   43:     'isunsigned_shortarray', 'l_and', 'l_not', 'l_or', 'outmess', 'replace',
   44:     'show', 'stripcomma', 'throw_error', 'isattr_value', 'getuseblocks',
   45:     'process_f2cmap_dict', 'containscommon', 'containsderivedtypes'
   46: ]
   47: 
   48: 
   49: f2py_version = __version__.version
   50: 
   51: 
   52: show = pprint.pprint
   53: 
   54: options = {}
   55: debugoptions = []
   56: wrapfuncs = 1
   57: 
   58: 
   59: def outmess(t):
   60:     if options.get('verbose', 1):
   61:         sys.stdout.write(t)
   62: 
   63: 
   64: def debugcapi(var):
   65:     return 'capi' in debugoptions
   66: 
   67: 
   68: def _ischaracter(var):
   69:     return 'typespec' in var and var['typespec'] == 'character' and \
   70:            not isexternal(var)
   71: 
   72: 
   73: def _isstring(var):
   74:     return 'typespec' in var and var['typespec'] == 'character' and \
   75:            not isexternal(var)
   76: 
   77: 
   78: def ischaracter_or_characterarray(var):
   79:     return _ischaracter(var) and 'charselector' not in var
   80: 
   81: 
   82: def ischaracter(var):
   83:     return ischaracter_or_characterarray(var) and not isarray(var)
   84: 
   85: 
   86: def ischaracterarray(var):
   87:     return ischaracter_or_characterarray(var) and isarray(var)
   88: 
   89: 
   90: def isstring_or_stringarray(var):
   91:     return _ischaracter(var) and 'charselector' in var
   92: 
   93: 
   94: def isstring(var):
   95:     return isstring_or_stringarray(var) and not isarray(var)
   96: 
   97: 
   98: def isstringarray(var):
   99:     return isstring_or_stringarray(var) and isarray(var)
  100: 
  101: 
  102: def isarrayofstrings(var):  # obsolete?
  103:     # leaving out '*' for now so that `character*(*) a(m)` and `character
  104:     # a(m,*)` are treated differently. Luckily `character**` is illegal.
  105:     return isstringarray(var) and var['dimension'][-1] == '(*)'
  106: 
  107: 
  108: def isarray(var):
  109:     return 'dimension' in var and not isexternal(var)
  110: 
  111: 
  112: def isscalar(var):
  113:     return not (isarray(var) or isstring(var) or isexternal(var))
  114: 
  115: 
  116: def iscomplex(var):
  117:     return isscalar(var) and \
  118:            var.get('typespec') in ['complex', 'double complex']
  119: 
  120: 
  121: def islogical(var):
  122:     return isscalar(var) and var.get('typespec') == 'logical'
  123: 
  124: 
  125: def isinteger(var):
  126:     return isscalar(var) and var.get('typespec') == 'integer'
  127: 
  128: 
  129: def isreal(var):
  130:     return isscalar(var) and var.get('typespec') == 'real'
  131: 
  132: 
  133: def get_kind(var):
  134:     try:
  135:         return var['kindselector']['*']
  136:     except KeyError:
  137:         try:
  138:             return var['kindselector']['kind']
  139:         except KeyError:
  140:             pass
  141: 
  142: 
  143: def isint1(var):
  144:     return var.get('typespec') == 'integer' \
  145:         and get_kind(var) == '1' and not isarray(var)
  146: 
  147: 
  148: def islong_long(var):
  149:     if not isscalar(var):
  150:         return 0
  151:     if var.get('typespec') not in ['integer', 'logical']:
  152:         return 0
  153:     return get_kind(var) == '8'
  154: 
  155: 
  156: def isunsigned_char(var):
  157:     if not isscalar(var):
  158:         return 0
  159:     if var.get('typespec') != 'integer':
  160:         return 0
  161:     return get_kind(var) == '-1'
  162: 
  163: 
  164: def isunsigned_short(var):
  165:     if not isscalar(var):
  166:         return 0
  167:     if var.get('typespec') != 'integer':
  168:         return 0
  169:     return get_kind(var) == '-2'
  170: 
  171: 
  172: def isunsigned(var):
  173:     if not isscalar(var):
  174:         return 0
  175:     if var.get('typespec') != 'integer':
  176:         return 0
  177:     return get_kind(var) == '-4'
  178: 
  179: 
  180: def isunsigned_long_long(var):
  181:     if not isscalar(var):
  182:         return 0
  183:     if var.get('typespec') != 'integer':
  184:         return 0
  185:     return get_kind(var) == '-8'
  186: 
  187: 
  188: def isdouble(var):
  189:     if not isscalar(var):
  190:         return 0
  191:     if not var.get('typespec') == 'real':
  192:         return 0
  193:     return get_kind(var) == '8'
  194: 
  195: 
  196: def islong_double(var):
  197:     if not isscalar(var):
  198:         return 0
  199:     if not var.get('typespec') == 'real':
  200:         return 0
  201:     return get_kind(var) == '16'
  202: 
  203: 
  204: def islong_complex(var):
  205:     if not iscomplex(var):
  206:         return 0
  207:     return get_kind(var) == '32'
  208: 
  209: 
  210: def iscomplexarray(var):
  211:     return isarray(var) and \
  212:            var.get('typespec') in ['complex', 'double complex']
  213: 
  214: 
  215: def isint1array(var):
  216:     return isarray(var) and var.get('typespec') == 'integer' \
  217:         and get_kind(var) == '1'
  218: 
  219: 
  220: def isunsigned_chararray(var):
  221:     return isarray(var) and var.get('typespec') in ['integer', 'logical']\
  222:         and get_kind(var) == '-1'
  223: 
  224: 
  225: def isunsigned_shortarray(var):
  226:     return isarray(var) and var.get('typespec') in ['integer', 'logical']\
  227:         and get_kind(var) == '-2'
  228: 
  229: 
  230: def isunsignedarray(var):
  231:     return isarray(var) and var.get('typespec') in ['integer', 'logical']\
  232:         and get_kind(var) == '-4'
  233: 
  234: 
  235: def isunsigned_long_longarray(var):
  236:     return isarray(var) and var.get('typespec') in ['integer', 'logical']\
  237:         and get_kind(var) == '-8'
  238: 
  239: 
  240: def issigned_chararray(var):
  241:     return isarray(var) and var.get('typespec') in ['integer', 'logical']\
  242:         and get_kind(var) == '1'
  243: 
  244: 
  245: def issigned_shortarray(var):
  246:     return isarray(var) and var.get('typespec') in ['integer', 'logical']\
  247:         and get_kind(var) == '2'
  248: 
  249: 
  250: def issigned_array(var):
  251:     return isarray(var) and var.get('typespec') in ['integer', 'logical']\
  252:         and get_kind(var) == '4'
  253: 
  254: 
  255: def issigned_long_longarray(var):
  256:     return isarray(var) and var.get('typespec') in ['integer', 'logical']\
  257:         and get_kind(var) == '8'
  258: 
  259: 
  260: def isallocatable(var):
  261:     return 'attrspec' in var and 'allocatable' in var['attrspec']
  262: 
  263: 
  264: def ismutable(var):
  265:     return not ('dimension' not in var or isstring(var))
  266: 
  267: 
  268: def ismoduleroutine(rout):
  269:     return 'modulename' in rout
  270: 
  271: 
  272: def ismodule(rout):
  273:     return 'block' in rout and 'module' == rout['block']
  274: 
  275: 
  276: def isfunction(rout):
  277:     return 'block' in rout and 'function' == rout['block']
  278: 
  279: 
  280: def isfunction_wrap(rout):
  281:     if isintent_c(rout):
  282:         return 0
  283:     return wrapfuncs and isfunction(rout) and (not isexternal(rout))
  284: 
  285: 
  286: def issubroutine(rout):
  287:     return 'block' in rout and 'subroutine' == rout['block']
  288: 
  289: 
  290: def issubroutine_wrap(rout):
  291:     if isintent_c(rout):
  292:         return 0
  293:     return issubroutine(rout) and hasassumedshape(rout)
  294: 
  295: def isattr_value(var):
  296:     return 'value' in var.get('attrspec', [])
  297: 
  298: 
  299: def hasassumedshape(rout):
  300:     if rout.get('hasassumedshape'):
  301:         return True
  302:     for a in rout['args']:
  303:         for d in rout['vars'].get(a, {}).get('dimension', []):
  304:             if d == ':':
  305:                 rout['hasassumedshape'] = True
  306:                 return True
  307:     return False
  308: 
  309: 
  310: def requiresf90wrapper(rout):
  311:     return ismoduleroutine(rout) or hasassumedshape(rout)
  312: 
  313: 
  314: def isroutine(rout):
  315:     return isfunction(rout) or issubroutine(rout)
  316: 
  317: 
  318: def islogicalfunction(rout):
  319:     if not isfunction(rout):
  320:         return 0
  321:     if 'result' in rout:
  322:         a = rout['result']
  323:     else:
  324:         a = rout['name']
  325:     if a in rout['vars']:
  326:         return islogical(rout['vars'][a])
  327:     return 0
  328: 
  329: 
  330: def islong_longfunction(rout):
  331:     if not isfunction(rout):
  332:         return 0
  333:     if 'result' in rout:
  334:         a = rout['result']
  335:     else:
  336:         a = rout['name']
  337:     if a in rout['vars']:
  338:         return islong_long(rout['vars'][a])
  339:     return 0
  340: 
  341: 
  342: def islong_doublefunction(rout):
  343:     if not isfunction(rout):
  344:         return 0
  345:     if 'result' in rout:
  346:         a = rout['result']
  347:     else:
  348:         a = rout['name']
  349:     if a in rout['vars']:
  350:         return islong_double(rout['vars'][a])
  351:     return 0
  352: 
  353: 
  354: def iscomplexfunction(rout):
  355:     if not isfunction(rout):
  356:         return 0
  357:     if 'result' in rout:
  358:         a = rout['result']
  359:     else:
  360:         a = rout['name']
  361:     if a in rout['vars']:
  362:         return iscomplex(rout['vars'][a])
  363:     return 0
  364: 
  365: 
  366: def iscomplexfunction_warn(rout):
  367:     if iscomplexfunction(rout):
  368:         outmess("""\
  369:     **************************************************************
  370:         Warning: code with a function returning complex value
  371:         may not work correctly with your Fortran compiler.
  372:         When using GNU gcc/g77 compilers, codes should work
  373:         correctly for callbacks with:
  374:         f2py -c -DF2PY_CB_RETURNCOMPLEX
  375:     **************************************************************\n""")
  376:         return 1
  377:     return 0
  378: 
  379: 
  380: def isstringfunction(rout):
  381:     if not isfunction(rout):
  382:         return 0
  383:     if 'result' in rout:
  384:         a = rout['result']
  385:     else:
  386:         a = rout['name']
  387:     if a in rout['vars']:
  388:         return isstring(rout['vars'][a])
  389:     return 0
  390: 
  391: 
  392: def hasexternals(rout):
  393:     return 'externals' in rout and rout['externals']
  394: 
  395: 
  396: def isthreadsafe(rout):
  397:     return 'f2pyenhancements' in rout and \
  398:            'threadsafe' in rout['f2pyenhancements']
  399: 
  400: 
  401: def hasvariables(rout):
  402:     return 'vars' in rout and rout['vars']
  403: 
  404: 
  405: def isoptional(var):
  406:     return ('attrspec' in var and 'optional' in var['attrspec'] and
  407:             'required' not in var['attrspec']) and isintent_nothide(var)
  408: 
  409: 
  410: def isexternal(var):
  411:     return 'attrspec' in var and 'external' in var['attrspec']
  412: 
  413: 
  414: def getdimension(var):
  415:     dimpattern = r"\((.*?)\)"
  416:     if 'attrspec' in var.keys():
  417:         if any('dimension' in s for s in var['attrspec']):
  418:             return next(re.findall(dimpattern, v) for v in var['attrspec'])
  419: 
  420: 
  421: def isrequired(var):
  422:     return not isoptional(var) and isintent_nothide(var)
  423: 
  424: 
  425: def iscstyledirective(f2py_line):
  426:     directives = {"callstatement", "callprotoargument", "pymethoddef"}
  427:     return any(directive in f2py_line.lower() for directive in directives)
  428: 
  429: 
  430: def isintent_in(var):
  431:     if 'intent' not in var:
  432:         return 1
  433:     if 'hide' in var['intent']:
  434:         return 0
  435:     if 'inplace' in var['intent']:
  436:         return 0
  437:     if 'in' in var['intent']:
  438:         return 1
  439:     if 'out' in var['intent']:
  440:         return 0
  441:     if 'inout' in var['intent']:
  442:         return 0
  443:     if 'outin' in var['intent']:
  444:         return 0
  445:     return 1
  446: 
  447: 
  448: def isintent_inout(var):
  449:     return ('intent' in var and ('inout' in var['intent'] or
  450:             'outin' in var['intent']) and 'in' not in var['intent'] and
  451:             'hide' not in var['intent'] and 'inplace' not in var['intent'])
  452: 
  453: 
  454: def isintent_out(var):
  455:     return 'out' in var.get('intent', [])
  456: 
  457: 
  458: def isintent_hide(var):
  459:     return ('intent' in var and ('hide' in var['intent'] or
  460:             ('out' in var['intent'] and 'in' not in var['intent'] and
  461:                 (not l_or(isintent_inout, isintent_inplace)(var)))))
  462: 
  463: 
  464: def isintent_nothide(var):
  465:     return not isintent_hide(var)
  466: 
  467: 
  468: def isintent_c(var):
  469:     return 'c' in var.get('intent', [])
  470: 
  471: 
  472: def isintent_cache(var):
  473:     return 'cache' in var.get('intent', [])
  474: 
  475: 
  476: def isintent_copy(var):
  477:     return 'copy' in var.get('intent', [])
  478: 
  479: 
  480: def isintent_overwrite(var):
  481:     return 'overwrite' in var.get('intent', [])
  482: 
  483: 
  484: def isintent_callback(var):
  485:     return 'callback' in var.get('intent', [])
  486: 
  487: 
  488: def isintent_inplace(var):
  489:     return 'inplace' in var.get('intent', [])
  490: 
  491: 
  492: def isintent_aux(var):
  493:     return 'aux' in var.get('intent', [])
  494: 
  495: 
  496: def isintent_aligned4(var):
  497:     return 'aligned4' in var.get('intent', [])
  498: 
  499: 
  500: def isintent_aligned8(var):
  501:     return 'aligned8' in var.get('intent', [])
  502: 
  503: 
  504: def isintent_aligned16(var):
  505:     return 'aligned16' in var.get('intent', [])
  506: 
  507: 
  508: isintent_dict = {isintent_in: 'INTENT_IN', isintent_inout: 'INTENT_INOUT',
  509:                  isintent_out: 'INTENT_OUT', isintent_hide: 'INTENT_HIDE',
  510:                  isintent_cache: 'INTENT_CACHE',
  511:                  isintent_c: 'INTENT_C', isoptional: 'OPTIONAL',
  512:                  isintent_inplace: 'INTENT_INPLACE',
  513:                  isintent_aligned4: 'INTENT_ALIGNED4',
  514:                  isintent_aligned8: 'INTENT_ALIGNED8',
  515:                  isintent_aligned16: 'INTENT_ALIGNED16',
  516:                  }
  517: 
  518: 
  519: def isprivate(var):
  520:     return 'attrspec' in var and 'private' in var['attrspec']
  521: 
  522: 
  523: def isvariable(var):
  524:     # heuristic to find public/private declarations of filtered subroutines
  525:     if len(var) == 1 and 'attrspec' in var and \
  526:             var['attrspec'][0] in ('public', 'private'):
  527:         is_var = False
  528:     else:
  529:         is_var = True
  530:     return is_var
  531: 
  532: def hasinitvalue(var):
  533:     return '=' in var
  534: 
  535: 
  536: def hasinitvalueasstring(var):
  537:     if not hasinitvalue(var):
  538:         return 0
  539:     return var['='][0] in ['"', "'"]
  540: 
  541: 
  542: def hasnote(var):
  543:     return 'note' in var
  544: 
  545: 
  546: def hasresultnote(rout):
  547:     if not isfunction(rout):
  548:         return 0
  549:     if 'result' in rout:
  550:         a = rout['result']
  551:     else:
  552:         a = rout['name']
  553:     if a in rout['vars']:
  554:         return hasnote(rout['vars'][a])
  555:     return 0
  556: 
  557: 
  558: def hascommon(rout):
  559:     return 'common' in rout
  560: 
  561: 
  562: def containscommon(rout):
  563:     if hascommon(rout):
  564:         return 1
  565:     if hasbody(rout):
  566:         for b in rout['body']:
  567:             if containscommon(b):
  568:                 return 1
  569:     return 0
  570: 
  571: 
  572: def hasderivedtypes(rout):
  573:     return ('block' in rout) and rout['block'] == 'type'
  574: 
  575: 
  576: def containsderivedtypes(rout):
  577:     if hasderivedtypes(rout):
  578:         return 1
  579:     if hasbody(rout):
  580:         for b in rout['body']:
  581:             if hasderivedtypes(b):
  582:                 return 1
  583:     return 0
  584: 
  585: 
  586: def containsmodule(block):
  587:     if ismodule(block):
  588:         return 1
  589:     if not hasbody(block):
  590:         return 0
  591:     for b in block['body']:
  592:         if containsmodule(b):
  593:             return 1
  594:     return 0
  595: 
  596: 
  597: def hasbody(rout):
  598:     return 'body' in rout
  599: 
  600: 
  601: def hascallstatement(rout):
  602:     return getcallstatement(rout) is not None
  603: 
  604: 
  605: def istrue(var):
  606:     return 1
  607: 
  608: 
  609: def isfalse(var):
  610:     return 0
  611: 
  612: 
  613: class F2PYError(Exception):
  614:     pass
  615: 
  616: 
  617: class throw_error:
  618: 
  619:     def __init__(self, mess):
  620:         self.mess = mess
  621: 
  622:     def __call__(self, var):
  623:         mess = f'\n\n  var = {var}\n  Message: {self.mess}\n'
  624:         raise F2PYError(mess)
  625: 
  626: 
  627: def l_and(*f):
  628:     l1, l2 = 'lambda v', []
  629:     for i in range(len(f)):
  630:         l1 = '%s,f%d=f[%d]' % (l1, i, i)
  631:         l2.append('f%d(v)' % (i))
  632:     return eval(f"{l1}:{' and '.join(l2)}")
  633: 
  634: 
  635: def l_or(*f):
  636:     l1, l2 = 'lambda v', []
  637:     for i in range(len(f)):
  638:         l1 = '%s,f%d=f[%d]' % (l1, i, i)
  639:         l2.append('f%d(v)' % (i))
  640:     return eval(f"{l1}:{' or '.join(l2)}")
  641: 
  642: 
  643: def l_not(f):
  644:     return eval('lambda v,f=f:not f(v)')
  645: 
  646: 
  647: def isdummyroutine(rout):
  648:     try:
  649:         return rout['f2pyenhancements']['fortranname'] == ''
  650:     except KeyError:
  651:         return 0
  652: 
  653: 
  654: def getfortranname(rout):
  655:     try:
  656:         name = rout['f2pyenhancements']['fortranname']
  657:         if name == '':
  658:             raise KeyError
  659:         if not name:
  660:             errmess(f"Failed to use fortranname from {rout['f2pyenhancements']}\n")
  661:             raise KeyError
  662:     except KeyError:
  663:         name = rout['name']
  664:     return name
  665: 
  666: 
  667: def getmultilineblock(rout, blockname, comment=1, counter=0):
  668:     try:
  669:         r = rout['f2pyenhancements'].get(blockname)
  670:     except KeyError:
  671:         return
  672:     if not r:
  673:         return
  674:     if counter > 0 and isinstance(r, str):
  675:         return
  676:     if isinstance(r, list):
  677:         if counter >= len(r):
  678:             return
  679:         r = r[counter]
  680:     if r[:3] == "'''":
  681:         if comment:
  682:             r = '\t/* start ' + blockname + \
  683:                 ' multiline (' + repr(counter) + ') */\n' + r[3:]
  684:         else:
  685:             r = r[3:]
  686:         if r[-3:] == "'''":
  687:             if comment:
  688:                 r = r[:-3] + '\n\t/* end multiline (' + repr(counter) + ')*/'
  689:             else:
  690:                 r = r[:-3]
  691:         else:
  692:             errmess(f"{blockname} multiline block should end with `'''`: {repr(r)}\n")
  693:     return r
  694: 
  695: 
  696: def getcallstatement(rout):
  697:     return getmultilineblock(rout, 'callstatement')
  698: 
  699: 
  700: def getcallprotoargument(rout, cb_map={}):
  701:     r = getmultilineblock(rout, 'callprotoargument', comment=0)
  702:     if r:
  703:         return r
  704:     if hascallstatement(rout):
  705:         outmess(
  706:             'warning: callstatement is defined without callprotoargument\n')
  707:         return
  708:     from .capi_maps import getctype
  709:     arg_types, arg_types2 = [], []
  710:     if l_and(isstringfunction, l_not(isfunction_wrap))(rout):
  711:         arg_types.extend(['char*', 'size_t'])
  712:     for n in rout['args']:
  713:         var = rout['vars'][n]
  714:         if isintent_callback(var):
  715:             continue
  716:         if n in cb_map:
  717:             ctype = cb_map[n] + '_typedef'
  718:         else:
  719:             ctype = getctype(var)
  720:             if l_and(isintent_c, l_or(isscalar, iscomplex))(var):
  721:                 pass
  722:             elif isstring(var):
  723:                 pass
  724:             elif not isattr_value(var):
  725:                 ctype = ctype + '*'
  726:             if (isstring(var)
  727:                  or isarrayofstrings(var)  # obsolete?
  728:                  or isstringarray(var)):
  729:                 arg_types2.append('size_t')
  730:         arg_types.append(ctype)
  731: 
  732:     proto_args = ','.join(arg_types + arg_types2)
  733:     if not proto_args:
  734:         proto_args = 'void'
  735:     return proto_args
  736: 
  737: 
  738: def getusercode(rout):
  739:     return getmultilineblock(rout, 'usercode')
  740: 
  741: 
  742: def getusercode1(rout):
  743:     return getmultilineblock(rout, 'usercode', counter=1)
  744: 
  745: 
  746: def getpymethoddef(rout):
  747:     return getmultilineblock(rout, 'pymethoddef')
  748: 
  749: 
  750: def getargs(rout):
  751:     sortargs, args = [], []
  752:     if 'args' in rout:
  753:         args = rout['args']
  754:         if 'sortvars' in rout:
  755:             for a in rout['sortvars']:
  756:                 if a in args:
  757:                     sortargs.append(a)
  758:             for a in args:
  759:                 if a not in sortargs:
  760:                     sortargs.append(a)
  761:         else:
  762:             sortargs = rout['args']
  763:     return args, sortargs
  764: 
  765: 
  766: def getargs2(rout):
  767:     sortargs, args = [], rout.get('args', [])
  768:     auxvars = [a for a in rout['vars'].keys() if isintent_aux(rout['vars'][a])
  769:                and a not in args]
  770:     args = auxvars + args
  771:     if 'sortvars' in rout:
  772:         for a in rout['sortvars']:
  773:             if a in args:
  774:                 sortargs.append(a)
  775:         for a in args:
  776:             if a not in sortargs:
  777:                 sortargs.append(a)
  778:     else:
  779:         sortargs = auxvars + rout['args']
  780:     return args, sortargs
  781: 
  782: 
  783: def getrestdoc(rout):
  784:     if 'f2pymultilines' not in rout:
  785:         return None
  786:     k = None
  787:     if rout['block'] == 'python module':
  788:         k = rout['block'], rout['name']
  789:     return rout['f2pymultilines'].get(k, None)
  790: 
  791: 
  792: def gentitle(name):
  793:     ln = (80 - len(name) - 6) // 2
  794:     return f"/*{ln * '*'} {name} {ln * '*'}*/"
  795: 
  796: 
  797: def flatlist(lst):
  798:     if isinstance(lst, list):
  799:         return reduce(lambda x, y, f=flatlist: x + f(y), lst, [])
  800:     return [lst]
  801: 
  802: 
  803: def stripcomma(s):
  804:     if s and s[-1] == ',':
  805:         return s[:-1]
  806:     return s
  807: 
  808: 
  809: def replace(str, d, defaultsep=''):
  810:     if isinstance(d, list):
  811:         return [replace(str, _m, defaultsep) for _m in d]
  812:     if isinstance(str, list):
  813:         return [replace(_m, d, defaultsep) for _m in str]
  814:     for k in 2 * list(d.keys()):
  815:         if k == 'separatorsfor':
  816:             continue
  817:         if 'separatorsfor' in d and k in d['separatorsfor']:
  818:             sep = d['separatorsfor'][k]
  819:         else:
  820:             sep = defaultsep
  821:         if isinstance(d[k], list):
  822:             str = str.replace(f'#{k}#', sep.join(flatlist(d[k])))
  823:         else:
  824:             str = str.replace(f'#{k}#', d[k])
  825:     return str
  826: 
  827: 
  828: def dictappend(rd, ar):
  829:     if isinstance(ar, list):
  830:         for a in ar:
  831:             rd = dictappend(rd, a)
  832:         return rd
  833:     for k in ar.keys():
  834:         if k[0] == '_':
  835:             continue
  836:         if k in rd:
  837:             if isinstance(rd[k], str):
  838:                 rd[k] = [rd[k]]
  839:             if isinstance(rd[k], list):
  840:                 if isinstance(ar[k], list):
  841:                     rd[k] = rd[k] + ar[k]
  842:                 else:
  843:                     rd[k].append(ar[k])
  844:             elif isinstance(rd[k], dict):
  845:                 if isinstance(ar[k], dict):
  846:                     if k == 'separatorsfor':
  847:                         for k1 in ar[k].keys():
  848:                             if k1 not in rd[k]:
  849:                                 rd[k][k1] = ar[k][k1]
  850:                     else:
  851:                         rd[k] = dictappend(rd[k], ar[k])
  852:         else:
  853:             rd[k] = ar[k]
  854:     return rd
  855: 
  856: 
  857: def applyrules(rules, d, var={}):
  858:     ret = {}
  859:     if isinstance(rules, list):
  860:         for r in rules:
  861:             rr = applyrules(r, d, var)
  862:             ret = dictappend(ret, rr)
  863:             if '_break' in rr:
  864:                 break
  865:         return ret
  866:     if '_check' in rules and (not rules['_check'](var)):
  867:         return ret
  868:     if 'need' in rules:
  869:         res = applyrules({'needs': rules['need']}, d, var)
  870:         if 'needs' in res:
  871:             cfuncs.append_needs(res['needs'])
  872: 
  873:     for k in rules.keys():
  874:         if k == 'separatorsfor':
  875:             ret[k] = rules[k]
  876:             continue
  877:         if isinstance(rules[k], str):
  878:             ret[k] = replace(rules[k], d)
  879:         elif isinstance(rules[k], list):
  880:             ret[k] = []
  881:             for i in rules[k]:
  882:                 ar = applyrules({k: i}, d, var)
  883:                 if k in ar:
  884:                     ret[k].append(ar[k])
  885:         elif k[0] == '_':
  886:             continue
  887:         elif isinstance(rules[k], dict):
  888:             ret[k] = []
  889:             for k1 in rules[k].keys():
  890:                 if isinstance(k1, types.FunctionType) and k1(var):
  891:                     if isinstance(rules[k][k1], list):
  892:                         for i in rules[k][k1]:
  893:                             if isinstance(i, dict):
  894:                                 res = applyrules({'supertext': i}, d, var)
  895:                                 i = res.get('supertext', '')
  896:                             ret[k].append(replace(i, d))
  897:                     else:
  898:                         i = rules[k][k1]
  899:                         if isinstance(i, dict):
  900:                             res = applyrules({'supertext': i}, d)
  901:                             i = res.get('supertext', '')
  902:                         ret[k].append(replace(i, d))
  903:         else:
  904:             errmess(f'applyrules: ignoring rule {repr(rules[k])}.\n')
  905:         if isinstance(ret[k], list):
  906:             if len(ret[k]) == 1:
  907:                 ret[k] = ret[k][0]
  908:             if ret[k] == []:
  909:                 del ret[k]
  910:     return ret
  911: 
  912: 
  913: _f2py_module_name_match = re.compile(r'\s*python\s*module\s*(?P<name>[\w_]+)',
  914:                                      re.I).match
  915: _f2py_user_module_name_match = re.compile(r'\s*python\s*module\s*(?P<name>[\w_]*?'
  916:                                           r'__user__[\w_]*)', re.I).match
  917: 
  918: def get_f2py_modulename(source):
  919:     name = None
  920:     with open(source) as f:
  921:         for line in f:
  922:             m = _f2py_module_name_match(line)
  923:             if m:
  924:                 if _f2py_user_module_name_match(line):  # skip *__user__* names
  925:                     continue
  926:                 name = m.group('name')
  927:                 break
  928:     return name
  929: 
  930: def getuseblocks(pymod):
  931:     all_uses = []
  932:     for inner in pymod['body']:
  933:         for modblock in inner['body']:
  934:             if modblock.get('use'):
  935:                 all_uses.extend([x for x in modblock.get("use").keys() if "__" not in x])
  936:     return all_uses
  937: 
  938: def process_f2cmap_dict(f2cmap_all, new_map, c2py_map, verbose=False):
  939:     """
  940:     Update the Fortran-to-C type mapping dictionary with new mappings and
  941:     return a list of successfully mapped C types.
  942: 
  943:     This function integrates a new mapping dictionary into an existing
  944:     Fortran-to-C type mapping dictionary. It ensures that all keys are in
  945:     lowercase and validates new entries against a given C-to-Python mapping
  946:     dictionary. Redefinitions and invalid entries are reported with a warning.
  947: 
  948:     Parameters
  949:     ----------
  950:     f2cmap_all : dict
  951:         The existing Fortran-to-C type mapping dictionary that will be updated.
  952:         It should be a dictionary of dictionaries where the main keys represent
  953:         Fortran types and the nested dictionaries map Fortran type specifiers
  954:         to corresponding C types.
  955: 
  956:     new_map : dict
  957:         A dictionary containing new type mappings to be added to `f2cmap_all`.
  958:         The structure should be similar to `f2cmap_all`, with keys representing
  959:         Fortran types and values being dictionaries of type specifiers and their
  960:         C type equivalents.
  961: 
  962:     c2py_map : dict
  963:         A dictionary used for validating the C types in `new_map`. It maps C
  964:         types to corresponding Python types and is used to ensure that the C
  965:         types specified in `new_map` are valid.
  966: 
  967:     verbose : boolean
  968:         A flag used to provide information about the types mapped
  969: 
  970:     Returns
  971:     -------
  972:     tuple of (dict, list)
  973:         The updated Fortran-to-C type mapping dictionary and a list of
  974:         successfully mapped C types.
  975:     """
  976:     f2cmap_mapped = []
  977: 
  978:     new_map_lower = {}
  979:     for k, d1 in new_map.items():
  980:         d1_lower = {k1.lower(): v1 for k1, v1 in d1.items()}
  981:         new_map_lower[k.lower()] = d1_lower
  982: 
  983:     for k, d1 in new_map_lower.items():
  984:         if k not in f2cmap_all:
  985:             f2cmap_all[k] = {}
  986: 
  987:         for k1, v1 in d1.items():
  988:             if v1 in c2py_map:
  989:                 if k1 in f2cmap_all[k]:
  990:                     outmess(
  991:                         "\tWarning: redefinition of {'%s':{'%s':'%s'->'%s'}}\n"
  992:                         % (k, k1, f2cmap_all[k][k1], v1)
  993:                     )
  994:                 f2cmap_all[k][k1] = v1
  995:                 if verbose:
  996:                     outmess(f'\tMapping "{k}(kind={k1})" to "{v1}\"\n')
  997:                 f2cmap_mapped.append(v1)
  998:             elif verbose:
  999:                 errmess(
 1000:                     "\tIgnoring map {'%s':{'%s':'%s'}}: '%s' must be in %s\n"
 1001:                     % (k, k1, v1, v1, list(c2py_map.keys()))
 1002:                 )
 1003: 
 1004:     return f2cmap_all, f2cmap_mapped
