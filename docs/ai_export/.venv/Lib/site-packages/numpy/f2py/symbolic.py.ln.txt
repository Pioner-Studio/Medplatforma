    1: """Fortran/C symbolic expressions
    2: 
    3: References:
    4: - J3/21-007: Draft Fortran 202x. https://j3-fortran.org/doc/year/21/21-007.pdf
    5: 
    6: Copyright 1999 -- 2011 Pearu Peterson all rights reserved.
    7: Copyright 2011 -- present NumPy Developers.
    8: Permission to use, modify, and distribute this software is given under the
    9: terms of the NumPy License.
   10: 
   11: NO WARRANTY IS EXPRESSED OR IMPLIED.  USE AT YOUR OWN RISK.
   12: """
   13: 
   14: # To analyze Fortran expressions to solve dimensions specifications,
   15: # for instances, we implement a minimal symbolic engine for parsing
   16: # expressions into a tree of expression instances. As a first
   17: # instance, we care only about arithmetic expressions involving
   18: # integers and operations like addition (+), subtraction (-),
   19: # multiplication (*), division (Fortran / is Python //, Fortran // is
   20: # concatenate), and exponentiation (**).  In addition, .pyf files may
   21: # contain C expressions that support here is implemented as well.
   22: #
   23: # TODO: support logical constants (Op.BOOLEAN)
   24: # TODO: support logical operators (.AND., ...)
   25: # TODO: support defined operators (.MYOP., ...)
   26: #
   27: __all__ = ['Expr']
   28: 
   29: 
   30: import re
   31: import warnings
   32: from enum import Enum
   33: from math import gcd
   34: 
   35: 
   36: class Language(Enum):
   37:     """
   38:     Used as Expr.tostring language argument.
   39:     """
   40:     Python = 0
   41:     Fortran = 1
   42:     C = 2
   43: 
   44: 
   45: class Op(Enum):
   46:     """
   47:     Used as Expr op attribute.
   48:     """
   49:     INTEGER = 10
   50:     REAL = 12
   51:     COMPLEX = 15
   52:     STRING = 20
   53:     ARRAY = 30
   54:     SYMBOL = 40
   55:     TERNARY = 100
   56:     APPLY = 200
   57:     INDEXING = 210
   58:     CONCAT = 220
   59:     RELATIONAL = 300
   60:     TERMS = 1000
   61:     FACTORS = 2000
   62:     REF = 3000
   63:     DEREF = 3001
   64: 
   65: 
   66: class RelOp(Enum):
   67:     """
   68:     Used in Op.RELATIONAL expression to specify the function part.
   69:     """
   70:     EQ = 1
   71:     NE = 2
   72:     LT = 3
   73:     LE = 4
   74:     GT = 5
   75:     GE = 6
   76: 
   77:     @classmethod
   78:     def fromstring(cls, s, language=Language.C):
   79:         if language is Language.Fortran:
   80:             return {'.eq.': RelOp.EQ, '.ne.': RelOp.NE,
   81:                     '.lt.': RelOp.LT, '.le.': RelOp.LE,
   82:                     '.gt.': RelOp.GT, '.ge.': RelOp.GE}[s.lower()]
   83:         return {'==': RelOp.EQ, '!=': RelOp.NE, '<': RelOp.LT,
   84:                 '<=': RelOp.LE, '>': RelOp.GT, '>=': RelOp.GE}[s]
   85: 
   86:     def tostring(self, language=Language.C):
   87:         if language is Language.Fortran:
   88:             return {RelOp.EQ: '.eq.', RelOp.NE: '.ne.',
   89:                     RelOp.LT: '.lt.', RelOp.LE: '.le.',
   90:                     RelOp.GT: '.gt.', RelOp.GE: '.ge.'}[self]
   91:         return {RelOp.EQ: '==', RelOp.NE: '!=',
   92:                 RelOp.LT: '<', RelOp.LE: '<=',
   93:                 RelOp.GT: '>', RelOp.GE: '>='}[self]
   94: 
   95: 
   96: class ArithOp(Enum):
   97:     """
   98:     Used in Op.APPLY expression to specify the function part.
   99:     """
  100:     POS = 1
  101:     NEG = 2
  102:     ADD = 3
  103:     SUB = 4
  104:     MUL = 5
  105:     DIV = 6
  106:     POW = 7
  107: 
  108: 
  109: class OpError(Exception):
  110:     pass
  111: 
  112: 
  113: class Precedence(Enum):
  114:     """
  115:     Used as Expr.tostring precedence argument.
  116:     """
  117:     ATOM = 0
  118:     POWER = 1
  119:     UNARY = 2
  120:     PRODUCT = 3
  121:     SUM = 4
  122:     LT = 6
  123:     EQ = 7
  124:     LAND = 11
  125:     LOR = 12
  126:     TERNARY = 13
  127:     ASSIGN = 14
  128:     TUPLE = 15
  129:     NONE = 100
  130: 
  131: 
  132: integer_types = (int,)
  133: number_types = (int, float)
  134: 
  135: 
  136: def _pairs_add(d, k, v):
  137:     # Internal utility method for updating terms and factors data.
  138:     c = d.get(k)
  139:     if c is None:
  140:         d[k] = v
  141:     else:
  142:         c = c + v
  143:         if c:
  144:             d[k] = c
  145:         else:
  146:             del d[k]
  147: 
  148: 
  149: class ExprWarning(UserWarning):
  150:     pass
  151: 
  152: 
  153: def ewarn(message):
  154:     warnings.warn(message, ExprWarning, stacklevel=2)
  155: 
  156: 
  157: class Expr:
  158:     """Represents a Fortran expression as a op-data pair.
  159: 
  160:     Expr instances are hashable and sortable.
  161:     """
  162: 
  163:     @staticmethod
  164:     def parse(s, language=Language.C):
  165:         """Parse a Fortran expression to a Expr.
  166:         """
  167:         return fromstring(s, language=language)
  168: 
  169:     def __init__(self, op, data):
  170:         assert isinstance(op, Op)
  171: 
  172:         # sanity checks
  173:         if op is Op.INTEGER:
  174:             # data is a 2-tuple of numeric object and a kind value
  175:             # (default is 4)
  176:             assert isinstance(data, tuple) and len(data) == 2
  177:             assert isinstance(data[0], int)
  178:             assert isinstance(data[1], (int, str)), data
  179:         elif op is Op.REAL:
  180:             # data is a 2-tuple of numeric object and a kind value
  181:             # (default is 4)
  182:             assert isinstance(data, tuple) and len(data) == 2
  183:             assert isinstance(data[0], float)
  184:             assert isinstance(data[1], (int, str)), data
  185:         elif op is Op.COMPLEX:
  186:             # data is a 2-tuple of constant expressions
  187:             assert isinstance(data, tuple) and len(data) == 2
  188:         elif op is Op.STRING:
  189:             # data is a 2-tuple of quoted string and a kind value
  190:             # (default is 1)
  191:             assert isinstance(data, tuple) and len(data) == 2
  192:             assert (isinstance(data[0], str)
  193:                     and data[0][::len(data[0]) - 1] in ('""', "''", '@@'))
  194:             assert isinstance(data[1], (int, str)), data
  195:         elif op is Op.SYMBOL:
  196:             # data is any hashable object
  197:             assert hash(data) is not None
  198:         elif op in (Op.ARRAY, Op.CONCAT):
  199:             # data is a tuple of expressions
  200:             assert isinstance(data, tuple)
  201:             assert all(isinstance(item, Expr) for item in data), data
  202:         elif op in (Op.TERMS, Op.FACTORS):
  203:             # data is {<term|base>:<coeff|exponent>} where dict values
  204:             # are nonzero Python integers
  205:             assert isinstance(data, dict)
  206:         elif op is Op.APPLY:
  207:             # data is (<function>, <operands>, <kwoperands>) where
  208:             # operands are Expr instances
  209:             assert isinstance(data, tuple) and len(data) == 3
  210:             # function is any hashable object
  211:             assert hash(data[0]) is not None
  212:             assert isinstance(data[1], tuple)
  213:             assert isinstance(data[2], dict)
  214:         elif op is Op.INDEXING:
  215:             # data is (<object>, <indices>)
  216:             assert isinstance(data, tuple) and len(data) == 2
  217:             # function is any hashable object
  218:             assert hash(data[0]) is not None
  219:         elif op is Op.TERNARY:
  220:             # data is (<cond>, <expr1>, <expr2>)
  221:             assert isinstance(data, tuple) and len(data) == 3
  222:         elif op in (Op.REF, Op.DEREF):
  223:             # data is Expr instance
  224:             assert isinstance(data, Expr)
  225:         elif op is Op.RELATIONAL:
  226:             # data is (<relop>, <left>, <right>)
  227:             assert isinstance(data, tuple) and len(data) == 3
  228:         else:
  229:             raise NotImplementedError(
  230:                 f'unknown op or missing sanity check: {op}')
  231: 
  232:         self.op = op
  233:         self.data = data
  234: 
  235:     def __eq__(self, other):
  236:         return (isinstance(other, Expr)
  237:                 and self.op is other.op
  238:                 and self.data == other.data)
  239: 
  240:     def __hash__(self):
  241:         if self.op in (Op.TERMS, Op.FACTORS):
  242:             data = tuple(sorted(self.data.items()))
  243:         elif self.op is Op.APPLY:
  244:             data = self.data[:2] + tuple(sorted(self.data[2].items()))
  245:         else:
  246:             data = self.data
  247:         return hash((self.op, data))
  248: 
  249:     def __lt__(self, other):
  250:         if isinstance(other, Expr):
  251:             if self.op is not other.op:
  252:                 return self.op.value < other.op.value
  253:             if self.op in (Op.TERMS, Op.FACTORS):
  254:                 return (tuple(sorted(self.data.items()))
  255:                         < tuple(sorted(other.data.items())))
  256:             if self.op is Op.APPLY:
  257:                 if self.data[:2] != other.data[:2]:
  258:                     return self.data[:2] < other.data[:2]
  259:                 return tuple(sorted(self.data[2].items())) < tuple(
  260:                     sorted(other.data[2].items()))
  261:             return self.data < other.data
  262:         return NotImplemented
  263: 
  264:     def __le__(self, other): return self == other or self < other
  265: 
  266:     def __gt__(self, other): return not (self <= other)
  267: 
  268:     def __ge__(self, other): return not (self < other)
  269: 
  270:     def __repr__(self):
  271:         return f'{type(self).__name__}({self.op}, {self.data!r})'
  272: 
  273:     def __str__(self):
  274:         return self.tostring()
  275: 
  276:     def tostring(self, parent_precedence=Precedence.NONE,
  277:                  language=Language.Fortran):
  278:         """Return a string representation of Expr.
  279:         """
  280:         if self.op in (Op.INTEGER, Op.REAL):
  281:             precedence = (Precedence.SUM if self.data[0] < 0
  282:                           else Precedence.ATOM)
  283:             r = str(self.data[0]) + (f'_{self.data[1]}'
  284:                                      if self.data[1] != 4 else '')
  285:         elif self.op is Op.COMPLEX:
  286:             r = ', '.join(item.tostring(Precedence.TUPLE, language=language)
  287:                           for item in self.data)
  288:             r = '(' + r + ')'
  289:             precedence = Precedence.ATOM
  290:         elif self.op is Op.SYMBOL:
  291:             precedence = Precedence.ATOM
  292:             r = str(self.data)
  293:         elif self.op is Op.STRING:
  294:             r = self.data[0]
  295:             if self.data[1] != 1:
  296:                 r = self.data[1] + '_' + r
  297:             precedence = Precedence.ATOM
  298:         elif self.op is Op.ARRAY:
  299:             r = ', '.join(item.tostring(Precedence.TUPLE, language=language)
  300:                           for item in self.data)
  301:             r = '[' + r + ']'
  302:             precedence = Precedence.ATOM
  303:         elif self.op is Op.TERMS:
  304:             terms = []
  305:             for term, coeff in sorted(self.data.items()):
  306:                 if coeff < 0:
  307:                     op = ' - '
  308:                     coeff = -coeff
  309:                 else:
  310:                     op = ' + '
  311:                 if coeff == 1:
  312:                     term = term.tostring(Precedence.SUM, language=language)
  313:                 elif term == as_number(1):
  314:                     term = str(coeff)
  315:                 else:
  316:                     term = f'{coeff} * ' + term.tostring(
  317:                         Precedence.PRODUCT, language=language)
  318:                 if terms:
  319:                     terms.append(op)
  320:                 elif op == ' - ':
  321:                     terms.append('-')
  322:                 terms.append(term)
  323:             r = ''.join(terms) or '0'
  324:             precedence = Precedence.SUM if terms else Precedence.ATOM
  325:         elif self.op is Op.FACTORS:
  326:             factors = []
  327:             tail = []
  328:             for base, exp in sorted(self.data.items()):
  329:                 op = ' * '
  330:                 if exp == 1:
  331:                     factor = base.tostring(Precedence.PRODUCT,
  332:                                            language=language)
  333:                 elif language is Language.C:
  334:                     if exp in range(2, 10):
  335:                         factor = base.tostring(Precedence.PRODUCT,
  336:                                                language=language)
  337:                         factor = ' * '.join([factor] * exp)
  338:                     elif exp in range(-10, 0):
  339:                         factor = base.tostring(Precedence.PRODUCT,
  340:                                                language=language)
  341:                         tail += [factor] * -exp
  342:                         continue
  343:                     else:
  344:                         factor = base.tostring(Precedence.TUPLE,
  345:                                                language=language)
  346:                         factor = f'pow({factor}, {exp})'
  347:                 else:
  348:                     factor = base.tostring(Precedence.POWER,
  349:                                            language=language) + f' ** {exp}'
  350:                 if factors:
  351:                     factors.append(op)
  352:                 factors.append(factor)
  353:             if tail:
  354:                 if not factors:
  355:                     factors += ['1']
  356:                 factors += ['/', '(', ' * '.join(tail), ')']
  357:             r = ''.join(factors) or '1'
  358:             precedence = Precedence.PRODUCT if factors else Precedence.ATOM
  359:         elif self.op is Op.APPLY:
  360:             name, args, kwargs = self.data
  361:             if name is ArithOp.DIV and language is Language.C:
  362:                 numer, denom = [arg.tostring(Precedence.PRODUCT,
  363:                                              language=language)
  364:                                 for arg in args]
  365:                 r = f'{numer} / {denom}'
  366:                 precedence = Precedence.PRODUCT
  367:             else:
  368:                 args = [arg.tostring(Precedence.TUPLE, language=language)
  369:                         for arg in args]
  370:                 args += [k + '=' + v.tostring(Precedence.NONE)
  371:                          for k, v in kwargs.items()]
  372:                 r = f'{name}({", ".join(args)})'
  373:                 precedence = Precedence.ATOM
  374:         elif self.op is Op.INDEXING:
  375:             name = self.data[0]
  376:             args = [arg.tostring(Precedence.TUPLE, language=language)
  377:                     for arg in self.data[1:]]
  378:             r = f'{name}[{", ".join(args)}]'
  379:             precedence = Precedence.ATOM
  380:         elif self.op is Op.CONCAT:
  381:             args = [arg.tostring(Precedence.PRODUCT, language=language)
  382:                     for arg in self.data]
  383:             r = " // ".join(args)
  384:             precedence = Precedence.PRODUCT
  385:         elif self.op is Op.TERNARY:
  386:             cond, expr1, expr2 = [a.tostring(Precedence.TUPLE,
  387:                                              language=language)
  388:                                   for a in self.data]
  389:             if language is Language.C:
  390:                 r = f'({cond}?{expr1}:{expr2})'
  391:             elif language is Language.Python:
  392:                 r = f'({expr1} if {cond} else {expr2})'
  393:             elif language is Language.Fortran:
  394:                 r = f'merge({expr1}, {expr2}, {cond})'
  395:             else:
  396:                 raise NotImplementedError(
  397:                     f'tostring for {self.op} and {language}')
  398:             precedence = Precedence.ATOM
  399:         elif self.op is Op.REF:
  400:             r = '&' + self.data.tostring(Precedence.UNARY, language=language)
  401:             precedence = Precedence.UNARY
  402:         elif self.op is Op.DEREF:
  403:             r = '*' + self.data.tostring(Precedence.UNARY, language=language)
  404:             precedence = Precedence.UNARY
  405:         elif self.op is Op.RELATIONAL:
  406:             rop, left, right = self.data
  407:             precedence = (Precedence.EQ if rop in (RelOp.EQ, RelOp.NE)
  408:                           else Precedence.LT)
  409:             left = left.tostring(precedence, language=language)
  410:             right = right.tostring(precedence, language=language)
  411:             rop = rop.tostring(language=language)
  412:             r = f'{left} {rop} {right}'
  413:         else:
  414:             raise NotImplementedError(f'tostring for op {self.op}')
  415:         if parent_precedence.value < precedence.value:
  416:             # If parent precedence is higher than operand precedence,
  417:             # operand will be enclosed in parenthesis.
  418:             return '(' + r + ')'
  419:         return r
  420: 
  421:     def __pos__(self):
  422:         return self
  423: 
  424:     def __neg__(self):
  425:         return self * -1
  426: 
  427:     def __add__(self, other):
  428:         other = as_expr(other)
  429:         if isinstance(other, Expr):
  430:             if self.op is other.op:
  431:                 if self.op in (Op.INTEGER, Op.REAL):
  432:                     return as_number(
  433:                         self.data[0] + other.data[0],
  434:                         max(self.data[1], other.data[1]))
  435:                 if self.op is Op.COMPLEX:
  436:                     r1, i1 = self.data
  437:                     r2, i2 = other.data
  438:                     return as_complex(r1 + r2, i1 + i2)
  439:                 if self.op is Op.TERMS:
  440:                     r = Expr(self.op, dict(self.data))
  441:                     for k, v in other.data.items():
  442:                         _pairs_add(r.data, k, v)
  443:                     return normalize(r)
  444:             if self.op is Op.COMPLEX and other.op in (Op.INTEGER, Op.REAL):
  445:                 return self + as_complex(other)
  446:             elif self.op in (Op.INTEGER, Op.REAL) and other.op is Op.COMPLEX:
  447:                 return as_complex(self) + other
  448:             elif self.op is Op.REAL and other.op is Op.INTEGER:
  449:                 return self + as_real(other, kind=self.data[1])
  450:             elif self.op is Op.INTEGER and other.op is Op.REAL:
  451:                 return as_real(self, kind=other.data[1]) + other
  452:             return as_terms(self) + as_terms(other)
  453:         return NotImplemented
  454: 
  455:     def __radd__(self, other):
  456:         if isinstance(other, number_types):
  457:             return as_number(other) + self
  458:         return NotImplemented
  459: 
  460:     def __sub__(self, other):
  461:         return self + (-other)
  462: 
  463:     def __rsub__(self, other):
  464:         if isinstance(other, number_types):
  465:             return as_number(other) - self
  466:         return NotImplemented
  467: 
  468:     def __mul__(self, other):
  469:         other = as_expr(other)
  470:         if isinstance(other, Expr):
  471:             if self.op is other.op:
  472:                 if self.op in (Op.INTEGER, Op.REAL):
  473:                     return as_number(self.data[0] * other.data[0],
  474:                                      max(self.data[1], other.data[1]))
  475:                 elif self.op is Op.COMPLEX:
  476:                     r1, i1 = self.data
  477:                     r2, i2 = other.data
  478:                     return as_complex(r1 * r2 - i1 * i2, r1 * i2 + r2 * i1)
  479: 
  480:                 if self.op is Op.FACTORS:
  481:                     r = Expr(self.op, dict(self.data))
  482:                     for k, v in other.data.items():
  483:                         _pairs_add(r.data, k, v)
  484:                     return normalize(r)
  485:                 elif self.op is Op.TERMS:
  486:                     r = Expr(self.op, {})
  487:                     for t1, c1 in self.data.items():
  488:                         for t2, c2 in other.data.items():
  489:                             _pairs_add(r.data, t1 * t2, c1 * c2)
  490:                     return normalize(r)
  491: 
  492:             if self.op is Op.COMPLEX and other.op in (Op.INTEGER, Op.REAL):
  493:                 return self * as_complex(other)
  494:             elif other.op is Op.COMPLEX and self.op in (Op.INTEGER, Op.REAL):
  495:                 return as_complex(self) * other
  496:             elif self.op is Op.REAL and other.op is Op.INTEGER:
  497:                 return self * as_real(other, kind=self.data[1])
  498:             elif self.op is Op.INTEGER and other.op is Op.REAL:
  499:                 return as_real(self, kind=other.data[1]) * other
  500: 
  501:             if self.op is Op.TERMS:
  502:                 return self * as_terms(other)
  503:             elif other.op is Op.TERMS:
  504:                 return as_terms(self) * other
  505: 
  506:             return as_factors(self) * as_factors(other)
  507:         return NotImplemented
  508: 
  509:     def __rmul__(self, other):
  510:         if isinstance(other, number_types):
  511:             return as_number(other) * self
  512:         return NotImplemented
  513: 
  514:     def __pow__(self, other):
  515:         other = as_expr(other)
  516:         if isinstance(other, Expr):
  517:             if other.op is Op.INTEGER:
  518:                 exponent = other.data[0]
  519:                 # TODO: other kind not used
  520:                 if exponent == 0:
  521:                     return as_number(1)
  522:                 if exponent == 1:
  523:                     return self
  524:                 if exponent > 0:
  525:                     if self.op is Op.FACTORS:
  526:                         r = Expr(self.op, {})
  527:                         for k, v in self.data.items():
  528:                             r.data[k] = v * exponent
  529:                         return normalize(r)
  530:                     return self * (self ** (exponent - 1))
  531:                 elif exponent != -1:
  532:                     return (self ** (-exponent)) ** -1
  533:                 return Expr(Op.FACTORS, {self: exponent})
  534:             return as_apply(ArithOp.POW, self, other)
  535:         return NotImplemented
  536: 
  537:     def __truediv__(self, other):
  538:         other = as_expr(other)
  539:         if isinstance(other, Expr):
  540:             # Fortran / is different from Python /:
  541:             # - `/` is a truncate operation for integer operands
  542:             return normalize(as_apply(ArithOp.DIV, self, other))
  543:         return NotImplemented
  544: 
  545:     def __rtruediv__(self, other):
  546:         other = as_expr(other)
  547:         if isinstance(other, Expr):
  548:             return other / self
  549:         return NotImplemented
  550: 
  551:     def __floordiv__(self, other):
  552:         other = as_expr(other)
  553:         if isinstance(other, Expr):
  554:             # Fortran // is different from Python //:
  555:             # - `//` is a concatenate operation for string operands
  556:             return normalize(Expr(Op.CONCAT, (self, other)))
  557:         return NotImplemented
  558: 
  559:     def __rfloordiv__(self, other):
  560:         other = as_expr(other)
  561:         if isinstance(other, Expr):
  562:             return other // self
  563:         return NotImplemented
  564: 
  565:     def __call__(self, *args, **kwargs):
  566:         # In Fortran, parenthesis () are use for both function call as
  567:         # well as indexing operations.
  568:         #
  569:         # TODO: implement a method for deciding when __call__ should
  570:         # return an INDEXING expression.
  571:         return as_apply(self, *map(as_expr, args),
  572:                         **{k: as_expr(v) for k, v in kwargs.items()})
  573: 
  574:     def __getitem__(self, index):
  575:         # Provided to support C indexing operations that .pyf files
  576:         # may contain.
  577:         index = as_expr(index)
  578:         if not isinstance(index, tuple):
  579:             index = index,
  580:         if len(index) > 1:
  581:             ewarn(f'C-index should be a single expression but got `{index}`')
  582:         return Expr(Op.INDEXING, (self,) + index)
  583: 
  584:     def substitute(self, symbols_map):
  585:         """Recursively substitute symbols with values in symbols map.
  586: 
  587:         Symbols map is a dictionary of symbol-expression pairs.
  588:         """
  589:         if self.op is Op.SYMBOL:
  590:             value = symbols_map.get(self)
  591:             if value is None:
  592:                 return self
  593:             m = re.match(r'\A(@__f2py_PARENTHESIS_(\w+)_\d+@)\Z', self.data)
  594:             if m:
  595:                 # complement to fromstring method
  596:                 items, paren = m.groups()
  597:                 if paren in ['ROUNDDIV', 'SQUARE']:
  598:                     return as_array(value)
  599:                 assert paren == 'ROUND', (paren, value)
  600:             return value
  601:         if self.op in (Op.INTEGER, Op.REAL, Op.STRING):
  602:             return self
  603:         if self.op in (Op.ARRAY, Op.COMPLEX):
  604:             return Expr(self.op, tuple(item.substitute(symbols_map)
  605:                                        for item in self.data))
  606:         if self.op is Op.CONCAT:
  607:             return normalize(Expr(self.op, tuple(item.substitute(symbols_map)
  608:                                                  for item in self.data)))
  609:         if self.op is Op.TERMS:
  610:             r = None
  611:             for term, coeff in self.data.items():
  612:                 if r is None:
  613:                     r = term.substitute(symbols_map) * coeff
  614:                 else:
  615:                     r += term.substitute(symbols_map) * coeff
  616:             if r is None:
  617:                 ewarn('substitute: empty TERMS expression interpreted as'
  618:                       ' int-literal 0')
  619:                 return as_number(0)
  620:             return r
  621:         if self.op is Op.FACTORS:
  622:             r = None
  623:             for base, exponent in self.data.items():
  624:                 if r is None:
  625:                     r = base.substitute(symbols_map) ** exponent
  626:                 else:
  627:                     r *= base.substitute(symbols_map) ** exponent
  628:             if r is None:
  629:                 ewarn('substitute: empty FACTORS expression interpreted'
  630:                       ' as int-literal 1')
  631:                 return as_number(1)
  632:             return r
  633:         if self.op is Op.APPLY:
  634:             target, args, kwargs = self.data
  635:             if isinstance(target, Expr):
  636:                 target = target.substitute(symbols_map)
  637:             args = tuple(a.substitute(symbols_map) for a in args)
  638:             kwargs = {k: v.substitute(symbols_map)
  639:                           for k, v in kwargs.items()}
  640:             return normalize(Expr(self.op, (target, args, kwargs)))
  641:         if self.op is Op.INDEXING:
  642:             func = self.data[0]
  643:             if isinstance(func, Expr):
  644:                 func = func.substitute(symbols_map)
  645:             args = tuple(a.substitute(symbols_map) for a in self.data[1:])
  646:             return normalize(Expr(self.op, (func,) + args))
  647:         if self.op is Op.TERNARY:
  648:             operands = tuple(a.substitute(symbols_map) for a in self.data)
  649:             return normalize(Expr(self.op, operands))
  650:         if self.op in (Op.REF, Op.DEREF):
  651:             return normalize(Expr(self.op, self.data.substitute(symbols_map)))
  652:         if self.op is Op.RELATIONAL:
  653:             rop, left, right = self.data
  654:             left = left.substitute(symbols_map)
  655:             right = right.substitute(symbols_map)
  656:             return normalize(Expr(self.op, (rop, left, right)))
  657:         raise NotImplementedError(f'substitute method for {self.op}: {self!r}')
  658: 
  659:     def traverse(self, visit, *args, **kwargs):
  660:         """Traverse expression tree with visit function.
  661: 
  662:         The visit function is applied to an expression with given args
  663:         and kwargs.
  664: 
  665:         Traverse call returns an expression returned by visit when not
  666:         None, otherwise return a new normalized expression with
  667:         traverse-visit sub-expressions.
  668:         """
  669:         result = visit(self, *args, **kwargs)
  670:         if result is not None:
  671:             return result
  672: 
  673:         if self.op in (Op.INTEGER, Op.REAL, Op.STRING, Op.SYMBOL):
  674:             return self
  675:         elif self.op in (Op.COMPLEX, Op.ARRAY, Op.CONCAT, Op.TERNARY):
  676:             return normalize(Expr(self.op, tuple(
  677:                 item.traverse(visit, *args, **kwargs)
  678:                 for item in self.data)))
  679:         elif self.op in (Op.TERMS, Op.FACTORS):
  680:             data = {}
  681:             for k, v in self.data.items():
  682:                 k = k.traverse(visit, *args, **kwargs)
  683:                 v = (v.traverse(visit, *args, **kwargs)
  684:                      if isinstance(v, Expr) else v)
  685:                 if k in data:
  686:                     v = data[k] + v
  687:                 data[k] = v
  688:             return normalize(Expr(self.op, data))
  689:         elif self.op is Op.APPLY:
  690:             obj = self.data[0]
  691:             func = (obj.traverse(visit, *args, **kwargs)
  692:                     if isinstance(obj, Expr) else obj)
  693:             operands = tuple(operand.traverse(visit, *args, **kwargs)
  694:                              for operand in self.data[1])
  695:             kwoperands = {k: v.traverse(visit, *args, **kwargs)
  696:                               for k, v in self.data[2].items()}
  697:             return normalize(Expr(self.op, (func, operands, kwoperands)))
  698:         elif self.op is Op.INDEXING:
  699:             obj = self.data[0]
  700:             obj = (obj.traverse(visit, *args, **kwargs)
  701:                    if isinstance(obj, Expr) else obj)
  702:             indices = tuple(index.traverse(visit, *args, **kwargs)
  703:                             for index in self.data[1:])
  704:             return normalize(Expr(self.op, (obj,) + indices))
  705:         elif self.op in (Op.REF, Op.DEREF):
  706:             return normalize(Expr(self.op,
  707:                                   self.data.traverse(visit, *args, **kwargs)))
  708:         elif self.op is Op.RELATIONAL:
  709:             rop, left, right = self.data
  710:             left = left.traverse(visit, *args, **kwargs)
  711:             right = right.traverse(visit, *args, **kwargs)
  712:             return normalize(Expr(self.op, (rop, left, right)))
  713:         raise NotImplementedError(f'traverse method for {self.op}')
  714: 
  715:     def contains(self, other):
  716:         """Check if self contains other.
  717:         """
  718:         found = []
  719: 
  720:         def visit(expr, found=found):
  721:             if found:
  722:                 return expr
  723:             elif expr == other:
  724:                 found.append(1)
  725:                 return expr
  726: 
  727:         self.traverse(visit)
  728: 
  729:         return len(found) != 0
  730: 
  731:     def symbols(self):
  732:         """Return a set of symbols contained in self.
  733:         """
  734:         found = set()
  735: 
  736:         def visit(expr, found=found):
  737:             if expr.op is Op.SYMBOL:
  738:                 found.add(expr)
  739: 
  740:         self.traverse(visit)
  741: 
  742:         return found
  743: 
  744:     def polynomial_atoms(self):
  745:         """Return a set of expressions used as atoms in polynomial self.
  746:         """
  747:         found = set()
  748: 
  749:         def visit(expr, found=found):
  750:             if expr.op is Op.FACTORS:
  751:                 for b in expr.data:
  752:                     b.traverse(visit)
  753:                 return expr
  754:             if expr.op in (Op.TERMS, Op.COMPLEX):
  755:                 return
  756:             if expr.op is Op.APPLY and isinstance(expr.data[0], ArithOp):
  757:                 if expr.data[0] is ArithOp.POW:
  758:                     expr.data[1][0].traverse(visit)
  759:                     return expr
  760:                 return
  761:             if expr.op in (Op.INTEGER, Op.REAL):
  762:                 return expr
  763: 
  764:             found.add(expr)
  765: 
  766:             if expr.op in (Op.INDEXING, Op.APPLY):
  767:                 return expr
  768: 
  769:         self.traverse(visit)
  770: 
  771:         return found
  772: 
  773:     def linear_solve(self, symbol):
  774:         """Return a, b such that a * symbol + b == self.
  775: 
  776:         If self is not linear with respect to symbol, raise RuntimeError.
  777:         """
  778:         b = self.substitute({symbol: as_number(0)})
  779:         ax = self - b
  780:         a = ax.substitute({symbol: as_number(1)})
  781: 
  782:         zero, _ = as_numer_denom(a * symbol - ax)
  783: 
  784:         if zero != as_number(0):
  785:             raise RuntimeError(f'not a {symbol}-linear equation:'
  786:                                f' {a} * {symbol} + {b} == {self}')
  787:         return a, b
  788: 
  789: 
  790: def normalize(obj):
  791:     """Normalize Expr and apply basic evaluation methods.
  792:     """
  793:     if not isinstance(obj, Expr):
  794:         return obj
  795: 
  796:     if obj.op is Op.TERMS:
  797:         d = {}
  798:         for t, c in obj.data.items():
  799:             if c == 0:
  800:                 continue
  801:             if t.op is Op.COMPLEX and c != 1:
  802:                 t = t * c
  803:                 c = 1
  804:             if t.op is Op.TERMS:
  805:                 for t1, c1 in t.data.items():
  806:                     _pairs_add(d, t1, c1 * c)
  807:             else:
  808:                 _pairs_add(d, t, c)
  809:         if len(d) == 0:
  810:             # TODO: determine correct kind
  811:             return as_number(0)
  812:         elif len(d) == 1:
  813:             (t, c), = d.items()
  814:             if c == 1:
  815:                 return t
  816:         return Expr(Op.TERMS, d)
  817: 
  818:     if obj.op is Op.FACTORS:
  819:         coeff = 1
  820:         d = {}
  821:         for b, e in obj.data.items():
  822:             if e == 0:
  823:                 continue
  824:             if b.op is Op.TERMS and isinstance(e, integer_types) and e > 1:
  825:                 # expand integer powers of sums
  826:                 b = b * (b ** (e - 1))
  827:                 e = 1
  828: 
  829:             if b.op in (Op.INTEGER, Op.REAL):
  830:                 if e == 1:
  831:                     coeff *= b.data[0]
  832:                 elif e > 0:
  833:                     coeff *= b.data[0] ** e
  834:                 else:
  835:                     _pairs_add(d, b, e)
  836:             elif b.op is Op.FACTORS:
  837:                 if e > 0 and isinstance(e, integer_types):
  838:                     for b1, e1 in b.data.items():
  839:                         _pairs_add(d, b1, e1 * e)
  840:                 else:
  841:                     _pairs_add(d, b, e)
  842:             else:
  843:                 _pairs_add(d, b, e)
  844:         if len(d) == 0 or coeff == 0:
  845:             # TODO: determine correct kind
  846:             assert isinstance(coeff, number_types)
  847:             return as_number(coeff)
  848:         elif len(d) == 1:
  849:             (b, e), = d.items()
  850:             if e == 1:
  851:                 t = b
  852:             else:
  853:                 t = Expr(Op.FACTORS, d)
  854:             if coeff == 1:
  855:                 return t
  856:             return Expr(Op.TERMS, {t: coeff})
  857:         elif coeff == 1:
  858:             return Expr(Op.FACTORS, d)
  859:         else:
  860:             return Expr(Op.TERMS, {Expr(Op.FACTORS, d): coeff})
  861: 
  862:     if obj.op is Op.APPLY and obj.data[0] is ArithOp.DIV:
  863:         dividend, divisor = obj.data[1]
  864:         t1, c1 = as_term_coeff(dividend)
  865:         t2, c2 = as_term_coeff(divisor)
  866:         if isinstance(c1, integer_types) and isinstance(c2, integer_types):
  867:             g = gcd(c1, c2)
  868:             c1, c2 = c1 // g, c2 // g
  869:         else:
  870:             c1, c2 = c1 / c2, 1
  871: 
  872:         if t1.op is Op.APPLY and t1.data[0] is ArithOp.DIV:
  873:             numer = t1.data[1][0] * c1
  874:             denom = t1.data[1][1] * t2 * c2
  875:             return as_apply(ArithOp.DIV, numer, denom)
  876: 
  877:         if t2.op is Op.APPLY and t2.data[0] is ArithOp.DIV:
  878:             numer = t2.data[1][1] * t1 * c1
  879:             denom = t2.data[1][0] * c2
  880:             return as_apply(ArithOp.DIV, numer, denom)
  881: 
  882:         d = dict(as_factors(t1).data)
  883:         for b, e in as_factors(t2).data.items():
  884:             _pairs_add(d, b, -e)
  885:         numer, denom = {}, {}
  886:         for b, e in d.items():
  887:             if e > 0:
  888:                 numer[b] = e
  889:             else:
  890:                 denom[b] = -e
  891:         numer = normalize(Expr(Op.FACTORS, numer)) * c1
  892:         denom = normalize(Expr(Op.FACTORS, denom)) * c2
  893: 
  894:         if denom.op in (Op.INTEGER, Op.REAL) and denom.data[0] == 1:
  895:             # TODO: denom kind not used
  896:             return numer
  897:         return as_apply(ArithOp.DIV, numer, denom)
  898: 
  899:     if obj.op is Op.CONCAT:
  900:         lst = [obj.data[0]]
  901:         for s in obj.data[1:]:
  902:             last = lst[-1]
  903:             if (
  904:                     last.op is Op.STRING
  905:                     and s.op is Op.STRING
  906:                     and last.data[0][0] in '"\''
  907:                     and s.data[0][0] == last.data[0][-1]
  908:             ):
  909:                 new_last = as_string(last.data[0][:-1] + s.data[0][1:],
  910:                                      max(last.data[1], s.data[1]))
  911:                 lst[-1] = new_last
  912:             else:
  913:                 lst.append(s)
  914:         if len(lst) == 1:
  915:             return lst[0]
  916:         return Expr(Op.CONCAT, tuple(lst))
  917: 
  918:     if obj.op is Op.TERNARY:
  919:         cond, expr1, expr2 = map(normalize, obj.data)
  920:         if cond.op is Op.INTEGER:
  921:             return expr1 if cond.data[0] else expr2
  922:         return Expr(Op.TERNARY, (cond, expr1, expr2))
  923: 
  924:     return obj
  925: 
  926: 
  927: def as_expr(obj):
  928:     """Convert non-Expr objects to Expr objects.
  929:     """
  930:     if isinstance(obj, complex):
  931:         return as_complex(obj.real, obj.imag)
  932:     if isinstance(obj, number_types):
  933:         return as_number(obj)
  934:     if isinstance(obj, str):
  935:         # STRING expression holds string with boundary quotes, hence
  936:         # applying repr:
  937:         return as_string(repr(obj))
  938:     if isinstance(obj, tuple):
  939:         return tuple(map(as_expr, obj))
  940:     return obj
  941: 
  942: 
  943: def as_symbol(obj):
  944:     """Return object as SYMBOL expression (variable or unparsed expression).
  945:     """
  946:     return Expr(Op.SYMBOL, obj)
  947: 
  948: 
  949: def as_number(obj, kind=4):
  950:     """Return object as INTEGER or REAL constant.
  951:     """
  952:     if isinstance(obj, int):
  953:         return Expr(Op.INTEGER, (obj, kind))
  954:     if isinstance(obj, float):
  955:         return Expr(Op.REAL, (obj, kind))
  956:     if isinstance(obj, Expr):
  957:         if obj.op in (Op.INTEGER, Op.REAL):
  958:             return obj
  959:     raise OpError(f'cannot convert {obj} to INTEGER or REAL constant')
  960: 
  961: 
  962: def as_integer(obj, kind=4):
  963:     """Return object as INTEGER constant.
  964:     """
  965:     if isinstance(obj, int):
  966:         return Expr(Op.INTEGER, (obj, kind))
  967:     if isinstance(obj, Expr):
  968:         if obj.op is Op.INTEGER:
  969:             return obj
  970:     raise OpError(f'cannot convert {obj} to INTEGER constant')
  971: 
  972: 
  973: def as_real(obj, kind=4):
  974:     """Return object as REAL constant.
  975:     """
  976:     if isinstance(obj, int):
  977:         return Expr(Op.REAL, (float(obj), kind))
  978:     if isinstance(obj, float):
  979:         return Expr(Op.REAL, (obj, kind))
  980:     if isinstance(obj, Expr):
  981:         if obj.op is Op.REAL:
  982:             return obj
  983:         elif obj.op is Op.INTEGER:
  984:             return Expr(Op.REAL, (float(obj.data[0]), kind))
  985:     raise OpError(f'cannot convert {obj} to REAL constant')
  986: 
  987: 
  988: def as_string(obj, kind=1):
  989:     """Return object as STRING expression (string literal constant).
  990:     """
  991:     return Expr(Op.STRING, (obj, kind))
  992: 
  993: 
  994: def as_array(obj):
  995:     """Return object as ARRAY expression (array constant).
  996:     """
  997:     if isinstance(obj, Expr):
  998:         obj = obj,
  999:     return Expr(Op.ARRAY, obj)
 1000: 
 1001: 
 1002: def as_complex(real, imag=0):
 1003:     """Return object as COMPLEX expression (complex literal constant).
 1004:     """
 1005:     return Expr(Op.COMPLEX, (as_expr(real), as_expr(imag)))
 1006: 
 1007: 
 1008: def as_apply(func, *args, **kwargs):
 1009:     """Return object as APPLY expression (function call, constructor, etc.)
 1010:     """
 1011:     return Expr(Op.APPLY,
 1012:                 (func, tuple(map(as_expr, args)),
 1013:                  {k: as_expr(v) for k, v in kwargs.items()}))
 1014: 
 1015: 
 1016: def as_ternary(cond, expr1, expr2):
 1017:     """Return object as TERNARY expression (cond?expr1:expr2).
 1018:     """
 1019:     return Expr(Op.TERNARY, (cond, expr1, expr2))
 1020: 
 1021: 
 1022: def as_ref(expr):
 1023:     """Return object as referencing expression.
 1024:     """
 1025:     return Expr(Op.REF, expr)
 1026: 
 1027: 
 1028: def as_deref(expr):
 1029:     """Return object as dereferencing expression.
 1030:     """
 1031:     return Expr(Op.DEREF, expr)
 1032: 
 1033: 
 1034: def as_eq(left, right):
 1035:     return Expr(Op.RELATIONAL, (RelOp.EQ, left, right))
 1036: 
 1037: 
 1038: def as_ne(left, right):
 1039:     return Expr(Op.RELATIONAL, (RelOp.NE, left, right))
 1040: 
 1041: 
 1042: def as_lt(left, right):
 1043:     return Expr(Op.RELATIONAL, (RelOp.LT, left, right))
 1044: 
 1045: 
 1046: def as_le(left, right):
 1047:     return Expr(Op.RELATIONAL, (RelOp.LE, left, right))
 1048: 
 1049: 
 1050: def as_gt(left, right):
 1051:     return Expr(Op.RELATIONAL, (RelOp.GT, left, right))
 1052: 
 1053: 
 1054: def as_ge(left, right):
 1055:     return Expr(Op.RELATIONAL, (RelOp.GE, left, right))
 1056: 
 1057: 
 1058: def as_terms(obj):
 1059:     """Return expression as TERMS expression.
 1060:     """
 1061:     if isinstance(obj, Expr):
 1062:         obj = normalize(obj)
 1063:         if obj.op is Op.TERMS:
 1064:             return obj
 1065:         if obj.op is Op.INTEGER:
 1066:             return Expr(Op.TERMS, {as_integer(1, obj.data[1]): obj.data[0]})
 1067:         if obj.op is Op.REAL:
 1068:             return Expr(Op.TERMS, {as_real(1, obj.data[1]): obj.data[0]})
 1069:         return Expr(Op.TERMS, {obj: 1})
 1070:     raise OpError(f'cannot convert {type(obj)} to terms Expr')
 1071: 
 1072: 
 1073: def as_factors(obj):
 1074:     """Return expression as FACTORS expression.
 1075:     """
 1076:     if isinstance(obj, Expr):
 1077:         obj = normalize(obj)
 1078:         if obj.op is Op.FACTORS:
 1079:             return obj
 1080:         if obj.op is Op.TERMS:
 1081:             if len(obj.data) == 1:
 1082:                 (term, coeff), = obj.data.items()
 1083:                 if coeff == 1:
 1084:                     return Expr(Op.FACTORS, {term: 1})
 1085:                 return Expr(Op.FACTORS, {term: 1, Expr.number(coeff): 1})
 1086:         if (obj.op is Op.APPLY
 1087:              and obj.data[0] is ArithOp.DIV
 1088:              and not obj.data[2]):
 1089:             return Expr(Op.FACTORS, {obj.data[1][0]: 1, obj.data[1][1]: -1})
 1090:         return Expr(Op.FACTORS, {obj: 1})
 1091:     raise OpError(f'cannot convert {type(obj)} to terms Expr')
 1092: 
 1093: 
 1094: def as_term_coeff(obj):
 1095:     """Return expression as term-coefficient pair.
 1096:     """
 1097:     if isinstance(obj, Expr):
 1098:         obj = normalize(obj)
 1099:         if obj.op is Op.INTEGER:
 1100:             return as_integer(1, obj.data[1]), obj.data[0]
 1101:         if obj.op is Op.REAL:
 1102:             return as_real(1, obj.data[1]), obj.data[0]
 1103:         if obj.op is Op.TERMS:
 1104:             if len(obj.data) == 1:
 1105:                 (term, coeff), = obj.data.items()
 1106:                 return term, coeff
 1107:             # TODO: find common divisor of coefficients
 1108:         if obj.op is Op.APPLY and obj.data[0] is ArithOp.DIV:
 1109:             t, c = as_term_coeff(obj.data[1][0])
 1110:             return as_apply(ArithOp.DIV, t, obj.data[1][1]), c
 1111:         return obj, 1
 1112:     raise OpError(f'cannot convert {type(obj)} to term and coeff')
 1113: 
 1114: 
 1115: def as_numer_denom(obj):
 1116:     """Return expression as numer-denom pair.
 1117:     """
 1118:     if isinstance(obj, Expr):
 1119:         obj = normalize(obj)
 1120:         if obj.op in (Op.INTEGER, Op.REAL, Op.COMPLEX, Op.SYMBOL,
 1121:                       Op.INDEXING, Op.TERNARY):
 1122:             return obj, as_number(1)
 1123:         elif obj.op is Op.APPLY:
 1124:             if obj.data[0] is ArithOp.DIV and not obj.data[2]:
 1125:                 numers, denoms = map(as_numer_denom, obj.data[1])
 1126:                 return numers[0] * denoms[1], numers[1] * denoms[0]
 1127:             return obj, as_number(1)
 1128:         elif obj.op is Op.TERMS:
 1129:             numers, denoms = [], []
 1130:             for term, coeff in obj.data.items():
 1131:                 n, d = as_numer_denom(term)
 1132:                 n = n * coeff
 1133:                 numers.append(n)
 1134:                 denoms.append(d)
 1135:             numer, denom = as_number(0), as_number(1)
 1136:             for i in range(len(numers)):
 1137:                 n = numers[i]
 1138:                 for j in range(len(numers)):
 1139:                     if i != j:
 1140:                         n *= denoms[j]
 1141:                 numer += n
 1142:                 denom *= denoms[i]
 1143:             if denom.op in (Op.INTEGER, Op.REAL) and denom.data[0] < 0:
 1144:                 numer, denom = -numer, -denom
 1145:             return numer, denom
 1146:         elif obj.op is Op.FACTORS:
 1147:             numer, denom = as_number(1), as_number(1)
 1148:             for b, e in obj.data.items():
 1149:                 bnumer, bdenom = as_numer_denom(b)
 1150:                 if e > 0:
 1151:                     numer *= bnumer ** e
 1152:                     denom *= bdenom ** e
 1153:                 elif e < 0:
 1154:                     numer *= bdenom ** (-e)
 1155:                     denom *= bnumer ** (-e)
 1156:             return numer, denom
 1157:     raise OpError(f'cannot convert {type(obj)} to numer and denom')
 1158: 
 1159: 
 1160: def _counter():
 1161:     # Used internally to generate unique dummy symbols
 1162:     counter = 0
 1163:     while True:
 1164:         counter += 1
 1165:         yield counter
 1166: 
 1167: 
 1168: COUNTER = _counter()
 1169: 
 1170: 
 1171: def eliminate_quotes(s):
 1172:     """Replace quoted substrings of input string.
 1173: 
 1174:     Return a new string and a mapping of replacements.
 1175:     """
 1176:     d = {}
 1177: 
 1178:     def repl(m):
 1179:         kind, value = m.groups()[:2]
 1180:         if kind:
 1181:             # remove trailing underscore
 1182:             kind = kind[:-1]
 1183:         p = {"'": "SINGLE", '"': "DOUBLE"}[value[0]]
 1184:         k = f'{kind}@__f2py_QUOTES_{p}_{COUNTER.__next__()}@'
 1185:         d[k] = value
 1186:         return k
 1187: 
 1188:     new_s = re.sub(r'({kind}_|)({single_quoted}|{double_quoted})'.format(
 1189:         kind=r'\w[\w\d_]*',
 1190:         single_quoted=r"('([^'\\]|(\\.))*')",
 1191:         double_quoted=r'("([^"\\]|(\\.))*")'),
 1192:         repl, s)
 1193: 
 1194:     assert '"' not in new_s
 1195:     assert "'" not in new_s
 1196: 
 1197:     return new_s, d
 1198: 
 1199: 
 1200: def insert_quotes(s, d):
 1201:     """Inverse of eliminate_quotes.
 1202:     """
 1203:     for k, v in d.items():
 1204:         kind = k[:k.find('@')]
 1205:         if kind:
 1206:             kind += '_'
 1207:         s = s.replace(k, kind + v)
 1208:     return s
 1209: 
 1210: 
 1211: def replace_parenthesis(s):
 1212:     """Replace substrings of input that are enclosed in parenthesis.
 1213: 
 1214:     Return a new string and a mapping of replacements.
 1215:     """
 1216:     # Find a parenthesis pair that appears first.
 1217: 
 1218:     # Fortran deliminator are `(`, `)`, `[`, `]`, `(/', '/)`, `/`.
 1219:     # We don't handle `/` deliminator because it is not a part of an
 1220:     # expression.
 1221:     left, right = None, None
 1222:     mn_i = len(s)
 1223:     for left_, right_ in (('(/', '/)'),
 1224:                           '()',
 1225:                           '{}',  # to support C literal structs
 1226:                           '[]'):
 1227:         i = s.find(left_)
 1228:         if i == -1:
 1229:             continue
 1230:         if i < mn_i:
 1231:             mn_i = i
 1232:             left, right = left_, right_
 1233: 
 1234:     if left is None:
 1235:         return s, {}
 1236: 
 1237:     i = mn_i
 1238:     j = s.find(right, i)
 1239: 
 1240:     while s.count(left, i + 1, j) != s.count(right, i + 1, j):
 1241:         j = s.find(right, j + 1)
 1242:         if j == -1:
 1243:             raise ValueError(f'Mismatch of {left + right} parenthesis in {s!r}')
 1244: 
 1245:     p = {'(': 'ROUND', '[': 'SQUARE', '{': 'CURLY', '(/': 'ROUNDDIV'}[left]
 1246: 
 1247:     k = f'@__f2py_PARENTHESIS_{p}_{COUNTER.__next__()}@'
 1248:     v = s[i + len(left):j]
 1249:     r, d = replace_parenthesis(s[j + len(right):])
 1250:     d[k] = v
 1251:     return s[:i] + k + r, d
 1252: 
 1253: 
 1254: def _get_parenthesis_kind(s):
 1255:     assert s.startswith('@__f2py_PARENTHESIS_'), s
 1256:     return s.split('_')[4]
 1257: 
 1258: 
 1259: def unreplace_parenthesis(s, d):
 1260:     """Inverse of replace_parenthesis.
 1261:     """
 1262:     for k, v in d.items():
 1263:         p = _get_parenthesis_kind(k)
 1264:         left = {'ROUND': '(', 'SQUARE': '[', 'CURLY': '{', 'ROUNDDIV': '(/'}[p]
 1265:         right = {'ROUND': ')', 'SQUARE': ']', 'CURLY': '}', 'ROUNDDIV': '/)'}[p]
 1266:         s = s.replace(k, left + v + right)
 1267:     return s
 1268: 
 1269: 
 1270: def fromstring(s, language=Language.C):
 1271:     """Create an expression from a string.
 1272: 
 1273:     This is a "lazy" parser, that is, only arithmetic operations are
 1274:     resolved, non-arithmetic operations are treated as symbols.
 1275:     """
 1276:     r = _FromStringWorker(language=language).parse(s)
 1277:     if isinstance(r, Expr):
 1278:         return r
 1279:     raise ValueError(f'failed to parse `{s}` to Expr instance: got `{r}`')
 1280: 
 1281: 
 1282: class _Pair:
 1283:     # Internal class to represent a pair of expressions
 1284: 
 1285:     def __init__(self, left, right):
 1286:         self.left = left
 1287:         self.right = right
 1288: 
 1289:     def substitute(self, symbols_map):
 1290:         left, right = self.left, self.right
 1291:         if isinstance(left, Expr):
 1292:             left = left.substitute(symbols_map)
 1293:         if isinstance(right, Expr):
 1294:             right = right.substitute(symbols_map)
 1295:         return _Pair(left, right)
 1296: 
 1297:     def __repr__(self):
 1298:         return f'{type(self).__name__}({self.left}, {self.right})'
 1299: 
 1300: 
 1301: class _FromStringWorker:
 1302: 
 1303:     def __init__(self, language=Language.C):
 1304:         self.original = None
 1305:         self.quotes_map = None
 1306:         self.language = language
 1307: 
 1308:     def finalize_string(self, s):
 1309:         return insert_quotes(s, self.quotes_map)
 1310: 
 1311:     def parse(self, inp):
 1312:         self.original = inp
 1313:         unquoted, self.quotes_map = eliminate_quotes(inp)
 1314:         return self.process(unquoted)
 1315: 
 1316:     def process(self, s, context='expr'):
 1317:         """Parse string within the given context.
 1318: 
 1319:         The context may define the result in case of ambiguous
 1320:         expressions. For instance, consider expressions `f(x, y)` and
 1321:         `(x, y) + (a, b)` where `f` is a function and pair `(x, y)`
 1322:         denotes complex number. Specifying context as "args" or
 1323:         "expr", the subexpression `(x, y)` will be parse to an
 1324:         argument list or to a complex number, respectively.
 1325:         """
 1326:         if isinstance(s, (list, tuple)):
 1327:             return type(s)(self.process(s_, context) for s_ in s)
 1328: 
 1329:         assert isinstance(s, str), (type(s), s)
 1330: 
 1331:         # replace subexpressions in parenthesis with f2py @-names
 1332:         r, raw_symbols_map = replace_parenthesis(s)
 1333:         r = r.strip()
 1334: 
 1335:         def restore(r):
 1336:             # restores subexpressions marked with f2py @-names
 1337:             if isinstance(r, (list, tuple)):
 1338:                 return type(r)(map(restore, r))
 1339:             return unreplace_parenthesis(r, raw_symbols_map)
 1340: 
 1341:         # comma-separated tuple
 1342:         if ',' in r:
 1343:             operands = restore(r.split(','))
 1344:             if context == 'args':
 1345:                 return tuple(self.process(operands))
 1346:             if context == 'expr':
 1347:                 if len(operands) == 2:
 1348:                     # complex number literal
 1349:                     return as_complex(*self.process(operands))
 1350:             raise NotImplementedError(
 1351:                 f'parsing comma-separated list (context={context}): {r}')
 1352: 
 1353:         # ternary operation
 1354:         m = re.match(r'\A([^?]+)[?]([^:]+)[:](.+)\Z', r)
 1355:         if m:
 1356:             assert context == 'expr', context
 1357:             oper, expr1, expr2 = restore(m.groups())
 1358:             oper = self.process(oper)
 1359:             expr1 = self.process(expr1)
 1360:             expr2 = self.process(expr2)
 1361:             return as_ternary(oper, expr1, expr2)
 1362: 
 1363:         # relational expression
 1364:         if self.language is Language.Fortran:
 1365:             m = re.match(
 1366:                 r'\A(.+)\s*[.](eq|ne|lt|le|gt|ge)[.]\s*(.+)\Z', r, re.I)
 1367:         else:
 1368:             m = re.match(
 1369:                 r'\A(.+)\s*([=][=]|[!][=]|[<][=]|[<]|[>][=]|[>])\s*(.+)\Z', r)
 1370:         if m:
 1371:             left, rop, right = m.groups()
 1372:             if self.language is Language.Fortran:
 1373:                 rop = '.' + rop + '.'
 1374:             left, right = self.process(restore((left, right)))
 1375:             rop = RelOp.fromstring(rop, language=self.language)
 1376:             return Expr(Op.RELATIONAL, (rop, left, right))
 1377: 
 1378:         # keyword argument
 1379:         m = re.match(r'\A(\w[\w\d_]*)\s*[=](.*)\Z', r)
 1380:         if m:
 1381:             keyname, value = m.groups()
 1382:             value = restore(value)
 1383:             return _Pair(keyname, self.process(value))
 1384: 
 1385:         # addition/subtraction operations
 1386:         operands = re.split(r'((?<!\d[edED])[+-])', r)
 1387:         if len(operands) > 1:
 1388:             result = self.process(restore(operands[0] or '0'))
 1389:             for op, operand in zip(operands[1::2], operands[2::2]):
 1390:                 operand = self.process(restore(operand))
 1391:                 op = op.strip()
 1392:                 if op == '+':
 1393:                     result += operand
 1394:                 else:
 1395:                     assert op == '-'
 1396:                     result -= operand
 1397:             return result
 1398: 
 1399:         # string concatenate operation
 1400:         if self.language is Language.Fortran and '//' in r:
 1401:             operands = restore(r.split('//'))
 1402:             return Expr(Op.CONCAT,
 1403:                         tuple(self.process(operands)))
 1404: 
 1405:         # multiplication/division operations
 1406:         operands = re.split(r'(?<=[@\w\d_])\s*([*]|/)',
 1407:                             (r if self.language is Language.C
 1408:                              else r.replace('**', '@__f2py_DOUBLE_STAR@')))
 1409:         if len(operands) > 1:
 1410:             operands = restore(operands)
 1411:             if self.language is not Language.C:
 1412:                 operands = [operand.replace('@__f2py_DOUBLE_STAR@', '**')
 1413:                             for operand in operands]
 1414:             # Expression is an arithmetic product
 1415:             result = self.process(operands[0])
 1416:             for op, operand in zip(operands[1::2], operands[2::2]):
 1417:                 operand = self.process(operand)
 1418:                 op = op.strip()
 1419:                 if op == '*':
 1420:                     result *= operand
 1421:                 else:
 1422:                     assert op == '/'
 1423:                     result /= operand
 1424:             return result
 1425: 
 1426:         # referencing/dereferencing
 1427:         if r.startswith(('*', '&')):
 1428:             op = {'*': Op.DEREF, '&': Op.REF}[r[0]]
 1429:             operand = self.process(restore(r[1:]))
 1430:             return Expr(op, operand)
 1431: 
 1432:         # exponentiation operations
 1433:         if self.language is not Language.C and '**' in r:
 1434:             operands = list(reversed(restore(r.split('**'))))
 1435:             result = self.process(operands[0])
 1436:             for operand in operands[1:]:
 1437:                 operand = self.process(operand)
 1438:                 result = operand ** result
 1439:             return result
 1440: 
 1441:         # int-literal-constant
 1442:         m = re.match(r'\A({digit_string})({kind}|)\Z'.format(
 1443:             digit_string=r'\d+',
 1444:             kind=r'_(\d+|\w[\w\d_]*)'), r)
 1445:         if m:
 1446:             value, _, kind = m.groups()
 1447:             if kind and kind.isdigit():
 1448:                 kind = int(kind)
 1449:             return as_integer(int(value), kind or 4)
 1450: 
 1451:         # real-literal-constant
 1452:         m = re.match(r'\A({significant}({exponent}|)|\d+{exponent})({kind}|)\Z'
 1453:                      .format(
 1454:                          significant=r'[.]\d+|\d+[.]\d*',
 1455:                          exponent=r'[edED][+-]?\d+',
 1456:                          kind=r'_(\d+|\w[\w\d_]*)'), r)
 1457:         if m:
 1458:             value, _, _, kind = m.groups()
 1459:             if kind and kind.isdigit():
 1460:                 kind = int(kind)
 1461:             value = value.lower()
 1462:             if 'd' in value:
 1463:                 return as_real(float(value.replace('d', 'e')), kind or 8)
 1464:             return as_real(float(value), kind or 4)
 1465: 
 1466:         # string-literal-constant with kind parameter specification
 1467:         if r in self.quotes_map:
 1468:             kind = r[:r.find('@')]
 1469:             return as_string(self.quotes_map[r], kind or 1)
 1470: 
 1471:         # array constructor or literal complex constant or
 1472:         # parenthesized expression
 1473:         if r in raw_symbols_map:
 1474:             paren = _get_parenthesis_kind(r)
 1475:             items = self.process(restore(raw_symbols_map[r]),
 1476:                                  'expr' if paren == 'ROUND' else 'args')
 1477:             if paren == 'ROUND':
 1478:                 if isinstance(items, Expr):
 1479:                     return items
 1480:             if paren in ['ROUNDDIV', 'SQUARE']:
 1481:                 # Expression is a array constructor
 1482:                 if isinstance(items, Expr):
 1483:                     items = (items,)
 1484:                 return as_array(items)
 1485: 
 1486:         # function call/indexing
 1487:         m = re.match(r'\A(.+)\s*(@__f2py_PARENTHESIS_(ROUND|SQUARE)_\d+@)\Z',
 1488:                      r)
 1489:         if m:
 1490:             target, args, paren = m.groups()
 1491:             target = self.process(restore(target))
 1492:             args = self.process(restore(args)[1:-1], 'args')
 1493:             if not isinstance(args, tuple):
 1494:                 args = args,
 1495:             if paren == 'ROUND':
 1496:                 kwargs = {a.left: a.right for a in args
 1497:                               if isinstance(a, _Pair)}
 1498:                 args = tuple(a for a in args if not isinstance(a, _Pair))
 1499:                 # Warning: this could also be Fortran indexing operation..
 1500:                 return as_apply(target, *args, **kwargs)
 1501:             else:
 1502:                 # Expression is a C/Python indexing operation
 1503:                 # (e.g. used in .pyf files)
 1504:                 assert paren == 'SQUARE'
 1505:                 return target[args]
 1506: 
 1507:         # Fortran standard conforming identifier
 1508:         m = re.match(r'\A\w[\w\d_]*\Z', r)
 1509:         if m:
 1510:             return as_symbol(r)
 1511: 
 1512:         # fall-back to symbol
 1513:         r = self.finalize_string(restore(r))
 1514:         ewarn(
 1515:             f'fromstring: treating {r!r} as symbol (original={self.original})')
 1516:         return as_symbol(r)
