    1: import sys
    2: import sysconfig
    3: import weakref
    4: from pathlib import Path
    5: 
    6: import pytest
    7: 
    8: import numpy as np
    9: from numpy.ctypeslib import as_array, load_library, ndpointer
   10: from numpy.testing import assert_, assert_array_equal, assert_equal, assert_raises
   11: 
   12: try:
   13:     import ctypes
   14: except ImportError:
   15:     ctypes = None
   16: else:
   17:     cdll = None
   18:     test_cdll = None
   19:     if hasattr(sys, 'gettotalrefcount'):
   20:         try:
   21:             cdll = load_library(
   22:                 '_multiarray_umath_d', np._core._multiarray_umath.__file__
   23:             )
   24:         except OSError:
   25:             pass
   26:         try:
   27:             test_cdll = load_library(
   28:                 '_multiarray_tests', np._core._multiarray_tests.__file__
   29:             )
   30:         except OSError:
   31:             pass
   32:     if cdll is None:
   33:         cdll = load_library(
   34:             '_multiarray_umath', np._core._multiarray_umath.__file__)
   35:     if test_cdll is None:
   36:         test_cdll = load_library(
   37:             '_multiarray_tests', np._core._multiarray_tests.__file__
   38:         )
   39: 
   40:     c_forward_pointer = test_cdll.forward_pointer
   41: 
   42: 
   43: @pytest.mark.skipif(ctypes is None,
   44:                     reason="ctypes not available in this python")
   45: @pytest.mark.skipif(sys.platform == 'cygwin',
   46:                     reason="Known to fail on cygwin")
   47: class TestLoadLibrary:
   48:     def test_basic(self):
   49:         loader_path = np._core._multiarray_umath.__file__
   50: 
   51:         out1 = load_library('_multiarray_umath', loader_path)
   52:         out2 = load_library(Path('_multiarray_umath'), loader_path)
   53:         out3 = load_library('_multiarray_umath', Path(loader_path))
   54:         out4 = load_library(b'_multiarray_umath', loader_path)
   55: 
   56:         assert isinstance(out1, ctypes.CDLL)
   57:         assert out1 is out2 is out3 is out4
   58: 
   59:     def test_basic2(self):
   60:         # Regression for #801: load_library with a full library name
   61:         # (including extension) does not work.
   62:         try:
   63:             so_ext = sysconfig.get_config_var('EXT_SUFFIX')
   64:             load_library(f'_multiarray_umath{so_ext}',
   65:                          np._core._multiarray_umath.__file__)
   66:         except ImportError as e:
   67:             msg = ("ctypes is not available on this python: skipping the test"
   68:                    " (import error was: %s)" % str(e))
   69:             print(msg)
   70: 
   71: 
   72: class TestNdpointer:
   73:     def test_dtype(self):
   74:         dt = np.intc
   75:         p = ndpointer(dtype=dt)
   76:         assert_(p.from_param(np.array([1], dt)))
   77:         dt = '<i4'
   78:         p = ndpointer(dtype=dt)
   79:         assert_(p.from_param(np.array([1], dt)))
   80:         dt = np.dtype('>i4')
   81:         p = ndpointer(dtype=dt)
   82:         p.from_param(np.array([1], dt))
   83:         assert_raises(TypeError, p.from_param,
   84:                           np.array([1], dt.newbyteorder('swap')))
   85:         dtnames = ['x', 'y']
   86:         dtformats = [np.intc, np.float64]
   87:         dtdescr = {'names': dtnames, 'formats': dtformats}
   88:         dt = np.dtype(dtdescr)
   89:         p = ndpointer(dtype=dt)
   90:         assert_(p.from_param(np.zeros((10,), dt)))
   91:         samedt = np.dtype(dtdescr)
   92:         p = ndpointer(dtype=samedt)
   93:         assert_(p.from_param(np.zeros((10,), dt)))
   94:         dt2 = np.dtype(dtdescr, align=True)
   95:         if dt.itemsize != dt2.itemsize:
   96:             assert_raises(TypeError, p.from_param, np.zeros((10,), dt2))
   97:         else:
   98:             assert_(p.from_param(np.zeros((10,), dt2)))
   99: 
  100:     def test_ndim(self):
  101:         p = ndpointer(ndim=0)
  102:         assert_(p.from_param(np.array(1)))
  103:         assert_raises(TypeError, p.from_param, np.array([1]))
  104:         p = ndpointer(ndim=1)
  105:         assert_raises(TypeError, p.from_param, np.array(1))
  106:         assert_(p.from_param(np.array([1])))
  107:         p = ndpointer(ndim=2)
  108:         assert_(p.from_param(np.array([[1]])))
  109: 
  110:     def test_shape(self):
  111:         p = ndpointer(shape=(1, 2))
  112:         assert_(p.from_param(np.array([[1, 2]])))
  113:         assert_raises(TypeError, p.from_param, np.array([[1], [2]]))
  114:         p = ndpointer(shape=())
  115:         assert_(p.from_param(np.array(1)))
  116: 
  117:     def test_flags(self):
  118:         x = np.array([[1, 2], [3, 4]], order='F')
  119:         p = ndpointer(flags='FORTRAN')
  120:         assert_(p.from_param(x))
  121:         p = ndpointer(flags='CONTIGUOUS')
  122:         assert_raises(TypeError, p.from_param, x)
  123:         p = ndpointer(flags=x.flags.num)
  124:         assert_(p.from_param(x))
  125:         assert_raises(TypeError, p.from_param, np.array([[1, 2], [3, 4]]))
  126: 
  127:     def test_cache(self):
  128:         assert_(ndpointer(dtype=np.float64) is ndpointer(dtype=np.float64))
  129: 
  130:         # shapes are normalized
  131:         assert_(ndpointer(shape=2) is ndpointer(shape=(2,)))
  132: 
  133:         # 1.12 <= v < 1.16 had a bug that made these fail
  134:         assert_(ndpointer(shape=2) is not ndpointer(ndim=2))
  135:         assert_(ndpointer(ndim=2) is not ndpointer(shape=2))
  136: 
  137: @pytest.mark.skipif(ctypes is None,
  138:                     reason="ctypes not available on this python installation")
  139: class TestNdpointerCFunc:
  140:     def test_arguments(self):
  141:         """ Test that arguments are coerced from arrays """
  142:         c_forward_pointer.restype = ctypes.c_void_p
  143:         c_forward_pointer.argtypes = (ndpointer(ndim=2),)
  144: 
  145:         c_forward_pointer(np.zeros((2, 3)))
  146:         # too many dimensions
  147:         assert_raises(
  148:             ctypes.ArgumentError, c_forward_pointer, np.zeros((2, 3, 4)))
  149: 
  150:     @pytest.mark.parametrize(
  151:         'dt', [
  152:             float,
  153:             np.dtype({
  154:                 'formats': ['<i4', '<i4'],
  155:                 'names': ['a', 'b'],
  156:                 'offsets': [0, 2],
  157:                 'itemsize': 6
  158:             })
  159:         ], ids=[
  160:             'float',
  161:             'overlapping-fields'
  162:         ]
  163:     )
  164:     def test_return(self, dt):
  165:         """ Test that return values are coerced to arrays """
  166:         arr = np.zeros((2, 3), dt)
  167:         ptr_type = ndpointer(shape=arr.shape, dtype=arr.dtype)
  168: 
  169:         c_forward_pointer.restype = ptr_type
  170:         c_forward_pointer.argtypes = (ptr_type,)
  171: 
  172:         # check that the arrays are equivalent views on the same data
  173:         arr2 = c_forward_pointer(arr)
  174:         assert_equal(arr2.dtype, arr.dtype)
  175:         assert_equal(arr2.shape, arr.shape)
  176:         assert_equal(
  177:             arr2.__array_interface__['data'],
  178:             arr.__array_interface__['data']
  179:         )
  180: 
  181:     def test_vague_return_value(self):
  182:         """ Test that vague ndpointer return values do not promote to arrays """
  183:         arr = np.zeros((2, 3))
  184:         ptr_type = ndpointer(dtype=arr.dtype)
  185: 
  186:         c_forward_pointer.restype = ptr_type
  187:         c_forward_pointer.argtypes = (ptr_type,)
  188: 
  189:         ret = c_forward_pointer(arr)
  190:         assert_(isinstance(ret, ptr_type))
  191: 
  192: 
  193: @pytest.mark.skipif(ctypes is None,
  194:                     reason="ctypes not available on this python installation")
  195: class TestAsArray:
  196:     def test_array(self):
  197:         from ctypes import c_int
  198: 
  199:         pair_t = c_int * 2
  200:         a = as_array(pair_t(1, 2))
  201:         assert_equal(a.shape, (2,))
  202:         assert_array_equal(a, np.array([1, 2]))
  203:         a = as_array((pair_t * 3)(pair_t(1, 2), pair_t(3, 4), pair_t(5, 6)))
  204:         assert_equal(a.shape, (3, 2))
  205:         assert_array_equal(a, np.array([[1, 2], [3, 4], [5, 6]]))
  206: 
  207:     def test_pointer(self):
  208:         from ctypes import POINTER, c_int, cast
  209: 
  210:         p = cast((c_int * 10)(*range(10)), POINTER(c_int))
  211: 
  212:         a = as_array(p, shape=(10,))
  213:         assert_equal(a.shape, (10,))
  214:         assert_array_equal(a, np.arange(10))
  215: 
  216:         a = as_array(p, shape=(2, 5))
  217:         assert_equal(a.shape, (2, 5))
  218:         assert_array_equal(a, np.arange(10).reshape((2, 5)))
  219: 
  220:         # shape argument is required
  221:         assert_raises(TypeError, as_array, p)
  222: 
  223:     @pytest.mark.skipif(
  224:             sys.version_info[:2] == (3, 12),
  225:             reason="Broken in 3.12.0rc1, see gh-24399",
  226:     )
  227:     def test_struct_array_pointer(self):
  228:         from ctypes import Structure, c_int16, pointer
  229: 
  230:         class Struct(Structure):
  231:             _fields_ = [('a', c_int16)]
  232: 
  233:         Struct3 = 3 * Struct
  234: 
  235:         c_array = (2 * Struct3)(
  236:             Struct3(Struct(a=1), Struct(a=2), Struct(a=3)),
  237:             Struct3(Struct(a=4), Struct(a=5), Struct(a=6))
  238:         )
  239: 
  240:         expected = np.array([
  241:             [(1,), (2,), (3,)],
  242:             [(4,), (5,), (6,)],
  243:         ], dtype=[('a', np.int16)])
  244: 
  245:         def check(x):
  246:             assert_equal(x.dtype, expected.dtype)
  247:             assert_equal(x, expected)
  248: 
  249:         # all of these should be equivalent
  250:         check(as_array(c_array))
  251:         check(as_array(pointer(c_array), shape=()))
  252:         check(as_array(pointer(c_array[0]), shape=(2,)))
  253:         check(as_array(pointer(c_array[0][0]), shape=(2, 3)))
  254: 
  255:     def test_reference_cycles(self):
  256:         # related to gh-6511
  257:         import ctypes
  258: 
  259:         # create array to work with
  260:         # don't use int/long to avoid running into bpo-10746
  261:         N = 100
  262:         a = np.arange(N, dtype=np.short)
  263: 
  264:         # get pointer to array
  265:         pnt = np.ctypeslib.as_ctypes(a)
  266: 
  267:         with np.testing.assert_no_gc_cycles():
  268:             # decay the array above to a pointer to its first element
  269:             newpnt = ctypes.cast(pnt, ctypes.POINTER(ctypes.c_short))
  270:             # and construct an array using this data
  271:             b = np.ctypeslib.as_array(newpnt, (N,))
  272:             # now delete both, which should cleanup both objects
  273:             del newpnt, b
  274: 
  275:     def test_segmentation_fault(self):
  276:         arr = np.zeros((224, 224, 3))
  277:         c_arr = np.ctypeslib.as_ctypes(arr)
  278:         arr_ref = weakref.ref(arr)
  279:         del arr
  280: 
  281:         # check the reference wasn't cleaned up
  282:         assert_(arr_ref() is not None)
  283: 
  284:         # check we avoid the segfault
  285:         c_arr[0][0][0]
  286: 
  287: 
  288: @pytest.mark.skipif(ctypes is None,
  289:                     reason="ctypes not available on this python installation")
  290: class TestAsCtypesType:
  291:     """ Test conversion from dtypes to ctypes types """
  292:     def test_scalar(self):
  293:         dt = np.dtype('<u2')
  294:         ct = np.ctypeslib.as_ctypes_type(dt)
  295:         assert_equal(ct, ctypes.c_uint16.__ctype_le__)
  296: 
  297:         dt = np.dtype('>u2')
  298:         ct = np.ctypeslib.as_ctypes_type(dt)
  299:         assert_equal(ct, ctypes.c_uint16.__ctype_be__)
  300: 
  301:         dt = np.dtype('u2')
  302:         ct = np.ctypeslib.as_ctypes_type(dt)
  303:         assert_equal(ct, ctypes.c_uint16)
  304: 
  305:     def test_subarray(self):
  306:         dt = np.dtype((np.int32, (2, 3)))
  307:         ct = np.ctypeslib.as_ctypes_type(dt)
  308:         assert_equal(ct, 2 * (3 * ctypes.c_int32))
  309: 
  310:     def test_structure(self):
  311:         dt = np.dtype([
  312:             ('a', np.uint16),
  313:             ('b', np.uint32),
  314:         ])
  315: 
  316:         ct = np.ctypeslib.as_ctypes_type(dt)
  317:         assert_(issubclass(ct, ctypes.Structure))
  318:         assert_equal(ctypes.sizeof(ct), dt.itemsize)
  319:         assert_equal(ct._fields_, [
  320:             ('a', ctypes.c_uint16),
  321:             ('b', ctypes.c_uint32),
  322:         ])
  323: 
  324:     def test_structure_aligned(self):
  325:         dt = np.dtype([
  326:             ('a', np.uint16),
  327:             ('b', np.uint32),
  328:         ], align=True)
  329: 
  330:         ct = np.ctypeslib.as_ctypes_type(dt)
  331:         assert_(issubclass(ct, ctypes.Structure))
  332:         assert_equal(ctypes.sizeof(ct), dt.itemsize)
  333:         assert_equal(ct._fields_, [
  334:             ('a', ctypes.c_uint16),
  335:             ('', ctypes.c_char * 2),  # padding
  336:             ('b', ctypes.c_uint32),
  337:         ])
  338: 
  339:     def test_union(self):
  340:         dt = np.dtype({
  341:             'names': ['a', 'b'],
  342:             'offsets': [0, 0],
  343:             'formats': [np.uint16, np.uint32]
  344:         })
  345: 
  346:         ct = np.ctypeslib.as_ctypes_type(dt)
  347:         assert_(issubclass(ct, ctypes.Union))
  348:         assert_equal(ctypes.sizeof(ct), dt.itemsize)
  349:         assert_equal(ct._fields_, [
  350:             ('a', ctypes.c_uint16),
  351:             ('b', ctypes.c_uint32),
  352:         ])
  353: 
  354:     def test_padded_union(self):
  355:         dt = np.dtype({
  356:             'names': ['a', 'b'],
  357:             'offsets': [0, 0],
  358:             'formats': [np.uint16, np.uint32],
  359:             'itemsize': 5,
  360:         })
  361: 
  362:         ct = np.ctypeslib.as_ctypes_type(dt)
  363:         assert_(issubclass(ct, ctypes.Union))
  364:         assert_equal(ctypes.sizeof(ct), dt.itemsize)
  365:         assert_equal(ct._fields_, [
  366:             ('a', ctypes.c_uint16),
  367:             ('b', ctypes.c_uint32),
  368:             ('', ctypes.c_char * 5),  # padding
  369:         ])
  370: 
  371:     def test_overlapping(self):
  372:         dt = np.dtype({
  373:             'names': ['a', 'b'],
  374:             'offsets': [0, 2],
  375:             'formats': [np.uint32, np.uint32]
  376:         })
  377:         assert_raises(NotImplementedError, np.ctypeslib.as_ctypes_type, dt)
