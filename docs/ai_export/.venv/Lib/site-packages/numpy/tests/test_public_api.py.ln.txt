    1: import functools
    2: import importlib
    3: import inspect
    4: import pkgutil
    5: import subprocess
    6: import sys
    7: import sysconfig
    8: import types
    9: import warnings
   10: 
   11: import pytest
   12: 
   13: import numpy
   14: import numpy as np
   15: from numpy.testing import IS_WASM
   16: 
   17: try:
   18:     import ctypes
   19: except ImportError:
   20:     ctypes = None
   21: 
   22: 
   23: def check_dir(module, module_name=None):
   24:     """Returns a mapping of all objects with the wrong __module__ attribute."""
   25:     if module_name is None:
   26:         module_name = module.__name__
   27:     results = {}
   28:     for name in dir(module):
   29:         if name == "core":
   30:             continue
   31:         item = getattr(module, name)
   32:         if (hasattr(item, '__module__') and hasattr(item, '__name__')
   33:                 and item.__module__ != module_name):
   34:             results[name] = item.__module__ + '.' + item.__name__
   35:     return results
   36: 
   37: 
   38: def test_numpy_namespace():
   39:     # We override dir to not show these members
   40:     allowlist = {
   41:         'recarray': 'numpy.rec.recarray',
   42:     }
   43:     bad_results = check_dir(np)
   44:     # pytest gives better error messages with the builtin assert than with
   45:     # assert_equal
   46:     assert bad_results == allowlist
   47: 
   48: 
   49: @pytest.mark.skipif(IS_WASM, reason="can't start subprocess")
   50: @pytest.mark.parametrize('name', ['testing'])
   51: def test_import_lazy_import(name):
   52:     """Make sure we can actually use the modules we lazy load.
   53: 
   54:     While not exported as part of the public API, it was accessible.  With the
   55:     use of __getattr__ and __dir__, this isn't always true It can happen that
   56:     an infinite recursion may happen.
   57: 
   58:     This is the only way I found that would force the failure to appear on the
   59:     badly implemented code.
   60: 
   61:     We also test for the presence of the lazily imported modules in dir
   62: 
   63:     """
   64:     exe = (sys.executable, '-c', "import numpy; numpy." + name)
   65:     result = subprocess.check_output(exe)
   66:     assert not result
   67: 
   68:     # Make sure they are still in the __dir__
   69:     assert name in dir(np)
   70: 
   71: 
   72: def test_dir_testing():
   73:     """Assert that output of dir has only one "testing/tester"
   74:     attribute without duplicate"""
   75:     assert len(dir(np)) == len(set(dir(np)))
   76: 
   77: 
   78: def test_numpy_linalg():
   79:     bad_results = check_dir(np.linalg)
   80:     assert bad_results == {}
   81: 
   82: 
   83: def test_numpy_fft():
   84:     bad_results = check_dir(np.fft)
   85:     assert bad_results == {}
   86: 
   87: 
   88: @pytest.mark.skipif(ctypes is None,
   89:                     reason="ctypes not available in this python")
   90: def test_NPY_NO_EXPORT():
   91:     cdll = ctypes.CDLL(np._core._multiarray_tests.__file__)
   92:     # Make sure an arbitrary NPY_NO_EXPORT function is actually hidden
   93:     f = getattr(cdll, 'test_not_exported', None)
   94:     assert f is None, ("'test_not_exported' is mistakenly exported, "
   95:                       "NPY_NO_EXPORT does not work")
   96: 
   97: 
   98: # Historically NumPy has not used leading underscores for private submodules
   99: # much.  This has resulted in lots of things that look like public modules
  100: # (i.e. things that can be imported as `import numpy.somesubmodule.somefile`),
  101: # but were never intended to be public.  The PUBLIC_MODULES list contains
  102: # modules that are either public because they were meant to be, or because they
  103: # contain public functions/objects that aren't present in any other namespace
  104: # for whatever reason and therefore should be treated as public.
  105: #
  106: # The PRIVATE_BUT_PRESENT_MODULES list contains modules that look public (lack
  107: # of underscores) but should not be used.  For many of those modules the
  108: # current status is fine.  For others it may make sense to work on making them
  109: # private, to clean up our public API and avoid confusion.
  110: PUBLIC_MODULES = ['numpy.' + s for s in [
  111:     "ctypeslib",
  112:     "dtypes",
  113:     "exceptions",
  114:     "f2py",
  115:     "fft",
  116:     "lib",
  117:     "lib.array_utils",
  118:     "lib.format",
  119:     "lib.introspect",
  120:     "lib.mixins",
  121:     "lib.npyio",
  122:     "lib.recfunctions",  # note: still needs cleaning, was forgotten for 2.0
  123:     "lib.scimath",
  124:     "lib.stride_tricks",
  125:     "linalg",
  126:     "ma",
  127:     "ma.extras",
  128:     "ma.mrecords",
  129:     "polynomial",
  130:     "polynomial.chebyshev",
  131:     "polynomial.hermite",
  132:     "polynomial.hermite_e",
  133:     "polynomial.laguerre",
  134:     "polynomial.legendre",
  135:     "polynomial.polynomial",
  136:     "random",
  137:     "strings",
  138:     "testing",
  139:     "testing.overrides",
  140:     "typing",
  141:     "typing.mypy_plugin",
  142:     "version",
  143: ]]
  144: if sys.version_info < (3, 12):
  145:     PUBLIC_MODULES += [
  146:         'numpy.' + s for s in [
  147:             "distutils",
  148:             "distutils.cpuinfo",
  149:             "distutils.exec_command",
  150:             "distutils.misc_util",
  151:             "distutils.log",
  152:             "distutils.system_info",
  153:         ]
  154:     ]
  155: 
  156: 
  157: PUBLIC_ALIASED_MODULES = [
  158:     "numpy.char",
  159:     "numpy.emath",
  160:     "numpy.rec",
  161: ]
  162: 
  163: 
  164: PRIVATE_BUT_PRESENT_MODULES = ['numpy.' + s for s in [
  165:     "conftest",
  166:     "core",
  167:     "core.multiarray",
  168:     "core.numeric",
  169:     "core.umath",
  170:     "core.arrayprint",
  171:     "core.defchararray",
  172:     "core.einsumfunc",
  173:     "core.fromnumeric",
  174:     "core.function_base",
  175:     "core.getlimits",
  176:     "core.numerictypes",
  177:     "core.overrides",
  178:     "core.records",
  179:     "core.shape_base",
  180:     "f2py.auxfuncs",
  181:     "f2py.capi_maps",
  182:     "f2py.cb_rules",
  183:     "f2py.cfuncs",
  184:     "f2py.common_rules",
  185:     "f2py.crackfortran",
  186:     "f2py.diagnose",
  187:     "f2py.f2py2e",
  188:     "f2py.f90mod_rules",
  189:     "f2py.func2subr",
  190:     "f2py.rules",
  191:     "f2py.symbolic",
  192:     "f2py.use_rules",
  193:     "fft.helper",
  194:     "lib.user_array",  # note: not in np.lib, but probably should just be deleted
  195:     "linalg.lapack_lite",
  196:     "linalg.linalg",
  197:     "ma.core",
  198:     "ma.testutils",
  199:     "matlib",
  200:     "matrixlib",
  201:     "matrixlib.defmatrix",
  202:     "polynomial.polyutils",
  203:     "random.mtrand",
  204:     "random.bit_generator",
  205:     "testing.print_coercion_tables",
  206: ]]
  207: if sys.version_info < (3, 12):
  208:     PRIVATE_BUT_PRESENT_MODULES += [
  209:         'numpy.' + s for s in [
  210:             "distutils.armccompiler",
  211:             "distutils.fujitsuccompiler",
  212:             "distutils.ccompiler",
  213:             'distutils.ccompiler_opt',
  214:             "distutils.command",
  215:             "distutils.command.autodist",
  216:             "distutils.command.bdist_rpm",
  217:             "distutils.command.build",
  218:             "distutils.command.build_clib",
  219:             "distutils.command.build_ext",
  220:             "distutils.command.build_py",
  221:             "distutils.command.build_scripts",
  222:             "distutils.command.build_src",
  223:             "distutils.command.config",
  224:             "distutils.command.config_compiler",
  225:             "distutils.command.develop",
  226:             "distutils.command.egg_info",
  227:             "distutils.command.install",
  228:             "distutils.command.install_clib",
  229:             "distutils.command.install_data",
  230:             "distutils.command.install_headers",
  231:             "distutils.command.sdist",
  232:             "distutils.conv_template",
  233:             "distutils.core",
  234:             "distutils.extension",
  235:             "distutils.fcompiler",
  236:             "distutils.fcompiler.absoft",
  237:             "distutils.fcompiler.arm",
  238:             "distutils.fcompiler.compaq",
  239:             "distutils.fcompiler.environment",
  240:             "distutils.fcompiler.g95",
  241:             "distutils.fcompiler.gnu",
  242:             "distutils.fcompiler.hpux",
  243:             "distutils.fcompiler.ibm",
  244:             "distutils.fcompiler.intel",
  245:             "distutils.fcompiler.lahey",
  246:             "distutils.fcompiler.mips",
  247:             "distutils.fcompiler.nag",
  248:             "distutils.fcompiler.none",
  249:             "distutils.fcompiler.pathf95",
  250:             "distutils.fcompiler.pg",
  251:             "distutils.fcompiler.nv",
  252:             "distutils.fcompiler.sun",
  253:             "distutils.fcompiler.vast",
  254:             "distutils.fcompiler.fujitsu",
  255:             "distutils.from_template",
  256:             "distutils.intelccompiler",
  257:             "distutils.lib2def",
  258:             "distutils.line_endings",
  259:             "distutils.mingw32ccompiler",
  260:             "distutils.msvccompiler",
  261:             "distutils.npy_pkg_config",
  262:             "distutils.numpy_distribution",
  263:             "distutils.pathccompiler",
  264:             "distutils.unixccompiler",
  265:         ]
  266:     ]
  267: 
  268: 
  269: def is_unexpected(name):
  270:     """Check if this needs to be considered."""
  271:     return (
  272:         '._' not in name and '.tests' not in name and '.setup' not in name
  273:         and name not in PUBLIC_MODULES
  274:         and name not in PUBLIC_ALIASED_MODULES
  275:         and name not in PRIVATE_BUT_PRESENT_MODULES
  276:     )
  277: 
  278: 
  279: if sys.version_info >= (3, 12):
  280:     SKIP_LIST = []
  281: else:
  282:     SKIP_LIST = ["numpy.distutils.msvc9compiler"]
  283: 
  284: 
  285: def test_all_modules_are_expected():
  286:     """
  287:     Test that we don't add anything that looks like a new public module by
  288:     accident.  Check is based on filenames.
  289:     """
  290: 
  291:     modnames = []
  292:     for _, modname, ispkg in pkgutil.walk_packages(path=np.__path__,
  293:                                                    prefix=np.__name__ + '.',
  294:                                                    onerror=None):
  295:         if is_unexpected(modname) and modname not in SKIP_LIST:
  296:             # We have a name that is new.  If that's on purpose, add it to
  297:             # PUBLIC_MODULES.  We don't expect to have to add anything to
  298:             # PRIVATE_BUT_PRESENT_MODULES.  Use an underscore in the name!
  299:             modnames.append(modname)
  300: 
  301:     if modnames:
  302:         raise AssertionError(f'Found unexpected modules: {modnames}')
  303: 
  304: 
  305: # Stuff that clearly shouldn't be in the API and is detected by the next test
  306: # below
  307: SKIP_LIST_2 = [
  308:     'numpy.lib.math',
  309:     'numpy.matlib.char',
  310:     'numpy.matlib.rec',
  311:     'numpy.matlib.emath',
  312:     'numpy.matlib.exceptions',
  313:     'numpy.matlib.math',
  314:     'numpy.matlib.linalg',
  315:     'numpy.matlib.fft',
  316:     'numpy.matlib.random',
  317:     'numpy.matlib.ctypeslib',
  318:     'numpy.matlib.ma',
  319: ]
  320: if sys.version_info < (3, 12):
  321:     SKIP_LIST_2 += [
  322:         'numpy.distutils.log.sys',
  323:         'numpy.distutils.log.logging',
  324:         'numpy.distutils.log.warnings',
  325:     ]
  326: 
  327: 
  328: def test_all_modules_are_expected_2():
  329:     """
  330:     Method checking all objects. The pkgutil-based method in
  331:     `test_all_modules_are_expected` does not catch imports into a namespace,
  332:     only filenames.  So this test is more thorough, and checks this like:
  333: 
  334:         import .lib.scimath as emath
  335: 
  336:     To check if something in a module is (effectively) public, one can check if
  337:     there's anything in that namespace that's a public function/object but is
  338:     not exposed in a higher-level namespace.  For example for a `numpy.lib`
  339:     submodule::
  340: 
  341:         mod = np.lib.mixins
  342:         for obj in mod.__all__:
  343:             if obj in np.__all__:
  344:                 continue
  345:             elif obj in np.lib.__all__:
  346:                 continue
  347: 
  348:             else:
  349:                 print(obj)
  350: 
  351:     """
  352: 
  353:     def find_unexpected_members(mod_name):
  354:         members = []
  355:         module = importlib.import_module(mod_name)
  356:         if hasattr(module, '__all__'):
  357:             objnames = module.__all__
  358:         else:
  359:             objnames = dir(module)
  360: 
  361:         for objname in objnames:
  362:             if not objname.startswith('_'):
  363:                 fullobjname = mod_name + '.' + objname
  364:                 if isinstance(getattr(module, objname), types.ModuleType):
  365:                     if is_unexpected(fullobjname):
  366:                         if fullobjname not in SKIP_LIST_2:
  367:                             members.append(fullobjname)
  368: 
  369:         return members
  370: 
  371:     unexpected_members = find_unexpected_members("numpy")
  372:     for modname in PUBLIC_MODULES:
  373:         unexpected_members.extend(find_unexpected_members(modname))
  374: 
  375:     if unexpected_members:
  376:         raise AssertionError("Found unexpected object(s) that look like "
  377:                              f"modules: {unexpected_members}")
  378: 
  379: 
  380: def test_api_importable():
  381:     """
  382:     Check that all submodules listed higher up in this file can be imported
  383: 
  384:     Note that if a PRIVATE_BUT_PRESENT_MODULES entry goes missing, it may
  385:     simply need to be removed from the list (deprecation may or may not be
  386:     needed - apply common sense).
  387:     """
  388:     def check_importable(module_name):
  389:         try:
  390:             importlib.import_module(module_name)
  391:         except (ImportError, AttributeError):
  392:             return False
  393: 
  394:         return True
  395: 
  396:     module_names = []
  397:     for module_name in PUBLIC_MODULES:
  398:         if not check_importable(module_name):
  399:             module_names.append(module_name)
  400: 
  401:     if module_names:
  402:         raise AssertionError("Modules in the public API that cannot be "
  403:                              f"imported: {module_names}")
  404: 
  405:     for module_name in PUBLIC_ALIASED_MODULES:
  406:         try:
  407:             eval(module_name)
  408:         except AttributeError:
  409:             module_names.append(module_name)
  410: 
  411:     if module_names:
  412:         raise AssertionError("Modules in the public API that were not "
  413:                              f"found: {module_names}")
  414: 
  415:     with warnings.catch_warnings(record=True) as w:
  416:         warnings.filterwarnings('always', category=DeprecationWarning)
  417:         warnings.filterwarnings('always', category=ImportWarning)
  418:         for module_name in PRIVATE_BUT_PRESENT_MODULES:
  419:             if not check_importable(module_name):
  420:                 module_names.append(module_name)
  421: 
  422:     if module_names:
  423:         raise AssertionError("Modules that are not really public but looked "
  424:                              "public and can not be imported: "
  425:                              f"{module_names}")
  426: 
  427: 
  428: @pytest.mark.xfail(
  429:     sysconfig.get_config_var("Py_DEBUG") not in (None, 0, "0"),
  430:     reason=(
  431:         "NumPy possibly built with `USE_DEBUG=True ./tools/travis-test.sh`, "
  432:         "which does not expose the `array_api` entry point. "
  433:         "See https://github.com/numpy/numpy/pull/19800"
  434:     ),
  435: )
  436: def test_array_api_entry_point():
  437:     """
  438:     Entry point for Array API implementation can be found with importlib and
  439:     returns the main numpy namespace.
  440:     """
  441:     # For a development install that did not go through meson-python,
  442:     # the entrypoint will not have been installed. So ensure this test fails
  443:     # only if numpy is inside site-packages.
  444:     numpy_in_sitepackages = sysconfig.get_path('platlib') in np.__file__
  445: 
  446:     eps = importlib.metadata.entry_points()
  447:     xp_eps = eps.select(group="array_api")
  448:     if len(xp_eps) == 0:
  449:         if numpy_in_sitepackages:
  450:             msg = "No entry points for 'array_api' found"
  451:             raise AssertionError(msg) from None
  452:         return
  453: 
  454:     try:
  455:         ep = next(ep for ep in xp_eps if ep.name == "numpy")
  456:     except StopIteration:
  457:         if numpy_in_sitepackages:
  458:             msg = "'numpy' not in array_api entry points"
  459:             raise AssertionError(msg) from None
  460:         return
  461: 
  462:     if ep.value == 'numpy.array_api':
  463:         # Looks like the entrypoint for the current numpy build isn't
  464:         # installed, but an older numpy is also installed and hence the
  465:         # entrypoint is pointing to the old (no longer existing) location.
  466:         # This isn't a problem except for when running tests with `spin` or an
  467:         # in-place build.
  468:         return
  469: 
  470:     xp = ep.load()
  471:     msg = (
  472:         f"numpy entry point value '{ep.value}' "
  473:         "does not point to our Array API implementation"
  474:     )
  475:     assert xp is numpy, msg
  476: 
  477: 
  478: def test_main_namespace_all_dir_coherence():
  479:     """
  480:     Checks if `dir(np)` and `np.__all__` are consistent and return
  481:     the same content, excluding exceptions and private members.
  482:     """
  483:     def _remove_private_members(member_set):
  484:         return {m for m in member_set if not m.startswith('_')}
  485: 
  486:     def _remove_exceptions(member_set):
  487:         return member_set.difference({
  488:             "bool"  # included only in __dir__
  489:         })
  490: 
  491:     all_members = _remove_private_members(np.__all__)
  492:     all_members = _remove_exceptions(all_members)
  493: 
  494:     dir_members = _remove_private_members(np.__dir__())
  495:     dir_members = _remove_exceptions(dir_members)
  496: 
  497:     assert all_members == dir_members, (
  498:         "Members that break symmetry: "
  499:         f"{all_members.symmetric_difference(dir_members)}"
  500:     )
  501: 
  502: 
  503: @pytest.mark.filterwarnings(
  504:     r"ignore:numpy.core(\.\w+)? is deprecated:DeprecationWarning"
  505: )
  506: def test_core_shims_coherence():
  507:     """
  508:     Check that all "semi-public" members of `numpy._core` are also accessible
  509:     from `numpy.core` shims.
  510:     """
  511:     import numpy.core as core
  512: 
  513:     for member_name in dir(np._core):
  514:         # Skip private and test members. Also if a module is aliased,
  515:         # no need to add it to np.core
  516:         if (
  517:             member_name.startswith("_")
  518:             or member_name in ["tests", "strings"]
  519:             or f"numpy.{member_name}" in PUBLIC_ALIASED_MODULES
  520:         ):
  521:             continue
  522: 
  523:         member = getattr(np._core, member_name)
  524: 
  525:         # np.core is a shim and all submodules of np.core are shims
  526:         # but we should be able to import everything in those shims
  527:         # that are available in the "real" modules in np._core, with
  528:         # the exception of the namespace packages (__spec__.origin is None),
  529:         # like numpy._core.include, or numpy._core.lib.pkgconfig.
  530:         if (
  531:             inspect.ismodule(member)
  532:             and member.__spec__ and member.__spec__.origin is not None
  533:         ):
  534:             submodule = member
  535:             submodule_name = member_name
  536:             for submodule_member_name in dir(submodule):
  537:                 # ignore dunder names
  538:                 if submodule_member_name.startswith("__"):
  539:                     continue
  540:                 submodule_member = getattr(submodule, submodule_member_name)
  541: 
  542:                 core_submodule = __import__(
  543:                     f"numpy.core.{submodule_name}",
  544:                     fromlist=[submodule_member_name]
  545:                 )
  546: 
  547:                 assert submodule_member is getattr(
  548:                     core_submodule, submodule_member_name
  549:                 )
  550: 
  551:         else:
  552:             assert member is getattr(core, member_name)
  553: 
  554: 
  555: def test_functions_single_location():
  556:     """
  557:     Check that each public function is available from one location only.
  558: 
  559:     Test performs BFS search traversing NumPy's public API. It flags
  560:     any function-like object that is accessible from more that one place.
  561:     """
  562:     from collections.abc import Callable
  563:     from typing import Any
  564: 
  565:     from numpy._core._multiarray_umath import (
  566:         _ArrayFunctionDispatcher as dispatched_function,
  567:     )
  568: 
  569:     visited_modules: set[types.ModuleType] = {np}
  570:     visited_functions: set[Callable[..., Any]] = set()
  571:     # Functions often have `__name__` overridden, therefore we need
  572:     # to keep track of locations where functions have been found.
  573:     functions_original_paths: dict[Callable[..., Any], str] = {}
  574: 
  575:     # Here we aggregate functions with more than one location.
  576:     # It must be empty for the test to pass.
  577:     duplicated_functions: list[tuple] = []
  578: 
  579:     modules_queue = [np]
  580: 
  581:     while len(modules_queue) > 0:
  582: 
  583:         module = modules_queue.pop()
  584: 
  585:         for member_name in dir(module):
  586:             member = getattr(module, member_name)
  587: 
  588:             # first check if we got a module
  589:             if (
  590:                 inspect.ismodule(member) and  # it's a module
  591:                 "numpy" in member.__name__ and  # inside NumPy
  592:                 not member_name.startswith("_") and  # not private
  593:                 "numpy._core" not in member.__name__ and  # outside _core
  594:                 # not a legacy or testing module
  595:                 member_name not in ["f2py", "ma", "testing", "tests"] and
  596:                 member not in visited_modules  # not visited yet
  597:             ):
  598:                 modules_queue.append(member)
  599:                 visited_modules.add(member)
  600: 
  601:             # else check if we got a function-like object
  602:             elif (
  603:                 inspect.isfunction(member) or
  604:                 isinstance(member, (dispatched_function, np.ufunc))
  605:             ):
  606:                 if member in visited_functions:
  607: 
  608:                     # skip main namespace functions with aliases
  609:                     if (
  610:                         member.__name__ in [
  611:                             "absolute",  # np.abs
  612:                             "arccos",  # np.acos
  613:                             "arccosh",  # np.acosh
  614:                             "arcsin",  # np.asin
  615:                             "arcsinh",  # np.asinh
  616:                             "arctan",  # np.atan
  617:                             "arctan2",  # np.atan2
  618:                             "arctanh",  # np.atanh
  619:                             "left_shift",  # np.bitwise_left_shift
  620:                             "right_shift",  # np.bitwise_right_shift
  621:                             "conjugate",  # np.conj
  622:                             "invert",  # np.bitwise_not & np.bitwise_invert
  623:                             "remainder",  # np.mod
  624:                             "divide",  # np.true_divide
  625:                             "concatenate",  # np.concat
  626:                             "power",  # np.pow
  627:                             "transpose",  # np.permute_dims
  628:                         ] and
  629:                         module.__name__ == "numpy"
  630:                     ):
  631:                         continue
  632:                     # skip trimcoef from numpy.polynomial as it is
  633:                     # duplicated by design.
  634:                     if (
  635:                         member.__name__ == "trimcoef" and
  636:                         module.__name__.startswith("numpy.polynomial")
  637:                     ):
  638:                         continue
  639: 
  640:                     # skip ufuncs that are exported in np.strings as well
  641:                     if member.__name__ in (
  642:                         "add",
  643:                         "equal",
  644:                         "not_equal",
  645:                         "greater",
  646:                         "greater_equal",
  647:                         "less",
  648:                         "less_equal",
  649:                     ) and module.__name__ == "numpy.strings":
  650:                         continue
  651: 
  652:                     # numpy.char reexports all numpy.strings functions for
  653:                     # backwards-compatibility
  654:                     if module.__name__ == "numpy.char":
  655:                         continue
  656: 
  657:                     # function is present in more than one location!
  658:                     duplicated_functions.append(
  659:                         (member.__name__,
  660:                          module.__name__,
  661:                          functions_original_paths[member])
  662:                     )
  663:                 else:
  664:                     visited_functions.add(member)
  665:                     functions_original_paths[member] = module.__name__
  666: 
  667:     del visited_functions, visited_modules, functions_original_paths
  668: 
  669:     assert len(duplicated_functions) == 0, duplicated_functions
  670: 
  671: 
  672: def test___module___attribute():
  673:     modules_queue = [np]
  674:     visited_modules = {np}
  675:     visited_functions = set()
  676:     incorrect_entries = []
  677: 
  678:     while len(modules_queue) > 0:
  679:         module = modules_queue.pop()
  680:         for member_name in dir(module):
  681:             member = getattr(module, member_name)
  682:             # first check if we got a module
  683:             if (
  684:                 inspect.ismodule(member) and  # it's a module
  685:                 "numpy" in member.__name__ and  # inside NumPy
  686:                 not member_name.startswith("_") and  # not private
  687:                 "numpy._core" not in member.__name__ and  # outside _core
  688:                 # not in a skip module list
  689:                 member_name not in [
  690:                     "char", "core", "f2py", "ma", "lapack_lite", "mrecords",
  691:                     "testing", "tests", "polynomial", "typing", "mtrand",
  692:                     "bit_generator",
  693:                 ] and
  694:                 member not in visited_modules  # not visited yet
  695:             ):
  696:                 modules_queue.append(member)
  697:                 visited_modules.add(member)
  698:             elif (
  699:                 not inspect.ismodule(member) and
  700:                 hasattr(member, "__name__") and
  701:                 not member.__name__.startswith("_") and
  702:                 member.__module__ != module.__name__ and
  703:                 member not in visited_functions
  704:             ):
  705:                 # skip ufuncs that are exported in np.strings as well
  706:                 if member.__name__ in (
  707:                     "add", "equal", "not_equal", "greater", "greater_equal",
  708:                     "less", "less_equal",
  709:                 ) and module.__name__ == "numpy.strings":
  710:                     continue
  711: 
  712:                 # recarray and record are exported in np and np.rec
  713:                 if (
  714:                     (member.__name__ == "recarray" and module.__name__ == "numpy") or
  715:                     (member.__name__ == "record" and module.__name__ == "numpy.rec")
  716:                 ):
  717:                     continue
  718: 
  719:                 # ctypeslib exports ctypes c_long/c_longlong
  720:                 if (
  721:                     member.__name__ in ("c_long", "c_longlong") and
  722:                     module.__name__ == "numpy.ctypeslib"
  723:                 ):
  724:                     continue
  725: 
  726:                 # skip cdef classes
  727:                 if member.__name__ in (
  728:                     "BitGenerator", "Generator", "MT19937", "PCG64", "PCG64DXSM",
  729:                     "Philox", "RandomState", "SFC64", "SeedSequence",
  730:                 ):
  731:                     continue
  732: 
  733:                 incorrect_entries.append(
  734:                     {
  735:                         "Func": member.__name__,
  736:                         "actual": member.__module__,
  737:                         "expected": module.__name__,
  738:                     }
  739:                 )
  740:                 visited_functions.add(member)
  741: 
  742:     if incorrect_entries:
  743:         assert len(incorrect_entries) == 0, incorrect_entries
  744: 
  745: 
  746: def _check_correct_qualname_and_module(obj) -> bool:
  747:     qualname = obj.__qualname__
  748:     name = obj.__name__
  749:     module_name = obj.__module__
  750:     assert name == qualname.split(".")[-1]
  751: 
  752:     module = sys.modules[module_name]
  753:     actual_obj = functools.reduce(getattr, qualname.split("."), module)
  754:     return (
  755:         actual_obj is obj or
  756:         # `obj` may be a bound method/property of `actual_obj`:
  757:         (
  758:             hasattr(actual_obj, "__get__") and hasattr(obj, "__self__") and
  759:             actual_obj.__module__ == obj.__module__ and
  760:             actual_obj.__qualname__ == qualname
  761:         )
  762:     )
  763: 
  764: 
  765: def test___qualname___and___module___attribute():
  766:     # NumPy messes with module and name/qualname attributes, but any object
  767:     # should be discoverable based on its module and qualname, so test that.
  768:     # We do this for anything with a name (ensuring qualname is also set).
  769:     modules_queue = [np]
  770:     visited_modules = {np}
  771:     visited_functions = set()
  772:     incorrect_entries = []
  773: 
  774:     while len(modules_queue) > 0:
  775:         module = modules_queue.pop()
  776:         for member_name in dir(module):
  777:             member = getattr(module, member_name)
  778:             # first check if we got a module
  779:             if (
  780:                 inspect.ismodule(member) and  # it's a module
  781:                 "numpy" in member.__name__ and  # inside NumPy
  782:                 not member_name.startswith("_") and  # not private
  783:                 member_name not in {"tests", "typing"} and  # 2024-12: type names don't match
  784:                 "numpy._core" not in member.__name__ and  # outside _core
  785:                 member not in visited_modules  # not visited yet
  786:             ):
  787:                 modules_queue.append(member)
  788:                 visited_modules.add(member)
  789:             elif (
  790:                 not inspect.ismodule(member) and
  791:                 hasattr(member, "__name__") and
  792:                 not member.__name__.startswith("_") and
  793:                 not member_name.startswith("_") and
  794:                 not _check_correct_qualname_and_module(member) and
  795:                 member not in visited_functions
  796:             ):
  797:                 incorrect_entries.append(
  798:                     {
  799:                         "found_at": f"{module.__name__}:{member_name}",
  800:                         "advertises": f"{member.__module__}:{member.__qualname__}",
  801:                     }
  802:                 )
  803:                 visited_functions.add(member)
  804: 
  805:     if incorrect_entries:
  806:         assert len(incorrect_entries) == 0, incorrect_entries
