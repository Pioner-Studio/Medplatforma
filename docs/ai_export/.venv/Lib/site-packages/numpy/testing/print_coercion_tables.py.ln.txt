    1: #!/usr/bin/env python3
    2: """Prints type-coercion tables for the built-in NumPy types
    3: 
    4: """
    5: from collections import namedtuple
    6: 
    7: import numpy as np
    8: from numpy._core.numerictypes import obj2sctype
    9: 
   10: 
   11: # Generic object that can be added, but doesn't do anything else
   12: class GenericObject:
   13:     def __init__(self, v):
   14:         self.v = v
   15: 
   16:     def __add__(self, other):
   17:         return self
   18: 
   19:     def __radd__(self, other):
   20:         return self
   21: 
   22:     dtype = np.dtype('O')
   23: 
   24: def print_cancast_table(ntypes):
   25:     print('X', end=' ')
   26:     for char in ntypes:
   27:         print(char, end=' ')
   28:     print()
   29:     for row in ntypes:
   30:         print(row, end=' ')
   31:         for col in ntypes:
   32:             if np.can_cast(row, col, "equiv"):
   33:                 cast = "#"
   34:             elif np.can_cast(row, col, "safe"):
   35:                 cast = "="
   36:             elif np.can_cast(row, col, "same_kind"):
   37:                 cast = "~"
   38:             elif np.can_cast(row, col, "unsafe"):
   39:                 cast = "."
   40:             else:
   41:                 cast = " "
   42:             print(cast, end=' ')
   43:         print()
   44: 
   45: def print_coercion_table(ntypes, inputfirstvalue, inputsecondvalue, firstarray,
   46:                          use_promote_types=False):
   47:     print('+', end=' ')
   48:     for char in ntypes:
   49:         print(char, end=' ')
   50:     print()
   51:     for row in ntypes:
   52:         if row == 'O':
   53:             rowtype = GenericObject
   54:         else:
   55:             rowtype = obj2sctype(row)
   56: 
   57:         print(row, end=' ')
   58:         for col in ntypes:
   59:             if col == 'O':
   60:                 coltype = GenericObject
   61:             else:
   62:                 coltype = obj2sctype(col)
   63:             try:
   64:                 if firstarray:
   65:                     rowvalue = np.array([rowtype(inputfirstvalue)], dtype=rowtype)
   66:                 else:
   67:                     rowvalue = rowtype(inputfirstvalue)
   68:                 colvalue = coltype(inputsecondvalue)
   69:                 if use_promote_types:
   70:                     char = np.promote_types(rowvalue.dtype, colvalue.dtype).char
   71:                 else:
   72:                     value = np.add(rowvalue, colvalue)
   73:                     if isinstance(value, np.ndarray):
   74:                         char = value.dtype.char
   75:                     else:
   76:                         char = np.dtype(type(value)).char
   77:             except ValueError:
   78:                 char = '!'
   79:             except OverflowError:
   80:                 char = '@'
   81:             except TypeError:
   82:                 char = '#'
   83:             print(char, end=' ')
   84:         print()
   85: 
   86: 
   87: def print_new_cast_table(*, can_cast=True, legacy=False, flags=False):
   88:     """Prints new casts, the values given are default "can-cast" values, not
   89:     actual ones.
   90:     """
   91:     from numpy._core._multiarray_tests import get_all_cast_information
   92: 
   93:     cast_table = {
   94:         -1: " ",
   95:         0: "#",  # No cast (classify as equivalent here)
   96:         1: "#",  # equivalent casting
   97:         2: "=",  # safe casting
   98:         3: "~",  # same-kind casting
   99:         4: ".",  # unsafe casting
  100:     }
  101:     flags_table = {
  102:         0: "в–—", 7: "в–€",
  103:         1: "в–љ", 2: "в–ђ", 4: "в–„",
  104:                 3: "в–њ", 5: "в–™",
  105:                         6: "в–џ",
  106:     }
  107: 
  108:     cast_info = namedtuple("cast_info", ["can_cast", "legacy", "flags"])
  109:     no_cast_info = cast_info(" ", " ", " ")
  110: 
  111:     casts = get_all_cast_information()
  112:     table = {}
  113:     dtypes = set()
  114:     for cast in casts:
  115:         dtypes.add(cast["from"])
  116:         dtypes.add(cast["to"])
  117: 
  118:         if cast["from"] not in table:
  119:             table[cast["from"]] = {}
  120:         to_dict = table[cast["from"]]
  121: 
  122:         can_cast = cast_table[cast["casting"]]
  123:         legacy = "L" if cast["legacy"] else "."
  124:         flags = 0
  125:         if cast["requires_pyapi"]:
  126:             flags |= 1
  127:         if cast["supports_unaligned"]:
  128:             flags |= 2
  129:         if cast["no_floatingpoint_errors"]:
  130:             flags |= 4
  131: 
  132:         flags = flags_table[flags]
  133:         to_dict[cast["to"]] = cast_info(can_cast=can_cast, legacy=legacy, flags=flags)
  134: 
  135:     # The np.dtype(x.type) is a bit strange, because dtype classes do
  136:     # not expose much yet.
  137:     types = np.typecodes["All"]
  138: 
  139:     def sorter(x):
  140:         # This is a bit weird hack, to get a table as close as possible to
  141:         # the one printing all typecodes (but expecting user-dtypes).
  142:         dtype = np.dtype(x.type)
  143:         try:
  144:             indx = types.index(dtype.char)
  145:         except ValueError:
  146:             indx = np.inf
  147:         return (indx, dtype.char)
  148: 
  149:     dtypes = sorted(dtypes, key=sorter)
  150: 
  151:     def print_table(field="can_cast"):
  152:         print('X', end=' ')
  153:         for dt in dtypes:
  154:             print(np.dtype(dt.type).char, end=' ')
  155:         print()
  156:         for from_dt in dtypes:
  157:             print(np.dtype(from_dt.type).char, end=' ')
  158:             row = table.get(from_dt, {})
  159:             for to_dt in dtypes:
  160:                 print(getattr(row.get(to_dt, no_cast_info), field), end=' ')
  161:             print()
  162: 
  163:     if can_cast:
  164:         # Print the actual table:
  165:         print()
  166:         print("Casting: # is equivalent, = is safe, ~ is same-kind, and . is unsafe")
  167:         print()
  168:         print_table("can_cast")
  169: 
  170:     if legacy:
  171:         print()
  172:         print("L denotes a legacy cast . a non-legacy one.")
  173:         print()
  174:         print_table("legacy")
  175: 
  176:     if flags:
  177:         print()
  178:         print(f"{flags_table[0]}: no flags, "
  179:               f"{flags_table[1]}: PyAPI, "
  180:               f"{flags_table[2]}: supports unaligned, "
  181:               f"{flags_table[4]}: no-float-errors")
  182:         print()
  183:         print_table("flags")
  184: 
  185: 
  186: if __name__ == '__main__':
  187:     print("can cast")
  188:     print_cancast_table(np.typecodes['All'])
  189:     print()
  190:     print("In these tables, ValueError is '!', OverflowError is '@', TypeError is '#'")
  191:     print()
  192:     print("scalar + scalar")
  193:     print_coercion_table(np.typecodes['All'], 0, 0, False)
  194:     print()
  195:     print("scalar + neg scalar")
  196:     print_coercion_table(np.typecodes['All'], 0, -1, False)
  197:     print()
  198:     print("array + scalar")
  199:     print_coercion_table(np.typecodes['All'], 0, 0, True)
  200:     print()
  201:     print("array + neg scalar")
  202:     print_coercion_table(np.typecodes['All'], 0, -1, True)
  203:     print()
  204:     print("promote_types")
  205:     print_coercion_table(np.typecodes['All'], 0, 0, False, True)
  206:     print("New casting type promotion:")
  207:     print_new_cast_table(can_cast=True, legacy=True, flags=True)
