    1: import itertools
    2: import os
    3: import re
    4: import sys
    5: import warnings
    6: import weakref
    7: 
    8: import pytest
    9: 
   10: import numpy as np
   11: import numpy._core._multiarray_umath as ncu
   12: from numpy.testing import (
   13:     HAS_REFCOUNT,
   14:     assert_,
   15:     assert_allclose,
   16:     assert_almost_equal,
   17:     assert_approx_equal,
   18:     assert_array_almost_equal,
   19:     assert_array_almost_equal_nulp,
   20:     assert_array_equal,
   21:     assert_array_less,
   22:     assert_array_max_ulp,
   23:     assert_equal,
   24:     assert_no_gc_cycles,
   25:     assert_no_warnings,
   26:     assert_raises,
   27:     assert_string_equal,
   28:     assert_warns,
   29:     build_err_msg,
   30:     clear_and_catch_warnings,
   31:     suppress_warnings,
   32:     tempdir,
   33:     temppath,
   34: )
   35: 
   36: 
   37: class _GenericTest:
   38: 
   39:     def _test_equal(self, a, b):
   40:         self._assert_func(a, b)
   41: 
   42:     def _test_not_equal(self, a, b):
   43:         with assert_raises(AssertionError):
   44:             self._assert_func(a, b)
   45: 
   46:     def test_array_rank1_eq(self):
   47:         """Test two equal array of rank 1 are found equal."""
   48:         a = np.array([1, 2])
   49:         b = np.array([1, 2])
   50: 
   51:         self._test_equal(a, b)
   52: 
   53:     def test_array_rank1_noteq(self):
   54:         """Test two different array of rank 1 are found not equal."""
   55:         a = np.array([1, 2])
   56:         b = np.array([2, 2])
   57: 
   58:         self._test_not_equal(a, b)
   59: 
   60:     def test_array_rank2_eq(self):
   61:         """Test two equal array of rank 2 are found equal."""
   62:         a = np.array([[1, 2], [3, 4]])
   63:         b = np.array([[1, 2], [3, 4]])
   64: 
   65:         self._test_equal(a, b)
   66: 
   67:     def test_array_diffshape(self):
   68:         """Test two arrays with different shapes are found not equal."""
   69:         a = np.array([1, 2])
   70:         b = np.array([[1, 2], [1, 2]])
   71: 
   72:         self._test_not_equal(a, b)
   73: 
   74:     def test_objarray(self):
   75:         """Test object arrays."""
   76:         a = np.array([1, 1], dtype=object)
   77:         self._test_equal(a, 1)
   78: 
   79:     def test_array_likes(self):
   80:         self._test_equal([1, 2, 3], (1, 2, 3))
   81: 
   82: 
   83: class TestArrayEqual(_GenericTest):
   84: 
   85:     def setup_method(self):
   86:         self._assert_func = assert_array_equal
   87: 
   88:     def test_generic_rank1(self):
   89:         """Test rank 1 array for all dtypes."""
   90:         def foo(t):
   91:             a = np.empty(2, t)
   92:             a.fill(1)
   93:             b = a.copy()
   94:             c = a.copy()
   95:             c.fill(0)
   96:             self._test_equal(a, b)
   97:             self._test_not_equal(c, b)
   98: 
   99:         # Test numeric types and object
  100:         for t in '?bhilqpBHILQPfdgFDG':
  101:             foo(t)
  102: 
  103:         # Test strings
  104:         for t in ['S1', 'U1']:
  105:             foo(t)
  106: 
  107:     def test_0_ndim_array(self):
  108:         x = np.array(473963742225900817127911193656584771)
  109:         y = np.array(18535119325151578301457182298393896)
  110: 
  111:         with pytest.raises(AssertionError) as exc_info:
  112:             self._assert_func(x, y)
  113:         msg = str(exc_info.value)
  114:         assert_('Mismatched elements: 1 / 1 (100%)\n'
  115:                 in msg)
  116: 
  117:         y = x
  118:         self._assert_func(x, y)
  119: 
  120:         x = np.array(4395065348745.5643764887869876)
  121:         y = np.array(0)
  122:         expected_msg = ('Mismatched elements: 1 / 1 (100%)\n'
  123:                         'Max absolute difference among violations: '
  124:                         '4.39506535e+12\n'
  125:                         'Max relative difference among violations: inf\n')
  126:         with pytest.raises(AssertionError, match=re.escape(expected_msg)):
  127:             self._assert_func(x, y)
  128: 
  129:         x = y
  130:         self._assert_func(x, y)
  131: 
  132:     def test_generic_rank3(self):
  133:         """Test rank 3 array for all dtypes."""
  134:         def foo(t):
  135:             a = np.empty((4, 2, 3), t)
  136:             a.fill(1)
  137:             b = a.copy()
  138:             c = a.copy()
  139:             c.fill(0)
  140:             self._test_equal(a, b)
  141:             self._test_not_equal(c, b)
  142: 
  143:         # Test numeric types and object
  144:         for t in '?bhilqpBHILQPfdgFDG':
  145:             foo(t)
  146: 
  147:         # Test strings
  148:         for t in ['S1', 'U1']:
  149:             foo(t)
  150: 
  151:     def test_nan_array(self):
  152:         """Test arrays with nan values in them."""
  153:         a = np.array([1, 2, np.nan])
  154:         b = np.array([1, 2, np.nan])
  155: 
  156:         self._test_equal(a, b)
  157: 
  158:         c = np.array([1, 2, 3])
  159:         self._test_not_equal(c, b)
  160: 
  161:     def test_string_arrays(self):
  162:         """Test two arrays with different shapes are found not equal."""
  163:         a = np.array(['floupi', 'floupa'])
  164:         b = np.array(['floupi', 'floupa'])
  165: 
  166:         self._test_equal(a, b)
  167: 
  168:         c = np.array(['floupipi', 'floupa'])
  169: 
  170:         self._test_not_equal(c, b)
  171: 
  172:     def test_recarrays(self):
  173:         """Test record arrays."""
  174:         a = np.empty(2, [('floupi', float), ('floupa', float)])
  175:         a['floupi'] = [1, 2]
  176:         a['floupa'] = [1, 2]
  177:         b = a.copy()
  178: 
  179:         self._test_equal(a, b)
  180: 
  181:         c = np.empty(2, [('floupipi', float),
  182:                          ('floupi', float), ('floupa', float)])
  183:         c['floupipi'] = a['floupi'].copy()
  184:         c['floupa'] = a['floupa'].copy()
  185: 
  186:         with pytest.raises(TypeError):
  187:             self._test_not_equal(c, b)
  188: 
  189:     def test_masked_nan_inf(self):
  190:         # Regression test for gh-11121
  191:         a = np.ma.MaskedArray([3., 4., 6.5], mask=[False, True, False])
  192:         b = np.array([3., np.nan, 6.5])
  193:         self._test_equal(a, b)
  194:         self._test_equal(b, a)
  195:         a = np.ma.MaskedArray([3., 4., 6.5], mask=[True, False, False])
  196:         b = np.array([np.inf, 4., 6.5])
  197:         self._test_equal(a, b)
  198:         self._test_equal(b, a)
  199: 
  200:     def test_subclass_that_overrides_eq(self):
  201:         # While we cannot guarantee testing functions will always work for
  202:         # subclasses, the tests should ideally rely only on subclasses having
  203:         # comparison operators, not on them being able to store booleans
  204:         # (which, e.g., astropy Quantity cannot usefully do). See gh-8452.
  205:         class MyArray(np.ndarray):
  206:             def __eq__(self, other):
  207:                 return bool(np.equal(self, other).all())
  208: 
  209:             def __ne__(self, other):
  210:                 return not self == other
  211: 
  212:         a = np.array([1., 2.]).view(MyArray)
  213:         b = np.array([2., 3.]).view(MyArray)
  214:         assert_(type(a == a), bool)
  215:         assert_(a == a)
  216:         assert_(a != b)
  217:         self._test_equal(a, a)
  218:         self._test_not_equal(a, b)
  219:         self._test_not_equal(b, a)
  220: 
  221:         expected_msg = ('Mismatched elements: 1 / 2 (50%)\n'
  222:                         'Max absolute difference among violations: 1.\n'
  223:                         'Max relative difference among violations: 0.5')
  224:         with pytest.raises(AssertionError, match=re.escape(expected_msg)):
  225:             self._test_equal(a, b)
  226: 
  227:         c = np.array([0., 2.9]).view(MyArray)
  228:         expected_msg = ('Mismatched elements: 1 / 2 (50%)\n'
  229:                         'Max absolute difference among violations: 2.\n'
  230:                         'Max relative difference among violations: inf')
  231:         with pytest.raises(AssertionError, match=re.escape(expected_msg)):
  232:             self._test_equal(b, c)
  233: 
  234:     def test_subclass_that_does_not_implement_npall(self):
  235:         class MyArray(np.ndarray):
  236:             def __array_function__(self, *args, **kwargs):
  237:                 return NotImplemented
  238: 
  239:         a = np.array([1., 2.]).view(MyArray)
  240:         b = np.array([2., 3.]).view(MyArray)
  241:         with assert_raises(TypeError):
  242:             np.all(a)
  243:         self._test_equal(a, a)
  244:         self._test_not_equal(a, b)
  245:         self._test_not_equal(b, a)
  246: 
  247:     def test_suppress_overflow_warnings(self):
  248:         # Based on issue #18992
  249:         with pytest.raises(AssertionError):
  250:             with np.errstate(all="raise"):
  251:                 np.testing.assert_array_equal(
  252:                     np.array([1, 2, 3], np.float32),
  253:                     np.array([1, 1e-40, 3], np.float32))
  254: 
  255:     def test_array_vs_scalar_is_equal(self):
  256:         """Test comparing an array with a scalar when all values are equal."""
  257:         a = np.array([1., 1., 1.])
  258:         b = 1.
  259: 
  260:         self._test_equal(a, b)
  261: 
  262:     def test_array_vs_array_not_equal(self):
  263:         """Test comparing an array with a scalar when not all values equal."""
  264:         a = np.array([34986, 545676, 439655, 563766])
  265:         b = np.array([34986, 545676, 439655, 0])
  266: 
  267:         expected_msg = ('Mismatched elements: 1 / 4 (25%)\n'
  268:                         'Max absolute difference among violations: 563766\n'
  269:                         'Max relative difference among violations: inf')
  270:         with pytest.raises(AssertionError, match=re.escape(expected_msg)):
  271:             self._assert_func(a, b)
  272: 
  273:         a = np.array([34986, 545676, 439655.2, 563766])
  274:         expected_msg = ('Mismatched elements: 2 / 4 (50%)\n'
  275:                         'Max absolute difference among violations: '
  276:                         '563766.\n'
  277:                         'Max relative difference among violations: '
  278:                         '4.54902139e-07')
  279:         with pytest.raises(AssertionError, match=re.escape(expected_msg)):
  280:             self._assert_func(a, b)
  281: 
  282:     def test_array_vs_scalar_strict(self):
  283:         """Test comparing an array with a scalar with strict option."""
  284:         a = np.array([1., 1., 1.])
  285:         b = 1.
  286: 
  287:         with pytest.raises(AssertionError):
  288:             self._assert_func(a, b, strict=True)
  289: 
  290:     def test_array_vs_array_strict(self):
  291:         """Test comparing two arrays with strict option."""
  292:         a = np.array([1., 1., 1.])
  293:         b = np.array([1., 1., 1.])
  294: 
  295:         self._assert_func(a, b, strict=True)
  296: 
  297:     def test_array_vs_float_array_strict(self):
  298:         """Test comparing two arrays with strict option."""
  299:         a = np.array([1, 1, 1])
  300:         b = np.array([1., 1., 1.])
  301: 
  302:         with pytest.raises(AssertionError):
  303:             self._assert_func(a, b, strict=True)
  304: 
  305: 
  306: class TestBuildErrorMessage:
  307: 
  308:     def test_build_err_msg_defaults(self):
  309:         x = np.array([1.00001, 2.00002, 3.00003])
  310:         y = np.array([1.00002, 2.00003, 3.00004])
  311:         err_msg = 'There is a mismatch'
  312: 
  313:         a = build_err_msg([x, y], err_msg)
  314:         b = ('\nItems are not equal: There is a mismatch\n ACTUAL: array(['
  315:              '1.00001, 2.00002, 3.00003])\n DESIRED: array([1.00002, '
  316:              '2.00003, 3.00004])')
  317:         assert_equal(a, b)
  318: 
  319:     def test_build_err_msg_no_verbose(self):
  320:         x = np.array([1.00001, 2.00002, 3.00003])
  321:         y = np.array([1.00002, 2.00003, 3.00004])
  322:         err_msg = 'There is a mismatch'
  323: 
  324:         a = build_err_msg([x, y], err_msg, verbose=False)
  325:         b = '\nItems are not equal: There is a mismatch'
  326:         assert_equal(a, b)
  327: 
  328:     def test_build_err_msg_custom_names(self):
  329:         x = np.array([1.00001, 2.00002, 3.00003])
  330:         y = np.array([1.00002, 2.00003, 3.00004])
  331:         err_msg = 'There is a mismatch'
  332: 
  333:         a = build_err_msg([x, y], err_msg, names=('FOO', 'BAR'))
  334:         b = ('\nItems are not equal: There is a mismatch\n FOO: array(['
  335:              '1.00001, 2.00002, 3.00003])\n BAR: array([1.00002, 2.00003, '
  336:              '3.00004])')
  337:         assert_equal(a, b)
  338: 
  339:     def test_build_err_msg_custom_precision(self):
  340:         x = np.array([1.000000001, 2.00002, 3.00003])
  341:         y = np.array([1.000000002, 2.00003, 3.00004])
  342:         err_msg = 'There is a mismatch'
  343: 
  344:         a = build_err_msg([x, y], err_msg, precision=10)
  345:         b = ('\nItems are not equal: There is a mismatch\n ACTUAL: array(['
  346:              '1.000000001, 2.00002    , 3.00003    ])\n DESIRED: array(['
  347:              '1.000000002, 2.00003    , 3.00004    ])')
  348:         assert_equal(a, b)
  349: 
  350: 
  351: class TestEqual(TestArrayEqual):
  352: 
  353:     def setup_method(self):
  354:         self._assert_func = assert_equal
  355: 
  356:     def test_nan_items(self):
  357:         self._assert_func(np.nan, np.nan)
  358:         self._assert_func([np.nan], [np.nan])
  359:         self._test_not_equal(np.nan, [np.nan])
  360:         self._test_not_equal(np.nan, 1)
  361: 
  362:     def test_inf_items(self):
  363:         self._assert_func(np.inf, np.inf)
  364:         self._assert_func([np.inf], [np.inf])
  365:         self._test_not_equal(np.inf, [np.inf])
  366: 
  367:     def test_datetime(self):
  368:         self._test_equal(
  369:             np.datetime64("2017-01-01", "s"),
  370:             np.datetime64("2017-01-01", "s")
  371:         )
  372:         self._test_equal(
  373:             np.datetime64("2017-01-01", "s"),
  374:             np.datetime64("2017-01-01", "m")
  375:         )
  376: 
  377:         # gh-10081
  378:         self._test_not_equal(
  379:             np.datetime64("2017-01-01", "s"),
  380:             np.datetime64("2017-01-02", "s")
  381:         )
  382:         self._test_not_equal(
  383:             np.datetime64("2017-01-01", "s"),
  384:             np.datetime64("2017-01-02", "m")
  385:         )
  386: 
  387:     def test_nat_items(self):
  388:         # not a datetime
  389:         nadt_no_unit = np.datetime64("NaT")
  390:         nadt_s = np.datetime64("NaT", "s")
  391:         nadt_d = np.datetime64("NaT", "ns")
  392:         # not a timedelta
  393:         natd_no_unit = np.timedelta64("NaT")
  394:         natd_s = np.timedelta64("NaT", "s")
  395:         natd_d = np.timedelta64("NaT", "ns")
  396: 
  397:         dts = [nadt_no_unit, nadt_s, nadt_d]
  398:         tds = [natd_no_unit, natd_s, natd_d]
  399:         for a, b in itertools.product(dts, dts):
  400:             self._assert_func(a, b)
  401:             self._assert_func([a], [b])
  402:             self._test_not_equal([a], b)
  403: 
  404:         for a, b in itertools.product(tds, tds):
  405:             self._assert_func(a, b)
  406:             self._assert_func([a], [b])
  407:             self._test_not_equal([a], b)
  408: 
  409:         for a, b in itertools.product(tds, dts):
  410:             self._test_not_equal(a, b)
  411:             self._test_not_equal(a, [b])
  412:             self._test_not_equal([a], [b])
  413:             self._test_not_equal([a], np.datetime64("2017-01-01", "s"))
  414:             self._test_not_equal([b], np.datetime64("2017-01-01", "s"))
  415:             self._test_not_equal([a], np.timedelta64(123, "s"))
  416:             self._test_not_equal([b], np.timedelta64(123, "s"))
  417: 
  418:     def test_non_numeric(self):
  419:         self._assert_func('ab', 'ab')
  420:         self._test_not_equal('ab', 'abb')
  421: 
  422:     def test_complex_item(self):
  423:         self._assert_func(complex(1, 2), complex(1, 2))
  424:         self._assert_func(complex(1, np.nan), complex(1, np.nan))
  425:         self._test_not_equal(complex(1, np.nan), complex(1, 2))
  426:         self._test_not_equal(complex(np.nan, 1), complex(1, np.nan))
  427:         self._test_not_equal(complex(np.nan, np.inf), complex(np.nan, 2))
  428: 
  429:     def test_negative_zero(self):
  430:         self._test_not_equal(ncu.PZERO, ncu.NZERO)
  431: 
  432:     def test_complex(self):
  433:         x = np.array([complex(1, 2), complex(1, np.nan)])
  434:         y = np.array([complex(1, 2), complex(1, 2)])
  435:         self._assert_func(x, x)
  436:         self._test_not_equal(x, y)
  437: 
  438:     def test_object(self):
  439:         # gh-12942
  440:         import datetime
  441:         a = np.array([datetime.datetime(2000, 1, 1),
  442:                       datetime.datetime(2000, 1, 2)])
  443:         self._test_not_equal(a, a[::-1])
  444: 
  445: 
  446: class TestArrayAlmostEqual(_GenericTest):
  447: 
  448:     def setup_method(self):
  449:         self._assert_func = assert_array_almost_equal
  450: 
  451:     def test_closeness(self):
  452:         # Note that in the course of time we ended up with
  453:         #     `abs(x - y) < 1.5 * 10**(-decimal)`
  454:         # instead of the previously documented
  455:         #     `abs(x - y) < 0.5 * 10**(-decimal)`
  456:         # so this check serves to preserve the wrongness.
  457: 
  458:         # test scalars
  459:         expected_msg = ('Mismatched elements: 1 / 1 (100%)\n'
  460:                         'Max absolute difference among violations: 1.5\n'
  461:                         'Max relative difference among violations: inf')
  462:         with pytest.raises(AssertionError, match=re.escape(expected_msg)):
  463:             self._assert_func(1.5, 0.0, decimal=0)
  464: 
  465:         # test arrays
  466:         self._assert_func([1.499999], [0.0], decimal=0)
  467: 
  468:         expected_msg = ('Mismatched elements: 1 / 1 (100%)\n'
  469:                         'Max absolute difference among violations: 1.5\n'
  470:                         'Max relative difference among violations: inf')
  471:         with pytest.raises(AssertionError, match=re.escape(expected_msg)):
  472:             self._assert_func([1.5], [0.0], decimal=0)
  473: 
  474:         a = [1.4999999, 0.00003]
  475:         b = [1.49999991, 0]
  476:         expected_msg = ('Mismatched elements: 1 / 2 (50%)\n'
  477:                         'Max absolute difference among violations: 3.e-05\n'
  478:                         'Max relative difference among violations: inf')
  479:         with pytest.raises(AssertionError, match=re.escape(expected_msg)):
  480:             self._assert_func(a, b, decimal=7)
  481: 
  482:         expected_msg = ('Mismatched elements: 1 / 2 (50%)\n'
  483:                         'Max absolute difference among violations: 3.e-05\n'
  484:                         'Max relative difference among violations: 1.')
  485:         with pytest.raises(AssertionError, match=re.escape(expected_msg)):
  486:             self._assert_func(b, a, decimal=7)
  487: 
  488:     def test_simple(self):
  489:         x = np.array([1234.2222])
  490:         y = np.array([1234.2223])
  491: 
  492:         self._assert_func(x, y, decimal=3)
  493:         self._assert_func(x, y, decimal=4)
  494: 
  495:         expected_msg = ('Mismatched elements: 1 / 1 (100%)\n'
  496:                         'Max absolute difference among violations: '
  497:                         '1.e-04\n'
  498:                         'Max relative difference among violations: '
  499:                         '8.10226812e-08')
  500:         with pytest.raises(AssertionError, match=re.escape(expected_msg)):
  501:             self._assert_func(x, y, decimal=5)
  502: 
  503:     def test_array_vs_scalar(self):
  504:         a = [5498.42354, 849.54345, 0.00]
  505:         b = 5498.42354
  506:         expected_msg = ('Mismatched elements: 2 / 3 (66.7%)\n'
  507:                         'Max absolute difference among violations: '
  508:                         '5498.42354\n'
  509:                         'Max relative difference among violations: 1.')
  510:         with pytest.raises(AssertionError, match=re.escape(expected_msg)):
  511:             self._assert_func(a, b, decimal=9)
  512: 
  513:         expected_msg = ('Mismatched elements: 2 / 3 (66.7%)\n'
  514:                         'Max absolute difference among violations: '
  515:                         '5498.42354\n'
  516:                         'Max relative difference among violations: 5.4722099')
  517:         with pytest.raises(AssertionError, match=re.escape(expected_msg)):
  518:             self._assert_func(b, a, decimal=9)
  519: 
  520:         a = [5498.42354, 0.00]
  521:         expected_msg = ('Mismatched elements: 1 / 2 (50%)\n'
  522:                         'Max absolute difference among violations: '
  523:                         '5498.42354\n'
  524:                         'Max relative difference among violations: inf')
  525:         with pytest.raises(AssertionError, match=re.escape(expected_msg)):
  526:             self._assert_func(b, a, decimal=7)
  527: 
  528:         b = 0
  529:         expected_msg = ('Mismatched elements: 1 / 2 (50%)\n'
  530:                         'Max absolute difference among violations: '
  531:                         '5498.42354\n'
  532:                         'Max relative difference among violations: inf')
  533:         with pytest.raises(AssertionError, match=re.escape(expected_msg)):
  534:             self._assert_func(a, b, decimal=7)
  535: 
  536:     def test_nan(self):
  537:         anan = np.array([np.nan])
  538:         aone = np.array([1])
  539:         ainf = np.array([np.inf])
  540:         self._assert_func(anan, anan)
  541:         assert_raises(AssertionError,
  542:                       lambda: self._assert_func(anan, aone))
  543:         assert_raises(AssertionError,
  544:                       lambda: self._assert_func(anan, ainf))
  545:         assert_raises(AssertionError,
  546:                       lambda: self._assert_func(ainf, anan))
  547: 
  548:     def test_inf(self):
  549:         a = np.array([[1., 2.], [3., 4.]])
  550:         b = a.copy()
  551:         a[0, 0] = np.inf
  552:         assert_raises(AssertionError,
  553:                       lambda: self._assert_func(a, b))
  554:         b[0, 0] = -np.inf
  555:         assert_raises(AssertionError,
  556:                       lambda: self._assert_func(a, b))
  557: 
  558:     def test_subclass(self):
  559:         a = np.array([[1., 2.], [3., 4.]])
  560:         b = np.ma.masked_array([[1., 2.], [0., 4.]],
  561:                                [[False, False], [True, False]])
  562:         self._assert_func(a, b)
  563:         self._assert_func(b, a)
  564:         self._assert_func(b, b)
  565: 
  566:         # Test fully masked as well (see gh-11123).
  567:         a = np.ma.MaskedArray(3.5, mask=True)
  568:         b = np.array([3., 4., 6.5])
  569:         self._test_equal(a, b)
  570:         self._test_equal(b, a)
  571:         a = np.ma.masked
  572:         b = np.array([3., 4., 6.5])
  573:         self._test_equal(a, b)
  574:         self._test_equal(b, a)
  575:         a = np.ma.MaskedArray([3., 4., 6.5], mask=[True, True, True])
  576:         b = np.array([1., 2., 3.])
  577:         self._test_equal(a, b)
  578:         self._test_equal(b, a)
  579:         a = np.ma.MaskedArray([3., 4., 6.5], mask=[True, True, True])
  580:         b = np.array(1.)
  581:         self._test_equal(a, b)
  582:         self._test_equal(b, a)
  583: 
  584:     def test_subclass_2(self):
  585:         # While we cannot guarantee testing functions will always work for
  586:         # subclasses, the tests should ideally rely only on subclasses having
  587:         # comparison operators, not on them being able to store booleans
  588:         # (which, e.g., astropy Quantity cannot usefully do). See gh-8452.
  589:         class MyArray(np.ndarray):
  590:             def __eq__(self, other):
  591:                 return super().__eq__(other).view(np.ndarray)
  592: 
  593:             def __lt__(self, other):
  594:                 return super().__lt__(other).view(np.ndarray)
  595: 
  596:             def all(self, *args, **kwargs):
  597:                 return all(self)
  598: 
  599:         a = np.array([1., 2.]).view(MyArray)
  600:         self._assert_func(a, a)
  601: 
  602:         z = np.array([True, True]).view(MyArray)
  603:         all(z)
  604:         b = np.array([1., 202]).view(MyArray)
  605:         expected_msg = ('Mismatched elements: 1 / 2 (50%)\n'
  606:                         'Max absolute difference among violations: 200.\n'
  607:                         'Max relative difference among violations: 0.99009')
  608:         with pytest.raises(AssertionError, match=re.escape(expected_msg)):
  609:             self._assert_func(a, b)
  610: 
  611:     def test_subclass_that_cannot_be_bool(self):
  612:         # While we cannot guarantee testing functions will always work for
  613:         # subclasses, the tests should ideally rely only on subclasses having
  614:         # comparison operators, not on them being able to store booleans
  615:         # (which, e.g., astropy Quantity cannot usefully do). See gh-8452.
  616:         class MyArray(np.ndarray):
  617:             def __eq__(self, other):
  618:                 return super().__eq__(other).view(np.ndarray)
  619: 
  620:             def __lt__(self, other):
  621:                 return super().__lt__(other).view(np.ndarray)
  622: 
  623:             def all(self, *args, **kwargs):
  624:                 raise NotImplementedError
  625: 
  626:         a = np.array([1., 2.]).view(MyArray)
  627:         self._assert_func(a, a)
  628: 
  629: 
  630: class TestAlmostEqual(_GenericTest):
  631: 
  632:     def setup_method(self):
  633:         self._assert_func = assert_almost_equal
  634: 
  635:     def test_closeness(self):
  636:         # Note that in the course of time we ended up with
  637:         #     `abs(x - y) < 1.5 * 10**(-decimal)`
  638:         # instead of the previously documented
  639:         #     `abs(x - y) < 0.5 * 10**(-decimal)`
  640:         # so this check serves to preserve the wrongness.
  641: 
  642:         # test scalars
  643:         self._assert_func(1.499999, 0.0, decimal=0)
  644:         assert_raises(AssertionError,
  645:                       lambda: self._assert_func(1.5, 0.0, decimal=0))
  646: 
  647:         # test arrays
  648:         self._assert_func([1.499999], [0.0], decimal=0)
  649:         assert_raises(AssertionError,
  650:                       lambda: self._assert_func([1.5], [0.0], decimal=0))
  651: 
  652:     def test_nan_item(self):
  653:         self._assert_func(np.nan, np.nan)
  654:         assert_raises(AssertionError,
  655:                       lambda: self._assert_func(np.nan, 1))
  656:         assert_raises(AssertionError,
  657:                       lambda: self._assert_func(np.nan, np.inf))
  658:         assert_raises(AssertionError,
  659:                       lambda: self._assert_func(np.inf, np.nan))
  660: 
  661:     def test_inf_item(self):
  662:         self._assert_func(np.inf, np.inf)
  663:         self._assert_func(-np.inf, -np.inf)
  664:         assert_raises(AssertionError,
  665:                       lambda: self._assert_func(np.inf, 1))
  666:         assert_raises(AssertionError,
  667:                       lambda: self._assert_func(-np.inf, np.inf))
  668: 
  669:     def test_simple_item(self):
  670:         self._test_not_equal(1, 2)
  671: 
  672:     def test_complex_item(self):
  673:         self._assert_func(complex(1, 2), complex(1, 2))
  674:         self._assert_func(complex(1, np.nan), complex(1, np.nan))
  675:         self._assert_func(complex(np.inf, np.nan), complex(np.inf, np.nan))
  676:         self._test_not_equal(complex(1, np.nan), complex(1, 2))
  677:         self._test_not_equal(complex(np.nan, 1), complex(1, np.nan))
  678:         self._test_not_equal(complex(np.nan, np.inf), complex(np.nan, 2))
  679: 
  680:     def test_complex(self):
  681:         x = np.array([complex(1, 2), complex(1, np.nan)])
  682:         z = np.array([complex(1, 2), complex(np.nan, 1)])
  683:         y = np.array([complex(1, 2), complex(1, 2)])
  684:         self._assert_func(x, x)
  685:         self._test_not_equal(x, y)
  686:         self._test_not_equal(x, z)
  687: 
  688:     def test_error_message(self):
  689:         """Check the message is formatted correctly for the decimal value.
  690:            Also check the message when input includes inf or nan (gh12200)"""
  691:         x = np.array([1.00000000001, 2.00000000002, 3.00003])
  692:         y = np.array([1.00000000002, 2.00000000003, 3.00004])
  693: 
  694:         # Test with a different amount of decimal digits
  695:         expected_msg = ('Mismatched elements: 3 / 3 (100%)\n'
  696:                         'Max absolute difference among violations: 1.e-05\n'
  697:                         'Max relative difference among violations: '
  698:                         '3.33328889e-06\n'
  699:                         ' ACTUAL: array([1.00000000001, '
  700:                         '2.00000000002, '
  701:                         '3.00003      ])\n'
  702:                         ' DESIRED: array([1.00000000002, 2.00000000003, '
  703:                         '3.00004      ])')
  704:         with pytest.raises(AssertionError, match=re.escape(expected_msg)):
  705:             self._assert_func(x, y, decimal=12)
  706: 
  707:         # With the default value of decimal digits, only the 3rd element
  708:         # differs. Note that we only check for the formatting of the arrays
  709:         # themselves.
  710:         expected_msg = ('Mismatched elements: 1 / 3 (33.3%)\n'
  711:                         'Max absolute difference among violations: 1.e-05\n'
  712:                         'Max relative difference among violations: '
  713:                         '3.33328889e-06\n'
  714:                         ' ACTUAL: array([1.     , 2.     , 3.00003])\n'
  715:                         ' DESIRED: array([1.     , 2.     , 3.00004])')
  716:         with pytest.raises(AssertionError, match=re.escape(expected_msg)):
  717:             self._assert_func(x, y)
  718: 
  719:         # Check the error message when input includes inf
  720:         x = np.array([np.inf, 0])
  721:         y = np.array([np.inf, 1])
  722:         expected_msg = ('Mismatched elements: 1 / 2 (50%)\n'
  723:                         'Max absolute difference among violations: 1.\n'
  724:                         'Max relative difference among violations: 1.\n'
  725:                         ' ACTUAL: array([inf,  0.])\n'
  726:                         ' DESIRED: array([inf,  1.])')
  727:         with pytest.raises(AssertionError, match=re.escape(expected_msg)):
  728:             self._assert_func(x, y)
  729: 
  730:         # Check the error message when dividing by zero
  731:         x = np.array([1, 2])
  732:         y = np.array([0, 0])
  733:         expected_msg = ('Mismatched elements: 2 / 2 (100%)\n'
  734:                         'Max absolute difference among violations: 2\n'
  735:                         'Max relative difference among violations: inf')
  736:         with pytest.raises(AssertionError, match=re.escape(expected_msg)):
  737:             self._assert_func(x, y)
  738: 
  739:     def test_error_message_2(self):
  740:         """Check the message is formatted correctly """
  741:         """when either x or y is a scalar."""
  742:         x = 2
  743:         y = np.ones(20)
  744:         expected_msg = ('Mismatched elements: 20 / 20 (100%)\n'
  745:                         'Max absolute difference among violations: 1.\n'
  746:                         'Max relative difference among violations: 1.')
  747:         with pytest.raises(AssertionError, match=re.escape(expected_msg)):
  748:             self._assert_func(x, y)
  749: 
  750:         y = 2
  751:         x = np.ones(20)
  752:         expected_msg = ('Mismatched elements: 20 / 20 (100%)\n'
  753:                         'Max absolute difference among violations: 1.\n'
  754:                         'Max relative difference among violations: 0.5')
  755:         with pytest.raises(AssertionError, match=re.escape(expected_msg)):
  756:             self._assert_func(x, y)
  757: 
  758:     def test_subclass_that_cannot_be_bool(self):
  759:         # While we cannot guarantee testing functions will always work for
  760:         # subclasses, the tests should ideally rely only on subclasses having
  761:         # comparison operators, not on them being able to store booleans
  762:         # (which, e.g., astropy Quantity cannot usefully do). See gh-8452.
  763:         class MyArray(np.ndarray):
  764:             def __eq__(self, other):
  765:                 return super().__eq__(other).view(np.ndarray)
  766: 
  767:             def __lt__(self, other):
  768:                 return super().__lt__(other).view(np.ndarray)
  769: 
  770:             def all(self, *args, **kwargs):
  771:                 raise NotImplementedError
  772: 
  773:         a = np.array([1., 2.]).view(MyArray)
  774:         self._assert_func(a, a)
  775: 
  776: 
  777: class TestApproxEqual:
  778: 
  779:     def setup_method(self):
  780:         self._assert_func = assert_approx_equal
  781: 
  782:     def test_simple_0d_arrays(self):
  783:         x = np.array(1234.22)
  784:         y = np.array(1234.23)
  785: 
  786:         self._assert_func(x, y, significant=5)
  787:         self._assert_func(x, y, significant=6)
  788:         assert_raises(AssertionError,
  789:                       lambda: self._assert_func(x, y, significant=7))
  790: 
  791:     def test_simple_items(self):
  792:         x = 1234.22
  793:         y = 1234.23
  794: 
  795:         self._assert_func(x, y, significant=4)
  796:         self._assert_func(x, y, significant=5)
  797:         self._assert_func(x, y, significant=6)
  798:         assert_raises(AssertionError,
  799:                       lambda: self._assert_func(x, y, significant=7))
  800: 
  801:     def test_nan_array(self):
  802:         anan = np.array(np.nan)
  803:         aone = np.array(1)
  804:         ainf = np.array(np.inf)
  805:         self._assert_func(anan, anan)
  806:         assert_raises(AssertionError, lambda: self._assert_func(anan, aone))
  807:         assert_raises(AssertionError, lambda: self._assert_func(anan, ainf))
  808:         assert_raises(AssertionError, lambda: self._assert_func(ainf, anan))
  809: 
  810:     def test_nan_items(self):
  811:         anan = np.array(np.nan)
  812:         aone = np.array(1)
  813:         ainf = np.array(np.inf)
  814:         self._assert_func(anan, anan)
  815:         assert_raises(AssertionError, lambda: self._assert_func(anan, aone))
  816:         assert_raises(AssertionError, lambda: self._assert_func(anan, ainf))
  817:         assert_raises(AssertionError, lambda: self._assert_func(ainf, anan))
  818: 
  819: 
  820: class TestArrayAssertLess:
  821: 
  822:     def setup_method(self):
  823:         self._assert_func = assert_array_less
  824: 
  825:     def test_simple_arrays(self):
  826:         x = np.array([1.1, 2.2])
  827:         y = np.array([1.2, 2.3])
  828: 
  829:         self._assert_func(x, y)
  830:         assert_raises(AssertionError, lambda: self._assert_func(y, x))
  831: 
  832:         y = np.array([1.0, 2.3])
  833: 
  834:         assert_raises(AssertionError, lambda: self._assert_func(x, y))
  835:         assert_raises(AssertionError, lambda: self._assert_func(y, x))
  836: 
  837:         a = np.array([1, 3, 6, 20])
  838:         b = np.array([2, 4, 6, 8])
  839: 
  840:         expected_msg = ('Mismatched elements: 2 / 4 (50%)\n'
  841:                         'Max absolute difference among violations: 12\n'
  842:                         'Max relative difference among violations: 1.5')
  843:         with pytest.raises(AssertionError, match=re.escape(expected_msg)):
  844:             self._assert_func(a, b)
  845: 
  846:     def test_rank2(self):
  847:         x = np.array([[1.1, 2.2], [3.3, 4.4]])
  848:         y = np.array([[1.2, 2.3], [3.4, 4.5]])
  849: 
  850:         self._assert_func(x, y)
  851:         expected_msg = ('Mismatched elements: 4 / 4 (100%)\n'
  852:                         'Max absolute difference among violations: 0.1\n'
  853:                         'Max relative difference among violations: 0.09090909')
  854:         with pytest.raises(AssertionError, match=re.escape(expected_msg)):
  855:             self._assert_func(y, x)
  856: 
  857:         y = np.array([[1.0, 2.3], [3.4, 4.5]])
  858:         assert_raises(AssertionError, lambda: self._assert_func(x, y))
  859:         assert_raises(AssertionError, lambda: self._assert_func(y, x))
  860: 
  861:     def test_rank3(self):
  862:         x = np.ones(shape=(2, 2, 2))
  863:         y = np.ones(shape=(2, 2, 2)) + 1
  864: 
  865:         self._assert_func(x, y)
  866:         assert_raises(AssertionError, lambda: self._assert_func(y, x))
  867: 
  868:         y[0, 0, 0] = 0
  869:         expected_msg = ('Mismatched elements: 1 / 8 (12.5%)\n'
  870:                         'Max absolute difference among violations: 1.\n'
  871:                         'Max relative difference among violations: inf')
  872:         with pytest.raises(AssertionError, match=re.escape(expected_msg)):
  873:             self._assert_func(x, y)
  874: 
  875:         assert_raises(AssertionError, lambda: self._assert_func(y, x))
  876: 
  877:     def test_simple_items(self):
  878:         x = 1.1
  879:         y = 2.2
  880: 
  881:         self._assert_func(x, y)
  882:         expected_msg = ('Mismatched elements: 1 / 1 (100%)\n'
  883:                         'Max absolute difference among violations: 1.1\n'
  884:                         'Max relative difference among violations: 1.')
  885:         with pytest.raises(AssertionError, match=re.escape(expected_msg)):
  886:             self._assert_func(y, x)
  887: 
  888:         y = np.array([2.2, 3.3])
  889: 
  890:         self._assert_func(x, y)
  891:         assert_raises(AssertionError, lambda: self._assert_func(y, x))
  892: 
  893:         y = np.array([1.0, 3.3])
  894: 
  895:         assert_raises(AssertionError, lambda: self._assert_func(x, y))
  896: 
  897:     def test_simple_items_and_array(self):
  898:         x = np.array([[621.345454, 390.5436, 43.54657, 626.4535],
  899:                       [54.54, 627.3399, 13., 405.5435],
  900:                       [543.545, 8.34, 91.543, 333.3]])
  901:         y = 627.34
  902:         self._assert_func(x, y)
  903: 
  904:         y = 8.339999
  905:         self._assert_func(y, x)
  906: 
  907:         x = np.array([[3.4536, 2390.5436, 435.54657, 324525.4535],
  908:                       [5449.54, 999090.54, 130303.54, 405.5435],
  909:                       [543.545, 8.34, 91.543, 999090.53999]])
  910:         y = 999090.54
  911: 
  912:         expected_msg = ('Mismatched elements: 1 / 12 (8.33%)\n'
  913:                         'Max absolute difference among violations: 0.\n'
  914:                         'Max relative difference among violations: 0.')
  915:         with pytest.raises(AssertionError, match=re.escape(expected_msg)):
  916:             self._assert_func(x, y)
  917: 
  918:         expected_msg = ('Mismatched elements: 12 / 12 (100%)\n'
  919:                         'Max absolute difference among violations: '
  920:                         '999087.0864\n'
  921:                         'Max relative difference among violations: '
  922:                         '289288.5934676')
  923:         with pytest.raises(AssertionError, match=re.escape(expected_msg)):
  924:             self._assert_func(y, x)
  925: 
  926:     def test_zeroes(self):
  927:         x = np.array([546456., 0, 15.455])
  928:         y = np.array(87654.)
  929: 
  930:         expected_msg = ('Mismatched elements: 1 / 3 (33.3%)\n'
  931:                         'Max absolute difference among violations: 458802.\n'
  932:                         'Max relative difference among violations: 5.23423917')
  933:         with pytest.raises(AssertionError, match=re.escape(expected_msg)):
  934:             self._assert_func(x, y)
  935: 
  936:         expected_msg = ('Mismatched elements: 2 / 3 (66.7%)\n'
  937:                         'Max absolute difference among violations: 87654.\n'
  938:                         'Max relative difference among violations: '
  939:                         '5670.5626011')
  940:         with pytest.raises(AssertionError, match=re.escape(expected_msg)):
  941:             self._assert_func(y, x)
  942: 
  943:         y = 0
  944: 
  945:         expected_msg = ('Mismatched elements: 3 / 3 (100%)\n'
  946:                         'Max absolute difference among violations: 546456.\n'
  947:                         'Max relative difference among violations: inf')
  948:         with pytest.raises(AssertionError, match=re.escape(expected_msg)):
  949:             self._assert_func(x, y)
  950: 
  951:         expected_msg = ('Mismatched elements: 1 / 3 (33.3%)\n'
  952:                         'Max absolute difference among violations: 0.\n'
  953:                         'Max relative difference among violations: inf')
  954:         with pytest.raises(AssertionError, match=re.escape(expected_msg)):
  955:             self._assert_func(y, x)
  956: 
  957:     def test_nan_noncompare(self):
  958:         anan = np.array(np.nan)
  959:         aone = np.array(1)
  960:         ainf = np.array(np.inf)
  961:         self._assert_func(anan, anan)
  962:         assert_raises(AssertionError, lambda: self._assert_func(aone, anan))
  963:         assert_raises(AssertionError, lambda: self._assert_func(anan, aone))
  964:         assert_raises(AssertionError, lambda: self._assert_func(anan, ainf))
  965:         assert_raises(AssertionError, lambda: self._assert_func(ainf, anan))
  966: 
  967:     def test_nan_noncompare_array(self):
  968:         x = np.array([1.1, 2.2, 3.3])
  969:         anan = np.array(np.nan)
  970: 
  971:         assert_raises(AssertionError, lambda: self._assert_func(x, anan))
  972:         assert_raises(AssertionError, lambda: self._assert_func(anan, x))
  973: 
  974:         x = np.array([1.1, 2.2, np.nan])
  975: 
  976:         assert_raises(AssertionError, lambda: self._assert_func(x, anan))
  977:         assert_raises(AssertionError, lambda: self._assert_func(anan, x))
  978: 
  979:         y = np.array([1.0, 2.0, np.nan])
  980: 
  981:         self._assert_func(y, x)
  982:         assert_raises(AssertionError, lambda: self._assert_func(x, y))
  983: 
  984:     def test_inf_compare(self):
  985:         aone = np.array(1)
  986:         ainf = np.array(np.inf)
  987: 
  988:         self._assert_func(aone, ainf)
  989:         self._assert_func(-ainf, aone)
  990:         self._assert_func(-ainf, ainf)
  991:         assert_raises(AssertionError, lambda: self._assert_func(ainf, aone))
  992:         assert_raises(AssertionError, lambda: self._assert_func(aone, -ainf))
  993:         assert_raises(AssertionError, lambda: self._assert_func(ainf, ainf))
  994:         assert_raises(AssertionError, lambda: self._assert_func(ainf, -ainf))
  995:         assert_raises(AssertionError, lambda: self._assert_func(-ainf, -ainf))
  996: 
  997:     def test_inf_compare_array(self):
  998:         x = np.array([1.1, 2.2, np.inf])
  999:         ainf = np.array(np.inf)
 1000: 
 1001:         assert_raises(AssertionError, lambda: self._assert_func(x, ainf))
 1002:         assert_raises(AssertionError, lambda: self._assert_func(ainf, x))
 1003:         assert_raises(AssertionError, lambda: self._assert_func(x, -ainf))
 1004:         assert_raises(AssertionError, lambda: self._assert_func(-x, -ainf))
 1005:         assert_raises(AssertionError, lambda: self._assert_func(-ainf, -x))
 1006:         self._assert_func(-ainf, x)
 1007: 
 1008:     def test_strict(self):
 1009:         """Test the behavior of the `strict` option."""
 1010:         x = np.zeros(3)
 1011:         y = np.ones(())
 1012:         self._assert_func(x, y)
 1013:         with pytest.raises(AssertionError):
 1014:             self._assert_func(x, y, strict=True)
 1015:         y = np.broadcast_to(y, x.shape)
 1016:         self._assert_func(x, y)
 1017:         with pytest.raises(AssertionError):
 1018:             self._assert_func(x, y.astype(np.float32), strict=True)
 1019: 
 1020: 
 1021: class TestWarns:
 1022: 
 1023:     def test_warn(self):
 1024:         def f():
 1025:             warnings.warn("yo")
 1026:             return 3
 1027: 
 1028:         before_filters = sys.modules['warnings'].filters[:]
 1029:         assert_equal(assert_warns(UserWarning, f), 3)
 1030:         after_filters = sys.modules['warnings'].filters
 1031: 
 1032:         assert_raises(AssertionError, assert_no_warnings, f)
 1033:         assert_equal(assert_no_warnings(lambda x: x, 1), 1)
 1034: 
 1035:         # Check that the warnings state is unchanged
 1036:         assert_equal(before_filters, after_filters,
 1037:                      "assert_warns does not preserver warnings state")
 1038: 
 1039:     def test_context_manager(self):
 1040: 
 1041:         before_filters = sys.modules['warnings'].filters[:]
 1042:         with assert_warns(UserWarning):
 1043:             warnings.warn("yo")
 1044:         after_filters = sys.modules['warnings'].filters
 1045: 
 1046:         def no_warnings():
 1047:             with assert_no_warnings():
 1048:                 warnings.warn("yo")
 1049: 
 1050:         assert_raises(AssertionError, no_warnings)
 1051:         assert_equal(before_filters, after_filters,
 1052:                      "assert_warns does not preserver warnings state")
 1053: 
 1054:     def test_args(self):
 1055:         def f(a=0, b=1):
 1056:             warnings.warn("yo")
 1057:             return a + b
 1058: 
 1059:         assert assert_warns(UserWarning, f, b=20) == 20
 1060: 
 1061:         with pytest.raises(RuntimeError) as exc:
 1062:             # assert_warns cannot do regexp matching, use pytest.warns
 1063:             with assert_warns(UserWarning, match="A"):
 1064:                 warnings.warn("B", UserWarning)
 1065:         assert "assert_warns" in str(exc)
 1066:         assert "pytest.warns" in str(exc)
 1067: 
 1068:         with pytest.raises(RuntimeError) as exc:
 1069:             # assert_warns cannot do regexp matching, use pytest.warns
 1070:             with assert_warns(UserWarning, wrong="A"):
 1071:                 warnings.warn("B", UserWarning)
 1072:         assert "assert_warns" in str(exc)
 1073:         assert "pytest.warns" not in str(exc)
 1074: 
 1075:     def test_warn_wrong_warning(self):
 1076:         def f():
 1077:             warnings.warn("yo", DeprecationWarning)
 1078: 
 1079:         failed = False
 1080:         with warnings.catch_warnings():
 1081:             warnings.simplefilter("error", DeprecationWarning)
 1082:             try:
 1083:                 # Should raise a DeprecationWarning
 1084:                 assert_warns(UserWarning, f)
 1085:                 failed = True
 1086:             except DeprecationWarning:
 1087:                 pass
 1088: 
 1089:         if failed:
 1090:             raise AssertionError("wrong warning caught by assert_warn")
 1091: 
 1092: 
 1093: class TestAssertAllclose:
 1094: 
 1095:     def test_simple(self):
 1096:         x = 1e-3
 1097:         y = 1e-9
 1098: 
 1099:         assert_allclose(x, y, atol=1)
 1100:         assert_raises(AssertionError, assert_allclose, x, y)
 1101: 
 1102:         expected_msg = ('Mismatched elements: 1 / 1 (100%)\n'
 1103:                         'Max absolute difference among violations: 0.001\n'
 1104:                         'Max relative difference among violations: 999999.')
 1105:         with pytest.raises(AssertionError, match=re.escape(expected_msg)):
 1106:             assert_allclose(x, y)
 1107: 
 1108:         z = 0
 1109:         expected_msg = ('Mismatched elements: 1 / 1 (100%)\n'
 1110:                         'Max absolute difference among violations: 1.e-09\n'
 1111:                         'Max relative difference among violations: inf')
 1112:         with pytest.raises(AssertionError, match=re.escape(expected_msg)):
 1113:             assert_allclose(y, z)
 1114: 
 1115:         expected_msg = ('Mismatched elements: 1 / 1 (100%)\n'
 1116:                         'Max absolute difference among violations: 1.e-09\n'
 1117:                         'Max relative difference among violations: 1.')
 1118:         with pytest.raises(AssertionError, match=re.escape(expected_msg)):
 1119:             assert_allclose(z, y)
 1120: 
 1121:         a = np.array([x, y, x, y])
 1122:         b = np.array([x, y, x, x])
 1123: 
 1124:         assert_allclose(a, b, atol=1)
 1125:         assert_raises(AssertionError, assert_allclose, a, b)
 1126: 
 1127:         b[-1] = y * (1 + 1e-8)
 1128:         assert_allclose(a, b)
 1129:         assert_raises(AssertionError, assert_allclose, a, b, rtol=1e-9)
 1130: 
 1131:         assert_allclose(6, 10, rtol=0.5)
 1132:         assert_raises(AssertionError, assert_allclose, 10, 6, rtol=0.5)
 1133: 
 1134:         b = np.array([x, y, x, x])
 1135:         c = np.array([x, y, x, z])
 1136:         expected_msg = ('Mismatched elements: 1 / 4 (25%)\n'
 1137:                         'Max absolute difference among violations: 0.001\n'
 1138:                         'Max relative difference among violations: inf')
 1139:         with pytest.raises(AssertionError, match=re.escape(expected_msg)):
 1140:             assert_allclose(b, c)
 1141: 
 1142:         expected_msg = ('Mismatched elements: 1 / 4 (25%)\n'
 1143:                         'Max absolute difference among violations: 0.001\n'
 1144:                         'Max relative difference among violations: 1.')
 1145:         with pytest.raises(AssertionError, match=re.escape(expected_msg)):
 1146:             assert_allclose(c, b)
 1147: 
 1148:     def test_min_int(self):
 1149:         a = np.array([np.iinfo(np.int_).min], dtype=np.int_)
 1150:         # Should not raise:
 1151:         assert_allclose(a, a)
 1152: 
 1153:     def test_report_fail_percentage(self):
 1154:         a = np.array([1, 1, 1, 1])
 1155:         b = np.array([1, 1, 1, 2])
 1156: 
 1157:         expected_msg = ('Mismatched elements: 1 / 4 (25%)\n'
 1158:                         'Max absolute difference among violations: 1\n'
 1159:                         'Max relative difference among violations: 0.5')
 1160:         with pytest.raises(AssertionError, match=re.escape(expected_msg)):
 1161:             assert_allclose(a, b)
 1162: 
 1163:     def test_equal_nan(self):
 1164:         a = np.array([np.nan])
 1165:         b = np.array([np.nan])
 1166:         # Should not raise:
 1167:         assert_allclose(a, b, equal_nan=True)
 1168: 
 1169:     def test_not_equal_nan(self):
 1170:         a = np.array([np.nan])
 1171:         b = np.array([np.nan])
 1172:         assert_raises(AssertionError, assert_allclose, a, b, equal_nan=False)
 1173: 
 1174:     def test_equal_nan_default(self):
 1175:         # Make sure equal_nan default behavior remains unchanged. (All
 1176:         # of these functions use assert_array_compare under the hood.)
 1177:         # None of these should raise.
 1178:         a = np.array([np.nan])
 1179:         b = np.array([np.nan])
 1180:         assert_array_equal(a, b)
 1181:         assert_array_almost_equal(a, b)
 1182:         assert_array_less(a, b)
 1183:         assert_allclose(a, b)
 1184: 
 1185:     def test_report_max_relative_error(self):
 1186:         a = np.array([0, 1])
 1187:         b = np.array([0, 2])
 1188: 
 1189:         expected_msg = 'Max relative difference among violations: 0.5'
 1190:         with pytest.raises(AssertionError, match=re.escape(expected_msg)):
 1191:             assert_allclose(a, b)
 1192: 
 1193:     def test_timedelta(self):
 1194:         # see gh-18286
 1195:         a = np.array([[1, 2, 3, "NaT"]], dtype="m8[ns]")
 1196:         assert_allclose(a, a)
 1197: 
 1198:     def test_error_message_unsigned(self):
 1199:         """Check the message is formatted correctly when overflow can occur
 1200:            (gh21768)"""
 1201:         # Ensure to test for potential overflow in the case of:
 1202:         #        x - y
 1203:         # and
 1204:         #        y - x
 1205:         x = np.asarray([0, 1, 8], dtype='uint8')
 1206:         y = np.asarray([4, 4, 4], dtype='uint8')
 1207:         expected_msg = 'Max absolute difference among violations: 4'
 1208:         with pytest.raises(AssertionError, match=re.escape(expected_msg)):
 1209:             assert_allclose(x, y, atol=3)
 1210: 
 1211:     def test_strict(self):
 1212:         """Test the behavior of the `strict` option."""
 1213:         x = np.ones(3)
 1214:         y = np.ones(())
 1215:         assert_allclose(x, y)
 1216:         with pytest.raises(AssertionError):
 1217:             assert_allclose(x, y, strict=True)
 1218:         assert_allclose(x, x)
 1219:         with pytest.raises(AssertionError):
 1220:             assert_allclose(x, x.astype(np.float32), strict=True)
 1221: 
 1222: 
 1223: class TestArrayAlmostEqualNulp:
 1224: 
 1225:     def test_float64_pass(self):
 1226:         # The number of units of least precision
 1227:         # In this case, use a few places above the lowest level (ie nulp=1)
 1228:         nulp = 5
 1229:         x = np.linspace(-20, 20, 50, dtype=np.float64)
 1230:         x = 10**x
 1231:         x = np.r_[-x, x]
 1232: 
 1233:         # Addition
 1234:         eps = np.finfo(x.dtype).eps
 1235:         y = x + x * eps * nulp / 2.
 1236:         assert_array_almost_equal_nulp(x, y, nulp)
 1237: 
 1238:         # Subtraction
 1239:         epsneg = np.finfo(x.dtype).epsneg
 1240:         y = x - x * epsneg * nulp / 2.
 1241:         assert_array_almost_equal_nulp(x, y, nulp)
 1242: 
 1243:     def test_float64_fail(self):
 1244:         nulp = 5
 1245:         x = np.linspace(-20, 20, 50, dtype=np.float64)
 1246:         x = 10**x
 1247:         x = np.r_[-x, x]
 1248: 
 1249:         eps = np.finfo(x.dtype).eps
 1250:         y = x + x * eps * nulp * 2.
 1251:         assert_raises(AssertionError, assert_array_almost_equal_nulp,
 1252:                       x, y, nulp)
 1253: 
 1254:         epsneg = np.finfo(x.dtype).epsneg
 1255:         y = x - x * epsneg * nulp * 2.
 1256:         assert_raises(AssertionError, assert_array_almost_equal_nulp,
 1257:                       x, y, nulp)
 1258: 
 1259:     def test_float64_ignore_nan(self):
 1260:         # Ignore ULP differences between various NAN's
 1261:         # Note that MIPS may reverse quiet and signaling nans
 1262:         # so we use the builtin version as a base.
 1263:         offset = np.uint64(0xffffffff)
 1264:         nan1_i64 = np.array(np.nan, dtype=np.float64).view(np.uint64)
 1265:         nan2_i64 = nan1_i64 ^ offset  # nan payload on MIPS is all ones.
 1266:         nan1_f64 = nan1_i64.view(np.float64)
 1267:         nan2_f64 = nan2_i64.view(np.float64)
 1268:         assert_array_max_ulp(nan1_f64, nan2_f64, 0)
 1269: 
 1270:     def test_float32_pass(self):
 1271:         nulp = 5
 1272:         x = np.linspace(-20, 20, 50, dtype=np.float32)
 1273:         x = 10**x
 1274:         x = np.r_[-x, x]
 1275: 
 1276:         eps = np.finfo(x.dtype).eps
 1277:         y = x + x * eps * nulp / 2.
 1278:         assert_array_almost_equal_nulp(x, y, nulp)
 1279: 
 1280:         epsneg = np.finfo(x.dtype).epsneg
 1281:         y = x - x * epsneg * nulp / 2.
 1282:         assert_array_almost_equal_nulp(x, y, nulp)
 1283: 
 1284:     def test_float32_fail(self):
 1285:         nulp = 5
 1286:         x = np.linspace(-20, 20, 50, dtype=np.float32)
 1287:         x = 10**x
 1288:         x = np.r_[-x, x]
 1289: 
 1290:         eps = np.finfo(x.dtype).eps
 1291:         y = x + x * eps * nulp * 2.
 1292:         assert_raises(AssertionError, assert_array_almost_equal_nulp,
 1293:                       x, y, nulp)
 1294: 
 1295:         epsneg = np.finfo(x.dtype).epsneg
 1296:         y = x - x * epsneg * nulp * 2.
 1297:         assert_raises(AssertionError, assert_array_almost_equal_nulp,
 1298:                       x, y, nulp)
 1299: 
 1300:     def test_float32_ignore_nan(self):
 1301:         # Ignore ULP differences between various NAN's
 1302:         # Note that MIPS may reverse quiet and signaling nans
 1303:         # so we use the builtin version as a base.
 1304:         offset = np.uint32(0xffff)
 1305:         nan1_i32 = np.array(np.nan, dtype=np.float32).view(np.uint32)
 1306:         nan2_i32 = nan1_i32 ^ offset  # nan payload on MIPS is all ones.
 1307:         nan1_f32 = nan1_i32.view(np.float32)
 1308:         nan2_f32 = nan2_i32.view(np.float32)
 1309:         assert_array_max_ulp(nan1_f32, nan2_f32, 0)
 1310: 
 1311:     def test_float16_pass(self):
 1312:         nulp = 5
 1313:         x = np.linspace(-4, 4, 10, dtype=np.float16)
 1314:         x = 10**x
 1315:         x = np.r_[-x, x]
 1316: 
 1317:         eps = np.finfo(x.dtype).eps
 1318:         y = x + x * eps * nulp / 2.
 1319:         assert_array_almost_equal_nulp(x, y, nulp)
 1320: 
 1321:         epsneg = np.finfo(x.dtype).epsneg
 1322:         y = x - x * epsneg * nulp / 2.
 1323:         assert_array_almost_equal_nulp(x, y, nulp)
 1324: 
 1325:     def test_float16_fail(self):
 1326:         nulp = 5
 1327:         x = np.linspace(-4, 4, 10, dtype=np.float16)
 1328:         x = 10**x
 1329:         x = np.r_[-x, x]
 1330: 
 1331:         eps = np.finfo(x.dtype).eps
 1332:         y = x + x * eps * nulp * 2.
 1333:         assert_raises(AssertionError, assert_array_almost_equal_nulp,
 1334:                       x, y, nulp)
 1335: 
 1336:         epsneg = np.finfo(x.dtype).epsneg
 1337:         y = x - x * epsneg * nulp * 2.
 1338:         assert_raises(AssertionError, assert_array_almost_equal_nulp,
 1339:                       x, y, nulp)
 1340: 
 1341:     def test_float16_ignore_nan(self):
 1342:         # Ignore ULP differences between various NAN's
 1343:         # Note that MIPS may reverse quiet and signaling nans
 1344:         # so we use the builtin version as a base.
 1345:         offset = np.uint16(0xff)
 1346:         nan1_i16 = np.array(np.nan, dtype=np.float16).view(np.uint16)
 1347:         nan2_i16 = nan1_i16 ^ offset  # nan payload on MIPS is all ones.
 1348:         nan1_f16 = nan1_i16.view(np.float16)
 1349:         nan2_f16 = nan2_i16.view(np.float16)
 1350:         assert_array_max_ulp(nan1_f16, nan2_f16, 0)
 1351: 
 1352:     def test_complex128_pass(self):
 1353:         nulp = 5
 1354:         x = np.linspace(-20, 20, 50, dtype=np.float64)
 1355:         x = 10**x
 1356:         x = np.r_[-x, x]
 1357:         xi = x + x * 1j
 1358: 
 1359:         eps = np.finfo(x.dtype).eps
 1360:         y = x + x * eps * nulp / 2.
 1361:         assert_array_almost_equal_nulp(xi, x + y * 1j, nulp)
 1362:         assert_array_almost_equal_nulp(xi, y + x * 1j, nulp)
 1363:         # The test condition needs to be at least a factor of sqrt(2) smaller
 1364:         # because the real and imaginary parts both change
 1365:         y = x + x * eps * nulp / 4.
 1366:         assert_array_almost_equal_nulp(xi, y + y * 1j, nulp)
 1367: 
 1368:         epsneg = np.finfo(x.dtype).epsneg
 1369:         y = x - x * epsneg * nulp / 2.
 1370:         assert_array_almost_equal_nulp(xi, x + y * 1j, nulp)
 1371:         assert_array_almost_equal_nulp(xi, y + x * 1j, nulp)
 1372:         y = x - x * epsneg * nulp / 4.
 1373:         assert_array_almost_equal_nulp(xi, y + y * 1j, nulp)
 1374: 
 1375:     def test_complex128_fail(self):
 1376:         nulp = 5
 1377:         x = np.linspace(-20, 20, 50, dtype=np.float64)
 1378:         x = 10**x
 1379:         x = np.r_[-x, x]
 1380:         xi = x + x * 1j
 1381: 
 1382:         eps = np.finfo(x.dtype).eps
 1383:         y = x + x * eps * nulp * 2.
 1384:         assert_raises(AssertionError, assert_array_almost_equal_nulp,
 1385:                       xi, x + y * 1j, nulp)
 1386:         assert_raises(AssertionError, assert_array_almost_equal_nulp,
 1387:                       xi, y + x * 1j, nulp)
 1388:         # The test condition needs to be at least a factor of sqrt(2) smaller
 1389:         # because the real and imaginary parts both change
 1390:         y = x + x * eps * nulp
 1391:         assert_raises(AssertionError, assert_array_almost_equal_nulp,
 1392:                       xi, y + y * 1j, nulp)
 1393: 
 1394:         epsneg = np.finfo(x.dtype).epsneg
 1395:         y = x - x * epsneg * nulp * 2.
 1396:         assert_raises(AssertionError, assert_array_almost_equal_nulp,
 1397:                       xi, x + y * 1j, nulp)
 1398:         assert_raises(AssertionError, assert_array_almost_equal_nulp,
 1399:                       xi, y + x * 1j, nulp)
 1400:         y = x - x * epsneg * nulp
 1401:         assert_raises(AssertionError, assert_array_almost_equal_nulp,
 1402:                       xi, y + y * 1j, nulp)
 1403: 
 1404:     def test_complex64_pass(self):
 1405:         nulp = 5
 1406:         x = np.linspace(-20, 20, 50, dtype=np.float32)
 1407:         x = 10**x
 1408:         x = np.r_[-x, x]
 1409:         xi = x + x * 1j
 1410: 
 1411:         eps = np.finfo(x.dtype).eps
 1412:         y = x + x * eps * nulp / 2.
 1413:         assert_array_almost_equal_nulp(xi, x + y * 1j, nulp)
 1414:         assert_array_almost_equal_nulp(xi, y + x * 1j, nulp)
 1415:         y = x + x * eps * nulp / 4.
 1416:         assert_array_almost_equal_nulp(xi, y + y * 1j, nulp)
 1417: 
 1418:         epsneg = np.finfo(x.dtype).epsneg
 1419:         y = x - x * epsneg * nulp / 2.
 1420:         assert_array_almost_equal_nulp(xi, x + y * 1j, nulp)
 1421:         assert_array_almost_equal_nulp(xi, y + x * 1j, nulp)
 1422:         y = x - x * epsneg * nulp / 4.
 1423:         assert_array_almost_equal_nulp(xi, y + y * 1j, nulp)
 1424: 
 1425:     def test_complex64_fail(self):
 1426:         nulp = 5
 1427:         x = np.linspace(-20, 20, 50, dtype=np.float32)
 1428:         x = 10**x
 1429:         x = np.r_[-x, x]
 1430:         xi = x + x * 1j
 1431: 
 1432:         eps = np.finfo(x.dtype).eps
 1433:         y = x + x * eps * nulp * 2.
 1434:         assert_raises(AssertionError, assert_array_almost_equal_nulp,
 1435:                       xi, x + y * 1j, nulp)
 1436:         assert_raises(AssertionError, assert_array_almost_equal_nulp,
 1437:                       xi, y + x * 1j, nulp)
 1438:         y = x + x * eps * nulp
 1439:         assert_raises(AssertionError, assert_array_almost_equal_nulp,
 1440:                       xi, y + y * 1j, nulp)
 1441: 
 1442:         epsneg = np.finfo(x.dtype).epsneg
 1443:         y = x - x * epsneg * nulp * 2.
 1444:         assert_raises(AssertionError, assert_array_almost_equal_nulp,
 1445:                       xi, x + y * 1j, nulp)
 1446:         assert_raises(AssertionError, assert_array_almost_equal_nulp,
 1447:                       xi, y + x * 1j, nulp)
 1448:         y = x - x * epsneg * nulp
 1449:         assert_raises(AssertionError, assert_array_almost_equal_nulp,
 1450:                       xi, y + y * 1j, nulp)
 1451: 
 1452: 
 1453: class TestULP:
 1454: 
 1455:     def test_equal(self):
 1456:         x = np.random.randn(10)
 1457:         assert_array_max_ulp(x, x, maxulp=0)
 1458: 
 1459:     def test_single(self):
 1460:         # Generate 1 + small deviation, check that adding eps gives a few UNL
 1461:         x = np.ones(10).astype(np.float32)
 1462:         x += 0.01 * np.random.randn(10).astype(np.float32)
 1463:         eps = np.finfo(np.float32).eps
 1464:         assert_array_max_ulp(x, x + eps, maxulp=20)
 1465: 
 1466:     def test_double(self):
 1467:         # Generate 1 + small deviation, check that adding eps gives a few UNL
 1468:         x = np.ones(10).astype(np.float64)
 1469:         x += 0.01 * np.random.randn(10).astype(np.float64)
 1470:         eps = np.finfo(np.float64).eps
 1471:         assert_array_max_ulp(x, x + eps, maxulp=200)
 1472: 
 1473:     def test_inf(self):
 1474:         for dt in [np.float32, np.float64]:
 1475:             inf = np.array([np.inf]).astype(dt)
 1476:             big = np.array([np.finfo(dt).max])
 1477:             assert_array_max_ulp(inf, big, maxulp=200)
 1478: 
 1479:     def test_nan(self):
 1480:         # Test that nan is 'far' from small, tiny, inf, max and min
 1481:         for dt in [np.float32, np.float64]:
 1482:             if dt == np.float32:
 1483:                 maxulp = 1e6
 1484:             else:
 1485:                 maxulp = 1e12
 1486:             inf = np.array([np.inf]).astype(dt)
 1487:             nan = np.array([np.nan]).astype(dt)
 1488:             big = np.array([np.finfo(dt).max])
 1489:             tiny = np.array([np.finfo(dt).tiny])
 1490:             zero = np.array([0.0]).astype(dt)
 1491:             nzero = np.array([-0.0]).astype(dt)
 1492:             assert_raises(AssertionError,
 1493:                           lambda: assert_array_max_ulp(nan, inf,
 1494:                                                        maxulp=maxulp))
 1495:             assert_raises(AssertionError,
 1496:                           lambda: assert_array_max_ulp(nan, big,
 1497:                                                        maxulp=maxulp))
 1498:             assert_raises(AssertionError,
 1499:                           lambda: assert_array_max_ulp(nan, tiny,
 1500:                                                        maxulp=maxulp))
 1501:             assert_raises(AssertionError,
 1502:                           lambda: assert_array_max_ulp(nan, zero,
 1503:                                                        maxulp=maxulp))
 1504:             assert_raises(AssertionError,
 1505:                           lambda: assert_array_max_ulp(nan, nzero,
 1506:                                                        maxulp=maxulp))
 1507: 
 1508: 
 1509: class TestStringEqual:
 1510:     def test_simple(self):
 1511:         assert_string_equal("hello", "hello")
 1512:         assert_string_equal("hello\nmultiline", "hello\nmultiline")
 1513: 
 1514:         with pytest.raises(AssertionError) as exc_info:
 1515:             assert_string_equal("foo\nbar", "hello\nbar")
 1516:         msg = str(exc_info.value)
 1517:         assert_equal(msg, "Differences in strings:\n- foo\n+ hello")
 1518: 
 1519:         assert_raises(AssertionError,
 1520:                       lambda: assert_string_equal("foo", "hello"))
 1521: 
 1522:     def test_regex(self):
 1523:         assert_string_equal("a+*b", "a+*b")
 1524: 
 1525:         assert_raises(AssertionError,
 1526:                       lambda: assert_string_equal("aaa", "a+b"))
 1527: 
 1528: 
 1529: def assert_warn_len_equal(mod, n_in_context):
 1530:     try:
 1531:         mod_warns = mod.__warningregistry__
 1532:     except AttributeError:
 1533:         # the lack of a __warningregistry__
 1534:         # attribute means that no warning has
 1535:         # occurred; this can be triggered in
 1536:         # a parallel test scenario, while in
 1537:         # a serial test scenario an initial
 1538:         # warning (and therefore the attribute)
 1539:         # are always created first
 1540:         mod_warns = {}
 1541: 
 1542:     num_warns = len(mod_warns)
 1543: 
 1544:     if 'version' in mod_warns:
 1545:         # Python adds a 'version' entry to the registry,
 1546:         # do not count it.
 1547:         num_warns -= 1
 1548: 
 1549:     assert_equal(num_warns, n_in_context)
 1550: 
 1551: 
 1552: def test_warn_len_equal_call_scenarios():
 1553:     # assert_warn_len_equal is called under
 1554:     # varying circumstances depending on serial
 1555:     # vs. parallel test scenarios; this test
 1556:     # simply aims to probe both code paths and
 1557:     # check that no assertion is uncaught
 1558: 
 1559:     # parallel scenario -- no warning issued yet
 1560:     class mod:
 1561:         pass
 1562: 
 1563:     mod_inst = mod()
 1564: 
 1565:     assert_warn_len_equal(mod=mod_inst,
 1566:                           n_in_context=0)
 1567: 
 1568:     # serial test scenario -- the __warningregistry__
 1569:     # attribute should be present
 1570:     class mod:
 1571:         def __init__(self):
 1572:             self.__warningregistry__ = {'warning1': 1,
 1573:                                         'warning2': 2}
 1574: 
 1575:     mod_inst = mod()
 1576:     assert_warn_len_equal(mod=mod_inst,
 1577:                           n_in_context=2)
 1578: 
 1579: 
 1580: def _get_fresh_mod():
 1581:     # Get this module, with warning registry empty
 1582:     my_mod = sys.modules[__name__]
 1583:     try:
 1584:         my_mod.__warningregistry__.clear()
 1585:     except AttributeError:
 1586:         # will not have a __warningregistry__ unless warning has been
 1587:         # raised in the module at some point
 1588:         pass
 1589:     return my_mod
 1590: 
 1591: 
 1592: def test_clear_and_catch_warnings():
 1593:     # Initial state of module, no warnings
 1594:     my_mod = _get_fresh_mod()
 1595:     assert_equal(getattr(my_mod, '__warningregistry__', {}), {})
 1596:     with clear_and_catch_warnings(modules=[my_mod]):
 1597:         warnings.simplefilter('ignore')
 1598:         warnings.warn('Some warning')
 1599:     assert_equal(my_mod.__warningregistry__, {})
 1600:     # Without specified modules, don't clear warnings during context.
 1601:     # catch_warnings doesn't make an entry for 'ignore'.
 1602:     with clear_and_catch_warnings():
 1603:         warnings.simplefilter('ignore')
 1604:         warnings.warn('Some warning')
 1605:     assert_warn_len_equal(my_mod, 0)
 1606: 
 1607:     # Manually adding two warnings to the registry:
 1608:     my_mod.__warningregistry__ = {'warning1': 1,
 1609:                                   'warning2': 2}
 1610: 
 1611:     # Confirm that specifying module keeps old warning, does not add new
 1612:     with clear_and_catch_warnings(modules=[my_mod]):
 1613:         warnings.simplefilter('ignore')
 1614:         warnings.warn('Another warning')
 1615:     assert_warn_len_equal(my_mod, 2)
 1616: 
 1617:     # Another warning, no module spec it clears up registry
 1618:     with clear_and_catch_warnings():
 1619:         warnings.simplefilter('ignore')
 1620:         warnings.warn('Another warning')
 1621:     assert_warn_len_equal(my_mod, 0)
 1622: 
 1623: 
 1624: def test_suppress_warnings_module():
 1625:     # Initial state of module, no warnings
 1626:     my_mod = _get_fresh_mod()
 1627:     assert_equal(getattr(my_mod, '__warningregistry__', {}), {})
 1628: 
 1629:     def warn_other_module():
 1630:         # Apply along axis is implemented in python; stacklevel=2 means
 1631:         # we end up inside its module, not ours.
 1632:         def warn(arr):
 1633:             warnings.warn("Some warning 2", stacklevel=2)
 1634:             return arr
 1635:         np.apply_along_axis(warn, 0, [0])
 1636: 
 1637:     # Test module based warning suppression:
 1638:     assert_warn_len_equal(my_mod, 0)
 1639:     with suppress_warnings() as sup:
 1640:         sup.record(UserWarning)
 1641:         # suppress warning from other module (may have .pyc ending),
 1642:         # if apply_along_axis is moved, had to be changed.
 1643:         sup.filter(module=np.lib._shape_base_impl)
 1644:         warnings.warn("Some warning")
 1645:         warn_other_module()
 1646:     # Check that the suppression did test the file correctly (this module
 1647:     # got filtered)
 1648:     assert_equal(len(sup.log), 1)
 1649:     assert_equal(sup.log[0].message.args[0], "Some warning")
 1650:     assert_warn_len_equal(my_mod, 0)
 1651:     sup = suppress_warnings()
 1652:     # Will have to be changed if apply_along_axis is moved:
 1653:     sup.filter(module=my_mod)
 1654:     with sup:
 1655:         warnings.warn('Some warning')
 1656:     assert_warn_len_equal(my_mod, 0)
 1657:     # And test repeat works:
 1658:     sup.filter(module=my_mod)
 1659:     with sup:
 1660:         warnings.warn('Some warning')
 1661:     assert_warn_len_equal(my_mod, 0)
 1662: 
 1663:     # Without specified modules
 1664:     with suppress_warnings():
 1665:         warnings.simplefilter('ignore')
 1666:         warnings.warn('Some warning')
 1667:     assert_warn_len_equal(my_mod, 0)
 1668: 
 1669: 
 1670: def test_suppress_warnings_type():
 1671:     # Initial state of module, no warnings
 1672:     my_mod = _get_fresh_mod()
 1673:     assert_equal(getattr(my_mod, '__warningregistry__', {}), {})
 1674: 
 1675:     # Test module based warning suppression:
 1676:     with suppress_warnings() as sup:
 1677:         sup.filter(UserWarning)
 1678:         warnings.warn('Some warning')
 1679:     assert_warn_len_equal(my_mod, 0)
 1680:     sup = suppress_warnings()
 1681:     sup.filter(UserWarning)
 1682:     with sup:
 1683:         warnings.warn('Some warning')
 1684:     assert_warn_len_equal(my_mod, 0)
 1685:     # And test repeat works:
 1686:     sup.filter(module=my_mod)
 1687:     with sup:
 1688:         warnings.warn('Some warning')
 1689:     assert_warn_len_equal(my_mod, 0)
 1690: 
 1691:     # Without specified modules
 1692:     with suppress_warnings():
 1693:         warnings.simplefilter('ignore')
 1694:         warnings.warn('Some warning')
 1695:     assert_warn_len_equal(my_mod, 0)
 1696: 
 1697: 
 1698: def test_suppress_warnings_decorate_no_record():
 1699:     sup = suppress_warnings()
 1700:     sup.filter(UserWarning)
 1701: 
 1702:     @sup
 1703:     def warn(category):
 1704:         warnings.warn('Some warning', category)
 1705: 
 1706:     with warnings.catch_warnings(record=True) as w:
 1707:         warnings.simplefilter("always")
 1708:         warn(UserWarning)  # should be suppressed
 1709:         warn(RuntimeWarning)
 1710:         assert_equal(len(w), 1)
 1711: 
 1712: 
 1713: def test_suppress_warnings_record():
 1714:     sup = suppress_warnings()
 1715:     log1 = sup.record()
 1716: 
 1717:     with sup:
 1718:         log2 = sup.record(message='Some other warning 2')
 1719:         sup.filter(message='Some warning')
 1720:         warnings.warn('Some warning')
 1721:         warnings.warn('Some other warning')
 1722:         warnings.warn('Some other warning 2')
 1723: 
 1724:         assert_equal(len(sup.log), 2)
 1725:         assert_equal(len(log1), 1)
 1726:         assert_equal(len(log2), 1)
 1727:         assert_equal(log2[0].message.args[0], 'Some other warning 2')
 1728: 
 1729:     # Do it again, with the same context to see if some warnings survived:
 1730:     with sup:
 1731:         log2 = sup.record(message='Some other warning 2')
 1732:         sup.filter(message='Some warning')
 1733:         warnings.warn('Some warning')
 1734:         warnings.warn('Some other warning')
 1735:         warnings.warn('Some other warning 2')
 1736: 
 1737:         assert_equal(len(sup.log), 2)
 1738:         assert_equal(len(log1), 1)
 1739:         assert_equal(len(log2), 1)
 1740:         assert_equal(log2[0].message.args[0], 'Some other warning 2')
 1741: 
 1742:     # Test nested:
 1743:     with suppress_warnings() as sup:
 1744:         sup.record()
 1745:         with suppress_warnings() as sup2:
 1746:             sup2.record(message='Some warning')
 1747:             warnings.warn('Some warning')
 1748:             warnings.warn('Some other warning')
 1749:             assert_equal(len(sup2.log), 1)
 1750:         assert_equal(len(sup.log), 1)
 1751: 
 1752: 
 1753: def test_suppress_warnings_forwarding():
 1754:     def warn_other_module():
 1755:         # Apply along axis is implemented in python; stacklevel=2 means
 1756:         # we end up inside its module, not ours.
 1757:         def warn(arr):
 1758:             warnings.warn("Some warning", stacklevel=2)
 1759:             return arr
 1760:         np.apply_along_axis(warn, 0, [0])
 1761: 
 1762:     with suppress_warnings() as sup:
 1763:         sup.record()
 1764:         with suppress_warnings("always"):
 1765:             for i in range(2):
 1766:                 warnings.warn("Some warning")
 1767: 
 1768:         assert_equal(len(sup.log), 2)
 1769: 
 1770:     with suppress_warnings() as sup:
 1771:         sup.record()
 1772:         with suppress_warnings("location"):
 1773:             for i in range(2):
 1774:                 warnings.warn("Some warning")
 1775:                 warnings.warn("Some warning")
 1776: 
 1777:         assert_equal(len(sup.log), 2)
 1778: 
 1779:     with suppress_warnings() as sup:
 1780:         sup.record()
 1781:         with suppress_warnings("module"):
 1782:             for i in range(2):
 1783:                 warnings.warn("Some warning")
 1784:                 warnings.warn("Some warning")
 1785:                 warn_other_module()
 1786: 
 1787:         assert_equal(len(sup.log), 2)
 1788: 
 1789:     with suppress_warnings() as sup:
 1790:         sup.record()
 1791:         with suppress_warnings("once"):
 1792:             for i in range(2):
 1793:                 warnings.warn("Some warning")
 1794:                 warnings.warn("Some other warning")
 1795:                 warn_other_module()
 1796: 
 1797:         assert_equal(len(sup.log), 2)
 1798: 
 1799: 
 1800: def test_tempdir():
 1801:     with tempdir() as tdir:
 1802:         fpath = os.path.join(tdir, 'tmp')
 1803:         with open(fpath, 'w'):
 1804:             pass
 1805:     assert_(not os.path.isdir(tdir))
 1806: 
 1807:     raised = False
 1808:     try:
 1809:         with tempdir() as tdir:
 1810:             raise ValueError
 1811:     except ValueError:
 1812:         raised = True
 1813:     assert_(raised)
 1814:     assert_(not os.path.isdir(tdir))
 1815: 
 1816: 
 1817: def test_temppath():
 1818:     with temppath() as fpath:
 1819:         with open(fpath, 'w'):
 1820:             pass
 1821:     assert_(not os.path.isfile(fpath))
 1822: 
 1823:     raised = False
 1824:     try:
 1825:         with temppath() as fpath:
 1826:             raise ValueError
 1827:     except ValueError:
 1828:         raised = True
 1829:     assert_(raised)
 1830:     assert_(not os.path.isfile(fpath))
 1831: 
 1832: 
 1833: class my_cacw(clear_and_catch_warnings):
 1834: 
 1835:     class_modules = (sys.modules[__name__],)
 1836: 
 1837: 
 1838: def test_clear_and_catch_warnings_inherit():
 1839:     # Test can subclass and add default modules
 1840:     my_mod = _get_fresh_mod()
 1841:     with my_cacw():
 1842:         warnings.simplefilter('ignore')
 1843:         warnings.warn('Some warning')
 1844:     assert_equal(my_mod.__warningregistry__, {})
 1845: 
 1846: 
 1847: @pytest.mark.skipif(not HAS_REFCOUNT, reason="Python lacks refcounts")
 1848: class TestAssertNoGcCycles:
 1849:     """ Test assert_no_gc_cycles """
 1850: 
 1851:     def test_passes(self):
 1852:         def no_cycle():
 1853:             b = []
 1854:             b.append([])
 1855:             return b
 1856: 
 1857:         with assert_no_gc_cycles():
 1858:             no_cycle()
 1859: 
 1860:         assert_no_gc_cycles(no_cycle)
 1861: 
 1862:     def test_asserts(self):
 1863:         def make_cycle():
 1864:             a = []
 1865:             a.append(a)
 1866:             a.append(a)
 1867:             return a
 1868: 
 1869:         with assert_raises(AssertionError):
 1870:             with assert_no_gc_cycles():
 1871:                 make_cycle()
 1872: 
 1873:         with assert_raises(AssertionError):
 1874:             assert_no_gc_cycles(make_cycle)
 1875: 
 1876:     @pytest.mark.slow
 1877:     def test_fails(self):
 1878:         """
 1879:         Test that in cases where the garbage cannot be collected, we raise an
 1880:         error, instead of hanging forever trying to clear it.
 1881:         """
 1882: 
 1883:         class ReferenceCycleInDel:
 1884:             """
 1885:             An object that not only contains a reference cycle, but creates new
 1886:             cycles whenever it's garbage-collected and its __del__ runs
 1887:             """
 1888:             make_cycle = True
 1889: 
 1890:             def __init__(self):
 1891:                 self.cycle = self
 1892: 
 1893:             def __del__(self):
 1894:                 # break the current cycle so that `self` can be freed
 1895:                 self.cycle = None
 1896: 
 1897:                 if ReferenceCycleInDel.make_cycle:
 1898:                     # but create a new one so that the garbage collector (GC) has more
 1899:                     # work to do.
 1900:                     ReferenceCycleInDel()
 1901: 
 1902:         try:
 1903:             w = weakref.ref(ReferenceCycleInDel())
 1904:             try:
 1905:                 with assert_raises(RuntimeError):
 1906:                     # this will be unable to get a baseline empty garbage
 1907:                     assert_no_gc_cycles(lambda: None)
 1908:             except AssertionError:
 1909:                 # the above test is only necessary if the GC actually tried to free
 1910:                 # our object anyway.
 1911:                 if w() is not None:
 1912:                     pytest.skip("GC does not call __del__ on cyclic objects")
 1913:                     raise
 1914: 
 1915:         finally:
 1916:             # make sure that we stop creating reference cycles
 1917:             ReferenceCycleInDel.make_cycle = False
