    1: __all__ = ['matrix', 'bmat', 'asmatrix']
    2: 
    3: import ast
    4: import sys
    5: import warnings
    6: 
    7: import numpy._core.numeric as N
    8: from numpy._core.numeric import concatenate, isscalar
    9: from numpy._utils import set_module
   10: 
   11: # While not in __all__, matrix_power used to be defined here, so we import
   12: # it for backward compatibility.
   13: from numpy.linalg import matrix_power
   14: 
   15: 
   16: def _convert_from_string(data):
   17:     for char in '[]':
   18:         data = data.replace(char, '')
   19: 
   20:     rows = data.split(';')
   21:     newdata = []
   22:     for count, row in enumerate(rows):
   23:         trow = row.split(',')
   24:         newrow = []
   25:         for col in trow:
   26:             temp = col.split()
   27:             newrow.extend(map(ast.literal_eval, temp))
   28:         if count == 0:
   29:             Ncols = len(newrow)
   30:         elif len(newrow) != Ncols:
   31:             raise ValueError("Rows not the same size.")
   32:         newdata.append(newrow)
   33:     return newdata
   34: 
   35: 
   36: @set_module('numpy')
   37: def asmatrix(data, dtype=None):
   38:     """
   39:     Interpret the input as a matrix.
   40: 
   41:     Unlike `matrix`, `asmatrix` does not make a copy if the input is already
   42:     a matrix or an ndarray.  Equivalent to ``matrix(data, copy=False)``.
   43: 
   44:     Parameters
   45:     ----------
   46:     data : array_like
   47:         Input data.
   48:     dtype : data-type
   49:        Data-type of the output matrix.
   50: 
   51:     Returns
   52:     -------
   53:     mat : matrix
   54:         `data` interpreted as a matrix.
   55: 
   56:     Examples
   57:     --------
   58:     >>> import numpy as np
   59:     >>> x = np.array([[1, 2], [3, 4]])
   60: 
   61:     >>> m = np.asmatrix(x)
   62: 
   63:     >>> x[0,0] = 5
   64: 
   65:     >>> m
   66:     matrix([[5, 2],
   67:             [3, 4]])
   68: 
   69:     """
   70:     return matrix(data, dtype=dtype, copy=False)
   71: 
   72: 
   73: @set_module('numpy')
   74: class matrix(N.ndarray):
   75:     """
   76:     matrix(data, dtype=None, copy=True)
   77: 
   78:     Returns a matrix from an array-like object, or from a string of data.
   79: 
   80:     A matrix is a specialized 2-D array that retains its 2-D nature
   81:     through operations.  It has certain special operators, such as ``*``
   82:     (matrix multiplication) and ``**`` (matrix power).
   83: 
   84:     .. note:: It is no longer recommended to use this class, even for linear
   85:               algebra. Instead use regular arrays. The class may be removed
   86:               in the future.
   87: 
   88:     Parameters
   89:     ----------
   90:     data : array_like or string
   91:        If `data` is a string, it is interpreted as a matrix with commas
   92:        or spaces separating columns, and semicolons separating rows.
   93:     dtype : data-type
   94:        Data-type of the output matrix.
   95:     copy : bool
   96:        If `data` is already an `ndarray`, then this flag determines
   97:        whether the data is copied (the default), or whether a view is
   98:        constructed.
   99: 
  100:     See Also
  101:     --------
  102:     array
  103: 
  104:     Examples
  105:     --------
  106:     >>> import numpy as np
  107:     >>> a = np.matrix('1 2; 3 4')
  108:     >>> a
  109:     matrix([[1, 2],
  110:             [3, 4]])
  111: 
  112:     >>> np.matrix([[1, 2], [3, 4]])
  113:     matrix([[1, 2],
  114:             [3, 4]])
  115: 
  116:     """
  117:     __array_priority__ = 10.0
  118: 
  119:     def __new__(subtype, data, dtype=None, copy=True):
  120:         warnings.warn('the matrix subclass is not the recommended way to '
  121:                       'represent matrices or deal with linear algebra (see '
  122:                       'https://docs.scipy.org/doc/numpy/user/'
  123:                       'numpy-for-matlab-users.html). '
  124:                       'Please adjust your code to use regular ndarray.',
  125:                       PendingDeprecationWarning, stacklevel=2)
  126:         if isinstance(data, matrix):
  127:             dtype2 = data.dtype
  128:             if (dtype is None):
  129:                 dtype = dtype2
  130:             if (dtype2 == dtype) and (not copy):
  131:                 return data
  132:             return data.astype(dtype)
  133: 
  134:         if isinstance(data, N.ndarray):
  135:             if dtype is None:
  136:                 intype = data.dtype
  137:             else:
  138:                 intype = N.dtype(dtype)
  139:             new = data.view(subtype)
  140:             if intype != data.dtype:
  141:                 return new.astype(intype)
  142:             if copy:
  143:                 return new.copy()
  144:             else:
  145:                 return new
  146: 
  147:         if isinstance(data, str):
  148:             data = _convert_from_string(data)
  149: 
  150:         # now convert data to an array
  151:         copy = None if not copy else True
  152:         arr = N.array(data, dtype=dtype, copy=copy)
  153:         ndim = arr.ndim
  154:         shape = arr.shape
  155:         if (ndim > 2):
  156:             raise ValueError("matrix must be 2-dimensional")
  157:         elif ndim == 0:
  158:             shape = (1, 1)
  159:         elif ndim == 1:
  160:             shape = (1, shape[0])
  161: 
  162:         order = 'C'
  163:         if (ndim == 2) and arr.flags.fortran:
  164:             order = 'F'
  165: 
  166:         if not (order or arr.flags.contiguous):
  167:             arr = arr.copy()
  168: 
  169:         ret = N.ndarray.__new__(subtype, shape, arr.dtype,
  170:                                 buffer=arr,
  171:                                 order=order)
  172:         return ret
  173: 
  174:     def __array_finalize__(self, obj):
  175:         self._getitem = False
  176:         if (isinstance(obj, matrix) and obj._getitem):
  177:             return
  178:         ndim = self.ndim
  179:         if (ndim == 2):
  180:             return
  181:         if (ndim > 2):
  182:             newshape = tuple(x for x in self.shape if x > 1)
  183:             ndim = len(newshape)
  184:             if ndim == 2:
  185:                 self.shape = newshape
  186:                 return
  187:             elif (ndim > 2):
  188:                 raise ValueError("shape too large to be a matrix.")
  189:         else:
  190:             newshape = self.shape
  191:         if ndim == 0:
  192:             self.shape = (1, 1)
  193:         elif ndim == 1:
  194:             self.shape = (1, newshape[0])
  195:         return
  196: 
  197:     def __getitem__(self, index):
  198:         self._getitem = True
  199: 
  200:         try:
  201:             out = N.ndarray.__getitem__(self, index)
  202:         finally:
  203:             self._getitem = False
  204: 
  205:         if not isinstance(out, N.ndarray):
  206:             return out
  207: 
  208:         if out.ndim == 0:
  209:             return out[()]
  210:         if out.ndim == 1:
  211:             sh = out.shape[0]
  212:             # Determine when we should have a column array
  213:             try:
  214:                 n = len(index)
  215:             except Exception:
  216:                 n = 0
  217:             if n > 1 and isscalar(index[1]):
  218:                 out.shape = (sh, 1)
  219:             else:
  220:                 out.shape = (1, sh)
  221:         return out
  222: 
  223:     def __mul__(self, other):
  224:         if isinstance(other, (N.ndarray, list, tuple)):
  225:             # This promotes 1-D vectors to row vectors
  226:             return N.dot(self, asmatrix(other))
  227:         if isscalar(other) or not hasattr(other, '__rmul__'):
  228:             return N.dot(self, other)
  229:         return NotImplemented
  230: 
  231:     def __rmul__(self, other):
  232:         return N.dot(other, self)
  233: 
  234:     def __imul__(self, other):
  235:         self[:] = self * other
  236:         return self
  237: 
  238:     def __pow__(self, other):
  239:         return matrix_power(self, other)
  240: 
  241:     def __ipow__(self, other):
  242:         self[:] = self ** other
  243:         return self
  244: 
  245:     def __rpow__(self, other):
  246:         return NotImplemented
  247: 
  248:     def _align(self, axis):
  249:         """A convenience function for operations that need to preserve axis
  250:         orientation.
  251:         """
  252:         if axis is None:
  253:             return self[0, 0]
  254:         elif axis == 0:
  255:             return self
  256:         elif axis == 1:
  257:             return self.transpose()
  258:         else:
  259:             raise ValueError("unsupported axis")
  260: 
  261:     def _collapse(self, axis):
  262:         """A convenience function for operations that want to collapse
  263:         to a scalar like _align, but are using keepdims=True
  264:         """
  265:         if axis is None:
  266:             return self[0, 0]
  267:         else:
  268:             return self
  269: 
  270:     # Necessary because base-class tolist expects dimension
  271:     #  reduction by x[0]
  272:     def tolist(self):
  273:         """
  274:         Return the matrix as a (possibly nested) list.
  275: 
  276:         See `ndarray.tolist` for full documentation.
  277: 
  278:         See Also
  279:         --------
  280:         ndarray.tolist
  281: 
  282:         Examples
  283:         --------
  284:         >>> x = np.matrix(np.arange(12).reshape((3,4))); x
  285:         matrix([[ 0,  1,  2,  3],
  286:                 [ 4,  5,  6,  7],
  287:                 [ 8,  9, 10, 11]])
  288:         >>> x.tolist()
  289:         [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]]
  290: 
  291:         """
  292:         return self.__array__().tolist()
  293: 
  294:     # To preserve orientation of result...
  295:     def sum(self, axis=None, dtype=None, out=None):
  296:         """
  297:         Returns the sum of the matrix elements, along the given axis.
  298: 
  299:         Refer to `numpy.sum` for full documentation.
  300: 
  301:         See Also
  302:         --------
  303:         numpy.sum
  304: 
  305:         Notes
  306:         -----
  307:         This is the same as `ndarray.sum`, except that where an `ndarray` would
  308:         be returned, a `matrix` object is returned instead.
  309: 
  310:         Examples
  311:         --------
  312:         >>> x = np.matrix([[1, 2], [4, 3]])
  313:         >>> x.sum()
  314:         10
  315:         >>> x.sum(axis=1)
  316:         matrix([[3],
  317:                 [7]])
  318:         >>> x.sum(axis=1, dtype='float')
  319:         matrix([[3.],
  320:                 [7.]])
  321:         >>> out = np.zeros((2, 1), dtype='float')
  322:         >>> x.sum(axis=1, dtype='float', out=np.asmatrix(out))
  323:         matrix([[3.],
  324:                 [7.]])
  325: 
  326:         """
  327:         return N.ndarray.sum(self, axis, dtype, out, keepdims=True)._collapse(axis)
  328: 
  329:     # To update docstring from array to matrix...
  330:     def squeeze(self, axis=None):
  331:         """
  332:         Return a possibly reshaped matrix.
  333: 
  334:         Refer to `numpy.squeeze` for more documentation.
  335: 
  336:         Parameters
  337:         ----------
  338:         axis : None or int or tuple of ints, optional
  339:             Selects a subset of the axes of length one in the shape.
  340:             If an axis is selected with shape entry greater than one,
  341:             an error is raised.
  342: 
  343:         Returns
  344:         -------
  345:         squeezed : matrix
  346:             The matrix, but as a (1, N) matrix if it had shape (N, 1).
  347: 
  348:         See Also
  349:         --------
  350:         numpy.squeeze : related function
  351: 
  352:         Notes
  353:         -----
  354:         If `m` has a single column then that column is returned
  355:         as the single row of a matrix.  Otherwise `m` is returned.
  356:         The returned matrix is always either `m` itself or a view into `m`.
  357:         Supplying an axis keyword argument will not affect the returned matrix
  358:         but it may cause an error to be raised.
  359: 
  360:         Examples
  361:         --------
  362:         >>> c = np.matrix([[1], [2]])
  363:         >>> c
  364:         matrix([[1],
  365:                 [2]])
  366:         >>> c.squeeze()
  367:         matrix([[1, 2]])
  368:         >>> r = c.T
  369:         >>> r
  370:         matrix([[1, 2]])
  371:         >>> r.squeeze()
  372:         matrix([[1, 2]])
  373:         >>> m = np.matrix([[1, 2], [3, 4]])
  374:         >>> m.squeeze()
  375:         matrix([[1, 2],
  376:                 [3, 4]])
  377: 
  378:         """
  379:         return N.ndarray.squeeze(self, axis=axis)
  380: 
  381:     # To update docstring from array to matrix...
  382:     def flatten(self, order='C'):
  383:         """
  384:         Return a flattened copy of the matrix.
  385: 
  386:         All `N` elements of the matrix are placed into a single row.
  387: 
  388:         Parameters
  389:         ----------
  390:         order : {'C', 'F', 'A', 'K'}, optional
  391:             'C' means to flatten in row-major (C-style) order. 'F' means to
  392:             flatten in column-major (Fortran-style) order. 'A' means to
  393:             flatten in column-major order if `m` is Fortran *contiguous* in
  394:             memory, row-major order otherwise. 'K' means to flatten `m` in
  395:             the order the elements occur in memory. The default is 'C'.
  396: 
  397:         Returns
  398:         -------
  399:         y : matrix
  400:             A copy of the matrix, flattened to a `(1, N)` matrix where `N`
  401:             is the number of elements in the original matrix.
  402: 
  403:         See Also
  404:         --------
  405:         ravel : Return a flattened array.
  406:         flat : A 1-D flat iterator over the matrix.
  407: 
  408:         Examples
  409:         --------
  410:         >>> m = np.matrix([[1,2], [3,4]])
  411:         >>> m.flatten()
  412:         matrix([[1, 2, 3, 4]])
  413:         >>> m.flatten('F')
  414:         matrix([[1, 3, 2, 4]])
  415: 
  416:         """
  417:         return N.ndarray.flatten(self, order=order)
  418: 
  419:     def mean(self, axis=None, dtype=None, out=None):
  420:         """
  421:         Returns the average of the matrix elements along the given axis.
  422: 
  423:         Refer to `numpy.mean` for full documentation.
  424: 
  425:         See Also
  426:         --------
  427:         numpy.mean
  428: 
  429:         Notes
  430:         -----
  431:         Same as `ndarray.mean` except that, where that returns an `ndarray`,
  432:         this returns a `matrix` object.
  433: 
  434:         Examples
  435:         --------
  436:         >>> x = np.matrix(np.arange(12).reshape((3, 4)))
  437:         >>> x
  438:         matrix([[ 0,  1,  2,  3],
  439:                 [ 4,  5,  6,  7],
  440:                 [ 8,  9, 10, 11]])
  441:         >>> x.mean()
  442:         5.5
  443:         >>> x.mean(0)
  444:         matrix([[4., 5., 6., 7.]])
  445:         >>> x.mean(1)
  446:         matrix([[ 1.5],
  447:                 [ 5.5],
  448:                 [ 9.5]])
  449: 
  450:         """
  451:         return N.ndarray.mean(self, axis, dtype, out, keepdims=True)._collapse(axis)
  452: 
  453:     def std(self, axis=None, dtype=None, out=None, ddof=0):
  454:         """
  455:         Return the standard deviation of the array elements along the given axis.
  456: 
  457:         Refer to `numpy.std` for full documentation.
  458: 
  459:         See Also
  460:         --------
  461:         numpy.std
  462: 
  463:         Notes
  464:         -----
  465:         This is the same as `ndarray.std`, except that where an `ndarray` would
  466:         be returned, a `matrix` object is returned instead.
  467: 
  468:         Examples
  469:         --------
  470:         >>> x = np.matrix(np.arange(12).reshape((3, 4)))
  471:         >>> x
  472:         matrix([[ 0,  1,  2,  3],
  473:                 [ 4,  5,  6,  7],
  474:                 [ 8,  9, 10, 11]])
  475:         >>> x.std()
  476:         3.4520525295346629 # may vary
  477:         >>> x.std(0)
  478:         matrix([[ 3.26598632,  3.26598632,  3.26598632,  3.26598632]]) # may vary
  479:         >>> x.std(1)
  480:         matrix([[ 1.11803399],
  481:                 [ 1.11803399],
  482:                 [ 1.11803399]])
  483: 
  484:         """
  485:         return N.ndarray.std(self, axis, dtype, out, ddof,
  486:                              keepdims=True)._collapse(axis)
  487: 
  488:     def var(self, axis=None, dtype=None, out=None, ddof=0):
  489:         """
  490:         Returns the variance of the matrix elements, along the given axis.
  491: 
  492:         Refer to `numpy.var` for full documentation.
  493: 
  494:         See Also
  495:         --------
  496:         numpy.var
  497: 
  498:         Notes
  499:         -----
  500:         This is the same as `ndarray.var`, except that where an `ndarray` would
  501:         be returned, a `matrix` object is returned instead.
  502: 
  503:         Examples
  504:         --------
  505:         >>> x = np.matrix(np.arange(12).reshape((3, 4)))
  506:         >>> x
  507:         matrix([[ 0,  1,  2,  3],
  508:                 [ 4,  5,  6,  7],
  509:                 [ 8,  9, 10, 11]])
  510:         >>> x.var()
  511:         11.916666666666666
  512:         >>> x.var(0)
  513:         matrix([[ 10.66666667,  10.66666667,  10.66666667,  10.66666667]]) # may vary
  514:         >>> x.var(1)
  515:         matrix([[1.25],
  516:                 [1.25],
  517:                 [1.25]])
  518: 
  519:         """
  520:         return N.ndarray.var(self, axis, dtype, out, ddof,
  521:                              keepdims=True)._collapse(axis)
  522: 
  523:     def prod(self, axis=None, dtype=None, out=None):
  524:         """
  525:         Return the product of the array elements over the given axis.
  526: 
  527:         Refer to `prod` for full documentation.
  528: 
  529:         See Also
  530:         --------
  531:         prod, ndarray.prod
  532: 
  533:         Notes
  534:         -----
  535:         Same as `ndarray.prod`, except, where that returns an `ndarray`, this
  536:         returns a `matrix` object instead.
  537: 
  538:         Examples
  539:         --------
  540:         >>> x = np.matrix(np.arange(12).reshape((3,4))); x
  541:         matrix([[ 0,  1,  2,  3],
  542:                 [ 4,  5,  6,  7],
  543:                 [ 8,  9, 10, 11]])
  544:         >>> x.prod()
  545:         0
  546:         >>> x.prod(0)
  547:         matrix([[  0,  45, 120, 231]])
  548:         >>> x.prod(1)
  549:         matrix([[   0],
  550:                 [ 840],
  551:                 [7920]])
  552: 
  553:         """
  554:         return N.ndarray.prod(self, axis, dtype, out, keepdims=True)._collapse(axis)
  555: 
  556:     def any(self, axis=None, out=None):
  557:         """
  558:         Test whether any array element along a given axis evaluates to True.
  559: 
  560:         Refer to `numpy.any` for full documentation.
  561: 
  562:         Parameters
  563:         ----------
  564:         axis : int, optional
  565:             Axis along which logical OR is performed
  566:         out : ndarray, optional
  567:             Output to existing array instead of creating new one, must have
  568:             same shape as expected output
  569: 
  570:         Returns
  571:         -------
  572:             any : bool, ndarray
  573:                 Returns a single bool if `axis` is ``None``; otherwise,
  574:                 returns `ndarray`
  575: 
  576:         """
  577:         return N.ndarray.any(self, axis, out, keepdims=True)._collapse(axis)
  578: 
  579:     def all(self, axis=None, out=None):
  580:         """
  581:         Test whether all matrix elements along a given axis evaluate to True.
  582: 
  583:         Parameters
  584:         ----------
  585:         See `numpy.all` for complete descriptions
  586: 
  587:         See Also
  588:         --------
  589:         numpy.all
  590: 
  591:         Notes
  592:         -----
  593:         This is the same as `ndarray.all`, but it returns a `matrix` object.
  594: 
  595:         Examples
  596:         --------
  597:         >>> x = np.matrix(np.arange(12).reshape((3,4))); x
  598:         matrix([[ 0,  1,  2,  3],
  599:                 [ 4,  5,  6,  7],
  600:                 [ 8,  9, 10, 11]])
  601:         >>> y = x[0]; y
  602:         matrix([[0, 1, 2, 3]])
  603:         >>> (x == y)
  604:         matrix([[ True,  True,  True,  True],
  605:                 [False, False, False, False],
  606:                 [False, False, False, False]])
  607:         >>> (x == y).all()
  608:         False
  609:         >>> (x == y).all(0)
  610:         matrix([[False, False, False, False]])
  611:         >>> (x == y).all(1)
  612:         matrix([[ True],
  613:                 [False],
  614:                 [False]])
  615: 
  616:         """
  617:         return N.ndarray.all(self, axis, out, keepdims=True)._collapse(axis)
  618: 
  619:     def max(self, axis=None, out=None):
  620:         """
  621:         Return the maximum value along an axis.
  622: 
  623:         Parameters
  624:         ----------
  625:         See `amax` for complete descriptions
  626: 
  627:         See Also
  628:         --------
  629:         amax, ndarray.max
  630: 
  631:         Notes
  632:         -----
  633:         This is the same as `ndarray.max`, but returns a `matrix` object
  634:         where `ndarray.max` would return an ndarray.
  635: 
  636:         Examples
  637:         --------
  638:         >>> x = np.matrix(np.arange(12).reshape((3,4))); x
  639:         matrix([[ 0,  1,  2,  3],
  640:                 [ 4,  5,  6,  7],
  641:                 [ 8,  9, 10, 11]])
  642:         >>> x.max()
  643:         11
  644:         >>> x.max(0)
  645:         matrix([[ 8,  9, 10, 11]])
  646:         >>> x.max(1)
  647:         matrix([[ 3],
  648:                 [ 7],
  649:                 [11]])
  650: 
  651:         """
  652:         return N.ndarray.max(self, axis, out, keepdims=True)._collapse(axis)
  653: 
  654:     def argmax(self, axis=None, out=None):
  655:         """
  656:         Indexes of the maximum values along an axis.
  657: 
  658:         Return the indexes of the first occurrences of the maximum values
  659:         along the specified axis.  If axis is None, the index is for the
  660:         flattened matrix.
  661: 
  662:         Parameters
  663:         ----------
  664:         See `numpy.argmax` for complete descriptions
  665: 
  666:         See Also
  667:         --------
  668:         numpy.argmax
  669: 
  670:         Notes
  671:         -----
  672:         This is the same as `ndarray.argmax`, but returns a `matrix` object
  673:         where `ndarray.argmax` would return an `ndarray`.
  674: 
  675:         Examples
  676:         --------
  677:         >>> x = np.matrix(np.arange(12).reshape((3,4))); x
  678:         matrix([[ 0,  1,  2,  3],
  679:                 [ 4,  5,  6,  7],
  680:                 [ 8,  9, 10, 11]])
  681:         >>> x.argmax()
  682:         11
  683:         >>> x.argmax(0)
  684:         matrix([[2, 2, 2, 2]])
  685:         >>> x.argmax(1)
  686:         matrix([[3],
  687:                 [3],
  688:                 [3]])
  689: 
  690:         """
  691:         return N.ndarray.argmax(self, axis, out)._align(axis)
  692: 
  693:     def min(self, axis=None, out=None):
  694:         """
  695:         Return the minimum value along an axis.
  696: 
  697:         Parameters
  698:         ----------
  699:         See `amin` for complete descriptions.
  700: 
  701:         See Also
  702:         --------
  703:         amin, ndarray.min
  704: 
  705:         Notes
  706:         -----
  707:         This is the same as `ndarray.min`, but returns a `matrix` object
  708:         where `ndarray.min` would return an ndarray.
  709: 
  710:         Examples
  711:         --------
  712:         >>> x = -np.matrix(np.arange(12).reshape((3,4))); x
  713:         matrix([[  0,  -1,  -2,  -3],
  714:                 [ -4,  -5,  -6,  -7],
  715:                 [ -8,  -9, -10, -11]])
  716:         >>> x.min()
  717:         -11
  718:         >>> x.min(0)
  719:         matrix([[ -8,  -9, -10, -11]])
  720:         >>> x.min(1)
  721:         matrix([[ -3],
  722:                 [ -7],
  723:                 [-11]])
  724: 
  725:         """
  726:         return N.ndarray.min(self, axis, out, keepdims=True)._collapse(axis)
  727: 
  728:     def argmin(self, axis=None, out=None):
  729:         """
  730:         Indexes of the minimum values along an axis.
  731: 
  732:         Return the indexes of the first occurrences of the minimum values
  733:         along the specified axis.  If axis is None, the index is for the
  734:         flattened matrix.
  735: 
  736:         Parameters
  737:         ----------
  738:         See `numpy.argmin` for complete descriptions.
  739: 
  740:         See Also
  741:         --------
  742:         numpy.argmin
  743: 
  744:         Notes
  745:         -----
  746:         This is the same as `ndarray.argmin`, but returns a `matrix` object
  747:         where `ndarray.argmin` would return an `ndarray`.
  748: 
  749:         Examples
  750:         --------
  751:         >>> x = -np.matrix(np.arange(12).reshape((3,4))); x
  752:         matrix([[  0,  -1,  -2,  -3],
  753:                 [ -4,  -5,  -6,  -7],
  754:                 [ -8,  -9, -10, -11]])
  755:         >>> x.argmin()
  756:         11
  757:         >>> x.argmin(0)
  758:         matrix([[2, 2, 2, 2]])
  759:         >>> x.argmin(1)
  760:         matrix([[3],
  761:                 [3],
  762:                 [3]])
  763: 
  764:         """
  765:         return N.ndarray.argmin(self, axis, out)._align(axis)
  766: 
  767:     def ptp(self, axis=None, out=None):
  768:         """
  769:         Peak-to-peak (maximum - minimum) value along the given axis.
  770: 
  771:         Refer to `numpy.ptp` for full documentation.
  772: 
  773:         See Also
  774:         --------
  775:         numpy.ptp
  776: 
  777:         Notes
  778:         -----
  779:         Same as `ndarray.ptp`, except, where that would return an `ndarray` object,
  780:         this returns a `matrix` object.
  781: 
  782:         Examples
  783:         --------
  784:         >>> x = np.matrix(np.arange(12).reshape((3,4))); x
  785:         matrix([[ 0,  1,  2,  3],
  786:                 [ 4,  5,  6,  7],
  787:                 [ 8,  9, 10, 11]])
  788:         >>> x.ptp()
  789:         11
  790:         >>> x.ptp(0)
  791:         matrix([[8, 8, 8, 8]])
  792:         >>> x.ptp(1)
  793:         matrix([[3],
  794:                 [3],
  795:                 [3]])
  796: 
  797:         """
  798:         return N.ptp(self, axis, out)._align(axis)
  799: 
  800:     @property
  801:     def I(self):  # noqa: E743
  802:         """
  803:         Returns the (multiplicative) inverse of invertible `self`.
  804: 
  805:         Parameters
  806:         ----------
  807:         None
  808: 
  809:         Returns
  810:         -------
  811:         ret : matrix object
  812:             If `self` is non-singular, `ret` is such that ``ret * self`` ==
  813:             ``self * ret`` == ``np.matrix(np.eye(self[0,:].size))`` all return
  814:             ``True``.
  815: 
  816:         Raises
  817:         ------
  818:         numpy.linalg.LinAlgError: Singular matrix
  819:             If `self` is singular.
  820: 
  821:         See Also
  822:         --------
  823:         linalg.inv
  824: 
  825:         Examples
  826:         --------
  827:         >>> m = np.matrix('[1, 2; 3, 4]'); m
  828:         matrix([[1, 2],
  829:                 [3, 4]])
  830:         >>> m.getI()
  831:         matrix([[-2. ,  1. ],
  832:                 [ 1.5, -0.5]])
  833:         >>> m.getI() * m
  834:         matrix([[ 1.,  0.], # may vary
  835:                 [ 0.,  1.]])
  836: 
  837:         """
  838:         M, N = self.shape
  839:         if M == N:
  840:             from numpy.linalg import inv as func
  841:         else:
  842:             from numpy.linalg import pinv as func
  843:         return asmatrix(func(self))
  844: 
  845:     @property
  846:     def A(self):
  847:         """
  848:         Return `self` as an `ndarray` object.
  849: 
  850:         Equivalent to ``np.asarray(self)``.
  851: 
  852:         Parameters
  853:         ----------
  854:         None
  855: 
  856:         Returns
  857:         -------
  858:         ret : ndarray
  859:             `self` as an `ndarray`
  860: 
  861:         Examples
  862:         --------
  863:         >>> x = np.matrix(np.arange(12).reshape((3,4))); x
  864:         matrix([[ 0,  1,  2,  3],
  865:                 [ 4,  5,  6,  7],
  866:                 [ 8,  9, 10, 11]])
  867:         >>> x.getA()
  868:         array([[ 0,  1,  2,  3],
  869:                [ 4,  5,  6,  7],
  870:                [ 8,  9, 10, 11]])
  871: 
  872:         """
  873:         return self.__array__()
  874: 
  875:     @property
  876:     def A1(self):
  877:         """
  878:         Return `self` as a flattened `ndarray`.
  879: 
  880:         Equivalent to ``np.asarray(x).ravel()``
  881: 
  882:         Parameters
  883:         ----------
  884:         None
  885: 
  886:         Returns
  887:         -------
  888:         ret : ndarray
  889:             `self`, 1-D, as an `ndarray`
  890: 
  891:         Examples
  892:         --------
  893:         >>> x = np.matrix(np.arange(12).reshape((3,4))); x
  894:         matrix([[ 0,  1,  2,  3],
  895:                 [ 4,  5,  6,  7],
  896:                 [ 8,  9, 10, 11]])
  897:         >>> x.getA1()
  898:         array([ 0,  1,  2, ...,  9, 10, 11])
  899: 
  900: 
  901:         """
  902:         return self.__array__().ravel()
  903: 
  904:     def ravel(self, order='C'):
  905:         """
  906:         Return a flattened matrix.
  907: 
  908:         Refer to `numpy.ravel` for more documentation.
  909: 
  910:         Parameters
  911:         ----------
  912:         order : {'C', 'F', 'A', 'K'}, optional
  913:             The elements of `m` are read using this index order. 'C' means to
  914:             index the elements in C-like order, with the last axis index
  915:             changing fastest, back to the first axis index changing slowest.
  916:             'F' means to index the elements in Fortran-like index order, with
  917:             the first index changing fastest, and the last index changing
  918:             slowest. Note that the 'C' and 'F' options take no account of the
  919:             memory layout of the underlying array, and only refer to the order
  920:             of axis indexing.  'A' means to read the elements in Fortran-like
  921:             index order if `m` is Fortran *contiguous* in memory, C-like order
  922:             otherwise.  'K' means to read the elements in the order they occur
  923:             in memory, except for reversing the data when strides are negative.
  924:             By default, 'C' index order is used.
  925: 
  926:         Returns
  927:         -------
  928:         ret : matrix
  929:             Return the matrix flattened to shape `(1, N)` where `N`
  930:             is the number of elements in the original matrix.
  931:             A copy is made only if necessary.
  932: 
  933:         See Also
  934:         --------
  935:         matrix.flatten : returns a similar output matrix but always a copy
  936:         matrix.flat : a flat iterator on the array.
  937:         numpy.ravel : related function which returns an ndarray
  938: 
  939:         """
  940:         return N.ndarray.ravel(self, order=order)
  941: 
  942:     @property
  943:     def T(self):
  944:         """
  945:         Returns the transpose of the matrix.
  946: 
  947:         Does *not* conjugate!  For the complex conjugate transpose, use ``.H``.
  948: 
  949:         Parameters
  950:         ----------
  951:         None
  952: 
  953:         Returns
  954:         -------
  955:         ret : matrix object
  956:             The (non-conjugated) transpose of the matrix.
  957: 
  958:         See Also
  959:         --------
  960:         transpose, getH
  961: 
  962:         Examples
  963:         --------
  964:         >>> m = np.matrix('[1, 2; 3, 4]')
  965:         >>> m
  966:         matrix([[1, 2],
  967:                 [3, 4]])
  968:         >>> m.getT()
  969:         matrix([[1, 3],
  970:                 [2, 4]])
  971: 
  972:         """
  973:         return self.transpose()
  974: 
  975:     @property
  976:     def H(self):
  977:         """
  978:         Returns the (complex) conjugate transpose of `self`.
  979: 
  980:         Equivalent to ``np.transpose(self)`` if `self` is real-valued.
  981: 
  982:         Parameters
  983:         ----------
  984:         None
  985: 
  986:         Returns
  987:         -------
  988:         ret : matrix object
  989:             complex conjugate transpose of `self`
  990: 
  991:         Examples
  992:         --------
  993:         >>> x = np.matrix(np.arange(12).reshape((3,4)))
  994:         >>> z = x - 1j*x; z
  995:         matrix([[  0. +0.j,   1. -1.j,   2. -2.j,   3. -3.j],
  996:                 [  4. -4.j,   5. -5.j,   6. -6.j,   7. -7.j],
  997:                 [  8. -8.j,   9. -9.j,  10.-10.j,  11.-11.j]])
  998:         >>> z.getH()
  999:         matrix([[ 0. -0.j,  4. +4.j,  8. +8.j],
 1000:                 [ 1. +1.j,  5. +5.j,  9. +9.j],
 1001:                 [ 2. +2.j,  6. +6.j, 10.+10.j],
 1002:                 [ 3. +3.j,  7. +7.j, 11.+11.j]])
 1003: 
 1004:         """
 1005:         if issubclass(self.dtype.type, N.complexfloating):
 1006:             return self.transpose().conjugate()
 1007:         else:
 1008:             return self.transpose()
 1009: 
 1010:     # kept for compatibility
 1011:     getT = T.fget
 1012:     getA = A.fget
 1013:     getA1 = A1.fget
 1014:     getH = H.fget
 1015:     getI = I.fget
 1016: 
 1017: def _from_string(str, gdict, ldict):
 1018:     rows = str.split(';')
 1019:     rowtup = []
 1020:     for row in rows:
 1021:         trow = row.split(',')
 1022:         newrow = []
 1023:         for x in trow:
 1024:             newrow.extend(x.split())
 1025:         trow = newrow
 1026:         coltup = []
 1027:         for col in trow:
 1028:             col = col.strip()
 1029:             try:
 1030:                 thismat = ldict[col]
 1031:             except KeyError:
 1032:                 try:
 1033:                     thismat = gdict[col]
 1034:                 except KeyError as e:
 1035:                     raise NameError(f"name {col!r} is not defined") from None
 1036: 
 1037:             coltup.append(thismat)
 1038:         rowtup.append(concatenate(coltup, axis=-1))
 1039:     return concatenate(rowtup, axis=0)
 1040: 
 1041: 
 1042: @set_module('numpy')
 1043: def bmat(obj, ldict=None, gdict=None):
 1044:     """
 1045:     Build a matrix object from a string, nested sequence, or array.
 1046: 
 1047:     Parameters
 1048:     ----------
 1049:     obj : str or array_like
 1050:         Input data. If a string, variables in the current scope may be
 1051:         referenced by name.
 1052:     ldict : dict, optional
 1053:         A dictionary that replaces local operands in current frame.
 1054:         Ignored if `obj` is not a string or `gdict` is None.
 1055:     gdict : dict, optional
 1056:         A dictionary that replaces global operands in current frame.
 1057:         Ignored if `obj` is not a string.
 1058: 
 1059:     Returns
 1060:     -------
 1061:     out : matrix
 1062:         Returns a matrix object, which is a specialized 2-D array.
 1063: 
 1064:     See Also
 1065:     --------
 1066:     block :
 1067:         A generalization of this function for N-d arrays, that returns normal
 1068:         ndarrays.
 1069: 
 1070:     Examples
 1071:     --------
 1072:     >>> import numpy as np
 1073:     >>> A = np.asmatrix('1 1; 1 1')
 1074:     >>> B = np.asmatrix('2 2; 2 2')
 1075:     >>> C = np.asmatrix('3 4; 5 6')
 1076:     >>> D = np.asmatrix('7 8; 9 0')
 1077: 
 1078:     All the following expressions construct the same block matrix:
 1079: 
 1080:     >>> np.bmat([[A, B], [C, D]])
 1081:     matrix([[1, 1, 2, 2],
 1082:             [1, 1, 2, 2],
 1083:             [3, 4, 7, 8],
 1084:             [5, 6, 9, 0]])
 1085:     >>> np.bmat(np.r_[np.c_[A, B], np.c_[C, D]])
 1086:     matrix([[1, 1, 2, 2],
 1087:             [1, 1, 2, 2],
 1088:             [3, 4, 7, 8],
 1089:             [5, 6, 9, 0]])
 1090:     >>> np.bmat('A,B; C,D')
 1091:     matrix([[1, 1, 2, 2],
 1092:             [1, 1, 2, 2],
 1093:             [3, 4, 7, 8],
 1094:             [5, 6, 9, 0]])
 1095: 
 1096:     """
 1097:     if isinstance(obj, str):
 1098:         if gdict is None:
 1099:             # get previous frame
 1100:             frame = sys._getframe().f_back
 1101:             glob_dict = frame.f_globals
 1102:             loc_dict = frame.f_locals
 1103:         else:
 1104:             glob_dict = gdict
 1105:             loc_dict = ldict
 1106: 
 1107:         return matrix(_from_string(obj, glob_dict, loc_dict))
 1108: 
 1109:     if isinstance(obj, (tuple, list)):
 1110:         # [[A,B],[C,D]]
 1111:         arr_rows = []
 1112:         for row in obj:
 1113:             if isinstance(row, N.ndarray):  # not 2-d
 1114:                 return matrix(concatenate(obj, axis=-1))
 1115:             else:
 1116:                 arr_rows.append(concatenate(row, axis=-1))
 1117:         return matrix(concatenate(arr_rows, axis=0))
 1118:     if isinstance(obj, N.ndarray):
 1119:         return matrix(obj)
