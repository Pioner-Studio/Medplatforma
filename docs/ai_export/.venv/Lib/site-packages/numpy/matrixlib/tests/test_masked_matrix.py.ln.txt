    1: import pickle
    2: 
    3: import numpy as np
    4: from numpy.ma.core import (
    5:     MaskedArray,
    6:     MaskType,
    7:     add,
    8:     allequal,
    9:     divide,
   10:     getmask,
   11:     hypot,
   12:     log,
   13:     masked,
   14:     masked_array,
   15:     masked_values,
   16:     nomask,
   17: )
   18: from numpy.ma.extras import mr_
   19: from numpy.ma.testutils import assert_, assert_array_equal, assert_equal, assert_raises
   20: 
   21: 
   22: class MMatrix(MaskedArray, np.matrix,):
   23: 
   24:     def __new__(cls, data, mask=nomask):
   25:         mat = np.matrix(data)
   26:         _data = MaskedArray.__new__(cls, data=mat, mask=mask)
   27:         return _data
   28: 
   29:     def __array_finalize__(self, obj):
   30:         np.matrix.__array_finalize__(self, obj)
   31:         MaskedArray.__array_finalize__(self, obj)
   32: 
   33:     @property
   34:     def _series(self):
   35:         _view = self.view(MaskedArray)
   36:         _view._sharedmask = False
   37:         return _view
   38: 
   39: 
   40: class TestMaskedMatrix:
   41:     def test_matrix_indexing(self):
   42:         # Tests conversions and indexing
   43:         x1 = np.matrix([[1, 2, 3], [4, 3, 2]])
   44:         x2 = masked_array(x1, mask=[[1, 0, 0], [0, 1, 0]])
   45:         x3 = masked_array(x1, mask=[[0, 1, 0], [1, 0, 0]])
   46:         x4 = masked_array(x1)
   47:         # test conversion to strings
   48:         str(x2)  # raises?
   49:         repr(x2)  # raises?
   50:         # tests of indexing
   51:         assert_(type(x2[1, 0]) is type(x1[1, 0]))
   52:         assert_(x1[1, 0] == x2[1, 0])
   53:         assert_(x2[1, 1] is masked)
   54:         assert_equal(x1[0, 2], x2[0, 2])
   55:         assert_equal(x1[0, 1:], x2[0, 1:])
   56:         assert_equal(x1[:, 2], x2[:, 2])
   57:         assert_equal(x1[:], x2[:])
   58:         assert_equal(x1[1:], x3[1:])
   59:         x1[0, 2] = 9
   60:         x2[0, 2] = 9
   61:         assert_equal(x1, x2)
   62:         x1[0, 1:] = 99
   63:         x2[0, 1:] = 99
   64:         assert_equal(x1, x2)
   65:         x2[0, 1] = masked
   66:         assert_equal(x1, x2)
   67:         x2[0, 1:] = masked
   68:         assert_equal(x1, x2)
   69:         x2[0, :] = x1[0, :]
   70:         x2[0, 1] = masked
   71:         assert_(allequal(getmask(x2), np.array([[0, 1, 0], [0, 1, 0]])))
   72:         x3[1, :] = masked_array([1, 2, 3], [1, 1, 0])
   73:         assert_(allequal(getmask(x3)[1], masked_array([1, 1, 0])))
   74:         assert_(allequal(getmask(x3[1]), masked_array([1, 1, 0])))
   75:         x4[1, :] = masked_array([1, 2, 3], [1, 1, 0])
   76:         assert_(allequal(getmask(x4[1]), masked_array([1, 1, 0])))
   77:         assert_(allequal(x4[1], masked_array([1, 2, 3])))
   78:         x1 = np.matrix(np.arange(5) * 1.0)
   79:         x2 = masked_values(x1, 3.0)
   80:         assert_equal(x1, x2)
   81:         assert_(allequal(masked_array([0, 0, 0, 1, 0], dtype=MaskType),
   82:                          x2.mask))
   83:         assert_equal(3.0, x2.fill_value)
   84: 
   85:     def test_pickling_subbaseclass(self):
   86:         # Test pickling w/ a subclass of ndarray
   87:         a = masked_array(np.matrix(list(range(10))), mask=[1, 0, 1, 0, 0] * 2)
   88:         for proto in range(2, pickle.HIGHEST_PROTOCOL + 1):
   89:             a_pickled = pickle.loads(pickle.dumps(a, protocol=proto))
   90:             assert_equal(a_pickled._mask, a._mask)
   91:             assert_equal(a_pickled, a)
   92:             assert_(isinstance(a_pickled._data, np.matrix))
   93: 
   94:     def test_count_mean_with_matrix(self):
   95:         m = masked_array(np.matrix([[1, 2], [3, 4]]), mask=np.zeros((2, 2)))
   96: 
   97:         assert_equal(m.count(axis=0).shape, (1, 2))
   98:         assert_equal(m.count(axis=1).shape, (2, 1))
   99: 
  100:         # Make sure broadcasting inside mean and var work
  101:         assert_equal(m.mean(axis=0), [[2., 3.]])
  102:         assert_equal(m.mean(axis=1), [[1.5], [3.5]])
  103: 
  104:     def test_flat(self):
  105:         # Test that flat can return items even for matrices [#4585, #4615]
  106:         # test simple access
  107:         test = masked_array(np.matrix([[1, 2, 3]]), mask=[0, 0, 1])
  108:         assert_equal(test.flat[1], 2)
  109:         assert_equal(test.flat[2], masked)
  110:         assert_(np.all(test.flat[0:2] == test[0, 0:2]))
  111:         # Test flat on masked_matrices
  112:         test = masked_array(np.matrix([[1, 2, 3]]), mask=[0, 0, 1])
  113:         test.flat = masked_array([3, 2, 1], mask=[1, 0, 0])
  114:         control = masked_array(np.matrix([[3, 2, 1]]), mask=[1, 0, 0])
  115:         assert_equal(test, control)
  116:         # Test setting
  117:         test = masked_array(np.matrix([[1, 2, 3]]), mask=[0, 0, 1])
  118:         testflat = test.flat
  119:         testflat[:] = testflat[[2, 1, 0]]
  120:         assert_equal(test, control)
  121:         testflat[0] = 9
  122:         # test that matrices keep the correct shape (#4615)
  123:         a = masked_array(np.matrix(np.eye(2)), mask=0)
  124:         b = a.flat
  125:         b01 = b[:2]
  126:         assert_equal(b01.data, np.array([[1., 0.]]))
  127:         assert_equal(b01.mask, np.array([[False, False]]))
  128: 
  129:     def test_allany_onmatrices(self):
  130:         x = np.array([[0.13, 0.26, 0.90],
  131:                       [0.28, 0.33, 0.63],
  132:                       [0.31, 0.87, 0.70]])
  133:         X = np.matrix(x)
  134:         m = np.array([[True, False, False],
  135:                       [False, False, False],
  136:                       [True, True, False]], dtype=np.bool)
  137:         mX = masked_array(X, mask=m)
  138:         mXbig = (mX > 0.5)
  139:         mXsmall = (mX < 0.5)
  140: 
  141:         assert_(not mXbig.all())
  142:         assert_(mXbig.any())
  143:         assert_equal(mXbig.all(0), np.matrix([False, False, True]))
  144:         assert_equal(mXbig.all(1), np.matrix([False, False, True]).T)
  145:         assert_equal(mXbig.any(0), np.matrix([False, False, True]))
  146:         assert_equal(mXbig.any(1), np.matrix([True, True, True]).T)
  147: 
  148:         assert_(not mXsmall.all())
  149:         assert_(mXsmall.any())
  150:         assert_equal(mXsmall.all(0), np.matrix([True, True, False]))
  151:         assert_equal(mXsmall.all(1), np.matrix([False, False, False]).T)
  152:         assert_equal(mXsmall.any(0), np.matrix([True, True, False]))
  153:         assert_equal(mXsmall.any(1), np.matrix([True, True, False]).T)
  154: 
  155:     def test_compressed(self):
  156:         a = masked_array(np.matrix([1, 2, 3, 4]), mask=[0, 0, 0, 0])
  157:         b = a.compressed()
  158:         assert_equal(b, a)
  159:         assert_(isinstance(b, np.matrix))
  160:         a[0, 0] = masked
  161:         b = a.compressed()
  162:         assert_equal(b, [[2, 3, 4]])
  163: 
  164:     def test_ravel(self):
  165:         a = masked_array(np.matrix([1, 2, 3, 4, 5]), mask=[[0, 1, 0, 0, 0]])
  166:         aravel = a.ravel()
  167:         assert_equal(aravel.shape, (1, 5))
  168:         assert_equal(aravel._mask.shape, a.shape)
  169: 
  170:     def test_view(self):
  171:         # Test view w/ flexible dtype
  172:         iterator = list(zip(np.arange(10), np.random.rand(10)))
  173:         data = np.array(iterator)
  174:         a = masked_array(iterator, dtype=[('a', float), ('b', float)])
  175:         a.mask[0] = (1, 0)
  176:         test = a.view((float, 2), np.matrix)
  177:         assert_equal(test, data)
  178:         assert_(isinstance(test, np.matrix))
  179:         assert_(not isinstance(test, MaskedArray))
  180: 
  181: 
  182: class TestSubclassing:
  183:     # Test suite for masked subclasses of ndarray.
  184: 
  185:     def setup_method(self):
  186:         x = np.arange(5, dtype='float')
  187:         mx = MMatrix(x, mask=[0, 1, 0, 0, 0])
  188:         self.data = (x, mx)
  189: 
  190:     def test_maskedarray_subclassing(self):
  191:         # Tests subclassing MaskedArray
  192:         (x, mx) = self.data
  193:         assert_(isinstance(mx._data, np.matrix))
  194: 
  195:     def test_masked_unary_operations(self):
  196:         # Tests masked_unary_operation
  197:         (x, mx) = self.data
  198:         with np.errstate(divide='ignore'):
  199:             assert_(isinstance(log(mx), MMatrix))
  200:             assert_equal(log(x), np.log(x))
  201: 
  202:     def test_masked_binary_operations(self):
  203:         # Tests masked_binary_operation
  204:         (x, mx) = self.data
  205:         # Result should be a MMatrix
  206:         assert_(isinstance(add(mx, mx), MMatrix))
  207:         assert_(isinstance(add(mx, x), MMatrix))
  208:         # Result should work
  209:         assert_equal(add(mx, x), mx + x)
  210:         assert_(isinstance(add(mx, mx)._data, np.matrix))
  211:         with assert_raises(TypeError):
  212:             add.outer(mx, mx)
  213:         assert_(isinstance(hypot(mx, mx), MMatrix))
  214:         assert_(isinstance(hypot(mx, x), MMatrix))
  215: 
  216:     def test_masked_binary_operations2(self):
  217:         # Tests domained_masked_binary_operation
  218:         (x, mx) = self.data
  219:         xmx = masked_array(mx.data.__array__(), mask=mx.mask)
  220:         assert_(isinstance(divide(mx, mx), MMatrix))
  221:         assert_(isinstance(divide(mx, x), MMatrix))
  222:         assert_equal(divide(mx, mx), divide(xmx, xmx))
  223: 
  224: class TestConcatenator:
  225:     # Tests for mr_, the equivalent of r_ for masked arrays.
  226: 
  227:     def test_matrix_builder(self):
  228:         assert_raises(np.ma.MAError, lambda: mr_['1, 2; 3, 4'])
  229: 
  230:     def test_matrix(self):
  231:         # Test consistency with unmasked version.  If we ever deprecate
  232:         # matrix, this test should either still pass, or both actual and
  233:         # expected should fail to be build.
  234:         actual = mr_['r', 1, 2, 3]
  235:         expected = np.ma.array(np.r_['r', 1, 2, 3])
  236:         assert_array_equal(actual, expected)
  237: 
  238:         # outer type is masked array, inner type is matrix
  239:         assert_equal(type(actual), type(expected))
  240:         assert_equal(type(actual.data), type(expected.data))
