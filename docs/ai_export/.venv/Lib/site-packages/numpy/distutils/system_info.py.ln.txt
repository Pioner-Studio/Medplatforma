    1: """
    2: This file defines a set of system_info classes for getting
    3: information about various resources (libraries, library directories,
    4: include directories, etc.) in the system. Usage:
    5:     info_dict = get_info(<name>)
    6:   where <name> is a string 'atlas','x11','fftw','lapack','blas',
    7:   'lapack_src', 'blas_src', etc. For a complete list of allowed names,
    8:   see the definition of get_info() function below.
    9: 
   10:   Returned info_dict is a dictionary which is compatible with
   11:   distutils.setup keyword arguments. If info_dict == {}, then the
   12:   asked resource is not available (system_info could not find it).
   13: 
   14:   Several *_info classes specify an environment variable to specify
   15:   the locations of software. When setting the corresponding environment
   16:   variable to 'None' then the software will be ignored, even when it
   17:   is available in system.
   18: 
   19: Global parameters:
   20:   system_info.search_static_first - search static libraries (.a)
   21:              in precedence to shared ones (.so, .sl) if enabled.
   22:   system_info.verbosity - output the results to stdout if enabled.
   23: 
   24: The file 'site.cfg' is looked for in
   25: 
   26: 1) Directory of main setup.py file being run.
   27: 2) Home directory of user running the setup.py file as ~/.numpy-site.cfg
   28: 3) System wide directory (location of this file...)
   29: 
   30: The first one found is used to get system configuration options The
   31: format is that used by ConfigParser (i.e., Windows .INI style). The
   32: section ALL is not intended for general use.
   33: 
   34: Appropriate defaults are used if nothing is specified.
   35: 
   36: The order of finding the locations of resources is the following:
   37:  1. environment variable
   38:  2. section in site.cfg
   39:  3. DEFAULT section in site.cfg
   40:  4. System default search paths (see ``default_*`` variables below).
   41: Only the first complete match is returned.
   42: 
   43: Currently, the following classes are available, along with their section names:
   44: 
   45:     Numeric_info:Numeric
   46:     _numpy_info:Numeric
   47:     _pkg_config_info:None
   48:     accelerate_info:accelerate
   49:     accelerate_lapack_info:accelerate
   50:     agg2_info:agg2
   51:     amd_info:amd
   52:     atlas_3_10_blas_info:atlas
   53:     atlas_3_10_blas_threads_info:atlas
   54:     atlas_3_10_info:atlas
   55:     atlas_3_10_threads_info:atlas
   56:     atlas_blas_info:atlas
   57:     atlas_blas_threads_info:atlas
   58:     atlas_info:atlas
   59:     atlas_threads_info:atlas
   60:     blas64__opt_info:ALL               # usage recommended (general ILP64 BLAS, 64_ symbol suffix)
   61:     blas_ilp64_opt_info:ALL            # usage recommended (general ILP64 BLAS)
   62:     blas_ilp64_plain_opt_info:ALL      # usage recommended (general ILP64 BLAS, no symbol suffix)
   63:     blas_info:blas
   64:     blas_mkl_info:mkl
   65:     blas_ssl2_info:ssl2
   66:     blas_opt_info:ALL                  # usage recommended
   67:     blas_src_info:blas_src
   68:     blis_info:blis
   69:     boost_python_info:boost_python
   70:     dfftw_info:fftw
   71:     dfftw_threads_info:fftw
   72:     djbfft_info:djbfft
   73:     f2py_info:ALL
   74:     fft_opt_info:ALL
   75:     fftw2_info:fftw
   76:     fftw3_info:fftw3
   77:     fftw_info:fftw
   78:     fftw_threads_info:fftw
   79:     flame_info:flame
   80:     freetype2_info:freetype2
   81:     gdk_2_info:gdk_2
   82:     gdk_info:gdk
   83:     gdk_pixbuf_2_info:gdk_pixbuf_2
   84:     gdk_pixbuf_xlib_2_info:gdk_pixbuf_xlib_2
   85:     gdk_x11_2_info:gdk_x11_2
   86:     gtkp_2_info:gtkp_2
   87:     gtkp_x11_2_info:gtkp_x11_2
   88:     lapack64__opt_info:ALL             # usage recommended (general ILP64 LAPACK, 64_ symbol suffix)
   89:     lapack_atlas_3_10_info:atlas
   90:     lapack_atlas_3_10_threads_info:atlas
   91:     lapack_atlas_info:atlas
   92:     lapack_atlas_threads_info:atlas
   93:     lapack_ilp64_opt_info:ALL          # usage recommended (general ILP64 LAPACK)
   94:     lapack_ilp64_plain_opt_info:ALL    # usage recommended (general ILP64 LAPACK, no symbol suffix)
   95:     lapack_info:lapack
   96:     lapack_mkl_info:mkl
   97:     lapack_ssl2_info:ssl2
   98:     lapack_opt_info:ALL                # usage recommended
   99:     lapack_src_info:lapack_src
  100:     mkl_info:mkl
  101:     ssl2_info:ssl2
  102:     numarray_info:numarray
  103:     numerix_info:numerix
  104:     numpy_info:numpy
  105:     openblas64__info:openblas64_
  106:     openblas64__lapack_info:openblas64_
  107:     openblas_clapack_info:openblas
  108:     openblas_ilp64_info:openblas_ilp64
  109:     openblas_ilp64_lapack_info:openblas_ilp64
  110:     openblas_info:openblas
  111:     openblas_lapack_info:openblas
  112:     sfftw_info:fftw
  113:     sfftw_threads_info:fftw
  114:     system_info:ALL
  115:     umfpack_info:umfpack
  116:     wx_info:wx
  117:     x11_info:x11
  118:     xft_info:xft
  119: 
  120: Note that blas_opt_info and lapack_opt_info honor the NPY_BLAS_ORDER
  121: and NPY_LAPACK_ORDER environment variables to determine the order in which
  122: specific BLAS and LAPACK libraries are searched for.
  123: 
  124: This search (or autodetection) can be bypassed by defining the environment
  125: variables NPY_BLAS_LIBS and NPY_LAPACK_LIBS, which should then contain the
  126: exact linker flags to use (language will be set to F77). Building against
  127: Netlib BLAS/LAPACK or stub files, in order to be able to switch BLAS and LAPACK
  128: implementations at runtime. If using this to build NumPy itself, it is
  129: recommended to also define NPY_CBLAS_LIBS (assuming your BLAS library has a
  130: CBLAS interface) to enable CBLAS usage for matrix multiplication (unoptimized
  131: otherwise).
  132: 
  133: Example:
  134: ----------
  135: [DEFAULT]
  136: # default section
  137: library_dirs = /usr/lib:/usr/local/lib:/opt/lib
  138: include_dirs = /usr/include:/usr/local/include:/opt/include
  139: src_dirs = /usr/local/src:/opt/src
  140: # search static libraries (.a) in preference to shared ones (.so)
  141: search_static_first = 0
  142: 
  143: [fftw]
  144: libraries = rfftw, fftw
  145: 
  146: [atlas]
  147: library_dirs = /usr/lib/3dnow:/usr/lib/3dnow/atlas
  148: # for overriding the names of the atlas libraries
  149: libraries = lapack, f77blas, cblas, atlas
  150: 
  151: [x11]
  152: library_dirs = /usr/X11R6/lib
  153: include_dirs = /usr/X11R6/include
  154: ----------
  155: 
  156: Note that the ``libraries`` key is the default setting for libraries.
  157: 
  158: Authors:
  159:   Pearu Peterson <pearu@cens.ioc.ee>, February 2002
  160:   David M. Cooke <cookedm@physics.mcmaster.ca>, April 2002
  161: 
  162: Copyright 2002 Pearu Peterson all rights reserved,
  163: Pearu Peterson <pearu@cens.ioc.ee>
  164: Permission to use, modify, and distribute this software is given under the
  165: terms of the NumPy (BSD style) license.  See LICENSE.txt that came with
  166: this distribution for specifics.
  167: 
  168: NO WARRANTY IS EXPRESSED OR IMPLIED.  USE AT YOUR OWN RISK.
  169: 
  170: """
  171: import sys
  172: import os
  173: import re
  174: import copy
  175: import warnings
  176: import subprocess
  177: import textwrap
  178: 
  179: from glob import glob
  180: from functools import reduce
  181: from configparser import NoOptionError
  182: from configparser import RawConfigParser as ConfigParser
  183: # It seems that some people are importing ConfigParser from here so is
  184: # good to keep its class name. Use of RawConfigParser is needed in
  185: # order to be able to load path names with percent in them, like
  186: # `feature%2Fcool` which is common on git flow branch names.
  187: 
  188: from distutils.errors import DistutilsError
  189: from distutils.dist import Distribution
  190: import sysconfig
  191: from numpy.distutils import log
  192: from distutils.util import get_platform
  193: 
  194: from numpy.distutils.exec_command import (
  195:     find_executable, filepath_from_subprocess_output,
  196:     )
  197: from numpy.distutils.misc_util import (is_sequence, is_string,
  198:                                        get_shared_lib_extension)
  199: from numpy.distutils.command.config import config as cmd_config
  200: from numpy.distutils import customized_ccompiler as _customized_ccompiler
  201: from numpy.distutils import _shell_utils
  202: import distutils.ccompiler
  203: import tempfile
  204: import shutil
  205: 
  206: __all__ = ['system_info']
  207: 
  208: # Determine number of bits
  209: import platform
  210: _bits = {'32bit': 32, '64bit': 64}
  211: platform_bits = _bits[platform.architecture()[0]]
  212: 
  213: 
  214: global_compiler = None
  215: 
  216: def customized_ccompiler():
  217:     global global_compiler
  218:     if not global_compiler:
  219:         global_compiler = _customized_ccompiler()
  220:     return global_compiler
  221: 
  222: 
  223: def _c_string_literal(s):
  224:     """
  225:     Convert a python string into a literal suitable for inclusion into C code
  226:     """
  227:     # only these three characters are forbidden in C strings
  228:     s = s.replace('\\', r'\\')
  229:     s = s.replace('"',  r'\"')
  230:     s = s.replace('\n', r'\n')
  231:     return '"{}"'.format(s)
  232: 
  233: 
  234: def libpaths(paths, bits):
  235:     """Return a list of library paths valid on 32 or 64 bit systems.
  236: 
  237:     Inputs:
  238:       paths : sequence
  239:         A sequence of strings (typically paths)
  240:       bits : int
  241:         An integer, the only valid values are 32 or 64.  A ValueError exception
  242:       is raised otherwise.
  243: 
  244:     Examples:
  245: 
  246:     Consider a list of directories
  247:     >>> paths = ['/usr/X11R6/lib','/usr/X11/lib','/usr/lib']
  248: 
  249:     For a 32-bit platform, this is already valid:
  250:     >>> np.distutils.system_info.libpaths(paths,32)
  251:     ['/usr/X11R6/lib', '/usr/X11/lib', '/usr/lib']
  252: 
  253:     On 64 bits, we prepend the '64' postfix
  254:     >>> np.distutils.system_info.libpaths(paths,64)
  255:     ['/usr/X11R6/lib64', '/usr/X11R6/lib', '/usr/X11/lib64', '/usr/X11/lib',
  256:     '/usr/lib64', '/usr/lib']
  257:     """
  258:     if bits not in (32, 64):
  259:         raise ValueError("Invalid bit size in libpaths: 32 or 64 only")
  260: 
  261:     # Handle 32bit case
  262:     if bits == 32:
  263:         return paths
  264: 
  265:     # Handle 64bit case
  266:     out = []
  267:     for p in paths:
  268:         out.extend([p + '64', p])
  269: 
  270:     return out
  271: 
  272: 
  273: if sys.platform == 'win32':
  274:     default_lib_dirs = ['C:\\',
  275:                         os.path.join(sysconfig.get_config_var('exec_prefix'),
  276:                                      'libs')]
  277:     default_runtime_dirs = []
  278:     default_include_dirs = []
  279:     default_src_dirs = ['.']
  280:     default_x11_lib_dirs = []
  281:     default_x11_include_dirs = []
  282:     _include_dirs = [
  283:         'include',
  284:         'include/suitesparse',
  285:     ]
  286:     _lib_dirs = [
  287:         'lib',
  288:     ]
  289: 
  290:     _include_dirs = [d.replace('/', os.sep) for d in _include_dirs]
  291:     _lib_dirs = [d.replace('/', os.sep) for d in _lib_dirs]
  292:     def add_system_root(library_root):
  293:         """Add a package manager root to the include directories"""
  294:         global default_lib_dirs
  295:         global default_include_dirs
  296: 
  297:         library_root = os.path.normpath(library_root)
  298: 
  299:         default_lib_dirs.extend(
  300:             os.path.join(library_root, d) for d in _lib_dirs)
  301:         default_include_dirs.extend(
  302:             os.path.join(library_root, d) for d in _include_dirs)
  303: 
  304:     # VCpkg is the de-facto package manager on windows for C/C++
  305:     # libraries. If it is on the PATH, then we append its paths here.
  306:     vcpkg = shutil.which('vcpkg')
  307:     if vcpkg:
  308:         vcpkg_dir = os.path.dirname(vcpkg)
  309:         if platform.architecture()[0] == '32bit':
  310:             specifier = 'x86'
  311:         else:
  312:             specifier = 'x64'
  313: 
  314:         vcpkg_installed = os.path.join(vcpkg_dir, 'installed')
  315:         for vcpkg_root in [
  316:             os.path.join(vcpkg_installed, specifier + '-windows'),
  317:             os.path.join(vcpkg_installed, specifier + '-windows-static'),
  318:         ]:
  319:             add_system_root(vcpkg_root)
  320: 
  321:     # Conda is another popular package manager that provides libraries
  322:     conda = shutil.which('conda')
  323:     if conda:
  324:         conda_dir = os.path.dirname(conda)
  325:         add_system_root(os.path.join(conda_dir, '..', 'Library'))
  326:         add_system_root(os.path.join(conda_dir, 'Library'))
  327: 
  328: else:
  329:     default_lib_dirs = libpaths(['/usr/local/lib', '/opt/lib', '/usr/lib',
  330:                                  '/opt/local/lib', '/sw/lib'], platform_bits)
  331:     default_runtime_dirs = []
  332:     default_include_dirs = ['/usr/local/include',
  333:                             '/opt/include',
  334:                             # path of umfpack under macports
  335:                             '/opt/local/include/ufsparse',
  336:                             '/opt/local/include', '/sw/include',
  337:                             '/usr/include/suitesparse']
  338:     default_src_dirs = ['.', '/usr/local/src', '/opt/src', '/sw/src']
  339: 
  340:     default_x11_lib_dirs = libpaths(['/usr/X11R6/lib', '/usr/X11/lib',
  341:                                      '/usr/lib'], platform_bits)
  342:     default_x11_include_dirs = ['/usr/X11R6/include', '/usr/X11/include']
  343: 
  344:     if os.path.exists('/usr/lib/X11'):
  345:         globbed_x11_dir = glob('/usr/lib/*/libX11.so')
  346:         if globbed_x11_dir:
  347:             x11_so_dir = os.path.split(globbed_x11_dir[0])[0]
  348:             default_x11_lib_dirs.extend([x11_so_dir, '/usr/lib/X11'])
  349:             default_x11_include_dirs.extend(['/usr/lib/X11/include',
  350:                                              '/usr/include/X11'])
  351: 
  352:     with open(os.devnull, 'w') as tmp:
  353:         try:
  354:             p = subprocess.Popen(["gcc", "-print-multiarch"], stdout=subprocess.PIPE,
  355:                          stderr=tmp)
  356:         except (OSError, DistutilsError):
  357:             # OSError if gcc is not installed, or SandboxViolation (DistutilsError
  358:             # subclass) if an old setuptools bug is triggered (see gh-3160).
  359:             pass
  360:         else:
  361:             triplet = str(p.communicate()[0].decode().strip())
  362:             if p.returncode == 0:
  363:                 # gcc supports the "-print-multiarch" option
  364:                 default_x11_lib_dirs += [os.path.join("/usr/lib/", triplet)]
  365:                 default_lib_dirs += [os.path.join("/usr/lib/", triplet)]
  366: 
  367: 
  368: if os.path.join(sys.prefix, 'lib') not in default_lib_dirs:
  369:     default_lib_dirs.insert(0, os.path.join(sys.prefix, 'lib'))
  370:     default_include_dirs.append(os.path.join(sys.prefix, 'include'))
  371:     default_src_dirs.append(os.path.join(sys.prefix, 'src'))
  372: 
  373: default_lib_dirs = [_m for _m in default_lib_dirs if os.path.isdir(_m)]
  374: default_runtime_dirs = [_m for _m in default_runtime_dirs if os.path.isdir(_m)]
  375: default_include_dirs = [_m for _m in default_include_dirs if os.path.isdir(_m)]
  376: default_src_dirs = [_m for _m in default_src_dirs if os.path.isdir(_m)]
  377: 
  378: so_ext = get_shared_lib_extension()
  379: 
  380: 
  381: def get_standard_file(fname):
  382:     """Returns a list of files named 'fname' from
  383:     1) System-wide directory (directory-location of this module)
  384:     2) Users HOME directory (os.environ['HOME'])
  385:     3) Local directory
  386:     """
  387:     # System-wide file
  388:     filenames = []
  389:     try:
  390:         f = __file__
  391:     except NameError:
  392:         f = sys.argv[0]
  393:     sysfile = os.path.join(os.path.split(os.path.abspath(f))[0],
  394:                            fname)
  395:     if os.path.isfile(sysfile):
  396:         filenames.append(sysfile)
  397: 
  398:     # Home directory
  399:     # And look for the user config file
  400:     try:
  401:         f = os.path.expanduser('~')
  402:     except KeyError:
  403:         pass
  404:     else:
  405:         user_file = os.path.join(f, fname)
  406:         if os.path.isfile(user_file):
  407:             filenames.append(user_file)
  408: 
  409:     # Local file
  410:     if os.path.isfile(fname):
  411:         filenames.append(os.path.abspath(fname))
  412: 
  413:     return filenames
  414: 
  415: 
  416: def _parse_env_order(base_order, env):
  417:     """ Parse an environment variable `env` by splitting with "," and only returning elements from `base_order`
  418: 
  419:     This method will sequence the environment variable and check for their
  420:     individual elements in `base_order`.
  421: 
  422:     The items in the environment variable may be negated via '^item' or '!itema,itemb'.
  423:     It must start with ^/! to negate all options.
  424: 
  425:     Raises
  426:     ------
  427:     ValueError: for mixed negated and non-negated orders or multiple negated orders
  428: 
  429:     Parameters
  430:     ----------
  431:     base_order : list of str
  432:        the base list of orders
  433:     env : str
  434:        the environment variable to be parsed, if none is found, `base_order` is returned
  435: 
  436:     Returns
  437:     -------
  438:     allow_order : list of str
  439:         allowed orders in lower-case
  440:     unknown_order : list of str
  441:         for values not overlapping with `base_order`
  442:     """
  443:     order_str = os.environ.get(env, None)
  444: 
  445:     # ensure all base-orders are lower-case (for easier comparison)
  446:     base_order = [order.lower() for order in base_order]
  447:     if order_str is None:
  448:         return base_order, []
  449: 
  450:     neg = order_str.startswith(('^', '!'))
  451:     # Check format
  452:     order_str_l = list(order_str)
  453:     sum_neg = order_str_l.count('^') + order_str_l.count('!')
  454:     if neg:
  455:         if sum_neg > 1:
  456:             raise ValueError(f"Environment variable '{env}' may only contain a single (prefixed) negation: {order_str}")
  457:         # remove prefix
  458:         order_str = order_str[1:]
  459:     elif sum_neg > 0:
  460:         raise ValueError(f"Environment variable '{env}' may not mix negated an non-negated items: {order_str}")
  461: 
  462:     # Split and lower case
  463:     orders = order_str.lower().split(',')
  464: 
  465:     # to inform callee about non-overlapping elements
  466:     unknown_order = []
  467: 
  468:     # if negated, we have to remove from the order
  469:     if neg:
  470:         allow_order = base_order.copy()
  471: 
  472:         for order in orders:
  473:             if not order:
  474:                 continue
  475: 
  476:             if order not in base_order:
  477:                 unknown_order.append(order)
  478:                 continue
  479: 
  480:             if order in allow_order:
  481:                 allow_order.remove(order)
  482: 
  483:     else:
  484:         allow_order = []
  485: 
  486:         for order in orders:
  487:             if not order:
  488:                 continue
  489: 
  490:             if order not in base_order:
  491:                 unknown_order.append(order)
  492:                 continue
  493: 
  494:             if order not in allow_order:
  495:                 allow_order.append(order)
  496: 
  497:     return allow_order, unknown_order
  498: 
  499: 
  500: def get_info(name, notfound_action=0):
  501:     """
  502:     notfound_action:
  503:       0 - do nothing
  504:       1 - display warning message
  505:       2 - raise error
  506:     """
  507:     cl = {'armpl': armpl_info,
  508:           'blas_armpl': blas_armpl_info,
  509:           'lapack_armpl': lapack_armpl_info,
  510:           'fftw3_armpl': fftw3_armpl_info,
  511:           'atlas': atlas_info,  # use lapack_opt or blas_opt instead
  512:           'atlas_threads': atlas_threads_info,                # ditto
  513:           'atlas_blas': atlas_blas_info,
  514:           'atlas_blas_threads': atlas_blas_threads_info,
  515:           'lapack_atlas': lapack_atlas_info,  # use lapack_opt instead
  516:           'lapack_atlas_threads': lapack_atlas_threads_info,  # ditto
  517:           'atlas_3_10': atlas_3_10_info,  # use lapack_opt or blas_opt instead
  518:           'atlas_3_10_threads': atlas_3_10_threads_info,                # ditto
  519:           'atlas_3_10_blas': atlas_3_10_blas_info,
  520:           'atlas_3_10_blas_threads': atlas_3_10_blas_threads_info,
  521:           'lapack_atlas_3_10': lapack_atlas_3_10_info,  # use lapack_opt instead
  522:           'lapack_atlas_3_10_threads': lapack_atlas_3_10_threads_info,  # ditto
  523:           'flame': flame_info,          # use lapack_opt instead
  524:           'mkl': mkl_info,
  525:           'ssl2': ssl2_info,
  526:           # openblas which may or may not have embedded lapack
  527:           'openblas': openblas_info,          # use blas_opt instead
  528:           # openblas with embedded lapack
  529:           'openblas_lapack': openblas_lapack_info, # use blas_opt instead
  530:           'openblas_clapack': openblas_clapack_info, # use blas_opt instead
  531:           'blis': blis_info,                  # use blas_opt instead
  532:           'lapack_mkl': lapack_mkl_info,      # use lapack_opt instead
  533:           'blas_mkl': blas_mkl_info,          # use blas_opt instead
  534:           'lapack_ssl2': lapack_ssl2_info,
  535:           'blas_ssl2': blas_ssl2_info,
  536:           'accelerate': accelerate_info,      # use blas_opt instead
  537:           'accelerate_lapack': accelerate_lapack_info,
  538:           'openblas64_': openblas64__info,
  539:           'openblas64__lapack': openblas64__lapack_info,
  540:           'openblas_ilp64': openblas_ilp64_info,
  541:           'openblas_ilp64_lapack': openblas_ilp64_lapack_info,
  542:           'x11': x11_info,
  543:           'fft_opt': fft_opt_info,
  544:           'fftw': fftw_info,
  545:           'fftw2': fftw2_info,
  546:           'fftw3': fftw3_info,
  547:           'dfftw': dfftw_info,
  548:           'sfftw': sfftw_info,
  549:           'fftw_threads': fftw_threads_info,
  550:           'dfftw_threads': dfftw_threads_info,
  551:           'sfftw_threads': sfftw_threads_info,
  552:           'djbfft': djbfft_info,
  553:           'blas': blas_info,                  # use blas_opt instead
  554:           'lapack': lapack_info,              # use lapack_opt instead
  555:           'lapack_src': lapack_src_info,
  556:           'blas_src': blas_src_info,
  557:           'numpy': numpy_info,
  558:           'f2py': f2py_info,
  559:           'Numeric': Numeric_info,
  560:           'numeric': Numeric_info,
  561:           'numarray': numarray_info,
  562:           'numerix': numerix_info,
  563:           'lapack_opt': lapack_opt_info,
  564:           'lapack_ilp64_opt': lapack_ilp64_opt_info,
  565:           'lapack_ilp64_plain_opt': lapack_ilp64_plain_opt_info,
  566:           'lapack64__opt': lapack64__opt_info,
  567:           'blas_opt': blas_opt_info,
  568:           'blas_ilp64_opt': blas_ilp64_opt_info,
  569:           'blas_ilp64_plain_opt': blas_ilp64_plain_opt_info,
  570:           'blas64__opt': blas64__opt_info,
  571:           'boost_python': boost_python_info,
  572:           'agg2': agg2_info,
  573:           'wx': wx_info,
  574:           'gdk_pixbuf_xlib_2': gdk_pixbuf_xlib_2_info,
  575:           'gdk-pixbuf-xlib-2.0': gdk_pixbuf_xlib_2_info,
  576:           'gdk_pixbuf_2': gdk_pixbuf_2_info,
  577:           'gdk-pixbuf-2.0': gdk_pixbuf_2_info,
  578:           'gdk': gdk_info,
  579:           'gdk_2': gdk_2_info,
  580:           'gdk-2.0': gdk_2_info,
  581:           'gdk_x11_2': gdk_x11_2_info,
  582:           'gdk-x11-2.0': gdk_x11_2_info,
  583:           'gtkp_x11_2': gtkp_x11_2_info,
  584:           'gtk+-x11-2.0': gtkp_x11_2_info,
  585:           'gtkp_2': gtkp_2_info,
  586:           'gtk+-2.0': gtkp_2_info,
  587:           'xft': xft_info,
  588:           'freetype2': freetype2_info,
  589:           'umfpack': umfpack_info,
  590:           'amd': amd_info,
  591:           }.get(name.lower(), system_info)
  592:     return cl().get_info(notfound_action)
  593: 
  594: 
  595: class NotFoundError(DistutilsError):
  596:     """Some third-party program or library is not found."""
  597: 
  598: 
  599: class AliasedOptionError(DistutilsError):
  600:     """
  601:     Aliases entries in config files should not be existing.
  602:     In section '{section}' we found multiple appearances of options {options}."""
  603: 
  604: 
  605: class AtlasNotFoundError(NotFoundError):
  606:     """
  607:     Atlas (http://github.com/math-atlas/math-atlas) libraries not found.
  608:     Directories to search for the libraries can be specified in the
  609:     numpy/distutils/site.cfg file (section [atlas]) or by setting
  610:     the ATLAS environment variable."""
  611: 
  612: 
  613: class FlameNotFoundError(NotFoundError):
  614:     """
  615:     FLAME (http://www.cs.utexas.edu/~flame/web/) libraries not found.
  616:     Directories to search for the libraries can be specified in the
  617:     numpy/distutils/site.cfg file (section [flame])."""
  618: 
  619: 
  620: class LapackNotFoundError(NotFoundError):
  621:     """
  622:     Lapack (http://www.netlib.org/lapack/) libraries not found.
  623:     Directories to search for the libraries can be specified in the
  624:     numpy/distutils/site.cfg file (section [lapack]) or by setting
  625:     the LAPACK environment variable."""
  626: 
  627: 
  628: class LapackSrcNotFoundError(LapackNotFoundError):
  629:     """
  630:     Lapack (http://www.netlib.org/lapack/) sources not found.
  631:     Directories to search for the sources can be specified in the
  632:     numpy/distutils/site.cfg file (section [lapack_src]) or by setting
  633:     the LAPACK_SRC environment variable."""
  634: 
  635: 
  636: class LapackILP64NotFoundError(NotFoundError):
  637:     """
  638:     64-bit Lapack libraries not found.
  639:     Known libraries in numpy/distutils/site.cfg file are:
  640:     openblas64_, openblas_ilp64
  641:     """
  642: 
  643: class BlasOptNotFoundError(NotFoundError):
  644:     """
  645:     Optimized (vendor) Blas libraries are not found.
  646:     Falls back to netlib Blas library which has worse performance.
  647:     A better performance should be easily gained by switching
  648:     Blas library."""
  649: 
  650: class BlasNotFoundError(NotFoundError):
  651:     """
  652:     Blas (http://www.netlib.org/blas/) libraries not found.
  653:     Directories to search for the libraries can be specified in the
  654:     numpy/distutils/site.cfg file (section [blas]) or by setting
  655:     the BLAS environment variable."""
  656: 
  657: class BlasILP64NotFoundError(NotFoundError):
  658:     """
  659:     64-bit Blas libraries not found.
  660:     Known libraries in numpy/distutils/site.cfg file are:
  661:     openblas64_, openblas_ilp64
  662:     """
  663: 
  664: class BlasSrcNotFoundError(BlasNotFoundError):
  665:     """
  666:     Blas (http://www.netlib.org/blas/) sources not found.
  667:     Directories to search for the sources can be specified in the
  668:     numpy/distutils/site.cfg file (section [blas_src]) or by setting
  669:     the BLAS_SRC environment variable."""
  670: 
  671: 
  672: class FFTWNotFoundError(NotFoundError):
  673:     """
  674:     FFTW (http://www.fftw.org/) libraries not found.
  675:     Directories to search for the libraries can be specified in the
  676:     numpy/distutils/site.cfg file (section [fftw]) or by setting
  677:     the FFTW environment variable."""
  678: 
  679: 
  680: class DJBFFTNotFoundError(NotFoundError):
  681:     """
  682:     DJBFFT (https://cr.yp.to/djbfft.html) libraries not found.
  683:     Directories to search for the libraries can be specified in the
  684:     numpy/distutils/site.cfg file (section [djbfft]) or by setting
  685:     the DJBFFT environment variable."""
  686: 
  687: 
  688: class NumericNotFoundError(NotFoundError):
  689:     """
  690:     Numeric (https://www.numpy.org/) module not found.
  691:     Get it from above location, install it, and retry setup.py."""
  692: 
  693: 
  694: class X11NotFoundError(NotFoundError):
  695:     """X11 libraries not found."""
  696: 
  697: 
  698: class UmfpackNotFoundError(NotFoundError):
  699:     """
  700:     UMFPACK sparse solver (https://www.cise.ufl.edu/research/sparse/umfpack/)
  701:     not found. Directories to search for the libraries can be specified in the
  702:     numpy/distutils/site.cfg file (section [umfpack]) or by setting
  703:     the UMFPACK environment variable."""
  704: 
  705: 
  706: class system_info:
  707: 
  708:     """ get_info() is the only public method. Don't use others.
  709:     """
  710:     dir_env_var = None
  711:     # XXX: search_static_first is disabled by default, may disappear in
  712:     # future unless it is proved to be useful.
  713:     search_static_first = 0
  714:     # The base-class section name is a random word "ALL" and is not really
  715:     # intended for general use. It cannot be None nor can it be DEFAULT as
  716:     # these break the ConfigParser. See gh-15338
  717:     section = 'ALL'
  718:     saved_results = {}
  719: 
  720:     notfounderror = NotFoundError
  721: 
  722:     def __init__(self,
  723:                   default_lib_dirs=default_lib_dirs,
  724:                   default_include_dirs=default_include_dirs,
  725:                   ):
  726:         self.__class__.info = {}
  727:         self.local_prefixes = []
  728:         defaults = {'library_dirs': os.pathsep.join(default_lib_dirs),
  729:                     'include_dirs': os.pathsep.join(default_include_dirs),
  730:                     'runtime_library_dirs': os.pathsep.join(default_runtime_dirs),
  731:                     'rpath': '',
  732:                     'src_dirs': os.pathsep.join(default_src_dirs),
  733:                     'search_static_first': str(self.search_static_first),
  734:                     'extra_compile_args': '', 'extra_link_args': ''}
  735:         self.cp = ConfigParser(defaults)
  736:         self.files = []
  737:         self.files.extend(get_standard_file('.numpy-site.cfg'))
  738:         self.files.extend(get_standard_file('site.cfg'))
  739:         self.parse_config_files()
  740: 
  741:         if self.section is not None:
  742:             self.search_static_first = self.cp.getboolean(
  743:                 self.section, 'search_static_first')
  744:         assert isinstance(self.search_static_first, int)
  745: 
  746:     def parse_config_files(self):
  747:         self.cp.read(self.files)
  748:         if not self.cp.has_section(self.section):
  749:             if self.section is not None:
  750:                 self.cp.add_section(self.section)
  751: 
  752:     def calc_libraries_info(self):
  753:         libs = self.get_libraries()
  754:         dirs = self.get_lib_dirs()
  755:         # The extensions use runtime_library_dirs
  756:         r_dirs = self.get_runtime_lib_dirs()
  757:         # Intrinsic distutils use rpath, we simply append both entries
  758:         # as though they were one entry
  759:         r_dirs.extend(self.get_runtime_lib_dirs(key='rpath'))
  760:         info = {}
  761:         for lib in libs:
  762:             i = self.check_libs(dirs, [lib])
  763:             if i is not None:
  764:                 dict_append(info, **i)
  765:             else:
  766:                 log.info('Library %s was not found. Ignoring' % (lib))
  767: 
  768:             if r_dirs:
  769:                 i = self.check_libs(r_dirs, [lib])
  770:                 if i is not None:
  771:                     # Swap library keywords found to runtime_library_dirs
  772:                     # the libraries are insisting on the user having defined
  773:                     # them using the library_dirs, and not necessarily by
  774:                     # runtime_library_dirs
  775:                     del i['libraries']
  776:                     i['runtime_library_dirs'] = i.pop('library_dirs')
  777:                     dict_append(info, **i)
  778:                 else:
  779:                     log.info('Runtime library %s was not found. Ignoring' % (lib))
  780: 
  781:         return info
  782: 
  783:     def set_info(self, **info):
  784:         if info:
  785:             lib_info = self.calc_libraries_info()
  786:             dict_append(info, **lib_info)
  787:             # Update extra information
  788:             extra_info = self.calc_extra_info()
  789:             dict_append(info, **extra_info)
  790:         self.saved_results[self.__class__.__name__] = info
  791: 
  792:     def get_option_single(self, *options):
  793:         """ Ensure that only one of `options` are found in the section
  794: 
  795:         Parameters
  796:         ----------
  797:         *options : list of str
  798:            a list of options to be found in the section (``self.section``)
  799: 
  800:         Returns
  801:         -------
  802:         str :
  803:             the option that is uniquely found in the section
  804: 
  805:         Raises
  806:         ------
  807:         AliasedOptionError :
  808:             in case more than one of the options are found
  809:         """
  810:         found = [self.cp.has_option(self.section, opt) for opt in options]
  811:         if sum(found) == 1:
  812:             return options[found.index(True)]
  813:         elif sum(found) == 0:
  814:             # nothing is found anyways
  815:             return options[0]
  816: 
  817:         # Else we have more than 1 key found
  818:         if AliasedOptionError.__doc__ is None:
  819:             raise AliasedOptionError()
  820:         raise AliasedOptionError(AliasedOptionError.__doc__.format(
  821:             section=self.section, options='[{}]'.format(', '.join(options))))
  822: 
  823: 
  824:     def has_info(self):
  825:         return self.__class__.__name__ in self.saved_results
  826: 
  827:     def calc_extra_info(self):
  828:         """ Updates the information in the current information with
  829:         respect to these flags:
  830:           extra_compile_args
  831:           extra_link_args
  832:         """
  833:         info = {}
  834:         for key in ['extra_compile_args', 'extra_link_args']:
  835:             # Get values
  836:             opt = self.cp.get(self.section, key)
  837:             opt = _shell_utils.NativeParser.split(opt)
  838:             if opt:
  839:                 tmp = {key: opt}
  840:                 dict_append(info, **tmp)
  841:         return info
  842: 
  843:     def get_info(self, notfound_action=0):
  844:         """ Return a dictionary with items that are compatible
  845:             with numpy.distutils.setup keyword arguments.
  846:         """
  847:         flag = 0
  848:         if not self.has_info():
  849:             flag = 1
  850:             log.info(self.__class__.__name__ + ':')
  851:             if hasattr(self, 'calc_info'):
  852:                 self.calc_info()
  853:             if notfound_action:
  854:                 if not self.has_info():
  855:                     if notfound_action == 1:
  856:                         warnings.warn(self.notfounderror.__doc__, stacklevel=2)
  857:                     elif notfound_action == 2:
  858:                         raise self.notfounderror(self.notfounderror.__doc__)
  859:                     else:
  860:                         raise ValueError(repr(notfound_action))
  861: 
  862:             if not self.has_info():
  863:                 log.info('  NOT AVAILABLE')
  864:                 self.set_info()
  865:             else:
  866:                 log.info('  FOUND:')
  867: 
  868:         res = self.saved_results.get(self.__class__.__name__)
  869:         if log.get_threshold() <= log.INFO and flag:
  870:             for k, v in res.items():
  871:                 v = str(v)
  872:                 if k in ['sources', 'libraries'] and len(v) > 270:
  873:                     v = v[:120] + '...\n...\n...' + v[-120:]
  874:                 log.info('    %s = %s', k, v)
  875:             log.info('')
  876: 
  877:         return copy.deepcopy(res)
  878: 
  879:     def get_paths(self, section, key):
  880:         dirs = self.cp.get(section, key).split(os.pathsep)
  881:         env_var = self.dir_env_var
  882:         if env_var:
  883:             if is_sequence(env_var):
  884:                 e0 = env_var[-1]
  885:                 for e in env_var:
  886:                     if e in os.environ:
  887:                         e0 = e
  888:                         break
  889:                 if not env_var[0] == e0:
  890:                     log.info('Setting %s=%s' % (env_var[0], e0))
  891:                 env_var = e0
  892:         if env_var and env_var in os.environ:
  893:             d = os.environ[env_var]
  894:             if d == 'None':
  895:                 log.info('Disabled %s: %s',
  896:                          self.__class__.__name__, '(%s is None)'
  897:                          % (env_var,))
  898:                 return []
  899:             if os.path.isfile(d):
  900:                 dirs = [os.path.dirname(d)] + dirs
  901:                 l = getattr(self, '_lib_names', [])
  902:                 if len(l) == 1:
  903:                     b = os.path.basename(d)
  904:                     b = os.path.splitext(b)[0]
  905:                     if b[:3] == 'lib':
  906:                         log.info('Replacing _lib_names[0]==%r with %r' \
  907:                               % (self._lib_names[0], b[3:]))
  908:                         self._lib_names[0] = b[3:]
  909:             else:
  910:                 ds = d.split(os.pathsep)
  911:                 ds2 = []
  912:                 for d in ds:
  913:                     if os.path.isdir(d):
  914:                         ds2.append(d)
  915:                         for dd in ['include', 'lib']:
  916:                             d1 = os.path.join(d, dd)
  917:                             if os.path.isdir(d1):
  918:                                 ds2.append(d1)
  919:                 dirs = ds2 + dirs
  920:         default_dirs = self.cp.get(self.section, key).split(os.pathsep)
  921:         dirs.extend(default_dirs)
  922:         ret = []
  923:         for d in dirs:
  924:             if len(d) > 0 and not os.path.isdir(d):
  925:                 warnings.warn('Specified path %s is invalid.' % d, stacklevel=2)
  926:                 continue
  927: 
  928:             if d not in ret:
  929:                 ret.append(d)
  930: 
  931:         log.debug('( %s = %s )', key, ':'.join(ret))
  932:         return ret
  933: 
  934:     def get_lib_dirs(self, key='library_dirs'):
  935:         return self.get_paths(self.section, key)
  936: 
  937:     def get_runtime_lib_dirs(self, key='runtime_library_dirs'):
  938:         path = self.get_paths(self.section, key)
  939:         if path == ['']:
  940:             path = []
  941:         return path
  942: 
  943:     def get_include_dirs(self, key='include_dirs'):
  944:         return self.get_paths(self.section, key)
  945: 
  946:     def get_src_dirs(self, key='src_dirs'):
  947:         return self.get_paths(self.section, key)
  948: 
  949:     def get_libs(self, key, default):
  950:         try:
  951:             libs = self.cp.get(self.section, key)
  952:         except NoOptionError:
  953:             if not default:
  954:                 return []
  955:             if is_string(default):
  956:                 return [default]
  957:             return default
  958:         return [b for b in [a.strip() for a in libs.split(',')] if b]
  959: 
  960:     def get_libraries(self, key='libraries'):
  961:         if hasattr(self, '_lib_names'):
  962:             return self.get_libs(key, default=self._lib_names)
  963:         else:
  964:             return self.get_libs(key, '')
  965: 
  966:     def library_extensions(self):
  967:         c = customized_ccompiler()
  968:         static_exts = []
  969:         if c.compiler_type != 'msvc':
  970:             # MSVC doesn't understand binutils
  971:             static_exts.append('.a')
  972:         if sys.platform == 'win32':
  973:             static_exts.append('.lib')  # .lib is used by MSVC and others
  974:         if self.search_static_first:
  975:             exts = static_exts + [so_ext]
  976:         else:
  977:             exts = [so_ext] + static_exts
  978:         if sys.platform == 'cygwin':
  979:             exts.append('.dll.a')
  980:         if sys.platform == 'darwin':
  981:             exts.append('.dylib')
  982:         return exts
  983: 
  984:     def check_libs(self, lib_dirs, libs, opt_libs=[]):
  985:         """If static or shared libraries are available then return
  986:         their info dictionary.
  987: 
  988:         Checks for all libraries as shared libraries first, then
  989:         static (or vice versa if self.search_static_first is True).
  990:         """
  991:         exts = self.library_extensions()
  992:         info = None
  993:         for ext in exts:
  994:             info = self._check_libs(lib_dirs, libs, opt_libs, [ext])
  995:             if info is not None:
  996:                 break
  997:         if not info:
  998:             log.info('  libraries %s not found in %s', ','.join(libs),
  999:                      lib_dirs)
 1000:         return info
 1001: 
 1002:     def check_libs2(self, lib_dirs, libs, opt_libs=[]):
 1003:         """If static or shared libraries are available then return
 1004:         their info dictionary.
 1005: 
 1006:         Checks each library for shared or static.
 1007:         """
 1008:         exts = self.library_extensions()
 1009:         info = self._check_libs(lib_dirs, libs, opt_libs, exts)
 1010:         if not info:
 1011:             log.info('  libraries %s not found in %s', ','.join(libs),
 1012:                      lib_dirs)
 1013: 
 1014:         return info
 1015: 
 1016:     def _find_lib(self, lib_dir, lib, exts):
 1017:         assert is_string(lib_dir)
 1018:         # under windows first try without 'lib' prefix
 1019:         if sys.platform == 'win32':
 1020:             lib_prefixes = ['', 'lib']
 1021:         else:
 1022:             lib_prefixes = ['lib']
 1023:         # for each library name, see if we can find a file for it.
 1024:         for ext in exts:
 1025:             for prefix in lib_prefixes:
 1026:                 p = self.combine_paths(lib_dir, prefix + lib + ext)
 1027:                 if p:
 1028:                     break
 1029:             if p:
 1030:                 assert len(p) == 1
 1031:                 # ??? splitext on p[0] would do this for cygwin
 1032:                 # doesn't seem correct
 1033:                 if ext == '.dll.a':
 1034:                     lib += '.dll'
 1035:                 if ext == '.lib':
 1036:                     lib = prefix + lib
 1037:                 return lib
 1038: 
 1039:         return False
 1040: 
 1041:     def _find_libs(self, lib_dirs, libs, exts):
 1042:         # make sure we preserve the order of libs, as it can be important
 1043:         found_dirs, found_libs = [], []
 1044:         for lib in libs:
 1045:             for lib_dir in lib_dirs:
 1046:                 found_lib = self._find_lib(lib_dir, lib, exts)
 1047:                 if found_lib:
 1048:                     found_libs.append(found_lib)
 1049:                     if lib_dir not in found_dirs:
 1050:                         found_dirs.append(lib_dir)
 1051:                     break
 1052:         return found_dirs, found_libs
 1053: 
 1054:     def _check_libs(self, lib_dirs, libs, opt_libs, exts):
 1055:         """Find mandatory and optional libs in expected paths.
 1056: 
 1057:         Missing optional libraries are silently forgotten.
 1058:         """
 1059:         if not is_sequence(lib_dirs):
 1060:             lib_dirs = [lib_dirs]
 1061:         # First, try to find the mandatory libraries
 1062:         found_dirs, found_libs = self._find_libs(lib_dirs, libs, exts)
 1063:         if len(found_libs) > 0 and len(found_libs) == len(libs):
 1064:             # Now, check for optional libraries
 1065:             opt_found_dirs, opt_found_libs = self._find_libs(lib_dirs, opt_libs, exts)
 1066:             found_libs.extend(opt_found_libs)
 1067:             for lib_dir in opt_found_dirs:
 1068:                 if lib_dir not in found_dirs:
 1069:                     found_dirs.append(lib_dir)
 1070:             info = {'libraries': found_libs, 'library_dirs': found_dirs}
 1071:             return info
 1072:         else:
 1073:             return None
 1074: 
 1075:     def combine_paths(self, *args):
 1076:         """Return a list of existing paths composed by all combinations
 1077:         of items from the arguments.
 1078:         """
 1079:         return combine_paths(*args)
 1080: 
 1081: 
 1082: class fft_opt_info(system_info):
 1083: 
 1084:     def calc_info(self):
 1085:         info = {}
 1086:         fftw_info = get_info('fftw3') or get_info('fftw2') or get_info('dfftw')
 1087:         djbfft_info = get_info('djbfft')
 1088:         if fftw_info:
 1089:             dict_append(info, **fftw_info)
 1090:             if djbfft_info:
 1091:                 dict_append(info, **djbfft_info)
 1092:             self.set_info(**info)
 1093:             return
 1094: 
 1095: 
 1096: class fftw_info(system_info):
 1097:     #variables to override
 1098:     section = 'fftw'
 1099:     dir_env_var = 'FFTW'
 1100:     notfounderror = FFTWNotFoundError
 1101:     ver_info = [{'name':'fftw3',
 1102:                     'libs':['fftw3'],
 1103:                     'includes':['fftw3.h'],
 1104:                     'macros':[('SCIPY_FFTW3_H', None)]},
 1105:                   {'name':'fftw2',
 1106:                     'libs':['rfftw', 'fftw'],
 1107:                     'includes':['fftw.h', 'rfftw.h'],
 1108:                     'macros':[('SCIPY_FFTW_H', None)]}]
 1109: 
 1110:     def calc_ver_info(self, ver_param):
 1111:         """Returns True on successful version detection, else False"""
 1112:         lib_dirs = self.get_lib_dirs()
 1113:         incl_dirs = self.get_include_dirs()
 1114: 
 1115:         opt = self.get_option_single(self.section + '_libs', 'libraries')
 1116:         libs = self.get_libs(opt, ver_param['libs'])
 1117:         info = self.check_libs(lib_dirs, libs)
 1118:         if info is not None:
 1119:             flag = 0
 1120:             for d in incl_dirs:
 1121:                 if len(self.combine_paths(d, ver_param['includes'])) \
 1122:                    == len(ver_param['includes']):
 1123:                     dict_append(info, include_dirs=[d])
 1124:                     flag = 1
 1125:                     break
 1126:             if flag:
 1127:                 dict_append(info, define_macros=ver_param['macros'])
 1128:             else:
 1129:                 info = None
 1130:         if info is not None:
 1131:             self.set_info(**info)
 1132:             return True
 1133:         else:
 1134:             log.info('  %s not found' % (ver_param['name']))
 1135:             return False
 1136: 
 1137:     def calc_info(self):
 1138:         for i in self.ver_info:
 1139:             if self.calc_ver_info(i):
 1140:                 break
 1141: 
 1142: 
 1143: class fftw2_info(fftw_info):
 1144:     #variables to override
 1145:     section = 'fftw'
 1146:     dir_env_var = 'FFTW'
 1147:     notfounderror = FFTWNotFoundError
 1148:     ver_info = [{'name':'fftw2',
 1149:                     'libs':['rfftw', 'fftw'],
 1150:                     'includes':['fftw.h', 'rfftw.h'],
 1151:                     'macros':[('SCIPY_FFTW_H', None)]}
 1152:                   ]
 1153: 
 1154: 
 1155: class fftw3_info(fftw_info):
 1156:     #variables to override
 1157:     section = 'fftw3'
 1158:     dir_env_var = 'FFTW3'
 1159:     notfounderror = FFTWNotFoundError
 1160:     ver_info = [{'name':'fftw3',
 1161:                     'libs':['fftw3'],
 1162:                     'includes':['fftw3.h'],
 1163:                     'macros':[('SCIPY_FFTW3_H', None)]},
 1164:                   ]
 1165: 
 1166: 
 1167: class fftw3_armpl_info(fftw_info):
 1168:     section = 'fftw3'
 1169:     dir_env_var = 'ARMPL_DIR'
 1170:     notfounderror = FFTWNotFoundError
 1171:     ver_info = [{'name': 'fftw3',
 1172:                     'libs': ['armpl_lp64_mp'],
 1173:                     'includes': ['fftw3.h'],
 1174:                     'macros': [('SCIPY_FFTW3_H', None)]}]
 1175: 
 1176: 
 1177: class dfftw_info(fftw_info):
 1178:     section = 'fftw'
 1179:     dir_env_var = 'FFTW'
 1180:     ver_info = [{'name':'dfftw',
 1181:                     'libs':['drfftw', 'dfftw'],
 1182:                     'includes':['dfftw.h', 'drfftw.h'],
 1183:                     'macros':[('SCIPY_DFFTW_H', None)]}]
 1184: 
 1185: 
 1186: class sfftw_info(fftw_info):
 1187:     section = 'fftw'
 1188:     dir_env_var = 'FFTW'
 1189:     ver_info = [{'name':'sfftw',
 1190:                     'libs':['srfftw', 'sfftw'],
 1191:                     'includes':['sfftw.h', 'srfftw.h'],
 1192:                     'macros':[('SCIPY_SFFTW_H', None)]}]
 1193: 
 1194: 
 1195: class fftw_threads_info(fftw_info):
 1196:     section = 'fftw'
 1197:     dir_env_var = 'FFTW'
 1198:     ver_info = [{'name':'fftw threads',
 1199:                     'libs':['rfftw_threads', 'fftw_threads'],
 1200:                     'includes':['fftw_threads.h', 'rfftw_threads.h'],
 1201:                     'macros':[('SCIPY_FFTW_THREADS_H', None)]}]
 1202: 
 1203: 
 1204: class dfftw_threads_info(fftw_info):
 1205:     section = 'fftw'
 1206:     dir_env_var = 'FFTW'
 1207:     ver_info = [{'name':'dfftw threads',
 1208:                     'libs':['drfftw_threads', 'dfftw_threads'],
 1209:                     'includes':['dfftw_threads.h', 'drfftw_threads.h'],
 1210:                     'macros':[('SCIPY_DFFTW_THREADS_H', None)]}]
 1211: 
 1212: 
 1213: class sfftw_threads_info(fftw_info):
 1214:     section = 'fftw'
 1215:     dir_env_var = 'FFTW'
 1216:     ver_info = [{'name':'sfftw threads',
 1217:                     'libs':['srfftw_threads', 'sfftw_threads'],
 1218:                     'includes':['sfftw_threads.h', 'srfftw_threads.h'],
 1219:                     'macros':[('SCIPY_SFFTW_THREADS_H', None)]}]
 1220: 
 1221: 
 1222: class djbfft_info(system_info):
 1223:     section = 'djbfft'
 1224:     dir_env_var = 'DJBFFT'
 1225:     notfounderror = DJBFFTNotFoundError
 1226: 
 1227:     def get_paths(self, section, key):
 1228:         pre_dirs = system_info.get_paths(self, section, key)
 1229:         dirs = []
 1230:         for d in pre_dirs:
 1231:             dirs.extend(self.combine_paths(d, ['djbfft']) + [d])
 1232:         return [d for d in dirs if os.path.isdir(d)]
 1233: 
 1234:     def calc_info(self):
 1235:         lib_dirs = self.get_lib_dirs()
 1236:         incl_dirs = self.get_include_dirs()
 1237:         info = None
 1238:         for d in lib_dirs:
 1239:             p = self.combine_paths(d, ['djbfft.a'])
 1240:             if p:
 1241:                 info = {'extra_objects': p}
 1242:                 break
 1243:             p = self.combine_paths(d, ['libdjbfft.a', 'libdjbfft' + so_ext])
 1244:             if p:
 1245:                 info = {'libraries': ['djbfft'], 'library_dirs': [d]}
 1246:                 break
 1247:         if info is None:
 1248:             return
 1249:         for d in incl_dirs:
 1250:             if len(self.combine_paths(d, ['fftc8.h', 'fftfreq.h'])) == 2:
 1251:                 dict_append(info, include_dirs=[d],
 1252:                             define_macros=[('SCIPY_DJBFFT_H', None)])
 1253:                 self.set_info(**info)
 1254:                 return
 1255:         return
 1256: 
 1257: 
 1258: class mkl_info(system_info):
 1259:     section = 'mkl'
 1260:     dir_env_var = 'MKLROOT'
 1261:     _lib_mkl = ['mkl_rt']
 1262: 
 1263:     def get_mkl_rootdir(self):
 1264:         mklroot = os.environ.get('MKLROOT', None)
 1265:         if mklroot is not None:
 1266:             return mklroot
 1267:         paths = os.environ.get('LD_LIBRARY_PATH', '').split(os.pathsep)
 1268:         ld_so_conf = '/etc/ld.so.conf'
 1269:         if os.path.isfile(ld_so_conf):
 1270:             with open(ld_so_conf) as f:
 1271:                 for d in f:
 1272:                     d = d.strip()
 1273:                     if d:
 1274:                         paths.append(d)
 1275:         intel_mkl_dirs = []
 1276:         for path in paths:
 1277:             path_atoms = path.split(os.sep)
 1278:             for m in path_atoms:
 1279:                 if m.startswith('mkl'):
 1280:                     d = os.sep.join(path_atoms[:path_atoms.index(m) + 2])
 1281:                     intel_mkl_dirs.append(d)
 1282:                     break
 1283:         for d in paths:
 1284:             dirs = glob(os.path.join(d, 'mkl', '*'))
 1285:             dirs += glob(os.path.join(d, 'mkl*'))
 1286:             for sub_dir in dirs:
 1287:                 if os.path.isdir(os.path.join(sub_dir, 'lib')):
 1288:                     return sub_dir
 1289:         return None
 1290: 
 1291:     def __init__(self):
 1292:         mklroot = self.get_mkl_rootdir()
 1293:         if mklroot is None:
 1294:             system_info.__init__(self)
 1295:         else:
 1296:             from .cpuinfo import cpu
 1297:             if cpu.is_Itanium():
 1298:                 plt = '64'
 1299:             elif cpu.is_Intel() and cpu.is_64bit():
 1300:                 plt = 'intel64'
 1301:             else:
 1302:                 plt = '32'
 1303:             system_info.__init__(
 1304:                 self,
 1305:                 default_lib_dirs=[os.path.join(mklroot, 'lib', plt)],
 1306:                 default_include_dirs=[os.path.join(mklroot, 'include')])
 1307: 
 1308:     def calc_info(self):
 1309:         lib_dirs = self.get_lib_dirs()
 1310:         incl_dirs = self.get_include_dirs()
 1311:         opt = self.get_option_single('mkl_libs', 'libraries')
 1312:         mkl_libs = self.get_libs(opt, self._lib_mkl)
 1313:         info = self.check_libs2(lib_dirs, mkl_libs)
 1314:         if info is None:
 1315:             return
 1316:         dict_append(info,
 1317:                     define_macros=[('SCIPY_MKL_H', None),
 1318:                                    ('HAVE_CBLAS', None)],
 1319:                     include_dirs=incl_dirs)
 1320:         if sys.platform == 'win32':
 1321:             pass  # win32 has no pthread library
 1322:         else:
 1323:             dict_append(info, libraries=['pthread'])
 1324:         self.set_info(**info)
 1325: 
 1326: 
 1327: class lapack_mkl_info(mkl_info):
 1328:     pass
 1329: 
 1330: 
 1331: class blas_mkl_info(mkl_info):
 1332:     pass
 1333: 
 1334: 
 1335: class ssl2_info(system_info):
 1336:     section = 'ssl2'
 1337:     dir_env_var = 'SSL2_DIR'
 1338:     # Multi-threaded version. Python itself must be built by Fujitsu compiler.
 1339:     _lib_ssl2 = ['fjlapackexsve']
 1340:     # Single-threaded version
 1341:     #_lib_ssl2 = ['fjlapacksve']
 1342: 
 1343:     def get_tcsds_rootdir(self):
 1344:         tcsdsroot = os.environ.get('TCSDS_PATH', None)
 1345:         if tcsdsroot is not None:
 1346:             return tcsdsroot
 1347:         return None
 1348: 
 1349:     def __init__(self):
 1350:         tcsdsroot = self.get_tcsds_rootdir()
 1351:         if tcsdsroot is None:
 1352:             system_info.__init__(self)
 1353:         else:
 1354:             system_info.__init__(
 1355:                 self,
 1356:                 default_lib_dirs=[os.path.join(tcsdsroot, 'lib64')],
 1357:                 default_include_dirs=[os.path.join(tcsdsroot,
 1358:                     'clang-comp/include')])
 1359: 
 1360:     def calc_info(self):
 1361:         tcsdsroot = self.get_tcsds_rootdir()
 1362: 
 1363:         lib_dirs = self.get_lib_dirs()
 1364:         if lib_dirs is None:
 1365:             lib_dirs = os.path.join(tcsdsroot, 'lib64')
 1366: 
 1367:         incl_dirs = self.get_include_dirs()
 1368:         if incl_dirs is None:
 1369:             incl_dirs = os.path.join(tcsdsroot, 'clang-comp/include')
 1370: 
 1371:         ssl2_libs = self.get_libs('ssl2_libs', self._lib_ssl2)
 1372: 
 1373:         info = self.check_libs2(lib_dirs, ssl2_libs)
 1374:         if info is None:
 1375:             return
 1376:         dict_append(info,
 1377:                     define_macros=[('HAVE_CBLAS', None),
 1378:                                    ('HAVE_SSL2', 1)],
 1379:                     include_dirs=incl_dirs,)
 1380:         self.set_info(**info)
 1381: 
 1382: 
 1383: class lapack_ssl2_info(ssl2_info):
 1384:     pass
 1385: 
 1386: 
 1387: class blas_ssl2_info(ssl2_info):
 1388:     pass
 1389: 
 1390: 
 1391: 
 1392: class armpl_info(system_info):
 1393:     section = 'armpl'
 1394:     dir_env_var = 'ARMPL_DIR'
 1395:     _lib_armpl = ['armpl_lp64_mp']
 1396: 
 1397:     def calc_info(self):
 1398:         lib_dirs = self.get_lib_dirs()
 1399:         incl_dirs = self.get_include_dirs()
 1400:         armpl_libs = self.get_libs('armpl_libs', self._lib_armpl)
 1401:         info = self.check_libs2(lib_dirs, armpl_libs)
 1402:         if info is None:
 1403:             return
 1404:         dict_append(info,
 1405:                     define_macros=[('SCIPY_MKL_H', None),
 1406:                                    ('HAVE_CBLAS', None)],
 1407:                     include_dirs=incl_dirs)
 1408:         self.set_info(**info)
 1409: 
 1410: class lapack_armpl_info(armpl_info):
 1411:     pass
 1412: 
 1413: class blas_armpl_info(armpl_info):
 1414:     pass
 1415: 
 1416: 
 1417: class atlas_info(system_info):
 1418:     section = 'atlas'
 1419:     dir_env_var = 'ATLAS'
 1420:     _lib_names = ['f77blas', 'cblas']
 1421:     if sys.platform[:7] == 'freebsd':
 1422:         _lib_atlas = ['atlas_r']
 1423:         _lib_lapack = ['alapack_r']
 1424:     else:
 1425:         _lib_atlas = ['atlas']
 1426:         _lib_lapack = ['lapack']
 1427: 
 1428:     notfounderror = AtlasNotFoundError
 1429: 
 1430:     def get_paths(self, section, key):
 1431:         pre_dirs = system_info.get_paths(self, section, key)
 1432:         dirs = []
 1433:         for d in pre_dirs:
 1434:             dirs.extend(self.combine_paths(d, ['atlas*', 'ATLAS*',
 1435:                                          'sse', '3dnow', 'sse2']) + [d])
 1436:         return [d for d in dirs if os.path.isdir(d)]
 1437: 
 1438:     def calc_info(self):
 1439:         lib_dirs = self.get_lib_dirs()
 1440:         info = {}
 1441:         opt = self.get_option_single('atlas_libs', 'libraries')
 1442:         atlas_libs = self.get_libs(opt, self._lib_names + self._lib_atlas)
 1443:         lapack_libs = self.get_libs('lapack_libs', self._lib_lapack)
 1444:         atlas = None
 1445:         lapack = None
 1446:         atlas_1 = None
 1447:         for d in lib_dirs:
 1448:             atlas = self.check_libs2(d, atlas_libs, [])
 1449:             if atlas is not None:
 1450:                 lib_dirs2 = [d] + self.combine_paths(d, ['atlas*', 'ATLAS*'])
 1451:                 lapack = self.check_libs2(lib_dirs2, lapack_libs, [])
 1452:                 if lapack is not None:
 1453:                     break
 1454:             if atlas:
 1455:                 atlas_1 = atlas
 1456:         log.info(self.__class__)
 1457:         if atlas is None:
 1458:             atlas = atlas_1
 1459:         if atlas is None:
 1460:             return
 1461:         include_dirs = self.get_include_dirs()
 1462:         h = (self.combine_paths(lib_dirs + include_dirs, 'cblas.h') or [None])
 1463:         h = h[0]
 1464:         if h:
 1465:             h = os.path.dirname(h)
 1466:             dict_append(info, include_dirs=[h])
 1467:         info['language'] = 'c'
 1468:         if lapack is not None:
 1469:             dict_append(info, **lapack)
 1470:             dict_append(info, **atlas)
 1471:         elif 'lapack_atlas' in atlas['libraries']:
 1472:             dict_append(info, **atlas)
 1473:             dict_append(info,
 1474:                         define_macros=[('ATLAS_WITH_LAPACK_ATLAS', None)])
 1475:             self.set_info(**info)
 1476:             return
 1477:         else:
 1478:             dict_append(info, **atlas)
 1479:             dict_append(info, define_macros=[('ATLAS_WITHOUT_LAPACK', None)])
 1480:             message = textwrap.dedent("""
 1481:                 *********************************************************************
 1482:                     Could not find lapack library within the ATLAS installation.
 1483:                 *********************************************************************
 1484:                 """)
 1485:             warnings.warn(message, stacklevel=2)
 1486:             self.set_info(**info)
 1487:             return
 1488: 
 1489:         # Check if lapack library is complete, only warn if it is not.
 1490:         lapack_dir = lapack['library_dirs'][0]
 1491:         lapack_name = lapack['libraries'][0]
 1492:         lapack_lib = None
 1493:         lib_prefixes = ['lib']
 1494:         if sys.platform == 'win32':
 1495:             lib_prefixes.append('')
 1496:         for e in self.library_extensions():
 1497:             for prefix in lib_prefixes:
 1498:                 fn = os.path.join(lapack_dir, prefix + lapack_name + e)
 1499:                 if os.path.exists(fn):
 1500:                     lapack_lib = fn
 1501:                     break
 1502:             if lapack_lib:
 1503:                 break
 1504:         if lapack_lib is not None:
 1505:             sz = os.stat(lapack_lib)[6]
 1506:             if sz <= 4000 * 1024:
 1507:                 message = textwrap.dedent("""
 1508:                     *********************************************************************
 1509:                         Lapack library (from ATLAS) is probably incomplete:
 1510:                           size of %s is %sk (expected >4000k)
 1511: 
 1512:                         Follow the instructions in the KNOWN PROBLEMS section of the file
 1513:                         numpy/INSTALL.txt.
 1514:                     *********************************************************************
 1515:                     """) % (lapack_lib, sz / 1024)
 1516:                 warnings.warn(message, stacklevel=2)
 1517:             else:
 1518:                 info['language'] = 'f77'
 1519: 
 1520:         atlas_version, atlas_extra_info = get_atlas_version(**atlas)
 1521:         dict_append(info, **atlas_extra_info)
 1522: 
 1523:         self.set_info(**info)
 1524: 
 1525: 
 1526: class atlas_blas_info(atlas_info):
 1527:     _lib_names = ['f77blas', 'cblas']
 1528: 
 1529:     def calc_info(self):
 1530:         lib_dirs = self.get_lib_dirs()
 1531:         info = {}
 1532:         opt = self.get_option_single('atlas_libs', 'libraries')
 1533:         atlas_libs = self.get_libs(opt, self._lib_names + self._lib_atlas)
 1534:         atlas = self.check_libs2(lib_dirs, atlas_libs, [])
 1535:         if atlas is None:
 1536:             return
 1537:         include_dirs = self.get_include_dirs()
 1538:         h = (self.combine_paths(lib_dirs + include_dirs, 'cblas.h') or [None])
 1539:         h = h[0]
 1540:         if h:
 1541:             h = os.path.dirname(h)
 1542:             dict_append(info, include_dirs=[h])
 1543:         info['language'] = 'c'
 1544:         info['define_macros'] = [('HAVE_CBLAS', None)]
 1545: 
 1546:         atlas_version, atlas_extra_info = get_atlas_version(**atlas)
 1547:         dict_append(atlas, **atlas_extra_info)
 1548: 
 1549:         dict_append(info, **atlas)
 1550: 
 1551:         self.set_info(**info)
 1552:         return
 1553: 
 1554: 
 1555: class atlas_threads_info(atlas_info):
 1556:     dir_env_var = ['PTATLAS', 'ATLAS']
 1557:     _lib_names = ['ptf77blas', 'ptcblas']
 1558: 
 1559: 
 1560: class atlas_blas_threads_info(atlas_blas_info):
 1561:     dir_env_var = ['PTATLAS', 'ATLAS']
 1562:     _lib_names = ['ptf77blas', 'ptcblas']
 1563: 
 1564: 
 1565: class lapack_atlas_info(atlas_info):
 1566:     _lib_names = ['lapack_atlas'] + atlas_info._lib_names
 1567: 
 1568: 
 1569: class lapack_atlas_threads_info(atlas_threads_info):
 1570:     _lib_names = ['lapack_atlas'] + atlas_threads_info._lib_names
 1571: 
 1572: 
 1573: class atlas_3_10_info(atlas_info):
 1574:     _lib_names = ['satlas']
 1575:     _lib_atlas = _lib_names
 1576:     _lib_lapack = _lib_names
 1577: 
 1578: 
 1579: class atlas_3_10_blas_info(atlas_3_10_info):
 1580:     _lib_names = ['satlas']
 1581: 
 1582:     def calc_info(self):
 1583:         lib_dirs = self.get_lib_dirs()
 1584:         info = {}
 1585:         opt = self.get_option_single('atlas_lib', 'libraries')
 1586:         atlas_libs = self.get_libs(opt, self._lib_names)
 1587:         atlas = self.check_libs2(lib_dirs, atlas_libs, [])
 1588:         if atlas is None:
 1589:             return
 1590:         include_dirs = self.get_include_dirs()
 1591:         h = (self.combine_paths(lib_dirs + include_dirs, 'cblas.h') or [None])
 1592:         h = h[0]
 1593:         if h:
 1594:             h = os.path.dirname(h)
 1595:             dict_append(info, include_dirs=[h])
 1596:         info['language'] = 'c'
 1597:         info['define_macros'] = [('HAVE_CBLAS', None)]
 1598: 
 1599:         atlas_version, atlas_extra_info = get_atlas_version(**atlas)
 1600:         dict_append(atlas, **atlas_extra_info)
 1601: 
 1602:         dict_append(info, **atlas)
 1603: 
 1604:         self.set_info(**info)
 1605:         return
 1606: 
 1607: 
 1608: class atlas_3_10_threads_info(atlas_3_10_info):
 1609:     dir_env_var = ['PTATLAS', 'ATLAS']
 1610:     _lib_names = ['tatlas']
 1611:     _lib_atlas = _lib_names
 1612:     _lib_lapack = _lib_names
 1613: 
 1614: 
 1615: class atlas_3_10_blas_threads_info(atlas_3_10_blas_info):
 1616:     dir_env_var = ['PTATLAS', 'ATLAS']
 1617:     _lib_names = ['tatlas']
 1618: 
 1619: 
 1620: class lapack_atlas_3_10_info(atlas_3_10_info):
 1621:     pass
 1622: 
 1623: 
 1624: class lapack_atlas_3_10_threads_info(atlas_3_10_threads_info):
 1625:     pass
 1626: 
 1627: 
 1628: class lapack_info(system_info):
 1629:     section = 'lapack'
 1630:     dir_env_var = 'LAPACK'
 1631:     _lib_names = ['lapack']
 1632:     notfounderror = LapackNotFoundError
 1633: 
 1634:     def calc_info(self):
 1635:         lib_dirs = self.get_lib_dirs()
 1636: 
 1637:         opt = self.get_option_single('lapack_libs', 'libraries')
 1638:         lapack_libs = self.get_libs(opt, self._lib_names)
 1639:         info = self.check_libs(lib_dirs, lapack_libs, [])
 1640:         if info is None:
 1641:             return
 1642:         info['language'] = 'f77'
 1643:         self.set_info(**info)
 1644: 
 1645: 
 1646: class lapack_src_info(system_info):
 1647:     # LAPACK_SRC is deprecated, please do not use this!
 1648:     # Build or install a BLAS library via your package manager or from
 1649:     # source separately.
 1650:     section = 'lapack_src'
 1651:     dir_env_var = 'LAPACK_SRC'
 1652:     notfounderror = LapackSrcNotFoundError
 1653: 
 1654:     def get_paths(self, section, key):
 1655:         pre_dirs = system_info.get_paths(self, section, key)
 1656:         dirs = []
 1657:         for d in pre_dirs:
 1658:             dirs.extend([d] + self.combine_paths(d, ['LAPACK*/SRC', 'SRC']))
 1659:         return [d for d in dirs if os.path.isdir(d)]
 1660: 
 1661:     def calc_info(self):
 1662:         src_dirs = self.get_src_dirs()
 1663:         src_dir = ''
 1664:         for d in src_dirs:
 1665:             if os.path.isfile(os.path.join(d, 'dgesv.f')):
 1666:                 src_dir = d
 1667:                 break
 1668:         if not src_dir:
 1669:             #XXX: Get sources from netlib. May be ask first.
 1670:             return
 1671:         # The following is extracted from LAPACK-3.0/SRC/Makefile.
 1672:         # Added missing names from lapack-lite-3.1.1/SRC/Makefile
 1673:         # while keeping removed names for Lapack-3.0 compatibility.
 1674:         allaux = '''
 1675:         ilaenv ieeeck lsame lsamen xerbla
 1676:         iparmq
 1677:         '''  # *.f
 1678:         laux = '''
 1679:         bdsdc bdsqr disna labad lacpy ladiv lae2 laebz laed0 laed1
 1680:         laed2 laed3 laed4 laed5 laed6 laed7 laed8 laed9 laeda laev2
 1681:         lagtf lagts lamch lamrg lanst lapy2 lapy3 larnv larrb larre
 1682:         larrf lartg laruv las2 lascl lasd0 lasd1 lasd2 lasd3 lasd4
 1683:         lasd5 lasd6 lasd7 lasd8 lasd9 lasda lasdq lasdt laset lasq1
 1684:         lasq2 lasq3 lasq4 lasq5 lasq6 lasr lasrt lassq lasv2 pttrf
 1685:         stebz stedc steqr sterf
 1686: 
 1687:         larra larrc larrd larr larrk larrj larrr laneg laisnan isnan
 1688:         lazq3 lazq4
 1689:         '''  # [s|d]*.f
 1690:         lasrc = '''
 1691:         gbbrd gbcon gbequ gbrfs gbsv gbsvx gbtf2 gbtrf gbtrs gebak
 1692:         gebal gebd2 gebrd gecon geequ gees geesx geev geevx gegs gegv
 1693:         gehd2 gehrd gelq2 gelqf gels gelsd gelss gelsx gelsy geql2
 1694:         geqlf geqp3 geqpf geqr2 geqrf gerfs gerq2 gerqf gesc2 gesdd
 1695:         gesv gesvd gesvx getc2 getf2 getrf getri getrs ggbak ggbal
 1696:         gges ggesx ggev ggevx ggglm gghrd gglse ggqrf ggrqf ggsvd
 1697:         ggsvp gtcon gtrfs gtsv gtsvx gttrf gttrs gtts2 hgeqz hsein
 1698:         hseqr labrd lacon laein lags2 lagtm lahqr lahrd laic1 lals0
 1699:         lalsa lalsd langb lange langt lanhs lansb lansp lansy lantb
 1700:         lantp lantr lapll lapmt laqgb laqge laqp2 laqps laqsb laqsp
 1701:         laqsy lar1v lar2v larf larfb larfg larft larfx largv larrv
 1702:         lartv larz larzb larzt laswp lasyf latbs latdf latps latrd
 1703:         latrs latrz latzm lauu2 lauum pbcon pbequ pbrfs pbstf pbsv
 1704:         pbsvx pbtf2 pbtrf pbtrs pocon poequ porfs posv posvx potf2
 1705:         potrf potri potrs ppcon ppequ pprfs ppsv ppsvx pptrf pptri
 1706:         pptrs ptcon pteqr ptrfs ptsv ptsvx pttrs ptts2 spcon sprfs
 1707:         spsv spsvx sptrf sptri sptrs stegr stein sycon syrfs sysv
 1708:         sysvx sytf2 sytrf sytri sytrs tbcon tbrfs tbtrs tgevc tgex2
 1709:         tgexc tgsen tgsja tgsna tgsy2 tgsyl tpcon tprfs tptri tptrs
 1710:         trcon trevc trexc trrfs trsen trsna trsyl trti2 trtri trtrs
 1711:         tzrqf tzrzf
 1712: 
 1713:         lacn2 lahr2 stemr laqr0 laqr1 laqr2 laqr3 laqr4 laqr5
 1714:         '''  # [s|c|d|z]*.f
 1715:         sd_lasrc = '''
 1716:         laexc lag2 lagv2 laln2 lanv2 laqtr lasy2 opgtr opmtr org2l
 1717:         org2r orgbr orghr orgl2 orglq orgql orgqr orgr2 orgrq orgtr
 1718:         orm2l orm2r ormbr ormhr orml2 ormlq ormql ormqr ormr2 ormr3
 1719:         ormrq ormrz ormtr rscl sbev sbevd sbevx sbgst sbgv sbgvd sbgvx
 1720:         sbtrd spev spevd spevx spgst spgv spgvd spgvx sptrd stev stevd
 1721:         stevr stevx syev syevd syevr syevx sygs2 sygst sygv sygvd
 1722:         sygvx sytd2 sytrd
 1723:         '''  # [s|d]*.f
 1724:         cz_lasrc = '''
 1725:         bdsqr hbev hbevd hbevx hbgst hbgv hbgvd hbgvx hbtrd hecon heev
 1726:         heevd heevr heevx hegs2 hegst hegv hegvd hegvx herfs hesv
 1727:         hesvx hetd2 hetf2 hetrd hetrf hetri hetrs hpcon hpev hpevd
 1728:         hpevx hpgst hpgv hpgvd hpgvx hprfs hpsv hpsvx hptrd hptrf
 1729:         hptri hptrs lacgv lacp2 lacpy lacrm lacrt ladiv laed0 laed7
 1730:         laed8 laesy laev2 lahef lanhb lanhe lanhp lanht laqhb laqhe
 1731:         laqhp larcm larnv lartg lascl laset lasr lassq pttrf rot spmv
 1732:         spr stedc steqr symv syr ung2l ung2r ungbr unghr ungl2 unglq
 1733:         ungql ungqr ungr2 ungrq ungtr unm2l unm2r unmbr unmhr unml2
 1734:         unmlq unmql unmqr unmr2 unmr3 unmrq unmrz unmtr upgtr upmtr
 1735:         '''  # [c|z]*.f
 1736:         #######
 1737:         sclaux = laux + ' econd '                  # s*.f
 1738:         dzlaux = laux + ' secnd '                  # d*.f
 1739:         slasrc = lasrc + sd_lasrc                  # s*.f
 1740:         dlasrc = lasrc + sd_lasrc                  # d*.f
 1741:         clasrc = lasrc + cz_lasrc + ' srot srscl '  # c*.f
 1742:         zlasrc = lasrc + cz_lasrc + ' drot drscl '  # z*.f
 1743:         oclasrc = ' icmax1 scsum1 '                # *.f
 1744:         ozlasrc = ' izmax1 dzsum1 '                # *.f
 1745:         sources = ['s%s.f' % f for f in (sclaux + slasrc).split()] \
 1746:                   + ['d%s.f' % f for f in (dzlaux + dlasrc).split()] \
 1747:                   + ['c%s.f' % f for f in (clasrc).split()] \
 1748:                   + ['z%s.f' % f for f in (zlasrc).split()] \
 1749:                   + ['%s.f' % f for f in (allaux + oclasrc + ozlasrc).split()]
 1750:         sources = [os.path.join(src_dir, f) for f in sources]
 1751:         # Lapack 3.1:
 1752:         src_dir2 = os.path.join(src_dir, '..', 'INSTALL')
 1753:         sources += [os.path.join(src_dir2, p + 'lamch.f') for p in 'sdcz']
 1754:         # Lapack 3.2.1:
 1755:         sources += [os.path.join(src_dir, p + 'larfp.f') for p in 'sdcz']
 1756:         sources += [os.path.join(src_dir, 'ila' + p + 'lr.f') for p in 'sdcz']
 1757:         sources += [os.path.join(src_dir, 'ila' + p + 'lc.f') for p in 'sdcz']
 1758:         # Should we check here actual existence of source files?
 1759:         # Yes, the file listing is different between 3.0 and 3.1
 1760:         # versions.
 1761:         sources = [f for f in sources if os.path.isfile(f)]
 1762:         info = {'sources': sources, 'language': 'f77'}
 1763:         self.set_info(**info)
 1764: 
 1765: atlas_version_c_text = r'''
 1766: /* This file is generated from numpy/distutils/system_info.py */
 1767: void ATL_buildinfo(void);
 1768: int main(void) {
 1769:   ATL_buildinfo();
 1770:   return 0;
 1771: }
 1772: '''
 1773: 
 1774: _cached_atlas_version = {}
 1775: 
 1776: 
 1777: def get_atlas_version(**config):
 1778:     libraries = config.get('libraries', [])
 1779:     library_dirs = config.get('library_dirs', [])
 1780:     key = (tuple(libraries), tuple(library_dirs))
 1781:     if key in _cached_atlas_version:
 1782:         return _cached_atlas_version[key]
 1783:     c = cmd_config(Distribution())
 1784:     atlas_version = None
 1785:     info = {}
 1786:     try:
 1787:         s, o = c.get_output(atlas_version_c_text,
 1788:                             libraries=libraries, library_dirs=library_dirs,
 1789:                            )
 1790:         if s and re.search(r'undefined reference to `_gfortran', o, re.M):
 1791:             s, o = c.get_output(atlas_version_c_text,
 1792:                                 libraries=libraries + ['gfortran'],
 1793:                                 library_dirs=library_dirs,
 1794:                                )
 1795:             if not s:
 1796:                 warnings.warn(textwrap.dedent("""
 1797:                     *****************************************************
 1798:                     Linkage with ATLAS requires gfortran. Use
 1799: 
 1800:                       python setup.py config_fc --fcompiler=gnu95 ...
 1801: 
 1802:                     when building extension libraries that use ATLAS.
 1803:                     Make sure that -lgfortran is used for C++ extensions.
 1804:                     *****************************************************
 1805:                     """), stacklevel=2)
 1806:                 dict_append(info, language='f90',
 1807:                             define_macros=[('ATLAS_REQUIRES_GFORTRAN', None)])
 1808:     except Exception:  # failed to get version from file -- maybe on Windows
 1809:         # look at directory name
 1810:         for o in library_dirs:
 1811:             m = re.search(r'ATLAS_(?P<version>\d+[.]\d+[.]\d+)_', o)
 1812:             if m:
 1813:                 atlas_version = m.group('version')
 1814:             if atlas_version is not None:
 1815:                 break
 1816: 
 1817:         # final choice --- look at ATLAS_VERSION environment
 1818:         #   variable
 1819:         if atlas_version is None:
 1820:             atlas_version = os.environ.get('ATLAS_VERSION', None)
 1821:         if atlas_version:
 1822:             dict_append(info, define_macros=[(
 1823:                 'ATLAS_INFO', _c_string_literal(atlas_version))
 1824:             ])
 1825:         else:
 1826:             dict_append(info, define_macros=[('NO_ATLAS_INFO', -1)])
 1827:         return atlas_version or '?.?.?', info
 1828: 
 1829:     if not s:
 1830:         m = re.search(r'ATLAS version (?P<version>\d+[.]\d+[.]\d+)', o)
 1831:         if m:
 1832:             atlas_version = m.group('version')
 1833:     if atlas_version is None:
 1834:         if re.search(r'undefined symbol: ATL_buildinfo', o, re.M):
 1835:             atlas_version = '3.2.1_pre3.3.6'
 1836:         else:
 1837:             log.info('Status: %d', s)
 1838:             log.info('Output: %s', o)
 1839: 
 1840:     elif atlas_version == '3.2.1_pre3.3.6':
 1841:         dict_append(info, define_macros=[('NO_ATLAS_INFO', -2)])
 1842:     else:
 1843:         dict_append(info, define_macros=[(
 1844:             'ATLAS_INFO', _c_string_literal(atlas_version))
 1845:         ])
 1846:     result = _cached_atlas_version[key] = atlas_version, info
 1847:     return result
 1848: 
 1849: 
 1850: class lapack_opt_info(system_info):
 1851:     notfounderror = LapackNotFoundError
 1852: 
 1853:     # List of all known LAPACK libraries, in the default order
 1854:     lapack_order = ['armpl', 'mkl', 'ssl2', 'openblas', 'flame',
 1855:                     'accelerate', 'atlas', 'lapack']
 1856:     order_env_var_name = 'NPY_LAPACK_ORDER'
 1857: 
 1858:     def _calc_info_armpl(self):
 1859:         info = get_info('lapack_armpl')
 1860:         if info:
 1861:             self.set_info(**info)
 1862:             return True
 1863:         return False
 1864: 
 1865:     def _calc_info_mkl(self):
 1866:         info = get_info('lapack_mkl')
 1867:         if info:
 1868:             self.set_info(**info)
 1869:             return True
 1870:         return False
 1871: 
 1872:     def _calc_info_ssl2(self):
 1873:         info = get_info('lapack_ssl2')
 1874:         if info:
 1875:             self.set_info(**info)
 1876:             return True
 1877:         return False
 1878: 
 1879:     def _calc_info_openblas(self):
 1880:         info = get_info('openblas_lapack')
 1881:         if info:
 1882:             self.set_info(**info)
 1883:             return True
 1884:         info = get_info('openblas_clapack')
 1885:         if info:
 1886:             self.set_info(**info)
 1887:             return True
 1888:         return False
 1889: 
 1890:     def _calc_info_flame(self):
 1891:         info = get_info('flame')
 1892:         if info:
 1893:             self.set_info(**info)
 1894:             return True
 1895:         return False
 1896: 
 1897:     def _calc_info_atlas(self):
 1898:         info = get_info('atlas_3_10_threads')
 1899:         if not info:
 1900:             info = get_info('atlas_3_10')
 1901:         if not info:
 1902:             info = get_info('atlas_threads')
 1903:         if not info:
 1904:             info = get_info('atlas')
 1905:         if info:
 1906:             # Figure out if ATLAS has lapack...
 1907:             # If not we need the lapack library, but not BLAS!
 1908:             l = info.get('define_macros', [])
 1909:             if ('ATLAS_WITH_LAPACK_ATLAS', None) in l \
 1910:                or ('ATLAS_WITHOUT_LAPACK', None) in l:
 1911:                 # Get LAPACK (with possible warnings)
 1912:                 # If not found we don't accept anything
 1913:                 # since we can't use ATLAS with LAPACK!
 1914:                 lapack_info = self._get_info_lapack()
 1915:                 if not lapack_info:
 1916:                     return False
 1917:                 dict_append(info, **lapack_info)
 1918:             self.set_info(**info)
 1919:             return True
 1920:         return False
 1921: 
 1922:     def _calc_info_accelerate(self):
 1923:         info = get_info('accelerate')
 1924:         if info:
 1925:             self.set_info(**info)
 1926:             return True
 1927:         return False
 1928: 
 1929:     def _get_info_blas(self):
 1930:         # Default to get the optimized BLAS implementation
 1931:         info = get_info('blas_opt')
 1932:         if not info:
 1933:             warnings.warn(BlasNotFoundError.__doc__ or '', stacklevel=3)
 1934:             info_src = get_info('blas_src')
 1935:             if not info_src:
 1936:                 warnings.warn(BlasSrcNotFoundError.__doc__ or '', stacklevel=3)
 1937:                 return {}
 1938:             dict_append(info, libraries=[('fblas_src', info_src)])
 1939:         return info
 1940: 
 1941:     def _get_info_lapack(self):
 1942:         info = get_info('lapack')
 1943:         if not info:
 1944:             warnings.warn(LapackNotFoundError.__doc__ or '', stacklevel=3)
 1945:             info_src = get_info('lapack_src')
 1946:             if not info_src:
 1947:                 warnings.warn(LapackSrcNotFoundError.__doc__ or '', stacklevel=3)
 1948:                 return {}
 1949:             dict_append(info, libraries=[('flapack_src', info_src)])
 1950:         return info
 1951: 
 1952:     def _calc_info_lapack(self):
 1953:         info = self._get_info_lapack()
 1954:         if info:
 1955:             info_blas = self._get_info_blas()
 1956:             dict_append(info, **info_blas)
 1957:             dict_append(info, define_macros=[('NO_ATLAS_INFO', 1)])
 1958:             self.set_info(**info)
 1959:             return True
 1960:         return False
 1961: 
 1962:     def _calc_info_from_envvar(self):
 1963:         info = {}
 1964:         info['language'] = 'f77'
 1965:         info['libraries'] = []
 1966:         info['include_dirs'] = []
 1967:         info['define_macros'] = []
 1968:         info['extra_link_args'] = os.environ['NPY_LAPACK_LIBS'].split()
 1969:         self.set_info(**info)
 1970:         return True
 1971: 
 1972:     def _calc_info(self, name):
 1973:         return getattr(self, '_calc_info_{}'.format(name))()
 1974: 
 1975:     def calc_info(self):
 1976:         lapack_order, unknown_order = _parse_env_order(self.lapack_order, self.order_env_var_name)
 1977:         if len(unknown_order) > 0:
 1978:             raise ValueError("lapack_opt_info user defined "
 1979:                              "LAPACK order has unacceptable "
 1980:                              "values: {}".format(unknown_order))
 1981: 
 1982:         if 'NPY_LAPACK_LIBS' in os.environ:
 1983:             # Bypass autodetection, set language to F77 and use env var linker
 1984:             # flags directly
 1985:             self._calc_info_from_envvar()
 1986:             return
 1987: 
 1988:         for lapack in lapack_order:
 1989:             if self._calc_info(lapack):
 1990:                 return
 1991: 
 1992:         if 'lapack' not in lapack_order:
 1993:             # Since the user may request *not* to use any library, we still need
 1994:             # to raise warnings to signal missing packages!
 1995:             warnings.warn(LapackNotFoundError.__doc__ or '', stacklevel=2)
 1996:             warnings.warn(LapackSrcNotFoundError.__doc__ or '', stacklevel=2)
 1997: 
 1998: 
 1999: class _ilp64_opt_info_mixin:
 2000:     symbol_suffix = None
 2001:     symbol_prefix = None
 2002: 
 2003:     def _check_info(self, info):
 2004:         macros = dict(info.get('define_macros', []))
 2005:         prefix = macros.get('BLAS_SYMBOL_PREFIX', '')
 2006:         suffix = macros.get('BLAS_SYMBOL_SUFFIX', '')
 2007: 
 2008:         if self.symbol_prefix not in (None, prefix):
 2009:             return False
 2010: 
 2011:         if self.symbol_suffix not in (None, suffix):
 2012:             return False
 2013: 
 2014:         return bool(info)
 2015: 
 2016: 
 2017: class lapack_ilp64_opt_info(lapack_opt_info, _ilp64_opt_info_mixin):
 2018:     notfounderror = LapackILP64NotFoundError
 2019:     lapack_order = ['openblas64_', 'openblas_ilp64', 'accelerate']
 2020:     order_env_var_name = 'NPY_LAPACK_ILP64_ORDER'
 2021: 
 2022:     def _calc_info(self, name):
 2023:         print('lapack_ilp64_opt_info._calc_info(name=%s)' % (name))
 2024:         info = get_info(name + '_lapack')
 2025:         if self._check_info(info):
 2026:             self.set_info(**info)
 2027:             return True
 2028:         else:
 2029:             print('%s_lapack does not exist' % (name))
 2030:         return False
 2031: 
 2032: 
 2033: class lapack_ilp64_plain_opt_info(lapack_ilp64_opt_info):
 2034:     # Same as lapack_ilp64_opt_info, but fix symbol names
 2035:     symbol_prefix = ''
 2036:     symbol_suffix = ''
 2037: 
 2038: 
 2039: class lapack64__opt_info(lapack_ilp64_opt_info):
 2040:     symbol_prefix = ''
 2041:     symbol_suffix = '64_'
 2042: 
 2043: 
 2044: class blas_opt_info(system_info):
 2045:     notfounderror = BlasNotFoundError
 2046:     # List of all known BLAS libraries, in the default order
 2047: 
 2048:     blas_order = ['armpl', 'mkl', 'ssl2', 'blis', 'openblas',
 2049:                   'accelerate', 'atlas', 'blas']
 2050:     order_env_var_name = 'NPY_BLAS_ORDER'
 2051: 
 2052:     def _calc_info_armpl(self):
 2053:         info = get_info('blas_armpl')
 2054:         if info:
 2055:             self.set_info(**info)
 2056:             return True
 2057:         return False
 2058: 
 2059:     def _calc_info_mkl(self):
 2060:         info = get_info('blas_mkl')
 2061:         if info:
 2062:             self.set_info(**info)
 2063:             return True
 2064:         return False
 2065: 
 2066:     def _calc_info_ssl2(self):
 2067:         info = get_info('blas_ssl2')
 2068:         if info:
 2069:             self.set_info(**info)
 2070:             return True
 2071:         return False
 2072: 
 2073:     def _calc_info_blis(self):
 2074:         info = get_info('blis')
 2075:         if info:
 2076:             self.set_info(**info)
 2077:             return True
 2078:         return False
 2079: 
 2080:     def _calc_info_openblas(self):
 2081:         info = get_info('openblas')
 2082:         if info:
 2083:             self.set_info(**info)
 2084:             return True
 2085:         return False
 2086: 
 2087:     def _calc_info_atlas(self):
 2088:         info = get_info('atlas_3_10_blas_threads')
 2089:         if not info:
 2090:             info = get_info('atlas_3_10_blas')
 2091:         if not info:
 2092:             info = get_info('atlas_blas_threads')
 2093:         if not info:
 2094:             info = get_info('atlas_blas')
 2095:         if info:
 2096:             self.set_info(**info)
 2097:             return True
 2098:         return False
 2099: 
 2100:     def _calc_info_accelerate(self):
 2101:         info = get_info('accelerate')
 2102:         if info:
 2103:             self.set_info(**info)
 2104:             return True
 2105:         return False
 2106: 
 2107:     def _calc_info_blas(self):
 2108:         # Warn about a non-optimized BLAS library
 2109:         warnings.warn(BlasOptNotFoundError.__doc__ or '', stacklevel=3)
 2110:         info = {}
 2111:         dict_append(info, define_macros=[('NO_ATLAS_INFO', 1)])
 2112: 
 2113:         blas = get_info('blas')
 2114:         if blas:
 2115:             dict_append(info, **blas)
 2116:         else:
 2117:             # Not even BLAS was found!
 2118:             warnings.warn(BlasNotFoundError.__doc__ or '', stacklevel=3)
 2119: 
 2120:             blas_src = get_info('blas_src')
 2121:             if not blas_src:
 2122:                 warnings.warn(BlasSrcNotFoundError.__doc__ or '', stacklevel=3)
 2123:                 return False
 2124:             dict_append(info, libraries=[('fblas_src', blas_src)])
 2125: 
 2126:         self.set_info(**info)
 2127:         return True
 2128: 
 2129:     def _calc_info_from_envvar(self):
 2130:         info = {}
 2131:         info['language'] = 'f77'
 2132:         info['libraries'] = []
 2133:         info['include_dirs'] = []
 2134:         info['define_macros'] = []
 2135:         info['extra_link_args'] = os.environ['NPY_BLAS_LIBS'].split()
 2136:         if 'NPY_CBLAS_LIBS' in os.environ:
 2137:             info['define_macros'].append(('HAVE_CBLAS', None))
 2138:             info['extra_link_args'].extend(
 2139:                                         os.environ['NPY_CBLAS_LIBS'].split())
 2140:         self.set_info(**info)
 2141:         return True
 2142: 
 2143:     def _calc_info(self, name):
 2144:         return getattr(self, '_calc_info_{}'.format(name))()
 2145: 
 2146:     def calc_info(self):
 2147:         blas_order, unknown_order = _parse_env_order(self.blas_order, self.order_env_var_name)
 2148:         if len(unknown_order) > 0:
 2149:             raise ValueError("blas_opt_info user defined BLAS order has unacceptable values: {}".format(unknown_order))
 2150: 
 2151:         if 'NPY_BLAS_LIBS' in os.environ:
 2152:             # Bypass autodetection, set language to F77 and use env var linker
 2153:             # flags directly
 2154:             self._calc_info_from_envvar()
 2155:             return
 2156: 
 2157:         for blas in blas_order:
 2158:             if self._calc_info(blas):
 2159:                 return
 2160: 
 2161:         if 'blas' not in blas_order:
 2162:             # Since the user may request *not* to use any library, we still need
 2163:             # to raise warnings to signal missing packages!
 2164:             warnings.warn(BlasNotFoundError.__doc__ or '', stacklevel=2)
 2165:             warnings.warn(BlasSrcNotFoundError.__doc__ or '', stacklevel=2)
 2166: 
 2167: 
 2168: class blas_ilp64_opt_info(blas_opt_info, _ilp64_opt_info_mixin):
 2169:     notfounderror = BlasILP64NotFoundError
 2170:     blas_order = ['openblas64_', 'openblas_ilp64', 'accelerate']
 2171:     order_env_var_name = 'NPY_BLAS_ILP64_ORDER'
 2172: 
 2173:     def _calc_info(self, name):
 2174:         info = get_info(name)
 2175:         if self._check_info(info):
 2176:             self.set_info(**info)
 2177:             return True
 2178:         return False
 2179: 
 2180: 
 2181: class blas_ilp64_plain_opt_info(blas_ilp64_opt_info):
 2182:     symbol_prefix = ''
 2183:     symbol_suffix = ''
 2184: 
 2185: 
 2186: class blas64__opt_info(blas_ilp64_opt_info):
 2187:     symbol_prefix = ''
 2188:     symbol_suffix = '64_'
 2189: 
 2190: 
 2191: class cblas_info(system_info):
 2192:     section = 'cblas'
 2193:     dir_env_var = 'CBLAS'
 2194:     # No default as it's used only in blas_info
 2195:     _lib_names = []
 2196:     notfounderror = BlasNotFoundError
 2197: 
 2198: 
 2199: class blas_info(system_info):
 2200:     section = 'blas'
 2201:     dir_env_var = 'BLAS'
 2202:     _lib_names = ['blas']
 2203:     notfounderror = BlasNotFoundError
 2204: 
 2205:     def calc_info(self):
 2206:         lib_dirs = self.get_lib_dirs()
 2207:         opt = self.get_option_single('blas_libs', 'libraries')
 2208:         blas_libs = self.get_libs(opt, self._lib_names)
 2209:         info = self.check_libs(lib_dirs, blas_libs, [])
 2210:         if info is None:
 2211:             return
 2212:         else:
 2213:             info['include_dirs'] = self.get_include_dirs()
 2214:         if platform.system() == 'Windows':
 2215:             # The check for windows is needed because get_cblas_libs uses the
 2216:             # same compiler that was used to compile Python and msvc is
 2217:             # often not installed when mingw is being used. This rough
 2218:             # treatment is not desirable, but windows is tricky.
 2219:             info['language'] = 'f77'  # XXX: is it generally true?
 2220:             # If cblas is given as an option, use those
 2221:             cblas_info_obj = cblas_info()
 2222:             cblas_opt = cblas_info_obj.get_option_single('cblas_libs', 'libraries')
 2223:             cblas_libs = cblas_info_obj.get_libs(cblas_opt, None)
 2224:             if cblas_libs:
 2225:                 info['libraries'] = cblas_libs + blas_libs
 2226:                 info['define_macros'] = [('HAVE_CBLAS', None)]
 2227:         else:
 2228:             lib = self.get_cblas_libs(info)
 2229:             if lib is not None:
 2230:                 info['language'] = 'c'
 2231:                 info['libraries'] = lib
 2232:                 info['define_macros'] = [('HAVE_CBLAS', None)]
 2233:         self.set_info(**info)
 2234: 
 2235:     def get_cblas_libs(self, info):
 2236:         """ Check whether we can link with CBLAS interface
 2237: 
 2238:         This method will search through several combinations of libraries
 2239:         to check whether CBLAS is present:
 2240: 
 2241:         1. Libraries in ``info['libraries']``, as is
 2242:         2. As 1. but also explicitly adding ``'cblas'`` as a library
 2243:         3. As 1. but also explicitly adding ``'blas'`` as a library
 2244:         4. Check only library ``'cblas'``
 2245:         5. Check only library ``'blas'``
 2246: 
 2247:         Parameters
 2248:         ----------
 2249:         info : dict
 2250:            system information dictionary for compilation and linking
 2251: 
 2252:         Returns
 2253:         -------
 2254:         libraries : list of str or None
 2255:             a list of libraries that enables the use of CBLAS interface.
 2256:             Returns None if not found or a compilation error occurs.
 2257: 
 2258:             Since 1.17 returns a list.
 2259:         """
 2260:         # primitive cblas check by looking for the header and trying to link
 2261:         # cblas or blas
 2262:         c = customized_ccompiler()
 2263:         tmpdir = tempfile.mkdtemp()
 2264:         s = textwrap.dedent("""\
 2265:             #include <cblas.h>
 2266:             int main(int argc, const char *argv[])
 2267:             {
 2268:                 double a[4] = {1,2,3,4};
 2269:                 double b[4] = {5,6,7,8};
 2270:                 return cblas_ddot(4, a, 1, b, 1) > 10;
 2271:             }""")
 2272:         src = os.path.join(tmpdir, 'source.c')
 2273:         try:
 2274:             with open(src, 'w') as f:
 2275:                 f.write(s)
 2276: 
 2277:             try:
 2278:                 # check we can compile (find headers)
 2279:                 obj = c.compile([src], output_dir=tmpdir,
 2280:                                 include_dirs=self.get_include_dirs())
 2281:             except (distutils.ccompiler.CompileError, distutils.ccompiler.LinkError):
 2282:                 return None
 2283: 
 2284:             # check we can link (find library)
 2285:             # some systems have separate cblas and blas libs.
 2286:             for libs in [info['libraries'], ['cblas'] + info['libraries'],
 2287:                          ['blas'] + info['libraries'], ['cblas'], ['blas']]:
 2288:                 try:
 2289:                     c.link_executable(obj, os.path.join(tmpdir, "a.out"),
 2290:                                       libraries=libs,
 2291:                                       library_dirs=info['library_dirs'],
 2292:                                       extra_postargs=info.get('extra_link_args', []))
 2293:                     return libs
 2294:                 except distutils.ccompiler.LinkError:
 2295:                     pass
 2296:         finally:
 2297:             shutil.rmtree(tmpdir)
 2298:         return None
 2299: 
 2300: 
 2301: class openblas_info(blas_info):
 2302:     section = 'openblas'
 2303:     dir_env_var = 'OPENBLAS'
 2304:     _lib_names = ['openblas']
 2305:     _require_symbols = []
 2306:     notfounderror = BlasNotFoundError
 2307: 
 2308:     @property
 2309:     def symbol_prefix(self):
 2310:         try:
 2311:             return self.cp.get(self.section, 'symbol_prefix')
 2312:         except NoOptionError:
 2313:             return ''
 2314: 
 2315:     @property
 2316:     def symbol_suffix(self):
 2317:         try:
 2318:             return self.cp.get(self.section, 'symbol_suffix')
 2319:         except NoOptionError:
 2320:             return ''
 2321: 
 2322:     def _calc_info(self):
 2323:         c = customized_ccompiler()
 2324: 
 2325:         lib_dirs = self.get_lib_dirs()
 2326: 
 2327:         # Prefer to use libraries over openblas_libs
 2328:         opt = self.get_option_single('openblas_libs', 'libraries')
 2329:         openblas_libs = self.get_libs(opt, self._lib_names)
 2330: 
 2331:         info = self.check_libs(lib_dirs, openblas_libs, [])
 2332: 
 2333:         if c.compiler_type == "msvc" and info is None:
 2334:             from numpy.distutils.fcompiler import new_fcompiler
 2335:             f = new_fcompiler(c_compiler=c)
 2336:             if f and f.compiler_type == 'gnu95':
 2337:                 # Try gfortran-compatible library files
 2338:                 info = self.check_msvc_gfortran_libs(lib_dirs, openblas_libs)
 2339:                 # Skip lapack check, we'd need build_ext to do it
 2340:                 skip_symbol_check = True
 2341:         elif info:
 2342:             skip_symbol_check = False
 2343:             info['language'] = 'c'
 2344: 
 2345:         if info is None:
 2346:             return None
 2347: 
 2348:         # Add extra info for OpenBLAS
 2349:         extra_info = self.calc_extra_info()
 2350:         dict_append(info, **extra_info)
 2351: 
 2352:         if not (skip_symbol_check or self.check_symbols(info)):
 2353:             return None
 2354: 
 2355:         info['define_macros'] = [('HAVE_CBLAS', None)]
 2356:         if self.symbol_prefix:
 2357:             info['define_macros'] += [('BLAS_SYMBOL_PREFIX', self.symbol_prefix)]
 2358:         if self.symbol_suffix:
 2359:             info['define_macros'] += [('BLAS_SYMBOL_SUFFIX', self.symbol_suffix)]
 2360: 
 2361:         return info
 2362: 
 2363:     def calc_info(self):
 2364:         info = self._calc_info()
 2365:         if info is not None:
 2366:             self.set_info(**info)
 2367: 
 2368:     def check_msvc_gfortran_libs(self, library_dirs, libraries):
 2369:         # First, find the full path to each library directory
 2370:         library_paths = []
 2371:         for library in libraries:
 2372:             for library_dir in library_dirs:
 2373:                 # MinGW static ext will be .a
 2374:                 fullpath = os.path.join(library_dir, library + '.a')
 2375:                 if os.path.isfile(fullpath):
 2376:                     library_paths.append(fullpath)
 2377:                     break
 2378:             else:
 2379:                 return None
 2380: 
 2381:         # Generate numpy.distutils virtual static library file
 2382:         basename = self.__class__.__name__
 2383:         tmpdir = os.path.join(os.getcwd(), 'build', basename)
 2384:         if not os.path.isdir(tmpdir):
 2385:             os.makedirs(tmpdir)
 2386: 
 2387:         info = {'library_dirs': [tmpdir],
 2388:                 'libraries': [basename],
 2389:                 'language': 'f77'}
 2390: 
 2391:         fake_lib_file = os.path.join(tmpdir, basename + '.fobjects')
 2392:         fake_clib_file = os.path.join(tmpdir, basename + '.cobjects')
 2393:         with open(fake_lib_file, 'w') as f:
 2394:             f.write("\n".join(library_paths))
 2395:         with open(fake_clib_file, 'w') as f:
 2396:             pass
 2397: 
 2398:         return info
 2399: 
 2400:     def check_symbols(self, info):
 2401:         res = False
 2402:         c = customized_ccompiler()
 2403: 
 2404:         tmpdir = tempfile.mkdtemp()
 2405: 
 2406:         prototypes = "\n".join("void %s%s%s();" % (self.symbol_prefix,
 2407:                                                    symbol_name,
 2408:                                                    self.symbol_suffix)
 2409:                                for symbol_name in self._require_symbols)
 2410:         calls = "\n".join("%s%s%s();" % (self.symbol_prefix,
 2411:                                          symbol_name,
 2412:                                          self.symbol_suffix)
 2413:                           for symbol_name in self._require_symbols)
 2414:         s = textwrap.dedent("""\
 2415:             %(prototypes)s
 2416:             int main(int argc, const char *argv[])
 2417:             {
 2418:                 %(calls)s
 2419:                 return 0;
 2420:             }""") % dict(prototypes=prototypes, calls=calls)
 2421:         src = os.path.join(tmpdir, 'source.c')
 2422:         out = os.path.join(tmpdir, 'a.out')
 2423:         # Add the additional "extra" arguments
 2424:         try:
 2425:             extra_args = info['extra_link_args']
 2426:         except Exception:
 2427:             extra_args = []
 2428:         try:
 2429:             with open(src, 'w') as f:
 2430:                 f.write(s)
 2431:             obj = c.compile([src], output_dir=tmpdir)
 2432:             try:
 2433:                 c.link_executable(obj, out, libraries=info['libraries'],
 2434:                                   library_dirs=info['library_dirs'],
 2435:                                   extra_postargs=extra_args)
 2436:                 res = True
 2437:             except distutils.ccompiler.LinkError:
 2438:                 res = False
 2439:         finally:
 2440:             shutil.rmtree(tmpdir)
 2441:         return res
 2442: 
 2443: class openblas_lapack_info(openblas_info):
 2444:     section = 'openblas'
 2445:     dir_env_var = 'OPENBLAS'
 2446:     _lib_names = ['openblas']
 2447:     _require_symbols = ['zungqr_']
 2448:     notfounderror = BlasNotFoundError
 2449: 
 2450: class openblas_clapack_info(openblas_lapack_info):
 2451:     _lib_names = ['openblas', 'lapack']
 2452: 
 2453: class openblas_ilp64_info(openblas_info):
 2454:     section = 'openblas_ilp64'
 2455:     dir_env_var = 'OPENBLAS_ILP64'
 2456:     _lib_names = ['openblas64']
 2457:     _require_symbols = ['dgemm_', 'cblas_dgemm']
 2458:     notfounderror = BlasILP64NotFoundError
 2459: 
 2460:     def _calc_info(self):
 2461:         info = super()._calc_info()
 2462:         if info is not None:
 2463:             info['define_macros'] += [('HAVE_BLAS_ILP64', None)]
 2464:         return info
 2465: 
 2466: class openblas_ilp64_lapack_info(openblas_ilp64_info):
 2467:     _require_symbols = ['dgemm_', 'cblas_dgemm', 'zungqr_', 'LAPACKE_zungqr']
 2468: 
 2469:     def _calc_info(self):
 2470:         info = super()._calc_info()
 2471:         if info:
 2472:             info['define_macros'] += [('HAVE_LAPACKE', None)]
 2473:         return info
 2474: 
 2475: class openblas64__info(openblas_ilp64_info):
 2476:     # ILP64 Openblas, with default symbol suffix
 2477:     section = 'openblas64_'
 2478:     dir_env_var = 'OPENBLAS64_'
 2479:     _lib_names = ['openblas64_']
 2480:     symbol_suffix = '64_'
 2481:     symbol_prefix = ''
 2482: 
 2483: class openblas64__lapack_info(openblas_ilp64_lapack_info, openblas64__info):
 2484:     pass
 2485: 
 2486: class blis_info(blas_info):
 2487:     section = 'blis'
 2488:     dir_env_var = 'BLIS'
 2489:     _lib_names = ['blis']
 2490:     notfounderror = BlasNotFoundError
 2491: 
 2492:     def calc_info(self):
 2493:         lib_dirs = self.get_lib_dirs()
 2494:         opt = self.get_option_single('blis_libs', 'libraries')
 2495:         blis_libs = self.get_libs(opt, self._lib_names)
 2496:         info = self.check_libs2(lib_dirs, blis_libs, [])
 2497:         if info is None:
 2498:             return
 2499: 
 2500:         # Add include dirs
 2501:         incl_dirs = self.get_include_dirs()
 2502:         dict_append(info,
 2503:                     language='c',
 2504:                     define_macros=[('HAVE_CBLAS', None)],
 2505:                     include_dirs=incl_dirs)
 2506:         self.set_info(**info)
 2507: 
 2508: 
 2509: class flame_info(system_info):
 2510:     """ Usage of libflame for LAPACK operations
 2511: 
 2512:     This requires libflame to be compiled with lapack wrappers:
 2513: 
 2514:     ./configure --enable-lapack2flame ...
 2515: 
 2516:     Be aware that libflame 5.1.0 has some missing names in the shared library, so
 2517:     if you have problems, try the static flame library.
 2518:     """
 2519:     section = 'flame'
 2520:     _lib_names = ['flame']
 2521:     notfounderror = FlameNotFoundError
 2522: 
 2523:     def check_embedded_lapack(self, info):
 2524:         """ libflame does not necessarily have a wrapper for fortran LAPACK, we need to check """
 2525:         c = customized_ccompiler()
 2526: 
 2527:         tmpdir = tempfile.mkdtemp()
 2528:         s = textwrap.dedent("""\
 2529:             void zungqr_();
 2530:             int main(int argc, const char *argv[])
 2531:             {
 2532:                 zungqr_();
 2533:                 return 0;
 2534:             }""")
 2535:         src = os.path.join(tmpdir, 'source.c')
 2536:         out = os.path.join(tmpdir, 'a.out')
 2537:         # Add the additional "extra" arguments
 2538:         extra_args = info.get('extra_link_args', [])
 2539:         try:
 2540:             with open(src, 'w') as f:
 2541:                 f.write(s)
 2542:             obj = c.compile([src], output_dir=tmpdir)
 2543:             try:
 2544:                 c.link_executable(obj, out, libraries=info['libraries'],
 2545:                                   library_dirs=info['library_dirs'],
 2546:                                   extra_postargs=extra_args)
 2547:                 return True
 2548:             except distutils.ccompiler.LinkError:
 2549:                 return False
 2550:         finally:
 2551:             shutil.rmtree(tmpdir)
 2552: 
 2553:     def calc_info(self):
 2554:         lib_dirs = self.get_lib_dirs()
 2555:         flame_libs = self.get_libs('libraries', self._lib_names)
 2556: 
 2557:         info = self.check_libs2(lib_dirs, flame_libs, [])
 2558:         if info is None:
 2559:             return
 2560: 
 2561:         # Add the extra flag args to info
 2562:         extra_info = self.calc_extra_info()
 2563:         dict_append(info, **extra_info)
 2564: 
 2565:         if self.check_embedded_lapack(info):
 2566:             # check if the user has supplied all information required
 2567:             self.set_info(**info)
 2568:         else:
 2569:             # Try and get the BLAS lib to see if we can get it to work
 2570:             blas_info = get_info('blas_opt')
 2571:             if not blas_info:
 2572:                 # since we already failed once, this ain't going to work either
 2573:                 return
 2574: 
 2575:             # Now we need to merge the two dictionaries
 2576:             for key in blas_info:
 2577:                 if isinstance(blas_info[key], list):
 2578:                     info[key] = info.get(key, []) + blas_info[key]
 2579:                 elif isinstance(blas_info[key], tuple):
 2580:                     info[key] = info.get(key, ()) + blas_info[key]
 2581:                 else:
 2582:                     info[key] = info.get(key, '') + blas_info[key]
 2583: 
 2584:             # Now check again
 2585:             if self.check_embedded_lapack(info):
 2586:                 self.set_info(**info)
 2587: 
 2588: 
 2589: class accelerate_info(system_info):
 2590:     section = 'accelerate'
 2591:     _lib_names = ['accelerate', 'veclib']
 2592:     notfounderror = BlasNotFoundError
 2593: 
 2594:     def calc_info(self):
 2595:         # Make possible to enable/disable from config file/env var
 2596:         libraries = os.environ.get('ACCELERATE')
 2597:         if libraries:
 2598:             libraries = [libraries]
 2599:         else:
 2600:             libraries = self.get_libs('libraries', self._lib_names)
 2601:         libraries = [lib.strip().lower() for lib in libraries]
 2602: 
 2603:         if (sys.platform == 'darwin' and
 2604:                 not os.getenv('_PYTHON_HOST_PLATFORM', None)):
 2605:             # Use the system BLAS from Accelerate or vecLib under OSX
 2606:             args = []
 2607:             link_args = []
 2608:             if get_platform()[-4:] == 'i386' or 'intel' in get_platform() or \
 2609:                'x86_64' in get_platform() or \
 2610:                'i386' in platform.platform():
 2611:                 intel = 1
 2612:             else:
 2613:                 intel = 0
 2614:             if (os.path.exists('/System/Library/Frameworks'
 2615:                               '/Accelerate.framework/') and
 2616:                     'accelerate' in libraries):
 2617:                 if intel:
 2618:                     args.extend(['-msse3'])
 2619:                 args.extend([
 2620:                     '-I/System/Library/Frameworks/vecLib.framework/Headers'])
 2621:                 link_args.extend(['-Wl,-framework', '-Wl,Accelerate'])
 2622:             elif (os.path.exists('/System/Library/Frameworks'
 2623:                                  '/vecLib.framework/') and
 2624:                       'veclib' in libraries):
 2625:                 if intel:
 2626:                     args.extend(['-msse3'])
 2627:                 args.extend([
 2628:                     '-I/System/Library/Frameworks/vecLib.framework/Headers'])
 2629:                 link_args.extend(['-Wl,-framework', '-Wl,vecLib'])
 2630: 
 2631:             if args:
 2632:                 macros = [
 2633:                     ('NO_ATLAS_INFO', 3),
 2634:                     ('HAVE_CBLAS', None),
 2635:                     ('ACCELERATE_NEW_LAPACK', None),
 2636:                 ]
 2637:                 if(os.getenv('NPY_USE_BLAS_ILP64', None)):
 2638:                     print('Setting HAVE_BLAS_ILP64')
 2639:                     macros += [
 2640:                         ('HAVE_BLAS_ILP64', None),
 2641:                         ('ACCELERATE_LAPACK_ILP64', None),
 2642:                     ]
 2643:                 self.set_info(extra_compile_args=args,
 2644:                               extra_link_args=link_args,
 2645:                               define_macros=macros)
 2646: 
 2647:         return
 2648: 
 2649: class accelerate_lapack_info(accelerate_info):
 2650:     def _calc_info(self):
 2651:         return super()._calc_info()
 2652: 
 2653: class blas_src_info(system_info):
 2654:     # BLAS_SRC is deprecated, please do not use this!
 2655:     # Build or install a BLAS library via your package manager or from
 2656:     # source separately.
 2657:     section = 'blas_src'
 2658:     dir_env_var = 'BLAS_SRC'
 2659:     notfounderror = BlasSrcNotFoundError
 2660: 
 2661:     def get_paths(self, section, key):
 2662:         pre_dirs = system_info.get_paths(self, section, key)
 2663:         dirs = []
 2664:         for d in pre_dirs:
 2665:             dirs.extend([d] + self.combine_paths(d, ['blas']))
 2666:         return [d for d in dirs if os.path.isdir(d)]
 2667: 
 2668:     def calc_info(self):
 2669:         src_dirs = self.get_src_dirs()
 2670:         src_dir = ''
 2671:         for d in src_dirs:
 2672:             if os.path.isfile(os.path.join(d, 'daxpy.f')):
 2673:                 src_dir = d
 2674:                 break
 2675:         if not src_dir:
 2676:             #XXX: Get sources from netlib. May be ask first.
 2677:             return
 2678:         blas1 = '''
 2679:         caxpy csscal dnrm2 dzasum saxpy srotg zdotc ccopy cswap drot
 2680:         dznrm2 scasum srotm zdotu cdotc dasum drotg icamax scnrm2
 2681:         srotmg zdrot cdotu daxpy drotm idamax scopy sscal zdscal crotg
 2682:         dcabs1 drotmg isamax sdot sswap zrotg cscal dcopy dscal izamax
 2683:         snrm2 zaxpy zscal csrot ddot dswap sasum srot zcopy zswap
 2684:         scabs1
 2685:         '''
 2686:         blas2 = '''
 2687:         cgbmv chpmv ctrsv dsymv dtrsv sspr2 strmv zhemv ztpmv cgemv
 2688:         chpr dgbmv dsyr lsame ssymv strsv zher ztpsv cgerc chpr2 dgemv
 2689:         dsyr2 sgbmv ssyr xerbla zher2 ztrmv cgeru ctbmv dger dtbmv
 2690:         sgemv ssyr2 zgbmv zhpmv ztrsv chbmv ctbsv dsbmv dtbsv sger
 2691:         stbmv zgemv zhpr chemv ctpmv dspmv dtpmv ssbmv stbsv zgerc
 2692:         zhpr2 cher ctpsv dspr dtpsv sspmv stpmv zgeru ztbmv cher2
 2693:         ctrmv dspr2 dtrmv sspr stpsv zhbmv ztbsv
 2694:         '''
 2695:         blas3 = '''
 2696:         cgemm csymm ctrsm dsyrk sgemm strmm zhemm zsyr2k chemm csyr2k
 2697:         dgemm dtrmm ssymm strsm zher2k zsyrk cher2k csyrk dsymm dtrsm
 2698:         ssyr2k zherk ztrmm cherk ctrmm dsyr2k ssyrk zgemm zsymm ztrsm
 2699:         '''
 2700:         sources = [os.path.join(src_dir, f + '.f') \
 2701:                    for f in (blas1 + blas2 + blas3).split()]
 2702:         #XXX: should we check here actual existence of source files?
 2703:         sources = [f for f in sources if os.path.isfile(f)]
 2704:         info = {'sources': sources, 'language': 'f77'}
 2705:         self.set_info(**info)
 2706: 
 2707: 
 2708: class x11_info(system_info):
 2709:     section = 'x11'
 2710:     notfounderror = X11NotFoundError
 2711:     _lib_names = ['X11']
 2712: 
 2713:     def __init__(self):
 2714:         system_info.__init__(self,
 2715:                              default_lib_dirs=default_x11_lib_dirs,
 2716:                              default_include_dirs=default_x11_include_dirs)
 2717: 
 2718:     def calc_info(self):
 2719:         if sys.platform  in ['win32']:
 2720:             return
 2721:         lib_dirs = self.get_lib_dirs()
 2722:         include_dirs = self.get_include_dirs()
 2723:         opt = self.get_option_single('x11_libs', 'libraries')
 2724:         x11_libs = self.get_libs(opt, self._lib_names)
 2725:         info = self.check_libs(lib_dirs, x11_libs, [])
 2726:         if info is None:
 2727:             return
 2728:         inc_dir = None
 2729:         for d in include_dirs:
 2730:             if self.combine_paths(d, 'X11/X.h'):
 2731:                 inc_dir = d
 2732:                 break
 2733:         if inc_dir is not None:
 2734:             dict_append(info, include_dirs=[inc_dir])
 2735:         self.set_info(**info)
 2736: 
 2737: 
 2738: class _numpy_info(system_info):
 2739:     section = 'Numeric'
 2740:     modulename = 'Numeric'
 2741:     notfounderror = NumericNotFoundError
 2742: 
 2743:     def __init__(self):
 2744:         include_dirs = []
 2745:         try:
 2746:             module = __import__(self.modulename)
 2747:             prefix = []
 2748:             for name in module.__file__.split(os.sep):
 2749:                 if name == 'lib':
 2750:                     break
 2751:                 prefix.append(name)
 2752: 
 2753:             # Ask numpy for its own include path before attempting
 2754:             # anything else
 2755:             try:
 2756:                 include_dirs.append(getattr(module, 'get_include')())
 2757:             except AttributeError:
 2758:                 pass
 2759: 
 2760:             include_dirs.append(sysconfig.get_path('include'))
 2761:         except ImportError:
 2762:             pass
 2763:         py_incl_dir = sysconfig.get_path('include')
 2764:         include_dirs.append(py_incl_dir)
 2765:         py_pincl_dir = sysconfig.get_path('platinclude')
 2766:         if py_pincl_dir not in include_dirs:
 2767:             include_dirs.append(py_pincl_dir)
 2768:         for d in default_include_dirs:
 2769:             d = os.path.join(d, os.path.basename(py_incl_dir))
 2770:             if d not in include_dirs:
 2771:                 include_dirs.append(d)
 2772:         system_info.__init__(self,
 2773:                              default_lib_dirs=[],
 2774:                              default_include_dirs=include_dirs)
 2775: 
 2776:     def calc_info(self):
 2777:         try:
 2778:             module = __import__(self.modulename)
 2779:         except ImportError:
 2780:             return
 2781:         info = {}
 2782:         macros = []
 2783:         for v in ['__version__', 'version']:
 2784:             vrs = getattr(module, v, None)
 2785:             if vrs is None:
 2786:                 continue
 2787:             macros = [(self.modulename.upper() + '_VERSION',
 2788:                       _c_string_literal(vrs)),
 2789:                       (self.modulename.upper(), None)]
 2790:             break
 2791:         dict_append(info, define_macros=macros)
 2792:         include_dirs = self.get_include_dirs()
 2793:         inc_dir = None
 2794:         for d in include_dirs:
 2795:             if self.combine_paths(d,
 2796:                                   os.path.join(self.modulename,
 2797:                                                'arrayobject.h')):
 2798:                 inc_dir = d
 2799:                 break
 2800:         if inc_dir is not None:
 2801:             dict_append(info, include_dirs=[inc_dir])
 2802:         if info:
 2803:             self.set_info(**info)
 2804:         return
 2805: 
 2806: 
 2807: class numarray_info(_numpy_info):
 2808:     section = 'numarray'
 2809:     modulename = 'numarray'
 2810: 
 2811: 
 2812: class Numeric_info(_numpy_info):
 2813:     section = 'Numeric'
 2814:     modulename = 'Numeric'
 2815: 
 2816: 
 2817: class numpy_info(_numpy_info):
 2818:     section = 'numpy'
 2819:     modulename = 'numpy'
 2820: 
 2821: 
 2822: class numerix_info(system_info):
 2823:     section = 'numerix'
 2824: 
 2825:     def calc_info(self):
 2826:         which = None, None
 2827:         if os.getenv("NUMERIX"):
 2828:             which = os.getenv("NUMERIX"), "environment var"
 2829:         # If all the above fail, default to numpy.
 2830:         if which[0] is None:
 2831:             which = "numpy", "defaulted"
 2832:             try:
 2833:                 import numpy  # noqa: F401
 2834:                 which = "numpy", "defaulted"
 2835:             except ImportError as e:
 2836:                 msg1 = str(e)
 2837:                 try:
 2838:                     import Numeric  # noqa: F401
 2839:                     which = "numeric", "defaulted"
 2840:                 except ImportError as e:
 2841:                     msg2 = str(e)
 2842:                     try:
 2843:                         import numarray  # noqa: F401
 2844:                         which = "numarray", "defaulted"
 2845:                     except ImportError as e:
 2846:                         msg3 = str(e)
 2847:                         log.info(msg1)
 2848:                         log.info(msg2)
 2849:                         log.info(msg3)
 2850:         which = which[0].strip().lower(), which[1]
 2851:         if which[0] not in ["numeric", "numarray", "numpy"]:
 2852:             raise ValueError("numerix selector must be either 'Numeric' "
 2853:                              "or 'numarray' or 'numpy' but the value obtained"
 2854:                              " from the %s was '%s'." % (which[1], which[0]))
 2855:         os.environ['NUMERIX'] = which[0]
 2856:         self.set_info(**get_info(which[0]))
 2857: 
 2858: 
 2859: class f2py_info(system_info):
 2860:     def calc_info(self):
 2861:         try:
 2862:             import numpy.f2py as f2py
 2863:         except ImportError:
 2864:             return
 2865:         f2py_dir = os.path.join(os.path.dirname(f2py.__file__), 'src')
 2866:         self.set_info(sources=[os.path.join(f2py_dir, 'fortranobject.c')],
 2867:                       include_dirs=[f2py_dir])
 2868:         return
 2869: 
 2870: 
 2871: class boost_python_info(system_info):
 2872:     section = 'boost_python'
 2873:     dir_env_var = 'BOOST'
 2874: 
 2875:     def get_paths(self, section, key):
 2876:         pre_dirs = system_info.get_paths(self, section, key)
 2877:         dirs = []
 2878:         for d in pre_dirs:
 2879:             dirs.extend([d] + self.combine_paths(d, ['boost*']))
 2880:         return [d for d in dirs if os.path.isdir(d)]
 2881: 
 2882:     def calc_info(self):
 2883:         src_dirs = self.get_src_dirs()
 2884:         src_dir = ''
 2885:         for d in src_dirs:
 2886:             if os.path.isfile(os.path.join(d, 'libs', 'python', 'src',
 2887:                                            'module.cpp')):
 2888:                 src_dir = d
 2889:                 break
 2890:         if not src_dir:
 2891:             return
 2892:         py_incl_dirs = [sysconfig.get_path('include')]
 2893:         py_pincl_dir = sysconfig.get_path('platinclude')
 2894:         if py_pincl_dir not in py_incl_dirs:
 2895:             py_incl_dirs.append(py_pincl_dir)
 2896:         srcs_dir = os.path.join(src_dir, 'libs', 'python', 'src')
 2897:         bpl_srcs = glob(os.path.join(srcs_dir, '*.cpp'))
 2898:         bpl_srcs += glob(os.path.join(srcs_dir, '*', '*.cpp'))
 2899:         info = {'libraries': [('boost_python_src',
 2900:                                {'include_dirs': [src_dir] + py_incl_dirs,
 2901:                                 'sources':bpl_srcs}
 2902:                               )],
 2903:                 'include_dirs': [src_dir],
 2904:                 }
 2905:         if info:
 2906:             self.set_info(**info)
 2907:         return
 2908: 
 2909: 
 2910: class agg2_info(system_info):
 2911:     section = 'agg2'
 2912:     dir_env_var = 'AGG2'
 2913: 
 2914:     def get_paths(self, section, key):
 2915:         pre_dirs = system_info.get_paths(self, section, key)
 2916:         dirs = []
 2917:         for d in pre_dirs:
 2918:             dirs.extend([d] + self.combine_paths(d, ['agg2*']))
 2919:         return [d for d in dirs if os.path.isdir(d)]
 2920: 
 2921:     def calc_info(self):
 2922:         src_dirs = self.get_src_dirs()
 2923:         src_dir = ''
 2924:         for d in src_dirs:
 2925:             if os.path.isfile(os.path.join(d, 'src', 'agg_affine_matrix.cpp')):
 2926:                 src_dir = d
 2927:                 break
 2928:         if not src_dir:
 2929:             return
 2930:         if sys.platform == 'win32':
 2931:             agg2_srcs = glob(os.path.join(src_dir, 'src', 'platform',
 2932:                                           'win32', 'agg_win32_bmp.cpp'))
 2933:         else:
 2934:             agg2_srcs = glob(os.path.join(src_dir, 'src', '*.cpp'))
 2935:             agg2_srcs += [os.path.join(src_dir, 'src', 'platform',
 2936:                                        'X11',
 2937:                                        'agg_platform_support.cpp')]
 2938: 
 2939:         info = {'libraries':
 2940:                 [('agg2_src',
 2941:                   {'sources': agg2_srcs,
 2942:                    'include_dirs': [os.path.join(src_dir, 'include')],
 2943:                   }
 2944:                  )],
 2945:                 'include_dirs': [os.path.join(src_dir, 'include')],
 2946:                 }
 2947:         if info:
 2948:             self.set_info(**info)
 2949:         return
 2950: 
 2951: 
 2952: class _pkg_config_info(system_info):
 2953:     section = None
 2954:     config_env_var = 'PKG_CONFIG'
 2955:     default_config_exe = 'pkg-config'
 2956:     append_config_exe = ''
 2957:     version_macro_name = None
 2958:     release_macro_name = None
 2959:     version_flag = '--modversion'
 2960:     cflags_flag = '--cflags'
 2961: 
 2962:     def get_config_exe(self):
 2963:         if self.config_env_var in os.environ:
 2964:             return os.environ[self.config_env_var]
 2965:         return self.default_config_exe
 2966: 
 2967:     def get_config_output(self, config_exe, option):
 2968:         cmd = config_exe + ' ' + self.append_config_exe + ' ' + option
 2969:         try:
 2970:             o = subprocess.check_output(cmd)
 2971:         except (OSError, subprocess.CalledProcessError):
 2972:             pass
 2973:         else:
 2974:             o = filepath_from_subprocess_output(o)
 2975:             return o
 2976: 
 2977:     def calc_info(self):
 2978:         config_exe = find_executable(self.get_config_exe())
 2979:         if not config_exe:
 2980:             log.warn('File not found: %s. Cannot determine %s info.' \
 2981:                   % (config_exe, self.section))
 2982:             return
 2983:         info = {}
 2984:         macros = []
 2985:         libraries = []
 2986:         library_dirs = []
 2987:         include_dirs = []
 2988:         extra_link_args = []
 2989:         extra_compile_args = []
 2990:         version = self.get_config_output(config_exe, self.version_flag)
 2991:         if version:
 2992:             macros.append((self.__class__.__name__.split('.')[-1].upper(),
 2993:                            _c_string_literal(version)))
 2994:             if self.version_macro_name:
 2995:                 macros.append((self.version_macro_name + '_%s'
 2996:                                % (version.replace('.', '_')), None))
 2997:         if self.release_macro_name:
 2998:             release = self.get_config_output(config_exe, '--release')
 2999:             if release:
 3000:                 macros.append((self.release_macro_name + '_%s'
 3001:                                % (release.replace('.', '_')), None))
 3002:         opts = self.get_config_output(config_exe, '--libs')
 3003:         if opts:
 3004:             for opt in opts.split():
 3005:                 if opt[:2] == '-l':
 3006:                     libraries.append(opt[2:])
 3007:                 elif opt[:2] == '-L':
 3008:                     library_dirs.append(opt[2:])
 3009:                 else:
 3010:                     extra_link_args.append(opt)
 3011:         opts = self.get_config_output(config_exe, self.cflags_flag)
 3012:         if opts:
 3013:             for opt in opts.split():
 3014:                 if opt[:2] == '-I':
 3015:                     include_dirs.append(opt[2:])
 3016:                 elif opt[:2] == '-D':
 3017:                     if '=' in opt:
 3018:                         n, v = opt[2:].split('=')
 3019:                         macros.append((n, v))
 3020:                     else:
 3021:                         macros.append((opt[2:], None))
 3022:                 else:
 3023:                     extra_compile_args.append(opt)
 3024:         if macros:
 3025:             dict_append(info, define_macros=macros)
 3026:         if libraries:
 3027:             dict_append(info, libraries=libraries)
 3028:         if library_dirs:
 3029:             dict_append(info, library_dirs=library_dirs)
 3030:         if include_dirs:
 3031:             dict_append(info, include_dirs=include_dirs)
 3032:         if extra_link_args:
 3033:             dict_append(info, extra_link_args=extra_link_args)
 3034:         if extra_compile_args:
 3035:             dict_append(info, extra_compile_args=extra_compile_args)
 3036:         if info:
 3037:             self.set_info(**info)
 3038:         return
 3039: 
 3040: 
 3041: class wx_info(_pkg_config_info):
 3042:     section = 'wx'
 3043:     config_env_var = 'WX_CONFIG'
 3044:     default_config_exe = 'wx-config'
 3045:     append_config_exe = ''
 3046:     version_macro_name = 'WX_VERSION'
 3047:     release_macro_name = 'WX_RELEASE'
 3048:     version_flag = '--version'
 3049:     cflags_flag = '--cxxflags'
 3050: 
 3051: 
 3052: class gdk_pixbuf_xlib_2_info(_pkg_config_info):
 3053:     section = 'gdk_pixbuf_xlib_2'
 3054:     append_config_exe = 'gdk-pixbuf-xlib-2.0'
 3055:     version_macro_name = 'GDK_PIXBUF_XLIB_VERSION'
 3056: 
 3057: 
 3058: class gdk_pixbuf_2_info(_pkg_config_info):
 3059:     section = 'gdk_pixbuf_2'
 3060:     append_config_exe = 'gdk-pixbuf-2.0'
 3061:     version_macro_name = 'GDK_PIXBUF_VERSION'
 3062: 
 3063: 
 3064: class gdk_x11_2_info(_pkg_config_info):
 3065:     section = 'gdk_x11_2'
 3066:     append_config_exe = 'gdk-x11-2.0'
 3067:     version_macro_name = 'GDK_X11_VERSION'
 3068: 
 3069: 
 3070: class gdk_2_info(_pkg_config_info):
 3071:     section = 'gdk_2'
 3072:     append_config_exe = 'gdk-2.0'
 3073:     version_macro_name = 'GDK_VERSION'
 3074: 
 3075: 
 3076: class gdk_info(_pkg_config_info):
 3077:     section = 'gdk'
 3078:     append_config_exe = 'gdk'
 3079:     version_macro_name = 'GDK_VERSION'
 3080: 
 3081: 
 3082: class gtkp_x11_2_info(_pkg_config_info):
 3083:     section = 'gtkp_x11_2'
 3084:     append_config_exe = 'gtk+-x11-2.0'
 3085:     version_macro_name = 'GTK_X11_VERSION'
 3086: 
 3087: 
 3088: class gtkp_2_info(_pkg_config_info):
 3089:     section = 'gtkp_2'
 3090:     append_config_exe = 'gtk+-2.0'
 3091:     version_macro_name = 'GTK_VERSION'
 3092: 
 3093: 
 3094: class xft_info(_pkg_config_info):
 3095:     section = 'xft'
 3096:     append_config_exe = 'xft'
 3097:     version_macro_name = 'XFT_VERSION'
 3098: 
 3099: 
 3100: class freetype2_info(_pkg_config_info):
 3101:     section = 'freetype2'
 3102:     append_config_exe = 'freetype2'
 3103:     version_macro_name = 'FREETYPE2_VERSION'
 3104: 
 3105: 
 3106: class amd_info(system_info):
 3107:     section = 'amd'
 3108:     dir_env_var = 'AMD'
 3109:     _lib_names = ['amd']
 3110: 
 3111:     def calc_info(self):
 3112:         lib_dirs = self.get_lib_dirs()
 3113: 
 3114:         opt = self.get_option_single('amd_libs', 'libraries')
 3115:         amd_libs = self.get_libs(opt, self._lib_names)
 3116:         info = self.check_libs(lib_dirs, amd_libs, [])
 3117:         if info is None:
 3118:             return
 3119: 
 3120:         include_dirs = self.get_include_dirs()
 3121: 
 3122:         inc_dir = None
 3123:         for d in include_dirs:
 3124:             p = self.combine_paths(d, 'amd.h')
 3125:             if p:
 3126:                 inc_dir = os.path.dirname(p[0])
 3127:                 break
 3128:         if inc_dir is not None:
 3129:             dict_append(info, include_dirs=[inc_dir],
 3130:                         define_macros=[('SCIPY_AMD_H', None)],
 3131:                         swig_opts=['-I' + inc_dir])
 3132: 
 3133:         self.set_info(**info)
 3134:         return
 3135: 
 3136: 
 3137: class umfpack_info(system_info):
 3138:     section = 'umfpack'
 3139:     dir_env_var = 'UMFPACK'
 3140:     notfounderror = UmfpackNotFoundError
 3141:     _lib_names = ['umfpack']
 3142: 
 3143:     def calc_info(self):
 3144:         lib_dirs = self.get_lib_dirs()
 3145: 
 3146:         opt = self.get_option_single('umfpack_libs', 'libraries')
 3147:         umfpack_libs = self.get_libs(opt, self._lib_names)
 3148:         info = self.check_libs(lib_dirs, umfpack_libs, [])
 3149:         if info is None:
 3150:             return
 3151: 
 3152:         include_dirs = self.get_include_dirs()
 3153: 
 3154:         inc_dir = None
 3155:         for d in include_dirs:
 3156:             p = self.combine_paths(d, ['', 'umfpack'], 'umfpack.h')
 3157:             if p:
 3158:                 inc_dir = os.path.dirname(p[0])
 3159:                 break
 3160:         if inc_dir is not None:
 3161:             dict_append(info, include_dirs=[inc_dir],
 3162:                         define_macros=[('SCIPY_UMFPACK_H', None)],
 3163:                         swig_opts=['-I' + inc_dir])
 3164: 
 3165:         dict_append(info, **get_info('amd'))
 3166: 
 3167:         self.set_info(**info)
 3168:         return
 3169: 
 3170: 
 3171: def combine_paths(*args, **kws):
 3172:     """ Return a list of existing paths composed by all combinations of
 3173:         items from arguments.
 3174:     """
 3175:     r = []
 3176:     for a in args:
 3177:         if not a:
 3178:             continue
 3179:         if is_string(a):
 3180:             a = [a]
 3181:         r.append(a)
 3182:     args = r
 3183:     if not args:
 3184:         return []
 3185:     if len(args) == 1:
 3186:         result = reduce(lambda a, b: a + b, map(glob, args[0]), [])
 3187:     elif len(args) == 2:
 3188:         result = []
 3189:         for a0 in args[0]:
 3190:             for a1 in args[1]:
 3191:                 result.extend(glob(os.path.join(a0, a1)))
 3192:     else:
 3193:         result = combine_paths(*(combine_paths(args[0], args[1]) + args[2:]))
 3194:     log.debug('(paths: %s)', ','.join(result))
 3195:     return result
 3196: 
 3197: language_map = {'c': 0, 'c++': 1, 'f77': 2, 'f90': 3}
 3198: inv_language_map = {0: 'c', 1: 'c++', 2: 'f77', 3: 'f90'}
 3199: 
 3200: 
 3201: def dict_append(d, **kws):
 3202:     languages = []
 3203:     for k, v in kws.items():
 3204:         if k == 'language':
 3205:             languages.append(v)
 3206:             continue
 3207:         if k in d:
 3208:             if k in ['library_dirs', 'include_dirs',
 3209:                      'extra_compile_args', 'extra_link_args',
 3210:                      'runtime_library_dirs', 'define_macros']:
 3211:                 [d[k].append(vv) for vv in v if vv not in d[k]]
 3212:             else:
 3213:                 d[k].extend(v)
 3214:         else:
 3215:             d[k] = v
 3216:     if languages:
 3217:         l = inv_language_map[max([language_map.get(l, 0) for l in languages])]
 3218:         d['language'] = l
 3219:     return
 3220: 
 3221: 
 3222: def parseCmdLine(argv=(None,)):
 3223:     import optparse
 3224:     parser = optparse.OptionParser("usage: %prog [-v] [info objs]")
 3225:     parser.add_option('-v', '--verbose', action='store_true', dest='verbose',
 3226:                       default=False,
 3227:                       help='be verbose and print more messages')
 3228: 
 3229:     opts, args = parser.parse_args(args=argv[1:])
 3230:     return opts, args
 3231: 
 3232: 
 3233: def show_all(argv=None):
 3234:     import inspect
 3235:     if argv is None:
 3236:         argv = sys.argv
 3237:     opts, args = parseCmdLine(argv)
 3238:     if opts.verbose:
 3239:         log.set_threshold(log.DEBUG)
 3240:     else:
 3241:         log.set_threshold(log.INFO)
 3242:     show_only = []
 3243:     for n in args:
 3244:         if n[-5:] != '_info':
 3245:             n = n + '_info'
 3246:         show_only.append(n)
 3247:     show_all = not show_only
 3248:     _gdict_ = globals().copy()
 3249:     for name, c in _gdict_.items():
 3250:         if not inspect.isclass(c):
 3251:             continue
 3252:         if not issubclass(c, system_info) or c is system_info:
 3253:             continue
 3254:         if not show_all:
 3255:             if name not in show_only:
 3256:                 continue
 3257:             del show_only[show_only.index(name)]
 3258:         conf = c()
 3259:         conf.verbosity = 2
 3260:         # we don't need the result, but we want
 3261:         # the side effect of printing diagnostics
 3262:         conf.get_info()
 3263:     if show_only:
 3264:         log.info('Info classes not defined: %s', ','.join(show_only))
 3265: 
 3266: if __name__ == "__main__":
 3267:     show_all()
