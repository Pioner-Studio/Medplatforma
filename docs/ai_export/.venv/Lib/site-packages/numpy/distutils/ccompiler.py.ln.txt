    1: import os
    2: import re
    3: import sys
    4: import platform
    5: import shlex
    6: import time
    7: import subprocess
    8: from copy import copy
    9: from pathlib import Path
   10: from distutils import ccompiler
   11: from distutils.ccompiler import (
   12:     compiler_class, gen_lib_options, get_default_compiler, new_compiler,
   13:     CCompiler
   14: )
   15: from distutils.errors import (
   16:     DistutilsExecError, DistutilsModuleError, DistutilsPlatformError,
   17:     CompileError, UnknownFileError
   18: )
   19: from distutils.sysconfig import customize_compiler
   20: from distutils.version import LooseVersion
   21: 
   22: from numpy.distutils import log
   23: from numpy.distutils.exec_command import (
   24:     filepath_from_subprocess_output, forward_bytes_to_stdout
   25: )
   26: from numpy.distutils.misc_util import cyg2win32, is_sequence, mingw32, \
   27:                                       get_num_build_jobs, \
   28:                                       _commandline_dep_string, \
   29:                                       sanitize_cxx_flags
   30: 
   31: # globals for parallel build management
   32: import threading
   33: 
   34: _job_semaphore = None
   35: _global_lock = threading.Lock()
   36: _processing_files = set()
   37: 
   38: 
   39: def _needs_build(obj, cc_args, extra_postargs, pp_opts):
   40:     """
   41:     Check if an objects needs to be rebuild based on its dependencies
   42: 
   43:     Parameters
   44:     ----------
   45:     obj : str
   46:         object file
   47: 
   48:     Returns
   49:     -------
   50:     bool
   51:     """
   52:     # defined in unixcompiler.py
   53:     dep_file = obj + '.d'
   54:     if not os.path.exists(dep_file):
   55:         return True
   56: 
   57:     # dep_file is a makefile containing 'object: dependencies'
   58:     # formatted like posix shell (spaces escaped, \ line continuations)
   59:     # the last line contains the compiler commandline arguments as some
   60:     # projects may compile an extension multiple times with different
   61:     # arguments
   62:     with open(dep_file) as f:
   63:         lines = f.readlines()
   64: 
   65:     cmdline =_commandline_dep_string(cc_args, extra_postargs, pp_opts)
   66:     last_cmdline = lines[-1]
   67:     if last_cmdline != cmdline:
   68:         return True
   69: 
   70:     contents = ''.join(lines[:-1])
   71:     deps = [x for x in shlex.split(contents, posix=True)
   72:             if x != "\n" and not x.endswith(":")]
   73: 
   74:     try:
   75:         t_obj = os.stat(obj).st_mtime
   76: 
   77:         # check if any of the dependencies is newer than the object
   78:         # the dependencies includes the source used to create the object
   79:         for f in deps:
   80:             if os.stat(f).st_mtime > t_obj:
   81:                 return True
   82:     except OSError:
   83:         # no object counts as newer (shouldn't happen if dep_file exists)
   84:         return True
   85: 
   86:     return False
   87: 
   88: 
   89: def replace_method(klass, method_name, func):
   90:     # Py3k does not have unbound method anymore, MethodType does not work
   91:     m = lambda self, *args, **kw: func(self, *args, **kw)
   92:     setattr(klass, method_name, m)
   93: 
   94: 
   95: ######################################################################
   96: ## Method that subclasses may redefine. But don't call this method,
   97: ## it i private to CCompiler class and may return unexpected
   98: ## results if used elsewhere. So, you have been warned..
   99: 
  100: def CCompiler_find_executables(self):
  101:     """
  102:     Does nothing here, but is called by the get_version method and can be
  103:     overridden by subclasses. In particular it is redefined in the `FCompiler`
  104:     class where more documentation can be found.
  105: 
  106:     """
  107:     pass
  108: 
  109: 
  110: replace_method(CCompiler, 'find_executables', CCompiler_find_executables)
  111: 
  112: 
  113: # Using customized CCompiler.spawn.
  114: def CCompiler_spawn(self, cmd, display=None, env=None):
  115:     """
  116:     Execute a command in a sub-process.
  117: 
  118:     Parameters
  119:     ----------
  120:     cmd : str
  121:         The command to execute.
  122:     display : str or sequence of str, optional
  123:         The text to add to the log file kept by `numpy.distutils`.
  124:         If not given, `display` is equal to `cmd`.
  125:     env : a dictionary for environment variables, optional
  126: 
  127:     Returns
  128:     -------
  129:     None
  130: 
  131:     Raises
  132:     ------
  133:     DistutilsExecError
  134:         If the command failed, i.e. the exit status was not 0.
  135: 
  136:     """
  137:     env = env if env is not None else dict(os.environ)
  138:     if display is None:
  139:         display = cmd
  140:         if is_sequence(display):
  141:             display = ' '.join(list(display))
  142:     log.info(display)
  143:     try:
  144:         if self.verbose:
  145:             subprocess.check_output(cmd, env=env)
  146:         else:
  147:             subprocess.check_output(cmd, stderr=subprocess.STDOUT, env=env)
  148:     except subprocess.CalledProcessError as exc:
  149:         o = exc.output
  150:         s = exc.returncode
  151:     except OSError as e:
  152:         # OSError doesn't have the same hooks for the exception
  153:         # output, but exec_command() historically would use an
  154:         # empty string for EnvironmentError (base class for
  155:         # OSError)
  156:         # o = b''
  157:         # still that would make the end-user lost in translation!
  158:         o = f"\n\n{e}\n\n\n"
  159:         try:
  160:             o = o.encode(sys.stdout.encoding)
  161:         except AttributeError:
  162:             o = o.encode('utf8')
  163:         # status previously used by exec_command() for parent
  164:         # of OSError
  165:         s = 127
  166:     else:
  167:         # use a convenience return here so that any kind of
  168:         # caught exception will execute the default code after the
  169:         # try / except block, which handles various exceptions
  170:         return None
  171: 
  172:     if is_sequence(cmd):
  173:         cmd = ' '.join(list(cmd))
  174: 
  175:     if self.verbose:
  176:         forward_bytes_to_stdout(o)
  177: 
  178:     if re.search(b'Too many open files', o):
  179:         msg = '\nTry rerunning setup command until build succeeds.'
  180:     else:
  181:         msg = ''
  182:     raise DistutilsExecError('Command "%s" failed with exit status %d%s' %
  183:                             (cmd, s, msg))
  184: 
  185: replace_method(CCompiler, 'spawn', CCompiler_spawn)
  186: 
  187: def CCompiler_object_filenames(self, source_filenames, strip_dir=0, output_dir=''):
  188:     """
  189:     Return the name of the object files for the given source files.
  190: 
  191:     Parameters
  192:     ----------
  193:     source_filenames : list of str
  194:         The list of paths to source files. Paths can be either relative or
  195:         absolute, this is handled transparently.
  196:     strip_dir : bool, optional
  197:         Whether to strip the directory from the returned paths. If True,
  198:         the file name prepended by `output_dir` is returned. Default is False.
  199:     output_dir : str, optional
  200:         If given, this path is prepended to the returned paths to the
  201:         object files.
  202: 
  203:     Returns
  204:     -------
  205:     obj_names : list of str
  206:         The list of paths to the object files corresponding to the source
  207:         files in `source_filenames`.
  208: 
  209:     """
  210:     if output_dir is None:
  211:         output_dir = ''
  212:     obj_names = []
  213:     for src_name in source_filenames:
  214:         base, ext = os.path.splitext(os.path.normpath(src_name))
  215:         base = os.path.splitdrive(base)[1] # Chop off the drive
  216:         base = base[os.path.isabs(base):]  # If abs, chop off leading /
  217:         if base.startswith('..'):
  218:             # Resolve starting relative path components, middle ones
  219:             # (if any) have been handled by os.path.normpath above.
  220:             i = base.rfind('..')+2
  221:             d = base[:i]
  222:             d = os.path.basename(os.path.abspath(d))
  223:             base = d + base[i:]
  224:         if ext not in self.src_extensions:
  225:             raise UnknownFileError("unknown file type '%s' (from '%s')" % (ext, src_name))
  226:         if strip_dir:
  227:             base = os.path.basename(base)
  228:         obj_name = os.path.join(output_dir, base + self.obj_extension)
  229:         obj_names.append(obj_name)
  230:     return obj_names
  231: 
  232: replace_method(CCompiler, 'object_filenames', CCompiler_object_filenames)
  233: 
  234: def CCompiler_compile(self, sources, output_dir=None, macros=None,
  235:                       include_dirs=None, debug=0, extra_preargs=None,
  236:                       extra_postargs=None, depends=None):
  237:     """
  238:     Compile one or more source files.
  239: 
  240:     Please refer to the Python distutils API reference for more details.
  241: 
  242:     Parameters
  243:     ----------
  244:     sources : list of str
  245:         A list of filenames
  246:     output_dir : str, optional
  247:         Path to the output directory.
  248:     macros : list of tuples
  249:         A list of macro definitions.
  250:     include_dirs : list of str, optional
  251:         The directories to add to the default include file search path for
  252:         this compilation only.
  253:     debug : bool, optional
  254:         Whether or not to output debug symbols in or alongside the object
  255:         file(s).
  256:     extra_preargs, extra_postargs : ?
  257:         Extra pre- and post-arguments.
  258:     depends : list of str, optional
  259:         A list of file names that all targets depend on.
  260: 
  261:     Returns
  262:     -------
  263:     objects : list of str
  264:         A list of object file names, one per source file `sources`.
  265: 
  266:     Raises
  267:     ------
  268:     CompileError
  269:         If compilation fails.
  270: 
  271:     """
  272:     global _job_semaphore
  273: 
  274:     jobs = get_num_build_jobs()
  275: 
  276:     # setup semaphore to not exceed number of compile jobs when parallelized at
  277:     # extension level (python >= 3.5)
  278:     with _global_lock:
  279:         if _job_semaphore is None:
  280:             _job_semaphore = threading.Semaphore(jobs)
  281: 
  282:     if not sources:
  283:         return []
  284:     from numpy.distutils.fcompiler import (FCompiler,
  285:                                            FORTRAN_COMMON_FIXED_EXTENSIONS,
  286:                                            has_f90_header)
  287:     if isinstance(self, FCompiler):
  288:         display = []
  289:         for fc in ['f77', 'f90', 'fix']:
  290:             fcomp = getattr(self, 'compiler_'+fc)
  291:             if fcomp is None:
  292:                 continue
  293:             display.append("Fortran %s compiler: %s" % (fc, ' '.join(fcomp)))
  294:         display = '\n'.join(display)
  295:     else:
  296:         ccomp = self.compiler_so
  297:         display = "C compiler: %s\n" % (' '.join(ccomp),)
  298:     log.info(display)
  299:     macros, objects, extra_postargs, pp_opts, build = \
  300:             self._setup_compile(output_dir, macros, include_dirs, sources,
  301:                                 depends, extra_postargs)
  302:     cc_args = self._get_cc_args(pp_opts, debug, extra_preargs)
  303:     display = "compile options: '%s'" % (' '.join(cc_args))
  304:     if extra_postargs:
  305:         display += "\nextra options: '%s'" % (' '.join(extra_postargs))
  306:     log.info(display)
  307: 
  308:     def single_compile(args):
  309:         obj, (src, ext) = args
  310:         if not _needs_build(obj, cc_args, extra_postargs, pp_opts):
  311:             return
  312: 
  313:         # check if we are currently already processing the same object
  314:         # happens when using the same source in multiple extensions
  315:         while True:
  316:             # need explicit lock as there is no atomic check and add with GIL
  317:             with _global_lock:
  318:                 # file not being worked on, start working
  319:                 if obj not in _processing_files:
  320:                     _processing_files.add(obj)
  321:                     break
  322:             # wait for the processing to end
  323:             time.sleep(0.1)
  324: 
  325:         try:
  326:             # retrieve slot from our #job semaphore and build
  327:             with _job_semaphore:
  328:                 self._compile(obj, src, ext, cc_args, extra_postargs, pp_opts)
  329:         finally:
  330:             # register being done processing
  331:             with _global_lock:
  332:                 _processing_files.remove(obj)
  333: 
  334: 
  335:     if isinstance(self, FCompiler):
  336:         objects_to_build = list(build.keys())
  337:         f77_objects, other_objects = [], []
  338:         for obj in objects:
  339:             if obj in objects_to_build:
  340:                 src, ext = build[obj]
  341:                 if self.compiler_type=='absoft':
  342:                     obj = cyg2win32(obj)
  343:                     src = cyg2win32(src)
  344:                 if Path(src).suffix.lower() in FORTRAN_COMMON_FIXED_EXTENSIONS \
  345:                    and not has_f90_header(src):
  346:                     f77_objects.append((obj, (src, ext)))
  347:                 else:
  348:                     other_objects.append((obj, (src, ext)))
  349: 
  350:         # f77 objects can be built in parallel
  351:         build_items = f77_objects
  352:         # build f90 modules serial, module files are generated during
  353:         # compilation and may be used by files later in the list so the
  354:         # ordering is important
  355:         for o in other_objects:
  356:             single_compile(o)
  357:     else:
  358:         build_items = build.items()
  359: 
  360:     if len(build) > 1 and jobs > 1:
  361:         # build parallel
  362:         from concurrent.futures import ThreadPoolExecutor
  363:         with ThreadPoolExecutor(jobs) as pool:
  364:             res = pool.map(single_compile, build_items)
  365:         list(res)  # access result to raise errors
  366:     else:
  367:         # build serial
  368:         for o in build_items:
  369:             single_compile(o)
  370: 
  371:     # Return *all* object filenames, not just the ones we just built.
  372:     return objects
  373: 
  374: replace_method(CCompiler, 'compile', CCompiler_compile)
  375: 
  376: def CCompiler_customize_cmd(self, cmd, ignore=()):
  377:     """
  378:     Customize compiler using distutils command.
  379: 
  380:     Parameters
  381:     ----------
  382:     cmd : class instance
  383:         An instance inheriting from ``distutils.cmd.Command``.
  384:     ignore : sequence of str, optional
  385:         List of ``distutils.ccompiler.CCompiler`` commands (without ``'set_'``) that should not be
  386:         altered. Strings that are checked for are:
  387:         ``('include_dirs', 'define', 'undef', 'libraries', 'library_dirs',
  388:         'rpath', 'link_objects')``.
  389: 
  390:     Returns
  391:     -------
  392:     None
  393: 
  394:     """
  395:     log.info('customize %s using %s' % (self.__class__.__name__,
  396:                                         cmd.__class__.__name__))
  397: 
  398:     if (
  399:         hasattr(self, 'compiler') and
  400:         'clang' in self.compiler[0] and
  401:         not (platform.machine() == 'arm64' and sys.platform == 'darwin')
  402:     ):
  403:         # clang defaults to a non-strict floating error point model.
  404:         # However, '-ftrapping-math' is not currently supported (2023-04-08)
  405:         # for macosx_arm64.
  406:         # Since NumPy and most Python libs give warnings for these, override:
  407:         self.compiler.append('-ftrapping-math')
  408:         self.compiler_so.append('-ftrapping-math')
  409: 
  410:     def allow(attr):
  411:         return getattr(cmd, attr, None) is not None and attr not in ignore
  412: 
  413:     if allow('include_dirs'):
  414:         self.set_include_dirs(cmd.include_dirs)
  415:     if allow('define'):
  416:         for (name, value) in cmd.define:
  417:             self.define_macro(name, value)
  418:     if allow('undef'):
  419:         for macro in cmd.undef:
  420:             self.undefine_macro(macro)
  421:     if allow('libraries'):
  422:         self.set_libraries(self.libraries + cmd.libraries)
  423:     if allow('library_dirs'):
  424:         self.set_library_dirs(self.library_dirs + cmd.library_dirs)
  425:     if allow('rpath'):
  426:         self.set_runtime_library_dirs(cmd.rpath)
  427:     if allow('link_objects'):
  428:         self.set_link_objects(cmd.link_objects)
  429: 
  430: replace_method(CCompiler, 'customize_cmd', CCompiler_customize_cmd)
  431: 
  432: def _compiler_to_string(compiler):
  433:     props = []
  434:     mx = 0
  435:     keys = list(compiler.executables.keys())
  436:     for key in ['version', 'libraries', 'library_dirs',
  437:                 'object_switch', 'compile_switch',
  438:                 'include_dirs', 'define', 'undef', 'rpath', 'link_objects']:
  439:         if key not in keys:
  440:             keys.append(key)
  441:     for key in keys:
  442:         if hasattr(compiler, key):
  443:             v = getattr(compiler, key)
  444:             mx = max(mx, len(key))
  445:             props.append((key, repr(v)))
  446:     fmt = '%-' + repr(mx+1) + 's = %s'
  447:     lines = [fmt % prop for prop in props]
  448:     return '\n'.join(lines)
  449: 
  450: def CCompiler_show_customization(self):
  451:     """
  452:     Print the compiler customizations to stdout.
  453: 
  454:     Parameters
  455:     ----------
  456:     None
  457: 
  458:     Returns
  459:     -------
  460:     None
  461: 
  462:     Notes
  463:     -----
  464:     Printing is only done if the distutils log threshold is < 2.
  465: 
  466:     """
  467:     try:
  468:         self.get_version()
  469:     except Exception:
  470:         pass
  471:     if log._global_log.threshold<2:
  472:         print('*'*80)
  473:         print(self.__class__)
  474:         print(_compiler_to_string(self))
  475:         print('*'*80)
  476: 
  477: replace_method(CCompiler, 'show_customization', CCompiler_show_customization)
  478: 
  479: def CCompiler_customize(self, dist, need_cxx=0):
  480:     """
  481:     Do any platform-specific customization of a compiler instance.
  482: 
  483:     This method calls ``distutils.sysconfig.customize_compiler`` for
  484:     platform-specific customization, as well as optionally remove a flag
  485:     to suppress spurious warnings in case C++ code is being compiled.
  486: 
  487:     Parameters
  488:     ----------
  489:     dist : object
  490:         This parameter is not used for anything.
  491:     need_cxx : bool, optional
  492:         Whether or not C++ has to be compiled. If so (True), the
  493:         ``"-Wstrict-prototypes"`` option is removed to prevent spurious
  494:         warnings. Default is False.
  495: 
  496:     Returns
  497:     -------
  498:     None
  499: 
  500:     Notes
  501:     -----
  502:     All the default options used by distutils can be extracted with::
  503: 
  504:       from distutils import sysconfig
  505:       sysconfig.get_config_vars('CC', 'CXX', 'OPT', 'BASECFLAGS',
  506:                                 'CCSHARED', 'LDSHARED', 'SO')
  507: 
  508:     """
  509:     # See FCompiler.customize for suggested usage.
  510:     log.info('customize %s' % (self.__class__.__name__))
  511:     customize_compiler(self)
  512:     if need_cxx:
  513:         # In general, distutils uses -Wstrict-prototypes, but this option is
  514:         # not valid for C++ code, only for C.  Remove it if it's there to
  515:         # avoid a spurious warning on every compilation.
  516:         try:
  517:             self.compiler_so.remove('-Wstrict-prototypes')
  518:         except (AttributeError, ValueError):
  519:             pass
  520: 
  521:         if hasattr(self, 'compiler') and 'cc' in self.compiler[0]:
  522:             if not self.compiler_cxx:
  523:                 if self.compiler[0].startswith('gcc'):
  524:                     a, b = 'gcc', 'g++'
  525:                 else:
  526:                     a, b = 'cc', 'c++'
  527:                 self.compiler_cxx = [self.compiler[0].replace(a, b)]\
  528:                                     + self.compiler[1:]
  529:         else:
  530:             if hasattr(self, 'compiler'):
  531:                 log.warn("#### %s #######" % (self.compiler,))
  532:             if not hasattr(self, 'compiler_cxx'):
  533:                 log.warn('Missing compiler_cxx fix for ' + self.__class__.__name__)
  534: 
  535: 
  536:     # check if compiler supports gcc style automatic dependencies
  537:     # run on every extension so skip for known good compilers
  538:     if hasattr(self, 'compiler') and ('gcc' in self.compiler[0] or
  539:                                       'g++' in self.compiler[0] or
  540:                                       'clang' in self.compiler[0]):
  541:         self._auto_depends = True
  542:     elif os.name == 'posix':
  543:         import tempfile
  544:         import shutil
  545:         tmpdir = tempfile.mkdtemp()
  546:         try:
  547:             fn = os.path.join(tmpdir, "file.c")
  548:             with open(fn, "w") as f:
  549:                 f.write("int a;\n")
  550:             self.compile([fn], output_dir=tmpdir,
  551:                          extra_preargs=['-MMD', '-MF', fn + '.d'])
  552:             self._auto_depends = True
  553:         except CompileError:
  554:             self._auto_depends = False
  555:         finally:
  556:             shutil.rmtree(tmpdir)
  557: 
  558:     return
  559: 
  560: replace_method(CCompiler, 'customize', CCompiler_customize)
  561: 
  562: def simple_version_match(pat=r'[-.\d]+', ignore='', start=''):
  563:     """
  564:     Simple matching of version numbers, for use in CCompiler and FCompiler.
  565: 
  566:     Parameters
  567:     ----------
  568:     pat : str, optional
  569:         A regular expression matching version numbers.
  570:         Default is ``r'[-.\\d]+'``.
  571:     ignore : str, optional
  572:         A regular expression matching patterns to skip.
  573:         Default is ``''``, in which case nothing is skipped.
  574:     start : str, optional
  575:         A regular expression matching the start of where to start looking
  576:         for version numbers.
  577:         Default is ``''``, in which case searching is started at the
  578:         beginning of the version string given to `matcher`.
  579: 
  580:     Returns
  581:     -------
  582:     matcher : callable
  583:         A function that is appropriate to use as the ``.version_match``
  584:         attribute of a ``distutils.ccompiler.CCompiler`` class. `matcher` takes a single parameter,
  585:         a version string.
  586: 
  587:     """
  588:     def matcher(self, version_string):
  589:         # version string may appear in the second line, so getting rid
  590:         # of new lines:
  591:         version_string = version_string.replace('\n', ' ')
  592:         pos = 0
  593:         if start:
  594:             m = re.match(start, version_string)
  595:             if not m:
  596:                 return None
  597:             pos = m.end()
  598:         while True:
  599:             m = re.search(pat, version_string[pos:])
  600:             if not m:
  601:                 return None
  602:             if ignore and re.match(ignore, m.group(0)):
  603:                 pos = m.end()
  604:                 continue
  605:             break
  606:         return m.group(0)
  607:     return matcher
  608: 
  609: def CCompiler_get_version(self, force=False, ok_status=[0]):
  610:     """
  611:     Return compiler version, or None if compiler is not available.
  612: 
  613:     Parameters
  614:     ----------
  615:     force : bool, optional
  616:         If True, force a new determination of the version, even if the
  617:         compiler already has a version attribute. Default is False.
  618:     ok_status : list of int, optional
  619:         The list of status values returned by the version look-up process
  620:         for which a version string is returned. If the status value is not
  621:         in `ok_status`, None is returned. Default is ``[0]``.
  622: 
  623:     Returns
  624:     -------
  625:     version : str or None
  626:         Version string, in the format of ``distutils.version.LooseVersion``.
  627: 
  628:     """
  629:     if not force and hasattr(self, 'version'):
  630:         return self.version
  631:     self.find_executables()
  632:     try:
  633:         version_cmd = self.version_cmd
  634:     except AttributeError:
  635:         return None
  636:     if not version_cmd or not version_cmd[0]:
  637:         return None
  638:     try:
  639:         matcher = self.version_match
  640:     except AttributeError:
  641:         try:
  642:             pat = self.version_pattern
  643:         except AttributeError:
  644:             return None
  645:         def matcher(version_string):
  646:             m = re.match(pat, version_string)
  647:             if not m:
  648:                 return None
  649:             version = m.group('version')
  650:             return version
  651: 
  652:     try:
  653:         output = subprocess.check_output(version_cmd, stderr=subprocess.STDOUT)
  654:     except subprocess.CalledProcessError as exc:
  655:         output = exc.output
  656:         status = exc.returncode
  657:     except OSError:
  658:         # match the historical returns for a parent
  659:         # exception class caught by exec_command()
  660:         status = 127
  661:         output = b''
  662:     else:
  663:         # output isn't actually a filepath but we do this
  664:         # for now to match previous distutils behavior
  665:         output = filepath_from_subprocess_output(output)
  666:         status = 0
  667: 
  668:     version = None
  669:     if status in ok_status:
  670:         version = matcher(output)
  671:         if version:
  672:             version = LooseVersion(version)
  673:     self.version = version
  674:     return version
  675: 
  676: replace_method(CCompiler, 'get_version', CCompiler_get_version)
  677: 
  678: def CCompiler_cxx_compiler(self):
  679:     """
  680:     Return the C++ compiler.
  681: 
  682:     Parameters
  683:     ----------
  684:     None
  685: 
  686:     Returns
  687:     -------
  688:     cxx : class instance
  689:         The C++ compiler, as a ``distutils.ccompiler.CCompiler`` instance.
  690: 
  691:     """
  692:     if self.compiler_type in ('msvc', 'intelw', 'intelemw'):
  693:         return self
  694: 
  695:     cxx = copy(self)
  696:     cxx.compiler_cxx = cxx.compiler_cxx
  697:     cxx.compiler_so = [cxx.compiler_cxx[0]] + \
  698:                       sanitize_cxx_flags(cxx.compiler_so[1:])
  699:     if (sys.platform.startswith(('aix', 'os400')) and
  700:             'ld_so_aix' in cxx.linker_so[0]):
  701:         # AIX needs the ld_so_aix script included with Python
  702:         cxx.linker_so = [cxx.linker_so[0], cxx.compiler_cxx[0]] \
  703:                         + cxx.linker_so[2:]
  704:     if sys.platform.startswith('os400'):
  705:         #This is required by i 7.4 and prievous for PRId64 in printf() call.
  706:         cxx.compiler_so.append('-D__STDC_FORMAT_MACROS')
  707:         #This a bug of gcc10.3, which failed to handle the TLS init.
  708:         cxx.compiler_so.append('-fno-extern-tls-init')
  709:         cxx.linker_so.append('-fno-extern-tls-init')
  710:     else:
  711:         cxx.linker_so = [cxx.compiler_cxx[0]] + cxx.linker_so[1:]
  712:     return cxx
  713: 
  714: replace_method(CCompiler, 'cxx_compiler', CCompiler_cxx_compiler)
  715: 
  716: compiler_class['intel'] = ('intelccompiler', 'IntelCCompiler',
  717:                            "Intel C Compiler for 32-bit applications")
  718: compiler_class['intele'] = ('intelccompiler', 'IntelItaniumCCompiler',
  719:                             "Intel C Itanium Compiler for Itanium-based applications")
  720: compiler_class['intelem'] = ('intelccompiler', 'IntelEM64TCCompiler',
  721:                              "Intel C Compiler for 64-bit applications")
  722: compiler_class['intelw'] = ('intelccompiler', 'IntelCCompilerW',
  723:                             "Intel C Compiler for 32-bit applications on Windows")
  724: compiler_class['intelemw'] = ('intelccompiler', 'IntelEM64TCCompilerW',
  725:                               "Intel C Compiler for 64-bit applications on Windows")
  726: compiler_class['pathcc'] = ('pathccompiler', 'PathScaleCCompiler',
  727:                             "PathScale Compiler for SiCortex-based applications")
  728: compiler_class['arm'] = ('armccompiler', 'ArmCCompiler',
  729:                             "Arm C Compiler")
  730: compiler_class['fujitsu'] = ('fujitsuccompiler', 'FujitsuCCompiler',
  731:                             "Fujitsu C Compiler")
  732: 
  733: ccompiler._default_compilers += (('linux.*', 'intel'),
  734:                                  ('linux.*', 'intele'),
  735:                                  ('linux.*', 'intelem'),
  736:                                  ('linux.*', 'pathcc'),
  737:                                  ('nt', 'intelw'),
  738:                                  ('nt', 'intelemw'))
  739: 
  740: if sys.platform == 'win32':
  741:     compiler_class['mingw32'] = ('mingw32ccompiler', 'Mingw32CCompiler',
  742:                                  "Mingw32 port of GNU C Compiler for Win32"\
  743:                                  "(for MSC built Python)")
  744:     if mingw32():
  745:         # On windows platforms, we want to default to mingw32 (gcc)
  746:         # because msvc can't build blitz stuff.
  747:         log.info('Setting mingw32 as default compiler for nt.')
  748:         ccompiler._default_compilers = (('nt', 'mingw32'),) \
  749:                                        + ccompiler._default_compilers
  750: 
  751: 
  752: _distutils_new_compiler = new_compiler
  753: def new_compiler (plat=None,
  754:                   compiler=None,
  755:                   verbose=None,
  756:                   dry_run=0,
  757:                   force=0):
  758:     # Try first C compilers from numpy.distutils.
  759:     if verbose is None:
  760:         verbose = log.get_threshold() <= log.INFO
  761:     if plat is None:
  762:         plat = os.name
  763:     try:
  764:         if compiler is None:
  765:             compiler = get_default_compiler(plat)
  766:         (module_name, class_name, long_description) = compiler_class[compiler]
  767:     except KeyError:
  768:         msg = "don't know how to compile C/C++ code on platform '%s'" % plat
  769:         if compiler is not None:
  770:             msg = msg + " with '%s' compiler" % compiler
  771:         raise DistutilsPlatformError(msg)
  772:     module_name = "numpy.distutils." + module_name
  773:     try:
  774:         __import__ (module_name)
  775:     except ImportError as e:
  776:         msg = str(e)
  777:         log.info('%s in numpy.distutils; trying from distutils',
  778:                  str(msg))
  779:         module_name = module_name[6:]
  780:         try:
  781:             __import__(module_name)
  782:         except ImportError as e:
  783:             msg = str(e)
  784:             raise DistutilsModuleError("can't compile C/C++ code: unable to load "
  785:                                        "module '%s'" % module_name)
  786:     try:
  787:         module = sys.modules[module_name]
  788:         klass = vars(module)[class_name]
  789:     except KeyError:
  790:         raise DistutilsModuleError(("can't compile C/C++ code: unable to find "
  791:                "class '%s' in module '%s'") % (class_name, module_name))
  792:     compiler = klass(None, dry_run, force)
  793:     compiler.verbose = verbose
  794:     log.debug('new_compiler returns %s' % (klass))
  795:     return compiler
  796: 
  797: ccompiler.new_compiler = new_compiler
  798: 
  799: _distutils_gen_lib_options = gen_lib_options
  800: def gen_lib_options(compiler, library_dirs, runtime_library_dirs, libraries):
  801:     # the version of this function provided by CPython allows the following
  802:     # to return lists, which are unpacked automatically:
  803:     # - compiler.runtime_library_dir_option
  804:     # our version extends the behavior to:
  805:     # - compiler.library_dir_option
  806:     # - compiler.library_option
  807:     # - compiler.find_library_file
  808:     r = _distutils_gen_lib_options(compiler, library_dirs,
  809:                                    runtime_library_dirs, libraries)
  810:     lib_opts = []
  811:     for i in r:
  812:         if is_sequence(i):
  813:             lib_opts.extend(list(i))
  814:         else:
  815:             lib_opts.append(i)
  816:     return lib_opts
  817: ccompiler.gen_lib_options = gen_lib_options
  818: 
  819: # Also fix up the various compiler modules, which do
  820: # from distutils.ccompiler import gen_lib_options
  821: # Don't bother with mwerks, as we don't support Classic Mac.
  822: for _cc in ['msvc9', 'msvc', '_msvc', 'bcpp', 'cygwinc', 'emxc', 'unixc']:
  823:     _m = sys.modules.get('distutils.' + _cc + 'compiler')
  824:     if _m is not None:
  825:         setattr(_m, 'gen_lib_options', gen_lib_options)
