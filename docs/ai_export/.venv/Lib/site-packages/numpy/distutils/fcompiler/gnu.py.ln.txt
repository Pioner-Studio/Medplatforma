    1: import re
    2: import os
    3: import sys
    4: import warnings
    5: import platform
    6: import tempfile
    7: import hashlib
    8: import base64
    9: import subprocess
   10: from subprocess import Popen, PIPE, STDOUT
   11: from numpy.distutils.exec_command import filepath_from_subprocess_output
   12: from numpy.distutils.fcompiler import FCompiler
   13: from distutils.version import LooseVersion
   14: 
   15: compilers = ['GnuFCompiler', 'Gnu95FCompiler']
   16: 
   17: TARGET_R = re.compile(r"Target: ([a-zA-Z0-9_\-]*)")
   18: 
   19: # XXX: handle cross compilation
   20: 
   21: 
   22: def is_win64():
   23:     return sys.platform == "win32" and platform.architecture()[0] == "64bit"
   24: 
   25: 
   26: class GnuFCompiler(FCompiler):
   27:     compiler_type = 'gnu'
   28:     compiler_aliases = ('g77', )
   29:     description = 'GNU Fortran 77 compiler'
   30: 
   31:     def gnu_version_match(self, version_string):
   32:         """Handle the different versions of GNU fortran compilers"""
   33:         # Strip warning(s) that may be emitted by gfortran
   34:         while version_string.startswith('gfortran: warning'):
   35:             version_string =\
   36:                 version_string[version_string.find('\n') + 1:].strip()
   37: 
   38:         # Gfortran versions from after 2010 will output a simple string
   39:         # (usually "x.y", "x.y.z" or "x.y.z-q") for ``-dumpversion``; older
   40:         # gfortrans may still return long version strings (``-dumpversion`` was
   41:         # an alias for ``--version``)
   42:         if len(version_string) <= 20:
   43:             # Try to find a valid version string
   44:             m = re.search(r'([0-9.]+)', version_string)
   45:             if m:
   46:                 # g77 provides a longer version string that starts with GNU
   47:                 # Fortran
   48:                 if version_string.startswith('GNU Fortran'):
   49:                     return ('g77', m.group(1))
   50: 
   51:                 # gfortran only outputs a version string such as #.#.#, so check
   52:                 # if the match is at the start of the string
   53:                 elif m.start() == 0:
   54:                     return ('gfortran', m.group(1))
   55:         else:
   56:             # Output probably from --version, try harder:
   57:             m = re.search(r'GNU Fortran\s+95.*?([0-9-.]+)', version_string)
   58:             if m:
   59:                 return ('gfortran', m.group(1))
   60:             m = re.search(
   61:                 r'GNU Fortran.*?\-?([0-9-.]+\.[0-9-.]+)', version_string)
   62:             if m:
   63:                 v = m.group(1)
   64:                 if v.startswith(('0', '2', '3')):
   65:                     # the '0' is for early g77's
   66:                     return ('g77', v)
   67:                 else:
   68:                     # at some point in the 4.x series, the ' 95' was dropped
   69:                     # from the version string
   70:                     return ('gfortran', v)
   71: 
   72:         # If still nothing, raise an error to make the problem easy to find.
   73:         err = 'A valid Fortran version was not found in this string:\n'
   74:         raise ValueError(err + version_string)
   75: 
   76:     def version_match(self, version_string):
   77:         v = self.gnu_version_match(version_string)
   78:         if not v or v[0] != 'g77':
   79:             return None
   80:         return v[1]
   81: 
   82:     possible_executables = ['g77', 'f77']
   83:     executables = {
   84:         'version_cmd'  : [None, "-dumpversion"],
   85:         'compiler_f77' : [None, "-g", "-Wall", "-fno-second-underscore"],
   86:         'compiler_f90' : None,  # Use --fcompiler=gnu95 for f90 codes
   87:         'compiler_fix' : None,
   88:         'linker_so'    : [None, "-g", "-Wall"],
   89:         'archiver'     : ["ar", "-cr"],
   90:         'ranlib'       : ["ranlib"],
   91:         'linker_exe'   : [None, "-g", "-Wall"]
   92:     }
   93:     module_dir_switch = None
   94:     module_include_switch = None
   95: 
   96:     # Cygwin: f771: warning: -fPIC ignored for target (all code is
   97:     # position independent)
   98:     if os.name != 'nt' and sys.platform != 'cygwin':
   99:         pic_flags = ['-fPIC']
  100: 
  101:     # use -mno-cygwin for g77 when Python is not Cygwin-Python
  102:     if sys.platform == 'win32':
  103:         for key in ['version_cmd', 'compiler_f77', 'linker_so', 'linker_exe']:
  104:             executables[key].append('-mno-cygwin')
  105: 
  106:     g2c = 'g2c'
  107:     suggested_f90_compiler = 'gnu95'
  108: 
  109:     def get_flags_linker_so(self):
  110:         opt = self.linker_so[1:]
  111:         if sys.platform == 'darwin':
  112:             target = os.environ.get('MACOSX_DEPLOYMENT_TARGET', None)
  113:             # If MACOSX_DEPLOYMENT_TARGET is set, we simply trust the value
  114:             # and leave it alone.  But, distutils will complain if the
  115:             # environment's value is different from the one in the Python
  116:             # Makefile used to build Python.  We let distutils handle this
  117:             # error checking.
  118:             if not target:
  119:                 # If MACOSX_DEPLOYMENT_TARGET is not set in the environment,
  120:                 # we try to get it first from sysconfig and then
  121:                 # fall back to setting it to 10.9 This is a reasonable default
  122:                 # even when using the official Python dist and those derived
  123:                 # from it.
  124:                 import sysconfig
  125:                 target = sysconfig.get_config_var('MACOSX_DEPLOYMENT_TARGET')
  126:                 if not target:
  127:                     target = '10.9'
  128:                     s = f'Env. variable MACOSX_DEPLOYMENT_TARGET set to {target}'
  129:                     warnings.warn(s, stacklevel=2)
  130:                 os.environ['MACOSX_DEPLOYMENT_TARGET'] = str(target)
  131:             opt.extend(['-undefined', 'dynamic_lookup', '-bundle'])
  132:         else:
  133:             opt.append("-shared")
  134:         if sys.platform.startswith('sunos'):
  135:             # SunOS often has dynamically loaded symbols defined in the
  136:             # static library libg2c.a  The linker doesn't like this.  To
  137:             # ignore the problem, use the -mimpure-text flag.  It isn't
  138:             # the safest thing, but seems to work. 'man gcc' says:
  139:             # ".. Instead of using -mimpure-text, you should compile all
  140:             #  source code with -fpic or -fPIC."
  141:             opt.append('-mimpure-text')
  142:         return opt
  143: 
  144:     def get_libgcc_dir(self):
  145:         try:
  146:             output = subprocess.check_output(self.compiler_f77 +
  147:                                             ['-print-libgcc-file-name'])
  148:         except (OSError, subprocess.CalledProcessError):
  149:             pass
  150:         else:
  151:             output = filepath_from_subprocess_output(output)
  152:             return os.path.dirname(output)
  153:         return None
  154: 
  155:     def get_libgfortran_dir(self):
  156:         if sys.platform[:5] == 'linux':
  157:             libgfortran_name = 'libgfortran.so'
  158:         elif sys.platform == 'darwin':
  159:             libgfortran_name = 'libgfortran.dylib'
  160:         else:
  161:             libgfortran_name = None
  162: 
  163:         libgfortran_dir = None
  164:         if libgfortran_name:
  165:             find_lib_arg = ['-print-file-name={0}'.format(libgfortran_name)]
  166:             try:
  167:                 output = subprocess.check_output(
  168:                                        self.compiler_f77 + find_lib_arg)
  169:             except (OSError, subprocess.CalledProcessError):
  170:                 pass
  171:             else:
  172:                 output = filepath_from_subprocess_output(output)
  173:                 libgfortran_dir = os.path.dirname(output)
  174:         return libgfortran_dir
  175: 
  176:     def get_library_dirs(self):
  177:         opt = []
  178:         if sys.platform[:5] != 'linux':
  179:             d = self.get_libgcc_dir()
  180:             if d:
  181:                 # if windows and not cygwin, libg2c lies in a different folder
  182:                 if sys.platform == 'win32' and not d.startswith('/usr/lib'):
  183:                     d = os.path.normpath(d)
  184:                     path = os.path.join(d, "lib%s.a" % self.g2c)
  185:                     if not os.path.exists(path):
  186:                         root = os.path.join(d, *((os.pardir, ) * 4))
  187:                         d2 = os.path.abspath(os.path.join(root, 'lib'))
  188:                         path = os.path.join(d2, "lib%s.a" % self.g2c)
  189:                         if os.path.exists(path):
  190:                             opt.append(d2)
  191:                 opt.append(d)
  192:         # For Macports / Linux, libgfortran and libgcc are not co-located
  193:         lib_gfortran_dir = self.get_libgfortran_dir()
  194:         if lib_gfortran_dir:
  195:             opt.append(lib_gfortran_dir)
  196:         return opt
  197: 
  198:     def get_libraries(self):
  199:         opt = []
  200:         d = self.get_libgcc_dir()
  201:         if d is not None:
  202:             g2c = self.g2c + '-pic'
  203:             f = self.static_lib_format % (g2c, self.static_lib_extension)
  204:             if not os.path.isfile(os.path.join(d, f)):
  205:                 g2c = self.g2c
  206:         else:
  207:             g2c = self.g2c
  208: 
  209:         if g2c is not None:
  210:             opt.append(g2c)
  211:         c_compiler = self.c_compiler
  212:         if sys.platform == 'win32' and c_compiler and \
  213:                 c_compiler.compiler_type == 'msvc':
  214:             opt.append('gcc')
  215:         if sys.platform == 'darwin':
  216:             opt.append('cc_dynamic')
  217:         return opt
  218: 
  219:     def get_flags_debug(self):
  220:         return ['-g']
  221: 
  222:     def get_flags_opt(self):
  223:         v = self.get_version()
  224:         if v and v <= '3.3.3':
  225:             # With this compiler version building Fortran BLAS/LAPACK
  226:             # with -O3 caused failures in lib.lapack heevr,syevr tests.
  227:             opt = ['-O2']
  228:         else:
  229:             opt = ['-O3']
  230:         opt.append('-funroll-loops')
  231:         return opt
  232: 
  233:     def _c_arch_flags(self):
  234:         """ Return detected arch flags from CFLAGS """
  235:         import sysconfig
  236:         try:
  237:             cflags = sysconfig.get_config_vars()['CFLAGS']
  238:         except KeyError:
  239:             return []
  240:         arch_re = re.compile(r"-arch\s+(\w+)")
  241:         arch_flags = []
  242:         for arch in arch_re.findall(cflags):
  243:             arch_flags += ['-arch', arch]
  244:         return arch_flags
  245: 
  246:     def get_flags_arch(self):
  247:         return []
  248: 
  249:     def runtime_library_dir_option(self, dir):
  250:         if sys.platform == 'win32' or sys.platform == 'cygwin':
  251:             # Linux/Solaris/Unix support RPATH, Windows does not
  252:             raise NotImplementedError
  253: 
  254:         # TODO: could use -Xlinker here, if it's supported
  255:         assert "," not in dir
  256: 
  257:         if sys.platform == 'darwin':
  258:             return f'-Wl,-rpath,{dir}'
  259:         elif sys.platform.startswith(('aix', 'os400')):
  260:             # AIX RPATH is called LIBPATH
  261:             return f'-Wl,-blibpath:{dir}'
  262:         else:
  263:             return f'-Wl,-rpath={dir}'
  264: 
  265: 
  266: class Gnu95FCompiler(GnuFCompiler):
  267:     compiler_type = 'gnu95'
  268:     compiler_aliases = ('gfortran', )
  269:     description = 'GNU Fortran 95 compiler'
  270: 
  271:     def version_match(self, version_string):
  272:         v = self.gnu_version_match(version_string)
  273:         if not v or v[0] != 'gfortran':
  274:             return None
  275:         v = v[1]
  276:         if LooseVersion(v) >= "4":
  277:             # gcc-4 series releases do not support -mno-cygwin option
  278:             pass
  279:         else:
  280:             # use -mno-cygwin flag for gfortran when Python is not
  281:             # Cygwin-Python
  282:             if sys.platform == 'win32':
  283:                 for key in [
  284:                         'version_cmd', 'compiler_f77', 'compiler_f90',
  285:                         'compiler_fix', 'linker_so', 'linker_exe'
  286:                 ]:
  287:                     self.executables[key].append('-mno-cygwin')
  288:         return v
  289: 
  290:     possible_executables = ['gfortran', 'f95']
  291:     executables = {
  292:         'version_cmd'  : ["<F90>", "-dumpversion"],
  293:         'compiler_f77' : [None, "-Wall", "-g", "-ffixed-form",
  294:                           "-fno-second-underscore"],
  295:         'compiler_f90' : [None, "-Wall", "-g",
  296:                           "-fno-second-underscore"],
  297:         'compiler_fix' : [None, "-Wall",  "-g","-ffixed-form",
  298:                           "-fno-second-underscore"],
  299:         'linker_so'    : ["<F90>", "-Wall", "-g"],
  300:         'archiver'     : ["ar", "-cr"],
  301:         'ranlib'       : ["ranlib"],
  302:         'linker_exe'   : [None, "-Wall"]
  303:     }
  304: 
  305:     module_dir_switch = '-J'
  306:     module_include_switch = '-I'
  307: 
  308:     if sys.platform.startswith(('aix', 'os400')):
  309:         executables['linker_so'].append('-lpthread')
  310:         if platform.architecture()[0][:2] == '64':
  311:             for key in ['compiler_f77', 'compiler_f90','compiler_fix','linker_so', 'linker_exe']:
  312:                 executables[key].append('-maix64')
  313: 
  314:     g2c = 'gfortran'
  315: 
  316:     def _universal_flags(self, cmd):
  317:         """Return a list of -arch flags for every supported architecture."""
  318:         if not sys.platform == 'darwin':
  319:             return []
  320:         arch_flags = []
  321:         # get arches the C compiler gets.
  322:         c_archs = self._c_arch_flags()
  323:         if "i386" in c_archs:
  324:             c_archs[c_archs.index("i386")] = "i686"
  325:         # check the arches the Fortran compiler supports, and compare with
  326:         # arch flags from C compiler
  327:         for arch in ["ppc", "i686", "x86_64", "ppc64", "s390x"]:
  328:             if _can_target(cmd, arch) and arch in c_archs:
  329:                 arch_flags.extend(["-arch", arch])
  330:         return arch_flags
  331: 
  332:     def get_flags(self):
  333:         flags = GnuFCompiler.get_flags(self)
  334:         arch_flags = self._universal_flags(self.compiler_f90)
  335:         if arch_flags:
  336:             flags[:0] = arch_flags
  337:         return flags
  338: 
  339:     def get_flags_linker_so(self):
  340:         flags = GnuFCompiler.get_flags_linker_so(self)
  341:         arch_flags = self._universal_flags(self.linker_so)
  342:         if arch_flags:
  343:             flags[:0] = arch_flags
  344:         return flags
  345: 
  346:     def get_library_dirs(self):
  347:         opt = GnuFCompiler.get_library_dirs(self)
  348:         if sys.platform == 'win32':
  349:             c_compiler = self.c_compiler
  350:             if c_compiler and c_compiler.compiler_type == "msvc":
  351:                 target = self.get_target()
  352:                 if target:
  353:                     d = os.path.normpath(self.get_libgcc_dir())
  354:                     root = os.path.join(d, *((os.pardir, ) * 4))
  355:                     path = os.path.join(root, "lib")
  356:                     mingwdir = os.path.normpath(path)
  357:                     if os.path.exists(os.path.join(mingwdir, "libmingwex.a")):
  358:                         opt.append(mingwdir)
  359:         # For Macports / Linux, libgfortran and libgcc are not co-located
  360:         lib_gfortran_dir = self.get_libgfortran_dir()
  361:         if lib_gfortran_dir:
  362:             opt.append(lib_gfortran_dir)
  363:         return opt
  364: 
  365:     def get_libraries(self):
  366:         opt = GnuFCompiler.get_libraries(self)
  367:         if sys.platform == 'darwin':
  368:             opt.remove('cc_dynamic')
  369:         if sys.platform == 'win32':
  370:             c_compiler = self.c_compiler
  371:             if c_compiler and c_compiler.compiler_type == "msvc":
  372:                 if "gcc" in opt:
  373:                     i = opt.index("gcc")
  374:                     opt.insert(i + 1, "mingwex")
  375:                     opt.insert(i + 1, "mingw32")
  376:             c_compiler = self.c_compiler
  377:             if c_compiler and c_compiler.compiler_type == "msvc":
  378:                 return []
  379:             else:
  380:                 pass
  381:         return opt
  382: 
  383:     def get_target(self):
  384:         try:
  385:             p = subprocess.Popen(
  386:                 self.compiler_f77 + ['-v'],
  387:                 stdin=subprocess.PIPE,
  388:                 stderr=subprocess.PIPE,
  389:             )
  390:             stdout, stderr = p.communicate()
  391:             output = (stdout or b"") + (stderr or b"")
  392:         except (OSError, subprocess.CalledProcessError):
  393:             pass
  394:         else:
  395:             output = filepath_from_subprocess_output(output)
  396:             m = TARGET_R.search(output)
  397:             if m:
  398:                 return m.group(1)
  399:         return ""
  400: 
  401:     def _hash_files(self, filenames):
  402:         h = hashlib.sha1()
  403:         for fn in filenames:
  404:             with open(fn, 'rb') as f:
  405:                 while True:
  406:                     block = f.read(131072)
  407:                     if not block:
  408:                         break
  409:                     h.update(block)
  410:         text = base64.b32encode(h.digest())
  411:         text = text.decode('ascii')
  412:         return text.rstrip('=')
  413: 
  414:     def _link_wrapper_lib(self, objects, output_dir, extra_dll_dir,
  415:                           chained_dlls, is_archive):
  416:         """Create a wrapper shared library for the given objects
  417: 
  418:         Return an MSVC-compatible lib
  419:         """
  420: 
  421:         c_compiler = self.c_compiler
  422:         if c_compiler.compiler_type != "msvc":
  423:             raise ValueError("This method only supports MSVC")
  424: 
  425:         object_hash = self._hash_files(list(objects) + list(chained_dlls))
  426: 
  427:         if is_win64():
  428:             tag = 'win_amd64'
  429:         else:
  430:             tag = 'win32'
  431: 
  432:         basename = 'lib' + os.path.splitext(
  433:             os.path.basename(objects[0]))[0][:8]
  434:         root_name = basename + '.' + object_hash + '.gfortran-' + tag
  435:         dll_name = root_name + '.dll'
  436:         def_name = root_name + '.def'
  437:         lib_name = root_name + '.lib'
  438:         dll_path = os.path.join(extra_dll_dir, dll_name)
  439:         def_path = os.path.join(output_dir, def_name)
  440:         lib_path = os.path.join(output_dir, lib_name)
  441: 
  442:         if os.path.isfile(lib_path):
  443:             # Nothing to do
  444:             return lib_path, dll_path
  445: 
  446:         if is_archive:
  447:             objects = (["-Wl,--whole-archive"] + list(objects) +
  448:                        ["-Wl,--no-whole-archive"])
  449:         self.link_shared_object(
  450:             objects,
  451:             dll_name,
  452:             output_dir=extra_dll_dir,
  453:             extra_postargs=list(chained_dlls) + [
  454:                 '-Wl,--allow-multiple-definition',
  455:                 '-Wl,--output-def,' + def_path,
  456:                 '-Wl,--export-all-symbols',
  457:                 '-Wl,--enable-auto-import',
  458:                 '-static',
  459:                 '-mlong-double-64',
  460:             ])
  461: 
  462:         # No PowerPC!
  463:         if is_win64():
  464:             specifier = '/MACHINE:X64'
  465:         else:
  466:             specifier = '/MACHINE:X86'
  467: 
  468:         # MSVC specific code
  469:         lib_args = ['/def:' + def_path, '/OUT:' + lib_path, specifier]
  470:         if not c_compiler.initialized:
  471:             c_compiler.initialize()
  472:         c_compiler.spawn([c_compiler.lib] + lib_args)
  473: 
  474:         return lib_path, dll_path
  475: 
  476:     def can_ccompiler_link(self, compiler):
  477:         # MSVC cannot link objects compiled by GNU fortran
  478:         return compiler.compiler_type not in ("msvc", )
  479: 
  480:     def wrap_unlinkable_objects(self, objects, output_dir, extra_dll_dir):
  481:         """
  482:         Convert a set of object files that are not compatible with the default
  483:         linker, to a file that is compatible.
  484:         """
  485:         if self.c_compiler.compiler_type == "msvc":
  486:             # Compile a DLL and return the lib for the DLL as
  487:             # the object. Also keep track of previous DLLs that
  488:             # we have compiled so that we can link against them.
  489: 
  490:             # If there are .a archives, assume they are self-contained
  491:             # static libraries, and build separate DLLs for each
  492:             archives = []
  493:             plain_objects = []
  494:             for obj in objects:
  495:                 if obj.lower().endswith('.a'):
  496:                     archives.append(obj)
  497:                 else:
  498:                     plain_objects.append(obj)
  499: 
  500:             chained_libs = []
  501:             chained_dlls = []
  502:             for archive in archives[::-1]:
  503:                 lib, dll = self._link_wrapper_lib(
  504:                     [archive],
  505:                     output_dir,
  506:                     extra_dll_dir,
  507:                     chained_dlls=chained_dlls,
  508:                     is_archive=True)
  509:                 chained_libs.insert(0, lib)
  510:                 chained_dlls.insert(0, dll)
  511: 
  512:             if not plain_objects:
  513:                 return chained_libs
  514: 
  515:             lib, dll = self._link_wrapper_lib(
  516:                 plain_objects,
  517:                 output_dir,
  518:                 extra_dll_dir,
  519:                 chained_dlls=chained_dlls,
  520:                 is_archive=False)
  521:             return [lib] + chained_libs
  522:         else:
  523:             raise ValueError("Unsupported C compiler")
  524: 
  525: 
  526: def _can_target(cmd, arch):
  527:     """Return true if the architecture supports the -arch flag"""
  528:     newcmd = cmd[:]
  529:     fid, filename = tempfile.mkstemp(suffix=".f")
  530:     os.close(fid)
  531:     try:
  532:         d = os.path.dirname(filename)
  533:         output = os.path.splitext(filename)[0] + ".o"
  534:         try:
  535:             newcmd.extend(["-arch", arch, "-c", filename])
  536:             p = Popen(newcmd, stderr=STDOUT, stdout=PIPE, cwd=d)
  537:             p.communicate()
  538:             return p.returncode == 0
  539:         finally:
  540:             if os.path.exists(output):
  541:                 os.remove(output)
  542:     finally:
  543:         os.remove(filename)
  544: 
  545: 
  546: if __name__ == '__main__':
  547:     from distutils import log
  548:     from numpy.distutils import customized_fcompiler
  549:     log.set_verbosity(2)
  550: 
  551:     print(customized_fcompiler('gnu').get_version())
  552:     try:
  553:         print(customized_fcompiler('g95').get_version())
  554:     except Exception as e:
  555:         print(e)
