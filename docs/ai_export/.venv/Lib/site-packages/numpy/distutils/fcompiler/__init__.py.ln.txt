    1: """numpy.distutils.fcompiler
    2: 
    3: Contains FCompiler, an abstract base class that defines the interface
    4: for the numpy.distutils Fortran compiler abstraction model.
    5: 
    6: Terminology:
    7: 
    8: To be consistent, where the term 'executable' is used, it means the single
    9: file, like 'gcc', that is executed, and should be a string. In contrast,
   10: 'command' means the entire command line, like ['gcc', '-c', 'file.c'], and
   11: should be a list.
   12: 
   13: But note that FCompiler.executables is actually a dictionary of commands.
   14: 
   15: """
   16: __all__ = ['FCompiler', 'new_fcompiler', 'show_fcompilers',
   17:            'dummy_fortran_file']
   18: 
   19: import os
   20: import sys
   21: import re
   22: from pathlib import Path
   23: 
   24: from distutils.sysconfig import get_python_lib
   25: from distutils.fancy_getopt import FancyGetopt
   26: from distutils.errors import DistutilsModuleError, \
   27:      DistutilsExecError, CompileError, LinkError, DistutilsPlatformError
   28: from distutils.util import split_quoted, strtobool
   29: 
   30: from numpy.distutils.ccompiler import CCompiler, gen_lib_options
   31: from numpy.distutils import log
   32: from numpy.distutils.misc_util import is_string, all_strings, is_sequence, \
   33:     make_temp_file, get_shared_lib_extension
   34: from numpy.distutils.exec_command import find_executable
   35: from numpy.distutils import _shell_utils
   36: 
   37: from .environment import EnvironmentConfig
   38: 
   39: __metaclass__ = type
   40: 
   41: 
   42: FORTRAN_COMMON_FIXED_EXTENSIONS = ['.for', '.ftn', '.f77', '.f']
   43: 
   44: 
   45: class CompilerNotFound(Exception):
   46:     pass
   47: 
   48: def flaglist(s):
   49:     if is_string(s):
   50:         return split_quoted(s)
   51:     else:
   52:         return s
   53: 
   54: def str2bool(s):
   55:     if is_string(s):
   56:         return strtobool(s)
   57:     return bool(s)
   58: 
   59: def is_sequence_of_strings(seq):
   60:     return is_sequence(seq) and all_strings(seq)
   61: 
   62: class FCompiler(CCompiler):
   63:     """Abstract base class to define the interface that must be implemented
   64:     by real Fortran compiler classes.
   65: 
   66:     Methods that subclasses may redefine:
   67: 
   68:         update_executables(), find_executables(), get_version()
   69:         get_flags(), get_flags_opt(), get_flags_arch(), get_flags_debug()
   70:         get_flags_f77(), get_flags_opt_f77(), get_flags_arch_f77(),
   71:         get_flags_debug_f77(), get_flags_f90(), get_flags_opt_f90(),
   72:         get_flags_arch_f90(), get_flags_debug_f90(),
   73:         get_flags_fix(), get_flags_linker_so()
   74: 
   75:     DON'T call these methods (except get_version) after
   76:     constructing a compiler instance or inside any other method.
   77:     All methods, except update_executables() and find_executables(),
   78:     may call the get_version() method.
   79: 
   80:     After constructing a compiler instance, always call customize(dist=None)
   81:     method that finalizes compiler construction and makes the following
   82:     attributes available:
   83:       compiler_f77
   84:       compiler_f90
   85:       compiler_fix
   86:       linker_so
   87:       archiver
   88:       ranlib
   89:       libraries
   90:       library_dirs
   91:     """
   92: 
   93:     # These are the environment variables and distutils keys used.
   94:     # Each configuration description is
   95:     # (<hook name>, <environment variable>, <key in distutils.cfg>, <convert>, <append>)
   96:     # The hook names are handled by the self._environment_hook method.
   97:     #  - names starting with 'self.' call methods in this class
   98:     #  - names starting with 'exe.' return the key in the executables dict
   99:     #  - names like 'flags.YYY' return self.get_flag_YYY()
  100:     # convert is either None or a function to convert a string to the
  101:     # appropriate type used.
  102: 
  103:     distutils_vars = EnvironmentConfig(
  104:         distutils_section='config_fc',
  105:         noopt = (None, None, 'noopt', str2bool, False),
  106:         noarch = (None, None, 'noarch', str2bool, False),
  107:         debug = (None, None, 'debug', str2bool, False),
  108:         verbose = (None, None, 'verbose', str2bool, False),
  109:     )
  110: 
  111:     command_vars = EnvironmentConfig(
  112:         distutils_section='config_fc',
  113:         compiler_f77 = ('exe.compiler_f77', 'F77', 'f77exec', None, False),
  114:         compiler_f90 = ('exe.compiler_f90', 'F90', 'f90exec', None, False),
  115:         compiler_fix = ('exe.compiler_fix', 'F90', 'f90exec', None, False),
  116:         version_cmd = ('exe.version_cmd', None, None, None, False),
  117:         linker_so = ('exe.linker_so', 'LDSHARED', 'ldshared', None, False),
  118:         linker_exe = ('exe.linker_exe', 'LD', 'ld', None, False),
  119:         archiver = (None, 'AR', 'ar', None, False),
  120:         ranlib = (None, 'RANLIB', 'ranlib', None, False),
  121:     )
  122: 
  123:     flag_vars = EnvironmentConfig(
  124:         distutils_section='config_fc',
  125:         f77 = ('flags.f77', 'F77FLAGS', 'f77flags', flaglist, True),
  126:         f90 = ('flags.f90', 'F90FLAGS', 'f90flags', flaglist, True),
  127:         free = ('flags.free', 'FREEFLAGS', 'freeflags', flaglist, True),
  128:         fix = ('flags.fix', None, None, flaglist, False),
  129:         opt = ('flags.opt', 'FOPT', 'opt', flaglist, True),
  130:         opt_f77 = ('flags.opt_f77', None, None, flaglist, False),
  131:         opt_f90 = ('flags.opt_f90', None, None, flaglist, False),
  132:         arch = ('flags.arch', 'FARCH', 'arch', flaglist, False),
  133:         arch_f77 = ('flags.arch_f77', None, None, flaglist, False),
  134:         arch_f90 = ('flags.arch_f90', None, None, flaglist, False),
  135:         debug = ('flags.debug', 'FDEBUG', 'fdebug', flaglist, True),
  136:         debug_f77 = ('flags.debug_f77', None, None, flaglist, False),
  137:         debug_f90 = ('flags.debug_f90', None, None, flaglist, False),
  138:         flags = ('self.get_flags', 'FFLAGS', 'fflags', flaglist, True),
  139:         linker_so = ('flags.linker_so', 'LDFLAGS', 'ldflags', flaglist, True),
  140:         linker_exe = ('flags.linker_exe', 'LDFLAGS', 'ldflags', flaglist, True),
  141:         ar = ('flags.ar', 'ARFLAGS', 'arflags', flaglist, True),
  142:     )
  143: 
  144:     language_map = {'.f': 'f77',
  145:                     '.for': 'f77',
  146:                     '.F': 'f77',    # XXX: needs preprocessor
  147:                     '.ftn': 'f77',
  148:                     '.f77': 'f77',
  149:                     '.f90': 'f90',
  150:                     '.F90': 'f90',  # XXX: needs preprocessor
  151:                     '.f95': 'f90',
  152:                     }
  153:     language_order = ['f90', 'f77']
  154: 
  155: 
  156:     # These will be set by the subclass
  157: 
  158:     compiler_type = None
  159:     compiler_aliases = ()
  160:     version_pattern = None
  161: 
  162:     possible_executables = []
  163:     executables = {
  164:         'version_cmd': ["f77", "-v"],
  165:         'compiler_f77': ["f77"],
  166:         'compiler_f90': ["f90"],
  167:         'compiler_fix': ["f90", "-fixed"],
  168:         'linker_so': ["f90", "-shared"],
  169:         'linker_exe': ["f90"],
  170:         'archiver': ["ar", "-cr"],
  171:         'ranlib': None,
  172:         }
  173: 
  174:     # If compiler does not support compiling Fortran 90 then it can
  175:     # suggest using another compiler. For example, gnu would suggest
  176:     # gnu95 compiler type when there are F90 sources.
  177:     suggested_f90_compiler = None
  178: 
  179:     compile_switch = "-c"
  180:     object_switch = "-o "   # Ending space matters! It will be stripped
  181:                             # but if it is missing then object_switch
  182:                             # will be prefixed to object file name by
  183:                             # string concatenation.
  184:     library_switch = "-o "  # Ditto!
  185: 
  186:     # Switch to specify where module files are created and searched
  187:     # for USE statement.  Normally it is a string and also here ending
  188:     # space matters. See above.
  189:     module_dir_switch = None
  190: 
  191:     # Switch to specify where module files are searched for USE statement.
  192:     module_include_switch = '-I'
  193: 
  194:     pic_flags = []           # Flags to create position-independent code
  195: 
  196:     src_extensions = ['.for', '.ftn', '.f77', '.f', '.f90', '.f95', '.F', '.F90', '.FOR']
  197:     obj_extension = ".o"
  198: 
  199:     shared_lib_extension = get_shared_lib_extension()
  200:     static_lib_extension = ".a"  # or .lib
  201:     static_lib_format = "lib%s%s" # or %s%s
  202:     shared_lib_format = "%s%s"
  203:     exe_extension = ""
  204: 
  205:     _exe_cache = {}
  206: 
  207:     _executable_keys = ['version_cmd', 'compiler_f77', 'compiler_f90',
  208:                         'compiler_fix', 'linker_so', 'linker_exe', 'archiver',
  209:                         'ranlib']
  210: 
  211:     # This will be set by new_fcompiler when called in
  212:     # command/{build_ext.py, build_clib.py, config.py} files.
  213:     c_compiler = None
  214: 
  215:     # extra_{f77,f90}_compile_args are set by build_ext.build_extension method
  216:     extra_f77_compile_args = []
  217:     extra_f90_compile_args = []
  218: 
  219:     def __init__(self, *args, **kw):
  220:         CCompiler.__init__(self, *args, **kw)
  221:         self.distutils_vars = self.distutils_vars.clone(self._environment_hook)
  222:         self.command_vars = self.command_vars.clone(self._environment_hook)
  223:         self.flag_vars = self.flag_vars.clone(self._environment_hook)
  224:         self.executables = self.executables.copy()
  225:         for e in self._executable_keys:
  226:             if e not in self.executables:
  227:                 self.executables[e] = None
  228: 
  229:         # Some methods depend on .customize() being called first, so
  230:         # this keeps track of whether that's happened yet.
  231:         self._is_customised = False
  232: 
  233:     def __copy__(self):
  234:         obj = self.__new__(self.__class__)
  235:         obj.__dict__.update(self.__dict__)
  236:         obj.distutils_vars = obj.distutils_vars.clone(obj._environment_hook)
  237:         obj.command_vars = obj.command_vars.clone(obj._environment_hook)
  238:         obj.flag_vars = obj.flag_vars.clone(obj._environment_hook)
  239:         obj.executables = obj.executables.copy()
  240:         return obj
  241: 
  242:     def copy(self):
  243:         return self.__copy__()
  244: 
  245:     # Use properties for the attributes used by CCompiler. Setting them
  246:     # as attributes from the self.executables dictionary is error-prone,
  247:     # so we get them from there each time.
  248:     def _command_property(key):
  249:         def fget(self):
  250:             assert self._is_customised
  251:             return self.executables[key]
  252:         return property(fget=fget)
  253:     version_cmd = _command_property('version_cmd')
  254:     compiler_f77 = _command_property('compiler_f77')
  255:     compiler_f90 = _command_property('compiler_f90')
  256:     compiler_fix = _command_property('compiler_fix')
  257:     linker_so = _command_property('linker_so')
  258:     linker_exe = _command_property('linker_exe')
  259:     archiver = _command_property('archiver')
  260:     ranlib = _command_property('ranlib')
  261: 
  262:     # Make our terminology consistent.
  263:     def set_executable(self, key, value):
  264:         self.set_command(key, value)
  265: 
  266:     def set_commands(self, **kw):
  267:         for k, v in kw.items():
  268:             self.set_command(k, v)
  269: 
  270:     def set_command(self, key, value):
  271:         if not key in self._executable_keys:
  272:             raise ValueError(
  273:                 "unknown executable '%s' for class %s" %
  274:                 (key, self.__class__.__name__))
  275:         if is_string(value):
  276:             value = split_quoted(value)
  277:         assert value is None or is_sequence_of_strings(value[1:]), (key, value)
  278:         self.executables[key] = value
  279: 
  280:     ######################################################################
  281:     ## Methods that subclasses may redefine. But don't call these methods!
  282:     ## They are private to FCompiler class and may return unexpected
  283:     ## results if used elsewhere. So, you have been warned..
  284: 
  285:     def find_executables(self):
  286:         """Go through the self.executables dictionary, and attempt to
  287:         find and assign appropriate executables.
  288: 
  289:         Executable names are looked for in the environment (environment
  290:         variables, the distutils.cfg, and command line), the 0th-element of
  291:         the command list, and the self.possible_executables list.
  292: 
  293:         Also, if the 0th element is "<F77>" or "<F90>", the Fortran 77
  294:         or the Fortran 90 compiler executable is used, unless overridden
  295:         by an environment setting.
  296: 
  297:         Subclasses should call this if overridden.
  298:         """
  299:         assert self._is_customised
  300:         exe_cache = self._exe_cache
  301:         def cached_find_executable(exe):
  302:             if exe in exe_cache:
  303:                 return exe_cache[exe]
  304:             fc_exe = find_executable(exe)
  305:             exe_cache[exe] = exe_cache[fc_exe] = fc_exe
  306:             return fc_exe
  307:         def verify_command_form(name, value):
  308:             if value is not None and not is_sequence_of_strings(value):
  309:                 raise ValueError(
  310:                     "%s value %r is invalid in class %s" %
  311:                     (name, value, self.__class__.__name__))
  312:         def set_exe(exe_key, f77=None, f90=None):
  313:             cmd = self.executables.get(exe_key, None)
  314:             if not cmd:
  315:                 return None
  316:             # Note that we get cmd[0] here if the environment doesn't
  317:             # have anything set
  318:             exe_from_environ = getattr(self.command_vars, exe_key)
  319:             if not exe_from_environ:
  320:                 possibles = [f90, f77] + self.possible_executables
  321:             else:
  322:                 possibles = [exe_from_environ] + self.possible_executables
  323: 
  324:             seen = set()
  325:             unique_possibles = []
  326:             for e in possibles:
  327:                 if e == '<F77>':
  328:                     e = f77
  329:                 elif e == '<F90>':
  330:                     e = f90
  331:                 if not e or e in seen:
  332:                     continue
  333:                 seen.add(e)
  334:                 unique_possibles.append(e)
  335: 
  336:             for exe in unique_possibles:
  337:                 fc_exe = cached_find_executable(exe)
  338:                 if fc_exe:
  339:                     cmd[0] = fc_exe
  340:                     return fc_exe
  341:             self.set_command(exe_key, None)
  342:             return None
  343: 
  344:         ctype = self.compiler_type
  345:         f90 = set_exe('compiler_f90')
  346:         if not f90:
  347:             f77 = set_exe('compiler_f77')
  348:             if f77:
  349:                 log.warn('%s: no Fortran 90 compiler found' % ctype)
  350:             else:
  351:                 raise CompilerNotFound('%s: f90 nor f77' % ctype)
  352:         else:
  353:             f77 = set_exe('compiler_f77', f90=f90)
  354:             if not f77:
  355:                 log.warn('%s: no Fortran 77 compiler found' % ctype)
  356:             set_exe('compiler_fix', f90=f90)
  357: 
  358:         set_exe('linker_so', f77=f77, f90=f90)
  359:         set_exe('linker_exe', f77=f77, f90=f90)
  360:         set_exe('version_cmd', f77=f77, f90=f90)
  361:         set_exe('archiver')
  362:         set_exe('ranlib')
  363: 
  364:     def update_executables(self):
  365:         """Called at the beginning of customisation. Subclasses should
  366:         override this if they need to set up the executables dictionary.
  367: 
  368:         Note that self.find_executables() is run afterwards, so the
  369:         self.executables dictionary values can contain <F77> or <F90> as
  370:         the command, which will be replaced by the found F77 or F90
  371:         compiler.
  372:         """
  373:         pass
  374: 
  375:     def get_flags(self):
  376:         """List of flags common to all compiler types."""
  377:         return [] + self.pic_flags
  378: 
  379:     def _get_command_flags(self, key):
  380:         cmd = self.executables.get(key, None)
  381:         if cmd is None:
  382:             return []
  383:         return cmd[1:]
  384: 
  385:     def get_flags_f77(self):
  386:         """List of Fortran 77 specific flags."""
  387:         return self._get_command_flags('compiler_f77')
  388:     def get_flags_f90(self):
  389:         """List of Fortran 90 specific flags."""
  390:         return self._get_command_flags('compiler_f90')
  391:     def get_flags_free(self):
  392:         """List of Fortran 90 free format specific flags."""
  393:         return []
  394:     def get_flags_fix(self):
  395:         """List of Fortran 90 fixed format specific flags."""
  396:         return self._get_command_flags('compiler_fix')
  397:     def get_flags_linker_so(self):
  398:         """List of linker flags to build a shared library."""
  399:         return self._get_command_flags('linker_so')
  400:     def get_flags_linker_exe(self):
  401:         """List of linker flags to build an executable."""
  402:         return self._get_command_flags('linker_exe')
  403:     def get_flags_ar(self):
  404:         """List of archiver flags. """
  405:         return self._get_command_flags('archiver')
  406:     def get_flags_opt(self):
  407:         """List of architecture independent compiler flags."""
  408:         return []
  409:     def get_flags_arch(self):
  410:         """List of architecture dependent compiler flags."""
  411:         return []
  412:     def get_flags_debug(self):
  413:         """List of compiler flags to compile with debugging information."""
  414:         return []
  415: 
  416:     get_flags_opt_f77 = get_flags_opt_f90 = get_flags_opt
  417:     get_flags_arch_f77 = get_flags_arch_f90 = get_flags_arch
  418:     get_flags_debug_f77 = get_flags_debug_f90 = get_flags_debug
  419: 
  420:     def get_libraries(self):
  421:         """List of compiler libraries."""
  422:         return self.libraries[:]
  423:     def get_library_dirs(self):
  424:         """List of compiler library directories."""
  425:         return self.library_dirs[:]
  426: 
  427:     def get_version(self, force=False, ok_status=[0]):
  428:         assert self._is_customised
  429:         version = CCompiler.get_version(self, force=force, ok_status=ok_status)
  430:         if version is None:
  431:             raise CompilerNotFound()
  432:         return version
  433: 
  434: 
  435:     ############################################################
  436: 
  437:     ## Public methods:
  438: 
  439:     def customize(self, dist = None):
  440:         """Customize Fortran compiler.
  441: 
  442:         This method gets Fortran compiler specific information from
  443:         (i) class definition, (ii) environment, (iii) distutils config
  444:         files, and (iv) command line (later overrides earlier).
  445: 
  446:         This method should be always called after constructing a
  447:         compiler instance. But not in __init__ because Distribution
  448:         instance is needed for (iii) and (iv).
  449:         """
  450:         log.info('customize %s' % (self.__class__.__name__))
  451: 
  452:         self._is_customised = True
  453: 
  454:         self.distutils_vars.use_distribution(dist)
  455:         self.command_vars.use_distribution(dist)
  456:         self.flag_vars.use_distribution(dist)
  457: 
  458:         self.update_executables()
  459: 
  460:         # find_executables takes care of setting the compiler commands,
  461:         # version_cmd, linker_so, linker_exe, ar, and ranlib
  462:         self.find_executables()
  463: 
  464:         noopt = self.distutils_vars.get('noopt', False)
  465:         noarch = self.distutils_vars.get('noarch', noopt)
  466:         debug = self.distutils_vars.get('debug', False)
  467: 
  468:         f77 = self.command_vars.compiler_f77
  469:         f90 = self.command_vars.compiler_f90
  470: 
  471:         f77flags = []
  472:         f90flags = []
  473:         freeflags = []
  474:         fixflags = []
  475: 
  476:         if f77:
  477:             f77 = _shell_utils.NativeParser.split(f77)
  478:             f77flags = self.flag_vars.f77
  479:         if f90:
  480:             f90 = _shell_utils.NativeParser.split(f90)
  481:             f90flags = self.flag_vars.f90
  482:             freeflags = self.flag_vars.free
  483:         # XXX Assuming that free format is default for f90 compiler.
  484:         fix = self.command_vars.compiler_fix
  485:         # NOTE: this and similar examples are probably just
  486:         # excluding --coverage flag when F90 = gfortran --coverage
  487:         # instead of putting that flag somewhere more appropriate
  488:         # this and similar examples where a Fortran compiler
  489:         # environment variable has been customized by CI or a user
  490:         # should perhaps eventually be more thoroughly tested and more
  491:         # robustly handled
  492:         if fix:
  493:             fix = _shell_utils.NativeParser.split(fix)
  494:             fixflags = self.flag_vars.fix + f90flags
  495: 
  496:         oflags, aflags, dflags = [], [], []
  497:         # examine get_flags_<tag>_<compiler> for extra flags
  498:         # only add them if the method is different from get_flags_<tag>
  499:         def get_flags(tag, flags):
  500:             # note that self.flag_vars.<tag> calls self.get_flags_<tag>()
  501:             flags.extend(getattr(self.flag_vars, tag))
  502:             this_get = getattr(self, 'get_flags_' + tag)
  503:             for name, c, flagvar in [('f77', f77, f77flags),
  504:                                      ('f90', f90, f90flags),
  505:                                      ('f90', fix, fixflags)]:
  506:                 t = '%s_%s' % (tag, name)
  507:                 if c and this_get is not getattr(self, 'get_flags_' + t):
  508:                     flagvar.extend(getattr(self.flag_vars, t))
  509:         if not noopt:
  510:             get_flags('opt', oflags)
  511:             if not noarch:
  512:                 get_flags('arch', aflags)
  513:         if debug:
  514:             get_flags('debug', dflags)
  515: 
  516:         fflags = self.flag_vars.flags + dflags + oflags + aflags
  517: 
  518:         if f77:
  519:             self.set_commands(compiler_f77=f77+f77flags+fflags)
  520:         if f90:
  521:             self.set_commands(compiler_f90=f90+freeflags+f90flags+fflags)
  522:         if fix:
  523:             self.set_commands(compiler_fix=fix+fixflags+fflags)
  524: 
  525: 
  526:         #XXX: Do we need LDSHARED->SOSHARED, LDFLAGS->SOFLAGS
  527:         linker_so = self.linker_so
  528:         if linker_so:
  529:             linker_so_flags = self.flag_vars.linker_so
  530:             if sys.platform.startswith('aix'):
  531:                 python_lib = get_python_lib(standard_lib=1)
  532:                 ld_so_aix = os.path.join(python_lib, 'config', 'ld_so_aix')
  533:                 python_exp = os.path.join(python_lib, 'config', 'python.exp')
  534:                 linker_so = [ld_so_aix] + linker_so + ['-bI:'+python_exp]
  535:             if sys.platform.startswith('os400'):
  536:                 from distutils.sysconfig import get_config_var
  537:                 python_config = get_config_var('LIBPL')
  538:                 ld_so_aix = os.path.join(python_config, 'ld_so_aix')
  539:                 python_exp = os.path.join(python_config, 'python.exp')
  540:                 linker_so = [ld_so_aix] + linker_so + ['-bI:'+python_exp]
  541:             self.set_commands(linker_so=linker_so+linker_so_flags)
  542: 
  543:         linker_exe = self.linker_exe
  544:         if linker_exe:
  545:             linker_exe_flags = self.flag_vars.linker_exe
  546:             self.set_commands(linker_exe=linker_exe+linker_exe_flags)
  547: 
  548:         ar = self.command_vars.archiver
  549:         if ar:
  550:             arflags = self.flag_vars.ar
  551:             self.set_commands(archiver=[ar]+arflags)
  552: 
  553:         self.set_library_dirs(self.get_library_dirs())
  554:         self.set_libraries(self.get_libraries())
  555: 
  556:     def dump_properties(self):
  557:         """Print out the attributes of a compiler instance."""
  558:         props = []
  559:         for key in list(self.executables.keys()) + \
  560:                 ['version', 'libraries', 'library_dirs',
  561:                  'object_switch', 'compile_switch']:
  562:             if hasattr(self, key):
  563:                 v = getattr(self, key)
  564:                 props.append((key, None, '= '+repr(v)))
  565:         props.sort()
  566: 
  567:         pretty_printer = FancyGetopt(props)
  568:         for l in pretty_printer.generate_help("%s instance properties:" \
  569:                                               % (self.__class__.__name__)):
  570:             if l[:4]=='  --':
  571:                 l = '  ' + l[4:]
  572:             print(l)
  573: 
  574:     ###################
  575: 
  576:     def _compile(self, obj, src, ext, cc_args, extra_postargs, pp_opts):
  577:         """Compile 'src' to product 'obj'."""
  578:         src_flags = {}
  579:         if Path(src).suffix.lower() in FORTRAN_COMMON_FIXED_EXTENSIONS \
  580:            and not has_f90_header(src):
  581:             flavor = ':f77'
  582:             compiler = self.compiler_f77
  583:             src_flags = get_f77flags(src)
  584:             extra_compile_args = self.extra_f77_compile_args or []
  585:         elif is_free_format(src):
  586:             flavor = ':f90'
  587:             compiler = self.compiler_f90
  588:             if compiler is None:
  589:                 raise DistutilsExecError('f90 not supported by %s needed for %s'\
  590:                       % (self.__class__.__name__, src))
  591:             extra_compile_args = self.extra_f90_compile_args or []
  592:         else:
  593:             flavor = ':fix'
  594:             compiler = self.compiler_fix
  595:             if compiler is None:
  596:                 raise DistutilsExecError('f90 (fixed) not supported by %s needed for %s'\
  597:                       % (self.__class__.__name__, src))
  598:             extra_compile_args = self.extra_f90_compile_args or []
  599:         if self.object_switch[-1]==' ':
  600:             o_args = [self.object_switch.strip(), obj]
  601:         else:
  602:             o_args = [self.object_switch.strip()+obj]
  603: 
  604:         assert self.compile_switch.strip()
  605:         s_args = [self.compile_switch, src]
  606: 
  607:         if extra_compile_args:
  608:             log.info('extra %s options: %r' \
  609:                      % (flavor[1:], ' '.join(extra_compile_args)))
  610: 
  611:         extra_flags = src_flags.get(self.compiler_type, [])
  612:         if extra_flags:
  613:             log.info('using compile options from source: %r' \
  614:                      % ' '.join(extra_flags))
  615: 
  616:         command = compiler + cc_args + extra_flags + s_args + o_args \
  617:                   + extra_postargs + extra_compile_args
  618: 
  619:         display = '%s: %s' % (os.path.basename(compiler[0]) + flavor,
  620:                               src)
  621:         try:
  622:             self.spawn(command, display=display)
  623:         except DistutilsExecError as e:
  624:             msg = str(e)
  625:             raise CompileError(msg) from None
  626: 
  627:     def module_options(self, module_dirs, module_build_dir):
  628:         options = []
  629:         if self.module_dir_switch is not None:
  630:             if self.module_dir_switch[-1]==' ':
  631:                 options.extend([self.module_dir_switch.strip(), module_build_dir])
  632:             else:
  633:                 options.append(self.module_dir_switch.strip()+module_build_dir)
  634:         else:
  635:             print('XXX: module_build_dir=%r option ignored' % (module_build_dir))
  636:             print('XXX: Fix module_dir_switch for ', self.__class__.__name__)
  637:         if self.module_include_switch is not None:
  638:             for d in [module_build_dir]+module_dirs:
  639:                 options.append('%s%s' % (self.module_include_switch, d))
  640:         else:
  641:             print('XXX: module_dirs=%r option ignored' % (module_dirs))
  642:             print('XXX: Fix module_include_switch for ', self.__class__.__name__)
  643:         return options
  644: 
  645:     def library_option(self, lib):
  646:         return "-l" + lib
  647:     def library_dir_option(self, dir):
  648:         return "-L" + dir
  649: 
  650:     def link(self, target_desc, objects,
  651:              output_filename, output_dir=None, libraries=None,
  652:              library_dirs=None, runtime_library_dirs=None,
  653:              export_symbols=None, debug=0, extra_preargs=None,
  654:              extra_postargs=None, build_temp=None, target_lang=None):
  655:         objects, output_dir = self._fix_object_args(objects, output_dir)
  656:         libraries, library_dirs, runtime_library_dirs = \
  657:             self._fix_lib_args(libraries, library_dirs, runtime_library_dirs)
  658: 
  659:         lib_opts = gen_lib_options(self, library_dirs, runtime_library_dirs,
  660:                                    libraries)
  661:         if is_string(output_dir):
  662:             output_filename = os.path.join(output_dir, output_filename)
  663:         elif output_dir is not None:
  664:             raise TypeError("'output_dir' must be a string or None")
  665: 
  666:         if self._need_link(objects, output_filename):
  667:             if self.library_switch[-1]==' ':
  668:                 o_args = [self.library_switch.strip(), output_filename]
  669:             else:
  670:                 o_args = [self.library_switch.strip()+output_filename]
  671: 
  672:             if is_string(self.objects):
  673:                 ld_args = objects + [self.objects]
  674:             else:
  675:                 ld_args = objects + self.objects
  676:             ld_args = ld_args + lib_opts + o_args
  677:             if debug:
  678:                 ld_args[:0] = ['-g']
  679:             if extra_preargs:
  680:                 ld_args[:0] = extra_preargs
  681:             if extra_postargs:
  682:                 ld_args.extend(extra_postargs)
  683:             self.mkpath(os.path.dirname(output_filename))
  684:             if target_desc == CCompiler.EXECUTABLE:
  685:                 linker = self.linker_exe[:]
  686:             else:
  687:                 linker = self.linker_so[:]
  688:             command = linker + ld_args
  689:             try:
  690:                 self.spawn(command)
  691:             except DistutilsExecError as e:
  692:                 msg = str(e)
  693:                 raise LinkError(msg) from None
  694:         else:
  695:             log.debug("skipping %s (up-to-date)", output_filename)
  696: 
  697:     def _environment_hook(self, name, hook_name):
  698:         if hook_name is None:
  699:             return None
  700:         if is_string(hook_name):
  701:             if hook_name.startswith('self.'):
  702:                 hook_name = hook_name[5:]
  703:                 hook = getattr(self, hook_name)
  704:                 return hook()
  705:             elif hook_name.startswith('exe.'):
  706:                 hook_name = hook_name[4:]
  707:                 var = self.executables[hook_name]
  708:                 if var:
  709:                     return var[0]
  710:                 else:
  711:                     return None
  712:             elif hook_name.startswith('flags.'):
  713:                 hook_name = hook_name[6:]
  714:                 hook = getattr(self, 'get_flags_' + hook_name)
  715:                 return hook()
  716:         else:
  717:             return hook_name()
  718: 
  719:     def can_ccompiler_link(self, ccompiler):
  720:         """
  721:         Check if the given C compiler can link objects produced by
  722:         this compiler.
  723:         """
  724:         return True
  725: 
  726:     def wrap_unlinkable_objects(self, objects, output_dir, extra_dll_dir):
  727:         """
  728:         Convert a set of object files that are not compatible with the default
  729:         linker, to a file that is compatible.
  730: 
  731:         Parameters
  732:         ----------
  733:         objects : list
  734:             List of object files to include.
  735:         output_dir : str
  736:             Output directory to place generated object files.
  737:         extra_dll_dir : str
  738:             Output directory to place extra DLL files that need to be
  739:             included on Windows.
  740: 
  741:         Returns
  742:         -------
  743:         converted_objects : list of str
  744:              List of converted object files.
  745:              Note that the number of output files is not necessarily
  746:              the same as inputs.
  747: 
  748:         """
  749:         raise NotImplementedError()
  750: 
  751:     ## class FCompiler
  752: 
  753: _default_compilers = (
  754:     # sys.platform mappings
  755:     ('win32', ('gnu', 'intelv', 'absoft', 'compaqv', 'intelev', 'gnu95', 'g95',
  756:                'intelvem', 'intelem', 'flang')),
  757:     ('cygwin.*', ('gnu', 'intelv', 'absoft', 'compaqv', 'intelev', 'gnu95', 'g95')),
  758:     ('linux.*', ('arm', 'gnu95', 'intel', 'lahey', 'pg', 'nv', 'absoft', 'nag',
  759:                  'vast', 'compaq', 'intele', 'intelem', 'gnu', 'g95',
  760:                  'pathf95', 'nagfor', 'fujitsu')),
  761:     ('darwin.*', ('gnu95', 'nag', 'nagfor', 'absoft', 'ibm', 'intel', 'gnu',
  762:                  'g95', 'pg')),
  763:     ('sunos.*', ('sun', 'gnu', 'gnu95', 'g95')),
  764:     ('irix.*', ('mips', 'gnu', 'gnu95',)),
  765:     ('aix.*', ('ibm', 'gnu', 'gnu95',)),
  766:     # os.name mappings
  767:     ('posix', ('gnu', 'gnu95',)),
  768:     ('nt', ('gnu', 'gnu95',)),
  769:     ('mac', ('gnu95', 'gnu', 'pg')),
  770:     )
  771: 
  772: fcompiler_class = None
  773: fcompiler_aliases = None
  774: 
  775: def load_all_fcompiler_classes():
  776:     """Cache all the FCompiler classes found in modules in the
  777:     numpy.distutils.fcompiler package.
  778:     """
  779:     from glob import glob
  780:     global fcompiler_class, fcompiler_aliases
  781:     if fcompiler_class is not None:
  782:         return
  783:     pys = os.path.join(os.path.dirname(__file__), '*.py')
  784:     fcompiler_class = {}
  785:     fcompiler_aliases = {}
  786:     for fname in glob(pys):
  787:         module_name, ext = os.path.splitext(os.path.basename(fname))
  788:         module_name = 'numpy.distutils.fcompiler.' + module_name
  789:         __import__ (module_name)
  790:         module = sys.modules[module_name]
  791:         if hasattr(module, 'compilers'):
  792:             for cname in module.compilers:
  793:                 klass = getattr(module, cname)
  794:                 desc = (klass.compiler_type, klass, klass.description)
  795:                 fcompiler_class[klass.compiler_type] = desc
  796:                 for alias in klass.compiler_aliases:
  797:                     if alias in fcompiler_aliases:
  798:                         raise ValueError("alias %r defined for both %s and %s"
  799:                                          % (alias, klass.__name__,
  800:                                             fcompiler_aliases[alias][1].__name__))
  801:                     fcompiler_aliases[alias] = desc
  802: 
  803: def _find_existing_fcompiler(compiler_types,
  804:                              osname=None, platform=None,
  805:                              requiref90=False,
  806:                              c_compiler=None):
  807:     from numpy.distutils.core import get_distribution
  808:     dist = get_distribution(always=True)
  809:     for compiler_type in compiler_types:
  810:         v = None
  811:         try:
  812:             c = new_fcompiler(plat=platform, compiler=compiler_type,
  813:                               c_compiler=c_compiler)
  814:             c.customize(dist)
  815:             v = c.get_version()
  816:             if requiref90 and c.compiler_f90 is None:
  817:                 v = None
  818:                 new_compiler = c.suggested_f90_compiler
  819:                 if new_compiler:
  820:                     log.warn('Trying %r compiler as suggested by %r '
  821:                              'compiler for f90 support.' % (compiler_type,
  822:                                                             new_compiler))
  823:                     c = new_fcompiler(plat=platform, compiler=new_compiler,
  824:                                       c_compiler=c_compiler)
  825:                     c.customize(dist)
  826:                     v = c.get_version()
  827:                     if v is not None:
  828:                         compiler_type = new_compiler
  829:             if requiref90 and c.compiler_f90 is None:
  830:                 raise ValueError('%s does not support compiling f90 codes, '
  831:                                  'skipping.' % (c.__class__.__name__))
  832:         except DistutilsModuleError:
  833:             log.debug("_find_existing_fcompiler: compiler_type='%s' raised DistutilsModuleError", compiler_type)
  834:         except CompilerNotFound:
  835:             log.debug("_find_existing_fcompiler: compiler_type='%s' not found", compiler_type)
  836:         if v is not None:
  837:             return compiler_type
  838:     return None
  839: 
  840: def available_fcompilers_for_platform(osname=None, platform=None):
  841:     if osname is None:
  842:         osname = os.name
  843:     if platform is None:
  844:         platform = sys.platform
  845:     matching_compiler_types = []
  846:     for pattern, compiler_type in _default_compilers:
  847:         if re.match(pattern, platform) or re.match(pattern, osname):
  848:             for ct in compiler_type:
  849:                 if ct not in matching_compiler_types:
  850:                     matching_compiler_types.append(ct)
  851:     if not matching_compiler_types:
  852:         matching_compiler_types.append('gnu')
  853:     return matching_compiler_types
  854: 
  855: def get_default_fcompiler(osname=None, platform=None, requiref90=False,
  856:                           c_compiler=None):
  857:     """Determine the default Fortran compiler to use for the given
  858:     platform."""
  859:     matching_compiler_types = available_fcompilers_for_platform(osname,
  860:                                                                 platform)
  861:     log.info("get_default_fcompiler: matching types: '%s'",
  862:              matching_compiler_types)
  863:     compiler_type =  _find_existing_fcompiler(matching_compiler_types,
  864:                                               osname=osname,
  865:                                               platform=platform,
  866:                                               requiref90=requiref90,
  867:                                               c_compiler=c_compiler)
  868:     return compiler_type
  869: 
  870: # Flag to avoid rechecking for Fortran compiler every time
  871: failed_fcompilers = set()
  872: 
  873: def new_fcompiler(plat=None,
  874:                   compiler=None,
  875:                   verbose=0,
  876:                   dry_run=0,
  877:                   force=0,
  878:                   requiref90=False,
  879:                   c_compiler = None):
  880:     """Generate an instance of some FCompiler subclass for the supplied
  881:     platform/compiler combination.
  882:     """
  883:     global failed_fcompilers
  884:     fcompiler_key = (plat, compiler)
  885:     if fcompiler_key in failed_fcompilers:
  886:         return None
  887: 
  888:     load_all_fcompiler_classes()
  889:     if plat is None:
  890:         plat = os.name
  891:     if compiler is None:
  892:         compiler = get_default_fcompiler(plat, requiref90=requiref90,
  893:                                          c_compiler=c_compiler)
  894:     if compiler in fcompiler_class:
  895:         module_name, klass, long_description = fcompiler_class[compiler]
  896:     elif compiler in fcompiler_aliases:
  897:         module_name, klass, long_description = fcompiler_aliases[compiler]
  898:     else:
  899:         msg = "don't know how to compile Fortran code on platform '%s'" % plat
  900:         if compiler is not None:
  901:             msg = msg + " with '%s' compiler." % compiler
  902:             msg = msg + " Supported compilers are: %s)" \
  903:                   % (','.join(fcompiler_class.keys()))
  904:         log.warn(msg)
  905:         failed_fcompilers.add(fcompiler_key)
  906:         return None
  907: 
  908:     compiler = klass(verbose=verbose, dry_run=dry_run, force=force)
  909:     compiler.c_compiler = c_compiler
  910:     return compiler
  911: 
  912: def show_fcompilers(dist=None):
  913:     """Print list of available compilers (used by the "--help-fcompiler"
  914:     option to "config_fc").
  915:     """
  916:     if dist is None:
  917:         from distutils.dist import Distribution
  918:         from numpy.distutils.command.config_compiler import config_fc
  919:         dist = Distribution()
  920:         dist.script_name = os.path.basename(sys.argv[0])
  921:         dist.script_args = ['config_fc'] + sys.argv[1:]
  922:         try:
  923:             dist.script_args.remove('--help-fcompiler')
  924:         except ValueError:
  925:             pass
  926:         dist.cmdclass['config_fc'] = config_fc
  927:         dist.parse_config_files()
  928:         dist.parse_command_line()
  929:     compilers = []
  930:     compilers_na = []
  931:     compilers_ni = []
  932:     if not fcompiler_class:
  933:         load_all_fcompiler_classes()
  934:     platform_compilers = available_fcompilers_for_platform()
  935:     for compiler in platform_compilers:
  936:         v = None
  937:         log.set_verbosity(-2)
  938:         try:
  939:             c = new_fcompiler(compiler=compiler, verbose=dist.verbose)
  940:             c.customize(dist)
  941:             v = c.get_version()
  942:         except (DistutilsModuleError, CompilerNotFound) as e:
  943:             log.debug("show_fcompilers: %s not found" % (compiler,))
  944:             log.debug(repr(e))
  945: 
  946:         if v is None:
  947:             compilers_na.append(("fcompiler="+compiler, None,
  948:                               fcompiler_class[compiler][2]))
  949:         else:
  950:             c.dump_properties()
  951:             compilers.append(("fcompiler="+compiler, None,
  952:                               fcompiler_class[compiler][2] + ' (%s)' % v))
  953: 
  954:     compilers_ni = list(set(fcompiler_class.keys()) - set(platform_compilers))
  955:     compilers_ni = [("fcompiler="+fc, None, fcompiler_class[fc][2])
  956:                     for fc in compilers_ni]
  957: 
  958:     compilers.sort()
  959:     compilers_na.sort()
  960:     compilers_ni.sort()
  961:     pretty_printer = FancyGetopt(compilers)
  962:     pretty_printer.print_help("Fortran compilers found:")
  963:     pretty_printer = FancyGetopt(compilers_na)
  964:     pretty_printer.print_help("Compilers available for this "
  965:                               "platform, but not found:")
  966:     if compilers_ni:
  967:         pretty_printer = FancyGetopt(compilers_ni)
  968:         pretty_printer.print_help("Compilers not available on this platform:")
  969:     print("For compiler details, run 'config_fc --verbose' setup command.")
  970: 
  971: 
  972: def dummy_fortran_file():
  973:     fo, name = make_temp_file(suffix='.f')
  974:     fo.write("      subroutine dummy()\n      end\n")
  975:     fo.close()
  976:     return name[:-2]
  977: 
  978: 
  979: _has_f_header = re.compile(r'-\*-\s*fortran\s*-\*-', re.I).search
  980: _has_f90_header = re.compile(r'-\*-\s*f90\s*-\*-', re.I).search
  981: _has_fix_header = re.compile(r'-\*-\s*fix\s*-\*-', re.I).search
  982: _free_f90_start = re.compile(r'[^c*!]\s*[^\s\d\t]', re.I).match
  983: 
  984: def is_free_format(file):
  985:     """Check if file is in free format Fortran."""
  986:     # f90 allows both fixed and free format, assuming fixed unless
  987:     # signs of free format are detected.
  988:     result = 0
  989:     with open(file, encoding='latin1') as f:
  990:         line = f.readline()
  991:         n = 10000 # the number of non-comment lines to scan for hints
  992:         if _has_f_header(line) or _has_fix_header(line):
  993:             n = 0
  994:         elif _has_f90_header(line):
  995:             n = 0
  996:             result = 1
  997:         while n>0 and line:
  998:             line = line.rstrip()
  999:             if line and line[0]!='!':
 1000:                 n -= 1
 1001:                 if (line[0]!='\t' and _free_f90_start(line[:5])) or line[-1:]=='&':
 1002:                     result = 1
 1003:                     break
 1004:             line = f.readline()
 1005:     return result
 1006: 
 1007: def has_f90_header(src):
 1008:     with open(src, encoding='latin1') as f:
 1009:         line = f.readline()
 1010:     return _has_f90_header(line) or _has_fix_header(line)
 1011: 
 1012: _f77flags_re = re.compile(r'(c|)f77flags\s*\(\s*(?P<fcname>\w+)\s*\)\s*=\s*(?P<fflags>.*)', re.I)
 1013: def get_f77flags(src):
 1014:     """
 1015:     Search the first 20 lines of fortran 77 code for line pattern
 1016:       `CF77FLAGS(<fcompiler type>)=<f77 flags>`
 1017:     Return a dictionary {<fcompiler type>:<f77 flags>}.
 1018:     """
 1019:     flags = {}
 1020:     with open(src, encoding='latin1') as f:
 1021:         i = 0
 1022:         for line in f:
 1023:             i += 1
 1024:             if i>20: break
 1025:             m = _f77flags_re.match(line)
 1026:             if not m: continue
 1027:             fcname = m.group('fcname').strip()
 1028:             fflags = m.group('fflags').strip()
 1029:             flags[fcname] = split_quoted(fflags)
 1030:     return flags
 1031: 
 1032: # TODO: implement get_f90flags and use it in _compile similarly to get_f77flags
 1033: 
 1034: if __name__ == '__main__':
 1035:     show_fcompilers()
