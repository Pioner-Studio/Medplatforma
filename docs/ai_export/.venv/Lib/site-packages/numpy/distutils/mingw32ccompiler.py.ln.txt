    1: """
    2: Support code for building Python extensions on Windows.
    3: 
    4:     # NT stuff
    5:     # 1. Make sure libpython<version>.a exists for gcc.  If not, build it.
    6:     # 2. Force windows to use gcc (we're struggling with MSVC and g77 support)
    7:     # 3. Force windows to use g77
    8: 
    9: """
   10: import os
   11: import sys
   12: import subprocess
   13: import re
   14: import textwrap
   15: 
   16: # Overwrite certain distutils.ccompiler functions:
   17: import numpy.distutils.ccompiler  # noqa: F401
   18: from numpy.distutils import log
   19: # NT stuff
   20: # 1. Make sure libpython<version>.a exists for gcc.  If not, build it.
   21: # 2. Force windows to use gcc (we're struggling with MSVC and g77 support)
   22: #    --> this is done in numpy/distutils/ccompiler.py
   23: # 3. Force windows to use g77
   24: 
   25: import distutils.cygwinccompiler
   26: from distutils.unixccompiler import UnixCCompiler
   27: 
   28: try:
   29:     from distutils.msvccompiler import get_build_version as get_build_msvc_version
   30: except ImportError:
   31:     def get_build_msvc_version():
   32:         return None
   33: 
   34: from distutils.errors import UnknownFileError
   35: from numpy.distutils.misc_util import (msvc_runtime_library,
   36:                                        msvc_runtime_version,
   37:                                        msvc_runtime_major,
   38:                                        get_build_architecture)
   39: 
   40: def get_msvcr_replacement():
   41:     """Replacement for outdated version of get_msvcr from cygwinccompiler"""
   42:     msvcr = msvc_runtime_library()
   43:     return [] if msvcr is None else [msvcr]
   44: 
   45: 
   46: # Useful to generate table of symbols from a dll
   47: _START = re.compile(r'\[Ordinal/Name Pointer\] Table')
   48: _TABLE = re.compile(r'^\s+\[([\s*[0-9]*)\] ([a-zA-Z0-9_]*)')
   49: 
   50: # the same as cygwin plus some additional parameters
   51: class Mingw32CCompiler(distutils.cygwinccompiler.CygwinCCompiler):
   52:     """ A modified MingW32 compiler compatible with an MSVC built Python.
   53: 
   54:     """
   55: 
   56:     compiler_type = 'mingw32'
   57: 
   58:     def __init__ (self,
   59:                   verbose=0,
   60:                   dry_run=0,
   61:                   force=0):
   62: 
   63:         distutils.cygwinccompiler.CygwinCCompiler.__init__ (self, verbose,
   64:                                                             dry_run, force)
   65: 
   66:         # **changes: eric jones 4/11/01
   67:         # 1. Check for import library on Windows.  Build if it doesn't exist.
   68: 
   69:         build_import_library()
   70: 
   71:         # Check for custom msvc runtime library on Windows. Build if it doesn't exist.
   72:         msvcr_success = build_msvcr_library()
   73:         msvcr_dbg_success = build_msvcr_library(debug=True)
   74:         if msvcr_success or msvcr_dbg_success:
   75:             # add preprocessor statement for using customized msvcr lib
   76:             self.define_macro('NPY_MINGW_USE_CUSTOM_MSVCR')
   77: 
   78:         # Define the MSVC version as hint for MinGW
   79:         msvcr_version = msvc_runtime_version()
   80:         if msvcr_version:
   81:             self.define_macro('__MSVCRT_VERSION__', '0x%04i' % msvcr_version)
   82: 
   83:         # MS_WIN64 should be defined when building for amd64 on windows,
   84:         # but python headers define it only for MS compilers, which has all
   85:         # kind of bad consequences, like using Py_ModuleInit4 instead of
   86:         # Py_ModuleInit4_64, etc... So we add it here
   87:         if get_build_architecture() == 'AMD64':
   88:             self.set_executables(
   89:                 compiler='gcc -g -DDEBUG -DMS_WIN64 -O0 -Wall',
   90:                 compiler_so='gcc -g -DDEBUG -DMS_WIN64 -O0 -Wall '
   91:                             '-Wstrict-prototypes',
   92:                 linker_exe='gcc -g',
   93:                 linker_so='gcc -g -shared')
   94:         else:
   95:             self.set_executables(
   96:                 compiler='gcc -O2 -Wall',
   97:                 compiler_so='gcc -O2 -Wall -Wstrict-prototypes',
   98:                 linker_exe='g++ ',
   99:                 linker_so='g++ -shared')
  100:         # added for python2.3 support
  101:         # we can't pass it through set_executables because pre 2.2 would fail
  102:         self.compiler_cxx = ['g++']
  103: 
  104:         # Maybe we should also append -mthreads, but then the finished dlls
  105:         # need another dll (mingwm10.dll see Mingw32 docs) (-mthreads: Support
  106:         # thread-safe exception handling on `Mingw32')
  107: 
  108:         # no additional libraries needed
  109:         #self.dll_libraries=[]
  110:         return
  111: 
  112:     # __init__ ()
  113: 
  114:     def link(self,
  115:              target_desc,
  116:              objects,
  117:              output_filename,
  118:              output_dir,
  119:              libraries,
  120:              library_dirs,
  121:              runtime_library_dirs,
  122:              export_symbols = None,
  123:              debug=0,
  124:              extra_preargs=None,
  125:              extra_postargs=None,
  126:              build_temp=None,
  127:              target_lang=None):
  128:         # Include the appropriate MSVC runtime library if Python was built
  129:         # with MSVC >= 7.0 (MinGW standard is msvcrt)
  130:         runtime_library = msvc_runtime_library()
  131:         if runtime_library:
  132:             if not libraries:
  133:                 libraries = []
  134:             libraries.append(runtime_library)
  135:         args = (self,
  136:                 target_desc,
  137:                 objects,
  138:                 output_filename,
  139:                 output_dir,
  140:                 libraries,
  141:                 library_dirs,
  142:                 runtime_library_dirs,
  143:                 None, #export_symbols, we do this in our def-file
  144:                 debug,
  145:                 extra_preargs,
  146:                 extra_postargs,
  147:                 build_temp,
  148:                 target_lang)
  149:         func = UnixCCompiler.link
  150:         func(*args[:func.__code__.co_argcount])
  151:         return
  152: 
  153:     def object_filenames (self,
  154:                           source_filenames,
  155:                           strip_dir=0,
  156:                           output_dir=''):
  157:         if output_dir is None: output_dir = ''
  158:         obj_names = []
  159:         for src_name in source_filenames:
  160:             # use normcase to make sure '.rc' is really '.rc' and not '.RC'
  161:             (base, ext) = os.path.splitext (os.path.normcase(src_name))
  162: 
  163:             # added these lines to strip off windows drive letters
  164:             # without it, .o files are placed next to .c files
  165:             # instead of the build directory
  166:             drv, base = os.path.splitdrive(base)
  167:             if drv:
  168:                 base = base[1:]
  169: 
  170:             if ext not in (self.src_extensions + ['.rc', '.res']):
  171:                 raise UnknownFileError(
  172:                       "unknown file type '%s' (from '%s')" % \
  173:                       (ext, src_name))
  174:             if strip_dir:
  175:                 base = os.path.basename (base)
  176:             if ext == '.res' or ext == '.rc':
  177:                 # these need to be compiled to object files
  178:                 obj_names.append (os.path.join (output_dir,
  179:                                                 base + ext + self.obj_extension))
  180:             else:
  181:                 obj_names.append (os.path.join (output_dir,
  182:                                                 base + self.obj_extension))
  183:         return obj_names
  184: 
  185:     # object_filenames ()
  186: 
  187: 
  188: def find_python_dll():
  189:     # We can't do much here:
  190:     # - find it in the virtualenv (sys.prefix)
  191:     # - find it in python main dir (sys.base_prefix, if in a virtualenv)
  192:     # - in system32,
  193:     # - otherwise (Sxs), I don't know how to get it.
  194:     stems = [sys.prefix]
  195:     if sys.base_prefix != sys.prefix:
  196:         stems.append(sys.base_prefix)
  197: 
  198:     sub_dirs = ['', 'lib', 'bin']
  199:     # generate possible combinations of directory trees and sub-directories
  200:     lib_dirs = []
  201:     for stem in stems:
  202:         for folder in sub_dirs:
  203:             lib_dirs.append(os.path.join(stem, folder))
  204: 
  205:     # add system directory as well
  206:     if 'SYSTEMROOT' in os.environ:
  207:         lib_dirs.append(os.path.join(os.environ['SYSTEMROOT'], 'System32'))
  208: 
  209:     # search in the file system for possible candidates
  210:     major_version, minor_version = tuple(sys.version_info[:2])
  211:     implementation = sys.implementation.name
  212:     if implementation == 'cpython':
  213:         dllname = f'python{major_version}{minor_version}.dll'
  214:     elif implementation == 'pypy':
  215:         dllname = f'libpypy{major_version}.{minor_version}-c.dll'
  216:     else:
  217:         dllname = f'Unknown platform {implementation}'
  218:     print("Looking for %s" % dllname)
  219:     for folder in lib_dirs:
  220:         dll = os.path.join(folder, dllname)
  221:         if os.path.exists(dll):
  222:             return dll
  223: 
  224:     raise ValueError("%s not found in %s" % (dllname, lib_dirs))
  225: 
  226: def dump_table(dll):
  227:     st = subprocess.check_output(["objdump.exe", "-p", dll])
  228:     return st.split(b'\n')
  229: 
  230: def generate_def(dll, dfile):
  231:     """Given a dll file location,  get all its exported symbols and dump them
  232:     into the given def file.
  233: 
  234:     The .def file will be overwritten"""
  235:     dump = dump_table(dll)
  236:     for i in range(len(dump)):
  237:         if _START.match(dump[i].decode()):
  238:             break
  239:     else:
  240:         raise ValueError("Symbol table not found")
  241: 
  242:     syms = []
  243:     for j in range(i+1, len(dump)):
  244:         m = _TABLE.match(dump[j].decode())
  245:         if m:
  246:             syms.append((int(m.group(1).strip()), m.group(2)))
  247:         else:
  248:             break
  249: 
  250:     if len(syms) == 0:
  251:         log.warn('No symbols found in %s' % dll)
  252: 
  253:     with open(dfile, 'w') as d:
  254:         d.write('LIBRARY        %s\n' % os.path.basename(dll))
  255:         d.write(';CODE          PRELOAD MOVEABLE DISCARDABLE\n')
  256:         d.write(';DATA          PRELOAD SINGLE\n')
  257:         d.write('\nEXPORTS\n')
  258:         for s in syms:
  259:             #d.write('@%d    %s\n' % (s[0], s[1]))
  260:             d.write('%s\n' % s[1])
  261: 
  262: def find_dll(dll_name):
  263: 
  264:     arch = {'AMD64' : 'amd64',
  265:             'ARM64' : 'arm64',
  266:             'Intel' : 'x86'}[get_build_architecture()]
  267: 
  268:     def _find_dll_in_winsxs(dll_name):
  269:         # Walk through the WinSxS directory to find the dll.
  270:         winsxs_path = os.path.join(os.environ.get('WINDIR', r'C:\WINDOWS'),
  271:                                    'winsxs')
  272:         if not os.path.exists(winsxs_path):
  273:             return None
  274:         for root, dirs, files in os.walk(winsxs_path):
  275:             if dll_name in files and arch in root:
  276:                 return os.path.join(root, dll_name)
  277:         return None
  278: 
  279:     def _find_dll_in_path(dll_name):
  280:         # First, look in the Python directory, then scan PATH for
  281:         # the given dll name.
  282:         for path in [sys.prefix] + os.environ['PATH'].split(';'):
  283:             filepath = os.path.join(path, dll_name)
  284:             if os.path.exists(filepath):
  285:                 return os.path.abspath(filepath)
  286: 
  287:     return _find_dll_in_winsxs(dll_name) or _find_dll_in_path(dll_name)
  288: 
  289: def build_msvcr_library(debug=False):
  290:     if os.name != 'nt':
  291:         return False
  292: 
  293:     # If the version number is None, then we couldn't find the MSVC runtime at
  294:     # all, because we are running on a Python distribution which is customed
  295:     # compiled; trust that the compiler is the same as the one available to us
  296:     # now, and that it is capable of linking with the correct runtime without
  297:     # any extra options.
  298:     msvcr_ver = msvc_runtime_major()
  299:     if msvcr_ver is None:
  300:         log.debug('Skip building import library: '
  301:                   'Runtime is not compiled with MSVC')
  302:         return False
  303: 
  304:     # Skip using a custom library for versions < MSVC 8.0
  305:     if msvcr_ver < 80:
  306:         log.debug('Skip building msvcr library:'
  307:                   ' custom functionality not present')
  308:         return False
  309: 
  310:     msvcr_name = msvc_runtime_library()
  311:     if debug:
  312:         msvcr_name += 'd'
  313: 
  314:     # Skip if custom library already exists
  315:     out_name = "lib%s.a" % msvcr_name
  316:     out_file = os.path.join(sys.prefix, 'libs', out_name)
  317:     if os.path.isfile(out_file):
  318:         log.debug('Skip building msvcr library: "%s" exists' %
  319:                   (out_file,))
  320:         return True
  321: 
  322:     # Find the msvcr dll
  323:     msvcr_dll_name = msvcr_name + '.dll'
  324:     dll_file = find_dll(msvcr_dll_name)
  325:     if not dll_file:
  326:         log.warn('Cannot build msvcr library: "%s" not found' %
  327:                  msvcr_dll_name)
  328:         return False
  329: 
  330:     def_name = "lib%s.def" % msvcr_name
  331:     def_file = os.path.join(sys.prefix, 'libs', def_name)
  332: 
  333:     log.info('Building msvcr library: "%s" (from %s)' \
  334:              % (out_file, dll_file))
  335: 
  336:     # Generate a symbol definition file from the msvcr dll
  337:     generate_def(dll_file, def_file)
  338: 
  339:     # Create a custom mingw library for the given symbol definitions
  340:     cmd = ['dlltool', '-d', def_file, '-l', out_file]
  341:     retcode = subprocess.call(cmd)
  342: 
  343:     # Clean up symbol definitions
  344:     os.remove(def_file)
  345: 
  346:     return (not retcode)
  347: 
  348: def build_import_library():
  349:     if os.name != 'nt':
  350:         return
  351: 
  352:     arch = get_build_architecture()
  353:     if arch == 'AMD64':
  354:         return _build_import_library_amd64()
  355:     if arch == 'ARM64':
  356:         return _build_import_library_arm64()
  357:     elif arch == 'Intel':
  358:         return _build_import_library_x86()
  359:     else:
  360:         raise ValueError("Unhandled arch %s" % arch)
  361: 
  362: def _check_for_import_lib():
  363:     """Check if an import library for the Python runtime already exists."""
  364:     major_version, minor_version = tuple(sys.version_info[:2])
  365: 
  366:     # patterns for the file name of the library itself
  367:     patterns = ['libpython%d%d.a',
  368:                 'libpython%d%d.dll.a',
  369:                 'libpython%d.%d.dll.a']
  370: 
  371:     # directory trees that may contain the library
  372:     stems = [sys.prefix]
  373:     if hasattr(sys, 'base_prefix') and sys.base_prefix != sys.prefix:
  374:         stems.append(sys.base_prefix)
  375:     elif hasattr(sys, 'real_prefix') and sys.real_prefix != sys.prefix:
  376:         stems.append(sys.real_prefix)
  377: 
  378:     # possible subdirectories within those trees where it is placed
  379:     sub_dirs = ['libs', 'lib']
  380: 
  381:     # generate a list of candidate locations
  382:     candidates = []
  383:     for pat in patterns:
  384:         filename = pat % (major_version, minor_version)
  385:         for stem_dir in stems:
  386:             for folder in sub_dirs:
  387:                 candidates.append(os.path.join(stem_dir, folder, filename))
  388: 
  389:     # test the filesystem to see if we can find any of these
  390:     for fullname in candidates:
  391:         if os.path.isfile(fullname):
  392:             # already exists, in location given
  393:             return (True, fullname)
  394: 
  395:     # needs to be built, preferred location given first
  396:     return (False, candidates[0])
  397: 
  398: def _build_import_library_amd64():
  399:     out_exists, out_file = _check_for_import_lib()
  400:     if out_exists:
  401:         log.debug('Skip building import library: "%s" exists', out_file)
  402:         return
  403: 
  404:     # get the runtime dll for which we are building import library
  405:     dll_file = find_python_dll()
  406:     log.info('Building import library (arch=AMD64): "%s" (from %s)' %
  407:              (out_file, dll_file))
  408: 
  409:     # generate symbol list from this library
  410:     def_name = "python%d%d.def" % tuple(sys.version_info[:2])
  411:     def_file = os.path.join(sys.prefix, 'libs', def_name)
  412:     generate_def(dll_file, def_file)
  413: 
  414:     # generate import library from this symbol list
  415:     cmd = ['dlltool', '-d', def_file, '-l', out_file]
  416:     subprocess.check_call(cmd)
  417: 
  418: def _build_import_library_arm64():
  419:     out_exists, out_file = _check_for_import_lib()
  420:     if out_exists:
  421:         log.debug('Skip building import library: "%s" exists', out_file)
  422:         return
  423: 
  424:     # get the runtime dll for which we are building import library
  425:     dll_file = find_python_dll()
  426:     log.info('Building import library (arch=ARM64): "%s" (from %s)' %
  427:              (out_file, dll_file))
  428: 
  429:     # generate symbol list from this library
  430:     def_name = "python%d%d.def" % tuple(sys.version_info[:2])
  431:     def_file = os.path.join(sys.prefix, 'libs', def_name)
  432:     generate_def(dll_file, def_file)
  433: 
  434:     # generate import library from this symbol list
  435:     cmd = ['dlltool', '-d', def_file, '-l', out_file]
  436:     subprocess.check_call(cmd)
  437: 
  438: def _build_import_library_x86():
  439:     """ Build the import libraries for Mingw32-gcc on Windows
  440:     """
  441:     out_exists, out_file = _check_for_import_lib()
  442:     if out_exists:
  443:         log.debug('Skip building import library: "%s" exists', out_file)
  444:         return
  445: 
  446:     lib_name = "python%d%d.lib" % tuple(sys.version_info[:2])
  447:     lib_file = os.path.join(sys.prefix, 'libs', lib_name)
  448:     if not os.path.isfile(lib_file):
  449:         # didn't find library file in virtualenv, try base distribution, too,
  450:         # and use that instead if found there. for Python 2.7 venvs, the base
  451:         # directory is in attribute real_prefix instead of base_prefix.
  452:         if hasattr(sys, 'base_prefix'):
  453:             base_lib = os.path.join(sys.base_prefix, 'libs', lib_name)
  454:         elif hasattr(sys, 'real_prefix'):
  455:             base_lib = os.path.join(sys.real_prefix, 'libs', lib_name)
  456:         else:
  457:             base_lib = ''  # os.path.isfile('') == False
  458: 
  459:         if os.path.isfile(base_lib):
  460:             lib_file = base_lib
  461:         else:
  462:             log.warn('Cannot build import library: "%s" not found', lib_file)
  463:             return
  464:     log.info('Building import library (ARCH=x86): "%s"', out_file)
  465: 
  466:     from numpy.distutils import lib2def
  467: 
  468:     def_name = "python%d%d.def" % tuple(sys.version_info[:2])
  469:     def_file = os.path.join(sys.prefix, 'libs', def_name)
  470:     nm_output = lib2def.getnm(
  471:             lib2def.DEFAULT_NM + [lib_file], shell=False)
  472:     dlist, flist = lib2def.parse_nm(nm_output)
  473:     with open(def_file, 'w') as fid:
  474:         lib2def.output_def(dlist, flist, lib2def.DEF_HEADER, fid)
  475: 
  476:     dll_name = find_python_dll ()
  477: 
  478:     cmd = ["dlltool",
  479:            "--dllname", dll_name,
  480:            "--def", def_file,
  481:            "--output-lib", out_file]
  482:     status = subprocess.check_output(cmd)
  483:     if status:
  484:         log.warn('Failed to build import library for gcc. Linking will fail.')
  485:     return
  486: 
  487: #=====================================
  488: # Dealing with Visual Studio MANIFESTS
  489: #=====================================
  490: 
  491: # Functions to deal with visual studio manifests. Manifest are a mechanism to
  492: # enforce strong DLL versioning on windows, and has nothing to do with
  493: # distutils MANIFEST. manifests are XML files with version info, and used by
  494: # the OS loader; they are necessary when linking against a DLL not in the
  495: # system path; in particular, official python 2.6 binary is built against the
  496: # MS runtime 9 (the one from VS 2008), which is not available on most windows
  497: # systems; python 2.6 installer does install it in the Win SxS (Side by side)
  498: # directory, but this requires the manifest for this to work. This is a big
  499: # mess, thanks MS for a wonderful system.
  500: 
  501: # XXX: ideally, we should use exactly the same version as used by python. I
  502: # submitted a patch to get this version, but it was only included for python
  503: # 2.6.1 and above. So for versions below, we use a "best guess".
  504: _MSVCRVER_TO_FULLVER = {}
  505: if sys.platform == 'win32':
  506:     try:
  507:         import msvcrt
  508:         # I took one version in my SxS directory: no idea if it is the good
  509:         # one, and we can't retrieve it from python
  510:         _MSVCRVER_TO_FULLVER['80'] = "8.0.50727.42"
  511:         _MSVCRVER_TO_FULLVER['90'] = "9.0.21022.8"
  512:         # Value from msvcrt.CRT_ASSEMBLY_VERSION under Python 3.3.0
  513:         # on Windows XP:
  514:         _MSVCRVER_TO_FULLVER['100'] = "10.0.30319.460"
  515:         crt_ver = getattr(msvcrt, 'CRT_ASSEMBLY_VERSION', None)
  516:         if crt_ver is not None:  # Available at least back to Python 3.3
  517:             maj, min = re.match(r'(\d+)\.(\d)', crt_ver).groups()
  518:             _MSVCRVER_TO_FULLVER[maj + min] = crt_ver
  519:             del maj, min
  520:         del crt_ver
  521:     except ImportError:
  522:         # If we are here, means python was not built with MSVC. Not sure what
  523:         # to do in that case: manifest building will fail, but it should not be
  524:         # used in that case anyway
  525:         log.warn('Cannot import msvcrt: using manifest will not be possible')
  526: 
  527: def msvc_manifest_xml(maj, min):
  528:     """Given a major and minor version of the MSVCR, returns the
  529:     corresponding XML file."""
  530:     try:
  531:         fullver = _MSVCRVER_TO_FULLVER[str(maj * 10 + min)]
  532:     except KeyError:
  533:         raise ValueError("Version %d,%d of MSVCRT not supported yet" %
  534:                          (maj, min)) from None
  535:     # Don't be fooled, it looks like an XML, but it is not. In particular, it
  536:     # should not have any space before starting, and its size should be
  537:     # divisible by 4, most likely for alignment constraints when the xml is
  538:     # embedded in the binary...
  539:     # This template was copied directly from the python 2.6 binary (using
  540:     # strings.exe from mingw on python.exe).
  541:     template = textwrap.dedent("""\
  542:         <assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  543:           <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
  544:             <security>
  545:               <requestedPrivileges>
  546:                 <requestedExecutionLevel level="asInvoker" uiAccess="false"></requestedExecutionLevel>
  547:               </requestedPrivileges>
  548:             </security>
  549:           </trustInfo>
  550:           <dependency>
  551:             <dependentAssembly>
  552:               <assemblyIdentity type="win32" name="Microsoft.VC%(maj)d%(min)d.CRT" version="%(fullver)s" processorArchitecture="*" publicKeyToken="1fc8b3b9a1e18e3b"></assemblyIdentity>
  553:             </dependentAssembly>
  554:           </dependency>
  555:         </assembly>""")
  556: 
  557:     return template % {'fullver': fullver, 'maj': maj, 'min': min}
  558: 
  559: def manifest_rc(name, type='dll'):
  560:     """Return the rc file used to generate the res file which will be embedded
  561:     as manifest for given manifest file name, of given type ('dll' or
  562:     'exe').
  563: 
  564:     Parameters
  565:     ----------
  566:     name : str
  567:             name of the manifest file to embed
  568:     type : str {'dll', 'exe'}
  569:             type of the binary which will embed the manifest
  570: 
  571:     """
  572:     if type == 'dll':
  573:         rctype = 2
  574:     elif type == 'exe':
  575:         rctype = 1
  576:     else:
  577:         raise ValueError("Type %s not supported" % type)
  578: 
  579:     return """\
  580: #include "winuser.h"
  581: %d RT_MANIFEST %s""" % (rctype, name)
  582: 
  583: def check_embedded_msvcr_match_linked(msver):
  584:     """msver is the ms runtime version used for the MANIFEST."""
  585:     # check msvcr major version are the same for linking and
  586:     # embedding
  587:     maj = msvc_runtime_major()
  588:     if maj:
  589:         if not maj == int(msver):
  590:             raise ValueError(
  591:                   "Discrepancy between linked msvcr " \
  592:                   "(%d) and the one about to be embedded " \
  593:                   "(%d)" % (int(msver), maj))
  594: 
  595: def configtest_name(config):
  596:     base = os.path.basename(config._gen_temp_sourcefile("yo", [], "c"))
  597:     return os.path.splitext(base)[0]
  598: 
  599: def manifest_name(config):
  600:     # Get configest name (including suffix)
  601:     root = configtest_name(config)
  602:     exext = config.compiler.exe_extension
  603:     return root + exext + ".manifest"
  604: 
  605: def rc_name(config):
  606:     # Get configtest name (including suffix)
  607:     root = configtest_name(config)
  608:     return root + ".rc"
  609: 
  610: def generate_manifest(config):
  611:     msver = get_build_msvc_version()
  612:     if msver is not None:
  613:         if msver >= 8:
  614:             check_embedded_msvcr_match_linked(msver)
  615:             ma_str, mi_str = str(msver).split('.')
  616:             # Write the manifest file
  617:             manxml = msvc_manifest_xml(int(ma_str), int(mi_str))
  618:             with open(manifest_name(config), "w") as man:
  619:                 config.temp_files.append(manifest_name(config))
  620:                 man.write(manxml)
