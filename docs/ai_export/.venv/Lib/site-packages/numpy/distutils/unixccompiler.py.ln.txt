    1: """
    2: unixccompiler - can handle very long argument lists for ar.
    3: 
    4: """
    5: import os
    6: import sys
    7: import subprocess
    8: import shlex
    9: 
   10: from distutils.errors import CompileError, DistutilsExecError, LibError
   11: from distutils.unixccompiler import UnixCCompiler
   12: from numpy.distutils.ccompiler import replace_method
   13: from numpy.distutils.misc_util import _commandline_dep_string
   14: from numpy.distutils import log
   15: 
   16: # Note that UnixCCompiler._compile appeared in Python 2.3
   17: def UnixCCompiler__compile(self, obj, src, ext, cc_args, extra_postargs, pp_opts):
   18:     """Compile a single source files with a Unix-style compiler."""
   19:     # HP ad-hoc fix, see ticket 1383
   20:     ccomp = self.compiler_so
   21:     if ccomp[0] == 'aCC':
   22:         # remove flags that will trigger ANSI-C mode for aCC
   23:         if '-Ae' in ccomp:
   24:             ccomp.remove('-Ae')
   25:         if '-Aa' in ccomp:
   26:             ccomp.remove('-Aa')
   27:         # add flags for (almost) sane C++ handling
   28:         ccomp += ['-AA']
   29:         self.compiler_so = ccomp
   30:     # ensure OPT environment variable is read
   31:     if 'OPT' in os.environ:
   32:         # XXX who uses this?
   33:         from sysconfig import get_config_vars
   34:         opt = shlex.join(shlex.split(os.environ['OPT']))
   35:         gcv_opt = shlex.join(shlex.split(get_config_vars('OPT')[0]))
   36:         ccomp_s = shlex.join(self.compiler_so)
   37:         if opt not in ccomp_s:
   38:             ccomp_s = ccomp_s.replace(gcv_opt, opt)
   39:             self.compiler_so = shlex.split(ccomp_s)
   40:         llink_s = shlex.join(self.linker_so)
   41:         if opt not in llink_s:
   42:             self.linker_so = self.linker_so + shlex.split(opt)
   43: 
   44:     display = '%s: %s' % (os.path.basename(self.compiler_so[0]), src)
   45: 
   46:     # gcc style automatic dependencies, outputs a makefile (-MF) that lists
   47:     # all headers needed by a c file as a side effect of compilation (-MMD)
   48:     if getattr(self, '_auto_depends', False):
   49:         deps = ['-MMD', '-MF', obj + '.d']
   50:     else:
   51:         deps = []
   52: 
   53:     try:
   54:         self.spawn(self.compiler_so + cc_args + [src, '-o', obj] + deps +
   55:                    extra_postargs, display = display)
   56:     except DistutilsExecError as e:
   57:         msg = str(e)
   58:         raise CompileError(msg) from None
   59: 
   60:     # add commandline flags to dependency file
   61:     if deps:
   62:         # After running the compiler, the file created will be in EBCDIC
   63:         # but will not be tagged as such. This tags it so the file does not
   64:         # have multiple different encodings being written to it
   65:         if sys.platform == 'zos':
   66:             subprocess.check_output(['chtag', '-tc', 'IBM1047', obj + '.d'])
   67:         with open(obj + '.d', 'a') as f:
   68:             f.write(_commandline_dep_string(cc_args, extra_postargs, pp_opts))
   69: 
   70: replace_method(UnixCCompiler, '_compile', UnixCCompiler__compile)
   71: 
   72: 
   73: def UnixCCompiler_create_static_lib(self, objects, output_libname,
   74:                                     output_dir=None, debug=0, target_lang=None):
   75:     """
   76:     Build a static library in a separate sub-process.
   77: 
   78:     Parameters
   79:     ----------
   80:     objects : list or tuple of str
   81:         List of paths to object files used to build the static library.
   82:     output_libname : str
   83:         The library name as an absolute or relative (if `output_dir` is used)
   84:         path.
   85:     output_dir : str, optional
   86:         The path to the output directory. Default is None, in which case
   87:         the ``output_dir`` attribute of the UnixCCompiler instance.
   88:     debug : bool, optional
   89:         This parameter is not used.
   90:     target_lang : str, optional
   91:         This parameter is not used.
   92: 
   93:     Returns
   94:     -------
   95:     None
   96: 
   97:     """
   98:     objects, output_dir = self._fix_object_args(objects, output_dir)
   99: 
  100:     output_filename = \
  101:                     self.library_filename(output_libname, output_dir=output_dir)
  102: 
  103:     if self._need_link(objects, output_filename):
  104:         try:
  105:             # previous .a may be screwed up; best to remove it first
  106:             # and recreate.
  107:             # Also, ar on OS X doesn't handle updating universal archives
  108:             os.unlink(output_filename)
  109:         except OSError:
  110:             pass
  111:         self.mkpath(os.path.dirname(output_filename))
  112:         tmp_objects = objects + self.objects
  113:         while tmp_objects:
  114:             objects = tmp_objects[:50]
  115:             tmp_objects = tmp_objects[50:]
  116:             display = '%s: adding %d object files to %s' % (
  117:                            os.path.basename(self.archiver[0]),
  118:                            len(objects), output_filename)
  119:             self.spawn(self.archiver + [output_filename] + objects,
  120:                        display = display)
  121: 
  122:         # Not many Unices required ranlib anymore -- SunOS 4.x is, I
  123:         # think the only major Unix that does.  Maybe we need some
  124:         # platform intelligence here to skip ranlib if it's not
  125:         # needed -- or maybe Python's configure script took care of
  126:         # it for us, hence the check for leading colon.
  127:         if self.ranlib:
  128:             display = '%s:@ %s' % (os.path.basename(self.ranlib[0]),
  129:                                    output_filename)
  130:             try:
  131:                 self.spawn(self.ranlib + [output_filename],
  132:                            display = display)
  133:             except DistutilsExecError as e:
  134:                 msg = str(e)
  135:                 raise LibError(msg) from None
  136:     else:
  137:         log.debug("skipping %s (up-to-date)", output_filename)
  138:     return
  139: 
  140: replace_method(UnixCCompiler, 'create_static_lib',
  141:                UnixCCompiler_create_static_lib)
