    1: import re, textwrap, os
    2: from os import sys, path
    3: from distutils.errors import DistutilsError
    4: 
    5: is_standalone = __name__ == '__main__' and __package__ is None
    6: if is_standalone:
    7:     import unittest, contextlib, tempfile, shutil
    8:     sys.path.append(path.abspath(path.join(path.dirname(__file__), "..")))
    9:     from ccompiler_opt import CCompilerOpt
   10: 
   11:     # from numpy/testing/_private/utils.py
   12:     @contextlib.contextmanager
   13:     def tempdir(*args, **kwargs):
   14:         tmpdir = tempfile.mkdtemp(*args, **kwargs)
   15:         try:
   16:             yield tmpdir
   17:         finally:
   18:             shutil.rmtree(tmpdir)
   19: 
   20:     def assert_(expr, msg=''):
   21:         if not expr:
   22:             raise AssertionError(msg)
   23: else:
   24:     from numpy.distutils.ccompiler_opt import CCompilerOpt
   25:     from numpy.testing import assert_, tempdir
   26: 
   27: # architectures and compilers to test
   28: arch_compilers = dict(
   29:     x86 = ("gcc", "clang", "icc", "iccw", "msvc"),
   30:     x64 = ("gcc", "clang", "icc", "iccw", "msvc"),
   31:     ppc64 = ("gcc", "clang"),
   32:     ppc64le = ("gcc", "clang"),
   33:     armhf = ("gcc", "clang"),
   34:     aarch64 = ("gcc", "clang", "fcc"),
   35:     s390x = ("gcc", "clang"),
   36:     noarch = ("gcc",)
   37: )
   38: 
   39: class FakeCCompilerOpt(CCompilerOpt):
   40:     fake_info = ""
   41:     def __init__(self, trap_files="", trap_flags="", *args, **kwargs):
   42:         self.fake_trap_files = trap_files
   43:         self.fake_trap_flags = trap_flags
   44:         CCompilerOpt.__init__(self, None, **kwargs)
   45: 
   46:     def __repr__(self):
   47:         return textwrap.dedent("""\
   48:             <<<<
   49:             march    : {}
   50:             compiler : {}
   51:             ----------------
   52:             {}
   53:             >>>>
   54:         """).format(self.cc_march, self.cc_name, self.report())
   55: 
   56:     def dist_compile(self, sources, flags, **kwargs):
   57:         assert(isinstance(sources, list))
   58:         assert(isinstance(flags, list))
   59:         if self.fake_trap_files:
   60:             for src in sources:
   61:                 if re.match(self.fake_trap_files, src):
   62:                     self.dist_error("source is trapped by a fake interface")
   63:         if self.fake_trap_flags:
   64:             for f in flags:
   65:                 if re.match(self.fake_trap_flags, f):
   66:                     self.dist_error("flag is trapped by a fake interface")
   67:         # fake objects
   68:         return zip(sources, [' '.join(flags)] * len(sources))
   69: 
   70:     def dist_info(self):
   71:         return FakeCCompilerOpt.fake_info
   72: 
   73:     @staticmethod
   74:     def dist_log(*args, stderr=False):
   75:         pass
   76: 
   77: class _Test_CCompilerOpt:
   78:     arch = None # x86_64
   79:     cc   = None # gcc
   80: 
   81:     def setup_class(self):
   82:         FakeCCompilerOpt.conf_nocache = True
   83:         self._opt = None
   84: 
   85:     def nopt(self, *args, **kwargs):
   86:         FakeCCompilerOpt.fake_info = (self.arch, self.cc, "")
   87:         return FakeCCompilerOpt(*args, **kwargs)
   88: 
   89:     def opt(self):
   90:         if not self._opt:
   91:             self._opt = self.nopt()
   92:         return self._opt
   93: 
   94:     def march(self):
   95:         return self.opt().cc_march
   96: 
   97:     def cc_name(self):
   98:         return self.opt().cc_name
   99: 
  100:     def get_targets(self, targets, groups, **kwargs):
  101:         FakeCCompilerOpt.conf_target_groups = groups
  102:         opt = self.nopt(
  103:             cpu_baseline=kwargs.get("baseline", "min"),
  104:             cpu_dispatch=kwargs.get("dispatch", "max"),
  105:             trap_files=kwargs.get("trap_files", ""),
  106:             trap_flags=kwargs.get("trap_flags", "")
  107:         )
  108:         with tempdir() as tmpdir:
  109:             file = os.path.join(tmpdir, "test_targets.c")
  110:             with open(file, 'w') as f:
  111:                 f.write(targets)
  112:             gtargets = []
  113:             gflags = {}
  114:             fake_objects = opt.try_dispatch([file])
  115:             for source, flags in fake_objects:
  116:                 gtar = path.basename(source).split('.')[1:-1]
  117:                 glen = len(gtar)
  118:                 if glen == 0:
  119:                     gtar = "baseline"
  120:                 elif glen == 1:
  121:                     gtar = gtar[0].upper()
  122:                 else:
  123:                     # converting multi-target into parentheses str format to be equivalent
  124:                     # to the configuration statements syntax.
  125:                     gtar = ('('+' '.join(gtar)+')').upper()
  126:                 gtargets.append(gtar)
  127:                 gflags[gtar] = flags
  128: 
  129:         has_baseline, targets = opt.sources_status[file]
  130:         targets = targets + ["baseline"] if has_baseline else targets
  131:         # convert tuple that represent multi-target into parentheses str format
  132:         targets = [
  133:             '('+' '.join(tar)+')' if isinstance(tar, tuple) else tar
  134:             for tar in targets
  135:         ]
  136:         if len(targets) != len(gtargets) or not all(t in gtargets for t in targets):
  137:             raise AssertionError(
  138:                 "'sources_status' returns different targets than the compiled targets\n"
  139:                 "%s != %s" % (targets, gtargets)
  140:             )
  141:         # return targets from 'sources_status' since the order is matters
  142:         return targets, gflags
  143: 
  144:     def arg_regex(self, **kwargs):
  145:         map2origin = dict(
  146:             x64 = "x86",
  147:             ppc64le = "ppc64",
  148:             aarch64 = "armhf",
  149:             clang = "gcc",
  150:         )
  151:         march = self.march(); cc_name = self.cc_name()
  152:         map_march = map2origin.get(march, march)
  153:         map_cc = map2origin.get(cc_name, cc_name)
  154:         for key in (
  155:             march, cc_name, map_march, map_cc,
  156:             march + '_' + cc_name,
  157:             map_march + '_' + cc_name,
  158:             march + '_' + map_cc,
  159:             map_march + '_' + map_cc,
  160:         ) :
  161:             regex = kwargs.pop(key, None)
  162:             if regex is not None:
  163:                 break
  164:         if regex:
  165:             if isinstance(regex, dict):
  166:                 for k, v in regex.items():
  167:                     if v[-1:] not in ')}$?\\.+*':
  168:                         regex[k] = v + '$'
  169:             else:
  170:                 assert(isinstance(regex, str))
  171:                 if regex[-1:] not in ')}$?\\.+*':
  172:                     regex += '$'
  173:         return regex
  174: 
  175:     def expect(self, dispatch, baseline="", **kwargs):
  176:         match = self.arg_regex(**kwargs)
  177:         if match is None:
  178:             return
  179:         opt = self.nopt(
  180:             cpu_baseline=baseline, cpu_dispatch=dispatch,
  181:             trap_files=kwargs.get("trap_files", ""),
  182:             trap_flags=kwargs.get("trap_flags", "")
  183:         )
  184:         features = ' '.join(opt.cpu_dispatch_names())
  185:         if not match:
  186:             if len(features) != 0:
  187:                 raise AssertionError(
  188:                     'expected empty features, not "%s"' % features
  189:                 )
  190:             return
  191:         if not re.match(match, features, re.IGNORECASE):
  192:             raise AssertionError(
  193:                 'dispatch features "%s" not match "%s"' % (features, match)
  194:             )
  195: 
  196:     def expect_baseline(self, baseline, dispatch="", **kwargs):
  197:         match = self.arg_regex(**kwargs)
  198:         if match is None:
  199:             return
  200:         opt = self.nopt(
  201:             cpu_baseline=baseline, cpu_dispatch=dispatch,
  202:             trap_files=kwargs.get("trap_files", ""),
  203:             trap_flags=kwargs.get("trap_flags", "")
  204:         )
  205:         features = ' '.join(opt.cpu_baseline_names())
  206:         if not match:
  207:             if len(features) != 0:
  208:                 raise AssertionError(
  209:                     'expected empty features, not "%s"' % features
  210:                 )
  211:             return
  212:         if not re.match(match, features, re.IGNORECASE):
  213:             raise AssertionError(
  214:                 'baseline features "%s" not match "%s"' % (features, match)
  215:             )
  216: 
  217:     def expect_flags(self, baseline, dispatch="", **kwargs):
  218:         match = self.arg_regex(**kwargs)
  219:         if match is None:
  220:             return
  221:         opt = self.nopt(
  222:             cpu_baseline=baseline, cpu_dispatch=dispatch,
  223:             trap_files=kwargs.get("trap_files", ""),
  224:             trap_flags=kwargs.get("trap_flags", "")
  225:         )
  226:         flags = ' '.join(opt.cpu_baseline_flags())
  227:         if not match:
  228:             if len(flags) != 0:
  229:                 raise AssertionError(
  230:                     'expected empty flags not "%s"' % flags
  231:                 )
  232:             return
  233:         if not re.match(match, flags):
  234:             raise AssertionError(
  235:                 'flags "%s" not match "%s"' % (flags, match)
  236:             )
  237: 
  238:     def expect_targets(self, targets, groups={}, **kwargs):
  239:         match = self.arg_regex(**kwargs)
  240:         if match is None:
  241:             return
  242:         targets, _ = self.get_targets(targets=targets, groups=groups, **kwargs)
  243:         targets = ' '.join(targets)
  244:         if not match:
  245:             if len(targets) != 0:
  246:                 raise AssertionError(
  247:                     'expected empty targets, not "%s"' % targets
  248:                 )
  249:             return
  250:         if not re.match(match, targets, re.IGNORECASE):
  251:             raise AssertionError(
  252:                 'targets "%s" not match "%s"' % (targets, match)
  253:             )
  254: 
  255:     def expect_target_flags(self, targets, groups={}, **kwargs):
  256:         match_dict = self.arg_regex(**kwargs)
  257:         if match_dict is None:
  258:             return
  259:         assert(isinstance(match_dict, dict))
  260:         _, tar_flags = self.get_targets(targets=targets, groups=groups)
  261: 
  262:         for match_tar, match_flags in match_dict.items():
  263:             if match_tar not in tar_flags:
  264:                 raise AssertionError(
  265:                     'expected to find target "%s"' % match_tar
  266:                 )
  267:             flags = tar_flags[match_tar]
  268:             if not match_flags:
  269:                 if len(flags) != 0:
  270:                     raise AssertionError(
  271:                         'expected to find empty flags in target "%s"' % match_tar
  272:                     )
  273:             if not re.match(match_flags, flags):
  274:                 raise AssertionError(
  275:                     '"%s" flags "%s" not match "%s"' % (match_tar, flags, match_flags)
  276:                 )
  277: 
  278:     def test_interface(self):
  279:         wrong_arch = "ppc64" if self.arch != "ppc64" else "x86"
  280:         wrong_cc   = "clang" if self.cc   != "clang" else "icc"
  281:         opt = self.opt()
  282:         assert_(getattr(opt, "cc_on_" + self.arch))
  283:         assert_(not getattr(opt, "cc_on_" + wrong_arch))
  284:         assert_(getattr(opt, "cc_is_" + self.cc))
  285:         assert_(not getattr(opt, "cc_is_" + wrong_cc))
  286: 
  287:     def test_args_empty(self):
  288:         for baseline, dispatch in (
  289:             ("", "none"),
  290:             (None, ""),
  291:             ("none +none", "none - none"),
  292:             ("none -max", "min - max"),
  293:             ("+vsx2 -VSX2", "vsx avx2 avx512f -max"),
  294:             ("max -vsx - avx + avx512f neon -MAX ",
  295:              "min -min + max -max -vsx + avx2 -avx2 +NONE")
  296:         ) :
  297:             opt = self.nopt(cpu_baseline=baseline, cpu_dispatch=dispatch)
  298:             assert(len(opt.cpu_baseline_names()) == 0)
  299:             assert(len(opt.cpu_dispatch_names()) == 0)
  300: 
  301:     def test_args_validation(self):
  302:         if self.march() == "unknown":
  303:             return
  304:         # check sanity of argument's validation
  305:         for baseline, dispatch in (
  306:             ("unkown_feature - max +min", "unknown max min"), # unknowing features
  307:             ("#avx2", "$vsx") # groups and polices aren't acceptable
  308:         ) :
  309:             try:
  310:                 self.nopt(cpu_baseline=baseline, cpu_dispatch=dispatch)
  311:                 raise AssertionError("excepted an exception for invalid arguments")
  312:             except DistutilsError:
  313:                 pass
  314: 
  315:     def test_skip(self):
  316:         # only takes what platform supports and skip the others
  317:         # without casing exceptions
  318:         self.expect(
  319:             "sse vsx neon",
  320:             x86="sse", ppc64="vsx", armhf="neon", unknown=""
  321:         )
  322:         self.expect(
  323:             "sse41 avx avx2 vsx2 vsx3 neon_vfpv4 asimd",
  324:             x86   = "sse41 avx avx2",
  325:             ppc64 = "vsx2 vsx3",
  326:             armhf = "neon_vfpv4 asimd",
  327:             unknown = ""
  328:         )
  329:         # any features in cpu_dispatch must be ignored if it's part of baseline
  330:         self.expect(
  331:             "sse neon vsx", baseline="sse neon vsx",
  332:             x86="", ppc64="", armhf=""
  333:         )
  334:         self.expect(
  335:             "avx2 vsx3 asimdhp", baseline="avx2 vsx3 asimdhp",
  336:             x86="", ppc64="", armhf=""
  337:         )
  338: 
  339:     def test_implies(self):
  340:         # baseline combining implied features, so we count
  341:         # on it instead of testing 'feature_implies()'' directly
  342:         self.expect_baseline(
  343:             "fma3 avx2 asimd vsx3",
  344:             # .* between two spaces can validate features in between
  345:             x86   = "sse .* sse41 .* fma3.*avx2",
  346:             ppc64 = "vsx vsx2 vsx3",
  347:             armhf = "neon neon_fp16 neon_vfpv4 asimd"
  348:         )
  349:         """
  350:         special cases
  351:         """
  352:         # in icc and msvc, FMA3 and AVX2 can't be separated
  353:         # both need to implies each other, same for avx512f & cd
  354:         for f0, f1 in (
  355:             ("fma3",    "avx2"),
  356:             ("avx512f", "avx512cd"),
  357:         ):
  358:             diff = ".* sse42 .* %s .*%s$" % (f0, f1)
  359:             self.expect_baseline(f0,
  360:                 x86_gcc=".* sse42 .* %s$" % f0,
  361:                 x86_icc=diff, x86_iccw=diff
  362:             )
  363:             self.expect_baseline(f1,
  364:                 x86_gcc=".* avx .* %s$" % f1,
  365:                 x86_icc=diff, x86_iccw=diff
  366:             )
  367:         # in msvc, following features can't be separated too
  368:         for f in (("fma3", "avx2"), ("avx512f", "avx512cd", "avx512_skx")):
  369:             for ff in f:
  370:                 self.expect_baseline(ff,
  371:                     x86_msvc=".*%s" % ' '.join(f)
  372:                 )
  373: 
  374:         # in ppc64le VSX and VSX2 can't be separated
  375:         self.expect_baseline("vsx", ppc64le="vsx vsx2")
  376:         # in aarch64 following features can't be separated
  377:         for f in ("neon", "neon_fp16", "neon_vfpv4", "asimd"):
  378:             self.expect_baseline(f, aarch64="neon neon_fp16 neon_vfpv4 asimd")
  379: 
  380:     def test_args_options(self):
  381:         # max & native
  382:         for o in ("max", "native"):
  383:             if o == "native" and self.cc_name() == "msvc":
  384:                 continue
  385:             self.expect(o,
  386:                 trap_files=".*cpu_(sse|vsx|neon|vx).c",
  387:                 x86="", ppc64="", armhf="", s390x=""
  388:             )
  389:             self.expect(o,
  390:                 trap_files=".*cpu_(sse3|vsx2|neon_vfpv4|vxe).c",
  391:                 x86="sse sse2", ppc64="vsx", armhf="neon neon_fp16",
  392:                 aarch64="", ppc64le="", s390x="vx"
  393:             )
  394:             self.expect(o,
  395:                 trap_files=".*cpu_(popcnt|vsx3).c",
  396:                 x86="sse .* sse41", ppc64="vsx vsx2",
  397:                 armhf="neon neon_fp16 .* asimd .*",
  398:                 s390x="vx vxe vxe2"
  399:             )
  400:             self.expect(o,
  401:                 x86_gcc=".* xop fma4 .* avx512f .* avx512_knl avx512_knm avx512_skx .*",
  402:                 # in icc, xop and fam4 aren't supported
  403:                 x86_icc=".* avx512f .* avx512_knl avx512_knm avx512_skx .*",
  404:                 x86_iccw=".* avx512f .* avx512_knl avx512_knm avx512_skx .*",
  405:                 # in msvc, avx512_knl avx512_knm aren't supported
  406:                 x86_msvc=".* xop fma4 .* avx512f .* avx512_skx .*",
  407:                 armhf=".* asimd asimdhp asimddp .*",
  408:                 ppc64="vsx vsx2 vsx3 vsx4.*",
  409:                 s390x="vx vxe vxe2.*"
  410:             )
  411:         # min
  412:         self.expect("min",
  413:             x86="sse sse2", x64="sse sse2 sse3",
  414:             armhf="", aarch64="neon neon_fp16 .* asimd",
  415:             ppc64="", ppc64le="vsx vsx2", s390x=""
  416:         )
  417:         self.expect(
  418:             "min", trap_files=".*cpu_(sse2|vsx2).c",
  419:             x86="", ppc64le=""
  420:         )
  421:         # an exception must triggered if native flag isn't supported
  422:         # when option "native" is activated through the args
  423:         try:
  424:             self.expect("native",
  425:                 trap_flags=".*(-march=native|-xHost|/QxHost|-mcpu=a64fx).*",
  426:                 x86=".*", ppc64=".*", armhf=".*", s390x=".*", aarch64=".*",
  427:             )
  428:             if self.march() != "unknown":
  429:                 raise AssertionError(
  430:                     "excepted an exception for %s" % self.march()
  431:                 )
  432:         except DistutilsError:
  433:             if self.march() == "unknown":
  434:                 raise AssertionError("excepted no exceptions")
  435: 
  436:     def test_flags(self):
  437:         self.expect_flags(
  438:             "sse sse2 vsx vsx2 neon neon_fp16 vx vxe",
  439:             x86_gcc="-msse -msse2", x86_icc="-msse -msse2",
  440:             x86_iccw="/arch:SSE2",
  441:             x86_msvc="/arch:SSE2" if self.march() == "x86" else "",
  442:             ppc64_gcc= "-mcpu=power8",
  443:             ppc64_clang="-mcpu=power8",
  444:             armhf_gcc="-mfpu=neon-fp16 -mfp16-format=ieee",
  445:             aarch64="",
  446:             s390x="-mzvector -march=arch12"
  447:         )
  448:         # testing normalize -march
  449:         self.expect_flags(
  450:             "asimd",
  451:             aarch64="",
  452:             armhf_gcc=r"-mfp16-format=ieee -mfpu=neon-fp-armv8 -march=armv8-a\+simd"
  453:         )
  454:         self.expect_flags(
  455:             "asimdhp",
  456:             aarch64_gcc=r"-march=armv8.2-a\+fp16",
  457:             armhf_gcc=r"-mfp16-format=ieee -mfpu=neon-fp-armv8 -march=armv8.2-a\+fp16"
  458:         )
  459:         self.expect_flags(
  460:             "asimddp", aarch64_gcc=r"-march=armv8.2-a\+dotprod"
  461:         )
  462:         self.expect_flags(
  463:             # asimdfhm implies asimdhp
  464:             "asimdfhm", aarch64_gcc=r"-march=armv8.2-a\+fp16\+fp16fml"
  465:         )
  466:         self.expect_flags(
  467:             "asimddp asimdhp asimdfhm",
  468:             aarch64_gcc=r"-march=armv8.2-a\+dotprod\+fp16\+fp16fml"
  469:         )
  470:         self.expect_flags(
  471:             "vx vxe vxe2",
  472:             s390x=r"-mzvector -march=arch13"
  473:         )
  474: 
  475:     def test_targets_exceptions(self):
  476:         for targets in (
  477:             "bla bla", "/*@targets",
  478:             "/*@targets */",
  479:             "/*@targets unknown */",
  480:             "/*@targets $unknown_policy avx2 */",
  481:             "/*@targets #unknown_group avx2 */",
  482:             "/*@targets $ */",
  483:             "/*@targets # vsx */",
  484:             "/*@targets #$ vsx */",
  485:             "/*@targets vsx avx2 ) */",
  486:             "/*@targets vsx avx2 (avx2 */",
  487:             "/*@targets vsx avx2 () */",
  488:             "/*@targets vsx avx2 ($autovec) */", # no features
  489:             "/*@targets vsx avx2 (xxx) */",
  490:             "/*@targets vsx avx2 (baseline) */",
  491:         ) :
  492:             try:
  493:                 self.expect_targets(
  494:                     targets,
  495:                     x86="", armhf="", ppc64="", s390x=""
  496:                 )
  497:                 if self.march() != "unknown":
  498:                     raise AssertionError(
  499:                         "excepted an exception for %s" % self.march()
  500:                     )
  501:             except DistutilsError:
  502:                 if self.march() == "unknown":
  503:                     raise AssertionError("excepted no exceptions")
  504: 
  505:     def test_targets_syntax(self):
  506:         for targets in (
  507:             "/*@targets $keep_baseline sse vsx neon vx*/",
  508:             "/*@targets,$keep_baseline,sse,vsx,neon vx*/",
  509:             "/*@targets*$keep_baseline*sse*vsx*neon*vx*/",
  510:             """
  511:             /*
  512:             ** @targets
  513:             ** $keep_baseline, sse vsx,neon, vx
  514:             */
  515:             """,
  516:             """
  517:             /*
  518:             ************@targets****************
  519:             ** $keep_baseline, sse vsx, neon, vx
  520:             ************************************
  521:             */
  522:             """,
  523:             """
  524:             /*
  525:             /////////////@targets/////////////////
  526:             //$keep_baseline//sse//vsx//neon//vx
  527:             /////////////////////////////////////
  528:             */
  529:             """,
  530:             """
  531:             /*
  532:             @targets
  533:             $keep_baseline
  534:             SSE VSX NEON VX*/
  535:             """
  536:         ) :
  537:             self.expect_targets(targets,
  538:                 x86="sse", ppc64="vsx", armhf="neon", s390x="vx", unknown=""
  539:             )
  540: 
  541:     def test_targets(self):
  542:         # test skipping baseline features
  543:         self.expect_targets(
  544:             """
  545:             /*@targets
  546:                 sse sse2 sse41 avx avx2 avx512f
  547:                 vsx vsx2 vsx3 vsx4
  548:                 neon neon_fp16 asimdhp asimddp
  549:                 vx vxe vxe2
  550:             */
  551:             """,
  552:             baseline="avx vsx2 asimd vx vxe",
  553:             x86="avx512f avx2", armhf="asimddp asimdhp", ppc64="vsx4 vsx3",
  554:             s390x="vxe2"
  555:         )
  556:         # test skipping non-dispatch features
  557:         self.expect_targets(
  558:             """
  559:             /*@targets
  560:                 sse41 avx avx2 avx512f
  561:                 vsx2 vsx3 vsx4
  562:                 asimd asimdhp asimddp
  563:                 vx vxe vxe2
  564:             */
  565:             """,
  566:             baseline="", dispatch="sse41 avx2 vsx2 asimd asimddp vxe2",
  567:             x86="avx2 sse41", armhf="asimddp asimd", ppc64="vsx2", s390x="vxe2"
  568:         )
  569:         # test skipping features that not supported
  570:         self.expect_targets(
  571:             """
  572:             /*@targets
  573:                 sse2 sse41 avx2 avx512f
  574:                 vsx2 vsx3 vsx4
  575:                 neon asimdhp asimddp
  576:                 vx vxe vxe2
  577:             */
  578:             """,
  579:             baseline="",
  580:             trap_files=".*(avx2|avx512f|vsx3|vsx4|asimddp|vxe2).c",
  581:             x86="sse41 sse2", ppc64="vsx2", armhf="asimdhp neon",
  582:             s390x="vxe vx"
  583:         )
  584:         # test skipping features that implies each other
  585:         self.expect_targets(
  586:             """
  587:             /*@targets
  588:                 sse sse2 avx fma3 avx2 avx512f avx512cd
  589:                 vsx vsx2 vsx3
  590:                 neon neon_vfpv4 neon_fp16 neon_fp16 asimd asimdhp
  591:                 asimddp asimdfhm
  592:             */
  593:             """,
  594:             baseline="",
  595:             x86_gcc="avx512cd avx512f avx2 fma3 avx sse2",
  596:             x86_msvc="avx512cd avx2 avx sse2",
  597:             x86_icc="avx512cd avx2 avx sse2",
  598:             x86_iccw="avx512cd avx2 avx sse2",
  599:             ppc64="vsx3 vsx2 vsx",
  600:             ppc64le="vsx3 vsx2",
  601:             armhf="asimdfhm asimddp asimdhp asimd neon_vfpv4 neon_fp16 neon",
  602:             aarch64="asimdfhm asimddp asimdhp asimd"
  603:         )
  604: 
  605:     def test_targets_policies(self):
  606:         # 'keep_baseline', generate objects for baseline features
  607:         self.expect_targets(
  608:             """
  609:             /*@targets
  610:                 $keep_baseline
  611:                 sse2 sse42 avx2 avx512f
  612:                 vsx2 vsx3
  613:                 neon neon_vfpv4 asimd asimddp
  614:                 vx vxe vxe2
  615:             */
  616:             """,
  617:             baseline="sse41 avx2 vsx2 asimd vsx3 vxe",
  618:             x86="avx512f avx2 sse42 sse2",
  619:             ppc64="vsx3 vsx2",
  620:             armhf="asimddp asimd neon_vfpv4 neon",
  621:             # neon, neon_vfpv4, asimd implies each other
  622:             aarch64="asimddp asimd",
  623:             s390x="vxe2 vxe vx"
  624:         )
  625:         # 'keep_sort', leave the sort as-is
  626:         self.expect_targets(
  627:             """
  628:             /*@targets
  629:                 $keep_baseline $keep_sort
  630:                 avx512f sse42 avx2 sse2
  631:                 vsx2 vsx3
  632:                 asimd neon neon_vfpv4 asimddp
  633:                 vxe vxe2
  634:             */
  635:             """,
  636:             x86="avx512f sse42 avx2 sse2",
  637:             ppc64="vsx2 vsx3",
  638:             armhf="asimd neon neon_vfpv4 asimddp",
  639:             # neon, neon_vfpv4, asimd implies each other
  640:             aarch64="asimd asimddp",
  641:             s390x="vxe vxe2"
  642:         )
  643:         # 'autovec', skipping features that can't be
  644:         # vectorized by the compiler
  645:         self.expect_targets(
  646:             """
  647:             /*@targets
  648:                 $keep_baseline $keep_sort $autovec
  649:                 avx512f avx2 sse42 sse41 sse2
  650:                 vsx3 vsx2
  651:                 asimddp asimd neon_vfpv4 neon
  652:             */
  653:             """,
  654:             x86_gcc="avx512f avx2 sse42 sse41 sse2",
  655:             x86_icc="avx512f avx2 sse42 sse41 sse2",
  656:             x86_iccw="avx512f avx2 sse42 sse41 sse2",
  657:             x86_msvc="avx512f avx2 sse2"
  658:                      if self.march() == 'x86' else "avx512f avx2",
  659:             ppc64="vsx3 vsx2",
  660:             armhf="asimddp asimd neon_vfpv4 neon",
  661:             # neon, neon_vfpv4, asimd implies each other
  662:             aarch64="asimddp asimd"
  663:         )
  664:         for policy in ("$maxopt", "$autovec"):
  665:             # 'maxopt' and autovec set the max acceptable optimization flags
  666:             self.expect_target_flags(
  667:                 "/*@targets baseline %s */" % policy,
  668:                 gcc={"baseline":".*-O3.*"}, icc={"baseline":".*-O3.*"},
  669:                 iccw={"baseline":".*/O3.*"}, msvc={"baseline":".*/O2.*"},
  670:                 unknown={"baseline":".*"}
  671:             )
  672: 
  673:         # 'werror', force compilers to treat warnings as errors
  674:         self.expect_target_flags(
  675:             "/*@targets baseline $werror */",
  676:             gcc={"baseline":".*-Werror.*"}, icc={"baseline":".*-Werror.*"},
  677:             iccw={"baseline":".*/Werror.*"}, msvc={"baseline":".*/WX.*"},
  678:             unknown={"baseline":".*"}
  679:         )
  680: 
  681:     def test_targets_groups(self):
  682:         self.expect_targets(
  683:             """
  684:             /*@targets $keep_baseline baseline #test_group */
  685:             """,
  686:             groups=dict(
  687:                 test_group=("""
  688:                     $keep_baseline
  689:                     asimddp sse2 vsx2 avx2 vsx3
  690:                     avx512f asimdhp
  691:                 """)
  692:             ),
  693:             x86="avx512f avx2 sse2 baseline",
  694:             ppc64="vsx3 vsx2 baseline",
  695:             armhf="asimddp asimdhp baseline"
  696:         )
  697:         # test skip duplicating and sorting
  698:         self.expect_targets(
  699:             """
  700:             /*@targets
  701:              * sse42 avx avx512f
  702:              * #test_group_1
  703:              * vsx2
  704:              * #test_group_2
  705:              * asimddp asimdfhm
  706:             */
  707:             """,
  708:             groups=dict(
  709:                 test_group_1=("""
  710:                     VSX2 vsx3 asimd avx2 SSE41
  711:                 """),
  712:                 test_group_2=("""
  713:                     vsx2 vsx3 asImd aVx2 sse41
  714:                 """)
  715:             ),
  716:             x86="avx512f avx2 avx sse42 sse41",
  717:             ppc64="vsx3 vsx2",
  718:             # vsx2 part of the default baseline of ppc64le, option ("min")
  719:             ppc64le="vsx3",
  720:             armhf="asimdfhm asimddp asimd",
  721:             # asimd part of the default baseline of aarch64, option ("min")
  722:             aarch64="asimdfhm asimddp"
  723:         )
  724: 
  725:     def test_targets_multi(self):
  726:         self.expect_targets(
  727:             """
  728:             /*@targets
  729:                 (avx512_clx avx512_cnl) (asimdhp asimddp)
  730:             */
  731:             """,
  732:             x86=r"\(avx512_clx avx512_cnl\)",
  733:             armhf=r"\(asimdhp asimddp\)",
  734:         )
  735:         # test skipping implied features and auto-sort
  736:         self.expect_targets(
  737:             """
  738:             /*@targets
  739:                 f16c (sse41 avx sse42) (sse3 avx2 avx512f)
  740:                 vsx2 (vsx vsx3 vsx2)
  741:                 (neon neon_vfpv4 asimd asimdhp asimddp)
  742:             */
  743:             """,
  744:             x86="avx512f f16c avx",
  745:             ppc64="vsx3 vsx2",
  746:             ppc64le="vsx3", # vsx2 part of baseline
  747:             armhf=r"\(asimdhp asimddp\)",
  748:         )
  749:         # test skipping implied features and keep sort
  750:         self.expect_targets(
  751:             """
  752:             /*@targets $keep_sort
  753:                 (sse41 avx sse42) (sse3 avx2 avx512f)
  754:                 (vsx vsx3 vsx2)
  755:                 (asimddp neon neon_vfpv4 asimd asimdhp)
  756:                 (vx vxe vxe2)
  757:             */
  758:             """,
  759:             x86="avx avx512f",
  760:             ppc64="vsx3",
  761:             armhf=r"\(asimdhp asimddp\)",
  762:             s390x="vxe2"
  763:         )
  764:         # test compiler variety and avoiding duplicating
  765:         self.expect_targets(
  766:             """
  767:             /*@targets $keep_sort
  768:                 fma3 avx2 (fma3 avx2) (avx2 fma3) avx2 fma3
  769:             */
  770:             """,
  771:             x86_gcc=r"fma3 avx2 \(fma3 avx2\)",
  772:             x86_icc="avx2", x86_iccw="avx2",
  773:             x86_msvc="avx2"
  774:         )
  775: 
  776: def new_test(arch, cc):
  777:     if is_standalone: return textwrap.dedent("""\
  778:     class TestCCompilerOpt_{class_name}(_Test_CCompilerOpt, unittest.TestCase):
  779:         arch = '{arch}'
  780:         cc   = '{cc}'
  781:         def __init__(self, methodName="runTest"):
  782:             unittest.TestCase.__init__(self, methodName)
  783:             self.setup_class()
  784:     """).format(
  785:         class_name=arch + '_' + cc, arch=arch, cc=cc
  786:     )
  787:     return textwrap.dedent("""\
  788:     class TestCCompilerOpt_{class_name}(_Test_CCompilerOpt):
  789:         arch = '{arch}'
  790:         cc   = '{cc}'
  791:     """).format(
  792:         class_name=arch + '_' + cc, arch=arch, cc=cc
  793:     )
  794: """
  795: if 1 and is_standalone:
  796:     FakeCCompilerOpt.fake_info = "x86_icc"
  797:     cco = FakeCCompilerOpt(None, cpu_baseline="avx2")
  798:     print(' '.join(cco.cpu_baseline_names()))
  799:     print(cco.cpu_baseline_flags())
  800:     unittest.main()
  801:     sys.exit()
  802: """
  803: for arch, compilers in arch_compilers.items():
  804:     for cc in compilers:
  805:         exec(new_test(arch, cc))
  806: 
  807: if is_standalone:
  808:     unittest.main()
