    1: import os
    2: import shutil
    3: import pytest
    4: from tempfile import mkstemp, mkdtemp
    5: from subprocess import Popen, PIPE
    6: import importlib.metadata
    7: from distutils.errors import DistutilsError
    8: 
    9: from numpy.testing import assert_, assert_equal, assert_raises
   10: from numpy.distutils import ccompiler, customized_ccompiler
   11: from numpy.distutils.system_info import system_info, ConfigParser, mkl_info
   12: from numpy.distutils.system_info import AliasedOptionError
   13: from numpy.distutils.system_info import default_lib_dirs, default_include_dirs
   14: from numpy.distutils import _shell_utils
   15: 
   16: 
   17: try:
   18:     if importlib.metadata.version('setuptools') >= '60':
   19:         # pkg-resources gives deprecation warnings, and there may be more
   20:         # issues. We only support setuptools <60
   21:         pytest.skip("setuptools is too new", allow_module_level=True)
   22: except importlib.metadata.PackageNotFoundError:
   23:     # we don't require `setuptools`; if it is not found, continue
   24:     pass
   25: 
   26: 
   27: def get_class(name, notfound_action=1):
   28:     """
   29:     notfound_action:
   30:       0 - do nothing
   31:       1 - display warning message
   32:       2 - raise error
   33:     """
   34:     cl = {'temp1': Temp1Info,
   35:           'temp2': Temp2Info,
   36:           'duplicate_options': DuplicateOptionInfo,
   37:           }.get(name.lower(), _system_info)
   38:     return cl()
   39: 
   40: simple_site = """
   41: [ALL]
   42: library_dirs = {dir1:s}{pathsep:s}{dir2:s}
   43: libraries = {lib1:s},{lib2:s}
   44: extra_compile_args = -I/fake/directory -I"/path with/spaces" -Os
   45: runtime_library_dirs = {dir1:s}
   46: 
   47: [temp1]
   48: library_dirs = {dir1:s}
   49: libraries = {lib1:s}
   50: runtime_library_dirs = {dir1:s}
   51: 
   52: [temp2]
   53: library_dirs = {dir2:s}
   54: libraries = {lib2:s}
   55: extra_link_args = -Wl,-rpath={lib2_escaped:s}
   56: rpath = {dir2:s}
   57: 
   58: [duplicate_options]
   59: mylib_libs = {lib1:s}
   60: libraries = {lib2:s}
   61: """
   62: site_cfg = simple_site
   63: 
   64: fakelib_c_text = """
   65: /* This file is generated from numpy/distutils/testing/test_system_info.py */
   66: #include<stdio.h>
   67: void foo(void) {
   68:    printf("Hello foo");
   69: }
   70: void bar(void) {
   71:    printf("Hello bar");
   72: }
   73: """
   74: 
   75: def have_compiler():
   76:     """ Return True if there appears to be an executable compiler
   77:     """
   78:     compiler = customized_ccompiler()
   79:     try:
   80:         cmd = compiler.compiler  # Unix compilers
   81:     except AttributeError:
   82:         try:
   83:             if not compiler.initialized:
   84:                 compiler.initialize()  # MSVC is different
   85:         except (DistutilsError, ValueError):
   86:             return False
   87:         cmd = [compiler.cc]
   88:     try:
   89:         p = Popen(cmd, stdout=PIPE, stderr=PIPE)
   90:         p.stdout.close()
   91:         p.stderr.close()
   92:         p.wait()
   93:     except OSError:
   94:         return False
   95:     return True
   96: 
   97: 
   98: HAVE_COMPILER = have_compiler()
   99: 
  100: 
  101: class _system_info(system_info):
  102: 
  103:     def __init__(self,
  104:                  default_lib_dirs=default_lib_dirs,
  105:                  default_include_dirs=default_include_dirs,
  106:                  verbosity=1,
  107:                  ):
  108:         self.__class__.info = {}
  109:         self.local_prefixes = []
  110:         defaults = {'library_dirs': '',
  111:                     'include_dirs': '',
  112:                     'runtime_library_dirs': '',
  113:                     'rpath': '',
  114:                     'src_dirs': '',
  115:                     'search_static_first': "0",
  116:                     'extra_compile_args': '',
  117:                     'extra_link_args': ''}
  118:         self.cp = ConfigParser(defaults)
  119:         # We have to parse the config files afterwards
  120:         # to have a consistent temporary filepath
  121: 
  122:     def _check_libs(self, lib_dirs, libs, opt_libs, exts):
  123:         """Override _check_libs to return with all dirs """
  124:         info = {'libraries': libs, 'library_dirs': lib_dirs}
  125:         return info
  126: 
  127: 
  128: class Temp1Info(_system_info):
  129:     """For testing purposes"""
  130:     section = 'temp1'
  131: 
  132: 
  133: class Temp2Info(_system_info):
  134:     """For testing purposes"""
  135:     section = 'temp2'
  136: 
  137: class DuplicateOptionInfo(_system_info):
  138:     """For testing purposes"""
  139:     section = 'duplicate_options'
  140: 
  141: 
  142: class TestSystemInfoReading:
  143: 
  144:     def setup_method(self):
  145:         """ Create the libraries """
  146:         # Create 2 sources and 2 libraries
  147:         self._dir1 = mkdtemp()
  148:         self._src1 = os.path.join(self._dir1, 'foo.c')
  149:         self._lib1 = os.path.join(self._dir1, 'libfoo.so')
  150:         self._dir2 = mkdtemp()
  151:         self._src2 = os.path.join(self._dir2, 'bar.c')
  152:         self._lib2 = os.path.join(self._dir2, 'libbar.so')
  153:         # Update local site.cfg
  154:         global simple_site, site_cfg
  155:         site_cfg = simple_site.format(
  156:             dir1=self._dir1,
  157:             lib1=self._lib1,
  158:             dir2=self._dir2,
  159:             lib2=self._lib2,
  160:             pathsep=os.pathsep,
  161:             lib2_escaped=_shell_utils.NativeParser.join([self._lib2])
  162:         )
  163:         # Write site.cfg
  164:         fd, self._sitecfg = mkstemp()
  165:         os.close(fd)
  166:         with open(self._sitecfg, 'w') as fd:
  167:             fd.write(site_cfg)
  168:         # Write the sources
  169:         with open(self._src1, 'w') as fd:
  170:             fd.write(fakelib_c_text)
  171:         with open(self._src2, 'w') as fd:
  172:             fd.write(fakelib_c_text)
  173:         # We create all class-instances
  174: 
  175:         def site_and_parse(c, site_cfg):
  176:             c.files = [site_cfg]
  177:             c.parse_config_files()
  178:             return c
  179:         self.c_default = site_and_parse(get_class('default'), self._sitecfg)
  180:         self.c_temp1 = site_and_parse(get_class('temp1'), self._sitecfg)
  181:         self.c_temp2 = site_and_parse(get_class('temp2'), self._sitecfg)
  182:         self.c_dup_options = site_and_parse(get_class('duplicate_options'),
  183:                                             self._sitecfg)
  184: 
  185:     def teardown_method(self):
  186:         # Do each removal separately
  187:         try:
  188:             shutil.rmtree(self._dir1)
  189:         except Exception:
  190:             pass
  191:         try:
  192:             shutil.rmtree(self._dir2)
  193:         except Exception:
  194:             pass
  195:         try:
  196:             os.remove(self._sitecfg)
  197:         except Exception:
  198:             pass
  199: 
  200:     def test_all(self):
  201:         # Read in all information in the ALL block
  202:         tsi = self.c_default
  203:         assert_equal(tsi.get_lib_dirs(), [self._dir1, self._dir2])
  204:         assert_equal(tsi.get_libraries(), [self._lib1, self._lib2])
  205:         assert_equal(tsi.get_runtime_lib_dirs(), [self._dir1])
  206:         extra = tsi.calc_extra_info()
  207:         assert_equal(extra['extra_compile_args'], ['-I/fake/directory', '-I/path with/spaces', '-Os'])
  208: 
  209:     def test_temp1(self):
  210:         # Read in all information in the temp1 block
  211:         tsi = self.c_temp1
  212:         assert_equal(tsi.get_lib_dirs(), [self._dir1])
  213:         assert_equal(tsi.get_libraries(), [self._lib1])
  214:         assert_equal(tsi.get_runtime_lib_dirs(), [self._dir1])
  215: 
  216:     def test_temp2(self):
  217:         # Read in all information in the temp2 block
  218:         tsi = self.c_temp2
  219:         assert_equal(tsi.get_lib_dirs(), [self._dir2])
  220:         assert_equal(tsi.get_libraries(), [self._lib2])
  221:         # Now from rpath and not runtime_library_dirs
  222:         assert_equal(tsi.get_runtime_lib_dirs(key='rpath'), [self._dir2])
  223:         extra = tsi.calc_extra_info()
  224:         assert_equal(extra['extra_link_args'], ['-Wl,-rpath=' + self._lib2])
  225: 
  226:     def test_duplicate_options(self):
  227:         # Ensure that duplicates are raising an AliasedOptionError
  228:         tsi = self.c_dup_options
  229:         assert_raises(AliasedOptionError, tsi.get_option_single, "mylib_libs", "libraries")
  230:         assert_equal(tsi.get_libs("mylib_libs", [self._lib1]), [self._lib1])
  231:         assert_equal(tsi.get_libs("libraries", [self._lib2]), [self._lib2])
  232: 
  233:     @pytest.mark.skipif(not HAVE_COMPILER, reason="Missing compiler")
  234:     def test_compile1(self):
  235:         # Compile source and link the first source
  236:         c = customized_ccompiler()
  237:         previousDir = os.getcwd()
  238:         try:
  239:             # Change directory to not screw up directories
  240:             os.chdir(self._dir1)
  241:             c.compile([os.path.basename(self._src1)], output_dir=self._dir1)
  242:             # Ensure that the object exists
  243:             assert_(os.path.isfile(self._src1.replace('.c', '.o')) or
  244:                     os.path.isfile(self._src1.replace('.c', '.obj')))
  245:         finally:
  246:             os.chdir(previousDir)
  247: 
  248:     @pytest.mark.skipif(not HAVE_COMPILER, reason="Missing compiler")
  249:     @pytest.mark.skipif('msvc' in repr(ccompiler.new_compiler()),
  250:                          reason="Fails with MSVC compiler ")
  251:     def test_compile2(self):
  252:         # Compile source and link the second source
  253:         tsi = self.c_temp2
  254:         c = customized_ccompiler()
  255:         extra_link_args = tsi.calc_extra_info()['extra_link_args']
  256:         previousDir = os.getcwd()
  257:         try:
  258:             # Change directory to not screw up directories
  259:             os.chdir(self._dir2)
  260:             c.compile([os.path.basename(self._src2)], output_dir=self._dir2,
  261:                       extra_postargs=extra_link_args)
  262:             # Ensure that the object exists
  263:             assert_(os.path.isfile(self._src2.replace('.c', '.o')))
  264:         finally:
  265:             os.chdir(previousDir)
  266: 
  267:     HAS_MKL = "mkl_rt" in mkl_info().calc_libraries_info().get("libraries", [])
  268: 
  269:     @pytest.mark.xfail(HAS_MKL, reason=("`[DEFAULT]` override doesn't work if "
  270:                                         "numpy is built with MKL support"))
  271:     def test_overrides(self):
  272:         previousDir = os.getcwd()
  273:         cfg = os.path.join(self._dir1, 'site.cfg')
  274:         shutil.copy(self._sitecfg, cfg)
  275:         try:
  276:             os.chdir(self._dir1)
  277:             # Check that the '[ALL]' section does not override
  278:             # missing values from other sections
  279:             info = mkl_info()
  280:             lib_dirs = info.cp['ALL']['library_dirs'].split(os.pathsep)
  281:             assert info.get_lib_dirs() != lib_dirs
  282: 
  283:             # But if we copy the values to a '[mkl]' section the value
  284:             # is correct
  285:             with open(cfg) as fid:
  286:                 mkl = fid.read().replace('[ALL]', '[mkl]', 1)
  287:             with open(cfg, 'w') as fid:
  288:                 fid.write(mkl)
  289:             info = mkl_info()
  290:             assert info.get_lib_dirs() == lib_dirs
  291: 
  292:             # Also, the values will be taken from a section named '[DEFAULT]'
  293:             with open(cfg) as fid:
  294:                 dflt = fid.read().replace('[mkl]', '[DEFAULT]', 1)
  295:             with open(cfg, 'w') as fid:
  296:                 fid.write(dflt)
  297:             info = mkl_info()
  298:             assert info.get_lib_dirs() == lib_dirs
  299:         finally:
  300:             os.chdir(previousDir)
  301: 
  302: 
  303: def test_distutils_parse_env_order(monkeypatch):
  304:     from numpy.distutils.system_info import _parse_env_order
  305:     env = 'NPY_TESTS_DISTUTILS_PARSE_ENV_ORDER'
  306: 
  307:     base_order = list('abcdef')
  308: 
  309:     monkeypatch.setenv(env, 'b,i,e,f')
  310:     order, unknown = _parse_env_order(base_order, env)
  311:     assert len(order) == 3
  312:     assert order == list('bef')
  313:     assert len(unknown) == 1
  314: 
  315:     # For when LAPACK/BLAS optimization is disabled
  316:     monkeypatch.setenv(env, '')
  317:     order, unknown = _parse_env_order(base_order, env)
  318:     assert len(order) == 0
  319:     assert len(unknown) == 0
  320: 
  321:     for prefix in '^!':
  322:         monkeypatch.setenv(env, f'{prefix}b,i,e')
  323:         order, unknown = _parse_env_order(base_order, env)
  324:         assert len(order) == 4
  325:         assert order == list('acdf')
  326:         assert len(unknown) == 1
  327: 
  328:     with pytest.raises(ValueError):
  329:         monkeypatch.setenv(env, 'b,^e,i')
  330:         _parse_env_order(base_order, env)
  331: 
  332:     with pytest.raises(ValueError):
  333:         monkeypatch.setenv(env, '!b,^e,i')
  334:         _parse_env_order(base_order, env)
