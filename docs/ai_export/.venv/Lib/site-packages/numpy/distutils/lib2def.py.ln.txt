    1: import re
    2: import sys
    3: import subprocess
    4: 
    5: __doc__ = """This module generates a DEF file from the symbols in
    6: an MSVC-compiled DLL import library.  It correctly discriminates between
    7: data and functions.  The data is collected from the output of the program
    8: nm(1).
    9: 
   10: Usage:
   11:     python lib2def.py [libname.lib] [output.def]
   12: or
   13:     python lib2def.py [libname.lib] > output.def
   14: 
   15: libname.lib defaults to python<py_ver>.lib and output.def defaults to stdout
   16: 
   17: Author: Robert Kern <kernr@mail.ncifcrf.gov>
   18: Last Update: April 30, 1999
   19: """
   20: 
   21: __version__ = '0.1a'
   22: 
   23: py_ver = "%d%d" % tuple(sys.version_info[:2])
   24: 
   25: DEFAULT_NM = ['nm', '-Cs']
   26: 
   27: DEF_HEADER = """LIBRARY         python%s.dll
   28: ;CODE           PRELOAD MOVEABLE DISCARDABLE
   29: ;DATA           PRELOAD SINGLE
   30: 
   31: EXPORTS
   32: """ % py_ver
   33: # the header of the DEF file
   34: 
   35: FUNC_RE = re.compile(r"^(.*) in python%s\.dll" % py_ver, re.MULTILINE)
   36: DATA_RE = re.compile(r"^_imp__(.*) in python%s\.dll" % py_ver, re.MULTILINE)
   37: 
   38: def parse_cmd():
   39:     """Parses the command-line arguments.
   40: 
   41: libfile, deffile = parse_cmd()"""
   42:     if len(sys.argv) == 3:
   43:         if sys.argv[1][-4:] == '.lib' and sys.argv[2][-4:] == '.def':
   44:             libfile, deffile = sys.argv[1:]
   45:         elif sys.argv[1][-4:] == '.def' and sys.argv[2][-4:] == '.lib':
   46:             deffile, libfile = sys.argv[1:]
   47:         else:
   48:             print("I'm assuming that your first argument is the library")
   49:             print("and the second is the DEF file.")
   50:     elif len(sys.argv) == 2:
   51:         if sys.argv[1][-4:] == '.def':
   52:             deffile = sys.argv[1]
   53:             libfile = 'python%s.lib' % py_ver
   54:         elif sys.argv[1][-4:] == '.lib':
   55:             deffile = None
   56:             libfile = sys.argv[1]
   57:     else:
   58:         libfile = 'python%s.lib' % py_ver
   59:         deffile = None
   60:     return libfile, deffile
   61: 
   62: def getnm(nm_cmd=['nm', '-Cs', 'python%s.lib' % py_ver], shell=True):
   63:     """Returns the output of nm_cmd via a pipe.
   64: 
   65: nm_output = getnm(nm_cmd = 'nm -Cs py_lib')"""
   66:     p = subprocess.Popen(nm_cmd, shell=shell, stdout=subprocess.PIPE,
   67:                          stderr=subprocess.PIPE, text=True)
   68:     nm_output, nm_err = p.communicate()
   69:     if p.returncode != 0:
   70:         raise RuntimeError('failed to run "%s": "%s"' % (
   71:                                      ' '.join(nm_cmd), nm_err))
   72:     return nm_output
   73: 
   74: def parse_nm(nm_output):
   75:     """Returns a tuple of lists: dlist for the list of data
   76: symbols and flist for the list of function symbols.
   77: 
   78: dlist, flist = parse_nm(nm_output)"""
   79:     data = DATA_RE.findall(nm_output)
   80:     func = FUNC_RE.findall(nm_output)
   81: 
   82:     flist = []
   83:     for sym in data:
   84:         if sym in func and (sym[:2] == 'Py' or sym[:3] == '_Py' or sym[:4] == 'init'):
   85:             flist.append(sym)
   86: 
   87:     dlist = []
   88:     for sym in data:
   89:         if sym not in flist and (sym[:2] == 'Py' or sym[:3] == '_Py'):
   90:             dlist.append(sym)
   91: 
   92:     dlist.sort()
   93:     flist.sort()
   94:     return dlist, flist
   95: 
   96: def output_def(dlist, flist, header, file = sys.stdout):
   97:     """Outputs the final DEF file to a file defaulting to stdout.
   98: 
   99: output_def(dlist, flist, header, file = sys.stdout)"""
  100:     for data_sym in dlist:
  101:         header = header + '\t%s DATA\n' % data_sym
  102:     header = header + '\n' # blank line
  103:     for func_sym in flist:
  104:         header = header + '\t%s\n' % func_sym
  105:     file.write(header)
  106: 
  107: if __name__ == '__main__':
  108:     libfile, deffile = parse_cmd()
  109:     if deffile is None:
  110:         deffile = sys.stdout
  111:     else:
  112:         deffile = open(deffile, 'w')
  113:     nm_cmd = DEFAULT_NM + [str(libfile)]
  114:     nm_output = getnm(nm_cmd, shell=False)
  115:     dlist, flist = parse_nm(nm_output)
  116:     output_def(dlist, flist, DEF_HEADER, deffile)
