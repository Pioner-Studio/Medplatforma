    1: """
    2: exec_command
    3: 
    4: Implements exec_command function that is (almost) equivalent to
    5: commands.getstatusoutput function but on NT, DOS systems the
    6: returned status is actually correct (though, the returned status
    7: values may be different by a factor). In addition, exec_command
    8: takes keyword arguments for (re-)defining environment variables.
    9: 
   10: Provides functions:
   11: 
   12:   exec_command  --- execute command in a specified directory and
   13:                     in the modified environment.
   14:   find_executable --- locate a command using info from environment
   15:                     variable PATH. Equivalent to posix `which`
   16:                     command.
   17: 
   18: Author: Pearu Peterson <pearu@cens.ioc.ee>
   19: Created: 11 January 2003
   20: 
   21: Requires: Python 2.x
   22: 
   23: Successfully tested on:
   24: 
   25: ========  ============  =================================================
   26: os.name   sys.platform  comments
   27: ========  ============  =================================================
   28: posix     linux2        Debian (sid) Linux, Python 2.1.3+, 2.2.3+, 2.3.3
   29:                         PyCrust 0.9.3, Idle 1.0.2
   30: posix     linux2        Red Hat 9 Linux, Python 2.1.3, 2.2.2, 2.3.2
   31: posix     sunos5        SunOS 5.9, Python 2.2, 2.3.2
   32: posix     darwin        Darwin 7.2.0, Python 2.3
   33: nt        win32         Windows Me
   34:                         Python 2.3(EE), Idle 1.0, PyCrust 0.7.2
   35:                         Python 2.1.1 Idle 0.8
   36: nt        win32         Windows 98, Python 2.1.1. Idle 0.8
   37: nt        win32         Cygwin 98-4.10, Python 2.1.1(MSC) - echo tests
   38:                         fail i.e. redefining environment variables may
   39:                         not work. FIXED: don't use cygwin echo!
   40:                         Comment: also `cmd /c echo` will not work
   41:                         but redefining environment variables do work.
   42: posix     cygwin        Cygwin 98-4.10, Python 2.3.3(cygming special)
   43: nt        win32         Windows XP, Python 2.3.3
   44: ========  ============  =================================================
   45: 
   46: Known bugs:
   47: 
   48: * Tests, that send messages to stderr, fail when executed from MSYS prompt
   49:   because the messages are lost at some point.
   50: 
   51: """
   52: __all__ = ['exec_command', 'find_executable']
   53: 
   54: import os
   55: import sys
   56: import subprocess
   57: import locale
   58: import warnings
   59: 
   60: from numpy.distutils.misc_util import is_sequence, make_temp_file
   61: from numpy.distutils import log
   62: 
   63: def filepath_from_subprocess_output(output):
   64:     """
   65:     Convert `bytes` in the encoding used by a subprocess into a filesystem-appropriate `str`.
   66: 
   67:     Inherited from `exec_command`, and possibly incorrect.
   68:     """
   69:     mylocale = locale.getpreferredencoding(False)
   70:     if mylocale is None:
   71:         mylocale = 'ascii'
   72:     output = output.decode(mylocale, errors='replace')
   73:     output = output.replace('\r\n', '\n')
   74:     # Another historical oddity
   75:     if output[-1:] == '\n':
   76:         output = output[:-1]
   77:     return output
   78: 
   79: 
   80: def forward_bytes_to_stdout(val):
   81:     """
   82:     Forward bytes from a subprocess call to the console, without attempting to
   83:     decode them.
   84: 
   85:     The assumption is that the subprocess call already returned bytes in
   86:     a suitable encoding.
   87:     """
   88:     if hasattr(sys.stdout, 'buffer'):
   89:         # use the underlying binary output if there is one
   90:         sys.stdout.buffer.write(val)
   91:     elif hasattr(sys.stdout, 'encoding'):
   92:         # round-trip the encoding if necessary
   93:         sys.stdout.write(val.decode(sys.stdout.encoding))
   94:     else:
   95:         # make a best-guess at the encoding
   96:         sys.stdout.write(val.decode('utf8', errors='replace'))
   97: 
   98: 
   99: def temp_file_name():
  100:     # 2019-01-30, 1.17
  101:     warnings.warn('temp_file_name is deprecated since NumPy v1.17, use '
  102:                   'tempfile.mkstemp instead', DeprecationWarning, stacklevel=1)
  103:     fo, name = make_temp_file()
  104:     fo.close()
  105:     return name
  106: 
  107: def get_pythonexe():
  108:     pythonexe = sys.executable
  109:     if os.name in ['nt', 'dos']:
  110:         fdir, fn = os.path.split(pythonexe)
  111:         fn = fn.upper().replace('PYTHONW', 'PYTHON')
  112:         pythonexe = os.path.join(fdir, fn)
  113:         assert os.path.isfile(pythonexe), '%r is not a file' % (pythonexe,)
  114:     return pythonexe
  115: 
  116: def find_executable(exe, path=None, _cache={}):
  117:     """Return full path of a executable or None.
  118: 
  119:     Symbolic links are not followed.
  120:     """
  121:     key = exe, path
  122:     try:
  123:         return _cache[key]
  124:     except KeyError:
  125:         pass
  126:     log.debug('find_executable(%r)' % exe)
  127:     orig_exe = exe
  128: 
  129:     if path is None:
  130:         path = os.environ.get('PATH', os.defpath)
  131:     if os.name=='posix':
  132:         realpath = os.path.realpath
  133:     else:
  134:         realpath = lambda a:a
  135: 
  136:     if exe.startswith('"'):
  137:         exe = exe[1:-1]
  138: 
  139:     suffixes = ['']
  140:     if os.name in ['nt', 'dos', 'os2']:
  141:         fn, ext = os.path.splitext(exe)
  142:         extra_suffixes = ['.exe', '.com', '.bat']
  143:         if ext.lower() not in extra_suffixes:
  144:             suffixes = extra_suffixes
  145: 
  146:     if os.path.isabs(exe):
  147:         paths = ['']
  148:     else:
  149:         paths = [ os.path.abspath(p) for p in path.split(os.pathsep) ]
  150: 
  151:     for path in paths:
  152:         fn = os.path.join(path, exe)
  153:         for s in suffixes:
  154:             f_ext = fn+s
  155:             if not os.path.islink(f_ext):
  156:                 f_ext = realpath(f_ext)
  157:             if os.path.isfile(f_ext) and os.access(f_ext, os.X_OK):
  158:                 log.info('Found executable %s' % f_ext)
  159:                 _cache[key] = f_ext
  160:                 return f_ext
  161: 
  162:     log.warn('Could not locate executable %s' % orig_exe)
  163:     return None
  164: 
  165: ############################################################
  166: 
  167: def _preserve_environment( names ):
  168:     log.debug('_preserve_environment(%r)' % (names))
  169:     env = {name: os.environ.get(name) for name in names}
  170:     return env
  171: 
  172: def _update_environment( **env ):
  173:     log.debug('_update_environment(...)')
  174:     for name, value in env.items():
  175:         os.environ[name] = value or ''
  176: 
  177: def exec_command(command, execute_in='', use_shell=None, use_tee=None,
  178:                  _with_python = 1, **env ):
  179:     """
  180:     Return (status,output) of executed command.
  181: 
  182:     .. deprecated:: 1.17
  183:         Use subprocess.Popen instead
  184: 
  185:     Parameters
  186:     ----------
  187:     command : str
  188:         A concatenated string of executable and arguments.
  189:     execute_in : str
  190:         Before running command ``cd execute_in`` and after ``cd -``.
  191:     use_shell : {bool, None}, optional
  192:         If True, execute ``sh -c command``. Default None (True)
  193:     use_tee : {bool, None}, optional
  194:         If True use tee. Default None (True)
  195: 
  196: 
  197:     Returns
  198:     -------
  199:     res : str
  200:         Both stdout and stderr messages.
  201: 
  202:     Notes
  203:     -----
  204:     On NT, DOS systems the returned status is correct for external commands.
  205:     Wild cards will not work for non-posix systems or when use_shell=0.
  206: 
  207:     """
  208:     # 2019-01-30, 1.17
  209:     warnings.warn('exec_command is deprecated since NumPy v1.17, use '
  210:                   'subprocess.Popen instead', DeprecationWarning, stacklevel=1)
  211:     log.debug('exec_command(%r,%s)' % (command,
  212:          ','.join(['%s=%r'%kv for kv in env.items()])))
  213: 
  214:     if use_tee is None:
  215:         use_tee = os.name=='posix'
  216:     if use_shell is None:
  217:         use_shell = os.name=='posix'
  218:     execute_in = os.path.abspath(execute_in)
  219:     oldcwd = os.path.abspath(os.getcwd())
  220: 
  221:     if __name__[-12:] == 'exec_command':
  222:         exec_dir = os.path.dirname(os.path.abspath(__file__))
  223:     elif os.path.isfile('exec_command.py'):
  224:         exec_dir = os.path.abspath('.')
  225:     else:
  226:         exec_dir = os.path.abspath(sys.argv[0])
  227:         if os.path.isfile(exec_dir):
  228:             exec_dir = os.path.dirname(exec_dir)
  229: 
  230:     if oldcwd!=execute_in:
  231:         os.chdir(execute_in)
  232:         log.debug('New cwd: %s' % execute_in)
  233:     else:
  234:         log.debug('Retaining cwd: %s' % oldcwd)
  235: 
  236:     oldenv = _preserve_environment( list(env.keys()) )
  237:     _update_environment( **env )
  238: 
  239:     try:
  240:         st = _exec_command(command,
  241:                            use_shell=use_shell,
  242:                            use_tee=use_tee,
  243:                            **env)
  244:     finally:
  245:         if oldcwd!=execute_in:
  246:             os.chdir(oldcwd)
  247:             log.debug('Restored cwd to %s' % oldcwd)
  248:         _update_environment(**oldenv)
  249: 
  250:     return st
  251: 
  252: 
  253: def _exec_command(command, use_shell=None, use_tee = None, **env):
  254:     """
  255:     Internal workhorse for exec_command().
  256:     """
  257:     if use_shell is None:
  258:         use_shell = os.name=='posix'
  259:     if use_tee is None:
  260:         use_tee = os.name=='posix'
  261: 
  262:     if os.name == 'posix' and use_shell:
  263:         # On POSIX, subprocess always uses /bin/sh, override
  264:         sh = os.environ.get('SHELL', '/bin/sh')
  265:         if is_sequence(command):
  266:             command = [sh, '-c', ' '.join(command)]
  267:         else:
  268:             command = [sh, '-c', command]
  269:         use_shell = False
  270: 
  271:     elif os.name == 'nt' and is_sequence(command):
  272:         # On Windows, join the string for CreateProcess() ourselves as
  273:         # subprocess does it a bit differently
  274:         command = ' '.join(_quote_arg(arg) for arg in command)
  275: 
  276:     # Inherit environment by default
  277:     env = env or None
  278:     try:
  279:         # text is set to False so that communicate()
  280:         # will return bytes. We need to decode the output ourselves
  281:         # so that Python will not raise a UnicodeDecodeError when
  282:         # it encounters an invalid character; rather, we simply replace it
  283:         proc = subprocess.Popen(command, shell=use_shell, env=env, text=False,
  284:                                 stdout=subprocess.PIPE,
  285:                                 stderr=subprocess.STDOUT)
  286:     except OSError:
  287:         # Return 127, as os.spawn*() and /bin/sh do
  288:         return 127, ''
  289: 
  290:     text, err = proc.communicate()
  291:     mylocale = locale.getpreferredencoding(False)
  292:     if mylocale is None:
  293:         mylocale = 'ascii'
  294:     text = text.decode(mylocale, errors='replace')
  295:     text = text.replace('\r\n', '\n')
  296:     # Another historical oddity
  297:     if text[-1:] == '\n':
  298:         text = text[:-1]
  299: 
  300:     if use_tee and text:
  301:         print(text)
  302:     return proc.returncode, text
  303: 
  304: 
  305: def _quote_arg(arg):
  306:     """
  307:     Quote the argument for safe use in a shell command line.
  308:     """
  309:     # If there is a quote in the string, assume relevant parts of the
  310:     # string are already quoted (e.g. '-I"C:\\Program Files\\..."')
  311:     if '"' not in arg and ' ' in arg:
  312:         return '"%s"' % arg
  313:     return arg
  314: 
  315: ############################################################
