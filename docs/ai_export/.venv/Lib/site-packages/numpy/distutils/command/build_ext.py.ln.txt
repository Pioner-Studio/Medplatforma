    1: """ Modified version of build_ext that handles fortran source files.
    2: 
    3: """
    4: import os
    5: import subprocess
    6: from glob import glob
    7: 
    8: from distutils.dep_util import newer_group
    9: from distutils.command.build_ext import build_ext as old_build_ext
   10: from distutils.errors import DistutilsFileError, DistutilsSetupError,\
   11:     DistutilsError
   12: from distutils.file_util import copy_file
   13: 
   14: from numpy.distutils import log
   15: from numpy.distutils.exec_command import filepath_from_subprocess_output
   16: from numpy.distutils.system_info import combine_paths
   17: from numpy.distutils.misc_util import (
   18:     filter_sources, get_ext_source_files, get_numpy_include_dirs,
   19:     has_cxx_sources, has_f_sources, is_sequence
   20: )
   21: from numpy.distutils.command.config_compiler import show_fortran_compilers
   22: from numpy.distutils.ccompiler_opt import new_ccompiler_opt, CCompilerOpt
   23: 
   24: class build_ext (old_build_ext):
   25: 
   26:     description = "build C/C++/F extensions (compile/link to build directory)"
   27: 
   28:     user_options = old_build_ext.user_options + [
   29:         ('fcompiler=', None,
   30:          "specify the Fortran compiler type"),
   31:         ('parallel=', 'j',
   32:          "number of parallel jobs"),
   33:         ('warn-error', None,
   34:          "turn all warnings into errors (-Werror)"),
   35:         ('cpu-baseline=', None,
   36:          "specify a list of enabled baseline CPU optimizations"),
   37:         ('cpu-dispatch=', None,
   38:          "specify a list of dispatched CPU optimizations"),
   39:         ('disable-optimization', None,
   40:          "disable CPU optimized code(dispatch,simd,fast...)"),
   41:         ('simd-test=', None,
   42:          "specify a list of CPU optimizations to be tested against NumPy SIMD interface"),
   43:     ]
   44: 
   45:     help_options = old_build_ext.help_options + [
   46:         ('help-fcompiler', None, "list available Fortran compilers",
   47:          show_fortran_compilers),
   48:     ]
   49: 
   50:     boolean_options = old_build_ext.boolean_options + ['warn-error', 'disable-optimization']
   51: 
   52:     def initialize_options(self):
   53:         old_build_ext.initialize_options(self)
   54:         self.fcompiler = None
   55:         self.parallel = None
   56:         self.warn_error = None
   57:         self.cpu_baseline = None
   58:         self.cpu_dispatch = None
   59:         self.disable_optimization = None
   60:         self.simd_test = None
   61: 
   62:     def finalize_options(self):
   63:         if self.parallel:
   64:             try:
   65:                 self.parallel = int(self.parallel)
   66:             except ValueError as e:
   67:                 raise ValueError("--parallel/-j argument must be an integer") from e
   68: 
   69:         # Ensure that self.include_dirs and self.distribution.include_dirs
   70:         # refer to the same list object. finalize_options will modify
   71:         # self.include_dirs, but self.distribution.include_dirs is used
   72:         # during the actual build.
   73:         # self.include_dirs is None unless paths are specified with
   74:         # --include-dirs.
   75:         # The include paths will be passed to the compiler in the order:
   76:         # numpy paths, --include-dirs paths, Python include path.
   77:         if isinstance(self.include_dirs, str):
   78:             self.include_dirs = self.include_dirs.split(os.pathsep)
   79:         incl_dirs = self.include_dirs or []
   80:         if self.distribution.include_dirs is None:
   81:             self.distribution.include_dirs = []
   82:         self.include_dirs = self.distribution.include_dirs
   83:         self.include_dirs.extend(incl_dirs)
   84: 
   85:         old_build_ext.finalize_options(self)
   86:         self.set_undefined_options('build',
   87:                                         ('parallel', 'parallel'),
   88:                                         ('warn_error', 'warn_error'),
   89:                                         ('cpu_baseline', 'cpu_baseline'),
   90:                                         ('cpu_dispatch', 'cpu_dispatch'),
   91:                                         ('disable_optimization', 'disable_optimization'),
   92:                                         ('simd_test', 'simd_test')
   93:                                   )
   94:         CCompilerOpt.conf_target_groups["simd_test"] = self.simd_test
   95: 
   96:     def run(self):
   97:         if not self.extensions:
   98:             return
   99: 
  100:         # Make sure that extension sources are complete.
  101:         self.run_command('build_src')
  102: 
  103:         if self.distribution.has_c_libraries():
  104:             if self.inplace:
  105:                 if self.distribution.have_run.get('build_clib'):
  106:                     log.warn('build_clib already run, it is too late to '
  107:                              'ensure in-place build of build_clib')
  108:                     build_clib = self.distribution.get_command_obj(
  109:                         'build_clib')
  110:                 else:
  111:                     build_clib = self.distribution.get_command_obj(
  112:                         'build_clib')
  113:                     build_clib.inplace = 1
  114:                     build_clib.ensure_finalized()
  115:                     build_clib.run()
  116:                     self.distribution.have_run['build_clib'] = 1
  117: 
  118:             else:
  119:                 self.run_command('build_clib')
  120:                 build_clib = self.get_finalized_command('build_clib')
  121:             self.library_dirs.append(build_clib.build_clib)
  122:         else:
  123:             build_clib = None
  124: 
  125:         # Not including C libraries to the list of
  126:         # extension libraries automatically to prevent
  127:         # bogus linking commands. Extensions must
  128:         # explicitly specify the C libraries that they use.
  129: 
  130:         from distutils.ccompiler import new_compiler
  131:         from numpy.distutils.fcompiler import new_fcompiler
  132: 
  133:         compiler_type = self.compiler
  134:         # Initialize C compiler:
  135:         self.compiler = new_compiler(compiler=compiler_type,
  136:                                      verbose=self.verbose,
  137:                                      dry_run=self.dry_run,
  138:                                      force=self.force)
  139:         self.compiler.customize(self.distribution)
  140:         self.compiler.customize_cmd(self)
  141: 
  142:         if self.warn_error:
  143:             self.compiler.compiler.append('-Werror')
  144:             self.compiler.compiler_so.append('-Werror')
  145: 
  146:         self.compiler.show_customization()
  147: 
  148:         if not self.disable_optimization:
  149:             dispatch_hpath = os.path.join("numpy", "distutils", "include", "npy_cpu_dispatch_config.h")
  150:             dispatch_hpath = os.path.join(self.get_finalized_command("build_src").build_src, dispatch_hpath)
  151:             opt_cache_path = os.path.abspath(
  152:                 os.path.join(self.build_temp, 'ccompiler_opt_cache_ext.py')
  153:             )
  154:             if hasattr(self, "compiler_opt"):
  155:                 # By default `CCompilerOpt` update the cache at the exit of
  156:                 # the process, which may lead to duplicate building
  157:                 # (see build_extension()/force_rebuild) if run() called
  158:                 # multiple times within the same os process/thread without
  159:                 # giving the chance the previous instances of `CCompilerOpt`
  160:                 # to update the cache.
  161:                 self.compiler_opt.cache_flush()
  162: 
  163:             self.compiler_opt = new_ccompiler_opt(
  164:                 compiler=self.compiler, dispatch_hpath=dispatch_hpath,
  165:                 cpu_baseline=self.cpu_baseline, cpu_dispatch=self.cpu_dispatch,
  166:                 cache_path=opt_cache_path
  167:             )
  168:             def report(copt):
  169:                 log.info("\n########### EXT COMPILER OPTIMIZATION ###########")
  170:                 log.info(copt.report(full=True))
  171: 
  172:             import atexit
  173:             atexit.register(report, self.compiler_opt)
  174: 
  175:         # Setup directory for storing generated extra DLL files on Windows
  176:         self.extra_dll_dir = os.path.join(self.build_temp, '.libs')
  177:         if not os.path.isdir(self.extra_dll_dir):
  178:             os.makedirs(self.extra_dll_dir)
  179: 
  180:         # Create mapping of libraries built by build_clib:
  181:         clibs = {}
  182:         if build_clib is not None:
  183:             for libname, build_info in build_clib.libraries or []:
  184:                 if libname in clibs and clibs[libname] != build_info:
  185:                     log.warn('library %r defined more than once,'
  186:                              ' overwriting build_info\n%s... \nwith\n%s...'
  187:                              % (libname, repr(clibs[libname])[:300], repr(build_info)[:300]))
  188:                 clibs[libname] = build_info
  189:         # .. and distribution libraries:
  190:         for libname, build_info in self.distribution.libraries or []:
  191:             if libname in clibs:
  192:                 # build_clib libraries have a precedence before distribution ones
  193:                 continue
  194:             clibs[libname] = build_info
  195: 
  196:         # Determine if C++/Fortran 77/Fortran 90 compilers are needed.
  197:         # Update extension libraries, library_dirs, and macros.
  198:         all_languages = set()
  199:         for ext in self.extensions:
  200:             ext_languages = set()
  201:             c_libs = []
  202:             c_lib_dirs = []
  203:             macros = []
  204:             for libname in ext.libraries:
  205:                 if libname in clibs:
  206:                     binfo = clibs[libname]
  207:                     c_libs += binfo.get('libraries', [])
  208:                     c_lib_dirs += binfo.get('library_dirs', [])
  209:                     for m in binfo.get('macros', []):
  210:                         if m not in macros:
  211:                             macros.append(m)
  212: 
  213:                 for l in clibs.get(libname, {}).get('source_languages', []):
  214:                     ext_languages.add(l)
  215:             if c_libs:
  216:                 new_c_libs = ext.libraries + c_libs
  217:                 log.info('updating extension %r libraries from %r to %r'
  218:                          % (ext.name, ext.libraries, new_c_libs))
  219:                 ext.libraries = new_c_libs
  220:                 ext.library_dirs = ext.library_dirs + c_lib_dirs
  221:             if macros:
  222:                 log.info('extending extension %r defined_macros with %r'
  223:                          % (ext.name, macros))
  224:                 ext.define_macros = ext.define_macros + macros
  225: 
  226:             # determine extension languages
  227:             if has_f_sources(ext.sources):
  228:                 ext_languages.add('f77')
  229:             if has_cxx_sources(ext.sources):
  230:                 ext_languages.add('c++')
  231:             l = ext.language or self.compiler.detect_language(ext.sources)
  232:             if l:
  233:                 ext_languages.add(l)
  234: 
  235:             # reset language attribute for choosing proper linker
  236:             #
  237:             # When we build extensions with multiple languages, we have to
  238:             # choose a linker. The rules here are:
  239:             #   1. if there is Fortran code, always prefer the Fortran linker,
  240:             #   2. otherwise prefer C++ over C,
  241:             #   3. Users can force a particular linker by using
  242:             #          `language='c'`  # or 'c++', 'f90', 'f77'
  243:             #      in their config.add_extension() calls.
  244:             if 'c++' in ext_languages:
  245:                 ext_language = 'c++'
  246:             else:
  247:                 ext_language = 'c'  # default
  248: 
  249:             has_fortran = False
  250:             if 'f90' in ext_languages:
  251:                 ext_language = 'f90'
  252:                 has_fortran = True
  253:             elif 'f77' in ext_languages:
  254:                 ext_language = 'f77'
  255:                 has_fortran = True
  256: 
  257:             if not ext.language or has_fortran:
  258:                 if l and l != ext_language and ext.language:
  259:                     log.warn('resetting extension %r language from %r to %r.' %
  260:                              (ext.name, l, ext_language))
  261: 
  262:             ext.language = ext_language
  263: 
  264:             # global language
  265:             all_languages.update(ext_languages)
  266: 
  267:         need_f90_compiler = 'f90' in all_languages
  268:         need_f77_compiler = 'f77' in all_languages
  269:         need_cxx_compiler = 'c++' in all_languages
  270: 
  271:         # Initialize C++ compiler:
  272:         if need_cxx_compiler:
  273:             self._cxx_compiler = new_compiler(compiler=compiler_type,
  274:                                               verbose=self.verbose,
  275:                                               dry_run=self.dry_run,
  276:                                               force=self.force)
  277:             compiler = self._cxx_compiler
  278:             compiler.customize(self.distribution, need_cxx=need_cxx_compiler)
  279:             compiler.customize_cmd(self)
  280:             compiler.show_customization()
  281:             self._cxx_compiler = compiler.cxx_compiler()
  282:         else:
  283:             self._cxx_compiler = None
  284: 
  285:         # Initialize Fortran 77 compiler:
  286:         if need_f77_compiler:
  287:             ctype = self.fcompiler
  288:             self._f77_compiler = new_fcompiler(compiler=self.fcompiler,
  289:                                                verbose=self.verbose,
  290:                                                dry_run=self.dry_run,
  291:                                                force=self.force,
  292:                                                requiref90=False,
  293:                                                c_compiler=self.compiler)
  294:             fcompiler = self._f77_compiler
  295:             if fcompiler:
  296:                 ctype = fcompiler.compiler_type
  297:                 fcompiler.customize(self.distribution)
  298:             if fcompiler and fcompiler.get_version():
  299:                 fcompiler.customize_cmd(self)
  300:                 fcompiler.show_customization()
  301:             else:
  302:                 self.warn('f77_compiler=%s is not available.' %
  303:                           (ctype))
  304:                 self._f77_compiler = None
  305:         else:
  306:             self._f77_compiler = None
  307: 
  308:         # Initialize Fortran 90 compiler:
  309:         if need_f90_compiler:
  310:             ctype = self.fcompiler
  311:             self._f90_compiler = new_fcompiler(compiler=self.fcompiler,
  312:                                                verbose=self.verbose,
  313:                                                dry_run=self.dry_run,
  314:                                                force=self.force,
  315:                                                requiref90=True,
  316:                                                c_compiler=self.compiler)
  317:             fcompiler = self._f90_compiler
  318:             if fcompiler:
  319:                 ctype = fcompiler.compiler_type
  320:                 fcompiler.customize(self.distribution)
  321:             if fcompiler and fcompiler.get_version():
  322:                 fcompiler.customize_cmd(self)
  323:                 fcompiler.show_customization()
  324:             else:
  325:                 self.warn('f90_compiler=%s is not available.' %
  326:                           (ctype))
  327:                 self._f90_compiler = None
  328:         else:
  329:             self._f90_compiler = None
  330: 
  331:         # Build extensions
  332:         self.build_extensions()
  333: 
  334:         # Copy over any extra DLL files
  335:         # FIXME: In the case where there are more than two packages,
  336:         # we blindly assume that both packages need all of the libraries,
  337:         # resulting in a larger wheel than is required. This should be fixed,
  338:         # but it's so rare that I won't bother to handle it.
  339:         pkg_roots = {
  340:             self.get_ext_fullname(ext.name).split('.')[0]
  341:             for ext in self.extensions
  342:         }
  343:         for pkg_root in pkg_roots:
  344:             shared_lib_dir = os.path.join(pkg_root, '.libs')
  345:             if not self.inplace:
  346:                 shared_lib_dir = os.path.join(self.build_lib, shared_lib_dir)
  347:             for fn in os.listdir(self.extra_dll_dir):
  348:                 if not os.path.isdir(shared_lib_dir):
  349:                     os.makedirs(shared_lib_dir)
  350:                 if not fn.lower().endswith('.dll'):
  351:                     continue
  352:                 runtime_lib = os.path.join(self.extra_dll_dir, fn)
  353:                 copy_file(runtime_lib, shared_lib_dir)
  354: 
  355:     def swig_sources(self, sources, extensions=None):
  356:         # Do nothing. Swig sources have been handled in build_src command.
  357:         return sources
  358: 
  359:     def build_extension(self, ext):
  360:         sources = ext.sources
  361:         if sources is None or not is_sequence(sources):
  362:             raise DistutilsSetupError(
  363:                 ("in 'ext_modules' option (extension '%s'), "
  364:                  "'sources' must be present and must be "
  365:                  "a list of source filenames") % ext.name)
  366:         sources = list(sources)
  367: 
  368:         if not sources:
  369:             return
  370: 
  371:         fullname = self.get_ext_fullname(ext.name)
  372:         if self.inplace:
  373:             modpath = fullname.split('.')
  374:             package = '.'.join(modpath[0:-1])
  375:             base = modpath[-1]
  376:             build_py = self.get_finalized_command('build_py')
  377:             package_dir = build_py.get_package_dir(package)
  378:             ext_filename = os.path.join(package_dir,
  379:                                         self.get_ext_filename(base))
  380:         else:
  381:             ext_filename = os.path.join(self.build_lib,
  382:                                         self.get_ext_filename(fullname))
  383:         depends = sources + ext.depends
  384: 
  385:         force_rebuild = self.force
  386:         if not self.disable_optimization and not self.compiler_opt.is_cached():
  387:             log.debug("Detected changes on compiler optimizations")
  388:             force_rebuild = True
  389:         if not (force_rebuild or newer_group(depends, ext_filename, 'newer')):
  390:             log.debug("skipping '%s' extension (up-to-date)", ext.name)
  391:             return
  392:         else:
  393:             log.info("building '%s' extension", ext.name)
  394: 
  395:         extra_args = ext.extra_compile_args or []
  396:         extra_cflags = getattr(ext, 'extra_c_compile_args', None) or []
  397:         extra_cxxflags = getattr(ext, 'extra_cxx_compile_args', None) or []
  398: 
  399:         macros = ext.define_macros[:]
  400:         for undef in ext.undef_macros:
  401:             macros.append((undef,))
  402: 
  403:         c_sources, cxx_sources, f_sources, fmodule_sources = \
  404:             filter_sources(ext.sources)
  405: 
  406:         if self.compiler.compiler_type == 'msvc':
  407:             if cxx_sources:
  408:                 # Needed to compile kiva.agg._agg extension.
  409:                 extra_args.append('/Zm1000')
  410:                 extra_cflags += extra_cxxflags
  411:             # this hack works around the msvc compiler attributes
  412:             # problem, msvc uses its own convention :(
  413:             c_sources += cxx_sources
  414:             cxx_sources = []
  415: 
  416:         # Set Fortran/C++ compilers for compilation and linking.
  417:         if ext.language == 'f90':
  418:             fcompiler = self._f90_compiler
  419:         elif ext.language == 'f77':
  420:             fcompiler = self._f77_compiler
  421:         else:  # in case ext.language is c++, for instance
  422:             fcompiler = self._f90_compiler or self._f77_compiler
  423:         if fcompiler is not None:
  424:             fcompiler.extra_f77_compile_args = (ext.extra_f77_compile_args or []) if hasattr(
  425:                 ext, 'extra_f77_compile_args') else []
  426:             fcompiler.extra_f90_compile_args = (ext.extra_f90_compile_args or []) if hasattr(
  427:                 ext, 'extra_f90_compile_args') else []
  428:         cxx_compiler = self._cxx_compiler
  429: 
  430:         # check for the availability of required compilers
  431:         if cxx_sources and cxx_compiler is None:
  432:             raise DistutilsError("extension %r has C++ sources"
  433:                                  "but no C++ compiler found" % (ext.name))
  434:         if (f_sources or fmodule_sources) and fcompiler is None:
  435:             raise DistutilsError("extension %r has Fortran sources "
  436:                                  "but no Fortran compiler found" % (ext.name))
  437:         if ext.language in ['f77', 'f90'] and fcompiler is None:
  438:             self.warn("extension %r has Fortran libraries "
  439:                       "but no Fortran linker found, using default linker" % (ext.name))
  440:         if ext.language == 'c++' and cxx_compiler is None:
  441:             self.warn("extension %r has C++ libraries "
  442:                       "but no C++ linker found, using default linker" % (ext.name))
  443: 
  444:         kws = {'depends': ext.depends}
  445:         output_dir = self.build_temp
  446: 
  447:         include_dirs = ext.include_dirs + get_numpy_include_dirs()
  448: 
  449:         # filtering C dispatch-table sources when optimization is not disabled,
  450:         # otherwise treated as normal sources.
  451:         copt_c_sources = []
  452:         copt_cxx_sources = []
  453:         copt_baseline_flags = []
  454:         copt_macros = []
  455:         if not self.disable_optimization:
  456:             bsrc_dir = self.get_finalized_command("build_src").build_src
  457:             dispatch_hpath = os.path.join("numpy", "distutils", "include")
  458:             dispatch_hpath = os.path.join(bsrc_dir, dispatch_hpath)
  459:             include_dirs.append(dispatch_hpath)
  460: 
  461:             # copt_build_src = None if self.inplace else bsrc_dir
  462:             # Always generate the generated config files and
  463:             # dispatch-able sources inside the build directory,
  464:             # even if the build option `inplace` is enabled.
  465:             # This approach prevents conflicts with Meson-generated
  466:             # config headers. Since `spin build --clean` will not remove
  467:             # these headers, they might overwrite the generated Meson headers,
  468:             # causing compatibility issues. Maintaining separate directories
  469:             # ensures compatibility between distutils dispatch config headers
  470:             # and Meson headers, avoiding build disruptions.
  471:             # See gh-24450 for more details.
  472:             copt_build_src = bsrc_dir
  473:             for _srcs, _dst, _ext in (
  474:                 ((c_sources,), copt_c_sources, ('.dispatch.c',)),
  475:                 ((c_sources, cxx_sources), copt_cxx_sources,
  476:                     ('.dispatch.cpp', '.dispatch.cxx'))
  477:             ):
  478:                 for _src in _srcs:
  479:                     _dst += [
  480:                         _src.pop(_src.index(s))
  481:                         for s in _src[:] if s.endswith(_ext)
  482:                     ]
  483:             copt_baseline_flags = self.compiler_opt.cpu_baseline_flags()
  484:         else:
  485:             copt_macros.append(("NPY_DISABLE_OPTIMIZATION", 1))
  486: 
  487:         c_objects = []
  488:         if copt_cxx_sources:
  489:             log.info("compiling C++ dispatch-able sources")
  490:             c_objects += self.compiler_opt.try_dispatch(
  491:                 copt_cxx_sources,
  492:                 output_dir=output_dir,
  493:                 src_dir=copt_build_src,
  494:                 macros=macros + copt_macros,
  495:                 include_dirs=include_dirs,
  496:                 debug=self.debug,
  497:                 extra_postargs=extra_args + extra_cxxflags,
  498:                 ccompiler=cxx_compiler,
  499:                 **kws
  500:             )
  501:         if copt_c_sources:
  502:             log.info("compiling C dispatch-able sources")
  503:             c_objects += self.compiler_opt.try_dispatch(
  504:                 copt_c_sources,
  505:                 output_dir=output_dir,
  506:                 src_dir=copt_build_src,
  507:                 macros=macros + copt_macros,
  508:                 include_dirs=include_dirs,
  509:                 debug=self.debug,
  510:                 extra_postargs=extra_args + extra_cflags,
  511:                 **kws)
  512:         if c_sources:
  513:             log.info("compiling C sources")
  514:             c_objects += self.compiler.compile(
  515:                 c_sources,
  516:                 output_dir=output_dir,
  517:                 macros=macros + copt_macros,
  518:                 include_dirs=include_dirs,
  519:                 debug=self.debug,
  520:                 extra_postargs=(extra_args + copt_baseline_flags +
  521:                                 extra_cflags),
  522:                 **kws)
  523:         if cxx_sources:
  524:             log.info("compiling C++ sources")
  525:             c_objects += cxx_compiler.compile(
  526:                 cxx_sources,
  527:                 output_dir=output_dir,
  528:                 macros=macros + copt_macros,
  529:                 include_dirs=include_dirs,
  530:                 debug=self.debug,
  531:                 extra_postargs=(extra_args + copt_baseline_flags +
  532:                                 extra_cxxflags),
  533:                 **kws)
  534: 
  535:         extra_postargs = []
  536:         f_objects = []
  537:         if fmodule_sources:
  538:             log.info("compiling Fortran 90 module sources")
  539:             module_dirs = ext.module_dirs[:]
  540:             module_build_dir = os.path.join(
  541:                 self.build_temp, os.path.dirname(
  542:                     self.get_ext_filename(fullname)))
  543: 
  544:             self.mkpath(module_build_dir)
  545:             if fcompiler.module_dir_switch is None:
  546:                 existing_modules = glob('*.mod')
  547:             extra_postargs += fcompiler.module_options(
  548:                 module_dirs, module_build_dir)
  549:             f_objects += fcompiler.compile(fmodule_sources,
  550:                                            output_dir=self.build_temp,
  551:                                            macros=macros,
  552:                                            include_dirs=include_dirs,
  553:                                            debug=self.debug,
  554:                                            extra_postargs=extra_postargs,
  555:                                            depends=ext.depends)
  556: 
  557:             if fcompiler.module_dir_switch is None:
  558:                 for f in glob('*.mod'):
  559:                     if f in existing_modules:
  560:                         continue
  561:                     t = os.path.join(module_build_dir, f)
  562:                     if os.path.abspath(f) == os.path.abspath(t):
  563:                         continue
  564:                     if os.path.isfile(t):
  565:                         os.remove(t)
  566:                     try:
  567:                         self.move_file(f, module_build_dir)
  568:                     except DistutilsFileError:
  569:                         log.warn('failed to move %r to %r' %
  570:                                  (f, module_build_dir))
  571:         if f_sources:
  572:             log.info("compiling Fortran sources")
  573:             f_objects += fcompiler.compile(f_sources,
  574:                                            output_dir=self.build_temp,
  575:                                            macros=macros,
  576:                                            include_dirs=include_dirs,
  577:                                            debug=self.debug,
  578:                                            extra_postargs=extra_postargs,
  579:                                            depends=ext.depends)
  580: 
  581:         if f_objects and not fcompiler.can_ccompiler_link(self.compiler):
  582:             unlinkable_fobjects = f_objects
  583:             objects = c_objects
  584:         else:
  585:             unlinkable_fobjects = []
  586:             objects = c_objects + f_objects
  587: 
  588:         if ext.extra_objects:
  589:             objects.extend(ext.extra_objects)
  590:         extra_args = ext.extra_link_args or []
  591:         libraries = self.get_libraries(ext)[:]
  592:         library_dirs = ext.library_dirs[:]
  593: 
  594:         linker = self.compiler.link_shared_object
  595:         # Always use system linker when using MSVC compiler.
  596:         if self.compiler.compiler_type in ('msvc', 'intelw', 'intelemw'):
  597:             # expand libraries with fcompiler libraries as we are
  598:             # not using fcompiler linker
  599:             self._libs_with_msvc_and_fortran(
  600:                 fcompiler, libraries, library_dirs)
  601:             if ext.runtime_library_dirs:
  602:                 # gcc adds RPATH to the link. On windows, copy the dll into
  603:                 # self.extra_dll_dir instead.
  604:                 for d in ext.runtime_library_dirs:
  605:                     for f in glob(d + '/*.dll'):
  606:                         copy_file(f, self.extra_dll_dir)
  607:                 ext.runtime_library_dirs = []
  608: 
  609:         elif ext.language in ['f77', 'f90'] and fcompiler is not None:
  610:             linker = fcompiler.link_shared_object
  611:         if ext.language == 'c++' and cxx_compiler is not None:
  612:             linker = cxx_compiler.link_shared_object
  613: 
  614:         if fcompiler is not None:
  615:             objects, libraries = self._process_unlinkable_fobjects(
  616:                     objects, libraries,
  617:                     fcompiler, library_dirs,
  618:                     unlinkable_fobjects)
  619: 
  620:         linker(objects, ext_filename,
  621:                libraries=libraries,
  622:                library_dirs=library_dirs,
  623:                runtime_library_dirs=ext.runtime_library_dirs,
  624:                extra_postargs=extra_args,
  625:                export_symbols=self.get_export_symbols(ext),
  626:                debug=self.debug,
  627:                build_temp=self.build_temp,
  628:                target_lang=ext.language)
  629: 
  630:     def _add_dummy_mingwex_sym(self, c_sources):
  631:         build_src = self.get_finalized_command("build_src").build_src
  632:         build_clib = self.get_finalized_command("build_clib").build_clib
  633:         objects = self.compiler.compile([os.path.join(build_src,
  634:                                                       "gfortran_vs2003_hack.c")],
  635:                                         output_dir=self.build_temp)
  636:         self.compiler.create_static_lib(
  637:             objects, "_gfortran_workaround", output_dir=build_clib, debug=self.debug)
  638: 
  639:     def _process_unlinkable_fobjects(self, objects, libraries,
  640:                                      fcompiler, library_dirs,
  641:                                      unlinkable_fobjects):
  642:         libraries = list(libraries)
  643:         objects = list(objects)
  644:         unlinkable_fobjects = list(unlinkable_fobjects)
  645: 
  646:         # Expand possible fake static libraries to objects;
  647:         # make sure to iterate over a copy of the list as
  648:         # "fake" libraries will be removed as they are
  649:         # encountered
  650:         for lib in libraries[:]:
  651:             for libdir in library_dirs:
  652:                 fake_lib = os.path.join(libdir, lib + '.fobjects')
  653:                 if os.path.isfile(fake_lib):
  654:                     # Replace fake static library
  655:                     libraries.remove(lib)
  656:                     with open(fake_lib) as f:
  657:                         unlinkable_fobjects.extend(f.read().splitlines())
  658: 
  659:                     # Expand C objects
  660:                     c_lib = os.path.join(libdir, lib + '.cobjects')
  661:                     with open(c_lib) as f:
  662:                         objects.extend(f.read().splitlines())
  663: 
  664:         # Wrap unlinkable objects to a linkable one
  665:         if unlinkable_fobjects:
  666:             fobjects = [os.path.abspath(obj) for obj in unlinkable_fobjects]
  667:             wrapped = fcompiler.wrap_unlinkable_objects(
  668:                     fobjects, output_dir=self.build_temp,
  669:                     extra_dll_dir=self.extra_dll_dir)
  670:             objects.extend(wrapped)
  671: 
  672:         return objects, libraries
  673: 
  674:     def _libs_with_msvc_and_fortran(self, fcompiler, c_libraries,
  675:                                     c_library_dirs):
  676:         if fcompiler is None:
  677:             return
  678: 
  679:         for libname in c_libraries:
  680:             if libname.startswith('msvc'):
  681:                 continue
  682:             fileexists = False
  683:             for libdir in c_library_dirs or []:
  684:                 libfile = os.path.join(libdir, '%s.lib' % (libname))
  685:                 if os.path.isfile(libfile):
  686:                     fileexists = True
  687:                     break
  688:             if fileexists:
  689:                 continue
  690:             # make g77-compiled static libs available to MSVC
  691:             fileexists = False
  692:             for libdir in c_library_dirs:
  693:                 libfile = os.path.join(libdir, 'lib%s.a' % (libname))
  694:                 if os.path.isfile(libfile):
  695:                     # copy libname.a file to name.lib so that MSVC linker
  696:                     # can find it
  697:                     libfile2 = os.path.join(self.build_temp, libname + '.lib')
  698:                     copy_file(libfile, libfile2)
  699:                     if self.build_temp not in c_library_dirs:
  700:                         c_library_dirs.append(self.build_temp)
  701:                     fileexists = True
  702:                     break
  703:             if fileexists:
  704:                 continue
  705:             log.warn('could not find library %r in directories %s'
  706:                      % (libname, c_library_dirs))
  707: 
  708:         # Always use system linker when using MSVC compiler.
  709:         f_lib_dirs = []
  710:         for dir in fcompiler.library_dirs:
  711:             # correct path when compiling in Cygwin but with normal Win
  712:             # Python
  713:             if dir.startswith('/usr/lib'):
  714:                 try:
  715:                     dir = subprocess.check_output(['cygpath', '-w', dir])
  716:                 except (OSError, subprocess.CalledProcessError):
  717:                     pass
  718:                 else:
  719:                     dir = filepath_from_subprocess_output(dir)
  720:             f_lib_dirs.append(dir)
  721:         c_library_dirs.extend(f_lib_dirs)
  722: 
  723:         # make g77-compiled static libs available to MSVC
  724:         for lib in fcompiler.libraries:
  725:             if not lib.startswith('msvc'):
  726:                 c_libraries.append(lib)
  727:                 p = combine_paths(f_lib_dirs, 'lib' + lib + '.a')
  728:                 if p:
  729:                     dst_name = os.path.join(self.build_temp, lib + '.lib')
  730:                     if not os.path.isfile(dst_name):
  731:                         copy_file(p[0], dst_name)
  732:                     if self.build_temp not in c_library_dirs:
  733:                         c_library_dirs.append(self.build_temp)
  734: 
  735:     def get_source_files(self):
  736:         self.check_extensions_list(self.extensions)
  737:         filenames = []
  738:         for ext in self.extensions:
  739:             filenames.extend(get_ext_source_files(ext))
  740:         return filenames
  741: 
  742:     def get_outputs(self):
  743:         self.check_extensions_list(self.extensions)
  744: 
  745:         outputs = []
  746:         for ext in self.extensions:
  747:             if not ext.sources:
  748:                 continue
  749:             fullname = self.get_ext_fullname(ext.name)
  750:             outputs.append(os.path.join(self.build_lib,
  751:                                         self.get_ext_filename(fullname)))
  752:         return outputs
