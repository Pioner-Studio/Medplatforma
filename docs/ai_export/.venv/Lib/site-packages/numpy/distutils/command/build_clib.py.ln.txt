    1: """ Modified version of build_clib that handles fortran source files.
    2: """
    3: import os
    4: from glob import glob
    5: import shutil
    6: from distutils.command.build_clib import build_clib as old_build_clib
    7: from distutils.errors import DistutilsSetupError, DistutilsError, \
    8:     DistutilsFileError
    9: 
   10: from numpy.distutils import log
   11: from distutils.dep_util import newer_group
   12: from numpy.distutils.misc_util import (
   13:     filter_sources, get_lib_source_files, get_numpy_include_dirs,
   14:     has_cxx_sources, has_f_sources, is_sequence
   15: )
   16: from numpy.distutils.ccompiler_opt import new_ccompiler_opt
   17: 
   18: # Fix Python distutils bug sf #1718574:
   19: _l = old_build_clib.user_options
   20: for _i in range(len(_l)):
   21:     if _l[_i][0] in ['build-clib', 'build-temp']:
   22:         _l[_i] = (_l[_i][0] + '=',) + _l[_i][1:]
   23: #
   24: 
   25: 
   26: class build_clib(old_build_clib):
   27: 
   28:     description = "build C/C++/F libraries used by Python extensions"
   29: 
   30:     user_options = old_build_clib.user_options + [
   31:         ('fcompiler=', None,
   32:          "specify the Fortran compiler type"),
   33:         ('inplace', 'i', 'Build in-place'),
   34:         ('parallel=', 'j',
   35:          "number of parallel jobs"),
   36:         ('warn-error', None,
   37:          "turn all warnings into errors (-Werror)"),
   38:         ('cpu-baseline=', None,
   39:          "specify a list of enabled baseline CPU optimizations"),
   40:         ('cpu-dispatch=', None,
   41:          "specify a list of dispatched CPU optimizations"),
   42:         ('disable-optimization', None,
   43:          "disable CPU optimized code(dispatch,simd,fast...)"),
   44:     ]
   45: 
   46:     boolean_options = old_build_clib.boolean_options + \
   47:     ['inplace', 'warn-error', 'disable-optimization']
   48: 
   49:     def initialize_options(self):
   50:         old_build_clib.initialize_options(self)
   51:         self.fcompiler = None
   52:         self.inplace = 0
   53:         self.parallel = None
   54:         self.warn_error = None
   55:         self.cpu_baseline = None
   56:         self.cpu_dispatch = None
   57:         self.disable_optimization = None
   58: 
   59: 
   60:     def finalize_options(self):
   61:         if self.parallel:
   62:             try:
   63:                 self.parallel = int(self.parallel)
   64:             except ValueError as e:
   65:                 raise ValueError("--parallel/-j argument must be an integer") from e
   66:         old_build_clib.finalize_options(self)
   67:         self.set_undefined_options('build',
   68:                                         ('parallel', 'parallel'),
   69:                                         ('warn_error', 'warn_error'),
   70:                                         ('cpu_baseline', 'cpu_baseline'),
   71:                                         ('cpu_dispatch', 'cpu_dispatch'),
   72:                                         ('disable_optimization', 'disable_optimization')
   73:                                   )
   74: 
   75:     def have_f_sources(self):
   76:         for (lib_name, build_info) in self.libraries:
   77:             if has_f_sources(build_info.get('sources', [])):
   78:                 return True
   79:         return False
   80: 
   81:     def have_cxx_sources(self):
   82:         for (lib_name, build_info) in self.libraries:
   83:             if has_cxx_sources(build_info.get('sources', [])):
   84:                 return True
   85:         return False
   86: 
   87:     def run(self):
   88:         if not self.libraries:
   89:             return
   90: 
   91:         # Make sure that library sources are complete.
   92:         languages = []
   93: 
   94:         # Make sure that extension sources are complete.
   95:         self.run_command('build_src')
   96: 
   97:         for (lib_name, build_info) in self.libraries:
   98:             l = build_info.get('language', None)
   99:             if l and l not in languages:
  100:                 languages.append(l)
  101: 
  102:         from distutils.ccompiler import new_compiler
  103:         self.compiler = new_compiler(compiler=self.compiler,
  104:                                      dry_run=self.dry_run,
  105:                                      force=self.force)
  106:         self.compiler.customize(self.distribution,
  107:                                 need_cxx=self.have_cxx_sources())
  108: 
  109:         if self.warn_error:
  110:             self.compiler.compiler.append('-Werror')
  111:             self.compiler.compiler_so.append('-Werror')
  112: 
  113:         libraries = self.libraries
  114:         self.libraries = None
  115:         self.compiler.customize_cmd(self)
  116:         self.libraries = libraries
  117: 
  118:         self.compiler.show_customization()
  119: 
  120:         if not self.disable_optimization:
  121:             dispatch_hpath = os.path.join("numpy", "distutils", "include", "npy_cpu_dispatch_config.h")
  122:             dispatch_hpath = os.path.join(self.get_finalized_command("build_src").build_src, dispatch_hpath)
  123:             opt_cache_path = os.path.abspath(
  124:                 os.path.join(self.build_temp, 'ccompiler_opt_cache_clib.py')
  125:             )
  126:             if hasattr(self, "compiler_opt"):
  127:                 # By default `CCompilerOpt` update the cache at the exit of
  128:                 # the process, which may lead to duplicate building
  129:                 # (see build_extension()/force_rebuild) if run() called
  130:                 # multiple times within the same os process/thread without
  131:                 # giving the chance the previous instances of `CCompilerOpt`
  132:                 # to update the cache.
  133:                 self.compiler_opt.cache_flush()
  134: 
  135:             self.compiler_opt = new_ccompiler_opt(
  136:                 compiler=self.compiler, dispatch_hpath=dispatch_hpath,
  137:                 cpu_baseline=self.cpu_baseline, cpu_dispatch=self.cpu_dispatch,
  138:                 cache_path=opt_cache_path
  139:             )
  140:             def report(copt):
  141:                 log.info("\n########### CLIB COMPILER OPTIMIZATION ###########")
  142:                 log.info(copt.report(full=True))
  143: 
  144:             import atexit
  145:             atexit.register(report, self.compiler_opt)
  146: 
  147:         if self.have_f_sources():
  148:             from numpy.distutils.fcompiler import new_fcompiler
  149:             self._f_compiler = new_fcompiler(compiler=self.fcompiler,
  150:                                              verbose=self.verbose,
  151:                                              dry_run=self.dry_run,
  152:                                              force=self.force,
  153:                                              requiref90='f90' in languages,
  154:                                              c_compiler=self.compiler)
  155:             if self._f_compiler is not None:
  156:                 self._f_compiler.customize(self.distribution)
  157: 
  158:                 libraries = self.libraries
  159:                 self.libraries = None
  160:                 self._f_compiler.customize_cmd(self)
  161:                 self.libraries = libraries
  162: 
  163:                 self._f_compiler.show_customization()
  164:         else:
  165:             self._f_compiler = None
  166: 
  167:         self.build_libraries(self.libraries)
  168: 
  169:         if self.inplace:
  170:             for l in self.distribution.installed_libraries:
  171:                 libname = self.compiler.library_filename(l.name)
  172:                 source = os.path.join(self.build_clib, libname)
  173:                 target = os.path.join(l.target_dir, libname)
  174:                 self.mkpath(l.target_dir)
  175:                 shutil.copy(source, target)
  176: 
  177:     def get_source_files(self):
  178:         self.check_library_list(self.libraries)
  179:         filenames = []
  180:         for lib in self.libraries:
  181:             filenames.extend(get_lib_source_files(lib))
  182:         return filenames
  183: 
  184:     def build_libraries(self, libraries):
  185:         for (lib_name, build_info) in libraries:
  186:             self.build_a_library(build_info, lib_name, libraries)
  187: 
  188:     def assemble_flags(self, in_flags):
  189:         """ Assemble flags from flag list
  190: 
  191:         Parameters
  192:         ----------
  193:         in_flags : None or sequence
  194:             None corresponds to empty list.  Sequence elements can be strings
  195:             or callables that return lists of strings. Callable takes `self` as
  196:             single parameter.
  197: 
  198:         Returns
  199:         -------
  200:         out_flags : list
  201:         """
  202:         if in_flags is None:
  203:             return []
  204:         out_flags = []
  205:         for in_flag in in_flags:
  206:             if callable(in_flag):
  207:                 out_flags += in_flag(self)
  208:             else:
  209:                 out_flags.append(in_flag)
  210:         return out_flags
  211: 
  212:     def build_a_library(self, build_info, lib_name, libraries):
  213:         # default compilers
  214:         compiler = self.compiler
  215:         fcompiler = self._f_compiler
  216: 
  217:         sources = build_info.get('sources')
  218:         if sources is None or not is_sequence(sources):
  219:             raise DistutilsSetupError(("in 'libraries' option (library '%s'), "
  220:                                        "'sources' must be present and must be "
  221:                                        "a list of source filenames") % lib_name)
  222:         sources = list(sources)
  223: 
  224:         c_sources, cxx_sources, f_sources, fmodule_sources \
  225:             = filter_sources(sources)
  226:         requiref90 = not not fmodule_sources or \
  227:             build_info.get('language', 'c') == 'f90'
  228: 
  229:         # save source type information so that build_ext can use it.
  230:         source_languages = []
  231:         if c_sources:
  232:             source_languages.append('c')
  233:         if cxx_sources:
  234:             source_languages.append('c++')
  235:         if requiref90:
  236:             source_languages.append('f90')
  237:         elif f_sources:
  238:             source_languages.append('f77')
  239:         build_info['source_languages'] = source_languages
  240: 
  241:         lib_file = compiler.library_filename(lib_name,
  242:                                              output_dir=self.build_clib)
  243:         depends = sources + build_info.get('depends', [])
  244: 
  245:         force_rebuild = self.force
  246:         if not self.disable_optimization and not self.compiler_opt.is_cached():
  247:             log.debug("Detected changes on compiler optimizations")
  248:             force_rebuild = True
  249:         if not (force_rebuild or newer_group(depends, lib_file, 'newer')):
  250:             log.debug("skipping '%s' library (up-to-date)", lib_name)
  251:             return
  252:         else:
  253:             log.info("building '%s' library", lib_name)
  254: 
  255:         config_fc = build_info.get('config_fc', {})
  256:         if fcompiler is not None and config_fc:
  257:             log.info('using additional config_fc from setup script '
  258:                      'for fortran compiler: %s'
  259:                      % (config_fc,))
  260:             from numpy.distutils.fcompiler import new_fcompiler
  261:             fcompiler = new_fcompiler(compiler=fcompiler.compiler_type,
  262:                                       verbose=self.verbose,
  263:                                       dry_run=self.dry_run,
  264:                                       force=self.force,
  265:                                       requiref90=requiref90,
  266:                                       c_compiler=self.compiler)
  267:             if fcompiler is not None:
  268:                 dist = self.distribution
  269:                 base_config_fc = dist.get_option_dict('config_fc').copy()
  270:                 base_config_fc.update(config_fc)
  271:                 fcompiler.customize(base_config_fc)
  272: 
  273:         # check availability of Fortran compilers
  274:         if (f_sources or fmodule_sources) and fcompiler is None:
  275:             raise DistutilsError("library %s has Fortran sources"
  276:                                  " but no Fortran compiler found" % (lib_name))
  277: 
  278:         if fcompiler is not None:
  279:             fcompiler.extra_f77_compile_args = build_info.get(
  280:                 'extra_f77_compile_args') or []
  281:             fcompiler.extra_f90_compile_args = build_info.get(
  282:                 'extra_f90_compile_args') or []
  283: 
  284:         macros = build_info.get('macros')
  285:         if macros is None:
  286:             macros = []
  287:         include_dirs = build_info.get('include_dirs')
  288:         if include_dirs is None:
  289:             include_dirs = []
  290:         # Flags can be strings, or callables that return a list of strings.
  291:         extra_postargs = self.assemble_flags(
  292:             build_info.get('extra_compiler_args'))
  293:         extra_cflags = self.assemble_flags(
  294:             build_info.get('extra_cflags'))
  295:         extra_cxxflags = self.assemble_flags(
  296:             build_info.get('extra_cxxflags'))
  297: 
  298:         include_dirs.extend(get_numpy_include_dirs())
  299:         # where compiled F90 module files are:
  300:         module_dirs = build_info.get('module_dirs') or []
  301:         module_build_dir = os.path.dirname(lib_file)
  302:         if requiref90:
  303:             self.mkpath(module_build_dir)
  304: 
  305:         if compiler.compiler_type == 'msvc':
  306:             # this hack works around the msvc compiler attributes
  307:             # problem, msvc uses its own convention :(
  308:             c_sources += cxx_sources
  309:             cxx_sources = []
  310:             extra_cflags += extra_cxxflags
  311: 
  312:         # filtering C dispatch-table sources when optimization is not disabled,
  313:         # otherwise treated as normal sources.
  314:         copt_c_sources = []
  315:         copt_cxx_sources = []
  316:         copt_baseline_flags = []
  317:         copt_macros = []
  318:         if not self.disable_optimization:
  319:             bsrc_dir = self.get_finalized_command("build_src").build_src
  320:             dispatch_hpath = os.path.join("numpy", "distutils", "include")
  321:             dispatch_hpath = os.path.join(bsrc_dir, dispatch_hpath)
  322:             include_dirs.append(dispatch_hpath)
  323:             # copt_build_src = None if self.inplace else bsrc_dir
  324:             copt_build_src = bsrc_dir
  325:             for _srcs, _dst, _ext in (
  326:                 ((c_sources,), copt_c_sources, ('.dispatch.c',)),
  327:                 ((c_sources, cxx_sources), copt_cxx_sources,
  328:                     ('.dispatch.cpp', '.dispatch.cxx'))
  329:             ):
  330:                 for _src in _srcs:
  331:                     _dst += [
  332:                         _src.pop(_src.index(s))
  333:                         for s in _src[:] if s.endswith(_ext)
  334:                     ]
  335:             copt_baseline_flags = self.compiler_opt.cpu_baseline_flags()
  336:         else:
  337:             copt_macros.append(("NPY_DISABLE_OPTIMIZATION", 1))
  338: 
  339:         objects = []
  340:         if copt_cxx_sources:
  341:             log.info("compiling C++ dispatch-able sources")
  342:             objects += self.compiler_opt.try_dispatch(
  343:                 copt_c_sources,
  344:                 output_dir=self.build_temp,
  345:                 src_dir=copt_build_src,
  346:                 macros=macros + copt_macros,
  347:                 include_dirs=include_dirs,
  348:                 debug=self.debug,
  349:                 extra_postargs=extra_postargs + extra_cxxflags,
  350:                 ccompiler=cxx_compiler
  351:             )
  352: 
  353:         if copt_c_sources:
  354:             log.info("compiling C dispatch-able sources")
  355:             objects += self.compiler_opt.try_dispatch(
  356:                 copt_c_sources,
  357:                 output_dir=self.build_temp,
  358:                 src_dir=copt_build_src,
  359:                 macros=macros + copt_macros,
  360:                 include_dirs=include_dirs,
  361:                 debug=self.debug,
  362:                 extra_postargs=extra_postargs + extra_cflags)
  363: 
  364:         if c_sources:
  365:             log.info("compiling C sources")
  366:             objects += compiler.compile(
  367:                 c_sources,
  368:                 output_dir=self.build_temp,
  369:                 macros=macros + copt_macros,
  370:                 include_dirs=include_dirs,
  371:                 debug=self.debug,
  372:                 extra_postargs=(extra_postargs +
  373:                                 copt_baseline_flags +
  374:                                 extra_cflags))
  375: 
  376:         if cxx_sources:
  377:             log.info("compiling C++ sources")
  378:             cxx_compiler = compiler.cxx_compiler()
  379:             cxx_objects = cxx_compiler.compile(
  380:                 cxx_sources,
  381:                 output_dir=self.build_temp,
  382:                 macros=macros + copt_macros,
  383:                 include_dirs=include_dirs,
  384:                 debug=self.debug,
  385:                 extra_postargs=(extra_postargs +
  386:                                 copt_baseline_flags +
  387:                                 extra_cxxflags))
  388:             objects.extend(cxx_objects)
  389: 
  390:         if f_sources or fmodule_sources:
  391:             extra_postargs = []
  392:             f_objects = []
  393: 
  394:             if requiref90:
  395:                 if fcompiler.module_dir_switch is None:
  396:                     existing_modules = glob('*.mod')
  397:                 extra_postargs += fcompiler.module_options(
  398:                     module_dirs, module_build_dir)
  399: 
  400:             if fmodule_sources:
  401:                 log.info("compiling Fortran 90 module sources")
  402:                 f_objects += fcompiler.compile(fmodule_sources,
  403:                                                output_dir=self.build_temp,
  404:                                                macros=macros,
  405:                                                include_dirs=include_dirs,
  406:                                                debug=self.debug,
  407:                                                extra_postargs=extra_postargs)
  408: 
  409:             if requiref90 and self._f_compiler.module_dir_switch is None:
  410:                 # move new compiled F90 module files to module_build_dir
  411:                 for f in glob('*.mod'):
  412:                     if f in existing_modules:
  413:                         continue
  414:                     t = os.path.join(module_build_dir, f)
  415:                     if os.path.abspath(f) == os.path.abspath(t):
  416:                         continue
  417:                     if os.path.isfile(t):
  418:                         os.remove(t)
  419:                     try:
  420:                         self.move_file(f, module_build_dir)
  421:                     except DistutilsFileError:
  422:                         log.warn('failed to move %r to %r'
  423:                                  % (f, module_build_dir))
  424: 
  425:             if f_sources:
  426:                 log.info("compiling Fortran sources")
  427:                 f_objects += fcompiler.compile(f_sources,
  428:                                                output_dir=self.build_temp,
  429:                                                macros=macros,
  430:                                                include_dirs=include_dirs,
  431:                                                debug=self.debug,
  432:                                                extra_postargs=extra_postargs)
  433:         else:
  434:             f_objects = []
  435: 
  436:         if f_objects and not fcompiler.can_ccompiler_link(compiler):
  437:             # Default linker cannot link Fortran object files, and results
  438:             # need to be wrapped later. Instead of creating a real static
  439:             # library, just keep track of the object files.
  440:             listfn = os.path.join(self.build_clib,
  441:                                   lib_name + '.fobjects')
  442:             with open(listfn, 'w') as f:
  443:                 f.write("\n".join(os.path.abspath(obj) for obj in f_objects))
  444: 
  445:             listfn = os.path.join(self.build_clib,
  446:                                   lib_name + '.cobjects')
  447:             with open(listfn, 'w') as f:
  448:                 f.write("\n".join(os.path.abspath(obj) for obj in objects))
  449: 
  450:             # create empty "library" file for dependency tracking
  451:             lib_fname = os.path.join(self.build_clib,
  452:                                      lib_name + compiler.static_lib_extension)
  453:             with open(lib_fname, 'wb') as f:
  454:                 pass
  455:         else:
  456:             # assume that default linker is suitable for
  457:             # linking Fortran object files
  458:             objects.extend(f_objects)
  459:             compiler.create_static_lib(objects, lib_name,
  460:                                        output_dir=self.build_clib,
  461:                                        debug=self.debug)
  462: 
  463:         # fix library dependencies
  464:         clib_libraries = build_info.get('libraries', [])
  465:         for lname, binfo in libraries:
  466:             if lname in clib_libraries:
  467:                 clib_libraries.extend(binfo.get('libraries', []))
  468:         if clib_libraries:
  469:             build_info['libraries'] = clib_libraries
