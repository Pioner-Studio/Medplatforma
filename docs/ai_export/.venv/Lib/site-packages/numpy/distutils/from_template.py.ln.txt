    1: #!/usr/bin/env python3
    2: """
    3: 
    4: process_file(filename)
    5: 
    6:   takes templated file .xxx.src and produces .xxx file where .xxx
    7:   is .pyf .f90 or .f using the following template rules:
    8: 
    9:   '<..>' denotes a template.
   10: 
   11:   All function and subroutine blocks in a source file with names that
   12:   contain '<..>' will be replicated according to the rules in '<..>'.
   13: 
   14:   The number of comma-separated words in '<..>' will determine the number of
   15:   replicates.
   16: 
   17:   '<..>' may have two different forms, named and short. For example,
   18: 
   19:   named:
   20:    <p=d,s,z,c> where anywhere inside a block '<p>' will be replaced with
   21:    'd', 's', 'z', and 'c' for each replicate of the block.
   22: 
   23:    <_c>  is already defined: <_c=s,d,c,z>
   24:    <_t>  is already defined: <_t=real,double precision,complex,double complex>
   25: 
   26:   short:
   27:    <s,d,c,z>, a short form of the named, useful when no <p> appears inside
   28:    a block.
   29: 
   30:   In general, '<..>' contains a comma separated list of arbitrary
   31:   expressions. If these expression must contain a comma|leftarrow|rightarrow,
   32:   then prepend the comma|leftarrow|rightarrow with a backslash.
   33: 
   34:   If an expression matches '\\<index>' then it will be replaced
   35:   by <index>-th expression.
   36: 
   37:   Note that all '<..>' forms in a block must have the same number of
   38:   comma-separated entries.
   39: 
   40:  Predefined named template rules:
   41:   <prefix=s,d,c,z>
   42:   <ftype=real,double precision,complex,double complex>
   43:   <ftypereal=real,double precision,\\0,\\1>
   44:   <ctype=float,double,complex_float,complex_double>
   45:   <ctypereal=float,double,\\0,\\1>
   46: 
   47: """
   48: __all__ = ['process_str', 'process_file']
   49: 
   50: import os
   51: import sys
   52: import re
   53: 
   54: routine_start_re = re.compile(r'(\n|\A)((     (\$|\*))|)\s*(subroutine|function)\b', re.I)
   55: routine_end_re = re.compile(r'\n\s*end\s*(subroutine|function)\b.*(\n|\Z)', re.I)
   56: function_start_re = re.compile(r'\n     (\$|\*)\s*function\b', re.I)
   57: 
   58: def parse_structure(astr):
   59:     """ Return a list of tuples for each function or subroutine each
   60:     tuple is the start and end of a subroutine or function to be
   61:     expanded.
   62:     """
   63: 
   64:     spanlist = []
   65:     ind = 0
   66:     while True:
   67:         m = routine_start_re.search(astr, ind)
   68:         if m is None:
   69:             break
   70:         start = m.start()
   71:         if function_start_re.match(astr, start, m.end()):
   72:             while True:
   73:                 i = astr.rfind('\n', ind, start)
   74:                 if i==-1:
   75:                     break
   76:                 start = i
   77:                 if astr[i:i+7]!='\n     $':
   78:                     break
   79:         start += 1
   80:         m = routine_end_re.search(astr, m.end())
   81:         ind = end = m and m.end()-1 or len(astr)
   82:         spanlist.append((start, end))
   83:     return spanlist
   84: 
   85: template_re = re.compile(r"<\s*(\w[\w\d]*)\s*>")
   86: named_re = re.compile(r"<\s*(\w[\w\d]*)\s*=\s*(.*?)\s*>")
   87: list_re = re.compile(r"<\s*((.*?))\s*>")
   88: 
   89: def find_repl_patterns(astr):
   90:     reps = named_re.findall(astr)
   91:     names = {}
   92:     for rep in reps:
   93:         name = rep[0].strip() or unique_key(names)
   94:         repl = rep[1].replace(r'\,', '@comma@')
   95:         thelist = conv(repl)
   96:         names[name] = thelist
   97:     return names
   98: 
   99: def find_and_remove_repl_patterns(astr):
  100:     names = find_repl_patterns(astr)
  101:     astr = re.subn(named_re, '', astr)[0]
  102:     return astr, names
  103: 
  104: item_re = re.compile(r"\A\\(?P<index>\d+)\Z")
  105: def conv(astr):
  106:     b = astr.split(',')
  107:     l = [x.strip() for x in b]
  108:     for i in range(len(l)):
  109:         m = item_re.match(l[i])
  110:         if m:
  111:             j = int(m.group('index'))
  112:             l[i] = l[j]
  113:     return ','.join(l)
  114: 
  115: def unique_key(adict):
  116:     """ Obtain a unique key given a dictionary."""
  117:     allkeys = list(adict.keys())
  118:     done = False
  119:     n = 1
  120:     while not done:
  121:         newkey = '__l%s' % (n)
  122:         if newkey in allkeys:
  123:             n += 1
  124:         else:
  125:             done = True
  126:     return newkey
  127: 
  128: 
  129: template_name_re = re.compile(r'\A\s*(\w[\w\d]*)\s*\Z')
  130: def expand_sub(substr, names):
  131:     substr = substr.replace(r'\>', '@rightarrow@')
  132:     substr = substr.replace(r'\<', '@leftarrow@')
  133:     lnames = find_repl_patterns(substr)
  134:     substr = named_re.sub(r"<\1>", substr)  # get rid of definition templates
  135: 
  136:     def listrepl(mobj):
  137:         thelist = conv(mobj.group(1).replace(r'\,', '@comma@'))
  138:         if template_name_re.match(thelist):
  139:             return "<%s>" % (thelist)
  140:         name = None
  141:         for key in lnames.keys():    # see if list is already in dictionary
  142:             if lnames[key] == thelist:
  143:                 name = key
  144:         if name is None:      # this list is not in the dictionary yet
  145:             name = unique_key(lnames)
  146:             lnames[name] = thelist
  147:         return "<%s>" % name
  148: 
  149:     substr = list_re.sub(listrepl, substr) # convert all lists to named templates
  150:                                            # newnames are constructed as needed
  151: 
  152:     numsubs = None
  153:     base_rule = None
  154:     rules = {}
  155:     for r in template_re.findall(substr):
  156:         if r not in rules:
  157:             thelist = lnames.get(r, names.get(r, None))
  158:             if thelist is None:
  159:                 raise ValueError('No replicates found for <%s>' % (r))
  160:             if r not in names and not thelist.startswith('_'):
  161:                 names[r] = thelist
  162:             rule = [i.replace('@comma@', ',') for i in thelist.split(',')]
  163:             num = len(rule)
  164: 
  165:             if numsubs is None:
  166:                 numsubs = num
  167:                 rules[r] = rule
  168:                 base_rule = r
  169:             elif num == numsubs:
  170:                 rules[r] = rule
  171:             else:
  172:                 print("Mismatch in number of replacements (base <%s=%s>)"
  173:                       " for <%s=%s>. Ignoring." %
  174:                       (base_rule, ','.join(rules[base_rule]), r, thelist))
  175:     if not rules:
  176:         return substr
  177: 
  178:     def namerepl(mobj):
  179:         name = mobj.group(1)
  180:         return rules.get(name, (k+1)*[name])[k]
  181: 
  182:     newstr = ''
  183:     for k in range(numsubs):
  184:         newstr += template_re.sub(namerepl, substr) + '\n\n'
  185: 
  186:     newstr = newstr.replace('@rightarrow@', '>')
  187:     newstr = newstr.replace('@leftarrow@', '<')
  188:     return newstr
  189: 
  190: def process_str(allstr):
  191:     newstr = allstr
  192:     writestr = ''
  193: 
  194:     struct = parse_structure(newstr)
  195: 
  196:     oldend = 0
  197:     names = {}
  198:     names.update(_special_names)
  199:     for sub in struct:
  200:         cleanedstr, defs = find_and_remove_repl_patterns(newstr[oldend:sub[0]])
  201:         writestr += cleanedstr
  202:         names.update(defs)
  203:         writestr += expand_sub(newstr[sub[0]:sub[1]], names)
  204:         oldend =  sub[1]
  205:     writestr += newstr[oldend:]
  206: 
  207:     return writestr
  208: 
  209: include_src_re = re.compile(r"(\n|\A)\s*include\s*['\"](?P<name>[\w\d./\\]+\.src)['\"]", re.I)
  210: 
  211: def resolve_includes(source):
  212:     d = os.path.dirname(source)
  213:     with open(source) as fid:
  214:         lines = []
  215:         for line in fid:
  216:             m = include_src_re.match(line)
  217:             if m:
  218:                 fn = m.group('name')
  219:                 if not os.path.isabs(fn):
  220:                     fn = os.path.join(d, fn)
  221:                 if os.path.isfile(fn):
  222:                     lines.extend(resolve_includes(fn))
  223:                 else:
  224:                     lines.append(line)
  225:             else:
  226:                 lines.append(line)
  227:     return lines
  228: 
  229: def process_file(source):
  230:     lines = resolve_includes(source)
  231:     return process_str(''.join(lines))
  232: 
  233: _special_names = find_repl_patterns('''
  234: <_c=s,d,c,z>
  235: <_t=real,double precision,complex,double complex>
  236: <prefix=s,d,c,z>
  237: <ftype=real,double precision,complex,double complex>
  238: <ctype=float,double,complex_float,complex_double>
  239: <ftypereal=real,double precision,\\0,\\1>
  240: <ctypereal=float,double,\\0,\\1>
  241: ''')
  242: 
  243: def main():
  244:     try:
  245:         file = sys.argv[1]
  246:     except IndexError:
  247:         fid = sys.stdin
  248:         outfile = sys.stdout
  249:     else:
  250:         fid = open(file, 'r')
  251:         (base, ext) = os.path.splitext(file)
  252:         newname = base
  253:         outfile = open(newname, 'w')
  254: 
  255:     allstr = fid.read()
  256:     writestr = process_str(allstr)
  257:     outfile.write(writestr)
  258: 
  259: 
  260: if __name__ == "__main__":
  261:     main()
