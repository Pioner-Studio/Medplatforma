    1: import os
    2: import re
    3: import sys
    4: import copy
    5: import glob
    6: import atexit
    7: import tempfile
    8: import subprocess
    9: import shutil
   10: import multiprocessing
   11: import textwrap
   12: import importlib.util
   13: from threading import local as tlocal
   14: from functools import reduce
   15: 
   16: import distutils
   17: from distutils.errors import DistutilsError
   18: 
   19: # stores temporary directory of each thread to only create one per thread
   20: _tdata = tlocal()
   21: 
   22: # store all created temporary directories so they can be deleted on exit
   23: _tmpdirs = []
   24: def clean_up_temporary_directory():
   25:     if _tmpdirs is not None:
   26:         for d in _tmpdirs:
   27:             try:
   28:                 shutil.rmtree(d)
   29:             except OSError:
   30:                 pass
   31: 
   32: atexit.register(clean_up_temporary_directory)
   33: 
   34: __all__ = ['Configuration', 'get_numpy_include_dirs', 'default_config_dict',
   35:            'dict_append', 'appendpath', 'generate_config_py',
   36:            'get_cmd', 'allpath', 'get_mathlibs',
   37:            'terminal_has_colors', 'red_text', 'green_text', 'yellow_text',
   38:            'blue_text', 'cyan_text', 'cyg2win32', 'mingw32', 'all_strings',
   39:            'has_f_sources', 'has_cxx_sources', 'filter_sources',
   40:            'get_dependencies', 'is_local_src_dir', 'get_ext_source_files',
   41:            'get_script_files', 'get_lib_source_files', 'get_data_files',
   42:            'dot_join', 'get_frame', 'minrelpath', 'njoin',
   43:            'is_sequence', 'is_string', 'as_list', 'gpaths', 'get_language',
   44:            'get_build_architecture', 'get_info', 'get_pkg_info',
   45:            'get_num_build_jobs', 'sanitize_cxx_flags',
   46:            'exec_mod_from_location']
   47: 
   48: class InstallableLib:
   49:     """
   50:     Container to hold information on an installable library.
   51: 
   52:     Parameters
   53:     ----------
   54:     name : str
   55:         Name of the installed library.
   56:     build_info : dict
   57:         Dictionary holding build information.
   58:     target_dir : str
   59:         Absolute path specifying where to install the library.
   60: 
   61:     See Also
   62:     --------
   63:     Configuration.add_installed_library
   64: 
   65:     Notes
   66:     -----
   67:     The three parameters are stored as attributes with the same names.
   68: 
   69:     """
   70:     def __init__(self, name, build_info, target_dir):
   71:         self.name = name
   72:         self.build_info = build_info
   73:         self.target_dir = target_dir
   74: 
   75: 
   76: def get_num_build_jobs():
   77:     """
   78:     Get number of parallel build jobs set by the --parallel command line
   79:     argument of setup.py
   80:     If the command did not receive a setting the environment variable
   81:     NPY_NUM_BUILD_JOBS is checked. If that is unset, return the number of
   82:     processors on the system, with a maximum of 8 (to prevent
   83:     overloading the system if there a lot of CPUs).
   84: 
   85:     Returns
   86:     -------
   87:     out : int
   88:         number of parallel jobs that can be run
   89: 
   90:     """
   91:     from numpy.distutils.core import get_distribution
   92:     try:
   93:         cpu_count = len(os.sched_getaffinity(0))
   94:     except AttributeError:
   95:         cpu_count = multiprocessing.cpu_count()
   96:     cpu_count = min(cpu_count, 8)
   97:     envjobs = int(os.environ.get("NPY_NUM_BUILD_JOBS", cpu_count))
   98:     dist = get_distribution()
   99:     # may be None during configuration
  100:     if dist is None:
  101:         return envjobs
  102: 
  103:     # any of these three may have the job set, take the largest
  104:     cmdattr = (getattr(dist.get_command_obj('build'), 'parallel', None),
  105:                getattr(dist.get_command_obj('build_ext'), 'parallel', None),
  106:                getattr(dist.get_command_obj('build_clib'), 'parallel', None))
  107:     if all(x is None for x in cmdattr):
  108:         return envjobs
  109:     else:
  110:         return max(x for x in cmdattr if x is not None)
  111: 
  112: def quote_args(args):
  113:     """Quote list of arguments.
  114: 
  115:     .. deprecated:: 1.22.
  116:     """
  117:     import warnings
  118:     warnings.warn('"quote_args" is deprecated.',
  119:                   DeprecationWarning, stacklevel=2)
  120:     # don't used _nt_quote_args as it does not check if
  121:     # args items already have quotes or not.
  122:     args = list(args)
  123:     for i in range(len(args)):
  124:         a = args[i]
  125:         if ' ' in a and a[0] not in '"\'':
  126:             args[i] = '"%s"' % (a)
  127:     return args
  128: 
  129: def allpath(name):
  130:     "Convert a /-separated pathname to one using the OS's path separator."
  131:     split = name.split('/')
  132:     return os.path.join(*split)
  133: 
  134: def rel_path(path, parent_path):
  135:     """Return path relative to parent_path."""
  136:     # Use realpath to avoid issues with symlinked dirs (see gh-7707)
  137:     pd = os.path.realpath(os.path.abspath(parent_path))
  138:     apath = os.path.realpath(os.path.abspath(path))
  139:     if len(apath) < len(pd):
  140:         return path
  141:     if apath == pd:
  142:         return ''
  143:     if pd == apath[:len(pd)]:
  144:         assert apath[len(pd)] in [os.sep], repr((path, apath[len(pd)]))
  145:         path = apath[len(pd)+1:]
  146:     return path
  147: 
  148: def get_path_from_frame(frame, parent_path=None):
  149:     """Return path of the module given a frame object from the call stack.
  150: 
  151:     Returned path is relative to parent_path when given,
  152:     otherwise it is absolute path.
  153:     """
  154: 
  155:     # First, try to find if the file name is in the frame.
  156:     try:
  157:         caller_file = eval('__file__', frame.f_globals, frame.f_locals)
  158:         d = os.path.dirname(os.path.abspath(caller_file))
  159:     except NameError:
  160:         # __file__ is not defined, so let's try __name__. We try this second
  161:         # because setuptools spoofs __name__ to be '__main__' even though
  162:         # sys.modules['__main__'] might be something else, like easy_install(1).
  163:         caller_name = eval('__name__', frame.f_globals, frame.f_locals)
  164:         __import__(caller_name)
  165:         mod = sys.modules[caller_name]
  166:         if hasattr(mod, '__file__'):
  167:             d = os.path.dirname(os.path.abspath(mod.__file__))
  168:         else:
  169:             # we're probably running setup.py as execfile("setup.py")
  170:             # (likely we're building an egg)
  171:             d = os.path.abspath('.')
  172: 
  173:     if parent_path is not None:
  174:         d = rel_path(d, parent_path)
  175: 
  176:     return d or '.'
  177: 
  178: def njoin(*path):
  179:     """Join two or more pathname components +
  180:     - convert a /-separated pathname to one using the OS's path separator.
  181:     - resolve `..` and `.` from path.
  182: 
  183:     Either passing n arguments as in njoin('a','b'), or a sequence
  184:     of n names as in njoin(['a','b']) is handled, or a mixture of such arguments.
  185:     """
  186:     paths = []
  187:     for p in path:
  188:         if is_sequence(p):
  189:             # njoin(['a', 'b'], 'c')
  190:             paths.append(njoin(*p))
  191:         else:
  192:             assert is_string(p)
  193:             paths.append(p)
  194:     path = paths
  195:     if not path:
  196:         # njoin()
  197:         joined = ''
  198:     else:
  199:         # njoin('a', 'b')
  200:         joined = os.path.join(*path)
  201:     if os.path.sep != '/':
  202:         joined = joined.replace('/', os.path.sep)
  203:     return minrelpath(joined)
  204: 
  205: def get_mathlibs(path=None):
  206:     """Return the MATHLIB line from numpyconfig.h
  207:     """
  208:     if path is not None:
  209:         config_file = os.path.join(path, '_numpyconfig.h')
  210:     else:
  211:         # Look for the file in each of the numpy include directories.
  212:         dirs = get_numpy_include_dirs()
  213:         for path in dirs:
  214:             fn = os.path.join(path, '_numpyconfig.h')
  215:             if os.path.exists(fn):
  216:                 config_file = fn
  217:                 break
  218:         else:
  219:             raise DistutilsError('_numpyconfig.h not found in numpy include '
  220:                 'dirs %r' % (dirs,))
  221: 
  222:     with open(config_file) as fid:
  223:         mathlibs = []
  224:         s = '#define MATHLIB'
  225:         for line in fid:
  226:             if line.startswith(s):
  227:                 value = line[len(s):].strip()
  228:                 if value:
  229:                     mathlibs.extend(value.split(','))
  230:     return mathlibs
  231: 
  232: def minrelpath(path):
  233:     """Resolve `..` and '.' from path.
  234:     """
  235:     if not is_string(path):
  236:         return path
  237:     if '.' not in path:
  238:         return path
  239:     l = path.split(os.sep)
  240:     while l:
  241:         try:
  242:             i = l.index('.', 1)
  243:         except ValueError:
  244:             break
  245:         del l[i]
  246:     j = 1
  247:     while l:
  248:         try:
  249:             i = l.index('..', j)
  250:         except ValueError:
  251:             break
  252:         if l[i-1]=='..':
  253:             j += 1
  254:         else:
  255:             del l[i], l[i-1]
  256:             j = 1
  257:     if not l:
  258:         return ''
  259:     return os.sep.join(l)
  260: 
  261: def sorted_glob(fileglob):
  262:     """sorts output of python glob for https://bugs.python.org/issue30461
  263:     to allow extensions to have reproducible build results"""
  264:     return sorted(glob.glob(fileglob))
  265: 
  266: def _fix_paths(paths, local_path, include_non_existing):
  267:     assert is_sequence(paths), repr(type(paths))
  268:     new_paths = []
  269:     assert not is_string(paths), repr(paths)
  270:     for n in paths:
  271:         if is_string(n):
  272:             if '*' in n or '?' in n:
  273:                 p = sorted_glob(n)
  274:                 p2 = sorted_glob(njoin(local_path, n))
  275:                 if p2:
  276:                     new_paths.extend(p2)
  277:                 elif p:
  278:                     new_paths.extend(p)
  279:                 else:
  280:                     if include_non_existing:
  281:                         new_paths.append(n)
  282:                     print('could not resolve pattern in %r: %r' %
  283:                             (local_path, n))
  284:             else:
  285:                 n2 = njoin(local_path, n)
  286:                 if os.path.exists(n2):
  287:                     new_paths.append(n2)
  288:                 else:
  289:                     if os.path.exists(n):
  290:                         new_paths.append(n)
  291:                     elif include_non_existing:
  292:                         new_paths.append(n)
  293:                     if not os.path.exists(n):
  294:                         print('non-existing path in %r: %r' %
  295:                                 (local_path, n))
  296: 
  297:         elif is_sequence(n):
  298:             new_paths.extend(_fix_paths(n, local_path, include_non_existing))
  299:         else:
  300:             new_paths.append(n)
  301:     return [minrelpath(p) for p in new_paths]
  302: 
  303: def gpaths(paths, local_path='', include_non_existing=True):
  304:     """Apply glob to paths and prepend local_path if needed.
  305:     """
  306:     if is_string(paths):
  307:         paths = (paths,)
  308:     return _fix_paths(paths, local_path, include_non_existing)
  309: 
  310: def make_temp_file(suffix='', prefix='', text=True):
  311:     if not hasattr(_tdata, 'tempdir'):
  312:         _tdata.tempdir = tempfile.mkdtemp()
  313:         _tmpdirs.append(_tdata.tempdir)
  314:     fid, name = tempfile.mkstemp(suffix=suffix,
  315:                                  prefix=prefix,
  316:                                  dir=_tdata.tempdir,
  317:                                  text=text)
  318:     fo = os.fdopen(fid, 'w')
  319:     return fo, name
  320: 
  321: # Hooks for colored terminal output.
  322: # See also https://web.archive.org/web/20100314204946/http://www.livinglogic.de/Python/ansistyle
  323: def terminal_has_colors():
  324:     if sys.platform=='cygwin' and 'USE_COLOR' not in os.environ:
  325:         # Avoid importing curses that causes illegal operation
  326:         # with a message:
  327:         #  PYTHON2 caused an invalid page fault in
  328:         #  module CYGNURSES7.DLL as 015f:18bbfc28
  329:         # Details: Python 2.3.3 [GCC 3.3.1 (cygming special)]
  330:         #          ssh to Win32 machine from debian
  331:         #          curses.version is 2.2
  332:         #          CYGWIN_98-4.10, release 1.5.7(0.109/3/2))
  333:         return 0
  334:     if hasattr(sys.stdout, 'isatty') and sys.stdout.isatty():
  335:         try:
  336:             import curses
  337:             curses.setupterm()
  338:             if (curses.tigetnum("colors") >= 0
  339:                 and curses.tigetnum("pairs") >= 0
  340:                 and ((curses.tigetstr("setf") is not None
  341:                       and curses.tigetstr("setb") is not None)
  342:                      or (curses.tigetstr("setaf") is not None
  343:                          and curses.tigetstr("setab") is not None)
  344:                      or curses.tigetstr("scp") is not None)):
  345:                 return 1
  346:         except Exception:
  347:             pass
  348:     return 0
  349: 
  350: if terminal_has_colors():
  351:     _colour_codes = dict(black=0, red=1, green=2, yellow=3,
  352:                          blue=4, magenta=5, cyan=6, white=7, default=9)
  353:     def colour_text(s, fg=None, bg=None, bold=False):
  354:         seq = []
  355:         if bold:
  356:             seq.append('1')
  357:         if fg:
  358:             fgcode = 30 + _colour_codes.get(fg.lower(), 0)
  359:             seq.append(str(fgcode))
  360:         if bg:
  361:             bgcode = 40 + _colour_codes.get(bg.lower(), 7)
  362:             seq.append(str(bgcode))
  363:         if seq:
  364:             return '\x1b[%sm%s\x1b[0m' % (';'.join(seq), s)
  365:         else:
  366:             return s
  367: else:
  368:     def colour_text(s, fg=None, bg=None):
  369:         return s
  370: 
  371: def default_text(s):
  372:     return colour_text(s, 'default')
  373: def red_text(s):
  374:     return colour_text(s, 'red')
  375: def green_text(s):
  376:     return colour_text(s, 'green')
  377: def yellow_text(s):
  378:     return colour_text(s, 'yellow')
  379: def cyan_text(s):
  380:     return colour_text(s, 'cyan')
  381: def blue_text(s):
  382:     return colour_text(s, 'blue')
  383: 
  384: #########################
  385: 
  386: def cyg2win32(path: str) -> str:
  387:     """Convert a path from Cygwin-native to Windows-native.
  388: 
  389:     Uses the cygpath utility (part of the Base install) to do the
  390:     actual conversion.  Falls back to returning the original path if
  391:     this fails.
  392: 
  393:     Handles the default ``/cygdrive`` mount prefix as well as the
  394:     ``/proc/cygdrive`` portable prefix, custom cygdrive prefixes such
  395:     as ``/`` or ``/mnt``, and absolute paths such as ``/usr/src/`` or
  396:     ``/home/username``
  397: 
  398:     Parameters
  399:     ----------
  400:     path : str
  401:        The path to convert
  402: 
  403:     Returns
  404:     -------
  405:     converted_path : str
  406:         The converted path
  407: 
  408:     Notes
  409:     -----
  410:     Documentation for cygpath utility:
  411:     https://cygwin.com/cygwin-ug-net/cygpath.html
  412:     Documentation for the C function it wraps:
  413:     https://cygwin.com/cygwin-api/func-cygwin-conv-path.html
  414: 
  415:     """
  416:     if sys.platform != "cygwin":
  417:         return path
  418:     return subprocess.check_output(
  419:         ["/usr/bin/cygpath", "--windows", path], text=True
  420:     )
  421: 
  422: 
  423: def mingw32():
  424:     """Return true when using mingw32 environment.
  425:     """
  426:     if sys.platform=='win32':
  427:         if os.environ.get('OSTYPE', '')=='msys':
  428:             return True
  429:         if os.environ.get('MSYSTEM', '')=='MINGW32':
  430:             return True
  431:     return False
  432: 
  433: def msvc_runtime_version():
  434:     "Return version of MSVC runtime library, as defined by __MSC_VER__ macro"
  435:     msc_pos = sys.version.find('MSC v.')
  436:     if msc_pos != -1:
  437:         msc_ver = int(sys.version[msc_pos+6:msc_pos+10])
  438:     else:
  439:         msc_ver = None
  440:     return msc_ver
  441: 
  442: def msvc_runtime_library():
  443:     "Return name of MSVC runtime library if Python was built with MSVC >= 7"
  444:     ver = msvc_runtime_major ()
  445:     if ver:
  446:         if ver < 140:
  447:             return "msvcr%i" % ver
  448:         else:
  449:             return "vcruntime%i" % ver
  450:     else:
  451:         return None
  452: 
  453: def msvc_runtime_major():
  454:     "Return major version of MSVC runtime coded like get_build_msvc_version"
  455:     major = {1300:  70,  # MSVC 7.0
  456:              1310:  71,  # MSVC 7.1
  457:              1400:  80,  # MSVC 8
  458:              1500:  90,  # MSVC 9  (aka 2008)
  459:              1600: 100,  # MSVC 10 (aka 2010)
  460:              1900: 140,  # MSVC 14 (aka 2015)
  461:     }.get(msvc_runtime_version(), None)
  462:     return major
  463: 
  464: #########################
  465: 
  466: #XXX need support for .C that is also C++
  467: cxx_ext_match = re.compile(r'.*\.(cpp|cxx|cc)\Z', re.I).match
  468: fortran_ext_match = re.compile(r'.*\.(f90|f95|f77|for|ftn|f)\Z', re.I).match
  469: f90_ext_match = re.compile(r'.*\.(f90|f95)\Z', re.I).match
  470: f90_module_name_match = re.compile(r'\s*module\s*(?P<name>[\w_]+)', re.I).match
  471: def _get_f90_modules(source):
  472:     """Return a list of Fortran f90 module names that
  473:     given source file defines.
  474:     """
  475:     if not f90_ext_match(source):
  476:         return []
  477:     modules = []
  478:     with open(source) as f:
  479:         for line in f:
  480:             m = f90_module_name_match(line)
  481:             if m:
  482:                 name = m.group('name')
  483:                 modules.append(name)
  484:                 # break  # XXX can we assume that there is one module per file?
  485:     return modules
  486: 
  487: def is_string(s):
  488:     return isinstance(s, str)
  489: 
  490: def all_strings(lst):
  491:     """Return True if all items in lst are string objects. """
  492:     return all(is_string(item) for item in lst)
  493: 
  494: def is_sequence(seq):
  495:     if is_string(seq):
  496:         return False
  497:     try:
  498:         len(seq)
  499:     except Exception:
  500:         return False
  501:     return True
  502: 
  503: def is_glob_pattern(s):
  504:     return is_string(s) and ('*' in s or '?' in s)
  505: 
  506: def as_list(seq):
  507:     if is_sequence(seq):
  508:         return list(seq)
  509:     else:
  510:         return [seq]
  511: 
  512: def get_language(sources):
  513:     # not used in numpy/scipy packages, use build_ext.detect_language instead
  514:     """Determine language value (c,f77,f90) from sources """
  515:     language = None
  516:     for source in sources:
  517:         if isinstance(source, str):
  518:             if f90_ext_match(source):
  519:                 language = 'f90'
  520:                 break
  521:             elif fortran_ext_match(source):
  522:                 language = 'f77'
  523:     return language
  524: 
  525: def has_f_sources(sources):
  526:     """Return True if sources contains Fortran files """
  527:     return any(fortran_ext_match(source) for source in sources)
  528: 
  529: def has_cxx_sources(sources):
  530:     """Return True if sources contains C++ files """
  531:     return any(cxx_ext_match(source) for source in sources)
  532: 
  533: def filter_sources(sources):
  534:     """Return four lists of filenames containing
  535:     C, C++, Fortran, and Fortran 90 module sources,
  536:     respectively.
  537:     """
  538:     c_sources = []
  539:     cxx_sources = []
  540:     f_sources = []
  541:     fmodule_sources = []
  542:     for source in sources:
  543:         if fortran_ext_match(source):
  544:             modules = _get_f90_modules(source)
  545:             if modules:
  546:                 fmodule_sources.append(source)
  547:             else:
  548:                 f_sources.append(source)
  549:         elif cxx_ext_match(source):
  550:             cxx_sources.append(source)
  551:         else:
  552:             c_sources.append(source)
  553:     return c_sources, cxx_sources, f_sources, fmodule_sources
  554: 
  555: 
  556: def _get_headers(directory_list):
  557:     # get *.h files from list of directories
  558:     headers = []
  559:     for d in directory_list:
  560:         head = sorted_glob(os.path.join(d, "*.h")) #XXX: *.hpp files??
  561:         headers.extend(head)
  562:     return headers
  563: 
  564: def _get_directories(list_of_sources):
  565:     # get unique directories from list of sources.
  566:     direcs = []
  567:     for f in list_of_sources:
  568:         d = os.path.split(f)
  569:         if d[0] != '' and not d[0] in direcs:
  570:             direcs.append(d[0])
  571:     return direcs
  572: 
  573: def _commandline_dep_string(cc_args, extra_postargs, pp_opts):
  574:     """
  575:     Return commandline representation used to determine if a file needs
  576:     to be recompiled
  577:     """
  578:     cmdline = 'commandline: '
  579:     cmdline += ' '.join(cc_args)
  580:     cmdline += ' '.join(extra_postargs)
  581:     cmdline += ' '.join(pp_opts) + '\n'
  582:     return cmdline
  583: 
  584: 
  585: def get_dependencies(sources):
  586:     #XXX scan sources for include statements
  587:     return _get_headers(_get_directories(sources))
  588: 
  589: def is_local_src_dir(directory):
  590:     """Return true if directory is local directory.
  591:     """
  592:     if not is_string(directory):
  593:         return False
  594:     abs_dir = os.path.abspath(directory)
  595:     c = os.path.commonprefix([os.getcwd(), abs_dir])
  596:     new_dir = abs_dir[len(c):].split(os.sep)
  597:     if new_dir and not new_dir[0]:
  598:         new_dir = new_dir[1:]
  599:     if new_dir and new_dir[0]=='build':
  600:         return False
  601:     new_dir = os.sep.join(new_dir)
  602:     return os.path.isdir(new_dir)
  603: 
  604: def general_source_files(top_path):
  605:     pruned_directories = {'CVS':1, '.svn':1, 'build':1}
  606:     prune_file_pat = re.compile(r'(?:[~#]|\.py[co]|\.o)$')
  607:     for dirpath, dirnames, filenames in os.walk(top_path, topdown=True):
  608:         pruned = [ d for d in dirnames if d not in pruned_directories ]
  609:         dirnames[:] = pruned
  610:         for f in filenames:
  611:             if not prune_file_pat.search(f):
  612:                 yield os.path.join(dirpath, f)
  613: 
  614: def general_source_directories_files(top_path):
  615:     """Return a directory name relative to top_path and
  616:     files contained.
  617:     """
  618:     pruned_directories = ['CVS', '.svn', 'build']
  619:     prune_file_pat = re.compile(r'(?:[~#]|\.py[co]|\.o)$')
  620:     for dirpath, dirnames, filenames in os.walk(top_path, topdown=True):
  621:         pruned = [ d for d in dirnames if d not in pruned_directories ]
  622:         dirnames[:] = pruned
  623:         for d in dirnames:
  624:             dpath = os.path.join(dirpath, d)
  625:             rpath = rel_path(dpath, top_path)
  626:             files = []
  627:             for f in os.listdir(dpath):
  628:                 fn = os.path.join(dpath, f)
  629:                 if os.path.isfile(fn) and not prune_file_pat.search(fn):
  630:                     files.append(fn)
  631:             yield rpath, files
  632:     dpath = top_path
  633:     rpath = rel_path(dpath, top_path)
  634:     filenames = [os.path.join(dpath, f) for f in os.listdir(dpath) \
  635:                  if not prune_file_pat.search(f)]
  636:     files = [f for f in filenames if os.path.isfile(f)]
  637:     yield rpath, files
  638: 
  639: 
  640: def get_ext_source_files(ext):
  641:     # Get sources and any include files in the same directory.
  642:     filenames = []
  643:     sources = [_m for _m in ext.sources if is_string(_m)]
  644:     filenames.extend(sources)
  645:     filenames.extend(get_dependencies(sources))
  646:     for d in ext.depends:
  647:         if is_local_src_dir(d):
  648:             filenames.extend(list(general_source_files(d)))
  649:         elif os.path.isfile(d):
  650:             filenames.append(d)
  651:     return filenames
  652: 
  653: def get_script_files(scripts):
  654:     scripts = [_m for _m in scripts if is_string(_m)]
  655:     return scripts
  656: 
  657: def get_lib_source_files(lib):
  658:     filenames = []
  659:     sources = lib[1].get('sources', [])
  660:     sources = [_m for _m in sources if is_string(_m)]
  661:     filenames.extend(sources)
  662:     filenames.extend(get_dependencies(sources))
  663:     depends = lib[1].get('depends', [])
  664:     for d in depends:
  665:         if is_local_src_dir(d):
  666:             filenames.extend(list(general_source_files(d)))
  667:         elif os.path.isfile(d):
  668:             filenames.append(d)
  669:     return filenames
  670: 
  671: def get_shared_lib_extension(is_python_ext=False):
  672:     """Return the correct file extension for shared libraries.
  673: 
  674:     Parameters
  675:     ----------
  676:     is_python_ext : bool, optional
  677:         Whether the shared library is a Python extension.  Default is False.
  678: 
  679:     Returns
  680:     -------
  681:     so_ext : str
  682:         The shared library extension.
  683: 
  684:     Notes
  685:     -----
  686:     For Python shared libs, `so_ext` will typically be '.so' on Linux and OS X,
  687:     and '.pyd' on Windows.  For Python >= 3.2 `so_ext` has a tag prepended on
  688:     POSIX systems according to PEP 3149.
  689: 
  690:     """
  691:     confvars = distutils.sysconfig.get_config_vars()
  692:     so_ext = confvars.get('EXT_SUFFIX', '')
  693: 
  694:     if not is_python_ext:
  695:         # hardcode known values, config vars (including SHLIB_SUFFIX) are
  696:         # unreliable (see #3182)
  697:         # darwin, windows and debug linux are wrong in 3.3.1 and older
  698:         if (sys.platform.startswith('linux') or
  699:             sys.platform.startswith('gnukfreebsd')):
  700:             so_ext = '.so'
  701:         elif sys.platform.startswith('darwin'):
  702:             so_ext = '.dylib'
  703:         elif sys.platform.startswith('win'):
  704:             so_ext = '.dll'
  705:         else:
  706:             # fall back to config vars for unknown platforms
  707:             # fix long extension for Python >=3.2, see PEP 3149.
  708:             if 'SOABI' in confvars:
  709:                 # Does nothing unless SOABI config var exists
  710:                 so_ext = so_ext.replace('.' + confvars.get('SOABI'), '', 1)
  711: 
  712:     return so_ext
  713: 
  714: def get_data_files(data):
  715:     if is_string(data):
  716:         return [data]
  717:     sources = data[1]
  718:     filenames = []
  719:     for s in sources:
  720:         if hasattr(s, '__call__'):
  721:             continue
  722:         if is_local_src_dir(s):
  723:             filenames.extend(list(general_source_files(s)))
  724:         elif is_string(s):
  725:             if os.path.isfile(s):
  726:                 filenames.append(s)
  727:             else:
  728:                 print('Not existing data file:', s)
  729:         else:
  730:             raise TypeError(repr(s))
  731:     return filenames
  732: 
  733: def dot_join(*args):
  734:     return '.'.join([a for a in args if a])
  735: 
  736: def get_frame(level=0):
  737:     """Return frame object from call stack with given level.
  738:     """
  739:     try:
  740:         return sys._getframe(level+1)
  741:     except AttributeError:
  742:         frame = sys.exc_info()[2].tb_frame
  743:         for _ in range(level+1):
  744:             frame = frame.f_back
  745:         return frame
  746: 
  747: 
  748: ######################
  749: 
  750: class Configuration:
  751: 
  752:     _list_keys = ['packages', 'ext_modules', 'data_files', 'include_dirs',
  753:                   'libraries', 'headers', 'scripts', 'py_modules',
  754:                   'installed_libraries', 'define_macros']
  755:     _dict_keys = ['package_dir', 'installed_pkg_config']
  756:     _extra_keys = ['name', 'version']
  757: 
  758:     numpy_include_dirs = []
  759: 
  760:     def __init__(self,
  761:                  package_name=None,
  762:                  parent_name=None,
  763:                  top_path=None,
  764:                  package_path=None,
  765:                  caller_level=1,
  766:                  setup_name='setup.py',
  767:                  **attrs):
  768:         """Construct configuration instance of a package.
  769: 
  770:         package_name -- name of the package
  771:                         Ex.: 'distutils'
  772:         parent_name  -- name of the parent package
  773:                         Ex.: 'numpy'
  774:         top_path     -- directory of the toplevel package
  775:                         Ex.: the directory where the numpy package source sits
  776:         package_path -- directory of package. Will be computed by magic from the
  777:                         directory of the caller module if not specified
  778:                         Ex.: the directory where numpy.distutils is
  779:         caller_level -- frame level to caller namespace, internal parameter.
  780:         """
  781:         self.name = dot_join(parent_name, package_name)
  782:         self.version = None
  783: 
  784:         caller_frame = get_frame(caller_level)
  785:         self.local_path = get_path_from_frame(caller_frame, top_path)
  786:         # local_path -- directory of a file (usually setup.py) that
  787:         #               defines a configuration() function.
  788:         # local_path -- directory of a file (usually setup.py) that
  789:         #               defines a configuration() function.
  790:         if top_path is None:
  791:             top_path = self.local_path
  792:             self.local_path = ''
  793:         if package_path is None:
  794:             package_path = self.local_path
  795:         elif os.path.isdir(njoin(self.local_path, package_path)):
  796:             package_path = njoin(self.local_path, package_path)
  797:         if not os.path.isdir(package_path or '.'):
  798:             raise ValueError("%r is not a directory" % (package_path,))
  799:         self.top_path = top_path
  800:         self.package_path = package_path
  801:         # this is the relative path in the installed package
  802:         self.path_in_package = os.path.join(*self.name.split('.'))
  803: 
  804:         self.list_keys = self._list_keys[:]
  805:         self.dict_keys = self._dict_keys[:]
  806: 
  807:         for n in self.list_keys:
  808:             v = copy.copy(attrs.get(n, []))
  809:             setattr(self, n, as_list(v))
  810: 
  811:         for n in self.dict_keys:
  812:             v = copy.copy(attrs.get(n, {}))
  813:             setattr(self, n, v)
  814: 
  815:         known_keys = self.list_keys + self.dict_keys
  816:         self.extra_keys = self._extra_keys[:]
  817:         for n in attrs.keys():
  818:             if n in known_keys:
  819:                 continue
  820:             a = attrs[n]
  821:             setattr(self, n, a)
  822:             if isinstance(a, list):
  823:                 self.list_keys.append(n)
  824:             elif isinstance(a, dict):
  825:                 self.dict_keys.append(n)
  826:             else:
  827:                 self.extra_keys.append(n)
  828: 
  829:         if os.path.exists(njoin(package_path, '__init__.py')):
  830:             self.packages.append(self.name)
  831:             self.package_dir[self.name] = package_path
  832: 
  833:         self.options = dict(
  834:             ignore_setup_xxx_py = False,
  835:             assume_default_configuration = False,
  836:             delegate_options_to_subpackages = False,
  837:             quiet = False,
  838:             )
  839: 
  840:         caller_instance = None
  841:         for i in range(1, 3):
  842:             try:
  843:                 f = get_frame(i)
  844:             except ValueError:
  845:                 break
  846:             try:
  847:                 caller_instance = eval('self', f.f_globals, f.f_locals)
  848:                 break
  849:             except NameError:
  850:                 pass
  851:         if isinstance(caller_instance, self.__class__):
  852:             if caller_instance.options['delegate_options_to_subpackages']:
  853:                 self.set_options(**caller_instance.options)
  854: 
  855:         self.setup_name = setup_name
  856: 
  857:     def todict(self):
  858:         """
  859:         Return a dictionary compatible with the keyword arguments of distutils
  860:         setup function.
  861: 
  862:         Examples
  863:         --------
  864:         >>> setup(**config.todict())                           #doctest: +SKIP
  865:         """
  866: 
  867:         self._optimize_data_files()
  868:         d = {}
  869:         known_keys = self.list_keys + self.dict_keys + self.extra_keys
  870:         for n in known_keys:
  871:             a = getattr(self, n)
  872:             if a:
  873:                 d[n] = a
  874:         return d
  875: 
  876:     def info(self, message):
  877:         if not self.options['quiet']:
  878:             print(message)
  879: 
  880:     def warn(self, message):
  881:         sys.stderr.write('Warning: %s\n' % (message,))
  882: 
  883:     def set_options(self, **options):
  884:         """
  885:         Configure Configuration instance.
  886: 
  887:         The following options are available:
  888:          - ignore_setup_xxx_py
  889:          - assume_default_configuration
  890:          - delegate_options_to_subpackages
  891:          - quiet
  892: 
  893:         """
  894:         for key, value in options.items():
  895:             if key in self.options:
  896:                 self.options[key] = value
  897:             else:
  898:                 raise ValueError('Unknown option: '+key)
  899: 
  900:     def get_distribution(self):
  901:         """Return the distutils distribution object for self."""
  902:         from numpy.distutils.core import get_distribution
  903:         return get_distribution()
  904: 
  905:     def _wildcard_get_subpackage(self, subpackage_name,
  906:                                  parent_name,
  907:                                  caller_level = 1):
  908:         l = subpackage_name.split('.')
  909:         subpackage_path = njoin([self.local_path]+l)
  910:         dirs = [_m for _m in sorted_glob(subpackage_path) if os.path.isdir(_m)]
  911:         config_list = []
  912:         for d in dirs:
  913:             if not os.path.isfile(njoin(d, '__init__.py')):
  914:                 continue
  915:             if 'build' in d.split(os.sep):
  916:                 continue
  917:             n = '.'.join(d.split(os.sep)[-len(l):])
  918:             c = self.get_subpackage(n,
  919:                                     parent_name = parent_name,
  920:                                     caller_level = caller_level+1)
  921:             config_list.extend(c)
  922:         return config_list
  923: 
  924:     def _get_configuration_from_setup_py(self, setup_py,
  925:                                          subpackage_name,
  926:                                          subpackage_path,
  927:                                          parent_name,
  928:                                          caller_level = 1):
  929:         # In case setup_py imports local modules:
  930:         sys.path.insert(0, os.path.dirname(setup_py))
  931:         try:
  932:             setup_name = os.path.splitext(os.path.basename(setup_py))[0]
  933:             n = dot_join(self.name, subpackage_name, setup_name)
  934:             setup_module = exec_mod_from_location(
  935:                                 '_'.join(n.split('.')), setup_py)
  936:             if not hasattr(setup_module, 'configuration'):
  937:                 if not self.options['assume_default_configuration']:
  938:                     self.warn('Assuming default configuration '\
  939:                               '(%s does not define configuration())'\
  940:                               % (setup_module))
  941:                 config = Configuration(subpackage_name, parent_name,
  942:                                        self.top_path, subpackage_path,
  943:                                        caller_level = caller_level + 1)
  944:             else:
  945:                 pn = dot_join(*([parent_name] + subpackage_name.split('.')[:-1]))
  946:                 args = (pn,)
  947:                 if setup_module.configuration.__code__.co_argcount > 1:
  948:                     args = args + (self.top_path,)
  949:                 config = setup_module.configuration(*args)
  950:             if config.name!=dot_join(parent_name, subpackage_name):
  951:                 self.warn('Subpackage %r configuration returned as %r' % \
  952:                           (dot_join(parent_name, subpackage_name), config.name))
  953:         finally:
  954:             del sys.path[0]
  955:         return config
  956: 
  957:     def get_subpackage(self,subpackage_name,
  958:                        subpackage_path=None,
  959:                        parent_name=None,
  960:                        caller_level = 1):
  961:         """Return list of subpackage configurations.
  962: 
  963:         Parameters
  964:         ----------
  965:         subpackage_name : str or None
  966:             Name of the subpackage to get the configuration. '*' in
  967:             subpackage_name is handled as a wildcard.
  968:         subpackage_path : str
  969:             If None, then the path is assumed to be the local path plus the
  970:             subpackage_name. If a setup.py file is not found in the
  971:             subpackage_path, then a default configuration is used.
  972:         parent_name : str
  973:             Parent name.
  974:         """
  975:         if subpackage_name is None:
  976:             if subpackage_path is None:
  977:                 raise ValueError(
  978:                     "either subpackage_name or subpackage_path must be specified")
  979:             subpackage_name = os.path.basename(subpackage_path)
  980: 
  981:         # handle wildcards
  982:         l = subpackage_name.split('.')
  983:         if subpackage_path is None and '*' in subpackage_name:
  984:             return self._wildcard_get_subpackage(subpackage_name,
  985:                                                  parent_name,
  986:                                                  caller_level = caller_level+1)
  987:         assert '*' not in subpackage_name, repr((subpackage_name, subpackage_path, parent_name))
  988:         if subpackage_path is None:
  989:             subpackage_path = njoin([self.local_path] + l)
  990:         else:
  991:             subpackage_path = njoin([subpackage_path] + l[:-1])
  992:             subpackage_path = self.paths([subpackage_path])[0]
  993:         setup_py = njoin(subpackage_path, self.setup_name)
  994:         if not self.options['ignore_setup_xxx_py']:
  995:             if not os.path.isfile(setup_py):
  996:                 setup_py = njoin(subpackage_path,
  997:                                  'setup_%s.py' % (subpackage_name))
  998:         if not os.path.isfile(setup_py):
  999:             if not self.options['assume_default_configuration']:
 1000:                 self.warn('Assuming default configuration '\
 1001:                           '(%s/{setup_%s,setup}.py was not found)' \
 1002:                           % (os.path.dirname(setup_py), subpackage_name))
 1003:             config = Configuration(subpackage_name, parent_name,
 1004:                                    self.top_path, subpackage_path,
 1005:                                    caller_level = caller_level+1)
 1006:         else:
 1007:             config = self._get_configuration_from_setup_py(
 1008:                 setup_py,
 1009:                 subpackage_name,
 1010:                 subpackage_path,
 1011:                 parent_name,
 1012:                 caller_level = caller_level + 1)
 1013:         if config:
 1014:             return [config]
 1015:         else:
 1016:             return []
 1017: 
 1018:     def add_subpackage(self,subpackage_name,
 1019:                        subpackage_path=None,
 1020:                        standalone = False):
 1021:         """Add a sub-package to the current Configuration instance.
 1022: 
 1023:         This is useful in a setup.py script for adding sub-packages to a
 1024:         package.
 1025: 
 1026:         Parameters
 1027:         ----------
 1028:         subpackage_name : str
 1029:             name of the subpackage
 1030:         subpackage_path : str
 1031:             if given, the subpackage path such as the subpackage is in
 1032:             subpackage_path / subpackage_name. If None,the subpackage is
 1033:             assumed to be located in the local path / subpackage_name.
 1034:         standalone : bool
 1035:         """
 1036: 
 1037:         if standalone:
 1038:             parent_name = None
 1039:         else:
 1040:             parent_name = self.name
 1041:         config_list = self.get_subpackage(subpackage_name, subpackage_path,
 1042:                                           parent_name = parent_name,
 1043:                                           caller_level = 2)
 1044:         if not config_list:
 1045:             self.warn('No configuration returned, assuming unavailable.')
 1046:         for config in config_list:
 1047:             d = config
 1048:             if isinstance(config, Configuration):
 1049:                 d = config.todict()
 1050:             assert isinstance(d, dict), repr(type(d))
 1051: 
 1052:             self.info('Appending %s configuration to %s' \
 1053:                       % (d.get('name'), self.name))
 1054:             self.dict_append(**d)
 1055: 
 1056:         dist = self.get_distribution()
 1057:         if dist is not None:
 1058:             self.warn('distutils distribution has been initialized,'\
 1059:                       ' it may be too late to add a subpackage '+ subpackage_name)
 1060: 
 1061:     def add_data_dir(self, data_path):
 1062:         """Recursively add files under data_path to data_files list.
 1063: 
 1064:         Recursively add files under data_path to the list of data_files to be
 1065:         installed (and distributed). The data_path can be either a relative
 1066:         path-name, or an absolute path-name, or a 2-tuple where the first
 1067:         argument shows where in the install directory the data directory
 1068:         should be installed to.
 1069: 
 1070:         Parameters
 1071:         ----------
 1072:         data_path : seq or str
 1073:             Argument can be either
 1074: 
 1075:                 * 2-sequence (<datadir suffix>, <path to data directory>)
 1076:                 * path to data directory where python datadir suffix defaults
 1077:                   to package dir.
 1078: 
 1079:         Notes
 1080:         -----
 1081:         Rules for installation paths::
 1082: 
 1083:             foo/bar -> (foo/bar, foo/bar) -> parent/foo/bar
 1084:             (gun, foo/bar) -> parent/gun
 1085:             foo/* -> (foo/a, foo/a), (foo/b, foo/b) -> parent/foo/a, parent/foo/b
 1086:             (gun, foo/*) -> (gun, foo/a), (gun, foo/b) -> gun
 1087:             (gun/*, foo/*) -> parent/gun/a, parent/gun/b
 1088:             /foo/bar -> (bar, /foo/bar) -> parent/bar
 1089:             (gun, /foo/bar) -> parent/gun
 1090:             (fun/*/gun/*, sun/foo/bar) -> parent/fun/foo/gun/bar
 1091: 
 1092:         Examples
 1093:         --------
 1094:         For example suppose the source directory contains fun/foo.dat and
 1095:         fun/bar/car.dat:
 1096: 
 1097:         >>> self.add_data_dir('fun')                       #doctest: +SKIP
 1098:         >>> self.add_data_dir(('sun', 'fun'))              #doctest: +SKIP
 1099:         >>> self.add_data_dir(('gun', '/full/path/to/fun'))#doctest: +SKIP
 1100: 
 1101:         Will install data-files to the locations::
 1102: 
 1103:             <package install directory>/
 1104:               fun/
 1105:                 foo.dat
 1106:                 bar/
 1107:                   car.dat
 1108:               sun/
 1109:                 foo.dat
 1110:                 bar/
 1111:                   car.dat
 1112:               gun/
 1113:                 foo.dat
 1114:                 car.dat
 1115: 
 1116:         """
 1117:         if is_sequence(data_path):
 1118:             d, data_path = data_path
 1119:         else:
 1120:             d = None
 1121:         if is_sequence(data_path):
 1122:             [self.add_data_dir((d, p)) for p in data_path]
 1123:             return
 1124:         if not is_string(data_path):
 1125:             raise TypeError("not a string: %r" % (data_path,))
 1126:         if d is None:
 1127:             if os.path.isabs(data_path):
 1128:                 return self.add_data_dir((os.path.basename(data_path), data_path))
 1129:             return self.add_data_dir((data_path, data_path))
 1130:         paths = self.paths(data_path, include_non_existing=False)
 1131:         if is_glob_pattern(data_path):
 1132:             if is_glob_pattern(d):
 1133:                 pattern_list = allpath(d).split(os.sep)
 1134:                 pattern_list.reverse()
 1135:                 # /a/*//b/ -> /a/*/b
 1136:                 rl = list(range(len(pattern_list)-1)); rl.reverse()
 1137:                 for i in rl:
 1138:                     if not pattern_list[i]:
 1139:                         del pattern_list[i]
 1140:                 #
 1141:                 for path in paths:
 1142:                     if not os.path.isdir(path):
 1143:                         print('Not a directory, skipping', path)
 1144:                         continue
 1145:                     rpath = rel_path(path, self.local_path)
 1146:                     path_list = rpath.split(os.sep)
 1147:                     path_list.reverse()
 1148:                     target_list = []
 1149:                     i = 0
 1150:                     for s in pattern_list:
 1151:                         if is_glob_pattern(s):
 1152:                             if i>=len(path_list):
 1153:                                 raise ValueError('cannot fill pattern %r with %r' \
 1154:                                       % (d, path))
 1155:                             target_list.append(path_list[i])
 1156:                         else:
 1157:                             assert s==path_list[i], repr((s, path_list[i], data_path, d, path, rpath))
 1158:                             target_list.append(s)
 1159:                         i += 1
 1160:                     if path_list[i:]:
 1161:                         self.warn('mismatch of pattern_list=%s and path_list=%s'\
 1162:                                   % (pattern_list, path_list))
 1163:                     target_list.reverse()
 1164:                     self.add_data_dir((os.sep.join(target_list), path))
 1165:             else:
 1166:                 for path in paths:
 1167:                     self.add_data_dir((d, path))
 1168:             return
 1169:         assert not is_glob_pattern(d), repr(d)
 1170: 
 1171:         dist = self.get_distribution()
 1172:         if dist is not None and dist.data_files is not None:
 1173:             data_files = dist.data_files
 1174:         else:
 1175:             data_files = self.data_files
 1176: 
 1177:         for path in paths:
 1178:             for d1, f in list(general_source_directories_files(path)):
 1179:                 target_path = os.path.join(self.path_in_package, d, d1)
 1180:                 data_files.append((target_path, f))
 1181: 
 1182:     def _optimize_data_files(self):
 1183:         data_dict = {}
 1184:         for p, files in self.data_files:
 1185:             if p not in data_dict:
 1186:                 data_dict[p] = set()
 1187:             for f in files:
 1188:                 data_dict[p].add(f)
 1189:         self.data_files[:] = [(p, list(files)) for p, files in data_dict.items()]
 1190: 
 1191:     def add_data_files(self,*files):
 1192:         """Add data files to configuration data_files.
 1193: 
 1194:         Parameters
 1195:         ----------
 1196:         files : sequence
 1197:             Argument(s) can be either
 1198: 
 1199:                 * 2-sequence (<datadir prefix>,<path to data file(s)>)
 1200:                 * paths to data files where python datadir prefix defaults
 1201:                   to package dir.
 1202: 
 1203:         Notes
 1204:         -----
 1205:         The form of each element of the files sequence is very flexible
 1206:         allowing many combinations of where to get the files from the package
 1207:         and where they should ultimately be installed on the system. The most
 1208:         basic usage is for an element of the files argument sequence to be a
 1209:         simple filename. This will cause that file from the local path to be
 1210:         installed to the installation path of the self.name package (package
 1211:         path). The file argument can also be a relative path in which case the
 1212:         entire relative path will be installed into the package directory.
 1213:         Finally, the file can be an absolute path name in which case the file
 1214:         will be found at the absolute path name but installed to the package
 1215:         path.
 1216: 
 1217:         This basic behavior can be augmented by passing a 2-tuple in as the
 1218:         file argument. The first element of the tuple should specify the
 1219:         relative path (under the package install directory) where the
 1220:         remaining sequence of files should be installed to (it has nothing to
 1221:         do with the file-names in the source distribution). The second element
 1222:         of the tuple is the sequence of files that should be installed. The
 1223:         files in this sequence can be filenames, relative paths, or absolute
 1224:         paths. For absolute paths the file will be installed in the top-level
 1225:         package installation directory (regardless of the first argument).
 1226:         Filenames and relative path names will be installed in the package
 1227:         install directory under the path name given as the first element of
 1228:         the tuple.
 1229: 
 1230:         Rules for installation paths:
 1231: 
 1232:           #. file.txt -> (., file.txt)-> parent/file.txt
 1233:           #. foo/file.txt -> (foo, foo/file.txt) -> parent/foo/file.txt
 1234:           #. /foo/bar/file.txt -> (., /foo/bar/file.txt) -> parent/file.txt
 1235:           #. ``*``.txt -> parent/a.txt, parent/b.txt
 1236:           #. foo/``*``.txt`` -> parent/foo/a.txt, parent/foo/b.txt
 1237:           #. ``*/*.txt`` -> (``*``, ``*``/``*``.txt) -> parent/c/a.txt, parent/d/b.txt
 1238:           #. (sun, file.txt) -> parent/sun/file.txt
 1239:           #. (sun, bar/file.txt) -> parent/sun/file.txt
 1240:           #. (sun, /foo/bar/file.txt) -> parent/sun/file.txt
 1241:           #. (sun, ``*``.txt) -> parent/sun/a.txt, parent/sun/b.txt
 1242:           #. (sun, bar/``*``.txt) -> parent/sun/a.txt, parent/sun/b.txt
 1243:           #. (sun/``*``, ``*``/``*``.txt) -> parent/sun/c/a.txt, parent/d/b.txt
 1244: 
 1245:         An additional feature is that the path to a data-file can actually be
 1246:         a function that takes no arguments and returns the actual path(s) to
 1247:         the data-files. This is useful when the data files are generated while
 1248:         building the package.
 1249: 
 1250:         Examples
 1251:         --------
 1252:         Add files to the list of data_files to be included with the package.
 1253: 
 1254:             >>> self.add_data_files('foo.dat',
 1255:             ...     ('fun', ['gun.dat', 'nun/pun.dat', '/tmp/sun.dat']),
 1256:             ...     'bar/cat.dat',
 1257:             ...     '/full/path/to/can.dat')                   #doctest: +SKIP
 1258: 
 1259:         will install these data files to::
 1260: 
 1261:             <package install directory>/
 1262:              foo.dat
 1263:              fun/
 1264:                gun.dat
 1265:                nun/
 1266:                  pun.dat
 1267:              sun.dat
 1268:              bar/
 1269:                car.dat
 1270:              can.dat
 1271: 
 1272:         where <package install directory> is the package (or sub-package)
 1273:         directory such as '/usr/lib/python2.4/site-packages/mypackage' ('C:
 1274:         \\Python2.4 \\Lib \\site-packages \\mypackage') or
 1275:         '/usr/lib/python2.4/site- packages/mypackage/mysubpackage' ('C:
 1276:         \\Python2.4 \\Lib \\site-packages \\mypackage \\mysubpackage').
 1277:         """
 1278: 
 1279:         if len(files)>1:
 1280:             for f in files:
 1281:                 self.add_data_files(f)
 1282:             return
 1283:         assert len(files)==1
 1284:         if is_sequence(files[0]):
 1285:             d, files = files[0]
 1286:         else:
 1287:             d = None
 1288:         if is_string(files):
 1289:             filepat = files
 1290:         elif is_sequence(files):
 1291:             if len(files)==1:
 1292:                 filepat = files[0]
 1293:             else:
 1294:                 for f in files:
 1295:                     self.add_data_files((d, f))
 1296:                 return
 1297:         else:
 1298:             raise TypeError(repr(type(files)))
 1299: 
 1300:         if d is None:
 1301:             if hasattr(filepat, '__call__'):
 1302:                 d = ''
 1303:             elif os.path.isabs(filepat):
 1304:                 d = ''
 1305:             else:
 1306:                 d = os.path.dirname(filepat)
 1307:             self.add_data_files((d, files))
 1308:             return
 1309: 
 1310:         paths = self.paths(filepat, include_non_existing=False)
 1311:         if is_glob_pattern(filepat):
 1312:             if is_glob_pattern(d):
 1313:                 pattern_list = d.split(os.sep)
 1314:                 pattern_list.reverse()
 1315:                 for path in paths:
 1316:                     path_list = path.split(os.sep)
 1317:                     path_list.reverse()
 1318:                     path_list.pop() # filename
 1319:                     target_list = []
 1320:                     i = 0
 1321:                     for s in pattern_list:
 1322:                         if is_glob_pattern(s):
 1323:                             target_list.append(path_list[i])
 1324:                             i += 1
 1325:                         else:
 1326:                             target_list.append(s)
 1327:                     target_list.reverse()
 1328:                     self.add_data_files((os.sep.join(target_list), path))
 1329:             else:
 1330:                 self.add_data_files((d, paths))
 1331:             return
 1332:         assert not is_glob_pattern(d), repr((d, filepat))
 1333: 
 1334:         dist = self.get_distribution()
 1335:         if dist is not None and dist.data_files is not None:
 1336:             data_files = dist.data_files
 1337:         else:
 1338:             data_files = self.data_files
 1339: 
 1340:         data_files.append((os.path.join(self.path_in_package, d), paths))
 1341: 
 1342:     ### XXX Implement add_py_modules
 1343: 
 1344:     def add_define_macros(self, macros):
 1345:         """Add define macros to configuration
 1346: 
 1347:         Add the given sequence of macro name and value duples to the beginning
 1348:         of the define_macros list This list will be visible to all extension
 1349:         modules of the current package.
 1350:         """
 1351:         dist = self.get_distribution()
 1352:         if dist is not None:
 1353:             if not hasattr(dist, 'define_macros'):
 1354:                 dist.define_macros = []
 1355:             dist.define_macros.extend(macros)
 1356:         else:
 1357:             self.define_macros.extend(macros)
 1358: 
 1359: 
 1360:     def add_include_dirs(self,*paths):
 1361:         """Add paths to configuration include directories.
 1362: 
 1363:         Add the given sequence of paths to the beginning of the include_dirs
 1364:         list. This list will be visible to all extension modules of the
 1365:         current package.
 1366:         """
 1367:         include_dirs = self.paths(paths)
 1368:         dist = self.get_distribution()
 1369:         if dist is not None:
 1370:             if dist.include_dirs is None:
 1371:                 dist.include_dirs = []
 1372:             dist.include_dirs.extend(include_dirs)
 1373:         else:
 1374:             self.include_dirs.extend(include_dirs)
 1375: 
 1376:     def add_headers(self,*files):
 1377:         """Add installable headers to configuration.
 1378: 
 1379:         Add the given sequence of files to the beginning of the headers list.
 1380:         By default, headers will be installed under <python-
 1381:         include>/<self.name.replace('.','/')>/ directory. If an item of files
 1382:         is a tuple, then its first argument specifies the actual installation
 1383:         location relative to the <python-include> path.
 1384: 
 1385:         Parameters
 1386:         ----------
 1387:         files : str or seq
 1388:             Argument(s) can be either:
 1389: 
 1390:                 * 2-sequence (<includedir suffix>,<path to header file(s)>)
 1391:                 * path(s) to header file(s) where python includedir suffix will
 1392:                   default to package name.
 1393:         """
 1394:         headers = []
 1395:         for path in files:
 1396:             if is_string(path):
 1397:                 [headers.append((self.name, p)) for p in self.paths(path)]
 1398:             else:
 1399:                 if not isinstance(path, (tuple, list)) or len(path) != 2:
 1400:                     raise TypeError(repr(path))
 1401:                 [headers.append((path[0], p)) for p in self.paths(path[1])]
 1402:         dist = self.get_distribution()
 1403:         if dist is not None:
 1404:             if dist.headers is None:
 1405:                 dist.headers = []
 1406:             dist.headers.extend(headers)
 1407:         else:
 1408:             self.headers.extend(headers)
 1409: 
 1410:     def paths(self,*paths,**kws):
 1411:         """Apply glob to paths and prepend local_path if needed.
 1412: 
 1413:         Applies glob.glob(...) to each path in the sequence (if needed) and
 1414:         prepends the local_path if needed. Because this is called on all
 1415:         source lists, this allows wildcard characters to be specified in lists
 1416:         of sources for extension modules and libraries and scripts and allows
 1417:         path-names be relative to the source directory.
 1418: 
 1419:         """
 1420:         include_non_existing = kws.get('include_non_existing', True)
 1421:         return gpaths(paths,
 1422:                       local_path = self.local_path,
 1423:                       include_non_existing=include_non_existing)
 1424: 
 1425:     def _fix_paths_dict(self, kw):
 1426:         for k in kw.keys():
 1427:             v = kw[k]
 1428:             if k in ['sources', 'depends', 'include_dirs', 'library_dirs',
 1429:                      'module_dirs', 'extra_objects']:
 1430:                 new_v = self.paths(v)
 1431:                 kw[k] = new_v
 1432: 
 1433:     def add_extension(self,name,sources,**kw):
 1434:         """Add extension to configuration.
 1435: 
 1436:         Create and add an Extension instance to the ext_modules list. This
 1437:         method also takes the following optional keyword arguments that are
 1438:         passed on to the Extension constructor.
 1439: 
 1440:         Parameters
 1441:         ----------
 1442:         name : str
 1443:             name of the extension
 1444:         sources : seq
 1445:             list of the sources. The list of sources may contain functions
 1446:             (called source generators) which must take an extension instance
 1447:             and a build directory as inputs and return a source file or list of
 1448:             source files or None. If None is returned then no sources are
 1449:             generated. If the Extension instance has no sources after
 1450:             processing all source generators, then no extension module is
 1451:             built.
 1452:         include_dirs :
 1453:         define_macros :
 1454:         undef_macros :
 1455:         library_dirs :
 1456:         libraries :
 1457:         runtime_library_dirs :
 1458:         extra_objects :
 1459:         extra_compile_args :
 1460:         extra_link_args :
 1461:         extra_f77_compile_args :
 1462:         extra_f90_compile_args :
 1463:         export_symbols :
 1464:         swig_opts :
 1465:         depends :
 1466:             The depends list contains paths to files or directories that the
 1467:             sources of the extension module depend on. If any path in the
 1468:             depends list is newer than the extension module, then the module
 1469:             will be rebuilt.
 1470:         language :
 1471:         f2py_options :
 1472:         module_dirs :
 1473:         extra_info : dict or list
 1474:             dict or list of dict of keywords to be appended to keywords.
 1475: 
 1476:         Notes
 1477:         -----
 1478:         The self.paths(...) method is applied to all lists that may contain
 1479:         paths.
 1480:         """
 1481:         ext_args = copy.copy(kw)
 1482:         ext_args['name'] = dot_join(self.name, name)
 1483:         ext_args['sources'] = sources
 1484: 
 1485:         if 'extra_info' in ext_args:
 1486:             extra_info = ext_args['extra_info']
 1487:             del ext_args['extra_info']
 1488:             if isinstance(extra_info, dict):
 1489:                 extra_info = [extra_info]
 1490:             for info in extra_info:
 1491:                 assert isinstance(info, dict), repr(info)
 1492:                 dict_append(ext_args,**info)
 1493: 
 1494:         self._fix_paths_dict(ext_args)
 1495: 
 1496:         # Resolve out-of-tree dependencies
 1497:         libraries = ext_args.get('libraries', [])
 1498:         libnames = []
 1499:         ext_args['libraries'] = []
 1500:         for libname in libraries:
 1501:             if isinstance(libname, tuple):
 1502:                 self._fix_paths_dict(libname[1])
 1503: 
 1504:             # Handle library names of the form libname@relative/path/to/library
 1505:             if '@' in libname:
 1506:                 lname, lpath = libname.split('@', 1)
 1507:                 lpath = os.path.abspath(njoin(self.local_path, lpath))
 1508:                 if os.path.isdir(lpath):
 1509:                     c = self.get_subpackage(None, lpath,
 1510:                                             caller_level = 2)
 1511:                     if isinstance(c, Configuration):
 1512:                         c = c.todict()
 1513:                     for l in [l[0] for l in c.get('libraries', [])]:
 1514:                         llname = l.split('__OF__', 1)[0]
 1515:                         if llname == lname:
 1516:                             c.pop('name', None)
 1517:                             dict_append(ext_args,**c)
 1518:                             break
 1519:                     continue
 1520:             libnames.append(libname)
 1521: 
 1522:         ext_args['libraries'] = libnames + ext_args['libraries']
 1523:         ext_args['define_macros'] = \
 1524:             self.define_macros + ext_args.get('define_macros', [])
 1525: 
 1526:         from numpy.distutils.core import Extension
 1527:         ext = Extension(**ext_args)
 1528:         self.ext_modules.append(ext)
 1529: 
 1530:         dist = self.get_distribution()
 1531:         if dist is not None:
 1532:             self.warn('distutils distribution has been initialized,'\
 1533:                       ' it may be too late to add an extension '+name)
 1534:         return ext
 1535: 
 1536:     def add_library(self,name,sources,**build_info):
 1537:         """
 1538:         Add library to configuration.
 1539: 
 1540:         Parameters
 1541:         ----------
 1542:         name : str
 1543:             Name of the extension.
 1544:         sources : sequence
 1545:             List of the sources. The list of sources may contain functions
 1546:             (called source generators) which must take an extension instance
 1547:             and a build directory as inputs and return a source file or list of
 1548:             source files or None. If None is returned then no sources are
 1549:             generated. If the Extension instance has no sources after
 1550:             processing all source generators, then no extension module is
 1551:             built.
 1552:         build_info : dict, optional
 1553:             The following keys are allowed:
 1554: 
 1555:                 * depends
 1556:                 * macros
 1557:                 * include_dirs
 1558:                 * extra_compiler_args
 1559:                 * extra_f77_compile_args
 1560:                 * extra_f90_compile_args
 1561:                 * f2py_options
 1562:                 * language
 1563: 
 1564:         """
 1565:         self._add_library(name, sources, None, build_info)
 1566: 
 1567:         dist = self.get_distribution()
 1568:         if dist is not None:
 1569:             self.warn('distutils distribution has been initialized,'\
 1570:                       ' it may be too late to add a library '+ name)
 1571: 
 1572:     def _add_library(self, name, sources, install_dir, build_info):
 1573:         """Common implementation for add_library and add_installed_library. Do
 1574:         not use directly"""
 1575:         build_info = copy.copy(build_info)
 1576:         build_info['sources'] = sources
 1577: 
 1578:         # Sometimes, depends is not set up to an empty list by default, and if
 1579:         # depends is not given to add_library, distutils barfs (#1134)
 1580:         if not 'depends' in build_info:
 1581:             build_info['depends'] = []
 1582: 
 1583:         self._fix_paths_dict(build_info)
 1584: 
 1585:         # Add to libraries list so that it is build with build_clib
 1586:         self.libraries.append((name, build_info))
 1587: 
 1588:     def add_installed_library(self, name, sources, install_dir, build_info=None):
 1589:         """
 1590:         Similar to add_library, but the specified library is installed.
 1591: 
 1592:         Most C libraries used with ``distutils`` are only used to build python
 1593:         extensions, but libraries built through this method will be installed
 1594:         so that they can be reused by third-party packages.
 1595: 
 1596:         Parameters
 1597:         ----------
 1598:         name : str
 1599:             Name of the installed library.
 1600:         sources : sequence
 1601:             List of the library's source files. See `add_library` for details.
 1602:         install_dir : str
 1603:             Path to install the library, relative to the current sub-package.
 1604:         build_info : dict, optional
 1605:             The following keys are allowed:
 1606: 
 1607:                 * depends
 1608:                 * macros
 1609:                 * include_dirs
 1610:                 * extra_compiler_args
 1611:                 * extra_f77_compile_args
 1612:                 * extra_f90_compile_args
 1613:                 * f2py_options
 1614:                 * language
 1615: 
 1616:         Returns
 1617:         -------
 1618:         None
 1619: 
 1620:         See Also
 1621:         --------
 1622:         add_library, add_npy_pkg_config, get_info
 1623: 
 1624:         Notes
 1625:         -----
 1626:         The best way to encode the options required to link against the specified
 1627:         C libraries is to use a "libname.ini" file, and use `get_info` to
 1628:         retrieve the required options (see `add_npy_pkg_config` for more
 1629:         information).
 1630: 
 1631:         """
 1632:         if not build_info:
 1633:             build_info = {}
 1634: 
 1635:         install_dir = os.path.join(self.package_path, install_dir)
 1636:         self._add_library(name, sources, install_dir, build_info)
 1637:         self.installed_libraries.append(InstallableLib(name, build_info, install_dir))
 1638: 
 1639:     def add_npy_pkg_config(self, template, install_dir, subst_dict=None):
 1640:         """
 1641:         Generate and install a npy-pkg config file from a template.
 1642: 
 1643:         The config file generated from `template` is installed in the
 1644:         given install directory, using `subst_dict` for variable substitution.
 1645: 
 1646:         Parameters
 1647:         ----------
 1648:         template : str
 1649:             The path of the template, relatively to the current package path.
 1650:         install_dir : str
 1651:             Where to install the npy-pkg config file, relatively to the current
 1652:             package path.
 1653:         subst_dict : dict, optional
 1654:             If given, any string of the form ``@key@`` will be replaced by
 1655:             ``subst_dict[key]`` in the template file when installed. The install
 1656:             prefix is always available through the variable ``@prefix@``, since the
 1657:             install prefix is not easy to get reliably from setup.py.
 1658: 
 1659:         See also
 1660:         --------
 1661:         add_installed_library, get_info
 1662: 
 1663:         Notes
 1664:         -----
 1665:         This works for both standard installs and in-place builds, i.e. the
 1666:         ``@prefix@`` refer to the source directory for in-place builds.
 1667: 
 1668:         Examples
 1669:         --------
 1670:         ::
 1671: 
 1672:             config.add_npy_pkg_config('foo.ini.in', 'lib', {'foo': bar})
 1673: 
 1674:         Assuming the foo.ini.in file has the following content::
 1675: 
 1676:             [meta]
 1677:             Name=@foo@
 1678:             Version=1.0
 1679:             Description=dummy description
 1680: 
 1681:             [default]
 1682:             Cflags=-I@prefix@/include
 1683:             Libs=
 1684: 
 1685:         The generated file will have the following content::
 1686: 
 1687:             [meta]
 1688:             Name=bar
 1689:             Version=1.0
 1690:             Description=dummy description
 1691: 
 1692:             [default]
 1693:             Cflags=-Iprefix_dir/include
 1694:             Libs=
 1695: 
 1696:         and will be installed as foo.ini in the 'lib' subpath.
 1697: 
 1698:         When cross-compiling with numpy distutils, it might be necessary to
 1699:         use modified npy-pkg-config files.  Using the default/generated files
 1700:         will link with the host libraries (i.e. libnpymath.a).  For
 1701:         cross-compilation you of-course need to link with target libraries,
 1702:         while using the host Python installation.
 1703: 
 1704:         You can copy out the numpy/_core/lib/npy-pkg-config directory, add a
 1705:         pkgdir value to the .ini files and set NPY_PKG_CONFIG_PATH environment
 1706:         variable to point to the directory with the modified npy-pkg-config
 1707:         files.
 1708: 
 1709:         Example npymath.ini modified for cross-compilation::
 1710: 
 1711:             [meta]
 1712:             Name=npymath
 1713:             Description=Portable, core math library implementing C99 standard
 1714:             Version=0.1
 1715: 
 1716:             [variables]
 1717:             pkgname=numpy._core
 1718:             pkgdir=/build/arm-linux-gnueabi/sysroot/usr/lib/python3.7/site-packages/numpy/_core
 1719:             prefix=${pkgdir}
 1720:             libdir=${prefix}/lib
 1721:             includedir=${prefix}/include
 1722: 
 1723:             [default]
 1724:             Libs=-L${libdir} -lnpymath
 1725:             Cflags=-I${includedir}
 1726:             Requires=mlib
 1727: 
 1728:             [msvc]
 1729:             Libs=/LIBPATH:${libdir} npymath.lib
 1730:             Cflags=/INCLUDE:${includedir}
 1731:             Requires=mlib
 1732: 
 1733:         """
 1734:         if subst_dict is None:
 1735:             subst_dict = {}
 1736:         template = os.path.join(self.package_path, template)
 1737: 
 1738:         if self.name in self.installed_pkg_config:
 1739:             self.installed_pkg_config[self.name].append((template, install_dir,
 1740:                 subst_dict))
 1741:         else:
 1742:             self.installed_pkg_config[self.name] = [(template, install_dir,
 1743:                 subst_dict)]
 1744: 
 1745: 
 1746:     def add_scripts(self,*files):
 1747:         """Add scripts to configuration.
 1748: 
 1749:         Add the sequence of files to the beginning of the scripts list.
 1750:         Scripts will be installed under the <prefix>/bin/ directory.
 1751: 
 1752:         """
 1753:         scripts = self.paths(files)
 1754:         dist = self.get_distribution()
 1755:         if dist is not None:
 1756:             if dist.scripts is None:
 1757:                 dist.scripts = []
 1758:             dist.scripts.extend(scripts)
 1759:         else:
 1760:             self.scripts.extend(scripts)
 1761: 
 1762:     def dict_append(self,**dict):
 1763:         for key in self.list_keys:
 1764:             a = getattr(self, key)
 1765:             a.extend(dict.get(key, []))
 1766:         for key in self.dict_keys:
 1767:             a = getattr(self, key)
 1768:             a.update(dict.get(key, {}))
 1769:         known_keys = self.list_keys + self.dict_keys + self.extra_keys
 1770:         for key in dict.keys():
 1771:             if key not in known_keys:
 1772:                 a = getattr(self, key, None)
 1773:                 if a and a==dict[key]: continue
 1774:                 self.warn('Inheriting attribute %r=%r from %r' \
 1775:                           % (key, dict[key], dict.get('name', '?')))
 1776:                 setattr(self, key, dict[key])
 1777:                 self.extra_keys.append(key)
 1778:             elif key in self.extra_keys:
 1779:                 self.info('Ignoring attempt to set %r (from %r to %r)' \
 1780:                           % (key, getattr(self, key), dict[key]))
 1781:             elif key in known_keys:
 1782:                 # key is already processed above
 1783:                 pass
 1784:             else:
 1785:                 raise ValueError("Don't know about key=%r" % (key))
 1786: 
 1787:     def __str__(self):
 1788:         from pprint import pformat
 1789:         known_keys = self.list_keys + self.dict_keys + self.extra_keys
 1790:         s = '<'+5*'-' + '\n'
 1791:         s += 'Configuration of '+self.name+':\n'
 1792:         known_keys.sort()
 1793:         for k in known_keys:
 1794:             a = getattr(self, k, None)
 1795:             if a:
 1796:                 s += '%s = %s\n' % (k, pformat(a))
 1797:         s += 5*'-' + '>'
 1798:         return s
 1799: 
 1800:     def get_config_cmd(self):
 1801:         """
 1802:         Returns the numpy.distutils config command instance.
 1803:         """
 1804:         cmd = get_cmd('config')
 1805:         cmd.ensure_finalized()
 1806:         cmd.dump_source = 0
 1807:         cmd.noisy = 0
 1808:         old_path = os.environ.get('PATH')
 1809:         if old_path:
 1810:             path = os.pathsep.join(['.', old_path])
 1811:             os.environ['PATH'] = path
 1812:         return cmd
 1813: 
 1814:     def get_build_temp_dir(self):
 1815:         """
 1816:         Return a path to a temporary directory where temporary files should be
 1817:         placed.
 1818:         """
 1819:         cmd = get_cmd('build')
 1820:         cmd.ensure_finalized()
 1821:         return cmd.build_temp
 1822: 
 1823:     def have_f77c(self):
 1824:         """Check for availability of Fortran 77 compiler.
 1825: 
 1826:         Use it inside source generating function to ensure that
 1827:         setup distribution instance has been initialized.
 1828: 
 1829:         Notes
 1830:         -----
 1831:         True if a Fortran 77 compiler is available (because a simple Fortran 77
 1832:         code was able to be compiled successfully).
 1833:         """
 1834:         simple_fortran_subroutine = '''
 1835:         subroutine simple
 1836:         end
 1837:         '''
 1838:         config_cmd = self.get_config_cmd()
 1839:         flag = config_cmd.try_compile(simple_fortran_subroutine, lang='f77')
 1840:         return flag
 1841: 
 1842:     def have_f90c(self):
 1843:         """Check for availability of Fortran 90 compiler.
 1844: 
 1845:         Use it inside source generating function to ensure that
 1846:         setup distribution instance has been initialized.
 1847: 
 1848:         Notes
 1849:         -----
 1850:         True if a Fortran 90 compiler is available (because a simple Fortran
 1851:         90 code was able to be compiled successfully)
 1852:         """
 1853:         simple_fortran_subroutine = '''
 1854:         subroutine simple
 1855:         end
 1856:         '''
 1857:         config_cmd = self.get_config_cmd()
 1858:         flag = config_cmd.try_compile(simple_fortran_subroutine, lang='f90')
 1859:         return flag
 1860: 
 1861:     def append_to(self, extlib):
 1862:         """Append libraries, include_dirs to extension or library item.
 1863:         """
 1864:         if is_sequence(extlib):
 1865:             lib_name, build_info = extlib
 1866:             dict_append(build_info,
 1867:                         libraries=self.libraries,
 1868:                         include_dirs=self.include_dirs)
 1869:         else:
 1870:             from numpy.distutils.core import Extension
 1871:             assert isinstance(extlib, Extension), repr(extlib)
 1872:             extlib.libraries.extend(self.libraries)
 1873:             extlib.include_dirs.extend(self.include_dirs)
 1874: 
 1875:     def _get_svn_revision(self, path):
 1876:         """Return path's SVN revision number.
 1877:         """
 1878:         try:
 1879:             output = subprocess.check_output(['svnversion'], cwd=path)
 1880:         except (subprocess.CalledProcessError, OSError):
 1881:             pass
 1882:         else:
 1883:             m = re.match(rb'(?P<revision>\d+)', output)
 1884:             if m:
 1885:                 return int(m.group('revision'))
 1886: 
 1887:         if sys.platform=='win32' and os.environ.get('SVN_ASP_DOT_NET_HACK', None):
 1888:             entries = njoin(path, '_svn', 'entries')
 1889:         else:
 1890:             entries = njoin(path, '.svn', 'entries')
 1891:         if os.path.isfile(entries):
 1892:             with open(entries) as f:
 1893:                 fstr = f.read()
 1894:             if fstr[:5] == '<?xml':  # pre 1.4
 1895:                 m = re.search(r'revision="(?P<revision>\d+)"', fstr)
 1896:                 if m:
 1897:                     return int(m.group('revision'))
 1898:             else:  # non-xml entries file --- check to be sure that
 1899:                 m = re.search(r'dir[\n\r]+(?P<revision>\d+)', fstr)
 1900:                 if m:
 1901:                     return int(m.group('revision'))
 1902:         return None
 1903: 
 1904:     def _get_hg_revision(self, path):
 1905:         """Return path's Mercurial revision number.
 1906:         """
 1907:         try:
 1908:             output = subprocess.check_output(
 1909:                 ['hg', 'identify', '--num'], cwd=path)
 1910:         except (subprocess.CalledProcessError, OSError):
 1911:             pass
 1912:         else:
 1913:             m = re.match(rb'(?P<revision>\d+)', output)
 1914:             if m:
 1915:                 return int(m.group('revision'))
 1916: 
 1917:         branch_fn = njoin(path, '.hg', 'branch')
 1918:         branch_cache_fn = njoin(path, '.hg', 'branch.cache')
 1919: 
 1920:         if os.path.isfile(branch_fn):
 1921:             branch0 = None
 1922:             with open(branch_fn) as f:
 1923:                 revision0 = f.read().strip()
 1924: 
 1925:             branch_map = {}
 1926:             with open(branch_cache_fn) as f:
 1927:                 for line in f:
 1928:                     branch1, revision1  = line.split()[:2]
 1929:                     if revision1==revision0:
 1930:                         branch0 = branch1
 1931:                     try:
 1932:                         revision1 = int(revision1)
 1933:                     except ValueError:
 1934:                         continue
 1935:                     branch_map[branch1] = revision1
 1936: 
 1937:             return branch_map.get(branch0)
 1938: 
 1939:         return None
 1940: 
 1941: 
 1942:     def get_version(self, version_file=None, version_variable=None):
 1943:         """Try to get version string of a package.
 1944: 
 1945:         Return a version string of the current package or None if the version
 1946:         information could not be detected.
 1947: 
 1948:         Notes
 1949:         -----
 1950:         This method scans files named
 1951:         __version__.py, <packagename>_version.py, version.py, and
 1952:         __svn_version__.py for string variables version, __version__, and
 1953:         <packagename>_version, until a version number is found.
 1954:         """
 1955:         version = getattr(self, 'version', None)
 1956:         if version is not None:
 1957:             return version
 1958: 
 1959:         # Get version from version file.
 1960:         if version_file is None:
 1961:             files = ['__version__.py',
 1962:                      self.name.split('.')[-1]+'_version.py',
 1963:                      'version.py',
 1964:                      '__svn_version__.py',
 1965:                      '__hg_version__.py']
 1966:         else:
 1967:             files = [version_file]
 1968:         if version_variable is None:
 1969:             version_vars = ['version',
 1970:                             '__version__',
 1971:                             self.name.split('.')[-1]+'_version']
 1972:         else:
 1973:             version_vars = [version_variable]
 1974:         for f in files:
 1975:             fn = njoin(self.local_path, f)
 1976:             if os.path.isfile(fn):
 1977:                 info = ('.py', 'U', 1)
 1978:                 name = os.path.splitext(os.path.basename(fn))[0]
 1979:                 n = dot_join(self.name, name)
 1980:                 try:
 1981:                     version_module = exec_mod_from_location(
 1982:                                         '_'.join(n.split('.')), fn)
 1983:                 except ImportError as e:
 1984:                     self.warn(str(e))
 1985:                     version_module = None
 1986:                 if version_module is None:
 1987:                     continue
 1988: 
 1989:                 for a in version_vars:
 1990:                     version = getattr(version_module, a, None)
 1991:                     if version is not None:
 1992:                         break
 1993: 
 1994:                 # Try if versioneer module
 1995:                 try:
 1996:                     version = version_module.get_versions()['version']
 1997:                 except AttributeError:
 1998:                     pass
 1999: 
 2000:                 if version is not None:
 2001:                     break
 2002: 
 2003:         if version is not None:
 2004:             self.version = version
 2005:             return version
 2006: 
 2007:         # Get version as SVN or Mercurial revision number
 2008:         revision = self._get_svn_revision(self.local_path)
 2009:         if revision is None:
 2010:             revision = self._get_hg_revision(self.local_path)
 2011: 
 2012:         if revision is not None:
 2013:             version = str(revision)
 2014:             self.version = version
 2015: 
 2016:         return version
 2017: 
 2018:     def make_svn_version_py(self, delete=True):
 2019:         """Appends a data function to the data_files list that will generate
 2020:         __svn_version__.py file to the current package directory.
 2021: 
 2022:         Generate package __svn_version__.py file from SVN revision number,
 2023:         it will be removed after python exits but will be available
 2024:         when sdist, etc commands are executed.
 2025: 
 2026:         Notes
 2027:         -----
 2028:         If __svn_version__.py existed before, nothing is done.
 2029: 
 2030:         This is
 2031:         intended for working with source directories that are in an SVN
 2032:         repository.
 2033:         """
 2034:         target = njoin(self.local_path, '__svn_version__.py')
 2035:         revision = self._get_svn_revision(self.local_path)
 2036:         if os.path.isfile(target) or revision is None:
 2037:             return
 2038:         else:
 2039:             def generate_svn_version_py():
 2040:                 if not os.path.isfile(target):
 2041:                     version = str(revision)
 2042:                     self.info('Creating %s (version=%r)' % (target, version))
 2043:                     with open(target, 'w') as f:
 2044:                         f.write('version = %r\n' % (version))
 2045: 
 2046:                 def rm_file(f=target,p=self.info):
 2047:                     if delete:
 2048:                         try: os.remove(f); p('removed '+f)
 2049:                         except OSError: pass
 2050:                         try: os.remove(f+'c'); p('removed '+f+'c')
 2051:                         except OSError: pass
 2052: 
 2053:                 atexit.register(rm_file)
 2054: 
 2055:                 return target
 2056: 
 2057:             self.add_data_files(('', generate_svn_version_py()))
 2058: 
 2059:     def make_hg_version_py(self, delete=True):
 2060:         """Appends a data function to the data_files list that will generate
 2061:         __hg_version__.py file to the current package directory.
 2062: 
 2063:         Generate package __hg_version__.py file from Mercurial revision,
 2064:         it will be removed after python exits but will be available
 2065:         when sdist, etc commands are executed.
 2066: 
 2067:         Notes
 2068:         -----
 2069:         If __hg_version__.py existed before, nothing is done.
 2070: 
 2071:         This is intended for working with source directories that are
 2072:         in an Mercurial repository.
 2073:         """
 2074:         target = njoin(self.local_path, '__hg_version__.py')
 2075:         revision = self._get_hg_revision(self.local_path)
 2076:         if os.path.isfile(target) or revision is None:
 2077:             return
 2078:         else:
 2079:             def generate_hg_version_py():
 2080:                 if not os.path.isfile(target):
 2081:                     version = str(revision)
 2082:                     self.info('Creating %s (version=%r)' % (target, version))
 2083:                     with open(target, 'w') as f:
 2084:                         f.write('version = %r\n' % (version))
 2085: 
 2086:                 def rm_file(f=target,p=self.info):
 2087:                     if delete:
 2088:                         try: os.remove(f); p('removed '+f)
 2089:                         except OSError: pass
 2090:                         try: os.remove(f+'c'); p('removed '+f+'c')
 2091:                         except OSError: pass
 2092: 
 2093:                 atexit.register(rm_file)
 2094: 
 2095:                 return target
 2096: 
 2097:             self.add_data_files(('', generate_hg_version_py()))
 2098: 
 2099:     def make_config_py(self,name='__config__'):
 2100:         """Generate package __config__.py file containing system_info
 2101:         information used during building the package.
 2102: 
 2103:         This file is installed to the
 2104:         package installation directory.
 2105: 
 2106:         """
 2107:         self.py_modules.append((self.name, name, generate_config_py))
 2108: 
 2109:     def get_info(self,*names):
 2110:         """Get resources information.
 2111: 
 2112:         Return information (from system_info.get_info) for all of the names in
 2113:         the argument list in a single dictionary.
 2114:         """
 2115:         from .system_info import get_info, dict_append
 2116:         info_dict = {}
 2117:         for a in names:
 2118:             dict_append(info_dict,**get_info(a))
 2119:         return info_dict
 2120: 
 2121: 
 2122: def get_cmd(cmdname, _cache={}):
 2123:     if cmdname not in _cache:
 2124:         import distutils.core
 2125:         dist = distutils.core._setup_distribution
 2126:         if dist is None:
 2127:             from distutils.errors import DistutilsInternalError
 2128:             raise DistutilsInternalError(
 2129:                   'setup distribution instance not initialized')
 2130:         cmd = dist.get_command_obj(cmdname)
 2131:         _cache[cmdname] = cmd
 2132:     return _cache[cmdname]
 2133: 
 2134: def get_numpy_include_dirs():
 2135:     # numpy_include_dirs are set by numpy/_core/setup.py, otherwise []
 2136:     include_dirs = Configuration.numpy_include_dirs[:]
 2137:     if not include_dirs:
 2138:         import numpy
 2139:         include_dirs = [ numpy.get_include() ]
 2140:     # else running numpy/_core/setup.py
 2141:     return include_dirs
 2142: 
 2143: def get_npy_pkg_dir():
 2144:     """Return the path where to find the npy-pkg-config directory.
 2145: 
 2146:     If the NPY_PKG_CONFIG_PATH environment variable is set, the value of that
 2147:     is returned.  Otherwise, a path inside the location of the numpy module is
 2148:     returned.
 2149: 
 2150:     The NPY_PKG_CONFIG_PATH can be useful when cross-compiling, maintaining
 2151:     customized npy-pkg-config .ini files for the cross-compilation
 2152:     environment, and using them when cross-compiling.
 2153: 
 2154:     """
 2155:     d = os.environ.get('NPY_PKG_CONFIG_PATH')
 2156:     if d is not None:
 2157:         return d
 2158:     spec = importlib.util.find_spec('numpy')
 2159:     d = os.path.join(os.path.dirname(spec.origin),
 2160:             '_core', 'lib', 'npy-pkg-config')
 2161:     return d
 2162: 
 2163: def get_pkg_info(pkgname, dirs=None):
 2164:     """
 2165:     Return library info for the given package.
 2166: 
 2167:     Parameters
 2168:     ----------
 2169:     pkgname : str
 2170:         Name of the package (should match the name of the .ini file, without
 2171:         the extension, e.g. foo for the file foo.ini).
 2172:     dirs : sequence, optional
 2173:         If given, should be a sequence of additional directories where to look
 2174:         for npy-pkg-config files. Those directories are searched prior to the
 2175:         NumPy directory.
 2176: 
 2177:     Returns
 2178:     -------
 2179:     pkginfo : class instance
 2180:         The `LibraryInfo` instance containing the build information.
 2181: 
 2182:     Raises
 2183:     ------
 2184:     PkgNotFound
 2185:         If the package is not found.
 2186: 
 2187:     See Also
 2188:     --------
 2189:     Configuration.add_npy_pkg_config, Configuration.add_installed_library,
 2190:     get_info
 2191: 
 2192:     """
 2193:     from numpy.distutils.npy_pkg_config import read_config
 2194: 
 2195:     if dirs:
 2196:         dirs.append(get_npy_pkg_dir())
 2197:     else:
 2198:         dirs = [get_npy_pkg_dir()]
 2199:     return read_config(pkgname, dirs)
 2200: 
 2201: def get_info(pkgname, dirs=None):
 2202:     """
 2203:     Return an info dict for a given C library.
 2204: 
 2205:     The info dict contains the necessary options to use the C library.
 2206: 
 2207:     Parameters
 2208:     ----------
 2209:     pkgname : str
 2210:         Name of the package (should match the name of the .ini file, without
 2211:         the extension, e.g. foo for the file foo.ini).
 2212:     dirs : sequence, optional
 2213:         If given, should be a sequence of additional directories where to look
 2214:         for npy-pkg-config files. Those directories are searched prior to the
 2215:         NumPy directory.
 2216: 
 2217:     Returns
 2218:     -------
 2219:     info : dict
 2220:         The dictionary with build information.
 2221: 
 2222:     Raises
 2223:     ------
 2224:     PkgNotFound
 2225:         If the package is not found.
 2226: 
 2227:     See Also
 2228:     --------
 2229:     Configuration.add_npy_pkg_config, Configuration.add_installed_library,
 2230:     get_pkg_info
 2231: 
 2232:     Examples
 2233:     --------
 2234:     To get the necessary information for the npymath library from NumPy:
 2235: 
 2236:     >>> npymath_info = np.distutils.misc_util.get_info('npymath')
 2237:     >>> npymath_info                                    #doctest: +SKIP
 2238:     {'define_macros': [], 'libraries': ['npymath'], 'library_dirs':
 2239:     ['.../numpy/_core/lib'], 'include_dirs': ['.../numpy/_core/include']}
 2240: 
 2241:     This info dict can then be used as input to a `Configuration` instance::
 2242: 
 2243:       config.add_extension('foo', sources=['foo.c'], extra_info=npymath_info)
 2244: 
 2245:     """
 2246:     from numpy.distutils.npy_pkg_config import parse_flags
 2247:     pkg_info = get_pkg_info(pkgname, dirs)
 2248: 
 2249:     # Translate LibraryInfo instance into a build_info dict
 2250:     info = parse_flags(pkg_info.cflags())
 2251:     for k, v in parse_flags(pkg_info.libs()).items():
 2252:         info[k].extend(v)
 2253: 
 2254:     # add_extension extra_info argument is ANAL
 2255:     info['define_macros'] = info['macros']
 2256:     del info['macros']
 2257:     del info['ignored']
 2258: 
 2259:     return info
 2260: 
 2261: def is_bootstrapping():
 2262:     import builtins
 2263: 
 2264:     try:
 2265:         builtins.__NUMPY_SETUP__
 2266:         return True
 2267:     except AttributeError:
 2268:         return False
 2269: 
 2270: 
 2271: #########################
 2272: 
 2273: def default_config_dict(name = None, parent_name = None, local_path=None):
 2274:     """Return a configuration dictionary for usage in
 2275:     configuration() function defined in file setup_<name>.py.
 2276:     """
 2277:     import warnings
 2278:     warnings.warn('Use Configuration(%r,%r,top_path=%r) instead of '\
 2279:                   'deprecated default_config_dict(%r,%r,%r)'
 2280:                   % (name, parent_name, local_path,
 2281:                      name, parent_name, local_path,
 2282:                      ), stacklevel=2)
 2283:     c = Configuration(name, parent_name, local_path)
 2284:     return c.todict()
 2285: 
 2286: 
 2287: def dict_append(d, **kws):
 2288:     for k, v in kws.items():
 2289:         if k in d:
 2290:             ov = d[k]
 2291:             if isinstance(ov, str):
 2292:                 d[k] = v
 2293:             else:
 2294:                 d[k].extend(v)
 2295:         else:
 2296:             d[k] = v
 2297: 
 2298: def appendpath(prefix, path):
 2299:     if os.path.sep != '/':
 2300:         prefix = prefix.replace('/', os.path.sep)
 2301:         path = path.replace('/', os.path.sep)
 2302:     drive = ''
 2303:     if os.path.isabs(path):
 2304:         drive = os.path.splitdrive(prefix)[0]
 2305:         absprefix = os.path.splitdrive(os.path.abspath(prefix))[1]
 2306:         pathdrive, path = os.path.splitdrive(path)
 2307:         d = os.path.commonprefix([absprefix, path])
 2308:         if os.path.join(absprefix[:len(d)], absprefix[len(d):]) != absprefix \
 2309:            or os.path.join(path[:len(d)], path[len(d):]) != path:
 2310:             # Handle invalid paths
 2311:             d = os.path.dirname(d)
 2312:         subpath = path[len(d):]
 2313:         if os.path.isabs(subpath):
 2314:             subpath = subpath[1:]
 2315:     else:
 2316:         subpath = path
 2317:     return os.path.normpath(njoin(drive + prefix, subpath))
 2318: 
 2319: def generate_config_py(target):
 2320:     """Generate config.py file containing system_info information
 2321:     used during building the package.
 2322: 
 2323:     Usage:
 2324:         config['py_modules'].append((packagename, '__config__',generate_config_py))
 2325:     """
 2326:     from numpy.distutils.system_info import system_info
 2327:     from distutils.dir_util import mkpath
 2328:     mkpath(os.path.dirname(target))
 2329:     with open(target, 'w') as f:
 2330:         f.write('# This file is generated by numpy\'s %s\n' % (os.path.basename(sys.argv[0])))
 2331:         f.write('# It contains system_info results at the time of building this package.\n')
 2332:         f.write('__all__ = ["get_info","show"]\n\n')
 2333: 
 2334:         # For gfortran+msvc combination, extra shared libraries may exist
 2335:         f.write(textwrap.dedent("""
 2336:             import os
 2337:             import sys
 2338: 
 2339:             extra_dll_dir = os.path.join(os.path.dirname(__file__), '.libs')
 2340: 
 2341:             if sys.platform == 'win32' and os.path.isdir(extra_dll_dir):
 2342:                 os.add_dll_directory(extra_dll_dir)
 2343: 
 2344:             """))
 2345: 
 2346:         for k, i in system_info.saved_results.items():
 2347:             f.write('%s=%r\n' % (k, i))
 2348:         f.write(textwrap.dedent(r'''
 2349:             def get_info(name):
 2350:                 g = globals()
 2351:                 return g.get(name, g.get(name + "_info", {}))
 2352: 
 2353:             def show():
 2354:                 """
 2355:                 Show libraries in the system on which NumPy was built.
 2356: 
 2357:                 Print information about various resources (libraries, library
 2358:                 directories, include directories, etc.) in the system on which
 2359:                 NumPy was built.
 2360: 
 2361:                 See Also
 2362:                 --------
 2363:                 get_include : Returns the directory containing NumPy C
 2364:                               header files.
 2365: 
 2366:                 Notes
 2367:                 -----
 2368:                 1. Classes specifying the information to be printed are defined
 2369:                    in the `numpy.distutils.system_info` module.
 2370: 
 2371:                    Information may include:
 2372: 
 2373:                    * ``language``: language used to write the libraries (mostly
 2374:                      C or f77)
 2375:                    * ``libraries``: names of libraries found in the system
 2376:                    * ``library_dirs``: directories containing the libraries
 2377:                    * ``include_dirs``: directories containing library header files
 2378:                    * ``src_dirs``: directories containing library source files
 2379:                    * ``define_macros``: preprocessor macros used by
 2380:                      ``distutils.setup``
 2381:                    * ``baseline``: minimum CPU features required
 2382:                    * ``found``: dispatched features supported in the system
 2383:                    * ``not found``: dispatched features that are not supported
 2384:                      in the system
 2385: 
 2386:                 2. NumPy BLAS/LAPACK Installation Notes
 2387: 
 2388:                    Installing a numpy wheel (``pip install numpy`` or force it
 2389:                    via ``pip install numpy --only-binary :numpy: numpy``) includes
 2390:                    an OpenBLAS implementation of the BLAS and LAPACK linear algebra
 2391:                    APIs. In this case, ``library_dirs`` reports the original build
 2392:                    time configuration as compiled with gcc/gfortran; at run time
 2393:                    the OpenBLAS library is in
 2394:                    ``site-packages/numpy.libs/`` (linux), or
 2395:                    ``site-packages/numpy/.dylibs/`` (macOS), or
 2396:                    ``site-packages/numpy/.libs/`` (windows).
 2397: 
 2398:                    Installing numpy from source
 2399:                    (``pip install numpy --no-binary numpy``) searches for BLAS and
 2400:                    LAPACK dynamic link libraries at build time as influenced by
 2401:                    environment variables NPY_BLAS_LIBS, NPY_CBLAS_LIBS, and
 2402:                    NPY_LAPACK_LIBS; or NPY_BLAS_ORDER and NPY_LAPACK_ORDER;
 2403:                    or the optional file ``~/.numpy-site.cfg``.
 2404:                    NumPy remembers those locations and expects to load the same
 2405:                    libraries at run-time.
 2406:                    In NumPy 1.21+ on macOS, 'accelerate' (Apple's Accelerate BLAS
 2407:                    library) is in the default build-time search order after
 2408:                    'openblas'.
 2409: 
 2410:                 Examples
 2411:                 --------
 2412:                 >>> import numpy as np
 2413:                 >>> np.show_config()
 2414:                 blas_opt_info:
 2415:                     language = c
 2416:                     define_macros = [('HAVE_CBLAS', None)]
 2417:                     libraries = ['openblas', 'openblas']
 2418:                     library_dirs = ['/usr/local/lib']
 2419:                 """
 2420:                 from numpy._core._multiarray_umath import (
 2421:                     __cpu_features__, __cpu_baseline__, __cpu_dispatch__
 2422:                 )
 2423:                 for name,info_dict in globals().items():
 2424:                     if name[0] == "_" or type(info_dict) is not type({}): continue
 2425:                     print(name + ":")
 2426:                     if not info_dict:
 2427:                         print("  NOT AVAILABLE")
 2428:                     for k,v in info_dict.items():
 2429:                         v = str(v)
 2430:                         if k == "sources" and len(v) > 200:
 2431:                             v = v[:60] + " ...\n... " + v[-60:]
 2432:                         print("    %s = %s" % (k,v))
 2433: 
 2434:                 features_found, features_not_found = [], []
 2435:                 for feature in __cpu_dispatch__:
 2436:                     if __cpu_features__[feature]:
 2437:                         features_found.append(feature)
 2438:                     else:
 2439:                         features_not_found.append(feature)
 2440: 
 2441:                 print("Supported SIMD extensions in this NumPy install:")
 2442:                 print("    baseline = %s" % (','.join(__cpu_baseline__)))
 2443:                 print("    found = %s" % (','.join(features_found)))
 2444:                 print("    not found = %s" % (','.join(features_not_found)))
 2445: 
 2446:                     '''))
 2447: 
 2448:     return target
 2449: 
 2450: def msvc_version(compiler):
 2451:     """Return version major and minor of compiler instance if it is
 2452:     MSVC, raise an exception otherwise."""
 2453:     if not compiler.compiler_type == "msvc":
 2454:         raise ValueError("Compiler instance is not msvc (%s)"\
 2455:                          % compiler.compiler_type)
 2456:     return compiler._MSVCCompiler__version
 2457: 
 2458: def get_build_architecture():
 2459:     # Importing distutils.msvccompiler triggers a warning on non-Windows
 2460:     # systems, so delay the import to here.
 2461:     from distutils.msvccompiler import get_build_architecture
 2462:     return get_build_architecture()
 2463: 
 2464: 
 2465: _cxx_ignore_flags = {'-Werror=implicit-function-declaration', '-std=c99'}
 2466: 
 2467: 
 2468: def sanitize_cxx_flags(cxxflags):
 2469:     '''
 2470:     Some flags are valid for C but not C++. Prune them.
 2471:     '''
 2472:     return [flag for flag in cxxflags if flag not in _cxx_ignore_flags]
 2473: 
 2474: 
 2475: def exec_mod_from_location(modname, modfile):
 2476:     '''
 2477:     Use importlib machinery to import a module `modname` from the file
 2478:     `modfile`. Depending on the `spec.loader`, the module may not be
 2479:     registered in sys.modules.
 2480:     '''
 2481:     spec = importlib.util.spec_from_file_location(modname, modfile)
 2482:     foo = importlib.util.module_from_spec(spec)
 2483:     spec.loader.exec_module(foo)
 2484:     return foo
