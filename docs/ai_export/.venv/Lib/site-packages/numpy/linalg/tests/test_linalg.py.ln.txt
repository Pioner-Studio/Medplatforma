    1: """ Test functions for linalg module
    2: 
    3: """
    4: import itertools
    5: import os
    6: import subprocess
    7: import sys
    8: import textwrap
    9: import threading
   10: import traceback
   11: 
   12: import pytest
   13: 
   14: import numpy as np
   15: from numpy import (
   16:     array,
   17:     asarray,
   18:     atleast_2d,
   19:     cdouble,
   20:     csingle,
   21:     dot,
   22:     double,
   23:     identity,
   24:     inf,
   25:     linalg,
   26:     matmul,
   27:     multiply,
   28:     single,
   29: )
   30: from numpy._core import swapaxes
   31: from numpy.exceptions import AxisError
   32: from numpy.linalg import LinAlgError, matrix_power, matrix_rank, multi_dot, norm
   33: from numpy.linalg._linalg import _multi_dot_matrix_chain_order
   34: from numpy.testing import (
   35:     HAS_LAPACK64,
   36:     IS_WASM,
   37:     NOGIL_BUILD,
   38:     assert_,
   39:     assert_allclose,
   40:     assert_almost_equal,
   41:     assert_array_equal,
   42:     assert_equal,
   43:     assert_raises,
   44:     assert_raises_regex,
   45:     suppress_warnings,
   46: )
   47: 
   48: try:
   49:     import numpy.linalg.lapack_lite
   50: except ImportError:
   51:     # May be broken when numpy was built without BLAS/LAPACK present
   52:     # If so, ensure we don't break the whole test suite - the `lapack_lite`
   53:     # submodule should be removed, it's only used in two tests in this file.
   54:     pass
   55: 
   56: 
   57: def consistent_subclass(out, in_):
   58:     # For ndarray subclass input, our output should have the same subclass
   59:     # (non-ndarray input gets converted to ndarray).
   60:     return type(out) is (type(in_) if isinstance(in_, np.ndarray)
   61:                          else np.ndarray)
   62: 
   63: 
   64: old_assert_almost_equal = assert_almost_equal
   65: 
   66: 
   67: def assert_almost_equal(a, b, single_decimal=6, double_decimal=12, **kw):
   68:     if asarray(a).dtype.type in (single, csingle):
   69:         decimal = single_decimal
   70:     else:
   71:         decimal = double_decimal
   72:     old_assert_almost_equal(a, b, decimal=decimal, **kw)
   73: 
   74: 
   75: def get_real_dtype(dtype):
   76:     return {single: single, double: double,
   77:             csingle: single, cdouble: double}[dtype]
   78: 
   79: 
   80: def get_complex_dtype(dtype):
   81:     return {single: csingle, double: cdouble,
   82:             csingle: csingle, cdouble: cdouble}[dtype]
   83: 
   84: 
   85: def get_rtol(dtype):
   86:     # Choose a safe rtol
   87:     if dtype in (single, csingle):
   88:         return 1e-5
   89:     else:
   90:         return 1e-11
   91: 
   92: 
   93: # used to categorize tests
   94: all_tags = {
   95:   'square', 'nonsquare', 'hermitian',  # mutually exclusive
   96:   'generalized', 'size-0', 'strided'  # optional additions
   97: }
   98: 
   99: 
  100: class LinalgCase:
  101:     def __init__(self, name, a, b, tags=set()):
  102:         """
  103:         A bundle of arguments to be passed to a test case, with an identifying
  104:         name, the operands a and b, and a set of tags to filter the tests
  105:         """
  106:         assert_(isinstance(name, str))
  107:         self.name = name
  108:         self.a = a
  109:         self.b = b
  110:         self.tags = frozenset(tags)  # prevent shared tags
  111: 
  112:     def check(self, do):
  113:         """
  114:         Run the function `do` on this test case, expanding arguments
  115:         """
  116:         do(self.a, self.b, tags=self.tags)
  117: 
  118:     def __repr__(self):
  119:         return f'<LinalgCase: {self.name}>'
  120: 
  121: 
  122: def apply_tag(tag, cases):
  123:     """
  124:     Add the given tag (a string) to each of the cases (a list of LinalgCase
  125:     objects)
  126:     """
  127:     assert tag in all_tags, "Invalid tag"
  128:     for case in cases:
  129:         case.tags = case.tags | {tag}
  130:     return cases
  131: 
  132: 
  133: #
  134: # Base test cases
  135: #
  136: 
  137: np.random.seed(1234)
  138: 
  139: CASES = []
  140: 
  141: # square test cases
  142: CASES += apply_tag('square', [
  143:     LinalgCase("single",
  144:                array([[1., 2.], [3., 4.]], dtype=single),
  145:                array([2., 1.], dtype=single)),
  146:     LinalgCase("double",
  147:                array([[1., 2.], [3., 4.]], dtype=double),
  148:                array([2., 1.], dtype=double)),
  149:     LinalgCase("double_2",
  150:                array([[1., 2.], [3., 4.]], dtype=double),
  151:                array([[2., 1., 4.], [3., 4., 6.]], dtype=double)),
  152:     LinalgCase("csingle",
  153:                array([[1. + 2j, 2 + 3j], [3 + 4j, 4 + 5j]], dtype=csingle),
  154:                array([2. + 1j, 1. + 2j], dtype=csingle)),
  155:     LinalgCase("cdouble",
  156:                array([[1. + 2j, 2 + 3j], [3 + 4j, 4 + 5j]], dtype=cdouble),
  157:                array([2. + 1j, 1. + 2j], dtype=cdouble)),
  158:     LinalgCase("cdouble_2",
  159:                array([[1. + 2j, 2 + 3j], [3 + 4j, 4 + 5j]], dtype=cdouble),
  160:                array([[2. + 1j, 1. + 2j, 1 + 3j], [1 - 2j, 1 - 3j, 1 - 6j]], dtype=cdouble)),
  161:     LinalgCase("0x0",
  162:                np.empty((0, 0), dtype=double),
  163:                np.empty((0,), dtype=double),
  164:                tags={'size-0'}),
  165:     LinalgCase("8x8",
  166:                np.random.rand(8, 8),
  167:                np.random.rand(8)),
  168:     LinalgCase("1x1",
  169:                np.random.rand(1, 1),
  170:                np.random.rand(1)),
  171:     LinalgCase("nonarray",
  172:                [[1, 2], [3, 4]],
  173:                [2, 1]),
  174: ])
  175: 
  176: # non-square test-cases
  177: CASES += apply_tag('nonsquare', [
  178:     LinalgCase("single_nsq_1",
  179:                array([[1., 2., 3.], [3., 4., 6.]], dtype=single),
  180:                array([2., 1.], dtype=single)),
  181:     LinalgCase("single_nsq_2",
  182:                array([[1., 2.], [3., 4.], [5., 6.]], dtype=single),
  183:                array([2., 1., 3.], dtype=single)),
  184:     LinalgCase("double_nsq_1",
  185:                array([[1., 2., 3.], [3., 4., 6.]], dtype=double),
  186:                array([2., 1.], dtype=double)),
  187:     LinalgCase("double_nsq_2",
  188:                array([[1., 2.], [3., 4.], [5., 6.]], dtype=double),
  189:                array([2., 1., 3.], dtype=double)),
  190:     LinalgCase("csingle_nsq_1",
  191:                array(
  192:                    [[1. + 1j, 2. + 2j, 3. - 3j], [3. - 5j, 4. + 9j, 6. + 2j]], dtype=csingle),
  193:                array([2. + 1j, 1. + 2j], dtype=csingle)),
  194:     LinalgCase("csingle_nsq_2",
  195:                array(
  196:                    [[1. + 1j, 2. + 2j], [3. - 3j, 4. - 9j], [5. - 4j, 6. + 8j]], dtype=csingle),
  197:                array([2. + 1j, 1. + 2j, 3. - 3j], dtype=csingle)),
  198:     LinalgCase("cdouble_nsq_1",
  199:                array(
  200:                    [[1. + 1j, 2. + 2j, 3. - 3j], [3. - 5j, 4. + 9j, 6. + 2j]], dtype=cdouble),
  201:                array([2. + 1j, 1. + 2j], dtype=cdouble)),
  202:     LinalgCase("cdouble_nsq_2",
  203:                array(
  204:                    [[1. + 1j, 2. + 2j], [3. - 3j, 4. - 9j], [5. - 4j, 6. + 8j]], dtype=cdouble),
  205:                array([2. + 1j, 1. + 2j, 3. - 3j], dtype=cdouble)),
  206:     LinalgCase("cdouble_nsq_1_2",
  207:                array(
  208:                    [[1. + 1j, 2. + 2j, 3. - 3j], [3. - 5j, 4. + 9j, 6. + 2j]], dtype=cdouble),
  209:                array([[2. + 1j, 1. + 2j], [1 - 1j, 2 - 2j]], dtype=cdouble)),
  210:     LinalgCase("cdouble_nsq_2_2",
  211:                array(
  212:                    [[1. + 1j, 2. + 2j], [3. - 3j, 4. - 9j], [5. - 4j, 6. + 8j]], dtype=cdouble),
  213:                array([[2. + 1j, 1. + 2j], [1 - 1j, 2 - 2j], [1 - 1j, 2 - 2j]], dtype=cdouble)),
  214:     LinalgCase("8x11",
  215:                np.random.rand(8, 11),
  216:                np.random.rand(8)),
  217:     LinalgCase("1x5",
  218:                np.random.rand(1, 5),
  219:                np.random.rand(1)),
  220:     LinalgCase("5x1",
  221:                np.random.rand(5, 1),
  222:                np.random.rand(5)),
  223:     LinalgCase("0x4",
  224:                np.random.rand(0, 4),
  225:                np.random.rand(0),
  226:                tags={'size-0'}),
  227:     LinalgCase("4x0",
  228:                np.random.rand(4, 0),
  229:                np.random.rand(4),
  230:                tags={'size-0'}),
  231: ])
  232: 
  233: # hermitian test-cases
  234: CASES += apply_tag('hermitian', [
  235:     LinalgCase("hsingle",
  236:                array([[1., 2.], [2., 1.]], dtype=single),
  237:                None),
  238:     LinalgCase("hdouble",
  239:                array([[1., 2.], [2., 1.]], dtype=double),
  240:                None),
  241:     LinalgCase("hcsingle",
  242:                array([[1., 2 + 3j], [2 - 3j, 1]], dtype=csingle),
  243:                None),
  244:     LinalgCase("hcdouble",
  245:                array([[1., 2 + 3j], [2 - 3j, 1]], dtype=cdouble),
  246:                None),
  247:     LinalgCase("hempty",
  248:                np.empty((0, 0), dtype=double),
  249:                None,
  250:                tags={'size-0'}),
  251:     LinalgCase("hnonarray",
  252:                [[1, 2], [2, 1]],
  253:                None),
  254:     LinalgCase("matrix_b_only",
  255:                array([[1., 2.], [2., 1.]]),
  256:                None),
  257:     LinalgCase("hmatrix_1x1",
  258:                np.random.rand(1, 1),
  259:                None),
  260: ])
  261: 
  262: 
  263: #
  264: # Gufunc test cases
  265: #
  266: def _make_generalized_cases():
  267:     new_cases = []
  268: 
  269:     for case in CASES:
  270:         if not isinstance(case.a, np.ndarray):
  271:             continue
  272: 
  273:         a = np.array([case.a, 2 * case.a, 3 * case.a])
  274:         if case.b is None:
  275:             b = None
  276:         elif case.b.ndim == 1:
  277:             b = case.b
  278:         else:
  279:             b = np.array([case.b, 7 * case.b, 6 * case.b])
  280:         new_case = LinalgCase(case.name + "_tile3", a, b,
  281:                               tags=case.tags | {'generalized'})
  282:         new_cases.append(new_case)
  283: 
  284:         a = np.array([case.a] * 2 * 3).reshape((3, 2) + case.a.shape)
  285:         if case.b is None:
  286:             b = None
  287:         elif case.b.ndim == 1:
  288:             b = np.array([case.b] * 2 * 3 * a.shape[-1])\
  289:                   .reshape((3, 2) + case.a.shape[-2:])
  290:         else:
  291:             b = np.array([case.b] * 2 * 3).reshape((3, 2) + case.b.shape)
  292:         new_case = LinalgCase(case.name + "_tile213", a, b,
  293:                               tags=case.tags | {'generalized'})
  294:         new_cases.append(new_case)
  295: 
  296:     return new_cases
  297: 
  298: 
  299: CASES += _make_generalized_cases()
  300: 
  301: 
  302: #
  303: # Generate stride combination variations of the above
  304: #
  305: def _stride_comb_iter(x):
  306:     """
  307:     Generate cartesian product of strides for all axes
  308:     """
  309: 
  310:     if not isinstance(x, np.ndarray):
  311:         yield x, "nop"
  312:         return
  313: 
  314:     stride_set = [(1,)] * x.ndim
  315:     stride_set[-1] = (1, 3, -4)
  316:     if x.ndim > 1:
  317:         stride_set[-2] = (1, 3, -4)
  318:     if x.ndim > 2:
  319:         stride_set[-3] = (1, -4)
  320: 
  321:     for repeats in itertools.product(*tuple(stride_set)):
  322:         new_shape = [abs(a * b) for a, b in zip(x.shape, repeats)]
  323:         slices = tuple(slice(None, None, repeat) for repeat in repeats)
  324: 
  325:         # new array with different strides, but same data
  326:         xi = np.empty(new_shape, dtype=x.dtype)
  327:         xi.view(np.uint32).fill(0xdeadbeef)
  328:         xi = xi[slices]
  329:         xi[...] = x
  330:         xi = xi.view(x.__class__)
  331:         assert_(np.all(xi == x))
  332:         yield xi, "stride_" + "_".join(["%+d" % j for j in repeats])
  333: 
  334:         # generate also zero strides if possible
  335:         if x.ndim >= 1 and x.shape[-1] == 1:
  336:             s = list(x.strides)
  337:             s[-1] = 0
  338:             xi = np.lib.stride_tricks.as_strided(x, strides=s)
  339:             yield xi, "stride_xxx_0"
  340:         if x.ndim >= 2 and x.shape[-2] == 1:
  341:             s = list(x.strides)
  342:             s[-2] = 0
  343:             xi = np.lib.stride_tricks.as_strided(x, strides=s)
  344:             yield xi, "stride_xxx_0_x"
  345:         if x.ndim >= 2 and x.shape[:-2] == (1, 1):
  346:             s = list(x.strides)
  347:             s[-1] = 0
  348:             s[-2] = 0
  349:             xi = np.lib.stride_tricks.as_strided(x, strides=s)
  350:             yield xi, "stride_xxx_0_0"
  351: 
  352: 
  353: def _make_strided_cases():
  354:     new_cases = []
  355:     for case in CASES:
  356:         for a, a_label in _stride_comb_iter(case.a):
  357:             for b, b_label in _stride_comb_iter(case.b):
  358:                 new_case = LinalgCase(case.name + "_" + a_label + "_" + b_label, a, b,
  359:                                       tags=case.tags | {'strided'})
  360:                 new_cases.append(new_case)
  361:     return new_cases
  362: 
  363: 
  364: CASES += _make_strided_cases()
  365: 
  366: 
  367: #
  368: # Test different routines against the above cases
  369: #
  370: class LinalgTestCase:
  371:     TEST_CASES = CASES
  372: 
  373:     def check_cases(self, require=set(), exclude=set()):
  374:         """
  375:         Run func on each of the cases with all of the tags in require, and none
  376:         of the tags in exclude
  377:         """
  378:         for case in self.TEST_CASES:
  379:             # filter by require and exclude
  380:             if case.tags & require != require:
  381:                 continue
  382:             if case.tags & exclude:
  383:                 continue
  384: 
  385:             try:
  386:                 case.check(self.do)
  387:             except Exception as e:
  388:                 msg = f'In test case: {case!r}\n\n'
  389:                 msg += traceback.format_exc()
  390:                 raise AssertionError(msg) from e
  391: 
  392: 
  393: class LinalgSquareTestCase(LinalgTestCase):
  394: 
  395:     def test_sq_cases(self):
  396:         self.check_cases(require={'square'},
  397:                          exclude={'generalized', 'size-0'})
  398: 
  399:     def test_empty_sq_cases(self):
  400:         self.check_cases(require={'square', 'size-0'},
  401:                          exclude={'generalized'})
  402: 
  403: 
  404: class LinalgNonsquareTestCase(LinalgTestCase):
  405: 
  406:     def test_nonsq_cases(self):
  407:         self.check_cases(require={'nonsquare'},
  408:                          exclude={'generalized', 'size-0'})
  409: 
  410:     def test_empty_nonsq_cases(self):
  411:         self.check_cases(require={'nonsquare', 'size-0'},
  412:                          exclude={'generalized'})
  413: 
  414: 
  415: class HermitianTestCase(LinalgTestCase):
  416: 
  417:     def test_herm_cases(self):
  418:         self.check_cases(require={'hermitian'},
  419:                          exclude={'generalized', 'size-0'})
  420: 
  421:     def test_empty_herm_cases(self):
  422:         self.check_cases(require={'hermitian', 'size-0'},
  423:                          exclude={'generalized'})
  424: 
  425: 
  426: class LinalgGeneralizedSquareTestCase(LinalgTestCase):
  427: 
  428:     @pytest.mark.slow
  429:     def test_generalized_sq_cases(self):
  430:         self.check_cases(require={'generalized', 'square'},
  431:                          exclude={'size-0'})
  432: 
  433:     @pytest.mark.slow
  434:     def test_generalized_empty_sq_cases(self):
  435:         self.check_cases(require={'generalized', 'square', 'size-0'})
  436: 
  437: 
  438: class LinalgGeneralizedNonsquareTestCase(LinalgTestCase):
  439: 
  440:     @pytest.mark.slow
  441:     def test_generalized_nonsq_cases(self):
  442:         self.check_cases(require={'generalized', 'nonsquare'},
  443:                          exclude={'size-0'})
  444: 
  445:     @pytest.mark.slow
  446:     def test_generalized_empty_nonsq_cases(self):
  447:         self.check_cases(require={'generalized', 'nonsquare', 'size-0'})
  448: 
  449: 
  450: class HermitianGeneralizedTestCase(LinalgTestCase):
  451: 
  452:     @pytest.mark.slow
  453:     def test_generalized_herm_cases(self):
  454:         self.check_cases(require={'generalized', 'hermitian'},
  455:                          exclude={'size-0'})
  456: 
  457:     @pytest.mark.slow
  458:     def test_generalized_empty_herm_cases(self):
  459:         self.check_cases(require={'generalized', 'hermitian', 'size-0'},
  460:                          exclude={'none'})
  461: 
  462: 
  463: def identity_like_generalized(a):
  464:     a = asarray(a)
  465:     if a.ndim >= 3:
  466:         r = np.empty(a.shape, dtype=a.dtype)
  467:         r[...] = identity(a.shape[-2])
  468:         return r
  469:     else:
  470:         return identity(a.shape[0])
  471: 
  472: 
  473: class SolveCases(LinalgSquareTestCase, LinalgGeneralizedSquareTestCase):
  474:     # kept apart from TestSolve for use for testing with matrices.
  475:     def do(self, a, b, tags):
  476:         x = linalg.solve(a, b)
  477:         if np.array(b).ndim == 1:
  478:             # When a is (..., M, M) and b is (M,), it is the same as when b is
  479:             # (M, 1), except the result has shape (..., M)
  480:             adotx = matmul(a, x[..., None])[..., 0]
  481:             assert_almost_equal(np.broadcast_to(b, adotx.shape), adotx)
  482:         else:
  483:             adotx = matmul(a, x)
  484:             assert_almost_equal(b, adotx)
  485:         assert_(consistent_subclass(x, b))
  486: 
  487: 
  488: class TestSolve(SolveCases):
  489:     @pytest.mark.parametrize('dtype', [single, double, csingle, cdouble])
  490:     def test_types(self, dtype):
  491:         x = np.array([[1, 0.5], [0.5, 1]], dtype=dtype)
  492:         assert_equal(linalg.solve(x, x).dtype, dtype)
  493: 
  494:     def test_1_d(self):
  495:         class ArraySubclass(np.ndarray):
  496:             pass
  497:         a = np.arange(8).reshape(2, 2, 2)
  498:         b = np.arange(2).view(ArraySubclass)
  499:         result = linalg.solve(a, b)
  500:         assert result.shape == (2, 2)
  501: 
  502:         # If b is anything other than 1-D it should be treated as a stack of
  503:         # matrices
  504:         b = np.arange(4).reshape(2, 2).view(ArraySubclass)
  505:         result = linalg.solve(a, b)
  506:         assert result.shape == (2, 2, 2)
  507: 
  508:         b = np.arange(2).reshape(1, 2).view(ArraySubclass)
  509:         assert_raises(ValueError, linalg.solve, a, b)
  510: 
  511:     def test_0_size(self):
  512:         class ArraySubclass(np.ndarray):
  513:             pass
  514:         # Test system of 0x0 matrices
  515:         a = np.arange(8).reshape(2, 2, 2)
  516:         b = np.arange(6).reshape(1, 2, 3).view(ArraySubclass)
  517: 
  518:         expected = linalg.solve(a, b)[:, 0:0, :]
  519:         result = linalg.solve(a[:, 0:0, 0:0], b[:, 0:0, :])
  520:         assert_array_equal(result, expected)
  521:         assert_(isinstance(result, ArraySubclass))
  522: 
  523:         # Test errors for non-square and only b's dimension being 0
  524:         assert_raises(linalg.LinAlgError, linalg.solve, a[:, 0:0, 0:1], b)
  525:         assert_raises(ValueError, linalg.solve, a, b[:, 0:0, :])
  526: 
  527:         # Test broadcasting error
  528:         b = np.arange(6).reshape(1, 3, 2)  # broadcasting error
  529:         assert_raises(ValueError, linalg.solve, a, b)
  530:         assert_raises(ValueError, linalg.solve, a[0:0], b[0:0])
  531: 
  532:         # Test zero "single equations" with 0x0 matrices.
  533:         b = np.arange(2).view(ArraySubclass)
  534:         expected = linalg.solve(a, b)[:, 0:0]
  535:         result = linalg.solve(a[:, 0:0, 0:0], b[0:0])
  536:         assert_array_equal(result, expected)
  537:         assert_(isinstance(result, ArraySubclass))
  538: 
  539:         b = np.arange(3).reshape(1, 3)
  540:         assert_raises(ValueError, linalg.solve, a, b)
  541:         assert_raises(ValueError, linalg.solve, a[0:0], b[0:0])
  542:         assert_raises(ValueError, linalg.solve, a[:, 0:0, 0:0], b)
  543: 
  544:     def test_0_size_k(self):
  545:         # test zero multiple equation (K=0) case.
  546:         class ArraySubclass(np.ndarray):
  547:             pass
  548:         a = np.arange(4).reshape(1, 2, 2)
  549:         b = np.arange(6).reshape(3, 2, 1).view(ArraySubclass)
  550: 
  551:         expected = linalg.solve(a, b)[:, :, 0:0]
  552:         result = linalg.solve(a, b[:, :, 0:0])
  553:         assert_array_equal(result, expected)
  554:         assert_(isinstance(result, ArraySubclass))
  555: 
  556:         # test both zero.
  557:         expected = linalg.solve(a, b)[:, 0:0, 0:0]
  558:         result = linalg.solve(a[:, 0:0, 0:0], b[:, 0:0, 0:0])
  559:         assert_array_equal(result, expected)
  560:         assert_(isinstance(result, ArraySubclass))
  561: 
  562: 
  563: class InvCases(LinalgSquareTestCase, LinalgGeneralizedSquareTestCase):
  564: 
  565:     def do(self, a, b, tags):
  566:         a_inv = linalg.inv(a)
  567:         assert_almost_equal(matmul(a, a_inv),
  568:                             identity_like_generalized(a))
  569:         assert_(consistent_subclass(a_inv, a))
  570: 
  571: 
  572: class TestInv(InvCases):
  573:     @pytest.mark.parametrize('dtype', [single, double, csingle, cdouble])
  574:     def test_types(self, dtype):
  575:         x = np.array([[1, 0.5], [0.5, 1]], dtype=dtype)
  576:         assert_equal(linalg.inv(x).dtype, dtype)
  577: 
  578:     def test_0_size(self):
  579:         # Check that all kinds of 0-sized arrays work
  580:         class ArraySubclass(np.ndarray):
  581:             pass
  582:         a = np.zeros((0, 1, 1), dtype=np.int_).view(ArraySubclass)
  583:         res = linalg.inv(a)
  584:         assert_(res.dtype.type is np.float64)
  585:         assert_equal(a.shape, res.shape)
  586:         assert_(isinstance(res, ArraySubclass))
  587: 
  588:         a = np.zeros((0, 0), dtype=np.complex64).view(ArraySubclass)
  589:         res = linalg.inv(a)
  590:         assert_(res.dtype.type is np.complex64)
  591:         assert_equal(a.shape, res.shape)
  592:         assert_(isinstance(res, ArraySubclass))
  593: 
  594: 
  595: class EigvalsCases(LinalgSquareTestCase, LinalgGeneralizedSquareTestCase):
  596: 
  597:     def do(self, a, b, tags):
  598:         ev = linalg.eigvals(a)
  599:         evalues, evectors = linalg.eig(a)
  600:         assert_almost_equal(ev, evalues)
  601: 
  602: 
  603: class TestEigvals(EigvalsCases):
  604:     @pytest.mark.parametrize('dtype', [single, double, csingle, cdouble])
  605:     def test_types(self, dtype):
  606:         x = np.array([[1, 0.5], [0.5, 1]], dtype=dtype)
  607:         assert_equal(linalg.eigvals(x).dtype, dtype)
  608:         x = np.array([[1, 0.5], [-1, 1]], dtype=dtype)
  609:         assert_equal(linalg.eigvals(x).dtype, get_complex_dtype(dtype))
  610: 
  611:     def test_0_size(self):
  612:         # Check that all kinds of 0-sized arrays work
  613:         class ArraySubclass(np.ndarray):
  614:             pass
  615:         a = np.zeros((0, 1, 1), dtype=np.int_).view(ArraySubclass)
  616:         res = linalg.eigvals(a)
  617:         assert_(res.dtype.type is np.float64)
  618:         assert_equal((0, 1), res.shape)
  619:         # This is just for documentation, it might make sense to change:
  620:         assert_(isinstance(res, np.ndarray))
  621: 
  622:         a = np.zeros((0, 0), dtype=np.complex64).view(ArraySubclass)
  623:         res = linalg.eigvals(a)
  624:         assert_(res.dtype.type is np.complex64)
  625:         assert_equal((0,), res.shape)
  626:         # This is just for documentation, it might make sense to change:
  627:         assert_(isinstance(res, np.ndarray))
  628: 
  629: 
  630: class EigCases(LinalgSquareTestCase, LinalgGeneralizedSquareTestCase):
  631: 
  632:     def do(self, a, b, tags):
  633:         res = linalg.eig(a)
  634:         eigenvalues, eigenvectors = res.eigenvalues, res.eigenvectors
  635:         assert_allclose(matmul(a, eigenvectors),
  636:                         np.asarray(eigenvectors) * np.asarray(eigenvalues)[..., None, :],
  637:                         rtol=get_rtol(eigenvalues.dtype))
  638:         assert_(consistent_subclass(eigenvectors, a))
  639: 
  640: 
  641: class TestEig(EigCases):
  642:     @pytest.mark.parametrize('dtype', [single, double, csingle, cdouble])
  643:     def test_types(self, dtype):
  644:         x = np.array([[1, 0.5], [0.5, 1]], dtype=dtype)
  645:         w, v = np.linalg.eig(x)
  646:         assert_equal(w.dtype, dtype)
  647:         assert_equal(v.dtype, dtype)
  648: 
  649:         x = np.array([[1, 0.5], [-1, 1]], dtype=dtype)
  650:         w, v = np.linalg.eig(x)
  651:         assert_equal(w.dtype, get_complex_dtype(dtype))
  652:         assert_equal(v.dtype, get_complex_dtype(dtype))
  653: 
  654:     def test_0_size(self):
  655:         # Check that all kinds of 0-sized arrays work
  656:         class ArraySubclass(np.ndarray):
  657:             pass
  658:         a = np.zeros((0, 1, 1), dtype=np.int_).view(ArraySubclass)
  659:         res, res_v = linalg.eig(a)
  660:         assert_(res_v.dtype.type is np.float64)
  661:         assert_(res.dtype.type is np.float64)
  662:         assert_equal(a.shape, res_v.shape)
  663:         assert_equal((0, 1), res.shape)
  664:         # This is just for documentation, it might make sense to change:
  665:         assert_(isinstance(a, np.ndarray))
  666: 
  667:         a = np.zeros((0, 0), dtype=np.complex64).view(ArraySubclass)
  668:         res, res_v = linalg.eig(a)
  669:         assert_(res_v.dtype.type is np.complex64)
  670:         assert_(res.dtype.type is np.complex64)
  671:         assert_equal(a.shape, res_v.shape)
  672:         assert_equal((0,), res.shape)
  673:         # This is just for documentation, it might make sense to change:
  674:         assert_(isinstance(a, np.ndarray))
  675: 
  676: 
  677: class SVDBaseTests:
  678:     hermitian = False
  679: 
  680:     @pytest.mark.parametrize('dtype', [single, double, csingle, cdouble])
  681:     def test_types(self, dtype):
  682:         x = np.array([[1, 0.5], [0.5, 1]], dtype=dtype)
  683:         res = linalg.svd(x)
  684:         U, S, Vh = res.U, res.S, res.Vh
  685:         assert_equal(U.dtype, dtype)
  686:         assert_equal(S.dtype, get_real_dtype(dtype))
  687:         assert_equal(Vh.dtype, dtype)
  688:         s = linalg.svd(x, compute_uv=False, hermitian=self.hermitian)
  689:         assert_equal(s.dtype, get_real_dtype(dtype))
  690: 
  691: 
  692: class SVDCases(LinalgSquareTestCase, LinalgGeneralizedSquareTestCase):
  693: 
  694:     def do(self, a, b, tags):
  695:         u, s, vt = linalg.svd(a, False)
  696:         assert_allclose(a, matmul(np.asarray(u) * np.asarray(s)[..., None, :],
  697:                                            np.asarray(vt)),
  698:                         rtol=get_rtol(u.dtype))
  699:         assert_(consistent_subclass(u, a))
  700:         assert_(consistent_subclass(vt, a))
  701: 
  702: 
  703: class TestSVD(SVDCases, SVDBaseTests):
  704:     def test_empty_identity(self):
  705:         """ Empty input should put an identity matrix in u or vh """
  706:         x = np.empty((4, 0))
  707:         u, s, vh = linalg.svd(x, compute_uv=True, hermitian=self.hermitian)
  708:         assert_equal(u.shape, (4, 4))
  709:         assert_equal(vh.shape, (0, 0))
  710:         assert_equal(u, np.eye(4))
  711: 
  712:         x = np.empty((0, 4))
  713:         u, s, vh = linalg.svd(x, compute_uv=True, hermitian=self.hermitian)
  714:         assert_equal(u.shape, (0, 0))
  715:         assert_equal(vh.shape, (4, 4))
  716:         assert_equal(vh, np.eye(4))
  717: 
  718:     def test_svdvals(self):
  719:         x = np.array([[1, 0.5], [0.5, 1]])
  720:         s_from_svd = linalg.svd(x, compute_uv=False, hermitian=self.hermitian)
  721:         s_from_svdvals = linalg.svdvals(x)
  722:         assert_almost_equal(s_from_svd, s_from_svdvals)
  723: 
  724: 
  725: class SVDHermitianCases(HermitianTestCase, HermitianGeneralizedTestCase):
  726: 
  727:     def do(self, a, b, tags):
  728:         u, s, vt = linalg.svd(a, False, hermitian=True)
  729:         assert_allclose(a, matmul(np.asarray(u) * np.asarray(s)[..., None, :],
  730:                                            np.asarray(vt)),
  731:                         rtol=get_rtol(u.dtype))
  732: 
  733:         def hermitian(mat):
  734:             axes = list(range(mat.ndim))
  735:             axes[-1], axes[-2] = axes[-2], axes[-1]
  736:             return np.conj(np.transpose(mat, axes=axes))
  737: 
  738:         assert_almost_equal(np.matmul(u, hermitian(u)), np.broadcast_to(np.eye(u.shape[-1]), u.shape))
  739:         assert_almost_equal(np.matmul(vt, hermitian(vt)), np.broadcast_to(np.eye(vt.shape[-1]), vt.shape))
  740:         assert_equal(np.sort(s)[..., ::-1], s)
  741:         assert_(consistent_subclass(u, a))
  742:         assert_(consistent_subclass(vt, a))
  743: 
  744: 
  745: class TestSVDHermitian(SVDHermitianCases, SVDBaseTests):
  746:     hermitian = True
  747: 
  748: 
  749: class CondCases(LinalgSquareTestCase, LinalgGeneralizedSquareTestCase):
  750:     # cond(x, p) for p in (None, 2, -2)
  751: 
  752:     def do(self, a, b, tags):
  753:         c = asarray(a)  # a might be a matrix
  754:         if 'size-0' in tags:
  755:             assert_raises(LinAlgError, linalg.cond, c)
  756:             return
  757: 
  758:         # +-2 norms
  759:         s = linalg.svd(c, compute_uv=False)
  760:         assert_almost_equal(
  761:             linalg.cond(a), s[..., 0] / s[..., -1],
  762:             single_decimal=5, double_decimal=11)
  763:         assert_almost_equal(
  764:             linalg.cond(a, 2), s[..., 0] / s[..., -1],
  765:             single_decimal=5, double_decimal=11)
  766:         assert_almost_equal(
  767:             linalg.cond(a, -2), s[..., -1] / s[..., 0],
  768:             single_decimal=5, double_decimal=11)
  769: 
  770:         # Other norms
  771:         cinv = np.linalg.inv(c)
  772:         assert_almost_equal(
  773:             linalg.cond(a, 1),
  774:             abs(c).sum(-2).max(-1) * abs(cinv).sum(-2).max(-1),
  775:             single_decimal=5, double_decimal=11)
  776:         assert_almost_equal(
  777:             linalg.cond(a, -1),
  778:             abs(c).sum(-2).min(-1) * abs(cinv).sum(-2).min(-1),
  779:             single_decimal=5, double_decimal=11)
  780:         assert_almost_equal(
  781:             linalg.cond(a, np.inf),
  782:             abs(c).sum(-1).max(-1) * abs(cinv).sum(-1).max(-1),
  783:             single_decimal=5, double_decimal=11)
  784:         assert_almost_equal(
  785:             linalg.cond(a, -np.inf),
  786:             abs(c).sum(-1).min(-1) * abs(cinv).sum(-1).min(-1),
  787:             single_decimal=5, double_decimal=11)
  788:         assert_almost_equal(
  789:             linalg.cond(a, 'fro'),
  790:             np.sqrt((abs(c)**2).sum(-1).sum(-1)
  791:                     * (abs(cinv)**2).sum(-1).sum(-1)),
  792:             single_decimal=5, double_decimal=11)
  793: 
  794: 
  795: class TestCond(CondCases):
  796:     def test_basic_nonsvd(self):
  797:         # Smoketest the non-svd norms
  798:         A = array([[1., 0, 1], [0, -2., 0], [0, 0, 3.]])
  799:         assert_almost_equal(linalg.cond(A, inf), 4)
  800:         assert_almost_equal(linalg.cond(A, -inf), 2 / 3)
  801:         assert_almost_equal(linalg.cond(A, 1), 4)
  802:         assert_almost_equal(linalg.cond(A, -1), 0.5)
  803:         assert_almost_equal(linalg.cond(A, 'fro'), np.sqrt(265 / 12))
  804: 
  805:     def test_singular(self):
  806:         # Singular matrices have infinite condition number for
  807:         # positive norms, and negative norms shouldn't raise
  808:         # exceptions
  809:         As = [np.zeros((2, 2)), np.ones((2, 2))]
  810:         p_pos = [None, 1, 2, 'fro']
  811:         p_neg = [-1, -2]
  812:         for A, p in itertools.product(As, p_pos):
  813:             # Inversion may not hit exact infinity, so just check the
  814:             # number is large
  815:             assert_(linalg.cond(A, p) > 1e15)
  816:         for A, p in itertools.product(As, p_neg):
  817:             linalg.cond(A, p)
  818: 
  819:     @pytest.mark.xfail(True, run=False,
  820:                        reason="Platform/LAPACK-dependent failure, "
  821:                               "see gh-18914")
  822:     def test_nan(self):
  823:         # nans should be passed through, not converted to infs
  824:         ps = [None, 1, -1, 2, -2, 'fro']
  825:         p_pos = [None, 1, 2, 'fro']
  826: 
  827:         A = np.ones((2, 2))
  828:         A[0, 1] = np.nan
  829:         for p in ps:
  830:             c = linalg.cond(A, p)
  831:             assert_(isinstance(c, np.float64))
  832:             assert_(np.isnan(c))
  833: 
  834:         A = np.ones((3, 2, 2))
  835:         A[1, 0, 1] = np.nan
  836:         for p in ps:
  837:             c = linalg.cond(A, p)
  838:             assert_(np.isnan(c[1]))
  839:             if p in p_pos:
  840:                 assert_(c[0] > 1e15)
  841:                 assert_(c[2] > 1e15)
  842:             else:
  843:                 assert_(not np.isnan(c[0]))
  844:                 assert_(not np.isnan(c[2]))
  845: 
  846:     def test_stacked_singular(self):
  847:         # Check behavior when only some of the stacked matrices are
  848:         # singular
  849:         np.random.seed(1234)
  850:         A = np.random.rand(2, 2, 2, 2)
  851:         A[0, 0] = 0
  852:         A[1, 1] = 0
  853: 
  854:         for p in (None, 1, 2, 'fro', -1, -2):
  855:             c = linalg.cond(A, p)
  856:             assert_equal(c[0, 0], np.inf)
  857:             assert_equal(c[1, 1], np.inf)
  858:             assert_(np.isfinite(c[0, 1]))
  859:             assert_(np.isfinite(c[1, 0]))
  860: 
  861: 
  862: class PinvCases(LinalgSquareTestCase,
  863:                 LinalgNonsquareTestCase,
  864:                 LinalgGeneralizedSquareTestCase,
  865:                 LinalgGeneralizedNonsquareTestCase):
  866: 
  867:     def do(self, a, b, tags):
  868:         a_ginv = linalg.pinv(a)
  869:         # `a @ a_ginv == I` does not hold if a is singular
  870:         dot = matmul
  871:         assert_almost_equal(dot(dot(a, a_ginv), a), a, single_decimal=5, double_decimal=11)
  872:         assert_(consistent_subclass(a_ginv, a))
  873: 
  874: 
  875: class TestPinv(PinvCases):
  876:     pass
  877: 
  878: 
  879: class PinvHermitianCases(HermitianTestCase, HermitianGeneralizedTestCase):
  880: 
  881:     def do(self, a, b, tags):
  882:         a_ginv = linalg.pinv(a, hermitian=True)
  883:         # `a @ a_ginv == I` does not hold if a is singular
  884:         dot = matmul
  885:         assert_almost_equal(dot(dot(a, a_ginv), a), a, single_decimal=5, double_decimal=11)
  886:         assert_(consistent_subclass(a_ginv, a))
  887: 
  888: 
  889: class TestPinvHermitian(PinvHermitianCases):
  890:     pass
  891: 
  892: 
  893: def test_pinv_rtol_arg():
  894:     a = np.array([[1, 2, 3], [4, 1, 1], [2, 3, 1]])
  895: 
  896:     assert_almost_equal(
  897:         np.linalg.pinv(a, rcond=0.5),
  898:         np.linalg.pinv(a, rtol=0.5),
  899:     )
  900: 
  901:     with pytest.raises(
  902:         ValueError, match=r"`rtol` and `rcond` can't be both set."
  903:     ):
  904:         np.linalg.pinv(a, rcond=0.5, rtol=0.5)
  905: 
  906: 
  907: class DetCases(LinalgSquareTestCase, LinalgGeneralizedSquareTestCase):
  908: 
  909:     def do(self, a, b, tags):
  910:         d = linalg.det(a)
  911:         res = linalg.slogdet(a)
  912:         s, ld = res.sign, res.logabsdet
  913:         if asarray(a).dtype.type in (single, double):
  914:             ad = asarray(a).astype(double)
  915:         else:
  916:             ad = asarray(a).astype(cdouble)
  917:         ev = linalg.eigvals(ad)
  918:         assert_almost_equal(d, multiply.reduce(ev, axis=-1))
  919:         assert_almost_equal(s * np.exp(ld), multiply.reduce(ev, axis=-1))
  920: 
  921:         s = np.atleast_1d(s)
  922:         ld = np.atleast_1d(ld)
  923:         m = (s != 0)
  924:         assert_almost_equal(np.abs(s[m]), 1)
  925:         assert_equal(ld[~m], -inf)
  926: 
  927: 
  928: class TestDet(DetCases):
  929:     def test_zero(self):
  930:         assert_equal(linalg.det([[0.0]]), 0.0)
  931:         assert_equal(type(linalg.det([[0.0]])), double)
  932:         assert_equal(linalg.det([[0.0j]]), 0.0)
  933:         assert_equal(type(linalg.det([[0.0j]])), cdouble)
  934: 
  935:         assert_equal(linalg.slogdet([[0.0]]), (0.0, -inf))
  936:         assert_equal(type(linalg.slogdet([[0.0]])[0]), double)
  937:         assert_equal(type(linalg.slogdet([[0.0]])[1]), double)
  938:         assert_equal(linalg.slogdet([[0.0j]]), (0.0j, -inf))
  939:         assert_equal(type(linalg.slogdet([[0.0j]])[0]), cdouble)
  940:         assert_equal(type(linalg.slogdet([[0.0j]])[1]), double)
  941: 
  942:     @pytest.mark.parametrize('dtype', [single, double, csingle, cdouble])
  943:     def test_types(self, dtype):
  944:         x = np.array([[1, 0.5], [0.5, 1]], dtype=dtype)
  945:         assert_equal(np.linalg.det(x).dtype, dtype)
  946:         ph, s = np.linalg.slogdet(x)
  947:         assert_equal(s.dtype, get_real_dtype(dtype))
  948:         assert_equal(ph.dtype, dtype)
  949: 
  950:     def test_0_size(self):
  951:         a = np.zeros((0, 0), dtype=np.complex64)
  952:         res = linalg.det(a)
  953:         assert_equal(res, 1.)
  954:         assert_(res.dtype.type is np.complex64)
  955:         res = linalg.slogdet(a)
  956:         assert_equal(res, (1, 0))
  957:         assert_(res[0].dtype.type is np.complex64)
  958:         assert_(res[1].dtype.type is np.float32)
  959: 
  960:         a = np.zeros((0, 0), dtype=np.float64)
  961:         res = linalg.det(a)
  962:         assert_equal(res, 1.)
  963:         assert_(res.dtype.type is np.float64)
  964:         res = linalg.slogdet(a)
  965:         assert_equal(res, (1, 0))
  966:         assert_(res[0].dtype.type is np.float64)
  967:         assert_(res[1].dtype.type is np.float64)
  968: 
  969: 
  970: class LstsqCases(LinalgSquareTestCase, LinalgNonsquareTestCase):
  971: 
  972:     def do(self, a, b, tags):
  973:         arr = np.asarray(a)
  974:         m, n = arr.shape
  975:         u, s, vt = linalg.svd(a, False)
  976:         x, residuals, rank, sv = linalg.lstsq(a, b, rcond=-1)
  977:         if m == 0:
  978:             assert_((x == 0).all())
  979:         if m <= n:
  980:             assert_almost_equal(b, dot(a, x))
  981:             assert_equal(rank, m)
  982:         else:
  983:             assert_equal(rank, n)
  984:         assert_almost_equal(sv, sv.__array_wrap__(s))
  985:         if rank == n and m > n:
  986:             expect_resids = (
  987:                 np.asarray(abs(np.dot(a, x) - b)) ** 2).sum(axis=0)
  988:             expect_resids = np.asarray(expect_resids)
  989:             if np.asarray(b).ndim == 1:
  990:                 expect_resids.shape = (1,)
  991:                 assert_equal(residuals.shape, expect_resids.shape)
  992:         else:
  993:             expect_resids = np.array([]).view(type(x))
  994:         assert_almost_equal(residuals, expect_resids)
  995:         assert_(np.issubdtype(residuals.dtype, np.floating))
  996:         assert_(consistent_subclass(x, b))
  997:         assert_(consistent_subclass(residuals, b))
  998: 
  999: 
 1000: class TestLstsq(LstsqCases):
 1001:     def test_rcond(self):
 1002:         a = np.array([[0., 1.,  0.,  1.,  2.,  0.],
 1003:                       [0., 2.,  0.,  0.,  1.,  0.],
 1004:                       [1., 0.,  1.,  0.,  0.,  4.],
 1005:                       [0., 0.,  0.,  2.,  3.,  0.]]).T
 1006: 
 1007:         b = np.array([1, 0, 0, 0, 0, 0])
 1008: 
 1009:         x, residuals, rank, s = linalg.lstsq(a, b, rcond=-1)
 1010:         assert_(rank == 4)
 1011:         x, residuals, rank, s = linalg.lstsq(a, b)
 1012:         assert_(rank == 3)
 1013:         x, residuals, rank, s = linalg.lstsq(a, b, rcond=None)
 1014:         assert_(rank == 3)
 1015: 
 1016:     @pytest.mark.parametrize(["m", "n", "n_rhs"], [
 1017:         (4, 2, 2),
 1018:         (0, 4, 1),
 1019:         (0, 4, 2),
 1020:         (4, 0, 1),
 1021:         (4, 0, 2),
 1022:         (4, 2, 0),
 1023:         (0, 0, 0)
 1024:     ])
 1025:     def test_empty_a_b(self, m, n, n_rhs):
 1026:         a = np.arange(m * n).reshape(m, n)
 1027:         b = np.ones((m, n_rhs))
 1028:         x, residuals, rank, s = linalg.lstsq(a, b, rcond=None)
 1029:         if m == 0:
 1030:             assert_((x == 0).all())
 1031:         assert_equal(x.shape, (n, n_rhs))
 1032:         assert_equal(residuals.shape, ((n_rhs,) if m > n else (0,)))
 1033:         if m > n and n_rhs > 0:
 1034:             # residuals are exactly the squared norms of b's columns
 1035:             r = b - np.dot(a, x)
 1036:             assert_almost_equal(residuals, (r * r).sum(axis=-2))
 1037:         assert_equal(rank, min(m, n))
 1038:         assert_equal(s.shape, (min(m, n),))
 1039: 
 1040:     def test_incompatible_dims(self):
 1041:         # use modified version of docstring example
 1042:         x = np.array([0, 1, 2, 3])
 1043:         y = np.array([-1, 0.2, 0.9, 2.1, 3.3])
 1044:         A = np.vstack([x, np.ones(len(x))]).T
 1045:         with assert_raises_regex(LinAlgError, "Incompatible dimensions"):
 1046:             linalg.lstsq(A, y, rcond=None)
 1047: 
 1048: 
 1049: @pytest.mark.parametrize('dt', [np.dtype(c) for c in '?bBhHiIqQefdgFDGO'])
 1050: class TestMatrixPower:
 1051: 
 1052:     rshft_0 = np.eye(4)
 1053:     rshft_1 = rshft_0[[3, 0, 1, 2]]
 1054:     rshft_2 = rshft_0[[2, 3, 0, 1]]
 1055:     rshft_3 = rshft_0[[1, 2, 3, 0]]
 1056:     rshft_all = [rshft_0, rshft_1, rshft_2, rshft_3]
 1057:     noninv = array([[1, 0], [0, 0]])
 1058:     stacked = np.block([[[rshft_0]]] * 2)
 1059:     # FIXME the 'e' dtype might work in future
 1060:     dtnoinv = [object, np.dtype('e'), np.dtype('g'), np.dtype('G')]
 1061: 
 1062:     def test_large_power(self, dt):
 1063:         rshft = self.rshft_1.astype(dt)
 1064:         assert_equal(
 1065:             matrix_power(rshft, 2**100 + 2**10 + 2**5 + 0), self.rshft_0)
 1066:         assert_equal(
 1067:             matrix_power(rshft, 2**100 + 2**10 + 2**5 + 1), self.rshft_1)
 1068:         assert_equal(
 1069:             matrix_power(rshft, 2**100 + 2**10 + 2**5 + 2), self.rshft_2)
 1070:         assert_equal(
 1071:             matrix_power(rshft, 2**100 + 2**10 + 2**5 + 3), self.rshft_3)
 1072: 
 1073:     def test_power_is_zero(self, dt):
 1074:         def tz(M):
 1075:             mz = matrix_power(M, 0)
 1076:             assert_equal(mz, identity_like_generalized(M))
 1077:             assert_equal(mz.dtype, M.dtype)
 1078: 
 1079:         for mat in self.rshft_all:
 1080:             tz(mat.astype(dt))
 1081:             if dt != object:
 1082:                 tz(self.stacked.astype(dt))
 1083: 
 1084:     def test_power_is_one(self, dt):
 1085:         def tz(mat):
 1086:             mz = matrix_power(mat, 1)
 1087:             assert_equal(mz, mat)
 1088:             assert_equal(mz.dtype, mat.dtype)
 1089: 
 1090:         for mat in self.rshft_all:
 1091:             tz(mat.astype(dt))
 1092:             if dt != object:
 1093:                 tz(self.stacked.astype(dt))
 1094: 
 1095:     def test_power_is_two(self, dt):
 1096:         def tz(mat):
 1097:             mz = matrix_power(mat, 2)
 1098:             mmul = matmul if mat.dtype != object else dot
 1099:             assert_equal(mz, mmul(mat, mat))
 1100:             assert_equal(mz.dtype, mat.dtype)
 1101: 
 1102:         for mat in self.rshft_all:
 1103:             tz(mat.astype(dt))
 1104:             if dt != object:
 1105:                 tz(self.stacked.astype(dt))
 1106: 
 1107:     def test_power_is_minus_one(self, dt):
 1108:         def tz(mat):
 1109:             invmat = matrix_power(mat, -1)
 1110:             mmul = matmul if mat.dtype != object else dot
 1111:             assert_almost_equal(
 1112:                 mmul(invmat, mat), identity_like_generalized(mat))
 1113: 
 1114:         for mat in self.rshft_all:
 1115:             if dt not in self.dtnoinv:
 1116:                 tz(mat.astype(dt))
 1117: 
 1118:     def test_exceptions_bad_power(self, dt):
 1119:         mat = self.rshft_0.astype(dt)
 1120:         assert_raises(TypeError, matrix_power, mat, 1.5)
 1121:         assert_raises(TypeError, matrix_power, mat, [1])
 1122: 
 1123:     def test_exceptions_non_square(self, dt):
 1124:         assert_raises(LinAlgError, matrix_power, np.array([1], dt), 1)
 1125:         assert_raises(LinAlgError, matrix_power, np.array([[1], [2]], dt), 1)
 1126:         assert_raises(LinAlgError, matrix_power, np.ones((4, 3, 2), dt), 1)
 1127: 
 1128:     @pytest.mark.skipif(IS_WASM, reason="fp errors don't work in wasm")
 1129:     def test_exceptions_not_invertible(self, dt):
 1130:         if dt in self.dtnoinv:
 1131:             return
 1132:         mat = self.noninv.astype(dt)
 1133:         assert_raises(LinAlgError, matrix_power, mat, -1)
 1134: 
 1135: 
 1136: class TestEigvalshCases(HermitianTestCase, HermitianGeneralizedTestCase):
 1137: 
 1138:     def do(self, a, b, tags):
 1139:         # note that eigenvalue arrays returned by eig must be sorted since
 1140:         # their order isn't guaranteed.
 1141:         ev = linalg.eigvalsh(a, 'L')
 1142:         evalues, evectors = linalg.eig(a)
 1143:         evalues.sort(axis=-1)
 1144:         assert_allclose(ev, evalues, rtol=get_rtol(ev.dtype))
 1145: 
 1146:         ev2 = linalg.eigvalsh(a, 'U')
 1147:         assert_allclose(ev2, evalues, rtol=get_rtol(ev.dtype))
 1148: 
 1149: 
 1150: class TestEigvalsh:
 1151:     @pytest.mark.parametrize('dtype', [single, double, csingle, cdouble])
 1152:     def test_types(self, dtype):
 1153:         x = np.array([[1, 0.5], [0.5, 1]], dtype=dtype)
 1154:         w = np.linalg.eigvalsh(x)
 1155:         assert_equal(w.dtype, get_real_dtype(dtype))
 1156: 
 1157:     def test_invalid(self):
 1158:         x = np.array([[1, 0.5], [0.5, 1]], dtype=np.float32)
 1159:         assert_raises(ValueError, np.linalg.eigvalsh, x, UPLO="lrong")
 1160:         assert_raises(ValueError, np.linalg.eigvalsh, x, "lower")
 1161:         assert_raises(ValueError, np.linalg.eigvalsh, x, "upper")
 1162: 
 1163:     def test_UPLO(self):
 1164:         Klo = np.array([[0, 0], [1, 0]], dtype=np.double)
 1165:         Kup = np.array([[0, 1], [0, 0]], dtype=np.double)
 1166:         tgt = np.array([-1, 1], dtype=np.double)
 1167:         rtol = get_rtol(np.double)
 1168: 
 1169:         # Check default is 'L'
 1170:         w = np.linalg.eigvalsh(Klo)
 1171:         assert_allclose(w, tgt, rtol=rtol)
 1172:         # Check 'L'
 1173:         w = np.linalg.eigvalsh(Klo, UPLO='L')
 1174:         assert_allclose(w, tgt, rtol=rtol)
 1175:         # Check 'l'
 1176:         w = np.linalg.eigvalsh(Klo, UPLO='l')
 1177:         assert_allclose(w, tgt, rtol=rtol)
 1178:         # Check 'U'
 1179:         w = np.linalg.eigvalsh(Kup, UPLO='U')
 1180:         assert_allclose(w, tgt, rtol=rtol)
 1181:         # Check 'u'
 1182:         w = np.linalg.eigvalsh(Kup, UPLO='u')
 1183:         assert_allclose(w, tgt, rtol=rtol)
 1184: 
 1185:     def test_0_size(self):
 1186:         # Check that all kinds of 0-sized arrays work
 1187:         class ArraySubclass(np.ndarray):
 1188:             pass
 1189:         a = np.zeros((0, 1, 1), dtype=np.int_).view(ArraySubclass)
 1190:         res = linalg.eigvalsh(a)
 1191:         assert_(res.dtype.type is np.float64)
 1192:         assert_equal((0, 1), res.shape)
 1193:         # This is just for documentation, it might make sense to change:
 1194:         assert_(isinstance(res, np.ndarray))
 1195: 
 1196:         a = np.zeros((0, 0), dtype=np.complex64).view(ArraySubclass)
 1197:         res = linalg.eigvalsh(a)
 1198:         assert_(res.dtype.type is np.float32)
 1199:         assert_equal((0,), res.shape)
 1200:         # This is just for documentation, it might make sense to change:
 1201:         assert_(isinstance(res, np.ndarray))
 1202: 
 1203: 
 1204: class TestEighCases(HermitianTestCase, HermitianGeneralizedTestCase):
 1205: 
 1206:     def do(self, a, b, tags):
 1207:         # note that eigenvalue arrays returned by eig must be sorted since
 1208:         # their order isn't guaranteed.
 1209:         res = linalg.eigh(a)
 1210:         ev, evc = res.eigenvalues, res.eigenvectors
 1211:         evalues, evectors = linalg.eig(a)
 1212:         evalues.sort(axis=-1)
 1213:         assert_almost_equal(ev, evalues)
 1214: 
 1215:         assert_allclose(matmul(a, evc),
 1216:                         np.asarray(ev)[..., None, :] * np.asarray(evc),
 1217:                         rtol=get_rtol(ev.dtype))
 1218: 
 1219:         ev2, evc2 = linalg.eigh(a, 'U')
 1220:         assert_almost_equal(ev2, evalues)
 1221: 
 1222:         assert_allclose(matmul(a, evc2),
 1223:                         np.asarray(ev2)[..., None, :] * np.asarray(evc2),
 1224:                         rtol=get_rtol(ev.dtype), err_msg=repr(a))
 1225: 
 1226: 
 1227: class TestEigh:
 1228:     @pytest.mark.parametrize('dtype', [single, double, csingle, cdouble])
 1229:     def test_types(self, dtype):
 1230:         x = np.array([[1, 0.5], [0.5, 1]], dtype=dtype)
 1231:         w, v = np.linalg.eigh(x)
 1232:         assert_equal(w.dtype, get_real_dtype(dtype))
 1233:         assert_equal(v.dtype, dtype)
 1234: 
 1235:     def test_invalid(self):
 1236:         x = np.array([[1, 0.5], [0.5, 1]], dtype=np.float32)
 1237:         assert_raises(ValueError, np.linalg.eigh, x, UPLO="lrong")
 1238:         assert_raises(ValueError, np.linalg.eigh, x, "lower")
 1239:         assert_raises(ValueError, np.linalg.eigh, x, "upper")
 1240: 
 1241:     def test_UPLO(self):
 1242:         Klo = np.array([[0, 0], [1, 0]], dtype=np.double)
 1243:         Kup = np.array([[0, 1], [0, 0]], dtype=np.double)
 1244:         tgt = np.array([-1, 1], dtype=np.double)
 1245:         rtol = get_rtol(np.double)
 1246: 
 1247:         # Check default is 'L'
 1248:         w, v = np.linalg.eigh(Klo)
 1249:         assert_allclose(w, tgt, rtol=rtol)
 1250:         # Check 'L'
 1251:         w, v = np.linalg.eigh(Klo, UPLO='L')
 1252:         assert_allclose(w, tgt, rtol=rtol)
 1253:         # Check 'l'
 1254:         w, v = np.linalg.eigh(Klo, UPLO='l')
 1255:         assert_allclose(w, tgt, rtol=rtol)
 1256:         # Check 'U'
 1257:         w, v = np.linalg.eigh(Kup, UPLO='U')
 1258:         assert_allclose(w, tgt, rtol=rtol)
 1259:         # Check 'u'
 1260:         w, v = np.linalg.eigh(Kup, UPLO='u')
 1261:         assert_allclose(w, tgt, rtol=rtol)
 1262: 
 1263:     def test_0_size(self):
 1264:         # Check that all kinds of 0-sized arrays work
 1265:         class ArraySubclass(np.ndarray):
 1266:             pass
 1267:         a = np.zeros((0, 1, 1), dtype=np.int_).view(ArraySubclass)
 1268:         res, res_v = linalg.eigh(a)
 1269:         assert_(res_v.dtype.type is np.float64)
 1270:         assert_(res.dtype.type is np.float64)
 1271:         assert_equal(a.shape, res_v.shape)
 1272:         assert_equal((0, 1), res.shape)
 1273:         # This is just for documentation, it might make sense to change:
 1274:         assert_(isinstance(a, np.ndarray))
 1275: 
 1276:         a = np.zeros((0, 0), dtype=np.complex64).view(ArraySubclass)
 1277:         res, res_v = linalg.eigh(a)
 1278:         assert_(res_v.dtype.type is np.complex64)
 1279:         assert_(res.dtype.type is np.float32)
 1280:         assert_equal(a.shape, res_v.shape)
 1281:         assert_equal((0,), res.shape)
 1282:         # This is just for documentation, it might make sense to change:
 1283:         assert_(isinstance(a, np.ndarray))
 1284: 
 1285: 
 1286: class _TestNormBase:
 1287:     dt = None
 1288:     dec = None
 1289: 
 1290:     @staticmethod
 1291:     def check_dtype(x, res):
 1292:         if issubclass(x.dtype.type, np.inexact):
 1293:             assert_equal(res.dtype, x.real.dtype)
 1294:         else:
 1295:             # For integer input, don't have to test float precision of output.
 1296:             assert_(issubclass(res.dtype.type, np.floating))
 1297: 
 1298: 
 1299: class _TestNormGeneral(_TestNormBase):
 1300: 
 1301:     def test_empty(self):
 1302:         assert_equal(norm([]), 0.0)
 1303:         assert_equal(norm(array([], dtype=self.dt)), 0.0)
 1304:         assert_equal(norm(atleast_2d(array([], dtype=self.dt))), 0.0)
 1305: 
 1306:     def test_vector_return_type(self):
 1307:         a = np.array([1, 0, 1])
 1308: 
 1309:         exact_types = np.typecodes['AllInteger']
 1310:         inexact_types = np.typecodes['AllFloat']
 1311: 
 1312:         all_types = exact_types + inexact_types
 1313: 
 1314:         for each_type in all_types:
 1315:             at = a.astype(each_type)
 1316: 
 1317:             an = norm(at, -np.inf)
 1318:             self.check_dtype(at, an)
 1319:             assert_almost_equal(an, 0.0)
 1320: 
 1321:             with suppress_warnings() as sup:
 1322:                 sup.filter(RuntimeWarning, "divide by zero encountered")
 1323:                 an = norm(at, -1)
 1324:                 self.check_dtype(at, an)
 1325:                 assert_almost_equal(an, 0.0)
 1326: 
 1327:             an = norm(at, 0)
 1328:             self.check_dtype(at, an)
 1329:             assert_almost_equal(an, 2)
 1330: 
 1331:             an = norm(at, 1)
 1332:             self.check_dtype(at, an)
 1333:             assert_almost_equal(an, 2.0)
 1334: 
 1335:             an = norm(at, 2)
 1336:             self.check_dtype(at, an)
 1337:             assert_almost_equal(an, an.dtype.type(2.0)**an.dtype.type(1.0 / 2.0))
 1338: 
 1339:             an = norm(at, 4)
 1340:             self.check_dtype(at, an)
 1341:             assert_almost_equal(an, an.dtype.type(2.0)**an.dtype.type(1.0 / 4.0))
 1342: 
 1343:             an = norm(at, np.inf)
 1344:             self.check_dtype(at, an)
 1345:             assert_almost_equal(an, 1.0)
 1346: 
 1347:     def test_vector(self):
 1348:         a = [1, 2, 3, 4]
 1349:         b = [-1, -2, -3, -4]
 1350:         c = [-1, 2, -3, 4]
 1351: 
 1352:         def _test(v):
 1353:             np.testing.assert_almost_equal(norm(v), 30 ** 0.5,
 1354:                                            decimal=self.dec)
 1355:             np.testing.assert_almost_equal(norm(v, inf), 4.0,
 1356:                                            decimal=self.dec)
 1357:             np.testing.assert_almost_equal(norm(v, -inf), 1.0,
 1358:                                            decimal=self.dec)
 1359:             np.testing.assert_almost_equal(norm(v, 1), 10.0,
 1360:                                            decimal=self.dec)
 1361:             np.testing.assert_almost_equal(norm(v, -1), 12.0 / 25,
 1362:                                            decimal=self.dec)
 1363:             np.testing.assert_almost_equal(norm(v, 2), 30 ** 0.5,
 1364:                                            decimal=self.dec)
 1365:             np.testing.assert_almost_equal(norm(v, -2), ((205. / 144) ** -0.5),
 1366:                                            decimal=self.dec)
 1367:             np.testing.assert_almost_equal(norm(v, 0), 4,
 1368:                                            decimal=self.dec)
 1369: 
 1370:         for v in (a, b, c,):
 1371:             _test(v)
 1372: 
 1373:         for v in (array(a, dtype=self.dt), array(b, dtype=self.dt),
 1374:                   array(c, dtype=self.dt)):
 1375:             _test(v)
 1376: 
 1377:     def test_axis(self):
 1378:         # Vector norms.
 1379:         # Compare the use of `axis` with computing the norm of each row
 1380:         # or column separately.
 1381:         A = array([[1, 2, 3], [4, 5, 6]], dtype=self.dt)
 1382:         for order in [None, -1, 0, 1, 2, 3, np.inf, -np.inf]:
 1383:             expected0 = [norm(A[:, k], ord=order) for k in range(A.shape[1])]
 1384:             assert_almost_equal(norm(A, ord=order, axis=0), expected0)
 1385:             expected1 = [norm(A[k, :], ord=order) for k in range(A.shape[0])]
 1386:             assert_almost_equal(norm(A, ord=order, axis=1), expected1)
 1387: 
 1388:         # Matrix norms.
 1389:         B = np.arange(1, 25, dtype=self.dt).reshape(2, 3, 4)
 1390:         nd = B.ndim
 1391:         for order in [None, -2, 2, -1, 1, np.inf, -np.inf, 'fro']:
 1392:             for axis in itertools.combinations(range(-nd, nd), 2):
 1393:                 row_axis, col_axis = axis
 1394:                 if row_axis < 0:
 1395:                     row_axis += nd
 1396:                 if col_axis < 0:
 1397:                     col_axis += nd
 1398:                 if row_axis == col_axis:
 1399:                     assert_raises(ValueError, norm, B, ord=order, axis=axis)
 1400:                 else:
 1401:                     n = norm(B, ord=order, axis=axis)
 1402: 
 1403:                     # The logic using k_index only works for nd = 3.
 1404:                     # This has to be changed if nd is increased.
 1405:                     k_index = nd - (row_axis + col_axis)
 1406:                     if row_axis < col_axis:
 1407:                         expected = [norm(B[:].take(k, axis=k_index), ord=order)
 1408:                                     for k in range(B.shape[k_index])]
 1409:                     else:
 1410:                         expected = [norm(B[:].take(k, axis=k_index).T, ord=order)
 1411:                                     for k in range(B.shape[k_index])]
 1412:                     assert_almost_equal(n, expected)
 1413: 
 1414:     def test_keepdims(self):
 1415:         A = np.arange(1, 25, dtype=self.dt).reshape(2, 3, 4)
 1416: 
 1417:         allclose_err = 'order {0}, axis = {1}'
 1418:         shape_err = 'Shape mismatch found {0}, expected {1}, order={2}, axis={3}'
 1419: 
 1420:         # check the order=None, axis=None case
 1421:         expected = norm(A, ord=None, axis=None)
 1422:         found = norm(A, ord=None, axis=None, keepdims=True)
 1423:         assert_allclose(np.squeeze(found), expected,
 1424:                         err_msg=allclose_err.format(None, None))
 1425:         expected_shape = (1, 1, 1)
 1426:         assert_(found.shape == expected_shape,
 1427:                 shape_err.format(found.shape, expected_shape, None, None))
 1428: 
 1429:         # Vector norms.
 1430:         for order in [None, -1, 0, 1, 2, 3, np.inf, -np.inf]:
 1431:             for k in range(A.ndim):
 1432:                 expected = norm(A, ord=order, axis=k)
 1433:                 found = norm(A, ord=order, axis=k, keepdims=True)
 1434:                 assert_allclose(np.squeeze(found), expected,
 1435:                                 err_msg=allclose_err.format(order, k))
 1436:                 expected_shape = list(A.shape)
 1437:                 expected_shape[k] = 1
 1438:                 expected_shape = tuple(expected_shape)
 1439:                 assert_(found.shape == expected_shape,
 1440:                         shape_err.format(found.shape, expected_shape, order, k))
 1441: 
 1442:         # Matrix norms.
 1443:         for order in [None, -2, 2, -1, 1, np.inf, -np.inf, 'fro', 'nuc']:
 1444:             for k in itertools.permutations(range(A.ndim), 2):
 1445:                 expected = norm(A, ord=order, axis=k)
 1446:                 found = norm(A, ord=order, axis=k, keepdims=True)
 1447:                 assert_allclose(np.squeeze(found), expected,
 1448:                                 err_msg=allclose_err.format(order, k))
 1449:                 expected_shape = list(A.shape)
 1450:                 expected_shape[k[0]] = 1
 1451:                 expected_shape[k[1]] = 1
 1452:                 expected_shape = tuple(expected_shape)
 1453:                 assert_(found.shape == expected_shape,
 1454:                         shape_err.format(found.shape, expected_shape, order, k))
 1455: 
 1456: 
 1457: class _TestNorm2D(_TestNormBase):
 1458:     # Define the part for 2d arrays separately, so we can subclass this
 1459:     # and run the tests using np.matrix in matrixlib.tests.test_matrix_linalg.
 1460:     array = np.array
 1461: 
 1462:     def test_matrix_empty(self):
 1463:         assert_equal(norm(self.array([[]], dtype=self.dt)), 0.0)
 1464: 
 1465:     def test_matrix_return_type(self):
 1466:         a = self.array([[1, 0, 1], [0, 1, 1]])
 1467: 
 1468:         exact_types = np.typecodes['AllInteger']
 1469: 
 1470:         # float32, complex64, float64, complex128 types are the only types
 1471:         # allowed by `linalg`, which performs the matrix operations used
 1472:         # within `norm`.
 1473:         inexact_types = 'fdFD'
 1474: 
 1475:         all_types = exact_types + inexact_types
 1476: 
 1477:         for each_type in all_types:
 1478:             at = a.astype(each_type)
 1479: 
 1480:             an = norm(at, -np.inf)
 1481:             self.check_dtype(at, an)
 1482:             assert_almost_equal(an, 2.0)
 1483: 
 1484:             with suppress_warnings() as sup:
 1485:                 sup.filter(RuntimeWarning, "divide by zero encountered")
 1486:                 an = norm(at, -1)
 1487:                 self.check_dtype(at, an)
 1488:                 assert_almost_equal(an, 1.0)
 1489: 
 1490:             an = norm(at, 1)
 1491:             self.check_dtype(at, an)
 1492:             assert_almost_equal(an, 2.0)
 1493: 
 1494:             an = norm(at, 2)
 1495:             self.check_dtype(at, an)
 1496:             assert_almost_equal(an, 3.0**(1.0 / 2.0))
 1497: 
 1498:             an = norm(at, -2)
 1499:             self.check_dtype(at, an)
 1500:             assert_almost_equal(an, 1.0)
 1501: 
 1502:             an = norm(at, np.inf)
 1503:             self.check_dtype(at, an)
 1504:             assert_almost_equal(an, 2.0)
 1505: 
 1506:             an = norm(at, 'fro')
 1507:             self.check_dtype(at, an)
 1508:             assert_almost_equal(an, 2.0)
 1509: 
 1510:             an = norm(at, 'nuc')
 1511:             self.check_dtype(at, an)
 1512:             # Lower bar needed to support low precision floats.
 1513:             # They end up being off by 1 in the 7th place.
 1514:             np.testing.assert_almost_equal(an, 2.7320508075688772, decimal=6)
 1515: 
 1516:     def test_matrix_2x2(self):
 1517:         A = self.array([[1, 3], [5, 7]], dtype=self.dt)
 1518:         assert_almost_equal(norm(A), 84 ** 0.5)
 1519:         assert_almost_equal(norm(A, 'fro'), 84 ** 0.5)
 1520:         assert_almost_equal(norm(A, 'nuc'), 10.0)
 1521:         assert_almost_equal(norm(A, inf), 12.0)
 1522:         assert_almost_equal(norm(A, -inf), 4.0)
 1523:         assert_almost_equal(norm(A, 1), 10.0)
 1524:         assert_almost_equal(norm(A, -1), 6.0)
 1525:         assert_almost_equal(norm(A, 2), 9.1231056256176615)
 1526:         assert_almost_equal(norm(A, -2), 0.87689437438234041)
 1527: 
 1528:         assert_raises(ValueError, norm, A, 'nofro')
 1529:         assert_raises(ValueError, norm, A, -3)
 1530:         assert_raises(ValueError, norm, A, 0)
 1531: 
 1532:     def test_matrix_3x3(self):
 1533:         # This test has been added because the 2x2 example
 1534:         # happened to have equal nuclear norm and induced 1-norm.
 1535:         # The 1/10 scaling factor accommodates the absolute tolerance
 1536:         # used in assert_almost_equal.
 1537:         A = (1 / 10) * \
 1538:             self.array([[1, 2, 3], [6, 0, 5], [3, 2, 1]], dtype=self.dt)
 1539:         assert_almost_equal(norm(A), (1 / 10) * 89 ** 0.5)
 1540:         assert_almost_equal(norm(A, 'fro'), (1 / 10) * 89 ** 0.5)
 1541:         assert_almost_equal(norm(A, 'nuc'), 1.3366836911774836)
 1542:         assert_almost_equal(norm(A, inf), 1.1)
 1543:         assert_almost_equal(norm(A, -inf), 0.6)
 1544:         assert_almost_equal(norm(A, 1), 1.0)
 1545:         assert_almost_equal(norm(A, -1), 0.4)
 1546:         assert_almost_equal(norm(A, 2), 0.88722940323461277)
 1547:         assert_almost_equal(norm(A, -2), 0.19456584790481812)
 1548: 
 1549:     def test_bad_args(self):
 1550:         # Check that bad arguments raise the appropriate exceptions.
 1551: 
 1552:         A = self.array([[1, 2, 3], [4, 5, 6]], dtype=self.dt)
 1553:         B = np.arange(1, 25, dtype=self.dt).reshape(2, 3, 4)
 1554: 
 1555:         # Using `axis=<integer>` or passing in a 1-D array implies vector
 1556:         # norms are being computed, so also using `ord='fro'`
 1557:         # or `ord='nuc'` or any other string raises a ValueError.
 1558:         assert_raises(ValueError, norm, A, 'fro', 0)
 1559:         assert_raises(ValueError, norm, A, 'nuc', 0)
 1560:         assert_raises(ValueError, norm, [3, 4], 'fro', None)
 1561:         assert_raises(ValueError, norm, [3, 4], 'nuc', None)
 1562:         assert_raises(ValueError, norm, [3, 4], 'test', None)
 1563: 
 1564:         # Similarly, norm should raise an exception when ord is any finite
 1565:         # number other than 1, 2, -1 or -2 when computing matrix norms.
 1566:         for order in [0, 3]:
 1567:             assert_raises(ValueError, norm, A, order, None)
 1568:             assert_raises(ValueError, norm, A, order, (0, 1))
 1569:             assert_raises(ValueError, norm, B, order, (1, 2))
 1570: 
 1571:         # Invalid axis
 1572:         assert_raises(AxisError, norm, B, None, 3)
 1573:         assert_raises(AxisError, norm, B, None, (2, 3))
 1574:         assert_raises(ValueError, norm, B, None, (0, 1, 2))
 1575: 
 1576: 
 1577: class _TestNorm(_TestNorm2D, _TestNormGeneral):
 1578:     pass
 1579: 
 1580: 
 1581: class TestNorm_NonSystematic:
 1582: 
 1583:     def test_longdouble_norm(self):
 1584:         # Non-regression test: p-norm of longdouble would previously raise
 1585:         # UnboundLocalError.
 1586:         x = np.arange(10, dtype=np.longdouble)
 1587:         old_assert_almost_equal(norm(x, ord=3), 12.65, decimal=2)
 1588: 
 1589:     def test_intmin(self):
 1590:         # Non-regression test: p-norm of signed integer would previously do
 1591:         # float cast and abs in the wrong order.
 1592:         x = np.array([-2 ** 31], dtype=np.int32)
 1593:         old_assert_almost_equal(norm(x, ord=3), 2 ** 31, decimal=5)
 1594: 
 1595:     def test_complex_high_ord(self):
 1596:         # gh-4156
 1597:         d = np.empty((2,), dtype=np.clongdouble)
 1598:         d[0] = 6 + 7j
 1599:         d[1] = -6 + 7j
 1600:         res = 11.615898132184
 1601:         old_assert_almost_equal(np.linalg.norm(d, ord=3), res, decimal=10)
 1602:         d = d.astype(np.complex128)
 1603:         old_assert_almost_equal(np.linalg.norm(d, ord=3), res, decimal=9)
 1604:         d = d.astype(np.complex64)
 1605:         old_assert_almost_equal(np.linalg.norm(d, ord=3), res, decimal=5)
 1606: 
 1607: 
 1608: # Separate definitions so we can use them for matrix tests.
 1609: class _TestNormDoubleBase(_TestNormBase):
 1610:     dt = np.double
 1611:     dec = 12
 1612: 
 1613: 
 1614: class _TestNormSingleBase(_TestNormBase):
 1615:     dt = np.float32
 1616:     dec = 6
 1617: 
 1618: 
 1619: class _TestNormInt64Base(_TestNormBase):
 1620:     dt = np.int64
 1621:     dec = 12
 1622: 
 1623: 
 1624: class TestNormDouble(_TestNorm, _TestNormDoubleBase):
 1625:     pass
 1626: 
 1627: 
 1628: class TestNormSingle(_TestNorm, _TestNormSingleBase):
 1629:     pass
 1630: 
 1631: 
 1632: class TestNormInt64(_TestNorm, _TestNormInt64Base):
 1633:     pass
 1634: 
 1635: 
 1636: class TestMatrixRank:
 1637: 
 1638:     def test_matrix_rank(self):
 1639:         # Full rank matrix
 1640:         assert_equal(4, matrix_rank(np.eye(4)))
 1641:         # rank deficient matrix
 1642:         I = np.eye(4)
 1643:         I[-1, -1] = 0.
 1644:         assert_equal(matrix_rank(I), 3)
 1645:         # All zeros - zero rank
 1646:         assert_equal(matrix_rank(np.zeros((4, 4))), 0)
 1647:         # 1 dimension - rank 1 unless all 0
 1648:         assert_equal(matrix_rank([1, 0, 0, 0]), 1)
 1649:         assert_equal(matrix_rank(np.zeros((4,))), 0)
 1650:         # accepts array-like
 1651:         assert_equal(matrix_rank([1]), 1)
 1652:         # greater than 2 dimensions treated as stacked matrices
 1653:         ms = np.array([I, np.eye(4), np.zeros((4, 4))])
 1654:         assert_equal(matrix_rank(ms), np.array([3, 4, 0]))
 1655:         # works on scalar
 1656:         assert_equal(matrix_rank(1), 1)
 1657: 
 1658:         with assert_raises_regex(
 1659:             ValueError, "`tol` and `rtol` can\'t be both set."
 1660:         ):
 1661:             matrix_rank(I, tol=0.01, rtol=0.01)
 1662: 
 1663:     def test_symmetric_rank(self):
 1664:         assert_equal(4, matrix_rank(np.eye(4), hermitian=True))
 1665:         assert_equal(1, matrix_rank(np.ones((4, 4)), hermitian=True))
 1666:         assert_equal(0, matrix_rank(np.zeros((4, 4)), hermitian=True))
 1667:         # rank deficient matrix
 1668:         I = np.eye(4)
 1669:         I[-1, -1] = 0.
 1670:         assert_equal(3, matrix_rank(I, hermitian=True))
 1671:         # manually supplied tolerance
 1672:         I[-1, -1] = 1e-8
 1673:         assert_equal(4, matrix_rank(I, hermitian=True, tol=0.99e-8))
 1674:         assert_equal(3, matrix_rank(I, hermitian=True, tol=1.01e-8))
 1675: 
 1676: 
 1677: def test_reduced_rank():
 1678:     # Test matrices with reduced rank
 1679:     rng = np.random.RandomState(20120714)
 1680:     for i in range(100):
 1681:         # Make a rank deficient matrix
 1682:         X = rng.normal(size=(40, 10))
 1683:         X[:, 0] = X[:, 1] + X[:, 2]
 1684:         # Assert that matrix_rank detected deficiency
 1685:         assert_equal(matrix_rank(X), 9)
 1686:         X[:, 3] = X[:, 4] + X[:, 5]
 1687:         assert_equal(matrix_rank(X), 8)
 1688: 
 1689: 
 1690: class TestQR:
 1691:     # Define the array class here, so run this on matrices elsewhere.
 1692:     array = np.array
 1693: 
 1694:     def check_qr(self, a):
 1695:         # This test expects the argument `a` to be an ndarray or
 1696:         # a subclass of an ndarray of inexact type.
 1697:         a_type = type(a)
 1698:         a_dtype = a.dtype
 1699:         m, n = a.shape
 1700:         k = min(m, n)
 1701: 
 1702:         # mode == 'complete'
 1703:         res = linalg.qr(a, mode='complete')
 1704:         Q, R = res.Q, res.R
 1705:         assert_(Q.dtype == a_dtype)
 1706:         assert_(R.dtype == a_dtype)
 1707:         assert_(isinstance(Q, a_type))
 1708:         assert_(isinstance(R, a_type))
 1709:         assert_(Q.shape == (m, m))
 1710:         assert_(R.shape == (m, n))
 1711:         assert_almost_equal(dot(Q, R), a)
 1712:         assert_almost_equal(dot(Q.T.conj(), Q), np.eye(m))
 1713:         assert_almost_equal(np.triu(R), R)
 1714: 
 1715:         # mode == 'reduced'
 1716:         q1, r1 = linalg.qr(a, mode='reduced')
 1717:         assert_(q1.dtype == a_dtype)
 1718:         assert_(r1.dtype == a_dtype)
 1719:         assert_(isinstance(q1, a_type))
 1720:         assert_(isinstance(r1, a_type))
 1721:         assert_(q1.shape == (m, k))
 1722:         assert_(r1.shape == (k, n))
 1723:         assert_almost_equal(dot(q1, r1), a)
 1724:         assert_almost_equal(dot(q1.T.conj(), q1), np.eye(k))
 1725:         assert_almost_equal(np.triu(r1), r1)
 1726: 
 1727:         # mode == 'r'
 1728:         r2 = linalg.qr(a, mode='r')
 1729:         assert_(r2.dtype == a_dtype)
 1730:         assert_(isinstance(r2, a_type))
 1731:         assert_almost_equal(r2, r1)
 1732: 
 1733:     @pytest.mark.parametrize(["m", "n"], [
 1734:         (3, 0),
 1735:         (0, 3),
 1736:         (0, 0)
 1737:     ])
 1738:     def test_qr_empty(self, m, n):
 1739:         k = min(m, n)
 1740:         a = np.empty((m, n))
 1741: 
 1742:         self.check_qr(a)
 1743: 
 1744:         h, tau = np.linalg.qr(a, mode='raw')
 1745:         assert_equal(h.dtype, np.double)
 1746:         assert_equal(tau.dtype, np.double)
 1747:         assert_equal(h.shape, (n, m))
 1748:         assert_equal(tau.shape, (k,))
 1749: 
 1750:     def test_mode_raw(self):
 1751:         # The factorization is not unique and varies between libraries,
 1752:         # so it is not possible to check against known values. Functional
 1753:         # testing is a possibility, but awaits the exposure of more
 1754:         # of the functions in lapack_lite. Consequently, this test is
 1755:         # very limited in scope. Note that the results are in FORTRAN
 1756:         # order, hence the h arrays are transposed.
 1757:         a = self.array([[1, 2], [3, 4], [5, 6]], dtype=np.double)
 1758: 
 1759:         # Test double
 1760:         h, tau = linalg.qr(a, mode='raw')
 1761:         assert_(h.dtype == np.double)
 1762:         assert_(tau.dtype == np.double)
 1763:         assert_(h.shape == (2, 3))
 1764:         assert_(tau.shape == (2,))
 1765: 
 1766:         h, tau = linalg.qr(a.T, mode='raw')
 1767:         assert_(h.dtype == np.double)
 1768:         assert_(tau.dtype == np.double)
 1769:         assert_(h.shape == (3, 2))
 1770:         assert_(tau.shape == (2,))
 1771: 
 1772:     def test_mode_all_but_economic(self):
 1773:         a = self.array([[1, 2], [3, 4]])
 1774:         b = self.array([[1, 2], [3, 4], [5, 6]])
 1775:         for dt in "fd":
 1776:             m1 = a.astype(dt)
 1777:             m2 = b.astype(dt)
 1778:             self.check_qr(m1)
 1779:             self.check_qr(m2)
 1780:             self.check_qr(m2.T)
 1781: 
 1782:         for dt in "fd":
 1783:             m1 = 1 + 1j * a.astype(dt)
 1784:             m2 = 1 + 1j * b.astype(dt)
 1785:             self.check_qr(m1)
 1786:             self.check_qr(m2)
 1787:             self.check_qr(m2.T)
 1788: 
 1789:     def check_qr_stacked(self, a):
 1790:         # This test expects the argument `a` to be an ndarray or
 1791:         # a subclass of an ndarray of inexact type.
 1792:         a_type = type(a)
 1793:         a_dtype = a.dtype
 1794:         m, n = a.shape[-2:]
 1795:         k = min(m, n)
 1796: 
 1797:         # mode == 'complete'
 1798:         q, r = linalg.qr(a, mode='complete')
 1799:         assert_(q.dtype == a_dtype)
 1800:         assert_(r.dtype == a_dtype)
 1801:         assert_(isinstance(q, a_type))
 1802:         assert_(isinstance(r, a_type))
 1803:         assert_(q.shape[-2:] == (m, m))
 1804:         assert_(r.shape[-2:] == (m, n))
 1805:         assert_almost_equal(matmul(q, r), a)
 1806:         I_mat = np.identity(q.shape[-1])
 1807:         stack_I_mat = np.broadcast_to(I_mat,
 1808:                         q.shape[:-2] + (q.shape[-1],) * 2)
 1809:         assert_almost_equal(matmul(swapaxes(q, -1, -2).conj(), q), stack_I_mat)
 1810:         assert_almost_equal(np.triu(r[..., :, :]), r)
 1811: 
 1812:         # mode == 'reduced'
 1813:         q1, r1 = linalg.qr(a, mode='reduced')
 1814:         assert_(q1.dtype == a_dtype)
 1815:         assert_(r1.dtype == a_dtype)
 1816:         assert_(isinstance(q1, a_type))
 1817:         assert_(isinstance(r1, a_type))
 1818:         assert_(q1.shape[-2:] == (m, k))
 1819:         assert_(r1.shape[-2:] == (k, n))
 1820:         assert_almost_equal(matmul(q1, r1), a)
 1821:         I_mat = np.identity(q1.shape[-1])
 1822:         stack_I_mat = np.broadcast_to(I_mat,
 1823:                         q1.shape[:-2] + (q1.shape[-1],) * 2)
 1824:         assert_almost_equal(matmul(swapaxes(q1, -1, -2).conj(), q1),
 1825:                             stack_I_mat)
 1826:         assert_almost_equal(np.triu(r1[..., :, :]), r1)
 1827: 
 1828:         # mode == 'r'
 1829:         r2 = linalg.qr(a, mode='r')
 1830:         assert_(r2.dtype == a_dtype)
 1831:         assert_(isinstance(r2, a_type))
 1832:         assert_almost_equal(r2, r1)
 1833: 
 1834:     @pytest.mark.parametrize("size", [
 1835:         (3, 4), (4, 3), (4, 4),
 1836:         (3, 0), (0, 3)])
 1837:     @pytest.mark.parametrize("outer_size", [
 1838:         (2, 2), (2,), (2, 3, 4)])
 1839:     @pytest.mark.parametrize("dt", [
 1840:         np.single, np.double,
 1841:         np.csingle, np.cdouble])
 1842:     def test_stacked_inputs(self, outer_size, size, dt):
 1843: 
 1844:         rng = np.random.default_rng(123)
 1845:         A = rng.normal(size=outer_size + size).astype(dt)
 1846:         B = rng.normal(size=outer_size + size).astype(dt)
 1847:         self.check_qr_stacked(A)
 1848:         self.check_qr_stacked(A + 1.j * B)
 1849: 
 1850: 
 1851: class TestCholesky:
 1852: 
 1853:     @pytest.mark.parametrize(
 1854:         'shape', [(1, 1), (2, 2), (3, 3), (50, 50), (3, 10, 10)]
 1855:     )
 1856:     @pytest.mark.parametrize(
 1857:         'dtype', (np.float32, np.float64, np.complex64, np.complex128)
 1858:     )
 1859:     @pytest.mark.parametrize(
 1860:         'upper', [False, True])
 1861:     def test_basic_property(self, shape, dtype, upper):
 1862:         np.random.seed(1)
 1863:         a = np.random.randn(*shape)
 1864:         if np.issubdtype(dtype, np.complexfloating):
 1865:             a = a + 1j * np.random.randn(*shape)
 1866: 
 1867:         t = list(range(len(shape)))
 1868:         t[-2:] = -1, -2
 1869: 
 1870:         a = np.matmul(a.transpose(t).conj(), a)
 1871:         a = np.asarray(a, dtype=dtype)
 1872: 
 1873:         c = np.linalg.cholesky(a, upper=upper)
 1874: 
 1875:         # Check A = L L^H or A = U^H U
 1876:         if upper:
 1877:             b = np.matmul(c.transpose(t).conj(), c)
 1878:         else:
 1879:             b = np.matmul(c, c.transpose(t).conj())
 1880: 
 1881:         atol = 500 * a.shape[0] * np.finfo(dtype).eps
 1882:         assert_allclose(b, a, atol=atol, err_msg=f'{shape} {dtype}\n{a}\n{c}')
 1883: 
 1884:         # Check diag(L or U) is real and positive
 1885:         d = np.diagonal(c, axis1=-2, axis2=-1)
 1886:         assert_(np.all(np.isreal(d)))
 1887:         assert_(np.all(d >= 0))
 1888: 
 1889:     def test_0_size(self):
 1890:         class ArraySubclass(np.ndarray):
 1891:             pass
 1892:         a = np.zeros((0, 1, 1), dtype=np.int_).view(ArraySubclass)
 1893:         res = linalg.cholesky(a)
 1894:         assert_equal(a.shape, res.shape)
 1895:         assert_(res.dtype.type is np.float64)
 1896:         # for documentation purpose:
 1897:         assert_(isinstance(res, np.ndarray))
 1898: 
 1899:         a = np.zeros((1, 0, 0), dtype=np.complex64).view(ArraySubclass)
 1900:         res = linalg.cholesky(a)
 1901:         assert_equal(a.shape, res.shape)
 1902:         assert_(res.dtype.type is np.complex64)
 1903:         assert_(isinstance(res, np.ndarray))
 1904: 
 1905:     def test_upper_lower_arg(self):
 1906:         # Explicit test of upper argument that also checks the default.
 1907:         a = np.array([[1 + 0j, 0 - 2j], [0 + 2j, 5 + 0j]])
 1908: 
 1909:         assert_equal(linalg.cholesky(a), linalg.cholesky(a, upper=False))
 1910: 
 1911:         assert_equal(
 1912:             linalg.cholesky(a, upper=True),
 1913:             linalg.cholesky(a).T.conj()
 1914:         )
 1915: 
 1916: 
 1917: class TestOuter:
 1918:     arr1 = np.arange(3)
 1919:     arr2 = np.arange(3)
 1920:     expected = np.array(
 1921:         [[0, 0, 0],
 1922:          [0, 1, 2],
 1923:          [0, 2, 4]]
 1924:     )
 1925: 
 1926:     assert_array_equal(np.linalg.outer(arr1, arr2), expected)
 1927: 
 1928:     with assert_raises_regex(
 1929:         ValueError, "Input arrays must be one-dimensional"
 1930:     ):
 1931:         np.linalg.outer(arr1[:, np.newaxis], arr2)
 1932: 
 1933: 
 1934: def test_byteorder_check():
 1935:     # Byte order check should pass for native order
 1936:     if sys.byteorder == 'little':
 1937:         native = '<'
 1938:     else:
 1939:         native = '>'
 1940: 
 1941:     for dtt in (np.float32, np.float64):
 1942:         arr = np.eye(4, dtype=dtt)
 1943:         n_arr = arr.view(arr.dtype.newbyteorder(native))
 1944:         sw_arr = arr.view(arr.dtype.newbyteorder("S")).byteswap()
 1945:         assert_equal(arr.dtype.byteorder, '=')
 1946:         for routine in (linalg.inv, linalg.det, linalg.pinv):
 1947:             # Normal call
 1948:             res = routine(arr)
 1949:             # Native but not '='
 1950:             assert_array_equal(res, routine(n_arr))
 1951:             # Swapped
 1952:             assert_array_equal(res, routine(sw_arr))
 1953: 
 1954: 
 1955: @pytest.mark.skipif(IS_WASM, reason="fp errors don't work in wasm")
 1956: def test_generalized_raise_multiloop():
 1957:     # It should raise an error even if the error doesn't occur in the
 1958:     # last iteration of the ufunc inner loop
 1959: 
 1960:     invertible = np.array([[1, 2], [3, 4]])
 1961:     non_invertible = np.array([[1, 1], [1, 1]])
 1962: 
 1963:     x = np.zeros([4, 4, 2, 2])[1::2]
 1964:     x[...] = invertible
 1965:     x[0, 0] = non_invertible
 1966: 
 1967:     assert_raises(np.linalg.LinAlgError, np.linalg.inv, x)
 1968: 
 1969: 
 1970: @pytest.mark.skipif(
 1971:     threading.active_count() > 1,
 1972:     reason="skipping test that uses fork because there are multiple threads")
 1973: @pytest.mark.skipif(
 1974:     NOGIL_BUILD,
 1975:     reason="Cannot safely use fork in tests on the free-threaded build")
 1976: def test_xerbla_override():
 1977:     # Check that our xerbla has been successfully linked in. If it is not,
 1978:     # the default xerbla routine is called, which prints a message to stdout
 1979:     # and may, or may not, abort the process depending on the LAPACK package.
 1980: 
 1981:     XERBLA_OK = 255
 1982: 
 1983:     try:
 1984:         pid = os.fork()
 1985:     except (OSError, AttributeError):
 1986:         # fork failed, or not running on POSIX
 1987:         pytest.skip("Not POSIX or fork failed.")
 1988: 
 1989:     if pid == 0:
 1990:         # child; close i/o file handles
 1991:         os.close(1)
 1992:         os.close(0)
 1993:         # Avoid producing core files.
 1994:         import resource
 1995:         resource.setrlimit(resource.RLIMIT_CORE, (0, 0))
 1996:         # These calls may abort.
 1997:         try:
 1998:             np.linalg.lapack_lite.xerbla()
 1999:         except ValueError:
 2000:             pass
 2001:         except Exception:
 2002:             os._exit(os.EX_CONFIG)
 2003: 
 2004:         try:
 2005:             a = np.array([[1.]])
 2006:             np.linalg.lapack_lite.dorgqr(
 2007:                 1, 1, 1, a,
 2008:                 0,  # <- invalid value
 2009:                 a, a, 0, 0)
 2010:         except ValueError as e:
 2011:             if "DORGQR parameter number 5" in str(e):
 2012:                 # success, reuse error code to mark success as
 2013:                 # FORTRAN STOP returns as success.
 2014:                 os._exit(XERBLA_OK)
 2015: 
 2016:         # Did not abort, but our xerbla was not linked in.
 2017:         os._exit(os.EX_CONFIG)
 2018:     else:
 2019:         # parent
 2020:         pid, status = os.wait()
 2021:         if os.WEXITSTATUS(status) != XERBLA_OK:
 2022:             pytest.skip('Numpy xerbla not linked in.')
 2023: 
 2024: 
 2025: @pytest.mark.skipif(IS_WASM, reason="Cannot start subprocess")
 2026: @pytest.mark.slow
 2027: def test_sdot_bug_8577():
 2028:     # Regression test that loading certain other libraries does not
 2029:     # result to wrong results in float32 linear algebra.
 2030:     #
 2031:     # There's a bug gh-8577 on OSX that can trigger this, and perhaps
 2032:     # there are also other situations in which it occurs.
 2033:     #
 2034:     # Do the check in a separate process.
 2035: 
 2036:     bad_libs = ['PyQt5.QtWidgets', 'IPython']
 2037: 
 2038:     template = textwrap.dedent("""
 2039:     import sys
 2040:     {before}
 2041:     try:
 2042:         import {bad_lib}
 2043:     except ImportError:
 2044:         sys.exit(0)
 2045:     {after}
 2046:     x = np.ones(2, dtype=np.float32)
 2047:     sys.exit(0 if np.allclose(x.dot(x), 2.0) else 1)
 2048:     """)
 2049: 
 2050:     for bad_lib in bad_libs:
 2051:         code = template.format(before="import numpy as np", after="",
 2052:                                bad_lib=bad_lib)
 2053:         subprocess.check_call([sys.executable, "-c", code])
 2054: 
 2055:         # Swapped import order
 2056:         code = template.format(after="import numpy as np", before="",
 2057:                                bad_lib=bad_lib)
 2058:         subprocess.check_call([sys.executable, "-c", code])
 2059: 
 2060: 
 2061: class TestMultiDot:
 2062: 
 2063:     def test_basic_function_with_three_arguments(self):
 2064:         # multi_dot with three arguments uses a fast hand coded algorithm to
 2065:         # determine the optimal order. Therefore test it separately.
 2066:         A = np.random.random((6, 2))
 2067:         B = np.random.random((2, 6))
 2068:         C = np.random.random((6, 2))
 2069: 
 2070:         assert_almost_equal(multi_dot([A, B, C]), A.dot(B).dot(C))
 2071:         assert_almost_equal(multi_dot([A, B, C]), np.dot(A, np.dot(B, C)))
 2072: 
 2073:     def test_basic_function_with_two_arguments(self):
 2074:         # separate code path with two arguments
 2075:         A = np.random.random((6, 2))
 2076:         B = np.random.random((2, 6))
 2077: 
 2078:         assert_almost_equal(multi_dot([A, B]), A.dot(B))
 2079:         assert_almost_equal(multi_dot([A, B]), np.dot(A, B))
 2080: 
 2081:     def test_basic_function_with_dynamic_programming_optimization(self):
 2082:         # multi_dot with four or more arguments uses the dynamic programming
 2083:         # optimization and therefore deserve a separate
 2084:         A = np.random.random((6, 2))
 2085:         B = np.random.random((2, 6))
 2086:         C = np.random.random((6, 2))
 2087:         D = np.random.random((2, 1))
 2088:         assert_almost_equal(multi_dot([A, B, C, D]), A.dot(B).dot(C).dot(D))
 2089: 
 2090:     def test_vector_as_first_argument(self):
 2091:         # The first argument can be 1-D
 2092:         A1d = np.random.random(2)  # 1-D
 2093:         B = np.random.random((2, 6))
 2094:         C = np.random.random((6, 2))
 2095:         D = np.random.random((2, 2))
 2096: 
 2097:         # the result should be 1-D
 2098:         assert_equal(multi_dot([A1d, B, C, D]).shape, (2,))
 2099: 
 2100:     def test_vector_as_last_argument(self):
 2101:         # The last argument can be 1-D
 2102:         A = np.random.random((6, 2))
 2103:         B = np.random.random((2, 6))
 2104:         C = np.random.random((6, 2))
 2105:         D1d = np.random.random(2)  # 1-D
 2106: 
 2107:         # the result should be 1-D
 2108:         assert_equal(multi_dot([A, B, C, D1d]).shape, (6,))
 2109: 
 2110:     def test_vector_as_first_and_last_argument(self):
 2111:         # The first and last arguments can be 1-D
 2112:         A1d = np.random.random(2)  # 1-D
 2113:         B = np.random.random((2, 6))
 2114:         C = np.random.random((6, 2))
 2115:         D1d = np.random.random(2)  # 1-D
 2116: 
 2117:         # the result should be a scalar
 2118:         assert_equal(multi_dot([A1d, B, C, D1d]).shape, ())
 2119: 
 2120:     def test_three_arguments_and_out(self):
 2121:         # multi_dot with three arguments uses a fast hand coded algorithm to
 2122:         # determine the optimal order. Therefore test it separately.
 2123:         A = np.random.random((6, 2))
 2124:         B = np.random.random((2, 6))
 2125:         C = np.random.random((6, 2))
 2126: 
 2127:         out = np.zeros((6, 2))
 2128:         ret = multi_dot([A, B, C], out=out)
 2129:         assert out is ret
 2130:         assert_almost_equal(out, A.dot(B).dot(C))
 2131:         assert_almost_equal(out, np.dot(A, np.dot(B, C)))
 2132: 
 2133:     def test_two_arguments_and_out(self):
 2134:         # separate code path with two arguments
 2135:         A = np.random.random((6, 2))
 2136:         B = np.random.random((2, 6))
 2137:         out = np.zeros((6, 6))
 2138:         ret = multi_dot([A, B], out=out)
 2139:         assert out is ret
 2140:         assert_almost_equal(out, A.dot(B))
 2141:         assert_almost_equal(out, np.dot(A, B))
 2142: 
 2143:     def test_dynamic_programming_optimization_and_out(self):
 2144:         # multi_dot with four or more arguments uses the dynamic programming
 2145:         # optimization and therefore deserve a separate test
 2146:         A = np.random.random((6, 2))
 2147:         B = np.random.random((2, 6))
 2148:         C = np.random.random((6, 2))
 2149:         D = np.random.random((2, 1))
 2150:         out = np.zeros((6, 1))
 2151:         ret = multi_dot([A, B, C, D], out=out)
 2152:         assert out is ret
 2153:         assert_almost_equal(out, A.dot(B).dot(C).dot(D))
 2154: 
 2155:     def test_dynamic_programming_logic(self):
 2156:         # Test for the dynamic programming part
 2157:         # This test is directly taken from Cormen page 376.
 2158:         arrays = [np.random.random((30, 35)),
 2159:                   np.random.random((35, 15)),
 2160:                   np.random.random((15, 5)),
 2161:                   np.random.random((5, 10)),
 2162:                   np.random.random((10, 20)),
 2163:                   np.random.random((20, 25))]
 2164:         m_expected = np.array([[0., 15750., 7875., 9375., 11875., 15125.],
 2165:                                [0.,     0., 2625., 4375.,  7125., 10500.],
 2166:                                [0.,     0.,    0.,  750.,  2500.,  5375.],
 2167:                                [0.,     0.,    0.,    0.,  1000.,  3500.],
 2168:                                [0.,     0.,    0.,    0.,     0.,  5000.],
 2169:                                [0.,     0.,    0.,    0.,     0.,     0.]])
 2170:         s_expected = np.array([[0,  1,  1,  3,  3,  3],
 2171:                                [0,  0,  2,  3,  3,  3],
 2172:                                [0,  0,  0,  3,  3,  3],
 2173:                                [0,  0,  0,  0,  4,  5],
 2174:                                [0,  0,  0,  0,  0,  5],
 2175:                                [0,  0,  0,  0,  0,  0]], dtype=int)
 2176:         s_expected -= 1  # Cormen uses 1-based index, python does not.
 2177: 
 2178:         s, m = _multi_dot_matrix_chain_order(arrays, return_costs=True)
 2179: 
 2180:         # Only the upper triangular part (without the diagonal) is interesting.
 2181:         assert_almost_equal(np.triu(s[:-1, 1:]),
 2182:                             np.triu(s_expected[:-1, 1:]))
 2183:         assert_almost_equal(np.triu(m), np.triu(m_expected))
 2184: 
 2185:     def test_too_few_input_arrays(self):
 2186:         assert_raises(ValueError, multi_dot, [])
 2187:         assert_raises(ValueError, multi_dot, [np.random.random((3, 3))])
 2188: 
 2189: 
 2190: class TestTensorinv:
 2191: 
 2192:     @pytest.mark.parametrize("arr, ind", [
 2193:         (np.ones((4, 6, 8, 2)), 2),
 2194:         (np.ones((3, 3, 2)), 1),
 2195:         ])
 2196:     def test_non_square_handling(self, arr, ind):
 2197:         with assert_raises(LinAlgError):
 2198:             linalg.tensorinv(arr, ind=ind)
 2199: 
 2200:     @pytest.mark.parametrize("shape, ind", [
 2201:         # examples from docstring
 2202:         ((4, 6, 8, 3), 2),
 2203:         ((24, 8, 3), 1),
 2204:         ])
 2205:     def test_tensorinv_shape(self, shape, ind):
 2206:         a = np.eye(24)
 2207:         a.shape = shape
 2208:         ainv = linalg.tensorinv(a=a, ind=ind)
 2209:         expected = a.shape[ind:] + a.shape[:ind]
 2210:         actual = ainv.shape
 2211:         assert_equal(actual, expected)
 2212: 
 2213:     @pytest.mark.parametrize("ind", [
 2214:         0, -2,
 2215:         ])
 2216:     def test_tensorinv_ind_limit(self, ind):
 2217:         a = np.eye(24)
 2218:         a.shape = (4, 6, 8, 3)
 2219:         with assert_raises(ValueError):
 2220:             linalg.tensorinv(a=a, ind=ind)
 2221: 
 2222:     def test_tensorinv_result(self):
 2223:         # mimic a docstring example
 2224:         a = np.eye(24)
 2225:         a.shape = (24, 8, 3)
 2226:         ainv = linalg.tensorinv(a, ind=1)
 2227:         b = np.ones(24)
 2228:         assert_allclose(np.tensordot(ainv, b, 1), np.linalg.tensorsolve(a, b))
 2229: 
 2230: 
 2231: class TestTensorsolve:
 2232: 
 2233:     @pytest.mark.parametrize("a, axes", [
 2234:         (np.ones((4, 6, 8, 2)), None),
 2235:         (np.ones((3, 3, 2)), (0, 2)),
 2236:         ])
 2237:     def test_non_square_handling(self, a, axes):
 2238:         with assert_raises(LinAlgError):
 2239:             b = np.ones(a.shape[:2])
 2240:             linalg.tensorsolve(a, b, axes=axes)
 2241: 
 2242:     @pytest.mark.parametrize("shape",
 2243:         [(2, 3, 6), (3, 4, 4, 3), (0, 3, 3, 0)],
 2244:     )
 2245:     def test_tensorsolve_result(self, shape):
 2246:         a = np.random.randn(*shape)
 2247:         b = np.ones(a.shape[:2])
 2248:         x = np.linalg.tensorsolve(a, b)
 2249:         assert_allclose(np.tensordot(a, x, axes=len(x.shape)), b)
 2250: 
 2251: 
 2252: def test_unsupported_commontype():
 2253:     # linalg gracefully handles unsupported type
 2254:     arr = np.array([[1, -2], [2, 5]], dtype='float16')
 2255:     with assert_raises_regex(TypeError, "unsupported in linalg"):
 2256:         linalg.cholesky(arr)
 2257: 
 2258: 
 2259: #@pytest.mark.slow
 2260: #@pytest.mark.xfail(not HAS_LAPACK64, run=False,
 2261: #                   reason="Numpy not compiled with 64-bit BLAS/LAPACK")
 2262: #@requires_memory(free_bytes=16e9)
 2263: @pytest.mark.skip(reason="Bad memory reports lead to OOM in ci testing")
 2264: def test_blas64_dot():
 2265:     n = 2**32
 2266:     a = np.zeros([1, n], dtype=np.float32)
 2267:     b = np.ones([1, 1], dtype=np.float32)
 2268:     a[0, -1] = 1
 2269:     c = np.dot(b, a)
 2270:     assert_equal(c[0, -1], 1)
 2271: 
 2272: 
 2273: @pytest.mark.xfail(not HAS_LAPACK64,
 2274:                    reason="Numpy not compiled with 64-bit BLAS/LAPACK")
 2275: def test_blas64_geqrf_lwork_smoketest():
 2276:     # Smoke test LAPACK geqrf lwork call with 64-bit integers
 2277:     dtype = np.float64
 2278:     lapack_routine = np.linalg.lapack_lite.dgeqrf
 2279: 
 2280:     m = 2**32 + 1
 2281:     n = 2**32 + 1
 2282:     lda = m
 2283: 
 2284:     # Dummy arrays, not referenced by the lapack routine, so don't
 2285:     # need to be of the right size
 2286:     a = np.zeros([1, 1], dtype=dtype)
 2287:     work = np.zeros([1], dtype=dtype)
 2288:     tau = np.zeros([1], dtype=dtype)
 2289: 
 2290:     # Size query
 2291:     results = lapack_routine(m, n, a, lda, tau, work, -1, 0)
 2292:     assert_equal(results['info'], 0)
 2293:     assert_equal(results['m'], m)
 2294:     assert_equal(results['n'], m)
 2295: 
 2296:     # Should result to an integer of a reasonable size
 2297:     lwork = int(work.item())
 2298:     assert_(2**32 < lwork < 2**42)
 2299: 
 2300: 
 2301: def test_diagonal():
 2302:     # Here we only test if selected axes are compatible
 2303:     # with Array API (last two). Core implementation
 2304:     # of `diagonal` is tested in `test_multiarray.py`.
 2305:     x = np.arange(60).reshape((3, 4, 5))
 2306:     actual = np.linalg.diagonal(x)
 2307:     expected = np.array(
 2308:         [
 2309:             [0,  6, 12, 18],
 2310:             [20, 26, 32, 38],
 2311:             [40, 46, 52, 58],
 2312:         ]
 2313:     )
 2314:     assert_equal(actual, expected)
 2315: 
 2316: 
 2317: def test_trace():
 2318:     # Here we only test if selected axes are compatible
 2319:     # with Array API (last two). Core implementation
 2320:     # of `trace` is tested in `test_multiarray.py`.
 2321:     x = np.arange(60).reshape((3, 4, 5))
 2322:     actual = np.linalg.trace(x)
 2323:     expected = np.array([36, 116, 196])
 2324: 
 2325:     assert_equal(actual, expected)
 2326: 
 2327: 
 2328: def test_cross():
 2329:     x = np.arange(9).reshape((3, 3))
 2330:     actual = np.linalg.cross(x, x + 1)
 2331:     expected = np.array([
 2332:         [-1, 2, -1],
 2333:         [-1, 2, -1],
 2334:         [-1, 2, -1],
 2335:     ])
 2336: 
 2337:     assert_equal(actual, expected)
 2338: 
 2339:     # We test that lists are converted to arrays.
 2340:     u = [1, 2, 3]
 2341:     v = [4, 5, 6]
 2342:     actual = np.linalg.cross(u, v)
 2343:     expected = array([-3,  6, -3])
 2344: 
 2345:     assert_equal(actual, expected)
 2346: 
 2347:     with assert_raises_regex(
 2348:         ValueError,
 2349:         r"input arrays must be \(arrays of\) 3-dimensional vectors"
 2350:     ):
 2351:         x_2dim = x[:, 1:]
 2352:         np.linalg.cross(x_2dim, x_2dim)
 2353: 
 2354: 
 2355: def test_tensordot():
 2356:     # np.linalg.tensordot is just an alias for np.tensordot
 2357:     x = np.arange(6).reshape((2, 3))
 2358: 
 2359:     assert np.linalg.tensordot(x, x) == 55
 2360:     assert np.linalg.tensordot(x, x, axes=[(0, 1), (0, 1)]) == 55
 2361: 
 2362: 
 2363: def test_matmul():
 2364:     # np.linalg.matmul and np.matmul only differs in the number
 2365:     # of arguments in the signature
 2366:     x = np.arange(6).reshape((2, 3))
 2367:     actual = np.linalg.matmul(x, x.T)
 2368:     expected = np.array([[5, 14], [14, 50]])
 2369: 
 2370:     assert_equal(actual, expected)
 2371: 
 2372: 
 2373: def test_matrix_transpose():
 2374:     x = np.arange(6).reshape((2, 3))
 2375:     actual = np.linalg.matrix_transpose(x)
 2376:     expected = x.T
 2377: 
 2378:     assert_equal(actual, expected)
 2379: 
 2380:     with assert_raises_regex(
 2381:         ValueError, "array must be at least 2-dimensional"
 2382:     ):
 2383:         np.linalg.matrix_transpose(x[:, 0])
 2384: 
 2385: 
 2386: def test_matrix_norm():
 2387:     x = np.arange(9).reshape((3, 3))
 2388:     actual = np.linalg.matrix_norm(x)
 2389: 
 2390:     assert_almost_equal(actual, np.float64(14.2828), double_decimal=3)
 2391: 
 2392:     actual = np.linalg.matrix_norm(x, keepdims=True)
 2393: 
 2394:     assert_almost_equal(actual, np.array([[14.2828]]), double_decimal=3)
 2395: 
 2396: 
 2397: def test_matrix_norm_empty():
 2398:     for shape in [(0, 2), (2, 0), (0, 0)]:
 2399:         for dtype in [np.float64, np.float32, np.int32]:
 2400:             x = np.zeros(shape, dtype)
 2401:             assert_equal(np.linalg.matrix_norm(x, ord="fro"), 0)
 2402:             assert_equal(np.linalg.matrix_norm(x, ord="nuc"), 0)
 2403:             assert_equal(np.linalg.matrix_norm(x, ord=1), 0)
 2404:             assert_equal(np.linalg.matrix_norm(x, ord=2), 0)
 2405:             assert_equal(np.linalg.matrix_norm(x, ord=np.inf), 0)
 2406: 
 2407: def test_vector_norm():
 2408:     x = np.arange(9).reshape((3, 3))
 2409:     actual = np.linalg.vector_norm(x)
 2410: 
 2411:     assert_almost_equal(actual, np.float64(14.2828), double_decimal=3)
 2412: 
 2413:     actual = np.linalg.vector_norm(x, axis=0)
 2414: 
 2415:     assert_almost_equal(
 2416:         actual, np.array([6.7082, 8.124, 9.6436]), double_decimal=3
 2417:     )
 2418: 
 2419:     actual = np.linalg.vector_norm(x, keepdims=True)
 2420:     expected = np.full((1, 1), 14.2828, dtype='float64')
 2421:     assert_equal(actual.shape, expected.shape)
 2422:     assert_almost_equal(actual, expected, double_decimal=3)
 2423: 
 2424: 
 2425: def test_vector_norm_empty():
 2426:     for dtype in [np.float64, np.float32, np.int32]:
 2427:         x = np.zeros(0, dtype)
 2428:         assert_equal(np.linalg.vector_norm(x, ord=1), 0)
 2429:         assert_equal(np.linalg.vector_norm(x, ord=2), 0)
 2430:         assert_equal(np.linalg.vector_norm(x, ord=np.inf), 0)
