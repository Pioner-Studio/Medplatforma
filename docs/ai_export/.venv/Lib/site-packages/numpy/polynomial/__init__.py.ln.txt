    1: """
    2: A sub-package for efficiently dealing with polynomials.
    3: 
    4: Within the documentation for this sub-package, a "finite power series,"
    5: i.e., a polynomial (also referred to simply as a "series") is represented
    6: by a 1-D numpy array of the polynomial's coefficients, ordered from lowest
    7: order term to highest.  For example, array([1,2,3]) represents
    8: ``P_0 + 2*P_1 + 3*P_2``, where P_n is the n-th order basis polynomial
    9: applicable to the specific module in question, e.g., `polynomial` (which
   10: "wraps" the "standard" basis) or `chebyshev`.  For optimal performance,
   11: all operations on polynomials, including evaluation at an argument, are
   12: implemented as operations on the coefficients.  Additional (module-specific)
   13: information can be found in the docstring for the module of interest.
   14: 
   15: This package provides *convenience classes* for each of six different kinds
   16: of polynomials:
   17: 
   18: ========================    ================
   19: **Name**                    **Provides**
   20: ========================    ================
   21: `~polynomial.Polynomial`    Power series
   22: `~chebyshev.Chebyshev`      Chebyshev series
   23: `~legendre.Legendre`        Legendre series
   24: `~laguerre.Laguerre`        Laguerre series
   25: `~hermite.Hermite`          Hermite series
   26: `~hermite_e.HermiteE`       HermiteE series
   27: ========================    ================
   28: 
   29: These *convenience classes* provide a consistent interface for creating,
   30: manipulating, and fitting data with polynomials of different bases.
   31: The convenience classes are the preferred interface for the `~numpy.polynomial`
   32: package, and are available from the ``numpy.polynomial`` namespace.
   33: This eliminates the need to navigate to the corresponding submodules, e.g.
   34: ``np.polynomial.Polynomial`` or ``np.polynomial.Chebyshev`` instead of
   35: ``np.polynomial.polynomial.Polynomial`` or
   36: ``np.polynomial.chebyshev.Chebyshev``, respectively.
   37: The classes provide a more consistent and concise interface than the
   38: type-specific functions defined in the submodules for each type of polynomial.
   39: For example, to fit a Chebyshev polynomial with degree ``1`` to data given
   40: by arrays ``xdata`` and ``ydata``, the
   41: `~chebyshev.Chebyshev.fit` class method::
   42: 
   43:     >>> from numpy.polynomial import Chebyshev
   44:     >>> xdata = [1, 2, 3, 4]
   45:     >>> ydata = [1, 4, 9, 16]
   46:     >>> c = Chebyshev.fit(xdata, ydata, deg=1)
   47: 
   48: is preferred over the `chebyshev.chebfit` function from the
   49: ``np.polynomial.chebyshev`` module::
   50: 
   51:     >>> from numpy.polynomial.chebyshev import chebfit
   52:     >>> c = chebfit(xdata, ydata, deg=1)
   53: 
   54: See :doc:`routines.polynomials.classes` for more details.
   55: 
   56: Convenience Classes
   57: ===================
   58: 
   59: The following lists the various constants and methods common to all of
   60: the classes representing the various kinds of polynomials. In the following,
   61: the term ``Poly`` represents any one of the convenience classes (e.g.
   62: `~polynomial.Polynomial`, `~chebyshev.Chebyshev`, `~hermite.Hermite`, etc.)
   63: while the lowercase ``p`` represents an **instance** of a polynomial class.
   64: 
   65: Constants
   66: ---------
   67: 
   68: - ``Poly.domain``     -- Default domain
   69: - ``Poly.window``     -- Default window
   70: - ``Poly.basis_name`` -- String used to represent the basis
   71: - ``Poly.maxpower``   -- Maximum value ``n`` such that ``p**n`` is allowed
   72: 
   73: Creation
   74: --------
   75: 
   76: Methods for creating polynomial instances.
   77: 
   78: - ``Poly.basis(degree)``    -- Basis polynomial of given degree
   79: - ``Poly.identity()``       -- ``p`` where ``p(x) = x`` for all ``x``
   80: - ``Poly.fit(x, y, deg)``   -- ``p`` of degree ``deg`` with coefficients
   81:   determined by the least-squares fit to the data ``x``, ``y``
   82: - ``Poly.fromroots(roots)`` -- ``p`` with specified roots
   83: - ``p.copy()``              -- Create a copy of ``p``
   84: 
   85: Conversion
   86: ----------
   87: 
   88: Methods for converting a polynomial instance of one kind to another.
   89: 
   90: - ``p.cast(Poly)``    -- Convert ``p`` to instance of kind ``Poly``
   91: - ``p.convert(Poly)`` -- Convert ``p`` to instance of kind ``Poly`` or map
   92:   between ``domain`` and ``window``
   93: 
   94: Calculus
   95: --------
   96: - ``p.deriv()`` -- Take the derivative of ``p``
   97: - ``p.integ()`` -- Integrate ``p``
   98: 
   99: Validation
  100: ----------
  101: - ``Poly.has_samecoef(p1, p2)``   -- Check if coefficients match
  102: - ``Poly.has_samedomain(p1, p2)`` -- Check if domains match
  103: - ``Poly.has_sametype(p1, p2)``   -- Check if types match
  104: - ``Poly.has_samewindow(p1, p2)`` -- Check if windows match
  105: 
  106: Misc
  107: ----
  108: - ``p.linspace()`` -- Return ``x, p(x)`` at equally-spaced points in ``domain``
  109: - ``p.mapparms()`` -- Return the parameters for the linear mapping between
  110:   ``domain`` and ``window``.
  111: - ``p.roots()``    -- Return the roots of ``p``.
  112: - ``p.trim()``     -- Remove trailing coefficients.
  113: - ``p.cutdeg(degree)`` -- Truncate ``p`` to given degree
  114: - ``p.truncate(size)`` -- Truncate ``p`` to given size
  115: 
  116: """
  117: from .chebyshev import Chebyshev
  118: from .hermite import Hermite
  119: from .hermite_e import HermiteE
  120: from .laguerre import Laguerre
  121: from .legendre import Legendre
  122: from .polynomial import Polynomial
  123: 
  124: __all__ = [  # noqa: F822
  125:     "set_default_printstyle",
  126:     "polynomial", "Polynomial",
  127:     "chebyshev", "Chebyshev",
  128:     "legendre", "Legendre",
  129:     "hermite", "Hermite",
  130:     "hermite_e", "HermiteE",
  131:     "laguerre", "Laguerre",
  132: ]
  133: 
  134: 
  135: def set_default_printstyle(style):
  136:     """
  137:     Set the default format for the string representation of polynomials.
  138: 
  139:     Values for ``style`` must be valid inputs to ``__format__``, i.e. 'ascii'
  140:     or 'unicode'.
  141: 
  142:     Parameters
  143:     ----------
  144:     style : str
  145:         Format string for default printing style. Must be either 'ascii' or
  146:         'unicode'.
  147: 
  148:     Notes
  149:     -----
  150:     The default format depends on the platform: 'unicode' is used on
  151:     Unix-based systems and 'ascii' on Windows. This determination is based on
  152:     default font support for the unicode superscript and subscript ranges.
  153: 
  154:     Examples
  155:     --------
  156:     >>> p = np.polynomial.Polynomial([1, 2, 3])
  157:     >>> c = np.polynomial.Chebyshev([1, 2, 3])
  158:     >>> np.polynomial.set_default_printstyle('unicode')
  159:     >>> print(p)
  160:     1.0 + 2.0В·x + 3.0В·xВІ
  161:     >>> print(c)
  162:     1.0 + 2.0В·Tв‚Ѓ(x) + 3.0В·Tв‚‚(x)
  163:     >>> np.polynomial.set_default_printstyle('ascii')
  164:     >>> print(p)
  165:     1.0 + 2.0 x + 3.0 x**2
  166:     >>> print(c)
  167:     1.0 + 2.0 T_1(x) + 3.0 T_2(x)
  168:     >>> # Formatting supersedes all class/package-level defaults
  169:     >>> print(f"{p:unicode}")
  170:     1.0 + 2.0В·x + 3.0В·xВІ
  171:     """
  172:     if style not in ('unicode', 'ascii'):
  173:         raise ValueError(
  174:             f"Unsupported format string '{style}'. Valid options are 'ascii' "
  175:             f"and 'unicode'"
  176:         )
  177:     _use_unicode = True
  178:     if style == 'ascii':
  179:         _use_unicode = False
  180:     from ._polybase import ABCPolyBase
  181:     ABCPolyBase._use_unicode = _use_unicode
  182: 
  183: 
  184: from numpy._pytesttester import PytestTester
  185: 
  186: test = PytestTester(__name__)
  187: del PytestTester
