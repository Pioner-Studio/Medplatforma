    1: """
    2: ====================================================
    3: Chebyshev Series (:mod:`numpy.polynomial.chebyshev`)
    4: ====================================================
    5: 
    6: This module provides a number of objects (mostly functions) useful for
    7: dealing with Chebyshev series, including a `Chebyshev` class that
    8: encapsulates the usual arithmetic operations.  (General information
    9: on how this module represents and works with such polynomials is in the
   10: docstring for its "parent" sub-package, `numpy.polynomial`).
   11: 
   12: Classes
   13: -------
   14: 
   15: .. autosummary::
   16:    :toctree: generated/
   17: 
   18:    Chebyshev
   19: 
   20: 
   21: Constants
   22: ---------
   23: 
   24: .. autosummary::
   25:    :toctree: generated/
   26: 
   27:    chebdomain
   28:    chebzero
   29:    chebone
   30:    chebx
   31: 
   32: Arithmetic
   33: ----------
   34: 
   35: .. autosummary::
   36:    :toctree: generated/
   37: 
   38:    chebadd
   39:    chebsub
   40:    chebmulx
   41:    chebmul
   42:    chebdiv
   43:    chebpow
   44:    chebval
   45:    chebval2d
   46:    chebval3d
   47:    chebgrid2d
   48:    chebgrid3d
   49: 
   50: Calculus
   51: --------
   52: 
   53: .. autosummary::
   54:    :toctree: generated/
   55: 
   56:    chebder
   57:    chebint
   58: 
   59: Misc Functions
   60: --------------
   61: 
   62: .. autosummary::
   63:    :toctree: generated/
   64: 
   65:    chebfromroots
   66:    chebroots
   67:    chebvander
   68:    chebvander2d
   69:    chebvander3d
   70:    chebgauss
   71:    chebweight
   72:    chebcompanion
   73:    chebfit
   74:    chebpts1
   75:    chebpts2
   76:    chebtrim
   77:    chebline
   78:    cheb2poly
   79:    poly2cheb
   80:    chebinterpolate
   81: 
   82: See also
   83: --------
   84: `numpy.polynomial`
   85: 
   86: Notes
   87: -----
   88: The implementations of multiplication, division, integration, and
   89: differentiation use the algebraic identities [1]_:
   90: 
   91: .. math::
   92:     T_n(x) = \\frac{z^n + z^{-n}}{2} \\\\
   93:     z\\frac{dx}{dz} = \\frac{z - z^{-1}}{2}.
   94: 
   95: where
   96: 
   97: .. math:: x = \\frac{z + z^{-1}}{2}.
   98: 
   99: These identities allow a Chebyshev series to be expressed as a finite,
  100: symmetric Laurent series.  In this module, this sort of Laurent series
  101: is referred to as a "z-series."
  102: 
  103: References
  104: ----------
  105: .. [1] A. T. Benjamin, et al., "Combinatorial Trigonometry with Chebyshev
  106:   Polynomials," *Journal of Statistical Planning and Inference 14*, 2008
  107:   (https://web.archive.org/web/20080221202153/https://www.math.hmc.edu/~benjamin/papers/CombTrig.pdf, pg. 4)
  108: 
  109: """  # noqa: E501
  110: import numpy as np
  111: import numpy.linalg as la
  112: from numpy.lib.array_utils import normalize_axis_index
  113: 
  114: from . import polyutils as pu
  115: from ._polybase import ABCPolyBase
  116: 
  117: __all__ = [
  118:     'chebzero', 'chebone', 'chebx', 'chebdomain', 'chebline', 'chebadd',
  119:     'chebsub', 'chebmulx', 'chebmul', 'chebdiv', 'chebpow', 'chebval',
  120:     'chebder', 'chebint', 'cheb2poly', 'poly2cheb', 'chebfromroots',
  121:     'chebvander', 'chebfit', 'chebtrim', 'chebroots', 'chebpts1',
  122:     'chebpts2', 'Chebyshev', 'chebval2d', 'chebval3d', 'chebgrid2d',
  123:     'chebgrid3d', 'chebvander2d', 'chebvander3d', 'chebcompanion',
  124:     'chebgauss', 'chebweight', 'chebinterpolate']
  125: 
  126: chebtrim = pu.trimcoef
  127: 
  128: #
  129: # A collection of functions for manipulating z-series. These are private
  130: # functions and do minimal error checking.
  131: #
  132: 
  133: def _cseries_to_zseries(c):
  134:     """Convert Chebyshev series to z-series.
  135: 
  136:     Convert a Chebyshev series to the equivalent z-series. The result is
  137:     never an empty array. The dtype of the return is the same as that of
  138:     the input. No checks are run on the arguments as this routine is for
  139:     internal use.
  140: 
  141:     Parameters
  142:     ----------
  143:     c : 1-D ndarray
  144:         Chebyshev coefficients, ordered from low to high
  145: 
  146:     Returns
  147:     -------
  148:     zs : 1-D ndarray
  149:         Odd length symmetric z-series, ordered from  low to high.
  150: 
  151:     """
  152:     n = c.size
  153:     zs = np.zeros(2 * n - 1, dtype=c.dtype)
  154:     zs[n - 1:] = c / 2
  155:     return zs + zs[::-1]
  156: 
  157: 
  158: def _zseries_to_cseries(zs):
  159:     """Convert z-series to a Chebyshev series.
  160: 
  161:     Convert a z series to the equivalent Chebyshev series. The result is
  162:     never an empty array. The dtype of the return is the same as that of
  163:     the input. No checks are run on the arguments as this routine is for
  164:     internal use.
  165: 
  166:     Parameters
  167:     ----------
  168:     zs : 1-D ndarray
  169:         Odd length symmetric z-series, ordered from  low to high.
  170: 
  171:     Returns
  172:     -------
  173:     c : 1-D ndarray
  174:         Chebyshev coefficients, ordered from  low to high.
  175: 
  176:     """
  177:     n = (zs.size + 1) // 2
  178:     c = zs[n - 1:].copy()
  179:     c[1:n] *= 2
  180:     return c
  181: 
  182: 
  183: def _zseries_mul(z1, z2):
  184:     """Multiply two z-series.
  185: 
  186:     Multiply two z-series to produce a z-series.
  187: 
  188:     Parameters
  189:     ----------
  190:     z1, z2 : 1-D ndarray
  191:         The arrays must be 1-D but this is not checked.
  192: 
  193:     Returns
  194:     -------
  195:     product : 1-D ndarray
  196:         The product z-series.
  197: 
  198:     Notes
  199:     -----
  200:     This is simply convolution. If symmetric/anti-symmetric z-series are
  201:     denoted by S/A then the following rules apply:
  202: 
  203:     S*S, A*A -> S
  204:     S*A, A*S -> A
  205: 
  206:     """
  207:     return np.convolve(z1, z2)
  208: 
  209: 
  210: def _zseries_div(z1, z2):
  211:     """Divide the first z-series by the second.
  212: 
  213:     Divide `z1` by `z2` and return the quotient and remainder as z-series.
  214:     Warning: this implementation only applies when both z1 and z2 have the
  215:     same symmetry, which is sufficient for present purposes.
  216: 
  217:     Parameters
  218:     ----------
  219:     z1, z2 : 1-D ndarray
  220:         The arrays must be 1-D and have the same symmetry, but this is not
  221:         checked.
  222: 
  223:     Returns
  224:     -------
  225: 
  226:     (quotient, remainder) : 1-D ndarrays
  227:         Quotient and remainder as z-series.
  228: 
  229:     Notes
  230:     -----
  231:     This is not the same as polynomial division on account of the desired form
  232:     of the remainder. If symmetric/anti-symmetric z-series are denoted by S/A
  233:     then the following rules apply:
  234: 
  235:     S/S -> S,S
  236:     A/A -> S,A
  237: 
  238:     The restriction to types of the same symmetry could be fixed but seems like
  239:     unneeded generality. There is no natural form for the remainder in the case
  240:     where there is no symmetry.
  241: 
  242:     """
  243:     z1 = z1.copy()
  244:     z2 = z2.copy()
  245:     lc1 = len(z1)
  246:     lc2 = len(z2)
  247:     if lc2 == 1:
  248:         z1 /= z2
  249:         return z1, z1[:1] * 0
  250:     elif lc1 < lc2:
  251:         return z1[:1] * 0, z1
  252:     else:
  253:         dlen = lc1 - lc2
  254:         scl = z2[0]
  255:         z2 /= scl
  256:         quo = np.empty(dlen + 1, dtype=z1.dtype)
  257:         i = 0
  258:         j = dlen
  259:         while i < j:
  260:             r = z1[i]
  261:             quo[i] = z1[i]
  262:             quo[dlen - i] = r
  263:             tmp = r * z2
  264:             z1[i:i + lc2] -= tmp
  265:             z1[j:j + lc2] -= tmp
  266:             i += 1
  267:             j -= 1
  268:         r = z1[i]
  269:         quo[i] = r
  270:         tmp = r * z2
  271:         z1[i:i + lc2] -= tmp
  272:         quo /= scl
  273:         rem = z1[i + 1:i - 1 + lc2].copy()
  274:         return quo, rem
  275: 
  276: 
  277: def _zseries_der(zs):
  278:     """Differentiate a z-series.
  279: 
  280:     The derivative is with respect to x, not z. This is achieved using the
  281:     chain rule and the value of dx/dz given in the module notes.
  282: 
  283:     Parameters
  284:     ----------
  285:     zs : z-series
  286:         The z-series to differentiate.
  287: 
  288:     Returns
  289:     -------
  290:     derivative : z-series
  291:         The derivative
  292: 
  293:     Notes
  294:     -----
  295:     The zseries for x (ns) has been multiplied by two in order to avoid
  296:     using floats that are incompatible with Decimal and likely other
  297:     specialized scalar types. This scaling has been compensated by
  298:     multiplying the value of zs by two also so that the two cancels in the
  299:     division.
  300: 
  301:     """
  302:     n = len(zs) // 2
  303:     ns = np.array([-1, 0, 1], dtype=zs.dtype)
  304:     zs *= np.arange(-n, n + 1) * 2
  305:     d, r = _zseries_div(zs, ns)
  306:     return d
  307: 
  308: 
  309: def _zseries_int(zs):
  310:     """Integrate a z-series.
  311: 
  312:     The integral is with respect to x, not z. This is achieved by a change
  313:     of variable using dx/dz given in the module notes.
  314: 
  315:     Parameters
  316:     ----------
  317:     zs : z-series
  318:         The z-series to integrate
  319: 
  320:     Returns
  321:     -------
  322:     integral : z-series
  323:         The indefinite integral
  324: 
  325:     Notes
  326:     -----
  327:     The zseries for x (ns) has been multiplied by two in order to avoid
  328:     using floats that are incompatible with Decimal and likely other
  329:     specialized scalar types. This scaling has been compensated by
  330:     dividing the resulting zs by two.
  331: 
  332:     """
  333:     n = 1 + len(zs) // 2
  334:     ns = np.array([-1, 0, 1], dtype=zs.dtype)
  335:     zs = _zseries_mul(zs, ns)
  336:     div = np.arange(-n, n + 1) * 2
  337:     zs[:n] /= div[:n]
  338:     zs[n + 1:] /= div[n + 1:]
  339:     zs[n] = 0
  340:     return zs
  341: 
  342: #
  343: # Chebyshev series functions
  344: #
  345: 
  346: 
  347: def poly2cheb(pol):
  348:     """
  349:     Convert a polynomial to a Chebyshev series.
  350: 
  351:     Convert an array representing the coefficients of a polynomial (relative
  352:     to the "standard" basis) ordered from lowest degree to highest, to an
  353:     array of the coefficients of the equivalent Chebyshev series, ordered
  354:     from lowest to highest degree.
  355: 
  356:     Parameters
  357:     ----------
  358:     pol : array_like
  359:         1-D array containing the polynomial coefficients
  360: 
  361:     Returns
  362:     -------
  363:     c : ndarray
  364:         1-D array containing the coefficients of the equivalent Chebyshev
  365:         series.
  366: 
  367:     See Also
  368:     --------
  369:     cheb2poly
  370: 
  371:     Notes
  372:     -----
  373:     The easy way to do conversions between polynomial basis sets
  374:     is to use the convert method of a class instance.
  375: 
  376:     Examples
  377:     --------
  378:     >>> from numpy import polynomial as P
  379:     >>> p = P.Polynomial(range(4))
  380:     >>> p
  381:     Polynomial([0., 1., 2., 3.], domain=[-1.,  1.], window=[-1.,  1.], symbol='x')
  382:     >>> c = p.convert(kind=P.Chebyshev)
  383:     >>> c
  384:     Chebyshev([1.  , 3.25, 1.  , 0.75], domain=[-1.,  1.], window=[-1., ...
  385:     >>> P.chebyshev.poly2cheb(range(4))
  386:     array([1.  , 3.25, 1.  , 0.75])
  387: 
  388:     """
  389:     [pol] = pu.as_series([pol])
  390:     deg = len(pol) - 1
  391:     res = 0
  392:     for i in range(deg, -1, -1):
  393:         res = chebadd(chebmulx(res), pol[i])
  394:     return res
  395: 
  396: 
  397: def cheb2poly(c):
  398:     """
  399:     Convert a Chebyshev series to a polynomial.
  400: 
  401:     Convert an array representing the coefficients of a Chebyshev series,
  402:     ordered from lowest degree to highest, to an array of the coefficients
  403:     of the equivalent polynomial (relative to the "standard" basis) ordered
  404:     from lowest to highest degree.
  405: 
  406:     Parameters
  407:     ----------
  408:     c : array_like
  409:         1-D array containing the Chebyshev series coefficients, ordered
  410:         from lowest order term to highest.
  411: 
  412:     Returns
  413:     -------
  414:     pol : ndarray
  415:         1-D array containing the coefficients of the equivalent polynomial
  416:         (relative to the "standard" basis) ordered from lowest order term
  417:         to highest.
  418: 
  419:     See Also
  420:     --------
  421:     poly2cheb
  422: 
  423:     Notes
  424:     -----
  425:     The easy way to do conversions between polynomial basis sets
  426:     is to use the convert method of a class instance.
  427: 
  428:     Examples
  429:     --------
  430:     >>> from numpy import polynomial as P
  431:     >>> c = P.Chebyshev(range(4))
  432:     >>> c
  433:     Chebyshev([0., 1., 2., 3.], domain=[-1.,  1.], window=[-1.,  1.], symbol='x')
  434:     >>> p = c.convert(kind=P.Polynomial)
  435:     >>> p
  436:     Polynomial([-2., -8.,  4., 12.], domain=[-1.,  1.], window=[-1.,  1.], ...
  437:     >>> P.chebyshev.cheb2poly(range(4))
  438:     array([-2.,  -8.,   4.,  12.])
  439: 
  440:     """
  441:     from .polynomial import polyadd, polymulx, polysub
  442: 
  443:     [c] = pu.as_series([c])
  444:     n = len(c)
  445:     if n < 3:
  446:         return c
  447:     else:
  448:         c0 = c[-2]
  449:         c1 = c[-1]
  450:         # i is the current degree of c1
  451:         for i in range(n - 1, 1, -1):
  452:             tmp = c0
  453:             c0 = polysub(c[i - 2], c1)
  454:             c1 = polyadd(tmp, polymulx(c1) * 2)
  455:         return polyadd(c0, polymulx(c1))
  456: 
  457: 
  458: #
  459: # These are constant arrays are of integer type so as to be compatible
  460: # with the widest range of other types, such as Decimal.
  461: #
  462: 
  463: # Chebyshev default domain.
  464: chebdomain = np.array([-1., 1.])
  465: 
  466: # Chebyshev coefficients representing zero.
  467: chebzero = np.array([0])
  468: 
  469: # Chebyshev coefficients representing one.
  470: chebone = np.array([1])
  471: 
  472: # Chebyshev coefficients representing the identity x.
  473: chebx = np.array([0, 1])
  474: 
  475: 
  476: def chebline(off, scl):
  477:     """
  478:     Chebyshev series whose graph is a straight line.
  479: 
  480:     Parameters
  481:     ----------
  482:     off, scl : scalars
  483:         The specified line is given by ``off + scl*x``.
  484: 
  485:     Returns
  486:     -------
  487:     y : ndarray
  488:         This module's representation of the Chebyshev series for
  489:         ``off + scl*x``.
  490: 
  491:     See Also
  492:     --------
  493:     numpy.polynomial.polynomial.polyline
  494:     numpy.polynomial.legendre.legline
  495:     numpy.polynomial.laguerre.lagline
  496:     numpy.polynomial.hermite.hermline
  497:     numpy.polynomial.hermite_e.hermeline
  498: 
  499:     Examples
  500:     --------
  501:     >>> import numpy.polynomial.chebyshev as C
  502:     >>> C.chebline(3,2)
  503:     array([3, 2])
  504:     >>> C.chebval(-3, C.chebline(3,2)) # should be -3
  505:     -3.0
  506: 
  507:     """
  508:     if scl != 0:
  509:         return np.array([off, scl])
  510:     else:
  511:         return np.array([off])
  512: 
  513: 
  514: def chebfromroots(roots):
  515:     """
  516:     Generate a Chebyshev series with given roots.
  517: 
  518:     The function returns the coefficients of the polynomial
  519: 
  520:     .. math:: p(x) = (x - r_0) * (x - r_1) * ... * (x - r_n),
  521: 
  522:     in Chebyshev form, where the :math:`r_n` are the roots specified in
  523:     `roots`.  If a zero has multiplicity n, then it must appear in `roots`
  524:     n times.  For instance, if 2 is a root of multiplicity three and 3 is a
  525:     root of multiplicity 2, then `roots` looks something like [2, 2, 2, 3, 3].
  526:     The roots can appear in any order.
  527: 
  528:     If the returned coefficients are `c`, then
  529: 
  530:     .. math:: p(x) = c_0 + c_1 * T_1(x) + ... +  c_n * T_n(x)
  531: 
  532:     The coefficient of the last term is not generally 1 for monic
  533:     polynomials in Chebyshev form.
  534: 
  535:     Parameters
  536:     ----------
  537:     roots : array_like
  538:         Sequence containing the roots.
  539: 
  540:     Returns
  541:     -------
  542:     out : ndarray
  543:         1-D array of coefficients.  If all roots are real then `out` is a
  544:         real array, if some of the roots are complex, then `out` is complex
  545:         even if all the coefficients in the result are real (see Examples
  546:         below).
  547: 
  548:     See Also
  549:     --------
  550:     numpy.polynomial.polynomial.polyfromroots
  551:     numpy.polynomial.legendre.legfromroots
  552:     numpy.polynomial.laguerre.lagfromroots
  553:     numpy.polynomial.hermite.hermfromroots
  554:     numpy.polynomial.hermite_e.hermefromroots
  555: 
  556:     Examples
  557:     --------
  558:     >>> import numpy.polynomial.chebyshev as C
  559:     >>> C.chebfromroots((-1,0,1)) # x^3 - x relative to the standard basis
  560:     array([ 0.  , -0.25,  0.  ,  0.25])
  561:     >>> j = complex(0,1)
  562:     >>> C.chebfromroots((-j,j)) # x^2 + 1 relative to the standard basis
  563:     array([1.5+0.j, 0. +0.j, 0.5+0.j])
  564: 
  565:     """
  566:     return pu._fromroots(chebline, chebmul, roots)
  567: 
  568: 
  569: def chebadd(c1, c2):
  570:     """
  571:     Add one Chebyshev series to another.
  572: 
  573:     Returns the sum of two Chebyshev series `c1` + `c2`.  The arguments
  574:     are sequences of coefficients ordered from lowest order term to
  575:     highest, i.e., [1,2,3] represents the series ``T_0 + 2*T_1 + 3*T_2``.
  576: 
  577:     Parameters
  578:     ----------
  579:     c1, c2 : array_like
  580:         1-D arrays of Chebyshev series coefficients ordered from low to
  581:         high.
  582: 
  583:     Returns
  584:     -------
  585:     out : ndarray
  586:         Array representing the Chebyshev series of their sum.
  587: 
  588:     See Also
  589:     --------
  590:     chebsub, chebmulx, chebmul, chebdiv, chebpow
  591: 
  592:     Notes
  593:     -----
  594:     Unlike multiplication, division, etc., the sum of two Chebyshev series
  595:     is a Chebyshev series (without having to "reproject" the result onto
  596:     the basis set) so addition, just like that of "standard" polynomials,
  597:     is simply "component-wise."
  598: 
  599:     Examples
  600:     --------
  601:     >>> from numpy.polynomial import chebyshev as C
  602:     >>> c1 = (1,2,3)
  603:     >>> c2 = (3,2,1)
  604:     >>> C.chebadd(c1,c2)
  605:     array([4., 4., 4.])
  606: 
  607:     """
  608:     return pu._add(c1, c2)
  609: 
  610: 
  611: def chebsub(c1, c2):
  612:     """
  613:     Subtract one Chebyshev series from another.
  614: 
  615:     Returns the difference of two Chebyshev series `c1` - `c2`.  The
  616:     sequences of coefficients are from lowest order term to highest, i.e.,
  617:     [1,2,3] represents the series ``T_0 + 2*T_1 + 3*T_2``.
  618: 
  619:     Parameters
  620:     ----------
  621:     c1, c2 : array_like
  622:         1-D arrays of Chebyshev series coefficients ordered from low to
  623:         high.
  624: 
  625:     Returns
  626:     -------
  627:     out : ndarray
  628:         Of Chebyshev series coefficients representing their difference.
  629: 
  630:     See Also
  631:     --------
  632:     chebadd, chebmulx, chebmul, chebdiv, chebpow
  633: 
  634:     Notes
  635:     -----
  636:     Unlike multiplication, division, etc., the difference of two Chebyshev
  637:     series is a Chebyshev series (without having to "reproject" the result
  638:     onto the basis set) so subtraction, just like that of "standard"
  639:     polynomials, is simply "component-wise."
  640: 
  641:     Examples
  642:     --------
  643:     >>> from numpy.polynomial import chebyshev as C
  644:     >>> c1 = (1,2,3)
  645:     >>> c2 = (3,2,1)
  646:     >>> C.chebsub(c1,c2)
  647:     array([-2.,  0.,  2.])
  648:     >>> C.chebsub(c2,c1) # -C.chebsub(c1,c2)
  649:     array([ 2.,  0., -2.])
  650: 
  651:     """
  652:     return pu._sub(c1, c2)
  653: 
  654: 
  655: def chebmulx(c):
  656:     """Multiply a Chebyshev series by x.
  657: 
  658:     Multiply the polynomial `c` by x, where x is the independent
  659:     variable.
  660: 
  661: 
  662:     Parameters
  663:     ----------
  664:     c : array_like
  665:         1-D array of Chebyshev series coefficients ordered from low to
  666:         high.
  667: 
  668:     Returns
  669:     -------
  670:     out : ndarray
  671:         Array representing the result of the multiplication.
  672: 
  673:     See Also
  674:     --------
  675:     chebadd, chebsub, chebmul, chebdiv, chebpow
  676: 
  677:     Examples
  678:     --------
  679:     >>> from numpy.polynomial import chebyshev as C
  680:     >>> C.chebmulx([1,2,3])
  681:     array([1. , 2.5, 1. , 1.5])
  682: 
  683:     """
  684:     # c is a trimmed copy
  685:     [c] = pu.as_series([c])
  686:     # The zero series needs special treatment
  687:     if len(c) == 1 and c[0] == 0:
  688:         return c
  689: 
  690:     prd = np.empty(len(c) + 1, dtype=c.dtype)
  691:     prd[0] = c[0] * 0
  692:     prd[1] = c[0]
  693:     if len(c) > 1:
  694:         tmp = c[1:] / 2
  695:         prd[2:] = tmp
  696:         prd[0:-2] += tmp
  697:     return prd
  698: 
  699: 
  700: def chebmul(c1, c2):
  701:     """
  702:     Multiply one Chebyshev series by another.
  703: 
  704:     Returns the product of two Chebyshev series `c1` * `c2`.  The arguments
  705:     are sequences of coefficients, from lowest order "term" to highest,
  706:     e.g., [1,2,3] represents the series ``T_0 + 2*T_1 + 3*T_2``.
  707: 
  708:     Parameters
  709:     ----------
  710:     c1, c2 : array_like
  711:         1-D arrays of Chebyshev series coefficients ordered from low to
  712:         high.
  713: 
  714:     Returns
  715:     -------
  716:     out : ndarray
  717:         Of Chebyshev series coefficients representing their product.
  718: 
  719:     See Also
  720:     --------
  721:     chebadd, chebsub, chebmulx, chebdiv, chebpow
  722: 
  723:     Notes
  724:     -----
  725:     In general, the (polynomial) product of two C-series results in terms
  726:     that are not in the Chebyshev polynomial basis set.  Thus, to express
  727:     the product as a C-series, it is typically necessary to "reproject"
  728:     the product onto said basis set, which typically produces
  729:     "unintuitive live" (but correct) results; see Examples section below.
  730: 
  731:     Examples
  732:     --------
  733:     >>> from numpy.polynomial import chebyshev as C
  734:     >>> c1 = (1,2,3)
  735:     >>> c2 = (3,2,1)
  736:     >>> C.chebmul(c1,c2) # multiplication requires "reprojection"
  737:     array([  6.5,  12. ,  12. ,   4. ,   1.5])
  738: 
  739:     """
  740:     # c1, c2 are trimmed copies
  741:     [c1, c2] = pu.as_series([c1, c2])
  742:     z1 = _cseries_to_zseries(c1)
  743:     z2 = _cseries_to_zseries(c2)
  744:     prd = _zseries_mul(z1, z2)
  745:     ret = _zseries_to_cseries(prd)
  746:     return pu.trimseq(ret)
  747: 
  748: 
  749: def chebdiv(c1, c2):
  750:     """
  751:     Divide one Chebyshev series by another.
  752: 
  753:     Returns the quotient-with-remainder of two Chebyshev series
  754:     `c1` / `c2`.  The arguments are sequences of coefficients from lowest
  755:     order "term" to highest, e.g., [1,2,3] represents the series
  756:     ``T_0 + 2*T_1 + 3*T_2``.
  757: 
  758:     Parameters
  759:     ----------
  760:     c1, c2 : array_like
  761:         1-D arrays of Chebyshev series coefficients ordered from low to
  762:         high.
  763: 
  764:     Returns
  765:     -------
  766:     [quo, rem] : ndarrays
  767:         Of Chebyshev series coefficients representing the quotient and
  768:         remainder.
  769: 
  770:     See Also
  771:     --------
  772:     chebadd, chebsub, chebmulx, chebmul, chebpow
  773: 
  774:     Notes
  775:     -----
  776:     In general, the (polynomial) division of one C-series by another
  777:     results in quotient and remainder terms that are not in the Chebyshev
  778:     polynomial basis set.  Thus, to express these results as C-series, it
  779:     is typically necessary to "reproject" the results onto said basis
  780:     set, which typically produces "unintuitive" (but correct) results;
  781:     see Examples section below.
  782: 
  783:     Examples
  784:     --------
  785:     >>> from numpy.polynomial import chebyshev as C
  786:     >>> c1 = (1,2,3)
  787:     >>> c2 = (3,2,1)
  788:     >>> C.chebdiv(c1,c2) # quotient "intuitive," remainder not
  789:     (array([3.]), array([-8., -4.]))
  790:     >>> c2 = (0,1,2,3)
  791:     >>> C.chebdiv(c2,c1) # neither "intuitive"
  792:     (array([0., 2.]), array([-2., -4.]))
  793: 
  794:     """
  795:     # c1, c2 are trimmed copies
  796:     [c1, c2] = pu.as_series([c1, c2])
  797:     if c2[-1] == 0:
  798:         raise ZeroDivisionError  # FIXME: add message with details to exception
  799: 
  800:     # note: this is more efficient than `pu._div(chebmul, c1, c2)`
  801:     lc1 = len(c1)
  802:     lc2 = len(c2)
  803:     if lc1 < lc2:
  804:         return c1[:1] * 0, c1
  805:     elif lc2 == 1:
  806:         return c1 / c2[-1], c1[:1] * 0
  807:     else:
  808:         z1 = _cseries_to_zseries(c1)
  809:         z2 = _cseries_to_zseries(c2)
  810:         quo, rem = _zseries_div(z1, z2)
  811:         quo = pu.trimseq(_zseries_to_cseries(quo))
  812:         rem = pu.trimseq(_zseries_to_cseries(rem))
  813:         return quo, rem
  814: 
  815: 
  816: def chebpow(c, pow, maxpower=16):
  817:     """Raise a Chebyshev series to a power.
  818: 
  819:     Returns the Chebyshev series `c` raised to the power `pow`. The
  820:     argument `c` is a sequence of coefficients ordered from low to high.
  821:     i.e., [1,2,3] is the series  ``T_0 + 2*T_1 + 3*T_2.``
  822: 
  823:     Parameters
  824:     ----------
  825:     c : array_like
  826:         1-D array of Chebyshev series coefficients ordered from low to
  827:         high.
  828:     pow : integer
  829:         Power to which the series will be raised
  830:     maxpower : integer, optional
  831:         Maximum power allowed. This is mainly to limit growth of the series
  832:         to unmanageable size. Default is 16
  833: 
  834:     Returns
  835:     -------
  836:     coef : ndarray
  837:         Chebyshev series of power.
  838: 
  839:     See Also
  840:     --------
  841:     chebadd, chebsub, chebmulx, chebmul, chebdiv
  842: 
  843:     Examples
  844:     --------
  845:     >>> from numpy.polynomial import chebyshev as C
  846:     >>> C.chebpow([1, 2, 3, 4], 2)
  847:     array([15.5, 22. , 16. , ..., 12.5, 12. ,  8. ])
  848: 
  849:     """
  850:     # note: this is more efficient than `pu._pow(chebmul, c1, c2)`, as it
  851:     # avoids converting between z and c series repeatedly
  852: 
  853:     # c is a trimmed copy
  854:     [c] = pu.as_series([c])
  855:     power = int(pow)
  856:     if power != pow or power < 0:
  857:         raise ValueError("Power must be a non-negative integer.")
  858:     elif maxpower is not None and power > maxpower:
  859:         raise ValueError("Power is too large")
  860:     elif power == 0:
  861:         return np.array([1], dtype=c.dtype)
  862:     elif power == 1:
  863:         return c
  864:     else:
  865:         # This can be made more efficient by using powers of two
  866:         # in the usual way.
  867:         zs = _cseries_to_zseries(c)
  868:         prd = zs
  869:         for i in range(2, power + 1):
  870:             prd = np.convolve(prd, zs)
  871:         return _zseries_to_cseries(prd)
  872: 
  873: 
  874: def chebder(c, m=1, scl=1, axis=0):
  875:     """
  876:     Differentiate a Chebyshev series.
  877: 
  878:     Returns the Chebyshev series coefficients `c` differentiated `m` times
  879:     along `axis`.  At each iteration the result is multiplied by `scl` (the
  880:     scaling factor is for use in a linear change of variable). The argument
  881:     `c` is an array of coefficients from low to high degree along each
  882:     axis, e.g., [1,2,3] represents the series ``1*T_0 + 2*T_1 + 3*T_2``
  883:     while [[1,2],[1,2]] represents ``1*T_0(x)*T_0(y) + 1*T_1(x)*T_0(y) +
  884:     2*T_0(x)*T_1(y) + 2*T_1(x)*T_1(y)`` if axis=0 is ``x`` and axis=1 is
  885:     ``y``.
  886: 
  887:     Parameters
  888:     ----------
  889:     c : array_like
  890:         Array of Chebyshev series coefficients. If c is multidimensional
  891:         the different axis correspond to different variables with the
  892:         degree in each axis given by the corresponding index.
  893:     m : int, optional
  894:         Number of derivatives taken, must be non-negative. (Default: 1)
  895:     scl : scalar, optional
  896:         Each differentiation is multiplied by `scl`.  The end result is
  897:         multiplication by ``scl**m``.  This is for use in a linear change of
  898:         variable. (Default: 1)
  899:     axis : int, optional
  900:         Axis over which the derivative is taken. (Default: 0).
  901: 
  902:     Returns
  903:     -------
  904:     der : ndarray
  905:         Chebyshev series of the derivative.
  906: 
  907:     See Also
  908:     --------
  909:     chebint
  910: 
  911:     Notes
  912:     -----
  913:     In general, the result of differentiating a C-series needs to be
  914:     "reprojected" onto the C-series basis set. Thus, typically, the
  915:     result of this function is "unintuitive," albeit correct; see Examples
  916:     section below.
  917: 
  918:     Examples
  919:     --------
  920:     >>> from numpy.polynomial import chebyshev as C
  921:     >>> c = (1,2,3,4)
  922:     >>> C.chebder(c)
  923:     array([14., 12., 24.])
  924:     >>> C.chebder(c,3)
  925:     array([96.])
  926:     >>> C.chebder(c,scl=-1)
  927:     array([-14., -12., -24.])
  928:     >>> C.chebder(c,2,-1)
  929:     array([12.,  96.])
  930: 
  931:     """
  932:     c = np.array(c, ndmin=1, copy=True)
  933:     if c.dtype.char in '?bBhHiIlLqQpP':
  934:         c = c.astype(np.double)
  935:     cnt = pu._as_int(m, "the order of derivation")
  936:     iaxis = pu._as_int(axis, "the axis")
  937:     if cnt < 0:
  938:         raise ValueError("The order of derivation must be non-negative")
  939:     iaxis = normalize_axis_index(iaxis, c.ndim)
  940: 
  941:     if cnt == 0:
  942:         return c
  943: 
  944:     c = np.moveaxis(c, iaxis, 0)
  945:     n = len(c)
  946:     if cnt >= n:
  947:         c = c[:1] * 0
  948:     else:
  949:         for i in range(cnt):
  950:             n = n - 1
  951:             c *= scl
  952:             der = np.empty((n,) + c.shape[1:], dtype=c.dtype)
  953:             for j in range(n, 2, -1):
  954:                 der[j - 1] = (2 * j) * c[j]
  955:                 c[j - 2] += (j * c[j]) / (j - 2)
  956:             if n > 1:
  957:                 der[1] = 4 * c[2]
  958:             der[0] = c[1]
  959:             c = der
  960:     c = np.moveaxis(c, 0, iaxis)
  961:     return c
  962: 
  963: 
  964: def chebint(c, m=1, k=[], lbnd=0, scl=1, axis=0):
  965:     """
  966:     Integrate a Chebyshev series.
  967: 
  968:     Returns the Chebyshev series coefficients `c` integrated `m` times from
  969:     `lbnd` along `axis`. At each iteration the resulting series is
  970:     **multiplied** by `scl` and an integration constant, `k`, is added.
  971:     The scaling factor is for use in a linear change of variable.  ("Buyer
  972:     beware": note that, depending on what one is doing, one may want `scl`
  973:     to be the reciprocal of what one might expect; for more information,
  974:     see the Notes section below.)  The argument `c` is an array of
  975:     coefficients from low to high degree along each axis, e.g., [1,2,3]
  976:     represents the series ``T_0 + 2*T_1 + 3*T_2`` while [[1,2],[1,2]]
  977:     represents ``1*T_0(x)*T_0(y) + 1*T_1(x)*T_0(y) + 2*T_0(x)*T_1(y) +
  978:     2*T_1(x)*T_1(y)`` if axis=0 is ``x`` and axis=1 is ``y``.
  979: 
  980:     Parameters
  981:     ----------
  982:     c : array_like
  983:         Array of Chebyshev series coefficients. If c is multidimensional
  984:         the different axis correspond to different variables with the
  985:         degree in each axis given by the corresponding index.
  986:     m : int, optional
  987:         Order of integration, must be positive. (Default: 1)
  988:     k : {[], list, scalar}, optional
  989:         Integration constant(s).  The value of the first integral at zero
  990:         is the first value in the list, the value of the second integral
  991:         at zero is the second value, etc.  If ``k == []`` (the default),
  992:         all constants are set to zero.  If ``m == 1``, a single scalar can
  993:         be given instead of a list.
  994:     lbnd : scalar, optional
  995:         The lower bound of the integral. (Default: 0)
  996:     scl : scalar, optional
  997:         Following each integration the result is *multiplied* by `scl`
  998:         before the integration constant is added. (Default: 1)
  999:     axis : int, optional
 1000:         Axis over which the integral is taken. (Default: 0).
 1001: 
 1002:     Returns
 1003:     -------
 1004:     S : ndarray
 1005:         C-series coefficients of the integral.
 1006: 
 1007:     Raises
 1008:     ------
 1009:     ValueError
 1010:         If ``m < 1``, ``len(k) > m``, ``np.ndim(lbnd) != 0``, or
 1011:         ``np.ndim(scl) != 0``.
 1012: 
 1013:     See Also
 1014:     --------
 1015:     chebder
 1016: 
 1017:     Notes
 1018:     -----
 1019:     Note that the result of each integration is *multiplied* by `scl`.
 1020:     Why is this important to note?  Say one is making a linear change of
 1021:     variable :math:`u = ax + b` in an integral relative to `x`.  Then
 1022:     :math:`dx = du/a`, so one will need to set `scl` equal to
 1023:     :math:`1/a`- perhaps not what one would have first thought.
 1024: 
 1025:     Also note that, in general, the result of integrating a C-series needs
 1026:     to be "reprojected" onto the C-series basis set.  Thus, typically,
 1027:     the result of this function is "unintuitive," albeit correct; see
 1028:     Examples section below.
 1029: 
 1030:     Examples
 1031:     --------
 1032:     >>> from numpy.polynomial import chebyshev as C
 1033:     >>> c = (1,2,3)
 1034:     >>> C.chebint(c)
 1035:     array([ 0.5, -0.5,  0.5,  0.5])
 1036:     >>> C.chebint(c,3)
 1037:     array([ 0.03125   , -0.1875    ,  0.04166667, -0.05208333,  0.01041667, # may vary
 1038:         0.00625   ])
 1039:     >>> C.chebint(c, k=3)
 1040:     array([ 3.5, -0.5,  0.5,  0.5])
 1041:     >>> C.chebint(c,lbnd=-2)
 1042:     array([ 8.5, -0.5,  0.5,  0.5])
 1043:     >>> C.chebint(c,scl=-2)
 1044:     array([-1.,  1., -1., -1.])
 1045: 
 1046:     """
 1047:     c = np.array(c, ndmin=1, copy=True)
 1048:     if c.dtype.char in '?bBhHiIlLqQpP':
 1049:         c = c.astype(np.double)
 1050:     if not np.iterable(k):
 1051:         k = [k]
 1052:     cnt = pu._as_int(m, "the order of integration")
 1053:     iaxis = pu._as_int(axis, "the axis")
 1054:     if cnt < 0:
 1055:         raise ValueError("The order of integration must be non-negative")
 1056:     if len(k) > cnt:
 1057:         raise ValueError("Too many integration constants")
 1058:     if np.ndim(lbnd) != 0:
 1059:         raise ValueError("lbnd must be a scalar.")
 1060:     if np.ndim(scl) != 0:
 1061:         raise ValueError("scl must be a scalar.")
 1062:     iaxis = normalize_axis_index(iaxis, c.ndim)
 1063: 
 1064:     if cnt == 0:
 1065:         return c
 1066: 
 1067:     c = np.moveaxis(c, iaxis, 0)
 1068:     k = list(k) + [0] * (cnt - len(k))
 1069:     for i in range(cnt):
 1070:         n = len(c)
 1071:         c *= scl
 1072:         if n == 1 and np.all(c[0] == 0):
 1073:             c[0] += k[i]
 1074:         else:
 1075:             tmp = np.empty((n + 1,) + c.shape[1:], dtype=c.dtype)
 1076:             tmp[0] = c[0] * 0
 1077:             tmp[1] = c[0]
 1078:             if n > 1:
 1079:                 tmp[2] = c[1] / 4
 1080:             for j in range(2, n):
 1081:                 tmp[j + 1] = c[j] / (2 * (j + 1))
 1082:                 tmp[j - 1] -= c[j] / (2 * (j - 1))
 1083:             tmp[0] += k[i] - chebval(lbnd, tmp)
 1084:             c = tmp
 1085:     c = np.moveaxis(c, 0, iaxis)
 1086:     return c
 1087: 
 1088: 
 1089: def chebval(x, c, tensor=True):
 1090:     """
 1091:     Evaluate a Chebyshev series at points x.
 1092: 
 1093:     If `c` is of length `n + 1`, this function returns the value:
 1094: 
 1095:     .. math:: p(x) = c_0 * T_0(x) + c_1 * T_1(x) + ... + c_n * T_n(x)
 1096: 
 1097:     The parameter `x` is converted to an array only if it is a tuple or a
 1098:     list, otherwise it is treated as a scalar. In either case, either `x`
 1099:     or its elements must support multiplication and addition both with
 1100:     themselves and with the elements of `c`.
 1101: 
 1102:     If `c` is a 1-D array, then ``p(x)`` will have the same shape as `x`.  If
 1103:     `c` is multidimensional, then the shape of the result depends on the
 1104:     value of `tensor`. If `tensor` is true the shape will be c.shape[1:] +
 1105:     x.shape. If `tensor` is false the shape will be c.shape[1:]. Note that
 1106:     scalars have shape (,).
 1107: 
 1108:     Trailing zeros in the coefficients will be used in the evaluation, so
 1109:     they should be avoided if efficiency is a concern.
 1110: 
 1111:     Parameters
 1112:     ----------
 1113:     x : array_like, compatible object
 1114:         If `x` is a list or tuple, it is converted to an ndarray, otherwise
 1115:         it is left unchanged and treated as a scalar. In either case, `x`
 1116:         or its elements must support addition and multiplication with
 1117:         themselves and with the elements of `c`.
 1118:     c : array_like
 1119:         Array of coefficients ordered so that the coefficients for terms of
 1120:         degree n are contained in c[n]. If `c` is multidimensional the
 1121:         remaining indices enumerate multiple polynomials. In the two
 1122:         dimensional case the coefficients may be thought of as stored in
 1123:         the columns of `c`.
 1124:     tensor : boolean, optional
 1125:         If True, the shape of the coefficient array is extended with ones
 1126:         on the right, one for each dimension of `x`. Scalars have dimension 0
 1127:         for this action. The result is that every column of coefficients in
 1128:         `c` is evaluated for every element of `x`. If False, `x` is broadcast
 1129:         over the columns of `c` for the evaluation.  This keyword is useful
 1130:         when `c` is multidimensional. The default value is True.
 1131: 
 1132:     Returns
 1133:     -------
 1134:     values : ndarray, algebra_like
 1135:         The shape of the return value is described above.
 1136: 
 1137:     See Also
 1138:     --------
 1139:     chebval2d, chebgrid2d, chebval3d, chebgrid3d
 1140: 
 1141:     Notes
 1142:     -----
 1143:     The evaluation uses Clenshaw recursion, aka synthetic division.
 1144: 
 1145:     """
 1146:     c = np.array(c, ndmin=1, copy=True)
 1147:     if c.dtype.char in '?bBhHiIlLqQpP':
 1148:         c = c.astype(np.double)
 1149:     if isinstance(x, (tuple, list)):
 1150:         x = np.asarray(x)
 1151:     if isinstance(x, np.ndarray) and tensor:
 1152:         c = c.reshape(c.shape + (1,) * x.ndim)
 1153: 
 1154:     if len(c) == 1:
 1155:         c0 = c[0]
 1156:         c1 = 0
 1157:     elif len(c) == 2:
 1158:         c0 = c[0]
 1159:         c1 = c[1]
 1160:     else:
 1161:         x2 = 2 * x
 1162:         c0 = c[-2]
 1163:         c1 = c[-1]
 1164:         for i in range(3, len(c) + 1):
 1165:             tmp = c0
 1166:             c0 = c[-i] - c1
 1167:             c1 = tmp + c1 * x2
 1168:     return c0 + c1 * x
 1169: 
 1170: 
 1171: def chebval2d(x, y, c):
 1172:     """
 1173:     Evaluate a 2-D Chebyshev series at points (x, y).
 1174: 
 1175:     This function returns the values:
 1176: 
 1177:     .. math:: p(x,y) = \\sum_{i,j} c_{i,j} * T_i(x) * T_j(y)
 1178: 
 1179:     The parameters `x` and `y` are converted to arrays only if they are
 1180:     tuples or a lists, otherwise they are treated as a scalars and they
 1181:     must have the same shape after conversion. In either case, either `x`
 1182:     and `y` or their elements must support multiplication and addition both
 1183:     with themselves and with the elements of `c`.
 1184: 
 1185:     If `c` is a 1-D array a one is implicitly appended to its shape to make
 1186:     it 2-D. The shape of the result will be c.shape[2:] + x.shape.
 1187: 
 1188:     Parameters
 1189:     ----------
 1190:     x, y : array_like, compatible objects
 1191:         The two dimensional series is evaluated at the points ``(x, y)``,
 1192:         where `x` and `y` must have the same shape. If `x` or `y` is a list
 1193:         or tuple, it is first converted to an ndarray, otherwise it is left
 1194:         unchanged and if it isn't an ndarray it is treated as a scalar.
 1195:     c : array_like
 1196:         Array of coefficients ordered so that the coefficient of the term
 1197:         of multi-degree i,j is contained in ``c[i,j]``. If `c` has
 1198:         dimension greater than 2 the remaining indices enumerate multiple
 1199:         sets of coefficients.
 1200: 
 1201:     Returns
 1202:     -------
 1203:     values : ndarray, compatible object
 1204:         The values of the two dimensional Chebyshev series at points formed
 1205:         from pairs of corresponding values from `x` and `y`.
 1206: 
 1207:     See Also
 1208:     --------
 1209:     chebval, chebgrid2d, chebval3d, chebgrid3d
 1210:     """
 1211:     return pu._valnd(chebval, c, x, y)
 1212: 
 1213: 
 1214: def chebgrid2d(x, y, c):
 1215:     """
 1216:     Evaluate a 2-D Chebyshev series on the Cartesian product of x and y.
 1217: 
 1218:     This function returns the values:
 1219: 
 1220:     .. math:: p(a,b) = \\sum_{i,j} c_{i,j} * T_i(a) * T_j(b),
 1221: 
 1222:     where the points `(a, b)` consist of all pairs formed by taking
 1223:     `a` from `x` and `b` from `y`. The resulting points form a grid with
 1224:     `x` in the first dimension and `y` in the second.
 1225: 
 1226:     The parameters `x` and `y` are converted to arrays only if they are
 1227:     tuples or a lists, otherwise they are treated as a scalars. In either
 1228:     case, either `x` and `y` or their elements must support multiplication
 1229:     and addition both with themselves and with the elements of `c`.
 1230: 
 1231:     If `c` has fewer than two dimensions, ones are implicitly appended to
 1232:     its shape to make it 2-D. The shape of the result will be c.shape[2:] +
 1233:     x.shape + y.shape.
 1234: 
 1235:     Parameters
 1236:     ----------
 1237:     x, y : array_like, compatible objects
 1238:         The two dimensional series is evaluated at the points in the
 1239:         Cartesian product of `x` and `y`.  If `x` or `y` is a list or
 1240:         tuple, it is first converted to an ndarray, otherwise it is left
 1241:         unchanged and, if it isn't an ndarray, it is treated as a scalar.
 1242:     c : array_like
 1243:         Array of coefficients ordered so that the coefficient of the term of
 1244:         multi-degree i,j is contained in ``c[i,j]``. If `c` has dimension
 1245:         greater than two the remaining indices enumerate multiple sets of
 1246:         coefficients.
 1247: 
 1248:     Returns
 1249:     -------
 1250:     values : ndarray, compatible object
 1251:         The values of the two dimensional Chebyshev series at points in the
 1252:         Cartesian product of `x` and `y`.
 1253: 
 1254:     See Also
 1255:     --------
 1256:     chebval, chebval2d, chebval3d, chebgrid3d
 1257:     """
 1258:     return pu._gridnd(chebval, c, x, y)
 1259: 
 1260: 
 1261: def chebval3d(x, y, z, c):
 1262:     """
 1263:     Evaluate a 3-D Chebyshev series at points (x, y, z).
 1264: 
 1265:     This function returns the values:
 1266: 
 1267:     .. math:: p(x,y,z) = \\sum_{i,j,k} c_{i,j,k} * T_i(x) * T_j(y) * T_k(z)
 1268: 
 1269:     The parameters `x`, `y`, and `z` are converted to arrays only if
 1270:     they are tuples or a lists, otherwise they are treated as a scalars and
 1271:     they must have the same shape after conversion. In either case, either
 1272:     `x`, `y`, and `z` or their elements must support multiplication and
 1273:     addition both with themselves and with the elements of `c`.
 1274: 
 1275:     If `c` has fewer than 3 dimensions, ones are implicitly appended to its
 1276:     shape to make it 3-D. The shape of the result will be c.shape[3:] +
 1277:     x.shape.
 1278: 
 1279:     Parameters
 1280:     ----------
 1281:     x, y, z : array_like, compatible object
 1282:         The three dimensional series is evaluated at the points
 1283:         ``(x, y, z)``, where `x`, `y`, and `z` must have the same shape.  If
 1284:         any of `x`, `y`, or `z` is a list or tuple, it is first converted
 1285:         to an ndarray, otherwise it is left unchanged and if it isn't an
 1286:         ndarray it is  treated as a scalar.
 1287:     c : array_like
 1288:         Array of coefficients ordered so that the coefficient of the term of
 1289:         multi-degree i,j,k is contained in ``c[i,j,k]``. If `c` has dimension
 1290:         greater than 3 the remaining indices enumerate multiple sets of
 1291:         coefficients.
 1292: 
 1293:     Returns
 1294:     -------
 1295:     values : ndarray, compatible object
 1296:         The values of the multidimensional polynomial on points formed with
 1297:         triples of corresponding values from `x`, `y`, and `z`.
 1298: 
 1299:     See Also
 1300:     --------
 1301:     chebval, chebval2d, chebgrid2d, chebgrid3d
 1302:     """
 1303:     return pu._valnd(chebval, c, x, y, z)
 1304: 
 1305: 
 1306: def chebgrid3d(x, y, z, c):
 1307:     """
 1308:     Evaluate a 3-D Chebyshev series on the Cartesian product of x, y, and z.
 1309: 
 1310:     This function returns the values:
 1311: 
 1312:     .. math:: p(a,b,c) = \\sum_{i,j,k} c_{i,j,k} * T_i(a) * T_j(b) * T_k(c)
 1313: 
 1314:     where the points ``(a, b, c)`` consist of all triples formed by taking
 1315:     `a` from `x`, `b` from `y`, and `c` from `z`. The resulting points form
 1316:     a grid with `x` in the first dimension, `y` in the second, and `z` in
 1317:     the third.
 1318: 
 1319:     The parameters `x`, `y`, and `z` are converted to arrays only if they
 1320:     are tuples or a lists, otherwise they are treated as a scalars. In
 1321:     either case, either `x`, `y`, and `z` or their elements must support
 1322:     multiplication and addition both with themselves and with the elements
 1323:     of `c`.
 1324: 
 1325:     If `c` has fewer than three dimensions, ones are implicitly appended to
 1326:     its shape to make it 3-D. The shape of the result will be c.shape[3:] +
 1327:     x.shape + y.shape + z.shape.
 1328: 
 1329:     Parameters
 1330:     ----------
 1331:     x, y, z : array_like, compatible objects
 1332:         The three dimensional series is evaluated at the points in the
 1333:         Cartesian product of `x`, `y`, and `z`.  If `x`, `y`, or `z` is a
 1334:         list or tuple, it is first converted to an ndarray, otherwise it is
 1335:         left unchanged and, if it isn't an ndarray, it is treated as a
 1336:         scalar.
 1337:     c : array_like
 1338:         Array of coefficients ordered so that the coefficients for terms of
 1339:         degree i,j are contained in ``c[i,j]``. If `c` has dimension
 1340:         greater than two the remaining indices enumerate multiple sets of
 1341:         coefficients.
 1342: 
 1343:     Returns
 1344:     -------
 1345:     values : ndarray, compatible object
 1346:         The values of the two dimensional polynomial at points in the Cartesian
 1347:         product of `x` and `y`.
 1348: 
 1349:     See Also
 1350:     --------
 1351:     chebval, chebval2d, chebgrid2d, chebval3d
 1352:     """
 1353:     return pu._gridnd(chebval, c, x, y, z)
 1354: 
 1355: 
 1356: def chebvander(x, deg):
 1357:     """Pseudo-Vandermonde matrix of given degree.
 1358: 
 1359:     Returns the pseudo-Vandermonde matrix of degree `deg` and sample points
 1360:     `x`. The pseudo-Vandermonde matrix is defined by
 1361: 
 1362:     .. math:: V[..., i] = T_i(x),
 1363: 
 1364:     where ``0 <= i <= deg``. The leading indices of `V` index the elements of
 1365:     `x` and the last index is the degree of the Chebyshev polynomial.
 1366: 
 1367:     If `c` is a 1-D array of coefficients of length ``n + 1`` and `V` is the
 1368:     matrix ``V = chebvander(x, n)``, then ``np.dot(V, c)`` and
 1369:     ``chebval(x, c)`` are the same up to roundoff.  This equivalence is
 1370:     useful both for least squares fitting and for the evaluation of a large
 1371:     number of Chebyshev series of the same degree and sample points.
 1372: 
 1373:     Parameters
 1374:     ----------
 1375:     x : array_like
 1376:         Array of points. The dtype is converted to float64 or complex128
 1377:         depending on whether any of the elements are complex. If `x` is
 1378:         scalar it is converted to a 1-D array.
 1379:     deg : int
 1380:         Degree of the resulting matrix.
 1381: 
 1382:     Returns
 1383:     -------
 1384:     vander : ndarray
 1385:         The pseudo Vandermonde matrix. The shape of the returned matrix is
 1386:         ``x.shape + (deg + 1,)``, where The last index is the degree of the
 1387:         corresponding Chebyshev polynomial.  The dtype will be the same as
 1388:         the converted `x`.
 1389: 
 1390:     """
 1391:     ideg = pu._as_int(deg, "deg")
 1392:     if ideg < 0:
 1393:         raise ValueError("deg must be non-negative")
 1394: 
 1395:     x = np.array(x, copy=None, ndmin=1) + 0.0
 1396:     dims = (ideg + 1,) + x.shape
 1397:     dtyp = x.dtype
 1398:     v = np.empty(dims, dtype=dtyp)
 1399:     # Use forward recursion to generate the entries.
 1400:     v[0] = x * 0 + 1
 1401:     if ideg > 0:
 1402:         x2 = 2 * x
 1403:         v[1] = x
 1404:         for i in range(2, ideg + 1):
 1405:             v[i] = v[i - 1] * x2 - v[i - 2]
 1406:     return np.moveaxis(v, 0, -1)
 1407: 
 1408: 
 1409: def chebvander2d(x, y, deg):
 1410:     """Pseudo-Vandermonde matrix of given degrees.
 1411: 
 1412:     Returns the pseudo-Vandermonde matrix of degrees `deg` and sample
 1413:     points ``(x, y)``. The pseudo-Vandermonde matrix is defined by
 1414: 
 1415:     .. math:: V[..., (deg[1] + 1)*i + j] = T_i(x) * T_j(y),
 1416: 
 1417:     where ``0 <= i <= deg[0]`` and ``0 <= j <= deg[1]``. The leading indices of
 1418:     `V` index the points ``(x, y)`` and the last index encodes the degrees of
 1419:     the Chebyshev polynomials.
 1420: 
 1421:     If ``V = chebvander2d(x, y, [xdeg, ydeg])``, then the columns of `V`
 1422:     correspond to the elements of a 2-D coefficient array `c` of shape
 1423:     (xdeg + 1, ydeg + 1) in the order
 1424: 
 1425:     .. math:: c_{00}, c_{01}, c_{02} ... , c_{10}, c_{11}, c_{12} ...
 1426: 
 1427:     and ``np.dot(V, c.flat)`` and ``chebval2d(x, y, c)`` will be the same
 1428:     up to roundoff. This equivalence is useful both for least squares
 1429:     fitting and for the evaluation of a large number of 2-D Chebyshev
 1430:     series of the same degrees and sample points.
 1431: 
 1432:     Parameters
 1433:     ----------
 1434:     x, y : array_like
 1435:         Arrays of point coordinates, all of the same shape. The dtypes
 1436:         will be converted to either float64 or complex128 depending on
 1437:         whether any of the elements are complex. Scalars are converted to
 1438:         1-D arrays.
 1439:     deg : list of ints
 1440:         List of maximum degrees of the form [x_deg, y_deg].
 1441: 
 1442:     Returns
 1443:     -------
 1444:     vander2d : ndarray
 1445:         The shape of the returned matrix is ``x.shape + (order,)``, where
 1446:         :math:`order = (deg[0]+1)*(deg[1]+1)`.  The dtype will be the same
 1447:         as the converted `x` and `y`.
 1448: 
 1449:     See Also
 1450:     --------
 1451:     chebvander, chebvander3d, chebval2d, chebval3d
 1452:     """
 1453:     return pu._vander_nd_flat((chebvander, chebvander), (x, y), deg)
 1454: 
 1455: 
 1456: def chebvander3d(x, y, z, deg):
 1457:     """Pseudo-Vandermonde matrix of given degrees.
 1458: 
 1459:     Returns the pseudo-Vandermonde matrix of degrees `deg` and sample
 1460:     points ``(x, y, z)``. If `l`, `m`, `n` are the given degrees in `x`, `y`, `z`,
 1461:     then The pseudo-Vandermonde matrix is defined by
 1462: 
 1463:     .. math:: V[..., (m+1)(n+1)i + (n+1)j + k] = T_i(x)*T_j(y)*T_k(z),
 1464: 
 1465:     where ``0 <= i <= l``, ``0 <= j <= m``, and ``0 <= j <= n``.  The leading
 1466:     indices of `V` index the points ``(x, y, z)`` and the last index encodes
 1467:     the degrees of the Chebyshev polynomials.
 1468: 
 1469:     If ``V = chebvander3d(x, y, z, [xdeg, ydeg, zdeg])``, then the columns
 1470:     of `V` correspond to the elements of a 3-D coefficient array `c` of
 1471:     shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order
 1472: 
 1473:     .. math:: c_{000}, c_{001}, c_{002},... , c_{010}, c_{011}, c_{012},...
 1474: 
 1475:     and ``np.dot(V, c.flat)`` and ``chebval3d(x, y, z, c)`` will be the
 1476:     same up to roundoff. This equivalence is useful both for least squares
 1477:     fitting and for the evaluation of a large number of 3-D Chebyshev
 1478:     series of the same degrees and sample points.
 1479: 
 1480:     Parameters
 1481:     ----------
 1482:     x, y, z : array_like
 1483:         Arrays of point coordinates, all of the same shape. The dtypes will
 1484:         be converted to either float64 or complex128 depending on whether
 1485:         any of the elements are complex. Scalars are converted to 1-D
 1486:         arrays.
 1487:     deg : list of ints
 1488:         List of maximum degrees of the form [x_deg, y_deg, z_deg].
 1489: 
 1490:     Returns
 1491:     -------
 1492:     vander3d : ndarray
 1493:         The shape of the returned matrix is ``x.shape + (order,)``, where
 1494:         :math:`order = (deg[0]+1)*(deg[1]+1)*(deg[2]+1)`.  The dtype will
 1495:         be the same as the converted `x`, `y`, and `z`.
 1496: 
 1497:     See Also
 1498:     --------
 1499:     chebvander, chebvander3d, chebval2d, chebval3d
 1500:     """
 1501:     return pu._vander_nd_flat((chebvander, chebvander, chebvander), (x, y, z), deg)
 1502: 
 1503: 
 1504: def chebfit(x, y, deg, rcond=None, full=False, w=None):
 1505:     """
 1506:     Least squares fit of Chebyshev series to data.
 1507: 
 1508:     Return the coefficients of a Chebyshev series of degree `deg` that is the
 1509:     least squares fit to the data values `y` given at points `x`. If `y` is
 1510:     1-D the returned coefficients will also be 1-D. If `y` is 2-D multiple
 1511:     fits are done, one for each column of `y`, and the resulting
 1512:     coefficients are stored in the corresponding columns of a 2-D return.
 1513:     The fitted polynomial(s) are in the form
 1514: 
 1515:     .. math::  p(x) = c_0 + c_1 * T_1(x) + ... + c_n * T_n(x),
 1516: 
 1517:     where `n` is `deg`.
 1518: 
 1519:     Parameters
 1520:     ----------
 1521:     x : array_like, shape (M,)
 1522:         x-coordinates of the M sample points ``(x[i], y[i])``.
 1523:     y : array_like, shape (M,) or (M, K)
 1524:         y-coordinates of the sample points. Several data sets of sample
 1525:         points sharing the same x-coordinates can be fitted at once by
 1526:         passing in a 2D-array that contains one dataset per column.
 1527:     deg : int or 1-D array_like
 1528:         Degree(s) of the fitting polynomials. If `deg` is a single integer,
 1529:         all terms up to and including the `deg`'th term are included in the
 1530:         fit. For NumPy versions >= 1.11.0 a list of integers specifying the
 1531:         degrees of the terms to include may be used instead.
 1532:     rcond : float, optional
 1533:         Relative condition number of the fit. Singular values smaller than
 1534:         this relative to the largest singular value will be ignored. The
 1535:         default value is ``len(x)*eps``, where eps is the relative precision of
 1536:         the float type, about 2e-16 in most cases.
 1537:     full : bool, optional
 1538:         Switch determining nature of return value. When it is False (the
 1539:         default) just the coefficients are returned, when True diagnostic
 1540:         information from the singular value decomposition is also returned.
 1541:     w : array_like, shape (`M`,), optional
 1542:         Weights. If not None, the weight ``w[i]`` applies to the unsquared
 1543:         residual ``y[i] - y_hat[i]`` at ``x[i]``. Ideally the weights are
 1544:         chosen so that the errors of the products ``w[i]*y[i]`` all have the
 1545:         same variance.  When using inverse-variance weighting, use
 1546:         ``w[i] = 1/sigma(y[i])``.  The default value is None.
 1547: 
 1548:     Returns
 1549:     -------
 1550:     coef : ndarray, shape (M,) or (M, K)
 1551:         Chebyshev coefficients ordered from low to high. If `y` was 2-D,
 1552:         the coefficients for the data in column k  of `y` are in column
 1553:         `k`.
 1554: 
 1555:     [residuals, rank, singular_values, rcond] : list
 1556:         These values are only returned if ``full == True``
 1557: 
 1558:         - residuals -- sum of squared residuals of the least squares fit
 1559:         - rank -- the numerical rank of the scaled Vandermonde matrix
 1560:         - singular_values -- singular values of the scaled Vandermonde matrix
 1561:         - rcond -- value of `rcond`.
 1562: 
 1563:         For more details, see `numpy.linalg.lstsq`.
 1564: 
 1565:     Warns
 1566:     -----
 1567:     RankWarning
 1568:         The rank of the coefficient matrix in the least-squares fit is
 1569:         deficient. The warning is only raised if ``full == False``.  The
 1570:         warnings can be turned off by
 1571: 
 1572:         >>> import warnings
 1573:         >>> warnings.simplefilter('ignore', np.exceptions.RankWarning)
 1574: 
 1575:     See Also
 1576:     --------
 1577:     numpy.polynomial.polynomial.polyfit
 1578:     numpy.polynomial.legendre.legfit
 1579:     numpy.polynomial.laguerre.lagfit
 1580:     numpy.polynomial.hermite.hermfit
 1581:     numpy.polynomial.hermite_e.hermefit
 1582:     chebval : Evaluates a Chebyshev series.
 1583:     chebvander : Vandermonde matrix of Chebyshev series.
 1584:     chebweight : Chebyshev weight function.
 1585:     numpy.linalg.lstsq : Computes a least-squares fit from the matrix.
 1586:     scipy.interpolate.UnivariateSpline : Computes spline fits.
 1587: 
 1588:     Notes
 1589:     -----
 1590:     The solution is the coefficients of the Chebyshev series `p` that
 1591:     minimizes the sum of the weighted squared errors
 1592: 
 1593:     .. math:: E = \\sum_j w_j^2 * |y_j - p(x_j)|^2,
 1594: 
 1595:     where :math:`w_j` are the weights. This problem is solved by setting up
 1596:     as the (typically) overdetermined matrix equation
 1597: 
 1598:     .. math:: V(x) * c = w * y,
 1599: 
 1600:     where `V` is the weighted pseudo Vandermonde matrix of `x`, `c` are the
 1601:     coefficients to be solved for, `w` are the weights, and `y` are the
 1602:     observed values.  This equation is then solved using the singular value
 1603:     decomposition of `V`.
 1604: 
 1605:     If some of the singular values of `V` are so small that they are
 1606:     neglected, then a `~exceptions.RankWarning` will be issued. This means that
 1607:     the coefficient values may be poorly determined. Using a lower order fit
 1608:     will usually get rid of the warning.  The `rcond` parameter can also be
 1609:     set to a value smaller than its default, but the resulting fit may be
 1610:     spurious and have large contributions from roundoff error.
 1611: 
 1612:     Fits using Chebyshev series are usually better conditioned than fits
 1613:     using power series, but much can depend on the distribution of the
 1614:     sample points and the smoothness of the data. If the quality of the fit
 1615:     is inadequate splines may be a good alternative.
 1616: 
 1617:     References
 1618:     ----------
 1619:     .. [1] Wikipedia, "Curve fitting",
 1620:            https://en.wikipedia.org/wiki/Curve_fitting
 1621: 
 1622:     Examples
 1623:     --------
 1624: 
 1625:     """
 1626:     return pu._fit(chebvander, x, y, deg, rcond, full, w)
 1627: 
 1628: 
 1629: def chebcompanion(c):
 1630:     """Return the scaled companion matrix of c.
 1631: 
 1632:     The basis polynomials are scaled so that the companion matrix is
 1633:     symmetric when `c` is a Chebyshev basis polynomial. This provides
 1634:     better eigenvalue estimates than the unscaled case and for basis
 1635:     polynomials the eigenvalues are guaranteed to be real if
 1636:     `numpy.linalg.eigvalsh` is used to obtain them.
 1637: 
 1638:     Parameters
 1639:     ----------
 1640:     c : array_like
 1641:         1-D array of Chebyshev series coefficients ordered from low to high
 1642:         degree.
 1643: 
 1644:     Returns
 1645:     -------
 1646:     mat : ndarray
 1647:         Scaled companion matrix of dimensions (deg, deg).
 1648:     """
 1649:     # c is a trimmed copy
 1650:     [c] = pu.as_series([c])
 1651:     if len(c) < 2:
 1652:         raise ValueError('Series must have maximum degree of at least 1.')
 1653:     if len(c) == 2:
 1654:         return np.array([[-c[0] / c[1]]])
 1655: 
 1656:     n = len(c) - 1
 1657:     mat = np.zeros((n, n), dtype=c.dtype)
 1658:     scl = np.array([1.] + [np.sqrt(.5)] * (n - 1))
 1659:     top = mat.reshape(-1)[1::n + 1]
 1660:     bot = mat.reshape(-1)[n::n + 1]
 1661:     top[0] = np.sqrt(.5)
 1662:     top[1:] = 1 / 2
 1663:     bot[...] = top
 1664:     mat[:, -1] -= (c[:-1] / c[-1]) * (scl / scl[-1]) * .5
 1665:     return mat
 1666: 
 1667: 
 1668: def chebroots(c):
 1669:     """
 1670:     Compute the roots of a Chebyshev series.
 1671: 
 1672:     Return the roots (a.k.a. "zeros") of the polynomial
 1673: 
 1674:     .. math:: p(x) = \\sum_i c[i] * T_i(x).
 1675: 
 1676:     Parameters
 1677:     ----------
 1678:     c : 1-D array_like
 1679:         1-D array of coefficients.
 1680: 
 1681:     Returns
 1682:     -------
 1683:     out : ndarray
 1684:         Array of the roots of the series. If all the roots are real,
 1685:         then `out` is also real, otherwise it is complex.
 1686: 
 1687:     See Also
 1688:     --------
 1689:     numpy.polynomial.polynomial.polyroots
 1690:     numpy.polynomial.legendre.legroots
 1691:     numpy.polynomial.laguerre.lagroots
 1692:     numpy.polynomial.hermite.hermroots
 1693:     numpy.polynomial.hermite_e.hermeroots
 1694: 
 1695:     Notes
 1696:     -----
 1697:     The root estimates are obtained as the eigenvalues of the companion
 1698:     matrix, Roots far from the origin of the complex plane may have large
 1699:     errors due to the numerical instability of the series for such
 1700:     values. Roots with multiplicity greater than 1 will also show larger
 1701:     errors as the value of the series near such points is relatively
 1702:     insensitive to errors in the roots. Isolated roots near the origin can
 1703:     be improved by a few iterations of Newton's method.
 1704: 
 1705:     The Chebyshev series basis polynomials aren't powers of `x` so the
 1706:     results of this function may seem unintuitive.
 1707: 
 1708:     Examples
 1709:     --------
 1710:     >>> import numpy.polynomial.chebyshev as cheb
 1711:     >>> cheb.chebroots((-1, 1,-1, 1)) # T3 - T2 + T1 - T0 has real roots
 1712:     array([ -5.00000000e-01,   2.60860684e-17,   1.00000000e+00]) # may vary
 1713: 
 1714:     """
 1715:     # c is a trimmed copy
 1716:     [c] = pu.as_series([c])
 1717:     if len(c) < 2:
 1718:         return np.array([], dtype=c.dtype)
 1719:     if len(c) == 2:
 1720:         return np.array([-c[0] / c[1]])
 1721: 
 1722:     # rotated companion matrix reduces error
 1723:     m = chebcompanion(c)[::-1, ::-1]
 1724:     r = la.eigvals(m)
 1725:     r.sort()
 1726:     return r
 1727: 
 1728: 
 1729: def chebinterpolate(func, deg, args=()):
 1730:     """Interpolate a function at the Chebyshev points of the first kind.
 1731: 
 1732:     Returns the Chebyshev series that interpolates `func` at the Chebyshev
 1733:     points of the first kind in the interval [-1, 1]. The interpolating
 1734:     series tends to a minmax approximation to `func` with increasing `deg`
 1735:     if the function is continuous in the interval.
 1736: 
 1737:     Parameters
 1738:     ----------
 1739:     func : function
 1740:         The function to be approximated. It must be a function of a single
 1741:         variable of the form ``f(x, a, b, c...)``, where ``a, b, c...`` are
 1742:         extra arguments passed in the `args` parameter.
 1743:     deg : int
 1744:         Degree of the interpolating polynomial
 1745:     args : tuple, optional
 1746:         Extra arguments to be used in the function call. Default is no extra
 1747:         arguments.
 1748: 
 1749:     Returns
 1750:     -------
 1751:     coef : ndarray, shape (deg + 1,)
 1752:         Chebyshev coefficients of the interpolating series ordered from low to
 1753:         high.
 1754: 
 1755:     Examples
 1756:     --------
 1757:     >>> import numpy.polynomial.chebyshev as C
 1758:     >>> C.chebinterpolate(lambda x: np.tanh(x) + 0.5, 8)
 1759:     array([  5.00000000e-01,   8.11675684e-01,  -9.86864911e-17,
 1760:             -5.42457905e-02,  -2.71387850e-16,   4.51658839e-03,
 1761:              2.46716228e-17,  -3.79694221e-04,  -3.26899002e-16])
 1762: 
 1763:     Notes
 1764:     -----
 1765:     The Chebyshev polynomials used in the interpolation are orthogonal when
 1766:     sampled at the Chebyshev points of the first kind. If it is desired to
 1767:     constrain some of the coefficients they can simply be set to the desired
 1768:     value after the interpolation, no new interpolation or fit is needed. This
 1769:     is especially useful if it is known apriori that some of coefficients are
 1770:     zero. For instance, if the function is even then the coefficients of the
 1771:     terms of odd degree in the result can be set to zero.
 1772: 
 1773:     """
 1774:     deg = np.asarray(deg)
 1775: 
 1776:     # check arguments.
 1777:     if deg.ndim > 0 or deg.dtype.kind not in 'iu' or deg.size == 0:
 1778:         raise TypeError("deg must be an int")
 1779:     if deg < 0:
 1780:         raise ValueError("expected deg >= 0")
 1781: 
 1782:     order = deg + 1
 1783:     xcheb = chebpts1(order)
 1784:     yfunc = func(xcheb, *args)
 1785:     m = chebvander(xcheb, deg)
 1786:     c = np.dot(m.T, yfunc)
 1787:     c[0] /= order
 1788:     c[1:] /= 0.5 * order
 1789: 
 1790:     return c
 1791: 
 1792: 
 1793: def chebgauss(deg):
 1794:     """
 1795:     Gauss-Chebyshev quadrature.
 1796: 
 1797:     Computes the sample points and weights for Gauss-Chebyshev quadrature.
 1798:     These sample points and weights will correctly integrate polynomials of
 1799:     degree :math:`2*deg - 1` or less over the interval :math:`[-1, 1]` with
 1800:     the weight function :math:`f(x) = 1/\\sqrt{1 - x^2}`.
 1801: 
 1802:     Parameters
 1803:     ----------
 1804:     deg : int
 1805:         Number of sample points and weights. It must be >= 1.
 1806: 
 1807:     Returns
 1808:     -------
 1809:     x : ndarray
 1810:         1-D ndarray containing the sample points.
 1811:     y : ndarray
 1812:         1-D ndarray containing the weights.
 1813: 
 1814:     Notes
 1815:     -----
 1816:     The results have only been tested up to degree 100, higher degrees may
 1817:     be problematic. For Gauss-Chebyshev there are closed form solutions for
 1818:     the sample points and weights. If n = `deg`, then
 1819: 
 1820:     .. math:: x_i = \\cos(\\pi (2 i - 1) / (2 n))
 1821: 
 1822:     .. math:: w_i = \\pi / n
 1823: 
 1824:     """
 1825:     ideg = pu._as_int(deg, "deg")
 1826:     if ideg <= 0:
 1827:         raise ValueError("deg must be a positive integer")
 1828: 
 1829:     x = np.cos(np.pi * np.arange(1, 2 * ideg, 2) / (2.0 * ideg))
 1830:     w = np.ones(ideg) * (np.pi / ideg)
 1831: 
 1832:     return x, w
 1833: 
 1834: 
 1835: def chebweight(x):
 1836:     """
 1837:     The weight function of the Chebyshev polynomials.
 1838: 
 1839:     The weight function is :math:`1/\\sqrt{1 - x^2}` and the interval of
 1840:     integration is :math:`[-1, 1]`. The Chebyshev polynomials are
 1841:     orthogonal, but not normalized, with respect to this weight function.
 1842: 
 1843:     Parameters
 1844:     ----------
 1845:     x : array_like
 1846:        Values at which the weight function will be computed.
 1847: 
 1848:     Returns
 1849:     -------
 1850:     w : ndarray
 1851:        The weight function at `x`.
 1852:     """
 1853:     w = 1. / (np.sqrt(1. + x) * np.sqrt(1. - x))
 1854:     return w
 1855: 
 1856: 
 1857: def chebpts1(npts):
 1858:     """
 1859:     Chebyshev points of the first kind.
 1860: 
 1861:     The Chebyshev points of the first kind are the points ``cos(x)``,
 1862:     where ``x = [pi*(k + .5)/npts for k in range(npts)]``.
 1863: 
 1864:     Parameters
 1865:     ----------
 1866:     npts : int
 1867:         Number of sample points desired.
 1868: 
 1869:     Returns
 1870:     -------
 1871:     pts : ndarray
 1872:         The Chebyshev points of the first kind.
 1873: 
 1874:     See Also
 1875:     --------
 1876:     chebpts2
 1877:     """
 1878:     _npts = int(npts)
 1879:     if _npts != npts:
 1880:         raise ValueError("npts must be integer")
 1881:     if _npts < 1:
 1882:         raise ValueError("npts must be >= 1")
 1883: 
 1884:     x = 0.5 * np.pi / _npts * np.arange(-_npts + 1, _npts + 1, 2)
 1885:     return np.sin(x)
 1886: 
 1887: 
 1888: def chebpts2(npts):
 1889:     """
 1890:     Chebyshev points of the second kind.
 1891: 
 1892:     The Chebyshev points of the second kind are the points ``cos(x)``,
 1893:     where ``x = [pi*k/(npts - 1) for k in range(npts)]`` sorted in ascending
 1894:     order.
 1895: 
 1896:     Parameters
 1897:     ----------
 1898:     npts : int
 1899:         Number of sample points desired.
 1900: 
 1901:     Returns
 1902:     -------
 1903:     pts : ndarray
 1904:         The Chebyshev points of the second kind.
 1905:     """
 1906:     _npts = int(npts)
 1907:     if _npts != npts:
 1908:         raise ValueError("npts must be integer")
 1909:     if _npts < 2:
 1910:         raise ValueError("npts must be >= 2")
 1911: 
 1912:     x = np.linspace(-np.pi, 0, _npts)
 1913:     return np.cos(x)
 1914: 
 1915: 
 1916: #
 1917: # Chebyshev series class
 1918: #
 1919: 
 1920: class Chebyshev(ABCPolyBase):
 1921:     """A Chebyshev series class.
 1922: 
 1923:     The Chebyshev class provides the standard Python numerical methods
 1924:     '+', '-', '*', '//', '%', 'divmod', '**', and '()' as well as the
 1925:     attributes and methods listed below.
 1926: 
 1927:     Parameters
 1928:     ----------
 1929:     coef : array_like
 1930:         Chebyshev coefficients in order of increasing degree, i.e.,
 1931:         ``(1, 2, 3)`` gives ``1*T_0(x) + 2*T_1(x) + 3*T_2(x)``.
 1932:     domain : (2,) array_like, optional
 1933:         Domain to use. The interval ``[domain[0], domain[1]]`` is mapped
 1934:         to the interval ``[window[0], window[1]]`` by shifting and scaling.
 1935:         The default value is [-1., 1.].
 1936:     window : (2,) array_like, optional
 1937:         Window, see `domain` for its use. The default value is [-1., 1.].
 1938:     symbol : str, optional
 1939:         Symbol used to represent the independent variable in string
 1940:         representations of the polynomial expression, e.g. for printing.
 1941:         The symbol must be a valid Python identifier. Default value is 'x'.
 1942: 
 1943:         .. versionadded:: 1.24
 1944: 
 1945:     """
 1946:     # Virtual Functions
 1947:     _add = staticmethod(chebadd)
 1948:     _sub = staticmethod(chebsub)
 1949:     _mul = staticmethod(chebmul)
 1950:     _div = staticmethod(chebdiv)
 1951:     _pow = staticmethod(chebpow)
 1952:     _val = staticmethod(chebval)
 1953:     _int = staticmethod(chebint)
 1954:     _der = staticmethod(chebder)
 1955:     _fit = staticmethod(chebfit)
 1956:     _line = staticmethod(chebline)
 1957:     _roots = staticmethod(chebroots)
 1958:     _fromroots = staticmethod(chebfromroots)
 1959: 
 1960:     @classmethod
 1961:     def interpolate(cls, func, deg, domain=None, args=()):
 1962:         """Interpolate a function at the Chebyshev points of the first kind.
 1963: 
 1964:         Returns the series that interpolates `func` at the Chebyshev points of
 1965:         the first kind scaled and shifted to the `domain`. The resulting series
 1966:         tends to a minmax approximation of `func` when the function is
 1967:         continuous in the domain.
 1968: 
 1969:         Parameters
 1970:         ----------
 1971:         func : function
 1972:             The function to be interpolated. It must be a function of a single
 1973:             variable of the form ``f(x, a, b, c...)``, where ``a, b, c...`` are
 1974:             extra arguments passed in the `args` parameter.
 1975:         deg : int
 1976:             Degree of the interpolating polynomial.
 1977:         domain : {None, [beg, end]}, optional
 1978:             Domain over which `func` is interpolated. The default is None, in
 1979:             which case the domain is [-1, 1].
 1980:         args : tuple, optional
 1981:             Extra arguments to be used in the function call. Default is no
 1982:             extra arguments.
 1983: 
 1984:         Returns
 1985:         -------
 1986:         polynomial : Chebyshev instance
 1987:             Interpolating Chebyshev instance.
 1988: 
 1989:         Notes
 1990:         -----
 1991:         See `numpy.polynomial.chebinterpolate` for more details.
 1992: 
 1993:         """
 1994:         if domain is None:
 1995:             domain = cls.domain
 1996:         xfunc = lambda x: func(pu.mapdomain(x, cls.window, domain), *args)
 1997:         coef = chebinterpolate(xfunc, deg)
 1998:         return cls(coef, domain=domain)
 1999: 
 2000:     # Virtual properties
 2001:     domain = np.array(chebdomain)
 2002:     window = np.array(chebdomain)
 2003:     basis_name = 'T'
