    1: """
    2: =================================================
    3: Power Series (:mod:`numpy.polynomial.polynomial`)
    4: =================================================
    5: 
    6: This module provides a number of objects (mostly functions) useful for
    7: dealing with polynomials, including a `Polynomial` class that
    8: encapsulates the usual arithmetic operations.  (General information
    9: on how this module represents and works with polynomial objects is in
   10: the docstring for its "parent" sub-package, `numpy.polynomial`).
   11: 
   12: Classes
   13: -------
   14: .. autosummary::
   15:    :toctree: generated/
   16: 
   17:    Polynomial
   18: 
   19: Constants
   20: ---------
   21: .. autosummary::
   22:    :toctree: generated/
   23: 
   24:    polydomain
   25:    polyzero
   26:    polyone
   27:    polyx
   28: 
   29: Arithmetic
   30: ----------
   31: .. autosummary::
   32:    :toctree: generated/
   33: 
   34:    polyadd
   35:    polysub
   36:    polymulx
   37:    polymul
   38:    polydiv
   39:    polypow
   40:    polyval
   41:    polyval2d
   42:    polyval3d
   43:    polygrid2d
   44:    polygrid3d
   45: 
   46: Calculus
   47: --------
   48: .. autosummary::
   49:    :toctree: generated/
   50: 
   51:    polyder
   52:    polyint
   53: 
   54: Misc Functions
   55: --------------
   56: .. autosummary::
   57:    :toctree: generated/
   58: 
   59:    polyfromroots
   60:    polyroots
   61:    polyvalfromroots
   62:    polyvander
   63:    polyvander2d
   64:    polyvander3d
   65:    polycompanion
   66:    polyfit
   67:    polytrim
   68:    polyline
   69: 
   70: See Also
   71: --------
   72: `numpy.polynomial`
   73: 
   74: """
   75: __all__ = [
   76:     'polyzero', 'polyone', 'polyx', 'polydomain', 'polyline', 'polyadd',
   77:     'polysub', 'polymulx', 'polymul', 'polydiv', 'polypow', 'polyval',
   78:     'polyvalfromroots', 'polyder', 'polyint', 'polyfromroots', 'polyvander',
   79:     'polyfit', 'polytrim', 'polyroots', 'Polynomial', 'polyval2d', 'polyval3d',
   80:     'polygrid2d', 'polygrid3d', 'polyvander2d', 'polyvander3d',
   81:     'polycompanion']
   82: 
   83: import numpy as np
   84: import numpy.linalg as la
   85: from numpy.lib.array_utils import normalize_axis_index
   86: 
   87: from . import polyutils as pu
   88: from ._polybase import ABCPolyBase
   89: 
   90: polytrim = pu.trimcoef
   91: 
   92: #
   93: # These are constant arrays are of integer type so as to be compatible
   94: # with the widest range of other types, such as Decimal.
   95: #
   96: 
   97: # Polynomial default domain.
   98: polydomain = np.array([-1., 1.])
   99: 
  100: # Polynomial coefficients representing zero.
  101: polyzero = np.array([0])
  102: 
  103: # Polynomial coefficients representing one.
  104: polyone = np.array([1])
  105: 
  106: # Polynomial coefficients representing the identity x.
  107: polyx = np.array([0, 1])
  108: 
  109: #
  110: # Polynomial series functions
  111: #
  112: 
  113: 
  114: def polyline(off, scl):
  115:     """
  116:     Returns an array representing a linear polynomial.
  117: 
  118:     Parameters
  119:     ----------
  120:     off, scl : scalars
  121:         The "y-intercept" and "slope" of the line, respectively.
  122: 
  123:     Returns
  124:     -------
  125:     y : ndarray
  126:         This module's representation of the linear polynomial ``off +
  127:         scl*x``.
  128: 
  129:     See Also
  130:     --------
  131:     numpy.polynomial.chebyshev.chebline
  132:     numpy.polynomial.legendre.legline
  133:     numpy.polynomial.laguerre.lagline
  134:     numpy.polynomial.hermite.hermline
  135:     numpy.polynomial.hermite_e.hermeline
  136: 
  137:     Examples
  138:     --------
  139:     >>> from numpy.polynomial import polynomial as P
  140:     >>> P.polyline(1, -1)
  141:     array([ 1, -1])
  142:     >>> P.polyval(1, P.polyline(1, -1))  # should be 0
  143:     0.0
  144: 
  145:     """
  146:     if scl != 0:
  147:         return np.array([off, scl])
  148:     else:
  149:         return np.array([off])
  150: 
  151: 
  152: def polyfromroots(roots):
  153:     """
  154:     Generate a monic polynomial with given roots.
  155: 
  156:     Return the coefficients of the polynomial
  157: 
  158:     .. math:: p(x) = (x - r_0) * (x - r_1) * ... * (x - r_n),
  159: 
  160:     where the :math:`r_n` are the roots specified in `roots`.  If a zero has
  161:     multiplicity n, then it must appear in `roots` n times. For instance,
  162:     if 2 is a root of multiplicity three and 3 is a root of multiplicity 2,
  163:     then `roots` looks something like [2, 2, 2, 3, 3]. The roots can appear
  164:     in any order.
  165: 
  166:     If the returned coefficients are `c`, then
  167: 
  168:     .. math:: p(x) = c_0 + c_1 * x + ... +  x^n
  169: 
  170:     The coefficient of the last term is 1 for monic polynomials in this
  171:     form.
  172: 
  173:     Parameters
  174:     ----------
  175:     roots : array_like
  176:         Sequence containing the roots.
  177: 
  178:     Returns
  179:     -------
  180:     out : ndarray
  181:         1-D array of the polynomial's coefficients If all the roots are
  182:         real, then `out` is also real, otherwise it is complex.  (see
  183:         Examples below).
  184: 
  185:     See Also
  186:     --------
  187:     numpy.polynomial.chebyshev.chebfromroots
  188:     numpy.polynomial.legendre.legfromroots
  189:     numpy.polynomial.laguerre.lagfromroots
  190:     numpy.polynomial.hermite.hermfromroots
  191:     numpy.polynomial.hermite_e.hermefromroots
  192: 
  193:     Notes
  194:     -----
  195:     The coefficients are determined by multiplying together linear factors
  196:     of the form ``(x - r_i)``, i.e.
  197: 
  198:     .. math:: p(x) = (x - r_0) (x - r_1) ... (x - r_n)
  199: 
  200:     where ``n == len(roots) - 1``; note that this implies that ``1`` is always
  201:     returned for :math:`a_n`.
  202: 
  203:     Examples
  204:     --------
  205:     >>> from numpy.polynomial import polynomial as P
  206:     >>> P.polyfromroots((-1,0,1))  # x(x - 1)(x + 1) = x^3 - x
  207:     array([ 0., -1.,  0.,  1.])
  208:     >>> j = complex(0,1)
  209:     >>> P.polyfromroots((-j,j))  # complex returned, though values are real
  210:     array([1.+0.j,  0.+0.j,  1.+0.j])
  211: 
  212:     """
  213:     return pu._fromroots(polyline, polymul, roots)
  214: 
  215: 
  216: def polyadd(c1, c2):
  217:     """
  218:     Add one polynomial to another.
  219: 
  220:     Returns the sum of two polynomials `c1` + `c2`.  The arguments are
  221:     sequences of coefficients from lowest order term to highest, i.e.,
  222:     [1,2,3] represents the polynomial ``1 + 2*x + 3*x**2``.
  223: 
  224:     Parameters
  225:     ----------
  226:     c1, c2 : array_like
  227:         1-D arrays of polynomial coefficients ordered from low to high.
  228: 
  229:     Returns
  230:     -------
  231:     out : ndarray
  232:         The coefficient array representing their sum.
  233: 
  234:     See Also
  235:     --------
  236:     polysub, polymulx, polymul, polydiv, polypow
  237: 
  238:     Examples
  239:     --------
  240:     >>> from numpy.polynomial import polynomial as P
  241:     >>> c1 = (1, 2, 3)
  242:     >>> c2 = (3, 2, 1)
  243:     >>> sum = P.polyadd(c1,c2); sum
  244:     array([4.,  4.,  4.])
  245:     >>> P.polyval(2, sum)  # 4 + 4(2) + 4(2**2)
  246:     28.0
  247: 
  248:     """
  249:     return pu._add(c1, c2)
  250: 
  251: 
  252: def polysub(c1, c2):
  253:     """
  254:     Subtract one polynomial from another.
  255: 
  256:     Returns the difference of two polynomials `c1` - `c2`.  The arguments
  257:     are sequences of coefficients from lowest order term to highest, i.e.,
  258:     [1,2,3] represents the polynomial ``1 + 2*x + 3*x**2``.
  259: 
  260:     Parameters
  261:     ----------
  262:     c1, c2 : array_like
  263:         1-D arrays of polynomial coefficients ordered from low to
  264:         high.
  265: 
  266:     Returns
  267:     -------
  268:     out : ndarray
  269:         Of coefficients representing their difference.
  270: 
  271:     See Also
  272:     --------
  273:     polyadd, polymulx, polymul, polydiv, polypow
  274: 
  275:     Examples
  276:     --------
  277:     >>> from numpy.polynomial import polynomial as P
  278:     >>> c1 = (1, 2, 3)
  279:     >>> c2 = (3, 2, 1)
  280:     >>> P.polysub(c1,c2)
  281:     array([-2.,  0.,  2.])
  282:     >>> P.polysub(c2, c1)  # -P.polysub(c1,c2)
  283:     array([ 2.,  0., -2.])
  284: 
  285:     """
  286:     return pu._sub(c1, c2)
  287: 
  288: 
  289: def polymulx(c):
  290:     """Multiply a polynomial by x.
  291: 
  292:     Multiply the polynomial `c` by x, where x is the independent
  293:     variable.
  294: 
  295: 
  296:     Parameters
  297:     ----------
  298:     c : array_like
  299:         1-D array of polynomial coefficients ordered from low to
  300:         high.
  301: 
  302:     Returns
  303:     -------
  304:     out : ndarray
  305:         Array representing the result of the multiplication.
  306: 
  307:     See Also
  308:     --------
  309:     polyadd, polysub, polymul, polydiv, polypow
  310: 
  311:     Examples
  312:     --------
  313:     >>> from numpy.polynomial import polynomial as P
  314:     >>> c = (1, 2, 3)
  315:     >>> P.polymulx(c)
  316:     array([0., 1., 2., 3.])
  317: 
  318:     """
  319:     # c is a trimmed copy
  320:     [c] = pu.as_series([c])
  321:     # The zero series needs special treatment
  322:     if len(c) == 1 and c[0] == 0:
  323:         return c
  324: 
  325:     prd = np.empty(len(c) + 1, dtype=c.dtype)
  326:     prd[0] = c[0] * 0
  327:     prd[1:] = c
  328:     return prd
  329: 
  330: 
  331: def polymul(c1, c2):
  332:     """
  333:     Multiply one polynomial by another.
  334: 
  335:     Returns the product of two polynomials `c1` * `c2`.  The arguments are
  336:     sequences of coefficients, from lowest order term to highest, e.g.,
  337:     [1,2,3] represents the polynomial ``1 + 2*x + 3*x**2.``
  338: 
  339:     Parameters
  340:     ----------
  341:     c1, c2 : array_like
  342:         1-D arrays of coefficients representing a polynomial, relative to the
  343:         "standard" basis, and ordered from lowest order term to highest.
  344: 
  345:     Returns
  346:     -------
  347:     out : ndarray
  348:         Of the coefficients of their product.
  349: 
  350:     See Also
  351:     --------
  352:     polyadd, polysub, polymulx, polydiv, polypow
  353: 
  354:     Examples
  355:     --------
  356:     >>> from numpy.polynomial import polynomial as P
  357:     >>> c1 = (1, 2, 3)
  358:     >>> c2 = (3, 2, 1)
  359:     >>> P.polymul(c1, c2)
  360:     array([  3.,   8.,  14.,   8.,   3.])
  361: 
  362:     """
  363:     # c1, c2 are trimmed copies
  364:     [c1, c2] = pu.as_series([c1, c2])
  365:     ret = np.convolve(c1, c2)
  366:     return pu.trimseq(ret)
  367: 
  368: 
  369: def polydiv(c1, c2):
  370:     """
  371:     Divide one polynomial by another.
  372: 
  373:     Returns the quotient-with-remainder of two polynomials `c1` / `c2`.
  374:     The arguments are sequences of coefficients, from lowest order term
  375:     to highest, e.g., [1,2,3] represents ``1 + 2*x + 3*x**2``.
  376: 
  377:     Parameters
  378:     ----------
  379:     c1, c2 : array_like
  380:         1-D arrays of polynomial coefficients ordered from low to high.
  381: 
  382:     Returns
  383:     -------
  384:     [quo, rem] : ndarrays
  385:         Of coefficient series representing the quotient and remainder.
  386: 
  387:     See Also
  388:     --------
  389:     polyadd, polysub, polymulx, polymul, polypow
  390: 
  391:     Examples
  392:     --------
  393:     >>> from numpy.polynomial import polynomial as P
  394:     >>> c1 = (1, 2, 3)
  395:     >>> c2 = (3, 2, 1)
  396:     >>> P.polydiv(c1, c2)
  397:     (array([3.]), array([-8., -4.]))
  398:     >>> P.polydiv(c2, c1)
  399:     (array([ 0.33333333]), array([ 2.66666667,  1.33333333]))  # may vary
  400: 
  401:     """
  402:     # c1, c2 are trimmed copies
  403:     [c1, c2] = pu.as_series([c1, c2])
  404:     if c2[-1] == 0:
  405:         raise ZeroDivisionError  # FIXME: add message with details to exception
  406: 
  407:     # note: this is more efficient than `pu._div(polymul, c1, c2)`
  408:     lc1 = len(c1)
  409:     lc2 = len(c2)
  410:     if lc1 < lc2:
  411:         return c1[:1] * 0, c1
  412:     elif lc2 == 1:
  413:         return c1 / c2[-1], c1[:1] * 0
  414:     else:
  415:         dlen = lc1 - lc2
  416:         scl = c2[-1]
  417:         c2 = c2[:-1] / scl
  418:         i = dlen
  419:         j = lc1 - 1
  420:         while i >= 0:
  421:             c1[i:j] -= c2 * c1[j]
  422:             i -= 1
  423:             j -= 1
  424:         return c1[j + 1:] / scl, pu.trimseq(c1[:j + 1])
  425: 
  426: 
  427: def polypow(c, pow, maxpower=None):
  428:     """Raise a polynomial to a power.
  429: 
  430:     Returns the polynomial `c` raised to the power `pow`. The argument
  431:     `c` is a sequence of coefficients ordered from low to high. i.e.,
  432:     [1,2,3] is the series  ``1 + 2*x + 3*x**2.``
  433: 
  434:     Parameters
  435:     ----------
  436:     c : array_like
  437:         1-D array of array of series coefficients ordered from low to
  438:         high degree.
  439:     pow : integer
  440:         Power to which the series will be raised
  441:     maxpower : integer, optional
  442:         Maximum power allowed. This is mainly to limit growth of the series
  443:         to unmanageable size. Default is 16
  444: 
  445:     Returns
  446:     -------
  447:     coef : ndarray
  448:         Power series of power.
  449: 
  450:     See Also
  451:     --------
  452:     polyadd, polysub, polymulx, polymul, polydiv
  453: 
  454:     Examples
  455:     --------
  456:     >>> from numpy.polynomial import polynomial as P
  457:     >>> P.polypow([1, 2, 3], 2)
  458:     array([ 1., 4., 10., 12., 9.])
  459: 
  460:     """
  461:     # note: this is more efficient than `pu._pow(polymul, c1, c2)`, as it
  462:     # avoids calling `as_series` repeatedly
  463:     return pu._pow(np.convolve, c, pow, maxpower)
  464: 
  465: 
  466: def polyder(c, m=1, scl=1, axis=0):
  467:     """
  468:     Differentiate a polynomial.
  469: 
  470:     Returns the polynomial coefficients `c` differentiated `m` times along
  471:     `axis`.  At each iteration the result is multiplied by `scl` (the
  472:     scaling factor is for use in a linear change of variable).  The
  473:     argument `c` is an array of coefficients from low to high degree along
  474:     each axis, e.g., [1,2,3] represents the polynomial ``1 + 2*x + 3*x**2``
  475:     while [[1,2],[1,2]] represents ``1 + 1*x + 2*y + 2*x*y`` if axis=0 is
  476:     ``x`` and axis=1 is ``y``.
  477: 
  478:     Parameters
  479:     ----------
  480:     c : array_like
  481:         Array of polynomial coefficients. If c is multidimensional the
  482:         different axis correspond to different variables with the degree
  483:         in each axis given by the corresponding index.
  484:     m : int, optional
  485:         Number of derivatives taken, must be non-negative. (Default: 1)
  486:     scl : scalar, optional
  487:         Each differentiation is multiplied by `scl`.  The end result is
  488:         multiplication by ``scl**m``.  This is for use in a linear change
  489:         of variable. (Default: 1)
  490:     axis : int, optional
  491:         Axis over which the derivative is taken. (Default: 0).
  492: 
  493:     Returns
  494:     -------
  495:     der : ndarray
  496:         Polynomial coefficients of the derivative.
  497: 
  498:     See Also
  499:     --------
  500:     polyint
  501: 
  502:     Examples
  503:     --------
  504:     >>> from numpy.polynomial import polynomial as P
  505:     >>> c = (1, 2, 3, 4)
  506:     >>> P.polyder(c)  # (d/dx)(c)
  507:     array([  2.,   6.,  12.])
  508:     >>> P.polyder(c, 3)  # (d**3/dx**3)(c)
  509:     array([24.])
  510:     >>> P.polyder(c, scl=-1)  # (d/d(-x))(c)
  511:     array([ -2.,  -6., -12.])
  512:     >>> P.polyder(c, 2, -1)  # (d**2/d(-x)**2)(c)
  513:     array([  6.,  24.])
  514: 
  515:     """
  516:     c = np.array(c, ndmin=1, copy=True)
  517:     if c.dtype.char in '?bBhHiIlLqQpP':
  518:         # astype fails with NA
  519:         c = c + 0.0
  520:     cdt = c.dtype
  521:     cnt = pu._as_int(m, "the order of derivation")
  522:     iaxis = pu._as_int(axis, "the axis")
  523:     if cnt < 0:
  524:         raise ValueError("The order of derivation must be non-negative")
  525:     iaxis = normalize_axis_index(iaxis, c.ndim)
  526: 
  527:     if cnt == 0:
  528:         return c
  529: 
  530:     c = np.moveaxis(c, iaxis, 0)
  531:     n = len(c)
  532:     if cnt >= n:
  533:         c = c[:1] * 0
  534:     else:
  535:         for i in range(cnt):
  536:             n = n - 1
  537:             c *= scl
  538:             der = np.empty((n,) + c.shape[1:], dtype=cdt)
  539:             for j in range(n, 0, -1):
  540:                 der[j - 1] = j * c[j]
  541:             c = der
  542:     c = np.moveaxis(c, 0, iaxis)
  543:     return c
  544: 
  545: 
  546: def polyint(c, m=1, k=[], lbnd=0, scl=1, axis=0):
  547:     """
  548:     Integrate a polynomial.
  549: 
  550:     Returns the polynomial coefficients `c` integrated `m` times from
  551:     `lbnd` along `axis`.  At each iteration the resulting series is
  552:     **multiplied** by `scl` and an integration constant, `k`, is added.
  553:     The scaling factor is for use in a linear change of variable.  ("Buyer
  554:     beware": note that, depending on what one is doing, one may want `scl`
  555:     to be the reciprocal of what one might expect; for more information,
  556:     see the Notes section below.) The argument `c` is an array of
  557:     coefficients, from low to high degree along each axis, e.g., [1,2,3]
  558:     represents the polynomial ``1 + 2*x + 3*x**2`` while [[1,2],[1,2]]
  559:     represents ``1 + 1*x + 2*y + 2*x*y`` if axis=0 is ``x`` and axis=1 is
  560:     ``y``.
  561: 
  562:     Parameters
  563:     ----------
  564:     c : array_like
  565:         1-D array of polynomial coefficients, ordered from low to high.
  566:     m : int, optional
  567:         Order of integration, must be positive. (Default: 1)
  568:     k : {[], list, scalar}, optional
  569:         Integration constant(s).  The value of the first integral at zero
  570:         is the first value in the list, the value of the second integral
  571:         at zero is the second value, etc.  If ``k == []`` (the default),
  572:         all constants are set to zero.  If ``m == 1``, a single scalar can
  573:         be given instead of a list.
  574:     lbnd : scalar, optional
  575:         The lower bound of the integral. (Default: 0)
  576:     scl : scalar, optional
  577:         Following each integration the result is *multiplied* by `scl`
  578:         before the integration constant is added. (Default: 1)
  579:     axis : int, optional
  580:         Axis over which the integral is taken. (Default: 0).
  581: 
  582:     Returns
  583:     -------
  584:     S : ndarray
  585:         Coefficient array of the integral.
  586: 
  587:     Raises
  588:     ------
  589:     ValueError
  590:         If ``m < 1``, ``len(k) > m``, ``np.ndim(lbnd) != 0``, or
  591:         ``np.ndim(scl) != 0``.
  592: 
  593:     See Also
  594:     --------
  595:     polyder
  596: 
  597:     Notes
  598:     -----
  599:     Note that the result of each integration is *multiplied* by `scl`.  Why
  600:     is this important to note?  Say one is making a linear change of
  601:     variable :math:`u = ax + b` in an integral relative to `x`. Then
  602:     :math:`dx = du/a`, so one will need to set `scl` equal to
  603:     :math:`1/a` - perhaps not what one would have first thought.
  604: 
  605:     Examples
  606:     --------
  607:     >>> from numpy.polynomial import polynomial as P
  608:     >>> c = (1, 2, 3)
  609:     >>> P.polyint(c)  # should return array([0, 1, 1, 1])
  610:     array([0.,  1.,  1.,  1.])
  611:     >>> P.polyint(c, 3)  # should return array([0, 0, 0, 1/6, 1/12, 1/20])
  612:      array([ 0.        ,  0.        ,  0.        ,  0.16666667,  0.08333333, # may vary
  613:              0.05      ])
  614:     >>> P.polyint(c, k=3)  # should return array([3, 1, 1, 1])
  615:     array([3.,  1.,  1.,  1.])
  616:     >>> P.polyint(c,lbnd=-2)  # should return array([6, 1, 1, 1])
  617:     array([6.,  1.,  1.,  1.])
  618:     >>> P.polyint(c,scl=-2)  # should return array([0, -2, -2, -2])
  619:     array([ 0., -2., -2., -2.])
  620: 
  621:     """
  622:     c = np.array(c, ndmin=1, copy=True)
  623:     if c.dtype.char in '?bBhHiIlLqQpP':
  624:         # astype doesn't preserve mask attribute.
  625:         c = c + 0.0
  626:     cdt = c.dtype
  627:     if not np.iterable(k):
  628:         k = [k]
  629:     cnt = pu._as_int(m, "the order of integration")
  630:     iaxis = pu._as_int(axis, "the axis")
  631:     if cnt < 0:
  632:         raise ValueError("The order of integration must be non-negative")
  633:     if len(k) > cnt:
  634:         raise ValueError("Too many integration constants")
  635:     if np.ndim(lbnd) != 0:
  636:         raise ValueError("lbnd must be a scalar.")
  637:     if np.ndim(scl) != 0:
  638:         raise ValueError("scl must be a scalar.")
  639:     iaxis = normalize_axis_index(iaxis, c.ndim)
  640: 
  641:     if cnt == 0:
  642:         return c
  643: 
  644:     k = list(k) + [0] * (cnt - len(k))
  645:     c = np.moveaxis(c, iaxis, 0)
  646:     for i in range(cnt):
  647:         n = len(c)
  648:         c *= scl
  649:         if n == 1 and np.all(c[0] == 0):
  650:             c[0] += k[i]
  651:         else:
  652:             tmp = np.empty((n + 1,) + c.shape[1:], dtype=cdt)
  653:             tmp[0] = c[0] * 0
  654:             tmp[1] = c[0]
  655:             for j in range(1, n):
  656:                 tmp[j + 1] = c[j] / (j + 1)
  657:             tmp[0] += k[i] - polyval(lbnd, tmp)
  658:             c = tmp
  659:     c = np.moveaxis(c, 0, iaxis)
  660:     return c
  661: 
  662: 
  663: def polyval(x, c, tensor=True):
  664:     """
  665:     Evaluate a polynomial at points x.
  666: 
  667:     If `c` is of length ``n + 1``, this function returns the value
  668: 
  669:     .. math:: p(x) = c_0 + c_1 * x + ... + c_n * x^n
  670: 
  671:     The parameter `x` is converted to an array only if it is a tuple or a
  672:     list, otherwise it is treated as a scalar. In either case, either `x`
  673:     or its elements must support multiplication and addition both with
  674:     themselves and with the elements of `c`.
  675: 
  676:     If `c` is a 1-D array, then ``p(x)`` will have the same shape as `x`.  If
  677:     `c` is multidimensional, then the shape of the result depends on the
  678:     value of `tensor`. If `tensor` is true the shape will be c.shape[1:] +
  679:     x.shape. If `tensor` is false the shape will be c.shape[1:]. Note that
  680:     scalars have shape (,).
  681: 
  682:     Trailing zeros in the coefficients will be used in the evaluation, so
  683:     they should be avoided if efficiency is a concern.
  684: 
  685:     Parameters
  686:     ----------
  687:     x : array_like, compatible object
  688:         If `x` is a list or tuple, it is converted to an ndarray, otherwise
  689:         it is left unchanged and treated as a scalar. In either case, `x`
  690:         or its elements must support addition and multiplication with
  691:         with themselves and with the elements of `c`.
  692:     c : array_like
  693:         Array of coefficients ordered so that the coefficients for terms of
  694:         degree n are contained in c[n]. If `c` is multidimensional the
  695:         remaining indices enumerate multiple polynomials. In the two
  696:         dimensional case the coefficients may be thought of as stored in
  697:         the columns of `c`.
  698:     tensor : boolean, optional
  699:         If True, the shape of the coefficient array is extended with ones
  700:         on the right, one for each dimension of `x`. Scalars have dimension 0
  701:         for this action. The result is that every column of coefficients in
  702:         `c` is evaluated for every element of `x`. If False, `x` is broadcast
  703:         over the columns of `c` for the evaluation.  This keyword is useful
  704:         when `c` is multidimensional. The default value is True.
  705: 
  706:     Returns
  707:     -------
  708:     values : ndarray, compatible object
  709:         The shape of the returned array is described above.
  710: 
  711:     See Also
  712:     --------
  713:     polyval2d, polygrid2d, polyval3d, polygrid3d
  714: 
  715:     Notes
  716:     -----
  717:     The evaluation uses Horner's method.
  718: 
  719:     Examples
  720:     --------
  721:     >>> import numpy as np
  722:     >>> from numpy.polynomial.polynomial import polyval
  723:     >>> polyval(1, [1,2,3])
  724:     6.0
  725:     >>> a = np.arange(4).reshape(2,2)
  726:     >>> a
  727:     array([[0, 1],
  728:            [2, 3]])
  729:     >>> polyval(a, [1, 2, 3])
  730:     array([[ 1.,   6.],
  731:            [17.,  34.]])
  732:     >>> coef = np.arange(4).reshape(2, 2)  # multidimensional coefficients
  733:     >>> coef
  734:     array([[0, 1],
  735:            [2, 3]])
  736:     >>> polyval([1, 2], coef, tensor=True)
  737:     array([[2.,  4.],
  738:            [4.,  7.]])
  739:     >>> polyval([1, 2], coef, tensor=False)
  740:     array([2.,  7.])
  741: 
  742:     """
  743:     c = np.array(c, ndmin=1, copy=None)
  744:     if c.dtype.char in '?bBhHiIlLqQpP':
  745:         # astype fails with NA
  746:         c = c + 0.0
  747:     if isinstance(x, (tuple, list)):
  748:         x = np.asarray(x)
  749:     if isinstance(x, np.ndarray) and tensor:
  750:         c = c.reshape(c.shape + (1,) * x.ndim)
  751: 
  752:     c0 = c[-1] + x * 0
  753:     for i in range(2, len(c) + 1):
  754:         c0 = c[-i] + c0 * x
  755:     return c0
  756: 
  757: 
  758: def polyvalfromroots(x, r, tensor=True):
  759:     """
  760:     Evaluate a polynomial specified by its roots at points x.
  761: 
  762:     If `r` is of length ``N``, this function returns the value
  763: 
  764:     .. math:: p(x) = \\prod_{n=1}^{N} (x - r_n)
  765: 
  766:     The parameter `x` is converted to an array only if it is a tuple or a
  767:     list, otherwise it is treated as a scalar. In either case, either `x`
  768:     or its elements must support multiplication and addition both with
  769:     themselves and with the elements of `r`.
  770: 
  771:     If `r` is a 1-D array, then ``p(x)`` will have the same shape as `x`.  If `r`
  772:     is multidimensional, then the shape of the result depends on the value of
  773:     `tensor`. If `tensor` is ``True`` the shape will be r.shape[1:] + x.shape;
  774:     that is, each polynomial is evaluated at every value of `x`. If `tensor` is
  775:     ``False``, the shape will be r.shape[1:]; that is, each polynomial is
  776:     evaluated only for the corresponding broadcast value of `x`. Note that
  777:     scalars have shape (,).
  778: 
  779:     Parameters
  780:     ----------
  781:     x : array_like, compatible object
  782:         If `x` is a list or tuple, it is converted to an ndarray, otherwise
  783:         it is left unchanged and treated as a scalar. In either case, `x`
  784:         or its elements must support addition and multiplication with
  785:         with themselves and with the elements of `r`.
  786:     r : array_like
  787:         Array of roots. If `r` is multidimensional the first index is the
  788:         root index, while the remaining indices enumerate multiple
  789:         polynomials. For instance, in the two dimensional case the roots
  790:         of each polynomial may be thought of as stored in the columns of `r`.
  791:     tensor : boolean, optional
  792:         If True, the shape of the roots array is extended with ones on the
  793:         right, one for each dimension of `x`. Scalars have dimension 0 for this
  794:         action. The result is that every column of coefficients in `r` is
  795:         evaluated for every element of `x`. If False, `x` is broadcast over the
  796:         columns of `r` for the evaluation.  This keyword is useful when `r` is
  797:         multidimensional. The default value is True.
  798: 
  799:     Returns
  800:     -------
  801:     values : ndarray, compatible object
  802:         The shape of the returned array is described above.
  803: 
  804:     See Also
  805:     --------
  806:     polyroots, polyfromroots, polyval
  807: 
  808:     Examples
  809:     --------
  810:     >>> from numpy.polynomial.polynomial import polyvalfromroots
  811:     >>> polyvalfromroots(1, [1, 2, 3])
  812:     0.0
  813:     >>> a = np.arange(4).reshape(2, 2)
  814:     >>> a
  815:     array([[0, 1],
  816:            [2, 3]])
  817:     >>> polyvalfromroots(a, [-1, 0, 1])
  818:     array([[-0.,   0.],
  819:            [ 6.,  24.]])
  820:     >>> r = np.arange(-2, 2).reshape(2,2)  # multidimensional coefficients
  821:     >>> r # each column of r defines one polynomial
  822:     array([[-2, -1],
  823:            [ 0,  1]])
  824:     >>> b = [-2, 1]
  825:     >>> polyvalfromroots(b, r, tensor=True)
  826:     array([[-0.,  3.],
  827:            [ 3., 0.]])
  828:     >>> polyvalfromroots(b, r, tensor=False)
  829:     array([-0.,  0.])
  830: 
  831:     """
  832:     r = np.array(r, ndmin=1, copy=None)
  833:     if r.dtype.char in '?bBhHiIlLqQpP':
  834:         r = r.astype(np.double)
  835:     if isinstance(x, (tuple, list)):
  836:         x = np.asarray(x)
  837:     if isinstance(x, np.ndarray):
  838:         if tensor:
  839:             r = r.reshape(r.shape + (1,) * x.ndim)
  840:         elif x.ndim >= r.ndim:
  841:             raise ValueError("x.ndim must be < r.ndim when tensor == False")
  842:     return np.prod(x - r, axis=0)
  843: 
  844: 
  845: def polyval2d(x, y, c):
  846:     """
  847:     Evaluate a 2-D polynomial at points (x, y).
  848: 
  849:     This function returns the value
  850: 
  851:     .. math:: p(x,y) = \\sum_{i,j} c_{i,j} * x^i * y^j
  852: 
  853:     The parameters `x` and `y` are converted to arrays only if they are
  854:     tuples or a lists, otherwise they are treated as a scalars and they
  855:     must have the same shape after conversion. In either case, either `x`
  856:     and `y` or their elements must support multiplication and addition both
  857:     with themselves and with the elements of `c`.
  858: 
  859:     If `c` has fewer than two dimensions, ones are implicitly appended to
  860:     its shape to make it 2-D. The shape of the result will be c.shape[2:] +
  861:     x.shape.
  862: 
  863:     Parameters
  864:     ----------
  865:     x, y : array_like, compatible objects
  866:         The two dimensional series is evaluated at the points ``(x, y)``,
  867:         where `x` and `y` must have the same shape. If `x` or `y` is a list
  868:         or tuple, it is first converted to an ndarray, otherwise it is left
  869:         unchanged and, if it isn't an ndarray, it is treated as a scalar.
  870:     c : array_like
  871:         Array of coefficients ordered so that the coefficient of the term
  872:         of multi-degree i,j is contained in ``c[i,j]``. If `c` has
  873:         dimension greater than two the remaining indices enumerate multiple
  874:         sets of coefficients.
  875: 
  876:     Returns
  877:     -------
  878:     values : ndarray, compatible object
  879:         The values of the two dimensional polynomial at points formed with
  880:         pairs of corresponding values from `x` and `y`.
  881: 
  882:     See Also
  883:     --------
  884:     polyval, polygrid2d, polyval3d, polygrid3d
  885: 
  886:     Examples
  887:     --------
  888:     >>> from numpy.polynomial import polynomial as P
  889:     >>> c = ((1, 2, 3), (4, 5, 6))
  890:     >>> P.polyval2d(1, 1, c)
  891:     21.0
  892: 
  893:     """
  894:     return pu._valnd(polyval, c, x, y)
  895: 
  896: 
  897: def polygrid2d(x, y, c):
  898:     """
  899:     Evaluate a 2-D polynomial on the Cartesian product of x and y.
  900: 
  901:     This function returns the values:
  902: 
  903:     .. math:: p(a,b) = \\sum_{i,j} c_{i,j} * a^i * b^j
  904: 
  905:     where the points ``(a, b)`` consist of all pairs formed by taking
  906:     `a` from `x` and `b` from `y`. The resulting points form a grid with
  907:     `x` in the first dimension and `y` in the second.
  908: 
  909:     The parameters `x` and `y` are converted to arrays only if they are
  910:     tuples or a lists, otherwise they are treated as a scalars. In either
  911:     case, either `x` and `y` or their elements must support multiplication
  912:     and addition both with themselves and with the elements of `c`.
  913: 
  914:     If `c` has fewer than two dimensions, ones are implicitly appended to
  915:     its shape to make it 2-D. The shape of the result will be c.shape[2:] +
  916:     x.shape + y.shape.
  917: 
  918:     Parameters
  919:     ----------
  920:     x, y : array_like, compatible objects
  921:         The two dimensional series is evaluated at the points in the
  922:         Cartesian product of `x` and `y`.  If `x` or `y` is a list or
  923:         tuple, it is first converted to an ndarray, otherwise it is left
  924:         unchanged and, if it isn't an ndarray, it is treated as a scalar.
  925:     c : array_like
  926:         Array of coefficients ordered so that the coefficients for terms of
  927:         degree i,j are contained in ``c[i,j]``. If `c` has dimension
  928:         greater than two the remaining indices enumerate multiple sets of
  929:         coefficients.
  930: 
  931:     Returns
  932:     -------
  933:     values : ndarray, compatible object
  934:         The values of the two dimensional polynomial at points in the Cartesian
  935:         product of `x` and `y`.
  936: 
  937:     See Also
  938:     --------
  939:     polyval, polyval2d, polyval3d, polygrid3d
  940: 
  941:     Examples
  942:     --------
  943:     >>> from numpy.polynomial import polynomial as P
  944:     >>> c = ((1, 2, 3), (4, 5, 6))
  945:     >>> P.polygrid2d([0, 1], [0, 1], c)
  946:     array([[ 1.,  6.],
  947:            [ 5., 21.]])
  948: 
  949:     """
  950:     return pu._gridnd(polyval, c, x, y)
  951: 
  952: 
  953: def polyval3d(x, y, z, c):
  954:     """
  955:     Evaluate a 3-D polynomial at points (x, y, z).
  956: 
  957:     This function returns the values:
  958: 
  959:     .. math:: p(x,y,z) = \\sum_{i,j,k} c_{i,j,k} * x^i * y^j * z^k
  960: 
  961:     The parameters `x`, `y`, and `z` are converted to arrays only if
  962:     they are tuples or a lists, otherwise they are treated as a scalars and
  963:     they must have the same shape after conversion. In either case, either
  964:     `x`, `y`, and `z` or their elements must support multiplication and
  965:     addition both with themselves and with the elements of `c`.
  966: 
  967:     If `c` has fewer than 3 dimensions, ones are implicitly appended to its
  968:     shape to make it 3-D. The shape of the result will be c.shape[3:] +
  969:     x.shape.
  970: 
  971:     Parameters
  972:     ----------
  973:     x, y, z : array_like, compatible object
  974:         The three dimensional series is evaluated at the points
  975:         ``(x, y, z)``, where `x`, `y`, and `z` must have the same shape.  If
  976:         any of `x`, `y`, or `z` is a list or tuple, it is first converted
  977:         to an ndarray, otherwise it is left unchanged and if it isn't an
  978:         ndarray it is  treated as a scalar.
  979:     c : array_like
  980:         Array of coefficients ordered so that the coefficient of the term of
  981:         multi-degree i,j,k is contained in ``c[i,j,k]``. If `c` has dimension
  982:         greater than 3 the remaining indices enumerate multiple sets of
  983:         coefficients.
  984: 
  985:     Returns
  986:     -------
  987:     values : ndarray, compatible object
  988:         The values of the multidimensional polynomial on points formed with
  989:         triples of corresponding values from `x`, `y`, and `z`.
  990: 
  991:     See Also
  992:     --------
  993:     polyval, polyval2d, polygrid2d, polygrid3d
  994: 
  995:     Examples
  996:     --------
  997:     >>> from numpy.polynomial import polynomial as P
  998:     >>> c = ((1, 2, 3), (4, 5, 6), (7, 8, 9))
  999:     >>> P.polyval3d(1, 1, 1, c)
 1000:     45.0
 1001: 
 1002:     """
 1003:     return pu._valnd(polyval, c, x, y, z)
 1004: 
 1005: 
 1006: def polygrid3d(x, y, z, c):
 1007:     """
 1008:     Evaluate a 3-D polynomial on the Cartesian product of x, y and z.
 1009: 
 1010:     This function returns the values:
 1011: 
 1012:     .. math:: p(a,b,c) = \\sum_{i,j,k} c_{i,j,k} * a^i * b^j * c^k
 1013: 
 1014:     where the points ``(a, b, c)`` consist of all triples formed by taking
 1015:     `a` from `x`, `b` from `y`, and `c` from `z`. The resulting points form
 1016:     a grid with `x` in the first dimension, `y` in the second, and `z` in
 1017:     the third.
 1018: 
 1019:     The parameters `x`, `y`, and `z` are converted to arrays only if they
 1020:     are tuples or a lists, otherwise they are treated as a scalars. In
 1021:     either case, either `x`, `y`, and `z` or their elements must support
 1022:     multiplication and addition both with themselves and with the elements
 1023:     of `c`.
 1024: 
 1025:     If `c` has fewer than three dimensions, ones are implicitly appended to
 1026:     its shape to make it 3-D. The shape of the result will be c.shape[3:] +
 1027:     x.shape + y.shape + z.shape.
 1028: 
 1029:     Parameters
 1030:     ----------
 1031:     x, y, z : array_like, compatible objects
 1032:         The three dimensional series is evaluated at the points in the
 1033:         Cartesian product of `x`, `y`, and `z`.  If `x`, `y`, or `z` is a
 1034:         list or tuple, it is first converted to an ndarray, otherwise it is
 1035:         left unchanged and, if it isn't an ndarray, it is treated as a
 1036:         scalar.
 1037:     c : array_like
 1038:         Array of coefficients ordered so that the coefficients for terms of
 1039:         degree i,j are contained in ``c[i,j]``. If `c` has dimension
 1040:         greater than two the remaining indices enumerate multiple sets of
 1041:         coefficients.
 1042: 
 1043:     Returns
 1044:     -------
 1045:     values : ndarray, compatible object
 1046:         The values of the two dimensional polynomial at points in the Cartesian
 1047:         product of `x` and `y`.
 1048: 
 1049:     See Also
 1050:     --------
 1051:     polyval, polyval2d, polygrid2d, polyval3d
 1052: 
 1053:     Examples
 1054:     --------
 1055:     >>> from numpy.polynomial import polynomial as P
 1056:     >>> c = ((1, 2, 3), (4, 5, 6), (7, 8, 9))
 1057:     >>> P.polygrid3d([0, 1], [0, 1], [0, 1], c)
 1058:     array([[ 1., 13.],
 1059:            [ 6., 51.]])
 1060: 
 1061:     """
 1062:     return pu._gridnd(polyval, c, x, y, z)
 1063: 
 1064: 
 1065: def polyvander(x, deg):
 1066:     """Vandermonde matrix of given degree.
 1067: 
 1068:     Returns the Vandermonde matrix of degree `deg` and sample points
 1069:     `x`. The Vandermonde matrix is defined by
 1070: 
 1071:     .. math:: V[..., i] = x^i,
 1072: 
 1073:     where ``0 <= i <= deg``. The leading indices of `V` index the elements of
 1074:     `x` and the last index is the power of `x`.
 1075: 
 1076:     If `c` is a 1-D array of coefficients of length ``n + 1`` and `V` is the
 1077:     matrix ``V = polyvander(x, n)``, then ``np.dot(V, c)`` and
 1078:     ``polyval(x, c)`` are the same up to roundoff. This equivalence is
 1079:     useful both for least squares fitting and for the evaluation of a large
 1080:     number of polynomials of the same degree and sample points.
 1081: 
 1082:     Parameters
 1083:     ----------
 1084:     x : array_like
 1085:         Array of points. The dtype is converted to float64 or complex128
 1086:         depending on whether any of the elements are complex. If `x` is
 1087:         scalar it is converted to a 1-D array.
 1088:     deg : int
 1089:         Degree of the resulting matrix.
 1090: 
 1091:     Returns
 1092:     -------
 1093:     vander : ndarray.
 1094:         The Vandermonde matrix. The shape of the returned matrix is
 1095:         ``x.shape + (deg + 1,)``, where the last index is the power of `x`.
 1096:         The dtype will be the same as the converted `x`.
 1097: 
 1098:     See Also
 1099:     --------
 1100:     polyvander2d, polyvander3d
 1101: 
 1102:     Examples
 1103:     --------
 1104:     The Vandermonde matrix of degree ``deg = 5`` and sample points
 1105:     ``x = [-1, 2, 3]`` contains the element-wise powers of `x`
 1106:     from 0 to 5 as its columns.
 1107: 
 1108:     >>> from numpy.polynomial import polynomial as P
 1109:     >>> x, deg = [-1, 2, 3], 5
 1110:     >>> P.polyvander(x=x, deg=deg)
 1111:     array([[  1.,  -1.,   1.,  -1.,   1.,  -1.],
 1112:            [  1.,   2.,   4.,   8.,  16.,  32.],
 1113:            [  1.,   3.,   9.,  27.,  81., 243.]])
 1114: 
 1115:     """
 1116:     ideg = pu._as_int(deg, "deg")
 1117:     if ideg < 0:
 1118:         raise ValueError("deg must be non-negative")
 1119: 
 1120:     x = np.array(x, copy=None, ndmin=1) + 0.0
 1121:     dims = (ideg + 1,) + x.shape
 1122:     dtyp = x.dtype
 1123:     v = np.empty(dims, dtype=dtyp)
 1124:     v[0] = x * 0 + 1
 1125:     if ideg > 0:
 1126:         v[1] = x
 1127:         for i in range(2, ideg + 1):
 1128:             v[i] = v[i - 1] * x
 1129:     return np.moveaxis(v, 0, -1)
 1130: 
 1131: 
 1132: def polyvander2d(x, y, deg):
 1133:     """Pseudo-Vandermonde matrix of given degrees.
 1134: 
 1135:     Returns the pseudo-Vandermonde matrix of degrees `deg` and sample
 1136:     points ``(x, y)``. The pseudo-Vandermonde matrix is defined by
 1137: 
 1138:     .. math:: V[..., (deg[1] + 1)*i + j] = x^i * y^j,
 1139: 
 1140:     where ``0 <= i <= deg[0]`` and ``0 <= j <= deg[1]``. The leading indices of
 1141:     `V` index the points ``(x, y)`` and the last index encodes the powers of
 1142:     `x` and `y`.
 1143: 
 1144:     If ``V = polyvander2d(x, y, [xdeg, ydeg])``, then the columns of `V`
 1145:     correspond to the elements of a 2-D coefficient array `c` of shape
 1146:     (xdeg + 1, ydeg + 1) in the order
 1147: 
 1148:     .. math:: c_{00}, c_{01}, c_{02} ... , c_{10}, c_{11}, c_{12} ...
 1149: 
 1150:     and ``np.dot(V, c.flat)`` and ``polyval2d(x, y, c)`` will be the same
 1151:     up to roundoff. This equivalence is useful both for least squares
 1152:     fitting and for the evaluation of a large number of 2-D polynomials
 1153:     of the same degrees and sample points.
 1154: 
 1155:     Parameters
 1156:     ----------
 1157:     x, y : array_like
 1158:         Arrays of point coordinates, all of the same shape. The dtypes
 1159:         will be converted to either float64 or complex128 depending on
 1160:         whether any of the elements are complex. Scalars are converted to
 1161:         1-D arrays.
 1162:     deg : list of ints
 1163:         List of maximum degrees of the form [x_deg, y_deg].
 1164: 
 1165:     Returns
 1166:     -------
 1167:     vander2d : ndarray
 1168:         The shape of the returned matrix is ``x.shape + (order,)``, where
 1169:         :math:`order = (deg[0]+1)*(deg([1]+1)`.  The dtype will be the same
 1170:         as the converted `x` and `y`.
 1171: 
 1172:     See Also
 1173:     --------
 1174:     polyvander, polyvander3d, polyval2d, polyval3d
 1175: 
 1176:     Examples
 1177:     --------
 1178:     >>> import numpy as np
 1179: 
 1180:     The 2-D pseudo-Vandermonde matrix of degree ``[1, 2]`` and sample
 1181:     points ``x = [-1, 2]`` and ``y = [1, 3]`` is as follows:
 1182: 
 1183:     >>> from numpy.polynomial import polynomial as P
 1184:     >>> x = np.array([-1, 2])
 1185:     >>> y = np.array([1, 3])
 1186:     >>> m, n = 1, 2
 1187:     >>> deg = np.array([m, n])
 1188:     >>> V = P.polyvander2d(x=x, y=y, deg=deg)
 1189:     >>> V
 1190:     array([[ 1.,  1.,  1., -1., -1., -1.],
 1191:            [ 1.,  3.,  9.,  2.,  6., 18.]])
 1192: 
 1193:     We can verify the columns for any ``0 <= i <= m`` and ``0 <= j <= n``:
 1194: 
 1195:     >>> i, j = 0, 1
 1196:     >>> V[:, (deg[1]+1)*i + j] == x**i * y**j
 1197:     array([ True,  True])
 1198: 
 1199:     The (1D) Vandermonde matrix of sample points ``x`` and degree ``m`` is a
 1200:     special case of the (2D) pseudo-Vandermonde matrix with ``y`` points all
 1201:     zero and degree ``[m, 0]``.
 1202: 
 1203:     >>> P.polyvander2d(x=x, y=0*x, deg=(m, 0)) == P.polyvander(x=x, deg=m)
 1204:     array([[ True,  True],
 1205:            [ True,  True]])
 1206: 
 1207:     """
 1208:     return pu._vander_nd_flat((polyvander, polyvander), (x, y), deg)
 1209: 
 1210: 
 1211: def polyvander3d(x, y, z, deg):
 1212:     """Pseudo-Vandermonde matrix of given degrees.
 1213: 
 1214:     Returns the pseudo-Vandermonde matrix of degrees `deg` and sample
 1215:     points ``(x, y, z)``. If `l`, `m`, `n` are the given degrees in `x`, `y`, `z`,
 1216:     then The pseudo-Vandermonde matrix is defined by
 1217: 
 1218:     .. math:: V[..., (m+1)(n+1)i + (n+1)j + k] = x^i * y^j * z^k,
 1219: 
 1220:     where ``0 <= i <= l``, ``0 <= j <= m``, and ``0 <= j <= n``.  The leading
 1221:     indices of `V` index the points ``(x, y, z)`` and the last index encodes
 1222:     the powers of `x`, `y`, and `z`.
 1223: 
 1224:     If ``V = polyvander3d(x, y, z, [xdeg, ydeg, zdeg])``, then the columns
 1225:     of `V` correspond to the elements of a 3-D coefficient array `c` of
 1226:     shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order
 1227: 
 1228:     .. math:: c_{000}, c_{001}, c_{002},... , c_{010}, c_{011}, c_{012},...
 1229: 
 1230:     and  ``np.dot(V, c.flat)`` and ``polyval3d(x, y, z, c)`` will be the
 1231:     same up to roundoff. This equivalence is useful both for least squares
 1232:     fitting and for the evaluation of a large number of 3-D polynomials
 1233:     of the same degrees and sample points.
 1234: 
 1235:     Parameters
 1236:     ----------
 1237:     x, y, z : array_like
 1238:         Arrays of point coordinates, all of the same shape. The dtypes will
 1239:         be converted to either float64 or complex128 depending on whether
 1240:         any of the elements are complex. Scalars are converted to 1-D
 1241:         arrays.
 1242:     deg : list of ints
 1243:         List of maximum degrees of the form [x_deg, y_deg, z_deg].
 1244: 
 1245:     Returns
 1246:     -------
 1247:     vander3d : ndarray
 1248:         The shape of the returned matrix is ``x.shape + (order,)``, where
 1249:         :math:`order = (deg[0]+1)*(deg([1]+1)*(deg[2]+1)`.  The dtype will
 1250:         be the same as the converted `x`, `y`, and `z`.
 1251: 
 1252:     See Also
 1253:     --------
 1254:     polyvander, polyvander3d, polyval2d, polyval3d
 1255: 
 1256:     Examples
 1257:     --------
 1258:     >>> import numpy as np
 1259:     >>> from numpy.polynomial import polynomial as P
 1260:     >>> x = np.asarray([-1, 2, 1])
 1261:     >>> y = np.asarray([1, -2, -3])
 1262:     >>> z = np.asarray([2, 2, 5])
 1263:     >>> l, m, n = [2, 2, 1]
 1264:     >>> deg = [l, m, n]
 1265:     >>> V = P.polyvander3d(x=x, y=y, z=z, deg=deg)
 1266:     >>> V
 1267:     array([[  1.,   2.,   1.,   2.,   1.,   2.,  -1.,  -2.,  -1.,
 1268:              -2.,  -1.,  -2.,   1.,   2.,   1.,   2.,   1.,   2.],
 1269:            [  1.,   2.,  -2.,  -4.,   4.,   8.,   2.,   4.,  -4.,
 1270:              -8.,   8.,  16.,   4.,   8.,  -8., -16.,  16.,  32.],
 1271:            [  1.,   5.,  -3., -15.,   9.,  45.,   1.,   5.,  -3.,
 1272:             -15.,   9.,  45.,   1.,   5.,  -3., -15.,   9.,  45.]])
 1273: 
 1274:     We can verify the columns for any ``0 <= i <= l``, ``0 <= j <= m``,
 1275:     and ``0 <= k <= n``
 1276: 
 1277:     >>> i, j, k = 2, 1, 0
 1278:     >>> V[:, (m+1)*(n+1)*i + (n+1)*j + k] == x**i * y**j * z**k
 1279:     array([ True,  True,  True])
 1280: 
 1281:     """
 1282:     return pu._vander_nd_flat((polyvander, polyvander, polyvander), (x, y, z), deg)
 1283: 
 1284: 
 1285: def polyfit(x, y, deg, rcond=None, full=False, w=None):
 1286:     """
 1287:     Least-squares fit of a polynomial to data.
 1288: 
 1289:     Return the coefficients of a polynomial of degree `deg` that is the
 1290:     least squares fit to the data values `y` given at points `x`. If `y` is
 1291:     1-D the returned coefficients will also be 1-D. If `y` is 2-D multiple
 1292:     fits are done, one for each column of `y`, and the resulting
 1293:     coefficients are stored in the corresponding columns of a 2-D return.
 1294:     The fitted polynomial(s) are in the form
 1295: 
 1296:     .. math::  p(x) = c_0 + c_1 * x + ... + c_n * x^n,
 1297: 
 1298:     where `n` is `deg`.
 1299: 
 1300:     Parameters
 1301:     ----------
 1302:     x : array_like, shape (`M`,)
 1303:         x-coordinates of the `M` sample (data) points ``(x[i], y[i])``.
 1304:     y : array_like, shape (`M`,) or (`M`, `K`)
 1305:         y-coordinates of the sample points.  Several sets of sample points
 1306:         sharing the same x-coordinates can be (independently) fit with one
 1307:         call to `polyfit` by passing in for `y` a 2-D array that contains
 1308:         one data set per column.
 1309:     deg : int or 1-D array_like
 1310:         Degree(s) of the fitting polynomials. If `deg` is a single integer
 1311:         all terms up to and including the `deg`'th term are included in the
 1312:         fit. For NumPy versions >= 1.11.0 a list of integers specifying the
 1313:         degrees of the terms to include may be used instead.
 1314:     rcond : float, optional
 1315:         Relative condition number of the fit.  Singular values smaller
 1316:         than `rcond`, relative to the largest singular value, will be
 1317:         ignored.  The default value is ``len(x)*eps``, where `eps` is the
 1318:         relative precision of the platform's float type, about 2e-16 in
 1319:         most cases.
 1320:     full : bool, optional
 1321:         Switch determining the nature of the return value.  When ``False``
 1322:         (the default) just the coefficients are returned; when ``True``,
 1323:         diagnostic information from the singular value decomposition (used
 1324:         to solve the fit's matrix equation) is also returned.
 1325:     w : array_like, shape (`M`,), optional
 1326:         Weights. If not None, the weight ``w[i]`` applies to the unsquared
 1327:         residual ``y[i] - y_hat[i]`` at ``x[i]``. Ideally the weights are
 1328:         chosen so that the errors of the products ``w[i]*y[i]`` all have the
 1329:         same variance.  When using inverse-variance weighting, use
 1330:         ``w[i] = 1/sigma(y[i])``.  The default value is None.
 1331: 
 1332:     Returns
 1333:     -------
 1334:     coef : ndarray, shape (`deg` + 1,) or (`deg` + 1, `K`)
 1335:         Polynomial coefficients ordered from low to high.  If `y` was 2-D,
 1336:         the coefficients in column `k` of `coef` represent the polynomial
 1337:         fit to the data in `y`'s `k`-th column.
 1338: 
 1339:     [residuals, rank, singular_values, rcond] : list
 1340:         These values are only returned if ``full == True``
 1341: 
 1342:         - residuals -- sum of squared residuals of the least squares fit
 1343:         - rank -- the numerical rank of the scaled Vandermonde matrix
 1344:         - singular_values -- singular values of the scaled Vandermonde matrix
 1345:         - rcond -- value of `rcond`.
 1346: 
 1347:         For more details, see `numpy.linalg.lstsq`.
 1348: 
 1349:     Raises
 1350:     ------
 1351:     RankWarning
 1352:         Raised if the matrix in the least-squares fit is rank deficient.
 1353:         The warning is only raised if ``full == False``.  The warnings can
 1354:         be turned off by:
 1355: 
 1356:         >>> import warnings
 1357:         >>> warnings.simplefilter('ignore', np.exceptions.RankWarning)
 1358: 
 1359:     See Also
 1360:     --------
 1361:     numpy.polynomial.chebyshev.chebfit
 1362:     numpy.polynomial.legendre.legfit
 1363:     numpy.polynomial.laguerre.lagfit
 1364:     numpy.polynomial.hermite.hermfit
 1365:     numpy.polynomial.hermite_e.hermefit
 1366:     polyval : Evaluates a polynomial.
 1367:     polyvander : Vandermonde matrix for powers.
 1368:     numpy.linalg.lstsq : Computes a least-squares fit from the matrix.
 1369:     scipy.interpolate.UnivariateSpline : Computes spline fits.
 1370: 
 1371:     Notes
 1372:     -----
 1373:     The solution is the coefficients of the polynomial `p` that minimizes
 1374:     the sum of the weighted squared errors
 1375: 
 1376:     .. math:: E = \\sum_j w_j^2 * |y_j - p(x_j)|^2,
 1377: 
 1378:     where the :math:`w_j` are the weights. This problem is solved by
 1379:     setting up the (typically) over-determined matrix equation:
 1380: 
 1381:     .. math:: V(x) * c = w * y,
 1382: 
 1383:     where `V` is the weighted pseudo Vandermonde matrix of `x`, `c` are the
 1384:     coefficients to be solved for, `w` are the weights, and `y` are the
 1385:     observed values.  This equation is then solved using the singular value
 1386:     decomposition of `V`.
 1387: 
 1388:     If some of the singular values of `V` are so small that they are
 1389:     neglected (and `full` == ``False``), a `~exceptions.RankWarning` will be
 1390:     raised.  This means that the coefficient values may be poorly determined.
 1391:     Fitting to a lower order polynomial will usually get rid of the warning
 1392:     (but may not be what you want, of course; if you have independent
 1393:     reason(s) for choosing the degree which isn't working, you may have to:
 1394:     a) reconsider those reasons, and/or b) reconsider the quality of your
 1395:     data).  The `rcond` parameter can also be set to a value smaller than
 1396:     its default, but the resulting fit may be spurious and have large
 1397:     contributions from roundoff error.
 1398: 
 1399:     Polynomial fits using double precision tend to "fail" at about
 1400:     (polynomial) degree 20. Fits using Chebyshev or Legendre series are
 1401:     generally better conditioned, but much can still depend on the
 1402:     distribution of the sample points and the smoothness of the data.  If
 1403:     the quality of the fit is inadequate, splines may be a good
 1404:     alternative.
 1405: 
 1406:     Examples
 1407:     --------
 1408:     >>> import numpy as np
 1409:     >>> from numpy.polynomial import polynomial as P
 1410:     >>> x = np.linspace(-1,1,51)  # x "data": [-1, -0.96, ..., 0.96, 1]
 1411:     >>> rng = np.random.default_rng()
 1412:     >>> err = rng.normal(size=len(x))
 1413:     >>> y = x**3 - x + err  # x^3 - x + Gaussian noise
 1414:     >>> c, stats = P.polyfit(x,y,3,full=True)
 1415:     >>> c # c[0], c[1] approx. -1, c[2] should be approx. 0, c[3] approx. 1
 1416:     array([ 0.23111996, -1.02785049, -0.2241444 ,  1.08405657]) # may vary
 1417:     >>> stats # note the large SSR, explaining the rather poor results
 1418:     [array([48.312088]),                                        # may vary
 1419:      4,
 1420:      array([1.38446749, 1.32119158, 0.50443316, 0.28853036]),
 1421:      1.1324274851176597e-14]
 1422: 
 1423:     Same thing without the added noise
 1424: 
 1425:     >>> y = x**3 - x
 1426:     >>> c, stats = P.polyfit(x,y,3,full=True)
 1427:     >>> c # c[0], c[1] ~= -1, c[2] should be "very close to 0", c[3] ~= 1
 1428:     array([-6.73496154e-17, -1.00000000e+00,  0.00000000e+00,  1.00000000e+00])
 1429:     >>> stats # note the minuscule SSR
 1430:     [array([8.79579319e-31]),
 1431:      np.int32(4),
 1432:      array([1.38446749, 1.32119158, 0.50443316, 0.28853036]),
 1433:      1.1324274851176597e-14]
 1434: 
 1435:     """
 1436:     return pu._fit(polyvander, x, y, deg, rcond, full, w)
 1437: 
 1438: 
 1439: def polycompanion(c):
 1440:     """
 1441:     Return the companion matrix of c.
 1442: 
 1443:     The companion matrix for power series cannot be made symmetric by
 1444:     scaling the basis, so this function differs from those for the
 1445:     orthogonal polynomials.
 1446: 
 1447:     Parameters
 1448:     ----------
 1449:     c : array_like
 1450:         1-D array of polynomial coefficients ordered from low to high
 1451:         degree.
 1452: 
 1453:     Returns
 1454:     -------
 1455:     mat : ndarray
 1456:         Companion matrix of dimensions (deg, deg).
 1457: 
 1458:     Examples
 1459:     --------
 1460:     >>> from numpy.polynomial import polynomial as P
 1461:     >>> c = (1, 2, 3)
 1462:     >>> P.polycompanion(c)
 1463:     array([[ 0.        , -0.33333333],
 1464:            [ 1.        , -0.66666667]])
 1465: 
 1466:     """
 1467:     # c is a trimmed copy
 1468:     [c] = pu.as_series([c])
 1469:     if len(c) < 2:
 1470:         raise ValueError('Series must have maximum degree of at least 1.')
 1471:     if len(c) == 2:
 1472:         return np.array([[-c[0] / c[1]]])
 1473: 
 1474:     n = len(c) - 1
 1475:     mat = np.zeros((n, n), dtype=c.dtype)
 1476:     bot = mat.reshape(-1)[n::n + 1]
 1477:     bot[...] = 1
 1478:     mat[:, -1] -= c[:-1] / c[-1]
 1479:     return mat
 1480: 
 1481: 
 1482: def polyroots(c):
 1483:     """
 1484:     Compute the roots of a polynomial.
 1485: 
 1486:     Return the roots (a.k.a. "zeros") of the polynomial
 1487: 
 1488:     .. math:: p(x) = \\sum_i c[i] * x^i.
 1489: 
 1490:     Parameters
 1491:     ----------
 1492:     c : 1-D array_like
 1493:         1-D array of polynomial coefficients.
 1494: 
 1495:     Returns
 1496:     -------
 1497:     out : ndarray
 1498:         Array of the roots of the polynomial. If all the roots are real,
 1499:         then `out` is also real, otherwise it is complex.
 1500: 
 1501:     See Also
 1502:     --------
 1503:     numpy.polynomial.chebyshev.chebroots
 1504:     numpy.polynomial.legendre.legroots
 1505:     numpy.polynomial.laguerre.lagroots
 1506:     numpy.polynomial.hermite.hermroots
 1507:     numpy.polynomial.hermite_e.hermeroots
 1508: 
 1509:     Notes
 1510:     -----
 1511:     The root estimates are obtained as the eigenvalues of the companion
 1512:     matrix, Roots far from the origin of the complex plane may have large
 1513:     errors due to the numerical instability of the power series for such
 1514:     values. Roots with multiplicity greater than 1 will also show larger
 1515:     errors as the value of the series near such points is relatively
 1516:     insensitive to errors in the roots. Isolated roots near the origin can
 1517:     be improved by a few iterations of Newton's method.
 1518: 
 1519:     Examples
 1520:     --------
 1521:     >>> import numpy.polynomial.polynomial as poly
 1522:     >>> poly.polyroots(poly.polyfromroots((-1,0,1)))
 1523:     array([-1.,  0.,  1.])
 1524:     >>> poly.polyroots(poly.polyfromroots((-1,0,1))).dtype
 1525:     dtype('float64')
 1526:     >>> j = complex(0,1)
 1527:     >>> poly.polyroots(poly.polyfromroots((-j,0,j)))
 1528:     array([  0.00000000e+00+0.j,   0.00000000e+00+1.j,   2.77555756e-17-1.j])  # may vary
 1529: 
 1530:     """  # noqa: E501
 1531:     # c is a trimmed copy
 1532:     [c] = pu.as_series([c])
 1533:     if len(c) < 2:
 1534:         return np.array([], dtype=c.dtype)
 1535:     if len(c) == 2:
 1536:         return np.array([-c[0] / c[1]])
 1537: 
 1538:     m = polycompanion(c)
 1539:     r = la.eigvals(m)
 1540:     r.sort()
 1541:     return r
 1542: 
 1543: 
 1544: #
 1545: # polynomial class
 1546: #
 1547: 
 1548: class Polynomial(ABCPolyBase):
 1549:     """A power series class.
 1550: 
 1551:     The Polynomial class provides the standard Python numerical methods
 1552:     '+', '-', '*', '//', '%', 'divmod', '**', and '()' as well as the
 1553:     attributes and methods listed below.
 1554: 
 1555:     Parameters
 1556:     ----------
 1557:     coef : array_like
 1558:         Polynomial coefficients in order of increasing degree, i.e.,
 1559:         ``(1, 2, 3)`` give ``1 + 2*x + 3*x**2``.
 1560:     domain : (2,) array_like, optional
 1561:         Domain to use. The interval ``[domain[0], domain[1]]`` is mapped
 1562:         to the interval ``[window[0], window[1]]`` by shifting and scaling.
 1563:         The default value is [-1., 1.].
 1564:     window : (2,) array_like, optional
 1565:         Window, see `domain` for its use. The default value is [-1., 1.].
 1566:     symbol : str, optional
 1567:         Symbol used to represent the independent variable in string
 1568:         representations of the polynomial expression, e.g. for printing.
 1569:         The symbol must be a valid Python identifier. Default value is 'x'.
 1570: 
 1571:         .. versionadded:: 1.24
 1572: 
 1573:     """
 1574:     # Virtual Functions
 1575:     _add = staticmethod(polyadd)
 1576:     _sub = staticmethod(polysub)
 1577:     _mul = staticmethod(polymul)
 1578:     _div = staticmethod(polydiv)
 1579:     _pow = staticmethod(polypow)
 1580:     _val = staticmethod(polyval)
 1581:     _int = staticmethod(polyint)
 1582:     _der = staticmethod(polyder)
 1583:     _fit = staticmethod(polyfit)
 1584:     _line = staticmethod(polyline)
 1585:     _roots = staticmethod(polyroots)
 1586:     _fromroots = staticmethod(polyfromroots)
 1587: 
 1588:     # Virtual properties
 1589:     domain = np.array(polydomain)
 1590:     window = np.array(polydomain)
 1591:     basis_name = None
 1592: 
 1593:     @classmethod
 1594:     def _str_term_unicode(cls, i, arg_str):
 1595:         if i == '1':
 1596:             return f"В·{arg_str}"
 1597:         else:
 1598:             return f"В·{arg_str}{i.translate(cls._superscript_mapping)}"
 1599: 
 1600:     @staticmethod
 1601:     def _str_term_ascii(i, arg_str):
 1602:         if i == '1':
 1603:             return f" {arg_str}"
 1604:         else:
 1605:             return f" {arg_str}**{i}"
 1606: 
 1607:     @staticmethod
 1608:     def _repr_latex_term(i, arg_str, needs_parens):
 1609:         if needs_parens:
 1610:             arg_str = rf"\left({arg_str}\right)"
 1611:         if i == 0:
 1612:             return '1'
 1613:         elif i == 1:
 1614:             return arg_str
 1615:         else:
 1616:             return f"{arg_str}^{{{i}}}"
