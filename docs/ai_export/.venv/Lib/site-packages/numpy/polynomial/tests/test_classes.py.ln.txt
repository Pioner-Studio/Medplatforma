    1: """Test inter-conversion of different polynomial classes.
    2: 
    3: This tests the convert and cast methods of all the polynomial classes.
    4: 
    5: """
    6: import operator as op
    7: from numbers import Number
    8: 
    9: import pytest
   10: 
   11: import numpy as np
   12: from numpy.exceptions import RankWarning
   13: from numpy.polynomial import (
   14:     Chebyshev,
   15:     Hermite,
   16:     HermiteE,
   17:     Laguerre,
   18:     Legendre,
   19:     Polynomial,
   20: )
   21: from numpy.testing import (
   22:     assert_,
   23:     assert_almost_equal,
   24:     assert_equal,
   25:     assert_raises,
   26: )
   27: 
   28: #
   29: # fixtures
   30: #
   31: 
   32: classes = (
   33:     Polynomial, Legendre, Chebyshev, Laguerre,
   34:     Hermite, HermiteE
   35:     )
   36: classids = tuple(cls.__name__ for cls in classes)
   37: 
   38: @pytest.fixture(params=classes, ids=classids)
   39: def Poly(request):
   40:     return request.param
   41: 
   42: 
   43: #
   44: # helper functions
   45: #
   46: random = np.random.random
   47: 
   48: 
   49: def assert_poly_almost_equal(p1, p2, msg=""):
   50:     try:
   51:         assert_(np.all(p1.domain == p2.domain))
   52:         assert_(np.all(p1.window == p2.window))
   53:         assert_almost_equal(p1.coef, p2.coef)
   54:     except AssertionError:
   55:         msg = f"Result: {p1}\nTarget: {p2}"
   56:         raise AssertionError(msg)
   57: 
   58: 
   59: #
   60: # Test conversion methods that depend on combinations of two classes.
   61: #
   62: 
   63: Poly1 = Poly
   64: Poly2 = Poly
   65: 
   66: 
   67: def test_conversion(Poly1, Poly2):
   68:     x = np.linspace(0, 1, 10)
   69:     coef = random((3,))
   70: 
   71:     d1 = Poly1.domain + random((2,)) * .25
   72:     w1 = Poly1.window + random((2,)) * .25
   73:     p1 = Poly1(coef, domain=d1, window=w1)
   74: 
   75:     d2 = Poly2.domain + random((2,)) * .25
   76:     w2 = Poly2.window + random((2,)) * .25
   77:     p2 = p1.convert(kind=Poly2, domain=d2, window=w2)
   78: 
   79:     assert_almost_equal(p2.domain, d2)
   80:     assert_almost_equal(p2.window, w2)
   81:     assert_almost_equal(p2(x), p1(x))
   82: 
   83: 
   84: def test_cast(Poly1, Poly2):
   85:     x = np.linspace(0, 1, 10)
   86:     coef = random((3,))
   87: 
   88:     d1 = Poly1.domain + random((2,)) * .25
   89:     w1 = Poly1.window + random((2,)) * .25
   90:     p1 = Poly1(coef, domain=d1, window=w1)
   91: 
   92:     d2 = Poly2.domain + random((2,)) * .25
   93:     w2 = Poly2.window + random((2,)) * .25
   94:     p2 = Poly2.cast(p1, domain=d2, window=w2)
   95: 
   96:     assert_almost_equal(p2.domain, d2)
   97:     assert_almost_equal(p2.window, w2)
   98:     assert_almost_equal(p2(x), p1(x))
   99: 
  100: 
  101: #
  102: # test methods that depend on one class
  103: #
  104: 
  105: 
  106: def test_identity(Poly):
  107:     d = Poly.domain + random((2,)) * .25
  108:     w = Poly.window + random((2,)) * .25
  109:     x = np.linspace(d[0], d[1], 11)
  110:     p = Poly.identity(domain=d, window=w)
  111:     assert_equal(p.domain, d)
  112:     assert_equal(p.window, w)
  113:     assert_almost_equal(p(x), x)
  114: 
  115: 
  116: def test_basis(Poly):
  117:     d = Poly.domain + random((2,)) * .25
  118:     w = Poly.window + random((2,)) * .25
  119:     p = Poly.basis(5, domain=d, window=w)
  120:     assert_equal(p.domain, d)
  121:     assert_equal(p.window, w)
  122:     assert_equal(p.coef, [0] * 5 + [1])
  123: 
  124: 
  125: def test_fromroots(Poly):
  126:     # check that requested roots are zeros of a polynomial
  127:     # of correct degree, domain, and window.
  128:     d = Poly.domain + random((2,)) * .25
  129:     w = Poly.window + random((2,)) * .25
  130:     r = random((5,))
  131:     p1 = Poly.fromroots(r, domain=d, window=w)
  132:     assert_equal(p1.degree(), len(r))
  133:     assert_equal(p1.domain, d)
  134:     assert_equal(p1.window, w)
  135:     assert_almost_equal(p1(r), 0)
  136: 
  137:     # check that polynomial is monic
  138:     pdom = Polynomial.domain
  139:     pwin = Polynomial.window
  140:     p2 = Polynomial.cast(p1, domain=pdom, window=pwin)
  141:     assert_almost_equal(p2.coef[-1], 1)
  142: 
  143: 
  144: def test_bad_conditioned_fit(Poly):
  145: 
  146:     x = [0., 0., 1.]
  147:     y = [1., 2., 3.]
  148: 
  149:     # check RankWarning is raised
  150:     with pytest.warns(RankWarning) as record:
  151:         Poly.fit(x, y, 2)
  152:     assert record[0].message.args[0] == "The fit may be poorly conditioned"
  153: 
  154: 
  155: def test_fit(Poly):
  156: 
  157:     def f(x):
  158:         return x * (x - 1) * (x - 2)
  159:     x = np.linspace(0, 3)
  160:     y = f(x)
  161: 
  162:     # check default value of domain and window
  163:     p = Poly.fit(x, y, 3)
  164:     assert_almost_equal(p.domain, [0, 3])
  165:     assert_almost_equal(p(x), y)
  166:     assert_equal(p.degree(), 3)
  167: 
  168:     # check with given domains and window
  169:     d = Poly.domain + random((2,)) * .25
  170:     w = Poly.window + random((2,)) * .25
  171:     p = Poly.fit(x, y, 3, domain=d, window=w)
  172:     assert_almost_equal(p(x), y)
  173:     assert_almost_equal(p.domain, d)
  174:     assert_almost_equal(p.window, w)
  175:     p = Poly.fit(x, y, [0, 1, 2, 3], domain=d, window=w)
  176:     assert_almost_equal(p(x), y)
  177:     assert_almost_equal(p.domain, d)
  178:     assert_almost_equal(p.window, w)
  179: 
  180:     # check with class domain default
  181:     p = Poly.fit(x, y, 3, [])
  182:     assert_equal(p.domain, Poly.domain)
  183:     assert_equal(p.window, Poly.window)
  184:     p = Poly.fit(x, y, [0, 1, 2, 3], [])
  185:     assert_equal(p.domain, Poly.domain)
  186:     assert_equal(p.window, Poly.window)
  187: 
  188:     # check that fit accepts weights.
  189:     w = np.zeros_like(x)
  190:     z = y + random(y.shape) * .25
  191:     w[::2] = 1
  192:     p1 = Poly.fit(x[::2], z[::2], 3)
  193:     p2 = Poly.fit(x, z, 3, w=w)
  194:     p3 = Poly.fit(x, z, [0, 1, 2, 3], w=w)
  195:     assert_almost_equal(p1(x), p2(x))
  196:     assert_almost_equal(p2(x), p3(x))
  197: 
  198: 
  199: def test_equal(Poly):
  200:     p1 = Poly([1, 2, 3], domain=[0, 1], window=[2, 3])
  201:     p2 = Poly([1, 1, 1], domain=[0, 1], window=[2, 3])
  202:     p3 = Poly([1, 2, 3], domain=[1, 2], window=[2, 3])
  203:     p4 = Poly([1, 2, 3], domain=[0, 1], window=[1, 2])
  204:     assert_(p1 == p1)
  205:     assert_(not p1 == p2)
  206:     assert_(not p1 == p3)
  207:     assert_(not p1 == p4)
  208: 
  209: 
  210: def test_not_equal(Poly):
  211:     p1 = Poly([1, 2, 3], domain=[0, 1], window=[2, 3])
  212:     p2 = Poly([1, 1, 1], domain=[0, 1], window=[2, 3])
  213:     p3 = Poly([1, 2, 3], domain=[1, 2], window=[2, 3])
  214:     p4 = Poly([1, 2, 3], domain=[0, 1], window=[1, 2])
  215:     assert_(not p1 != p1)
  216:     assert_(p1 != p2)
  217:     assert_(p1 != p3)
  218:     assert_(p1 != p4)
  219: 
  220: 
  221: def test_add(Poly):
  222:     # This checks commutation, not numerical correctness
  223:     c1 = list(random((4,)) + .5)
  224:     c2 = list(random((3,)) + .5)
  225:     p1 = Poly(c1)
  226:     p2 = Poly(c2)
  227:     p3 = p1 + p2
  228:     assert_poly_almost_equal(p2 + p1, p3)
  229:     assert_poly_almost_equal(p1 + c2, p3)
  230:     assert_poly_almost_equal(c2 + p1, p3)
  231:     assert_poly_almost_equal(p1 + tuple(c2), p3)
  232:     assert_poly_almost_equal(tuple(c2) + p1, p3)
  233:     assert_poly_almost_equal(p1 + np.array(c2), p3)
  234:     assert_poly_almost_equal(np.array(c2) + p1, p3)
  235:     assert_raises(TypeError, op.add, p1, Poly([0], domain=Poly.domain + 1))
  236:     assert_raises(TypeError, op.add, p1, Poly([0], window=Poly.window + 1))
  237:     if Poly is Polynomial:
  238:         assert_raises(TypeError, op.add, p1, Chebyshev([0]))
  239:     else:
  240:         assert_raises(TypeError, op.add, p1, Polynomial([0]))
  241: 
  242: 
  243: def test_sub(Poly):
  244:     # This checks commutation, not numerical correctness
  245:     c1 = list(random((4,)) + .5)
  246:     c2 = list(random((3,)) + .5)
  247:     p1 = Poly(c1)
  248:     p2 = Poly(c2)
  249:     p3 = p1 - p2
  250:     assert_poly_almost_equal(p2 - p1, -p3)
  251:     assert_poly_almost_equal(p1 - c2, p3)
  252:     assert_poly_almost_equal(c2 - p1, -p3)
  253:     assert_poly_almost_equal(p1 - tuple(c2), p3)
  254:     assert_poly_almost_equal(tuple(c2) - p1, -p3)
  255:     assert_poly_almost_equal(p1 - np.array(c2), p3)
  256:     assert_poly_almost_equal(np.array(c2) - p1, -p3)
  257:     assert_raises(TypeError, op.sub, p1, Poly([0], domain=Poly.domain + 1))
  258:     assert_raises(TypeError, op.sub, p1, Poly([0], window=Poly.window + 1))
  259:     if Poly is Polynomial:
  260:         assert_raises(TypeError, op.sub, p1, Chebyshev([0]))
  261:     else:
  262:         assert_raises(TypeError, op.sub, p1, Polynomial([0]))
  263: 
  264: 
  265: def test_mul(Poly):
  266:     c1 = list(random((4,)) + .5)
  267:     c2 = list(random((3,)) + .5)
  268:     p1 = Poly(c1)
  269:     p2 = Poly(c2)
  270:     p3 = p1 * p2
  271:     assert_poly_almost_equal(p2 * p1, p3)
  272:     assert_poly_almost_equal(p1 * c2, p3)
  273:     assert_poly_almost_equal(c2 * p1, p3)
  274:     assert_poly_almost_equal(p1 * tuple(c2), p3)
  275:     assert_poly_almost_equal(tuple(c2) * p1, p3)
  276:     assert_poly_almost_equal(p1 * np.array(c2), p3)
  277:     assert_poly_almost_equal(np.array(c2) * p1, p3)
  278:     assert_poly_almost_equal(p1 * 2, p1 * Poly([2]))
  279:     assert_poly_almost_equal(2 * p1, p1 * Poly([2]))
  280:     assert_raises(TypeError, op.mul, p1, Poly([0], domain=Poly.domain + 1))
  281:     assert_raises(TypeError, op.mul, p1, Poly([0], window=Poly.window + 1))
  282:     if Poly is Polynomial:
  283:         assert_raises(TypeError, op.mul, p1, Chebyshev([0]))
  284:     else:
  285:         assert_raises(TypeError, op.mul, p1, Polynomial([0]))
  286: 
  287: 
  288: def test_floordiv(Poly):
  289:     c1 = list(random((4,)) + .5)
  290:     c2 = list(random((3,)) + .5)
  291:     c3 = list(random((2,)) + .5)
  292:     p1 = Poly(c1)
  293:     p2 = Poly(c2)
  294:     p3 = Poly(c3)
  295:     p4 = p1 * p2 + p3
  296:     c4 = list(p4.coef)
  297:     assert_poly_almost_equal(p4 // p2, p1)
  298:     assert_poly_almost_equal(p4 // c2, p1)
  299:     assert_poly_almost_equal(c4 // p2, p1)
  300:     assert_poly_almost_equal(p4 // tuple(c2), p1)
  301:     assert_poly_almost_equal(tuple(c4) // p2, p1)
  302:     assert_poly_almost_equal(p4 // np.array(c2), p1)
  303:     assert_poly_almost_equal(np.array(c4) // p2, p1)
  304:     assert_poly_almost_equal(2 // p2, Poly([0]))
  305:     assert_poly_almost_equal(p2 // 2, 0.5 * p2)
  306:     assert_raises(
  307:         TypeError, op.floordiv, p1, Poly([0], domain=Poly.domain + 1))
  308:     assert_raises(
  309:         TypeError, op.floordiv, p1, Poly([0], window=Poly.window + 1))
  310:     if Poly is Polynomial:
  311:         assert_raises(TypeError, op.floordiv, p1, Chebyshev([0]))
  312:     else:
  313:         assert_raises(TypeError, op.floordiv, p1, Polynomial([0]))
  314: 
  315: 
  316: def test_truediv(Poly):
  317:     # true division is valid only if the denominator is a Number and
  318:     # not a python bool.
  319:     p1 = Poly([1, 2, 3])
  320:     p2 = p1 * 5
  321: 
  322:     for stype in np.ScalarType:
  323:         if not issubclass(stype, Number) or issubclass(stype, bool):
  324:             continue
  325:         s = stype(5)
  326:         assert_poly_almost_equal(op.truediv(p2, s), p1)
  327:         assert_raises(TypeError, op.truediv, s, p2)
  328:     for stype in (int, float):
  329:         s = stype(5)
  330:         assert_poly_almost_equal(op.truediv(p2, s), p1)
  331:         assert_raises(TypeError, op.truediv, s, p2)
  332:     for stype in [complex]:
  333:         s = stype(5, 0)
  334:         assert_poly_almost_equal(op.truediv(p2, s), p1)
  335:         assert_raises(TypeError, op.truediv, s, p2)
  336:     for s in [(), [], {}, False, np.array([1])]:
  337:         assert_raises(TypeError, op.truediv, p2, s)
  338:         assert_raises(TypeError, op.truediv, s, p2)
  339:     for ptype in classes:
  340:         assert_raises(TypeError, op.truediv, p2, ptype(1))
  341: 
  342: 
  343: def test_mod(Poly):
  344:     # This checks commutation, not numerical correctness
  345:     c1 = list(random((4,)) + .5)
  346:     c2 = list(random((3,)) + .5)
  347:     c3 = list(random((2,)) + .5)
  348:     p1 = Poly(c1)
  349:     p2 = Poly(c2)
  350:     p3 = Poly(c3)
  351:     p4 = p1 * p2 + p3
  352:     c4 = list(p4.coef)
  353:     assert_poly_almost_equal(p4 % p2, p3)
  354:     assert_poly_almost_equal(p4 % c2, p3)
  355:     assert_poly_almost_equal(c4 % p2, p3)
  356:     assert_poly_almost_equal(p4 % tuple(c2), p3)
  357:     assert_poly_almost_equal(tuple(c4) % p2, p3)
  358:     assert_poly_almost_equal(p4 % np.array(c2), p3)
  359:     assert_poly_almost_equal(np.array(c4) % p2, p3)
  360:     assert_poly_almost_equal(2 % p2, Poly([2]))
  361:     assert_poly_almost_equal(p2 % 2, Poly([0]))
  362:     assert_raises(TypeError, op.mod, p1, Poly([0], domain=Poly.domain + 1))
  363:     assert_raises(TypeError, op.mod, p1, Poly([0], window=Poly.window + 1))
  364:     if Poly is Polynomial:
  365:         assert_raises(TypeError, op.mod, p1, Chebyshev([0]))
  366:     else:
  367:         assert_raises(TypeError, op.mod, p1, Polynomial([0]))
  368: 
  369: 
  370: def test_divmod(Poly):
  371:     # This checks commutation, not numerical correctness
  372:     c1 = list(random((4,)) + .5)
  373:     c2 = list(random((3,)) + .5)
  374:     c3 = list(random((2,)) + .5)
  375:     p1 = Poly(c1)
  376:     p2 = Poly(c2)
  377:     p3 = Poly(c3)
  378:     p4 = p1 * p2 + p3
  379:     c4 = list(p4.coef)
  380:     quo, rem = divmod(p4, p2)
  381:     assert_poly_almost_equal(quo, p1)
  382:     assert_poly_almost_equal(rem, p3)
  383:     quo, rem = divmod(p4, c2)
  384:     assert_poly_almost_equal(quo, p1)
  385:     assert_poly_almost_equal(rem, p3)
  386:     quo, rem = divmod(c4, p2)
  387:     assert_poly_almost_equal(quo, p1)
  388:     assert_poly_almost_equal(rem, p3)
  389:     quo, rem = divmod(p4, tuple(c2))
  390:     assert_poly_almost_equal(quo, p1)
  391:     assert_poly_almost_equal(rem, p3)
  392:     quo, rem = divmod(tuple(c4), p2)
  393:     assert_poly_almost_equal(quo, p1)
  394:     assert_poly_almost_equal(rem, p3)
  395:     quo, rem = divmod(p4, np.array(c2))
  396:     assert_poly_almost_equal(quo, p1)
  397:     assert_poly_almost_equal(rem, p3)
  398:     quo, rem = divmod(np.array(c4), p2)
  399:     assert_poly_almost_equal(quo, p1)
  400:     assert_poly_almost_equal(rem, p3)
  401:     quo, rem = divmod(p2, 2)
  402:     assert_poly_almost_equal(quo, 0.5 * p2)
  403:     assert_poly_almost_equal(rem, Poly([0]))
  404:     quo, rem = divmod(2, p2)
  405:     assert_poly_almost_equal(quo, Poly([0]))
  406:     assert_poly_almost_equal(rem, Poly([2]))
  407:     assert_raises(TypeError, divmod, p1, Poly([0], domain=Poly.domain + 1))
  408:     assert_raises(TypeError, divmod, p1, Poly([0], window=Poly.window + 1))
  409:     if Poly is Polynomial:
  410:         assert_raises(TypeError, divmod, p1, Chebyshev([0]))
  411:     else:
  412:         assert_raises(TypeError, divmod, p1, Polynomial([0]))
  413: 
  414: 
  415: def test_roots(Poly):
  416:     d = Poly.domain * 1.25 + .25
  417:     w = Poly.window
  418:     tgt = np.linspace(d[0], d[1], 5)
  419:     res = np.sort(Poly.fromroots(tgt, domain=d, window=w).roots())
  420:     assert_almost_equal(res, tgt)
  421:     # default domain and window
  422:     res = np.sort(Poly.fromroots(tgt).roots())
  423:     assert_almost_equal(res, tgt)
  424: 
  425: 
  426: def test_degree(Poly):
  427:     p = Poly.basis(5)
  428:     assert_equal(p.degree(), 5)
  429: 
  430: 
  431: def test_copy(Poly):
  432:     p1 = Poly.basis(5)
  433:     p2 = p1.copy()
  434:     assert_(p1 == p2)
  435:     assert_(p1 is not p2)
  436:     assert_(p1.coef is not p2.coef)
  437:     assert_(p1.domain is not p2.domain)
  438:     assert_(p1.window is not p2.window)
  439: 
  440: 
  441: def test_integ(Poly):
  442:     P = Polynomial
  443:     # Check defaults
  444:     p0 = Poly.cast(P([1 * 2, 2 * 3, 3 * 4]))
  445:     p1 = P.cast(p0.integ())
  446:     p2 = P.cast(p0.integ(2))
  447:     assert_poly_almost_equal(p1, P([0, 2, 3, 4]))
  448:     assert_poly_almost_equal(p2, P([0, 0, 1, 1, 1]))
  449:     # Check with k
  450:     p0 = Poly.cast(P([1 * 2, 2 * 3, 3 * 4]))
  451:     p1 = P.cast(p0.integ(k=1))
  452:     p2 = P.cast(p0.integ(2, k=[1, 1]))
  453:     assert_poly_almost_equal(p1, P([1, 2, 3, 4]))
  454:     assert_poly_almost_equal(p2, P([1, 1, 1, 1, 1]))
  455:     # Check with lbnd
  456:     p0 = Poly.cast(P([1 * 2, 2 * 3, 3 * 4]))
  457:     p1 = P.cast(p0.integ(lbnd=1))
  458:     p2 = P.cast(p0.integ(2, lbnd=1))
  459:     assert_poly_almost_equal(p1, P([-9, 2, 3, 4]))
  460:     assert_poly_almost_equal(p2, P([6, -9, 1, 1, 1]))
  461:     # Check scaling
  462:     d = 2 * Poly.domain
  463:     p0 = Poly.cast(P([1 * 2, 2 * 3, 3 * 4]), domain=d)
  464:     p1 = P.cast(p0.integ())
  465:     p2 = P.cast(p0.integ(2))
  466:     assert_poly_almost_equal(p1, P([0, 2, 3, 4]))
  467:     assert_poly_almost_equal(p2, P([0, 0, 1, 1, 1]))
  468: 
  469: 
  470: def test_deriv(Poly):
  471:     # Check that the derivative is the inverse of integration. It is
  472:     # assumes that the integration has been checked elsewhere.
  473:     d = Poly.domain + random((2,)) * .25
  474:     w = Poly.window + random((2,)) * .25
  475:     p1 = Poly([1, 2, 3], domain=d, window=w)
  476:     p2 = p1.integ(2, k=[1, 2])
  477:     p3 = p1.integ(1, k=[1])
  478:     assert_almost_equal(p2.deriv(1).coef, p3.coef)
  479:     assert_almost_equal(p2.deriv(2).coef, p1.coef)
  480:     # default domain and window
  481:     p1 = Poly([1, 2, 3])
  482:     p2 = p1.integ(2, k=[1, 2])
  483:     p3 = p1.integ(1, k=[1])
  484:     assert_almost_equal(p2.deriv(1).coef, p3.coef)
  485:     assert_almost_equal(p2.deriv(2).coef, p1.coef)
  486: 
  487: 
  488: def test_linspace(Poly):
  489:     d = Poly.domain + random((2,)) * .25
  490:     w = Poly.window + random((2,)) * .25
  491:     p = Poly([1, 2, 3], domain=d, window=w)
  492:     # check default domain
  493:     xtgt = np.linspace(d[0], d[1], 20)
  494:     ytgt = p(xtgt)
  495:     xres, yres = p.linspace(20)
  496:     assert_almost_equal(xres, xtgt)
  497:     assert_almost_equal(yres, ytgt)
  498:     # check specified domain
  499:     xtgt = np.linspace(0, 2, 20)
  500:     ytgt = p(xtgt)
  501:     xres, yres = p.linspace(20, domain=[0, 2])
  502:     assert_almost_equal(xres, xtgt)
  503:     assert_almost_equal(yres, ytgt)
  504: 
  505: 
  506: def test_pow(Poly):
  507:     d = Poly.domain + random((2,)) * .25
  508:     w = Poly.window + random((2,)) * .25
  509:     tgt = Poly([1], domain=d, window=w)
  510:     tst = Poly([1, 2, 3], domain=d, window=w)
  511:     for i in range(5):
  512:         assert_poly_almost_equal(tst**i, tgt)
  513:         tgt = tgt * tst
  514:     # default domain and window
  515:     tgt = Poly([1])
  516:     tst = Poly([1, 2, 3])
  517:     for i in range(5):
  518:         assert_poly_almost_equal(tst**i, tgt)
  519:         tgt = tgt * tst
  520:     # check error for invalid powers
  521:     assert_raises(ValueError, op.pow, tgt, 1.5)
  522:     assert_raises(ValueError, op.pow, tgt, -1)
  523: 
  524: 
  525: def test_call(Poly):
  526:     P = Polynomial
  527:     d = Poly.domain
  528:     x = np.linspace(d[0], d[1], 11)
  529: 
  530:     # Check defaults
  531:     p = Poly.cast(P([1, 2, 3]))
  532:     tgt = 1 + x * (2 + 3 * x)
  533:     res = p(x)
  534:     assert_almost_equal(res, tgt)
  535: 
  536: 
  537: def test_call_with_list(Poly):
  538:     p = Poly([1, 2, 3])
  539:     x = [-1, 0, 2]
  540:     res = p(x)
  541:     assert_equal(res, p(np.array(x)))
  542: 
  543: 
  544: def test_cutdeg(Poly):
  545:     p = Poly([1, 2, 3])
  546:     assert_raises(ValueError, p.cutdeg, .5)
  547:     assert_raises(ValueError, p.cutdeg, -1)
  548:     assert_equal(len(p.cutdeg(3)), 3)
  549:     assert_equal(len(p.cutdeg(2)), 3)
  550:     assert_equal(len(p.cutdeg(1)), 2)
  551:     assert_equal(len(p.cutdeg(0)), 1)
  552: 
  553: 
  554: def test_truncate(Poly):
  555:     p = Poly([1, 2, 3])
  556:     assert_raises(ValueError, p.truncate, .5)
  557:     assert_raises(ValueError, p.truncate, 0)
  558:     assert_equal(len(p.truncate(4)), 3)
  559:     assert_equal(len(p.truncate(3)), 3)
  560:     assert_equal(len(p.truncate(2)), 2)
  561:     assert_equal(len(p.truncate(1)), 1)
  562: 
  563: 
  564: def test_trim(Poly):
  565:     c = [1, 1e-6, 1e-12, 0]
  566:     p = Poly(c)
  567:     assert_equal(p.trim().coef, c[:3])
  568:     assert_equal(p.trim(1e-10).coef, c[:2])
  569:     assert_equal(p.trim(1e-5).coef, c[:1])
  570: 
  571: 
  572: def test_mapparms(Poly):
  573:     # check with defaults. Should be identity.
  574:     d = Poly.domain
  575:     w = Poly.window
  576:     p = Poly([1], domain=d, window=w)
  577:     assert_almost_equal([0, 1], p.mapparms())
  578:     #
  579:     w = 2 * d + 1
  580:     p = Poly([1], domain=d, window=w)
  581:     assert_almost_equal([1, 2], p.mapparms())
  582: 
  583: 
  584: def test_ufunc_override(Poly):
  585:     p = Poly([1, 2, 3])
  586:     x = np.ones(3)
  587:     assert_raises(TypeError, np.add, p, x)
  588:     assert_raises(TypeError, np.add, x, p)
  589: 
  590: 
  591: #
  592: # Test class method that only exists for some classes
  593: #
  594: 
  595: 
  596: class TestInterpolate:
  597: 
  598:     def f(self, x):
  599:         return x * (x - 1) * (x - 2)
  600: 
  601:     def test_raises(self):
  602:         assert_raises(ValueError, Chebyshev.interpolate, self.f, -1)
  603:         assert_raises(TypeError, Chebyshev.interpolate, self.f, 10.)
  604: 
  605:     def test_dimensions(self):
  606:         for deg in range(1, 5):
  607:             assert_(Chebyshev.interpolate(self.f, deg).degree() == deg)
  608: 
  609:     def test_approximation(self):
  610: 
  611:         def powx(x, p):
  612:             return x**p
  613: 
  614:         x = np.linspace(0, 2, 10)
  615:         for deg in range(10):
  616:             for t in range(deg + 1):
  617:                 p = Chebyshev.interpolate(powx, deg, domain=[0, 2], args=(t,))
  618:                 assert_almost_equal(p(x), powx(x, t), decimal=11)
