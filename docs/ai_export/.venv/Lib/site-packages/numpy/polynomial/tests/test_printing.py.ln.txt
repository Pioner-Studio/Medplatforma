    1: from decimal import Decimal
    2: 
    3: # For testing polynomial printing with object arrays
    4: from fractions import Fraction
    5: from math import inf, nan
    6: 
    7: import pytest
    8: 
    9: import numpy.polynomial as poly
   10: from numpy._core import arange, array, printoptions
   11: from numpy.testing import assert_, assert_equal
   12: 
   13: 
   14: class TestStrUnicodeSuperSubscripts:
   15: 
   16:     @pytest.fixture(scope='class', autouse=True)
   17:     def use_unicode(self):
   18:         poly.set_default_printstyle('unicode')
   19: 
   20:     @pytest.mark.parametrize(('inp', 'tgt'), (
   21:         ([1, 2, 3], "1.0 + 2.0В·x + 3.0В·xВІ"),
   22:         ([-1, 0, 3, -1], "-1.0 + 0.0В·x + 3.0В·xВІ - 1.0В·xВі"),
   23:         (arange(12), ("0.0 + 1.0В·x + 2.0В·xВІ + 3.0В·xВі + 4.0В·xвЃґ + 5.0В·xвЃµ + "
   24:                       "6.0В·xвЃ¶ + 7.0В·xвЃ· +\n8.0В·xвЃё + 9.0В·xвЃ№ + 10.0В·xВ№вЃ° + "
   25:                       "11.0В·xВ№В№")),
   26:     ))
   27:     def test_polynomial_str(self, inp, tgt):
   28:         p = poly.Polynomial(inp)
   29:         res = str(p)
   30:         assert_equal(res, tgt)
   31: 
   32:     @pytest.mark.parametrize(('inp', 'tgt'), (
   33:         ([1, 2, 3], "1.0 + 2.0В·Tв‚Ѓ(x) + 3.0В·Tв‚‚(x)"),
   34:         ([-1, 0, 3, -1], "-1.0 + 0.0В·Tв‚Ѓ(x) + 3.0В·Tв‚‚(x) - 1.0В·Tв‚ѓ(x)"),
   35:         (arange(12), ("0.0 + 1.0В·Tв‚Ѓ(x) + 2.0В·Tв‚‚(x) + 3.0В·Tв‚ѓ(x) + 4.0В·Tв‚„(x) + "
   36:                       "5.0В·Tв‚…(x) +\n6.0В·Tв‚†(x) + 7.0В·Tв‚‡(x) + 8.0В·Tв‚€(x) + "
   37:                       "9.0В·Tв‚‰(x) + 10.0В·Tв‚Ѓв‚Ђ(x) + 11.0В·Tв‚Ѓв‚Ѓ(x)")),
   38:     ))
   39:     def test_chebyshev_str(self, inp, tgt):
   40:         res = str(poly.Chebyshev(inp))
   41:         assert_equal(res, tgt)
   42: 
   43:     @pytest.mark.parametrize(('inp', 'tgt'), (
   44:         ([1, 2, 3], "1.0 + 2.0В·Pв‚Ѓ(x) + 3.0В·Pв‚‚(x)"),
   45:         ([-1, 0, 3, -1], "-1.0 + 0.0В·Pв‚Ѓ(x) + 3.0В·Pв‚‚(x) - 1.0В·Pв‚ѓ(x)"),
   46:         (arange(12), ("0.0 + 1.0В·Pв‚Ѓ(x) + 2.0В·Pв‚‚(x) + 3.0В·Pв‚ѓ(x) + 4.0В·Pв‚„(x) + "
   47:                       "5.0В·Pв‚…(x) +\n6.0В·Pв‚†(x) + 7.0В·Pв‚‡(x) + 8.0В·Pв‚€(x) + "
   48:                       "9.0В·Pв‚‰(x) + 10.0В·Pв‚Ѓв‚Ђ(x) + 11.0В·Pв‚Ѓв‚Ѓ(x)")),
   49:     ))
   50:     def test_legendre_str(self, inp, tgt):
   51:         res = str(poly.Legendre(inp))
   52:         assert_equal(res, tgt)
   53: 
   54:     @pytest.mark.parametrize(('inp', 'tgt'), (
   55:         ([1, 2, 3], "1.0 + 2.0В·Hв‚Ѓ(x) + 3.0В·Hв‚‚(x)"),
   56:         ([-1, 0, 3, -1], "-1.0 + 0.0В·Hв‚Ѓ(x) + 3.0В·Hв‚‚(x) - 1.0В·Hв‚ѓ(x)"),
   57:         (arange(12), ("0.0 + 1.0В·Hв‚Ѓ(x) + 2.0В·Hв‚‚(x) + 3.0В·Hв‚ѓ(x) + 4.0В·Hв‚„(x) + "
   58:                       "5.0В·Hв‚…(x) +\n6.0В·Hв‚†(x) + 7.0В·Hв‚‡(x) + 8.0В·Hв‚€(x) + "
   59:                       "9.0В·Hв‚‰(x) + 10.0В·Hв‚Ѓв‚Ђ(x) + 11.0В·Hв‚Ѓв‚Ѓ(x)")),
   60:     ))
   61:     def test_hermite_str(self, inp, tgt):
   62:         res = str(poly.Hermite(inp))
   63:         assert_equal(res, tgt)
   64: 
   65:     @pytest.mark.parametrize(('inp', 'tgt'), (
   66:         ([1, 2, 3], "1.0 + 2.0В·Heв‚Ѓ(x) + 3.0В·Heв‚‚(x)"),
   67:         ([-1, 0, 3, -1], "-1.0 + 0.0В·Heв‚Ѓ(x) + 3.0В·Heв‚‚(x) - 1.0В·Heв‚ѓ(x)"),
   68:         (arange(12), ("0.0 + 1.0В·Heв‚Ѓ(x) + 2.0В·Heв‚‚(x) + 3.0В·Heв‚ѓ(x) + "
   69:                       "4.0В·Heв‚„(x) + 5.0В·Heв‚…(x) +\n6.0В·Heв‚†(x) + 7.0В·Heв‚‡(x) + "
   70:                       "8.0В·Heв‚€(x) + 9.0В·Heв‚‰(x) + 10.0В·Heв‚Ѓв‚Ђ(x) +\n"
   71:                       "11.0В·Heв‚Ѓв‚Ѓ(x)")),
   72:     ))
   73:     def test_hermiteE_str(self, inp, tgt):
   74:         res = str(poly.HermiteE(inp))
   75:         assert_equal(res, tgt)
   76: 
   77:     @pytest.mark.parametrize(('inp', 'tgt'), (
   78:         ([1, 2, 3], "1.0 + 2.0В·Lв‚Ѓ(x) + 3.0В·Lв‚‚(x)"),
   79:         ([-1, 0, 3, -1], "-1.0 + 0.0В·Lв‚Ѓ(x) + 3.0В·Lв‚‚(x) - 1.0В·Lв‚ѓ(x)"),
   80:         (arange(12), ("0.0 + 1.0В·Lв‚Ѓ(x) + 2.0В·Lв‚‚(x) + 3.0В·Lв‚ѓ(x) + 4.0В·Lв‚„(x) + "
   81:                       "5.0В·Lв‚…(x) +\n6.0В·Lв‚†(x) + 7.0В·Lв‚‡(x) + 8.0В·Lв‚€(x) + "
   82:                       "9.0В·Lв‚‰(x) + 10.0В·Lв‚Ѓв‚Ђ(x) + 11.0В·Lв‚Ѓв‚Ѓ(x)")),
   83:     ))
   84:     def test_laguerre_str(self, inp, tgt):
   85:         res = str(poly.Laguerre(inp))
   86:         assert_equal(res, tgt)
   87: 
   88:     def test_polynomial_str_domains(self):
   89:         res = str(poly.Polynomial([0, 1]))
   90:         tgt = '0.0 + 1.0В·x'
   91:         assert_equal(res, tgt)
   92: 
   93:         res = str(poly.Polynomial([0, 1], domain=[1, 2]))
   94:         tgt = '0.0 + 1.0В·(-3.0 + 2.0x)'
   95:         assert_equal(res, tgt)
   96: 
   97: class TestStrAscii:
   98: 
   99:     @pytest.fixture(scope='class', autouse=True)
  100:     def use_ascii(self):
  101:         poly.set_default_printstyle('ascii')
  102: 
  103:     @pytest.mark.parametrize(('inp', 'tgt'), (
  104:         ([1, 2, 3], "1.0 + 2.0 x + 3.0 x**2"),
  105:         ([-1, 0, 3, -1], "-1.0 + 0.0 x + 3.0 x**2 - 1.0 x**3"),
  106:         (arange(12), ("0.0 + 1.0 x + 2.0 x**2 + 3.0 x**3 + 4.0 x**4 + "
  107:                       "5.0 x**5 + 6.0 x**6 +\n7.0 x**7 + 8.0 x**8 + "
  108:                       "9.0 x**9 + 10.0 x**10 + 11.0 x**11")),
  109:     ))
  110:     def test_polynomial_str(self, inp, tgt):
  111:         res = str(poly.Polynomial(inp))
  112:         assert_equal(res, tgt)
  113: 
  114:     @pytest.mark.parametrize(('inp', 'tgt'), (
  115:         ([1, 2, 3], "1.0 + 2.0 T_1(x) + 3.0 T_2(x)"),
  116:         ([-1, 0, 3, -1], "-1.0 + 0.0 T_1(x) + 3.0 T_2(x) - 1.0 T_3(x)"),
  117:         (arange(12), ("0.0 + 1.0 T_1(x) + 2.0 T_2(x) + 3.0 T_3(x) + "
  118:                       "4.0 T_4(x) + 5.0 T_5(x) +\n6.0 T_6(x) + 7.0 T_7(x) + "
  119:                       "8.0 T_8(x) + 9.0 T_9(x) + 10.0 T_10(x) +\n"
  120:                       "11.0 T_11(x)")),
  121:     ))
  122:     def test_chebyshev_str(self, inp, tgt):
  123:         res = str(poly.Chebyshev(inp))
  124:         assert_equal(res, tgt)
  125: 
  126:     @pytest.mark.parametrize(('inp', 'tgt'), (
  127:         ([1, 2, 3], "1.0 + 2.0 P_1(x) + 3.0 P_2(x)"),
  128:         ([-1, 0, 3, -1], "-1.0 + 0.0 P_1(x) + 3.0 P_2(x) - 1.0 P_3(x)"),
  129:         (arange(12), ("0.0 + 1.0 P_1(x) + 2.0 P_2(x) + 3.0 P_3(x) + "
  130:                       "4.0 P_4(x) + 5.0 P_5(x) +\n6.0 P_6(x) + 7.0 P_7(x) + "
  131:                       "8.0 P_8(x) + 9.0 P_9(x) + 10.0 P_10(x) +\n"
  132:                       "11.0 P_11(x)")),
  133:     ))
  134:     def test_legendre_str(self, inp, tgt):
  135:         res = str(poly.Legendre(inp))
  136:         assert_equal(res, tgt)
  137: 
  138:     @pytest.mark.parametrize(('inp', 'tgt'), (
  139:         ([1, 2, 3], "1.0 + 2.0 H_1(x) + 3.0 H_2(x)"),
  140:         ([-1, 0, 3, -1], "-1.0 + 0.0 H_1(x) + 3.0 H_2(x) - 1.0 H_3(x)"),
  141:         (arange(12), ("0.0 + 1.0 H_1(x) + 2.0 H_2(x) + 3.0 H_3(x) + "
  142:                       "4.0 H_4(x) + 5.0 H_5(x) +\n6.0 H_6(x) + 7.0 H_7(x) + "
  143:                       "8.0 H_8(x) + 9.0 H_9(x) + 10.0 H_10(x) +\n"
  144:                       "11.0 H_11(x)")),
  145:     ))
  146:     def test_hermite_str(self, inp, tgt):
  147:         res = str(poly.Hermite(inp))
  148:         assert_equal(res, tgt)
  149: 
  150:     @pytest.mark.parametrize(('inp', 'tgt'), (
  151:         ([1, 2, 3], "1.0 + 2.0 He_1(x) + 3.0 He_2(x)"),
  152:         ([-1, 0, 3, -1], "-1.0 + 0.0 He_1(x) + 3.0 He_2(x) - 1.0 He_3(x)"),
  153:         (arange(12), ("0.0 + 1.0 He_1(x) + 2.0 He_2(x) + 3.0 He_3(x) + "
  154:                       "4.0 He_4(x) +\n5.0 He_5(x) + 6.0 He_6(x) + "
  155:                       "7.0 He_7(x) + 8.0 He_8(x) + 9.0 He_9(x) +\n"
  156:                       "10.0 He_10(x) + 11.0 He_11(x)")),
  157:     ))
  158:     def test_hermiteE_str(self, inp, tgt):
  159:         res = str(poly.HermiteE(inp))
  160:         assert_equal(res, tgt)
  161: 
  162:     @pytest.mark.parametrize(('inp', 'tgt'), (
  163:         ([1, 2, 3], "1.0 + 2.0 L_1(x) + 3.0 L_2(x)"),
  164:         ([-1, 0, 3, -1], "-1.0 + 0.0 L_1(x) + 3.0 L_2(x) - 1.0 L_3(x)"),
  165:         (arange(12), ("0.0 + 1.0 L_1(x) + 2.0 L_2(x) + 3.0 L_3(x) + "
  166:                       "4.0 L_4(x) + 5.0 L_5(x) +\n6.0 L_6(x) + 7.0 L_7(x) + "
  167:                       "8.0 L_8(x) + 9.0 L_9(x) + 10.0 L_10(x) +\n"
  168:                       "11.0 L_11(x)")),
  169:     ))
  170:     def test_laguerre_str(self, inp, tgt):
  171:         res = str(poly.Laguerre(inp))
  172:         assert_equal(res, tgt)
  173: 
  174:     def test_polynomial_str_domains(self):
  175:         res = str(poly.Polynomial([0, 1]))
  176:         tgt = '0.0 + 1.0 x'
  177:         assert_equal(res, tgt)
  178: 
  179:         res = str(poly.Polynomial([0, 1], domain=[1, 2]))
  180:         tgt = '0.0 + 1.0 (-3.0 + 2.0x)'
  181:         assert_equal(res, tgt)
  182: 
  183: class TestLinebreaking:
  184: 
  185:     @pytest.fixture(scope='class', autouse=True)
  186:     def use_ascii(self):
  187:         poly.set_default_printstyle('ascii')
  188: 
  189:     def test_single_line_one_less(self):
  190:         # With 'ascii' style, len(str(p)) is default linewidth - 1 (i.e. 74)
  191:         p = poly.Polynomial([12345678, 12345678, 12345678, 12345678, 123])
  192:         assert_equal(len(str(p)), 74)
  193:         assert_equal(str(p), (
  194:             '12345678.0 + 12345678.0 x + 12345678.0 x**2 + '
  195:             '12345678.0 x**3 + 123.0 x**4'
  196:         ))
  197: 
  198:     def test_num_chars_is_linewidth(self):
  199:         # len(str(p)) == default linewidth == 75
  200:         p = poly.Polynomial([12345678, 12345678, 12345678, 12345678, 1234])
  201:         assert_equal(len(str(p)), 75)
  202:         assert_equal(str(p), (
  203:             '12345678.0 + 12345678.0 x + 12345678.0 x**2 + '
  204:             '12345678.0 x**3 +\n1234.0 x**4'
  205:         ))
  206: 
  207:     def test_first_linebreak_multiline_one_less_than_linewidth(self):
  208:         # Multiline str where len(first_line) + len(next_term) == lw - 1 == 74
  209:         p = poly.Polynomial(
  210:                 [12345678, 12345678, 12345678, 12345678, 1, 12345678]
  211:             )
  212:         assert_equal(len(str(p).split('\n')[0]), 74)
  213:         assert_equal(str(p), (
  214:             '12345678.0 + 12345678.0 x + 12345678.0 x**2 + '
  215:             '12345678.0 x**3 + 1.0 x**4 +\n12345678.0 x**5'
  216:         ))
  217: 
  218:     def test_first_linebreak_multiline_on_linewidth(self):
  219:         # First line is one character longer than previous test
  220:         p = poly.Polynomial(
  221:                 [12345678, 12345678, 12345678, 12345678.12, 1, 12345678]
  222:             )
  223:         assert_equal(str(p), (
  224:             '12345678.0 + 12345678.0 x + 12345678.0 x**2 + '
  225:             '12345678.12 x**3 +\n1.0 x**4 + 12345678.0 x**5'
  226:         ))
  227: 
  228:     @pytest.mark.parametrize(('lw', 'tgt'), (
  229:         (75, ('0.0 + 10.0 x + 200.0 x**2 + 3000.0 x**3 + 40000.0 x**4 + '
  230:               '500000.0 x**5 +\n600000.0 x**6 + 70000.0 x**7 + 8000.0 x**8 + '
  231:               '900.0 x**9')),
  232:         (45, ('0.0 + 10.0 x + 200.0 x**2 + 3000.0 x**3 +\n40000.0 x**4 + '
  233:               '500000.0 x**5 +\n600000.0 x**6 + 70000.0 x**7 + 8000.0 x**8 +\n'
  234:               '900.0 x**9')),
  235:         (132, ('0.0 + 10.0 x + 200.0 x**2 + 3000.0 x**3 + 40000.0 x**4 + '
  236:                '500000.0 x**5 + 600000.0 x**6 + 70000.0 x**7 + 8000.0 x**8 + '
  237:                '900.0 x**9')),
  238:     ))
  239:     def test_linewidth_printoption(self, lw, tgt):
  240:         p = poly.Polynomial(
  241:             [0, 10, 200, 3000, 40000, 500000, 600000, 70000, 8000, 900]
  242:         )
  243:         with printoptions(linewidth=lw):
  244:             assert_equal(str(p), tgt)
  245:             for line in str(p).split('\n'):
  246:                 assert_(len(line) < lw)
  247: 
  248: 
  249: def test_set_default_printoptions():
  250:     p = poly.Polynomial([1, 2, 3])
  251:     c = poly.Chebyshev([1, 2, 3])
  252:     poly.set_default_printstyle('ascii')
  253:     assert_equal(str(p), "1.0 + 2.0 x + 3.0 x**2")
  254:     assert_equal(str(c), "1.0 + 2.0 T_1(x) + 3.0 T_2(x)")
  255:     poly.set_default_printstyle('unicode')
  256:     assert_equal(str(p), "1.0 + 2.0В·x + 3.0В·xВІ")
  257:     assert_equal(str(c), "1.0 + 2.0В·Tв‚Ѓ(x) + 3.0В·Tв‚‚(x)")
  258:     with pytest.raises(ValueError):
  259:         poly.set_default_printstyle('invalid_input')
  260: 
  261: 
  262: def test_complex_coefficients():
  263:     """Test both numpy and built-in complex."""
  264:     coefs = [0 + 1j, 1 + 1j, -2 + 2j, 3 + 0j]
  265:     # numpy complex
  266:     p1 = poly.Polynomial(coefs)
  267:     # Python complex
  268:     p2 = poly.Polynomial(array(coefs, dtype=object))
  269:     poly.set_default_printstyle('unicode')
  270:     assert_equal(str(p1), "1j + (1+1j)В·x - (2-2j)В·xВІ + (3+0j)В·xВі")
  271:     assert_equal(str(p2), "1j + (1+1j)В·x + (-2+2j)В·xВІ + (3+0j)В·xВі")
  272:     poly.set_default_printstyle('ascii')
  273:     assert_equal(str(p1), "1j + (1+1j) x - (2-2j) x**2 + (3+0j) x**3")
  274:     assert_equal(str(p2), "1j + (1+1j) x + (-2+2j) x**2 + (3+0j) x**3")
  275: 
  276: 
  277: @pytest.mark.parametrize(('coefs', 'tgt'), (
  278:     (array([Fraction(1, 2), Fraction(3, 4)], dtype=object), (
  279:         "1/2 + 3/4В·x"
  280:     )),
  281:     (array([1, 2, Fraction(5, 7)], dtype=object), (
  282:         "1 + 2В·x + 5/7В·xВІ"
  283:     )),
  284:     (array([Decimal('1.00'), Decimal('2.2'), 3], dtype=object), (
  285:         "1.00 + 2.2В·x + 3В·xВІ"
  286:     )),
  287: ))
  288: def test_numeric_object_coefficients(coefs, tgt):
  289:     p = poly.Polynomial(coefs)
  290:     poly.set_default_printstyle('unicode')
  291:     assert_equal(str(p), tgt)
  292: 
  293: 
  294: @pytest.mark.parametrize(('coefs', 'tgt'), (
  295:     (array([1, 2, 'f'], dtype=object), '1 + 2В·x + fВ·xВІ'),
  296:     (array([1, 2, [3, 4]], dtype=object), '1 + 2В·x + [3, 4]В·xВІ'),
  297: ))
  298: def test_nonnumeric_object_coefficients(coefs, tgt):
  299:     """
  300:     Test coef fallback for object arrays of non-numeric coefficients.
  301:     """
  302:     p = poly.Polynomial(coefs)
  303:     poly.set_default_printstyle('unicode')
  304:     assert_equal(str(p), tgt)
  305: 
  306: 
  307: class TestFormat:
  308:     def test_format_unicode(self):
  309:         poly.set_default_printstyle('ascii')
  310:         p = poly.Polynomial([1, 2, 0, -1])
  311:         assert_equal(format(p, 'unicode'), "1.0 + 2.0В·x + 0.0В·xВІ - 1.0В·xВі")
  312: 
  313:     def test_format_ascii(self):
  314:         poly.set_default_printstyle('unicode')
  315:         p = poly.Polynomial([1, 2, 0, -1])
  316:         assert_equal(
  317:             format(p, 'ascii'), "1.0 + 2.0 x + 0.0 x**2 - 1.0 x**3"
  318:         )
  319: 
  320:     def test_empty_formatstr(self):
  321:         poly.set_default_printstyle('ascii')
  322:         p = poly.Polynomial([1, 2, 3])
  323:         assert_equal(format(p), "1.0 + 2.0 x + 3.0 x**2")
  324:         assert_equal(f"{p}", "1.0 + 2.0 x + 3.0 x**2")
  325: 
  326:     def test_bad_formatstr(self):
  327:         p = poly.Polynomial([1, 2, 0, -1])
  328:         with pytest.raises(ValueError):
  329:             format(p, '.2f')
  330: 
  331: 
  332: @pytest.mark.parametrize(('poly', 'tgt'), (
  333:     (poly.Polynomial, '1.0 + 2.0В·z + 3.0В·zВІ'),
  334:     (poly.Chebyshev, '1.0 + 2.0В·Tв‚Ѓ(z) + 3.0В·Tв‚‚(z)'),
  335:     (poly.Hermite, '1.0 + 2.0В·Hв‚Ѓ(z) + 3.0В·Hв‚‚(z)'),
  336:     (poly.HermiteE, '1.0 + 2.0В·Heв‚Ѓ(z) + 3.0В·Heв‚‚(z)'),
  337:     (poly.Laguerre, '1.0 + 2.0В·Lв‚Ѓ(z) + 3.0В·Lв‚‚(z)'),
  338:     (poly.Legendre, '1.0 + 2.0В·Pв‚Ѓ(z) + 3.0В·Pв‚‚(z)'),
  339: ))
  340: def test_symbol(poly, tgt):
  341:     p = poly([1, 2, 3], symbol='z')
  342:     assert_equal(f"{p:unicode}", tgt)
  343: 
  344: 
  345: class TestRepr:
  346:     def test_polynomial_repr(self):
  347:         res = repr(poly.Polynomial([0, 1]))
  348:         tgt = (
  349:             "Polynomial([0., 1.], domain=[-1.,  1.], window=[-1.,  1.], "
  350:             "symbol='x')"
  351:         )
  352:         assert_equal(res, tgt)
  353: 
  354:     def test_chebyshev_repr(self):
  355:         res = repr(poly.Chebyshev([0, 1]))
  356:         tgt = (
  357:             "Chebyshev([0., 1.], domain=[-1.,  1.], window=[-1.,  1.], "
  358:             "symbol='x')"
  359:         )
  360:         assert_equal(res, tgt)
  361: 
  362:     def test_legendre_repr(self):
  363:         res = repr(poly.Legendre([0, 1]))
  364:         tgt = (
  365:             "Legendre([0., 1.], domain=[-1.,  1.], window=[-1.,  1.], "
  366:             "symbol='x')"
  367:         )
  368:         assert_equal(res, tgt)
  369: 
  370:     def test_hermite_repr(self):
  371:         res = repr(poly.Hermite([0, 1]))
  372:         tgt = (
  373:             "Hermite([0., 1.], domain=[-1.,  1.], window=[-1.,  1.], "
  374:             "symbol='x')"
  375:         )
  376:         assert_equal(res, tgt)
  377: 
  378:     def test_hermiteE_repr(self):
  379:         res = repr(poly.HermiteE([0, 1]))
  380:         tgt = (
  381:             "HermiteE([0., 1.], domain=[-1.,  1.], window=[-1.,  1.], "
  382:             "symbol='x')"
  383:         )
  384:         assert_equal(res, tgt)
  385: 
  386:     def test_laguerre_repr(self):
  387:         res = repr(poly.Laguerre([0, 1]))
  388:         tgt = (
  389:             "Laguerre([0., 1.], domain=[0., 1.], window=[0., 1.], "
  390:             "symbol='x')"
  391:         )
  392:         assert_equal(res, tgt)
  393: 
  394: 
  395: class TestLatexRepr:
  396:     """Test the latex repr used by Jupyter"""
  397: 
  398:     @staticmethod
  399:     def as_latex(obj):
  400:         # right now we ignore the formatting of scalars in our tests, since
  401:         # it makes them too verbose. Ideally, the formatting of scalars will
  402:         # be fixed such that tests below continue to pass
  403:         obj._repr_latex_scalar = lambda x, parens=False: str(x)
  404:         try:
  405:             return obj._repr_latex_()
  406:         finally:
  407:             del obj._repr_latex_scalar
  408: 
  409:     def test_simple_polynomial(self):
  410:         # default input
  411:         p = poly.Polynomial([1, 2, 3])
  412:         assert_equal(self.as_latex(p),
  413:             r'$x \mapsto 1.0 + 2.0\,x + 3.0\,x^{2}$')
  414: 
  415:         # translated input
  416:         p = poly.Polynomial([1, 2, 3], domain=[-2, 0])
  417:         assert_equal(self.as_latex(p),
  418:             r'$x \mapsto 1.0 + 2.0\,\left(1.0 + x\right) + 3.0\,\left(1.0 + x\right)^{2}$')  # noqa: E501
  419: 
  420:         # scaled input
  421:         p = poly.Polynomial([1, 2, 3], domain=[-0.5, 0.5])
  422:         assert_equal(self.as_latex(p),
  423:             r'$x \mapsto 1.0 + 2.0\,\left(2.0x\right) + 3.0\,\left(2.0x\right)^{2}$')
  424: 
  425:         # affine input
  426:         p = poly.Polynomial([1, 2, 3], domain=[-1, 0])
  427:         assert_equal(self.as_latex(p),
  428:             r'$x \mapsto 1.0 + 2.0\,\left(1.0 + 2.0x\right) + 3.0\,\left(1.0 + 2.0x\right)^{2}$')  # noqa: E501
  429: 
  430:     def test_basis_func(self):
  431:         p = poly.Chebyshev([1, 2, 3])
  432:         assert_equal(self.as_latex(p),
  433:             r'$x \mapsto 1.0\,{T}_{0}(x) + 2.0\,{T}_{1}(x) + 3.0\,{T}_{2}(x)$')
  434:         # affine input - check no surplus parens are added
  435:         p = poly.Chebyshev([1, 2, 3], domain=[-1, 0])
  436:         assert_equal(self.as_latex(p),
  437:             r'$x \mapsto 1.0\,{T}_{0}(1.0 + 2.0x) + 2.0\,{T}_{1}(1.0 + 2.0x) + 3.0\,{T}_{2}(1.0 + 2.0x)$')  # noqa: E501
  438: 
  439:     def test_multichar_basis_func(self):
  440:         p = poly.HermiteE([1, 2, 3])
  441:         assert_equal(self.as_latex(p),
  442:             r'$x \mapsto 1.0\,{He}_{0}(x) + 2.0\,{He}_{1}(x) + 3.0\,{He}_{2}(x)$')
  443: 
  444:     def test_symbol_basic(self):
  445:         # default input
  446:         p = poly.Polynomial([1, 2, 3], symbol='z')
  447:         assert_equal(self.as_latex(p),
  448:             r'$z \mapsto 1.0 + 2.0\,z + 3.0\,z^{2}$')
  449: 
  450:         # translated input
  451:         p = poly.Polynomial([1, 2, 3], domain=[-2, 0], symbol='z')
  452:         assert_equal(
  453:             self.as_latex(p),
  454:             (
  455:                 r'$z \mapsto 1.0 + 2.0\,\left(1.0 + z\right) + 3.0\,'
  456:                 r'\left(1.0 + z\right)^{2}$'
  457:             ),
  458:         )
  459: 
  460:         # scaled input
  461:         p = poly.Polynomial([1, 2, 3], domain=[-0.5, 0.5], symbol='z')
  462:         assert_equal(
  463:             self.as_latex(p),
  464:             (
  465:                 r'$z \mapsto 1.0 + 2.0\,\left(2.0z\right) + 3.0\,'
  466:                 r'\left(2.0z\right)^{2}$'
  467:             ),
  468:         )
  469: 
  470:         # affine input
  471:         p = poly.Polynomial([1, 2, 3], domain=[-1, 0], symbol='z')
  472:         assert_equal(
  473:             self.as_latex(p),
  474:             (
  475:                 r'$z \mapsto 1.0 + 2.0\,\left(1.0 + 2.0z\right) + 3.0\,'
  476:                 r'\left(1.0 + 2.0z\right)^{2}$'
  477:             ),
  478:         )
  479: 
  480:     def test_numeric_object_coefficients(self):
  481:         coefs = array([Fraction(1, 2), Fraction(1)])
  482:         p = poly.Polynomial(coefs)
  483:         assert_equal(self.as_latex(p), '$x \\mapsto 1/2 + 1\\,x$')
  484: 
  485: 
  486: SWITCH_TO_EXP = (
  487:     '1.0 + (1.0e-01) x + (1.0e-02) x**2',
  488:     '1.2 + (1.2e-01) x + (1.2e-02) x**2',
  489:     '1.23 + 0.12 x + (1.23e-02) x**2 + (1.23e-03) x**3',
  490:     '1.235 + 0.123 x + (1.235e-02) x**2 + (1.235e-03) x**3',
  491:     '1.2346 + 0.1235 x + 0.0123 x**2 + (1.2346e-03) x**3 + (1.2346e-04) x**4',
  492:     '1.23457 + 0.12346 x + 0.01235 x**2 + (1.23457e-03) x**3 + '
  493:     '(1.23457e-04) x**4',
  494:     '1.234568 + 0.123457 x + 0.012346 x**2 + 0.001235 x**3 + '
  495:     '(1.234568e-04) x**4 + (1.234568e-05) x**5',
  496:     '1.2345679 + 0.1234568 x + 0.0123457 x**2 + 0.0012346 x**3 + '
  497:     '(1.2345679e-04) x**4 + (1.2345679e-05) x**5')
  498: 
  499: class TestPrintOptions:
  500:     """
  501:     Test the output is properly configured via printoptions.
  502:     The exponential notation is enabled automatically when the values
  503:     are too small or too large.
  504:     """
  505: 
  506:     @pytest.fixture(scope='class', autouse=True)
  507:     def use_ascii(self):
  508:         poly.set_default_printstyle('ascii')
  509: 
  510:     def test_str(self):
  511:         p = poly.Polynomial([1 / 2, 1 / 7, 1 / 7 * 10**8, 1 / 7 * 10**9])
  512:         assert_equal(str(p), '0.5 + 0.14285714 x + 14285714.28571429 x**2 '
  513:                              '+ (1.42857143e+08) x**3')
  514: 
  515:         with printoptions(precision=3):
  516:             assert_equal(str(p), '0.5 + 0.143 x + 14285714.286 x**2 '
  517:                                  '+ (1.429e+08) x**3')
  518: 
  519:     def test_latex(self):
  520:         p = poly.Polynomial([1 / 2, 1 / 7, 1 / 7 * 10**8, 1 / 7 * 10**9])
  521:         assert_equal(p._repr_latex_(),
  522:             r'$x \mapsto \text{0.5} + \text{0.14285714}\,x + '
  523:             r'\text{14285714.28571429}\,x^{2} + '
  524:             r'\text{(1.42857143e+08)}\,x^{3}$')
  525: 
  526:         with printoptions(precision=3):
  527:             assert_equal(p._repr_latex_(),
  528:                 r'$x \mapsto \text{0.5} + \text{0.143}\,x + '
  529:                 r'\text{14285714.286}\,x^{2} + \text{(1.429e+08)}\,x^{3}$')
  530: 
  531:     def test_fixed(self):
  532:         p = poly.Polynomial([1 / 2])
  533:         assert_equal(str(p), '0.5')
  534: 
  535:         with printoptions(floatmode='fixed'):
  536:             assert_equal(str(p), '0.50000000')
  537: 
  538:         with printoptions(floatmode='fixed', precision=4):
  539:             assert_equal(str(p), '0.5000')
  540: 
  541:     def test_switch_to_exp(self):
  542:         for i, s in enumerate(SWITCH_TO_EXP):
  543:             with printoptions(precision=i):
  544:                 p = poly.Polynomial([1.23456789 * 10**-i
  545:                                      for i in range(i // 2 + 3)])
  546:                 assert str(p).replace('\n', ' ') == s
  547: 
  548:     def test_non_finite(self):
  549:         p = poly.Polynomial([nan, inf])
  550:         assert str(p) == 'nan + inf x'
  551:         assert p._repr_latex_() == r'$x \mapsto \text{nan} + \text{inf}\,x$'  # noqa: RUF027
  552:         with printoptions(nanstr='NAN', infstr='INF'):
  553:             assert str(p) == 'NAN + INF x'
  554:             assert p._repr_latex_() == \
  555:                 r'$x \mapsto \text{NAN} + \text{INF}\,x$'
