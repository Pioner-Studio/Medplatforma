    1: """Tests for polynomial module.
    2: 
    3: """
    4: import pickle
    5: from copy import deepcopy
    6: from fractions import Fraction
    7: from functools import reduce
    8: 
    9: import numpy as np
   10: import numpy.polynomial.polynomial as poly
   11: import numpy.polynomial.polyutils as pu
   12: from numpy.testing import (
   13:     assert_,
   14:     assert_almost_equal,
   15:     assert_array_equal,
   16:     assert_equal,
   17:     assert_raises,
   18:     assert_raises_regex,
   19:     assert_warns,
   20: )
   21: 
   22: 
   23: def trim(x):
   24:     return poly.polytrim(x, tol=1e-6)
   25: 
   26: 
   27: T0 = [1]
   28: T1 = [0, 1]
   29: T2 = [-1, 0, 2]
   30: T3 = [0, -3, 0, 4]
   31: T4 = [1, 0, -8, 0, 8]
   32: T5 = [0, 5, 0, -20, 0, 16]
   33: T6 = [-1, 0, 18, 0, -48, 0, 32]
   34: T7 = [0, -7, 0, 56, 0, -112, 0, 64]
   35: T8 = [1, 0, -32, 0, 160, 0, -256, 0, 128]
   36: T9 = [0, 9, 0, -120, 0, 432, 0, -576, 0, 256]
   37: 
   38: Tlist = [T0, T1, T2, T3, T4, T5, T6, T7, T8, T9]
   39: 
   40: 
   41: class TestConstants:
   42: 
   43:     def test_polydomain(self):
   44:         assert_equal(poly.polydomain, [-1, 1])
   45: 
   46:     def test_polyzero(self):
   47:         assert_equal(poly.polyzero, [0])
   48: 
   49:     def test_polyone(self):
   50:         assert_equal(poly.polyone, [1])
   51: 
   52:     def test_polyx(self):
   53:         assert_equal(poly.polyx, [0, 1])
   54: 
   55:     def test_copy(self):
   56:         x = poly.Polynomial([1, 2, 3])
   57:         y = deepcopy(x)
   58:         assert_equal(x, y)
   59: 
   60:     def test_pickle(self):
   61:         x = poly.Polynomial([1, 2, 3])
   62:         y = pickle.loads(pickle.dumps(x))
   63:         assert_equal(x, y)
   64: 
   65: class TestArithmetic:
   66: 
   67:     def test_polyadd(self):
   68:         for i in range(5):
   69:             for j in range(5):
   70:                 msg = f"At i={i}, j={j}"
   71:                 tgt = np.zeros(max(i, j) + 1)
   72:                 tgt[i] += 1
   73:                 tgt[j] += 1
   74:                 res = poly.polyadd([0] * i + [1], [0] * j + [1])
   75:                 assert_equal(trim(res), trim(tgt), err_msg=msg)
   76: 
   77:     def test_polysub(self):
   78:         for i in range(5):
   79:             for j in range(5):
   80:                 msg = f"At i={i}, j={j}"
   81:                 tgt = np.zeros(max(i, j) + 1)
   82:                 tgt[i] += 1
   83:                 tgt[j] -= 1
   84:                 res = poly.polysub([0] * i + [1], [0] * j + [1])
   85:                 assert_equal(trim(res), trim(tgt), err_msg=msg)
   86: 
   87:     def test_polymulx(self):
   88:         assert_equal(poly.polymulx([0]), [0])
   89:         assert_equal(poly.polymulx([1]), [0, 1])
   90:         for i in range(1, 5):
   91:             ser = [0] * i + [1]
   92:             tgt = [0] * (i + 1) + [1]
   93:             assert_equal(poly.polymulx(ser), tgt)
   94: 
   95:     def test_polymul(self):
   96:         for i in range(5):
   97:             for j in range(5):
   98:                 msg = f"At i={i}, j={j}"
   99:                 tgt = np.zeros(i + j + 1)
  100:                 tgt[i + j] += 1
  101:                 res = poly.polymul([0] * i + [1], [0] * j + [1])
  102:                 assert_equal(trim(res), trim(tgt), err_msg=msg)
  103: 
  104:     def test_polydiv(self):
  105:         # check zero division
  106:         assert_raises(ZeroDivisionError, poly.polydiv, [1], [0])
  107: 
  108:         # check scalar division
  109:         quo, rem = poly.polydiv([2], [2])
  110:         assert_equal((quo, rem), (1, 0))
  111:         quo, rem = poly.polydiv([2, 2], [2])
  112:         assert_equal((quo, rem), ((1, 1), 0))
  113: 
  114:         # check rest.
  115:         for i in range(5):
  116:             for j in range(5):
  117:                 msg = f"At i={i}, j={j}"
  118:                 ci = [0] * i + [1, 2]
  119:                 cj = [0] * j + [1, 2]
  120:                 tgt = poly.polyadd(ci, cj)
  121:                 quo, rem = poly.polydiv(tgt, ci)
  122:                 res = poly.polyadd(poly.polymul(quo, ci), rem)
  123:                 assert_equal(res, tgt, err_msg=msg)
  124: 
  125:     def test_polypow(self):
  126:         for i in range(5):
  127:             for j in range(5):
  128:                 msg = f"At i={i}, j={j}"
  129:                 c = np.arange(i + 1)
  130:                 tgt = reduce(poly.polymul, [c] * j, np.array([1]))
  131:                 res = poly.polypow(c, j)
  132:                 assert_equal(trim(res), trim(tgt), err_msg=msg)
  133: 
  134: class TestFraction:
  135: 
  136:     def test_Fraction(self):
  137:         # assert we can use Polynomials with coefficients of object dtype
  138:         f = Fraction(2, 3)
  139:         one = Fraction(1, 1)
  140:         zero = Fraction(0, 1)
  141:         p = poly.Polynomial([f, f], domain=[zero, one], window=[zero, one])
  142: 
  143:         x = 2 * p + p ** 2
  144:         assert_equal(x.coef, np.array([Fraction(16, 9), Fraction(20, 9),
  145:                                        Fraction(4, 9)], dtype=object))
  146:         assert_equal(p.domain, [zero, one])
  147:         assert_equal(p.coef.dtype, np.dtypes.ObjectDType())
  148:         assert_(isinstance(p(f), Fraction))
  149:         assert_equal(p(f), Fraction(10, 9))
  150:         p_deriv = poly.Polynomial([Fraction(2, 3)], domain=[zero, one],
  151:                                   window=[zero, one])
  152:         assert_equal(p.deriv(), p_deriv)
  153: 
  154: class TestEvaluation:
  155:     # coefficients of 1 + 2*x + 3*x**2
  156:     c1d = np.array([1., 2., 3.])
  157:     c2d = np.einsum('i,j->ij', c1d, c1d)
  158:     c3d = np.einsum('i,j,k->ijk', c1d, c1d, c1d)
  159: 
  160:     # some random values in [-1, 1)
  161:     x = np.random.random((3, 5)) * 2 - 1
  162:     y = poly.polyval(x, [1., 2., 3.])
  163: 
  164:     def test_polyval(self):
  165:         # check empty input
  166:         assert_equal(poly.polyval([], [1]).size, 0)
  167: 
  168:         # check normal input)
  169:         x = np.linspace(-1, 1)
  170:         y = [x**i for i in range(5)]
  171:         for i in range(5):
  172:             tgt = y[i]
  173:             res = poly.polyval(x, [0] * i + [1])
  174:             assert_almost_equal(res, tgt)
  175:         tgt = x * (x**2 - 1)
  176:         res = poly.polyval(x, [0, -1, 0, 1])
  177:         assert_almost_equal(res, tgt)
  178: 
  179:         # check that shape is preserved
  180:         for i in range(3):
  181:             dims = [2] * i
  182:             x = np.zeros(dims)
  183:             assert_equal(poly.polyval(x, [1]).shape, dims)
  184:             assert_equal(poly.polyval(x, [1, 0]).shape, dims)
  185:             assert_equal(poly.polyval(x, [1, 0, 0]).shape, dims)
  186: 
  187:         # check masked arrays are processed correctly
  188:         mask = [False, True, False]
  189:         mx = np.ma.array([1, 2, 3], mask=mask)
  190:         res = np.polyval([7, 5, 3], mx)
  191:         assert_array_equal(res.mask, mask)
  192: 
  193:         # check subtypes of ndarray are preserved
  194:         class C(np.ndarray):
  195:             pass
  196: 
  197:         cx = np.array([1, 2, 3]).view(C)
  198:         assert_equal(type(np.polyval([2, 3, 4], cx)), C)
  199: 
  200:     def test_polyvalfromroots(self):
  201:         # check exception for broadcasting x values over root array with
  202:         # too few dimensions
  203:         assert_raises(ValueError, poly.polyvalfromroots,
  204:                       [1], [1], tensor=False)
  205: 
  206:         # check empty input
  207:         assert_equal(poly.polyvalfromroots([], [1]).size, 0)
  208:         assert_(poly.polyvalfromroots([], [1]).shape == (0,))
  209: 
  210:         # check empty input + multidimensional roots
  211:         assert_equal(poly.polyvalfromroots([], [[1] * 5]).size, 0)
  212:         assert_(poly.polyvalfromroots([], [[1] * 5]).shape == (5, 0))
  213: 
  214:         # check scalar input
  215:         assert_equal(poly.polyvalfromroots(1, 1), 0)
  216:         assert_(poly.polyvalfromroots(1, np.ones((3, 3))).shape == (3,))
  217: 
  218:         # check normal input)
  219:         x = np.linspace(-1, 1)
  220:         y = [x**i for i in range(5)]
  221:         for i in range(1, 5):
  222:             tgt = y[i]
  223:             res = poly.polyvalfromroots(x, [0] * i)
  224:             assert_almost_equal(res, tgt)
  225:         tgt = x * (x - 1) * (x + 1)
  226:         res = poly.polyvalfromroots(x, [-1, 0, 1])
  227:         assert_almost_equal(res, tgt)
  228: 
  229:         # check that shape is preserved
  230:         for i in range(3):
  231:             dims = [2] * i
  232:             x = np.zeros(dims)
  233:             assert_equal(poly.polyvalfromroots(x, [1]).shape, dims)
  234:             assert_equal(poly.polyvalfromroots(x, [1, 0]).shape, dims)
  235:             assert_equal(poly.polyvalfromroots(x, [1, 0, 0]).shape, dims)
  236: 
  237:         # check compatibility with factorization
  238:         ptest = [15, 2, -16, -2, 1]
  239:         r = poly.polyroots(ptest)
  240:         x = np.linspace(-1, 1)
  241:         assert_almost_equal(poly.polyval(x, ptest),
  242:                             poly.polyvalfromroots(x, r))
  243: 
  244:         # check multidimensional arrays of roots and values
  245:         # check tensor=False
  246:         rshape = (3, 5)
  247:         x = np.arange(-3, 2)
  248:         r = np.random.randint(-5, 5, size=rshape)
  249:         res = poly.polyvalfromroots(x, r, tensor=False)
  250:         tgt = np.empty(r.shape[1:])
  251:         for ii in range(tgt.size):
  252:             tgt[ii] = poly.polyvalfromroots(x[ii], r[:, ii])
  253:         assert_equal(res, tgt)
  254: 
  255:         # check tensor=True
  256:         x = np.vstack([x, 2 * x])
  257:         res = poly.polyvalfromroots(x, r, tensor=True)
  258:         tgt = np.empty(r.shape[1:] + x.shape)
  259:         for ii in range(r.shape[1]):
  260:             for jj in range(x.shape[0]):
  261:                 tgt[ii, jj, :] = poly.polyvalfromroots(x[jj], r[:, ii])
  262:         assert_equal(res, tgt)
  263: 
  264:     def test_polyval2d(self):
  265:         x1, x2, x3 = self.x
  266:         y1, y2, y3 = self.y
  267: 
  268:         # test exceptions
  269:         assert_raises_regex(ValueError, 'incompatible',
  270:                             poly.polyval2d, x1, x2[:2], self.c2d)
  271: 
  272:         # test values
  273:         tgt = y1 * y2
  274:         res = poly.polyval2d(x1, x2, self.c2d)
  275:         assert_almost_equal(res, tgt)
  276: 
  277:         # test shape
  278:         z = np.ones((2, 3))
  279:         res = poly.polyval2d(z, z, self.c2d)
  280:         assert_(res.shape == (2, 3))
  281: 
  282:     def test_polyval3d(self):
  283:         x1, x2, x3 = self.x
  284:         y1, y2, y3 = self.y
  285: 
  286:         # test exceptions
  287:         assert_raises_regex(ValueError, 'incompatible',
  288:                       poly.polyval3d, x1, x2, x3[:2], self.c3d)
  289: 
  290:         # test values
  291:         tgt = y1 * y2 * y3
  292:         res = poly.polyval3d(x1, x2, x3, self.c3d)
  293:         assert_almost_equal(res, tgt)
  294: 
  295:         # test shape
  296:         z = np.ones((2, 3))
  297:         res = poly.polyval3d(z, z, z, self.c3d)
  298:         assert_(res.shape == (2, 3))
  299: 
  300:     def test_polygrid2d(self):
  301:         x1, x2, x3 = self.x
  302:         y1, y2, y3 = self.y
  303: 
  304:         # test values
  305:         tgt = np.einsum('i,j->ij', y1, y2)
  306:         res = poly.polygrid2d(x1, x2, self.c2d)
  307:         assert_almost_equal(res, tgt)
  308: 
  309:         # test shape
  310:         z = np.ones((2, 3))
  311:         res = poly.polygrid2d(z, z, self.c2d)
  312:         assert_(res.shape == (2, 3) * 2)
  313: 
  314:     def test_polygrid3d(self):
  315:         x1, x2, x3 = self.x
  316:         y1, y2, y3 = self.y
  317: 
  318:         # test values
  319:         tgt = np.einsum('i,j,k->ijk', y1, y2, y3)
  320:         res = poly.polygrid3d(x1, x2, x3, self.c3d)
  321:         assert_almost_equal(res, tgt)
  322: 
  323:         # test shape
  324:         z = np.ones((2, 3))
  325:         res = poly.polygrid3d(z, z, z, self.c3d)
  326:         assert_(res.shape == (2, 3) * 3)
  327: 
  328: 
  329: class TestIntegral:
  330: 
  331:     def test_polyint(self):
  332:         # check exceptions
  333:         assert_raises(TypeError, poly.polyint, [0], .5)
  334:         assert_raises(ValueError, poly.polyint, [0], -1)
  335:         assert_raises(ValueError, poly.polyint, [0], 1, [0, 0])
  336:         assert_raises(ValueError, poly.polyint, [0], lbnd=[0])
  337:         assert_raises(ValueError, poly.polyint, [0], scl=[0])
  338:         assert_raises(TypeError, poly.polyint, [0], axis=.5)
  339:         assert_raises(TypeError, poly.polyint, [1, 1], 1.)
  340: 
  341:         # test integration of zero polynomial
  342:         for i in range(2, 5):
  343:             k = [0] * (i - 2) + [1]
  344:             res = poly.polyint([0], m=i, k=k)
  345:             assert_almost_equal(res, [0, 1])
  346: 
  347:         # check single integration with integration constant
  348:         for i in range(5):
  349:             scl = i + 1
  350:             pol = [0] * i + [1]
  351:             tgt = [i] + [0] * i + [1 / scl]
  352:             res = poly.polyint(pol, m=1, k=[i])
  353:             assert_almost_equal(trim(res), trim(tgt))
  354: 
  355:         # check single integration with integration constant and lbnd
  356:         for i in range(5):
  357:             scl = i + 1
  358:             pol = [0] * i + [1]
  359:             res = poly.polyint(pol, m=1, k=[i], lbnd=-1)
  360:             assert_almost_equal(poly.polyval(-1, res), i)
  361: 
  362:         # check single integration with integration constant and scaling
  363:         for i in range(5):
  364:             scl = i + 1
  365:             pol = [0] * i + [1]
  366:             tgt = [i] + [0] * i + [2 / scl]
  367:             res = poly.polyint(pol, m=1, k=[i], scl=2)
  368:             assert_almost_equal(trim(res), trim(tgt))
  369: 
  370:         # check multiple integrations with default k
  371:         for i in range(5):
  372:             for j in range(2, 5):
  373:                 pol = [0] * i + [1]
  374:                 tgt = pol[:]
  375:                 for k in range(j):
  376:                     tgt = poly.polyint(tgt, m=1)
  377:                 res = poly.polyint(pol, m=j)
  378:                 assert_almost_equal(trim(res), trim(tgt))
  379: 
  380:         # check multiple integrations with defined k
  381:         for i in range(5):
  382:             for j in range(2, 5):
  383:                 pol = [0] * i + [1]
  384:                 tgt = pol[:]
  385:                 for k in range(j):
  386:                     tgt = poly.polyint(tgt, m=1, k=[k])
  387:                 res = poly.polyint(pol, m=j, k=list(range(j)))
  388:                 assert_almost_equal(trim(res), trim(tgt))
  389: 
  390:         # check multiple integrations with lbnd
  391:         for i in range(5):
  392:             for j in range(2, 5):
  393:                 pol = [0] * i + [1]
  394:                 tgt = pol[:]
  395:                 for k in range(j):
  396:                     tgt = poly.polyint(tgt, m=1, k=[k], lbnd=-1)
  397:                 res = poly.polyint(pol, m=j, k=list(range(j)), lbnd=-1)
  398:                 assert_almost_equal(trim(res), trim(tgt))
  399: 
  400:         # check multiple integrations with scaling
  401:         for i in range(5):
  402:             for j in range(2, 5):
  403:                 pol = [0] * i + [1]
  404:                 tgt = pol[:]
  405:                 for k in range(j):
  406:                     tgt = poly.polyint(tgt, m=1, k=[k], scl=2)
  407:                 res = poly.polyint(pol, m=j, k=list(range(j)), scl=2)
  408:                 assert_almost_equal(trim(res), trim(tgt))
  409: 
  410:     def test_polyint_axis(self):
  411:         # check that axis keyword works
  412:         c2d = np.random.random((3, 4))
  413: 
  414:         tgt = np.vstack([poly.polyint(c) for c in c2d.T]).T
  415:         res = poly.polyint(c2d, axis=0)
  416:         assert_almost_equal(res, tgt)
  417: 
  418:         tgt = np.vstack([poly.polyint(c) for c in c2d])
  419:         res = poly.polyint(c2d, axis=1)
  420:         assert_almost_equal(res, tgt)
  421: 
  422:         tgt = np.vstack([poly.polyint(c, k=3) for c in c2d])
  423:         res = poly.polyint(c2d, k=3, axis=1)
  424:         assert_almost_equal(res, tgt)
  425: 
  426: 
  427: class TestDerivative:
  428: 
  429:     def test_polyder(self):
  430:         # check exceptions
  431:         assert_raises(TypeError, poly.polyder, [0], .5)
  432:         assert_raises(ValueError, poly.polyder, [0], -1)
  433: 
  434:         # check that zeroth derivative does nothing
  435:         for i in range(5):
  436:             tgt = [0] * i + [1]
  437:             res = poly.polyder(tgt, m=0)
  438:             assert_equal(trim(res), trim(tgt))
  439: 
  440:         # check that derivation is the inverse of integration
  441:         for i in range(5):
  442:             for j in range(2, 5):
  443:                 tgt = [0] * i + [1]
  444:                 res = poly.polyder(poly.polyint(tgt, m=j), m=j)
  445:                 assert_almost_equal(trim(res), trim(tgt))
  446: 
  447:         # check derivation with scaling
  448:         for i in range(5):
  449:             for j in range(2, 5):
  450:                 tgt = [0] * i + [1]
  451:                 res = poly.polyder(poly.polyint(tgt, m=j, scl=2), m=j, scl=.5)
  452:                 assert_almost_equal(trim(res), trim(tgt))
  453: 
  454:     def test_polyder_axis(self):
  455:         # check that axis keyword works
  456:         c2d = np.random.random((3, 4))
  457: 
  458:         tgt = np.vstack([poly.polyder(c) for c in c2d.T]).T
  459:         res = poly.polyder(c2d, axis=0)
  460:         assert_almost_equal(res, tgt)
  461: 
  462:         tgt = np.vstack([poly.polyder(c) for c in c2d])
  463:         res = poly.polyder(c2d, axis=1)
  464:         assert_almost_equal(res, tgt)
  465: 
  466: 
  467: class TestVander:
  468:     # some random values in [-1, 1)
  469:     x = np.random.random((3, 5)) * 2 - 1
  470: 
  471:     def test_polyvander(self):
  472:         # check for 1d x
  473:         x = np.arange(3)
  474:         v = poly.polyvander(x, 3)
  475:         assert_(v.shape == (3, 4))
  476:         for i in range(4):
  477:             coef = [0] * i + [1]
  478:             assert_almost_equal(v[..., i], poly.polyval(x, coef))
  479: 
  480:         # check for 2d x
  481:         x = np.array([[1, 2], [3, 4], [5, 6]])
  482:         v = poly.polyvander(x, 3)
  483:         assert_(v.shape == (3, 2, 4))
  484:         for i in range(4):
  485:             coef = [0] * i + [1]
  486:             assert_almost_equal(v[..., i], poly.polyval(x, coef))
  487: 
  488:     def test_polyvander2d(self):
  489:         # also tests polyval2d for non-square coefficient array
  490:         x1, x2, x3 = self.x
  491:         c = np.random.random((2, 3))
  492:         van = poly.polyvander2d(x1, x2, [1, 2])
  493:         tgt = poly.polyval2d(x1, x2, c)
  494:         res = np.dot(van, c.flat)
  495:         assert_almost_equal(res, tgt)
  496: 
  497:         # check shape
  498:         van = poly.polyvander2d([x1], [x2], [1, 2])
  499:         assert_(van.shape == (1, 5, 6))
  500: 
  501:     def test_polyvander3d(self):
  502:         # also tests polyval3d for non-square coefficient array
  503:         x1, x2, x3 = self.x
  504:         c = np.random.random((2, 3, 4))
  505:         van = poly.polyvander3d(x1, x2, x3, [1, 2, 3])
  506:         tgt = poly.polyval3d(x1, x2, x3, c)
  507:         res = np.dot(van, c.flat)
  508:         assert_almost_equal(res, tgt)
  509: 
  510:         # check shape
  511:         van = poly.polyvander3d([x1], [x2], [x3], [1, 2, 3])
  512:         assert_(van.shape == (1, 5, 24))
  513: 
  514:     def test_polyvandernegdeg(self):
  515:         x = np.arange(3)
  516:         assert_raises(ValueError, poly.polyvander, x, -1)
  517: 
  518: 
  519: class TestCompanion:
  520: 
  521:     def test_raises(self):
  522:         assert_raises(ValueError, poly.polycompanion, [])
  523:         assert_raises(ValueError, poly.polycompanion, [1])
  524: 
  525:     def test_dimensions(self):
  526:         for i in range(1, 5):
  527:             coef = [0] * i + [1]
  528:             assert_(poly.polycompanion(coef).shape == (i, i))
  529: 
  530:     def test_linear_root(self):
  531:         assert_(poly.polycompanion([1, 2])[0, 0] == -.5)
  532: 
  533: 
  534: class TestMisc:
  535: 
  536:     def test_polyfromroots(self):
  537:         res = poly.polyfromroots([])
  538:         assert_almost_equal(trim(res), [1])
  539:         for i in range(1, 5):
  540:             roots = np.cos(np.linspace(-np.pi, 0, 2 * i + 1)[1::2])
  541:             tgt = Tlist[i]
  542:             res = poly.polyfromroots(roots) * 2**(i - 1)
  543:             assert_almost_equal(trim(res), trim(tgt))
  544: 
  545:     def test_polyroots(self):
  546:         assert_almost_equal(poly.polyroots([1]), [])
  547:         assert_almost_equal(poly.polyroots([1, 2]), [-.5])
  548:         for i in range(2, 5):
  549:             tgt = np.linspace(-1, 1, i)
  550:             res = poly.polyroots(poly.polyfromroots(tgt))
  551:             assert_almost_equal(trim(res), trim(tgt))
  552: 
  553:         # Testing for larger root values
  554:         for i in np.logspace(10, 25, num=1000, base=10):
  555:             tgt = np.array([-1, 1, i])
  556:             res = poly.polyroots(poly.polyfromroots(tgt))
  557:             # Adapting the expected precision according to the root value,
  558:             # to take into account numerical calculation error.
  559:             assert_almost_equal(res, tgt, 15 - int(np.log10(i)))
  560:         for i in np.logspace(10, 25, num=1000, base=10):
  561:             tgt = np.array([-1, 1.01, i])
  562:             res = poly.polyroots(poly.polyfromroots(tgt))
  563:             # Adapting the expected precision according to the root value,
  564:             # to take into account numerical calculation error.
  565:             assert_almost_equal(res, tgt, 14 - int(np.log10(i)))
  566: 
  567:     def test_polyfit(self):
  568:         def f(x):
  569:             return x * (x - 1) * (x - 2)
  570: 
  571:         def f2(x):
  572:             return x**4 + x**2 + 1
  573: 
  574:         # Test exceptions
  575:         assert_raises(ValueError, poly.polyfit, [1], [1], -1)
  576:         assert_raises(TypeError, poly.polyfit, [[1]], [1], 0)
  577:         assert_raises(TypeError, poly.polyfit, [], [1], 0)
  578:         assert_raises(TypeError, poly.polyfit, [1], [[[1]]], 0)
  579:         assert_raises(TypeError, poly.polyfit, [1, 2], [1], 0)
  580:         assert_raises(TypeError, poly.polyfit, [1], [1, 2], 0)
  581:         assert_raises(TypeError, poly.polyfit, [1], [1], 0, w=[[1]])
  582:         assert_raises(TypeError, poly.polyfit, [1], [1], 0, w=[1, 1])
  583:         assert_raises(ValueError, poly.polyfit, [1], [1], [-1,])
  584:         assert_raises(ValueError, poly.polyfit, [1], [1], [2, -1, 6])
  585:         assert_raises(TypeError, poly.polyfit, [1], [1], [])
  586: 
  587:         # Test fit
  588:         x = np.linspace(0, 2)
  589:         y = f(x)
  590:         #
  591:         coef3 = poly.polyfit(x, y, 3)
  592:         assert_equal(len(coef3), 4)
  593:         assert_almost_equal(poly.polyval(x, coef3), y)
  594:         coef3 = poly.polyfit(x, y, [0, 1, 2, 3])
  595:         assert_equal(len(coef3), 4)
  596:         assert_almost_equal(poly.polyval(x, coef3), y)
  597:         #
  598:         coef4 = poly.polyfit(x, y, 4)
  599:         assert_equal(len(coef4), 5)
  600:         assert_almost_equal(poly.polyval(x, coef4), y)
  601:         coef4 = poly.polyfit(x, y, [0, 1, 2, 3, 4])
  602:         assert_equal(len(coef4), 5)
  603:         assert_almost_equal(poly.polyval(x, coef4), y)
  604:         #
  605:         coef2d = poly.polyfit(x, np.array([y, y]).T, 3)
  606:         assert_almost_equal(coef2d, np.array([coef3, coef3]).T)
  607:         coef2d = poly.polyfit(x, np.array([y, y]).T, [0, 1, 2, 3])
  608:         assert_almost_equal(coef2d, np.array([coef3, coef3]).T)
  609:         # test weighting
  610:         w = np.zeros_like(x)
  611:         yw = y.copy()
  612:         w[1::2] = 1
  613:         yw[0::2] = 0
  614:         wcoef3 = poly.polyfit(x, yw, 3, w=w)
  615:         assert_almost_equal(wcoef3, coef3)
  616:         wcoef3 = poly.polyfit(x, yw, [0, 1, 2, 3], w=w)
  617:         assert_almost_equal(wcoef3, coef3)
  618:         #
  619:         wcoef2d = poly.polyfit(x, np.array([yw, yw]).T, 3, w=w)
  620:         assert_almost_equal(wcoef2d, np.array([coef3, coef3]).T)
  621:         wcoef2d = poly.polyfit(x, np.array([yw, yw]).T, [0, 1, 2, 3], w=w)
  622:         assert_almost_equal(wcoef2d, np.array([coef3, coef3]).T)
  623:         # test scaling with complex values x points whose square
  624:         # is zero when summed.
  625:         x = [1, 1j, -1, -1j]
  626:         assert_almost_equal(poly.polyfit(x, x, 1), [0, 1])
  627:         assert_almost_equal(poly.polyfit(x, x, [0, 1]), [0, 1])
  628:         # test fitting only even Polyendre polynomials
  629:         x = np.linspace(-1, 1)
  630:         y = f2(x)
  631:         coef1 = poly.polyfit(x, y, 4)
  632:         assert_almost_equal(poly.polyval(x, coef1), y)
  633:         coef2 = poly.polyfit(x, y, [0, 2, 4])
  634:         assert_almost_equal(poly.polyval(x, coef2), y)
  635:         assert_almost_equal(coef1, coef2)
  636: 
  637:     def test_polytrim(self):
  638:         coef = [2, -1, 1, 0]
  639: 
  640:         # Test exceptions
  641:         assert_raises(ValueError, poly.polytrim, coef, -1)
  642: 
  643:         # Test results
  644:         assert_equal(poly.polytrim(coef), coef[:-1])
  645:         assert_equal(poly.polytrim(coef, 1), coef[:-3])
  646:         assert_equal(poly.polytrim(coef, 2), [0])
  647: 
  648:     def test_polyline(self):
  649:         assert_equal(poly.polyline(3, 4), [3, 4])
  650: 
  651:     def test_polyline_zero(self):
  652:         assert_equal(poly.polyline(3, 0), [3])
  653: 
  654:     def test_fit_degenerate_domain(self):
  655:         p = poly.Polynomial.fit([1], [2], deg=0)
  656:         assert_equal(p.coef, [2.])
  657:         p = poly.Polynomial.fit([1, 1], [2, 2.1], deg=0)
  658:         assert_almost_equal(p.coef, [2.05])
  659:         with assert_warns(pu.RankWarning):
  660:             p = poly.Polynomial.fit([1, 1], [2, 2.1], deg=1)
  661: 
  662:     def test_result_type(self):
  663:         w = np.array([-1, 1], dtype=np.float32)
  664:         p = np.polynomial.Polynomial(w, domain=w, window=w)
  665:         v = p(2)
  666:         assert_equal(v.dtype, np.float32)
  667: 
  668:         arr = np.polydiv(1, np.float32(1))
  669:         assert_equal(arr[0].dtype, np.float64)
