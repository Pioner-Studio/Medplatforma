    1: """
    2: Utility classes and functions for the polynomial modules.
    3: 
    4: This module provides: error and warning objects; a polynomial base class;
    5: and some routines used in both the `polynomial` and `chebyshev` modules.
    6: 
    7: Functions
    8: ---------
    9: 
   10: .. autosummary::
   11:    :toctree: generated/
   12: 
   13:    as_series    convert list of array_likes into 1-D arrays of common type.
   14:    trimseq      remove trailing zeros.
   15:    trimcoef     remove small trailing coefficients.
   16:    getdomain    return the domain appropriate for a given set of abscissae.
   17:    mapdomain    maps points between domains.
   18:    mapparms     parameters of the linear map between domains.
   19: 
   20: """
   21: import functools
   22: import operator
   23: import warnings
   24: 
   25: import numpy as np
   26: from numpy._core.multiarray import dragon4_positional, dragon4_scientific
   27: from numpy.exceptions import RankWarning
   28: 
   29: __all__ = [
   30:     'as_series', 'trimseq', 'trimcoef', 'getdomain', 'mapdomain', 'mapparms',
   31:     'format_float']
   32: 
   33: #
   34: # Helper functions to convert inputs to 1-D arrays
   35: #
   36: def trimseq(seq):
   37:     """Remove small Poly series coefficients.
   38: 
   39:     Parameters
   40:     ----------
   41:     seq : sequence
   42:         Sequence of Poly series coefficients.
   43: 
   44:     Returns
   45:     -------
   46:     series : sequence
   47:         Subsequence with trailing zeros removed. If the resulting sequence
   48:         would be empty, return the first element. The returned sequence may
   49:         or may not be a view.
   50: 
   51:     Notes
   52:     -----
   53:     Do not lose the type info if the sequence contains unknown objects.
   54: 
   55:     """
   56:     if len(seq) == 0 or seq[-1] != 0:
   57:         return seq
   58:     else:
   59:         for i in range(len(seq) - 1, -1, -1):
   60:             if seq[i] != 0:
   61:                 break
   62:         return seq[:i + 1]
   63: 
   64: 
   65: def as_series(alist, trim=True):
   66:     """
   67:     Return argument as a list of 1-d arrays.
   68: 
   69:     The returned list contains array(s) of dtype double, complex double, or
   70:     object.  A 1-d argument of shape ``(N,)`` is parsed into ``N`` arrays of
   71:     size one; a 2-d argument of shape ``(M,N)`` is parsed into ``M`` arrays
   72:     of size ``N`` (i.e., is "parsed by row"); and a higher dimensional array
   73:     raises a Value Error if it is not first reshaped into either a 1-d or 2-d
   74:     array.
   75: 
   76:     Parameters
   77:     ----------
   78:     alist : array_like
   79:         A 1- or 2-d array_like
   80:     trim : boolean, optional
   81:         When True, trailing zeros are removed from the inputs.
   82:         When False, the inputs are passed through intact.
   83: 
   84:     Returns
   85:     -------
   86:     [a1, a2,...] : list of 1-D arrays
   87:         A copy of the input data as a list of 1-d arrays.
   88: 
   89:     Raises
   90:     ------
   91:     ValueError
   92:         Raised when `as_series` cannot convert its input to 1-d arrays, or at
   93:         least one of the resulting arrays is empty.
   94: 
   95:     Examples
   96:     --------
   97:     >>> import numpy as np
   98:     >>> from numpy.polynomial import polyutils as pu
   99:     >>> a = np.arange(4)
  100:     >>> pu.as_series(a)
  101:     [array([0.]), array([1.]), array([2.]), array([3.])]
  102:     >>> b = np.arange(6).reshape((2,3))
  103:     >>> pu.as_series(b)
  104:     [array([0., 1., 2.]), array([3., 4., 5.])]
  105: 
  106:     >>> pu.as_series((1, np.arange(3), np.arange(2, dtype=np.float16)))
  107:     [array([1.]), array([0., 1., 2.]), array([0., 1.])]
  108: 
  109:     >>> pu.as_series([2, [1.1, 0.]])
  110:     [array([2.]), array([1.1])]
  111: 
  112:     >>> pu.as_series([2, [1.1, 0.]], trim=False)
  113:     [array([2.]), array([1.1, 0. ])]
  114: 
  115:     """
  116:     arrays = [np.array(a, ndmin=1, copy=None) for a in alist]
  117:     for a in arrays:
  118:         if a.size == 0:
  119:             raise ValueError("Coefficient array is empty")
  120:         if a.ndim != 1:
  121:             raise ValueError("Coefficient array is not 1-d")
  122:     if trim:
  123:         arrays = [trimseq(a) for a in arrays]
  124: 
  125:     try:
  126:         dtype = np.common_type(*arrays)
  127:     except Exception as e:
  128:         object_dtype = np.dtypes.ObjectDType()
  129:         has_one_object_type = False
  130:         ret = []
  131:         for a in arrays:
  132:             if a.dtype != object_dtype:
  133:                 tmp = np.empty(len(a), dtype=object_dtype)
  134:                 tmp[:] = a[:]
  135:                 ret.append(tmp)
  136:             else:
  137:                 has_one_object_type = True
  138:                 ret.append(a.copy())
  139:         if not has_one_object_type:
  140:             raise ValueError("Coefficient arrays have no common type") from e
  141:     else:
  142:         ret = [np.array(a, copy=True, dtype=dtype) for a in arrays]
  143:     return ret
  144: 
  145: 
  146: def trimcoef(c, tol=0):
  147:     """
  148:     Remove "small" "trailing" coefficients from a polynomial.
  149: 
  150:     "Small" means "small in absolute value" and is controlled by the
  151:     parameter `tol`; "trailing" means highest order coefficient(s), e.g., in
  152:     ``[0, 1, 1, 0, 0]`` (which represents ``0 + x + x**2 + 0*x**3 + 0*x**4``)
  153:     both the 3-rd and 4-th order coefficients would be "trimmed."
  154: 
  155:     Parameters
  156:     ----------
  157:     c : array_like
  158:         1-d array of coefficients, ordered from lowest order to highest.
  159:     tol : number, optional
  160:         Trailing (i.e., highest order) elements with absolute value less
  161:         than or equal to `tol` (default value is zero) are removed.
  162: 
  163:     Returns
  164:     -------
  165:     trimmed : ndarray
  166:         1-d array with trailing zeros removed.  If the resulting series
  167:         would be empty, a series containing a single zero is returned.
  168: 
  169:     Raises
  170:     ------
  171:     ValueError
  172:         If `tol` < 0
  173: 
  174:     Examples
  175:     --------
  176:     >>> from numpy.polynomial import polyutils as pu
  177:     >>> pu.trimcoef((0,0,3,0,5,0,0))
  178:     array([0.,  0.,  3.,  0.,  5.])
  179:     >>> pu.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed
  180:     array([0.])
  181:     >>> i = complex(0,1) # works for complex
  182:     >>> pu.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)
  183:     array([0.0003+0.j   , 0.001 -0.001j])
  184: 
  185:     """
  186:     if tol < 0:
  187:         raise ValueError("tol must be non-negative")
  188: 
  189:     [c] = as_series([c])
  190:     [ind] = np.nonzero(np.abs(c) > tol)
  191:     if len(ind) == 0:
  192:         return c[:1] * 0
  193:     else:
  194:         return c[:ind[-1] + 1].copy()
  195: 
  196: def getdomain(x):
  197:     """
  198:     Return a domain suitable for given abscissae.
  199: 
  200:     Find a domain suitable for a polynomial or Chebyshev series
  201:     defined at the values supplied.
  202: 
  203:     Parameters
  204:     ----------
  205:     x : array_like
  206:         1-d array of abscissae whose domain will be determined.
  207: 
  208:     Returns
  209:     -------
  210:     domain : ndarray
  211:         1-d array containing two values.  If the inputs are complex, then
  212:         the two returned points are the lower left and upper right corners
  213:         of the smallest rectangle (aligned with the axes) in the complex
  214:         plane containing the points `x`. If the inputs are real, then the
  215:         two points are the ends of the smallest interval containing the
  216:         points `x`.
  217: 
  218:     See Also
  219:     --------
  220:     mapparms, mapdomain
  221: 
  222:     Examples
  223:     --------
  224:     >>> import numpy as np
  225:     >>> from numpy.polynomial import polyutils as pu
  226:     >>> points = np.arange(4)**2 - 5; points
  227:     array([-5, -4, -1,  4])
  228:     >>> pu.getdomain(points)
  229:     array([-5.,  4.])
  230:     >>> c = np.exp(complex(0,1)*np.pi*np.arange(12)/6) # unit circle
  231:     >>> pu.getdomain(c)
  232:     array([-1.-1.j,  1.+1.j])
  233: 
  234:     """
  235:     [x] = as_series([x], trim=False)
  236:     if x.dtype.char in np.typecodes['Complex']:
  237:         rmin, rmax = x.real.min(), x.real.max()
  238:         imin, imax = x.imag.min(), x.imag.max()
  239:         return np.array((complex(rmin, imin), complex(rmax, imax)))
  240:     else:
  241:         return np.array((x.min(), x.max()))
  242: 
  243: def mapparms(old, new):
  244:     """
  245:     Linear map parameters between domains.
  246: 
  247:     Return the parameters of the linear map ``offset + scale*x`` that maps
  248:     `old` to `new` such that ``old[i] -> new[i]``, ``i = 0, 1``.
  249: 
  250:     Parameters
  251:     ----------
  252:     old, new : array_like
  253:         Domains. Each domain must (successfully) convert to a 1-d array
  254:         containing precisely two values.
  255: 
  256:     Returns
  257:     -------
  258:     offset, scale : scalars
  259:         The map ``L(x) = offset + scale*x`` maps the first domain to the
  260:         second.
  261: 
  262:     See Also
  263:     --------
  264:     getdomain, mapdomain
  265: 
  266:     Notes
  267:     -----
  268:     Also works for complex numbers, and thus can be used to calculate the
  269:     parameters required to map any line in the complex plane to any other
  270:     line therein.
  271: 
  272:     Examples
  273:     --------
  274:     >>> from numpy.polynomial import polyutils as pu
  275:     >>> pu.mapparms((-1,1),(-1,1))
  276:     (0.0, 1.0)
  277:     >>> pu.mapparms((1,-1),(-1,1))
  278:     (-0.0, -1.0)
  279:     >>> i = complex(0,1)
  280:     >>> pu.mapparms((-i,-1),(1,i))
  281:     ((1+1j), (1-0j))
  282: 
  283:     """
  284:     oldlen = old[1] - old[0]
  285:     newlen = new[1] - new[0]
  286:     off = (old[1] * new[0] - old[0] * new[1]) / oldlen
  287:     scl = newlen / oldlen
  288:     return off, scl
  289: 
  290: def mapdomain(x, old, new):
  291:     """
  292:     Apply linear map to input points.
  293: 
  294:     The linear map ``offset + scale*x`` that maps the domain `old` to
  295:     the domain `new` is applied to the points `x`.
  296: 
  297:     Parameters
  298:     ----------
  299:     x : array_like
  300:         Points to be mapped. If `x` is a subtype of ndarray the subtype
  301:         will be preserved.
  302:     old, new : array_like
  303:         The two domains that determine the map.  Each must (successfully)
  304:         convert to 1-d arrays containing precisely two values.
  305: 
  306:     Returns
  307:     -------
  308:     x_out : ndarray
  309:         Array of points of the same shape as `x`, after application of the
  310:         linear map between the two domains.
  311: 
  312:     See Also
  313:     --------
  314:     getdomain, mapparms
  315: 
  316:     Notes
  317:     -----
  318:     Effectively, this implements:
  319: 
  320:     .. math::
  321:         x\\_out = new[0] + m(x - old[0])
  322: 
  323:     where
  324: 
  325:     .. math::
  326:         m = \\frac{new[1]-new[0]}{old[1]-old[0]}
  327: 
  328:     Examples
  329:     --------
  330:     >>> import numpy as np
  331:     >>> from numpy.polynomial import polyutils as pu
  332:     >>> old_domain = (-1,1)
  333:     >>> new_domain = (0,2*np.pi)
  334:     >>> x = np.linspace(-1,1,6); x
  335:     array([-1. , -0.6, -0.2,  0.2,  0.6,  1. ])
  336:     >>> x_out = pu.mapdomain(x, old_domain, new_domain); x_out
  337:     array([ 0.        ,  1.25663706,  2.51327412,  3.76991118,  5.02654825, # may vary
  338:             6.28318531])
  339:     >>> x - pu.mapdomain(x_out, new_domain, old_domain)
  340:     array([0., 0., 0., 0., 0., 0.])
  341: 
  342:     Also works for complex numbers (and thus can be used to map any line in
  343:     the complex plane to any other line therein).
  344: 
  345:     >>> i = complex(0,1)
  346:     >>> old = (-1 - i, 1 + i)
  347:     >>> new = (-1 + i, 1 - i)
  348:     >>> z = np.linspace(old[0], old[1], 6); z
  349:     array([-1. -1.j , -0.6-0.6j, -0.2-0.2j,  0.2+0.2j,  0.6+0.6j,  1. +1.j ])
  350:     >>> new_z = pu.mapdomain(z, old, new); new_z
  351:     array([-1.0+1.j , -0.6+0.6j, -0.2+0.2j,  0.2-0.2j,  0.6-0.6j,  1.0-1.j ]) # may vary
  352: 
  353:     """
  354:     if type(x) not in (int, float, complex) and not isinstance(x, np.generic):
  355:         x = np.asanyarray(x)
  356:     off, scl = mapparms(old, new)
  357:     return off + scl * x
  358: 
  359: 
  360: def _nth_slice(i, ndim):
  361:     sl = [np.newaxis] * ndim
  362:     sl[i] = slice(None)
  363:     return tuple(sl)
  364: 
  365: 
  366: def _vander_nd(vander_fs, points, degrees):
  367:     r"""
  368:     A generalization of the Vandermonde matrix for N dimensions
  369: 
  370:     The result is built by combining the results of 1d Vandermonde matrices,
  371: 
  372:     .. math::
  373:         W[i_0, \ldots, i_M, j_0, \ldots, j_N] = \prod_{k=0}^N{V_k(x_k)[i_0, \ldots, i_M, j_k]}
  374: 
  375:     where
  376: 
  377:     .. math::
  378:         N &= \texttt{len(points)} = \texttt{len(degrees)} = \texttt{len(vander\_fs)} \\
  379:         M &= \texttt{points[k].ndim} \\
  380:         V_k &= \texttt{vander\_fs[k]} \\
  381:         x_k &= \texttt{points[k]} \\
  382:         0 \le j_k &\le \texttt{degrees[k]}
  383: 
  384:     Expanding the one-dimensional :math:`V_k` functions gives:
  385: 
  386:     .. math::
  387:         W[i_0, \ldots, i_M, j_0, \ldots, j_N] = \prod_{k=0}^N{B_{k, j_k}(x_k[i_0, \ldots, i_M])}
  388: 
  389:     where :math:`B_{k,m}` is the m'th basis of the polynomial construction used along
  390:     dimension :math:`k`. For a regular polynomial, :math:`B_{k, m}(x) = P_m(x) = x^m`.
  391: 
  392:     Parameters
  393:     ----------
  394:     vander_fs : Sequence[function(array_like, int) -> ndarray]
  395:         The 1d vander function to use for each axis, such as ``polyvander``
  396:     points : Sequence[array_like]
  397:         Arrays of point coordinates, all of the same shape. The dtypes
  398:         will be converted to either float64 or complex128 depending on
  399:         whether any of the elements are complex. Scalars are converted to
  400:         1-D arrays.
  401:         This must be the same length as `vander_fs`.
  402:     degrees : Sequence[int]
  403:         The maximum degree (inclusive) to use for each axis.
  404:         This must be the same length as `vander_fs`.
  405: 
  406:     Returns
  407:     -------
  408:     vander_nd : ndarray
  409:         An array of shape ``points[0].shape + tuple(d + 1 for d in degrees)``.
  410:     """  # noqa: E501
  411:     n_dims = len(vander_fs)
  412:     if n_dims != len(points):
  413:         raise ValueError(
  414:             f"Expected {n_dims} dimensions of sample points, got {len(points)}")
  415:     if n_dims != len(degrees):
  416:         raise ValueError(
  417:             f"Expected {n_dims} dimensions of degrees, got {len(degrees)}")
  418:     if n_dims == 0:
  419:         raise ValueError("Unable to guess a dtype or shape when no points are given")
  420: 
  421:     # convert to the same shape and type
  422:     points = tuple(np.asarray(tuple(points)) + 0.0)
  423: 
  424:     # produce the vandermonde matrix for each dimension, placing the last
  425:     # axis of each in an independent trailing axis of the output
  426:     vander_arrays = (
  427:         vander_fs[i](points[i], degrees[i])[(...,) + _nth_slice(i, n_dims)]
  428:         for i in range(n_dims)
  429:     )
  430: 
  431:     # we checked this wasn't empty already, so no `initial` needed
  432:     return functools.reduce(operator.mul, vander_arrays)
  433: 
  434: 
  435: def _vander_nd_flat(vander_fs, points, degrees):
  436:     """
  437:     Like `_vander_nd`, but flattens the last ``len(degrees)`` axes into a single axis
  438: 
  439:     Used to implement the public ``<type>vander<n>d`` functions.
  440:     """
  441:     v = _vander_nd(vander_fs, points, degrees)
  442:     return v.reshape(v.shape[:-len(degrees)] + (-1,))
  443: 
  444: 
  445: def _fromroots(line_f, mul_f, roots):
  446:     """
  447:     Helper function used to implement the ``<type>fromroots`` functions.
  448: 
  449:     Parameters
  450:     ----------
  451:     line_f : function(float, float) -> ndarray
  452:         The ``<type>line`` function, such as ``polyline``
  453:     mul_f : function(array_like, array_like) -> ndarray
  454:         The ``<type>mul`` function, such as ``polymul``
  455:     roots
  456:         See the ``<type>fromroots`` functions for more detail
  457:     """
  458:     if len(roots) == 0:
  459:         return np.ones(1)
  460:     else:
  461:         [roots] = as_series([roots], trim=False)
  462:         roots.sort()
  463:         p = [line_f(-r, 1) for r in roots]
  464:         n = len(p)
  465:         while n > 1:
  466:             m, r = divmod(n, 2)
  467:             tmp = [mul_f(p[i], p[i + m]) for i in range(m)]
  468:             if r:
  469:                 tmp[0] = mul_f(tmp[0], p[-1])
  470:             p = tmp
  471:             n = m
  472:         return p[0]
  473: 
  474: 
  475: def _valnd(val_f, c, *args):
  476:     """
  477:     Helper function used to implement the ``<type>val<n>d`` functions.
  478: 
  479:     Parameters
  480:     ----------
  481:     val_f : function(array_like, array_like, tensor: bool) -> array_like
  482:         The ``<type>val`` function, such as ``polyval``
  483:     c, args
  484:         See the ``<type>val<n>d`` functions for more detail
  485:     """
  486:     args = [np.asanyarray(a) for a in args]
  487:     shape0 = args[0].shape
  488:     if not all(a.shape == shape0 for a in args[1:]):
  489:         if len(args) == 3:
  490:             raise ValueError('x, y, z are incompatible')
  491:         elif len(args) == 2:
  492:             raise ValueError('x, y are incompatible')
  493:         else:
  494:             raise ValueError('ordinates are incompatible')
  495:     it = iter(args)
  496:     x0 = next(it)
  497: 
  498:     # use tensor on only the first
  499:     c = val_f(x0, c)
  500:     for xi in it:
  501:         c = val_f(xi, c, tensor=False)
  502:     return c
  503: 
  504: 
  505: def _gridnd(val_f, c, *args):
  506:     """
  507:     Helper function used to implement the ``<type>grid<n>d`` functions.
  508: 
  509:     Parameters
  510:     ----------
  511:     val_f : function(array_like, array_like, tensor: bool) -> array_like
  512:         The ``<type>val`` function, such as ``polyval``
  513:     c, args
  514:         See the ``<type>grid<n>d`` functions for more detail
  515:     """
  516:     for xi in args:
  517:         c = val_f(xi, c)
  518:     return c
  519: 
  520: 
  521: def _div(mul_f, c1, c2):
  522:     """
  523:     Helper function used to implement the ``<type>div`` functions.
  524: 
  525:     Implementation uses repeated subtraction of c2 multiplied by the nth basis.
  526:     For some polynomial types, a more efficient approach may be possible.
  527: 
  528:     Parameters
  529:     ----------
  530:     mul_f : function(array_like, array_like) -> array_like
  531:         The ``<type>mul`` function, such as ``polymul``
  532:     c1, c2
  533:         See the ``<type>div`` functions for more detail
  534:     """
  535:     # c1, c2 are trimmed copies
  536:     [c1, c2] = as_series([c1, c2])
  537:     if c2[-1] == 0:
  538:         raise ZeroDivisionError  # FIXME: add message with details to exception
  539: 
  540:     lc1 = len(c1)
  541:     lc2 = len(c2)
  542:     if lc1 < lc2:
  543:         return c1[:1] * 0, c1
  544:     elif lc2 == 1:
  545:         return c1 / c2[-1], c1[:1] * 0
  546:     else:
  547:         quo = np.empty(lc1 - lc2 + 1, dtype=c1.dtype)
  548:         rem = c1
  549:         for i in range(lc1 - lc2, - 1, -1):
  550:             p = mul_f([0] * i + [1], c2)
  551:             q = rem[-1] / p[-1]
  552:             rem = rem[:-1] - q * p[:-1]
  553:             quo[i] = q
  554:         return quo, trimseq(rem)
  555: 
  556: 
  557: def _add(c1, c2):
  558:     """ Helper function used to implement the ``<type>add`` functions. """
  559:     # c1, c2 are trimmed copies
  560:     [c1, c2] = as_series([c1, c2])
  561:     if len(c1) > len(c2):
  562:         c1[:c2.size] += c2
  563:         ret = c1
  564:     else:
  565:         c2[:c1.size] += c1
  566:         ret = c2
  567:     return trimseq(ret)
  568: 
  569: 
  570: def _sub(c1, c2):
  571:     """ Helper function used to implement the ``<type>sub`` functions. """
  572:     # c1, c2 are trimmed copies
  573:     [c1, c2] = as_series([c1, c2])
  574:     if len(c1) > len(c2):
  575:         c1[:c2.size] -= c2
  576:         ret = c1
  577:     else:
  578:         c2 = -c2
  579:         c2[:c1.size] += c1
  580:         ret = c2
  581:     return trimseq(ret)
  582: 
  583: 
  584: def _fit(vander_f, x, y, deg, rcond=None, full=False, w=None):
  585:     """
  586:     Helper function used to implement the ``<type>fit`` functions.
  587: 
  588:     Parameters
  589:     ----------
  590:     vander_f : function(array_like, int) -> ndarray
  591:         The 1d vander function, such as ``polyvander``
  592:     c1, c2
  593:         See the ``<type>fit`` functions for more detail
  594:     """
  595:     x = np.asarray(x) + 0.0
  596:     y = np.asarray(y) + 0.0
  597:     deg = np.asarray(deg)
  598: 
  599:     # check arguments.
  600:     if deg.ndim > 1 or deg.dtype.kind not in 'iu' or deg.size == 0:
  601:         raise TypeError("deg must be an int or non-empty 1-D array of int")
  602:     if deg.min() < 0:
  603:         raise ValueError("expected deg >= 0")
  604:     if x.ndim != 1:
  605:         raise TypeError("expected 1D vector for x")
  606:     if x.size == 0:
  607:         raise TypeError("expected non-empty vector for x")
  608:     if y.ndim < 1 or y.ndim > 2:
  609:         raise TypeError("expected 1D or 2D array for y")
  610:     if len(x) != len(y):
  611:         raise TypeError("expected x and y to have same length")
  612: 
  613:     if deg.ndim == 0:
  614:         lmax = deg
  615:         order = lmax + 1
  616:         van = vander_f(x, lmax)
  617:     else:
  618:         deg = np.sort(deg)
  619:         lmax = deg[-1]
  620:         order = len(deg)
  621:         van = vander_f(x, lmax)[:, deg]
  622: 
  623:     # set up the least squares matrices in transposed form
  624:     lhs = van.T
  625:     rhs = y.T
  626:     if w is not None:
  627:         w = np.asarray(w) + 0.0
  628:         if w.ndim != 1:
  629:             raise TypeError("expected 1D vector for w")
  630:         if len(x) != len(w):
  631:             raise TypeError("expected x and w to have same length")
  632:         # apply weights. Don't use inplace operations as they
  633:         # can cause problems with NA.
  634:         lhs = lhs * w
  635:         rhs = rhs * w
  636: 
  637:     # set rcond
  638:     if rcond is None:
  639:         rcond = len(x) * np.finfo(x.dtype).eps
  640: 
  641:     # Determine the norms of the design matrix columns.
  642:     if issubclass(lhs.dtype.type, np.complexfloating):
  643:         scl = np.sqrt((np.square(lhs.real) + np.square(lhs.imag)).sum(1))
  644:     else:
  645:         scl = np.sqrt(np.square(lhs).sum(1))
  646:     scl[scl == 0] = 1
  647: 
  648:     # Solve the least squares problem.
  649:     c, resids, rank, s = np.linalg.lstsq(lhs.T / scl, rhs.T, rcond)
  650:     c = (c.T / scl).T
  651: 
  652:     # Expand c to include non-fitted coefficients which are set to zero
  653:     if deg.ndim > 0:
  654:         if c.ndim == 2:
  655:             cc = np.zeros((lmax + 1, c.shape[1]), dtype=c.dtype)
  656:         else:
  657:             cc = np.zeros(lmax + 1, dtype=c.dtype)
  658:         cc[deg] = c
  659:         c = cc
  660: 
  661:     # warn on rank reduction
  662:     if rank != order and not full:
  663:         msg = "The fit may be poorly conditioned"
  664:         warnings.warn(msg, RankWarning, stacklevel=2)
  665: 
  666:     if full:
  667:         return c, [resids, rank, s, rcond]
  668:     else:
  669:         return c
  670: 
  671: 
  672: def _pow(mul_f, c, pow, maxpower):
  673:     """
  674:     Helper function used to implement the ``<type>pow`` functions.
  675: 
  676:     Parameters
  677:     ----------
  678:     mul_f : function(array_like, array_like) -> ndarray
  679:         The ``<type>mul`` function, such as ``polymul``
  680:     c : array_like
  681:         1-D array of array of series coefficients
  682:     pow, maxpower
  683:         See the ``<type>pow`` functions for more detail
  684:     """
  685:     # c is a trimmed copy
  686:     [c] = as_series([c])
  687:     power = int(pow)
  688:     if power != pow or power < 0:
  689:         raise ValueError("Power must be a non-negative integer.")
  690:     elif maxpower is not None and power > maxpower:
  691:         raise ValueError("Power is too large")
  692:     elif power == 0:
  693:         return np.array([1], dtype=c.dtype)
  694:     elif power == 1:
  695:         return c
  696:     else:
  697:         # This can be made more efficient by using powers of two
  698:         # in the usual way.
  699:         prd = c
  700:         for i in range(2, power + 1):
  701:             prd = mul_f(prd, c)
  702:         return prd
  703: 
  704: 
  705: def _as_int(x, desc):
  706:     """
  707:     Like `operator.index`, but emits a custom exception when passed an
  708:     incorrect type
  709: 
  710:     Parameters
  711:     ----------
  712:     x : int-like
  713:         Value to interpret as an integer
  714:     desc : str
  715:         description to include in any error message
  716: 
  717:     Raises
  718:     ------
  719:     TypeError : if x is a float or non-numeric
  720:     """
  721:     try:
  722:         return operator.index(x)
  723:     except TypeError as e:
  724:         raise TypeError(f"{desc} must be an integer, received {x}") from e
  725: 
  726: 
  727: def format_float(x, parens=False):
  728:     if not np.issubdtype(type(x), np.floating):
  729:         return str(x)
  730: 
  731:     opts = np.get_printoptions()
  732: 
  733:     if np.isnan(x):
  734:         return opts['nanstr']
  735:     elif np.isinf(x):
  736:         return opts['infstr']
  737: 
  738:     exp_format = False
  739:     if x != 0:
  740:         a = np.abs(x)
  741:         if a >= 1.e8 or a < 10**min(0, -(opts['precision'] - 1) // 2):
  742:             exp_format = True
  743: 
  744:     trim, unique = '0', True
  745:     if opts['floatmode'] == 'fixed':
  746:         trim, unique = 'k', False
  747: 
  748:     if exp_format:
  749:         s = dragon4_scientific(x, precision=opts['precision'],
  750:                                unique=unique, trim=trim,
  751:                                sign=opts['sign'] == '+')
  752:         if parens:
  753:             s = '(' + s + ')'
  754:     else:
  755:         s = dragon4_positional(x, precision=opts['precision'],
  756:                                fractional=True,
  757:                                unique=unique, trim=trim,
  758:                                sign=opts['sign'] == '+')
  759:     return s
