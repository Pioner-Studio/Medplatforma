    1: """
    2: ===================================================================
    3: HermiteE Series, "Probabilists" (:mod:`numpy.polynomial.hermite_e`)
    4: ===================================================================
    5: 
    6: This module provides a number of objects (mostly functions) useful for
    7: dealing with Hermite_e series, including a `HermiteE` class that
    8: encapsulates the usual arithmetic operations.  (General information
    9: on how this module represents and works with such polynomials is in the
   10: docstring for its "parent" sub-package, `numpy.polynomial`).
   11: 
   12: Classes
   13: -------
   14: .. autosummary::
   15:    :toctree: generated/
   16: 
   17:    HermiteE
   18: 
   19: Constants
   20: ---------
   21: .. autosummary::
   22:    :toctree: generated/
   23: 
   24:    hermedomain
   25:    hermezero
   26:    hermeone
   27:    hermex
   28: 
   29: Arithmetic
   30: ----------
   31: .. autosummary::
   32:    :toctree: generated/
   33: 
   34:    hermeadd
   35:    hermesub
   36:    hermemulx
   37:    hermemul
   38:    hermediv
   39:    hermepow
   40:    hermeval
   41:    hermeval2d
   42:    hermeval3d
   43:    hermegrid2d
   44:    hermegrid3d
   45: 
   46: Calculus
   47: --------
   48: .. autosummary::
   49:    :toctree: generated/
   50: 
   51:    hermeder
   52:    hermeint
   53: 
   54: Misc Functions
   55: --------------
   56: .. autosummary::
   57:    :toctree: generated/
   58: 
   59:    hermefromroots
   60:    hermeroots
   61:    hermevander
   62:    hermevander2d
   63:    hermevander3d
   64:    hermegauss
   65:    hermeweight
   66:    hermecompanion
   67:    hermefit
   68:    hermetrim
   69:    hermeline
   70:    herme2poly
   71:    poly2herme
   72: 
   73: See also
   74: --------
   75: `numpy.polynomial`
   76: 
   77: """
   78: import numpy as np
   79: import numpy.linalg as la
   80: from numpy.lib.array_utils import normalize_axis_index
   81: 
   82: from . import polyutils as pu
   83: from ._polybase import ABCPolyBase
   84: 
   85: __all__ = [
   86:     'hermezero', 'hermeone', 'hermex', 'hermedomain', 'hermeline',
   87:     'hermeadd', 'hermesub', 'hermemulx', 'hermemul', 'hermediv',
   88:     'hermepow', 'hermeval', 'hermeder', 'hermeint', 'herme2poly',
   89:     'poly2herme', 'hermefromroots', 'hermevander', 'hermefit', 'hermetrim',
   90:     'hermeroots', 'HermiteE', 'hermeval2d', 'hermeval3d', 'hermegrid2d',
   91:     'hermegrid3d', 'hermevander2d', 'hermevander3d', 'hermecompanion',
   92:     'hermegauss', 'hermeweight']
   93: 
   94: hermetrim = pu.trimcoef
   95: 
   96: 
   97: def poly2herme(pol):
   98:     """
   99:     poly2herme(pol)
  100: 
  101:     Convert a polynomial to a Hermite series.
  102: 
  103:     Convert an array representing the coefficients of a polynomial (relative
  104:     to the "standard" basis) ordered from lowest degree to highest, to an
  105:     array of the coefficients of the equivalent Hermite series, ordered
  106:     from lowest to highest degree.
  107: 
  108:     Parameters
  109:     ----------
  110:     pol : array_like
  111:         1-D array containing the polynomial coefficients
  112: 
  113:     Returns
  114:     -------
  115:     c : ndarray
  116:         1-D array containing the coefficients of the equivalent Hermite
  117:         series.
  118: 
  119:     See Also
  120:     --------
  121:     herme2poly
  122: 
  123:     Notes
  124:     -----
  125:     The easy way to do conversions between polynomial basis sets
  126:     is to use the convert method of a class instance.
  127: 
  128:     Examples
  129:     --------
  130:     >>> import numpy as np
  131:     >>> from numpy.polynomial.hermite_e import poly2herme
  132:     >>> poly2herme(np.arange(4))
  133:     array([  2.,  10.,   2.,   3.])
  134: 
  135:     """
  136:     [pol] = pu.as_series([pol])
  137:     deg = len(pol) - 1
  138:     res = 0
  139:     for i in range(deg, -1, -1):
  140:         res = hermeadd(hermemulx(res), pol[i])
  141:     return res
  142: 
  143: 
  144: def herme2poly(c):
  145:     """
  146:     Convert a Hermite series to a polynomial.
  147: 
  148:     Convert an array representing the coefficients of a Hermite series,
  149:     ordered from lowest degree to highest, to an array of the coefficients
  150:     of the equivalent polynomial (relative to the "standard" basis) ordered
  151:     from lowest to highest degree.
  152: 
  153:     Parameters
  154:     ----------
  155:     c : array_like
  156:         1-D array containing the Hermite series coefficients, ordered
  157:         from lowest order term to highest.
  158: 
  159:     Returns
  160:     -------
  161:     pol : ndarray
  162:         1-D array containing the coefficients of the equivalent polynomial
  163:         (relative to the "standard" basis) ordered from lowest order term
  164:         to highest.
  165: 
  166:     See Also
  167:     --------
  168:     poly2herme
  169: 
  170:     Notes
  171:     -----
  172:     The easy way to do conversions between polynomial basis sets
  173:     is to use the convert method of a class instance.
  174: 
  175:     Examples
  176:     --------
  177:     >>> from numpy.polynomial.hermite_e import herme2poly
  178:     >>> herme2poly([  2.,  10.,   2.,   3.])
  179:     array([0.,  1.,  2.,  3.])
  180: 
  181:     """
  182:     from .polynomial import polyadd, polymulx, polysub
  183: 
  184:     [c] = pu.as_series([c])
  185:     n = len(c)
  186:     if n == 1:
  187:         return c
  188:     if n == 2:
  189:         return c
  190:     else:
  191:         c0 = c[-2]
  192:         c1 = c[-1]
  193:         # i is the current degree of c1
  194:         for i in range(n - 1, 1, -1):
  195:             tmp = c0
  196:             c0 = polysub(c[i - 2], c1 * (i - 1))
  197:             c1 = polyadd(tmp, polymulx(c1))
  198:         return polyadd(c0, polymulx(c1))
  199: 
  200: 
  201: #
  202: # These are constant arrays are of integer type so as to be compatible
  203: # with the widest range of other types, such as Decimal.
  204: #
  205: 
  206: # Hermite
  207: hermedomain = np.array([-1., 1.])
  208: 
  209: # Hermite coefficients representing zero.
  210: hermezero = np.array([0])
  211: 
  212: # Hermite coefficients representing one.
  213: hermeone = np.array([1])
  214: 
  215: # Hermite coefficients representing the identity x.
  216: hermex = np.array([0, 1])
  217: 
  218: 
  219: def hermeline(off, scl):
  220:     """
  221:     Hermite series whose graph is a straight line.
  222: 
  223:     Parameters
  224:     ----------
  225:     off, scl : scalars
  226:         The specified line is given by ``off + scl*x``.
  227: 
  228:     Returns
  229:     -------
  230:     y : ndarray
  231:         This module's representation of the Hermite series for
  232:         ``off + scl*x``.
  233: 
  234:     See Also
  235:     --------
  236:     numpy.polynomial.polynomial.polyline
  237:     numpy.polynomial.chebyshev.chebline
  238:     numpy.polynomial.legendre.legline
  239:     numpy.polynomial.laguerre.lagline
  240:     numpy.polynomial.hermite.hermline
  241: 
  242:     Examples
  243:     --------
  244:     >>> from numpy.polynomial.hermite_e import hermeline
  245:     >>> from numpy.polynomial.hermite_e import hermeline, hermeval
  246:     >>> hermeval(0,hermeline(3, 2))
  247:     3.0
  248:     >>> hermeval(1,hermeline(3, 2))
  249:     5.0
  250: 
  251:     """
  252:     if scl != 0:
  253:         return np.array([off, scl])
  254:     else:
  255:         return np.array([off])
  256: 
  257: 
  258: def hermefromroots(roots):
  259:     """
  260:     Generate a HermiteE series with given roots.
  261: 
  262:     The function returns the coefficients of the polynomial
  263: 
  264:     .. math:: p(x) = (x - r_0) * (x - r_1) * ... * (x - r_n),
  265: 
  266:     in HermiteE form, where the :math:`r_n` are the roots specified in `roots`.
  267:     If a zero has multiplicity n, then it must appear in `roots` n times.
  268:     For instance, if 2 is a root of multiplicity three and 3 is a root of
  269:     multiplicity 2, then `roots` looks something like [2, 2, 2, 3, 3]. The
  270:     roots can appear in any order.
  271: 
  272:     If the returned coefficients are `c`, then
  273: 
  274:     .. math:: p(x) = c_0 + c_1 * He_1(x) + ... +  c_n * He_n(x)
  275: 
  276:     The coefficient of the last term is not generally 1 for monic
  277:     polynomials in HermiteE form.
  278: 
  279:     Parameters
  280:     ----------
  281:     roots : array_like
  282:         Sequence containing the roots.
  283: 
  284:     Returns
  285:     -------
  286:     out : ndarray
  287:         1-D array of coefficients.  If all roots are real then `out` is a
  288:         real array, if some of the roots are complex, then `out` is complex
  289:         even if all the coefficients in the result are real (see Examples
  290:         below).
  291: 
  292:     See Also
  293:     --------
  294:     numpy.polynomial.polynomial.polyfromroots
  295:     numpy.polynomial.legendre.legfromroots
  296:     numpy.polynomial.laguerre.lagfromroots
  297:     numpy.polynomial.hermite.hermfromroots
  298:     numpy.polynomial.chebyshev.chebfromroots
  299: 
  300:     Examples
  301:     --------
  302:     >>> from numpy.polynomial.hermite_e import hermefromroots, hermeval
  303:     >>> coef = hermefromroots((-1, 0, 1))
  304:     >>> hermeval((-1, 0, 1), coef)
  305:     array([0., 0., 0.])
  306:     >>> coef = hermefromroots((-1j, 1j))
  307:     >>> hermeval((-1j, 1j), coef)
  308:     array([0.+0.j, 0.+0.j])
  309: 
  310:     """
  311:     return pu._fromroots(hermeline, hermemul, roots)
  312: 
  313: 
  314: def hermeadd(c1, c2):
  315:     """
  316:     Add one Hermite series to another.
  317: 
  318:     Returns the sum of two Hermite series `c1` + `c2`.  The arguments
  319:     are sequences of coefficients ordered from lowest order term to
  320:     highest, i.e., [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.
  321: 
  322:     Parameters
  323:     ----------
  324:     c1, c2 : array_like
  325:         1-D arrays of Hermite series coefficients ordered from low to
  326:         high.
  327: 
  328:     Returns
  329:     -------
  330:     out : ndarray
  331:         Array representing the Hermite series of their sum.
  332: 
  333:     See Also
  334:     --------
  335:     hermesub, hermemulx, hermemul, hermediv, hermepow
  336: 
  337:     Notes
  338:     -----
  339:     Unlike multiplication, division, etc., the sum of two Hermite series
  340:     is a Hermite series (without having to "reproject" the result onto
  341:     the basis set) so addition, just like that of "standard" polynomials,
  342:     is simply "component-wise."
  343: 
  344:     Examples
  345:     --------
  346:     >>> from numpy.polynomial.hermite_e import hermeadd
  347:     >>> hermeadd([1, 2, 3], [1, 2, 3, 4])
  348:     array([2.,  4.,  6.,  4.])
  349: 
  350:     """
  351:     return pu._add(c1, c2)
  352: 
  353: 
  354: def hermesub(c1, c2):
  355:     """
  356:     Subtract one Hermite series from another.
  357: 
  358:     Returns the difference of two Hermite series `c1` - `c2`.  The
  359:     sequences of coefficients are from lowest order term to highest, i.e.,
  360:     [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.
  361: 
  362:     Parameters
  363:     ----------
  364:     c1, c2 : array_like
  365:         1-D arrays of Hermite series coefficients ordered from low to
  366:         high.
  367: 
  368:     Returns
  369:     -------
  370:     out : ndarray
  371:         Of Hermite series coefficients representing their difference.
  372: 
  373:     See Also
  374:     --------
  375:     hermeadd, hermemulx, hermemul, hermediv, hermepow
  376: 
  377:     Notes
  378:     -----
  379:     Unlike multiplication, division, etc., the difference of two Hermite
  380:     series is a Hermite series (without having to "reproject" the result
  381:     onto the basis set) so subtraction, just like that of "standard"
  382:     polynomials, is simply "component-wise."
  383: 
  384:     Examples
  385:     --------
  386:     >>> from numpy.polynomial.hermite_e import hermesub
  387:     >>> hermesub([1, 2, 3, 4], [1, 2, 3])
  388:     array([0., 0., 0., 4.])
  389: 
  390:     """
  391:     return pu._sub(c1, c2)
  392: 
  393: 
  394: def hermemulx(c):
  395:     """Multiply a Hermite series by x.
  396: 
  397:     Multiply the Hermite series `c` by x, where x is the independent
  398:     variable.
  399: 
  400: 
  401:     Parameters
  402:     ----------
  403:     c : array_like
  404:         1-D array of Hermite series coefficients ordered from low to
  405:         high.
  406: 
  407:     Returns
  408:     -------
  409:     out : ndarray
  410:         Array representing the result of the multiplication.
  411: 
  412:     See Also
  413:     --------
  414:     hermeadd, hermesub, hermemul, hermediv, hermepow
  415: 
  416:     Notes
  417:     -----
  418:     The multiplication uses the recursion relationship for Hermite
  419:     polynomials in the form
  420: 
  421:     .. math::
  422: 
  423:         xP_i(x) = (P_{i + 1}(x) + iP_{i - 1}(x)))
  424: 
  425:     Examples
  426:     --------
  427:     >>> from numpy.polynomial.hermite_e import hermemulx
  428:     >>> hermemulx([1, 2, 3])
  429:     array([2.,  7.,  2.,  3.])
  430: 
  431:     """
  432:     # c is a trimmed copy
  433:     [c] = pu.as_series([c])
  434:     # The zero series needs special treatment
  435:     if len(c) == 1 and c[0] == 0:
  436:         return c
  437: 
  438:     prd = np.empty(len(c) + 1, dtype=c.dtype)
  439:     prd[0] = c[0] * 0
  440:     prd[1] = c[0]
  441:     for i in range(1, len(c)):
  442:         prd[i + 1] = c[i]
  443:         prd[i - 1] += c[i] * i
  444:     return prd
  445: 
  446: 
  447: def hermemul(c1, c2):
  448:     """
  449:     Multiply one Hermite series by another.
  450: 
  451:     Returns the product of two Hermite series `c1` * `c2`.  The arguments
  452:     are sequences of coefficients, from lowest order "term" to highest,
  453:     e.g., [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.
  454: 
  455:     Parameters
  456:     ----------
  457:     c1, c2 : array_like
  458:         1-D arrays of Hermite series coefficients ordered from low to
  459:         high.
  460: 
  461:     Returns
  462:     -------
  463:     out : ndarray
  464:         Of Hermite series coefficients representing their product.
  465: 
  466:     See Also
  467:     --------
  468:     hermeadd, hermesub, hermemulx, hermediv, hermepow
  469: 
  470:     Notes
  471:     -----
  472:     In general, the (polynomial) product of two C-series results in terms
  473:     that are not in the Hermite polynomial basis set.  Thus, to express
  474:     the product as a Hermite series, it is necessary to "reproject" the
  475:     product onto said basis set, which may produce "unintuitive" (but
  476:     correct) results; see Examples section below.
  477: 
  478:     Examples
  479:     --------
  480:     >>> from numpy.polynomial.hermite_e import hermemul
  481:     >>> hermemul([1, 2, 3], [0, 1, 2])
  482:     array([14.,  15.,  28.,   7.,   6.])
  483: 
  484:     """
  485:     # s1, s2 are trimmed copies
  486:     [c1, c2] = pu.as_series([c1, c2])
  487: 
  488:     if len(c1) > len(c2):
  489:         c = c2
  490:         xs = c1
  491:     else:
  492:         c = c1
  493:         xs = c2
  494: 
  495:     if len(c) == 1:
  496:         c0 = c[0] * xs
  497:         c1 = 0
  498:     elif len(c) == 2:
  499:         c0 = c[0] * xs
  500:         c1 = c[1] * xs
  501:     else:
  502:         nd = len(c)
  503:         c0 = c[-2] * xs
  504:         c1 = c[-1] * xs
  505:         for i in range(3, len(c) + 1):
  506:             tmp = c0
  507:             nd = nd - 1
  508:             c0 = hermesub(c[-i] * xs, c1 * (nd - 1))
  509:             c1 = hermeadd(tmp, hermemulx(c1))
  510:     return hermeadd(c0, hermemulx(c1))
  511: 
  512: 
  513: def hermediv(c1, c2):
  514:     """
  515:     Divide one Hermite series by another.
  516: 
  517:     Returns the quotient-with-remainder of two Hermite series
  518:     `c1` / `c2`.  The arguments are sequences of coefficients from lowest
  519:     order "term" to highest, e.g., [1,2,3] represents the series
  520:     ``P_0 + 2*P_1 + 3*P_2``.
  521: 
  522:     Parameters
  523:     ----------
  524:     c1, c2 : array_like
  525:         1-D arrays of Hermite series coefficients ordered from low to
  526:         high.
  527: 
  528:     Returns
  529:     -------
  530:     [quo, rem] : ndarrays
  531:         Of Hermite series coefficients representing the quotient and
  532:         remainder.
  533: 
  534:     See Also
  535:     --------
  536:     hermeadd, hermesub, hermemulx, hermemul, hermepow
  537: 
  538:     Notes
  539:     -----
  540:     In general, the (polynomial) division of one Hermite series by another
  541:     results in quotient and remainder terms that are not in the Hermite
  542:     polynomial basis set.  Thus, to express these results as a Hermite
  543:     series, it is necessary to "reproject" the results onto the Hermite
  544:     basis set, which may produce "unintuitive" (but correct) results; see
  545:     Examples section below.
  546: 
  547:     Examples
  548:     --------
  549:     >>> from numpy.polynomial.hermite_e import hermediv
  550:     >>> hermediv([ 14.,  15.,  28.,   7.,   6.], [0, 1, 2])
  551:     (array([1., 2., 3.]), array([0.]))
  552:     >>> hermediv([ 15.,  17.,  28.,   7.,   6.], [0, 1, 2])
  553:     (array([1., 2., 3.]), array([1., 2.]))
  554: 
  555:     """
  556:     return pu._div(hermemul, c1, c2)
  557: 
  558: 
  559: def hermepow(c, pow, maxpower=16):
  560:     """Raise a Hermite series to a power.
  561: 
  562:     Returns the Hermite series `c` raised to the power `pow`. The
  563:     argument `c` is a sequence of coefficients ordered from low to high.
  564:     i.e., [1,2,3] is the series  ``P_0 + 2*P_1 + 3*P_2.``
  565: 
  566:     Parameters
  567:     ----------
  568:     c : array_like
  569:         1-D array of Hermite series coefficients ordered from low to
  570:         high.
  571:     pow : integer
  572:         Power to which the series will be raised
  573:     maxpower : integer, optional
  574:         Maximum power allowed. This is mainly to limit growth of the series
  575:         to unmanageable size. Default is 16
  576: 
  577:     Returns
  578:     -------
  579:     coef : ndarray
  580:         Hermite series of power.
  581: 
  582:     See Also
  583:     --------
  584:     hermeadd, hermesub, hermemulx, hermemul, hermediv
  585: 
  586:     Examples
  587:     --------
  588:     >>> from numpy.polynomial.hermite_e import hermepow
  589:     >>> hermepow([1, 2, 3], 2)
  590:     array([23.,  28.,  46.,  12.,   9.])
  591: 
  592:     """
  593:     return pu._pow(hermemul, c, pow, maxpower)
  594: 
  595: 
  596: def hermeder(c, m=1, scl=1, axis=0):
  597:     """
  598:     Differentiate a Hermite_e series.
  599: 
  600:     Returns the series coefficients `c` differentiated `m` times along
  601:     `axis`.  At each iteration the result is multiplied by `scl` (the
  602:     scaling factor is for use in a linear change of variable). The argument
  603:     `c` is an array of coefficients from low to high degree along each
  604:     axis, e.g., [1,2,3] represents the series ``1*He_0 + 2*He_1 + 3*He_2``
  605:     while [[1,2],[1,2]] represents ``1*He_0(x)*He_0(y) + 1*He_1(x)*He_0(y)
  606:     + 2*He_0(x)*He_1(y) + 2*He_1(x)*He_1(y)`` if axis=0 is ``x`` and axis=1
  607:     is ``y``.
  608: 
  609:     Parameters
  610:     ----------
  611:     c : array_like
  612:         Array of Hermite_e series coefficients. If `c` is multidimensional
  613:         the different axis correspond to different variables with the
  614:         degree in each axis given by the corresponding index.
  615:     m : int, optional
  616:         Number of derivatives taken, must be non-negative. (Default: 1)
  617:     scl : scalar, optional
  618:         Each differentiation is multiplied by `scl`.  The end result is
  619:         multiplication by ``scl**m``.  This is for use in a linear change of
  620:         variable. (Default: 1)
  621:     axis : int, optional
  622:         Axis over which the derivative is taken. (Default: 0).
  623: 
  624:     Returns
  625:     -------
  626:     der : ndarray
  627:         Hermite series of the derivative.
  628: 
  629:     See Also
  630:     --------
  631:     hermeint
  632: 
  633:     Notes
  634:     -----
  635:     In general, the result of differentiating a Hermite series does not
  636:     resemble the same operation on a power series. Thus the result of this
  637:     function may be "unintuitive," albeit correct; see Examples section
  638:     below.
  639: 
  640:     Examples
  641:     --------
  642:     >>> from numpy.polynomial.hermite_e import hermeder
  643:     >>> hermeder([ 1.,  1.,  1.,  1.])
  644:     array([1.,  2.,  3.])
  645:     >>> hermeder([-0.25,  1.,  1./2.,  1./3.,  1./4 ], m=2)
  646:     array([1.,  2.,  3.])
  647: 
  648:     """
  649:     c = np.array(c, ndmin=1, copy=True)
  650:     if c.dtype.char in '?bBhHiIlLqQpP':
  651:         c = c.astype(np.double)
  652:     cnt = pu._as_int(m, "the order of derivation")
  653:     iaxis = pu._as_int(axis, "the axis")
  654:     if cnt < 0:
  655:         raise ValueError("The order of derivation must be non-negative")
  656:     iaxis = normalize_axis_index(iaxis, c.ndim)
  657: 
  658:     if cnt == 0:
  659:         return c
  660: 
  661:     c = np.moveaxis(c, iaxis, 0)
  662:     n = len(c)
  663:     if cnt >= n:
  664:         return c[:1] * 0
  665:     else:
  666:         for i in range(cnt):
  667:             n = n - 1
  668:             c *= scl
  669:             der = np.empty((n,) + c.shape[1:], dtype=c.dtype)
  670:             for j in range(n, 0, -1):
  671:                 der[j - 1] = j * c[j]
  672:             c = der
  673:     c = np.moveaxis(c, 0, iaxis)
  674:     return c
  675: 
  676: 
  677: def hermeint(c, m=1, k=[], lbnd=0, scl=1, axis=0):
  678:     """
  679:     Integrate a Hermite_e series.
  680: 
  681:     Returns the Hermite_e series coefficients `c` integrated `m` times from
  682:     `lbnd` along `axis`. At each iteration the resulting series is
  683:     **multiplied** by `scl` and an integration constant, `k`, is added.
  684:     The scaling factor is for use in a linear change of variable.  ("Buyer
  685:     beware": note that, depending on what one is doing, one may want `scl`
  686:     to be the reciprocal of what one might expect; for more information,
  687:     see the Notes section below.)  The argument `c` is an array of
  688:     coefficients from low to high degree along each axis, e.g., [1,2,3]
  689:     represents the series ``H_0 + 2*H_1 + 3*H_2`` while [[1,2],[1,2]]
  690:     represents ``1*H_0(x)*H_0(y) + 1*H_1(x)*H_0(y) + 2*H_0(x)*H_1(y) +
  691:     2*H_1(x)*H_1(y)`` if axis=0 is ``x`` and axis=1 is ``y``.
  692: 
  693:     Parameters
  694:     ----------
  695:     c : array_like
  696:         Array of Hermite_e series coefficients. If c is multidimensional
  697:         the different axis correspond to different variables with the
  698:         degree in each axis given by the corresponding index.
  699:     m : int, optional
  700:         Order of integration, must be positive. (Default: 1)
  701:     k : {[], list, scalar}, optional
  702:         Integration constant(s).  The value of the first integral at
  703:         ``lbnd`` is the first value in the list, the value of the second
  704:         integral at ``lbnd`` is the second value, etc.  If ``k == []`` (the
  705:         default), all constants are set to zero.  If ``m == 1``, a single
  706:         scalar can be given instead of a list.
  707:     lbnd : scalar, optional
  708:         The lower bound of the integral. (Default: 0)
  709:     scl : scalar, optional
  710:         Following each integration the result is *multiplied* by `scl`
  711:         before the integration constant is added. (Default: 1)
  712:     axis : int, optional
  713:         Axis over which the integral is taken. (Default: 0).
  714: 
  715:     Returns
  716:     -------
  717:     S : ndarray
  718:         Hermite_e series coefficients of the integral.
  719: 
  720:     Raises
  721:     ------
  722:     ValueError
  723:         If ``m < 0``, ``len(k) > m``, ``np.ndim(lbnd) != 0``, or
  724:         ``np.ndim(scl) != 0``.
  725: 
  726:     See Also
  727:     --------
  728:     hermeder
  729: 
  730:     Notes
  731:     -----
  732:     Note that the result of each integration is *multiplied* by `scl`.
  733:     Why is this important to note?  Say one is making a linear change of
  734:     variable :math:`u = ax + b` in an integral relative to `x`.  Then
  735:     :math:`dx = du/a`, so one will need to set `scl` equal to
  736:     :math:`1/a` - perhaps not what one would have first thought.
  737: 
  738:     Also note that, in general, the result of integrating a C-series needs
  739:     to be "reprojected" onto the C-series basis set.  Thus, typically,
  740:     the result of this function is "unintuitive," albeit correct; see
  741:     Examples section below.
  742: 
  743:     Examples
  744:     --------
  745:     >>> from numpy.polynomial.hermite_e import hermeint
  746:     >>> hermeint([1, 2, 3]) # integrate once, value 0 at 0.
  747:     array([1., 1., 1., 1.])
  748:     >>> hermeint([1, 2, 3], m=2) # integrate twice, value & deriv 0 at 0
  749:     array([-0.25      ,  1.        ,  0.5       ,  0.33333333,  0.25      ]) # may vary
  750:     >>> hermeint([1, 2, 3], k=1) # integrate once, value 1 at 0.
  751:     array([2., 1., 1., 1.])
  752:     >>> hermeint([1, 2, 3], lbnd=-1) # integrate once, value 0 at -1
  753:     array([-1.,  1.,  1.,  1.])
  754:     >>> hermeint([1, 2, 3], m=2, k=[1, 2], lbnd=-1)
  755:     array([ 1.83333333,  0.        ,  0.5       ,  0.33333333,  0.25      ]) # may vary
  756: 
  757:     """
  758:     c = np.array(c, ndmin=1, copy=True)
  759:     if c.dtype.char in '?bBhHiIlLqQpP':
  760:         c = c.astype(np.double)
  761:     if not np.iterable(k):
  762:         k = [k]
  763:     cnt = pu._as_int(m, "the order of integration")
  764:     iaxis = pu._as_int(axis, "the axis")
  765:     if cnt < 0:
  766:         raise ValueError("The order of integration must be non-negative")
  767:     if len(k) > cnt:
  768:         raise ValueError("Too many integration constants")
  769:     if np.ndim(lbnd) != 0:
  770:         raise ValueError("lbnd must be a scalar.")
  771:     if np.ndim(scl) != 0:
  772:         raise ValueError("scl must be a scalar.")
  773:     iaxis = normalize_axis_index(iaxis, c.ndim)
  774: 
  775:     if cnt == 0:
  776:         return c
  777: 
  778:     c = np.moveaxis(c, iaxis, 0)
  779:     k = list(k) + [0] * (cnt - len(k))
  780:     for i in range(cnt):
  781:         n = len(c)
  782:         c *= scl
  783:         if n == 1 and np.all(c[0] == 0):
  784:             c[0] += k[i]
  785:         else:
  786:             tmp = np.empty((n + 1,) + c.shape[1:], dtype=c.dtype)
  787:             tmp[0] = c[0] * 0
  788:             tmp[1] = c[0]
  789:             for j in range(1, n):
  790:                 tmp[j + 1] = c[j] / (j + 1)
  791:             tmp[0] += k[i] - hermeval(lbnd, tmp)
  792:             c = tmp
  793:     c = np.moveaxis(c, 0, iaxis)
  794:     return c
  795: 
  796: 
  797: def hermeval(x, c, tensor=True):
  798:     """
  799:     Evaluate an HermiteE series at points x.
  800: 
  801:     If `c` is of length ``n + 1``, this function returns the value:
  802: 
  803:     .. math:: p(x) = c_0 * He_0(x) + c_1 * He_1(x) + ... + c_n * He_n(x)
  804: 
  805:     The parameter `x` is converted to an array only if it is a tuple or a
  806:     list, otherwise it is treated as a scalar. In either case, either `x`
  807:     or its elements must support multiplication and addition both with
  808:     themselves and with the elements of `c`.
  809: 
  810:     If `c` is a 1-D array, then ``p(x)`` will have the same shape as `x`.  If
  811:     `c` is multidimensional, then the shape of the result depends on the
  812:     value of `tensor`. If `tensor` is true the shape will be c.shape[1:] +
  813:     x.shape. If `tensor` is false the shape will be c.shape[1:]. Note that
  814:     scalars have shape (,).
  815: 
  816:     Trailing zeros in the coefficients will be used in the evaluation, so
  817:     they should be avoided if efficiency is a concern.
  818: 
  819:     Parameters
  820:     ----------
  821:     x : array_like, compatible object
  822:         If `x` is a list or tuple, it is converted to an ndarray, otherwise
  823:         it is left unchanged and treated as a scalar. In either case, `x`
  824:         or its elements must support addition and multiplication with
  825:         with themselves and with the elements of `c`.
  826:     c : array_like
  827:         Array of coefficients ordered so that the coefficients for terms of
  828:         degree n are contained in c[n]. If `c` is multidimensional the
  829:         remaining indices enumerate multiple polynomials. In the two
  830:         dimensional case the coefficients may be thought of as stored in
  831:         the columns of `c`.
  832:     tensor : boolean, optional
  833:         If True, the shape of the coefficient array is extended with ones
  834:         on the right, one for each dimension of `x`. Scalars have dimension 0
  835:         for this action. The result is that every column of coefficients in
  836:         `c` is evaluated for every element of `x`. If False, `x` is broadcast
  837:         over the columns of `c` for the evaluation.  This keyword is useful
  838:         when `c` is multidimensional. The default value is True.
  839: 
  840:     Returns
  841:     -------
  842:     values : ndarray, algebra_like
  843:         The shape of the return value is described above.
  844: 
  845:     See Also
  846:     --------
  847:     hermeval2d, hermegrid2d, hermeval3d, hermegrid3d
  848: 
  849:     Notes
  850:     -----
  851:     The evaluation uses Clenshaw recursion, aka synthetic division.
  852: 
  853:     Examples
  854:     --------
  855:     >>> from numpy.polynomial.hermite_e import hermeval
  856:     >>> coef = [1,2,3]
  857:     >>> hermeval(1, coef)
  858:     3.0
  859:     >>> hermeval([[1,2],[3,4]], coef)
  860:     array([[ 3., 14.],
  861:            [31., 54.]])
  862: 
  863:     """
  864:     c = np.array(c, ndmin=1, copy=None)
  865:     if c.dtype.char in '?bBhHiIlLqQpP':
  866:         c = c.astype(np.double)
  867:     if isinstance(x, (tuple, list)):
  868:         x = np.asarray(x)
  869:     if isinstance(x, np.ndarray) and tensor:
  870:         c = c.reshape(c.shape + (1,) * x.ndim)
  871: 
  872:     if len(c) == 1:
  873:         c0 = c[0]
  874:         c1 = 0
  875:     elif len(c) == 2:
  876:         c0 = c[0]
  877:         c1 = c[1]
  878:     else:
  879:         nd = len(c)
  880:         c0 = c[-2]
  881:         c1 = c[-1]
  882:         for i in range(3, len(c) + 1):
  883:             tmp = c0
  884:             nd = nd - 1
  885:             c0 = c[-i] - c1 * (nd - 1)
  886:             c1 = tmp + c1 * x
  887:     return c0 + c1 * x
  888: 
  889: 
  890: def hermeval2d(x, y, c):
  891:     """
  892:     Evaluate a 2-D HermiteE series at points (x, y).
  893: 
  894:     This function returns the values:
  895: 
  896:     .. math:: p(x,y) = \\sum_{i,j} c_{i,j} * He_i(x) * He_j(y)
  897: 
  898:     The parameters `x` and `y` are converted to arrays only if they are
  899:     tuples or a lists, otherwise they are treated as a scalars and they
  900:     must have the same shape after conversion. In either case, either `x`
  901:     and `y` or their elements must support multiplication and addition both
  902:     with themselves and with the elements of `c`.
  903: 
  904:     If `c` is a 1-D array a one is implicitly appended to its shape to make
  905:     it 2-D. The shape of the result will be c.shape[2:] + x.shape.
  906: 
  907:     Parameters
  908:     ----------
  909:     x, y : array_like, compatible objects
  910:         The two dimensional series is evaluated at the points ``(x, y)``,
  911:         where `x` and `y` must have the same shape. If `x` or `y` is a list
  912:         or tuple, it is first converted to an ndarray, otherwise it is left
  913:         unchanged and if it isn't an ndarray it is treated as a scalar.
  914:     c : array_like
  915:         Array of coefficients ordered so that the coefficient of the term
  916:         of multi-degree i,j is contained in ``c[i,j]``. If `c` has
  917:         dimension greater than two the remaining indices enumerate multiple
  918:         sets of coefficients.
  919: 
  920:     Returns
  921:     -------
  922:     values : ndarray, compatible object
  923:         The values of the two dimensional polynomial at points formed with
  924:         pairs of corresponding values from `x` and `y`.
  925: 
  926:     See Also
  927:     --------
  928:     hermeval, hermegrid2d, hermeval3d, hermegrid3d
  929:     """
  930:     return pu._valnd(hermeval, c, x, y)
  931: 
  932: 
  933: def hermegrid2d(x, y, c):
  934:     """
  935:     Evaluate a 2-D HermiteE series on the Cartesian product of x and y.
  936: 
  937:     This function returns the values:
  938: 
  939:     .. math:: p(a,b) = \\sum_{i,j} c_{i,j} * H_i(a) * H_j(b)
  940: 
  941:     where the points ``(a, b)`` consist of all pairs formed by taking
  942:     `a` from `x` and `b` from `y`. The resulting points form a grid with
  943:     `x` in the first dimension and `y` in the second.
  944: 
  945:     The parameters `x` and `y` are converted to arrays only if they are
  946:     tuples or a lists, otherwise they are treated as a scalars. In either
  947:     case, either `x` and `y` or their elements must support multiplication
  948:     and addition both with themselves and with the elements of `c`.
  949: 
  950:     If `c` has fewer than two dimensions, ones are implicitly appended to
  951:     its shape to make it 2-D. The shape of the result will be c.shape[2:] +
  952:     x.shape.
  953: 
  954:     Parameters
  955:     ----------
  956:     x, y : array_like, compatible objects
  957:         The two dimensional series is evaluated at the points in the
  958:         Cartesian product of `x` and `y`.  If `x` or `y` is a list or
  959:         tuple, it is first converted to an ndarray, otherwise it is left
  960:         unchanged and, if it isn't an ndarray, it is treated as a scalar.
  961:     c : array_like
  962:         Array of coefficients ordered so that the coefficients for terms of
  963:         degree i,j are contained in ``c[i,j]``. If `c` has dimension
  964:         greater than two the remaining indices enumerate multiple sets of
  965:         coefficients.
  966: 
  967:     Returns
  968:     -------
  969:     values : ndarray, compatible object
  970:         The values of the two dimensional polynomial at points in the Cartesian
  971:         product of `x` and `y`.
  972: 
  973:     See Also
  974:     --------
  975:     hermeval, hermeval2d, hermeval3d, hermegrid3d
  976:     """
  977:     return pu._gridnd(hermeval, c, x, y)
  978: 
  979: 
  980: def hermeval3d(x, y, z, c):
  981:     """
  982:     Evaluate a 3-D Hermite_e series at points (x, y, z).
  983: 
  984:     This function returns the values:
  985: 
  986:     .. math:: p(x,y,z) = \\sum_{i,j,k} c_{i,j,k} * He_i(x) * He_j(y) * He_k(z)
  987: 
  988:     The parameters `x`, `y`, and `z` are converted to arrays only if
  989:     they are tuples or a lists, otherwise they are treated as a scalars and
  990:     they must have the same shape after conversion. In either case, either
  991:     `x`, `y`, and `z` or their elements must support multiplication and
  992:     addition both with themselves and with the elements of `c`.
  993: 
  994:     If `c` has fewer than 3 dimensions, ones are implicitly appended to its
  995:     shape to make it 3-D. The shape of the result will be c.shape[3:] +
  996:     x.shape.
  997: 
  998:     Parameters
  999:     ----------
 1000:     x, y, z : array_like, compatible object
 1001:         The three dimensional series is evaluated at the points
 1002:         `(x, y, z)`, where `x`, `y`, and `z` must have the same shape.  If
 1003:         any of `x`, `y`, or `z` is a list or tuple, it is first converted
 1004:         to an ndarray, otherwise it is left unchanged and if it isn't an
 1005:         ndarray it is  treated as a scalar.
 1006:     c : array_like
 1007:         Array of coefficients ordered so that the coefficient of the term of
 1008:         multi-degree i,j,k is contained in ``c[i,j,k]``. If `c` has dimension
 1009:         greater than 3 the remaining indices enumerate multiple sets of
 1010:         coefficients.
 1011: 
 1012:     Returns
 1013:     -------
 1014:     values : ndarray, compatible object
 1015:         The values of the multidimensional polynomial on points formed with
 1016:         triples of corresponding values from `x`, `y`, and `z`.
 1017: 
 1018:     See Also
 1019:     --------
 1020:     hermeval, hermeval2d, hermegrid2d, hermegrid3d
 1021:     """
 1022:     return pu._valnd(hermeval, c, x, y, z)
 1023: 
 1024: 
 1025: def hermegrid3d(x, y, z, c):
 1026:     """
 1027:     Evaluate a 3-D HermiteE series on the Cartesian product of x, y, and z.
 1028: 
 1029:     This function returns the values:
 1030: 
 1031:     .. math:: p(a,b,c) = \\sum_{i,j,k} c_{i,j,k} * He_i(a) * He_j(b) * He_k(c)
 1032: 
 1033:     where the points ``(a, b, c)`` consist of all triples formed by taking
 1034:     `a` from `x`, `b` from `y`, and `c` from `z`. The resulting points form
 1035:     a grid with `x` in the first dimension, `y` in the second, and `z` in
 1036:     the third.
 1037: 
 1038:     The parameters `x`, `y`, and `z` are converted to arrays only if they
 1039:     are tuples or a lists, otherwise they are treated as a scalars. In
 1040:     either case, either `x`, `y`, and `z` or their elements must support
 1041:     multiplication and addition both with themselves and with the elements
 1042:     of `c`.
 1043: 
 1044:     If `c` has fewer than three dimensions, ones are implicitly appended to
 1045:     its shape to make it 3-D. The shape of the result will be c.shape[3:] +
 1046:     x.shape + y.shape + z.shape.
 1047: 
 1048:     Parameters
 1049:     ----------
 1050:     x, y, z : array_like, compatible objects
 1051:         The three dimensional series is evaluated at the points in the
 1052:         Cartesian product of `x`, `y`, and `z`.  If `x`, `y`, or `z` is a
 1053:         list or tuple, it is first converted to an ndarray, otherwise it is
 1054:         left unchanged and, if it isn't an ndarray, it is treated as a
 1055:         scalar.
 1056:     c : array_like
 1057:         Array of coefficients ordered so that the coefficients for terms of
 1058:         degree i,j are contained in ``c[i,j]``. If `c` has dimension
 1059:         greater than two the remaining indices enumerate multiple sets of
 1060:         coefficients.
 1061: 
 1062:     Returns
 1063:     -------
 1064:     values : ndarray, compatible object
 1065:         The values of the two dimensional polynomial at points in the Cartesian
 1066:         product of `x` and `y`.
 1067: 
 1068:     See Also
 1069:     --------
 1070:     hermeval, hermeval2d, hermegrid2d, hermeval3d
 1071:     """
 1072:     return pu._gridnd(hermeval, c, x, y, z)
 1073: 
 1074: 
 1075: def hermevander(x, deg):
 1076:     """Pseudo-Vandermonde matrix of given degree.
 1077: 
 1078:     Returns the pseudo-Vandermonde matrix of degree `deg` and sample points
 1079:     `x`. The pseudo-Vandermonde matrix is defined by
 1080: 
 1081:     .. math:: V[..., i] = He_i(x),
 1082: 
 1083:     where ``0 <= i <= deg``. The leading indices of `V` index the elements of
 1084:     `x` and the last index is the degree of the HermiteE polynomial.
 1085: 
 1086:     If `c` is a 1-D array of coefficients of length ``n + 1`` and `V` is the
 1087:     array ``V = hermevander(x, n)``, then ``np.dot(V, c)`` and
 1088:     ``hermeval(x, c)`` are the same up to roundoff. This equivalence is
 1089:     useful both for least squares fitting and for the evaluation of a large
 1090:     number of HermiteE series of the same degree and sample points.
 1091: 
 1092:     Parameters
 1093:     ----------
 1094:     x : array_like
 1095:         Array of points. The dtype is converted to float64 or complex128
 1096:         depending on whether any of the elements are complex. If `x` is
 1097:         scalar it is converted to a 1-D array.
 1098:     deg : int
 1099:         Degree of the resulting matrix.
 1100: 
 1101:     Returns
 1102:     -------
 1103:     vander : ndarray
 1104:         The pseudo-Vandermonde matrix. The shape of the returned matrix is
 1105:         ``x.shape + (deg + 1,)``, where The last index is the degree of the
 1106:         corresponding HermiteE polynomial.  The dtype will be the same as
 1107:         the converted `x`.
 1108: 
 1109:     Examples
 1110:     --------
 1111:     >>> import numpy as np
 1112:     >>> from numpy.polynomial.hermite_e import hermevander
 1113:     >>> x = np.array([-1, 0, 1])
 1114:     >>> hermevander(x, 3)
 1115:     array([[ 1., -1.,  0.,  2.],
 1116:            [ 1.,  0., -1., -0.],
 1117:            [ 1.,  1.,  0., -2.]])
 1118: 
 1119:     """
 1120:     ideg = pu._as_int(deg, "deg")
 1121:     if ideg < 0:
 1122:         raise ValueError("deg must be non-negative")
 1123: 
 1124:     x = np.array(x, copy=None, ndmin=1) + 0.0
 1125:     dims = (ideg + 1,) + x.shape
 1126:     dtyp = x.dtype
 1127:     v = np.empty(dims, dtype=dtyp)
 1128:     v[0] = x * 0 + 1
 1129:     if ideg > 0:
 1130:         v[1] = x
 1131:         for i in range(2, ideg + 1):
 1132:             v[i] = (v[i - 1] * x - v[i - 2] * (i - 1))
 1133:     return np.moveaxis(v, 0, -1)
 1134: 
 1135: 
 1136: def hermevander2d(x, y, deg):
 1137:     """Pseudo-Vandermonde matrix of given degrees.
 1138: 
 1139:     Returns the pseudo-Vandermonde matrix of degrees `deg` and sample
 1140:     points ``(x, y)``. The pseudo-Vandermonde matrix is defined by
 1141: 
 1142:     .. math:: V[..., (deg[1] + 1)*i + j] = He_i(x) * He_j(y),
 1143: 
 1144:     where ``0 <= i <= deg[0]`` and ``0 <= j <= deg[1]``. The leading indices of
 1145:     `V` index the points ``(x, y)`` and the last index encodes the degrees of
 1146:     the HermiteE polynomials.
 1147: 
 1148:     If ``V = hermevander2d(x, y, [xdeg, ydeg])``, then the columns of `V`
 1149:     correspond to the elements of a 2-D coefficient array `c` of shape
 1150:     (xdeg + 1, ydeg + 1) in the order
 1151: 
 1152:     .. math:: c_{00}, c_{01}, c_{02} ... , c_{10}, c_{11}, c_{12} ...
 1153: 
 1154:     and ``np.dot(V, c.flat)`` and ``hermeval2d(x, y, c)`` will be the same
 1155:     up to roundoff. This equivalence is useful both for least squares
 1156:     fitting and for the evaluation of a large number of 2-D HermiteE
 1157:     series of the same degrees and sample points.
 1158: 
 1159:     Parameters
 1160:     ----------
 1161:     x, y : array_like
 1162:         Arrays of point coordinates, all of the same shape. The dtypes
 1163:         will be converted to either float64 or complex128 depending on
 1164:         whether any of the elements are complex. Scalars are converted to
 1165:         1-D arrays.
 1166:     deg : list of ints
 1167:         List of maximum degrees of the form [x_deg, y_deg].
 1168: 
 1169:     Returns
 1170:     -------
 1171:     vander2d : ndarray
 1172:         The shape of the returned matrix is ``x.shape + (order,)``, where
 1173:         :math:`order = (deg[0]+1)*(deg[1]+1)`.  The dtype will be the same
 1174:         as the converted `x` and `y`.
 1175: 
 1176:     See Also
 1177:     --------
 1178:     hermevander, hermevander3d, hermeval2d, hermeval3d
 1179:     """
 1180:     return pu._vander_nd_flat((hermevander, hermevander), (x, y), deg)
 1181: 
 1182: 
 1183: def hermevander3d(x, y, z, deg):
 1184:     """Pseudo-Vandermonde matrix of given degrees.
 1185: 
 1186:     Returns the pseudo-Vandermonde matrix of degrees `deg` and sample
 1187:     points ``(x, y, z)``. If `l`, `m`, `n` are the given degrees in `x`, `y`, `z`,
 1188:     then Hehe pseudo-Vandermonde matrix is defined by
 1189: 
 1190:     .. math:: V[..., (m+1)(n+1)i + (n+1)j + k] = He_i(x)*He_j(y)*He_k(z),
 1191: 
 1192:     where ``0 <= i <= l``, ``0 <= j <= m``, and ``0 <= j <= n``.  The leading
 1193:     indices of `V` index the points ``(x, y, z)`` and the last index encodes
 1194:     the degrees of the HermiteE polynomials.
 1195: 
 1196:     If ``V = hermevander3d(x, y, z, [xdeg, ydeg, zdeg])``, then the columns
 1197:     of `V` correspond to the elements of a 3-D coefficient array `c` of
 1198:     shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order
 1199: 
 1200:     .. math:: c_{000}, c_{001}, c_{002},... , c_{010}, c_{011}, c_{012},...
 1201: 
 1202:     and  ``np.dot(V, c.flat)`` and ``hermeval3d(x, y, z, c)`` will be the
 1203:     same up to roundoff. This equivalence is useful both for least squares
 1204:     fitting and for the evaluation of a large number of 3-D HermiteE
 1205:     series of the same degrees and sample points.
 1206: 
 1207:     Parameters
 1208:     ----------
 1209:     x, y, z : array_like
 1210:         Arrays of point coordinates, all of the same shape. The dtypes will
 1211:         be converted to either float64 or complex128 depending on whether
 1212:         any of the elements are complex. Scalars are converted to 1-D
 1213:         arrays.
 1214:     deg : list of ints
 1215:         List of maximum degrees of the form [x_deg, y_deg, z_deg].
 1216: 
 1217:     Returns
 1218:     -------
 1219:     vander3d : ndarray
 1220:         The shape of the returned matrix is ``x.shape + (order,)``, where
 1221:         :math:`order = (deg[0]+1)*(deg[1]+1)*(deg[2]+1)`.  The dtype will
 1222:         be the same as the converted `x`, `y`, and `z`.
 1223: 
 1224:     See Also
 1225:     --------
 1226:     hermevander, hermevander3d, hermeval2d, hermeval3d
 1227:     """
 1228:     return pu._vander_nd_flat((hermevander, hermevander, hermevander), (x, y, z), deg)
 1229: 
 1230: 
 1231: def hermefit(x, y, deg, rcond=None, full=False, w=None):
 1232:     """
 1233:     Least squares fit of Hermite series to data.
 1234: 
 1235:     Return the coefficients of a HermiteE series of degree `deg` that is
 1236:     the least squares fit to the data values `y` given at points `x`. If
 1237:     `y` is 1-D the returned coefficients will also be 1-D. If `y` is 2-D
 1238:     multiple fits are done, one for each column of `y`, and the resulting
 1239:     coefficients are stored in the corresponding columns of a 2-D return.
 1240:     The fitted polynomial(s) are in the form
 1241: 
 1242:     .. math::  p(x) = c_0 + c_1 * He_1(x) + ... + c_n * He_n(x),
 1243: 
 1244:     where `n` is `deg`.
 1245: 
 1246:     Parameters
 1247:     ----------
 1248:     x : array_like, shape (M,)
 1249:         x-coordinates of the M sample points ``(x[i], y[i])``.
 1250:     y : array_like, shape (M,) or (M, K)
 1251:         y-coordinates of the sample points. Several data sets of sample
 1252:         points sharing the same x-coordinates can be fitted at once by
 1253:         passing in a 2D-array that contains one dataset per column.
 1254:     deg : int or 1-D array_like
 1255:         Degree(s) of the fitting polynomials. If `deg` is a single integer
 1256:         all terms up to and including the `deg`'th term are included in the
 1257:         fit. For NumPy versions >= 1.11.0 a list of integers specifying the
 1258:         degrees of the terms to include may be used instead.
 1259:     rcond : float, optional
 1260:         Relative condition number of the fit. Singular values smaller than
 1261:         this relative to the largest singular value will be ignored. The
 1262:         default value is len(x)*eps, where eps is the relative precision of
 1263:         the float type, about 2e-16 in most cases.
 1264:     full : bool, optional
 1265:         Switch determining nature of return value. When it is False (the
 1266:         default) just the coefficients are returned, when True diagnostic
 1267:         information from the singular value decomposition is also returned.
 1268:     w : array_like, shape (`M`,), optional
 1269:         Weights. If not None, the weight ``w[i]`` applies to the unsquared
 1270:         residual ``y[i] - y_hat[i]`` at ``x[i]``. Ideally the weights are
 1271:         chosen so that the errors of the products ``w[i]*y[i]`` all have the
 1272:         same variance.  When using inverse-variance weighting, use
 1273:         ``w[i] = 1/sigma(y[i])``.  The default value is None.
 1274: 
 1275:     Returns
 1276:     -------
 1277:     coef : ndarray, shape (M,) or (M, K)
 1278:         Hermite coefficients ordered from low to high. If `y` was 2-D,
 1279:         the coefficients for the data in column k  of `y` are in column
 1280:         `k`.
 1281: 
 1282:     [residuals, rank, singular_values, rcond] : list
 1283:         These values are only returned if ``full == True``
 1284: 
 1285:         - residuals -- sum of squared residuals of the least squares fit
 1286:         - rank -- the numerical rank of the scaled Vandermonde matrix
 1287:         - singular_values -- singular values of the scaled Vandermonde matrix
 1288:         - rcond -- value of `rcond`.
 1289: 
 1290:         For more details, see `numpy.linalg.lstsq`.
 1291: 
 1292:     Warns
 1293:     -----
 1294:     RankWarning
 1295:         The rank of the coefficient matrix in the least-squares fit is
 1296:         deficient. The warning is only raised if ``full = False``.  The
 1297:         warnings can be turned off by
 1298: 
 1299:         >>> import warnings
 1300:         >>> warnings.simplefilter('ignore', np.exceptions.RankWarning)
 1301: 
 1302:     See Also
 1303:     --------
 1304:     numpy.polynomial.chebyshev.chebfit
 1305:     numpy.polynomial.legendre.legfit
 1306:     numpy.polynomial.polynomial.polyfit
 1307:     numpy.polynomial.hermite.hermfit
 1308:     numpy.polynomial.laguerre.lagfit
 1309:     hermeval : Evaluates a Hermite series.
 1310:     hermevander : pseudo Vandermonde matrix of Hermite series.
 1311:     hermeweight : HermiteE weight function.
 1312:     numpy.linalg.lstsq : Computes a least-squares fit from the matrix.
 1313:     scipy.interpolate.UnivariateSpline : Computes spline fits.
 1314: 
 1315:     Notes
 1316:     -----
 1317:     The solution is the coefficients of the HermiteE series `p` that
 1318:     minimizes the sum of the weighted squared errors
 1319: 
 1320:     .. math:: E = \\sum_j w_j^2 * |y_j - p(x_j)|^2,
 1321: 
 1322:     where the :math:`w_j` are the weights. This problem is solved by
 1323:     setting up the (typically) overdetermined matrix equation
 1324: 
 1325:     .. math:: V(x) * c = w * y,
 1326: 
 1327:     where `V` is the pseudo Vandermonde matrix of `x`, the elements of `c`
 1328:     are the coefficients to be solved for, and the elements of `y` are the
 1329:     observed values.  This equation is then solved using the singular value
 1330:     decomposition of `V`.
 1331: 
 1332:     If some of the singular values of `V` are so small that they are
 1333:     neglected, then a `~exceptions.RankWarning` will be issued. This means that
 1334:     the coefficient values may be poorly determined. Using a lower order fit
 1335:     will usually get rid of the warning.  The `rcond` parameter can also be
 1336:     set to a value smaller than its default, but the resulting fit may be
 1337:     spurious and have large contributions from roundoff error.
 1338: 
 1339:     Fits using HermiteE series are probably most useful when the data can
 1340:     be approximated by ``sqrt(w(x)) * p(x)``, where ``w(x)`` is the HermiteE
 1341:     weight. In that case the weight ``sqrt(w(x[i]))`` should be used
 1342:     together with data values ``y[i]/sqrt(w(x[i]))``. The weight function is
 1343:     available as `hermeweight`.
 1344: 
 1345:     References
 1346:     ----------
 1347:     .. [1] Wikipedia, "Curve fitting",
 1348:            https://en.wikipedia.org/wiki/Curve_fitting
 1349: 
 1350:     Examples
 1351:     --------
 1352:     >>> import numpy as np
 1353:     >>> from numpy.polynomial.hermite_e import hermefit, hermeval
 1354:     >>> x = np.linspace(-10, 10)
 1355:     >>> rng = np.random.default_rng()
 1356:     >>> err = rng.normal(scale=1./10, size=len(x))
 1357:     >>> y = hermeval(x, [1, 2, 3]) + err
 1358:     >>> hermefit(x, y, 2)
 1359:     array([1.02284196, 2.00032805, 2.99978457]) # may vary
 1360: 
 1361:     """
 1362:     return pu._fit(hermevander, x, y, deg, rcond, full, w)
 1363: 
 1364: 
 1365: def hermecompanion(c):
 1366:     """
 1367:     Return the scaled companion matrix of c.
 1368: 
 1369:     The basis polynomials are scaled so that the companion matrix is
 1370:     symmetric when `c` is an HermiteE basis polynomial. This provides
 1371:     better eigenvalue estimates than the unscaled case and for basis
 1372:     polynomials the eigenvalues are guaranteed to be real if
 1373:     `numpy.linalg.eigvalsh` is used to obtain them.
 1374: 
 1375:     Parameters
 1376:     ----------
 1377:     c : array_like
 1378:         1-D array of HermiteE series coefficients ordered from low to high
 1379:         degree.
 1380: 
 1381:     Returns
 1382:     -------
 1383:     mat : ndarray
 1384:         Scaled companion matrix of dimensions (deg, deg).
 1385:     """
 1386:     # c is a trimmed copy
 1387:     [c] = pu.as_series([c])
 1388:     if len(c) < 2:
 1389:         raise ValueError('Series must have maximum degree of at least 1.')
 1390:     if len(c) == 2:
 1391:         return np.array([[-c[0] / c[1]]])
 1392: 
 1393:     n = len(c) - 1
 1394:     mat = np.zeros((n, n), dtype=c.dtype)
 1395:     scl = np.hstack((1., 1. / np.sqrt(np.arange(n - 1, 0, -1))))
 1396:     scl = np.multiply.accumulate(scl)[::-1]
 1397:     top = mat.reshape(-1)[1::n + 1]
 1398:     bot = mat.reshape(-1)[n::n + 1]
 1399:     top[...] = np.sqrt(np.arange(1, n))
 1400:     bot[...] = top
 1401:     mat[:, -1] -= scl * c[:-1] / c[-1]
 1402:     return mat
 1403: 
 1404: 
 1405: def hermeroots(c):
 1406:     """
 1407:     Compute the roots of a HermiteE series.
 1408: 
 1409:     Return the roots (a.k.a. "zeros") of the polynomial
 1410: 
 1411:     .. math:: p(x) = \\sum_i c[i] * He_i(x).
 1412: 
 1413:     Parameters
 1414:     ----------
 1415:     c : 1-D array_like
 1416:         1-D array of coefficients.
 1417: 
 1418:     Returns
 1419:     -------
 1420:     out : ndarray
 1421:         Array of the roots of the series. If all the roots are real,
 1422:         then `out` is also real, otherwise it is complex.
 1423: 
 1424:     See Also
 1425:     --------
 1426:     numpy.polynomial.polynomial.polyroots
 1427:     numpy.polynomial.legendre.legroots
 1428:     numpy.polynomial.laguerre.lagroots
 1429:     numpy.polynomial.hermite.hermroots
 1430:     numpy.polynomial.chebyshev.chebroots
 1431: 
 1432:     Notes
 1433:     -----
 1434:     The root estimates are obtained as the eigenvalues of the companion
 1435:     matrix, Roots far from the origin of the complex plane may have large
 1436:     errors due to the numerical instability of the series for such
 1437:     values. Roots with multiplicity greater than 1 will also show larger
 1438:     errors as the value of the series near such points is relatively
 1439:     insensitive to errors in the roots. Isolated roots near the origin can
 1440:     be improved by a few iterations of Newton's method.
 1441: 
 1442:     The HermiteE series basis polynomials aren't powers of `x` so the
 1443:     results of this function may seem unintuitive.
 1444: 
 1445:     Examples
 1446:     --------
 1447:     >>> from numpy.polynomial.hermite_e import hermeroots, hermefromroots
 1448:     >>> coef = hermefromroots([-1, 0, 1])
 1449:     >>> coef
 1450:     array([0., 2., 0., 1.])
 1451:     >>> hermeroots(coef)
 1452:     array([-1.,  0.,  1.]) # may vary
 1453: 
 1454:     """
 1455:     # c is a trimmed copy
 1456:     [c] = pu.as_series([c])
 1457:     if len(c) <= 1:
 1458:         return np.array([], dtype=c.dtype)
 1459:     if len(c) == 2:
 1460:         return np.array([-c[0] / c[1]])
 1461: 
 1462:     # rotated companion matrix reduces error
 1463:     m = hermecompanion(c)[::-1, ::-1]
 1464:     r = la.eigvals(m)
 1465:     r.sort()
 1466:     return r
 1467: 
 1468: 
 1469: def _normed_hermite_e_n(x, n):
 1470:     """
 1471:     Evaluate a normalized HermiteE polynomial.
 1472: 
 1473:     Compute the value of the normalized HermiteE polynomial of degree ``n``
 1474:     at the points ``x``.
 1475: 
 1476: 
 1477:     Parameters
 1478:     ----------
 1479:     x : ndarray of double.
 1480:         Points at which to evaluate the function
 1481:     n : int
 1482:         Degree of the normalized HermiteE function to be evaluated.
 1483: 
 1484:     Returns
 1485:     -------
 1486:     values : ndarray
 1487:         The shape of the return value is described above.
 1488: 
 1489:     Notes
 1490:     -----
 1491:     This function is needed for finding the Gauss points and integration
 1492:     weights for high degrees. The values of the standard HermiteE functions
 1493:     overflow when n >= 207.
 1494: 
 1495:     """
 1496:     if n == 0:
 1497:         return np.full(x.shape, 1 / np.sqrt(np.sqrt(2 * np.pi)))
 1498: 
 1499:     c0 = 0.
 1500:     c1 = 1. / np.sqrt(np.sqrt(2 * np.pi))
 1501:     nd = float(n)
 1502:     for i in range(n - 1):
 1503:         tmp = c0
 1504:         c0 = -c1 * np.sqrt((nd - 1.) / nd)
 1505:         c1 = tmp + c1 * x * np.sqrt(1. / nd)
 1506:         nd = nd - 1.0
 1507:     return c0 + c1 * x
 1508: 
 1509: 
 1510: def hermegauss(deg):
 1511:     """
 1512:     Gauss-HermiteE quadrature.
 1513: 
 1514:     Computes the sample points and weights for Gauss-HermiteE quadrature.
 1515:     These sample points and weights will correctly integrate polynomials of
 1516:     degree :math:`2*deg - 1` or less over the interval :math:`[-\\inf, \\inf]`
 1517:     with the weight function :math:`f(x) = \\exp(-x^2/2)`.
 1518: 
 1519:     Parameters
 1520:     ----------
 1521:     deg : int
 1522:         Number of sample points and weights. It must be >= 1.
 1523: 
 1524:     Returns
 1525:     -------
 1526:     x : ndarray
 1527:         1-D ndarray containing the sample points.
 1528:     y : ndarray
 1529:         1-D ndarray containing the weights.
 1530: 
 1531:     Notes
 1532:     -----
 1533:     The results have only been tested up to degree 100, higher degrees may
 1534:     be problematic. The weights are determined by using the fact that
 1535: 
 1536:     .. math:: w_k = c / (He'_n(x_k) * He_{n-1}(x_k))
 1537: 
 1538:     where :math:`c` is a constant independent of :math:`k` and :math:`x_k`
 1539:     is the k'th root of :math:`He_n`, and then scaling the results to get
 1540:     the right value when integrating 1.
 1541: 
 1542:     """
 1543:     ideg = pu._as_int(deg, "deg")
 1544:     if ideg <= 0:
 1545:         raise ValueError("deg must be a positive integer")
 1546: 
 1547:     # first approximation of roots. We use the fact that the companion
 1548:     # matrix is symmetric in this case in order to obtain better zeros.
 1549:     c = np.array([0] * deg + [1])
 1550:     m = hermecompanion(c)
 1551:     x = la.eigvalsh(m)
 1552: 
 1553:     # improve roots by one application of Newton
 1554:     dy = _normed_hermite_e_n(x, ideg)
 1555:     df = _normed_hermite_e_n(x, ideg - 1) * np.sqrt(ideg)
 1556:     x -= dy / df
 1557: 
 1558:     # compute the weights. We scale the factor to avoid possible numerical
 1559:     # overflow.
 1560:     fm = _normed_hermite_e_n(x, ideg - 1)
 1561:     fm /= np.abs(fm).max()
 1562:     w = 1 / (fm * fm)
 1563: 
 1564:     # for Hermite_e we can also symmetrize
 1565:     w = (w + w[::-1]) / 2
 1566:     x = (x - x[::-1]) / 2
 1567: 
 1568:     # scale w to get the right value
 1569:     w *= np.sqrt(2 * np.pi) / w.sum()
 1570: 
 1571:     return x, w
 1572: 
 1573: 
 1574: def hermeweight(x):
 1575:     """Weight function of the Hermite_e polynomials.
 1576: 
 1577:     The weight function is :math:`\\exp(-x^2/2)` and the interval of
 1578:     integration is :math:`[-\\inf, \\inf]`. the HermiteE polynomials are
 1579:     orthogonal, but not normalized, with respect to this weight function.
 1580: 
 1581:     Parameters
 1582:     ----------
 1583:     x : array_like
 1584:        Values at which the weight function will be computed.
 1585: 
 1586:     Returns
 1587:     -------
 1588:     w : ndarray
 1589:        The weight function at `x`.
 1590:     """
 1591:     w = np.exp(-.5 * x**2)
 1592:     return w
 1593: 
 1594: 
 1595: #
 1596: # HermiteE series class
 1597: #
 1598: 
 1599: class HermiteE(ABCPolyBase):
 1600:     """An HermiteE series class.
 1601: 
 1602:     The HermiteE class provides the standard Python numerical methods
 1603:     '+', '-', '*', '//', '%', 'divmod', '**', and '()' as well as the
 1604:     attributes and methods listed below.
 1605: 
 1606:     Parameters
 1607:     ----------
 1608:     coef : array_like
 1609:         HermiteE coefficients in order of increasing degree, i.e,
 1610:         ``(1, 2, 3)`` gives ``1*He_0(x) + 2*He_1(X) + 3*He_2(x)``.
 1611:     domain : (2,) array_like, optional
 1612:         Domain to use. The interval ``[domain[0], domain[1]]`` is mapped
 1613:         to the interval ``[window[0], window[1]]`` by shifting and scaling.
 1614:         The default value is [-1., 1.].
 1615:     window : (2,) array_like, optional
 1616:         Window, see `domain` for its use. The default value is [-1., 1.].
 1617:     symbol : str, optional
 1618:         Symbol used to represent the independent variable in string
 1619:         representations of the polynomial expression, e.g. for printing.
 1620:         The symbol must be a valid Python identifier. Default value is 'x'.
 1621: 
 1622:         .. versionadded:: 1.24
 1623: 
 1624:     """
 1625:     # Virtual Functions
 1626:     _add = staticmethod(hermeadd)
 1627:     _sub = staticmethod(hermesub)
 1628:     _mul = staticmethod(hermemul)
 1629:     _div = staticmethod(hermediv)
 1630:     _pow = staticmethod(hermepow)
 1631:     _val = staticmethod(hermeval)
 1632:     _int = staticmethod(hermeint)
 1633:     _der = staticmethod(hermeder)
 1634:     _fit = staticmethod(hermefit)
 1635:     _line = staticmethod(hermeline)
 1636:     _roots = staticmethod(hermeroots)
 1637:     _fromroots = staticmethod(hermefromroots)
 1638: 
 1639:     # Virtual properties
 1640:     domain = np.array(hermedomain)
 1641:     window = np.array(hermedomain)
 1642:     basis_name = 'He'
