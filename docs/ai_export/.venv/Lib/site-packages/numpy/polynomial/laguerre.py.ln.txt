    1: """
    2: ==================================================
    3: Laguerre Series (:mod:`numpy.polynomial.laguerre`)
    4: ==================================================
    5: 
    6: This module provides a number of objects (mostly functions) useful for
    7: dealing with Laguerre series, including a `Laguerre` class that
    8: encapsulates the usual arithmetic operations.  (General information
    9: on how this module represents and works with such polynomials is in the
   10: docstring for its "parent" sub-package, `numpy.polynomial`).
   11: 
   12: Classes
   13: -------
   14: .. autosummary::
   15:    :toctree: generated/
   16: 
   17:    Laguerre
   18: 
   19: Constants
   20: ---------
   21: .. autosummary::
   22:    :toctree: generated/
   23: 
   24:    lagdomain
   25:    lagzero
   26:    lagone
   27:    lagx
   28: 
   29: Arithmetic
   30: ----------
   31: .. autosummary::
   32:    :toctree: generated/
   33: 
   34:    lagadd
   35:    lagsub
   36:    lagmulx
   37:    lagmul
   38:    lagdiv
   39:    lagpow
   40:    lagval
   41:    lagval2d
   42:    lagval3d
   43:    laggrid2d
   44:    laggrid3d
   45: 
   46: Calculus
   47: --------
   48: .. autosummary::
   49:    :toctree: generated/
   50: 
   51:    lagder
   52:    lagint
   53: 
   54: Misc Functions
   55: --------------
   56: .. autosummary::
   57:    :toctree: generated/
   58: 
   59:    lagfromroots
   60:    lagroots
   61:    lagvander
   62:    lagvander2d
   63:    lagvander3d
   64:    laggauss
   65:    lagweight
   66:    lagcompanion
   67:    lagfit
   68:    lagtrim
   69:    lagline
   70:    lag2poly
   71:    poly2lag
   72: 
   73: See also
   74: --------
   75: `numpy.polynomial`
   76: 
   77: """
   78: import numpy as np
   79: import numpy.linalg as la
   80: from numpy.lib.array_utils import normalize_axis_index
   81: 
   82: from . import polyutils as pu
   83: from ._polybase import ABCPolyBase
   84: 
   85: __all__ = [
   86:     'lagzero', 'lagone', 'lagx', 'lagdomain', 'lagline', 'lagadd',
   87:     'lagsub', 'lagmulx', 'lagmul', 'lagdiv', 'lagpow', 'lagval', 'lagder',
   88:     'lagint', 'lag2poly', 'poly2lag', 'lagfromroots', 'lagvander',
   89:     'lagfit', 'lagtrim', 'lagroots', 'Laguerre', 'lagval2d', 'lagval3d',
   90:     'laggrid2d', 'laggrid3d', 'lagvander2d', 'lagvander3d', 'lagcompanion',
   91:     'laggauss', 'lagweight']
   92: 
   93: lagtrim = pu.trimcoef
   94: 
   95: 
   96: def poly2lag(pol):
   97:     """
   98:     poly2lag(pol)
   99: 
  100:     Convert a polynomial to a Laguerre series.
  101: 
  102:     Convert an array representing the coefficients of a polynomial (relative
  103:     to the "standard" basis) ordered from lowest degree to highest, to an
  104:     array of the coefficients of the equivalent Laguerre series, ordered
  105:     from lowest to highest degree.
  106: 
  107:     Parameters
  108:     ----------
  109:     pol : array_like
  110:         1-D array containing the polynomial coefficients
  111: 
  112:     Returns
  113:     -------
  114:     c : ndarray
  115:         1-D array containing the coefficients of the equivalent Laguerre
  116:         series.
  117: 
  118:     See Also
  119:     --------
  120:     lag2poly
  121: 
  122:     Notes
  123:     -----
  124:     The easy way to do conversions between polynomial basis sets
  125:     is to use the convert method of a class instance.
  126: 
  127:     Examples
  128:     --------
  129:     >>> import numpy as np
  130:     >>> from numpy.polynomial.laguerre import poly2lag
  131:     >>> poly2lag(np.arange(4))
  132:     array([ 23., -63.,  58., -18.])
  133: 
  134:     """
  135:     [pol] = pu.as_series([pol])
  136:     res = 0
  137:     for p in pol[::-1]:
  138:         res = lagadd(lagmulx(res), p)
  139:     return res
  140: 
  141: 
  142: def lag2poly(c):
  143:     """
  144:     Convert a Laguerre series to a polynomial.
  145: 
  146:     Convert an array representing the coefficients of a Laguerre series,
  147:     ordered from lowest degree to highest, to an array of the coefficients
  148:     of the equivalent polynomial (relative to the "standard" basis) ordered
  149:     from lowest to highest degree.
  150: 
  151:     Parameters
  152:     ----------
  153:     c : array_like
  154:         1-D array containing the Laguerre series coefficients, ordered
  155:         from lowest order term to highest.
  156: 
  157:     Returns
  158:     -------
  159:     pol : ndarray
  160:         1-D array containing the coefficients of the equivalent polynomial
  161:         (relative to the "standard" basis) ordered from lowest order term
  162:         to highest.
  163: 
  164:     See Also
  165:     --------
  166:     poly2lag
  167: 
  168:     Notes
  169:     -----
  170:     The easy way to do conversions between polynomial basis sets
  171:     is to use the convert method of a class instance.
  172: 
  173:     Examples
  174:     --------
  175:     >>> from numpy.polynomial.laguerre import lag2poly
  176:     >>> lag2poly([ 23., -63.,  58., -18.])
  177:     array([0., 1., 2., 3.])
  178: 
  179:     """
  180:     from .polynomial import polyadd, polymulx, polysub
  181: 
  182:     [c] = pu.as_series([c])
  183:     n = len(c)
  184:     if n == 1:
  185:         return c
  186:     else:
  187:         c0 = c[-2]
  188:         c1 = c[-1]
  189:         # i is the current degree of c1
  190:         for i in range(n - 1, 1, -1):
  191:             tmp = c0
  192:             c0 = polysub(c[i - 2], (c1 * (i - 1)) / i)
  193:             c1 = polyadd(tmp, polysub((2 * i - 1) * c1, polymulx(c1)) / i)
  194:         return polyadd(c0, polysub(c1, polymulx(c1)))
  195: 
  196: 
  197: #
  198: # These are constant arrays are of integer type so as to be compatible
  199: # with the widest range of other types, such as Decimal.
  200: #
  201: 
  202: # Laguerre
  203: lagdomain = np.array([0., 1.])
  204: 
  205: # Laguerre coefficients representing zero.
  206: lagzero = np.array([0])
  207: 
  208: # Laguerre coefficients representing one.
  209: lagone = np.array([1])
  210: 
  211: # Laguerre coefficients representing the identity x.
  212: lagx = np.array([1, -1])
  213: 
  214: 
  215: def lagline(off, scl):
  216:     """
  217:     Laguerre series whose graph is a straight line.
  218: 
  219:     Parameters
  220:     ----------
  221:     off, scl : scalars
  222:         The specified line is given by ``off + scl*x``.
  223: 
  224:     Returns
  225:     -------
  226:     y : ndarray
  227:         This module's representation of the Laguerre series for
  228:         ``off + scl*x``.
  229: 
  230:     See Also
  231:     --------
  232:     numpy.polynomial.polynomial.polyline
  233:     numpy.polynomial.chebyshev.chebline
  234:     numpy.polynomial.legendre.legline
  235:     numpy.polynomial.hermite.hermline
  236:     numpy.polynomial.hermite_e.hermeline
  237: 
  238:     Examples
  239:     --------
  240:     >>> from numpy.polynomial.laguerre import lagline, lagval
  241:     >>> lagval(0,lagline(3, 2))
  242:     3.0
  243:     >>> lagval(1,lagline(3, 2))
  244:     5.0
  245: 
  246:     """
  247:     if scl != 0:
  248:         return np.array([off + scl, -scl])
  249:     else:
  250:         return np.array([off])
  251: 
  252: 
  253: def lagfromroots(roots):
  254:     """
  255:     Generate a Laguerre series with given roots.
  256: 
  257:     The function returns the coefficients of the polynomial
  258: 
  259:     .. math:: p(x) = (x - r_0) * (x - r_1) * ... * (x - r_n),
  260: 
  261:     in Laguerre form, where the :math:`r_n` are the roots specified in `roots`.
  262:     If a zero has multiplicity n, then it must appear in `roots` n times.
  263:     For instance, if 2 is a root of multiplicity three and 3 is a root of
  264:     multiplicity 2, then `roots` looks something like [2, 2, 2, 3, 3]. The
  265:     roots can appear in any order.
  266: 
  267:     If the returned coefficients are `c`, then
  268: 
  269:     .. math:: p(x) = c_0 + c_1 * L_1(x) + ... +  c_n * L_n(x)
  270: 
  271:     The coefficient of the last term is not generally 1 for monic
  272:     polynomials in Laguerre form.
  273: 
  274:     Parameters
  275:     ----------
  276:     roots : array_like
  277:         Sequence containing the roots.
  278: 
  279:     Returns
  280:     -------
  281:     out : ndarray
  282:         1-D array of coefficients.  If all roots are real then `out` is a
  283:         real array, if some of the roots are complex, then `out` is complex
  284:         even if all the coefficients in the result are real (see Examples
  285:         below).
  286: 
  287:     See Also
  288:     --------
  289:     numpy.polynomial.polynomial.polyfromroots
  290:     numpy.polynomial.legendre.legfromroots
  291:     numpy.polynomial.chebyshev.chebfromroots
  292:     numpy.polynomial.hermite.hermfromroots
  293:     numpy.polynomial.hermite_e.hermefromroots
  294: 
  295:     Examples
  296:     --------
  297:     >>> from numpy.polynomial.laguerre import lagfromroots, lagval
  298:     >>> coef = lagfromroots((-1, 0, 1))
  299:     >>> lagval((-1, 0, 1), coef)
  300:     array([0.,  0.,  0.])
  301:     >>> coef = lagfromroots((-1j, 1j))
  302:     >>> lagval((-1j, 1j), coef)
  303:     array([0.+0.j, 0.+0.j])
  304: 
  305:     """
  306:     return pu._fromroots(lagline, lagmul, roots)
  307: 
  308: 
  309: def lagadd(c1, c2):
  310:     """
  311:     Add one Laguerre series to another.
  312: 
  313:     Returns the sum of two Laguerre series `c1` + `c2`.  The arguments
  314:     are sequences of coefficients ordered from lowest order term to
  315:     highest, i.e., [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.
  316: 
  317:     Parameters
  318:     ----------
  319:     c1, c2 : array_like
  320:         1-D arrays of Laguerre series coefficients ordered from low to
  321:         high.
  322: 
  323:     Returns
  324:     -------
  325:     out : ndarray
  326:         Array representing the Laguerre series of their sum.
  327: 
  328:     See Also
  329:     --------
  330:     lagsub, lagmulx, lagmul, lagdiv, lagpow
  331: 
  332:     Notes
  333:     -----
  334:     Unlike multiplication, division, etc., the sum of two Laguerre series
  335:     is a Laguerre series (without having to "reproject" the result onto
  336:     the basis set) so addition, just like that of "standard" polynomials,
  337:     is simply "component-wise."
  338: 
  339:     Examples
  340:     --------
  341:     >>> from numpy.polynomial.laguerre import lagadd
  342:     >>> lagadd([1, 2, 3], [1, 2, 3, 4])
  343:     array([2.,  4.,  6.,  4.])
  344: 
  345:     """
  346:     return pu._add(c1, c2)
  347: 
  348: 
  349: def lagsub(c1, c2):
  350:     """
  351:     Subtract one Laguerre series from another.
  352: 
  353:     Returns the difference of two Laguerre series `c1` - `c2`.  The
  354:     sequences of coefficients are from lowest order term to highest, i.e.,
  355:     [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.
  356: 
  357:     Parameters
  358:     ----------
  359:     c1, c2 : array_like
  360:         1-D arrays of Laguerre series coefficients ordered from low to
  361:         high.
  362: 
  363:     Returns
  364:     -------
  365:     out : ndarray
  366:         Of Laguerre series coefficients representing their difference.
  367: 
  368:     See Also
  369:     --------
  370:     lagadd, lagmulx, lagmul, lagdiv, lagpow
  371: 
  372:     Notes
  373:     -----
  374:     Unlike multiplication, division, etc., the difference of two Laguerre
  375:     series is a Laguerre series (without having to "reproject" the result
  376:     onto the basis set) so subtraction, just like that of "standard"
  377:     polynomials, is simply "component-wise."
  378: 
  379:     Examples
  380:     --------
  381:     >>> from numpy.polynomial.laguerre import lagsub
  382:     >>> lagsub([1, 2, 3, 4], [1, 2, 3])
  383:     array([0.,  0.,  0.,  4.])
  384: 
  385:     """
  386:     return pu._sub(c1, c2)
  387: 
  388: 
  389: def lagmulx(c):
  390:     """Multiply a Laguerre series by x.
  391: 
  392:     Multiply the Laguerre series `c` by x, where x is the independent
  393:     variable.
  394: 
  395: 
  396:     Parameters
  397:     ----------
  398:     c : array_like
  399:         1-D array of Laguerre series coefficients ordered from low to
  400:         high.
  401: 
  402:     Returns
  403:     -------
  404:     out : ndarray
  405:         Array representing the result of the multiplication.
  406: 
  407:     See Also
  408:     --------
  409:     lagadd, lagsub, lagmul, lagdiv, lagpow
  410: 
  411:     Notes
  412:     -----
  413:     The multiplication uses the recursion relationship for Laguerre
  414:     polynomials in the form
  415: 
  416:     .. math::
  417: 
  418:         xP_i(x) = (-(i + 1)*P_{i + 1}(x) + (2i + 1)P_{i}(x) - iP_{i - 1}(x))
  419: 
  420:     Examples
  421:     --------
  422:     >>> from numpy.polynomial.laguerre import lagmulx
  423:     >>> lagmulx([1, 2, 3])
  424:     array([-1.,  -1.,  11.,  -9.])
  425: 
  426:     """
  427:     # c is a trimmed copy
  428:     [c] = pu.as_series([c])
  429:     # The zero series needs special treatment
  430:     if len(c) == 1 and c[0] == 0:
  431:         return c
  432: 
  433:     prd = np.empty(len(c) + 1, dtype=c.dtype)
  434:     prd[0] = c[0]
  435:     prd[1] = -c[0]
  436:     for i in range(1, len(c)):
  437:         prd[i + 1] = -c[i] * (i + 1)
  438:         prd[i] += c[i] * (2 * i + 1)
  439:         prd[i - 1] -= c[i] * i
  440:     return prd
  441: 
  442: 
  443: def lagmul(c1, c2):
  444:     """
  445:     Multiply one Laguerre series by another.
  446: 
  447:     Returns the product of two Laguerre series `c1` * `c2`.  The arguments
  448:     are sequences of coefficients, from lowest order "term" to highest,
  449:     e.g., [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.
  450: 
  451:     Parameters
  452:     ----------
  453:     c1, c2 : array_like
  454:         1-D arrays of Laguerre series coefficients ordered from low to
  455:         high.
  456: 
  457:     Returns
  458:     -------
  459:     out : ndarray
  460:         Of Laguerre series coefficients representing their product.
  461: 
  462:     See Also
  463:     --------
  464:     lagadd, lagsub, lagmulx, lagdiv, lagpow
  465: 
  466:     Notes
  467:     -----
  468:     In general, the (polynomial) product of two C-series results in terms
  469:     that are not in the Laguerre polynomial basis set.  Thus, to express
  470:     the product as a Laguerre series, it is necessary to "reproject" the
  471:     product onto said basis set, which may produce "unintuitive" (but
  472:     correct) results; see Examples section below.
  473: 
  474:     Examples
  475:     --------
  476:     >>> from numpy.polynomial.laguerre import lagmul
  477:     >>> lagmul([1, 2, 3], [0, 1, 2])
  478:     array([  8., -13.,  38., -51.,  36.])
  479: 
  480:     """
  481:     # s1, s2 are trimmed copies
  482:     [c1, c2] = pu.as_series([c1, c2])
  483: 
  484:     if len(c1) > len(c2):
  485:         c = c2
  486:         xs = c1
  487:     else:
  488:         c = c1
  489:         xs = c2
  490: 
  491:     if len(c) == 1:
  492:         c0 = c[0] * xs
  493:         c1 = 0
  494:     elif len(c) == 2:
  495:         c0 = c[0] * xs
  496:         c1 = c[1] * xs
  497:     else:
  498:         nd = len(c)
  499:         c0 = c[-2] * xs
  500:         c1 = c[-1] * xs
  501:         for i in range(3, len(c) + 1):
  502:             tmp = c0
  503:             nd = nd - 1
  504:             c0 = lagsub(c[-i] * xs, (c1 * (nd - 1)) / nd)
  505:             c1 = lagadd(tmp, lagsub((2 * nd - 1) * c1, lagmulx(c1)) / nd)
  506:     return lagadd(c0, lagsub(c1, lagmulx(c1)))
  507: 
  508: 
  509: def lagdiv(c1, c2):
  510:     """
  511:     Divide one Laguerre series by another.
  512: 
  513:     Returns the quotient-with-remainder of two Laguerre series
  514:     `c1` / `c2`.  The arguments are sequences of coefficients from lowest
  515:     order "term" to highest, e.g., [1,2,3] represents the series
  516:     ``P_0 + 2*P_1 + 3*P_2``.
  517: 
  518:     Parameters
  519:     ----------
  520:     c1, c2 : array_like
  521:         1-D arrays of Laguerre series coefficients ordered from low to
  522:         high.
  523: 
  524:     Returns
  525:     -------
  526:     [quo, rem] : ndarrays
  527:         Of Laguerre series coefficients representing the quotient and
  528:         remainder.
  529: 
  530:     See Also
  531:     --------
  532:     lagadd, lagsub, lagmulx, lagmul, lagpow
  533: 
  534:     Notes
  535:     -----
  536:     In general, the (polynomial) division of one Laguerre series by another
  537:     results in quotient and remainder terms that are not in the Laguerre
  538:     polynomial basis set.  Thus, to express these results as a Laguerre
  539:     series, it is necessary to "reproject" the results onto the Laguerre
  540:     basis set, which may produce "unintuitive" (but correct) results; see
  541:     Examples section below.
  542: 
  543:     Examples
  544:     --------
  545:     >>> from numpy.polynomial.laguerre import lagdiv
  546:     >>> lagdiv([  8., -13.,  38., -51.,  36.], [0, 1, 2])
  547:     (array([1., 2., 3.]), array([0.]))
  548:     >>> lagdiv([  9., -12.,  38., -51.,  36.], [0, 1, 2])
  549:     (array([1., 2., 3.]), array([1., 1.]))
  550: 
  551:     """
  552:     return pu._div(lagmul, c1, c2)
  553: 
  554: 
  555: def lagpow(c, pow, maxpower=16):
  556:     """Raise a Laguerre series to a power.
  557: 
  558:     Returns the Laguerre series `c` raised to the power `pow`. The
  559:     argument `c` is a sequence of coefficients ordered from low to high.
  560:     i.e., [1,2,3] is the series  ``P_0 + 2*P_1 + 3*P_2.``
  561: 
  562:     Parameters
  563:     ----------
  564:     c : array_like
  565:         1-D array of Laguerre series coefficients ordered from low to
  566:         high.
  567:     pow : integer
  568:         Power to which the series will be raised
  569:     maxpower : integer, optional
  570:         Maximum power allowed. This is mainly to limit growth of the series
  571:         to unmanageable size. Default is 16
  572: 
  573:     Returns
  574:     -------
  575:     coef : ndarray
  576:         Laguerre series of power.
  577: 
  578:     See Also
  579:     --------
  580:     lagadd, lagsub, lagmulx, lagmul, lagdiv
  581: 
  582:     Examples
  583:     --------
  584:     >>> from numpy.polynomial.laguerre import lagpow
  585:     >>> lagpow([1, 2, 3], 2)
  586:     array([ 14., -16.,  56., -72.,  54.])
  587: 
  588:     """
  589:     return pu._pow(lagmul, c, pow, maxpower)
  590: 
  591: 
  592: def lagder(c, m=1, scl=1, axis=0):
  593:     """
  594:     Differentiate a Laguerre series.
  595: 
  596:     Returns the Laguerre series coefficients `c` differentiated `m` times
  597:     along `axis`.  At each iteration the result is multiplied by `scl` (the
  598:     scaling factor is for use in a linear change of variable). The argument
  599:     `c` is an array of coefficients from low to high degree along each
  600:     axis, e.g., [1,2,3] represents the series ``1*L_0 + 2*L_1 + 3*L_2``
  601:     while [[1,2],[1,2]] represents ``1*L_0(x)*L_0(y) + 1*L_1(x)*L_0(y) +
  602:     2*L_0(x)*L_1(y) + 2*L_1(x)*L_1(y)`` if axis=0 is ``x`` and axis=1 is
  603:     ``y``.
  604: 
  605:     Parameters
  606:     ----------
  607:     c : array_like
  608:         Array of Laguerre series coefficients. If `c` is multidimensional
  609:         the different axis correspond to different variables with the
  610:         degree in each axis given by the corresponding index.
  611:     m : int, optional
  612:         Number of derivatives taken, must be non-negative. (Default: 1)
  613:     scl : scalar, optional
  614:         Each differentiation is multiplied by `scl`.  The end result is
  615:         multiplication by ``scl**m``.  This is for use in a linear change of
  616:         variable. (Default: 1)
  617:     axis : int, optional
  618:         Axis over which the derivative is taken. (Default: 0).
  619: 
  620:     Returns
  621:     -------
  622:     der : ndarray
  623:         Laguerre series of the derivative.
  624: 
  625:     See Also
  626:     --------
  627:     lagint
  628: 
  629:     Notes
  630:     -----
  631:     In general, the result of differentiating a Laguerre series does not
  632:     resemble the same operation on a power series. Thus the result of this
  633:     function may be "unintuitive," albeit correct; see Examples section
  634:     below.
  635: 
  636:     Examples
  637:     --------
  638:     >>> from numpy.polynomial.laguerre import lagder
  639:     >>> lagder([ 1.,  1.,  1., -3.])
  640:     array([1.,  2.,  3.])
  641:     >>> lagder([ 1.,  0.,  0., -4.,  3.], m=2)
  642:     array([1.,  2.,  3.])
  643: 
  644:     """
  645:     c = np.array(c, ndmin=1, copy=True)
  646:     if c.dtype.char in '?bBhHiIlLqQpP':
  647:         c = c.astype(np.double)
  648: 
  649:     cnt = pu._as_int(m, "the order of derivation")
  650:     iaxis = pu._as_int(axis, "the axis")
  651:     if cnt < 0:
  652:         raise ValueError("The order of derivation must be non-negative")
  653:     iaxis = normalize_axis_index(iaxis, c.ndim)
  654: 
  655:     if cnt == 0:
  656:         return c
  657: 
  658:     c = np.moveaxis(c, iaxis, 0)
  659:     n = len(c)
  660:     if cnt >= n:
  661:         c = c[:1] * 0
  662:     else:
  663:         for i in range(cnt):
  664:             n = n - 1
  665:             c *= scl
  666:             der = np.empty((n,) + c.shape[1:], dtype=c.dtype)
  667:             for j in range(n, 1, -1):
  668:                 der[j - 1] = -c[j]
  669:                 c[j - 1] += c[j]
  670:             der[0] = -c[1]
  671:             c = der
  672:     c = np.moveaxis(c, 0, iaxis)
  673:     return c
  674: 
  675: 
  676: def lagint(c, m=1, k=[], lbnd=0, scl=1, axis=0):
  677:     """
  678:     Integrate a Laguerre series.
  679: 
  680:     Returns the Laguerre series coefficients `c` integrated `m` times from
  681:     `lbnd` along `axis`. At each iteration the resulting series is
  682:     **multiplied** by `scl` and an integration constant, `k`, is added.
  683:     The scaling factor is for use in a linear change of variable.  ("Buyer
  684:     beware": note that, depending on what one is doing, one may want `scl`
  685:     to be the reciprocal of what one might expect; for more information,
  686:     see the Notes section below.)  The argument `c` is an array of
  687:     coefficients from low to high degree along each axis, e.g., [1,2,3]
  688:     represents the series ``L_0 + 2*L_1 + 3*L_2`` while [[1,2],[1,2]]
  689:     represents ``1*L_0(x)*L_0(y) + 1*L_1(x)*L_0(y) + 2*L_0(x)*L_1(y) +
  690:     2*L_1(x)*L_1(y)`` if axis=0 is ``x`` and axis=1 is ``y``.
  691: 
  692: 
  693:     Parameters
  694:     ----------
  695:     c : array_like
  696:         Array of Laguerre series coefficients. If `c` is multidimensional
  697:         the different axis correspond to different variables with the
  698:         degree in each axis given by the corresponding index.
  699:     m : int, optional
  700:         Order of integration, must be positive. (Default: 1)
  701:     k : {[], list, scalar}, optional
  702:         Integration constant(s).  The value of the first integral at
  703:         ``lbnd`` is the first value in the list, the value of the second
  704:         integral at ``lbnd`` is the second value, etc.  If ``k == []`` (the
  705:         default), all constants are set to zero.  If ``m == 1``, a single
  706:         scalar can be given instead of a list.
  707:     lbnd : scalar, optional
  708:         The lower bound of the integral. (Default: 0)
  709:     scl : scalar, optional
  710:         Following each integration the result is *multiplied* by `scl`
  711:         before the integration constant is added. (Default: 1)
  712:     axis : int, optional
  713:         Axis over which the integral is taken. (Default: 0).
  714: 
  715:     Returns
  716:     -------
  717:     S : ndarray
  718:         Laguerre series coefficients of the integral.
  719: 
  720:     Raises
  721:     ------
  722:     ValueError
  723:         If ``m < 0``, ``len(k) > m``, ``np.ndim(lbnd) != 0``, or
  724:         ``np.ndim(scl) != 0``.
  725: 
  726:     See Also
  727:     --------
  728:     lagder
  729: 
  730:     Notes
  731:     -----
  732:     Note that the result of each integration is *multiplied* by `scl`.
  733:     Why is this important to note?  Say one is making a linear change of
  734:     variable :math:`u = ax + b` in an integral relative to `x`.  Then
  735:     :math:`dx = du/a`, so one will need to set `scl` equal to
  736:     :math:`1/a` - perhaps not what one would have first thought.
  737: 
  738:     Also note that, in general, the result of integrating a C-series needs
  739:     to be "reprojected" onto the C-series basis set.  Thus, typically,
  740:     the result of this function is "unintuitive," albeit correct; see
  741:     Examples section below.
  742: 
  743:     Examples
  744:     --------
  745:     >>> from numpy.polynomial.laguerre import lagint
  746:     >>> lagint([1,2,3])
  747:     array([ 1.,  1.,  1., -3.])
  748:     >>> lagint([1,2,3], m=2)
  749:     array([ 1.,  0.,  0., -4.,  3.])
  750:     >>> lagint([1,2,3], k=1)
  751:     array([ 2.,  1.,  1., -3.])
  752:     >>> lagint([1,2,3], lbnd=-1)
  753:     array([11.5,  1. ,  1. , -3. ])
  754:     >>> lagint([1,2], m=2, k=[1,2], lbnd=-1)
  755:     array([ 11.16666667,  -5.        ,  -3.        ,   2.        ]) # may vary
  756: 
  757:     """
  758:     c = np.array(c, ndmin=1, copy=True)
  759:     if c.dtype.char in '?bBhHiIlLqQpP':
  760:         c = c.astype(np.double)
  761:     if not np.iterable(k):
  762:         k = [k]
  763:     cnt = pu._as_int(m, "the order of integration")
  764:     iaxis = pu._as_int(axis, "the axis")
  765:     if cnt < 0:
  766:         raise ValueError("The order of integration must be non-negative")
  767:     if len(k) > cnt:
  768:         raise ValueError("Too many integration constants")
  769:     if np.ndim(lbnd) != 0:
  770:         raise ValueError("lbnd must be a scalar.")
  771:     if np.ndim(scl) != 0:
  772:         raise ValueError("scl must be a scalar.")
  773:     iaxis = normalize_axis_index(iaxis, c.ndim)
  774: 
  775:     if cnt == 0:
  776:         return c
  777: 
  778:     c = np.moveaxis(c, iaxis, 0)
  779:     k = list(k) + [0] * (cnt - len(k))
  780:     for i in range(cnt):
  781:         n = len(c)
  782:         c *= scl
  783:         if n == 1 and np.all(c[0] == 0):
  784:             c[0] += k[i]
  785:         else:
  786:             tmp = np.empty((n + 1,) + c.shape[1:], dtype=c.dtype)
  787:             tmp[0] = c[0]
  788:             tmp[1] = -c[0]
  789:             for j in range(1, n):
  790:                 tmp[j] += c[j]
  791:                 tmp[j + 1] = -c[j]
  792:             tmp[0] += k[i] - lagval(lbnd, tmp)
  793:             c = tmp
  794:     c = np.moveaxis(c, 0, iaxis)
  795:     return c
  796: 
  797: 
  798: def lagval(x, c, tensor=True):
  799:     """
  800:     Evaluate a Laguerre series at points x.
  801: 
  802:     If `c` is of length ``n + 1``, this function returns the value:
  803: 
  804:     .. math:: p(x) = c_0 * L_0(x) + c_1 * L_1(x) + ... + c_n * L_n(x)
  805: 
  806:     The parameter `x` is converted to an array only if it is a tuple or a
  807:     list, otherwise it is treated as a scalar. In either case, either `x`
  808:     or its elements must support multiplication and addition both with
  809:     themselves and with the elements of `c`.
  810: 
  811:     If `c` is a 1-D array, then ``p(x)`` will have the same shape as `x`.  If
  812:     `c` is multidimensional, then the shape of the result depends on the
  813:     value of `tensor`. If `tensor` is true the shape will be c.shape[1:] +
  814:     x.shape. If `tensor` is false the shape will be c.shape[1:]. Note that
  815:     scalars have shape (,).
  816: 
  817:     Trailing zeros in the coefficients will be used in the evaluation, so
  818:     they should be avoided if efficiency is a concern.
  819: 
  820:     Parameters
  821:     ----------
  822:     x : array_like, compatible object
  823:         If `x` is a list or tuple, it is converted to an ndarray, otherwise
  824:         it is left unchanged and treated as a scalar. In either case, `x`
  825:         or its elements must support addition and multiplication with
  826:         themselves and with the elements of `c`.
  827:     c : array_like
  828:         Array of coefficients ordered so that the coefficients for terms of
  829:         degree n are contained in c[n]. If `c` is multidimensional the
  830:         remaining indices enumerate multiple polynomials. In the two
  831:         dimensional case the coefficients may be thought of as stored in
  832:         the columns of `c`.
  833:     tensor : boolean, optional
  834:         If True, the shape of the coefficient array is extended with ones
  835:         on the right, one for each dimension of `x`. Scalars have dimension 0
  836:         for this action. The result is that every column of coefficients in
  837:         `c` is evaluated for every element of `x`. If False, `x` is broadcast
  838:         over the columns of `c` for the evaluation.  This keyword is useful
  839:         when `c` is multidimensional. The default value is True.
  840: 
  841:     Returns
  842:     -------
  843:     values : ndarray, algebra_like
  844:         The shape of the return value is described above.
  845: 
  846:     See Also
  847:     --------
  848:     lagval2d, laggrid2d, lagval3d, laggrid3d
  849: 
  850:     Notes
  851:     -----
  852:     The evaluation uses Clenshaw recursion, aka synthetic division.
  853: 
  854:     Examples
  855:     --------
  856:     >>> from numpy.polynomial.laguerre import lagval
  857:     >>> coef = [1, 2, 3]
  858:     >>> lagval(1, coef)
  859:     -0.5
  860:     >>> lagval([[1, 2],[3, 4]], coef)
  861:     array([[-0.5, -4. ],
  862:            [-4.5, -2. ]])
  863: 
  864:     """
  865:     c = np.array(c, ndmin=1, copy=None)
  866:     if c.dtype.char in '?bBhHiIlLqQpP':
  867:         c = c.astype(np.double)
  868:     if isinstance(x, (tuple, list)):
  869:         x = np.asarray(x)
  870:     if isinstance(x, np.ndarray) and tensor:
  871:         c = c.reshape(c.shape + (1,) * x.ndim)
  872: 
  873:     if len(c) == 1:
  874:         c0 = c[0]
  875:         c1 = 0
  876:     elif len(c) == 2:
  877:         c0 = c[0]
  878:         c1 = c[1]
  879:     else:
  880:         nd = len(c)
  881:         c0 = c[-2]
  882:         c1 = c[-1]
  883:         for i in range(3, len(c) + 1):
  884:             tmp = c0
  885:             nd = nd - 1
  886:             c0 = c[-i] - (c1 * (nd - 1)) / nd
  887:             c1 = tmp + (c1 * ((2 * nd - 1) - x)) / nd
  888:     return c0 + c1 * (1 - x)
  889: 
  890: 
  891: def lagval2d(x, y, c):
  892:     """
  893:     Evaluate a 2-D Laguerre series at points (x, y).
  894: 
  895:     This function returns the values:
  896: 
  897:     .. math:: p(x,y) = \\sum_{i,j} c_{i,j} * L_i(x) * L_j(y)
  898: 
  899:     The parameters `x` and `y` are converted to arrays only if they are
  900:     tuples or a lists, otherwise they are treated as a scalars and they
  901:     must have the same shape after conversion. In either case, either `x`
  902:     and `y` or their elements must support multiplication and addition both
  903:     with themselves and with the elements of `c`.
  904: 
  905:     If `c` is a 1-D array a one is implicitly appended to its shape to make
  906:     it 2-D. The shape of the result will be c.shape[2:] + x.shape.
  907: 
  908:     Parameters
  909:     ----------
  910:     x, y : array_like, compatible objects
  911:         The two dimensional series is evaluated at the points ``(x, y)``,
  912:         where `x` and `y` must have the same shape. If `x` or `y` is a list
  913:         or tuple, it is first converted to an ndarray, otherwise it is left
  914:         unchanged and if it isn't an ndarray it is treated as a scalar.
  915:     c : array_like
  916:         Array of coefficients ordered so that the coefficient of the term
  917:         of multi-degree i,j is contained in ``c[i,j]``. If `c` has
  918:         dimension greater than two the remaining indices enumerate multiple
  919:         sets of coefficients.
  920: 
  921:     Returns
  922:     -------
  923:     values : ndarray, compatible object
  924:         The values of the two dimensional polynomial at points formed with
  925:         pairs of corresponding values from `x` and `y`.
  926: 
  927:     See Also
  928:     --------
  929:     lagval, laggrid2d, lagval3d, laggrid3d
  930: 
  931:     Examples
  932:     --------
  933:     >>> from numpy.polynomial.laguerre import lagval2d
  934:     >>> c = [[1, 2],[3, 4]]
  935:     >>> lagval2d(1, 1, c)
  936:     1.0
  937:     """
  938:     return pu._valnd(lagval, c, x, y)
  939: 
  940: 
  941: def laggrid2d(x, y, c):
  942:     """
  943:     Evaluate a 2-D Laguerre series on the Cartesian product of x and y.
  944: 
  945:     This function returns the values:
  946: 
  947:     .. math:: p(a,b) = \\sum_{i,j} c_{i,j} * L_i(a) * L_j(b)
  948: 
  949:     where the points ``(a, b)`` consist of all pairs formed by taking
  950:     `a` from `x` and `b` from `y`. The resulting points form a grid with
  951:     `x` in the first dimension and `y` in the second.
  952: 
  953:     The parameters `x` and `y` are converted to arrays only if they are
  954:     tuples or a lists, otherwise they are treated as a scalars. In either
  955:     case, either `x` and `y` or their elements must support multiplication
  956:     and addition both with themselves and with the elements of `c`.
  957: 
  958:     If `c` has fewer than two dimensions, ones are implicitly appended to
  959:     its shape to make it 2-D. The shape of the result will be c.shape[2:] +
  960:     x.shape + y.shape.
  961: 
  962:     Parameters
  963:     ----------
  964:     x, y : array_like, compatible objects
  965:         The two dimensional series is evaluated at the points in the
  966:         Cartesian product of `x` and `y`.  If `x` or `y` is a list or
  967:         tuple, it is first converted to an ndarray, otherwise it is left
  968:         unchanged and, if it isn't an ndarray, it is treated as a scalar.
  969:     c : array_like
  970:         Array of coefficients ordered so that the coefficient of the term of
  971:         multi-degree i,j is contained in ``c[i,j]``. If `c` has dimension
  972:         greater than two the remaining indices enumerate multiple sets of
  973:         coefficients.
  974: 
  975:     Returns
  976:     -------
  977:     values : ndarray, compatible object
  978:         The values of the two dimensional Chebyshev series at points in the
  979:         Cartesian product of `x` and `y`.
  980: 
  981:     See Also
  982:     --------
  983:     lagval, lagval2d, lagval3d, laggrid3d
  984: 
  985:     Examples
  986:     --------
  987:     >>> from numpy.polynomial.laguerre import laggrid2d
  988:     >>> c = [[1, 2], [3, 4]]
  989:     >>> laggrid2d([0, 1], [0, 1], c)
  990:     array([[10.,  4.],
  991:            [ 3.,  1.]])
  992: 
  993:     """
  994:     return pu._gridnd(lagval, c, x, y)
  995: 
  996: 
  997: def lagval3d(x, y, z, c):
  998:     """
  999:     Evaluate a 3-D Laguerre series at points (x, y, z).
 1000: 
 1001:     This function returns the values:
 1002: 
 1003:     .. math:: p(x,y,z) = \\sum_{i,j,k} c_{i,j,k} * L_i(x) * L_j(y) * L_k(z)
 1004: 
 1005:     The parameters `x`, `y`, and `z` are converted to arrays only if
 1006:     they are tuples or a lists, otherwise they are treated as a scalars and
 1007:     they must have the same shape after conversion. In either case, either
 1008:     `x`, `y`, and `z` or their elements must support multiplication and
 1009:     addition both with themselves and with the elements of `c`.
 1010: 
 1011:     If `c` has fewer than 3 dimensions, ones are implicitly appended to its
 1012:     shape to make it 3-D. The shape of the result will be c.shape[3:] +
 1013:     x.shape.
 1014: 
 1015:     Parameters
 1016:     ----------
 1017:     x, y, z : array_like, compatible object
 1018:         The three dimensional series is evaluated at the points
 1019:         ``(x, y, z)``, where `x`, `y`, and `z` must have the same shape.  If
 1020:         any of `x`, `y`, or `z` is a list or tuple, it is first converted
 1021:         to an ndarray, otherwise it is left unchanged and if it isn't an
 1022:         ndarray it is  treated as a scalar.
 1023:     c : array_like
 1024:         Array of coefficients ordered so that the coefficient of the term of
 1025:         multi-degree i,j,k is contained in ``c[i,j,k]``. If `c` has dimension
 1026:         greater than 3 the remaining indices enumerate multiple sets of
 1027:         coefficients.
 1028: 
 1029:     Returns
 1030:     -------
 1031:     values : ndarray, compatible object
 1032:         The values of the multidimensional polynomial on points formed with
 1033:         triples of corresponding values from `x`, `y`, and `z`.
 1034: 
 1035:     See Also
 1036:     --------
 1037:     lagval, lagval2d, laggrid2d, laggrid3d
 1038: 
 1039:     Examples
 1040:     --------
 1041:     >>> from numpy.polynomial.laguerre import lagval3d
 1042:     >>> c = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
 1043:     >>> lagval3d(1, 1, 2, c)
 1044:     -1.0
 1045: 
 1046:     """
 1047:     return pu._valnd(lagval, c, x, y, z)
 1048: 
 1049: 
 1050: def laggrid3d(x, y, z, c):
 1051:     """
 1052:     Evaluate a 3-D Laguerre series on the Cartesian product of x, y, and z.
 1053: 
 1054:     This function returns the values:
 1055: 
 1056:     .. math:: p(a,b,c) = \\sum_{i,j,k} c_{i,j,k} * L_i(a) * L_j(b) * L_k(c)
 1057: 
 1058:     where the points ``(a, b, c)`` consist of all triples formed by taking
 1059:     `a` from `x`, `b` from `y`, and `c` from `z`. The resulting points form
 1060:     a grid with `x` in the first dimension, `y` in the second, and `z` in
 1061:     the third.
 1062: 
 1063:     The parameters `x`, `y`, and `z` are converted to arrays only if they
 1064:     are tuples or a lists, otherwise they are treated as a scalars. In
 1065:     either case, either `x`, `y`, and `z` or their elements must support
 1066:     multiplication and addition both with themselves and with the elements
 1067:     of `c`.
 1068: 
 1069:     If `c` has fewer than three dimensions, ones are implicitly appended to
 1070:     its shape to make it 3-D. The shape of the result will be c.shape[3:] +
 1071:     x.shape + y.shape + z.shape.
 1072: 
 1073:     Parameters
 1074:     ----------
 1075:     x, y, z : array_like, compatible objects
 1076:         The three dimensional series is evaluated at the points in the
 1077:         Cartesian product of `x`, `y`, and `z`.  If `x`, `y`, or `z` is a
 1078:         list or tuple, it is first converted to an ndarray, otherwise it is
 1079:         left unchanged and, if it isn't an ndarray, it is treated as a
 1080:         scalar.
 1081:     c : array_like
 1082:         Array of coefficients ordered so that the coefficients for terms of
 1083:         degree i,j are contained in ``c[i,j]``. If `c` has dimension
 1084:         greater than two the remaining indices enumerate multiple sets of
 1085:         coefficients.
 1086: 
 1087:     Returns
 1088:     -------
 1089:     values : ndarray, compatible object
 1090:         The values of the two dimensional polynomial at points in the Cartesian
 1091:         product of `x` and `y`.
 1092: 
 1093:     See Also
 1094:     --------
 1095:     lagval, lagval2d, laggrid2d, lagval3d
 1096: 
 1097:     Examples
 1098:     --------
 1099:     >>> from numpy.polynomial.laguerre import laggrid3d
 1100:     >>> c = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
 1101:     >>> laggrid3d([0, 1], [0, 1], [2, 4], c)
 1102:     array([[[ -4., -44.],
 1103:             [ -2., -18.]],
 1104:            [[ -2., -14.],
 1105:             [ -1.,  -5.]]])
 1106: 
 1107:     """
 1108:     return pu._gridnd(lagval, c, x, y, z)
 1109: 
 1110: 
 1111: def lagvander(x, deg):
 1112:     """Pseudo-Vandermonde matrix of given degree.
 1113: 
 1114:     Returns the pseudo-Vandermonde matrix of degree `deg` and sample points
 1115:     `x`. The pseudo-Vandermonde matrix is defined by
 1116: 
 1117:     .. math:: V[..., i] = L_i(x)
 1118: 
 1119:     where ``0 <= i <= deg``. The leading indices of `V` index the elements of
 1120:     `x` and the last index is the degree of the Laguerre polynomial.
 1121: 
 1122:     If `c` is a 1-D array of coefficients of length ``n + 1`` and `V` is the
 1123:     array ``V = lagvander(x, n)``, then ``np.dot(V, c)`` and
 1124:     ``lagval(x, c)`` are the same up to roundoff. This equivalence is
 1125:     useful both for least squares fitting and for the evaluation of a large
 1126:     number of Laguerre series of the same degree and sample points.
 1127: 
 1128:     Parameters
 1129:     ----------
 1130:     x : array_like
 1131:         Array of points. The dtype is converted to float64 or complex128
 1132:         depending on whether any of the elements are complex. If `x` is
 1133:         scalar it is converted to a 1-D array.
 1134:     deg : int
 1135:         Degree of the resulting matrix.
 1136: 
 1137:     Returns
 1138:     -------
 1139:     vander : ndarray
 1140:         The pseudo-Vandermonde matrix. The shape of the returned matrix is
 1141:         ``x.shape + (deg + 1,)``, where The last index is the degree of the
 1142:         corresponding Laguerre polynomial.  The dtype will be the same as
 1143:         the converted `x`.
 1144: 
 1145:     Examples
 1146:     --------
 1147:     >>> import numpy as np
 1148:     >>> from numpy.polynomial.laguerre import lagvander
 1149:     >>> x = np.array([0, 1, 2])
 1150:     >>> lagvander(x, 3)
 1151:     array([[ 1.        ,  1.        ,  1.        ,  1.        ],
 1152:            [ 1.        ,  0.        , -0.5       , -0.66666667],
 1153:            [ 1.        , -1.        , -1.        , -0.33333333]])
 1154: 
 1155:     """
 1156:     ideg = pu._as_int(deg, "deg")
 1157:     if ideg < 0:
 1158:         raise ValueError("deg must be non-negative")
 1159: 
 1160:     x = np.array(x, copy=None, ndmin=1) + 0.0
 1161:     dims = (ideg + 1,) + x.shape
 1162:     dtyp = x.dtype
 1163:     v = np.empty(dims, dtype=dtyp)
 1164:     v[0] = x * 0 + 1
 1165:     if ideg > 0:
 1166:         v[1] = 1 - x
 1167:         for i in range(2, ideg + 1):
 1168:             v[i] = (v[i - 1] * (2 * i - 1 - x) - v[i - 2] * (i - 1)) / i
 1169:     return np.moveaxis(v, 0, -1)
 1170: 
 1171: 
 1172: def lagvander2d(x, y, deg):
 1173:     """Pseudo-Vandermonde matrix of given degrees.
 1174: 
 1175:     Returns the pseudo-Vandermonde matrix of degrees `deg` and sample
 1176:     points ``(x, y)``. The pseudo-Vandermonde matrix is defined by
 1177: 
 1178:     .. math:: V[..., (deg[1] + 1)*i + j] = L_i(x) * L_j(y),
 1179: 
 1180:     where ``0 <= i <= deg[0]`` and ``0 <= j <= deg[1]``. The leading indices of
 1181:     `V` index the points ``(x, y)`` and the last index encodes the degrees of
 1182:     the Laguerre polynomials.
 1183: 
 1184:     If ``V = lagvander2d(x, y, [xdeg, ydeg])``, then the columns of `V`
 1185:     correspond to the elements of a 2-D coefficient array `c` of shape
 1186:     (xdeg + 1, ydeg + 1) in the order
 1187: 
 1188:     .. math:: c_{00}, c_{01}, c_{02} ... , c_{10}, c_{11}, c_{12} ...
 1189: 
 1190:     and ``np.dot(V, c.flat)`` and ``lagval2d(x, y, c)`` will be the same
 1191:     up to roundoff. This equivalence is useful both for least squares
 1192:     fitting and for the evaluation of a large number of 2-D Laguerre
 1193:     series of the same degrees and sample points.
 1194: 
 1195:     Parameters
 1196:     ----------
 1197:     x, y : array_like
 1198:         Arrays of point coordinates, all of the same shape. The dtypes
 1199:         will be converted to either float64 or complex128 depending on
 1200:         whether any of the elements are complex. Scalars are converted to
 1201:         1-D arrays.
 1202:     deg : list of ints
 1203:         List of maximum degrees of the form [x_deg, y_deg].
 1204: 
 1205:     Returns
 1206:     -------
 1207:     vander2d : ndarray
 1208:         The shape of the returned matrix is ``x.shape + (order,)``, where
 1209:         :math:`order = (deg[0]+1)*(deg[1]+1)`.  The dtype will be the same
 1210:         as the converted `x` and `y`.
 1211: 
 1212:     See Also
 1213:     --------
 1214:     lagvander, lagvander3d, lagval2d, lagval3d
 1215: 
 1216:     Examples
 1217:     --------
 1218:     >>> import numpy as np
 1219:     >>> from numpy.polynomial.laguerre import lagvander2d
 1220:     >>> x = np.array([0])
 1221:     >>> y = np.array([2])
 1222:     >>> lagvander2d(x, y, [2, 1])
 1223:     array([[ 1., -1.,  1., -1.,  1., -1.]])
 1224: 
 1225:     """
 1226:     return pu._vander_nd_flat((lagvander, lagvander), (x, y), deg)
 1227: 
 1228: 
 1229: def lagvander3d(x, y, z, deg):
 1230:     """Pseudo-Vandermonde matrix of given degrees.
 1231: 
 1232:     Returns the pseudo-Vandermonde matrix of degrees `deg` and sample
 1233:     points ``(x, y, z)``. If `l`, `m`, `n` are the given degrees in `x`, `y`, `z`,
 1234:     then The pseudo-Vandermonde matrix is defined by
 1235: 
 1236:     .. math:: V[..., (m+1)(n+1)i + (n+1)j + k] = L_i(x)*L_j(y)*L_k(z),
 1237: 
 1238:     where ``0 <= i <= l``, ``0 <= j <= m``, and ``0 <= j <= n``.  The leading
 1239:     indices of `V` index the points ``(x, y, z)`` and the last index encodes
 1240:     the degrees of the Laguerre polynomials.
 1241: 
 1242:     If ``V = lagvander3d(x, y, z, [xdeg, ydeg, zdeg])``, then the columns
 1243:     of `V` correspond to the elements of a 3-D coefficient array `c` of
 1244:     shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order
 1245: 
 1246:     .. math:: c_{000}, c_{001}, c_{002},... , c_{010}, c_{011}, c_{012},...
 1247: 
 1248:     and  ``np.dot(V, c.flat)`` and ``lagval3d(x, y, z, c)`` will be the
 1249:     same up to roundoff. This equivalence is useful both for least squares
 1250:     fitting and for the evaluation of a large number of 3-D Laguerre
 1251:     series of the same degrees and sample points.
 1252: 
 1253:     Parameters
 1254:     ----------
 1255:     x, y, z : array_like
 1256:         Arrays of point coordinates, all of the same shape. The dtypes will
 1257:         be converted to either float64 or complex128 depending on whether
 1258:         any of the elements are complex. Scalars are converted to 1-D
 1259:         arrays.
 1260:     deg : list of ints
 1261:         List of maximum degrees of the form [x_deg, y_deg, z_deg].
 1262: 
 1263:     Returns
 1264:     -------
 1265:     vander3d : ndarray
 1266:         The shape of the returned matrix is ``x.shape + (order,)``, where
 1267:         :math:`order = (deg[0]+1)*(deg[1]+1)*(deg[2]+1)`.  The dtype will
 1268:         be the same as the converted `x`, `y`, and `z`.
 1269: 
 1270:     See Also
 1271:     --------
 1272:     lagvander, lagvander3d, lagval2d, lagval3d
 1273: 
 1274:     Examples
 1275:     --------
 1276:     >>> import numpy as np
 1277:     >>> from numpy.polynomial.laguerre import lagvander3d
 1278:     >>> x = np.array([0])
 1279:     >>> y = np.array([2])
 1280:     >>> z = np.array([0])
 1281:     >>> lagvander3d(x, y, z, [2, 1, 3])
 1282:     array([[ 1.,  1.,  1.,  1., -1., -1., -1., -1.,  1.,  1.,  1.,  1., -1.,
 1283:             -1., -1., -1.,  1.,  1.,  1.,  1., -1., -1., -1., -1.]])
 1284: 
 1285:     """
 1286:     return pu._vander_nd_flat((lagvander, lagvander, lagvander), (x, y, z), deg)
 1287: 
 1288: 
 1289: def lagfit(x, y, deg, rcond=None, full=False, w=None):
 1290:     """
 1291:     Least squares fit of Laguerre series to data.
 1292: 
 1293:     Return the coefficients of a Laguerre series of degree `deg` that is the
 1294:     least squares fit to the data values `y` given at points `x`. If `y` is
 1295:     1-D the returned coefficients will also be 1-D. If `y` is 2-D multiple
 1296:     fits are done, one for each column of `y`, and the resulting
 1297:     coefficients are stored in the corresponding columns of a 2-D return.
 1298:     The fitted polynomial(s) are in the form
 1299: 
 1300:     .. math::  p(x) = c_0 + c_1 * L_1(x) + ... + c_n * L_n(x),
 1301: 
 1302:     where ``n`` is `deg`.
 1303: 
 1304:     Parameters
 1305:     ----------
 1306:     x : array_like, shape (M,)
 1307:         x-coordinates of the M sample points ``(x[i], y[i])``.
 1308:     y : array_like, shape (M,) or (M, K)
 1309:         y-coordinates of the sample points. Several data sets of sample
 1310:         points sharing the same x-coordinates can be fitted at once by
 1311:         passing in a 2D-array that contains one dataset per column.
 1312:     deg : int or 1-D array_like
 1313:         Degree(s) of the fitting polynomials. If `deg` is a single integer
 1314:         all terms up to and including the `deg`'th term are included in the
 1315:         fit. For NumPy versions >= 1.11.0 a list of integers specifying the
 1316:         degrees of the terms to include may be used instead.
 1317:     rcond : float, optional
 1318:         Relative condition number of the fit. Singular values smaller than
 1319:         this relative to the largest singular value will be ignored. The
 1320:         default value is len(x)*eps, where eps is the relative precision of
 1321:         the float type, about 2e-16 in most cases.
 1322:     full : bool, optional
 1323:         Switch determining nature of return value. When it is False (the
 1324:         default) just the coefficients are returned, when True diagnostic
 1325:         information from the singular value decomposition is also returned.
 1326:     w : array_like, shape (`M`,), optional
 1327:         Weights. If not None, the weight ``w[i]`` applies to the unsquared
 1328:         residual ``y[i] - y_hat[i]`` at ``x[i]``. Ideally the weights are
 1329:         chosen so that the errors of the products ``w[i]*y[i]`` all have the
 1330:         same variance.  When using inverse-variance weighting, use
 1331:         ``w[i] = 1/sigma(y[i])``.  The default value is None.
 1332: 
 1333:     Returns
 1334:     -------
 1335:     coef : ndarray, shape (M,) or (M, K)
 1336:         Laguerre coefficients ordered from low to high. If `y` was 2-D,
 1337:         the coefficients for the data in column *k*  of `y` are in column
 1338:         *k*.
 1339: 
 1340:     [residuals, rank, singular_values, rcond] : list
 1341:         These values are only returned if ``full == True``
 1342: 
 1343:         - residuals -- sum of squared residuals of the least squares fit
 1344:         - rank -- the numerical rank of the scaled Vandermonde matrix
 1345:         - singular_values -- singular values of the scaled Vandermonde matrix
 1346:         - rcond -- value of `rcond`.
 1347: 
 1348:         For more details, see `numpy.linalg.lstsq`.
 1349: 
 1350:     Warns
 1351:     -----
 1352:     RankWarning
 1353:         The rank of the coefficient matrix in the least-squares fit is
 1354:         deficient. The warning is only raised if ``full == False``.  The
 1355:         warnings can be turned off by
 1356: 
 1357:         >>> import warnings
 1358:         >>> warnings.simplefilter('ignore', np.exceptions.RankWarning)
 1359: 
 1360:     See Also
 1361:     --------
 1362:     numpy.polynomial.polynomial.polyfit
 1363:     numpy.polynomial.legendre.legfit
 1364:     numpy.polynomial.chebyshev.chebfit
 1365:     numpy.polynomial.hermite.hermfit
 1366:     numpy.polynomial.hermite_e.hermefit
 1367:     lagval : Evaluates a Laguerre series.
 1368:     lagvander : pseudo Vandermonde matrix of Laguerre series.
 1369:     lagweight : Laguerre weight function.
 1370:     numpy.linalg.lstsq : Computes a least-squares fit from the matrix.
 1371:     scipy.interpolate.UnivariateSpline : Computes spline fits.
 1372: 
 1373:     Notes
 1374:     -----
 1375:     The solution is the coefficients of the Laguerre series ``p`` that
 1376:     minimizes the sum of the weighted squared errors
 1377: 
 1378:     .. math:: E = \\sum_j w_j^2 * |y_j - p(x_j)|^2,
 1379: 
 1380:     where the :math:`w_j` are the weights. This problem is solved by
 1381:     setting up as the (typically) overdetermined matrix equation
 1382: 
 1383:     .. math:: V(x) * c = w * y,
 1384: 
 1385:     where ``V`` is the weighted pseudo Vandermonde matrix of `x`, ``c`` are the
 1386:     coefficients to be solved for, `w` are the weights, and `y` are the
 1387:     observed values.  This equation is then solved using the singular value
 1388:     decomposition of ``V``.
 1389: 
 1390:     If some of the singular values of `V` are so small that they are
 1391:     neglected, then a `~exceptions.RankWarning` will be issued. This means that
 1392:     the coefficient values may be poorly determined. Using a lower order fit
 1393:     will usually get rid of the warning.  The `rcond` parameter can also be
 1394:     set to a value smaller than its default, but the resulting fit may be
 1395:     spurious and have large contributions from roundoff error.
 1396: 
 1397:     Fits using Laguerre series are probably most useful when the data can
 1398:     be approximated by ``sqrt(w(x)) * p(x)``, where ``w(x)`` is the Laguerre
 1399:     weight. In that case the weight ``sqrt(w(x[i]))`` should be used
 1400:     together with data values ``y[i]/sqrt(w(x[i]))``. The weight function is
 1401:     available as `lagweight`.
 1402: 
 1403:     References
 1404:     ----------
 1405:     .. [1] Wikipedia, "Curve fitting",
 1406:            https://en.wikipedia.org/wiki/Curve_fitting
 1407: 
 1408:     Examples
 1409:     --------
 1410:     >>> import numpy as np
 1411:     >>> from numpy.polynomial.laguerre import lagfit, lagval
 1412:     >>> x = np.linspace(0, 10)
 1413:     >>> rng = np.random.default_rng()
 1414:     >>> err = rng.normal(scale=1./10, size=len(x))
 1415:     >>> y = lagval(x, [1, 2, 3]) + err
 1416:     >>> lagfit(x, y, 2)
 1417:     array([1.00578369, 1.99417356, 2.99827656]) # may vary
 1418: 
 1419:     """
 1420:     return pu._fit(lagvander, x, y, deg, rcond, full, w)
 1421: 
 1422: 
 1423: def lagcompanion(c):
 1424:     """
 1425:     Return the companion matrix of c.
 1426: 
 1427:     The usual companion matrix of the Laguerre polynomials is already
 1428:     symmetric when `c` is a basis Laguerre polynomial, so no scaling is
 1429:     applied.
 1430: 
 1431:     Parameters
 1432:     ----------
 1433:     c : array_like
 1434:         1-D array of Laguerre series coefficients ordered from low to high
 1435:         degree.
 1436: 
 1437:     Returns
 1438:     -------
 1439:     mat : ndarray
 1440:         Companion matrix of dimensions (deg, deg).
 1441: 
 1442:     Examples
 1443:     --------
 1444:     >>> from numpy.polynomial.laguerre import lagcompanion
 1445:     >>> lagcompanion([1, 2, 3])
 1446:     array([[ 1.        , -0.33333333],
 1447:            [-1.        ,  4.33333333]])
 1448: 
 1449:     """
 1450:     # c is a trimmed copy
 1451:     [c] = pu.as_series([c])
 1452:     if len(c) < 2:
 1453:         raise ValueError('Series must have maximum degree of at least 1.')
 1454:     if len(c) == 2:
 1455:         return np.array([[1 + c[0] / c[1]]])
 1456: 
 1457:     n = len(c) - 1
 1458:     mat = np.zeros((n, n), dtype=c.dtype)
 1459:     top = mat.reshape(-1)[1::n + 1]
 1460:     mid = mat.reshape(-1)[0::n + 1]
 1461:     bot = mat.reshape(-1)[n::n + 1]
 1462:     top[...] = -np.arange(1, n)
 1463:     mid[...] = 2. * np.arange(n) + 1.
 1464:     bot[...] = top
 1465:     mat[:, -1] += (c[:-1] / c[-1]) * n
 1466:     return mat
 1467: 
 1468: 
 1469: def lagroots(c):
 1470:     """
 1471:     Compute the roots of a Laguerre series.
 1472: 
 1473:     Return the roots (a.k.a. "zeros") of the polynomial
 1474: 
 1475:     .. math:: p(x) = \\sum_i c[i] * L_i(x).
 1476: 
 1477:     Parameters
 1478:     ----------
 1479:     c : 1-D array_like
 1480:         1-D array of coefficients.
 1481: 
 1482:     Returns
 1483:     -------
 1484:     out : ndarray
 1485:         Array of the roots of the series. If all the roots are real,
 1486:         then `out` is also real, otherwise it is complex.
 1487: 
 1488:     See Also
 1489:     --------
 1490:     numpy.polynomial.polynomial.polyroots
 1491:     numpy.polynomial.legendre.legroots
 1492:     numpy.polynomial.chebyshev.chebroots
 1493:     numpy.polynomial.hermite.hermroots
 1494:     numpy.polynomial.hermite_e.hermeroots
 1495: 
 1496:     Notes
 1497:     -----
 1498:     The root estimates are obtained as the eigenvalues of the companion
 1499:     matrix, Roots far from the origin of the complex plane may have large
 1500:     errors due to the numerical instability of the series for such
 1501:     values. Roots with multiplicity greater than 1 will also show larger
 1502:     errors as the value of the series near such points is relatively
 1503:     insensitive to errors in the roots. Isolated roots near the origin can
 1504:     be improved by a few iterations of Newton's method.
 1505: 
 1506:     The Laguerre series basis polynomials aren't powers of `x` so the
 1507:     results of this function may seem unintuitive.
 1508: 
 1509:     Examples
 1510:     --------
 1511:     >>> from numpy.polynomial.laguerre import lagroots, lagfromroots
 1512:     >>> coef = lagfromroots([0, 1, 2])
 1513:     >>> coef
 1514:     array([  2.,  -8.,  12.,  -6.])
 1515:     >>> lagroots(coef)
 1516:     array([-4.4408921e-16,  1.0000000e+00,  2.0000000e+00])
 1517: 
 1518:     """
 1519:     # c is a trimmed copy
 1520:     [c] = pu.as_series([c])
 1521:     if len(c) <= 1:
 1522:         return np.array([], dtype=c.dtype)
 1523:     if len(c) == 2:
 1524:         return np.array([1 + c[0] / c[1]])
 1525: 
 1526:     # rotated companion matrix reduces error
 1527:     m = lagcompanion(c)[::-1, ::-1]
 1528:     r = la.eigvals(m)
 1529:     r.sort()
 1530:     return r
 1531: 
 1532: 
 1533: def laggauss(deg):
 1534:     """
 1535:     Gauss-Laguerre quadrature.
 1536: 
 1537:     Computes the sample points and weights for Gauss-Laguerre quadrature.
 1538:     These sample points and weights will correctly integrate polynomials of
 1539:     degree :math:`2*deg - 1` or less over the interval :math:`[0, \\inf]`
 1540:     with the weight function :math:`f(x) = \\exp(-x)`.
 1541: 
 1542:     Parameters
 1543:     ----------
 1544:     deg : int
 1545:         Number of sample points and weights. It must be >= 1.
 1546: 
 1547:     Returns
 1548:     -------
 1549:     x : ndarray
 1550:         1-D ndarray containing the sample points.
 1551:     y : ndarray
 1552:         1-D ndarray containing the weights.
 1553: 
 1554:     Notes
 1555:     -----
 1556:     The results have only been tested up to degree 100 higher degrees may
 1557:     be problematic. The weights are determined by using the fact that
 1558: 
 1559:     .. math:: w_k = c / (L'_n(x_k) * L_{n-1}(x_k))
 1560: 
 1561:     where :math:`c` is a constant independent of :math:`k` and :math:`x_k`
 1562:     is the k'th root of :math:`L_n`, and then scaling the results to get
 1563:     the right value when integrating 1.
 1564: 
 1565:     Examples
 1566:     --------
 1567:     >>> from numpy.polynomial.laguerre import laggauss
 1568:     >>> laggauss(2)
 1569:     (array([0.58578644, 3.41421356]), array([0.85355339, 0.14644661]))
 1570: 
 1571:     """
 1572:     ideg = pu._as_int(deg, "deg")
 1573:     if ideg <= 0:
 1574:         raise ValueError("deg must be a positive integer")
 1575: 
 1576:     # first approximation of roots. We use the fact that the companion
 1577:     # matrix is symmetric in this case in order to obtain better zeros.
 1578:     c = np.array([0] * deg + [1])
 1579:     m = lagcompanion(c)
 1580:     x = la.eigvalsh(m)
 1581: 
 1582:     # improve roots by one application of Newton
 1583:     dy = lagval(x, c)
 1584:     df = lagval(x, lagder(c))
 1585:     x -= dy / df
 1586: 
 1587:     # compute the weights. We scale the factor to avoid possible numerical
 1588:     # overflow.
 1589:     fm = lagval(x, c[1:])
 1590:     fm /= np.abs(fm).max()
 1591:     df /= np.abs(df).max()
 1592:     w = 1 / (fm * df)
 1593: 
 1594:     # scale w to get the right value, 1 in this case
 1595:     w /= w.sum()
 1596: 
 1597:     return x, w
 1598: 
 1599: 
 1600: def lagweight(x):
 1601:     """Weight function of the Laguerre polynomials.
 1602: 
 1603:     The weight function is :math:`exp(-x)` and the interval of integration
 1604:     is :math:`[0, \\inf]`. The Laguerre polynomials are orthogonal, but not
 1605:     normalized, with respect to this weight function.
 1606: 
 1607:     Parameters
 1608:     ----------
 1609:     x : array_like
 1610:        Values at which the weight function will be computed.
 1611: 
 1612:     Returns
 1613:     -------
 1614:     w : ndarray
 1615:        The weight function at `x`.
 1616: 
 1617:     Examples
 1618:     --------
 1619:     >>> from numpy.polynomial.laguerre import lagweight
 1620:     >>> x = np.array([0, 1, 2])
 1621:     >>> lagweight(x)
 1622:     array([1.        , 0.36787944, 0.13533528])
 1623: 
 1624:     """
 1625:     w = np.exp(-x)
 1626:     return w
 1627: 
 1628: #
 1629: # Laguerre series class
 1630: #
 1631: 
 1632: class Laguerre(ABCPolyBase):
 1633:     """A Laguerre series class.
 1634: 
 1635:     The Laguerre class provides the standard Python numerical methods
 1636:     '+', '-', '*', '//', '%', 'divmod', '**', and '()' as well as the
 1637:     attributes and methods listed below.
 1638: 
 1639:     Parameters
 1640:     ----------
 1641:     coef : array_like
 1642:         Laguerre coefficients in order of increasing degree, i.e,
 1643:         ``(1, 2, 3)`` gives ``1*L_0(x) + 2*L_1(X) + 3*L_2(x)``.
 1644:     domain : (2,) array_like, optional
 1645:         Domain to use. The interval ``[domain[0], domain[1]]`` is mapped
 1646:         to the interval ``[window[0], window[1]]`` by shifting and scaling.
 1647:         The default value is [0., 1.].
 1648:     window : (2,) array_like, optional
 1649:         Window, see `domain` for its use. The default value is [0., 1.].
 1650:     symbol : str, optional
 1651:         Symbol used to represent the independent variable in string
 1652:         representations of the polynomial expression, e.g. for printing.
 1653:         The symbol must be a valid Python identifier. Default value is 'x'.
 1654: 
 1655:         .. versionadded:: 1.24
 1656: 
 1657:     """
 1658:     # Virtual Functions
 1659:     _add = staticmethod(lagadd)
 1660:     _sub = staticmethod(lagsub)
 1661:     _mul = staticmethod(lagmul)
 1662:     _div = staticmethod(lagdiv)
 1663:     _pow = staticmethod(lagpow)
 1664:     _val = staticmethod(lagval)
 1665:     _int = staticmethod(lagint)
 1666:     _der = staticmethod(lagder)
 1667:     _fit = staticmethod(lagfit)
 1668:     _line = staticmethod(lagline)
 1669:     _roots = staticmethod(lagroots)
 1670:     _fromroots = staticmethod(lagfromroots)
 1671: 
 1672:     # Virtual properties
 1673:     domain = np.array(lagdomain)
 1674:     window = np.array(lagdomain)
 1675:     basis_name = 'L'
