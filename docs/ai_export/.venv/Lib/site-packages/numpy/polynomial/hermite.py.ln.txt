    1: """
    2: ==============================================================
    3: Hermite Series, "Physicists" (:mod:`numpy.polynomial.hermite`)
    4: ==============================================================
    5: 
    6: This module provides a number of objects (mostly functions) useful for
    7: dealing with Hermite series, including a `Hermite` class that
    8: encapsulates the usual arithmetic operations.  (General information
    9: on how this module represents and works with such polynomials is in the
   10: docstring for its "parent" sub-package, `numpy.polynomial`).
   11: 
   12: Classes
   13: -------
   14: .. autosummary::
   15:    :toctree: generated/
   16: 
   17:    Hermite
   18: 
   19: Constants
   20: ---------
   21: .. autosummary::
   22:    :toctree: generated/
   23: 
   24:    hermdomain
   25:    hermzero
   26:    hermone
   27:    hermx
   28: 
   29: Arithmetic
   30: ----------
   31: .. autosummary::
   32:    :toctree: generated/
   33: 
   34:    hermadd
   35:    hermsub
   36:    hermmulx
   37:    hermmul
   38:    hermdiv
   39:    hermpow
   40:    hermval
   41:    hermval2d
   42:    hermval3d
   43:    hermgrid2d
   44:    hermgrid3d
   45: 
   46: Calculus
   47: --------
   48: .. autosummary::
   49:    :toctree: generated/
   50: 
   51:    hermder
   52:    hermint
   53: 
   54: Misc Functions
   55: --------------
   56: .. autosummary::
   57:    :toctree: generated/
   58: 
   59:    hermfromroots
   60:    hermroots
   61:    hermvander
   62:    hermvander2d
   63:    hermvander3d
   64:    hermgauss
   65:    hermweight
   66:    hermcompanion
   67:    hermfit
   68:    hermtrim
   69:    hermline
   70:    herm2poly
   71:    poly2herm
   72: 
   73: See also
   74: --------
   75: `numpy.polynomial`
   76: 
   77: """
   78: import numpy as np
   79: import numpy.linalg as la
   80: from numpy.lib.array_utils import normalize_axis_index
   81: 
   82: from . import polyutils as pu
   83: from ._polybase import ABCPolyBase
   84: 
   85: __all__ = [
   86:     'hermzero', 'hermone', 'hermx', 'hermdomain', 'hermline', 'hermadd',
   87:     'hermsub', 'hermmulx', 'hermmul', 'hermdiv', 'hermpow', 'hermval',
   88:     'hermder', 'hermint', 'herm2poly', 'poly2herm', 'hermfromroots',
   89:     'hermvander', 'hermfit', 'hermtrim', 'hermroots', 'Hermite',
   90:     'hermval2d', 'hermval3d', 'hermgrid2d', 'hermgrid3d', 'hermvander2d',
   91:     'hermvander3d', 'hermcompanion', 'hermgauss', 'hermweight']
   92: 
   93: hermtrim = pu.trimcoef
   94: 
   95: 
   96: def poly2herm(pol):
   97:     """
   98:     poly2herm(pol)
   99: 
  100:     Convert a polynomial to a Hermite series.
  101: 
  102:     Convert an array representing the coefficients of a polynomial (relative
  103:     to the "standard" basis) ordered from lowest degree to highest, to an
  104:     array of the coefficients of the equivalent Hermite series, ordered
  105:     from lowest to highest degree.
  106: 
  107:     Parameters
  108:     ----------
  109:     pol : array_like
  110:         1-D array containing the polynomial coefficients
  111: 
  112:     Returns
  113:     -------
  114:     c : ndarray
  115:         1-D array containing the coefficients of the equivalent Hermite
  116:         series.
  117: 
  118:     See Also
  119:     --------
  120:     herm2poly
  121: 
  122:     Notes
  123:     -----
  124:     The easy way to do conversions between polynomial basis sets
  125:     is to use the convert method of a class instance.
  126: 
  127:     Examples
  128:     --------
  129:     >>> from numpy.polynomial.hermite import poly2herm
  130:     >>> poly2herm(np.arange(4))
  131:     array([1.   ,  2.75 ,  0.5  ,  0.375])
  132: 
  133:     """
  134:     [pol] = pu.as_series([pol])
  135:     deg = len(pol) - 1
  136:     res = 0
  137:     for i in range(deg, -1, -1):
  138:         res = hermadd(hermmulx(res), pol[i])
  139:     return res
  140: 
  141: 
  142: def herm2poly(c):
  143:     """
  144:     Convert a Hermite series to a polynomial.
  145: 
  146:     Convert an array representing the coefficients of a Hermite series,
  147:     ordered from lowest degree to highest, to an array of the coefficients
  148:     of the equivalent polynomial (relative to the "standard" basis) ordered
  149:     from lowest to highest degree.
  150: 
  151:     Parameters
  152:     ----------
  153:     c : array_like
  154:         1-D array containing the Hermite series coefficients, ordered
  155:         from lowest order term to highest.
  156: 
  157:     Returns
  158:     -------
  159:     pol : ndarray
  160:         1-D array containing the coefficients of the equivalent polynomial
  161:         (relative to the "standard" basis) ordered from lowest order term
  162:         to highest.
  163: 
  164:     See Also
  165:     --------
  166:     poly2herm
  167: 
  168:     Notes
  169:     -----
  170:     The easy way to do conversions between polynomial basis sets
  171:     is to use the convert method of a class instance.
  172: 
  173:     Examples
  174:     --------
  175:     >>> from numpy.polynomial.hermite import herm2poly
  176:     >>> herm2poly([ 1.   ,  2.75 ,  0.5  ,  0.375])
  177:     array([0., 1., 2., 3.])
  178: 
  179:     """
  180:     from .polynomial import polyadd, polymulx, polysub
  181: 
  182:     [c] = pu.as_series([c])
  183:     n = len(c)
  184:     if n == 1:
  185:         return c
  186:     if n == 2:
  187:         c[1] *= 2
  188:         return c
  189:     else:
  190:         c0 = c[-2]
  191:         c1 = c[-1]
  192:         # i is the current degree of c1
  193:         for i in range(n - 1, 1, -1):
  194:             tmp = c0
  195:             c0 = polysub(c[i - 2], c1 * (2 * (i - 1)))
  196:             c1 = polyadd(tmp, polymulx(c1) * 2)
  197:         return polyadd(c0, polymulx(c1) * 2)
  198: 
  199: 
  200: #
  201: # These are constant arrays are of integer type so as to be compatible
  202: # with the widest range of other types, such as Decimal.
  203: #
  204: 
  205: # Hermite
  206: hermdomain = np.array([-1., 1.])
  207: 
  208: # Hermite coefficients representing zero.
  209: hermzero = np.array([0])
  210: 
  211: # Hermite coefficients representing one.
  212: hermone = np.array([1])
  213: 
  214: # Hermite coefficients representing the identity x.
  215: hermx = np.array([0, 1 / 2])
  216: 
  217: 
  218: def hermline(off, scl):
  219:     """
  220:     Hermite series whose graph is a straight line.
  221: 
  222: 
  223: 
  224:     Parameters
  225:     ----------
  226:     off, scl : scalars
  227:         The specified line is given by ``off + scl*x``.
  228: 
  229:     Returns
  230:     -------
  231:     y : ndarray
  232:         This module's representation of the Hermite series for
  233:         ``off + scl*x``.
  234: 
  235:     See Also
  236:     --------
  237:     numpy.polynomial.polynomial.polyline
  238:     numpy.polynomial.chebyshev.chebline
  239:     numpy.polynomial.legendre.legline
  240:     numpy.polynomial.laguerre.lagline
  241:     numpy.polynomial.hermite_e.hermeline
  242: 
  243:     Examples
  244:     --------
  245:     >>> from numpy.polynomial.hermite import hermline, hermval
  246:     >>> hermval(0,hermline(3, 2))
  247:     3.0
  248:     >>> hermval(1,hermline(3, 2))
  249:     5.0
  250: 
  251:     """
  252:     if scl != 0:
  253:         return np.array([off, scl / 2])
  254:     else:
  255:         return np.array([off])
  256: 
  257: 
  258: def hermfromroots(roots):
  259:     """
  260:     Generate a Hermite series with given roots.
  261: 
  262:     The function returns the coefficients of the polynomial
  263: 
  264:     .. math:: p(x) = (x - r_0) * (x - r_1) * ... * (x - r_n),
  265: 
  266:     in Hermite form, where the :math:`r_n` are the roots specified in `roots`.
  267:     If a zero has multiplicity n, then it must appear in `roots` n times.
  268:     For instance, if 2 is a root of multiplicity three and 3 is a root of
  269:     multiplicity 2, then `roots` looks something like [2, 2, 2, 3, 3]. The
  270:     roots can appear in any order.
  271: 
  272:     If the returned coefficients are `c`, then
  273: 
  274:     .. math:: p(x) = c_0 + c_1 * H_1(x) + ... +  c_n * H_n(x)
  275: 
  276:     The coefficient of the last term is not generally 1 for monic
  277:     polynomials in Hermite form.
  278: 
  279:     Parameters
  280:     ----------
  281:     roots : array_like
  282:         Sequence containing the roots.
  283: 
  284:     Returns
  285:     -------
  286:     out : ndarray
  287:         1-D array of coefficients.  If all roots are real then `out` is a
  288:         real array, if some of the roots are complex, then `out` is complex
  289:         even if all the coefficients in the result are real (see Examples
  290:         below).
  291: 
  292:     See Also
  293:     --------
  294:     numpy.polynomial.polynomial.polyfromroots
  295:     numpy.polynomial.legendre.legfromroots
  296:     numpy.polynomial.laguerre.lagfromroots
  297:     numpy.polynomial.chebyshev.chebfromroots
  298:     numpy.polynomial.hermite_e.hermefromroots
  299: 
  300:     Examples
  301:     --------
  302:     >>> from numpy.polynomial.hermite import hermfromroots, hermval
  303:     >>> coef = hermfromroots((-1, 0, 1))
  304:     >>> hermval((-1, 0, 1), coef)
  305:     array([0.,  0.,  0.])
  306:     >>> coef = hermfromroots((-1j, 1j))
  307:     >>> hermval((-1j, 1j), coef)
  308:     array([0.+0.j, 0.+0.j])
  309: 
  310:     """
  311:     return pu._fromroots(hermline, hermmul, roots)
  312: 
  313: 
  314: def hermadd(c1, c2):
  315:     """
  316:     Add one Hermite series to another.
  317: 
  318:     Returns the sum of two Hermite series `c1` + `c2`.  The arguments
  319:     are sequences of coefficients ordered from lowest order term to
  320:     highest, i.e., [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.
  321: 
  322:     Parameters
  323:     ----------
  324:     c1, c2 : array_like
  325:         1-D arrays of Hermite series coefficients ordered from low to
  326:         high.
  327: 
  328:     Returns
  329:     -------
  330:     out : ndarray
  331:         Array representing the Hermite series of their sum.
  332: 
  333:     See Also
  334:     --------
  335:     hermsub, hermmulx, hermmul, hermdiv, hermpow
  336: 
  337:     Notes
  338:     -----
  339:     Unlike multiplication, division, etc., the sum of two Hermite series
  340:     is a Hermite series (without having to "reproject" the result onto
  341:     the basis set) so addition, just like that of "standard" polynomials,
  342:     is simply "component-wise."
  343: 
  344:     Examples
  345:     --------
  346:     >>> from numpy.polynomial.hermite import hermadd
  347:     >>> hermadd([1, 2, 3], [1, 2, 3, 4])
  348:     array([2., 4., 6., 4.])
  349: 
  350:     """
  351:     return pu._add(c1, c2)
  352: 
  353: 
  354: def hermsub(c1, c2):
  355:     """
  356:     Subtract one Hermite series from another.
  357: 
  358:     Returns the difference of two Hermite series `c1` - `c2`.  The
  359:     sequences of coefficients are from lowest order term to highest, i.e.,
  360:     [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.
  361: 
  362:     Parameters
  363:     ----------
  364:     c1, c2 : array_like
  365:         1-D arrays of Hermite series coefficients ordered from low to
  366:         high.
  367: 
  368:     Returns
  369:     -------
  370:     out : ndarray
  371:         Of Hermite series coefficients representing their difference.
  372: 
  373:     See Also
  374:     --------
  375:     hermadd, hermmulx, hermmul, hermdiv, hermpow
  376: 
  377:     Notes
  378:     -----
  379:     Unlike multiplication, division, etc., the difference of two Hermite
  380:     series is a Hermite series (without having to "reproject" the result
  381:     onto the basis set) so subtraction, just like that of "standard"
  382:     polynomials, is simply "component-wise."
  383: 
  384:     Examples
  385:     --------
  386:     >>> from numpy.polynomial.hermite import hermsub
  387:     >>> hermsub([1, 2, 3, 4], [1, 2, 3])
  388:     array([0.,  0.,  0.,  4.])
  389: 
  390:     """
  391:     return pu._sub(c1, c2)
  392: 
  393: 
  394: def hermmulx(c):
  395:     """Multiply a Hermite series by x.
  396: 
  397:     Multiply the Hermite series `c` by x, where x is the independent
  398:     variable.
  399: 
  400: 
  401:     Parameters
  402:     ----------
  403:     c : array_like
  404:         1-D array of Hermite series coefficients ordered from low to
  405:         high.
  406: 
  407:     Returns
  408:     -------
  409:     out : ndarray
  410:         Array representing the result of the multiplication.
  411: 
  412:     See Also
  413:     --------
  414:     hermadd, hermsub, hermmul, hermdiv, hermpow
  415: 
  416:     Notes
  417:     -----
  418:     The multiplication uses the recursion relationship for Hermite
  419:     polynomials in the form
  420: 
  421:     .. math::
  422: 
  423:         xP_i(x) = (P_{i + 1}(x)/2 + i*P_{i - 1}(x))
  424: 
  425:     Examples
  426:     --------
  427:     >>> from numpy.polynomial.hermite import hermmulx
  428:     >>> hermmulx([1, 2, 3])
  429:     array([2. , 6.5, 1. , 1.5])
  430: 
  431:     """
  432:     # c is a trimmed copy
  433:     [c] = pu.as_series([c])
  434:     # The zero series needs special treatment
  435:     if len(c) == 1 and c[0] == 0:
  436:         return c
  437: 
  438:     prd = np.empty(len(c) + 1, dtype=c.dtype)
  439:     prd[0] = c[0] * 0
  440:     prd[1] = c[0] / 2
  441:     for i in range(1, len(c)):
  442:         prd[i + 1] = c[i] / 2
  443:         prd[i - 1] += c[i] * i
  444:     return prd
  445: 
  446: 
  447: def hermmul(c1, c2):
  448:     """
  449:     Multiply one Hermite series by another.
  450: 
  451:     Returns the product of two Hermite series `c1` * `c2`.  The arguments
  452:     are sequences of coefficients, from lowest order "term" to highest,
  453:     e.g., [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.
  454: 
  455:     Parameters
  456:     ----------
  457:     c1, c2 : array_like
  458:         1-D arrays of Hermite series coefficients ordered from low to
  459:         high.
  460: 
  461:     Returns
  462:     -------
  463:     out : ndarray
  464:         Of Hermite series coefficients representing their product.
  465: 
  466:     See Also
  467:     --------
  468:     hermadd, hermsub, hermmulx, hermdiv, hermpow
  469: 
  470:     Notes
  471:     -----
  472:     In general, the (polynomial) product of two C-series results in terms
  473:     that are not in the Hermite polynomial basis set.  Thus, to express
  474:     the product as a Hermite series, it is necessary to "reproject" the
  475:     product onto said basis set, which may produce "unintuitive" (but
  476:     correct) results; see Examples section below.
  477: 
  478:     Examples
  479:     --------
  480:     >>> from numpy.polynomial.hermite import hermmul
  481:     >>> hermmul([1, 2, 3], [0, 1, 2])
  482:     array([52.,  29.,  52.,   7.,   6.])
  483: 
  484:     """
  485:     # s1, s2 are trimmed copies
  486:     [c1, c2] = pu.as_series([c1, c2])
  487: 
  488:     if len(c1) > len(c2):
  489:         c = c2
  490:         xs = c1
  491:     else:
  492:         c = c1
  493:         xs = c2
  494: 
  495:     if len(c) == 1:
  496:         c0 = c[0] * xs
  497:         c1 = 0
  498:     elif len(c) == 2:
  499:         c0 = c[0] * xs
  500:         c1 = c[1] * xs
  501:     else:
  502:         nd = len(c)
  503:         c0 = c[-2] * xs
  504:         c1 = c[-1] * xs
  505:         for i in range(3, len(c) + 1):
  506:             tmp = c0
  507:             nd = nd - 1
  508:             c0 = hermsub(c[-i] * xs, c1 * (2 * (nd - 1)))
  509:             c1 = hermadd(tmp, hermmulx(c1) * 2)
  510:     return hermadd(c0, hermmulx(c1) * 2)
  511: 
  512: 
  513: def hermdiv(c1, c2):
  514:     """
  515:     Divide one Hermite series by another.
  516: 
  517:     Returns the quotient-with-remainder of two Hermite series
  518:     `c1` / `c2`.  The arguments are sequences of coefficients from lowest
  519:     order "term" to highest, e.g., [1,2,3] represents the series
  520:     ``P_0 + 2*P_1 + 3*P_2``.
  521: 
  522:     Parameters
  523:     ----------
  524:     c1, c2 : array_like
  525:         1-D arrays of Hermite series coefficients ordered from low to
  526:         high.
  527: 
  528:     Returns
  529:     -------
  530:     [quo, rem] : ndarrays
  531:         Of Hermite series coefficients representing the quotient and
  532:         remainder.
  533: 
  534:     See Also
  535:     --------
  536:     hermadd, hermsub, hermmulx, hermmul, hermpow
  537: 
  538:     Notes
  539:     -----
  540:     In general, the (polynomial) division of one Hermite series by another
  541:     results in quotient and remainder terms that are not in the Hermite
  542:     polynomial basis set.  Thus, to express these results as a Hermite
  543:     series, it is necessary to "reproject" the results onto the Hermite
  544:     basis set, which may produce "unintuitive" (but correct) results; see
  545:     Examples section below.
  546: 
  547:     Examples
  548:     --------
  549:     >>> from numpy.polynomial.hermite import hermdiv
  550:     >>> hermdiv([ 52.,  29.,  52.,   7.,   6.], [0, 1, 2])
  551:     (array([1., 2., 3.]), array([0.]))
  552:     >>> hermdiv([ 54.,  31.,  52.,   7.,   6.], [0, 1, 2])
  553:     (array([1., 2., 3.]), array([2., 2.]))
  554:     >>> hermdiv([ 53.,  30.,  52.,   7.,   6.], [0, 1, 2])
  555:     (array([1., 2., 3.]), array([1., 1.]))
  556: 
  557:     """
  558:     return pu._div(hermmul, c1, c2)
  559: 
  560: 
  561: def hermpow(c, pow, maxpower=16):
  562:     """Raise a Hermite series to a power.
  563: 
  564:     Returns the Hermite series `c` raised to the power `pow`. The
  565:     argument `c` is a sequence of coefficients ordered from low to high.
  566:     i.e., [1,2,3] is the series  ``P_0 + 2*P_1 + 3*P_2.``
  567: 
  568:     Parameters
  569:     ----------
  570:     c : array_like
  571:         1-D array of Hermite series coefficients ordered from low to
  572:         high.
  573:     pow : integer
  574:         Power to which the series will be raised
  575:     maxpower : integer, optional
  576:         Maximum power allowed. This is mainly to limit growth of the series
  577:         to unmanageable size. Default is 16
  578: 
  579:     Returns
  580:     -------
  581:     coef : ndarray
  582:         Hermite series of power.
  583: 
  584:     See Also
  585:     --------
  586:     hermadd, hermsub, hermmulx, hermmul, hermdiv
  587: 
  588:     Examples
  589:     --------
  590:     >>> from numpy.polynomial.hermite import hermpow
  591:     >>> hermpow([1, 2, 3], 2)
  592:     array([81.,  52.,  82.,  12.,   9.])
  593: 
  594:     """
  595:     return pu._pow(hermmul, c, pow, maxpower)
  596: 
  597: 
  598: def hermder(c, m=1, scl=1, axis=0):
  599:     """
  600:     Differentiate a Hermite series.
  601: 
  602:     Returns the Hermite series coefficients `c` differentiated `m` times
  603:     along `axis`.  At each iteration the result is multiplied by `scl` (the
  604:     scaling factor is for use in a linear change of variable). The argument
  605:     `c` is an array of coefficients from low to high degree along each
  606:     axis, e.g., [1,2,3] represents the series ``1*H_0 + 2*H_1 + 3*H_2``
  607:     while [[1,2],[1,2]] represents ``1*H_0(x)*H_0(y) + 1*H_1(x)*H_0(y) +
  608:     2*H_0(x)*H_1(y) + 2*H_1(x)*H_1(y)`` if axis=0 is ``x`` and axis=1 is
  609:     ``y``.
  610: 
  611:     Parameters
  612:     ----------
  613:     c : array_like
  614:         Array of Hermite series coefficients. If `c` is multidimensional the
  615:         different axis correspond to different variables with the degree in
  616:         each axis given by the corresponding index.
  617:     m : int, optional
  618:         Number of derivatives taken, must be non-negative. (Default: 1)
  619:     scl : scalar, optional
  620:         Each differentiation is multiplied by `scl`.  The end result is
  621:         multiplication by ``scl**m``.  This is for use in a linear change of
  622:         variable. (Default: 1)
  623:     axis : int, optional
  624:         Axis over which the derivative is taken. (Default: 0).
  625: 
  626:     Returns
  627:     -------
  628:     der : ndarray
  629:         Hermite series of the derivative.
  630: 
  631:     See Also
  632:     --------
  633:     hermint
  634: 
  635:     Notes
  636:     -----
  637:     In general, the result of differentiating a Hermite series does not
  638:     resemble the same operation on a power series. Thus the result of this
  639:     function may be "unintuitive," albeit correct; see Examples section
  640:     below.
  641: 
  642:     Examples
  643:     --------
  644:     >>> from numpy.polynomial.hermite import hermder
  645:     >>> hermder([ 1. ,  0.5,  0.5,  0.5])
  646:     array([1., 2., 3.])
  647:     >>> hermder([-0.5,  1./2.,  1./8.,  1./12.,  1./16.], m=2)
  648:     array([1., 2., 3.])
  649: 
  650:     """
  651:     c = np.array(c, ndmin=1, copy=True)
  652:     if c.dtype.char in '?bBhHiIlLqQpP':
  653:         c = c.astype(np.double)
  654:     cnt = pu._as_int(m, "the order of derivation")
  655:     iaxis = pu._as_int(axis, "the axis")
  656:     if cnt < 0:
  657:         raise ValueError("The order of derivation must be non-negative")
  658:     iaxis = normalize_axis_index(iaxis, c.ndim)
  659: 
  660:     if cnt == 0:
  661:         return c
  662: 
  663:     c = np.moveaxis(c, iaxis, 0)
  664:     n = len(c)
  665:     if cnt >= n:
  666:         c = c[:1] * 0
  667:     else:
  668:         for i in range(cnt):
  669:             n = n - 1
  670:             c *= scl
  671:             der = np.empty((n,) + c.shape[1:], dtype=c.dtype)
  672:             for j in range(n, 0, -1):
  673:                 der[j - 1] = (2 * j) * c[j]
  674:             c = der
  675:     c = np.moveaxis(c, 0, iaxis)
  676:     return c
  677: 
  678: 
  679: def hermint(c, m=1, k=[], lbnd=0, scl=1, axis=0):
  680:     """
  681:     Integrate a Hermite series.
  682: 
  683:     Returns the Hermite series coefficients `c` integrated `m` times from
  684:     `lbnd` along `axis`. At each iteration the resulting series is
  685:     **multiplied** by `scl` and an integration constant, `k`, is added.
  686:     The scaling factor is for use in a linear change of variable.  ("Buyer
  687:     beware": note that, depending on what one is doing, one may want `scl`
  688:     to be the reciprocal of what one might expect; for more information,
  689:     see the Notes section below.)  The argument `c` is an array of
  690:     coefficients from low to high degree along each axis, e.g., [1,2,3]
  691:     represents the series ``H_0 + 2*H_1 + 3*H_2`` while [[1,2],[1,2]]
  692:     represents ``1*H_0(x)*H_0(y) + 1*H_1(x)*H_0(y) + 2*H_0(x)*H_1(y) +
  693:     2*H_1(x)*H_1(y)`` if axis=0 is ``x`` and axis=1 is ``y``.
  694: 
  695:     Parameters
  696:     ----------
  697:     c : array_like
  698:         Array of Hermite series coefficients. If c is multidimensional the
  699:         different axis correspond to different variables with the degree in
  700:         each axis given by the corresponding index.
  701:     m : int, optional
  702:         Order of integration, must be positive. (Default: 1)
  703:     k : {[], list, scalar}, optional
  704:         Integration constant(s).  The value of the first integral at
  705:         ``lbnd`` is the first value in the list, the value of the second
  706:         integral at ``lbnd`` is the second value, etc.  If ``k == []`` (the
  707:         default), all constants are set to zero.  If ``m == 1``, a single
  708:         scalar can be given instead of a list.
  709:     lbnd : scalar, optional
  710:         The lower bound of the integral. (Default: 0)
  711:     scl : scalar, optional
  712:         Following each integration the result is *multiplied* by `scl`
  713:         before the integration constant is added. (Default: 1)
  714:     axis : int, optional
  715:         Axis over which the integral is taken. (Default: 0).
  716: 
  717:     Returns
  718:     -------
  719:     S : ndarray
  720:         Hermite series coefficients of the integral.
  721: 
  722:     Raises
  723:     ------
  724:     ValueError
  725:         If ``m < 0``, ``len(k) > m``, ``np.ndim(lbnd) != 0``, or
  726:         ``np.ndim(scl) != 0``.
  727: 
  728:     See Also
  729:     --------
  730:     hermder
  731: 
  732:     Notes
  733:     -----
  734:     Note that the result of each integration is *multiplied* by `scl`.
  735:     Why is this important to note?  Say one is making a linear change of
  736:     variable :math:`u = ax + b` in an integral relative to `x`.  Then
  737:     :math:`dx = du/a`, so one will need to set `scl` equal to
  738:     :math:`1/a` - perhaps not what one would have first thought.
  739: 
  740:     Also note that, in general, the result of integrating a C-series needs
  741:     to be "reprojected" onto the C-series basis set.  Thus, typically,
  742:     the result of this function is "unintuitive," albeit correct; see
  743:     Examples section below.
  744: 
  745:     Examples
  746:     --------
  747:     >>> from numpy.polynomial.hermite import hermint
  748:     >>> hermint([1,2,3]) # integrate once, value 0 at 0.
  749:     array([1. , 0.5, 0.5, 0.5])
  750:     >>> hermint([1,2,3], m=2) # integrate twice, value & deriv 0 at 0
  751:     array([-0.5       ,  0.5       ,  0.125     ,  0.08333333,  0.0625    ]) # may vary
  752:     >>> hermint([1,2,3], k=1) # integrate once, value 1 at 0.
  753:     array([2. , 0.5, 0.5, 0.5])
  754:     >>> hermint([1,2,3], lbnd=-1) # integrate once, value 0 at -1
  755:     array([-2. ,  0.5,  0.5,  0.5])
  756:     >>> hermint([1,2,3], m=2, k=[1,2], lbnd=-1)
  757:     array([ 1.66666667, -0.5       ,  0.125     ,  0.08333333,  0.0625    ]) # may vary
  758: 
  759:     """
  760:     c = np.array(c, ndmin=1, copy=True)
  761:     if c.dtype.char in '?bBhHiIlLqQpP':
  762:         c = c.astype(np.double)
  763:     if not np.iterable(k):
  764:         k = [k]
  765:     cnt = pu._as_int(m, "the order of integration")
  766:     iaxis = pu._as_int(axis, "the axis")
  767:     if cnt < 0:
  768:         raise ValueError("The order of integration must be non-negative")
  769:     if len(k) > cnt:
  770:         raise ValueError("Too many integration constants")
  771:     if np.ndim(lbnd) != 0:
  772:         raise ValueError("lbnd must be a scalar.")
  773:     if np.ndim(scl) != 0:
  774:         raise ValueError("scl must be a scalar.")
  775:     iaxis = normalize_axis_index(iaxis, c.ndim)
  776: 
  777:     if cnt == 0:
  778:         return c
  779: 
  780:     c = np.moveaxis(c, iaxis, 0)
  781:     k = list(k) + [0] * (cnt - len(k))
  782:     for i in range(cnt):
  783:         n = len(c)
  784:         c *= scl
  785:         if n == 1 and np.all(c[0] == 0):
  786:             c[0] += k[i]
  787:         else:
  788:             tmp = np.empty((n + 1,) + c.shape[1:], dtype=c.dtype)
  789:             tmp[0] = c[0] * 0
  790:             tmp[1] = c[0] / 2
  791:             for j in range(1, n):
  792:                 tmp[j + 1] = c[j] / (2 * (j + 1))
  793:             tmp[0] += k[i] - hermval(lbnd, tmp)
  794:             c = tmp
  795:     c = np.moveaxis(c, 0, iaxis)
  796:     return c
  797: 
  798: 
  799: def hermval(x, c, tensor=True):
  800:     """
  801:     Evaluate an Hermite series at points x.
  802: 
  803:     If `c` is of length ``n + 1``, this function returns the value:
  804: 
  805:     .. math:: p(x) = c_0 * H_0(x) + c_1 * H_1(x) + ... + c_n * H_n(x)
  806: 
  807:     The parameter `x` is converted to an array only if it is a tuple or a
  808:     list, otherwise it is treated as a scalar. In either case, either `x`
  809:     or its elements must support multiplication and addition both with
  810:     themselves and with the elements of `c`.
  811: 
  812:     If `c` is a 1-D array, then ``p(x)`` will have the same shape as `x`.  If
  813:     `c` is multidimensional, then the shape of the result depends on the
  814:     value of `tensor`. If `tensor` is true the shape will be c.shape[1:] +
  815:     x.shape. If `tensor` is false the shape will be c.shape[1:]. Note that
  816:     scalars have shape (,).
  817: 
  818:     Trailing zeros in the coefficients will be used in the evaluation, so
  819:     they should be avoided if efficiency is a concern.
  820: 
  821:     Parameters
  822:     ----------
  823:     x : array_like, compatible object
  824:         If `x` is a list or tuple, it is converted to an ndarray, otherwise
  825:         it is left unchanged and treated as a scalar. In either case, `x`
  826:         or its elements must support addition and multiplication with
  827:         themselves and with the elements of `c`.
  828:     c : array_like
  829:         Array of coefficients ordered so that the coefficients for terms of
  830:         degree n are contained in c[n]. If `c` is multidimensional the
  831:         remaining indices enumerate multiple polynomials. In the two
  832:         dimensional case the coefficients may be thought of as stored in
  833:         the columns of `c`.
  834:     tensor : boolean, optional
  835:         If True, the shape of the coefficient array is extended with ones
  836:         on the right, one for each dimension of `x`. Scalars have dimension 0
  837:         for this action. The result is that every column of coefficients in
  838:         `c` is evaluated for every element of `x`. If False, `x` is broadcast
  839:         over the columns of `c` for the evaluation.  This keyword is useful
  840:         when `c` is multidimensional. The default value is True.
  841: 
  842:     Returns
  843:     -------
  844:     values : ndarray, algebra_like
  845:         The shape of the return value is described above.
  846: 
  847:     See Also
  848:     --------
  849:     hermval2d, hermgrid2d, hermval3d, hermgrid3d
  850: 
  851:     Notes
  852:     -----
  853:     The evaluation uses Clenshaw recursion, aka synthetic division.
  854: 
  855:     Examples
  856:     --------
  857:     >>> from numpy.polynomial.hermite import hermval
  858:     >>> coef = [1,2,3]
  859:     >>> hermval(1, coef)
  860:     11.0
  861:     >>> hermval([[1,2],[3,4]], coef)
  862:     array([[ 11.,   51.],
  863:            [115.,  203.]])
  864: 
  865:     """
  866:     c = np.array(c, ndmin=1, copy=None)
  867:     if c.dtype.char in '?bBhHiIlLqQpP':
  868:         c = c.astype(np.double)
  869:     if isinstance(x, (tuple, list)):
  870:         x = np.asarray(x)
  871:     if isinstance(x, np.ndarray) and tensor:
  872:         c = c.reshape(c.shape + (1,) * x.ndim)
  873: 
  874:     x2 = x * 2
  875:     if len(c) == 1:
  876:         c0 = c[0]
  877:         c1 = 0
  878:     elif len(c) == 2:
  879:         c0 = c[0]
  880:         c1 = c[1]
  881:     else:
  882:         nd = len(c)
  883:         c0 = c[-2]
  884:         c1 = c[-1]
  885:         for i in range(3, len(c) + 1):
  886:             tmp = c0
  887:             nd = nd - 1
  888:             c0 = c[-i] - c1 * (2 * (nd - 1))
  889:             c1 = tmp + c1 * x2
  890:     return c0 + c1 * x2
  891: 
  892: 
  893: def hermval2d(x, y, c):
  894:     """
  895:     Evaluate a 2-D Hermite series at points (x, y).
  896: 
  897:     This function returns the values:
  898: 
  899:     .. math:: p(x,y) = \\sum_{i,j} c_{i,j} * H_i(x) * H_j(y)
  900: 
  901:     The parameters `x` and `y` are converted to arrays only if they are
  902:     tuples or a lists, otherwise they are treated as a scalars and they
  903:     must have the same shape after conversion. In either case, either `x`
  904:     and `y` or their elements must support multiplication and addition both
  905:     with themselves and with the elements of `c`.
  906: 
  907:     If `c` is a 1-D array a one is implicitly appended to its shape to make
  908:     it 2-D. The shape of the result will be c.shape[2:] + x.shape.
  909: 
  910:     Parameters
  911:     ----------
  912:     x, y : array_like, compatible objects
  913:         The two dimensional series is evaluated at the points ``(x, y)``,
  914:         where `x` and `y` must have the same shape. If `x` or `y` is a list
  915:         or tuple, it is first converted to an ndarray, otherwise it is left
  916:         unchanged and if it isn't an ndarray it is treated as a scalar.
  917:     c : array_like
  918:         Array of coefficients ordered so that the coefficient of the term
  919:         of multi-degree i,j is contained in ``c[i,j]``. If `c` has
  920:         dimension greater than two the remaining indices enumerate multiple
  921:         sets of coefficients.
  922: 
  923:     Returns
  924:     -------
  925:     values : ndarray, compatible object
  926:         The values of the two dimensional polynomial at points formed with
  927:         pairs of corresponding values from `x` and `y`.
  928: 
  929:     See Also
  930:     --------
  931:     hermval, hermgrid2d, hermval3d, hermgrid3d
  932: 
  933:     Examples
  934:     --------
  935:     >>> from numpy.polynomial.hermite import hermval2d
  936:     >>> x = [1, 2]
  937:     >>> y = [4, 5]
  938:     >>> c = [[1, 2, 3], [4, 5, 6]]
  939:     >>> hermval2d(x, y, c)
  940:     array([1035., 2883.])
  941: 
  942:     """
  943:     return pu._valnd(hermval, c, x, y)
  944: 
  945: 
  946: def hermgrid2d(x, y, c):
  947:     """
  948:     Evaluate a 2-D Hermite series on the Cartesian product of x and y.
  949: 
  950:     This function returns the values:
  951: 
  952:     .. math:: p(a,b) = \\sum_{i,j} c_{i,j} * H_i(a) * H_j(b)
  953: 
  954:     where the points ``(a, b)`` consist of all pairs formed by taking
  955:     `a` from `x` and `b` from `y`. The resulting points form a grid with
  956:     `x` in the first dimension and `y` in the second.
  957: 
  958:     The parameters `x` and `y` are converted to arrays only if they are
  959:     tuples or a lists, otherwise they are treated as a scalars. In either
  960:     case, either `x` and `y` or their elements must support multiplication
  961:     and addition both with themselves and with the elements of `c`.
  962: 
  963:     If `c` has fewer than two dimensions, ones are implicitly appended to
  964:     its shape to make it 2-D. The shape of the result will be c.shape[2:] +
  965:     x.shape.
  966: 
  967:     Parameters
  968:     ----------
  969:     x, y : array_like, compatible objects
  970:         The two dimensional series is evaluated at the points in the
  971:         Cartesian product of `x` and `y`.  If `x` or `y` is a list or
  972:         tuple, it is first converted to an ndarray, otherwise it is left
  973:         unchanged and, if it isn't an ndarray, it is treated as a scalar.
  974:     c : array_like
  975:         Array of coefficients ordered so that the coefficients for terms of
  976:         degree i,j are contained in ``c[i,j]``. If `c` has dimension
  977:         greater than two the remaining indices enumerate multiple sets of
  978:         coefficients.
  979: 
  980:     Returns
  981:     -------
  982:     values : ndarray, compatible object
  983:         The values of the two dimensional polynomial at points in the Cartesian
  984:         product of `x` and `y`.
  985: 
  986:     See Also
  987:     --------
  988:     hermval, hermval2d, hermval3d, hermgrid3d
  989: 
  990:     Examples
  991:     --------
  992:     >>> from numpy.polynomial.hermite import hermgrid2d
  993:     >>> x = [1, 2, 3]
  994:     >>> y = [4, 5]
  995:     >>> c = [[1, 2, 3], [4, 5, 6]]
  996:     >>> hermgrid2d(x, y, c)
  997:     array([[1035., 1599.],
  998:            [1867., 2883.],
  999:            [2699., 4167.]])
 1000: 
 1001:     """
 1002:     return pu._gridnd(hermval, c, x, y)
 1003: 
 1004: 
 1005: def hermval3d(x, y, z, c):
 1006:     """
 1007:     Evaluate a 3-D Hermite series at points (x, y, z).
 1008: 
 1009:     This function returns the values:
 1010: 
 1011:     .. math:: p(x,y,z) = \\sum_{i,j,k} c_{i,j,k} * H_i(x) * H_j(y) * H_k(z)
 1012: 
 1013:     The parameters `x`, `y`, and `z` are converted to arrays only if
 1014:     they are tuples or a lists, otherwise they are treated as a scalars and
 1015:     they must have the same shape after conversion. In either case, either
 1016:     `x`, `y`, and `z` or their elements must support multiplication and
 1017:     addition both with themselves and with the elements of `c`.
 1018: 
 1019:     If `c` has fewer than 3 dimensions, ones are implicitly appended to its
 1020:     shape to make it 3-D. The shape of the result will be c.shape[3:] +
 1021:     x.shape.
 1022: 
 1023:     Parameters
 1024:     ----------
 1025:     x, y, z : array_like, compatible object
 1026:         The three dimensional series is evaluated at the points
 1027:         ``(x, y, z)``, where `x`, `y`, and `z` must have the same shape.  If
 1028:         any of `x`, `y`, or `z` is a list or tuple, it is first converted
 1029:         to an ndarray, otherwise it is left unchanged and if it isn't an
 1030:         ndarray it is  treated as a scalar.
 1031:     c : array_like
 1032:         Array of coefficients ordered so that the coefficient of the term of
 1033:         multi-degree i,j,k is contained in ``c[i,j,k]``. If `c` has dimension
 1034:         greater than 3 the remaining indices enumerate multiple sets of
 1035:         coefficients.
 1036: 
 1037:     Returns
 1038:     -------
 1039:     values : ndarray, compatible object
 1040:         The values of the multidimensional polynomial on points formed with
 1041:         triples of corresponding values from `x`, `y`, and `z`.
 1042: 
 1043:     See Also
 1044:     --------
 1045:     hermval, hermval2d, hermgrid2d, hermgrid3d
 1046: 
 1047:     Examples
 1048:     --------
 1049:     >>> from numpy.polynomial.hermite import hermval3d
 1050:     >>> x = [1, 2]
 1051:     >>> y = [4, 5]
 1052:     >>> z = [6, 7]
 1053:     >>> c = [[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]]
 1054:     >>> hermval3d(x, y, z, c)
 1055:     array([ 40077., 120131.])
 1056: 
 1057:     """
 1058:     return pu._valnd(hermval, c, x, y, z)
 1059: 
 1060: 
 1061: def hermgrid3d(x, y, z, c):
 1062:     """
 1063:     Evaluate a 3-D Hermite series on the Cartesian product of x, y, and z.
 1064: 
 1065:     This function returns the values:
 1066: 
 1067:     .. math:: p(a,b,c) = \\sum_{i,j,k} c_{i,j,k} * H_i(a) * H_j(b) * H_k(c)
 1068: 
 1069:     where the points ``(a, b, c)`` consist of all triples formed by taking
 1070:     `a` from `x`, `b` from `y`, and `c` from `z`. The resulting points form
 1071:     a grid with `x` in the first dimension, `y` in the second, and `z` in
 1072:     the third.
 1073: 
 1074:     The parameters `x`, `y`, and `z` are converted to arrays only if they
 1075:     are tuples or a lists, otherwise they are treated as a scalars. In
 1076:     either case, either `x`, `y`, and `z` or their elements must support
 1077:     multiplication and addition both with themselves and with the elements
 1078:     of `c`.
 1079: 
 1080:     If `c` has fewer than three dimensions, ones are implicitly appended to
 1081:     its shape to make it 3-D. The shape of the result will be c.shape[3:] +
 1082:     x.shape + y.shape + z.shape.
 1083: 
 1084:     Parameters
 1085:     ----------
 1086:     x, y, z : array_like, compatible objects
 1087:         The three dimensional series is evaluated at the points in the
 1088:         Cartesian product of `x`, `y`, and `z`.  If `x`, `y`, or `z` is a
 1089:         list or tuple, it is first converted to an ndarray, otherwise it is
 1090:         left unchanged and, if it isn't an ndarray, it is treated as a
 1091:         scalar.
 1092:     c : array_like
 1093:         Array of coefficients ordered so that the coefficients for terms of
 1094:         degree i,j are contained in ``c[i,j]``. If `c` has dimension
 1095:         greater than two the remaining indices enumerate multiple sets of
 1096:         coefficients.
 1097: 
 1098:     Returns
 1099:     -------
 1100:     values : ndarray, compatible object
 1101:         The values of the two dimensional polynomial at points in the Cartesian
 1102:         product of `x` and `y`.
 1103: 
 1104:     See Also
 1105:     --------
 1106:     hermval, hermval2d, hermgrid2d, hermval3d
 1107: 
 1108:     Examples
 1109:     --------
 1110:     >>> from numpy.polynomial.hermite import hermgrid3d
 1111:     >>> x = [1, 2]
 1112:     >>> y = [4, 5]
 1113:     >>> z = [6, 7]
 1114:     >>> c = [[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]]
 1115:     >>> hermgrid3d(x, y, z, c)
 1116:     array([[[ 40077.,  54117.],
 1117:             [ 49293.,  66561.]],
 1118:            [[ 72375.,  97719.],
 1119:             [ 88975., 120131.]]])
 1120: 
 1121:     """
 1122:     return pu._gridnd(hermval, c, x, y, z)
 1123: 
 1124: 
 1125: def hermvander(x, deg):
 1126:     """Pseudo-Vandermonde matrix of given degree.
 1127: 
 1128:     Returns the pseudo-Vandermonde matrix of degree `deg` and sample points
 1129:     `x`. The pseudo-Vandermonde matrix is defined by
 1130: 
 1131:     .. math:: V[..., i] = H_i(x),
 1132: 
 1133:     where ``0 <= i <= deg``. The leading indices of `V` index the elements of
 1134:     `x` and the last index is the degree of the Hermite polynomial.
 1135: 
 1136:     If `c` is a 1-D array of coefficients of length ``n + 1`` and `V` is the
 1137:     array ``V = hermvander(x, n)``, then ``np.dot(V, c)`` and
 1138:     ``hermval(x, c)`` are the same up to roundoff. This equivalence is
 1139:     useful both for least squares fitting and for the evaluation of a large
 1140:     number of Hermite series of the same degree and sample points.
 1141: 
 1142:     Parameters
 1143:     ----------
 1144:     x : array_like
 1145:         Array of points. The dtype is converted to float64 or complex128
 1146:         depending on whether any of the elements are complex. If `x` is
 1147:         scalar it is converted to a 1-D array.
 1148:     deg : int
 1149:         Degree of the resulting matrix.
 1150: 
 1151:     Returns
 1152:     -------
 1153:     vander : ndarray
 1154:         The pseudo-Vandermonde matrix. The shape of the returned matrix is
 1155:         ``x.shape + (deg + 1,)``, where The last index is the degree of the
 1156:         corresponding Hermite polynomial.  The dtype will be the same as
 1157:         the converted `x`.
 1158: 
 1159:     Examples
 1160:     --------
 1161:     >>> import numpy as np
 1162:     >>> from numpy.polynomial.hermite import hermvander
 1163:     >>> x = np.array([-1, 0, 1])
 1164:     >>> hermvander(x, 3)
 1165:     array([[ 1., -2.,  2.,  4.],
 1166:            [ 1.,  0., -2., -0.],
 1167:            [ 1.,  2.,  2., -4.]])
 1168: 
 1169:     """
 1170:     ideg = pu._as_int(deg, "deg")
 1171:     if ideg < 0:
 1172:         raise ValueError("deg must be non-negative")
 1173: 
 1174:     x = np.array(x, copy=None, ndmin=1) + 0.0
 1175:     dims = (ideg + 1,) + x.shape
 1176:     dtyp = x.dtype
 1177:     v = np.empty(dims, dtype=dtyp)
 1178:     v[0] = x * 0 + 1
 1179:     if ideg > 0:
 1180:         x2 = x * 2
 1181:         v[1] = x2
 1182:         for i in range(2, ideg + 1):
 1183:             v[i] = (v[i - 1] * x2 - v[i - 2] * (2 * (i - 1)))
 1184:     return np.moveaxis(v, 0, -1)
 1185: 
 1186: 
 1187: def hermvander2d(x, y, deg):
 1188:     """Pseudo-Vandermonde matrix of given degrees.
 1189: 
 1190:     Returns the pseudo-Vandermonde matrix of degrees `deg` and sample
 1191:     points ``(x, y)``. The pseudo-Vandermonde matrix is defined by
 1192: 
 1193:     .. math:: V[..., (deg[1] + 1)*i + j] = H_i(x) * H_j(y),
 1194: 
 1195:     where ``0 <= i <= deg[0]`` and ``0 <= j <= deg[1]``. The leading indices of
 1196:     `V` index the points ``(x, y)`` and the last index encodes the degrees of
 1197:     the Hermite polynomials.
 1198: 
 1199:     If ``V = hermvander2d(x, y, [xdeg, ydeg])``, then the columns of `V`
 1200:     correspond to the elements of a 2-D coefficient array `c` of shape
 1201:     (xdeg + 1, ydeg + 1) in the order
 1202: 
 1203:     .. math:: c_{00}, c_{01}, c_{02} ... , c_{10}, c_{11}, c_{12} ...
 1204: 
 1205:     and ``np.dot(V, c.flat)`` and ``hermval2d(x, y, c)`` will be the same
 1206:     up to roundoff. This equivalence is useful both for least squares
 1207:     fitting and for the evaluation of a large number of 2-D Hermite
 1208:     series of the same degrees and sample points.
 1209: 
 1210:     Parameters
 1211:     ----------
 1212:     x, y : array_like
 1213:         Arrays of point coordinates, all of the same shape. The dtypes
 1214:         will be converted to either float64 or complex128 depending on
 1215:         whether any of the elements are complex. Scalars are converted to 1-D
 1216:         arrays.
 1217:     deg : list of ints
 1218:         List of maximum degrees of the form [x_deg, y_deg].
 1219: 
 1220:     Returns
 1221:     -------
 1222:     vander2d : ndarray
 1223:         The shape of the returned matrix is ``x.shape + (order,)``, where
 1224:         :math:`order = (deg[0]+1)*(deg[1]+1)`.  The dtype will be the same
 1225:         as the converted `x` and `y`.
 1226: 
 1227:     See Also
 1228:     --------
 1229:     hermvander, hermvander3d, hermval2d, hermval3d
 1230: 
 1231:     Examples
 1232:     --------
 1233:     >>> import numpy as np
 1234:     >>> from numpy.polynomial.hermite import hermvander2d
 1235:     >>> x = np.array([-1, 0, 1])
 1236:     >>> y = np.array([-1, 0, 1])
 1237:     >>> hermvander2d(x, y, [2, 2])
 1238:     array([[ 1., -2.,  2., -2.,  4., -4.,  2., -4.,  4.],
 1239:            [ 1.,  0., -2.,  0.,  0., -0., -2., -0.,  4.],
 1240:            [ 1.,  2.,  2.,  2.,  4.,  4.,  2.,  4.,  4.]])
 1241: 
 1242:     """
 1243:     return pu._vander_nd_flat((hermvander, hermvander), (x, y), deg)
 1244: 
 1245: 
 1246: def hermvander3d(x, y, z, deg):
 1247:     """Pseudo-Vandermonde matrix of given degrees.
 1248: 
 1249:     Returns the pseudo-Vandermonde matrix of degrees `deg` and sample
 1250:     points ``(x, y, z)``. If `l`, `m`, `n` are the given degrees in `x`, `y`, `z`,
 1251:     then The pseudo-Vandermonde matrix is defined by
 1252: 
 1253:     .. math:: V[..., (m+1)(n+1)i + (n+1)j + k] = H_i(x)*H_j(y)*H_k(z),
 1254: 
 1255:     where ``0 <= i <= l``, ``0 <= j <= m``, and ``0 <= j <= n``.  The leading
 1256:     indices of `V` index the points ``(x, y, z)`` and the last index encodes
 1257:     the degrees of the Hermite polynomials.
 1258: 
 1259:     If ``V = hermvander3d(x, y, z, [xdeg, ydeg, zdeg])``, then the columns
 1260:     of `V` correspond to the elements of a 3-D coefficient array `c` of
 1261:     shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order
 1262: 
 1263:     .. math:: c_{000}, c_{001}, c_{002},... , c_{010}, c_{011}, c_{012},...
 1264: 
 1265:     and  ``np.dot(V, c.flat)`` and ``hermval3d(x, y, z, c)`` will be the
 1266:     same up to roundoff. This equivalence is useful both for least squares
 1267:     fitting and for the evaluation of a large number of 3-D Hermite
 1268:     series of the same degrees and sample points.
 1269: 
 1270:     Parameters
 1271:     ----------
 1272:     x, y, z : array_like
 1273:         Arrays of point coordinates, all of the same shape. The dtypes will
 1274:         be converted to either float64 or complex128 depending on whether
 1275:         any of the elements are complex. Scalars are converted to 1-D
 1276:         arrays.
 1277:     deg : list of ints
 1278:         List of maximum degrees of the form [x_deg, y_deg, z_deg].
 1279: 
 1280:     Returns
 1281:     -------
 1282:     vander3d : ndarray
 1283:         The shape of the returned matrix is ``x.shape + (order,)``, where
 1284:         :math:`order = (deg[0]+1)*(deg[1]+1)*(deg[2]+1)`.  The dtype will
 1285:         be the same as the converted `x`, `y`, and `z`.
 1286: 
 1287:     See Also
 1288:     --------
 1289:     hermvander, hermvander3d, hermval2d, hermval3d
 1290: 
 1291:     Examples
 1292:     --------
 1293:     >>> from numpy.polynomial.hermite import hermvander3d
 1294:     >>> x = np.array([-1, 0, 1])
 1295:     >>> y = np.array([-1, 0, 1])
 1296:     >>> z = np.array([-1, 0, 1])
 1297:     >>> hermvander3d(x, y, z, [0, 1, 2])
 1298:     array([[ 1., -2.,  2., -2.,  4., -4.],
 1299:            [ 1.,  0., -2.,  0.,  0., -0.],
 1300:            [ 1.,  2.,  2.,  2.,  4.,  4.]])
 1301: 
 1302:     """
 1303:     return pu._vander_nd_flat((hermvander, hermvander, hermvander), (x, y, z), deg)
 1304: 
 1305: 
 1306: def hermfit(x, y, deg, rcond=None, full=False, w=None):
 1307:     """
 1308:     Least squares fit of Hermite series to data.
 1309: 
 1310:     Return the coefficients of a Hermite series of degree `deg` that is the
 1311:     least squares fit to the data values `y` given at points `x`. If `y` is
 1312:     1-D the returned coefficients will also be 1-D. If `y` is 2-D multiple
 1313:     fits are done, one for each column of `y`, and the resulting
 1314:     coefficients are stored in the corresponding columns of a 2-D return.
 1315:     The fitted polynomial(s) are in the form
 1316: 
 1317:     .. math::  p(x) = c_0 + c_1 * H_1(x) + ... + c_n * H_n(x),
 1318: 
 1319:     where `n` is `deg`.
 1320: 
 1321:     Parameters
 1322:     ----------
 1323:     x : array_like, shape (M,)
 1324:         x-coordinates of the M sample points ``(x[i], y[i])``.
 1325:     y : array_like, shape (M,) or (M, K)
 1326:         y-coordinates of the sample points. Several data sets of sample
 1327:         points sharing the same x-coordinates can be fitted at once by
 1328:         passing in a 2D-array that contains one dataset per column.
 1329:     deg : int or 1-D array_like
 1330:         Degree(s) of the fitting polynomials. If `deg` is a single integer
 1331:         all terms up to and including the `deg`'th term are included in the
 1332:         fit. For NumPy versions >= 1.11.0 a list of integers specifying the
 1333:         degrees of the terms to include may be used instead.
 1334:     rcond : float, optional
 1335:         Relative condition number of the fit. Singular values smaller than
 1336:         this relative to the largest singular value will be ignored. The
 1337:         default value is len(x)*eps, where eps is the relative precision of
 1338:         the float type, about 2e-16 in most cases.
 1339:     full : bool, optional
 1340:         Switch determining nature of return value. When it is False (the
 1341:         default) just the coefficients are returned, when True diagnostic
 1342:         information from the singular value decomposition is also returned.
 1343:     w : array_like, shape (`M`,), optional
 1344:         Weights. If not None, the weight ``w[i]`` applies to the unsquared
 1345:         residual ``y[i] - y_hat[i]`` at ``x[i]``. Ideally the weights are
 1346:         chosen so that the errors of the products ``w[i]*y[i]`` all have the
 1347:         same variance.  When using inverse-variance weighting, use
 1348:         ``w[i] = 1/sigma(y[i])``.  The default value is None.
 1349: 
 1350:     Returns
 1351:     -------
 1352:     coef : ndarray, shape (M,) or (M, K)
 1353:         Hermite coefficients ordered from low to high. If `y` was 2-D,
 1354:         the coefficients for the data in column k  of `y` are in column
 1355:         `k`.
 1356: 
 1357:     [residuals, rank, singular_values, rcond] : list
 1358:         These values are only returned if ``full == True``
 1359: 
 1360:         - residuals -- sum of squared residuals of the least squares fit
 1361:         - rank -- the numerical rank of the scaled Vandermonde matrix
 1362:         - singular_values -- singular values of the scaled Vandermonde matrix
 1363:         - rcond -- value of `rcond`.
 1364: 
 1365:         For more details, see `numpy.linalg.lstsq`.
 1366: 
 1367:     Warns
 1368:     -----
 1369:     RankWarning
 1370:         The rank of the coefficient matrix in the least-squares fit is
 1371:         deficient. The warning is only raised if ``full == False``.  The
 1372:         warnings can be turned off by
 1373: 
 1374:         >>> import warnings
 1375:         >>> warnings.simplefilter('ignore', np.exceptions.RankWarning)
 1376: 
 1377:     See Also
 1378:     --------
 1379:     numpy.polynomial.chebyshev.chebfit
 1380:     numpy.polynomial.legendre.legfit
 1381:     numpy.polynomial.laguerre.lagfit
 1382:     numpy.polynomial.polynomial.polyfit
 1383:     numpy.polynomial.hermite_e.hermefit
 1384:     hermval : Evaluates a Hermite series.
 1385:     hermvander : Vandermonde matrix of Hermite series.
 1386:     hermweight : Hermite weight function
 1387:     numpy.linalg.lstsq : Computes a least-squares fit from the matrix.
 1388:     scipy.interpolate.UnivariateSpline : Computes spline fits.
 1389: 
 1390:     Notes
 1391:     -----
 1392:     The solution is the coefficients of the Hermite series `p` that
 1393:     minimizes the sum of the weighted squared errors
 1394: 
 1395:     .. math:: E = \\sum_j w_j^2 * |y_j - p(x_j)|^2,
 1396: 
 1397:     where the :math:`w_j` are the weights. This problem is solved by
 1398:     setting up the (typically) overdetermined matrix equation
 1399: 
 1400:     .. math:: V(x) * c = w * y,
 1401: 
 1402:     where `V` is the weighted pseudo Vandermonde matrix of `x`, `c` are the
 1403:     coefficients to be solved for, `w` are the weights, `y` are the
 1404:     observed values.  This equation is then solved using the singular value
 1405:     decomposition of `V`.
 1406: 
 1407:     If some of the singular values of `V` are so small that they are
 1408:     neglected, then a `~exceptions.RankWarning` will be issued. This means that
 1409:     the coefficient values may be poorly determined. Using a lower order fit
 1410:     will usually get rid of the warning.  The `rcond` parameter can also be
 1411:     set to a value smaller than its default, but the resulting fit may be
 1412:     spurious and have large contributions from roundoff error.
 1413: 
 1414:     Fits using Hermite series are probably most useful when the data can be
 1415:     approximated by ``sqrt(w(x)) * p(x)``, where ``w(x)`` is the Hermite
 1416:     weight. In that case the weight ``sqrt(w(x[i]))`` should be used
 1417:     together with data values ``y[i]/sqrt(w(x[i]))``. The weight function is
 1418:     available as `hermweight`.
 1419: 
 1420:     References
 1421:     ----------
 1422:     .. [1] Wikipedia, "Curve fitting",
 1423:            https://en.wikipedia.org/wiki/Curve_fitting
 1424: 
 1425:     Examples
 1426:     --------
 1427:     >>> import numpy as np
 1428:     >>> from numpy.polynomial.hermite import hermfit, hermval
 1429:     >>> x = np.linspace(-10, 10)
 1430:     >>> rng = np.random.default_rng()
 1431:     >>> err = rng.normal(scale=1./10, size=len(x))
 1432:     >>> y = hermval(x, [1, 2, 3]) + err
 1433:     >>> hermfit(x, y, 2)
 1434:     array([1.02294967, 2.00016403, 2.99994614]) # may vary
 1435: 
 1436:     """
 1437:     return pu._fit(hermvander, x, y, deg, rcond, full, w)
 1438: 
 1439: 
 1440: def hermcompanion(c):
 1441:     """Return the scaled companion matrix of c.
 1442: 
 1443:     The basis polynomials are scaled so that the companion matrix is
 1444:     symmetric when `c` is an Hermite basis polynomial. This provides
 1445:     better eigenvalue estimates than the unscaled case and for basis
 1446:     polynomials the eigenvalues are guaranteed to be real if
 1447:     `numpy.linalg.eigvalsh` is used to obtain them.
 1448: 
 1449:     Parameters
 1450:     ----------
 1451:     c : array_like
 1452:         1-D array of Hermite series coefficients ordered from low to high
 1453:         degree.
 1454: 
 1455:     Returns
 1456:     -------
 1457:     mat : ndarray
 1458:         Scaled companion matrix of dimensions (deg, deg).
 1459: 
 1460:     Examples
 1461:     --------
 1462:     >>> from numpy.polynomial.hermite import hermcompanion
 1463:     >>> hermcompanion([1, 0, 1])
 1464:     array([[0.        , 0.35355339],
 1465:            [0.70710678, 0.        ]])
 1466: 
 1467:     """
 1468:     # c is a trimmed copy
 1469:     [c] = pu.as_series([c])
 1470:     if len(c) < 2:
 1471:         raise ValueError('Series must have maximum degree of at least 1.')
 1472:     if len(c) == 2:
 1473:         return np.array([[-.5 * c[0] / c[1]]])
 1474: 
 1475:     n = len(c) - 1
 1476:     mat = np.zeros((n, n), dtype=c.dtype)
 1477:     scl = np.hstack((1., 1. / np.sqrt(2. * np.arange(n - 1, 0, -1))))
 1478:     scl = np.multiply.accumulate(scl)[::-1]
 1479:     top = mat.reshape(-1)[1::n + 1]
 1480:     bot = mat.reshape(-1)[n::n + 1]
 1481:     top[...] = np.sqrt(.5 * np.arange(1, n))
 1482:     bot[...] = top
 1483:     mat[:, -1] -= scl * c[:-1] / (2.0 * c[-1])
 1484:     return mat
 1485: 
 1486: 
 1487: def hermroots(c):
 1488:     """
 1489:     Compute the roots of a Hermite series.
 1490: 
 1491:     Return the roots (a.k.a. "zeros") of the polynomial
 1492: 
 1493:     .. math:: p(x) = \\sum_i c[i] * H_i(x).
 1494: 
 1495:     Parameters
 1496:     ----------
 1497:     c : 1-D array_like
 1498:         1-D array of coefficients.
 1499: 
 1500:     Returns
 1501:     -------
 1502:     out : ndarray
 1503:         Array of the roots of the series. If all the roots are real,
 1504:         then `out` is also real, otherwise it is complex.
 1505: 
 1506:     See Also
 1507:     --------
 1508:     numpy.polynomial.polynomial.polyroots
 1509:     numpy.polynomial.legendre.legroots
 1510:     numpy.polynomial.laguerre.lagroots
 1511:     numpy.polynomial.chebyshev.chebroots
 1512:     numpy.polynomial.hermite_e.hermeroots
 1513: 
 1514:     Notes
 1515:     -----
 1516:     The root estimates are obtained as the eigenvalues of the companion
 1517:     matrix, Roots far from the origin of the complex plane may have large
 1518:     errors due to the numerical instability of the series for such
 1519:     values. Roots with multiplicity greater than 1 will also show larger
 1520:     errors as the value of the series near such points is relatively
 1521:     insensitive to errors in the roots. Isolated roots near the origin can
 1522:     be improved by a few iterations of Newton's method.
 1523: 
 1524:     The Hermite series basis polynomials aren't powers of `x` so the
 1525:     results of this function may seem unintuitive.
 1526: 
 1527:     Examples
 1528:     --------
 1529:     >>> from numpy.polynomial.hermite import hermroots, hermfromroots
 1530:     >>> coef = hermfromroots([-1, 0, 1])
 1531:     >>> coef
 1532:     array([0.   ,  0.25 ,  0.   ,  0.125])
 1533:     >>> hermroots(coef)
 1534:     array([-1.00000000e+00, -1.38777878e-17,  1.00000000e+00])
 1535: 
 1536:     """
 1537:     # c is a trimmed copy
 1538:     [c] = pu.as_series([c])
 1539:     if len(c) <= 1:
 1540:         return np.array([], dtype=c.dtype)
 1541:     if len(c) == 2:
 1542:         return np.array([-.5 * c[0] / c[1]])
 1543: 
 1544:     # rotated companion matrix reduces error
 1545:     m = hermcompanion(c)[::-1, ::-1]
 1546:     r = la.eigvals(m)
 1547:     r.sort()
 1548:     return r
 1549: 
 1550: 
 1551: def _normed_hermite_n(x, n):
 1552:     """
 1553:     Evaluate a normalized Hermite polynomial.
 1554: 
 1555:     Compute the value of the normalized Hermite polynomial of degree ``n``
 1556:     at the points ``x``.
 1557: 
 1558: 
 1559:     Parameters
 1560:     ----------
 1561:     x : ndarray of double.
 1562:         Points at which to evaluate the function
 1563:     n : int
 1564:         Degree of the normalized Hermite function to be evaluated.
 1565: 
 1566:     Returns
 1567:     -------
 1568:     values : ndarray
 1569:         The shape of the return value is described above.
 1570: 
 1571:     Notes
 1572:     -----
 1573:     This function is needed for finding the Gauss points and integration
 1574:     weights for high degrees. The values of the standard Hermite functions
 1575:     overflow when n >= 207.
 1576: 
 1577:     """
 1578:     if n == 0:
 1579:         return np.full(x.shape, 1 / np.sqrt(np.sqrt(np.pi)))
 1580: 
 1581:     c0 = 0.
 1582:     c1 = 1. / np.sqrt(np.sqrt(np.pi))
 1583:     nd = float(n)
 1584:     for i in range(n - 1):
 1585:         tmp = c0
 1586:         c0 = -c1 * np.sqrt((nd - 1.) / nd)
 1587:         c1 = tmp + c1 * x * np.sqrt(2. / nd)
 1588:         nd = nd - 1.0
 1589:     return c0 + c1 * x * np.sqrt(2)
 1590: 
 1591: 
 1592: def hermgauss(deg):
 1593:     """
 1594:     Gauss-Hermite quadrature.
 1595: 
 1596:     Computes the sample points and weights for Gauss-Hermite quadrature.
 1597:     These sample points and weights will correctly integrate polynomials of
 1598:     degree :math:`2*deg - 1` or less over the interval :math:`[-\\inf, \\inf]`
 1599:     with the weight function :math:`f(x) = \\exp(-x^2)`.
 1600: 
 1601:     Parameters
 1602:     ----------
 1603:     deg : int
 1604:         Number of sample points and weights. It must be >= 1.
 1605: 
 1606:     Returns
 1607:     -------
 1608:     x : ndarray
 1609:         1-D ndarray containing the sample points.
 1610:     y : ndarray
 1611:         1-D ndarray containing the weights.
 1612: 
 1613:     Notes
 1614:     -----
 1615:     The results have only been tested up to degree 100, higher degrees may
 1616:     be problematic. The weights are determined by using the fact that
 1617: 
 1618:     .. math:: w_k = c / (H'_n(x_k) * H_{n-1}(x_k))
 1619: 
 1620:     where :math:`c` is a constant independent of :math:`k` and :math:`x_k`
 1621:     is the k'th root of :math:`H_n`, and then scaling the results to get
 1622:     the right value when integrating 1.
 1623: 
 1624:     Examples
 1625:     --------
 1626:     >>> from numpy.polynomial.hermite import hermgauss
 1627:     >>> hermgauss(2)
 1628:     (array([-0.70710678,  0.70710678]), array([0.88622693, 0.88622693]))
 1629: 
 1630:     """
 1631:     ideg = pu._as_int(deg, "deg")
 1632:     if ideg <= 0:
 1633:         raise ValueError("deg must be a positive integer")
 1634: 
 1635:     # first approximation of roots. We use the fact that the companion
 1636:     # matrix is symmetric in this case in order to obtain better zeros.
 1637:     c = np.array([0] * deg + [1], dtype=np.float64)
 1638:     m = hermcompanion(c)
 1639:     x = la.eigvalsh(m)
 1640: 
 1641:     # improve roots by one application of Newton
 1642:     dy = _normed_hermite_n(x, ideg)
 1643:     df = _normed_hermite_n(x, ideg - 1) * np.sqrt(2 * ideg)
 1644:     x -= dy / df
 1645: 
 1646:     # compute the weights. We scale the factor to avoid possible numerical
 1647:     # overflow.
 1648:     fm = _normed_hermite_n(x, ideg - 1)
 1649:     fm /= np.abs(fm).max()
 1650:     w = 1 / (fm * fm)
 1651: 
 1652:     # for Hermite we can also symmetrize
 1653:     w = (w + w[::-1]) / 2
 1654:     x = (x - x[::-1]) / 2
 1655: 
 1656:     # scale w to get the right value
 1657:     w *= np.sqrt(np.pi) / w.sum()
 1658: 
 1659:     return x, w
 1660: 
 1661: 
 1662: def hermweight(x):
 1663:     """
 1664:     Weight function of the Hermite polynomials.
 1665: 
 1666:     The weight function is :math:`\\exp(-x^2)` and the interval of
 1667:     integration is :math:`[-\\inf, \\inf]`. the Hermite polynomials are
 1668:     orthogonal, but not normalized, with respect to this weight function.
 1669: 
 1670:     Parameters
 1671:     ----------
 1672:     x : array_like
 1673:        Values at which the weight function will be computed.
 1674: 
 1675:     Returns
 1676:     -------
 1677:     w : ndarray
 1678:        The weight function at `x`.
 1679: 
 1680:     Examples
 1681:     --------
 1682:     >>> import numpy as np
 1683:     >>> from numpy.polynomial.hermite import hermweight
 1684:     >>> x = np.arange(-2, 2)
 1685:     >>> hermweight(x)
 1686:     array([0.01831564, 0.36787944, 1.        , 0.36787944])
 1687: 
 1688:     """
 1689:     w = np.exp(-x**2)
 1690:     return w
 1691: 
 1692: 
 1693: #
 1694: # Hermite series class
 1695: #
 1696: 
 1697: class Hermite(ABCPolyBase):
 1698:     """An Hermite series class.
 1699: 
 1700:     The Hermite class provides the standard Python numerical methods
 1701:     '+', '-', '*', '//', '%', 'divmod', '**', and '()' as well as the
 1702:     attributes and methods listed below.
 1703: 
 1704:     Parameters
 1705:     ----------
 1706:     coef : array_like
 1707:         Hermite coefficients in order of increasing degree, i.e,
 1708:         ``(1, 2, 3)`` gives ``1*H_0(x) + 2*H_1(x) + 3*H_2(x)``.
 1709:     domain : (2,) array_like, optional
 1710:         Domain to use. The interval ``[domain[0], domain[1]]`` is mapped
 1711:         to the interval ``[window[0], window[1]]`` by shifting and scaling.
 1712:         The default value is [-1., 1.].
 1713:     window : (2,) array_like, optional
 1714:         Window, see `domain` for its use. The default value is [-1., 1.].
 1715:     symbol : str, optional
 1716:         Symbol used to represent the independent variable in string
 1717:         representations of the polynomial expression, e.g. for printing.
 1718:         The symbol must be a valid Python identifier. Default value is 'x'.
 1719: 
 1720:         .. versionadded:: 1.24
 1721: 
 1722:     """
 1723:     # Virtual Functions
 1724:     _add = staticmethod(hermadd)
 1725:     _sub = staticmethod(hermsub)
 1726:     _mul = staticmethod(hermmul)
 1727:     _div = staticmethod(hermdiv)
 1728:     _pow = staticmethod(hermpow)
 1729:     _val = staticmethod(hermval)
 1730:     _int = staticmethod(hermint)
 1731:     _der = staticmethod(hermder)
 1732:     _fit = staticmethod(hermfit)
 1733:     _line = staticmethod(hermline)
 1734:     _roots = staticmethod(hermroots)
 1735:     _fromroots = staticmethod(hermfromroots)
 1736: 
 1737:     # Virtual properties
 1738:     domain = np.array(hermdomain)
 1739:     window = np.array(hermdomain)
 1740:     basis_name = 'H'
