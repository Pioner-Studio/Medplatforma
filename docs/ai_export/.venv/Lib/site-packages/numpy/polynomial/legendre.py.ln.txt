    1: """
    2: ==================================================
    3: Legendre Series (:mod:`numpy.polynomial.legendre`)
    4: ==================================================
    5: 
    6: This module provides a number of objects (mostly functions) useful for
    7: dealing with Legendre series, including a `Legendre` class that
    8: encapsulates the usual arithmetic operations.  (General information
    9: on how this module represents and works with such polynomials is in the
   10: docstring for its "parent" sub-package, `numpy.polynomial`).
   11: 
   12: Classes
   13: -------
   14: .. autosummary::
   15:    :toctree: generated/
   16: 
   17:     Legendre
   18: 
   19: Constants
   20: ---------
   21: 
   22: .. autosummary::
   23:    :toctree: generated/
   24: 
   25:    legdomain
   26:    legzero
   27:    legone
   28:    legx
   29: 
   30: Arithmetic
   31: ----------
   32: 
   33: .. autosummary::
   34:    :toctree: generated/
   35: 
   36:    legadd
   37:    legsub
   38:    legmulx
   39:    legmul
   40:    legdiv
   41:    legpow
   42:    legval
   43:    legval2d
   44:    legval3d
   45:    leggrid2d
   46:    leggrid3d
   47: 
   48: Calculus
   49: --------
   50: 
   51: .. autosummary::
   52:    :toctree: generated/
   53: 
   54:    legder
   55:    legint
   56: 
   57: Misc Functions
   58: --------------
   59: 
   60: .. autosummary::
   61:    :toctree: generated/
   62: 
   63:    legfromroots
   64:    legroots
   65:    legvander
   66:    legvander2d
   67:    legvander3d
   68:    leggauss
   69:    legweight
   70:    legcompanion
   71:    legfit
   72:    legtrim
   73:    legline
   74:    leg2poly
   75:    poly2leg
   76: 
   77: See also
   78: --------
   79: numpy.polynomial
   80: 
   81: """
   82: import numpy as np
   83: import numpy.linalg as la
   84: from numpy.lib.array_utils import normalize_axis_index
   85: 
   86: from . import polyutils as pu
   87: from ._polybase import ABCPolyBase
   88: 
   89: __all__ = [
   90:     'legzero', 'legone', 'legx', 'legdomain', 'legline', 'legadd',
   91:     'legsub', 'legmulx', 'legmul', 'legdiv', 'legpow', 'legval', 'legder',
   92:     'legint', 'leg2poly', 'poly2leg', 'legfromroots', 'legvander',
   93:     'legfit', 'legtrim', 'legroots', 'Legendre', 'legval2d', 'legval3d',
   94:     'leggrid2d', 'leggrid3d', 'legvander2d', 'legvander3d', 'legcompanion',
   95:     'leggauss', 'legweight']
   96: 
   97: legtrim = pu.trimcoef
   98: 
   99: 
  100: def poly2leg(pol):
  101:     """
  102:     Convert a polynomial to a Legendre series.
  103: 
  104:     Convert an array representing the coefficients of a polynomial (relative
  105:     to the "standard" basis) ordered from lowest degree to highest, to an
  106:     array of the coefficients of the equivalent Legendre series, ordered
  107:     from lowest to highest degree.
  108: 
  109:     Parameters
  110:     ----------
  111:     pol : array_like
  112:         1-D array containing the polynomial coefficients
  113: 
  114:     Returns
  115:     -------
  116:     c : ndarray
  117:         1-D array containing the coefficients of the equivalent Legendre
  118:         series.
  119: 
  120:     See Also
  121:     --------
  122:     leg2poly
  123: 
  124:     Notes
  125:     -----
  126:     The easy way to do conversions between polynomial basis sets
  127:     is to use the convert method of a class instance.
  128: 
  129:     Examples
  130:     --------
  131:     >>> import numpy as np
  132:     >>> from numpy import polynomial as P
  133:     >>> p = P.Polynomial(np.arange(4))
  134:     >>> p
  135:     Polynomial([0.,  1.,  2.,  3.], domain=[-1.,  1.], window=[-1.,  1.], ...
  136:     >>> c = P.Legendre(P.legendre.poly2leg(p.coef))
  137:     >>> c
  138:     Legendre([ 1.  ,  3.25,  1.  ,  0.75], domain=[-1,  1], window=[-1,  1]) # may vary
  139: 
  140:     """
  141:     [pol] = pu.as_series([pol])
  142:     deg = len(pol) - 1
  143:     res = 0
  144:     for i in range(deg, -1, -1):
  145:         res = legadd(legmulx(res), pol[i])
  146:     return res
  147: 
  148: 
  149: def leg2poly(c):
  150:     """
  151:     Convert a Legendre series to a polynomial.
  152: 
  153:     Convert an array representing the coefficients of a Legendre series,
  154:     ordered from lowest degree to highest, to an array of the coefficients
  155:     of the equivalent polynomial (relative to the "standard" basis) ordered
  156:     from lowest to highest degree.
  157: 
  158:     Parameters
  159:     ----------
  160:     c : array_like
  161:         1-D array containing the Legendre series coefficients, ordered
  162:         from lowest order term to highest.
  163: 
  164:     Returns
  165:     -------
  166:     pol : ndarray
  167:         1-D array containing the coefficients of the equivalent polynomial
  168:         (relative to the "standard" basis) ordered from lowest order term
  169:         to highest.
  170: 
  171:     See Also
  172:     --------
  173:     poly2leg
  174: 
  175:     Notes
  176:     -----
  177:     The easy way to do conversions between polynomial basis sets
  178:     is to use the convert method of a class instance.
  179: 
  180:     Examples
  181:     --------
  182:     >>> from numpy import polynomial as P
  183:     >>> c = P.Legendre(range(4))
  184:     >>> c
  185:     Legendre([0., 1., 2., 3.], domain=[-1.,  1.], window=[-1.,  1.], symbol='x')
  186:     >>> p = c.convert(kind=P.Polynomial)
  187:     >>> p
  188:     Polynomial([-1. , -3.5,  3. ,  7.5], domain=[-1.,  1.], window=[-1., ...
  189:     >>> P.legendre.leg2poly(range(4))
  190:     array([-1. , -3.5,  3. ,  7.5])
  191: 
  192: 
  193:     """
  194:     from .polynomial import polyadd, polymulx, polysub
  195: 
  196:     [c] = pu.as_series([c])
  197:     n = len(c)
  198:     if n < 3:
  199:         return c
  200:     else:
  201:         c0 = c[-2]
  202:         c1 = c[-1]
  203:         # i is the current degree of c1
  204:         for i in range(n - 1, 1, -1):
  205:             tmp = c0
  206:             c0 = polysub(c[i - 2], (c1 * (i - 1)) / i)
  207:             c1 = polyadd(tmp, (polymulx(c1) * (2 * i - 1)) / i)
  208:         return polyadd(c0, polymulx(c1))
  209: 
  210: 
  211: #
  212: # These are constant arrays are of integer type so as to be compatible
  213: # with the widest range of other types, such as Decimal.
  214: #
  215: 
  216: # Legendre
  217: legdomain = np.array([-1., 1.])
  218: 
  219: # Legendre coefficients representing zero.
  220: legzero = np.array([0])
  221: 
  222: # Legendre coefficients representing one.
  223: legone = np.array([1])
  224: 
  225: # Legendre coefficients representing the identity x.
  226: legx = np.array([0, 1])
  227: 
  228: 
  229: def legline(off, scl):
  230:     """
  231:     Legendre series whose graph is a straight line.
  232: 
  233: 
  234: 
  235:     Parameters
  236:     ----------
  237:     off, scl : scalars
  238:         The specified line is given by ``off + scl*x``.
  239: 
  240:     Returns
  241:     -------
  242:     y : ndarray
  243:         This module's representation of the Legendre series for
  244:         ``off + scl*x``.
  245: 
  246:     See Also
  247:     --------
  248:     numpy.polynomial.polynomial.polyline
  249:     numpy.polynomial.chebyshev.chebline
  250:     numpy.polynomial.laguerre.lagline
  251:     numpy.polynomial.hermite.hermline
  252:     numpy.polynomial.hermite_e.hermeline
  253: 
  254:     Examples
  255:     --------
  256:     >>> import numpy.polynomial.legendre as L
  257:     >>> L.legline(3,2)
  258:     array([3, 2])
  259:     >>> L.legval(-3, L.legline(3,2)) # should be -3
  260:     -3.0
  261: 
  262:     """
  263:     if scl != 0:
  264:         return np.array([off, scl])
  265:     else:
  266:         return np.array([off])
  267: 
  268: 
  269: def legfromroots(roots):
  270:     """
  271:     Generate a Legendre series with given roots.
  272: 
  273:     The function returns the coefficients of the polynomial
  274: 
  275:     .. math:: p(x) = (x - r_0) * (x - r_1) * ... * (x - r_n),
  276: 
  277:     in Legendre form, where the :math:`r_n` are the roots specified in `roots`.
  278:     If a zero has multiplicity n, then it must appear in `roots` n times.
  279:     For instance, if 2 is a root of multiplicity three and 3 is a root of
  280:     multiplicity 2, then `roots` looks something like [2, 2, 2, 3, 3]. The
  281:     roots can appear in any order.
  282: 
  283:     If the returned coefficients are `c`, then
  284: 
  285:     .. math:: p(x) = c_0 + c_1 * L_1(x) + ... +  c_n * L_n(x)
  286: 
  287:     The coefficient of the last term is not generally 1 for monic
  288:     polynomials in Legendre form.
  289: 
  290:     Parameters
  291:     ----------
  292:     roots : array_like
  293:         Sequence containing the roots.
  294: 
  295:     Returns
  296:     -------
  297:     out : ndarray
  298:         1-D array of coefficients.  If all roots are real then `out` is a
  299:         real array, if some of the roots are complex, then `out` is complex
  300:         even if all the coefficients in the result are real (see Examples
  301:         below).
  302: 
  303:     See Also
  304:     --------
  305:     numpy.polynomial.polynomial.polyfromroots
  306:     numpy.polynomial.chebyshev.chebfromroots
  307:     numpy.polynomial.laguerre.lagfromroots
  308:     numpy.polynomial.hermite.hermfromroots
  309:     numpy.polynomial.hermite_e.hermefromroots
  310: 
  311:     Examples
  312:     --------
  313:     >>> import numpy.polynomial.legendre as L
  314:     >>> L.legfromroots((-1,0,1)) # x^3 - x relative to the standard basis
  315:     array([ 0. , -0.4,  0. ,  0.4])
  316:     >>> j = complex(0,1)
  317:     >>> L.legfromroots((-j,j)) # x^2 + 1 relative to the standard basis
  318:     array([ 1.33333333+0.j,  0.00000000+0.j,  0.66666667+0.j]) # may vary
  319: 
  320:     """
  321:     return pu._fromroots(legline, legmul, roots)
  322: 
  323: 
  324: def legadd(c1, c2):
  325:     """
  326:     Add one Legendre series to another.
  327: 
  328:     Returns the sum of two Legendre series `c1` + `c2`.  The arguments
  329:     are sequences of coefficients ordered from lowest order term to
  330:     highest, i.e., [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.
  331: 
  332:     Parameters
  333:     ----------
  334:     c1, c2 : array_like
  335:         1-D arrays of Legendre series coefficients ordered from low to
  336:         high.
  337: 
  338:     Returns
  339:     -------
  340:     out : ndarray
  341:         Array representing the Legendre series of their sum.
  342: 
  343:     See Also
  344:     --------
  345:     legsub, legmulx, legmul, legdiv, legpow
  346: 
  347:     Notes
  348:     -----
  349:     Unlike multiplication, division, etc., the sum of two Legendre series
  350:     is a Legendre series (without having to "reproject" the result onto
  351:     the basis set) so addition, just like that of "standard" polynomials,
  352:     is simply "component-wise."
  353: 
  354:     Examples
  355:     --------
  356:     >>> from numpy.polynomial import legendre as L
  357:     >>> c1 = (1,2,3)
  358:     >>> c2 = (3,2,1)
  359:     >>> L.legadd(c1,c2)
  360:     array([4.,  4.,  4.])
  361: 
  362:     """
  363:     return pu._add(c1, c2)
  364: 
  365: 
  366: def legsub(c1, c2):
  367:     """
  368:     Subtract one Legendre series from another.
  369: 
  370:     Returns the difference of two Legendre series `c1` - `c2`.  The
  371:     sequences of coefficients are from lowest order term to highest, i.e.,
  372:     [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.
  373: 
  374:     Parameters
  375:     ----------
  376:     c1, c2 : array_like
  377:         1-D arrays of Legendre series coefficients ordered from low to
  378:         high.
  379: 
  380:     Returns
  381:     -------
  382:     out : ndarray
  383:         Of Legendre series coefficients representing their difference.
  384: 
  385:     See Also
  386:     --------
  387:     legadd, legmulx, legmul, legdiv, legpow
  388: 
  389:     Notes
  390:     -----
  391:     Unlike multiplication, division, etc., the difference of two Legendre
  392:     series is a Legendre series (without having to "reproject" the result
  393:     onto the basis set) so subtraction, just like that of "standard"
  394:     polynomials, is simply "component-wise."
  395: 
  396:     Examples
  397:     --------
  398:     >>> from numpy.polynomial import legendre as L
  399:     >>> c1 = (1,2,3)
  400:     >>> c2 = (3,2,1)
  401:     >>> L.legsub(c1,c2)
  402:     array([-2.,  0.,  2.])
  403:     >>> L.legsub(c2,c1) # -C.legsub(c1,c2)
  404:     array([ 2.,  0., -2.])
  405: 
  406:     """
  407:     return pu._sub(c1, c2)
  408: 
  409: 
  410: def legmulx(c):
  411:     """Multiply a Legendre series by x.
  412: 
  413:     Multiply the Legendre series `c` by x, where x is the independent
  414:     variable.
  415: 
  416: 
  417:     Parameters
  418:     ----------
  419:     c : array_like
  420:         1-D array of Legendre series coefficients ordered from low to
  421:         high.
  422: 
  423:     Returns
  424:     -------
  425:     out : ndarray
  426:         Array representing the result of the multiplication.
  427: 
  428:     See Also
  429:     --------
  430:     legadd, legsub, legmul, legdiv, legpow
  431: 
  432:     Notes
  433:     -----
  434:     The multiplication uses the recursion relationship for Legendre
  435:     polynomials in the form
  436: 
  437:     .. math::
  438: 
  439:       xP_i(x) = ((i + 1)*P_{i + 1}(x) + i*P_{i - 1}(x))/(2i + 1)
  440: 
  441:     Examples
  442:     --------
  443:     >>> from numpy.polynomial import legendre as L
  444:     >>> L.legmulx([1,2,3])
  445:     array([ 0.66666667, 2.2, 1.33333333, 1.8]) # may vary
  446: 
  447:     """
  448:     # c is a trimmed copy
  449:     [c] = pu.as_series([c])
  450:     # The zero series needs special treatment
  451:     if len(c) == 1 and c[0] == 0:
  452:         return c
  453: 
  454:     prd = np.empty(len(c) + 1, dtype=c.dtype)
  455:     prd[0] = c[0] * 0
  456:     prd[1] = c[0]
  457:     for i in range(1, len(c)):
  458:         j = i + 1
  459:         k = i - 1
  460:         s = i + j
  461:         prd[j] = (c[i] * j) / s
  462:         prd[k] += (c[i] * i) / s
  463:     return prd
  464: 
  465: 
  466: def legmul(c1, c2):
  467:     """
  468:     Multiply one Legendre series by another.
  469: 
  470:     Returns the product of two Legendre series `c1` * `c2`.  The arguments
  471:     are sequences of coefficients, from lowest order "term" to highest,
  472:     e.g., [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.
  473: 
  474:     Parameters
  475:     ----------
  476:     c1, c2 : array_like
  477:         1-D arrays of Legendre series coefficients ordered from low to
  478:         high.
  479: 
  480:     Returns
  481:     -------
  482:     out : ndarray
  483:         Of Legendre series coefficients representing their product.
  484: 
  485:     See Also
  486:     --------
  487:     legadd, legsub, legmulx, legdiv, legpow
  488: 
  489:     Notes
  490:     -----
  491:     In general, the (polynomial) product of two C-series results in terms
  492:     that are not in the Legendre polynomial basis set.  Thus, to express
  493:     the product as a Legendre series, it is necessary to "reproject" the
  494:     product onto said basis set, which may produce "unintuitive" (but
  495:     correct) results; see Examples section below.
  496: 
  497:     Examples
  498:     --------
  499:     >>> from numpy.polynomial import legendre as L
  500:     >>> c1 = (1,2,3)
  501:     >>> c2 = (3,2)
  502:     >>> L.legmul(c1,c2) # multiplication requires "reprojection"
  503:     array([  4.33333333,  10.4       ,  11.66666667,   3.6       ]) # may vary
  504: 
  505:     """
  506:     # s1, s2 are trimmed copies
  507:     [c1, c2] = pu.as_series([c1, c2])
  508: 
  509:     if len(c1) > len(c2):
  510:         c = c2
  511:         xs = c1
  512:     else:
  513:         c = c1
  514:         xs = c2
  515: 
  516:     if len(c) == 1:
  517:         c0 = c[0] * xs
  518:         c1 = 0
  519:     elif len(c) == 2:
  520:         c0 = c[0] * xs
  521:         c1 = c[1] * xs
  522:     else:
  523:         nd = len(c)
  524:         c0 = c[-2] * xs
  525:         c1 = c[-1] * xs
  526:         for i in range(3, len(c) + 1):
  527:             tmp = c0
  528:             nd = nd - 1
  529:             c0 = legsub(c[-i] * xs, (c1 * (nd - 1)) / nd)
  530:             c1 = legadd(tmp, (legmulx(c1) * (2 * nd - 1)) / nd)
  531:     return legadd(c0, legmulx(c1))
  532: 
  533: 
  534: def legdiv(c1, c2):
  535:     """
  536:     Divide one Legendre series by another.
  537: 
  538:     Returns the quotient-with-remainder of two Legendre series
  539:     `c1` / `c2`.  The arguments are sequences of coefficients from lowest
  540:     order "term" to highest, e.g., [1,2,3] represents the series
  541:     ``P_0 + 2*P_1 + 3*P_2``.
  542: 
  543:     Parameters
  544:     ----------
  545:     c1, c2 : array_like
  546:         1-D arrays of Legendre series coefficients ordered from low to
  547:         high.
  548: 
  549:     Returns
  550:     -------
  551:     quo, rem : ndarrays
  552:         Of Legendre series coefficients representing the quotient and
  553:         remainder.
  554: 
  555:     See Also
  556:     --------
  557:     legadd, legsub, legmulx, legmul, legpow
  558: 
  559:     Notes
  560:     -----
  561:     In general, the (polynomial) division of one Legendre series by another
  562:     results in quotient and remainder terms that are not in the Legendre
  563:     polynomial basis set.  Thus, to express these results as a Legendre
  564:     series, it is necessary to "reproject" the results onto the Legendre
  565:     basis set, which may produce "unintuitive" (but correct) results; see
  566:     Examples section below.
  567: 
  568:     Examples
  569:     --------
  570:     >>> from numpy.polynomial import legendre as L
  571:     >>> c1 = (1,2,3)
  572:     >>> c2 = (3,2,1)
  573:     >>> L.legdiv(c1,c2) # quotient "intuitive," remainder not
  574:     (array([3.]), array([-8., -4.]))
  575:     >>> c2 = (0,1,2,3)
  576:     >>> L.legdiv(c2,c1) # neither "intuitive"
  577:     (array([-0.07407407,  1.66666667]), array([-1.03703704, -2.51851852])) # may vary
  578: 
  579:     """
  580:     return pu._div(legmul, c1, c2)
  581: 
  582: 
  583: def legpow(c, pow, maxpower=16):
  584:     """Raise a Legendre series to a power.
  585: 
  586:     Returns the Legendre series `c` raised to the power `pow`. The
  587:     argument `c` is a sequence of coefficients ordered from low to high.
  588:     i.e., [1,2,3] is the series  ``P_0 + 2*P_1 + 3*P_2.``
  589: 
  590:     Parameters
  591:     ----------
  592:     c : array_like
  593:         1-D array of Legendre series coefficients ordered from low to
  594:         high.
  595:     pow : integer
  596:         Power to which the series will be raised
  597:     maxpower : integer, optional
  598:         Maximum power allowed. This is mainly to limit growth of the series
  599:         to unmanageable size. Default is 16
  600: 
  601:     Returns
  602:     -------
  603:     coef : ndarray
  604:         Legendre series of power.
  605: 
  606:     See Also
  607:     --------
  608:     legadd, legsub, legmulx, legmul, legdiv
  609: 
  610:     """
  611:     return pu._pow(legmul, c, pow, maxpower)
  612: 
  613: 
  614: def legder(c, m=1, scl=1, axis=0):
  615:     """
  616:     Differentiate a Legendre series.
  617: 
  618:     Returns the Legendre series coefficients `c` differentiated `m` times
  619:     along `axis`.  At each iteration the result is multiplied by `scl` (the
  620:     scaling factor is for use in a linear change of variable). The argument
  621:     `c` is an array of coefficients from low to high degree along each
  622:     axis, e.g., [1,2,3] represents the series ``1*L_0 + 2*L_1 + 3*L_2``
  623:     while [[1,2],[1,2]] represents ``1*L_0(x)*L_0(y) + 1*L_1(x)*L_0(y) +
  624:     2*L_0(x)*L_1(y) + 2*L_1(x)*L_1(y)`` if axis=0 is ``x`` and axis=1 is
  625:     ``y``.
  626: 
  627:     Parameters
  628:     ----------
  629:     c : array_like
  630:         Array of Legendre series coefficients. If c is multidimensional the
  631:         different axis correspond to different variables with the degree in
  632:         each axis given by the corresponding index.
  633:     m : int, optional
  634:         Number of derivatives taken, must be non-negative. (Default: 1)
  635:     scl : scalar, optional
  636:         Each differentiation is multiplied by `scl`.  The end result is
  637:         multiplication by ``scl**m``.  This is for use in a linear change of
  638:         variable. (Default: 1)
  639:     axis : int, optional
  640:         Axis over which the derivative is taken. (Default: 0).
  641: 
  642:     Returns
  643:     -------
  644:     der : ndarray
  645:         Legendre series of the derivative.
  646: 
  647:     See Also
  648:     --------
  649:     legint
  650: 
  651:     Notes
  652:     -----
  653:     In general, the result of differentiating a Legendre series does not
  654:     resemble the same operation on a power series. Thus the result of this
  655:     function may be "unintuitive," albeit correct; see Examples section
  656:     below.
  657: 
  658:     Examples
  659:     --------
  660:     >>> from numpy.polynomial import legendre as L
  661:     >>> c = (1,2,3,4)
  662:     >>> L.legder(c)
  663:     array([  6.,   9.,  20.])
  664:     >>> L.legder(c, 3)
  665:     array([60.])
  666:     >>> L.legder(c, scl=-1)
  667:     array([ -6.,  -9., -20.])
  668:     >>> L.legder(c, 2,-1)
  669:     array([  9.,  60.])
  670: 
  671:     """
  672:     c = np.array(c, ndmin=1, copy=True)
  673:     if c.dtype.char in '?bBhHiIlLqQpP':
  674:         c = c.astype(np.double)
  675:     cnt = pu._as_int(m, "the order of derivation")
  676:     iaxis = pu._as_int(axis, "the axis")
  677:     if cnt < 0:
  678:         raise ValueError("The order of derivation must be non-negative")
  679:     iaxis = normalize_axis_index(iaxis, c.ndim)
  680: 
  681:     if cnt == 0:
  682:         return c
  683: 
  684:     c = np.moveaxis(c, iaxis, 0)
  685:     n = len(c)
  686:     if cnt >= n:
  687:         c = c[:1] * 0
  688:     else:
  689:         for i in range(cnt):
  690:             n = n - 1
  691:             c *= scl
  692:             der = np.empty((n,) + c.shape[1:], dtype=c.dtype)
  693:             for j in range(n, 2, -1):
  694:                 der[j - 1] = (2 * j - 1) * c[j]
  695:                 c[j - 2] += c[j]
  696:             if n > 1:
  697:                 der[1] = 3 * c[2]
  698:             der[0] = c[1]
  699:             c = der
  700:     c = np.moveaxis(c, 0, iaxis)
  701:     return c
  702: 
  703: 
  704: def legint(c, m=1, k=[], lbnd=0, scl=1, axis=0):
  705:     """
  706:     Integrate a Legendre series.
  707: 
  708:     Returns the Legendre series coefficients `c` integrated `m` times from
  709:     `lbnd` along `axis`. At each iteration the resulting series is
  710:     **multiplied** by `scl` and an integration constant, `k`, is added.
  711:     The scaling factor is for use in a linear change of variable.  ("Buyer
  712:     beware": note that, depending on what one is doing, one may want `scl`
  713:     to be the reciprocal of what one might expect; for more information,
  714:     see the Notes section below.)  The argument `c` is an array of
  715:     coefficients from low to high degree along each axis, e.g., [1,2,3]
  716:     represents the series ``L_0 + 2*L_1 + 3*L_2`` while [[1,2],[1,2]]
  717:     represents ``1*L_0(x)*L_0(y) + 1*L_1(x)*L_0(y) + 2*L_0(x)*L_1(y) +
  718:     2*L_1(x)*L_1(y)`` if axis=0 is ``x`` and axis=1 is ``y``.
  719: 
  720:     Parameters
  721:     ----------
  722:     c : array_like
  723:         Array of Legendre series coefficients. If c is multidimensional the
  724:         different axis correspond to different variables with the degree in
  725:         each axis given by the corresponding index.
  726:     m : int, optional
  727:         Order of integration, must be positive. (Default: 1)
  728:     k : {[], list, scalar}, optional
  729:         Integration constant(s).  The value of the first integral at
  730:         ``lbnd`` is the first value in the list, the value of the second
  731:         integral at ``lbnd`` is the second value, etc.  If ``k == []`` (the
  732:         default), all constants are set to zero.  If ``m == 1``, a single
  733:         scalar can be given instead of a list.
  734:     lbnd : scalar, optional
  735:         The lower bound of the integral. (Default: 0)
  736:     scl : scalar, optional
  737:         Following each integration the result is *multiplied* by `scl`
  738:         before the integration constant is added. (Default: 1)
  739:     axis : int, optional
  740:         Axis over which the integral is taken. (Default: 0).
  741: 
  742:     Returns
  743:     -------
  744:     S : ndarray
  745:         Legendre series coefficient array of the integral.
  746: 
  747:     Raises
  748:     ------
  749:     ValueError
  750:         If ``m < 0``, ``len(k) > m``, ``np.ndim(lbnd) != 0``, or
  751:         ``np.ndim(scl) != 0``.
  752: 
  753:     See Also
  754:     --------
  755:     legder
  756: 
  757:     Notes
  758:     -----
  759:     Note that the result of each integration is *multiplied* by `scl`.
  760:     Why is this important to note?  Say one is making a linear change of
  761:     variable :math:`u = ax + b` in an integral relative to `x`.  Then
  762:     :math:`dx = du/a`, so one will need to set `scl` equal to
  763:     :math:`1/a` - perhaps not what one would have first thought.
  764: 
  765:     Also note that, in general, the result of integrating a C-series needs
  766:     to be "reprojected" onto the C-series basis set.  Thus, typically,
  767:     the result of this function is "unintuitive," albeit correct; see
  768:     Examples section below.
  769: 
  770:     Examples
  771:     --------
  772:     >>> from numpy.polynomial import legendre as L
  773:     >>> c = (1,2,3)
  774:     >>> L.legint(c)
  775:     array([ 0.33333333,  0.4       ,  0.66666667,  0.6       ]) # may vary
  776:     >>> L.legint(c, 3)
  777:     array([  1.66666667e-02,  -1.78571429e-02,   4.76190476e-02, # may vary
  778:              -1.73472348e-18,   1.90476190e-02,   9.52380952e-03])
  779:     >>> L.legint(c, k=3)
  780:      array([ 3.33333333,  0.4       ,  0.66666667,  0.6       ]) # may vary
  781:     >>> L.legint(c, lbnd=-2)
  782:     array([ 7.33333333,  0.4       ,  0.66666667,  0.6       ]) # may vary
  783:     >>> L.legint(c, scl=2)
  784:     array([ 0.66666667,  0.8       ,  1.33333333,  1.2       ]) # may vary
  785: 
  786:     """
  787:     c = np.array(c, ndmin=1, copy=True)
  788:     if c.dtype.char in '?bBhHiIlLqQpP':
  789:         c = c.astype(np.double)
  790:     if not np.iterable(k):
  791:         k = [k]
  792:     cnt = pu._as_int(m, "the order of integration")
  793:     iaxis = pu._as_int(axis, "the axis")
  794:     if cnt < 0:
  795:         raise ValueError("The order of integration must be non-negative")
  796:     if len(k) > cnt:
  797:         raise ValueError("Too many integration constants")
  798:     if np.ndim(lbnd) != 0:
  799:         raise ValueError("lbnd must be a scalar.")
  800:     if np.ndim(scl) != 0:
  801:         raise ValueError("scl must be a scalar.")
  802:     iaxis = normalize_axis_index(iaxis, c.ndim)
  803: 
  804:     if cnt == 0:
  805:         return c
  806: 
  807:     c = np.moveaxis(c, iaxis, 0)
  808:     k = list(k) + [0] * (cnt - len(k))
  809:     for i in range(cnt):
  810:         n = len(c)
  811:         c *= scl
  812:         if n == 1 and np.all(c[0] == 0):
  813:             c[0] += k[i]
  814:         else:
  815:             tmp = np.empty((n + 1,) + c.shape[1:], dtype=c.dtype)
  816:             tmp[0] = c[0] * 0
  817:             tmp[1] = c[0]
  818:             if n > 1:
  819:                 tmp[2] = c[1] / 3
  820:             for j in range(2, n):
  821:                 t = c[j] / (2 * j + 1)
  822:                 tmp[j + 1] = t
  823:                 tmp[j - 1] -= t
  824:             tmp[0] += k[i] - legval(lbnd, tmp)
  825:             c = tmp
  826:     c = np.moveaxis(c, 0, iaxis)
  827:     return c
  828: 
  829: 
  830: def legval(x, c, tensor=True):
  831:     """
  832:     Evaluate a Legendre series at points x.
  833: 
  834:     If `c` is of length ``n + 1``, this function returns the value:
  835: 
  836:     .. math:: p(x) = c_0 * L_0(x) + c_1 * L_1(x) + ... + c_n * L_n(x)
  837: 
  838:     The parameter `x` is converted to an array only if it is a tuple or a
  839:     list, otherwise it is treated as a scalar. In either case, either `x`
  840:     or its elements must support multiplication and addition both with
  841:     themselves and with the elements of `c`.
  842: 
  843:     If `c` is a 1-D array, then ``p(x)`` will have the same shape as `x`.  If
  844:     `c` is multidimensional, then the shape of the result depends on the
  845:     value of `tensor`. If `tensor` is true the shape will be c.shape[1:] +
  846:     x.shape. If `tensor` is false the shape will be c.shape[1:]. Note that
  847:     scalars have shape (,).
  848: 
  849:     Trailing zeros in the coefficients will be used in the evaluation, so
  850:     they should be avoided if efficiency is a concern.
  851: 
  852:     Parameters
  853:     ----------
  854:     x : array_like, compatible object
  855:         If `x` is a list or tuple, it is converted to an ndarray, otherwise
  856:         it is left unchanged and treated as a scalar. In either case, `x`
  857:         or its elements must support addition and multiplication with
  858:         themselves and with the elements of `c`.
  859:     c : array_like
  860:         Array of coefficients ordered so that the coefficients for terms of
  861:         degree n are contained in c[n]. If `c` is multidimensional the
  862:         remaining indices enumerate multiple polynomials. In the two
  863:         dimensional case the coefficients may be thought of as stored in
  864:         the columns of `c`.
  865:     tensor : boolean, optional
  866:         If True, the shape of the coefficient array is extended with ones
  867:         on the right, one for each dimension of `x`. Scalars have dimension 0
  868:         for this action. The result is that every column of coefficients in
  869:         `c` is evaluated for every element of `x`. If False, `x` is broadcast
  870:         over the columns of `c` for the evaluation.  This keyword is useful
  871:         when `c` is multidimensional. The default value is True.
  872: 
  873:     Returns
  874:     -------
  875:     values : ndarray, algebra_like
  876:         The shape of the return value is described above.
  877: 
  878:     See Also
  879:     --------
  880:     legval2d, leggrid2d, legval3d, leggrid3d
  881: 
  882:     Notes
  883:     -----
  884:     The evaluation uses Clenshaw recursion, aka synthetic division.
  885: 
  886:     """
  887:     c = np.array(c, ndmin=1, copy=None)
  888:     if c.dtype.char in '?bBhHiIlLqQpP':
  889:         c = c.astype(np.double)
  890:     if isinstance(x, (tuple, list)):
  891:         x = np.asarray(x)
  892:     if isinstance(x, np.ndarray) and tensor:
  893:         c = c.reshape(c.shape + (1,) * x.ndim)
  894: 
  895:     if len(c) == 1:
  896:         c0 = c[0]
  897:         c1 = 0
  898:     elif len(c) == 2:
  899:         c0 = c[0]
  900:         c1 = c[1]
  901:     else:
  902:         nd = len(c)
  903:         c0 = c[-2]
  904:         c1 = c[-1]
  905:         for i in range(3, len(c) + 1):
  906:             tmp = c0
  907:             nd = nd - 1
  908:             c0 = c[-i] - c1 * ((nd - 1) / nd)
  909:             c1 = tmp + c1 * x * ((2 * nd - 1) / nd)
  910:     return c0 + c1 * x
  911: 
  912: 
  913: def legval2d(x, y, c):
  914:     """
  915:     Evaluate a 2-D Legendre series at points (x, y).
  916: 
  917:     This function returns the values:
  918: 
  919:     .. math:: p(x,y) = \\sum_{i,j} c_{i,j} * L_i(x) * L_j(y)
  920: 
  921:     The parameters `x` and `y` are converted to arrays only if they are
  922:     tuples or a lists, otherwise they are treated as a scalars and they
  923:     must have the same shape after conversion. In either case, either `x`
  924:     and `y` or their elements must support multiplication and addition both
  925:     with themselves and with the elements of `c`.
  926: 
  927:     If `c` is a 1-D array a one is implicitly appended to its shape to make
  928:     it 2-D. The shape of the result will be c.shape[2:] + x.shape.
  929: 
  930:     Parameters
  931:     ----------
  932:     x, y : array_like, compatible objects
  933:         The two dimensional series is evaluated at the points ``(x, y)``,
  934:         where `x` and `y` must have the same shape. If `x` or `y` is a list
  935:         or tuple, it is first converted to an ndarray, otherwise it is left
  936:         unchanged and if it isn't an ndarray it is treated as a scalar.
  937:     c : array_like
  938:         Array of coefficients ordered so that the coefficient of the term
  939:         of multi-degree i,j is contained in ``c[i,j]``. If `c` has
  940:         dimension greater than two the remaining indices enumerate multiple
  941:         sets of coefficients.
  942: 
  943:     Returns
  944:     -------
  945:     values : ndarray, compatible object
  946:         The values of the two dimensional Legendre series at points formed
  947:         from pairs of corresponding values from `x` and `y`.
  948: 
  949:     See Also
  950:     --------
  951:     legval, leggrid2d, legval3d, leggrid3d
  952:     """
  953:     return pu._valnd(legval, c, x, y)
  954: 
  955: 
  956: def leggrid2d(x, y, c):
  957:     """
  958:     Evaluate a 2-D Legendre series on the Cartesian product of x and y.
  959: 
  960:     This function returns the values:
  961: 
  962:     .. math:: p(a,b) = \\sum_{i,j} c_{i,j} * L_i(a) * L_j(b)
  963: 
  964:     where the points ``(a, b)`` consist of all pairs formed by taking
  965:     `a` from `x` and `b` from `y`. The resulting points form a grid with
  966:     `x` in the first dimension and `y` in the second.
  967: 
  968:     The parameters `x` and `y` are converted to arrays only if they are
  969:     tuples or a lists, otherwise they are treated as a scalars. In either
  970:     case, either `x` and `y` or their elements must support multiplication
  971:     and addition both with themselves and with the elements of `c`.
  972: 
  973:     If `c` has fewer than two dimensions, ones are implicitly appended to
  974:     its shape to make it 2-D. The shape of the result will be c.shape[2:] +
  975:     x.shape + y.shape.
  976: 
  977:     Parameters
  978:     ----------
  979:     x, y : array_like, compatible objects
  980:         The two dimensional series is evaluated at the points in the
  981:         Cartesian product of `x` and `y`.  If `x` or `y` is a list or
  982:         tuple, it is first converted to an ndarray, otherwise it is left
  983:         unchanged and, if it isn't an ndarray, it is treated as a scalar.
  984:     c : array_like
  985:         Array of coefficients ordered so that the coefficient of the term of
  986:         multi-degree i,j is contained in ``c[i,j]``. If `c` has dimension
  987:         greater than two the remaining indices enumerate multiple sets of
  988:         coefficients.
  989: 
  990:     Returns
  991:     -------
  992:     values : ndarray, compatible object
  993:         The values of the two dimensional Chebyshev series at points in the
  994:         Cartesian product of `x` and `y`.
  995: 
  996:     See Also
  997:     --------
  998:     legval, legval2d, legval3d, leggrid3d
  999:     """
 1000:     return pu._gridnd(legval, c, x, y)
 1001: 
 1002: 
 1003: def legval3d(x, y, z, c):
 1004:     """
 1005:     Evaluate a 3-D Legendre series at points (x, y, z).
 1006: 
 1007:     This function returns the values:
 1008: 
 1009:     .. math:: p(x,y,z) = \\sum_{i,j,k} c_{i,j,k} * L_i(x) * L_j(y) * L_k(z)
 1010: 
 1011:     The parameters `x`, `y`, and `z` are converted to arrays only if
 1012:     they are tuples or a lists, otherwise they are treated as a scalars and
 1013:     they must have the same shape after conversion. In either case, either
 1014:     `x`, `y`, and `z` or their elements must support multiplication and
 1015:     addition both with themselves and with the elements of `c`.
 1016: 
 1017:     If `c` has fewer than 3 dimensions, ones are implicitly appended to its
 1018:     shape to make it 3-D. The shape of the result will be c.shape[3:] +
 1019:     x.shape.
 1020: 
 1021:     Parameters
 1022:     ----------
 1023:     x, y, z : array_like, compatible object
 1024:         The three dimensional series is evaluated at the points
 1025:         ``(x, y, z)``, where `x`, `y`, and `z` must have the same shape.  If
 1026:         any of `x`, `y`, or `z` is a list or tuple, it is first converted
 1027:         to an ndarray, otherwise it is left unchanged and if it isn't an
 1028:         ndarray it is  treated as a scalar.
 1029:     c : array_like
 1030:         Array of coefficients ordered so that the coefficient of the term of
 1031:         multi-degree i,j,k is contained in ``c[i,j,k]``. If `c` has dimension
 1032:         greater than 3 the remaining indices enumerate multiple sets of
 1033:         coefficients.
 1034: 
 1035:     Returns
 1036:     -------
 1037:     values : ndarray, compatible object
 1038:         The values of the multidimensional polynomial on points formed with
 1039:         triples of corresponding values from `x`, `y`, and `z`.
 1040: 
 1041:     See Also
 1042:     --------
 1043:     legval, legval2d, leggrid2d, leggrid3d
 1044:     """
 1045:     return pu._valnd(legval, c, x, y, z)
 1046: 
 1047: 
 1048: def leggrid3d(x, y, z, c):
 1049:     """
 1050:     Evaluate a 3-D Legendre series on the Cartesian product of x, y, and z.
 1051: 
 1052:     This function returns the values:
 1053: 
 1054:     .. math:: p(a,b,c) = \\sum_{i,j,k} c_{i,j,k} * L_i(a) * L_j(b) * L_k(c)
 1055: 
 1056:     where the points ``(a, b, c)`` consist of all triples formed by taking
 1057:     `a` from `x`, `b` from `y`, and `c` from `z`. The resulting points form
 1058:     a grid with `x` in the first dimension, `y` in the second, and `z` in
 1059:     the third.
 1060: 
 1061:     The parameters `x`, `y`, and `z` are converted to arrays only if they
 1062:     are tuples or a lists, otherwise they are treated as a scalars. In
 1063:     either case, either `x`, `y`, and `z` or their elements must support
 1064:     multiplication and addition both with themselves and with the elements
 1065:     of `c`.
 1066: 
 1067:     If `c` has fewer than three dimensions, ones are implicitly appended to
 1068:     its shape to make it 3-D. The shape of the result will be c.shape[3:] +
 1069:     x.shape + y.shape + z.shape.
 1070: 
 1071:     Parameters
 1072:     ----------
 1073:     x, y, z : array_like, compatible objects
 1074:         The three dimensional series is evaluated at the points in the
 1075:         Cartesian product of `x`, `y`, and `z`.  If `x`, `y`, or `z` is a
 1076:         list or tuple, it is first converted to an ndarray, otherwise it is
 1077:         left unchanged and, if it isn't an ndarray, it is treated as a
 1078:         scalar.
 1079:     c : array_like
 1080:         Array of coefficients ordered so that the coefficients for terms of
 1081:         degree i,j are contained in ``c[i,j]``. If `c` has dimension
 1082:         greater than two the remaining indices enumerate multiple sets of
 1083:         coefficients.
 1084: 
 1085:     Returns
 1086:     -------
 1087:     values : ndarray, compatible object
 1088:         The values of the two dimensional polynomial at points in the Cartesian
 1089:         product of `x` and `y`.
 1090: 
 1091:     See Also
 1092:     --------
 1093:     legval, legval2d, leggrid2d, legval3d
 1094:     """
 1095:     return pu._gridnd(legval, c, x, y, z)
 1096: 
 1097: 
 1098: def legvander(x, deg):
 1099:     """Pseudo-Vandermonde matrix of given degree.
 1100: 
 1101:     Returns the pseudo-Vandermonde matrix of degree `deg` and sample points
 1102:     `x`. The pseudo-Vandermonde matrix is defined by
 1103: 
 1104:     .. math:: V[..., i] = L_i(x)
 1105: 
 1106:     where ``0 <= i <= deg``. The leading indices of `V` index the elements of
 1107:     `x` and the last index is the degree of the Legendre polynomial.
 1108: 
 1109:     If `c` is a 1-D array of coefficients of length ``n + 1`` and `V` is the
 1110:     array ``V = legvander(x, n)``, then ``np.dot(V, c)`` and
 1111:     ``legval(x, c)`` are the same up to roundoff. This equivalence is
 1112:     useful both for least squares fitting and for the evaluation of a large
 1113:     number of Legendre series of the same degree and sample points.
 1114: 
 1115:     Parameters
 1116:     ----------
 1117:     x : array_like
 1118:         Array of points. The dtype is converted to float64 or complex128
 1119:         depending on whether any of the elements are complex. If `x` is
 1120:         scalar it is converted to a 1-D array.
 1121:     deg : int
 1122:         Degree of the resulting matrix.
 1123: 
 1124:     Returns
 1125:     -------
 1126:     vander : ndarray
 1127:         The pseudo-Vandermonde matrix. The shape of the returned matrix is
 1128:         ``x.shape + (deg + 1,)``, where The last index is the degree of the
 1129:         corresponding Legendre polynomial.  The dtype will be the same as
 1130:         the converted `x`.
 1131: 
 1132:     """
 1133:     ideg = pu._as_int(deg, "deg")
 1134:     if ideg < 0:
 1135:         raise ValueError("deg must be non-negative")
 1136: 
 1137:     x = np.array(x, copy=None, ndmin=1) + 0.0
 1138:     dims = (ideg + 1,) + x.shape
 1139:     dtyp = x.dtype
 1140:     v = np.empty(dims, dtype=dtyp)
 1141:     # Use forward recursion to generate the entries. This is not as accurate
 1142:     # as reverse recursion in this application but it is more efficient.
 1143:     v[0] = x * 0 + 1
 1144:     if ideg > 0:
 1145:         v[1] = x
 1146:         for i in range(2, ideg + 1):
 1147:             v[i] = (v[i - 1] * x * (2 * i - 1) - v[i - 2] * (i - 1)) / i
 1148:     return np.moveaxis(v, 0, -1)
 1149: 
 1150: 
 1151: def legvander2d(x, y, deg):
 1152:     """Pseudo-Vandermonde matrix of given degrees.
 1153: 
 1154:     Returns the pseudo-Vandermonde matrix of degrees `deg` and sample
 1155:     points ``(x, y)``. The pseudo-Vandermonde matrix is defined by
 1156: 
 1157:     .. math:: V[..., (deg[1] + 1)*i + j] = L_i(x) * L_j(y),
 1158: 
 1159:     where ``0 <= i <= deg[0]`` and ``0 <= j <= deg[1]``. The leading indices of
 1160:     `V` index the points ``(x, y)`` and the last index encodes the degrees of
 1161:     the Legendre polynomials.
 1162: 
 1163:     If ``V = legvander2d(x, y, [xdeg, ydeg])``, then the columns of `V`
 1164:     correspond to the elements of a 2-D coefficient array `c` of shape
 1165:     (xdeg + 1, ydeg + 1) in the order
 1166: 
 1167:     .. math:: c_{00}, c_{01}, c_{02} ... , c_{10}, c_{11}, c_{12} ...
 1168: 
 1169:     and ``np.dot(V, c.flat)`` and ``legval2d(x, y, c)`` will be the same
 1170:     up to roundoff. This equivalence is useful both for least squares
 1171:     fitting and for the evaluation of a large number of 2-D Legendre
 1172:     series of the same degrees and sample points.
 1173: 
 1174:     Parameters
 1175:     ----------
 1176:     x, y : array_like
 1177:         Arrays of point coordinates, all of the same shape. The dtypes
 1178:         will be converted to either float64 or complex128 depending on
 1179:         whether any of the elements are complex. Scalars are converted to
 1180:         1-D arrays.
 1181:     deg : list of ints
 1182:         List of maximum degrees of the form [x_deg, y_deg].
 1183: 
 1184:     Returns
 1185:     -------
 1186:     vander2d : ndarray
 1187:         The shape of the returned matrix is ``x.shape + (order,)``, where
 1188:         :math:`order = (deg[0]+1)*(deg[1]+1)`.  The dtype will be the same
 1189:         as the converted `x` and `y`.
 1190: 
 1191:     See Also
 1192:     --------
 1193:     legvander, legvander3d, legval2d, legval3d
 1194:     """
 1195:     return pu._vander_nd_flat((legvander, legvander), (x, y), deg)
 1196: 
 1197: 
 1198: def legvander3d(x, y, z, deg):
 1199:     """Pseudo-Vandermonde matrix of given degrees.
 1200: 
 1201:     Returns the pseudo-Vandermonde matrix of degrees `deg` and sample
 1202:     points ``(x, y, z)``. If `l`, `m`, `n` are the given degrees in `x`, `y`, `z`,
 1203:     then The pseudo-Vandermonde matrix is defined by
 1204: 
 1205:     .. math:: V[..., (m+1)(n+1)i + (n+1)j + k] = L_i(x)*L_j(y)*L_k(z),
 1206: 
 1207:     where ``0 <= i <= l``, ``0 <= j <= m``, and ``0 <= j <= n``.  The leading
 1208:     indices of `V` index the points ``(x, y, z)`` and the last index encodes
 1209:     the degrees of the Legendre polynomials.
 1210: 
 1211:     If ``V = legvander3d(x, y, z, [xdeg, ydeg, zdeg])``, then the columns
 1212:     of `V` correspond to the elements of a 3-D coefficient array `c` of
 1213:     shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order
 1214: 
 1215:     .. math:: c_{000}, c_{001}, c_{002},... , c_{010}, c_{011}, c_{012},...
 1216: 
 1217:     and ``np.dot(V, c.flat)`` and ``legval3d(x, y, z, c)`` will be the
 1218:     same up to roundoff. This equivalence is useful both for least squares
 1219:     fitting and for the evaluation of a large number of 3-D Legendre
 1220:     series of the same degrees and sample points.
 1221: 
 1222:     Parameters
 1223:     ----------
 1224:     x, y, z : array_like
 1225:         Arrays of point coordinates, all of the same shape. The dtypes will
 1226:         be converted to either float64 or complex128 depending on whether
 1227:         any of the elements are complex. Scalars are converted to 1-D
 1228:         arrays.
 1229:     deg : list of ints
 1230:         List of maximum degrees of the form [x_deg, y_deg, z_deg].
 1231: 
 1232:     Returns
 1233:     -------
 1234:     vander3d : ndarray
 1235:         The shape of the returned matrix is ``x.shape + (order,)``, where
 1236:         :math:`order = (deg[0]+1)*(deg[1]+1)*(deg[2]+1)`.  The dtype will
 1237:         be the same as the converted `x`, `y`, and `z`.
 1238: 
 1239:     See Also
 1240:     --------
 1241:     legvander, legvander3d, legval2d, legval3d
 1242:     """
 1243:     return pu._vander_nd_flat((legvander, legvander, legvander), (x, y, z), deg)
 1244: 
 1245: 
 1246: def legfit(x, y, deg, rcond=None, full=False, w=None):
 1247:     """
 1248:     Least squares fit of Legendre series to data.
 1249: 
 1250:     Return the coefficients of a Legendre series of degree `deg` that is the
 1251:     least squares fit to the data values `y` given at points `x`. If `y` is
 1252:     1-D the returned coefficients will also be 1-D. If `y` is 2-D multiple
 1253:     fits are done, one for each column of `y`, and the resulting
 1254:     coefficients are stored in the corresponding columns of a 2-D return.
 1255:     The fitted polynomial(s) are in the form
 1256: 
 1257:     .. math::  p(x) = c_0 + c_1 * L_1(x) + ... + c_n * L_n(x),
 1258: 
 1259:     where `n` is `deg`.
 1260: 
 1261:     Parameters
 1262:     ----------
 1263:     x : array_like, shape (M,)
 1264:         x-coordinates of the M sample points ``(x[i], y[i])``.
 1265:     y : array_like, shape (M,) or (M, K)
 1266:         y-coordinates of the sample points. Several data sets of sample
 1267:         points sharing the same x-coordinates can be fitted at once by
 1268:         passing in a 2D-array that contains one dataset per column.
 1269:     deg : int or 1-D array_like
 1270:         Degree(s) of the fitting polynomials. If `deg` is a single integer
 1271:         all terms up to and including the `deg`'th term are included in the
 1272:         fit. For NumPy versions >= 1.11.0 a list of integers specifying the
 1273:         degrees of the terms to include may be used instead.
 1274:     rcond : float, optional
 1275:         Relative condition number of the fit. Singular values smaller than
 1276:         this relative to the largest singular value will be ignored. The
 1277:         default value is len(x)*eps, where eps is the relative precision of
 1278:         the float type, about 2e-16 in most cases.
 1279:     full : bool, optional
 1280:         Switch determining nature of return value. When it is False (the
 1281:         default) just the coefficients are returned, when True diagnostic
 1282:         information from the singular value decomposition is also returned.
 1283:     w : array_like, shape (`M`,), optional
 1284:         Weights. If not None, the weight ``w[i]`` applies to the unsquared
 1285:         residual ``y[i] - y_hat[i]`` at ``x[i]``. Ideally the weights are
 1286:         chosen so that the errors of the products ``w[i]*y[i]`` all have the
 1287:         same variance.  When using inverse-variance weighting, use
 1288:         ``w[i] = 1/sigma(y[i])``.  The default value is None.
 1289: 
 1290:     Returns
 1291:     -------
 1292:     coef : ndarray, shape (M,) or (M, K)
 1293:         Legendre coefficients ordered from low to high. If `y` was
 1294:         2-D, the coefficients for the data in column k of `y` are in
 1295:         column `k`. If `deg` is specified as a list, coefficients for
 1296:         terms not included in the fit are set equal to zero in the
 1297:         returned `coef`.
 1298: 
 1299:     [residuals, rank, singular_values, rcond] : list
 1300:         These values are only returned if ``full == True``
 1301: 
 1302:         - residuals -- sum of squared residuals of the least squares fit
 1303:         - rank -- the numerical rank of the scaled Vandermonde matrix
 1304:         - singular_values -- singular values of the scaled Vandermonde matrix
 1305:         - rcond -- value of `rcond`.
 1306: 
 1307:         For more details, see `numpy.linalg.lstsq`.
 1308: 
 1309:     Warns
 1310:     -----
 1311:     RankWarning
 1312:         The rank of the coefficient matrix in the least-squares fit is
 1313:         deficient. The warning is only raised if ``full == False``.  The
 1314:         warnings can be turned off by
 1315: 
 1316:         >>> import warnings
 1317:         >>> warnings.simplefilter('ignore', np.exceptions.RankWarning)
 1318: 
 1319:     See Also
 1320:     --------
 1321:     numpy.polynomial.polynomial.polyfit
 1322:     numpy.polynomial.chebyshev.chebfit
 1323:     numpy.polynomial.laguerre.lagfit
 1324:     numpy.polynomial.hermite.hermfit
 1325:     numpy.polynomial.hermite_e.hermefit
 1326:     legval : Evaluates a Legendre series.
 1327:     legvander : Vandermonde matrix of Legendre series.
 1328:     legweight : Legendre weight function (= 1).
 1329:     numpy.linalg.lstsq : Computes a least-squares fit from the matrix.
 1330:     scipy.interpolate.UnivariateSpline : Computes spline fits.
 1331: 
 1332:     Notes
 1333:     -----
 1334:     The solution is the coefficients of the Legendre series `p` that
 1335:     minimizes the sum of the weighted squared errors
 1336: 
 1337:     .. math:: E = \\sum_j w_j^2 * |y_j - p(x_j)|^2,
 1338: 
 1339:     where :math:`w_j` are the weights. This problem is solved by setting up
 1340:     as the (typically) overdetermined matrix equation
 1341: 
 1342:     .. math:: V(x) * c = w * y,
 1343: 
 1344:     where `V` is the weighted pseudo Vandermonde matrix of `x`, `c` are the
 1345:     coefficients to be solved for, `w` are the weights, and `y` are the
 1346:     observed values.  This equation is then solved using the singular value
 1347:     decomposition of `V`.
 1348: 
 1349:     If some of the singular values of `V` are so small that they are
 1350:     neglected, then a `~exceptions.RankWarning` will be issued. This means that
 1351:     the coefficient values may be poorly determined. Using a lower order fit
 1352:     will usually get rid of the warning.  The `rcond` parameter can also be
 1353:     set to a value smaller than its default, but the resulting fit may be
 1354:     spurious and have large contributions from roundoff error.
 1355: 
 1356:     Fits using Legendre series are usually better conditioned than fits
 1357:     using power series, but much can depend on the distribution of the
 1358:     sample points and the smoothness of the data. If the quality of the fit
 1359:     is inadequate splines may be a good alternative.
 1360: 
 1361:     References
 1362:     ----------
 1363:     .. [1] Wikipedia, "Curve fitting",
 1364:            https://en.wikipedia.org/wiki/Curve_fitting
 1365: 
 1366:     Examples
 1367:     --------
 1368: 
 1369:     """
 1370:     return pu._fit(legvander, x, y, deg, rcond, full, w)
 1371: 
 1372: 
 1373: def legcompanion(c):
 1374:     """Return the scaled companion matrix of c.
 1375: 
 1376:     The basis polynomials are scaled so that the companion matrix is
 1377:     symmetric when `c` is an Legendre basis polynomial. This provides
 1378:     better eigenvalue estimates than the unscaled case and for basis
 1379:     polynomials the eigenvalues are guaranteed to be real if
 1380:     `numpy.linalg.eigvalsh` is used to obtain them.
 1381: 
 1382:     Parameters
 1383:     ----------
 1384:     c : array_like
 1385:         1-D array of Legendre series coefficients ordered from low to high
 1386:         degree.
 1387: 
 1388:     Returns
 1389:     -------
 1390:     mat : ndarray
 1391:         Scaled companion matrix of dimensions (deg, deg).
 1392:     """
 1393:     # c is a trimmed copy
 1394:     [c] = pu.as_series([c])
 1395:     if len(c) < 2:
 1396:         raise ValueError('Series must have maximum degree of at least 1.')
 1397:     if len(c) == 2:
 1398:         return np.array([[-c[0] / c[1]]])
 1399: 
 1400:     n = len(c) - 1
 1401:     mat = np.zeros((n, n), dtype=c.dtype)
 1402:     scl = 1. / np.sqrt(2 * np.arange(n) + 1)
 1403:     top = mat.reshape(-1)[1::n + 1]
 1404:     bot = mat.reshape(-1)[n::n + 1]
 1405:     top[...] = np.arange(1, n) * scl[:n - 1] * scl[1:n]
 1406:     bot[...] = top
 1407:     mat[:, -1] -= (c[:-1] / c[-1]) * (scl / scl[-1]) * (n / (2 * n - 1))
 1408:     return mat
 1409: 
 1410: 
 1411: def legroots(c):
 1412:     """
 1413:     Compute the roots of a Legendre series.
 1414: 
 1415:     Return the roots (a.k.a. "zeros") of the polynomial
 1416: 
 1417:     .. math:: p(x) = \\sum_i c[i] * L_i(x).
 1418: 
 1419:     Parameters
 1420:     ----------
 1421:     c : 1-D array_like
 1422:         1-D array of coefficients.
 1423: 
 1424:     Returns
 1425:     -------
 1426:     out : ndarray
 1427:         Array of the roots of the series. If all the roots are real,
 1428:         then `out` is also real, otherwise it is complex.
 1429: 
 1430:     See Also
 1431:     --------
 1432:     numpy.polynomial.polynomial.polyroots
 1433:     numpy.polynomial.chebyshev.chebroots
 1434:     numpy.polynomial.laguerre.lagroots
 1435:     numpy.polynomial.hermite.hermroots
 1436:     numpy.polynomial.hermite_e.hermeroots
 1437: 
 1438:     Notes
 1439:     -----
 1440:     The root estimates are obtained as the eigenvalues of the companion
 1441:     matrix, Roots far from the origin of the complex plane may have large
 1442:     errors due to the numerical instability of the series for such values.
 1443:     Roots with multiplicity greater than 1 will also show larger errors as
 1444:     the value of the series near such points is relatively insensitive to
 1445:     errors in the roots. Isolated roots near the origin can be improved by
 1446:     a few iterations of Newton's method.
 1447: 
 1448:     The Legendre series basis polynomials aren't powers of ``x`` so the
 1449:     results of this function may seem unintuitive.
 1450: 
 1451:     Examples
 1452:     --------
 1453:     >>> import numpy.polynomial.legendre as leg
 1454:     >>> leg.legroots((1, 2, 3, 4)) # 4L_3 + 3L_2 + 2L_1 + 1L_0, all real roots
 1455:     array([-0.85099543, -0.11407192,  0.51506735]) # may vary
 1456: 
 1457:     """
 1458:     # c is a trimmed copy
 1459:     [c] = pu.as_series([c])
 1460:     if len(c) < 2:
 1461:         return np.array([], dtype=c.dtype)
 1462:     if len(c) == 2:
 1463:         return np.array([-c[0] / c[1]])
 1464: 
 1465:     # rotated companion matrix reduces error
 1466:     m = legcompanion(c)[::-1, ::-1]
 1467:     r = la.eigvals(m)
 1468:     r.sort()
 1469:     return r
 1470: 
 1471: 
 1472: def leggauss(deg):
 1473:     """
 1474:     Gauss-Legendre quadrature.
 1475: 
 1476:     Computes the sample points and weights for Gauss-Legendre quadrature.
 1477:     These sample points and weights will correctly integrate polynomials of
 1478:     degree :math:`2*deg - 1` or less over the interval :math:`[-1, 1]` with
 1479:     the weight function :math:`f(x) = 1`.
 1480: 
 1481:     Parameters
 1482:     ----------
 1483:     deg : int
 1484:         Number of sample points and weights. It must be >= 1.
 1485: 
 1486:     Returns
 1487:     -------
 1488:     x : ndarray
 1489:         1-D ndarray containing the sample points.
 1490:     y : ndarray
 1491:         1-D ndarray containing the weights.
 1492: 
 1493:     Notes
 1494:     -----
 1495:     The results have only been tested up to degree 100, higher degrees may
 1496:     be problematic. The weights are determined by using the fact that
 1497: 
 1498:     .. math:: w_k = c / (L'_n(x_k) * L_{n-1}(x_k))
 1499: 
 1500:     where :math:`c` is a constant independent of :math:`k` and :math:`x_k`
 1501:     is the k'th root of :math:`L_n`, and then scaling the results to get
 1502:     the right value when integrating 1.
 1503: 
 1504:     """
 1505:     ideg = pu._as_int(deg, "deg")
 1506:     if ideg <= 0:
 1507:         raise ValueError("deg must be a positive integer")
 1508: 
 1509:     # first approximation of roots. We use the fact that the companion
 1510:     # matrix is symmetric in this case in order to obtain better zeros.
 1511:     c = np.array([0] * deg + [1])
 1512:     m = legcompanion(c)
 1513:     x = la.eigvalsh(m)
 1514: 
 1515:     # improve roots by one application of Newton
 1516:     dy = legval(x, c)
 1517:     df = legval(x, legder(c))
 1518:     x -= dy / df
 1519: 
 1520:     # compute the weights. We scale the factor to avoid possible numerical
 1521:     # overflow.
 1522:     fm = legval(x, c[1:])
 1523:     fm /= np.abs(fm).max()
 1524:     df /= np.abs(df).max()
 1525:     w = 1 / (fm * df)
 1526: 
 1527:     # for Legendre we can also symmetrize
 1528:     w = (w + w[::-1]) / 2
 1529:     x = (x - x[::-1]) / 2
 1530: 
 1531:     # scale w to get the right value
 1532:     w *= 2. / w.sum()
 1533: 
 1534:     return x, w
 1535: 
 1536: 
 1537: def legweight(x):
 1538:     """
 1539:     Weight function of the Legendre polynomials.
 1540: 
 1541:     The weight function is :math:`1` and the interval of integration is
 1542:     :math:`[-1, 1]`. The Legendre polynomials are orthogonal, but not
 1543:     normalized, with respect to this weight function.
 1544: 
 1545:     Parameters
 1546:     ----------
 1547:     x : array_like
 1548:        Values at which the weight function will be computed.
 1549: 
 1550:     Returns
 1551:     -------
 1552:     w : ndarray
 1553:        The weight function at `x`.
 1554:     """
 1555:     w = x * 0.0 + 1.0
 1556:     return w
 1557: 
 1558: #
 1559: # Legendre series class
 1560: #
 1561: 
 1562: class Legendre(ABCPolyBase):
 1563:     """A Legendre series class.
 1564: 
 1565:     The Legendre class provides the standard Python numerical methods
 1566:     '+', '-', '*', '//', '%', 'divmod', '**', and '()' as well as the
 1567:     attributes and methods listed below.
 1568: 
 1569:     Parameters
 1570:     ----------
 1571:     coef : array_like
 1572:         Legendre coefficients in order of increasing degree, i.e.,
 1573:         ``(1, 2, 3)`` gives ``1*P_0(x) + 2*P_1(x) + 3*P_2(x)``.
 1574:     domain : (2,) array_like, optional
 1575:         Domain to use. The interval ``[domain[0], domain[1]]`` is mapped
 1576:         to the interval ``[window[0], window[1]]`` by shifting and scaling.
 1577:         The default value is [-1., 1.].
 1578:     window : (2,) array_like, optional
 1579:         Window, see `domain` for its use. The default value is [-1., 1.].
 1580:     symbol : str, optional
 1581:         Symbol used to represent the independent variable in string
 1582:         representations of the polynomial expression, e.g. for printing.
 1583:         The symbol must be a valid Python identifier. Default value is 'x'.
 1584: 
 1585:         .. versionadded:: 1.24
 1586: 
 1587:     """
 1588:     # Virtual Functions
 1589:     _add = staticmethod(legadd)
 1590:     _sub = staticmethod(legsub)
 1591:     _mul = staticmethod(legmul)
 1592:     _div = staticmethod(legdiv)
 1593:     _pow = staticmethod(legpow)
 1594:     _val = staticmethod(legval)
 1595:     _int = staticmethod(legint)
 1596:     _der = staticmethod(legder)
 1597:     _fit = staticmethod(legfit)
 1598:     _line = staticmethod(legline)
 1599:     _roots = staticmethod(legroots)
 1600:     _fromroots = staticmethod(legfromroots)
 1601: 
 1602:     # Virtual properties
 1603:     domain = np.array(legdomain)
 1604:     window = np.array(legdomain)
 1605:     basis_name = 'P'
