    1: """
    2: numpy.ma : a package to handle missing or invalid values.
    3: 
    4: This package was initially written for numarray by Paul F. Dubois
    5: at Lawrence Livermore National Laboratory.
    6: In 2006, the package was completely rewritten by Pierre Gerard-Marchant
    7: (University of Georgia) to make the MaskedArray class a subclass of ndarray,
    8: and to improve support of structured arrays.
    9: 
   10: 
   11: Copyright 1999, 2000, 2001 Regents of the University of California.
   12: Released for unlimited redistribution.
   13: 
   14: * Adapted for numpy_core 2005 by Travis Oliphant and (mainly) Paul Dubois.
   15: * Subclassing of the base `ndarray` 2006 by Pierre Gerard-Marchant
   16:   (pgmdevlist_AT_gmail_DOT_com)
   17: * Improvements suggested by Reggie Dugard (reggie_AT_merfinllc_DOT_com)
   18: 
   19: .. moduleauthor:: Pierre Gerard-Marchant
   20: 
   21: """
   22: import builtins
   23: import functools
   24: import inspect
   25: import operator
   26: import re
   27: import textwrap
   28: import warnings
   29: 
   30: import numpy as np
   31: import numpy._core.numerictypes as ntypes
   32: import numpy._core.umath as umath
   33: from numpy import (
   34:     _NoValue,
   35:     amax,
   36:     amin,
   37:     angle,
   38:     bool_,
   39:     expand_dims,
   40:     finfo,  # noqa: F401
   41:     iinfo,  # noqa: F401
   42:     iscomplexobj,
   43:     ndarray,
   44: )
   45: from numpy import array as narray  # noqa: F401
   46: from numpy._core import multiarray as mu
   47: from numpy._core.numeric import normalize_axis_tuple
   48: from numpy._utils import set_module
   49: from numpy._utils._inspect import formatargspec, getargspec
   50: 
   51: __all__ = [
   52:     'MAError', 'MaskError', 'MaskType', 'MaskedArray', 'abs', 'absolute',
   53:     'add', 'all', 'allclose', 'allequal', 'alltrue', 'amax', 'amin',
   54:     'angle', 'anom', 'anomalies', 'any', 'append', 'arange', 'arccos',
   55:     'arccosh', 'arcsin', 'arcsinh', 'arctan', 'arctan2', 'arctanh',
   56:     'argmax', 'argmin', 'argsort', 'around', 'array', 'asanyarray',
   57:     'asarray', 'bitwise_and', 'bitwise_or', 'bitwise_xor', 'bool_', 'ceil',
   58:     'choose', 'clip', 'common_fill_value', 'compress', 'compressed',
   59:     'concatenate', 'conjugate', 'convolve', 'copy', 'correlate', 'cos', 'cosh',
   60:     'count', 'cumprod', 'cumsum', 'default_fill_value', 'diag', 'diagonal',
   61:     'diff', 'divide', 'empty', 'empty_like', 'equal', 'exp',
   62:     'expand_dims', 'fabs', 'filled', 'fix_invalid', 'flatten_mask',
   63:     'flatten_structured_array', 'floor', 'floor_divide', 'fmod',
   64:     'frombuffer', 'fromflex', 'fromfunction', 'getdata', 'getmask',
   65:     'getmaskarray', 'greater', 'greater_equal', 'harden_mask', 'hypot',
   66:     'identity', 'ids', 'indices', 'inner', 'innerproduct', 'isMA',
   67:     'isMaskedArray', 'is_mask', 'is_masked', 'isarray', 'left_shift',
   68:     'less', 'less_equal', 'log', 'log10', 'log2',
   69:     'logical_and', 'logical_not', 'logical_or', 'logical_xor', 'make_mask',
   70:     'make_mask_descr', 'make_mask_none', 'mask_or', 'masked',
   71:     'masked_array', 'masked_equal', 'masked_greater',
   72:     'masked_greater_equal', 'masked_inside', 'masked_invalid',
   73:     'masked_less', 'masked_less_equal', 'masked_not_equal',
   74:     'masked_object', 'masked_outside', 'masked_print_option',
   75:     'masked_singleton', 'masked_values', 'masked_where', 'max', 'maximum',
   76:     'maximum_fill_value', 'mean', 'min', 'minimum', 'minimum_fill_value',
   77:     'mod', 'multiply', 'mvoid', 'ndim', 'negative', 'nomask', 'nonzero',
   78:     'not_equal', 'ones', 'ones_like', 'outer', 'outerproduct', 'power', 'prod',
   79:     'product', 'ptp', 'put', 'putmask', 'ravel', 'remainder',
   80:     'repeat', 'reshape', 'resize', 'right_shift', 'round', 'round_',
   81:     'set_fill_value', 'shape', 'sin', 'sinh', 'size', 'soften_mask',
   82:     'sometrue', 'sort', 'sqrt', 'squeeze', 'std', 'subtract', 'sum',
   83:     'swapaxes', 'take', 'tan', 'tanh', 'trace', 'transpose', 'true_divide',
   84:     'var', 'where', 'zeros', 'zeros_like',
   85:     ]
   86: 
   87: MaskType = np.bool
   88: nomask = MaskType(0)
   89: 
   90: class MaskedArrayFutureWarning(FutureWarning):
   91:     pass
   92: 
   93: def _deprecate_argsort_axis(arr):
   94:     """
   95:     Adjust the axis passed to argsort, warning if necessary
   96: 
   97:     Parameters
   98:     ----------
   99:     arr
  100:         The array which argsort was called on
  101: 
  102:     np.ma.argsort has a long-term bug where the default of the axis argument
  103:     is wrong (gh-8701), which now must be kept for backwards compatibility.
  104:     Thankfully, this only makes a difference when arrays are 2- or more-
  105:     dimensional, so we only need a warning then.
  106:     """
  107:     if arr.ndim <= 1:
  108:         # no warning needed - but switch to -1 anyway, to avoid surprising
  109:         # subclasses, which are more likely to implement scalar axes.
  110:         return -1
  111:     else:
  112:         # 2017-04-11, Numpy 1.13.0, gh-8701: warn on axis default
  113:         warnings.warn(
  114:             "In the future the default for argsort will be axis=-1, not the "
  115:             "current None, to match its documentation and np.argsort. "
  116:             "Explicitly pass -1 or None to silence this warning.",
  117:             MaskedArrayFutureWarning, stacklevel=3)
  118:         return None
  119: 
  120: 
  121: def doc_note(initialdoc, note):
  122:     """
  123:     Adds a Notes section to an existing docstring.
  124: 
  125:     """
  126:     if initialdoc is None:
  127:         return
  128:     if note is None:
  129:         return initialdoc
  130: 
  131:     notesplit = re.split(r'\n\s*?Notes\n\s*?-----', inspect.cleandoc(initialdoc))
  132:     notedoc = f"\n\nNotes\n-----\n{inspect.cleandoc(note)}\n"
  133: 
  134:     return ''.join(notesplit[:1] + [notedoc] + notesplit[1:])
  135: 
  136: 
  137: def get_object_signature(obj):
  138:     """
  139:     Get the signature from obj
  140: 
  141:     """
  142:     try:
  143:         sig = formatargspec(*getargspec(obj))
  144:     except TypeError:
  145:         sig = ''
  146:     return sig
  147: 
  148: 
  149: ###############################################################################
  150: #                              Exceptions                                     #
  151: ###############################################################################
  152: 
  153: 
  154: class MAError(Exception):
  155:     """
  156:     Class for masked array related errors.
  157: 
  158:     """
  159:     pass
  160: 
  161: 
  162: class MaskError(MAError):
  163:     """
  164:     Class for mask related errors.
  165: 
  166:     """
  167:     pass
  168: 
  169: 
  170: ###############################################################################
  171: #                           Filling options                                   #
  172: ###############################################################################
  173: 
  174: 
  175: # b: boolean - c: complex - f: floats - i: integer - O: object - S: string
  176: default_filler = {'b': True,
  177:                   'c': 1.e20 + 0.0j,
  178:                   'f': 1.e20,
  179:                   'i': 999999,
  180:                   'O': '?',
  181:                   'S': b'N/A',
  182:                   'u': 999999,
  183:                   'V': b'???',
  184:                   'U': 'N/A'
  185:                   }
  186: 
  187: # Add datetime64 and timedelta64 types
  188: for v in ["Y", "M", "W", "D", "h", "m", "s", "ms", "us", "ns", "ps",
  189:           "fs", "as"]:
  190:     default_filler["M8[" + v + "]"] = np.datetime64("NaT", v)
  191:     default_filler["m8[" + v + "]"] = np.timedelta64("NaT", v)
  192: 
  193: float_types_list = [np.half, np.single, np.double, np.longdouble,
  194:                     np.csingle, np.cdouble, np.clongdouble]
  195: 
  196: _minvals: dict[type, int] = {}
  197: _maxvals: dict[type, int] = {}
  198: 
  199: for sctype in ntypes.sctypeDict.values():
  200:     scalar_dtype = np.dtype(sctype)
  201: 
  202:     if scalar_dtype.kind in "Mm":
  203:         info = np.iinfo(np.int64)
  204:         min_val, max_val = info.min + 1, info.max
  205:     elif np.issubdtype(scalar_dtype, np.integer):
  206:         info = np.iinfo(sctype)
  207:         min_val, max_val = info.min, info.max
  208:     elif np.issubdtype(scalar_dtype, np.floating):
  209:         info = np.finfo(sctype)
  210:         min_val, max_val = info.min, info.max
  211:     elif scalar_dtype.kind == "b":
  212:         min_val, max_val = 0, 1
  213:     else:
  214:         min_val, max_val = None, None
  215: 
  216:     _minvals[sctype] = min_val
  217:     _maxvals[sctype] = max_val
  218: 
  219: max_filler = _minvals
  220: max_filler.update([(k, -np.inf) for k in float_types_list[:4]])
  221: max_filler.update([(k, complex(-np.inf, -np.inf)) for k in float_types_list[-3:]])
  222: 
  223: min_filler = _maxvals
  224: min_filler.update([(k, +np.inf) for k in float_types_list[:4]])
  225: min_filler.update([(k, complex(+np.inf, +np.inf)) for k in float_types_list[-3:]])
  226: 
  227: del float_types_list
  228: 
  229: def _recursive_fill_value(dtype, f):
  230:     """
  231:     Recursively produce a fill value for `dtype`, calling f on scalar dtypes
  232:     """
  233:     if dtype.names is not None:
  234:         # We wrap into `array` here, which ensures we use NumPy cast rules
  235:         # for integer casts, this allows the use of 99999 as a fill value
  236:         # for int8.
  237:         # TODO: This is probably a mess, but should best preserve behavior?
  238:         vals = tuple(
  239:                 np.array(_recursive_fill_value(dtype[name], f))
  240:                 for name in dtype.names)
  241:         return np.array(vals, dtype=dtype)[()]  # decay to void scalar from 0d
  242:     elif dtype.subdtype:
  243:         subtype, shape = dtype.subdtype
  244:         subval = _recursive_fill_value(subtype, f)
  245:         return np.full(shape, subval)
  246:     else:
  247:         return f(dtype)
  248: 
  249: 
  250: def _get_dtype_of(obj):
  251:     """ Convert the argument for *_fill_value into a dtype """
  252:     if isinstance(obj, np.dtype):
  253:         return obj
  254:     elif hasattr(obj, 'dtype'):
  255:         return obj.dtype
  256:     else:
  257:         return np.asanyarray(obj).dtype
  258: 
  259: 
  260: def default_fill_value(obj):
  261:     """
  262:     Return the default fill value for the argument object.
  263: 
  264:     The default filling value depends on the datatype of the input
  265:     array or the type of the input scalar:
  266: 
  267:        ========  ========
  268:        datatype  default
  269:        ========  ========
  270:        bool      True
  271:        int       999999
  272:        float     1.e20
  273:        complex   1.e20+0j
  274:        object    '?'
  275:        string    'N/A'
  276:        ========  ========
  277: 
  278:     For structured types, a structured scalar is returned, with each field the
  279:     default fill value for its type.
  280: 
  281:     For subarray types, the fill value is an array of the same size containing
  282:     the default scalar fill value.
  283: 
  284:     Parameters
  285:     ----------
  286:     obj : ndarray, dtype or scalar
  287:         The array data-type or scalar for which the default fill value
  288:         is returned.
  289: 
  290:     Returns
  291:     -------
  292:     fill_value : scalar
  293:         The default fill value.
  294: 
  295:     Examples
  296:     --------
  297:     >>> import numpy as np
  298:     >>> np.ma.default_fill_value(1)
  299:     999999
  300:     >>> np.ma.default_fill_value(np.array([1.1, 2., np.pi]))
  301:     1e+20
  302:     >>> np.ma.default_fill_value(np.dtype(complex))
  303:     (1e+20+0j)
  304: 
  305:     """
  306:     def _scalar_fill_value(dtype):
  307:         if dtype.kind in 'Mm':
  308:             return default_filler.get(dtype.str[1:], '?')
  309:         else:
  310:             return default_filler.get(dtype.kind, '?')
  311: 
  312:     dtype = _get_dtype_of(obj)
  313:     return _recursive_fill_value(dtype, _scalar_fill_value)
  314: 
  315: 
  316: def _extremum_fill_value(obj, extremum, extremum_name):
  317: 
  318:     def _scalar_fill_value(dtype):
  319:         try:
  320:             return extremum[dtype.type]
  321:         except KeyError as e:
  322:             raise TypeError(
  323:                 f"Unsuitable type {dtype} for calculating {extremum_name}."
  324:             ) from None
  325: 
  326:     dtype = _get_dtype_of(obj)
  327:     return _recursive_fill_value(dtype, _scalar_fill_value)
  328: 
  329: 
  330: def minimum_fill_value(obj):
  331:     """
  332:     Return the maximum value that can be represented by the dtype of an object.
  333: 
  334:     This function is useful for calculating a fill value suitable for
  335:     taking the minimum of an array with a given dtype.
  336: 
  337:     Parameters
  338:     ----------
  339:     obj : ndarray, dtype or scalar
  340:         An object that can be queried for it's numeric type.
  341: 
  342:     Returns
  343:     -------
  344:     val : scalar
  345:         The maximum representable value.
  346: 
  347:     Raises
  348:     ------
  349:     TypeError
  350:         If `obj` isn't a suitable numeric type.
  351: 
  352:     See Also
  353:     --------
  354:     maximum_fill_value : The inverse function.
  355:     set_fill_value : Set the filling value of a masked array.
  356:     MaskedArray.fill_value : Return current fill value.
  357: 
  358:     Examples
  359:     --------
  360:     >>> import numpy as np
  361:     >>> import numpy.ma as ma
  362:     >>> a = np.int8()
  363:     >>> ma.minimum_fill_value(a)
  364:     127
  365:     >>> a = np.int32()
  366:     >>> ma.minimum_fill_value(a)
  367:     2147483647
  368: 
  369:     An array of numeric data can also be passed.
  370: 
  371:     >>> a = np.array([1, 2, 3], dtype=np.int8)
  372:     >>> ma.minimum_fill_value(a)
  373:     127
  374:     >>> a = np.array([1, 2, 3], dtype=np.float32)
  375:     >>> ma.minimum_fill_value(a)
  376:     inf
  377: 
  378:     """
  379:     return _extremum_fill_value(obj, min_filler, "minimum")
  380: 
  381: 
  382: def maximum_fill_value(obj):
  383:     """
  384:     Return the minimum value that can be represented by the dtype of an object.
  385: 
  386:     This function is useful for calculating a fill value suitable for
  387:     taking the maximum of an array with a given dtype.
  388: 
  389:     Parameters
  390:     ----------
  391:     obj : ndarray, dtype or scalar
  392:         An object that can be queried for it's numeric type.
  393: 
  394:     Returns
  395:     -------
  396:     val : scalar
  397:         The minimum representable value.
  398: 
  399:     Raises
  400:     ------
  401:     TypeError
  402:         If `obj` isn't a suitable numeric type.
  403: 
  404:     See Also
  405:     --------
  406:     minimum_fill_value : The inverse function.
  407:     set_fill_value : Set the filling value of a masked array.
  408:     MaskedArray.fill_value : Return current fill value.
  409: 
  410:     Examples
  411:     --------
  412:     >>> import numpy as np
  413:     >>> import numpy.ma as ma
  414:     >>> a = np.int8()
  415:     >>> ma.maximum_fill_value(a)
  416:     -128
  417:     >>> a = np.int32()
  418:     >>> ma.maximum_fill_value(a)
  419:     -2147483648
  420: 
  421:     An array of numeric data can also be passed.
  422: 
  423:     >>> a = np.array([1, 2, 3], dtype=np.int8)
  424:     >>> ma.maximum_fill_value(a)
  425:     -128
  426:     >>> a = np.array([1, 2, 3], dtype=np.float32)
  427:     >>> ma.maximum_fill_value(a)
  428:     -inf
  429: 
  430:     """
  431:     return _extremum_fill_value(obj, max_filler, "maximum")
  432: 
  433: 
  434: def _recursive_set_fill_value(fillvalue, dt):
  435:     """
  436:     Create a fill value for a structured dtype.
  437: 
  438:     Parameters
  439:     ----------
  440:     fillvalue : scalar or array_like
  441:         Scalar or array representing the fill value. If it is of shorter
  442:         length than the number of fields in dt, it will be resized.
  443:     dt : dtype
  444:         The structured dtype for which to create the fill value.
  445: 
  446:     Returns
  447:     -------
  448:     val : tuple
  449:         A tuple of values corresponding to the structured fill value.
  450: 
  451:     """
  452:     fillvalue = np.resize(fillvalue, len(dt.names))
  453:     output_value = []
  454:     for (fval, name) in zip(fillvalue, dt.names):
  455:         cdtype = dt[name]
  456:         if cdtype.subdtype:
  457:             cdtype = cdtype.subdtype[0]
  458: 
  459:         if cdtype.names is not None:
  460:             output_value.append(tuple(_recursive_set_fill_value(fval, cdtype)))
  461:         else:
  462:             output_value.append(np.array(fval, dtype=cdtype).item())
  463:     return tuple(output_value)
  464: 
  465: 
  466: def _check_fill_value(fill_value, ndtype):
  467:     """
  468:     Private function validating the given `fill_value` for the given dtype.
  469: 
  470:     If fill_value is None, it is set to the default corresponding to the dtype.
  471: 
  472:     If fill_value is not None, its value is forced to the given dtype.
  473: 
  474:     The result is always a 0d array.
  475: 
  476:     """
  477:     ndtype = np.dtype(ndtype)
  478:     if fill_value is None:
  479:         fill_value = default_fill_value(ndtype)
  480:         # TODO: It seems better to always store a valid fill_value, the oddity
  481:         #       about is that `_fill_value = None` would behave even more
  482:         #       different then.
  483:         #       (e.g. this allows arr_uint8.astype(int64) to have the default
  484:         #       fill value again...)
  485:         # The one thing that changed in 2.0/2.1 around cast safety is that the
  486:         # default `int(99...)` is not a same-kind cast anymore, so if we
  487:         # have a uint, use the default uint.
  488:         if ndtype.kind == "u":
  489:             fill_value = np.uint(fill_value)
  490:     elif ndtype.names is not None:
  491:         if isinstance(fill_value, (ndarray, np.void)):
  492:             try:
  493:                 fill_value = np.asarray(fill_value, dtype=ndtype)
  494:             except ValueError as e:
  495:                 err_msg = "Unable to transform %s to dtype %s"
  496:                 raise ValueError(err_msg % (fill_value, ndtype)) from e
  497:         else:
  498:             fill_value = np.asarray(fill_value, dtype=object)
  499:             fill_value = np.array(_recursive_set_fill_value(fill_value, ndtype),
  500:                                   dtype=ndtype)
  501:     elif isinstance(fill_value, str) and (ndtype.char not in 'OSVU'):
  502:         # Note this check doesn't work if fill_value is not a scalar
  503:         err_msg = "Cannot set fill value of string with array of dtype %s"
  504:         raise TypeError(err_msg % ndtype)
  505:     else:
  506:         # In case we want to convert 1e20 to int.
  507:         # Also in case of converting string arrays.
  508:         try:
  509:             fill_value = np.asarray(fill_value, dtype=ndtype)
  510:         except (OverflowError, ValueError) as e:
  511:             # Raise TypeError instead of OverflowError or ValueError.
  512:             # OverflowError is seldom used, and the real problem here is
  513:             # that the passed fill_value is not compatible with the ndtype.
  514:             err_msg = "Cannot convert fill_value %s to dtype %s"
  515:             raise TypeError(err_msg % (fill_value, ndtype)) from e
  516:     return np.array(fill_value)
  517: 
  518: 
  519: def set_fill_value(a, fill_value):
  520:     """
  521:     Set the filling value of a, if a is a masked array.
  522: 
  523:     This function changes the fill value of the masked array `a` in place.
  524:     If `a` is not a masked array, the function returns silently, without
  525:     doing anything.
  526: 
  527:     Parameters
  528:     ----------
  529:     a : array_like
  530:         Input array.
  531:     fill_value : dtype
  532:         Filling value. A consistency test is performed to make sure
  533:         the value is compatible with the dtype of `a`.
  534: 
  535:     Returns
  536:     -------
  537:     None
  538:         Nothing returned by this function.
  539: 
  540:     See Also
  541:     --------
  542:     maximum_fill_value : Return the default fill value for a dtype.
  543:     MaskedArray.fill_value : Return current fill value.
  544:     MaskedArray.set_fill_value : Equivalent method.
  545: 
  546:     Examples
  547:     --------
  548:     >>> import numpy as np
  549:     >>> import numpy.ma as ma
  550:     >>> a = np.arange(5)
  551:     >>> a
  552:     array([0, 1, 2, 3, 4])
  553:     >>> a = ma.masked_where(a < 3, a)
  554:     >>> a
  555:     masked_array(data=[--, --, --, 3, 4],
  556:                  mask=[ True,  True,  True, False, False],
  557:            fill_value=999999)
  558:     >>> ma.set_fill_value(a, -999)
  559:     >>> a
  560:     masked_array(data=[--, --, --, 3, 4],
  561:                  mask=[ True,  True,  True, False, False],
  562:            fill_value=-999)
  563: 
  564:     Nothing happens if `a` is not a masked array.
  565: 
  566:     >>> a = list(range(5))
  567:     >>> a
  568:     [0, 1, 2, 3, 4]
  569:     >>> ma.set_fill_value(a, 100)
  570:     >>> a
  571:     [0, 1, 2, 3, 4]
  572:     >>> a = np.arange(5)
  573:     >>> a
  574:     array([0, 1, 2, 3, 4])
  575:     >>> ma.set_fill_value(a, 100)
  576:     >>> a
  577:     array([0, 1, 2, 3, 4])
  578: 
  579:     """
  580:     if isinstance(a, MaskedArray):
  581:         a.set_fill_value(fill_value)
  582: 
  583: 
  584: def get_fill_value(a):
  585:     """
  586:     Return the filling value of a, if any.  Otherwise, returns the
  587:     default filling value for that type.
  588: 
  589:     """
  590:     if isinstance(a, MaskedArray):
  591:         result = a.fill_value
  592:     else:
  593:         result = default_fill_value(a)
  594:     return result
  595: 
  596: 
  597: def common_fill_value(a, b):
  598:     """
  599:     Return the common filling value of two masked arrays, if any.
  600: 
  601:     If ``a.fill_value == b.fill_value``, return the fill value,
  602:     otherwise return None.
  603: 
  604:     Parameters
  605:     ----------
  606:     a, b : MaskedArray
  607:         The masked arrays for which to compare fill values.
  608: 
  609:     Returns
  610:     -------
  611:     fill_value : scalar or None
  612:         The common fill value, or None.
  613: 
  614:     Examples
  615:     --------
  616:     >>> import numpy as np
  617:     >>> x = np.ma.array([0, 1.], fill_value=3)
  618:     >>> y = np.ma.array([0, 1.], fill_value=3)
  619:     >>> np.ma.common_fill_value(x, y)
  620:     3.0
  621: 
  622:     """
  623:     t1 = get_fill_value(a)
  624:     t2 = get_fill_value(b)
  625:     if t1 == t2:
  626:         return t1
  627:     return None
  628: 
  629: 
  630: def filled(a, fill_value=None):
  631:     """
  632:     Return input as an `~numpy.ndarray`, with masked values replaced by
  633:     `fill_value`.
  634: 
  635:     If `a` is not a `MaskedArray`, `a` itself is returned.
  636:     If `a` is a `MaskedArray` with no masked values, then ``a.data`` is
  637:     returned.
  638:     If `a` is a `MaskedArray` and `fill_value` is None, `fill_value` is set to
  639:     ``a.fill_value``.
  640: 
  641:     Parameters
  642:     ----------
  643:     a : MaskedArray or array_like
  644:         An input object.
  645:     fill_value : array_like, optional.
  646:         Can be scalar or non-scalar. If non-scalar, the
  647:         resulting filled array should be broadcastable
  648:         over input array. Default is None.
  649: 
  650:     Returns
  651:     -------
  652:     a : ndarray
  653:         The filled array.
  654: 
  655:     See Also
  656:     --------
  657:     compressed
  658: 
  659:     Examples
  660:     --------
  661:     >>> import numpy as np
  662:     >>> import numpy.ma as ma
  663:     >>> x = ma.array(np.arange(9).reshape(3, 3), mask=[[1, 0, 0],
  664:     ...                                                [1, 0, 0],
  665:     ...                                                [0, 0, 0]])
  666:     >>> x.filled()
  667:     array([[999999,      1,      2],
  668:            [999999,      4,      5],
  669:            [     6,      7,      8]])
  670:     >>> x.filled(fill_value=333)
  671:     array([[333,   1,   2],
  672:            [333,   4,   5],
  673:            [  6,   7,   8]])
  674:     >>> x.filled(fill_value=np.arange(3))
  675:     array([[0, 1, 2],
  676:            [0, 4, 5],
  677:            [6, 7, 8]])
  678: 
  679:     """
  680:     if hasattr(a, 'filled'):
  681:         return a.filled(fill_value)
  682: 
  683:     elif isinstance(a, ndarray):
  684:         # Should we check for contiguity ? and a.flags['CONTIGUOUS']:
  685:         return a
  686:     elif isinstance(a, dict):
  687:         return np.array(a, 'O')
  688:     else:
  689:         return np.array(a)
  690: 
  691: 
  692: def get_masked_subclass(*arrays):
  693:     """
  694:     Return the youngest subclass of MaskedArray from a list of (masked) arrays.
  695: 
  696:     In case of siblings, the first listed takes over.
  697: 
  698:     """
  699:     if len(arrays) == 1:
  700:         arr = arrays[0]
  701:         if isinstance(arr, MaskedArray):
  702:             rcls = type(arr)
  703:         else:
  704:             rcls = MaskedArray
  705:     else:
  706:         arrcls = [type(a) for a in arrays]
  707:         rcls = arrcls[0]
  708:         if not issubclass(rcls, MaskedArray):
  709:             rcls = MaskedArray
  710:         for cls in arrcls[1:]:
  711:             if issubclass(cls, rcls):
  712:                 rcls = cls
  713:     # Don't return MaskedConstant as result: revert to MaskedArray
  714:     if rcls.__name__ == 'MaskedConstant':
  715:         return MaskedArray
  716:     return rcls
  717: 
  718: 
  719: def getdata(a, subok=True):
  720:     """
  721:     Return the data of a masked array as an ndarray.
  722: 
  723:     Return the data of `a` (if any) as an ndarray if `a` is a ``MaskedArray``,
  724:     else return `a` as a ndarray or subclass (depending on `subok`) if not.
  725: 
  726:     Parameters
  727:     ----------
  728:     a : array_like
  729:         Input ``MaskedArray``, alternatively a ndarray or a subclass thereof.
  730:     subok : bool
  731:         Whether to force the output to be a `pure` ndarray (False) or to
  732:         return a subclass of ndarray if appropriate (True, default).
  733: 
  734:     See Also
  735:     --------
  736:     getmask : Return the mask of a masked array, or nomask.
  737:     getmaskarray : Return the mask of a masked array, or full array of False.
  738: 
  739:     Examples
  740:     --------
  741:     >>> import numpy as np
  742:     >>> import numpy.ma as ma
  743:     >>> a = ma.masked_equal([[1,2],[3,4]], 2)
  744:     >>> a
  745:     masked_array(
  746:       data=[[1, --],
  747:             [3, 4]],
  748:       mask=[[False,  True],
  749:             [False, False]],
  750:       fill_value=2)
  751:     >>> ma.getdata(a)
  752:     array([[1, 2],
  753:            [3, 4]])
  754: 
  755:     Equivalently use the ``MaskedArray`` `data` attribute.
  756: 
  757:     >>> a.data
  758:     array([[1, 2],
  759:            [3, 4]])
  760: 
  761:     """
  762:     try:
  763:         data = a._data
  764:     except AttributeError:
  765:         data = np.array(a, copy=None, subok=subok)
  766:     if not subok:
  767:         return data.view(ndarray)
  768:     return data
  769: 
  770: 
  771: get_data = getdata
  772: 
  773: 
  774: def fix_invalid(a, mask=nomask, copy=True, fill_value=None):
  775:     """
  776:     Return input with invalid data masked and replaced by a fill value.
  777: 
  778:     Invalid data means values of `nan`, `inf`, etc.
  779: 
  780:     Parameters
  781:     ----------
  782:     a : array_like
  783:         Input array, a (subclass of) ndarray.
  784:     mask : sequence, optional
  785:         Mask. Must be convertible to an array of booleans with the same
  786:         shape as `data`. True indicates a masked (i.e. invalid) data.
  787:     copy : bool, optional
  788:         Whether to use a copy of `a` (True) or to fix `a` in place (False).
  789:         Default is True.
  790:     fill_value : scalar, optional
  791:         Value used for fixing invalid data. Default is None, in which case
  792:         the ``a.fill_value`` is used.
  793: 
  794:     Returns
  795:     -------
  796:     b : MaskedArray
  797:         The input array with invalid entries fixed.
  798: 
  799:     Notes
  800:     -----
  801:     A copy is performed by default.
  802: 
  803:     Examples
  804:     --------
  805:     >>> import numpy as np
  806:     >>> x = np.ma.array([1., -1, np.nan, np.inf], mask=[1] + [0]*3)
  807:     >>> x
  808:     masked_array(data=[--, -1.0, nan, inf],
  809:                  mask=[ True, False, False, False],
  810:            fill_value=1e+20)
  811:     >>> np.ma.fix_invalid(x)
  812:     masked_array(data=[--, -1.0, --, --],
  813:                  mask=[ True, False,  True,  True],
  814:            fill_value=1e+20)
  815: 
  816:     >>> fixed = np.ma.fix_invalid(x)
  817:     >>> fixed.data
  818:     array([ 1.e+00, -1.e+00,  1.e+20,  1.e+20])
  819:     >>> x.data
  820:     array([ 1., -1., nan, inf])
  821: 
  822:     """
  823:     a = masked_array(a, copy=copy, mask=mask, subok=True)
  824:     invalid = np.logical_not(np.isfinite(a._data))
  825:     if not invalid.any():
  826:         return a
  827:     a._mask |= invalid
  828:     if fill_value is None:
  829:         fill_value = a.fill_value
  830:     a._data[invalid] = fill_value
  831:     return a
  832: 
  833: def is_string_or_list_of_strings(val):
  834:     return (isinstance(val, str) or
  835:             (isinstance(val, list) and val and
  836:              builtins.all(isinstance(s, str) for s in val)))
  837: 
  838: ###############################################################################
  839: #                                  Ufuncs                                     #
  840: ###############################################################################
  841: 
  842: 
  843: ufunc_domain = {}
  844: ufunc_fills = {}
  845: 
  846: 
  847: class _DomainCheckInterval:
  848:     """
  849:     Define a valid interval, so that :
  850: 
  851:     ``domain_check_interval(a,b)(x) == True`` where
  852:     ``x < a`` or ``x > b``.
  853: 
  854:     """
  855: 
  856:     def __init__(self, a, b):
  857:         "domain_check_interval(a,b)(x) = true where x < a or y > b"
  858:         if a > b:
  859:             (a, b) = (b, a)
  860:         self.a = a
  861:         self.b = b
  862: 
  863:     def __call__(self, x):
  864:         "Execute the call behavior."
  865:         # nans at masked positions cause RuntimeWarnings, even though
  866:         # they are masked. To avoid this we suppress warnings.
  867:         with np.errstate(invalid='ignore'):
  868:             return umath.logical_or(umath.greater(x, self.b),
  869:                                     umath.less(x, self.a))
  870: 
  871: 
  872: class _DomainTan:
  873:     """
  874:     Define a valid interval for the `tan` function, so that:
  875: 
  876:     ``domain_tan(eps) = True`` where ``abs(cos(x)) < eps``
  877: 
  878:     """
  879: 
  880:     def __init__(self, eps):
  881:         "domain_tan(eps) = true where abs(cos(x)) < eps)"
  882:         self.eps = eps
  883: 
  884:     def __call__(self, x):
  885:         "Executes the call behavior."
  886:         with np.errstate(invalid='ignore'):
  887:             return umath.less(umath.absolute(umath.cos(x)), self.eps)
  888: 
  889: 
  890: class _DomainSafeDivide:
  891:     """
  892:     Define a domain for safe division.
  893: 
  894:     """
  895: 
  896:     def __init__(self, tolerance=None):
  897:         self.tolerance = tolerance
  898: 
  899:     def __call__(self, a, b):
  900:         # Delay the selection of the tolerance to here in order to reduce numpy
  901:         # import times. The calculation of these parameters is a substantial
  902:         # component of numpy's import time.
  903:         if self.tolerance is None:
  904:             self.tolerance = np.finfo(float).tiny
  905:         # don't call ma ufuncs from __array_wrap__ which would fail for scalars
  906:         a, b = np.asarray(a), np.asarray(b)
  907:         with np.errstate(all='ignore'):
  908:             return umath.absolute(a) * self.tolerance >= umath.absolute(b)
  909: 
  910: 
  911: class _DomainGreater:
  912:     """
  913:     DomainGreater(v)(x) is True where x <= v.
  914: 
  915:     """
  916: 
  917:     def __init__(self, critical_value):
  918:         "DomainGreater(v)(x) = true where x <= v"
  919:         self.critical_value = critical_value
  920: 
  921:     def __call__(self, x):
  922:         "Executes the call behavior."
  923:         with np.errstate(invalid='ignore'):
  924:             return umath.less_equal(x, self.critical_value)
  925: 
  926: 
  927: class _DomainGreaterEqual:
  928:     """
  929:     DomainGreaterEqual(v)(x) is True where x < v.
  930: 
  931:     """
  932: 
  933:     def __init__(self, critical_value):
  934:         "DomainGreaterEqual(v)(x) = true where x < v"
  935:         self.critical_value = critical_value
  936: 
  937:     def __call__(self, x):
  938:         "Executes the call behavior."
  939:         with np.errstate(invalid='ignore'):
  940:             return umath.less(x, self.critical_value)
  941: 
  942: 
  943: class _MaskedUFunc:
  944:     def __init__(self, ufunc):
  945:         self.f = ufunc
  946:         self.__doc__ = ufunc.__doc__
  947:         self.__name__ = ufunc.__name__
  948:         self.__qualname__ = ufunc.__qualname__
  949: 
  950:     def __str__(self):
  951:         return f"Masked version of {self.f}"
  952: 
  953: 
  954: class _MaskedUnaryOperation(_MaskedUFunc):
  955:     """
  956:     Defines masked version of unary operations, where invalid values are
  957:     pre-masked.
  958: 
  959:     Parameters
  960:     ----------
  961:     mufunc : callable
  962:         The function for which to define a masked version. Made available
  963:         as ``_MaskedUnaryOperation.f``.
  964:     fill : scalar, optional
  965:         Filling value, default is 0.
  966:     domain : class instance
  967:         Domain for the function. Should be one of the ``_Domain*``
  968:         classes. Default is None.
  969: 
  970:     """
  971: 
  972:     def __init__(self, mufunc, fill=0, domain=None):
  973:         super().__init__(mufunc)
  974:         self.fill = fill
  975:         self.domain = domain
  976:         ufunc_domain[mufunc] = domain
  977:         ufunc_fills[mufunc] = fill
  978: 
  979:     def __call__(self, a, *args, **kwargs):
  980:         """
  981:         Execute the call behavior.
  982: 
  983:         """
  984:         d = getdata(a)
  985:         # Deal with domain
  986:         if self.domain is not None:
  987:             # Case 1.1. : Domained function
  988:             # nans at masked positions cause RuntimeWarnings, even though
  989:             # they are masked. To avoid this we suppress warnings.
  990:             with np.errstate(divide='ignore', invalid='ignore'):
  991:                 result = self.f(d, *args, **kwargs)
  992:             # Make a mask
  993:             m = ~umath.isfinite(result)
  994:             m |= self.domain(d)
  995:             m |= getmask(a)
  996:         else:
  997:             # Case 1.2. : Function without a domain
  998:             # Get the result and the mask
  999:             with np.errstate(divide='ignore', invalid='ignore'):
 1000:                 result = self.f(d, *args, **kwargs)
 1001:             m = getmask(a)
 1002: 
 1003:         if not result.ndim:
 1004:             # Case 2.1. : The result is scalarscalar
 1005:             if m:
 1006:                 return masked
 1007:             return result
 1008: 
 1009:         if m is not nomask:
 1010:             # Case 2.2. The result is an array
 1011:             # We need to fill the invalid data back w/ the input Now,
 1012:             # that's plain silly: in C, we would just skip the element and
 1013:             # keep the original, but we do have to do it that way in Python
 1014: 
 1015:             # In case result has a lower dtype than the inputs (as in
 1016:             # equal)
 1017:             try:
 1018:                 np.copyto(result, d, where=m)
 1019:             except TypeError:
 1020:                 pass
 1021:         # Transform to
 1022:         masked_result = result.view(get_masked_subclass(a))
 1023:         masked_result._mask = m
 1024:         masked_result._update_from(a)
 1025:         return masked_result
 1026: 
 1027: 
 1028: class _MaskedBinaryOperation(_MaskedUFunc):
 1029:     """
 1030:     Define masked version of binary operations, where invalid
 1031:     values are pre-masked.
 1032: 
 1033:     Parameters
 1034:     ----------
 1035:     mbfunc : function
 1036:         The function for which to define a masked version. Made available
 1037:         as ``_MaskedBinaryOperation.f``.
 1038:     domain : class instance
 1039:         Default domain for the function. Should be one of the ``_Domain*``
 1040:         classes. Default is None.
 1041:     fillx : scalar, optional
 1042:         Filling value for the first argument, default is 0.
 1043:     filly : scalar, optional
 1044:         Filling value for the second argument, default is 0.
 1045: 
 1046:     """
 1047: 
 1048:     def __init__(self, mbfunc, fillx=0, filly=0):
 1049:         """
 1050:         abfunc(fillx, filly) must be defined.
 1051: 
 1052:         abfunc(x, filly) = x for all x to enable reduce.
 1053: 
 1054:         """
 1055:         super().__init__(mbfunc)
 1056:         self.fillx = fillx
 1057:         self.filly = filly
 1058:         ufunc_domain[mbfunc] = None
 1059:         ufunc_fills[mbfunc] = (fillx, filly)
 1060: 
 1061:     def __call__(self, a, b, *args, **kwargs):
 1062:         """
 1063:         Execute the call behavior.
 1064: 
 1065:         """
 1066:         # Get the data, as ndarray
 1067:         (da, db) = (getdata(a), getdata(b))
 1068:         # Get the result
 1069:         with np.errstate():
 1070:             np.seterr(divide='ignore', invalid='ignore')
 1071:             result = self.f(da, db, *args, **kwargs)
 1072:         # Get the mask for the result
 1073:         (ma, mb) = (getmask(a), getmask(b))
 1074:         if ma is nomask:
 1075:             if mb is nomask:
 1076:                 m = nomask
 1077:             else:
 1078:                 m = umath.logical_or(getmaskarray(a), mb)
 1079:         elif mb is nomask:
 1080:             m = umath.logical_or(ma, getmaskarray(b))
 1081:         else:
 1082:             m = umath.logical_or(ma, mb)
 1083: 
 1084:         # Case 1. : scalar
 1085:         if not result.ndim:
 1086:             if m:
 1087:                 return masked
 1088:             return result
 1089: 
 1090:         # Case 2. : array
 1091:         # Revert result to da where masked
 1092:         if m is not nomask and m.any():
 1093:             # any errors, just abort; impossible to guarantee masked values
 1094:             try:
 1095:                 np.copyto(result, da, casting='unsafe', where=m)
 1096:             except Exception:
 1097:                 pass
 1098: 
 1099:         # Transforms to a (subclass of) MaskedArray
 1100:         masked_result = result.view(get_masked_subclass(a, b))
 1101:         masked_result._mask = m
 1102:         if isinstance(a, MaskedArray):
 1103:             masked_result._update_from(a)
 1104:         elif isinstance(b, MaskedArray):
 1105:             masked_result._update_from(b)
 1106:         return masked_result
 1107: 
 1108:     def reduce(self, target, axis=0, dtype=None):
 1109:         """
 1110:         Reduce `target` along the given `axis`.
 1111: 
 1112:         """
 1113:         tclass = get_masked_subclass(target)
 1114:         m = getmask(target)
 1115:         t = filled(target, self.filly)
 1116:         if t.shape == ():
 1117:             t = t.reshape(1)
 1118:             if m is not nomask:
 1119:                 m = make_mask(m, copy=True)
 1120:                 m.shape = (1,)
 1121: 
 1122:         if m is nomask:
 1123:             tr = self.f.reduce(t, axis)
 1124:             mr = nomask
 1125:         else:
 1126:             tr = self.f.reduce(t, axis, dtype=dtype)
 1127:             mr = umath.logical_and.reduce(m, axis)
 1128: 
 1129:         if not tr.shape:
 1130:             if mr:
 1131:                 return masked
 1132:             else:
 1133:                 return tr
 1134:         masked_tr = tr.view(tclass)
 1135:         masked_tr._mask = mr
 1136:         return masked_tr
 1137: 
 1138:     def outer(self, a, b):
 1139:         """
 1140:         Return the function applied to the outer product of a and b.
 1141: 
 1142:         """
 1143:         (da, db) = (getdata(a), getdata(b))
 1144:         d = self.f.outer(da, db)
 1145:         ma = getmask(a)
 1146:         mb = getmask(b)
 1147:         if ma is nomask and mb is nomask:
 1148:             m = nomask
 1149:         else:
 1150:             ma = getmaskarray(a)
 1151:             mb = getmaskarray(b)
 1152:             m = umath.logical_or.outer(ma, mb)
 1153:         if (not m.ndim) and m:
 1154:             return masked
 1155:         if m is not nomask:
 1156:             np.copyto(d, da, where=m)
 1157:         if not d.shape:
 1158:             return d
 1159:         masked_d = d.view(get_masked_subclass(a, b))
 1160:         masked_d._mask = m
 1161:         return masked_d
 1162: 
 1163:     def accumulate(self, target, axis=0):
 1164:         """Accumulate `target` along `axis` after filling with y fill
 1165:         value.
 1166: 
 1167:         """
 1168:         tclass = get_masked_subclass(target)
 1169:         t = filled(target, self.filly)
 1170:         result = self.f.accumulate(t, axis)
 1171:         masked_result = result.view(tclass)
 1172:         return masked_result
 1173: 
 1174: 
 1175: class _DomainedBinaryOperation(_MaskedUFunc):
 1176:     """
 1177:     Define binary operations that have a domain, like divide.
 1178: 
 1179:     They have no reduce, outer or accumulate.
 1180: 
 1181:     Parameters
 1182:     ----------
 1183:     mbfunc : function
 1184:         The function for which to define a masked version. Made available
 1185:         as ``_DomainedBinaryOperation.f``.
 1186:     domain : class instance
 1187:         Default domain for the function. Should be one of the ``_Domain*``
 1188:         classes.
 1189:     fillx : scalar, optional
 1190:         Filling value for the first argument, default is 0.
 1191:     filly : scalar, optional
 1192:         Filling value for the second argument, default is 0.
 1193: 
 1194:     """
 1195: 
 1196:     def __init__(self, dbfunc, domain, fillx=0, filly=0):
 1197:         """abfunc(fillx, filly) must be defined.
 1198:            abfunc(x, filly) = x for all x to enable reduce.
 1199:         """
 1200:         super().__init__(dbfunc)
 1201:         self.domain = domain
 1202:         self.fillx = fillx
 1203:         self.filly = filly
 1204:         ufunc_domain[dbfunc] = domain
 1205:         ufunc_fills[dbfunc] = (fillx, filly)
 1206: 
 1207:     def __call__(self, a, b, *args, **kwargs):
 1208:         "Execute the call behavior."
 1209:         # Get the data
 1210:         (da, db) = (getdata(a), getdata(b))
 1211:         # Get the result
 1212:         with np.errstate(divide='ignore', invalid='ignore'):
 1213:             result = self.f(da, db, *args, **kwargs)
 1214:         # Get the mask as a combination of the source masks and invalid
 1215:         m = ~umath.isfinite(result)
 1216:         m |= getmask(a)
 1217:         m |= getmask(b)
 1218:         # Apply the domain
 1219:         domain = ufunc_domain.get(self.f, None)
 1220:         if domain is not None:
 1221:             m |= domain(da, db)
 1222:         # Take care of the scalar case first
 1223:         if not m.ndim:
 1224:             if m:
 1225:                 return masked
 1226:             else:
 1227:                 return result
 1228:         # When the mask is True, put back da if possible
 1229:         # any errors, just abort; impossible to guarantee masked values
 1230:         try:
 1231:             np.copyto(result, 0, casting='unsafe', where=m)
 1232:             # avoid using "*" since this may be overlaid
 1233:             masked_da = umath.multiply(m, da)
 1234:             # only add back if it can be cast safely
 1235:             if np.can_cast(masked_da.dtype, result.dtype, casting='safe'):
 1236:                 result += masked_da
 1237:         except Exception:
 1238:             pass
 1239: 
 1240:         # Transforms to a (subclass of) MaskedArray
 1241:         masked_result = result.view(get_masked_subclass(a, b))
 1242:         masked_result._mask = m
 1243:         if isinstance(a, MaskedArray):
 1244:             masked_result._update_from(a)
 1245:         elif isinstance(b, MaskedArray):
 1246:             masked_result._update_from(b)
 1247:         return masked_result
 1248: 
 1249: 
 1250: # Unary ufuncs
 1251: exp = _MaskedUnaryOperation(umath.exp)
 1252: conjugate = _MaskedUnaryOperation(umath.conjugate)
 1253: sin = _MaskedUnaryOperation(umath.sin)
 1254: cos = _MaskedUnaryOperation(umath.cos)
 1255: arctan = _MaskedUnaryOperation(umath.arctan)
 1256: arcsinh = _MaskedUnaryOperation(umath.arcsinh)
 1257: sinh = _MaskedUnaryOperation(umath.sinh)
 1258: cosh = _MaskedUnaryOperation(umath.cosh)
 1259: tanh = _MaskedUnaryOperation(umath.tanh)
 1260: abs = absolute = _MaskedUnaryOperation(umath.absolute)
 1261: angle = _MaskedUnaryOperation(angle)
 1262: fabs = _MaskedUnaryOperation(umath.fabs)
 1263: negative = _MaskedUnaryOperation(umath.negative)
 1264: floor = _MaskedUnaryOperation(umath.floor)
 1265: ceil = _MaskedUnaryOperation(umath.ceil)
 1266: around = _MaskedUnaryOperation(np.around)
 1267: logical_not = _MaskedUnaryOperation(umath.logical_not)
 1268: 
 1269: # Domained unary ufuncs
 1270: sqrt = _MaskedUnaryOperation(umath.sqrt, 0.0,
 1271:                              _DomainGreaterEqual(0.0))
 1272: log = _MaskedUnaryOperation(umath.log, 1.0,
 1273:                             _DomainGreater(0.0))
 1274: log2 = _MaskedUnaryOperation(umath.log2, 1.0,
 1275:                              _DomainGreater(0.0))
 1276: log10 = _MaskedUnaryOperation(umath.log10, 1.0,
 1277:                               _DomainGreater(0.0))
 1278: tan = _MaskedUnaryOperation(umath.tan, 0.0,
 1279:                             _DomainTan(1e-35))
 1280: arcsin = _MaskedUnaryOperation(umath.arcsin, 0.0,
 1281:                                _DomainCheckInterval(-1.0, 1.0))
 1282: arccos = _MaskedUnaryOperation(umath.arccos, 0.0,
 1283:                                _DomainCheckInterval(-1.0, 1.0))
 1284: arccosh = _MaskedUnaryOperation(umath.arccosh, 1.0,
 1285:                                 _DomainGreaterEqual(1.0))
 1286: arctanh = _MaskedUnaryOperation(umath.arctanh, 0.0,
 1287:                                 _DomainCheckInterval(-1.0 + 1e-15, 1.0 - 1e-15))
 1288: 
 1289: # Binary ufuncs
 1290: add = _MaskedBinaryOperation(umath.add)
 1291: subtract = _MaskedBinaryOperation(umath.subtract)
 1292: multiply = _MaskedBinaryOperation(umath.multiply, 1, 1)
 1293: arctan2 = _MaskedBinaryOperation(umath.arctan2, 0.0, 1.0)
 1294: equal = _MaskedBinaryOperation(umath.equal)
 1295: equal.reduce = None
 1296: not_equal = _MaskedBinaryOperation(umath.not_equal)
 1297: not_equal.reduce = None
 1298: less_equal = _MaskedBinaryOperation(umath.less_equal)
 1299: less_equal.reduce = None
 1300: greater_equal = _MaskedBinaryOperation(umath.greater_equal)
 1301: greater_equal.reduce = None
 1302: less = _MaskedBinaryOperation(umath.less)
 1303: less.reduce = None
 1304: greater = _MaskedBinaryOperation(umath.greater)
 1305: greater.reduce = None
 1306: logical_and = _MaskedBinaryOperation(umath.logical_and)
 1307: alltrue = _MaskedBinaryOperation(umath.logical_and, 1, 1).reduce
 1308: logical_or = _MaskedBinaryOperation(umath.logical_or)
 1309: sometrue = logical_or.reduce
 1310: logical_xor = _MaskedBinaryOperation(umath.logical_xor)
 1311: bitwise_and = _MaskedBinaryOperation(umath.bitwise_and)
 1312: bitwise_or = _MaskedBinaryOperation(umath.bitwise_or)
 1313: bitwise_xor = _MaskedBinaryOperation(umath.bitwise_xor)
 1314: hypot = _MaskedBinaryOperation(umath.hypot)
 1315: 
 1316: # Domained binary ufuncs
 1317: divide = _DomainedBinaryOperation(umath.divide, _DomainSafeDivide(), 0, 1)
 1318: true_divide = divide  # Just an alias for divide.
 1319: floor_divide = _DomainedBinaryOperation(umath.floor_divide,
 1320:                                         _DomainSafeDivide(), 0, 1)
 1321: remainder = _DomainedBinaryOperation(umath.remainder,
 1322:                                      _DomainSafeDivide(), 0, 1)
 1323: fmod = _DomainedBinaryOperation(umath.fmod, _DomainSafeDivide(), 0, 1)
 1324: mod = remainder
 1325: 
 1326: ###############################################################################
 1327: #                        Mask creation functions                              #
 1328: ###############################################################################
 1329: 
 1330: 
 1331: def _replace_dtype_fields_recursive(dtype, primitive_dtype):
 1332:     "Private function allowing recursion in _replace_dtype_fields."
 1333:     _recurse = _replace_dtype_fields_recursive
 1334: 
 1335:     # Do we have some name fields ?
 1336:     if dtype.names is not None:
 1337:         descr = []
 1338:         for name in dtype.names:
 1339:             field = dtype.fields[name]
 1340:             if len(field) == 3:
 1341:                 # Prepend the title to the name
 1342:                 name = (field[-1], name)
 1343:             descr.append((name, _recurse(field[0], primitive_dtype)))
 1344:         new_dtype = np.dtype(descr)
 1345: 
 1346:     # Is this some kind of composite a la (float,2)
 1347:     elif dtype.subdtype:
 1348:         descr = list(dtype.subdtype)
 1349:         descr[0] = _recurse(dtype.subdtype[0], primitive_dtype)
 1350:         new_dtype = np.dtype(tuple(descr))
 1351: 
 1352:     # this is a primitive type, so do a direct replacement
 1353:     else:
 1354:         new_dtype = primitive_dtype
 1355: 
 1356:     # preserve identity of dtypes
 1357:     if new_dtype == dtype:
 1358:         new_dtype = dtype
 1359: 
 1360:     return new_dtype
 1361: 
 1362: 
 1363: def _replace_dtype_fields(dtype, primitive_dtype):
 1364:     """
 1365:     Construct a dtype description list from a given dtype.
 1366: 
 1367:     Returns a new dtype object, with all fields and subtypes in the given type
 1368:     recursively replaced with `primitive_dtype`.
 1369: 
 1370:     Arguments are coerced to dtypes first.
 1371:     """
 1372:     dtype = np.dtype(dtype)
 1373:     primitive_dtype = np.dtype(primitive_dtype)
 1374:     return _replace_dtype_fields_recursive(dtype, primitive_dtype)
 1375: 
 1376: 
 1377: def make_mask_descr(ndtype):
 1378:     """
 1379:     Construct a dtype description list from a given dtype.
 1380: 
 1381:     Returns a new dtype object, with the type of all fields in `ndtype` to a
 1382:     boolean type. Field names are not altered.
 1383: 
 1384:     Parameters
 1385:     ----------
 1386:     ndtype : dtype
 1387:         The dtype to convert.
 1388: 
 1389:     Returns
 1390:     -------
 1391:     result : dtype
 1392:         A dtype that looks like `ndtype`, the type of all fields is boolean.
 1393: 
 1394:     Examples
 1395:     --------
 1396:     >>> import numpy as np
 1397:     >>> import numpy.ma as ma
 1398:     >>> dtype = np.dtype({'names':['foo', 'bar'],
 1399:     ...                   'formats':[np.float32, np.int64]})
 1400:     >>> dtype
 1401:     dtype([('foo', '<f4'), ('bar', '<i8')])
 1402:     >>> ma.make_mask_descr(dtype)
 1403:     dtype([('foo', '|b1'), ('bar', '|b1')])
 1404:     >>> ma.make_mask_descr(np.float32)
 1405:     dtype('bool')
 1406: 
 1407:     """
 1408:     return _replace_dtype_fields(ndtype, MaskType)
 1409: 
 1410: 
 1411: def getmask(a):
 1412:     """
 1413:     Return the mask of a masked array, or nomask.
 1414: 
 1415:     Return the mask of `a` as an ndarray if `a` is a `MaskedArray` and the
 1416:     mask is not `nomask`, else return `nomask`. To guarantee a full array
 1417:     of booleans of the same shape as a, use `getmaskarray`.
 1418: 
 1419:     Parameters
 1420:     ----------
 1421:     a : array_like
 1422:         Input `MaskedArray` for which the mask is required.
 1423: 
 1424:     See Also
 1425:     --------
 1426:     getdata : Return the data of a masked array as an ndarray.
 1427:     getmaskarray : Return the mask of a masked array, or full array of False.
 1428: 
 1429:     Examples
 1430:     --------
 1431:     >>> import numpy as np
 1432:     >>> import numpy.ma as ma
 1433:     >>> a = ma.masked_equal([[1,2],[3,4]], 2)
 1434:     >>> a
 1435:     masked_array(
 1436:       data=[[1, --],
 1437:             [3, 4]],
 1438:       mask=[[False,  True],
 1439:             [False, False]],
 1440:       fill_value=2)
 1441:     >>> ma.getmask(a)
 1442:     array([[False,  True],
 1443:            [False, False]])
 1444: 
 1445:     Equivalently use the `MaskedArray` `mask` attribute.
 1446: 
 1447:     >>> a.mask
 1448:     array([[False,  True],
 1449:            [False, False]])
 1450: 
 1451:     Result when mask == `nomask`
 1452: 
 1453:     >>> b = ma.masked_array([[1,2],[3,4]])
 1454:     >>> b
 1455:     masked_array(
 1456:       data=[[1, 2],
 1457:             [3, 4]],
 1458:       mask=False,
 1459:       fill_value=999999)
 1460:     >>> ma.nomask
 1461:     False
 1462:     >>> ma.getmask(b) == ma.nomask
 1463:     True
 1464:     >>> b.mask == ma.nomask
 1465:     True
 1466: 
 1467:     """
 1468:     return getattr(a, '_mask', nomask)
 1469: 
 1470: 
 1471: get_mask = getmask
 1472: 
 1473: 
 1474: def getmaskarray(arr):
 1475:     """
 1476:     Return the mask of a masked array, or full boolean array of False.
 1477: 
 1478:     Return the mask of `arr` as an ndarray if `arr` is a `MaskedArray` and
 1479:     the mask is not `nomask`, else return a full boolean array of False of
 1480:     the same shape as `arr`.
 1481: 
 1482:     Parameters
 1483:     ----------
 1484:     arr : array_like
 1485:         Input `MaskedArray` for which the mask is required.
 1486: 
 1487:     See Also
 1488:     --------
 1489:     getmask : Return the mask of a masked array, or nomask.
 1490:     getdata : Return the data of a masked array as an ndarray.
 1491: 
 1492:     Examples
 1493:     --------
 1494:     >>> import numpy as np
 1495:     >>> import numpy.ma as ma
 1496:     >>> a = ma.masked_equal([[1,2],[3,4]], 2)
 1497:     >>> a
 1498:     masked_array(
 1499:       data=[[1, --],
 1500:             [3, 4]],
 1501:       mask=[[False,  True],
 1502:             [False, False]],
 1503:       fill_value=2)
 1504:     >>> ma.getmaskarray(a)
 1505:     array([[False,  True],
 1506:            [False, False]])
 1507: 
 1508:     Result when mask == ``nomask``
 1509: 
 1510:     >>> b = ma.masked_array([[1,2],[3,4]])
 1511:     >>> b
 1512:     masked_array(
 1513:       data=[[1, 2],
 1514:             [3, 4]],
 1515:       mask=False,
 1516:       fill_value=999999)
 1517:     >>> ma.getmaskarray(b)
 1518:     array([[False, False],
 1519:            [False, False]])
 1520: 
 1521:     """
 1522:     mask = getmask(arr)
 1523:     if mask is nomask:
 1524:         mask = make_mask_none(np.shape(arr), getattr(arr, 'dtype', None))
 1525:     return mask
 1526: 
 1527: 
 1528: def is_mask(m):
 1529:     """
 1530:     Return True if m is a valid, standard mask.
 1531: 
 1532:     This function does not check the contents of the input, only that the
 1533:     type is MaskType. In particular, this function returns False if the
 1534:     mask has a flexible dtype.
 1535: 
 1536:     Parameters
 1537:     ----------
 1538:     m : array_like
 1539:         Array to test.
 1540: 
 1541:     Returns
 1542:     -------
 1543:     result : bool
 1544:         True if `m.dtype.type` is MaskType, False otherwise.
 1545: 
 1546:     See Also
 1547:     --------
 1548:     ma.isMaskedArray : Test whether input is an instance of MaskedArray.
 1549: 
 1550:     Examples
 1551:     --------
 1552:     >>> import numpy as np
 1553:     >>> import numpy.ma as ma
 1554:     >>> m = ma.masked_equal([0, 1, 0, 2, 3], 0)
 1555:     >>> m
 1556:     masked_array(data=[--, 1, --, 2, 3],
 1557:                  mask=[ True, False,  True, False, False],
 1558:            fill_value=0)
 1559:     >>> ma.is_mask(m)
 1560:     False
 1561:     >>> ma.is_mask(m.mask)
 1562:     True
 1563: 
 1564:     Input must be an ndarray (or have similar attributes)
 1565:     for it to be considered a valid mask.
 1566: 
 1567:     >>> m = [False, True, False]
 1568:     >>> ma.is_mask(m)
 1569:     False
 1570:     >>> m = np.array([False, True, False])
 1571:     >>> m
 1572:     array([False,  True, False])
 1573:     >>> ma.is_mask(m)
 1574:     True
 1575: 
 1576:     Arrays with complex dtypes don't return True.
 1577: 
 1578:     >>> dtype = np.dtype({'names':['monty', 'pithon'],
 1579:     ...                   'formats':[bool, bool]})
 1580:     >>> dtype
 1581:     dtype([('monty', '|b1'), ('pithon', '|b1')])
 1582:     >>> m = np.array([(True, False), (False, True), (True, False)],
 1583:     ...              dtype=dtype)
 1584:     >>> m
 1585:     array([( True, False), (False,  True), ( True, False)],
 1586:           dtype=[('monty', '?'), ('pithon', '?')])
 1587:     >>> ma.is_mask(m)
 1588:     False
 1589: 
 1590:     """
 1591:     try:
 1592:         return m.dtype.type is MaskType
 1593:     except AttributeError:
 1594:         return False
 1595: 
 1596: 
 1597: def _shrink_mask(m):
 1598:     """
 1599:     Shrink a mask to nomask if possible
 1600:     """
 1601:     if m.dtype.names is None and not m.any():
 1602:         return nomask
 1603:     else:
 1604:         return m
 1605: 
 1606: 
 1607: def make_mask(m, copy=False, shrink=True, dtype=MaskType):
 1608:     """
 1609:     Create a boolean mask from an array.
 1610: 
 1611:     Return `m` as a boolean mask, creating a copy if necessary or requested.
 1612:     The function can accept any sequence that is convertible to integers,
 1613:     or ``nomask``.  Does not require that contents must be 0s and 1s, values
 1614:     of 0 are interpreted as False, everything else as True.
 1615: 
 1616:     Parameters
 1617:     ----------
 1618:     m : array_like
 1619:         Potential mask.
 1620:     copy : bool, optional
 1621:         Whether to return a copy of `m` (True) or `m` itself (False).
 1622:     shrink : bool, optional
 1623:         Whether to shrink `m` to ``nomask`` if all its values are False.
 1624:     dtype : dtype, optional
 1625:         Data-type of the output mask. By default, the output mask has a
 1626:         dtype of MaskType (bool). If the dtype is flexible, each field has
 1627:         a boolean dtype. This is ignored when `m` is ``nomask``, in which
 1628:         case ``nomask`` is always returned.
 1629: 
 1630:     Returns
 1631:     -------
 1632:     result : ndarray
 1633:         A boolean mask derived from `m`.
 1634: 
 1635:     Examples
 1636:     --------
 1637:     >>> import numpy as np
 1638:     >>> import numpy.ma as ma
 1639:     >>> m = [True, False, True, True]
 1640:     >>> ma.make_mask(m)
 1641:     array([ True, False,  True,  True])
 1642:     >>> m = [1, 0, 1, 1]
 1643:     >>> ma.make_mask(m)
 1644:     array([ True, False,  True,  True])
 1645:     >>> m = [1, 0, 2, -3]
 1646:     >>> ma.make_mask(m)
 1647:     array([ True, False,  True,  True])
 1648: 
 1649:     Effect of the `shrink` parameter.
 1650: 
 1651:     >>> m = np.zeros(4)
 1652:     >>> m
 1653:     array([0., 0., 0., 0.])
 1654:     >>> ma.make_mask(m)
 1655:     False
 1656:     >>> ma.make_mask(m, shrink=False)
 1657:     array([False, False, False, False])
 1658: 
 1659:     Using a flexible `dtype`.
 1660: 
 1661:     >>> m = [1, 0, 1, 1]
 1662:     >>> n = [0, 1, 0, 0]
 1663:     >>> arr = []
 1664:     >>> for man, mouse in zip(m, n):
 1665:     ...     arr.append((man, mouse))
 1666:     >>> arr
 1667:     [(1, 0), (0, 1), (1, 0), (1, 0)]
 1668:     >>> dtype = np.dtype({'names':['man', 'mouse'],
 1669:     ...                   'formats':[np.int64, np.int64]})
 1670:     >>> arr = np.array(arr, dtype=dtype)
 1671:     >>> arr
 1672:     array([(1, 0), (0, 1), (1, 0), (1, 0)],
 1673:           dtype=[('man', '<i8'), ('mouse', '<i8')])
 1674:     >>> ma.make_mask(arr, dtype=dtype)
 1675:     array([(True, False), (False, True), (True, False), (True, False)],
 1676:           dtype=[('man', '|b1'), ('mouse', '|b1')])
 1677: 
 1678:     """
 1679:     if m is nomask:
 1680:         return nomask
 1681: 
 1682:     # Make sure the input dtype is valid.
 1683:     dtype = make_mask_descr(dtype)
 1684: 
 1685:     # legacy boolean special case: "existence of fields implies true"
 1686:     if isinstance(m, ndarray) and m.dtype.fields and dtype == np.bool:
 1687:         return np.ones(m.shape, dtype=dtype)
 1688: 
 1689:     # Fill the mask in case there are missing data; turn it into an ndarray.
 1690:     copy = None if not copy else True
 1691:     result = np.array(filled(m, True), copy=copy, dtype=dtype, subok=True)
 1692:     # Bas les masques !
 1693:     if shrink:
 1694:         result = _shrink_mask(result)
 1695:     return result
 1696: 
 1697: 
 1698: def make_mask_none(newshape, dtype=None):
 1699:     """
 1700:     Return a boolean mask of the given shape, filled with False.
 1701: 
 1702:     This function returns a boolean ndarray with all entries False, that can
 1703:     be used in common mask manipulations. If a complex dtype is specified, the
 1704:     type of each field is converted to a boolean type.
 1705: 
 1706:     Parameters
 1707:     ----------
 1708:     newshape : tuple
 1709:         A tuple indicating the shape of the mask.
 1710:     dtype : {None, dtype}, optional
 1711:         If None, use a MaskType instance. Otherwise, use a new datatype with
 1712:         the same fields as `dtype`, converted to boolean types.
 1713: 
 1714:     Returns
 1715:     -------
 1716:     result : ndarray
 1717:         An ndarray of appropriate shape and dtype, filled with False.
 1718: 
 1719:     See Also
 1720:     --------
 1721:     make_mask : Create a boolean mask from an array.
 1722:     make_mask_descr : Construct a dtype description list from a given dtype.
 1723: 
 1724:     Examples
 1725:     --------
 1726:     >>> import numpy as np
 1727:     >>> import numpy.ma as ma
 1728:     >>> ma.make_mask_none((3,))
 1729:     array([False, False, False])
 1730: 
 1731:     Defining a more complex dtype.
 1732: 
 1733:     >>> dtype = np.dtype({'names':['foo', 'bar'],
 1734:     ...                   'formats':[np.float32, np.int64]})
 1735:     >>> dtype
 1736:     dtype([('foo', '<f4'), ('bar', '<i8')])
 1737:     >>> ma.make_mask_none((3,), dtype=dtype)
 1738:     array([(False, False), (False, False), (False, False)],
 1739:           dtype=[('foo', '|b1'), ('bar', '|b1')])
 1740: 
 1741:     """
 1742:     if dtype is None:
 1743:         result = np.zeros(newshape, dtype=MaskType)
 1744:     else:
 1745:         result = np.zeros(newshape, dtype=make_mask_descr(dtype))
 1746:     return result
 1747: 
 1748: 
 1749: def _recursive_mask_or(m1, m2, newmask):
 1750:     names = m1.dtype.names
 1751:     for name in names:
 1752:         current1 = m1[name]
 1753:         if current1.dtype.names is not None:
 1754:             _recursive_mask_or(current1, m2[name], newmask[name])
 1755:         else:
 1756:             umath.logical_or(current1, m2[name], newmask[name])
 1757: 
 1758: 
 1759: def mask_or(m1, m2, copy=False, shrink=True):
 1760:     """
 1761:     Combine two masks with the ``logical_or`` operator.
 1762: 
 1763:     The result may be a view on `m1` or `m2` if the other is `nomask`
 1764:     (i.e. False).
 1765: 
 1766:     Parameters
 1767:     ----------
 1768:     m1, m2 : array_like
 1769:         Input masks.
 1770:     copy : bool, optional
 1771:         If copy is False and one of the inputs is `nomask`, return a view
 1772:         of the other input mask. Defaults to False.
 1773:     shrink : bool, optional
 1774:         Whether to shrink the output to `nomask` if all its values are
 1775:         False. Defaults to True.
 1776: 
 1777:     Returns
 1778:     -------
 1779:     mask : output mask
 1780:         The result masks values that are masked in either `m1` or `m2`.
 1781: 
 1782:     Raises
 1783:     ------
 1784:     ValueError
 1785:         If `m1` and `m2` have different flexible dtypes.
 1786: 
 1787:     Examples
 1788:     --------
 1789:     >>> import numpy as np
 1790:     >>> m1 = np.ma.make_mask([0, 1, 1, 0])
 1791:     >>> m2 = np.ma.make_mask([1, 0, 0, 0])
 1792:     >>> np.ma.mask_or(m1, m2)
 1793:     array([ True,  True,  True, False])
 1794: 
 1795:     """
 1796: 
 1797:     if (m1 is nomask) or (m1 is False):
 1798:         dtype = getattr(m2, 'dtype', MaskType)
 1799:         return make_mask(m2, copy=copy, shrink=shrink, dtype=dtype)
 1800:     if (m2 is nomask) or (m2 is False):
 1801:         dtype = getattr(m1, 'dtype', MaskType)
 1802:         return make_mask(m1, copy=copy, shrink=shrink, dtype=dtype)
 1803:     if m1 is m2 and is_mask(m1):
 1804:         return _shrink_mask(m1) if shrink else m1
 1805:     (dtype1, dtype2) = (getattr(m1, 'dtype', None), getattr(m2, 'dtype', None))
 1806:     if dtype1 != dtype2:
 1807:         raise ValueError(f"Incompatible dtypes '{dtype1}'<>'{dtype2}'")
 1808:     if dtype1.names is not None:
 1809:         # Allocate an output mask array with the properly broadcast shape.
 1810:         newmask = np.empty(np.broadcast(m1, m2).shape, dtype1)
 1811:         _recursive_mask_or(m1, m2, newmask)
 1812:         return newmask
 1813:     return make_mask(umath.logical_or(m1, m2), copy=copy, shrink=shrink)
 1814: 
 1815: 
 1816: def flatten_mask(mask):
 1817:     """
 1818:     Returns a completely flattened version of the mask, where nested fields
 1819:     are collapsed.
 1820: 
 1821:     Parameters
 1822:     ----------
 1823:     mask : array_like
 1824:         Input array, which will be interpreted as booleans.
 1825: 
 1826:     Returns
 1827:     -------
 1828:     flattened_mask : ndarray of bools
 1829:         The flattened input.
 1830: 
 1831:     Examples
 1832:     --------
 1833:     >>> import numpy as np
 1834:     >>> mask = np.array([0, 0, 1])
 1835:     >>> np.ma.flatten_mask(mask)
 1836:     array([False, False,  True])
 1837: 
 1838:     >>> mask = np.array([(0, 0), (0, 1)], dtype=[('a', bool), ('b', bool)])
 1839:     >>> np.ma.flatten_mask(mask)
 1840:     array([False, False, False,  True])
 1841: 
 1842:     >>> mdtype = [('a', bool), ('b', [('ba', bool), ('bb', bool)])]
 1843:     >>> mask = np.array([(0, (0, 0)), (0, (0, 1))], dtype=mdtype)
 1844:     >>> np.ma.flatten_mask(mask)
 1845:     array([False, False, False, False, False,  True])
 1846: 
 1847:     """
 1848: 
 1849:     def _flatmask(mask):
 1850:         "Flatten the mask and returns a (maybe nested) sequence of booleans."
 1851:         mnames = mask.dtype.names
 1852:         if mnames is not None:
 1853:             return [flatten_mask(mask[name]) for name in mnames]
 1854:         else:
 1855:             return mask
 1856: 
 1857:     def _flatsequence(sequence):
 1858:         "Generates a flattened version of the sequence."
 1859:         try:
 1860:             for element in sequence:
 1861:                 if hasattr(element, '__iter__'):
 1862:                     yield from _flatsequence(element)
 1863:                 else:
 1864:                     yield element
 1865:         except TypeError:
 1866:             yield sequence
 1867: 
 1868:     mask = np.asarray(mask)
 1869:     flattened = _flatsequence(_flatmask(mask))
 1870:     return np.array(list(flattened), dtype=bool)
 1871: 
 1872: 
 1873: def _check_mask_axis(mask, axis, keepdims=np._NoValue):
 1874:     "Check whether there are masked values along the given axis"
 1875:     kwargs = {} if keepdims is np._NoValue else {'keepdims': keepdims}
 1876:     if mask is not nomask:
 1877:         return mask.all(axis=axis, **kwargs)
 1878:     return nomask
 1879: 
 1880: 
 1881: ###############################################################################
 1882: #                             Masking functions                               #
 1883: ###############################################################################
 1884: 
 1885: def masked_where(condition, a, copy=True):
 1886:     """
 1887:     Mask an array where a condition is met.
 1888: 
 1889:     Return `a` as an array masked where `condition` is True.
 1890:     Any masked values of `a` or `condition` are also masked in the output.
 1891: 
 1892:     Parameters
 1893:     ----------
 1894:     condition : array_like
 1895:         Masking condition.  When `condition` tests floating point values for
 1896:         equality, consider using ``masked_values`` instead.
 1897:     a : array_like
 1898:         Array to mask.
 1899:     copy : bool
 1900:         If True (default) make a copy of `a` in the result.  If False modify
 1901:         `a` in place and return a view.
 1902: 
 1903:     Returns
 1904:     -------
 1905:     result : MaskedArray
 1906:         The result of masking `a` where `condition` is True.
 1907: 
 1908:     See Also
 1909:     --------
 1910:     masked_values : Mask using floating point equality.
 1911:     masked_equal : Mask where equal to a given value.
 1912:     masked_not_equal : Mask where *not* equal to a given value.
 1913:     masked_less_equal : Mask where less than or equal to a given value.
 1914:     masked_greater_equal : Mask where greater than or equal to a given value.
 1915:     masked_less : Mask where less than a given value.
 1916:     masked_greater : Mask where greater than a given value.
 1917:     masked_inside : Mask inside a given interval.
 1918:     masked_outside : Mask outside a given interval.
 1919:     masked_invalid : Mask invalid values (NaNs or infs).
 1920: 
 1921:     Examples
 1922:     --------
 1923:     >>> import numpy as np
 1924:     >>> import numpy.ma as ma
 1925:     >>> a = np.arange(4)
 1926:     >>> a
 1927:     array([0, 1, 2, 3])
 1928:     >>> ma.masked_where(a <= 2, a)
 1929:     masked_array(data=[--, --, --, 3],
 1930:                  mask=[ True,  True,  True, False],
 1931:            fill_value=999999)
 1932: 
 1933:     Mask array `b` conditional on `a`.
 1934: 
 1935:     >>> b = ['a', 'b', 'c', 'd']
 1936:     >>> ma.masked_where(a == 2, b)
 1937:     masked_array(data=['a', 'b', --, 'd'],
 1938:                  mask=[False, False,  True, False],
 1939:            fill_value='N/A',
 1940:                 dtype='<U1')
 1941: 
 1942:     Effect of the `copy` argument.
 1943: 
 1944:     >>> c = ma.masked_where(a <= 2, a)
 1945:     >>> c
 1946:     masked_array(data=[--, --, --, 3],
 1947:                  mask=[ True,  True,  True, False],
 1948:            fill_value=999999)
 1949:     >>> c[0] = 99
 1950:     >>> c
 1951:     masked_array(data=[99, --, --, 3],
 1952:                  mask=[False,  True,  True, False],
 1953:            fill_value=999999)
 1954:     >>> a
 1955:     array([0, 1, 2, 3])
 1956:     >>> c = ma.masked_where(a <= 2, a, copy=False)
 1957:     >>> c[0] = 99
 1958:     >>> c
 1959:     masked_array(data=[99, --, --, 3],
 1960:                  mask=[False,  True,  True, False],
 1961:            fill_value=999999)
 1962:     >>> a
 1963:     array([99,  1,  2,  3])
 1964: 
 1965:     When `condition` or `a` contain masked values.
 1966: 
 1967:     >>> a = np.arange(4)
 1968:     >>> a = ma.masked_where(a == 2, a)
 1969:     >>> a
 1970:     masked_array(data=[0, 1, --, 3],
 1971:                  mask=[False, False,  True, False],
 1972:            fill_value=999999)
 1973:     >>> b = np.arange(4)
 1974:     >>> b = ma.masked_where(b == 0, b)
 1975:     >>> b
 1976:     masked_array(data=[--, 1, 2, 3],
 1977:                  mask=[ True, False, False, False],
 1978:            fill_value=999999)
 1979:     >>> ma.masked_where(a == 3, b)
 1980:     masked_array(data=[--, 1, --, --],
 1981:                  mask=[ True, False,  True,  True],
 1982:            fill_value=999999)
 1983: 
 1984:     """
 1985:     # Make sure that condition is a valid standard-type mask.
 1986:     cond = make_mask(condition, shrink=False)
 1987:     a = np.array(a, copy=copy, subok=True)
 1988: 
 1989:     (cshape, ashape) = (cond.shape, a.shape)
 1990:     if cshape and cshape != ashape:
 1991:         raise IndexError("Inconsistent shape between the condition and the input"
 1992:                          " (got %s and %s)" % (cshape, ashape))
 1993:     if hasattr(a, '_mask'):
 1994:         cond = mask_or(cond, a._mask)
 1995:         cls = type(a)
 1996:     else:
 1997:         cls = MaskedArray
 1998:     result = a.view(cls)
 1999:     # Assign to *.mask so that structured masks are handled correctly.
 2000:     result.mask = _shrink_mask(cond)
 2001:     # There is no view of a boolean so when 'a' is a MaskedArray with nomask
 2002:     # the update to the result's mask has no effect.
 2003:     if not copy and hasattr(a, '_mask') and getmask(a) is nomask:
 2004:         a._mask = result._mask.view()
 2005:     return result
 2006: 
 2007: 
 2008: def masked_greater(x, value, copy=True):
 2009:     """
 2010:     Mask an array where greater than a given value.
 2011: 
 2012:     This function is a shortcut to ``masked_where``, with
 2013:     `condition` = (x > value).
 2014: 
 2015:     See Also
 2016:     --------
 2017:     masked_where : Mask where a condition is met.
 2018: 
 2019:     Examples
 2020:     --------
 2021:     >>> import numpy as np
 2022:     >>> import numpy.ma as ma
 2023:     >>> a = np.arange(4)
 2024:     >>> a
 2025:     array([0, 1, 2, 3])
 2026:     >>> ma.masked_greater(a, 2)
 2027:     masked_array(data=[0, 1, 2, --],
 2028:                  mask=[False, False, False,  True],
 2029:            fill_value=999999)
 2030: 
 2031:     """
 2032:     return masked_where(greater(x, value), x, copy=copy)
 2033: 
 2034: 
 2035: def masked_greater_equal(x, value, copy=True):
 2036:     """
 2037:     Mask an array where greater than or equal to a given value.
 2038: 
 2039:     This function is a shortcut to ``masked_where``, with
 2040:     `condition` = (x >= value).
 2041: 
 2042:     See Also
 2043:     --------
 2044:     masked_where : Mask where a condition is met.
 2045: 
 2046:     Examples
 2047:     --------
 2048:     >>> import numpy as np
 2049:     >>> import numpy.ma as ma
 2050:     >>> a = np.arange(4)
 2051:     >>> a
 2052:     array([0, 1, 2, 3])
 2053:     >>> ma.masked_greater_equal(a, 2)
 2054:     masked_array(data=[0, 1, --, --],
 2055:                  mask=[False, False,  True,  True],
 2056:            fill_value=999999)
 2057: 
 2058:     """
 2059:     return masked_where(greater_equal(x, value), x, copy=copy)
 2060: 
 2061: 
 2062: def masked_less(x, value, copy=True):
 2063:     """
 2064:     Mask an array where less than a given value.
 2065: 
 2066:     This function is a shortcut to ``masked_where``, with
 2067:     `condition` = (x < value).
 2068: 
 2069:     See Also
 2070:     --------
 2071:     masked_where : Mask where a condition is met.
 2072: 
 2073:     Examples
 2074:     --------
 2075:     >>> import numpy as np
 2076:     >>> import numpy.ma as ma
 2077:     >>> a = np.arange(4)
 2078:     >>> a
 2079:     array([0, 1, 2, 3])
 2080:     >>> ma.masked_less(a, 2)
 2081:     masked_array(data=[--, --, 2, 3],
 2082:                  mask=[ True,  True, False, False],
 2083:            fill_value=999999)
 2084: 
 2085:     """
 2086:     return masked_where(less(x, value), x, copy=copy)
 2087: 
 2088: 
 2089: def masked_less_equal(x, value, copy=True):
 2090:     """
 2091:     Mask an array where less than or equal to a given value.
 2092: 
 2093:     This function is a shortcut to ``masked_where``, with
 2094:     `condition` = (x <= value).
 2095: 
 2096:     See Also
 2097:     --------
 2098:     masked_where : Mask where a condition is met.
 2099: 
 2100:     Examples
 2101:     --------
 2102:     >>> import numpy as np
 2103:     >>> import numpy.ma as ma
 2104:     >>> a = np.arange(4)
 2105:     >>> a
 2106:     array([0, 1, 2, 3])
 2107:     >>> ma.masked_less_equal(a, 2)
 2108:     masked_array(data=[--, --, --, 3],
 2109:                  mask=[ True,  True,  True, False],
 2110:            fill_value=999999)
 2111: 
 2112:     """
 2113:     return masked_where(less_equal(x, value), x, copy=copy)
 2114: 
 2115: 
 2116: def masked_not_equal(x, value, copy=True):
 2117:     """
 2118:     Mask an array where *not* equal to a given value.
 2119: 
 2120:     This function is a shortcut to ``masked_where``, with
 2121:     `condition` = (x != value).
 2122: 
 2123:     See Also
 2124:     --------
 2125:     masked_where : Mask where a condition is met.
 2126: 
 2127:     Examples
 2128:     --------
 2129:     >>> import numpy as np
 2130:     >>> import numpy.ma as ma
 2131:     >>> a = np.arange(4)
 2132:     >>> a
 2133:     array([0, 1, 2, 3])
 2134:     >>> ma.masked_not_equal(a, 2)
 2135:     masked_array(data=[--, --, 2, --],
 2136:                  mask=[ True,  True, False,  True],
 2137:            fill_value=999999)
 2138: 
 2139:     """
 2140:     return masked_where(not_equal(x, value), x, copy=copy)
 2141: 
 2142: 
 2143: def masked_equal(x, value, copy=True):
 2144:     """
 2145:     Mask an array where equal to a given value.
 2146: 
 2147:     Return a MaskedArray, masked where the data in array `x` are
 2148:     equal to `value`. The fill_value of the returned MaskedArray
 2149:     is set to `value`.
 2150: 
 2151:     For floating point arrays, consider using ``masked_values(x, value)``.
 2152: 
 2153:     See Also
 2154:     --------
 2155:     masked_where : Mask where a condition is met.
 2156:     masked_values : Mask using floating point equality.
 2157: 
 2158:     Examples
 2159:     --------
 2160:     >>> import numpy as np
 2161:     >>> import numpy.ma as ma
 2162:     >>> a = np.arange(4)
 2163:     >>> a
 2164:     array([0, 1, 2, 3])
 2165:     >>> ma.masked_equal(a, 2)
 2166:     masked_array(data=[0, 1, --, 3],
 2167:                  mask=[False, False,  True, False],
 2168:            fill_value=2)
 2169: 
 2170:     """
 2171:     output = masked_where(equal(x, value), x, copy=copy)
 2172:     output.fill_value = value
 2173:     return output
 2174: 
 2175: 
 2176: def masked_inside(x, v1, v2, copy=True):
 2177:     """
 2178:     Mask an array inside a given interval.
 2179: 
 2180:     Shortcut to ``masked_where``, where `condition` is True for `x` inside
 2181:     the interval [v1,v2] (v1 <= x <= v2).  The boundaries `v1` and `v2`
 2182:     can be given in either order.
 2183: 
 2184:     See Also
 2185:     --------
 2186:     masked_where : Mask where a condition is met.
 2187: 
 2188:     Notes
 2189:     -----
 2190:     The array `x` is prefilled with its filling value.
 2191: 
 2192:     Examples
 2193:     --------
 2194:     >>> import numpy as np
 2195:     >>> import numpy.ma as ma
 2196:     >>> x = [0.31, 1.2, 0.01, 0.2, -0.4, -1.1]
 2197:     >>> ma.masked_inside(x, -0.3, 0.3)
 2198:     masked_array(data=[0.31, 1.2, --, --, -0.4, -1.1],
 2199:                  mask=[False, False,  True,  True, False, False],
 2200:            fill_value=1e+20)
 2201: 
 2202:     The order of `v1` and `v2` doesn't matter.
 2203: 
 2204:     >>> ma.masked_inside(x, 0.3, -0.3)
 2205:     masked_array(data=[0.31, 1.2, --, --, -0.4, -1.1],
 2206:                  mask=[False, False,  True,  True, False, False],
 2207:            fill_value=1e+20)
 2208: 
 2209:     """
 2210:     if v2 < v1:
 2211:         (v1, v2) = (v2, v1)
 2212:     xf = filled(x)
 2213:     condition = (xf >= v1) & (xf <= v2)
 2214:     return masked_where(condition, x, copy=copy)
 2215: 
 2216: 
 2217: def masked_outside(x, v1, v2, copy=True):
 2218:     """
 2219:     Mask an array outside a given interval.
 2220: 
 2221:     Shortcut to ``masked_where``, where `condition` is True for `x` outside
 2222:     the interval [v1,v2] (x < v1)|(x > v2).
 2223:     The boundaries `v1` and `v2` can be given in either order.
 2224: 
 2225:     See Also
 2226:     --------
 2227:     masked_where : Mask where a condition is met.
 2228: 
 2229:     Notes
 2230:     -----
 2231:     The array `x` is prefilled with its filling value.
 2232: 
 2233:     Examples
 2234:     --------
 2235:     >>> import numpy as np
 2236:     >>> import numpy.ma as ma
 2237:     >>> x = [0.31, 1.2, 0.01, 0.2, -0.4, -1.1]
 2238:     >>> ma.masked_outside(x, -0.3, 0.3)
 2239:     masked_array(data=[--, --, 0.01, 0.2, --, --],
 2240:                  mask=[ True,  True, False, False,  True,  True],
 2241:            fill_value=1e+20)
 2242: 
 2243:     The order of `v1` and `v2` doesn't matter.
 2244: 
 2245:     >>> ma.masked_outside(x, 0.3, -0.3)
 2246:     masked_array(data=[--, --, 0.01, 0.2, --, --],
 2247:                  mask=[ True,  True, False, False,  True,  True],
 2248:            fill_value=1e+20)
 2249: 
 2250:     """
 2251:     if v2 < v1:
 2252:         (v1, v2) = (v2, v1)
 2253:     xf = filled(x)
 2254:     condition = (xf < v1) | (xf > v2)
 2255:     return masked_where(condition, x, copy=copy)
 2256: 
 2257: 
 2258: def masked_object(x, value, copy=True, shrink=True):
 2259:     """
 2260:     Mask the array `x` where the data are exactly equal to value.
 2261: 
 2262:     This function is similar to `masked_values`, but only suitable
 2263:     for object arrays: for floating point, use `masked_values` instead.
 2264: 
 2265:     Parameters
 2266:     ----------
 2267:     x : array_like
 2268:         Array to mask
 2269:     value : object
 2270:         Comparison value
 2271:     copy : {True, False}, optional
 2272:         Whether to return a copy of `x`.
 2273:     shrink : {True, False}, optional
 2274:         Whether to collapse a mask full of False to nomask
 2275: 
 2276:     Returns
 2277:     -------
 2278:     result : MaskedArray
 2279:         The result of masking `x` where equal to `value`.
 2280: 
 2281:     See Also
 2282:     --------
 2283:     masked_where : Mask where a condition is met.
 2284:     masked_equal : Mask where equal to a given value (integers).
 2285:     masked_values : Mask using floating point equality.
 2286: 
 2287:     Examples
 2288:     --------
 2289:     >>> import numpy as np
 2290:     >>> import numpy.ma as ma
 2291:     >>> food = np.array(['green_eggs', 'ham'], dtype=object)
 2292:     >>> # don't eat spoiled food
 2293:     >>> eat = ma.masked_object(food, 'green_eggs')
 2294:     >>> eat
 2295:     masked_array(data=[--, 'ham'],
 2296:                  mask=[ True, False],
 2297:            fill_value='green_eggs',
 2298:                 dtype=object)
 2299:     >>> # plain ol` ham is boring
 2300:     >>> fresh_food = np.array(['cheese', 'ham', 'pineapple'], dtype=object)
 2301:     >>> eat = ma.masked_object(fresh_food, 'green_eggs')
 2302:     >>> eat
 2303:     masked_array(data=['cheese', 'ham', 'pineapple'],
 2304:                  mask=False,
 2305:            fill_value='green_eggs',
 2306:                 dtype=object)
 2307: 
 2308:     Note that `mask` is set to ``nomask`` if possible.
 2309: 
 2310:     >>> eat
 2311:     masked_array(data=['cheese', 'ham', 'pineapple'],
 2312:                  mask=False,
 2313:            fill_value='green_eggs',
 2314:                 dtype=object)
 2315: 
 2316:     """
 2317:     if isMaskedArray(x):
 2318:         condition = umath.equal(x._data, value)
 2319:         mask = x._mask
 2320:     else:
 2321:         condition = umath.equal(np.asarray(x), value)
 2322:         mask = nomask
 2323:     mask = mask_or(mask, make_mask(condition, shrink=shrink))
 2324:     return masked_array(x, mask=mask, copy=copy, fill_value=value)
 2325: 
 2326: 
 2327: def masked_values(x, value, rtol=1e-5, atol=1e-8, copy=True, shrink=True):
 2328:     """
 2329:     Mask using floating point equality.
 2330: 
 2331:     Return a MaskedArray, masked where the data in array `x` are approximately
 2332:     equal to `value`, determined using `isclose`. The default tolerances for
 2333:     `masked_values` are the same as those for `isclose`.
 2334: 
 2335:     For integer types, exact equality is used, in the same way as
 2336:     `masked_equal`.
 2337: 
 2338:     The fill_value is set to `value` and the mask is set to ``nomask`` if
 2339:     possible.
 2340: 
 2341:     Parameters
 2342:     ----------
 2343:     x : array_like
 2344:         Array to mask.
 2345:     value : float
 2346:         Masking value.
 2347:     rtol, atol : float, optional
 2348:         Tolerance parameters passed on to `isclose`
 2349:     copy : bool, optional
 2350:         Whether to return a copy of `x`.
 2351:     shrink : bool, optional
 2352:         Whether to collapse a mask full of False to ``nomask``.
 2353: 
 2354:     Returns
 2355:     -------
 2356:     result : MaskedArray
 2357:         The result of masking `x` where approximately equal to `value`.
 2358: 
 2359:     See Also
 2360:     --------
 2361:     masked_where : Mask where a condition is met.
 2362:     masked_equal : Mask where equal to a given value (integers).
 2363: 
 2364:     Examples
 2365:     --------
 2366:     >>> import numpy as np
 2367:     >>> import numpy.ma as ma
 2368:     >>> x = np.array([1, 1.1, 2, 1.1, 3])
 2369:     >>> ma.masked_values(x, 1.1)
 2370:     masked_array(data=[1.0, --, 2.0, --, 3.0],
 2371:                  mask=[False,  True, False,  True, False],
 2372:            fill_value=1.1)
 2373: 
 2374:     Note that `mask` is set to ``nomask`` if possible.
 2375: 
 2376:     >>> ma.masked_values(x, 2.1)
 2377:     masked_array(data=[1. , 1.1, 2. , 1.1, 3. ],
 2378:                  mask=False,
 2379:            fill_value=2.1)
 2380: 
 2381:     Unlike `masked_equal`, `masked_values` can perform approximate equalities.
 2382: 
 2383:     >>> ma.masked_values(x, 2.1, atol=1e-1)
 2384:     masked_array(data=[1.0, 1.1, --, 1.1, 3.0],
 2385:                  mask=[False, False,  True, False, False],
 2386:            fill_value=2.1)
 2387: 
 2388:     """
 2389:     xnew = filled(x, value)
 2390:     if np.issubdtype(xnew.dtype, np.floating):
 2391:         mask = np.isclose(xnew, value, atol=atol, rtol=rtol)
 2392:     else:
 2393:         mask = umath.equal(xnew, value)
 2394:     ret = masked_array(xnew, mask=mask, copy=copy, fill_value=value)
 2395:     if shrink:
 2396:         ret.shrink_mask()
 2397:     return ret
 2398: 
 2399: 
 2400: def masked_invalid(a, copy=True):
 2401:     """
 2402:     Mask an array where invalid values occur (NaNs or infs).
 2403: 
 2404:     This function is a shortcut to ``masked_where``, with
 2405:     `condition` = ~(np.isfinite(a)). Any pre-existing mask is conserved.
 2406:     Only applies to arrays with a dtype where NaNs or infs make sense
 2407:     (i.e. floating point types), but accepts any array_like object.
 2408: 
 2409:     See Also
 2410:     --------
 2411:     masked_where : Mask where a condition is met.
 2412: 
 2413:     Examples
 2414:     --------
 2415:     >>> import numpy as np
 2416:     >>> import numpy.ma as ma
 2417:     >>> a = np.arange(5, dtype=float)
 2418:     >>> a[2] = np.nan
 2419:     >>> a[3] = np.inf
 2420:     >>> a
 2421:     array([ 0.,  1., nan, inf,  4.])
 2422:     >>> ma.masked_invalid(a)
 2423:     masked_array(data=[0.0, 1.0, --, --, 4.0],
 2424:                  mask=[False, False,  True,  True, False],
 2425:            fill_value=1e+20)
 2426: 
 2427:     """
 2428:     a = np.array(a, copy=None, subok=True)
 2429:     res = masked_where(~(np.isfinite(a)), a, copy=copy)
 2430:     # masked_invalid previously never returned nomask as a mask and doing so
 2431:     # threw off matplotlib (gh-22842).  So use shrink=False:
 2432:     if res._mask is nomask:
 2433:         res._mask = make_mask_none(res.shape, res.dtype)
 2434:     return res
 2435: 
 2436: ###############################################################################
 2437: #                            Printing options                                 #
 2438: ###############################################################################
 2439: 
 2440: 
 2441: class _MaskedPrintOption:
 2442:     """
 2443:     Handle the string used to represent missing data in a masked array.
 2444: 
 2445:     """
 2446: 
 2447:     def __init__(self, display):
 2448:         """
 2449:         Create the masked_print_option object.
 2450: 
 2451:         """
 2452:         self._display = display
 2453:         self._enabled = True
 2454: 
 2455:     def display(self):
 2456:         """
 2457:         Display the string to print for masked values.
 2458: 
 2459:         """
 2460:         return self._display
 2461: 
 2462:     def set_display(self, s):
 2463:         """
 2464:         Set the string to print for masked values.
 2465: 
 2466:         """
 2467:         self._display = s
 2468: 
 2469:     def enabled(self):
 2470:         """
 2471:         Is the use of the display value enabled?
 2472: 
 2473:         """
 2474:         return self._enabled
 2475: 
 2476:     def enable(self, shrink=1):
 2477:         """
 2478:         Set the enabling shrink to `shrink`.
 2479: 
 2480:         """
 2481:         self._enabled = shrink
 2482: 
 2483:     def __str__(self):
 2484:         return str(self._display)
 2485: 
 2486:     __repr__ = __str__
 2487: 
 2488: 
 2489: # if you single index into a masked location you get this object.
 2490: masked_print_option = _MaskedPrintOption('--')
 2491: 
 2492: 
 2493: def _recursive_printoption(result, mask, printopt):
 2494:     """
 2495:     Puts printoptions in result where mask is True.
 2496: 
 2497:     Private function allowing for recursion
 2498: 
 2499:     """
 2500:     names = result.dtype.names
 2501:     if names is not None:
 2502:         for name in names:
 2503:             curdata = result[name]
 2504:             curmask = mask[name]
 2505:             _recursive_printoption(curdata, curmask, printopt)
 2506:     else:
 2507:         np.copyto(result, printopt, where=mask)
 2508: 
 2509: 
 2510: # For better or worse, these end in a newline
 2511: _legacy_print_templates = {
 2512:     'long_std': textwrap.dedent("""\
 2513:         masked_%(name)s(data =
 2514:          %(data)s,
 2515:         %(nlen)s        mask =
 2516:          %(mask)s,
 2517:         %(nlen)s  fill_value = %(fill)s)
 2518:         """),
 2519:     'long_flx': textwrap.dedent("""\
 2520:         masked_%(name)s(data =
 2521:          %(data)s,
 2522:         %(nlen)s        mask =
 2523:          %(mask)s,
 2524:         %(nlen)s  fill_value = %(fill)s,
 2525:         %(nlen)s       dtype = %(dtype)s)
 2526:         """),
 2527:     'short_std': textwrap.dedent("""\
 2528:         masked_%(name)s(data = %(data)s,
 2529:         %(nlen)s        mask = %(mask)s,
 2530:         %(nlen)s  fill_value = %(fill)s)
 2531:         """),
 2532:     'short_flx': textwrap.dedent("""\
 2533:         masked_%(name)s(data = %(data)s,
 2534:         %(nlen)s        mask = %(mask)s,
 2535:         %(nlen)s  fill_value = %(fill)s,
 2536:         %(nlen)s       dtype = %(dtype)s)
 2537:         """)
 2538: }
 2539: 
 2540: ###############################################################################
 2541: #                          MaskedArray class                                  #
 2542: ###############################################################################
 2543: 
 2544: 
 2545: def _recursive_filled(a, mask, fill_value):
 2546:     """
 2547:     Recursively fill `a` with `fill_value`.
 2548: 
 2549:     """
 2550:     names = a.dtype.names
 2551:     for name in names:
 2552:         current = a[name]
 2553:         if current.dtype.names is not None:
 2554:             _recursive_filled(current, mask[name], fill_value[name])
 2555:         else:
 2556:             np.copyto(current, fill_value[name], where=mask[name])
 2557: 
 2558: 
 2559: def flatten_structured_array(a):
 2560:     """
 2561:     Flatten a structured array.
 2562: 
 2563:     The data type of the output is chosen such that it can represent all of the
 2564:     (nested) fields.
 2565: 
 2566:     Parameters
 2567:     ----------
 2568:     a : structured array
 2569: 
 2570:     Returns
 2571:     -------
 2572:     output : masked array or ndarray
 2573:         A flattened masked array if the input is a masked array, otherwise a
 2574:         standard ndarray.
 2575: 
 2576:     Examples
 2577:     --------
 2578:     >>> import numpy as np
 2579:     >>> ndtype = [('a', int), ('b', float)]
 2580:     >>> a = np.array([(1, 1), (2, 2)], dtype=ndtype)
 2581:     >>> np.ma.flatten_structured_array(a)
 2582:     array([[1., 1.],
 2583:            [2., 2.]])
 2584: 
 2585:     """
 2586: 
 2587:     def flatten_sequence(iterable):
 2588:         """
 2589:         Flattens a compound of nested iterables.
 2590: 
 2591:         """
 2592:         for elm in iter(iterable):
 2593:             if hasattr(elm, '__iter__'):
 2594:                 yield from flatten_sequence(elm)
 2595:             else:
 2596:                 yield elm
 2597: 
 2598:     a = np.asanyarray(a)
 2599:     inishape = a.shape
 2600:     a = a.ravel()
 2601:     if isinstance(a, MaskedArray):
 2602:         out = np.array([tuple(flatten_sequence(d.item())) for d in a._data])
 2603:         out = out.view(MaskedArray)
 2604:         out._mask = np.array([tuple(flatten_sequence(d.item()))
 2605:                               for d in getmaskarray(a)])
 2606:     else:
 2607:         out = np.array([tuple(flatten_sequence(d.item())) for d in a])
 2608:     if len(inishape) > 1:
 2609:         newshape = list(out.shape)
 2610:         newshape[0] = inishape
 2611:         out.shape = tuple(flatten_sequence(newshape))
 2612:     return out
 2613: 
 2614: 
 2615: def _arraymethod(funcname, onmask=True):
 2616:     """
 2617:     Return a class method wrapper around a basic array method.
 2618: 
 2619:     Creates a class method which returns a masked array, where the new
 2620:     ``_data`` array is the output of the corresponding basic method called
 2621:     on the original ``_data``.
 2622: 
 2623:     If `onmask` is True, the new mask is the output of the method called
 2624:     on the initial mask. Otherwise, the new mask is just a reference
 2625:     to the initial mask.
 2626: 
 2627:     Parameters
 2628:     ----------
 2629:     funcname : str
 2630:         Name of the function to apply on data.
 2631:     onmask : bool
 2632:         Whether the mask must be processed also (True) or left
 2633:         alone (False). Default is True. Make available as `_onmask`
 2634:         attribute.
 2635: 
 2636:     Returns
 2637:     -------
 2638:     method : instancemethod
 2639:         Class method wrapper of the specified basic array method.
 2640: 
 2641:     """
 2642:     def wrapped_method(self, *args, **params):
 2643:         result = getattr(self._data, funcname)(*args, **params)
 2644:         result = result.view(type(self))
 2645:         result._update_from(self)
 2646:         mask = self._mask
 2647:         if not onmask:
 2648:             result.__setmask__(mask)
 2649:         elif mask is not nomask:
 2650:             # __setmask__ makes a copy, which we don't want
 2651:             result._mask = getattr(mask, funcname)(*args, **params)
 2652:         return result
 2653:     methdoc = getattr(ndarray, funcname, None) or getattr(np, funcname, None)
 2654:     if methdoc is not None:
 2655:         wrapped_method.__doc__ = methdoc.__doc__
 2656:     wrapped_method.__name__ = funcname
 2657:     return wrapped_method
 2658: 
 2659: 
 2660: class MaskedIterator:
 2661:     """
 2662:     Flat iterator object to iterate over masked arrays.
 2663: 
 2664:     A `MaskedIterator` iterator is returned by ``x.flat`` for any masked array
 2665:     `x`. It allows iterating over the array as if it were a 1-D array,
 2666:     either in a for-loop or by calling its `next` method.
 2667: 
 2668:     Iteration is done in C-contiguous style, with the last index varying the
 2669:     fastest. The iterator can also be indexed using basic slicing or
 2670:     advanced indexing.
 2671: 
 2672:     See Also
 2673:     --------
 2674:     MaskedArray.flat : Return a flat iterator over an array.
 2675:     MaskedArray.flatten : Returns a flattened copy of an array.
 2676: 
 2677:     Notes
 2678:     -----
 2679:     `MaskedIterator` is not exported by the `ma` module. Instead of
 2680:     instantiating a `MaskedIterator` directly, use `MaskedArray.flat`.
 2681: 
 2682:     Examples
 2683:     --------
 2684:     >>> import numpy as np
 2685:     >>> x = np.ma.array(arange(6).reshape(2, 3))
 2686:     >>> fl = x.flat
 2687:     >>> type(fl)
 2688:     <class 'numpy.ma.MaskedIterator'>
 2689:     >>> for item in fl:
 2690:     ...     print(item)
 2691:     ...
 2692:     0
 2693:     1
 2694:     2
 2695:     3
 2696:     4
 2697:     5
 2698: 
 2699:     Extracting more than a single element b indexing the `MaskedIterator`
 2700:     returns a masked array:
 2701: 
 2702:     >>> fl[2:4]
 2703:     masked_array(data = [2 3],
 2704:                  mask = False,
 2705:            fill_value = 999999)
 2706: 
 2707:     """
 2708: 
 2709:     def __init__(self, ma):
 2710:         self.ma = ma
 2711:         self.dataiter = ma._data.flat
 2712: 
 2713:         if ma._mask is nomask:
 2714:             self.maskiter = None
 2715:         else:
 2716:             self.maskiter = ma._mask.flat
 2717: 
 2718:     def __iter__(self):
 2719:         return self
 2720: 
 2721:     def __getitem__(self, indx):
 2722:         result = self.dataiter.__getitem__(indx).view(type(self.ma))
 2723:         if self.maskiter is not None:
 2724:             _mask = self.maskiter.__getitem__(indx)
 2725:             if isinstance(_mask, ndarray):
 2726:                 # set shape to match that of data; this is needed for matrices
 2727:                 _mask.shape = result.shape
 2728:                 result._mask = _mask
 2729:             elif isinstance(_mask, np.void):
 2730:                 return mvoid(result, mask=_mask, hardmask=self.ma._hardmask)
 2731:             elif _mask:  # Just a scalar, masked
 2732:                 return masked
 2733:         return result
 2734: 
 2735:     # This won't work if ravel makes a copy
 2736:     def __setitem__(self, index, value):
 2737:         self.dataiter[index] = getdata(value)
 2738:         if self.maskiter is not None:
 2739:             self.maskiter[index] = getmaskarray(value)
 2740: 
 2741:     def __next__(self):
 2742:         """
 2743:         Return the next value, or raise StopIteration.
 2744: 
 2745:         Examples
 2746:         --------
 2747:         >>> import numpy as np
 2748:         >>> x = np.ma.array([3, 2], mask=[0, 1])
 2749:         >>> fl = x.flat
 2750:         >>> next(fl)
 2751:         3
 2752:         >>> next(fl)
 2753:         masked
 2754:         >>> next(fl)
 2755:         Traceback (most recent call last):
 2756:           ...
 2757:         StopIteration
 2758: 
 2759:         """
 2760:         d = next(self.dataiter)
 2761:         if self.maskiter is not None:
 2762:             m = next(self.maskiter)
 2763:             if isinstance(m, np.void):
 2764:                 return mvoid(d, mask=m, hardmask=self.ma._hardmask)
 2765:             elif m:  # Just a scalar, masked
 2766:                 return masked
 2767:         return d
 2768: 
 2769: 
 2770: @set_module("numpy.ma")
 2771: class MaskedArray(ndarray):
 2772:     """
 2773:     An array class with possibly masked values.
 2774: 
 2775:     Masked values of True exclude the corresponding element from any
 2776:     computation.
 2777: 
 2778:     Construction::
 2779: 
 2780:       x = MaskedArray(data, mask=nomask, dtype=None, copy=False, subok=True,
 2781:                       ndmin=0, fill_value=None, keep_mask=True, hard_mask=None,
 2782:                       shrink=True, order=None)
 2783: 
 2784:     Parameters
 2785:     ----------
 2786:     data : array_like
 2787:         Input data.
 2788:     mask : sequence, optional
 2789:         Mask. Must be convertible to an array of booleans with the same
 2790:         shape as `data`. True indicates a masked (i.e. invalid) data.
 2791:     dtype : dtype, optional
 2792:         Data type of the output.
 2793:         If `dtype` is None, the type of the data argument (``data.dtype``)
 2794:         is used. If `dtype` is not None and different from ``data.dtype``,
 2795:         a copy is performed.
 2796:     copy : bool, optional
 2797:         Whether to copy the input data (True), or to use a reference instead.
 2798:         Default is False.
 2799:     subok : bool, optional
 2800:         Whether to return a subclass of `MaskedArray` if possible (True) or a
 2801:         plain `MaskedArray`. Default is True.
 2802:     ndmin : int, optional
 2803:         Minimum number of dimensions. Default is 0.
 2804:     fill_value : scalar, optional
 2805:         Value used to fill in the masked values when necessary.
 2806:         If None, a default based on the data-type is used.
 2807:     keep_mask : bool, optional
 2808:         Whether to combine `mask` with the mask of the input data, if any
 2809:         (True), or to use only `mask` for the output (False). Default is True.
 2810:     hard_mask : bool, optional
 2811:         Whether to use a hard mask or not. With a hard mask, masked values
 2812:         cannot be unmasked. Default is False.
 2813:     shrink : bool, optional
 2814:         Whether to force compression of an empty mask. Default is True.
 2815:     order : {'C', 'F', 'A'}, optional
 2816:         Specify the order of the array.  If order is 'C', then the array
 2817:         will be in C-contiguous order (last-index varies the fastest).
 2818:         If order is 'F', then the returned array will be in
 2819:         Fortran-contiguous order (first-index varies the fastest).
 2820:         If order is 'A' (default), then the returned array may be
 2821:         in any order (either C-, Fortran-contiguous, or even discontiguous),
 2822:         unless a copy is required, in which case it will be C-contiguous.
 2823: 
 2824:     Examples
 2825:     --------
 2826:     >>> import numpy as np
 2827: 
 2828:     The ``mask`` can be initialized with an array of boolean values
 2829:     with the same shape as ``data``.
 2830: 
 2831:     >>> data = np.arange(6).reshape((2, 3))
 2832:     >>> np.ma.MaskedArray(data, mask=[[False, True, False],
 2833:     ...                               [False, False, True]])
 2834:     masked_array(
 2835:       data=[[0, --, 2],
 2836:             [3, 4, --]],
 2837:       mask=[[False,  True, False],
 2838:             [False, False,  True]],
 2839:       fill_value=999999)
 2840: 
 2841:     Alternatively, the ``mask`` can be initialized to homogeneous boolean
 2842:     array with the same shape as ``data`` by passing in a scalar
 2843:     boolean value:
 2844: 
 2845:     >>> np.ma.MaskedArray(data, mask=False)
 2846:     masked_array(
 2847:       data=[[0, 1, 2],
 2848:             [3, 4, 5]],
 2849:       mask=[[False, False, False],
 2850:             [False, False, False]],
 2851:       fill_value=999999)
 2852: 
 2853:     >>> np.ma.MaskedArray(data, mask=True)
 2854:     masked_array(
 2855:       data=[[--, --, --],
 2856:             [--, --, --]],
 2857:       mask=[[ True,  True,  True],
 2858:             [ True,  True,  True]],
 2859:       fill_value=999999,
 2860:       dtype=int64)
 2861: 
 2862:     .. note::
 2863:         The recommended practice for initializing ``mask`` with a scalar
 2864:         boolean value is to use ``True``/``False`` rather than
 2865:         ``np.True_``/``np.False_``. The reason is :attr:`nomask`
 2866:         is represented internally as ``np.False_``.
 2867: 
 2868:         >>> np.False_ is np.ma.nomask
 2869:         True
 2870: 
 2871:     """
 2872: 
 2873:     __array_priority__ = 15
 2874:     _defaultmask = nomask
 2875:     _defaulthardmask = False
 2876:     _baseclass = ndarray
 2877: 
 2878:     # Maximum number of elements per axis used when printing an array. The
 2879:     # 1d case is handled separately because we need more values in this case.
 2880:     _print_width = 100
 2881:     _print_width_1d = 1500
 2882: 
 2883:     def __new__(cls, data=None, mask=nomask, dtype=None, copy=False,
 2884:                 subok=True, ndmin=0, fill_value=None, keep_mask=True,
 2885:                 hard_mask=None, shrink=True, order=None):
 2886:         """
 2887:         Create a new masked array from scratch.
 2888: 
 2889:         Notes
 2890:         -----
 2891:         A masked array can also be created by taking a .view(MaskedArray).
 2892: 
 2893:         """
 2894:         # Process data.
 2895:         copy = None if not copy else True
 2896:         _data = np.array(data, dtype=dtype, copy=copy,
 2897:                          order=order, subok=True, ndmin=ndmin)
 2898:         _baseclass = getattr(data, '_baseclass', type(_data))
 2899:         # Check that we're not erasing the mask.
 2900:         if isinstance(data, MaskedArray) and (data.shape != _data.shape):
 2901:             copy = True
 2902: 
 2903:         # Here, we copy the _view_, so that we can attach new properties to it
 2904:         # we must never do .view(MaskedConstant), as that would create a new
 2905:         # instance of np.ma.masked, which make identity comparison fail
 2906:         if isinstance(data, cls) and subok and not isinstance(data, MaskedConstant):
 2907:             _data = ndarray.view(_data, type(data))
 2908:         else:
 2909:             _data = ndarray.view(_data, cls)
 2910: 
 2911:         # Handle the case where data is not a subclass of ndarray, but
 2912:         # still has the _mask attribute like MaskedArrays
 2913:         if hasattr(data, '_mask') and not isinstance(data, ndarray):
 2914:             _data._mask = data._mask
 2915:             # FIXME: should we set `_data._sharedmask = True`?
 2916:         # Process mask.
 2917:         # Type of the mask
 2918:         mdtype = make_mask_descr(_data.dtype)
 2919:         if mask is nomask:
 2920:             # Case 1. : no mask in input.
 2921:             # Erase the current mask ?
 2922:             if not keep_mask:
 2923:                 # With a reduced version
 2924:                 if shrink:
 2925:                     _data._mask = nomask
 2926:                 # With full version
 2927:                 else:
 2928:                     _data._mask = np.zeros(_data.shape, dtype=mdtype)
 2929:             # Check whether we missed something
 2930:             elif isinstance(data, (tuple, list)):
 2931:                 try:
 2932:                     # If data is a sequence of masked array
 2933:                     mask = np.array(
 2934:                         [getmaskarray(np.asanyarray(m, dtype=_data.dtype))
 2935:                          for m in data], dtype=mdtype)
 2936:                 except (ValueError, TypeError):
 2937:                     # If data is nested
 2938:                     mask = nomask
 2939:                 # Force shrinking of the mask if needed (and possible)
 2940:                 if (mdtype == MaskType) and mask.any():
 2941:                     _data._mask = mask
 2942:                     _data._sharedmask = False
 2943:             else:
 2944:                 _data._sharedmask = not copy
 2945:                 if copy:
 2946:                     _data._mask = _data._mask.copy()
 2947:                     # Reset the shape of the original mask
 2948:                     if getmask(data) is not nomask:
 2949:                         # gh-21022 encounters an issue here
 2950:                         # because data._mask.shape is not writeable, but
 2951:                         # the op was also pointless in that case, because
 2952:                         # the shapes were the same, so we can at least
 2953:                         # avoid that path
 2954:                         if data._mask.shape != data.shape:
 2955:                             data._mask.shape = data.shape
 2956:         else:
 2957:             # Case 2. : With a mask in input.
 2958:             # If mask is boolean, create an array of True or False
 2959: 
 2960:             # if users pass `mask=None` be forgiving here and cast it False
 2961:             # for speed; although the default is `mask=nomask` and can differ.
 2962:             if mask is None:
 2963:                 mask = False
 2964: 
 2965:             if mask is True and mdtype == MaskType:
 2966:                 mask = np.ones(_data.shape, dtype=mdtype)
 2967:             elif mask is False and mdtype == MaskType:
 2968:                 mask = np.zeros(_data.shape, dtype=mdtype)
 2969:             else:
 2970:                 # Read the mask with the current mdtype
 2971:                 try:
 2972:                     mask = np.array(mask, copy=copy, dtype=mdtype)
 2973:                 # Or assume it's a sequence of bool/int
 2974:                 except TypeError:
 2975:                     mask = np.array([tuple([m] * len(mdtype)) for m in mask],
 2976:                                     dtype=mdtype)
 2977:             # Make sure the mask and the data have the same shape
 2978:             if mask.shape != _data.shape:
 2979:                 (nd, nm) = (_data.size, mask.size)
 2980:                 if nm == 1:
 2981:                     mask = np.resize(mask, _data.shape)
 2982:                 elif nm == nd:
 2983:                     mask = np.reshape(mask, _data.shape)
 2984:                 else:
 2985:                     msg = (f"Mask and data not compatible:"
 2986:                            f" data size is {nd}, mask size is {nm}.")
 2987:                     raise MaskError(msg)
 2988:                 copy = True
 2989:             # Set the mask to the new value
 2990:             if _data._mask is nomask:
 2991:                 _data._mask = mask
 2992:                 _data._sharedmask = not copy
 2993:             elif not keep_mask:
 2994:                 _data._mask = mask
 2995:                 _data._sharedmask = not copy
 2996:             else:
 2997:                 if _data.dtype.names is not None:
 2998:                     def _recursive_or(a, b):
 2999:                         "do a|=b on each field of a, recursively"
 3000:                         for name in a.dtype.names:
 3001:                             (af, bf) = (a[name], b[name])
 3002:                             if af.dtype.names is not None:
 3003:                                 _recursive_or(af, bf)
 3004:                             else:
 3005:                                 af |= bf
 3006: 
 3007:                     _recursive_or(_data._mask, mask)
 3008:                 else:
 3009:                     _data._mask = np.logical_or(mask, _data._mask)
 3010:                 _data._sharedmask = False
 3011: 
 3012:         # Update fill_value.
 3013:         if fill_value is None:
 3014:             fill_value = getattr(data, '_fill_value', None)
 3015:         # But don't run the check unless we have something to check.
 3016:         if fill_value is not None:
 3017:             _data._fill_value = _check_fill_value(fill_value, _data.dtype)
 3018:         # Process extra options ..
 3019:         if hard_mask is None:
 3020:             _data._hardmask = getattr(data, '_hardmask', False)
 3021:         else:
 3022:             _data._hardmask = hard_mask
 3023:         _data._baseclass = _baseclass
 3024:         return _data
 3025: 
 3026:     def _update_from(self, obj):
 3027:         """
 3028:         Copies some attributes of obj to self.
 3029: 
 3030:         """
 3031:         if isinstance(obj, ndarray):
 3032:             _baseclass = type(obj)
 3033:         else:
 3034:             _baseclass = ndarray
 3035:         # We need to copy the _basedict to avoid backward propagation
 3036:         _optinfo = {}
 3037:         _optinfo.update(getattr(obj, '_optinfo', {}))
 3038:         _optinfo.update(getattr(obj, '_basedict', {}))
 3039:         if not isinstance(obj, MaskedArray):
 3040:             _optinfo.update(getattr(obj, '__dict__', {}))
 3041:         _dict = {'_fill_value': getattr(obj, '_fill_value', None),
 3042:                      '_hardmask': getattr(obj, '_hardmask', False),
 3043:                      '_sharedmask': getattr(obj, '_sharedmask', False),
 3044:                      '_isfield': getattr(obj, '_isfield', False),
 3045:                      '_baseclass': getattr(obj, '_baseclass', _baseclass),
 3046:                      '_optinfo': _optinfo,
 3047:                      '_basedict': _optinfo}
 3048:         self.__dict__.update(_dict)
 3049:         self.__dict__.update(_optinfo)
 3050: 
 3051:     def __array_finalize__(self, obj):
 3052:         """
 3053:         Finalizes the masked array.
 3054: 
 3055:         """
 3056:         # Get main attributes.
 3057:         self._update_from(obj)
 3058: 
 3059:         # We have to decide how to initialize self.mask, based on
 3060:         # obj.mask. This is very difficult.  There might be some
 3061:         # correspondence between the elements in the array we are being
 3062:         # created from (= obj) and us. Or there might not. This method can
 3063:         # be called in all kinds of places for all kinds of reasons -- could
 3064:         # be empty_like, could be slicing, could be a ufunc, could be a view.
 3065:         # The numpy subclassing interface simply doesn't give us any way
 3066:         # to know, which means that at best this method will be based on
 3067:         # guesswork and heuristics. To make things worse, there isn't even any
 3068:         # clear consensus about what the desired behavior is. For instance,
 3069:         # most users think that np.empty_like(marr) -- which goes via this
 3070:         # method -- should return a masked array with an empty mask (see
 3071:         # gh-3404 and linked discussions), but others disagree, and they have
 3072:         # existing code which depends on empty_like returning an array that
 3073:         # matches the input mask.
 3074:         #
 3075:         # Historically our algorithm was: if the template object mask had the
 3076:         # same *number of elements* as us, then we used *it's mask object
 3077:         # itself* as our mask, so that writes to us would also write to the
 3078:         # original array. This is horribly broken in multiple ways.
 3079:         #
 3080:         # Now what we do instead is, if the template object mask has the same
 3081:         # number of elements as us, and we do not have the same base pointer
 3082:         # as the template object (b/c views like arr[...] should keep the same
 3083:         # mask), then we make a copy of the template object mask and use
 3084:         # that. This is also horribly broken but somewhat less so. Maybe.
 3085:         if isinstance(obj, ndarray):
 3086:             # XX: This looks like a bug -- shouldn't it check self.dtype
 3087:             # instead?
 3088:             if obj.dtype.names is not None:
 3089:                 _mask = getmaskarray(obj)
 3090:             else:
 3091:                 _mask = getmask(obj)
 3092: 
 3093:             # If self and obj point to exactly the same data, then probably
 3094:             # self is a simple view of obj (e.g., self = obj[...]), so they
 3095:             # should share the same mask. (This isn't 100% reliable, e.g. self
 3096:             # could be the first row of obj, or have strange strides, but as a
 3097:             # heuristic it's not bad.) In all other cases, we make a copy of
 3098:             # the mask, so that future modifications to 'self' do not end up
 3099:             # side-effecting 'obj' as well.
 3100:             if (_mask is not nomask and obj.__array_interface__["data"][0]
 3101:                     != self.__array_interface__["data"][0]):
 3102:                 # We should make a copy. But we could get here via astype,
 3103:                 # in which case the mask might need a new dtype as well
 3104:                 # (e.g., changing to or from a structured dtype), and the
 3105:                 # order could have changed. So, change the mask type if
 3106:                 # needed and use astype instead of copy.
 3107:                 if self.dtype == obj.dtype:
 3108:                     _mask_dtype = _mask.dtype
 3109:                 else:
 3110:                     _mask_dtype = make_mask_descr(self.dtype)
 3111: 
 3112:                 if self.flags.c_contiguous:
 3113:                     order = "C"
 3114:                 elif self.flags.f_contiguous:
 3115:                     order = "F"
 3116:                 else:
 3117:                     order = "K"
 3118: 
 3119:                 _mask = _mask.astype(_mask_dtype, order)
 3120:             else:
 3121:                 # Take a view so shape changes, etc., do not propagate back.
 3122:                 _mask = _mask.view()
 3123:         else:
 3124:             _mask = nomask
 3125: 
 3126:         self._mask = _mask
 3127:         # Finalize the mask
 3128:         if self._mask is not nomask:
 3129:             try:
 3130:                 self._mask.shape = self.shape
 3131:             except ValueError:
 3132:                 self._mask = nomask
 3133:             except (TypeError, AttributeError):
 3134:                 # When _mask.shape is not writable (because it's a void)
 3135:                 pass
 3136: 
 3137:         # Finalize the fill_value
 3138:         if self._fill_value is not None:
 3139:             self._fill_value = _check_fill_value(self._fill_value, self.dtype)
 3140:         elif self.dtype.names is not None:
 3141:             # Finalize the default fill_value for structured arrays
 3142:             self._fill_value = _check_fill_value(None, self.dtype)
 3143: 
 3144:     def __array_wrap__(self, obj, context=None, return_scalar=False):
 3145:         """
 3146:         Special hook for ufuncs.
 3147: 
 3148:         Wraps the numpy array and sets the mask according to context.
 3149: 
 3150:         """
 3151:         if obj is self:  # for in-place operations
 3152:             result = obj
 3153:         else:
 3154:             result = obj.view(type(self))
 3155:             result._update_from(self)
 3156: 
 3157:         if context is not None:
 3158:             result._mask = result._mask.copy()
 3159:             func, args, out_i = context
 3160:             # args sometimes contains outputs (gh-10459), which we don't want
 3161:             input_args = args[:func.nin]
 3162:             m = functools.reduce(mask_or, [getmaskarray(arg) for arg in input_args])
 3163:             # Get the domain mask
 3164:             domain = ufunc_domain.get(func)
 3165:             if domain is not None:
 3166:                 # Take the domain, and make sure it's a ndarray
 3167:                 with np.errstate(divide='ignore', invalid='ignore'):
 3168:                     # The result may be masked for two (unary) domains.
 3169:                     # That can't really be right as some domains drop
 3170:                     # the mask and some don't behaving differently here.
 3171:                     d = domain(*input_args).astype(bool, copy=False)
 3172:                     d = filled(d, True)
 3173: 
 3174:                 if d.any():
 3175:                     # Fill the result where the domain is wrong
 3176:                     try:
 3177:                         # Binary domain: take the last value
 3178:                         fill_value = ufunc_fills[func][-1]
 3179:                     except TypeError:
 3180:                         # Unary domain: just use this one
 3181:                         fill_value = ufunc_fills[func]
 3182:                     except KeyError:
 3183:                         # Domain not recognized, use fill_value instead
 3184:                         fill_value = self.fill_value
 3185: 
 3186:                     np.copyto(result, fill_value, where=d)
 3187: 
 3188:                     # Update the mask
 3189:                     if m is nomask:
 3190:                         m = d
 3191:                     else:
 3192:                         # Don't modify inplace, we risk back-propagation
 3193:                         m = (m | d)
 3194: 
 3195:             # Make sure the mask has the proper size
 3196:             if result is not self and result.shape == () and m:
 3197:                 return masked
 3198:             else:
 3199:                 result._mask = m
 3200:                 result._sharedmask = False
 3201: 
 3202:         return result
 3203: 
 3204:     def view(self, dtype=None, type=None, fill_value=None):
 3205:         """
 3206:         Return a view of the MaskedArray data.
 3207: 
 3208:         Parameters
 3209:         ----------
 3210:         dtype : data-type or ndarray sub-class, optional
 3211:             Data-type descriptor of the returned view, e.g., float32 or int16.
 3212:             The default, None, results in the view having the same data-type
 3213:             as `a`. As with ``ndarray.view``, dtype can also be specified as
 3214:             an ndarray sub-class, which then specifies the type of the
 3215:             returned object (this is equivalent to setting the ``type``
 3216:             parameter).
 3217:         type : Python type, optional
 3218:             Type of the returned view, either ndarray or a subclass.  The
 3219:             default None results in type preservation.
 3220:         fill_value : scalar, optional
 3221:             The value to use for invalid entries (None by default).
 3222:             If None, then this argument is inferred from the passed `dtype`, or
 3223:             in its absence the original array, as discussed in the notes below.
 3224: 
 3225:         See Also
 3226:         --------
 3227:         numpy.ndarray.view : Equivalent method on ndarray object.
 3228: 
 3229:         Notes
 3230:         -----
 3231: 
 3232:         ``a.view()`` is used two different ways:
 3233: 
 3234:         ``a.view(some_dtype)`` or ``a.view(dtype=some_dtype)`` constructs a view
 3235:         of the array's memory with a different data-type.  This can cause a
 3236:         reinterpretation of the bytes of memory.
 3237: 
 3238:         ``a.view(ndarray_subclass)`` or ``a.view(type=ndarray_subclass)`` just
 3239:         returns an instance of `ndarray_subclass` that looks at the same array
 3240:         (same shape, dtype, etc.)  This does not cause a reinterpretation of the
 3241:         memory.
 3242: 
 3243:         If `fill_value` is not specified, but `dtype` is specified (and is not
 3244:         an ndarray sub-class), the `fill_value` of the MaskedArray will be
 3245:         reset. If neither `fill_value` nor `dtype` are specified (or if
 3246:         `dtype` is an ndarray sub-class), then the fill value is preserved.
 3247:         Finally, if `fill_value` is specified, but `dtype` is not, the fill
 3248:         value is set to the specified value.
 3249: 
 3250:         For ``a.view(some_dtype)``, if ``some_dtype`` has a different number of
 3251:         bytes per entry than the previous dtype (for example, converting a
 3252:         regular array to a structured array), then the behavior of the view
 3253:         cannot be predicted just from the superficial appearance of ``a`` (shown
 3254:         by ``print(a)``). It also depends on exactly how ``a`` is stored in
 3255:         memory. Therefore if ``a`` is C-ordered versus fortran-ordered, versus
 3256:         defined as a slice or transpose, etc., the view may give different
 3257:         results.
 3258:         """
 3259: 
 3260:         if dtype is None:
 3261:             if type is None:
 3262:                 output = ndarray.view(self)
 3263:             else:
 3264:                 output = ndarray.view(self, type)
 3265:         elif type is None:
 3266:             try:
 3267:                 if issubclass(dtype, ndarray):
 3268:                     output = ndarray.view(self, dtype)
 3269:                     dtype = None
 3270:                 else:
 3271:                     output = ndarray.view(self, dtype)
 3272:             except TypeError:
 3273:                 output = ndarray.view(self, dtype)
 3274:         else:
 3275:             output = ndarray.view(self, dtype, type)
 3276: 
 3277:         # also make the mask be a view (so attr changes to the view's
 3278:         # mask do no affect original object's mask)
 3279:         # (especially important to avoid affecting np.masked singleton)
 3280:         if getmask(output) is not nomask:
 3281:             output._mask = output._mask.view()
 3282: 
 3283:         # Make sure to reset the _fill_value if needed
 3284:         if getattr(output, '_fill_value', None) is not None:
 3285:             if fill_value is None:
 3286:                 if dtype is None:
 3287:                     pass  # leave _fill_value as is
 3288:                 else:
 3289:                     output._fill_value = None
 3290:             else:
 3291:                 output.fill_value = fill_value
 3292:         return output
 3293: 
 3294:     def __getitem__(self, indx):
 3295:         """
 3296:         x.__getitem__(y) <==> x[y]
 3297: 
 3298:         Return the item described by i, as a masked array.
 3299: 
 3300:         """
 3301:         # We could directly use ndarray.__getitem__ on self.
 3302:         # But then we would have to modify __array_finalize__ to prevent the
 3303:         # mask of being reshaped if it hasn't been set up properly yet
 3304:         # So it's easier to stick to the current version
 3305:         dout = self.data[indx]
 3306:         _mask = self._mask
 3307: 
 3308:         def _is_scalar(m):
 3309:             return not isinstance(m, np.ndarray)
 3310: 
 3311:         def _scalar_heuristic(arr, elem):
 3312:             """
 3313:             Return whether `elem` is a scalar result of indexing `arr`, or None
 3314:             if undecidable without promoting nomask to a full mask
 3315:             """
 3316:             # obviously a scalar
 3317:             if not isinstance(elem, np.ndarray):
 3318:                 return True
 3319: 
 3320:             # object array scalar indexing can return anything
 3321:             elif arr.dtype.type is np.object_:
 3322:                 if arr.dtype is not elem.dtype:
 3323:                     # elem is an array, but dtypes do not match, so must be
 3324:                     # an element
 3325:                     return True
 3326: 
 3327:             # well-behaved subclass that only returns 0d arrays when
 3328:             # expected - this is not a scalar
 3329:             elif type(arr).__getitem__ == ndarray.__getitem__:
 3330:                 return False
 3331: 
 3332:             return None
 3333: 
 3334:         if _mask is not nomask:
 3335:             # _mask cannot be a subclass, so it tells us whether we should
 3336:             # expect a scalar. It also cannot be of dtype object.
 3337:             mout = _mask[indx]
 3338:             scalar_expected = _is_scalar(mout)
 3339: 
 3340:         else:
 3341:             # attempt to apply the heuristic to avoid constructing a full mask
 3342:             mout = nomask
 3343:             scalar_expected = _scalar_heuristic(self.data, dout)
 3344:             if scalar_expected is None:
 3345:                 # heuristics have failed
 3346:                 # construct a full array, so we can be certain. This is costly.
 3347:                 # we could also fall back on ndarray.__getitem__(self.data, indx)
 3348:                 scalar_expected = _is_scalar(getmaskarray(self)[indx])
 3349: 
 3350:         # Did we extract a single item?
 3351:         if scalar_expected:
 3352:             # A record
 3353:             if isinstance(dout, np.void):
 3354:                 # We should always re-cast to mvoid, otherwise users can
 3355:                 # change masks on rows that already have masked values, but not
 3356:                 # on rows that have no masked values, which is inconsistent.
 3357:                 return mvoid(dout, mask=mout, hardmask=self._hardmask)
 3358: 
 3359:             # special case introduced in gh-5962
 3360:             elif (self.dtype.type is np.object_ and
 3361:                   isinstance(dout, np.ndarray) and
 3362:                   dout is not masked):
 3363:                 # If masked, turn into a MaskedArray, with everything masked.
 3364:                 if mout:
 3365:                     return MaskedArray(dout, mask=True)
 3366:                 else:
 3367:                     return dout
 3368: 
 3369:             # Just a scalar
 3370:             elif mout:
 3371:                 return masked
 3372:             else:
 3373:                 return dout
 3374:         else:
 3375:             # Force dout to MA
 3376:             dout = dout.view(type(self))
 3377:             # Inherit attributes from self
 3378:             dout._update_from(self)
 3379:             # Check the fill_value
 3380:             if is_string_or_list_of_strings(indx):
 3381:                 if self._fill_value is not None:
 3382:                     dout._fill_value = self._fill_value[indx]
 3383: 
 3384:                     # Something like gh-15895 has happened if this check fails.
 3385:                     # _fill_value should always be an ndarray.
 3386:                     if not isinstance(dout._fill_value, np.ndarray):
 3387:                         raise RuntimeError('Internal NumPy error.')
 3388:                     # If we're indexing a multidimensional field in a
 3389:                     # structured array (such as dtype("(2,)i2,(2,)i1")),
 3390:                     # dimensionality goes up (M[field].ndim == M.ndim +
 3391:                     # M.dtype[field].ndim).  That's fine for
 3392:                     # M[field] but problematic for M[field].fill_value
 3393:                     # which should have shape () to avoid breaking several
 3394:                     # methods. There is no great way out, so set to
 3395:                     # first element. See issue #6723.
 3396:                     if dout._fill_value.ndim > 0:
 3397:                         if not (dout._fill_value ==
 3398:                                 dout._fill_value.flat[0]).all():
 3399:                             warnings.warn(
 3400:                                 "Upon accessing multidimensional field "
 3401:                                 f"{indx!s}, need to keep dimensionality "
 3402:                                 "of fill_value at 0. Discarding "
 3403:                                 "heterogeneous fill_value and setting "
 3404:                                 f"all to {dout._fill_value[0]!s}.",
 3405:                                 stacklevel=2)
 3406:                         # Need to use `.flat[0:1].squeeze(...)` instead of just
 3407:                         # `.flat[0]` to ensure the result is a 0d array and not
 3408:                         # a scalar.
 3409:                         dout._fill_value = dout._fill_value.flat[0:1].squeeze(axis=0)
 3410:                 dout._isfield = True
 3411:             # Update the mask if needed
 3412:             if mout is not nomask:
 3413:                 # set shape to match that of data; this is needed for matrices
 3414:                 dout._mask = reshape(mout, dout.shape)
 3415:                 dout._sharedmask = True
 3416:                 # Note: Don't try to check for m.any(), that'll take too long
 3417:         return dout
 3418: 
 3419:     # setitem may put NaNs into integer arrays or occasionally overflow a
 3420:     # float.  But this may happen in masked values, so avoid otherwise
 3421:     # correct warnings (as is typical also in masked calculations).
 3422:     @np.errstate(over='ignore', invalid='ignore')
 3423:     def __setitem__(self, indx, value):
 3424:         """
 3425:         x.__setitem__(i, y) <==> x[i]=y
 3426: 
 3427:         Set item described by index. If value is masked, masks those
 3428:         locations.
 3429: 
 3430:         """
 3431:         if self is masked:
 3432:             raise MaskError('Cannot alter the masked element.')
 3433:         _data = self._data
 3434:         _mask = self._mask
 3435:         if isinstance(indx, str):
 3436:             _data[indx] = value
 3437:             if _mask is nomask:
 3438:                 self._mask = _mask = make_mask_none(self.shape, self.dtype)
 3439:             _mask[indx] = getmask(value)
 3440:             return
 3441: 
 3442:         _dtype = _data.dtype
 3443: 
 3444:         if value is masked:
 3445:             # The mask wasn't set: create a full version.
 3446:             if _mask is nomask:
 3447:                 _mask = self._mask = make_mask_none(self.shape, _dtype)
 3448:             # Now, set the mask to its value.
 3449:             if _dtype.names is not None:
 3450:                 _mask[indx] = tuple([True] * len(_dtype.names))
 3451:             else:
 3452:                 _mask[indx] = True
 3453:             return
 3454: 
 3455:         # Get the _data part of the new value
 3456:         dval = getattr(value, '_data', value)
 3457:         # Get the _mask part of the new value
 3458:         mval = getmask(value)
 3459:         if _dtype.names is not None and mval is nomask:
 3460:             mval = tuple([False] * len(_dtype.names))
 3461:         if _mask is nomask:
 3462:             # Set the data, then the mask
 3463:             _data[indx] = dval
 3464:             if mval is not nomask:
 3465:                 _mask = self._mask = make_mask_none(self.shape, _dtype)
 3466:                 _mask[indx] = mval
 3467:         elif not self._hardmask:
 3468:             # Set the data, then the mask
 3469:             if (isinstance(indx, masked_array) and
 3470:                     not isinstance(value, masked_array)):
 3471:                 _data[indx.data] = dval
 3472:             else:
 3473:                 _data[indx] = dval
 3474:                 _mask[indx] = mval
 3475:         elif hasattr(indx, 'dtype') and (indx.dtype == MaskType):
 3476:             indx = indx * umath.logical_not(_mask)
 3477:             _data[indx] = dval
 3478:         else:
 3479:             if _dtype.names is not None:
 3480:                 err_msg = "Flexible 'hard' masks are not yet supported."
 3481:                 raise NotImplementedError(err_msg)
 3482:             mindx = mask_or(_mask[indx], mval, copy=True)
 3483:             dindx = self._data[indx]
 3484:             if dindx.size > 1:
 3485:                 np.copyto(dindx, dval, where=~mindx)
 3486:             elif mindx is nomask:
 3487:                 dindx = dval
 3488:             _data[indx] = dindx
 3489:             _mask[indx] = mindx
 3490:         return
 3491: 
 3492:     # Define so that we can overwrite the setter.
 3493:     @property
 3494:     def dtype(self):
 3495:         return super().dtype
 3496: 
 3497:     @dtype.setter
 3498:     def dtype(self, dtype):
 3499:         super(MaskedArray, type(self)).dtype.__set__(self, dtype)
 3500:         if self._mask is not nomask:
 3501:             self._mask = self._mask.view(make_mask_descr(dtype), ndarray)
 3502:             # Try to reset the shape of the mask (if we don't have a void).
 3503:             # This raises a ValueError if the dtype change won't work.
 3504:             try:
 3505:                 self._mask.shape = self.shape
 3506:             except (AttributeError, TypeError):
 3507:                 pass
 3508: 
 3509:     @property
 3510:     def shape(self):
 3511:         return super().shape
 3512: 
 3513:     @shape.setter
 3514:     def shape(self, shape):
 3515:         super(MaskedArray, type(self)).shape.__set__(self, shape)
 3516:         # Cannot use self._mask, since it may not (yet) exist when a
 3517:         # masked matrix sets the shape.
 3518:         if getmask(self) is not nomask:
 3519:             self._mask.shape = self.shape
 3520: 
 3521:     def __setmask__(self, mask, copy=False):
 3522:         """
 3523:         Set the mask.
 3524: 
 3525:         """
 3526:         idtype = self.dtype
 3527:         current_mask = self._mask
 3528:         if mask is masked:
 3529:             mask = True
 3530: 
 3531:         if current_mask is nomask:
 3532:             # Make sure the mask is set
 3533:             # Just don't do anything if there's nothing to do.
 3534:             if mask is nomask:
 3535:                 return
 3536:             current_mask = self._mask = make_mask_none(self.shape, idtype)
 3537: 
 3538:         if idtype.names is None:
 3539:             # No named fields.
 3540:             # Hardmask: don't unmask the data
 3541:             if self._hardmask:
 3542:                 current_mask |= mask
 3543:             # Softmask: set everything to False
 3544:             # If it's obviously a compatible scalar, use a quick update
 3545:             # method.
 3546:             elif isinstance(mask, (int, float, np.bool, np.number)):
 3547:                 current_mask[...] = mask
 3548:             # Otherwise fall back to the slower, general purpose way.
 3549:             else:
 3550:                 current_mask.flat = mask
 3551:         else:
 3552:             # Named fields w/
 3553:             mdtype = current_mask.dtype
 3554:             mask = np.asarray(mask)
 3555:             # Mask is a singleton
 3556:             if not mask.ndim:
 3557:                 # It's a boolean : make a record
 3558:                 if mask.dtype.kind == 'b':
 3559:                     mask = np.array(tuple([mask.item()] * len(mdtype)),
 3560:                                     dtype=mdtype)
 3561:                 # It's a record: make sure the dtype is correct
 3562:                 else:
 3563:                     mask = mask.astype(mdtype)
 3564:             # Mask is a sequence
 3565:             else:
 3566:                 # Make sure the new mask is a ndarray with the proper dtype
 3567:                 try:
 3568:                     copy = None if not copy else True
 3569:                     mask = np.array(mask, copy=copy, dtype=mdtype)
 3570:                 # Or assume it's a sequence of bool/int
 3571:                 except TypeError:
 3572:                     mask = np.array([tuple([m] * len(mdtype)) for m in mask],
 3573:                                     dtype=mdtype)
 3574:             # Hardmask: don't unmask the data
 3575:             if self._hardmask:
 3576:                 for n in idtype.names:
 3577:                     current_mask[n] |= mask[n]
 3578:             # Softmask: set everything to False
 3579:             # If it's obviously a compatible scalar, use a quick update
 3580:             # method.
 3581:             elif isinstance(mask, (int, float, np.bool, np.number)):
 3582:                 current_mask[...] = mask
 3583:             # Otherwise fall back to the slower, general purpose way.
 3584:             else:
 3585:                 current_mask.flat = mask
 3586:         # Reshape if needed
 3587:         if current_mask.shape:
 3588:             current_mask.shape = self.shape
 3589:         return
 3590: 
 3591:     _set_mask = __setmask__
 3592: 
 3593:     @property
 3594:     def mask(self):
 3595:         """ Current mask. """
 3596: 
 3597:         # We could try to force a reshape, but that wouldn't work in some
 3598:         # cases.
 3599:         # Return a view so that the dtype and shape cannot be changed in place
 3600:         # This still preserves nomask by identity
 3601:         return self._mask.view()
 3602: 
 3603:     @mask.setter
 3604:     def mask(self, value):
 3605:         self.__setmask__(value)
 3606: 
 3607:     @property
 3608:     def recordmask(self):
 3609:         """
 3610:         Get or set the mask of the array if it has no named fields. For
 3611:         structured arrays, returns a ndarray of booleans where entries are
 3612:         ``True`` if **all** the fields are masked, ``False`` otherwise:
 3613: 
 3614:         >>> x = np.ma.array([(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)],
 3615:         ...         mask=[(0, 0), (1, 0), (1, 1), (0, 1), (0, 0)],
 3616:         ...        dtype=[('a', int), ('b', int)])
 3617:         >>> x.recordmask
 3618:         array([False, False,  True, False, False])
 3619:         """
 3620: 
 3621:         _mask = self._mask.view(ndarray)
 3622:         if _mask.dtype.names is None:
 3623:             return _mask
 3624:         return np.all(flatten_structured_array(_mask), axis=-1)
 3625: 
 3626:     @recordmask.setter
 3627:     def recordmask(self, mask):
 3628:         raise NotImplementedError("Coming soon: setting the mask per records!")
 3629: 
 3630:     def harden_mask(self):
 3631:         """
 3632:         Force the mask to hard, preventing unmasking by assignment.
 3633: 
 3634:         Whether the mask of a masked array is hard or soft is determined by
 3635:         its `~ma.MaskedArray.hardmask` property. `harden_mask` sets
 3636:         `~ma.MaskedArray.hardmask` to ``True`` (and returns the modified
 3637:         self).
 3638: 
 3639:         See Also
 3640:         --------
 3641:         ma.MaskedArray.hardmask
 3642:         ma.MaskedArray.soften_mask
 3643: 
 3644:         """
 3645:         self._hardmask = True
 3646:         return self
 3647: 
 3648:     def soften_mask(self):
 3649:         """
 3650:         Force the mask to soft (default), allowing unmasking by assignment.
 3651: 
 3652:         Whether the mask of a masked array is hard or soft is determined by
 3653:         its `~ma.MaskedArray.hardmask` property. `soften_mask` sets
 3654:         `~ma.MaskedArray.hardmask` to ``False`` (and returns the modified
 3655:         self).
 3656: 
 3657:         See Also
 3658:         --------
 3659:         ma.MaskedArray.hardmask
 3660:         ma.MaskedArray.harden_mask
 3661: 
 3662:         """
 3663:         self._hardmask = False
 3664:         return self
 3665: 
 3666:     @property
 3667:     def hardmask(self):
 3668:         """
 3669:         Specifies whether values can be unmasked through assignments.
 3670: 
 3671:         By default, assigning definite values to masked array entries will
 3672:         unmask them.  When `hardmask` is ``True``, the mask will not change
 3673:         through assignments.
 3674: 
 3675:         See Also
 3676:         --------
 3677:         ma.MaskedArray.harden_mask
 3678:         ma.MaskedArray.soften_mask
 3679: 
 3680:         Examples
 3681:         --------
 3682:         >>> import numpy as np
 3683:         >>> x = np.arange(10)
 3684:         >>> m = np.ma.masked_array(x, x>5)
 3685:         >>> assert not m.hardmask
 3686: 
 3687:         Since `m` has a soft mask, assigning an element value unmasks that
 3688:         element:
 3689: 
 3690:         >>> m[8] = 42
 3691:         >>> m
 3692:         masked_array(data=[0, 1, 2, 3, 4, 5, --, --, 42, --],
 3693:                      mask=[False, False, False, False, False, False,
 3694:                            True, True, False, True],
 3695:                fill_value=999999)
 3696: 
 3697:         After hardening, the mask is not affected by assignments:
 3698: 
 3699:         >>> hardened = np.ma.harden_mask(m)
 3700:         >>> assert m.hardmask and hardened is m
 3701:         >>> m[:] = 23
 3702:         >>> m
 3703:         masked_array(data=[23, 23, 23, 23, 23, 23, --, --, 23, --],
 3704:                      mask=[False, False, False, False, False, False,
 3705:                            True, True, False, True],
 3706:                fill_value=999999)
 3707: 
 3708:         """
 3709:         return self._hardmask
 3710: 
 3711:     def unshare_mask(self):
 3712:         """
 3713:         Copy the mask and set the `sharedmask` flag to ``False``.
 3714: 
 3715:         Whether the mask is shared between masked arrays can be seen from
 3716:         the `sharedmask` property. `unshare_mask` ensures the mask is not
 3717:         shared. A copy of the mask is only made if it was shared.
 3718: 
 3719:         See Also
 3720:         --------
 3721:         sharedmask
 3722: 
 3723:         """
 3724:         if self._sharedmask:
 3725:             self._mask = self._mask.copy()
 3726:             self._sharedmask = False
 3727:         return self
 3728: 
 3729:     @property
 3730:     def sharedmask(self):
 3731:         """ Share status of the mask (read-only). """
 3732:         return self._sharedmask
 3733: 
 3734:     def shrink_mask(self):
 3735:         """
 3736:         Reduce a mask to nomask when possible.
 3737: 
 3738:         Parameters
 3739:         ----------
 3740:         None
 3741: 
 3742:         Returns
 3743:         -------
 3744:         result : MaskedArray
 3745:             A :class:`~ma.MaskedArray` object.
 3746: 
 3747:         Examples
 3748:         --------
 3749:         >>> import numpy as np
 3750:         >>> x = np.ma.array([[1,2 ], [3, 4]], mask=[0]*4)
 3751:         >>> x.mask
 3752:         array([[False, False],
 3753:                [False, False]])
 3754:         >>> x.shrink_mask()
 3755:         masked_array(
 3756:           data=[[1, 2],
 3757:                 [3, 4]],
 3758:           mask=False,
 3759:           fill_value=999999)
 3760:         >>> x.mask
 3761:         False
 3762: 
 3763:         """
 3764:         self._mask = _shrink_mask(self._mask)
 3765:         return self
 3766: 
 3767:     @property
 3768:     def baseclass(self):
 3769:         """ Class of the underlying data (read-only). """
 3770:         return self._baseclass
 3771: 
 3772:     def _get_data(self):
 3773:         """
 3774:         Returns the underlying data, as a view of the masked array.
 3775: 
 3776:         If the underlying data is a subclass of :class:`numpy.ndarray`, it is
 3777:         returned as such.
 3778: 
 3779:         >>> x = np.ma.array(np.matrix([[1, 2], [3, 4]]), mask=[[0, 1], [1, 0]])
 3780:         >>> x.data
 3781:         matrix([[1, 2],
 3782:                 [3, 4]])
 3783: 
 3784:         The type of the data can be accessed through the :attr:`baseclass`
 3785:         attribute.
 3786:         """
 3787:         return ndarray.view(self, self._baseclass)
 3788: 
 3789:     _data = property(fget=_get_data)
 3790:     data = property(fget=_get_data)
 3791: 
 3792:     @property
 3793:     def flat(self):
 3794:         """ Return a flat iterator, or set a flattened version of self to value. """
 3795:         return MaskedIterator(self)
 3796: 
 3797:     @flat.setter
 3798:     def flat(self, value):
 3799:         y = self.ravel()
 3800:         y[:] = value
 3801: 
 3802:     @property
 3803:     def fill_value(self):
 3804:         """
 3805:         The filling value of the masked array is a scalar. When setting, None
 3806:         will set to a default based on the data type.
 3807: 
 3808:         Examples
 3809:         --------
 3810:         >>> import numpy as np
 3811:         >>> for dt in [np.int32, np.int64, np.float64, np.complex128]:
 3812:         ...     np.ma.array([0, 1], dtype=dt).get_fill_value()
 3813:         ...
 3814:         np.int64(999999)
 3815:         np.int64(999999)
 3816:         np.float64(1e+20)
 3817:         np.complex128(1e+20+0j)
 3818: 
 3819:         >>> x = np.ma.array([0, 1.], fill_value=-np.inf)
 3820:         >>> x.fill_value
 3821:         np.float64(-inf)
 3822:         >>> x.fill_value = np.pi
 3823:         >>> x.fill_value
 3824:         np.float64(3.1415926535897931)
 3825: 
 3826:         Reset to default:
 3827: 
 3828:         >>> x.fill_value = None
 3829:         >>> x.fill_value
 3830:         np.float64(1e+20)
 3831: 
 3832:         """
 3833:         if self._fill_value is None:
 3834:             self._fill_value = _check_fill_value(None, self.dtype)
 3835: 
 3836:         # Temporary workaround to account for the fact that str and bytes
 3837:         # scalars cannot be indexed with (), whereas all other numpy
 3838:         # scalars can. See issues #7259 and #7267.
 3839:         # The if-block can be removed after #7267 has been fixed.
 3840:         if isinstance(self._fill_value, ndarray):
 3841:             return self._fill_value[()]
 3842:         return self._fill_value
 3843: 
 3844:     @fill_value.setter
 3845:     def fill_value(self, value=None):
 3846:         target = _check_fill_value(value, self.dtype)
 3847:         if not target.ndim == 0:
 3848:             # 2019-11-12, 1.18.0
 3849:             warnings.warn(
 3850:                 "Non-scalar arrays for the fill value are deprecated. Use "
 3851:                 "arrays with scalar values instead. The filled function "
 3852:                 "still supports any array as `fill_value`.",
 3853:                 DeprecationWarning, stacklevel=2)
 3854: 
 3855:         _fill_value = self._fill_value
 3856:         if _fill_value is None:
 3857:             # Create the attribute if it was undefined
 3858:             self._fill_value = target
 3859:         else:
 3860:             # Don't overwrite the attribute, just fill it (for propagation)
 3861:             _fill_value[()] = target
 3862: 
 3863:     # kept for compatibility
 3864:     get_fill_value = fill_value.fget
 3865:     set_fill_value = fill_value.fset
 3866: 
 3867:     def filled(self, fill_value=None):
 3868:         """
 3869:         Return a copy of self, with masked values filled with a given value.
 3870:         **However**, if there are no masked values to fill, self will be
 3871:         returned instead as an ndarray.
 3872: 
 3873:         Parameters
 3874:         ----------
 3875:         fill_value : array_like, optional
 3876:             The value to use for invalid entries. Can be scalar or non-scalar.
 3877:             If non-scalar, the resulting ndarray must be broadcastable over
 3878:             input array. Default is None, in which case, the `fill_value`
 3879:             attribute of the array is used instead.
 3880: 
 3881:         Returns
 3882:         -------
 3883:         filled_array : ndarray
 3884:             A copy of ``self`` with invalid entries replaced by *fill_value*
 3885:             (be it the function argument or the attribute of ``self``), or
 3886:             ``self`` itself as an ndarray if there are no invalid entries to
 3887:             be replaced.
 3888: 
 3889:         Notes
 3890:         -----
 3891:         The result is **not** a MaskedArray!
 3892: 
 3893:         Examples
 3894:         --------
 3895:         >>> import numpy as np
 3896:         >>> x = np.ma.array([1,2,3,4,5], mask=[0,0,1,0,1], fill_value=-999)
 3897:         >>> x.filled()
 3898:         array([   1,    2, -999,    4, -999])
 3899:         >>> x.filled(fill_value=1000)
 3900:         array([   1,    2, 1000,    4, 1000])
 3901:         >>> type(x.filled())
 3902:         <class 'numpy.ndarray'>
 3903: 
 3904:         Subclassing is preserved. This means that if, e.g., the data part of
 3905:         the masked array is a recarray, `filled` returns a recarray:
 3906: 
 3907:         >>> x = np.array([(-1, 2), (-3, 4)], dtype='i8,i8').view(np.recarray)
 3908:         >>> m = np.ma.array(x, mask=[(True, False), (False, True)])
 3909:         >>> m.filled()
 3910:         rec.array([(999999,      2), (    -3, 999999)],
 3911:                   dtype=[('f0', '<i8'), ('f1', '<i8')])
 3912:         """
 3913:         m = self._mask
 3914:         if m is nomask:
 3915:             return self._data
 3916: 
 3917:         if fill_value is None:
 3918:             fill_value = self.fill_value
 3919:         else:
 3920:             fill_value = _check_fill_value(fill_value, self.dtype)
 3921: 
 3922:         if self is masked_singleton:
 3923:             return np.asanyarray(fill_value)
 3924: 
 3925:         if m.dtype.names is not None:
 3926:             result = self._data.copy('K')
 3927:             _recursive_filled(result, self._mask, fill_value)
 3928:         elif not m.any():
 3929:             return self._data
 3930:         else:
 3931:             result = self._data.copy('K')
 3932:             try:
 3933:                 np.copyto(result, fill_value, where=m)
 3934:             except (TypeError, AttributeError):
 3935:                 fill_value = narray(fill_value, dtype=object)
 3936:                 d = result.astype(object)
 3937:                 result = np.choose(m, (d, fill_value))
 3938:             except IndexError:
 3939:                 # ok, if scalar
 3940:                 if self._data.shape:
 3941:                     raise
 3942:                 elif m:
 3943:                     result = np.array(fill_value, dtype=self.dtype)
 3944:                 else:
 3945:                     result = self._data
 3946:         return result
 3947: 
 3948:     def compressed(self):
 3949:         """
 3950:         Return all the non-masked data as a 1-D array.
 3951: 
 3952:         Returns
 3953:         -------
 3954:         data : ndarray
 3955:             A new `ndarray` holding the non-masked data is returned.
 3956: 
 3957:         Notes
 3958:         -----
 3959:         The result is **not** a MaskedArray!
 3960: 
 3961:         Examples
 3962:         --------
 3963:         >>> import numpy as np
 3964:         >>> x = np.ma.array(np.arange(5), mask=[0]*2 + [1]*3)
 3965:         >>> x.compressed()
 3966:         array([0, 1])
 3967:         >>> type(x.compressed())
 3968:         <class 'numpy.ndarray'>
 3969: 
 3970:         N-D arrays are compressed to 1-D.
 3971: 
 3972:         >>> arr = [[1, 2], [3, 4]]
 3973:         >>> mask = [[1, 0], [0, 1]]
 3974:         >>> x = np.ma.array(arr, mask=mask)
 3975:         >>> x.compressed()
 3976:         array([2, 3])
 3977: 
 3978:         """
 3979:         data = ndarray.ravel(self._data)
 3980:         if self._mask is not nomask:
 3981:             data = data.compress(np.logical_not(ndarray.ravel(self._mask)))
 3982:         return data
 3983: 
 3984:     def compress(self, condition, axis=None, out=None):
 3985:         """
 3986:         Return `a` where condition is ``True``.
 3987: 
 3988:         If condition is a `~ma.MaskedArray`, missing values are considered
 3989:         as ``False``.
 3990: 
 3991:         Parameters
 3992:         ----------
 3993:         condition : var
 3994:             Boolean 1-d array selecting which entries to return. If len(condition)
 3995:             is less than the size of a along the axis, then output is truncated
 3996:             to length of condition array.
 3997:         axis : {None, int}, optional
 3998:             Axis along which the operation must be performed.
 3999:         out : {None, ndarray}, optional
 4000:             Alternative output array in which to place the result. It must have
 4001:             the same shape as the expected output but the type will be cast if
 4002:             necessary.
 4003: 
 4004:         Returns
 4005:         -------
 4006:         result : MaskedArray
 4007:             A :class:`~ma.MaskedArray` object.
 4008: 
 4009:         Notes
 4010:         -----
 4011:         Please note the difference with :meth:`compressed` !
 4012:         The output of :meth:`compress` has a mask, the output of
 4013:         :meth:`compressed` does not.
 4014: 
 4015:         Examples
 4016:         --------
 4017:         >>> import numpy as np
 4018:         >>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
 4019:         >>> x
 4020:         masked_array(
 4021:           data=[[1, --, 3],
 4022:                 [--, 5, --],
 4023:                 [7, --, 9]],
 4024:           mask=[[False,  True, False],
 4025:                 [ True, False,  True],
 4026:                 [False,  True, False]],
 4027:           fill_value=999999)
 4028:         >>> x.compress([1, 0, 1])
 4029:         masked_array(data=[1, 3],
 4030:                      mask=[False, False],
 4031:                fill_value=999999)
 4032: 
 4033:         >>> x.compress([1, 0, 1], axis=1)
 4034:         masked_array(
 4035:           data=[[1, 3],
 4036:                 [--, --],
 4037:                 [7, 9]],
 4038:           mask=[[False, False],
 4039:                 [ True,  True],
 4040:                 [False, False]],
 4041:           fill_value=999999)
 4042: 
 4043:         """
 4044:         # Get the basic components
 4045:         (_data, _mask) = (self._data, self._mask)
 4046: 
 4047:         # Force the condition to a regular ndarray and forget the missing
 4048:         # values.
 4049:         condition = np.asarray(condition)
 4050: 
 4051:         _new = _data.compress(condition, axis=axis, out=out).view(type(self))
 4052:         _new._update_from(self)
 4053:         if _mask is not nomask:
 4054:             _new._mask = _mask.compress(condition, axis=axis)
 4055:         return _new
 4056: 
 4057:     def _insert_masked_print(self):
 4058:         """
 4059:         Replace masked values with masked_print_option, casting all innermost
 4060:         dtypes to object.
 4061:         """
 4062:         if masked_print_option.enabled():
 4063:             mask = self._mask
 4064:             if mask is nomask:
 4065:                 res = self._data
 4066:             else:
 4067:                 # convert to object array to make filled work
 4068:                 data = self._data
 4069:                 # For big arrays, to avoid a costly conversion to the
 4070:                 # object dtype, extract the corners before the conversion.
 4071:                 print_width = (self._print_width if self.ndim > 1
 4072:                                else self._print_width_1d)
 4073:                 for axis in range(self.ndim):
 4074:                     if data.shape[axis] > print_width:
 4075:                         ind = print_width // 2
 4076:                         arr = np.split(data, (ind, -ind), axis=axis)
 4077:                         data = np.concatenate((arr[0], arr[2]), axis=axis)
 4078:                         arr = np.split(mask, (ind, -ind), axis=axis)
 4079:                         mask = np.concatenate((arr[0], arr[2]), axis=axis)
 4080: 
 4081:                 rdtype = _replace_dtype_fields(self.dtype, "O")
 4082:                 res = data.astype(rdtype)
 4083:                 _recursive_printoption(res, mask, masked_print_option)
 4084:         else:
 4085:             res = self.filled(self.fill_value)
 4086:         return res
 4087: 
 4088:     def __str__(self):
 4089:         return str(self._insert_masked_print())
 4090: 
 4091:     def __repr__(self):
 4092:         """
 4093:         Literal string representation.
 4094: 
 4095:         """
 4096:         if self._baseclass is np.ndarray:
 4097:             name = 'array'
 4098:         else:
 4099:             name = self._baseclass.__name__
 4100: 
 4101:         # 2016-11-19: Demoted to legacy format
 4102:         if np._core.arrayprint._get_legacy_print_mode() <= 113:
 4103:             is_long = self.ndim > 1
 4104:             parameters = {
 4105:                 'name': name,
 4106:                 'nlen': " " * len(name),
 4107:                 'data': str(self),
 4108:                 'mask': str(self._mask),
 4109:                 'fill': str(self.fill_value),
 4110:                 'dtype': str(self.dtype)
 4111:             }
 4112:             is_structured = bool(self.dtype.names)
 4113:             key = '{}_{}'.format(
 4114:                 'long' if is_long else 'short',
 4115:                 'flx' if is_structured else 'std'
 4116:             )
 4117:             return _legacy_print_templates[key] % parameters
 4118: 
 4119:         prefix = f"masked_{name}("
 4120: 
 4121:         dtype_needed = (
 4122:             not np._core.arrayprint.dtype_is_implied(self.dtype) or
 4123:             np.all(self.mask) or
 4124:             self.size == 0
 4125:         )
 4126: 
 4127:         # determine which keyword args need to be shown
 4128:         keys = ['data', 'mask', 'fill_value']
 4129:         if dtype_needed:
 4130:             keys.append('dtype')
 4131: 
 4132:         # array has only one row (non-column)
 4133:         is_one_row = builtins.all(dim == 1 for dim in self.shape[:-1])
 4134: 
 4135:         # choose what to indent each keyword with
 4136:         min_indent = 2
 4137:         if is_one_row:
 4138:             # first key on the same line as the type, remaining keys
 4139:             # aligned by equals
 4140:             indents = {}
 4141:             indents[keys[0]] = prefix
 4142:             for k in keys[1:]:
 4143:                 n = builtins.max(min_indent, len(prefix + keys[0]) - len(k))
 4144:                 indents[k] = ' ' * n
 4145:             prefix = ''  # absorbed into the first indent
 4146:         else:
 4147:             # each key on its own line, indented by two spaces
 4148:             indents = dict.fromkeys(keys, ' ' * min_indent)
 4149:             prefix = prefix + '\n'  # first key on the next line
 4150: 
 4151:         # format the field values
 4152:         reprs = {}
 4153:         reprs['data'] = np.array2string(
 4154:             self._insert_masked_print(),
 4155:             separator=", ",
 4156:             prefix=indents['data'] + 'data=',
 4157:             suffix=',')
 4158:         reprs['mask'] = np.array2string(
 4159:             self._mask,
 4160:             separator=", ",
 4161:             prefix=indents['mask'] + 'mask=',
 4162:             suffix=',')
 4163: 
 4164:         if self._fill_value is None:
 4165:             self.fill_value  # initialize fill_value  # noqa: B018
 4166: 
 4167:         if (self._fill_value.dtype.kind in ("S", "U")
 4168:                 and self.dtype.kind == self._fill_value.dtype.kind):
 4169:             # Allow strings: "N/A" has length 3 so would mismatch.
 4170:             fill_repr = repr(self.fill_value.item())
 4171:         elif self._fill_value.dtype == self.dtype and not self.dtype == object:
 4172:             # Guess that it is OK to use the string as item repr.  To really
 4173:             # fix this, it needs new logic (shared with structured scalars)
 4174:             fill_repr = str(self.fill_value)
 4175:         else:
 4176:             fill_repr = repr(self.fill_value)
 4177: 
 4178:         reprs['fill_value'] = fill_repr
 4179:         if dtype_needed:
 4180:             reprs['dtype'] = np._core.arrayprint.dtype_short_repr(self.dtype)
 4181: 
 4182:         # join keys with values and indentations
 4183:         result = ',\n'.join(
 4184:             f'{indents[k]}{k}={reprs[k]}'
 4185:             for k in keys
 4186:         )
 4187:         return prefix + result + ')'
 4188: 
 4189:     def _delegate_binop(self, other):
 4190:         # This emulates the logic in
 4191:         #     private/binop_override.h:forward_binop_should_defer
 4192:         if isinstance(other, type(self)):
 4193:             return False
 4194:         array_ufunc = getattr(other, "__array_ufunc__", False)
 4195:         if array_ufunc is False:
 4196:             other_priority = getattr(other, "__array_priority__", -1000000)
 4197:             return self.__array_priority__ < other_priority
 4198:         else:
 4199:             # If array_ufunc is not None, it will be called inside the ufunc;
 4200:             # None explicitly tells us to not call the ufunc, i.e., defer.
 4201:             return array_ufunc is None
 4202: 
 4203:     def _comparison(self, other, compare):
 4204:         """Compare self with other using operator.eq or operator.ne.
 4205: 
 4206:         When either of the elements is masked, the result is masked as well,
 4207:         but the underlying boolean data are still set, with self and other
 4208:         considered equal if both are masked, and unequal otherwise.
 4209: 
 4210:         For structured arrays, all fields are combined, with masked values
 4211:         ignored. The result is masked if all fields were masked, with self
 4212:         and other considered equal only if both were fully masked.
 4213:         """
 4214:         omask = getmask(other)
 4215:         smask = self.mask
 4216:         mask = mask_or(smask, omask, copy=True)
 4217: 
 4218:         odata = getdata(other)
 4219:         if mask.dtype.names is not None:
 4220:             # only == and != are reasonably defined for structured dtypes,
 4221:             # so give up early for all other comparisons:
 4222:             if compare not in (operator.eq, operator.ne):
 4223:                 return NotImplemented
 4224:             # For possibly masked structured arrays we need to be careful,
 4225:             # since the standard structured array comparison will use all
 4226:             # fields, masked or not. To avoid masked fields influencing the
 4227:             # outcome, we set all masked fields in self to other, so they'll
 4228:             # count as equal.  To prepare, we ensure we have the right shape.
 4229:             broadcast_shape = np.broadcast(self, odata).shape
 4230:             sbroadcast = np.broadcast_to(self, broadcast_shape, subok=True)
 4231:             sbroadcast._mask = mask
 4232:             sdata = sbroadcast.filled(odata)
 4233:             # Now take care of the mask; the merged mask should have an item
 4234:             # masked if all fields were masked (in one and/or other).
 4235:             mask = (mask == np.ones((), mask.dtype))
 4236:             # Ensure we can compare masks below if other was not masked.
 4237:             if omask is np.False_:
 4238:                 omask = np.zeros((), smask.dtype)
 4239: 
 4240:         else:
 4241:             # For regular arrays, just use the data as they come.
 4242:             sdata = self.data
 4243: 
 4244:         check = compare(sdata, odata)
 4245: 
 4246:         if isinstance(check, (np.bool, bool)):
 4247:             return masked if mask else check
 4248: 
 4249:         if mask is not nomask:
 4250:             if compare in (operator.eq, operator.ne):
 4251:                 # Adjust elements that were masked, which should be treated
 4252:                 # as equal if masked in both, unequal if masked in one.
 4253:                 # Note that this works automatically for structured arrays too.
 4254:                 # Ignore this for operations other than `==` and `!=`
 4255:                 check = np.where(mask, compare(smask, omask), check)
 4256: 
 4257:             if mask.shape != check.shape:
 4258:                 # Guarantee consistency of the shape, making a copy since the
 4259:                 # the mask may need to get written to later.
 4260:                 mask = np.broadcast_to(mask, check.shape).copy()
 4261: 
 4262:         check = check.view(type(self))
 4263:         check._update_from(self)
 4264:         check._mask = mask
 4265: 
 4266:         # Cast fill value to np.bool if needed. If it cannot be cast, the
 4267:         # default boolean fill value is used.
 4268:         if check._fill_value is not None:
 4269:             try:
 4270:                 fill = _check_fill_value(check._fill_value, np.bool)
 4271:             except (TypeError, ValueError):
 4272:                 fill = _check_fill_value(None, np.bool)
 4273:             check._fill_value = fill
 4274: 
 4275:         return check
 4276: 
 4277:     def __eq__(self, other):
 4278:         """Check whether other equals self elementwise.
 4279: 
 4280:         When either of the elements is masked, the result is masked as well,
 4281:         but the underlying boolean data are still set, with self and other
 4282:         considered equal if both are masked, and unequal otherwise.
 4283: 
 4284:         For structured arrays, all fields are combined, with masked values
 4285:         ignored. The result is masked if all fields were masked, with self
 4286:         and other considered equal only if both were fully masked.
 4287:         """
 4288:         return self._comparison(other, operator.eq)
 4289: 
 4290:     def __ne__(self, other):
 4291:         """Check whether other does not equal self elementwise.
 4292: 
 4293:         When either of the elements is masked, the result is masked as well,
 4294:         but the underlying boolean data are still set, with self and other
 4295:         considered equal if both are masked, and unequal otherwise.
 4296: 
 4297:         For structured arrays, all fields are combined, with masked values
 4298:         ignored. The result is masked if all fields were masked, with self
 4299:         and other considered equal only if both were fully masked.
 4300:         """
 4301:         return self._comparison(other, operator.ne)
 4302: 
 4303:     # All other comparisons:
 4304:     def __le__(self, other):
 4305:         return self._comparison(other, operator.le)
 4306: 
 4307:     def __lt__(self, other):
 4308:         return self._comparison(other, operator.lt)
 4309: 
 4310:     def __ge__(self, other):
 4311:         return self._comparison(other, operator.ge)
 4312: 
 4313:     def __gt__(self, other):
 4314:         return self._comparison(other, operator.gt)
 4315: 
 4316:     def __add__(self, other):
 4317:         """
 4318:         Add self to other, and return a new masked array.
 4319: 
 4320:         """
 4321:         if self._delegate_binop(other):
 4322:             return NotImplemented
 4323:         return add(self, other)
 4324: 
 4325:     def __radd__(self, other):
 4326:         """
 4327:         Add other to self, and return a new masked array.
 4328: 
 4329:         """
 4330:         # In analogy with __rsub__ and __rdiv__, use original order:
 4331:         # we get here from `other + self`.
 4332:         return add(other, self)
 4333: 
 4334:     def __sub__(self, other):
 4335:         """
 4336:         Subtract other from self, and return a new masked array.
 4337: 
 4338:         """
 4339:         if self._delegate_binop(other):
 4340:             return NotImplemented
 4341:         return subtract(self, other)
 4342: 
 4343:     def __rsub__(self, other):
 4344:         """
 4345:         Subtract self from other, and return a new masked array.
 4346: 
 4347:         """
 4348:         return subtract(other, self)
 4349: 
 4350:     def __mul__(self, other):
 4351:         "Multiply self by other, and return a new masked array."
 4352:         if self._delegate_binop(other):
 4353:             return NotImplemented
 4354:         return multiply(self, other)
 4355: 
 4356:     def __rmul__(self, other):
 4357:         """
 4358:         Multiply other by self, and return a new masked array.
 4359: 
 4360:         """
 4361:         # In analogy with __rsub__ and __rdiv__, use original order:
 4362:         # we get here from `other * self`.
 4363:         return multiply(other, self)
 4364: 
 4365:     def __truediv__(self, other):
 4366:         """
 4367:         Divide other into self, and return a new masked array.
 4368: 
 4369:         """
 4370:         if self._delegate_binop(other):
 4371:             return NotImplemented
 4372:         return true_divide(self, other)
 4373: 
 4374:     def __rtruediv__(self, other):
 4375:         """
 4376:         Divide self into other, and return a new masked array.
 4377: 
 4378:         """
 4379:         return true_divide(other, self)
 4380: 
 4381:     def __floordiv__(self, other):
 4382:         """
 4383:         Divide other into self, and return a new masked array.
 4384: 
 4385:         """
 4386:         if self._delegate_binop(other):
 4387:             return NotImplemented
 4388:         return floor_divide(self, other)
 4389: 
 4390:     def __rfloordiv__(self, other):
 4391:         """
 4392:         Divide self into other, and return a new masked array.
 4393: 
 4394:         """
 4395:         return floor_divide(other, self)
 4396: 
 4397:     def __pow__(self, other):
 4398:         """
 4399:         Raise self to the power other, masking the potential NaNs/Infs
 4400: 
 4401:         """
 4402:         if self._delegate_binop(other):
 4403:             return NotImplemented
 4404:         return power(self, other)
 4405: 
 4406:     def __rpow__(self, other):
 4407:         """
 4408:         Raise other to the power self, masking the potential NaNs/Infs
 4409: 
 4410:         """
 4411:         return power(other, self)
 4412: 
 4413:     def __iadd__(self, other):
 4414:         """
 4415:         Add other to self in-place.
 4416: 
 4417:         """
 4418:         m = getmask(other)
 4419:         if self._mask is nomask:
 4420:             if m is not nomask and m.any():
 4421:                 self._mask = make_mask_none(self.shape, self.dtype)
 4422:                 self._mask += m
 4423:         elif m is not nomask:
 4424:             self._mask += m
 4425:         other_data = getdata(other)
 4426:         other_data = np.where(self._mask, other_data.dtype.type(0), other_data)
 4427:         self._data.__iadd__(other_data)
 4428:         return self
 4429: 
 4430:     def __isub__(self, other):
 4431:         """
 4432:         Subtract other from self in-place.
 4433: 
 4434:         """
 4435:         m = getmask(other)
 4436:         if self._mask is nomask:
 4437:             if m is not nomask and m.any():
 4438:                 self._mask = make_mask_none(self.shape, self.dtype)
 4439:                 self._mask += m
 4440:         elif m is not nomask:
 4441:             self._mask += m
 4442:         other_data = getdata(other)
 4443:         other_data = np.where(self._mask, other_data.dtype.type(0), other_data)
 4444:         self._data.__isub__(other_data)
 4445:         return self
 4446: 
 4447:     def __imul__(self, other):
 4448:         """
 4449:         Multiply self by other in-place.
 4450: 
 4451:         """
 4452:         m = getmask(other)
 4453:         if self._mask is nomask:
 4454:             if m is not nomask and m.any():
 4455:                 self._mask = make_mask_none(self.shape, self.dtype)
 4456:                 self._mask += m
 4457:         elif m is not nomask:
 4458:             self._mask += m
 4459:         other_data = getdata(other)
 4460:         other_data = np.where(self._mask, other_data.dtype.type(1), other_data)
 4461:         self._data.__imul__(other_data)
 4462:         return self
 4463: 
 4464:     def __ifloordiv__(self, other):
 4465:         """
 4466:         Floor divide self by other in-place.
 4467: 
 4468:         """
 4469:         other_data = getdata(other)
 4470:         dom_mask = _DomainSafeDivide().__call__(self._data, other_data)
 4471:         other_mask = getmask(other)
 4472:         new_mask = mask_or(other_mask, dom_mask)
 4473:         # The following 3 lines control the domain filling
 4474:         if dom_mask.any():
 4475:             (_, fval) = ufunc_fills[np.floor_divide]
 4476:             other_data = np.where(
 4477:                     dom_mask, other_data.dtype.type(fval), other_data)
 4478:         self._mask |= new_mask
 4479:         other_data = np.where(self._mask, other_data.dtype.type(1), other_data)
 4480:         self._data.__ifloordiv__(other_data)
 4481:         return self
 4482: 
 4483:     def __itruediv__(self, other):
 4484:         """
 4485:         True divide self by other in-place.
 4486: 
 4487:         """
 4488:         other_data = getdata(other)
 4489:         dom_mask = _DomainSafeDivide().__call__(self._data, other_data)
 4490:         other_mask = getmask(other)
 4491:         new_mask = mask_or(other_mask, dom_mask)
 4492:         # The following 3 lines control the domain filling
 4493:         if dom_mask.any():
 4494:             (_, fval) = ufunc_fills[np.true_divide]
 4495:             other_data = np.where(
 4496:                     dom_mask, other_data.dtype.type(fval), other_data)
 4497:         self._mask |= new_mask
 4498:         other_data = np.where(self._mask, other_data.dtype.type(1), other_data)
 4499:         self._data.__itruediv__(other_data)
 4500:         return self
 4501: 
 4502:     def __ipow__(self, other):
 4503:         """
 4504:         Raise self to the power other, in place.
 4505: 
 4506:         """
 4507:         other_data = getdata(other)
 4508:         other_data = np.where(self._mask, other_data.dtype.type(1), other_data)
 4509:         other_mask = getmask(other)
 4510:         with np.errstate(divide='ignore', invalid='ignore'):
 4511:             self._data.__ipow__(other_data)
 4512:         invalid = np.logical_not(np.isfinite(self._data))
 4513:         if invalid.any():
 4514:             if self._mask is not nomask:
 4515:                 self._mask |= invalid
 4516:             else:
 4517:                 self._mask = invalid
 4518:             np.copyto(self._data, self.fill_value, where=invalid)
 4519:         new_mask = mask_or(other_mask, invalid)
 4520:         self._mask = mask_or(self._mask, new_mask)
 4521:         return self
 4522: 
 4523:     def __float__(self):
 4524:         """
 4525:         Convert to float.
 4526: 
 4527:         """
 4528:         if self.size > 1:
 4529:             raise TypeError("Only length-1 arrays can be converted "
 4530:                             "to Python scalars")
 4531:         elif self._mask:
 4532:             warnings.warn("Warning: converting a masked element to nan.", stacklevel=2)
 4533:             return np.nan
 4534:         return float(self.item())
 4535: 
 4536:     def __int__(self):
 4537:         """
 4538:         Convert to int.
 4539: 
 4540:         """
 4541:         if self.size > 1:
 4542:             raise TypeError("Only length-1 arrays can be converted "
 4543:                             "to Python scalars")
 4544:         elif self._mask:
 4545:             raise MaskError('Cannot convert masked element to a Python int.')
 4546:         return int(self.item())
 4547: 
 4548:     @property
 4549:     def imag(self):
 4550:         """
 4551:         The imaginary part of the masked array.
 4552: 
 4553:         This property is a view on the imaginary part of this `MaskedArray`.
 4554: 
 4555:         See Also
 4556:         --------
 4557:         real
 4558: 
 4559:         Examples
 4560:         --------
 4561:         >>> import numpy as np
 4562:         >>> x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])
 4563:         >>> x.imag
 4564:         masked_array(data=[1.0, --, 1.6],
 4565:                      mask=[False,  True, False],
 4566:                fill_value=1e+20)
 4567: 
 4568:         """
 4569:         result = self._data.imag.view(type(self))
 4570:         result.__setmask__(self._mask)
 4571:         return result
 4572: 
 4573:     # kept for compatibility
 4574:     get_imag = imag.fget
 4575: 
 4576:     @property
 4577:     def real(self):
 4578:         """
 4579:         The real part of the masked array.
 4580: 
 4581:         This property is a view on the real part of this `MaskedArray`.
 4582: 
 4583:         See Also
 4584:         --------
 4585:         imag
 4586: 
 4587:         Examples
 4588:         --------
 4589:         >>> import numpy as np
 4590:         >>> x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])
 4591:         >>> x.real
 4592:         masked_array(data=[1.0, --, 3.45],
 4593:                      mask=[False,  True, False],
 4594:                fill_value=1e+20)
 4595: 
 4596:         """
 4597:         result = self._data.real.view(type(self))
 4598:         result.__setmask__(self._mask)
 4599:         return result
 4600: 
 4601:     # kept for compatibility
 4602:     get_real = real.fget
 4603: 
 4604:     def count(self, axis=None, keepdims=np._NoValue):
 4605:         """
 4606:         Count the non-masked elements of the array along the given axis.
 4607: 
 4608:         Parameters
 4609:         ----------
 4610:         axis : None or int or tuple of ints, optional
 4611:             Axis or axes along which the count is performed.
 4612:             The default, None, performs the count over all
 4613:             the dimensions of the input array. `axis` may be negative, in
 4614:             which case it counts from the last to the first axis.
 4615:             If this is a tuple of ints, the count is performed on multiple
 4616:             axes, instead of a single axis or all the axes as before.
 4617:         keepdims : bool, optional
 4618:             If this is set to True, the axes which are reduced are left
 4619:             in the result as dimensions with size one. With this option,
 4620:             the result will broadcast correctly against the array.
 4621: 
 4622:         Returns
 4623:         -------
 4624:         result : ndarray or scalar
 4625:             An array with the same shape as the input array, with the specified
 4626:             axis removed. If the array is a 0-d array, or if `axis` is None, a
 4627:             scalar is returned.
 4628: 
 4629:         See Also
 4630:         --------
 4631:         ma.count_masked : Count masked elements in array or along a given axis.
 4632: 
 4633:         Examples
 4634:         --------
 4635:         >>> import numpy.ma as ma
 4636:         >>> a = ma.arange(6).reshape((2, 3))
 4637:         >>> a[1, :] = ma.masked
 4638:         >>> a
 4639:         masked_array(
 4640:           data=[[0, 1, 2],
 4641:                 [--, --, --]],
 4642:           mask=[[False, False, False],
 4643:                 [ True,  True,  True]],
 4644:           fill_value=999999)
 4645:         >>> a.count()
 4646:         3
 4647: 
 4648:         When the `axis` keyword is specified an array of appropriate size is
 4649:         returned.
 4650: 
 4651:         >>> a.count(axis=0)
 4652:         array([1, 1, 1])
 4653:         >>> a.count(axis=1)
 4654:         array([3, 0])
 4655: 
 4656:         """
 4657:         kwargs = {} if keepdims is np._NoValue else {'keepdims': keepdims}
 4658: 
 4659:         m = self._mask
 4660:         # special case for matrices (we assume no other subclasses modify
 4661:         # their dimensions)
 4662:         if isinstance(self.data, np.matrix):
 4663:             if m is nomask:
 4664:                 m = np.zeros(self.shape, dtype=np.bool)
 4665:             m = m.view(type(self.data))
 4666: 
 4667:         if m is nomask:
 4668:             # compare to _count_reduce_items in _methods.py
 4669: 
 4670:             if self.shape == ():
 4671:                 if axis not in (None, 0):
 4672:                     raise np.exceptions.AxisError(axis=axis, ndim=self.ndim)
 4673:                 return 1
 4674:             elif axis is None:
 4675:                 if kwargs.get('keepdims'):
 4676:                     return np.array(self.size, dtype=np.intp, ndmin=self.ndim)
 4677:                 return self.size
 4678: 
 4679:             axes = normalize_axis_tuple(axis, self.ndim)
 4680:             items = 1
 4681:             for ax in axes:
 4682:                 items *= self.shape[ax]
 4683: 
 4684:             if kwargs.get('keepdims'):
 4685:                 out_dims = list(self.shape)
 4686:                 for a in axes:
 4687:                     out_dims[a] = 1
 4688:             else:
 4689:                 out_dims = [d for n, d in enumerate(self.shape)
 4690:                             if n not in axes]
 4691:             # make sure to return a 0-d array if axis is supplied
 4692:             return np.full(out_dims, items, dtype=np.intp)
 4693: 
 4694:         # take care of the masked singleton
 4695:         if self is masked:
 4696:             return 0
 4697: 
 4698:         return (~m).sum(axis=axis, dtype=np.intp, **kwargs)
 4699: 
 4700:     def ravel(self, order='C'):
 4701:         """
 4702:         Returns a 1D version of self, as a view.
 4703: 
 4704:         Parameters
 4705:         ----------
 4706:         order : {'C', 'F', 'A', 'K'}, optional
 4707:             The elements of `a` are read using this index order. 'C' means to
 4708:             index the elements in C-like order, with the last axis index
 4709:             changing fastest, back to the first axis index changing slowest.
 4710:             'F' means to index the elements in Fortran-like index order, with
 4711:             the first index changing fastest, and the last index changing
 4712:             slowest. Note that the 'C' and 'F' options take no account of the
 4713:             memory layout of the underlying array, and only refer to the order
 4714:             of axis indexing.  'A' means to read the elements in Fortran-like
 4715:             index order if `m` is Fortran *contiguous* in memory, C-like order
 4716:             otherwise.  'K' means to read the elements in the order they occur
 4717:             in memory, except for reversing the data when strides are negative.
 4718:             By default, 'C' index order is used.
 4719:             (Masked arrays currently use 'A' on the data when 'K' is passed.)
 4720: 
 4721:         Returns
 4722:         -------
 4723:         MaskedArray
 4724:             Output view is of shape ``(self.size,)`` (or
 4725:             ``(np.ma.product(self.shape),)``).
 4726: 
 4727:         Examples
 4728:         --------
 4729:         >>> import numpy as np
 4730:         >>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
 4731:         >>> x
 4732:         masked_array(
 4733:           data=[[1, --, 3],
 4734:                 [--, 5, --],
 4735:                 [7, --, 9]],
 4736:           mask=[[False,  True, False],
 4737:                 [ True, False,  True],
 4738:                 [False,  True, False]],
 4739:           fill_value=999999)
 4740:         >>> x.ravel()
 4741:         masked_array(data=[1, --, 3, --, 5, --, 7, --, 9],
 4742:                      mask=[False,  True, False,  True, False,  True, False,  True,
 4743:                            False],
 4744:                fill_value=999999)
 4745: 
 4746:         """
 4747:         # The order of _data and _mask could be different (it shouldn't be
 4748:         # normally).  Passing order `K` or `A` would be incorrect.
 4749:         # So we ignore the mask memory order.
 4750:         # TODO: We don't actually support K, so use A instead.  We could
 4751:         #       try to guess this correct by sorting strides or deprecate.
 4752:         if order in "kKaA":
 4753:             order = "F" if self._data.flags.fnc else "C"
 4754:         r = ndarray.ravel(self._data, order=order).view(type(self))
 4755:         r._update_from(self)
 4756:         if self._mask is not nomask:
 4757:             r._mask = ndarray.ravel(self._mask, order=order).reshape(r.shape)
 4758:         else:
 4759:             r._mask = nomask
 4760:         return r
 4761: 
 4762:     def reshape(self, *s, **kwargs):
 4763:         """
 4764:         Give a new shape to the array without changing its data.
 4765: 
 4766:         Returns a masked array containing the same data, but with a new shape.
 4767:         The result is a view on the original array; if this is not possible, a
 4768:         ValueError is raised.
 4769: 
 4770:         Parameters
 4771:         ----------
 4772:         shape : int or tuple of ints
 4773:             The new shape should be compatible with the original shape. If an
 4774:             integer is supplied, then the result will be a 1-D array of that
 4775:             length.
 4776:         order : {'C', 'F'}, optional
 4777:             Determines whether the array data should be viewed as in C
 4778:             (row-major) or FORTRAN (column-major) order.
 4779: 
 4780:         Returns
 4781:         -------
 4782:         reshaped_array : array
 4783:             A new view on the array.
 4784: 
 4785:         See Also
 4786:         --------
 4787:         reshape : Equivalent function in the masked array module.
 4788:         numpy.ndarray.reshape : Equivalent method on ndarray object.
 4789:         numpy.reshape : Equivalent function in the NumPy module.
 4790: 
 4791:         Notes
 4792:         -----
 4793:         The reshaping operation cannot guarantee that a copy will not be made,
 4794:         to modify the shape in place, use ``a.shape = s``
 4795: 
 4796:         Examples
 4797:         --------
 4798:         >>> import numpy as np
 4799:         >>> x = np.ma.array([[1,2],[3,4]], mask=[1,0,0,1])
 4800:         >>> x
 4801:         masked_array(
 4802:           data=[[--, 2],
 4803:                 [3, --]],
 4804:           mask=[[ True, False],
 4805:                 [False,  True]],
 4806:           fill_value=999999)
 4807:         >>> x = x.reshape((4,1))
 4808:         >>> x
 4809:         masked_array(
 4810:           data=[[--],
 4811:                 [2],
 4812:                 [3],
 4813:                 [--]],
 4814:           mask=[[ True],
 4815:                 [False],
 4816:                 [False],
 4817:                 [ True]],
 4818:           fill_value=999999)
 4819: 
 4820:         """
 4821:         kwargs.update(order=kwargs.get('order', 'C'))
 4822:         result = self._data.reshape(*s, **kwargs).view(type(self))
 4823:         result._update_from(self)
 4824:         mask = self._mask
 4825:         if mask is not nomask:
 4826:             result._mask = mask.reshape(*s, **kwargs)
 4827:         return result
 4828: 
 4829:     def resize(self, newshape, refcheck=True, order=False):
 4830:         """
 4831:         .. warning::
 4832: 
 4833:             This method does nothing, except raise a ValueError exception. A
 4834:             masked array does not own its data and therefore cannot safely be
 4835:             resized in place. Use the `numpy.ma.resize` function instead.
 4836: 
 4837:         This method is difficult to implement safely and may be deprecated in
 4838:         future releases of NumPy.
 4839: 
 4840:         """
 4841:         # Note : the 'order' keyword looks broken, let's just drop it
 4842:         errmsg = "A masked array does not own its data "\
 4843:                  "and therefore cannot be resized.\n" \
 4844:                  "Use the numpy.ma.resize function instead."
 4845:         raise ValueError(errmsg)
 4846: 
 4847:     def put(self, indices, values, mode='raise'):
 4848:         """
 4849:         Set storage-indexed locations to corresponding values.
 4850: 
 4851:         Sets self._data.flat[n] = values[n] for each n in indices.
 4852:         If `values` is shorter than `indices` then it will repeat.
 4853:         If `values` has some masked values, the initial mask is updated
 4854:         in consequence, else the corresponding values are unmasked.
 4855: 
 4856:         Parameters
 4857:         ----------
 4858:         indices : 1-D array_like
 4859:             Target indices, interpreted as integers.
 4860:         values : array_like
 4861:             Values to place in self._data copy at target indices.
 4862:         mode : {'raise', 'wrap', 'clip'}, optional
 4863:             Specifies how out-of-bounds indices will behave.
 4864:             'raise' : raise an error.
 4865:             'wrap' : wrap around.
 4866:             'clip' : clip to the range.
 4867: 
 4868:         Notes
 4869:         -----
 4870:         `values` can be a scalar or length 1 array.
 4871: 
 4872:         Examples
 4873:         --------
 4874:         >>> import numpy as np
 4875:         >>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
 4876:         >>> x
 4877:         masked_array(
 4878:           data=[[1, --, 3],
 4879:                 [--, 5, --],
 4880:                 [7, --, 9]],
 4881:           mask=[[False,  True, False],
 4882:                 [ True, False,  True],
 4883:                 [False,  True, False]],
 4884:           fill_value=999999)
 4885:         >>> x.put([0,4,8],[10,20,30])
 4886:         >>> x
 4887:         masked_array(
 4888:           data=[[10, --, 3],
 4889:                 [--, 20, --],
 4890:                 [7, --, 30]],
 4891:           mask=[[False,  True, False],
 4892:                 [ True, False,  True],
 4893:                 [False,  True, False]],
 4894:           fill_value=999999)
 4895: 
 4896:         >>> x.put(4,999)
 4897:         >>> x
 4898:         masked_array(
 4899:           data=[[10, --, 3],
 4900:                 [--, 999, --],
 4901:                 [7, --, 30]],
 4902:           mask=[[False,  True, False],
 4903:                 [ True, False,  True],
 4904:                 [False,  True, False]],
 4905:           fill_value=999999)
 4906: 
 4907:         """
 4908:         # Hard mask: Get rid of the values/indices that fall on masked data
 4909:         if self._hardmask and self._mask is not nomask:
 4910:             mask = self._mask[indices]
 4911:             indices = narray(indices, copy=None)
 4912:             values = narray(values, copy=None, subok=True)
 4913:             values.resize(indices.shape)
 4914:             indices = indices[~mask]
 4915:             values = values[~mask]
 4916: 
 4917:         self._data.put(indices, values, mode=mode)
 4918: 
 4919:         # short circuit if neither self nor values are masked
 4920:         if self._mask is nomask and getmask(values) is nomask:
 4921:             return
 4922: 
 4923:         m = getmaskarray(self)
 4924: 
 4925:         if getmask(values) is nomask:
 4926:             m.put(indices, False, mode=mode)
 4927:         else:
 4928:             m.put(indices, values._mask, mode=mode)
 4929:         m = make_mask(m, copy=False, shrink=True)
 4930:         self._mask = m
 4931:         return
 4932: 
 4933:     def ids(self):
 4934:         """
 4935:         Return the addresses of the data and mask areas.
 4936: 
 4937:         Parameters
 4938:         ----------
 4939:         None
 4940: 
 4941:         Examples
 4942:         --------
 4943:         >>> import numpy as np
 4944:         >>> x = np.ma.array([1, 2, 3], mask=[0, 1, 1])
 4945:         >>> x.ids()
 4946:         (166670640, 166659832) # may vary
 4947: 
 4948:         If the array has no mask, the address of `nomask` is returned. This address
 4949:         is typically not close to the data in memory:
 4950: 
 4951:         >>> x = np.ma.array([1, 2, 3])
 4952:         >>> x.ids()
 4953:         (166691080, 3083169284) # may vary
 4954: 
 4955:         """
 4956:         if self._mask is nomask:
 4957:             return (self.ctypes.data, id(nomask))
 4958:         return (self.ctypes.data, self._mask.ctypes.data)
 4959: 
 4960:     def iscontiguous(self):
 4961:         """
 4962:         Return a boolean indicating whether the data is contiguous.
 4963: 
 4964:         Parameters
 4965:         ----------
 4966:         None
 4967: 
 4968:         Examples
 4969:         --------
 4970:         >>> import numpy as np
 4971:         >>> x = np.ma.array([1, 2, 3])
 4972:         >>> x.iscontiguous()
 4973:         True
 4974: 
 4975:         `iscontiguous` returns one of the flags of the masked array:
 4976: 
 4977:         >>> x.flags
 4978:           C_CONTIGUOUS : True
 4979:           F_CONTIGUOUS : True
 4980:           OWNDATA : False
 4981:           WRITEABLE : True
 4982:           ALIGNED : True
 4983:           WRITEBACKIFCOPY : False
 4984: 
 4985:         """
 4986:         return self.flags['CONTIGUOUS']
 4987: 
 4988:     def all(self, axis=None, out=None, keepdims=np._NoValue):
 4989:         """
 4990:         Returns True if all elements evaluate to True.
 4991: 
 4992:         The output array is masked where all the values along the given axis
 4993:         are masked: if the output would have been a scalar and that all the
 4994:         values are masked, then the output is `masked`.
 4995: 
 4996:         Refer to `numpy.all` for full documentation.
 4997: 
 4998:         See Also
 4999:         --------
 5000:         numpy.ndarray.all : corresponding function for ndarrays
 5001:         numpy.all : equivalent function
 5002: 
 5003:         Examples
 5004:         --------
 5005:         >>> import numpy as np
 5006:         >>> np.ma.array([1,2,3]).all()
 5007:         True
 5008:         >>> a = np.ma.array([1,2,3], mask=True)
 5009:         >>> (a.all() is np.ma.masked)
 5010:         True
 5011: 
 5012:         """
 5013:         kwargs = {} if keepdims is np._NoValue else {'keepdims': keepdims}
 5014: 
 5015:         mask = _check_mask_axis(self._mask, axis, **kwargs)
 5016:         if out is None:
 5017:             d = self.filled(True).all(axis=axis, **kwargs).view(type(self))
 5018:             if d.ndim:
 5019:                 d.__setmask__(mask)
 5020:             elif mask:
 5021:                 return masked
 5022:             return d
 5023:         self.filled(True).all(axis=axis, out=out, **kwargs)
 5024:         if isinstance(out, MaskedArray):
 5025:             if out.ndim or mask:
 5026:                 out.__setmask__(mask)
 5027:         return out
 5028: 
 5029:     def any(self, axis=None, out=None, keepdims=np._NoValue):
 5030:         """
 5031:         Returns True if any of the elements of `a` evaluate to True.
 5032: 
 5033:         Masked values are considered as False during computation.
 5034: 
 5035:         Refer to `numpy.any` for full documentation.
 5036: 
 5037:         See Also
 5038:         --------
 5039:         numpy.ndarray.any : corresponding function for ndarrays
 5040:         numpy.any : equivalent function
 5041: 
 5042:         """
 5043:         kwargs = {} if keepdims is np._NoValue else {'keepdims': keepdims}
 5044: 
 5045:         mask = _check_mask_axis(self._mask, axis, **kwargs)
 5046:         if out is None:
 5047:             d = self.filled(False).any(axis=axis, **kwargs).view(type(self))
 5048:             if d.ndim:
 5049:                 d.__setmask__(mask)
 5050:             elif mask:
 5051:                 d = masked
 5052:             return d
 5053:         self.filled(False).any(axis=axis, out=out, **kwargs)
 5054:         if isinstance(out, MaskedArray):
 5055:             if out.ndim or mask:
 5056:                 out.__setmask__(mask)
 5057:         return out
 5058: 
 5059:     def nonzero(self):
 5060:         """
 5061:         Return the indices of unmasked elements that are not zero.
 5062: 
 5063:         Returns a tuple of arrays, one for each dimension, containing the
 5064:         indices of the non-zero elements in that dimension. The corresponding
 5065:         non-zero values can be obtained with::
 5066: 
 5067:             a[a.nonzero()]
 5068: 
 5069:         To group the indices by element, rather than dimension, use
 5070:         instead::
 5071: 
 5072:             np.transpose(a.nonzero())
 5073: 
 5074:         The result of this is always a 2d array, with a row for each non-zero
 5075:         element.
 5076: 
 5077:         Parameters
 5078:         ----------
 5079:         None
 5080: 
 5081:         Returns
 5082:         -------
 5083:         tuple_of_arrays : tuple
 5084:             Indices of elements that are non-zero.
 5085: 
 5086:         See Also
 5087:         --------
 5088:         numpy.nonzero :
 5089:             Function operating on ndarrays.
 5090:         flatnonzero :
 5091:             Return indices that are non-zero in the flattened version of the input
 5092:             array.
 5093:         numpy.ndarray.nonzero :
 5094:             Equivalent ndarray method.
 5095:         count_nonzero :
 5096:             Counts the number of non-zero elements in the input array.
 5097: 
 5098:         Examples
 5099:         --------
 5100:         >>> import numpy as np
 5101:         >>> import numpy.ma as ma
 5102:         >>> x = ma.array(np.eye(3))
 5103:         >>> x
 5104:         masked_array(
 5105:           data=[[1., 0., 0.],
 5106:                 [0., 1., 0.],
 5107:                 [0., 0., 1.]],
 5108:           mask=False,
 5109:           fill_value=1e+20)
 5110:         >>> x.nonzero()
 5111:         (array([0, 1, 2]), array([0, 1, 2]))
 5112: 
 5113:         Masked elements are ignored.
 5114: 
 5115:         >>> x[1, 1] = ma.masked
 5116:         >>> x
 5117:         masked_array(
 5118:           data=[[1.0, 0.0, 0.0],
 5119:                 [0.0, --, 0.0],
 5120:                 [0.0, 0.0, 1.0]],
 5121:           mask=[[False, False, False],
 5122:                 [False,  True, False],
 5123:                 [False, False, False]],
 5124:           fill_value=1e+20)
 5125:         >>> x.nonzero()
 5126:         (array([0, 2]), array([0, 2]))
 5127: 
 5128:         Indices can also be grouped by element.
 5129: 
 5130:         >>> np.transpose(x.nonzero())
 5131:         array([[0, 0],
 5132:                [2, 2]])
 5133: 
 5134:         A common use for ``nonzero`` is to find the indices of an array, where
 5135:         a condition is True.  Given an array `a`, the condition `a` > 3 is a
 5136:         boolean array and since False is interpreted as 0, ma.nonzero(a > 3)
 5137:         yields the indices of the `a` where the condition is true.
 5138: 
 5139:         >>> a = ma.array([[1,2,3],[4,5,6],[7,8,9]])
 5140:         >>> a > 3
 5141:         masked_array(
 5142:           data=[[False, False, False],
 5143:                 [ True,  True,  True],
 5144:                 [ True,  True,  True]],
 5145:           mask=False,
 5146:           fill_value=True)
 5147:         >>> ma.nonzero(a > 3)
 5148:         (array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))
 5149: 
 5150:         The ``nonzero`` method of the condition array can also be called.
 5151: 
 5152:         >>> (a > 3).nonzero()
 5153:         (array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))
 5154: 
 5155:         """
 5156:         return np.asarray(self.filled(0)).nonzero()
 5157: 
 5158:     def trace(self, offset=0, axis1=0, axis2=1, dtype=None, out=None):
 5159:         """
 5160:         (this docstring should be overwritten)
 5161:         """
 5162:         # !!!: implement out + test!
 5163:         m = self._mask
 5164:         if m is nomask:
 5165:             result = super().trace(offset=offset, axis1=axis1, axis2=axis2,
 5166:                                    out=out)
 5167:             return result.astype(dtype)
 5168:         else:
 5169:             D = self.diagonal(offset=offset, axis1=axis1, axis2=axis2)
 5170:             return D.astype(dtype).filled(0).sum(axis=-1, out=out)
 5171:     trace.__doc__ = ndarray.trace.__doc__
 5172: 
 5173:     def dot(self, b, out=None, strict=False):
 5174:         """
 5175:         a.dot(b, out=None)
 5176: 
 5177:         Masked dot product of two arrays. Note that `out` and `strict` are
 5178:         located in different positions than in `ma.dot`. In order to
 5179:         maintain compatibility with the functional version, it is
 5180:         recommended that the optional arguments be treated as keyword only.
 5181:         At some point that may be mandatory.
 5182: 
 5183:         Parameters
 5184:         ----------
 5185:         b : masked_array_like
 5186:             Inputs array.
 5187:         out : masked_array, optional
 5188:             Output argument. This must have the exact kind that would be
 5189:             returned if it was not used. In particular, it must have the
 5190:             right type, must be C-contiguous, and its dtype must be the
 5191:             dtype that would be returned for `ma.dot(a,b)`. This is a
 5192:             performance feature. Therefore, if these conditions are not
 5193:             met, an exception is raised, instead of attempting to be
 5194:             flexible.
 5195:         strict : bool, optional
 5196:             Whether masked data are propagated (True) or set to 0 (False)
 5197:             for the computation. Default is False.  Propagating the mask
 5198:             means that if a masked value appears in a row or column, the
 5199:             whole row or column is considered masked.
 5200: 
 5201:         See Also
 5202:         --------
 5203:         numpy.ma.dot : equivalent function
 5204: 
 5205:         """
 5206:         return dot(self, b, out=out, strict=strict)
 5207: 
 5208:     def sum(self, axis=None, dtype=None, out=None, keepdims=np._NoValue):
 5209:         """
 5210:         Return the sum of the array elements over the given axis.
 5211: 
 5212:         Masked elements are set to 0 internally.
 5213: 
 5214:         Refer to `numpy.sum` for full documentation.
 5215: 
 5216:         See Also
 5217:         --------
 5218:         numpy.ndarray.sum : corresponding function for ndarrays
 5219:         numpy.sum : equivalent function
 5220: 
 5221:         Examples
 5222:         --------
 5223:         >>> import numpy as np
 5224:         >>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
 5225:         >>> x
 5226:         masked_array(
 5227:           data=[[1, --, 3],
 5228:                 [--, 5, --],
 5229:                 [7, --, 9]],
 5230:           mask=[[False,  True, False],
 5231:                 [ True, False,  True],
 5232:                 [False,  True, False]],
 5233:           fill_value=999999)
 5234:         >>> x.sum()
 5235:         25
 5236:         >>> x.sum(axis=1)
 5237:         masked_array(data=[4, 5, 16],
 5238:                      mask=[False, False, False],
 5239:                fill_value=999999)
 5240:         >>> x.sum(axis=0)
 5241:         masked_array(data=[8, 5, 12],
 5242:                      mask=[False, False, False],
 5243:                fill_value=999999)
 5244:         >>> print(type(x.sum(axis=0, dtype=np.int64)[0]))
 5245:         <class 'numpy.int64'>
 5246: 
 5247:         """
 5248:         kwargs = {} if keepdims is np._NoValue else {'keepdims': keepdims}
 5249: 
 5250:         _mask = self._mask
 5251:         newmask = _check_mask_axis(_mask, axis, **kwargs)
 5252:         # No explicit output
 5253:         if out is None:
 5254:             result = self.filled(0).sum(axis, dtype=dtype, **kwargs)
 5255:             rndim = getattr(result, 'ndim', 0)
 5256:             if rndim:
 5257:                 result = result.view(type(self))
 5258:                 result.__setmask__(newmask)
 5259:             elif newmask:
 5260:                 result = masked
 5261:             return result
 5262:         # Explicit output
 5263:         result = self.filled(0).sum(axis, dtype=dtype, out=out, **kwargs)
 5264:         if isinstance(out, MaskedArray):
 5265:             outmask = getmask(out)
 5266:             if outmask is nomask:
 5267:                 outmask = out._mask = make_mask_none(out.shape)
 5268:             outmask.flat = newmask
 5269:         return out
 5270: 
 5271:     def cumsum(self, axis=None, dtype=None, out=None):
 5272:         """
 5273:         Return the cumulative sum of the array elements over the given axis.
 5274: 
 5275:         Masked values are set to 0 internally during the computation.
 5276:         However, their position is saved, and the result will be masked at
 5277:         the same locations.
 5278: 
 5279:         Refer to `numpy.cumsum` for full documentation.
 5280: 
 5281:         Notes
 5282:         -----
 5283:         The mask is lost if `out` is not a valid :class:`ma.MaskedArray` !
 5284: 
 5285:         Arithmetic is modular when using integer types, and no error is
 5286:         raised on overflow.
 5287: 
 5288:         See Also
 5289:         --------
 5290:         numpy.ndarray.cumsum : corresponding function for ndarrays
 5291:         numpy.cumsum : equivalent function
 5292: 
 5293:         Examples
 5294:         --------
 5295:         >>> import numpy as np
 5296:         >>> marr = np.ma.array(np.arange(10), mask=[0,0,0,1,1,1,0,0,0,0])
 5297:         >>> marr.cumsum()
 5298:         masked_array(data=[0, 1, 3, --, --, --, 9, 16, 24, 33],
 5299:                      mask=[False, False, False,  True,  True,  True, False, False,
 5300:                            False, False],
 5301:                fill_value=999999)
 5302: 
 5303:         """
 5304:         result = self.filled(0).cumsum(axis=axis, dtype=dtype, out=out)
 5305:         if out is not None:
 5306:             if isinstance(out, MaskedArray):
 5307:                 out.__setmask__(self.mask)
 5308:             return out
 5309:         result = result.view(type(self))
 5310:         result.__setmask__(self._mask)
 5311:         return result
 5312: 
 5313:     def prod(self, axis=None, dtype=None, out=None, keepdims=np._NoValue):
 5314:         """
 5315:         Return the product of the array elements over the given axis.
 5316: 
 5317:         Masked elements are set to 1 internally for computation.
 5318: 
 5319:         Refer to `numpy.prod` for full documentation.
 5320: 
 5321:         Notes
 5322:         -----
 5323:         Arithmetic is modular when using integer types, and no error is raised
 5324:         on overflow.
 5325: 
 5326:         See Also
 5327:         --------
 5328:         numpy.ndarray.prod : corresponding function for ndarrays
 5329:         numpy.prod : equivalent function
 5330:         """
 5331:         kwargs = {} if keepdims is np._NoValue else {'keepdims': keepdims}
 5332: 
 5333:         _mask = self._mask
 5334:         newmask = _check_mask_axis(_mask, axis, **kwargs)
 5335:         # No explicit output
 5336:         if out is None:
 5337:             result = self.filled(1).prod(axis, dtype=dtype, **kwargs)
 5338:             rndim = getattr(result, 'ndim', 0)
 5339:             if rndim:
 5340:                 result = result.view(type(self))
 5341:                 result.__setmask__(newmask)
 5342:             elif newmask:
 5343:                 result = masked
 5344:             return result
 5345:         # Explicit output
 5346:         result = self.filled(1).prod(axis, dtype=dtype, out=out, **kwargs)
 5347:         if isinstance(out, MaskedArray):
 5348:             outmask = getmask(out)
 5349:             if outmask is nomask:
 5350:                 outmask = out._mask = make_mask_none(out.shape)
 5351:             outmask.flat = newmask
 5352:         return out
 5353:     product = prod
 5354: 
 5355:     def cumprod(self, axis=None, dtype=None, out=None):
 5356:         """
 5357:         Return the cumulative product of the array elements over the given axis.
 5358: 
 5359:         Masked values are set to 1 internally during the computation.
 5360:         However, their position is saved, and the result will be masked at
 5361:         the same locations.
 5362: 
 5363:         Refer to `numpy.cumprod` for full documentation.
 5364: 
 5365:         Notes
 5366:         -----
 5367:         The mask is lost if `out` is not a valid MaskedArray !
 5368: 
 5369:         Arithmetic is modular when using integer types, and no error is
 5370:         raised on overflow.
 5371: 
 5372:         See Also
 5373:         --------
 5374:         numpy.ndarray.cumprod : corresponding function for ndarrays
 5375:         numpy.cumprod : equivalent function
 5376:         """
 5377:         result = self.filled(1).cumprod(axis=axis, dtype=dtype, out=out)
 5378:         if out is not None:
 5379:             if isinstance(out, MaskedArray):
 5380:                 out.__setmask__(self._mask)
 5381:             return out
 5382:         result = result.view(type(self))
 5383:         result.__setmask__(self._mask)
 5384:         return result
 5385: 
 5386:     def mean(self, axis=None, dtype=None, out=None, keepdims=np._NoValue):
 5387:         """
 5388:         Returns the average of the array elements along given axis.
 5389: 
 5390:         Masked entries are ignored, and result elements which are not
 5391:         finite will be masked.
 5392: 
 5393:         Refer to `numpy.mean` for full documentation.
 5394: 
 5395:         See Also
 5396:         --------
 5397:         numpy.ndarray.mean : corresponding function for ndarrays
 5398:         numpy.mean : Equivalent function
 5399:         numpy.ma.average : Weighted average.
 5400: 
 5401:         Examples
 5402:         --------
 5403:         >>> import numpy as np
 5404:         >>> a = np.ma.array([1,2,3], mask=[False, False, True])
 5405:         >>> a
 5406:         masked_array(data=[1, 2, --],
 5407:                      mask=[False, False,  True],
 5408:                fill_value=999999)
 5409:         >>> a.mean()
 5410:         1.5
 5411: 
 5412:         """
 5413:         kwargs = {} if keepdims is np._NoValue else {'keepdims': keepdims}
 5414:         if self._mask is nomask:
 5415:             result = super().mean(axis=axis, dtype=dtype, **kwargs)[()]
 5416:         else:
 5417:             is_float16_result = False
 5418:             if dtype is None:
 5419:                 if issubclass(self.dtype.type, (ntypes.integer, ntypes.bool)):
 5420:                     dtype = mu.dtype('f8')
 5421:                 elif issubclass(self.dtype.type, ntypes.float16):
 5422:                     dtype = mu.dtype('f4')
 5423:                     is_float16_result = True
 5424:             dsum = self.sum(axis=axis, dtype=dtype, **kwargs)
 5425:             cnt = self.count(axis=axis, **kwargs)
 5426:             if cnt.shape == () and (cnt == 0):
 5427:                 result = masked
 5428:             elif is_float16_result:
 5429:                 result = self.dtype.type(dsum * 1. / cnt)
 5430:             else:
 5431:                 result = dsum * 1. / cnt
 5432:         if out is not None:
 5433:             out.flat = result
 5434:             if isinstance(out, MaskedArray):
 5435:                 outmask = getmask(out)
 5436:                 if outmask is nomask:
 5437:                     outmask = out._mask = make_mask_none(out.shape)
 5438:                 outmask.flat = getmask(result)
 5439:             return out
 5440:         return result
 5441: 
 5442:     def anom(self, axis=None, dtype=None):
 5443:         """
 5444:         Compute the anomalies (deviations from the arithmetic mean)
 5445:         along the given axis.
 5446: 
 5447:         Returns an array of anomalies, with the same shape as the input and
 5448:         where the arithmetic mean is computed along the given axis.
 5449: 
 5450:         Parameters
 5451:         ----------
 5452:         axis : int, optional
 5453:             Axis over which the anomalies are taken.
 5454:             The default is to use the mean of the flattened array as reference.
 5455:         dtype : dtype, optional
 5456:             Type to use in computing the variance. For arrays of integer type
 5457:              the default is float32; for arrays of float types it is the same as
 5458:              the array type.
 5459: 
 5460:         See Also
 5461:         --------
 5462:         mean : Compute the mean of the array.
 5463: 
 5464:         Examples
 5465:         --------
 5466:         >>> import numpy as np
 5467:         >>> a = np.ma.array([1,2,3])
 5468:         >>> a.anom()
 5469:         masked_array(data=[-1.,  0.,  1.],
 5470:                      mask=False,
 5471:                fill_value=1e+20)
 5472: 
 5473:         """
 5474:         m = self.mean(axis, dtype)
 5475:         if not axis:
 5476:             return self - m
 5477:         else:
 5478:             return self - expand_dims(m, axis)
 5479: 
 5480:     def var(self, axis=None, dtype=None, out=None, ddof=0,
 5481:             keepdims=np._NoValue, mean=np._NoValue):
 5482:         """
 5483:         Returns the variance of the array elements along given axis.
 5484: 
 5485:         Masked entries are ignored, and result elements which are not
 5486:         finite will be masked.
 5487: 
 5488:         Refer to `numpy.var` for full documentation.
 5489: 
 5490:         See Also
 5491:         --------
 5492:         numpy.ndarray.var : corresponding function for ndarrays
 5493:         numpy.var : Equivalent function
 5494:         """
 5495:         kwargs = {}
 5496: 
 5497:         if keepdims is not np._NoValue:
 5498:             kwargs['keepdims'] = keepdims
 5499: 
 5500:         # Easy case: nomask, business as usual
 5501:         if self._mask is nomask:
 5502: 
 5503:             if mean is not np._NoValue:
 5504:                 kwargs['mean'] = mean
 5505: 
 5506:             ret = super().var(axis=axis, dtype=dtype, out=out, ddof=ddof,
 5507:                               **kwargs)[()]
 5508:             if out is not None:
 5509:                 if isinstance(out, MaskedArray):
 5510:                     out.__setmask__(nomask)
 5511:                 return out
 5512:             return ret
 5513: 
 5514:         # Some data are masked, yay!
 5515:         cnt = self.count(axis=axis, **kwargs) - ddof
 5516: 
 5517:         if mean is not np._NoValue:
 5518:             danom = self - mean
 5519:         else:
 5520:             danom = self - self.mean(axis, dtype, keepdims=True)
 5521: 
 5522:         if iscomplexobj(self):
 5523:             danom = umath.absolute(danom) ** 2
 5524:         else:
 5525:             danom *= danom
 5526:         dvar = divide(danom.sum(axis, **kwargs), cnt).view(type(self))
 5527:         # Apply the mask if it's not a scalar
 5528:         if dvar.ndim:
 5529:             dvar._mask = mask_or(self._mask.all(axis, **kwargs), (cnt <= 0))
 5530:             dvar._update_from(self)
 5531:         elif getmask(dvar):
 5532:             # Make sure that masked is returned when the scalar is masked.
 5533:             dvar = masked
 5534:             if out is not None:
 5535:                 if isinstance(out, MaskedArray):
 5536:                     out.flat = 0
 5537:                     out.__setmask__(True)
 5538:                 elif out.dtype.kind in 'biu':
 5539:                     errmsg = "Masked data information would be lost in one or "\
 5540:                              "more location."
 5541:                     raise MaskError(errmsg)
 5542:                 else:
 5543:                     out.flat = np.nan
 5544:                 return out
 5545:         # In case with have an explicit output
 5546:         if out is not None:
 5547:             # Set the data
 5548:             out.flat = dvar
 5549:             # Set the mask if needed
 5550:             if isinstance(out, MaskedArray):
 5551:                 out.__setmask__(dvar.mask)
 5552:             return out
 5553:         return dvar
 5554:     var.__doc__ = np.var.__doc__
 5555: 
 5556:     def std(self, axis=None, dtype=None, out=None, ddof=0,
 5557:             keepdims=np._NoValue, mean=np._NoValue):
 5558:         """
 5559:         Returns the standard deviation of the array elements along given axis.
 5560: 
 5561:         Masked entries are ignored.
 5562: 
 5563:         Refer to `numpy.std` for full documentation.
 5564: 
 5565:         See Also
 5566:         --------
 5567:         numpy.ndarray.std : corresponding function for ndarrays
 5568:         numpy.std : Equivalent function
 5569:         """
 5570:         kwargs = {} if keepdims is np._NoValue else {'keepdims': keepdims}
 5571: 
 5572:         dvar = self.var(axis, dtype, out, ddof, **kwargs)
 5573:         if dvar is not masked:
 5574:             if out is not None:
 5575:                 np.power(out, 0.5, out=out, casting='unsafe')
 5576:                 return out
 5577:             dvar = sqrt(dvar)
 5578:         return dvar
 5579: 
 5580:     def round(self, decimals=0, out=None):
 5581:         """
 5582:         Return each element rounded to the given number of decimals.
 5583: 
 5584:         Refer to `numpy.around` for full documentation.
 5585: 
 5586:         See Also
 5587:         --------
 5588:         numpy.ndarray.round : corresponding function for ndarrays
 5589:         numpy.around : equivalent function
 5590: 
 5591:         Examples
 5592:         --------
 5593:         >>> import numpy as np
 5594:         >>> import numpy.ma as ma
 5595:         >>> x = ma.array([1.35, 2.5, 1.5, 1.75, 2.25, 2.75],
 5596:         ...              mask=[0, 0, 0, 1, 0, 0])
 5597:         >>> ma.round(x)
 5598:         masked_array(data=[1.0, 2.0, 2.0, --, 2.0, 3.0],
 5599:                      mask=[False, False, False,  True, False, False],
 5600:                 fill_value=1e+20)
 5601: 
 5602:         """
 5603:         result = self._data.round(decimals=decimals, out=out).view(type(self))
 5604:         if result.ndim > 0:
 5605:             result._mask = self._mask
 5606:             result._update_from(self)
 5607:         elif self._mask:
 5608:             # Return masked when the scalar is masked
 5609:             result = masked
 5610:         # No explicit output: we're done
 5611:         if out is None:
 5612:             return result
 5613:         if isinstance(out, MaskedArray):
 5614:             out.__setmask__(self._mask)
 5615:         return out
 5616: 
 5617:     def argsort(self, axis=np._NoValue, kind=None, order=None, endwith=True,
 5618:                 fill_value=None, *, stable=False):
 5619:         """
 5620:         Return an ndarray of indices that sort the array along the
 5621:         specified axis.  Masked values are filled beforehand to
 5622:         `fill_value`.
 5623: 
 5624:         Parameters
 5625:         ----------
 5626:         axis : int, optional
 5627:             Axis along which to sort. If None, the default, the flattened array
 5628:             is used.
 5629:         kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional
 5630:             The sorting algorithm used.
 5631:         order : list, optional
 5632:             When `a` is an array with fields defined, this argument specifies
 5633:             which fields to compare first, second, etc.  Not all fields need be
 5634:             specified.
 5635:         endwith : {True, False}, optional
 5636:             Whether missing values (if any) should be treated as the largest values
 5637:             (True) or the smallest values (False)
 5638:             When the array contains unmasked values at the same extremes of the
 5639:             datatype, the ordering of these values and the masked values is
 5640:             undefined.
 5641:         fill_value : scalar or None, optional
 5642:             Value used internally for the masked values.
 5643:             If ``fill_value`` is not None, it supersedes ``endwith``.
 5644:         stable : bool, optional
 5645:             Only for compatibility with ``np.argsort``. Ignored.
 5646: 
 5647:         Returns
 5648:         -------
 5649:         index_array : ndarray, int
 5650:             Array of indices that sort `a` along the specified axis.
 5651:             In other words, ``a[index_array]`` yields a sorted `a`.
 5652: 
 5653:         See Also
 5654:         --------
 5655:         ma.MaskedArray.sort : Describes sorting algorithms used.
 5656:         lexsort : Indirect stable sort with multiple keys.
 5657:         numpy.ndarray.sort : Inplace sort.
 5658: 
 5659:         Notes
 5660:         -----
 5661:         See `sort` for notes on the different sorting algorithms.
 5662: 
 5663:         Examples
 5664:         --------
 5665:         >>> import numpy as np
 5666:         >>> a = np.ma.array([3,2,1], mask=[False, False, True])
 5667:         >>> a
 5668:         masked_array(data=[3, 2, --],
 5669:                      mask=[False, False,  True],
 5670:                fill_value=999999)
 5671:         >>> a.argsort()
 5672:         array([1, 0, 2])
 5673: 
 5674:         """
 5675:         if stable:
 5676:             raise ValueError(
 5677:                 "`stable` parameter is not supported for masked arrays."
 5678:             )
 5679: 
 5680:         # 2017-04-11, Numpy 1.13.0, gh-8701: warn on axis default
 5681:         if axis is np._NoValue:
 5682:             axis = _deprecate_argsort_axis(self)
 5683: 
 5684:         if fill_value is None:
 5685:             if endwith:
 5686:                 # nan > inf
 5687:                 if np.issubdtype(self.dtype, np.floating):
 5688:                     fill_value = np.nan
 5689:                 else:
 5690:                     fill_value = minimum_fill_value(self)
 5691:             else:
 5692:                 fill_value = maximum_fill_value(self)
 5693: 
 5694:         filled = self.filled(fill_value)
 5695:         return filled.argsort(axis=axis, kind=kind, order=order)
 5696: 
 5697:     def argmin(self, axis=None, fill_value=None, out=None, *,
 5698:                 keepdims=np._NoValue):
 5699:         """
 5700:         Return array of indices to the minimum values along the given axis.
 5701: 
 5702:         Parameters
 5703:         ----------
 5704:         axis : {None, integer}
 5705:             If None, the index is into the flattened array, otherwise along
 5706:             the specified axis
 5707:         fill_value : scalar or None, optional
 5708:             Value used to fill in the masked values.  If None, the output of
 5709:             minimum_fill_value(self._data) is used instead.
 5710:         out : {None, array}, optional
 5711:             Array into which the result can be placed. Its type is preserved
 5712:             and it must be of the right shape to hold the output.
 5713: 
 5714:         Returns
 5715:         -------
 5716:         ndarray or scalar
 5717:             If multi-dimension input, returns a new ndarray of indices to the
 5718:             minimum values along the given axis.  Otherwise, returns a scalar
 5719:             of index to the minimum values along the given axis.
 5720: 
 5721:         Examples
 5722:         --------
 5723:         >>> import numpy as np
 5724:         >>> x = np.ma.array(np.arange(4), mask=[1,1,0,0])
 5725:         >>> x.shape = (2,2)
 5726:         >>> x
 5727:         masked_array(
 5728:           data=[[--, --],
 5729:                 [2, 3]],
 5730:           mask=[[ True,  True],
 5731:                 [False, False]],
 5732:           fill_value=999999)
 5733:         >>> x.argmin(axis=0, fill_value=-1)
 5734:         array([0, 0])
 5735:         >>> x.argmin(axis=0, fill_value=9)
 5736:         array([1, 1])
 5737: 
 5738:         """
 5739:         if fill_value is None:
 5740:             fill_value = minimum_fill_value(self)
 5741:         d = self.filled(fill_value).view(ndarray)
 5742:         keepdims = False if keepdims is np._NoValue else bool(keepdims)
 5743:         return d.argmin(axis, out=out, keepdims=keepdims)
 5744: 
 5745:     def argmax(self, axis=None, fill_value=None, out=None, *,
 5746:                 keepdims=np._NoValue):
 5747:         """
 5748:         Returns array of indices of the maximum values along the given axis.
 5749:         Masked values are treated as if they had the value fill_value.
 5750: 
 5751:         Parameters
 5752:         ----------
 5753:         axis : {None, integer}
 5754:             If None, the index is into the flattened array, otherwise along
 5755:             the specified axis
 5756:         fill_value : scalar or None, optional
 5757:             Value used to fill in the masked values.  If None, the output of
 5758:             maximum_fill_value(self._data) is used instead.
 5759:         out : {None, array}, optional
 5760:             Array into which the result can be placed. Its type is preserved
 5761:             and it must be of the right shape to hold the output.
 5762: 
 5763:         Returns
 5764:         -------
 5765:         index_array : {integer_array}
 5766: 
 5767:         Examples
 5768:         --------
 5769:         >>> import numpy as np
 5770:         >>> a = np.arange(6).reshape(2,3)
 5771:         >>> a.argmax()
 5772:         5
 5773:         >>> a.argmax(0)
 5774:         array([1, 1, 1])
 5775:         >>> a.argmax(1)
 5776:         array([2, 2])
 5777: 
 5778:         """
 5779:         if fill_value is None:
 5780:             fill_value = maximum_fill_value(self._data)
 5781:         d = self.filled(fill_value).view(ndarray)
 5782:         keepdims = False if keepdims is np._NoValue else bool(keepdims)
 5783:         return d.argmax(axis, out=out, keepdims=keepdims)
 5784: 
 5785:     def sort(self, axis=-1, kind=None, order=None, endwith=True,
 5786:              fill_value=None, *, stable=False):
 5787:         """
 5788:         Sort the array, in-place
 5789: 
 5790:         Parameters
 5791:         ----------
 5792:         a : array_like
 5793:             Array to be sorted.
 5794:         axis : int, optional
 5795:             Axis along which to sort. If None, the array is flattened before
 5796:             sorting. The default is -1, which sorts along the last axis.
 5797:         kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional
 5798:             The sorting algorithm used.
 5799:         order : list, optional
 5800:             When `a` is a structured array, this argument specifies which fields
 5801:             to compare first, second, and so on.  This list does not need to
 5802:             include all of the fields.
 5803:         endwith : {True, False}, optional
 5804:             Whether missing values (if any) should be treated as the largest values
 5805:             (True) or the smallest values (False)
 5806:             When the array contains unmasked values sorting at the same extremes of the
 5807:             datatype, the ordering of these values and the masked values is
 5808:             undefined.
 5809:         fill_value : scalar or None, optional
 5810:             Value used internally for the masked values.
 5811:             If ``fill_value`` is not None, it supersedes ``endwith``.
 5812:         stable : bool, optional
 5813:             Only for compatibility with ``np.sort``. Ignored.
 5814: 
 5815:         Returns
 5816:         -------
 5817:         sorted_array : ndarray
 5818:             Array of the same type and shape as `a`.
 5819: 
 5820:         See Also
 5821:         --------
 5822:         numpy.ndarray.sort : Method to sort an array in-place.
 5823:         argsort : Indirect sort.
 5824:         lexsort : Indirect stable sort on multiple keys.
 5825:         searchsorted : Find elements in a sorted array.
 5826: 
 5827:         Notes
 5828:         -----
 5829:         See ``sort`` for notes on the different sorting algorithms.
 5830: 
 5831:         Examples
 5832:         --------
 5833:         >>> import numpy as np
 5834:         >>> a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])
 5835:         >>> # Default
 5836:         >>> a.sort()
 5837:         >>> a
 5838:         masked_array(data=[1, 3, 5, --, --],
 5839:                      mask=[False, False, False,  True,  True],
 5840:                fill_value=999999)
 5841: 
 5842:         >>> a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])
 5843:         >>> # Put missing values in the front
 5844:         >>> a.sort(endwith=False)
 5845:         >>> a
 5846:         masked_array(data=[--, --, 1, 3, 5],
 5847:                      mask=[ True,  True, False, False, False],
 5848:                fill_value=999999)
 5849: 
 5850:         >>> a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])
 5851:         >>> # fill_value takes over endwith
 5852:         >>> a.sort(endwith=False, fill_value=3)
 5853:         >>> a
 5854:         masked_array(data=[1, --, --, 3, 5],
 5855:                      mask=[False,  True,  True, False, False],
 5856:                fill_value=999999)
 5857: 
 5858:         """
 5859:         if stable:
 5860:             raise ValueError(
 5861:                 "`stable` parameter is not supported for masked arrays."
 5862:             )
 5863: 
 5864:         if self._mask is nomask:
 5865:             ndarray.sort(self, axis=axis, kind=kind, order=order)
 5866:             return
 5867: 
 5868:         if self is masked:
 5869:             return
 5870: 
 5871:         sidx = self.argsort(axis=axis, kind=kind, order=order,
 5872:                             fill_value=fill_value, endwith=endwith)
 5873: 
 5874:         self[...] = np.take_along_axis(self, sidx, axis=axis)
 5875: 
 5876:     def min(self, axis=None, out=None, fill_value=None, keepdims=np._NoValue):
 5877:         """
 5878:         Return the minimum along a given axis.
 5879: 
 5880:         Parameters
 5881:         ----------
 5882:         axis : None or int or tuple of ints, optional
 5883:             Axis along which to operate.  By default, ``axis`` is None and the
 5884:             flattened input is used.
 5885:             If this is a tuple of ints, the minimum is selected over multiple
 5886:             axes, instead of a single axis or all the axes as before.
 5887:         out : array_like, optional
 5888:             Alternative output array in which to place the result.  Must be of
 5889:             the same shape and buffer length as the expected output.
 5890:         fill_value : scalar or None, optional
 5891:             Value used to fill in the masked values.
 5892:             If None, use the output of `minimum_fill_value`.
 5893:         keepdims : bool, optional
 5894:             If this is set to True, the axes which are reduced are left
 5895:             in the result as dimensions with size one. With this option,
 5896:             the result will broadcast correctly against the array.
 5897: 
 5898:         Returns
 5899:         -------
 5900:         amin : array_like
 5901:             New array holding the result.
 5902:             If ``out`` was specified, ``out`` is returned.
 5903: 
 5904:         See Also
 5905:         --------
 5906:         ma.minimum_fill_value
 5907:             Returns the minimum filling value for a given datatype.
 5908: 
 5909:         Examples
 5910:         --------
 5911:         >>> import numpy.ma as ma
 5912:         >>> x = [[1., -2., 3.], [0.2, -0.7, 0.1]]
 5913:         >>> mask = [[1, 1, 0], [0, 0, 1]]
 5914:         >>> masked_x = ma.masked_array(x, mask)
 5915:         >>> masked_x
 5916:         masked_array(
 5917:           data=[[--, --, 3.0],
 5918:                 [0.2, -0.7, --]],
 5919:           mask=[[ True,  True, False],
 5920:                 [False, False,  True]],
 5921:           fill_value=1e+20)
 5922:         >>> ma.min(masked_x)
 5923:         -0.7
 5924:         >>> ma.min(masked_x, axis=-1)
 5925:         masked_array(data=[3.0, -0.7],
 5926:                      mask=[False, False],
 5927:                 fill_value=1e+20)
 5928:         >>> ma.min(masked_x, axis=0, keepdims=True)
 5929:         masked_array(data=[[0.2, -0.7, 3.0]],
 5930:                      mask=[[False, False, False]],
 5931:                 fill_value=1e+20)
 5932:         >>> mask = [[1, 1, 1,], [1, 1, 1]]
 5933:         >>> masked_x = ma.masked_array(x, mask)
 5934:         >>> ma.min(masked_x, axis=0)
 5935:         masked_array(data=[--, --, --],
 5936:                      mask=[ True,  True,  True],
 5937:                 fill_value=1e+20,
 5938:                     dtype=float64)
 5939:         """
 5940:         kwargs = {} if keepdims is np._NoValue else {'keepdims': keepdims}
 5941: 
 5942:         _mask = self._mask
 5943:         newmask = _check_mask_axis(_mask, axis, **kwargs)
 5944:         if fill_value is None:
 5945:             fill_value = minimum_fill_value(self)
 5946:         # No explicit output
 5947:         if out is None:
 5948:             result = self.filled(fill_value).min(
 5949:                 axis=axis, out=out, **kwargs).view(type(self))
 5950:             if result.ndim:
 5951:                 # Set the mask
 5952:                 result.__setmask__(newmask)
 5953:                 # Get rid of Infs
 5954:                 if newmask.ndim:
 5955:                     np.copyto(result, result.fill_value, where=newmask)
 5956:             elif newmask:
 5957:                 result = masked
 5958:             return result
 5959:         # Explicit output
 5960:         self.filled(fill_value).min(axis=axis, out=out, **kwargs)
 5961:         if isinstance(out, MaskedArray):
 5962:             outmask = getmask(out)
 5963:             if outmask is nomask:
 5964:                 outmask = out._mask = make_mask_none(out.shape)
 5965:             outmask.flat = newmask
 5966:         else:
 5967:             if out.dtype.kind in 'biu':
 5968:                 errmsg = "Masked data information would be lost in one or more"\
 5969:                          " location."
 5970:                 raise MaskError(errmsg)
 5971:             np.copyto(out, np.nan, where=newmask)
 5972:         return out
 5973: 
 5974:     def max(self, axis=None, out=None, fill_value=None, keepdims=np._NoValue):
 5975:         """
 5976:         Return the maximum along a given axis.
 5977: 
 5978:         Parameters
 5979:         ----------
 5980:         axis : None or int or tuple of ints, optional
 5981:             Axis along which to operate.  By default, ``axis`` is None and the
 5982:             flattened input is used.
 5983:             If this is a tuple of ints, the maximum is selected over multiple
 5984:             axes, instead of a single axis or all the axes as before.
 5985:         out : array_like, optional
 5986:             Alternative output array in which to place the result.  Must
 5987:             be of the same shape and buffer length as the expected output.
 5988:         fill_value : scalar or None, optional
 5989:             Value used to fill in the masked values.
 5990:             If None, use the output of maximum_fill_value().
 5991:         keepdims : bool, optional
 5992:             If this is set to True, the axes which are reduced are left
 5993:             in the result as dimensions with size one. With this option,
 5994:             the result will broadcast correctly against the array.
 5995: 
 5996:         Returns
 5997:         -------
 5998:         amax : array_like
 5999:             New array holding the result.
 6000:             If ``out`` was specified, ``out`` is returned.
 6001: 
 6002:         See Also
 6003:         --------
 6004:         ma.maximum_fill_value
 6005:             Returns the maximum filling value for a given datatype.
 6006: 
 6007:         Examples
 6008:         --------
 6009:         >>> import numpy.ma as ma
 6010:         >>> x = [[-1., 2.5], [4., -2.], [3., 0.]]
 6011:         >>> mask = [[0, 0], [1, 0], [1, 0]]
 6012:         >>> masked_x = ma.masked_array(x, mask)
 6013:         >>> masked_x
 6014:         masked_array(
 6015:           data=[[-1.0, 2.5],
 6016:                 [--, -2.0],
 6017:                 [--, 0.0]],
 6018:           mask=[[False, False],
 6019:                 [ True, False],
 6020:                 [ True, False]],
 6021:           fill_value=1e+20)
 6022:         >>> ma.max(masked_x)
 6023:         2.5
 6024:         >>> ma.max(masked_x, axis=0)
 6025:         masked_array(data=[-1.0, 2.5],
 6026:                      mask=[False, False],
 6027:                fill_value=1e+20)
 6028:         >>> ma.max(masked_x, axis=1, keepdims=True)
 6029:         masked_array(
 6030:           data=[[2.5],
 6031:                 [-2.0],
 6032:                 [0.0]],
 6033:           mask=[[False],
 6034:                 [False],
 6035:                 [False]],
 6036:           fill_value=1e+20)
 6037:         >>> mask = [[1, 1], [1, 1], [1, 1]]
 6038:         >>> masked_x = ma.masked_array(x, mask)
 6039:         >>> ma.max(masked_x, axis=1)
 6040:         masked_array(data=[--, --, --],
 6041:                      mask=[ True,  True,  True],
 6042:                fill_value=1e+20,
 6043:                     dtype=float64)
 6044:         """
 6045:         kwargs = {} if keepdims is np._NoValue else {'keepdims': keepdims}
 6046: 
 6047:         _mask = self._mask
 6048:         newmask = _check_mask_axis(_mask, axis, **kwargs)
 6049:         if fill_value is None:
 6050:             fill_value = maximum_fill_value(self)
 6051:         # No explicit output
 6052:         if out is None:
 6053:             result = self.filled(fill_value).max(
 6054:                 axis=axis, out=out, **kwargs).view(type(self))
 6055:             if result.ndim:
 6056:                 # Set the mask
 6057:                 result.__setmask__(newmask)
 6058:                 # Get rid of Infs
 6059:                 if newmask.ndim:
 6060:                     np.copyto(result, result.fill_value, where=newmask)
 6061:             elif newmask:
 6062:                 result = masked
 6063:             return result
 6064:         # Explicit output
 6065:         self.filled(fill_value).max(axis=axis, out=out, **kwargs)
 6066:         if isinstance(out, MaskedArray):
 6067:             outmask = getmask(out)
 6068:             if outmask is nomask:
 6069:                 outmask = out._mask = make_mask_none(out.shape)
 6070:             outmask.flat = newmask
 6071:         else:
 6072: 
 6073:             if out.dtype.kind in 'biu':
 6074:                 errmsg = "Masked data information would be lost in one or more"\
 6075:                          " location."
 6076:                 raise MaskError(errmsg)
 6077:             np.copyto(out, np.nan, where=newmask)
 6078:         return out
 6079: 
 6080:     def ptp(self, axis=None, out=None, fill_value=None, keepdims=False):
 6081:         """
 6082:         Return (maximum - minimum) along the given dimension
 6083:         (i.e. peak-to-peak value).
 6084: 
 6085:         .. warning::
 6086:             `ptp` preserves the data type of the array. This means the
 6087:             return value for an input of signed integers with n bits
 6088:             (e.g. `np.int8`, `np.int16`, etc) is also a signed integer
 6089:             with n bits.  In that case, peak-to-peak values greater than
 6090:             ``2**(n-1)-1`` will be returned as negative values. An example
 6091:             with a work-around is shown below.
 6092: 
 6093:         Parameters
 6094:         ----------
 6095:         axis : {None, int}, optional
 6096:             Axis along which to find the peaks.  If None (default) the
 6097:             flattened array is used.
 6098:         out : {None, array_like}, optional
 6099:             Alternative output array in which to place the result. It must
 6100:             have the same shape and buffer length as the expected output
 6101:             but the type will be cast if necessary.
 6102:         fill_value : scalar or None, optional
 6103:             Value used to fill in the masked values.
 6104:         keepdims : bool, optional
 6105:             If this is set to True, the axes which are reduced are left
 6106:             in the result as dimensions with size one. With this option,
 6107:             the result will broadcast correctly against the array.
 6108: 
 6109:         Returns
 6110:         -------
 6111:         ptp : ndarray.
 6112:             A new array holding the result, unless ``out`` was
 6113:             specified, in which case a reference to ``out`` is returned.
 6114: 
 6115:         Examples
 6116:         --------
 6117:         >>> import numpy as np
 6118:         >>> x = np.ma.MaskedArray([[4, 9, 2, 10],
 6119:         ...                        [6, 9, 7, 12]])
 6120: 
 6121:         >>> x.ptp(axis=1)
 6122:         masked_array(data=[8, 6],
 6123:                      mask=False,
 6124:                fill_value=999999)
 6125: 
 6126:         >>> x.ptp(axis=0)
 6127:         masked_array(data=[2, 0, 5, 2],
 6128:                      mask=False,
 6129:                fill_value=999999)
 6130: 
 6131:         >>> x.ptp()
 6132:         10
 6133: 
 6134:         This example shows that a negative value can be returned when
 6135:         the input is an array of signed integers.
 6136: 
 6137:         >>> y = np.ma.MaskedArray([[1, 127],
 6138:         ...                        [0, 127],
 6139:         ...                        [-1, 127],
 6140:         ...                        [-2, 127]], dtype=np.int8)
 6141:         >>> y.ptp(axis=1)
 6142:         masked_array(data=[ 126,  127, -128, -127],
 6143:                      mask=False,
 6144:                fill_value=np.int64(999999),
 6145:                     dtype=int8)
 6146: 
 6147:         A work-around is to use the `view()` method to view the result as
 6148:         unsigned integers with the same bit width:
 6149: 
 6150:         >>> y.ptp(axis=1).view(np.uint8)
 6151:         masked_array(data=[126, 127, 128, 129],
 6152:                      mask=False,
 6153:                fill_value=np.uint64(999999),
 6154:                     dtype=uint8)
 6155:         """
 6156:         if out is None:
 6157:             result = self.max(axis=axis, fill_value=fill_value,
 6158:                               keepdims=keepdims)
 6159:             result -= self.min(axis=axis, fill_value=fill_value,
 6160:                                keepdims=keepdims)
 6161:             return result
 6162:         out.flat = self.max(axis=axis, out=out, fill_value=fill_value,
 6163:                             keepdims=keepdims)
 6164:         min_value = self.min(axis=axis, fill_value=fill_value,
 6165:                              keepdims=keepdims)
 6166:         np.subtract(out, min_value, out=out, casting='unsafe')
 6167:         return out
 6168: 
 6169:     def partition(self, *args, **kwargs):
 6170:         warnings.warn("Warning: 'partition' will ignore the 'mask' "
 6171:                       f"of the {self.__class__.__name__}.",
 6172:                       stacklevel=2)
 6173:         return super().partition(*args, **kwargs)
 6174: 
 6175:     def argpartition(self, *args, **kwargs):
 6176:         warnings.warn("Warning: 'argpartition' will ignore the 'mask' "
 6177:                       f"of the {self.__class__.__name__}.",
 6178:                       stacklevel=2)
 6179:         return super().argpartition(*args, **kwargs)
 6180: 
 6181:     def take(self, indices, axis=None, out=None, mode='raise'):
 6182:         """
 6183:         Take elements from a masked array along an axis.
 6184: 
 6185:         This function does the same thing as "fancy" indexing (indexing arrays
 6186:         using arrays) for masked arrays. It can be easier to use if you need
 6187:         elements along a given axis.
 6188: 
 6189:         Parameters
 6190:         ----------
 6191:         a : masked_array
 6192:             The source masked array.
 6193:         indices : array_like
 6194:             The indices of the values to extract. Also allow scalars for indices.
 6195:         axis : int, optional
 6196:             The axis over which to select values. By default, the flattened
 6197:             input array is used.
 6198:         out : MaskedArray, optional
 6199:             If provided, the result will be placed in this array. It should
 6200:             be of the appropriate shape and dtype. Note that `out` is always
 6201:             buffered if `mode='raise'`; use other modes for better performance.
 6202:         mode : {'raise', 'wrap', 'clip'}, optional
 6203:             Specifies how out-of-bounds indices will behave.
 6204: 
 6205:             * 'raise' -- raise an error (default)
 6206:             * 'wrap' -- wrap around
 6207:             * 'clip' -- clip to the range
 6208: 
 6209:             'clip' mode means that all indices that are too large are replaced
 6210:             by the index that addresses the last element along that axis. Note
 6211:             that this disables indexing with negative numbers.
 6212: 
 6213:         Returns
 6214:         -------
 6215:         out : MaskedArray
 6216:             The returned array has the same type as `a`.
 6217: 
 6218:         See Also
 6219:         --------
 6220:         numpy.take : Equivalent function for ndarrays.
 6221:         compress : Take elements using a boolean mask.
 6222:         take_along_axis : Take elements by matching the array and the index arrays.
 6223: 
 6224:         Notes
 6225:         -----
 6226:         This function behaves similarly to `numpy.take`, but it handles masked
 6227:         values. The mask is retained in the output array, and masked values
 6228:         in the input array remain masked in the output.
 6229: 
 6230:         Examples
 6231:         --------
 6232:         >>> import numpy as np
 6233:         >>> a = np.ma.array([4, 3, 5, 7, 6, 8], mask=[0, 0, 1, 0, 1, 0])
 6234:         >>> indices = [0, 1, 4]
 6235:         >>> np.ma.take(a, indices)
 6236:         masked_array(data=[4, 3, --],
 6237:                     mask=[False, False,  True],
 6238:             fill_value=999999)
 6239: 
 6240:         When `indices` is not one-dimensional, the output also has these dimensions:
 6241: 
 6242:         >>> np.ma.take(a, [[0, 1], [2, 3]])
 6243:         masked_array(data=[[4, 3],
 6244:                         [--, 7]],
 6245:                     mask=[[False, False],
 6246:                         [ True, False]],
 6247:             fill_value=999999)
 6248:         """
 6249:         (_data, _mask) = (self._data, self._mask)
 6250:         cls = type(self)
 6251:         # Make sure the indices are not masked
 6252:         maskindices = getmask(indices)
 6253:         if maskindices is not nomask:
 6254:             indices = indices.filled(0)
 6255:         # Get the data, promoting scalars to 0d arrays with [...] so that
 6256:         # .view works correctly
 6257:         if out is None:
 6258:             out = _data.take(indices, axis=axis, mode=mode)[...].view(cls)
 6259:         else:
 6260:             np.take(_data, indices, axis=axis, mode=mode, out=out)
 6261:         # Get the mask
 6262:         if isinstance(out, MaskedArray):
 6263:             if _mask is nomask:
 6264:                 outmask = maskindices
 6265:             else:
 6266:                 outmask = _mask.take(indices, axis=axis, mode=mode)
 6267:                 outmask |= maskindices
 6268:             out.__setmask__(outmask)
 6269:         # demote 0d arrays back to scalars, for consistency with ndarray.take
 6270:         return out[()]
 6271: 
 6272:     # Array methods
 6273:     copy = _arraymethod('copy')
 6274:     diagonal = _arraymethod('diagonal')
 6275:     flatten = _arraymethod('flatten')
 6276:     repeat = _arraymethod('repeat')
 6277:     squeeze = _arraymethod('squeeze')
 6278:     swapaxes = _arraymethod('swapaxes')
 6279:     T = property(fget=lambda self: self.transpose())
 6280:     transpose = _arraymethod('transpose')
 6281: 
 6282:     @property
 6283:     def mT(self):
 6284:         """
 6285:         Return the matrix-transpose of the masked array.
 6286: 
 6287:         The matrix transpose is the transpose of the last two dimensions, even
 6288:         if the array is of higher dimension.
 6289: 
 6290:         .. versionadded:: 2.0
 6291: 
 6292:         Returns
 6293:         -------
 6294:         result: MaskedArray
 6295:             The masked array with the last two dimensions transposed
 6296: 
 6297:         Raises
 6298:         ------
 6299:         ValueError
 6300:             If the array is of dimension less than 2.
 6301: 
 6302:         See Also
 6303:         --------
 6304:         ndarray.mT:
 6305:             Equivalent method for arrays
 6306:         """
 6307: 
 6308:         if self.ndim < 2:
 6309:             raise ValueError("matrix transpose with ndim < 2 is undefined")
 6310: 
 6311:         if self._mask is nomask:
 6312:             return masked_array(data=self._data.mT)
 6313:         else:
 6314:             return masked_array(data=self.data.mT, mask=self.mask.mT)
 6315: 
 6316:     def tolist(self, fill_value=None):
 6317:         """
 6318:         Return the data portion of the masked array as a hierarchical Python list.
 6319: 
 6320:         Data items are converted to the nearest compatible Python type.
 6321:         Masked values are converted to `fill_value`. If `fill_value` is None,
 6322:         the corresponding entries in the output list will be ``None``.
 6323: 
 6324:         Parameters
 6325:         ----------
 6326:         fill_value : scalar, optional
 6327:             The value to use for invalid entries. Default is None.
 6328: 
 6329:         Returns
 6330:         -------
 6331:         result : list
 6332:             The Python list representation of the masked array.
 6333: 
 6334:         Examples
 6335:         --------
 6336:         >>> import numpy as np
 6337:         >>> x = np.ma.array([[1,2,3], [4,5,6], [7,8,9]], mask=[0] + [1,0]*4)
 6338:         >>> x.tolist()
 6339:         [[1, None, 3], [None, 5, None], [7, None, 9]]
 6340:         >>> x.tolist(-999)
 6341:         [[1, -999, 3], [-999, 5, -999], [7, -999, 9]]
 6342: 
 6343:         """
 6344:         _mask = self._mask
 6345:         # No mask ? Just return .data.tolist ?
 6346:         if _mask is nomask:
 6347:             return self._data.tolist()
 6348:         # Explicit fill_value: fill the array and get the list
 6349:         if fill_value is not None:
 6350:             return self.filled(fill_value).tolist()
 6351:         # Structured array.
 6352:         names = self.dtype.names
 6353:         if names:
 6354:             result = self._data.astype([(_, object) for _ in names])
 6355:             for n in names:
 6356:                 result[n][_mask[n]] = None
 6357:             return result.tolist()
 6358:         # Standard arrays.
 6359:         if _mask is nomask:
 6360:             return [None]
 6361:         # Set temps to save time when dealing w/ marrays.
 6362:         inishape = self.shape
 6363:         result = np.array(self._data.ravel(), dtype=object)
 6364:         result[_mask.ravel()] = None
 6365:         result.shape = inishape
 6366:         return result.tolist()
 6367: 
 6368:     def tobytes(self, fill_value=None, order='C'):
 6369:         """
 6370:         Return the array data as a string containing the raw bytes in the array.
 6371: 
 6372:         The array is filled with a fill value before the string conversion.
 6373: 
 6374:         Parameters
 6375:         ----------
 6376:         fill_value : scalar, optional
 6377:             Value used to fill in the masked values. Default is None, in which
 6378:             case `MaskedArray.fill_value` is used.
 6379:         order : {'C','F','A'}, optional
 6380:             Order of the data item in the copy. Default is 'C'.
 6381: 
 6382:             - 'C'   -- C order (row major).
 6383:             - 'F'   -- Fortran order (column major).
 6384:             - 'A'   -- Any, current order of array.
 6385:             - None  -- Same as 'A'.
 6386: 
 6387:         See Also
 6388:         --------
 6389:         numpy.ndarray.tobytes
 6390:         tolist, tofile
 6391: 
 6392:         Notes
 6393:         -----
 6394:         As for `ndarray.tobytes`, information about the shape, dtype, etc.,
 6395:         but also about `fill_value`, will be lost.
 6396: 
 6397:         Examples
 6398:         --------
 6399:         >>> import numpy as np
 6400:         >>> x = np.ma.array(np.array([[1, 2], [3, 4]]), mask=[[0, 1], [1, 0]])
 6401:         >>> x.tobytes()
 6402:         b'\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00?B\\x0f\\x00\\x00\\x00\\x00\\x00?B\\x0f\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00'
 6403: 
 6404:         """
 6405:         return self.filled(fill_value).tobytes(order=order)
 6406: 
 6407:     def tofile(self, fid, sep="", format="%s"):
 6408:         """
 6409:         Save a masked array to a file in binary format.
 6410: 
 6411:         .. warning::
 6412:           This function is not implemented yet.
 6413: 
 6414:         Raises
 6415:         ------
 6416:         NotImplementedError
 6417:             When `tofile` is called.
 6418: 
 6419:         """
 6420:         raise NotImplementedError("MaskedArray.tofile() not implemented yet.")
 6421: 
 6422:     def toflex(self):
 6423:         """
 6424:         Transforms a masked array into a flexible-type array.
 6425: 
 6426:         The flexible type array that is returned will have two fields:
 6427: 
 6428:         * the ``_data`` field stores the ``_data`` part of the array.
 6429:         * the ``_mask`` field stores the ``_mask`` part of the array.
 6430: 
 6431:         Parameters
 6432:         ----------
 6433:         None
 6434: 
 6435:         Returns
 6436:         -------
 6437:         record : ndarray
 6438:             A new flexible-type `ndarray` with two fields: the first element
 6439:             containing a value, the second element containing the corresponding
 6440:             mask boolean. The returned record shape matches self.shape.
 6441: 
 6442:         Notes
 6443:         -----
 6444:         A side-effect of transforming a masked array into a flexible `ndarray` is
 6445:         that meta information (``fill_value``, ...) will be lost.
 6446: 
 6447:         Examples
 6448:         --------
 6449:         >>> import numpy as np
 6450:         >>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
 6451:         >>> x
 6452:         masked_array(
 6453:           data=[[1, --, 3],
 6454:                 [--, 5, --],
 6455:                 [7, --, 9]],
 6456:           mask=[[False,  True, False],
 6457:                 [ True, False,  True],
 6458:                 [False,  True, False]],
 6459:           fill_value=999999)
 6460:         >>> x.toflex()
 6461:         array([[(1, False), (2,  True), (3, False)],
 6462:                [(4,  True), (5, False), (6,  True)],
 6463:                [(7, False), (8,  True), (9, False)]],
 6464:               dtype=[('_data', '<i8'), ('_mask', '?')])
 6465: 
 6466:         """
 6467:         # Get the basic dtype.
 6468:         ddtype = self.dtype
 6469:         # Make sure we have a mask
 6470:         _mask = self._mask
 6471:         if _mask is None:
 6472:             _mask = make_mask_none(self.shape, ddtype)
 6473:         # And get its dtype
 6474:         mdtype = self._mask.dtype
 6475: 
 6476:         record = np.ndarray(shape=self.shape,
 6477:                             dtype=[('_data', ddtype), ('_mask', mdtype)])
 6478:         record['_data'] = self._data
 6479:         record['_mask'] = self._mask
 6480:         return record
 6481:     torecords = toflex
 6482: 
 6483:     # Pickling
 6484:     def __getstate__(self):
 6485:         """Return the internal state of the masked array, for pickling
 6486:         purposes.
 6487: 
 6488:         """
 6489:         cf = 'CF'[self.flags.fnc]
 6490:         data_state = super().__reduce__()[2]
 6491:         return data_state + (getmaskarray(self).tobytes(cf), self._fill_value)
 6492: 
 6493:     def __setstate__(self, state):
 6494:         """Restore the internal state of the masked array, for
 6495:         pickling purposes.  ``state`` is typically the output of the
 6496:         ``__getstate__`` output, and is a 5-tuple:
 6497: 
 6498:         - class name
 6499:         - a tuple giving the shape of the data
 6500:         - a typecode for the data
 6501:         - a binary string for the data
 6502:         - a binary string for the mask.
 6503: 
 6504:         """
 6505:         (_, shp, typ, isf, raw, msk, flv) = state
 6506:         super().__setstate__((shp, typ, isf, raw))
 6507:         self._mask.__setstate__((shp, make_mask_descr(typ), isf, msk))
 6508:         self.fill_value = flv
 6509: 
 6510:     def __reduce__(self):
 6511:         """Return a 3-tuple for pickling a MaskedArray.
 6512: 
 6513:         """
 6514:         return (_mareconstruct,
 6515:                 (self.__class__, self._baseclass, (0,), 'b',),
 6516:                 self.__getstate__())
 6517: 
 6518:     def __deepcopy__(self, memo=None):
 6519:         from copy import deepcopy
 6520:         copied = MaskedArray.__new__(type(self), self, copy=True)
 6521:         if memo is None:
 6522:             memo = {}
 6523:         memo[id(self)] = copied
 6524:         for (k, v) in self.__dict__.items():
 6525:             copied.__dict__[k] = deepcopy(v, memo)
 6526:         # as clearly documented for np.copy(), you need to use
 6527:         # deepcopy() directly for arrays of object type that may
 6528:         # contain compound types--you cannot depend on normal
 6529:         # copy semantics to do the right thing here
 6530:         if self.dtype.hasobject:
 6531:             copied._data[...] = deepcopy(copied._data)
 6532:         return copied
 6533: 
 6534: 
 6535: def _mareconstruct(subtype, baseclass, baseshape, basetype,):
 6536:     """Internal function that builds a new MaskedArray from the
 6537:     information stored in a pickle.
 6538: 
 6539:     """
 6540:     _data = ndarray.__new__(baseclass, baseshape, basetype)
 6541:     _mask = ndarray.__new__(ndarray, baseshape, make_mask_descr(basetype))
 6542:     return subtype.__new__(subtype, _data, mask=_mask, dtype=basetype,)
 6543: 
 6544: 
 6545: class mvoid(MaskedArray):
 6546:     """
 6547:     Fake a 'void' object to use for masked array with structured dtypes.
 6548:     """
 6549: 
 6550:     def __new__(self, data, mask=nomask, dtype=None, fill_value=None,
 6551:                 hardmask=False, copy=False, subok=True):
 6552:         copy = None if not copy else True
 6553:         _data = np.array(data, copy=copy, subok=subok, dtype=dtype)
 6554:         _data = _data.view(self)
 6555:         _data._hardmask = hardmask
 6556:         if mask is not nomask:
 6557:             if isinstance(mask, np.void):
 6558:                 _data._mask = mask
 6559:             else:
 6560:                 try:
 6561:                     # Mask is already a 0D array
 6562:                     _data._mask = np.void(mask)
 6563:                 except TypeError:
 6564:                     # Transform the mask to a void
 6565:                     mdtype = make_mask_descr(dtype)
 6566:                     _data._mask = np.array(mask, dtype=mdtype)[()]
 6567:         if fill_value is not None:
 6568:             _data.fill_value = fill_value
 6569:         return _data
 6570: 
 6571:     @property
 6572:     def _data(self):
 6573:         # Make sure that the _data part is a np.void
 6574:         return super()._data[()]
 6575: 
 6576:     def __getitem__(self, indx):
 6577:         """
 6578:         Get the index.
 6579: 
 6580:         """
 6581:         m = self._mask
 6582:         if isinstance(m[indx], ndarray):
 6583:             # Can happen when indx is a multi-dimensional field:
 6584:             # A = ma.masked_array(data=[([0,1],)], mask=[([True,
 6585:             #                     False],)], dtype=[("A", ">i2", (2,))])
 6586:             # x = A[0]; y = x["A"]; then y.mask["A"].size==2
 6587:             # and we can not say masked/unmasked.
 6588:             # The result is no longer mvoid!
 6589:             # See also issue #6724.
 6590:             return masked_array(
 6591:                 data=self._data[indx], mask=m[indx],
 6592:                 fill_value=self._fill_value[indx],
 6593:                 hard_mask=self._hardmask)
 6594:         if m is not nomask and m[indx]:
 6595:             return masked
 6596:         return self._data[indx]
 6597: 
 6598:     def __setitem__(self, indx, value):
 6599:         self._data[indx] = value
 6600:         if self._hardmask:
 6601:             self._mask[indx] |= getattr(value, "_mask", False)
 6602:         else:
 6603:             self._mask[indx] = getattr(value, "_mask", False)
 6604: 
 6605:     def __str__(self):
 6606:         m = self._mask
 6607:         if m is nomask:
 6608:             return str(self._data)
 6609: 
 6610:         rdtype = _replace_dtype_fields(self._data.dtype, "O")
 6611:         data_arr = super()._data
 6612:         res = data_arr.astype(rdtype)
 6613:         _recursive_printoption(res, self._mask, masked_print_option)
 6614:         return str(res)
 6615: 
 6616:     __repr__ = __str__
 6617: 
 6618:     def __iter__(self):
 6619:         "Defines an iterator for mvoid"
 6620:         (_data, _mask) = (self._data, self._mask)
 6621:         if _mask is nomask:
 6622:             yield from _data
 6623:         else:
 6624:             for (d, m) in zip(_data, _mask):
 6625:                 if m:
 6626:                     yield masked
 6627:                 else:
 6628:                     yield d
 6629: 
 6630:     def __len__(self):
 6631:         return self._data.__len__()
 6632: 
 6633:     def filled(self, fill_value=None):
 6634:         """
 6635:         Return a copy with masked fields filled with a given value.
 6636: 
 6637:         Parameters
 6638:         ----------
 6639:         fill_value : array_like, optional
 6640:             The value to use for invalid entries. Can be scalar or
 6641:             non-scalar. If latter is the case, the filled array should
 6642:             be broadcastable over input array. Default is None, in
 6643:             which case the `fill_value` attribute is used instead.
 6644: 
 6645:         Returns
 6646:         -------
 6647:         filled_void
 6648:             A `np.void` object
 6649: 
 6650:         See Also
 6651:         --------
 6652:         MaskedArray.filled
 6653: 
 6654:         """
 6655:         return asarray(self).filled(fill_value)[()]
 6656: 
 6657:     def tolist(self):
 6658:         """
 6659:     Transforms the mvoid object into a tuple.
 6660: 
 6661:     Masked fields are replaced by None.
 6662: 
 6663:     Returns
 6664:     -------
 6665:     returned_tuple
 6666:         Tuple of fields
 6667:         """
 6668:         _mask = self._mask
 6669:         if _mask is nomask:
 6670:             return self._data.tolist()
 6671:         result = []
 6672:         for (d, m) in zip(self._data, self._mask):
 6673:             if m:
 6674:                 result.append(None)
 6675:             else:
 6676:                 # .item() makes sure we return a standard Python object
 6677:                 result.append(d.item())
 6678:         return tuple(result)
 6679: 
 6680: 
 6681: ##############################################################################
 6682: #                                Shortcuts                                   #
 6683: ##############################################################################
 6684: 
 6685: 
 6686: def isMaskedArray(x):
 6687:     """
 6688:     Test whether input is an instance of MaskedArray.
 6689: 
 6690:     This function returns True if `x` is an instance of MaskedArray
 6691:     and returns False otherwise.  Any object is accepted as input.
 6692: 
 6693:     Parameters
 6694:     ----------
 6695:     x : object
 6696:         Object to test.
 6697: 
 6698:     Returns
 6699:     -------
 6700:     result : bool
 6701:         True if `x` is a MaskedArray.
 6702: 
 6703:     See Also
 6704:     --------
 6705:     isMA : Alias to isMaskedArray.
 6706:     isarray : Alias to isMaskedArray.
 6707: 
 6708:     Examples
 6709:     --------
 6710:     >>> import numpy as np
 6711:     >>> import numpy.ma as ma
 6712:     >>> a = np.eye(3, 3)
 6713:     >>> a
 6714:     array([[ 1.,  0.,  0.],
 6715:            [ 0.,  1.,  0.],
 6716:            [ 0.,  0.,  1.]])
 6717:     >>> m = ma.masked_values(a, 0)
 6718:     >>> m
 6719:     masked_array(
 6720:       data=[[1.0, --, --],
 6721:             [--, 1.0, --],
 6722:             [--, --, 1.0]],
 6723:       mask=[[False,  True,  True],
 6724:             [ True, False,  True],
 6725:             [ True,  True, False]],
 6726:       fill_value=0.0)
 6727:     >>> ma.isMaskedArray(a)
 6728:     False
 6729:     >>> ma.isMaskedArray(m)
 6730:     True
 6731:     >>> ma.isMaskedArray([0, 1, 2])
 6732:     False
 6733: 
 6734:     """
 6735:     return isinstance(x, MaskedArray)
 6736: 
 6737: 
 6738: isarray = isMaskedArray
 6739: isMA = isMaskedArray  # backward compatibility
 6740: 
 6741: 
 6742: class MaskedConstant(MaskedArray):
 6743:     # the lone np.ma.masked instance
 6744:     __singleton = None
 6745: 
 6746:     @classmethod
 6747:     def __has_singleton(cls):
 6748:         # second case ensures `cls.__singleton` is not just a view on the
 6749:         # superclass singleton
 6750:         return cls.__singleton is not None and type(cls.__singleton) is cls
 6751: 
 6752:     def __new__(cls):
 6753:         if not cls.__has_singleton():
 6754:             # We define the masked singleton as a float for higher precedence.
 6755:             # Note that it can be tricky sometimes w/ type comparison
 6756:             data = np.array(0.)
 6757:             mask = np.array(True)
 6758: 
 6759:             # prevent any modifications
 6760:             data.flags.writeable = False
 6761:             mask.flags.writeable = False
 6762: 
 6763:             # don't fall back on MaskedArray.__new__(MaskedConstant), since
 6764:             # that might confuse it - this way, the construction is entirely
 6765:             # within our control
 6766:             cls.__singleton = MaskedArray(data, mask=mask).view(cls)
 6767: 
 6768:         return cls.__singleton
 6769: 
 6770:     def __array_finalize__(self, obj):
 6771:         if not self.__has_singleton():
 6772:             # this handles the `.view` in __new__, which we want to copy across
 6773:             # properties normally
 6774:             return super().__array_finalize__(obj)
 6775:         elif self is self.__singleton:
 6776:             # not clear how this can happen, play it safe
 6777:             pass
 6778:         else:
 6779:             # everywhere else, we want to downcast to MaskedArray, to prevent a
 6780:             # duplicate maskedconstant.
 6781:             self.__class__ = MaskedArray
 6782:             MaskedArray.__array_finalize__(self, obj)
 6783: 
 6784:     def __array_wrap__(self, obj, context=None, return_scalar=False):
 6785:         return self.view(MaskedArray).__array_wrap__(obj, context)
 6786: 
 6787:     def __str__(self):
 6788:         return str(masked_print_option._display)
 6789: 
 6790:     def __repr__(self):
 6791:         if self is MaskedConstant.__singleton:
 6792:             return 'masked'
 6793:         else:
 6794:             # it's a subclass, or something is wrong, make it obvious
 6795:             return object.__repr__(self)
 6796: 
 6797:     def __format__(self, format_spec):
 6798:         # Replace ndarray.__format__ with the default, which supports no
 6799:         # format characters.
 6800:         # Supporting format characters is unwise here, because we do not know
 6801:         # what type the user was expecting - better to not guess.
 6802:         try:
 6803:             return object.__format__(self, format_spec)
 6804:         except TypeError:
 6805:             # 2020-03-23, NumPy 1.19.0
 6806:             warnings.warn(
 6807:                 "Format strings passed to MaskedConstant are ignored,"
 6808:                 " but in future may error or produce different behavior",
 6809:                 FutureWarning, stacklevel=2
 6810:             )
 6811:             return object.__format__(self, "")
 6812: 
 6813:     def __reduce__(self):
 6814:         """Override of MaskedArray's __reduce__.
 6815:         """
 6816:         return (self.__class__, ())
 6817: 
 6818:     # inplace operations have no effect. We have to override them to avoid
 6819:     # trying to modify the readonly data and mask arrays
 6820:     def __iop__(self, other):
 6821:         return self
 6822:     __iadd__ = \
 6823:     __isub__ = \
 6824:     __imul__ = \
 6825:     __ifloordiv__ = \
 6826:     __itruediv__ = \
 6827:     __ipow__ = \
 6828:         __iop__
 6829:     del __iop__  # don't leave this around
 6830: 
 6831:     def copy(self, *args, **kwargs):
 6832:         """ Copy is a no-op on the maskedconstant, as it is a scalar """
 6833:         # maskedconstant is a scalar, so copy doesn't need to copy. There's
 6834:         # precedent for this with `np.bool` scalars.
 6835:         return self
 6836: 
 6837:     def __copy__(self):
 6838:         return self
 6839: 
 6840:     def __deepcopy__(self, memo):
 6841:         return self
 6842: 
 6843:     def __setattr__(self, attr, value):
 6844:         if not self.__has_singleton():
 6845:             # allow the singleton to be initialized
 6846:             return super().__setattr__(attr, value)
 6847:         elif self is self.__singleton:
 6848:             raise AttributeError(
 6849:                 f"attributes of {self!r} are not writeable")
 6850:         else:
 6851:             # duplicate instance - we can end up here from __array_finalize__,
 6852:             # where we set the __class__ attribute
 6853:             return super().__setattr__(attr, value)
 6854: 
 6855: 
 6856: masked = masked_singleton = MaskedConstant()
 6857: masked_array = MaskedArray
 6858: 
 6859: 
 6860: def array(data, dtype=None, copy=False, order=None,
 6861:           mask=nomask, fill_value=None, keep_mask=True,
 6862:           hard_mask=False, shrink=True, subok=True, ndmin=0):
 6863:     """
 6864:     Shortcut to MaskedArray.
 6865: 
 6866:     The options are in a different order for convenience and backwards
 6867:     compatibility.
 6868: 
 6869:     """
 6870:     return MaskedArray(data, mask=mask, dtype=dtype, copy=copy,
 6871:                        subok=subok, keep_mask=keep_mask,
 6872:                        hard_mask=hard_mask, fill_value=fill_value,
 6873:                        ndmin=ndmin, shrink=shrink, order=order)
 6874: 
 6875: 
 6876: array.__doc__ = masked_array.__doc__
 6877: 
 6878: 
 6879: def is_masked(x):
 6880:     """
 6881:     Determine whether input has masked values.
 6882: 
 6883:     Accepts any object as input, but always returns False unless the
 6884:     input is a MaskedArray containing masked values.
 6885: 
 6886:     Parameters
 6887:     ----------
 6888:     x : array_like
 6889:         Array to check for masked values.
 6890: 
 6891:     Returns
 6892:     -------
 6893:     result : bool
 6894:         True if `x` is a MaskedArray with masked values, False otherwise.
 6895: 
 6896:     Examples
 6897:     --------
 6898:     >>> import numpy as np
 6899:     >>> import numpy.ma as ma
 6900:     >>> x = ma.masked_equal([0, 1, 0, 2, 3], 0)
 6901:     >>> x
 6902:     masked_array(data=[--, 1, --, 2, 3],
 6903:                  mask=[ True, False,  True, False, False],
 6904:            fill_value=0)
 6905:     >>> ma.is_masked(x)
 6906:     True
 6907:     >>> x = ma.masked_equal([0, 1, 0, 2, 3], 42)
 6908:     >>> x
 6909:     masked_array(data=[0, 1, 0, 2, 3],
 6910:                  mask=False,
 6911:            fill_value=42)
 6912:     >>> ma.is_masked(x)
 6913:     False
 6914: 
 6915:     Always returns False if `x` isn't a MaskedArray.
 6916: 
 6917:     >>> x = [False, True, False]
 6918:     >>> ma.is_masked(x)
 6919:     False
 6920:     >>> x = 'a string'
 6921:     >>> ma.is_masked(x)
 6922:     False
 6923: 
 6924:     """
 6925:     m = getmask(x)
 6926:     if m is nomask:
 6927:         return False
 6928:     elif m.any():
 6929:         return True
 6930:     return False
 6931: 
 6932: 
 6933: ##############################################################################
 6934: #                             Extrema functions                              #
 6935: ##############################################################################
 6936: 
 6937: 
 6938: class _extrema_operation(_MaskedUFunc):
 6939:     """
 6940:     Generic class for maximum/minimum functions.
 6941: 
 6942:     .. note::
 6943:       This is the base class for `_maximum_operation` and
 6944:       `_minimum_operation`.
 6945: 
 6946:     """
 6947:     def __init__(self, ufunc, compare, fill_value):
 6948:         super().__init__(ufunc)
 6949:         self.compare = compare
 6950:         self.fill_value_func = fill_value
 6951: 
 6952:     def __call__(self, a, b):
 6953:         "Executes the call behavior."
 6954: 
 6955:         return where(self.compare(a, b), a, b)
 6956: 
 6957:     def reduce(self, target, axis=np._NoValue):
 6958:         "Reduce target along the given axis."
 6959:         target = narray(target, copy=None, subok=True)
 6960:         m = getmask(target)
 6961: 
 6962:         if axis is np._NoValue and target.ndim > 1:
 6963:             name = self.__name__
 6964:             # 2017-05-06, Numpy 1.13.0: warn on axis default
 6965:             warnings.warn(
 6966:                 f"In the future the default for ma.{name}.reduce will be axis=0, "
 6967:                 f"not the current None, to match np.{name}.reduce. "
 6968:                 "Explicitly pass 0 or None to silence this warning.",
 6969:                 MaskedArrayFutureWarning, stacklevel=2)
 6970:             axis = None
 6971: 
 6972:         if axis is not np._NoValue:
 6973:             kwargs = {'axis': axis}
 6974:         else:
 6975:             kwargs = {}
 6976: 
 6977:         if m is nomask:
 6978:             t = self.f.reduce(target, **kwargs)
 6979:         else:
 6980:             target = target.filled(
 6981:                 self.fill_value_func(target)).view(type(target))
 6982:             t = self.f.reduce(target, **kwargs)
 6983:             m = umath.logical_and.reduce(m, **kwargs)
 6984:             if hasattr(t, '_mask'):
 6985:                 t._mask = m
 6986:             elif m:
 6987:                 t = masked
 6988:         return t
 6989: 
 6990:     def outer(self, a, b):
 6991:         "Return the function applied to the outer product of a and b."
 6992:         ma = getmask(a)
 6993:         mb = getmask(b)
 6994:         if ma is nomask and mb is nomask:
 6995:             m = nomask
 6996:         else:
 6997:             ma = getmaskarray(a)
 6998:             mb = getmaskarray(b)
 6999:             m = logical_or.outer(ma, mb)
 7000:         result = self.f.outer(filled(a), filled(b))
 7001:         if not isinstance(result, MaskedArray):
 7002:             result = result.view(MaskedArray)
 7003:         result._mask = m
 7004:         return result
 7005: 
 7006: def min(obj, axis=None, out=None, fill_value=None, keepdims=np._NoValue):
 7007:     kwargs = {} if keepdims is np._NoValue else {'keepdims': keepdims}
 7008: 
 7009:     try:
 7010:         return obj.min(axis=axis, fill_value=fill_value, out=out, **kwargs)
 7011:     except (AttributeError, TypeError):
 7012:         # If obj doesn't have a min method, or if the method doesn't accept a
 7013:         # fill_value argument
 7014:         return asanyarray(obj).min(axis=axis, fill_value=fill_value,
 7015:                                    out=out, **kwargs)
 7016: 
 7017: 
 7018: min.__doc__ = MaskedArray.min.__doc__
 7019: 
 7020: def max(obj, axis=None, out=None, fill_value=None, keepdims=np._NoValue):
 7021:     kwargs = {} if keepdims is np._NoValue else {'keepdims': keepdims}
 7022: 
 7023:     try:
 7024:         return obj.max(axis=axis, fill_value=fill_value, out=out, **kwargs)
 7025:     except (AttributeError, TypeError):
 7026:         # If obj doesn't have a max method, or if the method doesn't accept a
 7027:         # fill_value argument
 7028:         return asanyarray(obj).max(axis=axis, fill_value=fill_value,
 7029:                                    out=out, **kwargs)
 7030: 
 7031: 
 7032: max.__doc__ = MaskedArray.max.__doc__
 7033: 
 7034: 
 7035: def ptp(obj, axis=None, out=None, fill_value=None, keepdims=np._NoValue):
 7036:     kwargs = {} if keepdims is np._NoValue else {'keepdims': keepdims}
 7037:     try:
 7038:         return obj.ptp(axis, out=out, fill_value=fill_value, **kwargs)
 7039:     except (AttributeError, TypeError):
 7040:         # If obj doesn't have a ptp method or if the method doesn't accept
 7041:         # a fill_value argument
 7042:         return asanyarray(obj).ptp(axis=axis, fill_value=fill_value,
 7043:                                    out=out, **kwargs)
 7044: 
 7045: 
 7046: ptp.__doc__ = MaskedArray.ptp.__doc__
 7047: 
 7048: 
 7049: ##############################################################################
 7050: #           Definition of functions from the corresponding methods           #
 7051: ##############################################################################
 7052: 
 7053: 
 7054: class _frommethod:
 7055:     """
 7056:     Define functions from existing MaskedArray methods.
 7057: 
 7058:     Parameters
 7059:     ----------
 7060:     methodname : str
 7061:         Name of the method to transform.
 7062: 
 7063:     """
 7064: 
 7065:     def __init__(self, methodname, reversed=False):
 7066:         self.__name__ = methodname
 7067:         self.__qualname__ = methodname
 7068:         self.__doc__ = self.getdoc()
 7069:         self.reversed = reversed
 7070: 
 7071:     def getdoc(self):
 7072:         "Return the doc of the function (from the doc of the method)."
 7073:         meth = getattr(MaskedArray, self.__name__, None) or\
 7074:             getattr(np, self.__name__, None)
 7075:         signature = self.__name__ + get_object_signature(meth)
 7076:         if meth is not None:
 7077:             doc = f"""    {signature}
 7078: {getattr(meth, '__doc__', None)}"""
 7079:             return doc
 7080: 
 7081:     def __call__(self, a, *args, **params):
 7082:         if self.reversed:
 7083:             args = list(args)
 7084:             a, args[0] = args[0], a
 7085: 
 7086:         marr = asanyarray(a)
 7087:         method_name = self.__name__
 7088:         method = getattr(type(marr), method_name, None)
 7089:         if method is None:
 7090:             # use the corresponding np function
 7091:             method = getattr(np, method_name)
 7092: 
 7093:         return method(marr, *args, **params)
 7094: 
 7095: 
 7096: all = _frommethod('all')
 7097: anomalies = anom = _frommethod('anom')
 7098: any = _frommethod('any')
 7099: compress = _frommethod('compress', reversed=True)
 7100: cumprod = _frommethod('cumprod')
 7101: cumsum = _frommethod('cumsum')
 7102: copy = _frommethod('copy')
 7103: diagonal = _frommethod('diagonal')
 7104: harden_mask = _frommethod('harden_mask')
 7105: ids = _frommethod('ids')
 7106: maximum = _extrema_operation(umath.maximum, greater, maximum_fill_value)
 7107: mean = _frommethod('mean')
 7108: minimum = _extrema_operation(umath.minimum, less, minimum_fill_value)
 7109: nonzero = _frommethod('nonzero')
 7110: prod = _frommethod('prod')
 7111: product = _frommethod('product')
 7112: ravel = _frommethod('ravel')
 7113: repeat = _frommethod('repeat')
 7114: shrink_mask = _frommethod('shrink_mask')
 7115: soften_mask = _frommethod('soften_mask')
 7116: std = _frommethod('std')
 7117: sum = _frommethod('sum')
 7118: swapaxes = _frommethod('swapaxes')
 7119: #take = _frommethod('take')
 7120: trace = _frommethod('trace')
 7121: var = _frommethod('var')
 7122: 
 7123: count = _frommethod('count')
 7124: 
 7125: def take(a, indices, axis=None, out=None, mode='raise'):
 7126:     """
 7127: 
 7128:     """
 7129:     a = masked_array(a)
 7130:     return a.take(indices, axis=axis, out=out, mode=mode)
 7131: 
 7132: 
 7133: def power(a, b, third=None):
 7134:     """
 7135:     Returns element-wise base array raised to power from second array.
 7136: 
 7137:     This is the masked array version of `numpy.power`. For details see
 7138:     `numpy.power`.
 7139: 
 7140:     See Also
 7141:     --------
 7142:     numpy.power
 7143: 
 7144:     Notes
 7145:     -----
 7146:     The *out* argument to `numpy.power` is not supported, `third` has to be
 7147:     None.
 7148: 
 7149:     Examples
 7150:     --------
 7151:     >>> import numpy as np
 7152:     >>> import numpy.ma as ma
 7153:     >>> x = [11.2, -3.973, 0.801, -1.41]
 7154:     >>> mask = [0, 0, 0, 1]
 7155:     >>> masked_x = ma.masked_array(x, mask)
 7156:     >>> masked_x
 7157:     masked_array(data=[11.2, -3.973, 0.801, --],
 7158:              mask=[False, False, False,  True],
 7159:        fill_value=1e+20)
 7160:     >>> ma.power(masked_x, 2)
 7161:     masked_array(data=[125.43999999999998, 15.784728999999999,
 7162:                    0.6416010000000001, --],
 7163:              mask=[False, False, False,  True],
 7164:        fill_value=1e+20)
 7165:     >>> y = [-0.5, 2, 0, 17]
 7166:     >>> masked_y = ma.masked_array(y, mask)
 7167:     >>> masked_y
 7168:     masked_array(data=[-0.5, 2.0, 0.0, --],
 7169:              mask=[False, False, False,  True],
 7170:        fill_value=1e+20)
 7171:     >>> ma.power(masked_x, masked_y)
 7172:     masked_array(data=[0.2988071523335984, 15.784728999999999, 1.0, --],
 7173:              mask=[False, False, False,  True],
 7174:        fill_value=1e+20)
 7175: 
 7176:     """
 7177:     if third is not None:
 7178:         raise MaskError("3-argument power not supported.")
 7179:     # Get the masks
 7180:     ma = getmask(a)
 7181:     mb = getmask(b)
 7182:     m = mask_or(ma, mb)
 7183:     # Get the rawdata
 7184:     fa = getdata(a)
 7185:     fb = getdata(b)
 7186:     # Get the type of the result (so that we preserve subclasses)
 7187:     if isinstance(a, MaskedArray):
 7188:         basetype = type(a)
 7189:     else:
 7190:         basetype = MaskedArray
 7191:     # Get the result and view it as a (subclass of) MaskedArray
 7192:     with np.errstate(divide='ignore', invalid='ignore'):
 7193:         result = np.where(m, fa, umath.power(fa, fb)).view(basetype)
 7194:     result._update_from(a)
 7195:     # Find where we're in trouble w/ NaNs and Infs
 7196:     invalid = np.logical_not(np.isfinite(result.view(ndarray)))
 7197:     # Add the initial mask
 7198:     if m is not nomask:
 7199:         if not result.ndim:
 7200:             return masked
 7201:         result._mask = np.logical_or(m, invalid)
 7202:     # Fix the invalid parts
 7203:     if invalid.any():
 7204:         if not result.ndim:
 7205:             return masked
 7206:         elif result._mask is nomask:
 7207:             result._mask = invalid
 7208:         result._data[invalid] = result.fill_value
 7209:     return result
 7210: 
 7211: 
 7212: argmin = _frommethod('argmin')
 7213: argmax = _frommethod('argmax')
 7214: 
 7215: def argsort(a, axis=np._NoValue, kind=None, order=None, endwith=True,
 7216:             fill_value=None, *, stable=None):
 7217:     "Function version of the eponymous method."
 7218:     a = np.asanyarray(a)
 7219: 
 7220:     # 2017-04-11, Numpy 1.13.0, gh-8701: warn on axis default
 7221:     if axis is np._NoValue:
 7222:         axis = _deprecate_argsort_axis(a)
 7223: 
 7224:     if isinstance(a, MaskedArray):
 7225:         return a.argsort(axis=axis, kind=kind, order=order, endwith=endwith,
 7226:                          fill_value=fill_value, stable=None)
 7227:     else:
 7228:         return a.argsort(axis=axis, kind=kind, order=order, stable=None)
 7229: 
 7230: 
 7231: argsort.__doc__ = MaskedArray.argsort.__doc__
 7232: 
 7233: def sort(a, axis=-1, kind=None, order=None, endwith=True, fill_value=None, *,
 7234:          stable=None):
 7235:     """
 7236:     Return a sorted copy of the masked array.
 7237: 
 7238:     Equivalent to creating a copy of the array
 7239:     and applying the  MaskedArray ``sort()`` method.
 7240: 
 7241:     Refer to ``MaskedArray.sort`` for the full documentation
 7242: 
 7243:     See Also
 7244:     --------
 7245:     MaskedArray.sort : equivalent method
 7246: 
 7247:     Examples
 7248:     --------
 7249:     >>> import numpy as np
 7250:     >>> import numpy.ma as ma
 7251:     >>> x = [11.2, -3.973, 0.801, -1.41]
 7252:     >>> mask = [0, 0, 0, 1]
 7253:     >>> masked_x = ma.masked_array(x, mask)
 7254:     >>> masked_x
 7255:     masked_array(data=[11.2, -3.973, 0.801, --],
 7256:                  mask=[False, False, False,  True],
 7257:            fill_value=1e+20)
 7258:     >>> ma.sort(masked_x)
 7259:     masked_array(data=[-3.973, 0.801, 11.2, --],
 7260:                  mask=[False, False, False,  True],
 7261:            fill_value=1e+20)
 7262:     """
 7263:     a = np.array(a, copy=True, subok=True)
 7264:     if axis is None:
 7265:         a = a.flatten()
 7266:         axis = 0
 7267: 
 7268:     if isinstance(a, MaskedArray):
 7269:         a.sort(axis=axis, kind=kind, order=order, endwith=endwith,
 7270:                fill_value=fill_value, stable=stable)
 7271:     else:
 7272:         a.sort(axis=axis, kind=kind, order=order, stable=stable)
 7273:     return a
 7274: 
 7275: 
 7276: def compressed(x):
 7277:     """
 7278:     Return all the non-masked data as a 1-D array.
 7279: 
 7280:     This function is equivalent to calling the "compressed" method of a
 7281:     `ma.MaskedArray`, see `ma.MaskedArray.compressed` for details.
 7282: 
 7283:     See Also
 7284:     --------
 7285:     ma.MaskedArray.compressed : Equivalent method.
 7286: 
 7287:     Examples
 7288:     --------
 7289:     >>> import numpy as np
 7290: 
 7291:     Create an array with negative values masked:
 7292: 
 7293:     >>> import numpy as np
 7294:     >>> x = np.array([[1, -1, 0], [2, -1, 3], [7, 4, -1]])
 7295:     >>> masked_x = np.ma.masked_array(x, mask=x < 0)
 7296:     >>> masked_x
 7297:     masked_array(
 7298:       data=[[1, --, 0],
 7299:             [2, --, 3],
 7300:             [7, 4, --]],
 7301:       mask=[[False,  True, False],
 7302:             [False,  True, False],
 7303:             [False, False,  True]],
 7304:       fill_value=999999)
 7305: 
 7306:     Compress the masked array into a 1-D array of non-masked values:
 7307: 
 7308:     >>> np.ma.compressed(masked_x)
 7309:     array([1, 0, 2, 3, 7, 4])
 7310: 
 7311:     """
 7312:     return asanyarray(x).compressed()
 7313: 
 7314: 
 7315: def concatenate(arrays, axis=0):
 7316:     """
 7317:     Concatenate a sequence of arrays along the given axis.
 7318: 
 7319:     Parameters
 7320:     ----------
 7321:     arrays : sequence of array_like
 7322:         The arrays must have the same shape, except in the dimension
 7323:         corresponding to `axis` (the first, by default).
 7324:     axis : int, optional
 7325:         The axis along which the arrays will be joined. Default is 0.
 7326: 
 7327:     Returns
 7328:     -------
 7329:     result : MaskedArray
 7330:         The concatenated array with any masked entries preserved.
 7331: 
 7332:     See Also
 7333:     --------
 7334:     numpy.concatenate : Equivalent function in the top-level NumPy module.
 7335: 
 7336:     Examples
 7337:     --------
 7338:     >>> import numpy as np
 7339:     >>> import numpy.ma as ma
 7340:     >>> a = ma.arange(3)
 7341:     >>> a[1] = ma.masked
 7342:     >>> b = ma.arange(2, 5)
 7343:     >>> a
 7344:     masked_array(data=[0, --, 2],
 7345:                  mask=[False,  True, False],
 7346:            fill_value=999999)
 7347:     >>> b
 7348:     masked_array(data=[2, 3, 4],
 7349:                  mask=False,
 7350:            fill_value=999999)
 7351:     >>> ma.concatenate([a, b])
 7352:     masked_array(data=[0, --, 2, 2, 3, 4],
 7353:                  mask=[False,  True, False, False, False, False],
 7354:            fill_value=999999)
 7355: 
 7356:     """
 7357:     d = np.concatenate([getdata(a) for a in arrays], axis)
 7358:     rcls = get_masked_subclass(*arrays)
 7359:     data = d.view(rcls)
 7360:     # Check whether one of the arrays has a non-empty mask.
 7361:     for x in arrays:
 7362:         if getmask(x) is not nomask:
 7363:             break
 7364:     else:
 7365:         return data
 7366:     # OK, so we have to concatenate the masks
 7367:     dm = np.concatenate([getmaskarray(a) for a in arrays], axis)
 7368:     dm = dm.reshape(d.shape)
 7369: 
 7370:     # If we decide to keep a '_shrinkmask' option, we want to check that
 7371:     # all of them are True, and then check for dm.any()
 7372:     data._mask = _shrink_mask(dm)
 7373:     return data
 7374: 
 7375: 
 7376: def diag(v, k=0):
 7377:     """
 7378:     Extract a diagonal or construct a diagonal array.
 7379: 
 7380:     This function is the equivalent of `numpy.diag` that takes masked
 7381:     values into account, see `numpy.diag` for details.
 7382: 
 7383:     See Also
 7384:     --------
 7385:     numpy.diag : Equivalent function for ndarrays.
 7386: 
 7387:     Examples
 7388:     --------
 7389:     >>> import numpy as np
 7390: 
 7391:     Create an array with negative values masked:
 7392: 
 7393:     >>> import numpy as np
 7394:     >>> x = np.array([[11.2, -3.973, 18], [0.801, -1.41, 12], [7, 33, -12]])
 7395:     >>> masked_x = np.ma.masked_array(x, mask=x < 0)
 7396:     >>> masked_x
 7397:     masked_array(
 7398:       data=[[11.2, --, 18.0],
 7399:             [0.801, --, 12.0],
 7400:             [7.0, 33.0, --]],
 7401:       mask=[[False,  True, False],
 7402:             [False,  True, False],
 7403:             [False, False,  True]],
 7404:       fill_value=1e+20)
 7405: 
 7406:     Isolate the main diagonal from the masked array:
 7407: 
 7408:     >>> np.ma.diag(masked_x)
 7409:     masked_array(data=[11.2, --, --],
 7410:                  mask=[False,  True,  True],
 7411:            fill_value=1e+20)
 7412: 
 7413:     Isolate the first diagonal below the main diagonal:
 7414: 
 7415:     >>> np.ma.diag(masked_x, -1)
 7416:     masked_array(data=[0.801, 33.0],
 7417:                  mask=[False, False],
 7418:            fill_value=1e+20)
 7419: 
 7420:     """
 7421:     output = np.diag(v, k).view(MaskedArray)
 7422:     if getmask(v) is not nomask:
 7423:         output._mask = np.diag(v._mask, k)
 7424:     return output
 7425: 
 7426: 
 7427: def left_shift(a, n):
 7428:     """
 7429:     Shift the bits of an integer to the left.
 7430: 
 7431:     This is the masked array version of `numpy.left_shift`, for details
 7432:     see that function.
 7433: 
 7434:     See Also
 7435:     --------
 7436:     numpy.left_shift
 7437: 
 7438:     Examples
 7439:     --------
 7440:     Shift with a masked array:
 7441: 
 7442:     >>> arr = np.ma.array([10, 20, 30], mask=[False, True, False])
 7443:     >>> np.ma.left_shift(arr, 1)
 7444:     masked_array(data=[20, --, 60],
 7445:                  mask=[False,  True, False],
 7446:            fill_value=999999)
 7447: 
 7448:     Large shift:
 7449: 
 7450:     >>> np.ma.left_shift(10, 10)
 7451:     masked_array(data=10240,
 7452:                  mask=False,
 7453:            fill_value=999999)
 7454: 
 7455:     Shift with a scalar and an array:
 7456: 
 7457:     >>> scalar = 10
 7458:     >>> arr = np.ma.array([1, 2, 3], mask=[False, True, False])
 7459:     >>> np.ma.left_shift(scalar, arr)
 7460:     masked_array(data=[20, --, 80],
 7461:                  mask=[False,  True, False],
 7462:            fill_value=999999)
 7463: 
 7464: 
 7465:     """
 7466:     m = getmask(a)
 7467:     if m is nomask:
 7468:         d = umath.left_shift(filled(a), n)
 7469:         return masked_array(d)
 7470:     else:
 7471:         d = umath.left_shift(filled(a, 0), n)
 7472:         return masked_array(d, mask=m)
 7473: 
 7474: 
 7475: def right_shift(a, n):
 7476:     """
 7477:     Shift the bits of an integer to the right.
 7478: 
 7479:     This is the masked array version of `numpy.right_shift`, for details
 7480:     see that function.
 7481: 
 7482:     See Also
 7483:     --------
 7484:     numpy.right_shift
 7485: 
 7486:     Examples
 7487:     --------
 7488:     >>> import numpy as np
 7489:     >>> import numpy.ma as ma
 7490:     >>> x = [11, 3, 8, 1]
 7491:     >>> mask = [0, 0, 0, 1]
 7492:     >>> masked_x = ma.masked_array(x, mask)
 7493:     >>> masked_x
 7494:     masked_array(data=[11, 3, 8, --],
 7495:                  mask=[False, False, False,  True],
 7496:            fill_value=999999)
 7497:     >>> ma.right_shift(masked_x,1)
 7498:     masked_array(data=[5, 1, 4, --],
 7499:                  mask=[False, False, False,  True],
 7500:            fill_value=999999)
 7501: 
 7502:     """
 7503:     m = getmask(a)
 7504:     if m is nomask:
 7505:         d = umath.right_shift(filled(a), n)
 7506:         return masked_array(d)
 7507:     else:
 7508:         d = umath.right_shift(filled(a, 0), n)
 7509:         return masked_array(d, mask=m)
 7510: 
 7511: 
 7512: def put(a, indices, values, mode='raise'):
 7513:     """
 7514:     Set storage-indexed locations to corresponding values.
 7515: 
 7516:     This function is equivalent to `MaskedArray.put`, see that method
 7517:     for details.
 7518: 
 7519:     See Also
 7520:     --------
 7521:     MaskedArray.put
 7522: 
 7523:     Examples
 7524:     --------
 7525:     Putting values in a masked array:
 7526: 
 7527:     >>> a = np.ma.array([1, 2, 3, 4], mask=[False, True, False, False])
 7528:     >>> np.ma.put(a, [1, 3], [10, 30])
 7529:     >>> a
 7530:     masked_array(data=[ 1, 10,  3, 30],
 7531:                  mask=False,
 7532:            fill_value=999999)
 7533: 
 7534:     Using put with a 2D array:
 7535: 
 7536:     >>> b = np.ma.array([[1, 2], [3, 4]], mask=[[False, True], [False, False]])
 7537:     >>> np.ma.put(b, [[0, 1], [1, 0]], [[10, 20], [30, 40]])
 7538:     >>> b
 7539:     masked_array(
 7540:       data=[[40, 30],
 7541:             [ 3,  4]],
 7542:       mask=False,
 7543:       fill_value=999999)
 7544: 
 7545:     """
 7546:     # We can't use 'frommethod', the order of arguments is different
 7547:     try:
 7548:         return a.put(indices, values, mode=mode)
 7549:     except AttributeError:
 7550:         return np.asarray(a).put(indices, values, mode=mode)
 7551: 
 7552: 
 7553: def putmask(a, mask, values):  # , mode='raise'):
 7554:     """
 7555:     Changes elements of an array based on conditional and input values.
 7556: 
 7557:     This is the masked array version of `numpy.putmask`, for details see
 7558:     `numpy.putmask`.
 7559: 
 7560:     See Also
 7561:     --------
 7562:     numpy.putmask
 7563: 
 7564:     Notes
 7565:     -----
 7566:     Using a masked array as `values` will **not** transform a `ndarray` into
 7567:     a `MaskedArray`.
 7568: 
 7569:     Examples
 7570:     --------
 7571:     >>> import numpy as np
 7572:     >>> arr = [[1, 2], [3, 4]]
 7573:     >>> mask = [[1, 0], [0, 0]]
 7574:     >>> x = np.ma.array(arr, mask=mask)
 7575:     >>> np.ma.putmask(x, x < 4, 10*x)
 7576:     >>> x
 7577:     masked_array(
 7578:       data=[[--, 20],
 7579:             [30, 4]],
 7580:       mask=[[ True, False],
 7581:             [False, False]],
 7582:       fill_value=999999)
 7583:     >>> x.data
 7584:     array([[10, 20],
 7585:            [30,  4]])
 7586: 
 7587:     """
 7588:     # We can't use 'frommethod', the order of arguments is different
 7589:     if not isinstance(a, MaskedArray):
 7590:         a = a.view(MaskedArray)
 7591:     (valdata, valmask) = (getdata(values), getmask(values))
 7592:     if getmask(a) is nomask:
 7593:         if valmask is not nomask:
 7594:             a._sharedmask = True
 7595:             a._mask = make_mask_none(a.shape, a.dtype)
 7596:             np.copyto(a._mask, valmask, where=mask)
 7597:     elif a._hardmask:
 7598:         if valmask is not nomask:
 7599:             m = a._mask.copy()
 7600:             np.copyto(m, valmask, where=mask)
 7601:             a.mask |= m
 7602:     else:
 7603:         if valmask is nomask:
 7604:             valmask = getmaskarray(values)
 7605:         np.copyto(a._mask, valmask, where=mask)
 7606:     np.copyto(a._data, valdata, where=mask)
 7607: 
 7608: 
 7609: def transpose(a, axes=None):
 7610:     """
 7611:     Permute the dimensions of an array.
 7612: 
 7613:     This function is exactly equivalent to `numpy.transpose`.
 7614: 
 7615:     See Also
 7616:     --------
 7617:     numpy.transpose : Equivalent function in top-level NumPy module.
 7618: 
 7619:     Examples
 7620:     --------
 7621:     >>> import numpy as np
 7622:     >>> import numpy.ma as ma
 7623:     >>> x = ma.arange(4).reshape((2,2))
 7624:     >>> x[1, 1] = ma.masked
 7625:     >>> x
 7626:     masked_array(
 7627:       data=[[0, 1],
 7628:             [2, --]],
 7629:       mask=[[False, False],
 7630:             [False,  True]],
 7631:       fill_value=999999)
 7632: 
 7633:     >>> ma.transpose(x)
 7634:     masked_array(
 7635:       data=[[0, 2],
 7636:             [1, --]],
 7637:       mask=[[False, False],
 7638:             [False,  True]],
 7639:       fill_value=999999)
 7640:     """
 7641:     # We can't use 'frommethod', as 'transpose' doesn't take keywords
 7642:     try:
 7643:         return a.transpose(axes)
 7644:     except AttributeError:
 7645:         return np.asarray(a).transpose(axes).view(MaskedArray)
 7646: 
 7647: 
 7648: def reshape(a, new_shape, order='C'):
 7649:     """
 7650:     Returns an array containing the same data with a new shape.
 7651: 
 7652:     Refer to `MaskedArray.reshape` for full documentation.
 7653: 
 7654:     See Also
 7655:     --------
 7656:     MaskedArray.reshape : equivalent function
 7657: 
 7658:     Examples
 7659:     --------
 7660:     Reshaping a 1-D array:
 7661: 
 7662:     >>> a = np.ma.array([1, 2, 3, 4])
 7663:     >>> np.ma.reshape(a, (2, 2))
 7664:     masked_array(
 7665:       data=[[1, 2],
 7666:             [3, 4]],
 7667:       mask=False,
 7668:       fill_value=999999)
 7669: 
 7670:     Reshaping a 2-D array:
 7671: 
 7672:     >>> b = np.ma.array([[1, 2], [3, 4]])
 7673:     >>> np.ma.reshape(b, (1, 4))
 7674:     masked_array(data=[[1, 2, 3, 4]],
 7675:                  mask=False,
 7676:            fill_value=999999)
 7677: 
 7678:     Reshaping a 1-D array with a mask:
 7679: 
 7680:     >>> c = np.ma.array([1, 2, 3, 4], mask=[False, True, False, False])
 7681:     >>> np.ma.reshape(c, (2, 2))
 7682:     masked_array(
 7683:       data=[[1, --],
 7684:             [3, 4]],
 7685:       mask=[[False,  True],
 7686:             [False, False]],
 7687:       fill_value=999999)
 7688: 
 7689:     """
 7690:     # We can't use 'frommethod', it whine about some parameters. Dmmit.
 7691:     try:
 7692:         return a.reshape(new_shape, order=order)
 7693:     except AttributeError:
 7694:         _tmp = np.asarray(a).reshape(new_shape, order=order)
 7695:         return _tmp.view(MaskedArray)
 7696: 
 7697: 
 7698: def resize(x, new_shape):
 7699:     """
 7700:     Return a new masked array with the specified size and shape.
 7701: 
 7702:     This is the masked equivalent of the `numpy.resize` function. The new
 7703:     array is filled with repeated copies of `x` (in the order that the
 7704:     data are stored in memory). If `x` is masked, the new array will be
 7705:     masked, and the new mask will be a repetition of the old one.
 7706: 
 7707:     See Also
 7708:     --------
 7709:     numpy.resize : Equivalent function in the top level NumPy module.
 7710: 
 7711:     Examples
 7712:     --------
 7713:     >>> import numpy as np
 7714:     >>> import numpy.ma as ma
 7715:     >>> a = ma.array([[1, 2] ,[3, 4]])
 7716:     >>> a[0, 1] = ma.masked
 7717:     >>> a
 7718:     masked_array(
 7719:       data=[[1, --],
 7720:             [3, 4]],
 7721:       mask=[[False,  True],
 7722:             [False, False]],
 7723:       fill_value=999999)
 7724:     >>> np.resize(a, (3, 3))
 7725:     masked_array(
 7726:       data=[[1, 2, 3],
 7727:             [4, 1, 2],
 7728:             [3, 4, 1]],
 7729:       mask=False,
 7730:       fill_value=999999)
 7731:     >>> ma.resize(a, (3, 3))
 7732:     masked_array(
 7733:       data=[[1, --, 3],
 7734:             [4, 1, --],
 7735:             [3, 4, 1]],
 7736:       mask=[[False,  True, False],
 7737:             [False, False,  True],
 7738:             [False, False, False]],
 7739:       fill_value=999999)
 7740: 
 7741:     A MaskedArray is always returned, regardless of the input type.
 7742: 
 7743:     >>> a = np.array([[1, 2] ,[3, 4]])
 7744:     >>> ma.resize(a, (3, 3))
 7745:     masked_array(
 7746:       data=[[1, 2, 3],
 7747:             [4, 1, 2],
 7748:             [3, 4, 1]],
 7749:       mask=False,
 7750:       fill_value=999999)
 7751: 
 7752:     """
 7753:     # We can't use _frommethods here, as N.resize is notoriously whiny.
 7754:     m = getmask(x)
 7755:     if m is not nomask:
 7756:         m = np.resize(m, new_shape)
 7757:     result = np.resize(x, new_shape).view(get_masked_subclass(x))
 7758:     if result.ndim:
 7759:         result._mask = m
 7760:     return result
 7761: 
 7762: 
 7763: def ndim(obj):
 7764:     """
 7765:     maskedarray version of the numpy function.
 7766: 
 7767:     """
 7768:     return np.ndim(getdata(obj))
 7769: 
 7770: 
 7771: ndim.__doc__ = np.ndim.__doc__
 7772: 
 7773: 
 7774: def shape(obj):
 7775:     "maskedarray version of the numpy function."
 7776:     return np.shape(getdata(obj))
 7777: 
 7778: 
 7779: shape.__doc__ = np.shape.__doc__
 7780: 
 7781: 
 7782: def size(obj, axis=None):
 7783:     "maskedarray version of the numpy function."
 7784:     return np.size(getdata(obj), axis)
 7785: 
 7786: 
 7787: size.__doc__ = np.size.__doc__
 7788: 
 7789: 
 7790: def diff(a, /, n=1, axis=-1, prepend=np._NoValue, append=np._NoValue):
 7791:     """
 7792:     Calculate the n-th discrete difference along the given axis.
 7793:     The first difference is given by ``out[i] = a[i+1] - a[i]`` along
 7794:     the given axis, higher differences are calculated by using `diff`
 7795:     recursively.
 7796:     Preserves the input mask.
 7797: 
 7798:     Parameters
 7799:     ----------
 7800:     a : array_like
 7801:         Input array
 7802:     n : int, optional
 7803:         The number of times values are differenced. If zero, the input
 7804:         is returned as-is.
 7805:     axis : int, optional
 7806:         The axis along which the difference is taken, default is the
 7807:         last axis.
 7808:     prepend, append : array_like, optional
 7809:         Values to prepend or append to `a` along axis prior to
 7810:         performing the difference.  Scalar values are expanded to
 7811:         arrays with length 1 in the direction of axis and the shape
 7812:         of the input array in along all other axes.  Otherwise the
 7813:         dimension and shape must match `a` except along axis.
 7814: 
 7815:     Returns
 7816:     -------
 7817:     diff : MaskedArray
 7818:         The n-th differences. The shape of the output is the same as `a`
 7819:         except along `axis` where the dimension is smaller by `n`. The
 7820:         type of the output is the same as the type of the difference
 7821:         between any two elements of `a`. This is the same as the type of
 7822:         `a` in most cases. A notable exception is `datetime64`, which
 7823:         results in a `timedelta64` output array.
 7824: 
 7825:     See Also
 7826:     --------
 7827:     numpy.diff : Equivalent function in the top-level NumPy module.
 7828: 
 7829:     Notes
 7830:     -----
 7831:     Type is preserved for boolean arrays, so the result will contain
 7832:     `False` when consecutive elements are the same and `True` when they
 7833:     differ.
 7834: 
 7835:     For unsigned integer arrays, the results will also be unsigned. This
 7836:     should not be surprising, as the result is consistent with
 7837:     calculating the difference directly:
 7838: 
 7839:     >>> u8_arr = np.array([1, 0], dtype=np.uint8)
 7840:     >>> np.ma.diff(u8_arr)
 7841:     masked_array(data=[255],
 7842:                  mask=False,
 7843:            fill_value=np.uint64(999999),
 7844:                 dtype=uint8)
 7845:     >>> u8_arr[1,...] - u8_arr[0,...]
 7846:     np.uint8(255)
 7847: 
 7848:     If this is not desirable, then the array should be cast to a larger
 7849:     integer type first:
 7850: 
 7851:     >>> i16_arr = u8_arr.astype(np.int16)
 7852:     >>> np.ma.diff(i16_arr)
 7853:     masked_array(data=[-1],
 7854:                  mask=False,
 7855:            fill_value=np.int64(999999),
 7856:                 dtype=int16)
 7857: 
 7858:     Examples
 7859:     --------
 7860:     >>> import numpy as np
 7861:     >>> a = np.array([1, 2, 3, 4, 7, 0, 2, 3])
 7862:     >>> x = np.ma.masked_where(a < 2, a)
 7863:     >>> np.ma.diff(x)
 7864:     masked_array(data=[--, 1, 1, 3, --, --, 1],
 7865:             mask=[ True, False, False, False,  True,  True, False],
 7866:         fill_value=999999)
 7867: 
 7868:     >>> np.ma.diff(x, n=2)
 7869:     masked_array(data=[--, 0, 2, --, --, --],
 7870:                 mask=[ True, False, False,  True,  True,  True],
 7871:         fill_value=999999)
 7872: 
 7873:     >>> a = np.array([[1, 3, 1, 5, 10], [0, 1, 5, 6, 8]])
 7874:     >>> x = np.ma.masked_equal(a, value=1)
 7875:     >>> np.ma.diff(x)
 7876:     masked_array(
 7877:         data=[[--, --, --, 5],
 7878:                 [--, --, 1, 2]],
 7879:         mask=[[ True,  True,  True, False],
 7880:                 [ True,  True, False, False]],
 7881:         fill_value=1)
 7882: 
 7883:     >>> np.ma.diff(x, axis=0)
 7884:     masked_array(data=[[--, --, --, 1, -2]],
 7885:             mask=[[ True,  True,  True, False, False]],
 7886:         fill_value=1)
 7887: 
 7888:     """
 7889:     if n == 0:
 7890:         return a
 7891:     if n < 0:
 7892:         raise ValueError("order must be non-negative but got " + repr(n))
 7893: 
 7894:     a = np.ma.asanyarray(a)
 7895:     if a.ndim == 0:
 7896:         raise ValueError(
 7897:             "diff requires input that is at least one dimensional"
 7898:             )
 7899: 
 7900:     combined = []
 7901:     if prepend is not np._NoValue:
 7902:         prepend = np.ma.asanyarray(prepend)
 7903:         if prepend.ndim == 0:
 7904:             shape = list(a.shape)
 7905:             shape[axis] = 1
 7906:             prepend = np.broadcast_to(prepend, tuple(shape))
 7907:         combined.append(prepend)
 7908: 
 7909:     combined.append(a)
 7910: 
 7911:     if append is not np._NoValue:
 7912:         append = np.ma.asanyarray(append)
 7913:         if append.ndim == 0:
 7914:             shape = list(a.shape)
 7915:             shape[axis] = 1
 7916:             append = np.broadcast_to(append, tuple(shape))
 7917:         combined.append(append)
 7918: 
 7919:     if len(combined) > 1:
 7920:         a = np.ma.concatenate(combined, axis)
 7921: 
 7922:     # GH 22465 np.diff without prepend/append preserves the mask
 7923:     return np.diff(a, n, axis)
 7924: 
 7925: 
 7926: ##############################################################################
 7927: #                            Extra functions                                 #
 7928: ##############################################################################
 7929: 
 7930: 
 7931: def where(condition, x=_NoValue, y=_NoValue):
 7932:     """
 7933:     Return a masked array with elements from `x` or `y`, depending on condition.
 7934: 
 7935:     .. note::
 7936:         When only `condition` is provided, this function is identical to
 7937:         `nonzero`. The rest of this documentation covers only the case where
 7938:         all three arguments are provided.
 7939: 
 7940:     Parameters
 7941:     ----------
 7942:     condition : array_like, bool
 7943:         Where True, yield `x`, otherwise yield `y`.
 7944:     x, y : array_like, optional
 7945:         Values from which to choose. `x`, `y` and `condition` need to be
 7946:         broadcastable to some shape.
 7947: 
 7948:     Returns
 7949:     -------
 7950:     out : MaskedArray
 7951:         An masked array with `masked` elements where the condition is masked,
 7952:         elements from `x` where `condition` is True, and elements from `y`
 7953:         elsewhere.
 7954: 
 7955:     See Also
 7956:     --------
 7957:     numpy.where : Equivalent function in the top-level NumPy module.
 7958:     nonzero : The function that is called when x and y are omitted
 7959: 
 7960:     Examples
 7961:     --------
 7962:     >>> import numpy as np
 7963:     >>> x = np.ma.array(np.arange(9.).reshape(3, 3), mask=[[0, 1, 0],
 7964:     ...                                                    [1, 0, 1],
 7965:     ...                                                    [0, 1, 0]])
 7966:     >>> x
 7967:     masked_array(
 7968:       data=[[0.0, --, 2.0],
 7969:             [--, 4.0, --],
 7970:             [6.0, --, 8.0]],
 7971:       mask=[[False,  True, False],
 7972:             [ True, False,  True],
 7973:             [False,  True, False]],
 7974:       fill_value=1e+20)
 7975:     >>> np.ma.where(x > 5, x, -3.1416)
 7976:     masked_array(
 7977:       data=[[-3.1416, --, -3.1416],
 7978:             [--, -3.1416, --],
 7979:             [6.0, --, 8.0]],
 7980:       mask=[[False,  True, False],
 7981:             [ True, False,  True],
 7982:             [False,  True, False]],
 7983:       fill_value=1e+20)
 7984: 
 7985:     """
 7986: 
 7987:     # handle the single-argument case
 7988:     missing = (x is _NoValue, y is _NoValue).count(True)
 7989:     if missing == 1:
 7990:         raise ValueError("Must provide both 'x' and 'y' or neither.")
 7991:     if missing == 2:
 7992:         return nonzero(condition)
 7993: 
 7994:     # we only care if the condition is true - false or masked pick y
 7995:     cf = filled(condition, False)
 7996:     xd = getdata(x)
 7997:     yd = getdata(y)
 7998: 
 7999:     # we need the full arrays here for correct final dimensions
 8000:     cm = getmaskarray(condition)
 8001:     xm = getmaskarray(x)
 8002:     ym = getmaskarray(y)
 8003: 
 8004:     # deal with the fact that masked.dtype == float64, but we don't actually
 8005:     # want to treat it as that.
 8006:     if x is masked and y is not masked:
 8007:         xd = np.zeros((), dtype=yd.dtype)
 8008:         xm = np.ones((),  dtype=ym.dtype)
 8009:     elif y is masked and x is not masked:
 8010:         yd = np.zeros((), dtype=xd.dtype)
 8011:         ym = np.ones((),  dtype=xm.dtype)
 8012: 
 8013:     data = np.where(cf, xd, yd)
 8014:     mask = np.where(cf, xm, ym)
 8015:     mask = np.where(cm, np.ones((), dtype=mask.dtype), mask)
 8016: 
 8017:     # collapse the mask, for backwards compatibility
 8018:     mask = _shrink_mask(mask)
 8019: 
 8020:     return masked_array(data, mask=mask)
 8021: 
 8022: 
 8023: def choose(indices, choices, out=None, mode='raise'):
 8024:     """
 8025:     Use an index array to construct a new array from a list of choices.
 8026: 
 8027:     Given an array of integers and a list of n choice arrays, this method
 8028:     will create a new array that merges each of the choice arrays.  Where a
 8029:     value in `index` is i, the new array will have the value that choices[i]
 8030:     contains in the same place.
 8031: 
 8032:     Parameters
 8033:     ----------
 8034:     indices : ndarray of ints
 8035:         This array must contain integers in ``[0, n-1]``, where n is the
 8036:         number of choices.
 8037:     choices : sequence of arrays
 8038:         Choice arrays. The index array and all of the choices should be
 8039:         broadcastable to the same shape.
 8040:     out : array, optional
 8041:         If provided, the result will be inserted into this array. It should
 8042:         be of the appropriate shape and `dtype`.
 8043:     mode : {'raise', 'wrap', 'clip'}, optional
 8044:         Specifies how out-of-bounds indices will behave.
 8045: 
 8046:         * 'raise' : raise an error
 8047:         * 'wrap' : wrap around
 8048:         * 'clip' : clip to the range
 8049: 
 8050:     Returns
 8051:     -------
 8052:     merged_array : array
 8053: 
 8054:     See Also
 8055:     --------
 8056:     choose : equivalent function
 8057: 
 8058:     Examples
 8059:     --------
 8060:     >>> import numpy as np
 8061:     >>> choice = np.array([[1,1,1], [2,2,2], [3,3,3]])
 8062:     >>> a = np.array([2, 1, 0])
 8063:     >>> np.ma.choose(a, choice)
 8064:     masked_array(data=[3, 2, 1],
 8065:                  mask=False,
 8066:            fill_value=999999)
 8067: 
 8068:     """
 8069:     def fmask(x):
 8070:         "Returns the filled array, or True if masked."
 8071:         if x is masked:
 8072:             return True
 8073:         return filled(x)
 8074: 
 8075:     def nmask(x):
 8076:         "Returns the mask, True if ``masked``, False if ``nomask``."
 8077:         if x is masked:
 8078:             return True
 8079:         return getmask(x)
 8080:     # Get the indices.
 8081:     c = filled(indices, 0)
 8082:     # Get the masks.
 8083:     masks = [nmask(x) for x in choices]
 8084:     data = [fmask(x) for x in choices]
 8085:     # Construct the mask
 8086:     outputmask = np.choose(c, masks, mode=mode)
 8087:     outputmask = make_mask(mask_or(outputmask, getmask(indices)),
 8088:                            copy=False, shrink=True)
 8089:     # Get the choices.
 8090:     d = np.choose(c, data, mode=mode, out=out).view(MaskedArray)
 8091:     if out is not None:
 8092:         if isinstance(out, MaskedArray):
 8093:             out.__setmask__(outputmask)
 8094:         return out
 8095:     d.__setmask__(outputmask)
 8096:     return d
 8097: 
 8098: 
 8099: def round_(a, decimals=0, out=None):
 8100:     """
 8101:     Return a copy of a, rounded to 'decimals' places.
 8102: 
 8103:     When 'decimals' is negative, it specifies the number of positions
 8104:     to the left of the decimal point.  The real and imaginary parts of
 8105:     complex numbers are rounded separately. Nothing is done if the
 8106:     array is not of float type and 'decimals' is greater than or equal
 8107:     to 0.
 8108: 
 8109:     Parameters
 8110:     ----------
 8111:     decimals : int
 8112:         Number of decimals to round to. May be negative.
 8113:     out : array_like
 8114:         Existing array to use for output.
 8115:         If not given, returns a default copy of a.
 8116: 
 8117:     Notes
 8118:     -----
 8119:     If out is given and does not have a mask attribute, the mask of a
 8120:     is lost!
 8121: 
 8122:     Examples
 8123:     --------
 8124:     >>> import numpy as np
 8125:     >>> import numpy.ma as ma
 8126:     >>> x = [11.2, -3.973, 0.801, -1.41]
 8127:     >>> mask = [0, 0, 0, 1]
 8128:     >>> masked_x = ma.masked_array(x, mask)
 8129:     >>> masked_x
 8130:     masked_array(data=[11.2, -3.973, 0.801, --],
 8131:                  mask=[False, False, False, True],
 8132:         fill_value=1e+20)
 8133:     >>> ma.round_(masked_x)
 8134:     masked_array(data=[11.0, -4.0, 1.0, --],
 8135:                  mask=[False, False, False, True],
 8136:         fill_value=1e+20)
 8137:     >>> ma.round(masked_x, decimals=1)
 8138:     masked_array(data=[11.2, -4.0, 0.8, --],
 8139:                  mask=[False, False, False, True],
 8140:         fill_value=1e+20)
 8141:     >>> ma.round_(masked_x, decimals=-1)
 8142:     masked_array(data=[10.0, -0.0, 0.0, --],
 8143:                  mask=[False, False, False, True],
 8144:         fill_value=1e+20)
 8145:     """
 8146:     if out is None:
 8147:         return np.round(a, decimals, out)
 8148:     else:
 8149:         np.round(getdata(a), decimals, out)
 8150:         if hasattr(out, '_mask'):
 8151:             out._mask = getmask(a)
 8152:         return out
 8153: 
 8154: 
 8155: round = round_
 8156: 
 8157: 
 8158: def _mask_propagate(a, axis):
 8159:     """
 8160:     Mask whole 1-d vectors of an array that contain masked values.
 8161:     """
 8162:     a = array(a, subok=False)
 8163:     m = getmask(a)
 8164:     if m is nomask or not m.any() or axis is None:
 8165:         return a
 8166:     a._mask = a._mask.copy()
 8167:     axes = normalize_axis_tuple(axis, a.ndim)
 8168:     for ax in axes:
 8169:         a._mask |= m.any(axis=ax, keepdims=True)
 8170:     return a
 8171: 
 8172: 
 8173: # Include masked dot here to avoid import problems in getting it from
 8174: # extras.py. Note that it is not included in __all__, but rather exported
 8175: # from extras in order to avoid backward compatibility problems.
 8176: def dot(a, b, strict=False, out=None):
 8177:     """
 8178:     Return the dot product of two arrays.
 8179: 
 8180:     This function is the equivalent of `numpy.dot` that takes masked values
 8181:     into account. Note that `strict` and `out` are in different position
 8182:     than in the method version. In order to maintain compatibility with the
 8183:     corresponding method, it is recommended that the optional arguments be
 8184:     treated as keyword only.  At some point that may be mandatory.
 8185: 
 8186:     Parameters
 8187:     ----------
 8188:     a, b : masked_array_like
 8189:         Inputs arrays.
 8190:     strict : bool, optional
 8191:         Whether masked data are propagated (True) or set to 0 (False) for
 8192:         the computation. Default is False.  Propagating the mask means that
 8193:         if a masked value appears in a row or column, the whole row or
 8194:         column is considered masked.
 8195:     out : masked_array, optional
 8196:         Output argument. This must have the exact kind that would be returned
 8197:         if it was not used. In particular, it must have the right type, must be
 8198:         C-contiguous, and its dtype must be the dtype that would be returned
 8199:         for `dot(a,b)`. This is a performance feature. Therefore, if these
 8200:         conditions are not met, an exception is raised, instead of attempting
 8201:         to be flexible.
 8202: 
 8203:     See Also
 8204:     --------
 8205:     numpy.dot : Equivalent function for ndarrays.
 8206: 
 8207:     Examples
 8208:     --------
 8209:     >>> import numpy as np
 8210:     >>> a = np.ma.array([[1, 2, 3], [4, 5, 6]], mask=[[1, 0, 0], [0, 0, 0]])
 8211:     >>> b = np.ma.array([[1, 2], [3, 4], [5, 6]], mask=[[1, 0], [0, 0], [0, 0]])
 8212:     >>> np.ma.dot(a, b)
 8213:     masked_array(
 8214:       data=[[21, 26],
 8215:             [45, 64]],
 8216:       mask=[[False, False],
 8217:             [False, False]],
 8218:       fill_value=999999)
 8219:     >>> np.ma.dot(a, b, strict=True)
 8220:     masked_array(
 8221:       data=[[--, --],
 8222:             [--, 64]],
 8223:       mask=[[ True,  True],
 8224:             [ True, False]],
 8225:       fill_value=999999)
 8226: 
 8227:     """
 8228:     if strict is True:
 8229:         if np.ndim(a) == 0 or np.ndim(b) == 0:
 8230:             pass
 8231:         elif b.ndim == 1:
 8232:             a = _mask_propagate(a, a.ndim - 1)
 8233:             b = _mask_propagate(b, b.ndim - 1)
 8234:         else:
 8235:             a = _mask_propagate(a, a.ndim - 1)
 8236:             b = _mask_propagate(b, b.ndim - 2)
 8237:     am = ~getmaskarray(a)
 8238:     bm = ~getmaskarray(b)
 8239: 
 8240:     if out is None:
 8241:         d = np.dot(filled(a, 0), filled(b, 0))
 8242:         m = ~np.dot(am, bm)
 8243:         if np.ndim(d) == 0:
 8244:             d = np.asarray(d)
 8245:         r = d.view(get_masked_subclass(a, b))
 8246:         r.__setmask__(m)
 8247:         return r
 8248:     else:
 8249:         d = np.dot(filled(a, 0), filled(b, 0), out._data)
 8250:         if out.mask.shape != d.shape:
 8251:             out._mask = np.empty(d.shape, MaskType)
 8252:         np.dot(am, bm, out._mask)
 8253:         np.logical_not(out._mask, out._mask)
 8254:         return out
 8255: 
 8256: 
 8257: def inner(a, b):
 8258:     """
 8259:     Returns the inner product of a and b for arrays of floating point types.
 8260: 
 8261:     Like the generic NumPy equivalent the product sum is over the last dimension
 8262:     of a and b. The first argument is not conjugated.
 8263: 
 8264:     """
 8265:     fa = filled(a, 0)
 8266:     fb = filled(b, 0)
 8267:     if fa.ndim == 0:
 8268:         fa.shape = (1,)
 8269:     if fb.ndim == 0:
 8270:         fb.shape = (1,)
 8271:     return np.inner(fa, fb).view(MaskedArray)
 8272: 
 8273: 
 8274: inner.__doc__ = doc_note(np.inner.__doc__,
 8275:                          "Masked values are replaced by 0.")
 8276: innerproduct = inner
 8277: 
 8278: 
 8279: def outer(a, b):
 8280:     "maskedarray version of the numpy function."
 8281:     fa = filled(a, 0).ravel()
 8282:     fb = filled(b, 0).ravel()
 8283:     d = np.outer(fa, fb)
 8284:     ma = getmask(a)
 8285:     mb = getmask(b)
 8286:     if ma is nomask and mb is nomask:
 8287:         return masked_array(d)
 8288:     ma = getmaskarray(a)
 8289:     mb = getmaskarray(b)
 8290:     m = make_mask(1 - np.outer(1 - ma, 1 - mb), copy=False)
 8291:     return masked_array(d, mask=m)
 8292: 
 8293: 
 8294: outer.__doc__ = doc_note(np.outer.__doc__,
 8295:                          "Masked values are replaced by 0.")
 8296: outerproduct = outer
 8297: 
 8298: 
 8299: def _convolve_or_correlate(f, a, v, mode, propagate_mask):
 8300:     """
 8301:     Helper function for ma.correlate and ma.convolve
 8302:     """
 8303:     if propagate_mask:
 8304:         # results which are contributed to by either item in any pair being invalid
 8305:         mask = (
 8306:             f(getmaskarray(a), np.ones(np.shape(v), dtype=bool), mode=mode)
 8307:           | f(np.ones(np.shape(a), dtype=bool), getmaskarray(v), mode=mode)
 8308:         )
 8309:         data = f(getdata(a), getdata(v), mode=mode)
 8310:     else:
 8311:         # results which are not contributed to by any pair of valid elements
 8312:         mask = ~f(~getmaskarray(a), ~getmaskarray(v), mode=mode)
 8313:         data = f(filled(a, 0), filled(v, 0), mode=mode)
 8314: 
 8315:     return masked_array(data, mask=mask)
 8316: 
 8317: 
 8318: def correlate(a, v, mode='valid', propagate_mask=True):
 8319:     """
 8320:     Cross-correlation of two 1-dimensional sequences.
 8321: 
 8322:     Parameters
 8323:     ----------
 8324:     a, v : array_like
 8325:         Input sequences.
 8326:     mode : {'valid', 'same', 'full'}, optional
 8327:         Refer to the `np.convolve` docstring.  Note that the default
 8328:         is 'valid', unlike `convolve`, which uses 'full'.
 8329:     propagate_mask : bool
 8330:         If True, then a result element is masked if any masked element contributes
 8331:         towards it. If False, then a result element is only masked if no non-masked
 8332:         element contribute towards it
 8333: 
 8334:     Returns
 8335:     -------
 8336:     out : MaskedArray
 8337:         Discrete cross-correlation of `a` and `v`.
 8338: 
 8339:     See Also
 8340:     --------
 8341:     numpy.correlate : Equivalent function in the top-level NumPy module.
 8342: 
 8343:     Examples
 8344:     --------
 8345:     Basic correlation:
 8346: 
 8347:     >>> a = np.ma.array([1, 2, 3])
 8348:     >>> v = np.ma.array([0, 1, 0])
 8349:     >>> np.ma.correlate(a, v, mode='valid')
 8350:     masked_array(data=[2],
 8351:                  mask=[False],
 8352:            fill_value=999999)
 8353: 
 8354:     Correlation with masked elements:
 8355: 
 8356:     >>> a = np.ma.array([1, 2, 3], mask=[False, True, False])
 8357:     >>> v = np.ma.array([0, 1, 0])
 8358:     >>> np.ma.correlate(a, v, mode='valid', propagate_mask=True)
 8359:     masked_array(data=[--],
 8360:                  mask=[ True],
 8361:            fill_value=999999,
 8362:                 dtype=int64)
 8363: 
 8364:     Correlation with different modes and mixed array types:
 8365: 
 8366:     >>> a = np.ma.array([1, 2, 3])
 8367:     >>> v = np.ma.array([0, 1, 0])
 8368:     >>> np.ma.correlate(a, v, mode='full')
 8369:     masked_array(data=[0, 1, 2, 3, 0],
 8370:                  mask=[False, False, False, False, False],
 8371:            fill_value=999999)
 8372: 
 8373:     """
 8374:     return _convolve_or_correlate(np.correlate, a, v, mode, propagate_mask)
 8375: 
 8376: 
 8377: def convolve(a, v, mode='full', propagate_mask=True):
 8378:     """
 8379:     Returns the discrete, linear convolution of two one-dimensional sequences.
 8380: 
 8381:     Parameters
 8382:     ----------
 8383:     a, v : array_like
 8384:         Input sequences.
 8385:     mode : {'valid', 'same', 'full'}, optional
 8386:         Refer to the `np.convolve` docstring.
 8387:     propagate_mask : bool
 8388:         If True, then if any masked element is included in the sum for a result
 8389:         element, then the result is masked.
 8390:         If False, then the result element is only masked if no non-masked cells
 8391:         contribute towards it
 8392: 
 8393:     Returns
 8394:     -------
 8395:     out : MaskedArray
 8396:         Discrete, linear convolution of `a` and `v`.
 8397: 
 8398:     See Also
 8399:     --------
 8400:     numpy.convolve : Equivalent function in the top-level NumPy module.
 8401:     """
 8402:     return _convolve_or_correlate(np.convolve, a, v, mode, propagate_mask)
 8403: 
 8404: 
 8405: def allequal(a, b, fill_value=True):
 8406:     """
 8407:     Return True if all entries of a and b are equal, using
 8408:     fill_value as a truth value where either or both are masked.
 8409: 
 8410:     Parameters
 8411:     ----------
 8412:     a, b : array_like
 8413:         Input arrays to compare.
 8414:     fill_value : bool, optional
 8415:         Whether masked values in a or b are considered equal (True) or not
 8416:         (False).
 8417: 
 8418:     Returns
 8419:     -------
 8420:     y : bool
 8421:         Returns True if the two arrays are equal within the given
 8422:         tolerance, False otherwise. If either array contains NaN,
 8423:         then False is returned.
 8424: 
 8425:     See Also
 8426:     --------
 8427:     all, any
 8428:     numpy.ma.allclose
 8429: 
 8430:     Examples
 8431:     --------
 8432:     >>> import numpy as np
 8433:     >>> a = np.ma.array([1e10, 1e-7, 42.0], mask=[0, 0, 1])
 8434:     >>> a
 8435:     masked_array(data=[10000000000.0, 1e-07, --],
 8436:                  mask=[False, False,  True],
 8437:            fill_value=1e+20)
 8438: 
 8439:     >>> b = np.array([1e10, 1e-7, -42.0])
 8440:     >>> b
 8441:     array([  1.00000000e+10,   1.00000000e-07,  -4.20000000e+01])
 8442:     >>> np.ma.allequal(a, b, fill_value=False)
 8443:     False
 8444:     >>> np.ma.allequal(a, b)
 8445:     True
 8446: 
 8447:     """
 8448:     m = mask_or(getmask(a), getmask(b))
 8449:     if m is nomask:
 8450:         x = getdata(a)
 8451:         y = getdata(b)
 8452:         d = umath.equal(x, y)
 8453:         return d.all()
 8454:     elif fill_value:
 8455:         x = getdata(a)
 8456:         y = getdata(b)
 8457:         d = umath.equal(x, y)
 8458:         dm = array(d, mask=m, copy=False)
 8459:         return dm.filled(True).all(None)
 8460:     else:
 8461:         return False
 8462: 
 8463: 
 8464: def allclose(a, b, masked_equal=True, rtol=1e-5, atol=1e-8):
 8465:     """
 8466:     Returns True if two arrays are element-wise equal within a tolerance.
 8467: 
 8468:     This function is equivalent to `allclose` except that masked values
 8469:     are treated as equal (default) or unequal, depending on the `masked_equal`
 8470:     argument.
 8471: 
 8472:     Parameters
 8473:     ----------
 8474:     a, b : array_like
 8475:         Input arrays to compare.
 8476:     masked_equal : bool, optional
 8477:         Whether masked values in `a` and `b` are considered equal (True) or not
 8478:         (False). They are considered equal by default.
 8479:     rtol : float, optional
 8480:         Relative tolerance. The relative difference is equal to ``rtol * b``.
 8481:         Default is 1e-5.
 8482:     atol : float, optional
 8483:         Absolute tolerance. The absolute difference is equal to `atol`.
 8484:         Default is 1e-8.
 8485: 
 8486:     Returns
 8487:     -------
 8488:     y : bool
 8489:         Returns True if the two arrays are equal within the given
 8490:         tolerance, False otherwise. If either array contains NaN, then
 8491:         False is returned.
 8492: 
 8493:     See Also
 8494:     --------
 8495:     all, any
 8496:     numpy.allclose : the non-masked `allclose`.
 8497: 
 8498:     Notes
 8499:     -----
 8500:     If the following equation is element-wise True, then `allclose` returns
 8501:     True::
 8502: 
 8503:       absolute(`a` - `b`) <= (`atol` + `rtol` * absolute(`b`))
 8504: 
 8505:     Return True if all elements of `a` and `b` are equal subject to
 8506:     given tolerances.
 8507: 
 8508:     Examples
 8509:     --------
 8510:     >>> import numpy as np
 8511:     >>> a = np.ma.array([1e10, 1e-7, 42.0], mask=[0, 0, 1])
 8512:     >>> a
 8513:     masked_array(data=[10000000000.0, 1e-07, --],
 8514:                  mask=[False, False,  True],
 8515:            fill_value=1e+20)
 8516:     >>> b = np.ma.array([1e10, 1e-8, -42.0], mask=[0, 0, 1])
 8517:     >>> np.ma.allclose(a, b)
 8518:     False
 8519: 
 8520:     >>> a = np.ma.array([1e10, 1e-8, 42.0], mask=[0, 0, 1])
 8521:     >>> b = np.ma.array([1.00001e10, 1e-9, -42.0], mask=[0, 0, 1])
 8522:     >>> np.ma.allclose(a, b)
 8523:     True
 8524:     >>> np.ma.allclose(a, b, masked_equal=False)
 8525:     False
 8526: 
 8527:     Masked values are not compared directly.
 8528: 
 8529:     >>> a = np.ma.array([1e10, 1e-8, 42.0], mask=[0, 0, 1])
 8530:     >>> b = np.ma.array([1.00001e10, 1e-9, 42.0], mask=[0, 0, 1])
 8531:     >>> np.ma.allclose(a, b)
 8532:     True
 8533:     >>> np.ma.allclose(a, b, masked_equal=False)
 8534:     False
 8535: 
 8536:     """
 8537:     x = masked_array(a, copy=False)
 8538:     y = masked_array(b, copy=False)
 8539: 
 8540:     # make sure y is an inexact type to avoid abs(MIN_INT); will cause
 8541:     # casting of x later.
 8542:     # NOTE: We explicitly allow timedelta, which used to work. This could
 8543:     #       possibly be deprecated. See also gh-18286.
 8544:     #       timedelta works if `atol` is an integer or also a timedelta.
 8545:     #       Although, the default tolerances are unlikely to be useful
 8546:     if y.dtype.kind != "m":
 8547:         dtype = np.result_type(y, 1.)
 8548:         if y.dtype != dtype:
 8549:             y = masked_array(y, dtype=dtype, copy=False)
 8550: 
 8551:     m = mask_or(getmask(x), getmask(y))
 8552:     xinf = np.isinf(masked_array(x, copy=False, mask=m)).filled(False)
 8553:     # If we have some infs, they should fall at the same place.
 8554:     if not np.all(xinf == filled(np.isinf(y), False)):
 8555:         return False
 8556:     # No infs at all
 8557:     if not np.any(xinf):
 8558:         d = filled(less_equal(absolute(x - y), atol + rtol * absolute(y)),
 8559:                    masked_equal)
 8560:         return np.all(d)
 8561: 
 8562:     if not np.all(filled(x[xinf] == y[xinf], masked_equal)):
 8563:         return False
 8564:     x = x[~xinf]
 8565:     y = y[~xinf]
 8566: 
 8567:     d = filled(less_equal(absolute(x - y), atol + rtol * absolute(y)),
 8568:                masked_equal)
 8569: 
 8570:     return np.all(d)
 8571: 
 8572: 
 8573: def asarray(a, dtype=None, order=None):
 8574:     """
 8575:     Convert the input to a masked array of the given data-type.
 8576: 
 8577:     No copy is performed if the input is already an `ndarray`. If `a` is
 8578:     a subclass of `MaskedArray`, a base class `MaskedArray` is returned.
 8579: 
 8580:     Parameters
 8581:     ----------
 8582:     a : array_like
 8583:         Input data, in any form that can be converted to a masked array. This
 8584:         includes lists, lists of tuples, tuples, tuples of tuples, tuples
 8585:         of lists, ndarrays and masked arrays.
 8586:     dtype : dtype, optional
 8587:         By default, the data-type is inferred from the input data.
 8588:     order : {'C', 'F'}, optional
 8589:         Whether to use row-major ('C') or column-major ('FORTRAN') memory
 8590:         representation.  Default is 'C'.
 8591: 
 8592:     Returns
 8593:     -------
 8594:     out : MaskedArray
 8595:         Masked array interpretation of `a`.
 8596: 
 8597:     See Also
 8598:     --------
 8599:     asanyarray : Similar to `asarray`, but conserves subclasses.
 8600: 
 8601:     Examples
 8602:     --------
 8603:     >>> import numpy as np
 8604:     >>> x = np.arange(10.).reshape(2, 5)
 8605:     >>> x
 8606:     array([[0., 1., 2., 3., 4.],
 8607:            [5., 6., 7., 8., 9.]])
 8608:     >>> np.ma.asarray(x)
 8609:     masked_array(
 8610:       data=[[0., 1., 2., 3., 4.],
 8611:             [5., 6., 7., 8., 9.]],
 8612:       mask=False,
 8613:       fill_value=1e+20)
 8614:     >>> type(np.ma.asarray(x))
 8615:     <class 'numpy.ma.MaskedArray'>
 8616: 
 8617:     """
 8618:     order = order or 'C'
 8619:     return masked_array(a, dtype=dtype, copy=False, keep_mask=True,
 8620:                         subok=False, order=order)
 8621: 
 8622: 
 8623: def asanyarray(a, dtype=None):
 8624:     """
 8625:     Convert the input to a masked array, conserving subclasses.
 8626: 
 8627:     If `a` is a subclass of `MaskedArray`, its class is conserved.
 8628:     No copy is performed if the input is already an `ndarray`.
 8629: 
 8630:     Parameters
 8631:     ----------
 8632:     a : array_like
 8633:         Input data, in any form that can be converted to an array.
 8634:     dtype : dtype, optional
 8635:         By default, the data-type is inferred from the input data.
 8636:     order : {'C', 'F'}, optional
 8637:         Whether to use row-major ('C') or column-major ('FORTRAN') memory
 8638:         representation.  Default is 'C'.
 8639: 
 8640:     Returns
 8641:     -------
 8642:     out : MaskedArray
 8643:         MaskedArray interpretation of `a`.
 8644: 
 8645:     See Also
 8646:     --------
 8647:     asarray : Similar to `asanyarray`, but does not conserve subclass.
 8648: 
 8649:     Examples
 8650:     --------
 8651:     >>> import numpy as np
 8652:     >>> x = np.arange(10.).reshape(2, 5)
 8653:     >>> x
 8654:     array([[0., 1., 2., 3., 4.],
 8655:            [5., 6., 7., 8., 9.]])
 8656:     >>> np.ma.asanyarray(x)
 8657:     masked_array(
 8658:       data=[[0., 1., 2., 3., 4.],
 8659:             [5., 6., 7., 8., 9.]],
 8660:       mask=False,
 8661:       fill_value=1e+20)
 8662:     >>> type(np.ma.asanyarray(x))
 8663:     <class 'numpy.ma.MaskedArray'>
 8664: 
 8665:     """
 8666:     # workaround for #8666, to preserve identity. Ideally the bottom line
 8667:     # would handle this for us.
 8668:     if isinstance(a, MaskedArray) and (dtype is None or dtype == a.dtype):
 8669:         return a
 8670:     return masked_array(a, dtype=dtype, copy=False, keep_mask=True, subok=True)
 8671: 
 8672: 
 8673: ##############################################################################
 8674: #                               Pickling                                     #
 8675: ##############################################################################
 8676: 
 8677: 
 8678: def fromfile(file, dtype=float, count=-1, sep=''):
 8679:     raise NotImplementedError(
 8680:         "fromfile() not yet implemented for a MaskedArray.")
 8681: 
 8682: 
 8683: def fromflex(fxarray):
 8684:     """
 8685:     Build a masked array from a suitable flexible-type array.
 8686: 
 8687:     The input array has to have a data-type with ``_data`` and ``_mask``
 8688:     fields. This type of array is output by `MaskedArray.toflex`.
 8689: 
 8690:     Parameters
 8691:     ----------
 8692:     fxarray : ndarray
 8693:         The structured input array, containing ``_data`` and ``_mask``
 8694:         fields. If present, other fields are discarded.
 8695: 
 8696:     Returns
 8697:     -------
 8698:     result : MaskedArray
 8699:         The constructed masked array.
 8700: 
 8701:     See Also
 8702:     --------
 8703:     MaskedArray.toflex : Build a flexible-type array from a masked array.
 8704: 
 8705:     Examples
 8706:     --------
 8707:     >>> import numpy as np
 8708:     >>> x = np.ma.array(np.arange(9).reshape(3, 3), mask=[0] + [1, 0] * 4)
 8709:     >>> rec = x.toflex()
 8710:     >>> rec
 8711:     array([[(0, False), (1,  True), (2, False)],
 8712:            [(3,  True), (4, False), (5,  True)],
 8713:            [(6, False), (7,  True), (8, False)]],
 8714:           dtype=[('_data', '<i8'), ('_mask', '?')])
 8715:     >>> x2 = np.ma.fromflex(rec)
 8716:     >>> x2
 8717:     masked_array(
 8718:       data=[[0, --, 2],
 8719:             [--, 4, --],
 8720:             [6, --, 8]],
 8721:       mask=[[False,  True, False],
 8722:             [ True, False,  True],
 8723:             [False,  True, False]],
 8724:       fill_value=999999)
 8725: 
 8726:     Extra fields can be present in the structured array but are discarded:
 8727: 
 8728:     >>> dt = [('_data', '<i4'), ('_mask', '|b1'), ('field3', '<f4')]
 8729:     >>> rec2 = np.zeros((2, 2), dtype=dt)
 8730:     >>> rec2
 8731:     array([[(0, False, 0.), (0, False, 0.)],
 8732:            [(0, False, 0.), (0, False, 0.)]],
 8733:           dtype=[('_data', '<i4'), ('_mask', '?'), ('field3', '<f4')])
 8734:     >>> y = np.ma.fromflex(rec2)
 8735:     >>> y
 8736:     masked_array(
 8737:       data=[[0, 0],
 8738:             [0, 0]],
 8739:       mask=[[False, False],
 8740:             [False, False]],
 8741:       fill_value=np.int64(999999),
 8742:       dtype=int32)
 8743: 
 8744:     """
 8745:     return masked_array(fxarray['_data'], mask=fxarray['_mask'])
 8746: 
 8747: 
 8748: class _convert2ma:
 8749: 
 8750:     """
 8751:     Convert functions from numpy to numpy.ma.
 8752: 
 8753:     Parameters
 8754:     ----------
 8755:         _methodname : string
 8756:             Name of the method to transform.
 8757: 
 8758:     """
 8759:     __doc__ = None
 8760: 
 8761:     def __init__(self, funcname, np_ret, np_ma_ret, params=None):
 8762:         self._func = getattr(np, funcname)
 8763:         self.__doc__ = self.getdoc(np_ret, np_ma_ret)
 8764:         self._extras = params or {}
 8765: 
 8766:     def getdoc(self, np_ret, np_ma_ret):
 8767:         "Return the doc of the function (from the doc of the method)."
 8768:         doc = getattr(self._func, '__doc__', None)
 8769:         sig = get_object_signature(self._func)
 8770:         if doc:
 8771:             doc = self._replace_return_type(doc, np_ret, np_ma_ret)
 8772:             # Add the signature of the function at the beginning of the doc
 8773:             if sig:
 8774:                 sig = f"{self._func.__name__}{sig}\n"
 8775:             doc = sig + doc
 8776:         return doc
 8777: 
 8778:     def _replace_return_type(self, doc, np_ret, np_ma_ret):
 8779:         """
 8780:         Replace documentation of ``np`` function's return type.
 8781: 
 8782:         Replaces it with the proper type for the ``np.ma`` function.
 8783: 
 8784:         Parameters
 8785:         ----------
 8786:         doc : str
 8787:             The documentation of the ``np`` method.
 8788:         np_ret : str
 8789:             The return type string of the ``np`` method that we want to
 8790:             replace. (e.g. "out : ndarray")
 8791:         np_ma_ret : str
 8792:             The return type string of the ``np.ma`` method.
 8793:             (e.g. "out : MaskedArray")
 8794:         """
 8795:         if np_ret not in doc:
 8796:             raise RuntimeError(
 8797:                 f"Failed to replace `{np_ret}` with `{np_ma_ret}`. "
 8798:                 f"The documentation string for return type, {np_ret}, is not "
 8799:                 f"found in the docstring for `np.{self._func.__name__}`. "
 8800:                 f"Fix the docstring for `np.{self._func.__name__}` or "
 8801:                 "update the expected string for return type."
 8802:             )
 8803: 
 8804:         return doc.replace(np_ret, np_ma_ret)
 8805: 
 8806:     def __call__(self, *args, **params):
 8807:         # Find the common parameters to the call and the definition
 8808:         _extras = self._extras
 8809:         common_params = set(params).intersection(_extras)
 8810:         # Drop the common parameters from the call
 8811:         for p in common_params:
 8812:             _extras[p] = params.pop(p)
 8813:         # Get the result
 8814:         result = self._func.__call__(*args, **params).view(MaskedArray)
 8815:         if "fill_value" in common_params:
 8816:             result.fill_value = _extras.get("fill_value", None)
 8817:         if "hardmask" in common_params:
 8818:             result._hardmask = bool(_extras.get("hard_mask", False))
 8819:         return result
 8820: 
 8821: 
 8822: arange = _convert2ma(
 8823:     'arange',
 8824:     params={'fill_value': None, 'hardmask': False},
 8825:     np_ret='arange : ndarray',
 8826:     np_ma_ret='arange : MaskedArray',
 8827: )
 8828: clip = _convert2ma(
 8829:     'clip',
 8830:     params={'fill_value': None, 'hardmask': False},
 8831:     np_ret='clipped_array : ndarray',
 8832:     np_ma_ret='clipped_array : MaskedArray',
 8833: )
 8834: empty = _convert2ma(
 8835:     'empty',
 8836:     params={'fill_value': None, 'hardmask': False},
 8837:     np_ret='out : ndarray',
 8838:     np_ma_ret='out : MaskedArray',
 8839: )
 8840: empty_like = _convert2ma(
 8841:     'empty_like',
 8842:     np_ret='out : ndarray',
 8843:     np_ma_ret='out : MaskedArray',
 8844: )
 8845: frombuffer = _convert2ma(
 8846:     'frombuffer',
 8847:     np_ret='out : ndarray',
 8848:     np_ma_ret='out: MaskedArray',
 8849: )
 8850: fromfunction = _convert2ma(
 8851:    'fromfunction',
 8852:    np_ret='fromfunction : any',
 8853:    np_ma_ret='fromfunction: MaskedArray',
 8854: )
 8855: identity = _convert2ma(
 8856:     'identity',
 8857:     params={'fill_value': None, 'hardmask': False},
 8858:     np_ret='out : ndarray',
 8859:     np_ma_ret='out : MaskedArray',
 8860: )
 8861: indices = _convert2ma(
 8862:     'indices',
 8863:     params={'fill_value': None, 'hardmask': False},
 8864:     np_ret='grid : one ndarray or tuple of ndarrays',
 8865:     np_ma_ret='grid : one MaskedArray or tuple of MaskedArrays',
 8866: )
 8867: ones = _convert2ma(
 8868:     'ones',
 8869:     params={'fill_value': None, 'hardmask': False},
 8870:     np_ret='out : ndarray',
 8871:     np_ma_ret='out : MaskedArray',
 8872: )
 8873: ones_like = _convert2ma(
 8874:     'ones_like',
 8875:     np_ret='out : ndarray',
 8876:     np_ma_ret='out : MaskedArray',
 8877: )
 8878: squeeze = _convert2ma(
 8879:     'squeeze',
 8880:     params={'fill_value': None, 'hardmask': False},
 8881:     np_ret='squeezed : ndarray',
 8882:     np_ma_ret='squeezed : MaskedArray',
 8883: )
 8884: zeros = _convert2ma(
 8885:     'zeros',
 8886:     params={'fill_value': None, 'hardmask': False},
 8887:     np_ret='out : ndarray',
 8888:     np_ma_ret='out : MaskedArray',
 8889: )
 8890: zeros_like = _convert2ma(
 8891:     'zeros_like',
 8892:     np_ret='out : ndarray',
 8893:     np_ma_ret='out : MaskedArray',
 8894: )
 8895: 
 8896: 
 8897: def append(a, b, axis=None):
 8898:     """Append values to the end of an array.
 8899: 
 8900:     Parameters
 8901:     ----------
 8902:     a : array_like
 8903:         Values are appended to a copy of this array.
 8904:     b : array_like
 8905:         These values are appended to a copy of `a`.  It must be of the
 8906:         correct shape (the same shape as `a`, excluding `axis`).  If `axis`
 8907:         is not specified, `b` can be any shape and will be flattened
 8908:         before use.
 8909:     axis : int, optional
 8910:         The axis along which `v` are appended.  If `axis` is not given,
 8911:         both `a` and `b` are flattened before use.
 8912: 
 8913:     Returns
 8914:     -------
 8915:     append : MaskedArray
 8916:         A copy of `a` with `b` appended to `axis`.  Note that `append`
 8917:         does not occur in-place: a new array is allocated and filled.  If
 8918:         `axis` is None, the result is a flattened array.
 8919: 
 8920:     See Also
 8921:     --------
 8922:     numpy.append : Equivalent function in the top-level NumPy module.
 8923: 
 8924:     Examples
 8925:     --------
 8926:     >>> import numpy as np
 8927:     >>> import numpy.ma as ma
 8928:     >>> a = ma.masked_values([1, 2, 3], 2)
 8929:     >>> b = ma.masked_values([[4, 5, 6], [7, 8, 9]], 7)
 8930:     >>> ma.append(a, b)
 8931:     masked_array(data=[1, --, 3, 4, 5, 6, --, 8, 9],
 8932:                  mask=[False,  True, False, False, False, False,  True, False,
 8933:                        False],
 8934:            fill_value=999999)
 8935:     """
 8936:     return concatenate([a, b], axis)
