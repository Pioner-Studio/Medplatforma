    1: """
    2: Masked arrays add-ons.
    3: 
    4: A collection of utilities for `numpy.ma`.
    5: 
    6: :author: Pierre Gerard-Marchant
    7: :contact: pierregm_at_uga_dot_edu
    8: 
    9: """
   10: __all__ = [
   11:     'apply_along_axis', 'apply_over_axes', 'atleast_1d', 'atleast_2d',
   12:     'atleast_3d', 'average', 'clump_masked', 'clump_unmasked', 'column_stack',
   13:     'compress_cols', 'compress_nd', 'compress_rowcols', 'compress_rows',
   14:     'count_masked', 'corrcoef', 'cov', 'diagflat', 'dot', 'dstack', 'ediff1d',
   15:     'flatnotmasked_contiguous', 'flatnotmasked_edges', 'hsplit', 'hstack',
   16:     'isin', 'in1d', 'intersect1d', 'mask_cols', 'mask_rowcols', 'mask_rows',
   17:     'masked_all', 'masked_all_like', 'median', 'mr_', 'ndenumerate',
   18:     'notmasked_contiguous', 'notmasked_edges', 'polyfit', 'row_stack',
   19:     'setdiff1d', 'setxor1d', 'stack', 'unique', 'union1d', 'vander', 'vstack',
   20:     ]
   21: 
   22: import itertools
   23: import warnings
   24: 
   25: import numpy as np
   26: from numpy import array as nxarray
   27: from numpy import ndarray
   28: from numpy.lib._function_base_impl import _ureduce
   29: from numpy.lib._index_tricks_impl import AxisConcatenator
   30: from numpy.lib.array_utils import normalize_axis_index, normalize_axis_tuple
   31: 
   32: from . import core as ma
   33: from .core import (  # noqa: F401
   34:     MAError,
   35:     MaskedArray,
   36:     add,
   37:     array,
   38:     asarray,
   39:     concatenate,
   40:     count,
   41:     dot,
   42:     filled,
   43:     get_masked_subclass,
   44:     getdata,
   45:     getmask,
   46:     getmaskarray,
   47:     make_mask_descr,
   48:     mask_or,
   49:     masked,
   50:     masked_array,
   51:     nomask,
   52:     ones,
   53:     sort,
   54:     zeros,
   55: )
   56: 
   57: 
   58: def issequence(seq):
   59:     """
   60:     Is seq a sequence (ndarray, list or tuple)?
   61: 
   62:     """
   63:     return isinstance(seq, (ndarray, tuple, list))
   64: 
   65: 
   66: def count_masked(arr, axis=None):
   67:     """
   68:     Count the number of masked elements along the given axis.
   69: 
   70:     Parameters
   71:     ----------
   72:     arr : array_like
   73:         An array with (possibly) masked elements.
   74:     axis : int, optional
   75:         Axis along which to count. If None (default), a flattened
   76:         version of the array is used.
   77: 
   78:     Returns
   79:     -------
   80:     count : int, ndarray
   81:         The total number of masked elements (axis=None) or the number
   82:         of masked elements along each slice of the given axis.
   83: 
   84:     See Also
   85:     --------
   86:     MaskedArray.count : Count non-masked elements.
   87: 
   88:     Examples
   89:     --------
   90:     >>> import numpy as np
   91:     >>> a = np.arange(9).reshape((3,3))
   92:     >>> a = np.ma.array(a)
   93:     >>> a[1, 0] = np.ma.masked
   94:     >>> a[1, 2] = np.ma.masked
   95:     >>> a[2, 1] = np.ma.masked
   96:     >>> a
   97:     masked_array(
   98:       data=[[0, 1, 2],
   99:             [--, 4, --],
  100:             [6, --, 8]],
  101:       mask=[[False, False, False],
  102:             [ True, False,  True],
  103:             [False,  True, False]],
  104:       fill_value=999999)
  105:     >>> np.ma.count_masked(a)
  106:     3
  107: 
  108:     When the `axis` keyword is used an array is returned.
  109: 
  110:     >>> np.ma.count_masked(a, axis=0)
  111:     array([1, 1, 1])
  112:     >>> np.ma.count_masked(a, axis=1)
  113:     array([0, 2, 1])
  114: 
  115:     """
  116:     m = getmaskarray(arr)
  117:     return m.sum(axis)
  118: 
  119: 
  120: def masked_all(shape, dtype=float):
  121:     """
  122:     Empty masked array with all elements masked.
  123: 
  124:     Return an empty masked array of the given shape and dtype, where all the
  125:     data are masked.
  126: 
  127:     Parameters
  128:     ----------
  129:     shape : int or tuple of ints
  130:         Shape of the required MaskedArray, e.g., ``(2, 3)`` or ``2``.
  131:     dtype : dtype, optional
  132:         Data type of the output.
  133: 
  134:     Returns
  135:     -------
  136:     a : MaskedArray
  137:         A masked array with all data masked.
  138: 
  139:     See Also
  140:     --------
  141:     masked_all_like : Empty masked array modelled on an existing array.
  142: 
  143:     Notes
  144:     -----
  145:     Unlike other masked array creation functions (e.g. `numpy.ma.zeros`,
  146:     `numpy.ma.ones`, `numpy.ma.full`), `masked_all` does not initialize the
  147:     values of the array, and may therefore be marginally faster. However,
  148:     the values stored in the newly allocated array are arbitrary. For
  149:     reproducible behavior, be sure to set each element of the array before
  150:     reading.
  151: 
  152:     Examples
  153:     --------
  154:     >>> import numpy as np
  155:     >>> np.ma.masked_all((3, 3))
  156:     masked_array(
  157:       data=[[--, --, --],
  158:             [--, --, --],
  159:             [--, --, --]],
  160:       mask=[[ True,  True,  True],
  161:             [ True,  True,  True],
  162:             [ True,  True,  True]],
  163:       fill_value=1e+20,
  164:       dtype=float64)
  165: 
  166:     The `dtype` parameter defines the underlying data type.
  167: 
  168:     >>> a = np.ma.masked_all((3, 3))
  169:     >>> a.dtype
  170:     dtype('float64')
  171:     >>> a = np.ma.masked_all((3, 3), dtype=np.int32)
  172:     >>> a.dtype
  173:     dtype('int32')
  174: 
  175:     """
  176:     a = masked_array(np.empty(shape, dtype),
  177:                      mask=np.ones(shape, make_mask_descr(dtype)))
  178:     return a
  179: 
  180: 
  181: def masked_all_like(arr):
  182:     """
  183:     Empty masked array with the properties of an existing array.
  184: 
  185:     Return an empty masked array of the same shape and dtype as
  186:     the array `arr`, where all the data are masked.
  187: 
  188:     Parameters
  189:     ----------
  190:     arr : ndarray
  191:         An array describing the shape and dtype of the required MaskedArray.
  192: 
  193:     Returns
  194:     -------
  195:     a : MaskedArray
  196:         A masked array with all data masked.
  197: 
  198:     Raises
  199:     ------
  200:     AttributeError
  201:         If `arr` doesn't have a shape attribute (i.e. not an ndarray)
  202: 
  203:     See Also
  204:     --------
  205:     masked_all : Empty masked array with all elements masked.
  206: 
  207:     Notes
  208:     -----
  209:     Unlike other masked array creation functions (e.g. `numpy.ma.zeros_like`,
  210:     `numpy.ma.ones_like`, `numpy.ma.full_like`), `masked_all_like` does not
  211:     initialize the values of the array, and may therefore be marginally
  212:     faster. However, the values stored in the newly allocated array are
  213:     arbitrary. For reproducible behavior, be sure to set each element of the
  214:     array before reading.
  215: 
  216:     Examples
  217:     --------
  218:     >>> import numpy as np
  219:     >>> arr = np.zeros((2, 3), dtype=np.float32)
  220:     >>> arr
  221:     array([[0., 0., 0.],
  222:            [0., 0., 0.]], dtype=float32)
  223:     >>> np.ma.masked_all_like(arr)
  224:     masked_array(
  225:       data=[[--, --, --],
  226:             [--, --, --]],
  227:       mask=[[ True,  True,  True],
  228:             [ True,  True,  True]],
  229:       fill_value=np.float64(1e+20),
  230:       dtype=float32)
  231: 
  232:     The dtype of the masked array matches the dtype of `arr`.
  233: 
  234:     >>> arr.dtype
  235:     dtype('float32')
  236:     >>> np.ma.masked_all_like(arr).dtype
  237:     dtype('float32')
  238: 
  239:     """
  240:     a = np.empty_like(arr).view(MaskedArray)
  241:     a._mask = np.ones(a.shape, dtype=make_mask_descr(a.dtype))
  242:     return a
  243: 
  244: 
  245: #####--------------------------------------------------------------------------
  246: #---- --- Standard functions ---
  247: #####--------------------------------------------------------------------------
  248: class _fromnxfunction:
  249:     """
  250:     Defines a wrapper to adapt NumPy functions to masked arrays.
  251: 
  252: 
  253:     An instance of `_fromnxfunction` can be called with the same parameters
  254:     as the wrapped NumPy function. The docstring of `newfunc` is adapted from
  255:     the wrapped function as well, see `getdoc`.
  256: 
  257:     This class should not be used directly. Instead, one of its extensions that
  258:     provides support for a specific type of input should be used.
  259: 
  260:     Parameters
  261:     ----------
  262:     funcname : str
  263:         The name of the function to be adapted. The function should be
  264:         in the NumPy namespace (i.e. ``np.funcname``).
  265: 
  266:     """
  267: 
  268:     def __init__(self, funcname):
  269:         self.__name__ = funcname
  270:         self.__qualname__ = funcname
  271:         self.__doc__ = self.getdoc()
  272: 
  273:     def getdoc(self):
  274:         """
  275:         Retrieve the docstring and signature from the function.
  276: 
  277:         The ``__doc__`` attribute of the function is used as the docstring for
  278:         the new masked array version of the function. A note on application
  279:         of the function to the mask is appended.
  280: 
  281:         Parameters
  282:         ----------
  283:         None
  284: 
  285:         """
  286:         npfunc = getattr(np, self.__name__, None)
  287:         doc = getattr(npfunc, '__doc__', None)
  288:         if doc:
  289:             sig = ma.get_object_signature(npfunc)
  290:             doc = ma.doc_note(doc, "The function is applied to both the _data "
  291:                                    "and the _mask, if any.")
  292:             if sig:
  293:                 sig = self.__name__ + sig + "\n\n"
  294:             return sig + doc
  295:         return
  296: 
  297:     def __call__(self, *args, **params):
  298:         pass
  299: 
  300: 
  301: class _fromnxfunction_single(_fromnxfunction):
  302:     """
  303:     A version of `_fromnxfunction` that is called with a single array
  304:     argument followed by auxiliary args that are passed verbatim for
  305:     both the data and mask calls.
  306:     """
  307:     def __call__(self, x, *args, **params):
  308:         func = getattr(np, self.__name__)
  309:         if isinstance(x, ndarray):
  310:             _d = func(x.__array__(), *args, **params)
  311:             _m = func(getmaskarray(x), *args, **params)
  312:             return masked_array(_d, mask=_m)
  313:         else:
  314:             _d = func(np.asarray(x), *args, **params)
  315:             _m = func(getmaskarray(x), *args, **params)
  316:             return masked_array(_d, mask=_m)
  317: 
  318: 
  319: class _fromnxfunction_seq(_fromnxfunction):
  320:     """
  321:     A version of `_fromnxfunction` that is called with a single sequence
  322:     of arrays followed by auxiliary args that are passed verbatim for
  323:     both the data and mask calls.
  324:     """
  325:     def __call__(self, x, *args, **params):
  326:         func = getattr(np, self.__name__)
  327:         _d = func(tuple(np.asarray(a) for a in x), *args, **params)
  328:         _m = func(tuple(getmaskarray(a) for a in x), *args, **params)
  329:         return masked_array(_d, mask=_m)
  330: 
  331: 
  332: class _fromnxfunction_args(_fromnxfunction):
  333:     """
  334:     A version of `_fromnxfunction` that is called with multiple array
  335:     arguments. The first non-array-like input marks the beginning of the
  336:     arguments that are passed verbatim for both the data and mask calls.
  337:     Array arguments are processed independently and the results are
  338:     returned in a list. If only one array is found, the return value is
  339:     just the processed array instead of a list.
  340:     """
  341:     def __call__(self, *args, **params):
  342:         func = getattr(np, self.__name__)
  343:         arrays = []
  344:         args = list(args)
  345:         while len(args) > 0 and issequence(args[0]):
  346:             arrays.append(args.pop(0))
  347:         res = []
  348:         for x in arrays:
  349:             _d = func(np.asarray(x), *args, **params)
  350:             _m = func(getmaskarray(x), *args, **params)
  351:             res.append(masked_array(_d, mask=_m))
  352:         if len(arrays) == 1:
  353:             return res[0]
  354:         return res
  355: 
  356: 
  357: class _fromnxfunction_allargs(_fromnxfunction):
  358:     """
  359:     A version of `_fromnxfunction` that is called with multiple array
  360:     arguments. Similar to `_fromnxfunction_args` except that all args
  361:     are converted to arrays even if they are not so already. This makes
  362:     it possible to process scalars as 1-D arrays. Only keyword arguments
  363:     are passed through verbatim for the data and mask calls. Arrays
  364:     arguments are processed independently and the results are returned
  365:     in a list. If only one arg is present, the return value is just the
  366:     processed array instead of a list.
  367:     """
  368:     def __call__(self, *args, **params):
  369:         func = getattr(np, self.__name__)
  370:         res = []
  371:         for x in args:
  372:             _d = func(np.asarray(x), **params)
  373:             _m = func(getmaskarray(x), **params)
  374:             res.append(masked_array(_d, mask=_m))
  375:         if len(args) == 1:
  376:             return res[0]
  377:         return res
  378: 
  379: 
  380: atleast_1d = _fromnxfunction_allargs('atleast_1d')
  381: atleast_2d = _fromnxfunction_allargs('atleast_2d')
  382: atleast_3d = _fromnxfunction_allargs('atleast_3d')
  383: 
  384: vstack = row_stack = _fromnxfunction_seq('vstack')
  385: hstack = _fromnxfunction_seq('hstack')
  386: column_stack = _fromnxfunction_seq('column_stack')
  387: dstack = _fromnxfunction_seq('dstack')
  388: stack = _fromnxfunction_seq('stack')
  389: 
  390: hsplit = _fromnxfunction_single('hsplit')
  391: 
  392: diagflat = _fromnxfunction_single('diagflat')
  393: 
  394: 
  395: #####--------------------------------------------------------------------------
  396: #----
  397: #####--------------------------------------------------------------------------
  398: def flatten_inplace(seq):
  399:     """Flatten a sequence in place."""
  400:     k = 0
  401:     while (k != len(seq)):
  402:         while hasattr(seq[k], '__iter__'):
  403:             seq[k:(k + 1)] = seq[k]
  404:         k += 1
  405:     return seq
  406: 
  407: 
  408: def apply_along_axis(func1d, axis, arr, *args, **kwargs):
  409:     """
  410:     (This docstring should be overwritten)
  411:     """
  412:     arr = array(arr, copy=False, subok=True)
  413:     nd = arr.ndim
  414:     axis = normalize_axis_index(axis, nd)
  415:     ind = [0] * (nd - 1)
  416:     i = np.zeros(nd, 'O')
  417:     indlist = list(range(nd))
  418:     indlist.remove(axis)
  419:     i[axis] = slice(None, None)
  420:     outshape = np.asarray(arr.shape).take(indlist)
  421:     i.put(indlist, ind)
  422:     res = func1d(arr[tuple(i.tolist())], *args, **kwargs)
  423:     #  if res is a number, then we have a smaller output array
  424:     asscalar = np.isscalar(res)
  425:     if not asscalar:
  426:         try:
  427:             len(res)
  428:         except TypeError:
  429:             asscalar = True
  430:     # Note: we shouldn't set the dtype of the output from the first result
  431:     # so we force the type to object, and build a list of dtypes.  We'll
  432:     # just take the largest, to avoid some downcasting
  433:     dtypes = []
  434:     if asscalar:
  435:         dtypes.append(np.asarray(res).dtype)
  436:         outarr = zeros(outshape, object)
  437:         outarr[tuple(ind)] = res
  438:         Ntot = np.prod(outshape)
  439:         k = 1
  440:         while k < Ntot:
  441:             # increment the index
  442:             ind[-1] += 1
  443:             n = -1
  444:             while (ind[n] >= outshape[n]) and (n > (1 - nd)):
  445:                 ind[n - 1] += 1
  446:                 ind[n] = 0
  447:                 n -= 1
  448:             i.put(indlist, ind)
  449:             res = func1d(arr[tuple(i.tolist())], *args, **kwargs)
  450:             outarr[tuple(ind)] = res
  451:             dtypes.append(asarray(res).dtype)
  452:             k += 1
  453:     else:
  454:         res = array(res, copy=False, subok=True)
  455:         j = i.copy()
  456:         j[axis] = ([slice(None, None)] * res.ndim)
  457:         j.put(indlist, ind)
  458:         Ntot = np.prod(outshape)
  459:         holdshape = outshape
  460:         outshape = list(arr.shape)
  461:         outshape[axis] = res.shape
  462:         dtypes.append(asarray(res).dtype)
  463:         outshape = flatten_inplace(outshape)
  464:         outarr = zeros(outshape, object)
  465:         outarr[tuple(flatten_inplace(j.tolist()))] = res
  466:         k = 1
  467:         while k < Ntot:
  468:             # increment the index
  469:             ind[-1] += 1
  470:             n = -1
  471:             while (ind[n] >= holdshape[n]) and (n > (1 - nd)):
  472:                 ind[n - 1] += 1
  473:                 ind[n] = 0
  474:                 n -= 1
  475:             i.put(indlist, ind)
  476:             j.put(indlist, ind)
  477:             res = func1d(arr[tuple(i.tolist())], *args, **kwargs)
  478:             outarr[tuple(flatten_inplace(j.tolist()))] = res
  479:             dtypes.append(asarray(res).dtype)
  480:             k += 1
  481:     max_dtypes = np.dtype(np.asarray(dtypes).max())
  482:     if not hasattr(arr, '_mask'):
  483:         result = np.asarray(outarr, dtype=max_dtypes)
  484:     else:
  485:         result = asarray(outarr, dtype=max_dtypes)
  486:         result.fill_value = ma.default_fill_value(result)
  487:     return result
  488: 
  489: 
  490: apply_along_axis.__doc__ = np.apply_along_axis.__doc__
  491: 
  492: 
  493: def apply_over_axes(func, a, axes):
  494:     """
  495:     (This docstring will be overwritten)
  496:     """
  497:     val = asarray(a)
  498:     N = a.ndim
  499:     if array(axes).ndim == 0:
  500:         axes = (axes,)
  501:     for axis in axes:
  502:         if axis < 0:
  503:             axis = N + axis
  504:         args = (val, axis)
  505:         res = func(*args)
  506:         if res.ndim == val.ndim:
  507:             val = res
  508:         else:
  509:             res = ma.expand_dims(res, axis)
  510:             if res.ndim == val.ndim:
  511:                 val = res
  512:             else:
  513:                 raise ValueError("function is not returning "
  514:                         "an array of the correct shape")
  515:     return val
  516: 
  517: 
  518: if apply_over_axes.__doc__ is not None:
  519:     apply_over_axes.__doc__ = np.apply_over_axes.__doc__[
  520:         :np.apply_over_axes.__doc__.find('Notes')].rstrip() + \
  521:     """
  522: 
  523:     Examples
  524:     --------
  525:     >>> import numpy as np
  526:     >>> a = np.ma.arange(24).reshape(2,3,4)
  527:     >>> a[:,0,1] = np.ma.masked
  528:     >>> a[:,1,:] = np.ma.masked
  529:     >>> a
  530:     masked_array(
  531:       data=[[[0, --, 2, 3],
  532:              [--, --, --, --],
  533:              [8, 9, 10, 11]],
  534:             [[12, --, 14, 15],
  535:              [--, --, --, --],
  536:              [20, 21, 22, 23]]],
  537:       mask=[[[False,  True, False, False],
  538:              [ True,  True,  True,  True],
  539:              [False, False, False, False]],
  540:             [[False,  True, False, False],
  541:              [ True,  True,  True,  True],
  542:              [False, False, False, False]]],
  543:       fill_value=999999)
  544:     >>> np.ma.apply_over_axes(np.ma.sum, a, [0,2])
  545:     masked_array(
  546:       data=[[[46],
  547:              [--],
  548:              [124]]],
  549:       mask=[[[False],
  550:              [ True],
  551:              [False]]],
  552:       fill_value=999999)
  553: 
  554:     Tuple axis arguments to ufuncs are equivalent:
  555: 
  556:     >>> np.ma.sum(a, axis=(0,2)).reshape((1,-1,1))
  557:     masked_array(
  558:       data=[[[46],
  559:              [--],
  560:              [124]]],
  561:       mask=[[[False],
  562:              [ True],
  563:              [False]]],
  564:       fill_value=999999)
  565:     """
  566: 
  567: 
  568: def average(a, axis=None, weights=None, returned=False, *,
  569:             keepdims=np._NoValue):
  570:     """
  571:     Return the weighted average of array over the given axis.
  572: 
  573:     Parameters
  574:     ----------
  575:     a : array_like
  576:         Data to be averaged.
  577:         Masked entries are not taken into account in the computation.
  578:     axis : None or int or tuple of ints, optional
  579:         Axis or axes along which to average `a`.  The default,
  580:         `axis=None`, will average over all of the elements of the input array.
  581:         If axis is a tuple of ints, averaging is performed on all of the axes
  582:         specified in the tuple instead of a single axis or all the axes as
  583:         before.
  584:     weights : array_like, optional
  585:         An array of weights associated with the values in `a`. Each value in
  586:         `a` contributes to the average according to its associated weight.
  587:         The array of weights must be the same shape as `a` if no axis is
  588:         specified, otherwise the weights must have dimensions and shape
  589:         consistent with `a` along the specified axis.
  590:         If `weights=None`, then all data in `a` are assumed to have a
  591:         weight equal to one.
  592:         The calculation is::
  593: 
  594:             avg = sum(a * weights) / sum(weights)
  595: 
  596:         where the sum is over all included elements.
  597:         The only constraint on the values of `weights` is that `sum(weights)`
  598:         must not be 0.
  599:     returned : bool, optional
  600:         Flag indicating whether a tuple ``(result, sum of weights)``
  601:         should be returned as output (True), or just the result (False).
  602:         Default is False.
  603:     keepdims : bool, optional
  604:         If this is set to True, the axes which are reduced are left
  605:         in the result as dimensions with size one. With this option,
  606:         the result will broadcast correctly against the original `a`.
  607:         *Note:* `keepdims` will not work with instances of `numpy.matrix`
  608:         or other classes whose methods do not support `keepdims`.
  609: 
  610:         .. versionadded:: 1.23.0
  611: 
  612:     Returns
  613:     -------
  614:     average, [sum_of_weights] : (tuple of) scalar or MaskedArray
  615:         The average along the specified axis. When returned is `True`,
  616:         return a tuple with the average as the first element and the sum
  617:         of the weights as the second element. The return type is `np.float64`
  618:         if `a` is of integer type and floats smaller than `float64`, or the
  619:         input data-type, otherwise. If returned, `sum_of_weights` is always
  620:         `float64`.
  621: 
  622:     Raises
  623:     ------
  624:     ZeroDivisionError
  625:         When all weights along axis are zero. See `numpy.ma.average` for a
  626:         version robust to this type of error.
  627:     TypeError
  628:         When `weights` does not have the same shape as `a`, and `axis=None`.
  629:     ValueError
  630:         When `weights` does not have dimensions and shape consistent with `a`
  631:         along specified `axis`.
  632: 
  633:     Examples
  634:     --------
  635:     >>> import numpy as np
  636:     >>> a = np.ma.array([1., 2., 3., 4.], mask=[False, False, True, True])
  637:     >>> np.ma.average(a, weights=[3, 1, 0, 0])
  638:     1.25
  639: 
  640:     >>> x = np.ma.arange(6.).reshape(3, 2)
  641:     >>> x
  642:     masked_array(
  643:       data=[[0., 1.],
  644:             [2., 3.],
  645:             [4., 5.]],
  646:       mask=False,
  647:       fill_value=1e+20)
  648:     >>> data = np.arange(8).reshape((2, 2, 2))
  649:     >>> data
  650:     array([[[0, 1],
  651:             [2, 3]],
  652:            [[4, 5],
  653:             [6, 7]]])
  654:     >>> np.ma.average(data, axis=(0, 1), weights=[[1./4, 3./4], [1., 1./2]])
  655:     masked_array(data=[3.4, 4.4],
  656:              mask=[False, False],
  657:        fill_value=1e+20)
  658:     >>> np.ma.average(data, axis=0, weights=[[1./4, 3./4], [1., 1./2]])
  659:     Traceback (most recent call last):
  660:         ...
  661:     ValueError: Shape of weights must be consistent
  662:     with shape of a along specified axis.
  663: 
  664:     >>> avg, sumweights = np.ma.average(x, axis=0, weights=[1, 2, 3],
  665:     ...                                 returned=True)
  666:     >>> avg
  667:     masked_array(data=[2.6666666666666665, 3.6666666666666665],
  668:                  mask=[False, False],
  669:            fill_value=1e+20)
  670: 
  671:     With ``keepdims=True``, the following result has shape (3, 1).
  672: 
  673:     >>> np.ma.average(x, axis=1, keepdims=True)
  674:     masked_array(
  675:       data=[[0.5],
  676:             [2.5],
  677:             [4.5]],
  678:       mask=False,
  679:       fill_value=1e+20)
  680:     """
  681:     a = asarray(a)
  682:     m = getmask(a)
  683: 
  684:     if axis is not None:
  685:         axis = normalize_axis_tuple(axis, a.ndim, argname="axis")
  686: 
  687:     if keepdims is np._NoValue:
  688:         # Don't pass on the keepdims argument if one wasn't given.
  689:         keepdims_kw = {}
  690:     else:
  691:         keepdims_kw = {'keepdims': keepdims}
  692: 
  693:     if weights is None:
  694:         avg = a.mean(axis, **keepdims_kw)
  695:         scl = avg.dtype.type(a.count(axis))
  696:     else:
  697:         wgt = asarray(weights)
  698: 
  699:         if issubclass(a.dtype.type, (np.integer, np.bool)):
  700:             result_dtype = np.result_type(a.dtype, wgt.dtype, 'f8')
  701:         else:
  702:             result_dtype = np.result_type(a.dtype, wgt.dtype)
  703: 
  704:         # Sanity checks
  705:         if a.shape != wgt.shape:
  706:             if axis is None:
  707:                 raise TypeError(
  708:                     "Axis must be specified when shapes of a and weights "
  709:                     "differ.")
  710:             if wgt.shape != tuple(a.shape[ax] for ax in axis):
  711:                 raise ValueError(
  712:                     "Shape of weights must be consistent with "
  713:                     "shape of a along specified axis.")
  714: 
  715:             # setup wgt to broadcast along axis
  716:             wgt = wgt.transpose(np.argsort(axis))
  717:             wgt = wgt.reshape(tuple((s if ax in axis else 1)
  718:                                     for ax, s in enumerate(a.shape)))
  719: 
  720:         if m is not nomask:
  721:             wgt = wgt * (~a.mask)
  722:             wgt.mask |= a.mask
  723: 
  724:         scl = wgt.sum(axis=axis, dtype=result_dtype, **keepdims_kw)
  725:         avg = np.multiply(a, wgt,
  726:                           dtype=result_dtype).sum(axis, **keepdims_kw) / scl
  727: 
  728:     if returned:
  729:         if scl.shape != avg.shape:
  730:             scl = np.broadcast_to(scl, avg.shape).copy()
  731:         return avg, scl
  732:     else:
  733:         return avg
  734: 
  735: 
  736: def median(a, axis=None, out=None, overwrite_input=False, keepdims=False):
  737:     """
  738:     Compute the median along the specified axis.
  739: 
  740:     Returns the median of the array elements.
  741: 
  742:     Parameters
  743:     ----------
  744:     a : array_like
  745:         Input array or object that can be converted to an array.
  746:     axis : int, optional
  747:         Axis along which the medians are computed. The default (None) is
  748:         to compute the median along a flattened version of the array.
  749:     out : ndarray, optional
  750:         Alternative output array in which to place the result. It must
  751:         have the same shape and buffer length as the expected output
  752:         but the type will be cast if necessary.
  753:     overwrite_input : bool, optional
  754:         If True, then allow use of memory of input array (a) for
  755:         calculations. The input array will be modified by the call to
  756:         median. This will save memory when you do not need to preserve
  757:         the contents of the input array. Treat the input as undefined,
  758:         but it will probably be fully or partially sorted. Default is
  759:         False. Note that, if `overwrite_input` is True, and the input
  760:         is not already an `ndarray`, an error will be raised.
  761:     keepdims : bool, optional
  762:         If this is set to True, the axes which are reduced are left
  763:         in the result as dimensions with size one. With this option,
  764:         the result will broadcast correctly against the input array.
  765: 
  766:     Returns
  767:     -------
  768:     median : ndarray
  769:         A new array holding the result is returned unless out is
  770:         specified, in which case a reference to out is returned.
  771:         Return data-type is `float64` for integers and floats smaller than
  772:         `float64`, or the input data-type, otherwise.
  773: 
  774:     See Also
  775:     --------
  776:     mean
  777: 
  778:     Notes
  779:     -----
  780:     Given a vector ``V`` with ``N`` non masked values, the median of ``V``
  781:     is the middle value of a sorted copy of ``V`` (``Vs``) - i.e.
  782:     ``Vs[(N-1)/2]``, when ``N`` is odd, or ``{Vs[N/2 - 1] + Vs[N/2]}/2``
  783:     when ``N`` is even.
  784: 
  785:     Examples
  786:     --------
  787:     >>> import numpy as np
  788:     >>> x = np.ma.array(np.arange(8), mask=[0]*4 + [1]*4)
  789:     >>> np.ma.median(x)
  790:     1.5
  791: 
  792:     >>> x = np.ma.array(np.arange(10).reshape(2, 5), mask=[0]*6 + [1]*4)
  793:     >>> np.ma.median(x)
  794:     2.5
  795:     >>> np.ma.median(x, axis=-1, overwrite_input=True)
  796:     masked_array(data=[2.0, 5.0],
  797:                  mask=[False, False],
  798:            fill_value=1e+20)
  799: 
  800:     """
  801:     if not hasattr(a, 'mask'):
  802:         m = np.median(getdata(a, subok=True), axis=axis,
  803:                       out=out, overwrite_input=overwrite_input,
  804:                       keepdims=keepdims)
  805:         if isinstance(m, np.ndarray) and 1 <= m.ndim:
  806:             return masked_array(m, copy=False)
  807:         else:
  808:             return m
  809: 
  810:     return _ureduce(a, func=_median, keepdims=keepdims, axis=axis, out=out,
  811:                     overwrite_input=overwrite_input)
  812: 
  813: 
  814: def _median(a, axis=None, out=None, overwrite_input=False):
  815:     # when an unmasked NaN is present return it, so we need to sort the NaN
  816:     # values behind the mask
  817:     if np.issubdtype(a.dtype, np.inexact):
  818:         fill_value = np.inf
  819:     else:
  820:         fill_value = None
  821:     if overwrite_input:
  822:         if axis is None:
  823:             asorted = a.ravel()
  824:             asorted.sort(fill_value=fill_value)
  825:         else:
  826:             a.sort(axis=axis, fill_value=fill_value)
  827:             asorted = a
  828:     else:
  829:         asorted = sort(a, axis=axis, fill_value=fill_value)
  830: 
  831:     if axis is None:
  832:         axis = 0
  833:     else:
  834:         axis = normalize_axis_index(axis, asorted.ndim)
  835: 
  836:     if asorted.shape[axis] == 0:
  837:         # for empty axis integer indices fail so use slicing to get same result
  838:         # as median (which is mean of empty slice = nan)
  839:         indexer = [slice(None)] * asorted.ndim
  840:         indexer[axis] = slice(0, 0)
  841:         indexer = tuple(indexer)
  842:         return np.ma.mean(asorted[indexer], axis=axis, out=out)
  843: 
  844:     if asorted.ndim == 1:
  845:         idx, odd = divmod(count(asorted), 2)
  846:         mid = asorted[idx + odd - 1:idx + 1]
  847:         if np.issubdtype(asorted.dtype, np.inexact) and asorted.size > 0:
  848:             # avoid inf / x = masked
  849:             s = mid.sum(out=out)
  850:             if not odd:
  851:                 s = np.true_divide(s, 2., casting='safe', out=out)
  852:             s = np.lib._utils_impl._median_nancheck(asorted, s, axis)
  853:         else:
  854:             s = mid.mean(out=out)
  855: 
  856:         # if result is masked either the input contained enough
  857:         # minimum_fill_value so that it would be the median or all values
  858:         # masked
  859:         if np.ma.is_masked(s) and not np.all(asorted.mask):
  860:             return np.ma.minimum_fill_value(asorted)
  861:         return s
  862: 
  863:     counts = count(asorted, axis=axis, keepdims=True)
  864:     h = counts // 2
  865: 
  866:     # duplicate high if odd number of elements so mean does nothing
  867:     odd = counts % 2 == 1
  868:     l = np.where(odd, h, h - 1)
  869: 
  870:     lh = np.concatenate([l, h], axis=axis)
  871: 
  872:     # get low and high median
  873:     low_high = np.take_along_axis(asorted, lh, axis=axis)
  874: 
  875:     def replace_masked(s):
  876:         # Replace masked entries with minimum_full_value unless it all values
  877:         # are masked. This is required as the sort order of values equal or
  878:         # larger than the fill value is undefined and a valid value placed
  879:         # elsewhere, e.g. [4, --, inf].
  880:         if np.ma.is_masked(s):
  881:             rep = (~np.all(asorted.mask, axis=axis, keepdims=True)) & s.mask
  882:             s.data[rep] = np.ma.minimum_fill_value(asorted)
  883:             s.mask[rep] = False
  884: 
  885:     replace_masked(low_high)
  886: 
  887:     if np.issubdtype(asorted.dtype, np.inexact):
  888:         # avoid inf / x = masked
  889:         s = np.ma.sum(low_high, axis=axis, out=out)
  890:         np.true_divide(s.data, 2., casting='unsafe', out=s.data)
  891: 
  892:         s = np.lib._utils_impl._median_nancheck(asorted, s, axis)
  893:     else:
  894:         s = np.ma.mean(low_high, axis=axis, out=out)
  895: 
  896:     return s
  897: 
  898: 
  899: def compress_nd(x, axis=None):
  900:     """Suppress slices from multiple dimensions which contain masked values.
  901: 
  902:     Parameters
  903:     ----------
  904:     x : array_like, MaskedArray
  905:         The array to operate on. If not a MaskedArray instance (or if no array
  906:         elements are masked), `x` is interpreted as a MaskedArray with `mask`
  907:         set to `nomask`.
  908:     axis : tuple of ints or int, optional
  909:         Which dimensions to suppress slices from can be configured with this
  910:         parameter.
  911:         - If axis is a tuple of ints, those are the axes to suppress slices from.
  912:         - If axis is an int, then that is the only axis to suppress slices from.
  913:         - If axis is None, all axis are selected.
  914: 
  915:     Returns
  916:     -------
  917:     compress_array : ndarray
  918:         The compressed array.
  919: 
  920:     Examples
  921:     --------
  922:     >>> import numpy as np
  923:     >>> arr = [[1, 2], [3, 4]]
  924:     >>> mask = [[0, 1], [0, 0]]
  925:     >>> x = np.ma.array(arr, mask=mask)
  926:     >>> np.ma.compress_nd(x, axis=0)
  927:     array([[3, 4]])
  928:     >>> np.ma.compress_nd(x, axis=1)
  929:     array([[1],
  930:            [3]])
  931:     >>> np.ma.compress_nd(x)
  932:     array([[3]])
  933: 
  934:     """
  935:     x = asarray(x)
  936:     m = getmask(x)
  937:     # Set axis to tuple of ints
  938:     if axis is None:
  939:         axis = tuple(range(x.ndim))
  940:     else:
  941:         axis = normalize_axis_tuple(axis, x.ndim)
  942: 
  943:     # Nothing is masked: return x
  944:     if m is nomask or not m.any():
  945:         return x._data
  946:     # All is masked: return empty
  947:     if m.all():
  948:         return nxarray([])
  949:     # Filter elements through boolean indexing
  950:     data = x._data
  951:     for ax in axis:
  952:         axes = tuple(list(range(ax)) + list(range(ax + 1, x.ndim)))
  953:         data = data[(slice(None),) * ax + (~m.any(axis=axes),)]
  954:     return data
  955: 
  956: 
  957: def compress_rowcols(x, axis=None):
  958:     """
  959:     Suppress the rows and/or columns of a 2-D array that contain
  960:     masked values.
  961: 
  962:     The suppression behavior is selected with the `axis` parameter.
  963: 
  964:     - If axis is None, both rows and columns are suppressed.
  965:     - If axis is 0, only rows are suppressed.
  966:     - If axis is 1 or -1, only columns are suppressed.
  967: 
  968:     Parameters
  969:     ----------
  970:     x : array_like, MaskedArray
  971:         The array to operate on.  If not a MaskedArray instance (or if no array
  972:         elements are masked), `x` is interpreted as a MaskedArray with
  973:         `mask` set to `nomask`. Must be a 2D array.
  974:     axis : int, optional
  975:         Axis along which to perform the operation. Default is None.
  976: 
  977:     Returns
  978:     -------
  979:     compressed_array : ndarray
  980:         The compressed array.
  981: 
  982:     Examples
  983:     --------
  984:     >>> import numpy as np
  985:     >>> x = np.ma.array(np.arange(9).reshape(3, 3), mask=[[1, 0, 0],
  986:     ...                                                   [1, 0, 0],
  987:     ...                                                   [0, 0, 0]])
  988:     >>> x
  989:     masked_array(
  990:       data=[[--, 1, 2],
  991:             [--, 4, 5],
  992:             [6, 7, 8]],
  993:       mask=[[ True, False, False],
  994:             [ True, False, False],
  995:             [False, False, False]],
  996:       fill_value=999999)
  997: 
  998:     >>> np.ma.compress_rowcols(x)
  999:     array([[7, 8]])
 1000:     >>> np.ma.compress_rowcols(x, 0)
 1001:     array([[6, 7, 8]])
 1002:     >>> np.ma.compress_rowcols(x, 1)
 1003:     array([[1, 2],
 1004:            [4, 5],
 1005:            [7, 8]])
 1006: 
 1007:     """
 1008:     if asarray(x).ndim != 2:
 1009:         raise NotImplementedError("compress_rowcols works for 2D arrays only.")
 1010:     return compress_nd(x, axis=axis)
 1011: 
 1012: 
 1013: def compress_rows(a):
 1014:     """
 1015:     Suppress whole rows of a 2-D array that contain masked values.
 1016: 
 1017:     This is equivalent to ``np.ma.compress_rowcols(a, 0)``, see
 1018:     `compress_rowcols` for details.
 1019: 
 1020:     Parameters
 1021:     ----------
 1022:     x : array_like, MaskedArray
 1023:         The array to operate on. If not a MaskedArray instance (or if no array
 1024:         elements are masked), `x` is interpreted as a MaskedArray with
 1025:         `mask` set to `nomask`. Must be a 2D array.
 1026: 
 1027:     Returns
 1028:     -------
 1029:     compressed_array : ndarray
 1030:         The compressed array.
 1031: 
 1032:     See Also
 1033:     --------
 1034:     compress_rowcols
 1035: 
 1036:     Examples
 1037:     --------
 1038:     >>> import numpy as np
 1039:     >>> a = np.ma.array(np.arange(9).reshape(3, 3), mask=[[1, 0, 0],
 1040:     ...                                                   [1, 0, 0],
 1041:     ...                                                   [0, 0, 0]])
 1042:     >>> np.ma.compress_rows(a)
 1043:     array([[6, 7, 8]])
 1044: 
 1045:     """
 1046:     a = asarray(a)
 1047:     if a.ndim != 2:
 1048:         raise NotImplementedError("compress_rows works for 2D arrays only.")
 1049:     return compress_rowcols(a, 0)
 1050: 
 1051: 
 1052: def compress_cols(a):
 1053:     """
 1054:     Suppress whole columns of a 2-D array that contain masked values.
 1055: 
 1056:     This is equivalent to ``np.ma.compress_rowcols(a, 1)``, see
 1057:     `compress_rowcols` for details.
 1058: 
 1059:     Parameters
 1060:     ----------
 1061:     x : array_like, MaskedArray
 1062:         The array to operate on.  If not a MaskedArray instance (or if no array
 1063:         elements are masked), `x` is interpreted as a MaskedArray with
 1064:         `mask` set to `nomask`. Must be a 2D array.
 1065: 
 1066:     Returns
 1067:     -------
 1068:     compressed_array : ndarray
 1069:         The compressed array.
 1070: 
 1071:     See Also
 1072:     --------
 1073:     compress_rowcols
 1074: 
 1075:     Examples
 1076:     --------
 1077:     >>> import numpy as np
 1078:     >>> a = np.ma.array(np.arange(9).reshape(3, 3), mask=[[1, 0, 0],
 1079:     ...                                                   [1, 0, 0],
 1080:     ...                                                   [0, 0, 0]])
 1081:     >>> np.ma.compress_cols(a)
 1082:     array([[1, 2],
 1083:            [4, 5],
 1084:            [7, 8]])
 1085: 
 1086:     """
 1087:     a = asarray(a)
 1088:     if a.ndim != 2:
 1089:         raise NotImplementedError("compress_cols works for 2D arrays only.")
 1090:     return compress_rowcols(a, 1)
 1091: 
 1092: 
 1093: def mask_rowcols(a, axis=None):
 1094:     """
 1095:     Mask rows and/or columns of a 2D array that contain masked values.
 1096: 
 1097:     Mask whole rows and/or columns of a 2D array that contain
 1098:     masked values.  The masking behavior is selected using the
 1099:     `axis` parameter.
 1100: 
 1101:       - If `axis` is None, rows *and* columns are masked.
 1102:       - If `axis` is 0, only rows are masked.
 1103:       - If `axis` is 1 or -1, only columns are masked.
 1104: 
 1105:     Parameters
 1106:     ----------
 1107:     a : array_like, MaskedArray
 1108:         The array to mask.  If not a MaskedArray instance (or if no array
 1109:         elements are masked), the result is a MaskedArray with `mask` set
 1110:         to `nomask` (False). Must be a 2D array.
 1111:     axis : int, optional
 1112:         Axis along which to perform the operation. If None, applies to a
 1113:         flattened version of the array.
 1114: 
 1115:     Returns
 1116:     -------
 1117:     a : MaskedArray
 1118:         A modified version of the input array, masked depending on the value
 1119:         of the `axis` parameter.
 1120: 
 1121:     Raises
 1122:     ------
 1123:     NotImplementedError
 1124:         If input array `a` is not 2D.
 1125: 
 1126:     See Also
 1127:     --------
 1128:     mask_rows : Mask rows of a 2D array that contain masked values.
 1129:     mask_cols : Mask cols of a 2D array that contain masked values.
 1130:     masked_where : Mask where a condition is met.
 1131: 
 1132:     Notes
 1133:     -----
 1134:     The input array's mask is modified by this function.
 1135: 
 1136:     Examples
 1137:     --------
 1138:     >>> import numpy as np
 1139:     >>> a = np.zeros((3, 3), dtype=int)
 1140:     >>> a[1, 1] = 1
 1141:     >>> a
 1142:     array([[0, 0, 0],
 1143:            [0, 1, 0],
 1144:            [0, 0, 0]])
 1145:     >>> a = np.ma.masked_equal(a, 1)
 1146:     >>> a
 1147:     masked_array(
 1148:       data=[[0, 0, 0],
 1149:             [0, --, 0],
 1150:             [0, 0, 0]],
 1151:       mask=[[False, False, False],
 1152:             [False,  True, False],
 1153:             [False, False, False]],
 1154:       fill_value=1)
 1155:     >>> np.ma.mask_rowcols(a)
 1156:     masked_array(
 1157:       data=[[0, --, 0],
 1158:             [--, --, --],
 1159:             [0, --, 0]],
 1160:       mask=[[False,  True, False],
 1161:             [ True,  True,  True],
 1162:             [False,  True, False]],
 1163:       fill_value=1)
 1164: 
 1165:     """
 1166:     a = array(a, subok=False)
 1167:     if a.ndim != 2:
 1168:         raise NotImplementedError("mask_rowcols works for 2D arrays only.")
 1169:     m = getmask(a)
 1170:     # Nothing is masked: return a
 1171:     if m is nomask or not m.any():
 1172:         return a
 1173:     maskedval = m.nonzero()
 1174:     a._mask = a._mask.copy()
 1175:     if not axis:
 1176:         a[np.unique(maskedval[0])] = masked
 1177:     if axis in [None, 1, -1]:
 1178:         a[:, np.unique(maskedval[1])] = masked
 1179:     return a
 1180: 
 1181: 
 1182: def mask_rows(a, axis=np._NoValue):
 1183:     """
 1184:     Mask rows of a 2D array that contain masked values.
 1185: 
 1186:     This function is a shortcut to ``mask_rowcols`` with `axis` equal to 0.
 1187: 
 1188:     See Also
 1189:     --------
 1190:     mask_rowcols : Mask rows and/or columns of a 2D array.
 1191:     masked_where : Mask where a condition is met.
 1192: 
 1193:     Examples
 1194:     --------
 1195:     >>> import numpy as np
 1196:     >>> a = np.zeros((3, 3), dtype=int)
 1197:     >>> a[1, 1] = 1
 1198:     >>> a
 1199:     array([[0, 0, 0],
 1200:            [0, 1, 0],
 1201:            [0, 0, 0]])
 1202:     >>> a = np.ma.masked_equal(a, 1)
 1203:     >>> a
 1204:     masked_array(
 1205:       data=[[0, 0, 0],
 1206:             [0, --, 0],
 1207:             [0, 0, 0]],
 1208:       mask=[[False, False, False],
 1209:             [False,  True, False],
 1210:             [False, False, False]],
 1211:       fill_value=1)
 1212: 
 1213:     >>> np.ma.mask_rows(a)
 1214:     masked_array(
 1215:       data=[[0, 0, 0],
 1216:             [--, --, --],
 1217:             [0, 0, 0]],
 1218:       mask=[[False, False, False],
 1219:             [ True,  True,  True],
 1220:             [False, False, False]],
 1221:       fill_value=1)
 1222: 
 1223:     """
 1224:     if axis is not np._NoValue:
 1225:         # remove the axis argument when this deprecation expires
 1226:         # NumPy 1.18.0, 2019-11-28
 1227:         warnings.warn(
 1228:             "The axis argument has always been ignored, in future passing it "
 1229:             "will raise TypeError", DeprecationWarning, stacklevel=2)
 1230:     return mask_rowcols(a, 0)
 1231: 
 1232: 
 1233: def mask_cols(a, axis=np._NoValue):
 1234:     """
 1235:     Mask columns of a 2D array that contain masked values.
 1236: 
 1237:     This function is a shortcut to ``mask_rowcols`` with `axis` equal to 1.
 1238: 
 1239:     See Also
 1240:     --------
 1241:     mask_rowcols : Mask rows and/or columns of a 2D array.
 1242:     masked_where : Mask where a condition is met.
 1243: 
 1244:     Examples
 1245:     --------
 1246:     >>> import numpy as np
 1247:     >>> a = np.zeros((3, 3), dtype=int)
 1248:     >>> a[1, 1] = 1
 1249:     >>> a
 1250:     array([[0, 0, 0],
 1251:            [0, 1, 0],
 1252:            [0, 0, 0]])
 1253:     >>> a = np.ma.masked_equal(a, 1)
 1254:     >>> a
 1255:     masked_array(
 1256:       data=[[0, 0, 0],
 1257:             [0, --, 0],
 1258:             [0, 0, 0]],
 1259:       mask=[[False, False, False],
 1260:             [False,  True, False],
 1261:             [False, False, False]],
 1262:       fill_value=1)
 1263:     >>> np.ma.mask_cols(a)
 1264:     masked_array(
 1265:       data=[[0, --, 0],
 1266:             [0, --, 0],
 1267:             [0, --, 0]],
 1268:       mask=[[False,  True, False],
 1269:             [False,  True, False],
 1270:             [False,  True, False]],
 1271:       fill_value=1)
 1272: 
 1273:     """
 1274:     if axis is not np._NoValue:
 1275:         # remove the axis argument when this deprecation expires
 1276:         # NumPy 1.18.0, 2019-11-28
 1277:         warnings.warn(
 1278:             "The axis argument has always been ignored, in future passing it "
 1279:             "will raise TypeError", DeprecationWarning, stacklevel=2)
 1280:     return mask_rowcols(a, 1)
 1281: 
 1282: 
 1283: #####--------------------------------------------------------------------------
 1284: #---- --- arraysetops ---
 1285: #####--------------------------------------------------------------------------
 1286: 
 1287: def ediff1d(arr, to_end=None, to_begin=None):
 1288:     """
 1289:     Compute the differences between consecutive elements of an array.
 1290: 
 1291:     This function is the equivalent of `numpy.ediff1d` that takes masked
 1292:     values into account, see `numpy.ediff1d` for details.
 1293: 
 1294:     See Also
 1295:     --------
 1296:     numpy.ediff1d : Equivalent function for ndarrays.
 1297: 
 1298:     Examples
 1299:     --------
 1300:     >>> import numpy as np
 1301:     >>> arr = np.ma.array([1, 2, 4, 7, 0])
 1302:     >>> np.ma.ediff1d(arr)
 1303:     masked_array(data=[ 1,  2,  3, -7],
 1304:                  mask=False,
 1305:            fill_value=999999)
 1306: 
 1307:     """
 1308:     arr = ma.asanyarray(arr).flat
 1309:     ed = arr[1:] - arr[:-1]
 1310:     arrays = [ed]
 1311:     #
 1312:     if to_begin is not None:
 1313:         arrays.insert(0, to_begin)
 1314:     if to_end is not None:
 1315:         arrays.append(to_end)
 1316:     #
 1317:     if len(arrays) != 1:
 1318:         # We'll save ourselves a copy of a potentially large array in the common
 1319:         # case where neither to_begin or to_end was given.
 1320:         ed = hstack(arrays)
 1321:     #
 1322:     return ed
 1323: 
 1324: 
 1325: def unique(ar1, return_index=False, return_inverse=False):
 1326:     """
 1327:     Finds the unique elements of an array.
 1328: 
 1329:     Masked values are considered the same element (masked). The output array
 1330:     is always a masked array. See `numpy.unique` for more details.
 1331: 
 1332:     See Also
 1333:     --------
 1334:     numpy.unique : Equivalent function for ndarrays.
 1335: 
 1336:     Examples
 1337:     --------
 1338:     >>> import numpy as np
 1339:     >>> a = [1, 2, 1000, 2, 3]
 1340:     >>> mask = [0, 0, 1, 0, 0]
 1341:     >>> masked_a = np.ma.masked_array(a, mask)
 1342:     >>> masked_a
 1343:     masked_array(data=[1, 2, --, 2, 3],
 1344:                 mask=[False, False,  True, False, False],
 1345:         fill_value=999999)
 1346:     >>> np.ma.unique(masked_a)
 1347:     masked_array(data=[1, 2, 3, --],
 1348:                 mask=[False, False, False,  True],
 1349:         fill_value=999999)
 1350:     >>> np.ma.unique(masked_a, return_index=True)
 1351:     (masked_array(data=[1, 2, 3, --],
 1352:                 mask=[False, False, False,  True],
 1353:         fill_value=999999), array([0, 1, 4, 2]))
 1354:     >>> np.ma.unique(masked_a, return_inverse=True)
 1355:     (masked_array(data=[1, 2, 3, --],
 1356:                 mask=[False, False, False,  True],
 1357:         fill_value=999999), array([0, 1, 3, 1, 2]))
 1358:     >>> np.ma.unique(masked_a, return_index=True, return_inverse=True)
 1359:     (masked_array(data=[1, 2, 3, --],
 1360:                 mask=[False, False, False,  True],
 1361:         fill_value=999999), array([0, 1, 4, 2]), array([0, 1, 3, 1, 2]))
 1362:     """
 1363:     output = np.unique(ar1,
 1364:                        return_index=return_index,
 1365:                        return_inverse=return_inverse)
 1366:     if isinstance(output, tuple):
 1367:         output = list(output)
 1368:         output[0] = output[0].view(MaskedArray)
 1369:         output = tuple(output)
 1370:     else:
 1371:         output = output.view(MaskedArray)
 1372:     return output
 1373: 
 1374: 
 1375: def intersect1d(ar1, ar2, assume_unique=False):
 1376:     """
 1377:     Returns the unique elements common to both arrays.
 1378: 
 1379:     Masked values are considered equal one to the other.
 1380:     The output is always a masked array.
 1381: 
 1382:     See `numpy.intersect1d` for more details.
 1383: 
 1384:     See Also
 1385:     --------
 1386:     numpy.intersect1d : Equivalent function for ndarrays.
 1387: 
 1388:     Examples
 1389:     --------
 1390:     >>> import numpy as np
 1391:     >>> x = np.ma.array([1, 3, 3, 3], mask=[0, 0, 0, 1])
 1392:     >>> y = np.ma.array([3, 1, 1, 1], mask=[0, 0, 0, 1])
 1393:     >>> np.ma.intersect1d(x, y)
 1394:     masked_array(data=[1, 3, --],
 1395:                  mask=[False, False,  True],
 1396:            fill_value=999999)
 1397: 
 1398:     """
 1399:     if assume_unique:
 1400:         aux = ma.concatenate((ar1, ar2))
 1401:     else:
 1402:         # Might be faster than unique( intersect1d( ar1, ar2 ) )?
 1403:         aux = ma.concatenate((unique(ar1), unique(ar2)))
 1404:     aux.sort()
 1405:     return aux[:-1][aux[1:] == aux[:-1]]
 1406: 
 1407: 
 1408: def setxor1d(ar1, ar2, assume_unique=False):
 1409:     """
 1410:     Set exclusive-or of 1-D arrays with unique elements.
 1411: 
 1412:     The output is always a masked array. See `numpy.setxor1d` for more details.
 1413: 
 1414:     See Also
 1415:     --------
 1416:     numpy.setxor1d : Equivalent function for ndarrays.
 1417: 
 1418:     Examples
 1419:     --------
 1420:     >>> import numpy as np
 1421:     >>> ar1 = np.ma.array([1, 2, 3, 2, 4])
 1422:     >>> ar2 = np.ma.array([2, 3, 5, 7, 5])
 1423:     >>> np.ma.setxor1d(ar1, ar2)
 1424:     masked_array(data=[1, 4, 5, 7],
 1425:                  mask=False,
 1426:            fill_value=999999)
 1427: 
 1428:     """
 1429:     if not assume_unique:
 1430:         ar1 = unique(ar1)
 1431:         ar2 = unique(ar2)
 1432: 
 1433:     aux = ma.concatenate((ar1, ar2), axis=None)
 1434:     if aux.size == 0:
 1435:         return aux
 1436:     aux.sort()
 1437:     auxf = aux.filled()
 1438: #    flag = ediff1d( aux, to_end = 1, to_begin = 1 ) == 0
 1439:     flag = ma.concatenate(([True], (auxf[1:] != auxf[:-1]), [True]))
 1440: #    flag2 = ediff1d( flag ) == 0
 1441:     flag2 = (flag[1:] == flag[:-1])
 1442:     return aux[flag2]
 1443: 
 1444: 
 1445: def in1d(ar1, ar2, assume_unique=False, invert=False):
 1446:     """
 1447:     Test whether each element of an array is also present in a second
 1448:     array.
 1449: 
 1450:     The output is always a masked array. See `numpy.in1d` for more details.
 1451: 
 1452:     We recommend using :func:`isin` instead of `in1d` for new code.
 1453: 
 1454:     See Also
 1455:     --------
 1456:     isin       : Version of this function that preserves the shape of ar1.
 1457:     numpy.in1d : Equivalent function for ndarrays.
 1458: 
 1459:     Examples
 1460:     --------
 1461:     >>> import numpy as np
 1462:     >>> ar1 = np.ma.array([0, 1, 2, 5, 0])
 1463:     >>> ar2 = [0, 2]
 1464:     >>> np.ma.in1d(ar1, ar2)
 1465:     masked_array(data=[ True, False,  True, False,  True],
 1466:                  mask=False,
 1467:            fill_value=True)
 1468: 
 1469:     """
 1470:     if not assume_unique:
 1471:         ar1, rev_idx = unique(ar1, return_inverse=True)
 1472:         ar2 = unique(ar2)
 1473: 
 1474:     ar = ma.concatenate((ar1, ar2))
 1475:     # We need this to be a stable sort, so always use 'mergesort'
 1476:     # here. The values from the first array should always come before
 1477:     # the values from the second array.
 1478:     order = ar.argsort(kind='mergesort')
 1479:     sar = ar[order]
 1480:     if invert:
 1481:         bool_ar = (sar[1:] != sar[:-1])
 1482:     else:
 1483:         bool_ar = (sar[1:] == sar[:-1])
 1484:     flag = ma.concatenate((bool_ar, [invert]))
 1485:     indx = order.argsort(kind='mergesort')[:len(ar1)]
 1486: 
 1487:     if assume_unique:
 1488:         return flag[indx]
 1489:     else:
 1490:         return flag[indx][rev_idx]
 1491: 
 1492: 
 1493: def isin(element, test_elements, assume_unique=False, invert=False):
 1494:     """
 1495:     Calculates `element in test_elements`, broadcasting over
 1496:     `element` only.
 1497: 
 1498:     The output is always a masked array of the same shape as `element`.
 1499:     See `numpy.isin` for more details.
 1500: 
 1501:     See Also
 1502:     --------
 1503:     in1d       : Flattened version of this function.
 1504:     numpy.isin : Equivalent function for ndarrays.
 1505: 
 1506:     Examples
 1507:     --------
 1508:     >>> import numpy as np
 1509:     >>> element = np.ma.array([1, 2, 3, 4, 5, 6])
 1510:     >>> test_elements = [0, 2]
 1511:     >>> np.ma.isin(element, test_elements)
 1512:     masked_array(data=[False,  True, False, False, False, False],
 1513:                  mask=False,
 1514:            fill_value=True)
 1515: 
 1516:     """
 1517:     element = ma.asarray(element)
 1518:     return in1d(element, test_elements, assume_unique=assume_unique,
 1519:                 invert=invert).reshape(element.shape)
 1520: 
 1521: 
 1522: def union1d(ar1, ar2):
 1523:     """
 1524:     Union of two arrays.
 1525: 
 1526:     The output is always a masked array. See `numpy.union1d` for more details.
 1527: 
 1528:     See Also
 1529:     --------
 1530:     numpy.union1d : Equivalent function for ndarrays.
 1531: 
 1532:     Examples
 1533:     --------
 1534:     >>> import numpy as np
 1535:     >>> ar1 = np.ma.array([1, 2, 3, 4])
 1536:     >>> ar2 = np.ma.array([3, 4, 5, 6])
 1537:     >>> np.ma.union1d(ar1, ar2)
 1538:     masked_array(data=[1, 2, 3, 4, 5, 6],
 1539:              mask=False,
 1540:        fill_value=999999)
 1541: 
 1542:     """
 1543:     return unique(ma.concatenate((ar1, ar2), axis=None))
 1544: 
 1545: 
 1546: def setdiff1d(ar1, ar2, assume_unique=False):
 1547:     """
 1548:     Set difference of 1D arrays with unique elements.
 1549: 
 1550:     The output is always a masked array. See `numpy.setdiff1d` for more
 1551:     details.
 1552: 
 1553:     See Also
 1554:     --------
 1555:     numpy.setdiff1d : Equivalent function for ndarrays.
 1556: 
 1557:     Examples
 1558:     --------
 1559:     >>> import numpy as np
 1560:     >>> x = np.ma.array([1, 2, 3, 4], mask=[0, 1, 0, 1])
 1561:     >>> np.ma.setdiff1d(x, [1, 2])
 1562:     masked_array(data=[3, --],
 1563:                  mask=[False,  True],
 1564:            fill_value=999999)
 1565: 
 1566:     """
 1567:     if assume_unique:
 1568:         ar1 = ma.asarray(ar1).ravel()
 1569:     else:
 1570:         ar1 = unique(ar1)
 1571:         ar2 = unique(ar2)
 1572:     return ar1[in1d(ar1, ar2, assume_unique=True, invert=True)]
 1573: 
 1574: 
 1575: ###############################################################################
 1576: #                                Covariance                                   #
 1577: ###############################################################################
 1578: 
 1579: 
 1580: def _covhelper(x, y=None, rowvar=True, allow_masked=True):
 1581:     """
 1582:     Private function for the computation of covariance and correlation
 1583:     coefficients.
 1584: 
 1585:     """
 1586:     x = ma.array(x, ndmin=2, copy=True, dtype=float)
 1587:     xmask = ma.getmaskarray(x)
 1588:     # Quick exit if we can't process masked data
 1589:     if not allow_masked and xmask.any():
 1590:         raise ValueError("Cannot process masked data.")
 1591:     #
 1592:     if x.shape[0] == 1:
 1593:         rowvar = True
 1594:     # Make sure that rowvar is either 0 or 1
 1595:     rowvar = int(bool(rowvar))
 1596:     axis = 1 - rowvar
 1597:     if rowvar:
 1598:         tup = (slice(None), None)
 1599:     else:
 1600:         tup = (None, slice(None))
 1601:     #
 1602:     if y is None:
 1603:         # Check if we can guarantee that the integers in the (N - ddof)
 1604:         # normalisation can be accurately represented with single-precision
 1605:         # before computing the dot product.
 1606:         if x.shape[0] > 2 ** 24 or x.shape[1] > 2 ** 24:
 1607:             xnm_dtype = np.float64
 1608:         else:
 1609:             xnm_dtype = np.float32
 1610:         xnotmask = np.logical_not(xmask).astype(xnm_dtype)
 1611:     else:
 1612:         y = array(y, copy=False, ndmin=2, dtype=float)
 1613:         ymask = ma.getmaskarray(y)
 1614:         if not allow_masked and ymask.any():
 1615:             raise ValueError("Cannot process masked data.")
 1616:         if xmask.any() or ymask.any():
 1617:             if y.shape == x.shape:
 1618:                 # Define some common mask
 1619:                 common_mask = np.logical_or(xmask, ymask)
 1620:                 if common_mask is not nomask:
 1621:                     xmask = x._mask = y._mask = ymask = common_mask
 1622:                     x._sharedmask = False
 1623:                     y._sharedmask = False
 1624:         x = ma.concatenate((x, y), axis)
 1625:         # Check if we can guarantee that the integers in the (N - ddof)
 1626:         # normalisation can be accurately represented with single-precision
 1627:         # before computing the dot product.
 1628:         if x.shape[0] > 2 ** 24 or x.shape[1] > 2 ** 24:
 1629:             xnm_dtype = np.float64
 1630:         else:
 1631:             xnm_dtype = np.float32
 1632:         xnotmask = np.logical_not(np.concatenate((xmask, ymask), axis)).astype(
 1633:             xnm_dtype
 1634:         )
 1635:     x -= x.mean(axis=rowvar)[tup]
 1636:     return (x, xnotmask, rowvar)
 1637: 
 1638: 
 1639: def cov(x, y=None, rowvar=True, bias=False, allow_masked=True, ddof=None):
 1640:     """
 1641:     Estimate the covariance matrix.
 1642: 
 1643:     Except for the handling of missing data this function does the same as
 1644:     `numpy.cov`. For more details and examples, see `numpy.cov`.
 1645: 
 1646:     By default, masked values are recognized as such. If `x` and `y` have the
 1647:     same shape, a common mask is allocated: if ``x[i,j]`` is masked, then
 1648:     ``y[i,j]`` will also be masked.
 1649:     Setting `allow_masked` to False will raise an exception if values are
 1650:     missing in either of the input arrays.
 1651: 
 1652:     Parameters
 1653:     ----------
 1654:     x : array_like
 1655:         A 1-D or 2-D array containing multiple variables and observations.
 1656:         Each row of `x` represents a variable, and each column a single
 1657:         observation of all those variables. Also see `rowvar` below.
 1658:     y : array_like, optional
 1659:         An additional set of variables and observations. `y` has the same
 1660:         shape as `x`.
 1661:     rowvar : bool, optional
 1662:         If `rowvar` is True (default), then each row represents a
 1663:         variable, with observations in the columns. Otherwise, the relationship
 1664:         is transposed: each column represents a variable, while the rows
 1665:         contain observations.
 1666:     bias : bool, optional
 1667:         Default normalization (False) is by ``(N-1)``, where ``N`` is the
 1668:         number of observations given (unbiased estimate). If `bias` is True,
 1669:         then normalization is by ``N``. This keyword can be overridden by
 1670:         the keyword ``ddof`` in numpy versions >= 1.5.
 1671:     allow_masked : bool, optional
 1672:         If True, masked values are propagated pair-wise: if a value is masked
 1673:         in `x`, the corresponding value is masked in `y`.
 1674:         If False, raises a `ValueError` exception when some values are missing.
 1675:     ddof : {None, int}, optional
 1676:         If not ``None`` normalization is by ``(N - ddof)``, where ``N`` is
 1677:         the number of observations; this overrides the value implied by
 1678:         ``bias``. The default value is ``None``.
 1679: 
 1680:     Raises
 1681:     ------
 1682:     ValueError
 1683:         Raised if some values are missing and `allow_masked` is False.
 1684: 
 1685:     See Also
 1686:     --------
 1687:     numpy.cov
 1688: 
 1689:     Examples
 1690:     --------
 1691:     >>> import numpy as np
 1692:     >>> x = np.ma.array([[0, 1], [1, 1]], mask=[0, 1, 0, 1])
 1693:     >>> y = np.ma.array([[1, 0], [0, 1]], mask=[0, 0, 1, 1])
 1694:     >>> np.ma.cov(x, y)
 1695:     masked_array(
 1696:     data=[[--, --, --, --],
 1697:           [--, --, --, --],
 1698:           [--, --, --, --],
 1699:           [--, --, --, --]],
 1700:     mask=[[ True,  True,  True,  True],
 1701:           [ True,  True,  True,  True],
 1702:           [ True,  True,  True,  True],
 1703:           [ True,  True,  True,  True]],
 1704:     fill_value=1e+20,
 1705:     dtype=float64)
 1706: 
 1707:     """
 1708:     # Check inputs
 1709:     if ddof is not None and ddof != int(ddof):
 1710:         raise ValueError("ddof must be an integer")
 1711:     # Set up ddof
 1712:     if ddof is None:
 1713:         if bias:
 1714:             ddof = 0
 1715:         else:
 1716:             ddof = 1
 1717: 
 1718:     (x, xnotmask, rowvar) = _covhelper(x, y, rowvar, allow_masked)
 1719:     if not rowvar:
 1720:         fact = np.dot(xnotmask.T, xnotmask) - ddof
 1721:         mask = np.less_equal(fact, 0, dtype=bool)
 1722:         with np.errstate(divide="ignore", invalid="ignore"):
 1723:             data = np.dot(filled(x.T, 0), filled(x.conj(), 0)) / fact
 1724:         result = ma.array(data, mask=mask).squeeze()
 1725:     else:
 1726:         fact = np.dot(xnotmask, xnotmask.T) - ddof
 1727:         mask = np.less_equal(fact, 0, dtype=bool)
 1728:         with np.errstate(divide="ignore", invalid="ignore"):
 1729:             data = np.dot(filled(x, 0), filled(x.T.conj(), 0)) / fact
 1730:         result = ma.array(data, mask=mask).squeeze()
 1731:     return result
 1732: 
 1733: 
 1734: def corrcoef(x, y=None, rowvar=True, bias=np._NoValue, allow_masked=True,
 1735:              ddof=np._NoValue):
 1736:     """
 1737:     Return Pearson product-moment correlation coefficients.
 1738: 
 1739:     Except for the handling of missing data this function does the same as
 1740:     `numpy.corrcoef`. For more details and examples, see `numpy.corrcoef`.
 1741: 
 1742:     Parameters
 1743:     ----------
 1744:     x : array_like
 1745:         A 1-D or 2-D array containing multiple variables and observations.
 1746:         Each row of `x` represents a variable, and each column a single
 1747:         observation of all those variables. Also see `rowvar` below.
 1748:     y : array_like, optional
 1749:         An additional set of variables and observations. `y` has the same
 1750:         shape as `x`.
 1751:     rowvar : bool, optional
 1752:         If `rowvar` is True (default), then each row represents a
 1753:         variable, with observations in the columns. Otherwise, the relationship
 1754:         is transposed: each column represents a variable, while the rows
 1755:         contain observations.
 1756:     bias : _NoValue, optional
 1757:         Has no effect, do not use.
 1758: 
 1759:         .. deprecated:: 1.10.0
 1760:     allow_masked : bool, optional
 1761:         If True, masked values are propagated pair-wise: if a value is masked
 1762:         in `x`, the corresponding value is masked in `y`.
 1763:         If False, raises an exception.  Because `bias` is deprecated, this
 1764:         argument needs to be treated as keyword only to avoid a warning.
 1765:     ddof : _NoValue, optional
 1766:         Has no effect, do not use.
 1767: 
 1768:         .. deprecated:: 1.10.0
 1769: 
 1770:     See Also
 1771:     --------
 1772:     numpy.corrcoef : Equivalent function in top-level NumPy module.
 1773:     cov : Estimate the covariance matrix.
 1774: 
 1775:     Notes
 1776:     -----
 1777:     This function accepts but discards arguments `bias` and `ddof`.  This is
 1778:     for backwards compatibility with previous versions of this function.  These
 1779:     arguments had no effect on the return values of the function and can be
 1780:     safely ignored in this and previous versions of numpy.
 1781: 
 1782:     Examples
 1783:     --------
 1784:     >>> import numpy as np
 1785:     >>> x = np.ma.array([[0, 1], [1, 1]], mask=[0, 1, 0, 1])
 1786:     >>> np.ma.corrcoef(x)
 1787:     masked_array(
 1788:       data=[[--, --],
 1789:             [--, --]],
 1790:       mask=[[ True,  True],
 1791:             [ True,  True]],
 1792:       fill_value=1e+20,
 1793:       dtype=float64)
 1794: 
 1795:     """
 1796:     msg = 'bias and ddof have no effect and are deprecated'
 1797:     if bias is not np._NoValue or ddof is not np._NoValue:
 1798:         # 2015-03-15, 1.10
 1799:         warnings.warn(msg, DeprecationWarning, stacklevel=2)
 1800:     # Estimate the covariance matrix.
 1801:     corr = cov(x, y, rowvar, allow_masked=allow_masked)
 1802:     # The non-masked version returns a masked value for a scalar.
 1803:     try:
 1804:         std = ma.sqrt(ma.diagonal(corr))
 1805:     except ValueError:
 1806:         return ma.MaskedConstant()
 1807:     corr /= ma.multiply.outer(std, std)
 1808:     return corr
 1809: 
 1810: #####--------------------------------------------------------------------------
 1811: #---- --- Concatenation helpers ---
 1812: #####--------------------------------------------------------------------------
 1813: 
 1814: class MAxisConcatenator(AxisConcatenator):
 1815:     """
 1816:     Translate slice objects to concatenation along an axis.
 1817: 
 1818:     For documentation on usage, see `mr_class`.
 1819: 
 1820:     See Also
 1821:     --------
 1822:     mr_class
 1823: 
 1824:     """
 1825:     __slots__ = ()
 1826: 
 1827:     concatenate = staticmethod(concatenate)
 1828: 
 1829:     @classmethod
 1830:     def makemat(cls, arr):
 1831:         # There used to be a view as np.matrix here, but we may eventually
 1832:         # deprecate that class. In preparation, we use the unmasked version
 1833:         # to construct the matrix (with copy=False for backwards compatibility
 1834:         # with the .view)
 1835:         data = super().makemat(arr.data, copy=False)
 1836:         return array(data, mask=arr.mask)
 1837: 
 1838:     def __getitem__(self, key):
 1839:         # matrix builder syntax, like 'a, b; c, d'
 1840:         if isinstance(key, str):
 1841:             raise MAError("Unavailable for masked array.")
 1842: 
 1843:         return super().__getitem__(key)
 1844: 
 1845: 
 1846: class mr_class(MAxisConcatenator):
 1847:     """
 1848:     Translate slice objects to concatenation along the first axis.
 1849: 
 1850:     This is the masked array version of `r_`.
 1851: 
 1852:     See Also
 1853:     --------
 1854:     r_
 1855: 
 1856:     Examples
 1857:     --------
 1858:     >>> import numpy as np
 1859:     >>> np.ma.mr_[np.ma.array([1,2,3]), 0, 0, np.ma.array([4,5,6])]
 1860:     masked_array(data=[1, 2, 3, ..., 4, 5, 6],
 1861:                  mask=False,
 1862:            fill_value=999999)
 1863: 
 1864:     """
 1865:     __slots__ = ()
 1866: 
 1867:     def __init__(self):
 1868:         MAxisConcatenator.__init__(self, 0)
 1869: 
 1870: 
 1871: mr_ = mr_class()
 1872: 
 1873: 
 1874: #####--------------------------------------------------------------------------
 1875: #---- Find unmasked data ---
 1876: #####--------------------------------------------------------------------------
 1877: 
 1878: def ndenumerate(a, compressed=True):
 1879:     """
 1880:     Multidimensional index iterator.
 1881: 
 1882:     Return an iterator yielding pairs of array coordinates and values,
 1883:     skipping elements that are masked. With `compressed=False`,
 1884:     `ma.masked` is yielded as the value of masked elements. This
 1885:     behavior differs from that of `numpy.ndenumerate`, which yields the
 1886:     value of the underlying data array.
 1887: 
 1888:     Notes
 1889:     -----
 1890:     .. versionadded:: 1.23.0
 1891: 
 1892:     Parameters
 1893:     ----------
 1894:     a : array_like
 1895:         An array with (possibly) masked elements.
 1896:     compressed : bool, optional
 1897:         If True (default), masked elements are skipped.
 1898: 
 1899:     See Also
 1900:     --------
 1901:     numpy.ndenumerate : Equivalent function ignoring any mask.
 1902: 
 1903:     Examples
 1904:     --------
 1905:     >>> import numpy as np
 1906:     >>> a = np.ma.arange(9).reshape((3, 3))
 1907:     >>> a[1, 0] = np.ma.masked
 1908:     >>> a[1, 2] = np.ma.masked
 1909:     >>> a[2, 1] = np.ma.masked
 1910:     >>> a
 1911:     masked_array(
 1912:       data=[[0, 1, 2],
 1913:             [--, 4, --],
 1914:             [6, --, 8]],
 1915:       mask=[[False, False, False],
 1916:             [ True, False,  True],
 1917:             [False,  True, False]],
 1918:       fill_value=999999)
 1919:     >>> for index, x in np.ma.ndenumerate(a):
 1920:     ...     print(index, x)
 1921:     (0, 0) 0
 1922:     (0, 1) 1
 1923:     (0, 2) 2
 1924:     (1, 1) 4
 1925:     (2, 0) 6
 1926:     (2, 2) 8
 1927: 
 1928:     >>> for index, x in np.ma.ndenumerate(a, compressed=False):
 1929:     ...     print(index, x)
 1930:     (0, 0) 0
 1931:     (0, 1) 1
 1932:     (0, 2) 2
 1933:     (1, 0) --
 1934:     (1, 1) 4
 1935:     (1, 2) --
 1936:     (2, 0) 6
 1937:     (2, 1) --
 1938:     (2, 2) 8
 1939:     """
 1940:     for it, mask in zip(np.ndenumerate(a), getmaskarray(a).flat):
 1941:         if not mask:
 1942:             yield it
 1943:         elif not compressed:
 1944:             yield it[0], masked
 1945: 
 1946: 
 1947: def flatnotmasked_edges(a):
 1948:     """
 1949:     Find the indices of the first and last unmasked values.
 1950: 
 1951:     Expects a 1-D `MaskedArray`, returns None if all values are masked.
 1952: 
 1953:     Parameters
 1954:     ----------
 1955:     a : array_like
 1956:         Input 1-D `MaskedArray`
 1957: 
 1958:     Returns
 1959:     -------
 1960:     edges : ndarray or None
 1961:         The indices of first and last non-masked value in the array.
 1962:         Returns None if all values are masked.
 1963: 
 1964:     See Also
 1965:     --------
 1966:     flatnotmasked_contiguous, notmasked_contiguous, notmasked_edges
 1967:     clump_masked, clump_unmasked
 1968: 
 1969:     Notes
 1970:     -----
 1971:     Only accepts 1-D arrays.
 1972: 
 1973:     Examples
 1974:     --------
 1975:     >>> import numpy as np
 1976:     >>> a = np.ma.arange(10)
 1977:     >>> np.ma.flatnotmasked_edges(a)
 1978:     array([0, 9])
 1979: 
 1980:     >>> mask = (a < 3) | (a > 8) | (a == 5)
 1981:     >>> a[mask] = np.ma.masked
 1982:     >>> np.array(a[~a.mask])
 1983:     array([3, 4, 6, 7, 8])
 1984: 
 1985:     >>> np.ma.flatnotmasked_edges(a)
 1986:     array([3, 8])
 1987: 
 1988:     >>> a[:] = np.ma.masked
 1989:     >>> print(np.ma.flatnotmasked_edges(a))
 1990:     None
 1991: 
 1992:     """
 1993:     m = getmask(a)
 1994:     if m is nomask or not np.any(m):
 1995:         return np.array([0, a.size - 1])
 1996:     unmasked = np.flatnonzero(~m)
 1997:     if len(unmasked) > 0:
 1998:         return unmasked[[0, -1]]
 1999:     else:
 2000:         return None
 2001: 
 2002: 
 2003: def notmasked_edges(a, axis=None):
 2004:     """
 2005:     Find the indices of the first and last unmasked values along an axis.
 2006: 
 2007:     If all values are masked, return None.  Otherwise, return a list
 2008:     of two tuples, corresponding to the indices of the first and last
 2009:     unmasked values respectively.
 2010: 
 2011:     Parameters
 2012:     ----------
 2013:     a : array_like
 2014:         The input array.
 2015:     axis : int, optional
 2016:         Axis along which to perform the operation.
 2017:         If None (default), applies to a flattened version of the array.
 2018: 
 2019:     Returns
 2020:     -------
 2021:     edges : ndarray or list
 2022:         An array of start and end indexes if there are any masked data in
 2023:         the array. If there are no masked data in the array, `edges` is a
 2024:         list of the first and last index.
 2025: 
 2026:     See Also
 2027:     --------
 2028:     flatnotmasked_contiguous, flatnotmasked_edges, notmasked_contiguous
 2029:     clump_masked, clump_unmasked
 2030: 
 2031:     Examples
 2032:     --------
 2033:     >>> import numpy as np
 2034:     >>> a = np.arange(9).reshape((3, 3))
 2035:     >>> m = np.zeros_like(a)
 2036:     >>> m[1:, 1:] = 1
 2037: 
 2038:     >>> am = np.ma.array(a, mask=m)
 2039:     >>> np.array(am[~am.mask])
 2040:     array([0, 1, 2, 3, 6])
 2041: 
 2042:     >>> np.ma.notmasked_edges(am)
 2043:     array([0, 6])
 2044: 
 2045:     """
 2046:     a = asarray(a)
 2047:     if axis is None or a.ndim == 1:
 2048:         return flatnotmasked_edges(a)
 2049:     m = getmaskarray(a)
 2050:     idx = array(np.indices(a.shape), mask=np.asarray([m] * a.ndim))
 2051:     return [tuple(idx[i].min(axis).compressed() for i in range(a.ndim)),
 2052:             tuple(idx[i].max(axis).compressed() for i in range(a.ndim)), ]
 2053: 
 2054: 
 2055: def flatnotmasked_contiguous(a):
 2056:     """
 2057:     Find contiguous unmasked data in a masked array.
 2058: 
 2059:     Parameters
 2060:     ----------
 2061:     a : array_like
 2062:         The input array.
 2063: 
 2064:     Returns
 2065:     -------
 2066:     slice_list : list
 2067:         A sorted sequence of `slice` objects (start index, end index).
 2068: 
 2069:     See Also
 2070:     --------
 2071:     flatnotmasked_edges, notmasked_contiguous, notmasked_edges
 2072:     clump_masked, clump_unmasked
 2073: 
 2074:     Notes
 2075:     -----
 2076:     Only accepts 2-D arrays at most.
 2077: 
 2078:     Examples
 2079:     --------
 2080:     >>> import numpy as np
 2081:     >>> a = np.ma.arange(10)
 2082:     >>> np.ma.flatnotmasked_contiguous(a)
 2083:     [slice(0, 10, None)]
 2084: 
 2085:     >>> mask = (a < 3) | (a > 8) | (a == 5)
 2086:     >>> a[mask] = np.ma.masked
 2087:     >>> np.array(a[~a.mask])
 2088:     array([3, 4, 6, 7, 8])
 2089: 
 2090:     >>> np.ma.flatnotmasked_contiguous(a)
 2091:     [slice(3, 5, None), slice(6, 9, None)]
 2092:     >>> a[:] = np.ma.masked
 2093:     >>> np.ma.flatnotmasked_contiguous(a)
 2094:     []
 2095: 
 2096:     """
 2097:     m = getmask(a)
 2098:     if m is nomask:
 2099:         return [slice(0, a.size)]
 2100:     i = 0
 2101:     result = []
 2102:     for (k, g) in itertools.groupby(m.ravel()):
 2103:         n = len(list(g))
 2104:         if not k:
 2105:             result.append(slice(i, i + n))
 2106:         i += n
 2107:     return result
 2108: 
 2109: 
 2110: def notmasked_contiguous(a, axis=None):
 2111:     """
 2112:     Find contiguous unmasked data in a masked array along the given axis.
 2113: 
 2114:     Parameters
 2115:     ----------
 2116:     a : array_like
 2117:         The input array.
 2118:     axis : int, optional
 2119:         Axis along which to perform the operation.
 2120:         If None (default), applies to a flattened version of the array, and this
 2121:         is the same as `flatnotmasked_contiguous`.
 2122: 
 2123:     Returns
 2124:     -------
 2125:     endpoints : list
 2126:         A list of slices (start and end indexes) of unmasked indexes
 2127:         in the array.
 2128: 
 2129:         If the input is 2d and axis is specified, the result is a list of lists.
 2130: 
 2131:     See Also
 2132:     --------
 2133:     flatnotmasked_edges, flatnotmasked_contiguous, notmasked_edges
 2134:     clump_masked, clump_unmasked
 2135: 
 2136:     Notes
 2137:     -----
 2138:     Only accepts 2-D arrays at most.
 2139: 
 2140:     Examples
 2141:     --------
 2142:     >>> import numpy as np
 2143:     >>> a = np.arange(12).reshape((3, 4))
 2144:     >>> mask = np.zeros_like(a)
 2145:     >>> mask[1:, :-1] = 1; mask[0, 1] = 1; mask[-1, 0] = 0
 2146:     >>> ma = np.ma.array(a, mask=mask)
 2147:     >>> ma
 2148:     masked_array(
 2149:       data=[[0, --, 2, 3],
 2150:             [--, --, --, 7],
 2151:             [8, --, --, 11]],
 2152:       mask=[[False,  True, False, False],
 2153:             [ True,  True,  True, False],
 2154:             [False,  True,  True, False]],
 2155:       fill_value=999999)
 2156:     >>> np.array(ma[~ma.mask])
 2157:     array([ 0,  2,  3,  7, 8, 11])
 2158: 
 2159:     >>> np.ma.notmasked_contiguous(ma)
 2160:     [slice(0, 1, None), slice(2, 4, None), slice(7, 9, None), slice(11, 12, None)]
 2161: 
 2162:     >>> np.ma.notmasked_contiguous(ma, axis=0)
 2163:     [[slice(0, 1, None), slice(2, 3, None)], [], [slice(0, 1, None)], [slice(0, 3, None)]]
 2164: 
 2165:     >>> np.ma.notmasked_contiguous(ma, axis=1)
 2166:     [[slice(0, 1, None), slice(2, 4, None)], [slice(3, 4, None)], [slice(0, 1, None), slice(3, 4, None)]]
 2167: 
 2168:     """  # noqa: E501
 2169:     a = asarray(a)
 2170:     nd = a.ndim
 2171:     if nd > 2:
 2172:         raise NotImplementedError("Currently limited to at most 2D array.")
 2173:     if axis is None or nd == 1:
 2174:         return flatnotmasked_contiguous(a)
 2175:     #
 2176:     result = []
 2177:     #
 2178:     other = (axis + 1) % 2
 2179:     idx = [0, 0]
 2180:     idx[axis] = slice(None, None)
 2181:     #
 2182:     for i in range(a.shape[other]):
 2183:         idx[other] = i
 2184:         result.append(flatnotmasked_contiguous(a[tuple(idx)]))
 2185:     return result
 2186: 
 2187: 
 2188: def _ezclump(mask):
 2189:     """
 2190:     Finds the clumps (groups of data with the same values) for a 1D bool array.
 2191: 
 2192:     Returns a series of slices.
 2193:     """
 2194:     if mask.ndim > 1:
 2195:         mask = mask.ravel()
 2196:     idx = (mask[1:] ^ mask[:-1]).nonzero()
 2197:     idx = idx[0] + 1
 2198: 
 2199:     if mask[0]:
 2200:         if len(idx) == 0:
 2201:             return [slice(0, mask.size)]
 2202: 
 2203:         r = [slice(0, idx[0])]
 2204:         r.extend((slice(left, right)
 2205:                   for left, right in zip(idx[1:-1:2], idx[2::2])))
 2206:     else:
 2207:         if len(idx) == 0:
 2208:             return []
 2209: 
 2210:         r = [slice(left, right) for left, right in zip(idx[:-1:2], idx[1::2])]
 2211: 
 2212:     if mask[-1]:
 2213:         r.append(slice(idx[-1], mask.size))
 2214:     return r
 2215: 
 2216: 
 2217: def clump_unmasked(a):
 2218:     """
 2219:     Return list of slices corresponding to the unmasked clumps of a 1-D array.
 2220:     (A "clump" is defined as a contiguous region of the array).
 2221: 
 2222:     Parameters
 2223:     ----------
 2224:     a : ndarray
 2225:         A one-dimensional masked array.
 2226: 
 2227:     Returns
 2228:     -------
 2229:     slices : list of slice
 2230:         The list of slices, one for each continuous region of unmasked
 2231:         elements in `a`.
 2232: 
 2233:     See Also
 2234:     --------
 2235:     flatnotmasked_edges, flatnotmasked_contiguous, notmasked_edges
 2236:     notmasked_contiguous, clump_masked
 2237: 
 2238:     Examples
 2239:     --------
 2240:     >>> import numpy as np
 2241:     >>> a = np.ma.masked_array(np.arange(10))
 2242:     >>> a[[0, 1, 2, 6, 8, 9]] = np.ma.masked
 2243:     >>> np.ma.clump_unmasked(a)
 2244:     [slice(3, 6, None), slice(7, 8, None)]
 2245: 
 2246:     """
 2247:     mask = getattr(a, '_mask', nomask)
 2248:     if mask is nomask:
 2249:         return [slice(0, a.size)]
 2250:     return _ezclump(~mask)
 2251: 
 2252: 
 2253: def clump_masked(a):
 2254:     """
 2255:     Returns a list of slices corresponding to the masked clumps of a 1-D array.
 2256:     (A "clump" is defined as a contiguous region of the array).
 2257: 
 2258:     Parameters
 2259:     ----------
 2260:     a : ndarray
 2261:         A one-dimensional masked array.
 2262: 
 2263:     Returns
 2264:     -------
 2265:     slices : list of slice
 2266:         The list of slices, one for each continuous region of masked elements
 2267:         in `a`.
 2268: 
 2269:     See Also
 2270:     --------
 2271:     flatnotmasked_edges, flatnotmasked_contiguous, notmasked_edges
 2272:     notmasked_contiguous, clump_unmasked
 2273: 
 2274:     Examples
 2275:     --------
 2276:     >>> import numpy as np
 2277:     >>> a = np.ma.masked_array(np.arange(10))
 2278:     >>> a[[0, 1, 2, 6, 8, 9]] = np.ma.masked
 2279:     >>> np.ma.clump_masked(a)
 2280:     [slice(0, 3, None), slice(6, 7, None), slice(8, 10, None)]
 2281: 
 2282:     """
 2283:     mask = ma.getmask(a)
 2284:     if mask is nomask:
 2285:         return []
 2286:     return _ezclump(mask)
 2287: 
 2288: 
 2289: ###############################################################################
 2290: #                              Polynomial fit                                 #
 2291: ###############################################################################
 2292: 
 2293: 
 2294: def vander(x, n=None):
 2295:     """
 2296:     Masked values in the input array result in rows of zeros.
 2297: 
 2298:     """
 2299:     _vander = np.vander(x, n)
 2300:     m = getmask(x)
 2301:     if m is not nomask:
 2302:         _vander[m] = 0
 2303:     return _vander
 2304: 
 2305: 
 2306: vander.__doc__ = ma.doc_note(np.vander.__doc__, vander.__doc__)
 2307: 
 2308: 
 2309: def polyfit(x, y, deg, rcond=None, full=False, w=None, cov=False):
 2310:     """
 2311:     Any masked values in x is propagated in y, and vice-versa.
 2312: 
 2313:     """
 2314:     x = asarray(x)
 2315:     y = asarray(y)
 2316: 
 2317:     m = getmask(x)
 2318:     if y.ndim == 1:
 2319:         m = mask_or(m, getmask(y))
 2320:     elif y.ndim == 2:
 2321:         my = getmask(mask_rows(y))
 2322:         if my is not nomask:
 2323:             m = mask_or(m, my[:, 0])
 2324:     else:
 2325:         raise TypeError("Expected a 1D or 2D array for y!")
 2326: 
 2327:     if w is not None:
 2328:         w = asarray(w)
 2329:         if w.ndim != 1:
 2330:             raise TypeError("expected a 1-d array for weights")
 2331:         if w.shape[0] != y.shape[0]:
 2332:             raise TypeError("expected w and y to have the same length")
 2333:         m = mask_or(m, getmask(w))
 2334: 
 2335:     if m is not nomask:
 2336:         not_m = ~m
 2337:         if w is not None:
 2338:             w = w[not_m]
 2339:         return np.polyfit(x[not_m], y[not_m], deg, rcond, full, w, cov)
 2340:     else:
 2341:         return np.polyfit(x, y, deg, rcond, full, w, cov)
 2342: 
 2343: 
 2344: polyfit.__doc__ = ma.doc_note(np.polyfit.__doc__, polyfit.__doc__)
