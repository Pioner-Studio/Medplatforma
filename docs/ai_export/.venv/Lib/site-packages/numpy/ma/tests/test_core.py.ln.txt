    1: """Tests suite for MaskedArray & subclassing.
    2: 
    3: :author: Pierre Gerard-Marchant
    4: :contact: pierregm_at_uga_dot_edu
    5: """
    6: __author__ = "Pierre GF Gerard-Marchant"
    7: 
    8: import copy
    9: import itertools
   10: import operator
   11: import pickle
   12: import sys
   13: import textwrap
   14: import warnings
   15: from functools import reduce
   16: 
   17: import pytest
   18: 
   19: import numpy as np
   20: import numpy._core.fromnumeric as fromnumeric
   21: import numpy._core.umath as umath
   22: import numpy.ma.core
   23: from numpy import ndarray
   24: from numpy._utils import asbytes
   25: from numpy.exceptions import AxisError
   26: from numpy.ma.core import (
   27:     MAError,
   28:     MaskedArray,
   29:     MaskError,
   30:     MaskType,
   31:     abs,
   32:     absolute,
   33:     add,
   34:     all,
   35:     allclose,
   36:     allequal,
   37:     alltrue,
   38:     angle,
   39:     anom,
   40:     arange,
   41:     arccos,
   42:     arccosh,
   43:     arcsin,
   44:     arctan,
   45:     arctan2,
   46:     argsort,
   47:     array,
   48:     asarray,
   49:     choose,
   50:     concatenate,
   51:     conjugate,
   52:     cos,
   53:     cosh,
   54:     count,
   55:     default_fill_value,
   56:     diag,
   57:     divide,
   58:     empty,
   59:     empty_like,
   60:     equal,
   61:     exp,
   62:     filled,
   63:     fix_invalid,
   64:     flatten_mask,
   65:     flatten_structured_array,
   66:     fromflex,
   67:     getmask,
   68:     getmaskarray,
   69:     greater,
   70:     greater_equal,
   71:     identity,
   72:     inner,
   73:     isMaskedArray,
   74:     less,
   75:     less_equal,
   76:     log,
   77:     log10,
   78:     make_mask,
   79:     make_mask_descr,
   80:     mask_or,
   81:     masked,
   82:     masked_array,
   83:     masked_equal,
   84:     masked_greater,
   85:     masked_greater_equal,
   86:     masked_inside,
   87:     masked_less,
   88:     masked_less_equal,
   89:     masked_not_equal,
   90:     masked_outside,
   91:     masked_print_option,
   92:     masked_values,
   93:     masked_where,
   94:     max,
   95:     maximum,
   96:     maximum_fill_value,
   97:     min,
   98:     minimum,
   99:     minimum_fill_value,
  100:     mod,
  101:     multiply,
  102:     mvoid,
  103:     nomask,
  104:     not_equal,
  105:     ones,
  106:     ones_like,
  107:     outer,
  108:     power,
  109:     product,
  110:     put,
  111:     putmask,
  112:     ravel,
  113:     repeat,
  114:     reshape,
  115:     resize,
  116:     shape,
  117:     sin,
  118:     sinh,
  119:     sometrue,
  120:     sort,
  121:     sqrt,
  122:     subtract,
  123:     sum,
  124:     take,
  125:     tan,
  126:     tanh,
  127:     transpose,
  128:     where,
  129:     zeros,
  130:     zeros_like,
  131: )
  132: from numpy.ma.testutils import (
  133:     assert_,
  134:     assert_almost_equal,
  135:     assert_array_equal,
  136:     assert_equal,
  137:     assert_equal_records,
  138:     assert_mask_equal,
  139:     assert_not_equal,
  140:     fail_if_equal,
  141: )
  142: from numpy.testing import (
  143:     IS_WASM,
  144:     assert_raises,
  145:     assert_warns,
  146:     suppress_warnings,
  147:     temppath,
  148: )
  149: from numpy.testing._private.utils import requires_memory
  150: 
  151: pi = np.pi
  152: 
  153: 
  154: suppress_copy_mask_on_assignment = suppress_warnings()
  155: suppress_copy_mask_on_assignment.filter(
  156:     numpy.ma.core.MaskedArrayFutureWarning,
  157:     "setting an item on a masked array which has a shared mask will not copy")
  158: 
  159: 
  160: # For parametrized numeric testing
  161: num_dts = [np.dtype(dt_) for dt_ in '?bhilqBHILQefdgFD']
  162: num_ids = [dt_.char for dt_ in num_dts]
  163: 
  164: 
  165: class TestMaskedArray:
  166:     # Base test class for MaskedArrays.
  167: 
  168:     def setup_method(self):
  169:         # Base data definition.
  170:         x = np.array([1., 1., 1., -2., pi / 2.0, 4., 5., -10., 10., 1., 2., 3.])
  171:         y = np.array([5., 0., 3., 2., -1., -4., 0., -10., 10., 1., 0., 3.])
  172:         a10 = 10.
  173:         m1 = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]
  174:         m2 = [0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1]
  175:         xm = masked_array(x, mask=m1)
  176:         ym = masked_array(y, mask=m2)
  177:         z = np.array([-.5, 0., .5, .8])
  178:         zm = masked_array(z, mask=[0, 1, 0, 0])
  179:         xf = np.where(m1, 1e+20, x)
  180:         xm.set_fill_value(1e+20)
  181:         self.d = (x, y, a10, m1, m2, xm, ym, z, zm, xf)
  182: 
  183:     def test_basicattributes(self):
  184:         # Tests some basic array attributes.
  185:         a = array([1, 3, 2])
  186:         b = array([1, 3, 2], mask=[1, 0, 1])
  187:         assert_equal(a.ndim, 1)
  188:         assert_equal(b.ndim, 1)
  189:         assert_equal(a.size, 3)
  190:         assert_equal(b.size, 3)
  191:         assert_equal(a.shape, (3,))
  192:         assert_equal(b.shape, (3,))
  193: 
  194:     def test_basic0d(self):
  195:         # Checks masking a scalar
  196:         x = masked_array(0)
  197:         assert_equal(str(x), '0')
  198:         x = masked_array(0, mask=True)
  199:         assert_equal(str(x), str(masked_print_option))
  200:         x = masked_array(0, mask=False)
  201:         assert_equal(str(x), '0')
  202:         x = array(0, mask=1)
  203:         assert_(x.filled().dtype is x._data.dtype)
  204: 
  205:     def test_basic1d(self):
  206:         # Test of basic array creation and properties in 1 dimension.
  207:         (x, y, a10, m1, m2, xm, ym, z, zm, xf) = self.d
  208:         assert_(not isMaskedArray(x))
  209:         assert_(isMaskedArray(xm))
  210:         assert_((xm - ym).filled(0).any())
  211:         fail_if_equal(xm.mask.astype(int), ym.mask.astype(int))
  212:         s = x.shape
  213:         assert_equal(np.shape(xm), s)
  214:         assert_equal(xm.shape, s)
  215:         assert_equal(xm.dtype, x.dtype)
  216:         assert_equal(zm.dtype, z.dtype)
  217:         assert_equal(xm.size, reduce(lambda x, y: x * y, s))
  218:         assert_equal(count(xm), len(m1) - reduce(lambda x, y: x + y, m1))
  219:         assert_array_equal(xm, xf)
  220:         assert_array_equal(filled(xm, 1.e20), xf)
  221:         assert_array_equal(x, xm)
  222: 
  223:     def test_basic2d(self):
  224:         # Test of basic array creation and properties in 2 dimensions.
  225:         (x, y, a10, m1, m2, xm, ym, z, zm, xf) = self.d
  226:         for s in [(4, 3), (6, 2)]:
  227:             x.shape = s
  228:             y.shape = s
  229:             xm.shape = s
  230:             ym.shape = s
  231:             xf.shape = s
  232: 
  233:             assert_(not isMaskedArray(x))
  234:             assert_(isMaskedArray(xm))
  235:             assert_equal(shape(xm), s)
  236:             assert_equal(xm.shape, s)
  237:             assert_equal(xm.size, reduce(lambda x, y: x * y, s))
  238:             assert_equal(count(xm), len(m1) - reduce(lambda x, y: x + y, m1))
  239:             assert_equal(xm, xf)
  240:             assert_equal(filled(xm, 1.e20), xf)
  241:             assert_equal(x, xm)
  242: 
  243:     def test_concatenate_basic(self):
  244:         # Tests concatenations.
  245:         (x, y, a10, m1, m2, xm, ym, z, zm, xf) = self.d
  246:         # basic concatenation
  247:         assert_equal(np.concatenate((x, y)), concatenate((xm, ym)))
  248:         assert_equal(np.concatenate((x, y)), concatenate((x, y)))
  249:         assert_equal(np.concatenate((x, y)), concatenate((xm, y)))
  250:         assert_equal(np.concatenate((x, y, x)), concatenate((x, ym, x)))
  251: 
  252:     def test_concatenate_alongaxis(self):
  253:         # Tests concatenations.
  254:         (x, y, a10, m1, m2, xm, ym, z, zm, xf) = self.d
  255:         # Concatenation along an axis
  256:         s = (3, 4)
  257:         x.shape = y.shape = xm.shape = ym.shape = s
  258:         assert_equal(xm.mask, np.reshape(m1, s))
  259:         assert_equal(ym.mask, np.reshape(m2, s))
  260:         xmym = concatenate((xm, ym), 1)
  261:         assert_equal(np.concatenate((x, y), 1), xmym)
  262:         assert_equal(np.concatenate((xm.mask, ym.mask), 1), xmym._mask)
  263: 
  264:         x = zeros(2)
  265:         y = array(ones(2), mask=[False, True])
  266:         z = concatenate((x, y))
  267:         assert_array_equal(z, [0, 0, 1, 1])
  268:         assert_array_equal(z.mask, [False, False, False, True])
  269:         z = concatenate((y, x))
  270:         assert_array_equal(z, [1, 1, 0, 0])
  271:         assert_array_equal(z.mask, [False, True, False, False])
  272: 
  273:     def test_concatenate_flexible(self):
  274:         # Tests the concatenation on flexible arrays.
  275:         data = masked_array(list(zip(np.random.rand(10),
  276:                                      np.arange(10))),
  277:                             dtype=[('a', float), ('b', int)])
  278: 
  279:         test = concatenate([data[:5], data[5:]])
  280:         assert_equal_records(test, data)
  281: 
  282:     def test_creation_ndmin(self):
  283:         # Check the use of ndmin
  284:         x = array([1, 2, 3], mask=[1, 0, 0], ndmin=2)
  285:         assert_equal(x.shape, (1, 3))
  286:         assert_equal(x._data, [[1, 2, 3]])
  287:         assert_equal(x._mask, [[1, 0, 0]])
  288: 
  289:     def test_creation_ndmin_from_maskedarray(self):
  290:         # Make sure we're not losing the original mask w/ ndmin
  291:         x = array([1, 2, 3])
  292:         x[-1] = masked
  293:         xx = array(x, ndmin=2, dtype=float)
  294:         assert_equal(x.shape, x._mask.shape)
  295:         assert_equal(xx.shape, xx._mask.shape)
  296: 
  297:     def test_creation_maskcreation(self):
  298:         # Tests how masks are initialized at the creation of Maskedarrays.
  299:         data = arange(24, dtype=float)
  300:         data[[3, 6, 15]] = masked
  301:         dma_1 = MaskedArray(data)
  302:         assert_equal(dma_1.mask, data.mask)
  303:         dma_2 = MaskedArray(dma_1)
  304:         assert_equal(dma_2.mask, dma_1.mask)
  305:         dma_3 = MaskedArray(dma_1, mask=[1, 0, 0, 0] * 6)
  306:         fail_if_equal(dma_3.mask, dma_1.mask)
  307: 
  308:         x = array([1, 2, 3], mask=True)
  309:         assert_equal(x._mask, [True, True, True])
  310:         x = array([1, 2, 3], mask=False)
  311:         assert_equal(x._mask, [False, False, False])
  312:         y = array([1, 2, 3], mask=x._mask, copy=False)
  313:         assert_(np.may_share_memory(x.mask, y.mask))
  314:         y = array([1, 2, 3], mask=x._mask, copy=True)
  315:         assert_(not np.may_share_memory(x.mask, y.mask))
  316:         x = array([1, 2, 3], mask=None)
  317:         assert_equal(x._mask, [False, False, False])
  318: 
  319:     def test_masked_singleton_array_creation_warns(self):
  320:         # The first works, but should not (ideally), there may be no way
  321:         # to solve this, however, as long as `np.ma.masked` is an ndarray.
  322:         np.array(np.ma.masked)
  323:         with pytest.warns(UserWarning):
  324:             # Tries to create a float array, using `float(np.ma.masked)`.
  325:             # We may want to define this is invalid behaviour in the future!
  326:             # (requiring np.ma.masked to be a known NumPy scalar probably
  327:             # with a DType.)
  328:             np.array([3., np.ma.masked])
  329: 
  330:     def test_creation_with_list_of_maskedarrays(self):
  331:         # Tests creating a masked array from a list of masked arrays.
  332:         x = array(np.arange(5), mask=[1, 0, 0, 0, 0])
  333:         data = array((x, x[::-1]))
  334:         assert_equal(data, [[0, 1, 2, 3, 4], [4, 3, 2, 1, 0]])
  335:         assert_equal(data._mask, [[1, 0, 0, 0, 0], [0, 0, 0, 0, 1]])
  336: 
  337:         x.mask = nomask
  338:         data = array((x, x[::-1]))
  339:         assert_equal(data, [[0, 1, 2, 3, 4], [4, 3, 2, 1, 0]])
  340:         assert_(data.mask is nomask)
  341: 
  342:     def test_creation_with_list_of_maskedarrays_no_bool_cast(self):
  343:         # Tests the regression in gh-18551
  344:         masked_str = np.ma.masked_array(['a', 'b'], mask=[True, False])
  345:         normal_int = np.arange(2)
  346:         res = np.ma.asarray([masked_str, normal_int], dtype="U21")
  347:         assert_array_equal(res.mask, [[True, False], [False, False]])
  348: 
  349:         # The above only failed due a long chain of oddity, try also with
  350:         # an object array that cannot be converted to bool always:
  351:         class NotBool:
  352:             def __bool__(self):
  353:                 raise ValueError("not a bool!")
  354:         masked_obj = np.ma.masked_array([NotBool(), 'b'], mask=[True, False])
  355:         # Check that the NotBool actually fails like we would expect:
  356:         with pytest.raises(ValueError, match="not a bool!"):
  357:             np.asarray([masked_obj], dtype=bool)
  358: 
  359:         res = np.ma.asarray([masked_obj, normal_int])
  360:         assert_array_equal(res.mask, [[True, False], [False, False]])
  361: 
  362:     def test_creation_from_ndarray_with_padding(self):
  363:         x = np.array([('A', 0)], dtype={'names': ['f0', 'f1'],
  364:                                         'formats': ['S4', 'i8'],
  365:                                         'offsets': [0, 8]})
  366:         array(x)  # used to fail due to 'V' padding field in x.dtype.descr
  367: 
  368:     def test_unknown_keyword_parameter(self):
  369:         with pytest.raises(TypeError, match="unexpected keyword argument"):
  370:             MaskedArray([1, 2, 3], maks=[0, 1, 0])  # `mask` is misspelled.
  371: 
  372:     def test_asarray(self):
  373:         (x, y, a10, m1, m2, xm, ym, z, zm, xf) = self.d
  374:         xm.fill_value = -9999
  375:         xm._hardmask = True
  376:         xmm = asarray(xm)
  377:         assert_equal(xmm._data, xm._data)
  378:         assert_equal(xmm._mask, xm._mask)
  379:         assert_equal(xmm.fill_value, xm.fill_value)
  380:         assert_equal(xmm._hardmask, xm._hardmask)
  381: 
  382:     def test_asarray_default_order(self):
  383:         # See Issue #6646
  384:         m = np.eye(3).T
  385:         assert_(not m.flags.c_contiguous)
  386: 
  387:         new_m = asarray(m)
  388:         assert_(new_m.flags.c_contiguous)
  389: 
  390:     def test_asarray_enforce_order(self):
  391:         # See Issue #6646
  392:         m = np.eye(3).T
  393:         assert_(not m.flags.c_contiguous)
  394: 
  395:         new_m = asarray(m, order='C')
  396:         assert_(new_m.flags.c_contiguous)
  397: 
  398:     def test_fix_invalid(self):
  399:         # Checks fix_invalid.
  400:         with np.errstate(invalid='ignore'):
  401:             data = masked_array([np.nan, 0., 1.], mask=[0, 0, 1])
  402:             data_fixed = fix_invalid(data)
  403:             assert_equal(data_fixed._data, [data.fill_value, 0., 1.])
  404:             assert_equal(data_fixed._mask, [1., 0., 1.])
  405: 
  406:     def test_maskedelement(self):
  407:         # Test of masked element
  408:         x = arange(6)
  409:         x[1] = masked
  410:         assert_(str(masked) == '--')
  411:         assert_(x[1] is masked)
  412:         assert_equal(filled(x[1], 0), 0)
  413: 
  414:     def test_set_element_as_object(self):
  415:         # Tests setting elements with object
  416:         a = empty(1, dtype=object)
  417:         x = (1, 2, 3, 4, 5)
  418:         a[0] = x
  419:         assert_equal(a[0], x)
  420:         assert_(a[0] is x)
  421: 
  422:         import datetime
  423:         dt = datetime.datetime.now()
  424:         a[0] = dt
  425:         assert_(a[0] is dt)
  426: 
  427:     def test_indexing(self):
  428:         # Tests conversions and indexing
  429:         x1 = np.array([1, 2, 4, 3])
  430:         x2 = array(x1, mask=[1, 0, 0, 0])
  431:         x3 = array(x1, mask=[0, 1, 0, 1])
  432:         x4 = array(x1)
  433:         # test conversion to strings
  434:         str(x2)  # raises?
  435:         repr(x2)  # raises?
  436:         assert_equal(np.sort(x1), sort(x2, endwith=False))
  437:         # tests of indexing
  438:         assert_(type(x2[1]) is type(x1[1]))
  439:         assert_(x1[1] == x2[1])
  440:         assert_(x2[0] is masked)
  441:         assert_equal(x1[2], x2[2])
  442:         assert_equal(x1[2:5], x2[2:5])
  443:         assert_equal(x1[:], x2[:])
  444:         assert_equal(x1[1:], x3[1:])
  445:         x1[2] = 9
  446:         x2[2] = 9
  447:         assert_equal(x1, x2)
  448:         x1[1:3] = 99
  449:         x2[1:3] = 99
  450:         assert_equal(x1, x2)
  451:         x2[1] = masked
  452:         assert_equal(x1, x2)
  453:         x2[1:3] = masked
  454:         assert_equal(x1, x2)
  455:         x2[:] = x1
  456:         x2[1] = masked
  457:         assert_(allequal(getmask(x2), array([0, 1, 0, 0])))
  458:         x3[:] = masked_array([1, 2, 3, 4], [0, 1, 1, 0])
  459:         assert_(allequal(getmask(x3), array([0, 1, 1, 0])))
  460:         x4[:] = masked_array([1, 2, 3, 4], [0, 1, 1, 0])
  461:         assert_(allequal(getmask(x4), array([0, 1, 1, 0])))
  462:         assert_(allequal(x4, array([1, 2, 3, 4])))
  463:         x1 = np.arange(5) * 1.0
  464:         x2 = masked_values(x1, 3.0)
  465:         assert_equal(x1, x2)
  466:         assert_(allequal(array([0, 0, 0, 1, 0], MaskType), x2.mask))
  467:         assert_equal(3.0, x2.fill_value)
  468:         x1 = array([1, 'hello', 2, 3], object)
  469:         x2 = np.array([1, 'hello', 2, 3], object)
  470:         s1 = x1[1]
  471:         s2 = x2[1]
  472:         assert_equal(type(s2), str)
  473:         assert_equal(type(s1), str)
  474:         assert_equal(s1, s2)
  475:         assert_(x1[1:1].shape == (0,))
  476: 
  477:     def test_setitem_no_warning(self):
  478:         # Setitem shouldn't warn, because the assignment might be masked
  479:         # and warning for a masked assignment is weird (see gh-23000)
  480:         # (When the value is masked, otherwise a warning would be acceptable
  481:         # but is not given currently.)
  482:         x = np.ma.arange(60).reshape((6, 10))
  483:         index = (slice(1, 5, 2), [7, 5])
  484:         value = np.ma.masked_all((2, 2))
  485:         value._data[...] = np.inf  # not a valid integer...
  486:         x[index] = value
  487:         # The masked scalar is special cased, but test anyway (it's NaN):
  488:         x[...] = np.ma.masked
  489:         # Finally, a large value that cannot be cast to the float32 `x`
  490:         x = np.ma.arange(3., dtype=np.float32)
  491:         value = np.ma.array([2e234, 1, 1], mask=[True, False, False])
  492:         x[...] = value
  493:         x[[0, 1, 2]] = value
  494: 
  495:     @suppress_copy_mask_on_assignment
  496:     def test_copy(self):
  497:         # Tests of some subtle points of copying and sizing.
  498:         n = [0, 0, 1, 0, 0]
  499:         m = make_mask(n)
  500:         m2 = make_mask(m)
  501:         assert_(m is m2)
  502:         m3 = make_mask(m, copy=True)
  503:         assert_(m is not m3)
  504: 
  505:         x1 = np.arange(5)
  506:         y1 = array(x1, mask=m)
  507:         assert_equal(y1._data.__array_interface__, x1.__array_interface__)
  508:         assert_(allequal(x1, y1.data))
  509:         assert_equal(y1._mask.__array_interface__, m.__array_interface__)
  510: 
  511:         y1a = array(y1)
  512:         # Default for masked array is not to copy; see gh-10318.
  513:         assert_(y1a._data.__array_interface__ ==
  514:                         y1._data.__array_interface__)
  515:         assert_(y1a._mask.__array_interface__ ==
  516:                         y1._mask.__array_interface__)
  517: 
  518:         y2 = array(x1, mask=m3)
  519:         assert_(y2._data.__array_interface__ == x1.__array_interface__)
  520:         assert_(y2._mask.__array_interface__ == m3.__array_interface__)
  521:         assert_(y2[2] is masked)
  522:         y2[2] = 9
  523:         assert_(y2[2] is not masked)
  524:         assert_(y2._mask.__array_interface__ == m3.__array_interface__)
  525:         assert_(allequal(y2.mask, 0))
  526: 
  527:         y2a = array(x1, mask=m, copy=1)
  528:         assert_(y2a._data.__array_interface__ != x1.__array_interface__)
  529:         #assert_( y2a._mask is not m)
  530:         assert_(y2a._mask.__array_interface__ != m.__array_interface__)
  531:         assert_(y2a[2] is masked)
  532:         y2a[2] = 9
  533:         assert_(y2a[2] is not masked)
  534:         #assert_( y2a._mask is not m)
  535:         assert_(y2a._mask.__array_interface__ != m.__array_interface__)
  536:         assert_(allequal(y2a.mask, 0))
  537: 
  538:         y3 = array(x1 * 1.0, mask=m)
  539:         assert_(filled(y3).dtype is (x1 * 1.0).dtype)
  540: 
  541:         x4 = arange(4)
  542:         x4[2] = masked
  543:         y4 = resize(x4, (8,))
  544:         assert_equal(concatenate([x4, x4]), y4)
  545:         assert_equal(getmask(y4), [0, 0, 1, 0, 0, 0, 1, 0])
  546:         y5 = repeat(x4, (2, 2, 2, 2), axis=0)
  547:         assert_equal(y5, [0, 0, 1, 1, 2, 2, 3, 3])
  548:         y6 = repeat(x4, 2, axis=0)
  549:         assert_equal(y5, y6)
  550:         y7 = x4.repeat((2, 2, 2, 2), axis=0)
  551:         assert_equal(y5, y7)
  552:         y8 = x4.repeat(2, 0)
  553:         assert_equal(y5, y8)
  554: 
  555:         y9 = x4.copy()
  556:         assert_equal(y9._data, x4._data)
  557:         assert_equal(y9._mask, x4._mask)
  558: 
  559:         x = masked_array([1, 2, 3], mask=[0, 1, 0])
  560:         # Copy is False by default
  561:         y = masked_array(x)
  562:         assert_equal(y._data.ctypes.data, x._data.ctypes.data)
  563:         assert_equal(y._mask.ctypes.data, x._mask.ctypes.data)
  564:         y = masked_array(x, copy=True)
  565:         assert_not_equal(y._data.ctypes.data, x._data.ctypes.data)
  566:         assert_not_equal(y._mask.ctypes.data, x._mask.ctypes.data)
  567: 
  568:     def test_copy_0d(self):
  569:         # gh-9430
  570:         x = np.ma.array(43, mask=True)
  571:         xc = x.copy()
  572:         assert_equal(xc.mask, True)
  573: 
  574:     def test_copy_on_python_builtins(self):
  575:         # Tests copy works on python builtins (issue#8019)
  576:         assert_(isMaskedArray(np.ma.copy([1, 2, 3])))
  577:         assert_(isMaskedArray(np.ma.copy((1, 2, 3))))
  578: 
  579:     def test_copy_immutable(self):
  580:         # Tests that the copy method is immutable, GitHub issue #5247
  581:         a = np.ma.array([1, 2, 3])
  582:         b = np.ma.array([4, 5, 6])
  583:         a_copy_method = a.copy
  584:         b.copy
  585:         assert_equal(a_copy_method(), [1, 2, 3])
  586: 
  587:     def test_deepcopy(self):
  588:         from copy import deepcopy
  589:         a = array([0, 1, 2], mask=[False, True, False])
  590:         copied = deepcopy(a)
  591:         assert_equal(copied.mask, a.mask)
  592:         assert_not_equal(id(a._mask), id(copied._mask))
  593: 
  594:         copied[1] = 1
  595:         assert_equal(copied.mask, [0, 0, 0])
  596:         assert_equal(a.mask, [0, 1, 0])
  597: 
  598:         copied = deepcopy(a)
  599:         assert_equal(copied.mask, a.mask)
  600:         copied.mask[1] = False
  601:         assert_equal(copied.mask, [0, 0, 0])
  602:         assert_equal(a.mask, [0, 1, 0])
  603: 
  604:     def test_format(self):
  605:         a = array([0, 1, 2], mask=[False, True, False])
  606:         assert_equal(format(a), "[0 -- 2]")
  607:         assert_equal(format(masked), "--")
  608:         assert_equal(format(masked, ""), "--")
  609: 
  610:         # Postponed from PR #15410, perhaps address in the future.
  611:         # assert_equal(format(masked, " >5"), "   --")
  612:         # assert_equal(format(masked, " <5"), "--   ")
  613: 
  614:         # Expect a FutureWarning for using format_spec with MaskedElement
  615:         with assert_warns(FutureWarning):
  616:             with_format_string = format(masked, " >5")
  617:         assert_equal(with_format_string, "--")
  618: 
  619:     def test_str_repr(self):
  620:         a = array([0, 1, 2], mask=[False, True, False])
  621:         assert_equal(str(a), '[0 -- 2]')
  622:         assert_equal(
  623:             repr(a),
  624:             textwrap.dedent('''\
  625:             masked_array(data=[0, --, 2],
  626:                          mask=[False,  True, False],
  627:                    fill_value=999999)''')
  628:         )
  629: 
  630:         # arrays with a continuation
  631:         a = np.ma.arange(2000)
  632:         a[1:50] = np.ma.masked
  633:         assert_equal(
  634:             repr(a),
  635:             textwrap.dedent('''\
  636:             masked_array(data=[0, --, --, ..., 1997, 1998, 1999],
  637:                          mask=[False,  True,  True, ..., False, False, False],
  638:                    fill_value=999999)''')
  639:         )
  640: 
  641:         # line-wrapped 1d arrays are correctly aligned
  642:         a = np.ma.arange(20)
  643:         assert_equal(
  644:             repr(a),
  645:             textwrap.dedent('''\
  646:             masked_array(data=[ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13,
  647:                                14, 15, 16, 17, 18, 19],
  648:                          mask=False,
  649:                    fill_value=999999)''')
  650:         )
  651: 
  652:         # 2d arrays cause wrapping
  653:         a = array([[1, 2, 3], [4, 5, 6]], dtype=np.int8)
  654:         a[1, 1] = np.ma.masked
  655:         assert_equal(
  656:             repr(a),
  657:             textwrap.dedent(f'''\
  658:             masked_array(
  659:               data=[[1, 2, 3],
  660:                     [4, --, 6]],
  661:               mask=[[False, False, False],
  662:                     [False,  True, False]],
  663:               fill_value={np.array(999999)[()]!r},
  664:               dtype=int8)''')
  665:         )
  666: 
  667:         # but not it they're a row vector
  668:         assert_equal(
  669:             repr(a[:1]),
  670:             textwrap.dedent(f'''\
  671:             masked_array(data=[[1, 2, 3]],
  672:                          mask=[[False, False, False]],
  673:                    fill_value={np.array(999999)[()]!r},
  674:                         dtype=int8)''')
  675:         )
  676: 
  677:         # dtype=int is implied, so not shown
  678:         assert_equal(
  679:             repr(a.astype(int)),
  680:             textwrap.dedent('''\
  681:             masked_array(
  682:               data=[[1, 2, 3],
  683:                     [4, --, 6]],
  684:               mask=[[False, False, False],
  685:                     [False,  True, False]],
  686:               fill_value=999999)''')
  687:         )
  688: 
  689:     def test_str_repr_legacy(self):
  690:         oldopts = np.get_printoptions()
  691:         np.set_printoptions(legacy='1.13')
  692:         try:
  693:             a = array([0, 1, 2], mask=[False, True, False])
  694:             assert_equal(str(a), '[0 -- 2]')
  695:             assert_equal(repr(a), 'masked_array(data = [0 -- 2],\n'
  696:                                   '             mask = [False  True False],\n'
  697:                                   '       fill_value = 999999)\n')
  698: 
  699:             a = np.ma.arange(2000)
  700:             a[1:50] = np.ma.masked
  701:             assert_equal(
  702:                 repr(a),
  703:                 'masked_array(data = [0 -- -- ..., 1997 1998 1999],\n'
  704:                 '             mask = [False  True  True ..., False False False],\n'
  705:                 '       fill_value = 999999)\n'
  706:             )
  707:         finally:
  708:             np.set_printoptions(**oldopts)
  709: 
  710:     def test_0d_unicode(self):
  711:         u = 'caf\xe9'
  712:         utype = type(u)
  713: 
  714:         arr_nomask = np.ma.array(u)
  715:         arr_masked = np.ma.array(u, mask=True)
  716: 
  717:         assert_equal(utype(arr_nomask), u)
  718:         assert_equal(utype(arr_masked), '--')
  719: 
  720:     def test_pickling(self):
  721:         # Tests pickling
  722:         for dtype in (int, float, str, object):
  723:             a = arange(10).astype(dtype)
  724:             a.fill_value = 999
  725: 
  726:             masks = ([0, 0, 0, 1, 0, 1, 0, 1, 0, 1],  # partially masked
  727:                      True,                            # Fully masked
  728:                      False)                           # Fully unmasked
  729: 
  730:             for proto in range(2, pickle.HIGHEST_PROTOCOL + 1):
  731:                 for mask in masks:
  732:                     a.mask = mask
  733:                     a_pickled = pickle.loads(pickle.dumps(a, protocol=proto))
  734:                     assert_equal(a_pickled._mask, a._mask)
  735:                     assert_equal(a_pickled._data, a._data)
  736:                     if dtype in (object, int):
  737:                         assert_equal(a_pickled.fill_value, 999)
  738:                     else:
  739:                         assert_equal(a_pickled.fill_value, dtype(999))
  740:                     assert_array_equal(a_pickled.mask, mask)
  741: 
  742:     def test_pickling_subbaseclass(self):
  743:         # Test pickling w/ a subclass of ndarray
  744:         x = np.array([(1.0, 2), (3.0, 4)],
  745:                      dtype=[('x', float), ('y', int)]).view(np.recarray)
  746:         a = masked_array(x, mask=[(True, False), (False, True)])
  747:         for proto in range(2, pickle.HIGHEST_PROTOCOL + 1):
  748:             a_pickled = pickle.loads(pickle.dumps(a, protocol=proto))
  749:             assert_equal(a_pickled._mask, a._mask)
  750:             assert_equal(a_pickled, a)
  751:             assert_(isinstance(a_pickled._data, np.recarray))
  752: 
  753:     def test_pickling_maskedconstant(self):
  754:         # Test pickling MaskedConstant
  755:         mc = np.ma.masked
  756:         for proto in range(2, pickle.HIGHEST_PROTOCOL + 1):
  757:             mc_pickled = pickle.loads(pickle.dumps(mc, protocol=proto))
  758:             assert_equal(mc_pickled._baseclass, mc._baseclass)
  759:             assert_equal(mc_pickled._mask, mc._mask)
  760:             assert_equal(mc_pickled._data, mc._data)
  761: 
  762:     def test_pickling_wstructured(self):
  763:         # Tests pickling w/ structured array
  764:         a = array([(1, 1.), (2, 2.)], mask=[(0, 0), (0, 1)],
  765:                   dtype=[('a', int), ('b', float)])
  766:         for proto in range(2, pickle.HIGHEST_PROTOCOL + 1):
  767:             a_pickled = pickle.loads(pickle.dumps(a, protocol=proto))
  768:             assert_equal(a_pickled._mask, a._mask)
  769:             assert_equal(a_pickled, a)
  770: 
  771:     def test_pickling_keepalignment(self):
  772:         # Tests pickling w/ F_CONTIGUOUS arrays
  773:         a = arange(10)
  774:         a.shape = (-1, 2)
  775:         b = a.T
  776:         for proto in range(2, pickle.HIGHEST_PROTOCOL + 1):
  777:             test = pickle.loads(pickle.dumps(b, protocol=proto))
  778:             assert_equal(test, b)
  779: 
  780:     def test_single_element_subscript(self):
  781:         # Tests single element subscripts of Maskedarrays.
  782:         a = array([1, 3, 2])
  783:         b = array([1, 3, 2], mask=[1, 0, 1])
  784:         assert_equal(a[0].shape, ())
  785:         assert_equal(b[0].shape, ())
  786:         assert_equal(b[1].shape, ())
  787: 
  788:     def test_topython(self):
  789:         # Tests some communication issues with Python.
  790:         assert_equal(1, int(array(1)))
  791:         assert_equal(1.0, float(array(1)))
  792:         assert_equal(1, int(array([[[1]]])))
  793:         assert_equal(1.0, float(array([[1]])))
  794:         assert_raises(TypeError, float, array([1, 1]))
  795: 
  796:         with suppress_warnings() as sup:
  797:             sup.filter(UserWarning, 'Warning: converting a masked element')
  798:             assert_(np.isnan(float(array([1], mask=[1]))))
  799: 
  800:             a = array([1, 2, 3], mask=[1, 0, 0])
  801:             assert_raises(TypeError, lambda: float(a))
  802:             assert_equal(float(a[-1]), 3.)
  803:             assert_(np.isnan(float(a[0])))
  804:         assert_raises(TypeError, int, a)
  805:         assert_equal(int(a[-1]), 3)
  806:         assert_raises(MAError, lambda: int(a[0]))
  807: 
  808:     def test_oddfeatures_1(self):
  809:         # Test of other odd features
  810:         x = arange(20)
  811:         x = x.reshape(4, 5)
  812:         x.flat[5] = 12
  813:         assert_(x[1, 0] == 12)
  814:         z = x + 10j * x
  815:         assert_equal(z.real, x)
  816:         assert_equal(z.imag, 10 * x)
  817:         assert_equal((z * conjugate(z)).real, 101 * x * x)
  818:         z.imag[...] = 0.0
  819: 
  820:         x = arange(10)
  821:         x[3] = masked
  822:         assert_(str(x[3]) == str(masked))
  823:         c = x >= 8
  824:         assert_(count(where(c, masked, masked)) == 0)
  825:         assert_(shape(where(c, masked, masked)) == c.shape)
  826: 
  827:         z = masked_where(c, x)
  828:         assert_(z.dtype is x.dtype)
  829:         assert_(z[3] is masked)
  830:         assert_(z[4] is not masked)
  831:         assert_(z[7] is not masked)
  832:         assert_(z[8] is masked)
  833:         assert_(z[9] is masked)
  834:         assert_equal(x, z)
  835: 
  836:     def test_oddfeatures_2(self):
  837:         # Tests some more features.
  838:         x = array([1., 2., 3., 4., 5.])
  839:         c = array([1, 1, 1, 0, 0])
  840:         x[2] = masked
  841:         z = where(c, x, -x)
  842:         assert_equal(z, [1., 2., 0., -4., -5])
  843:         c[0] = masked
  844:         z = where(c, x, -x)
  845:         assert_equal(z, [1., 2., 0., -4., -5])
  846:         assert_(z[0] is masked)
  847:         assert_(z[1] is not masked)
  848:         assert_(z[2] is masked)
  849: 
  850:     @suppress_copy_mask_on_assignment
  851:     def test_oddfeatures_3(self):
  852:         # Tests some generic features
  853:         atest = array([10], mask=True)
  854:         btest = array([20])
  855:         idx = atest.mask
  856:         atest[idx] = btest[idx]
  857:         assert_equal(atest, [20])
  858: 
  859:     def test_filled_with_object_dtype(self):
  860:         a = np.ma.masked_all(1, dtype='O')
  861:         assert_equal(a.filled('x')[0], 'x')
  862: 
  863:     def test_filled_with_flexible_dtype(self):
  864:         # Test filled w/ flexible dtype
  865:         flexi = array([(1, 1, 1)],
  866:                       dtype=[('i', int), ('s', '|S8'), ('f', float)])
  867:         flexi[0] = masked
  868:         assert_equal(flexi.filled(),
  869:                      np.array([(default_fill_value(0),
  870:                                 default_fill_value('0'),
  871:                                 default_fill_value(0.),)], dtype=flexi.dtype))
  872:         flexi[0] = masked
  873:         assert_equal(flexi.filled(1),
  874:                      np.array([(1, '1', 1.)], dtype=flexi.dtype))
  875: 
  876:     def test_filled_with_mvoid(self):
  877:         # Test filled w/ mvoid
  878:         ndtype = [('a', int), ('b', float)]
  879:         a = mvoid((1, 2.), mask=[(0, 1)], dtype=ndtype)
  880:         # Filled using default
  881:         test = a.filled()
  882:         assert_equal(tuple(test), (1, default_fill_value(1.)))
  883:         # Explicit fill_value
  884:         test = a.filled((-1, -1))
  885:         assert_equal(tuple(test), (1, -1))
  886:         # Using predefined filling values
  887:         a.fill_value = (-999, -999)
  888:         assert_equal(tuple(a.filled()), (1, -999))
  889: 
  890:     def test_filled_with_nested_dtype(self):
  891:         # Test filled w/ nested dtype
  892:         ndtype = [('A', int), ('B', [('BA', int), ('BB', int)])]
  893:         a = array([(1, (1, 1)), (2, (2, 2))],
  894:                   mask=[(0, (1, 0)), (0, (0, 1))], dtype=ndtype)
  895:         test = a.filled(0)
  896:         control = np.array([(1, (0, 1)), (2, (2, 0))], dtype=ndtype)
  897:         assert_equal(test, control)
  898: 
  899:         test = a['B'].filled(0)
  900:         control = np.array([(0, 1), (2, 0)], dtype=a['B'].dtype)
  901:         assert_equal(test, control)
  902: 
  903:         # test if mask gets set correctly (see #6760)
  904:         Z = numpy.ma.zeros(2, numpy.dtype([("A", "(2,2)i1,(2,2)i1", (2, 2))]))
  905:         assert_equal(Z.data.dtype, numpy.dtype([('A', [('f0', 'i1', (2, 2)),
  906:                                           ('f1', 'i1', (2, 2))], (2, 2))]))
  907:         assert_equal(Z.mask.dtype, numpy.dtype([('A', [('f0', '?', (2, 2)),
  908:                                           ('f1', '?', (2, 2))], (2, 2))]))
  909: 
  910:     def test_filled_with_f_order(self):
  911:         # Test filled w/ F-contiguous array
  912:         a = array(np.array([(0, 1, 2), (4, 5, 6)], order='F'),
  913:                   mask=np.array([(0, 0, 1), (1, 0, 0)], order='F'),
  914:                   order='F')  # this is currently ignored
  915:         assert_(a.flags['F_CONTIGUOUS'])
  916:         assert_(a.filled(0).flags['F_CONTIGUOUS'])
  917: 
  918:     def test_optinfo_propagation(self):
  919:         # Checks that _optinfo dictionary isn't back-propagated
  920:         x = array([1, 2, 3, ], dtype=float)
  921:         x._optinfo['info'] = '???'
  922:         y = x.copy()
  923:         assert_equal(y._optinfo['info'], '???')
  924:         y._optinfo['info'] = '!!!'
  925:         assert_equal(x._optinfo['info'], '???')
  926: 
  927:     def test_optinfo_forward_propagation(self):
  928:         a = array([1, 2, 2, 4])
  929:         a._optinfo["key"] = "value"
  930:         assert_equal(a._optinfo["key"], (a == 2)._optinfo["key"])
  931:         assert_equal(a._optinfo["key"], (a != 2)._optinfo["key"])
  932:         assert_equal(a._optinfo["key"], (a > 2)._optinfo["key"])
  933:         assert_equal(a._optinfo["key"], (a >= 2)._optinfo["key"])
  934:         assert_equal(a._optinfo["key"], (a <= 2)._optinfo["key"])
  935:         assert_equal(a._optinfo["key"], (a + 2)._optinfo["key"])
  936:         assert_equal(a._optinfo["key"], (a - 2)._optinfo["key"])
  937:         assert_equal(a._optinfo["key"], (a * 2)._optinfo["key"])
  938:         assert_equal(a._optinfo["key"], (a / 2)._optinfo["key"])
  939:         assert_equal(a._optinfo["key"], a[:2]._optinfo["key"])
  940:         assert_equal(a._optinfo["key"], a[[0, 0, 2]]._optinfo["key"])
  941:         assert_equal(a._optinfo["key"], np.exp(a)._optinfo["key"])
  942:         assert_equal(a._optinfo["key"], np.abs(a)._optinfo["key"])
  943:         assert_equal(a._optinfo["key"], array(a, copy=True)._optinfo["key"])
  944:         assert_equal(a._optinfo["key"], np.zeros_like(a)._optinfo["key"])
  945: 
  946:     def test_fancy_printoptions(self):
  947:         # Test printing a masked array w/ fancy dtype.
  948:         fancydtype = np.dtype([('x', int), ('y', [('t', int), ('s', float)])])
  949:         test = array([(1, (2, 3.0)), (4, (5, 6.0))],
  950:                      mask=[(1, (0, 1)), (0, (1, 0))],
  951:                      dtype=fancydtype)
  952:         control = "[(--, (2, --)) (4, (--, 6.0))]"
  953:         assert_equal(str(test), control)
  954: 
  955:         # Test 0-d array with multi-dimensional dtype
  956:         t_2d0 = masked_array(data=(0, [[0.0, 0.0, 0.0],
  957:                                        [0.0, 0.0, 0.0]],
  958:                                    0.0),
  959:                              mask=(False, [[True, False, True],
  960:                                            [False, False, True]],
  961:                                    False),
  962:                              dtype="int, (2,3)float, float")
  963:         control = "(0, [[--, 0.0, --], [0.0, 0.0, --]], 0.0)"
  964:         assert_equal(str(t_2d0), control)
  965: 
  966:     def test_flatten_structured_array(self):
  967:         # Test flatten_structured_array on arrays
  968:         # On ndarray
  969:         ndtype = [('a', int), ('b', float)]
  970:         a = np.array([(1, 1), (2, 2)], dtype=ndtype)
  971:         test = flatten_structured_array(a)
  972:         control = np.array([[1., 1.], [2., 2.]], dtype=float)
  973:         assert_equal(test, control)
  974:         assert_equal(test.dtype, control.dtype)
  975:         # On masked_array
  976:         a = array([(1, 1), (2, 2)], mask=[(0, 1), (1, 0)], dtype=ndtype)
  977:         test = flatten_structured_array(a)
  978:         control = array([[1., 1.], [2., 2.]],
  979:                         mask=[[0, 1], [1, 0]], dtype=float)
  980:         assert_equal(test, control)
  981:         assert_equal(test.dtype, control.dtype)
  982:         assert_equal(test.mask, control.mask)
  983:         # On masked array with nested structure
  984:         ndtype = [('a', int), ('b', [('ba', int), ('bb', float)])]
  985:         a = array([(1, (1, 1.1)), (2, (2, 2.2))],
  986:                   mask=[(0, (1, 0)), (1, (0, 1))], dtype=ndtype)
  987:         test = flatten_structured_array(a)
  988:         control = array([[1., 1., 1.1], [2., 2., 2.2]],
  989:                         mask=[[0, 1, 0], [1, 0, 1]], dtype=float)
  990:         assert_equal(test, control)
  991:         assert_equal(test.dtype, control.dtype)
  992:         assert_equal(test.mask, control.mask)
  993:         # Keeping the initial shape
  994:         ndtype = [('a', int), ('b', float)]
  995:         a = np.array([[(1, 1), ], [(2, 2), ]], dtype=ndtype)
  996:         test = flatten_structured_array(a)
  997:         control = np.array([[[1., 1.], ], [[2., 2.], ]], dtype=float)
  998:         assert_equal(test, control)
  999:         assert_equal(test.dtype, control.dtype)
 1000: 
 1001:     def test_void0d(self):
 1002:         # Test creating a mvoid object
 1003:         ndtype = [('a', int), ('b', int)]
 1004:         a = np.array([(1, 2,)], dtype=ndtype)[0]
 1005:         f = mvoid(a)
 1006:         assert_(isinstance(f, mvoid))
 1007: 
 1008:         a = masked_array([(1, 2)], mask=[(1, 0)], dtype=ndtype)[0]
 1009:         assert_(isinstance(a, mvoid))
 1010: 
 1011:         a = masked_array([(1, 2), (1, 2)], mask=[(1, 0), (0, 0)], dtype=ndtype)
 1012:         f = mvoid(a._data[0], a._mask[0])
 1013:         assert_(isinstance(f, mvoid))
 1014: 
 1015:     def test_mvoid_getitem(self):
 1016:         # Test mvoid.__getitem__
 1017:         ndtype = [('a', int), ('b', int)]
 1018:         a = masked_array([(1, 2,), (3, 4)], mask=[(0, 0), (1, 0)],
 1019:                          dtype=ndtype)
 1020:         # w/o mask
 1021:         f = a[0]
 1022:         assert_(isinstance(f, mvoid))
 1023:         assert_equal((f[0], f['a']), (1, 1))
 1024:         assert_equal(f['b'], 2)
 1025:         # w/ mask
 1026:         f = a[1]
 1027:         assert_(isinstance(f, mvoid))
 1028:         assert_(f[0] is masked)
 1029:         assert_(f['a'] is masked)
 1030:         assert_equal(f[1], 4)
 1031: 
 1032:         # exotic dtype
 1033:         A = masked_array(data=[([0, 1],)],
 1034:                          mask=[([True, False],)],
 1035:                          dtype=[("A", ">i2", (2,))])
 1036:         assert_equal(A[0]["A"], A["A"][0])
 1037:         assert_equal(A[0]["A"], masked_array(data=[0, 1],
 1038:                          mask=[True, False], dtype=">i2"))
 1039: 
 1040:     def test_mvoid_iter(self):
 1041:         # Test iteration on __getitem__
 1042:         ndtype = [('a', int), ('b', int)]
 1043:         a = masked_array([(1, 2,), (3, 4)], mask=[(0, 0), (1, 0)],
 1044:                          dtype=ndtype)
 1045:         # w/o mask
 1046:         assert_equal(list(a[0]), [1, 2])
 1047:         # w/ mask
 1048:         assert_equal(list(a[1]), [masked, 4])
 1049: 
 1050:     def test_mvoid_print(self):
 1051:         # Test printing a mvoid
 1052:         mx = array([(1, 1), (2, 2)], dtype=[('a', int), ('b', int)])
 1053:         assert_equal(str(mx[0]), "(1, 1)")
 1054:         mx['b'][0] = masked
 1055:         ini_display = masked_print_option._display
 1056:         masked_print_option.set_display("-X-")
 1057:         try:
 1058:             assert_equal(str(mx[0]), "(1, -X-)")
 1059:             assert_equal(repr(mx[0]), "(1, -X-)")
 1060:         finally:
 1061:             masked_print_option.set_display(ini_display)
 1062: 
 1063:         # also check if there are object datatypes (see gh-7493)
 1064:         mx = array([(1,), (2,)], dtype=[('a', 'O')])
 1065:         assert_equal(str(mx[0]), "(1,)")
 1066: 
 1067:     def test_mvoid_multidim_print(self):
 1068: 
 1069:         # regression test for gh-6019
 1070:         t_ma = masked_array(data=[([1, 2, 3],)],
 1071:                             mask=[([False, True, False],)],
 1072:                             fill_value=([999999, 999999, 999999],),
 1073:                             dtype=[('a', '<i4', (3,))])
 1074:         assert_(str(t_ma[0]) == "([1, --, 3],)")
 1075:         assert_(repr(t_ma[0]) == "([1, --, 3],)")
 1076: 
 1077:         # additional tests with structured arrays
 1078: 
 1079:         t_2d = masked_array(data=[([[1, 2], [3, 4]],)],
 1080:                             mask=[([[False, True], [True, False]],)],
 1081:                             dtype=[('a', '<i4', (2, 2))])
 1082:         assert_(str(t_2d[0]) == "([[1, --], [--, 4]],)")
 1083:         assert_(repr(t_2d[0]) == "([[1, --], [--, 4]],)")
 1084: 
 1085:         t_0d = masked_array(data=[(1, 2)],
 1086:                             mask=[(True, False)],
 1087:                             dtype=[('a', '<i4'), ('b', '<i4')])
 1088:         assert_(str(t_0d[0]) == "(--, 2)")
 1089:         assert_(repr(t_0d[0]) == "(--, 2)")
 1090: 
 1091:         t_2d = masked_array(data=[([[1, 2], [3, 4]], 1)],
 1092:                             mask=[([[False, True], [True, False]], False)],
 1093:                             dtype=[('a', '<i4', (2, 2)), ('b', float)])
 1094:         assert_(str(t_2d[0]) == "([[1, --], [--, 4]], 1.0)")
 1095:         assert_(repr(t_2d[0]) == "([[1, --], [--, 4]], 1.0)")
 1096: 
 1097:         t_ne = masked_array(data=[(1, (1, 1))],
 1098:                             mask=[(True, (True, False))],
 1099:                             dtype=[('a', '<i4'), ('b', 'i4,i4')])
 1100:         assert_(str(t_ne[0]) == "(--, (--, 1))")
 1101:         assert_(repr(t_ne[0]) == "(--, (--, 1))")
 1102: 
 1103:     def test_object_with_array(self):
 1104:         mx1 = masked_array([1.], mask=[True])
 1105:         mx2 = masked_array([1., 2.])
 1106:         mx = masked_array([mx1, mx2], mask=[False, True], dtype=object)
 1107:         assert_(mx[0] is mx1)
 1108:         assert_(mx[1] is not mx2)
 1109:         assert_(np.all(mx[1].data == mx2.data))
 1110:         assert_(np.all(mx[1].mask))
 1111:         # check that we return a view.
 1112:         mx[1].data[0] = 0.
 1113:         assert_(mx2[0] == 0.)
 1114: 
 1115:     def test_maskedarray_tofile_raises_notimplementederror(self):
 1116:         xm = masked_array([1, 2, 3], mask=[False, True, False])
 1117:         # Test case to check the NotImplementedError.
 1118:         # It is not implemented at this point of time. We can change this in future
 1119:         with temppath(suffix='.npy') as path:
 1120:             with pytest.raises(NotImplementedError):
 1121:                 np.save(path, xm)
 1122: 
 1123: 
 1124: class TestMaskedArrayArithmetic:
 1125:     # Base test class for MaskedArrays.
 1126: 
 1127:     def setup_method(self):
 1128:         # Base data definition.
 1129:         x = np.array([1., 1., 1., -2., pi / 2.0, 4., 5., -10., 10., 1., 2., 3.])
 1130:         y = np.array([5., 0., 3., 2., -1., -4., 0., -10., 10., 1., 0., 3.])
 1131:         a10 = 10.
 1132:         m1 = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]
 1133:         m2 = [0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1]
 1134:         xm = masked_array(x, mask=m1)
 1135:         ym = masked_array(y, mask=m2)
 1136:         z = np.array([-.5, 0., .5, .8])
 1137:         zm = masked_array(z, mask=[0, 1, 0, 0])
 1138:         xf = np.where(m1, 1e+20, x)
 1139:         xm.set_fill_value(1e+20)
 1140:         self.d = (x, y, a10, m1, m2, xm, ym, z, zm, xf)
 1141:         self.err_status = np.geterr()
 1142:         np.seterr(divide='ignore', invalid='ignore')
 1143: 
 1144:     def teardown_method(self):
 1145:         np.seterr(**self.err_status)
 1146: 
 1147:     def test_basic_arithmetic(self):
 1148:         # Test of basic arithmetic.
 1149:         (x, y, a10, m1, m2, xm, ym, z, zm, xf) = self.d
 1150:         a2d = array([[1, 2], [0, 4]])
 1151:         a2dm = masked_array(a2d, [[0, 0], [1, 0]])
 1152:         assert_equal(a2d * a2d, a2d * a2dm)
 1153:         assert_equal(a2d + a2d, a2d + a2dm)
 1154:         assert_equal(a2d - a2d, a2d - a2dm)
 1155:         for s in [(12,), (4, 3), (2, 6)]:
 1156:             x = x.reshape(s)
 1157:             y = y.reshape(s)
 1158:             xm = xm.reshape(s)
 1159:             ym = ym.reshape(s)
 1160:             xf = xf.reshape(s)
 1161:             assert_equal(-x, -xm)
 1162:             assert_equal(x + y, xm + ym)
 1163:             assert_equal(x - y, xm - ym)
 1164:             assert_equal(x * y, xm * ym)
 1165:             assert_equal(x / y, xm / ym)
 1166:             assert_equal(a10 + y, a10 + ym)
 1167:             assert_equal(a10 - y, a10 - ym)
 1168:             assert_equal(a10 * y, a10 * ym)
 1169:             assert_equal(a10 / y, a10 / ym)
 1170:             assert_equal(x + a10, xm + a10)
 1171:             assert_equal(x - a10, xm - a10)
 1172:             assert_equal(x * a10, xm * a10)
 1173:             assert_equal(x / a10, xm / a10)
 1174:             assert_equal(x ** 2, xm ** 2)
 1175:             assert_equal(abs(x) ** 2.5, abs(xm) ** 2.5)
 1176:             assert_equal(x ** y, xm ** ym)
 1177:             assert_equal(np.add(x, y), add(xm, ym))
 1178:             assert_equal(np.subtract(x, y), subtract(xm, ym))
 1179:             assert_equal(np.multiply(x, y), multiply(xm, ym))
 1180:             assert_equal(np.divide(x, y), divide(xm, ym))
 1181: 
 1182:     def test_divide_on_different_shapes(self):
 1183:         x = arange(6, dtype=float)
 1184:         x.shape = (2, 3)
 1185:         y = arange(3, dtype=float)
 1186: 
 1187:         z = x / y
 1188:         assert_equal(z, [[-1., 1., 1.], [-1., 4., 2.5]])
 1189:         assert_equal(z.mask, [[1, 0, 0], [1, 0, 0]])
 1190: 
 1191:         z = x / y[None, :]
 1192:         assert_equal(z, [[-1., 1., 1.], [-1., 4., 2.5]])
 1193:         assert_equal(z.mask, [[1, 0, 0], [1, 0, 0]])
 1194: 
 1195:         y = arange(2, dtype=float)
 1196:         z = x / y[:, None]
 1197:         assert_equal(z, [[-1., -1., -1.], [3., 4., 5.]])
 1198:         assert_equal(z.mask, [[1, 1, 1], [0, 0, 0]])
 1199: 
 1200:     def test_mixed_arithmetic(self):
 1201:         # Tests mixed arithmetic.
 1202:         na = np.array([1])
 1203:         ma = array([1])
 1204:         assert_(isinstance(na + ma, MaskedArray))
 1205:         assert_(isinstance(ma + na, MaskedArray))
 1206: 
 1207:     def test_limits_arithmetic(self):
 1208:         tiny = np.finfo(float).tiny
 1209:         a = array([tiny, 1. / tiny, 0.])
 1210:         assert_equal(getmaskarray(a / 2), [0, 0, 0])
 1211:         assert_equal(getmaskarray(2 / a), [1, 0, 1])
 1212: 
 1213:     def test_masked_singleton_arithmetic(self):
 1214:         # Tests some scalar arithmetic on MaskedArrays.
 1215:         # Masked singleton should remain masked no matter what
 1216:         xm = array(0, mask=1)
 1217:         assert_((1 / array(0)).mask)
 1218:         assert_((1 + xm).mask)
 1219:         assert_((-xm).mask)
 1220:         assert_(maximum(xm, xm).mask)
 1221:         assert_(minimum(xm, xm).mask)
 1222: 
 1223:     def test_masked_singleton_equality(self):
 1224:         # Tests (in)equality on masked singleton
 1225:         a = array([1, 2, 3], mask=[1, 1, 0])
 1226:         assert_((a[0] == 0) is masked)
 1227:         assert_((a[0] != 0) is masked)
 1228:         assert_equal((a[-1] == 0), False)
 1229:         assert_equal((a[-1] != 0), True)
 1230: 
 1231:     def test_arithmetic_with_masked_singleton(self):
 1232:         # Checks that there's no collapsing to masked
 1233:         x = masked_array([1, 2])
 1234:         y = x * masked
 1235:         assert_equal(y.shape, x.shape)
 1236:         assert_equal(y._mask, [True, True])
 1237:         y = x[0] * masked
 1238:         assert_(y is masked)
 1239:         y = x + masked
 1240:         assert_equal(y.shape, x.shape)
 1241:         assert_equal(y._mask, [True, True])
 1242: 
 1243:     def test_arithmetic_with_masked_singleton_on_1d_singleton(self):
 1244:         # Check that we're not losing the shape of a singleton
 1245:         x = masked_array([1, ])
 1246:         y = x + masked
 1247:         assert_equal(y.shape, x.shape)
 1248:         assert_equal(y.mask, [True, ])
 1249: 
 1250:     def test_scalar_arithmetic(self):
 1251:         x = array(0, mask=0)
 1252:         assert_equal(x.filled().ctypes.data, x.ctypes.data)
 1253:         # Make sure we don't lose the shape in some circumstances
 1254:         xm = array((0, 0)) / 0.
 1255:         assert_equal(xm.shape, (2,))
 1256:         assert_equal(xm.mask, [1, 1])
 1257: 
 1258:     def test_basic_ufuncs(self):
 1259:         # Test various functions such as sin, cos.
 1260:         (x, y, a10, m1, m2, xm, ym, z, zm, xf) = self.d
 1261:         assert_equal(np.cos(x), cos(xm))
 1262:         assert_equal(np.cosh(x), cosh(xm))
 1263:         assert_equal(np.sin(x), sin(xm))
 1264:         assert_equal(np.sinh(x), sinh(xm))
 1265:         assert_equal(np.tan(x), tan(xm))
 1266:         assert_equal(np.tanh(x), tanh(xm))
 1267:         assert_equal(np.sqrt(abs(x)), sqrt(xm))
 1268:         assert_equal(np.log(abs(x)), log(xm))
 1269:         assert_equal(np.log10(abs(x)), log10(xm))
 1270:         assert_equal(np.exp(x), exp(xm))
 1271:         assert_equal(np.arcsin(z), arcsin(zm))
 1272:         assert_equal(np.arccos(z), arccos(zm))
 1273:         assert_equal(np.arctan(z), arctan(zm))
 1274:         assert_equal(np.arctan2(x, y), arctan2(xm, ym))
 1275:         assert_equal(np.absolute(x), absolute(xm))
 1276:         assert_equal(np.angle(x + 1j * y), angle(xm + 1j * ym))
 1277:         assert_equal(np.angle(x + 1j * y, deg=True), angle(xm + 1j * ym, deg=True))
 1278:         assert_equal(np.equal(x, y), equal(xm, ym))
 1279:         assert_equal(np.not_equal(x, y), not_equal(xm, ym))
 1280:         assert_equal(np.less(x, y), less(xm, ym))
 1281:         assert_equal(np.greater(x, y), greater(xm, ym))
 1282:         assert_equal(np.less_equal(x, y), less_equal(xm, ym))
 1283:         assert_equal(np.greater_equal(x, y), greater_equal(xm, ym))
 1284:         assert_equal(np.conjugate(x), conjugate(xm))
 1285: 
 1286:     def test_basic_ufuncs_masked(self):
 1287:         # Mostly regression test for gh-25635
 1288:         assert np.sqrt(np.ma.masked) is np.ma.masked
 1289: 
 1290:     def test_count_func(self):
 1291:         # Tests count
 1292:         assert_equal(1, count(1))
 1293:         assert_equal(0, array(1, mask=[1]))
 1294: 
 1295:         ott = array([0., 1., 2., 3.], mask=[1, 0, 0, 0])
 1296:         res = count(ott)
 1297:         assert_(res.dtype.type is np.intp)
 1298:         assert_equal(3, res)
 1299: 
 1300:         ott = ott.reshape((2, 2))
 1301:         res = count(ott)
 1302:         assert_(res.dtype.type is np.intp)
 1303:         assert_equal(3, res)
 1304:         res = count(ott, 0)
 1305:         assert_(isinstance(res, ndarray))
 1306:         assert_equal([1, 2], res)
 1307:         assert_(getmask(res) is nomask)
 1308: 
 1309:         ott = array([0., 1., 2., 3.])
 1310:         res = count(ott, 0)
 1311:         assert_(isinstance(res, ndarray))
 1312:         assert_(res.dtype.type is np.intp)
 1313:         assert_raises(AxisError, ott.count, axis=1)
 1314: 
 1315:     def test_count_on_python_builtins(self):
 1316:         # Tests count works on python builtins (issue#8019)
 1317:         assert_equal(3, count([1, 2, 3]))
 1318:         assert_equal(2, count((1, 2)))
 1319: 
 1320:     def test_minmax_func(self):
 1321:         # Tests minimum and maximum.
 1322:         (x, y, a10, m1, m2, xm, ym, z, zm, xf) = self.d
 1323:         # max doesn't work if shaped
 1324:         xr = np.ravel(x)
 1325:         xmr = ravel(xm)
 1326:         # following are true because of careful selection of data
 1327:         assert_equal(max(xr), maximum.reduce(xmr))
 1328:         assert_equal(min(xr), minimum.reduce(xmr))
 1329: 
 1330:         assert_equal(minimum([1, 2, 3], [4, 0, 9]), [1, 0, 3])
 1331:         assert_equal(maximum([1, 2, 3], [4, 0, 9]), [4, 2, 9])
 1332:         x = arange(5)
 1333:         y = arange(5) - 2
 1334:         x[3] = masked
 1335:         y[0] = masked
 1336:         assert_equal(minimum(x, y), where(less(x, y), x, y))
 1337:         assert_equal(maximum(x, y), where(greater(x, y), x, y))
 1338:         assert_(minimum.reduce(x) == 0)
 1339:         assert_(maximum.reduce(x) == 4)
 1340: 
 1341:         x = arange(4).reshape(2, 2)
 1342:         x[-1, -1] = masked
 1343:         assert_equal(maximum.reduce(x, axis=None), 2)
 1344: 
 1345:     def test_minimummaximum_func(self):
 1346:         a = np.ones((2, 2))
 1347:         aminimum = minimum(a, a)
 1348:         assert_(isinstance(aminimum, MaskedArray))
 1349:         assert_equal(aminimum, np.minimum(a, a))
 1350: 
 1351:         aminimum = minimum.outer(a, a)
 1352:         assert_(isinstance(aminimum, MaskedArray))
 1353:         assert_equal(aminimum, np.minimum.outer(a, a))
 1354: 
 1355:         amaximum = maximum(a, a)
 1356:         assert_(isinstance(amaximum, MaskedArray))
 1357:         assert_equal(amaximum, np.maximum(a, a))
 1358: 
 1359:         amaximum = maximum.outer(a, a)
 1360:         assert_(isinstance(amaximum, MaskedArray))
 1361:         assert_equal(amaximum, np.maximum.outer(a, a))
 1362: 
 1363:     def test_minmax_reduce(self):
 1364:         # Test np.min/maximum.reduce on array w/ full False mask
 1365:         a = array([1, 2, 3], mask=[False, False, False])
 1366:         b = np.maximum.reduce(a)
 1367:         assert_equal(b, 3)
 1368: 
 1369:     def test_minmax_funcs_with_output(self):
 1370:         # Tests the min/max functions with explicit outputs
 1371:         mask = np.random.rand(12).round()
 1372:         xm = array(np.random.uniform(0, 10, 12), mask=mask)
 1373:         xm.shape = (3, 4)
 1374:         for funcname in ('min', 'max'):
 1375:             # Initialize
 1376:             npfunc = getattr(np, funcname)
 1377:             mafunc = getattr(numpy.ma.core, funcname)
 1378:             # Use the np version
 1379:             nout = np.empty((4,), dtype=int)
 1380:             try:
 1381:                 result = npfunc(xm, axis=0, out=nout)
 1382:             except MaskError:
 1383:                 pass
 1384:             nout = np.empty((4,), dtype=float)
 1385:             result = npfunc(xm, axis=0, out=nout)
 1386:             assert_(result is nout)
 1387:             # Use the ma version
 1388:             nout.fill(-999)
 1389:             result = mafunc(xm, axis=0, out=nout)
 1390:             assert_(result is nout)
 1391: 
 1392:     def test_minmax_methods(self):
 1393:         # Additional tests on max/min
 1394:         (_, _, _, _, _, xm, _, _, _, _) = self.d
 1395:         xm.shape = (xm.size,)
 1396:         assert_equal(xm.max(), 10)
 1397:         assert_(xm[0].max() is masked)
 1398:         assert_(xm[0].max(0) is masked)
 1399:         assert_(xm[0].max(-1) is masked)
 1400:         assert_equal(xm.min(), -10.)
 1401:         assert_(xm[0].min() is masked)
 1402:         assert_(xm[0].min(0) is masked)
 1403:         assert_(xm[0].min(-1) is masked)
 1404:         assert_equal(xm.ptp(), 20.)
 1405:         assert_(xm[0].ptp() is masked)
 1406:         assert_(xm[0].ptp(0) is masked)
 1407:         assert_(xm[0].ptp(-1) is masked)
 1408: 
 1409:         x = array([1, 2, 3], mask=True)
 1410:         assert_(x.min() is masked)
 1411:         assert_(x.max() is masked)
 1412:         assert_(x.ptp() is masked)
 1413: 
 1414:     def test_minmax_dtypes(self):
 1415:         # Additional tests on max/min for non-standard float and complex dtypes
 1416:         x = np.array([1., 1., 1., -2., pi / 2.0, 4., 5., -10., 10., 1., 2., 3.])
 1417:         a10 = 10.
 1418:         an10 = -10.0
 1419:         m1 = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]
 1420:         xm = masked_array(x, mask=m1)
 1421:         xm.set_fill_value(1e+20)
 1422:         float_dtypes = [np.float16, np.float32, np.float64, np.longdouble,
 1423:                         np.complex64, np.complex128, np.clongdouble]
 1424:         for float_dtype in float_dtypes:
 1425:             assert_equal(masked_array(x, mask=m1, dtype=float_dtype).max(),
 1426:                          float_dtype(a10))
 1427:             assert_equal(masked_array(x, mask=m1, dtype=float_dtype).min(),
 1428:                          float_dtype(an10))
 1429: 
 1430:         assert_equal(xm.min(), an10)
 1431:         assert_equal(xm.max(), a10)
 1432: 
 1433:         # Non-complex type only test
 1434:         for float_dtype in float_dtypes[:4]:
 1435:             assert_equal(masked_array(x, mask=m1, dtype=float_dtype).max(),
 1436:                          float_dtype(a10))
 1437:             assert_equal(masked_array(x, mask=m1, dtype=float_dtype).min(),
 1438:                          float_dtype(an10))
 1439: 
 1440:         # Complex types only test
 1441:         for float_dtype in float_dtypes[-3:]:
 1442:             ym = masked_array([1e20 + 1j, 1e20 - 2j, 1e20 - 1j], mask=[0, 1, 0],
 1443:                           dtype=float_dtype)
 1444:             assert_equal(ym.min(), float_dtype(1e20 - 1j))
 1445:             assert_equal(ym.max(), float_dtype(1e20 + 1j))
 1446: 
 1447:             zm = masked_array([np.inf + 2j, np.inf + 3j, -np.inf - 1j], mask=[0, 1, 0],
 1448:                               dtype=float_dtype)
 1449:             assert_equal(zm.min(), float_dtype(-np.inf - 1j))
 1450:             assert_equal(zm.max(), float_dtype(np.inf + 2j))
 1451: 
 1452:             cmax = np.inf - 1j * np.finfo(np.float64).max
 1453:             assert masked_array([-cmax, 0], mask=[0, 1]).max() == -cmax
 1454:             assert masked_array([cmax, 0], mask=[0, 1]).min() == cmax
 1455: 
 1456:     @pytest.mark.parametrize("dtype", "bBiIqQ")
 1457:     @pytest.mark.parametrize("mask", [
 1458:         [False, False, False, True, True],  # masked min/max
 1459:         [False, False, False, True, False],  # masked max only
 1460:         [False, False, False, False, True],  # masked min only
 1461:     ])
 1462:     @pytest.mark.parametrize("axis", [None, -1])
 1463:     def test_minmax_ints(self, dtype, mask, axis):
 1464:         iinfo = np.iinfo(dtype)
 1465:         # two dimensional to hit certain filling paths
 1466:         a = np.array([[0, 10, -10, iinfo.min, iinfo.max]] * 2).astype(dtype)
 1467:         mask = np.asarray([mask] * 2)
 1468: 
 1469:         masked_a = masked_array(a, mask=mask)
 1470:         assert_array_equal(masked_a.min(axis), a[~mask].min(axis))
 1471:         assert_array_equal(masked_a.max(axis), a[~mask].max(axis))
 1472: 
 1473:     @pytest.mark.parametrize("time_type", ["M8[s]", "m8[s]"])
 1474:     def test_minmax_time_dtypes(self, time_type):
 1475:         def minmax_with_mask(arr, mask):
 1476:             masked_arr = masked_array(arr, mask=mask)
 1477:             expected_min = arr[~np.array(mask, dtype=bool)].min()
 1478:             expected_max = arr[~np.array(mask, dtype=bool)].max()
 1479: 
 1480:             assert_array_equal(masked_arr.min(), expected_min)
 1481:             assert_array_equal(masked_arr.max(), expected_max)
 1482: 
 1483:         # Additional tests on max/min for time dtypes
 1484:         x1 = np.array([1, 1, -2, 4, 5, -10, 10, 1, 2, -2**63 + 1], dtype=time_type)
 1485:         x2 = np.array(['NaT', 1, -2, 4, 5, -10, 10, 1, 2, 3], dtype=time_type)
 1486:         x3 = np.array(['NaT', 'NaT', -2, 4, 5, -10, 10, 1, 2, 3], dtype=time_type)
 1487:         x_test = [x1, x2, x3]
 1488:         m = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0]
 1489: 
 1490:         for x in x_test:
 1491:             minmax_with_mask(x, m)
 1492: 
 1493:     def test_addsumprod(self):
 1494:         # Tests add, sum, product.
 1495:         (x, y, a10, m1, m2, xm, ym, z, zm, xf) = self.d
 1496:         assert_equal(np.add.reduce(x), add.reduce(x))
 1497:         assert_equal(np.add.accumulate(x), add.accumulate(x))
 1498:         assert_equal(4, sum(array(4), axis=0))
 1499:         assert_equal(4, sum(array(4), axis=0))
 1500:         assert_equal(np.sum(x, axis=0), sum(x, axis=0))
 1501:         assert_equal(np.sum(filled(xm, 0), axis=0), sum(xm, axis=0))
 1502:         assert_equal(np.sum(x, 0), sum(x, 0))
 1503:         assert_equal(np.prod(x, axis=0), product(x, axis=0))
 1504:         assert_equal(np.prod(x, 0), product(x, 0))
 1505:         assert_equal(np.prod(filled(xm, 1), axis=0), product(xm, axis=0))
 1506:         s = (3, 4)
 1507:         x.shape = y.shape = xm.shape = ym.shape = s
 1508:         if len(s) > 1:
 1509:             assert_equal(np.concatenate((x, y), 1), concatenate((xm, ym), 1))
 1510:             assert_equal(np.add.reduce(x, 1), add.reduce(x, 1))
 1511:             assert_equal(np.sum(x, 1), sum(x, 1))
 1512:             assert_equal(np.prod(x, 1), product(x, 1))
 1513: 
 1514:     def test_binops_d2D(self):
 1515:         # Test binary operations on 2D data
 1516:         a = array([[1.], [2.], [3.]], mask=[[False], [True], [True]])
 1517:         b = array([[2., 3.], [4., 5.], [6., 7.]])
 1518: 
 1519:         test = a * b
 1520:         control = array([[2., 3.], [2., 2.], [3., 3.]],
 1521:                         mask=[[0, 0], [1, 1], [1, 1]])
 1522:         assert_equal(test, control)
 1523:         assert_equal(test.data, control.data)
 1524:         assert_equal(test.mask, control.mask)
 1525: 
 1526:         test = b * a
 1527:         control = array([[2., 3.], [4., 5.], [6., 7.]],
 1528:                         mask=[[0, 0], [1, 1], [1, 1]])
 1529:         assert_equal(test, control)
 1530:         assert_equal(test.data, control.data)
 1531:         assert_equal(test.mask, control.mask)
 1532: 
 1533:         a = array([[1.], [2.], [3.]])
 1534:         b = array([[2., 3.], [4., 5.], [6., 7.]],
 1535:                   mask=[[0, 0], [0, 0], [0, 1]])
 1536:         test = a * b
 1537:         control = array([[2, 3], [8, 10], [18, 3]],
 1538:                         mask=[[0, 0], [0, 0], [0, 1]])
 1539:         assert_equal(test, control)
 1540:         assert_equal(test.data, control.data)
 1541:         assert_equal(test.mask, control.mask)
 1542: 
 1543:         test = b * a
 1544:         control = array([[2, 3], [8, 10], [18, 7]],
 1545:                         mask=[[0, 0], [0, 0], [0, 1]])
 1546:         assert_equal(test, control)
 1547:         assert_equal(test.data, control.data)
 1548:         assert_equal(test.mask, control.mask)
 1549: 
 1550:     def test_domained_binops_d2D(self):
 1551:         # Test domained binary operations on 2D data
 1552:         a = array([[1.], [2.], [3.]], mask=[[False], [True], [True]])
 1553:         b = array([[2., 3.], [4., 5.], [6., 7.]])
 1554: 
 1555:         test = a / b
 1556:         control = array([[1. / 2., 1. / 3.], [2., 2.], [3., 3.]],
 1557:                         mask=[[0, 0], [1, 1], [1, 1]])
 1558:         assert_equal(test, control)
 1559:         assert_equal(test.data, control.data)
 1560:         assert_equal(test.mask, control.mask)
 1561: 
 1562:         test = b / a
 1563:         control = array([[2. / 1., 3. / 1.], [4., 5.], [6., 7.]],
 1564:                         mask=[[0, 0], [1, 1], [1, 1]])
 1565:         assert_equal(test, control)
 1566:         assert_equal(test.data, control.data)
 1567:         assert_equal(test.mask, control.mask)
 1568: 
 1569:         a = array([[1.], [2.], [3.]])
 1570:         b = array([[2., 3.], [4., 5.], [6., 7.]],
 1571:                   mask=[[0, 0], [0, 0], [0, 1]])
 1572:         test = a / b
 1573:         control = array([[1. / 2, 1. / 3], [2. / 4, 2. / 5], [3. / 6, 3]],
 1574:                         mask=[[0, 0], [0, 0], [0, 1]])
 1575:         assert_equal(test, control)
 1576:         assert_equal(test.data, control.data)
 1577:         assert_equal(test.mask, control.mask)
 1578: 
 1579:         test = b / a
 1580:         control = array([[2 / 1., 3 / 1.], [4 / 2., 5 / 2.], [6 / 3., 7]],
 1581:                         mask=[[0, 0], [0, 0], [0, 1]])
 1582:         assert_equal(test, control)
 1583:         assert_equal(test.data, control.data)
 1584:         assert_equal(test.mask, control.mask)
 1585: 
 1586:     def test_noshrinking(self):
 1587:         # Check that we don't shrink a mask when not wanted
 1588:         # Binary operations
 1589:         a = masked_array([1., 2., 3.], mask=[False, False, False],
 1590:                          shrink=False)
 1591:         b = a + 1
 1592:         assert_equal(b.mask, [0, 0, 0])
 1593:         # In place binary operation
 1594:         a += 1
 1595:         assert_equal(a.mask, [0, 0, 0])
 1596:         # Domained binary operation
 1597:         b = a / 1.
 1598:         assert_equal(b.mask, [0, 0, 0])
 1599:         # In place binary operation
 1600:         a /= 1.
 1601:         assert_equal(a.mask, [0, 0, 0])
 1602: 
 1603:     def test_ufunc_nomask(self):
 1604:         # check the case ufuncs should set the mask to false
 1605:         m = np.ma.array([1])
 1606:         # check we don't get array([False], dtype=bool)
 1607:         assert_equal(np.true_divide(m, 5).mask.shape, ())
 1608: 
 1609:     def test_noshink_on_creation(self):
 1610:         # Check that the mask is not shrunk on array creation when not wanted
 1611:         a = np.ma.masked_values([1., 2.5, 3.1], 1.5, shrink=False)
 1612:         assert_equal(a.mask, [0, 0, 0])
 1613: 
 1614:     def test_mod(self):
 1615:         # Tests mod
 1616:         (x, y, a10, m1, m2, xm, ym, z, zm, xf) = self.d
 1617:         assert_equal(mod(x, y), mod(xm, ym))
 1618:         test = mod(ym, xm)
 1619:         assert_equal(test, np.mod(ym, xm))
 1620:         assert_equal(test.mask, mask_or(xm.mask, ym.mask))
 1621:         test = mod(xm, ym)
 1622:         assert_equal(test, np.mod(xm, ym))
 1623:         assert_equal(test.mask, mask_or(mask_or(xm.mask, ym.mask), (ym == 0)))
 1624: 
 1625:     def test_TakeTransposeInnerOuter(self):
 1626:         # Test of take, transpose, inner, outer products
 1627:         x = arange(24)
 1628:         y = np.arange(24)
 1629:         x[5:6] = masked
 1630:         x = x.reshape(2, 3, 4)
 1631:         y = y.reshape(2, 3, 4)
 1632:         assert_equal(np.transpose(y, (2, 0, 1)), transpose(x, (2, 0, 1)))
 1633:         assert_equal(np.take(y, (2, 0, 1), 1), take(x, (2, 0, 1), 1))
 1634:         assert_equal(np.inner(filled(x, 0), filled(y, 0)),
 1635:                      inner(x, y))
 1636:         assert_equal(np.outer(filled(x, 0), filled(y, 0)),
 1637:                      outer(x, y))
 1638:         y = array(['abc', 1, 'def', 2, 3], object)
 1639:         y[2] = masked
 1640:         t = take(y, [0, 3, 4])
 1641:         assert_(t[0] == 'abc')
 1642:         assert_(t[1] == 2)
 1643:         assert_(t[2] == 3)
 1644: 
 1645:     def test_imag_real(self):
 1646:         # Check complex
 1647:         xx = array([1 + 10j, 20 + 2j], mask=[1, 0])
 1648:         assert_equal(xx.imag, [10, 2])
 1649:         assert_equal(xx.imag.filled(), [1e+20, 2])
 1650:         assert_equal(xx.imag.dtype, xx._data.imag.dtype)
 1651:         assert_equal(xx.real, [1, 20])
 1652:         assert_equal(xx.real.filled(), [1e+20, 20])
 1653:         assert_equal(xx.real.dtype, xx._data.real.dtype)
 1654: 
 1655:     def test_methods_with_output(self):
 1656:         xm = array(np.random.uniform(0, 10, 12)).reshape(3, 4)
 1657:         xm[:, 0] = xm[0] = xm[-1, -1] = masked
 1658: 
 1659:         funclist = ('sum', 'prod', 'var', 'std', 'max', 'min', 'ptp', 'mean',)
 1660: 
 1661:         for funcname in funclist:
 1662:             npfunc = getattr(np, funcname)
 1663:             xmmeth = getattr(xm, funcname)
 1664:             # A ndarray as explicit input
 1665:             output = np.empty(4, dtype=float)
 1666:             output.fill(-9999)
 1667:             result = npfunc(xm, axis=0, out=output)
 1668:             # ... the result should be the given output
 1669:             assert_(result is output)
 1670:             assert_equal(result, xmmeth(axis=0, out=output))
 1671: 
 1672:             output = empty(4, dtype=int)
 1673:             result = xmmeth(axis=0, out=output)
 1674:             assert_(result is output)
 1675:             assert_(output[0] is masked)
 1676: 
 1677:     def test_eq_on_structured(self):
 1678:         # Test the equality of structured arrays
 1679:         ndtype = [('A', int), ('B', int)]
 1680:         a = array([(1, 1), (2, 2)], mask=[(0, 1), (0, 0)], dtype=ndtype)
 1681: 
 1682:         test = (a == a)
 1683:         assert_equal(test.data, [True, True])
 1684:         assert_equal(test.mask, [False, False])
 1685:         assert_(test.fill_value == True)
 1686: 
 1687:         test = (a == a[0])
 1688:         assert_equal(test.data, [True, False])
 1689:         assert_equal(test.mask, [False, False])
 1690:         assert_(test.fill_value == True)
 1691: 
 1692:         b = array([(1, 1), (2, 2)], mask=[(1, 0), (0, 0)], dtype=ndtype)
 1693:         test = (a == b)
 1694:         assert_equal(test.data, [False, True])
 1695:         assert_equal(test.mask, [True, False])
 1696:         assert_(test.fill_value == True)
 1697: 
 1698:         test = (a[0] == b)
 1699:         assert_equal(test.data, [False, False])
 1700:         assert_equal(test.mask, [True, False])
 1701:         assert_(test.fill_value == True)
 1702: 
 1703:         b = array([(1, 1), (2, 2)], mask=[(0, 1), (1, 0)], dtype=ndtype)
 1704:         test = (a == b)
 1705:         assert_equal(test.data, [True, True])
 1706:         assert_equal(test.mask, [False, False])
 1707:         assert_(test.fill_value == True)
 1708: 
 1709:         # complicated dtype, 2-dimensional array.
 1710:         ndtype = [('A', int), ('B', [('BA', int), ('BB', int)])]
 1711:         a = array([[(1, (1, 1)), (2, (2, 2))],
 1712:                    [(3, (3, 3)), (4, (4, 4))]],
 1713:                   mask=[[(0, (1, 0)), (0, (0, 1))],
 1714:                         [(1, (0, 0)), (1, (1, 1))]], dtype=ndtype)
 1715:         test = (a[0, 0] == a)
 1716:         assert_equal(test.data, [[True, False], [False, False]])
 1717:         assert_equal(test.mask, [[False, False], [False, True]])
 1718:         assert_(test.fill_value == True)
 1719: 
 1720:     def test_ne_on_structured(self):
 1721:         # Test the equality of structured arrays
 1722:         ndtype = [('A', int), ('B', int)]
 1723:         a = array([(1, 1), (2, 2)], mask=[(0, 1), (0, 0)], dtype=ndtype)
 1724: 
 1725:         test = (a != a)
 1726:         assert_equal(test.data, [False, False])
 1727:         assert_equal(test.mask, [False, False])
 1728:         assert_(test.fill_value == True)
 1729: 
 1730:         test = (a != a[0])
 1731:         assert_equal(test.data, [False, True])
 1732:         assert_equal(test.mask, [False, False])
 1733:         assert_(test.fill_value == True)
 1734: 
 1735:         b = array([(1, 1), (2, 2)], mask=[(1, 0), (0, 0)], dtype=ndtype)
 1736:         test = (a != b)
 1737:         assert_equal(test.data, [True, False])
 1738:         assert_equal(test.mask, [True, False])
 1739:         assert_(test.fill_value == True)
 1740: 
 1741:         test = (a[0] != b)
 1742:         assert_equal(test.data, [True, True])
 1743:         assert_equal(test.mask, [True, False])
 1744:         assert_(test.fill_value == True)
 1745: 
 1746:         b = array([(1, 1), (2, 2)], mask=[(0, 1), (1, 0)], dtype=ndtype)
 1747:         test = (a != b)
 1748:         assert_equal(test.data, [False, False])
 1749:         assert_equal(test.mask, [False, False])
 1750:         assert_(test.fill_value == True)
 1751: 
 1752:         # complicated dtype, 2-dimensional array.
 1753:         ndtype = [('A', int), ('B', [('BA', int), ('BB', int)])]
 1754:         a = array([[(1, (1, 1)), (2, (2, 2))],
 1755:                    [(3, (3, 3)), (4, (4, 4))]],
 1756:                   mask=[[(0, (1, 0)), (0, (0, 1))],
 1757:                         [(1, (0, 0)), (1, (1, 1))]], dtype=ndtype)
 1758:         test = (a[0, 0] != a)
 1759:         assert_equal(test.data, [[False, True], [True, True]])
 1760:         assert_equal(test.mask, [[False, False], [False, True]])
 1761:         assert_(test.fill_value == True)
 1762: 
 1763:     def test_eq_ne_structured_with_non_masked(self):
 1764:         a = array([(1, 1), (2, 2), (3, 4)],
 1765:                   mask=[(0, 1), (0, 0), (1, 1)], dtype='i4,i4')
 1766:         eq = a == a.data
 1767:         ne = a.data != a
 1768:         # Test the obvious.
 1769:         assert_(np.all(eq))
 1770:         assert_(not np.any(ne))
 1771:         # Expect the mask set only for items with all fields masked.
 1772:         expected_mask = a.mask == np.ones((), a.mask.dtype)
 1773:         assert_array_equal(eq.mask, expected_mask)
 1774:         assert_array_equal(ne.mask, expected_mask)
 1775:         # The masked element will indicated not equal, because the
 1776:         # masks did not match.
 1777:         assert_equal(eq.data, [True, True, False])
 1778:         assert_array_equal(eq.data, ~ne.data)
 1779: 
 1780:     def test_eq_ne_structured_extra(self):
 1781:         # ensure simple examples are symmetric and make sense.
 1782:         # from https://github.com/numpy/numpy/pull/8590#discussion_r101126465
 1783:         dt = np.dtype('i4,i4')
 1784:         for m1 in (mvoid((1, 2), mask=(0, 0), dtype=dt),
 1785:                    mvoid((1, 2), mask=(0, 1), dtype=dt),
 1786:                    mvoid((1, 2), mask=(1, 0), dtype=dt),
 1787:                    mvoid((1, 2), mask=(1, 1), dtype=dt)):
 1788:             ma1 = m1.view(MaskedArray)
 1789:             r1 = ma1.view('2i4')
 1790:             for m2 in (np.array((1, 1), dtype=dt),
 1791:                        mvoid((1, 1), dtype=dt),
 1792:                        mvoid((1, 0), mask=(0, 1), dtype=dt),
 1793:                        mvoid((3, 2), mask=(0, 1), dtype=dt)):
 1794:                 ma2 = m2.view(MaskedArray)
 1795:                 r2 = ma2.view('2i4')
 1796:                 eq_expected = (r1 == r2).all()
 1797:                 assert_equal(m1 == m2, eq_expected)
 1798:                 assert_equal(m2 == m1, eq_expected)
 1799:                 assert_equal(ma1 == m2, eq_expected)
 1800:                 assert_equal(m1 == ma2, eq_expected)
 1801:                 assert_equal(ma1 == ma2, eq_expected)
 1802:                 # Also check it is the same if we do it element by element.
 1803:                 el_by_el = [m1[name] == m2[name] for name in dt.names]
 1804:                 assert_equal(array(el_by_el, dtype=bool).all(), eq_expected)
 1805:                 ne_expected = (r1 != r2).any()
 1806:                 assert_equal(m1 != m2, ne_expected)
 1807:                 assert_equal(m2 != m1, ne_expected)
 1808:                 assert_equal(ma1 != m2, ne_expected)
 1809:                 assert_equal(m1 != ma2, ne_expected)
 1810:                 assert_equal(ma1 != ma2, ne_expected)
 1811:                 el_by_el = [m1[name] != m2[name] for name in dt.names]
 1812:                 assert_equal(array(el_by_el, dtype=bool).any(), ne_expected)
 1813: 
 1814:     @pytest.mark.parametrize('dt', ['S', 'U'])
 1815:     @pytest.mark.parametrize('fill', [None, 'A'])
 1816:     def test_eq_for_strings(self, dt, fill):
 1817:         # Test the equality of structured arrays
 1818:         a = array(['a', 'b'], dtype=dt, mask=[0, 1], fill_value=fill)
 1819: 
 1820:         test = (a == a)
 1821:         assert_equal(test.data, [True, True])
 1822:         assert_equal(test.mask, [False, True])
 1823:         assert_(test.fill_value == True)
 1824: 
 1825:         test = (a == a[0])
 1826:         assert_equal(test.data, [True, False])
 1827:         assert_equal(test.mask, [False, True])
 1828:         assert_(test.fill_value == True)
 1829: 
 1830:         b = array(['a', 'b'], dtype=dt, mask=[1, 0], fill_value=fill)
 1831:         test = (a == b)
 1832:         assert_equal(test.data, [False, False])
 1833:         assert_equal(test.mask, [True, True])
 1834:         assert_(test.fill_value == True)
 1835: 
 1836:         test = (a[0] == b)
 1837:         assert_equal(test.data, [False, False])
 1838:         assert_equal(test.mask, [True, False])
 1839:         assert_(test.fill_value == True)
 1840: 
 1841:         test = (b == a[0])
 1842:         assert_equal(test.data, [False, False])
 1843:         assert_equal(test.mask, [True, False])
 1844:         assert_(test.fill_value == True)
 1845: 
 1846:     @pytest.mark.parametrize('dt', ['S', 'U'])
 1847:     @pytest.mark.parametrize('fill', [None, 'A'])
 1848:     def test_ne_for_strings(self, dt, fill):
 1849:         # Test the equality of structured arrays
 1850:         a = array(['a', 'b'], dtype=dt, mask=[0, 1], fill_value=fill)
 1851: 
 1852:         test = (a != a)
 1853:         assert_equal(test.data, [False, False])
 1854:         assert_equal(test.mask, [False, True])
 1855:         assert_(test.fill_value == True)
 1856: 
 1857:         test = (a != a[0])
 1858:         assert_equal(test.data, [False, True])
 1859:         assert_equal(test.mask, [False, True])
 1860:         assert_(test.fill_value == True)
 1861: 
 1862:         b = array(['a', 'b'], dtype=dt, mask=[1, 0], fill_value=fill)
 1863:         test = (a != b)
 1864:         assert_equal(test.data, [True, True])
 1865:         assert_equal(test.mask, [True, True])
 1866:         assert_(test.fill_value == True)
 1867: 
 1868:         test = (a[0] != b)
 1869:         assert_equal(test.data, [True, True])
 1870:         assert_equal(test.mask, [True, False])
 1871:         assert_(test.fill_value == True)
 1872: 
 1873:         test = (b != a[0])
 1874:         assert_equal(test.data, [True, True])
 1875:         assert_equal(test.mask, [True, False])
 1876:         assert_(test.fill_value == True)
 1877: 
 1878:     @pytest.mark.parametrize('dt1', num_dts, ids=num_ids)
 1879:     @pytest.mark.parametrize('dt2', num_dts, ids=num_ids)
 1880:     @pytest.mark.parametrize('fill', [None, 1])
 1881:     def test_eq_for_numeric(self, dt1, dt2, fill):
 1882:         # Test the equality of structured arrays
 1883:         a = array([0, 1], dtype=dt1, mask=[0, 1], fill_value=fill)
 1884: 
 1885:         test = (a == a)
 1886:         assert_equal(test.data, [True, True])
 1887:         assert_equal(test.mask, [False, True])
 1888:         assert_(test.fill_value == True)
 1889: 
 1890:         test = (a == a[0])
 1891:         assert_equal(test.data, [True, False])
 1892:         assert_equal(test.mask, [False, True])
 1893:         assert_(test.fill_value == True)
 1894: 
 1895:         b = array([0, 1], dtype=dt2, mask=[1, 0], fill_value=fill)
 1896:         test = (a == b)
 1897:         assert_equal(test.data, [False, False])
 1898:         assert_equal(test.mask, [True, True])
 1899:         assert_(test.fill_value == True)
 1900: 
 1901:         test = (a[0] == b)
 1902:         assert_equal(test.data, [False, False])
 1903:         assert_equal(test.mask, [True, False])
 1904:         assert_(test.fill_value == True)
 1905: 
 1906:         test = (b == a[0])
 1907:         assert_equal(test.data, [False, False])
 1908:         assert_equal(test.mask, [True, False])
 1909:         assert_(test.fill_value == True)
 1910: 
 1911:     @pytest.mark.parametrize("op", [operator.eq, operator.lt])
 1912:     def test_eq_broadcast_with_unmasked(self, op):
 1913:         a = array([0, 1], mask=[0, 1])
 1914:         b = np.arange(10).reshape(5, 2)
 1915:         result = op(a, b)
 1916:         assert_(result.mask.shape == b.shape)
 1917:         assert_equal(result.mask, np.zeros(b.shape, bool) | a.mask)
 1918: 
 1919:     @pytest.mark.parametrize("op", [operator.eq, operator.gt])
 1920:     def test_comp_no_mask_not_broadcast(self, op):
 1921:         # Regression test for failing doctest in MaskedArray.nonzero
 1922:         # after gh-24556.
 1923:         a = array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
 1924:         result = op(a, 3)
 1925:         assert_(not result.mask.shape)
 1926:         assert_(result.mask is nomask)
 1927: 
 1928:     @pytest.mark.parametrize('dt1', num_dts, ids=num_ids)
 1929:     @pytest.mark.parametrize('dt2', num_dts, ids=num_ids)
 1930:     @pytest.mark.parametrize('fill', [None, 1])
 1931:     def test_ne_for_numeric(self, dt1, dt2, fill):
 1932:         # Test the equality of structured arrays
 1933:         a = array([0, 1], dtype=dt1, mask=[0, 1], fill_value=fill)
 1934: 
 1935:         test = (a != a)
 1936:         assert_equal(test.data, [False, False])
 1937:         assert_equal(test.mask, [False, True])
 1938:         assert_(test.fill_value == True)
 1939: 
 1940:         test = (a != a[0])
 1941:         assert_equal(test.data, [False, True])
 1942:         assert_equal(test.mask, [False, True])
 1943:         assert_(test.fill_value == True)
 1944: 
 1945:         b = array([0, 1], dtype=dt2, mask=[1, 0], fill_value=fill)
 1946:         test = (a != b)
 1947:         assert_equal(test.data, [True, True])
 1948:         assert_equal(test.mask, [True, True])
 1949:         assert_(test.fill_value == True)
 1950: 
 1951:         test = (a[0] != b)
 1952:         assert_equal(test.data, [True, True])
 1953:         assert_equal(test.mask, [True, False])
 1954:         assert_(test.fill_value == True)
 1955: 
 1956:         test = (b != a[0])
 1957:         assert_equal(test.data, [True, True])
 1958:         assert_equal(test.mask, [True, False])
 1959:         assert_(test.fill_value == True)
 1960: 
 1961:     @pytest.mark.parametrize('dt1', num_dts, ids=num_ids)
 1962:     @pytest.mark.parametrize('dt2', num_dts, ids=num_ids)
 1963:     @pytest.mark.parametrize('fill', [None, 1])
 1964:     @pytest.mark.parametrize('op',
 1965:             [operator.le, operator.lt, operator.ge, operator.gt])
 1966:     def test_comparisons_for_numeric(self, op, dt1, dt2, fill):
 1967:         # Test the equality of structured arrays
 1968:         a = array([0, 1], dtype=dt1, mask=[0, 1], fill_value=fill)
 1969: 
 1970:         test = op(a, a)
 1971:         assert_equal(test.data, op(a._data, a._data))
 1972:         assert_equal(test.mask, [False, True])
 1973:         assert_(test.fill_value == True)
 1974: 
 1975:         test = op(a, a[0])
 1976:         assert_equal(test.data, op(a._data, a._data[0]))
 1977:         assert_equal(test.mask, [False, True])
 1978:         assert_(test.fill_value == True)
 1979: 
 1980:         b = array([0, 1], dtype=dt2, mask=[1, 0], fill_value=fill)
 1981:         test = op(a, b)
 1982:         assert_equal(test.data, op(a._data, b._data))
 1983:         assert_equal(test.mask, [True, True])
 1984:         assert_(test.fill_value == True)
 1985: 
 1986:         test = op(a[0], b)
 1987:         assert_equal(test.data, op(a._data[0], b._data))
 1988:         assert_equal(test.mask, [True, False])
 1989:         assert_(test.fill_value == True)
 1990: 
 1991:         test = op(b, a[0])
 1992:         assert_equal(test.data, op(b._data, a._data[0]))
 1993:         assert_equal(test.mask, [True, False])
 1994:         assert_(test.fill_value == True)
 1995: 
 1996:     @pytest.mark.parametrize('op',
 1997:             [operator.le, operator.lt, operator.ge, operator.gt])
 1998:     @pytest.mark.parametrize('fill', [None, "N/A"])
 1999:     def test_comparisons_strings(self, op, fill):
 2000:         # See gh-21770, mask propagation is broken for strings (and some other
 2001:         # cases) so we explicitly test strings here.
 2002:         # In principle only == and != may need special handling...
 2003:         ma1 = masked_array(["a", "b", "cde"], mask=[0, 1, 0], fill_value=fill)
 2004:         ma2 = masked_array(["cde", "b", "a"], mask=[0, 1, 0], fill_value=fill)
 2005:         assert_equal(op(ma1, ma2)._data, op(ma1._data, ma2._data))
 2006: 
 2007:     def test_eq_with_None(self):
 2008:         # Really, comparisons with None should not be done, but check them
 2009:         # anyway. Note that pep8 will flag these tests.
 2010:         # Deprecation is in place for arrays, and when it happens this
 2011:         # test will fail (and have to be changed accordingly).
 2012: 
 2013:         # With partial mask
 2014:         with suppress_warnings() as sup:
 2015:             sup.filter(FutureWarning, "Comparison to `None`")
 2016:             a = array([None, 1], mask=[0, 1])
 2017:             assert_equal(a == None, array([True, False], mask=[0, 1]))  # noqa: E711
 2018:             assert_equal(a.data == None, [True, False])  # noqa: E711
 2019:             assert_equal(a != None, array([False, True], mask=[0, 1]))  # noqa: E711
 2020:             # With nomask
 2021:             a = array([None, 1], mask=False)
 2022:             assert_equal(a == None, [True, False])  # noqa: E711
 2023:             assert_equal(a != None, [False, True])  # noqa: E711
 2024:             # With complete mask
 2025:             a = array([None, 2], mask=True)
 2026:             assert_equal(a == None, array([False, True], mask=True))  # noqa: E711
 2027:             assert_equal(a != None, array([True, False], mask=True))  # noqa: E711
 2028:             # Fully masked, even comparison to None should return "masked"
 2029:             a = masked
 2030:             assert_equal(a == None, masked)  # noqa: E711
 2031: 
 2032:     def test_eq_with_scalar(self):
 2033:         a = array(1)
 2034:         assert_equal(a == 1, True)
 2035:         assert_equal(a == 0, False)
 2036:         assert_equal(a != 1, False)
 2037:         assert_equal(a != 0, True)
 2038:         b = array(1, mask=True)
 2039:         assert_equal(b == 0, masked)
 2040:         assert_equal(b == 1, masked)
 2041:         assert_equal(b != 0, masked)
 2042:         assert_equal(b != 1, masked)
 2043: 
 2044:     def test_eq_different_dimensions(self):
 2045:         m1 = array([1, 1], mask=[0, 1])
 2046:         # test comparison with both masked and regular arrays.
 2047:         for m2 in (array([[0, 1], [1, 2]]),
 2048:                    np.array([[0, 1], [1, 2]])):
 2049:             test = (m1 == m2)
 2050:             assert_equal(test.data, [[False, False],
 2051:                                      [True, False]])
 2052:             assert_equal(test.mask, [[False, True],
 2053:                                      [False, True]])
 2054: 
 2055:     def test_numpyarithmetic(self):
 2056:         # Check that the mask is not back-propagated when using numpy functions
 2057:         a = masked_array([-1, 0, 1, 2, 3], mask=[0, 0, 0, 0, 1])
 2058:         control = masked_array([np.nan, np.nan, 0, np.log(2), -1],
 2059:                                mask=[1, 1, 0, 0, 1])
 2060: 
 2061:         test = log(a)
 2062:         assert_equal(test, control)
 2063:         assert_equal(test.mask, control.mask)
 2064:         assert_equal(a.mask, [0, 0, 0, 0, 1])
 2065: 
 2066:         test = np.log(a)
 2067:         assert_equal(test, control)
 2068:         assert_equal(test.mask, control.mask)
 2069:         assert_equal(a.mask, [0, 0, 0, 0, 1])
 2070: 
 2071: 
 2072: class TestMaskedArrayAttributes:
 2073: 
 2074:     def test_keepmask(self):
 2075:         # Tests the keep mask flag
 2076:         x = masked_array([1, 2, 3], mask=[1, 0, 0])
 2077:         mx = masked_array(x)
 2078:         assert_equal(mx.mask, x.mask)
 2079:         mx = masked_array(x, mask=[0, 1, 0], keep_mask=False)
 2080:         assert_equal(mx.mask, [0, 1, 0])
 2081:         mx = masked_array(x, mask=[0, 1, 0], keep_mask=True)
 2082:         assert_equal(mx.mask, [1, 1, 0])
 2083:         # We default to true
 2084:         mx = masked_array(x, mask=[0, 1, 0])
 2085:         assert_equal(mx.mask, [1, 1, 0])
 2086: 
 2087:     def test_hardmask(self):
 2088:         # Test hard_mask
 2089:         d = arange(5)
 2090:         n = [0, 0, 0, 1, 1]
 2091:         m = make_mask(n)
 2092:         xh = array(d, mask=m, hard_mask=True)
 2093:         # We need to copy, to avoid updating d in xh !
 2094:         xs = array(d, mask=m, hard_mask=False, copy=True)
 2095:         xh[[1, 4]] = [10, 40]
 2096:         xs[[1, 4]] = [10, 40]
 2097:         assert_equal(xh._data, [0, 10, 2, 3, 4])
 2098:         assert_equal(xs._data, [0, 10, 2, 3, 40])
 2099:         assert_equal(xs.mask, [0, 0, 0, 1, 0])
 2100:         assert_(xh._hardmask)
 2101:         assert_(not xs._hardmask)
 2102:         xh[1:4] = [10, 20, 30]
 2103:         xs[1:4] = [10, 20, 30]
 2104:         assert_equal(xh._data, [0, 10, 20, 3, 4])
 2105:         assert_equal(xs._data, [0, 10, 20, 30, 40])
 2106:         assert_equal(xs.mask, nomask)
 2107:         xh[0] = masked
 2108:         xs[0] = masked
 2109:         assert_equal(xh.mask, [1, 0, 0, 1, 1])
 2110:         assert_equal(xs.mask, [1, 0, 0, 0, 0])
 2111:         xh[:] = 1
 2112:         xs[:] = 1
 2113:         assert_equal(xh._data, [0, 1, 1, 3, 4])
 2114:         assert_equal(xs._data, [1, 1, 1, 1, 1])
 2115:         assert_equal(xh.mask, [1, 0, 0, 1, 1])
 2116:         assert_equal(xs.mask, nomask)
 2117:         # Switch to soft mask
 2118:         xh.soften_mask()
 2119:         xh[:] = arange(5)
 2120:         assert_equal(xh._data, [0, 1, 2, 3, 4])
 2121:         assert_equal(xh.mask, nomask)
 2122:         # Switch back to hard mask
 2123:         xh.harden_mask()
 2124:         xh[xh < 3] = masked
 2125:         assert_equal(xh._data, [0, 1, 2, 3, 4])
 2126:         assert_equal(xh._mask, [1, 1, 1, 0, 0])
 2127:         xh[filled(xh > 1, False)] = 5
 2128:         assert_equal(xh._data, [0, 1, 2, 5, 5])
 2129:         assert_equal(xh._mask, [1, 1, 1, 0, 0])
 2130: 
 2131:         xh = array([[1, 2], [3, 4]], mask=[[1, 0], [0, 0]], hard_mask=True)
 2132:         xh[0] = 0
 2133:         assert_equal(xh._data, [[1, 0], [3, 4]])
 2134:         assert_equal(xh._mask, [[1, 0], [0, 0]])
 2135:         xh[-1, -1] = 5
 2136:         assert_equal(xh._data, [[1, 0], [3, 5]])
 2137:         assert_equal(xh._mask, [[1, 0], [0, 0]])
 2138:         xh[filled(xh < 5, False)] = 2
 2139:         assert_equal(xh._data, [[1, 2], [2, 5]])
 2140:         assert_equal(xh._mask, [[1, 0], [0, 0]])
 2141: 
 2142:     def test_hardmask_again(self):
 2143:         # Another test of hardmask
 2144:         d = arange(5)
 2145:         n = [0, 0, 0, 1, 1]
 2146:         m = make_mask(n)
 2147:         xh = array(d, mask=m, hard_mask=True)
 2148:         xh[4:5] = 999
 2149:         xh[0:1] = 999
 2150:         assert_equal(xh._data, [999, 1, 2, 3, 4])
 2151: 
 2152:     def test_hardmask_oncemore_yay(self):
 2153:         # OK, yet another test of hardmask
 2154:         # Make sure that harden_mask/soften_mask//unshare_mask returns self
 2155:         a = array([1, 2, 3], mask=[1, 0, 0])
 2156:         b = a.harden_mask()
 2157:         assert_equal(a, b)
 2158:         b[0] = 0
 2159:         assert_equal(a, b)
 2160:         assert_equal(b, array([1, 2, 3], mask=[1, 0, 0]))
 2161:         a = b.soften_mask()
 2162:         a[0] = 0
 2163:         assert_equal(a, b)
 2164:         assert_equal(b, array([0, 2, 3], mask=[0, 0, 0]))
 2165: 
 2166:     def test_smallmask(self):
 2167:         # Checks the behaviour of _smallmask
 2168:         a = arange(10)
 2169:         a[1] = masked
 2170:         a[1] = 1
 2171:         assert_equal(a._mask, nomask)
 2172:         a = arange(10)
 2173:         a._smallmask = False
 2174:         a[1] = masked
 2175:         a[1] = 1
 2176:         assert_equal(a._mask, zeros(10))
 2177: 
 2178:     def test_shrink_mask(self):
 2179:         # Tests .shrink_mask()
 2180:         a = array([1, 2, 3], mask=[0, 0, 0])
 2181:         b = a.shrink_mask()
 2182:         assert_equal(a, b)
 2183:         assert_equal(a.mask, nomask)
 2184: 
 2185:         # Mask cannot be shrunk on structured types, so is a no-op
 2186:         a = np.ma.array([(1, 2.0)], [('a', int), ('b', float)])
 2187:         b = a.copy()
 2188:         a.shrink_mask()
 2189:         assert_equal(a.mask, b.mask)
 2190: 
 2191:     def test_flat(self):
 2192:         # Test that flat can return all types of items [#4585, #4615]
 2193:         # test 2-D record array
 2194:         # ... on structured array w/ masked records
 2195:         x = array([[(1, 1.1, 'one'), (2, 2.2, 'two'), (3, 3.3, 'thr')],
 2196:                    [(4, 4.4, 'fou'), (5, 5.5, 'fiv'), (6, 6.6, 'six')]],
 2197:                   dtype=[('a', int), ('b', float), ('c', '|S8')])
 2198:         x['a'][0, 1] = masked
 2199:         x['b'][1, 0] = masked
 2200:         x['c'][0, 2] = masked
 2201:         x[-1, -1] = masked
 2202:         xflat = x.flat
 2203:         assert_equal(xflat[0], x[0, 0])
 2204:         assert_equal(xflat[1], x[0, 1])
 2205:         assert_equal(xflat[2], x[0, 2])
 2206:         assert_equal(xflat[:3], x[0])
 2207:         assert_equal(xflat[3], x[1, 0])
 2208:         assert_equal(xflat[4], x[1, 1])
 2209:         assert_equal(xflat[5], x[1, 2])
 2210:         assert_equal(xflat[3:], x[1])
 2211:         assert_equal(xflat[-1], x[-1, -1])
 2212:         i = 0
 2213:         j = 0
 2214:         for xf in xflat:
 2215:             assert_equal(xf, x[j, i])
 2216:             i += 1
 2217:             if i >= x.shape[-1]:
 2218:                 i = 0
 2219:                 j += 1
 2220: 
 2221:     def test_assign_dtype(self):
 2222:         # check that the mask's dtype is updated when dtype is changed
 2223:         a = np.zeros(4, dtype='f4,i4')
 2224: 
 2225:         m = np.ma.array(a)
 2226:         m.dtype = np.dtype('f4')
 2227:         repr(m)  # raises?
 2228:         assert_equal(m.dtype, np.dtype('f4'))
 2229: 
 2230:         # check that dtype changes that change shape of mask too much
 2231:         # are not allowed
 2232:         def assign():
 2233:             m = np.ma.array(a)
 2234:             m.dtype = np.dtype('f8')
 2235:         assert_raises(ValueError, assign)
 2236: 
 2237:         b = a.view(dtype='f4', type=np.ma.MaskedArray)  # raises?
 2238:         assert_equal(b.dtype, np.dtype('f4'))
 2239: 
 2240:         # check that nomask is preserved
 2241:         a = np.zeros(4, dtype='f4')
 2242:         m = np.ma.array(a)
 2243:         m.dtype = np.dtype('f4,i4')
 2244:         assert_equal(m.dtype, np.dtype('f4,i4'))
 2245:         assert_equal(m._mask, np.ma.nomask)
 2246: 
 2247: 
 2248: class TestFillingValues:
 2249: 
 2250:     def test_check_on_scalar(self):
 2251:         # Test _check_fill_value set to valid and invalid values
 2252:         _check_fill_value = np.ma.core._check_fill_value
 2253: 
 2254:         fval = _check_fill_value(0, int)
 2255:         assert_equal(fval, 0)
 2256:         fval = _check_fill_value(None, int)
 2257:         assert_equal(fval, default_fill_value(0))
 2258: 
 2259:         fval = _check_fill_value(0, "|S3")
 2260:         assert_equal(fval, b"0")
 2261:         fval = _check_fill_value(None, "|S3")
 2262:         assert_equal(fval, default_fill_value(b"camelot!"))
 2263:         assert_raises(TypeError, _check_fill_value, 1e+20, int)
 2264:         assert_raises(TypeError, _check_fill_value, 'stuff', int)
 2265: 
 2266:     def test_check_on_fields(self):
 2267:         # Tests _check_fill_value with records
 2268:         _check_fill_value = np.ma.core._check_fill_value
 2269:         ndtype = [('a', int), ('b', float), ('c', "|S3")]
 2270:         # A check on a list should return a single record
 2271:         fval = _check_fill_value([-999, -12345678.9, "???"], ndtype)
 2272:         assert_(isinstance(fval, ndarray))
 2273:         assert_equal(fval.item(), [-999, -12345678.9, b"???"])
 2274:         # A check on None should output the defaults
 2275:         fval = _check_fill_value(None, ndtype)
 2276:         assert_(isinstance(fval, ndarray))
 2277:         assert_equal(fval.item(), [default_fill_value(0),
 2278:                                    default_fill_value(0.),
 2279:                                    asbytes(default_fill_value("0"))])
 2280:         #.....Using a structured type as fill_value should work
 2281:         fill_val = np.array((-999, -12345678.9, "???"), dtype=ndtype)
 2282:         fval = _check_fill_value(fill_val, ndtype)
 2283:         assert_(isinstance(fval, ndarray))
 2284:         assert_equal(fval.item(), [-999, -12345678.9, b"???"])
 2285: 
 2286:         #.....Using a flexible type w/ a different type shouldn't matter
 2287:         # BEHAVIOR in 1.5 and earlier, and 1.13 and later: match structured
 2288:         # types by position
 2289:         fill_val = np.array((-999, -12345678.9, "???"),
 2290:                             dtype=[("A", int), ("B", float), ("C", "|S3")])
 2291:         fval = _check_fill_value(fill_val, ndtype)
 2292:         assert_(isinstance(fval, ndarray))
 2293:         assert_equal(fval.item(), [-999, -12345678.9, b"???"])
 2294: 
 2295:         #.....Using an object-array shouldn't matter either
 2296:         fill_val = np.ndarray(shape=(1,), dtype=object)
 2297:         fill_val[0] = (-999, -12345678.9, b"???")
 2298:         fval = _check_fill_value(fill_val, object)
 2299:         assert_(isinstance(fval, ndarray))
 2300:         assert_equal(fval.item(), [-999, -12345678.9, b"???"])
 2301:         # NOTE: This test was never run properly as "fill_value" rather than
 2302:         # "fill_val" was assigned.  Written properly, it fails.
 2303:         #fill_val = np.array((-999, -12345678.9, "???"))
 2304:         #fval = _check_fill_value(fill_val, ndtype)
 2305:         #assert_(isinstance(fval, ndarray))
 2306:         #assert_equal(fval.item(), [-999, -12345678.9, b"???"])
 2307:         #.....One-field-only flexible type should work as well
 2308:         ndtype = [("a", int)]
 2309:         fval = _check_fill_value(-999999999, ndtype)
 2310:         assert_(isinstance(fval, ndarray))
 2311:         assert_equal(fval.item(), (-999999999,))
 2312: 
 2313:     def test_fillvalue_conversion(self):
 2314:         # Tests the behavior of fill_value during conversion
 2315:         # We had a tailored comment to make sure special attributes are
 2316:         # properly dealt with
 2317:         a = array([b'3', b'4', b'5'])
 2318:         a._optinfo.update({'comment': "updated!"})
 2319: 
 2320:         b = array(a, dtype=int)
 2321:         assert_equal(b._data, [3, 4, 5])
 2322:         assert_equal(b.fill_value, default_fill_value(0))
 2323: 
 2324:         b = array(a, dtype=float)
 2325:         assert_equal(b._data, [3, 4, 5])
 2326:         assert_equal(b.fill_value, default_fill_value(0.))
 2327: 
 2328:         b = a.astype(int)
 2329:         assert_equal(b._data, [3, 4, 5])
 2330:         assert_equal(b.fill_value, default_fill_value(0))
 2331:         assert_equal(b._optinfo['comment'], "updated!")
 2332: 
 2333:         b = a.astype([('a', '|S3')])
 2334:         assert_equal(b['a']._data, a._data)
 2335:         assert_equal(b['a'].fill_value, a.fill_value)
 2336: 
 2337:     def test_default_fill_value(self):
 2338:         # check all calling conventions
 2339:         f1 = default_fill_value(1.)
 2340:         f2 = default_fill_value(np.array(1.))
 2341:         f3 = default_fill_value(np.array(1.).dtype)
 2342:         assert_equal(f1, f2)
 2343:         assert_equal(f1, f3)
 2344: 
 2345:     def test_default_fill_value_structured(self):
 2346:         fields = array([(1, 1, 1)],
 2347:                       dtype=[('i', int), ('s', '|S8'), ('f', float)])
 2348: 
 2349:         f1 = default_fill_value(fields)
 2350:         f2 = default_fill_value(fields.dtype)
 2351:         expected = np.array((default_fill_value(0),
 2352:                              default_fill_value('0'),
 2353:                              default_fill_value(0.)), dtype=fields.dtype)
 2354:         assert_equal(f1, expected)
 2355:         assert_equal(f2, expected)
 2356: 
 2357:     def test_default_fill_value_void(self):
 2358:         dt = np.dtype([('v', 'V7')])
 2359:         f = default_fill_value(dt)
 2360:         assert_equal(f['v'], np.array(default_fill_value(dt['v']), dt['v']))
 2361: 
 2362:     def test_fillvalue(self):
 2363:         # Yet more fun with the fill_value
 2364:         data = masked_array([1, 2, 3], fill_value=-999)
 2365:         series = data[[0, 2, 1]]
 2366:         assert_equal(series._fill_value, data._fill_value)
 2367: 
 2368:         mtype = [('f', float), ('s', '|S3')]
 2369:         x = array([(1, 'a'), (2, 'b'), (pi, 'pi')], dtype=mtype)
 2370:         x.fill_value = 999
 2371:         assert_equal(x.fill_value.item(), [999., b'999'])
 2372:         assert_equal(x['f'].fill_value, 999)
 2373:         assert_equal(x['s'].fill_value, b'999')
 2374: 
 2375:         x.fill_value = (9, '???')
 2376:         assert_equal(x.fill_value.item(), (9, b'???'))
 2377:         assert_equal(x['f'].fill_value, 9)
 2378:         assert_equal(x['s'].fill_value, b'???')
 2379: 
 2380:         x = array([1, 2, 3.1])
 2381:         x.fill_value = 999
 2382:         assert_equal(np.asarray(x.fill_value).dtype, float)
 2383:         assert_equal(x.fill_value, 999.)
 2384:         assert_equal(x._fill_value, np.array(999.))
 2385: 
 2386:     def test_subarray_fillvalue(self):
 2387:         # gh-10483   test multi-field index fill value
 2388:         fields = array([(1, 1, 1)],
 2389:                       dtype=[('i', int), ('s', '|S8'), ('f', float)])
 2390:         with suppress_warnings() as sup:
 2391:             sup.filter(FutureWarning, "Numpy has detected")
 2392:             subfields = fields[['i', 'f']]
 2393:             assert_equal(tuple(subfields.fill_value), (999999, 1.e+20))
 2394:             # test comparison does not raise:
 2395:             subfields[1:] == subfields[:-1]
 2396: 
 2397:     def test_fillvalue_exotic_dtype(self):
 2398:         # Tests yet more exotic flexible dtypes
 2399:         _check_fill_value = np.ma.core._check_fill_value
 2400:         ndtype = [('i', int), ('s', '|S8'), ('f', float)]
 2401:         control = np.array((default_fill_value(0),
 2402:                             default_fill_value('0'),
 2403:                             default_fill_value(0.),),
 2404:                            dtype=ndtype)
 2405:         assert_equal(_check_fill_value(None, ndtype), control)
 2406:         # The shape shouldn't matter
 2407:         ndtype = [('f0', float, (2, 2))]
 2408:         control = np.array((default_fill_value(0.),),
 2409:                            dtype=[('f0', float)]).astype(ndtype)
 2410:         assert_equal(_check_fill_value(None, ndtype), control)
 2411:         control = np.array((0,), dtype=[('f0', float)]).astype(ndtype)
 2412:         assert_equal(_check_fill_value(0, ndtype), control)
 2413: 
 2414:         ndtype = np.dtype("int, (2,3)float, float")
 2415:         control = np.array((default_fill_value(0),
 2416:                             default_fill_value(0.),
 2417:                             default_fill_value(0.),),
 2418:                            dtype="int, float, float").astype(ndtype)
 2419:         test = _check_fill_value(None, ndtype)
 2420:         assert_equal(test, control)
 2421:         control = np.array((0, 0, 0), dtype="int, float, float").astype(ndtype)
 2422:         assert_equal(_check_fill_value(0, ndtype), control)
 2423:         # but when indexing, fill value should become scalar not tuple
 2424:         # See issue #6723
 2425:         M = masked_array(control)
 2426:         assert_equal(M["f1"].fill_value.ndim, 0)
 2427: 
 2428:     def test_fillvalue_datetime_timedelta(self):
 2429:         # Test default fillvalue for datetime64 and timedelta64 types.
 2430:         # See issue #4476, this would return '?' which would cause errors
 2431:         # elsewhere
 2432: 
 2433:         for timecode in ("as", "fs", "ps", "ns", "us", "ms", "s", "m",
 2434:                          "h", "D", "W", "M", "Y"):
 2435:             control = numpy.datetime64("NaT", timecode)
 2436:             test = default_fill_value(numpy.dtype("<M8[" + timecode + "]"))
 2437:             np.testing.assert_equal(test, control)
 2438: 
 2439:             control = numpy.timedelta64("NaT", timecode)
 2440:             test = default_fill_value(numpy.dtype("<m8[" + timecode + "]"))
 2441:             np.testing.assert_equal(test, control)
 2442: 
 2443:     def test_extremum_fill_value(self):
 2444:         # Tests extremum fill values for flexible type.
 2445:         a = array([(1, (2, 3)), (4, (5, 6))],
 2446:                   dtype=[('A', int), ('B', [('BA', int), ('BB', int)])])
 2447:         test = a.fill_value
 2448:         assert_equal(test.dtype, a.dtype)
 2449:         assert_equal(test['A'], default_fill_value(a['A']))
 2450:         assert_equal(test['B']['BA'], default_fill_value(a['B']['BA']))
 2451:         assert_equal(test['B']['BB'], default_fill_value(a['B']['BB']))
 2452: 
 2453:         test = minimum_fill_value(a)
 2454:         assert_equal(test.dtype, a.dtype)
 2455:         assert_equal(test[0], minimum_fill_value(a['A']))
 2456:         assert_equal(test[1][0], minimum_fill_value(a['B']['BA']))
 2457:         assert_equal(test[1][1], minimum_fill_value(a['B']['BB']))
 2458:         assert_equal(test[1], minimum_fill_value(a['B']))
 2459: 
 2460:         test = maximum_fill_value(a)
 2461:         assert_equal(test.dtype, a.dtype)
 2462:         assert_equal(test[0], maximum_fill_value(a['A']))
 2463:         assert_equal(test[1][0], maximum_fill_value(a['B']['BA']))
 2464:         assert_equal(test[1][1], maximum_fill_value(a['B']['BB']))
 2465:         assert_equal(test[1], maximum_fill_value(a['B']))
 2466: 
 2467:     def test_extremum_fill_value_subdtype(self):
 2468:         a = array(([2, 3, 4],), dtype=[('value', np.int8, 3)])
 2469: 
 2470:         test = minimum_fill_value(a)
 2471:         assert_equal(test.dtype, a.dtype)
 2472:         assert_equal(test[0], np.full(3, minimum_fill_value(a['value'])))
 2473: 
 2474:         test = maximum_fill_value(a)
 2475:         assert_equal(test.dtype, a.dtype)
 2476:         assert_equal(test[0], np.full(3, maximum_fill_value(a['value'])))
 2477: 
 2478:     def test_fillvalue_individual_fields(self):
 2479:         # Test setting fill_value on individual fields
 2480:         ndtype = [('a', int), ('b', int)]
 2481:         # Explicit fill_value
 2482:         a = array(list(zip([1, 2, 3], [4, 5, 6])),
 2483:                   fill_value=(-999, -999), dtype=ndtype)
 2484:         aa = a['a']
 2485:         aa.set_fill_value(10)
 2486:         assert_equal(aa._fill_value, np.array(10))
 2487:         assert_equal(tuple(a.fill_value), (10, -999))
 2488:         a.fill_value['b'] = -10
 2489:         assert_equal(tuple(a.fill_value), (10, -10))
 2490:         # Implicit fill_value
 2491:         t = array(list(zip([1, 2, 3], [4, 5, 6])), dtype=ndtype)
 2492:         tt = t['a']
 2493:         tt.set_fill_value(10)
 2494:         assert_equal(tt._fill_value, np.array(10))
 2495:         assert_equal(tuple(t.fill_value), (10, default_fill_value(0)))
 2496: 
 2497:     def test_fillvalue_implicit_structured_array(self):
 2498:         # Check that fill_value is always defined for structured arrays
 2499:         ndtype = ('b', float)
 2500:         adtype = ('a', float)
 2501:         a = array([(1.,), (2.,)], mask=[(False,), (False,)],
 2502:                   fill_value=(np.nan,), dtype=np.dtype([adtype]))
 2503:         b = empty(a.shape, dtype=[adtype, ndtype])
 2504:         b['a'] = a['a']
 2505:         b['a'].set_fill_value(a['a'].fill_value)
 2506:         f = b._fill_value[()]
 2507:         assert_(np.isnan(f[0]))
 2508:         assert_equal(f[-1], default_fill_value(1.))
 2509: 
 2510:     def test_fillvalue_as_arguments(self):
 2511:         # Test adding a fill_value parameter to empty/ones/zeros
 2512:         a = empty(3, fill_value=999.)
 2513:         assert_equal(a.fill_value, 999.)
 2514: 
 2515:         a = ones(3, fill_value=999., dtype=float)
 2516:         assert_equal(a.fill_value, 999.)
 2517: 
 2518:         a = zeros(3, fill_value=0., dtype=complex)
 2519:         assert_equal(a.fill_value, 0.)
 2520: 
 2521:         a = identity(3, fill_value=0., dtype=complex)
 2522:         assert_equal(a.fill_value, 0.)
 2523: 
 2524:     def test_shape_argument(self):
 2525:         # Test that shape can be provides as an argument
 2526:         # GH issue 6106
 2527:         a = empty(shape=(3, ))
 2528:         assert_equal(a.shape, (3, ))
 2529: 
 2530:         a = ones(shape=(3, ), dtype=float)
 2531:         assert_equal(a.shape, (3, ))
 2532: 
 2533:         a = zeros(shape=(3, ), dtype=complex)
 2534:         assert_equal(a.shape, (3, ))
 2535: 
 2536:     def test_fillvalue_in_view(self):
 2537:         # Test the behavior of fill_value in view
 2538: 
 2539:         # Create initial masked array
 2540:         x = array([1, 2, 3], fill_value=1, dtype=np.int64)
 2541: 
 2542:         # Check that fill_value is preserved by default
 2543:         y = x.view()
 2544:         assert_(y.fill_value == 1)
 2545: 
 2546:         # Check that fill_value is preserved if dtype is specified and the
 2547:         # dtype is an ndarray sub-class and has a _fill_value attribute
 2548:         y = x.view(MaskedArray)
 2549:         assert_(y.fill_value == 1)
 2550: 
 2551:         # Check that fill_value is preserved if type is specified and the
 2552:         # dtype is an ndarray sub-class and has a _fill_value attribute (by
 2553:         # default, the first argument is dtype, not type)
 2554:         y = x.view(type=MaskedArray)
 2555:         assert_(y.fill_value == 1)
 2556: 
 2557:         # Check that code does not crash if passed an ndarray sub-class that
 2558:         # does not have a _fill_value attribute
 2559:         y = x.view(np.ndarray)
 2560:         y = x.view(type=np.ndarray)
 2561: 
 2562:         # Check that fill_value can be overridden with view
 2563:         y = x.view(MaskedArray, fill_value=2)
 2564:         assert_(y.fill_value == 2)
 2565: 
 2566:         # Check that fill_value can be overridden with view (using type=)
 2567:         y = x.view(type=MaskedArray, fill_value=2)
 2568:         assert_(y.fill_value == 2)
 2569: 
 2570:         # Check that fill_value gets reset if passed a dtype but not a
 2571:         # fill_value. This is because even though in some cases one can safely
 2572:         # cast the fill_value, e.g. if taking an int64 view of an int32 array,
 2573:         # in other cases, this cannot be done (e.g. int32 view of an int64
 2574:         # array with a large fill_value).
 2575:         y = x.view(dtype=np.int32)
 2576:         assert_(y.fill_value == 999999)
 2577: 
 2578:     def test_fillvalue_bytes_or_str(self):
 2579:         # Test whether fill values work as expected for structured dtypes
 2580:         # containing bytes or str.  See issue #7259.
 2581:         a = empty(shape=(3, ), dtype="(2,)3S,(2,)3U")
 2582:         assert_equal(a["f0"].fill_value, default_fill_value(b"spam"))
 2583:         assert_equal(a["f1"].fill_value, default_fill_value("eggs"))
 2584: 
 2585: 
 2586: class TestUfuncs:
 2587:     # Test class for the application of ufuncs on MaskedArrays.
 2588: 
 2589:     def setup_method(self):
 2590:         # Base data definition.
 2591:         self.d = (array([1.0, 0, -1, pi / 2] * 2, mask=[0, 1] + [0] * 6),
 2592:                   array([1.0, 0, -1, pi / 2] * 2, mask=[1, 0] + [0] * 6),)
 2593:         self.err_status = np.geterr()
 2594:         np.seterr(divide='ignore', invalid='ignore')
 2595: 
 2596:     def teardown_method(self):
 2597:         np.seterr(**self.err_status)
 2598: 
 2599:     def test_testUfuncRegression(self):
 2600:         # Tests new ufuncs on MaskedArrays.
 2601:         for f in ['sqrt', 'log', 'log10', 'exp', 'conjugate',
 2602:                   'sin', 'cos', 'tan',
 2603:                   'arcsin', 'arccos', 'arctan',
 2604:                   'sinh', 'cosh', 'tanh',
 2605:                   'arcsinh',
 2606:                   'arccosh',
 2607:                   'arctanh',
 2608:                   'absolute', 'fabs', 'negative',
 2609:                   'floor', 'ceil',
 2610:                   'logical_not',
 2611:                   'add', 'subtract', 'multiply',
 2612:                   'divide', 'true_divide', 'floor_divide',
 2613:                   'remainder', 'fmod', 'hypot', 'arctan2',
 2614:                   'equal', 'not_equal', 'less_equal', 'greater_equal',
 2615:                   'less', 'greater',
 2616:                   'logical_and', 'logical_or', 'logical_xor',
 2617:                   ]:
 2618:             try:
 2619:                 uf = getattr(umath, f)
 2620:             except AttributeError:
 2621:                 uf = getattr(fromnumeric, f)
 2622:             mf = getattr(numpy.ma.core, f)
 2623:             args = self.d[:uf.nin]
 2624:             ur = uf(*args)
 2625:             mr = mf(*args)
 2626:             assert_equal(ur.filled(0), mr.filled(0), f)
 2627:             assert_mask_equal(ur.mask, mr.mask, err_msg=f)
 2628: 
 2629:     def test_reduce(self):
 2630:         # Tests reduce on MaskedArrays.
 2631:         a = self.d[0]
 2632:         assert_(not alltrue(a, axis=0))
 2633:         assert_(sometrue(a, axis=0))
 2634:         assert_equal(sum(a[:3], axis=0), 0)
 2635:         assert_equal(product(a, axis=0), 0)
 2636:         assert_equal(add.reduce(a), pi)
 2637: 
 2638:     def test_minmax(self):
 2639:         # Tests extrema on MaskedArrays.
 2640:         a = arange(1, 13).reshape(3, 4)
 2641:         amask = masked_where(a < 5, a)
 2642:         assert_equal(amask.max(), a.max())
 2643:         assert_equal(amask.min(), 5)
 2644:         assert_equal(amask.max(0), a.max(0))
 2645:         assert_equal(amask.min(0), [5, 6, 7, 8])
 2646:         assert_(amask.max(1)[0].mask)
 2647:         assert_(amask.min(1)[0].mask)
 2648: 
 2649:     def test_ndarray_mask(self):
 2650:         # Check that the mask of the result is a ndarray (not a MaskedArray...)
 2651:         a = masked_array([-1, 0, 1, 2, 3], mask=[0, 0, 0, 0, 1])
 2652:         test = np.sqrt(a)
 2653:         control = masked_array([-1, 0, 1, np.sqrt(2), -1],
 2654:                                mask=[1, 0, 0, 0, 1])
 2655:         assert_equal(test, control)
 2656:         assert_equal(test.mask, control.mask)
 2657:         assert_(not isinstance(test.mask, MaskedArray))
 2658: 
 2659:     def test_treatment_of_NotImplemented(self):
 2660:         # Check that NotImplemented is returned at appropriate places
 2661: 
 2662:         a = masked_array([1., 2.], mask=[1, 0])
 2663:         assert_raises(TypeError, operator.mul, a, "abc")
 2664:         assert_raises(TypeError, operator.truediv, a, "abc")
 2665: 
 2666:         class MyClass:
 2667:             __array_priority__ = a.__array_priority__ + 1
 2668: 
 2669:             def __mul__(self, other):
 2670:                 return "My mul"
 2671: 
 2672:             def __rmul__(self, other):
 2673:                 return "My rmul"
 2674: 
 2675:         me = MyClass()
 2676:         assert_(me * a == "My mul")
 2677:         assert_(a * me == "My rmul")
 2678: 
 2679:         # and that __array_priority__ is respected
 2680:         class MyClass2:
 2681:             __array_priority__ = 100
 2682: 
 2683:             def __mul__(self, other):
 2684:                 return "Me2mul"
 2685: 
 2686:             def __rmul__(self, other):
 2687:                 return "Me2rmul"
 2688: 
 2689:             def __rtruediv__(self, other):
 2690:                 return "Me2rdiv"
 2691: 
 2692:         me_too = MyClass2()
 2693:         assert_(a.__mul__(me_too) is NotImplemented)
 2694:         assert_(all(multiply.outer(a, me_too) == "Me2rmul"))
 2695:         assert_(a.__truediv__(me_too) is NotImplemented)
 2696:         assert_(me_too * a == "Me2mul")
 2697:         assert_(a * me_too == "Me2rmul")
 2698:         assert_(a / me_too == "Me2rdiv")
 2699: 
 2700:     def test_no_masked_nan_warnings(self):
 2701:         # check that a nan in masked position does not
 2702:         # cause ufunc warnings
 2703: 
 2704:         m = np.ma.array([0.5, np.nan], mask=[0, 1])
 2705: 
 2706:         with warnings.catch_warnings():
 2707:             warnings.filterwarnings("error")
 2708: 
 2709:             # test unary and binary ufuncs
 2710:             exp(m)
 2711:             add(m, 1)
 2712:             m > 0
 2713: 
 2714:             # test different unary domains
 2715:             sqrt(m)
 2716:             log(m)
 2717:             tan(m)
 2718:             arcsin(m)
 2719:             arccos(m)
 2720:             arccosh(m)
 2721: 
 2722:             # test binary domains
 2723:             divide(m, 2)
 2724: 
 2725:             # also check that allclose uses ma ufuncs, to avoid warning
 2726:             allclose(m, 0.5)
 2727: 
 2728:     def test_masked_array_underflow(self):
 2729:         x = np.arange(0, 3, 0.1)
 2730:         X = np.ma.array(x)
 2731:         with np.errstate(under="raise"):
 2732:             X2 = X / 2.0
 2733:             np.testing.assert_array_equal(X2, x / 2)
 2734: 
 2735: class TestMaskedArrayInPlaceArithmetic:
 2736:     # Test MaskedArray Arithmetic
 2737: 
 2738:     def setup_method(self):
 2739:         x = arange(10)
 2740:         y = arange(10)
 2741:         xm = arange(10)
 2742:         xm[2] = masked
 2743:         self.intdata = (x, y, xm)
 2744:         self.floatdata = (x.astype(float), y.astype(float), xm.astype(float))
 2745:         self.othertypes = np.typecodes['AllInteger'] + np.typecodes['AllFloat']
 2746:         self.othertypes = [np.dtype(_).type for _ in self.othertypes]
 2747:         self.uint8data = (
 2748:             x.astype(np.uint8),
 2749:             y.astype(np.uint8),
 2750:             xm.astype(np.uint8)
 2751:         )
 2752: 
 2753:     def test_inplace_addition_scalar(self):
 2754:         # Test of inplace additions
 2755:         (x, y, xm) = self.intdata
 2756:         xm[2] = masked
 2757:         x += 1
 2758:         assert_equal(x, y + 1)
 2759:         xm += 1
 2760:         assert_equal(xm, y + 1)
 2761: 
 2762:         (x, _, xm) = self.floatdata
 2763:         id1 = x.data.ctypes.data
 2764:         x += 1.
 2765:         assert_(id1 == x.data.ctypes.data)
 2766:         assert_equal(x, y + 1.)
 2767: 
 2768:     def test_inplace_addition_array(self):
 2769:         # Test of inplace additions
 2770:         (x, y, xm) = self.intdata
 2771:         m = xm.mask
 2772:         a = arange(10, dtype=np.int16)
 2773:         a[-1] = masked
 2774:         x += a
 2775:         xm += a
 2776:         assert_equal(x, y + a)
 2777:         assert_equal(xm, y + a)
 2778:         assert_equal(xm.mask, mask_or(m, a.mask))
 2779: 
 2780:     def test_inplace_subtraction_scalar(self):
 2781:         # Test of inplace subtractions
 2782:         (x, y, xm) = self.intdata
 2783:         x -= 1
 2784:         assert_equal(x, y - 1)
 2785:         xm -= 1
 2786:         assert_equal(xm, y - 1)
 2787: 
 2788:     def test_inplace_subtraction_array(self):
 2789:         # Test of inplace subtractions
 2790:         (x, y, xm) = self.floatdata
 2791:         m = xm.mask
 2792:         a = arange(10, dtype=float)
 2793:         a[-1] = masked
 2794:         x -= a
 2795:         xm -= a
 2796:         assert_equal(x, y - a)
 2797:         assert_equal(xm, y - a)
 2798:         assert_equal(xm.mask, mask_or(m, a.mask))
 2799: 
 2800:     def test_inplace_multiplication_scalar(self):
 2801:         # Test of inplace multiplication
 2802:         (x, y, xm) = self.floatdata
 2803:         x *= 2.0
 2804:         assert_equal(x, y * 2)
 2805:         xm *= 2.0
 2806:         assert_equal(xm, y * 2)
 2807: 
 2808:     def test_inplace_multiplication_array(self):
 2809:         # Test of inplace multiplication
 2810:         (x, y, xm) = self.floatdata
 2811:         m = xm.mask
 2812:         a = arange(10, dtype=float)
 2813:         a[-1] = masked
 2814:         x *= a
 2815:         xm *= a
 2816:         assert_equal(x, y * a)
 2817:         assert_equal(xm, y * a)
 2818:         assert_equal(xm.mask, mask_or(m, a.mask))
 2819: 
 2820:     def test_inplace_division_scalar_int(self):
 2821:         # Test of inplace division
 2822:         (x, y, xm) = self.intdata
 2823:         x = arange(10) * 2
 2824:         xm = arange(10) * 2
 2825:         xm[2] = masked
 2826:         x //= 2
 2827:         assert_equal(x, y)
 2828:         xm //= 2
 2829:         assert_equal(xm, y)
 2830: 
 2831:     def test_inplace_division_scalar_float(self):
 2832:         # Test of inplace division
 2833:         (x, y, xm) = self.floatdata
 2834:         x /= 2.0
 2835:         assert_equal(x, y / 2.0)
 2836:         xm /= arange(10)
 2837:         assert_equal(xm, ones((10,)))
 2838: 
 2839:     def test_inplace_division_array_float(self):
 2840:         # Test of inplace division
 2841:         (x, y, xm) = self.floatdata
 2842:         m = xm.mask
 2843:         a = arange(10, dtype=float)
 2844:         a[-1] = masked
 2845:         x /= a
 2846:         xm /= a
 2847:         assert_equal(x, y / a)
 2848:         assert_equal(xm, y / a)
 2849:         assert_equal(xm.mask, mask_or(mask_or(m, a.mask), (a == 0)))
 2850: 
 2851:     def test_inplace_division_misc(self):
 2852: 
 2853:         x = [1., 1., 1., -2., pi / 2., 4., 5., -10., 10., 1., 2., 3.]
 2854:         y = [5., 0., 3., 2., -1., -4., 0., -10., 10., 1., 0., 3.]
 2855:         m1 = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]
 2856:         m2 = [0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1]
 2857:         xm = masked_array(x, mask=m1)
 2858:         ym = masked_array(y, mask=m2)
 2859: 
 2860:         z = xm / ym
 2861:         assert_equal(z._mask, [1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1])
 2862:         assert_equal(z._data,
 2863:                      [1., 1., 1., -1., -pi / 2., 4., 5., 1., 1., 1., 2., 3.])
 2864: 
 2865:         xm = xm.copy()
 2866:         xm /= ym
 2867:         assert_equal(xm._mask, [1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1])
 2868:         assert_equal(z._data,
 2869:                      [1., 1., 1., -1., -pi / 2., 4., 5., 1., 1., 1., 2., 3.])
 2870: 
 2871:     def test_datafriendly_add(self):
 2872:         # Test keeping data w/ (inplace) addition
 2873:         x = array([1, 2, 3], mask=[0, 0, 1])
 2874:         # Test add w/ scalar
 2875:         xx = x + 1
 2876:         assert_equal(xx.data, [2, 3, 3])
 2877:         assert_equal(xx.mask, [0, 0, 1])
 2878:         # Test iadd w/ scalar
 2879:         x += 1
 2880:         assert_equal(x.data, [2, 3, 3])
 2881:         assert_equal(x.mask, [0, 0, 1])
 2882:         # Test add w/ array
 2883:         x = array([1, 2, 3], mask=[0, 0, 1])
 2884:         xx = x + array([1, 2, 3], mask=[1, 0, 0])
 2885:         assert_equal(xx.data, [1, 4, 3])
 2886:         assert_equal(xx.mask, [1, 0, 1])
 2887:         # Test iadd w/ array
 2888:         x = array([1, 2, 3], mask=[0, 0, 1])
 2889:         x += array([1, 2, 3], mask=[1, 0, 0])
 2890:         assert_equal(x.data, [1, 4, 3])
 2891:         assert_equal(x.mask, [1, 0, 1])
 2892: 
 2893:     def test_datafriendly_sub(self):
 2894:         # Test keeping data w/ (inplace) subtraction
 2895:         # Test sub w/ scalar
 2896:         x = array([1, 2, 3], mask=[0, 0, 1])
 2897:         xx = x - 1
 2898:         assert_equal(xx.data, [0, 1, 3])
 2899:         assert_equal(xx.mask, [0, 0, 1])
 2900:         # Test isub w/ scalar
 2901:         x = array([1, 2, 3], mask=[0, 0, 1])
 2902:         x -= 1
 2903:         assert_equal(x.data, [0, 1, 3])
 2904:         assert_equal(x.mask, [0, 0, 1])
 2905:         # Test sub w/ array
 2906:         x = array([1, 2, 3], mask=[0, 0, 1])
 2907:         xx = x - array([1, 2, 3], mask=[1, 0, 0])
 2908:         assert_equal(xx.data, [1, 0, 3])
 2909:         assert_equal(xx.mask, [1, 0, 1])
 2910:         # Test isub w/ array
 2911:         x = array([1, 2, 3], mask=[0, 0, 1])
 2912:         x -= array([1, 2, 3], mask=[1, 0, 0])
 2913:         assert_equal(x.data, [1, 0, 3])
 2914:         assert_equal(x.mask, [1, 0, 1])
 2915: 
 2916:     def test_datafriendly_mul(self):
 2917:         # Test keeping data w/ (inplace) multiplication
 2918:         # Test mul w/ scalar
 2919:         x = array([1, 2, 3], mask=[0, 0, 1])
 2920:         xx = x * 2
 2921:         assert_equal(xx.data, [2, 4, 3])
 2922:         assert_equal(xx.mask, [0, 0, 1])
 2923:         # Test imul w/ scalar
 2924:         x = array([1, 2, 3], mask=[0, 0, 1])
 2925:         x *= 2
 2926:         assert_equal(x.data, [2, 4, 3])
 2927:         assert_equal(x.mask, [0, 0, 1])
 2928:         # Test mul w/ array
 2929:         x = array([1, 2, 3], mask=[0, 0, 1])
 2930:         xx = x * array([10, 20, 30], mask=[1, 0, 0])
 2931:         assert_equal(xx.data, [1, 40, 3])
 2932:         assert_equal(xx.mask, [1, 0, 1])
 2933:         # Test imul w/ array
 2934:         x = array([1, 2, 3], mask=[0, 0, 1])
 2935:         x *= array([10, 20, 30], mask=[1, 0, 0])
 2936:         assert_equal(x.data, [1, 40, 3])
 2937:         assert_equal(x.mask, [1, 0, 1])
 2938: 
 2939:     def test_datafriendly_div(self):
 2940:         # Test keeping data w/ (inplace) division
 2941:         # Test div on scalar
 2942:         x = array([1, 2, 3], mask=[0, 0, 1])
 2943:         xx = x / 2.
 2944:         assert_equal(xx.data, [1 / 2., 2 / 2., 3])
 2945:         assert_equal(xx.mask, [0, 0, 1])
 2946:         # Test idiv on scalar
 2947:         x = array([1., 2., 3.], mask=[0, 0, 1])
 2948:         x /= 2.
 2949:         assert_equal(x.data, [1 / 2., 2 / 2., 3])
 2950:         assert_equal(x.mask, [0, 0, 1])
 2951:         # Test div on array
 2952:         x = array([1., 2., 3.], mask=[0, 0, 1])
 2953:         xx = x / array([10., 20., 30.], mask=[1, 0, 0])
 2954:         assert_equal(xx.data, [1., 2. / 20., 3.])
 2955:         assert_equal(xx.mask, [1, 0, 1])
 2956:         # Test idiv on array
 2957:         x = array([1., 2., 3.], mask=[0, 0, 1])
 2958:         x /= array([10., 20., 30.], mask=[1, 0, 0])
 2959:         assert_equal(x.data, [1., 2 / 20., 3.])
 2960:         assert_equal(x.mask, [1, 0, 1])
 2961: 
 2962:     def test_datafriendly_pow(self):
 2963:         # Test keeping data w/ (inplace) power
 2964:         # Test pow on scalar
 2965:         x = array([1., 2., 3.], mask=[0, 0, 1])
 2966:         xx = x ** 2.5
 2967:         assert_equal(xx.data, [1., 2. ** 2.5, 3.])
 2968:         assert_equal(xx.mask, [0, 0, 1])
 2969:         # Test ipow on scalar
 2970:         x **= 2.5
 2971:         assert_equal(x.data, [1., 2. ** 2.5, 3])
 2972:         assert_equal(x.mask, [0, 0, 1])
 2973: 
 2974:     def test_datafriendly_add_arrays(self):
 2975:         a = array([[1, 1], [3, 3]])
 2976:         b = array([1, 1], mask=[0, 0])
 2977:         a += b
 2978:         assert_equal(a, [[2, 2], [4, 4]])
 2979:         if a.mask is not nomask:
 2980:             assert_equal(a.mask, [[0, 0], [0, 0]])
 2981: 
 2982:         a = array([[1, 1], [3, 3]])
 2983:         b = array([1, 1], mask=[0, 1])
 2984:         a += b
 2985:         assert_equal(a, [[2, 2], [4, 4]])
 2986:         assert_equal(a.mask, [[0, 1], [0, 1]])
 2987: 
 2988:     def test_datafriendly_sub_arrays(self):
 2989:         a = array([[1, 1], [3, 3]])
 2990:         b = array([1, 1], mask=[0, 0])
 2991:         a -= b
 2992:         assert_equal(a, [[0, 0], [2, 2]])
 2993:         if a.mask is not nomask:
 2994:             assert_equal(a.mask, [[0, 0], [0, 0]])
 2995: 
 2996:         a = array([[1, 1], [3, 3]])
 2997:         b = array([1, 1], mask=[0, 1])
 2998:         a -= b
 2999:         assert_equal(a, [[0, 0], [2, 2]])
 3000:         assert_equal(a.mask, [[0, 1], [0, 1]])
 3001: 
 3002:     def test_datafriendly_mul_arrays(self):
 3003:         a = array([[1, 1], [3, 3]])
 3004:         b = array([1, 1], mask=[0, 0])
 3005:         a *= b
 3006:         assert_equal(a, [[1, 1], [3, 3]])
 3007:         if a.mask is not nomask:
 3008:             assert_equal(a.mask, [[0, 0], [0, 0]])
 3009: 
 3010:         a = array([[1, 1], [3, 3]])
 3011:         b = array([1, 1], mask=[0, 1])
 3012:         a *= b
 3013:         assert_equal(a, [[1, 1], [3, 3]])
 3014:         assert_equal(a.mask, [[0, 1], [0, 1]])
 3015: 
 3016:     def test_inplace_addition_scalar_type(self):
 3017:         # Test of inplace additions
 3018:         for t in self.othertypes:
 3019:             with warnings.catch_warnings():
 3020:                 warnings.filterwarnings("error")
 3021:                 (x, y, xm) = (_.astype(t) for _ in self.uint8data)
 3022:                 xm[2] = masked
 3023:                 x += t(1)
 3024:                 assert_equal(x, y + t(1))
 3025:                 xm += t(1)
 3026:                 assert_equal(xm, y + t(1))
 3027: 
 3028:     def test_inplace_addition_array_type(self):
 3029:         # Test of inplace additions
 3030:         for t in self.othertypes:
 3031:             with warnings.catch_warnings():
 3032:                 warnings.filterwarnings("error")
 3033:                 (x, y, xm) = (_.astype(t) for _ in self.uint8data)
 3034:                 m = xm.mask
 3035:                 a = arange(10, dtype=t)
 3036:                 a[-1] = masked
 3037:                 x += a
 3038:                 xm += a
 3039:                 assert_equal(x, y + a)
 3040:                 assert_equal(xm, y + a)
 3041:                 assert_equal(xm.mask, mask_or(m, a.mask))
 3042: 
 3043:     def test_inplace_subtraction_scalar_type(self):
 3044:         # Test of inplace subtractions
 3045:         for t in self.othertypes:
 3046:             with warnings.catch_warnings():
 3047:                 warnings.filterwarnings("error")
 3048:                 (x, y, xm) = (_.astype(t) for _ in self.uint8data)
 3049:                 x -= t(1)
 3050:                 assert_equal(x, y - t(1))
 3051:                 xm -= t(1)
 3052:                 assert_equal(xm, y - t(1))
 3053: 
 3054:     def test_inplace_subtraction_array_type(self):
 3055:         # Test of inplace subtractions
 3056:         for t in self.othertypes:
 3057:             with warnings.catch_warnings():
 3058:                 warnings.filterwarnings("error")
 3059:                 (x, y, xm) = (_.astype(t) for _ in self.uint8data)
 3060:                 m = xm.mask
 3061:                 a = arange(10, dtype=t)
 3062:                 a[-1] = masked
 3063:                 x -= a
 3064:                 xm -= a
 3065:                 assert_equal(x, y - a)
 3066:                 assert_equal(xm, y - a)
 3067:                 assert_equal(xm.mask, mask_or(m, a.mask))
 3068: 
 3069:     def test_inplace_multiplication_scalar_type(self):
 3070:         # Test of inplace multiplication
 3071:         for t in self.othertypes:
 3072:             with warnings.catch_warnings():
 3073:                 warnings.filterwarnings("error")
 3074:                 (x, y, xm) = (_.astype(t) for _ in self.uint8data)
 3075:                 x *= t(2)
 3076:                 assert_equal(x, y * t(2))
 3077:                 xm *= t(2)
 3078:                 assert_equal(xm, y * t(2))
 3079: 
 3080:     def test_inplace_multiplication_array_type(self):
 3081:         # Test of inplace multiplication
 3082:         for t in self.othertypes:
 3083:             with warnings.catch_warnings():
 3084:                 warnings.filterwarnings("error")
 3085:                 (x, y, xm) = (_.astype(t) for _ in self.uint8data)
 3086:                 m = xm.mask
 3087:                 a = arange(10, dtype=t)
 3088:                 a[-1] = masked
 3089:                 x *= a
 3090:                 xm *= a
 3091:                 assert_equal(x, y * a)
 3092:                 assert_equal(xm, y * a)
 3093:                 assert_equal(xm.mask, mask_or(m, a.mask))
 3094: 
 3095:     def test_inplace_floor_division_scalar_type(self):
 3096:         # Test of inplace division
 3097:         # Check for TypeError in case of unsupported types
 3098:         unsupported = {np.dtype(t).type for t in np.typecodes["Complex"]}
 3099:         for t in self.othertypes:
 3100:             with warnings.catch_warnings():
 3101:                 warnings.filterwarnings("error")
 3102:                 (x, y, xm) = (_.astype(t) for _ in self.uint8data)
 3103:                 x = arange(10, dtype=t) * t(2)
 3104:                 xm = arange(10, dtype=t) * t(2)
 3105:                 xm[2] = masked
 3106:                 try:
 3107:                     x //= t(2)
 3108:                     xm //= t(2)
 3109:                     assert_equal(x, y)
 3110:                     assert_equal(xm, y)
 3111:                 except TypeError:
 3112:                     msg = f"Supported type {t} throwing TypeError"
 3113:                     assert t in unsupported, msg
 3114: 
 3115:     def test_inplace_floor_division_array_type(self):
 3116:         # Test of inplace division
 3117:         # Check for TypeError in case of unsupported types
 3118:         unsupported = {np.dtype(t).type for t in np.typecodes["Complex"]}
 3119:         for t in self.othertypes:
 3120:             with warnings.catch_warnings():
 3121:                 warnings.filterwarnings("error")
 3122:                 (x, y, xm) = (_.astype(t) for _ in self.uint8data)
 3123:                 m = xm.mask
 3124:                 a = arange(10, dtype=t)
 3125:                 a[-1] = masked
 3126:                 try:
 3127:                     x //= a
 3128:                     xm //= a
 3129:                     assert_equal(x, y // a)
 3130:                     assert_equal(xm, y // a)
 3131:                     assert_equal(
 3132:                         xm.mask,
 3133:                         mask_or(mask_or(m, a.mask), (a == t(0)))
 3134:                     )
 3135:                 except TypeError:
 3136:                     msg = f"Supported type {t} throwing TypeError"
 3137:                     assert t in unsupported, msg
 3138: 
 3139:     def test_inplace_division_scalar_type(self):
 3140:         # Test of inplace division
 3141:         for t in self.othertypes:
 3142:             with suppress_warnings() as sup:
 3143:                 sup.record(UserWarning)
 3144: 
 3145:                 (x, y, xm) = (_.astype(t) for _ in self.uint8data)
 3146:                 x = arange(10, dtype=t) * t(2)
 3147:                 xm = arange(10, dtype=t) * t(2)
 3148:                 xm[2] = masked
 3149: 
 3150:                 # May get a DeprecationWarning or a TypeError.
 3151:                 #
 3152:                 # This is a consequence of the fact that this is true divide
 3153:                 # and will require casting to float for calculation and
 3154:                 # casting back to the original type. This will only be raised
 3155:                 # with integers. Whether it is an error or warning is only
 3156:                 # dependent on how stringent the casting rules are.
 3157:                 #
 3158:                 # Will handle the same way.
 3159:                 try:
 3160:                     x /= t(2)
 3161:                     assert_equal(x, y)
 3162:                 except (DeprecationWarning, TypeError) as e:
 3163:                     warnings.warn(str(e), stacklevel=1)
 3164:                 try:
 3165:                     xm /= t(2)
 3166:                     assert_equal(xm, y)
 3167:                 except (DeprecationWarning, TypeError) as e:
 3168:                     warnings.warn(str(e), stacklevel=1)
 3169: 
 3170:                 if issubclass(t, np.integer):
 3171:                     assert_equal(len(sup.log), 2, f'Failed on type={t}.')
 3172:                 else:
 3173:                     assert_equal(len(sup.log), 0, f'Failed on type={t}.')
 3174: 
 3175:     def test_inplace_division_array_type(self):
 3176:         # Test of inplace division
 3177:         for t in self.othertypes:
 3178:             with suppress_warnings() as sup:
 3179:                 sup.record(UserWarning)
 3180:                 (x, y, xm) = (_.astype(t) for _ in self.uint8data)
 3181:                 m = xm.mask
 3182:                 a = arange(10, dtype=t)
 3183:                 a[-1] = masked
 3184: 
 3185:                 # May get a DeprecationWarning or a TypeError.
 3186:                 #
 3187:                 # This is a consequence of the fact that this is true divide
 3188:                 # and will require casting to float for calculation and
 3189:                 # casting back to the original type. This will only be raised
 3190:                 # with integers. Whether it is an error or warning is only
 3191:                 # dependent on how stringent the casting rules are.
 3192:                 #
 3193:                 # Will handle the same way.
 3194:                 try:
 3195:                     x /= a
 3196:                     assert_equal(x, y / a)
 3197:                 except (DeprecationWarning, TypeError) as e:
 3198:                     warnings.warn(str(e), stacklevel=1)
 3199:                 try:
 3200:                     xm /= a
 3201:                     assert_equal(xm, y / a)
 3202:                     assert_equal(
 3203:                         xm.mask,
 3204:                         mask_or(mask_or(m, a.mask), (a == t(0)))
 3205:                     )
 3206:                 except (DeprecationWarning, TypeError) as e:
 3207:                     warnings.warn(str(e), stacklevel=1)
 3208: 
 3209:                 if issubclass(t, np.integer):
 3210:                     assert_equal(len(sup.log), 2, f'Failed on type={t}.')
 3211:                 else:
 3212:                     assert_equal(len(sup.log), 0, f'Failed on type={t}.')
 3213: 
 3214:     def test_inplace_pow_type(self):
 3215:         # Test keeping data w/ (inplace) power
 3216:         for t in self.othertypes:
 3217:             with warnings.catch_warnings():
 3218:                 warnings.filterwarnings("error")
 3219:                 # Test pow on scalar
 3220:                 x = array([1, 2, 3], mask=[0, 0, 1], dtype=t)
 3221:                 xx = x ** t(2)
 3222:                 xx_r = array([1, 2 ** 2, 3], mask=[0, 0, 1], dtype=t)
 3223:                 assert_equal(xx.data, xx_r.data)
 3224:                 assert_equal(xx.mask, xx_r.mask)
 3225:                 # Test ipow on scalar
 3226:                 x **= t(2)
 3227:                 assert_equal(x.data, xx_r.data)
 3228:                 assert_equal(x.mask, xx_r.mask)
 3229: 
 3230: 
 3231: class TestMaskedArrayMethods:
 3232:     # Test class for miscellaneous MaskedArrays methods.
 3233:     def setup_method(self):
 3234:         # Base data definition.
 3235:         x = np.array([8.375, 7.545, 8.828, 8.5, 1.757, 5.928,
 3236:                       8.43, 7.78, 9.865, 5.878, 8.979, 4.732,
 3237:                       3.012, 6.022, 5.095, 3.116, 5.238, 3.957,
 3238:                       6.04, 9.63, 7.712, 3.382, 4.489, 6.479,
 3239:                       7.189, 9.645, 5.395, 4.961, 9.894, 2.893,
 3240:                       7.357, 9.828, 6.272, 3.758, 6.693, 0.993])
 3241:         X = x.reshape(6, 6)
 3242:         XX = x.reshape(3, 2, 2, 3)
 3243: 
 3244:         m = np.array([0, 1, 0, 1, 0, 0,
 3245:                      1, 0, 1, 1, 0, 1,
 3246:                      0, 0, 0, 1, 0, 1,
 3247:                      0, 0, 0, 1, 1, 1,
 3248:                      1, 0, 0, 1, 0, 0,
 3249:                      0, 0, 1, 0, 1, 0])
 3250:         mx = array(data=x, mask=m)
 3251:         mX = array(data=X, mask=m.reshape(X.shape))
 3252:         mXX = array(data=XX, mask=m.reshape(XX.shape))
 3253: 
 3254:         m2 = np.array([1, 1, 0, 1, 0, 0,
 3255:                       1, 1, 1, 1, 0, 1,
 3256:                       0, 0, 1, 1, 0, 1,
 3257:                       0, 0, 0, 1, 1, 1,
 3258:                       1, 0, 0, 1, 1, 0,
 3259:                       0, 0, 1, 0, 1, 1])
 3260:         m2x = array(data=x, mask=m2)
 3261:         m2X = array(data=X, mask=m2.reshape(X.shape))
 3262:         m2XX = array(data=XX, mask=m2.reshape(XX.shape))
 3263:         self.d = (x, X, XX, m, mx, mX, mXX, m2x, m2X, m2XX)
 3264: 
 3265:     def test_generic_methods(self):
 3266:         # Tests some MaskedArray methods.
 3267:         a = array([1, 3, 2])
 3268:         assert_equal(a.any(), a._data.any())
 3269:         assert_equal(a.all(), a._data.all())
 3270:         assert_equal(a.argmax(), a._data.argmax())
 3271:         assert_equal(a.argmin(), a._data.argmin())
 3272:         assert_equal(a.choose(0, 1, 2, 3, 4), a._data.choose(0, 1, 2, 3, 4))
 3273:         assert_equal(a.compress([1, 0, 1]), a._data.compress([1, 0, 1]))
 3274:         assert_equal(a.conj(), a._data.conj())
 3275:         assert_equal(a.conjugate(), a._data.conjugate())
 3276: 
 3277:         m = array([[1, 2], [3, 4]])
 3278:         assert_equal(m.diagonal(), m._data.diagonal())
 3279:         assert_equal(a.sum(), a._data.sum())
 3280:         assert_equal(a.take([1, 2]), a._data.take([1, 2]))
 3281:         assert_equal(m.transpose(), m._data.transpose())
 3282: 
 3283:     def test_allclose(self):
 3284:         # Tests allclose on arrays
 3285:         a = np.random.rand(10)
 3286:         b = a + np.random.rand(10) * 1e-8
 3287:         assert_(allclose(a, b))
 3288:         # Test allclose w/ infs
 3289:         a[0] = np.inf
 3290:         assert_(not allclose(a, b))
 3291:         b[0] = np.inf
 3292:         assert_(allclose(a, b))
 3293:         # Test allclose w/ masked
 3294:         a = masked_array(a)
 3295:         a[-1] = masked
 3296:         assert_(allclose(a, b, masked_equal=True))
 3297:         assert_(not allclose(a, b, masked_equal=False))
 3298:         # Test comparison w/ scalar
 3299:         a *= 1e-8
 3300:         a[0] = 0
 3301:         assert_(allclose(a, 0, masked_equal=True))
 3302: 
 3303:         # Test that the function works for MIN_INT integer typed arrays
 3304:         a = masked_array([np.iinfo(np.int_).min], dtype=np.int_)
 3305:         assert_(allclose(a, a))
 3306: 
 3307:     def test_allclose_timedelta(self):
 3308:         # Allclose currently works for timedelta64 as long as `atol` is
 3309:         # an integer or also a timedelta64
 3310:         a = np.array([[1, 2, 3, 4]], dtype="m8[ns]")
 3311:         assert allclose(a, a, atol=0)
 3312:         assert allclose(a, a, atol=np.timedelta64(1, "ns"))
 3313: 
 3314:     def test_allany(self):
 3315:         # Checks the any/all methods/functions.
 3316:         x = np.array([[0.13, 0.26, 0.90],
 3317:                       [0.28, 0.33, 0.63],
 3318:                       [0.31, 0.87, 0.70]])
 3319:         m = np.array([[True, False, False],
 3320:                       [False, False, False],
 3321:                       [True, True, False]], dtype=np.bool)
 3322:         mx = masked_array(x, mask=m)
 3323:         mxbig = (mx > 0.5)
 3324:         mxsmall = (mx < 0.5)
 3325: 
 3326:         assert_(not mxbig.all())
 3327:         assert_(mxbig.any())
 3328:         assert_equal(mxbig.all(0), [False, False, True])
 3329:         assert_equal(mxbig.all(1), [False, False, True])
 3330:         assert_equal(mxbig.any(0), [False, False, True])
 3331:         assert_equal(mxbig.any(1), [True, True, True])
 3332: 
 3333:         assert_(not mxsmall.all())
 3334:         assert_(mxsmall.any())
 3335:         assert_equal(mxsmall.all(0), [True, True, False])
 3336:         assert_equal(mxsmall.all(1), [False, False, False])
 3337:         assert_equal(mxsmall.any(0), [True, True, False])
 3338:         assert_equal(mxsmall.any(1), [True, True, False])
 3339: 
 3340:     def test_allany_oddities(self):
 3341:         # Some fun with all and any
 3342:         store = empty((), dtype=bool)
 3343:         full = array([1, 2, 3], mask=True)
 3344: 
 3345:         assert_(full.all() is masked)
 3346:         full.all(out=store)
 3347:         assert_(store)
 3348:         assert_(store._mask, True)
 3349:         assert_(store is not masked)
 3350: 
 3351:         store = empty((), dtype=bool)
 3352:         assert_(full.any() is masked)
 3353:         full.any(out=store)
 3354:         assert_(not store)
 3355:         assert_(store._mask, True)
 3356:         assert_(store is not masked)
 3357: 
 3358:     def test_argmax_argmin(self):
 3359:         # Tests argmin & argmax on MaskedArrays.
 3360:         (x, X, XX, m, mx, mX, mXX, m2x, m2X, m2XX) = self.d
 3361: 
 3362:         assert_equal(mx.argmin(), 35)
 3363:         assert_equal(mX.argmin(), 35)
 3364:         assert_equal(m2x.argmin(), 4)
 3365:         assert_equal(m2X.argmin(), 4)
 3366:         assert_equal(mx.argmax(), 28)
 3367:         assert_equal(mX.argmax(), 28)
 3368:         assert_equal(m2x.argmax(), 31)
 3369:         assert_equal(m2X.argmax(), 31)
 3370: 
 3371:         assert_equal(mX.argmin(0), [2, 2, 2, 5, 0, 5])
 3372:         assert_equal(m2X.argmin(0), [2, 2, 4, 5, 0, 4])
 3373:         assert_equal(mX.argmax(0), [0, 5, 0, 5, 4, 0])
 3374:         assert_equal(m2X.argmax(0), [5, 5, 0, 5, 1, 0])
 3375: 
 3376:         assert_equal(mX.argmin(1), [4, 1, 0, 0, 5, 5, ])
 3377:         assert_equal(m2X.argmin(1), [4, 4, 0, 0, 5, 3])
 3378:         assert_equal(mX.argmax(1), [2, 4, 1, 1, 4, 1])
 3379:         assert_equal(m2X.argmax(1), [2, 4, 1, 1, 1, 1])
 3380: 
 3381:     def test_clip(self):
 3382:         # Tests clip on MaskedArrays.
 3383:         x = np.array([8.375, 7.545, 8.828, 8.5, 1.757, 5.928,
 3384:                       8.43, 7.78, 9.865, 5.878, 8.979, 4.732,
 3385:                       3.012, 6.022, 5.095, 3.116, 5.238, 3.957,
 3386:                       6.04, 9.63, 7.712, 3.382, 4.489, 6.479,
 3387:                       7.189, 9.645, 5.395, 4.961, 9.894, 2.893,
 3388:                       7.357, 9.828, 6.272, 3.758, 6.693, 0.993])
 3389:         m = np.array([0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1,
 3390:                       0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1,
 3391:                       1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0])
 3392:         mx = array(x, mask=m)
 3393:         clipped = mx.clip(2, 8)
 3394:         assert_equal(clipped.mask, mx.mask)
 3395:         assert_equal(clipped._data, x.clip(2, 8))
 3396:         assert_equal(clipped._data, mx._data.clip(2, 8))
 3397: 
 3398:     def test_clip_out(self):
 3399:         # gh-14140
 3400:         a = np.arange(10)
 3401:         m = np.ma.MaskedArray(a, mask=[0, 1] * 5)
 3402:         m.clip(0, 5, out=m)
 3403:         assert_equal(m.mask, [0, 1] * 5)
 3404: 
 3405:     def test_compress(self):
 3406:         # test compress
 3407:         a = masked_array([1., 2., 3., 4., 5.], fill_value=9999)
 3408:         condition = (a > 1.5) & (a < 3.5)
 3409:         assert_equal(a.compress(condition), [2., 3.])
 3410: 
 3411:         a[[2, 3]] = masked
 3412:         b = a.compress(condition)
 3413:         assert_equal(b._data, [2., 3.])
 3414:         assert_equal(b._mask, [0, 1])
 3415:         assert_equal(b.fill_value, 9999)
 3416:         assert_equal(b, a[condition])
 3417: 
 3418:         condition = (a < 4.)
 3419:         b = a.compress(condition)
 3420:         assert_equal(b._data, [1., 2., 3.])
 3421:         assert_equal(b._mask, [0, 0, 1])
 3422:         assert_equal(b.fill_value, 9999)
 3423:         assert_equal(b, a[condition])
 3424: 
 3425:         a = masked_array([[10, 20, 30], [40, 50, 60]],
 3426:                          mask=[[0, 0, 1], [1, 0, 0]])
 3427:         b = a.compress(a.ravel() >= 22)
 3428:         assert_equal(b._data, [30, 40, 50, 60])
 3429:         assert_equal(b._mask, [1, 1, 0, 0])
 3430: 
 3431:         x = np.array([3, 1, 2])
 3432:         b = a.compress(x >= 2, axis=1)
 3433:         assert_equal(b._data, [[10, 30], [40, 60]])
 3434:         assert_equal(b._mask, [[0, 1], [1, 0]])
 3435: 
 3436:     def test_compressed(self):
 3437:         # Tests compressed
 3438:         a = array([1, 2, 3, 4], mask=[0, 0, 0, 0])
 3439:         b = a.compressed()
 3440:         assert_equal(b, a)
 3441:         a[0] = masked
 3442:         b = a.compressed()
 3443:         assert_equal(b, [2, 3, 4])
 3444: 
 3445:     def test_empty(self):
 3446:         # Tests empty/like
 3447:         datatype = [('a', int), ('b', float), ('c', '|S8')]
 3448:         a = masked_array([(1, 1.1, '1.1'), (2, 2.2, '2.2'), (3, 3.3, '3.3')],
 3449:                          dtype=datatype)
 3450:         assert_equal(len(a.fill_value.item()), len(datatype))
 3451: 
 3452:         b = empty_like(a)
 3453:         assert_equal(b.shape, a.shape)
 3454:         assert_equal(b.fill_value, a.fill_value)
 3455: 
 3456:         b = empty(len(a), dtype=datatype)
 3457:         assert_equal(b.shape, a.shape)
 3458:         assert_equal(b.fill_value, a.fill_value)
 3459: 
 3460:         # check empty_like mask handling
 3461:         a = masked_array([1, 2, 3], mask=[False, True, False])
 3462:         b = empty_like(a)
 3463:         assert_(not np.may_share_memory(a.mask, b.mask))
 3464:         b = a.view(masked_array)
 3465:         assert_(np.may_share_memory(a.mask, b.mask))
 3466: 
 3467:     def test_zeros(self):
 3468:         # Tests zeros/like
 3469:         datatype = [('a', int), ('b', float), ('c', '|S8')]
 3470:         a = masked_array([(1, 1.1, '1.1'), (2, 2.2, '2.2'), (3, 3.3, '3.3')],
 3471:                          dtype=datatype)
 3472:         assert_equal(len(a.fill_value.item()), len(datatype))
 3473: 
 3474:         b = zeros(len(a), dtype=datatype)
 3475:         assert_equal(b.shape, a.shape)
 3476:         assert_equal(b.fill_value, a.fill_value)
 3477: 
 3478:         b = zeros_like(a)
 3479:         assert_equal(b.shape, a.shape)
 3480:         assert_equal(b.fill_value, a.fill_value)
 3481: 
 3482:         # check zeros_like mask handling
 3483:         a = masked_array([1, 2, 3], mask=[False, True, False])
 3484:         b = zeros_like(a)
 3485:         assert_(not np.may_share_memory(a.mask, b.mask))
 3486:         b = a.view()
 3487:         assert_(np.may_share_memory(a.mask, b.mask))
 3488: 
 3489:     def test_ones(self):
 3490:         # Tests ones/like
 3491:         datatype = [('a', int), ('b', float), ('c', '|S8')]
 3492:         a = masked_array([(1, 1.1, '1.1'), (2, 2.2, '2.2'), (3, 3.3, '3.3')],
 3493:                          dtype=datatype)
 3494:         assert_equal(len(a.fill_value.item()), len(datatype))
 3495: 
 3496:         b = ones(len(a), dtype=datatype)
 3497:         assert_equal(b.shape, a.shape)
 3498:         assert_equal(b.fill_value, a.fill_value)
 3499: 
 3500:         b = ones_like(a)
 3501:         assert_equal(b.shape, a.shape)
 3502:         assert_equal(b.fill_value, a.fill_value)
 3503: 
 3504:         # check ones_like mask handling
 3505:         a = masked_array([1, 2, 3], mask=[False, True, False])
 3506:         b = ones_like(a)
 3507:         assert_(not np.may_share_memory(a.mask, b.mask))
 3508:         b = a.view()
 3509:         assert_(np.may_share_memory(a.mask, b.mask))
 3510: 
 3511:     @suppress_copy_mask_on_assignment
 3512:     def test_put(self):
 3513:         # Tests put.
 3514:         d = arange(5)
 3515:         n = [0, 0, 0, 1, 1]
 3516:         m = make_mask(n)
 3517:         x = array(d, mask=m)
 3518:         assert_(x[3] is masked)
 3519:         assert_(x[4] is masked)
 3520:         x[[1, 4]] = [10, 40]
 3521:         assert_(x[3] is masked)
 3522:         assert_(x[4] is not masked)
 3523:         assert_equal(x, [0, 10, 2, -1, 40])
 3524: 
 3525:         x = masked_array(arange(10), mask=[1, 0, 0, 0, 0] * 2)
 3526:         i = [0, 2, 4, 6]
 3527:         x.put(i, [6, 4, 2, 0])
 3528:         assert_equal(x, asarray([6, 1, 4, 3, 2, 5, 0, 7, 8, 9, ]))
 3529:         assert_equal(x.mask, [0, 0, 0, 0, 0, 1, 0, 0, 0, 0])
 3530:         x.put(i, masked_array([0, 2, 4, 6], [1, 0, 1, 0]))
 3531:         assert_array_equal(x, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ])
 3532:         assert_equal(x.mask, [1, 0, 0, 0, 1, 1, 0, 0, 0, 0])
 3533: 
 3534:         x = masked_array(arange(10), mask=[1, 0, 0, 0, 0] * 2)
 3535:         put(x, i, [6, 4, 2, 0])
 3536:         assert_equal(x, asarray([6, 1, 4, 3, 2, 5, 0, 7, 8, 9, ]))
 3537:         assert_equal(x.mask, [0, 0, 0, 0, 0, 1, 0, 0, 0, 0])
 3538:         put(x, i, masked_array([0, 2, 4, 6], [1, 0, 1, 0]))
 3539:         assert_array_equal(x, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ])
 3540:         assert_equal(x.mask, [1, 0, 0, 0, 1, 1, 0, 0, 0, 0])
 3541: 
 3542:     def test_put_nomask(self):
 3543:         # GitHub issue 6425
 3544:         x = zeros(10)
 3545:         z = array([3., -1.], mask=[False, True])
 3546: 
 3547:         x.put([1, 2], z)
 3548:         assert_(x[0] is not masked)
 3549:         assert_equal(x[0], 0)
 3550:         assert_(x[1] is not masked)
 3551:         assert_equal(x[1], 3)
 3552:         assert_(x[2] is masked)
 3553:         assert_(x[3] is not masked)
 3554:         assert_equal(x[3], 0)
 3555: 
 3556:     def test_put_hardmask(self):
 3557:         # Tests put on hardmask
 3558:         d = arange(5)
 3559:         n = [0, 0, 0, 1, 1]
 3560:         m = make_mask(n)
 3561:         xh = array(d + 1, mask=m, hard_mask=True, copy=True)
 3562:         xh.put([4, 2, 0, 1, 3], [1, 2, 3, 4, 5])
 3563:         assert_equal(xh._data, [3, 4, 2, 4, 5])
 3564: 
 3565:     def test_putmask(self):
 3566:         x = arange(6) + 1
 3567:         mx = array(x, mask=[0, 0, 0, 1, 1, 1])
 3568:         mask = [0, 0, 1, 0, 0, 1]
 3569:         # w/o mask, w/o masked values
 3570:         xx = x.copy()
 3571:         putmask(xx, mask, 99)
 3572:         assert_equal(xx, [1, 2, 99, 4, 5, 99])
 3573:         # w/ mask, w/o masked values
 3574:         mxx = mx.copy()
 3575:         putmask(mxx, mask, 99)
 3576:         assert_equal(mxx._data, [1, 2, 99, 4, 5, 99])
 3577:         assert_equal(mxx._mask, [0, 0, 0, 1, 1, 0])
 3578:         # w/o mask, w/ masked values
 3579:         values = array([10, 20, 30, 40, 50, 60], mask=[1, 1, 1, 0, 0, 0])
 3580:         xx = x.copy()
 3581:         putmask(xx, mask, values)
 3582:         assert_equal(xx._data, [1, 2, 30, 4, 5, 60])
 3583:         assert_equal(xx._mask, [0, 0, 1, 0, 0, 0])
 3584:         # w/ mask, w/ masked values
 3585:         mxx = mx.copy()
 3586:         putmask(mxx, mask, values)
 3587:         assert_equal(mxx._data, [1, 2, 30, 4, 5, 60])
 3588:         assert_equal(mxx._mask, [0, 0, 1, 1, 1, 0])
 3589:         # w/ mask, w/ masked values + hardmask
 3590:         mxx = mx.copy()
 3591:         mxx.harden_mask()
 3592:         putmask(mxx, mask, values)
 3593:         assert_equal(mxx, [1, 2, 30, 4, 5, 60])
 3594: 
 3595:     def test_ravel(self):
 3596:         # Tests ravel
 3597:         a = array([[1, 2, 3, 4, 5]], mask=[[0, 1, 0, 0, 0]])
 3598:         aravel = a.ravel()
 3599:         assert_equal(aravel._mask.shape, aravel.shape)
 3600:         a = array([0, 0], mask=[1, 1])
 3601:         aravel = a.ravel()
 3602:         assert_equal(aravel._mask.shape, a.shape)
 3603:         # Checks that small_mask is preserved
 3604:         a = array([1, 2, 3, 4], mask=[0, 0, 0, 0], shrink=False)
 3605:         assert_equal(a.ravel()._mask, [0, 0, 0, 0])
 3606:         # Test that the fill_value is preserved
 3607:         a.fill_value = -99
 3608:         a.shape = (2, 2)
 3609:         ar = a.ravel()
 3610:         assert_equal(ar._mask, [0, 0, 0, 0])
 3611:         assert_equal(ar._data, [1, 2, 3, 4])
 3612:         assert_equal(ar.fill_value, -99)
 3613:         # Test index ordering
 3614:         assert_equal(a.ravel(order='C'), [1, 2, 3, 4])
 3615:         assert_equal(a.ravel(order='F'), [1, 3, 2, 4])
 3616: 
 3617:     @pytest.mark.parametrize("order", "AKCF")
 3618:     @pytest.mark.parametrize("data_order", "CF")
 3619:     def test_ravel_order(self, order, data_order):
 3620:         # Ravelling must ravel mask and data in the same order always to avoid
 3621:         # misaligning the two in the ravel result.
 3622:         arr = np.ones((5, 10), order=data_order)
 3623:         arr[0, :] = 0
 3624:         mask = np.ones((10, 5), dtype=bool, order=data_order).T
 3625:         mask[0, :] = False
 3626:         x = array(arr, mask=mask)
 3627:         assert x._data.flags.fnc != x._mask.flags.fnc
 3628:         assert (x.filled(0) == 0).all()
 3629:         raveled = x.ravel(order)
 3630:         assert (raveled.filled(0) == 0).all()
 3631: 
 3632:         # NOTE: Can be wrong if arr order is neither C nor F and `order="K"`
 3633:         assert_array_equal(arr.ravel(order), x.ravel(order)._data)
 3634: 
 3635:     def test_reshape(self):
 3636:         # Tests reshape
 3637:         x = arange(4)
 3638:         x[0] = masked
 3639:         y = x.reshape(2, 2)
 3640:         assert_equal(y.shape, (2, 2,))
 3641:         assert_equal(y._mask.shape, (2, 2,))
 3642:         assert_equal(x.shape, (4,))
 3643:         assert_equal(x._mask.shape, (4,))
 3644: 
 3645:     def test_sort(self):
 3646:         # Test sort
 3647:         x = array([1, 4, 2, 3], mask=[0, 1, 0, 0], dtype=np.uint8)
 3648: 
 3649:         sortedx = sort(x)
 3650:         assert_equal(sortedx._data, [1, 2, 3, 4])
 3651:         assert_equal(sortedx._mask, [0, 0, 0, 1])
 3652: 
 3653:         sortedx = sort(x, endwith=False)
 3654:         assert_equal(sortedx._data, [4, 1, 2, 3])
 3655:         assert_equal(sortedx._mask, [1, 0, 0, 0])
 3656: 
 3657:         x.sort()
 3658:         assert_equal(x._data, [1, 2, 3, 4])
 3659:         assert_equal(x._mask, [0, 0, 0, 1])
 3660: 
 3661:         x = array([1, 4, 2, 3], mask=[0, 1, 0, 0], dtype=np.uint8)
 3662:         x.sort(endwith=False)
 3663:         assert_equal(x._data, [4, 1, 2, 3])
 3664:         assert_equal(x._mask, [1, 0, 0, 0])
 3665: 
 3666:         x = [1, 4, 2, 3]
 3667:         sortedx = sort(x)
 3668:         assert_(not isinstance(sorted, MaskedArray))
 3669: 
 3670:         x = array([0, 1, -1, -2, 2], mask=nomask, dtype=np.int8)
 3671:         sortedx = sort(x, endwith=False)
 3672:         assert_equal(sortedx._data, [-2, -1, 0, 1, 2])
 3673:         x = array([0, 1, -1, -2, 2], mask=[0, 1, 0, 0, 1], dtype=np.int8)
 3674:         sortedx = sort(x, endwith=False)
 3675:         assert_equal(sortedx._data, [1, 2, -2, -1, 0])
 3676:         assert_equal(sortedx._mask, [1, 1, 0, 0, 0])
 3677: 
 3678:         x = array([0, -1], dtype=np.int8)
 3679:         sortedx = sort(x, kind="stable")
 3680:         assert_equal(sortedx, array([-1, 0], dtype=np.int8))
 3681: 
 3682:     def test_stable_sort(self):
 3683:         x = array([1, 2, 3, 1, 2, 3], dtype=np.uint8)
 3684:         expected = array([0, 3, 1, 4, 2, 5])
 3685:         computed = argsort(x, kind='stable')
 3686:         assert_equal(computed, expected)
 3687: 
 3688:     def test_argsort_matches_sort(self):
 3689:         x = array([1, 4, 2, 3], mask=[0, 1, 0, 0], dtype=np.uint8)
 3690: 
 3691:         for kwargs in [{},
 3692:                        {"endwith": True},
 3693:                        {"endwith": False},
 3694:                        {"fill_value": 2},
 3695:                        {"fill_value": 2, "endwith": True},
 3696:                        {"fill_value": 2, "endwith": False}]:
 3697:             sortedx = sort(x, **kwargs)
 3698:             argsortedx = x[argsort(x, **kwargs)]
 3699:             assert_equal(sortedx._data, argsortedx._data)
 3700:             assert_equal(sortedx._mask, argsortedx._mask)
 3701: 
 3702:     def test_sort_2d(self):
 3703:         # Check sort of 2D array.
 3704:         # 2D array w/o mask
 3705:         a = masked_array([[8, 4, 1], [2, 0, 9]])
 3706:         a.sort(0)
 3707:         assert_equal(a, [[2, 0, 1], [8, 4, 9]])
 3708:         a = masked_array([[8, 4, 1], [2, 0, 9]])
 3709:         a.sort(1)
 3710:         assert_equal(a, [[1, 4, 8], [0, 2, 9]])
 3711:         # 2D array w/mask
 3712:         a = masked_array([[8, 4, 1], [2, 0, 9]], mask=[[1, 0, 0], [0, 0, 1]])
 3713:         a.sort(0)
 3714:         assert_equal(a, [[2, 0, 1], [8, 4, 9]])
 3715:         assert_equal(a._mask, [[0, 0, 0], [1, 0, 1]])
 3716:         a = masked_array([[8, 4, 1], [2, 0, 9]], mask=[[1, 0, 0], [0, 0, 1]])
 3717:         a.sort(1)
 3718:         assert_equal(a, [[1, 4, 8], [0, 2, 9]])
 3719:         assert_equal(a._mask, [[0, 0, 1], [0, 0, 1]])
 3720:         # 3D
 3721:         a = masked_array([[[7, 8, 9], [4, 5, 6], [1, 2, 3]],
 3722:                           [[1, 2, 3], [7, 8, 9], [4, 5, 6]],
 3723:                           [[7, 8, 9], [1, 2, 3], [4, 5, 6]],
 3724:                           [[4, 5, 6], [1, 2, 3], [7, 8, 9]]])
 3725:         a[a % 4 == 0] = masked
 3726:         am = a.copy()
 3727:         an = a.filled(99)
 3728:         am.sort(0)
 3729:         an.sort(0)
 3730:         assert_equal(am, an)
 3731:         am = a.copy()
 3732:         an = a.filled(99)
 3733:         am.sort(1)
 3734:         an.sort(1)
 3735:         assert_equal(am, an)
 3736:         am = a.copy()
 3737:         an = a.filled(99)
 3738:         am.sort(2)
 3739:         an.sort(2)
 3740:         assert_equal(am, an)
 3741: 
 3742:     def test_sort_flexible(self):
 3743:         # Test sort on structured dtype.
 3744:         a = array(
 3745:             data=[(3, 3), (3, 2), (2, 2), (2, 1), (1, 0), (1, 1), (1, 2)],
 3746:             mask=[(0, 0), (0, 1), (0, 0), (0, 0), (1, 0), (0, 0), (0, 0)],
 3747:             dtype=[('A', int), ('B', int)])
 3748:         mask_last = array(
 3749:             data=[(1, 1), (1, 2), (2, 1), (2, 2), (3, 3), (3, 2), (1, 0)],
 3750:             mask=[(0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 1), (1, 0)],
 3751:             dtype=[('A', int), ('B', int)])
 3752:         mask_first = array(
 3753:             data=[(1, 0), (1, 1), (1, 2), (2, 1), (2, 2), (3, 2), (3, 3)],
 3754:             mask=[(1, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 1), (0, 0)],
 3755:             dtype=[('A', int), ('B', int)])
 3756: 
 3757:         test = sort(a)
 3758:         assert_equal(test, mask_last)
 3759:         assert_equal(test.mask, mask_last.mask)
 3760: 
 3761:         test = sort(a, endwith=False)
 3762:         assert_equal(test, mask_first)
 3763:         assert_equal(test.mask, mask_first.mask)
 3764: 
 3765:         # Test sort on dtype with subarray (gh-8069)
 3766:         # Just check that the sort does not error, structured array subarrays
 3767:         # are treated as byte strings and that leads to differing behavior
 3768:         # depending on endianness and `endwith`.
 3769:         dt = np.dtype([('v', int, 2)])
 3770:         a = a.view(dt)
 3771:         test = sort(a)
 3772:         test = sort(a, endwith=False)
 3773: 
 3774:     def test_argsort(self):
 3775:         # Test argsort
 3776:         a = array([1, 5, 2, 4, 3], mask=[1, 0, 0, 1, 0])
 3777:         assert_equal(np.argsort(a), argsort(a))
 3778: 
 3779:     def test_squeeze(self):
 3780:         # Check squeeze
 3781:         data = masked_array([[1, 2, 3]])
 3782:         assert_equal(data.squeeze(), [1, 2, 3])
 3783:         data = masked_array([[1, 2, 3]], mask=[[1, 1, 1]])
 3784:         assert_equal(data.squeeze(), [1, 2, 3])
 3785:         assert_equal(data.squeeze()._mask, [1, 1, 1])
 3786: 
 3787:         # normal ndarrays return a view
 3788:         arr = np.array([[1]])
 3789:         arr_sq = arr.squeeze()
 3790:         assert_equal(arr_sq, 1)
 3791:         arr_sq[...] = 2
 3792:         assert_equal(arr[0, 0], 2)
 3793: 
 3794:         # so maskedarrays should too
 3795:         m_arr = masked_array([[1]], mask=True)
 3796:         m_arr_sq = m_arr.squeeze()
 3797:         assert_(m_arr_sq is not np.ma.masked)
 3798:         assert_equal(m_arr_sq.mask, True)
 3799:         m_arr_sq[...] = 2
 3800:         assert_equal(m_arr[0, 0], 2)
 3801: 
 3802:     def test_swapaxes(self):
 3803:         # Tests swapaxes on MaskedArrays.
 3804:         x = np.array([8.375, 7.545, 8.828, 8.5, 1.757, 5.928,
 3805:                       8.43, 7.78, 9.865, 5.878, 8.979, 4.732,
 3806:                       3.012, 6.022, 5.095, 3.116, 5.238, 3.957,
 3807:                       6.04, 9.63, 7.712, 3.382, 4.489, 6.479,
 3808:                       7.189, 9.645, 5.395, 4.961, 9.894, 2.893,
 3809:                       7.357, 9.828, 6.272, 3.758, 6.693, 0.993])
 3810:         m = np.array([0, 1, 0, 1, 0, 0,
 3811:                       1, 0, 1, 1, 0, 1,
 3812:                       0, 0, 0, 1, 0, 1,
 3813:                       0, 0, 0, 1, 1, 1,
 3814:                       1, 0, 0, 1, 0, 0,
 3815:                       0, 0, 1, 0, 1, 0])
 3816:         mX = array(x, mask=m).reshape(6, 6)
 3817:         mXX = mX.reshape(3, 2, 2, 3)
 3818: 
 3819:         mXswapped = mX.swapaxes(0, 1)
 3820:         assert_equal(mXswapped[-1], mX[:, -1])
 3821: 
 3822:         mXXswapped = mXX.swapaxes(0, 2)
 3823:         assert_equal(mXXswapped.shape, (2, 2, 3, 3))
 3824: 
 3825:     def test_take(self):
 3826:         # Tests take
 3827:         x = masked_array([10, 20, 30, 40], [0, 1, 0, 1])
 3828:         assert_equal(x.take([0, 0, 3]), masked_array([10, 10, 40], [0, 0, 1]))
 3829:         assert_equal(x.take([0, 0, 3]), x[[0, 0, 3]])
 3830:         assert_equal(x.take([[0, 1], [0, 1]]),
 3831:                      masked_array([[10, 20], [10, 20]], [[0, 1], [0, 1]]))
 3832: 
 3833:         # assert_equal crashes when passed np.ma.mask
 3834:         assert_(x[1] is np.ma.masked)
 3835:         assert_(x.take(1) is np.ma.masked)
 3836: 
 3837:         x = array([[10, 20, 30], [40, 50, 60]], mask=[[0, 0, 1], [1, 0, 0, ]])
 3838:         assert_equal(x.take([0, 2], axis=1),
 3839:                      array([[10, 30], [40, 60]], mask=[[0, 1], [1, 0]]))
 3840:         assert_equal(take(x, [0, 2], axis=1),
 3841:                      array([[10, 30], [40, 60]], mask=[[0, 1], [1, 0]]))
 3842: 
 3843:     def test_take_masked_indices(self):
 3844:         # Test take w/ masked indices
 3845:         a = np.array((40, 18, 37, 9, 22))
 3846:         indices = np.arange(3)[None, :] + np.arange(5)[:, None]
 3847:         mindices = array(indices, mask=(indices >= len(a)))
 3848:         # No mask
 3849:         test = take(a, mindices, mode='clip')
 3850:         ctrl = array([[40, 18, 37],
 3851:                       [18, 37, 9],
 3852:                       [37, 9, 22],
 3853:                       [9, 22, 22],
 3854:                       [22, 22, 22]])
 3855:         assert_equal(test, ctrl)
 3856:         # Masked indices
 3857:         test = take(a, mindices)
 3858:         ctrl = array([[40, 18, 37],
 3859:                       [18, 37, 9],
 3860:                       [37, 9, 22],
 3861:                       [9, 22, 40],
 3862:                       [22, 40, 40]])
 3863:         ctrl[3, 2] = ctrl[4, 1] = ctrl[4, 2] = masked
 3864:         assert_equal(test, ctrl)
 3865:         assert_equal(test.mask, ctrl.mask)
 3866:         # Masked input + masked indices
 3867:         a = array((40, 18, 37, 9, 22), mask=(0, 1, 0, 0, 0))
 3868:         test = take(a, mindices)
 3869:         ctrl[0, 1] = ctrl[1, 0] = masked
 3870:         assert_equal(test, ctrl)
 3871:         assert_equal(test.mask, ctrl.mask)
 3872: 
 3873:     def test_tolist(self):
 3874:         # Tests to list
 3875:         # ... on 1D
 3876:         x = array(np.arange(12))
 3877:         x[[1, -2]] = masked
 3878:         xlist = x.tolist()
 3879:         assert_(xlist[1] is None)
 3880:         assert_(xlist[-2] is None)
 3881:         # ... on 2D
 3882:         x.shape = (3, 4)
 3883:         xlist = x.tolist()
 3884:         ctrl = [[0, None, 2, 3], [4, 5, 6, 7], [8, 9, None, 11]]
 3885:         assert_equal(xlist[0], [0, None, 2, 3])
 3886:         assert_equal(xlist[1], [4, 5, 6, 7])
 3887:         assert_equal(xlist[2], [8, 9, None, 11])
 3888:         assert_equal(xlist, ctrl)
 3889:         # ... on structured array w/ masked records
 3890:         x = array(list(zip([1, 2, 3],
 3891:                            [1.1, 2.2, 3.3],
 3892:                            ['one', 'two', 'thr'])),
 3893:                   dtype=[('a', int), ('b', float), ('c', '|S8')])
 3894:         x[-1] = masked
 3895:         assert_equal(x.tolist(),
 3896:                      [(1, 1.1, b'one'),
 3897:                       (2, 2.2, b'two'),
 3898:                       (None, None, None)])
 3899:         # ... on structured array w/ masked fields
 3900:         a = array([(1, 2,), (3, 4)], mask=[(0, 1), (0, 0)],
 3901:                   dtype=[('a', int), ('b', int)])
 3902:         test = a.tolist()
 3903:         assert_equal(test, [[1, None], [3, 4]])
 3904:         # ... on mvoid
 3905:         a = a[0]
 3906:         test = a.tolist()
 3907:         assert_equal(test, [1, None])
 3908: 
 3909:     def test_tolist_specialcase(self):
 3910:         # Test mvoid.tolist: make sure we return a standard Python object
 3911:         a = array([(0, 1), (2, 3)], dtype=[('a', int), ('b', int)])
 3912:         # w/o mask: each entry is a np.void whose elements are standard Python
 3913:         for entry in a:
 3914:             for item in entry.tolist():
 3915:                 assert_(not isinstance(item, np.generic))
 3916:         # w/ mask: each entry is a ma.void whose elements should be
 3917:         # standard Python
 3918:         a.mask[0] = (0, 1)
 3919:         for entry in a:
 3920:             for item in entry.tolist():
 3921:                 assert_(not isinstance(item, np.generic))
 3922: 
 3923:     def test_toflex(self):
 3924:         # Test the conversion to records
 3925:         data = arange(10)
 3926:         record = data.toflex()
 3927:         assert_equal(record['_data'], data._data)
 3928:         assert_equal(record['_mask'], data._mask)
 3929: 
 3930:         data[[0, 1, 2, -1]] = masked
 3931:         record = data.toflex()
 3932:         assert_equal(record['_data'], data._data)
 3933:         assert_equal(record['_mask'], data._mask)
 3934: 
 3935:         ndtype = [('i', int), ('s', '|S3'), ('f', float)]
 3936:         data = array(list(zip(np.arange(10),
 3937:                               'ABCDEFGHIJKLM',
 3938:                               np.random.rand(10))),
 3939:                      dtype=ndtype)
 3940:         data[[0, 1, 2, -1]] = masked
 3941:         record = data.toflex()
 3942:         assert_equal(record['_data'], data._data)
 3943:         assert_equal(record['_mask'], data._mask)
 3944: 
 3945:         ndtype = np.dtype("int, (2,3)float, float")
 3946:         data = array(list(zip(np.arange(10),
 3947:                               np.random.rand(10),
 3948:                               np.random.rand(10))),
 3949:                      dtype=ndtype)
 3950:         data[[0, 1, 2, -1]] = masked
 3951:         record = data.toflex()
 3952:         assert_equal_records(record['_data'], data._data)
 3953:         assert_equal_records(record['_mask'], data._mask)
 3954: 
 3955:     def test_fromflex(self):
 3956:         # Test the reconstruction of a masked_array from a record
 3957:         a = array([1, 2, 3])
 3958:         test = fromflex(a.toflex())
 3959:         assert_equal(test, a)
 3960:         assert_equal(test.mask, a.mask)
 3961: 
 3962:         a = array([1, 2, 3], mask=[0, 0, 1])
 3963:         test = fromflex(a.toflex())
 3964:         assert_equal(test, a)
 3965:         assert_equal(test.mask, a.mask)
 3966: 
 3967:         a = array([(1, 1.), (2, 2.), (3, 3.)], mask=[(1, 0), (0, 0), (0, 1)],
 3968:                   dtype=[('A', int), ('B', float)])
 3969:         test = fromflex(a.toflex())
 3970:         assert_equal(test, a)
 3971:         assert_equal(test.data, a.data)
 3972: 
 3973:     def test_arraymethod(self):
 3974:         # Test a _arraymethod w/ n argument
 3975:         marray = masked_array([[1, 2, 3, 4, 5]], mask=[0, 0, 1, 0, 0])
 3976:         control = masked_array([[1], [2], [3], [4], [5]],
 3977:                                mask=[0, 0, 1, 0, 0])
 3978:         assert_equal(marray.T, control)
 3979:         assert_equal(marray.transpose(), control)
 3980: 
 3981:         assert_equal(MaskedArray.cumsum(marray.T, 0), control.cumsum(0))
 3982: 
 3983:     def test_arraymethod_0d(self):
 3984:         # gh-9430
 3985:         x = np.ma.array(42, mask=True)
 3986:         assert_equal(x.T.mask, x.mask)
 3987:         assert_equal(x.T.data, x.data)
 3988: 
 3989:     def test_transpose_view(self):
 3990:         x = np.ma.array([[1, 2, 3], [4, 5, 6]])
 3991:         x[0, 1] = np.ma.masked
 3992:         xt = x.T
 3993: 
 3994:         xt[1, 0] = 10
 3995:         xt[0, 1] = np.ma.masked
 3996: 
 3997:         assert_equal(x.data, xt.T.data)
 3998:         assert_equal(x.mask, xt.T.mask)
 3999: 
 4000:     def test_diagonal_view(self):
 4001:         x = np.ma.zeros((3, 3))
 4002:         x[0, 0] = 10
 4003:         x[1, 1] = np.ma.masked
 4004:         x[2, 2] = 20
 4005:         xd = x.diagonal()
 4006:         x[1, 1] = 15
 4007:         assert_equal(xd.mask, x.diagonal().mask)
 4008:         assert_equal(xd.data, x.diagonal().data)
 4009: 
 4010: 
 4011: class TestMaskedArrayMathMethods:
 4012: 
 4013:     def setup_method(self):
 4014:         # Base data definition.
 4015:         x = np.array([8.375, 7.545, 8.828, 8.5, 1.757, 5.928,
 4016:                       8.43, 7.78, 9.865, 5.878, 8.979, 4.732,
 4017:                       3.012, 6.022, 5.095, 3.116, 5.238, 3.957,
 4018:                       6.04, 9.63, 7.712, 3.382, 4.489, 6.479,
 4019:                       7.189, 9.645, 5.395, 4.961, 9.894, 2.893,
 4020:                       7.357, 9.828, 6.272, 3.758, 6.693, 0.993])
 4021:         X = x.reshape(6, 6)
 4022:         XX = x.reshape(3, 2, 2, 3)
 4023: 
 4024:         m = np.array([0, 1, 0, 1, 0, 0,
 4025:                      1, 0, 1, 1, 0, 1,
 4026:                      0, 0, 0, 1, 0, 1,
 4027:                      0, 0, 0, 1, 1, 1,
 4028:                      1, 0, 0, 1, 0, 0,
 4029:                      0, 0, 1, 0, 1, 0])
 4030:         mx = array(data=x, mask=m)
 4031:         mX = array(data=X, mask=m.reshape(X.shape))
 4032:         mXX = array(data=XX, mask=m.reshape(XX.shape))
 4033: 
 4034:         m2 = np.array([1, 1, 0, 1, 0, 0,
 4035:                       1, 1, 1, 1, 0, 1,
 4036:                       0, 0, 1, 1, 0, 1,
 4037:                       0, 0, 0, 1, 1, 1,
 4038:                       1, 0, 0, 1, 1, 0,
 4039:                       0, 0, 1, 0, 1, 1])
 4040:         m2x = array(data=x, mask=m2)
 4041:         m2X = array(data=X, mask=m2.reshape(X.shape))
 4042:         m2XX = array(data=XX, mask=m2.reshape(XX.shape))
 4043:         self.d = (x, X, XX, m, mx, mX, mXX, m2x, m2X, m2XX)
 4044: 
 4045:     def test_cumsumprod(self):
 4046:         # Tests cumsum & cumprod on MaskedArrays.
 4047:         (x, X, XX, m, mx, mX, mXX, m2x, m2X, m2XX) = self.d
 4048:         mXcp = mX.cumsum(0)
 4049:         assert_equal(mXcp._data, mX.filled(0).cumsum(0))
 4050:         mXcp = mX.cumsum(1)
 4051:         assert_equal(mXcp._data, mX.filled(0).cumsum(1))
 4052: 
 4053:         mXcp = mX.cumprod(0)
 4054:         assert_equal(mXcp._data, mX.filled(1).cumprod(0))
 4055:         mXcp = mX.cumprod(1)
 4056:         assert_equal(mXcp._data, mX.filled(1).cumprod(1))
 4057: 
 4058:     def test_cumsumprod_with_output(self):
 4059:         # Tests cumsum/cumprod w/ output
 4060:         xm = array(np.random.uniform(0, 10, 12)).reshape(3, 4)
 4061:         xm[:, 0] = xm[0] = xm[-1, -1] = masked
 4062: 
 4063:         for funcname in ('cumsum', 'cumprod'):
 4064:             npfunc = getattr(np, funcname)
 4065:             xmmeth = getattr(xm, funcname)
 4066: 
 4067:             # A ndarray as explicit input
 4068:             output = np.empty((3, 4), dtype=float)
 4069:             output.fill(-9999)
 4070:             result = npfunc(xm, axis=0, out=output)
 4071:             # ... the result should be the given output
 4072:             assert_(result is output)
 4073:             assert_equal(result, xmmeth(axis=0, out=output))
 4074: 
 4075:             output = empty((3, 4), dtype=int)
 4076:             result = xmmeth(axis=0, out=output)
 4077:             assert_(result is output)
 4078: 
 4079:     def test_ptp(self):
 4080:         # Tests ptp on MaskedArrays.
 4081:         (x, X, XX, m, mx, mX, mXX, m2x, m2X, m2XX) = self.d
 4082:         (n, m) = X.shape
 4083:         assert_equal(mx.ptp(), np.ptp(mx.compressed()))
 4084:         rows = np.zeros(n, float)
 4085:         cols = np.zeros(m, float)
 4086:         for k in range(m):
 4087:             cols[k] = np.ptp(mX[:, k].compressed())
 4088:         for k in range(n):
 4089:             rows[k] = np.ptp(mX[k].compressed())
 4090:         assert_equal(mX.ptp(0), cols)
 4091:         assert_equal(mX.ptp(1), rows)
 4092: 
 4093:     def test_add_object(self):
 4094:         x = masked_array(['a', 'b'], mask=[1, 0], dtype=object)
 4095:         y = x + 'x'
 4096:         assert_equal(y[1], 'bx')
 4097:         assert_(y.mask[0])
 4098: 
 4099:     def test_sum_object(self):
 4100:         # Test sum on object dtype
 4101:         a = masked_array([1, 2, 3], mask=[1, 0, 0], dtype=object)
 4102:         assert_equal(a.sum(), 5)
 4103:         a = masked_array([[1, 2, 3], [4, 5, 6]], dtype=object)
 4104:         assert_equal(a.sum(axis=0), [5, 7, 9])
 4105: 
 4106:     def test_prod_object(self):
 4107:         # Test prod on object dtype
 4108:         a = masked_array([1, 2, 3], mask=[1, 0, 0], dtype=object)
 4109:         assert_equal(a.prod(), 2 * 3)
 4110:         a = masked_array([[1, 2, 3], [4, 5, 6]], dtype=object)
 4111:         assert_equal(a.prod(axis=0), [4, 10, 18])
 4112: 
 4113:     def test_meananom_object(self):
 4114:         # Test mean/anom on object dtype
 4115:         a = masked_array([1, 2, 3], dtype=object)
 4116:         assert_equal(a.mean(), 2)
 4117:         assert_equal(a.anom(), [-1, 0, 1])
 4118: 
 4119:     def test_anom_shape(self):
 4120:         a = masked_array([1, 2, 3])
 4121:         assert_equal(a.anom().shape, a.shape)
 4122:         a.mask = True
 4123:         assert_equal(a.anom().shape, a.shape)
 4124:         assert_(np.ma.is_masked(a.anom()))
 4125: 
 4126:     def test_anom(self):
 4127:         a = masked_array(np.arange(1, 7).reshape(2, 3))
 4128:         assert_almost_equal(a.anom(),
 4129:                             [[-2.5, -1.5, -0.5], [0.5, 1.5, 2.5]])
 4130:         assert_almost_equal(a.anom(axis=0),
 4131:                             [[-1.5, -1.5, -1.5], [1.5, 1.5, 1.5]])
 4132:         assert_almost_equal(a.anom(axis=1),
 4133:                             [[-1., 0., 1.], [-1., 0., 1.]])
 4134:         a.mask = [[0, 0, 1], [0, 1, 0]]
 4135:         mval = -99
 4136:         assert_almost_equal(a.anom().filled(mval),
 4137:                             [[-2.25, -1.25, mval], [0.75, mval, 2.75]])
 4138:         assert_almost_equal(a.anom(axis=0).filled(mval),
 4139:                             [[-1.5, 0.0, mval], [1.5, mval, 0.0]])
 4140:         assert_almost_equal(a.anom(axis=1).filled(mval),
 4141:                             [[-0.5, 0.5, mval], [-1.0, mval, 1.0]])
 4142: 
 4143:     def test_trace(self):
 4144:         # Tests trace on MaskedArrays.
 4145:         (x, X, XX, m, mx, mX, mXX, m2x, m2X, m2XX) = self.d
 4146:         mXdiag = mX.diagonal()
 4147:         assert_equal(mX.trace(), mX.diagonal().compressed().sum())
 4148:         assert_almost_equal(mX.trace(),
 4149:                             X.trace() - sum(mXdiag.mask * X.diagonal(),
 4150:                                             axis=0))
 4151:         assert_equal(np.trace(mX), mX.trace())
 4152: 
 4153:         # gh-5560
 4154:         arr = np.arange(2 * 4 * 4).reshape(2, 4, 4)
 4155:         m_arr = np.ma.masked_array(arr, False)
 4156:         assert_equal(arr.trace(axis1=1, axis2=2), m_arr.trace(axis1=1, axis2=2))
 4157: 
 4158:     def test_dot(self):
 4159:         # Tests dot on MaskedArrays.
 4160:         (x, X, XX, m, mx, mX, mXX, m2x, m2X, m2XX) = self.d
 4161:         fx = mx.filled(0)
 4162:         r = mx.dot(mx)
 4163:         assert_almost_equal(r.filled(0), fx.dot(fx))
 4164:         assert_(r.mask is nomask)
 4165: 
 4166:         fX = mX.filled(0)
 4167:         r = mX.dot(mX)
 4168:         assert_almost_equal(r.filled(0), fX.dot(fX))
 4169:         assert_(r.mask[1, 3])
 4170:         r1 = empty_like(r)
 4171:         mX.dot(mX, out=r1)
 4172:         assert_almost_equal(r, r1)
 4173: 
 4174:         mYY = mXX.swapaxes(-1, -2)
 4175:         fXX, fYY = mXX.filled(0), mYY.filled(0)
 4176:         r = mXX.dot(mYY)
 4177:         assert_almost_equal(r.filled(0), fXX.dot(fYY))
 4178:         r1 = empty_like(r)
 4179:         mXX.dot(mYY, out=r1)
 4180:         assert_almost_equal(r, r1)
 4181: 
 4182:     def test_dot_shape_mismatch(self):
 4183:         # regression test
 4184:         x = masked_array([[1, 2], [3, 4]], mask=[[0, 1], [0, 0]])
 4185:         y = masked_array([[1, 2], [3, 4]], mask=[[0, 1], [0, 0]])
 4186:         z = masked_array([[0, 1], [3, 3]])
 4187:         x.dot(y, out=z)
 4188:         assert_almost_equal(z.filled(0), [[1, 0], [15, 16]])
 4189:         assert_almost_equal(z.mask, [[0, 1], [0, 0]])
 4190: 
 4191:     def test_varmean_nomask(self):
 4192:         # gh-5769
 4193:         foo = array([1, 2, 3, 4], dtype='f8')
 4194:         bar = array([1, 2, 3, 4], dtype='f8')
 4195:         assert_equal(type(foo.mean()), np.float64)
 4196:         assert_equal(type(foo.var()), np.float64)
 4197:         assert (foo.mean() == bar.mean()) is np.bool(True)
 4198: 
 4199:         # check array type is preserved and out works
 4200:         foo = array(np.arange(16).reshape((4, 4)), dtype='f8')
 4201:         bar = empty(4, dtype='f4')
 4202:         assert_equal(type(foo.mean(axis=1)), MaskedArray)
 4203:         assert_equal(type(foo.var(axis=1)), MaskedArray)
 4204:         assert_(foo.mean(axis=1, out=bar) is bar)
 4205:         assert_(foo.var(axis=1, out=bar) is bar)
 4206: 
 4207:     def test_varstd(self):
 4208:         # Tests var & std on MaskedArrays.
 4209:         (x, X, XX, m, mx, mX, mXX, m2x, m2X, m2XX) = self.d
 4210:         assert_almost_equal(mX.var(axis=None), mX.compressed().var())
 4211:         assert_almost_equal(mX.std(axis=None), mX.compressed().std())
 4212:         assert_almost_equal(mX.std(axis=None, ddof=1),
 4213:                             mX.compressed().std(ddof=1))
 4214:         assert_almost_equal(mX.var(axis=None, ddof=1),
 4215:                             mX.compressed().var(ddof=1))
 4216:         assert_equal(mXX.var(axis=3).shape, XX.var(axis=3).shape)
 4217:         assert_equal(mX.var().shape, X.var().shape)
 4218:         (mXvar0, mXvar1) = (mX.var(axis=0), mX.var(axis=1))
 4219:         assert_almost_equal(mX.var(axis=None, ddof=2),
 4220:                             mX.compressed().var(ddof=2))
 4221:         assert_almost_equal(mX.std(axis=None, ddof=2),
 4222:                             mX.compressed().std(ddof=2))
 4223:         for k in range(6):
 4224:             assert_almost_equal(mXvar1[k], mX[k].compressed().var())
 4225:             assert_almost_equal(mXvar0[k], mX[:, k].compressed().var())
 4226:             assert_almost_equal(np.sqrt(mXvar0[k]),
 4227:                                 mX[:, k].compressed().std())
 4228: 
 4229:     @suppress_copy_mask_on_assignment
 4230:     def test_varstd_specialcases(self):
 4231:         # Test a special case for var
 4232:         nout = np.array(-1, dtype=float)
 4233:         mout = array(-1, dtype=float)
 4234: 
 4235:         x = array(arange(10), mask=True)
 4236:         for methodname in ('var', 'std'):
 4237:             method = getattr(x, methodname)
 4238:             assert_(method() is masked)
 4239:             assert_(method(0) is masked)
 4240:             assert_(method(-1) is masked)
 4241:             # Using a masked array as explicit output
 4242:             method(out=mout)
 4243:             assert_(mout is not masked)
 4244:             assert_equal(mout.mask, True)
 4245:             # Using a ndarray as explicit output
 4246:             method(out=nout)
 4247:             assert_(np.isnan(nout))
 4248: 
 4249:         x = array(arange(10), mask=True)
 4250:         x[-1] = 9
 4251:         for methodname in ('var', 'std'):
 4252:             method = getattr(x, methodname)
 4253:             assert_(method(ddof=1) is masked)
 4254:             assert_(method(0, ddof=1) is masked)
 4255:             assert_(method(-1, ddof=1) is masked)
 4256:             # Using a masked array as explicit output
 4257:             method(out=mout, ddof=1)
 4258:             assert_(mout is not masked)
 4259:             assert_equal(mout.mask, True)
 4260:             # Using a ndarray as explicit output
 4261:             method(out=nout, ddof=1)
 4262:             assert_(np.isnan(nout))
 4263: 
 4264:     def test_varstd_ddof(self):
 4265:         a = array([[1, 1, 0], [1, 1, 0]], mask=[[0, 0, 1], [0, 0, 1]])
 4266:         test = a.std(axis=0, ddof=0)
 4267:         assert_equal(test.filled(0), [0, 0, 0])
 4268:         assert_equal(test.mask, [0, 0, 1])
 4269:         test = a.std(axis=0, ddof=1)
 4270:         assert_equal(test.filled(0), [0, 0, 0])
 4271:         assert_equal(test.mask, [0, 0, 1])
 4272:         test = a.std(axis=0, ddof=2)
 4273:         assert_equal(test.filled(0), [0, 0, 0])
 4274:         assert_equal(test.mask, [1, 1, 1])
 4275: 
 4276:     def test_diag(self):
 4277:         # Test diag
 4278:         x = arange(9).reshape((3, 3))
 4279:         x[1, 1] = masked
 4280:         out = np.diag(x)
 4281:         assert_equal(out, [0, 4, 8])
 4282:         out = diag(x)
 4283:         assert_equal(out, [0, 4, 8])
 4284:         assert_equal(out.mask, [0, 1, 0])
 4285:         out = diag(out)
 4286:         control = array([[0, 0, 0], [0, 4, 0], [0, 0, 8]],
 4287:                         mask=[[0, 0, 0], [0, 1, 0], [0, 0, 0]])
 4288:         assert_equal(out, control)
 4289: 
 4290:     def test_axis_methods_nomask(self):
 4291:         # Test the combination nomask & methods w/ axis
 4292:         a = array([[1, 2, 3], [4, 5, 6]])
 4293: 
 4294:         assert_equal(a.sum(0), [5, 7, 9])
 4295:         assert_equal(a.sum(-1), [6, 15])
 4296:         assert_equal(a.sum(1), [6, 15])
 4297: 
 4298:         assert_equal(a.prod(0), [4, 10, 18])
 4299:         assert_equal(a.prod(-1), [6, 120])
 4300:         assert_equal(a.prod(1), [6, 120])
 4301: 
 4302:         assert_equal(a.min(0), [1, 2, 3])
 4303:         assert_equal(a.min(-1), [1, 4])
 4304:         assert_equal(a.min(1), [1, 4])
 4305: 
 4306:         assert_equal(a.max(0), [4, 5, 6])
 4307:         assert_equal(a.max(-1), [3, 6])
 4308:         assert_equal(a.max(1), [3, 6])
 4309: 
 4310:     @requires_memory(free_bytes=2 * 10000 * 1000 * 2)
 4311:     def test_mean_overflow(self):
 4312:         # Test overflow in masked arrays
 4313:         # gh-20272
 4314:         a = masked_array(np.full((10000, 10000), 65535, dtype=np.uint16),
 4315:                          mask=np.zeros((10000, 10000)))
 4316:         assert_equal(a.mean(), 65535.0)
 4317: 
 4318:     def test_diff_with_prepend(self):
 4319:         # GH 22465
 4320:         x = np.array([1, 2, 2, 3, 4, 2, 1, 1])
 4321: 
 4322:         a = np.ma.masked_equal(x[3:], value=2)
 4323:         a_prep = np.ma.masked_equal(x[:3], value=2)
 4324:         diff1 = np.ma.diff(a, prepend=a_prep, axis=0)
 4325: 
 4326:         b = np.ma.masked_equal(x, value=2)
 4327:         diff2 = np.ma.diff(b, axis=0)
 4328: 
 4329:         assert_(np.ma.allequal(diff1, diff2))
 4330: 
 4331:     def test_diff_with_append(self):
 4332:         # GH 22465
 4333:         x = np.array([1, 2, 2, 3, 4, 2, 1, 1])
 4334: 
 4335:         a = np.ma.masked_equal(x[:3], value=2)
 4336:         a_app = np.ma.masked_equal(x[3:], value=2)
 4337:         diff1 = np.ma.diff(a, append=a_app, axis=0)
 4338: 
 4339:         b = np.ma.masked_equal(x, value=2)
 4340:         diff2 = np.ma.diff(b, axis=0)
 4341: 
 4342:         assert_(np.ma.allequal(diff1, diff2))
 4343: 
 4344:     def test_diff_with_dim_0(self):
 4345:         with pytest.raises(
 4346:             ValueError,
 4347:             match="diff requires input that is at least one dimensional"
 4348:             ):
 4349:             np.ma.diff(np.array(1))
 4350: 
 4351:     def test_diff_with_n_0(self):
 4352:         a = np.ma.masked_equal([1, 2, 2, 3, 4, 2, 1, 1], value=2)
 4353:         diff = np.ma.diff(a, n=0, axis=0)
 4354: 
 4355:         assert_(np.ma.allequal(a, diff))
 4356: 
 4357: 
 4358: class TestMaskedArrayMathMethodsComplex:
 4359:     # Test class for miscellaneous MaskedArrays methods.
 4360:     def setup_method(self):
 4361:         # Base data definition.
 4362:         x = np.array([8.375j, 7.545j, 8.828j, 8.5j, 1.757j, 5.928,
 4363:                       8.43, 7.78, 9.865, 5.878, 8.979, 4.732,
 4364:                       3.012, 6.022, 5.095, 3.116, 5.238, 3.957,
 4365:                       6.04, 9.63, 7.712, 3.382, 4.489, 6.479j,
 4366:                       7.189j, 9.645, 5.395, 4.961, 9.894, 2.893,
 4367:                       7.357, 9.828, 6.272, 3.758, 6.693, 0.993j])
 4368:         X = x.reshape(6, 6)
 4369:         XX = x.reshape(3, 2, 2, 3)
 4370: 
 4371:         m = np.array([0, 1, 0, 1, 0, 0,
 4372:                      1, 0, 1, 1, 0, 1,
 4373:                      0, 0, 0, 1, 0, 1,
 4374:                      0, 0, 0, 1, 1, 1,
 4375:                      1, 0, 0, 1, 0, 0,
 4376:                      0, 0, 1, 0, 1, 0])
 4377:         mx = array(data=x, mask=m)
 4378:         mX = array(data=X, mask=m.reshape(X.shape))
 4379:         mXX = array(data=XX, mask=m.reshape(XX.shape))
 4380: 
 4381:         m2 = np.array([1, 1, 0, 1, 0, 0,
 4382:                       1, 1, 1, 1, 0, 1,
 4383:                       0, 0, 1, 1, 0, 1,
 4384:                       0, 0, 0, 1, 1, 1,
 4385:                       1, 0, 0, 1, 1, 0,
 4386:                       0, 0, 1, 0, 1, 1])
 4387:         m2x = array(data=x, mask=m2)
 4388:         m2X = array(data=X, mask=m2.reshape(X.shape))
 4389:         m2XX = array(data=XX, mask=m2.reshape(XX.shape))
 4390:         self.d = (x, X, XX, m, mx, mX, mXX, m2x, m2X, m2XX)
 4391: 
 4392:     def test_varstd(self):
 4393:         # Tests var & std on MaskedArrays.
 4394:         (x, X, XX, m, mx, mX, mXX, m2x, m2X, m2XX) = self.d
 4395:         assert_almost_equal(mX.var(axis=None), mX.compressed().var())
 4396:         assert_almost_equal(mX.std(axis=None), mX.compressed().std())
 4397:         assert_equal(mXX.var(axis=3).shape, XX.var(axis=3).shape)
 4398:         assert_equal(mX.var().shape, X.var().shape)
 4399:         (mXvar0, mXvar1) = (mX.var(axis=0), mX.var(axis=1))
 4400:         assert_almost_equal(mX.var(axis=None, ddof=2),
 4401:                             mX.compressed().var(ddof=2))
 4402:         assert_almost_equal(mX.std(axis=None, ddof=2),
 4403:                             mX.compressed().std(ddof=2))
 4404:         for k in range(6):
 4405:             assert_almost_equal(mXvar1[k], mX[k].compressed().var())
 4406:             assert_almost_equal(mXvar0[k], mX[:, k].compressed().var())
 4407:             assert_almost_equal(np.sqrt(mXvar0[k]),
 4408:                                 mX[:, k].compressed().std())
 4409: 
 4410: 
 4411: class TestMaskedArrayFunctions:
 4412:     # Test class for miscellaneous functions.
 4413: 
 4414:     def setup_method(self):
 4415:         x = np.array([1., 1., 1., -2., pi / 2.0, 4., 5., -10., 10., 1., 2., 3.])
 4416:         y = np.array([5., 0., 3., 2., -1., -4., 0., -10., 10., 1., 0., 3.])
 4417:         m1 = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]
 4418:         m2 = [0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1]
 4419:         xm = masked_array(x, mask=m1)
 4420:         ym = masked_array(y, mask=m2)
 4421:         xm.set_fill_value(1e+20)
 4422:         self.info = (xm, ym)
 4423: 
 4424:     def test_masked_where_bool(self):
 4425:         x = [1, 2]
 4426:         y = masked_where(False, x)
 4427:         assert_equal(y, [1, 2])
 4428:         assert_equal(y[1], 2)
 4429: 
 4430:     def test_masked_equal_wlist(self):
 4431:         x = [1, 2, 3]
 4432:         mx = masked_equal(x, 3)
 4433:         assert_equal(mx, x)
 4434:         assert_equal(mx._mask, [0, 0, 1])
 4435:         mx = masked_not_equal(x, 3)
 4436:         assert_equal(mx, x)
 4437:         assert_equal(mx._mask, [1, 1, 0])
 4438: 
 4439:     def test_masked_equal_fill_value(self):
 4440:         x = [1, 2, 3]
 4441:         mx = masked_equal(x, 3)
 4442:         assert_equal(mx._mask, [0, 0, 1])
 4443:         assert_equal(mx.fill_value, 3)
 4444: 
 4445:     def test_masked_where_condition(self):
 4446:         # Tests masking functions.
 4447:         x = array([1., 2., 3., 4., 5.])
 4448:         x[2] = masked
 4449:         assert_equal(masked_where(greater(x, 2), x), masked_greater(x, 2))
 4450:         assert_equal(masked_where(greater_equal(x, 2), x),
 4451:                      masked_greater_equal(x, 2))
 4452:         assert_equal(masked_where(less(x, 2), x), masked_less(x, 2))
 4453:         assert_equal(masked_where(less_equal(x, 2), x),
 4454:                      masked_less_equal(x, 2))
 4455:         assert_equal(masked_where(not_equal(x, 2), x), masked_not_equal(x, 2))
 4456:         assert_equal(masked_where(equal(x, 2), x), masked_equal(x, 2))
 4457:         assert_equal(masked_where(not_equal(x, 2), x), masked_not_equal(x, 2))
 4458:         assert_equal(masked_where([1, 1, 0, 0, 0], [1, 2, 3, 4, 5]),
 4459:                      [99, 99, 3, 4, 5])
 4460: 
 4461:     def test_masked_where_oddities(self):
 4462:         # Tests some generic features.
 4463:         atest = ones((10, 10, 10), dtype=float)
 4464:         btest = zeros(atest.shape, MaskType)
 4465:         ctest = masked_where(btest, atest)
 4466:         assert_equal(atest, ctest)
 4467: 
 4468:     def test_masked_where_shape_constraint(self):
 4469:         a = arange(10)
 4470:         with assert_raises(IndexError):
 4471:             masked_equal(1, a)
 4472:         test = masked_equal(a, 1)
 4473:         assert_equal(test.mask, [0, 1, 0, 0, 0, 0, 0, 0, 0, 0])
 4474: 
 4475:     def test_masked_where_structured(self):
 4476:         # test that masked_where on a structured array sets a structured
 4477:         # mask (see issue #2972)
 4478:         a = np.zeros(10, dtype=[("A", "<f2"), ("B", "<f4")])
 4479:         with np.errstate(over="ignore"):
 4480:             # NOTE: The float16 "uses" 1e20 as mask, which overflows to inf
 4481:             #       and warns.  Unrelated to this test, but probably undesired.
 4482:             #       But NumPy previously did not warn for this overflow.
 4483:             am = np.ma.masked_where(a["A"] < 5, a)
 4484:         assert_equal(am.mask.dtype.names, am.dtype.names)
 4485:         assert_equal(am["A"],
 4486:                     np.ma.masked_array(np.zeros(10), np.ones(10)))
 4487: 
 4488:     def test_masked_where_mismatch(self):
 4489:         # gh-4520
 4490:         x = np.arange(10)
 4491:         y = np.arange(5)
 4492:         assert_raises(IndexError, np.ma.masked_where, y > 6, x)
 4493: 
 4494:     def test_masked_otherfunctions(self):
 4495:         assert_equal(masked_inside(list(range(5)), 1, 3),
 4496:                      [0, 199, 199, 199, 4])
 4497:         assert_equal(masked_outside(list(range(5)), 1, 3), [199, 1, 2, 3, 199])
 4498:         assert_equal(masked_inside(array(list(range(5)),
 4499:                                          mask=[1, 0, 0, 0, 0]), 1, 3).mask,
 4500:                      [1, 1, 1, 1, 0])
 4501:         assert_equal(masked_outside(array(list(range(5)),
 4502:                                           mask=[0, 1, 0, 0, 0]), 1, 3).mask,
 4503:                      [1, 1, 0, 0, 1])
 4504:         assert_equal(masked_equal(array(list(range(5)),
 4505:                                         mask=[1, 0, 0, 0, 0]), 2).mask,
 4506:                      [1, 0, 1, 0, 0])
 4507:         assert_equal(masked_not_equal(array([2, 2, 1, 2, 1],
 4508:                                             mask=[1, 0, 0, 0, 0]), 2).mask,
 4509:                      [1, 0, 1, 0, 1])
 4510: 
 4511:     def test_round(self):
 4512:         a = array([1.23456, 2.34567, 3.45678, 4.56789, 5.67890],
 4513:                   mask=[0, 1, 0, 0, 0])
 4514:         assert_equal(a.round(), [1., 2., 3., 5., 6.])
 4515:         assert_equal(a.round(1), [1.2, 2.3, 3.5, 4.6, 5.7])
 4516:         assert_equal(a.round(3), [1.235, 2.346, 3.457, 4.568, 5.679])
 4517:         b = empty_like(a)
 4518:         a.round(out=b)
 4519:         assert_equal(b, [1., 2., 3., 5., 6.])
 4520: 
 4521:         x = array([1., 2., 3., 4., 5.])
 4522:         c = array([1, 1, 1, 0, 0])
 4523:         x[2] = masked
 4524:         z = where(c, x, -x)
 4525:         assert_equal(z, [1., 2., 0., -4., -5])
 4526:         c[0] = masked
 4527:         z = where(c, x, -x)
 4528:         assert_equal(z, [1., 2., 0., -4., -5])
 4529:         assert_(z[0] is masked)
 4530:         assert_(z[1] is not masked)
 4531:         assert_(z[2] is masked)
 4532: 
 4533:     def test_round_with_output(self):
 4534:         # Testing round with an explicit output
 4535: 
 4536:         xm = array(np.random.uniform(0, 10, 12)).reshape(3, 4)
 4537:         xm[:, 0] = xm[0] = xm[-1, -1] = masked
 4538: 
 4539:         # A ndarray as explicit input
 4540:         output = np.empty((3, 4), dtype=float)
 4541:         output.fill(-9999)
 4542:         result = np.round(xm, decimals=2, out=output)
 4543:         # ... the result should be the given output
 4544:         assert_(result is output)
 4545:         assert_equal(result, xm.round(decimals=2, out=output))
 4546: 
 4547:         output = empty((3, 4), dtype=float)
 4548:         result = xm.round(decimals=2, out=output)
 4549:         assert_(result is output)
 4550: 
 4551:     def test_round_with_scalar(self):
 4552:         # Testing round with scalar/zero dimension input
 4553:         # GH issue 2244
 4554:         a = array(1.1, mask=[False])
 4555:         assert_equal(a.round(), 1)
 4556: 
 4557:         a = array(1.1, mask=[True])
 4558:         assert_(a.round() is masked)
 4559: 
 4560:         a = array(1.1, mask=[False])
 4561:         output = np.empty(1, dtype=float)
 4562:         output.fill(-9999)
 4563:         a.round(out=output)
 4564:         assert_equal(output, 1)
 4565: 
 4566:         a = array(1.1, mask=[False])
 4567:         output = array(-9999., mask=[True])
 4568:         a.round(out=output)
 4569:         assert_equal(output[()], 1)
 4570: 
 4571:         a = array(1.1, mask=[True])
 4572:         output = array(-9999., mask=[False])
 4573:         a.round(out=output)
 4574:         assert_(output[()] is masked)
 4575: 
 4576:     def test_identity(self):
 4577:         a = identity(5)
 4578:         assert_(isinstance(a, MaskedArray))
 4579:         assert_equal(a, np.identity(5))
 4580: 
 4581:     def test_power(self):
 4582:         x = -1.1
 4583:         assert_almost_equal(power(x, 2.), 1.21)
 4584:         assert_(power(x, masked) is masked)
 4585:         x = array([-1.1, -1.1, 1.1, 1.1, 0.])
 4586:         b = array([0.5, 2., 0.5, 2., -1.], mask=[0, 0, 0, 0, 1])
 4587:         y = power(x, b)
 4588:         assert_almost_equal(y, [0, 1.21, 1.04880884817, 1.21, 0.])
 4589:         assert_equal(y._mask, [1, 0, 0, 0, 1])
 4590:         b.mask = nomask
 4591:         y = power(x, b)
 4592:         assert_equal(y._mask, [1, 0, 0, 0, 1])
 4593:         z = x ** b
 4594:         assert_equal(z._mask, y._mask)
 4595:         assert_almost_equal(z, y)
 4596:         assert_almost_equal(z._data, y._data)
 4597:         x **= b
 4598:         assert_equal(x._mask, y._mask)
 4599:         assert_almost_equal(x, y)
 4600:         assert_almost_equal(x._data, y._data)
 4601: 
 4602:     def test_power_with_broadcasting(self):
 4603:         # Test power w/ broadcasting
 4604:         a2 = np.array([[1., 2., 3.], [4., 5., 6.]])
 4605:         a2m = array(a2, mask=[[1, 0, 0], [0, 0, 1]])
 4606:         b1 = np.array([2, 4, 3])
 4607:         b2 = np.array([b1, b1])
 4608:         b2m = array(b2, mask=[[0, 1, 0], [0, 1, 0]])
 4609: 
 4610:         ctrl = array([[1 ** 2, 2 ** 4, 3 ** 3], [4 ** 2, 5 ** 4, 6 ** 3]],
 4611:                      mask=[[1, 1, 0], [0, 1, 1]])
 4612:         # No broadcasting, base & exp w/ mask
 4613:         test = a2m ** b2m
 4614:         assert_equal(test, ctrl)
 4615:         assert_equal(test.mask, ctrl.mask)
 4616:         # No broadcasting, base w/ mask, exp w/o mask
 4617:         test = a2m ** b2
 4618:         assert_equal(test, ctrl)
 4619:         assert_equal(test.mask, a2m.mask)
 4620:         # No broadcasting, base w/o mask, exp w/ mask
 4621:         test = a2 ** b2m
 4622:         assert_equal(test, ctrl)
 4623:         assert_equal(test.mask, b2m.mask)
 4624: 
 4625:         ctrl = array([[2 ** 2, 4 ** 4, 3 ** 3], [2 ** 2, 4 ** 4, 3 ** 3]],
 4626:                      mask=[[0, 1, 0], [0, 1, 0]])
 4627:         test = b1 ** b2m
 4628:         assert_equal(test, ctrl)
 4629:         assert_equal(test.mask, ctrl.mask)
 4630:         test = b2m ** b1
 4631:         assert_equal(test, ctrl)
 4632:         assert_equal(test.mask, ctrl.mask)
 4633: 
 4634:     @pytest.mark.skipif(IS_WASM, reason="fp errors don't work in wasm")
 4635:     def test_where(self):
 4636:         # Test the where function
 4637:         x = np.array([1., 1., 1., -2., pi / 2.0, 4., 5., -10., 10., 1., 2., 3.])
 4638:         y = np.array([5., 0., 3., 2., -1., -4., 0., -10., 10., 1., 0., 3.])
 4639:         m1 = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]
 4640:         m2 = [0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1]
 4641:         xm = masked_array(x, mask=m1)
 4642:         ym = masked_array(y, mask=m2)
 4643:         xm.set_fill_value(1e+20)
 4644: 
 4645:         d = where(xm > 2, xm, -9)
 4646:         assert_equal(d, [-9., -9., -9., -9., -9., 4.,
 4647:                          -9., -9., 10., -9., -9., 3.])
 4648:         assert_equal(d._mask, xm._mask)
 4649:         d = where(xm > 2, -9, ym)
 4650:         assert_equal(d, [5., 0., 3., 2., -1., -9.,
 4651:                          -9., -10., -9., 1., 0., -9.])
 4652:         assert_equal(d._mask, [1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0])
 4653:         d = where(xm > 2, xm, masked)
 4654:         assert_equal(d, [-9., -9., -9., -9., -9., 4.,
 4655:                          -9., -9., 10., -9., -9., 3.])
 4656:         tmp = xm._mask.copy()
 4657:         tmp[(xm <= 2).filled(True)] = True
 4658:         assert_equal(d._mask, tmp)
 4659: 
 4660:         with np.errstate(invalid="warn"):
 4661:             # The fill value is 1e20, it cannot be converted to `int`:
 4662:             with pytest.warns(RuntimeWarning, match="invalid value"):
 4663:                 ixm = xm.astype(int)
 4664:         d = where(ixm > 2, ixm, masked)
 4665:         assert_equal(d, [-9, -9, -9, -9, -9, 4, -9, -9, 10, -9, -9, 3])
 4666:         assert_equal(d.dtype, ixm.dtype)
 4667: 
 4668:     def test_where_object(self):
 4669:         a = np.array(None)
 4670:         b = masked_array(None)
 4671:         r = b.copy()
 4672:         assert_equal(np.ma.where(True, a, a), r)
 4673:         assert_equal(np.ma.where(True, b, b), r)
 4674: 
 4675:     def test_where_with_masked_choice(self):
 4676:         x = arange(10)
 4677:         x[3] = masked
 4678:         c = x >= 8
 4679:         # Set False to masked
 4680:         z = where(c, x, masked)
 4681:         assert_(z.dtype is x.dtype)
 4682:         assert_(z[3] is masked)
 4683:         assert_(z[4] is masked)
 4684:         assert_(z[7] is masked)
 4685:         assert_(z[8] is not masked)
 4686:         assert_(z[9] is not masked)
 4687:         assert_equal(x, z)
 4688:         # Set True to masked
 4689:         z = where(c, masked, x)
 4690:         assert_(z.dtype is x.dtype)
 4691:         assert_(z[3] is masked)
 4692:         assert_(z[4] is not masked)
 4693:         assert_(z[7] is not masked)
 4694:         assert_(z[8] is masked)
 4695:         assert_(z[9] is masked)
 4696: 
 4697:     def test_where_with_masked_condition(self):
 4698:         x = array([1., 2., 3., 4., 5.])
 4699:         c = array([1, 1, 1, 0, 0])
 4700:         x[2] = masked
 4701:         z = where(c, x, -x)
 4702:         assert_equal(z, [1., 2., 0., -4., -5])
 4703:         c[0] = masked
 4704:         z = where(c, x, -x)
 4705:         assert_equal(z, [1., 2., 0., -4., -5])
 4706:         assert_(z[0] is masked)
 4707:         assert_(z[1] is not masked)
 4708:         assert_(z[2] is masked)
 4709: 
 4710:         x = arange(1, 6)
 4711:         x[-1] = masked
 4712:         y = arange(1, 6) * 10
 4713:         y[2] = masked
 4714:         c = array([1, 1, 1, 0, 0], mask=[1, 0, 0, 0, 0])
 4715:         cm = c.filled(1)
 4716:         z = where(c, x, y)
 4717:         zm = where(cm, x, y)
 4718:         assert_equal(z, zm)
 4719:         assert_(getmask(zm) is nomask)
 4720:         assert_equal(zm, [1, 2, 3, 40, 50])
 4721:         z = where(c, masked, 1)
 4722:         assert_equal(z, [99, 99, 99, 1, 1])
 4723:         z = where(c, 1, masked)
 4724:         assert_equal(z, [99, 1, 1, 99, 99])
 4725: 
 4726:     def test_where_type(self):
 4727:         # Test the type conservation with where
 4728:         x = np.arange(4, dtype=np.int32)
 4729:         y = np.arange(4, dtype=np.float32) * 2.2
 4730:         test = where(x > 1.5, y, x).dtype
 4731:         control = np.result_type(np.int32, np.float32)
 4732:         assert_equal(test, control)
 4733: 
 4734:     def test_where_broadcast(self):
 4735:         # Issue 8599
 4736:         x = np.arange(9).reshape(3, 3)
 4737:         y = np.zeros(3)
 4738:         core = np.where([1, 0, 1], x, y)
 4739:         ma = where([1, 0, 1], x, y)
 4740: 
 4741:         assert_equal(core, ma)
 4742:         assert_equal(core.dtype, ma.dtype)
 4743: 
 4744:     def test_where_structured(self):
 4745:         # Issue 8600
 4746:         dt = np.dtype([('a', int), ('b', int)])
 4747:         x = np.array([(1, 2), (3, 4), (5, 6)], dtype=dt)
 4748:         y = np.array((10, 20), dtype=dt)
 4749:         core = np.where([0, 1, 1], x, y)
 4750:         ma = np.where([0, 1, 1], x, y)
 4751: 
 4752:         assert_equal(core, ma)
 4753:         assert_equal(core.dtype, ma.dtype)
 4754: 
 4755:     def test_where_structured_masked(self):
 4756:         dt = np.dtype([('a', int), ('b', int)])
 4757:         x = np.array([(1, 2), (3, 4), (5, 6)], dtype=dt)
 4758: 
 4759:         ma = where([0, 1, 1], x, masked)
 4760:         expected = masked_where([1, 0, 0], x)
 4761: 
 4762:         assert_equal(ma.dtype, expected.dtype)
 4763:         assert_equal(ma, expected)
 4764:         assert_equal(ma.mask, expected.mask)
 4765: 
 4766:     def test_masked_invalid_error(self):
 4767:         a = np.arange(5, dtype=object)
 4768:         a[3] = np.inf
 4769:         a[2] = np.nan
 4770:         with pytest.raises(TypeError,
 4771:                            match="not supported for the input types"):
 4772:             np.ma.masked_invalid(a)
 4773: 
 4774:     def test_masked_invalid_pandas(self):
 4775:         # getdata() used to be bad for pandas series due to its _data
 4776:         # attribute.  This test is a regression test mainly and may be
 4777:         # removed if getdata() is adjusted.
 4778:         class Series:
 4779:             _data = "nonsense"
 4780: 
 4781:             def __array__(self, dtype=None, copy=None):
 4782:                 return np.array([5, np.nan, np.inf])
 4783: 
 4784:         arr = np.ma.masked_invalid(Series())
 4785:         assert_array_equal(arr._data, np.array(Series()))
 4786:         assert_array_equal(arr._mask, [False, True, True])
 4787: 
 4788:     @pytest.mark.parametrize("copy", [True, False])
 4789:     def test_masked_invalid_full_mask(self, copy):
 4790:         # Matplotlib relied on masked_invalid always returning a full mask
 4791:         # (Also astropy projects, but were ok with it gh-22720 and gh-22842)
 4792:         a = np.ma.array([1, 2, 3, 4])
 4793:         assert a._mask is nomask
 4794:         res = np.ma.masked_invalid(a, copy=copy)
 4795:         assert res.mask is not nomask
 4796:         # mask of a should not be mutated
 4797:         assert a.mask is nomask
 4798:         assert np.may_share_memory(a._data, res._data) != copy
 4799: 
 4800:     def test_choose(self):
 4801:         # Test choose
 4802:         choices = [[0, 1, 2, 3], [10, 11, 12, 13],
 4803:                    [20, 21, 22, 23], [30, 31, 32, 33]]
 4804:         chosen = choose([2, 3, 1, 0], choices)
 4805:         assert_equal(chosen, array([20, 31, 12, 3]))
 4806:         chosen = choose([2, 4, 1, 0], choices, mode='clip')
 4807:         assert_equal(chosen, array([20, 31, 12, 3]))
 4808:         chosen = choose([2, 4, 1, 0], choices, mode='wrap')
 4809:         assert_equal(chosen, array([20, 1, 12, 3]))
 4810:         # Check with some masked indices
 4811:         indices_ = array([2, 4, 1, 0], mask=[1, 0, 0, 1])
 4812:         chosen = choose(indices_, choices, mode='wrap')
 4813:         assert_equal(chosen, array([99, 1, 12, 99]))
 4814:         assert_equal(chosen.mask, [1, 0, 0, 1])
 4815:         # Check with some masked choices
 4816:         choices = array(choices, mask=[[0, 0, 0, 1], [1, 1, 0, 1],
 4817:                                        [1, 0, 0, 0], [0, 0, 0, 0]])
 4818:         indices_ = [2, 3, 1, 0]
 4819:         chosen = choose(indices_, choices, mode='wrap')
 4820:         assert_equal(chosen, array([20, 31, 12, 3]))
 4821:         assert_equal(chosen.mask, [1, 0, 0, 1])
 4822: 
 4823:     def test_choose_with_out(self):
 4824:         # Test choose with an explicit out keyword
 4825:         choices = [[0, 1, 2, 3], [10, 11, 12, 13],
 4826:                    [20, 21, 22, 23], [30, 31, 32, 33]]
 4827:         store = empty(4, dtype=int)
 4828:         chosen = choose([2, 3, 1, 0], choices, out=store)
 4829:         assert_equal(store, array([20, 31, 12, 3]))
 4830:         assert_(store is chosen)
 4831:         # Check with some masked indices + out
 4832:         store = empty(4, dtype=int)
 4833:         indices_ = array([2, 3, 1, 0], mask=[1, 0, 0, 1])
 4834:         chosen = choose(indices_, choices, mode='wrap', out=store)
 4835:         assert_equal(store, array([99, 31, 12, 99]))
 4836:         assert_equal(store.mask, [1, 0, 0, 1])
 4837:         # Check with some masked choices + out ina ndarray !
 4838:         choices = array(choices, mask=[[0, 0, 0, 1], [1, 1, 0, 1],
 4839:                                        [1, 0, 0, 0], [0, 0, 0, 0]])
 4840:         indices_ = [2, 3, 1, 0]
 4841:         store = empty(4, dtype=int).view(ndarray)
 4842:         chosen = choose(indices_, choices, mode='wrap', out=store)
 4843:         assert_equal(store, array([999999, 31, 12, 999999]))
 4844: 
 4845:     def test_reshape(self):
 4846:         a = arange(10)
 4847:         a[0] = masked
 4848:         # Try the default
 4849:         b = a.reshape((5, 2))
 4850:         assert_equal(b.shape, (5, 2))
 4851:         assert_(b.flags['C'])
 4852:         # Try w/ arguments as list instead of tuple
 4853:         b = a.reshape(5, 2)
 4854:         assert_equal(b.shape, (5, 2))
 4855:         assert_(b.flags['C'])
 4856:         # Try w/ order
 4857:         b = a.reshape((5, 2), order='F')
 4858:         assert_equal(b.shape, (5, 2))
 4859:         assert_(b.flags['F'])
 4860:         # Try w/ order
 4861:         b = a.reshape(5, 2, order='F')
 4862:         assert_equal(b.shape, (5, 2))
 4863:         assert_(b.flags['F'])
 4864: 
 4865:         c = np.reshape(a, (2, 5))
 4866:         assert_(isinstance(c, MaskedArray))
 4867:         assert_equal(c.shape, (2, 5))
 4868:         assert_(c[0, 0] is masked)
 4869:         assert_(c.flags['C'])
 4870: 
 4871:     def test_make_mask_descr(self):
 4872:         # Flexible
 4873:         ntype = [('a', float), ('b', float)]
 4874:         test = make_mask_descr(ntype)
 4875:         assert_equal(test, [('a', bool), ('b', bool)])
 4876:         assert_(test is make_mask_descr(test))
 4877: 
 4878:         # Standard w/ shape
 4879:         ntype = (float, 2)
 4880:         test = make_mask_descr(ntype)
 4881:         assert_equal(test, (bool, 2))
 4882:         assert_(test is make_mask_descr(test))
 4883: 
 4884:         # Standard standard
 4885:         ntype = float
 4886:         test = make_mask_descr(ntype)
 4887:         assert_equal(test, np.dtype(bool))
 4888:         assert_(test is make_mask_descr(test))
 4889: 
 4890:         # Nested
 4891:         ntype = [('a', float), ('b', [('ba', float), ('bb', float)])]
 4892:         test = make_mask_descr(ntype)
 4893:         control = np.dtype([('a', 'b1'), ('b', [('ba', 'b1'), ('bb', 'b1')])])
 4894:         assert_equal(test, control)
 4895:         assert_(test is make_mask_descr(test))
 4896: 
 4897:         # Named+ shape
 4898:         ntype = [('a', (float, 2))]
 4899:         test = make_mask_descr(ntype)
 4900:         assert_equal(test, np.dtype([('a', (bool, 2))]))
 4901:         assert_(test is make_mask_descr(test))
 4902: 
 4903:         # 2 names
 4904:         ntype = [(('A', 'a'), float)]
 4905:         test = make_mask_descr(ntype)
 4906:         assert_equal(test, np.dtype([(('A', 'a'), bool)]))
 4907:         assert_(test is make_mask_descr(test))
 4908: 
 4909:         # nested boolean types should preserve identity
 4910:         base_type = np.dtype([('a', int, 3)])
 4911:         base_mtype = make_mask_descr(base_type)
 4912:         sub_type = np.dtype([('a', int), ('b', base_mtype)])
 4913:         test = make_mask_descr(sub_type)
 4914:         assert_equal(test, np.dtype([('a', bool), ('b', [('a', bool, 3)])]))
 4915:         assert_(test.fields['b'][0] is base_mtype)
 4916: 
 4917:     def test_make_mask(self):
 4918:         # Test make_mask
 4919:         # w/ a list as an input
 4920:         mask = [0, 1]
 4921:         test = make_mask(mask)
 4922:         assert_equal(test.dtype, MaskType)
 4923:         assert_equal(test, [0, 1])
 4924:         # w/ a ndarray as an input
 4925:         mask = np.array([0, 1], dtype=bool)
 4926:         test = make_mask(mask)
 4927:         assert_equal(test.dtype, MaskType)
 4928:         assert_equal(test, [0, 1])
 4929:         # w/ a flexible-type ndarray as an input - use default
 4930:         mdtype = [('a', bool), ('b', bool)]
 4931:         mask = np.array([(0, 0), (0, 1)], dtype=mdtype)
 4932:         test = make_mask(mask)
 4933:         assert_equal(test.dtype, MaskType)
 4934:         assert_equal(test, [1, 1])
 4935:         # w/ a flexible-type ndarray as an input - use input dtype
 4936:         mdtype = [('a', bool), ('b', bool)]
 4937:         mask = np.array([(0, 0), (0, 1)], dtype=mdtype)
 4938:         test = make_mask(mask, dtype=mask.dtype)
 4939:         assert_equal(test.dtype, mdtype)
 4940:         assert_equal(test, mask)
 4941:         # w/ a flexible-type ndarray as an input - use input dtype
 4942:         mdtype = [('a', float), ('b', float)]
 4943:         bdtype = [('a', bool), ('b', bool)]
 4944:         mask = np.array([(0, 0), (0, 1)], dtype=mdtype)
 4945:         test = make_mask(mask, dtype=mask.dtype)
 4946:         assert_equal(test.dtype, bdtype)
 4947:         assert_equal(test, np.array([(0, 0), (0, 1)], dtype=bdtype))
 4948:         # Ensure this also works for void
 4949:         mask = np.array((False, True), dtype='?,?')[()]
 4950:         assert_(isinstance(mask, np.void))
 4951:         test = make_mask(mask, dtype=mask.dtype)
 4952:         assert_equal(test, mask)
 4953:         assert_(test is not mask)
 4954:         mask = np.array((0, 1), dtype='i4,i4')[()]
 4955:         test2 = make_mask(mask, dtype=mask.dtype)
 4956:         assert_equal(test2, test)
 4957:         # test that nomask is returned when m is nomask.
 4958:         bools = [True, False]
 4959:         dtypes = [MaskType, float]
 4960:         msgformat = 'copy=%s, shrink=%s, dtype=%s'
 4961:         for cpy, shr, dt in itertools.product(bools, bools, dtypes):
 4962:             res = make_mask(nomask, copy=cpy, shrink=shr, dtype=dt)
 4963:             assert_(res is nomask, msgformat % (cpy, shr, dt))
 4964: 
 4965:     def test_mask_or(self):
 4966:         # Initialize
 4967:         mtype = [('a', bool), ('b', bool)]
 4968:         mask = np.array([(0, 0), (0, 1), (1, 0), (0, 0)], dtype=mtype)
 4969:         # Test using nomask as input
 4970:         test = mask_or(mask, nomask)
 4971:         assert_equal(test, mask)
 4972:         test = mask_or(nomask, mask)
 4973:         assert_equal(test, mask)
 4974:         # Using False as input
 4975:         test = mask_or(mask, False)
 4976:         assert_equal(test, mask)
 4977:         # Using another array w / the same dtype
 4978:         other = np.array([(0, 1), (0, 1), (0, 1), (0, 1)], dtype=mtype)
 4979:         test = mask_or(mask, other)
 4980:         control = np.array([(0, 1), (0, 1), (1, 1), (0, 1)], dtype=mtype)
 4981:         assert_equal(test, control)
 4982:         # Using another array w / a different dtype
 4983:         othertype = [('A', bool), ('B', bool)]
 4984:         other = np.array([(0, 1), (0, 1), (0, 1), (0, 1)], dtype=othertype)
 4985:         try:
 4986:             test = mask_or(mask, other)
 4987:         except ValueError:
 4988:             pass
 4989:         # Using nested arrays
 4990:         dtype = [('a', bool), ('b', [('ba', bool), ('bb', bool)])]
 4991:         amask = np.array([(0, (1, 0)), (0, (1, 0))], dtype=dtype)
 4992:         bmask = np.array([(1, (0, 1)), (0, (0, 0))], dtype=dtype)
 4993:         cntrl = np.array([(1, (1, 1)), (0, (1, 0))], dtype=dtype)
 4994:         assert_equal(mask_or(amask, bmask), cntrl)
 4995: 
 4996:         a = np.array([False, False])
 4997:         assert mask_or(a, a) is nomask  # gh-27360
 4998: 
 4999:     def test_allequal(self):
 5000:         x = array([1, 2, 3], mask=[0, 0, 0])
 5001:         y = array([1, 2, 3], mask=[1, 0, 0])
 5002:         z = array([[1, 2, 3], [4, 5, 6]], mask=[[0, 0, 0], [1, 1, 1]])
 5003: 
 5004:         assert allequal(x, y)
 5005:         assert not allequal(x, y, fill_value=False)
 5006:         assert allequal(x, z)
 5007: 
 5008:         # test allequal for the same input, with mask=nomask, this test is for
 5009:         # the scenario raised in https://github.com/numpy/numpy/issues/27201
 5010:         assert allequal(x, x)
 5011:         assert allequal(x, x, fill_value=False)
 5012: 
 5013:         assert allequal(y, y)
 5014:         assert not allequal(y, y, fill_value=False)
 5015: 
 5016:     def test_flatten_mask(self):
 5017:         # Tests flatten mask
 5018:         # Standard dtype
 5019:         mask = np.array([0, 0, 1], dtype=bool)
 5020:         assert_equal(flatten_mask(mask), mask)
 5021:         # Flexible dtype
 5022:         mask = np.array([(0, 0), (0, 1)], dtype=[('a', bool), ('b', bool)])
 5023:         test = flatten_mask(mask)
 5024:         control = np.array([0, 0, 0, 1], dtype=bool)
 5025:         assert_equal(test, control)
 5026: 
 5027:         mdtype = [('a', bool), ('b', [('ba', bool), ('bb', bool)])]
 5028:         data = [(0, (0, 0)), (0, (0, 1))]
 5029:         mask = np.array(data, dtype=mdtype)
 5030:         test = flatten_mask(mask)
 5031:         control = np.array([0, 0, 0, 0, 0, 1], dtype=bool)
 5032:         assert_equal(test, control)
 5033: 
 5034:     def test_on_ndarray(self):
 5035:         # Test functions on ndarrays
 5036:         a = np.array([1, 2, 3, 4])
 5037:         m = array(a, mask=False)
 5038:         test = anom(a)
 5039:         assert_equal(test, m.anom())
 5040:         test = reshape(a, (2, 2))
 5041:         assert_equal(test, m.reshape(2, 2))
 5042: 
 5043:     def test_compress(self):
 5044:         # Test compress function on ndarray and masked array
 5045:         # Address Github #2495.
 5046:         arr = np.arange(8)
 5047:         arr.shape = 4, 2
 5048:         cond = np.array([True, False, True, True])
 5049:         control = arr[[0, 2, 3]]
 5050:         test = np.ma.compress(cond, arr, axis=0)
 5051:         assert_equal(test, control)
 5052:         marr = np.ma.array(arr)
 5053:         test = np.ma.compress(cond, marr, axis=0)
 5054:         assert_equal(test, control)
 5055: 
 5056:     def test_compressed(self):
 5057:         # Test ma.compressed function.
 5058:         # Address gh-4026
 5059:         a = np.ma.array([1, 2])
 5060:         test = np.ma.compressed(a)
 5061:         assert_(type(test) is np.ndarray)
 5062: 
 5063:         # Test case when input data is ndarray subclass
 5064:         class A(np.ndarray):
 5065:             pass
 5066: 
 5067:         a = np.ma.array(A(shape=0))
 5068:         test = np.ma.compressed(a)
 5069:         assert_(type(test) is A)
 5070: 
 5071:         # Test that compress flattens
 5072:         test = np.ma.compressed([[1], [2]])
 5073:         assert_equal(test.ndim, 1)
 5074:         test = np.ma.compressed([[[[[1]]]]])
 5075:         assert_equal(test.ndim, 1)
 5076: 
 5077:         # Test case when input is MaskedArray subclass
 5078:         class M(MaskedArray):
 5079:             pass
 5080: 
 5081:         test = np.ma.compressed(M([[[]], [[]]]))
 5082:         assert_equal(test.ndim, 1)
 5083: 
 5084:         # with .compressed() overridden
 5085:         class M(MaskedArray):
 5086:             def compressed(self):
 5087:                 return 42
 5088: 
 5089:         test = np.ma.compressed(M([[[]], [[]]]))
 5090:         assert_equal(test, 42)
 5091: 
 5092:     def test_convolve(self):
 5093:         a = masked_equal(np.arange(5), 2)
 5094:         b = np.array([1, 1])
 5095: 
 5096:         result = masked_equal([0, 1, -1, -1, 7, 4], -1)
 5097:         test = np.ma.convolve(a, b, mode='full')
 5098:         assert_equal(test, result)
 5099: 
 5100:         test = np.ma.convolve(a, b, mode='same')
 5101:         assert_equal(test, result[:-1])
 5102: 
 5103:         test = np.ma.convolve(a, b, mode='valid')
 5104:         assert_equal(test, result[1:-1])
 5105: 
 5106:         result = masked_equal([0, 1, 1, 3, 7, 4], -1)
 5107:         test = np.ma.convolve(a, b, mode='full', propagate_mask=False)
 5108:         assert_equal(test, result)
 5109: 
 5110:         test = np.ma.convolve(a, b, mode='same', propagate_mask=False)
 5111:         assert_equal(test, result[:-1])
 5112: 
 5113:         test = np.ma.convolve(a, b, mode='valid', propagate_mask=False)
 5114:         assert_equal(test, result[1:-1])
 5115: 
 5116:         test = np.ma.convolve([1, 1], [1, 1, 1])
 5117:         assert_equal(test, masked_equal([1, 2, 2, 1], -1))
 5118: 
 5119:         a = [1, 1]
 5120:         b = masked_equal([1, -1, -1, 1], -1)
 5121:         test = np.ma.convolve(a, b, propagate_mask=False)
 5122:         assert_equal(test, masked_equal([1, 1, -1, 1, 1], -1))
 5123:         test = np.ma.convolve(a, b, propagate_mask=True)
 5124:         assert_equal(test, masked_equal([-1, -1, -1, -1, -1], -1))
 5125: 
 5126: 
 5127: class TestMaskedFields:
 5128: 
 5129:     def setup_method(self):
 5130:         ilist = [1, 2, 3, 4, 5]
 5131:         flist = [1.1, 2.2, 3.3, 4.4, 5.5]
 5132:         slist = ['one', 'two', 'three', 'four', 'five']
 5133:         ddtype = [('a', int), ('b', float), ('c', '|S8')]
 5134:         mdtype = [('a', bool), ('b', bool), ('c', bool)]
 5135:         mask = [0, 1, 0, 0, 1]
 5136:         base = array(list(zip(ilist, flist, slist)), mask=mask, dtype=ddtype)
 5137:         self.data = {"base": base, "mask": mask, "ddtype": ddtype, "mdtype": mdtype}
 5138: 
 5139:     def test_set_records_masks(self):
 5140:         base = self.data['base']
 5141:         mdtype = self.data['mdtype']
 5142:         # Set w/ nomask or masked
 5143:         base.mask = nomask
 5144:         assert_equal_records(base._mask, np.zeros(base.shape, dtype=mdtype))
 5145:         base.mask = masked
 5146:         assert_equal_records(base._mask, np.ones(base.shape, dtype=mdtype))
 5147:         # Set w/ simple boolean
 5148:         base.mask = False
 5149:         assert_equal_records(base._mask, np.zeros(base.shape, dtype=mdtype))
 5150:         base.mask = True
 5151:         assert_equal_records(base._mask, np.ones(base.shape, dtype=mdtype))
 5152:         # Set w/ list
 5153:         base.mask = [0, 0, 0, 1, 1]
 5154:         assert_equal_records(base._mask,
 5155:                              np.array([(x, x, x) for x in [0, 0, 0, 1, 1]],
 5156:                                       dtype=mdtype))
 5157: 
 5158:     def test_set_record_element(self):
 5159:         # Check setting an element of a record)
 5160:         base = self.data['base']
 5161:         (base_a, base_b, base_c) = (base['a'], base['b'], base['c'])
 5162:         base[0] = (pi, pi, 'pi')
 5163: 
 5164:         assert_equal(base_a.dtype, int)
 5165:         assert_equal(base_a._data, [3, 2, 3, 4, 5])
 5166: 
 5167:         assert_equal(base_b.dtype, float)
 5168:         assert_equal(base_b._data, [pi, 2.2, 3.3, 4.4, 5.5])
 5169: 
 5170:         assert_equal(base_c.dtype, '|S8')
 5171:         assert_equal(base_c._data,
 5172:                      [b'pi', b'two', b'three', b'four', b'five'])
 5173: 
 5174:     def test_set_record_slice(self):
 5175:         base = self.data['base']
 5176:         (base_a, base_b, base_c) = (base['a'], base['b'], base['c'])
 5177:         base[:3] = (pi, pi, 'pi')
 5178: 
 5179:         assert_equal(base_a.dtype, int)
 5180:         assert_equal(base_a._data, [3, 3, 3, 4, 5])
 5181: 
 5182:         assert_equal(base_b.dtype, float)
 5183:         assert_equal(base_b._data, [pi, pi, pi, 4.4, 5.5])
 5184: 
 5185:         assert_equal(base_c.dtype, '|S8')
 5186:         assert_equal(base_c._data,
 5187:                      [b'pi', b'pi', b'pi', b'four', b'five'])
 5188: 
 5189:     def test_mask_element(self):
 5190:         "Check record access"
 5191:         base = self.data['base']
 5192:         base[0] = masked
 5193: 
 5194:         for n in ('a', 'b', 'c'):
 5195:             assert_equal(base[n].mask, [1, 1, 0, 0, 1])
 5196:             assert_equal(base[n]._data, base._data[n])
 5197: 
 5198:     def test_getmaskarray(self):
 5199:         # Test getmaskarray on flexible dtype
 5200:         ndtype = [('a', int), ('b', float)]
 5201:         test = empty(3, dtype=ndtype)
 5202:         assert_equal(getmaskarray(test),
 5203:                      np.array([(0, 0), (0, 0), (0, 0)],
 5204:                               dtype=[('a', '|b1'), ('b', '|b1')]))
 5205:         test[:] = masked
 5206:         assert_equal(getmaskarray(test),
 5207:                      np.array([(1, 1), (1, 1), (1, 1)],
 5208:                               dtype=[('a', '|b1'), ('b', '|b1')]))
 5209: 
 5210:     def test_view(self):
 5211:         # Test view w/ flexible dtype
 5212:         iterator = list(zip(np.arange(10), np.random.rand(10)))
 5213:         data = np.array(iterator)
 5214:         a = array(iterator, dtype=[('a', float), ('b', float)])
 5215:         a.mask[0] = (1, 0)
 5216:         controlmask = np.array([1] + 19 * [0], dtype=bool)
 5217:         # Transform globally to simple dtype
 5218:         test = a.view(float)
 5219:         assert_equal(test, data.ravel())
 5220:         assert_equal(test.mask, controlmask)
 5221:         # Transform globally to dty
 5222:         test = a.view((float, 2))
 5223:         assert_equal(test, data)
 5224:         assert_equal(test.mask, controlmask.reshape(-1, 2))
 5225: 
 5226:     def test_getitem(self):
 5227:         ndtype = [('a', float), ('b', float)]
 5228:         a = array(list(zip(np.random.rand(10), np.arange(10))), dtype=ndtype)
 5229:         a.mask = np.array(list(zip([0, 0, 0, 0, 0, 0, 0, 0, 1, 1],
 5230:                                    [1, 0, 0, 0, 0, 0, 0, 0, 1, 0])),
 5231:                           dtype=[('a', bool), ('b', bool)])
 5232: 
 5233:         def _test_index(i):
 5234:             assert_equal(type(a[i]), mvoid)
 5235:             assert_equal_records(a[i]._data, a._data[i])
 5236:             assert_equal_records(a[i]._mask, a._mask[i])
 5237: 
 5238:             assert_equal(type(a[i, ...]), MaskedArray)
 5239:             assert_equal_records(a[i, ...]._data, a._data[i, ...])
 5240:             assert_equal_records(a[i, ...]._mask, a._mask[i, ...])
 5241: 
 5242:         _test_index(1)   # No mask
 5243:         _test_index(0)   # One element masked
 5244:         _test_index(-2)  # All element masked
 5245: 
 5246:     def test_setitem(self):
 5247:         # Issue 4866: check that one can set individual items in [record][col]
 5248:         # and [col][record] order
 5249:         ndtype = np.dtype([('a', float), ('b', int)])
 5250:         ma = np.ma.MaskedArray([(1.0, 1), (2.0, 2)], dtype=ndtype)
 5251:         ma['a'][1] = 3.0
 5252:         assert_equal(ma['a'], np.array([1.0, 3.0]))
 5253:         ma[1]['a'] = 4.0
 5254:         assert_equal(ma['a'], np.array([1.0, 4.0]))
 5255:         # Issue 2403
 5256:         mdtype = np.dtype([('a', bool), ('b', bool)])
 5257:         # soft mask
 5258:         control = np.array([(False, True), (True, True)], dtype=mdtype)
 5259:         a = np.ma.masked_all((2,), dtype=ndtype)
 5260:         a['a'][0] = 2
 5261:         assert_equal(a.mask, control)
 5262:         a = np.ma.masked_all((2,), dtype=ndtype)
 5263:         a[0]['a'] = 2
 5264:         assert_equal(a.mask, control)
 5265:         # hard mask
 5266:         control = np.array([(True, True), (True, True)], dtype=mdtype)
 5267:         a = np.ma.masked_all((2,), dtype=ndtype)
 5268:         a.harden_mask()
 5269:         a['a'][0] = 2
 5270:         assert_equal(a.mask, control)
 5271:         a = np.ma.masked_all((2,), dtype=ndtype)
 5272:         a.harden_mask()
 5273:         a[0]['a'] = 2
 5274:         assert_equal(a.mask, control)
 5275: 
 5276:     def test_setitem_scalar(self):
 5277:         # 8510
 5278:         mask_0d = np.ma.masked_array(1, mask=True)
 5279:         arr = np.ma.arange(3)
 5280:         arr[0] = mask_0d
 5281:         assert_array_equal(arr.mask, [True, False, False])
 5282: 
 5283:     def test_element_len(self):
 5284:         # check that len() works for mvoid (Github issue #576)
 5285:         for rec in self.data['base']:
 5286:             assert_equal(len(rec), len(self.data['ddtype']))
 5287: 
 5288: 
 5289: class TestMaskedObjectArray:
 5290: 
 5291:     def test_getitem(self):
 5292:         arr = np.ma.array([None, None])
 5293:         for dt in [float, object]:
 5294:             a0 = np.eye(2).astype(dt)
 5295:             a1 = np.eye(3).astype(dt)
 5296:             arr[0] = a0
 5297:             arr[1] = a1
 5298: 
 5299:             assert_(arr[0] is a0)
 5300:             assert_(arr[1] is a1)
 5301:             assert_(isinstance(arr[0, ...], MaskedArray))
 5302:             assert_(isinstance(arr[1, ...], MaskedArray))
 5303:             assert_(arr[0, ...][()] is a0)
 5304:             assert_(arr[1, ...][()] is a1)
 5305: 
 5306:             arr[0] = np.ma.masked
 5307: 
 5308:             assert_(arr[1] is a1)
 5309:             assert_(isinstance(arr[0, ...], MaskedArray))
 5310:             assert_(isinstance(arr[1, ...], MaskedArray))
 5311:             assert_equal(arr[0, ...].mask, True)
 5312:             assert_(arr[1, ...][()] is a1)
 5313: 
 5314:             # gh-5962 - object arrays of arrays do something special
 5315:             assert_equal(arr[0].data, a0)
 5316:             assert_equal(arr[0].mask, True)
 5317:             assert_equal(arr[0, ...][()].data, a0)
 5318:             assert_equal(arr[0, ...][()].mask, True)
 5319: 
 5320:     def test_nested_ma(self):
 5321: 
 5322:         arr = np.ma.array([None, None])
 5323:         # set the first object to be an unmasked masked constant. A little fiddly
 5324:         arr[0, ...] = np.array([np.ma.masked], object)[0, ...]
 5325: 
 5326:         # check the above line did what we were aiming for
 5327:         assert_(arr.data[0] is np.ma.masked)
 5328: 
 5329:         # test that getitem returned the value by identity
 5330:         assert_(arr[0] is np.ma.masked)
 5331: 
 5332:         # now mask the masked value!
 5333:         arr[0] = np.ma.masked
 5334:         assert_(arr[0] is np.ma.masked)
 5335: 
 5336: 
 5337: class TestMaskedView:
 5338: 
 5339:     def setup_method(self):
 5340:         iterator = list(zip(np.arange(10), np.random.rand(10)))
 5341:         data = np.array(iterator)
 5342:         a = array(iterator, dtype=[('a', float), ('b', float)])
 5343:         a.mask[0] = (1, 0)
 5344:         controlmask = np.array([1] + 19 * [0], dtype=bool)
 5345:         self.data = (data, a, controlmask)
 5346: 
 5347:     def test_view_to_nothing(self):
 5348:         (data, a, controlmask) = self.data
 5349:         test = a.view()
 5350:         assert_(isinstance(test, MaskedArray))
 5351:         assert_equal(test._data, a._data)
 5352:         assert_equal(test._mask, a._mask)
 5353: 
 5354:     def test_view_to_type(self):
 5355:         (data, a, controlmask) = self.data
 5356:         test = a.view(np.ndarray)
 5357:         assert_(not isinstance(test, MaskedArray))
 5358:         assert_equal(test, a._data)
 5359:         assert_equal_records(test, data.view(a.dtype).squeeze())
 5360: 
 5361:     def test_view_to_simple_dtype(self):
 5362:         (data, a, controlmask) = self.data
 5363:         # View globally
 5364:         test = a.view(float)
 5365:         assert_(isinstance(test, MaskedArray))
 5366:         assert_equal(test, data.ravel())
 5367:         assert_equal(test.mask, controlmask)
 5368: 
 5369:     def test_view_to_flexible_dtype(self):
 5370:         (data, a, controlmask) = self.data
 5371: 
 5372:         test = a.view([('A', float), ('B', float)])
 5373:         assert_equal(test.mask.dtype.names, ('A', 'B'))
 5374:         assert_equal(test['A'], a['a'])
 5375:         assert_equal(test['B'], a['b'])
 5376: 
 5377:         test = a[0].view([('A', float), ('B', float)])
 5378:         assert_(isinstance(test, MaskedArray))
 5379:         assert_equal(test.mask.dtype.names, ('A', 'B'))
 5380:         assert_equal(test['A'], a['a'][0])
 5381:         assert_equal(test['B'], a['b'][0])
 5382: 
 5383:         test = a[-1].view([('A', float), ('B', float)])
 5384:         assert_(isinstance(test, MaskedArray))
 5385:         assert_equal(test.dtype.names, ('A', 'B'))
 5386:         assert_equal(test['A'], a['a'][-1])
 5387:         assert_equal(test['B'], a['b'][-1])
 5388: 
 5389:     def test_view_to_subdtype(self):
 5390:         (data, a, controlmask) = self.data
 5391:         # View globally
 5392:         test = a.view((float, 2))
 5393:         assert_(isinstance(test, MaskedArray))
 5394:         assert_equal(test, data)
 5395:         assert_equal(test.mask, controlmask.reshape(-1, 2))
 5396:         # View on 1 masked element
 5397:         test = a[0].view((float, 2))
 5398:         assert_(isinstance(test, MaskedArray))
 5399:         assert_equal(test, data[0])
 5400:         assert_equal(test.mask, (1, 0))
 5401:         # View on 1 unmasked element
 5402:         test = a[-1].view((float, 2))
 5403:         assert_(isinstance(test, MaskedArray))
 5404:         assert_equal(test, data[-1])
 5405: 
 5406:     def test_view_to_dtype_and_type(self):
 5407:         (data, a, controlmask) = self.data
 5408: 
 5409:         test = a.view((float, 2), np.recarray)
 5410:         assert_equal(test, data)
 5411:         assert_(isinstance(test, np.recarray))
 5412:         assert_(not isinstance(test, MaskedArray))
 5413: 
 5414: 
 5415: class TestOptionalArgs:
 5416:     def test_ndarrayfuncs(self):
 5417:         # test axis arg behaves the same as ndarray (including multiple axes)
 5418: 
 5419:         d = np.arange(24.0).reshape((2, 3, 4))
 5420:         m = np.zeros(24, dtype=bool).reshape((2, 3, 4))
 5421:         # mask out last element of last dimension
 5422:         m[:, :, -1] = True
 5423:         a = np.ma.array(d, mask=m)
 5424: 
 5425:         def testaxis(f, a, d):
 5426:             numpy_f = numpy.__getattribute__(f)
 5427:             ma_f = np.ma.__getattribute__(f)
 5428: 
 5429:             # test axis arg
 5430:             assert_equal(ma_f(a, axis=1)[..., :-1], numpy_f(d[..., :-1], axis=1))
 5431:             assert_equal(ma_f(a, axis=(0, 1))[..., :-1],
 5432:                          numpy_f(d[..., :-1], axis=(0, 1)))
 5433: 
 5434:         def testkeepdims(f, a, d):
 5435:             numpy_f = numpy.__getattribute__(f)
 5436:             ma_f = np.ma.__getattribute__(f)
 5437: 
 5438:             # test keepdims arg
 5439:             assert_equal(ma_f(a, keepdims=True).shape,
 5440:                          numpy_f(d, keepdims=True).shape)
 5441:             assert_equal(ma_f(a, keepdims=False).shape,
 5442:                          numpy_f(d, keepdims=False).shape)
 5443: 
 5444:             # test both at once
 5445:             assert_equal(ma_f(a, axis=1, keepdims=True)[..., :-1],
 5446:                          numpy_f(d[..., :-1], axis=1, keepdims=True))
 5447:             assert_equal(ma_f(a, axis=(0, 1), keepdims=True)[..., :-1],
 5448:                          numpy_f(d[..., :-1], axis=(0, 1), keepdims=True))
 5449: 
 5450:         for f in ['sum', 'prod', 'mean', 'var', 'std']:
 5451:             testaxis(f, a, d)
 5452:             testkeepdims(f, a, d)
 5453: 
 5454:         for f in ['min', 'max']:
 5455:             testaxis(f, a, d)
 5456: 
 5457:         d = (np.arange(24).reshape((2, 3, 4)) % 2 == 0)
 5458:         a = np.ma.array(d, mask=m)
 5459:         for f in ['all', 'any']:
 5460:             testaxis(f, a, d)
 5461:             testkeepdims(f, a, d)
 5462: 
 5463:     def test_count(self):
 5464:         # test np.ma.count specially
 5465: 
 5466:         d = np.arange(24.0).reshape((2, 3, 4))
 5467:         m = np.zeros(24, dtype=bool).reshape((2, 3, 4))
 5468:         m[:, 0, :] = True
 5469:         a = np.ma.array(d, mask=m)
 5470: 
 5471:         assert_equal(count(a), 16)
 5472:         assert_equal(count(a, axis=1), 2 * ones((2, 4)))
 5473:         assert_equal(count(a, axis=(0, 1)), 4 * ones((4,)))
 5474:         assert_equal(count(a, keepdims=True), 16 * ones((1, 1, 1)))
 5475:         assert_equal(count(a, axis=1, keepdims=True), 2 * ones((2, 1, 4)))
 5476:         assert_equal(count(a, axis=(0, 1), keepdims=True), 4 * ones((1, 1, 4)))
 5477:         assert_equal(count(a, axis=-2), 2 * ones((2, 4)))
 5478:         assert_raises(ValueError, count, a, axis=(1, 1))
 5479:         assert_raises(AxisError, count, a, axis=3)
 5480: 
 5481:         # check the 'nomask' path
 5482:         a = np.ma.array(d, mask=nomask)
 5483: 
 5484:         assert_equal(count(a), 24)
 5485:         assert_equal(count(a, axis=1), 3 * ones((2, 4)))
 5486:         assert_equal(count(a, axis=(0, 1)), 6 * ones((4,)))
 5487:         assert_equal(count(a, keepdims=True), 24 * ones((1, 1, 1)))
 5488:         assert_equal(np.ndim(count(a, keepdims=True)), 3)
 5489:         assert_equal(count(a, axis=1, keepdims=True), 3 * ones((2, 1, 4)))
 5490:         assert_equal(count(a, axis=(0, 1), keepdims=True), 6 * ones((1, 1, 4)))
 5491:         assert_equal(count(a, axis=-2), 3 * ones((2, 4)))
 5492:         assert_raises(ValueError, count, a, axis=(1, 1))
 5493:         assert_raises(AxisError, count, a, axis=3)
 5494: 
 5495:         # check the 'masked' singleton
 5496:         assert_equal(count(np.ma.masked), 0)
 5497: 
 5498:         # check 0-d arrays do not allow axis > 0
 5499:         assert_raises(AxisError, count, np.ma.array(1), axis=1)
 5500: 
 5501: 
 5502: class TestMaskedConstant:
 5503:     def _do_add_test(self, add):
 5504:         # sanity check
 5505:         assert_(add(np.ma.masked, 1) is np.ma.masked)
 5506: 
 5507:         # now try with a vector
 5508:         vector = np.array([1, 2, 3])
 5509:         result = add(np.ma.masked, vector)
 5510: 
 5511:         # lots of things could go wrong here
 5512:         assert_(result is not np.ma.masked)
 5513:         assert_(not isinstance(result, np.ma.core.MaskedConstant))
 5514:         assert_equal(result.shape, vector.shape)
 5515:         assert_equal(np.ma.getmask(result), np.ones(vector.shape, dtype=bool))
 5516: 
 5517:     def test_ufunc(self):
 5518:         self._do_add_test(np.add)
 5519: 
 5520:     def test_operator(self):
 5521:         self._do_add_test(lambda a, b: a + b)
 5522: 
 5523:     def test_ctor(self):
 5524:         m = np.ma.array(np.ma.masked)
 5525: 
 5526:         # most importantly, we do not want to create a new MaskedConstant
 5527:         # instance
 5528:         assert_(not isinstance(m, np.ma.core.MaskedConstant))
 5529:         assert_(m is not np.ma.masked)
 5530: 
 5531:     def test_repr(self):
 5532:         # copies should not exist, but if they do, it should be obvious that
 5533:         # something is wrong
 5534:         assert_equal(repr(np.ma.masked), 'masked')
 5535: 
 5536:         # create a new instance in a weird way
 5537:         masked2 = np.ma.MaskedArray.__new__(np.ma.core.MaskedConstant)
 5538:         assert_not_equal(repr(masked2), 'masked')
 5539: 
 5540:     def test_pickle(self):
 5541:         from io import BytesIO
 5542: 
 5543:         for proto in range(2, pickle.HIGHEST_PROTOCOL + 1):
 5544:             with BytesIO() as f:
 5545:                 pickle.dump(np.ma.masked, f, protocol=proto)
 5546:                 f.seek(0)
 5547:                 res = pickle.load(f)
 5548:             assert_(res is np.ma.masked)
 5549: 
 5550:     def test_copy(self):
 5551:         # gh-9328
 5552:         # copy is a no-op, like it is with np.True_
 5553:         assert_equal(
 5554:             np.ma.masked.copy() is np.ma.masked,
 5555:             np.True_.copy() is np.True_)
 5556: 
 5557:     def test__copy(self):
 5558:         import copy
 5559:         assert_(
 5560:             copy.copy(np.ma.masked) is np.ma.masked)
 5561: 
 5562:     def test_deepcopy(self):
 5563:         import copy
 5564:         assert_(
 5565:             copy.deepcopy(np.ma.masked) is np.ma.masked)
 5566: 
 5567:     def test_immutable(self):
 5568:         orig = np.ma.masked
 5569:         assert_raises(np.ma.core.MaskError, operator.setitem, orig, (), 1)
 5570:         assert_raises(ValueError, operator.setitem, orig.data, (), 1)
 5571:         assert_raises(ValueError, operator.setitem, orig.mask, (), False)
 5572: 
 5573:         view = np.ma.masked.view(np.ma.MaskedArray)
 5574:         assert_raises(ValueError, operator.setitem, view, (), 1)
 5575:         assert_raises(ValueError, operator.setitem, view.data, (), 1)
 5576:         assert_raises(ValueError, operator.setitem, view.mask, (), False)
 5577: 
 5578:     def test_coercion_int(self):
 5579:         a_i = np.zeros((), int)
 5580:         assert_raises(MaskError, operator.setitem, a_i, (), np.ma.masked)
 5581:         assert_raises(MaskError, int, np.ma.masked)
 5582: 
 5583:     def test_coercion_float(self):
 5584:         a_f = np.zeros((), float)
 5585:         assert_warns(UserWarning, operator.setitem, a_f, (), np.ma.masked)
 5586:         assert_(np.isnan(a_f[()]))
 5587: 
 5588:     @pytest.mark.xfail(reason="See gh-9750")
 5589:     def test_coercion_unicode(self):
 5590:         a_u = np.zeros((), 'U10')
 5591:         a_u[()] = np.ma.masked
 5592:         assert_equal(a_u[()], '--')
 5593: 
 5594:     @pytest.mark.xfail(reason="See gh-9750")
 5595:     def test_coercion_bytes(self):
 5596:         a_b = np.zeros((), 'S10')
 5597:         a_b[()] = np.ma.masked
 5598:         assert_equal(a_b[()], b'--')
 5599: 
 5600:     def test_subclass(self):
 5601:         # https://github.com/astropy/astropy/issues/6645
 5602:         class Sub(type(np.ma.masked)):
 5603:             pass
 5604: 
 5605:         a = Sub()
 5606:         assert_(a is Sub())
 5607:         assert_(a is not np.ma.masked)
 5608:         assert_not_equal(repr(a), 'masked')
 5609: 
 5610:     def test_attributes_readonly(self):
 5611:         assert_raises(AttributeError, setattr, np.ma.masked, 'shape', (1,))
 5612:         assert_raises(AttributeError, setattr, np.ma.masked, 'dtype', np.int64)
 5613: 
 5614: 
 5615: class TestMaskedWhereAliases:
 5616: 
 5617:     # TODO: Test masked_object, masked_equal, ...
 5618: 
 5619:     def test_masked_values(self):
 5620:         res = masked_values(np.array([-32768.0]), np.int16(-32768))
 5621:         assert_equal(res.mask, [True])
 5622: 
 5623:         res = masked_values(np.inf, np.inf)
 5624:         assert_equal(res.mask, True)
 5625: 
 5626:         res = np.ma.masked_values(np.inf, -np.inf)
 5627:         assert_equal(res.mask, False)
 5628: 
 5629:         res = np.ma.masked_values([1, 2, 3, 4], 5, shrink=True)
 5630:         assert_(res.mask is np.ma.nomask)
 5631: 
 5632:         res = np.ma.masked_values([1, 2, 3, 4], 5, shrink=False)
 5633:         assert_equal(res.mask, [False] * 4)
 5634: 
 5635: 
 5636: def test_masked_array():
 5637:     a = np.ma.array([0, 1, 2, 3], mask=[0, 0, 1, 0])
 5638:     assert_equal(np.argwhere(a), [[1], [3]])
 5639: 
 5640: def test_masked_array_no_copy():
 5641:     # check nomask array is updated in place
 5642:     a = np.ma.array([1, 2, 3, 4])
 5643:     _ = np.ma.masked_where(a == 3, a, copy=False)
 5644:     assert_array_equal(a.mask, [False, False, True, False])
 5645:     # check masked array is updated in place
 5646:     a = np.ma.array([1, 2, 3, 4], mask=[1, 0, 0, 0])
 5647:     _ = np.ma.masked_where(a == 3, a, copy=False)
 5648:     assert_array_equal(a.mask, [True, False, True, False])
 5649:     # check masked array with masked_invalid is updated in place
 5650:     a = np.ma.array([np.inf, 1, 2, 3, 4])
 5651:     _ = np.ma.masked_invalid(a, copy=False)
 5652:     assert_array_equal(a.mask, [True, False, False, False, False])
 5653: 
 5654: def test_append_masked_array():
 5655:     a = np.ma.masked_equal([1, 2, 3], value=2)
 5656:     b = np.ma.masked_equal([4, 3, 2], value=2)
 5657: 
 5658:     result = np.ma.append(a, b)
 5659:     expected_data = [1, 2, 3, 4, 3, 2]
 5660:     expected_mask = [False, True, False, False, False, True]
 5661:     assert_array_equal(result.data, expected_data)
 5662:     assert_array_equal(result.mask, expected_mask)
 5663: 
 5664:     a = np.ma.masked_all((2, 2))
 5665:     b = np.ma.ones((3, 1))
 5666: 
 5667:     result = np.ma.append(a, b)
 5668:     expected_data = [1] * 3
 5669:     expected_mask = [True] * 4 + [False] * 3
 5670:     assert_array_equal(result.data[-3], expected_data)
 5671:     assert_array_equal(result.mask, expected_mask)
 5672: 
 5673:     result = np.ma.append(a, b, axis=None)
 5674:     assert_array_equal(result.data[-3], expected_data)
 5675:     assert_array_equal(result.mask, expected_mask)
 5676: 
 5677: 
 5678: def test_append_masked_array_along_axis():
 5679:     a = np.ma.masked_equal([1, 2, 3], value=2)
 5680:     b = np.ma.masked_values([[4, 5, 6], [7, 8, 9]], 7)
 5681: 
 5682:     # When `axis` is specified, `values` must have the correct shape.
 5683:     assert_raises(ValueError, np.ma.append, a, b, axis=0)
 5684: 
 5685:     result = np.ma.append(a[np.newaxis, :], b, axis=0)
 5686:     expected = np.ma.arange(1, 10)
 5687:     expected[[1, 6]] = np.ma.masked
 5688:     expected = expected.reshape((3, 3))
 5689:     assert_array_equal(result.data, expected.data)
 5690:     assert_array_equal(result.mask, expected.mask)
 5691: 
 5692: def test_default_fill_value_complex():
 5693:     # regression test for Python 3, where 'unicode' was not defined
 5694:     assert_(default_fill_value(1 + 1j) == 1.e20 + 0.0j)
 5695: 
 5696: 
 5697: def test_ufunc_with_output():
 5698:     # check that giving an output argument always returns that output.
 5699:     # Regression test for gh-8416.
 5700:     x = array([1., 2., 3.], mask=[0, 0, 1])
 5701:     y = np.add(x, 1., out=x)
 5702:     assert_(y is x)
 5703: 
 5704: 
 5705: def test_ufunc_with_out_varied():
 5706:     """ Test that masked arrays are immune to gh-10459 """
 5707:     # the mask of the output should not affect the result, however it is passed
 5708:     a = array([ 1,  2,  3], mask=[1, 0, 0])
 5709:     b = array([10, 20, 30], mask=[1, 0, 0])
 5710:     out = array([ 0,  0,  0], mask=[0, 0, 1])
 5711:     expected = array([11, 22, 33], mask=[1, 0, 0])
 5712: 
 5713:     out_pos = out.copy()
 5714:     res_pos = np.add(a, b, out_pos)
 5715: 
 5716:     out_kw = out.copy()
 5717:     res_kw = np.add(a, b, out=out_kw)
 5718: 
 5719:     out_tup = out.copy()
 5720:     res_tup = np.add(a, b, out=(out_tup,))
 5721: 
 5722:     assert_equal(res_kw.mask,  expected.mask)
 5723:     assert_equal(res_kw.data,  expected.data)
 5724:     assert_equal(res_tup.mask, expected.mask)
 5725:     assert_equal(res_tup.data, expected.data)
 5726:     assert_equal(res_pos.mask, expected.mask)
 5727:     assert_equal(res_pos.data, expected.data)
 5728: 
 5729: 
 5730: def test_astype_mask_ordering():
 5731:     descr = np.dtype([('v', int, 3), ('x', [('y', float)])])
 5732:     x = array([
 5733:         [([1, 2, 3], (1.0,)),  ([1, 2, 3], (2.0,))],
 5734:         [([1, 2, 3], (3.0,)),  ([1, 2, 3], (4.0,))]], dtype=descr)
 5735:     x[0]['v'][0] = np.ma.masked
 5736: 
 5737:     x_a = x.astype(descr)
 5738:     assert x_a.dtype.names == np.dtype(descr).names
 5739:     assert x_a.mask.dtype.names == np.dtype(descr).names
 5740:     assert_equal(x, x_a)
 5741: 
 5742:     assert_(x is x.astype(x.dtype, copy=False))
 5743:     assert_equal(type(x.astype(x.dtype, subok=False)), np.ndarray)
 5744: 
 5745:     x_f = x.astype(x.dtype, order='F')
 5746:     assert_(x_f.flags.f_contiguous)
 5747:     assert_(x_f.mask.flags.f_contiguous)
 5748: 
 5749:     # Also test the same indirectly, via np.array
 5750:     x_a2 = np.array(x, dtype=descr, subok=True)
 5751:     assert x_a2.dtype.names == np.dtype(descr).names
 5752:     assert x_a2.mask.dtype.names == np.dtype(descr).names
 5753:     assert_equal(x, x_a2)
 5754: 
 5755:     assert_(x is np.array(x, dtype=descr, copy=None, subok=True))
 5756: 
 5757:     x_f2 = np.array(x, dtype=x.dtype, order='F', subok=True)
 5758:     assert_(x_f2.flags.f_contiguous)
 5759:     assert_(x_f2.mask.flags.f_contiguous)
 5760: 
 5761: 
 5762: @pytest.mark.parametrize('dt1', num_dts, ids=num_ids)
 5763: @pytest.mark.parametrize('dt2', num_dts, ids=num_ids)
 5764: @pytest.mark.filterwarnings('ignore::numpy.exceptions.ComplexWarning')
 5765: def test_astype_basic(dt1, dt2):
 5766:     # See gh-12070
 5767:     src = np.ma.array(ones(3, dt1), fill_value=1)
 5768:     dst = src.astype(dt2)
 5769: 
 5770:     assert_(src.fill_value == 1)
 5771:     assert_(src.dtype == dt1)
 5772:     assert_(src.fill_value.dtype == dt1)
 5773: 
 5774:     assert_(dst.fill_value == 1)
 5775:     assert_(dst.dtype == dt2)
 5776:     assert_(dst.fill_value.dtype == dt2)
 5777: 
 5778:     assert_equal(src, dst)
 5779: 
 5780: 
 5781: def test_fieldless_void():
 5782:     dt = np.dtype([])  # a void dtype with no fields
 5783:     x = np.empty(4, dt)
 5784: 
 5785:     # these arrays contain no values, so there's little to test - but this
 5786:     # shouldn't crash
 5787:     mx = np.ma.array(x)
 5788:     assert_equal(mx.dtype, x.dtype)
 5789:     assert_equal(mx.shape, x.shape)
 5790: 
 5791:     mx = np.ma.array(x, mask=x)
 5792:     assert_equal(mx.dtype, x.dtype)
 5793:     assert_equal(mx.shape, x.shape)
 5794: 
 5795: 
 5796: def test_mask_shape_assignment_does_not_break_masked():
 5797:     a = np.ma.masked
 5798:     b = np.ma.array(1, mask=a.mask)
 5799:     b.shape = (1,)
 5800:     assert_equal(a.mask.shape, ())
 5801: 
 5802: @pytest.mark.skipif(sys.flags.optimize > 1,
 5803:                     reason="no docstrings present to inspect when PYTHONOPTIMIZE/Py_OptimizeFlag > 1")  # noqa: E501
 5804: def test_doc_note():
 5805:     def method(self):
 5806:         """This docstring
 5807: 
 5808:         Has multiple lines
 5809: 
 5810:         And notes
 5811: 
 5812:         Notes
 5813:         -----
 5814:         original note
 5815:         """
 5816:         pass
 5817: 
 5818:     expected_doc = """This docstring
 5819: 
 5820: Has multiple lines
 5821: 
 5822: And notes
 5823: 
 5824: Notes
 5825: -----
 5826: note
 5827: 
 5828: original note"""
 5829: 
 5830:     assert_equal(np.ma.core.doc_note(method.__doc__, "note"), expected_doc)
 5831: 
 5832: 
 5833: def test_gh_22556():
 5834:     source = np.ma.array([0, [0, 1, 2]], dtype=object)
 5835:     deepcopy = copy.deepcopy(source)
 5836:     deepcopy[1].append('this should not appear in source')
 5837:     assert len(source[1]) == 3
 5838: 
 5839: 
 5840: def test_gh_21022():
 5841:     # testing for absence of reported error
 5842:     source = np.ma.masked_array(data=[-1, -1], mask=True, dtype=np.float64)
 5843:     axis = np.array(0)
 5844:     result = np.prod(source, axis=axis, keepdims=False)
 5845:     result = np.ma.masked_array(result,
 5846:                                 mask=np.ones(result.shape, dtype=np.bool))
 5847:     array = np.ma.masked_array(data=-1, mask=True, dtype=np.float64)
 5848:     copy.deepcopy(array)
 5849:     copy.deepcopy(result)
 5850: 
 5851: 
 5852: def test_deepcopy_2d_obj():
 5853:     source = np.ma.array([[0, "dog"],
 5854:                           [1, 1],
 5855:                           [[1, 2], "cat"]],
 5856:                         mask=[[0, 1],
 5857:                               [0, 0],
 5858:                               [0, 0]],
 5859:                         dtype=object)
 5860:     deepcopy = copy.deepcopy(source)
 5861:     deepcopy[2, 0].extend(['this should not appear in source', 3])
 5862:     assert len(source[2, 0]) == 2
 5863:     assert len(deepcopy[2, 0]) == 4
 5864:     assert_equal(deepcopy._mask, source._mask)
 5865:     deepcopy._mask[0, 0] = 1
 5866:     assert source._mask[0, 0] == 0
 5867: 
 5868: 
 5869: def test_deepcopy_0d_obj():
 5870:     source = np.ma.array(0, mask=[0], dtype=object)
 5871:     deepcopy = copy.deepcopy(source)
 5872:     deepcopy[...] = 17
 5873:     assert_equal(source, 0)
 5874:     assert_equal(deepcopy, 17)
 5875: 
 5876: 
 5877: def test_uint_fill_value_and_filled():
 5878:     # See also gh-27269
 5879:     a = np.ma.MaskedArray([1, 1], [True, False], dtype="uint16")
 5880:     # the fill value should likely not be 99999, but for now guarantee it:
 5881:     assert a.fill_value == 999999
 5882:     # However, it's type is uint:
 5883:     assert a.fill_value.dtype.kind == "u"
 5884:     # And this ensures things like filled work:
 5885:     np.testing.assert_array_equal(
 5886:         a.filled(), np.array([999999, 1]).astype("uint16"), strict=True)
