    1: """Tests suite for MaskedArray & subclassing.
    2: 
    3: :author: Pierre Gerard-Marchant
    4: :contact: pierregm_at_uga_dot_edu
    5: 
    6: """
    7: import numpy as np
    8: from numpy.lib.mixins import NDArrayOperatorsMixin
    9: from numpy.ma.core import (
   10:     MaskedArray,
   11:     add,
   12:     arange,
   13:     array,
   14:     asanyarray,
   15:     asarray,
   16:     divide,
   17:     hypot,
   18:     log,
   19:     masked,
   20:     masked_array,
   21:     nomask,
   22: )
   23: from numpy.ma.testutils import assert_equal
   24: from numpy.testing import assert_, assert_raises
   25: 
   26: # from numpy.ma.core import (
   27: 
   28: def assert_startswith(a, b):
   29:     # produces a better error message than assert_(a.startswith(b))
   30:     assert_equal(a[:len(b)], b)
   31: 
   32: class SubArray(np.ndarray):
   33:     # Defines a generic np.ndarray subclass, that stores some metadata
   34:     # in the  dictionary `info`.
   35:     def __new__(cls, arr, info={}):
   36:         x = np.asanyarray(arr).view(cls)
   37:         x.info = info.copy()
   38:         return x
   39: 
   40:     def __array_finalize__(self, obj):
   41:         super().__array_finalize__(obj)
   42:         self.info = getattr(obj, 'info', {}).copy()
   43: 
   44:     def __add__(self, other):
   45:         result = super().__add__(other)
   46:         result.info['added'] = result.info.get('added', 0) + 1
   47:         return result
   48: 
   49:     def __iadd__(self, other):
   50:         result = super().__iadd__(other)
   51:         result.info['iadded'] = result.info.get('iadded', 0) + 1
   52:         return result
   53: 
   54: 
   55: subarray = SubArray
   56: 
   57: 
   58: class SubMaskedArray(MaskedArray):
   59:     """Pure subclass of MaskedArray, keeping some info on subclass."""
   60:     def __new__(cls, info=None, **kwargs):
   61:         obj = super().__new__(cls, **kwargs)
   62:         obj._optinfo['info'] = info
   63:         return obj
   64: 
   65: 
   66: class MSubArray(SubArray, MaskedArray):
   67: 
   68:     def __new__(cls, data, info={}, mask=nomask):
   69:         subarr = SubArray(data, info)
   70:         _data = MaskedArray.__new__(cls, data=subarr, mask=mask)
   71:         _data.info = subarr.info
   72:         return _data
   73: 
   74:     @property
   75:     def _series(self):
   76:         _view = self.view(MaskedArray)
   77:         _view._sharedmask = False
   78:         return _view
   79: 
   80: 
   81: msubarray = MSubArray
   82: 
   83: 
   84: # Also a subclass that overrides __str__, __repr__ and __setitem__, disallowing
   85: # setting to non-class values (and thus np.ma.core.masked_print_option)
   86: # and overrides __array_wrap__, updating the info dict, to check that this
   87: # doesn't get destroyed by MaskedArray._update_from.  But this one also needs
   88: # its own iterator...
   89: class CSAIterator:
   90:     """
   91:     Flat iterator object that uses its own setter/getter
   92:     (works around ndarray.flat not propagating subclass setters/getters
   93:     see https://github.com/numpy/numpy/issues/4564)
   94:     roughly following MaskedIterator
   95:     """
   96:     def __init__(self, a):
   97:         self._original = a
   98:         self._dataiter = a.view(np.ndarray).flat
   99: 
  100:     def __iter__(self):
  101:         return self
  102: 
  103:     def __getitem__(self, indx):
  104:         out = self._dataiter.__getitem__(indx)
  105:         if not isinstance(out, np.ndarray):
  106:             out = out.__array__()
  107:         out = out.view(type(self._original))
  108:         return out
  109: 
  110:     def __setitem__(self, index, value):
  111:         self._dataiter[index] = self._original._validate_input(value)
  112: 
  113:     def __next__(self):
  114:         return next(self._dataiter).__array__().view(type(self._original))
  115: 
  116: 
  117: class ComplicatedSubArray(SubArray):
  118: 
  119:     def __str__(self):
  120:         return f'myprefix {self.view(SubArray)} mypostfix'
  121: 
  122:     def __repr__(self):
  123:         # Return a repr that does not start with 'name('
  124:         return f'<{self.__class__.__name__} {self}>'
  125: 
  126:     def _validate_input(self, value):
  127:         if not isinstance(value, ComplicatedSubArray):
  128:             raise ValueError("Can only set to MySubArray values")
  129:         return value
  130: 
  131:     def __setitem__(self, item, value):
  132:         # validation ensures direct assignment with ndarray or
  133:         # masked_print_option will fail
  134:         super().__setitem__(item, self._validate_input(value))
  135: 
  136:     def __getitem__(self, item):
  137:         # ensure getter returns our own class also for scalars
  138:         value = super().__getitem__(item)
  139:         if not isinstance(value, np.ndarray):  # scalar
  140:             value = value.__array__().view(ComplicatedSubArray)
  141:         return value
  142: 
  143:     @property
  144:     def flat(self):
  145:         return CSAIterator(self)
  146: 
  147:     @flat.setter
  148:     def flat(self, value):
  149:         y = self.ravel()
  150:         y[:] = value
  151: 
  152:     def __array_wrap__(self, obj, context=None, return_scalar=False):
  153:         obj = super().__array_wrap__(obj, context, return_scalar)
  154:         if context is not None and context[0] is np.multiply:
  155:             obj.info['multiplied'] = obj.info.get('multiplied', 0) + 1
  156: 
  157:         return obj
  158: 
  159: 
  160: class WrappedArray(NDArrayOperatorsMixin):
  161:     """
  162:     Wrapping a MaskedArray rather than subclassing to test that
  163:     ufunc deferrals are commutative.
  164:     See: https://github.com/numpy/numpy/issues/15200)
  165:     """
  166:     __slots__ = ('_array', 'attrs')
  167:     __array_priority__ = 20
  168: 
  169:     def __init__(self, array, **attrs):
  170:         self._array = array
  171:         self.attrs = attrs
  172: 
  173:     def __repr__(self):
  174:         return f"{self.__class__.__name__}(\n{self._array}\n{self.attrs}\n)"
  175: 
  176:     def __array__(self, dtype=None, copy=None):
  177:         return np.asarray(self._array)
  178: 
  179:     def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):
  180:         if method == '__call__':
  181:             inputs = [arg._array if isinstance(arg, self.__class__) else arg
  182:                       for arg in inputs]
  183:             return self.__class__(ufunc(*inputs, **kwargs), **self.attrs)
  184:         else:
  185:             return NotImplemented
  186: 
  187: 
  188: class TestSubclassing:
  189:     # Test suite for masked subclasses of ndarray.
  190: 
  191:     def setup_method(self):
  192:         x = np.arange(5, dtype='float')
  193:         mx = msubarray(x, mask=[0, 1, 0, 0, 0])
  194:         self.data = (x, mx)
  195: 
  196:     def test_data_subclassing(self):
  197:         # Tests whether the subclass is kept.
  198:         x = np.arange(5)
  199:         m = [0, 0, 1, 0, 0]
  200:         xsub = SubArray(x)
  201:         xmsub = masked_array(xsub, mask=m)
  202:         assert_(isinstance(xmsub, MaskedArray))
  203:         assert_equal(xmsub._data, xsub)
  204:         assert_(isinstance(xmsub._data, SubArray))
  205: 
  206:     def test_maskedarray_subclassing(self):
  207:         # Tests subclassing MaskedArray
  208:         (x, mx) = self.data
  209:         assert_(isinstance(mx._data, subarray))
  210: 
  211:     def test_masked_unary_operations(self):
  212:         # Tests masked_unary_operation
  213:         (x, mx) = self.data
  214:         with np.errstate(divide='ignore'):
  215:             assert_(isinstance(log(mx), msubarray))
  216:             assert_equal(log(x), np.log(x))
  217: 
  218:     def test_masked_binary_operations(self):
  219:         # Tests masked_binary_operation
  220:         (x, mx) = self.data
  221:         # Result should be a msubarray
  222:         assert_(isinstance(add(mx, mx), msubarray))
  223:         assert_(isinstance(add(mx, x), msubarray))
  224:         # Result should work
  225:         assert_equal(add(mx, x), mx + x)
  226:         assert_(isinstance(add(mx, mx)._data, subarray))
  227:         assert_(isinstance(add.outer(mx, mx), msubarray))
  228:         assert_(isinstance(hypot(mx, mx), msubarray))
  229:         assert_(isinstance(hypot(mx, x), msubarray))
  230: 
  231:     def test_masked_binary_operations2(self):
  232:         # Tests domained_masked_binary_operation
  233:         (x, mx) = self.data
  234:         xmx = masked_array(mx.data.__array__(), mask=mx.mask)
  235:         assert_(isinstance(divide(mx, mx), msubarray))
  236:         assert_(isinstance(divide(mx, x), msubarray))
  237:         assert_equal(divide(mx, mx), divide(xmx, xmx))
  238: 
  239:     def test_attributepropagation(self):
  240:         x = array(arange(5), mask=[0] + [1] * 4)
  241:         my = masked_array(subarray(x))
  242:         ym = msubarray(x)
  243:         #
  244:         z = (my + 1)
  245:         assert_(isinstance(z, MaskedArray))
  246:         assert_(not isinstance(z, MSubArray))
  247:         assert_(isinstance(z._data, SubArray))
  248:         assert_equal(z._data.info, {})
  249:         #
  250:         z = (ym + 1)
  251:         assert_(isinstance(z, MaskedArray))
  252:         assert_(isinstance(z, MSubArray))
  253:         assert_(isinstance(z._data, SubArray))
  254:         assert_(z._data.info['added'] > 0)
  255:         # Test that inplace methods from data get used (gh-4617)
  256:         ym += 1
  257:         assert_(isinstance(ym, MaskedArray))
  258:         assert_(isinstance(ym, MSubArray))
  259:         assert_(isinstance(ym._data, SubArray))
  260:         assert_(ym._data.info['iadded'] > 0)
  261:         #
  262:         ym._set_mask([1, 0, 0, 0, 1])
  263:         assert_equal(ym._mask, [1, 0, 0, 0, 1])
  264:         ym._series._set_mask([0, 0, 0, 0, 1])
  265:         assert_equal(ym._mask, [0, 0, 0, 0, 1])
  266:         #
  267:         xsub = subarray(x, info={'name': 'x'})
  268:         mxsub = masked_array(xsub)
  269:         assert_(hasattr(mxsub, 'info'))
  270:         assert_equal(mxsub.info, xsub.info)
  271: 
  272:     def test_subclasspreservation(self):
  273:         # Checks that masked_array(...,subok=True) preserves the class.
  274:         x = np.arange(5)
  275:         m = [0, 0, 1, 0, 0]
  276:         xinfo = list(zip(x, m))
  277:         xsub = MSubArray(x, mask=m, info={'xsub': xinfo})
  278:         #
  279:         mxsub = masked_array(xsub, subok=False)
  280:         assert_(not isinstance(mxsub, MSubArray))
  281:         assert_(isinstance(mxsub, MaskedArray))
  282:         assert_equal(mxsub._mask, m)
  283:         #
  284:         mxsub = asarray(xsub)
  285:         assert_(not isinstance(mxsub, MSubArray))
  286:         assert_(isinstance(mxsub, MaskedArray))
  287:         assert_equal(mxsub._mask, m)
  288:         #
  289:         mxsub = masked_array(xsub, subok=True)
  290:         assert_(isinstance(mxsub, MSubArray))
  291:         assert_equal(mxsub.info, xsub.info)
  292:         assert_equal(mxsub._mask, xsub._mask)
  293:         #
  294:         mxsub = asanyarray(xsub)
  295:         assert_(isinstance(mxsub, MSubArray))
  296:         assert_equal(mxsub.info, xsub.info)
  297:         assert_equal(mxsub._mask, m)
  298: 
  299:     def test_subclass_items(self):
  300:         """test that getter and setter go via baseclass"""
  301:         x = np.arange(5)
  302:         xcsub = ComplicatedSubArray(x)
  303:         mxcsub = masked_array(xcsub, mask=[True, False, True, False, False])
  304:         # getter should  return a ComplicatedSubArray, even for single item
  305:         # first check we wrote ComplicatedSubArray correctly
  306:         assert_(isinstance(xcsub[1], ComplicatedSubArray))
  307:         assert_(isinstance(xcsub[1, ...], ComplicatedSubArray))
  308:         assert_(isinstance(xcsub[1:4], ComplicatedSubArray))
  309: 
  310:         # now that it propagates inside the MaskedArray
  311:         assert_(isinstance(mxcsub[1], ComplicatedSubArray))
  312:         assert_(isinstance(mxcsub[1, ...].data, ComplicatedSubArray))
  313:         assert_(mxcsub[0] is masked)
  314:         assert_(isinstance(mxcsub[0, ...].data, ComplicatedSubArray))
  315:         assert_(isinstance(mxcsub[1:4].data, ComplicatedSubArray))
  316: 
  317:         # also for flattened version (which goes via MaskedIterator)
  318:         assert_(isinstance(mxcsub.flat[1].data, ComplicatedSubArray))
  319:         assert_(mxcsub.flat[0] is masked)
  320:         assert_(isinstance(mxcsub.flat[1:4].base, ComplicatedSubArray))
  321: 
  322:         # setter should only work with ComplicatedSubArray input
  323:         # first check we wrote ComplicatedSubArray correctly
  324:         assert_raises(ValueError, xcsub.__setitem__, 1, x[4])
  325:         # now that it propagates inside the MaskedArray
  326:         assert_raises(ValueError, mxcsub.__setitem__, 1, x[4])
  327:         assert_raises(ValueError, mxcsub.__setitem__, slice(1, 4), x[1:4])
  328:         mxcsub[1] = xcsub[4]
  329:         mxcsub[1:4] = xcsub[1:4]
  330:         # also for flattened version (which goes via MaskedIterator)
  331:         assert_raises(ValueError, mxcsub.flat.__setitem__, 1, x[4])
  332:         assert_raises(ValueError, mxcsub.flat.__setitem__, slice(1, 4), x[1:4])
  333:         mxcsub.flat[1] = xcsub[4]
  334:         mxcsub.flat[1:4] = xcsub[1:4]
  335: 
  336:     def test_subclass_nomask_items(self):
  337:         x = np.arange(5)
  338:         xcsub = ComplicatedSubArray(x)
  339:         mxcsub_nomask = masked_array(xcsub)
  340: 
  341:         assert_(isinstance(mxcsub_nomask[1, ...].data, ComplicatedSubArray))
  342:         assert_(isinstance(mxcsub_nomask[0, ...].data, ComplicatedSubArray))
  343: 
  344:         assert_(isinstance(mxcsub_nomask[1], ComplicatedSubArray))
  345:         assert_(isinstance(mxcsub_nomask[0], ComplicatedSubArray))
  346: 
  347:     def test_subclass_repr(self):
  348:         """test that repr uses the name of the subclass
  349:         and 'array' for np.ndarray"""
  350:         x = np.arange(5)
  351:         mx = masked_array(x, mask=[True, False, True, False, False])
  352:         assert_startswith(repr(mx), 'masked_array')
  353:         xsub = SubArray(x)
  354:         mxsub = masked_array(xsub, mask=[True, False, True, False, False])
  355:         assert_startswith(repr(mxsub),
  356:             f'masked_{SubArray.__name__}(data=[--, 1, --, 3, 4]')
  357: 
  358:     def test_subclass_str(self):
  359:         """test str with subclass that has overridden str, setitem"""
  360:         # first without override
  361:         x = np.arange(5)
  362:         xsub = SubArray(x)
  363:         mxsub = masked_array(xsub, mask=[True, False, True, False, False])
  364:         assert_equal(str(mxsub), '[-- 1 -- 3 4]')
  365: 
  366:         xcsub = ComplicatedSubArray(x)
  367:         assert_raises(ValueError, xcsub.__setitem__, 0,
  368:                       np.ma.core.masked_print_option)
  369:         mxcsub = masked_array(xcsub, mask=[True, False, True, False, False])
  370:         assert_equal(str(mxcsub), 'myprefix [-- 1 -- 3 4] mypostfix')
  371: 
  372:     def test_pure_subclass_info_preservation(self):
  373:         # Test that ufuncs and methods conserve extra information consistently;
  374:         # see gh-7122.
  375:         arr1 = SubMaskedArray('test', data=[1, 2, 3, 4, 5, 6])
  376:         arr2 = SubMaskedArray(data=[0, 1, 2, 3, 4, 5])
  377:         diff1 = np.subtract(arr1, arr2)
  378:         assert_('info' in diff1._optinfo)
  379:         assert_(diff1._optinfo['info'] == 'test')
  380:         diff2 = arr1 - arr2
  381:         assert_('info' in diff2._optinfo)
  382:         assert_(diff2._optinfo['info'] == 'test')
  383: 
  384: 
  385: class ArrayNoInheritance:
  386:     """Quantity-like class that does not inherit from ndarray"""
  387:     def __init__(self, data, units):
  388:         self.magnitude = data
  389:         self.units = units
  390: 
  391:     def __getattr__(self, attr):
  392:         return getattr(self.magnitude, attr)
  393: 
  394: 
  395: def test_array_no_inheritance():
  396:     data_masked = np.ma.array([1, 2, 3], mask=[True, False, True])
  397:     data_masked_units = ArrayNoInheritance(data_masked, 'meters')
  398: 
  399:     # Get the masked representation of the Quantity-like class
  400:     new_array = np.ma.array(data_masked_units)
  401:     assert_equal(data_masked.data, new_array.data)
  402:     assert_equal(data_masked.mask, new_array.mask)
  403:     # Test sharing the mask
  404:     data_masked.mask = [True, False, False]
  405:     assert_equal(data_masked.mask, new_array.mask)
  406:     assert_(new_array.sharedmask)
  407: 
  408:     # Get the masked representation of the Quantity-like class
  409:     new_array = np.ma.array(data_masked_units, copy=True)
  410:     assert_equal(data_masked.data, new_array.data)
  411:     assert_equal(data_masked.mask, new_array.mask)
  412:     # Test that the mask is not shared when copy=True
  413:     data_masked.mask = [True, False, True]
  414:     assert_equal([True, False, False], new_array.mask)
  415:     assert_(not new_array.sharedmask)
  416: 
  417:     # Get the masked representation of the Quantity-like class
  418:     new_array = np.ma.array(data_masked_units, keep_mask=False)
  419:     assert_equal(data_masked.data, new_array.data)
  420:     # The change did not affect the original mask
  421:     assert_equal(data_masked.mask, [True, False, True])
  422:     # Test that the mask is False and not shared when keep_mask=False
  423:     assert_(not new_array.mask)
  424:     assert_(not new_array.sharedmask)
  425: 
  426: 
  427: class TestClassWrapping:
  428:     # Test suite for classes that wrap MaskedArrays
  429: 
  430:     def setup_method(self):
  431:         m = np.ma.masked_array([1, 3, 5], mask=[False, True, False])
  432:         wm = WrappedArray(m)
  433:         self.data = (m, wm)
  434: 
  435:     def test_masked_unary_operations(self):
  436:         # Tests masked_unary_operation
  437:         (m, wm) = self.data
  438:         with np.errstate(divide='ignore'):
  439:             assert_(isinstance(np.log(wm), WrappedArray))
  440: 
  441:     def test_masked_binary_operations(self):
  442:         # Tests masked_binary_operation
  443:         (m, wm) = self.data
  444:         # Result should be a WrappedArray
  445:         assert_(isinstance(np.add(wm, wm), WrappedArray))
  446:         assert_(isinstance(np.add(m, wm), WrappedArray))
  447:         assert_(isinstance(np.add(wm, m), WrappedArray))
  448:         # add and '+' should call the same ufunc
  449:         assert_equal(np.add(m, wm), m + wm)
  450:         assert_(isinstance(np.hypot(m, wm), WrappedArray))
  451:         assert_(isinstance(np.hypot(wm, m), WrappedArray))
  452:         # Test domained binary operations
  453:         assert_(isinstance(np.divide(wm, m), WrappedArray))
  454:         assert_(isinstance(np.divide(m, wm), WrappedArray))
  455:         assert_equal(np.divide(wm, m) * m, np.divide(m, m) * wm)
  456:         # Test broadcasting
  457:         m2 = np.stack([m, m])
  458:         assert_(isinstance(np.divide(wm, m2), WrappedArray))
  459:         assert_(isinstance(np.divide(m2, wm), WrappedArray))
  460:         assert_equal(np.divide(m2, wm), np.divide(wm, m2))
  461: 
  462:     def test_mixins_have_slots(self):
  463:         mixin = NDArrayOperatorsMixin()
  464:         # Should raise an error
  465:         assert_raises(AttributeError, mixin.__setattr__, "not_a_real_attr", 1)
  466: 
  467:         m = np.ma.masked_array([1, 3, 5], mask=[False, True, False])
  468:         wm = WrappedArray(m)
  469:         assert_raises(AttributeError, wm.__setattr__, "not_an_attr", 2)
