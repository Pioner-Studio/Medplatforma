    1: """:mod:`numpy.ma..mrecords`
    2: 
    3: Defines the equivalent of :class:`numpy.recarrays` for masked arrays,
    4: where fields can be accessed as attributes.
    5: Note that :class:`numpy.ma.MaskedArray` already supports structured datatypes
    6: and the masking of individual fields.
    7: 
    8: .. moduleauthor:: Pierre Gerard-Marchant
    9: 
   10: """
   11: #  We should make sure that no field is called '_mask','mask','_fieldmask',
   12: #  or whatever restricted keywords.  An idea would be to no bother in the
   13: #  first place, and then rename the invalid fields with a trailing
   14: #  underscore. Maybe we could just overload the parser function ?
   15: 
   16: import warnings
   17: 
   18: import numpy as np
   19: import numpy.ma as ma
   20: 
   21: _byteorderconv = np._core.records._byteorderconv
   22: 
   23: 
   24: _check_fill_value = ma.core._check_fill_value
   25: 
   26: 
   27: __all__ = [
   28:     'MaskedRecords', 'mrecarray', 'fromarrays', 'fromrecords',
   29:     'fromtextfile', 'addfield',
   30: ]
   31: 
   32: reserved_fields = ['_data', '_mask', '_fieldmask', 'dtype']
   33: 
   34: 
   35: def _checknames(descr, names=None):
   36:     """
   37:     Checks that field names ``descr`` are not reserved keywords.
   38: 
   39:     If this is the case, a default 'f%i' is substituted.  If the argument
   40:     `names` is not None, updates the field names to valid names.
   41: 
   42:     """
   43:     ndescr = len(descr)
   44:     default_names = [f'f{i}' for i in range(ndescr)]
   45:     if names is None:
   46:         new_names = default_names
   47:     else:
   48:         if isinstance(names, (tuple, list)):
   49:             new_names = names
   50:         elif isinstance(names, str):
   51:             new_names = names.split(',')
   52:         else:
   53:             raise NameError(f'illegal input names {names!r}')
   54:         nnames = len(new_names)
   55:         if nnames < ndescr:
   56:             new_names += default_names[nnames:]
   57:     ndescr = []
   58:     for (n, d, t) in zip(new_names, default_names, descr.descr):
   59:         if n in reserved_fields:
   60:             if t[0] in reserved_fields:
   61:                 ndescr.append((d, t[1]))
   62:             else:
   63:                 ndescr.append(t)
   64:         else:
   65:             ndescr.append((n, t[1]))
   66:     return np.dtype(ndescr)
   67: 
   68: 
   69: def _get_fieldmask(self):
   70:     mdescr = [(n, '|b1') for n in self.dtype.names]
   71:     fdmask = np.empty(self.shape, dtype=mdescr)
   72:     fdmask.flat = tuple([False] * len(mdescr))
   73:     return fdmask
   74: 
   75: 
   76: class MaskedRecords(ma.MaskedArray):
   77:     """
   78: 
   79:     Attributes
   80:     ----------
   81:     _data : recarray
   82:         Underlying data, as a record array.
   83:     _mask : boolean array
   84:         Mask of the records. A record is masked when all its fields are
   85:         masked.
   86:     _fieldmask : boolean recarray
   87:         Record array of booleans, setting the mask of each individual field
   88:         of each record.
   89:     _fill_value : record
   90:         Filling values for each field.
   91: 
   92:     """
   93: 
   94:     def __new__(cls, shape, dtype=None, buf=None, offset=0, strides=None,
   95:                 formats=None, names=None, titles=None,
   96:                 byteorder=None, aligned=False,
   97:                 mask=ma.nomask, hard_mask=False, fill_value=None, keep_mask=True,
   98:                 copy=False,
   99:                 **options):
  100: 
  101:         self = np.recarray.__new__(cls, shape, dtype=dtype, buf=buf, offset=offset,
  102:                                    strides=strides, formats=formats, names=names,
  103:                                    titles=titles, byteorder=byteorder,
  104:                                    aligned=aligned,)
  105: 
  106:         mdtype = ma.make_mask_descr(self.dtype)
  107:         if mask is ma.nomask or not np.size(mask):
  108:             if not keep_mask:
  109:                 self._mask = tuple([False] * len(mdtype))
  110:         else:
  111:             mask = np.array(mask, copy=copy)
  112:             if mask.shape != self.shape:
  113:                 (nd, nm) = (self.size, mask.size)
  114:                 if nm == 1:
  115:                     mask = np.resize(mask, self.shape)
  116:                 elif nm == nd:
  117:                     mask = np.reshape(mask, self.shape)
  118:                 else:
  119:                     msg = (f"Mask and data not compatible: data size is {nd},"
  120:                            " mask size is {nm}.")
  121:                     raise ma.MAError(msg)
  122:             if not keep_mask:
  123:                 self.__setmask__(mask)
  124:                 self._sharedmask = True
  125:             else:
  126:                 if mask.dtype == mdtype:
  127:                     _mask = mask
  128:                 else:
  129:                     _mask = np.array([tuple([m] * len(mdtype)) for m in mask],
  130:                                      dtype=mdtype)
  131:                 self._mask = _mask
  132:         return self
  133: 
  134:     def __array_finalize__(self, obj):
  135:         # Make sure we have a _fieldmask by default
  136:         _mask = getattr(obj, '_mask', None)
  137:         if _mask is None:
  138:             objmask = getattr(obj, '_mask', ma.nomask)
  139:             _dtype = np.ndarray.__getattribute__(self, 'dtype')
  140:             if objmask is ma.nomask:
  141:                 _mask = ma.make_mask_none(self.shape, dtype=_dtype)
  142:             else:
  143:                 mdescr = ma.make_mask_descr(_dtype)
  144:                 _mask = np.array([tuple([m] * len(mdescr)) for m in objmask],
  145:                                dtype=mdescr).view(np.recarray)
  146:         # Update some of the attributes
  147:         _dict = self.__dict__
  148:         _dict.update(_mask=_mask)
  149:         self._update_from(obj)
  150:         if _dict['_baseclass'] == np.ndarray:
  151:             _dict['_baseclass'] = np.recarray
  152: 
  153:     @property
  154:     def _data(self):
  155:         """
  156:         Returns the data as a recarray.
  157: 
  158:         """
  159:         return np.ndarray.view(self, np.recarray)
  160: 
  161:     @property
  162:     def _fieldmask(self):
  163:         """
  164:         Alias to mask.
  165: 
  166:         """
  167:         return self._mask
  168: 
  169:     def __len__(self):
  170:         """
  171:         Returns the length
  172: 
  173:         """
  174:         # We have more than one record
  175:         if self.ndim:
  176:             return len(self._data)
  177:         # We have only one record: return the nb of fields
  178:         return len(self.dtype)
  179: 
  180:     def __getattribute__(self, attr):
  181:         try:
  182:             return object.__getattribute__(self, attr)
  183:         except AttributeError:
  184:             # attr must be a fieldname
  185:             pass
  186:         fielddict = np.ndarray.__getattribute__(self, 'dtype').fields
  187:         try:
  188:             res = fielddict[attr][:2]
  189:         except (TypeError, KeyError) as e:
  190:             raise AttributeError(
  191:                 f'record array has no attribute {attr}') from e
  192:         # So far, so good
  193:         _localdict = np.ndarray.__getattribute__(self, '__dict__')
  194:         _data = np.ndarray.view(self, _localdict['_baseclass'])
  195:         obj = _data.getfield(*res)
  196:         if obj.dtype.names is not None:
  197:             raise NotImplementedError("MaskedRecords is currently limited to"
  198:                                       "simple records.")
  199:         # Get some special attributes
  200:         # Reset the object's mask
  201:         hasmasked = False
  202:         _mask = _localdict.get('_mask', None)
  203:         if _mask is not None:
  204:             try:
  205:                 _mask = _mask[attr]
  206:             except IndexError:
  207:                 # Couldn't find a mask: use the default (nomask)
  208:                 pass
  209:             tp_len = len(_mask.dtype)
  210:             hasmasked = _mask.view((bool, ((tp_len,) if tp_len else ()))).any()
  211:         if (obj.shape or hasmasked):
  212:             obj = obj.view(ma.MaskedArray)
  213:             obj._baseclass = np.ndarray
  214:             obj._isfield = True
  215:             obj._mask = _mask
  216:             # Reset the field values
  217:             _fill_value = _localdict.get('_fill_value', None)
  218:             if _fill_value is not None:
  219:                 try:
  220:                     obj._fill_value = _fill_value[attr]
  221:                 except ValueError:
  222:                     obj._fill_value = None
  223:         else:
  224:             obj = obj.item()
  225:         return obj
  226: 
  227:     def __setattr__(self, attr, val):
  228:         """
  229:         Sets the attribute attr to the value val.
  230: 
  231:         """
  232:         # Should we call __setmask__ first ?
  233:         if attr in ['mask', 'fieldmask']:
  234:             self.__setmask__(val)
  235:             return
  236:         # Create a shortcut (so that we don't have to call getattr all the time)
  237:         _localdict = object.__getattribute__(self, '__dict__')
  238:         # Check whether we're creating a new field
  239:         newattr = attr not in _localdict
  240:         try:
  241:             # Is attr a generic attribute ?
  242:             ret = object.__setattr__(self, attr, val)
  243:         except Exception:
  244:             # Not a generic attribute: exit if it's not a valid field
  245:             fielddict = np.ndarray.__getattribute__(self, 'dtype').fields or {}
  246:             optinfo = np.ndarray.__getattribute__(self, '_optinfo') or {}
  247:             if not (attr in fielddict or attr in optinfo):
  248:                 raise
  249:         else:
  250:             # Get the list of names
  251:             fielddict = np.ndarray.__getattribute__(self, 'dtype').fields or {}
  252:             # Check the attribute
  253:             if attr not in fielddict:
  254:                 return ret
  255:             if newattr:
  256:                 # We just added this one or this setattr worked on an
  257:                 # internal attribute.
  258:                 try:
  259:                     object.__delattr__(self, attr)
  260:                 except Exception:
  261:                     return ret
  262:         # Let's try to set the field
  263:         try:
  264:             res = fielddict[attr][:2]
  265:         except (TypeError, KeyError) as e:
  266:             raise AttributeError(
  267:                 f'record array has no attribute {attr}') from e
  268: 
  269:         if val is ma.masked:
  270:             _fill_value = _localdict['_fill_value']
  271:             if _fill_value is not None:
  272:                 dval = _localdict['_fill_value'][attr]
  273:             else:
  274:                 dval = val
  275:             mval = True
  276:         else:
  277:             dval = ma.filled(val)
  278:             mval = ma.getmaskarray(val)
  279:         obj = np.ndarray.__getattribute__(self, '_data').setfield(dval, *res)
  280:         _localdict['_mask'].__setitem__(attr, mval)
  281:         return obj
  282: 
  283:     def __getitem__(self, indx):
  284:         """
  285:         Returns all the fields sharing the same fieldname base.
  286: 
  287:         The fieldname base is either `_data` or `_mask`.
  288: 
  289:         """
  290:         _localdict = self.__dict__
  291:         _mask = np.ndarray.__getattribute__(self, '_mask')
  292:         _data = np.ndarray.view(self, _localdict['_baseclass'])
  293:         # We want a field
  294:         if isinstance(indx, str):
  295:             # Make sure _sharedmask is True to propagate back to _fieldmask
  296:             # Don't use _set_mask, there are some copies being made that
  297:             # break propagation Don't force the mask to nomask, that wreaks
  298:             # easy masking
  299:             obj = _data[indx].view(ma.MaskedArray)
  300:             obj._mask = _mask[indx]
  301:             obj._sharedmask = True
  302:             fval = _localdict['_fill_value']
  303:             if fval is not None:
  304:                 obj._fill_value = fval[indx]
  305:             # Force to masked if the mask is True
  306:             if not obj.ndim and obj._mask:
  307:                 return ma.masked
  308:             return obj
  309:         # We want some elements.
  310:         # First, the data.
  311:         obj = np.asarray(_data[indx]).view(mrecarray)
  312:         obj._mask = np.asarray(_mask[indx]).view(np.recarray)
  313:         return obj
  314: 
  315:     def __setitem__(self, indx, value):
  316:         """
  317:         Sets the given record to value.
  318: 
  319:         """
  320:         ma.MaskedArray.__setitem__(self, indx, value)
  321:         if isinstance(indx, str):
  322:             self._mask[indx] = ma.getmaskarray(value)
  323: 
  324:     def __str__(self):
  325:         """
  326:         Calculates the string representation.
  327: 
  328:         """
  329:         if self.size > 1:
  330:             mstr = [f"({','.join([str(i) for i in s])})"
  331:                     for s in zip(*[getattr(self, f) for f in self.dtype.names])]
  332:             return f"[{', '.join(mstr)}]"
  333:         else:
  334:             mstr = [f"{','.join([str(i) for i in s])}"
  335:                     for s in zip([getattr(self, f) for f in self.dtype.names])]
  336:             return f"({', '.join(mstr)})"
  337: 
  338:     def __repr__(self):
  339:         """
  340:         Calculates the repr representation.
  341: 
  342:         """
  343:         _names = self.dtype.names
  344:         fmt = f"%{max(len(n) for n in _names) + 4}s : %s"
  345:         reprstr = [fmt % (f, getattr(self, f)) for f in self.dtype.names]
  346:         reprstr.insert(0, 'masked_records(')
  347:         reprstr.extend([fmt % ('    fill_value', self.fill_value),
  348:                         '              )'])
  349:         return str("\n".join(reprstr))
  350: 
  351:     def view(self, dtype=None, type=None):
  352:         """
  353:         Returns a view of the mrecarray.
  354: 
  355:         """
  356:         # OK, basic copy-paste from MaskedArray.view.
  357:         if dtype is None:
  358:             if type is None:
  359:                 output = np.ndarray.view(self)
  360:             else:
  361:                 output = np.ndarray.view(self, type)
  362:         # Here again.
  363:         elif type is None:
  364:             try:
  365:                 if issubclass(dtype, np.ndarray):
  366:                     output = np.ndarray.view(self, dtype)
  367:                 else:
  368:                     output = np.ndarray.view(self, dtype)
  369:             # OK, there's the change
  370:             except TypeError:
  371:                 dtype = np.dtype(dtype)
  372:                 # we need to revert to MaskedArray, but keeping the possibility
  373:                 # of subclasses (eg, TimeSeriesRecords), so we'll force a type
  374:                 # set to the first parent
  375:                 if dtype.fields is None:
  376:                     basetype = self.__class__.__bases__[0]
  377:                     output = self.__array__().view(dtype, basetype)
  378:                     output._update_from(self)
  379:                 else:
  380:                     output = np.ndarray.view(self, dtype)
  381:                 output._fill_value = None
  382:         else:
  383:             output = np.ndarray.view(self, dtype, type)
  384:         # Update the mask, just like in MaskedArray.view
  385:         if (getattr(output, '_mask', ma.nomask) is not ma.nomask):
  386:             mdtype = ma.make_mask_descr(output.dtype)
  387:             output._mask = self._mask.view(mdtype, np.ndarray)
  388:             output._mask.shape = output.shape
  389:         return output
  390: 
  391:     def harden_mask(self):
  392:         """
  393:         Forces the mask to hard.
  394: 
  395:         """
  396:         self._hardmask = True
  397: 
  398:     def soften_mask(self):
  399:         """
  400:         Forces the mask to soft
  401: 
  402:         """
  403:         self._hardmask = False
  404: 
  405:     def copy(self):
  406:         """
  407:         Returns a copy of the masked record.
  408: 
  409:         """
  410:         copied = self._data.copy().view(type(self))
  411:         copied._mask = self._mask.copy()
  412:         return copied
  413: 
  414:     def tolist(self, fill_value=None):
  415:         """
  416:         Return the data portion of the array as a list.
  417: 
  418:         Data items are converted to the nearest compatible Python type.
  419:         Masked values are converted to fill_value. If fill_value is None,
  420:         the corresponding entries in the output list will be ``None``.
  421: 
  422:         """
  423:         if fill_value is not None:
  424:             return self.filled(fill_value).tolist()
  425:         result = np.array(self.filled().tolist(), dtype=object)
  426:         mask = np.array(self._mask.tolist())
  427:         result[mask] = None
  428:         return result.tolist()
  429: 
  430:     def __getstate__(self):
  431:         """Return the internal state of the masked array.
  432: 
  433:         This is for pickling.
  434: 
  435:         """
  436:         state = (1,
  437:                  self.shape,
  438:                  self.dtype,
  439:                  self.flags.fnc,
  440:                  self._data.tobytes(),
  441:                  self._mask.tobytes(),
  442:                  self._fill_value,
  443:                  )
  444:         return state
  445: 
  446:     def __setstate__(self, state):
  447:         """
  448:         Restore the internal state of the masked array.
  449: 
  450:         This is for pickling.  ``state`` is typically the output of the
  451:         ``__getstate__`` output, and is a 5-tuple:
  452: 
  453:         - class name
  454:         - a tuple giving the shape of the data
  455:         - a typecode for the data
  456:         - a binary string for the data
  457:         - a binary string for the mask.
  458: 
  459:         """
  460:         (ver, shp, typ, isf, raw, msk, flv) = state
  461:         np.ndarray.__setstate__(self, (shp, typ, isf, raw))
  462:         mdtype = np.dtype([(k, np.bool) for (k, _) in self.dtype.descr])
  463:         self.__dict__['_mask'].__setstate__((shp, mdtype, isf, msk))
  464:         self.fill_value = flv
  465: 
  466:     def __reduce__(self):
  467:         """
  468:         Return a 3-tuple for pickling a MaskedArray.
  469: 
  470:         """
  471:         return (_mrreconstruct,
  472:                 (self.__class__, self._baseclass, (0,), 'b',),
  473:                 self.__getstate__())
  474: 
  475: 
  476: def _mrreconstruct(subtype, baseclass, baseshape, basetype,):
  477:     """
  478:     Build a new MaskedArray from the information stored in a pickle.
  479: 
  480:     """
  481:     _data = np.ndarray.__new__(baseclass, baseshape, basetype).view(subtype)
  482:     _mask = np.ndarray.__new__(np.ndarray, baseshape, 'b1')
  483:     return subtype.__new__(subtype, _data, mask=_mask, dtype=basetype,)
  484: 
  485: 
  486: mrecarray = MaskedRecords
  487: 
  488: 
  489: ###############################################################################
  490: #                             Constructors                                    #
  491: ###############################################################################
  492: 
  493: 
  494: def fromarrays(arraylist, dtype=None, shape=None, formats=None,
  495:                names=None, titles=None, aligned=False, byteorder=None,
  496:                fill_value=None):
  497:     """
  498:     Creates a mrecarray from a (flat) list of masked arrays.
  499: 
  500:     Parameters
  501:     ----------
  502:     arraylist : sequence
  503:         A list of (masked) arrays. Each element of the sequence is first converted
  504:         to a masked array if needed. If a 2D array is passed as argument, it is
  505:         processed line by line
  506:     dtype : {None, dtype}, optional
  507:         Data type descriptor.
  508:     shape : {None, integer}, optional
  509:         Number of records. If None, shape is defined from the shape of the
  510:         first array in the list.
  511:     formats : {None, sequence}, optional
  512:         Sequence of formats for each individual field. If None, the formats will
  513:         be autodetected by inspecting the fields and selecting the highest dtype
  514:         possible.
  515:     names : {None, sequence}, optional
  516:         Sequence of the names of each field.
  517:     fill_value : {None, sequence}, optional
  518:         Sequence of data to be used as filling values.
  519: 
  520:     Notes
  521:     -----
  522:     Lists of tuples should be preferred over lists of lists for faster processing.
  523: 
  524:     """
  525:     datalist = [ma.getdata(x) for x in arraylist]
  526:     masklist = [np.atleast_1d(ma.getmaskarray(x)) for x in arraylist]
  527:     _array = np.rec.fromarrays(datalist,
  528:                                dtype=dtype, shape=shape, formats=formats,
  529:                                names=names, titles=titles, aligned=aligned,
  530:                                byteorder=byteorder).view(mrecarray)
  531:     _array._mask.flat = list(zip(*masklist))
  532:     if fill_value is not None:
  533:         _array.fill_value = fill_value
  534:     return _array
  535: 
  536: 
  537: def fromrecords(reclist, dtype=None, shape=None, formats=None, names=None,
  538:                 titles=None, aligned=False, byteorder=None,
  539:                 fill_value=None, mask=ma.nomask):
  540:     """
  541:     Creates a MaskedRecords from a list of records.
  542: 
  543:     Parameters
  544:     ----------
  545:     reclist : sequence
  546:         A list of records. Each element of the sequence is first converted
  547:         to a masked array if needed. If a 2D array is passed as argument, it is
  548:         processed line by line
  549:     dtype : {None, dtype}, optional
  550:         Data type descriptor.
  551:     shape : {None,int}, optional
  552:         Number of records. If None, ``shape`` is defined from the shape of the
  553:         first array in the list.
  554:     formats : {None, sequence}, optional
  555:         Sequence of formats for each individual field. If None, the formats will
  556:         be autodetected by inspecting the fields and selecting the highest dtype
  557:         possible.
  558:     names : {None, sequence}, optional
  559:         Sequence of the names of each field.
  560:     fill_value : {None, sequence}, optional
  561:         Sequence of data to be used as filling values.
  562:     mask : {nomask, sequence}, optional.
  563:         External mask to apply on the data.
  564: 
  565:     Notes
  566:     -----
  567:     Lists of tuples should be preferred over lists of lists for faster processing.
  568: 
  569:     """
  570:     # Grab the initial _fieldmask, if needed:
  571:     _mask = getattr(reclist, '_mask', None)
  572:     # Get the list of records.
  573:     if isinstance(reclist, np.ndarray):
  574:         # Make sure we don't have some hidden mask
  575:         if isinstance(reclist, ma.MaskedArray):
  576:             reclist = reclist.filled().view(np.ndarray)
  577:         # Grab the initial dtype, just in case
  578:         if dtype is None:
  579:             dtype = reclist.dtype
  580:         reclist = reclist.tolist()
  581:     mrec = np.rec.fromrecords(reclist, dtype=dtype, shape=shape, formats=formats,
  582:                           names=names, titles=titles,
  583:                           aligned=aligned, byteorder=byteorder).view(mrecarray)
  584:     # Set the fill_value if needed
  585:     if fill_value is not None:
  586:         mrec.fill_value = fill_value
  587:     # Now, let's deal w/ the mask
  588:     if mask is not ma.nomask:
  589:         mask = np.asarray(mask)
  590:         maskrecordlength = len(mask.dtype)
  591:         if maskrecordlength:
  592:             mrec._mask.flat = mask
  593:         elif mask.ndim == 2:
  594:             mrec._mask.flat = [tuple(m) for m in mask]
  595:         else:
  596:             mrec.__setmask__(mask)
  597:     if _mask is not None:
  598:         mrec._mask[:] = _mask
  599:     return mrec
  600: 
  601: 
  602: def _guessvartypes(arr):
  603:     """
  604:     Tries to guess the dtypes of the str_ ndarray `arr`.
  605: 
  606:     Guesses by testing element-wise conversion. Returns a list of dtypes.
  607:     The array is first converted to ndarray. If the array is 2D, the test
  608:     is performed on the first line. An exception is raised if the file is
  609:     3D or more.
  610: 
  611:     """
  612:     vartypes = []
  613:     arr = np.asarray(arr)
  614:     if arr.ndim == 2:
  615:         arr = arr[0]
  616:     elif arr.ndim > 2:
  617:         raise ValueError("The array should be 2D at most!")
  618:     # Start the conversion loop.
  619:     for f in arr:
  620:         try:
  621:             int(f)
  622:         except (ValueError, TypeError):
  623:             try:
  624:                 float(f)
  625:             except (ValueError, TypeError):
  626:                 try:
  627:                     complex(f)
  628:                 except (ValueError, TypeError):
  629:                     vartypes.append(arr.dtype)
  630:                 else:
  631:                     vartypes.append(np.dtype(complex))
  632:             else:
  633:                 vartypes.append(np.dtype(float))
  634:         else:
  635:             vartypes.append(np.dtype(int))
  636:     return vartypes
  637: 
  638: 
  639: def openfile(fname):
  640:     """
  641:     Opens the file handle of file `fname`.
  642: 
  643:     """
  644:     # A file handle
  645:     if hasattr(fname, 'readline'):
  646:         return fname
  647:     # Try to open the file and guess its type
  648:     try:
  649:         f = open(fname)
  650:     except FileNotFoundError as e:
  651:         raise FileNotFoundError(f"No such file: '{fname}'") from e
  652:     if f.readline()[:2] != "\\x":
  653:         f.seek(0, 0)
  654:         return f
  655:     f.close()
  656:     raise NotImplementedError("Wow, binary file")
  657: 
  658: 
  659: def fromtextfile(fname, delimiter=None, commentchar='#', missingchar='',
  660:                  varnames=None, vartypes=None,
  661:                  *, delimitor=np._NoValue):  # backwards compatibility
  662:     """
  663:     Creates a mrecarray from data stored in the file `filename`.
  664: 
  665:     Parameters
  666:     ----------
  667:     fname : {file name/handle}
  668:         Handle of an opened file.
  669:     delimiter : {None, string}, optional
  670:         Alphanumeric character used to separate columns in the file.
  671:         If None, any (group of) white spacestring(s) will be used.
  672:     commentchar : {'#', string}, optional
  673:         Alphanumeric character used to mark the start of a comment.
  674:     missingchar : {'', string}, optional
  675:         String indicating missing data, and used to create the masks.
  676:     varnames : {None, sequence}, optional
  677:         Sequence of the variable names. If None, a list will be created from
  678:         the first non empty line of the file.
  679:     vartypes : {None, sequence}, optional
  680:         Sequence of the variables dtypes. If None, it will be estimated from
  681:         the first non-commented line.
  682: 
  683: 
  684:     Ultra simple: the varnames are in the header, one line"""
  685:     if delimitor is not np._NoValue:
  686:         if delimiter is not None:
  687:             raise TypeError("fromtextfile() got multiple values for argument "
  688:                             "'delimiter'")
  689:         # NumPy 1.22.0, 2021-09-23
  690:         warnings.warn("The 'delimitor' keyword argument of "
  691:                       "numpy.ma.mrecords.fromtextfile() is deprecated "
  692:                       "since NumPy 1.22.0, use 'delimiter' instead.",
  693:                       DeprecationWarning, stacklevel=2)
  694:         delimiter = delimitor
  695: 
  696:     # Try to open the file.
  697:     ftext = openfile(fname)
  698: 
  699:     # Get the first non-empty line as the varnames
  700:     while True:
  701:         line = ftext.readline()
  702:         firstline = line[:line.find(commentchar)].strip()
  703:         _varnames = firstline.split(delimiter)
  704:         if len(_varnames) > 1:
  705:             break
  706:     if varnames is None:
  707:         varnames = _varnames
  708: 
  709:     # Get the data.
  710:     _variables = ma.masked_array([line.strip().split(delimiter) for line in ftext
  711:                                  if line[0] != commentchar and len(line) > 1])
  712:     (_, nfields) = _variables.shape
  713:     ftext.close()
  714: 
  715:     # Try to guess the dtype.
  716:     if vartypes is None:
  717:         vartypes = _guessvartypes(_variables[0])
  718:     else:
  719:         vartypes = [np.dtype(v) for v in vartypes]
  720:         if len(vartypes) != nfields:
  721:             msg = f"Attempting to {len(vartypes)} dtypes for {nfields} fields!"
  722:             msg += " Reverting to default."
  723:             warnings.warn(msg, stacklevel=2)
  724:             vartypes = _guessvartypes(_variables[0])
  725: 
  726:     # Construct the descriptor.
  727:     mdescr = list(zip(varnames, vartypes))
  728:     mfillv = [ma.default_fill_value(f) for f in vartypes]
  729: 
  730:     # Get the data and the mask.
  731:     # We just need a list of masked_arrays. It's easier to create it like that:
  732:     _mask = (_variables.T == missingchar)
  733:     _datalist = [ma.masked_array(a, mask=m, dtype=t, fill_value=f)
  734:                  for (a, m, t, f) in zip(_variables.T, _mask, vartypes, mfillv)]
  735: 
  736:     return fromarrays(_datalist, dtype=mdescr)
  737: 
  738: 
  739: def addfield(mrecord, newfield, newfieldname=None):
  740:     """Adds a new field to the masked record array
  741: 
  742:     Uses `newfield` as data and `newfieldname` as name. If `newfieldname`
  743:     is None, the new field name is set to 'fi', where `i` is the number of
  744:     existing fields.
  745: 
  746:     """
  747:     _data = mrecord._data
  748:     _mask = mrecord._mask
  749:     if newfieldname is None or newfieldname in reserved_fields:
  750:         newfieldname = f'f{len(_data.dtype)}'
  751:     newfield = ma.array(newfield)
  752:     # Get the new data.
  753:     # Create a new empty recarray
  754:     newdtype = np.dtype(_data.dtype.descr + [(newfieldname, newfield.dtype)])
  755:     newdata = np.recarray(_data.shape, newdtype)
  756:     # Add the existing field
  757:     [newdata.setfield(_data.getfield(*f), *f)
  758:      for f in _data.dtype.fields.values()]
  759:     # Add the new field
  760:     newdata.setfield(newfield._data, *newdata.dtype.fields[newfieldname])
  761:     newdata = newdata.view(MaskedRecords)
  762:     # Get the new mask
  763:     # Create a new empty recarray
  764:     newmdtype = np.dtype([(n, np.bool) for n in newdtype.names])
  765:     newmask = np.recarray(_data.shape, newmdtype)
  766:     # Add the old masks
  767:     [newmask.setfield(_mask.getfield(*f), *f)
  768:      for f in _mask.dtype.fields.values()]
  769:     # Add the mask of the new field
  770:     newmask.setfield(ma.getmaskarray(newfield),
  771:                      *newmask.dtype.fields[newfieldname])
  772:     newdata._mask = newmask
  773:     return newdata
