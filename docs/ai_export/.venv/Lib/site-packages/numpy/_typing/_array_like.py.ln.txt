    1: import sys
    2: from collections.abc import Callable, Collection, Sequence
    3: from typing import TYPE_CHECKING, Any, Protocol, TypeAlias, TypeVar, runtime_checkable
    4: 
    5: import numpy as np
    6: from numpy import dtype
    7: 
    8: from ._nbit_base import _32Bit, _64Bit
    9: from ._nested_sequence import _NestedSequence
   10: from ._shape import _AnyShape
   11: 
   12: if TYPE_CHECKING:
   13:     StringDType = np.dtypes.StringDType
   14: else:
   15:     # at runtime outside of type checking importing this from numpy.dtypes
   16:     # would lead to a circular import
   17:     from numpy._core.multiarray import StringDType
   18: 
   19: _T = TypeVar("_T")
   20: _ScalarT = TypeVar("_ScalarT", bound=np.generic)
   21: _DTypeT = TypeVar("_DTypeT", bound=dtype[Any])
   22: _DTypeT_co = TypeVar("_DTypeT_co", covariant=True, bound=dtype[Any])
   23: 
   24: NDArray: TypeAlias = np.ndarray[_AnyShape, dtype[_ScalarT]]
   25: 
   26: # The `_SupportsArray` protocol only cares about the default dtype
   27: # (i.e. `dtype=None` or no `dtype` parameter at all) of the to-be returned
   28: # array.
   29: # Concrete implementations of the protocol are responsible for adding
   30: # any and all remaining overloads
   31: @runtime_checkable
   32: class _SupportsArray(Protocol[_DTypeT_co]):
   33:     def __array__(self) -> np.ndarray[Any, _DTypeT_co]: ...
   34: 
   35: 
   36: @runtime_checkable
   37: class _SupportsArrayFunc(Protocol):
   38:     """A protocol class representing `~class.__array_function__`."""
   39:     def __array_function__(
   40:         self,
   41:         func: Callable[..., Any],
   42:         types: Collection[type[Any]],
   43:         args: tuple[Any, ...],
   44:         kwargs: dict[str, Any],
   45:     ) -> object: ...
   46: 
   47: 
   48: # TODO: Wait until mypy supports recursive objects in combination with typevars
   49: _FiniteNestedSequence: TypeAlias = (
   50:     _T
   51:     | Sequence[_T]
   52:     | Sequence[Sequence[_T]]
   53:     | Sequence[Sequence[Sequence[_T]]]
   54:     | Sequence[Sequence[Sequence[Sequence[_T]]]]
   55: )
   56: 
   57: # A subset of `npt.ArrayLike` that can be parametrized w.r.t. `np.generic`
   58: _ArrayLike: TypeAlias = (
   59:     _SupportsArray[dtype[_ScalarT]]
   60:     | _NestedSequence[_SupportsArray[dtype[_ScalarT]]]
   61: )
   62: 
   63: # A union representing array-like objects; consists of two typevars:
   64: # One representing types that can be parametrized w.r.t. `np.dtype`
   65: # and another one for the rest
   66: _DualArrayLike: TypeAlias = (
   67:     _SupportsArray[_DTypeT]
   68:     | _NestedSequence[_SupportsArray[_DTypeT]]
   69:     | _T
   70:     | _NestedSequence[_T]
   71: )
   72: 
   73: if sys.version_info >= (3, 12):
   74:     from collections.abc import Buffer as _Buffer
   75: else:
   76:     @runtime_checkable
   77:     class _Buffer(Protocol):
   78:         def __buffer__(self, flags: int, /) -> memoryview: ...
   79: 
   80: ArrayLike: TypeAlias = _Buffer | _DualArrayLike[dtype[Any], complex | bytes | str]
   81: 
   82: # `ArrayLike<X>_co`: array-like objects that can be coerced into `X`
   83: # given the casting rules `same_kind`
   84: _ArrayLikeBool_co: TypeAlias = _DualArrayLike[dtype[np.bool], bool]
   85: _ArrayLikeUInt_co: TypeAlias = _DualArrayLike[dtype[np.bool | np.unsignedinteger], bool]
   86: _ArrayLikeInt_co: TypeAlias = _DualArrayLike[dtype[np.bool | np.integer], int]
   87: _ArrayLikeFloat_co: TypeAlias = _DualArrayLike[dtype[np.bool | np.integer | np.floating], float]
   88: _ArrayLikeComplex_co: TypeAlias = _DualArrayLike[dtype[np.bool | np.number], complex]
   89: _ArrayLikeNumber_co: TypeAlias = _ArrayLikeComplex_co
   90: _ArrayLikeTD64_co: TypeAlias = _DualArrayLike[dtype[np.bool | np.integer | np.timedelta64], int]
   91: _ArrayLikeDT64_co: TypeAlias = _ArrayLike[np.datetime64]
   92: _ArrayLikeObject_co: TypeAlias = _ArrayLike[np.object_]
   93: 
   94: _ArrayLikeVoid_co: TypeAlias = _ArrayLike[np.void]
   95: _ArrayLikeBytes_co: TypeAlias = _DualArrayLike[dtype[np.bytes_], bytes]
   96: _ArrayLikeStr_co: TypeAlias = _DualArrayLike[dtype[np.str_], str]
   97: _ArrayLikeString_co: TypeAlias = _DualArrayLike[StringDType, str]
   98: _ArrayLikeAnyString_co: TypeAlias = _DualArrayLike[dtype[np.character] | StringDType, bytes | str]
   99: 
  100: __Float64_co: TypeAlias = np.floating[_64Bit] | np.float32 | np.float16 | np.integer | np.bool
  101: __Complex128_co: TypeAlias = np.number[_64Bit] | np.number[_32Bit] | np.float16 | np.integer | np.bool
  102: _ArrayLikeFloat64_co: TypeAlias = _DualArrayLike[dtype[__Float64_co], float]
  103: _ArrayLikeComplex128_co: TypeAlias = _DualArrayLike[dtype[__Complex128_co], complex]
  104: 
  105: # NOTE: This includes `builtins.bool`, but not `numpy.bool`.
  106: _ArrayLikeInt: TypeAlias = _DualArrayLike[dtype[np.integer], int]
