    1: from collections.abc import Sequence  # noqa: F811
    2: from typing import (
    3:     Any,
    4:     Protocol,
    5:     TypeAlias,
    6:     TypedDict,
    7:     TypeVar,
    8:     runtime_checkable,
    9: )
   10: 
   11: import numpy as np
   12: 
   13: from ._char_codes import (
   14:     _BoolCodes,
   15:     _BytesCodes,
   16:     _ComplexFloatingCodes,
   17:     _DT64Codes,
   18:     _FloatingCodes,
   19:     _NumberCodes,
   20:     _ObjectCodes,
   21:     _SignedIntegerCodes,
   22:     _StrCodes,
   23:     _TD64Codes,
   24:     _UnsignedIntegerCodes,
   25:     _VoidCodes,
   26: )
   27: 
   28: _ScalarT = TypeVar("_ScalarT", bound=np.generic)
   29: _DTypeT_co = TypeVar("_DTypeT_co", bound=np.dtype, covariant=True)
   30: 
   31: _DTypeLikeNested: TypeAlias = Any  # TODO: wait for support for recursive types
   32: 
   33: 
   34: # Mandatory keys
   35: class _DTypeDictBase(TypedDict):
   36:     names: Sequence[str]
   37:     formats: Sequence[_DTypeLikeNested]
   38: 
   39: 
   40: # Mandatory + optional keys
   41: class _DTypeDict(_DTypeDictBase, total=False):
   42:     # Only `str` elements are usable as indexing aliases,
   43:     # but `titles` can in principle accept any object
   44:     offsets: Sequence[int]
   45:     titles: Sequence[Any]
   46:     itemsize: int
   47:     aligned: bool
   48: 
   49: 
   50: # A protocol for anything with the dtype attribute
   51: @runtime_checkable
   52: class _SupportsDType(Protocol[_DTypeT_co]):
   53:     @property
   54:     def dtype(self) -> _DTypeT_co: ...
   55: 
   56: 
   57: # A subset of `npt.DTypeLike` that can be parametrized w.r.t. `np.generic`
   58: _DTypeLike: TypeAlias = type[_ScalarT] | np.dtype[_ScalarT] | _SupportsDType[np.dtype[_ScalarT]]
   59: 
   60: 
   61: # Would create a dtype[np.void]
   62: _VoidDTypeLike: TypeAlias = (
   63:     # If a tuple, then it can be either:
   64:     # - (flexible_dtype, itemsize)
   65:     # - (fixed_dtype, shape)
   66:     # - (base_dtype, new_dtype)
   67:     # But because `_DTypeLikeNested = Any`, the first two cases are redundant
   68: 
   69:     # tuple[_DTypeLikeNested, int] | tuple[_DTypeLikeNested, _ShapeLike] |
   70:     tuple[_DTypeLikeNested, _DTypeLikeNested]
   71: 
   72:     # [(field_name, field_dtype, field_shape), ...]
   73:     # The type here is quite broad because NumPy accepts quite a wide
   74:     # range of inputs inside the list; see the tests for some examples.
   75:     | list[Any]
   76: 
   77:     # {'names': ..., 'formats': ..., 'offsets': ..., 'titles': ..., 'itemsize': ...}
   78:     | _DTypeDict
   79: )
   80: 
   81: # Aliases for commonly used dtype-like objects.
   82: # Note that the precision of `np.number` subclasses is ignored herein.
   83: _DTypeLikeBool: TypeAlias = type[bool] | _DTypeLike[np.bool] | _BoolCodes
   84: _DTypeLikeInt: TypeAlias = (
   85:     type[int] | _DTypeLike[np.signedinteger] | _SignedIntegerCodes
   86: )
   87: _DTypeLikeUInt: TypeAlias = _DTypeLike[np.unsignedinteger] | _UnsignedIntegerCodes
   88: _DTypeLikeFloat: TypeAlias = type[float] | _DTypeLike[np.floating] | _FloatingCodes
   89: _DTypeLikeComplex: TypeAlias = (
   90:     type[complex] | _DTypeLike[np.complexfloating] | _ComplexFloatingCodes
   91: )
   92: _DTypeLikeComplex_co: TypeAlias = (
   93:     type[complex] | _DTypeLike[np.bool | np.number] | _BoolCodes | _NumberCodes
   94: )
   95: _DTypeLikeDT64: TypeAlias = _DTypeLike[np.timedelta64] | _TD64Codes
   96: _DTypeLikeTD64: TypeAlias = _DTypeLike[np.datetime64] | _DT64Codes
   97: _DTypeLikeBytes: TypeAlias = type[bytes] | _DTypeLike[np.bytes_] | _BytesCodes
   98: _DTypeLikeStr: TypeAlias = type[str] | _DTypeLike[np.str_] | _StrCodes
   99: _DTypeLikeVoid: TypeAlias = (
  100:     type[memoryview] | _DTypeLike[np.void] | _VoidDTypeLike | _VoidCodes
  101: )
  102: _DTypeLikeObject: TypeAlias = type[object] | _DTypeLike[np.object_] | _ObjectCodes
  103: 
  104: 
  105: # Anything that can be coerced into numpy.dtype.
  106: # Reference: https://docs.scipy.org/doc/numpy/reference/arrays.dtypes.html
  107: DTypeLike: TypeAlias = _DTypeLike[Any] | _VoidDTypeLike | str | None
  108: 
  109: # NOTE: while it is possible to provide the dtype as a dict of
  110: # dtype-like objects (e.g. `{'field1': ..., 'field2': ..., ...}`),
  111: # this syntax is officially discouraged and
  112: # therefore not included in the type-union defining `DTypeLike`.
  113: #
  114: # See https://github.com/numpy/numpy/issues/16891 for more details.
