    1: from __future__ import annotations
    2: 
    3: import fnmatch
    4: import os
    5: import subprocess
    6: import sys
    7: import threading
    8: import time
    9: import typing as t
   10: from itertools import chain
   11: from pathlib import PurePath
   12: 
   13: from ._internal import _log
   14: 
   15: # The various system prefixes where imports are found. Base values are
   16: # different when running in a virtualenv. All reloaders will ignore the
   17: # base paths (usually the system installation). The stat reloader won't
   18: # scan the virtualenv paths, it will only include modules that are
   19: # already imported.
   20: _ignore_always = tuple({sys.base_prefix, sys.base_exec_prefix})
   21: prefix = {*_ignore_always, sys.prefix, sys.exec_prefix}
   22: 
   23: if hasattr(sys, "real_prefix"):
   24:     # virtualenv < 20
   25:     prefix.add(sys.real_prefix)
   26: 
   27: _stat_ignore_scan = tuple(prefix)
   28: del prefix
   29: _ignore_common_dirs = {
   30:     "__pycache__",
   31:     ".git",
   32:     ".hg",
   33:     ".tox",
   34:     ".nox",
   35:     ".pytest_cache",
   36:     ".mypy_cache",
   37: }
   38: 
   39: 
   40: def _iter_module_paths() -> t.Iterator[str]:
   41:     """Find the filesystem paths associated with imported modules."""
   42:     # List is in case the value is modified by the app while updating.
   43:     for module in list(sys.modules.values()):
   44:         name = getattr(module, "__file__", None)
   45: 
   46:         if name is None or name.startswith(_ignore_always):
   47:             continue
   48: 
   49:         while not os.path.isfile(name):
   50:             # Zip file, find the base file without the module path.
   51:             old = name
   52:             name = os.path.dirname(name)
   53: 
   54:             if name == old:  # skip if it was all directories somehow
   55:                 break
   56:         else:
   57:             yield name
   58: 
   59: 
   60: def _remove_by_pattern(paths: set[str], exclude_patterns: set[str]) -> None:
   61:     for pattern in exclude_patterns:
   62:         paths.difference_update(fnmatch.filter(paths, pattern))
   63: 
   64: 
   65: def _find_stat_paths(
   66:     extra_files: set[str], exclude_patterns: set[str]
   67: ) -> t.Iterable[str]:
   68:     """Find paths for the stat reloader to watch. Returns imported
   69:     module files, Python files under non-system paths. Extra files and
   70:     Python files under extra directories can also be scanned.
   71: 
   72:     System paths have to be excluded for efficiency. Non-system paths,
   73:     such as a project root or ``sys.path.insert``, should be the paths
   74:     of interest to the user anyway.
   75:     """
   76:     paths = set()
   77: 
   78:     for path in chain(list(sys.path), extra_files):
   79:         path = os.path.abspath(path)
   80: 
   81:         if os.path.isfile(path):
   82:             # zip file on sys.path, or extra file
   83:             paths.add(path)
   84:             continue
   85: 
   86:         parent_has_py = {os.path.dirname(path): True}
   87: 
   88:         for root, dirs, files in os.walk(path):
   89:             # Optimizations: ignore system prefixes, __pycache__ will
   90:             # have a py or pyc module at the import path, ignore some
   91:             # common known dirs such as version control and tool caches.
   92:             if (
   93:                 root.startswith(_stat_ignore_scan)
   94:                 or os.path.basename(root) in _ignore_common_dirs
   95:             ):
   96:                 dirs.clear()
   97:                 continue
   98: 
   99:             has_py = False
  100: 
  101:             for name in files:
  102:                 if name.endswith((".py", ".pyc")):
  103:                     has_py = True
  104:                     paths.add(os.path.join(root, name))
  105: 
  106:             # Optimization: stop scanning a directory if neither it nor
  107:             # its parent contained Python files.
  108:             if not (has_py or parent_has_py[os.path.dirname(root)]):
  109:                 dirs.clear()
  110:                 continue
  111: 
  112:             parent_has_py[root] = has_py
  113: 
  114:     paths.update(_iter_module_paths())
  115:     _remove_by_pattern(paths, exclude_patterns)
  116:     return paths
  117: 
  118: 
  119: def _find_watchdog_paths(
  120:     extra_files: set[str], exclude_patterns: set[str]
  121: ) -> t.Iterable[str]:
  122:     """Find paths for the stat reloader to watch. Looks at the same
  123:     sources as the stat reloader, but watches everything under
  124:     directories instead of individual files.
  125:     """
  126:     dirs = set()
  127: 
  128:     for name in chain(list(sys.path), extra_files):
  129:         name = os.path.abspath(name)
  130: 
  131:         if os.path.isfile(name):
  132:             name = os.path.dirname(name)
  133: 
  134:         dirs.add(name)
  135: 
  136:     for name in _iter_module_paths():
  137:         dirs.add(os.path.dirname(name))
  138: 
  139:     _remove_by_pattern(dirs, exclude_patterns)
  140:     return _find_common_roots(dirs)
  141: 
  142: 
  143: def _find_common_roots(paths: t.Iterable[str]) -> t.Iterable[str]:
  144:     root: dict[str, dict[str, t.Any]] = {}
  145: 
  146:     for chunks in sorted((PurePath(x).parts for x in paths), key=len, reverse=True):
  147:         node = root
  148: 
  149:         for chunk in chunks:
  150:             node = node.setdefault(chunk, {})
  151: 
  152:         node.clear()
  153: 
  154:     rv = set()
  155: 
  156:     def _walk(node: t.Mapping[str, dict[str, t.Any]], path: tuple[str, ...]) -> None:
  157:         for prefix, child in node.items():
  158:             _walk(child, path + (prefix,))
  159: 
  160:         # If there are no more nodes, and a path has been accumulated, add it.
  161:         # Path may be empty if the "" entry is in sys.path.
  162:         if not node and path:
  163:             rv.add(os.path.join(*path))
  164: 
  165:     _walk(root, ())
  166:     return rv
  167: 
  168: 
  169: def _get_args_for_reloading() -> list[str]:
  170:     """Determine how the script was executed, and return the args needed
  171:     to execute it again in a new process.
  172:     """
  173:     if sys.version_info >= (3, 10):
  174:         # sys.orig_argv, added in Python 3.10, contains the exact args used to invoke
  175:         # Python. Still replace argv[0] with sys.executable for accuracy.
  176:         return [sys.executable, *sys.orig_argv[1:]]
  177: 
  178:     rv = [sys.executable]
  179:     py_script = sys.argv[0]
  180:     args = sys.argv[1:]
  181:     # Need to look at main module to determine how it was executed.
  182:     __main__ = sys.modules["__main__"]
  183: 
  184:     # The value of __package__ indicates how Python was called. It may
  185:     # not exist if a setuptools script is installed as an egg. It may be
  186:     # set incorrectly for entry points created with pip on Windows.
  187:     if getattr(__main__, "__package__", None) is None or (
  188:         os.name == "nt"
  189:         and __main__.__package__ == ""
  190:         and not os.path.exists(py_script)
  191:         and os.path.exists(f"{py_script}.exe")
  192:     ):
  193:         # Executed a file, like "python app.py".
  194:         py_script = os.path.abspath(py_script)
  195: 
  196:         if os.name == "nt":
  197:             # Windows entry points have ".exe" extension and should be
  198:             # called directly.
  199:             if not os.path.exists(py_script) and os.path.exists(f"{py_script}.exe"):
  200:                 py_script += ".exe"
  201: 
  202:             if (
  203:                 os.path.splitext(sys.executable)[1] == ".exe"
  204:                 and os.path.splitext(py_script)[1] == ".exe"
  205:             ):
  206:                 rv.pop(0)
  207: 
  208:         rv.append(py_script)
  209:     else:
  210:         # Executed a module, like "python -m werkzeug.serving".
  211:         if os.path.isfile(py_script):
  212:             # Rewritten by Python from "-m script" to "/path/to/script.py".
  213:             py_module = t.cast(str, __main__.__package__)
  214:             name = os.path.splitext(os.path.basename(py_script))[0]
  215: 
  216:             if name != "__main__":
  217:                 py_module += f".{name}"
  218:         else:
  219:             # Incorrectly rewritten by pydevd debugger from "-m script" to "script".
  220:             py_module = py_script
  221: 
  222:         rv.extend(("-m", py_module.lstrip(".")))
  223: 
  224:     rv.extend(args)
  225:     return rv
  226: 
  227: 
  228: class ReloaderLoop:
  229:     name = ""
  230: 
  231:     def __init__(
  232:         self,
  233:         extra_files: t.Iterable[str] | None = None,
  234:         exclude_patterns: t.Iterable[str] | None = None,
  235:         interval: int | float = 1,
  236:     ) -> None:
  237:         self.extra_files: set[str] = {os.path.abspath(x) for x in extra_files or ()}
  238:         self.exclude_patterns: set[str] = set(exclude_patterns or ())
  239:         self.interval = interval
  240: 
  241:     def __enter__(self) -> ReloaderLoop:
  242:         """Do any setup, then run one step of the watch to populate the
  243:         initial filesystem state.
  244:         """
  245:         self.run_step()
  246:         return self
  247: 
  248:     def __exit__(self, exc_type, exc_val, exc_tb):  # type: ignore
  249:         """Clean up any resources associated with the reloader."""
  250:         pass
  251: 
  252:     def run(self) -> None:
  253:         """Continually run the watch step, sleeping for the configured
  254:         interval after each step.
  255:         """
  256:         while True:
  257:             self.run_step()
  258:             time.sleep(self.interval)
  259: 
  260:     def run_step(self) -> None:
  261:         """Run one step for watching the filesystem. Called once to set
  262:         up initial state, then repeatedly to update it.
  263:         """
  264:         pass
  265: 
  266:     def restart_with_reloader(self) -> int:
  267:         """Spawn a new Python interpreter with the same arguments as the
  268:         current one, but running the reloader thread.
  269:         """
  270:         while True:
  271:             _log("info", f" * Restarting with {self.name}")
  272:             args = _get_args_for_reloading()
  273:             new_environ = os.environ.copy()
  274:             new_environ["WERKZEUG_RUN_MAIN"] = "true"
  275:             exit_code = subprocess.call(args, env=new_environ, close_fds=False)
  276: 
  277:             if exit_code != 3:
  278:                 return exit_code
  279: 
  280:     def trigger_reload(self, filename: str) -> None:
  281:         self.log_reload(filename)
  282:         sys.exit(3)
  283: 
  284:     def log_reload(self, filename: str) -> None:
  285:         filename = os.path.abspath(filename)
  286:         _log("info", f" * Detected change in {filename!r}, reloading")
  287: 
  288: 
  289: class StatReloaderLoop(ReloaderLoop):
  290:     name = "stat"
  291: 
  292:     def __enter__(self) -> ReloaderLoop:
  293:         self.mtimes: dict[str, float] = {}
  294:         return super().__enter__()
  295: 
  296:     def run_step(self) -> None:
  297:         for name in _find_stat_paths(self.extra_files, self.exclude_patterns):
  298:             try:
  299:                 mtime = os.stat(name).st_mtime
  300:             except OSError:
  301:                 continue
  302: 
  303:             old_time = self.mtimes.get(name)
  304: 
  305:             if old_time is None:
  306:                 self.mtimes[name] = mtime
  307:                 continue
  308: 
  309:             if mtime > old_time:
  310:                 self.trigger_reload(name)
  311: 
  312: 
  313: class WatchdogReloaderLoop(ReloaderLoop):
  314:     def __init__(self, *args: t.Any, **kwargs: t.Any) -> None:
  315:         from watchdog.events import EVENT_TYPE_OPENED
  316:         from watchdog.events import FileModifiedEvent
  317:         from watchdog.events import PatternMatchingEventHandler
  318:         from watchdog.observers import Observer
  319: 
  320:         super().__init__(*args, **kwargs)
  321:         trigger_reload = self.trigger_reload
  322: 
  323:         class EventHandler(PatternMatchingEventHandler):
  324:             def on_any_event(self, event: FileModifiedEvent):  # type: ignore
  325:                 if event.event_type == EVENT_TYPE_OPENED:
  326:                     return
  327: 
  328:                 trigger_reload(event.src_path)
  329: 
  330:         reloader_name = Observer.__name__.lower()  # type: ignore[attr-defined]
  331: 
  332:         if reloader_name.endswith("observer"):
  333:             reloader_name = reloader_name[:-8]
  334: 
  335:         self.name = f"watchdog ({reloader_name})"
  336:         self.observer = Observer()
  337:         # Extra patterns can be non-Python files, match them in addition
  338:         # to all Python files in default and extra directories. Ignore
  339:         # __pycache__ since a change there will always have a change to
  340:         # the source file (or initial pyc file) as well. Ignore Git and
  341:         # Mercurial internal changes.
  342:         extra_patterns = [p for p in self.extra_files if not os.path.isdir(p)]
  343:         self.event_handler = EventHandler(  # type: ignore[no-untyped-call]
  344:             patterns=["*.py", "*.pyc", "*.zip", *extra_patterns],
  345:             ignore_patterns=[
  346:                 *[f"*/{d}/*" for d in _ignore_common_dirs],
  347:                 *self.exclude_patterns,
  348:             ],
  349:         )
  350:         self.should_reload = False
  351: 
  352:     def trigger_reload(self, filename: str) -> None:
  353:         # This is called inside an event handler, which means throwing
  354:         # SystemExit has no effect.
  355:         # https://github.com/gorakhargosh/watchdog/issues/294
  356:         self.should_reload = True
  357:         self.log_reload(filename)
  358: 
  359:     def __enter__(self) -> ReloaderLoop:
  360:         self.watches: dict[str, t.Any] = {}
  361:         self.observer.start()  # type: ignore[no-untyped-call]
  362:         return super().__enter__()
  363: 
  364:     def __exit__(self, exc_type, exc_val, exc_tb):  # type: ignore
  365:         self.observer.stop()  # type: ignore[no-untyped-call]
  366:         self.observer.join()
  367: 
  368:     def run(self) -> None:
  369:         while not self.should_reload:
  370:             self.run_step()
  371:             time.sleep(self.interval)
  372: 
  373:         sys.exit(3)
  374: 
  375:     def run_step(self) -> None:
  376:         to_delete = set(self.watches)
  377: 
  378:         for path in _find_watchdog_paths(self.extra_files, self.exclude_patterns):
  379:             if path not in self.watches:
  380:                 try:
  381:                     self.watches[path] = self.observer.schedule(  # type: ignore[no-untyped-call]
  382:                         self.event_handler, path, recursive=True
  383:                     )
  384:                 except OSError:
  385:                     # Clear this path from list of watches We don't want
  386:                     # the same error message showing again in the next
  387:                     # iteration.
  388:                     self.watches[path] = None
  389: 
  390:             to_delete.discard(path)
  391: 
  392:         for path in to_delete:
  393:             watch = self.watches.pop(path, None)
  394: 
  395:             if watch is not None:
  396:                 self.observer.unschedule(watch)  # type: ignore[no-untyped-call]
  397: 
  398: 
  399: reloader_loops: dict[str, type[ReloaderLoop]] = {
  400:     "stat": StatReloaderLoop,
  401:     "watchdog": WatchdogReloaderLoop,
  402: }
  403: 
  404: try:
  405:     __import__("watchdog.observers")
  406: except ImportError:
  407:     reloader_loops["auto"] = reloader_loops["stat"]
  408: else:
  409:     reloader_loops["auto"] = reloader_loops["watchdog"]
  410: 
  411: 
  412: def ensure_echo_on() -> None:
  413:     """Ensure that echo mode is enabled. Some tools such as PDB disable
  414:     it which causes usability issues after a reload."""
  415:     # tcgetattr will fail if stdin isn't a tty
  416:     if sys.stdin is None or not sys.stdin.isatty():
  417:         return
  418: 
  419:     try:
  420:         import termios
  421:     except ImportError:
  422:         return
  423: 
  424:     attributes = termios.tcgetattr(sys.stdin)
  425: 
  426:     if not attributes[3] & termios.ECHO:
  427:         attributes[3] |= termios.ECHO
  428:         termios.tcsetattr(sys.stdin, termios.TCSANOW, attributes)
  429: 
  430: 
  431: def run_with_reloader(
  432:     main_func: t.Callable[[], None],
  433:     extra_files: t.Iterable[str] | None = None,
  434:     exclude_patterns: t.Iterable[str] | None = None,
  435:     interval: int | float = 1,
  436:     reloader_type: str = "auto",
  437: ) -> None:
  438:     """Run the given function in an independent Python interpreter."""
  439:     import signal
  440: 
  441:     signal.signal(signal.SIGTERM, lambda *args: sys.exit(0))
  442:     reloader = reloader_loops[reloader_type](
  443:         extra_files=extra_files, exclude_patterns=exclude_patterns, interval=interval
  444:     )
  445: 
  446:     try:
  447:         if os.environ.get("WERKZEUG_RUN_MAIN") == "true":
  448:             ensure_echo_on()
  449:             t = threading.Thread(target=main_func, args=())
  450:             t.daemon = True
  451: 
  452:             # Enter the reloader to set up initial state, then start
  453:             # the app thread and reloader update loop.
  454:             with reloader:
  455:                 t.start()
  456:                 reloader.run()
  457:         else:
  458:             sys.exit(reloader.restart_with_reloader())
  459:     except KeyboardInterrupt:
  460:         pass
