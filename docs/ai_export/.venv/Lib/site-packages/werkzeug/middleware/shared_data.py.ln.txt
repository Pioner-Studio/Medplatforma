    1: """
    2: Serve Shared Static Files
    3: =========================
    4: 
    5: .. autoclass:: SharedDataMiddleware
    6:     :members: is_allowed
    7: 
    8: :copyright: 2007 Pallets
    9: :license: BSD-3-Clause
   10: """
   11: 
   12: from __future__ import annotations
   13: 
   14: import importlib.util
   15: import mimetypes
   16: import os
   17: import posixpath
   18: import typing as t
   19: from datetime import datetime
   20: from datetime import timezone
   21: from io import BytesIO
   22: from time import time
   23: from zlib import adler32
   24: 
   25: from ..http import http_date
   26: from ..http import is_resource_modified
   27: from ..security import safe_join
   28: from ..utils import get_content_type
   29: from ..wsgi import get_path_info
   30: from ..wsgi import wrap_file
   31: 
   32: _TOpener = t.Callable[[], t.Tuple[t.IO[bytes], datetime, int]]
   33: _TLoader = t.Callable[[t.Optional[str]], t.Tuple[t.Optional[str], t.Optional[_TOpener]]]
   34: 
   35: if t.TYPE_CHECKING:
   36:     from _typeshed.wsgi import StartResponse
   37:     from _typeshed.wsgi import WSGIApplication
   38:     from _typeshed.wsgi import WSGIEnvironment
   39: 
   40: 
   41: class SharedDataMiddleware:
   42:     """A WSGI middleware which provides static content for development
   43:     environments or simple server setups. Its usage is quite simple::
   44: 
   45:         import os
   46:         from werkzeug.middleware.shared_data import SharedDataMiddleware
   47: 
   48:         app = SharedDataMiddleware(app, {
   49:             '/shared': os.path.join(os.path.dirname(__file__), 'shared')
   50:         })
   51: 
   52:     The contents of the folder ``./shared`` will now be available on
   53:     ``http://example.com/shared/``.  This is pretty useful during development
   54:     because a standalone media server is not required. Files can also be
   55:     mounted on the root folder and still continue to use the application because
   56:     the shared data middleware forwards all unhandled requests to the
   57:     application, even if the requests are below one of the shared folders.
   58: 
   59:     If `pkg_resources` is available you can also tell the middleware to serve
   60:     files from package data::
   61: 
   62:         app = SharedDataMiddleware(app, {
   63:             '/static': ('myapplication', 'static')
   64:         })
   65: 
   66:     This will then serve the ``static`` folder in the `myapplication`
   67:     Python package.
   68: 
   69:     The optional `disallow` parameter can be a list of :func:`~fnmatch.fnmatch`
   70:     rules for files that are not accessible from the web.  If `cache` is set to
   71:     `False` no caching headers are sent.
   72: 
   73:     Currently the middleware does not support non-ASCII filenames. If the
   74:     encoding on the file system happens to match the encoding of the URI it may
   75:     work but this could also be by accident. We strongly suggest using ASCII
   76:     only file names for static files.
   77: 
   78:     The middleware will guess the mimetype using the Python `mimetype`
   79:     module.  If it's unable to figure out the charset it will fall back
   80:     to `fallback_mimetype`.
   81: 
   82:     :param app: the application to wrap.  If you don't want to wrap an
   83:                 application you can pass it :exc:`NotFound`.
   84:     :param exports: a list or dict of exported files and folders.
   85:     :param disallow: a list of :func:`~fnmatch.fnmatch` rules.
   86:     :param cache: enable or disable caching headers.
   87:     :param cache_timeout: the cache timeout in seconds for the headers.
   88:     :param fallback_mimetype: The fallback mimetype for unknown files.
   89: 
   90:     .. versionchanged:: 1.0
   91:         The default ``fallback_mimetype`` is
   92:         ``application/octet-stream``. If a filename looks like a text
   93:         mimetype, the ``utf-8`` charset is added to it.
   94: 
   95:     .. versionadded:: 0.6
   96:         Added ``fallback_mimetype``.
   97: 
   98:     .. versionchanged:: 0.5
   99:         Added ``cache_timeout``.
  100:     """
  101: 
  102:     def __init__(
  103:         self,
  104:         app: WSGIApplication,
  105:         exports: (
  106:             dict[str, str | tuple[str, str]]
  107:             | t.Iterable[tuple[str, str | tuple[str, str]]]
  108:         ),
  109:         disallow: None = None,
  110:         cache: bool = True,
  111:         cache_timeout: int = 60 * 60 * 12,
  112:         fallback_mimetype: str = "application/octet-stream",
  113:     ) -> None:
  114:         self.app = app
  115:         self.exports: list[tuple[str, _TLoader]] = []
  116:         self.cache = cache
  117:         self.cache_timeout = cache_timeout
  118: 
  119:         if isinstance(exports, dict):
  120:             exports = exports.items()
  121: 
  122:         for key, value in exports:
  123:             if isinstance(value, tuple):
  124:                 loader = self.get_package_loader(*value)
  125:             elif isinstance(value, str):
  126:                 if os.path.isfile(value):
  127:                     loader = self.get_file_loader(value)
  128:                 else:
  129:                     loader = self.get_directory_loader(value)
  130:             else:
  131:                 raise TypeError(f"unknown def {value!r}")
  132: 
  133:             self.exports.append((key, loader))
  134: 
  135:         if disallow is not None:
  136:             from fnmatch import fnmatch
  137: 
  138:             self.is_allowed = lambda x: not fnmatch(x, disallow)
  139: 
  140:         self.fallback_mimetype = fallback_mimetype
  141: 
  142:     def is_allowed(self, filename: str) -> bool:
  143:         """Subclasses can override this method to disallow the access to
  144:         certain files.  However by providing `disallow` in the constructor
  145:         this method is overwritten.
  146:         """
  147:         return True
  148: 
  149:     def _opener(self, filename: str) -> _TOpener:
  150:         return lambda: (
  151:             open(filename, "rb"),
  152:             datetime.fromtimestamp(os.path.getmtime(filename), tz=timezone.utc),
  153:             int(os.path.getsize(filename)),
  154:         )
  155: 
  156:     def get_file_loader(self, filename: str) -> _TLoader:
  157:         return lambda x: (os.path.basename(filename), self._opener(filename))
  158: 
  159:     def get_package_loader(self, package: str, package_path: str) -> _TLoader:
  160:         load_time = datetime.now(timezone.utc)
  161:         spec = importlib.util.find_spec(package)
  162:         reader = spec.loader.get_resource_reader(package)  # type: ignore[union-attr]
  163: 
  164:         def loader(
  165:             path: str | None,
  166:         ) -> tuple[str | None, _TOpener | None]:
  167:             if path is None:
  168:                 return None, None
  169: 
  170:             path = safe_join(package_path, path)
  171: 
  172:             if path is None:
  173:                 return None, None
  174: 
  175:             basename = posixpath.basename(path)
  176: 
  177:             try:
  178:                 resource = reader.open_resource(path)
  179:             except OSError:
  180:                 return None, None
  181: 
  182:             if isinstance(resource, BytesIO):
  183:                 return (
  184:                     basename,
  185:                     lambda: (resource, load_time, len(resource.getvalue())),
  186:                 )
  187: 
  188:             return (
  189:                 basename,
  190:                 lambda: (
  191:                     resource,
  192:                     datetime.fromtimestamp(
  193:                         os.path.getmtime(resource.name), tz=timezone.utc
  194:                     ),
  195:                     os.path.getsize(resource.name),
  196:                 ),
  197:             )
  198: 
  199:         return loader
  200: 
  201:     def get_directory_loader(self, directory: str) -> _TLoader:
  202:         def loader(
  203:             path: str | None,
  204:         ) -> tuple[str | None, _TOpener | None]:
  205:             if path is not None:
  206:                 path = safe_join(directory, path)
  207: 
  208:                 if path is None:
  209:                     return None, None
  210:             else:
  211:                 path = directory
  212: 
  213:             if os.path.isfile(path):
  214:                 return os.path.basename(path), self._opener(path)
  215: 
  216:             return None, None
  217: 
  218:         return loader
  219: 
  220:     def generate_etag(self, mtime: datetime, file_size: int, real_filename: str) -> str:
  221:         fn_str = os.fsencode(real_filename)
  222:         timestamp = mtime.timestamp()
  223:         checksum = adler32(fn_str) & 0xFFFFFFFF
  224:         return f"wzsdm-{timestamp}-{file_size}-{checksum}"
  225: 
  226:     def __call__(
  227:         self, environ: WSGIEnvironment, start_response: StartResponse
  228:     ) -> t.Iterable[bytes]:
  229:         path = get_path_info(environ)
  230:         file_loader = None
  231: 
  232:         for search_path, loader in self.exports:
  233:             if search_path == path:
  234:                 real_filename, file_loader = loader(None)
  235: 
  236:                 if file_loader is not None:
  237:                     break
  238: 
  239:             if not search_path.endswith("/"):
  240:                 search_path += "/"
  241: 
  242:             if path.startswith(search_path):
  243:                 real_filename, file_loader = loader(path[len(search_path) :])
  244: 
  245:                 if file_loader is not None:
  246:                     break
  247: 
  248:         if file_loader is None or not self.is_allowed(real_filename):  # type: ignore
  249:             return self.app(environ, start_response)
  250: 
  251:         guessed_type = mimetypes.guess_type(real_filename)  # type: ignore
  252:         mime_type = get_content_type(guessed_type[0] or self.fallback_mimetype, "utf-8")
  253:         f, mtime, file_size = file_loader()
  254: 
  255:         headers = [("Date", http_date())]
  256: 
  257:         if self.cache:
  258:             timeout = self.cache_timeout
  259:             etag = self.generate_etag(mtime, file_size, real_filename)  # type: ignore
  260:             headers += [
  261:                 ("Etag", f'"{etag}"'),
  262:                 ("Cache-Control", f"max-age={timeout}, public"),
  263:             ]
  264: 
  265:             if not is_resource_modified(environ, etag, last_modified=mtime):
  266:                 f.close()
  267:                 start_response("304 Not Modified", headers)
  268:                 return []
  269: 
  270:             headers.append(("Expires", http_date(time() + timeout)))
  271:         else:
  272:             headers.append(("Cache-Control", "public"))
  273: 
  274:         headers.extend(
  275:             (
  276:                 ("Content-Type", mime_type),
  277:                 ("Content-Length", str(file_size)),
  278:                 ("Last-Modified", http_date(mtime)),
  279:             )
  280:         )
  281:         start_response("200 OK", headers)
  282:         return wrap_file(environ, f)
