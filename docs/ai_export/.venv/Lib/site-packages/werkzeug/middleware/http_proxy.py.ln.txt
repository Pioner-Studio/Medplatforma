    1: """
    2: Basic HTTP Proxy
    3: ================
    4: 
    5: .. autoclass:: ProxyMiddleware
    6: 
    7: :copyright: 2007 Pallets
    8: :license: BSD-3-Clause
    9: """
   10: 
   11: from __future__ import annotations
   12: 
   13: import typing as t
   14: from http import client
   15: from urllib.parse import quote
   16: from urllib.parse import urlsplit
   17: 
   18: from ..datastructures import EnvironHeaders
   19: from ..http import is_hop_by_hop_header
   20: from ..wsgi import get_input_stream
   21: 
   22: if t.TYPE_CHECKING:
   23:     from _typeshed.wsgi import StartResponse
   24:     from _typeshed.wsgi import WSGIApplication
   25:     from _typeshed.wsgi import WSGIEnvironment
   26: 
   27: 
   28: class ProxyMiddleware:
   29:     """Proxy requests under a path to an external server, routing other
   30:     requests to the app.
   31: 
   32:     This middleware can only proxy HTTP requests, as HTTP is the only
   33:     protocol handled by the WSGI server. Other protocols, such as
   34:     WebSocket requests, cannot be proxied at this layer. This should
   35:     only be used for development, in production a real proxy server
   36:     should be used.
   37: 
   38:     The middleware takes a dict mapping a path prefix to a dict
   39:     describing the host to be proxied to::
   40: 
   41:         app = ProxyMiddleware(app, {
   42:             "/static/": {
   43:                 "target": "http://127.0.0.1:5001/",
   44:             }
   45:         })
   46: 
   47:     Each host has the following options:
   48: 
   49:     ``target``:
   50:         The target URL to dispatch to. This is required.
   51:     ``remove_prefix``:
   52:         Whether to remove the prefix from the URL before dispatching it
   53:         to the target. The default is ``False``.
   54:     ``host``:
   55:         ``"<auto>"`` (default):
   56:             The host header is automatically rewritten to the URL of the
   57:             target.
   58:         ``None``:
   59:             The host header is unmodified from the client request.
   60:         Any other value:
   61:             The host header is overwritten with the value.
   62:     ``headers``:
   63:         A dictionary of headers to be sent with the request to the
   64:         target. The default is ``{}``.
   65:     ``ssl_context``:
   66:         A :class:`ssl.SSLContext` defining how to verify requests if the
   67:         target is HTTPS. The default is ``None``.
   68: 
   69:     In the example above, everything under ``"/static/"`` is proxied to
   70:     the server on port 5001. The host header is rewritten to the target,
   71:     and the ``"/static/"`` prefix is removed from the URLs.
   72: 
   73:     :param app: The WSGI application to wrap.
   74:     :param targets: Proxy target configurations. See description above.
   75:     :param chunk_size: Size of chunks to read from input stream and
   76:         write to target.
   77:     :param timeout: Seconds before an operation to a target fails.
   78: 
   79:     .. versionadded:: 0.14
   80:     """
   81: 
   82:     def __init__(
   83:         self,
   84:         app: WSGIApplication,
   85:         targets: t.Mapping[str, dict[str, t.Any]],
   86:         chunk_size: int = 2 << 13,
   87:         timeout: int = 10,
   88:     ) -> None:
   89:         def _set_defaults(opts: dict[str, t.Any]) -> dict[str, t.Any]:
   90:             opts.setdefault("remove_prefix", False)
   91:             opts.setdefault("host", "<auto>")
   92:             opts.setdefault("headers", {})
   93:             opts.setdefault("ssl_context", None)
   94:             return opts
   95: 
   96:         self.app = app
   97:         self.targets = {
   98:             f"/{k.strip('/')}/": _set_defaults(v) for k, v in targets.items()
   99:         }
  100:         self.chunk_size = chunk_size
  101:         self.timeout = timeout
  102: 
  103:     def proxy_to(
  104:         self, opts: dict[str, t.Any], path: str, prefix: str
  105:     ) -> WSGIApplication:
  106:         target = urlsplit(opts["target"])
  107:         # socket can handle unicode host, but header must be ascii
  108:         host = target.hostname.encode("idna").decode("ascii")
  109: 
  110:         def application(
  111:             environ: WSGIEnvironment, start_response: StartResponse
  112:         ) -> t.Iterable[bytes]:
  113:             headers = list(EnvironHeaders(environ).items())
  114:             headers[:] = [
  115:                 (k, v)
  116:                 for k, v in headers
  117:                 if not is_hop_by_hop_header(k)
  118:                 and k.lower() not in ("content-length", "host")
  119:             ]
  120:             headers.append(("Connection", "close"))
  121: 
  122:             if opts["host"] == "<auto>":
  123:                 headers.append(("Host", host))
  124:             elif opts["host"] is None:
  125:                 headers.append(("Host", environ["HTTP_HOST"]))
  126:             else:
  127:                 headers.append(("Host", opts["host"]))
  128: 
  129:             headers.extend(opts["headers"].items())
  130:             remote_path = path
  131: 
  132:             if opts["remove_prefix"]:
  133:                 remote_path = remote_path[len(prefix) :].lstrip("/")
  134:                 remote_path = f"{target.path.rstrip('/')}/{remote_path}"
  135: 
  136:             content_length = environ.get("CONTENT_LENGTH")
  137:             chunked = False
  138: 
  139:             if content_length not in ("", None):
  140:                 headers.append(("Content-Length", content_length))  # type: ignore
  141:             elif content_length is not None:
  142:                 headers.append(("Transfer-Encoding", "chunked"))
  143:                 chunked = True
  144: 
  145:             try:
  146:                 if target.scheme == "http":
  147:                     con = client.HTTPConnection(
  148:                         host, target.port or 80, timeout=self.timeout
  149:                     )
  150:                 elif target.scheme == "https":
  151:                     con = client.HTTPSConnection(
  152:                         host,
  153:                         target.port or 443,
  154:                         timeout=self.timeout,
  155:                         context=opts["ssl_context"],
  156:                     )
  157:                 else:
  158:                     raise RuntimeError(
  159:                         "Target scheme must be 'http' or 'https', got"
  160:                         f" {target.scheme!r}."
  161:                     )
  162: 
  163:                 con.connect()
  164:                 # safe = https://url.spec.whatwg.org/#url-path-segment-string
  165:                 # as well as percent for things that are already quoted
  166:                 remote_url = quote(remote_path, safe="!$&'()*+,/:;=@%")
  167:                 querystring = environ["QUERY_STRING"]
  168: 
  169:                 if querystring:
  170:                     remote_url = f"{remote_url}?{querystring}"
  171: 
  172:                 con.putrequest(environ["REQUEST_METHOD"], remote_url, skip_host=True)
  173: 
  174:                 for k, v in headers:
  175:                     if k.lower() == "connection":
  176:                         v = "close"
  177: 
  178:                     con.putheader(k, v)
  179: 
  180:                 con.endheaders()
  181:                 stream = get_input_stream(environ)
  182: 
  183:                 while True:
  184:                     data = stream.read(self.chunk_size)
  185: 
  186:                     if not data:
  187:                         break
  188: 
  189:                     if chunked:
  190:                         con.send(b"%x\r\n%s\r\n" % (len(data), data))
  191:                     else:
  192:                         con.send(data)
  193: 
  194:                 resp = con.getresponse()
  195:             except OSError:
  196:                 from ..exceptions import BadGateway
  197: 
  198:                 return BadGateway()(environ, start_response)
  199: 
  200:             start_response(
  201:                 f"{resp.status} {resp.reason}",
  202:                 [
  203:                     (k.title(), v)
  204:                     for k, v in resp.getheaders()
  205:                     if not is_hop_by_hop_header(k)
  206:                 ],
  207:             )
  208: 
  209:             def read() -> t.Iterator[bytes]:
  210:                 while True:
  211:                     try:
  212:                         data = resp.read(self.chunk_size)
  213:                     except OSError:
  214:                         break
  215: 
  216:                     if not data:
  217:                         break
  218: 
  219:                     yield data
  220: 
  221:             return read()
  222: 
  223:         return application
  224: 
  225:     def __call__(
  226:         self, environ: WSGIEnvironment, start_response: StartResponse
  227:     ) -> t.Iterable[bytes]:
  228:         path = environ["PATH_INFO"]
  229:         app = self.app
  230: 
  231:         for prefix, opts in self.targets.items():
  232:             if path.startswith(prefix):
  233:                 app = self.proxy_to(opts, path, prefix)
  234:                 break
  235: 
  236:         return app(environ, start_response)
