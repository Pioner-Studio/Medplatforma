    1: from __future__ import annotations
    2: 
    3: import itertools
    4: import linecache
    5: import os
    6: import re
    7: import sys
    8: import sysconfig
    9: import traceback
   10: import typing as t
   11: 
   12: from markupsafe import escape
   13: 
   14: from ..utils import cached_property
   15: from .console import Console
   16: 
   17: HEADER = """\
   18: <!doctype html>
   19: <html lang=en>
   20:   <head>
   21:     <title>%(title)s // Werkzeug Debugger</title>
   22:     <link rel="stylesheet" href="?__debugger__=yes&amp;cmd=resource&amp;f=style.css">
   23:     <link rel="shortcut icon"
   24:         href="?__debugger__=yes&amp;cmd=resource&amp;f=console.png">
   25:     <script src="?__debugger__=yes&amp;cmd=resource&amp;f=debugger.js"></script>
   26:     <script>
   27:       var CONSOLE_MODE = %(console)s,
   28:           EVALEX = %(evalex)s,
   29:           EVALEX_TRUSTED = %(evalex_trusted)s,
   30:           SECRET = "%(secret)s";
   31:     </script>
   32:   </head>
   33:   <body style="background-color: #fff">
   34:     <div class="debugger">
   35: """
   36: 
   37: FOOTER = """\
   38:       <div class="footer">
   39:         Brought to you by <strong class="arthur">DON'T PANIC</strong>, your
   40:         friendly Werkzeug powered traceback interpreter.
   41:       </div>
   42:     </div>
   43: 
   44:     <div class="pin-prompt">
   45:       <div class="inner">
   46:         <h3>Console Locked</h3>
   47:         <p>
   48:           The console is locked and needs to be unlocked by entering the PIN.
   49:           You can find the PIN printed out on the standard output of your
   50:           shell that runs the server.
   51:         <form>
   52:           <p>PIN:
   53:             <input type=text name=pin size=14>
   54:             <input type=submit name=btn value="Confirm Pin">
   55:         </form>
   56:       </div>
   57:     </div>
   58:   </body>
   59: </html>
   60: """
   61: 
   62: PAGE_HTML = (
   63:     HEADER
   64:     + """\
   65: <h1>%(exception_type)s</h1>
   66: <div class="detail">
   67:   <p class="errormsg">%(exception)s</p>
   68: </div>
   69: <h2 class="traceback">Traceback <em>(most recent call last)</em></h2>
   70: %(summary)s
   71: <div class="plain">
   72:     <p>
   73:       This is the Copy/Paste friendly version of the traceback.
   74:     </p>
   75:     <textarea cols="50" rows="10" name="code" readonly>%(plaintext)s</textarea>
   76: </div>
   77: <div class="explanation">
   78:   The debugger caught an exception in your WSGI application.  You can now
   79:   look at the traceback which led to the error.  <span class="nojavascript">
   80:   If you enable JavaScript you can also use additional features such as code
   81:   execution (if the evalex feature is enabled), automatic pasting of the
   82:   exceptions and much more.</span>
   83: </div>
   84: """
   85:     + FOOTER
   86:     + """
   87: <!--
   88: 
   89: %(plaintext_cs)s
   90: 
   91: -->
   92: """
   93: )
   94: 
   95: CONSOLE_HTML = (
   96:     HEADER
   97:     + """\
   98: <h1>Interactive Console</h1>
   99: <div class="explanation">
  100: In this console you can execute Python expressions in the context of the
  101: application.  The initial namespace was created by the debugger automatically.
  102: </div>
  103: <div class="console"><div class="inner">The Console requires JavaScript.</div></div>
  104: """
  105:     + FOOTER
  106: )
  107: 
  108: SUMMARY_HTML = """\
  109: <div class="%(classes)s">
  110:   %(title)s
  111:   <ul>%(frames)s</ul>
  112:   %(description)s
  113: </div>
  114: """
  115: 
  116: FRAME_HTML = """\
  117: <div class="frame" id="frame-%(id)d">
  118:   <h4>File <cite class="filename">"%(filename)s"</cite>,
  119:       line <em class="line">%(lineno)s</em>,
  120:       in <code class="function">%(function_name)s</code></h4>
  121:   <div class="source %(library)s">%(lines)s</div>
  122: </div>
  123: """
  124: 
  125: 
  126: def _process_traceback(
  127:     exc: BaseException,
  128:     te: traceback.TracebackException | None = None,
  129:     *,
  130:     skip: int = 0,
  131:     hide: bool = True,
  132: ) -> traceback.TracebackException:
  133:     if te is None:
  134:         te = traceback.TracebackException.from_exception(exc, lookup_lines=False)
  135: 
  136:     # Get the frames the same way StackSummary.extract did, in order
  137:     # to match each frame with the FrameSummary to augment.
  138:     frame_gen = traceback.walk_tb(exc.__traceback__)
  139:     limit = getattr(sys, "tracebacklimit", None)
  140: 
  141:     if limit is not None:
  142:         if limit < 0:
  143:             limit = 0
  144: 
  145:         frame_gen = itertools.islice(frame_gen, limit)
  146: 
  147:     if skip:
  148:         frame_gen = itertools.islice(frame_gen, skip, None)
  149:         del te.stack[:skip]
  150: 
  151:     new_stack: list[DebugFrameSummary] = []
  152:     hidden = False
  153: 
  154:     # Match each frame with the FrameSummary that was generated.
  155:     # Hide frames using Paste's __traceback_hide__ rules. Replace
  156:     # all visible FrameSummary with DebugFrameSummary.
  157:     for (f, _), fs in zip(frame_gen, te.stack):
  158:         if hide:
  159:             hide_value = f.f_locals.get("__traceback_hide__", False)
  160: 
  161:             if hide_value in {"before", "before_and_this"}:
  162:                 new_stack = []
  163:                 hidden = False
  164: 
  165:                 if hide_value == "before_and_this":
  166:                     continue
  167:             elif hide_value in {"reset", "reset_and_this"}:
  168:                 hidden = False
  169: 
  170:                 if hide_value == "reset_and_this":
  171:                     continue
  172:             elif hide_value in {"after", "after_and_this"}:
  173:                 hidden = True
  174: 
  175:                 if hide_value == "after_and_this":
  176:                     continue
  177:             elif hide_value or hidden:
  178:                 continue
  179: 
  180:         frame_args: dict[str, t.Any] = {
  181:             "filename": fs.filename,
  182:             "lineno": fs.lineno,
  183:             "name": fs.name,
  184:             "locals": f.f_locals,
  185:             "globals": f.f_globals,
  186:         }
  187: 
  188:         if hasattr(fs, "colno"):
  189:             frame_args["colno"] = fs.colno
  190:             frame_args["end_colno"] = fs.end_colno
  191: 
  192:         new_stack.append(DebugFrameSummary(**frame_args))
  193: 
  194:     # The codeop module is used to compile code from the interactive
  195:     # debugger. Hide any codeop frames from the bottom of the traceback.
  196:     while new_stack:
  197:         module = new_stack[0].global_ns.get("__name__")
  198: 
  199:         if module is None:
  200:             module = new_stack[0].local_ns.get("__name__")
  201: 
  202:         if module == "codeop":
  203:             del new_stack[0]
  204:         else:
  205:             break
  206: 
  207:     te.stack[:] = new_stack
  208: 
  209:     if te.__context__:
  210:         context_exc = t.cast(BaseException, exc.__context__)
  211:         te.__context__ = _process_traceback(context_exc, te.__context__, hide=hide)
  212: 
  213:     if te.__cause__:
  214:         cause_exc = t.cast(BaseException, exc.__cause__)
  215:         te.__cause__ = _process_traceback(cause_exc, te.__cause__, hide=hide)
  216: 
  217:     return te
  218: 
  219: 
  220: class DebugTraceback:
  221:     __slots__ = ("_te", "_cache_all_tracebacks", "_cache_all_frames")
  222: 
  223:     def __init__(
  224:         self,
  225:         exc: BaseException,
  226:         te: traceback.TracebackException | None = None,
  227:         *,
  228:         skip: int = 0,
  229:         hide: bool = True,
  230:     ) -> None:
  231:         self._te = _process_traceback(exc, te, skip=skip, hide=hide)
  232: 
  233:     def __str__(self) -> str:
  234:         return f"<{type(self).__name__} {self._te}>"
  235: 
  236:     @cached_property
  237:     def all_tracebacks(
  238:         self,
  239:     ) -> list[tuple[str | None, traceback.TracebackException]]:
  240:         out = []
  241:         current = self._te
  242: 
  243:         while current is not None:
  244:             if current.__cause__ is not None:
  245:                 chained_msg = (
  246:                     "The above exception was the direct cause of the"
  247:                     " following exception"
  248:                 )
  249:                 chained_exc = current.__cause__
  250:             elif current.__context__ is not None and not current.__suppress_context__:
  251:                 chained_msg = (
  252:                     "During handling of the above exception, another"
  253:                     " exception occurred"
  254:                 )
  255:                 chained_exc = current.__context__
  256:             else:
  257:                 chained_msg = None
  258:                 chained_exc = None
  259: 
  260:             out.append((chained_msg, current))
  261:             current = chained_exc
  262: 
  263:         return out
  264: 
  265:     @cached_property
  266:     def all_frames(self) -> list[DebugFrameSummary]:
  267:         return [
  268:             f  # type: ignore[misc]
  269:             for _, te in self.all_tracebacks
  270:             for f in te.stack
  271:         ]
  272: 
  273:     def render_traceback_text(self) -> str:
  274:         return "".join(self._te.format())
  275: 
  276:     def render_traceback_html(self, include_title: bool = True) -> str:
  277:         library_frames = [f.is_library for f in self.all_frames]
  278:         mark_library = 0 < sum(library_frames) < len(library_frames)
  279:         rows = []
  280: 
  281:         if not library_frames:
  282:             classes = "traceback noframe-traceback"
  283:         else:
  284:             classes = "traceback"
  285: 
  286:             for msg, current in reversed(self.all_tracebacks):
  287:                 row_parts = []
  288: 
  289:                 if msg is not None:
  290:                     row_parts.append(f'<li><div class="exc-divider">{msg}:</div>')
  291: 
  292:                 for frame in current.stack:
  293:                     frame = t.cast(DebugFrameSummary, frame)
  294:                     info = f' title="{escape(frame.info)}"' if frame.info else ""
  295:                     row_parts.append(f"<li{info}>{frame.render_html(mark_library)}")
  296: 
  297:                 rows.append("\n".join(row_parts))
  298: 
  299:         is_syntax_error = issubclass(self._te.exc_type, SyntaxError)
  300: 
  301:         if include_title:
  302:             if is_syntax_error:
  303:                 title = "Syntax Error"
  304:             else:
  305:                 title = "Traceback <em>(most recent call last)</em>:"
  306:         else:
  307:             title = ""
  308: 
  309:         exc_full = escape("".join(self._te.format_exception_only()))
  310: 
  311:         if is_syntax_error:
  312:             description = f"<pre class=syntaxerror>{exc_full}</pre>"
  313:         else:
  314:             description = f"<blockquote>{exc_full}</blockquote>"
  315: 
  316:         return SUMMARY_HTML % {
  317:             "classes": classes,
  318:             "title": f"<h3>{title}</h3>",
  319:             "frames": "\n".join(rows),
  320:             "description": description,
  321:         }
  322: 
  323:     def render_debugger_html(
  324:         self, evalex: bool, secret: str, evalex_trusted: bool
  325:     ) -> str:
  326:         exc_lines = list(self._te.format_exception_only())
  327:         plaintext = "".join(self._te.format())
  328:         return PAGE_HTML % {
  329:             "evalex": "true" if evalex else "false",
  330:             "evalex_trusted": "true" if evalex_trusted else "false",
  331:             "console": "false",
  332:             "title": escape(exc_lines[0]),
  333:             "exception": escape("".join(exc_lines)),
  334:             "exception_type": escape(self._te.exc_type.__name__),
  335:             "summary": self.render_traceback_html(include_title=False),
  336:             "plaintext": escape(plaintext),
  337:             "plaintext_cs": re.sub("-{2,}", "-", plaintext),
  338:             "secret": secret,
  339:         }
  340: 
  341: 
  342: class DebugFrameSummary(traceback.FrameSummary):
  343:     """A :class:`traceback.FrameSummary` that can evaluate code in the
  344:     frame's namespace.
  345:     """
  346: 
  347:     __slots__ = (
  348:         "local_ns",
  349:         "global_ns",
  350:         "_cache_info",
  351:         "_cache_is_library",
  352:         "_cache_console",
  353:     )
  354: 
  355:     def __init__(
  356:         self,
  357:         *,
  358:         locals: dict[str, t.Any],
  359:         globals: dict[str, t.Any],
  360:         **kwargs: t.Any,
  361:     ) -> None:
  362:         super().__init__(locals=None, **kwargs)
  363:         self.local_ns = locals
  364:         self.global_ns = globals
  365: 
  366:     @cached_property
  367:     def info(self) -> str | None:
  368:         return self.local_ns.get("__traceback_info__")
  369: 
  370:     @cached_property
  371:     def is_library(self) -> bool:
  372:         return any(
  373:             self.filename.startswith((path, os.path.realpath(path)))
  374:             for path in sysconfig.get_paths().values()
  375:         )
  376: 
  377:     @cached_property
  378:     def console(self) -> Console:
  379:         return Console(self.global_ns, self.local_ns)
  380: 
  381:     def eval(self, code: str) -> t.Any:
  382:         return self.console.eval(code)
  383: 
  384:     def render_html(self, mark_library: bool) -> str:
  385:         context = 5
  386:         lines = linecache.getlines(self.filename)
  387:         line_idx = self.lineno - 1  # type: ignore[operator]
  388:         start_idx = max(0, line_idx - context)
  389:         stop_idx = min(len(lines), line_idx + context + 1)
  390:         rendered_lines = []
  391: 
  392:         def render_line(line: str, cls: str) -> None:
  393:             line = line.expandtabs().rstrip()
  394:             stripped_line = line.strip()
  395:             prefix = len(line) - len(stripped_line)
  396:             colno = getattr(self, "colno", 0)
  397:             end_colno = getattr(self, "end_colno", 0)
  398: 
  399:             if cls == "current" and colno and end_colno:
  400:                 arrow = (
  401:                     f'\n<span class="ws">{" " * prefix}</span>'
  402:                     f'{" " * (colno - prefix)}{"^" * (end_colno - colno)}'
  403:                 )
  404:             else:
  405:                 arrow = ""
  406: 
  407:             rendered_lines.append(
  408:                 f'<pre class="line {cls}"><span class="ws">{" " * prefix}</span>'
  409:                 f"{escape(stripped_line) if stripped_line else ' '}"
  410:                 f"{arrow if arrow else ''}</pre>"
  411:             )
  412: 
  413:         if lines:
  414:             for line in lines[start_idx:line_idx]:
  415:                 render_line(line, "before")
  416: 
  417:             render_line(lines[line_idx], "current")
  418: 
  419:             for line in lines[line_idx + 1 : stop_idx]:
  420:                 render_line(line, "after")
  421: 
  422:         return FRAME_HTML % {
  423:             "id": id(self),
  424:             "filename": escape(self.filename),
  425:             "lineno": self.lineno,
  426:             "function_name": escape(self.name),
  427:             "lines": "\n".join(rendered_lines),
  428:             "library": "library" if mark_library and self.is_library else "",
  429:         }
  430: 
  431: 
  432: def render_console_html(secret: str, evalex_trusted: bool) -> str:
  433:     return CONSOLE_HTML % {
  434:         "evalex": "true",
  435:         "evalex_trusted": "true" if evalex_trusted else "false",
  436:         "console": "true",
  437:         "title": "Console",
  438:         "secret": secret,
  439:     }
