    1: from __future__ import annotations
    2: 
    3: import code
    4: import sys
    5: import typing as t
    6: from contextvars import ContextVar
    7: from types import CodeType
    8: 
    9: from markupsafe import escape
   10: 
   11: from .repr import debug_repr
   12: from .repr import dump
   13: from .repr import helper
   14: 
   15: _stream: ContextVar[HTMLStringO] = ContextVar("werkzeug.debug.console.stream")
   16: _ipy: ContextVar[_InteractiveConsole] = ContextVar("werkzeug.debug.console.ipy")
   17: 
   18: 
   19: class HTMLStringO:
   20:     """A StringO version that HTML escapes on write."""
   21: 
   22:     def __init__(self) -> None:
   23:         self._buffer: list[str] = []
   24: 
   25:     def isatty(self) -> bool:
   26:         return False
   27: 
   28:     def close(self) -> None:
   29:         pass
   30: 
   31:     def flush(self) -> None:
   32:         pass
   33: 
   34:     def seek(self, n: int, mode: int = 0) -> None:
   35:         pass
   36: 
   37:     def readline(self) -> str:
   38:         if len(self._buffer) == 0:
   39:             return ""
   40:         ret = self._buffer[0]
   41:         del self._buffer[0]
   42:         return ret
   43: 
   44:     def reset(self) -> str:
   45:         val = "".join(self._buffer)
   46:         del self._buffer[:]
   47:         return val
   48: 
   49:     def _write(self, x: str) -> None:
   50:         self._buffer.append(x)
   51: 
   52:     def write(self, x: str) -> None:
   53:         self._write(escape(x))
   54: 
   55:     def writelines(self, x: t.Iterable[str]) -> None:
   56:         self._write(escape("".join(x)))
   57: 
   58: 
   59: class ThreadedStream:
   60:     """Thread-local wrapper for sys.stdout for the interactive console."""
   61: 
   62:     @staticmethod
   63:     def push() -> None:
   64:         if not isinstance(sys.stdout, ThreadedStream):
   65:             sys.stdout = t.cast(t.TextIO, ThreadedStream())
   66: 
   67:         _stream.set(HTMLStringO())
   68: 
   69:     @staticmethod
   70:     def fetch() -> str:
   71:         try:
   72:             stream = _stream.get()
   73:         except LookupError:
   74:             return ""
   75: 
   76:         return stream.reset()
   77: 
   78:     @staticmethod
   79:     def displayhook(obj: object) -> None:
   80:         try:
   81:             stream = _stream.get()
   82:         except LookupError:
   83:             return _displayhook(obj)  # type: ignore
   84: 
   85:         # stream._write bypasses escaping as debug_repr is
   86:         # already generating HTML for us.
   87:         if obj is not None:
   88:             _ipy.get().locals["_"] = obj
   89:             stream._write(debug_repr(obj))
   90: 
   91:     def __setattr__(self, name: str, value: t.Any) -> None:
   92:         raise AttributeError(f"read only attribute {name}")
   93: 
   94:     def __dir__(self) -> list[str]:
   95:         return dir(sys.__stdout__)
   96: 
   97:     def __getattribute__(self, name: str) -> t.Any:
   98:         try:
   99:             stream = _stream.get()
  100:         except LookupError:
  101:             stream = sys.__stdout__  # type: ignore[assignment]
  102: 
  103:         return getattr(stream, name)
  104: 
  105:     def __repr__(self) -> str:
  106:         return repr(sys.__stdout__)
  107: 
  108: 
  109: # add the threaded stream as display hook
  110: _displayhook = sys.displayhook
  111: sys.displayhook = ThreadedStream.displayhook
  112: 
  113: 
  114: class _ConsoleLoader:
  115:     def __init__(self) -> None:
  116:         self._storage: dict[int, str] = {}
  117: 
  118:     def register(self, code: CodeType, source: str) -> None:
  119:         self._storage[id(code)] = source
  120:         # register code objects of wrapped functions too.
  121:         for var in code.co_consts:
  122:             if isinstance(var, CodeType):
  123:                 self._storage[id(var)] = source
  124: 
  125:     def get_source_by_code(self, code: CodeType) -> str | None:
  126:         try:
  127:             return self._storage[id(code)]
  128:         except KeyError:
  129:             return None
  130: 
  131: 
  132: class _InteractiveConsole(code.InteractiveInterpreter):
  133:     locals: dict[str, t.Any]
  134: 
  135:     def __init__(self, globals: dict[str, t.Any], locals: dict[str, t.Any]) -> None:
  136:         self.loader = _ConsoleLoader()
  137:         locals = {
  138:             **globals,
  139:             **locals,
  140:             "dump": dump,
  141:             "help": helper,
  142:             "__loader__": self.loader,
  143:         }
  144:         super().__init__(locals)
  145:         original_compile = self.compile
  146: 
  147:         def compile(source: str, filename: str, symbol: str) -> CodeType | None:
  148:             code = original_compile(source, filename, symbol)
  149: 
  150:             if code is not None:
  151:                 self.loader.register(code, source)
  152: 
  153:             return code
  154: 
  155:         self.compile = compile  # type: ignore[assignment]
  156:         self.more = False
  157:         self.buffer: list[str] = []
  158: 
  159:     def runsource(self, source: str, **kwargs: t.Any) -> str:  # type: ignore
  160:         source = f"{source.rstrip()}\n"
  161:         ThreadedStream.push()
  162:         prompt = "... " if self.more else ">>> "
  163:         try:
  164:             source_to_eval = "".join(self.buffer + [source])
  165:             if super().runsource(source_to_eval, "<debugger>", "single"):
  166:                 self.more = True
  167:                 self.buffer.append(source)
  168:             else:
  169:                 self.more = False
  170:                 del self.buffer[:]
  171:         finally:
  172:             output = ThreadedStream.fetch()
  173:         return f"{prompt}{escape(source)}{output}"
  174: 
  175:     def runcode(self, code: CodeType) -> None:
  176:         try:
  177:             exec(code, self.locals)
  178:         except Exception:
  179:             self.showtraceback()
  180: 
  181:     def showtraceback(self) -> None:
  182:         from .tbtools import DebugTraceback
  183: 
  184:         exc = t.cast(BaseException, sys.exc_info()[1])
  185:         te = DebugTraceback(exc, skip=1)
  186:         sys.stdout._write(te.render_traceback_html())  # type: ignore
  187: 
  188:     def showsyntaxerror(self, filename: str | None = None) -> None:
  189:         from .tbtools import DebugTraceback
  190: 
  191:         exc = t.cast(BaseException, sys.exc_info()[1])
  192:         te = DebugTraceback(exc, skip=4)
  193:         sys.stdout._write(te.render_traceback_html())  # type: ignore
  194: 
  195:     def write(self, data: str) -> None:
  196:         sys.stdout.write(data)
  197: 
  198: 
  199: class Console:
  200:     """An interactive console."""
  201: 
  202:     def __init__(
  203:         self,
  204:         globals: dict[str, t.Any] | None = None,
  205:         locals: dict[str, t.Any] | None = None,
  206:     ) -> None:
  207:         if locals is None:
  208:             locals = {}
  209:         if globals is None:
  210:             globals = {}
  211:         self._ipy = _InteractiveConsole(globals, locals)
  212: 
  213:     def eval(self, code: str) -> str:
  214:         _ipy.set(self._ipy)
  215:         old_sys_stdout = sys.stdout
  216:         try:
  217:             return self._ipy.runsource(code)
  218:         finally:
  219:             sys.stdout = old_sys_stdout
