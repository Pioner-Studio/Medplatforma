    1: """Imported from the recipes section of the itertools documentation.
    2: 
    3: All functions taken from the recipes section of the itertools library docs
    4: [1]_.
    5: Some backward-compatible usability improvements have been made.
    6: 
    7: .. [1] http://docs.python.org/library/itertools.html#recipes
    8: 
    9: """
   10: import warnings
   11: from collections import deque
   12: from itertools import (
   13:     chain,
   14:     combinations,
   15:     count,
   16:     cycle,
   17:     groupby,
   18:     islice,
   19:     repeat,
   20:     starmap,
   21:     tee,
   22:     zip_longest,
   23: )
   24: import operator
   25: from random import randrange, sample, choice
   26: 
   27: __all__ = [
   28:     'all_equal',
   29:     'before_and_after',
   30:     'consume',
   31:     'convolve',
   32:     'dotproduct',
   33:     'first_true',
   34:     'flatten',
   35:     'grouper',
   36:     'iter_except',
   37:     'ncycles',
   38:     'nth',
   39:     'nth_combination',
   40:     'padnone',
   41:     'pad_none',
   42:     'pairwise',
   43:     'partition',
   44:     'powerset',
   45:     'prepend',
   46:     'quantify',
   47:     'random_combination_with_replacement',
   48:     'random_combination',
   49:     'random_permutation',
   50:     'random_product',
   51:     'repeatfunc',
   52:     'roundrobin',
   53:     'sliding_window',
   54:     'tabulate',
   55:     'tail',
   56:     'take',
   57:     'triplewise',
   58:     'unique_everseen',
   59:     'unique_justseen',
   60: ]
   61: 
   62: 
   63: def take(n, iterable):
   64:     """Return first *n* items of the iterable as a list.
   65: 
   66:         >>> take(3, range(10))
   67:         [0, 1, 2]
   68: 
   69:     If there are fewer than *n* items in the iterable, all of them are
   70:     returned.
   71: 
   72:         >>> take(10, range(3))
   73:         [0, 1, 2]
   74: 
   75:     """
   76:     return list(islice(iterable, n))
   77: 
   78: 
   79: def tabulate(function, start=0):
   80:     """Return an iterator over the results of ``func(start)``,
   81:     ``func(start + 1)``, ``func(start + 2)``...
   82: 
   83:     *func* should be a function that accepts one integer argument.
   84: 
   85:     If *start* is not specified it defaults to 0. It will be incremented each
   86:     time the iterator is advanced.
   87: 
   88:         >>> square = lambda x: x ** 2
   89:         >>> iterator = tabulate(square, -3)
   90:         >>> take(4, iterator)
   91:         [9, 4, 1, 0]
   92: 
   93:     """
   94:     return map(function, count(start))
   95: 
   96: 
   97: def tail(n, iterable):
   98:     """Return an iterator over the last *n* items of *iterable*.
   99: 
  100:     >>> t = tail(3, 'ABCDEFG')
  101:     >>> list(t)
  102:     ['E', 'F', 'G']
  103: 
  104:     """
  105:     return iter(deque(iterable, maxlen=n))
  106: 
  107: 
  108: def consume(iterator, n=None):
  109:     """Advance *iterable* by *n* steps. If *n* is ``None``, consume it
  110:     entirely.
  111: 
  112:     Efficiently exhausts an iterator without returning values. Defaults to
  113:     consuming the whole iterator, but an optional second argument may be
  114:     provided to limit consumption.
  115: 
  116:         >>> i = (x for x in range(10))
  117:         >>> next(i)
  118:         0
  119:         >>> consume(i, 3)
  120:         >>> next(i)
  121:         4
  122:         >>> consume(i)
  123:         >>> next(i)
  124:         Traceback (most recent call last):
  125:           File "<stdin>", line 1, in <module>
  126:         StopIteration
  127: 
  128:     If the iterator has fewer items remaining than the provided limit, the
  129:     whole iterator will be consumed.
  130: 
  131:         >>> i = (x for x in range(3))
  132:         >>> consume(i, 5)
  133:         >>> next(i)
  134:         Traceback (most recent call last):
  135:           File "<stdin>", line 1, in <module>
  136:         StopIteration
  137: 
  138:     """
  139:     # Use functions that consume iterators at C speed.
  140:     if n is None:
  141:         # feed the entire iterator into a zero-length deque
  142:         deque(iterator, maxlen=0)
  143:     else:
  144:         # advance to the empty slice starting at position n
  145:         next(islice(iterator, n, n), None)
  146: 
  147: 
  148: def nth(iterable, n, default=None):
  149:     """Returns the nth item or a default value.
  150: 
  151:     >>> l = range(10)
  152:     >>> nth(l, 3)
  153:     3
  154:     >>> nth(l, 20, "zebra")
  155:     'zebra'
  156: 
  157:     """
  158:     return next(islice(iterable, n, None), default)
  159: 
  160: 
  161: def all_equal(iterable):
  162:     """
  163:     Returns ``True`` if all the elements are equal to each other.
  164: 
  165:         >>> all_equal('aaaa')
  166:         True
  167:         >>> all_equal('aaab')
  168:         False
  169: 
  170:     """
  171:     g = groupby(iterable)
  172:     return next(g, True) and not next(g, False)
  173: 
  174: 
  175: def quantify(iterable, pred=bool):
  176:     """Return the how many times the predicate is true.
  177: 
  178:     >>> quantify([True, False, True])
  179:     2
  180: 
  181:     """
  182:     return sum(map(pred, iterable))
  183: 
  184: 
  185: def pad_none(iterable):
  186:     """Returns the sequence of elements and then returns ``None`` indefinitely.
  187: 
  188:         >>> take(5, pad_none(range(3)))
  189:         [0, 1, 2, None, None]
  190: 
  191:     Useful for emulating the behavior of the built-in :func:`map` function.
  192: 
  193:     See also :func:`padded`.
  194: 
  195:     """
  196:     return chain(iterable, repeat(None))
  197: 
  198: 
  199: padnone = pad_none
  200: 
  201: 
  202: def ncycles(iterable, n):
  203:     """Returns the sequence elements *n* times
  204: 
  205:     >>> list(ncycles(["a", "b"], 3))
  206:     ['a', 'b', 'a', 'b', 'a', 'b']
  207: 
  208:     """
  209:     return chain.from_iterable(repeat(tuple(iterable), n))
  210: 
  211: 
  212: def dotproduct(vec1, vec2):
  213:     """Returns the dot product of the two iterables.
  214: 
  215:     >>> dotproduct([10, 10], [20, 20])
  216:     400
  217: 
  218:     """
  219:     return sum(map(operator.mul, vec1, vec2))
  220: 
  221: 
  222: def flatten(listOfLists):
  223:     """Return an iterator flattening one level of nesting in a list of lists.
  224: 
  225:         >>> list(flatten([[0, 1], [2, 3]]))
  226:         [0, 1, 2, 3]
  227: 
  228:     See also :func:`collapse`, which can flatten multiple levels of nesting.
  229: 
  230:     """
  231:     return chain.from_iterable(listOfLists)
  232: 
  233: 
  234: def repeatfunc(func, times=None, *args):
  235:     """Call *func* with *args* repeatedly, returning an iterable over the
  236:     results.
  237: 
  238:     If *times* is specified, the iterable will terminate after that many
  239:     repetitions:
  240: 
  241:         >>> from operator import add
  242:         >>> times = 4
  243:         >>> args = 3, 5
  244:         >>> list(repeatfunc(add, times, *args))
  245:         [8, 8, 8, 8]
  246: 
  247:     If *times* is ``None`` the iterable will not terminate:
  248: 
  249:         >>> from random import randrange
  250:         >>> times = None
  251:         >>> args = 1, 11
  252:         >>> take(6, repeatfunc(randrange, times, *args))  # doctest:+SKIP
  253:         [2, 4, 8, 1, 8, 4]
  254: 
  255:     """
  256:     if times is None:
  257:         return starmap(func, repeat(args))
  258:     return starmap(func, repeat(args, times))
  259: 
  260: 
  261: def _pairwise(iterable):
  262:     """Returns an iterator of paired items, overlapping, from the original
  263: 
  264:     >>> take(4, pairwise(count()))
  265:     [(0, 1), (1, 2), (2, 3), (3, 4)]
  266: 
  267:     On Python 3.10 and above, this is an alias for :func:`itertools.pairwise`.
  268: 
  269:     """
  270:     a, b = tee(iterable)
  271:     next(b, None)
  272:     yield from zip(a, b)
  273: 
  274: 
  275: try:
  276:     from itertools import pairwise as itertools_pairwise
  277: except ImportError:
  278:     pairwise = _pairwise
  279: else:
  280: 
  281:     def pairwise(iterable):
  282:         yield from itertools_pairwise(iterable)
  283: 
  284:     pairwise.__doc__ = _pairwise.__doc__
  285: 
  286: 
  287: def grouper(iterable, n, fillvalue=None):
  288:     """Collect data into fixed-length chunks or blocks.
  289: 
  290:     >>> list(grouper('ABCDEFG', 3, 'x'))
  291:     [('A', 'B', 'C'), ('D', 'E', 'F'), ('G', 'x', 'x')]
  292: 
  293:     """
  294:     if isinstance(iterable, int):
  295:         warnings.warn(
  296:             "grouper expects iterable as first parameter", DeprecationWarning
  297:         )
  298:         n, iterable = iterable, n
  299:     args = [iter(iterable)] * n
  300:     return zip_longest(fillvalue=fillvalue, *args)
  301: 
  302: 
  303: def roundrobin(*iterables):
  304:     """Yields an item from each iterable, alternating between them.
  305: 
  306:         >>> list(roundrobin('ABC', 'D', 'EF'))
  307:         ['A', 'D', 'E', 'B', 'F', 'C']
  308: 
  309:     This function produces the same output as :func:`interleave_longest`, but
  310:     may perform better for some inputs (in particular when the number of
  311:     iterables is small).
  312: 
  313:     """
  314:     # Recipe credited to George Sakkis
  315:     pending = len(iterables)
  316:     nexts = cycle(iter(it).__next__ for it in iterables)
  317:     while pending:
  318:         try:
  319:             for next in nexts:
  320:                 yield next()
  321:         except StopIteration:
  322:             pending -= 1
  323:             nexts = cycle(islice(nexts, pending))
  324: 
  325: 
  326: def partition(pred, iterable):
  327:     """
  328:     Returns a 2-tuple of iterables derived from the input iterable.
  329:     The first yields the items that have ``pred(item) == False``.
  330:     The second yields the items that have ``pred(item) == True``.
  331: 
  332:         >>> is_odd = lambda x: x % 2 != 0
  333:         >>> iterable = range(10)
  334:         >>> even_items, odd_items = partition(is_odd, iterable)
  335:         >>> list(even_items), list(odd_items)
  336:         ([0, 2, 4, 6, 8], [1, 3, 5, 7, 9])
  337: 
  338:     If *pred* is None, :func:`bool` is used.
  339: 
  340:         >>> iterable = [0, 1, False, True, '', ' ']
  341:         >>> false_items, true_items = partition(None, iterable)
  342:         >>> list(false_items), list(true_items)
  343:         ([0, False, ''], [1, True, ' '])
  344: 
  345:     """
  346:     if pred is None:
  347:         pred = bool
  348: 
  349:     evaluations = ((pred(x), x) for x in iterable)
  350:     t1, t2 = tee(evaluations)
  351:     return (
  352:         (x for (cond, x) in t1 if not cond),
  353:         (x for (cond, x) in t2 if cond),
  354:     )
  355: 
  356: 
  357: def powerset(iterable):
  358:     """Yields all possible subsets of the iterable.
  359: 
  360:         >>> list(powerset([1, 2, 3]))
  361:         [(), (1,), (2,), (3,), (1, 2), (1, 3), (2, 3), (1, 2, 3)]
  362: 
  363:     :func:`powerset` will operate on iterables that aren't :class:`set`
  364:     instances, so repeated elements in the input will produce repeated elements
  365:     in the output. Use :func:`unique_everseen` on the input to avoid generating
  366:     duplicates:
  367: 
  368:         >>> seq = [1, 1, 0]
  369:         >>> list(powerset(seq))
  370:         [(), (1,), (1,), (0,), (1, 1), (1, 0), (1, 0), (1, 1, 0)]
  371:         >>> from more_itertools import unique_everseen
  372:         >>> list(powerset(unique_everseen(seq)))
  373:         [(), (1,), (0,), (1, 0)]
  374: 
  375:     """
  376:     s = list(iterable)
  377:     return chain.from_iterable(combinations(s, r) for r in range(len(s) + 1))
  378: 
  379: 
  380: def unique_everseen(iterable, key=None):
  381:     """
  382:     Yield unique elements, preserving order.
  383: 
  384:         >>> list(unique_everseen('AAAABBBCCDAABBB'))
  385:         ['A', 'B', 'C', 'D']
  386:         >>> list(unique_everseen('ABBCcAD', str.lower))
  387:         ['A', 'B', 'C', 'D']
  388: 
  389:     Sequences with a mix of hashable and unhashable items can be used.
  390:     The function will be slower (i.e., `O(n^2)`) for unhashable items.
  391: 
  392:     Remember that ``list`` objects are unhashable - you can use the *key*
  393:     parameter to transform the list to a tuple (which is hashable) to
  394:     avoid a slowdown.
  395: 
  396:         >>> iterable = ([1, 2], [2, 3], [1, 2])
  397:         >>> list(unique_everseen(iterable))  # Slow
  398:         [[1, 2], [2, 3]]
  399:         >>> list(unique_everseen(iterable, key=tuple))  # Faster
  400:         [[1, 2], [2, 3]]
  401: 
  402:     Similary, you may want to convert unhashable ``set`` objects with
  403:     ``key=frozenset``. For ``dict`` objects,
  404:     ``key=lambda x: frozenset(x.items())`` can be used.
  405: 
  406:     """
  407:     seenset = set()
  408:     seenset_add = seenset.add
  409:     seenlist = []
  410:     seenlist_add = seenlist.append
  411:     use_key = key is not None
  412: 
  413:     for element in iterable:
  414:         k = key(element) if use_key else element
  415:         try:
  416:             if k not in seenset:
  417:                 seenset_add(k)
  418:                 yield element
  419:         except TypeError:
  420:             if k not in seenlist:
  421:                 seenlist_add(k)
  422:                 yield element
  423: 
  424: 
  425: def unique_justseen(iterable, key=None):
  426:     """Yields elements in order, ignoring serial duplicates
  427: 
  428:     >>> list(unique_justseen('AAAABBBCCDAABBB'))
  429:     ['A', 'B', 'C', 'D', 'A', 'B']
  430:     >>> list(unique_justseen('ABBCcAD', str.lower))
  431:     ['A', 'B', 'C', 'A', 'D']
  432: 
  433:     """
  434:     return map(next, map(operator.itemgetter(1), groupby(iterable, key)))
  435: 
  436: 
  437: def iter_except(func, exception, first=None):
  438:     """Yields results from a function repeatedly until an exception is raised.
  439: 
  440:     Converts a call-until-exception interface to an iterator interface.
  441:     Like ``iter(func, sentinel)``, but uses an exception instead of a sentinel
  442:     to end the loop.
  443: 
  444:         >>> l = [0, 1, 2]
  445:         >>> list(iter_except(l.pop, IndexError))
  446:         [2, 1, 0]
  447: 
  448:     Multiple exceptions can be specified as a stopping condition:
  449: 
  450:         >>> l = [1, 2, 3, '...', 4, 5, 6]
  451:         >>> list(iter_except(lambda: 1 + l.pop(), (IndexError, TypeError)))
  452:         [7, 6, 5]
  453:         >>> list(iter_except(lambda: 1 + l.pop(), (IndexError, TypeError)))
  454:         [4, 3, 2]
  455:         >>> list(iter_except(lambda: 1 + l.pop(), (IndexError, TypeError)))
  456:         []
  457: 
  458:     """
  459:     try:
  460:         if first is not None:
  461:             yield first()
  462:         while 1:
  463:             yield func()
  464:     except exception:
  465:         pass
  466: 
  467: 
  468: def first_true(iterable, default=None, pred=None):
  469:     """
  470:     Returns the first true value in the iterable.
  471: 
  472:     If no true value is found, returns *default*
  473: 
  474:     If *pred* is not None, returns the first item for which
  475:     ``pred(item) == True`` .
  476: 
  477:         >>> first_true(range(10))
  478:         1
  479:         >>> first_true(range(10), pred=lambda x: x > 5)
  480:         6
  481:         >>> first_true(range(10), default='missing', pred=lambda x: x > 9)
  482:         'missing'
  483: 
  484:     """
  485:     return next(filter(pred, iterable), default)
  486: 
  487: 
  488: def random_product(*args, repeat=1):
  489:     """Draw an item at random from each of the input iterables.
  490: 
  491:         >>> random_product('abc', range(4), 'XYZ')  # doctest:+SKIP
  492:         ('c', 3, 'Z')
  493: 
  494:     If *repeat* is provided as a keyword argument, that many items will be
  495:     drawn from each iterable.
  496: 
  497:         >>> random_product('abcd', range(4), repeat=2)  # doctest:+SKIP
  498:         ('a', 2, 'd', 3)
  499: 
  500:     This equivalent to taking a random selection from
  501:     ``itertools.product(*args, **kwarg)``.
  502: 
  503:     """
  504:     pools = [tuple(pool) for pool in args] * repeat
  505:     return tuple(choice(pool) for pool in pools)
  506: 
  507: 
  508: def random_permutation(iterable, r=None):
  509:     """Return a random *r* length permutation of the elements in *iterable*.
  510: 
  511:     If *r* is not specified or is ``None``, then *r* defaults to the length of
  512:     *iterable*.
  513: 
  514:         >>> random_permutation(range(5))  # doctest:+SKIP
  515:         (3, 4, 0, 1, 2)
  516: 
  517:     This equivalent to taking a random selection from
  518:     ``itertools.permutations(iterable, r)``.
  519: 
  520:     """
  521:     pool = tuple(iterable)
  522:     r = len(pool) if r is None else r
  523:     return tuple(sample(pool, r))
  524: 
  525: 
  526: def random_combination(iterable, r):
  527:     """Return a random *r* length subsequence of the elements in *iterable*.
  528: 
  529:         >>> random_combination(range(5), 3)  # doctest:+SKIP
  530:         (2, 3, 4)
  531: 
  532:     This equivalent to taking a random selection from
  533:     ``itertools.combinations(iterable, r)``.
  534: 
  535:     """
  536:     pool = tuple(iterable)
  537:     n = len(pool)
  538:     indices = sorted(sample(range(n), r))
  539:     return tuple(pool[i] for i in indices)
  540: 
  541: 
  542: def random_combination_with_replacement(iterable, r):
  543:     """Return a random *r* length subsequence of elements in *iterable*,
  544:     allowing individual elements to be repeated.
  545: 
  546:         >>> random_combination_with_replacement(range(3), 5) # doctest:+SKIP
  547:         (0, 0, 1, 2, 2)
  548: 
  549:     This equivalent to taking a random selection from
  550:     ``itertools.combinations_with_replacement(iterable, r)``.
  551: 
  552:     """
  553:     pool = tuple(iterable)
  554:     n = len(pool)
  555:     indices = sorted(randrange(n) for i in range(r))
  556:     return tuple(pool[i] for i in indices)
  557: 
  558: 
  559: def nth_combination(iterable, r, index):
  560:     """Equivalent to ``list(combinations(iterable, r))[index]``.
  561: 
  562:     The subsequences of *iterable* that are of length *r* can be ordered
  563:     lexicographically. :func:`nth_combination` computes the subsequence at
  564:     sort position *index* directly, without computing the previous
  565:     subsequences.
  566: 
  567:         >>> nth_combination(range(5), 3, 5)
  568:         (0, 3, 4)
  569: 
  570:     ``ValueError`` will be raised If *r* is negative or greater than the length
  571:     of *iterable*.
  572:     ``IndexError`` will be raised if the given *index* is invalid.
  573:     """
  574:     pool = tuple(iterable)
  575:     n = len(pool)
  576:     if (r < 0) or (r > n):
  577:         raise ValueError
  578: 
  579:     c = 1
  580:     k = min(r, n - r)
  581:     for i in range(1, k + 1):
  582:         c = c * (n - k + i) // i
  583: 
  584:     if index < 0:
  585:         index += c
  586: 
  587:     if (index < 0) or (index >= c):
  588:         raise IndexError
  589: 
  590:     result = []
  591:     while r:
  592:         c, n, r = c * r // n, n - 1, r - 1
  593:         while index >= c:
  594:             index -= c
  595:             c, n = c * (n - r) // n, n - 1
  596:         result.append(pool[-1 - n])
  597: 
  598:     return tuple(result)
  599: 
  600: 
  601: def prepend(value, iterator):
  602:     """Yield *value*, followed by the elements in *iterator*.
  603: 
  604:         >>> value = '0'
  605:         >>> iterator = ['1', '2', '3']
  606:         >>> list(prepend(value, iterator))
  607:         ['0', '1', '2', '3']
  608: 
  609:     To prepend multiple values, see :func:`itertools.chain`
  610:     or :func:`value_chain`.
  611: 
  612:     """
  613:     return chain([value], iterator)
  614: 
  615: 
  616: def convolve(signal, kernel):
  617:     """Convolve the iterable *signal* with the iterable *kernel*.
  618: 
  619:         >>> signal = (1, 2, 3, 4, 5)
  620:         >>> kernel = [3, 2, 1]
  621:         >>> list(convolve(signal, kernel))
  622:         [3, 8, 14, 20, 26, 14, 5]
  623: 
  624:     Note: the input arguments are not interchangeable, as the *kernel*
  625:     is immediately consumed and stored.
  626: 
  627:     """
  628:     kernel = tuple(kernel)[::-1]
  629:     n = len(kernel)
  630:     window = deque([0], maxlen=n) * n
  631:     for x in chain(signal, repeat(0, n - 1)):
  632:         window.append(x)
  633:         yield sum(map(operator.mul, kernel, window))
  634: 
  635: 
  636: def before_and_after(predicate, it):
  637:     """A variant of :func:`takewhile` that allows complete access to the
  638:     remainder of the iterator.
  639: 
  640:          >>> it = iter('ABCdEfGhI')
  641:          >>> all_upper, remainder = before_and_after(str.isupper, it)
  642:          >>> ''.join(all_upper)
  643:          'ABC'
  644:          >>> ''.join(remainder) # takewhile() would lose the 'd'
  645:          'dEfGhI'
  646: 
  647:     Note that the first iterator must be fully consumed before the second
  648:     iterator can generate valid results.
  649:     """
  650:     it = iter(it)
  651:     transition = []
  652: 
  653:     def true_iterator():
  654:         for elem in it:
  655:             if predicate(elem):
  656:                 yield elem
  657:             else:
  658:                 transition.append(elem)
  659:                 return
  660: 
  661:     def remainder_iterator():
  662:         yield from transition
  663:         yield from it
  664: 
  665:     return true_iterator(), remainder_iterator()
  666: 
  667: 
  668: def triplewise(iterable):
  669:     """Return overlapping triplets from *iterable*.
  670: 
  671:     >>> list(triplewise('ABCDE'))
  672:     [('A', 'B', 'C'), ('B', 'C', 'D'), ('C', 'D', 'E')]
  673: 
  674:     """
  675:     for (a, _), (b, c) in pairwise(pairwise(iterable)):
  676:         yield a, b, c
  677: 
  678: 
  679: def sliding_window(iterable, n):
  680:     """Return a sliding window of width *n* over *iterable*.
  681: 
  682:         >>> list(sliding_window(range(6), 4))
  683:         [(0, 1, 2, 3), (1, 2, 3, 4), (2, 3, 4, 5)]
  684: 
  685:     If *iterable* has fewer than *n* items, then nothing is yielded:
  686: 
  687:         >>> list(sliding_window(range(3), 4))
  688:         []
  689: 
  690:     For a variant with more features, see :func:`windowed`.
  691:     """
  692:     it = iter(iterable)
  693:     window = deque(islice(it, n), maxlen=n)
  694:     if len(window) == n:
  695:         yield tuple(window)
  696:     for x in it:
  697:         window.append(x)
  698:         yield tuple(window)
