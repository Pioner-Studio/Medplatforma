    1: # Copyright 2009-present MongoDB, Inc.
    2: #
    3: # Licensed under the Apache License, Version 2.0 (the "License");
    4: # you may not use this file except in compliance with the License.
    5: # You may obtain a copy of the License at
    6: #
    7: # http://www.apache.org/licenses/LICENSE-2.0
    8: #
    9: # Unless required by applicable law or agreed to in writing, software
   10: # distributed under the License is distributed on an "AS IS" BASIS,
   11: # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12: # See the License for the specific language governing permissions and
   13: # limitations under the License.
   14: 
   15: """GridFS is a specification for storing large objects in Mongo.
   16: 
   17: The :mod:`gridfs` package is an implementation of GridFS on top of
   18: :mod:`pymongo`, exposing a file-like interface.
   19: 
   20: .. seealso:: The MongoDB documentation on `gridfs <https://dochub.mongodb.org/core/gridfs>`_.
   21: """
   22: from __future__ import annotations
   23: 
   24: from collections import abc
   25: from typing import Any, Mapping, Optional, cast
   26: 
   27: from bson.objectid import ObjectId
   28: from gridfs.errors import NoFile
   29: from gridfs.grid_file import (
   30:     DEFAULT_CHUNK_SIZE,
   31:     GridIn,
   32:     GridOut,
   33:     GridOutCursor,
   34:     _clear_entity_type_registry,
   35:     _disallow_transactions,
   36: )
   37: from pymongo import ASCENDING, DESCENDING, _csot
   38: from pymongo.client_session import ClientSession
   39: from pymongo.collection import Collection
   40: from pymongo.common import validate_string
   41: from pymongo.database import Database
   42: from pymongo.errors import ConfigurationError
   43: from pymongo.read_preferences import _ServerMode
   44: from pymongo.write_concern import WriteConcern
   45: 
   46: __all__ = [
   47:     "GridFS",
   48:     "GridFSBucket",
   49:     "NoFile",
   50:     "DEFAULT_CHUNK_SIZE",
   51:     "GridIn",
   52:     "GridOut",
   53:     "GridOutCursor",
   54: ]
   55: 
   56: 
   57: class GridFS:
   58:     """An instance of GridFS on top of a single Database."""
   59: 
   60:     def __init__(self, database: Database, collection: str = "fs"):
   61:         """Create a new instance of :class:`GridFS`.
   62: 
   63:         Raises :class:`TypeError` if `database` is not an instance of
   64:         :class:`~pymongo.database.Database`.
   65: 
   66:         :param database: database to use
   67:         :param collection: root collection to use
   68: 
   69:         .. versionchanged:: 4.0
   70:            Removed the `disable_md5` parameter. See
   71:            :ref:`removed-gridfs-checksum` for details.
   72: 
   73:         .. versionchanged:: 3.11
   74:            Running a GridFS operation in a transaction now always raises an
   75:            error. GridFS does not support multi-document transactions.
   76: 
   77:         .. versionchanged:: 3.7
   78:            Added the `disable_md5` parameter.
   79: 
   80:         .. versionchanged:: 3.1
   81:            Indexes are only ensured on the first write to the DB.
   82: 
   83:         .. versionchanged:: 3.0
   84:            `database` must use an acknowledged
   85:            :attr:`~pymongo.database.Database.write_concern`
   86: 
   87:         .. seealso:: The MongoDB documentation on `gridfs <https://dochub.mongodb.org/core/gridfs>`_.
   88:         """
   89:         if not isinstance(database, Database):
   90:             raise TypeError("database must be an instance of Database")
   91: 
   92:         database = _clear_entity_type_registry(database)
   93: 
   94:         if not database.write_concern.acknowledged:
   95:             raise ConfigurationError("database must use acknowledged write_concern")
   96: 
   97:         self.__collection = database[collection]
   98:         self.__files = self.__collection.files
   99:         self.__chunks = self.__collection.chunks
  100: 
  101:     def new_file(self, **kwargs: Any) -> GridIn:
  102:         """Create a new file in GridFS.
  103: 
  104:         Returns a new :class:`~gridfs.grid_file.GridIn` instance to
  105:         which data can be written. Any keyword arguments will be
  106:         passed through to :meth:`~gridfs.grid_file.GridIn`.
  107: 
  108:         If the ``"_id"`` of the file is manually specified, it must
  109:         not already exist in GridFS. Otherwise
  110:         :class:`~gridfs.errors.FileExists` is raised.
  111: 
  112:         :param kwargs: keyword arguments for file creation
  113:         """
  114:         return GridIn(self.__collection, **kwargs)
  115: 
  116:     def put(self, data: Any, **kwargs: Any) -> Any:
  117:         """Put data in GridFS as a new file.
  118: 
  119:         Equivalent to doing::
  120: 
  121:           with fs.new_file(**kwargs) as f:
  122:               f.write(data)
  123: 
  124:         `data` can be either an instance of :class:`bytes` or a file-like
  125:         object providing a :meth:`read` method. If an `encoding` keyword
  126:         argument is passed, `data` can also be a :class:`str` instance, which
  127:         will be encoded as `encoding` before being written. Any keyword
  128:         arguments will be passed through to the created file - see
  129:         :meth:`~gridfs.grid_file.GridIn` for possible arguments. Returns the
  130:         ``"_id"`` of the created file.
  131: 
  132:         If the ``"_id"`` of the file is manually specified, it must
  133:         not already exist in GridFS. Otherwise
  134:         :class:`~gridfs.errors.FileExists` is raised.
  135: 
  136:         :param data: data to be written as a file.
  137:         :param kwargs: keyword arguments for file creation
  138: 
  139:         .. versionchanged:: 3.0
  140:            w=0 writes to GridFS are now prohibited.
  141:         """
  142:         with GridIn(self.__collection, **kwargs) as grid_file:
  143:             grid_file.write(data)
  144:             return grid_file._id
  145: 
  146:     def get(self, file_id: Any, session: Optional[ClientSession] = None) -> GridOut:
  147:         """Get a file from GridFS by ``"_id"``.
  148: 
  149:         Returns an instance of :class:`~gridfs.grid_file.GridOut`,
  150:         which provides a file-like interface for reading.
  151: 
  152:         :param file_id: ``"_id"`` of the file to get
  153:         :param session: a
  154:             :class:`~pymongo.client_session.ClientSession`
  155: 
  156:         .. versionchanged:: 3.6
  157:            Added ``session`` parameter.
  158:         """
  159:         gout = GridOut(self.__collection, file_id, session=session)
  160: 
  161:         # Raise NoFile now, instead of on first attribute access.
  162:         gout._ensure_file()
  163:         return gout
  164: 
  165:     def get_version(
  166:         self,
  167:         filename: Optional[str] = None,
  168:         version: Optional[int] = -1,
  169:         session: Optional[ClientSession] = None,
  170:         **kwargs: Any,
  171:     ) -> GridOut:
  172:         """Get a file from GridFS by ``"filename"`` or metadata fields.
  173: 
  174:         Returns a version of the file in GridFS whose filename matches
  175:         `filename` and whose metadata fields match the supplied keyword
  176:         arguments, as an instance of :class:`~gridfs.grid_file.GridOut`.
  177: 
  178:         Version numbering is a convenience atop the GridFS API provided
  179:         by MongoDB. If more than one file matches the query (either by
  180:         `filename` alone, by metadata fields, or by a combination of
  181:         both), then version ``-1`` will be the most recently uploaded
  182:         matching file, ``-2`` the second most recently
  183:         uploaded, etc. Version ``0`` will be the first version
  184:         uploaded, ``1`` the second version, etc. So if three versions
  185:         have been uploaded, then version ``0`` is the same as version
  186:         ``-3``, version ``1`` is the same as version ``-2``, and
  187:         version ``2`` is the same as version ``-1``.
  188: 
  189:         Raises :class:`~gridfs.errors.NoFile` if no such version of
  190:         that file exists.
  191: 
  192:         :param filename: ``"filename"`` of the file to get, or `None`
  193:         :param version: version of the file to get (defaults
  194:             to -1, the most recent version uploaded)
  195:         :param session: a
  196:             :class:`~pymongo.client_session.ClientSession`
  197:         :param kwargs: find files by custom metadata.
  198: 
  199:         .. versionchanged:: 3.6
  200:            Added ``session`` parameter.
  201: 
  202:         .. versionchanged:: 3.1
  203:            ``get_version`` no longer ensures indexes.
  204:         """
  205:         query = kwargs
  206:         if filename is not None:
  207:             query["filename"] = filename
  208: 
  209:         _disallow_transactions(session)
  210:         cursor = self.__files.find(query, session=session)
  211:         if version is None:
  212:             version = -1
  213:         if version < 0:
  214:             skip = abs(version) - 1
  215:             cursor.limit(-1).skip(skip).sort("uploadDate", DESCENDING)
  216:         else:
  217:             cursor.limit(-1).skip(version).sort("uploadDate", ASCENDING)
  218:         try:
  219:             doc = next(cursor)
  220:             return GridOut(self.__collection, file_document=doc, session=session)
  221:         except StopIteration:
  222:             raise NoFile("no version %d for filename %r" % (version, filename)) from None
  223: 
  224:     def get_last_version(
  225:         self, filename: Optional[str] = None, session: Optional[ClientSession] = None, **kwargs: Any
  226:     ) -> GridOut:
  227:         """Get the most recent version of a file in GridFS by ``"filename"``
  228:         or metadata fields.
  229: 
  230:         Equivalent to calling :meth:`get_version` with the default
  231:         `version` (``-1``).
  232: 
  233:         :param filename: ``"filename"`` of the file to get, or `None`
  234:         :param session: a
  235:             :class:`~pymongo.client_session.ClientSession`
  236:         :param kwargs: find files by custom metadata.
  237: 
  238:         .. versionchanged:: 3.6
  239:            Added ``session`` parameter.
  240:         """
  241:         return self.get_version(filename=filename, session=session, **kwargs)
  242: 
  243:     # TODO add optional safe mode for chunk removal?
  244:     def delete(self, file_id: Any, session: Optional[ClientSession] = None) -> None:
  245:         """Delete a file from GridFS by ``"_id"``.
  246: 
  247:         Deletes all data belonging to the file with ``"_id"``:
  248:         `file_id`.
  249: 
  250:         .. warning:: Any processes/threads reading from the file while
  251:            this method is executing will likely see an invalid/corrupt
  252:            file. Care should be taken to avoid concurrent reads to a file
  253:            while it is being deleted.
  254: 
  255:         .. note:: Deletes of non-existent files are considered successful
  256:            since the end result is the same: no file with that _id remains.
  257: 
  258:         :param file_id: ``"_id"`` of the file to delete
  259:         :param session: a
  260:             :class:`~pymongo.client_session.ClientSession`
  261: 
  262:         .. versionchanged:: 3.6
  263:            Added ``session`` parameter.
  264: 
  265:         .. versionchanged:: 3.1
  266:            ``delete`` no longer ensures indexes.
  267:         """
  268:         _disallow_transactions(session)
  269:         self.__files.delete_one({"_id": file_id}, session=session)
  270:         self.__chunks.delete_many({"files_id": file_id}, session=session)
  271: 
  272:     def list(self, session: Optional[ClientSession] = None) -> list[str]:
  273:         """List the names of all files stored in this instance of
  274:         :class:`GridFS`.
  275: 
  276:         :param session: a
  277:             :class:`~pymongo.client_session.ClientSession`
  278: 
  279:         .. versionchanged:: 3.6
  280:            Added ``session`` parameter.
  281: 
  282:         .. versionchanged:: 3.1
  283:            ``list`` no longer ensures indexes.
  284:         """
  285:         _disallow_transactions(session)
  286:         # With an index, distinct includes documents with no filename
  287:         # as None.
  288:         return [
  289:             name for name in self.__files.distinct("filename", session=session) if name is not None
  290:         ]
  291: 
  292:     def find_one(
  293:         self,
  294:         filter: Optional[Any] = None,
  295:         session: Optional[ClientSession] = None,
  296:         *args: Any,
  297:         **kwargs: Any,
  298:     ) -> Optional[GridOut]:
  299:         """Get a single file from gridfs.
  300: 
  301:         All arguments to :meth:`find` are also valid arguments for
  302:         :meth:`find_one`, although any `limit` argument will be
  303:         ignored. Returns a single :class:`~gridfs.grid_file.GridOut`,
  304:         or ``None`` if no matching file is found. For example:
  305: 
  306:         .. code-block: python
  307: 
  308:             file = fs.find_one({"filename": "lisa.txt"})
  309: 
  310:         :param filter: a dictionary specifying
  311:             the query to be performing OR any other type to be used as
  312:             the value for a query for ``"_id"`` in the file collection.
  313:         :param args: any additional positional arguments are
  314:             the same as the arguments to :meth:`find`.
  315:         :param session: a
  316:             :class:`~pymongo.client_session.ClientSession`
  317:         :param kwargs: any additional keyword arguments
  318:             are the same as the arguments to :meth:`find`.
  319: 
  320:         .. versionchanged:: 3.6
  321:            Added ``session`` parameter.
  322:         """
  323:         if filter is not None and not isinstance(filter, abc.Mapping):
  324:             filter = {"_id": filter}
  325: 
  326:         _disallow_transactions(session)
  327:         for f in self.find(filter, *args, session=session, **kwargs):
  328:             return f
  329: 
  330:         return None
  331: 
  332:     def find(self, *args: Any, **kwargs: Any) -> GridOutCursor:
  333:         """Query GridFS for files.
  334: 
  335:         Returns a cursor that iterates across files matching
  336:         arbitrary queries on the files collection. Can be combined
  337:         with other modifiers for additional control. For example::
  338: 
  339:           for grid_out in fs.find({"filename": "lisa.txt"},
  340:                                   no_cursor_timeout=True):
  341:               data = grid_out.read()
  342: 
  343:         would iterate through all versions of "lisa.txt" stored in GridFS.
  344:         Note that setting no_cursor_timeout to True may be important to
  345:         prevent the cursor from timing out during long multi-file processing
  346:         work.
  347: 
  348:         As another example, the call::
  349: 
  350:           most_recent_three = fs.find().sort("uploadDate", -1).limit(3)
  351: 
  352:         would return a cursor to the three most recently uploaded files
  353:         in GridFS.
  354: 
  355:         Follows a similar interface to
  356:         :meth:`~pymongo.collection.Collection.find`
  357:         in :class:`~pymongo.collection.Collection`.
  358: 
  359:         If a :class:`~pymongo.client_session.ClientSession` is passed to
  360:         :meth:`find`, all returned :class:`~gridfs.grid_file.GridOut` instances
  361:         are associated with that session.
  362: 
  363:         :param filter: A query document that selects which files
  364:             to include in the result set. Can be an empty document to include
  365:             all files.
  366:         :param skip: the number of files to omit (from
  367:             the start of the result set) when returning the results
  368:         :param limit: the maximum number of results to
  369:             return
  370:         :param no_cursor_timeout: if False (the default), any
  371:             returned cursor is closed by the server after 10 minutes of
  372:             inactivity. If set to True, the returned cursor will never
  373:             time out on the server. Care should be taken to ensure that
  374:             cursors with no_cursor_timeout turned on are properly closed.
  375:         :param sort: a list of (key, direction) pairs
  376:             specifying the sort order for this query. See
  377:             :meth:`~pymongo.cursor.Cursor.sort` for details.
  378: 
  379:         Raises :class:`TypeError` if any of the arguments are of
  380:         improper type. Returns an instance of
  381:         :class:`~gridfs.grid_file.GridOutCursor`
  382:         corresponding to this query.
  383: 
  384:         .. versionchanged:: 3.0
  385:            Removed the read_preference, tag_sets, and
  386:            secondary_acceptable_latency_ms options.
  387:         .. versionadded:: 2.7
  388:         .. seealso:: The MongoDB documentation on `find <https://dochub.mongodb.org/core/find>`_.
  389:         """
  390:         return GridOutCursor(self.__collection, *args, **kwargs)
  391: 
  392:     def exists(
  393:         self,
  394:         document_or_id: Optional[Any] = None,
  395:         session: Optional[ClientSession] = None,
  396:         **kwargs: Any,
  397:     ) -> bool:
  398:         """Check if a file exists in this instance of :class:`GridFS`.
  399: 
  400:         The file to check for can be specified by the value of its
  401:         ``_id`` key, or by passing in a query document. A query
  402:         document can be passed in as dictionary, or by using keyword
  403:         arguments. Thus, the following three calls are equivalent:
  404: 
  405:         >>> fs.exists(file_id)
  406:         >>> fs.exists({"_id": file_id})
  407:         >>> fs.exists(_id=file_id)
  408: 
  409:         As are the following two calls:
  410: 
  411:         >>> fs.exists({"filename": "mike.txt"})
  412:         >>> fs.exists(filename="mike.txt")
  413: 
  414:         And the following two:
  415: 
  416:         >>> fs.exists({"foo": {"$gt": 12}})
  417:         >>> fs.exists(foo={"$gt": 12})
  418: 
  419:         Returns ``True`` if a matching file exists, ``False``
  420:         otherwise. Calls to :meth:`exists` will not automatically
  421:         create appropriate indexes; application developers should be
  422:         sure to create indexes if needed and as appropriate.
  423: 
  424:         :param document_or_id: query document, or _id of the
  425:             document to check for
  426:         :param session: a
  427:             :class:`~pymongo.client_session.ClientSession`
  428:         :param kwargs: keyword arguments are used as a
  429:             query document, if they're present.
  430: 
  431:         .. versionchanged:: 3.6
  432:            Added ``session`` parameter.
  433:         """
  434:         _disallow_transactions(session)
  435:         if kwargs:
  436:             f = self.__files.find_one(kwargs, ["_id"], session=session)
  437:         else:
  438:             f = self.__files.find_one(document_or_id, ["_id"], session=session)
  439: 
  440:         return f is not None
  441: 
  442: 
  443: class GridFSBucket:
  444:     """An instance of GridFS on top of a single Database."""
  445: 
  446:     def __init__(
  447:         self,
  448:         db: Database,
  449:         bucket_name: str = "fs",
  450:         chunk_size_bytes: int = DEFAULT_CHUNK_SIZE,
  451:         write_concern: Optional[WriteConcern] = None,
  452:         read_preference: Optional[_ServerMode] = None,
  453:     ) -> None:
  454:         """Create a new instance of :class:`GridFSBucket`.
  455: 
  456:         Raises :exc:`TypeError` if `database` is not an instance of
  457:         :class:`~pymongo.database.Database`.
  458: 
  459:         Raises :exc:`~pymongo.errors.ConfigurationError` if `write_concern`
  460:         is not acknowledged.
  461: 
  462:         :param database: database to use.
  463:         :param bucket_name: The name of the bucket. Defaults to 'fs'.
  464:         :param chunk_size_bytes: The chunk size in bytes. Defaults
  465:             to 255KB.
  466:         :param write_concern: The
  467:             :class:`~pymongo.write_concern.WriteConcern` to use. If ``None``
  468:             (the default) db.write_concern is used.
  469:         :param read_preference: The read preference to use. If
  470:             ``None`` (the default) db.read_preference is used.
  471: 
  472:         .. versionchanged:: 4.0
  473:            Removed the `disable_md5` parameter. See
  474:            :ref:`removed-gridfs-checksum` for details.
  475: 
  476:         .. versionchanged:: 3.11
  477:            Running a GridFSBucket operation in a transaction now always raises
  478:            an error. GridFSBucket does not support multi-document transactions.
  479: 
  480:         .. versionchanged:: 3.7
  481:            Added the `disable_md5` parameter.
  482: 
  483:         .. versionadded:: 3.1
  484: 
  485:         .. seealso:: The MongoDB documentation on `gridfs <https://dochub.mongodb.org/core/gridfs>`_.
  486:         """
  487:         if not isinstance(db, Database):
  488:             raise TypeError("database must be an instance of Database")
  489: 
  490:         db = _clear_entity_type_registry(db)
  491: 
  492:         wtc = write_concern if write_concern is not None else db.write_concern
  493:         if not wtc.acknowledged:
  494:             raise ConfigurationError("write concern must be acknowledged")
  495: 
  496:         self._bucket_name = bucket_name
  497:         self._collection = db[bucket_name]
  498:         self._chunks: Collection = self._collection.chunks.with_options(
  499:             write_concern=write_concern, read_preference=read_preference
  500:         )
  501: 
  502:         self._files: Collection = self._collection.files.with_options(
  503:             write_concern=write_concern, read_preference=read_preference
  504:         )
  505: 
  506:         self._chunk_size_bytes = chunk_size_bytes
  507:         self._timeout = db.client.options.timeout
  508: 
  509:     def open_upload_stream(
  510:         self,
  511:         filename: str,
  512:         chunk_size_bytes: Optional[int] = None,
  513:         metadata: Optional[Mapping[str, Any]] = None,
  514:         session: Optional[ClientSession] = None,
  515:     ) -> GridIn:
  516:         """Opens a Stream that the application can write the contents of the
  517:         file to.
  518: 
  519:         The user must specify the filename, and can choose to add any
  520:         additional information in the metadata field of the file document or
  521:         modify the chunk size.
  522:         For example::
  523: 
  524:           my_db = MongoClient().test
  525:           fs = GridFSBucket(my_db)
  526:           with fs.open_upload_stream(
  527:                 "test_file", chunk_size_bytes=4,
  528:                 metadata={"contentType": "text/plain"}) as grid_in:
  529:               grid_in.write("data I want to store!")
  530:           # uploaded on close
  531: 
  532:         Returns an instance of :class:`~gridfs.grid_file.GridIn`.
  533: 
  534:         Raises :exc:`~gridfs.errors.NoFile` if no such version of
  535:         that file exists.
  536:         Raises :exc:`~ValueError` if `filename` is not a string.
  537: 
  538:         :param filename: The name of the file to upload.
  539:         :param chunk_size_bytes` (options): The number of bytes per chunk of this
  540:             file. Defaults to the chunk_size_bytes in :class:`GridFSBucket`.
  541:         :param metadata: User data for the 'metadata' field of the
  542:             files collection document. If not provided the metadata field will
  543:             be omitted from the files collection document.
  544:         :param session: a
  545:             :class:`~pymongo.client_session.ClientSession`
  546: 
  547:         .. versionchanged:: 3.6
  548:            Added ``session`` parameter.
  549:         """
  550:         validate_string("filename", filename)
  551: 
  552:         opts = {
  553:             "filename": filename,
  554:             "chunk_size": (
  555:                 chunk_size_bytes if chunk_size_bytes is not None else self._chunk_size_bytes
  556:             ),
  557:         }
  558:         if metadata is not None:
  559:             opts["metadata"] = metadata
  560: 
  561:         return GridIn(self._collection, session=session, **opts)
  562: 
  563:     def open_upload_stream_with_id(
  564:         self,
  565:         file_id: Any,
  566:         filename: str,
  567:         chunk_size_bytes: Optional[int] = None,
  568:         metadata: Optional[Mapping[str, Any]] = None,
  569:         session: Optional[ClientSession] = None,
  570:     ) -> GridIn:
  571:         """Opens a Stream that the application can write the contents of the
  572:         file to.
  573: 
  574:         The user must specify the file id and filename, and can choose to add
  575:         any additional information in the metadata field of the file document
  576:         or modify the chunk size.
  577:         For example::
  578: 
  579:           my_db = MongoClient().test
  580:           fs = GridFSBucket(my_db)
  581:           with fs.open_upload_stream_with_id(
  582:                 ObjectId(),
  583:                 "test_file",
  584:                 chunk_size_bytes=4,
  585:                 metadata={"contentType": "text/plain"}) as grid_in:
  586:               grid_in.write("data I want to store!")
  587:           # uploaded on close
  588: 
  589:         Returns an instance of :class:`~gridfs.grid_file.GridIn`.
  590: 
  591:         Raises :exc:`~gridfs.errors.NoFile` if no such version of
  592:         that file exists.
  593:         Raises :exc:`~ValueError` if `filename` is not a string.
  594: 
  595:         :param file_id: The id to use for this file. The id must not have
  596:             already been used for another file.
  597:         :param filename: The name of the file to upload.
  598:         :param chunk_size_bytes` (options): The number of bytes per chunk of this
  599:             file. Defaults to the chunk_size_bytes in :class:`GridFSBucket`.
  600:         :param metadata: User data for the 'metadata' field of the
  601:             files collection document. If not provided the metadata field will
  602:             be omitted from the files collection document.
  603:         :param session: a
  604:             :class:`~pymongo.client_session.ClientSession`
  605: 
  606:         .. versionchanged:: 3.6
  607:            Added ``session`` parameter.
  608:         """
  609:         validate_string("filename", filename)
  610: 
  611:         opts = {
  612:             "_id": file_id,
  613:             "filename": filename,
  614:             "chunk_size": (
  615:                 chunk_size_bytes if chunk_size_bytes is not None else self._chunk_size_bytes
  616:             ),
  617:         }
  618:         if metadata is not None:
  619:             opts["metadata"] = metadata
  620: 
  621:         return GridIn(self._collection, session=session, **opts)
  622: 
  623:     @_csot.apply
  624:     def upload_from_stream(
  625:         self,
  626:         filename: str,
  627:         source: Any,
  628:         chunk_size_bytes: Optional[int] = None,
  629:         metadata: Optional[Mapping[str, Any]] = None,
  630:         session: Optional[ClientSession] = None,
  631:     ) -> ObjectId:
  632:         """Uploads a user file to a GridFS bucket.
  633: 
  634:         Reads the contents of the user file from `source` and uploads
  635:         it to the file `filename`. Source can be a string or file-like object.
  636:         For example::
  637: 
  638:           my_db = MongoClient().test
  639:           fs = GridFSBucket(my_db)
  640:           file_id = fs.upload_from_stream(
  641:               "test_file",
  642:               "data I want to store!",
  643:               chunk_size_bytes=4,
  644:               metadata={"contentType": "text/plain"})
  645: 
  646:         Returns the _id of the uploaded file.
  647: 
  648:         Raises :exc:`~gridfs.errors.NoFile` if no such version of
  649:         that file exists.
  650:         Raises :exc:`~ValueError` if `filename` is not a string.
  651: 
  652:         :param filename: The name of the file to upload.
  653:         :param source: The source stream of the content to be uploaded. Must be
  654:             a file-like object that implements :meth:`read` or a string.
  655:         :param chunk_size_bytes` (options): The number of bytes per chunk of this
  656:             file. Defaults to the chunk_size_bytes of :class:`GridFSBucket`.
  657:         :param metadata: User data for the 'metadata' field of the
  658:             files collection document. If not provided the metadata field will
  659:             be omitted from the files collection document.
  660:         :param session: a
  661:             :class:`~pymongo.client_session.ClientSession`
  662: 
  663:         .. versionchanged:: 3.6
  664:            Added ``session`` parameter.
  665:         """
  666:         with self.open_upload_stream(filename, chunk_size_bytes, metadata, session=session) as gin:
  667:             gin.write(source)
  668: 
  669:         return cast(ObjectId, gin._id)
  670: 
  671:     @_csot.apply
  672:     def upload_from_stream_with_id(
  673:         self,
  674:         file_id: Any,
  675:         filename: str,
  676:         source: Any,
  677:         chunk_size_bytes: Optional[int] = None,
  678:         metadata: Optional[Mapping[str, Any]] = None,
  679:         session: Optional[ClientSession] = None,
  680:     ) -> None:
  681:         """Uploads a user file to a GridFS bucket with a custom file id.
  682: 
  683:         Reads the contents of the user file from `source` and uploads
  684:         it to the file `filename`. Source can be a string or file-like object.
  685:         For example::
  686: 
  687:           my_db = MongoClient().test
  688:           fs = GridFSBucket(my_db)
  689:           file_id = fs.upload_from_stream(
  690:               ObjectId(),
  691:               "test_file",
  692:               "data I want to store!",
  693:               chunk_size_bytes=4,
  694:               metadata={"contentType": "text/plain"})
  695: 
  696:         Raises :exc:`~gridfs.errors.NoFile` if no such version of
  697:         that file exists.
  698:         Raises :exc:`~ValueError` if `filename` is not a string.
  699: 
  700:         :param file_id: The id to use for this file. The id must not have
  701:             already been used for another file.
  702:         :param filename: The name of the file to upload.
  703:         :param source: The source stream of the content to be uploaded. Must be
  704:             a file-like object that implements :meth:`read` or a string.
  705:         :param chunk_size_bytes` (options): The number of bytes per chunk of this
  706:             file. Defaults to the chunk_size_bytes of :class:`GridFSBucket`.
  707:         :param metadata: User data for the 'metadata' field of the
  708:             files collection document. If not provided the metadata field will
  709:             be omitted from the files collection document.
  710:         :param session: a
  711:             :class:`~pymongo.client_session.ClientSession`
  712: 
  713:         .. versionchanged:: 3.6
  714:            Added ``session`` parameter.
  715:         """
  716:         with self.open_upload_stream_with_id(
  717:             file_id, filename, chunk_size_bytes, metadata, session=session
  718:         ) as gin:
  719:             gin.write(source)
  720: 
  721:     def open_download_stream(
  722:         self, file_id: Any, session: Optional[ClientSession] = None
  723:     ) -> GridOut:
  724:         """Opens a Stream from which the application can read the contents of
  725:         the stored file specified by file_id.
  726: 
  727:         For example::
  728: 
  729:           my_db = MongoClient().test
  730:           fs = GridFSBucket(my_db)
  731:           # get _id of file to read.
  732:           file_id = fs.upload_from_stream("test_file", "data I want to store!")
  733:           grid_out = fs.open_download_stream(file_id)
  734:           contents = grid_out.read()
  735: 
  736:         Returns an instance of :class:`~gridfs.grid_file.GridOut`.
  737: 
  738:         Raises :exc:`~gridfs.errors.NoFile` if no file with file_id exists.
  739: 
  740:         :param file_id: The _id of the file to be downloaded.
  741:         :param session: a
  742:             :class:`~pymongo.client_session.ClientSession`
  743: 
  744:         .. versionchanged:: 3.6
  745:            Added ``session`` parameter.
  746:         """
  747:         gout = GridOut(self._collection, file_id, session=session)
  748: 
  749:         # Raise NoFile now, instead of on first attribute access.
  750:         gout._ensure_file()
  751:         return gout
  752: 
  753:     @_csot.apply
  754:     def download_to_stream(
  755:         self, file_id: Any, destination: Any, session: Optional[ClientSession] = None
  756:     ) -> None:
  757:         """Downloads the contents of the stored file specified by file_id and
  758:         writes the contents to `destination`.
  759: 
  760:         For example::
  761: 
  762:           my_db = MongoClient().test
  763:           fs = GridFSBucket(my_db)
  764:           # Get _id of file to read
  765:           file_id = fs.upload_from_stream("test_file", "data I want to store!")
  766:           # Get file to write to
  767:           file = open('myfile','wb+')
  768:           fs.download_to_stream(file_id, file)
  769:           file.seek(0)
  770:           contents = file.read()
  771: 
  772:         Raises :exc:`~gridfs.errors.NoFile` if no file with file_id exists.
  773: 
  774:         :param file_id: The _id of the file to be downloaded.
  775:         :param destination: a file-like object implementing :meth:`write`.
  776:         :param session: a
  777:             :class:`~pymongo.client_session.ClientSession`
  778: 
  779:         .. versionchanged:: 3.6
  780:            Added ``session`` parameter.
  781:         """
  782:         with self.open_download_stream(file_id, session=session) as gout:
  783:             while True:
  784:                 chunk = gout.readchunk()
  785:                 if not len(chunk):
  786:                     break
  787:                 destination.write(chunk)
  788: 
  789:     @_csot.apply
  790:     def delete(self, file_id: Any, session: Optional[ClientSession] = None) -> None:
  791:         """Given an file_id, delete this stored file's files collection document
  792:         and associated chunks from a GridFS bucket.
  793: 
  794:         For example::
  795: 
  796:           my_db = MongoClient().test
  797:           fs = GridFSBucket(my_db)
  798:           # Get _id of file to delete
  799:           file_id = fs.upload_from_stream("test_file", "data I want to store!")
  800:           fs.delete(file_id)
  801: 
  802:         Raises :exc:`~gridfs.errors.NoFile` if no file with file_id exists.
  803: 
  804:         :param file_id: The _id of the file to be deleted.
  805:         :param session: a
  806:             :class:`~pymongo.client_session.ClientSession`
  807: 
  808:         .. versionchanged:: 3.6
  809:            Added ``session`` parameter.
  810:         """
  811:         _disallow_transactions(session)
  812:         res = self._files.delete_one({"_id": file_id}, session=session)
  813:         self._chunks.delete_many({"files_id": file_id}, session=session)
  814:         if not res.deleted_count:
  815:             raise NoFile("no file could be deleted because none matched %s" % file_id)
  816: 
  817:     def find(self, *args: Any, **kwargs: Any) -> GridOutCursor:
  818:         """Find and return the files collection documents that match ``filter``
  819: 
  820:         Returns a cursor that iterates across files matching
  821:         arbitrary queries on the files collection. Can be combined
  822:         with other modifiers for additional control.
  823: 
  824:         For example::
  825: 
  826:           for grid_data in fs.find({"filename": "lisa.txt"},
  827:                                   no_cursor_timeout=True):
  828:               data = grid_data.read()
  829: 
  830:         would iterate through all versions of "lisa.txt" stored in GridFS.
  831:         Note that setting no_cursor_timeout to True may be important to
  832:         prevent the cursor from timing out during long multi-file processing
  833:         work.
  834: 
  835:         As another example, the call::
  836: 
  837:           most_recent_three = fs.find().sort("uploadDate", -1).limit(3)
  838: 
  839:         would return a cursor to the three most recently uploaded files
  840:         in GridFS.
  841: 
  842:         Follows a similar interface to
  843:         :meth:`~pymongo.collection.Collection.find`
  844:         in :class:`~pymongo.collection.Collection`.
  845: 
  846:         If a :class:`~pymongo.client_session.ClientSession` is passed to
  847:         :meth:`find`, all returned :class:`~gridfs.grid_file.GridOut` instances
  848:         are associated with that session.
  849: 
  850:         :param filter: Search query.
  851:         :param batch_size: The number of documents to return per
  852:             batch.
  853:         :param limit: The maximum number of documents to return.
  854:         :param no_cursor_timeout: The server normally times out idle
  855:             cursors after an inactivity period (10 minutes) to prevent excess
  856:             memory use. Set this option to True prevent that.
  857:         :param skip: The number of documents to skip before
  858:             returning.
  859:         :param sort: The order by which to sort results. Defaults to
  860:             None.
  861:         """
  862:         return GridOutCursor(self._collection, *args, **kwargs)
  863: 
  864:     def open_download_stream_by_name(
  865:         self, filename: str, revision: int = -1, session: Optional[ClientSession] = None
  866:     ) -> GridOut:
  867:         """Opens a Stream from which the application can read the contents of
  868:         `filename` and optional `revision`.
  869: 
  870:         For example::
  871: 
  872:           my_db = MongoClient().test
  873:           fs = GridFSBucket(my_db)
  874:           grid_out = fs.open_download_stream_by_name("test_file")
  875:           contents = grid_out.read()
  876: 
  877:         Returns an instance of :class:`~gridfs.grid_file.GridOut`.
  878: 
  879:         Raises :exc:`~gridfs.errors.NoFile` if no such version of
  880:         that file exists.
  881: 
  882:         Raises :exc:`~ValueError` filename is not a string.
  883: 
  884:         :param filename: The name of the file to read from.
  885:         :param revision: Which revision (documents with the same
  886:             filename and different uploadDate) of the file to retrieve.
  887:             Defaults to -1 (the most recent revision).
  888:         :param session: a
  889:             :class:`~pymongo.client_session.ClientSession`
  890: 
  891:         :Note: Revision numbers are defined as follows:
  892: 
  893:           - 0 = the original stored file
  894:           - 1 = the first revision
  895:           - 2 = the second revision
  896:           - etc...
  897:           - -2 = the second most recent revision
  898:           - -1 = the most recent revision
  899: 
  900:         .. versionchanged:: 3.6
  901:            Added ``session`` parameter.
  902:         """
  903:         validate_string("filename", filename)
  904:         query = {"filename": filename}
  905:         _disallow_transactions(session)
  906:         cursor = self._files.find(query, session=session)
  907:         if revision < 0:
  908:             skip = abs(revision) - 1
  909:             cursor.limit(-1).skip(skip).sort("uploadDate", DESCENDING)
  910:         else:
  911:             cursor.limit(-1).skip(revision).sort("uploadDate", ASCENDING)
  912:         try:
  913:             grid_file = next(cursor)
  914:             return GridOut(self._collection, file_document=grid_file, session=session)
  915:         except StopIteration:
  916:             raise NoFile("no version %d for filename %r" % (revision, filename)) from None
  917: 
  918:     @_csot.apply
  919:     def download_to_stream_by_name(
  920:         self,
  921:         filename: str,
  922:         destination: Any,
  923:         revision: int = -1,
  924:         session: Optional[ClientSession] = None,
  925:     ) -> None:
  926:         """Write the contents of `filename` (with optional `revision`) to
  927:         `destination`.
  928: 
  929:         For example::
  930: 
  931:           my_db = MongoClient().test
  932:           fs = GridFSBucket(my_db)
  933:           # Get file to write to
  934:           file = open('myfile','wb')
  935:           fs.download_to_stream_by_name("test_file", file)
  936: 
  937:         Raises :exc:`~gridfs.errors.NoFile` if no such version of
  938:         that file exists.
  939: 
  940:         Raises :exc:`~ValueError` if `filename` is not a string.
  941: 
  942:         :param filename: The name of the file to read from.
  943:         :param destination: A file-like object that implements :meth:`write`.
  944:         :param revision: Which revision (documents with the same
  945:             filename and different uploadDate) of the file to retrieve.
  946:             Defaults to -1 (the most recent revision).
  947:         :param session: a
  948:             :class:`~pymongo.client_session.ClientSession`
  949: 
  950:         :Note: Revision numbers are defined as follows:
  951: 
  952:           - 0 = the original stored file
  953:           - 1 = the first revision
  954:           - 2 = the second revision
  955:           - etc...
  956:           - -2 = the second most recent revision
  957:           - -1 = the most recent revision
  958: 
  959:         .. versionchanged:: 3.6
  960:            Added ``session`` parameter.
  961:         """
  962:         with self.open_download_stream_by_name(filename, revision, session=session) as gout:
  963:             while True:
  964:                 chunk = gout.readchunk()
  965:                 if not len(chunk):
  966:                     break
  967:                 destination.write(chunk)
  968: 
  969:     def rename(
  970:         self, file_id: Any, new_filename: str, session: Optional[ClientSession] = None
  971:     ) -> None:
  972:         """Renames the stored file with the specified file_id.
  973: 
  974:         For example::
  975: 
  976:           my_db = MongoClient().test
  977:           fs = GridFSBucket(my_db)
  978:           # Get _id of file to rename
  979:           file_id = fs.upload_from_stream("test_file", "data I want to store!")
  980:           fs.rename(file_id, "new_test_name")
  981: 
  982:         Raises :exc:`~gridfs.errors.NoFile` if no file with file_id exists.
  983: 
  984:         :param file_id: The _id of the file to be renamed.
  985:         :param new_filename: The new name of the file.
  986:         :param session: a
  987:             :class:`~pymongo.client_session.ClientSession`
  988: 
  989:         .. versionchanged:: 3.6
  990:            Added ``session`` parameter.
  991:         """
  992:         _disallow_transactions(session)
  993:         result = self._files.update_one(
  994:             {"_id": file_id}, {"$set": {"filename": new_filename}}, session=session
  995:         )
  996:         if not result.matched_count:
  997:             raise NoFile(
  998:                 "no files could be renamed %r because none "
  999:                 "matched file_id %i" % (new_filename, file_id)
 1000:             )
