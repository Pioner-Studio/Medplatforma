    1: from __future__ import annotations
    2: 
    3: import typing as t
    4: from datetime import datetime
    5: 
    6: 
    7: class BadData(Exception):
    8:     """Raised if bad data of any sort was encountered. This is the base
    9:     for all exceptions that ItsDangerous defines.
   10: 
   11:     .. versionadded:: 0.15
   12:     """
   13: 
   14:     def __init__(self, message: str):
   15:         super().__init__(message)
   16:         self.message = message
   17: 
   18:     def __str__(self) -> str:
   19:         return self.message
   20: 
   21: 
   22: class BadSignature(BadData):
   23:     """Raised if a signature does not match."""
   24: 
   25:     def __init__(self, message: str, payload: t.Any | None = None):
   26:         super().__init__(message)
   27: 
   28:         #: The payload that failed the signature test. In some
   29:         #: situations you might still want to inspect this, even if
   30:         #: you know it was tampered with.
   31:         #:
   32:         #: .. versionadded:: 0.14
   33:         self.payload: t.Any | None = payload
   34: 
   35: 
   36: class BadTimeSignature(BadSignature):
   37:     """Raised if a time-based signature is invalid. This is a subclass
   38:     of :class:`BadSignature`.
   39:     """
   40: 
   41:     def __init__(
   42:         self,
   43:         message: str,
   44:         payload: t.Any | None = None,
   45:         date_signed: datetime | None = None,
   46:     ):
   47:         super().__init__(message, payload)
   48: 
   49:         #: If the signature expired this exposes the date of when the
   50:         #: signature was created. This can be helpful in order to
   51:         #: tell the user how long a link has been gone stale.
   52:         #:
   53:         #: .. versionchanged:: 2.0
   54:         #:     The datetime value is timezone-aware rather than naive.
   55:         #:
   56:         #: .. versionadded:: 0.14
   57:         self.date_signed = date_signed
   58: 
   59: 
   60: class SignatureExpired(BadTimeSignature):
   61:     """Raised if a signature timestamp is older than ``max_age``. This
   62:     is a subclass of :exc:`BadTimeSignature`.
   63:     """
   64: 
   65: 
   66: class BadHeader(BadSignature):
   67:     """Raised if a signed header is invalid in some form. This only
   68:     happens for serializers that have a header that goes with the
   69:     signature.
   70: 
   71:     .. versionadded:: 0.24
   72:     """
   73: 
   74:     def __init__(
   75:         self,
   76:         message: str,
   77:         payload: t.Any | None = None,
   78:         header: t.Any | None = None,
   79:         original_error: Exception | None = None,
   80:     ):
   81:         super().__init__(message, payload)
   82: 
   83:         #: If the header is actually available but just malformed it
   84:         #: might be stored here.
   85:         self.header: t.Any | None = header
   86: 
   87:         #: If available, the error that indicates why the payload was
   88:         #: not valid. This might be ``None``.
   89:         self.original_error: Exception | None = original_error
   90: 
   91: 
   92: class BadPayload(BadData):
   93:     """Raised if a payload is invalid. This could happen if the payload
   94:     is loaded despite an invalid signature, or if there is a mismatch
   95:     between the serializer and deserializer. The original exception
   96:     that occurred during loading is stored on as :attr:`original_error`.
   97: 
   98:     .. versionadded:: 0.15
   99:     """
  100: 
  101:     def __init__(self, message: str, original_error: Exception | None = None):
  102:         super().__init__(message)
  103: 
  104:         #: If available, the error that indicates why the payload was
  105:         #: not valid. This might be ``None``.
  106:         self.original_error: Exception | None = original_error
