    1: from __future__ import annotations
    2: 
    3: from typing import (
    4:     TYPE_CHECKING,
    5:     Literal,
    6:     overload,
    7: )
    8: import warnings
    9: 
   10: import numpy as np
   11: 
   12: from pandas._libs import (
   13:     lib,
   14:     missing as libmissing,
   15: )
   16: from pandas.util._exceptions import find_stack_level
   17: 
   18: from pandas.core.dtypes.cast import maybe_box_native
   19: from pandas.core.dtypes.dtypes import (
   20:     BaseMaskedDtype,
   21:     ExtensionDtype,
   22: )
   23: 
   24: from pandas.core import common as com
   25: 
   26: if TYPE_CHECKING:
   27:     from pandas._typing import MutableMappingT
   28: 
   29:     from pandas import DataFrame
   30: 
   31: 
   32: @overload
   33: def to_dict(
   34:     df: DataFrame,
   35:     orient: Literal["dict", "list", "series", "split", "tight", "index"] = ...,
   36:     *,
   37:     into: type[MutableMappingT] | MutableMappingT,
   38:     index: bool = ...,
   39: ) -> MutableMappingT:
   40:     ...
   41: 
   42: 
   43: @overload
   44: def to_dict(
   45:     df: DataFrame,
   46:     orient: Literal["records"],
   47:     *,
   48:     into: type[MutableMappingT] | MutableMappingT,
   49:     index: bool = ...,
   50: ) -> list[MutableMappingT]:
   51:     ...
   52: 
   53: 
   54: @overload
   55: def to_dict(
   56:     df: DataFrame,
   57:     orient: Literal["dict", "list", "series", "split", "tight", "index"] = ...,
   58:     *,
   59:     into: type[dict] = ...,
   60:     index: bool = ...,
   61: ) -> dict:
   62:     ...
   63: 
   64: 
   65: @overload
   66: def to_dict(
   67:     df: DataFrame,
   68:     orient: Literal["records"],
   69:     *,
   70:     into: type[dict] = ...,
   71:     index: bool = ...,
   72: ) -> list[dict]:
   73:     ...
   74: 
   75: 
   76: # error: Incompatible default for argument "into" (default has type "type[dict
   77: # [Any, Any]]", argument has type "type[MutableMappingT] | MutableMappingT")
   78: def to_dict(
   79:     df: DataFrame,
   80:     orient: Literal[
   81:         "dict", "list", "series", "split", "tight", "records", "index"
   82:     ] = "dict",
   83:     *,
   84:     into: type[MutableMappingT] | MutableMappingT = dict,  # type: ignore[assignment]
   85:     index: bool = True,
   86: ) -> MutableMappingT | list[MutableMappingT]:
   87:     """
   88:     Convert the DataFrame to a dictionary.
   89: 
   90:     The type of the key-value pairs can be customized with the parameters
   91:     (see below).
   92: 
   93:     Parameters
   94:     ----------
   95:     orient : str {'dict', 'list', 'series', 'split', 'tight', 'records', 'index'}
   96:         Determines the type of the values of the dictionary.
   97: 
   98:         - 'dict' (default) : dict like {column -> {index -> value}}
   99:         - 'list' : dict like {column -> [values]}
  100:         - 'series' : dict like {column -> Series(values)}
  101:         - 'split' : dict like
  102:           {'index' -> [index], 'columns' -> [columns], 'data' -> [values]}
  103:         - 'tight' : dict like
  104:           {'index' -> [index], 'columns' -> [columns], 'data' -> [values],
  105:           'index_names' -> [index.names], 'column_names' -> [column.names]}
  106:         - 'records' : list like
  107:           [{column -> value}, ... , {column -> value}]
  108:         - 'index' : dict like {index -> {column -> value}}
  109: 
  110:         .. versionadded:: 1.4.0
  111:             'tight' as an allowed value for the ``orient`` argument
  112: 
  113:     into : class, default dict
  114:         The collections.abc.MutableMapping subclass used for all Mappings
  115:         in the return value.  Can be the actual class or an empty
  116:         instance of the mapping type you want.  If you want a
  117:         collections.defaultdict, you must pass it initialized.
  118: 
  119:     index : bool, default True
  120:         Whether to include the index item (and index_names item if `orient`
  121:         is 'tight') in the returned dictionary. Can only be ``False``
  122:         when `orient` is 'split' or 'tight'.
  123: 
  124:         .. versionadded:: 2.0.0
  125: 
  126:     Returns
  127:     -------
  128:     dict, list or collections.abc.Mapping
  129:         Return a collections.abc.MutableMapping object representing the
  130:         DataFrame. The resulting transformation depends on the `orient` parameter.
  131:     """
  132:     if not df.columns.is_unique:
  133:         warnings.warn(
  134:             "DataFrame columns are not unique, some columns will be omitted.",
  135:             UserWarning,
  136:             stacklevel=find_stack_level(),
  137:         )
  138:     # GH16122
  139:     into_c = com.standardize_mapping(into)
  140: 
  141:     #  error: Incompatible types in assignment (expression has type "str",
  142:     # variable has type "Literal['dict', 'list', 'series', 'split', 'tight',
  143:     # 'records', 'index']")
  144:     orient = orient.lower()  # type: ignore[assignment]
  145: 
  146:     if not index and orient not in ["split", "tight"]:
  147:         raise ValueError(
  148:             "'index=False' is only valid when 'orient' is 'split' or 'tight'"
  149:         )
  150: 
  151:     if orient == "series":
  152:         # GH46470 Return quickly if orient series to avoid creating dtype objects
  153:         return into_c((k, v) for k, v in df.items())
  154: 
  155:     box_native_indices = [
  156:         i
  157:         for i, col_dtype in enumerate(df.dtypes.values)
  158:         if col_dtype == np.dtype(object) or isinstance(col_dtype, ExtensionDtype)
  159:     ]
  160:     box_na_values = [
  161:         lib.no_default if not isinstance(col_dtype, BaseMaskedDtype) else libmissing.NA
  162:         for i, col_dtype in enumerate(df.dtypes.values)
  163:     ]
  164:     are_all_object_dtype_cols = len(box_native_indices) == len(df.dtypes)
  165: 
  166:     if orient == "dict":
  167:         return into_c((k, v.to_dict(into=into)) for k, v in df.items())
  168: 
  169:     elif orient == "list":
  170:         object_dtype_indices_as_set: set[int] = set(box_native_indices)
  171:         return into_c(
  172:             (
  173:                 k,
  174:                 list(map(maybe_box_native, v.to_numpy(na_value=box_na_values[i])))
  175:                 if i in object_dtype_indices_as_set
  176:                 else list(map(maybe_box_native, v.to_numpy())),
  177:             )
  178:             for i, (k, v) in enumerate(df.items())
  179:         )
  180: 
  181:     elif orient == "split":
  182:         data = df._create_data_for_split_and_tight_to_dict(
  183:             are_all_object_dtype_cols, box_native_indices
  184:         )
  185: 
  186:         return into_c(
  187:             ((("index", df.index.tolist()),) if index else ())
  188:             + (
  189:                 ("columns", df.columns.tolist()),
  190:                 ("data", data),
  191:             )
  192:         )
  193: 
  194:     elif orient == "tight":
  195:         data = df._create_data_for_split_and_tight_to_dict(
  196:             are_all_object_dtype_cols, box_native_indices
  197:         )
  198: 
  199:         return into_c(
  200:             ((("index", df.index.tolist()),) if index else ())
  201:             + (
  202:                 ("columns", df.columns.tolist()),
  203:                 (
  204:                     "data",
  205:                     [
  206:                         list(map(maybe_box_native, t))
  207:                         for t in df.itertuples(index=False, name=None)
  208:                     ],
  209:                 ),
  210:             )
  211:             + ((("index_names", list(df.index.names)),) if index else ())
  212:             + (("column_names", list(df.columns.names)),)
  213:         )
  214: 
  215:     elif orient == "records":
  216:         columns = df.columns.tolist()
  217:         if are_all_object_dtype_cols:
  218:             rows = (
  219:                 dict(zip(columns, row)) for row in df.itertuples(index=False, name=None)
  220:             )
  221:             return [
  222:                 into_c((k, maybe_box_native(v)) for k, v in row.items()) for row in rows
  223:             ]
  224:         else:
  225:             data = [
  226:                 into_c(zip(columns, t)) for t in df.itertuples(index=False, name=None)
  227:             ]
  228:             if box_native_indices:
  229:                 object_dtype_indices_as_set = set(box_native_indices)
  230:                 object_dtype_cols = {
  231:                     col
  232:                     for i, col in enumerate(df.columns)
  233:                     if i in object_dtype_indices_as_set
  234:                 }
  235:                 for row in data:
  236:                     for col in object_dtype_cols:
  237:                         row[col] = maybe_box_native(row[col])
  238:             return data
  239: 
  240:     elif orient == "index":
  241:         if not df.index.is_unique:
  242:             raise ValueError("DataFrame index must be unique for orient='index'.")
  243:         columns = df.columns.tolist()
  244:         if are_all_object_dtype_cols:
  245:             return into_c(
  246:                 (t[0], dict(zip(df.columns, map(maybe_box_native, t[1:]))))
  247:                 for t in df.itertuples(name=None)
  248:             )
  249:         elif box_native_indices:
  250:             object_dtype_indices_as_set = set(box_native_indices)
  251:             is_object_dtype_by_index = [
  252:                 i in object_dtype_indices_as_set for i in range(len(df.columns))
  253:             ]
  254:             return into_c(
  255:                 (
  256:                     t[0],
  257:                     {
  258:                         columns[i]: maybe_box_native(v)
  259:                         if is_object_dtype_by_index[i]
  260:                         else v
  261:                         for i, v in enumerate(t[1:])
  262:                     },
  263:                 )
  264:                 for t in df.itertuples(name=None)
  265:             )
  266:         else:
  267:             return into_c(
  268:                 (t[0], dict(zip(df.columns, t[1:]))) for t in df.itertuples(name=None)
  269:             )
  270: 
  271:     else:
  272:         raise ValueError(f"orient '{orient}' not understood")
