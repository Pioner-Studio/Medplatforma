    1: from __future__ import annotations
    2: 
    3: from functools import reduce
    4: 
    5: import numpy as np
    6: 
    7: from pandas._config import get_option
    8: 
    9: 
   10: def ensure_decoded(s) -> str:
   11:     """
   12:     If we have bytes, decode them to unicode.
   13:     """
   14:     if isinstance(s, (np.bytes_, bytes)):
   15:         s = s.decode(get_option("display.encoding"))
   16:     return s
   17: 
   18: 
   19: def result_type_many(*arrays_and_dtypes):
   20:     """
   21:     Wrapper around numpy.result_type which overcomes the NPY_MAXARGS (32)
   22:     argument limit.
   23:     """
   24:     try:
   25:         return np.result_type(*arrays_and_dtypes)
   26:     except ValueError:
   27:         # we have > NPY_MAXARGS terms in our expression
   28:         return reduce(np.result_type, arrays_and_dtypes)
   29:     except TypeError:
   30:         from pandas.core.dtypes.cast import find_common_type
   31:         from pandas.core.dtypes.common import is_extension_array_dtype
   32: 
   33:         arr_and_dtypes = list(arrays_and_dtypes)
   34:         ea_dtypes, non_ea_dtypes = [], []
   35:         for arr_or_dtype in arr_and_dtypes:
   36:             if is_extension_array_dtype(arr_or_dtype):
   37:                 ea_dtypes.append(arr_or_dtype)
   38:             else:
   39:                 non_ea_dtypes.append(arr_or_dtype)
   40: 
   41:         if non_ea_dtypes:
   42:             try:
   43:                 np_dtype = np.result_type(*non_ea_dtypes)
   44:             except ValueError:
   45:                 np_dtype = reduce(np.result_type, arrays_and_dtypes)
   46:             return find_common_type(ea_dtypes + [np_dtype])
   47: 
   48:         return find_common_type(ea_dtypes)
