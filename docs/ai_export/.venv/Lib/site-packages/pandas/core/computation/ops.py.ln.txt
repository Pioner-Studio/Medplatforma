    1: """
    2: Operator classes for eval.
    3: """
    4: 
    5: from __future__ import annotations
    6: 
    7: from datetime import datetime
    8: from functools import partial
    9: import operator
   10: from typing import (
   11:     TYPE_CHECKING,
   12:     Callable,
   13:     Literal,
   14: )
   15: 
   16: import numpy as np
   17: 
   18: from pandas._libs.tslibs import Timestamp
   19: 
   20: from pandas.core.dtypes.common import (
   21:     is_list_like,
   22:     is_scalar,
   23: )
   24: 
   25: import pandas.core.common as com
   26: from pandas.core.computation.common import (
   27:     ensure_decoded,
   28:     result_type_many,
   29: )
   30: from pandas.core.computation.scope import DEFAULT_GLOBALS
   31: 
   32: from pandas.io.formats.printing import (
   33:     pprint_thing,
   34:     pprint_thing_encoded,
   35: )
   36: 
   37: if TYPE_CHECKING:
   38:     from collections.abc import (
   39:         Iterable,
   40:         Iterator,
   41:     )
   42: 
   43: REDUCTIONS = ("sum", "prod", "min", "max")
   44: 
   45: _unary_math_ops = (
   46:     "sin",
   47:     "cos",
   48:     "exp",
   49:     "log",
   50:     "expm1",
   51:     "log1p",
   52:     "sqrt",
   53:     "sinh",
   54:     "cosh",
   55:     "tanh",
   56:     "arcsin",
   57:     "arccos",
   58:     "arctan",
   59:     "arccosh",
   60:     "arcsinh",
   61:     "arctanh",
   62:     "abs",
   63:     "log10",
   64:     "floor",
   65:     "ceil",
   66: )
   67: _binary_math_ops = ("arctan2",)
   68: 
   69: MATHOPS = _unary_math_ops + _binary_math_ops
   70: 
   71: 
   72: LOCAL_TAG = "__pd_eval_local_"
   73: 
   74: 
   75: class Term:
   76:     def __new__(cls, name, env, side=None, encoding=None):
   77:         klass = Constant if not isinstance(name, str) else cls
   78:         # error: Argument 2 for "super" not an instance of argument 1
   79:         supr_new = super(Term, klass).__new__  # type: ignore[misc]
   80:         return supr_new(klass)
   81: 
   82:     is_local: bool
   83: 
   84:     def __init__(self, name, env, side=None, encoding=None) -> None:
   85:         # name is a str for Term, but may be something else for subclasses
   86:         self._name = name
   87:         self.env = env
   88:         self.side = side
   89:         tname = str(name)
   90:         self.is_local = tname.startswith(LOCAL_TAG) or tname in DEFAULT_GLOBALS
   91:         self._value = self._resolve_name()
   92:         self.encoding = encoding
   93: 
   94:     @property
   95:     def local_name(self) -> str:
   96:         return self.name.replace(LOCAL_TAG, "")
   97: 
   98:     def __repr__(self) -> str:
   99:         return pprint_thing(self.name)
  100: 
  101:     def __call__(self, *args, **kwargs):
  102:         return self.value
  103: 
  104:     def evaluate(self, *args, **kwargs) -> Term:
  105:         return self
  106: 
  107:     def _resolve_name(self):
  108:         local_name = str(self.local_name)
  109:         is_local = self.is_local
  110:         if local_name in self.env.scope and isinstance(
  111:             self.env.scope[local_name], type
  112:         ):
  113:             is_local = False
  114: 
  115:         res = self.env.resolve(local_name, is_local=is_local)
  116:         self.update(res)
  117: 
  118:         if hasattr(res, "ndim") and res.ndim > 2:
  119:             raise NotImplementedError(
  120:                 "N-dimensional objects, where N > 2, are not supported with eval"
  121:             )
  122:         return res
  123: 
  124:     def update(self, value) -> None:
  125:         """
  126:         search order for local (i.e., @variable) variables:
  127: 
  128:         scope, key_variable
  129:         [('locals', 'local_name'),
  130:          ('globals', 'local_name'),
  131:          ('locals', 'key'),
  132:          ('globals', 'key')]
  133:         """
  134:         key = self.name
  135: 
  136:         # if it's a variable name (otherwise a constant)
  137:         if isinstance(key, str):
  138:             self.env.swapkey(self.local_name, key, new_value=value)
  139: 
  140:         self.value = value
  141: 
  142:     @property
  143:     def is_scalar(self) -> bool:
  144:         return is_scalar(self._value)
  145: 
  146:     @property
  147:     def type(self):
  148:         try:
  149:             # potentially very slow for large, mixed dtype frames
  150:             return self._value.values.dtype
  151:         except AttributeError:
  152:             try:
  153:                 # ndarray
  154:                 return self._value.dtype
  155:             except AttributeError:
  156:                 # scalar
  157:                 return type(self._value)
  158: 
  159:     return_type = type
  160: 
  161:     @property
  162:     def raw(self) -> str:
  163:         return f"{type(self).__name__}(name={repr(self.name)}, type={self.type})"
  164: 
  165:     @property
  166:     def is_datetime(self) -> bool:
  167:         try:
  168:             t = self.type.type
  169:         except AttributeError:
  170:             t = self.type
  171: 
  172:         return issubclass(t, (datetime, np.datetime64))
  173: 
  174:     @property
  175:     def value(self):
  176:         return self._value
  177: 
  178:     @value.setter
  179:     def value(self, new_value) -> None:
  180:         self._value = new_value
  181: 
  182:     @property
  183:     def name(self):
  184:         return self._name
  185: 
  186:     @property
  187:     def ndim(self) -> int:
  188:         return self._value.ndim
  189: 
  190: 
  191: class Constant(Term):
  192:     def _resolve_name(self):
  193:         return self._name
  194: 
  195:     @property
  196:     def name(self):
  197:         return self.value
  198: 
  199:     def __repr__(self) -> str:
  200:         # in python 2 str() of float
  201:         # can truncate shorter than repr()
  202:         return repr(self.name)
  203: 
  204: 
  205: _bool_op_map = {"not": "~", "and": "&", "or": "|"}
  206: 
  207: 
  208: class Op:
  209:     """
  210:     Hold an operator of arbitrary arity.
  211:     """
  212: 
  213:     op: str
  214: 
  215:     def __init__(self, op: str, operands: Iterable[Term | Op], encoding=None) -> None:
  216:         self.op = _bool_op_map.get(op, op)
  217:         self.operands = operands
  218:         self.encoding = encoding
  219: 
  220:     def __iter__(self) -> Iterator:
  221:         return iter(self.operands)
  222: 
  223:     def __repr__(self) -> str:
  224:         """
  225:         Print a generic n-ary operator and its operands using infix notation.
  226:         """
  227:         # recurse over the operands
  228:         parened = (f"({pprint_thing(opr)})" for opr in self.operands)
  229:         return pprint_thing(f" {self.op} ".join(parened))
  230: 
  231:     @property
  232:     def return_type(self):
  233:         # clobber types to bool if the op is a boolean operator
  234:         if self.op in (CMP_OPS_SYMS + BOOL_OPS_SYMS):
  235:             return np.bool_
  236:         return result_type_many(*(term.type for term in com.flatten(self)))
  237: 
  238:     @property
  239:     def has_invalid_return_type(self) -> bool:
  240:         types = self.operand_types
  241:         obj_dtype_set = frozenset([np.dtype("object")])
  242:         return self.return_type == object and types - obj_dtype_set
  243: 
  244:     @property
  245:     def operand_types(self):
  246:         return frozenset(term.type for term in com.flatten(self))
  247: 
  248:     @property
  249:     def is_scalar(self) -> bool:
  250:         return all(operand.is_scalar for operand in self.operands)
  251: 
  252:     @property
  253:     def is_datetime(self) -> bool:
  254:         try:
  255:             t = self.return_type.type
  256:         except AttributeError:
  257:             t = self.return_type
  258: 
  259:         return issubclass(t, (datetime, np.datetime64))
  260: 
  261: 
  262: def _in(x, y):
  263:     """
  264:     Compute the vectorized membership of ``x in y`` if possible, otherwise
  265:     use Python.
  266:     """
  267:     try:
  268:         return x.isin(y)
  269:     except AttributeError:
  270:         if is_list_like(x):
  271:             try:
  272:                 return y.isin(x)
  273:             except AttributeError:
  274:                 pass
  275:         return x in y
  276: 
  277: 
  278: def _not_in(x, y):
  279:     """
  280:     Compute the vectorized membership of ``x not in y`` if possible,
  281:     otherwise use Python.
  282:     """
  283:     try:
  284:         return ~x.isin(y)
  285:     except AttributeError:
  286:         if is_list_like(x):
  287:             try:
  288:                 return ~y.isin(x)
  289:             except AttributeError:
  290:                 pass
  291:         return x not in y
  292: 
  293: 
  294: CMP_OPS_SYMS = (">", "<", ">=", "<=", "==", "!=", "in", "not in")
  295: _cmp_ops_funcs = (
  296:     operator.gt,
  297:     operator.lt,
  298:     operator.ge,
  299:     operator.le,
  300:     operator.eq,
  301:     operator.ne,
  302:     _in,
  303:     _not_in,
  304: )
  305: _cmp_ops_dict = dict(zip(CMP_OPS_SYMS, _cmp_ops_funcs))
  306: 
  307: BOOL_OPS_SYMS = ("&", "|", "and", "or")
  308: _bool_ops_funcs = (operator.and_, operator.or_, operator.and_, operator.or_)
  309: _bool_ops_dict = dict(zip(BOOL_OPS_SYMS, _bool_ops_funcs))
  310: 
  311: ARITH_OPS_SYMS = ("+", "-", "*", "/", "**", "//", "%")
  312: _arith_ops_funcs = (
  313:     operator.add,
  314:     operator.sub,
  315:     operator.mul,
  316:     operator.truediv,
  317:     operator.pow,
  318:     operator.floordiv,
  319:     operator.mod,
  320: )
  321: _arith_ops_dict = dict(zip(ARITH_OPS_SYMS, _arith_ops_funcs))
  322: 
  323: SPECIAL_CASE_ARITH_OPS_SYMS = ("**", "//", "%")
  324: _special_case_arith_ops_funcs = (operator.pow, operator.floordiv, operator.mod)
  325: _special_case_arith_ops_dict = dict(
  326:     zip(SPECIAL_CASE_ARITH_OPS_SYMS, _special_case_arith_ops_funcs)
  327: )
  328: 
  329: _binary_ops_dict = {}
  330: 
  331: for d in (_cmp_ops_dict, _bool_ops_dict, _arith_ops_dict):
  332:     _binary_ops_dict.update(d)
  333: 
  334: 
  335: def _cast_inplace(terms, acceptable_dtypes, dtype) -> None:
  336:     """
  337:     Cast an expression inplace.
  338: 
  339:     Parameters
  340:     ----------
  341:     terms : Op
  342:         The expression that should cast.
  343:     acceptable_dtypes : list of acceptable numpy.dtype
  344:         Will not cast if term's dtype in this list.
  345:     dtype : str or numpy.dtype
  346:         The dtype to cast to.
  347:     """
  348:     dt = np.dtype(dtype)
  349:     for term in terms:
  350:         if term.type in acceptable_dtypes:
  351:             continue
  352: 
  353:         try:
  354:             new_value = term.value.astype(dt)
  355:         except AttributeError:
  356:             new_value = dt.type(term.value)
  357:         term.update(new_value)
  358: 
  359: 
  360: def is_term(obj) -> bool:
  361:     return isinstance(obj, Term)
  362: 
  363: 
  364: class BinOp(Op):
  365:     """
  366:     Hold a binary operator and its operands.
  367: 
  368:     Parameters
  369:     ----------
  370:     op : str
  371:     lhs : Term or Op
  372:     rhs : Term or Op
  373:     """
  374: 
  375:     def __init__(self, op: str, lhs, rhs) -> None:
  376:         super().__init__(op, (lhs, rhs))
  377:         self.lhs = lhs
  378:         self.rhs = rhs
  379: 
  380:         self._disallow_scalar_only_bool_ops()
  381: 
  382:         self.convert_values()
  383: 
  384:         try:
  385:             self.func = _binary_ops_dict[op]
  386:         except KeyError as err:
  387:             # has to be made a list for python3
  388:             keys = list(_binary_ops_dict.keys())
  389:             raise ValueError(
  390:                 f"Invalid binary operator {repr(op)}, valid operators are {keys}"
  391:             ) from err
  392: 
  393:     def __call__(self, env):
  394:         """
  395:         Recursively evaluate an expression in Python space.
  396: 
  397:         Parameters
  398:         ----------
  399:         env : Scope
  400: 
  401:         Returns
  402:         -------
  403:         object
  404:             The result of an evaluated expression.
  405:         """
  406:         # recurse over the left/right nodes
  407:         left = self.lhs(env)
  408:         right = self.rhs(env)
  409: 
  410:         return self.func(left, right)
  411: 
  412:     def evaluate(self, env, engine: str, parser, term_type, eval_in_python):
  413:         """
  414:         Evaluate a binary operation *before* being passed to the engine.
  415: 
  416:         Parameters
  417:         ----------
  418:         env : Scope
  419:         engine : str
  420:         parser : str
  421:         term_type : type
  422:         eval_in_python : list
  423: 
  424:         Returns
  425:         -------
  426:         term_type
  427:             The "pre-evaluated" expression as an instance of ``term_type``
  428:         """
  429:         if engine == "python":
  430:             res = self(env)
  431:         else:
  432:             # recurse over the left/right nodes
  433: 
  434:             left = self.lhs.evaluate(
  435:                 env,
  436:                 engine=engine,
  437:                 parser=parser,
  438:                 term_type=term_type,
  439:                 eval_in_python=eval_in_python,
  440:             )
  441: 
  442:             right = self.rhs.evaluate(
  443:                 env,
  444:                 engine=engine,
  445:                 parser=parser,
  446:                 term_type=term_type,
  447:                 eval_in_python=eval_in_python,
  448:             )
  449: 
  450:             # base cases
  451:             if self.op in eval_in_python:
  452:                 res = self.func(left.value, right.value)
  453:             else:
  454:                 from pandas.core.computation.eval import eval
  455: 
  456:                 res = eval(self, local_dict=env, engine=engine, parser=parser)
  457: 
  458:         name = env.add_tmp(res)
  459:         return term_type(name, env=env)
  460: 
  461:     def convert_values(self) -> None:
  462:         """
  463:         Convert datetimes to a comparable value in an expression.
  464:         """
  465: 
  466:         def stringify(value):
  467:             encoder: Callable
  468:             if self.encoding is not None:
  469:                 encoder = partial(pprint_thing_encoded, encoding=self.encoding)
  470:             else:
  471:                 encoder = pprint_thing
  472:             return encoder(value)
  473: 
  474:         lhs, rhs = self.lhs, self.rhs
  475: 
  476:         if is_term(lhs) and lhs.is_datetime and is_term(rhs) and rhs.is_scalar:
  477:             v = rhs.value
  478:             if isinstance(v, (int, float)):
  479:                 v = stringify(v)
  480:             v = Timestamp(ensure_decoded(v))
  481:             if v.tz is not None:
  482:                 v = v.tz_convert("UTC")
  483:             self.rhs.update(v)
  484: 
  485:         if is_term(rhs) and rhs.is_datetime and is_term(lhs) and lhs.is_scalar:
  486:             v = lhs.value
  487:             if isinstance(v, (int, float)):
  488:                 v = stringify(v)
  489:             v = Timestamp(ensure_decoded(v))
  490:             if v.tz is not None:
  491:                 v = v.tz_convert("UTC")
  492:             self.lhs.update(v)
  493: 
  494:     def _disallow_scalar_only_bool_ops(self):
  495:         rhs = self.rhs
  496:         lhs = self.lhs
  497: 
  498:         # GH#24883 unwrap dtype if necessary to ensure we have a type object
  499:         rhs_rt = rhs.return_type
  500:         rhs_rt = getattr(rhs_rt, "type", rhs_rt)
  501:         lhs_rt = lhs.return_type
  502:         lhs_rt = getattr(lhs_rt, "type", lhs_rt)
  503:         if (
  504:             (lhs.is_scalar or rhs.is_scalar)
  505:             and self.op in _bool_ops_dict
  506:             and (
  507:                 not (
  508:                     issubclass(rhs_rt, (bool, np.bool_))
  509:                     and issubclass(lhs_rt, (bool, np.bool_))
  510:                 )
  511:             )
  512:         ):
  513:             raise NotImplementedError("cannot evaluate scalar only bool ops")
  514: 
  515: 
  516: def isnumeric(dtype) -> bool:
  517:     return issubclass(np.dtype(dtype).type, np.number)
  518: 
  519: 
  520: class Div(BinOp):
  521:     """
  522:     Div operator to special case casting.
  523: 
  524:     Parameters
  525:     ----------
  526:     lhs, rhs : Term or Op
  527:         The Terms or Ops in the ``/`` expression.
  528:     """
  529: 
  530:     def __init__(self, lhs, rhs) -> None:
  531:         super().__init__("/", lhs, rhs)
  532: 
  533:         if not isnumeric(lhs.return_type) or not isnumeric(rhs.return_type):
  534:             raise TypeError(
  535:                 f"unsupported operand type(s) for {self.op}: "
  536:                 f"'{lhs.return_type}' and '{rhs.return_type}'"
  537:             )
  538: 
  539:         # do not upcast float32s to float64 un-necessarily
  540:         acceptable_dtypes = [np.float32, np.float64]
  541:         _cast_inplace(com.flatten(self), acceptable_dtypes, np.float64)
  542: 
  543: 
  544: UNARY_OPS_SYMS = ("+", "-", "~", "not")
  545: _unary_ops_funcs = (operator.pos, operator.neg, operator.invert, operator.invert)
  546: _unary_ops_dict = dict(zip(UNARY_OPS_SYMS, _unary_ops_funcs))
  547: 
  548: 
  549: class UnaryOp(Op):
  550:     """
  551:     Hold a unary operator and its operands.
  552: 
  553:     Parameters
  554:     ----------
  555:     op : str
  556:         The token used to represent the operator.
  557:     operand : Term or Op
  558:         The Term or Op operand to the operator.
  559: 
  560:     Raises
  561:     ------
  562:     ValueError
  563:         * If no function associated with the passed operator token is found.
  564:     """
  565: 
  566:     def __init__(self, op: Literal["+", "-", "~", "not"], operand) -> None:
  567:         super().__init__(op, (operand,))
  568:         self.operand = operand
  569: 
  570:         try:
  571:             self.func = _unary_ops_dict[op]
  572:         except KeyError as err:
  573:             raise ValueError(
  574:                 f"Invalid unary operator {repr(op)}, "
  575:                 f"valid operators are {UNARY_OPS_SYMS}"
  576:             ) from err
  577: 
  578:     def __call__(self, env) -> MathCall:
  579:         operand = self.operand(env)
  580:         # error: Cannot call function of unknown type
  581:         return self.func(operand)  # type: ignore[operator]
  582: 
  583:     def __repr__(self) -> str:
  584:         return pprint_thing(f"{self.op}({self.operand})")
  585: 
  586:     @property
  587:     def return_type(self) -> np.dtype:
  588:         operand = self.operand
  589:         if operand.return_type == np.dtype("bool"):
  590:             return np.dtype("bool")
  591:         if isinstance(operand, Op) and (
  592:             operand.op in _cmp_ops_dict or operand.op in _bool_ops_dict
  593:         ):
  594:             return np.dtype("bool")
  595:         return np.dtype("int")
  596: 
  597: 
  598: class MathCall(Op):
  599:     def __init__(self, func, args) -> None:
  600:         super().__init__(func.name, args)
  601:         self.func = func
  602: 
  603:     def __call__(self, env):
  604:         # error: "Op" not callable
  605:         operands = [op(env) for op in self.operands]  # type: ignore[operator]
  606:         return self.func.func(*operands)
  607: 
  608:     def __repr__(self) -> str:
  609:         operands = map(str, self.operands)
  610:         return pprint_thing(f"{self.op}({','.join(operands)})")
  611: 
  612: 
  613: class FuncNode:
  614:     def __init__(self, name: str) -> None:
  615:         if name not in MATHOPS:
  616:             raise ValueError(f'"{name}" is not a supported function')
  617:         self.name = name
  618:         self.func = getattr(np, name)
  619: 
  620:     def __call__(self, *args) -> MathCall:
  621:         return MathCall(self, args)
