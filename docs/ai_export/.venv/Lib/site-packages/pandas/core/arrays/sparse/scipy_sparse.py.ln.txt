    1: """
    2: Interaction with scipy.sparse matrices.
    3: 
    4: Currently only includes to_coo helpers.
    5: """
    6: from __future__ import annotations
    7: 
    8: from typing import TYPE_CHECKING
    9: 
   10: from pandas._libs import lib
   11: 
   12: from pandas.core.dtypes.missing import notna
   13: 
   14: from pandas.core.algorithms import factorize
   15: from pandas.core.indexes.api import MultiIndex
   16: from pandas.core.series import Series
   17: 
   18: if TYPE_CHECKING:
   19:     from collections.abc import Iterable
   20: 
   21:     import numpy as np
   22:     import scipy.sparse
   23: 
   24:     from pandas._typing import (
   25:         IndexLabel,
   26:         npt,
   27:     )
   28: 
   29: 
   30: def _check_is_partition(parts: Iterable, whole: Iterable):
   31:     whole = set(whole)
   32:     parts = [set(x) for x in parts]
   33:     if set.intersection(*parts) != set():
   34:         raise ValueError("Is not a partition because intersection is not null.")
   35:     if set.union(*parts) != whole:
   36:         raise ValueError("Is not a partition because union is not the whole.")
   37: 
   38: 
   39: def _levels_to_axis(
   40:     ss,
   41:     levels: tuple[int] | list[int],
   42:     valid_ilocs: npt.NDArray[np.intp],
   43:     sort_labels: bool = False,
   44: ) -> tuple[npt.NDArray[np.intp], list[IndexLabel]]:
   45:     """
   46:     For a MultiIndexed sparse Series `ss`, return `ax_coords` and `ax_labels`,
   47:     where `ax_coords` are the coordinates along one of the two axes of the
   48:     destination sparse matrix, and `ax_labels` are the labels from `ss`' Index
   49:     which correspond to these coordinates.
   50: 
   51:     Parameters
   52:     ----------
   53:     ss : Series
   54:     levels : tuple/list
   55:     valid_ilocs : numpy.ndarray
   56:         Array of integer positions of valid values for the sparse matrix in ss.
   57:     sort_labels : bool, default False
   58:         Sort the axis labels before forming the sparse matrix. When `levels`
   59:         refers to a single level, set to True for a faster execution.
   60: 
   61:     Returns
   62:     -------
   63:     ax_coords : numpy.ndarray (axis coordinates)
   64:     ax_labels : list (axis labels)
   65:     """
   66:     # Since the labels are sorted in `Index.levels`, when we wish to sort and
   67:     # there is only one level of the MultiIndex for this axis, the desired
   68:     # output can be obtained in the following simpler, more efficient way.
   69:     if sort_labels and len(levels) == 1:
   70:         ax_coords = ss.index.codes[levels[0]][valid_ilocs]
   71:         ax_labels = ss.index.levels[levels[0]]
   72: 
   73:     else:
   74:         levels_values = lib.fast_zip(
   75:             [ss.index.get_level_values(lvl).to_numpy() for lvl in levels]
   76:         )
   77:         codes, ax_labels = factorize(levels_values, sort=sort_labels)
   78:         ax_coords = codes[valid_ilocs]
   79: 
   80:     ax_labels = ax_labels.tolist()
   81:     return ax_coords, ax_labels
   82: 
   83: 
   84: def _to_ijv(
   85:     ss,
   86:     row_levels: tuple[int] | list[int] = (0,),
   87:     column_levels: tuple[int] | list[int] = (1,),
   88:     sort_labels: bool = False,
   89: ) -> tuple[
   90:     np.ndarray,
   91:     npt.NDArray[np.intp],
   92:     npt.NDArray[np.intp],
   93:     list[IndexLabel],
   94:     list[IndexLabel],
   95: ]:
   96:     """
   97:     For an arbitrary MultiIndexed sparse Series return (v, i, j, ilabels,
   98:     jlabels) where (v, (i, j)) is suitable for passing to scipy.sparse.coo
   99:     constructor, and ilabels and jlabels are the row and column labels
  100:     respectively.
  101: 
  102:     Parameters
  103:     ----------
  104:     ss : Series
  105:     row_levels : tuple/list
  106:     column_levels : tuple/list
  107:     sort_labels : bool, default False
  108:         Sort the row and column labels before forming the sparse matrix.
  109:         When `row_levels` and/or `column_levels` refer to a single level,
  110:         set to `True` for a faster execution.
  111: 
  112:     Returns
  113:     -------
  114:     values : numpy.ndarray
  115:         Valid values to populate a sparse matrix, extracted from
  116:         ss.
  117:     i_coords : numpy.ndarray (row coordinates of the values)
  118:     j_coords : numpy.ndarray (column coordinates of the values)
  119:     i_labels : list (row labels)
  120:     j_labels : list (column labels)
  121:     """
  122:     # index and column levels must be a partition of the index
  123:     _check_is_partition([row_levels, column_levels], range(ss.index.nlevels))
  124:     # From the sparse Series, get the integer indices and data for valid sparse
  125:     # entries.
  126:     sp_vals = ss.array.sp_values
  127:     na_mask = notna(sp_vals)
  128:     values = sp_vals[na_mask]
  129:     valid_ilocs = ss.array.sp_index.indices[na_mask]
  130: 
  131:     i_coords, i_labels = _levels_to_axis(
  132:         ss, row_levels, valid_ilocs, sort_labels=sort_labels
  133:     )
  134: 
  135:     j_coords, j_labels = _levels_to_axis(
  136:         ss, column_levels, valid_ilocs, sort_labels=sort_labels
  137:     )
  138: 
  139:     return values, i_coords, j_coords, i_labels, j_labels
  140: 
  141: 
  142: def sparse_series_to_coo(
  143:     ss: Series,
  144:     row_levels: Iterable[int] = (0,),
  145:     column_levels: Iterable[int] = (1,),
  146:     sort_labels: bool = False,
  147: ) -> tuple[scipy.sparse.coo_matrix, list[IndexLabel], list[IndexLabel]]:
  148:     """
  149:     Convert a sparse Series to a scipy.sparse.coo_matrix using index
  150:     levels row_levels, column_levels as the row and column
  151:     labels respectively. Returns the sparse_matrix, row and column labels.
  152:     """
  153:     import scipy.sparse
  154: 
  155:     if ss.index.nlevels < 2:
  156:         raise ValueError("to_coo requires MultiIndex with nlevels >= 2.")
  157:     if not ss.index.is_unique:
  158:         raise ValueError(
  159:             "Duplicate index entries are not allowed in to_coo transformation."
  160:         )
  161: 
  162:     # to keep things simple, only rely on integer indexing (not labels)
  163:     row_levels = [ss.index._get_level_number(x) for x in row_levels]
  164:     column_levels = [ss.index._get_level_number(x) for x in column_levels]
  165: 
  166:     v, i, j, rows, columns = _to_ijv(
  167:         ss, row_levels=row_levels, column_levels=column_levels, sort_labels=sort_labels
  168:     )
  169:     sparse_matrix = scipy.sparse.coo_matrix(
  170:         (v, (i, j)), shape=(len(rows), len(columns))
  171:     )
  172:     return sparse_matrix, rows, columns
  173: 
  174: 
  175: def coo_to_sparse_series(
  176:     A: scipy.sparse.coo_matrix, dense_index: bool = False
  177: ) -> Series:
  178:     """
  179:     Convert a scipy.sparse.coo_matrix to a Series with type sparse.
  180: 
  181:     Parameters
  182:     ----------
  183:     A : scipy.sparse.coo_matrix
  184:     dense_index : bool, default False
  185: 
  186:     Returns
  187:     -------
  188:     Series
  189: 
  190:     Raises
  191:     ------
  192:     TypeError if A is not a coo_matrix
  193:     """
  194:     from pandas import SparseDtype
  195: 
  196:     try:
  197:         ser = Series(A.data, MultiIndex.from_arrays((A.row, A.col)), copy=False)
  198:     except AttributeError as err:
  199:         raise TypeError(
  200:             f"Expected coo_matrix. Got {type(A).__name__} instead."
  201:         ) from err
  202:     ser = ser.sort_index()
  203:     ser = ser.astype(SparseDtype(ser.dtype))
  204:     if dense_index:
  205:         ind = MultiIndex.from_product([A.row, A.col])
  206:         ser = ser.reindex(ind)
  207:     return ser
