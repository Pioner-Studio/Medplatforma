    1: from __future__ import annotations
    2: 
    3: from functools import partial
    4: import operator
    5: import re
    6: from typing import (
    7:     TYPE_CHECKING,
    8:     Callable,
    9:     Union,
   10: )
   11: import warnings
   12: 
   13: import numpy as np
   14: 
   15: from pandas._libs import (
   16:     lib,
   17:     missing as libmissing,
   18: )
   19: from pandas.compat import (
   20:     pa_version_under10p1,
   21:     pa_version_under13p0,
   22: )
   23: from pandas.util._exceptions import find_stack_level
   24: 
   25: from pandas.core.dtypes.common import (
   26:     is_bool_dtype,
   27:     is_integer_dtype,
   28:     is_object_dtype,
   29:     is_scalar,
   30:     is_string_dtype,
   31:     pandas_dtype,
   32: )
   33: from pandas.core.dtypes.missing import isna
   34: 
   35: from pandas.core.arrays._arrow_string_mixins import ArrowStringArrayMixin
   36: from pandas.core.arrays.arrow import ArrowExtensionArray
   37: from pandas.core.arrays.boolean import BooleanDtype
   38: from pandas.core.arrays.integer import Int64Dtype
   39: from pandas.core.arrays.numeric import NumericDtype
   40: from pandas.core.arrays.string_ import (
   41:     BaseStringArray,
   42:     StringDtype,
   43: )
   44: from pandas.core.ops import invalid_comparison
   45: from pandas.core.strings.object_array import ObjectStringArrayMixin
   46: 
   47: if not pa_version_under10p1:
   48:     import pyarrow as pa
   49:     import pyarrow.compute as pc
   50: 
   51:     from pandas.core.arrays.arrow._arrow_utils import fallback_performancewarning
   52: 
   53: 
   54: if TYPE_CHECKING:
   55:     from collections.abc import Sequence
   56: 
   57:     from pandas._typing import (
   58:         ArrayLike,
   59:         AxisInt,
   60:         Dtype,
   61:         Scalar,
   62:         npt,
   63:     )
   64: 
   65:     from pandas import Series
   66: 
   67: 
   68: ArrowStringScalarOrNAT = Union[str, libmissing.NAType]
   69: 
   70: 
   71: def _chk_pyarrow_available() -> None:
   72:     if pa_version_under10p1:
   73:         msg = "pyarrow>=10.0.1 is required for PyArrow backed ArrowExtensionArray."
   74:         raise ImportError(msg)
   75: 
   76: 
   77: # TODO: Inherit directly from BaseStringArrayMethods. Currently we inherit from
   78: # ObjectStringArrayMixin because we want to have the object-dtype based methods as
   79: # fallback for the ones that pyarrow doesn't yet support
   80: 
   81: 
   82: class ArrowStringArray(ObjectStringArrayMixin, ArrowExtensionArray, BaseStringArray):
   83:     """
   84:     Extension array for string data in a ``pyarrow.ChunkedArray``.
   85: 
   86:     .. warning::
   87: 
   88:        ArrowStringArray is considered experimental. The implementation and
   89:        parts of the API may change without warning.
   90: 
   91:     Parameters
   92:     ----------
   93:     values : pyarrow.Array or pyarrow.ChunkedArray
   94:         The array of data.
   95: 
   96:     Attributes
   97:     ----------
   98:     None
   99: 
  100:     Methods
  101:     -------
  102:     None
  103: 
  104:     See Also
  105:     --------
  106:     :func:`pandas.array`
  107:         The recommended function for creating a ArrowStringArray.
  108:     Series.str
  109:         The string methods are available on Series backed by
  110:         a ArrowStringArray.
  111: 
  112:     Notes
  113:     -----
  114:     ArrowStringArray returns a BooleanArray for comparison methods.
  115: 
  116:     Examples
  117:     --------
  118:     >>> pd.array(['This is', 'some text', None, 'data.'], dtype="string[pyarrow]")
  119:     <ArrowStringArray>
  120:     ['This is', 'some text', <NA>, 'data.']
  121:     Length: 4, dtype: string
  122:     """
  123: 
  124:     # error: Incompatible types in assignment (expression has type "StringDtype",
  125:     # base class "ArrowExtensionArray" defined the type as "ArrowDtype")
  126:     _dtype: StringDtype  # type: ignore[assignment]
  127:     _storage = "pyarrow"
  128: 
  129:     def __init__(self, values) -> None:
  130:         _chk_pyarrow_available()
  131:         if isinstance(values, (pa.Array, pa.ChunkedArray)) and pa.types.is_string(
  132:             values.type
  133:         ):
  134:             values = pc.cast(values, pa.large_string())
  135: 
  136:         super().__init__(values)
  137:         self._dtype = StringDtype(storage=self._storage)
  138: 
  139:         if not pa.types.is_large_string(self._pa_array.type) and not (
  140:             pa.types.is_dictionary(self._pa_array.type)
  141:             and pa.types.is_large_string(self._pa_array.type.value_type)
  142:         ):
  143:             raise ValueError(
  144:                 "ArrowStringArray requires a PyArrow (chunked) array of "
  145:                 "large_string type"
  146:             )
  147: 
  148:     @classmethod
  149:     def _box_pa_scalar(cls, value, pa_type: pa.DataType | None = None) -> pa.Scalar:
  150:         pa_scalar = super()._box_pa_scalar(value, pa_type)
  151:         if pa.types.is_string(pa_scalar.type) and pa_type is None:
  152:             pa_scalar = pc.cast(pa_scalar, pa.large_string())
  153:         return pa_scalar
  154: 
  155:     @classmethod
  156:     def _box_pa_array(
  157:         cls, value, pa_type: pa.DataType | None = None, copy: bool = False
  158:     ) -> pa.Array | pa.ChunkedArray:
  159:         pa_array = super()._box_pa_array(value, pa_type)
  160:         if pa.types.is_string(pa_array.type) and pa_type is None:
  161:             pa_array = pc.cast(pa_array, pa.large_string())
  162:         return pa_array
  163: 
  164:     def __len__(self) -> int:
  165:         """
  166:         Length of this array.
  167: 
  168:         Returns
  169:         -------
  170:         length : int
  171:         """
  172:         return len(self._pa_array)
  173: 
  174:     @classmethod
  175:     def _from_sequence(cls, scalars, *, dtype: Dtype | None = None, copy: bool = False):
  176:         from pandas.core.arrays.masked import BaseMaskedArray
  177: 
  178:         _chk_pyarrow_available()
  179: 
  180:         if dtype and not (isinstance(dtype, str) and dtype == "string"):
  181:             dtype = pandas_dtype(dtype)
  182:             assert isinstance(dtype, StringDtype) and dtype.storage in (
  183:                 "pyarrow",
  184:                 "pyarrow_numpy",
  185:             )
  186: 
  187:         if isinstance(scalars, BaseMaskedArray):
  188:             # avoid costly conversion to object dtype in ensure_string_array and
  189:             # numerical issues with Float32Dtype
  190:             na_values = scalars._mask
  191:             result = scalars._data
  192:             result = lib.ensure_string_array(result, copy=copy, convert_na_value=False)
  193:             return cls(pa.array(result, mask=na_values, type=pa.string()))
  194:         elif isinstance(scalars, (pa.Array, pa.ChunkedArray)):
  195:             return cls(pc.cast(scalars, pa.string()))
  196: 
  197:         # convert non-na-likes to str
  198:         result = lib.ensure_string_array(scalars, copy=copy)
  199:         return cls(pa.array(result, type=pa.string(), from_pandas=True))
  200: 
  201:     @classmethod
  202:     def _from_sequence_of_strings(
  203:         cls, strings, dtype: Dtype | None = None, copy: bool = False
  204:     ):
  205:         return cls._from_sequence(strings, dtype=dtype, copy=copy)
  206: 
  207:     @property
  208:     def dtype(self) -> StringDtype:  # type: ignore[override]
  209:         """
  210:         An instance of 'string[pyarrow]'.
  211:         """
  212:         return self._dtype
  213: 
  214:     def insert(self, loc: int, item) -> ArrowStringArray:
  215:         if not isinstance(item, str) and item is not libmissing.NA:
  216:             raise TypeError("Scalar must be NA or str")
  217:         return super().insert(loc, item)
  218: 
  219:     @classmethod
  220:     def _result_converter(cls, values, na=None):
  221:         return BooleanDtype().__from_arrow__(values)
  222: 
  223:     def _maybe_convert_setitem_value(self, value):
  224:         """Maybe convert value to be pyarrow compatible."""
  225:         if is_scalar(value):
  226:             if isna(value):
  227:                 value = None
  228:             elif not isinstance(value, str):
  229:                 raise TypeError("Scalar must be NA or str")
  230:         else:
  231:             value = np.array(value, dtype=object, copy=True)
  232:             value[isna(value)] = None
  233:             for v in value:
  234:                 if not (v is None or isinstance(v, str)):
  235:                     raise TypeError("Scalar must be NA or str")
  236:         return super()._maybe_convert_setitem_value(value)
  237: 
  238:     def isin(self, values: ArrayLike) -> npt.NDArray[np.bool_]:
  239:         value_set = [
  240:             pa_scalar.as_py()
  241:             for pa_scalar in [pa.scalar(value, from_pandas=True) for value in values]
  242:             if pa_scalar.type in (pa.string(), pa.null())
  243:         ]
  244: 
  245:         # short-circuit to return all False array.
  246:         if not len(value_set):
  247:             return np.zeros(len(self), dtype=bool)
  248: 
  249:         result = pc.is_in(
  250:             self._pa_array, value_set=pa.array(value_set, type=self._pa_array.type)
  251:         )
  252:         # pyarrow 2.0.0 returned nulls, so we explicily specify dtype to convert nulls
  253:         # to False
  254:         return np.array(result, dtype=np.bool_)
  255: 
  256:     def astype(self, dtype, copy: bool = True):
  257:         dtype = pandas_dtype(dtype)
  258: 
  259:         if dtype == self.dtype:
  260:             if copy:
  261:                 return self.copy()
  262:             return self
  263:         elif isinstance(dtype, NumericDtype):
  264:             data = self._pa_array.cast(pa.from_numpy_dtype(dtype.numpy_dtype))
  265:             return dtype.__from_arrow__(data)
  266:         elif isinstance(dtype, np.dtype) and np.issubdtype(dtype, np.floating):
  267:             return self.to_numpy(dtype=dtype, na_value=np.nan)
  268: 
  269:         return super().astype(dtype, copy=copy)
  270: 
  271:     @property
  272:     def _data(self):
  273:         # dask accesses ._data directlys
  274:         warnings.warn(
  275:             f"{type(self).__name__}._data is a deprecated and will be removed "
  276:             "in a future version, use ._pa_array instead",
  277:             FutureWarning,
  278:             stacklevel=find_stack_level(),
  279:         )
  280:         return self._pa_array
  281: 
  282:     # ------------------------------------------------------------------------
  283:     # String methods interface
  284: 
  285:     # error: Incompatible types in assignment (expression has type "NAType",
  286:     # base class "ObjectStringArrayMixin" defined the type as "float")
  287:     _str_na_value = libmissing.NA  # type: ignore[assignment]
  288: 
  289:     def _str_map(
  290:         self, f, na_value=None, dtype: Dtype | None = None, convert: bool = True
  291:     ):
  292:         # TODO: de-duplicate with StringArray method. This method is moreless copy and
  293:         # paste.
  294: 
  295:         from pandas.arrays import (
  296:             BooleanArray,
  297:             IntegerArray,
  298:         )
  299: 
  300:         if dtype is None:
  301:             dtype = self.dtype
  302:         if na_value is None:
  303:             na_value = self.dtype.na_value
  304: 
  305:         mask = isna(self)
  306:         arr = np.asarray(self)
  307: 
  308:         if is_integer_dtype(dtype) or is_bool_dtype(dtype):
  309:             constructor: type[IntegerArray | BooleanArray]
  310:             if is_integer_dtype(dtype):
  311:                 constructor = IntegerArray
  312:             else:
  313:                 constructor = BooleanArray
  314: 
  315:             na_value_is_na = isna(na_value)
  316:             if na_value_is_na:
  317:                 na_value = 1
  318:             result = lib.map_infer_mask(
  319:                 arr,
  320:                 f,
  321:                 mask.view("uint8"),
  322:                 convert=False,
  323:                 na_value=na_value,
  324:                 # error: Argument 1 to "dtype" has incompatible type
  325:                 # "Union[ExtensionDtype, str, dtype[Any], Type[object]]"; expected
  326:                 # "Type[object]"
  327:                 dtype=np.dtype(dtype),  # type: ignore[arg-type]
  328:             )
  329: 
  330:             if not na_value_is_na:
  331:                 mask[:] = False
  332: 
  333:             return constructor(result, mask)
  334: 
  335:         elif is_string_dtype(dtype) and not is_object_dtype(dtype):
  336:             # i.e. StringDtype
  337:             result = lib.map_infer_mask(
  338:                 arr, f, mask.view("uint8"), convert=False, na_value=na_value
  339:             )
  340:             result = pa.array(result, mask=mask, type=pa.string(), from_pandas=True)
  341:             return type(self)(result)
  342:         else:
  343:             # This is when the result type is object. We reach this when
  344:             # -> We know the result type is truly object (e.g. .encode returns bytes
  345:             #    or .findall returns a list).
  346:             # -> We don't know the result type. E.g. `.get` can return anything.
  347:             return lib.map_infer_mask(arr, f, mask.view("uint8"))
  348: 
  349:     def _str_contains(
  350:         self, pat, case: bool = True, flags: int = 0, na=np.nan, regex: bool = True
  351:     ):
  352:         if flags:
  353:             fallback_performancewarning()
  354:             return super()._str_contains(pat, case, flags, na, regex)
  355: 
  356:         if regex:
  357:             result = pc.match_substring_regex(self._pa_array, pat, ignore_case=not case)
  358:         else:
  359:             result = pc.match_substring(self._pa_array, pat, ignore_case=not case)
  360:         result = self._result_converter(result, na=na)
  361:         if not isna(na):
  362:             result[isna(result)] = bool(na)
  363:         return result
  364: 
  365:     def _str_startswith(self, pat: str | tuple[str, ...], na: Scalar | None = None):
  366:         if isinstance(pat, str):
  367:             result = pc.starts_with(self._pa_array, pattern=pat)
  368:         else:
  369:             if len(pat) == 0:
  370:                 # mimic existing behaviour of string extension array
  371:                 # and python string method
  372:                 result = pa.array(
  373:                     np.zeros(len(self._pa_array), dtype=bool), mask=isna(self._pa_array)
  374:                 )
  375:             else:
  376:                 result = pc.starts_with(self._pa_array, pattern=pat[0])
  377: 
  378:                 for p in pat[1:]:
  379:                     result = pc.or_(result, pc.starts_with(self._pa_array, pattern=p))
  380:         if not isna(na):
  381:             result = result.fill_null(na)
  382:         return self._result_converter(result)
  383: 
  384:     def _str_endswith(self, pat: str | tuple[str, ...], na: Scalar | None = None):
  385:         if isinstance(pat, str):
  386:             result = pc.ends_with(self._pa_array, pattern=pat)
  387:         else:
  388:             if len(pat) == 0:
  389:                 # mimic existing behaviour of string extension array
  390:                 # and python string method
  391:                 result = pa.array(
  392:                     np.zeros(len(self._pa_array), dtype=bool), mask=isna(self._pa_array)
  393:                 )
  394:             else:
  395:                 result = pc.ends_with(self._pa_array, pattern=pat[0])
  396: 
  397:                 for p in pat[1:]:
  398:                     result = pc.or_(result, pc.ends_with(self._pa_array, pattern=p))
  399:         if not isna(na):
  400:             result = result.fill_null(na)
  401:         return self._result_converter(result)
  402: 
  403:     def _str_replace(
  404:         self,
  405:         pat: str | re.Pattern,
  406:         repl: str | Callable,
  407:         n: int = -1,
  408:         case: bool = True,
  409:         flags: int = 0,
  410:         regex: bool = True,
  411:     ):
  412:         if isinstance(pat, re.Pattern) or callable(repl) or not case or flags:
  413:             fallback_performancewarning()
  414:             return super()._str_replace(pat, repl, n, case, flags, regex)
  415: 
  416:         func = pc.replace_substring_regex if regex else pc.replace_substring
  417:         result = func(self._pa_array, pattern=pat, replacement=repl, max_replacements=n)
  418:         return type(self)(result)
  419: 
  420:     def _str_repeat(self, repeats: int | Sequence[int]):
  421:         if not isinstance(repeats, int):
  422:             return super()._str_repeat(repeats)
  423:         else:
  424:             return type(self)(pc.binary_repeat(self._pa_array, repeats))
  425: 
  426:     def _str_match(
  427:         self, pat: str, case: bool = True, flags: int = 0, na: Scalar | None = None
  428:     ):
  429:         if not pat.startswith("^"):
  430:             pat = f"^{pat}"
  431:         return self._str_contains(pat, case, flags, na, regex=True)
  432: 
  433:     def _str_fullmatch(
  434:         self, pat, case: bool = True, flags: int = 0, na: Scalar | None = None
  435:     ):
  436:         if not pat.endswith("$") or pat.endswith("\\$"):
  437:             pat = f"{pat}$"
  438:         return self._str_match(pat, case, flags, na)
  439: 
  440:     def _str_slice(
  441:         self, start: int | None = None, stop: int | None = None, step: int | None = None
  442:     ):
  443:         if stop is None:
  444:             return super()._str_slice(start, stop, step)
  445:         if start is None:
  446:             start = 0
  447:         if step is None:
  448:             step = 1
  449:         return type(self)(
  450:             pc.utf8_slice_codeunits(self._pa_array, start=start, stop=stop, step=step)
  451:         )
  452: 
  453:     def _str_isalnum(self):
  454:         result = pc.utf8_is_alnum(self._pa_array)
  455:         return self._result_converter(result)
  456: 
  457:     def _str_isalpha(self):
  458:         result = pc.utf8_is_alpha(self._pa_array)
  459:         return self._result_converter(result)
  460: 
  461:     def _str_isdecimal(self):
  462:         result = pc.utf8_is_decimal(self._pa_array)
  463:         return self._result_converter(result)
  464: 
  465:     def _str_isdigit(self):
  466:         result = pc.utf8_is_digit(self._pa_array)
  467:         return self._result_converter(result)
  468: 
  469:     def _str_islower(self):
  470:         result = pc.utf8_is_lower(self._pa_array)
  471:         return self._result_converter(result)
  472: 
  473:     def _str_isnumeric(self):
  474:         result = pc.utf8_is_numeric(self._pa_array)
  475:         return self._result_converter(result)
  476: 
  477:     def _str_isspace(self):
  478:         result = pc.utf8_is_space(self._pa_array)
  479:         return self._result_converter(result)
  480: 
  481:     def _str_istitle(self):
  482:         result = pc.utf8_is_title(self._pa_array)
  483:         return self._result_converter(result)
  484: 
  485:     def _str_isupper(self):
  486:         result = pc.utf8_is_upper(self._pa_array)
  487:         return self._result_converter(result)
  488: 
  489:     def _str_len(self):
  490:         result = pc.utf8_length(self._pa_array)
  491:         return self._convert_int_dtype(result)
  492: 
  493:     def _str_lower(self):
  494:         return type(self)(pc.utf8_lower(self._pa_array))
  495: 
  496:     def _str_upper(self):
  497:         return type(self)(pc.utf8_upper(self._pa_array))
  498: 
  499:     def _str_strip(self, to_strip=None):
  500:         if to_strip is None:
  501:             result = pc.utf8_trim_whitespace(self._pa_array)
  502:         else:
  503:             result = pc.utf8_trim(self._pa_array, characters=to_strip)
  504:         return type(self)(result)
  505: 
  506:     def _str_lstrip(self, to_strip=None):
  507:         if to_strip is None:
  508:             result = pc.utf8_ltrim_whitespace(self._pa_array)
  509:         else:
  510:             result = pc.utf8_ltrim(self._pa_array, characters=to_strip)
  511:         return type(self)(result)
  512: 
  513:     def _str_rstrip(self, to_strip=None):
  514:         if to_strip is None:
  515:             result = pc.utf8_rtrim_whitespace(self._pa_array)
  516:         else:
  517:             result = pc.utf8_rtrim(self._pa_array, characters=to_strip)
  518:         return type(self)(result)
  519: 
  520:     def _str_removeprefix(self, prefix: str):
  521:         if not pa_version_under13p0:
  522:             starts_with = pc.starts_with(self._pa_array, pattern=prefix)
  523:             removed = pc.utf8_slice_codeunits(self._pa_array, len(prefix))
  524:             result = pc.if_else(starts_with, removed, self._pa_array)
  525:             return type(self)(result)
  526:         return super()._str_removeprefix(prefix)
  527: 
  528:     def _str_removesuffix(self, suffix: str):
  529:         ends_with = pc.ends_with(self._pa_array, pattern=suffix)
  530:         removed = pc.utf8_slice_codeunits(self._pa_array, 0, stop=-len(suffix))
  531:         result = pc.if_else(ends_with, removed, self._pa_array)
  532:         return type(self)(result)
  533: 
  534:     def _str_count(self, pat: str, flags: int = 0):
  535:         if flags:
  536:             return super()._str_count(pat, flags)
  537:         result = pc.count_substring_regex(self._pa_array, pat)
  538:         return self._convert_int_dtype(result)
  539: 
  540:     def _str_find(self, sub: str, start: int = 0, end: int | None = None):
  541:         if start != 0 and end is not None:
  542:             slices = pc.utf8_slice_codeunits(self._pa_array, start, stop=end)
  543:             result = pc.find_substring(slices, sub)
  544:             not_found = pc.equal(result, -1)
  545:             offset_result = pc.add(result, end - start)
  546:             result = pc.if_else(not_found, result, offset_result)
  547:         elif start == 0 and end is None:
  548:             slices = self._pa_array
  549:             result = pc.find_substring(slices, sub)
  550:         else:
  551:             return super()._str_find(sub, start, end)
  552:         return self._convert_int_dtype(result)
  553: 
  554:     def _str_get_dummies(self, sep: str = "|"):
  555:         dummies_pa, labels = ArrowExtensionArray(self._pa_array)._str_get_dummies(sep)
  556:         if len(labels) == 0:
  557:             return np.empty(shape=(0, 0), dtype=np.int64), labels
  558:         dummies = np.vstack(dummies_pa.to_numpy())
  559:         return dummies.astype(np.int64, copy=False), labels
  560: 
  561:     def _convert_int_dtype(self, result):
  562:         return Int64Dtype().__from_arrow__(result)
  563: 
  564:     def _reduce(
  565:         self, name: str, *, skipna: bool = True, keepdims: bool = False, **kwargs
  566:     ):
  567:         result = self._reduce_calc(name, skipna=skipna, keepdims=keepdims, **kwargs)
  568:         if name in ("argmin", "argmax") and isinstance(result, pa.Array):
  569:             return self._convert_int_dtype(result)
  570:         elif isinstance(result, pa.Array):
  571:             return type(self)(result)
  572:         else:
  573:             return result
  574: 
  575:     def _rank(
  576:         self,
  577:         *,
  578:         axis: AxisInt = 0,
  579:         method: str = "average",
  580:         na_option: str = "keep",
  581:         ascending: bool = True,
  582:         pct: bool = False,
  583:     ):
  584:         """
  585:         See Series.rank.__doc__.
  586:         """
  587:         return self._convert_int_dtype(
  588:             self._rank_calc(
  589:                 axis=axis,
  590:                 method=method,
  591:                 na_option=na_option,
  592:                 ascending=ascending,
  593:                 pct=pct,
  594:             )
  595:         )
  596: 
  597: 
  598: class ArrowStringArrayNumpySemantics(ArrowStringArray):
  599:     _storage = "pyarrow_numpy"
  600: 
  601:     @classmethod
  602:     def _result_converter(cls, values, na=None):
  603:         if not isna(na):
  604:             values = values.fill_null(bool(na))
  605:         return ArrowExtensionArray(values).to_numpy(na_value=np.nan)
  606: 
  607:     def __getattribute__(self, item):
  608:         # ArrowStringArray and we both inherit from ArrowExtensionArray, which
  609:         # creates inheritance problems (Diamond inheritance)
  610:         if item in ArrowStringArrayMixin.__dict__ and item not in (
  611:             "_pa_array",
  612:             "__dict__",
  613:         ):
  614:             return partial(getattr(ArrowStringArrayMixin, item), self)
  615:         return super().__getattribute__(item)
  616: 
  617:     def _str_map(
  618:         self, f, na_value=None, dtype: Dtype | None = None, convert: bool = True
  619:     ):
  620:         if dtype is None:
  621:             dtype = self.dtype
  622:         if na_value is None:
  623:             na_value = self.dtype.na_value
  624: 
  625:         mask = isna(self)
  626:         arr = np.asarray(self)
  627: 
  628:         if is_integer_dtype(dtype) or is_bool_dtype(dtype):
  629:             if is_integer_dtype(dtype):
  630:                 na_value = np.nan
  631:             else:
  632:                 na_value = False
  633:             try:
  634:                 result = lib.map_infer_mask(
  635:                     arr,
  636:                     f,
  637:                     mask.view("uint8"),
  638:                     convert=False,
  639:                     na_value=na_value,
  640:                     dtype=np.dtype(dtype),  # type: ignore[arg-type]
  641:                 )
  642:                 return result
  643: 
  644:             except ValueError:
  645:                 result = lib.map_infer_mask(
  646:                     arr,
  647:                     f,
  648:                     mask.view("uint8"),
  649:                     convert=False,
  650:                     na_value=na_value,
  651:                 )
  652:                 if convert and result.dtype == object:
  653:                     result = lib.maybe_convert_objects(result)
  654:                 return result
  655: 
  656:         elif is_string_dtype(dtype) and not is_object_dtype(dtype):
  657:             # i.e. StringDtype
  658:             result = lib.map_infer_mask(
  659:                 arr, f, mask.view("uint8"), convert=False, na_value=na_value
  660:             )
  661:             result = pa.array(result, mask=mask, type=pa.string(), from_pandas=True)
  662:             return type(self)(result)
  663:         else:
  664:             # This is when the result type is object. We reach this when
  665:             # -> We know the result type is truly object (e.g. .encode returns bytes
  666:             #    or .findall returns a list).
  667:             # -> We don't know the result type. E.g. `.get` can return anything.
  668:             return lib.map_infer_mask(arr, f, mask.view("uint8"))
  669: 
  670:     def _convert_int_dtype(self, result):
  671:         if isinstance(result, pa.Array):
  672:             result = result.to_numpy(zero_copy_only=False)
  673:         else:
  674:             result = result.to_numpy()
  675:         if result.dtype == np.int32:
  676:             result = result.astype(np.int64)
  677:         return result
  678: 
  679:     def _cmp_method(self, other, op):
  680:         try:
  681:             result = super()._cmp_method(other, op)
  682:         except pa.ArrowNotImplementedError:
  683:             return invalid_comparison(self, other, op)
  684:         if op == operator.ne:
  685:             return result.to_numpy(np.bool_, na_value=True)
  686:         else:
  687:             return result.to_numpy(np.bool_, na_value=False)
  688: 
  689:     def value_counts(self, dropna: bool = True) -> Series:
  690:         from pandas import Series
  691: 
  692:         result = super().value_counts(dropna)
  693:         return Series(
  694:             result._values.to_numpy(), index=result.index, name=result.name, copy=False
  695:         )
  696: 
  697:     def _reduce(
  698:         self, name: str, *, skipna: bool = True, keepdims: bool = False, **kwargs
  699:     ):
  700:         if name in ["any", "all"]:
  701:             if not skipna and name == "all":
  702:                 nas = pc.invert(pc.is_null(self._pa_array))
  703:                 arr = pc.and_kleene(nas, pc.not_equal(self._pa_array, ""))
  704:             else:
  705:                 arr = pc.not_equal(self._pa_array, "")
  706:             return ArrowExtensionArray(arr)._reduce(
  707:                 name, skipna=skipna, keepdims=keepdims, **kwargs
  708:             )
  709:         else:
  710:             return super()._reduce(name, skipna=skipna, keepdims=keepdims, **kwargs)
  711: 
  712:     def insert(self, loc: int, item) -> ArrowStringArrayNumpySemantics:
  713:         if item is np.nan:
  714:             item = libmissing.NA
  715:         return super().insert(loc, item)  # type: ignore[return-value]
