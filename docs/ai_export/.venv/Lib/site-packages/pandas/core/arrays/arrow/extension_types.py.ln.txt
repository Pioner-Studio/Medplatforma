    1: from __future__ import annotations
    2: 
    3: import json
    4: from typing import TYPE_CHECKING
    5: 
    6: import pyarrow
    7: 
    8: from pandas.compat import pa_version_under14p1
    9: 
   10: from pandas.core.dtypes.dtypes import (
   11:     IntervalDtype,
   12:     PeriodDtype,
   13: )
   14: 
   15: from pandas.core.arrays.interval import VALID_CLOSED
   16: 
   17: if TYPE_CHECKING:
   18:     from pandas._typing import IntervalClosedType
   19: 
   20: 
   21: class ArrowPeriodType(pyarrow.ExtensionType):
   22:     def __init__(self, freq) -> None:
   23:         # attributes need to be set first before calling
   24:         # super init (as that calls serialize)
   25:         self._freq = freq
   26:         pyarrow.ExtensionType.__init__(self, pyarrow.int64(), "pandas.period")
   27: 
   28:     @property
   29:     def freq(self):
   30:         return self._freq
   31: 
   32:     def __arrow_ext_serialize__(self) -> bytes:
   33:         metadata = {"freq": self.freq}
   34:         return json.dumps(metadata).encode()
   35: 
   36:     @classmethod
   37:     def __arrow_ext_deserialize__(cls, storage_type, serialized) -> ArrowPeriodType:
   38:         metadata = json.loads(serialized.decode())
   39:         return ArrowPeriodType(metadata["freq"])
   40: 
   41:     def __eq__(self, other):
   42:         if isinstance(other, pyarrow.BaseExtensionType):
   43:             return type(self) == type(other) and self.freq == other.freq
   44:         else:
   45:             return NotImplemented
   46: 
   47:     def __ne__(self, other) -> bool:
   48:         return not self == other
   49: 
   50:     def __hash__(self) -> int:
   51:         return hash((str(self), self.freq))
   52: 
   53:     def to_pandas_dtype(self) -> PeriodDtype:
   54:         return PeriodDtype(freq=self.freq)
   55: 
   56: 
   57: # register the type with a dummy instance
   58: _period_type = ArrowPeriodType("D")
   59: pyarrow.register_extension_type(_period_type)
   60: 
   61: 
   62: class ArrowIntervalType(pyarrow.ExtensionType):
   63:     def __init__(self, subtype, closed: IntervalClosedType) -> None:
   64:         # attributes need to be set first before calling
   65:         # super init (as that calls serialize)
   66:         assert closed in VALID_CLOSED
   67:         self._closed: IntervalClosedType = closed
   68:         if not isinstance(subtype, pyarrow.DataType):
   69:             subtype = pyarrow.type_for_alias(str(subtype))
   70:         self._subtype = subtype
   71: 
   72:         storage_type = pyarrow.struct([("left", subtype), ("right", subtype)])
   73:         pyarrow.ExtensionType.__init__(self, storage_type, "pandas.interval")
   74: 
   75:     @property
   76:     def subtype(self):
   77:         return self._subtype
   78: 
   79:     @property
   80:     def closed(self) -> IntervalClosedType:
   81:         return self._closed
   82: 
   83:     def __arrow_ext_serialize__(self) -> bytes:
   84:         metadata = {"subtype": str(self.subtype), "closed": self.closed}
   85:         return json.dumps(metadata).encode()
   86: 
   87:     @classmethod
   88:     def __arrow_ext_deserialize__(cls, storage_type, serialized) -> ArrowIntervalType:
   89:         metadata = json.loads(serialized.decode())
   90:         subtype = pyarrow.type_for_alias(metadata["subtype"])
   91:         closed = metadata["closed"]
   92:         return ArrowIntervalType(subtype, closed)
   93: 
   94:     def __eq__(self, other):
   95:         if isinstance(other, pyarrow.BaseExtensionType):
   96:             return (
   97:                 type(self) == type(other)
   98:                 and self.subtype == other.subtype
   99:                 and self.closed == other.closed
  100:             )
  101:         else:
  102:             return NotImplemented
  103: 
  104:     def __ne__(self, other) -> bool:
  105:         return not self == other
  106: 
  107:     def __hash__(self) -> int:
  108:         return hash((str(self), str(self.subtype), self.closed))
  109: 
  110:     def to_pandas_dtype(self) -> IntervalDtype:
  111:         return IntervalDtype(self.subtype.to_pandas_dtype(), self.closed)
  112: 
  113: 
  114: # register the type with a dummy instance
  115: _interval_type = ArrowIntervalType(pyarrow.int64(), "left")
  116: pyarrow.register_extension_type(_interval_type)
  117: 
  118: 
  119: _ERROR_MSG = """\
  120: Disallowed deserialization of 'arrow.py_extension_type':
  121: storage_type = {storage_type}
  122: serialized = {serialized}
  123: pickle disassembly:\n{pickle_disassembly}
  124: 
  125: Reading of untrusted Parquet or Feather files with a PyExtensionType column
  126: allows arbitrary code execution.
  127: If you trust this file, you can enable reading the extension type by one of:
  128: 
  129: - upgrading to pyarrow >= 14.0.1, and call `pa.PyExtensionType.set_auto_load(True)`
  130: - install pyarrow-hotfix (`pip install pyarrow-hotfix`) and disable it by running
  131:   `import pyarrow_hotfix; pyarrow_hotfix.uninstall()`
  132: 
  133: We strongly recommend updating your Parquet/Feather files to use extension types
  134: derived from `pyarrow.ExtensionType` instead, and register this type explicitly.
  135: """
  136: 
  137: 
  138: def patch_pyarrow():
  139:     # starting from pyarrow 14.0.1, it has its own mechanism
  140:     if not pa_version_under14p1:
  141:         return
  142: 
  143:     # if https://github.com/pitrou/pyarrow-hotfix was installed and enabled
  144:     if getattr(pyarrow, "_hotfix_installed", False):
  145:         return
  146: 
  147:     class ForbiddenExtensionType(pyarrow.ExtensionType):
  148:         def __arrow_ext_serialize__(self):
  149:             return b""
  150: 
  151:         @classmethod
  152:         def __arrow_ext_deserialize__(cls, storage_type, serialized):
  153:             import io
  154:             import pickletools
  155: 
  156:             out = io.StringIO()
  157:             pickletools.dis(serialized, out)
  158:             raise RuntimeError(
  159:                 _ERROR_MSG.format(
  160:                     storage_type=storage_type,
  161:                     serialized=serialized,
  162:                     pickle_disassembly=out.getvalue(),
  163:                 )
  164:             )
  165: 
  166:     pyarrow.unregister_extension_type("arrow.py_extension_type")
  167:     pyarrow.register_extension_type(
  168:         ForbiddenExtensionType(pyarrow.null(), "arrow.py_extension_type")
  169:     )
  170: 
  171:     pyarrow._hotfix_installed = True
  172: 
  173: 
  174: patch_pyarrow()
