    1: """
    2: frozen (immutable) data structures to support MultiIndexing
    3: 
    4: These are used for:
    5: 
    6: - .names (FrozenList)
    7: 
    8: """
    9: from __future__ import annotations
   10: 
   11: from typing import (
   12:     TYPE_CHECKING,
   13:     NoReturn,
   14: )
   15: 
   16: from pandas.core.base import PandasObject
   17: 
   18: from pandas.io.formats.printing import pprint_thing
   19: 
   20: if TYPE_CHECKING:
   21:     from pandas._typing import Self
   22: 
   23: 
   24: class FrozenList(PandasObject, list):
   25:     """
   26:     Container that doesn't allow setting item *but*
   27:     because it's technically hashable, will be used
   28:     for lookups, appropriately, etc.
   29:     """
   30: 
   31:     # Side note: This has to be of type list. Otherwise,
   32:     #            it messes up PyTables type checks.
   33: 
   34:     def union(self, other) -> FrozenList:
   35:         """
   36:         Returns a FrozenList with other concatenated to the end of self.
   37: 
   38:         Parameters
   39:         ----------
   40:         other : array-like
   41:             The array-like whose elements we are concatenating.
   42: 
   43:         Returns
   44:         -------
   45:         FrozenList
   46:             The collection difference between self and other.
   47:         """
   48:         if isinstance(other, tuple):
   49:             other = list(other)
   50:         return type(self)(super().__add__(other))
   51: 
   52:     def difference(self, other) -> FrozenList:
   53:         """
   54:         Returns a FrozenList with elements from other removed from self.
   55: 
   56:         Parameters
   57:         ----------
   58:         other : array-like
   59:             The array-like whose elements we are removing self.
   60: 
   61:         Returns
   62:         -------
   63:         FrozenList
   64:             The collection difference between self and other.
   65:         """
   66:         other = set(other)
   67:         temp = [x for x in self if x not in other]
   68:         return type(self)(temp)
   69: 
   70:     # TODO: Consider deprecating these in favor of `union` (xref gh-15506)
   71:     # error: Incompatible types in assignment (expression has type
   72:     # "Callable[[FrozenList, Any], FrozenList]", base class "list" defined the
   73:     # type as overloaded function)
   74:     __add__ = __iadd__ = union  # type: ignore[assignment]
   75: 
   76:     def __getitem__(self, n):
   77:         if isinstance(n, slice):
   78:             return type(self)(super().__getitem__(n))
   79:         return super().__getitem__(n)
   80: 
   81:     def __radd__(self, other) -> Self:
   82:         if isinstance(other, tuple):
   83:             other = list(other)
   84:         return type(self)(other + list(self))
   85: 
   86:     def __eq__(self, other: object) -> bool:
   87:         if isinstance(other, (tuple, FrozenList)):
   88:             other = list(other)
   89:         return super().__eq__(other)
   90: 
   91:     __req__ = __eq__
   92: 
   93:     def __mul__(self, other) -> Self:
   94:         return type(self)(super().__mul__(other))
   95: 
   96:     __imul__ = __mul__
   97: 
   98:     def __reduce__(self):
   99:         return type(self), (list(self),)
  100: 
  101:     # error: Signature of "__hash__" incompatible with supertype "list"
  102:     def __hash__(self) -> int:  # type: ignore[override]
  103:         return hash(tuple(self))
  104: 
  105:     def _disabled(self, *args, **kwargs) -> NoReturn:
  106:         """
  107:         This method will not function because object is immutable.
  108:         """
  109:         raise TypeError(f"'{type(self).__name__}' does not support mutable operations.")
  110: 
  111:     def __str__(self) -> str:
  112:         return pprint_thing(self, quote_strings=True, escape_chars=("\t", "\r", "\n"))
  113: 
  114:     def __repr__(self) -> str:
  115:         return f"{type(self).__name__}({str(self)})"
  116: 
  117:     __setitem__ = __setslice__ = _disabled  # type: ignore[assignment]
  118:     __delitem__ = __delslice__ = _disabled
  119:     pop = append = extend = _disabled
  120:     remove = sort = insert = _disabled  # type: ignore[assignment]
