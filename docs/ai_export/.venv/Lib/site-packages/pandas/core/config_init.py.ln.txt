    1: """
    2: This module is imported from the pandas package __init__.py file
    3: in order to ensure that the core.config options registered here will
    4: be available as soon as the user loads the package. if register_option
    5: is invoked inside specific modules, they will not be registered until that
    6: module is imported, which may or may not be a problem.
    7: 
    8: If you need to make sure options are available even before a certain
    9: module is imported, register them here rather than in the module.
   10: 
   11: """
   12: from __future__ import annotations
   13: 
   14: import os
   15: from typing import Callable
   16: 
   17: import pandas._config.config as cf
   18: from pandas._config.config import (
   19:     is_bool,
   20:     is_callable,
   21:     is_instance_factory,
   22:     is_int,
   23:     is_nonnegative_int,
   24:     is_one_of_factory,
   25:     is_str,
   26:     is_text,
   27: )
   28: 
   29: # compute
   30: 
   31: use_bottleneck_doc = """
   32: : bool
   33:     Use the bottleneck library to accelerate if it is installed,
   34:     the default is True
   35:     Valid values: False,True
   36: """
   37: 
   38: 
   39: def use_bottleneck_cb(key) -> None:
   40:     from pandas.core import nanops
   41: 
   42:     nanops.set_use_bottleneck(cf.get_option(key))
   43: 
   44: 
   45: use_numexpr_doc = """
   46: : bool
   47:     Use the numexpr library to accelerate computation if it is installed,
   48:     the default is True
   49:     Valid values: False,True
   50: """
   51: 
   52: 
   53: def use_numexpr_cb(key) -> None:
   54:     from pandas.core.computation import expressions
   55: 
   56:     expressions.set_use_numexpr(cf.get_option(key))
   57: 
   58: 
   59: use_numba_doc = """
   60: : bool
   61:     Use the numba engine option for select operations if it is installed,
   62:     the default is False
   63:     Valid values: False,True
   64: """
   65: 
   66: 
   67: def use_numba_cb(key) -> None:
   68:     from pandas.core.util import numba_
   69: 
   70:     numba_.set_use_numba(cf.get_option(key))
   71: 
   72: 
   73: with cf.config_prefix("compute"):
   74:     cf.register_option(
   75:         "use_bottleneck",
   76:         True,
   77:         use_bottleneck_doc,
   78:         validator=is_bool,
   79:         cb=use_bottleneck_cb,
   80:     )
   81:     cf.register_option(
   82:         "use_numexpr", True, use_numexpr_doc, validator=is_bool, cb=use_numexpr_cb
   83:     )
   84:     cf.register_option(
   85:         "use_numba", False, use_numba_doc, validator=is_bool, cb=use_numba_cb
   86:     )
   87: #
   88: # options from the "display" namespace
   89: 
   90: pc_precision_doc = """
   91: : int
   92:     Floating point output precision in terms of number of places after the
   93:     decimal, for regular formatting as well as scientific notation. Similar
   94:     to ``precision`` in :meth:`numpy.set_printoptions`.
   95: """
   96: 
   97: pc_colspace_doc = """
   98: : int
   99:     Default space for DataFrame columns.
  100: """
  101: 
  102: pc_max_rows_doc = """
  103: : int
  104:     If max_rows is exceeded, switch to truncate view. Depending on
  105:     `large_repr`, objects are either centrally truncated or printed as
  106:     a summary view. 'None' value means unlimited.
  107: 
  108:     In case python/IPython is running in a terminal and `large_repr`
  109:     equals 'truncate' this can be set to 0 and pandas will auto-detect
  110:     the height of the terminal and print a truncated object which fits
  111:     the screen height. The IPython notebook, IPython qtconsole, or
  112:     IDLE do not run in a terminal and hence it is not possible to do
  113:     correct auto-detection.
  114: """
  115: 
  116: pc_min_rows_doc = """
  117: : int
  118:     The numbers of rows to show in a truncated view (when `max_rows` is
  119:     exceeded). Ignored when `max_rows` is set to None or 0. When set to
  120:     None, follows the value of `max_rows`.
  121: """
  122: 
  123: pc_max_cols_doc = """
  124: : int
  125:     If max_cols is exceeded, switch to truncate view. Depending on
  126:     `large_repr`, objects are either centrally truncated or printed as
  127:     a summary view. 'None' value means unlimited.
  128: 
  129:     In case python/IPython is running in a terminal and `large_repr`
  130:     equals 'truncate' this can be set to 0 or None and pandas will auto-detect
  131:     the width of the terminal and print a truncated object which fits
  132:     the screen width. The IPython notebook, IPython qtconsole, or IDLE
  133:     do not run in a terminal and hence it is not possible to do
  134:     correct auto-detection and defaults to 20.
  135: """
  136: 
  137: pc_max_categories_doc = """
  138: : int
  139:     This sets the maximum number of categories pandas should output when
  140:     printing out a `Categorical` or a Series of dtype "category".
  141: """
  142: 
  143: pc_max_info_cols_doc = """
  144: : int
  145:     max_info_columns is used in DataFrame.info method to decide if
  146:     per column information will be printed.
  147: """
  148: 
  149: pc_nb_repr_h_doc = """
  150: : boolean
  151:     When True, IPython notebook will use html representation for
  152:     pandas objects (if it is available).
  153: """
  154: 
  155: pc_pprint_nest_depth = """
  156: : int
  157:     Controls the number of nested levels to process when pretty-printing
  158: """
  159: 
  160: pc_multi_sparse_doc = """
  161: : boolean
  162:     "sparsify" MultiIndex display (don't display repeated
  163:     elements in outer levels within groups)
  164: """
  165: 
  166: float_format_doc = """
  167: : callable
  168:     The callable should accept a floating point number and return
  169:     a string with the desired format of the number. This is used
  170:     in some places like SeriesFormatter.
  171:     See formats.format.EngFormatter for an example.
  172: """
  173: 
  174: max_colwidth_doc = """
  175: : int or None
  176:     The maximum width in characters of a column in the repr of
  177:     a pandas data structure. When the column overflows, a "..."
  178:     placeholder is embedded in the output. A 'None' value means unlimited.
  179: """
  180: 
  181: colheader_justify_doc = """
  182: : 'left'/'right'
  183:     Controls the justification of column headers. used by DataFrameFormatter.
  184: """
  185: 
  186: pc_expand_repr_doc = """
  187: : boolean
  188:     Whether to print out the full DataFrame repr for wide DataFrames across
  189:     multiple lines, `max_columns` is still respected, but the output will
  190:     wrap-around across multiple "pages" if its width exceeds `display.width`.
  191: """
  192: 
  193: pc_show_dimensions_doc = """
  194: : boolean or 'truncate'
  195:     Whether to print out dimensions at the end of DataFrame repr.
  196:     If 'truncate' is specified, only print out the dimensions if the
  197:     frame is truncated (e.g. not display all rows and/or columns)
  198: """
  199: 
  200: pc_east_asian_width_doc = """
  201: : boolean
  202:     Whether to use the Unicode East Asian Width to calculate the display text
  203:     width.
  204:     Enabling this may affect to the performance (default: False)
  205: """
  206: 
  207: pc_ambiguous_as_wide_doc = """
  208: : boolean
  209:     Whether to handle Unicode characters belong to Ambiguous as Wide (width=2)
  210:     (default: False)
  211: """
  212: 
  213: pc_table_schema_doc = """
  214: : boolean
  215:     Whether to publish a Table Schema representation for frontends
  216:     that support it.
  217:     (default: False)
  218: """
  219: 
  220: pc_html_border_doc = """
  221: : int
  222:     A ``border=value`` attribute is inserted in the ``<table>`` tag
  223:     for the DataFrame HTML repr.
  224: """
  225: 
  226: pc_html_use_mathjax_doc = """\
  227: : boolean
  228:     When True, Jupyter notebook will process table contents using MathJax,
  229:     rendering mathematical expressions enclosed by the dollar symbol.
  230:     (default: True)
  231: """
  232: 
  233: pc_max_dir_items = """\
  234: : int
  235:     The number of items that will be added to `dir(...)`. 'None' value means
  236:     unlimited. Because dir is cached, changing this option will not immediately
  237:     affect already existing dataframes until a column is deleted or added.
  238: 
  239:     This is for instance used to suggest columns from a dataframe to tab
  240:     completion.
  241: """
  242: 
  243: pc_width_doc = """
  244: : int
  245:     Width of the display in characters. In case python/IPython is running in
  246:     a terminal this can be set to None and pandas will correctly auto-detect
  247:     the width.
  248:     Note that the IPython notebook, IPython qtconsole, or IDLE do not run in a
  249:     terminal and hence it is not possible to correctly detect the width.
  250: """
  251: 
  252: pc_chop_threshold_doc = """
  253: : float or None
  254:     if set to a float value, all float values smaller than the given threshold
  255:     will be displayed as exactly 0 by repr and friends.
  256: """
  257: 
  258: pc_max_seq_items = """
  259: : int or None
  260:     When pretty-printing a long sequence, no more then `max_seq_items`
  261:     will be printed. If items are omitted, they will be denoted by the
  262:     addition of "..." to the resulting string.
  263: 
  264:     If set to None, the number of items to be printed is unlimited.
  265: """
  266: 
  267: pc_max_info_rows_doc = """
  268: : int
  269:     df.info() will usually show null-counts for each column.
  270:     For large frames this can be quite slow. max_info_rows and max_info_cols
  271:     limit this null check only to frames with smaller dimensions than
  272:     specified.
  273: """
  274: 
  275: pc_large_repr_doc = """
  276: : 'truncate'/'info'
  277:     For DataFrames exceeding max_rows/max_cols, the repr (and HTML repr) can
  278:     show a truncated table, or switch to the view from
  279:     df.info() (the behaviour in earlier versions of pandas).
  280: """
  281: 
  282: pc_memory_usage_doc = """
  283: : bool, string or None
  284:     This specifies if the memory usage of a DataFrame should be displayed when
  285:     df.info() is called. Valid values True,False,'deep'
  286: """
  287: 
  288: 
  289: def table_schema_cb(key) -> None:
  290:     from pandas.io.formats.printing import enable_data_resource_formatter
  291: 
  292:     enable_data_resource_formatter(cf.get_option(key))
  293: 
  294: 
  295: def is_terminal() -> bool:
  296:     """
  297:     Detect if Python is running in a terminal.
  298: 
  299:     Returns True if Python is running in a terminal or False if not.
  300:     """
  301:     try:
  302:         # error: Name 'get_ipython' is not defined
  303:         ip = get_ipython()  # type: ignore[name-defined]
  304:     except NameError:  # assume standard Python interpreter in a terminal
  305:         return True
  306:     else:
  307:         if hasattr(ip, "kernel"):  # IPython as a Jupyter kernel
  308:             return False
  309:         else:  # IPython in a terminal
  310:             return True
  311: 
  312: 
  313: with cf.config_prefix("display"):
  314:     cf.register_option("precision", 6, pc_precision_doc, validator=is_nonnegative_int)
  315:     cf.register_option(
  316:         "float_format",
  317:         None,
  318:         float_format_doc,
  319:         validator=is_one_of_factory([None, is_callable]),
  320:     )
  321:     cf.register_option(
  322:         "max_info_rows",
  323:         1690785,
  324:         pc_max_info_rows_doc,
  325:         validator=is_int,
  326:     )
  327:     cf.register_option("max_rows", 60, pc_max_rows_doc, validator=is_nonnegative_int)
  328:     cf.register_option(
  329:         "min_rows",
  330:         10,
  331:         pc_min_rows_doc,
  332:         validator=is_instance_factory([type(None), int]),
  333:     )
  334:     cf.register_option("max_categories", 8, pc_max_categories_doc, validator=is_int)
  335: 
  336:     cf.register_option(
  337:         "max_colwidth",
  338:         50,
  339:         max_colwidth_doc,
  340:         validator=is_nonnegative_int,
  341:     )
  342:     if is_terminal():
  343:         max_cols = 0  # automatically determine optimal number of columns
  344:     else:
  345:         max_cols = 20  # cannot determine optimal number of columns
  346:     cf.register_option(
  347:         "max_columns", max_cols, pc_max_cols_doc, validator=is_nonnegative_int
  348:     )
  349:     cf.register_option(
  350:         "large_repr",
  351:         "truncate",
  352:         pc_large_repr_doc,
  353:         validator=is_one_of_factory(["truncate", "info"]),
  354:     )
  355:     cf.register_option("max_info_columns", 100, pc_max_info_cols_doc, validator=is_int)
  356:     cf.register_option(
  357:         "colheader_justify", "right", colheader_justify_doc, validator=is_text
  358:     )
  359:     cf.register_option("notebook_repr_html", True, pc_nb_repr_h_doc, validator=is_bool)
  360:     cf.register_option("pprint_nest_depth", 3, pc_pprint_nest_depth, validator=is_int)
  361:     cf.register_option("multi_sparse", True, pc_multi_sparse_doc, validator=is_bool)
  362:     cf.register_option("expand_frame_repr", True, pc_expand_repr_doc)
  363:     cf.register_option(
  364:         "show_dimensions",
  365:         "truncate",
  366:         pc_show_dimensions_doc,
  367:         validator=is_one_of_factory([True, False, "truncate"]),
  368:     )
  369:     cf.register_option("chop_threshold", None, pc_chop_threshold_doc)
  370:     cf.register_option("max_seq_items", 100, pc_max_seq_items)
  371:     cf.register_option(
  372:         "width", 80, pc_width_doc, validator=is_instance_factory([type(None), int])
  373:     )
  374:     cf.register_option(
  375:         "memory_usage",
  376:         True,
  377:         pc_memory_usage_doc,
  378:         validator=is_one_of_factory([None, True, False, "deep"]),
  379:     )
  380:     cf.register_option(
  381:         "unicode.east_asian_width", False, pc_east_asian_width_doc, validator=is_bool
  382:     )
  383:     cf.register_option(
  384:         "unicode.ambiguous_as_wide", False, pc_east_asian_width_doc, validator=is_bool
  385:     )
  386:     cf.register_option(
  387:         "html.table_schema",
  388:         False,
  389:         pc_table_schema_doc,
  390:         validator=is_bool,
  391:         cb=table_schema_cb,
  392:     )
  393:     cf.register_option("html.border", 1, pc_html_border_doc, validator=is_int)
  394:     cf.register_option(
  395:         "html.use_mathjax", True, pc_html_use_mathjax_doc, validator=is_bool
  396:     )
  397:     cf.register_option(
  398:         "max_dir_items", 100, pc_max_dir_items, validator=is_nonnegative_int
  399:     )
  400: 
  401: tc_sim_interactive_doc = """
  402: : boolean
  403:     Whether to simulate interactive mode for purposes of testing
  404: """
  405: 
  406: with cf.config_prefix("mode"):
  407:     cf.register_option("sim_interactive", False, tc_sim_interactive_doc)
  408: 
  409: use_inf_as_na_doc = """
  410: : boolean
  411:     True means treat None, NaN, INF, -INF as NA (old way),
  412:     False means None and NaN are null, but INF, -INF are not NA
  413:     (new way).
  414: 
  415:     This option is deprecated in pandas 2.1.0 and will be removed in 3.0.
  416: """
  417: 
  418: # We don't want to start importing everything at the global context level
  419: # or we'll hit circular deps.
  420: 
  421: 
  422: def use_inf_as_na_cb(key) -> None:
  423:     # TODO(3.0): enforcing this deprecation will close GH#52501
  424:     from pandas.core.dtypes.missing import _use_inf_as_na
  425: 
  426:     _use_inf_as_na(key)
  427: 
  428: 
  429: with cf.config_prefix("mode"):
  430:     cf.register_option("use_inf_as_na", False, use_inf_as_na_doc, cb=use_inf_as_na_cb)
  431: 
  432: cf.deprecate_option(
  433:     # GH#51684
  434:     "mode.use_inf_as_na",
  435:     "use_inf_as_na option is deprecated and will be removed in a future "
  436:     "version. Convert inf values to NaN before operating instead.",
  437: )
  438: 
  439: data_manager_doc = """
  440: : string
  441:     Internal data manager type; can be "block" or "array". Defaults to "block",
  442:     unless overridden by the 'PANDAS_DATA_MANAGER' environment variable (needs
  443:     to be set before pandas is imported).
  444: """
  445: 
  446: 
  447: with cf.config_prefix("mode"):
  448:     cf.register_option(
  449:         "data_manager",
  450:         # Get the default from an environment variable, if set, otherwise defaults
  451:         # to "block". This environment variable can be set for testing.
  452:         os.environ.get("PANDAS_DATA_MANAGER", "block"),
  453:         data_manager_doc,
  454:         validator=is_one_of_factory(["block", "array"]),
  455:     )
  456: 
  457: cf.deprecate_option(
  458:     # GH#55043
  459:     "mode.data_manager",
  460:     "data_manager option is deprecated and will be removed in a future "
  461:     "version. Only the BlockManager will be available.",
  462: )
  463: 
  464: 
  465: # TODO better name?
  466: copy_on_write_doc = """
  467: : bool
  468:     Use new copy-view behaviour using Copy-on-Write. Defaults to False,
  469:     unless overridden by the 'PANDAS_COPY_ON_WRITE' environment variable
  470:     (if set to "1" for True, needs to be set before pandas is imported).
  471: """
  472: 
  473: 
  474: with cf.config_prefix("mode"):
  475:     cf.register_option(
  476:         "copy_on_write",
  477:         # Get the default from an environment variable, if set, otherwise defaults
  478:         # to False. This environment variable can be set for testing.
  479:         "warn"
  480:         if os.environ.get("PANDAS_COPY_ON_WRITE", "0") == "warn"
  481:         else os.environ.get("PANDAS_COPY_ON_WRITE", "0") == "1",
  482:         copy_on_write_doc,
  483:         validator=is_one_of_factory([True, False, "warn"]),
  484:     )
  485: 
  486: 
  487: # user warnings
  488: chained_assignment = """
  489: : string
  490:     Raise an exception, warn, or no action if trying to use chained assignment,
  491:     The default is warn
  492: """
  493: 
  494: with cf.config_prefix("mode"):
  495:     cf.register_option(
  496:         "chained_assignment",
  497:         "warn",
  498:         chained_assignment,
  499:         validator=is_one_of_factory([None, "warn", "raise"]),
  500:     )
  501: 
  502: 
  503: string_storage_doc = """
  504: : string
  505:     The default storage for StringDtype. This option is ignored if
  506:     ``future.infer_string`` is set to True.
  507: """
  508: 
  509: with cf.config_prefix("mode"):
  510:     cf.register_option(
  511:         "string_storage",
  512:         "python",
  513:         string_storage_doc,
  514:         validator=is_one_of_factory(["python", "pyarrow", "pyarrow_numpy"]),
  515:     )
  516: 
  517: 
  518: # Set up the io.excel specific reader configuration.
  519: reader_engine_doc = """
  520: : string
  521:     The default Excel reader engine for '{ext}' files. Available options:
  522:     auto, {others}.
  523: """
  524: 
  525: _xls_options = ["xlrd", "calamine"]
  526: _xlsm_options = ["xlrd", "openpyxl", "calamine"]
  527: _xlsx_options = ["xlrd", "openpyxl", "calamine"]
  528: _ods_options = ["odf", "calamine"]
  529: _xlsb_options = ["pyxlsb", "calamine"]
  530: 
  531: 
  532: with cf.config_prefix("io.excel.xls"):
  533:     cf.register_option(
  534:         "reader",
  535:         "auto",
  536:         reader_engine_doc.format(ext="xls", others=", ".join(_xls_options)),
  537:         validator=is_one_of_factory(_xls_options + ["auto"]),
  538:     )
  539: 
  540: with cf.config_prefix("io.excel.xlsm"):
  541:     cf.register_option(
  542:         "reader",
  543:         "auto",
  544:         reader_engine_doc.format(ext="xlsm", others=", ".join(_xlsm_options)),
  545:         validator=is_one_of_factory(_xlsm_options + ["auto"]),
  546:     )
  547: 
  548: 
  549: with cf.config_prefix("io.excel.xlsx"):
  550:     cf.register_option(
  551:         "reader",
  552:         "auto",
  553:         reader_engine_doc.format(ext="xlsx", others=", ".join(_xlsx_options)),
  554:         validator=is_one_of_factory(_xlsx_options + ["auto"]),
  555:     )
  556: 
  557: 
  558: with cf.config_prefix("io.excel.ods"):
  559:     cf.register_option(
  560:         "reader",
  561:         "auto",
  562:         reader_engine_doc.format(ext="ods", others=", ".join(_ods_options)),
  563:         validator=is_one_of_factory(_ods_options + ["auto"]),
  564:     )
  565: 
  566: with cf.config_prefix("io.excel.xlsb"):
  567:     cf.register_option(
  568:         "reader",
  569:         "auto",
  570:         reader_engine_doc.format(ext="xlsb", others=", ".join(_xlsb_options)),
  571:         validator=is_one_of_factory(_xlsb_options + ["auto"]),
  572:     )
  573: 
  574: # Set up the io.excel specific writer configuration.
  575: writer_engine_doc = """
  576: : string
  577:     The default Excel writer engine for '{ext}' files. Available options:
  578:     auto, {others}.
  579: """
  580: 
  581: _xlsm_options = ["openpyxl"]
  582: _xlsx_options = ["openpyxl", "xlsxwriter"]
  583: _ods_options = ["odf"]
  584: 
  585: 
  586: with cf.config_prefix("io.excel.xlsm"):
  587:     cf.register_option(
  588:         "writer",
  589:         "auto",
  590:         writer_engine_doc.format(ext="xlsm", others=", ".join(_xlsm_options)),
  591:         validator=str,
  592:     )
  593: 
  594: 
  595: with cf.config_prefix("io.excel.xlsx"):
  596:     cf.register_option(
  597:         "writer",
  598:         "auto",
  599:         writer_engine_doc.format(ext="xlsx", others=", ".join(_xlsx_options)),
  600:         validator=str,
  601:     )
  602: 
  603: 
  604: with cf.config_prefix("io.excel.ods"):
  605:     cf.register_option(
  606:         "writer",
  607:         "auto",
  608:         writer_engine_doc.format(ext="ods", others=", ".join(_ods_options)),
  609:         validator=str,
  610:     )
  611: 
  612: 
  613: # Set up the io.parquet specific configuration.
  614: parquet_engine_doc = """
  615: : string
  616:     The default parquet reader/writer engine. Available options:
  617:     'auto', 'pyarrow', 'fastparquet', the default is 'auto'
  618: """
  619: 
  620: with cf.config_prefix("io.parquet"):
  621:     cf.register_option(
  622:         "engine",
  623:         "auto",
  624:         parquet_engine_doc,
  625:         validator=is_one_of_factory(["auto", "pyarrow", "fastparquet"]),
  626:     )
  627: 
  628: 
  629: # Set up the io.sql specific configuration.
  630: sql_engine_doc = """
  631: : string
  632:     The default sql reader/writer engine. Available options:
  633:     'auto', 'sqlalchemy', the default is 'auto'
  634: """
  635: 
  636: with cf.config_prefix("io.sql"):
  637:     cf.register_option(
  638:         "engine",
  639:         "auto",
  640:         sql_engine_doc,
  641:         validator=is_one_of_factory(["auto", "sqlalchemy"]),
  642:     )
  643: 
  644: # --------
  645: # Plotting
  646: # ---------
  647: 
  648: plotting_backend_doc = """
  649: : str
  650:     The plotting backend to use. The default value is "matplotlib", the
  651:     backend provided with pandas. Other backends can be specified by
  652:     providing the name of the module that implements the backend.
  653: """
  654: 
  655: 
  656: def register_plotting_backend_cb(key) -> None:
  657:     if key == "matplotlib":
  658:         # We defer matplotlib validation, since it's the default
  659:         return
  660:     from pandas.plotting._core import _get_plot_backend
  661: 
  662:     _get_plot_backend(key)
  663: 
  664: 
  665: with cf.config_prefix("plotting"):
  666:     cf.register_option(
  667:         "backend",
  668:         defval="matplotlib",
  669:         doc=plotting_backend_doc,
  670:         validator=register_plotting_backend_cb,
  671:     )
  672: 
  673: 
  674: register_converter_doc = """
  675: : bool or 'auto'.
  676:     Whether to register converters with matplotlib's units registry for
  677:     dates, times, datetimes, and Periods. Toggling to False will remove
  678:     the converters, restoring any converters that pandas overwrote.
  679: """
  680: 
  681: 
  682: def register_converter_cb(key) -> None:
  683:     from pandas.plotting import (
  684:         deregister_matplotlib_converters,
  685:         register_matplotlib_converters,
  686:     )
  687: 
  688:     if cf.get_option(key):
  689:         register_matplotlib_converters()
  690:     else:
  691:         deregister_matplotlib_converters()
  692: 
  693: 
  694: with cf.config_prefix("plotting.matplotlib"):
  695:     cf.register_option(
  696:         "register_converters",
  697:         "auto",
  698:         register_converter_doc,
  699:         validator=is_one_of_factory(["auto", True, False]),
  700:         cb=register_converter_cb,
  701:     )
  702: 
  703: # ------
  704: # Styler
  705: # ------
  706: 
  707: styler_sparse_index_doc = """
  708: : bool
  709:     Whether to sparsify the display of a hierarchical index. Setting to False will
  710:     display each explicit level element in a hierarchical key for each row.
  711: """
  712: 
  713: styler_sparse_columns_doc = """
  714: : bool
  715:     Whether to sparsify the display of hierarchical columns. Setting to False will
  716:     display each explicit level element in a hierarchical key for each column.
  717: """
  718: 
  719: styler_render_repr = """
  720: : str
  721:     Determine which output to use in Jupyter Notebook in {"html", "latex"}.
  722: """
  723: 
  724: styler_max_elements = """
  725: : int
  726:     The maximum number of data-cell (<td>) elements that will be rendered before
  727:     trimming will occur over columns, rows or both if needed.
  728: """
  729: 
  730: styler_max_rows = """
  731: : int, optional
  732:     The maximum number of rows that will be rendered. May still be reduced to
  733:     satisfy ``max_elements``, which takes precedence.
  734: """
  735: 
  736: styler_max_columns = """
  737: : int, optional
  738:     The maximum number of columns that will be rendered. May still be reduced to
  739:     satisfy ``max_elements``, which takes precedence.
  740: """
  741: 
  742: styler_precision = """
  743: : int
  744:     The precision for floats and complex numbers.
  745: """
  746: 
  747: styler_decimal = """
  748: : str
  749:     The character representation for the decimal separator for floats and complex.
  750: """
  751: 
  752: styler_thousands = """
  753: : str, optional
  754:     The character representation for thousands separator for floats, int and complex.
  755: """
  756: 
  757: styler_na_rep = """
  758: : str, optional
  759:     The string representation for values identified as missing.
  760: """
  761: 
  762: styler_escape = """
  763: : str, optional
  764:     Whether to escape certain characters according to the given context; html or latex.
  765: """
  766: 
  767: styler_formatter = """
  768: : str, callable, dict, optional
  769:     A formatter object to be used as default within ``Styler.format``.
  770: """
  771: 
  772: styler_multirow_align = """
  773: : {"c", "t", "b"}
  774:     The specifier for vertical alignment of sparsified LaTeX multirows.
  775: """
  776: 
  777: styler_multicol_align = r"""
  778: : {"r", "c", "l", "naive-l", "naive-r"}
  779:     The specifier for horizontal alignment of sparsified LaTeX multicolumns. Pipe
  780:     decorators can also be added to non-naive values to draw vertical
  781:     rules, e.g. "\|r" will draw a rule on the left side of right aligned merged cells.
  782: """
  783: 
  784: styler_hrules = """
  785: : bool
  786:     Whether to add horizontal rules on top and bottom and below the headers.
  787: """
  788: 
  789: styler_environment = """
  790: : str
  791:     The environment to replace ``\\begin{table}``. If "longtable" is used results
  792:     in a specific longtable environment format.
  793: """
  794: 
  795: styler_encoding = """
  796: : str
  797:     The encoding used for output HTML and LaTeX files.
  798: """
  799: 
  800: styler_mathjax = """
  801: : bool
  802:     If False will render special CSS classes to table attributes that indicate Mathjax
  803:     will not be used in Jupyter Notebook.
  804: """
  805: 
  806: with cf.config_prefix("styler"):
  807:     cf.register_option("sparse.index", True, styler_sparse_index_doc, validator=is_bool)
  808: 
  809:     cf.register_option(
  810:         "sparse.columns", True, styler_sparse_columns_doc, validator=is_bool
  811:     )
  812: 
  813:     cf.register_option(
  814:         "render.repr",
  815:         "html",
  816:         styler_render_repr,
  817:         validator=is_one_of_factory(["html", "latex"]),
  818:     )
  819: 
  820:     cf.register_option(
  821:         "render.max_elements",
  822:         2**18,
  823:         styler_max_elements,
  824:         validator=is_nonnegative_int,
  825:     )
  826: 
  827:     cf.register_option(
  828:         "render.max_rows",
  829:         None,
  830:         styler_max_rows,
  831:         validator=is_nonnegative_int,
  832:     )
  833: 
  834:     cf.register_option(
  835:         "render.max_columns",
  836:         None,
  837:         styler_max_columns,
  838:         validator=is_nonnegative_int,
  839:     )
  840: 
  841:     cf.register_option("render.encoding", "utf-8", styler_encoding, validator=is_str)
  842: 
  843:     cf.register_option("format.decimal", ".", styler_decimal, validator=is_str)
  844: 
  845:     cf.register_option(
  846:         "format.precision", 6, styler_precision, validator=is_nonnegative_int
  847:     )
  848: 
  849:     cf.register_option(
  850:         "format.thousands",
  851:         None,
  852:         styler_thousands,
  853:         validator=is_instance_factory([type(None), str]),
  854:     )
  855: 
  856:     cf.register_option(
  857:         "format.na_rep",
  858:         None,
  859:         styler_na_rep,
  860:         validator=is_instance_factory([type(None), str]),
  861:     )
  862: 
  863:     cf.register_option(
  864:         "format.escape",
  865:         None,
  866:         styler_escape,
  867:         validator=is_one_of_factory([None, "html", "latex", "latex-math"]),
  868:     )
  869: 
  870:     cf.register_option(
  871:         "format.formatter",
  872:         None,
  873:         styler_formatter,
  874:         validator=is_instance_factory([type(None), dict, Callable, str]),
  875:     )
  876: 
  877:     cf.register_option("html.mathjax", True, styler_mathjax, validator=is_bool)
  878: 
  879:     cf.register_option(
  880:         "latex.multirow_align",
  881:         "c",
  882:         styler_multirow_align,
  883:         validator=is_one_of_factory(["c", "t", "b", "naive"]),
  884:     )
  885: 
  886:     val_mca = ["r", "|r|", "|r", "r|", "c", "|c|", "|c", "c|", "l", "|l|", "|l", "l|"]
  887:     val_mca += ["naive-l", "naive-r"]
  888:     cf.register_option(
  889:         "latex.multicol_align",
  890:         "r",
  891:         styler_multicol_align,
  892:         validator=is_one_of_factory(val_mca),
  893:     )
  894: 
  895:     cf.register_option("latex.hrules", False, styler_hrules, validator=is_bool)
  896: 
  897:     cf.register_option(
  898:         "latex.environment",
  899:         None,
  900:         styler_environment,
  901:         validator=is_instance_factory([type(None), str]),
  902:     )
  903: 
  904: 
  905: with cf.config_prefix("future"):
  906:     cf.register_option(
  907:         "infer_string",
  908:         False,
  909:         "Whether to infer sequence of str objects as pyarrow string "
  910:         "dtype, which will be the default in pandas 3.0 "
  911:         "(at which point this option will be deprecated).",
  912:         validator=is_one_of_factory([True, False]),
  913:     )
  914: 
  915:     cf.register_option(
  916:         "no_silent_downcasting",
  917:         False,
  918:         "Whether to opt-in to the future behavior which will *not* silently "
  919:         "downcast results from Series and DataFrame `where`, `mask`, and `clip` "
  920:         "methods. "
  921:         "Silent downcasting will be removed in pandas 3.0 "
  922:         "(at which point this option will be deprecated).",
  923:         validator=is_one_of_factory([True, False]),
  924:     )
