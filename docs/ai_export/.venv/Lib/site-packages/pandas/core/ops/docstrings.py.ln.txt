    1: """
    2: Templating for ops docstrings
    3: """
    4: from __future__ import annotations
    5: 
    6: 
    7: def make_flex_doc(op_name: str, typ: str) -> str:
    8:     """
    9:     Make the appropriate substitutions for the given operation and class-typ
   10:     into either _flex_doc_SERIES or _flex_doc_FRAME to return the docstring
   11:     to attach to a generated method.
   12: 
   13:     Parameters
   14:     ----------
   15:     op_name : str {'__add__', '__sub__', ... '__eq__', '__ne__', ...}
   16:     typ : str {series, 'dataframe']}
   17: 
   18:     Returns
   19:     -------
   20:     doc : str
   21:     """
   22:     op_name = op_name.replace("__", "")
   23:     op_desc = _op_descriptions[op_name]
   24: 
   25:     op_desc_op = op_desc["op"]
   26:     assert op_desc_op is not None  # for mypy
   27:     if op_name.startswith("r"):
   28:         equiv = f"other {op_desc_op} {typ}"
   29:     elif op_name == "divmod":
   30:         equiv = f"{op_name}({typ}, other)"
   31:     else:
   32:         equiv = f"{typ} {op_desc_op} other"
   33: 
   34:     if typ == "series":
   35:         base_doc = _flex_doc_SERIES
   36:         if op_desc["reverse"]:
   37:             base_doc += _see_also_reverse_SERIES.format(
   38:                 reverse=op_desc["reverse"], see_also_desc=op_desc["see_also_desc"]
   39:             )
   40:         doc_no_examples = base_doc.format(
   41:             desc=op_desc["desc"],
   42:             op_name=op_name,
   43:             equiv=equiv,
   44:             series_returns=op_desc["series_returns"],
   45:         )
   46:         ser_example = op_desc["series_examples"]
   47:         if ser_example:
   48:             doc = doc_no_examples + ser_example
   49:         else:
   50:             doc = doc_no_examples
   51:     elif typ == "dataframe":
   52:         if op_name in ["eq", "ne", "le", "lt", "ge", "gt"]:
   53:             base_doc = _flex_comp_doc_FRAME
   54:             doc = _flex_comp_doc_FRAME.format(
   55:                 op_name=op_name,
   56:                 desc=op_desc["desc"],
   57:             )
   58:         else:
   59:             base_doc = _flex_doc_FRAME
   60:             doc = base_doc.format(
   61:                 desc=op_desc["desc"],
   62:                 op_name=op_name,
   63:                 equiv=equiv,
   64:                 reverse=op_desc["reverse"],
   65:             )
   66:     else:
   67:         raise AssertionError("Invalid typ argument.")
   68:     return doc
   69: 
   70: 
   71: _common_examples_algebra_SERIES = """
   72: Examples
   73: --------
   74: >>> a = pd.Series([1, 1, 1, np.nan], index=['a', 'b', 'c', 'd'])
   75: >>> a
   76: a    1.0
   77: b    1.0
   78: c    1.0
   79: d    NaN
   80: dtype: float64
   81: >>> b = pd.Series([1, np.nan, 1, np.nan], index=['a', 'b', 'd', 'e'])
   82: >>> b
   83: a    1.0
   84: b    NaN
   85: d    1.0
   86: e    NaN
   87: dtype: float64"""
   88: 
   89: _common_examples_comparison_SERIES = """
   90: Examples
   91: --------
   92: >>> a = pd.Series([1, 1, 1, np.nan, 1], index=['a', 'b', 'c', 'd', 'e'])
   93: >>> a
   94: a    1.0
   95: b    1.0
   96: c    1.0
   97: d    NaN
   98: e    1.0
   99: dtype: float64
  100: >>> b = pd.Series([0, 1, 2, np.nan, 1], index=['a', 'b', 'c', 'd', 'f'])
  101: >>> b
  102: a    0.0
  103: b    1.0
  104: c    2.0
  105: d    NaN
  106: f    1.0
  107: dtype: float64"""
  108: 
  109: _add_example_SERIES = (
  110:     _common_examples_algebra_SERIES
  111:     + """
  112: >>> a.add(b, fill_value=0)
  113: a    2.0
  114: b    1.0
  115: c    1.0
  116: d    1.0
  117: e    NaN
  118: dtype: float64
  119: """
  120: )
  121: 
  122: _sub_example_SERIES = (
  123:     _common_examples_algebra_SERIES
  124:     + """
  125: >>> a.subtract(b, fill_value=0)
  126: a    0.0
  127: b    1.0
  128: c    1.0
  129: d   -1.0
  130: e    NaN
  131: dtype: float64
  132: """
  133: )
  134: 
  135: _mul_example_SERIES = (
  136:     _common_examples_algebra_SERIES
  137:     + """
  138: >>> a.multiply(b, fill_value=0)
  139: a    1.0
  140: b    0.0
  141: c    0.0
  142: d    0.0
  143: e    NaN
  144: dtype: float64
  145: """
  146: )
  147: 
  148: _div_example_SERIES = (
  149:     _common_examples_algebra_SERIES
  150:     + """
  151: >>> a.divide(b, fill_value=0)
  152: a    1.0
  153: b    inf
  154: c    inf
  155: d    0.0
  156: e    NaN
  157: dtype: float64
  158: """
  159: )
  160: 
  161: _floordiv_example_SERIES = (
  162:     _common_examples_algebra_SERIES
  163:     + """
  164: >>> a.floordiv(b, fill_value=0)
  165: a    1.0
  166: b    inf
  167: c    inf
  168: d    0.0
  169: e    NaN
  170: dtype: float64
  171: """
  172: )
  173: 
  174: _divmod_example_SERIES = (
  175:     _common_examples_algebra_SERIES
  176:     + """
  177: >>> a.divmod(b, fill_value=0)
  178: (a    1.0
  179:  b    inf
  180:  c    inf
  181:  d    0.0
  182:  e    NaN
  183:  dtype: float64,
  184:  a    0.0
  185:  b    NaN
  186:  c    NaN
  187:  d    0.0
  188:  e    NaN
  189:  dtype: float64)
  190: """
  191: )
  192: 
  193: _mod_example_SERIES = (
  194:     _common_examples_algebra_SERIES
  195:     + """
  196: >>> a.mod(b, fill_value=0)
  197: a    0.0
  198: b    NaN
  199: c    NaN
  200: d    0.0
  201: e    NaN
  202: dtype: float64
  203: """
  204: )
  205: _pow_example_SERIES = (
  206:     _common_examples_algebra_SERIES
  207:     + """
  208: >>> a.pow(b, fill_value=0)
  209: a    1.0
  210: b    1.0
  211: c    1.0
  212: d    0.0
  213: e    NaN
  214: dtype: float64
  215: """
  216: )
  217: 
  218: _ne_example_SERIES = (
  219:     _common_examples_algebra_SERIES
  220:     + """
  221: >>> a.ne(b, fill_value=0)
  222: a    False
  223: b     True
  224: c     True
  225: d     True
  226: e     True
  227: dtype: bool
  228: """
  229: )
  230: 
  231: _eq_example_SERIES = (
  232:     _common_examples_algebra_SERIES
  233:     + """
  234: >>> a.eq(b, fill_value=0)
  235: a     True
  236: b    False
  237: c    False
  238: d    False
  239: e    False
  240: dtype: bool
  241: """
  242: )
  243: 
  244: _lt_example_SERIES = (
  245:     _common_examples_comparison_SERIES
  246:     + """
  247: >>> a.lt(b, fill_value=0)
  248: a    False
  249: b    False
  250: c     True
  251: d    False
  252: e    False
  253: f     True
  254: dtype: bool
  255: """
  256: )
  257: 
  258: _le_example_SERIES = (
  259:     _common_examples_comparison_SERIES
  260:     + """
  261: >>> a.le(b, fill_value=0)
  262: a    False
  263: b     True
  264: c     True
  265: d    False
  266: e    False
  267: f     True
  268: dtype: bool
  269: """
  270: )
  271: 
  272: _gt_example_SERIES = (
  273:     _common_examples_comparison_SERIES
  274:     + """
  275: >>> a.gt(b, fill_value=0)
  276: a     True
  277: b    False
  278: c    False
  279: d    False
  280: e     True
  281: f    False
  282: dtype: bool
  283: """
  284: )
  285: 
  286: _ge_example_SERIES = (
  287:     _common_examples_comparison_SERIES
  288:     + """
  289: >>> a.ge(b, fill_value=0)
  290: a     True
  291: b     True
  292: c    False
  293: d    False
  294: e     True
  295: f    False
  296: dtype: bool
  297: """
  298: )
  299: 
  300: _returns_series = """Series\n    The result of the operation."""
  301: 
  302: _returns_tuple = """2-Tuple of Series\n    The result of the operation."""
  303: 
  304: _op_descriptions: dict[str, dict[str, str | None]] = {
  305:     # Arithmetic Operators
  306:     "add": {
  307:         "op": "+",
  308:         "desc": "Addition",
  309:         "reverse": "radd",
  310:         "series_examples": _add_example_SERIES,
  311:         "series_returns": _returns_series,
  312:     },
  313:     "sub": {
  314:         "op": "-",
  315:         "desc": "Subtraction",
  316:         "reverse": "rsub",
  317:         "series_examples": _sub_example_SERIES,
  318:         "series_returns": _returns_series,
  319:     },
  320:     "mul": {
  321:         "op": "*",
  322:         "desc": "Multiplication",
  323:         "reverse": "rmul",
  324:         "series_examples": _mul_example_SERIES,
  325:         "series_returns": _returns_series,
  326:         "df_examples": None,
  327:     },
  328:     "mod": {
  329:         "op": "%",
  330:         "desc": "Modulo",
  331:         "reverse": "rmod",
  332:         "series_examples": _mod_example_SERIES,
  333:         "series_returns": _returns_series,
  334:     },
  335:     "pow": {
  336:         "op": "**",
  337:         "desc": "Exponential power",
  338:         "reverse": "rpow",
  339:         "series_examples": _pow_example_SERIES,
  340:         "series_returns": _returns_series,
  341:         "df_examples": None,
  342:     },
  343:     "truediv": {
  344:         "op": "/",
  345:         "desc": "Floating division",
  346:         "reverse": "rtruediv",
  347:         "series_examples": _div_example_SERIES,
  348:         "series_returns": _returns_series,
  349:         "df_examples": None,
  350:     },
  351:     "floordiv": {
  352:         "op": "//",
  353:         "desc": "Integer division",
  354:         "reverse": "rfloordiv",
  355:         "series_examples": _floordiv_example_SERIES,
  356:         "series_returns": _returns_series,
  357:         "df_examples": None,
  358:     },
  359:     "divmod": {
  360:         "op": "divmod",
  361:         "desc": "Integer division and modulo",
  362:         "reverse": "rdivmod",
  363:         "series_examples": _divmod_example_SERIES,
  364:         "series_returns": _returns_tuple,
  365:         "df_examples": None,
  366:     },
  367:     # Comparison Operators
  368:     "eq": {
  369:         "op": "==",
  370:         "desc": "Equal to",
  371:         "reverse": None,
  372:         "series_examples": _eq_example_SERIES,
  373:         "series_returns": _returns_series,
  374:     },
  375:     "ne": {
  376:         "op": "!=",
  377:         "desc": "Not equal to",
  378:         "reverse": None,
  379:         "series_examples": _ne_example_SERIES,
  380:         "series_returns": _returns_series,
  381:     },
  382:     "lt": {
  383:         "op": "<",
  384:         "desc": "Less than",
  385:         "reverse": None,
  386:         "series_examples": _lt_example_SERIES,
  387:         "series_returns": _returns_series,
  388:     },
  389:     "le": {
  390:         "op": "<=",
  391:         "desc": "Less than or equal to",
  392:         "reverse": None,
  393:         "series_examples": _le_example_SERIES,
  394:         "series_returns": _returns_series,
  395:     },
  396:     "gt": {
  397:         "op": ">",
  398:         "desc": "Greater than",
  399:         "reverse": None,
  400:         "series_examples": _gt_example_SERIES,
  401:         "series_returns": _returns_series,
  402:     },
  403:     "ge": {
  404:         "op": ">=",
  405:         "desc": "Greater than or equal to",
  406:         "reverse": None,
  407:         "series_examples": _ge_example_SERIES,
  408:         "series_returns": _returns_series,
  409:     },
  410: }
  411: 
  412: _py_num_ref = """see
  413:     `Python documentation
  414:     <https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types>`_
  415:     for more details"""
  416: _op_names = list(_op_descriptions.keys())
  417: for key in _op_names:
  418:     reverse_op = _op_descriptions[key]["reverse"]
  419:     if reverse_op is not None:
  420:         _op_descriptions[reverse_op] = _op_descriptions[key].copy()
  421:         _op_descriptions[reverse_op]["reverse"] = key
  422:         _op_descriptions[key][
  423:             "see_also_desc"
  424:         ] = f"Reverse of the {_op_descriptions[key]['desc']} operator, {_py_num_ref}"
  425:         _op_descriptions[reverse_op][
  426:             "see_also_desc"
  427:         ] = f"Element-wise {_op_descriptions[key]['desc']}, {_py_num_ref}"
  428: 
  429: _flex_doc_SERIES = """
  430: Return {desc} of series and other, element-wise (binary operator `{op_name}`).
  431: 
  432: Equivalent to ``{equiv}``, but with support to substitute a fill_value for
  433: missing data in either one of the inputs.
  434: 
  435: Parameters
  436: ----------
  437: other : Series or scalar value
  438: level : int or name
  439:     Broadcast across a level, matching Index values on the
  440:     passed MultiIndex level.
  441: fill_value : None or float value, default None (NaN)
  442:     Fill existing missing (NaN) values, and any new element needed for
  443:     successful Series alignment, with this value before computation.
  444:     If data in both corresponding Series locations is missing
  445:     the result of filling (at that location) will be missing.
  446: axis : {{0 or 'index'}}
  447:     Unused. Parameter needed for compatibility with DataFrame.
  448: 
  449: Returns
  450: -------
  451: {series_returns}
  452: """
  453: 
  454: _see_also_reverse_SERIES = """
  455: See Also
  456: --------
  457: Series.{reverse} : {see_also_desc}.
  458: """
  459: 
  460: _flex_doc_FRAME = """
  461: Get {desc} of dataframe and other, element-wise (binary operator `{op_name}`).
  462: 
  463: Equivalent to ``{equiv}``, but with support to substitute a fill_value
  464: for missing data in one of the inputs. With reverse version, `{reverse}`.
  465: 
  466: Among flexible wrappers (`add`, `sub`, `mul`, `div`, `floordiv`, `mod`, `pow`) to
  467: arithmetic operators: `+`, `-`, `*`, `/`, `//`, `%`, `**`.
  468: 
  469: Parameters
  470: ----------
  471: other : scalar, sequence, Series, dict or DataFrame
  472:     Any single or multiple element data structure, or list-like object.
  473: axis : {{0 or 'index', 1 or 'columns'}}
  474:     Whether to compare by the index (0 or 'index') or columns.
  475:     (1 or 'columns'). For Series input, axis to match Series index on.
  476: level : int or label
  477:     Broadcast across a level, matching Index values on the
  478:     passed MultiIndex level.
  479: fill_value : float or None, default None
  480:     Fill existing missing (NaN) values, and any new element needed for
  481:     successful DataFrame alignment, with this value before computation.
  482:     If data in both corresponding DataFrame locations is missing
  483:     the result will be missing.
  484: 
  485: Returns
  486: -------
  487: DataFrame
  488:     Result of the arithmetic operation.
  489: 
  490: See Also
  491: --------
  492: DataFrame.add : Add DataFrames.
  493: DataFrame.sub : Subtract DataFrames.
  494: DataFrame.mul : Multiply DataFrames.
  495: DataFrame.div : Divide DataFrames (float division).
  496: DataFrame.truediv : Divide DataFrames (float division).
  497: DataFrame.floordiv : Divide DataFrames (integer division).
  498: DataFrame.mod : Calculate modulo (remainder after division).
  499: DataFrame.pow : Calculate exponential power.
  500: 
  501: Notes
  502: -----
  503: Mismatched indices will be unioned together.
  504: 
  505: Examples
  506: --------
  507: >>> df = pd.DataFrame({{'angles': [0, 3, 4],
  508: ...                    'degrees': [360, 180, 360]}},
  509: ...                   index=['circle', 'triangle', 'rectangle'])
  510: >>> df
  511:            angles  degrees
  512: circle          0      360
  513: triangle        3      180
  514: rectangle       4      360
  515: 
  516: Add a scalar with operator version which return the same
  517: results.
  518: 
  519: >>> df + 1
  520:            angles  degrees
  521: circle          1      361
  522: triangle        4      181
  523: rectangle       5      361
  524: 
  525: >>> df.add(1)
  526:            angles  degrees
  527: circle          1      361
  528: triangle        4      181
  529: rectangle       5      361
  530: 
  531: Divide by constant with reverse version.
  532: 
  533: >>> df.div(10)
  534:            angles  degrees
  535: circle        0.0     36.0
  536: triangle      0.3     18.0
  537: rectangle     0.4     36.0
  538: 
  539: >>> df.rdiv(10)
  540:              angles   degrees
  541: circle          inf  0.027778
  542: triangle   3.333333  0.055556
  543: rectangle  2.500000  0.027778
  544: 
  545: Subtract a list and Series by axis with operator version.
  546: 
  547: >>> df - [1, 2]
  548:            angles  degrees
  549: circle         -1      358
  550: triangle        2      178
  551: rectangle       3      358
  552: 
  553: >>> df.sub([1, 2], axis='columns')
  554:            angles  degrees
  555: circle         -1      358
  556: triangle        2      178
  557: rectangle       3      358
  558: 
  559: >>> df.sub(pd.Series([1, 1, 1], index=['circle', 'triangle', 'rectangle']),
  560: ...        axis='index')
  561:            angles  degrees
  562: circle         -1      359
  563: triangle        2      179
  564: rectangle       3      359
  565: 
  566: Multiply a dictionary by axis.
  567: 
  568: >>> df.mul({{'angles': 0, 'degrees': 2}})
  569:             angles  degrees
  570: circle           0      720
  571: triangle         0      360
  572: rectangle        0      720
  573: 
  574: >>> df.mul({{'circle': 0, 'triangle': 2, 'rectangle': 3}}, axis='index')
  575:             angles  degrees
  576: circle           0        0
  577: triangle         6      360
  578: rectangle       12     1080
  579: 
  580: Multiply a DataFrame of different shape with operator version.
  581: 
  582: >>> other = pd.DataFrame({{'angles': [0, 3, 4]}},
  583: ...                      index=['circle', 'triangle', 'rectangle'])
  584: >>> other
  585:            angles
  586: circle          0
  587: triangle        3
  588: rectangle       4
  589: 
  590: >>> df * other
  591:            angles  degrees
  592: circle          0      NaN
  593: triangle        9      NaN
  594: rectangle      16      NaN
  595: 
  596: >>> df.mul(other, fill_value=0)
  597:            angles  degrees
  598: circle          0      0.0
  599: triangle        9      0.0
  600: rectangle      16      0.0
  601: 
  602: Divide by a MultiIndex by level.
  603: 
  604: >>> df_multindex = pd.DataFrame({{'angles': [0, 3, 4, 4, 5, 6],
  605: ...                              'degrees': [360, 180, 360, 360, 540, 720]}},
  606: ...                             index=[['A', 'A', 'A', 'B', 'B', 'B'],
  607: ...                                    ['circle', 'triangle', 'rectangle',
  608: ...                                     'square', 'pentagon', 'hexagon']])
  609: >>> df_multindex
  610:              angles  degrees
  611: A circle          0      360
  612:   triangle        3      180
  613:   rectangle       4      360
  614: B square          4      360
  615:   pentagon        5      540
  616:   hexagon         6      720
  617: 
  618: >>> df.div(df_multindex, level=1, fill_value=0)
  619:              angles  degrees
  620: A circle        NaN      1.0
  621:   triangle      1.0      1.0
  622:   rectangle     1.0      1.0
  623: B square        0.0      0.0
  624:   pentagon      0.0      0.0
  625:   hexagon       0.0      0.0
  626: """
  627: 
  628: _flex_comp_doc_FRAME = """
  629: Get {desc} of dataframe and other, element-wise (binary operator `{op_name}`).
  630: 
  631: Among flexible wrappers (`eq`, `ne`, `le`, `lt`, `ge`, `gt`) to comparison
  632: operators.
  633: 
  634: Equivalent to `==`, `!=`, `<=`, `<`, `>=`, `>` with support to choose axis
  635: (rows or columns) and level for comparison.
  636: 
  637: Parameters
  638: ----------
  639: other : scalar, sequence, Series, or DataFrame
  640:     Any single or multiple element data structure, or list-like object.
  641: axis : {{0 or 'index', 1 or 'columns'}}, default 'columns'
  642:     Whether to compare by the index (0 or 'index') or columns
  643:     (1 or 'columns').
  644: level : int or label
  645:     Broadcast across a level, matching Index values on the passed
  646:     MultiIndex level.
  647: 
  648: Returns
  649: -------
  650: DataFrame of bool
  651:     Result of the comparison.
  652: 
  653: See Also
  654: --------
  655: DataFrame.eq : Compare DataFrames for equality elementwise.
  656: DataFrame.ne : Compare DataFrames for inequality elementwise.
  657: DataFrame.le : Compare DataFrames for less than inequality
  658:     or equality elementwise.
  659: DataFrame.lt : Compare DataFrames for strictly less than
  660:     inequality elementwise.
  661: DataFrame.ge : Compare DataFrames for greater than inequality
  662:     or equality elementwise.
  663: DataFrame.gt : Compare DataFrames for strictly greater than
  664:     inequality elementwise.
  665: 
  666: Notes
  667: -----
  668: Mismatched indices will be unioned together.
  669: `NaN` values are considered different (i.e. `NaN` != `NaN`).
  670: 
  671: Examples
  672: --------
  673: >>> df = pd.DataFrame({{'cost': [250, 150, 100],
  674: ...                    'revenue': [100, 250, 300]}},
  675: ...                   index=['A', 'B', 'C'])
  676: >>> df
  677:    cost  revenue
  678: A   250      100
  679: B   150      250
  680: C   100      300
  681: 
  682: Comparison with a scalar, using either the operator or method:
  683: 
  684: >>> df == 100
  685:     cost  revenue
  686: A  False     True
  687: B  False    False
  688: C   True    False
  689: 
  690: >>> df.eq(100)
  691:     cost  revenue
  692: A  False     True
  693: B  False    False
  694: C   True    False
  695: 
  696: When `other` is a :class:`Series`, the columns of a DataFrame are aligned
  697: with the index of `other` and broadcast:
  698: 
  699: >>> df != pd.Series([100, 250], index=["cost", "revenue"])
  700:     cost  revenue
  701: A   True     True
  702: B   True    False
  703: C  False     True
  704: 
  705: Use the method to control the broadcast axis:
  706: 
  707: >>> df.ne(pd.Series([100, 300], index=["A", "D"]), axis='index')
  708:    cost  revenue
  709: A  True    False
  710: B  True     True
  711: C  True     True
  712: D  True     True
  713: 
  714: When comparing to an arbitrary sequence, the number of columns must
  715: match the number elements in `other`:
  716: 
  717: >>> df == [250, 100]
  718:     cost  revenue
  719: A   True     True
  720: B  False    False
  721: C  False    False
  722: 
  723: Use the method to control the axis:
  724: 
  725: >>> df.eq([250, 250, 100], axis='index')
  726:     cost  revenue
  727: A   True    False
  728: B  False     True
  729: C   True    False
  730: 
  731: Compare to a DataFrame of different shape.
  732: 
  733: >>> other = pd.DataFrame({{'revenue': [300, 250, 100, 150]}},
  734: ...                      index=['A', 'B', 'C', 'D'])
  735: >>> other
  736:    revenue
  737: A      300
  738: B      250
  739: C      100
  740: D      150
  741: 
  742: >>> df.gt(other)
  743:     cost  revenue
  744: A  False    False
  745: B  False    False
  746: C  False     True
  747: D  False    False
  748: 
  749: Compare to a MultiIndex by level.
  750: 
  751: >>> df_multindex = pd.DataFrame({{'cost': [250, 150, 100, 150, 300, 220],
  752: ...                              'revenue': [100, 250, 300, 200, 175, 225]}},
  753: ...                             index=[['Q1', 'Q1', 'Q1', 'Q2', 'Q2', 'Q2'],
  754: ...                                    ['A', 'B', 'C', 'A', 'B', 'C']])
  755: >>> df_multindex
  756:       cost  revenue
  757: Q1 A   250      100
  758:    B   150      250
  759:    C   100      300
  760: Q2 A   150      200
  761:    B   300      175
  762:    C   220      225
  763: 
  764: >>> df.le(df_multindex, level=1)
  765:        cost  revenue
  766: Q1 A   True     True
  767:    B   True     True
  768:    C   True     True
  769: Q2 A  False     True
  770:    B   True    False
  771:    C   True    False
  772: """
