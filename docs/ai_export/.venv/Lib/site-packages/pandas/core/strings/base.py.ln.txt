    1: from __future__ import annotations
    2: 
    3: import abc
    4: from typing import (
    5:     TYPE_CHECKING,
    6:     Callable,
    7:     Literal,
    8: )
    9: 
   10: import numpy as np
   11: 
   12: if TYPE_CHECKING:
   13:     from collections.abc import Sequence
   14:     import re
   15: 
   16:     from pandas._typing import Scalar
   17: 
   18:     from pandas import Series
   19: 
   20: 
   21: class BaseStringArrayMethods(abc.ABC):
   22:     """
   23:     Base class for extension arrays implementing string methods.
   24: 
   25:     This is where our ExtensionArrays can override the implementation of
   26:     Series.str.<method>. We don't expect this to work with
   27:     3rd-party extension arrays.
   28: 
   29:     * User calls Series.str.<method>
   30:     * pandas extracts the extension array from the Series
   31:     * pandas calls ``extension_array._str_<method>(*args, **kwargs)``
   32:     * pandas wraps the result, to return to the user.
   33: 
   34:     See :ref:`Series.str` for the docstring of each method.
   35:     """
   36: 
   37:     def _str_getitem(self, key):
   38:         if isinstance(key, slice):
   39:             return self._str_slice(start=key.start, stop=key.stop, step=key.step)
   40:         else:
   41:             return self._str_get(key)
   42: 
   43:     @abc.abstractmethod
   44:     def _str_count(self, pat, flags: int = 0):
   45:         pass
   46: 
   47:     @abc.abstractmethod
   48:     def _str_pad(
   49:         self,
   50:         width: int,
   51:         side: Literal["left", "right", "both"] = "left",
   52:         fillchar: str = " ",
   53:     ):
   54:         pass
   55: 
   56:     @abc.abstractmethod
   57:     def _str_contains(
   58:         self, pat, case: bool = True, flags: int = 0, na=None, regex: bool = True
   59:     ):
   60:         pass
   61: 
   62:     @abc.abstractmethod
   63:     def _str_startswith(self, pat, na=None):
   64:         pass
   65: 
   66:     @abc.abstractmethod
   67:     def _str_endswith(self, pat, na=None):
   68:         pass
   69: 
   70:     @abc.abstractmethod
   71:     def _str_replace(
   72:         self,
   73:         pat: str | re.Pattern,
   74:         repl: str | Callable,
   75:         n: int = -1,
   76:         case: bool = True,
   77:         flags: int = 0,
   78:         regex: bool = True,
   79:     ):
   80:         pass
   81: 
   82:     @abc.abstractmethod
   83:     def _str_repeat(self, repeats: int | Sequence[int]):
   84:         pass
   85: 
   86:     @abc.abstractmethod
   87:     def _str_match(
   88:         self, pat: str, case: bool = True, flags: int = 0, na: Scalar = np.nan
   89:     ):
   90:         pass
   91: 
   92:     @abc.abstractmethod
   93:     def _str_fullmatch(
   94:         self,
   95:         pat: str | re.Pattern,
   96:         case: bool = True,
   97:         flags: int = 0,
   98:         na: Scalar = np.nan,
   99:     ):
  100:         pass
  101: 
  102:     @abc.abstractmethod
  103:     def _str_encode(self, encoding, errors: str = "strict"):
  104:         pass
  105: 
  106:     @abc.abstractmethod
  107:     def _str_find(self, sub, start: int = 0, end=None):
  108:         pass
  109: 
  110:     @abc.abstractmethod
  111:     def _str_rfind(self, sub, start: int = 0, end=None):
  112:         pass
  113: 
  114:     @abc.abstractmethod
  115:     def _str_findall(self, pat, flags: int = 0):
  116:         pass
  117: 
  118:     @abc.abstractmethod
  119:     def _str_get(self, i):
  120:         pass
  121: 
  122:     @abc.abstractmethod
  123:     def _str_index(self, sub, start: int = 0, end=None):
  124:         pass
  125: 
  126:     @abc.abstractmethod
  127:     def _str_rindex(self, sub, start: int = 0, end=None):
  128:         pass
  129: 
  130:     @abc.abstractmethod
  131:     def _str_join(self, sep: str):
  132:         pass
  133: 
  134:     @abc.abstractmethod
  135:     def _str_partition(self, sep: str, expand):
  136:         pass
  137: 
  138:     @abc.abstractmethod
  139:     def _str_rpartition(self, sep: str, expand):
  140:         pass
  141: 
  142:     @abc.abstractmethod
  143:     def _str_len(self):
  144:         pass
  145: 
  146:     @abc.abstractmethod
  147:     def _str_slice(self, start=None, stop=None, step=None):
  148:         pass
  149: 
  150:     @abc.abstractmethod
  151:     def _str_slice_replace(self, start=None, stop=None, repl=None):
  152:         pass
  153: 
  154:     @abc.abstractmethod
  155:     def _str_translate(self, table):
  156:         pass
  157: 
  158:     @abc.abstractmethod
  159:     def _str_wrap(self, width: int, **kwargs):
  160:         pass
  161: 
  162:     @abc.abstractmethod
  163:     def _str_get_dummies(self, sep: str = "|"):
  164:         pass
  165: 
  166:     @abc.abstractmethod
  167:     def _str_isalnum(self):
  168:         pass
  169: 
  170:     @abc.abstractmethod
  171:     def _str_isalpha(self):
  172:         pass
  173: 
  174:     @abc.abstractmethod
  175:     def _str_isdecimal(self):
  176:         pass
  177: 
  178:     @abc.abstractmethod
  179:     def _str_isdigit(self):
  180:         pass
  181: 
  182:     @abc.abstractmethod
  183:     def _str_islower(self):
  184:         pass
  185: 
  186:     @abc.abstractmethod
  187:     def _str_isnumeric(self):
  188:         pass
  189: 
  190:     @abc.abstractmethod
  191:     def _str_isspace(self):
  192:         pass
  193: 
  194:     @abc.abstractmethod
  195:     def _str_istitle(self):
  196:         pass
  197: 
  198:     @abc.abstractmethod
  199:     def _str_isupper(self):
  200:         pass
  201: 
  202:     @abc.abstractmethod
  203:     def _str_capitalize(self):
  204:         pass
  205: 
  206:     @abc.abstractmethod
  207:     def _str_casefold(self):
  208:         pass
  209: 
  210:     @abc.abstractmethod
  211:     def _str_title(self):
  212:         pass
  213: 
  214:     @abc.abstractmethod
  215:     def _str_swapcase(self):
  216:         pass
  217: 
  218:     @abc.abstractmethod
  219:     def _str_lower(self):
  220:         pass
  221: 
  222:     @abc.abstractmethod
  223:     def _str_upper(self):
  224:         pass
  225: 
  226:     @abc.abstractmethod
  227:     def _str_normalize(self, form):
  228:         pass
  229: 
  230:     @abc.abstractmethod
  231:     def _str_strip(self, to_strip=None):
  232:         pass
  233: 
  234:     @abc.abstractmethod
  235:     def _str_lstrip(self, to_strip=None):
  236:         pass
  237: 
  238:     @abc.abstractmethod
  239:     def _str_rstrip(self, to_strip=None):
  240:         pass
  241: 
  242:     @abc.abstractmethod
  243:     def _str_removeprefix(self, prefix: str) -> Series:
  244:         pass
  245: 
  246:     @abc.abstractmethod
  247:     def _str_removesuffix(self, suffix: str) -> Series:
  248:         pass
  249: 
  250:     @abc.abstractmethod
  251:     def _str_split(
  252:         self, pat=None, n=-1, expand: bool = False, regex: bool | None = None
  253:     ):
  254:         pass
  255: 
  256:     @abc.abstractmethod
  257:     def _str_rsplit(self, pat=None, n=-1):
  258:         pass
  259: 
  260:     @abc.abstractmethod
  261:     def _str_extract(self, pat: str, flags: int = 0, expand: bool = True):
  262:         pass
