    1: """
    2: Numba 1D var kernels that can be shared by
    3: * Dataframe / Series
    4: * groupby
    5: * rolling / expanding
    6: 
    7: Mirrors pandas/_libs/window/aggregation.pyx
    8: """
    9: from __future__ import annotations
   10: 
   11: from typing import TYPE_CHECKING
   12: 
   13: import numba
   14: import numpy as np
   15: 
   16: if TYPE_CHECKING:
   17:     from pandas._typing import npt
   18: 
   19: from pandas.core._numba.kernels.shared import is_monotonic_increasing
   20: 
   21: 
   22: @numba.jit(nopython=True, nogil=True, parallel=False)
   23: def add_var(
   24:     val: float,
   25:     nobs: int,
   26:     mean_x: float,
   27:     ssqdm_x: float,
   28:     compensation: float,
   29:     num_consecutive_same_value: int,
   30:     prev_value: float,
   31: ) -> tuple[int, float, float, float, int, float]:
   32:     if not np.isnan(val):
   33:         if val == prev_value:
   34:             num_consecutive_same_value += 1
   35:         else:
   36:             num_consecutive_same_value = 1
   37:         prev_value = val
   38: 
   39:         nobs += 1
   40:         prev_mean = mean_x - compensation
   41:         y = val - compensation
   42:         t = y - mean_x
   43:         compensation = t + mean_x - y
   44:         delta = t
   45:         if nobs:
   46:             mean_x += delta / nobs
   47:         else:
   48:             mean_x = 0
   49:         ssqdm_x += (val - prev_mean) * (val - mean_x)
   50:     return nobs, mean_x, ssqdm_x, compensation, num_consecutive_same_value, prev_value
   51: 
   52: 
   53: @numba.jit(nopython=True, nogil=True, parallel=False)
   54: def remove_var(
   55:     val: float, nobs: int, mean_x: float, ssqdm_x: float, compensation: float
   56: ) -> tuple[int, float, float, float]:
   57:     if not np.isnan(val):
   58:         nobs -= 1
   59:         if nobs:
   60:             prev_mean = mean_x - compensation
   61:             y = val - compensation
   62:             t = y - mean_x
   63:             compensation = t + mean_x - y
   64:             delta = t
   65:             mean_x -= delta / nobs
   66:             ssqdm_x -= (val - prev_mean) * (val - mean_x)
   67:         else:
   68:             mean_x = 0
   69:             ssqdm_x = 0
   70:     return nobs, mean_x, ssqdm_x, compensation
   71: 
   72: 
   73: @numba.jit(nopython=True, nogil=True, parallel=False)
   74: def sliding_var(
   75:     values: np.ndarray,
   76:     result_dtype: np.dtype,
   77:     start: np.ndarray,
   78:     end: np.ndarray,
   79:     min_periods: int,
   80:     ddof: int = 1,
   81: ) -> tuple[np.ndarray, list[int]]:
   82:     N = len(start)
   83:     nobs = 0
   84:     mean_x = 0.0
   85:     ssqdm_x = 0.0
   86:     compensation_add = 0.0
   87:     compensation_remove = 0.0
   88: 
   89:     min_periods = max(min_periods, 1)
   90:     is_monotonic_increasing_bounds = is_monotonic_increasing(
   91:         start
   92:     ) and is_monotonic_increasing(end)
   93: 
   94:     output = np.empty(N, dtype=result_dtype)
   95: 
   96:     for i in range(N):
   97:         s = start[i]
   98:         e = end[i]
   99:         if i == 0 or not is_monotonic_increasing_bounds:
  100:             prev_value = values[s]
  101:             num_consecutive_same_value = 0
  102: 
  103:             for j in range(s, e):
  104:                 val = values[j]
  105:                 (
  106:                     nobs,
  107:                     mean_x,
  108:                     ssqdm_x,
  109:                     compensation_add,
  110:                     num_consecutive_same_value,
  111:                     prev_value,
  112:                 ) = add_var(
  113:                     val,
  114:                     nobs,
  115:                     mean_x,
  116:                     ssqdm_x,
  117:                     compensation_add,
  118:                     num_consecutive_same_value,
  119:                     prev_value,
  120:                 )
  121:         else:
  122:             for j in range(start[i - 1], s):
  123:                 val = values[j]
  124:                 nobs, mean_x, ssqdm_x, compensation_remove = remove_var(
  125:                     val, nobs, mean_x, ssqdm_x, compensation_remove
  126:                 )
  127: 
  128:             for j in range(end[i - 1], e):
  129:                 val = values[j]
  130:                 (
  131:                     nobs,
  132:                     mean_x,
  133:                     ssqdm_x,
  134:                     compensation_add,
  135:                     num_consecutive_same_value,
  136:                     prev_value,
  137:                 ) = add_var(
  138:                     val,
  139:                     nobs,
  140:                     mean_x,
  141:                     ssqdm_x,
  142:                     compensation_add,
  143:                     num_consecutive_same_value,
  144:                     prev_value,
  145:                 )
  146: 
  147:         if nobs >= min_periods and nobs > ddof:
  148:             if nobs == 1 or num_consecutive_same_value >= nobs:
  149:                 result = 0.0
  150:             else:
  151:                 result = ssqdm_x / (nobs - ddof)
  152:         else:
  153:             result = np.nan
  154: 
  155:         output[i] = result
  156: 
  157:         if not is_monotonic_increasing_bounds:
  158:             nobs = 0
  159:             mean_x = 0.0
  160:             ssqdm_x = 0.0
  161:             compensation_remove = 0.0
  162: 
  163:     # na_position is empty list since float64 can already hold nans
  164:     # Do list comprehension, since numba cannot figure out that na_pos is
  165:     # empty list of ints on its own
  166:     na_pos = [0 for i in range(0)]
  167:     return output, na_pos
  168: 
  169: 
  170: @numba.jit(nopython=True, nogil=True, parallel=False)
  171: def grouped_var(
  172:     values: np.ndarray,
  173:     result_dtype: np.dtype,
  174:     labels: npt.NDArray[np.intp],
  175:     ngroups: int,
  176:     min_periods: int,
  177:     ddof: int = 1,
  178: ) -> tuple[np.ndarray, list[int]]:
  179:     N = len(labels)
  180: 
  181:     nobs_arr = np.zeros(ngroups, dtype=np.int64)
  182:     comp_arr = np.zeros(ngroups, dtype=values.dtype)
  183:     consecutive_counts = np.zeros(ngroups, dtype=np.int64)
  184:     prev_vals = np.zeros(ngroups, dtype=values.dtype)
  185:     output = np.zeros(ngroups, dtype=result_dtype)
  186:     means = np.zeros(ngroups, dtype=result_dtype)
  187: 
  188:     for i in range(N):
  189:         lab = labels[i]
  190:         val = values[i]
  191: 
  192:         if lab < 0:
  193:             continue
  194: 
  195:         mean_x = means[lab]
  196:         ssqdm_x = output[lab]
  197:         nobs = nobs_arr[lab]
  198:         compensation_add = comp_arr[lab]
  199:         num_consecutive_same_value = consecutive_counts[lab]
  200:         prev_value = prev_vals[lab]
  201: 
  202:         (
  203:             nobs,
  204:             mean_x,
  205:             ssqdm_x,
  206:             compensation_add,
  207:             num_consecutive_same_value,
  208:             prev_value,
  209:         ) = add_var(
  210:             val,
  211:             nobs,
  212:             mean_x,
  213:             ssqdm_x,
  214:             compensation_add,
  215:             num_consecutive_same_value,
  216:             prev_value,
  217:         )
  218: 
  219:         output[lab] = ssqdm_x
  220:         means[lab] = mean_x
  221:         consecutive_counts[lab] = num_consecutive_same_value
  222:         prev_vals[lab] = prev_value
  223:         comp_arr[lab] = compensation_add
  224:         nobs_arr[lab] = nobs
  225: 
  226:     # Post-processing, replace vars that don't satisfy min_periods
  227:     for lab in range(ngroups):
  228:         nobs = nobs_arr[lab]
  229:         num_consecutive_same_value = consecutive_counts[lab]
  230:         ssqdm_x = output[lab]
  231:         if nobs >= min_periods and nobs > ddof:
  232:             if nobs == 1 or num_consecutive_same_value >= nobs:
  233:                 result = 0.0
  234:             else:
  235:                 result = ssqdm_x / (nobs - ddof)
  236:         else:
  237:             result = np.nan
  238:         output[lab] = result
  239: 
  240:     # Second pass to get the std.dev
  241:     # na_position is empty list since float64 can already hold nans
  242:     # Do list comprehension, since numba cannot figure out that na_pos is
  243:     # empty list of ints on its own
  244:     na_pos = [0 for i in range(0)]
  245:     return output, na_pos
