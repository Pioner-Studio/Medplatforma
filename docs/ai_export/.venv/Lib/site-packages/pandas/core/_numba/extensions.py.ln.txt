    1: # Disable type checking for this module since numba's internals
    2: # are not typed, and we use numba's internals via its extension API
    3: # mypy: ignore-errors
    4: """
    5: Utility classes/functions to let numba recognize
    6: pandas Index/Series/DataFrame
    7: 
    8: Mostly vendored from https://github.com/numba/numba/blob/main/numba/tests/pdlike_usecase.py
    9: """
   10: 
   11: from __future__ import annotations
   12: 
   13: from contextlib import contextmanager
   14: import operator
   15: 
   16: import numba
   17: from numba import types
   18: from numba.core import cgutils
   19: from numba.core.datamodel import models
   20: from numba.core.extending import (
   21:     NativeValue,
   22:     box,
   23:     lower_builtin,
   24:     make_attribute_wrapper,
   25:     overload,
   26:     overload_attribute,
   27:     overload_method,
   28:     register_model,
   29:     type_callable,
   30:     typeof_impl,
   31:     unbox,
   32: )
   33: from numba.core.imputils import impl_ret_borrowed
   34: import numpy as np
   35: 
   36: from pandas._libs import lib
   37: 
   38: from pandas.core.indexes.base import Index
   39: from pandas.core.indexing import _iLocIndexer
   40: from pandas.core.internals import SingleBlockManager
   41: from pandas.core.series import Series
   42: 
   43: 
   44: # Helper function to hack around fact that Index casts numpy string dtype to object
   45: #
   46: # Idea is to set an attribute on a Index called _numba_data
   47: # that is the original data, or the object data casted to numpy string dtype,
   48: # with a context manager that is unset afterwards
   49: @contextmanager
   50: def set_numba_data(index: Index):
   51:     numba_data = index._data
   52:     if numba_data.dtype == object:
   53:         if not lib.is_string_array(numba_data):
   54:             raise ValueError(
   55:                 "The numba engine only supports using string or numeric column names"
   56:             )
   57:         numba_data = numba_data.astype("U")
   58:     try:
   59:         index._numba_data = numba_data
   60:         yield index
   61:     finally:
   62:         del index._numba_data
   63: 
   64: 
   65: # TODO: Range index support
   66: # (this currently lowers OK, but does not round-trip)
   67: class IndexType(types.Type):
   68:     """
   69:     The type class for Index objects.
   70:     """
   71: 
   72:     def __init__(self, dtype, layout, pyclass: any) -> None:
   73:         self.pyclass = pyclass
   74:         name = f"index({dtype}, {layout})"
   75:         self.dtype = dtype
   76:         self.layout = layout
   77:         super().__init__(name)
   78: 
   79:     @property
   80:     def key(self):
   81:         return self.pyclass, self.dtype, self.layout
   82: 
   83:     @property
   84:     def as_array(self):
   85:         return types.Array(self.dtype, 1, self.layout)
   86: 
   87:     def copy(self, dtype=None, ndim: int = 1, layout=None):
   88:         assert ndim == 1
   89:         if dtype is None:
   90:             dtype = self.dtype
   91:         layout = layout or self.layout
   92:         return type(self)(dtype, layout, self.pyclass)
   93: 
   94: 
   95: class SeriesType(types.Type):
   96:     """
   97:     The type class for Series objects.
   98:     """
   99: 
  100:     def __init__(self, dtype, index, namety) -> None:
  101:         assert isinstance(index, IndexType)
  102:         self.dtype = dtype
  103:         self.index = index
  104:         self.values = types.Array(self.dtype, 1, "C")
  105:         self.namety = namety
  106:         name = f"series({dtype}, {index}, {namety})"
  107:         super().__init__(name)
  108: 
  109:     @property
  110:     def key(self):
  111:         return self.dtype, self.index, self.namety
  112: 
  113:     @property
  114:     def as_array(self):
  115:         return self.values
  116: 
  117:     def copy(self, dtype=None, ndim: int = 1, layout: str = "C"):
  118:         assert ndim == 1
  119:         assert layout == "C"
  120:         if dtype is None:
  121:             dtype = self.dtype
  122:         return type(self)(dtype, self.index, self.namety)
  123: 
  124: 
  125: @typeof_impl.register(Index)
  126: def typeof_index(val, c):
  127:     """
  128:     This will assume that only strings are in object dtype
  129:     index.
  130:     (you should check this before this gets lowered down to numba)
  131:     """
  132:     # arrty = typeof_impl(val._data, c)
  133:     arrty = typeof_impl(val._numba_data, c)
  134:     assert arrty.ndim == 1
  135:     return IndexType(arrty.dtype, arrty.layout, type(val))
  136: 
  137: 
  138: @typeof_impl.register(Series)
  139: def typeof_series(val, c):
  140:     index = typeof_impl(val.index, c)
  141:     arrty = typeof_impl(val.values, c)
  142:     namety = typeof_impl(val.name, c)
  143:     assert arrty.ndim == 1
  144:     assert arrty.layout == "C"
  145:     return SeriesType(arrty.dtype, index, namety)
  146: 
  147: 
  148: @type_callable(Series)
  149: def type_series_constructor(context):
  150:     def typer(data, index, name=None):
  151:         if isinstance(index, IndexType) and isinstance(data, types.Array):
  152:             assert data.ndim == 1
  153:             if name is None:
  154:                 name = types.intp
  155:             return SeriesType(data.dtype, index, name)
  156: 
  157:     return typer
  158: 
  159: 
  160: @type_callable(Index)
  161: def type_index_constructor(context):
  162:     def typer(data, hashmap=None):
  163:         if isinstance(data, types.Array):
  164:             assert data.layout == "C"
  165:             assert data.ndim == 1
  166:             assert hashmap is None or isinstance(hashmap, types.DictType)
  167:             return IndexType(data.dtype, layout=data.layout, pyclass=Index)
  168: 
  169:     return typer
  170: 
  171: 
  172: # Backend extensions for Index and Series and Frame
  173: @register_model(IndexType)
  174: class IndexModel(models.StructModel):
  175:     def __init__(self, dmm, fe_type) -> None:
  176:         # We don't want the numpy string scalar type in our hashmap
  177:         members = [
  178:             ("data", fe_type.as_array),
  179:             # This is an attempt to emulate our hashtable code with a numba
  180:             # typed dict
  181:             # It maps from values in the index to their integer positions in the array
  182:             ("hashmap", types.DictType(fe_type.dtype, types.intp)),
  183:             # Pointer to the Index object this was created from, or that it
  184:             # boxes to
  185:             # https://numba.discourse.group/t/qst-how-to-cache-the-boxing-of-an-object/2128/2?u=lithomas1
  186:             ("parent", types.pyobject),
  187:         ]
  188:         models.StructModel.__init__(self, dmm, fe_type, members)
  189: 
  190: 
  191: @register_model(SeriesType)
  192: class SeriesModel(models.StructModel):
  193:     def __init__(self, dmm, fe_type) -> None:
  194:         members = [
  195:             ("index", fe_type.index),
  196:             ("values", fe_type.as_array),
  197:             ("name", fe_type.namety),
  198:         ]
  199:         models.StructModel.__init__(self, dmm, fe_type, members)
  200: 
  201: 
  202: make_attribute_wrapper(IndexType, "data", "_data")
  203: make_attribute_wrapper(IndexType, "hashmap", "hashmap")
  204: 
  205: make_attribute_wrapper(SeriesType, "index", "index")
  206: make_attribute_wrapper(SeriesType, "values", "values")
  207: make_attribute_wrapper(SeriesType, "name", "name")
  208: 
  209: 
  210: @lower_builtin(Series, types.Array, IndexType)
  211: def pdseries_constructor(context, builder, sig, args):
  212:     data, index = args
  213:     series = cgutils.create_struct_proxy(sig.return_type)(context, builder)
  214:     series.index = index
  215:     series.values = data
  216:     series.name = context.get_constant(types.intp, 0)
  217:     return impl_ret_borrowed(context, builder, sig.return_type, series._getvalue())
  218: 
  219: 
  220: @lower_builtin(Series, types.Array, IndexType, types.intp)
  221: @lower_builtin(Series, types.Array, IndexType, types.float64)
  222: @lower_builtin(Series, types.Array, IndexType, types.unicode_type)
  223: def pdseries_constructor_with_name(context, builder, sig, args):
  224:     data, index, name = args
  225:     series = cgutils.create_struct_proxy(sig.return_type)(context, builder)
  226:     series.index = index
  227:     series.values = data
  228:     series.name = name
  229:     return impl_ret_borrowed(context, builder, sig.return_type, series._getvalue())
  230: 
  231: 
  232: @lower_builtin(Index, types.Array, types.DictType, types.pyobject)
  233: def index_constructor_2arg(context, builder, sig, args):
  234:     (data, hashmap, parent) = args
  235:     index = cgutils.create_struct_proxy(sig.return_type)(context, builder)
  236: 
  237:     index.data = data
  238:     index.hashmap = hashmap
  239:     index.parent = parent
  240:     return impl_ret_borrowed(context, builder, sig.return_type, index._getvalue())
  241: 
  242: 
  243: @lower_builtin(Index, types.Array, types.DictType)
  244: def index_constructor_2arg_parent(context, builder, sig, args):
  245:     # Basically same as index_constructor_1arg, but also lets you specify the
  246:     # parent object
  247:     (data, hashmap) = args
  248:     index = cgutils.create_struct_proxy(sig.return_type)(context, builder)
  249: 
  250:     index.data = data
  251:     index.hashmap = hashmap
  252:     return impl_ret_borrowed(context, builder, sig.return_type, index._getvalue())
  253: 
  254: 
  255: @lower_builtin(Index, types.Array)
  256: def index_constructor_1arg(context, builder, sig, args):
  257:     from numba.typed import Dict
  258: 
  259:     key_type = sig.return_type.dtype
  260:     value_type = types.intp
  261: 
  262:     def index_impl(data):
  263:         return Index(data, Dict.empty(key_type, value_type))
  264: 
  265:     return context.compile_internal(builder, index_impl, sig, args)
  266: 
  267: 
  268: # Helper to convert the unicodecharseq (numpy string scalar) into a unicode_type
  269: # (regular string)
  270: def maybe_cast_str(x):
  271:     # Dummy function that numba can overload
  272:     pass
  273: 
  274: 
  275: @overload(maybe_cast_str)
  276: def maybe_cast_str_impl(x):
  277:     """Converts numba UnicodeCharSeq (numpy string scalar) -> unicode type (string).
  278:     Is a no-op for other types."""
  279:     if isinstance(x, types.UnicodeCharSeq):
  280:         return lambda x: str(x)
  281:     else:
  282:         return lambda x: x
  283: 
  284: 
  285: @unbox(IndexType)
  286: def unbox_index(typ, obj, c):
  287:     """
  288:     Convert a Index object to a native structure.
  289: 
  290:     Note: Object dtype is not allowed here
  291:     """
  292:     data_obj = c.pyapi.object_getattr_string(obj, "_numba_data")
  293:     index = cgutils.create_struct_proxy(typ)(c.context, c.builder)
  294:     # If we see an object array, assume its been validated as only containing strings
  295:     # We still need to do the conversion though
  296:     index.data = c.unbox(typ.as_array, data_obj).value
  297:     typed_dict_obj = c.pyapi.unserialize(c.pyapi.serialize_object(numba.typed.Dict))
  298:     # Create an empty typed dict in numba for the hashmap for indexing
  299:     # equiv of numba.typed.Dict.empty(typ.dtype, types.intp)
  300:     arr_type_obj = c.pyapi.unserialize(c.pyapi.serialize_object(typ.dtype))
  301:     intp_type_obj = c.pyapi.unserialize(c.pyapi.serialize_object(types.intp))
  302:     hashmap_obj = c.pyapi.call_method(
  303:         typed_dict_obj, "empty", (arr_type_obj, intp_type_obj)
  304:     )
  305:     index.hashmap = c.unbox(types.DictType(typ.dtype, types.intp), hashmap_obj).value
  306:     # Set the parent for speedy boxing.
  307:     index.parent = obj
  308: 
  309:     # Decrefs
  310:     c.pyapi.decref(data_obj)
  311:     c.pyapi.decref(arr_type_obj)
  312:     c.pyapi.decref(intp_type_obj)
  313:     c.pyapi.decref(typed_dict_obj)
  314: 
  315:     return NativeValue(index._getvalue())
  316: 
  317: 
  318: @unbox(SeriesType)
  319: def unbox_series(typ, obj, c):
  320:     """
  321:     Convert a Series object to a native structure.
  322:     """
  323:     index_obj = c.pyapi.object_getattr_string(obj, "index")
  324:     values_obj = c.pyapi.object_getattr_string(obj, "values")
  325:     name_obj = c.pyapi.object_getattr_string(obj, "name")
  326: 
  327:     series = cgutils.create_struct_proxy(typ)(c.context, c.builder)
  328:     series.index = c.unbox(typ.index, index_obj).value
  329:     series.values = c.unbox(typ.values, values_obj).value
  330:     series.name = c.unbox(typ.namety, name_obj).value
  331: 
  332:     # Decrefs
  333:     c.pyapi.decref(index_obj)
  334:     c.pyapi.decref(values_obj)
  335:     c.pyapi.decref(name_obj)
  336: 
  337:     return NativeValue(series._getvalue())
  338: 
  339: 
  340: @box(IndexType)
  341: def box_index(typ, val, c):
  342:     """
  343:     Convert a native index structure to a Index object.
  344: 
  345:     If our native index is of a numpy string dtype, we'll cast it to
  346:     object.
  347:     """
  348:     # First build a Numpy array object, then wrap it in a Index
  349:     index = cgutils.create_struct_proxy(typ)(c.context, c.builder, value=val)
  350: 
  351:     res = cgutils.alloca_once_value(c.builder, index.parent)
  352: 
  353:     # Does parent exist?
  354:     # (it means already boxed once, or Index same as original df.index or df.columns)
  355:     # xref https://github.com/numba/numba/blob/596e8a55334cc46854e3192766e643767bd7c934/numba/core/boxing.py#L593C17-L593C17
  356:     with c.builder.if_else(cgutils.is_not_null(c.builder, index.parent)) as (
  357:         has_parent,
  358:         otherwise,
  359:     ):
  360:         with has_parent:
  361:             c.pyapi.incref(index.parent)
  362:         with otherwise:
  363:             # TODO: preserve the original class for the index
  364:             # Also need preserve the name of the Index
  365:             # class_obj = c.pyapi.unserialize(c.pyapi.serialize_object(typ.pyclass))
  366:             class_obj = c.pyapi.unserialize(c.pyapi.serialize_object(Index))
  367:             array_obj = c.box(typ.as_array, index.data)
  368:             if isinstance(typ.dtype, types.UnicodeCharSeq):
  369:                 # We converted to numpy string dtype, convert back
  370:                 # to object since _simple_new won't do that for uss
  371:                 object_str_obj = c.pyapi.unserialize(c.pyapi.serialize_object("object"))
  372:                 array_obj = c.pyapi.call_method(array_obj, "astype", (object_str_obj,))
  373:                 c.pyapi.decref(object_str_obj)
  374:             # this is basically Index._simple_new(array_obj, name_obj) in python
  375:             index_obj = c.pyapi.call_method(class_obj, "_simple_new", (array_obj,))
  376:             index.parent = index_obj
  377:             c.builder.store(index_obj, res)
  378: 
  379:             # Decrefs
  380:             c.pyapi.decref(class_obj)
  381:             c.pyapi.decref(array_obj)
  382:     return c.builder.load(res)
  383: 
  384: 
  385: @box(SeriesType)
  386: def box_series(typ, val, c):
  387:     """
  388:     Convert a native series structure to a Series object.
  389:     """
  390:     series = cgutils.create_struct_proxy(typ)(c.context, c.builder, value=val)
  391:     series_const_obj = c.pyapi.unserialize(c.pyapi.serialize_object(Series._from_mgr))
  392:     mgr_const_obj = c.pyapi.unserialize(
  393:         c.pyapi.serialize_object(SingleBlockManager.from_array)
  394:     )
  395:     index_obj = c.box(typ.index, series.index)
  396:     array_obj = c.box(typ.as_array, series.values)
  397:     name_obj = c.box(typ.namety, series.name)
  398:     # This is basically equivalent of
  399:     # pd.Series(data=array_obj, index=index_obj)
  400:     # To improve perf, we will construct the Series from a manager
  401:     # object to avoid checks.
  402:     # We'll also set the name attribute manually to avoid validation
  403:     mgr_obj = c.pyapi.call_function_objargs(
  404:         mgr_const_obj,
  405:         (
  406:             array_obj,
  407:             index_obj,
  408:         ),
  409:     )
  410:     mgr_axes_obj = c.pyapi.object_getattr_string(mgr_obj, "axes")
  411:     # Series._constructor_from_mgr(mgr, axes)
  412:     series_obj = c.pyapi.call_function_objargs(
  413:         series_const_obj, (mgr_obj, mgr_axes_obj)
  414:     )
  415:     c.pyapi.object_setattr_string(series_obj, "_name", name_obj)
  416: 
  417:     # Decrefs
  418:     c.pyapi.decref(series_const_obj)
  419:     c.pyapi.decref(mgr_axes_obj)
  420:     c.pyapi.decref(mgr_obj)
  421:     c.pyapi.decref(mgr_const_obj)
  422:     c.pyapi.decref(index_obj)
  423:     c.pyapi.decref(array_obj)
  424:     c.pyapi.decref(name_obj)
  425: 
  426:     return series_obj
  427: 
  428: 
  429: # Add common series reductions (e.g. mean, sum),
  430: # and also add common binops (e.g. add, sub, mul, div)
  431: def generate_series_reduction(ser_reduction, ser_method):
  432:     @overload_method(SeriesType, ser_reduction)
  433:     def series_reduction(series):
  434:         def series_reduction_impl(series):
  435:             return ser_method(series.values)
  436: 
  437:         return series_reduction_impl
  438: 
  439:     return series_reduction
  440: 
  441: 
  442: def generate_series_binop(binop):
  443:     @overload(binop)
  444:     def series_binop(series1, value):
  445:         if isinstance(series1, SeriesType):
  446:             if isinstance(value, SeriesType):
  447: 
  448:                 def series_binop_impl(series1, series2):
  449:                     # TODO: Check index matching?
  450:                     return Series(
  451:                         binop(series1.values, series2.values),
  452:                         series1.index,
  453:                         series1.name,
  454:                     )
  455: 
  456:                 return series_binop_impl
  457:             else:
  458: 
  459:                 def series_binop_impl(series1, value):
  460:                     return Series(
  461:                         binop(series1.values, value), series1.index, series1.name
  462:                     )
  463: 
  464:                 return series_binop_impl
  465: 
  466:     return series_binop
  467: 
  468: 
  469: series_reductions = [
  470:     ("sum", np.sum),
  471:     ("mean", np.mean),
  472:     # Disabled due to discrepancies between numba std. dev
  473:     # and pandas std. dev (no way to specify dof)
  474:     # ("std", np.std),
  475:     # ("var", np.var),
  476:     ("min", np.min),
  477:     ("max", np.max),
  478: ]
  479: for reduction, reduction_method in series_reductions:
  480:     generate_series_reduction(reduction, reduction_method)
  481: 
  482: series_binops = [operator.add, operator.sub, operator.mul, operator.truediv]
  483: 
  484: for ser_binop in series_binops:
  485:     generate_series_binop(ser_binop)
  486: 
  487: 
  488: # get_loc on Index
  489: @overload_method(IndexType, "get_loc")
  490: def index_get_loc(index, item):
  491:     def index_get_loc_impl(index, item):
  492:         # Initialize the hash table if not initialized
  493:         if len(index.hashmap) == 0:
  494:             for i, val in enumerate(index._data):
  495:                 index.hashmap[val] = i
  496:         return index.hashmap[item]
  497: 
  498:     return index_get_loc_impl
  499: 
  500: 
  501: # Indexing for Series/Index
  502: @overload(operator.getitem)
  503: def series_indexing(series, item):
  504:     if isinstance(series, SeriesType):
  505: 
  506:         def series_getitem(series, item):
  507:             loc = series.index.get_loc(item)
  508:             return series.iloc[loc]
  509: 
  510:         return series_getitem
  511: 
  512: 
  513: @overload(operator.getitem)
  514: def index_indexing(index, idx):
  515:     if isinstance(index, IndexType):
  516: 
  517:         def index_getitem(index, idx):
  518:             return index._data[idx]
  519: 
  520:         return index_getitem
  521: 
  522: 
  523: class IlocType(types.Type):
  524:     def __init__(self, obj_type) -> None:
  525:         self.obj_type = obj_type
  526:         name = f"iLocIndexer({obj_type})"
  527:         super().__init__(name=name)
  528: 
  529:     @property
  530:     def key(self):
  531:         return self.obj_type
  532: 
  533: 
  534: @typeof_impl.register(_iLocIndexer)
  535: def typeof_iloc(val, c):
  536:     objtype = typeof_impl(val.obj, c)
  537:     return IlocType(objtype)
  538: 
  539: 
  540: @type_callable(_iLocIndexer)
  541: def type_iloc_constructor(context):
  542:     def typer(obj):
  543:         if isinstance(obj, SeriesType):
  544:             return IlocType(obj)
  545: 
  546:     return typer
  547: 
  548: 
  549: @lower_builtin(_iLocIndexer, SeriesType)
  550: def iloc_constructor(context, builder, sig, args):
  551:     (obj,) = args
  552:     iloc_indexer = cgutils.create_struct_proxy(sig.return_type)(context, builder)
  553:     iloc_indexer.obj = obj
  554:     return impl_ret_borrowed(
  555:         context, builder, sig.return_type, iloc_indexer._getvalue()
  556:     )
  557: 
  558: 
  559: @register_model(IlocType)
  560: class ILocModel(models.StructModel):
  561:     def __init__(self, dmm, fe_type) -> None:
  562:         members = [("obj", fe_type.obj_type)]
  563:         models.StructModel.__init__(self, dmm, fe_type, members)
  564: 
  565: 
  566: make_attribute_wrapper(IlocType, "obj", "obj")
  567: 
  568: 
  569: @overload_attribute(SeriesType, "iloc")
  570: def series_iloc(series):
  571:     def get(series):
  572:         return _iLocIndexer(series)
  573: 
  574:     return get
  575: 
  576: 
  577: @overload(operator.getitem)
  578: def iloc_getitem(iloc_indexer, i):
  579:     if isinstance(iloc_indexer, IlocType):
  580: 
  581:         def getitem_impl(iloc_indexer, i):
  582:             return iloc_indexer.obj.values[i]
  583: 
  584:         return getitem_impl
