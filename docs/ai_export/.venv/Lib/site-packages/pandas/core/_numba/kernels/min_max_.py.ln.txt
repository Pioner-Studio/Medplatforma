    1: """
    2: Numba 1D min/max kernels that can be shared by
    3: * Dataframe / Series
    4: * groupby
    5: * rolling / expanding
    6: 
    7: Mirrors pandas/_libs/window/aggregation.pyx
    8: """
    9: from __future__ import annotations
   10: 
   11: from typing import TYPE_CHECKING
   12: 
   13: import numba
   14: import numpy as np
   15: 
   16: if TYPE_CHECKING:
   17:     from pandas._typing import npt
   18: 
   19: 
   20: @numba.jit(nopython=True, nogil=True, parallel=False)
   21: def sliding_min_max(
   22:     values: np.ndarray,
   23:     result_dtype: np.dtype,
   24:     start: np.ndarray,
   25:     end: np.ndarray,
   26:     min_periods: int,
   27:     is_max: bool,
   28: ) -> tuple[np.ndarray, list[int]]:
   29:     N = len(start)
   30:     nobs = 0
   31:     output = np.empty(N, dtype=result_dtype)
   32:     na_pos = []
   33:     # Use deque once numba supports it
   34:     # https://github.com/numba/numba/issues/7417
   35:     Q: list = []
   36:     W: list = []
   37:     for i in range(N):
   38:         curr_win_size = end[i] - start[i]
   39:         if i == 0:
   40:             st = start[i]
   41:         else:
   42:             st = end[i - 1]
   43: 
   44:         for k in range(st, end[i]):
   45:             ai = values[k]
   46:             if not np.isnan(ai):
   47:                 nobs += 1
   48:             elif is_max:
   49:                 ai = -np.inf
   50:             else:
   51:                 ai = np.inf
   52:             # Discard previous entries if we find new min or max
   53:             if is_max:
   54:                 while Q and ((ai >= values[Q[-1]]) or values[Q[-1]] != values[Q[-1]]):
   55:                     Q.pop()
   56:             else:
   57:                 while Q and ((ai <= values[Q[-1]]) or values[Q[-1]] != values[Q[-1]]):
   58:                     Q.pop()
   59:             Q.append(k)
   60:             W.append(k)
   61: 
   62:         # Discard entries outside and left of current window
   63:         while Q and Q[0] <= start[i] - 1:
   64:             Q.pop(0)
   65:         while W and W[0] <= start[i] - 1:
   66:             if not np.isnan(values[W[0]]):
   67:                 nobs -= 1
   68:             W.pop(0)
   69: 
   70:         # Save output based on index in input value array
   71:         if Q and curr_win_size > 0 and nobs >= min_periods:
   72:             output[i] = values[Q[0]]
   73:         else:
   74:             if values.dtype.kind != "i":
   75:                 output[i] = np.nan
   76:             else:
   77:                 na_pos.append(i)
   78: 
   79:     return output, na_pos
   80: 
   81: 
   82: @numba.jit(nopython=True, nogil=True, parallel=False)
   83: def grouped_min_max(
   84:     values: np.ndarray,
   85:     result_dtype: np.dtype,
   86:     labels: npt.NDArray[np.intp],
   87:     ngroups: int,
   88:     min_periods: int,
   89:     is_max: bool,
   90: ) -> tuple[np.ndarray, list[int]]:
   91:     N = len(labels)
   92:     nobs = np.zeros(ngroups, dtype=np.int64)
   93:     na_pos = []
   94:     output = np.empty(ngroups, dtype=result_dtype)
   95: 
   96:     for i in range(N):
   97:         lab = labels[i]
   98:         val = values[i]
   99:         if lab < 0:
  100:             continue
  101: 
  102:         if values.dtype.kind == "i" or not np.isnan(val):
  103:             nobs[lab] += 1
  104:         else:
  105:             # NaN value cannot be a min/max value
  106:             continue
  107: 
  108:         if nobs[lab] == 1:
  109:             # First element in group, set output equal to this
  110:             output[lab] = val
  111:             continue
  112: 
  113:         if is_max:
  114:             if val > output[lab]:
  115:                 output[lab] = val
  116:         else:
  117:             if val < output[lab]:
  118:                 output[lab] = val
  119: 
  120:     # Set labels that don't satisfy min_periods as np.nan
  121:     for lab, count in enumerate(nobs):
  122:         if count < min_periods:
  123:             na_pos.append(lab)
  124: 
  125:     return output, na_pos
