    1: """
    2: Numba 1D sum kernels that can be shared by
    3: * Dataframe / Series
    4: * groupby
    5: * rolling / expanding
    6: 
    7: Mirrors pandas/_libs/window/aggregation.pyx
    8: """
    9: from __future__ import annotations
   10: 
   11: from typing import (
   12:     TYPE_CHECKING,
   13:     Any,
   14: )
   15: 
   16: import numba
   17: from numba.extending import register_jitable
   18: import numpy as np
   19: 
   20: if TYPE_CHECKING:
   21:     from pandas._typing import npt
   22: 
   23: from pandas.core._numba.kernels.shared import is_monotonic_increasing
   24: 
   25: 
   26: @numba.jit(nopython=True, nogil=True, parallel=False)
   27: def add_sum(
   28:     val: Any,
   29:     nobs: int,
   30:     sum_x: Any,
   31:     compensation: Any,
   32:     num_consecutive_same_value: int,
   33:     prev_value: Any,
   34: ) -> tuple[int, Any, Any, int, Any]:
   35:     if not np.isnan(val):
   36:         nobs += 1
   37:         y = val - compensation
   38:         t = sum_x + y
   39:         compensation = t - sum_x - y
   40:         sum_x = t
   41: 
   42:         if val == prev_value:
   43:             num_consecutive_same_value += 1
   44:         else:
   45:             num_consecutive_same_value = 1
   46:         prev_value = val
   47: 
   48:     return nobs, sum_x, compensation, num_consecutive_same_value, prev_value
   49: 
   50: 
   51: @numba.jit(nopython=True, nogil=True, parallel=False)
   52: def remove_sum(
   53:     val: Any, nobs: int, sum_x: Any, compensation: Any
   54: ) -> tuple[int, Any, Any]:
   55:     if not np.isnan(val):
   56:         nobs -= 1
   57:         y = -val - compensation
   58:         t = sum_x + y
   59:         compensation = t - sum_x - y
   60:         sum_x = t
   61:     return nobs, sum_x, compensation
   62: 
   63: 
   64: @numba.jit(nopython=True, nogil=True, parallel=False)
   65: def sliding_sum(
   66:     values: np.ndarray,
   67:     result_dtype: np.dtype,
   68:     start: np.ndarray,
   69:     end: np.ndarray,
   70:     min_periods: int,
   71: ) -> tuple[np.ndarray, list[int]]:
   72:     dtype = values.dtype
   73: 
   74:     na_val: object = np.nan
   75:     if dtype.kind == "i":
   76:         na_val = 0
   77: 
   78:     N = len(start)
   79:     nobs = 0
   80:     sum_x = 0
   81:     compensation_add = 0
   82:     compensation_remove = 0
   83:     na_pos = []
   84: 
   85:     is_monotonic_increasing_bounds = is_monotonic_increasing(
   86:         start
   87:     ) and is_monotonic_increasing(end)
   88: 
   89:     output = np.empty(N, dtype=result_dtype)
   90: 
   91:     for i in range(N):
   92:         s = start[i]
   93:         e = end[i]
   94:         if i == 0 or not is_monotonic_increasing_bounds:
   95:             prev_value = values[s]
   96:             num_consecutive_same_value = 0
   97: 
   98:             for j in range(s, e):
   99:                 val = values[j]
  100:                 (
  101:                     nobs,
  102:                     sum_x,
  103:                     compensation_add,
  104:                     num_consecutive_same_value,
  105:                     prev_value,
  106:                 ) = add_sum(
  107:                     val,
  108:                     nobs,
  109:                     sum_x,
  110:                     compensation_add,
  111:                     num_consecutive_same_value,
  112:                     prev_value,
  113:                 )
  114:         else:
  115:             for j in range(start[i - 1], s):
  116:                 val = values[j]
  117:                 nobs, sum_x, compensation_remove = remove_sum(
  118:                     val, nobs, sum_x, compensation_remove
  119:                 )
  120: 
  121:             for j in range(end[i - 1], e):
  122:                 val = values[j]
  123:                 (
  124:                     nobs,
  125:                     sum_x,
  126:                     compensation_add,
  127:                     num_consecutive_same_value,
  128:                     prev_value,
  129:                 ) = add_sum(
  130:                     val,
  131:                     nobs,
  132:                     sum_x,
  133:                     compensation_add,
  134:                     num_consecutive_same_value,
  135:                     prev_value,
  136:                 )
  137: 
  138:         if nobs == 0 == min_periods:
  139:             result: object = 0
  140:         elif nobs >= min_periods:
  141:             if num_consecutive_same_value >= nobs:
  142:                 result = prev_value * nobs
  143:             else:
  144:                 result = sum_x
  145:         else:
  146:             result = na_val
  147:             if dtype.kind == "i":
  148:                 na_pos.append(i)
  149: 
  150:         output[i] = result
  151: 
  152:         if not is_monotonic_increasing_bounds:
  153:             nobs = 0
  154:             sum_x = 0
  155:             compensation_remove = 0
  156: 
  157:     return output, na_pos
  158: 
  159: 
  160: # Mypy/pyright don't like the fact that the decorator is untyped
  161: @register_jitable  # type: ignore[misc]
  162: def grouped_kahan_sum(
  163:     values: np.ndarray,
  164:     result_dtype: np.dtype,
  165:     labels: npt.NDArray[np.intp],
  166:     ngroups: int,
  167: ) -> tuple[
  168:     np.ndarray, npt.NDArray[np.int64], np.ndarray, npt.NDArray[np.int64], np.ndarray
  169: ]:
  170:     N = len(labels)
  171: 
  172:     nobs_arr = np.zeros(ngroups, dtype=np.int64)
  173:     comp_arr = np.zeros(ngroups, dtype=values.dtype)
  174:     consecutive_counts = np.zeros(ngroups, dtype=np.int64)
  175:     prev_vals = np.zeros(ngroups, dtype=values.dtype)
  176:     output = np.zeros(ngroups, dtype=result_dtype)
  177: 
  178:     for i in range(N):
  179:         lab = labels[i]
  180:         val = values[i]
  181: 
  182:         if lab < 0:
  183:             continue
  184: 
  185:         sum_x = output[lab]
  186:         nobs = nobs_arr[lab]
  187:         compensation_add = comp_arr[lab]
  188:         num_consecutive_same_value = consecutive_counts[lab]
  189:         prev_value = prev_vals[lab]
  190: 
  191:         (
  192:             nobs,
  193:             sum_x,
  194:             compensation_add,
  195:             num_consecutive_same_value,
  196:             prev_value,
  197:         ) = add_sum(
  198:             val,
  199:             nobs,
  200:             sum_x,
  201:             compensation_add,
  202:             num_consecutive_same_value,
  203:             prev_value,
  204:         )
  205: 
  206:         output[lab] = sum_x
  207:         consecutive_counts[lab] = num_consecutive_same_value
  208:         prev_vals[lab] = prev_value
  209:         comp_arr[lab] = compensation_add
  210:         nobs_arr[lab] = nobs
  211:     return output, nobs_arr, comp_arr, consecutive_counts, prev_vals
  212: 
  213: 
  214: @numba.jit(nopython=True, nogil=True, parallel=False)
  215: def grouped_sum(
  216:     values: np.ndarray,
  217:     result_dtype: np.dtype,
  218:     labels: npt.NDArray[np.intp],
  219:     ngroups: int,
  220:     min_periods: int,
  221: ) -> tuple[np.ndarray, list[int]]:
  222:     na_pos = []
  223: 
  224:     output, nobs_arr, comp_arr, consecutive_counts, prev_vals = grouped_kahan_sum(
  225:         values, result_dtype, labels, ngroups
  226:     )
  227: 
  228:     # Post-processing, replace sums that don't satisfy min_periods
  229:     for lab in range(ngroups):
  230:         nobs = nobs_arr[lab]
  231:         num_consecutive_same_value = consecutive_counts[lab]
  232:         prev_value = prev_vals[lab]
  233:         sum_x = output[lab]
  234:         if nobs >= min_periods:
  235:             if num_consecutive_same_value >= nobs:
  236:                 result = prev_value * nobs
  237:             else:
  238:                 result = sum_x
  239:         else:
  240:             result = sum_x  # Don't change val, will be replaced by nan later
  241:             na_pos.append(lab)
  242:         output[lab] = result
  243: 
  244:     return output, na_pos
