    1: """
    2: Numba 1D mean kernels that can be shared by
    3: * Dataframe / Series
    4: * groupby
    5: * rolling / expanding
    6: 
    7: Mirrors pandas/_libs/window/aggregation.pyx
    8: """
    9: from __future__ import annotations
   10: 
   11: from typing import TYPE_CHECKING
   12: 
   13: import numba
   14: import numpy as np
   15: 
   16: from pandas.core._numba.kernels.shared import is_monotonic_increasing
   17: from pandas.core._numba.kernels.sum_ import grouped_kahan_sum
   18: 
   19: if TYPE_CHECKING:
   20:     from pandas._typing import npt
   21: 
   22: 
   23: @numba.jit(nopython=True, nogil=True, parallel=False)
   24: def add_mean(
   25:     val: float,
   26:     nobs: int,
   27:     sum_x: float,
   28:     neg_ct: int,
   29:     compensation: float,
   30:     num_consecutive_same_value: int,
   31:     prev_value: float,
   32: ) -> tuple[int, float, int, float, int, float]:
   33:     if not np.isnan(val):
   34:         nobs += 1
   35:         y = val - compensation
   36:         t = sum_x + y
   37:         compensation = t - sum_x - y
   38:         sum_x = t
   39:         if val < 0:
   40:             neg_ct += 1
   41: 
   42:         if val == prev_value:
   43:             num_consecutive_same_value += 1
   44:         else:
   45:             num_consecutive_same_value = 1
   46:         prev_value = val
   47: 
   48:     return nobs, sum_x, neg_ct, compensation, num_consecutive_same_value, prev_value
   49: 
   50: 
   51: @numba.jit(nopython=True, nogil=True, parallel=False)
   52: def remove_mean(
   53:     val: float, nobs: int, sum_x: float, neg_ct: int, compensation: float
   54: ) -> tuple[int, float, int, float]:
   55:     if not np.isnan(val):
   56:         nobs -= 1
   57:         y = -val - compensation
   58:         t = sum_x + y
   59:         compensation = t - sum_x - y
   60:         sum_x = t
   61:         if val < 0:
   62:             neg_ct -= 1
   63:     return nobs, sum_x, neg_ct, compensation
   64: 
   65: 
   66: @numba.jit(nopython=True, nogil=True, parallel=False)
   67: def sliding_mean(
   68:     values: np.ndarray,
   69:     result_dtype: np.dtype,
   70:     start: np.ndarray,
   71:     end: np.ndarray,
   72:     min_periods: int,
   73: ) -> tuple[np.ndarray, list[int]]:
   74:     N = len(start)
   75:     nobs = 0
   76:     sum_x = 0.0
   77:     neg_ct = 0
   78:     compensation_add = 0.0
   79:     compensation_remove = 0.0
   80: 
   81:     is_monotonic_increasing_bounds = is_monotonic_increasing(
   82:         start
   83:     ) and is_monotonic_increasing(end)
   84: 
   85:     output = np.empty(N, dtype=result_dtype)
   86: 
   87:     for i in range(N):
   88:         s = start[i]
   89:         e = end[i]
   90:         if i == 0 or not is_monotonic_increasing_bounds:
   91:             prev_value = values[s]
   92:             num_consecutive_same_value = 0
   93: 
   94:             for j in range(s, e):
   95:                 val = values[j]
   96:                 (
   97:                     nobs,
   98:                     sum_x,
   99:                     neg_ct,
  100:                     compensation_add,
  101:                     num_consecutive_same_value,
  102:                     prev_value,
  103:                 ) = add_mean(
  104:                     val,
  105:                     nobs,
  106:                     sum_x,
  107:                     neg_ct,
  108:                     compensation_add,
  109:                     num_consecutive_same_value,
  110:                     prev_value,  # pyright: ignore[reportGeneralTypeIssues]
  111:                 )
  112:         else:
  113:             for j in range(start[i - 1], s):
  114:                 val = values[j]
  115:                 nobs, sum_x, neg_ct, compensation_remove = remove_mean(
  116:                     val, nobs, sum_x, neg_ct, compensation_remove
  117:                 )
  118: 
  119:             for j in range(end[i - 1], e):
  120:                 val = values[j]
  121:                 (
  122:                     nobs,
  123:                     sum_x,
  124:                     neg_ct,
  125:                     compensation_add,
  126:                     num_consecutive_same_value,
  127:                     prev_value,
  128:                 ) = add_mean(
  129:                     val,
  130:                     nobs,
  131:                     sum_x,
  132:                     neg_ct,
  133:                     compensation_add,
  134:                     num_consecutive_same_value,
  135:                     prev_value,  # pyright: ignore[reportGeneralTypeIssues]
  136:                 )
  137: 
  138:         if nobs >= min_periods and nobs > 0:
  139:             result = sum_x / nobs
  140:             if num_consecutive_same_value >= nobs:
  141:                 result = prev_value
  142:             elif neg_ct == 0 and result < 0:
  143:                 result = 0
  144:             elif neg_ct == nobs and result > 0:
  145:                 result = 0
  146:         else:
  147:             result = np.nan
  148: 
  149:         output[i] = result
  150: 
  151:         if not is_monotonic_increasing_bounds:
  152:             nobs = 0
  153:             sum_x = 0.0
  154:             neg_ct = 0
  155:             compensation_remove = 0.0
  156: 
  157:     # na_position is empty list since float64 can already hold nans
  158:     # Do list comprehension, since numba cannot figure out that na_pos is
  159:     # empty list of ints on its own
  160:     na_pos = [0 for i in range(0)]
  161:     return output, na_pos
  162: 
  163: 
  164: @numba.jit(nopython=True, nogil=True, parallel=False)
  165: def grouped_mean(
  166:     values: np.ndarray,
  167:     result_dtype: np.dtype,
  168:     labels: npt.NDArray[np.intp],
  169:     ngroups: int,
  170:     min_periods: int,
  171: ) -> tuple[np.ndarray, list[int]]:
  172:     output, nobs_arr, comp_arr, consecutive_counts, prev_vals = grouped_kahan_sum(
  173:         values, result_dtype, labels, ngroups
  174:     )
  175: 
  176:     # Post-processing, replace sums that don't satisfy min_periods
  177:     for lab in range(ngroups):
  178:         nobs = nobs_arr[lab]
  179:         num_consecutive_same_value = consecutive_counts[lab]
  180:         prev_value = prev_vals[lab]
  181:         sum_x = output[lab]
  182:         if nobs >= min_periods:
  183:             if num_consecutive_same_value >= nobs:
  184:                 result = prev_value * nobs
  185:             else:
  186:                 result = sum_x
  187:         else:
  188:             result = np.nan
  189:         result /= nobs
  190:         output[lab] = result
  191: 
  192:     # na_position is empty list since float64 can already hold nans
  193:     # Do list comprehension, since numba cannot figure out that na_pos is
  194:     # empty list of ints on its own
  195:     na_pos = [0 for i in range(0)]
  196:     return output, na_pos
