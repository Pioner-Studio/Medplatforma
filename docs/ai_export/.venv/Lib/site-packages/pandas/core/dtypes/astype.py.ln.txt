    1: """
    2: Functions for implementing 'astype' methods according to pandas conventions,
    3: particularly ones that differ from numpy.
    4: """
    5: from __future__ import annotations
    6: 
    7: import inspect
    8: from typing import (
    9:     TYPE_CHECKING,
   10:     overload,
   11: )
   12: import warnings
   13: 
   14: import numpy as np
   15: 
   16: from pandas._libs import lib
   17: from pandas._libs.tslibs.timedeltas import array_to_timedelta64
   18: from pandas.errors import IntCastingNaNError
   19: 
   20: from pandas.core.dtypes.common import (
   21:     is_object_dtype,
   22:     is_string_dtype,
   23:     pandas_dtype,
   24: )
   25: from pandas.core.dtypes.dtypes import (
   26:     ExtensionDtype,
   27:     NumpyEADtype,
   28: )
   29: 
   30: if TYPE_CHECKING:
   31:     from pandas._typing import (
   32:         ArrayLike,
   33:         DtypeObj,
   34:         IgnoreRaise,
   35:     )
   36: 
   37:     from pandas.core.arrays import ExtensionArray
   38: 
   39: _dtype_obj = np.dtype(object)
   40: 
   41: 
   42: @overload
   43: def _astype_nansafe(
   44:     arr: np.ndarray, dtype: np.dtype, copy: bool = ..., skipna: bool = ...
   45: ) -> np.ndarray:
   46:     ...
   47: 
   48: 
   49: @overload
   50: def _astype_nansafe(
   51:     arr: np.ndarray, dtype: ExtensionDtype, copy: bool = ..., skipna: bool = ...
   52: ) -> ExtensionArray:
   53:     ...
   54: 
   55: 
   56: def _astype_nansafe(
   57:     arr: np.ndarray, dtype: DtypeObj, copy: bool = True, skipna: bool = False
   58: ) -> ArrayLike:
   59:     """
   60:     Cast the elements of an array to a given dtype a nan-safe manner.
   61: 
   62:     Parameters
   63:     ----------
   64:     arr : ndarray
   65:     dtype : np.dtype or ExtensionDtype
   66:     copy : bool, default True
   67:         If False, a view will be attempted but may fail, if
   68:         e.g. the item sizes don't align.
   69:     skipna: bool, default False
   70:         Whether or not we should skip NaN when casting as a string-type.
   71: 
   72:     Raises
   73:     ------
   74:     ValueError
   75:         The dtype was a datetime64/timedelta64 dtype, but it had no unit.
   76:     """
   77: 
   78:     # dispatch on extension dtype if needed
   79:     if isinstance(dtype, ExtensionDtype):
   80:         return dtype.construct_array_type()._from_sequence(arr, dtype=dtype, copy=copy)
   81: 
   82:     elif not isinstance(dtype, np.dtype):  # pragma: no cover
   83:         raise ValueError("dtype must be np.dtype or ExtensionDtype")
   84: 
   85:     if arr.dtype.kind in "mM":
   86:         from pandas.core.construction import ensure_wrapped_if_datetimelike
   87: 
   88:         arr = ensure_wrapped_if_datetimelike(arr)
   89:         res = arr.astype(dtype, copy=copy)
   90:         return np.asarray(res)
   91: 
   92:     if issubclass(dtype.type, str):
   93:         shape = arr.shape
   94:         if arr.ndim > 1:
   95:             arr = arr.ravel()
   96:         return lib.ensure_string_array(
   97:             arr, skipna=skipna, convert_na_value=False
   98:         ).reshape(shape)
   99: 
  100:     elif np.issubdtype(arr.dtype, np.floating) and dtype.kind in "iu":
  101:         return _astype_float_to_int_nansafe(arr, dtype, copy)
  102: 
  103:     elif arr.dtype == object:
  104:         # if we have a datetime/timedelta array of objects
  105:         # then coerce to datetime64[ns] and use DatetimeArray.astype
  106: 
  107:         if lib.is_np_dtype(dtype, "M"):
  108:             from pandas.core.arrays import DatetimeArray
  109: 
  110:             dta = DatetimeArray._from_sequence(arr, dtype=dtype)
  111:             return dta._ndarray
  112: 
  113:         elif lib.is_np_dtype(dtype, "m"):
  114:             from pandas.core.construction import ensure_wrapped_if_datetimelike
  115: 
  116:             # bc we know arr.dtype == object, this is equivalent to
  117:             #  `np.asarray(to_timedelta(arr))`, but using a lower-level API that
  118:             #  does not require a circular import.
  119:             tdvals = array_to_timedelta64(arr).view("m8[ns]")
  120: 
  121:             tda = ensure_wrapped_if_datetimelike(tdvals)
  122:             return tda.astype(dtype, copy=False)._ndarray
  123: 
  124:     if dtype.name in ("datetime64", "timedelta64"):
  125:         msg = (
  126:             f"The '{dtype.name}' dtype has no unit. Please pass in "
  127:             f"'{dtype.name}[ns]' instead."
  128:         )
  129:         raise ValueError(msg)
  130: 
  131:     if copy or arr.dtype == object or dtype == object:
  132:         # Explicit copy, or required since NumPy can't view from / to object.
  133:         return arr.astype(dtype, copy=True)
  134: 
  135:     return arr.astype(dtype, copy=copy)
  136: 
  137: 
  138: def _astype_float_to_int_nansafe(
  139:     values: np.ndarray, dtype: np.dtype, copy: bool
  140: ) -> np.ndarray:
  141:     """
  142:     astype with a check preventing converting NaN to an meaningless integer value.
  143:     """
  144:     if not np.isfinite(values).all():
  145:         raise IntCastingNaNError(
  146:             "Cannot convert non-finite values (NA or inf) to integer"
  147:         )
  148:     if dtype.kind == "u":
  149:         # GH#45151
  150:         if not (values >= 0).all():
  151:             raise ValueError(f"Cannot losslessly cast from {values.dtype} to {dtype}")
  152:     with warnings.catch_warnings():
  153:         warnings.filterwarnings("ignore", category=RuntimeWarning)
  154:         return values.astype(dtype, copy=copy)
  155: 
  156: 
  157: def astype_array(values: ArrayLike, dtype: DtypeObj, copy: bool = False) -> ArrayLike:
  158:     """
  159:     Cast array (ndarray or ExtensionArray) to the new dtype.
  160: 
  161:     Parameters
  162:     ----------
  163:     values : ndarray or ExtensionArray
  164:     dtype : dtype object
  165:     copy : bool, default False
  166:         copy if indicated
  167: 
  168:     Returns
  169:     -------
  170:     ndarray or ExtensionArray
  171:     """
  172:     if values.dtype == dtype:
  173:         if copy:
  174:             return values.copy()
  175:         return values
  176: 
  177:     if not isinstance(values, np.ndarray):
  178:         # i.e. ExtensionArray
  179:         values = values.astype(dtype, copy=copy)
  180: 
  181:     else:
  182:         values = _astype_nansafe(values, dtype, copy=copy)
  183: 
  184:     # in pandas we don't store numpy str dtypes, so convert to object
  185:     if isinstance(dtype, np.dtype) and issubclass(values.dtype.type, str):
  186:         values = np.array(values, dtype=object)
  187: 
  188:     return values
  189: 
  190: 
  191: def astype_array_safe(
  192:     values: ArrayLike, dtype, copy: bool = False, errors: IgnoreRaise = "raise"
  193: ) -> ArrayLike:
  194:     """
  195:     Cast array (ndarray or ExtensionArray) to the new dtype.
  196: 
  197:     This basically is the implementation for DataFrame/Series.astype and
  198:     includes all custom logic for pandas (NaN-safety, converting str to object,
  199:     not allowing )
  200: 
  201:     Parameters
  202:     ----------
  203:     values : ndarray or ExtensionArray
  204:     dtype : str, dtype convertible
  205:     copy : bool, default False
  206:         copy if indicated
  207:     errors : str, {'raise', 'ignore'}, default 'raise'
  208:         - ``raise`` : allow exceptions to be raised
  209:         - ``ignore`` : suppress exceptions. On error return original object
  210: 
  211:     Returns
  212:     -------
  213:     ndarray or ExtensionArray
  214:     """
  215:     errors_legal_values = ("raise", "ignore")
  216: 
  217:     if errors not in errors_legal_values:
  218:         invalid_arg = (
  219:             "Expected value of kwarg 'errors' to be one of "
  220:             f"{list(errors_legal_values)}. Supplied value is '{errors}'"
  221:         )
  222:         raise ValueError(invalid_arg)
  223: 
  224:     if inspect.isclass(dtype) and issubclass(dtype, ExtensionDtype):
  225:         msg = (
  226:             f"Expected an instance of {dtype.__name__}, "
  227:             "but got the class instead. Try instantiating 'dtype'."
  228:         )
  229:         raise TypeError(msg)
  230: 
  231:     dtype = pandas_dtype(dtype)
  232:     if isinstance(dtype, NumpyEADtype):
  233:         # Ensure we don't end up with a NumpyExtensionArray
  234:         dtype = dtype.numpy_dtype
  235: 
  236:     try:
  237:         new_values = astype_array(values, dtype, copy=copy)
  238:     except (ValueError, TypeError):
  239:         # e.g. _astype_nansafe can fail on object-dtype of strings
  240:         #  trying to convert to float
  241:         if errors == "ignore":
  242:             new_values = values
  243:         else:
  244:             raise
  245: 
  246:     return new_values
  247: 
  248: 
  249: def astype_is_view(dtype: DtypeObj, new_dtype: DtypeObj) -> bool:
  250:     """Checks if astype avoided copying the data.
  251: 
  252:     Parameters
  253:     ----------
  254:     dtype : Original dtype
  255:     new_dtype : target dtype
  256: 
  257:     Returns
  258:     -------
  259:     True if new data is a view or not guaranteed to be a copy, False otherwise
  260:     """
  261:     if isinstance(dtype, np.dtype) and not isinstance(new_dtype, np.dtype):
  262:         new_dtype, dtype = dtype, new_dtype
  263: 
  264:     if dtype == new_dtype:
  265:         return True
  266: 
  267:     elif isinstance(dtype, np.dtype) and isinstance(new_dtype, np.dtype):
  268:         # Only equal numpy dtypes avoid a copy
  269:         return False
  270: 
  271:     elif is_string_dtype(dtype) and is_string_dtype(new_dtype):
  272:         # Potentially! a view when converting from object to string
  273:         return True
  274: 
  275:     elif is_object_dtype(dtype) and new_dtype.kind == "O":
  276:         # When the underlying array has dtype object, we don't have to make a copy
  277:         return True
  278: 
  279:     elif dtype.kind in "mM" and new_dtype.kind in "mM":
  280:         dtype = getattr(dtype, "numpy_dtype", dtype)
  281:         new_dtype = getattr(new_dtype, "numpy_dtype", new_dtype)
  282:         return getattr(dtype, "unit", None) == getattr(new_dtype, "unit", None)
  283: 
  284:     numpy_dtype = getattr(dtype, "numpy_dtype", None)
  285:     new_numpy_dtype = getattr(new_dtype, "numpy_dtype", None)
  286: 
  287:     if numpy_dtype is None and isinstance(dtype, np.dtype):
  288:         numpy_dtype = dtype
  289: 
  290:     if new_numpy_dtype is None and isinstance(new_dtype, np.dtype):
  291:         new_numpy_dtype = new_dtype
  292: 
  293:     if numpy_dtype is not None and new_numpy_dtype is not None:
  294:         # if both have NumPy dtype or one of them is a numpy dtype
  295:         # they are only a view when the numpy dtypes are equal, e.g.
  296:         # int64 -> Int64 or int64[pyarrow]
  297:         # int64 -> Int32 copies
  298:         return numpy_dtype == new_numpy_dtype
  299: 
  300:     # Assume this is a view since we don't know for sure if a copy was made
  301:     return True
