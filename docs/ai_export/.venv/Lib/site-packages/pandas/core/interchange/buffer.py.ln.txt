    1: from __future__ import annotations
    2: 
    3: from typing import (
    4:     TYPE_CHECKING,
    5:     Any,
    6: )
    7: 
    8: from pandas.core.interchange.dataframe_protocol import (
    9:     Buffer,
   10:     DlpackDeviceType,
   11: )
   12: 
   13: if TYPE_CHECKING:
   14:     import numpy as np
   15:     import pyarrow as pa
   16: 
   17: 
   18: class PandasBuffer(Buffer):
   19:     """
   20:     Data in the buffer is guaranteed to be contiguous in memory.
   21:     """
   22: 
   23:     def __init__(self, x: np.ndarray, allow_copy: bool = True) -> None:
   24:         """
   25:         Handle only regular columns (= numpy arrays) for now.
   26:         """
   27:         if x.strides[0] and not x.strides == (x.dtype.itemsize,):
   28:             # The protocol does not support strided buffers, so a copy is
   29:             # necessary. If that's not allowed, we need to raise an exception.
   30:             if allow_copy:
   31:                 x = x.copy()
   32:             else:
   33:                 raise RuntimeError(
   34:                     "Exports cannot be zero-copy in the case "
   35:                     "of a non-contiguous buffer"
   36:                 )
   37: 
   38:         # Store the numpy array in which the data resides as a private
   39:         # attribute, so we can use it to retrieve the public attributes
   40:         self._x = x
   41: 
   42:     @property
   43:     def bufsize(self) -> int:
   44:         """
   45:         Buffer size in bytes.
   46:         """
   47:         return self._x.size * self._x.dtype.itemsize
   48: 
   49:     @property
   50:     def ptr(self) -> int:
   51:         """
   52:         Pointer to start of the buffer as an integer.
   53:         """
   54:         return self._x.__array_interface__["data"][0]
   55: 
   56:     def __dlpack__(self) -> Any:
   57:         """
   58:         Represent this structure as DLPack interface.
   59:         """
   60:         return self._x.__dlpack__()
   61: 
   62:     def __dlpack_device__(self) -> tuple[DlpackDeviceType, int | None]:
   63:         """
   64:         Device type and device ID for where the data in the buffer resides.
   65:         """
   66:         return (DlpackDeviceType.CPU, None)
   67: 
   68:     def __repr__(self) -> str:
   69:         return (
   70:             "PandasBuffer("
   71:             + str(
   72:                 {
   73:                     "bufsize": self.bufsize,
   74:                     "ptr": self.ptr,
   75:                     "device": self.__dlpack_device__()[0].name,
   76:                 }
   77:             )
   78:             + ")"
   79:         )
   80: 
   81: 
   82: class PandasBufferPyarrow(Buffer):
   83:     """
   84:     Data in the buffer is guaranteed to be contiguous in memory.
   85:     """
   86: 
   87:     def __init__(
   88:         self,
   89:         buffer: pa.Buffer,
   90:         *,
   91:         length: int,
   92:     ) -> None:
   93:         """
   94:         Handle pyarrow chunked arrays.
   95:         """
   96:         self._buffer = buffer
   97:         self._length = length
   98: 
   99:     @property
  100:     def bufsize(self) -> int:
  101:         """
  102:         Buffer size in bytes.
  103:         """
  104:         return self._buffer.size
  105: 
  106:     @property
  107:     def ptr(self) -> int:
  108:         """
  109:         Pointer to start of the buffer as an integer.
  110:         """
  111:         return self._buffer.address
  112: 
  113:     def __dlpack__(self) -> Any:
  114:         """
  115:         Represent this structure as DLPack interface.
  116:         """
  117:         raise NotImplementedError()
  118: 
  119:     def __dlpack_device__(self) -> tuple[DlpackDeviceType, int | None]:
  120:         """
  121:         Device type and device ID for where the data in the buffer resides.
  122:         """
  123:         return (DlpackDeviceType.CPU, None)
  124: 
  125:     def __repr__(self) -> str:
  126:         return (
  127:             "PandasBuffer[pyarrow]("
  128:             + str(
  129:                 {
  130:                     "bufsize": self.bufsize,
  131:                     "ptr": self.ptr,
  132:                     "device": "CPU",
  133:                 }
  134:             )
  135:             + ")"
  136:         )
