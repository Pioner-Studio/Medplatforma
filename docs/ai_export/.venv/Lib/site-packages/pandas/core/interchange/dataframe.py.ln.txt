    1: from __future__ import annotations
    2: 
    3: from collections import abc
    4: from typing import TYPE_CHECKING
    5: 
    6: from pandas.core.interchange.column import PandasColumn
    7: from pandas.core.interchange.dataframe_protocol import DataFrame as DataFrameXchg
    8: from pandas.core.interchange.utils import maybe_rechunk
    9: 
   10: if TYPE_CHECKING:
   11:     from collections.abc import (
   12:         Iterable,
   13:         Sequence,
   14:     )
   15: 
   16:     from pandas import (
   17:         DataFrame,
   18:         Index,
   19:     )
   20: 
   21: 
   22: class PandasDataFrameXchg(DataFrameXchg):
   23:     """
   24:     A data frame class, with only the methods required by the interchange
   25:     protocol defined.
   26:     Instances of this (private) class are returned from
   27:     ``pd.DataFrame.__dataframe__`` as objects with the methods and
   28:     attributes defined on this class.
   29:     """
   30: 
   31:     def __init__(self, df: DataFrame, allow_copy: bool = True) -> None:
   32:         """
   33:         Constructor - an instance of this (private) class is returned from
   34:         `pd.DataFrame.__dataframe__`.
   35:         """
   36:         self._df = df.rename(columns=str, copy=False)
   37:         self._allow_copy = allow_copy
   38:         for i, _col in enumerate(self._df.columns):
   39:             rechunked = maybe_rechunk(self._df.iloc[:, i], allow_copy=allow_copy)
   40:             if rechunked is not None:
   41:                 self._df.isetitem(i, rechunked)
   42: 
   43:     def __dataframe__(
   44:         self, nan_as_null: bool = False, allow_copy: bool = True
   45:     ) -> PandasDataFrameXchg:
   46:         # `nan_as_null` can be removed here once it's removed from
   47:         # Dataframe.__dataframe__
   48:         return PandasDataFrameXchg(self._df, allow_copy)
   49: 
   50:     @property
   51:     def metadata(self) -> dict[str, Index]:
   52:         # `index` isn't a regular column, and the protocol doesn't support row
   53:         # labels - so we export it as Pandas-specific metadata here.
   54:         return {"pandas.index": self._df.index}
   55: 
   56:     def num_columns(self) -> int:
   57:         return len(self._df.columns)
   58: 
   59:     def num_rows(self) -> int:
   60:         return len(self._df)
   61: 
   62:     def num_chunks(self) -> int:
   63:         return 1
   64: 
   65:     def column_names(self) -> Index:
   66:         return self._df.columns
   67: 
   68:     def get_column(self, i: int) -> PandasColumn:
   69:         return PandasColumn(self._df.iloc[:, i], allow_copy=self._allow_copy)
   70: 
   71:     def get_column_by_name(self, name: str) -> PandasColumn:
   72:         return PandasColumn(self._df[name], allow_copy=self._allow_copy)
   73: 
   74:     def get_columns(self) -> list[PandasColumn]:
   75:         return [
   76:             PandasColumn(self._df[name], allow_copy=self._allow_copy)
   77:             for name in self._df.columns
   78:         ]
   79: 
   80:     def select_columns(self, indices: Sequence[int]) -> PandasDataFrameXchg:
   81:         if not isinstance(indices, abc.Sequence):
   82:             raise ValueError("`indices` is not a sequence")
   83:         if not isinstance(indices, list):
   84:             indices = list(indices)
   85: 
   86:         return PandasDataFrameXchg(
   87:             self._df.iloc[:, indices], allow_copy=self._allow_copy
   88:         )
   89: 
   90:     def select_columns_by_name(self, names: list[str]) -> PandasDataFrameXchg:  # type: ignore[override]
   91:         if not isinstance(names, abc.Sequence):
   92:             raise ValueError("`names` is not a sequence")
   93:         if not isinstance(names, list):
   94:             names = list(names)
   95: 
   96:         return PandasDataFrameXchg(self._df.loc[:, names], allow_copy=self._allow_copy)
   97: 
   98:     def get_chunks(self, n_chunks: int | None = None) -> Iterable[PandasDataFrameXchg]:
   99:         """
  100:         Return an iterator yielding the chunks.
  101:         """
  102:         if n_chunks and n_chunks > 1:
  103:             size = len(self._df)
  104:             step = size // n_chunks
  105:             if size % n_chunks != 0:
  106:                 step += 1
  107:             for start in range(0, step * n_chunks, step):
  108:                 yield PandasDataFrameXchg(
  109:                     self._df.iloc[start : start + step, :],
  110:                     allow_copy=self._allow_copy,
  111:                 )
  112:         else:
  113:             yield self
