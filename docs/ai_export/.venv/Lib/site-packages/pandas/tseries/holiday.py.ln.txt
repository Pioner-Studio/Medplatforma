    1: from __future__ import annotations
    2: 
    3: from datetime import (
    4:     datetime,
    5:     timedelta,
    6: )
    7: import warnings
    8: 
    9: from dateutil.relativedelta import (
   10:     FR,
   11:     MO,
   12:     SA,
   13:     SU,
   14:     TH,
   15:     TU,
   16:     WE,
   17: )
   18: import numpy as np
   19: 
   20: from pandas.errors import PerformanceWarning
   21: 
   22: from pandas import (
   23:     DateOffset,
   24:     DatetimeIndex,
   25:     Series,
   26:     Timestamp,
   27:     concat,
   28:     date_range,
   29: )
   30: 
   31: from pandas.tseries.offsets import (
   32:     Day,
   33:     Easter,
   34: )
   35: 
   36: 
   37: def next_monday(dt: datetime) -> datetime:
   38:     """
   39:     If holiday falls on Saturday, use following Monday instead;
   40:     if holiday falls on Sunday, use Monday instead
   41:     """
   42:     if dt.weekday() == 5:
   43:         return dt + timedelta(2)
   44:     elif dt.weekday() == 6:
   45:         return dt + timedelta(1)
   46:     return dt
   47: 
   48: 
   49: def next_monday_or_tuesday(dt: datetime) -> datetime:
   50:     """
   51:     For second holiday of two adjacent ones!
   52:     If holiday falls on Saturday, use following Monday instead;
   53:     if holiday falls on Sunday or Monday, use following Tuesday instead
   54:     (because Monday is already taken by adjacent holiday on the day before)
   55:     """
   56:     dow = dt.weekday()
   57:     if dow in (5, 6):
   58:         return dt + timedelta(2)
   59:     if dow == 0:
   60:         return dt + timedelta(1)
   61:     return dt
   62: 
   63: 
   64: def previous_friday(dt: datetime) -> datetime:
   65:     """
   66:     If holiday falls on Saturday or Sunday, use previous Friday instead.
   67:     """
   68:     if dt.weekday() == 5:
   69:         return dt - timedelta(1)
   70:     elif dt.weekday() == 6:
   71:         return dt - timedelta(2)
   72:     return dt
   73: 
   74: 
   75: def sunday_to_monday(dt: datetime) -> datetime:
   76:     """
   77:     If holiday falls on Sunday, use day thereafter (Monday) instead.
   78:     """
   79:     if dt.weekday() == 6:
   80:         return dt + timedelta(1)
   81:     return dt
   82: 
   83: 
   84: def weekend_to_monday(dt: datetime) -> datetime:
   85:     """
   86:     If holiday falls on Sunday or Saturday,
   87:     use day thereafter (Monday) instead.
   88:     Needed for holidays such as Christmas observation in Europe
   89:     """
   90:     if dt.weekday() == 6:
   91:         return dt + timedelta(1)
   92:     elif dt.weekday() == 5:
   93:         return dt + timedelta(2)
   94:     return dt
   95: 
   96: 
   97: def nearest_workday(dt: datetime) -> datetime:
   98:     """
   99:     If holiday falls on Saturday, use day before (Friday) instead;
  100:     if holiday falls on Sunday, use day thereafter (Monday) instead.
  101:     """
  102:     if dt.weekday() == 5:
  103:         return dt - timedelta(1)
  104:     elif dt.weekday() == 6:
  105:         return dt + timedelta(1)
  106:     return dt
  107: 
  108: 
  109: def next_workday(dt: datetime) -> datetime:
  110:     """
  111:     returns next weekday used for observances
  112:     """
  113:     dt += timedelta(days=1)
  114:     while dt.weekday() > 4:
  115:         # Mon-Fri are 0-4
  116:         dt += timedelta(days=1)
  117:     return dt
  118: 
  119: 
  120: def previous_workday(dt: datetime) -> datetime:
  121:     """
  122:     returns previous weekday used for observances
  123:     """
  124:     dt -= timedelta(days=1)
  125:     while dt.weekday() > 4:
  126:         # Mon-Fri are 0-4
  127:         dt -= timedelta(days=1)
  128:     return dt
  129: 
  130: 
  131: def before_nearest_workday(dt: datetime) -> datetime:
  132:     """
  133:     returns previous workday after nearest workday
  134:     """
  135:     return previous_workday(nearest_workday(dt))
  136: 
  137: 
  138: def after_nearest_workday(dt: datetime) -> datetime:
  139:     """
  140:     returns next workday after nearest workday
  141:     needed for Boxing day or multiple holidays in a series
  142:     """
  143:     return next_workday(nearest_workday(dt))
  144: 
  145: 
  146: class Holiday:
  147:     """
  148:     Class that defines a holiday with start/end dates and rules
  149:     for observance.
  150:     """
  151: 
  152:     start_date: Timestamp | None
  153:     end_date: Timestamp | None
  154:     days_of_week: tuple[int, ...] | None
  155: 
  156:     def __init__(
  157:         self,
  158:         name: str,
  159:         year=None,
  160:         month=None,
  161:         day=None,
  162:         offset=None,
  163:         observance=None,
  164:         start_date=None,
  165:         end_date=None,
  166:         days_of_week=None,
  167:     ) -> None:
  168:         """
  169:         Parameters
  170:         ----------
  171:         name : str
  172:             Name of the holiday , defaults to class name
  173:         offset : array of pandas.tseries.offsets or
  174:                 class from pandas.tseries.offsets
  175:             computes offset from date
  176:         observance: function
  177:             computes when holiday is given a pandas Timestamp
  178:         days_of_week:
  179:             provide a tuple of days e.g  (0,1,2,3,) for Monday Through Thursday
  180:             Monday=0,..,Sunday=6
  181: 
  182:         Examples
  183:         --------
  184:         >>> from dateutil.relativedelta import MO
  185: 
  186:         >>> USMemorialDay = pd.tseries.holiday.Holiday(
  187:         ...     "Memorial Day", month=5, day=31, offset=pd.DateOffset(weekday=MO(-1))
  188:         ... )
  189:         >>> USMemorialDay
  190:         Holiday: Memorial Day (month=5, day=31, offset=<DateOffset: weekday=MO(-1)>)
  191: 
  192:         >>> USLaborDay = pd.tseries.holiday.Holiday(
  193:         ...     "Labor Day", month=9, day=1, offset=pd.DateOffset(weekday=MO(1))
  194:         ... )
  195:         >>> USLaborDay
  196:         Holiday: Labor Day (month=9, day=1, offset=<DateOffset: weekday=MO(+1)>)
  197: 
  198:         >>> July3rd = pd.tseries.holiday.Holiday("July 3rd", month=7, day=3)
  199:         >>> July3rd
  200:         Holiday: July 3rd (month=7, day=3, )
  201: 
  202:         >>> NewYears = pd.tseries.holiday.Holiday(
  203:         ...     "New Years Day", month=1,  day=1,
  204:         ...      observance=pd.tseries.holiday.nearest_workday
  205:         ... )
  206:         >>> NewYears  # doctest: +SKIP
  207:         Holiday: New Years Day (
  208:             month=1, day=1, observance=<function nearest_workday at 0x66545e9bc440>
  209:         )
  210: 
  211:         >>> July3rd = pd.tseries.holiday.Holiday(
  212:         ...     "July 3rd", month=7, day=3,
  213:         ...     days_of_week=(0, 1, 2, 3)
  214:         ... )
  215:         >>> July3rd
  216:         Holiday: July 3rd (month=7, day=3, )
  217:         """
  218:         if offset is not None and observance is not None:
  219:             raise NotImplementedError("Cannot use both offset and observance.")
  220: 
  221:         self.name = name
  222:         self.year = year
  223:         self.month = month
  224:         self.day = day
  225:         self.offset = offset
  226:         self.start_date = (
  227:             Timestamp(start_date) if start_date is not None else start_date
  228:         )
  229:         self.end_date = Timestamp(end_date) if end_date is not None else end_date
  230:         self.observance = observance
  231:         assert days_of_week is None or type(days_of_week) == tuple
  232:         self.days_of_week = days_of_week
  233: 
  234:     def __repr__(self) -> str:
  235:         info = ""
  236:         if self.year is not None:
  237:             info += f"year={self.year}, "
  238:         info += f"month={self.month}, day={self.day}, "
  239: 
  240:         if self.offset is not None:
  241:             info += f"offset={self.offset}"
  242: 
  243:         if self.observance is not None:
  244:             info += f"observance={self.observance}"
  245: 
  246:         repr = f"Holiday: {self.name} ({info})"
  247:         return repr
  248: 
  249:     def dates(
  250:         self, start_date, end_date, return_name: bool = False
  251:     ) -> Series | DatetimeIndex:
  252:         """
  253:         Calculate holidays observed between start date and end date
  254: 
  255:         Parameters
  256:         ----------
  257:         start_date : starting date, datetime-like, optional
  258:         end_date : ending date, datetime-like, optional
  259:         return_name : bool, optional, default=False
  260:             If True, return a series that has dates and holiday names.
  261:             False will only return dates.
  262: 
  263:         Returns
  264:         -------
  265:         Series or DatetimeIndex
  266:             Series if return_name is True
  267:         """
  268:         start_date = Timestamp(start_date)
  269:         end_date = Timestamp(end_date)
  270: 
  271:         filter_start_date = start_date
  272:         filter_end_date = end_date
  273: 
  274:         if self.year is not None:
  275:             dt = Timestamp(datetime(self.year, self.month, self.day))
  276:             dti = DatetimeIndex([dt])
  277:             if return_name:
  278:                 return Series(self.name, index=dti)
  279:             else:
  280:                 return dti
  281: 
  282:         dates = self._reference_dates(start_date, end_date)
  283:         holiday_dates = self._apply_rule(dates)
  284:         if self.days_of_week is not None:
  285:             holiday_dates = holiday_dates[
  286:                 np.isin(
  287:                     # error: "DatetimeIndex" has no attribute "dayofweek"
  288:                     holiday_dates.dayofweek,  # type: ignore[attr-defined]
  289:                     self.days_of_week,
  290:                 ).ravel()
  291:             ]
  292: 
  293:         if self.start_date is not None:
  294:             filter_start_date = max(
  295:                 self.start_date.tz_localize(filter_start_date.tz), filter_start_date
  296:             )
  297:         if self.end_date is not None:
  298:             filter_end_date = min(
  299:                 self.end_date.tz_localize(filter_end_date.tz), filter_end_date
  300:             )
  301:         holiday_dates = holiday_dates[
  302:             (holiday_dates >= filter_start_date) & (holiday_dates <= filter_end_date)
  303:         ]
  304:         if return_name:
  305:             return Series(self.name, index=holiday_dates)
  306:         return holiday_dates
  307: 
  308:     def _reference_dates(
  309:         self, start_date: Timestamp, end_date: Timestamp
  310:     ) -> DatetimeIndex:
  311:         """
  312:         Get reference dates for the holiday.
  313: 
  314:         Return reference dates for the holiday also returning the year
  315:         prior to the start_date and year following the end_date.  This ensures
  316:         that any offsets to be applied will yield the holidays within
  317:         the passed in dates.
  318:         """
  319:         if self.start_date is not None:
  320:             start_date = self.start_date.tz_localize(start_date.tz)
  321: 
  322:         if self.end_date is not None:
  323:             end_date = self.end_date.tz_localize(start_date.tz)
  324: 
  325:         year_offset = DateOffset(years=1)
  326:         reference_start_date = Timestamp(
  327:             datetime(start_date.year - 1, self.month, self.day)
  328:         )
  329: 
  330:         reference_end_date = Timestamp(
  331:             datetime(end_date.year + 1, self.month, self.day)
  332:         )
  333:         # Don't process unnecessary holidays
  334:         dates = date_range(
  335:             start=reference_start_date,
  336:             end=reference_end_date,
  337:             freq=year_offset,
  338:             tz=start_date.tz,
  339:         )
  340: 
  341:         return dates
  342: 
  343:     def _apply_rule(self, dates: DatetimeIndex) -> DatetimeIndex:
  344:         """
  345:         Apply the given offset/observance to a DatetimeIndex of dates.
  346: 
  347:         Parameters
  348:         ----------
  349:         dates : DatetimeIndex
  350:             Dates to apply the given offset/observance rule
  351: 
  352:         Returns
  353:         -------
  354:         Dates with rules applied
  355:         """
  356:         if dates.empty:
  357:             return dates.copy()
  358: 
  359:         if self.observance is not None:
  360:             return dates.map(lambda d: self.observance(d))
  361: 
  362:         if self.offset is not None:
  363:             if not isinstance(self.offset, list):
  364:                 offsets = [self.offset]
  365:             else:
  366:                 offsets = self.offset
  367:             for offset in offsets:
  368:                 # if we are adding a non-vectorized value
  369:                 # ignore the PerformanceWarnings:
  370:                 with warnings.catch_warnings():
  371:                     warnings.simplefilter("ignore", PerformanceWarning)
  372:                     dates += offset
  373:         return dates
  374: 
  375: 
  376: holiday_calendars = {}
  377: 
  378: 
  379: def register(cls) -> None:
  380:     try:
  381:         name = cls.name
  382:     except AttributeError:
  383:         name = cls.__name__
  384:     holiday_calendars[name] = cls
  385: 
  386: 
  387: def get_calendar(name: str):
  388:     """
  389:     Return an instance of a calendar based on its name.
  390: 
  391:     Parameters
  392:     ----------
  393:     name : str
  394:         Calendar name to return an instance of
  395:     """
  396:     return holiday_calendars[name]()
  397: 
  398: 
  399: class HolidayCalendarMetaClass(type):
  400:     def __new__(cls, clsname: str, bases, attrs):
  401:         calendar_class = super().__new__(cls, clsname, bases, attrs)
  402:         register(calendar_class)
  403:         return calendar_class
  404: 
  405: 
  406: class AbstractHolidayCalendar(metaclass=HolidayCalendarMetaClass):
  407:     """
  408:     Abstract interface to create holidays following certain rules.
  409:     """
  410: 
  411:     rules: list[Holiday] = []
  412:     start_date = Timestamp(datetime(1970, 1, 1))
  413:     end_date = Timestamp(datetime(2200, 12, 31))
  414:     _cache = None
  415: 
  416:     def __init__(self, name: str = "", rules=None) -> None:
  417:         """
  418:         Initializes holiday object with a given set a rules.  Normally
  419:         classes just have the rules defined within them.
  420: 
  421:         Parameters
  422:         ----------
  423:         name : str
  424:             Name of the holiday calendar, defaults to class name
  425:         rules : array of Holiday objects
  426:             A set of rules used to create the holidays.
  427:         """
  428:         super().__init__()
  429:         if not name:
  430:             name = type(self).__name__
  431:         self.name = name
  432: 
  433:         if rules is not None:
  434:             self.rules = rules
  435: 
  436:     def rule_from_name(self, name: str):
  437:         for rule in self.rules:
  438:             if rule.name == name:
  439:                 return rule
  440: 
  441:         return None
  442: 
  443:     def holidays(self, start=None, end=None, return_name: bool = False):
  444:         """
  445:         Returns a curve with holidays between start_date and end_date
  446: 
  447:         Parameters
  448:         ----------
  449:         start : starting date, datetime-like, optional
  450:         end : ending date, datetime-like, optional
  451:         return_name : bool, optional
  452:             If True, return a series that has dates and holiday names.
  453:             False will only return a DatetimeIndex of dates.
  454: 
  455:         Returns
  456:         -------
  457:             DatetimeIndex of holidays
  458:         """
  459:         if self.rules is None:
  460:             raise Exception(
  461:                 f"Holiday Calendar {self.name} does not have any rules specified"
  462:             )
  463: 
  464:         if start is None:
  465:             start = AbstractHolidayCalendar.start_date
  466: 
  467:         if end is None:
  468:             end = AbstractHolidayCalendar.end_date
  469: 
  470:         start = Timestamp(start)
  471:         end = Timestamp(end)
  472: 
  473:         # If we don't have a cache or the dates are outside the prior cache, we
  474:         # get them again
  475:         if self._cache is None or start < self._cache[0] or end > self._cache[1]:
  476:             pre_holidays = [
  477:                 rule.dates(start, end, return_name=True) for rule in self.rules
  478:             ]
  479:             if pre_holidays:
  480:                 # error: Argument 1 to "concat" has incompatible type
  481:                 # "List[Union[Series, DatetimeIndex]]"; expected
  482:                 # "Union[Iterable[DataFrame], Mapping[<nothing>, DataFrame]]"
  483:                 holidays = concat(pre_holidays)  # type: ignore[arg-type]
  484:             else:
  485:                 # error: Incompatible types in assignment (expression has type
  486:                 # "Series", variable has type "DataFrame")
  487:                 holidays = Series(
  488:                     index=DatetimeIndex([]), dtype=object
  489:                 )  # type: ignore[assignment]
  490: 
  491:             self._cache = (start, end, holidays.sort_index())
  492: 
  493:         holidays = self._cache[2]
  494:         holidays = holidays[start:end]
  495: 
  496:         if return_name:
  497:             return holidays
  498:         else:
  499:             return holidays.index
  500: 
  501:     @staticmethod
  502:     def merge_class(base, other):
  503:         """
  504:         Merge holiday calendars together. The base calendar
  505:         will take precedence to other. The merge will be done
  506:         based on each holiday's name.
  507: 
  508:         Parameters
  509:         ----------
  510:         base : AbstractHolidayCalendar
  511:           instance/subclass or array of Holiday objects
  512:         other : AbstractHolidayCalendar
  513:           instance/subclass or array of Holiday objects
  514:         """
  515:         try:
  516:             other = other.rules
  517:         except AttributeError:
  518:             pass
  519: 
  520:         if not isinstance(other, list):
  521:             other = [other]
  522:         other_holidays = {holiday.name: holiday for holiday in other}
  523: 
  524:         try:
  525:             base = base.rules
  526:         except AttributeError:
  527:             pass
  528: 
  529:         if not isinstance(base, list):
  530:             base = [base]
  531:         base_holidays = {holiday.name: holiday for holiday in base}
  532: 
  533:         other_holidays.update(base_holidays)
  534:         return list(other_holidays.values())
  535: 
  536:     def merge(self, other, inplace: bool = False):
  537:         """
  538:         Merge holiday calendars together.  The caller's class
  539:         rules take precedence.  The merge will be done
  540:         based on each holiday's name.
  541: 
  542:         Parameters
  543:         ----------
  544:         other : holiday calendar
  545:         inplace : bool (default=False)
  546:             If True set rule_table to holidays, else return array of Holidays
  547:         """
  548:         holidays = self.merge_class(self, other)
  549:         if inplace:
  550:             self.rules = holidays
  551:         else:
  552:             return holidays
  553: 
  554: 
  555: USMemorialDay = Holiday(
  556:     "Memorial Day", month=5, day=31, offset=DateOffset(weekday=MO(-1))
  557: )
  558: USLaborDay = Holiday("Labor Day", month=9, day=1, offset=DateOffset(weekday=MO(1)))
  559: USColumbusDay = Holiday(
  560:     "Columbus Day", month=10, day=1, offset=DateOffset(weekday=MO(2))
  561: )
  562: USThanksgivingDay = Holiday(
  563:     "Thanksgiving Day", month=11, day=1, offset=DateOffset(weekday=TH(4))
  564: )
  565: USMartinLutherKingJr = Holiday(
  566:     "Birthday of Martin Luther King, Jr.",
  567:     start_date=datetime(1986, 1, 1),
  568:     month=1,
  569:     day=1,
  570:     offset=DateOffset(weekday=MO(3)),
  571: )
  572: USPresidentsDay = Holiday(
  573:     "Washington's Birthday", month=2, day=1, offset=DateOffset(weekday=MO(3))
  574: )
  575: GoodFriday = Holiday("Good Friday", month=1, day=1, offset=[Easter(), Day(-2)])
  576: 
  577: EasterMonday = Holiday("Easter Monday", month=1, day=1, offset=[Easter(), Day(1)])
  578: 
  579: 
  580: class USFederalHolidayCalendar(AbstractHolidayCalendar):
  581:     """
  582:     US Federal Government Holiday Calendar based on rules specified by:
  583:     https://www.opm.gov/policy-data-oversight/pay-leave/federal-holidays/
  584:     """
  585: 
  586:     rules = [
  587:         Holiday("New Year's Day", month=1, day=1, observance=nearest_workday),
  588:         USMartinLutherKingJr,
  589:         USPresidentsDay,
  590:         USMemorialDay,
  591:         Holiday(
  592:             "Juneteenth National Independence Day",
  593:             month=6,
  594:             day=19,
  595:             start_date="2021-06-18",
  596:             observance=nearest_workday,
  597:         ),
  598:         Holiday("Independence Day", month=7, day=4, observance=nearest_workday),
  599:         USLaborDay,
  600:         USColumbusDay,
  601:         Holiday("Veterans Day", month=11, day=11, observance=nearest_workday),
  602:         USThanksgivingDay,
  603:         Holiday("Christmas Day", month=12, day=25, observance=nearest_workday),
  604:     ]
  605: 
  606: 
  607: def HolidayCalendarFactory(name: str, base, other, base_class=AbstractHolidayCalendar):
  608:     rules = AbstractHolidayCalendar.merge_class(base, other)
  609:     calendar_class = type(name, (base_class,), {"rules": rules, "name": name})
  610:     return calendar_class
  611: 
  612: 
  613: __all__ = [
  614:     "after_nearest_workday",
  615:     "before_nearest_workday",
  616:     "FR",
  617:     "get_calendar",
  618:     "HolidayCalendarFactory",
  619:     "MO",
  620:     "nearest_workday",
  621:     "next_monday",
  622:     "next_monday_or_tuesday",
  623:     "next_workday",
  624:     "previous_friday",
  625:     "previous_workday",
  626:     "register",
  627:     "SA",
  628:     "SU",
  629:     "sunday_to_monday",
  630:     "TH",
  631:     "TU",
  632:     "WE",
  633:     "weekend_to_monday",
  634: ]
