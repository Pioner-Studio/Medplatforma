    1: """
    2: :mod:`pandas.io.formats.xml` is a module for formatting data in XML.
    3: """
    4: from __future__ import annotations
    5: 
    6: import codecs
    7: import io
    8: from typing import (
    9:     TYPE_CHECKING,
   10:     Any,
   11:     final,
   12: )
   13: import warnings
   14: 
   15: from pandas.errors import AbstractMethodError
   16: from pandas.util._decorators import (
   17:     cache_readonly,
   18:     doc,
   19: )
   20: 
   21: from pandas.core.dtypes.common import is_list_like
   22: from pandas.core.dtypes.missing import isna
   23: 
   24: from pandas.core.shared_docs import _shared_docs
   25: 
   26: from pandas.io.common import get_handle
   27: from pandas.io.xml import (
   28:     get_data_from_filepath,
   29:     preprocess_data,
   30: )
   31: 
   32: if TYPE_CHECKING:
   33:     from pandas._typing import (
   34:         CompressionOptions,
   35:         FilePath,
   36:         ReadBuffer,
   37:         StorageOptions,
   38:         WriteBuffer,
   39:     )
   40: 
   41:     from pandas import DataFrame
   42: 
   43: 
   44: @doc(
   45:     storage_options=_shared_docs["storage_options"],
   46:     compression_options=_shared_docs["compression_options"] % "path_or_buffer",
   47: )
   48: class _BaseXMLFormatter:
   49:     """
   50:     Subclass for formatting data in XML.
   51: 
   52:     Parameters
   53:     ----------
   54:     path_or_buffer : str or file-like
   55:         This can be either a string of raw XML, a valid URL,
   56:         file or file-like object.
   57: 
   58:     index : bool
   59:         Whether to include index in xml document.
   60: 
   61:     row_name : str
   62:         Name for root of xml document. Default is 'data'.
   63: 
   64:     root_name : str
   65:         Name for row elements of xml document. Default is 'row'.
   66: 
   67:     na_rep : str
   68:         Missing data representation.
   69: 
   70:     attrs_cols : list
   71:         List of columns to write as attributes in row element.
   72: 
   73:     elem_cols : list
   74:         List of columns to write as children in row element.
   75: 
   76:     namespaces : dict
   77:         The namespaces to define in XML document as dicts with key
   78:         being namespace and value the URI.
   79: 
   80:     prefix : str
   81:         The prefix for each element in XML document including root.
   82: 
   83:     encoding : str
   84:         Encoding of xml object or document.
   85: 
   86:     xml_declaration : bool
   87:         Whether to include xml declaration at top line item in xml.
   88: 
   89:     pretty_print : bool
   90:         Whether to write xml document with line breaks and indentation.
   91: 
   92:     stylesheet : str or file-like
   93:         A URL, file, file-like object, or a raw string containing XSLT.
   94: 
   95:     {compression_options}
   96: 
   97:         .. versionchanged:: 1.4.0 Zstandard support.
   98: 
   99:     {storage_options}
  100: 
  101:     See also
  102:     --------
  103:     pandas.io.formats.xml.EtreeXMLFormatter
  104:     pandas.io.formats.xml.LxmlXMLFormatter
  105: 
  106:     """
  107: 
  108:     def __init__(
  109:         self,
  110:         frame: DataFrame,
  111:         path_or_buffer: FilePath | WriteBuffer[bytes] | WriteBuffer[str] | None = None,
  112:         index: bool = True,
  113:         root_name: str | None = "data",
  114:         row_name: str | None = "row",
  115:         na_rep: str | None = None,
  116:         attr_cols: list[str] | None = None,
  117:         elem_cols: list[str] | None = None,
  118:         namespaces: dict[str | None, str] | None = None,
  119:         prefix: str | None = None,
  120:         encoding: str = "utf-8",
  121:         xml_declaration: bool | None = True,
  122:         pretty_print: bool | None = True,
  123:         stylesheet: FilePath | ReadBuffer[str] | ReadBuffer[bytes] | None = None,
  124:         compression: CompressionOptions = "infer",
  125:         storage_options: StorageOptions | None = None,
  126:     ) -> None:
  127:         self.frame = frame
  128:         self.path_or_buffer = path_or_buffer
  129:         self.index = index
  130:         self.root_name = root_name
  131:         self.row_name = row_name
  132:         self.na_rep = na_rep
  133:         self.attr_cols = attr_cols
  134:         self.elem_cols = elem_cols
  135:         self.namespaces = namespaces
  136:         self.prefix = prefix
  137:         self.encoding = encoding
  138:         self.xml_declaration = xml_declaration
  139:         self.pretty_print = pretty_print
  140:         self.stylesheet = stylesheet
  141:         self.compression: CompressionOptions = compression
  142:         self.storage_options = storage_options
  143: 
  144:         self.orig_cols = self.frame.columns.tolist()
  145:         self.frame_dicts = self._process_dataframe()
  146: 
  147:         self._validate_columns()
  148:         self._validate_encoding()
  149:         self.prefix_uri = self._get_prefix_uri()
  150:         self._handle_indexes()
  151: 
  152:     def _build_tree(self) -> bytes:
  153:         """
  154:         Build tree from  data.
  155: 
  156:         This method initializes the root and builds attributes and elements
  157:         with optional namespaces.
  158:         """
  159:         raise AbstractMethodError(self)
  160: 
  161:     @final
  162:     def _validate_columns(self) -> None:
  163:         """
  164:         Validate elems_cols and attrs_cols.
  165: 
  166:         This method will check if columns is list-like.
  167: 
  168:         Raises
  169:         ------
  170:         ValueError
  171:             * If value is not a list and less then length of nodes.
  172:         """
  173:         if self.attr_cols and not is_list_like(self.attr_cols):
  174:             raise TypeError(
  175:                 f"{type(self.attr_cols).__name__} is not a valid type for attr_cols"
  176:             )
  177: 
  178:         if self.elem_cols and not is_list_like(self.elem_cols):
  179:             raise TypeError(
  180:                 f"{type(self.elem_cols).__name__} is not a valid type for elem_cols"
  181:             )
  182: 
  183:     @final
  184:     def _validate_encoding(self) -> None:
  185:         """
  186:         Validate encoding.
  187: 
  188:         This method will check if encoding is among listed under codecs.
  189: 
  190:         Raises
  191:         ------
  192:         LookupError
  193:             * If encoding is not available in codecs.
  194:         """
  195: 
  196:         codecs.lookup(self.encoding)
  197: 
  198:     @final
  199:     def _process_dataframe(self) -> dict[int | str, dict[str, Any]]:
  200:         """
  201:         Adjust Data Frame to fit xml output.
  202: 
  203:         This method will adjust underlying data frame for xml output,
  204:         including optionally replacing missing values and including indexes.
  205:         """
  206: 
  207:         df = self.frame
  208: 
  209:         if self.index:
  210:             df = df.reset_index()
  211: 
  212:         if self.na_rep is not None:
  213:             with warnings.catch_warnings():
  214:                 warnings.filterwarnings(
  215:                     "ignore",
  216:                     "Downcasting object dtype arrays",
  217:                     category=FutureWarning,
  218:                 )
  219:                 df = df.fillna(self.na_rep)
  220: 
  221:         return df.to_dict(orient="index")
  222: 
  223:     @final
  224:     def _handle_indexes(self) -> None:
  225:         """
  226:         Handle indexes.
  227: 
  228:         This method will add indexes into attr_cols or elem_cols.
  229:         """
  230: 
  231:         if not self.index:
  232:             return
  233: 
  234:         first_key = next(iter(self.frame_dicts))
  235:         indexes: list[str] = [
  236:             x for x in self.frame_dicts[first_key].keys() if x not in self.orig_cols
  237:         ]
  238: 
  239:         if self.attr_cols:
  240:             self.attr_cols = indexes + self.attr_cols
  241: 
  242:         if self.elem_cols:
  243:             self.elem_cols = indexes + self.elem_cols
  244: 
  245:     def _get_prefix_uri(self) -> str:
  246:         """
  247:         Get uri of namespace prefix.
  248: 
  249:         This method retrieves corresponding URI to prefix in namespaces.
  250: 
  251:         Raises
  252:         ------
  253:         KeyError
  254:             *If prefix is not included in namespace dict.
  255:         """
  256: 
  257:         raise AbstractMethodError(self)
  258: 
  259:     @final
  260:     def _other_namespaces(self) -> dict:
  261:         """
  262:         Define other namespaces.
  263: 
  264:         This method will build dictionary of namespaces attributes
  265:         for root element, conditionally with optional namespaces and
  266:         prefix.
  267:         """
  268: 
  269:         nmsp_dict: dict[str, str] = {}
  270:         if self.namespaces:
  271:             nmsp_dict = {
  272:                 f"xmlns{p if p=='' else f':{p}'}": n
  273:                 for p, n in self.namespaces.items()
  274:                 if n != self.prefix_uri[1:-1]
  275:             }
  276: 
  277:         return nmsp_dict
  278: 
  279:     @final
  280:     def _build_attribs(self, d: dict[str, Any], elem_row: Any) -> Any:
  281:         """
  282:         Create attributes of row.
  283: 
  284:         This method adds attributes using attr_cols to row element and
  285:         works with tuples for multindex or hierarchical columns.
  286:         """
  287: 
  288:         if not self.attr_cols:
  289:             return elem_row
  290: 
  291:         for col in self.attr_cols:
  292:             attr_name = self._get_flat_col_name(col)
  293:             try:
  294:                 if not isna(d[col]):
  295:                     elem_row.attrib[attr_name] = str(d[col])
  296:             except KeyError:
  297:                 raise KeyError(f"no valid column, {col}")
  298:         return elem_row
  299: 
  300:     @final
  301:     def _get_flat_col_name(self, col: str | tuple) -> str:
  302:         flat_col = col
  303:         if isinstance(col, tuple):
  304:             flat_col = (
  305:                 "".join([str(c) for c in col]).strip()
  306:                 if "" in col
  307:                 else "_".join([str(c) for c in col]).strip()
  308:             )
  309:         return f"{self.prefix_uri}{flat_col}"
  310: 
  311:     @cache_readonly
  312:     def _sub_element_cls(self):
  313:         raise AbstractMethodError(self)
  314: 
  315:     @final
  316:     def _build_elems(self, d: dict[str, Any], elem_row: Any) -> None:
  317:         """
  318:         Create child elements of row.
  319: 
  320:         This method adds child elements using elem_cols to row element and
  321:         works with tuples for multindex or hierarchical columns.
  322:         """
  323:         sub_element_cls = self._sub_element_cls
  324: 
  325:         if not self.elem_cols:
  326:             return
  327: 
  328:         for col in self.elem_cols:
  329:             elem_name = self._get_flat_col_name(col)
  330:             try:
  331:                 val = None if isna(d[col]) or d[col] == "" else str(d[col])
  332:                 sub_element_cls(elem_row, elem_name).text = val
  333:             except KeyError:
  334:                 raise KeyError(f"no valid column, {col}")
  335: 
  336:     @final
  337:     def write_output(self) -> str | None:
  338:         xml_doc = self._build_tree()
  339: 
  340:         if self.path_or_buffer is not None:
  341:             with get_handle(
  342:                 self.path_or_buffer,
  343:                 "wb",
  344:                 compression=self.compression,
  345:                 storage_options=self.storage_options,
  346:                 is_text=False,
  347:             ) as handles:
  348:                 handles.handle.write(xml_doc)
  349:             return None
  350: 
  351:         else:
  352:             return xml_doc.decode(self.encoding).rstrip()
  353: 
  354: 
  355: class EtreeXMLFormatter(_BaseXMLFormatter):
  356:     """
  357:     Class for formatting data in xml using Python standard library
  358:     modules: `xml.etree.ElementTree` and `xml.dom.minidom`.
  359:     """
  360: 
  361:     def _build_tree(self) -> bytes:
  362:         from xml.etree.ElementTree import (
  363:             Element,
  364:             SubElement,
  365:             tostring,
  366:         )
  367: 
  368:         self.root = Element(
  369:             f"{self.prefix_uri}{self.root_name}", attrib=self._other_namespaces()
  370:         )
  371: 
  372:         for d in self.frame_dicts.values():
  373:             elem_row = SubElement(self.root, f"{self.prefix_uri}{self.row_name}")
  374: 
  375:             if not self.attr_cols and not self.elem_cols:
  376:                 self.elem_cols = list(d.keys())
  377:                 self._build_elems(d, elem_row)
  378: 
  379:             else:
  380:                 elem_row = self._build_attribs(d, elem_row)
  381:                 self._build_elems(d, elem_row)
  382: 
  383:         self.out_xml = tostring(
  384:             self.root,
  385:             method="xml",
  386:             encoding=self.encoding,
  387:             xml_declaration=self.xml_declaration,
  388:         )
  389: 
  390:         if self.pretty_print:
  391:             self.out_xml = self._prettify_tree()
  392: 
  393:         if self.stylesheet is not None:
  394:             raise ValueError(
  395:                 "To use stylesheet, you need lxml installed and selected as parser."
  396:             )
  397: 
  398:         return self.out_xml
  399: 
  400:     def _get_prefix_uri(self) -> str:
  401:         from xml.etree.ElementTree import register_namespace
  402: 
  403:         uri = ""
  404:         if self.namespaces:
  405:             for p, n in self.namespaces.items():
  406:                 if isinstance(p, str) and isinstance(n, str):
  407:                     register_namespace(p, n)
  408:             if self.prefix:
  409:                 try:
  410:                     uri = f"{{{self.namespaces[self.prefix]}}}"
  411:                 except KeyError:
  412:                     raise KeyError(f"{self.prefix} is not included in namespaces")
  413:             elif "" in self.namespaces:
  414:                 uri = f'{{{self.namespaces[""]}}}'
  415:             else:
  416:                 uri = ""
  417: 
  418:         return uri
  419: 
  420:     @cache_readonly
  421:     def _sub_element_cls(self):
  422:         from xml.etree.ElementTree import SubElement
  423: 
  424:         return SubElement
  425: 
  426:     def _prettify_tree(self) -> bytes:
  427:         """
  428:         Output tree for pretty print format.
  429: 
  430:         This method will pretty print xml with line breaks and indentation.
  431:         """
  432: 
  433:         from xml.dom.minidom import parseString
  434: 
  435:         dom = parseString(self.out_xml)
  436: 
  437:         return dom.toprettyxml(indent="  ", encoding=self.encoding)
  438: 
  439: 
  440: class LxmlXMLFormatter(_BaseXMLFormatter):
  441:     """
  442:     Class for formatting data in xml using Python standard library
  443:     modules: `xml.etree.ElementTree` and `xml.dom.minidom`.
  444:     """
  445: 
  446:     def __init__(self, *args, **kwargs) -> None:
  447:         super().__init__(*args, **kwargs)
  448: 
  449:         self._convert_empty_str_key()
  450: 
  451:     def _build_tree(self) -> bytes:
  452:         """
  453:         Build tree from  data.
  454: 
  455:         This method initializes the root and builds attributes and elements
  456:         with optional namespaces.
  457:         """
  458:         from lxml.etree import (
  459:             Element,
  460:             SubElement,
  461:             tostring,
  462:         )
  463: 
  464:         self.root = Element(f"{self.prefix_uri}{self.root_name}", nsmap=self.namespaces)
  465: 
  466:         for d in self.frame_dicts.values():
  467:             elem_row = SubElement(self.root, f"{self.prefix_uri}{self.row_name}")
  468: 
  469:             if not self.attr_cols and not self.elem_cols:
  470:                 self.elem_cols = list(d.keys())
  471:                 self._build_elems(d, elem_row)
  472: 
  473:             else:
  474:                 elem_row = self._build_attribs(d, elem_row)
  475:                 self._build_elems(d, elem_row)
  476: 
  477:         self.out_xml = tostring(
  478:             self.root,
  479:             pretty_print=self.pretty_print,
  480:             method="xml",
  481:             encoding=self.encoding,
  482:             xml_declaration=self.xml_declaration,
  483:         )
  484: 
  485:         if self.stylesheet is not None:
  486:             self.out_xml = self._transform_doc()
  487: 
  488:         return self.out_xml
  489: 
  490:     def _convert_empty_str_key(self) -> None:
  491:         """
  492:         Replace zero-length string in `namespaces`.
  493: 
  494:         This method will replace '' with None to align to `lxml`
  495:         requirement that empty string prefixes are not allowed.
  496:         """
  497: 
  498:         if self.namespaces and "" in self.namespaces.keys():
  499:             self.namespaces[None] = self.namespaces.pop("", "default")
  500: 
  501:     def _get_prefix_uri(self) -> str:
  502:         uri = ""
  503:         if self.namespaces:
  504:             if self.prefix:
  505:                 try:
  506:                     uri = f"{{{self.namespaces[self.prefix]}}}"
  507:                 except KeyError:
  508:                     raise KeyError(f"{self.prefix} is not included in namespaces")
  509:             elif "" in self.namespaces:
  510:                 uri = f'{{{self.namespaces[""]}}}'
  511:             else:
  512:                 uri = ""
  513: 
  514:         return uri
  515: 
  516:     @cache_readonly
  517:     def _sub_element_cls(self):
  518:         from lxml.etree import SubElement
  519: 
  520:         return SubElement
  521: 
  522:     def _transform_doc(self) -> bytes:
  523:         """
  524:         Parse stylesheet from file or buffer and run it.
  525: 
  526:         This method will parse stylesheet object into tree for parsing
  527:         conditionally by its specific object type, then transforms
  528:         original tree with XSLT script.
  529:         """
  530:         from lxml.etree import (
  531:             XSLT,
  532:             XMLParser,
  533:             fromstring,
  534:             parse,
  535:         )
  536: 
  537:         style_doc = self.stylesheet
  538:         assert style_doc is not None  # is ensured by caller
  539: 
  540:         handle_data = get_data_from_filepath(
  541:             filepath_or_buffer=style_doc,
  542:             encoding=self.encoding,
  543:             compression=self.compression,
  544:             storage_options=self.storage_options,
  545:         )
  546: 
  547:         with preprocess_data(handle_data) as xml_data:
  548:             curr_parser = XMLParser(encoding=self.encoding)
  549: 
  550:             if isinstance(xml_data, io.StringIO):
  551:                 xsl_doc = fromstring(
  552:                     xml_data.getvalue().encode(self.encoding), parser=curr_parser
  553:                 )
  554:             else:
  555:                 xsl_doc = parse(xml_data, parser=curr_parser)
  556: 
  557:         transformer = XSLT(xsl_doc)
  558:         new_doc = transformer(self.root)
  559: 
  560:         return bytes(new_doc)
