    1: """
    2: Utilities for conversion to writer-agnostic Excel representation.
    3: """
    4: from __future__ import annotations
    5: 
    6: from collections.abc import (
    7:     Hashable,
    8:     Iterable,
    9:     Mapping,
   10:     Sequence,
   11: )
   12: import functools
   13: import itertools
   14: import re
   15: from typing import (
   16:     TYPE_CHECKING,
   17:     Any,
   18:     Callable,
   19:     cast,
   20: )
   21: import warnings
   22: 
   23: import numpy as np
   24: 
   25: from pandas._libs.lib import is_list_like
   26: from pandas.util._decorators import doc
   27: from pandas.util._exceptions import find_stack_level
   28: 
   29: from pandas.core.dtypes import missing
   30: from pandas.core.dtypes.common import (
   31:     is_float,
   32:     is_scalar,
   33: )
   34: 
   35: from pandas import (
   36:     DataFrame,
   37:     Index,
   38:     MultiIndex,
   39:     PeriodIndex,
   40: )
   41: import pandas.core.common as com
   42: from pandas.core.shared_docs import _shared_docs
   43: 
   44: from pandas.io.formats._color_data import CSS4_COLORS
   45: from pandas.io.formats.css import (
   46:     CSSResolver,
   47:     CSSWarning,
   48: )
   49: from pandas.io.formats.format import get_level_lengths
   50: from pandas.io.formats.printing import pprint_thing
   51: 
   52: if TYPE_CHECKING:
   53:     from pandas._typing import (
   54:         FilePath,
   55:         IndexLabel,
   56:         StorageOptions,
   57:         WriteExcelBuffer,
   58:     )
   59: 
   60:     from pandas import ExcelWriter
   61: 
   62: 
   63: class ExcelCell:
   64:     __fields__ = ("row", "col", "val", "style", "mergestart", "mergeend")
   65:     __slots__ = __fields__
   66: 
   67:     def __init__(
   68:         self,
   69:         row: int,
   70:         col: int,
   71:         val,
   72:         style=None,
   73:         mergestart: int | None = None,
   74:         mergeend: int | None = None,
   75:     ) -> None:
   76:         self.row = row
   77:         self.col = col
   78:         self.val = val
   79:         self.style = style
   80:         self.mergestart = mergestart
   81:         self.mergeend = mergeend
   82: 
   83: 
   84: class CssExcelCell(ExcelCell):
   85:     def __init__(
   86:         self,
   87:         row: int,
   88:         col: int,
   89:         val,
   90:         style: dict | None,
   91:         css_styles: dict[tuple[int, int], list[tuple[str, Any]]] | None,
   92:         css_row: int,
   93:         css_col: int,
   94:         css_converter: Callable | None,
   95:         **kwargs,
   96:     ) -> None:
   97:         if css_styles and css_converter:
   98:             # Use dict to get only one (case-insensitive) declaration per property
   99:             declaration_dict = {
  100:                 prop.lower(): val for prop, val in css_styles[css_row, css_col]
  101:             }
  102:             # Convert to frozenset for order-invariant caching
  103:             unique_declarations = frozenset(declaration_dict.items())
  104:             style = css_converter(unique_declarations)
  105: 
  106:         super().__init__(row=row, col=col, val=val, style=style, **kwargs)
  107: 
  108: 
  109: class CSSToExcelConverter:
  110:     """
  111:     A callable for converting CSS declarations to ExcelWriter styles
  112: 
  113:     Supports parts of CSS 2.2, with minimal CSS 3.0 support (e.g. text-shadow),
  114:     focusing on font styling, backgrounds, borders and alignment.
  115: 
  116:     Operates by first computing CSS styles in a fairly generic
  117:     way (see :meth:`compute_css`) then determining Excel style
  118:     properties from CSS properties (see :meth:`build_xlstyle`).
  119: 
  120:     Parameters
  121:     ----------
  122:     inherited : str, optional
  123:         CSS declarations understood to be the containing scope for the
  124:         CSS processed by :meth:`__call__`.
  125:     """
  126: 
  127:     NAMED_COLORS = CSS4_COLORS
  128: 
  129:     VERTICAL_MAP = {
  130:         "top": "top",
  131:         "text-top": "top",
  132:         "middle": "center",
  133:         "baseline": "bottom",
  134:         "bottom": "bottom",
  135:         "text-bottom": "bottom",
  136:         # OpenXML also has 'justify', 'distributed'
  137:     }
  138: 
  139:     BOLD_MAP = {
  140:         "bold": True,
  141:         "bolder": True,
  142:         "600": True,
  143:         "700": True,
  144:         "800": True,
  145:         "900": True,
  146:         "normal": False,
  147:         "lighter": False,
  148:         "100": False,
  149:         "200": False,
  150:         "300": False,
  151:         "400": False,
  152:         "500": False,
  153:     }
  154: 
  155:     ITALIC_MAP = {
  156:         "normal": False,
  157:         "italic": True,
  158:         "oblique": True,
  159:     }
  160: 
  161:     FAMILY_MAP = {
  162:         "serif": 1,  # roman
  163:         "sans-serif": 2,  # swiss
  164:         "cursive": 4,  # script
  165:         "fantasy": 5,  # decorative
  166:     }
  167: 
  168:     BORDER_STYLE_MAP = {
  169:         style.lower(): style
  170:         for style in [
  171:             "dashed",
  172:             "mediumDashDot",
  173:             "dashDotDot",
  174:             "hair",
  175:             "dotted",
  176:             "mediumDashDotDot",
  177:             "double",
  178:             "dashDot",
  179:             "slantDashDot",
  180:             "mediumDashed",
  181:         ]
  182:     }
  183: 
  184:     # NB: Most of the methods here could be classmethods, as only __init__
  185:     #     and __call__ make use of instance attributes.  We leave them as
  186:     #     instancemethods so that users can easily experiment with extensions
  187:     #     without monkey-patching.
  188:     inherited: dict[str, str] | None
  189: 
  190:     def __init__(self, inherited: str | None = None) -> None:
  191:         if inherited is not None:
  192:             self.inherited = self.compute_css(inherited)
  193:         else:
  194:             self.inherited = None
  195:         # We should avoid cache on the __call__ method.
  196:         # Otherwise once the method __call__ has been called
  197:         # garbage collection no longer deletes the instance.
  198:         self._call_cached = functools.cache(self._call_uncached)
  199: 
  200:     compute_css = CSSResolver()
  201: 
  202:     def __call__(
  203:         self, declarations: str | frozenset[tuple[str, str]]
  204:     ) -> dict[str, dict[str, str]]:
  205:         """
  206:         Convert CSS declarations to ExcelWriter style.
  207: 
  208:         Parameters
  209:         ----------
  210:         declarations : str | frozenset[tuple[str, str]]
  211:             CSS string or set of CSS declaration tuples.
  212:             e.g. "font-weight: bold; background: blue" or
  213:             {("font-weight", "bold"), ("background", "blue")}
  214: 
  215:         Returns
  216:         -------
  217:         xlstyle : dict
  218:             A style as interpreted by ExcelWriter when found in
  219:             ExcelCell.style.
  220:         """
  221:         return self._call_cached(declarations)
  222: 
  223:     def _call_uncached(
  224:         self, declarations: str | frozenset[tuple[str, str]]
  225:     ) -> dict[str, dict[str, str]]:
  226:         properties = self.compute_css(declarations, self.inherited)
  227:         return self.build_xlstyle(properties)
  228: 
  229:     def build_xlstyle(self, props: Mapping[str, str]) -> dict[str, dict[str, str]]:
  230:         out = {
  231:             "alignment": self.build_alignment(props),
  232:             "border": self.build_border(props),
  233:             "fill": self.build_fill(props),
  234:             "font": self.build_font(props),
  235:             "number_format": self.build_number_format(props),
  236:         }
  237: 
  238:         # TODO: handle cell width and height: needs support in pandas.io.excel
  239: 
  240:         def remove_none(d: dict[str, str | None]) -> None:
  241:             """Remove key where value is None, through nested dicts"""
  242:             for k, v in list(d.items()):
  243:                 if v is None:
  244:                     del d[k]
  245:                 elif isinstance(v, dict):
  246:                     remove_none(v)
  247:                     if not v:
  248:                         del d[k]
  249: 
  250:         remove_none(out)
  251:         return out
  252: 
  253:     def build_alignment(self, props: Mapping[str, str]) -> dict[str, bool | str | None]:
  254:         # TODO: text-indent, padding-left -> alignment.indent
  255:         return {
  256:             "horizontal": props.get("text-align"),
  257:             "vertical": self._get_vertical_alignment(props),
  258:             "wrap_text": self._get_is_wrap_text(props),
  259:         }
  260: 
  261:     def _get_vertical_alignment(self, props: Mapping[str, str]) -> str | None:
  262:         vertical_align = props.get("vertical-align")
  263:         if vertical_align:
  264:             return self.VERTICAL_MAP.get(vertical_align)
  265:         return None
  266: 
  267:     def _get_is_wrap_text(self, props: Mapping[str, str]) -> bool | None:
  268:         if props.get("white-space") is None:
  269:             return None
  270:         return bool(props["white-space"] not in ("nowrap", "pre", "pre-line"))
  271: 
  272:     def build_border(
  273:         self, props: Mapping[str, str]
  274:     ) -> dict[str, dict[str, str | None]]:
  275:         return {
  276:             side: {
  277:                 "style": self._border_style(
  278:                     props.get(f"border-{side}-style"),
  279:                     props.get(f"border-{side}-width"),
  280:                     self.color_to_excel(props.get(f"border-{side}-color")),
  281:                 ),
  282:                 "color": self.color_to_excel(props.get(f"border-{side}-color")),
  283:             }
  284:             for side in ["top", "right", "bottom", "left"]
  285:         }
  286: 
  287:     def _border_style(self, style: str | None, width: str | None, color: str | None):
  288:         # convert styles and widths to openxml, one of:
  289:         #       'dashDot'
  290:         #       'dashDotDot'
  291:         #       'dashed'
  292:         #       'dotted'
  293:         #       'double'
  294:         #       'hair'
  295:         #       'medium'
  296:         #       'mediumDashDot'
  297:         #       'mediumDashDotDot'
  298:         #       'mediumDashed'
  299:         #       'slantDashDot'
  300:         #       'thick'
  301:         #       'thin'
  302:         if width is None and style is None and color is None:
  303:             # Return None will remove "border" from style dictionary
  304:             return None
  305: 
  306:         if width is None and style is None:
  307:             # Return "none" will keep "border" in style dictionary
  308:             return "none"
  309: 
  310:         if style in ("none", "hidden"):
  311:             return "none"
  312: 
  313:         width_name = self._get_width_name(width)
  314:         if width_name is None:
  315:             return "none"
  316: 
  317:         if style in (None, "groove", "ridge", "inset", "outset", "solid"):
  318:             # not handled
  319:             return width_name
  320: 
  321:         if style == "double":
  322:             return "double"
  323:         if style == "dotted":
  324:             if width_name in ("hair", "thin"):
  325:                 return "dotted"
  326:             return "mediumDashDotDot"
  327:         if style == "dashed":
  328:             if width_name in ("hair", "thin"):
  329:                 return "dashed"
  330:             return "mediumDashed"
  331:         elif style in self.BORDER_STYLE_MAP:
  332:             # Excel-specific styles
  333:             return self.BORDER_STYLE_MAP[style]
  334:         else:
  335:             warnings.warn(
  336:                 f"Unhandled border style format: {repr(style)}",
  337:                 CSSWarning,
  338:                 stacklevel=find_stack_level(),
  339:             )
  340:             return "none"
  341: 
  342:     def _get_width_name(self, width_input: str | None) -> str | None:
  343:         width = self._width_to_float(width_input)
  344:         if width < 1e-5:
  345:             return None
  346:         elif width < 1.3:
  347:             return "thin"
  348:         elif width < 2.8:
  349:             return "medium"
  350:         return "thick"
  351: 
  352:     def _width_to_float(self, width: str | None) -> float:
  353:         if width is None:
  354:             width = "2pt"
  355:         return self._pt_to_float(width)
  356: 
  357:     def _pt_to_float(self, pt_string: str) -> float:
  358:         assert pt_string.endswith("pt")
  359:         return float(pt_string.rstrip("pt"))
  360: 
  361:     def build_fill(self, props: Mapping[str, str]):
  362:         # TODO: perhaps allow for special properties
  363:         #       -excel-pattern-bgcolor and -excel-pattern-type
  364:         fill_color = props.get("background-color")
  365:         if fill_color not in (None, "transparent", "none"):
  366:             return {"fgColor": self.color_to_excel(fill_color), "patternType": "solid"}
  367: 
  368:     def build_number_format(self, props: Mapping[str, str]) -> dict[str, str | None]:
  369:         fc = props.get("number-format")
  370:         fc = fc.replace("В§", ";") if isinstance(fc, str) else fc
  371:         return {"format_code": fc}
  372: 
  373:     def build_font(
  374:         self, props: Mapping[str, str]
  375:     ) -> dict[str, bool | float | str | None]:
  376:         font_names = self._get_font_names(props)
  377:         decoration = self._get_decoration(props)
  378:         return {
  379:             "name": font_names[0] if font_names else None,
  380:             "family": self._select_font_family(font_names),
  381:             "size": self._get_font_size(props),
  382:             "bold": self._get_is_bold(props),
  383:             "italic": self._get_is_italic(props),
  384:             "underline": ("single" if "underline" in decoration else None),
  385:             "strike": ("line-through" in decoration) or None,
  386:             "color": self.color_to_excel(props.get("color")),
  387:             # shadow if nonzero digit before shadow color
  388:             "shadow": self._get_shadow(props),
  389:         }
  390: 
  391:     def _get_is_bold(self, props: Mapping[str, str]) -> bool | None:
  392:         weight = props.get("font-weight")
  393:         if weight:
  394:             return self.BOLD_MAP.get(weight)
  395:         return None
  396: 
  397:     def _get_is_italic(self, props: Mapping[str, str]) -> bool | None:
  398:         font_style = props.get("font-style")
  399:         if font_style:
  400:             return self.ITALIC_MAP.get(font_style)
  401:         return None
  402: 
  403:     def _get_decoration(self, props: Mapping[str, str]) -> Sequence[str]:
  404:         decoration = props.get("text-decoration")
  405:         if decoration is not None:
  406:             return decoration.split()
  407:         else:
  408:             return ()
  409: 
  410:     def _get_underline(self, decoration: Sequence[str]) -> str | None:
  411:         if "underline" in decoration:
  412:             return "single"
  413:         return None
  414: 
  415:     def _get_shadow(self, props: Mapping[str, str]) -> bool | None:
  416:         if "text-shadow" in props:
  417:             return bool(re.search("^[^#(]*[1-9]", props["text-shadow"]))
  418:         return None
  419: 
  420:     def _get_font_names(self, props: Mapping[str, str]) -> Sequence[str]:
  421:         font_names_tmp = re.findall(
  422:             r"""(?x)
  423:             (
  424:             "(?:[^"]|\\")+"
  425:             |
  426:             '(?:[^']|\\')+'
  427:             |
  428:             [^'",]+
  429:             )(?=,|\s*$)
  430:         """,
  431:             props.get("font-family", ""),
  432:         )
  433: 
  434:         font_names = []
  435:         for name in font_names_tmp:
  436:             if name[:1] == '"':
  437:                 name = name[1:-1].replace('\\"', '"')
  438:             elif name[:1] == "'":
  439:                 name = name[1:-1].replace("\\'", "'")
  440:             else:
  441:                 name = name.strip()
  442:             if name:
  443:                 font_names.append(name)
  444:         return font_names
  445: 
  446:     def _get_font_size(self, props: Mapping[str, str]) -> float | None:
  447:         size = props.get("font-size")
  448:         if size is None:
  449:             return size
  450:         return self._pt_to_float(size)
  451: 
  452:     def _select_font_family(self, font_names: Sequence[str]) -> int | None:
  453:         family = None
  454:         for name in font_names:
  455:             family = self.FAMILY_MAP.get(name)
  456:             if family:
  457:                 break
  458: 
  459:         return family
  460: 
  461:     def color_to_excel(self, val: str | None) -> str | None:
  462:         if val is None:
  463:             return None
  464: 
  465:         if self._is_hex_color(val):
  466:             return self._convert_hex_to_excel(val)
  467: 
  468:         try:
  469:             return self.NAMED_COLORS[val]
  470:         except KeyError:
  471:             warnings.warn(
  472:                 f"Unhandled color format: {repr(val)}",
  473:                 CSSWarning,
  474:                 stacklevel=find_stack_level(),
  475:             )
  476:         return None
  477: 
  478:     def _is_hex_color(self, color_string: str) -> bool:
  479:         return bool(color_string.startswith("#"))
  480: 
  481:     def _convert_hex_to_excel(self, color_string: str) -> str:
  482:         code = color_string.lstrip("#")
  483:         if self._is_shorthand_color(color_string):
  484:             return (code[0] * 2 + code[1] * 2 + code[2] * 2).upper()
  485:         else:
  486:             return code.upper()
  487: 
  488:     def _is_shorthand_color(self, color_string: str) -> bool:
  489:         """Check if color code is shorthand.
  490: 
  491:         #FFF is a shorthand as opposed to full #FFFFFF.
  492:         """
  493:         code = color_string.lstrip("#")
  494:         if len(code) == 3:
  495:             return True
  496:         elif len(code) == 6:
  497:             return False
  498:         else:
  499:             raise ValueError(f"Unexpected color {color_string}")
  500: 
  501: 
  502: class ExcelFormatter:
  503:     """
  504:     Class for formatting a DataFrame to a list of ExcelCells,
  505: 
  506:     Parameters
  507:     ----------
  508:     df : DataFrame or Styler
  509:     na_rep: na representation
  510:     float_format : str, default None
  511:         Format string for floating point numbers
  512:     cols : sequence, optional
  513:         Columns to write
  514:     header : bool or sequence of str, default True
  515:         Write out column names. If a list of string is given it is
  516:         assumed to be aliases for the column names
  517:     index : bool, default True
  518:         output row names (index)
  519:     index_label : str or sequence, default None
  520:         Column label for index column(s) if desired. If None is given, and
  521:         `header` and `index` are True, then the index names are used. A
  522:         sequence should be given if the DataFrame uses MultiIndex.
  523:     merge_cells : bool, default False
  524:         Format MultiIndex and Hierarchical Rows as merged cells.
  525:     inf_rep : str, default `'inf'`
  526:         representation for np.inf values (which aren't representable in Excel)
  527:         A `'-'` sign will be added in front of -inf.
  528:     style_converter : callable, optional
  529:         This translates Styler styles (CSS) into ExcelWriter styles.
  530:         Defaults to ``CSSToExcelConverter()``.
  531:         It should have signature css_declarations string -> excel style.
  532:         This is only called for body cells.
  533:     """
  534: 
  535:     max_rows = 2**20
  536:     max_cols = 2**14
  537: 
  538:     def __init__(
  539:         self,
  540:         df,
  541:         na_rep: str = "",
  542:         float_format: str | None = None,
  543:         cols: Sequence[Hashable] | None = None,
  544:         header: Sequence[Hashable] | bool = True,
  545:         index: bool = True,
  546:         index_label: IndexLabel | None = None,
  547:         merge_cells: bool = False,
  548:         inf_rep: str = "inf",
  549:         style_converter: Callable | None = None,
  550:     ) -> None:
  551:         self.rowcounter = 0
  552:         self.na_rep = na_rep
  553:         if not isinstance(df, DataFrame):
  554:             self.styler = df
  555:             self.styler._compute()  # calculate applied styles
  556:             df = df.data
  557:             if style_converter is None:
  558:                 style_converter = CSSToExcelConverter()
  559:             self.style_converter: Callable | None = style_converter
  560:         else:
  561:             self.styler = None
  562:             self.style_converter = None
  563:         self.df = df
  564:         if cols is not None:
  565:             # all missing, raise
  566:             if not len(Index(cols).intersection(df.columns)):
  567:                 raise KeyError("passes columns are not ALL present dataframe")
  568: 
  569:             if len(Index(cols).intersection(df.columns)) != len(set(cols)):
  570:                 # Deprecated in GH#17295, enforced in 1.0.0
  571:                 raise KeyError("Not all names specified in 'columns' are found")
  572: 
  573:             self.df = df.reindex(columns=cols)
  574: 
  575:         self.columns = self.df.columns
  576:         self.float_format = float_format
  577:         self.index = index
  578:         self.index_label = index_label
  579:         self.header = header
  580:         self.merge_cells = merge_cells
  581:         self.inf_rep = inf_rep
  582: 
  583:     @property
  584:     def header_style(self) -> dict[str, dict[str, str | bool]]:
  585:         return {
  586:             "font": {"bold": True},
  587:             "borders": {
  588:                 "top": "thin",
  589:                 "right": "thin",
  590:                 "bottom": "thin",
  591:                 "left": "thin",
  592:             },
  593:             "alignment": {"horizontal": "center", "vertical": "top"},
  594:         }
  595: 
  596:     def _format_value(self, val):
  597:         if is_scalar(val) and missing.isna(val):
  598:             val = self.na_rep
  599:         elif is_float(val):
  600:             if missing.isposinf_scalar(val):
  601:                 val = self.inf_rep
  602:             elif missing.isneginf_scalar(val):
  603:                 val = f"-{self.inf_rep}"
  604:             elif self.float_format is not None:
  605:                 val = float(self.float_format % val)
  606:         if getattr(val, "tzinfo", None) is not None:
  607:             raise ValueError(
  608:                 "Excel does not support datetimes with "
  609:                 "timezones. Please ensure that datetimes "
  610:                 "are timezone unaware before writing to Excel."
  611:             )
  612:         return val
  613: 
  614:     def _format_header_mi(self) -> Iterable[ExcelCell]:
  615:         if self.columns.nlevels > 1:
  616:             if not self.index:
  617:                 raise NotImplementedError(
  618:                     "Writing to Excel with MultiIndex columns and no "
  619:                     "index ('index'=False) is not yet implemented."
  620:                 )
  621: 
  622:         if not (self._has_aliases or self.header):
  623:             return
  624: 
  625:         columns = self.columns
  626:         level_strs = columns._format_multi(
  627:             sparsify=self.merge_cells, include_names=False
  628:         )
  629:         level_lengths = get_level_lengths(level_strs)
  630:         coloffset = 0
  631:         lnum = 0
  632: 
  633:         if self.index and isinstance(self.df.index, MultiIndex):
  634:             coloffset = len(self.df.index[0]) - 1
  635: 
  636:         if self.merge_cells:
  637:             # Format multi-index as a merged cells.
  638:             for lnum, name in enumerate(columns.names):
  639:                 yield ExcelCell(
  640:                     row=lnum,
  641:                     col=coloffset,
  642:                     val=name,
  643:                     style=self.header_style,
  644:                 )
  645: 
  646:             for lnum, (spans, levels, level_codes) in enumerate(
  647:                 zip(level_lengths, columns.levels, columns.codes)
  648:             ):
  649:                 values = levels.take(level_codes)
  650:                 for i, span_val in spans.items():
  651:                     mergestart, mergeend = None, None
  652:                     if span_val > 1:
  653:                         mergestart, mergeend = lnum, coloffset + i + span_val
  654:                     yield CssExcelCell(
  655:                         row=lnum,
  656:                         col=coloffset + i + 1,
  657:                         val=values[i],
  658:                         style=self.header_style,
  659:                         css_styles=getattr(self.styler, "ctx_columns", None),
  660:                         css_row=lnum,
  661:                         css_col=i,
  662:                         css_converter=self.style_converter,
  663:                         mergestart=mergestart,
  664:                         mergeend=mergeend,
  665:                     )
  666:         else:
  667:             # Format in legacy format with dots to indicate levels.
  668:             for i, values in enumerate(zip(*level_strs)):
  669:                 v = ".".join(map(pprint_thing, values))
  670:                 yield CssExcelCell(
  671:                     row=lnum,
  672:                     col=coloffset + i + 1,
  673:                     val=v,
  674:                     style=self.header_style,
  675:                     css_styles=getattr(self.styler, "ctx_columns", None),
  676:                     css_row=lnum,
  677:                     css_col=i,
  678:                     css_converter=self.style_converter,
  679:                 )
  680: 
  681:         self.rowcounter = lnum
  682: 
  683:     def _format_header_regular(self) -> Iterable[ExcelCell]:
  684:         if self._has_aliases or self.header:
  685:             coloffset = 0
  686: 
  687:             if self.index:
  688:                 coloffset = 1
  689:                 if isinstance(self.df.index, MultiIndex):
  690:                     coloffset = len(self.df.index.names)
  691: 
  692:             colnames = self.columns
  693:             if self._has_aliases:
  694:                 self.header = cast(Sequence, self.header)
  695:                 if len(self.header) != len(self.columns):
  696:                     raise ValueError(
  697:                         f"Writing {len(self.columns)} cols "
  698:                         f"but got {len(self.header)} aliases"
  699:                     )
  700:                 colnames = self.header
  701: 
  702:             for colindex, colname in enumerate(colnames):
  703:                 yield CssExcelCell(
  704:                     row=self.rowcounter,
  705:                     col=colindex + coloffset,
  706:                     val=colname,
  707:                     style=self.header_style,
  708:                     css_styles=getattr(self.styler, "ctx_columns", None),
  709:                     css_row=0,
  710:                     css_col=colindex,
  711:                     css_converter=self.style_converter,
  712:                 )
  713: 
  714:     def _format_header(self) -> Iterable[ExcelCell]:
  715:         gen: Iterable[ExcelCell]
  716: 
  717:         if isinstance(self.columns, MultiIndex):
  718:             gen = self._format_header_mi()
  719:         else:
  720:             gen = self._format_header_regular()
  721: 
  722:         gen2: Iterable[ExcelCell] = ()
  723: 
  724:         if self.df.index.names:
  725:             row = [x if x is not None else "" for x in self.df.index.names] + [
  726:                 ""
  727:             ] * len(self.columns)
  728:             if functools.reduce(lambda x, y: x and y, (x != "" for x in row)):
  729:                 gen2 = (
  730:                     ExcelCell(self.rowcounter, colindex, val, self.header_style)
  731:                     for colindex, val in enumerate(row)
  732:                 )
  733:                 self.rowcounter += 1
  734:         return itertools.chain(gen, gen2)
  735: 
  736:     def _format_body(self) -> Iterable[ExcelCell]:
  737:         if isinstance(self.df.index, MultiIndex):
  738:             return self._format_hierarchical_rows()
  739:         else:
  740:             return self._format_regular_rows()
  741: 
  742:     def _format_regular_rows(self) -> Iterable[ExcelCell]:
  743:         if self._has_aliases or self.header:
  744:             self.rowcounter += 1
  745: 
  746:         # output index and index_label?
  747:         if self.index:
  748:             # check aliases
  749:             # if list only take first as this is not a MultiIndex
  750:             if self.index_label and isinstance(
  751:                 self.index_label, (list, tuple, np.ndarray, Index)
  752:             ):
  753:                 index_label = self.index_label[0]
  754:             # if string good to go
  755:             elif self.index_label and isinstance(self.index_label, str):
  756:                 index_label = self.index_label
  757:             else:
  758:                 index_label = self.df.index.names[0]
  759: 
  760:             if isinstance(self.columns, MultiIndex):
  761:                 self.rowcounter += 1
  762: 
  763:             if index_label and self.header is not False:
  764:                 yield ExcelCell(self.rowcounter - 1, 0, index_label, self.header_style)
  765: 
  766:             # write index_values
  767:             index_values = self.df.index
  768:             if isinstance(self.df.index, PeriodIndex):
  769:                 index_values = self.df.index.to_timestamp()
  770: 
  771:             for idx, idxval in enumerate(index_values):
  772:                 yield CssExcelCell(
  773:                     row=self.rowcounter + idx,
  774:                     col=0,
  775:                     val=idxval,
  776:                     style=self.header_style,
  777:                     css_styles=getattr(self.styler, "ctx_index", None),
  778:                     css_row=idx,
  779:                     css_col=0,
  780:                     css_converter=self.style_converter,
  781:                 )
  782:             coloffset = 1
  783:         else:
  784:             coloffset = 0
  785: 
  786:         yield from self._generate_body(coloffset)
  787: 
  788:     def _format_hierarchical_rows(self) -> Iterable[ExcelCell]:
  789:         if self._has_aliases or self.header:
  790:             self.rowcounter += 1
  791: 
  792:         gcolidx = 0
  793: 
  794:         if self.index:
  795:             index_labels = self.df.index.names
  796:             # check for aliases
  797:             if self.index_label and isinstance(
  798:                 self.index_label, (list, tuple, np.ndarray, Index)
  799:             ):
  800:                 index_labels = self.index_label
  801: 
  802:             # MultiIndex columns require an extra row
  803:             # with index names (blank if None) for
  804:             # unambiguous round-trip, unless not merging,
  805:             # in which case the names all go on one row Issue #11328
  806:             if isinstance(self.columns, MultiIndex) and self.merge_cells:
  807:                 self.rowcounter += 1
  808: 
  809:             # if index labels are not empty go ahead and dump
  810:             if com.any_not_none(*index_labels) and self.header is not False:
  811:                 for cidx, name in enumerate(index_labels):
  812:                     yield ExcelCell(self.rowcounter - 1, cidx, name, self.header_style)
  813: 
  814:             if self.merge_cells:
  815:                 # Format hierarchical rows as merged cells.
  816:                 level_strs = self.df.index._format_multi(
  817:                     sparsify=True, include_names=False
  818:                 )
  819:                 level_lengths = get_level_lengths(level_strs)
  820: 
  821:                 for spans, levels, level_codes in zip(
  822:                     level_lengths, self.df.index.levels, self.df.index.codes
  823:                 ):
  824:                     values = levels.take(
  825:                         level_codes,
  826:                         allow_fill=levels._can_hold_na,
  827:                         fill_value=levels._na_value,
  828:                     )
  829: 
  830:                     for i, span_val in spans.items():
  831:                         mergestart, mergeend = None, None
  832:                         if span_val > 1:
  833:                             mergestart = self.rowcounter + i + span_val - 1
  834:                             mergeend = gcolidx
  835:                         yield CssExcelCell(
  836:                             row=self.rowcounter + i,
  837:                             col=gcolidx,
  838:                             val=values[i],
  839:                             style=self.header_style,
  840:                             css_styles=getattr(self.styler, "ctx_index", None),
  841:                             css_row=i,
  842:                             css_col=gcolidx,
  843:                             css_converter=self.style_converter,
  844:                             mergestart=mergestart,
  845:                             mergeend=mergeend,
  846:                         )
  847:                     gcolidx += 1
  848: 
  849:             else:
  850:                 # Format hierarchical rows with non-merged values.
  851:                 for indexcolvals in zip(*self.df.index):
  852:                     for idx, indexcolval in enumerate(indexcolvals):
  853:                         yield CssExcelCell(
  854:                             row=self.rowcounter + idx,
  855:                             col=gcolidx,
  856:                             val=indexcolval,
  857:                             style=self.header_style,
  858:                             css_styles=getattr(self.styler, "ctx_index", None),
  859:                             css_row=idx,
  860:                             css_col=gcolidx,
  861:                             css_converter=self.style_converter,
  862:                         )
  863:                     gcolidx += 1
  864: 
  865:         yield from self._generate_body(gcolidx)
  866: 
  867:     @property
  868:     def _has_aliases(self) -> bool:
  869:         """Whether the aliases for column names are present."""
  870:         return is_list_like(self.header)
  871: 
  872:     def _generate_body(self, coloffset: int) -> Iterable[ExcelCell]:
  873:         # Write the body of the frame data series by series.
  874:         for colidx in range(len(self.columns)):
  875:             series = self.df.iloc[:, colidx]
  876:             for i, val in enumerate(series):
  877:                 yield CssExcelCell(
  878:                     row=self.rowcounter + i,
  879:                     col=colidx + coloffset,
  880:                     val=val,
  881:                     style=None,
  882:                     css_styles=getattr(self.styler, "ctx", None),
  883:                     css_row=i,
  884:                     css_col=colidx,
  885:                     css_converter=self.style_converter,
  886:                 )
  887: 
  888:     def get_formatted_cells(self) -> Iterable[ExcelCell]:
  889:         for cell in itertools.chain(self._format_header(), self._format_body()):
  890:             cell.val = self._format_value(cell.val)
  891:             yield cell
  892: 
  893:     @doc(storage_options=_shared_docs["storage_options"])
  894:     def write(
  895:         self,
  896:         writer: FilePath | WriteExcelBuffer | ExcelWriter,
  897:         sheet_name: str = "Sheet1",
  898:         startrow: int = 0,
  899:         startcol: int = 0,
  900:         freeze_panes: tuple[int, int] | None = None,
  901:         engine: str | None = None,
  902:         storage_options: StorageOptions | None = None,
  903:         engine_kwargs: dict | None = None,
  904:     ) -> None:
  905:         """
  906:         writer : path-like, file-like, or ExcelWriter object
  907:             File path or existing ExcelWriter
  908:         sheet_name : str, default 'Sheet1'
  909:             Name of sheet which will contain DataFrame
  910:         startrow :
  911:             upper left cell row to dump data frame
  912:         startcol :
  913:             upper left cell column to dump data frame
  914:         freeze_panes : tuple of integer (length 2), default None
  915:             Specifies the one-based bottommost row and rightmost column that
  916:             is to be frozen
  917:         engine : string, default None
  918:             write engine to use if writer is a path - you can also set this
  919:             via the options ``io.excel.xlsx.writer``,
  920:             or ``io.excel.xlsm.writer``.
  921: 
  922:         {storage_options}
  923: 
  924:         engine_kwargs: dict, optional
  925:             Arbitrary keyword arguments passed to excel engine.
  926:         """
  927:         from pandas.io.excel import ExcelWriter
  928: 
  929:         num_rows, num_cols = self.df.shape
  930:         if num_rows > self.max_rows or num_cols > self.max_cols:
  931:             raise ValueError(
  932:                 f"This sheet is too large! Your sheet size is: {num_rows}, {num_cols} "
  933:                 f"Max sheet size is: {self.max_rows}, {self.max_cols}"
  934:             )
  935: 
  936:         if engine_kwargs is None:
  937:             engine_kwargs = {}
  938: 
  939:         formatted_cells = self.get_formatted_cells()
  940:         if isinstance(writer, ExcelWriter):
  941:             need_save = False
  942:         else:
  943:             writer = ExcelWriter(
  944:                 writer,
  945:                 engine=engine,
  946:                 storage_options=storage_options,
  947:                 engine_kwargs=engine_kwargs,
  948:             )
  949:             need_save = True
  950: 
  951:         try:
  952:             writer._write_cells(
  953:                 formatted_cells,
  954:                 sheet_name,
  955:                 startrow=startrow,
  956:                 startcol=startcol,
  957:                 freeze_panes=freeze_panes,
  958:             )
  959:         finally:
  960:             # make sure to close opened file handles
  961:             if need_save:
  962:                 writer.close()
