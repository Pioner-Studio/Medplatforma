    1: """
    2: Module for formatting output data in console (to string).
    3: """
    4: from __future__ import annotations
    5: 
    6: from shutil import get_terminal_size
    7: from typing import TYPE_CHECKING
    8: 
    9: import numpy as np
   10: 
   11: from pandas.io.formats.printing import pprint_thing
   12: 
   13: if TYPE_CHECKING:
   14:     from collections.abc import Iterable
   15: 
   16:     from pandas.io.formats.format import DataFrameFormatter
   17: 
   18: 
   19: class StringFormatter:
   20:     """Formatter for string representation of a dataframe."""
   21: 
   22:     def __init__(self, fmt: DataFrameFormatter, line_width: int | None = None) -> None:
   23:         self.fmt = fmt
   24:         self.adj = fmt.adj
   25:         self.frame = fmt.frame
   26:         self.line_width = line_width
   27: 
   28:     def to_string(self) -> str:
   29:         text = self._get_string_representation()
   30:         if self.fmt.should_show_dimensions:
   31:             text = f"{text}{self.fmt.dimensions_info}"
   32:         return text
   33: 
   34:     def _get_strcols(self) -> list[list[str]]:
   35:         strcols = self.fmt.get_strcols()
   36:         if self.fmt.is_truncated:
   37:             strcols = self._insert_dot_separators(strcols)
   38:         return strcols
   39: 
   40:     def _get_string_representation(self) -> str:
   41:         if self.fmt.frame.empty:
   42:             return self._empty_info_line
   43: 
   44:         strcols = self._get_strcols()
   45: 
   46:         if self.line_width is None:
   47:             # no need to wrap around just print the whole frame
   48:             return self.adj.adjoin(1, *strcols)
   49: 
   50:         if self._need_to_wrap_around:
   51:             return self._join_multiline(strcols)
   52: 
   53:         return self._fit_strcols_to_terminal_width(strcols)
   54: 
   55:     @property
   56:     def _empty_info_line(self) -> str:
   57:         return (
   58:             f"Empty {type(self.frame).__name__}\n"
   59:             f"Columns: {pprint_thing(self.frame.columns)}\n"
   60:             f"Index: {pprint_thing(self.frame.index)}"
   61:         )
   62: 
   63:     @property
   64:     def _need_to_wrap_around(self) -> bool:
   65:         return bool(self.fmt.max_cols is None or self.fmt.max_cols > 0)
   66: 
   67:     def _insert_dot_separators(self, strcols: list[list[str]]) -> list[list[str]]:
   68:         str_index = self.fmt._get_formatted_index(self.fmt.tr_frame)
   69:         index_length = len(str_index)
   70: 
   71:         if self.fmt.is_truncated_horizontally:
   72:             strcols = self._insert_dot_separator_horizontal(strcols, index_length)
   73: 
   74:         if self.fmt.is_truncated_vertically:
   75:             strcols = self._insert_dot_separator_vertical(strcols, index_length)
   76: 
   77:         return strcols
   78: 
   79:     @property
   80:     def _adjusted_tr_col_num(self) -> int:
   81:         return self.fmt.tr_col_num + 1 if self.fmt.index else self.fmt.tr_col_num
   82: 
   83:     def _insert_dot_separator_horizontal(
   84:         self, strcols: list[list[str]], index_length: int
   85:     ) -> list[list[str]]:
   86:         strcols.insert(self._adjusted_tr_col_num, [" ..."] * index_length)
   87:         return strcols
   88: 
   89:     def _insert_dot_separator_vertical(
   90:         self, strcols: list[list[str]], index_length: int
   91:     ) -> list[list[str]]:
   92:         n_header_rows = index_length - len(self.fmt.tr_frame)
   93:         row_num = self.fmt.tr_row_num
   94:         for ix, col in enumerate(strcols):
   95:             cwidth = self.adj.len(col[row_num])
   96: 
   97:             if self.fmt.is_truncated_horizontally:
   98:                 is_dot_col = ix == self._adjusted_tr_col_num
   99:             else:
  100:                 is_dot_col = False
  101: 
  102:             if cwidth > 3 or is_dot_col:
  103:                 dots = "..."
  104:             else:
  105:                 dots = ".."
  106: 
  107:             if ix == 0 and self.fmt.index:
  108:                 dot_mode = "left"
  109:             elif is_dot_col:
  110:                 cwidth = 4
  111:                 dot_mode = "right"
  112:             else:
  113:                 dot_mode = "right"
  114: 
  115:             dot_str = self.adj.justify([dots], cwidth, mode=dot_mode)[0]
  116:             col.insert(row_num + n_header_rows, dot_str)
  117:         return strcols
  118: 
  119:     def _join_multiline(self, strcols_input: Iterable[list[str]]) -> str:
  120:         lwidth = self.line_width
  121:         adjoin_width = 1
  122:         strcols = list(strcols_input)
  123: 
  124:         if self.fmt.index:
  125:             idx = strcols.pop(0)
  126:             lwidth -= np.array([self.adj.len(x) for x in idx]).max() + adjoin_width
  127: 
  128:         col_widths = [
  129:             np.array([self.adj.len(x) for x in col]).max() if len(col) > 0 else 0
  130:             for col in strcols
  131:         ]
  132: 
  133:         assert lwidth is not None
  134:         col_bins = _binify(col_widths, lwidth)
  135:         nbins = len(col_bins)
  136: 
  137:         str_lst = []
  138:         start = 0
  139:         for i, end in enumerate(col_bins):
  140:             row = strcols[start:end]
  141:             if self.fmt.index:
  142:                 row.insert(0, idx)
  143:             if nbins > 1:
  144:                 nrows = len(row[-1])
  145:                 if end <= len(strcols) and i < nbins - 1:
  146:                     row.append([" \\"] + ["  "] * (nrows - 1))
  147:                 else:
  148:                     row.append([" "] * nrows)
  149:             str_lst.append(self.adj.adjoin(adjoin_width, *row))
  150:             start = end
  151:         return "\n\n".join(str_lst)
  152: 
  153:     def _fit_strcols_to_terminal_width(self, strcols: list[list[str]]) -> str:
  154:         from pandas import Series
  155: 
  156:         lines = self.adj.adjoin(1, *strcols).split("\n")
  157:         max_len = Series(lines).str.len().max()
  158:         # plus truncate dot col
  159:         width, _ = get_terminal_size()
  160:         dif = max_len - width
  161:         # '+ 1' to avoid too wide repr (GH PR #17023)
  162:         adj_dif = dif + 1
  163:         col_lens = Series([Series(ele).str.len().max() for ele in strcols])
  164:         n_cols = len(col_lens)
  165:         counter = 0
  166:         while adj_dif > 0 and n_cols > 1:
  167:             counter += 1
  168:             mid = round(n_cols / 2)
  169:             mid_ix = col_lens.index[mid]
  170:             col_len = col_lens[mid_ix]
  171:             # adjoin adds one
  172:             adj_dif -= col_len + 1
  173:             col_lens = col_lens.drop(mid_ix)
  174:             n_cols = len(col_lens)
  175: 
  176:         # subtract index column
  177:         max_cols_fitted = n_cols - self.fmt.index
  178:         # GH-21180. Ensure that we print at least two.
  179:         max_cols_fitted = max(max_cols_fitted, 2)
  180:         self.fmt.max_cols_fitted = max_cols_fitted
  181: 
  182:         # Call again _truncate to cut frame appropriately
  183:         # and then generate string representation
  184:         self.fmt.truncate()
  185:         strcols = self._get_strcols()
  186:         return self.adj.adjoin(1, *strcols)
  187: 
  188: 
  189: def _binify(cols: list[int], line_width: int) -> list[int]:
  190:     adjoin_width = 1
  191:     bins = []
  192:     curr_width = 0
  193:     i_last_column = len(cols) - 1
  194:     for i, w in enumerate(cols):
  195:         w_adjoined = w + adjoin_width
  196:         curr_width += w_adjoined
  197:         if i_last_column == i:
  198:             wrap = curr_width + 1 > line_width and i > 0
  199:         else:
  200:             wrap = curr_width + 2 > line_width and i > 0
  201:         if wrap:
  202:             bins.append(i)
  203:             curr_width = w_adjoined
  204: 
  205:     bins.append(len(cols))
  206:     return bins
