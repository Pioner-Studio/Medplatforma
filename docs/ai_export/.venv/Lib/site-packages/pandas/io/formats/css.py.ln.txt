    1: """
    2: Utilities for interpreting CSS from Stylers for formatting non-HTML outputs.
    3: """
    4: from __future__ import annotations
    5: 
    6: import re
    7: from typing import (
    8:     TYPE_CHECKING,
    9:     Callable,
   10: )
   11: import warnings
   12: 
   13: from pandas.errors import CSSWarning
   14: from pandas.util._exceptions import find_stack_level
   15: 
   16: if TYPE_CHECKING:
   17:     from collections.abc import (
   18:         Generator,
   19:         Iterable,
   20:         Iterator,
   21:     )
   22: 
   23: 
   24: def _side_expander(prop_fmt: str) -> Callable:
   25:     """
   26:     Wrapper to expand shorthand property into top, right, bottom, left properties
   27: 
   28:     Parameters
   29:     ----------
   30:     side : str
   31:         The border side to expand into properties
   32: 
   33:     Returns
   34:     -------
   35:         function: Return to call when a 'border(-{side}): {value}' string is encountered
   36:     """
   37: 
   38:     def expand(self, prop, value: str) -> Generator[tuple[str, str], None, None]:
   39:         """
   40:         Expand shorthand property into side-specific property (top, right, bottom, left)
   41: 
   42:         Parameters
   43:         ----------
   44:             prop (str): CSS property name
   45:             value (str): String token for property
   46: 
   47:         Yields
   48:         ------
   49:             Tuple (str, str): Expanded property, value
   50:         """
   51:         tokens = value.split()
   52:         try:
   53:             mapping = self.SIDE_SHORTHANDS[len(tokens)]
   54:         except KeyError:
   55:             warnings.warn(
   56:                 f'Could not expand "{prop}: {value}"',
   57:                 CSSWarning,
   58:                 stacklevel=find_stack_level(),
   59:             )
   60:             return
   61:         for key, idx in zip(self.SIDES, mapping):
   62:             yield prop_fmt.format(key), tokens[idx]
   63: 
   64:     return expand
   65: 
   66: 
   67: def _border_expander(side: str = "") -> Callable:
   68:     """
   69:     Wrapper to expand 'border' property into border color, style, and width properties
   70: 
   71:     Parameters
   72:     ----------
   73:     side : str
   74:         The border side to expand into properties
   75: 
   76:     Returns
   77:     -------
   78:         function: Return to call when a 'border(-{side}): {value}' string is encountered
   79:     """
   80:     if side != "":
   81:         side = f"-{side}"
   82: 
   83:     def expand(self, prop, value: str) -> Generator[tuple[str, str], None, None]:
   84:         """
   85:         Expand border into color, style, and width tuples
   86: 
   87:         Parameters
   88:         ----------
   89:             prop : str
   90:                 CSS property name passed to styler
   91:             value : str
   92:                 Value passed to styler for property
   93: 
   94:         Yields
   95:         ------
   96:             Tuple (str, str): Expanded property, value
   97:         """
   98:         tokens = value.split()
   99:         if len(tokens) == 0 or len(tokens) > 3:
  100:             warnings.warn(
  101:                 f'Too many tokens provided to "{prop}" (expected 1-3)',
  102:                 CSSWarning,
  103:                 stacklevel=find_stack_level(),
  104:             )
  105: 
  106:         # TODO: Can we use current color as initial value to comply with CSS standards?
  107:         border_declarations = {
  108:             f"border{side}-color": "black",
  109:             f"border{side}-style": "none",
  110:             f"border{side}-width": "medium",
  111:         }
  112:         for token in tokens:
  113:             if token.lower() in self.BORDER_STYLES:
  114:                 border_declarations[f"border{side}-style"] = token
  115:             elif any(ratio in token.lower() for ratio in self.BORDER_WIDTH_RATIOS):
  116:                 border_declarations[f"border{side}-width"] = token
  117:             else:
  118:                 border_declarations[f"border{side}-color"] = token
  119:             # TODO: Warn user if item entered more than once (e.g. "border: red green")
  120: 
  121:         # Per CSS, "border" will reset previous "border-*" definitions
  122:         yield from self.atomize(border_declarations.items())
  123: 
  124:     return expand
  125: 
  126: 
  127: class CSSResolver:
  128:     """
  129:     A callable for parsing and resolving CSS to atomic properties.
  130:     """
  131: 
  132:     UNIT_RATIOS = {
  133:         "pt": ("pt", 1),
  134:         "em": ("em", 1),
  135:         "rem": ("pt", 12),
  136:         "ex": ("em", 0.5),
  137:         # 'ch':
  138:         "px": ("pt", 0.75),
  139:         "pc": ("pt", 12),
  140:         "in": ("pt", 72),
  141:         "cm": ("in", 1 / 2.54),
  142:         "mm": ("in", 1 / 25.4),
  143:         "q": ("mm", 0.25),
  144:         "!!default": ("em", 0),
  145:     }
  146: 
  147:     FONT_SIZE_RATIOS = UNIT_RATIOS.copy()
  148:     FONT_SIZE_RATIOS.update(
  149:         {
  150:             "%": ("em", 0.01),
  151:             "xx-small": ("rem", 0.5),
  152:             "x-small": ("rem", 0.625),
  153:             "small": ("rem", 0.8),
  154:             "medium": ("rem", 1),
  155:             "large": ("rem", 1.125),
  156:             "x-large": ("rem", 1.5),
  157:             "xx-large": ("rem", 2),
  158:             "smaller": ("em", 1 / 1.2),
  159:             "larger": ("em", 1.2),
  160:             "!!default": ("em", 1),
  161:         }
  162:     )
  163: 
  164:     MARGIN_RATIOS = UNIT_RATIOS.copy()
  165:     MARGIN_RATIOS.update({"none": ("pt", 0)})
  166: 
  167:     BORDER_WIDTH_RATIOS = UNIT_RATIOS.copy()
  168:     BORDER_WIDTH_RATIOS.update(
  169:         {
  170:             "none": ("pt", 0),
  171:             "thick": ("px", 4),
  172:             "medium": ("px", 2),
  173:             "thin": ("px", 1),
  174:             # Default: medium only if solid
  175:         }
  176:     )
  177: 
  178:     BORDER_STYLES = [
  179:         "none",
  180:         "hidden",
  181:         "dotted",
  182:         "dashed",
  183:         "solid",
  184:         "double",
  185:         "groove",
  186:         "ridge",
  187:         "inset",
  188:         "outset",
  189:         "mediumdashdot",
  190:         "dashdotdot",
  191:         "hair",
  192:         "mediumdashdotdot",
  193:         "dashdot",
  194:         "slantdashdot",
  195:         "mediumdashed",
  196:     ]
  197: 
  198:     SIDE_SHORTHANDS = {
  199:         1: [0, 0, 0, 0],
  200:         2: [0, 1, 0, 1],
  201:         3: [0, 1, 2, 1],
  202:         4: [0, 1, 2, 3],
  203:     }
  204: 
  205:     SIDES = ("top", "right", "bottom", "left")
  206: 
  207:     CSS_EXPANSIONS = {
  208:         **{
  209:             (f"border-{prop}" if prop else "border"): _border_expander(prop)
  210:             for prop in ["", "top", "right", "bottom", "left"]
  211:         },
  212:         **{
  213:             f"border-{prop}": _side_expander(f"border-{{:s}}-{prop}")
  214:             for prop in ["color", "style", "width"]
  215:         },
  216:         "margin": _side_expander("margin-{:s}"),
  217:         "padding": _side_expander("padding-{:s}"),
  218:     }
  219: 
  220:     def __call__(
  221:         self,
  222:         declarations: str | Iterable[tuple[str, str]],
  223:         inherited: dict[str, str] | None = None,
  224:     ) -> dict[str, str]:
  225:         """
  226:         The given declarations to atomic properties.
  227: 
  228:         Parameters
  229:         ----------
  230:         declarations_str : str | Iterable[tuple[str, str]]
  231:             A CSS string or set of CSS declaration tuples
  232:             e.g. "font-weight: bold; background: blue" or
  233:             {("font-weight", "bold"), ("background", "blue")}
  234:         inherited : dict, optional
  235:             Atomic properties indicating the inherited style context in which
  236:             declarations_str is to be resolved. ``inherited`` should already
  237:             be resolved, i.e. valid output of this method.
  238: 
  239:         Returns
  240:         -------
  241:         dict
  242:             Atomic CSS 2.2 properties.
  243: 
  244:         Examples
  245:         --------
  246:         >>> resolve = CSSResolver()
  247:         >>> inherited = {'font-family': 'serif', 'font-weight': 'bold'}
  248:         >>> out = resolve('''
  249:         ...               border-color: BLUE RED;
  250:         ...               font-size: 1em;
  251:         ...               font-size: 2em;
  252:         ...               font-weight: normal;
  253:         ...               font-weight: inherit;
  254:         ...               ''', inherited)
  255:         >>> sorted(out.items())  # doctest: +NORMALIZE_WHITESPACE
  256:         [('border-bottom-color', 'blue'),
  257:          ('border-left-color', 'red'),
  258:          ('border-right-color', 'red'),
  259:          ('border-top-color', 'blue'),
  260:          ('font-family', 'serif'),
  261:          ('font-size', '24pt'),
  262:          ('font-weight', 'bold')]
  263:         """
  264:         if isinstance(declarations, str):
  265:             declarations = self.parse(declarations)
  266:         props = dict(self.atomize(declarations))
  267:         if inherited is None:
  268:             inherited = {}
  269: 
  270:         props = self._update_initial(props, inherited)
  271:         props = self._update_font_size(props, inherited)
  272:         return self._update_other_units(props)
  273: 
  274:     def _update_initial(
  275:         self,
  276:         props: dict[str, str],
  277:         inherited: dict[str, str],
  278:     ) -> dict[str, str]:
  279:         # 1. resolve inherited, initial
  280:         for prop, val in inherited.items():
  281:             if prop not in props:
  282:                 props[prop] = val
  283: 
  284:         new_props = props.copy()
  285:         for prop, val in props.items():
  286:             if val == "inherit":
  287:                 val = inherited.get(prop, "initial")
  288: 
  289:             if val in ("initial", None):
  290:                 # we do not define a complete initial stylesheet
  291:                 del new_props[prop]
  292:             else:
  293:                 new_props[prop] = val
  294:         return new_props
  295: 
  296:     def _update_font_size(
  297:         self,
  298:         props: dict[str, str],
  299:         inherited: dict[str, str],
  300:     ) -> dict[str, str]:
  301:         # 2. resolve relative font size
  302:         if props.get("font-size"):
  303:             props["font-size"] = self.size_to_pt(
  304:                 props["font-size"],
  305:                 self._get_font_size(inherited),
  306:                 conversions=self.FONT_SIZE_RATIOS,
  307:             )
  308:         return props
  309: 
  310:     def _get_font_size(self, props: dict[str, str]) -> float | None:
  311:         if props.get("font-size"):
  312:             font_size_string = props["font-size"]
  313:             return self._get_float_font_size_from_pt(font_size_string)
  314:         return None
  315: 
  316:     def _get_float_font_size_from_pt(self, font_size_string: str) -> float:
  317:         assert font_size_string.endswith("pt")
  318:         return float(font_size_string.rstrip("pt"))
  319: 
  320:     def _update_other_units(self, props: dict[str, str]) -> dict[str, str]:
  321:         font_size = self._get_font_size(props)
  322:         # 3. TODO: resolve other font-relative units
  323:         for side in self.SIDES:
  324:             prop = f"border-{side}-width"
  325:             if prop in props:
  326:                 props[prop] = self.size_to_pt(
  327:                     props[prop],
  328:                     em_pt=font_size,
  329:                     conversions=self.BORDER_WIDTH_RATIOS,
  330:                 )
  331: 
  332:             for prop in [f"margin-{side}", f"padding-{side}"]:
  333:                 if prop in props:
  334:                     # TODO: support %
  335:                     props[prop] = self.size_to_pt(
  336:                         props[prop],
  337:                         em_pt=font_size,
  338:                         conversions=self.MARGIN_RATIOS,
  339:                     )
  340:         return props
  341: 
  342:     def size_to_pt(self, in_val, em_pt=None, conversions=UNIT_RATIOS) -> str:
  343:         def _error():
  344:             warnings.warn(
  345:                 f"Unhandled size: {repr(in_val)}",
  346:                 CSSWarning,
  347:                 stacklevel=find_stack_level(),
  348:             )
  349:             return self.size_to_pt("1!!default", conversions=conversions)
  350: 
  351:         match = re.match(r"^(\S*?)([a-zA-Z%!].*)", in_val)
  352:         if match is None:
  353:             return _error()
  354: 
  355:         val, unit = match.groups()
  356:         if val == "":
  357:             # hack for 'large' etc.
  358:             val = 1
  359:         else:
  360:             try:
  361:                 val = float(val)
  362:             except ValueError:
  363:                 return _error()
  364: 
  365:         while unit != "pt":
  366:             if unit == "em":
  367:                 if em_pt is None:
  368:                     unit = "rem"
  369:                 else:
  370:                     val *= em_pt
  371:                     unit = "pt"
  372:                 continue
  373: 
  374:             try:
  375:                 unit, mul = conversions[unit]
  376:             except KeyError:
  377:                 return _error()
  378:             val *= mul
  379: 
  380:         val = round(val, 5)
  381:         if int(val) == val:
  382:             size_fmt = f"{int(val):d}pt"
  383:         else:
  384:             size_fmt = f"{val:f}pt"
  385:         return size_fmt
  386: 
  387:     def atomize(self, declarations: Iterable) -> Generator[tuple[str, str], None, None]:
  388:         for prop, value in declarations:
  389:             prop = prop.lower()
  390:             value = value.lower()
  391:             if prop in self.CSS_EXPANSIONS:
  392:                 expand = self.CSS_EXPANSIONS[prop]
  393:                 yield from expand(self, prop, value)
  394:             else:
  395:                 yield prop, value
  396: 
  397:     def parse(self, declarations_str: str) -> Iterator[tuple[str, str]]:
  398:         """
  399:         Generates (prop, value) pairs from declarations.
  400: 
  401:         In a future version may generate parsed tokens from tinycss/tinycss2
  402: 
  403:         Parameters
  404:         ----------
  405:         declarations_str : str
  406:         """
  407:         for decl in declarations_str.split(";"):
  408:             if not decl.strip():
  409:                 continue
  410:             prop, sep, val = decl.partition(":")
  411:             prop = prop.strip().lower()
  412:             # TODO: don't lowercase case sensitive parts of values (strings)
  413:             val = val.strip().lower()
  414:             if sep:
  415:                 yield prop, val
  416:             else:
  417:                 warnings.warn(
  418:                     f"Ill-formatted attribute: expected a colon in {repr(decl)}",
  419:                     CSSWarning,
  420:                     stacklevel=find_stack_level(),
  421:                 )
