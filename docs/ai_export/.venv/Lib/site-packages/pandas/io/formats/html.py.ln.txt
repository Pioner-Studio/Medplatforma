    1: """
    2: Module for formatting output data in HTML.
    3: """
    4: from __future__ import annotations
    5: 
    6: from textwrap import dedent
    7: from typing import (
    8:     TYPE_CHECKING,
    9:     Any,
   10:     Final,
   11:     cast,
   12: )
   13: 
   14: from pandas._config import get_option
   15: 
   16: from pandas._libs import lib
   17: 
   18: from pandas import (
   19:     MultiIndex,
   20:     option_context,
   21: )
   22: 
   23: from pandas.io.common import is_url
   24: from pandas.io.formats.format import (
   25:     DataFrameFormatter,
   26:     get_level_lengths,
   27: )
   28: from pandas.io.formats.printing import pprint_thing
   29: 
   30: if TYPE_CHECKING:
   31:     from collections.abc import (
   32:         Hashable,
   33:         Iterable,
   34:         Mapping,
   35:     )
   36: 
   37: 
   38: class HTMLFormatter:
   39:     """
   40:     Internal class for formatting output data in html.
   41:     This class is intended for shared functionality between
   42:     DataFrame.to_html() and DataFrame._repr_html_().
   43:     Any logic in common with other output formatting methods
   44:     should ideally be inherited from classes in format.py
   45:     and this class responsible for only producing html markup.
   46:     """
   47: 
   48:     indent_delta: Final = 2
   49: 
   50:     def __init__(
   51:         self,
   52:         formatter: DataFrameFormatter,
   53:         classes: str | list[str] | tuple[str, ...] | None = None,
   54:         border: int | bool | None = None,
   55:         table_id: str | None = None,
   56:         render_links: bool = False,
   57:     ) -> None:
   58:         self.fmt = formatter
   59:         self.classes = classes
   60: 
   61:         self.frame = self.fmt.frame
   62:         self.columns = self.fmt.tr_frame.columns
   63:         self.elements: list[str] = []
   64:         self.bold_rows = self.fmt.bold_rows
   65:         self.escape = self.fmt.escape
   66:         self.show_dimensions = self.fmt.show_dimensions
   67:         if border is None or border is True:
   68:             border = cast(int, get_option("display.html.border"))
   69:         elif not border:
   70:             border = None
   71: 
   72:         self.border = border
   73:         self.table_id = table_id
   74:         self.render_links = render_links
   75: 
   76:         self.col_space = {}
   77:         is_multi_index = isinstance(self.columns, MultiIndex)
   78:         for column, value in self.fmt.col_space.items():
   79:             col_space_value = f"{value}px" if isinstance(value, int) else value
   80:             self.col_space[column] = col_space_value
   81:             # GH 53885: Handling case where column is index
   82:             # Flatten the data in the multi index and add in the map
   83:             if is_multi_index and isinstance(column, tuple):
   84:                 for column_index in column:
   85:                     self.col_space[str(column_index)] = col_space_value
   86: 
   87:     def to_string(self) -> str:
   88:         lines = self.render()
   89:         if any(isinstance(x, str) for x in lines):
   90:             lines = [str(x) for x in lines]
   91:         return "\n".join(lines)
   92: 
   93:     def render(self) -> list[str]:
   94:         self._write_table()
   95: 
   96:         if self.should_show_dimensions:
   97:             by = chr(215)  # Г—  # noqa: RUF003
   98:             self.write(
   99:                 f"<p>{len(self.frame)} rows {by} {len(self.frame.columns)} columns</p>"
  100:             )
  101: 
  102:         return self.elements
  103: 
  104:     @property
  105:     def should_show_dimensions(self) -> bool:
  106:         return self.fmt.should_show_dimensions
  107: 
  108:     @property
  109:     def show_row_idx_names(self) -> bool:
  110:         return self.fmt.show_row_idx_names
  111: 
  112:     @property
  113:     def show_col_idx_names(self) -> bool:
  114:         return self.fmt.show_col_idx_names
  115: 
  116:     @property
  117:     def row_levels(self) -> int:
  118:         if self.fmt.index:
  119:             # showing (row) index
  120:             return self.frame.index.nlevels
  121:         elif self.show_col_idx_names:
  122:             # see gh-22579
  123:             # Column misalignment also occurs for
  124:             # a standard index when the columns index is named.
  125:             # If the row index is not displayed a column of
  126:             # blank cells need to be included before the DataFrame values.
  127:             return 1
  128:         # not showing (row) index
  129:         return 0
  130: 
  131:     def _get_columns_formatted_values(self) -> Iterable:
  132:         return self.columns
  133: 
  134:     @property
  135:     def is_truncated(self) -> bool:
  136:         return self.fmt.is_truncated
  137: 
  138:     @property
  139:     def ncols(self) -> int:
  140:         return len(self.fmt.tr_frame.columns)
  141: 
  142:     def write(self, s: Any, indent: int = 0) -> None:
  143:         rs = pprint_thing(s)
  144:         self.elements.append(" " * indent + rs)
  145: 
  146:     def write_th(
  147:         self, s: Any, header: bool = False, indent: int = 0, tags: str | None = None
  148:     ) -> None:
  149:         """
  150:         Method for writing a formatted <th> cell.
  151: 
  152:         If col_space is set on the formatter then that is used for
  153:         the value of min-width.
  154: 
  155:         Parameters
  156:         ----------
  157:         s : object
  158:             The data to be written inside the cell.
  159:         header : bool, default False
  160:             Set to True if the <th> is for use inside <thead>.  This will
  161:             cause min-width to be set if there is one.
  162:         indent : int, default 0
  163:             The indentation level of the cell.
  164:         tags : str, default None
  165:             Tags to include in the cell.
  166: 
  167:         Returns
  168:         -------
  169:         A written <th> cell.
  170:         """
  171:         col_space = self.col_space.get(s, None)
  172: 
  173:         if header and col_space is not None:
  174:             tags = tags or ""
  175:             tags += f'style="min-width: {col_space};"'
  176: 
  177:         self._write_cell(s, kind="th", indent=indent, tags=tags)
  178: 
  179:     def write_td(self, s: Any, indent: int = 0, tags: str | None = None) -> None:
  180:         self._write_cell(s, kind="td", indent=indent, tags=tags)
  181: 
  182:     def _write_cell(
  183:         self, s: Any, kind: str = "td", indent: int = 0, tags: str | None = None
  184:     ) -> None:
  185:         if tags is not None:
  186:             start_tag = f"<{kind} {tags}>"
  187:         else:
  188:             start_tag = f"<{kind}>"
  189: 
  190:         if self.escape:
  191:             # escape & first to prevent double escaping of &
  192:             esc = {"&": r"&amp;", "<": r"&lt;", ">": r"&gt;"}
  193:         else:
  194:             esc = {}
  195: 
  196:         rs = pprint_thing(s, escape_chars=esc).strip()
  197: 
  198:         if self.render_links and is_url(rs):
  199:             rs_unescaped = pprint_thing(s, escape_chars={}).strip()
  200:             start_tag += f'<a href="{rs_unescaped}" target="_blank">'
  201:             end_a = "</a>"
  202:         else:
  203:             end_a = ""
  204: 
  205:         self.write(f"{start_tag}{rs}{end_a}</{kind}>", indent)
  206: 
  207:     def write_tr(
  208:         self,
  209:         line: Iterable,
  210:         indent: int = 0,
  211:         indent_delta: int = 0,
  212:         header: bool = False,
  213:         align: str | None = None,
  214:         tags: dict[int, str] | None = None,
  215:         nindex_levels: int = 0,
  216:     ) -> None:
  217:         if tags is None:
  218:             tags = {}
  219: 
  220:         if align is None:
  221:             self.write("<tr>", indent)
  222:         else:
  223:             self.write(f'<tr style="text-align: {align};">', indent)
  224:         indent += indent_delta
  225: 
  226:         for i, s in enumerate(line):
  227:             val_tag = tags.get(i, None)
  228:             if header or (self.bold_rows and i < nindex_levels):
  229:                 self.write_th(s, indent=indent, header=header, tags=val_tag)
  230:             else:
  231:                 self.write_td(s, indent, tags=val_tag)
  232: 
  233:         indent -= indent_delta
  234:         self.write("</tr>", indent)
  235: 
  236:     def _write_table(self, indent: int = 0) -> None:
  237:         _classes = ["dataframe"]  # Default class.
  238:         use_mathjax = get_option("display.html.use_mathjax")
  239:         if not use_mathjax:
  240:             _classes.append("tex2jax_ignore")
  241:         if self.classes is not None:
  242:             if isinstance(self.classes, str):
  243:                 self.classes = self.classes.split()
  244:             if not isinstance(self.classes, (list, tuple)):
  245:                 raise TypeError(
  246:                     "classes must be a string, list, "
  247:                     f"or tuple, not {type(self.classes)}"
  248:                 )
  249:             _classes.extend(self.classes)
  250: 
  251:         if self.table_id is None:
  252:             id_section = ""
  253:         else:
  254:             id_section = f' id="{self.table_id}"'
  255: 
  256:         if self.border is None:
  257:             border_attr = ""
  258:         else:
  259:             border_attr = f' border="{self.border}"'
  260: 
  261:         self.write(
  262:             f'<table{border_attr} class="{" ".join(_classes)}"{id_section}>',
  263:             indent,
  264:         )
  265: 
  266:         if self.fmt.header or self.show_row_idx_names:
  267:             self._write_header(indent + self.indent_delta)
  268: 
  269:         self._write_body(indent + self.indent_delta)
  270: 
  271:         self.write("</table>", indent)
  272: 
  273:     def _write_col_header(self, indent: int) -> None:
  274:         row: list[Hashable]
  275:         is_truncated_horizontally = self.fmt.is_truncated_horizontally
  276:         if isinstance(self.columns, MultiIndex):
  277:             template = 'colspan="{span:d}" halign="left"'
  278: 
  279:             sentinel: lib.NoDefault | bool
  280:             if self.fmt.sparsify:
  281:                 # GH3547
  282:                 sentinel = lib.no_default
  283:             else:
  284:                 sentinel = False
  285:             levels = self.columns._format_multi(sparsify=sentinel, include_names=False)
  286:             level_lengths = get_level_lengths(levels, sentinel)
  287:             inner_lvl = len(level_lengths) - 1
  288:             for lnum, (records, values) in enumerate(zip(level_lengths, levels)):
  289:                 if is_truncated_horizontally:
  290:                     # modify the header lines
  291:                     ins_col = self.fmt.tr_col_num
  292:                     if self.fmt.sparsify:
  293:                         recs_new = {}
  294:                         # Increment tags after ... col.
  295:                         for tag, span in list(records.items()):
  296:                             if tag >= ins_col:
  297:                                 recs_new[tag + 1] = span
  298:                             elif tag + span > ins_col:
  299:                                 recs_new[tag] = span + 1
  300:                                 if lnum == inner_lvl:
  301:                                     values = (
  302:                                         values[:ins_col] + ("...",) + values[ins_col:]
  303:                                     )
  304:                                 else:
  305:                                     # sparse col headers do not receive a ...
  306:                                     values = (
  307:                                         values[:ins_col]
  308:                                         + (values[ins_col - 1],)
  309:                                         + values[ins_col:]
  310:                                     )
  311:                             else:
  312:                                 recs_new[tag] = span
  313:                             # if ins_col lies between tags, all col headers
  314:                             # get ...
  315:                             if tag + span == ins_col:
  316:                                 recs_new[ins_col] = 1
  317:                                 values = values[:ins_col] + ("...",) + values[ins_col:]
  318:                         records = recs_new
  319:                         inner_lvl = len(level_lengths) - 1
  320:                         if lnum == inner_lvl:
  321:                             records[ins_col] = 1
  322:                     else:
  323:                         recs_new = {}
  324:                         for tag, span in list(records.items()):
  325:                             if tag >= ins_col:
  326:                                 recs_new[tag + 1] = span
  327:                             else:
  328:                                 recs_new[tag] = span
  329:                         recs_new[ins_col] = 1
  330:                         records = recs_new
  331:                         values = values[:ins_col] + ["..."] + values[ins_col:]
  332: 
  333:                 # see gh-22579
  334:                 # Column Offset Bug with to_html(index=False) with
  335:                 # MultiIndex Columns and Index.
  336:                 # Initially fill row with blank cells before column names.
  337:                 # TODO: Refactor to remove code duplication with code
  338:                 # block below for standard columns index.
  339:                 row = [""] * (self.row_levels - 1)
  340:                 if self.fmt.index or self.show_col_idx_names:
  341:                     # see gh-22747
  342:                     # If to_html(index_names=False) do not show columns
  343:                     # index names.
  344:                     # TODO: Refactor to use _get_column_name_list from
  345:                     # DataFrameFormatter class and create a
  346:                     # _get_formatted_column_labels function for code
  347:                     # parity with DataFrameFormatter class.
  348:                     if self.fmt.show_index_names:
  349:                         name = self.columns.names[lnum]
  350:                         row.append(pprint_thing(name or ""))
  351:                     else:
  352:                         row.append("")
  353: 
  354:                 tags = {}
  355:                 j = len(row)
  356:                 for i, v in enumerate(values):
  357:                     if i in records:
  358:                         if records[i] > 1:
  359:                             tags[j] = template.format(span=records[i])
  360:                     else:
  361:                         continue
  362:                     j += 1
  363:                     row.append(v)
  364:                 self.write_tr(row, indent, self.indent_delta, tags=tags, header=True)
  365:         else:
  366:             # see gh-22579
  367:             # Column misalignment also occurs for
  368:             # a standard index when the columns index is named.
  369:             # Initially fill row with blank cells before column names.
  370:             # TODO: Refactor to remove code duplication with code block
  371:             # above for columns MultiIndex.
  372:             row = [""] * (self.row_levels - 1)
  373:             if self.fmt.index or self.show_col_idx_names:
  374:                 # see gh-22747
  375:                 # If to_html(index_names=False) do not show columns
  376:                 # index names.
  377:                 # TODO: Refactor to use _get_column_name_list from
  378:                 # DataFrameFormatter class.
  379:                 if self.fmt.show_index_names:
  380:                     row.append(self.columns.name or "")
  381:                 else:
  382:                     row.append("")
  383:             row.extend(self._get_columns_formatted_values())
  384:             align = self.fmt.justify
  385: 
  386:             if is_truncated_horizontally:
  387:                 ins_col = self.row_levels + self.fmt.tr_col_num
  388:                 row.insert(ins_col, "...")
  389: 
  390:             self.write_tr(row, indent, self.indent_delta, header=True, align=align)
  391: 
  392:     def _write_row_header(self, indent: int) -> None:
  393:         is_truncated_horizontally = self.fmt.is_truncated_horizontally
  394:         row = [x if x is not None else "" for x in self.frame.index.names] + [""] * (
  395:             self.ncols + (1 if is_truncated_horizontally else 0)
  396:         )
  397:         self.write_tr(row, indent, self.indent_delta, header=True)
  398: 
  399:     def _write_header(self, indent: int) -> None:
  400:         self.write("<thead>", indent)
  401: 
  402:         if self.fmt.header:
  403:             self._write_col_header(indent + self.indent_delta)
  404: 
  405:         if self.show_row_idx_names:
  406:             self._write_row_header(indent + self.indent_delta)
  407: 
  408:         self.write("</thead>", indent)
  409: 
  410:     def _get_formatted_values(self) -> dict[int, list[str]]:
  411:         with option_context("display.max_colwidth", None):
  412:             fmt_values = {i: self.fmt.format_col(i) for i in range(self.ncols)}
  413:         return fmt_values
  414: 
  415:     def _write_body(self, indent: int) -> None:
  416:         self.write("<tbody>", indent)
  417:         fmt_values = self._get_formatted_values()
  418: 
  419:         # write values
  420:         if self.fmt.index and isinstance(self.frame.index, MultiIndex):
  421:             self._write_hierarchical_rows(fmt_values, indent + self.indent_delta)
  422:         else:
  423:             self._write_regular_rows(fmt_values, indent + self.indent_delta)
  424: 
  425:         self.write("</tbody>", indent)
  426: 
  427:     def _write_regular_rows(
  428:         self, fmt_values: Mapping[int, list[str]], indent: int
  429:     ) -> None:
  430:         is_truncated_horizontally = self.fmt.is_truncated_horizontally
  431:         is_truncated_vertically = self.fmt.is_truncated_vertically
  432: 
  433:         nrows = len(self.fmt.tr_frame)
  434: 
  435:         if self.fmt.index:
  436:             fmt = self.fmt._get_formatter("__index__")
  437:             if fmt is not None:
  438:                 index_values = self.fmt.tr_frame.index.map(fmt)
  439:             else:
  440:                 # only reached with non-Multi index
  441:                 index_values = self.fmt.tr_frame.index._format_flat(include_name=False)
  442: 
  443:         row: list[str] = []
  444:         for i in range(nrows):
  445:             if is_truncated_vertically and i == (self.fmt.tr_row_num):
  446:                 str_sep_row = ["..."] * len(row)
  447:                 self.write_tr(
  448:                     str_sep_row,
  449:                     indent,
  450:                     self.indent_delta,
  451:                     tags=None,
  452:                     nindex_levels=self.row_levels,
  453:                 )
  454: 
  455:             row = []
  456:             if self.fmt.index:
  457:                 row.append(index_values[i])
  458:             # see gh-22579
  459:             # Column misalignment also occurs for
  460:             # a standard index when the columns index is named.
  461:             # Add blank cell before data cells.
  462:             elif self.show_col_idx_names:
  463:                 row.append("")
  464:             row.extend(fmt_values[j][i] for j in range(self.ncols))
  465: 
  466:             if is_truncated_horizontally:
  467:                 dot_col_ix = self.fmt.tr_col_num + self.row_levels
  468:                 row.insert(dot_col_ix, "...")
  469:             self.write_tr(
  470:                 row, indent, self.indent_delta, tags=None, nindex_levels=self.row_levels
  471:             )
  472: 
  473:     def _write_hierarchical_rows(
  474:         self, fmt_values: Mapping[int, list[str]], indent: int
  475:     ) -> None:
  476:         template = 'rowspan="{span}" valign="top"'
  477: 
  478:         is_truncated_horizontally = self.fmt.is_truncated_horizontally
  479:         is_truncated_vertically = self.fmt.is_truncated_vertically
  480:         frame = self.fmt.tr_frame
  481:         nrows = len(frame)
  482: 
  483:         assert isinstance(frame.index, MultiIndex)
  484:         idx_values = frame.index._format_multi(sparsify=False, include_names=False)
  485:         idx_values = list(zip(*idx_values))
  486: 
  487:         if self.fmt.sparsify:
  488:             # GH3547
  489:             sentinel = lib.no_default
  490:             levels = frame.index._format_multi(sparsify=sentinel, include_names=False)
  491: 
  492:             level_lengths = get_level_lengths(levels, sentinel)
  493:             inner_lvl = len(level_lengths) - 1
  494:             if is_truncated_vertically:
  495:                 # Insert ... row and adjust idx_values and
  496:                 # level_lengths to take this into account.
  497:                 ins_row = self.fmt.tr_row_num
  498:                 inserted = False
  499:                 for lnum, records in enumerate(level_lengths):
  500:                     rec_new = {}
  501:                     for tag, span in list(records.items()):
  502:                         if tag >= ins_row:
  503:                             rec_new[tag + 1] = span
  504:                         elif tag + span > ins_row:
  505:                             rec_new[tag] = span + 1
  506: 
  507:                             # GH 14882 - Make sure insertion done once
  508:                             if not inserted:
  509:                                 dot_row = list(idx_values[ins_row - 1])
  510:                                 dot_row[-1] = "..."
  511:                                 idx_values.insert(ins_row, tuple(dot_row))
  512:                                 inserted = True
  513:                             else:
  514:                                 dot_row = list(idx_values[ins_row])
  515:                                 dot_row[inner_lvl - lnum] = "..."
  516:                                 idx_values[ins_row] = tuple(dot_row)
  517:                         else:
  518:                             rec_new[tag] = span
  519:                         # If ins_row lies between tags, all cols idx cols
  520:                         # receive ...
  521:                         if tag + span == ins_row:
  522:                             rec_new[ins_row] = 1
  523:                             if lnum == 0:
  524:                                 idx_values.insert(
  525:                                     ins_row, tuple(["..."] * len(level_lengths))
  526:                                 )
  527: 
  528:                             # GH 14882 - Place ... in correct level
  529:                             elif inserted:
  530:                                 dot_row = list(idx_values[ins_row])
  531:                                 dot_row[inner_lvl - lnum] = "..."
  532:                                 idx_values[ins_row] = tuple(dot_row)
  533:                     level_lengths[lnum] = rec_new
  534: 
  535:                 level_lengths[inner_lvl][ins_row] = 1
  536:                 for ix_col in fmt_values:
  537:                     fmt_values[ix_col].insert(ins_row, "...")
  538:                 nrows += 1
  539: 
  540:             for i in range(nrows):
  541:                 row = []
  542:                 tags = {}
  543: 
  544:                 sparse_offset = 0
  545:                 j = 0
  546:                 for records, v in zip(level_lengths, idx_values[i]):
  547:                     if i in records:
  548:                         if records[i] > 1:
  549:                             tags[j] = template.format(span=records[i])
  550:                     else:
  551:                         sparse_offset += 1
  552:                         continue
  553: 
  554:                     j += 1
  555:                     row.append(v)
  556: 
  557:                 row.extend(fmt_values[j][i] for j in range(self.ncols))
  558:                 if is_truncated_horizontally:
  559:                     row.insert(
  560:                         self.row_levels - sparse_offset + self.fmt.tr_col_num, "..."
  561:                     )
  562:                 self.write_tr(
  563:                     row,
  564:                     indent,
  565:                     self.indent_delta,
  566:                     tags=tags,
  567:                     nindex_levels=len(levels) - sparse_offset,
  568:                 )
  569:         else:
  570:             row = []
  571:             for i in range(len(frame)):
  572:                 if is_truncated_vertically and i == (self.fmt.tr_row_num):
  573:                     str_sep_row = ["..."] * len(row)
  574:                     self.write_tr(
  575:                         str_sep_row,
  576:                         indent,
  577:                         self.indent_delta,
  578:                         tags=None,
  579:                         nindex_levels=self.row_levels,
  580:                     )
  581: 
  582:                 idx_values = list(
  583:                     zip(*frame.index._format_multi(sparsify=False, include_names=False))
  584:                 )
  585:                 row = []
  586:                 row.extend(idx_values[i])
  587:                 row.extend(fmt_values[j][i] for j in range(self.ncols))
  588:                 if is_truncated_horizontally:
  589:                     row.insert(self.row_levels + self.fmt.tr_col_num, "...")
  590:                 self.write_tr(
  591:                     row,
  592:                     indent,
  593:                     self.indent_delta,
  594:                     tags=None,
  595:                     nindex_levels=frame.index.nlevels,
  596:                 )
  597: 
  598: 
  599: class NotebookFormatter(HTMLFormatter):
  600:     """
  601:     Internal class for formatting output data in html for display in Jupyter
  602:     Notebooks. This class is intended for functionality specific to
  603:     DataFrame._repr_html_() and DataFrame.to_html(notebook=True)
  604:     """
  605: 
  606:     def _get_formatted_values(self) -> dict[int, list[str]]:
  607:         return {i: self.fmt.format_col(i) for i in range(self.ncols)}
  608: 
  609:     def _get_columns_formatted_values(self) -> list[str]:
  610:         # only reached with non-Multi Index
  611:         return self.columns._format_flat(include_name=False)
  612: 
  613:     def write_style(self) -> None:
  614:         # We use the "scoped" attribute here so that the desired
  615:         # style properties for the data frame are not then applied
  616:         # throughout the entire notebook.
  617:         template_first = """\
  618:             <style scoped>"""
  619:         template_last = """\
  620:             </style>"""
  621:         template_select = """\
  622:                 .dataframe %s {
  623:                     %s: %s;
  624:                 }"""
  625:         element_props = [
  626:             ("tbody tr th:only-of-type", "vertical-align", "middle"),
  627:             ("tbody tr th", "vertical-align", "top"),
  628:         ]
  629:         if isinstance(self.columns, MultiIndex):
  630:             element_props.append(("thead tr th", "text-align", "left"))
  631:             if self.show_row_idx_names:
  632:                 element_props.append(
  633:                     ("thead tr:last-of-type th", "text-align", "right")
  634:                 )
  635:         else:
  636:             element_props.append(("thead th", "text-align", "right"))
  637:         template_mid = "\n\n".join(template_select % t for t in element_props)
  638:         template = dedent(f"{template_first}\n{template_mid}\n{template_last}")
  639:         self.write(template)
  640: 
  641:     def render(self) -> list[str]:
  642:         self.write("<div>")
  643:         self.write_style()
  644:         super().render()
  645:         self.write("</div>")
  646:         return self.elements
