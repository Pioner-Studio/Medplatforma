    1: """
    2: Module for formatting output data into CSV files.
    3: """
    4: 
    5: from __future__ import annotations
    6: 
    7: from collections.abc import (
    8:     Hashable,
    9:     Iterable,
   10:     Iterator,
   11:     Sequence,
   12: )
   13: import csv as csvlib
   14: import os
   15: from typing import (
   16:     TYPE_CHECKING,
   17:     Any,
   18:     cast,
   19: )
   20: 
   21: import numpy as np
   22: 
   23: from pandas._libs import writers as libwriters
   24: from pandas._typing import SequenceNotStr
   25: from pandas.util._decorators import cache_readonly
   26: 
   27: from pandas.core.dtypes.generic import (
   28:     ABCDatetimeIndex,
   29:     ABCIndex,
   30:     ABCMultiIndex,
   31:     ABCPeriodIndex,
   32: )
   33: from pandas.core.dtypes.missing import notna
   34: 
   35: from pandas.core.indexes.api import Index
   36: 
   37: from pandas.io.common import get_handle
   38: 
   39: if TYPE_CHECKING:
   40:     from pandas._typing import (
   41:         CompressionOptions,
   42:         FilePath,
   43:         FloatFormatType,
   44:         IndexLabel,
   45:         StorageOptions,
   46:         WriteBuffer,
   47:         npt,
   48:     )
   49: 
   50:     from pandas.io.formats.format import DataFrameFormatter
   51: 
   52: 
   53: _DEFAULT_CHUNKSIZE_CELLS = 100_000
   54: 
   55: 
   56: class CSVFormatter:
   57:     cols: npt.NDArray[np.object_]
   58: 
   59:     def __init__(
   60:         self,
   61:         formatter: DataFrameFormatter,
   62:         path_or_buf: FilePath | WriteBuffer[str] | WriteBuffer[bytes] = "",
   63:         sep: str = ",",
   64:         cols: Sequence[Hashable] | None = None,
   65:         index_label: IndexLabel | None = None,
   66:         mode: str = "w",
   67:         encoding: str | None = None,
   68:         errors: str = "strict",
   69:         compression: CompressionOptions = "infer",
   70:         quoting: int | None = None,
   71:         lineterminator: str | None = "\n",
   72:         chunksize: int | None = None,
   73:         quotechar: str | None = '"',
   74:         date_format: str | None = None,
   75:         doublequote: bool = True,
   76:         escapechar: str | None = None,
   77:         storage_options: StorageOptions | None = None,
   78:     ) -> None:
   79:         self.fmt = formatter
   80: 
   81:         self.obj = self.fmt.frame
   82: 
   83:         self.filepath_or_buffer = path_or_buf
   84:         self.encoding = encoding
   85:         self.compression: CompressionOptions = compression
   86:         self.mode = mode
   87:         self.storage_options = storage_options
   88: 
   89:         self.sep = sep
   90:         self.index_label = self._initialize_index_label(index_label)
   91:         self.errors = errors
   92:         self.quoting = quoting or csvlib.QUOTE_MINIMAL
   93:         self.quotechar = self._initialize_quotechar(quotechar)
   94:         self.doublequote = doublequote
   95:         self.escapechar = escapechar
   96:         self.lineterminator = lineterminator or os.linesep
   97:         self.date_format = date_format
   98:         self.cols = self._initialize_columns(cols)
   99:         self.chunksize = self._initialize_chunksize(chunksize)
  100: 
  101:     @property
  102:     def na_rep(self) -> str:
  103:         return self.fmt.na_rep
  104: 
  105:     @property
  106:     def float_format(self) -> FloatFormatType | None:
  107:         return self.fmt.float_format
  108: 
  109:     @property
  110:     def decimal(self) -> str:
  111:         return self.fmt.decimal
  112: 
  113:     @property
  114:     def header(self) -> bool | SequenceNotStr[str]:
  115:         return self.fmt.header
  116: 
  117:     @property
  118:     def index(self) -> bool:
  119:         return self.fmt.index
  120: 
  121:     def _initialize_index_label(self, index_label: IndexLabel | None) -> IndexLabel:
  122:         if index_label is not False:
  123:             if index_label is None:
  124:                 return self._get_index_label_from_obj()
  125:             elif not isinstance(index_label, (list, tuple, np.ndarray, ABCIndex)):
  126:                 # given a string for a DF with Index
  127:                 return [index_label]
  128:         return index_label
  129: 
  130:     def _get_index_label_from_obj(self) -> Sequence[Hashable]:
  131:         if isinstance(self.obj.index, ABCMultiIndex):
  132:             return self._get_index_label_multiindex()
  133:         else:
  134:             return self._get_index_label_flat()
  135: 
  136:     def _get_index_label_multiindex(self) -> Sequence[Hashable]:
  137:         return [name or "" for name in self.obj.index.names]
  138: 
  139:     def _get_index_label_flat(self) -> Sequence[Hashable]:
  140:         index_label = self.obj.index.name
  141:         return [""] if index_label is None else [index_label]
  142: 
  143:     def _initialize_quotechar(self, quotechar: str | None) -> str | None:
  144:         if self.quoting != csvlib.QUOTE_NONE:
  145:             # prevents crash in _csv
  146:             return quotechar
  147:         return None
  148: 
  149:     @property
  150:     def has_mi_columns(self) -> bool:
  151:         return bool(isinstance(self.obj.columns, ABCMultiIndex))
  152: 
  153:     def _initialize_columns(
  154:         self, cols: Iterable[Hashable] | None
  155:     ) -> npt.NDArray[np.object_]:
  156:         # validate mi options
  157:         if self.has_mi_columns:
  158:             if cols is not None:
  159:                 msg = "cannot specify cols with a MultiIndex on the columns"
  160:                 raise TypeError(msg)
  161: 
  162:         if cols is not None:
  163:             if isinstance(cols, ABCIndex):
  164:                 cols = cols._get_values_for_csv(**self._number_format)
  165:             else:
  166:                 cols = list(cols)
  167:             self.obj = self.obj.loc[:, cols]
  168: 
  169:         # update columns to include possible multiplicity of dupes
  170:         # and make sure cols is just a list of labels
  171:         new_cols = self.obj.columns
  172:         return new_cols._get_values_for_csv(**self._number_format)
  173: 
  174:     def _initialize_chunksize(self, chunksize: int | None) -> int:
  175:         if chunksize is None:
  176:             return (_DEFAULT_CHUNKSIZE_CELLS // (len(self.cols) or 1)) or 1
  177:         return int(chunksize)
  178: 
  179:     @property
  180:     def _number_format(self) -> dict[str, Any]:
  181:         """Dictionary used for storing number formatting settings."""
  182:         return {
  183:             "na_rep": self.na_rep,
  184:             "float_format": self.float_format,
  185:             "date_format": self.date_format,
  186:             "quoting": self.quoting,
  187:             "decimal": self.decimal,
  188:         }
  189: 
  190:     @cache_readonly
  191:     def data_index(self) -> Index:
  192:         data_index = self.obj.index
  193:         if (
  194:             isinstance(data_index, (ABCDatetimeIndex, ABCPeriodIndex))
  195:             and self.date_format is not None
  196:         ):
  197:             data_index = Index(
  198:                 [x.strftime(self.date_format) if notna(x) else "" for x in data_index]
  199:             )
  200:         elif isinstance(data_index, ABCMultiIndex):
  201:             data_index = data_index.remove_unused_levels()
  202:         return data_index
  203: 
  204:     @property
  205:     def nlevels(self) -> int:
  206:         if self.index:
  207:             return getattr(self.data_index, "nlevels", 1)
  208:         else:
  209:             return 0
  210: 
  211:     @property
  212:     def _has_aliases(self) -> bool:
  213:         return isinstance(self.header, (tuple, list, np.ndarray, ABCIndex))
  214: 
  215:     @property
  216:     def _need_to_save_header(self) -> bool:
  217:         return bool(self._has_aliases or self.header)
  218: 
  219:     @property
  220:     def write_cols(self) -> SequenceNotStr[Hashable]:
  221:         if self._has_aliases:
  222:             assert not isinstance(self.header, bool)
  223:             if len(self.header) != len(self.cols):
  224:                 raise ValueError(
  225:                     f"Writing {len(self.cols)} cols but got {len(self.header)} aliases"
  226:                 )
  227:             return self.header
  228:         else:
  229:             # self.cols is an ndarray derived from Index._get_values_for_csv,
  230:             #  so its entries are strings, i.e. hashable
  231:             return cast(SequenceNotStr[Hashable], self.cols)
  232: 
  233:     @property
  234:     def encoded_labels(self) -> list[Hashable]:
  235:         encoded_labels: list[Hashable] = []
  236: 
  237:         if self.index and self.index_label:
  238:             assert isinstance(self.index_label, Sequence)
  239:             encoded_labels = list(self.index_label)
  240: 
  241:         if not self.has_mi_columns or self._has_aliases:
  242:             encoded_labels += list(self.write_cols)
  243: 
  244:         return encoded_labels
  245: 
  246:     def save(self) -> None:
  247:         """
  248:         Create the writer & save.
  249:         """
  250:         # apply compression and byte/text conversion
  251:         with get_handle(
  252:             self.filepath_or_buffer,
  253:             self.mode,
  254:             encoding=self.encoding,
  255:             errors=self.errors,
  256:             compression=self.compression,
  257:             storage_options=self.storage_options,
  258:         ) as handles:
  259:             # Note: self.encoding is irrelevant here
  260:             self.writer = csvlib.writer(
  261:                 handles.handle,
  262:                 lineterminator=self.lineterminator,
  263:                 delimiter=self.sep,
  264:                 quoting=self.quoting,
  265:                 doublequote=self.doublequote,
  266:                 escapechar=self.escapechar,
  267:                 quotechar=self.quotechar,
  268:             )
  269: 
  270:             self._save()
  271: 
  272:     def _save(self) -> None:
  273:         if self._need_to_save_header:
  274:             self._save_header()
  275:         self._save_body()
  276: 
  277:     def _save_header(self) -> None:
  278:         if not self.has_mi_columns or self._has_aliases:
  279:             self.writer.writerow(self.encoded_labels)
  280:         else:
  281:             for row in self._generate_multiindex_header_rows():
  282:                 self.writer.writerow(row)
  283: 
  284:     def _generate_multiindex_header_rows(self) -> Iterator[list[Hashable]]:
  285:         columns = self.obj.columns
  286:         for i in range(columns.nlevels):
  287:             # we need at least 1 index column to write our col names
  288:             col_line = []
  289:             if self.index:
  290:                 # name is the first column
  291:                 col_line.append(columns.names[i])
  292: 
  293:                 if isinstance(self.index_label, list) and len(self.index_label) > 1:
  294:                     col_line.extend([""] * (len(self.index_label) - 1))
  295: 
  296:             col_line.extend(columns._get_level_values(i))
  297:             yield col_line
  298: 
  299:         # Write out the index line if it's not empty.
  300:         # Otherwise, we will print out an extraneous
  301:         # blank line between the mi and the data rows.
  302:         if self.encoded_labels and set(self.encoded_labels) != {""}:
  303:             yield self.encoded_labels + [""] * len(columns)
  304: 
  305:     def _save_body(self) -> None:
  306:         nrows = len(self.data_index)
  307:         chunks = (nrows // self.chunksize) + 1
  308:         for i in range(chunks):
  309:             start_i = i * self.chunksize
  310:             end_i = min(start_i + self.chunksize, nrows)
  311:             if start_i >= end_i:
  312:                 break
  313:             self._save_chunk(start_i, end_i)
  314: 
  315:     def _save_chunk(self, start_i: int, end_i: int) -> None:
  316:         # create the data for a chunk
  317:         slicer = slice(start_i, end_i)
  318:         df = self.obj.iloc[slicer]
  319: 
  320:         res = df._get_values_for_csv(**self._number_format)
  321:         data = list(res._iter_column_arrays())
  322: 
  323:         ix = self.data_index[slicer]._get_values_for_csv(**self._number_format)
  324:         libwriters.write_csv_rows(
  325:             data,
  326:             ix,
  327:             self.nlevels,
  328:             self.cols,
  329:             self.writer,
  330:         )
