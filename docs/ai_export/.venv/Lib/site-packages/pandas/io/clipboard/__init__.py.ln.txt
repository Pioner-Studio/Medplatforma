    1: """
    2: Pyperclip
    3: 
    4: A cross-platform clipboard module for Python,
    5: with copy & paste functions for plain text.
    6: By Al Sweigart al@inventwithpython.com
    7: Licence at LICENSES/PYPERCLIP_LICENSE
    8: 
    9: Usage:
   10:   import pyperclip
   11:   pyperclip.copy('The text to be copied to the clipboard.')
   12:   spam = pyperclip.paste()
   13: 
   14:   if not pyperclip.is_available():
   15:     print("Copy functionality unavailable!")
   16: 
   17: On Windows, no additional modules are needed.
   18: On Mac, the pyobjc module is used, falling back to the pbcopy and pbpaste cli
   19:     commands. (These commands should come with OS X.).
   20: On Linux, install xclip, xsel, or wl-clipboard (for "wayland" sessions) via
   21: package manager.
   22: For example, in Debian:
   23:     sudo apt-get install xclip
   24:     sudo apt-get install xsel
   25:     sudo apt-get install wl-clipboard
   26: 
   27: Otherwise on Linux, you will need the PyQt5 modules installed.
   28: 
   29: This module does not work with PyGObject yet.
   30: 
   31: Cygwin is currently not supported.
   32: 
   33: Security Note: This module runs programs with these names:
   34:     - pbcopy
   35:     - pbpaste
   36:     - xclip
   37:     - xsel
   38:     - wl-copy/wl-paste
   39:     - klipper
   40:     - qdbus
   41: A malicious user could rename or add programs with these names, tricking
   42: Pyperclip into running them with whatever permissions the Python process has.
   43: 
   44: """
   45: 
   46: __version__ = "1.8.2"
   47: 
   48: 
   49: import contextlib
   50: import ctypes
   51: from ctypes import (
   52:     c_size_t,
   53:     c_wchar,
   54:     c_wchar_p,
   55:     get_errno,
   56:     sizeof,
   57: )
   58: import os
   59: import platform
   60: from shutil import which as _executable_exists
   61: import subprocess
   62: import time
   63: import warnings
   64: 
   65: from pandas.errors import (
   66:     PyperclipException,
   67:     PyperclipWindowsException,
   68: )
   69: from pandas.util._exceptions import find_stack_level
   70: 
   71: # `import PyQt4` sys.exit()s if DISPLAY is not in the environment.
   72: # Thus, we need to detect the presence of $DISPLAY manually
   73: # and not load PyQt4 if it is absent.
   74: HAS_DISPLAY = os.getenv("DISPLAY")
   75: 
   76: EXCEPT_MSG = """
   77:     Pyperclip could not find a copy/paste mechanism for your system.
   78:     For more information, please visit
   79:     https://pyperclip.readthedocs.io/en/latest/index.html#not-implemented-error
   80:     """
   81: 
   82: ENCODING = "utf-8"
   83: 
   84: 
   85: class PyperclipTimeoutException(PyperclipException):
   86:     pass
   87: 
   88: 
   89: def _stringifyText(text) -> str:
   90:     acceptedTypes = (str, int, float, bool)
   91:     if not isinstance(text, acceptedTypes):
   92:         raise PyperclipException(
   93:             f"only str, int, float, and bool values "
   94:             f"can be copied to the clipboard, not {type(text).__name__}"
   95:         )
   96:     return str(text)
   97: 
   98: 
   99: def init_osx_pbcopy_clipboard():
  100:     def copy_osx_pbcopy(text):
  101:         text = _stringifyText(text)  # Converts non-str values to str.
  102:         with subprocess.Popen(
  103:             ["pbcopy", "w"], stdin=subprocess.PIPE, close_fds=True
  104:         ) as p:
  105:             p.communicate(input=text.encode(ENCODING))
  106: 
  107:     def paste_osx_pbcopy():
  108:         with subprocess.Popen(
  109:             ["pbpaste", "r"], stdout=subprocess.PIPE, close_fds=True
  110:         ) as p:
  111:             stdout = p.communicate()[0]
  112:         return stdout.decode(ENCODING)
  113: 
  114:     return copy_osx_pbcopy, paste_osx_pbcopy
  115: 
  116: 
  117: def init_osx_pyobjc_clipboard():
  118:     def copy_osx_pyobjc(text):
  119:         """Copy string argument to clipboard"""
  120:         text = _stringifyText(text)  # Converts non-str values to str.
  121:         newStr = Foundation.NSString.stringWithString_(text).nsstring()
  122:         newData = newStr.dataUsingEncoding_(Foundation.NSUTF8StringEncoding)
  123:         board = AppKit.NSPasteboard.generalPasteboard()
  124:         board.declareTypes_owner_([AppKit.NSStringPboardType], None)
  125:         board.setData_forType_(newData, AppKit.NSStringPboardType)
  126: 
  127:     def paste_osx_pyobjc():
  128:         """Returns contents of clipboard"""
  129:         board = AppKit.NSPasteboard.generalPasteboard()
  130:         content = board.stringForType_(AppKit.NSStringPboardType)
  131:         return content
  132: 
  133:     return copy_osx_pyobjc, paste_osx_pyobjc
  134: 
  135: 
  136: def init_qt_clipboard():
  137:     global QApplication
  138:     # $DISPLAY should exist
  139: 
  140:     # Try to import from qtpy, but if that fails try PyQt5 then PyQt4
  141:     try:
  142:         from qtpy.QtWidgets import QApplication
  143:     except ImportError:
  144:         try:
  145:             from PyQt5.QtWidgets import QApplication
  146:         except ImportError:
  147:             from PyQt4.QtGui import QApplication
  148: 
  149:     app = QApplication.instance()
  150:     if app is None:
  151:         app = QApplication([])
  152: 
  153:     def copy_qt(text):
  154:         text = _stringifyText(text)  # Converts non-str values to str.
  155:         cb = app.clipboard()
  156:         cb.setText(text)
  157: 
  158:     def paste_qt() -> str:
  159:         cb = app.clipboard()
  160:         return str(cb.text())
  161: 
  162:     return copy_qt, paste_qt
  163: 
  164: 
  165: def init_xclip_clipboard():
  166:     DEFAULT_SELECTION = "c"
  167:     PRIMARY_SELECTION = "p"
  168: 
  169:     def copy_xclip(text, primary=False):
  170:         text = _stringifyText(text)  # Converts non-str values to str.
  171:         selection = DEFAULT_SELECTION
  172:         if primary:
  173:             selection = PRIMARY_SELECTION
  174:         with subprocess.Popen(
  175:             ["xclip", "-selection", selection], stdin=subprocess.PIPE, close_fds=True
  176:         ) as p:
  177:             p.communicate(input=text.encode(ENCODING))
  178: 
  179:     def paste_xclip(primary=False):
  180:         selection = DEFAULT_SELECTION
  181:         if primary:
  182:             selection = PRIMARY_SELECTION
  183:         with subprocess.Popen(
  184:             ["xclip", "-selection", selection, "-o"],
  185:             stdout=subprocess.PIPE,
  186:             stderr=subprocess.PIPE,
  187:             close_fds=True,
  188:         ) as p:
  189:             stdout = p.communicate()[0]
  190:         # Intentionally ignore extraneous output on stderr when clipboard is empty
  191:         return stdout.decode(ENCODING)
  192: 
  193:     return copy_xclip, paste_xclip
  194: 
  195: 
  196: def init_xsel_clipboard():
  197:     DEFAULT_SELECTION = "-b"
  198:     PRIMARY_SELECTION = "-p"
  199: 
  200:     def copy_xsel(text, primary=False):
  201:         text = _stringifyText(text)  # Converts non-str values to str.
  202:         selection_flag = DEFAULT_SELECTION
  203:         if primary:
  204:             selection_flag = PRIMARY_SELECTION
  205:         with subprocess.Popen(
  206:             ["xsel", selection_flag, "-i"], stdin=subprocess.PIPE, close_fds=True
  207:         ) as p:
  208:             p.communicate(input=text.encode(ENCODING))
  209: 
  210:     def paste_xsel(primary=False):
  211:         selection_flag = DEFAULT_SELECTION
  212:         if primary:
  213:             selection_flag = PRIMARY_SELECTION
  214:         with subprocess.Popen(
  215:             ["xsel", selection_flag, "-o"], stdout=subprocess.PIPE, close_fds=True
  216:         ) as p:
  217:             stdout = p.communicate()[0]
  218:         return stdout.decode(ENCODING)
  219: 
  220:     return copy_xsel, paste_xsel
  221: 
  222: 
  223: def init_wl_clipboard():
  224:     PRIMARY_SELECTION = "-p"
  225: 
  226:     def copy_wl(text, primary=False):
  227:         text = _stringifyText(text)  # Converts non-str values to str.
  228:         args = ["wl-copy"]
  229:         if primary:
  230:             args.append(PRIMARY_SELECTION)
  231:         if not text:
  232:             args.append("--clear")
  233:             subprocess.check_call(args, close_fds=True)
  234:         else:
  235:             p = subprocess.Popen(args, stdin=subprocess.PIPE, close_fds=True)
  236:             p.communicate(input=text.encode(ENCODING))
  237: 
  238:     def paste_wl(primary=False):
  239:         args = ["wl-paste", "-n"]
  240:         if primary:
  241:             args.append(PRIMARY_SELECTION)
  242:         p = subprocess.Popen(args, stdout=subprocess.PIPE, close_fds=True)
  243:         stdout, _stderr = p.communicate()
  244:         return stdout.decode(ENCODING)
  245: 
  246:     return copy_wl, paste_wl
  247: 
  248: 
  249: def init_klipper_clipboard():
  250:     def copy_klipper(text):
  251:         text = _stringifyText(text)  # Converts non-str values to str.
  252:         with subprocess.Popen(
  253:             [
  254:                 "qdbus",
  255:                 "org.kde.klipper",
  256:                 "/klipper",
  257:                 "setClipboardContents",
  258:                 text.encode(ENCODING),
  259:             ],
  260:             stdin=subprocess.PIPE,
  261:             close_fds=True,
  262:         ) as p:
  263:             p.communicate(input=None)
  264: 
  265:     def paste_klipper():
  266:         with subprocess.Popen(
  267:             ["qdbus", "org.kde.klipper", "/klipper", "getClipboardContents"],
  268:             stdout=subprocess.PIPE,
  269:             close_fds=True,
  270:         ) as p:
  271:             stdout = p.communicate()[0]
  272: 
  273:         # Workaround for https://bugs.kde.org/show_bug.cgi?id=342874
  274:         # TODO: https://github.com/asweigart/pyperclip/issues/43
  275:         clipboardContents = stdout.decode(ENCODING)
  276:         # even if blank, Klipper will append a newline at the end
  277:         assert len(clipboardContents) > 0
  278:         # make sure that newline is there
  279:         assert clipboardContents.endswith("\n")
  280:         if clipboardContents.endswith("\n"):
  281:             clipboardContents = clipboardContents[:-1]
  282:         return clipboardContents
  283: 
  284:     return copy_klipper, paste_klipper
  285: 
  286: 
  287: def init_dev_clipboard_clipboard():
  288:     def copy_dev_clipboard(text):
  289:         text = _stringifyText(text)  # Converts non-str values to str.
  290:         if text == "":
  291:             warnings.warn(
  292:                 "Pyperclip cannot copy a blank string to the clipboard on Cygwin. "
  293:                 "This is effectively a no-op.",
  294:                 stacklevel=find_stack_level(),
  295:             )
  296:         if "\r" in text:
  297:             warnings.warn(
  298:                 "Pyperclip cannot handle \\r characters on Cygwin.",
  299:                 stacklevel=find_stack_level(),
  300:             )
  301: 
  302:         with open("/dev/clipboard", "w", encoding="utf-8") as fd:
  303:             fd.write(text)
  304: 
  305:     def paste_dev_clipboard() -> str:
  306:         with open("/dev/clipboard", encoding="utf-8") as fd:
  307:             content = fd.read()
  308:         return content
  309: 
  310:     return copy_dev_clipboard, paste_dev_clipboard
  311: 
  312: 
  313: def init_no_clipboard():
  314:     class ClipboardUnavailable:
  315:         def __call__(self, *args, **kwargs):
  316:             raise PyperclipException(EXCEPT_MSG)
  317: 
  318:         def __bool__(self) -> bool:
  319:             return False
  320: 
  321:     return ClipboardUnavailable(), ClipboardUnavailable()
  322: 
  323: 
  324: # Windows-related clipboard functions:
  325: class CheckedCall:
  326:     def __init__(self, f) -> None:
  327:         super().__setattr__("f", f)
  328: 
  329:     def __call__(self, *args):
  330:         ret = self.f(*args)
  331:         if not ret and get_errno():
  332:             raise PyperclipWindowsException("Error calling " + self.f.__name__)
  333:         return ret
  334: 
  335:     def __setattr__(self, key, value):
  336:         setattr(self.f, key, value)
  337: 
  338: 
  339: def init_windows_clipboard():
  340:     global HGLOBAL, LPVOID, DWORD, LPCSTR, INT
  341:     global HWND, HINSTANCE, HMENU, BOOL, UINT, HANDLE
  342:     from ctypes.wintypes import (
  343:         BOOL,
  344:         DWORD,
  345:         HANDLE,
  346:         HGLOBAL,
  347:         HINSTANCE,
  348:         HMENU,
  349:         HWND,
  350:         INT,
  351:         LPCSTR,
  352:         LPVOID,
  353:         UINT,
  354:     )
  355: 
  356:     windll = ctypes.windll
  357:     msvcrt = ctypes.CDLL("msvcrt")
  358: 
  359:     safeCreateWindowExA = CheckedCall(windll.user32.CreateWindowExA)
  360:     safeCreateWindowExA.argtypes = [
  361:         DWORD,
  362:         LPCSTR,
  363:         LPCSTR,
  364:         DWORD,
  365:         INT,
  366:         INT,
  367:         INT,
  368:         INT,
  369:         HWND,
  370:         HMENU,
  371:         HINSTANCE,
  372:         LPVOID,
  373:     ]
  374:     safeCreateWindowExA.restype = HWND
  375: 
  376:     safeDestroyWindow = CheckedCall(windll.user32.DestroyWindow)
  377:     safeDestroyWindow.argtypes = [HWND]
  378:     safeDestroyWindow.restype = BOOL
  379: 
  380:     OpenClipboard = windll.user32.OpenClipboard
  381:     OpenClipboard.argtypes = [HWND]
  382:     OpenClipboard.restype = BOOL
  383: 
  384:     safeCloseClipboard = CheckedCall(windll.user32.CloseClipboard)
  385:     safeCloseClipboard.argtypes = []
  386:     safeCloseClipboard.restype = BOOL
  387: 
  388:     safeEmptyClipboard = CheckedCall(windll.user32.EmptyClipboard)
  389:     safeEmptyClipboard.argtypes = []
  390:     safeEmptyClipboard.restype = BOOL
  391: 
  392:     safeGetClipboardData = CheckedCall(windll.user32.GetClipboardData)
  393:     safeGetClipboardData.argtypes = [UINT]
  394:     safeGetClipboardData.restype = HANDLE
  395: 
  396:     safeSetClipboardData = CheckedCall(windll.user32.SetClipboardData)
  397:     safeSetClipboardData.argtypes = [UINT, HANDLE]
  398:     safeSetClipboardData.restype = HANDLE
  399: 
  400:     safeGlobalAlloc = CheckedCall(windll.kernel32.GlobalAlloc)
  401:     safeGlobalAlloc.argtypes = [UINT, c_size_t]
  402:     safeGlobalAlloc.restype = HGLOBAL
  403: 
  404:     safeGlobalLock = CheckedCall(windll.kernel32.GlobalLock)
  405:     safeGlobalLock.argtypes = [HGLOBAL]
  406:     safeGlobalLock.restype = LPVOID
  407: 
  408:     safeGlobalUnlock = CheckedCall(windll.kernel32.GlobalUnlock)
  409:     safeGlobalUnlock.argtypes = [HGLOBAL]
  410:     safeGlobalUnlock.restype = BOOL
  411: 
  412:     wcslen = CheckedCall(msvcrt.wcslen)
  413:     wcslen.argtypes = [c_wchar_p]
  414:     wcslen.restype = UINT
  415: 
  416:     GMEM_MOVEABLE = 0x0002
  417:     CF_UNICODETEXT = 13
  418: 
  419:     @contextlib.contextmanager
  420:     def window():
  421:         """
  422:         Context that provides a valid Windows hwnd.
  423:         """
  424:         # we really just need the hwnd, so setting "STATIC"
  425:         # as predefined lpClass is just fine.
  426:         hwnd = safeCreateWindowExA(
  427:             0, b"STATIC", None, 0, 0, 0, 0, 0, None, None, None, None
  428:         )
  429:         try:
  430:             yield hwnd
  431:         finally:
  432:             safeDestroyWindow(hwnd)
  433: 
  434:     @contextlib.contextmanager
  435:     def clipboard(hwnd):
  436:         """
  437:         Context manager that opens the clipboard and prevents
  438:         other applications from modifying the clipboard content.
  439:         """
  440:         # We may not get the clipboard handle immediately because
  441:         # some other application is accessing it (?)
  442:         # We try for at least 500ms to get the clipboard.
  443:         t = time.time() + 0.5
  444:         success = False
  445:         while time.time() < t:
  446:             success = OpenClipboard(hwnd)
  447:             if success:
  448:                 break
  449:             time.sleep(0.01)
  450:         if not success:
  451:             raise PyperclipWindowsException("Error calling OpenClipboard")
  452: 
  453:         try:
  454:             yield
  455:         finally:
  456:             safeCloseClipboard()
  457: 
  458:     def copy_windows(text):
  459:         # This function is heavily based on
  460:         # http://msdn.com/ms649016#_win32_Copying_Information_to_the_Clipboard
  461: 
  462:         text = _stringifyText(text)  # Converts non-str values to str.
  463: 
  464:         with window() as hwnd:
  465:             # http://msdn.com/ms649048
  466:             # If an application calls OpenClipboard with hwnd set to NULL,
  467:             # EmptyClipboard sets the clipboard owner to NULL;
  468:             # this causes SetClipboardData to fail.
  469:             # => We need a valid hwnd to copy something.
  470:             with clipboard(hwnd):
  471:                 safeEmptyClipboard()
  472: 
  473:                 if text:
  474:                     # http://msdn.com/ms649051
  475:                     # If the hMem parameter identifies a memory object,
  476:                     # the object must have been allocated using the
  477:                     # function with the GMEM_MOVEABLE flag.
  478:                     count = wcslen(text) + 1
  479:                     handle = safeGlobalAlloc(GMEM_MOVEABLE, count * sizeof(c_wchar))
  480:                     locked_handle = safeGlobalLock(handle)
  481: 
  482:                     ctypes.memmove(
  483:                         c_wchar_p(locked_handle),
  484:                         c_wchar_p(text),
  485:                         count * sizeof(c_wchar),
  486:                     )
  487: 
  488:                     safeGlobalUnlock(handle)
  489:                     safeSetClipboardData(CF_UNICODETEXT, handle)
  490: 
  491:     def paste_windows():
  492:         with clipboard(None):
  493:             handle = safeGetClipboardData(CF_UNICODETEXT)
  494:             if not handle:
  495:                 # GetClipboardData may return NULL with errno == NO_ERROR
  496:                 # if the clipboard is empty.
  497:                 # (Also, it may return a handle to an empty buffer,
  498:                 # but technically that's not empty)
  499:                 return ""
  500:             return c_wchar_p(handle).value
  501: 
  502:     return copy_windows, paste_windows
  503: 
  504: 
  505: def init_wsl_clipboard():
  506:     def copy_wsl(text):
  507:         text = _stringifyText(text)  # Converts non-str values to str.
  508:         with subprocess.Popen(["clip.exe"], stdin=subprocess.PIPE, close_fds=True) as p:
  509:             p.communicate(input=text.encode(ENCODING))
  510: 
  511:     def paste_wsl():
  512:         with subprocess.Popen(
  513:             ["powershell.exe", "-command", "Get-Clipboard"],
  514:             stdout=subprocess.PIPE,
  515:             stderr=subprocess.PIPE,
  516:             close_fds=True,
  517:         ) as p:
  518:             stdout = p.communicate()[0]
  519:         # WSL appends "\r\n" to the contents.
  520:         return stdout[:-2].decode(ENCODING)
  521: 
  522:     return copy_wsl, paste_wsl
  523: 
  524: 
  525: # Automatic detection of clipboard mechanisms
  526: # and importing is done in determine_clipboard():
  527: def determine_clipboard():
  528:     """
  529:     Determine the OS/platform and set the copy() and paste() functions
  530:     accordingly.
  531:     """
  532:     global Foundation, AppKit, qtpy, PyQt4, PyQt5
  533: 
  534:     # Setup for the CYGWIN platform:
  535:     if (
  536:         "cygwin" in platform.system().lower()
  537:     ):  # Cygwin has a variety of values returned by platform.system(),
  538:         # such as 'CYGWIN_NT-6.1'
  539:         # FIXME(pyperclip#55): pyperclip currently does not support Cygwin,
  540:         # see https://github.com/asweigart/pyperclip/issues/55
  541:         if os.path.exists("/dev/clipboard"):
  542:             warnings.warn(
  543:                 "Pyperclip's support for Cygwin is not perfect, "
  544:                 "see https://github.com/asweigart/pyperclip/issues/55",
  545:                 stacklevel=find_stack_level(),
  546:             )
  547:             return init_dev_clipboard_clipboard()
  548: 
  549:     # Setup for the WINDOWS platform:
  550:     elif os.name == "nt" or platform.system() == "Windows":
  551:         return init_windows_clipboard()
  552: 
  553:     if platform.system() == "Linux":
  554:         if _executable_exists("wslconfig.exe"):
  555:             return init_wsl_clipboard()
  556: 
  557:     # Setup for the macOS platform:
  558:     if os.name == "mac" or platform.system() == "Darwin":
  559:         try:
  560:             import AppKit
  561:             import Foundation  # check if pyobjc is installed
  562:         except ImportError:
  563:             return init_osx_pbcopy_clipboard()
  564:         else:
  565:             return init_osx_pyobjc_clipboard()
  566: 
  567:     # Setup for the LINUX platform:
  568:     if HAS_DISPLAY:
  569:         if os.environ.get("WAYLAND_DISPLAY") and _executable_exists("wl-copy"):
  570:             return init_wl_clipboard()
  571:         if _executable_exists("xsel"):
  572:             return init_xsel_clipboard()
  573:         if _executable_exists("xclip"):
  574:             return init_xclip_clipboard()
  575:         if _executable_exists("klipper") and _executable_exists("qdbus"):
  576:             return init_klipper_clipboard()
  577: 
  578:         try:
  579:             # qtpy is a small abstraction layer that lets you write applications
  580:             # using a single api call to either PyQt or PySide.
  581:             # https://pypi.python.org/project/QtPy
  582:             import qtpy  # check if qtpy is installed
  583:         except ImportError:
  584:             # If qtpy isn't installed, fall back on importing PyQt4.
  585:             try:
  586:                 import PyQt5  # check if PyQt5 is installed
  587:             except ImportError:
  588:                 try:
  589:                     import PyQt4  # check if PyQt4 is installed
  590:                 except ImportError:
  591:                     pass  # We want to fail fast for all non-ImportError exceptions.
  592:                 else:
  593:                     return init_qt_clipboard()
  594:             else:
  595:                 return init_qt_clipboard()
  596:         else:
  597:             return init_qt_clipboard()
  598: 
  599:     return init_no_clipboard()
  600: 
  601: 
  602: def set_clipboard(clipboard):
  603:     """
  604:     Explicitly sets the clipboard mechanism. The "clipboard mechanism" is how
  605:     the copy() and paste() functions interact with the operating system to
  606:     implement the copy/paste feature. The clipboard parameter must be one of:
  607:         - pbcopy
  608:         - pyobjc (default on macOS)
  609:         - qt
  610:         - xclip
  611:         - xsel
  612:         - klipper
  613:         - windows (default on Windows)
  614:         - no (this is what is set when no clipboard mechanism can be found)
  615:     """
  616:     global copy, paste
  617: 
  618:     clipboard_types = {
  619:         "pbcopy": init_osx_pbcopy_clipboard,
  620:         "pyobjc": init_osx_pyobjc_clipboard,
  621:         "qt": init_qt_clipboard,  # TODO - split this into 'qtpy', 'pyqt4', and 'pyqt5'
  622:         "xclip": init_xclip_clipboard,
  623:         "xsel": init_xsel_clipboard,
  624:         "wl-clipboard": init_wl_clipboard,
  625:         "klipper": init_klipper_clipboard,
  626:         "windows": init_windows_clipboard,
  627:         "no": init_no_clipboard,
  628:     }
  629: 
  630:     if clipboard not in clipboard_types:
  631:         allowed_clipboard_types = [repr(_) for _ in clipboard_types]
  632:         raise ValueError(
  633:             f"Argument must be one of {', '.join(allowed_clipboard_types)}"
  634:         )
  635: 
  636:     # Sets pyperclip's copy() and paste() functions:
  637:     copy, paste = clipboard_types[clipboard]()
  638: 
  639: 
  640: def lazy_load_stub_copy(text):
  641:     """
  642:     A stub function for copy(), which will load the real copy() function when
  643:     called so that the real copy() function is used for later calls.
  644: 
  645:     This allows users to import pyperclip without having determine_clipboard()
  646:     automatically run, which will automatically select a clipboard mechanism.
  647:     This could be a problem if it selects, say, the memory-heavy PyQt4 module
  648:     but the user was just going to immediately call set_clipboard() to use a
  649:     different clipboard mechanism.
  650: 
  651:     The lazy loading this stub function implements gives the user a chance to
  652:     call set_clipboard() to pick another clipboard mechanism. Or, if the user
  653:     simply calls copy() or paste() without calling set_clipboard() first,
  654:     will fall back on whatever clipboard mechanism that determine_clipboard()
  655:     automatically chooses.
  656:     """
  657:     global copy, paste
  658:     copy, paste = determine_clipboard()
  659:     return copy(text)
  660: 
  661: 
  662: def lazy_load_stub_paste():
  663:     """
  664:     A stub function for paste(), which will load the real paste() function when
  665:     called so that the real paste() function is used for later calls.
  666: 
  667:     This allows users to import pyperclip without having determine_clipboard()
  668:     automatically run, which will automatically select a clipboard mechanism.
  669:     This could be a problem if it selects, say, the memory-heavy PyQt4 module
  670:     but the user was just going to immediately call set_clipboard() to use a
  671:     different clipboard mechanism.
  672: 
  673:     The lazy loading this stub function implements gives the user a chance to
  674:     call set_clipboard() to pick another clipboard mechanism. Or, if the user
  675:     simply calls copy() or paste() without calling set_clipboard() first,
  676:     will fall back on whatever clipboard mechanism that determine_clipboard()
  677:     automatically chooses.
  678:     """
  679:     global copy, paste
  680:     copy, paste = determine_clipboard()
  681:     return paste()
  682: 
  683: 
  684: def is_available() -> bool:
  685:     return copy != lazy_load_stub_copy and paste != lazy_load_stub_paste
  686: 
  687: 
  688: # Initially, copy() and paste() are set to lazy loading wrappers which will
  689: # set `copy` and `paste` to real functions the first time they're used, unless
  690: # set_clipboard() or determine_clipboard() is called first.
  691: copy, paste = lazy_load_stub_copy, lazy_load_stub_paste
  692: 
  693: 
  694: def waitForPaste(timeout=None):
  695:     """This function call blocks until a non-empty text string exists on the
  696:     clipboard. It returns this text.
  697: 
  698:     This function raises PyperclipTimeoutException if timeout was set to
  699:     a number of seconds that has elapsed without non-empty text being put on
  700:     the clipboard."""
  701:     startTime = time.time()
  702:     while True:
  703:         clipboardText = paste()
  704:         if clipboardText != "":
  705:             return clipboardText
  706:         time.sleep(0.01)
  707: 
  708:         if timeout is not None and time.time() > startTime + timeout:
  709:             raise PyperclipTimeoutException(
  710:                 "waitForPaste() timed out after " + str(timeout) + " seconds."
  711:             )
  712: 
  713: 
  714: def waitForNewPaste(timeout=None):
  715:     """This function call blocks until a new text string exists on the
  716:     clipboard that is different from the text that was there when the function
  717:     was first called. It returns this text.
  718: 
  719:     This function raises PyperclipTimeoutException if timeout was set to
  720:     a number of seconds that has elapsed without non-empty text being put on
  721:     the clipboard."""
  722:     startTime = time.time()
  723:     originalText = paste()
  724:     while True:
  725:         currentText = paste()
  726:         if currentText != originalText:
  727:             return currentText
  728:         time.sleep(0.01)
  729: 
  730:         if timeout is not None and time.time() > startTime + timeout:
  731:             raise PyperclipTimeoutException(
  732:                 "waitForNewPaste() timed out after " + str(timeout) + " seconds."
  733:             )
  734: 
  735: 
  736: __all__ = [
  737:     "copy",
  738:     "paste",
  739:     "waitForPaste",
  740:     "waitForNewPaste",
  741:     "set_clipboard",
  742:     "determine_clipboard",
  743: ]
  744: 
  745: # pandas aliases
  746: clipboard_get = paste
  747: clipboard_set = copy
