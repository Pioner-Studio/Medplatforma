    1: """
    2: This file is very long and growing, but it was decided to not split it yet, as
    3: it's still manageable (2020-03-17, ~1.1k LoC). See gh-31989
    4: 
    5: Instead of splitting it was decided to define sections here:
    6: - Configuration / Settings
    7: - Autouse fixtures
    8: - Common arguments
    9: - Missing values & co.
   10: - Classes
   11: - Indices
   12: - Series'
   13: - DataFrames
   14: - Operators & Operations
   15: - Data sets/files
   16: - Time zones
   17: - Dtypes
   18: - Misc
   19: """
   20: from __future__ import annotations
   21: 
   22: from collections import abc
   23: from datetime import (
   24:     date,
   25:     datetime,
   26:     time,
   27:     timedelta,
   28:     timezone,
   29: )
   30: from decimal import Decimal
   31: import operator
   32: import os
   33: from typing import (
   34:     TYPE_CHECKING,
   35:     Callable,
   36: )
   37: 
   38: from dateutil.tz import (
   39:     tzlocal,
   40:     tzutc,
   41: )
   42: import hypothesis
   43: from hypothesis import strategies as st
   44: import numpy as np
   45: import pytest
   46: from pytz import (
   47:     FixedOffset,
   48:     utc,
   49: )
   50: 
   51: from pandas._config.config import _get_option
   52: 
   53: import pandas.util._test_decorators as td
   54: 
   55: from pandas.core.dtypes.dtypes import (
   56:     DatetimeTZDtype,
   57:     IntervalDtype,
   58: )
   59: 
   60: import pandas as pd
   61: from pandas import (
   62:     CategoricalIndex,
   63:     DataFrame,
   64:     Interval,
   65:     IntervalIndex,
   66:     Period,
   67:     RangeIndex,
   68:     Series,
   69:     Timedelta,
   70:     Timestamp,
   71:     date_range,
   72:     period_range,
   73:     timedelta_range,
   74: )
   75: import pandas._testing as tm
   76: from pandas.core import ops
   77: from pandas.core.indexes.api import (
   78:     Index,
   79:     MultiIndex,
   80: )
   81: from pandas.util.version import Version
   82: 
   83: if TYPE_CHECKING:
   84:     from collections.abc import (
   85:         Hashable,
   86:         Iterator,
   87:     )
   88: 
   89: try:
   90:     import pyarrow as pa
   91: except ImportError:
   92:     has_pyarrow = False
   93: else:
   94:     del pa
   95:     has_pyarrow = True
   96: 
   97: import zoneinfo
   98: 
   99: try:
  100:     zoneinfo.ZoneInfo("UTC")
  101: except zoneinfo.ZoneInfoNotFoundError:
  102:     zoneinfo = None  # type: ignore[assignment]
  103: 
  104: 
  105: # ----------------------------------------------------------------
  106: # Configuration / Settings
  107: # ----------------------------------------------------------------
  108: # pytest
  109: 
  110: 
  111: def pytest_addoption(parser) -> None:
  112:     parser.addoption(
  113:         "--no-strict-data-files",
  114:         action="store_false",
  115:         help="Don't fail if a test is skipped for missing data file.",
  116:     )
  117: 
  118: 
  119: def ignore_doctest_warning(item: pytest.Item, path: str, message: str) -> None:
  120:     """Ignore doctest warning.
  121: 
  122:     Parameters
  123:     ----------
  124:     item : pytest.Item
  125:         pytest test item.
  126:     path : str
  127:         Module path to Python object, e.g. "pandas.core.frame.DataFrame.append". A
  128:         warning will be filtered when item.name ends with in given path. So it is
  129:         sufficient to specify e.g. "DataFrame.append".
  130:     message : str
  131:         Message to be filtered.
  132:     """
  133:     if item.name.endswith(path):
  134:         item.add_marker(pytest.mark.filterwarnings(f"ignore:{message}"))
  135: 
  136: 
  137: def pytest_collection_modifyitems(items, config) -> None:
  138:     is_doctest = config.getoption("--doctest-modules") or config.getoption(
  139:         "--doctest-cython", default=False
  140:     )
  141: 
  142:     # Warnings from doctests that can be ignored; place reason in comment above.
  143:     # Each entry specifies (path, message) - see the ignore_doctest_warning function
  144:     ignored_doctest_warnings = [
  145:         ("is_int64_dtype", "is_int64_dtype is deprecated"),
  146:         ("is_interval_dtype", "is_interval_dtype is deprecated"),
  147:         ("is_period_dtype", "is_period_dtype is deprecated"),
  148:         ("is_datetime64tz_dtype", "is_datetime64tz_dtype is deprecated"),
  149:         ("is_categorical_dtype", "is_categorical_dtype is deprecated"),
  150:         ("is_sparse", "is_sparse is deprecated"),
  151:         ("DataFrameGroupBy.fillna", "DataFrameGroupBy.fillna is deprecated"),
  152:         ("NDFrame.replace", "The 'method' keyword"),
  153:         ("NDFrame.replace", "Series.replace without 'value'"),
  154:         ("NDFrame.clip", "Downcasting behavior in Series and DataFrame methods"),
  155:         ("Series.idxmin", "The behavior of Series.idxmin"),
  156:         ("Series.idxmax", "The behavior of Series.idxmax"),
  157:         ("SeriesGroupBy.fillna", "SeriesGroupBy.fillna is deprecated"),
  158:         ("SeriesGroupBy.idxmin", "The behavior of Series.idxmin"),
  159:         ("SeriesGroupBy.idxmax", "The behavior of Series.idxmax"),
  160:         # Docstring divides by zero to show behavior difference
  161:         ("missing.mask_zero_div_zero", "divide by zero encountered"),
  162:         (
  163:             "to_pydatetime",
  164:             "The behavior of DatetimeProperties.to_pydatetime is deprecated",
  165:         ),
  166:         (
  167:             "pandas.core.generic.NDFrame.bool",
  168:             "(Series|DataFrame).bool is now deprecated and will be removed "
  169:             "in future version of pandas",
  170:         ),
  171:         (
  172:             "pandas.core.generic.NDFrame.first",
  173:             "first is deprecated and will be removed in a future version. "
  174:             "Please create a mask and filter using `.loc` instead",
  175:         ),
  176:         (
  177:             "Resampler.fillna",
  178:             "DatetimeIndexResampler.fillna is deprecated",
  179:         ),
  180:         (
  181:             "DataFrameGroupBy.fillna",
  182:             "DataFrameGroupBy.fillna with 'method' is deprecated",
  183:         ),
  184:         (
  185:             "DataFrameGroupBy.fillna",
  186:             "DataFrame.fillna with 'method' is deprecated",
  187:         ),
  188:         ("read_parquet", "Passing a BlockManager to DataFrame is deprecated"),
  189:     ]
  190: 
  191:     if is_doctest:
  192:         for item in items:
  193:             for path, message in ignored_doctest_warnings:
  194:                 ignore_doctest_warning(item, path, message)
  195: 
  196: 
  197: hypothesis_health_checks = [hypothesis.HealthCheck.too_slow]
  198: if Version(hypothesis.__version__) >= Version("6.83.2"):
  199:     hypothesis_health_checks.append(hypothesis.HealthCheck.differing_executors)
  200: 
  201: # Hypothesis
  202: hypothesis.settings.register_profile(
  203:     "ci",
  204:     # Hypothesis timing checks are tuned for scalars by default, so we bump
  205:     # them from 200ms to 500ms per test case as the global default.  If this
  206:     # is too short for a specific test, (a) try to make it faster, and (b)
  207:     # if it really is slow add `@settings(deadline=...)` with a working value,
  208:     # or `deadline=None` to entirely disable timeouts for that test.
  209:     # 2022-02-09: Changed deadline from 500 -> None. Deadline leads to
  210:     # non-actionable, flaky CI failures (# GH 24641, 44969, 45118, 44969)
  211:     deadline=None,
  212:     suppress_health_check=tuple(hypothesis_health_checks),
  213: )
  214: hypothesis.settings.load_profile("ci")
  215: 
  216: # Registering these strategies makes them globally available via st.from_type,
  217: # which is use for offsets in tests/tseries/offsets/test_offsets_properties.py
  218: for name in "MonthBegin MonthEnd BMonthBegin BMonthEnd".split():
  219:     cls = getattr(pd.tseries.offsets, name)
  220:     st.register_type_strategy(
  221:         cls, st.builds(cls, n=st.integers(-99, 99), normalize=st.booleans())
  222:     )
  223: 
  224: for name in "YearBegin YearEnd BYearBegin BYearEnd".split():
  225:     cls = getattr(pd.tseries.offsets, name)
  226:     st.register_type_strategy(
  227:         cls,
  228:         st.builds(
  229:             cls,
  230:             n=st.integers(-5, 5),
  231:             normalize=st.booleans(),
  232:             month=st.integers(min_value=1, max_value=12),
  233:         ),
  234:     )
  235: 
  236: for name in "QuarterBegin QuarterEnd BQuarterBegin BQuarterEnd".split():
  237:     cls = getattr(pd.tseries.offsets, name)
  238:     st.register_type_strategy(
  239:         cls,
  240:         st.builds(
  241:             cls,
  242:             n=st.integers(-24, 24),
  243:             normalize=st.booleans(),
  244:             startingMonth=st.integers(min_value=1, max_value=12),
  245:         ),
  246:     )
  247: 
  248: 
  249: # ----------------------------------------------------------------
  250: # Autouse fixtures
  251: # ----------------------------------------------------------------
  252: 
  253: 
  254: # https://github.com/pytest-dev/pytest/issues/11873
  255: # Would like to avoid autouse=True, but cannot as of pytest 8.0.0
  256: @pytest.fixture(autouse=True)
  257: def add_doctest_imports(doctest_namespace) -> None:
  258:     """
  259:     Make `np` and `pd` names available for doctests.
  260:     """
  261:     doctest_namespace["np"] = np
  262:     doctest_namespace["pd"] = pd
  263: 
  264: 
  265: @pytest.fixture(autouse=True)
  266: def configure_tests() -> None:
  267:     """
  268:     Configure settings for all tests and test modules.
  269:     """
  270:     pd.set_option("chained_assignment", "raise")
  271: 
  272: 
  273: # ----------------------------------------------------------------
  274: # Common arguments
  275: # ----------------------------------------------------------------
  276: @pytest.fixture(params=[0, 1, "index", "columns"], ids=lambda x: f"axis={repr(x)}")
  277: def axis(request):
  278:     """
  279:     Fixture for returning the axis numbers of a DataFrame.
  280:     """
  281:     return request.param
  282: 
  283: 
  284: axis_frame = axis
  285: 
  286: 
  287: @pytest.fixture(params=[1, "columns"], ids=lambda x: f"axis={repr(x)}")
  288: def axis_1(request):
  289:     """
  290:     Fixture for returning aliases of axis 1 of a DataFrame.
  291:     """
  292:     return request.param
  293: 
  294: 
  295: @pytest.fixture(params=[True, False, None])
  296: def observed(request):
  297:     """
  298:     Pass in the observed keyword to groupby for [True, False]
  299:     This indicates whether categoricals should return values for
  300:     values which are not in the grouper [False / None], or only values which
  301:     appear in the grouper [True]. [None] is supported for future compatibility
  302:     if we decide to change the default (and would need to warn if this
  303:     parameter is not passed).
  304:     """
  305:     return request.param
  306: 
  307: 
  308: @pytest.fixture(params=[True, False, None])
  309: def ordered(request):
  310:     """
  311:     Boolean 'ordered' parameter for Categorical.
  312:     """
  313:     return request.param
  314: 
  315: 
  316: @pytest.fixture(params=[True, False])
  317: def skipna(request):
  318:     """
  319:     Boolean 'skipna' parameter.
  320:     """
  321:     return request.param
  322: 
  323: 
  324: @pytest.fixture(params=["first", "last", False])
  325: def keep(request):
  326:     """
  327:     Valid values for the 'keep' parameter used in
  328:     .duplicated or .drop_duplicates
  329:     """
  330:     return request.param
  331: 
  332: 
  333: @pytest.fixture(params=["both", "neither", "left", "right"])
  334: def inclusive_endpoints_fixture(request):
  335:     """
  336:     Fixture for trying all interval 'inclusive' parameters.
  337:     """
  338:     return request.param
  339: 
  340: 
  341: @pytest.fixture(params=["left", "right", "both", "neither"])
  342: def closed(request):
  343:     """
  344:     Fixture for trying all interval closed parameters.
  345:     """
  346:     return request.param
  347: 
  348: 
  349: @pytest.fixture(params=["left", "right", "both", "neither"])
  350: def other_closed(request):
  351:     """
  352:     Secondary closed fixture to allow parametrizing over all pairs of closed.
  353:     """
  354:     return request.param
  355: 
  356: 
  357: @pytest.fixture(
  358:     params=[
  359:         None,
  360:         "gzip",
  361:         "bz2",
  362:         "zip",
  363:         "xz",
  364:         "tar",
  365:         pytest.param("zstd", marks=td.skip_if_no("zstandard")),
  366:     ]
  367: )
  368: def compression(request):
  369:     """
  370:     Fixture for trying common compression types in compression tests.
  371:     """
  372:     return request.param
  373: 
  374: 
  375: @pytest.fixture(
  376:     params=[
  377:         "gzip",
  378:         "bz2",
  379:         "zip",
  380:         "xz",
  381:         "tar",
  382:         pytest.param("zstd", marks=td.skip_if_no("zstandard")),
  383:     ]
  384: )
  385: def compression_only(request):
  386:     """
  387:     Fixture for trying common compression types in compression tests excluding
  388:     uncompressed case.
  389:     """
  390:     return request.param
  391: 
  392: 
  393: @pytest.fixture(params=[True, False])
  394: def writable(request):
  395:     """
  396:     Fixture that an array is writable.
  397:     """
  398:     return request.param
  399: 
  400: 
  401: @pytest.fixture(params=["inner", "outer", "left", "right"])
  402: def join_type(request):
  403:     """
  404:     Fixture for trying all types of join operations.
  405:     """
  406:     return request.param
  407: 
  408: 
  409: @pytest.fixture(params=["nlargest", "nsmallest"])
  410: def nselect_method(request):
  411:     """
  412:     Fixture for trying all nselect methods.
  413:     """
  414:     return request.param
  415: 
  416: 
  417: # ----------------------------------------------------------------
  418: # Missing values & co.
  419: # ----------------------------------------------------------------
  420: @pytest.fixture(params=tm.NULL_OBJECTS, ids=lambda x: type(x).__name__)
  421: def nulls_fixture(request):
  422:     """
  423:     Fixture for each null type in pandas.
  424:     """
  425:     return request.param
  426: 
  427: 
  428: nulls_fixture2 = nulls_fixture  # Generate cartesian product of nulls_fixture
  429: 
  430: 
  431: @pytest.fixture(params=[None, np.nan, pd.NaT])
  432: def unique_nulls_fixture(request):
  433:     """
  434:     Fixture for each null type in pandas, each null type exactly once.
  435:     """
  436:     return request.param
  437: 
  438: 
  439: # Generate cartesian product of unique_nulls_fixture:
  440: unique_nulls_fixture2 = unique_nulls_fixture
  441: 
  442: 
  443: @pytest.fixture(params=tm.NP_NAT_OBJECTS, ids=lambda x: type(x).__name__)
  444: def np_nat_fixture(request):
  445:     """
  446:     Fixture for each NaT type in numpy.
  447:     """
  448:     return request.param
  449: 
  450: 
  451: # Generate cartesian product of np_nat_fixture:
  452: np_nat_fixture2 = np_nat_fixture
  453: 
  454: 
  455: # ----------------------------------------------------------------
  456: # Classes
  457: # ----------------------------------------------------------------
  458: 
  459: 
  460: @pytest.fixture(params=[DataFrame, Series])
  461: def frame_or_series(request):
  462:     """
  463:     Fixture to parametrize over DataFrame and Series.
  464:     """
  465:     return request.param
  466: 
  467: 
  468: @pytest.fixture(params=[Index, Series], ids=["index", "series"])
  469: def index_or_series(request):
  470:     """
  471:     Fixture to parametrize over Index and Series, made necessary by a mypy
  472:     bug, giving an error:
  473: 
  474:     List item 0 has incompatible type "Type[Series]"; expected "Type[PandasObject]"
  475: 
  476:     See GH#29725
  477:     """
  478:     return request.param
  479: 
  480: 
  481: # Generate cartesian product of index_or_series fixture:
  482: index_or_series2 = index_or_series
  483: 
  484: 
  485: @pytest.fixture(params=[Index, Series, pd.array], ids=["index", "series", "array"])
  486: def index_or_series_or_array(request):
  487:     """
  488:     Fixture to parametrize over Index, Series, and ExtensionArray
  489:     """
  490:     return request.param
  491: 
  492: 
  493: @pytest.fixture(params=[Index, Series, DataFrame, pd.array], ids=lambda x: x.__name__)
  494: def box_with_array(request):
  495:     """
  496:     Fixture to test behavior for Index, Series, DataFrame, and pandas Array
  497:     classes
  498:     """
  499:     return request.param
  500: 
  501: 
  502: box_with_array2 = box_with_array
  503: 
  504: 
  505: @pytest.fixture
  506: def dict_subclass() -> type[dict]:
  507:     """
  508:     Fixture for a dictionary subclass.
  509:     """
  510: 
  511:     class TestSubDict(dict):
  512:         def __init__(self, *args, **kwargs) -> None:
  513:             dict.__init__(self, *args, **kwargs)
  514: 
  515:     return TestSubDict
  516: 
  517: 
  518: @pytest.fixture
  519: def non_dict_mapping_subclass() -> type[abc.Mapping]:
  520:     """
  521:     Fixture for a non-mapping dictionary subclass.
  522:     """
  523: 
  524:     class TestNonDictMapping(abc.Mapping):
  525:         def __init__(self, underlying_dict) -> None:
  526:             self._data = underlying_dict
  527: 
  528:         def __getitem__(self, key):
  529:             return self._data.__getitem__(key)
  530: 
  531:         def __iter__(self) -> Iterator:
  532:             return self._data.__iter__()
  533: 
  534:         def __len__(self) -> int:
  535:             return self._data.__len__()
  536: 
  537:     return TestNonDictMapping
  538: 
  539: 
  540: # ----------------------------------------------------------------
  541: # Indices
  542: # ----------------------------------------------------------------
  543: @pytest.fixture
  544: def multiindex_year_month_day_dataframe_random_data():
  545:     """
  546:     DataFrame with 3 level MultiIndex (year, month, day) covering
  547:     first 100 business days from 2000-01-01 with random data
  548:     """
  549:     tdf = DataFrame(
  550:         np.random.default_rng(2).standard_normal((100, 4)),
  551:         columns=Index(list("ABCD"), dtype=object),
  552:         index=date_range("2000-01-01", periods=100, freq="B"),
  553:     )
  554:     ymd = tdf.groupby([lambda x: x.year, lambda x: x.month, lambda x: x.day]).sum()
  555:     # use int64 Index, to make sure things work
  556:     ymd.index = ymd.index.set_levels([lev.astype("i8") for lev in ymd.index.levels])
  557:     ymd.index.set_names(["year", "month", "day"], inplace=True)
  558:     return ymd
  559: 
  560: 
  561: @pytest.fixture
  562: def lexsorted_two_level_string_multiindex() -> MultiIndex:
  563:     """
  564:     2-level MultiIndex, lexsorted, with string names.
  565:     """
  566:     return MultiIndex(
  567:         levels=[["foo", "bar", "baz", "qux"], ["one", "two", "three"]],
  568:         codes=[[0, 0, 0, 1, 1, 2, 2, 3, 3, 3], [0, 1, 2, 0, 1, 1, 2, 0, 1, 2]],
  569:         names=["first", "second"],
  570:     )
  571: 
  572: 
  573: @pytest.fixture
  574: def multiindex_dataframe_random_data(
  575:     lexsorted_two_level_string_multiindex,
  576: ) -> DataFrame:
  577:     """DataFrame with 2 level MultiIndex with random data"""
  578:     index = lexsorted_two_level_string_multiindex
  579:     return DataFrame(
  580:         np.random.default_rng(2).standard_normal((10, 3)),
  581:         index=index,
  582:         columns=Index(["A", "B", "C"], name="exp"),
  583:     )
  584: 
  585: 
  586: def _create_multiindex():
  587:     """
  588:     MultiIndex used to test the general functionality of this object
  589:     """
  590: 
  591:     # See Also: tests.multi.conftest.idx
  592:     major_axis = Index(["foo", "bar", "baz", "qux"])
  593:     minor_axis = Index(["one", "two"])
  594: 
  595:     major_codes = np.array([0, 0, 1, 2, 3, 3])
  596:     minor_codes = np.array([0, 1, 0, 1, 0, 1])
  597:     index_names = ["first", "second"]
  598:     return MultiIndex(
  599:         levels=[major_axis, minor_axis],
  600:         codes=[major_codes, minor_codes],
  601:         names=index_names,
  602:         verify_integrity=False,
  603:     )
  604: 
  605: 
  606: def _create_mi_with_dt64tz_level():
  607:     """
  608:     MultiIndex with a level that is a tzaware DatetimeIndex.
  609:     """
  610:     # GH#8367 round trip with pickle
  611:     return MultiIndex.from_product(
  612:         [[1, 2], ["a", "b"], date_range("20130101", periods=3, tz="US/Eastern")],
  613:         names=["one", "two", "three"],
  614:     )
  615: 
  616: 
  617: indices_dict = {
  618:     "string": Index([f"pandas_{i}" for i in range(100)]),
  619:     "datetime": date_range("2020-01-01", periods=100),
  620:     "datetime-tz": date_range("2020-01-01", periods=100, tz="US/Pacific"),
  621:     "period": period_range("2020-01-01", periods=100, freq="D"),
  622:     "timedelta": timedelta_range(start="1 day", periods=100, freq="D"),
  623:     "range": RangeIndex(100),
  624:     "int8": Index(np.arange(100), dtype="int8"),
  625:     "int16": Index(np.arange(100), dtype="int16"),
  626:     "int32": Index(np.arange(100), dtype="int32"),
  627:     "int64": Index(np.arange(100), dtype="int64"),
  628:     "uint8": Index(np.arange(100), dtype="uint8"),
  629:     "uint16": Index(np.arange(100), dtype="uint16"),
  630:     "uint32": Index(np.arange(100), dtype="uint32"),
  631:     "uint64": Index(np.arange(100), dtype="uint64"),
  632:     "float32": Index(np.arange(100), dtype="float32"),
  633:     "float64": Index(np.arange(100), dtype="float64"),
  634:     "bool-object": Index([True, False] * 5, dtype=object),
  635:     "bool-dtype": Index([True, False] * 5, dtype=bool),
  636:     "complex64": Index(
  637:         np.arange(100, dtype="complex64") + 1.0j * np.arange(100, dtype="complex64")
  638:     ),
  639:     "complex128": Index(
  640:         np.arange(100, dtype="complex128") + 1.0j * np.arange(100, dtype="complex128")
  641:     ),
  642:     "categorical": CategoricalIndex(list("abcd") * 25),
  643:     "interval": IntervalIndex.from_breaks(np.linspace(0, 100, num=101)),
  644:     "empty": Index([]),
  645:     "tuples": MultiIndex.from_tuples(zip(["foo", "bar", "baz"], [1, 2, 3])),
  646:     "mi-with-dt64tz-level": _create_mi_with_dt64tz_level(),
  647:     "multi": _create_multiindex(),
  648:     "repeats": Index([0, 0, 1, 1, 2, 2]),
  649:     "nullable_int": Index(np.arange(100), dtype="Int64"),
  650:     "nullable_uint": Index(np.arange(100), dtype="UInt16"),
  651:     "nullable_float": Index(np.arange(100), dtype="Float32"),
  652:     "nullable_bool": Index(np.arange(100).astype(bool), dtype="boolean"),
  653:     "string-python": Index(
  654:         pd.array([f"pandas_{i}" for i in range(100)], dtype="string[python]")
  655:     ),
  656: }
  657: if has_pyarrow:
  658:     idx = Index(pd.array([f"pandas_{i}" for i in range(100)], dtype="string[pyarrow]"))
  659:     indices_dict["string-pyarrow"] = idx
  660: 
  661: 
  662: @pytest.fixture(params=indices_dict.keys())
  663: def index(request):
  664:     """
  665:     Fixture for many "simple" kinds of indices.
  666: 
  667:     These indices are unlikely to cover corner cases, e.g.
  668:         - no names
  669:         - no NaTs/NaNs
  670:         - no values near implementation bounds
  671:         - ...
  672:     """
  673:     # copy to avoid mutation, e.g. setting .name
  674:     return indices_dict[request.param].copy()
  675: 
  676: 
  677: # Needed to generate cartesian product of indices
  678: index_fixture2 = index
  679: 
  680: 
  681: @pytest.fixture(
  682:     params=[
  683:         key for key, value in indices_dict.items() if not isinstance(value, MultiIndex)
  684:     ]
  685: )
  686: def index_flat(request):
  687:     """
  688:     index fixture, but excluding MultiIndex cases.
  689:     """
  690:     key = request.param
  691:     return indices_dict[key].copy()
  692: 
  693: 
  694: # Alias so we can test with cartesian product of index_flat
  695: index_flat2 = index_flat
  696: 
  697: 
  698: @pytest.fixture(
  699:     params=[
  700:         key
  701:         for key, value in indices_dict.items()
  702:         if not (
  703:             key.startswith(("int", "uint", "float"))
  704:             or key in ["range", "empty", "repeats", "bool-dtype"]
  705:         )
  706:         and not isinstance(value, MultiIndex)
  707:     ]
  708: )
  709: def index_with_missing(request):
  710:     """
  711:     Fixture for indices with missing values.
  712: 
  713:     Integer-dtype and empty cases are excluded because they cannot hold missing
  714:     values.
  715: 
  716:     MultiIndex is excluded because isna() is not defined for MultiIndex.
  717:     """
  718: 
  719:     # GH 35538. Use deep copy to avoid illusive bug on np-dev
  720:     # GHA pipeline that writes into indices_dict despite copy
  721:     ind = indices_dict[request.param].copy(deep=True)
  722:     vals = ind.values.copy()
  723:     if request.param in ["tuples", "mi-with-dt64tz-level", "multi"]:
  724:         # For setting missing values in the top level of MultiIndex
  725:         vals = ind.tolist()
  726:         vals[0] = (None,) + vals[0][1:]
  727:         vals[-1] = (None,) + vals[-1][1:]
  728:         return MultiIndex.from_tuples(vals)
  729:     else:
  730:         vals[0] = None
  731:         vals[-1] = None
  732:         return type(ind)(vals)
  733: 
  734: 
  735: # ----------------------------------------------------------------
  736: # Series'
  737: # ----------------------------------------------------------------
  738: @pytest.fixture
  739: def string_series() -> Series:
  740:     """
  741:     Fixture for Series of floats with Index of unique strings
  742:     """
  743:     return Series(
  744:         np.arange(30, dtype=np.float64) * 1.1,
  745:         index=Index([f"i_{i}" for i in range(30)], dtype=object),
  746:         name="series",
  747:     )
  748: 
  749: 
  750: @pytest.fixture
  751: def object_series() -> Series:
  752:     """
  753:     Fixture for Series of dtype object with Index of unique strings
  754:     """
  755:     data = [f"foo_{i}" for i in range(30)]
  756:     index = Index([f"bar_{i}" for i in range(30)], dtype=object)
  757:     return Series(data, index=index, name="objects", dtype=object)
  758: 
  759: 
  760: @pytest.fixture
  761: def datetime_series() -> Series:
  762:     """
  763:     Fixture for Series of floats with DatetimeIndex
  764:     """
  765:     return Series(
  766:         np.random.default_rng(2).standard_normal(30),
  767:         index=date_range("2000-01-01", periods=30, freq="B"),
  768:         name="ts",
  769:     )
  770: 
  771: 
  772: def _create_series(index):
  773:     """Helper for the _series dict"""
  774:     size = len(index)
  775:     data = np.random.default_rng(2).standard_normal(size)
  776:     return Series(data, index=index, name="a", copy=False)
  777: 
  778: 
  779: _series = {
  780:     f"series-with-{index_id}-index": _create_series(index)
  781:     for index_id, index in indices_dict.items()
  782: }
  783: 
  784: 
  785: @pytest.fixture
  786: def series_with_simple_index(index) -> Series:
  787:     """
  788:     Fixture for tests on series with changing types of indices.
  789:     """
  790:     return _create_series(index)
  791: 
  792: 
  793: _narrow_series = {
  794:     f"{dtype.__name__}-series": Series(
  795:         range(30), index=[f"i-{i}" for i in range(30)], name="a", dtype=dtype
  796:     )
  797:     for dtype in tm.NARROW_NP_DTYPES
  798: }
  799: 
  800: 
  801: _index_or_series_objs = {**indices_dict, **_series, **_narrow_series}
  802: 
  803: 
  804: @pytest.fixture(params=_index_or_series_objs.keys())
  805: def index_or_series_obj(request):
  806:     """
  807:     Fixture for tests on indexes, series and series with a narrow dtype
  808:     copy to avoid mutation, e.g. setting .name
  809:     """
  810:     return _index_or_series_objs[request.param].copy(deep=True)
  811: 
  812: 
  813: _typ_objects_series = {
  814:     f"{dtype.__name__}-series": Series(dtype) for dtype in tm.PYTHON_DATA_TYPES
  815: }
  816: 
  817: 
  818: _index_or_series_memory_objs = {
  819:     **indices_dict,
  820:     **_series,
  821:     **_narrow_series,
  822:     **_typ_objects_series,
  823: }
  824: 
  825: 
  826: @pytest.fixture(params=_index_or_series_memory_objs.keys())
  827: def index_or_series_memory_obj(request):
  828:     """
  829:     Fixture for tests on indexes, series, series with a narrow dtype and
  830:     series with empty objects type
  831:     copy to avoid mutation, e.g. setting .name
  832:     """
  833:     return _index_or_series_memory_objs[request.param].copy(deep=True)
  834: 
  835: 
  836: # ----------------------------------------------------------------
  837: # DataFrames
  838: # ----------------------------------------------------------------
  839: @pytest.fixture
  840: def int_frame() -> DataFrame:
  841:     """
  842:     Fixture for DataFrame of ints with index of unique strings
  843: 
  844:     Columns are ['A', 'B', 'C', 'D']
  845:     """
  846:     return DataFrame(
  847:         np.ones((30, 4), dtype=np.int64),
  848:         index=Index([f"foo_{i}" for i in range(30)], dtype=object),
  849:         columns=Index(list("ABCD"), dtype=object),
  850:     )
  851: 
  852: 
  853: @pytest.fixture
  854: def float_frame() -> DataFrame:
  855:     """
  856:     Fixture for DataFrame of floats with index of unique strings
  857: 
  858:     Columns are ['A', 'B', 'C', 'D'].
  859:     """
  860:     return DataFrame(
  861:         np.random.default_rng(2).standard_normal((30, 4)),
  862:         index=Index([f"foo_{i}" for i in range(30)]),
  863:         columns=Index(list("ABCD")),
  864:     )
  865: 
  866: 
  867: @pytest.fixture
  868: def rand_series_with_duplicate_datetimeindex() -> Series:
  869:     """
  870:     Fixture for Series with a DatetimeIndex that has duplicates.
  871:     """
  872:     dates = [
  873:         datetime(2000, 1, 2),
  874:         datetime(2000, 1, 2),
  875:         datetime(2000, 1, 2),
  876:         datetime(2000, 1, 3),
  877:         datetime(2000, 1, 3),
  878:         datetime(2000, 1, 3),
  879:         datetime(2000, 1, 4),
  880:         datetime(2000, 1, 4),
  881:         datetime(2000, 1, 4),
  882:         datetime(2000, 1, 5),
  883:     ]
  884: 
  885:     return Series(np.random.default_rng(2).standard_normal(len(dates)), index=dates)
  886: 
  887: 
  888: # ----------------------------------------------------------------
  889: # Scalars
  890: # ----------------------------------------------------------------
  891: @pytest.fixture(
  892:     params=[
  893:         (Interval(left=0, right=5), IntervalDtype("int64", "right")),
  894:         (Interval(left=0.1, right=0.5), IntervalDtype("float64", "right")),
  895:         (Period("2012-01", freq="M"), "period[M]"),
  896:         (Period("2012-02-01", freq="D"), "period[D]"),
  897:         (
  898:             Timestamp("2011-01-01", tz="US/Eastern"),
  899:             DatetimeTZDtype(unit="s", tz="US/Eastern"),
  900:         ),
  901:         (Timedelta(seconds=500), "timedelta64[ns]"),
  902:     ]
  903: )
  904: def ea_scalar_and_dtype(request):
  905:     return request.param
  906: 
  907: 
  908: # ----------------------------------------------------------------
  909: # Operators & Operations
  910: # ----------------------------------------------------------------
  911: 
  912: 
  913: @pytest.fixture(params=tm.arithmetic_dunder_methods)
  914: def all_arithmetic_operators(request):
  915:     """
  916:     Fixture for dunder names for common arithmetic operations.
  917:     """
  918:     return request.param
  919: 
  920: 
  921: @pytest.fixture(
  922:     params=[
  923:         operator.add,
  924:         ops.radd,
  925:         operator.sub,
  926:         ops.rsub,
  927:         operator.mul,
  928:         ops.rmul,
  929:         operator.truediv,
  930:         ops.rtruediv,
  931:         operator.floordiv,
  932:         ops.rfloordiv,
  933:         operator.mod,
  934:         ops.rmod,
  935:         operator.pow,
  936:         ops.rpow,
  937:         operator.eq,
  938:         operator.ne,
  939:         operator.lt,
  940:         operator.le,
  941:         operator.gt,
  942:         operator.ge,
  943:         operator.and_,
  944:         ops.rand_,
  945:         operator.xor,
  946:         ops.rxor,
  947:         operator.or_,
  948:         ops.ror_,
  949:     ]
  950: )
  951: def all_binary_operators(request):
  952:     """
  953:     Fixture for operator and roperator arithmetic, comparison, and logical ops.
  954:     """
  955:     return request.param
  956: 
  957: 
  958: @pytest.fixture(
  959:     params=[
  960:         operator.add,
  961:         ops.radd,
  962:         operator.sub,
  963:         ops.rsub,
  964:         operator.mul,
  965:         ops.rmul,
  966:         operator.truediv,
  967:         ops.rtruediv,
  968:         operator.floordiv,
  969:         ops.rfloordiv,
  970:         operator.mod,
  971:         ops.rmod,
  972:         operator.pow,
  973:         ops.rpow,
  974:     ]
  975: )
  976: def all_arithmetic_functions(request):
  977:     """
  978:     Fixture for operator and roperator arithmetic functions.
  979: 
  980:     Notes
  981:     -----
  982:     This includes divmod and rdivmod, whereas all_arithmetic_operators
  983:     does not.
  984:     """
  985:     return request.param
  986: 
  987: 
  988: _all_numeric_reductions = [
  989:     "count",
  990:     "sum",
  991:     "max",
  992:     "min",
  993:     "mean",
  994:     "prod",
  995:     "std",
  996:     "var",
  997:     "median",
  998:     "kurt",
  999:     "skew",
 1000:     "sem",
 1001: ]
 1002: 
 1003: 
 1004: @pytest.fixture(params=_all_numeric_reductions)
 1005: def all_numeric_reductions(request):
 1006:     """
 1007:     Fixture for numeric reduction names.
 1008:     """
 1009:     return request.param
 1010: 
 1011: 
 1012: _all_boolean_reductions = ["all", "any"]
 1013: 
 1014: 
 1015: @pytest.fixture(params=_all_boolean_reductions)
 1016: def all_boolean_reductions(request):
 1017:     """
 1018:     Fixture for boolean reduction names.
 1019:     """
 1020:     return request.param
 1021: 
 1022: 
 1023: _all_reductions = _all_numeric_reductions + _all_boolean_reductions
 1024: 
 1025: 
 1026: @pytest.fixture(params=_all_reductions)
 1027: def all_reductions(request):
 1028:     """
 1029:     Fixture for all (boolean + numeric) reduction names.
 1030:     """
 1031:     return request.param
 1032: 
 1033: 
 1034: @pytest.fixture(
 1035:     params=[
 1036:         operator.eq,
 1037:         operator.ne,
 1038:         operator.gt,
 1039:         operator.ge,
 1040:         operator.lt,
 1041:         operator.le,
 1042:     ]
 1043: )
 1044: def comparison_op(request):
 1045:     """
 1046:     Fixture for operator module comparison functions.
 1047:     """
 1048:     return request.param
 1049: 
 1050: 
 1051: @pytest.fixture(params=["__le__", "__lt__", "__ge__", "__gt__"])
 1052: def compare_operators_no_eq_ne(request):
 1053:     """
 1054:     Fixture for dunder names for compare operations except == and !=
 1055: 
 1056:     * >=
 1057:     * >
 1058:     * <
 1059:     * <=
 1060:     """
 1061:     return request.param
 1062: 
 1063: 
 1064: @pytest.fixture(
 1065:     params=["__and__", "__rand__", "__or__", "__ror__", "__xor__", "__rxor__"]
 1066: )
 1067: def all_logical_operators(request):
 1068:     """
 1069:     Fixture for dunder names for common logical operations
 1070: 
 1071:     * |
 1072:     * &
 1073:     * ^
 1074:     """
 1075:     return request.param
 1076: 
 1077: 
 1078: _all_numeric_accumulations = ["cumsum", "cumprod", "cummin", "cummax"]
 1079: 
 1080: 
 1081: @pytest.fixture(params=_all_numeric_accumulations)
 1082: def all_numeric_accumulations(request):
 1083:     """
 1084:     Fixture for numeric accumulation names
 1085:     """
 1086:     return request.param
 1087: 
 1088: 
 1089: # ----------------------------------------------------------------
 1090: # Data sets/files
 1091: # ----------------------------------------------------------------
 1092: @pytest.fixture
 1093: def strict_data_files(pytestconfig):
 1094:     """
 1095:     Returns the configuration for the test setting `--no-strict-data-files`.
 1096:     """
 1097:     return pytestconfig.getoption("--no-strict-data-files")
 1098: 
 1099: 
 1100: @pytest.fixture
 1101: def datapath(strict_data_files: str) -> Callable[..., str]:
 1102:     """
 1103:     Get the path to a data file.
 1104: 
 1105:     Parameters
 1106:     ----------
 1107:     path : str
 1108:         Path to the file, relative to ``pandas/tests/``
 1109: 
 1110:     Returns
 1111:     -------
 1112:     path including ``pandas/tests``.
 1113: 
 1114:     Raises
 1115:     ------
 1116:     ValueError
 1117:         If the path doesn't exist and the --no-strict-data-files option is not set.
 1118:     """
 1119:     BASE_PATH = os.path.join(os.path.dirname(__file__), "tests")
 1120: 
 1121:     def deco(*args):
 1122:         path = os.path.join(BASE_PATH, *args)
 1123:         if not os.path.exists(path):
 1124:             if strict_data_files:
 1125:                 raise ValueError(
 1126:                     f"Could not find file {path} and --no-strict-data-files is not set."
 1127:                 )
 1128:             pytest.skip(f"Could not find {path}.")
 1129:         return path
 1130: 
 1131:     return deco
 1132: 
 1133: 
 1134: # ----------------------------------------------------------------
 1135: # Time zones
 1136: # ----------------------------------------------------------------
 1137: TIMEZONES = [
 1138:     None,
 1139:     "UTC",
 1140:     "US/Eastern",
 1141:     "Asia/Tokyo",
 1142:     "dateutil/US/Pacific",
 1143:     "dateutil/Asia/Singapore",
 1144:     "+01:15",
 1145:     "-02:15",
 1146:     "UTC+01:15",
 1147:     "UTC-02:15",
 1148:     tzutc(),
 1149:     tzlocal(),
 1150:     FixedOffset(300),
 1151:     FixedOffset(0),
 1152:     FixedOffset(-300),
 1153:     timezone.utc,
 1154:     timezone(timedelta(hours=1)),
 1155:     timezone(timedelta(hours=-1), name="foo"),
 1156: ]
 1157: if zoneinfo is not None:
 1158:     TIMEZONES.extend(
 1159:         [
 1160:             zoneinfo.ZoneInfo("US/Pacific"),  # type: ignore[list-item]
 1161:             zoneinfo.ZoneInfo("UTC"),  # type: ignore[list-item]
 1162:         ]
 1163:     )
 1164: TIMEZONE_IDS = [repr(i) for i in TIMEZONES]
 1165: 
 1166: 
 1167: @td.parametrize_fixture_doc(str(TIMEZONE_IDS))
 1168: @pytest.fixture(params=TIMEZONES, ids=TIMEZONE_IDS)
 1169: def tz_naive_fixture(request):
 1170:     """
 1171:     Fixture for trying timezones including default (None): {0}
 1172:     """
 1173:     return request.param
 1174: 
 1175: 
 1176: @td.parametrize_fixture_doc(str(TIMEZONE_IDS[1:]))
 1177: @pytest.fixture(params=TIMEZONES[1:], ids=TIMEZONE_IDS[1:])
 1178: def tz_aware_fixture(request):
 1179:     """
 1180:     Fixture for trying explicit timezones: {0}
 1181:     """
 1182:     return request.param
 1183: 
 1184: 
 1185: # Generate cartesian product of tz_aware_fixture:
 1186: tz_aware_fixture2 = tz_aware_fixture
 1187: 
 1188: 
 1189: _UTCS = ["utc", "dateutil/UTC", utc, tzutc(), timezone.utc]
 1190: if zoneinfo is not None:
 1191:     _UTCS.append(zoneinfo.ZoneInfo("UTC"))
 1192: 
 1193: 
 1194: @pytest.fixture(params=_UTCS)
 1195: def utc_fixture(request):
 1196:     """
 1197:     Fixture to provide variants of UTC timezone strings and tzinfo objects.
 1198:     """
 1199:     return request.param
 1200: 
 1201: 
 1202: utc_fixture2 = utc_fixture
 1203: 
 1204: 
 1205: @pytest.fixture(params=["s", "ms", "us", "ns"])
 1206: def unit(request):
 1207:     """
 1208:     datetime64 units we support.
 1209:     """
 1210:     return request.param
 1211: 
 1212: 
 1213: unit2 = unit
 1214: 
 1215: 
 1216: # ----------------------------------------------------------------
 1217: # Dtypes
 1218: # ----------------------------------------------------------------
 1219: @pytest.fixture(params=tm.STRING_DTYPES)
 1220: def string_dtype(request):
 1221:     """
 1222:     Parametrized fixture for string dtypes.
 1223: 
 1224:     * str
 1225:     * 'str'
 1226:     * 'U'
 1227:     """
 1228:     return request.param
 1229: 
 1230: 
 1231: @pytest.fixture(
 1232:     params=[
 1233:         "string[python]",
 1234:         pytest.param("string[pyarrow]", marks=td.skip_if_no("pyarrow")),
 1235:     ]
 1236: )
 1237: def nullable_string_dtype(request):
 1238:     """
 1239:     Parametrized fixture for string dtypes.
 1240: 
 1241:     * 'string[python]'
 1242:     * 'string[pyarrow]'
 1243:     """
 1244:     return request.param
 1245: 
 1246: 
 1247: @pytest.fixture(
 1248:     params=[
 1249:         "python",
 1250:         pytest.param("pyarrow", marks=td.skip_if_no("pyarrow")),
 1251:         pytest.param("pyarrow_numpy", marks=td.skip_if_no("pyarrow")),
 1252:     ]
 1253: )
 1254: def string_storage(request):
 1255:     """
 1256:     Parametrized fixture for pd.options.mode.string_storage.
 1257: 
 1258:     * 'python'
 1259:     * 'pyarrow'
 1260:     * 'pyarrow_numpy'
 1261:     """
 1262:     return request.param
 1263: 
 1264: 
 1265: @pytest.fixture(
 1266:     params=[
 1267:         "numpy_nullable",
 1268:         pytest.param("pyarrow", marks=td.skip_if_no("pyarrow")),
 1269:     ]
 1270: )
 1271: def dtype_backend(request):
 1272:     """
 1273:     Parametrized fixture for pd.options.mode.string_storage.
 1274: 
 1275:     * 'python'
 1276:     * 'pyarrow'
 1277:     """
 1278:     return request.param
 1279: 
 1280: 
 1281: # Alias so we can test with cartesian product of string_storage
 1282: string_storage2 = string_storage
 1283: 
 1284: 
 1285: @pytest.fixture(params=tm.BYTES_DTYPES)
 1286: def bytes_dtype(request):
 1287:     """
 1288:     Parametrized fixture for bytes dtypes.
 1289: 
 1290:     * bytes
 1291:     * 'bytes'
 1292:     """
 1293:     return request.param
 1294: 
 1295: 
 1296: @pytest.fixture(params=tm.OBJECT_DTYPES)
 1297: def object_dtype(request):
 1298:     """
 1299:     Parametrized fixture for object dtypes.
 1300: 
 1301:     * object
 1302:     * 'object'
 1303:     """
 1304:     return request.param
 1305: 
 1306: 
 1307: @pytest.fixture(
 1308:     params=[
 1309:         "object",
 1310:         "string[python]",
 1311:         pytest.param("string[pyarrow]", marks=td.skip_if_no("pyarrow")),
 1312:         pytest.param("string[pyarrow_numpy]", marks=td.skip_if_no("pyarrow")),
 1313:     ]
 1314: )
 1315: def any_string_dtype(request):
 1316:     """
 1317:     Parametrized fixture for string dtypes.
 1318:     * 'object'
 1319:     * 'string[python]'
 1320:     * 'string[pyarrow]'
 1321:     """
 1322:     return request.param
 1323: 
 1324: 
 1325: @pytest.fixture(params=tm.DATETIME64_DTYPES)
 1326: def datetime64_dtype(request):
 1327:     """
 1328:     Parametrized fixture for datetime64 dtypes.
 1329: 
 1330:     * 'datetime64[ns]'
 1331:     * 'M8[ns]'
 1332:     """
 1333:     return request.param
 1334: 
 1335: 
 1336: @pytest.fixture(params=tm.TIMEDELTA64_DTYPES)
 1337: def timedelta64_dtype(request):
 1338:     """
 1339:     Parametrized fixture for timedelta64 dtypes.
 1340: 
 1341:     * 'timedelta64[ns]'
 1342:     * 'm8[ns]'
 1343:     """
 1344:     return request.param
 1345: 
 1346: 
 1347: @pytest.fixture
 1348: def fixed_now_ts() -> Timestamp:
 1349:     """
 1350:     Fixture emits fixed Timestamp.now()
 1351:     """
 1352:     return Timestamp(  # pyright: ignore[reportGeneralTypeIssues]
 1353:         year=2021, month=1, day=1, hour=12, minute=4, second=13, microsecond=22
 1354:     )
 1355: 
 1356: 
 1357: @pytest.fixture(params=tm.FLOAT_NUMPY_DTYPES)
 1358: def float_numpy_dtype(request):
 1359:     """
 1360:     Parameterized fixture for float dtypes.
 1361: 
 1362:     * float
 1363:     * 'float32'
 1364:     * 'float64'
 1365:     """
 1366:     return request.param
 1367: 
 1368: 
 1369: @pytest.fixture(params=tm.FLOAT_EA_DTYPES)
 1370: def float_ea_dtype(request):
 1371:     """
 1372:     Parameterized fixture for float dtypes.
 1373: 
 1374:     * 'Float32'
 1375:     * 'Float64'
 1376:     """
 1377:     return request.param
 1378: 
 1379: 
 1380: @pytest.fixture(params=tm.ALL_FLOAT_DTYPES)
 1381: def any_float_dtype(request):
 1382:     """
 1383:     Parameterized fixture for float dtypes.
 1384: 
 1385:     * float
 1386:     * 'float32'
 1387:     * 'float64'
 1388:     * 'Float32'
 1389:     * 'Float64'
 1390:     """
 1391:     return request.param
 1392: 
 1393: 
 1394: @pytest.fixture(params=tm.COMPLEX_DTYPES)
 1395: def complex_dtype(request):
 1396:     """
 1397:     Parameterized fixture for complex dtypes.
 1398: 
 1399:     * complex
 1400:     * 'complex64'
 1401:     * 'complex128'
 1402:     """
 1403:     return request.param
 1404: 
 1405: 
 1406: @pytest.fixture(params=tm.SIGNED_INT_NUMPY_DTYPES)
 1407: def any_signed_int_numpy_dtype(request):
 1408:     """
 1409:     Parameterized fixture for signed integer dtypes.
 1410: 
 1411:     * int
 1412:     * 'int8'
 1413:     * 'int16'
 1414:     * 'int32'
 1415:     * 'int64'
 1416:     """
 1417:     return request.param
 1418: 
 1419: 
 1420: @pytest.fixture(params=tm.UNSIGNED_INT_NUMPY_DTYPES)
 1421: def any_unsigned_int_numpy_dtype(request):
 1422:     """
 1423:     Parameterized fixture for unsigned integer dtypes.
 1424: 
 1425:     * 'uint8'
 1426:     * 'uint16'
 1427:     * 'uint32'
 1428:     * 'uint64'
 1429:     """
 1430:     return request.param
 1431: 
 1432: 
 1433: @pytest.fixture(params=tm.ALL_INT_NUMPY_DTYPES)
 1434: def any_int_numpy_dtype(request):
 1435:     """
 1436:     Parameterized fixture for any integer dtype.
 1437: 
 1438:     * int
 1439:     * 'int8'
 1440:     * 'uint8'
 1441:     * 'int16'
 1442:     * 'uint16'
 1443:     * 'int32'
 1444:     * 'uint32'
 1445:     * 'int64'
 1446:     * 'uint64'
 1447:     """
 1448:     return request.param
 1449: 
 1450: 
 1451: @pytest.fixture(params=tm.ALL_INT_EA_DTYPES)
 1452: def any_int_ea_dtype(request):
 1453:     """
 1454:     Parameterized fixture for any nullable integer dtype.
 1455: 
 1456:     * 'UInt8'
 1457:     * 'Int8'
 1458:     * 'UInt16'
 1459:     * 'Int16'
 1460:     * 'UInt32'
 1461:     * 'Int32'
 1462:     * 'UInt64'
 1463:     * 'Int64'
 1464:     """
 1465:     return request.param
 1466: 
 1467: 
 1468: @pytest.fixture(params=tm.ALL_INT_DTYPES)
 1469: def any_int_dtype(request):
 1470:     """
 1471:     Parameterized fixture for any nullable integer dtype.
 1472: 
 1473:     * int
 1474:     * 'int8'
 1475:     * 'uint8'
 1476:     * 'int16'
 1477:     * 'uint16'
 1478:     * 'int32'
 1479:     * 'uint32'
 1480:     * 'int64'
 1481:     * 'uint64'
 1482:     * 'UInt8'
 1483:     * 'Int8'
 1484:     * 'UInt16'
 1485:     * 'Int16'
 1486:     * 'UInt32'
 1487:     * 'Int32'
 1488:     * 'UInt64'
 1489:     * 'Int64'
 1490:     """
 1491:     return request.param
 1492: 
 1493: 
 1494: @pytest.fixture(params=tm.ALL_INT_EA_DTYPES + tm.FLOAT_EA_DTYPES)
 1495: def any_numeric_ea_dtype(request):
 1496:     """
 1497:     Parameterized fixture for any nullable integer dtype and
 1498:     any float ea dtypes.
 1499: 
 1500:     * 'UInt8'
 1501:     * 'Int8'
 1502:     * 'UInt16'
 1503:     * 'Int16'
 1504:     * 'UInt32'
 1505:     * 'Int32'
 1506:     * 'UInt64'
 1507:     * 'Int64'
 1508:     * 'Float32'
 1509:     * 'Float64'
 1510:     """
 1511:     return request.param
 1512: 
 1513: 
 1514: #  Unsupported operand types for + ("List[Union[str, ExtensionDtype, dtype[Any],
 1515: #  Type[object]]]" and "List[str]")
 1516: @pytest.fixture(
 1517:     params=tm.ALL_INT_EA_DTYPES
 1518:     + tm.FLOAT_EA_DTYPES
 1519:     + tm.ALL_INT_PYARROW_DTYPES_STR_REPR
 1520:     + tm.FLOAT_PYARROW_DTYPES_STR_REPR  # type: ignore[operator]
 1521: )
 1522: def any_numeric_ea_and_arrow_dtype(request):
 1523:     """
 1524:     Parameterized fixture for any nullable integer dtype and
 1525:     any float ea dtypes.
 1526: 
 1527:     * 'UInt8'
 1528:     * 'Int8'
 1529:     * 'UInt16'
 1530:     * 'Int16'
 1531:     * 'UInt32'
 1532:     * 'Int32'
 1533:     * 'UInt64'
 1534:     * 'Int64'
 1535:     * 'Float32'
 1536:     * 'Float64'
 1537:     * 'uint8[pyarrow]'
 1538:     * 'int8[pyarrow]'
 1539:     * 'uint16[pyarrow]'
 1540:     * 'int16[pyarrow]'
 1541:     * 'uint32[pyarrow]'
 1542:     * 'int32[pyarrow]'
 1543:     * 'uint64[pyarrow]'
 1544:     * 'int64[pyarrow]'
 1545:     * 'float32[pyarrow]'
 1546:     * 'float64[pyarrow]'
 1547:     """
 1548:     return request.param
 1549: 
 1550: 
 1551: @pytest.fixture(params=tm.SIGNED_INT_EA_DTYPES)
 1552: def any_signed_int_ea_dtype(request):
 1553:     """
 1554:     Parameterized fixture for any signed nullable integer dtype.
 1555: 
 1556:     * 'Int8'
 1557:     * 'Int16'
 1558:     * 'Int32'
 1559:     * 'Int64'
 1560:     """
 1561:     return request.param
 1562: 
 1563: 
 1564: @pytest.fixture(params=tm.ALL_REAL_NUMPY_DTYPES)
 1565: def any_real_numpy_dtype(request):
 1566:     """
 1567:     Parameterized fixture for any (purely) real numeric dtype.
 1568: 
 1569:     * int
 1570:     * 'int8'
 1571:     * 'uint8'
 1572:     * 'int16'
 1573:     * 'uint16'
 1574:     * 'int32'
 1575:     * 'uint32'
 1576:     * 'int64'
 1577:     * 'uint64'
 1578:     * float
 1579:     * 'float32'
 1580:     * 'float64'
 1581:     """
 1582:     return request.param
 1583: 
 1584: 
 1585: @pytest.fixture(params=tm.ALL_REAL_DTYPES)
 1586: def any_real_numeric_dtype(request):
 1587:     """
 1588:     Parameterized fixture for any (purely) real numeric dtype.
 1589: 
 1590:     * int
 1591:     * 'int8'
 1592:     * 'uint8'
 1593:     * 'int16'
 1594:     * 'uint16'
 1595:     * 'int32'
 1596:     * 'uint32'
 1597:     * 'int64'
 1598:     * 'uint64'
 1599:     * float
 1600:     * 'float32'
 1601:     * 'float64'
 1602: 
 1603:     and associated ea dtypes.
 1604:     """
 1605:     return request.param
 1606: 
 1607: 
 1608: @pytest.fixture(params=tm.ALL_NUMPY_DTYPES)
 1609: def any_numpy_dtype(request):
 1610:     """
 1611:     Parameterized fixture for all numpy dtypes.
 1612: 
 1613:     * bool
 1614:     * 'bool'
 1615:     * int
 1616:     * 'int8'
 1617:     * 'uint8'
 1618:     * 'int16'
 1619:     * 'uint16'
 1620:     * 'int32'
 1621:     * 'uint32'
 1622:     * 'int64'
 1623:     * 'uint64'
 1624:     * float
 1625:     * 'float32'
 1626:     * 'float64'
 1627:     * complex
 1628:     * 'complex64'
 1629:     * 'complex128'
 1630:     * str
 1631:     * 'str'
 1632:     * 'U'
 1633:     * bytes
 1634:     * 'bytes'
 1635:     * 'datetime64[ns]'
 1636:     * 'M8[ns]'
 1637:     * 'timedelta64[ns]'
 1638:     * 'm8[ns]'
 1639:     * object
 1640:     * 'object'
 1641:     """
 1642:     return request.param
 1643: 
 1644: 
 1645: @pytest.fixture(params=tm.ALL_REAL_NULLABLE_DTYPES)
 1646: def any_real_nullable_dtype(request):
 1647:     """
 1648:     Parameterized fixture for all real dtypes that can hold NA.
 1649: 
 1650:     * float
 1651:     * 'float32'
 1652:     * 'float64'
 1653:     * 'Float32'
 1654:     * 'Float64'
 1655:     * 'UInt8'
 1656:     * 'UInt16'
 1657:     * 'UInt32'
 1658:     * 'UInt64'
 1659:     * 'Int8'
 1660:     * 'Int16'
 1661:     * 'Int32'
 1662:     * 'Int64'
 1663:     * 'uint8[pyarrow]'
 1664:     * 'uint16[pyarrow]'
 1665:     * 'uint32[pyarrow]'
 1666:     * 'uint64[pyarrow]'
 1667:     * 'int8[pyarrow]'
 1668:     * 'int16[pyarrow]'
 1669:     * 'int32[pyarrow]'
 1670:     * 'int64[pyarrow]'
 1671:     * 'float[pyarrow]'
 1672:     * 'double[pyarrow]'
 1673:     """
 1674:     return request.param
 1675: 
 1676: 
 1677: @pytest.fixture(params=tm.ALL_NUMERIC_DTYPES)
 1678: def any_numeric_dtype(request):
 1679:     """
 1680:     Parameterized fixture for all numeric dtypes.
 1681: 
 1682:     * int
 1683:     * 'int8'
 1684:     * 'uint8'
 1685:     * 'int16'
 1686:     * 'uint16'
 1687:     * 'int32'
 1688:     * 'uint32'
 1689:     * 'int64'
 1690:     * 'uint64'
 1691:     * float
 1692:     * 'float32'
 1693:     * 'float64'
 1694:     * complex
 1695:     * 'complex64'
 1696:     * 'complex128'
 1697:     * 'UInt8'
 1698:     * 'Int8'
 1699:     * 'UInt16'
 1700:     * 'Int16'
 1701:     * 'UInt32'
 1702:     * 'Int32'
 1703:     * 'UInt64'
 1704:     * 'Int64'
 1705:     * 'Float32'
 1706:     * 'Float64'
 1707:     """
 1708:     return request.param
 1709: 
 1710: 
 1711: # categoricals are handled separately
 1712: _any_skipna_inferred_dtype = [
 1713:     ("string", ["a", np.nan, "c"]),
 1714:     ("string", ["a", pd.NA, "c"]),
 1715:     ("mixed", ["a", pd.NaT, "c"]),  # pd.NaT not considered valid by is_string_array
 1716:     ("bytes", [b"a", np.nan, b"c"]),
 1717:     ("empty", [np.nan, np.nan, np.nan]),
 1718:     ("empty", []),
 1719:     ("mixed-integer", ["a", np.nan, 2]),
 1720:     ("mixed", ["a", np.nan, 2.0]),
 1721:     ("floating", [1.0, np.nan, 2.0]),
 1722:     ("integer", [1, np.nan, 2]),
 1723:     ("mixed-integer-float", [1, np.nan, 2.0]),
 1724:     ("decimal", [Decimal(1), np.nan, Decimal(2)]),
 1725:     ("boolean", [True, np.nan, False]),
 1726:     ("boolean", [True, pd.NA, False]),
 1727:     ("datetime64", [np.datetime64("2013-01-01"), np.nan, np.datetime64("2018-01-01")]),
 1728:     ("datetime", [Timestamp("20130101"), np.nan, Timestamp("20180101")]),
 1729:     ("date", [date(2013, 1, 1), np.nan, date(2018, 1, 1)]),
 1730:     ("complex", [1 + 1j, np.nan, 2 + 2j]),
 1731:     # The following dtype is commented out due to GH 23554
 1732:     # ('timedelta64', [np.timedelta64(1, 'D'),
 1733:     #                  np.nan, np.timedelta64(2, 'D')]),
 1734:     ("timedelta", [timedelta(1), np.nan, timedelta(2)]),
 1735:     ("time", [time(1), np.nan, time(2)]),
 1736:     ("period", [Period(2013), pd.NaT, Period(2018)]),
 1737:     ("interval", [Interval(0, 1), np.nan, Interval(0, 2)]),
 1738: ]
 1739: ids, _ = zip(*_any_skipna_inferred_dtype)  # use inferred type as fixture-id
 1740: 
 1741: 
 1742: @pytest.fixture(params=_any_skipna_inferred_dtype, ids=ids)
 1743: def any_skipna_inferred_dtype(request):
 1744:     """
 1745:     Fixture for all inferred dtypes from _libs.lib.infer_dtype
 1746: 
 1747:     The covered (inferred) types are:
 1748:     * 'string'
 1749:     * 'empty'
 1750:     * 'bytes'
 1751:     * 'mixed'
 1752:     * 'mixed-integer'
 1753:     * 'mixed-integer-float'
 1754:     * 'floating'
 1755:     * 'integer'
 1756:     * 'decimal'
 1757:     * 'boolean'
 1758:     * 'datetime64'
 1759:     * 'datetime'
 1760:     * 'date'
 1761:     * 'timedelta'
 1762:     * 'time'
 1763:     * 'period'
 1764:     * 'interval'
 1765: 
 1766:     Returns
 1767:     -------
 1768:     inferred_dtype : str
 1769:         The string for the inferred dtype from _libs.lib.infer_dtype
 1770:     values : np.ndarray
 1771:         An array of object dtype that will be inferred to have
 1772:         `inferred_dtype`
 1773: 
 1774:     Examples
 1775:     --------
 1776:     >>> from pandas._libs import lib
 1777:     >>>
 1778:     >>> def test_something(any_skipna_inferred_dtype):
 1779:     ...     inferred_dtype, values = any_skipna_inferred_dtype
 1780:     ...     # will pass
 1781:     ...     assert lib.infer_dtype(values, skipna=True) == inferred_dtype
 1782:     """
 1783:     inferred_dtype, values = request.param
 1784:     values = np.array(values, dtype=object)  # object dtype to avoid casting
 1785: 
 1786:     # correctness of inference tested in tests/dtypes/test_inference.py
 1787:     return inferred_dtype, values
 1788: 
 1789: 
 1790: # ----------------------------------------------------------------
 1791: # Misc
 1792: # ----------------------------------------------------------------
 1793: @pytest.fixture
 1794: def ip():
 1795:     """
 1796:     Get an instance of IPython.InteractiveShell.
 1797: 
 1798:     Will raise a skip if IPython is not installed.
 1799:     """
 1800:     pytest.importorskip("IPython", minversion="6.0.0")
 1801:     from IPython.core.interactiveshell import InteractiveShell
 1802: 
 1803:     # GH#35711 make sure sqlite history file handle is not leaked
 1804:     from traitlets.config import Config  # isort:skip
 1805: 
 1806:     c = Config()
 1807:     c.HistoryManager.hist_file = ":memory:"
 1808: 
 1809:     return InteractiveShell(config=c)
 1810: 
 1811: 
 1812: @pytest.fixture(params=["bsr", "coo", "csc", "csr", "dia", "dok", "lil"])
 1813: def spmatrix(request):
 1814:     """
 1815:     Yields scipy sparse matrix classes.
 1816:     """
 1817:     sparse = pytest.importorskip("scipy.sparse")
 1818: 
 1819:     return getattr(sparse, request.param + "_matrix")
 1820: 
 1821: 
 1822: @pytest.fixture(
 1823:     params=[
 1824:         getattr(pd.offsets, o)
 1825:         for o in pd.offsets.__all__
 1826:         if issubclass(getattr(pd.offsets, o), pd.offsets.Tick) and o != "Tick"
 1827:     ]
 1828: )
 1829: def tick_classes(request):
 1830:     """
 1831:     Fixture for Tick based datetime offsets available for a time series.
 1832:     """
 1833:     return request.param
 1834: 
 1835: 
 1836: @pytest.fixture(params=[None, lambda x: x])
 1837: def sort_by_key(request):
 1838:     """
 1839:     Simple fixture for testing keys in sorting methods.
 1840:     Tests None (no key) and the identity key.
 1841:     """
 1842:     return request.param
 1843: 
 1844: 
 1845: @pytest.fixture(
 1846:     params=[
 1847:         ("foo", None, None),
 1848:         ("Egon", "Venkman", None),
 1849:         ("NCC1701D", "NCC1701D", "NCC1701D"),
 1850:         # possibly-matching NAs
 1851:         (np.nan, np.nan, np.nan),
 1852:         (np.nan, pd.NaT, None),
 1853:         (np.nan, pd.NA, None),
 1854:         (pd.NA, pd.NA, pd.NA),
 1855:     ]
 1856: )
 1857: def names(request) -> tuple[Hashable, Hashable, Hashable]:
 1858:     """
 1859:     A 3-tuple of names, the first two for operands, the last for a result.
 1860:     """
 1861:     return request.param
 1862: 
 1863: 
 1864: @pytest.fixture(params=[tm.setitem, tm.loc, tm.iloc])
 1865: def indexer_sli(request):
 1866:     """
 1867:     Parametrize over __setitem__, loc.__setitem__, iloc.__setitem__
 1868:     """
 1869:     return request.param
 1870: 
 1871: 
 1872: @pytest.fixture(params=[tm.loc, tm.iloc])
 1873: def indexer_li(request):
 1874:     """
 1875:     Parametrize over loc.__getitem__, iloc.__getitem__
 1876:     """
 1877:     return request.param
 1878: 
 1879: 
 1880: @pytest.fixture(params=[tm.setitem, tm.iloc])
 1881: def indexer_si(request):
 1882:     """
 1883:     Parametrize over __setitem__, iloc.__setitem__
 1884:     """
 1885:     return request.param
 1886: 
 1887: 
 1888: @pytest.fixture(params=[tm.setitem, tm.loc])
 1889: def indexer_sl(request):
 1890:     """
 1891:     Parametrize over __setitem__, loc.__setitem__
 1892:     """
 1893:     return request.param
 1894: 
 1895: 
 1896: @pytest.fixture(params=[tm.at, tm.loc])
 1897: def indexer_al(request):
 1898:     """
 1899:     Parametrize over at.__setitem__, loc.__setitem__
 1900:     """
 1901:     return request.param
 1902: 
 1903: 
 1904: @pytest.fixture(params=[tm.iat, tm.iloc])
 1905: def indexer_ial(request):
 1906:     """
 1907:     Parametrize over iat.__setitem__, iloc.__setitem__
 1908:     """
 1909:     return request.param
 1910: 
 1911: 
 1912: @pytest.fixture
 1913: def using_array_manager() -> bool:
 1914:     """
 1915:     Fixture to check if the array manager is being used.
 1916:     """
 1917:     return _get_option("mode.data_manager", silent=True) == "array"
 1918: 
 1919: 
 1920: @pytest.fixture
 1921: def using_copy_on_write() -> bool:
 1922:     """
 1923:     Fixture to check if Copy-on-Write is enabled.
 1924:     """
 1925:     return (
 1926:         pd.options.mode.copy_on_write is True
 1927:         and _get_option("mode.data_manager", silent=True) == "block"
 1928:     )
 1929: 
 1930: 
 1931: @pytest.fixture
 1932: def warn_copy_on_write() -> bool:
 1933:     """
 1934:     Fixture to check if Copy-on-Write is in warning mode.
 1935:     """
 1936:     return (
 1937:         pd.options.mode.copy_on_write == "warn"
 1938:         and _get_option("mode.data_manager", silent=True) == "block"
 1939:     )
 1940: 
 1941: 
 1942: @pytest.fixture
 1943: def using_infer_string() -> bool:
 1944:     """
 1945:     Fixture to check if infer string option is enabled.
 1946:     """
 1947:     return pd.options.future.infer_string is True
 1948: 
 1949: 
 1950: warsaws = ["Europe/Warsaw", "dateutil/Europe/Warsaw"]
 1951: if zoneinfo is not None:
 1952:     warsaws.append(zoneinfo.ZoneInfo("Europe/Warsaw"))  # type: ignore[arg-type]
 1953: 
 1954: 
 1955: @pytest.fixture(params=warsaws)
 1956: def warsaw(request) -> str:
 1957:     """
 1958:     tzinfo for Europe/Warsaw using pytz, dateutil, or zoneinfo.
 1959:     """
 1960:     return request.param
 1961: 
 1962: 
 1963: @pytest.fixture()
 1964: def arrow_string_storage():
 1965:     return ("pyarrow", "pyarrow_numpy")
