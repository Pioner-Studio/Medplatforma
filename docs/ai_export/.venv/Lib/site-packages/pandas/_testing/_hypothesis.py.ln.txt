    1: """
    2: Hypothesis data generator helpers.
    3: """
    4: from datetime import datetime
    5: 
    6: from hypothesis import strategies as st
    7: from hypothesis.extra.dateutil import timezones as dateutil_timezones
    8: from hypothesis.extra.pytz import timezones as pytz_timezones
    9: 
   10: from pandas.compat import is_platform_windows
   11: 
   12: import pandas as pd
   13: 
   14: from pandas.tseries.offsets import (
   15:     BMonthBegin,
   16:     BMonthEnd,
   17:     BQuarterBegin,
   18:     BQuarterEnd,
   19:     BYearBegin,
   20:     BYearEnd,
   21:     MonthBegin,
   22:     MonthEnd,
   23:     QuarterBegin,
   24:     QuarterEnd,
   25:     YearBegin,
   26:     YearEnd,
   27: )
   28: 
   29: OPTIONAL_INTS = st.lists(st.one_of(st.integers(), st.none()), max_size=10, min_size=3)
   30: 
   31: OPTIONAL_FLOATS = st.lists(st.one_of(st.floats(), st.none()), max_size=10, min_size=3)
   32: 
   33: OPTIONAL_TEXT = st.lists(st.one_of(st.none(), st.text()), max_size=10, min_size=3)
   34: 
   35: OPTIONAL_DICTS = st.lists(
   36:     st.one_of(st.none(), st.dictionaries(st.text(), st.integers())),
   37:     max_size=10,
   38:     min_size=3,
   39: )
   40: 
   41: OPTIONAL_LISTS = st.lists(
   42:     st.one_of(st.none(), st.lists(st.text(), max_size=10, min_size=3)),
   43:     max_size=10,
   44:     min_size=3,
   45: )
   46: 
   47: OPTIONAL_ONE_OF_ALL = st.one_of(
   48:     OPTIONAL_DICTS, OPTIONAL_FLOATS, OPTIONAL_INTS, OPTIONAL_LISTS, OPTIONAL_TEXT
   49: )
   50: 
   51: if is_platform_windows():
   52:     DATETIME_NO_TZ = st.datetimes(min_value=datetime(1900, 1, 1))
   53: else:
   54:     DATETIME_NO_TZ = st.datetimes()
   55: 
   56: DATETIME_JAN_1_1900_OPTIONAL_TZ = st.datetimes(
   57:     min_value=pd.Timestamp(
   58:         1900, 1, 1
   59:     ).to_pydatetime(),  # pyright: ignore[reportGeneralTypeIssues]
   60:     max_value=pd.Timestamp(
   61:         1900, 1, 1
   62:     ).to_pydatetime(),  # pyright: ignore[reportGeneralTypeIssues]
   63:     timezones=st.one_of(st.none(), dateutil_timezones(), pytz_timezones()),
   64: )
   65: 
   66: DATETIME_IN_PD_TIMESTAMP_RANGE_NO_TZ = st.datetimes(
   67:     min_value=pd.Timestamp.min.to_pydatetime(warn=False),
   68:     max_value=pd.Timestamp.max.to_pydatetime(warn=False),
   69: )
   70: 
   71: INT_NEG_999_TO_POS_999 = st.integers(-999, 999)
   72: 
   73: # The strategy for each type is registered in conftest.py, as they don't carry
   74: # enough runtime information (e.g. type hints) to infer how to build them.
   75: YQM_OFFSET = st.one_of(
   76:     *map(
   77:         st.from_type,
   78:         [
   79:             MonthBegin,
   80:             MonthEnd,
   81:             BMonthBegin,
   82:             BMonthEnd,
   83:             QuarterBegin,
   84:             QuarterEnd,
   85:             BQuarterBegin,
   86:             BQuarterEnd,
   87:             YearBegin,
   88:             YearEnd,
   89:             BYearBegin,
   90:             BYearEnd,
   91:         ],
   92:     )
   93: )
