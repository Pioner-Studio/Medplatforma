    1: # This file helps to compute a version number in source trees obtained from
    2: # git-archive tarball (such as those provided by githubs download-from-tag
    3: # feature). Distribution tarballs (built by setup.py sdist) and build
    4: # directories (produced by setup.py build) will contain a much shorter file
    5: # that just contains the computed version number.
    6: 
    7: # This file is released into the public domain.
    8: # Generated by versioneer-0.28
    9: # https://github.com/python-versioneer/python-versioneer
   10: 
   11: """Git implementation of _version.py."""
   12: 
   13: import errno
   14: import functools
   15: import os
   16: import re
   17: import subprocess
   18: import sys
   19: from typing import Callable
   20: 
   21: 
   22: def get_keywords():
   23:     """Get the keywords needed to look up the version information."""
   24:     # these strings will be replaced by git during git-archive.
   25:     # setup.py/versioneer.py will grep for the variable names, so they must
   26:     # each be defined on a line of their own. _version.py will just call
   27:     # get_keywords().
   28:     git_refnames = "$Format:%d$"
   29:     git_full = "$Format:%H$"
   30:     git_date = "$Format:%ci$"
   31:     keywords = {"refnames": git_refnames, "full": git_full, "date": git_date}
   32:     return keywords
   33: 
   34: 
   35: class VersioneerConfig:
   36:     """Container for Versioneer configuration parameters."""
   37: 
   38: 
   39: def get_config():
   40:     """Create, populate and return the VersioneerConfig() object."""
   41:     # these strings are filled in when 'setup.py versioneer' creates
   42:     # _version.py
   43:     cfg = VersioneerConfig()
   44:     cfg.VCS = "git"
   45:     cfg.style = "pep440"
   46:     cfg.tag_prefix = "v"
   47:     cfg.parentdir_prefix = "pandas-"
   48:     cfg.versionfile_source = "pandas/_version.py"
   49:     cfg.verbose = False
   50:     return cfg
   51: 
   52: 
   53: class NotThisMethod(Exception):
   54:     """Exception raised if a method is not valid for the current scenario."""
   55: 
   56: 
   57: LONG_VERSION_PY: dict[str, str] = {}
   58: HANDLERS: dict[str, dict[str, Callable]] = {}
   59: 
   60: 
   61: def register_vcs_handler(vcs, method):  # decorator
   62:     """Create decorator to mark a method as the handler of a VCS."""
   63: 
   64:     def decorate(f):
   65:         """Store f in HANDLERS[vcs][method]."""
   66:         if vcs not in HANDLERS:
   67:             HANDLERS[vcs] = {}
   68:         HANDLERS[vcs][method] = f
   69:         return f
   70: 
   71:     return decorate
   72: 
   73: 
   74: def run_command(commands, args, cwd=None, verbose=False, hide_stderr=False, env=None):
   75:     """Call the given command(s)."""
   76:     assert isinstance(commands, list)
   77:     process = None
   78: 
   79:     popen_kwargs = {}
   80:     if sys.platform == "win32":
   81:         # This hides the console window if pythonw.exe is used
   82:         startupinfo = subprocess.STARTUPINFO()
   83:         startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
   84:         popen_kwargs["startupinfo"] = startupinfo
   85: 
   86:     for command in commands:
   87:         dispcmd = str([command] + args)
   88:         try:
   89:             # remember shell=False, so use git.cmd on windows, not just git
   90:             process = subprocess.Popen(
   91:                 [command] + args,
   92:                 cwd=cwd,
   93:                 env=env,
   94:                 stdout=subprocess.PIPE,
   95:                 stderr=(subprocess.PIPE if hide_stderr else None),
   96:                 **popen_kwargs,
   97:             )
   98:             break
   99:         except OSError:
  100:             e = sys.exc_info()[1]
  101:             if e.errno == errno.ENOENT:
  102:                 continue
  103:             if verbose:
  104:                 print(f"unable to run {dispcmd}")
  105:                 print(e)
  106:             return None, None
  107:     else:
  108:         if verbose:
  109:             print(f"unable to find command, tried {commands}")
  110:         return None, None
  111:     stdout = process.communicate()[0].strip().decode()
  112:     if process.returncode != 0:
  113:         if verbose:
  114:             print(f"unable to run {dispcmd} (error)")
  115:             print(f"stdout was {stdout}")
  116:         return None, process.returncode
  117:     return stdout, process.returncode
  118: 
  119: 
  120: def versions_from_parentdir(parentdir_prefix, root, verbose):
  121:     """Try to determine the version from the parent directory name.
  122: 
  123:     Source tarballs conventionally unpack into a directory that includes both
  124:     the project name and a version string. We will also support searching up
  125:     two directory levels for an appropriately named parent directory
  126:     """
  127:     rootdirs = []
  128: 
  129:     for _ in range(3):
  130:         dirname = os.path.basename(root)
  131:         if dirname.startswith(parentdir_prefix):
  132:             return {
  133:                 "version": dirname[len(parentdir_prefix) :],
  134:                 "full-revisionid": None,
  135:                 "dirty": False,
  136:                 "error": None,
  137:                 "date": None,
  138:             }
  139:         rootdirs.append(root)
  140:         root = os.path.dirname(root)  # up a level
  141: 
  142:     if verbose:
  143:         print(
  144:             f"Tried directories {str(rootdirs)} \
  145:             but none started with prefix {parentdir_prefix}"
  146:         )
  147:     raise NotThisMethod("rootdir doesn't start with parentdir_prefix")
  148: 
  149: 
  150: @register_vcs_handler("git", "get_keywords")
  151: def git_get_keywords(versionfile_abs):
  152:     """Extract version information from the given file."""
  153:     # the code embedded in _version.py can just fetch the value of these
  154:     # keywords. When used from setup.py, we don't want to import _version.py,
  155:     # so we do it with a regexp instead. This function is not used from
  156:     # _version.py.
  157:     keywords = {}
  158:     try:
  159:         with open(versionfile_abs, encoding="utf-8") as fobj:
  160:             for line in fobj:
  161:                 if line.strip().startswith("git_refnames ="):
  162:                     mo = re.search(r'=\s*"(.*)"', line)
  163:                     if mo:
  164:                         keywords["refnames"] = mo.group(1)
  165:                 if line.strip().startswith("git_full ="):
  166:                     mo = re.search(r'=\s*"(.*)"', line)
  167:                     if mo:
  168:                         keywords["full"] = mo.group(1)
  169:                 if line.strip().startswith("git_date ="):
  170:                     mo = re.search(r'=\s*"(.*)"', line)
  171:                     if mo:
  172:                         keywords["date"] = mo.group(1)
  173:     except OSError:
  174:         pass
  175:     return keywords
  176: 
  177: 
  178: @register_vcs_handler("git", "keywords")
  179: def git_versions_from_keywords(keywords, tag_prefix, verbose):
  180:     """Get version information from git keywords."""
  181:     if "refnames" not in keywords:
  182:         raise NotThisMethod("Short version file found")
  183:     date = keywords.get("date")
  184:     if date is not None:
  185:         # Use only the last line.  Previous lines may contain GPG signature
  186:         # information.
  187:         date = date.splitlines()[-1]
  188: 
  189:         # git-2.2.0 added "%cI", which expands to an ISO-8601 -compliant
  190:         # datestamp. However we prefer "%ci" (which expands to an "ISO-8601
  191:         # -like" string, which we must then edit to make compliant), because
  192:         # it's been around since git-1.5.3, and it's too difficult to
  193:         # discover which version we're using, or to work around using an
  194:         # older one.
  195:         date = date.strip().replace(" ", "T", 1).replace(" ", "", 1)
  196:     refnames = keywords["refnames"].strip()
  197:     if refnames.startswith("$Format"):
  198:         if verbose:
  199:             print("keywords are unexpanded, not using")
  200:         raise NotThisMethod("unexpanded keywords, not a git-archive tarball")
  201:     refs = {r.strip() for r in refnames.strip("()").split(",")}
  202:     # starting in git-1.8.3, tags are listed as "tag: foo-1.0" instead of
  203:     # just "foo-1.0". If we see a "tag: " prefix, prefer those.
  204:     TAG = "tag: "
  205:     tags = {r[len(TAG) :] for r in refs if r.startswith(TAG)}
  206:     if not tags:
  207:         # Either we're using git < 1.8.3, or there really are no tags. We use
  208:         # a heuristic: assume all version tags have a digit. The old git %d
  209:         # expansion behaves like git log --decorate=short and strips out the
  210:         # refs/heads/ and refs/tags/ prefixes that would let us distinguish
  211:         # between branches and tags. By ignoring refnames without digits, we
  212:         # filter out many common branch names like "release" and
  213:         # "stabilization", as well as "HEAD" and "master".
  214:         tags = {r for r in refs if re.search(r"\d", r)}
  215:         if verbose:
  216:             print(f"discarding '{','.join(refs - tags)}', no digits")
  217:     if verbose:
  218:         print(f"likely tags: {','.join(sorted(tags))}")
  219:     for ref in sorted(tags):
  220:         # sorting will prefer e.g. "2.0" over "2.0rc1"
  221:         if ref.startswith(tag_prefix):
  222:             r = ref[len(tag_prefix) :]
  223:             # Filter out refs that exactly match prefix or that don't start
  224:             # with a number once the prefix is stripped (mostly a concern
  225:             # when prefix is '')
  226:             if not re.match(r"\d", r):
  227:                 continue
  228:             if verbose:
  229:                 print(f"picking {r}")
  230:             return {
  231:                 "version": r,
  232:                 "full-revisionid": keywords["full"].strip(),
  233:                 "dirty": False,
  234:                 "error": None,
  235:                 "date": date,
  236:             }
  237:     # no suitable tags, so version is "0+unknown", but full hex is still there
  238:     if verbose:
  239:         print("no suitable tags, using unknown + full revision id")
  240:     return {
  241:         "version": "0+unknown",
  242:         "full-revisionid": keywords["full"].strip(),
  243:         "dirty": False,
  244:         "error": "no suitable tags",
  245:         "date": None,
  246:     }
  247: 
  248: 
  249: @register_vcs_handler("git", "pieces_from_vcs")
  250: def git_pieces_from_vcs(tag_prefix, root, verbose, runner=run_command):
  251:     """Get version from 'git describe' in the root of the source tree.
  252: 
  253:     This only gets called if the git-archive 'subst' keywords were *not*
  254:     expanded, and _version.py hasn't already been rewritten with a short
  255:     version string, meaning we're inside a checked out source tree.
  256:     """
  257:     GITS = ["git"]
  258:     if sys.platform == "win32":
  259:         GITS = ["git.cmd", "git.exe"]
  260: 
  261:     # GIT_DIR can interfere with correct operation of Versioneer.
  262:     # It may be intended to be passed to the Versioneer-versioned project,
  263:     # but that should not change where we get our version from.
  264:     env = os.environ.copy()
  265:     env.pop("GIT_DIR", None)
  266:     runner = functools.partial(runner, env=env)
  267: 
  268:     _, rc = runner(GITS, ["rev-parse", "--git-dir"], cwd=root, hide_stderr=not verbose)
  269:     if rc != 0:
  270:         if verbose:
  271:             print(f"Directory {root} not under git control")
  272:         raise NotThisMethod("'git rev-parse --git-dir' returned error")
  273: 
  274:     # if there is a tag matching tag_prefix, this yields TAG-NUM-gHEX[-dirty]
  275:     # if there isn't one, this yields HEX[-dirty] (no NUM)
  276:     describe_out, rc = runner(
  277:         GITS,
  278:         [
  279:             "describe",
  280:             "--tags",
  281:             "--dirty",
  282:             "--always",
  283:             "--long",
  284:             "--match",
  285:             f"{tag_prefix}[[:digit:]]*",
  286:         ],
  287:         cwd=root,
  288:     )
  289:     # --long was added in git-1.5.5
  290:     if describe_out is None:
  291:         raise NotThisMethod("'git describe' failed")
  292:     describe_out = describe_out.strip()
  293:     full_out, rc = runner(GITS, ["rev-parse", "HEAD"], cwd=root)
  294:     if full_out is None:
  295:         raise NotThisMethod("'git rev-parse' failed")
  296:     full_out = full_out.strip()
  297: 
  298:     pieces = {}
  299:     pieces["long"] = full_out
  300:     pieces["short"] = full_out[:7]  # maybe improved later
  301:     pieces["error"] = None
  302: 
  303:     branch_name, rc = runner(GITS, ["rev-parse", "--abbrev-ref", "HEAD"], cwd=root)
  304:     # --abbrev-ref was added in git-1.6.3
  305:     if rc != 0 or branch_name is None:
  306:         raise NotThisMethod("'git rev-parse --abbrev-ref' returned error")
  307:     branch_name = branch_name.strip()
  308: 
  309:     if branch_name == "HEAD":
  310:         # If we aren't exactly on a branch, pick a branch which represents
  311:         # the current commit. If all else fails, we are on a branchless
  312:         # commit.
  313:         branches, rc = runner(GITS, ["branch", "--contains"], cwd=root)
  314:         # --contains was added in git-1.5.4
  315:         if rc != 0 or branches is None:
  316:             raise NotThisMethod("'git branch --contains' returned error")
  317:         branches = branches.split("\n")
  318: 
  319:         # Remove the first line if we're running detached
  320:         if "(" in branches[0]:
  321:             branches.pop(0)
  322: 
  323:         # Strip off the leading "* " from the list of branches.
  324:         branches = [branch[2:] for branch in branches]
  325:         if "master" in branches:
  326:             branch_name = "master"
  327:         elif not branches:
  328:             branch_name = None
  329:         else:
  330:             # Pick the first branch that is returned. Good or bad.
  331:             branch_name = branches[0]
  332: 
  333:     pieces["branch"] = branch_name
  334: 
  335:     # parse describe_out. It will be like TAG-NUM-gHEX[-dirty] or HEX[-dirty]
  336:     # TAG might have hyphens.
  337:     git_describe = describe_out
  338: 
  339:     # look for -dirty suffix
  340:     dirty = git_describe.endswith("-dirty")
  341:     pieces["dirty"] = dirty
  342:     if dirty:
  343:         git_describe = git_describe[: git_describe.rindex("-dirty")]
  344: 
  345:     # now we have TAG-NUM-gHEX or HEX
  346: 
  347:     if "-" in git_describe:
  348:         # TAG-NUM-gHEX
  349:         mo = re.search(r"^(.+)-(\d+)-g([0-9a-f]+)$", git_describe)
  350:         if not mo:
  351:             # unparsable. Maybe git-describe is misbehaving?
  352:             pieces["error"] = f"unable to parse git-describe output: '{describe_out}'"
  353:             return pieces
  354: 
  355:         # tag
  356:         full_tag = mo.group(1)
  357:         if not full_tag.startswith(tag_prefix):
  358:             if verbose:
  359:                 fmt = "tag '%s' doesn't start with prefix '%s'"
  360:                 print(fmt % (full_tag, tag_prefix))
  361:             pieces[
  362:                 "error"
  363:             ] = f"tag '{full_tag}' doesn't start with prefix '{tag_prefix}'"
  364:             return pieces
  365:         pieces["closest-tag"] = full_tag[len(tag_prefix) :]
  366: 
  367:         # distance: number of commits since tag
  368:         pieces["distance"] = int(mo.group(2))
  369: 
  370:         # commit: short hex revision ID
  371:         pieces["short"] = mo.group(3)
  372: 
  373:     else:
  374:         # HEX: no tags
  375:         pieces["closest-tag"] = None
  376:         out, rc = runner(GITS, ["rev-list", "HEAD", "--left-right"], cwd=root)
  377:         pieces["distance"] = len(out.split())  # total number of commits
  378: 
  379:     # commit date: see ISO-8601 comment in git_versions_from_keywords()
  380:     date = runner(GITS, ["show", "-s", "--format=%ci", "HEAD"], cwd=root)[0].strip()
  381:     # Use only the last line.  Previous lines may contain GPG signature
  382:     # information.
  383:     date = date.splitlines()[-1]
  384:     pieces["date"] = date.strip().replace(" ", "T", 1).replace(" ", "", 1)
  385: 
  386:     return pieces
  387: 
  388: 
  389: def plus_or_dot(pieces) -> str:
  390:     """Return a + if we don't already have one, else return a ."""
  391:     if "+" in pieces.get("closest-tag", ""):
  392:         return "."
  393:     return "+"
  394: 
  395: 
  396: def render_pep440(pieces):
  397:     """Build up version string, with post-release "local version identifier".
  398: 
  399:     Our goal: TAG[+DISTANCE.gHEX[.dirty]] . Note that if you
  400:     get a tagged build and then dirty it, you'll get TAG+0.gHEX.dirty
  401: 
  402:     Exceptions:
  403:     1: no tags. git_describe was just HEX. 0+untagged.DISTANCE.gHEX[.dirty]
  404:     """
  405:     if pieces["closest-tag"]:
  406:         rendered = pieces["closest-tag"]
  407:         if pieces["distance"] or pieces["dirty"]:
  408:             rendered += plus_or_dot(pieces)
  409:             rendered += f"{pieces['distance']}.g{pieces['short']}"
  410:             if pieces["dirty"]:
  411:                 rendered += ".dirty"
  412:     else:
  413:         # exception #1
  414:         rendered = f"0+untagged.{pieces['distance']}.g{pieces['short']}"
  415:         if pieces["dirty"]:
  416:             rendered += ".dirty"
  417:     return rendered
  418: 
  419: 
  420: def render_pep440_branch(pieces):
  421:     """TAG[[.dev0]+DISTANCE.gHEX[.dirty]] .
  422: 
  423:     The ".dev0" means not master branch. Note that .dev0 sorts backwards
  424:     (a feature branch will appear "older" than the master branch).
  425: 
  426:     Exceptions:
  427:     1: no tags. 0[.dev0]+untagged.DISTANCE.gHEX[.dirty]
  428:     """
  429:     if pieces["closest-tag"]:
  430:         rendered = pieces["closest-tag"]
  431:         if pieces["distance"] or pieces["dirty"]:
  432:             if pieces["branch"] != "master":
  433:                 rendered += ".dev0"
  434:             rendered += plus_or_dot(pieces)
  435:             rendered += f"{pieces['distance']}.g{pieces['short']}"
  436:             if pieces["dirty"]:
  437:                 rendered += ".dirty"
  438:     else:
  439:         # exception #1
  440:         rendered = "0"
  441:         if pieces["branch"] != "master":
  442:             rendered += ".dev0"
  443:         rendered += f"+untagged.{pieces['distance']}.g{pieces['short']}"
  444:         if pieces["dirty"]:
  445:             rendered += ".dirty"
  446:     return rendered
  447: 
  448: 
  449: def pep440_split_post(ver):
  450:     """Split pep440 version string at the post-release segment.
  451: 
  452:     Returns the release segments before the post-release and the
  453:     post-release version number (or -1 if no post-release segment is present).
  454:     """
  455:     vc = str.split(ver, ".post")
  456:     return vc[0], int(vc[1] or 0) if len(vc) == 2 else None
  457: 
  458: 
  459: def render_pep440_pre(pieces):
  460:     """TAG[.postN.devDISTANCE] -- No -dirty.
  461: 
  462:     Exceptions:
  463:     1: no tags. 0.post0.devDISTANCE
  464:     """
  465:     if pieces["closest-tag"]:
  466:         if pieces["distance"]:
  467:             # update the post release segment
  468:             tag_version, post_version = pep440_split_post(pieces["closest-tag"])
  469:             rendered = tag_version
  470:             if post_version is not None:
  471:                 rendered += f".post{post_version + 1}.dev{pieces['distance']}"
  472:             else:
  473:                 rendered += f".post0.dev{pieces['distance']}"
  474:         else:
  475:             # no commits, use the tag as the version
  476:             rendered = pieces["closest-tag"]
  477:     else:
  478:         # exception #1
  479:         rendered = f"0.post0.dev{pieces['distance']}"
  480:     return rendered
  481: 
  482: 
  483: def render_pep440_post(pieces):
  484:     """TAG[.postDISTANCE[.dev0]+gHEX] .
  485: 
  486:     The ".dev0" means dirty. Note that .dev0 sorts backwards
  487:     (a dirty tree will appear "older" than the corresponding clean one),
  488:     but you shouldn't be releasing software with -dirty anyways.
  489: 
  490:     Exceptions:
  491:     1: no tags. 0.postDISTANCE[.dev0]
  492:     """
  493:     if pieces["closest-tag"]:
  494:         rendered = pieces["closest-tag"]
  495:         if pieces["distance"] or pieces["dirty"]:
  496:             rendered += f".post{pieces['distance']}"
  497:             if pieces["dirty"]:
  498:                 rendered += ".dev0"
  499:             rendered += plus_or_dot(pieces)
  500:             rendered += f"g{pieces['short']}"
  501:     else:
  502:         # exception #1
  503:         rendered = f"0.post{pieces['distance']}"
  504:         if pieces["dirty"]:
  505:             rendered += ".dev0"
  506:         rendered += f"+g{pieces['short']}"
  507:     return rendered
  508: 
  509: 
  510: def render_pep440_post_branch(pieces):
  511:     """TAG[.postDISTANCE[.dev0]+gHEX[.dirty]] .
  512: 
  513:     The ".dev0" means not master branch.
  514: 
  515:     Exceptions:
  516:     1: no tags. 0.postDISTANCE[.dev0]+gHEX[.dirty]
  517:     """
  518:     if pieces["closest-tag"]:
  519:         rendered = pieces["closest-tag"]
  520:         if pieces["distance"] or pieces["dirty"]:
  521:             rendered += f".post{pieces['distance']}"
  522:             if pieces["branch"] != "master":
  523:                 rendered += ".dev0"
  524:             rendered += plus_or_dot(pieces)
  525:             rendered += f"g{pieces['short']}"
  526:             if pieces["dirty"]:
  527:                 rendered += ".dirty"
  528:     else:
  529:         # exception #1
  530:         rendered = f"0.post{pieces['distance']}"
  531:         if pieces["branch"] != "master":
  532:             rendered += ".dev0"
  533:         rendered += f"+g{pieces['short']}"
  534:         if pieces["dirty"]:
  535:             rendered += ".dirty"
  536:     return rendered
  537: 
  538: 
  539: def render_pep440_old(pieces):
  540:     """TAG[.postDISTANCE[.dev0]] .
  541: 
  542:     The ".dev0" means dirty.
  543: 
  544:     Exceptions:
  545:     1: no tags. 0.postDISTANCE[.dev0]
  546:     """
  547:     if pieces["closest-tag"]:
  548:         rendered = pieces["closest-tag"]
  549:         if pieces["distance"] or pieces["dirty"]:
  550:             rendered += f"0.post{pieces['distance']}"
  551:             if pieces["dirty"]:
  552:                 rendered += ".dev0"
  553:     else:
  554:         # exception #1
  555:         rendered = f"0.post{pieces['distance']}"
  556:         if pieces["dirty"]:
  557:             rendered += ".dev0"
  558:     return rendered
  559: 
  560: 
  561: def render_git_describe(pieces):
  562:     """TAG[-DISTANCE-gHEX][-dirty].
  563: 
  564:     Like 'git describe --tags --dirty --always'.
  565: 
  566:     Exceptions:
  567:     1: no tags. HEX[-dirty]  (note: no 'g' prefix)
  568:     """
  569:     if pieces["closest-tag"]:
  570:         rendered = pieces["closest-tag"]
  571:         if pieces["distance"]:
  572:             rendered += f"-{pieces['distance']}-g{pieces['short']}"
  573:     else:
  574:         # exception #1
  575:         rendered = pieces["short"]
  576:     if pieces["dirty"]:
  577:         rendered += "-dirty"
  578:     return rendered
  579: 
  580: 
  581: def render_git_describe_long(pieces):
  582:     """TAG-DISTANCE-gHEX[-dirty].
  583: 
  584:     Like 'git describe --tags --dirty --always -long'.
  585:     The distance/hash is unconditional.
  586: 
  587:     Exceptions:
  588:     1: no tags. HEX[-dirty]  (note: no 'g' prefix)
  589:     """
  590:     if pieces["closest-tag"]:
  591:         rendered = pieces["closest-tag"]
  592:         rendered += f"-{pieces['distance']}-g{pieces['short']}"
  593:     else:
  594:         # exception #1
  595:         rendered = pieces["short"]
  596:     if pieces["dirty"]:
  597:         rendered += "-dirty"
  598:     return rendered
  599: 
  600: 
  601: def render(pieces, style):
  602:     """Render the given version pieces into the requested style."""
  603:     if pieces["error"]:
  604:         return {
  605:             "version": "unknown",
  606:             "full-revisionid": pieces.get("long"),
  607:             "dirty": None,
  608:             "error": pieces["error"],
  609:             "date": None,
  610:         }
  611: 
  612:     if not style or style == "default":
  613:         style = "pep440"  # the default
  614: 
  615:     if style == "pep440":
  616:         rendered = render_pep440(pieces)
  617:     elif style == "pep440-branch":
  618:         rendered = render_pep440_branch(pieces)
  619:     elif style == "pep440-pre":
  620:         rendered = render_pep440_pre(pieces)
  621:     elif style == "pep440-post":
  622:         rendered = render_pep440_post(pieces)
  623:     elif style == "pep440-post-branch":
  624:         rendered = render_pep440_post_branch(pieces)
  625:     elif style == "pep440-old":
  626:         rendered = render_pep440_old(pieces)
  627:     elif style == "git-describe":
  628:         rendered = render_git_describe(pieces)
  629:     elif style == "git-describe-long":
  630:         rendered = render_git_describe_long(pieces)
  631:     else:
  632:         raise ValueError(f"unknown style '{style}'")
  633: 
  634:     return {
  635:         "version": rendered,
  636:         "full-revisionid": pieces["long"],
  637:         "dirty": pieces["dirty"],
  638:         "error": None,
  639:         "date": pieces.get("date"),
  640:     }
  641: 
  642: 
  643: def get_versions():
  644:     """Get version information or return default if unable to do so."""
  645:     # I am in _version.py, which lives at ROOT/VERSIONFILE_SOURCE. If we have
  646:     # __file__, we can work backwards from there to the root. Some
  647:     # py2exe/bbfreeze/non-CPython implementations don't do __file__, in which
  648:     # case we can only use expanded keywords.
  649: 
  650:     cfg = get_config()
  651:     verbose = cfg.verbose
  652: 
  653:     try:
  654:         return git_versions_from_keywords(get_keywords(), cfg.tag_prefix, verbose)
  655:     except NotThisMethod:
  656:         pass
  657: 
  658:     try:
  659:         root = os.path.realpath(__file__)
  660:         # versionfile_source is the relative path from the top of the source
  661:         # tree (where the .git directory might live) to this file. Invert
  662:         # this to find the root from __file__.
  663:         for _ in cfg.versionfile_source.split("/"):
  664:             root = os.path.dirname(root)
  665:     except NameError:
  666:         return {
  667:             "version": "0+unknown",
  668:             "full-revisionid": None,
  669:             "dirty": None,
  670:             "error": "unable to find root of source tree",
  671:             "date": None,
  672:         }
  673: 
  674:     try:
  675:         pieces = git_pieces_from_vcs(cfg.tag_prefix, root, verbose)
  676:         return render(pieces, cfg.style)
  677:     except NotThisMethod:
  678:         pass
  679: 
  680:     try:
  681:         if cfg.parentdir_prefix:
  682:             return versions_from_parentdir(cfg.parentdir_prefix, root, verbose)
  683:     except NotThisMethod:
  684:         pass
  685: 
  686:     return {
  687:         "version": "0+unknown",
  688:         "full-revisionid": None,
  689:         "dirty": None,
  690:         "error": "unable to compute version",
  691:         "date": None,
  692:     }
