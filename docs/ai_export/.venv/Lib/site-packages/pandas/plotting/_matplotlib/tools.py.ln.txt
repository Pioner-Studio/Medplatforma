    1: # being a bit too dynamic
    2: from __future__ import annotations
    3: 
    4: from math import ceil
    5: from typing import TYPE_CHECKING
    6: import warnings
    7: 
    8: from matplotlib import ticker
    9: import matplotlib.table
   10: import numpy as np
   11: 
   12: from pandas.util._exceptions import find_stack_level
   13: 
   14: from pandas.core.dtypes.common import is_list_like
   15: from pandas.core.dtypes.generic import (
   16:     ABCDataFrame,
   17:     ABCIndex,
   18:     ABCSeries,
   19: )
   20: 
   21: if TYPE_CHECKING:
   22:     from collections.abc import (
   23:         Iterable,
   24:         Sequence,
   25:     )
   26: 
   27:     from matplotlib.axes import Axes
   28:     from matplotlib.axis import Axis
   29:     from matplotlib.figure import Figure
   30:     from matplotlib.lines import Line2D
   31:     from matplotlib.table import Table
   32: 
   33:     from pandas import (
   34:         DataFrame,
   35:         Series,
   36:     )
   37: 
   38: 
   39: def do_adjust_figure(fig: Figure) -> bool:
   40:     """Whether fig has constrained_layout enabled."""
   41:     if not hasattr(fig, "get_constrained_layout"):
   42:         return False
   43:     return not fig.get_constrained_layout()
   44: 
   45: 
   46: def maybe_adjust_figure(fig: Figure, *args, **kwargs) -> None:
   47:     """Call fig.subplots_adjust unless fig has constrained_layout enabled."""
   48:     if do_adjust_figure(fig):
   49:         fig.subplots_adjust(*args, **kwargs)
   50: 
   51: 
   52: def format_date_labels(ax: Axes, rot) -> None:
   53:     # mini version of autofmt_xdate
   54:     for label in ax.get_xticklabels():
   55:         label.set_horizontalalignment("right")
   56:         label.set_rotation(rot)
   57:     fig = ax.get_figure()
   58:     if fig is not None:
   59:         # should always be a Figure but can technically be None
   60:         maybe_adjust_figure(fig, bottom=0.2)
   61: 
   62: 
   63: def table(
   64:     ax, data: DataFrame | Series, rowLabels=None, colLabels=None, **kwargs
   65: ) -> Table:
   66:     if isinstance(data, ABCSeries):
   67:         data = data.to_frame()
   68:     elif isinstance(data, ABCDataFrame):
   69:         pass
   70:     else:
   71:         raise ValueError("Input data must be DataFrame or Series")
   72: 
   73:     if rowLabels is None:
   74:         rowLabels = data.index
   75: 
   76:     if colLabels is None:
   77:         colLabels = data.columns
   78: 
   79:     cellText = data.values
   80: 
   81:     # error: Argument "cellText" to "table" has incompatible type "ndarray[Any,
   82:     # Any]"; expected "Sequence[Sequence[str]] | None"
   83:     return matplotlib.table.table(
   84:         ax,
   85:         cellText=cellText,  # type: ignore[arg-type]
   86:         rowLabels=rowLabels,
   87:         colLabels=colLabels,
   88:         **kwargs,
   89:     )
   90: 
   91: 
   92: def _get_layout(
   93:     nplots: int,
   94:     layout: tuple[int, int] | None = None,
   95:     layout_type: str = "box",
   96: ) -> tuple[int, int]:
   97:     if layout is not None:
   98:         if not isinstance(layout, (tuple, list)) or len(layout) != 2:
   99:             raise ValueError("Layout must be a tuple of (rows, columns)")
  100: 
  101:         nrows, ncols = layout
  102: 
  103:         if nrows == -1 and ncols > 0:
  104:             layout = nrows, ncols = (ceil(nplots / ncols), ncols)
  105:         elif ncols == -1 and nrows > 0:
  106:             layout = nrows, ncols = (nrows, ceil(nplots / nrows))
  107:         elif ncols <= 0 and nrows <= 0:
  108:             msg = "At least one dimension of layout must be positive"
  109:             raise ValueError(msg)
  110: 
  111:         if nrows * ncols < nplots:
  112:             raise ValueError(
  113:                 f"Layout of {nrows}x{ncols} must be larger than required size {nplots}"
  114:             )
  115: 
  116:         return layout
  117: 
  118:     if layout_type == "single":
  119:         return (1, 1)
  120:     elif layout_type == "horizontal":
  121:         return (1, nplots)
  122:     elif layout_type == "vertical":
  123:         return (nplots, 1)
  124: 
  125:     layouts = {1: (1, 1), 2: (1, 2), 3: (2, 2), 4: (2, 2)}
  126:     try:
  127:         return layouts[nplots]
  128:     except KeyError:
  129:         k = 1
  130:         while k**2 < nplots:
  131:             k += 1
  132: 
  133:         if (k - 1) * k >= nplots:
  134:             return k, (k - 1)
  135:         else:
  136:             return k, k
  137: 
  138: 
  139: # copied from matplotlib/pyplot.py and modified for pandas.plotting
  140: 
  141: 
  142: def create_subplots(
  143:     naxes: int,
  144:     sharex: bool = False,
  145:     sharey: bool = False,
  146:     squeeze: bool = True,
  147:     subplot_kw=None,
  148:     ax=None,
  149:     layout=None,
  150:     layout_type: str = "box",
  151:     **fig_kw,
  152: ):
  153:     """
  154:     Create a figure with a set of subplots already made.
  155: 
  156:     This utility wrapper makes it convenient to create common layouts of
  157:     subplots, including the enclosing figure object, in a single call.
  158: 
  159:     Parameters
  160:     ----------
  161:     naxes : int
  162:       Number of required axes. Exceeded axes are set invisible. Default is
  163:       nrows * ncols.
  164: 
  165:     sharex : bool
  166:       If True, the X axis will be shared amongst all subplots.
  167: 
  168:     sharey : bool
  169:       If True, the Y axis will be shared amongst all subplots.
  170: 
  171:     squeeze : bool
  172: 
  173:       If True, extra dimensions are squeezed out from the returned axis object:
  174:         - if only one subplot is constructed (nrows=ncols=1), the resulting
  175:         single Axis object is returned as a scalar.
  176:         - for Nx1 or 1xN subplots, the returned object is a 1-d numpy object
  177:         array of Axis objects are returned as numpy 1-d arrays.
  178:         - for NxM subplots with N>1 and M>1 are returned as a 2d array.
  179: 
  180:       If False, no squeezing is done: the returned axis object is always
  181:       a 2-d array containing Axis instances, even if it ends up being 1x1.
  182: 
  183:     subplot_kw : dict
  184:       Dict with keywords passed to the add_subplot() call used to create each
  185:       subplots.
  186: 
  187:     ax : Matplotlib axis object, optional
  188: 
  189:     layout : tuple
  190:       Number of rows and columns of the subplot grid.
  191:       If not specified, calculated from naxes and layout_type
  192: 
  193:     layout_type : {'box', 'horizontal', 'vertical'}, default 'box'
  194:       Specify how to layout the subplot grid.
  195: 
  196:     fig_kw : Other keyword arguments to be passed to the figure() call.
  197:         Note that all keywords not recognized above will be
  198:         automatically included here.
  199: 
  200:     Returns
  201:     -------
  202:     fig, ax : tuple
  203:       - fig is the Matplotlib Figure object
  204:       - ax can be either a single axis object or an array of axis objects if
  205:       more than one subplot was created.  The dimensions of the resulting array
  206:       can be controlled with the squeeze keyword, see above.
  207: 
  208:     Examples
  209:     --------
  210:     x = np.linspace(0, 2*np.pi, 400)
  211:     y = np.sin(x**2)
  212: 
  213:     # Just a figure and one subplot
  214:     f, ax = plt.subplots()
  215:     ax.plot(x, y)
  216:     ax.set_title('Simple plot')
  217: 
  218:     # Two subplots, unpack the output array immediately
  219:     f, (ax1, ax2) = plt.subplots(1, 2, sharey=True)
  220:     ax1.plot(x, y)
  221:     ax1.set_title('Sharing Y axis')
  222:     ax2.scatter(x, y)
  223: 
  224:     # Four polar axes
  225:     plt.subplots(2, 2, subplot_kw=dict(polar=True))
  226:     """
  227:     import matplotlib.pyplot as plt
  228: 
  229:     if subplot_kw is None:
  230:         subplot_kw = {}
  231: 
  232:     if ax is None:
  233:         fig = plt.figure(**fig_kw)
  234:     else:
  235:         if is_list_like(ax):
  236:             if squeeze:
  237:                 ax = flatten_axes(ax)
  238:             if layout is not None:
  239:                 warnings.warn(
  240:                     "When passing multiple axes, layout keyword is ignored.",
  241:                     UserWarning,
  242:                     stacklevel=find_stack_level(),
  243:                 )
  244:             if sharex or sharey:
  245:                 warnings.warn(
  246:                     "When passing multiple axes, sharex and sharey "
  247:                     "are ignored. These settings must be specified when creating axes.",
  248:                     UserWarning,
  249:                     stacklevel=find_stack_level(),
  250:                 )
  251:             if ax.size == naxes:
  252:                 fig = ax.flat[0].get_figure()
  253:                 return fig, ax
  254:             else:
  255:                 raise ValueError(
  256:                     f"The number of passed axes must be {naxes}, the "
  257:                     "same as the output plot"
  258:                 )
  259: 
  260:         fig = ax.get_figure()
  261:         # if ax is passed and a number of subplots is 1, return ax as it is
  262:         if naxes == 1:
  263:             if squeeze:
  264:                 return fig, ax
  265:             else:
  266:                 return fig, flatten_axes(ax)
  267:         else:
  268:             warnings.warn(
  269:                 "To output multiple subplots, the figure containing "
  270:                 "the passed axes is being cleared.",
  271:                 UserWarning,
  272:                 stacklevel=find_stack_level(),
  273:             )
  274:             fig.clear()
  275: 
  276:     nrows, ncols = _get_layout(naxes, layout=layout, layout_type=layout_type)
  277:     nplots = nrows * ncols
  278: 
  279:     # Create empty object array to hold all axes.  It's easiest to make it 1-d
  280:     # so we can just append subplots upon creation, and then
  281:     axarr = np.empty(nplots, dtype=object)
  282: 
  283:     # Create first subplot separately, so we can share it if requested
  284:     ax0 = fig.add_subplot(nrows, ncols, 1, **subplot_kw)
  285: 
  286:     if sharex:
  287:         subplot_kw["sharex"] = ax0
  288:     if sharey:
  289:         subplot_kw["sharey"] = ax0
  290:     axarr[0] = ax0
  291: 
  292:     # Note off-by-one counting because add_subplot uses the MATLAB 1-based
  293:     # convention.
  294:     for i in range(1, nplots):
  295:         kwds = subplot_kw.copy()
  296:         # Set sharex and sharey to None for blank/dummy axes, these can
  297:         # interfere with proper axis limits on the visible axes if
  298:         # they share axes e.g. issue #7528
  299:         if i >= naxes:
  300:             kwds["sharex"] = None
  301:             kwds["sharey"] = None
  302:         ax = fig.add_subplot(nrows, ncols, i + 1, **kwds)
  303:         axarr[i] = ax
  304: 
  305:     if naxes != nplots:
  306:         for ax in axarr[naxes:]:
  307:             ax.set_visible(False)
  308: 
  309:     handle_shared_axes(axarr, nplots, naxes, nrows, ncols, sharex, sharey)
  310: 
  311:     if squeeze:
  312:         # Reshape the array to have the final desired dimension (nrow,ncol),
  313:         # though discarding unneeded dimensions that equal 1.  If we only have
  314:         # one subplot, just return it instead of a 1-element array.
  315:         if nplots == 1:
  316:             axes = axarr[0]
  317:         else:
  318:             axes = axarr.reshape(nrows, ncols).squeeze()
  319:     else:
  320:         # returned axis array will be always 2-d, even if nrows=ncols=1
  321:         axes = axarr.reshape(nrows, ncols)
  322: 
  323:     return fig, axes
  324: 
  325: 
  326: def _remove_labels_from_axis(axis: Axis) -> None:
  327:     for t in axis.get_majorticklabels():
  328:         t.set_visible(False)
  329: 
  330:     # set_visible will not be effective if
  331:     # minor axis has NullLocator and NullFormatter (default)
  332:     if isinstance(axis.get_minor_locator(), ticker.NullLocator):
  333:         axis.set_minor_locator(ticker.AutoLocator())
  334:     if isinstance(axis.get_minor_formatter(), ticker.NullFormatter):
  335:         axis.set_minor_formatter(ticker.FormatStrFormatter(""))
  336:     for t in axis.get_minorticklabels():
  337:         t.set_visible(False)
  338: 
  339:     axis.get_label().set_visible(False)
  340: 
  341: 
  342: def _has_externally_shared_axis(ax1: Axes, compare_axis: str) -> bool:
  343:     """
  344:     Return whether an axis is externally shared.
  345: 
  346:     Parameters
  347:     ----------
  348:     ax1 : matplotlib.axes.Axes
  349:         Axis to query.
  350:     compare_axis : str
  351:         `"x"` or `"y"` according to whether the X-axis or Y-axis is being
  352:         compared.
  353: 
  354:     Returns
  355:     -------
  356:     bool
  357:         `True` if the axis is externally shared. Otherwise `False`.
  358: 
  359:     Notes
  360:     -----
  361:     If two axes with different positions are sharing an axis, they can be
  362:     referred to as *externally* sharing the common axis.
  363: 
  364:     If two axes sharing an axis also have the same position, they can be
  365:     referred to as *internally* sharing the common axis (a.k.a twinning).
  366: 
  367:     _handle_shared_axes() is only interested in axes externally sharing an
  368:     axis, regardless of whether either of the axes is also internally sharing
  369:     with a third axis.
  370:     """
  371:     if compare_axis == "x":
  372:         axes = ax1.get_shared_x_axes()
  373:     elif compare_axis == "y":
  374:         axes = ax1.get_shared_y_axes()
  375:     else:
  376:         raise ValueError(
  377:             "_has_externally_shared_axis() needs 'x' or 'y' as a second parameter"
  378:         )
  379: 
  380:     axes_siblings = axes.get_siblings(ax1)
  381: 
  382:     # Retain ax1 and any of its siblings which aren't in the same position as it
  383:     ax1_points = ax1.get_position().get_points()
  384: 
  385:     for ax2 in axes_siblings:
  386:         if not np.array_equal(ax1_points, ax2.get_position().get_points()):
  387:             return True
  388: 
  389:     return False
  390: 
  391: 
  392: def handle_shared_axes(
  393:     axarr: Iterable[Axes],
  394:     nplots: int,
  395:     naxes: int,
  396:     nrows: int,
  397:     ncols: int,
  398:     sharex: bool,
  399:     sharey: bool,
  400: ) -> None:
  401:     if nplots > 1:
  402:         row_num = lambda x: x.get_subplotspec().rowspan.start
  403:         col_num = lambda x: x.get_subplotspec().colspan.start
  404: 
  405:         is_first_col = lambda x: x.get_subplotspec().is_first_col()
  406: 
  407:         if nrows > 1:
  408:             try:
  409:                 # first find out the ax layout,
  410:                 # so that we can correctly handle 'gaps"
  411:                 layout = np.zeros((nrows + 1, ncols + 1), dtype=np.bool_)
  412:                 for ax in axarr:
  413:                     layout[row_num(ax), col_num(ax)] = ax.get_visible()
  414: 
  415:                 for ax in axarr:
  416:                     # only the last row of subplots should get x labels -> all
  417:                     # other off layout handles the case that the subplot is
  418:                     # the last in the column, because below is no subplot/gap.
  419:                     if not layout[row_num(ax) + 1, col_num(ax)]:
  420:                         continue
  421:                     if sharex or _has_externally_shared_axis(ax, "x"):
  422:                         _remove_labels_from_axis(ax.xaxis)
  423: 
  424:             except IndexError:
  425:                 # if gridspec is used, ax.rowNum and ax.colNum may different
  426:                 # from layout shape. in this case, use last_row logic
  427:                 is_last_row = lambda x: x.get_subplotspec().is_last_row()
  428:                 for ax in axarr:
  429:                     if is_last_row(ax):
  430:                         continue
  431:                     if sharex or _has_externally_shared_axis(ax, "x"):
  432:                         _remove_labels_from_axis(ax.xaxis)
  433: 
  434:         if ncols > 1:
  435:             for ax in axarr:
  436:                 # only the first column should get y labels -> set all other to
  437:                 # off as we only have labels in the first column and we always
  438:                 # have a subplot there, we can skip the layout test
  439:                 if is_first_col(ax):
  440:                     continue
  441:                 if sharey or _has_externally_shared_axis(ax, "y"):
  442:                     _remove_labels_from_axis(ax.yaxis)
  443: 
  444: 
  445: def flatten_axes(axes: Axes | Sequence[Axes]) -> np.ndarray:
  446:     if not is_list_like(axes):
  447:         return np.array([axes])
  448:     elif isinstance(axes, (np.ndarray, ABCIndex)):
  449:         return np.asarray(axes).ravel()
  450:     return np.array(axes)
  451: 
  452: 
  453: def set_ticks_props(
  454:     axes: Axes | Sequence[Axes],
  455:     xlabelsize: int | None = None,
  456:     xrot=None,
  457:     ylabelsize: int | None = None,
  458:     yrot=None,
  459: ):
  460:     import matplotlib.pyplot as plt
  461: 
  462:     for ax in flatten_axes(axes):
  463:         if xlabelsize is not None:
  464:             plt.setp(ax.get_xticklabels(), fontsize=xlabelsize)
  465:         if xrot is not None:
  466:             plt.setp(ax.get_xticklabels(), rotation=xrot)
  467:         if ylabelsize is not None:
  468:             plt.setp(ax.get_yticklabels(), fontsize=ylabelsize)
  469:         if yrot is not None:
  470:             plt.setp(ax.get_yticklabels(), rotation=yrot)
  471:     return axes
  472: 
  473: 
  474: def get_all_lines(ax: Axes) -> list[Line2D]:
  475:     lines = ax.get_lines()
  476: 
  477:     if hasattr(ax, "right_ax"):
  478:         lines += ax.right_ax.get_lines()
  479: 
  480:     if hasattr(ax, "left_ax"):
  481:         lines += ax.left_ax.get_lines()
  482: 
  483:     return lines
  484: 
  485: 
  486: def get_xlim(lines: Iterable[Line2D]) -> tuple[float, float]:
  487:     left, right = np.inf, -np.inf
  488:     for line in lines:
  489:         x = line.get_xdata(orig=False)
  490:         left = min(np.nanmin(x), left)
  491:         right = max(np.nanmax(x), right)
  492:     return left, right
