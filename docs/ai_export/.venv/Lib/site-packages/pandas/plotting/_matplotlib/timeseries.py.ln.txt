    1: # TODO: Use the fact that axis can have units to simplify the process
    2: 
    3: from __future__ import annotations
    4: 
    5: import functools
    6: from typing import (
    7:     TYPE_CHECKING,
    8:     Any,
    9:     cast,
   10: )
   11: import warnings
   12: 
   13: import numpy as np
   14: 
   15: from pandas._libs.tslibs import (
   16:     BaseOffset,
   17:     Period,
   18:     to_offset,
   19: )
   20: from pandas._libs.tslibs.dtypes import (
   21:     OFFSET_TO_PERIOD_FREQSTR,
   22:     FreqGroup,
   23: )
   24: 
   25: from pandas.core.dtypes.generic import (
   26:     ABCDatetimeIndex,
   27:     ABCPeriodIndex,
   28:     ABCTimedeltaIndex,
   29: )
   30: 
   31: from pandas.io.formats.printing import pprint_thing
   32: from pandas.plotting._matplotlib.converter import (
   33:     TimeSeries_DateFormatter,
   34:     TimeSeries_DateLocator,
   35:     TimeSeries_TimedeltaFormatter,
   36: )
   37: from pandas.tseries.frequencies import (
   38:     get_period_alias,
   39:     is_subperiod,
   40:     is_superperiod,
   41: )
   42: 
   43: if TYPE_CHECKING:
   44:     from datetime import timedelta
   45: 
   46:     from matplotlib.axes import Axes
   47: 
   48:     from pandas._typing import NDFrameT
   49: 
   50:     from pandas import (
   51:         DataFrame,
   52:         DatetimeIndex,
   53:         Index,
   54:         PeriodIndex,
   55:         Series,
   56:     )
   57: 
   58: # ---------------------------------------------------------------------
   59: # Plotting functions and monkey patches
   60: 
   61: 
   62: def maybe_resample(series: Series, ax: Axes, kwargs: dict[str, Any]):
   63:     # resample against axes freq if necessary
   64: 
   65:     if "how" in kwargs:
   66:         raise ValueError(
   67:             "'how' is not a valid keyword for plotting functions. If plotting "
   68:             "multiple objects on shared axes, resample manually first."
   69:         )
   70: 
   71:     freq, ax_freq = _get_freq(ax, series)
   72: 
   73:     if freq is None:  # pragma: no cover
   74:         raise ValueError("Cannot use dynamic axis without frequency info")
   75: 
   76:     # Convert DatetimeIndex to PeriodIndex
   77:     if isinstance(series.index, ABCDatetimeIndex):
   78:         series = series.to_period(freq=freq)
   79: 
   80:     if ax_freq is not None and freq != ax_freq:
   81:         if is_superperiod(freq, ax_freq):  # upsample input
   82:             series = series.copy()
   83:             # error: "Index" has no attribute "asfreq"
   84:             series.index = series.index.asfreq(  # type: ignore[attr-defined]
   85:                 ax_freq, how="s"
   86:             )
   87:             freq = ax_freq
   88:         elif _is_sup(freq, ax_freq):  # one is weekly
   89:             # Resampling with PeriodDtype is deprecated, so we convert to
   90:             #  DatetimeIndex, resample, then convert back.
   91:             ser_ts = series.to_timestamp()
   92:             ser_d = ser_ts.resample("D").last().dropna()
   93:             ser_freq = ser_d.resample(ax_freq).last().dropna()
   94:             series = ser_freq.to_period(ax_freq)
   95:             freq = ax_freq
   96:         elif is_subperiod(freq, ax_freq) or _is_sub(freq, ax_freq):
   97:             _upsample_others(ax, freq, kwargs)
   98:         else:  # pragma: no cover
   99:             raise ValueError("Incompatible frequency conversion")
  100:     return freq, series
  101: 
  102: 
  103: def _is_sub(f1: str, f2: str) -> bool:
  104:     return (f1.startswith("W") and is_subperiod("D", f2)) or (
  105:         f2.startswith("W") and is_subperiod(f1, "D")
  106:     )
  107: 
  108: 
  109: def _is_sup(f1: str, f2: str) -> bool:
  110:     return (f1.startswith("W") and is_superperiod("D", f2)) or (
  111:         f2.startswith("W") and is_superperiod(f1, "D")
  112:     )
  113: 
  114: 
  115: def _upsample_others(ax: Axes, freq: BaseOffset, kwargs: dict[str, Any]) -> None:
  116:     legend = ax.get_legend()
  117:     lines, labels = _replot_ax(ax, freq)
  118:     _replot_ax(ax, freq)
  119: 
  120:     other_ax = None
  121:     if hasattr(ax, "left_ax"):
  122:         other_ax = ax.left_ax
  123:     if hasattr(ax, "right_ax"):
  124:         other_ax = ax.right_ax
  125: 
  126:     if other_ax is not None:
  127:         rlines, rlabels = _replot_ax(other_ax, freq)
  128:         lines.extend(rlines)
  129:         labels.extend(rlabels)
  130: 
  131:     if legend is not None and kwargs.get("legend", True) and len(lines) > 0:
  132:         title: str | None = legend.get_title().get_text()
  133:         if title == "None":
  134:             title = None
  135:         ax.legend(lines, labels, loc="best", title=title)
  136: 
  137: 
  138: def _replot_ax(ax: Axes, freq: BaseOffset):
  139:     data = getattr(ax, "_plot_data", None)
  140: 
  141:     # clear current axes and data
  142:     # TODO #54485
  143:     ax._plot_data = []  # type: ignore[attr-defined]
  144:     ax.clear()
  145: 
  146:     decorate_axes(ax, freq)
  147: 
  148:     lines = []
  149:     labels = []
  150:     if data is not None:
  151:         for series, plotf, kwds in data:
  152:             series = series.copy()
  153:             idx = series.index.asfreq(freq, how="S")
  154:             series.index = idx
  155:             # TODO #54485
  156:             ax._plot_data.append((series, plotf, kwds))  # type: ignore[attr-defined]
  157: 
  158:             # for tsplot
  159:             if isinstance(plotf, str):
  160:                 from pandas.plotting._matplotlib import PLOT_CLASSES
  161: 
  162:                 plotf = PLOT_CLASSES[plotf]._plot
  163: 
  164:             lines.append(plotf(ax, series.index._mpl_repr(), series.values, **kwds)[0])
  165:             labels.append(pprint_thing(series.name))
  166: 
  167:     return lines, labels
  168: 
  169: 
  170: def decorate_axes(ax: Axes, freq: BaseOffset) -> None:
  171:     """Initialize axes for time-series plotting"""
  172:     if not hasattr(ax, "_plot_data"):
  173:         # TODO #54485
  174:         ax._plot_data = []  # type: ignore[attr-defined]
  175: 
  176:     # TODO #54485
  177:     ax.freq = freq  # type: ignore[attr-defined]
  178:     xaxis = ax.get_xaxis()
  179:     # TODO #54485
  180:     xaxis.freq = freq  # type: ignore[attr-defined]
  181: 
  182: 
  183: def _get_ax_freq(ax: Axes):
  184:     """
  185:     Get the freq attribute of the ax object if set.
  186:     Also checks shared axes (eg when using secondary yaxis, sharex=True
  187:     or twinx)
  188:     """
  189:     ax_freq = getattr(ax, "freq", None)
  190:     if ax_freq is None:
  191:         # check for left/right ax in case of secondary yaxis
  192:         if hasattr(ax, "left_ax"):
  193:             ax_freq = getattr(ax.left_ax, "freq", None)
  194:         elif hasattr(ax, "right_ax"):
  195:             ax_freq = getattr(ax.right_ax, "freq", None)
  196:     if ax_freq is None:
  197:         # check if a shared ax (sharex/twinx) has already freq set
  198:         shared_axes = ax.get_shared_x_axes().get_siblings(ax)
  199:         if len(shared_axes) > 1:
  200:             for shared_ax in shared_axes:
  201:                 ax_freq = getattr(shared_ax, "freq", None)
  202:                 if ax_freq is not None:
  203:                     break
  204:     return ax_freq
  205: 
  206: 
  207: def _get_period_alias(freq: timedelta | BaseOffset | str) -> str | None:
  208:     if isinstance(freq, BaseOffset):
  209:         freqstr = freq.name
  210:     else:
  211:         freqstr = to_offset(freq, is_period=True).rule_code
  212: 
  213:     return get_period_alias(freqstr)
  214: 
  215: 
  216: def _get_freq(ax: Axes, series: Series):
  217:     # get frequency from data
  218:     freq = getattr(series.index, "freq", None)
  219:     if freq is None:
  220:         freq = getattr(series.index, "inferred_freq", None)
  221:         freq = to_offset(freq, is_period=True)
  222: 
  223:     ax_freq = _get_ax_freq(ax)
  224: 
  225:     # use axes freq if no data freq
  226:     if freq is None:
  227:         freq = ax_freq
  228: 
  229:     # get the period frequency
  230:     freq = _get_period_alias(freq)
  231:     return freq, ax_freq
  232: 
  233: 
  234: def use_dynamic_x(ax: Axes, data: DataFrame | Series) -> bool:
  235:     freq = _get_index_freq(data.index)
  236:     ax_freq = _get_ax_freq(ax)
  237: 
  238:     if freq is None:  # convert irregular if axes has freq info
  239:         freq = ax_freq
  240:     # do not use tsplot if irregular was plotted first
  241:     elif (ax_freq is None) and (len(ax.get_lines()) > 0):
  242:         return False
  243: 
  244:     if freq is None:
  245:         return False
  246: 
  247:     freq_str = _get_period_alias(freq)
  248: 
  249:     if freq_str is None:
  250:         return False
  251: 
  252:     # FIXME: hack this for 0.10.1, creating more technical debt...sigh
  253:     if isinstance(data.index, ABCDatetimeIndex):
  254:         # error: "BaseOffset" has no attribute "_period_dtype_code"
  255:         freq_str = OFFSET_TO_PERIOD_FREQSTR.get(freq_str, freq_str)
  256:         base = to_offset(
  257:             freq_str, is_period=True
  258:         )._period_dtype_code  # type: ignore[attr-defined]
  259:         x = data.index
  260:         if base <= FreqGroup.FR_DAY.value:
  261:             return x[:1].is_normalized
  262:         period = Period(x[0], freq_str)
  263:         assert isinstance(period, Period)
  264:         return period.to_timestamp().tz_localize(x.tz) == x[0]
  265:     return True
  266: 
  267: 
  268: def _get_index_freq(index: Index) -> BaseOffset | None:
  269:     freq = getattr(index, "freq", None)
  270:     if freq is None:
  271:         freq = getattr(index, "inferred_freq", None)
  272:         if freq == "B":
  273:             # error: "Index" has no attribute "dayofweek"
  274:             weekdays = np.unique(index.dayofweek)  # type: ignore[attr-defined]
  275:             if (5 in weekdays) or (6 in weekdays):
  276:                 freq = None
  277: 
  278:     freq = to_offset(freq)
  279:     return freq
  280: 
  281: 
  282: def maybe_convert_index(ax: Axes, data: NDFrameT) -> NDFrameT:
  283:     # tsplot converts automatically, but don't want to convert index
  284:     # over and over for DataFrames
  285:     if isinstance(data.index, (ABCDatetimeIndex, ABCPeriodIndex)):
  286:         freq: str | BaseOffset | None = data.index.freq
  287: 
  288:         if freq is None:
  289:             # We only get here for DatetimeIndex
  290:             data.index = cast("DatetimeIndex", data.index)
  291:             freq = data.index.inferred_freq
  292:             freq = to_offset(freq)
  293: 
  294:         if freq is None:
  295:             freq = _get_ax_freq(ax)
  296: 
  297:         if freq is None:
  298:             raise ValueError("Could not get frequency alias for plotting")
  299: 
  300:         freq_str = _get_period_alias(freq)
  301: 
  302:         with warnings.catch_warnings():
  303:             # suppress Period[B] deprecation warning
  304:             # TODO: need to find an alternative to this before the deprecation
  305:             #  is enforced!
  306:             warnings.filterwarnings(
  307:                 "ignore",
  308:                 r"PeriodDtype\[B\] is deprecated",
  309:                 category=FutureWarning,
  310:             )
  311: 
  312:             if isinstance(data.index, ABCDatetimeIndex):
  313:                 data = data.tz_localize(None).to_period(freq=freq_str)
  314:             elif isinstance(data.index, ABCPeriodIndex):
  315:                 data.index = data.index.asfreq(freq=freq_str)
  316:     return data
  317: 
  318: 
  319: # Patch methods for subplot.
  320: 
  321: 
  322: def _format_coord(freq, t, y) -> str:
  323:     time_period = Period(ordinal=int(t), freq=freq)
  324:     return f"t = {time_period}  y = {y:8f}"
  325: 
  326: 
  327: def format_dateaxis(
  328:     subplot, freq: BaseOffset, index: DatetimeIndex | PeriodIndex
  329: ) -> None:
  330:     """
  331:     Pretty-formats the date axis (x-axis).
  332: 
  333:     Major and minor ticks are automatically set for the frequency of the
  334:     current underlying series.  As the dynamic mode is activated by
  335:     default, changing the limits of the x axis will intelligently change
  336:     the positions of the ticks.
  337:     """
  338:     from matplotlib import pylab
  339: 
  340:     # handle index specific formatting
  341:     # Note: DatetimeIndex does not use this
  342:     # interface. DatetimeIndex uses matplotlib.date directly
  343:     if isinstance(index, ABCPeriodIndex):
  344:         majlocator = TimeSeries_DateLocator(
  345:             freq, dynamic_mode=True, minor_locator=False, plot_obj=subplot
  346:         )
  347:         minlocator = TimeSeries_DateLocator(
  348:             freq, dynamic_mode=True, minor_locator=True, plot_obj=subplot
  349:         )
  350:         subplot.xaxis.set_major_locator(majlocator)
  351:         subplot.xaxis.set_minor_locator(minlocator)
  352: 
  353:         majformatter = TimeSeries_DateFormatter(
  354:             freq, dynamic_mode=True, minor_locator=False, plot_obj=subplot
  355:         )
  356:         minformatter = TimeSeries_DateFormatter(
  357:             freq, dynamic_mode=True, minor_locator=True, plot_obj=subplot
  358:         )
  359:         subplot.xaxis.set_major_formatter(majformatter)
  360:         subplot.xaxis.set_minor_formatter(minformatter)
  361: 
  362:         # x and y coord info
  363:         subplot.format_coord = functools.partial(_format_coord, freq)
  364: 
  365:     elif isinstance(index, ABCTimedeltaIndex):
  366:         subplot.xaxis.set_major_formatter(TimeSeries_TimedeltaFormatter())
  367:     else:
  368:         raise TypeError("index type not supported")
  369: 
  370:     pylab.draw_if_interactive()
