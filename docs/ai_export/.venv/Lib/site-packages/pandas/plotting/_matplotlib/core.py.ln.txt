    1: from __future__ import annotations
    2: 
    3: from abc import (
    4:     ABC,
    5:     abstractmethod,
    6: )
    7: from collections.abc import (
    8:     Hashable,
    9:     Iterable,
   10:     Iterator,
   11:     Sequence,
   12: )
   13: from typing import (
   14:     TYPE_CHECKING,
   15:     Any,
   16:     Literal,
   17:     cast,
   18:     final,
   19: )
   20: import warnings
   21: 
   22: import matplotlib as mpl
   23: import numpy as np
   24: 
   25: from pandas._libs import lib
   26: from pandas.errors import AbstractMethodError
   27: from pandas.util._decorators import cache_readonly
   28: from pandas.util._exceptions import find_stack_level
   29: 
   30: from pandas.core.dtypes.common import (
   31:     is_any_real_numeric_dtype,
   32:     is_bool,
   33:     is_float,
   34:     is_float_dtype,
   35:     is_hashable,
   36:     is_integer,
   37:     is_integer_dtype,
   38:     is_iterator,
   39:     is_list_like,
   40:     is_number,
   41:     is_numeric_dtype,
   42: )
   43: from pandas.core.dtypes.dtypes import (
   44:     CategoricalDtype,
   45:     ExtensionDtype,
   46: )
   47: from pandas.core.dtypes.generic import (
   48:     ABCDataFrame,
   49:     ABCDatetimeIndex,
   50:     ABCIndex,
   51:     ABCMultiIndex,
   52:     ABCPeriodIndex,
   53:     ABCSeries,
   54: )
   55: from pandas.core.dtypes.missing import isna
   56: 
   57: import pandas.core.common as com
   58: from pandas.core.frame import DataFrame
   59: from pandas.util.version import Version
   60: 
   61: from pandas.io.formats.printing import pprint_thing
   62: from pandas.plotting._matplotlib import tools
   63: from pandas.plotting._matplotlib.converter import register_pandas_matplotlib_converters
   64: from pandas.plotting._matplotlib.groupby import reconstruct_data_with_by
   65: from pandas.plotting._matplotlib.misc import unpack_single_str_list
   66: from pandas.plotting._matplotlib.style import get_standard_colors
   67: from pandas.plotting._matplotlib.timeseries import (
   68:     decorate_axes,
   69:     format_dateaxis,
   70:     maybe_convert_index,
   71:     maybe_resample,
   72:     use_dynamic_x,
   73: )
   74: from pandas.plotting._matplotlib.tools import (
   75:     create_subplots,
   76:     flatten_axes,
   77:     format_date_labels,
   78:     get_all_lines,
   79:     get_xlim,
   80:     handle_shared_axes,
   81: )
   82: 
   83: if TYPE_CHECKING:
   84:     from matplotlib.artist import Artist
   85:     from matplotlib.axes import Axes
   86:     from matplotlib.axis import Axis
   87:     from matplotlib.figure import Figure
   88: 
   89:     from pandas._typing import (
   90:         IndexLabel,
   91:         NDFrameT,
   92:         PlottingOrientation,
   93:         npt,
   94:     )
   95: 
   96:     from pandas import Series
   97: 
   98: 
   99: def _color_in_style(style: str) -> bool:
  100:     """
  101:     Check if there is a color letter in the style string.
  102:     """
  103:     from matplotlib.colors import BASE_COLORS
  104: 
  105:     return not set(BASE_COLORS).isdisjoint(style)
  106: 
  107: 
  108: class MPLPlot(ABC):
  109:     """
  110:     Base class for assembling a pandas plot using matplotlib
  111: 
  112:     Parameters
  113:     ----------
  114:     data :
  115: 
  116:     """
  117: 
  118:     @property
  119:     @abstractmethod
  120:     def _kind(self) -> str:
  121:         """Specify kind str. Must be overridden in child class"""
  122:         raise NotImplementedError
  123: 
  124:     _layout_type = "vertical"
  125:     _default_rot = 0
  126: 
  127:     @property
  128:     def orientation(self) -> str | None:
  129:         return None
  130: 
  131:     data: DataFrame
  132: 
  133:     def __init__(
  134:         self,
  135:         data,
  136:         kind=None,
  137:         by: IndexLabel | None = None,
  138:         subplots: bool | Sequence[Sequence[str]] = False,
  139:         sharex: bool | None = None,
  140:         sharey: bool = False,
  141:         use_index: bool = True,
  142:         figsize: tuple[float, float] | None = None,
  143:         grid=None,
  144:         legend: bool | str = True,
  145:         rot=None,
  146:         ax=None,
  147:         fig=None,
  148:         title=None,
  149:         xlim=None,
  150:         ylim=None,
  151:         xticks=None,
  152:         yticks=None,
  153:         xlabel: Hashable | None = None,
  154:         ylabel: Hashable | None = None,
  155:         fontsize: int | None = None,
  156:         secondary_y: bool | tuple | list | np.ndarray = False,
  157:         colormap=None,
  158:         table: bool = False,
  159:         layout=None,
  160:         include_bool: bool = False,
  161:         column: IndexLabel | None = None,
  162:         *,
  163:         logx: bool | None | Literal["sym"] = False,
  164:         logy: bool | None | Literal["sym"] = False,
  165:         loglog: bool | None | Literal["sym"] = False,
  166:         mark_right: bool = True,
  167:         stacked: bool = False,
  168:         label: Hashable | None = None,
  169:         style=None,
  170:         **kwds,
  171:     ) -> None:
  172:         import matplotlib.pyplot as plt
  173: 
  174:         # if users assign an empty list or tuple, raise `ValueError`
  175:         # similar to current `df.box` and `df.hist` APIs.
  176:         if by in ([], ()):
  177:             raise ValueError("No group keys passed!")
  178:         self.by = com.maybe_make_list(by)
  179: 
  180:         # Assign the rest of columns into self.columns if by is explicitly defined
  181:         # while column is not, only need `columns` in hist/box plot when it's DF
  182:         # TODO: Might deprecate `column` argument in future PR (#28373)
  183:         if isinstance(data, DataFrame):
  184:             if column:
  185:                 self.columns = com.maybe_make_list(column)
  186:             elif self.by is None:
  187:                 self.columns = [
  188:                     col for col in data.columns if is_numeric_dtype(data[col])
  189:                 ]
  190:             else:
  191:                 self.columns = [
  192:                     col
  193:                     for col in data.columns
  194:                     if col not in self.by and is_numeric_dtype(data[col])
  195:                 ]
  196: 
  197:         # For `hist` plot, need to get grouped original data before `self.data` is
  198:         # updated later
  199:         if self.by is not None and self._kind == "hist":
  200:             self._grouped = data.groupby(unpack_single_str_list(self.by))
  201: 
  202:         self.kind = kind
  203: 
  204:         self.subplots = type(self)._validate_subplots_kwarg(
  205:             subplots, data, kind=self._kind
  206:         )
  207: 
  208:         self.sharex = type(self)._validate_sharex(sharex, ax, by)
  209:         self.sharey = sharey
  210:         self.figsize = figsize
  211:         self.layout = layout
  212: 
  213:         self.xticks = xticks
  214:         self.yticks = yticks
  215:         self.xlim = xlim
  216:         self.ylim = ylim
  217:         self.title = title
  218:         self.use_index = use_index
  219:         self.xlabel = xlabel
  220:         self.ylabel = ylabel
  221: 
  222:         self.fontsize = fontsize
  223: 
  224:         if rot is not None:
  225:             self.rot = rot
  226:             # need to know for format_date_labels since it's rotated to 30 by
  227:             # default
  228:             self._rot_set = True
  229:         else:
  230:             self._rot_set = False
  231:             self.rot = self._default_rot
  232: 
  233:         if grid is None:
  234:             grid = False if secondary_y else plt.rcParams["axes.grid"]
  235: 
  236:         self.grid = grid
  237:         self.legend = legend
  238:         self.legend_handles: list[Artist] = []
  239:         self.legend_labels: list[Hashable] = []
  240: 
  241:         self.logx = type(self)._validate_log_kwd("logx", logx)
  242:         self.logy = type(self)._validate_log_kwd("logy", logy)
  243:         self.loglog = type(self)._validate_log_kwd("loglog", loglog)
  244:         self.label = label
  245:         self.style = style
  246:         self.mark_right = mark_right
  247:         self.stacked = stacked
  248: 
  249:         # ax may be an Axes object or (if self.subplots) an ndarray of
  250:         #  Axes objects
  251:         self.ax = ax
  252:         # TODO: deprecate fig keyword as it is ignored, not passed in tests
  253:         #  as of 2023-11-05
  254: 
  255:         # parse errorbar input if given
  256:         xerr = kwds.pop("xerr", None)
  257:         yerr = kwds.pop("yerr", None)
  258:         nseries = self._get_nseries(data)
  259:         xerr, data = type(self)._parse_errorbars("xerr", xerr, data, nseries)
  260:         yerr, data = type(self)._parse_errorbars("yerr", yerr, data, nseries)
  261:         self.errors = {"xerr": xerr, "yerr": yerr}
  262:         self.data = data
  263: 
  264:         if not isinstance(secondary_y, (bool, tuple, list, np.ndarray, ABCIndex)):
  265:             secondary_y = [secondary_y]
  266:         self.secondary_y = secondary_y
  267: 
  268:         # ugly TypeError if user passes matplotlib's `cmap` name.
  269:         # Probably better to accept either.
  270:         if "cmap" in kwds and colormap:
  271:             raise TypeError("Only specify one of `cmap` and `colormap`.")
  272:         if "cmap" in kwds:
  273:             self.colormap = kwds.pop("cmap")
  274:         else:
  275:             self.colormap = colormap
  276: 
  277:         self.table = table
  278:         self.include_bool = include_bool
  279: 
  280:         self.kwds = kwds
  281: 
  282:         color = kwds.pop("color", lib.no_default)
  283:         self.color = self._validate_color_args(color, self.colormap)
  284:         assert "color" not in self.kwds
  285: 
  286:         self.data = self._ensure_frame(self.data)
  287: 
  288:     @final
  289:     @staticmethod
  290:     def _validate_sharex(sharex: bool | None, ax, by) -> bool:
  291:         if sharex is None:
  292:             # if by is defined, subplots are used and sharex should be False
  293:             if ax is None and by is None:  # pylint: disable=simplifiable-if-statement
  294:                 sharex = True
  295:             else:
  296:                 # if we get an axis, the users should do the visibility
  297:                 # setting...
  298:                 sharex = False
  299:         elif not is_bool(sharex):
  300:             raise TypeError("sharex must be a bool or None")
  301:         return bool(sharex)
  302: 
  303:     @classmethod
  304:     def _validate_log_kwd(
  305:         cls,
  306:         kwd: str,
  307:         value: bool | None | Literal["sym"],
  308:     ) -> bool | None | Literal["sym"]:
  309:         if (
  310:             value is None
  311:             or isinstance(value, bool)
  312:             or (isinstance(value, str) and value == "sym")
  313:         ):
  314:             return value
  315:         raise ValueError(
  316:             f"keyword '{kwd}' should be bool, None, or 'sym', not '{value}'"
  317:         )
  318: 
  319:     @final
  320:     @staticmethod
  321:     def _validate_subplots_kwarg(
  322:         subplots: bool | Sequence[Sequence[str]], data: Series | DataFrame, kind: str
  323:     ) -> bool | list[tuple[int, ...]]:
  324:         """
  325:         Validate the subplots parameter
  326: 
  327:         - check type and content
  328:         - check for duplicate columns
  329:         - check for invalid column names
  330:         - convert column names into indices
  331:         - add missing columns in a group of their own
  332:         See comments in code below for more details.
  333: 
  334:         Parameters
  335:         ----------
  336:         subplots : subplots parameters as passed to PlotAccessor
  337: 
  338:         Returns
  339:         -------
  340:         validated subplots : a bool or a list of tuples of column indices. Columns
  341:         in the same tuple will be grouped together in the resulting plot.
  342:         """
  343: 
  344:         if isinstance(subplots, bool):
  345:             return subplots
  346:         elif not isinstance(subplots, Iterable):
  347:             raise ValueError("subplots should be a bool or an iterable")
  348: 
  349:         supported_kinds = (
  350:             "line",
  351:             "bar",
  352:             "barh",
  353:             "hist",
  354:             "kde",
  355:             "density",
  356:             "area",
  357:             "pie",
  358:         )
  359:         if kind not in supported_kinds:
  360:             raise ValueError(
  361:                 "When subplots is an iterable, kind must be "
  362:                 f"one of {', '.join(supported_kinds)}. Got {kind}."
  363:             )
  364: 
  365:         if isinstance(data, ABCSeries):
  366:             raise NotImplementedError(
  367:                 "An iterable subplots for a Series is not supported."
  368:             )
  369: 
  370:         columns = data.columns
  371:         if isinstance(columns, ABCMultiIndex):
  372:             raise NotImplementedError(
  373:                 "An iterable subplots for a DataFrame with a MultiIndex column "
  374:                 "is not supported."
  375:             )
  376: 
  377:         if columns.nunique() != len(columns):
  378:             raise NotImplementedError(
  379:                 "An iterable subplots for a DataFrame with non-unique column "
  380:                 "labels is not supported."
  381:             )
  382: 
  383:         # subplots is a list of tuples where each tuple is a group of
  384:         # columns to be grouped together (one ax per group).
  385:         # we consolidate the subplots list such that:
  386:         # - the tuples contain indices instead of column names
  387:         # - the columns that aren't yet in the list are added in a group
  388:         #   of their own.
  389:         # For example with columns from a to g, and
  390:         # subplots = [(a, c), (b, f, e)],
  391:         # we end up with [(ai, ci), (bi, fi, ei), (di,), (gi,)]
  392:         # This way, we can handle self.subplots in a homogeneous manner
  393:         # later.
  394:         # TODO: also accept indices instead of just names?
  395: 
  396:         out = []
  397:         seen_columns: set[Hashable] = set()
  398:         for group in subplots:
  399:             if not is_list_like(group):
  400:                 raise ValueError(
  401:                     "When subplots is an iterable, each entry "
  402:                     "should be a list/tuple of column names."
  403:                 )
  404:             idx_locs = columns.get_indexer_for(group)
  405:             if (idx_locs == -1).any():
  406:                 bad_labels = np.extract(idx_locs == -1, group)
  407:                 raise ValueError(
  408:                     f"Column label(s) {list(bad_labels)} not found in the DataFrame."
  409:                 )
  410:             unique_columns = set(group)
  411:             duplicates = seen_columns.intersection(unique_columns)
  412:             if duplicates:
  413:                 raise ValueError(
  414:                     "Each column should be in only one subplot. "
  415:                     f"Columns {duplicates} were found in multiple subplots."
  416:                 )
  417:             seen_columns = seen_columns.union(unique_columns)
  418:             out.append(tuple(idx_locs))
  419: 
  420:         unseen_columns = columns.difference(seen_columns)
  421:         for column in unseen_columns:
  422:             idx_loc = columns.get_loc(column)
  423:             out.append((idx_loc,))
  424:         return out
  425: 
  426:     def _validate_color_args(self, color, colormap):
  427:         if color is lib.no_default:
  428:             # It was not provided by the user
  429:             if "colors" in self.kwds and colormap is not None:
  430:                 warnings.warn(
  431:                     "'color' and 'colormap' cannot be used simultaneously. "
  432:                     "Using 'color'",
  433:                     stacklevel=find_stack_level(),
  434:                 )
  435:             return None
  436:         if self.nseries == 1 and color is not None and not is_list_like(color):
  437:             # support series.plot(color='green')
  438:             color = [color]
  439: 
  440:         if isinstance(color, tuple) and self.nseries == 1 and len(color) in (3, 4):
  441:             # support RGB and RGBA tuples in series plot
  442:             color = [color]
  443: 
  444:         if colormap is not None:
  445:             warnings.warn(
  446:                 "'color' and 'colormap' cannot be used simultaneously. Using 'color'",
  447:                 stacklevel=find_stack_level(),
  448:             )
  449: 
  450:         if self.style is not None:
  451:             if is_list_like(self.style):
  452:                 styles = self.style
  453:             else:
  454:                 styles = [self.style]
  455:             # need only a single match
  456:             for s in styles:
  457:                 if _color_in_style(s):
  458:                     raise ValueError(
  459:                         "Cannot pass 'style' string with a color symbol and "
  460:                         "'color' keyword argument. Please use one or the "
  461:                         "other or pass 'style' without a color symbol"
  462:                     )
  463:         return color
  464: 
  465:     @final
  466:     @staticmethod
  467:     def _iter_data(
  468:         data: DataFrame | dict[Hashable, Series | DataFrame]
  469:     ) -> Iterator[tuple[Hashable, np.ndarray]]:
  470:         for col, values in data.items():
  471:             # This was originally written to use values.values before EAs
  472:             #  were implemented; adding np.asarray(...) to keep consistent
  473:             #  typing.
  474:             yield col, np.asarray(values.values)
  475: 
  476:     def _get_nseries(self, data: Series | DataFrame) -> int:
  477:         # When `by` is explicitly assigned, grouped data size will be defined, and
  478:         # this will determine number of subplots to have, aka `self.nseries`
  479:         if data.ndim == 1:
  480:             return 1
  481:         elif self.by is not None and self._kind == "hist":
  482:             return len(self._grouped)
  483:         elif self.by is not None and self._kind == "box":
  484:             return len(self.columns)
  485:         else:
  486:             return data.shape[1]
  487: 
  488:     @final
  489:     @property
  490:     def nseries(self) -> int:
  491:         return self._get_nseries(self.data)
  492: 
  493:     @final
  494:     def draw(self) -> None:
  495:         self.plt.draw_if_interactive()
  496: 
  497:     @final
  498:     def generate(self) -> None:
  499:         self._compute_plot_data()
  500:         fig = self.fig
  501:         self._make_plot(fig)
  502:         self._add_table()
  503:         self._make_legend()
  504:         self._adorn_subplots(fig)
  505: 
  506:         for ax in self.axes:
  507:             self._post_plot_logic_common(ax)
  508:             self._post_plot_logic(ax, self.data)
  509: 
  510:     @final
  511:     @staticmethod
  512:     def _has_plotted_object(ax: Axes) -> bool:
  513:         """check whether ax has data"""
  514:         return len(ax.lines) != 0 or len(ax.artists) != 0 or len(ax.containers) != 0
  515: 
  516:     @final
  517:     def _maybe_right_yaxis(self, ax: Axes, axes_num: int) -> Axes:
  518:         if not self.on_right(axes_num):
  519:             # secondary axes may be passed via ax kw
  520:             return self._get_ax_layer(ax)
  521: 
  522:         if hasattr(ax, "right_ax"):
  523:             # if it has right_ax property, ``ax`` must be left axes
  524:             return ax.right_ax
  525:         elif hasattr(ax, "left_ax"):
  526:             # if it has left_ax property, ``ax`` must be right axes
  527:             return ax
  528:         else:
  529:             # otherwise, create twin axes
  530:             orig_ax, new_ax = ax, ax.twinx()
  531:             # TODO: use Matplotlib public API when available
  532:             new_ax._get_lines = orig_ax._get_lines  # type: ignore[attr-defined]
  533:             # TODO #54485
  534:             new_ax._get_patches_for_fill = (  # type: ignore[attr-defined]
  535:                 orig_ax._get_patches_for_fill  # type: ignore[attr-defined]
  536:             )
  537:             # TODO #54485
  538:             orig_ax.right_ax, new_ax.left_ax = (  # type: ignore[attr-defined]
  539:                 new_ax,
  540:                 orig_ax,
  541:             )
  542: 
  543:             if not self._has_plotted_object(orig_ax):  # no data on left y
  544:                 orig_ax.get_yaxis().set_visible(False)
  545: 
  546:             if self.logy is True or self.loglog is True:
  547:                 new_ax.set_yscale("log")
  548:             elif self.logy == "sym" or self.loglog == "sym":
  549:                 new_ax.set_yscale("symlog")
  550:             return new_ax  # type: ignore[return-value]
  551: 
  552:     @final
  553:     @cache_readonly
  554:     def fig(self) -> Figure:
  555:         return self._axes_and_fig[1]
  556: 
  557:     @final
  558:     @cache_readonly
  559:     # TODO: can we annotate this as both a Sequence[Axes] and ndarray[object]?
  560:     def axes(self) -> Sequence[Axes]:
  561:         return self._axes_and_fig[0]
  562: 
  563:     @final
  564:     @cache_readonly
  565:     def _axes_and_fig(self) -> tuple[Sequence[Axes], Figure]:
  566:         if self.subplots:
  567:             naxes = (
  568:                 self.nseries if isinstance(self.subplots, bool) else len(self.subplots)
  569:             )
  570:             fig, axes = create_subplots(
  571:                 naxes=naxes,
  572:                 sharex=self.sharex,
  573:                 sharey=self.sharey,
  574:                 figsize=self.figsize,
  575:                 ax=self.ax,
  576:                 layout=self.layout,
  577:                 layout_type=self._layout_type,
  578:             )
  579:         elif self.ax is None:
  580:             fig = self.plt.figure(figsize=self.figsize)
  581:             axes = fig.add_subplot(111)
  582:         else:
  583:             fig = self.ax.get_figure()
  584:             if self.figsize is not None:
  585:                 fig.set_size_inches(self.figsize)
  586:             axes = self.ax
  587: 
  588:         axes = flatten_axes(axes)
  589: 
  590:         if self.logx is True or self.loglog is True:
  591:             [a.set_xscale("log") for a in axes]
  592:         elif self.logx == "sym" or self.loglog == "sym":
  593:             [a.set_xscale("symlog") for a in axes]
  594: 
  595:         if self.logy is True or self.loglog is True:
  596:             [a.set_yscale("log") for a in axes]
  597:         elif self.logy == "sym" or self.loglog == "sym":
  598:             [a.set_yscale("symlog") for a in axes]
  599: 
  600:         axes_seq = cast(Sequence["Axes"], axes)
  601:         return axes_seq, fig
  602: 
  603:     @property
  604:     def result(self):
  605:         """
  606:         Return result axes
  607:         """
  608:         if self.subplots:
  609:             if self.layout is not None and not is_list_like(self.ax):
  610:                 # error: "Sequence[Any]" has no attribute "reshape"
  611:                 return self.axes.reshape(*self.layout)  # type: ignore[attr-defined]
  612:             else:
  613:                 return self.axes
  614:         else:
  615:             sec_true = isinstance(self.secondary_y, bool) and self.secondary_y
  616:             # error: Argument 1 to "len" has incompatible type "Union[bool,
  617:             # Tuple[Any, ...], List[Any], ndarray[Any, Any]]"; expected "Sized"
  618:             all_sec = (
  619:                 is_list_like(self.secondary_y)
  620:                 and len(self.secondary_y) == self.nseries  # type: ignore[arg-type]
  621:             )
  622:             if sec_true or all_sec:
  623:                 # if all data is plotted on secondary, return right axes
  624:                 return self._get_ax_layer(self.axes[0], primary=False)
  625:             else:
  626:                 return self.axes[0]
  627: 
  628:     @final
  629:     @staticmethod
  630:     def _convert_to_ndarray(data):
  631:         # GH31357: categorical columns are processed separately
  632:         if isinstance(data.dtype, CategoricalDtype):
  633:             return data
  634: 
  635:         # GH32073: cast to float if values contain nulled integers
  636:         if (is_integer_dtype(data.dtype) or is_float_dtype(data.dtype)) and isinstance(
  637:             data.dtype, ExtensionDtype
  638:         ):
  639:             return data.to_numpy(dtype="float", na_value=np.nan)
  640: 
  641:         # GH25587: cast ExtensionArray of pandas (IntegerArray, etc.) to
  642:         # np.ndarray before plot.
  643:         if len(data) > 0:
  644:             return np.asarray(data)
  645: 
  646:         return data
  647: 
  648:     @final
  649:     def _ensure_frame(self, data) -> DataFrame:
  650:         if isinstance(data, ABCSeries):
  651:             label = self.label
  652:             if label is None and data.name is None:
  653:                 label = ""
  654:             if label is None:
  655:                 # We'll end up with columns of [0] instead of [None]
  656:                 data = data.to_frame()
  657:             else:
  658:                 data = data.to_frame(name=label)
  659:         elif self._kind in ("hist", "box"):
  660:             cols = self.columns if self.by is None else self.columns + self.by
  661:             data = data.loc[:, cols]
  662:         return data
  663: 
  664:     @final
  665:     def _compute_plot_data(self) -> None:
  666:         data = self.data
  667: 
  668:         # GH15079 reconstruct data if by is defined
  669:         if self.by is not None:
  670:             self.subplots = True
  671:             data = reconstruct_data_with_by(self.data, by=self.by, cols=self.columns)
  672: 
  673:         # GH16953, infer_objects is needed as fallback, for ``Series``
  674:         # with ``dtype == object``
  675:         data = data.infer_objects(copy=False)
  676:         include_type = [np.number, "datetime", "datetimetz", "timedelta"]
  677: 
  678:         # GH23719, allow plotting boolean
  679:         if self.include_bool is True:
  680:             include_type.append(np.bool_)
  681: 
  682:         # GH22799, exclude datetime-like type for boxplot
  683:         exclude_type = None
  684:         if self._kind == "box":
  685:             # TODO: change after solving issue 27881
  686:             include_type = [np.number]
  687:             exclude_type = ["timedelta"]
  688: 
  689:         # GH 18755, include object and category type for scatter plot
  690:         if self._kind == "scatter":
  691:             include_type.extend(["object", "category", "string"])
  692: 
  693:         numeric_data = data.select_dtypes(include=include_type, exclude=exclude_type)
  694: 
  695:         is_empty = numeric_data.shape[-1] == 0
  696:         # no non-numeric frames or series allowed
  697:         if is_empty:
  698:             raise TypeError("no numeric data to plot")
  699: 
  700:         self.data = numeric_data.apply(type(self)._convert_to_ndarray)
  701: 
  702:     def _make_plot(self, fig: Figure) -> None:
  703:         raise AbstractMethodError(self)
  704: 
  705:     @final
  706:     def _add_table(self) -> None:
  707:         if self.table is False:
  708:             return
  709:         elif self.table is True:
  710:             data = self.data.transpose()
  711:         else:
  712:             data = self.table
  713:         ax = self._get_ax(0)
  714:         tools.table(ax, data)
  715: 
  716:     @final
  717:     def _post_plot_logic_common(self, ax: Axes) -> None:
  718:         """Common post process for each axes"""
  719:         if self.orientation == "vertical" or self.orientation is None:
  720:             type(self)._apply_axis_properties(
  721:                 ax.xaxis, rot=self.rot, fontsize=self.fontsize
  722:             )
  723:             type(self)._apply_axis_properties(ax.yaxis, fontsize=self.fontsize)
  724: 
  725:             if hasattr(ax, "right_ax"):
  726:                 type(self)._apply_axis_properties(
  727:                     ax.right_ax.yaxis, fontsize=self.fontsize
  728:                 )
  729: 
  730:         elif self.orientation == "horizontal":
  731:             type(self)._apply_axis_properties(
  732:                 ax.yaxis, rot=self.rot, fontsize=self.fontsize
  733:             )
  734:             type(self)._apply_axis_properties(ax.xaxis, fontsize=self.fontsize)
  735: 
  736:             if hasattr(ax, "right_ax"):
  737:                 type(self)._apply_axis_properties(
  738:                     ax.right_ax.yaxis, fontsize=self.fontsize
  739:                 )
  740:         else:  # pragma no cover
  741:             raise ValueError
  742: 
  743:     @abstractmethod
  744:     def _post_plot_logic(self, ax: Axes, data) -> None:
  745:         """Post process for each axes. Overridden in child classes"""
  746: 
  747:     @final
  748:     def _adorn_subplots(self, fig: Figure) -> None:
  749:         """Common post process unrelated to data"""
  750:         if len(self.axes) > 0:
  751:             all_axes = self._get_subplots(fig)
  752:             nrows, ncols = self._get_axes_layout(fig)
  753:             handle_shared_axes(
  754:                 axarr=all_axes,
  755:                 nplots=len(all_axes),
  756:                 naxes=nrows * ncols,
  757:                 nrows=nrows,
  758:                 ncols=ncols,
  759:                 sharex=self.sharex,
  760:                 sharey=self.sharey,
  761:             )
  762: 
  763:         for ax in self.axes:
  764:             ax = getattr(ax, "right_ax", ax)
  765:             if self.yticks is not None:
  766:                 ax.set_yticks(self.yticks)
  767: 
  768:             if self.xticks is not None:
  769:                 ax.set_xticks(self.xticks)
  770: 
  771:             if self.ylim is not None:
  772:                 ax.set_ylim(self.ylim)
  773: 
  774:             if self.xlim is not None:
  775:                 ax.set_xlim(self.xlim)
  776: 
  777:             # GH9093, currently Pandas does not show ylabel, so if users provide
  778:             # ylabel will set it as ylabel in the plot.
  779:             if self.ylabel is not None:
  780:                 ax.set_ylabel(pprint_thing(self.ylabel))
  781: 
  782:             ax.grid(self.grid)
  783: 
  784:         if self.title:
  785:             if self.subplots:
  786:                 if is_list_like(self.title):
  787:                     if len(self.title) != self.nseries:
  788:                         raise ValueError(
  789:                             "The length of `title` must equal the number "
  790:                             "of columns if using `title` of type `list` "
  791:                             "and `subplots=True`.\n"
  792:                             f"length of title = {len(self.title)}\n"
  793:                             f"number of columns = {self.nseries}"
  794:                         )
  795: 
  796:                     for ax, title in zip(self.axes, self.title):
  797:                         ax.set_title(title)
  798:                 else:
  799:                     fig.suptitle(self.title)
  800:             else:
  801:                 if is_list_like(self.title):
  802:                     msg = (
  803:                         "Using `title` of type `list` is not supported "
  804:                         "unless `subplots=True` is passed"
  805:                     )
  806:                     raise ValueError(msg)
  807:                 self.axes[0].set_title(self.title)
  808: 
  809:     @final
  810:     @staticmethod
  811:     def _apply_axis_properties(
  812:         axis: Axis, rot=None, fontsize: int | None = None
  813:     ) -> None:
  814:         """
  815:         Tick creation within matplotlib is reasonably expensive and is
  816:         internally deferred until accessed as Ticks are created/destroyed
  817:         multiple times per draw. It's therefore beneficial for us to avoid
  818:         accessing unless we will act on the Tick.
  819:         """
  820:         if rot is not None or fontsize is not None:
  821:             # rot=0 is a valid setting, hence the explicit None check
  822:             labels = axis.get_majorticklabels() + axis.get_minorticklabels()
  823:             for label in labels:
  824:                 if rot is not None:
  825:                     label.set_rotation(rot)
  826:                 if fontsize is not None:
  827:                     label.set_fontsize(fontsize)
  828: 
  829:     @final
  830:     @property
  831:     def legend_title(self) -> str | None:
  832:         if not isinstance(self.data.columns, ABCMultiIndex):
  833:             name = self.data.columns.name
  834:             if name is not None:
  835:                 name = pprint_thing(name)
  836:             return name
  837:         else:
  838:             stringified = map(pprint_thing, self.data.columns.names)
  839:             return ",".join(stringified)
  840: 
  841:     @final
  842:     def _mark_right_label(self, label: str, index: int) -> str:
  843:         """
  844:         Append ``(right)`` to the label of a line if it's plotted on the right axis.
  845: 
  846:         Note that ``(right)`` is only appended when ``subplots=False``.
  847:         """
  848:         if not self.subplots and self.mark_right and self.on_right(index):
  849:             label += " (right)"
  850:         return label
  851: 
  852:     @final
  853:     def _append_legend_handles_labels(self, handle: Artist, label: str) -> None:
  854:         """
  855:         Append current handle and label to ``legend_handles`` and ``legend_labels``.
  856: 
  857:         These will be used to make the legend.
  858:         """
  859:         self.legend_handles.append(handle)
  860:         self.legend_labels.append(label)
  861: 
  862:     def _make_legend(self) -> None:
  863:         ax, leg = self._get_ax_legend(self.axes[0])
  864: 
  865:         handles = []
  866:         labels = []
  867:         title = ""
  868: 
  869:         if not self.subplots:
  870:             if leg is not None:
  871:                 title = leg.get_title().get_text()
  872:                 # Replace leg.legend_handles because it misses marker info
  873:                 if Version(mpl.__version__) < Version("3.7"):
  874:                     handles = leg.legendHandles
  875:                 else:
  876:                     handles = leg.legend_handles
  877:                 labels = [x.get_text() for x in leg.get_texts()]
  878: 
  879:             if self.legend:
  880:                 if self.legend == "reverse":
  881:                     handles += reversed(self.legend_handles)
  882:                     labels += reversed(self.legend_labels)
  883:                 else:
  884:                     handles += self.legend_handles
  885:                     labels += self.legend_labels
  886: 
  887:                 if self.legend_title is not None:
  888:                     title = self.legend_title
  889: 
  890:             if len(handles) > 0:
  891:                 ax.legend(handles, labels, loc="best", title=title)
  892: 
  893:         elif self.subplots and self.legend:
  894:             for ax in self.axes:
  895:                 if ax.get_visible():
  896:                     ax.legend(loc="best")
  897: 
  898:     @final
  899:     @staticmethod
  900:     def _get_ax_legend(ax: Axes):
  901:         """
  902:         Take in axes and return ax and legend under different scenarios
  903:         """
  904:         leg = ax.get_legend()
  905: 
  906:         other_ax = getattr(ax, "left_ax", None) or getattr(ax, "right_ax", None)
  907:         other_leg = None
  908:         if other_ax is not None:
  909:             other_leg = other_ax.get_legend()
  910:         if leg is None and other_leg is not None:
  911:             leg = other_leg
  912:             ax = other_ax
  913:         return ax, leg
  914: 
  915:     @final
  916:     @cache_readonly
  917:     def plt(self):
  918:         import matplotlib.pyplot as plt
  919: 
  920:         return plt
  921: 
  922:     _need_to_set_index = False
  923: 
  924:     @final
  925:     def _get_xticks(self):
  926:         index = self.data.index
  927:         is_datetype = index.inferred_type in ("datetime", "date", "datetime64", "time")
  928: 
  929:         # TODO: be stricter about x?
  930:         x: list[int] | np.ndarray
  931:         if self.use_index:
  932:             if isinstance(index, ABCPeriodIndex):
  933:                 # test_mixed_freq_irreg_period
  934:                 x = index.to_timestamp()._mpl_repr()
  935:                 # TODO: why do we need to do to_timestamp() here but not other
  936:                 #  places where we call mpl_repr?
  937:             elif is_any_real_numeric_dtype(index.dtype):
  938:                 # Matplotlib supports numeric values or datetime objects as
  939:                 # xaxis values. Taking LBYL approach here, by the time
  940:                 # matplotlib raises exception when using non numeric/datetime
  941:                 # values for xaxis, several actions are already taken by plt.
  942:                 x = index._mpl_repr()
  943:             elif isinstance(index, ABCDatetimeIndex) or is_datetype:
  944:                 x = index._mpl_repr()
  945:             else:
  946:                 self._need_to_set_index = True
  947:                 x = list(range(len(index)))
  948:         else:
  949:             x = list(range(len(index)))
  950: 
  951:         return x
  952: 
  953:     @classmethod
  954:     @register_pandas_matplotlib_converters
  955:     def _plot(
  956:         cls, ax: Axes, x, y: np.ndarray, style=None, is_errorbar: bool = False, **kwds
  957:     ):
  958:         mask = isna(y)
  959:         if mask.any():
  960:             y = np.ma.array(y)
  961:             y = np.ma.masked_where(mask, y)
  962: 
  963:         if isinstance(x, ABCIndex):
  964:             x = x._mpl_repr()
  965: 
  966:         if is_errorbar:
  967:             if "xerr" in kwds:
  968:                 kwds["xerr"] = np.array(kwds.get("xerr"))
  969:             if "yerr" in kwds:
  970:                 kwds["yerr"] = np.array(kwds.get("yerr"))
  971:             return ax.errorbar(x, y, **kwds)
  972:         else:
  973:             # prevent style kwarg from going to errorbar, where it is unsupported
  974:             args = (x, y, style) if style is not None else (x, y)
  975:             return ax.plot(*args, **kwds)
  976: 
  977:     def _get_custom_index_name(self):
  978:         """Specify whether xlabel/ylabel should be used to override index name"""
  979:         return self.xlabel
  980: 
  981:     @final
  982:     def _get_index_name(self) -> str | None:
  983:         if isinstance(self.data.index, ABCMultiIndex):
  984:             name = self.data.index.names
  985:             if com.any_not_none(*name):
  986:                 name = ",".join([pprint_thing(x) for x in name])
  987:             else:
  988:                 name = None
  989:         else:
  990:             name = self.data.index.name
  991:             if name is not None:
  992:                 name = pprint_thing(name)
  993: 
  994:         # GH 45145, override the default axis label if one is provided.
  995:         index_name = self._get_custom_index_name()
  996:         if index_name is not None:
  997:             name = pprint_thing(index_name)
  998: 
  999:         return name
 1000: 
 1001:     @final
 1002:     @classmethod
 1003:     def _get_ax_layer(cls, ax, primary: bool = True):
 1004:         """get left (primary) or right (secondary) axes"""
 1005:         if primary:
 1006:             return getattr(ax, "left_ax", ax)
 1007:         else:
 1008:             return getattr(ax, "right_ax", ax)
 1009: 
 1010:     @final
 1011:     def _col_idx_to_axis_idx(self, col_idx: int) -> int:
 1012:         """Return the index of the axis where the column at col_idx should be plotted"""
 1013:         if isinstance(self.subplots, list):
 1014:             # Subplots is a list: some columns will be grouped together in the same ax
 1015:             return next(
 1016:                 group_idx
 1017:                 for (group_idx, group) in enumerate(self.subplots)
 1018:                 if col_idx in group
 1019:             )
 1020:         else:
 1021:             # subplots is True: one ax per column
 1022:             return col_idx
 1023: 
 1024:     @final
 1025:     def _get_ax(self, i: int):
 1026:         # get the twinx ax if appropriate
 1027:         if self.subplots:
 1028:             i = self._col_idx_to_axis_idx(i)
 1029:             ax = self.axes[i]
 1030:             ax = self._maybe_right_yaxis(ax, i)
 1031:             # error: Unsupported target for indexed assignment ("Sequence[Any]")
 1032:             self.axes[i] = ax  # type: ignore[index]
 1033:         else:
 1034:             ax = self.axes[0]
 1035:             ax = self._maybe_right_yaxis(ax, i)
 1036: 
 1037:         ax.get_yaxis().set_visible(True)
 1038:         return ax
 1039: 
 1040:     @final
 1041:     def on_right(self, i: int):
 1042:         if isinstance(self.secondary_y, bool):
 1043:             return self.secondary_y
 1044: 
 1045:         if isinstance(self.secondary_y, (tuple, list, np.ndarray, ABCIndex)):
 1046:             return self.data.columns[i] in self.secondary_y
 1047: 
 1048:     @final
 1049:     def _apply_style_colors(
 1050:         self, colors, kwds: dict[str, Any], col_num: int, label: str
 1051:     ):
 1052:         """
 1053:         Manage style and color based on column number and its label.
 1054:         Returns tuple of appropriate style and kwds which "color" may be added.
 1055:         """
 1056:         style = None
 1057:         if self.style is not None:
 1058:             if isinstance(self.style, list):
 1059:                 try:
 1060:                     style = self.style[col_num]
 1061:                 except IndexError:
 1062:                     pass
 1063:             elif isinstance(self.style, dict):
 1064:                 style = self.style.get(label, style)
 1065:             else:
 1066:                 style = self.style
 1067: 
 1068:         has_color = "color" in kwds or self.colormap is not None
 1069:         nocolor_style = style is None or not _color_in_style(style)
 1070:         if (has_color or self.subplots) and nocolor_style:
 1071:             if isinstance(colors, dict):
 1072:                 kwds["color"] = colors[label]
 1073:             else:
 1074:                 kwds["color"] = colors[col_num % len(colors)]
 1075:         return style, kwds
 1076: 
 1077:     def _get_colors(
 1078:         self,
 1079:         num_colors: int | None = None,
 1080:         color_kwds: str = "color",
 1081:     ):
 1082:         if num_colors is None:
 1083:             num_colors = self.nseries
 1084:         if color_kwds == "color":
 1085:             color = self.color
 1086:         else:
 1087:             color = self.kwds.get(color_kwds)
 1088:         return get_standard_colors(
 1089:             num_colors=num_colors,
 1090:             colormap=self.colormap,
 1091:             color=color,
 1092:         )
 1093: 
 1094:     # TODO: tighter typing for first return?
 1095:     @final
 1096:     @staticmethod
 1097:     def _parse_errorbars(
 1098:         label: str, err, data: NDFrameT, nseries: int
 1099:     ) -> tuple[Any, NDFrameT]:
 1100:         """
 1101:         Look for error keyword arguments and return the actual errorbar data
 1102:         or return the error DataFrame/dict
 1103: 
 1104:         Error bars can be specified in several ways:
 1105:             Series: the user provides a pandas.Series object of the same
 1106:                     length as the data
 1107:             ndarray: provides a np.ndarray of the same length as the data
 1108:             DataFrame/dict: error values are paired with keys matching the
 1109:                     key in the plotted DataFrame
 1110:             str: the name of the column within the plotted DataFrame
 1111: 
 1112:         Asymmetrical error bars are also supported, however raw error values
 1113:         must be provided in this case. For a ``N`` length :class:`Series`, a
 1114:         ``2xN`` array should be provided indicating lower and upper (or left
 1115:         and right) errors. For a ``MxN`` :class:`DataFrame`, asymmetrical errors
 1116:         should be in a ``Mx2xN`` array.
 1117:         """
 1118:         if err is None:
 1119:             return None, data
 1120: 
 1121:         def match_labels(data, e):
 1122:             e = e.reindex(data.index)
 1123:             return e
 1124: 
 1125:         # key-matched DataFrame
 1126:         if isinstance(err, ABCDataFrame):
 1127:             err = match_labels(data, err)
 1128:         # key-matched dict
 1129:         elif isinstance(err, dict):
 1130:             pass
 1131: 
 1132:         # Series of error values
 1133:         elif isinstance(err, ABCSeries):
 1134:             # broadcast error series across data
 1135:             err = match_labels(data, err)
 1136:             err = np.atleast_2d(err)
 1137:             err = np.tile(err, (nseries, 1))
 1138: 
 1139:         # errors are a column in the dataframe
 1140:         elif isinstance(err, str):
 1141:             evalues = data[err].values
 1142:             data = data[data.columns.drop(err)]
 1143:             err = np.atleast_2d(evalues)
 1144:             err = np.tile(err, (nseries, 1))
 1145: 
 1146:         elif is_list_like(err):
 1147:             if is_iterator(err):
 1148:                 err = np.atleast_2d(list(err))
 1149:             else:
 1150:                 # raw error values
 1151:                 err = np.atleast_2d(err)
 1152: 
 1153:             err_shape = err.shape
 1154: 
 1155:             # asymmetrical error bars
 1156:             if isinstance(data, ABCSeries) and err_shape[0] == 2:
 1157:                 err = np.expand_dims(err, 0)
 1158:                 err_shape = err.shape
 1159:                 if err_shape[2] != len(data):
 1160:                     raise ValueError(
 1161:                         "Asymmetrical error bars should be provided "
 1162:                         f"with the shape (2, {len(data)})"
 1163:                     )
 1164:             elif isinstance(data, ABCDataFrame) and err.ndim == 3:
 1165:                 if (
 1166:                     (err_shape[0] != nseries)
 1167:                     or (err_shape[1] != 2)
 1168:                     or (err_shape[2] != len(data))
 1169:                 ):
 1170:                     raise ValueError(
 1171:                         "Asymmetrical error bars should be provided "
 1172:                         f"with the shape ({nseries}, 2, {len(data)})"
 1173:                     )
 1174: 
 1175:             # broadcast errors to each data series
 1176:             if len(err) == 1:
 1177:                 err = np.tile(err, (nseries, 1))
 1178: 
 1179:         elif is_number(err):
 1180:             err = np.tile(
 1181:                 [err],
 1182:                 (nseries, len(data)),
 1183:             )
 1184: 
 1185:         else:
 1186:             msg = f"No valid {label} detected"
 1187:             raise ValueError(msg)
 1188: 
 1189:         return err, data
 1190: 
 1191:     @final
 1192:     def _get_errorbars(
 1193:         self, label=None, index=None, xerr: bool = True, yerr: bool = True
 1194:     ) -> dict[str, Any]:
 1195:         errors = {}
 1196: 
 1197:         for kw, flag in zip(["xerr", "yerr"], [xerr, yerr]):
 1198:             if flag:
 1199:                 err = self.errors[kw]
 1200:                 # user provided label-matched dataframe of errors
 1201:                 if isinstance(err, (ABCDataFrame, dict)):
 1202:                     if label is not None and label in err.keys():
 1203:                         err = err[label]
 1204:                     else:
 1205:                         err = None
 1206:                 elif index is not None and err is not None:
 1207:                     err = err[index]
 1208: 
 1209:                 if err is not None:
 1210:                     errors[kw] = err
 1211:         return errors
 1212: 
 1213:     @final
 1214:     def _get_subplots(self, fig: Figure):
 1215:         if Version(mpl.__version__) < Version("3.8"):
 1216:             from matplotlib.axes import Subplot as Klass
 1217:         else:
 1218:             from matplotlib.axes import Axes as Klass
 1219: 
 1220:         return [
 1221:             ax
 1222:             for ax in fig.get_axes()
 1223:             if (isinstance(ax, Klass) and ax.get_subplotspec() is not None)
 1224:         ]
 1225: 
 1226:     @final
 1227:     def _get_axes_layout(self, fig: Figure) -> tuple[int, int]:
 1228:         axes = self._get_subplots(fig)
 1229:         x_set = set()
 1230:         y_set = set()
 1231:         for ax in axes:
 1232:             # check axes coordinates to estimate layout
 1233:             points = ax.get_position().get_points()
 1234:             x_set.add(points[0][0])
 1235:             y_set.add(points[0][1])
 1236:         return (len(y_set), len(x_set))
 1237: 
 1238: 
 1239: class PlanePlot(MPLPlot, ABC):
 1240:     """
 1241:     Abstract class for plotting on plane, currently scatter and hexbin.
 1242:     """
 1243: 
 1244:     _layout_type = "single"
 1245: 
 1246:     def __init__(self, data, x, y, **kwargs) -> None:
 1247:         MPLPlot.__init__(self, data, **kwargs)
 1248:         if x is None or y is None:
 1249:             raise ValueError(self._kind + " requires an x and y column")
 1250:         if is_integer(x) and not self.data.columns._holds_integer():
 1251:             x = self.data.columns[x]
 1252:         if is_integer(y) and not self.data.columns._holds_integer():
 1253:             y = self.data.columns[y]
 1254: 
 1255:         self.x = x
 1256:         self.y = y
 1257: 
 1258:     @final
 1259:     def _get_nseries(self, data: Series | DataFrame) -> int:
 1260:         return 1
 1261: 
 1262:     @final
 1263:     def _post_plot_logic(self, ax: Axes, data) -> None:
 1264:         x, y = self.x, self.y
 1265:         xlabel = self.xlabel if self.xlabel is not None else pprint_thing(x)
 1266:         ylabel = self.ylabel if self.ylabel is not None else pprint_thing(y)
 1267:         # error: Argument 1 to "set_xlabel" of "_AxesBase" has incompatible
 1268:         # type "Hashable"; expected "str"
 1269:         ax.set_xlabel(xlabel)  # type: ignore[arg-type]
 1270:         ax.set_ylabel(ylabel)  # type: ignore[arg-type]
 1271: 
 1272:     @final
 1273:     def _plot_colorbar(self, ax: Axes, *, fig: Figure, **kwds):
 1274:         # Addresses issues #10611 and #10678:
 1275:         # When plotting scatterplots and hexbinplots in IPython
 1276:         # inline backend the colorbar axis height tends not to
 1277:         # exactly match the parent axis height.
 1278:         # The difference is due to small fractional differences
 1279:         # in floating points with similar representation.
 1280:         # To deal with this, this method forces the colorbar
 1281:         # height to take the height of the parent axes.
 1282:         # For a more detailed description of the issue
 1283:         # see the following link:
 1284:         # https://github.com/ipython/ipython/issues/11215
 1285: 
 1286:         # GH33389, if ax is used multiple times, we should always
 1287:         # use the last one which contains the latest information
 1288:         # about the ax
 1289:         img = ax.collections[-1]
 1290:         return fig.colorbar(img, ax=ax, **kwds)
 1291: 
 1292: 
 1293: class ScatterPlot(PlanePlot):
 1294:     @property
 1295:     def _kind(self) -> Literal["scatter"]:
 1296:         return "scatter"
 1297: 
 1298:     def __init__(
 1299:         self,
 1300:         data,
 1301:         x,
 1302:         y,
 1303:         s=None,
 1304:         c=None,
 1305:         *,
 1306:         colorbar: bool | lib.NoDefault = lib.no_default,
 1307:         norm=None,
 1308:         **kwargs,
 1309:     ) -> None:
 1310:         if s is None:
 1311:             # hide the matplotlib default for size, in case we want to change
 1312:             # the handling of this argument later
 1313:             s = 20
 1314:         elif is_hashable(s) and s in data.columns:
 1315:             s = data[s]
 1316:         self.s = s
 1317: 
 1318:         self.colorbar = colorbar
 1319:         self.norm = norm
 1320: 
 1321:         super().__init__(data, x, y, **kwargs)
 1322:         if is_integer(c) and not self.data.columns._holds_integer():
 1323:             c = self.data.columns[c]
 1324:         self.c = c
 1325: 
 1326:     def _make_plot(self, fig: Figure) -> None:
 1327:         x, y, c, data = self.x, self.y, self.c, self.data
 1328:         ax = self.axes[0]
 1329: 
 1330:         c_is_column = is_hashable(c) and c in self.data.columns
 1331: 
 1332:         color_by_categorical = c_is_column and isinstance(
 1333:             self.data[c].dtype, CategoricalDtype
 1334:         )
 1335: 
 1336:         color = self.color
 1337:         c_values = self._get_c_values(color, color_by_categorical, c_is_column)
 1338:         norm, cmap = self._get_norm_and_cmap(c_values, color_by_categorical)
 1339:         cb = self._get_colorbar(c_values, c_is_column)
 1340: 
 1341:         if self.legend:
 1342:             label = self.label
 1343:         else:
 1344:             label = None
 1345:         scatter = ax.scatter(
 1346:             data[x].values,
 1347:             data[y].values,
 1348:             c=c_values,
 1349:             label=label,
 1350:             cmap=cmap,
 1351:             norm=norm,
 1352:             s=self.s,
 1353:             **self.kwds,
 1354:         )
 1355:         if cb:
 1356:             cbar_label = c if c_is_column else ""
 1357:             cbar = self._plot_colorbar(ax, fig=fig, label=cbar_label)
 1358:             if color_by_categorical:
 1359:                 n_cats = len(self.data[c].cat.categories)
 1360:                 cbar.set_ticks(np.linspace(0.5, n_cats - 0.5, n_cats))
 1361:                 cbar.ax.set_yticklabels(self.data[c].cat.categories)
 1362: 
 1363:         if label is not None:
 1364:             self._append_legend_handles_labels(
 1365:                 # error: Argument 2 to "_append_legend_handles_labels" of
 1366:                 # "MPLPlot" has incompatible type "Hashable"; expected "str"
 1367:                 scatter,
 1368:                 label,  # type: ignore[arg-type]
 1369:             )
 1370: 
 1371:         errors_x = self._get_errorbars(label=x, index=0, yerr=False)
 1372:         errors_y = self._get_errorbars(label=y, index=0, xerr=False)
 1373:         if len(errors_x) > 0 or len(errors_y) > 0:
 1374:             err_kwds = dict(errors_x, **errors_y)
 1375:             err_kwds["ecolor"] = scatter.get_facecolor()[0]
 1376:             ax.errorbar(data[x].values, data[y].values, linestyle="none", **err_kwds)
 1377: 
 1378:     def _get_c_values(self, color, color_by_categorical: bool, c_is_column: bool):
 1379:         c = self.c
 1380:         if c is not None and color is not None:
 1381:             raise TypeError("Specify exactly one of `c` and `color`")
 1382:         if c is None and color is None:
 1383:             c_values = self.plt.rcParams["patch.facecolor"]
 1384:         elif color is not None:
 1385:             c_values = color
 1386:         elif color_by_categorical:
 1387:             c_values = self.data[c].cat.codes
 1388:         elif c_is_column:
 1389:             c_values = self.data[c].values
 1390:         else:
 1391:             c_values = c
 1392:         return c_values
 1393: 
 1394:     def _get_norm_and_cmap(self, c_values, color_by_categorical: bool):
 1395:         c = self.c
 1396:         if self.colormap is not None:
 1397:             cmap = mpl.colormaps.get_cmap(self.colormap)
 1398:         # cmap is only used if c_values are integers, otherwise UserWarning.
 1399:         # GH-53908: additionally call isinstance() because is_integer_dtype
 1400:         # returns True for "b" (meaning "blue" and not int8 in this context)
 1401:         elif not isinstance(c_values, str) and is_integer_dtype(c_values):
 1402:             # pandas uses colormap, matplotlib uses cmap.
 1403:             cmap = mpl.colormaps["Greys"]
 1404:         else:
 1405:             cmap = None
 1406: 
 1407:         if color_by_categorical and cmap is not None:
 1408:             from matplotlib import colors
 1409: 
 1410:             n_cats = len(self.data[c].cat.categories)
 1411:             cmap = colors.ListedColormap([cmap(i) for i in range(cmap.N)])
 1412:             bounds = np.linspace(0, n_cats, n_cats + 1)
 1413:             norm = colors.BoundaryNorm(bounds, cmap.N)
 1414:             # TODO: warn that we are ignoring self.norm if user specified it?
 1415:             #  Doesn't happen in any tests 2023-11-09
 1416:         else:
 1417:             norm = self.norm
 1418:         return norm, cmap
 1419: 
 1420:     def _get_colorbar(self, c_values, c_is_column: bool) -> bool:
 1421:         # plot colorbar if
 1422:         # 1. colormap is assigned, and
 1423:         # 2.`c` is a column containing only numeric values
 1424:         plot_colorbar = self.colormap or c_is_column
 1425:         cb = self.colorbar
 1426:         if cb is lib.no_default:
 1427:             return is_numeric_dtype(c_values) and plot_colorbar
 1428:         return cb
 1429: 
 1430: 
 1431: class HexBinPlot(PlanePlot):
 1432:     @property
 1433:     def _kind(self) -> Literal["hexbin"]:
 1434:         return "hexbin"
 1435: 
 1436:     def __init__(self, data, x, y, C=None, *, colorbar: bool = True, **kwargs) -> None:
 1437:         super().__init__(data, x, y, **kwargs)
 1438:         if is_integer(C) and not self.data.columns._holds_integer():
 1439:             C = self.data.columns[C]
 1440:         self.C = C
 1441: 
 1442:         self.colorbar = colorbar
 1443: 
 1444:         # Scatter plot allows to plot objects data
 1445:         if len(self.data[self.x]._get_numeric_data()) == 0:
 1446:             raise ValueError(self._kind + " requires x column to be numeric")
 1447:         if len(self.data[self.y]._get_numeric_data()) == 0:
 1448:             raise ValueError(self._kind + " requires y column to be numeric")
 1449: 
 1450:     def _make_plot(self, fig: Figure) -> None:
 1451:         x, y, data, C = self.x, self.y, self.data, self.C
 1452:         ax = self.axes[0]
 1453:         # pandas uses colormap, matplotlib uses cmap.
 1454:         cmap = self.colormap or "BuGn"
 1455:         cmap = mpl.colormaps.get_cmap(cmap)
 1456:         cb = self.colorbar
 1457: 
 1458:         if C is None:
 1459:             c_values = None
 1460:         else:
 1461:             c_values = data[C].values
 1462: 
 1463:         ax.hexbin(data[x].values, data[y].values, C=c_values, cmap=cmap, **self.kwds)
 1464:         if cb:
 1465:             self._plot_colorbar(ax, fig=fig)
 1466: 
 1467:     def _make_legend(self) -> None:
 1468:         pass
 1469: 
 1470: 
 1471: class LinePlot(MPLPlot):
 1472:     _default_rot = 0
 1473: 
 1474:     @property
 1475:     def orientation(self) -> PlottingOrientation:
 1476:         return "vertical"
 1477: 
 1478:     @property
 1479:     def _kind(self) -> Literal["line", "area", "hist", "kde", "box"]:
 1480:         return "line"
 1481: 
 1482:     def __init__(self, data, **kwargs) -> None:
 1483:         from pandas.plotting import plot_params
 1484: 
 1485:         MPLPlot.__init__(self, data, **kwargs)
 1486:         if self.stacked:
 1487:             self.data = self.data.fillna(value=0)
 1488:         self.x_compat = plot_params["x_compat"]
 1489:         if "x_compat" in self.kwds:
 1490:             self.x_compat = bool(self.kwds.pop("x_compat"))
 1491: 
 1492:     @final
 1493:     def _is_ts_plot(self) -> bool:
 1494:         # this is slightly deceptive
 1495:         return not self.x_compat and self.use_index and self._use_dynamic_x()
 1496: 
 1497:     @final
 1498:     def _use_dynamic_x(self) -> bool:
 1499:         return use_dynamic_x(self._get_ax(0), self.data)
 1500: 
 1501:     def _make_plot(self, fig: Figure) -> None:
 1502:         if self._is_ts_plot():
 1503:             data = maybe_convert_index(self._get_ax(0), self.data)
 1504: 
 1505:             x = data.index  # dummy, not used
 1506:             plotf = self._ts_plot
 1507:             it = data.items()
 1508:         else:
 1509:             x = self._get_xticks()
 1510:             # error: Incompatible types in assignment (expression has type
 1511:             # "Callable[[Any, Any, Any, Any, Any, Any, KwArg(Any)], Any]", variable has
 1512:             # type "Callable[[Any, Any, Any, Any, KwArg(Any)], Any]")
 1513:             plotf = self._plot  # type: ignore[assignment]
 1514:             # error: Incompatible types in assignment (expression has type
 1515:             # "Iterator[tuple[Hashable, ndarray[Any, Any]]]", variable has
 1516:             # type "Iterable[tuple[Hashable, Series]]")
 1517:             it = self._iter_data(data=self.data)  # type: ignore[assignment]
 1518: 
 1519:         stacking_id = self._get_stacking_id()
 1520:         is_errorbar = com.any_not_none(*self.errors.values())
 1521: 
 1522:         colors = self._get_colors()
 1523:         for i, (label, y) in enumerate(it):
 1524:             ax = self._get_ax(i)
 1525:             kwds = self.kwds.copy()
 1526:             if self.color is not None:
 1527:                 kwds["color"] = self.color
 1528:             style, kwds = self._apply_style_colors(
 1529:                 colors,
 1530:                 kwds,
 1531:                 i,
 1532:                 # error: Argument 4 to "_apply_style_colors" of "MPLPlot" has
 1533:                 # incompatible type "Hashable"; expected "str"
 1534:                 label,  # type: ignore[arg-type]
 1535:             )
 1536: 
 1537:             errors = self._get_errorbars(label=label, index=i)
 1538:             kwds = dict(kwds, **errors)
 1539: 
 1540:             label = pprint_thing(label)
 1541:             label = self._mark_right_label(label, index=i)
 1542:             kwds["label"] = label
 1543: 
 1544:             newlines = plotf(
 1545:                 ax,
 1546:                 x,
 1547:                 y,
 1548:                 style=style,
 1549:                 column_num=i,
 1550:                 stacking_id=stacking_id,
 1551:                 is_errorbar=is_errorbar,
 1552:                 **kwds,
 1553:             )
 1554:             self._append_legend_handles_labels(newlines[0], label)
 1555: 
 1556:             if self._is_ts_plot():
 1557:                 # reset of xlim should be used for ts data
 1558:                 # TODO: GH28021, should find a way to change view limit on xaxis
 1559:                 lines = get_all_lines(ax)
 1560:                 left, right = get_xlim(lines)
 1561:                 ax.set_xlim(left, right)
 1562: 
 1563:     # error: Signature of "_plot" incompatible with supertype "MPLPlot"
 1564:     @classmethod
 1565:     def _plot(  # type: ignore[override]
 1566:         cls,
 1567:         ax: Axes,
 1568:         x,
 1569:         y: np.ndarray,
 1570:         style=None,
 1571:         column_num=None,
 1572:         stacking_id=None,
 1573:         **kwds,
 1574:     ):
 1575:         # column_num is used to get the target column from plotf in line and
 1576:         # area plots
 1577:         if column_num == 0:
 1578:             cls._initialize_stacker(ax, stacking_id, len(y))
 1579:         y_values = cls._get_stacked_values(ax, stacking_id, y, kwds["label"])
 1580:         lines = MPLPlot._plot(ax, x, y_values, style=style, **kwds)
 1581:         cls._update_stacker(ax, stacking_id, y)
 1582:         return lines
 1583: 
 1584:     @final
 1585:     def _ts_plot(self, ax: Axes, x, data: Series, style=None, **kwds):
 1586:         # accept x to be consistent with normal plot func,
 1587:         # x is not passed to tsplot as it uses data.index as x coordinate
 1588:         # column_num must be in kwds for stacking purpose
 1589:         freq, data = maybe_resample(data, ax, kwds)
 1590: 
 1591:         # Set ax with freq info
 1592:         decorate_axes(ax, freq)
 1593:         # digging deeper
 1594:         if hasattr(ax, "left_ax"):
 1595:             decorate_axes(ax.left_ax, freq)
 1596:         if hasattr(ax, "right_ax"):
 1597:             decorate_axes(ax.right_ax, freq)
 1598:         # TODO #54485
 1599:         ax._plot_data.append((data, self._kind, kwds))  # type: ignore[attr-defined]
 1600: 
 1601:         lines = self._plot(ax, data.index, np.asarray(data.values), style=style, **kwds)
 1602:         # set date formatter, locators and rescale limits
 1603:         # TODO #54485
 1604:         format_dateaxis(ax, ax.freq, data.index)  # type: ignore[arg-type, attr-defined]
 1605:         return lines
 1606: 
 1607:     @final
 1608:     def _get_stacking_id(self) -> int | None:
 1609:         if self.stacked:
 1610:             return id(self.data)
 1611:         else:
 1612:             return None
 1613: 
 1614:     @final
 1615:     @classmethod
 1616:     def _initialize_stacker(cls, ax: Axes, stacking_id, n: int) -> None:
 1617:         if stacking_id is None:
 1618:             return
 1619:         if not hasattr(ax, "_stacker_pos_prior"):
 1620:             # TODO #54485
 1621:             ax._stacker_pos_prior = {}  # type: ignore[attr-defined]
 1622:         if not hasattr(ax, "_stacker_neg_prior"):
 1623:             # TODO #54485
 1624:             ax._stacker_neg_prior = {}  # type: ignore[attr-defined]
 1625:         # TODO #54485
 1626:         ax._stacker_pos_prior[stacking_id] = np.zeros(n)  # type: ignore[attr-defined]
 1627:         # TODO #54485
 1628:         ax._stacker_neg_prior[stacking_id] = np.zeros(n)  # type: ignore[attr-defined]
 1629: 
 1630:     @final
 1631:     @classmethod
 1632:     def _get_stacked_values(
 1633:         cls, ax: Axes, stacking_id: int | None, values: np.ndarray, label
 1634:     ) -> np.ndarray:
 1635:         if stacking_id is None:
 1636:             return values
 1637:         if not hasattr(ax, "_stacker_pos_prior"):
 1638:             # stacker may not be initialized for subplots
 1639:             cls._initialize_stacker(ax, stacking_id, len(values))
 1640: 
 1641:         if (values >= 0).all():
 1642:             # TODO #54485
 1643:             return (
 1644:                 ax._stacker_pos_prior[stacking_id]  # type: ignore[attr-defined]
 1645:                 + values
 1646:             )
 1647:         elif (values <= 0).all():
 1648:             # TODO #54485
 1649:             return (
 1650:                 ax._stacker_neg_prior[stacking_id]  # type: ignore[attr-defined]
 1651:                 + values
 1652:             )
 1653: 
 1654:         raise ValueError(
 1655:             "When stacked is True, each column must be either "
 1656:             "all positive or all negative. "
 1657:             f"Column '{label}' contains both positive and negative values"
 1658:         )
 1659: 
 1660:     @final
 1661:     @classmethod
 1662:     def _update_stacker(cls, ax: Axes, stacking_id: int | None, values) -> None:
 1663:         if stacking_id is None:
 1664:             return
 1665:         if (values >= 0).all():
 1666:             # TODO #54485
 1667:             ax._stacker_pos_prior[stacking_id] += values  # type: ignore[attr-defined]
 1668:         elif (values <= 0).all():
 1669:             # TODO #54485
 1670:             ax._stacker_neg_prior[stacking_id] += values  # type: ignore[attr-defined]
 1671: 
 1672:     def _post_plot_logic(self, ax: Axes, data) -> None:
 1673:         from matplotlib.ticker import FixedLocator
 1674: 
 1675:         def get_label(i):
 1676:             if is_float(i) and i.is_integer():
 1677:                 i = int(i)
 1678:             try:
 1679:                 return pprint_thing(data.index[i])
 1680:             except Exception:
 1681:                 return ""
 1682: 
 1683:         if self._need_to_set_index:
 1684:             xticks = ax.get_xticks()
 1685:             xticklabels = [get_label(x) for x in xticks]
 1686:             # error: Argument 1 to "FixedLocator" has incompatible type "ndarray[Any,
 1687:             # Any]"; expected "Sequence[float]"
 1688:             ax.xaxis.set_major_locator(FixedLocator(xticks))  # type: ignore[arg-type]
 1689:             ax.set_xticklabels(xticklabels)
 1690: 
 1691:         # If the index is an irregular time series, then by default
 1692:         # we rotate the tick labels. The exception is if there are
 1693:         # subplots which don't share their x-axes, in which we case
 1694:         # we don't rotate the ticklabels as by default the subplots
 1695:         # would be too close together.
 1696:         condition = (
 1697:             not self._use_dynamic_x()
 1698:             and (data.index._is_all_dates and self.use_index)
 1699:             and (not self.subplots or (self.subplots and self.sharex))
 1700:         )
 1701: 
 1702:         index_name = self._get_index_name()
 1703: 
 1704:         if condition:
 1705:             # irregular TS rotated 30 deg. by default
 1706:             # probably a better place to check / set this.
 1707:             if not self._rot_set:
 1708:                 self.rot = 30
 1709:             format_date_labels(ax, rot=self.rot)
 1710: 
 1711:         if index_name is not None and self.use_index:
 1712:             ax.set_xlabel(index_name)
 1713: 
 1714: 
 1715: class AreaPlot(LinePlot):
 1716:     @property
 1717:     def _kind(self) -> Literal["area"]:
 1718:         return "area"
 1719: 
 1720:     def __init__(self, data, **kwargs) -> None:
 1721:         kwargs.setdefault("stacked", True)
 1722:         with warnings.catch_warnings():
 1723:             warnings.filterwarnings(
 1724:                 "ignore",
 1725:                 "Downcasting object dtype arrays",
 1726:                 category=FutureWarning,
 1727:             )
 1728:             data = data.fillna(value=0)
 1729:         LinePlot.__init__(self, data, **kwargs)
 1730: 
 1731:         if not self.stacked:
 1732:             # use smaller alpha to distinguish overlap
 1733:             self.kwds.setdefault("alpha", 0.5)
 1734: 
 1735:         if self.logy or self.loglog:
 1736:             raise ValueError("Log-y scales are not supported in area plot")
 1737: 
 1738:     # error: Signature of "_plot" incompatible with supertype "MPLPlot"
 1739:     @classmethod
 1740:     def _plot(  # type: ignore[override]
 1741:         cls,
 1742:         ax: Axes,
 1743:         x,
 1744:         y: np.ndarray,
 1745:         style=None,
 1746:         column_num=None,
 1747:         stacking_id=None,
 1748:         is_errorbar: bool = False,
 1749:         **kwds,
 1750:     ):
 1751:         if column_num == 0:
 1752:             cls._initialize_stacker(ax, stacking_id, len(y))
 1753:         y_values = cls._get_stacked_values(ax, stacking_id, y, kwds["label"])
 1754: 
 1755:         # need to remove label, because subplots uses mpl legend as it is
 1756:         line_kwds = kwds.copy()
 1757:         line_kwds.pop("label")
 1758:         lines = MPLPlot._plot(ax, x, y_values, style=style, **line_kwds)
 1759: 
 1760:         # get data from the line to get coordinates for fill_between
 1761:         xdata, y_values = lines[0].get_data(orig=False)
 1762: 
 1763:         # unable to use ``_get_stacked_values`` here to get starting point
 1764:         if stacking_id is None:
 1765:             start = np.zeros(len(y))
 1766:         elif (y >= 0).all():
 1767:             # TODO #54485
 1768:             start = ax._stacker_pos_prior[stacking_id]  # type: ignore[attr-defined]
 1769:         elif (y <= 0).all():
 1770:             # TODO #54485
 1771:             start = ax._stacker_neg_prior[stacking_id]  # type: ignore[attr-defined]
 1772:         else:
 1773:             start = np.zeros(len(y))
 1774: 
 1775:         if "color" not in kwds:
 1776:             kwds["color"] = lines[0].get_color()
 1777: 
 1778:         rect = ax.fill_between(xdata, start, y_values, **kwds)
 1779:         cls._update_stacker(ax, stacking_id, y)
 1780: 
 1781:         # LinePlot expects list of artists
 1782:         res = [rect]
 1783:         return res
 1784: 
 1785:     def _post_plot_logic(self, ax: Axes, data) -> None:
 1786:         LinePlot._post_plot_logic(self, ax, data)
 1787: 
 1788:         is_shared_y = len(list(ax.get_shared_y_axes())) > 0
 1789:         # do not override the default axis behaviour in case of shared y axes
 1790:         if self.ylim is None and not is_shared_y:
 1791:             if (data >= 0).all().all():
 1792:                 ax.set_ylim(0, None)
 1793:             elif (data <= 0).all().all():
 1794:                 ax.set_ylim(None, 0)
 1795: 
 1796: 
 1797: class BarPlot(MPLPlot):
 1798:     @property
 1799:     def _kind(self) -> Literal["bar", "barh"]:
 1800:         return "bar"
 1801: 
 1802:     _default_rot = 90
 1803: 
 1804:     @property
 1805:     def orientation(self) -> PlottingOrientation:
 1806:         return "vertical"
 1807: 
 1808:     def __init__(
 1809:         self,
 1810:         data,
 1811:         *,
 1812:         align="center",
 1813:         bottom=0,
 1814:         left=0,
 1815:         width=0.5,
 1816:         position=0.5,
 1817:         log=False,
 1818:         **kwargs,
 1819:     ) -> None:
 1820:         # we have to treat a series differently than a
 1821:         # 1-column DataFrame w.r.t. color handling
 1822:         self._is_series = isinstance(data, ABCSeries)
 1823:         self.bar_width = width
 1824:         self._align = align
 1825:         self._position = position
 1826:         self.tick_pos = np.arange(len(data))
 1827: 
 1828:         if is_list_like(bottom):
 1829:             bottom = np.array(bottom)
 1830:         if is_list_like(left):
 1831:             left = np.array(left)
 1832:         self.bottom = bottom
 1833:         self.left = left
 1834: 
 1835:         self.log = log
 1836: 
 1837:         MPLPlot.__init__(self, data, **kwargs)
 1838: 
 1839:     @cache_readonly
 1840:     def ax_pos(self) -> np.ndarray:
 1841:         return self.tick_pos - self.tickoffset
 1842: 
 1843:     @cache_readonly
 1844:     def tickoffset(self):
 1845:         if self.stacked or self.subplots:
 1846:             return self.bar_width * self._position
 1847:         elif self._align == "edge":
 1848:             w = self.bar_width / self.nseries
 1849:             return self.bar_width * (self._position - 0.5) + w * 0.5
 1850:         else:
 1851:             return self.bar_width * self._position
 1852: 
 1853:     @cache_readonly
 1854:     def lim_offset(self):
 1855:         if self.stacked or self.subplots:
 1856:             if self._align == "edge":
 1857:                 return self.bar_width / 2
 1858:             else:
 1859:                 return 0
 1860:         elif self._align == "edge":
 1861:             w = self.bar_width / self.nseries
 1862:             return w * 0.5
 1863:         else:
 1864:             return 0
 1865: 
 1866:     # error: Signature of "_plot" incompatible with supertype "MPLPlot"
 1867:     @classmethod
 1868:     def _plot(  # type: ignore[override]
 1869:         cls,
 1870:         ax: Axes,
 1871:         x,
 1872:         y: np.ndarray,
 1873:         w,
 1874:         start: int | npt.NDArray[np.intp] = 0,
 1875:         log: bool = False,
 1876:         **kwds,
 1877:     ):
 1878:         return ax.bar(x, y, w, bottom=start, log=log, **kwds)
 1879: 
 1880:     @property
 1881:     def _start_base(self):
 1882:         return self.bottom
 1883: 
 1884:     def _make_plot(self, fig: Figure) -> None:
 1885:         colors = self._get_colors()
 1886:         ncolors = len(colors)
 1887: 
 1888:         pos_prior = neg_prior = np.zeros(len(self.data))
 1889:         K = self.nseries
 1890: 
 1891:         data = self.data.fillna(0)
 1892:         for i, (label, y) in enumerate(self._iter_data(data=data)):
 1893:             ax = self._get_ax(i)
 1894:             kwds = self.kwds.copy()
 1895:             if self._is_series:
 1896:                 kwds["color"] = colors
 1897:             elif isinstance(colors, dict):
 1898:                 kwds["color"] = colors[label]
 1899:             else:
 1900:                 kwds["color"] = colors[i % ncolors]
 1901: 
 1902:             errors = self._get_errorbars(label=label, index=i)
 1903:             kwds = dict(kwds, **errors)
 1904: 
 1905:             label = pprint_thing(label)
 1906:             label = self._mark_right_label(label, index=i)
 1907: 
 1908:             if (("yerr" in kwds) or ("xerr" in kwds)) and (kwds.get("ecolor") is None):
 1909:                 kwds["ecolor"] = mpl.rcParams["xtick.color"]
 1910: 
 1911:             start = 0
 1912:             if self.log and (y >= 1).all():
 1913:                 start = 1
 1914:             start = start + self._start_base
 1915: 
 1916:             kwds["align"] = self._align
 1917:             if self.subplots:
 1918:                 w = self.bar_width / 2
 1919:                 rect = self._plot(
 1920:                     ax,
 1921:                     self.ax_pos + w,
 1922:                     y,
 1923:                     self.bar_width,
 1924:                     start=start,
 1925:                     label=label,
 1926:                     log=self.log,
 1927:                     **kwds,
 1928:                 )
 1929:                 ax.set_title(label)
 1930:             elif self.stacked:
 1931:                 mask = y > 0
 1932:                 start = np.where(mask, pos_prior, neg_prior) + self._start_base
 1933:                 w = self.bar_width / 2
 1934:                 rect = self._plot(
 1935:                     ax,
 1936:                     self.ax_pos + w,
 1937:                     y,
 1938:                     self.bar_width,
 1939:                     start=start,
 1940:                     label=label,
 1941:                     log=self.log,
 1942:                     **kwds,
 1943:                 )
 1944:                 pos_prior = pos_prior + np.where(mask, y, 0)
 1945:                 neg_prior = neg_prior + np.where(mask, 0, y)
 1946:             else:
 1947:                 w = self.bar_width / K
 1948:                 rect = self._plot(
 1949:                     ax,
 1950:                     self.ax_pos + (i + 0.5) * w,
 1951:                     y,
 1952:                     w,
 1953:                     start=start,
 1954:                     label=label,
 1955:                     log=self.log,
 1956:                     **kwds,
 1957:                 )
 1958:             self._append_legend_handles_labels(rect, label)
 1959: 
 1960:     def _post_plot_logic(self, ax: Axes, data) -> None:
 1961:         if self.use_index:
 1962:             str_index = [pprint_thing(key) for key in data.index]
 1963:         else:
 1964:             str_index = [pprint_thing(key) for key in range(data.shape[0])]
 1965: 
 1966:         s_edge = self.ax_pos[0] - 0.25 + self.lim_offset
 1967:         e_edge = self.ax_pos[-1] + 0.25 + self.bar_width + self.lim_offset
 1968: 
 1969:         self._decorate_ticks(ax, self._get_index_name(), str_index, s_edge, e_edge)
 1970: 
 1971:     def _decorate_ticks(
 1972:         self,
 1973:         ax: Axes,
 1974:         name: str | None,
 1975:         ticklabels: list[str],
 1976:         start_edge: float,
 1977:         end_edge: float,
 1978:     ) -> None:
 1979:         ax.set_xlim((start_edge, end_edge))
 1980: 
 1981:         if self.xticks is not None:
 1982:             ax.set_xticks(np.array(self.xticks))
 1983:         else:
 1984:             ax.set_xticks(self.tick_pos)
 1985:             ax.set_xticklabels(ticklabels)
 1986: 
 1987:         if name is not None and self.use_index:
 1988:             ax.set_xlabel(name)
 1989: 
 1990: 
 1991: class BarhPlot(BarPlot):
 1992:     @property
 1993:     def _kind(self) -> Literal["barh"]:
 1994:         return "barh"
 1995: 
 1996:     _default_rot = 0
 1997: 
 1998:     @property
 1999:     def orientation(self) -> Literal["horizontal"]:
 2000:         return "horizontal"
 2001: 
 2002:     @property
 2003:     def _start_base(self):
 2004:         return self.left
 2005: 
 2006:     # error: Signature of "_plot" incompatible with supertype "MPLPlot"
 2007:     @classmethod
 2008:     def _plot(  # type: ignore[override]
 2009:         cls,
 2010:         ax: Axes,
 2011:         x,
 2012:         y: np.ndarray,
 2013:         w,
 2014:         start: int | npt.NDArray[np.intp] = 0,
 2015:         log: bool = False,
 2016:         **kwds,
 2017:     ):
 2018:         return ax.barh(x, y, w, left=start, log=log, **kwds)
 2019: 
 2020:     def _get_custom_index_name(self):
 2021:         return self.ylabel
 2022: 
 2023:     def _decorate_ticks(
 2024:         self,
 2025:         ax: Axes,
 2026:         name: str | None,
 2027:         ticklabels: list[str],
 2028:         start_edge: float,
 2029:         end_edge: float,
 2030:     ) -> None:
 2031:         # horizontal bars
 2032:         ax.set_ylim((start_edge, end_edge))
 2033:         ax.set_yticks(self.tick_pos)
 2034:         ax.set_yticklabels(ticklabels)
 2035:         if name is not None and self.use_index:
 2036:             ax.set_ylabel(name)
 2037:         # error: Argument 1 to "set_xlabel" of "_AxesBase" has incompatible type
 2038:         # "Hashable | None"; expected "str"
 2039:         ax.set_xlabel(self.xlabel)  # type: ignore[arg-type]
 2040: 
 2041: 
 2042: class PiePlot(MPLPlot):
 2043:     @property
 2044:     def _kind(self) -> Literal["pie"]:
 2045:         return "pie"
 2046: 
 2047:     _layout_type = "horizontal"
 2048: 
 2049:     def __init__(self, data, kind=None, **kwargs) -> None:
 2050:         data = data.fillna(value=0)
 2051:         if (data < 0).any().any():
 2052:             raise ValueError(f"{self._kind} plot doesn't allow negative values")
 2053:         MPLPlot.__init__(self, data, kind=kind, **kwargs)
 2054: 
 2055:     @classmethod
 2056:     def _validate_log_kwd(
 2057:         cls,
 2058:         kwd: str,
 2059:         value: bool | None | Literal["sym"],
 2060:     ) -> bool | None | Literal["sym"]:
 2061:         super()._validate_log_kwd(kwd=kwd, value=value)
 2062:         if value is not False:
 2063:             warnings.warn(
 2064:                 f"PiePlot ignores the '{kwd}' keyword",
 2065:                 UserWarning,
 2066:                 stacklevel=find_stack_level(),
 2067:             )
 2068:         return False
 2069: 
 2070:     def _validate_color_args(self, color, colormap) -> None:
 2071:         # TODO: warn if color is passed and ignored?
 2072:         return None
 2073: 
 2074:     def _make_plot(self, fig: Figure) -> None:
 2075:         colors = self._get_colors(num_colors=len(self.data), color_kwds="colors")
 2076:         self.kwds.setdefault("colors", colors)
 2077: 
 2078:         for i, (label, y) in enumerate(self._iter_data(data=self.data)):
 2079:             ax = self._get_ax(i)
 2080:             if label is not None:
 2081:                 label = pprint_thing(label)
 2082:                 ax.set_ylabel(label)
 2083: 
 2084:             kwds = self.kwds.copy()
 2085: 
 2086:             def blank_labeler(label, value):
 2087:                 if value == 0:
 2088:                     return ""
 2089:                 else:
 2090:                     return label
 2091: 
 2092:             idx = [pprint_thing(v) for v in self.data.index]
 2093:             labels = kwds.pop("labels", idx)
 2094:             # labels is used for each wedge's labels
 2095:             # Blank out labels for values of 0 so they don't overlap
 2096:             # with nonzero wedges
 2097:             if labels is not None:
 2098:                 blabels = [blank_labeler(left, value) for left, value in zip(labels, y)]
 2099:             else:
 2100:                 blabels = None
 2101:             results = ax.pie(y, labels=blabels, **kwds)
 2102: 
 2103:             if kwds.get("autopct", None) is not None:
 2104:                 patches, texts, autotexts = results
 2105:             else:
 2106:                 patches, texts = results
 2107:                 autotexts = []
 2108: 
 2109:             if self.fontsize is not None:
 2110:                 for t in texts + autotexts:
 2111:                     t.set_fontsize(self.fontsize)
 2112: 
 2113:             # leglabels is used for legend labels
 2114:             leglabels = labels if labels is not None else idx
 2115:             for _patch, _leglabel in zip(patches, leglabels):
 2116:                 self._append_legend_handles_labels(_patch, _leglabel)
 2117: 
 2118:     def _post_plot_logic(self, ax: Axes, data) -> None:
 2119:         pass
