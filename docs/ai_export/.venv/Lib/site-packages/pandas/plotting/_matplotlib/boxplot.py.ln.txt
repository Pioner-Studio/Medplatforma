    1: from __future__ import annotations
    2: 
    3: from typing import (
    4:     TYPE_CHECKING,
    5:     Literal,
    6:     NamedTuple,
    7: )
    8: import warnings
    9: 
   10: from matplotlib.artist import setp
   11: import numpy as np
   12: 
   13: from pandas._libs import lib
   14: from pandas.util._decorators import cache_readonly
   15: from pandas.util._exceptions import find_stack_level
   16: 
   17: from pandas.core.dtypes.common import is_dict_like
   18: from pandas.core.dtypes.generic import ABCSeries
   19: from pandas.core.dtypes.missing import remove_na_arraylike
   20: 
   21: import pandas as pd
   22: import pandas.core.common as com
   23: 
   24: from pandas.io.formats.printing import pprint_thing
   25: from pandas.plotting._matplotlib.core import (
   26:     LinePlot,
   27:     MPLPlot,
   28: )
   29: from pandas.plotting._matplotlib.groupby import create_iter_data_given_by
   30: from pandas.plotting._matplotlib.style import get_standard_colors
   31: from pandas.plotting._matplotlib.tools import (
   32:     create_subplots,
   33:     flatten_axes,
   34:     maybe_adjust_figure,
   35: )
   36: 
   37: if TYPE_CHECKING:
   38:     from collections.abc import Collection
   39: 
   40:     from matplotlib.axes import Axes
   41:     from matplotlib.figure import Figure
   42:     from matplotlib.lines import Line2D
   43: 
   44:     from pandas._typing import MatplotlibColor
   45: 
   46: 
   47: def _set_ticklabels(ax: Axes, labels: list[str], is_vertical: bool, **kwargs) -> None:
   48:     """Set the tick labels of a given axis.
   49: 
   50:     Due to https://github.com/matplotlib/matplotlib/pull/17266, we need to handle the
   51:     case of repeated ticks (due to `FixedLocator`) and thus we duplicate the number of
   52:     labels.
   53:     """
   54:     ticks = ax.get_xticks() if is_vertical else ax.get_yticks()
   55:     if len(ticks) != len(labels):
   56:         i, remainder = divmod(len(ticks), len(labels))
   57:         assert remainder == 0, remainder
   58:         labels *= i
   59:     if is_vertical:
   60:         ax.set_xticklabels(labels, **kwargs)
   61:     else:
   62:         ax.set_yticklabels(labels, **kwargs)
   63: 
   64: 
   65: class BoxPlot(LinePlot):
   66:     @property
   67:     def _kind(self) -> Literal["box"]:
   68:         return "box"
   69: 
   70:     _layout_type = "horizontal"
   71: 
   72:     _valid_return_types = (None, "axes", "dict", "both")
   73: 
   74:     class BP(NamedTuple):
   75:         # namedtuple to hold results
   76:         ax: Axes
   77:         lines: dict[str, list[Line2D]]
   78: 
   79:     def __init__(self, data, return_type: str = "axes", **kwargs) -> None:
   80:         if return_type not in self._valid_return_types:
   81:             raise ValueError("return_type must be {None, 'axes', 'dict', 'both'}")
   82: 
   83:         self.return_type = return_type
   84:         # Do not call LinePlot.__init__ which may fill nan
   85:         MPLPlot.__init__(self, data, **kwargs)  # pylint: disable=non-parent-init-called
   86: 
   87:         if self.subplots:
   88:             # Disable label ax sharing. Otherwise, all subplots shows last
   89:             # column label
   90:             if self.orientation == "vertical":
   91:                 self.sharex = False
   92:             else:
   93:                 self.sharey = False
   94: 
   95:     # error: Signature of "_plot" incompatible with supertype "MPLPlot"
   96:     @classmethod
   97:     def _plot(  # type: ignore[override]
   98:         cls, ax: Axes, y: np.ndarray, column_num=None, return_type: str = "axes", **kwds
   99:     ):
  100:         ys: np.ndarray | list[np.ndarray]
  101:         if y.ndim == 2:
  102:             ys = [remove_na_arraylike(v) for v in y]
  103:             # Boxplot fails with empty arrays, so need to add a NaN
  104:             #   if any cols are empty
  105:             # GH 8181
  106:             ys = [v if v.size > 0 else np.array([np.nan]) for v in ys]
  107:         else:
  108:             ys = remove_na_arraylike(y)
  109:         bp = ax.boxplot(ys, **kwds)
  110: 
  111:         if return_type == "dict":
  112:             return bp, bp
  113:         elif return_type == "both":
  114:             return cls.BP(ax=ax, lines=bp), bp
  115:         else:
  116:             return ax, bp
  117: 
  118:     def _validate_color_args(self, color, colormap):
  119:         if color is lib.no_default:
  120:             return None
  121: 
  122:         if colormap is not None:
  123:             warnings.warn(
  124:                 "'color' and 'colormap' cannot be used "
  125:                 "simultaneously. Using 'color'",
  126:                 stacklevel=find_stack_level(),
  127:             )
  128: 
  129:         if isinstance(color, dict):
  130:             valid_keys = ["boxes", "whiskers", "medians", "caps"]
  131:             for key in color:
  132:                 if key not in valid_keys:
  133:                     raise ValueError(
  134:                         f"color dict contains invalid key '{key}'. "
  135:                         f"The key must be either {valid_keys}"
  136:                     )
  137:         return color
  138: 
  139:     @cache_readonly
  140:     def _color_attrs(self):
  141:         # get standard colors for default
  142:         # use 2 colors by default, for box/whisker and median
  143:         # flier colors isn't needed here
  144:         # because it can be specified by ``sym`` kw
  145:         return get_standard_colors(num_colors=3, colormap=self.colormap, color=None)
  146: 
  147:     @cache_readonly
  148:     def _boxes_c(self):
  149:         return self._color_attrs[0]
  150: 
  151:     @cache_readonly
  152:     def _whiskers_c(self):
  153:         return self._color_attrs[0]
  154: 
  155:     @cache_readonly
  156:     def _medians_c(self):
  157:         return self._color_attrs[2]
  158: 
  159:     @cache_readonly
  160:     def _caps_c(self):
  161:         return self._color_attrs[0]
  162: 
  163:     def _get_colors(
  164:         self,
  165:         num_colors=None,
  166:         color_kwds: dict[str, MatplotlibColor]
  167:         | MatplotlibColor
  168:         | Collection[MatplotlibColor]
  169:         | None = "color",
  170:     ) -> None:
  171:         pass
  172: 
  173:     def maybe_color_bp(self, bp) -> None:
  174:         if isinstance(self.color, dict):
  175:             boxes = self.color.get("boxes", self._boxes_c)
  176:             whiskers = self.color.get("whiskers", self._whiskers_c)
  177:             medians = self.color.get("medians", self._medians_c)
  178:             caps = self.color.get("caps", self._caps_c)
  179:         else:
  180:             # Other types are forwarded to matplotlib
  181:             # If None, use default colors
  182:             boxes = self.color or self._boxes_c
  183:             whiskers = self.color or self._whiskers_c
  184:             medians = self.color or self._medians_c
  185:             caps = self.color or self._caps_c
  186: 
  187:         color_tup = (boxes, whiskers, medians, caps)
  188:         maybe_color_bp(bp, color_tup=color_tup, **self.kwds)
  189: 
  190:     def _make_plot(self, fig: Figure) -> None:
  191:         if self.subplots:
  192:             self._return_obj = pd.Series(dtype=object)
  193: 
  194:             # Re-create iterated data if `by` is assigned by users
  195:             data = (
  196:                 create_iter_data_given_by(self.data, self._kind)
  197:                 if self.by is not None
  198:                 else self.data
  199:             )
  200: 
  201:             # error: Argument "data" to "_iter_data" of "MPLPlot" has
  202:             # incompatible type "object"; expected "DataFrame |
  203:             # dict[Hashable, Series | DataFrame]"
  204:             for i, (label, y) in enumerate(self._iter_data(data=data)):  # type: ignore[arg-type]
  205:                 ax = self._get_ax(i)
  206:                 kwds = self.kwds.copy()
  207: 
  208:                 # When by is applied, show title for subplots to know which group it is
  209:                 # just like df.boxplot, and need to apply T on y to provide right input
  210:                 if self.by is not None:
  211:                     y = y.T
  212:                     ax.set_title(pprint_thing(label))
  213: 
  214:                     # When `by` is assigned, the ticklabels will become unique grouped
  215:                     # values, instead of label which is used as subtitle in this case.
  216:                     # error: "Index" has no attribute "levels"; maybe "nlevels"?
  217:                     levels = self.data.columns.levels  # type: ignore[attr-defined]
  218:                     ticklabels = [pprint_thing(col) for col in levels[0]]
  219:                 else:
  220:                     ticklabels = [pprint_thing(label)]
  221: 
  222:                 ret, bp = self._plot(
  223:                     ax, y, column_num=i, return_type=self.return_type, **kwds
  224:                 )
  225:                 self.maybe_color_bp(bp)
  226:                 self._return_obj[label] = ret
  227:                 _set_ticklabels(
  228:                     ax=ax, labels=ticklabels, is_vertical=self.orientation == "vertical"
  229:                 )
  230:         else:
  231:             y = self.data.values.T
  232:             ax = self._get_ax(0)
  233:             kwds = self.kwds.copy()
  234: 
  235:             ret, bp = self._plot(
  236:                 ax, y, column_num=0, return_type=self.return_type, **kwds
  237:             )
  238:             self.maybe_color_bp(bp)
  239:             self._return_obj = ret
  240: 
  241:             labels = [pprint_thing(left) for left in self.data.columns]
  242:             if not self.use_index:
  243:                 labels = [pprint_thing(key) for key in range(len(labels))]
  244:             _set_ticklabels(
  245:                 ax=ax, labels=labels, is_vertical=self.orientation == "vertical"
  246:             )
  247: 
  248:     def _make_legend(self) -> None:
  249:         pass
  250: 
  251:     def _post_plot_logic(self, ax: Axes, data) -> None:
  252:         # GH 45465: make sure that the boxplot doesn't ignore xlabel/ylabel
  253:         if self.xlabel:
  254:             ax.set_xlabel(pprint_thing(self.xlabel))
  255:         if self.ylabel:
  256:             ax.set_ylabel(pprint_thing(self.ylabel))
  257: 
  258:     @property
  259:     def orientation(self) -> Literal["horizontal", "vertical"]:
  260:         if self.kwds.get("vert", True):
  261:             return "vertical"
  262:         else:
  263:             return "horizontal"
  264: 
  265:     @property
  266:     def result(self):
  267:         if self.return_type is None:
  268:             return super().result
  269:         else:
  270:             return self._return_obj
  271: 
  272: 
  273: def maybe_color_bp(bp, color_tup, **kwds) -> None:
  274:     # GH#30346, when users specifying those arguments explicitly, our defaults
  275:     # for these four kwargs should be overridden; if not, use Pandas settings
  276:     if not kwds.get("boxprops"):
  277:         setp(bp["boxes"], color=color_tup[0], alpha=1)
  278:     if not kwds.get("whiskerprops"):
  279:         setp(bp["whiskers"], color=color_tup[1], alpha=1)
  280:     if not kwds.get("medianprops"):
  281:         setp(bp["medians"], color=color_tup[2], alpha=1)
  282:     if not kwds.get("capprops"):
  283:         setp(bp["caps"], color=color_tup[3], alpha=1)
  284: 
  285: 
  286: def _grouped_plot_by_column(
  287:     plotf,
  288:     data,
  289:     columns=None,
  290:     by=None,
  291:     numeric_only: bool = True,
  292:     grid: bool = False,
  293:     figsize: tuple[float, float] | None = None,
  294:     ax=None,
  295:     layout=None,
  296:     return_type=None,
  297:     **kwargs,
  298: ):
  299:     grouped = data.groupby(by, observed=False)
  300:     if columns is None:
  301:         if not isinstance(by, (list, tuple)):
  302:             by = [by]
  303:         columns = data._get_numeric_data().columns.difference(by)
  304:     naxes = len(columns)
  305:     fig, axes = create_subplots(
  306:         naxes=naxes,
  307:         sharex=kwargs.pop("sharex", True),
  308:         sharey=kwargs.pop("sharey", True),
  309:         figsize=figsize,
  310:         ax=ax,
  311:         layout=layout,
  312:     )
  313: 
  314:     _axes = flatten_axes(axes)
  315: 
  316:     # GH 45465: move the "by" label based on "vert"
  317:     xlabel, ylabel = kwargs.pop("xlabel", None), kwargs.pop("ylabel", None)
  318:     if kwargs.get("vert", True):
  319:         xlabel = xlabel or by
  320:     else:
  321:         ylabel = ylabel or by
  322: 
  323:     ax_values = []
  324: 
  325:     for i, col in enumerate(columns):
  326:         ax = _axes[i]
  327:         gp_col = grouped[col]
  328:         keys, values = zip(*gp_col)
  329:         re_plotf = plotf(keys, values, ax, xlabel=xlabel, ylabel=ylabel, **kwargs)
  330:         ax.set_title(col)
  331:         ax_values.append(re_plotf)
  332:         ax.grid(grid)
  333: 
  334:     result = pd.Series(ax_values, index=columns, copy=False)
  335: 
  336:     # Return axes in multiplot case, maybe revisit later # 985
  337:     if return_type is None:
  338:         result = axes
  339: 
  340:     byline = by[0] if len(by) == 1 else by
  341:     fig.suptitle(f"Boxplot grouped by {byline}")
  342:     maybe_adjust_figure(fig, bottom=0.15, top=0.9, left=0.1, right=0.9, wspace=0.2)
  343: 
  344:     return result
  345: 
  346: 
  347: def boxplot(
  348:     data,
  349:     column=None,
  350:     by=None,
  351:     ax=None,
  352:     fontsize: int | None = None,
  353:     rot: int = 0,
  354:     grid: bool = True,
  355:     figsize: tuple[float, float] | None = None,
  356:     layout=None,
  357:     return_type=None,
  358:     **kwds,
  359: ):
  360:     import matplotlib.pyplot as plt
  361: 
  362:     # validate return_type:
  363:     if return_type not in BoxPlot._valid_return_types:
  364:         raise ValueError("return_type must be {'axes', 'dict', 'both'}")
  365: 
  366:     if isinstance(data, ABCSeries):
  367:         data = data.to_frame("x")
  368:         column = "x"
  369: 
  370:     def _get_colors():
  371:         #  num_colors=3 is required as method maybe_color_bp takes the colors
  372:         #  in positions 0 and 2.
  373:         #  if colors not provided, use same defaults as DataFrame.plot.box
  374:         result = get_standard_colors(num_colors=3)
  375:         result = np.take(result, [0, 0, 2])
  376:         result = np.append(result, "k")
  377: 
  378:         colors = kwds.pop("color", None)
  379:         if colors:
  380:             if is_dict_like(colors):
  381:                 # replace colors in result array with user-specified colors
  382:                 # taken from the colors dict parameter
  383:                 # "boxes" value placed in position 0, "whiskers" in 1, etc.
  384:                 valid_keys = ["boxes", "whiskers", "medians", "caps"]
  385:                 key_to_index = dict(zip(valid_keys, range(4)))
  386:                 for key, value in colors.items():
  387:                     if key in valid_keys:
  388:                         result[key_to_index[key]] = value
  389:                     else:
  390:                         raise ValueError(
  391:                             f"color dict contains invalid key '{key}'. "
  392:                             f"The key must be either {valid_keys}"
  393:                         )
  394:             else:
  395:                 result.fill(colors)
  396: 
  397:         return result
  398: 
  399:     def plot_group(keys, values, ax: Axes, **kwds):
  400:         # GH 45465: xlabel/ylabel need to be popped out before plotting happens
  401:         xlabel, ylabel = kwds.pop("xlabel", None), kwds.pop("ylabel", None)
  402:         if xlabel:
  403:             ax.set_xlabel(pprint_thing(xlabel))
  404:         if ylabel:
  405:             ax.set_ylabel(pprint_thing(ylabel))
  406: 
  407:         keys = [pprint_thing(x) for x in keys]
  408:         values = [np.asarray(remove_na_arraylike(v), dtype=object) for v in values]
  409:         bp = ax.boxplot(values, **kwds)
  410:         if fontsize is not None:
  411:             ax.tick_params(axis="both", labelsize=fontsize)
  412: 
  413:         # GH 45465: x/y are flipped when "vert" changes
  414:         _set_ticklabels(
  415:             ax=ax, labels=keys, is_vertical=kwds.get("vert", True), rotation=rot
  416:         )
  417:         maybe_color_bp(bp, color_tup=colors, **kwds)
  418: 
  419:         # Return axes in multiplot case, maybe revisit later # 985
  420:         if return_type == "dict":
  421:             return bp
  422:         elif return_type == "both":
  423:             return BoxPlot.BP(ax=ax, lines=bp)
  424:         else:
  425:             return ax
  426: 
  427:     colors = _get_colors()
  428:     if column is None:
  429:         columns = None
  430:     elif isinstance(column, (list, tuple)):
  431:         columns = column
  432:     else:
  433:         columns = [column]
  434: 
  435:     if by is not None:
  436:         # Prefer array return type for 2-D plots to match the subplot layout
  437:         # https://github.com/pandas-dev/pandas/pull/12216#issuecomment-241175580
  438:         result = _grouped_plot_by_column(
  439:             plot_group,
  440:             data,
  441:             columns=columns,
  442:             by=by,
  443:             grid=grid,
  444:             figsize=figsize,
  445:             ax=ax,
  446:             layout=layout,
  447:             return_type=return_type,
  448:             **kwds,
  449:         )
  450:     else:
  451:         if return_type is None:
  452:             return_type = "axes"
  453:         if layout is not None:
  454:             raise ValueError("The 'layout' keyword is not supported when 'by' is None")
  455: 
  456:         if ax is None:
  457:             rc = {"figure.figsize": figsize} if figsize is not None else {}
  458:             with plt.rc_context(rc):
  459:                 ax = plt.gca()
  460:         data = data._get_numeric_data()
  461:         naxes = len(data.columns)
  462:         if naxes == 0:
  463:             raise ValueError(
  464:                 "boxplot method requires numerical columns, nothing to plot."
  465:             )
  466:         if columns is None:
  467:             columns = data.columns
  468:         else:
  469:             data = data[columns]
  470: 
  471:         result = plot_group(columns, data.values.T, ax, **kwds)
  472:         ax.grid(grid)
  473: 
  474:     return result
  475: 
  476: 
  477: def boxplot_frame(
  478:     self,
  479:     column=None,
  480:     by=None,
  481:     ax=None,
  482:     fontsize: int | None = None,
  483:     rot: int = 0,
  484:     grid: bool = True,
  485:     figsize: tuple[float, float] | None = None,
  486:     layout=None,
  487:     return_type=None,
  488:     **kwds,
  489: ):
  490:     import matplotlib.pyplot as plt
  491: 
  492:     ax = boxplot(
  493:         self,
  494:         column=column,
  495:         by=by,
  496:         ax=ax,
  497:         fontsize=fontsize,
  498:         grid=grid,
  499:         rot=rot,
  500:         figsize=figsize,
  501:         layout=layout,
  502:         return_type=return_type,
  503:         **kwds,
  504:     )
  505:     plt.draw_if_interactive()
  506:     return ax
  507: 
  508: 
  509: def boxplot_frame_groupby(
  510:     grouped,
  511:     subplots: bool = True,
  512:     column=None,
  513:     fontsize: int | None = None,
  514:     rot: int = 0,
  515:     grid: bool = True,
  516:     ax=None,
  517:     figsize: tuple[float, float] | None = None,
  518:     layout=None,
  519:     sharex: bool = False,
  520:     sharey: bool = True,
  521:     **kwds,
  522: ):
  523:     if subplots is True:
  524:         naxes = len(grouped)
  525:         fig, axes = create_subplots(
  526:             naxes=naxes,
  527:             squeeze=False,
  528:             ax=ax,
  529:             sharex=sharex,
  530:             sharey=sharey,
  531:             figsize=figsize,
  532:             layout=layout,
  533:         )
  534:         axes = flatten_axes(axes)
  535: 
  536:         ret = pd.Series(dtype=object)
  537: 
  538:         for (key, group), ax in zip(grouped, axes):
  539:             d = group.boxplot(
  540:                 ax=ax, column=column, fontsize=fontsize, rot=rot, grid=grid, **kwds
  541:             )
  542:             ax.set_title(pprint_thing(key))
  543:             ret.loc[key] = d
  544:         maybe_adjust_figure(fig, bottom=0.15, top=0.9, left=0.1, right=0.9, wspace=0.2)
  545:     else:
  546:         keys, frames = zip(*grouped)
  547:         if grouped.axis == 0:
  548:             df = pd.concat(frames, keys=keys, axis=1)
  549:         elif len(frames) > 1:
  550:             df = frames[0].join(frames[1::])
  551:         else:
  552:             df = frames[0]
  553: 
  554:         # GH 16748, DataFrameGroupby fails when subplots=False and `column` argument
  555:         # is assigned, and in this case, since `df` here becomes MI after groupby,
  556:         # so we need to couple the keys (grouped values) and column (original df
  557:         # column) together to search for subset to plot
  558:         if column is not None:
  559:             column = com.convert_to_list_like(column)
  560:             multi_key = pd.MultiIndex.from_product([keys, column])
  561:             column = list(multi_key.values)
  562:         ret = df.boxplot(
  563:             column=column,
  564:             fontsize=fontsize,
  565:             rot=rot,
  566:             grid=grid,
  567:             ax=ax,
  568:             figsize=figsize,
  569:             layout=layout,
  570:             **kwds,
  571:         )
  572:     return ret
