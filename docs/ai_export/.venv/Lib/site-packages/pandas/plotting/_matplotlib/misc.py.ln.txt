    1: from __future__ import annotations
    2: 
    3: import random
    4: from typing import TYPE_CHECKING
    5: 
    6: from matplotlib import patches
    7: import matplotlib.lines as mlines
    8: import numpy as np
    9: 
   10: from pandas.core.dtypes.missing import notna
   11: 
   12: from pandas.io.formats.printing import pprint_thing
   13: from pandas.plotting._matplotlib.style import get_standard_colors
   14: from pandas.plotting._matplotlib.tools import (
   15:     create_subplots,
   16:     do_adjust_figure,
   17:     maybe_adjust_figure,
   18:     set_ticks_props,
   19: )
   20: 
   21: if TYPE_CHECKING:
   22:     from collections.abc import Hashable
   23: 
   24:     from matplotlib.axes import Axes
   25:     from matplotlib.figure import Figure
   26: 
   27:     from pandas import (
   28:         DataFrame,
   29:         Index,
   30:         Series,
   31:     )
   32: 
   33: 
   34: def scatter_matrix(
   35:     frame: DataFrame,
   36:     alpha: float = 0.5,
   37:     figsize: tuple[float, float] | None = None,
   38:     ax=None,
   39:     grid: bool = False,
   40:     diagonal: str = "hist",
   41:     marker: str = ".",
   42:     density_kwds=None,
   43:     hist_kwds=None,
   44:     range_padding: float = 0.05,
   45:     **kwds,
   46: ):
   47:     df = frame._get_numeric_data()
   48:     n = df.columns.size
   49:     naxes = n * n
   50:     fig, axes = create_subplots(naxes=naxes, figsize=figsize, ax=ax, squeeze=False)
   51: 
   52:     # no gaps between subplots
   53:     maybe_adjust_figure(fig, wspace=0, hspace=0)
   54: 
   55:     mask = notna(df)
   56: 
   57:     marker = _get_marker_compat(marker)
   58: 
   59:     hist_kwds = hist_kwds or {}
   60:     density_kwds = density_kwds or {}
   61: 
   62:     # GH 14855
   63:     kwds.setdefault("edgecolors", "none")
   64: 
   65:     boundaries_list = []
   66:     for a in df.columns:
   67:         values = df[a].values[mask[a].values]
   68:         rmin_, rmax_ = np.min(values), np.max(values)
   69:         rdelta_ext = (rmax_ - rmin_) * range_padding / 2
   70:         boundaries_list.append((rmin_ - rdelta_ext, rmax_ + rdelta_ext))
   71: 
   72:     for i, a in enumerate(df.columns):
   73:         for j, b in enumerate(df.columns):
   74:             ax = axes[i, j]
   75: 
   76:             if i == j:
   77:                 values = df[a].values[mask[a].values]
   78: 
   79:                 # Deal with the diagonal by drawing a histogram there.
   80:                 if diagonal == "hist":
   81:                     ax.hist(values, **hist_kwds)
   82: 
   83:                 elif diagonal in ("kde", "density"):
   84:                     from scipy.stats import gaussian_kde
   85: 
   86:                     y = values
   87:                     gkde = gaussian_kde(y)
   88:                     ind = np.linspace(y.min(), y.max(), 1000)
   89:                     ax.plot(ind, gkde.evaluate(ind), **density_kwds)
   90: 
   91:                 ax.set_xlim(boundaries_list[i])
   92: 
   93:             else:
   94:                 common = (mask[a] & mask[b]).values
   95: 
   96:                 ax.scatter(
   97:                     df[b][common], df[a][common], marker=marker, alpha=alpha, **kwds
   98:                 )
   99: 
  100:                 ax.set_xlim(boundaries_list[j])
  101:                 ax.set_ylim(boundaries_list[i])
  102: 
  103:             ax.set_xlabel(b)
  104:             ax.set_ylabel(a)
  105: 
  106:             if j != 0:
  107:                 ax.yaxis.set_visible(False)
  108:             if i != n - 1:
  109:                 ax.xaxis.set_visible(False)
  110: 
  111:     if len(df.columns) > 1:
  112:         lim1 = boundaries_list[0]
  113:         locs = axes[0][1].yaxis.get_majorticklocs()
  114:         locs = locs[(lim1[0] <= locs) & (locs <= lim1[1])]
  115:         adj = (locs - lim1[0]) / (lim1[1] - lim1[0])
  116: 
  117:         lim0 = axes[0][0].get_ylim()
  118:         adj = adj * (lim0[1] - lim0[0]) + lim0[0]
  119:         axes[0][0].yaxis.set_ticks(adj)
  120: 
  121:         if np.all(locs == locs.astype(int)):
  122:             # if all ticks are int
  123:             locs = locs.astype(int)
  124:         axes[0][0].yaxis.set_ticklabels(locs)
  125: 
  126:     set_ticks_props(axes, xlabelsize=8, xrot=90, ylabelsize=8, yrot=0)
  127: 
  128:     return axes
  129: 
  130: 
  131: def _get_marker_compat(marker):
  132:     if marker not in mlines.lineMarkers:
  133:         return "o"
  134:     return marker
  135: 
  136: 
  137: def radviz(
  138:     frame: DataFrame,
  139:     class_column,
  140:     ax: Axes | None = None,
  141:     color=None,
  142:     colormap=None,
  143:     **kwds,
  144: ) -> Axes:
  145:     import matplotlib.pyplot as plt
  146: 
  147:     def normalize(series):
  148:         a = min(series)
  149:         b = max(series)
  150:         return (series - a) / (b - a)
  151: 
  152:     n = len(frame)
  153:     classes = frame[class_column].drop_duplicates()
  154:     class_col = frame[class_column]
  155:     df = frame.drop(class_column, axis=1).apply(normalize)
  156: 
  157:     if ax is None:
  158:         ax = plt.gca()
  159:         ax.set_xlim(-1, 1)
  160:         ax.set_ylim(-1, 1)
  161: 
  162:     to_plot: dict[Hashable, list[list]] = {}
  163:     colors = get_standard_colors(
  164:         num_colors=len(classes), colormap=colormap, color_type="random", color=color
  165:     )
  166: 
  167:     for kls in classes:
  168:         to_plot[kls] = [[], []]
  169: 
  170:     m = len(frame.columns) - 1
  171:     s = np.array(
  172:         [(np.cos(t), np.sin(t)) for t in [2 * np.pi * (i / m) for i in range(m)]]
  173:     )
  174: 
  175:     for i in range(n):
  176:         row = df.iloc[i].values
  177:         row_ = np.repeat(np.expand_dims(row, axis=1), 2, axis=1)
  178:         y = (s * row_).sum(axis=0) / row.sum()
  179:         kls = class_col.iat[i]
  180:         to_plot[kls][0].append(y[0])
  181:         to_plot[kls][1].append(y[1])
  182: 
  183:     for i, kls in enumerate(classes):
  184:         ax.scatter(
  185:             to_plot[kls][0],
  186:             to_plot[kls][1],
  187:             color=colors[i],
  188:             label=pprint_thing(kls),
  189:             **kwds,
  190:         )
  191:     ax.legend()
  192: 
  193:     ax.add_patch(patches.Circle((0.0, 0.0), radius=1.0, facecolor="none"))
  194: 
  195:     for xy, name in zip(s, df.columns):
  196:         ax.add_patch(patches.Circle(xy, radius=0.025, facecolor="gray"))
  197: 
  198:         if xy[0] < 0.0 and xy[1] < 0.0:
  199:             ax.text(
  200:                 xy[0] - 0.025, xy[1] - 0.025, name, ha="right", va="top", size="small"
  201:             )
  202:         elif xy[0] < 0.0 <= xy[1]:
  203:             ax.text(
  204:                 xy[0] - 0.025,
  205:                 xy[1] + 0.025,
  206:                 name,
  207:                 ha="right",
  208:                 va="bottom",
  209:                 size="small",
  210:             )
  211:         elif xy[1] < 0.0 <= xy[0]:
  212:             ax.text(
  213:                 xy[0] + 0.025, xy[1] - 0.025, name, ha="left", va="top", size="small"
  214:             )
  215:         elif xy[0] >= 0.0 and xy[1] >= 0.0:
  216:             ax.text(
  217:                 xy[0] + 0.025, xy[1] + 0.025, name, ha="left", va="bottom", size="small"
  218:             )
  219: 
  220:     ax.axis("equal")
  221:     return ax
  222: 
  223: 
  224: def andrews_curves(
  225:     frame: DataFrame,
  226:     class_column,
  227:     ax: Axes | None = None,
  228:     samples: int = 200,
  229:     color=None,
  230:     colormap=None,
  231:     **kwds,
  232: ) -> Axes:
  233:     import matplotlib.pyplot as plt
  234: 
  235:     def function(amplitudes):
  236:         def f(t):
  237:             x1 = amplitudes[0]
  238:             result = x1 / np.sqrt(2.0)
  239: 
  240:             # Take the rest of the coefficients and resize them
  241:             # appropriately. Take a copy of amplitudes as otherwise numpy
  242:             # deletes the element from amplitudes itself.
  243:             coeffs = np.delete(np.copy(amplitudes), 0)
  244:             coeffs = np.resize(coeffs, (int((coeffs.size + 1) / 2), 2))
  245: 
  246:             # Generate the harmonics and arguments for the sin and cos
  247:             # functions.
  248:             harmonics = np.arange(0, coeffs.shape[0]) + 1
  249:             trig_args = np.outer(harmonics, t)
  250: 
  251:             result += np.sum(
  252:                 coeffs[:, 0, np.newaxis] * np.sin(trig_args)
  253:                 + coeffs[:, 1, np.newaxis] * np.cos(trig_args),
  254:                 axis=0,
  255:             )
  256:             return result
  257: 
  258:         return f
  259: 
  260:     n = len(frame)
  261:     class_col = frame[class_column]
  262:     classes = frame[class_column].drop_duplicates()
  263:     df = frame.drop(class_column, axis=1)
  264:     t = np.linspace(-np.pi, np.pi, samples)
  265:     used_legends: set[str] = set()
  266: 
  267:     color_values = get_standard_colors(
  268:         num_colors=len(classes), colormap=colormap, color_type="random", color=color
  269:     )
  270:     colors = dict(zip(classes, color_values))
  271:     if ax is None:
  272:         ax = plt.gca()
  273:         ax.set_xlim(-np.pi, np.pi)
  274:     for i in range(n):
  275:         row = df.iloc[i].values
  276:         f = function(row)
  277:         y = f(t)
  278:         kls = class_col.iat[i]
  279:         label = pprint_thing(kls)
  280:         if label not in used_legends:
  281:             used_legends.add(label)
  282:             ax.plot(t, y, color=colors[kls], label=label, **kwds)
  283:         else:
  284:             ax.plot(t, y, color=colors[kls], **kwds)
  285: 
  286:     ax.legend(loc="upper right")
  287:     ax.grid()
  288:     return ax
  289: 
  290: 
  291: def bootstrap_plot(
  292:     series: Series,
  293:     fig: Figure | None = None,
  294:     size: int = 50,
  295:     samples: int = 500,
  296:     **kwds,
  297: ) -> Figure:
  298:     import matplotlib.pyplot as plt
  299: 
  300:     # TODO: is the failure mentioned below still relevant?
  301:     # random.sample(ndarray, int) fails on python 3.3, sigh
  302:     data = list(series.values)
  303:     samplings = [random.sample(data, size) for _ in range(samples)]
  304: 
  305:     means = np.array([np.mean(sampling) for sampling in samplings])
  306:     medians = np.array([np.median(sampling) for sampling in samplings])
  307:     midranges = np.array(
  308:         [(min(sampling) + max(sampling)) * 0.5 for sampling in samplings]
  309:     )
  310:     if fig is None:
  311:         fig = plt.figure()
  312:     x = list(range(samples))
  313:     axes = []
  314:     ax1 = fig.add_subplot(2, 3, 1)
  315:     ax1.set_xlabel("Sample")
  316:     axes.append(ax1)
  317:     ax1.plot(x, means, **kwds)
  318:     ax2 = fig.add_subplot(2, 3, 2)
  319:     ax2.set_xlabel("Sample")
  320:     axes.append(ax2)
  321:     ax2.plot(x, medians, **kwds)
  322:     ax3 = fig.add_subplot(2, 3, 3)
  323:     ax3.set_xlabel("Sample")
  324:     axes.append(ax3)
  325:     ax3.plot(x, midranges, **kwds)
  326:     ax4 = fig.add_subplot(2, 3, 4)
  327:     ax4.set_xlabel("Mean")
  328:     axes.append(ax4)
  329:     ax4.hist(means, **kwds)
  330:     ax5 = fig.add_subplot(2, 3, 5)
  331:     ax5.set_xlabel("Median")
  332:     axes.append(ax5)
  333:     ax5.hist(medians, **kwds)
  334:     ax6 = fig.add_subplot(2, 3, 6)
  335:     ax6.set_xlabel("Midrange")
  336:     axes.append(ax6)
  337:     ax6.hist(midranges, **kwds)
  338:     for axis in axes:
  339:         plt.setp(axis.get_xticklabels(), fontsize=8)
  340:         plt.setp(axis.get_yticklabels(), fontsize=8)
  341:     if do_adjust_figure(fig):
  342:         plt.tight_layout()
  343:     return fig
  344: 
  345: 
  346: def parallel_coordinates(
  347:     frame: DataFrame,
  348:     class_column,
  349:     cols=None,
  350:     ax: Axes | None = None,
  351:     color=None,
  352:     use_columns: bool = False,
  353:     xticks=None,
  354:     colormap=None,
  355:     axvlines: bool = True,
  356:     axvlines_kwds=None,
  357:     sort_labels: bool = False,
  358:     **kwds,
  359: ) -> Axes:
  360:     import matplotlib.pyplot as plt
  361: 
  362:     if axvlines_kwds is None:
  363:         axvlines_kwds = {"linewidth": 1, "color": "black"}
  364: 
  365:     n = len(frame)
  366:     classes = frame[class_column].drop_duplicates()
  367:     class_col = frame[class_column]
  368: 
  369:     if cols is None:
  370:         df = frame.drop(class_column, axis=1)
  371:     else:
  372:         df = frame[cols]
  373: 
  374:     used_legends: set[str] = set()
  375: 
  376:     ncols = len(df.columns)
  377: 
  378:     # determine values to use for xticks
  379:     x: list[int] | Index
  380:     if use_columns is True:
  381:         if not np.all(np.isreal(list(df.columns))):
  382:             raise ValueError("Columns must be numeric to be used as xticks")
  383:         x = df.columns
  384:     elif xticks is not None:
  385:         if not np.all(np.isreal(xticks)):
  386:             raise ValueError("xticks specified must be numeric")
  387:         if len(xticks) != ncols:
  388:             raise ValueError("Length of xticks must match number of columns")
  389:         x = xticks
  390:     else:
  391:         x = list(range(ncols))
  392: 
  393:     if ax is None:
  394:         ax = plt.gca()
  395: 
  396:     color_values = get_standard_colors(
  397:         num_colors=len(classes), colormap=colormap, color_type="random", color=color
  398:     )
  399: 
  400:     if sort_labels:
  401:         classes = sorted(classes)
  402:         color_values = sorted(color_values)
  403:     colors = dict(zip(classes, color_values))
  404: 
  405:     for i in range(n):
  406:         y = df.iloc[i].values
  407:         kls = class_col.iat[i]
  408:         label = pprint_thing(kls)
  409:         if label not in used_legends:
  410:             used_legends.add(label)
  411:             ax.plot(x, y, color=colors[kls], label=label, **kwds)
  412:         else:
  413:             ax.plot(x, y, color=colors[kls], **kwds)
  414: 
  415:     if axvlines:
  416:         for i in x:
  417:             ax.axvline(i, **axvlines_kwds)
  418: 
  419:     ax.set_xticks(x)
  420:     ax.set_xticklabels(df.columns)
  421:     ax.set_xlim(x[0], x[-1])
  422:     ax.legend(loc="upper right")
  423:     ax.grid()
  424:     return ax
  425: 
  426: 
  427: def lag_plot(series: Series, lag: int = 1, ax: Axes | None = None, **kwds) -> Axes:
  428:     # workaround because `c='b'` is hardcoded in matplotlib's scatter method
  429:     import matplotlib.pyplot as plt
  430: 
  431:     kwds.setdefault("c", plt.rcParams["patch.facecolor"])
  432: 
  433:     data = series.values
  434:     y1 = data[:-lag]
  435:     y2 = data[lag:]
  436:     if ax is None:
  437:         ax = plt.gca()
  438:     ax.set_xlabel("y(t)")
  439:     ax.set_ylabel(f"y(t + {lag})")
  440:     ax.scatter(y1, y2, **kwds)
  441:     return ax
  442: 
  443: 
  444: def autocorrelation_plot(series: Series, ax: Axes | None = None, **kwds) -> Axes:
  445:     import matplotlib.pyplot as plt
  446: 
  447:     n = len(series)
  448:     data = np.asarray(series)
  449:     if ax is None:
  450:         ax = plt.gca()
  451:         ax.set_xlim(1, n)
  452:         ax.set_ylim(-1.0, 1.0)
  453:     mean = np.mean(data)
  454:     c0 = np.sum((data - mean) ** 2) / n
  455: 
  456:     def r(h):
  457:         return ((data[: n - h] - mean) * (data[h:] - mean)).sum() / n / c0
  458: 
  459:     x = np.arange(n) + 1
  460:     y = [r(loc) for loc in x]
  461:     z95 = 1.959963984540054
  462:     z99 = 2.5758293035489004
  463:     ax.axhline(y=z99 / np.sqrt(n), linestyle="--", color="grey")
  464:     ax.axhline(y=z95 / np.sqrt(n), color="grey")
  465:     ax.axhline(y=0.0, color="black")
  466:     ax.axhline(y=-z95 / np.sqrt(n), color="grey")
  467:     ax.axhline(y=-z99 / np.sqrt(n), linestyle="--", color="grey")
  468:     ax.set_xlabel("Lag")
  469:     ax.set_ylabel("Autocorrelation")
  470:     ax.plot(x, y, **kwds)
  471:     if "label" in kwds:
  472:         ax.legend()
  473:     ax.grid()
  474:     return ax
  475: 
  476: 
  477: def unpack_single_str_list(keys):
  478:     # GH 42795
  479:     if isinstance(keys, list) and len(keys) == 1:
  480:         keys = keys[0]
  481:     return keys
