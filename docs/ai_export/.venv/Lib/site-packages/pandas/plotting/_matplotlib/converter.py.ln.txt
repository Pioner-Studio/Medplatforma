    1: from __future__ import annotations
    2: 
    3: import contextlib
    4: import datetime as pydt
    5: from datetime import (
    6:     datetime,
    7:     timedelta,
    8:     tzinfo,
    9: )
   10: import functools
   11: from typing import (
   12:     TYPE_CHECKING,
   13:     Any,
   14:     cast,
   15: )
   16: import warnings
   17: 
   18: import matplotlib.dates as mdates
   19: from matplotlib.ticker import (
   20:     AutoLocator,
   21:     Formatter,
   22:     Locator,
   23: )
   24: from matplotlib.transforms import nonsingular
   25: import matplotlib.units as munits
   26: import numpy as np
   27: 
   28: from pandas._libs import lib
   29: from pandas._libs.tslibs import (
   30:     Timestamp,
   31:     to_offset,
   32: )
   33: from pandas._libs.tslibs.dtypes import (
   34:     FreqGroup,
   35:     periods_per_day,
   36: )
   37: from pandas._typing import (
   38:     F,
   39:     npt,
   40: )
   41: 
   42: from pandas.core.dtypes.common import (
   43:     is_float,
   44:     is_float_dtype,
   45:     is_integer,
   46:     is_integer_dtype,
   47:     is_nested_list_like,
   48: )
   49: 
   50: from pandas import (
   51:     Index,
   52:     Series,
   53:     get_option,
   54: )
   55: import pandas.core.common as com
   56: from pandas.core.indexes.datetimes import date_range
   57: from pandas.core.indexes.period import (
   58:     Period,
   59:     PeriodIndex,
   60:     period_range,
   61: )
   62: import pandas.core.tools.datetimes as tools
   63: 
   64: if TYPE_CHECKING:
   65:     from collections.abc import Generator
   66: 
   67:     from matplotlib.axis import Axis
   68: 
   69:     from pandas._libs.tslibs.offsets import BaseOffset
   70: 
   71: 
   72: _mpl_units = {}  # Cache for units overwritten by us
   73: 
   74: 
   75: def get_pairs():
   76:     pairs = [
   77:         (Timestamp, DatetimeConverter),
   78:         (Period, PeriodConverter),
   79:         (pydt.datetime, DatetimeConverter),
   80:         (pydt.date, DatetimeConverter),
   81:         (pydt.time, TimeConverter),
   82:         (np.datetime64, DatetimeConverter),
   83:     ]
   84:     return pairs
   85: 
   86: 
   87: def register_pandas_matplotlib_converters(func: F) -> F:
   88:     """
   89:     Decorator applying pandas_converters.
   90:     """
   91: 
   92:     @functools.wraps(func)
   93:     def wrapper(*args, **kwargs):
   94:         with pandas_converters():
   95:             return func(*args, **kwargs)
   96: 
   97:     return cast(F, wrapper)
   98: 
   99: 
  100: @contextlib.contextmanager
  101: def pandas_converters() -> Generator[None, None, None]:
  102:     """
  103:     Context manager registering pandas' converters for a plot.
  104: 
  105:     See Also
  106:     --------
  107:     register_pandas_matplotlib_converters : Decorator that applies this.
  108:     """
  109:     value = get_option("plotting.matplotlib.register_converters")
  110: 
  111:     if value:
  112:         # register for True or "auto"
  113:         register()
  114:     try:
  115:         yield
  116:     finally:
  117:         if value == "auto":
  118:             # only deregister for "auto"
  119:             deregister()
  120: 
  121: 
  122: def register() -> None:
  123:     pairs = get_pairs()
  124:     for type_, cls in pairs:
  125:         # Cache previous converter if present
  126:         if type_ in munits.registry and not isinstance(munits.registry[type_], cls):
  127:             previous = munits.registry[type_]
  128:             _mpl_units[type_] = previous
  129:         # Replace with pandas converter
  130:         munits.registry[type_] = cls()
  131: 
  132: 
  133: def deregister() -> None:
  134:     # Renamed in pandas.plotting.__init__
  135:     for type_, cls in get_pairs():
  136:         # We use type to catch our classes directly, no inheritance
  137:         if type(munits.registry.get(type_)) is cls:
  138:             munits.registry.pop(type_)
  139: 
  140:     # restore the old keys
  141:     for unit, formatter in _mpl_units.items():
  142:         if type(formatter) not in {DatetimeConverter, PeriodConverter, TimeConverter}:
  143:             # make it idempotent by excluding ours.
  144:             munits.registry[unit] = formatter
  145: 
  146: 
  147: def _to_ordinalf(tm: pydt.time) -> float:
  148:     tot_sec = tm.hour * 3600 + tm.minute * 60 + tm.second + tm.microsecond / 10**6
  149:     return tot_sec
  150: 
  151: 
  152: def time2num(d):
  153:     if isinstance(d, str):
  154:         parsed = Timestamp(d)
  155:         return _to_ordinalf(parsed.time())
  156:     if isinstance(d, pydt.time):
  157:         return _to_ordinalf(d)
  158:     return d
  159: 
  160: 
  161: class TimeConverter(munits.ConversionInterface):
  162:     @staticmethod
  163:     def convert(value, unit, axis):
  164:         valid_types = (str, pydt.time)
  165:         if isinstance(value, valid_types) or is_integer(value) or is_float(value):
  166:             return time2num(value)
  167:         if isinstance(value, Index):
  168:             return value.map(time2num)
  169:         if isinstance(value, (list, tuple, np.ndarray, Index)):
  170:             return [time2num(x) for x in value]
  171:         return value
  172: 
  173:     @staticmethod
  174:     def axisinfo(unit, axis) -> munits.AxisInfo | None:
  175:         if unit != "time":
  176:             return None
  177: 
  178:         majloc = AutoLocator()
  179:         majfmt = TimeFormatter(majloc)
  180:         return munits.AxisInfo(majloc=majloc, majfmt=majfmt, label="time")
  181: 
  182:     @staticmethod
  183:     def default_units(x, axis) -> str:
  184:         return "time"
  185: 
  186: 
  187: # time formatter
  188: class TimeFormatter(Formatter):
  189:     def __init__(self, locs) -> None:
  190:         self.locs = locs
  191: 
  192:     def __call__(self, x, pos: int | None = 0) -> str:
  193:         """
  194:         Return the time of day as a formatted string.
  195: 
  196:         Parameters
  197:         ----------
  198:         x : float
  199:             The time of day specified as seconds since 00:00 (midnight),
  200:             with up to microsecond precision.
  201:         pos
  202:             Unused
  203: 
  204:         Returns
  205:         -------
  206:         str
  207:             A string in HH:MM:SS.mmmuuu format. Microseconds,
  208:             milliseconds and seconds are only displayed if non-zero.
  209:         """
  210:         fmt = "%H:%M:%S.%f"
  211:         s = int(x)
  212:         msus = round((x - s) * 10**6)
  213:         ms = msus // 1000
  214:         us = msus % 1000
  215:         m, s = divmod(s, 60)
  216:         h, m = divmod(m, 60)
  217:         _, h = divmod(h, 24)
  218:         if us != 0:
  219:             return pydt.time(h, m, s, msus).strftime(fmt)
  220:         elif ms != 0:
  221:             return pydt.time(h, m, s, msus).strftime(fmt)[:-3]
  222:         elif s != 0:
  223:             return pydt.time(h, m, s).strftime("%H:%M:%S")
  224: 
  225:         return pydt.time(h, m).strftime("%H:%M")
  226: 
  227: 
  228: # Period Conversion
  229: 
  230: 
  231: class PeriodConverter(mdates.DateConverter):
  232:     @staticmethod
  233:     def convert(values, units, axis):
  234:         if is_nested_list_like(values):
  235:             values = [PeriodConverter._convert_1d(v, units, axis) for v in values]
  236:         else:
  237:             values = PeriodConverter._convert_1d(values, units, axis)
  238:         return values
  239: 
  240:     @staticmethod
  241:     def _convert_1d(values, units, axis):
  242:         if not hasattr(axis, "freq"):
  243:             raise TypeError("Axis must have `freq` set to convert to Periods")
  244:         valid_types = (str, datetime, Period, pydt.date, pydt.time, np.datetime64)
  245:         with warnings.catch_warnings():
  246:             warnings.filterwarnings(
  247:                 "ignore", "Period with BDay freq is deprecated", category=FutureWarning
  248:             )
  249:             warnings.filterwarnings(
  250:                 "ignore", r"PeriodDtype\[B\] is deprecated", category=FutureWarning
  251:             )
  252:             if (
  253:                 isinstance(values, valid_types)
  254:                 or is_integer(values)
  255:                 or is_float(values)
  256:             ):
  257:                 return get_datevalue(values, axis.freq)
  258:             elif isinstance(values, PeriodIndex):
  259:                 return values.asfreq(axis.freq).asi8
  260:             elif isinstance(values, Index):
  261:                 return values.map(lambda x: get_datevalue(x, axis.freq))
  262:             elif lib.infer_dtype(values, skipna=False) == "period":
  263:                 # https://github.com/pandas-dev/pandas/issues/24304
  264:                 # convert ndarray[period] -> PeriodIndex
  265:                 return PeriodIndex(values, freq=axis.freq).asi8
  266:             elif isinstance(values, (list, tuple, np.ndarray, Index)):
  267:                 return [get_datevalue(x, axis.freq) for x in values]
  268:         return values
  269: 
  270: 
  271: def get_datevalue(date, freq):
  272:     if isinstance(date, Period):
  273:         return date.asfreq(freq).ordinal
  274:     elif isinstance(date, (str, datetime, pydt.date, pydt.time, np.datetime64)):
  275:         return Period(date, freq).ordinal
  276:     elif (
  277:         is_integer(date)
  278:         or is_float(date)
  279:         or (isinstance(date, (np.ndarray, Index)) and (date.size == 1))
  280:     ):
  281:         return date
  282:     elif date is None:
  283:         return None
  284:     raise ValueError(f"Unrecognizable date '{date}'")
  285: 
  286: 
  287: # Datetime Conversion
  288: class DatetimeConverter(mdates.DateConverter):
  289:     @staticmethod
  290:     def convert(values, unit, axis):
  291:         # values might be a 1-d array, or a list-like of arrays.
  292:         if is_nested_list_like(values):
  293:             values = [DatetimeConverter._convert_1d(v, unit, axis) for v in values]
  294:         else:
  295:             values = DatetimeConverter._convert_1d(values, unit, axis)
  296:         return values
  297: 
  298:     @staticmethod
  299:     def _convert_1d(values, unit, axis):
  300:         def try_parse(values):
  301:             try:
  302:                 return mdates.date2num(tools.to_datetime(values))
  303:             except Exception:
  304:                 return values
  305: 
  306:         if isinstance(values, (datetime, pydt.date, np.datetime64, pydt.time)):
  307:             return mdates.date2num(values)
  308:         elif is_integer(values) or is_float(values):
  309:             return values
  310:         elif isinstance(values, str):
  311:             return try_parse(values)
  312:         elif isinstance(values, (list, tuple, np.ndarray, Index, Series)):
  313:             if isinstance(values, Series):
  314:                 # https://github.com/matplotlib/matplotlib/issues/11391
  315:                 # Series was skipped. Convert to DatetimeIndex to get asi8
  316:                 values = Index(values)
  317:             if isinstance(values, Index):
  318:                 values = values.values
  319:             if not isinstance(values, np.ndarray):
  320:                 values = com.asarray_tuplesafe(values)
  321: 
  322:             if is_integer_dtype(values) or is_float_dtype(values):
  323:                 return values
  324: 
  325:             try:
  326:                 values = tools.to_datetime(values)
  327:             except Exception:
  328:                 pass
  329: 
  330:             values = mdates.date2num(values)
  331: 
  332:         return values
  333: 
  334:     @staticmethod
  335:     def axisinfo(unit: tzinfo | None, axis) -> munits.AxisInfo:
  336:         """
  337:         Return the :class:`~matplotlib.units.AxisInfo` for *unit*.
  338: 
  339:         *unit* is a tzinfo instance or None.
  340:         The *axis* argument is required but not used.
  341:         """
  342:         tz = unit
  343: 
  344:         majloc = PandasAutoDateLocator(tz=tz)
  345:         majfmt = PandasAutoDateFormatter(majloc, tz=tz)
  346:         datemin = pydt.date(2000, 1, 1)
  347:         datemax = pydt.date(2010, 1, 1)
  348: 
  349:         return munits.AxisInfo(
  350:             majloc=majloc, majfmt=majfmt, label="", default_limits=(datemin, datemax)
  351:         )
  352: 
  353: 
  354: class PandasAutoDateFormatter(mdates.AutoDateFormatter):
  355:     def __init__(self, locator, tz=None, defaultfmt: str = "%Y-%m-%d") -> None:
  356:         mdates.AutoDateFormatter.__init__(self, locator, tz, defaultfmt)
  357: 
  358: 
  359: class PandasAutoDateLocator(mdates.AutoDateLocator):
  360:     def get_locator(self, dmin, dmax):
  361:         """Pick the best locator based on a distance."""
  362:         tot_sec = (dmax - dmin).total_seconds()
  363: 
  364:         if abs(tot_sec) < self.minticks:
  365:             self._freq = -1
  366:             locator = MilliSecondLocator(self.tz)
  367:             locator.set_axis(self.axis)
  368: 
  369:             # error: Item "None" of "Axis | _DummyAxis | _AxisWrapper | None"
  370:             # has no attribute "get_data_interval"
  371:             locator.axis.set_view_interval(  # type: ignore[union-attr]
  372:                 *self.axis.get_view_interval()  # type: ignore[union-attr]
  373:             )
  374:             locator.axis.set_data_interval(  # type: ignore[union-attr]
  375:                 *self.axis.get_data_interval()  # type: ignore[union-attr]
  376:             )
  377:             return locator
  378: 
  379:         return mdates.AutoDateLocator.get_locator(self, dmin, dmax)
  380: 
  381:     def _get_unit(self):
  382:         return MilliSecondLocator.get_unit_generic(self._freq)
  383: 
  384: 
  385: class MilliSecondLocator(mdates.DateLocator):
  386:     UNIT = 1.0 / (24 * 3600 * 1000)
  387: 
  388:     def __init__(self, tz) -> None:
  389:         mdates.DateLocator.__init__(self, tz)
  390:         self._interval = 1.0
  391: 
  392:     def _get_unit(self):
  393:         return self.get_unit_generic(-1)
  394: 
  395:     @staticmethod
  396:     def get_unit_generic(freq):
  397:         unit = mdates.RRuleLocator.get_unit_generic(freq)
  398:         if unit < 0:
  399:             return MilliSecondLocator.UNIT
  400:         return unit
  401: 
  402:     def __call__(self):
  403:         # if no data have been set, this will tank with a ValueError
  404:         try:
  405:             dmin, dmax = self.viewlim_to_dt()
  406:         except ValueError:
  407:             return []
  408: 
  409:         # We need to cap at the endpoints of valid datetime
  410:         nmax, nmin = mdates.date2num((dmax, dmin))
  411: 
  412:         num = (nmax - nmin) * 86400 * 1000
  413:         max_millis_ticks = 6
  414:         for interval in [1, 10, 50, 100, 200, 500]:
  415:             if num <= interval * (max_millis_ticks - 1):
  416:                 self._interval = interval
  417:                 break
  418:             # We went through the whole loop without breaking, default to 1
  419:             self._interval = 1000.0
  420: 
  421:         estimate = (nmax - nmin) / (self._get_unit() * self._get_interval())
  422: 
  423:         if estimate > self.MAXTICKS * 2:
  424:             raise RuntimeError(
  425:                 "MillisecondLocator estimated to generate "
  426:                 f"{estimate:d} ticks from {dmin} to {dmax}: exceeds Locator.MAXTICKS"
  427:                 f"* 2 ({self.MAXTICKS * 2:d}) "
  428:             )
  429: 
  430:         interval = self._get_interval()
  431:         freq = f"{interval}ms"
  432:         tz = self.tz.tzname(None)
  433:         st = dmin.replace(tzinfo=None)
  434:         ed = dmin.replace(tzinfo=None)
  435:         all_dates = date_range(start=st, end=ed, freq=freq, tz=tz).astype(object)
  436: 
  437:         try:
  438:             if len(all_dates) > 0:
  439:                 locs = self.raise_if_exceeds(mdates.date2num(all_dates))
  440:                 return locs
  441:         except Exception:  # pragma: no cover
  442:             pass
  443: 
  444:         lims = mdates.date2num([dmin, dmax])
  445:         return lims
  446: 
  447:     def _get_interval(self):
  448:         return self._interval
  449: 
  450:     def autoscale(self):
  451:         """
  452:         Set the view limits to include the data range.
  453:         """
  454:         # We need to cap at the endpoints of valid datetime
  455:         dmin, dmax = self.datalim_to_dt()
  456: 
  457:         vmin = mdates.date2num(dmin)
  458:         vmax = mdates.date2num(dmax)
  459: 
  460:         return self.nonsingular(vmin, vmax)
  461: 
  462: 
  463: def _from_ordinal(x, tz: tzinfo | None = None) -> datetime:
  464:     ix = int(x)
  465:     dt = datetime.fromordinal(ix)
  466:     remainder = float(x) - ix
  467:     hour, remainder = divmod(24 * remainder, 1)
  468:     minute, remainder = divmod(60 * remainder, 1)
  469:     second, remainder = divmod(60 * remainder, 1)
  470:     microsecond = int(1_000_000 * remainder)
  471:     if microsecond < 10:
  472:         microsecond = 0  # compensate for rounding errors
  473:     dt = datetime(
  474:         dt.year, dt.month, dt.day, int(hour), int(minute), int(second), microsecond
  475:     )
  476:     if tz is not None:
  477:         dt = dt.astimezone(tz)
  478: 
  479:     if microsecond > 999990:  # compensate for rounding errors
  480:         dt += timedelta(microseconds=1_000_000 - microsecond)
  481: 
  482:     return dt
  483: 
  484: 
  485: # Fixed frequency dynamic tick locators and formatters
  486: 
  487: # -------------------------------------------------------------------------
  488: # --- Locators ---
  489: # -------------------------------------------------------------------------
  490: 
  491: 
  492: def _get_default_annual_spacing(nyears) -> tuple[int, int]:
  493:     """
  494:     Returns a default spacing between consecutive ticks for annual data.
  495:     """
  496:     if nyears < 11:
  497:         (min_spacing, maj_spacing) = (1, 1)
  498:     elif nyears < 20:
  499:         (min_spacing, maj_spacing) = (1, 2)
  500:     elif nyears < 50:
  501:         (min_spacing, maj_spacing) = (1, 5)
  502:     elif nyears < 100:
  503:         (min_spacing, maj_spacing) = (5, 10)
  504:     elif nyears < 200:
  505:         (min_spacing, maj_spacing) = (5, 25)
  506:     elif nyears < 600:
  507:         (min_spacing, maj_spacing) = (10, 50)
  508:     else:
  509:         factor = nyears // 1000 + 1
  510:         (min_spacing, maj_spacing) = (factor * 20, factor * 100)
  511:     return (min_spacing, maj_spacing)
  512: 
  513: 
  514: def _period_break(dates: PeriodIndex, period: str) -> npt.NDArray[np.intp]:
  515:     """
  516:     Returns the indices where the given period changes.
  517: 
  518:     Parameters
  519:     ----------
  520:     dates : PeriodIndex
  521:         Array of intervals to monitor.
  522:     period : str
  523:         Name of the period to monitor.
  524:     """
  525:     mask = _period_break_mask(dates, period)
  526:     return np.nonzero(mask)[0]
  527: 
  528: 
  529: def _period_break_mask(dates: PeriodIndex, period: str) -> npt.NDArray[np.bool_]:
  530:     current = getattr(dates, period)
  531:     previous = getattr(dates - 1 * dates.freq, period)
  532:     return current != previous
  533: 
  534: 
  535: def has_level_label(label_flags: npt.NDArray[np.intp], vmin: float) -> bool:
  536:     """
  537:     Returns true if the ``label_flags`` indicate there is at least one label
  538:     for this level.
  539: 
  540:     if the minimum view limit is not an exact integer, then the first tick
  541:     label won't be shown, so we must adjust for that.
  542:     """
  543:     if label_flags.size == 0 or (
  544:         label_flags.size == 1 and label_flags[0] == 0 and vmin % 1 > 0.0
  545:     ):
  546:         return False
  547:     else:
  548:         return True
  549: 
  550: 
  551: def _get_periods_per_ymd(freq: BaseOffset) -> tuple[int, int, int]:
  552:     # error: "BaseOffset" has no attribute "_period_dtype_code"
  553:     dtype_code = freq._period_dtype_code  # type: ignore[attr-defined]
  554:     freq_group = FreqGroup.from_period_dtype_code(dtype_code)
  555: 
  556:     ppd = -1  # placeholder for above-day freqs
  557: 
  558:     if dtype_code >= FreqGroup.FR_HR.value:
  559:         # error: "BaseOffset" has no attribute "_creso"
  560:         ppd = periods_per_day(freq._creso)  # type: ignore[attr-defined]
  561:         ppm = 28 * ppd
  562:         ppy = 365 * ppd
  563:     elif freq_group == FreqGroup.FR_BUS:
  564:         ppm = 19
  565:         ppy = 261
  566:     elif freq_group == FreqGroup.FR_DAY:
  567:         ppm = 28
  568:         ppy = 365
  569:     elif freq_group == FreqGroup.FR_WK:
  570:         ppm = 3
  571:         ppy = 52
  572:     elif freq_group == FreqGroup.FR_MTH:
  573:         ppm = 1
  574:         ppy = 12
  575:     elif freq_group == FreqGroup.FR_QTR:
  576:         ppm = -1  # placerholder
  577:         ppy = 4
  578:     elif freq_group == FreqGroup.FR_ANN:
  579:         ppm = -1  # placeholder
  580:         ppy = 1
  581:     else:
  582:         raise NotImplementedError(f"Unsupported frequency: {dtype_code}")
  583: 
  584:     return ppd, ppm, ppy
  585: 
  586: 
  587: def _daily_finder(vmin, vmax, freq: BaseOffset) -> np.ndarray:
  588:     # error: "BaseOffset" has no attribute "_period_dtype_code"
  589:     dtype_code = freq._period_dtype_code  # type: ignore[attr-defined]
  590: 
  591:     periodsperday, periodspermonth, periodsperyear = _get_periods_per_ymd(freq)
  592: 
  593:     # save this for later usage
  594:     vmin_orig = vmin
  595:     (vmin, vmax) = (int(vmin), int(vmax))
  596:     span = vmax - vmin + 1
  597: 
  598:     with warnings.catch_warnings():
  599:         warnings.filterwarnings(
  600:             "ignore", "Period with BDay freq is deprecated", category=FutureWarning
  601:         )
  602:         warnings.filterwarnings(
  603:             "ignore", r"PeriodDtype\[B\] is deprecated", category=FutureWarning
  604:         )
  605:         dates_ = period_range(
  606:             start=Period(ordinal=vmin, freq=freq),
  607:             end=Period(ordinal=vmax, freq=freq),
  608:             freq=freq,
  609:         )
  610: 
  611:     # Initialize the output
  612:     info = np.zeros(
  613:         span, dtype=[("val", np.int64), ("maj", bool), ("min", bool), ("fmt", "|S20")]
  614:     )
  615:     info["val"][:] = dates_.asi8
  616:     info["fmt"][:] = ""
  617:     info["maj"][[0, -1]] = True
  618:     # .. and set some shortcuts
  619:     info_maj = info["maj"]
  620:     info_min = info["min"]
  621:     info_fmt = info["fmt"]
  622: 
  623:     def first_label(label_flags):
  624:         if (label_flags[0] == 0) and (label_flags.size > 1) and ((vmin_orig % 1) > 0.0):
  625:             return label_flags[1]
  626:         else:
  627:             return label_flags[0]
  628: 
  629:     # Case 1. Less than a month
  630:     if span <= periodspermonth:
  631:         day_start = _period_break(dates_, "day")
  632:         month_start = _period_break(dates_, "month")
  633:         year_start = _period_break(dates_, "year")
  634: 
  635:         def _hour_finder(label_interval: int, force_year_start: bool) -> None:
  636:             target = dates_.hour
  637:             mask = _period_break_mask(dates_, "hour")
  638:             info_maj[day_start] = True
  639:             info_min[mask & (target % label_interval == 0)] = True
  640:             info_fmt[mask & (target % label_interval == 0)] = "%H:%M"
  641:             info_fmt[day_start] = "%H:%M\n%d-%b"
  642:             info_fmt[year_start] = "%H:%M\n%d-%b\n%Y"
  643:             if force_year_start and not has_level_label(year_start, vmin_orig):
  644:                 info_fmt[first_label(day_start)] = "%H:%M\n%d-%b\n%Y"
  645: 
  646:         def _minute_finder(label_interval: int) -> None:
  647:             target = dates_.minute
  648:             hour_start = _period_break(dates_, "hour")
  649:             mask = _period_break_mask(dates_, "minute")
  650:             info_maj[hour_start] = True
  651:             info_min[mask & (target % label_interval == 0)] = True
  652:             info_fmt[mask & (target % label_interval == 0)] = "%H:%M"
  653:             info_fmt[day_start] = "%H:%M\n%d-%b"
  654:             info_fmt[year_start] = "%H:%M\n%d-%b\n%Y"
  655: 
  656:         def _second_finder(label_interval: int) -> None:
  657:             target = dates_.second
  658:             minute_start = _period_break(dates_, "minute")
  659:             mask = _period_break_mask(dates_, "second")
  660:             info_maj[minute_start] = True
  661:             info_min[mask & (target % label_interval == 0)] = True
  662:             info_fmt[mask & (target % label_interval == 0)] = "%H:%M:%S"
  663:             info_fmt[day_start] = "%H:%M:%S\n%d-%b"
  664:             info_fmt[year_start] = "%H:%M:%S\n%d-%b\n%Y"
  665: 
  666:         if span < periodsperday / 12000:
  667:             _second_finder(1)
  668:         elif span < periodsperday / 6000:
  669:             _second_finder(2)
  670:         elif span < periodsperday / 2400:
  671:             _second_finder(5)
  672:         elif span < periodsperday / 1200:
  673:             _second_finder(10)
  674:         elif span < periodsperday / 800:
  675:             _second_finder(15)
  676:         elif span < periodsperday / 400:
  677:             _second_finder(30)
  678:         elif span < periodsperday / 150:
  679:             _minute_finder(1)
  680:         elif span < periodsperday / 70:
  681:             _minute_finder(2)
  682:         elif span < periodsperday / 24:
  683:             _minute_finder(5)
  684:         elif span < periodsperday / 12:
  685:             _minute_finder(15)
  686:         elif span < periodsperday / 6:
  687:             _minute_finder(30)
  688:         elif span < periodsperday / 2.5:
  689:             _hour_finder(1, False)
  690:         elif span < periodsperday / 1.5:
  691:             _hour_finder(2, False)
  692:         elif span < periodsperday * 1.25:
  693:             _hour_finder(3, False)
  694:         elif span < periodsperday * 2.5:
  695:             _hour_finder(6, True)
  696:         elif span < periodsperday * 4:
  697:             _hour_finder(12, True)
  698:         else:
  699:             info_maj[month_start] = True
  700:             info_min[day_start] = True
  701:             info_fmt[day_start] = "%d"
  702:             info_fmt[month_start] = "%d\n%b"
  703:             info_fmt[year_start] = "%d\n%b\n%Y"
  704:             if not has_level_label(year_start, vmin_orig):
  705:                 if not has_level_label(month_start, vmin_orig):
  706:                     info_fmt[first_label(day_start)] = "%d\n%b\n%Y"
  707:                 else:
  708:                     info_fmt[first_label(month_start)] = "%d\n%b\n%Y"
  709: 
  710:     # Case 2. Less than three months
  711:     elif span <= periodsperyear // 4:
  712:         month_start = _period_break(dates_, "month")
  713:         info_maj[month_start] = True
  714:         if dtype_code < FreqGroup.FR_HR.value:
  715:             info["min"] = True
  716:         else:
  717:             day_start = _period_break(dates_, "day")
  718:             info["min"][day_start] = True
  719:         week_start = _period_break(dates_, "week")
  720:         year_start = _period_break(dates_, "year")
  721:         info_fmt[week_start] = "%d"
  722:         info_fmt[month_start] = "\n\n%b"
  723:         info_fmt[year_start] = "\n\n%b\n%Y"
  724:         if not has_level_label(year_start, vmin_orig):
  725:             if not has_level_label(month_start, vmin_orig):
  726:                 info_fmt[first_label(week_start)] = "\n\n%b\n%Y"
  727:             else:
  728:                 info_fmt[first_label(month_start)] = "\n\n%b\n%Y"
  729:     # Case 3. Less than 14 months ...............
  730:     elif span <= 1.15 * periodsperyear:
  731:         year_start = _period_break(dates_, "year")
  732:         month_start = _period_break(dates_, "month")
  733:         week_start = _period_break(dates_, "week")
  734:         info_maj[month_start] = True
  735:         info_min[week_start] = True
  736:         info_min[year_start] = False
  737:         info_min[month_start] = False
  738:         info_fmt[month_start] = "%b"
  739:         info_fmt[year_start] = "%b\n%Y"
  740:         if not has_level_label(year_start, vmin_orig):
  741:             info_fmt[first_label(month_start)] = "%b\n%Y"
  742:     # Case 4. Less than 2.5 years ...............
  743:     elif span <= 2.5 * periodsperyear:
  744:         year_start = _period_break(dates_, "year")
  745:         quarter_start = _period_break(dates_, "quarter")
  746:         month_start = _period_break(dates_, "month")
  747:         info_maj[quarter_start] = True
  748:         info_min[month_start] = True
  749:         info_fmt[quarter_start] = "%b"
  750:         info_fmt[year_start] = "%b\n%Y"
  751:     # Case 4. Less than 4 years .................
  752:     elif span <= 4 * periodsperyear:
  753:         year_start = _period_break(dates_, "year")
  754:         month_start = _period_break(dates_, "month")
  755:         info_maj[year_start] = True
  756:         info_min[month_start] = True
  757:         info_min[year_start] = False
  758: 
  759:         month_break = dates_[month_start].month
  760:         jan_or_jul = month_start[(month_break == 1) | (month_break == 7)]
  761:         info_fmt[jan_or_jul] = "%b"
  762:         info_fmt[year_start] = "%b\n%Y"
  763:     # Case 5. Less than 11 years ................
  764:     elif span <= 11 * periodsperyear:
  765:         year_start = _period_break(dates_, "year")
  766:         quarter_start = _period_break(dates_, "quarter")
  767:         info_maj[year_start] = True
  768:         info_min[quarter_start] = True
  769:         info_min[year_start] = False
  770:         info_fmt[year_start] = "%Y"
  771:     # Case 6. More than 12 years ................
  772:     else:
  773:         year_start = _period_break(dates_, "year")
  774:         year_break = dates_[year_start].year
  775:         nyears = span / periodsperyear
  776:         (min_anndef, maj_anndef) = _get_default_annual_spacing(nyears)
  777:         major_idx = year_start[(year_break % maj_anndef == 0)]
  778:         info_maj[major_idx] = True
  779:         minor_idx = year_start[(year_break % min_anndef == 0)]
  780:         info_min[minor_idx] = True
  781:         info_fmt[major_idx] = "%Y"
  782: 
  783:     return info
  784: 
  785: 
  786: def _monthly_finder(vmin, vmax, freq: BaseOffset) -> np.ndarray:
  787:     _, _, periodsperyear = _get_periods_per_ymd(freq)
  788: 
  789:     vmin_orig = vmin
  790:     (vmin, vmax) = (int(vmin), int(vmax))
  791:     span = vmax - vmin + 1
  792: 
  793:     # Initialize the output
  794:     info = np.zeros(
  795:         span, dtype=[("val", int), ("maj", bool), ("min", bool), ("fmt", "|S8")]
  796:     )
  797:     info["val"] = np.arange(vmin, vmax + 1)
  798:     dates_ = info["val"]
  799:     info["fmt"] = ""
  800:     year_start = (dates_ % 12 == 0).nonzero()[0]
  801:     info_maj = info["maj"]
  802:     info_fmt = info["fmt"]
  803: 
  804:     if span <= 1.15 * periodsperyear:
  805:         info_maj[year_start] = True
  806:         info["min"] = True
  807: 
  808:         info_fmt[:] = "%b"
  809:         info_fmt[year_start] = "%b\n%Y"
  810: 
  811:         if not has_level_label(year_start, vmin_orig):
  812:             if dates_.size > 1:
  813:                 idx = 1
  814:             else:
  815:                 idx = 0
  816:             info_fmt[idx] = "%b\n%Y"
  817: 
  818:     elif span <= 2.5 * periodsperyear:
  819:         quarter_start = (dates_ % 3 == 0).nonzero()
  820:         info_maj[year_start] = True
  821:         # TODO: Check the following : is it really info['fmt'] ?
  822:         #  2023-09-15 this is reached in test_finder_monthly
  823:         info["fmt"][quarter_start] = True
  824:         info["min"] = True
  825: 
  826:         info_fmt[quarter_start] = "%b"
  827:         info_fmt[year_start] = "%b\n%Y"
  828: 
  829:     elif span <= 4 * periodsperyear:
  830:         info_maj[year_start] = True
  831:         info["min"] = True
  832: 
  833:         jan_or_jul = (dates_ % 12 == 0) | (dates_ % 12 == 6)
  834:         info_fmt[jan_or_jul] = "%b"
  835:         info_fmt[year_start] = "%b\n%Y"
  836: 
  837:     elif span <= 11 * periodsperyear:
  838:         quarter_start = (dates_ % 3 == 0).nonzero()
  839:         info_maj[year_start] = True
  840:         info["min"][quarter_start] = True
  841: 
  842:         info_fmt[year_start] = "%Y"
  843: 
  844:     else:
  845:         nyears = span / periodsperyear
  846:         (min_anndef, maj_anndef) = _get_default_annual_spacing(nyears)
  847:         years = dates_[year_start] // 12 + 1
  848:         major_idx = year_start[(years % maj_anndef == 0)]
  849:         info_maj[major_idx] = True
  850:         info["min"][year_start[(years % min_anndef == 0)]] = True
  851: 
  852:         info_fmt[major_idx] = "%Y"
  853: 
  854:     return info
  855: 
  856: 
  857: def _quarterly_finder(vmin, vmax, freq: BaseOffset) -> np.ndarray:
  858:     _, _, periodsperyear = _get_periods_per_ymd(freq)
  859:     vmin_orig = vmin
  860:     (vmin, vmax) = (int(vmin), int(vmax))
  861:     span = vmax - vmin + 1
  862: 
  863:     info = np.zeros(
  864:         span, dtype=[("val", int), ("maj", bool), ("min", bool), ("fmt", "|S8")]
  865:     )
  866:     info["val"] = np.arange(vmin, vmax + 1)
  867:     info["fmt"] = ""
  868:     dates_ = info["val"]
  869:     info_maj = info["maj"]
  870:     info_fmt = info["fmt"]
  871:     year_start = (dates_ % 4 == 0).nonzero()[0]
  872: 
  873:     if span <= 3.5 * periodsperyear:
  874:         info_maj[year_start] = True
  875:         info["min"] = True
  876: 
  877:         info_fmt[:] = "Q%q"
  878:         info_fmt[year_start] = "Q%q\n%F"
  879:         if not has_level_label(year_start, vmin_orig):
  880:             if dates_.size > 1:
  881:                 idx = 1
  882:             else:
  883:                 idx = 0
  884:             info_fmt[idx] = "Q%q\n%F"
  885: 
  886:     elif span <= 11 * periodsperyear:
  887:         info_maj[year_start] = True
  888:         info["min"] = True
  889:         info_fmt[year_start] = "%F"
  890: 
  891:     else:
  892:         # https://github.com/pandas-dev/pandas/pull/47602
  893:         years = dates_[year_start] // 4 + 1970
  894:         nyears = span / periodsperyear
  895:         (min_anndef, maj_anndef) = _get_default_annual_spacing(nyears)
  896:         major_idx = year_start[(years % maj_anndef == 0)]
  897:         info_maj[major_idx] = True
  898:         info["min"][year_start[(years % min_anndef == 0)]] = True
  899:         info_fmt[major_idx] = "%F"
  900: 
  901:     return info
  902: 
  903: 
  904: def _annual_finder(vmin, vmax, freq: BaseOffset) -> np.ndarray:
  905:     # Note: small difference here vs other finders in adding 1 to vmax
  906:     (vmin, vmax) = (int(vmin), int(vmax + 1))
  907:     span = vmax - vmin + 1
  908: 
  909:     info = np.zeros(
  910:         span, dtype=[("val", int), ("maj", bool), ("min", bool), ("fmt", "|S8")]
  911:     )
  912:     info["val"] = np.arange(vmin, vmax + 1)
  913:     info["fmt"] = ""
  914:     dates_ = info["val"]
  915: 
  916:     (min_anndef, maj_anndef) = _get_default_annual_spacing(span)
  917:     major_idx = dates_ % maj_anndef == 0
  918:     minor_idx = dates_ % min_anndef == 0
  919:     info["maj"][major_idx] = True
  920:     info["min"][minor_idx] = True
  921:     info["fmt"][major_idx] = "%Y"
  922: 
  923:     return info
  924: 
  925: 
  926: def get_finder(freq: BaseOffset):
  927:     # error: "BaseOffset" has no attribute "_period_dtype_code"
  928:     dtype_code = freq._period_dtype_code  # type: ignore[attr-defined]
  929:     fgroup = FreqGroup.from_period_dtype_code(dtype_code)
  930: 
  931:     if fgroup == FreqGroup.FR_ANN:
  932:         return _annual_finder
  933:     elif fgroup == FreqGroup.FR_QTR:
  934:         return _quarterly_finder
  935:     elif fgroup == FreqGroup.FR_MTH:
  936:         return _monthly_finder
  937:     elif (dtype_code >= FreqGroup.FR_BUS.value) or fgroup == FreqGroup.FR_WK:
  938:         return _daily_finder
  939:     else:  # pragma: no cover
  940:         raise NotImplementedError(f"Unsupported frequency: {dtype_code}")
  941: 
  942: 
  943: class TimeSeries_DateLocator(Locator):
  944:     """
  945:     Locates the ticks along an axis controlled by a :class:`Series`.
  946: 
  947:     Parameters
  948:     ----------
  949:     freq : BaseOffset
  950:         Valid frequency specifier.
  951:     minor_locator : {False, True}, optional
  952:         Whether the locator is for minor ticks (True) or not.
  953:     dynamic_mode : {True, False}, optional
  954:         Whether the locator should work in dynamic mode.
  955:     base : {int}, optional
  956:     quarter : {int}, optional
  957:     month : {int}, optional
  958:     day : {int}, optional
  959:     """
  960: 
  961:     axis: Axis
  962: 
  963:     def __init__(
  964:         self,
  965:         freq: BaseOffset,
  966:         minor_locator: bool = False,
  967:         dynamic_mode: bool = True,
  968:         base: int = 1,
  969:         quarter: int = 1,
  970:         month: int = 1,
  971:         day: int = 1,
  972:         plot_obj=None,
  973:     ) -> None:
  974:         freq = to_offset(freq, is_period=True)
  975:         self.freq = freq
  976:         self.base = base
  977:         (self.quarter, self.month, self.day) = (quarter, month, day)
  978:         self.isminor = minor_locator
  979:         self.isdynamic = dynamic_mode
  980:         self.offset = 0
  981:         self.plot_obj = plot_obj
  982:         self.finder = get_finder(freq)
  983: 
  984:     def _get_default_locs(self, vmin, vmax):
  985:         """Returns the default locations of ticks."""
  986:         locator = self.finder(vmin, vmax, self.freq)
  987: 
  988:         if self.isminor:
  989:             return np.compress(locator["min"], locator["val"])
  990:         return np.compress(locator["maj"], locator["val"])
  991: 
  992:     def __call__(self):
  993:         """Return the locations of the ticks."""
  994:         # axis calls Locator.set_axis inside set_m<xxxx>_formatter
  995: 
  996:         vi = tuple(self.axis.get_view_interval())
  997:         vmin, vmax = vi
  998:         if vmax < vmin:
  999:             vmin, vmax = vmax, vmin
 1000:         if self.isdynamic:
 1001:             locs = self._get_default_locs(vmin, vmax)
 1002:         else:  # pragma: no cover
 1003:             base = self.base
 1004:             (d, m) = divmod(vmin, base)
 1005:             vmin = (d + 1) * base
 1006:             # error: No overload variant of "range" matches argument types "float",
 1007:             # "float", "int"
 1008:             locs = list(range(vmin, vmax + 1, base))  # type: ignore[call-overload]
 1009:         return locs
 1010: 
 1011:     def autoscale(self):
 1012:         """
 1013:         Sets the view limits to the nearest multiples of base that contain the
 1014:         data.
 1015:         """
 1016:         # requires matplotlib >= 0.98.0
 1017:         (vmin, vmax) = self.axis.get_data_interval()
 1018: 
 1019:         locs = self._get_default_locs(vmin, vmax)
 1020:         (vmin, vmax) = locs[[0, -1]]
 1021:         if vmin == vmax:
 1022:             vmin -= 1
 1023:             vmax += 1
 1024:         return nonsingular(vmin, vmax)
 1025: 
 1026: 
 1027: # -------------------------------------------------------------------------
 1028: # --- Formatter ---
 1029: # -------------------------------------------------------------------------
 1030: 
 1031: 
 1032: class TimeSeries_DateFormatter(Formatter):
 1033:     """
 1034:     Formats the ticks along an axis controlled by a :class:`PeriodIndex`.
 1035: 
 1036:     Parameters
 1037:     ----------
 1038:     freq : BaseOffset
 1039:         Valid frequency specifier.
 1040:     minor_locator : bool, default False
 1041:         Whether the current formatter should apply to minor ticks (True) or
 1042:         major ticks (False).
 1043:     dynamic_mode : bool, default True
 1044:         Whether the formatter works in dynamic mode or not.
 1045:     """
 1046: 
 1047:     axis: Axis
 1048: 
 1049:     def __init__(
 1050:         self,
 1051:         freq: BaseOffset,
 1052:         minor_locator: bool = False,
 1053:         dynamic_mode: bool = True,
 1054:         plot_obj=None,
 1055:     ) -> None:
 1056:         freq = to_offset(freq, is_period=True)
 1057:         self.format = None
 1058:         self.freq = freq
 1059:         self.locs: list[Any] = []  # unused, for matplotlib compat
 1060:         self.formatdict: dict[Any, Any] | None = None
 1061:         self.isminor = minor_locator
 1062:         self.isdynamic = dynamic_mode
 1063:         self.offset = 0
 1064:         self.plot_obj = plot_obj
 1065:         self.finder = get_finder(freq)
 1066: 
 1067:     def _set_default_format(self, vmin, vmax):
 1068:         """Returns the default ticks spacing."""
 1069:         info = self.finder(vmin, vmax, self.freq)
 1070: 
 1071:         if self.isminor:
 1072:             format = np.compress(info["min"] & np.logical_not(info["maj"]), info)
 1073:         else:
 1074:             format = np.compress(info["maj"], info)
 1075:         self.formatdict = {x: f for (x, _, _, f) in format}
 1076:         return self.formatdict
 1077: 
 1078:     def set_locs(self, locs) -> None:
 1079:         """Sets the locations of the ticks"""
 1080:         # don't actually use the locs. This is just needed to work with
 1081:         # matplotlib. Force to use vmin, vmax
 1082: 
 1083:         self.locs = locs
 1084: 
 1085:         (vmin, vmax) = tuple(self.axis.get_view_interval())
 1086:         if vmax < vmin:
 1087:             (vmin, vmax) = (vmax, vmin)
 1088:         self._set_default_format(vmin, vmax)
 1089: 
 1090:     def __call__(self, x, pos: int | None = 0) -> str:
 1091:         if self.formatdict is None:
 1092:             return ""
 1093:         else:
 1094:             fmt = self.formatdict.pop(x, "")
 1095:             if isinstance(fmt, np.bytes_):
 1096:                 fmt = fmt.decode("utf-8")
 1097:             with warnings.catch_warnings():
 1098:                 warnings.filterwarnings(
 1099:                     "ignore",
 1100:                     "Period with BDay freq is deprecated",
 1101:                     category=FutureWarning,
 1102:                 )
 1103:                 period = Period(ordinal=int(x), freq=self.freq)
 1104:             assert isinstance(period, Period)
 1105:             return period.strftime(fmt)
 1106: 
 1107: 
 1108: class TimeSeries_TimedeltaFormatter(Formatter):
 1109:     """
 1110:     Formats the ticks along an axis controlled by a :class:`TimedeltaIndex`.
 1111:     """
 1112: 
 1113:     axis: Axis
 1114: 
 1115:     @staticmethod
 1116:     def format_timedelta_ticks(x, pos, n_decimals: int) -> str:
 1117:         """
 1118:         Convert seconds to 'D days HH:MM:SS.F'
 1119:         """
 1120:         s, ns = divmod(x, 10**9)  # TODO(non-nano): this looks like it assumes ns
 1121:         m, s = divmod(s, 60)
 1122:         h, m = divmod(m, 60)
 1123:         d, h = divmod(h, 24)
 1124:         decimals = int(ns * 10 ** (n_decimals - 9))
 1125:         s = f"{int(h):02d}:{int(m):02d}:{int(s):02d}"
 1126:         if n_decimals > 0:
 1127:             s += f".{decimals:0{n_decimals}d}"
 1128:         if d != 0:
 1129:             s = f"{int(d):d} days {s}"
 1130:         return s
 1131: 
 1132:     def __call__(self, x, pos: int | None = 0) -> str:
 1133:         (vmin, vmax) = tuple(self.axis.get_view_interval())
 1134:         n_decimals = min(int(np.ceil(np.log10(100 * 10**9 / abs(vmax - vmin)))), 9)
 1135:         return self.format_timedelta_ticks(x, pos, n_decimals)
