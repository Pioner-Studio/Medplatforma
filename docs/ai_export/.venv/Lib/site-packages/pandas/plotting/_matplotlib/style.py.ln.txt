    1: from __future__ import annotations
    2: 
    3: from collections.abc import (
    4:     Collection,
    5:     Iterator,
    6: )
    7: import itertools
    8: from typing import (
    9:     TYPE_CHECKING,
   10:     cast,
   11: )
   12: import warnings
   13: 
   14: import matplotlib as mpl
   15: import matplotlib.colors
   16: import numpy as np
   17: 
   18: from pandas._typing import MatplotlibColor as Color
   19: from pandas.util._exceptions import find_stack_level
   20: 
   21: from pandas.core.dtypes.common import is_list_like
   22: 
   23: import pandas.core.common as com
   24: 
   25: if TYPE_CHECKING:
   26:     from matplotlib.colors import Colormap
   27: 
   28: 
   29: def get_standard_colors(
   30:     num_colors: int,
   31:     colormap: Colormap | None = None,
   32:     color_type: str = "default",
   33:     color: dict[str, Color] | Color | Collection[Color] | None = None,
   34: ):
   35:     """
   36:     Get standard colors based on `colormap`, `color_type` or `color` inputs.
   37: 
   38:     Parameters
   39:     ----------
   40:     num_colors : int
   41:         Minimum number of colors to be returned.
   42:         Ignored if `color` is a dictionary.
   43:     colormap : :py:class:`matplotlib.colors.Colormap`, optional
   44:         Matplotlib colormap.
   45:         When provided, the resulting colors will be derived from the colormap.
   46:     color_type : {"default", "random"}, optional
   47:         Type of colors to derive. Used if provided `color` and `colormap` are None.
   48:         Ignored if either `color` or `colormap` are not None.
   49:     color : dict or str or sequence, optional
   50:         Color(s) to be used for deriving sequence of colors.
   51:         Can be either be a dictionary, or a single color (single color string,
   52:         or sequence of floats representing a single color),
   53:         or a sequence of colors.
   54: 
   55:     Returns
   56:     -------
   57:     dict or list
   58:         Standard colors. Can either be a mapping if `color` was a dictionary,
   59:         or a list of colors with a length of `num_colors` or more.
   60: 
   61:     Warns
   62:     -----
   63:     UserWarning
   64:         If both `colormap` and `color` are provided.
   65:         Parameter `color` will override.
   66:     """
   67:     if isinstance(color, dict):
   68:         return color
   69: 
   70:     colors = _derive_colors(
   71:         color=color,
   72:         colormap=colormap,
   73:         color_type=color_type,
   74:         num_colors=num_colors,
   75:     )
   76: 
   77:     return list(_cycle_colors(colors, num_colors=num_colors))
   78: 
   79: 
   80: def _derive_colors(
   81:     *,
   82:     color: Color | Collection[Color] | None,
   83:     colormap: str | Colormap | None,
   84:     color_type: str,
   85:     num_colors: int,
   86: ) -> list[Color]:
   87:     """
   88:     Derive colors from either `colormap`, `color_type` or `color` inputs.
   89: 
   90:     Get a list of colors either from `colormap`, or from `color`,
   91:     or from `color_type` (if both `colormap` and `color` are None).
   92: 
   93:     Parameters
   94:     ----------
   95:     color : str or sequence, optional
   96:         Color(s) to be used for deriving sequence of colors.
   97:         Can be either be a single color (single color string, or sequence of floats
   98:         representing a single color), or a sequence of colors.
   99:     colormap : :py:class:`matplotlib.colors.Colormap`, optional
  100:         Matplotlib colormap.
  101:         When provided, the resulting colors will be derived from the colormap.
  102:     color_type : {"default", "random"}, optional
  103:         Type of colors to derive. Used if provided `color` and `colormap` are None.
  104:         Ignored if either `color` or `colormap`` are not None.
  105:     num_colors : int
  106:         Number of colors to be extracted.
  107: 
  108:     Returns
  109:     -------
  110:     list
  111:         List of colors extracted.
  112: 
  113:     Warns
  114:     -----
  115:     UserWarning
  116:         If both `colormap` and `color` are provided.
  117:         Parameter `color` will override.
  118:     """
  119:     if color is None and colormap is not None:
  120:         return _get_colors_from_colormap(colormap, num_colors=num_colors)
  121:     elif color is not None:
  122:         if colormap is not None:
  123:             warnings.warn(
  124:                 "'color' and 'colormap' cannot be used simultaneously. Using 'color'",
  125:                 stacklevel=find_stack_level(),
  126:             )
  127:         return _get_colors_from_color(color)
  128:     else:
  129:         return _get_colors_from_color_type(color_type, num_colors=num_colors)
  130: 
  131: 
  132: def _cycle_colors(colors: list[Color], num_colors: int) -> Iterator[Color]:
  133:     """Cycle colors until achieving max of `num_colors` or length of `colors`.
  134: 
  135:     Extra colors will be ignored by matplotlib if there are more colors
  136:     than needed and nothing needs to be done here.
  137:     """
  138:     max_colors = max(num_colors, len(colors))
  139:     yield from itertools.islice(itertools.cycle(colors), max_colors)
  140: 
  141: 
  142: def _get_colors_from_colormap(
  143:     colormap: str | Colormap,
  144:     num_colors: int,
  145: ) -> list[Color]:
  146:     """Get colors from colormap."""
  147:     cmap = _get_cmap_instance(colormap)
  148:     return [cmap(num) for num in np.linspace(0, 1, num=num_colors)]
  149: 
  150: 
  151: def _get_cmap_instance(colormap: str | Colormap) -> Colormap:
  152:     """Get instance of matplotlib colormap."""
  153:     if isinstance(colormap, str):
  154:         cmap = colormap
  155:         colormap = mpl.colormaps[colormap]
  156:         if colormap is None:
  157:             raise ValueError(f"Colormap {cmap} is not recognized")
  158:     return colormap
  159: 
  160: 
  161: def _get_colors_from_color(
  162:     color: Color | Collection[Color],
  163: ) -> list[Color]:
  164:     """Get colors from user input color."""
  165:     if len(color) == 0:
  166:         raise ValueError(f"Invalid color argument: {color}")
  167: 
  168:     if _is_single_color(color):
  169:         color = cast(Color, color)
  170:         return [color]
  171: 
  172:     color = cast(Collection[Color], color)
  173:     return list(_gen_list_of_colors_from_iterable(color))
  174: 
  175: 
  176: def _is_single_color(color: Color | Collection[Color]) -> bool:
  177:     """Check if `color` is a single color, not a sequence of colors.
  178: 
  179:     Single color is of these kinds:
  180:         - Named color "red", "C0", "firebrick"
  181:         - Alias "g"
  182:         - Sequence of floats, such as (0.1, 0.2, 0.3) or (0.1, 0.2, 0.3, 0.4).
  183: 
  184:     See Also
  185:     --------
  186:     _is_single_string_color
  187:     """
  188:     if isinstance(color, str) and _is_single_string_color(color):
  189:         # GH #36972
  190:         return True
  191: 
  192:     if _is_floats_color(color):
  193:         return True
  194: 
  195:     return False
  196: 
  197: 
  198: def _gen_list_of_colors_from_iterable(color: Collection[Color]) -> Iterator[Color]:
  199:     """
  200:     Yield colors from string of several letters or from collection of colors.
  201:     """
  202:     for x in color:
  203:         if _is_single_color(x):
  204:             yield x
  205:         else:
  206:             raise ValueError(f"Invalid color {x}")
  207: 
  208: 
  209: def _is_floats_color(color: Color | Collection[Color]) -> bool:
  210:     """Check if color comprises a sequence of floats representing color."""
  211:     return bool(
  212:         is_list_like(color)
  213:         and (len(color) == 3 or len(color) == 4)
  214:         and all(isinstance(x, (int, float)) for x in color)
  215:     )
  216: 
  217: 
  218: def _get_colors_from_color_type(color_type: str, num_colors: int) -> list[Color]:
  219:     """Get colors from user input color type."""
  220:     if color_type == "default":
  221:         return _get_default_colors(num_colors)
  222:     elif color_type == "random":
  223:         return _get_random_colors(num_colors)
  224:     else:
  225:         raise ValueError("color_type must be either 'default' or 'random'")
  226: 
  227: 
  228: def _get_default_colors(num_colors: int) -> list[Color]:
  229:     """Get `num_colors` of default colors from matplotlib rc params."""
  230:     import matplotlib.pyplot as plt
  231: 
  232:     colors = [c["color"] for c in plt.rcParams["axes.prop_cycle"]]
  233:     return colors[0:num_colors]
  234: 
  235: 
  236: def _get_random_colors(num_colors: int) -> list[Color]:
  237:     """Get `num_colors` of random colors."""
  238:     return [_random_color(num) for num in range(num_colors)]
  239: 
  240: 
  241: def _random_color(column: int) -> list[float]:
  242:     """Get a random color represented as a list of length 3"""
  243:     # GH17525 use common._random_state to avoid resetting the seed
  244:     rs = com.random_state(column)
  245:     return rs.rand(3).tolist()
  246: 
  247: 
  248: def _is_single_string_color(color: Color) -> bool:
  249:     """Check if `color` is a single string color.
  250: 
  251:     Examples of single string colors:
  252:         - 'r'
  253:         - 'g'
  254:         - 'red'
  255:         - 'green'
  256:         - 'C3'
  257:         - 'firebrick'
  258: 
  259:     Parameters
  260:     ----------
  261:     color : Color
  262:         Color string or sequence of floats.
  263: 
  264:     Returns
  265:     -------
  266:     bool
  267:         True if `color` looks like a valid color.
  268:         False otherwise.
  269:     """
  270:     conv = matplotlib.colors.ColorConverter()
  271:     try:
  272:         # error: Argument 1 to "to_rgba" of "ColorConverter" has incompatible type
  273:         # "str | Sequence[float]"; expected "tuple[float, float, float] | ..."
  274:         conv.to_rgba(color)  # type: ignore[arg-type]
  275:     except ValueError:
  276:         return False
  277:     else:
  278:         return True
