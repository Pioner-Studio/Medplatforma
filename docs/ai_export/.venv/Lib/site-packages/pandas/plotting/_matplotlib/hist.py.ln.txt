    1: from __future__ import annotations
    2: 
    3: from typing import (
    4:     TYPE_CHECKING,
    5:     Any,
    6:     Literal,
    7:     final,
    8: )
    9: 
   10: import numpy as np
   11: 
   12: from pandas.core.dtypes.common import (
   13:     is_integer,
   14:     is_list_like,
   15: )
   16: from pandas.core.dtypes.generic import (
   17:     ABCDataFrame,
   18:     ABCIndex,
   19: )
   20: from pandas.core.dtypes.missing import (
   21:     isna,
   22:     remove_na_arraylike,
   23: )
   24: 
   25: from pandas.io.formats.printing import pprint_thing
   26: from pandas.plotting._matplotlib.core import (
   27:     LinePlot,
   28:     MPLPlot,
   29: )
   30: from pandas.plotting._matplotlib.groupby import (
   31:     create_iter_data_given_by,
   32:     reformat_hist_y_given_by,
   33: )
   34: from pandas.plotting._matplotlib.misc import unpack_single_str_list
   35: from pandas.plotting._matplotlib.tools import (
   36:     create_subplots,
   37:     flatten_axes,
   38:     maybe_adjust_figure,
   39:     set_ticks_props,
   40: )
   41: 
   42: if TYPE_CHECKING:
   43:     from matplotlib.axes import Axes
   44:     from matplotlib.figure import Figure
   45: 
   46:     from pandas._typing import PlottingOrientation
   47: 
   48:     from pandas import (
   49:         DataFrame,
   50:         Series,
   51:     )
   52: 
   53: 
   54: class HistPlot(LinePlot):
   55:     @property
   56:     def _kind(self) -> Literal["hist", "kde"]:
   57:         return "hist"
   58: 
   59:     def __init__(
   60:         self,
   61:         data,
   62:         bins: int | np.ndarray | list[np.ndarray] = 10,
   63:         bottom: int | np.ndarray = 0,
   64:         *,
   65:         range=None,
   66:         weights=None,
   67:         **kwargs,
   68:     ) -> None:
   69:         if is_list_like(bottom):
   70:             bottom = np.array(bottom)
   71:         self.bottom = bottom
   72: 
   73:         self._bin_range = range
   74:         self.weights = weights
   75: 
   76:         self.xlabel = kwargs.get("xlabel")
   77:         self.ylabel = kwargs.get("ylabel")
   78:         # Do not call LinePlot.__init__ which may fill nan
   79:         MPLPlot.__init__(self, data, **kwargs)  # pylint: disable=non-parent-init-called
   80: 
   81:         self.bins = self._adjust_bins(bins)
   82: 
   83:     def _adjust_bins(self, bins: int | np.ndarray | list[np.ndarray]):
   84:         if is_integer(bins):
   85:             if self.by is not None:
   86:                 by_modified = unpack_single_str_list(self.by)
   87:                 grouped = self.data.groupby(by_modified)[self.columns]
   88:                 bins = [self._calculate_bins(group, bins) for key, group in grouped]
   89:             else:
   90:                 bins = self._calculate_bins(self.data, bins)
   91:         return bins
   92: 
   93:     def _calculate_bins(self, data: Series | DataFrame, bins) -> np.ndarray:
   94:         """Calculate bins given data"""
   95:         nd_values = data.infer_objects(copy=False)._get_numeric_data()
   96:         values = np.ravel(nd_values)
   97:         values = values[~isna(values)]
   98: 
   99:         hist, bins = np.histogram(values, bins=bins, range=self._bin_range)
  100:         return bins
  101: 
  102:     # error: Signature of "_plot" incompatible with supertype "LinePlot"
  103:     @classmethod
  104:     def _plot(  # type: ignore[override]
  105:         cls,
  106:         ax: Axes,
  107:         y: np.ndarray,
  108:         style=None,
  109:         bottom: int | np.ndarray = 0,
  110:         column_num: int = 0,
  111:         stacking_id=None,
  112:         *,
  113:         bins,
  114:         **kwds,
  115:     ):
  116:         if column_num == 0:
  117:             cls._initialize_stacker(ax, stacking_id, len(bins) - 1)
  118: 
  119:         base = np.zeros(len(bins) - 1)
  120:         bottom = bottom + cls._get_stacked_values(ax, stacking_id, base, kwds["label"])
  121:         # ignore style
  122:         n, bins, patches = ax.hist(y, bins=bins, bottom=bottom, **kwds)
  123:         cls._update_stacker(ax, stacking_id, n)
  124:         return patches
  125: 
  126:     def _make_plot(self, fig: Figure) -> None:
  127:         colors = self._get_colors()
  128:         stacking_id = self._get_stacking_id()
  129: 
  130:         # Re-create iterated data if `by` is assigned by users
  131:         data = (
  132:             create_iter_data_given_by(self.data, self._kind)
  133:             if self.by is not None
  134:             else self.data
  135:         )
  136: 
  137:         # error: Argument "data" to "_iter_data" of "MPLPlot" has incompatible
  138:         # type "object"; expected "DataFrame | dict[Hashable, Series | DataFrame]"
  139:         for i, (label, y) in enumerate(self._iter_data(data=data)):  # type: ignore[arg-type]
  140:             ax = self._get_ax(i)
  141: 
  142:             kwds = self.kwds.copy()
  143:             if self.color is not None:
  144:                 kwds["color"] = self.color
  145: 
  146:             label = pprint_thing(label)
  147:             label = self._mark_right_label(label, index=i)
  148:             kwds["label"] = label
  149: 
  150:             style, kwds = self._apply_style_colors(colors, kwds, i, label)
  151:             if style is not None:
  152:                 kwds["style"] = style
  153: 
  154:             self._make_plot_keywords(kwds, y)
  155: 
  156:             # the bins is multi-dimension array now and each plot need only 1-d and
  157:             # when by is applied, label should be columns that are grouped
  158:             if self.by is not None:
  159:                 kwds["bins"] = kwds["bins"][i]
  160:                 kwds["label"] = self.columns
  161:                 kwds.pop("color")
  162: 
  163:             if self.weights is not None:
  164:                 kwds["weights"] = type(self)._get_column_weights(self.weights, i, y)
  165: 
  166:             y = reformat_hist_y_given_by(y, self.by)
  167: 
  168:             artists = self._plot(ax, y, column_num=i, stacking_id=stacking_id, **kwds)
  169: 
  170:             # when by is applied, show title for subplots to know which group it is
  171:             if self.by is not None:
  172:                 ax.set_title(pprint_thing(label))
  173: 
  174:             self._append_legend_handles_labels(artists[0], label)
  175: 
  176:     def _make_plot_keywords(self, kwds: dict[str, Any], y: np.ndarray) -> None:
  177:         """merge BoxPlot/KdePlot properties to passed kwds"""
  178:         # y is required for KdePlot
  179:         kwds["bottom"] = self.bottom
  180:         kwds["bins"] = self.bins
  181: 
  182:     @final
  183:     @staticmethod
  184:     def _get_column_weights(weights, i: int, y):
  185:         # We allow weights to be a multi-dimensional array, e.g. a (10, 2) array,
  186:         # and each sub-array (10,) will be called in each iteration. If users only
  187:         # provide 1D array, we assume the same weights is used for all iterations
  188:         if weights is not None:
  189:             if np.ndim(weights) != 1 and np.shape(weights)[-1] != 1:
  190:                 try:
  191:                     weights = weights[:, i]
  192:                 except IndexError as err:
  193:                     raise ValueError(
  194:                         "weights must have the same shape as data, "
  195:                         "or be a single column"
  196:                     ) from err
  197:             weights = weights[~isna(y)]
  198:         return weights
  199: 
  200:     def _post_plot_logic(self, ax: Axes, data) -> None:
  201:         if self.orientation == "horizontal":
  202:             # error: Argument 1 to "set_xlabel" of "_AxesBase" has incompatible
  203:             # type "Hashable"; expected "str"
  204:             ax.set_xlabel(
  205:                 "Frequency"
  206:                 if self.xlabel is None
  207:                 else self.xlabel  # type: ignore[arg-type]
  208:             )
  209:             ax.set_ylabel(self.ylabel)  # type: ignore[arg-type]
  210:         else:
  211:             ax.set_xlabel(self.xlabel)  # type: ignore[arg-type]
  212:             ax.set_ylabel(
  213:                 "Frequency"
  214:                 if self.ylabel is None
  215:                 else self.ylabel  # type: ignore[arg-type]
  216:             )
  217: 
  218:     @property
  219:     def orientation(self) -> PlottingOrientation:
  220:         if self.kwds.get("orientation", None) == "horizontal":
  221:             return "horizontal"
  222:         else:
  223:             return "vertical"
  224: 
  225: 
  226: class KdePlot(HistPlot):
  227:     @property
  228:     def _kind(self) -> Literal["kde"]:
  229:         return "kde"
  230: 
  231:     @property
  232:     def orientation(self) -> Literal["vertical"]:
  233:         return "vertical"
  234: 
  235:     def __init__(
  236:         self, data, bw_method=None, ind=None, *, weights=None, **kwargs
  237:     ) -> None:
  238:         # Do not call LinePlot.__init__ which may fill nan
  239:         MPLPlot.__init__(self, data, **kwargs)  # pylint: disable=non-parent-init-called
  240:         self.bw_method = bw_method
  241:         self.ind = ind
  242:         self.weights = weights
  243: 
  244:     @staticmethod
  245:     def _get_ind(y: np.ndarray, ind):
  246:         if ind is None:
  247:             # np.nanmax() and np.nanmin() ignores the missing values
  248:             sample_range = np.nanmax(y) - np.nanmin(y)
  249:             ind = np.linspace(
  250:                 np.nanmin(y) - 0.5 * sample_range,
  251:                 np.nanmax(y) + 0.5 * sample_range,
  252:                 1000,
  253:             )
  254:         elif is_integer(ind):
  255:             sample_range = np.nanmax(y) - np.nanmin(y)
  256:             ind = np.linspace(
  257:                 np.nanmin(y) - 0.5 * sample_range,
  258:                 np.nanmax(y) + 0.5 * sample_range,
  259:                 ind,
  260:             )
  261:         return ind
  262: 
  263:     @classmethod
  264:     # error: Signature of "_plot" incompatible with supertype "MPLPlot"
  265:     def _plot(  #  type: ignore[override]
  266:         cls,
  267:         ax: Axes,
  268:         y: np.ndarray,
  269:         style=None,
  270:         bw_method=None,
  271:         ind=None,
  272:         column_num=None,
  273:         stacking_id: int | None = None,
  274:         **kwds,
  275:     ):
  276:         from scipy.stats import gaussian_kde
  277: 
  278:         y = remove_na_arraylike(y)
  279:         gkde = gaussian_kde(y, bw_method=bw_method)
  280: 
  281:         y = gkde.evaluate(ind)
  282:         lines = MPLPlot._plot(ax, ind, y, style=style, **kwds)
  283:         return lines
  284: 
  285:     def _make_plot_keywords(self, kwds: dict[str, Any], y: np.ndarray) -> None:
  286:         kwds["bw_method"] = self.bw_method
  287:         kwds["ind"] = type(self)._get_ind(y, ind=self.ind)
  288: 
  289:     def _post_plot_logic(self, ax: Axes, data) -> None:
  290:         ax.set_ylabel("Density")
  291: 
  292: 
  293: def _grouped_plot(
  294:     plotf,
  295:     data: Series | DataFrame,
  296:     column=None,
  297:     by=None,
  298:     numeric_only: bool = True,
  299:     figsize: tuple[float, float] | None = None,
  300:     sharex: bool = True,
  301:     sharey: bool = True,
  302:     layout=None,
  303:     rot: float = 0,
  304:     ax=None,
  305:     **kwargs,
  306: ):
  307:     # error: Non-overlapping equality check (left operand type: "Optional[Tuple[float,
  308:     # float]]", right operand type: "Literal['default']")
  309:     if figsize == "default":  # type: ignore[comparison-overlap]
  310:         # allowed to specify mpl default with 'default'
  311:         raise ValueError(
  312:             "figsize='default' is no longer supported. "
  313:             "Specify figure size by tuple instead"
  314:         )
  315: 
  316:     grouped = data.groupby(by)
  317:     if column is not None:
  318:         grouped = grouped[column]
  319: 
  320:     naxes = len(grouped)
  321:     fig, axes = create_subplots(
  322:         naxes=naxes, figsize=figsize, sharex=sharex, sharey=sharey, ax=ax, layout=layout
  323:     )
  324: 
  325:     _axes = flatten_axes(axes)
  326: 
  327:     for i, (key, group) in enumerate(grouped):
  328:         ax = _axes[i]
  329:         if numeric_only and isinstance(group, ABCDataFrame):
  330:             group = group._get_numeric_data()
  331:         plotf(group, ax, **kwargs)
  332:         ax.set_title(pprint_thing(key))
  333: 
  334:     return fig, axes
  335: 
  336: 
  337: def _grouped_hist(
  338:     data: Series | DataFrame,
  339:     column=None,
  340:     by=None,
  341:     ax=None,
  342:     bins: int = 50,
  343:     figsize: tuple[float, float] | None = None,
  344:     layout=None,
  345:     sharex: bool = False,
  346:     sharey: bool = False,
  347:     rot: float = 90,
  348:     grid: bool = True,
  349:     xlabelsize: int | None = None,
  350:     xrot=None,
  351:     ylabelsize: int | None = None,
  352:     yrot=None,
  353:     legend: bool = False,
  354:     **kwargs,
  355: ):
  356:     """
  357:     Grouped histogram
  358: 
  359:     Parameters
  360:     ----------
  361:     data : Series/DataFrame
  362:     column : object, optional
  363:     by : object, optional
  364:     ax : axes, optional
  365:     bins : int, default 50
  366:     figsize : tuple, optional
  367:     layout : optional
  368:     sharex : bool, default False
  369:     sharey : bool, default False
  370:     rot : float, default 90
  371:     grid : bool, default True
  372:     legend: : bool, default False
  373:     kwargs : dict, keyword arguments passed to matplotlib.Axes.hist
  374: 
  375:     Returns
  376:     -------
  377:     collection of Matplotlib Axes
  378:     """
  379:     if legend:
  380:         assert "label" not in kwargs
  381:         if data.ndim == 1:
  382:             kwargs["label"] = data.name
  383:         elif column is None:
  384:             kwargs["label"] = data.columns
  385:         else:
  386:             kwargs["label"] = column
  387: 
  388:     def plot_group(group, ax) -> None:
  389:         ax.hist(group.dropna().values, bins=bins, **kwargs)
  390:         if legend:
  391:             ax.legend()
  392: 
  393:     if xrot is None:
  394:         xrot = rot
  395: 
  396:     fig, axes = _grouped_plot(
  397:         plot_group,
  398:         data,
  399:         column=column,
  400:         by=by,
  401:         sharex=sharex,
  402:         sharey=sharey,
  403:         ax=ax,
  404:         figsize=figsize,
  405:         layout=layout,
  406:         rot=rot,
  407:     )
  408: 
  409:     set_ticks_props(
  410:         axes, xlabelsize=xlabelsize, xrot=xrot, ylabelsize=ylabelsize, yrot=yrot
  411:     )
  412: 
  413:     maybe_adjust_figure(
  414:         fig, bottom=0.15, top=0.9, left=0.1, right=0.9, hspace=0.5, wspace=0.3
  415:     )
  416:     return axes
  417: 
  418: 
  419: def hist_series(
  420:     self: Series,
  421:     by=None,
  422:     ax=None,
  423:     grid: bool = True,
  424:     xlabelsize: int | None = None,
  425:     xrot=None,
  426:     ylabelsize: int | None = None,
  427:     yrot=None,
  428:     figsize: tuple[float, float] | None = None,
  429:     bins: int = 10,
  430:     legend: bool = False,
  431:     **kwds,
  432: ):
  433:     import matplotlib.pyplot as plt
  434: 
  435:     if legend and "label" in kwds:
  436:         raise ValueError("Cannot use both legend and label")
  437: 
  438:     if by is None:
  439:         if kwds.get("layout", None) is not None:
  440:             raise ValueError("The 'layout' keyword is not supported when 'by' is None")
  441:         # hack until the plotting interface is a bit more unified
  442:         fig = kwds.pop(
  443:             "figure", plt.gcf() if plt.get_fignums() else plt.figure(figsize=figsize)
  444:         )
  445:         if figsize is not None and tuple(figsize) != tuple(fig.get_size_inches()):
  446:             fig.set_size_inches(*figsize, forward=True)
  447:         if ax is None:
  448:             ax = fig.gca()
  449:         elif ax.get_figure() != fig:
  450:             raise AssertionError("passed axis not bound to passed figure")
  451:         values = self.dropna().values
  452:         if legend:
  453:             kwds["label"] = self.name
  454:         ax.hist(values, bins=bins, **kwds)
  455:         if legend:
  456:             ax.legend()
  457:         ax.grid(grid)
  458:         axes = np.array([ax])
  459: 
  460:         # error: Argument 1 to "set_ticks_props" has incompatible type "ndarray[Any,
  461:         # dtype[Any]]"; expected "Axes | Sequence[Axes]"
  462:         set_ticks_props(
  463:             axes,  # type: ignore[arg-type]
  464:             xlabelsize=xlabelsize,
  465:             xrot=xrot,
  466:             ylabelsize=ylabelsize,
  467:             yrot=yrot,
  468:         )
  469: 
  470:     else:
  471:         if "figure" in kwds:
  472:             raise ValueError(
  473:                 "Cannot pass 'figure' when using the "
  474:                 "'by' argument, since a new 'Figure' instance will be created"
  475:             )
  476:         axes = _grouped_hist(
  477:             self,
  478:             by=by,
  479:             ax=ax,
  480:             grid=grid,
  481:             figsize=figsize,
  482:             bins=bins,
  483:             xlabelsize=xlabelsize,
  484:             xrot=xrot,
  485:             ylabelsize=ylabelsize,
  486:             yrot=yrot,
  487:             legend=legend,
  488:             **kwds,
  489:         )
  490: 
  491:     if hasattr(axes, "ndim"):
  492:         if axes.ndim == 1 and len(axes) == 1:
  493:             return axes[0]
  494:     return axes
  495: 
  496: 
  497: def hist_frame(
  498:     data: DataFrame,
  499:     column=None,
  500:     by=None,
  501:     grid: bool = True,
  502:     xlabelsize: int | None = None,
  503:     xrot=None,
  504:     ylabelsize: int | None = None,
  505:     yrot=None,
  506:     ax=None,
  507:     sharex: bool = False,
  508:     sharey: bool = False,
  509:     figsize: tuple[float, float] | None = None,
  510:     layout=None,
  511:     bins: int = 10,
  512:     legend: bool = False,
  513:     **kwds,
  514: ):
  515:     if legend and "label" in kwds:
  516:         raise ValueError("Cannot use both legend and label")
  517:     if by is not None:
  518:         axes = _grouped_hist(
  519:             data,
  520:             column=column,
  521:             by=by,
  522:             ax=ax,
  523:             grid=grid,
  524:             figsize=figsize,
  525:             sharex=sharex,
  526:             sharey=sharey,
  527:             layout=layout,
  528:             bins=bins,
  529:             xlabelsize=xlabelsize,
  530:             xrot=xrot,
  531:             ylabelsize=ylabelsize,
  532:             yrot=yrot,
  533:             legend=legend,
  534:             **kwds,
  535:         )
  536:         return axes
  537: 
  538:     if column is not None:
  539:         if not isinstance(column, (list, np.ndarray, ABCIndex)):
  540:             column = [column]
  541:         data = data[column]
  542:     # GH32590
  543:     data = data.select_dtypes(
  544:         include=(np.number, "datetime64", "datetimetz"), exclude="timedelta"
  545:     )
  546:     naxes = len(data.columns)
  547: 
  548:     if naxes == 0:
  549:         raise ValueError(
  550:             "hist method requires numerical or datetime columns, nothing to plot."
  551:         )
  552: 
  553:     fig, axes = create_subplots(
  554:         naxes=naxes,
  555:         ax=ax,
  556:         squeeze=False,
  557:         sharex=sharex,
  558:         sharey=sharey,
  559:         figsize=figsize,
  560:         layout=layout,
  561:     )
  562:     _axes = flatten_axes(axes)
  563: 
  564:     can_set_label = "label" not in kwds
  565: 
  566:     for i, col in enumerate(data.columns):
  567:         ax = _axes[i]
  568:         if legend and can_set_label:
  569:             kwds["label"] = col
  570:         ax.hist(data[col].dropna().values, bins=bins, **kwds)
  571:         ax.set_title(col)
  572:         ax.grid(grid)
  573:         if legend:
  574:             ax.legend()
  575: 
  576:     set_ticks_props(
  577:         axes, xlabelsize=xlabelsize, xrot=xrot, ylabelsize=ylabelsize, yrot=yrot
  578:     )
  579:     maybe_adjust_figure(fig, wspace=0.3, hspace=0.3)
  580: 
  581:     return axes
