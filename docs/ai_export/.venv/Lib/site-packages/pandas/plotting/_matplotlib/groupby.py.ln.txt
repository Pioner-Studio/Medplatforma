    1: from __future__ import annotations
    2: 
    3: from typing import TYPE_CHECKING
    4: 
    5: import numpy as np
    6: 
    7: from pandas.core.dtypes.missing import remove_na_arraylike
    8: 
    9: from pandas import (
   10:     MultiIndex,
   11:     concat,
   12: )
   13: 
   14: from pandas.plotting._matplotlib.misc import unpack_single_str_list
   15: 
   16: if TYPE_CHECKING:
   17:     from collections.abc import Hashable
   18: 
   19:     from pandas._typing import IndexLabel
   20: 
   21:     from pandas import (
   22:         DataFrame,
   23:         Series,
   24:     )
   25: 
   26: 
   27: def create_iter_data_given_by(
   28:     data: DataFrame, kind: str = "hist"
   29: ) -> dict[Hashable, DataFrame | Series]:
   30:     """
   31:     Create data for iteration given `by` is assigned or not, and it is only
   32:     used in both hist and boxplot.
   33: 
   34:     If `by` is assigned, return a dictionary of DataFrames in which the key of
   35:     dictionary is the values in groups.
   36:     If `by` is not assigned, return input as is, and this preserves current
   37:     status of iter_data.
   38: 
   39:     Parameters
   40:     ----------
   41:     data : reformatted grouped data from `_compute_plot_data` method.
   42:     kind : str, plot kind. This function is only used for `hist` and `box` plots.
   43: 
   44:     Returns
   45:     -------
   46:     iter_data : DataFrame or Dictionary of DataFrames
   47: 
   48:     Examples
   49:     --------
   50:     If `by` is assigned:
   51: 
   52:     >>> import numpy as np
   53:     >>> tuples = [('h1', 'a'), ('h1', 'b'), ('h2', 'a'), ('h2', 'b')]
   54:     >>> mi = pd.MultiIndex.from_tuples(tuples)
   55:     >>> value = [[1, 3, np.nan, np.nan],
   56:     ...          [3, 4, np.nan, np.nan], [np.nan, np.nan, 5, 6]]
   57:     >>> data = pd.DataFrame(value, columns=mi)
   58:     >>> create_iter_data_given_by(data)
   59:     {'h1':     h1
   60:          a    b
   61:     0  1.0  3.0
   62:     1  3.0  4.0
   63:     2  NaN  NaN, 'h2':     h2
   64:          a    b
   65:     0  NaN  NaN
   66:     1  NaN  NaN
   67:     2  5.0  6.0}
   68:     """
   69: 
   70:     # For `hist` plot, before transformation, the values in level 0 are values
   71:     # in groups and subplot titles, and later used for column subselection and
   72:     # iteration; For `box` plot, values in level 1 are column names to show,
   73:     # and are used for iteration and as subplots titles.
   74:     if kind == "hist":
   75:         level = 0
   76:     else:
   77:         level = 1
   78: 
   79:     # Select sub-columns based on the value of level of MI, and if `by` is
   80:     # assigned, data must be a MI DataFrame
   81:     assert isinstance(data.columns, MultiIndex)
   82:     return {
   83:         col: data.loc[:, data.columns.get_level_values(level) == col]
   84:         for col in data.columns.levels[level]
   85:     }
   86: 
   87: 
   88: def reconstruct_data_with_by(
   89:     data: DataFrame, by: IndexLabel, cols: IndexLabel
   90: ) -> DataFrame:
   91:     """
   92:     Internal function to group data, and reassign multiindex column names onto the
   93:     result in order to let grouped data be used in _compute_plot_data method.
   94: 
   95:     Parameters
   96:     ----------
   97:     data : Original DataFrame to plot
   98:     by : grouped `by` parameter selected by users
   99:     cols : columns of data set (excluding columns used in `by`)
  100: 
  101:     Returns
  102:     -------
  103:     Output is the reconstructed DataFrame with MultiIndex columns. The first level
  104:     of MI is unique values of groups, and second level of MI is the columns
  105:     selected by users.
  106: 
  107:     Examples
  108:     --------
  109:     >>> d = {'h': ['h1', 'h1', 'h2'], 'a': [1, 3, 5], 'b': [3, 4, 6]}
  110:     >>> df = pd.DataFrame(d)
  111:     >>> reconstruct_data_with_by(df, by='h', cols=['a', 'b'])
  112:        h1      h2
  113:        a     b     a     b
  114:     0  1.0   3.0   NaN   NaN
  115:     1  3.0   4.0   NaN   NaN
  116:     2  NaN   NaN   5.0   6.0
  117:     """
  118:     by_modified = unpack_single_str_list(by)
  119:     grouped = data.groupby(by_modified)
  120: 
  121:     data_list = []
  122:     for key, group in grouped:
  123:         # error: List item 1 has incompatible type "Union[Hashable,
  124:         # Sequence[Hashable]]"; expected "Iterable[Hashable]"
  125:         columns = MultiIndex.from_product([[key], cols])  # type: ignore[list-item]
  126:         sub_group = group[cols]
  127:         sub_group.columns = columns
  128:         data_list.append(sub_group)
  129: 
  130:     data = concat(data_list, axis=1)
  131:     return data
  132: 
  133: 
  134: def reformat_hist_y_given_by(y: np.ndarray, by: IndexLabel | None) -> np.ndarray:
  135:     """Internal function to reformat y given `by` is applied or not for hist plot.
  136: 
  137:     If by is None, input y is 1-d with NaN removed; and if by is not None, groupby
  138:     will take place and input y is multi-dimensional array.
  139:     """
  140:     if by is not None and len(y.shape) > 1:
  141:         return np.array([remove_na_arraylike(col) for col in y.T]).T
  142:     return remove_na_arraylike(y)
