    1: from __future__ import annotations
    2: 
    3: from typing import TYPE_CHECKING
    4: 
    5: import numpy as np
    6: 
    7: import pandas as pd
    8: 
    9: if TYPE_CHECKING:
   10:     from collections.abc import Iterable
   11: 
   12: 
   13: class TablePlotter:
   14:     """
   15:     Layout some DataFrames in vertical/horizontal layout for explanation.
   16:     Used in merging.rst
   17:     """
   18: 
   19:     def __init__(
   20:         self,
   21:         cell_width: float = 0.37,
   22:         cell_height: float = 0.25,
   23:         font_size: float = 7.5,
   24:     ) -> None:
   25:         self.cell_width = cell_width
   26:         self.cell_height = cell_height
   27:         self.font_size = font_size
   28: 
   29:     def _shape(self, df: pd.DataFrame) -> tuple[int, int]:
   30:         """
   31:         Calculate table shape considering index levels.
   32:         """
   33:         row, col = df.shape
   34:         return row + df.columns.nlevels, col + df.index.nlevels
   35: 
   36:     def _get_cells(self, left, right, vertical) -> tuple[int, int]:
   37:         """
   38:         Calculate appropriate figure size based on left and right data.
   39:         """
   40:         if vertical:
   41:             # calculate required number of cells
   42:             vcells = max(sum(self._shape(df)[0] for df in left), self._shape(right)[0])
   43:             hcells = max(self._shape(df)[1] for df in left) + self._shape(right)[1]
   44:         else:
   45:             vcells = max([self._shape(df)[0] for df in left] + [self._shape(right)[0]])
   46:             hcells = sum([self._shape(df)[1] for df in left] + [self._shape(right)[1]])
   47:         return hcells, vcells
   48: 
   49:     def plot(self, left, right, labels: Iterable[str] = (), vertical: bool = True):
   50:         """
   51:         Plot left / right DataFrames in specified layout.
   52: 
   53:         Parameters
   54:         ----------
   55:         left : list of DataFrames before operation is applied
   56:         right : DataFrame of operation result
   57:         labels : list of str to be drawn as titles of left DataFrames
   58:         vertical : bool, default True
   59:             If True, use vertical layout. If False, use horizontal layout.
   60:         """
   61:         from matplotlib import gridspec
   62:         import matplotlib.pyplot as plt
   63: 
   64:         if not isinstance(left, list):
   65:             left = [left]
   66:         left = [self._conv(df) for df in left]
   67:         right = self._conv(right)
   68: 
   69:         hcells, vcells = self._get_cells(left, right, vertical)
   70: 
   71:         if vertical:
   72:             figsize = self.cell_width * hcells, self.cell_height * vcells
   73:         else:
   74:             # include margin for titles
   75:             figsize = self.cell_width * hcells, self.cell_height * vcells
   76:         fig = plt.figure(figsize=figsize)
   77: 
   78:         if vertical:
   79:             gs = gridspec.GridSpec(len(left), hcells)
   80:             # left
   81:             max_left_cols = max(self._shape(df)[1] for df in left)
   82:             max_left_rows = max(self._shape(df)[0] for df in left)
   83:             for i, (_left, _label) in enumerate(zip(left, labels)):
   84:                 ax = fig.add_subplot(gs[i, 0:max_left_cols])
   85:                 self._make_table(ax, _left, title=_label, height=1.0 / max_left_rows)
   86:             # right
   87:             ax = plt.subplot(gs[:, max_left_cols:])
   88:             self._make_table(ax, right, title="Result", height=1.05 / vcells)
   89:             fig.subplots_adjust(top=0.9, bottom=0.05, left=0.05, right=0.95)
   90:         else:
   91:             max_rows = max(self._shape(df)[0] for df in left + [right])
   92:             height = 1.0 / np.max(max_rows)
   93:             gs = gridspec.GridSpec(1, hcells)
   94:             # left
   95:             i = 0
   96:             for df, _label in zip(left, labels):
   97:                 sp = self._shape(df)
   98:                 ax = fig.add_subplot(gs[0, i : i + sp[1]])
   99:                 self._make_table(ax, df, title=_label, height=height)
  100:                 i += sp[1]
  101:             # right
  102:             ax = plt.subplot(gs[0, i:])
  103:             self._make_table(ax, right, title="Result", height=height)
  104:             fig.subplots_adjust(top=0.85, bottom=0.05, left=0.05, right=0.95)
  105: 
  106:         return fig
  107: 
  108:     def _conv(self, data):
  109:         """
  110:         Convert each input to appropriate for table outplot.
  111:         """
  112:         if isinstance(data, pd.Series):
  113:             if data.name is None:
  114:                 data = data.to_frame(name="")
  115:             else:
  116:                 data = data.to_frame()
  117:         data = data.fillna("NaN")
  118:         return data
  119: 
  120:     def _insert_index(self, data):
  121:         # insert is destructive
  122:         data = data.copy()
  123:         idx_nlevels = data.index.nlevels
  124:         if idx_nlevels == 1:
  125:             data.insert(0, "Index", data.index)
  126:         else:
  127:             for i in range(idx_nlevels):
  128:                 data.insert(i, f"Index{i}", data.index._get_level_values(i))
  129: 
  130:         col_nlevels = data.columns.nlevels
  131:         if col_nlevels > 1:
  132:             col = data.columns._get_level_values(0)
  133:             values = [
  134:                 data.columns._get_level_values(i)._values for i in range(1, col_nlevels)
  135:             ]
  136:             col_df = pd.DataFrame(values)
  137:             data.columns = col_df.columns
  138:             data = pd.concat([col_df, data])
  139:             data.columns = col
  140:         return data
  141: 
  142:     def _make_table(self, ax, df, title: str, height: float | None = None) -> None:
  143:         if df is None:
  144:             ax.set_visible(False)
  145:             return
  146: 
  147:         from pandas import plotting
  148: 
  149:         idx_nlevels = df.index.nlevels
  150:         col_nlevels = df.columns.nlevels
  151:         # must be convert here to get index levels for colorization
  152:         df = self._insert_index(df)
  153:         tb = plotting.table(ax, df, loc=9)
  154:         tb.set_fontsize(self.font_size)
  155: 
  156:         if height is None:
  157:             height = 1.0 / (len(df) + 1)
  158: 
  159:         props = tb.properties()
  160:         for (r, c), cell in props["celld"].items():
  161:             if c == -1:
  162:                 cell.set_visible(False)
  163:             elif r < col_nlevels and c < idx_nlevels:
  164:                 cell.set_visible(False)
  165:             elif r < col_nlevels or c < idx_nlevels:
  166:                 cell.set_facecolor("#AAAAAA")
  167:             cell.set_height(height)
  168: 
  169:         ax.set_title(title, size=self.font_size)
  170:         ax.axis("off")
  171: 
  172: 
  173: def main() -> None:
  174:     import matplotlib.pyplot as plt
  175: 
  176:     p = TablePlotter()
  177: 
  178:     df1 = pd.DataFrame({"A": [10, 11, 12], "B": [20, 21, 22], "C": [30, 31, 32]})
  179:     df2 = pd.DataFrame({"A": [10, 12], "C": [30, 32]})
  180: 
  181:     p.plot([df1, df2], pd.concat([df1, df2]), labels=["df1", "df2"], vertical=True)
  182:     plt.show()
  183: 
  184:     df3 = pd.DataFrame({"X": [10, 12], "Z": [30, 32]})
  185: 
  186:     p.plot(
  187:         [df1, df3], pd.concat([df1, df3], axis=1), labels=["df1", "df2"], vertical=False
  188:     )
  189:     plt.show()
  190: 
  191:     idx = pd.MultiIndex.from_tuples(
  192:         [(1, "A"), (1, "B"), (1, "C"), (2, "A"), (2, "B"), (2, "C")]
  193:     )
  194:     column = pd.MultiIndex.from_tuples([(1, "A"), (1, "B")])
  195:     df3 = pd.DataFrame({"v1": [1, 2, 3, 4, 5, 6], "v2": [5, 6, 7, 8, 9, 10]}, index=idx)
  196:     df3.columns = column
  197:     p.plot(df3, df3, labels=["df3"])
  198:     plt.show()
  199: 
  200: 
  201: if __name__ == "__main__":
  202:     main()
