    1: """
    2: This module provides decorator functions which can be applied to test objects
    3: in order to skip those objects when certain conditions occur. A sample use case
    4: is to detect if the platform is missing ``matplotlib``. If so, any test objects
    5: which require ``matplotlib`` and decorated with ``@td.skip_if_no("matplotlib")``
    6: will be skipped by ``pytest`` during the execution of the test suite.
    7: 
    8: To illustrate, after importing this module:
    9: 
   10: import pandas.util._test_decorators as td
   11: 
   12: The decorators can be applied to classes:
   13: 
   14: @td.skip_if_no("package")
   15: class Foo:
   16:     ...
   17: 
   18: Or individual functions:
   19: 
   20: @td.skip_if_no("package")
   21: def test_foo():
   22:     ...
   23: 
   24: For more information, refer to the ``pytest`` documentation on ``skipif``.
   25: """
   26: from __future__ import annotations
   27: 
   28: import locale
   29: from typing import (
   30:     TYPE_CHECKING,
   31:     Callable,
   32: )
   33: 
   34: import pytest
   35: 
   36: from pandas._config import get_option
   37: 
   38: if TYPE_CHECKING:
   39:     from pandas._typing import F
   40: 
   41: from pandas._config.config import _get_option
   42: 
   43: from pandas.compat import (
   44:     IS64,
   45:     is_platform_windows,
   46: )
   47: from pandas.compat._optional import import_optional_dependency
   48: 
   49: 
   50: def skip_if_installed(package: str) -> pytest.MarkDecorator:
   51:     """
   52:     Skip a test if a package is installed.
   53: 
   54:     Parameters
   55:     ----------
   56:     package : str
   57:         The name of the package.
   58: 
   59:     Returns
   60:     -------
   61:     pytest.MarkDecorator
   62:         a pytest.mark.skipif to use as either a test decorator or a
   63:         parametrization mark.
   64:     """
   65:     return pytest.mark.skipif(
   66:         bool(import_optional_dependency(package, errors="ignore")),
   67:         reason=f"Skipping because {package} is installed.",
   68:     )
   69: 
   70: 
   71: def skip_if_no(package: str, min_version: str | None = None) -> pytest.MarkDecorator:
   72:     """
   73:     Generic function to help skip tests when required packages are not
   74:     present on the testing system.
   75: 
   76:     This function returns a pytest mark with a skip condition that will be
   77:     evaluated during test collection. An attempt will be made to import the
   78:     specified ``package`` and optionally ensure it meets the ``min_version``
   79: 
   80:     The mark can be used as either a decorator for a test class or to be
   81:     applied to parameters in pytest.mark.parametrize calls or parametrized
   82:     fixtures. Use pytest.importorskip if an imported moduled is later needed
   83:     or for test functions.
   84: 
   85:     If the import and version check are unsuccessful, then the test function
   86:     (or test case when used in conjunction with parametrization) will be
   87:     skipped.
   88: 
   89:     Parameters
   90:     ----------
   91:     package: str
   92:         The name of the required package.
   93:     min_version: str or None, default None
   94:         Optional minimum version of the package.
   95: 
   96:     Returns
   97:     -------
   98:     pytest.MarkDecorator
   99:         a pytest.mark.skipif to use as either a test decorator or a
  100:         parametrization mark.
  101:     """
  102:     msg = f"Could not import '{package}'"
  103:     if min_version:
  104:         msg += f" satisfying a min_version of {min_version}"
  105:     return pytest.mark.skipif(
  106:         not bool(
  107:             import_optional_dependency(
  108:                 package, errors="ignore", min_version=min_version
  109:             )
  110:         ),
  111:         reason=msg,
  112:     )
  113: 
  114: 
  115: skip_if_32bit = pytest.mark.skipif(not IS64, reason="skipping for 32 bit")
  116: skip_if_windows = pytest.mark.skipif(is_platform_windows(), reason="Running on Windows")
  117: skip_if_not_us_locale = pytest.mark.skipif(
  118:     locale.getlocale()[0] != "en_US",
  119:     reason=f"Set local {locale.getlocale()[0]} is not en_US",
  120: )
  121: 
  122: 
  123: def parametrize_fixture_doc(*args) -> Callable[[F], F]:
  124:     """
  125:     Intended for use as a decorator for parametrized fixture,
  126:     this function will wrap the decorated function with a pytest
  127:     ``parametrize_fixture_doc`` mark. That mark will format
  128:     initial fixture docstring by replacing placeholders {0}, {1} etc
  129:     with parameters passed as arguments.
  130: 
  131:     Parameters
  132:     ----------
  133:     args: iterable
  134:         Positional arguments for docstring.
  135: 
  136:     Returns
  137:     -------
  138:     function
  139:         The decorated function wrapped within a pytest
  140:         ``parametrize_fixture_doc`` mark
  141:     """
  142: 
  143:     def documented_fixture(fixture):
  144:         fixture.__doc__ = fixture.__doc__.format(*args)
  145:         return fixture
  146: 
  147:     return documented_fixture
  148: 
  149: 
  150: def mark_array_manager_not_yet_implemented(request) -> None:
  151:     mark = pytest.mark.xfail(reason="Not yet implemented for ArrayManager")
  152:     request.applymarker(mark)
  153: 
  154: 
  155: skip_array_manager_not_yet_implemented = pytest.mark.xfail(
  156:     _get_option("mode.data_manager", silent=True) == "array",
  157:     reason="Not yet implemented for ArrayManager",
  158: )
  159: 
  160: skip_array_manager_invalid_test = pytest.mark.skipif(
  161:     _get_option("mode.data_manager", silent=True) == "array",
  162:     reason="Test that relies on BlockManager internals or specific behaviour",
  163: )
  164: 
  165: skip_copy_on_write_not_yet_implemented = pytest.mark.xfail(
  166:     get_option("mode.copy_on_write") is True,
  167:     reason="Not yet implemented/adapted for Copy-on-Write mode",
  168: )
  169: 
  170: skip_copy_on_write_invalid_test = pytest.mark.skipif(
  171:     get_option("mode.copy_on_write") is True,
  172:     reason="Test not valid for Copy-on-Write mode",
  173: )
