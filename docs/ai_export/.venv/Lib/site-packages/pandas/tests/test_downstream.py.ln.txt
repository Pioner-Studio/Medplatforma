    1: """
    2: Testing that we work in the downstream packages
    3: """
    4: import array
    5: import subprocess
    6: import sys
    7: 
    8: import numpy as np
    9: import pytest
   10: 
   11: from pandas.errors import IntCastingNaNError
   12: import pandas.util._test_decorators as td
   13: 
   14: import pandas as pd
   15: from pandas import (
   16:     DataFrame,
   17:     DatetimeIndex,
   18:     Series,
   19:     TimedeltaIndex,
   20: )
   21: import pandas._testing as tm
   22: from pandas.core.arrays import (
   23:     DatetimeArray,
   24:     TimedeltaArray,
   25: )
   26: 
   27: 
   28: @pytest.fixture
   29: def df():
   30:     return DataFrame({"A": [1, 2, 3]})
   31: 
   32: 
   33: def test_dask(df):
   34:     # dask sets "compute.use_numexpr" to False, so catch the current value
   35:     # and ensure to reset it afterwards to avoid impacting other tests
   36:     olduse = pd.get_option("compute.use_numexpr")
   37: 
   38:     try:
   39:         pytest.importorskip("toolz")
   40:         dd = pytest.importorskip("dask.dataframe")
   41: 
   42:         ddf = dd.from_pandas(df, npartitions=3)
   43:         assert ddf.A is not None
   44:         assert ddf.compute() is not None
   45:     finally:
   46:         pd.set_option("compute.use_numexpr", olduse)
   47: 
   48: 
   49: def test_dask_ufunc():
   50:     # dask sets "compute.use_numexpr" to False, so catch the current value
   51:     # and ensure to reset it afterwards to avoid impacting other tests
   52:     olduse = pd.get_option("compute.use_numexpr")
   53: 
   54:     try:
   55:         da = pytest.importorskip("dask.array")
   56:         dd = pytest.importorskip("dask.dataframe")
   57: 
   58:         s = Series([1.5, 2.3, 3.7, 4.0])
   59:         ds = dd.from_pandas(s, npartitions=2)
   60: 
   61:         result = da.fix(ds).compute()
   62:         expected = np.fix(s)
   63:         tm.assert_series_equal(result, expected)
   64:     finally:
   65:         pd.set_option("compute.use_numexpr", olduse)
   66: 
   67: 
   68: def test_construct_dask_float_array_int_dtype_match_ndarray():
   69:     # GH#40110 make sure we treat a float-dtype dask array with the same
   70:     #  rules we would for an ndarray
   71:     dd = pytest.importorskip("dask.dataframe")
   72: 
   73:     arr = np.array([1, 2.5, 3])
   74:     darr = dd.from_array(arr)
   75: 
   76:     res = Series(darr)
   77:     expected = Series(arr)
   78:     tm.assert_series_equal(res, expected)
   79: 
   80:     # GH#49599 in 2.0 we raise instead of silently ignoring the dtype
   81:     msg = "Trying to coerce float values to integers"
   82:     with pytest.raises(ValueError, match=msg):
   83:         Series(darr, dtype="i8")
   84: 
   85:     msg = r"Cannot convert non-finite values \(NA or inf\) to integer"
   86:     arr[2] = np.nan
   87:     with pytest.raises(IntCastingNaNError, match=msg):
   88:         Series(darr, dtype="i8")
   89:     # which is the same as we get with a numpy input
   90:     with pytest.raises(IntCastingNaNError, match=msg):
   91:         Series(arr, dtype="i8")
   92: 
   93: 
   94: def test_xarray(df):
   95:     pytest.importorskip("xarray")
   96: 
   97:     assert df.to_xarray() is not None
   98: 
   99: 
  100: def test_xarray_cftimeindex_nearest():
  101:     # https://github.com/pydata/xarray/issues/3751
  102:     cftime = pytest.importorskip("cftime")
  103:     xarray = pytest.importorskip("xarray")
  104: 
  105:     times = xarray.cftime_range("0001", periods=2)
  106:     key = cftime.DatetimeGregorian(2000, 1, 1)
  107:     result = times.get_indexer([key], method="nearest")
  108:     expected = 1
  109:     assert result == expected
  110: 
  111: 
  112: @pytest.mark.single_cpu
  113: def test_oo_optimizable():
  114:     # GH 21071
  115:     subprocess.check_call([sys.executable, "-OO", "-c", "import pandas"])
  116: 
  117: 
  118: @pytest.mark.single_cpu
  119: def test_oo_optimized_datetime_index_unpickle():
  120:     # GH 42866
  121:     subprocess.check_call(
  122:         [
  123:             sys.executable,
  124:             "-OO",
  125:             "-c",
  126:             (
  127:                 "import pandas as pd, pickle; "
  128:                 "pickle.loads(pickle.dumps(pd.date_range('2021-01-01', periods=1)))"
  129:             ),
  130:         ]
  131:     )
  132: 
  133: 
  134: def test_statsmodels():
  135:     smf = pytest.importorskip("statsmodels.formula.api")
  136: 
  137:     df = DataFrame(
  138:         {"Lottery": range(5), "Literacy": range(5), "Pop1831": range(100, 105)}
  139:     )
  140:     smf.ols("Lottery ~ Literacy + np.log(Pop1831)", data=df).fit()
  141: 
  142: 
  143: def test_scikit_learn():
  144:     pytest.importorskip("sklearn")
  145:     from sklearn import (
  146:         datasets,
  147:         svm,
  148:     )
  149: 
  150:     digits = datasets.load_digits()
  151:     clf = svm.SVC(gamma=0.001, C=100.0)
  152:     clf.fit(digits.data[:-1], digits.target[:-1])
  153:     clf.predict(digits.data[-1:])
  154: 
  155: 
  156: def test_seaborn():
  157:     seaborn = pytest.importorskip("seaborn")
  158:     tips = DataFrame(
  159:         {"day": pd.date_range("2023", freq="D", periods=5), "total_bill": range(5)}
  160:     )
  161:     seaborn.stripplot(x="day", y="total_bill", data=tips)
  162: 
  163: 
  164: def test_pandas_datareader():
  165:     pytest.importorskip("pandas_datareader")
  166: 
  167: 
  168: @pytest.mark.filterwarnings("ignore:Passing a BlockManager:DeprecationWarning")
  169: def test_pyarrow(df):
  170:     pyarrow = pytest.importorskip("pyarrow")
  171:     table = pyarrow.Table.from_pandas(df)
  172:     result = table.to_pandas()
  173:     tm.assert_frame_equal(result, df)
  174: 
  175: 
  176: def test_yaml_dump(df):
  177:     # GH#42748
  178:     yaml = pytest.importorskip("yaml")
  179: 
  180:     dumped = yaml.dump(df)
  181: 
  182:     loaded = yaml.load(dumped, Loader=yaml.Loader)
  183:     tm.assert_frame_equal(df, loaded)
  184: 
  185:     loaded2 = yaml.load(dumped, Loader=yaml.UnsafeLoader)
  186:     tm.assert_frame_equal(df, loaded2)
  187: 
  188: 
  189: @pytest.mark.single_cpu
  190: def test_missing_required_dependency():
  191:     # GH 23868
  192:     # To ensure proper isolation, we pass these flags
  193:     # -S : disable site-packages
  194:     # -s : disable user site-packages
  195:     # -E : disable PYTHON* env vars, especially PYTHONPATH
  196:     # https://github.com/MacPython/pandas-wheels/pull/50
  197: 
  198:     pyexe = sys.executable.replace("\\", "/")
  199: 
  200:     # We skip this test if pandas is installed as a site package. We first
  201:     # import the package normally and check the path to the module before
  202:     # executing the test which imports pandas with site packages disabled.
  203:     call = [pyexe, "-c", "import pandas;print(pandas.__file__)"]
  204:     output = subprocess.check_output(call).decode()
  205:     if "site-packages" in output:
  206:         pytest.skip("pandas installed as site package")
  207: 
  208:     # This test will fail if pandas is installed as a site package. The flags
  209:     # prevent pandas being imported and the test will report Failed: DID NOT
  210:     # RAISE <class 'subprocess.CalledProcessError'>
  211:     call = [pyexe, "-sSE", "-c", "import pandas"]
  212: 
  213:     msg = (
  214:         rf"Command '\['{pyexe}', '-sSE', '-c', 'import pandas'\]' "
  215:         "returned non-zero exit status 1."
  216:     )
  217: 
  218:     with pytest.raises(subprocess.CalledProcessError, match=msg) as exc:
  219:         subprocess.check_output(call, stderr=subprocess.STDOUT)
  220: 
  221:     output = exc.value.stdout.decode()
  222:     for name in ["numpy", "pytz", "dateutil"]:
  223:         assert name in output
  224: 
  225: 
  226: def test_frame_setitem_dask_array_into_new_col():
  227:     # GH#47128
  228: 
  229:     # dask sets "compute.use_numexpr" to False, so catch the current value
  230:     # and ensure to reset it afterwards to avoid impacting other tests
  231:     olduse = pd.get_option("compute.use_numexpr")
  232: 
  233:     try:
  234:         da = pytest.importorskip("dask.array")
  235: 
  236:         dda = da.array([1, 2])
  237:         df = DataFrame({"a": ["a", "b"]})
  238:         df["b"] = dda
  239:         df["c"] = dda
  240:         df.loc[[False, True], "b"] = 100
  241:         result = df.loc[[1], :]
  242:         expected = DataFrame({"a": ["b"], "b": [100], "c": [2]}, index=[1])
  243:         tm.assert_frame_equal(result, expected)
  244:     finally:
  245:         pd.set_option("compute.use_numexpr", olduse)
  246: 
  247: 
  248: def test_pandas_priority():
  249:     # GH#48347
  250: 
  251:     class MyClass:
  252:         __pandas_priority__ = 5000
  253: 
  254:         def __radd__(self, other):
  255:             return self
  256: 
  257:     left = MyClass()
  258:     right = Series(range(3))
  259: 
  260:     assert right.__add__(left) is NotImplemented
  261:     assert right + left is left
  262: 
  263: 
  264: @pytest.fixture(
  265:     params=[
  266:         "memoryview",
  267:         "array",
  268:         pytest.param("dask", marks=td.skip_if_no("dask.array")),
  269:         pytest.param("xarray", marks=td.skip_if_no("xarray")),
  270:     ]
  271: )
  272: def array_likes(request):
  273:     """
  274:     Fixture giving a numpy array and a parametrized 'data' object, which can
  275:     be a memoryview, array, dask or xarray object created from the numpy array.
  276:     """
  277:     # GH#24539 recognize e.g xarray, dask, ...
  278:     arr = np.array([1, 2, 3], dtype=np.int64)
  279: 
  280:     name = request.param
  281:     if name == "memoryview":
  282:         data = memoryview(arr)
  283:     elif name == "array":
  284:         data = array.array("i", arr)
  285:     elif name == "dask":
  286:         import dask.array
  287: 
  288:         data = dask.array.array(arr)
  289:     elif name == "xarray":
  290:         import xarray as xr
  291: 
  292:         data = xr.DataArray(arr)
  293: 
  294:     return arr, data
  295: 
  296: 
  297: @pytest.mark.parametrize("dtype", ["M8[ns]", "m8[ns]"])
  298: def test_from_obscure_array(dtype, array_likes):
  299:     # GH#24539 recognize e.g xarray, dask, ...
  300:     # Note: we dont do this for PeriodArray bc _from_sequence won't accept
  301:     #  an array of integers
  302:     # TODO: could check with arraylike of Period objects
  303:     arr, data = array_likes
  304: 
  305:     cls = {"M8[ns]": DatetimeArray, "m8[ns]": TimedeltaArray}[dtype]
  306: 
  307:     depr_msg = f"{cls.__name__}.__init__ is deprecated"
  308:     with tm.assert_produces_warning(FutureWarning, match=depr_msg):
  309:         expected = cls(arr)
  310:     result = cls._from_sequence(data, dtype=dtype)
  311:     tm.assert_extension_array_equal(result, expected)
  312: 
  313:     if not isinstance(data, memoryview):
  314:         # FIXME(GH#44431) these raise on memoryview and attempted fix
  315:         #  fails on py3.10
  316:         func = {"M8[ns]": pd.to_datetime, "m8[ns]": pd.to_timedelta}[dtype]
  317:         result = func(arr).array
  318:         expected = func(data).array
  319:         tm.assert_equal(result, expected)
  320: 
  321:     # Let's check the Indexes while we're here
  322:     idx_cls = {"M8[ns]": DatetimeIndex, "m8[ns]": TimedeltaIndex}[dtype]
  323:     result = idx_cls(arr)
  324:     expected = idx_cls(data)
  325:     tm.assert_index_equal(result, expected)
  326: 
  327: 
  328: def test_dataframe_consortium() -> None:
  329:     """
  330:     Test some basic methods of the dataframe consortium standard.
  331: 
  332:     Full testing is done at https://github.com/data-apis/dataframe-api-compat,
  333:     this is just to check that the entry point works as expected.
  334:     """
  335:     pytest.importorskip("dataframe_api_compat")
  336:     df_pd = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6]})
  337:     df = df_pd.__dataframe_consortium_standard__()
  338:     result_1 = df.get_column_names()
  339:     expected_1 = ["a", "b"]
  340:     assert result_1 == expected_1
  341: 
  342:     ser = Series([1, 2, 3], name="a")
  343:     col = ser.__column_consortium_standard__()
  344:     assert col.name == "a"
  345: 
  346: 
  347: def test_xarray_coerce_unit():
  348:     # GH44053
  349:     xr = pytest.importorskip("xarray")
  350: 
  351:     arr = xr.DataArray([1, 2, 3])
  352:     result = pd.to_datetime(arr, unit="ns")
  353:     expected = DatetimeIndex(
  354:         [
  355:             "1970-01-01 00:00:00.000000001",
  356:             "1970-01-01 00:00:00.000000002",
  357:             "1970-01-01 00:00:00.000000003",
  358:         ],
  359:         dtype="datetime64[ns]",
  360:         freq=None,
  361:     )
  362:     tm.assert_index_equal(result, expected)
