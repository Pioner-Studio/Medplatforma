    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas import (
    5:     DataFrame,
    6:     MultiIndex,
    7:     Series,
    8: )
    9: import pandas._testing as tm
   10: from pandas.tests.apply.common import frame_transform_kernels
   11: from pandas.tests.frame.common import zip_frames
   12: 
   13: 
   14: def unpack_obj(obj, klass, axis):
   15:     """
   16:     Helper to ensure we have the right type of object for a test parametrized
   17:     over frame_or_series.
   18:     """
   19:     if klass is not DataFrame:
   20:         obj = obj["A"]
   21:         if axis != 0:
   22:             pytest.skip(f"Test is only for DataFrame with axis={axis}")
   23:     return obj
   24: 
   25: 
   26: def test_transform_ufunc(axis, float_frame, frame_or_series):
   27:     # GH 35964
   28:     obj = unpack_obj(float_frame, frame_or_series, axis)
   29: 
   30:     with np.errstate(all="ignore"):
   31:         f_sqrt = np.sqrt(obj)
   32: 
   33:     # ufunc
   34:     result = obj.transform(np.sqrt, axis=axis)
   35:     expected = f_sqrt
   36:     tm.assert_equal(result, expected)
   37: 
   38: 
   39: @pytest.mark.parametrize(
   40:     "ops, names",
   41:     [
   42:         ([np.sqrt], ["sqrt"]),
   43:         ([np.abs, np.sqrt], ["absolute", "sqrt"]),
   44:         (np.array([np.sqrt]), ["sqrt"]),
   45:         (np.array([np.abs, np.sqrt]), ["absolute", "sqrt"]),
   46:     ],
   47: )
   48: def test_transform_listlike(axis, float_frame, ops, names):
   49:     # GH 35964
   50:     other_axis = 1 if axis in {0, "index"} else 0
   51:     with np.errstate(all="ignore"):
   52:         expected = zip_frames([op(float_frame) for op in ops], axis=other_axis)
   53:     if axis in {0, "index"}:
   54:         expected.columns = MultiIndex.from_product([float_frame.columns, names])
   55:     else:
   56:         expected.index = MultiIndex.from_product([float_frame.index, names])
   57:     result = float_frame.transform(ops, axis=axis)
   58:     tm.assert_frame_equal(result, expected)
   59: 
   60: 
   61: @pytest.mark.parametrize("ops", [[], np.array([])])
   62: def test_transform_empty_listlike(float_frame, ops, frame_or_series):
   63:     obj = unpack_obj(float_frame, frame_or_series, 0)
   64: 
   65:     with pytest.raises(ValueError, match="No transform functions were provided"):
   66:         obj.transform(ops)
   67: 
   68: 
   69: def test_transform_listlike_func_with_args():
   70:     # GH 50624
   71:     df = DataFrame({"x": [1, 2, 3]})
   72: 
   73:     def foo1(x, a=1, c=0):
   74:         return x + a + c
   75: 
   76:     def foo2(x, b=2, c=0):
   77:         return x + b + c
   78: 
   79:     msg = r"foo1\(\) got an unexpected keyword argument 'b'"
   80:     with pytest.raises(TypeError, match=msg):
   81:         df.transform([foo1, foo2], 0, 3, b=3, c=4)
   82: 
   83:     result = df.transform([foo1, foo2], 0, 3, c=4)
   84:     expected = DataFrame(
   85:         [[8, 8], [9, 9], [10, 10]],
   86:         columns=MultiIndex.from_tuples([("x", "foo1"), ("x", "foo2")]),
   87:     )
   88:     tm.assert_frame_equal(result, expected)
   89: 
   90: 
   91: @pytest.mark.parametrize("box", [dict, Series])
   92: def test_transform_dictlike(axis, float_frame, box):
   93:     # GH 35964
   94:     if axis in (0, "index"):
   95:         e = float_frame.columns[0]
   96:         expected = float_frame[[e]].transform(np.abs)
   97:     else:
   98:         e = float_frame.index[0]
   99:         expected = float_frame.iloc[[0]].transform(np.abs)
  100:     result = float_frame.transform(box({e: np.abs}), axis=axis)
  101:     tm.assert_frame_equal(result, expected)
  102: 
  103: 
  104: def test_transform_dictlike_mixed():
  105:     # GH 40018 - mix of lists and non-lists in values of a dictionary
  106:     df = DataFrame({"a": [1, 2], "b": [1, 4], "c": [1, 4]})
  107:     result = df.transform({"b": ["sqrt", "abs"], "c": "sqrt"})
  108:     expected = DataFrame(
  109:         [[1.0, 1, 1.0], [2.0, 4, 2.0]],
  110:         columns=MultiIndex([("b", "c"), ("sqrt", "abs")], [(0, 0, 1), (0, 1, 0)]),
  111:     )
  112:     tm.assert_frame_equal(result, expected)
  113: 
  114: 
  115: @pytest.mark.parametrize(
  116:     "ops",
  117:     [
  118:         {},
  119:         {"A": []},
  120:         {"A": [], "B": "cumsum"},
  121:         {"A": "cumsum", "B": []},
  122:         {"A": [], "B": ["cumsum"]},
  123:         {"A": ["cumsum"], "B": []},
  124:     ],
  125: )
  126: def test_transform_empty_dictlike(float_frame, ops, frame_or_series):
  127:     obj = unpack_obj(float_frame, frame_or_series, 0)
  128: 
  129:     with pytest.raises(ValueError, match="No transform functions were provided"):
  130:         obj.transform(ops)
  131: 
  132: 
  133: @pytest.mark.parametrize("use_apply", [True, False])
  134: def test_transform_udf(axis, float_frame, use_apply, frame_or_series):
  135:     # GH 35964
  136:     obj = unpack_obj(float_frame, frame_or_series, axis)
  137: 
  138:     # transform uses UDF either via apply or passing the entire DataFrame
  139:     def func(x):
  140:         # transform is using apply iff x is not a DataFrame
  141:         if use_apply == isinstance(x, frame_or_series):
  142:             # Force transform to fallback
  143:             raise ValueError
  144:         return x + 1
  145: 
  146:     result = obj.transform(func, axis=axis)
  147:     expected = obj + 1
  148:     tm.assert_equal(result, expected)
  149: 
  150: 
  151: wont_fail = ["ffill", "bfill", "fillna", "pad", "backfill", "shift"]
  152: frame_kernels_raise = [x for x in frame_transform_kernels if x not in wont_fail]
  153: 
  154: 
  155: @pytest.mark.parametrize("op", [*frame_kernels_raise, lambda x: x + 1])
  156: def test_transform_bad_dtype(op, frame_or_series, request):
  157:     # GH 35964
  158:     if op == "ngroup":
  159:         request.applymarker(
  160:             pytest.mark.xfail(raises=ValueError, reason="ngroup not valid for NDFrame")
  161:         )
  162: 
  163:     obj = DataFrame({"A": 3 * [object]})  # DataFrame that will fail on most transforms
  164:     obj = tm.get_obj(obj, frame_or_series)
  165:     error = TypeError
  166:     msg = "|".join(
  167:         [
  168:             "not supported between instances of 'type' and 'type'",
  169:             "unsupported operand type",
  170:         ]
  171:     )
  172: 
  173:     with pytest.raises(error, match=msg):
  174:         obj.transform(op)
  175:     with pytest.raises(error, match=msg):
  176:         obj.transform([op])
  177:     with pytest.raises(error, match=msg):
  178:         obj.transform({"A": op})
  179:     with pytest.raises(error, match=msg):
  180:         obj.transform({"A": [op]})
  181: 
  182: 
  183: @pytest.mark.parametrize("op", frame_kernels_raise)
  184: def test_transform_failure_typeerror(request, op):
  185:     # GH 35964
  186: 
  187:     if op == "ngroup":
  188:         request.applymarker(
  189:             pytest.mark.xfail(raises=ValueError, reason="ngroup not valid for NDFrame")
  190:         )
  191: 
  192:     # Using object makes most transform kernels fail
  193:     df = DataFrame({"A": 3 * [object], "B": [1, 2, 3]})
  194:     error = TypeError
  195:     msg = "|".join(
  196:         [
  197:             "not supported between instances of 'type' and 'type'",
  198:             "unsupported operand type",
  199:         ]
  200:     )
  201: 
  202:     with pytest.raises(error, match=msg):
  203:         df.transform([op])
  204: 
  205:     with pytest.raises(error, match=msg):
  206:         df.transform({"A": op, "B": op})
  207: 
  208:     with pytest.raises(error, match=msg):
  209:         df.transform({"A": [op], "B": [op]})
  210: 
  211:     with pytest.raises(error, match=msg):
  212:         df.transform({"A": [op, "shift"], "B": [op]})
  213: 
  214: 
  215: def test_transform_failure_valueerror():
  216:     # GH 40211
  217:     def op(x):
  218:         if np.sum(np.sum(x)) < 10:
  219:             raise ValueError
  220:         return x
  221: 
  222:     df = DataFrame({"A": [1, 2, 3], "B": [400, 500, 600]})
  223:     msg = "Transform function failed"
  224: 
  225:     with pytest.raises(ValueError, match=msg):
  226:         df.transform([op])
  227: 
  228:     with pytest.raises(ValueError, match=msg):
  229:         df.transform({"A": op, "B": op})
  230: 
  231:     with pytest.raises(ValueError, match=msg):
  232:         df.transform({"A": [op], "B": [op]})
  233: 
  234:     with pytest.raises(ValueError, match=msg):
  235:         df.transform({"A": [op, "shift"], "B": [op]})
  236: 
  237: 
  238: @pytest.mark.parametrize("use_apply", [True, False])
  239: def test_transform_passes_args(use_apply, frame_or_series):
  240:     # GH 35964
  241:     # transform uses UDF either via apply or passing the entire DataFrame
  242:     expected_args = [1, 2]
  243:     expected_kwargs = {"c": 3}
  244: 
  245:     def f(x, a, b, c):
  246:         # transform is using apply iff x is not a DataFrame
  247:         if use_apply == isinstance(x, frame_or_series):
  248:             # Force transform to fallback
  249:             raise ValueError
  250:         assert [a, b] == expected_args
  251:         assert c == expected_kwargs["c"]
  252:         return x
  253: 
  254:     frame_or_series([1]).transform(f, 0, *expected_args, **expected_kwargs)
  255: 
  256: 
  257: def test_transform_empty_dataframe():
  258:     # https://github.com/pandas-dev/pandas/issues/39636
  259:     df = DataFrame([], columns=["col1", "col2"])
  260:     result = df.transform(lambda x: x + 10)
  261:     tm.assert_frame_equal(result, df)
  262: 
  263:     result = df["col1"].transform(lambda x: x + 10)
  264:     tm.assert_series_equal(result, df["col1"])
