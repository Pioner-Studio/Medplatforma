    1: # Tests specifically aimed at detecting bad arguments.
    2: # This file is organized by reason for exception.
    3: #     1. always invalid argument values
    4: #     2. missing column(s)
    5: #     3. incompatible ops/dtype/args/kwargs
    6: #     4. invalid result shape/type
    7: # If your test does not fit into one of these categories, add to this list.
    8: 
    9: from itertools import chain
   10: import re
   11: 
   12: import numpy as np
   13: import pytest
   14: 
   15: from pandas.errors import SpecificationError
   16: 
   17: from pandas import (
   18:     DataFrame,
   19:     Series,
   20:     date_range,
   21: )
   22: import pandas._testing as tm
   23: 
   24: 
   25: @pytest.mark.parametrize("result_type", ["foo", 1])
   26: def test_result_type_error(result_type):
   27:     # allowed result_type
   28:     df = DataFrame(
   29:         np.tile(np.arange(3, dtype="int64"), 6).reshape(6, -1) + 1,
   30:         columns=["A", "B", "C"],
   31:     )
   32: 
   33:     msg = (
   34:         "invalid value for result_type, must be one of "
   35:         "{None, 'reduce', 'broadcast', 'expand'}"
   36:     )
   37:     with pytest.raises(ValueError, match=msg):
   38:         df.apply(lambda x: [1, 2, 3], axis=1, result_type=result_type)
   39: 
   40: 
   41: def test_apply_invalid_axis_value():
   42:     df = DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]], index=["a", "a", "c"])
   43:     msg = "No axis named 2 for object type DataFrame"
   44:     with pytest.raises(ValueError, match=msg):
   45:         df.apply(lambda x: x, 2)
   46: 
   47: 
   48: def test_agg_raises():
   49:     # GH 26513
   50:     df = DataFrame({"A": [0, 1], "B": [1, 2]})
   51:     msg = "Must provide"
   52: 
   53:     with pytest.raises(TypeError, match=msg):
   54:         df.agg()
   55: 
   56: 
   57: def test_map_with_invalid_na_action_raises():
   58:     # https://github.com/pandas-dev/pandas/issues/32815
   59:     s = Series([1, 2, 3])
   60:     msg = "na_action must either be 'ignore' or None"
   61:     with pytest.raises(ValueError, match=msg):
   62:         s.map(lambda x: x, na_action="____")
   63: 
   64: 
   65: @pytest.mark.parametrize("input_na_action", ["____", True])
   66: def test_map_arg_is_dict_with_invalid_na_action_raises(input_na_action):
   67:     # https://github.com/pandas-dev/pandas/issues/46588
   68:     s = Series([1, 2, 3])
   69:     msg = f"na_action must either be 'ignore' or None, {input_na_action} was passed"
   70:     with pytest.raises(ValueError, match=msg):
   71:         s.map({1: 2}, na_action=input_na_action)
   72: 
   73: 
   74: @pytest.mark.parametrize("method", ["apply", "agg", "transform"])
   75: @pytest.mark.parametrize("func", [{"A": {"B": "sum"}}, {"A": {"B": ["sum"]}}])
   76: def test_nested_renamer(frame_or_series, method, func):
   77:     # GH 35964
   78:     obj = frame_or_series({"A": [1]})
   79:     match = "nested renamer is not supported"
   80:     with pytest.raises(SpecificationError, match=match):
   81:         getattr(obj, method)(func)
   82: 
   83: 
   84: @pytest.mark.parametrize(
   85:     "renamer",
   86:     [{"foo": ["min", "max"]}, {"foo": ["min", "max"], "bar": ["sum", "mean"]}],
   87: )
   88: def test_series_nested_renamer(renamer):
   89:     s = Series(range(6), dtype="int64", name="series")
   90:     msg = "nested renamer is not supported"
   91:     with pytest.raises(SpecificationError, match=msg):
   92:         s.agg(renamer)
   93: 
   94: 
   95: def test_apply_dict_depr():
   96:     tsdf = DataFrame(
   97:         np.random.default_rng(2).standard_normal((10, 3)),
   98:         columns=["A", "B", "C"],
   99:         index=date_range("1/1/2000", periods=10),
  100:     )
  101:     msg = "nested renamer is not supported"
  102:     with pytest.raises(SpecificationError, match=msg):
  103:         tsdf.A.agg({"foo": ["sum", "mean"]})
  104: 
  105: 
  106: @pytest.mark.parametrize("method", ["agg", "transform"])
  107: def test_dict_nested_renaming_depr(method):
  108:     df = DataFrame({"A": range(5), "B": 5})
  109: 
  110:     # nested renaming
  111:     msg = r"nested renamer is not supported"
  112:     with pytest.raises(SpecificationError, match=msg):
  113:         getattr(df, method)({"A": {"foo": "min"}, "B": {"bar": "max"}})
  114: 
  115: 
  116: @pytest.mark.parametrize("method", ["apply", "agg", "transform"])
  117: @pytest.mark.parametrize("func", [{"B": "sum"}, {"B": ["sum"]}])
  118: def test_missing_column(method, func):
  119:     # GH 40004
  120:     obj = DataFrame({"A": [1]})
  121:     match = re.escape("Column(s) ['B'] do not exist")
  122:     with pytest.raises(KeyError, match=match):
  123:         getattr(obj, method)(func)
  124: 
  125: 
  126: def test_transform_mixed_column_name_dtypes():
  127:     # GH39025
  128:     df = DataFrame({"a": ["1"]})
  129:     msg = r"Column\(s\) \[1, 'b'\] do not exist"
  130:     with pytest.raises(KeyError, match=msg):
  131:         df.transform({"a": int, 1: str, "b": int})
  132: 
  133: 
  134: @pytest.mark.parametrize(
  135:     "how, args", [("pct_change", ()), ("nsmallest", (1, ["a", "b"])), ("tail", 1)]
  136: )
  137: def test_apply_str_axis_1_raises(how, args):
  138:     # GH 39211 - some ops don't support axis=1
  139:     df = DataFrame({"a": [1, 2], "b": [3, 4]})
  140:     msg = f"Operation {how} does not support axis=1"
  141:     with pytest.raises(ValueError, match=msg):
  142:         df.apply(how, axis=1, args=args)
  143: 
  144: 
  145: def test_transform_axis_1_raises():
  146:     # GH 35964
  147:     msg = "No axis named 1 for object type Series"
  148:     with pytest.raises(ValueError, match=msg):
  149:         Series([1]).transform("sum", axis=1)
  150: 
  151: 
  152: def test_apply_modify_traceback():
  153:     data = DataFrame(
  154:         {
  155:             "A": [
  156:                 "foo",
  157:                 "foo",
  158:                 "foo",
  159:                 "foo",
  160:                 "bar",
  161:                 "bar",
  162:                 "bar",
  163:                 "bar",
  164:                 "foo",
  165:                 "foo",
  166:                 "foo",
  167:             ],
  168:             "B": [
  169:                 "one",
  170:                 "one",
  171:                 "one",
  172:                 "two",
  173:                 "one",
  174:                 "one",
  175:                 "one",
  176:                 "two",
  177:                 "two",
  178:                 "two",
  179:                 "one",
  180:             ],
  181:             "C": [
  182:                 "dull",
  183:                 "dull",
  184:                 "shiny",
  185:                 "dull",
  186:                 "dull",
  187:                 "shiny",
  188:                 "shiny",
  189:                 "dull",
  190:                 "shiny",
  191:                 "shiny",
  192:                 "shiny",
  193:             ],
  194:             "D": np.random.default_rng(2).standard_normal(11),
  195:             "E": np.random.default_rng(2).standard_normal(11),
  196:             "F": np.random.default_rng(2).standard_normal(11),
  197:         }
  198:     )
  199: 
  200:     data.loc[4, "C"] = np.nan
  201: 
  202:     def transform(row):
  203:         if row["C"].startswith("shin") and row["A"] == "foo":
  204:             row["D"] = 7
  205:         return row
  206: 
  207:     msg = "'float' object has no attribute 'startswith'"
  208:     with pytest.raises(AttributeError, match=msg):
  209:         data.apply(transform, axis=1)
  210: 
  211: 
  212: @pytest.mark.parametrize(
  213:     "df, func, expected",
  214:     tm.get_cython_table_params(
  215:         DataFrame([["a", "b"], ["b", "a"]]), [["cumprod", TypeError]]
  216:     ),
  217: )
  218: def test_agg_cython_table_raises_frame(df, func, expected, axis, using_infer_string):
  219:     # GH 21224
  220:     if using_infer_string:
  221:         import pyarrow as pa
  222: 
  223:         expected = (expected, pa.lib.ArrowNotImplementedError)
  224: 
  225:     msg = "can't multiply sequence by non-int of type 'str'|has no kernel"
  226:     warn = None if isinstance(func, str) else FutureWarning
  227:     with pytest.raises(expected, match=msg):
  228:         with tm.assert_produces_warning(warn, match="using DataFrame.cumprod"):
  229:             df.agg(func, axis=axis)
  230: 
  231: 
  232: @pytest.mark.parametrize(
  233:     "series, func, expected",
  234:     chain(
  235:         tm.get_cython_table_params(
  236:             Series("a b c".split()),
  237:             [
  238:                 ("mean", TypeError),  # mean raises TypeError
  239:                 ("prod", TypeError),
  240:                 ("std", TypeError),
  241:                 ("var", TypeError),
  242:                 ("median", TypeError),
  243:                 ("cumprod", TypeError),
  244:             ],
  245:         )
  246:     ),
  247: )
  248: def test_agg_cython_table_raises_series(series, func, expected, using_infer_string):
  249:     # GH21224
  250:     msg = r"[Cc]ould not convert|can't multiply sequence by non-int of type"
  251:     if func == "median" or func is np.nanmedian or func is np.median:
  252:         msg = r"Cannot convert \['a' 'b' 'c'\] to numeric"
  253: 
  254:     if using_infer_string:
  255:         import pyarrow as pa
  256: 
  257:         expected = (expected, pa.lib.ArrowNotImplementedError)
  258: 
  259:     msg = msg + "|does not support|has no kernel"
  260:     warn = None if isinstance(func, str) else FutureWarning
  261: 
  262:     with pytest.raises(expected, match=msg):
  263:         # e.g. Series('a b'.split()).cumprod() will raise
  264:         with tm.assert_produces_warning(warn, match="is currently using Series.*"):
  265:             series.agg(func)
  266: 
  267: 
  268: def test_agg_none_to_type():
  269:     # GH 40543
  270:     df = DataFrame({"a": [None]})
  271:     msg = re.escape("int() argument must be a string")
  272:     with pytest.raises(TypeError, match=msg):
  273:         df.agg({"a": lambda x: int(x.iloc[0])})
  274: 
  275: 
  276: def test_transform_none_to_type():
  277:     # GH#34377
  278:     df = DataFrame({"a": [None]})
  279:     msg = "argument must be a"
  280:     with pytest.raises(TypeError, match=msg):
  281:         df.transform({"a": lambda x: int(x.iloc[0])})
  282: 
  283: 
  284: @pytest.mark.parametrize(
  285:     "func",
  286:     [
  287:         lambda x: np.array([1, 2]).reshape(-1, 2),
  288:         lambda x: [1, 2],
  289:         lambda x: Series([1, 2]),
  290:     ],
  291: )
  292: def test_apply_broadcast_error(func):
  293:     df = DataFrame(
  294:         np.tile(np.arange(3, dtype="int64"), 6).reshape(6, -1) + 1,
  295:         columns=["A", "B", "C"],
  296:     )
  297: 
  298:     # > 1 ndim
  299:     msg = "too many dims to broadcast|cannot broadcast result"
  300:     with pytest.raises(ValueError, match=msg):
  301:         df.apply(func, axis=1, result_type="broadcast")
  302: 
  303: 
  304: def test_transform_and_agg_err_agg(axis, float_frame):
  305:     # cannot both transform and agg
  306:     msg = "cannot combine transform and aggregation operations"
  307:     with pytest.raises(ValueError, match=msg):
  308:         with np.errstate(all="ignore"):
  309:             float_frame.agg(["max", "sqrt"], axis=axis)
  310: 
  311: 
  312: @pytest.mark.filterwarnings("ignore::FutureWarning")  # GH53325
  313: @pytest.mark.parametrize(
  314:     "func, msg",
  315:     [
  316:         (["sqrt", "max"], "cannot combine transform and aggregation"),
  317:         (
  318:             {"foo": np.sqrt, "bar": "sum"},
  319:             "cannot perform both aggregation and transformation",
  320:         ),
  321:     ],
  322: )
  323: def test_transform_and_agg_err_series(string_series, func, msg):
  324:     # we are trying to transform with an aggregator
  325:     with pytest.raises(ValueError, match=msg):
  326:         with np.errstate(all="ignore"):
  327:             string_series.agg(func)
  328: 
  329: 
  330: @pytest.mark.parametrize("func", [["max", "min"], ["max", "sqrt"]])
  331: def test_transform_wont_agg_frame(axis, float_frame, func):
  332:     # GH 35964
  333:     # cannot both transform and agg
  334:     msg = "Function did not transform"
  335:     with pytest.raises(ValueError, match=msg):
  336:         float_frame.transform(func, axis=axis)
  337: 
  338: 
  339: @pytest.mark.parametrize("func", [["min", "max"], ["sqrt", "max"]])
  340: def test_transform_wont_agg_series(string_series, func):
  341:     # GH 35964
  342:     # we are trying to transform with an aggregator
  343:     msg = "Function did not transform"
  344: 
  345:     with pytest.raises(ValueError, match=msg):
  346:         string_series.transform(func)
  347: 
  348: 
  349: @pytest.mark.parametrize(
  350:     "op_wrapper", [lambda x: x, lambda x: [x], lambda x: {"A": x}, lambda x: {"A": [x]}]
  351: )
  352: def test_transform_reducer_raises(all_reductions, frame_or_series, op_wrapper):
  353:     # GH 35964
  354:     op = op_wrapper(all_reductions)
  355: 
  356:     obj = DataFrame({"A": [1, 2, 3]})
  357:     obj = tm.get_obj(obj, frame_or_series)
  358: 
  359:     msg = "Function did not transform"
  360:     with pytest.raises(ValueError, match=msg):
  361:         obj.transform(op)
