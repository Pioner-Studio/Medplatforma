    1: from itertools import chain
    2: import operator
    3: 
    4: import numpy as np
    5: import pytest
    6: 
    7: from pandas.core.dtypes.common import is_number
    8: 
    9: from pandas import (
   10:     DataFrame,
   11:     Series,
   12: )
   13: import pandas._testing as tm
   14: from pandas.tests.apply.common import (
   15:     frame_transform_kernels,
   16:     series_transform_kernels,
   17: )
   18: 
   19: 
   20: @pytest.mark.parametrize("func", ["sum", "mean", "min", "max", "std"])
   21: @pytest.mark.parametrize(
   22:     "args,kwds",
   23:     [
   24:         pytest.param([], {}, id="no_args_or_kwds"),
   25:         pytest.param([1], {}, id="axis_from_args"),
   26:         pytest.param([], {"axis": 1}, id="axis_from_kwds"),
   27:         pytest.param([], {"numeric_only": True}, id="optional_kwds"),
   28:         pytest.param([1, True], {"numeric_only": True}, id="args_and_kwds"),
   29:     ],
   30: )
   31: @pytest.mark.parametrize("how", ["agg", "apply"])
   32: def test_apply_with_string_funcs(request, float_frame, func, args, kwds, how):
   33:     if len(args) > 1 and how == "agg":
   34:         request.applymarker(
   35:             pytest.mark.xfail(
   36:                 raises=TypeError,
   37:                 reason="agg/apply signature mismatch - agg passes 2nd "
   38:                 "argument to func",
   39:             )
   40:         )
   41:     result = getattr(float_frame, how)(func, *args, **kwds)
   42:     expected = getattr(float_frame, func)(*args, **kwds)
   43:     tm.assert_series_equal(result, expected)
   44: 
   45: 
   46: @pytest.mark.parametrize("arg", ["sum", "mean", "min", "max", "std"])
   47: def test_with_string_args(datetime_series, arg):
   48:     result = datetime_series.apply(arg)
   49:     expected = getattr(datetime_series, arg)()
   50:     assert result == expected
   51: 
   52: 
   53: @pytest.mark.parametrize("op", ["mean", "median", "std", "var"])
   54: @pytest.mark.parametrize("how", ["agg", "apply"])
   55: def test_apply_np_reducer(op, how):
   56:     # GH 39116
   57:     float_frame = DataFrame({"a": [1, 2], "b": [3, 4]})
   58:     result = getattr(float_frame, how)(op)
   59:     # pandas ddof defaults to 1, numpy to 0
   60:     kwargs = {"ddof": 1} if op in ("std", "var") else {}
   61:     expected = Series(
   62:         getattr(np, op)(float_frame, axis=0, **kwargs), index=float_frame.columns
   63:     )
   64:     tm.assert_series_equal(result, expected)
   65: 
   66: 
   67: @pytest.mark.parametrize(
   68:     "op", ["abs", "ceil", "cos", "cumsum", "exp", "log", "sqrt", "square"]
   69: )
   70: @pytest.mark.parametrize("how", ["transform", "apply"])
   71: def test_apply_np_transformer(float_frame, op, how):
   72:     # GH 39116
   73: 
   74:     # float_frame will _usually_ have negative values, which will
   75:     #  trigger the warning here, but let's put one in just to be sure
   76:     float_frame.iloc[0, 0] = -1.0
   77:     warn = None
   78:     if op in ["log", "sqrt"]:
   79:         warn = RuntimeWarning
   80: 
   81:     with tm.assert_produces_warning(warn, check_stacklevel=False):
   82:         # float_frame fixture is defined in conftest.py, so we don't check the
   83:         # stacklevel as otherwise the test would fail.
   84:         result = getattr(float_frame, how)(op)
   85:         expected = getattr(np, op)(float_frame)
   86:     tm.assert_frame_equal(result, expected)
   87: 
   88: 
   89: @pytest.mark.parametrize(
   90:     "series, func, expected",
   91:     chain(
   92:         tm.get_cython_table_params(
   93:             Series(dtype=np.float64),
   94:             [
   95:                 ("sum", 0),
   96:                 ("max", np.nan),
   97:                 ("min", np.nan),
   98:                 ("all", True),
   99:                 ("any", False),
  100:                 ("mean", np.nan),
  101:                 ("prod", 1),
  102:                 ("std", np.nan),
  103:                 ("var", np.nan),
  104:                 ("median", np.nan),
  105:             ],
  106:         ),
  107:         tm.get_cython_table_params(
  108:             Series([np.nan, 1, 2, 3]),
  109:             [
  110:                 ("sum", 6),
  111:                 ("max", 3),
  112:                 ("min", 1),
  113:                 ("all", True),
  114:                 ("any", True),
  115:                 ("mean", 2),
  116:                 ("prod", 6),
  117:                 ("std", 1),
  118:                 ("var", 1),
  119:                 ("median", 2),
  120:             ],
  121:         ),
  122:         tm.get_cython_table_params(
  123:             Series("a b c".split()),
  124:             [
  125:                 ("sum", "abc"),
  126:                 ("max", "c"),
  127:                 ("min", "a"),
  128:                 ("all", True),
  129:                 ("any", True),
  130:             ],
  131:         ),
  132:     ),
  133: )
  134: def test_agg_cython_table_series(series, func, expected):
  135:     # GH21224
  136:     # test reducing functions in
  137:     # pandas.core.base.SelectionMixin._cython_table
  138:     warn = None if isinstance(func, str) else FutureWarning
  139:     with tm.assert_produces_warning(warn, match="is currently using Series.*"):
  140:         result = series.agg(func)
  141:     if is_number(expected):
  142:         assert np.isclose(result, expected, equal_nan=True)
  143:     else:
  144:         assert result == expected
  145: 
  146: 
  147: @pytest.mark.parametrize(
  148:     "series, func, expected",
  149:     chain(
  150:         tm.get_cython_table_params(
  151:             Series(dtype=np.float64),
  152:             [
  153:                 ("cumprod", Series([], dtype=np.float64)),
  154:                 ("cumsum", Series([], dtype=np.float64)),
  155:             ],
  156:         ),
  157:         tm.get_cython_table_params(
  158:             Series([np.nan, 1, 2, 3]),
  159:             [
  160:                 ("cumprod", Series([np.nan, 1, 2, 6])),
  161:                 ("cumsum", Series([np.nan, 1, 3, 6])),
  162:             ],
  163:         ),
  164:         tm.get_cython_table_params(
  165:             Series("a b c".split()), [("cumsum", Series(["a", "ab", "abc"]))]
  166:         ),
  167:     ),
  168: )
  169: def test_agg_cython_table_transform_series(series, func, expected):
  170:     # GH21224
  171:     # test transforming functions in
  172:     # pandas.core.base.SelectionMixin._cython_table (cumprod, cumsum)
  173:     warn = None if isinstance(func, str) else FutureWarning
  174:     with tm.assert_produces_warning(warn, match="is currently using Series.*"):
  175:         result = series.agg(func)
  176:     tm.assert_series_equal(result, expected)
  177: 
  178: 
  179: @pytest.mark.parametrize(
  180:     "df, func, expected",
  181:     chain(
  182:         tm.get_cython_table_params(
  183:             DataFrame(),
  184:             [
  185:                 ("sum", Series(dtype="float64")),
  186:                 ("max", Series(dtype="float64")),
  187:                 ("min", Series(dtype="float64")),
  188:                 ("all", Series(dtype=bool)),
  189:                 ("any", Series(dtype=bool)),
  190:                 ("mean", Series(dtype="float64")),
  191:                 ("prod", Series(dtype="float64")),
  192:                 ("std", Series(dtype="float64")),
  193:                 ("var", Series(dtype="float64")),
  194:                 ("median", Series(dtype="float64")),
  195:             ],
  196:         ),
  197:         tm.get_cython_table_params(
  198:             DataFrame([[np.nan, 1], [1, 2]]),
  199:             [
  200:                 ("sum", Series([1.0, 3])),
  201:                 ("max", Series([1.0, 2])),
  202:                 ("min", Series([1.0, 1])),
  203:                 ("all", Series([True, True])),
  204:                 ("any", Series([True, True])),
  205:                 ("mean", Series([1, 1.5])),
  206:                 ("prod", Series([1.0, 2])),
  207:                 ("std", Series([np.nan, 0.707107])),
  208:                 ("var", Series([np.nan, 0.5])),
  209:                 ("median", Series([1, 1.5])),
  210:             ],
  211:         ),
  212:     ),
  213: )
  214: def test_agg_cython_table_frame(df, func, expected, axis):
  215:     # GH 21224
  216:     # test reducing functions in
  217:     # pandas.core.base.SelectionMixin._cython_table
  218:     warn = None if isinstance(func, str) else FutureWarning
  219:     with tm.assert_produces_warning(warn, match="is currently using DataFrame.*"):
  220:         # GH#53425
  221:         result = df.agg(func, axis=axis)
  222:     tm.assert_series_equal(result, expected)
  223: 
  224: 
  225: @pytest.mark.parametrize(
  226:     "df, func, expected",
  227:     chain(
  228:         tm.get_cython_table_params(
  229:             DataFrame(), [("cumprod", DataFrame()), ("cumsum", DataFrame())]
  230:         ),
  231:         tm.get_cython_table_params(
  232:             DataFrame([[np.nan, 1], [1, 2]]),
  233:             [
  234:                 ("cumprod", DataFrame([[np.nan, 1], [1, 2]])),
  235:                 ("cumsum", DataFrame([[np.nan, 1], [1, 3]])),
  236:             ],
  237:         ),
  238:     ),
  239: )
  240: def test_agg_cython_table_transform_frame(df, func, expected, axis):
  241:     # GH 21224
  242:     # test transforming functions in
  243:     # pandas.core.base.SelectionMixin._cython_table (cumprod, cumsum)
  244:     if axis in ("columns", 1):
  245:         # operating blockwise doesn't let us preserve dtypes
  246:         expected = expected.astype("float64")
  247: 
  248:     warn = None if isinstance(func, str) else FutureWarning
  249:     with tm.assert_produces_warning(warn, match="is currently using DataFrame.*"):
  250:         # GH#53425
  251:         result = df.agg(func, axis=axis)
  252:     tm.assert_frame_equal(result, expected)
  253: 
  254: 
  255: @pytest.mark.parametrize("op", series_transform_kernels)
  256: def test_transform_groupby_kernel_series(request, string_series, op):
  257:     # GH 35964
  258:     if op == "ngroup":
  259:         request.applymarker(
  260:             pytest.mark.xfail(raises=ValueError, reason="ngroup not valid for NDFrame")
  261:         )
  262:     args = [0.0] if op == "fillna" else []
  263:     ones = np.ones(string_series.shape[0])
  264: 
  265:     warn = FutureWarning if op == "fillna" else None
  266:     msg = "SeriesGroupBy.fillna is deprecated"
  267:     with tm.assert_produces_warning(warn, match=msg):
  268:         expected = string_series.groupby(ones).transform(op, *args)
  269:     result = string_series.transform(op, 0, *args)
  270:     tm.assert_series_equal(result, expected)
  271: 
  272: 
  273: @pytest.mark.parametrize("op", frame_transform_kernels)
  274: def test_transform_groupby_kernel_frame(request, axis, float_frame, op):
  275:     if op == "ngroup":
  276:         request.applymarker(
  277:             pytest.mark.xfail(raises=ValueError, reason="ngroup not valid for NDFrame")
  278:         )
  279: 
  280:     # GH 35964
  281: 
  282:     args = [0.0] if op == "fillna" else []
  283:     if axis in (0, "index"):
  284:         ones = np.ones(float_frame.shape[0])
  285:         msg = "The 'axis' keyword in DataFrame.groupby is deprecated"
  286:     else:
  287:         ones = np.ones(float_frame.shape[1])
  288:         msg = "DataFrame.groupby with axis=1 is deprecated"
  289: 
  290:     with tm.assert_produces_warning(FutureWarning, match=msg):
  291:         gb = float_frame.groupby(ones, axis=axis)
  292: 
  293:     warn = FutureWarning if op == "fillna" else None
  294:     op_msg = "DataFrameGroupBy.fillna is deprecated"
  295:     with tm.assert_produces_warning(warn, match=op_msg):
  296:         expected = gb.transform(op, *args)
  297: 
  298:     result = float_frame.transform(op, axis, *args)
  299:     tm.assert_frame_equal(result, expected)
  300: 
  301:     # same thing, but ensuring we have multiple blocks
  302:     assert "E" not in float_frame.columns
  303:     float_frame["E"] = float_frame["A"].copy()
  304:     assert len(float_frame._mgr.arrays) > 1
  305: 
  306:     if axis in (0, "index"):
  307:         ones = np.ones(float_frame.shape[0])
  308:     else:
  309:         ones = np.ones(float_frame.shape[1])
  310:     with tm.assert_produces_warning(FutureWarning, match=msg):
  311:         gb2 = float_frame.groupby(ones, axis=axis)
  312:     warn = FutureWarning if op == "fillna" else None
  313:     op_msg = "DataFrameGroupBy.fillna is deprecated"
  314:     with tm.assert_produces_warning(warn, match=op_msg):
  315:         expected2 = gb2.transform(op, *args)
  316:     result2 = float_frame.transform(op, axis, *args)
  317:     tm.assert_frame_equal(result2, expected2)
  318: 
  319: 
  320: @pytest.mark.parametrize("method", ["abs", "shift", "pct_change", "cumsum", "rank"])
  321: def test_transform_method_name(method):
  322:     # GH 19760
  323:     df = DataFrame({"A": [-1, 2]})
  324:     result = df.transform(method)
  325:     expected = operator.methodcaller(method)(df)
  326:     tm.assert_frame_equal(result, expected)
