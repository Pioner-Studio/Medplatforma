    1: from datetime import datetime
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: from pandas.core.dtypes.common import is_extension_array_dtype
    7: 
    8: import pandas as pd
    9: from pandas import (
   10:     DataFrame,
   11:     DatetimeIndex,
   12:     Index,
   13:     MultiIndex,
   14:     NaT,
   15:     PeriodIndex,
   16:     Series,
   17:     TimedeltaIndex,
   18: )
   19: import pandas._testing as tm
   20: from pandas.core.groupby.groupby import DataError
   21: from pandas.core.groupby.grouper import Grouper
   22: from pandas.core.indexes.datetimes import date_range
   23: from pandas.core.indexes.period import period_range
   24: from pandas.core.indexes.timedeltas import timedelta_range
   25: from pandas.core.resample import _asfreq_compat
   26: 
   27: # a fixture value can be overridden by the test parameter value. Note that the
   28: # value of the fixture can be overridden this way even if the test doesn't use
   29: # it directly (doesn't mention it in the function prototype).
   30: # see https://docs.pytest.org/en/latest/fixture.html#override-a-fixture-with-direct-test-parametrization  # noqa: E501
   31: # in this module we override the fixture values defined in conftest.py
   32: # tuples of '_index_factory,_series_name,_index_start,_index_end'
   33: DATE_RANGE = (date_range, "dti", datetime(2005, 1, 1), datetime(2005, 1, 10))
   34: PERIOD_RANGE = (period_range, "pi", datetime(2005, 1, 1), datetime(2005, 1, 10))
   35: TIMEDELTA_RANGE = (timedelta_range, "tdi", "1 day", "10 day")
   36: 
   37: all_ts = pytest.mark.parametrize(
   38:     "_index_factory,_series_name,_index_start,_index_end",
   39:     [DATE_RANGE, PERIOD_RANGE, TIMEDELTA_RANGE],
   40: )
   41: 
   42: 
   43: @pytest.fixture
   44: def create_index(_index_factory):
   45:     def _create_index(*args, **kwargs):
   46:         """return the _index_factory created using the args, kwargs"""
   47:         return _index_factory(*args, **kwargs)
   48: 
   49:     return _create_index
   50: 
   51: 
   52: @pytest.mark.parametrize("freq", ["2D", "1h"])
   53: @pytest.mark.parametrize(
   54:     "_index_factory,_series_name,_index_start,_index_end", [DATE_RANGE, TIMEDELTA_RANGE]
   55: )
   56: def test_asfreq(series_and_frame, freq, create_index):
   57:     obj = series_and_frame
   58: 
   59:     result = obj.resample(freq).asfreq()
   60:     new_index = create_index(obj.index[0], obj.index[-1], freq=freq)
   61:     expected = obj.reindex(new_index)
   62:     tm.assert_almost_equal(result, expected)
   63: 
   64: 
   65: @pytest.mark.parametrize(
   66:     "_index_factory,_series_name,_index_start,_index_end", [DATE_RANGE, TIMEDELTA_RANGE]
   67: )
   68: def test_asfreq_fill_value(series, create_index):
   69:     # test for fill value during resampling, issue 3715
   70: 
   71:     ser = series
   72: 
   73:     result = ser.resample("1h").asfreq()
   74:     new_index = create_index(ser.index[0], ser.index[-1], freq="1h")
   75:     expected = ser.reindex(new_index)
   76:     tm.assert_series_equal(result, expected)
   77: 
   78:     # Explicit cast to float to avoid implicit cast when setting None
   79:     frame = ser.astype("float").to_frame("value")
   80:     frame.iloc[1] = None
   81:     result = frame.resample("1h").asfreq(fill_value=4.0)
   82:     new_index = create_index(frame.index[0], frame.index[-1], freq="1h")
   83:     expected = frame.reindex(new_index, fill_value=4.0)
   84:     tm.assert_frame_equal(result, expected)
   85: 
   86: 
   87: @all_ts
   88: def test_resample_interpolate(frame):
   89:     # GH#12925
   90:     df = frame
   91:     warn = None
   92:     if isinstance(df.index, PeriodIndex):
   93:         warn = FutureWarning
   94:     msg = "Resampling with a PeriodIndex is deprecated"
   95:     with tm.assert_produces_warning(warn, match=msg):
   96:         result = df.resample("1min").asfreq().interpolate()
   97:         expected = df.resample("1min").interpolate()
   98:     tm.assert_frame_equal(result, expected)
   99: 
  100: 
  101: def test_raises_on_non_datetimelike_index():
  102:     # this is a non datetimelike index
  103:     xp = DataFrame()
  104:     msg = (
  105:         "Only valid with DatetimeIndex, TimedeltaIndex or PeriodIndex, "
  106:         "but got an instance of 'RangeIndex'"
  107:     )
  108:     with pytest.raises(TypeError, match=msg):
  109:         xp.resample("YE")
  110: 
  111: 
  112: @all_ts
  113: @pytest.mark.parametrize("freq", ["ME", "D", "h"])
  114: def test_resample_empty_series(freq, empty_series_dti, resample_method):
  115:     # GH12771 & GH12868
  116: 
  117:     ser = empty_series_dti
  118:     if freq == "ME" and isinstance(ser.index, TimedeltaIndex):
  119:         msg = (
  120:             "Resampling on a TimedeltaIndex requires fixed-duration `freq`, "
  121:             "e.g. '24h' or '3D', not <MonthEnd>"
  122:         )
  123:         with pytest.raises(ValueError, match=msg):
  124:             ser.resample(freq)
  125:         return
  126:     elif freq == "ME" and isinstance(ser.index, PeriodIndex):
  127:         # index is PeriodIndex, so convert to corresponding Period freq
  128:         freq = "M"
  129: 
  130:     warn = None
  131:     if isinstance(ser.index, PeriodIndex):
  132:         warn = FutureWarning
  133:     msg = "Resampling with a PeriodIndex is deprecated"
  134:     with tm.assert_produces_warning(warn, match=msg):
  135:         rs = ser.resample(freq)
  136:     result = getattr(rs, resample_method)()
  137: 
  138:     if resample_method == "ohlc":
  139:         expected = DataFrame(
  140:             [], index=ser.index[:0].copy(), columns=["open", "high", "low", "close"]
  141:         )
  142:         expected.index = _asfreq_compat(ser.index, freq)
  143:         tm.assert_frame_equal(result, expected, check_dtype=False)
  144:     else:
  145:         expected = ser.copy()
  146:         expected.index = _asfreq_compat(ser.index, freq)
  147:         tm.assert_series_equal(result, expected, check_dtype=False)
  148: 
  149:     tm.assert_index_equal(result.index, expected.index)
  150:     assert result.index.freq == expected.index.freq
  151: 
  152: 
  153: @all_ts
  154: @pytest.mark.parametrize(
  155:     "freq",
  156:     [
  157:         pytest.param("ME", marks=pytest.mark.xfail(reason="Don't know why this fails")),
  158:         "D",
  159:         "h",
  160:     ],
  161: )
  162: def test_resample_nat_index_series(freq, series, resample_method):
  163:     # GH39227
  164: 
  165:     ser = series.copy()
  166:     ser.index = PeriodIndex([NaT] * len(ser), freq=freq)
  167: 
  168:     msg = "Resampling with a PeriodIndex is deprecated"
  169:     with tm.assert_produces_warning(FutureWarning, match=msg):
  170:         rs = ser.resample(freq)
  171:     result = getattr(rs, resample_method)()
  172: 
  173:     if resample_method == "ohlc":
  174:         expected = DataFrame(
  175:             [], index=ser.index[:0].copy(), columns=["open", "high", "low", "close"]
  176:         )
  177:         tm.assert_frame_equal(result, expected, check_dtype=False)
  178:     else:
  179:         expected = ser[:0].copy()
  180:         tm.assert_series_equal(result, expected, check_dtype=False)
  181:     tm.assert_index_equal(result.index, expected.index)
  182:     assert result.index.freq == expected.index.freq
  183: 
  184: 
  185: @all_ts
  186: @pytest.mark.parametrize("freq", ["ME", "D", "h"])
  187: @pytest.mark.parametrize("resample_method", ["count", "size"])
  188: def test_resample_count_empty_series(freq, empty_series_dti, resample_method):
  189:     # GH28427
  190:     ser = empty_series_dti
  191:     if freq == "ME" and isinstance(ser.index, TimedeltaIndex):
  192:         msg = (
  193:             "Resampling on a TimedeltaIndex requires fixed-duration `freq`, "
  194:             "e.g. '24h' or '3D', not <MonthEnd>"
  195:         )
  196:         with pytest.raises(ValueError, match=msg):
  197:             ser.resample(freq)
  198:         return
  199:     elif freq == "ME" and isinstance(ser.index, PeriodIndex):
  200:         # index is PeriodIndex, so convert to corresponding Period freq
  201:         freq = "M"
  202: 
  203:     warn = None
  204:     if isinstance(ser.index, PeriodIndex):
  205:         warn = FutureWarning
  206:     msg = "Resampling with a PeriodIndex is deprecated"
  207:     with tm.assert_produces_warning(warn, match=msg):
  208:         rs = ser.resample(freq)
  209: 
  210:     result = getattr(rs, resample_method)()
  211: 
  212:     index = _asfreq_compat(ser.index, freq)
  213: 
  214:     expected = Series([], dtype="int64", index=index, name=ser.name)
  215: 
  216:     tm.assert_series_equal(result, expected)
  217: 
  218: 
  219: @all_ts
  220: @pytest.mark.parametrize("freq", ["ME", "D", "h"])
  221: def test_resample_empty_dataframe(empty_frame_dti, freq, resample_method):
  222:     # GH13212
  223:     df = empty_frame_dti
  224:     # count retains dimensions too
  225:     if freq == "ME" and isinstance(df.index, TimedeltaIndex):
  226:         msg = (
  227:             "Resampling on a TimedeltaIndex requires fixed-duration `freq`, "
  228:             "e.g. '24h' or '3D', not <MonthEnd>"
  229:         )
  230:         with pytest.raises(ValueError, match=msg):
  231:             df.resample(freq, group_keys=False)
  232:         return
  233:     elif freq == "ME" and isinstance(df.index, PeriodIndex):
  234:         # index is PeriodIndex, so convert to corresponding Period freq
  235:         freq = "M"
  236: 
  237:     warn = None
  238:     if isinstance(df.index, PeriodIndex):
  239:         warn = FutureWarning
  240:     msg = "Resampling with a PeriodIndex is deprecated"
  241:     with tm.assert_produces_warning(warn, match=msg):
  242:         rs = df.resample(freq, group_keys=False)
  243:     result = getattr(rs, resample_method)()
  244:     if resample_method == "ohlc":
  245:         # TODO: no tests with len(df.columns) > 0
  246:         mi = MultiIndex.from_product([df.columns, ["open", "high", "low", "close"]])
  247:         expected = DataFrame(
  248:             [], index=df.index[:0].copy(), columns=mi, dtype=np.float64
  249:         )
  250:         expected.index = _asfreq_compat(df.index, freq)
  251: 
  252:     elif resample_method != "size":
  253:         expected = df.copy()
  254:     else:
  255:         # GH14962
  256:         expected = Series([], dtype=np.int64)
  257: 
  258:     expected.index = _asfreq_compat(df.index, freq)
  259: 
  260:     tm.assert_index_equal(result.index, expected.index)
  261:     assert result.index.freq == expected.index.freq
  262:     tm.assert_almost_equal(result, expected)
  263: 
  264:     # test size for GH13212 (currently stays as df)
  265: 
  266: 
  267: @all_ts
  268: @pytest.mark.parametrize("freq", ["ME", "D", "h"])
  269: def test_resample_count_empty_dataframe(freq, empty_frame_dti):
  270:     # GH28427
  271: 
  272:     empty_frame_dti["a"] = []
  273: 
  274:     if freq == "ME" and isinstance(empty_frame_dti.index, TimedeltaIndex):
  275:         msg = (
  276:             "Resampling on a TimedeltaIndex requires fixed-duration `freq`, "
  277:             "e.g. '24h' or '3D', not <MonthEnd>"
  278:         )
  279:         with pytest.raises(ValueError, match=msg):
  280:             empty_frame_dti.resample(freq)
  281:         return
  282:     elif freq == "ME" and isinstance(empty_frame_dti.index, PeriodIndex):
  283:         # index is PeriodIndex, so convert to corresponding Period freq
  284:         freq = "M"
  285: 
  286:     warn = None
  287:     if isinstance(empty_frame_dti.index, PeriodIndex):
  288:         warn = FutureWarning
  289:     msg = "Resampling with a PeriodIndex is deprecated"
  290:     with tm.assert_produces_warning(warn, match=msg):
  291:         rs = empty_frame_dti.resample(freq)
  292:     result = rs.count()
  293: 
  294:     index = _asfreq_compat(empty_frame_dti.index, freq)
  295: 
  296:     expected = DataFrame(dtype="int64", index=index, columns=Index(["a"], dtype=object))
  297: 
  298:     tm.assert_frame_equal(result, expected)
  299: 
  300: 
  301: @all_ts
  302: @pytest.mark.parametrize("freq", ["ME", "D", "h"])
  303: def test_resample_size_empty_dataframe(freq, empty_frame_dti):
  304:     # GH28427
  305: 
  306:     empty_frame_dti["a"] = []
  307: 
  308:     if freq == "ME" and isinstance(empty_frame_dti.index, TimedeltaIndex):
  309:         msg = (
  310:             "Resampling on a TimedeltaIndex requires fixed-duration `freq`, "
  311:             "e.g. '24h' or '3D', not <MonthEnd>"
  312:         )
  313:         with pytest.raises(ValueError, match=msg):
  314:             empty_frame_dti.resample(freq)
  315:         return
  316:     elif freq == "ME" and isinstance(empty_frame_dti.index, PeriodIndex):
  317:         # index is PeriodIndex, so convert to corresponding Period freq
  318:         freq = "M"
  319: 
  320:     msg = "Resampling with a PeriodIndex"
  321:     warn = None
  322:     if isinstance(empty_frame_dti.index, PeriodIndex):
  323:         warn = FutureWarning
  324:     with tm.assert_produces_warning(warn, match=msg):
  325:         rs = empty_frame_dti.resample(freq)
  326:     result = rs.size()
  327: 
  328:     index = _asfreq_compat(empty_frame_dti.index, freq)
  329: 
  330:     expected = Series([], dtype="int64", index=index)
  331: 
  332:     tm.assert_series_equal(result, expected)
  333: 
  334: 
  335: @pytest.mark.parametrize(
  336:     "index",
  337:     [
  338:         PeriodIndex([], freq="M", name="a"),
  339:         DatetimeIndex([], name="a"),
  340:         TimedeltaIndex([], name="a"),
  341:     ],
  342: )
  343: @pytest.mark.parametrize("dtype", [float, int, object, "datetime64[ns]"])
  344: @pytest.mark.filterwarnings(r"ignore:PeriodDtype\[B\] is deprecated:FutureWarning")
  345: def test_resample_empty_dtypes(index, dtype, resample_method):
  346:     # Empty series were sometimes causing a segfault (for the functions
  347:     # with Cython bounds-checking disabled) or an IndexError.  We just run
  348:     # them to ensure they no longer do.  (GH #10228)
  349:     warn = None
  350:     if isinstance(index, PeriodIndex):
  351:         # GH#53511
  352:         index = PeriodIndex([], freq="B", name=index.name)
  353:         warn = FutureWarning
  354:     msg = "Resampling with a PeriodIndex is deprecated"
  355: 
  356:     empty_series_dti = Series([], index, dtype)
  357:     with tm.assert_produces_warning(warn, match=msg):
  358:         rs = empty_series_dti.resample("d", group_keys=False)
  359:     try:
  360:         getattr(rs, resample_method)()
  361:     except DataError:
  362:         # Ignore these since some combinations are invalid
  363:         # (ex: doing mean with dtype of np.object_)
  364:         pass
  365: 
  366: 
  367: @all_ts
  368: @pytest.mark.parametrize("freq", ["ME", "D", "h"])
  369: def test_apply_to_empty_series(empty_series_dti, freq):
  370:     # GH 14313
  371:     ser = empty_series_dti
  372: 
  373:     if freq == "ME" and isinstance(empty_series_dti.index, TimedeltaIndex):
  374:         msg = (
  375:             "Resampling on a TimedeltaIndex requires fixed-duration `freq`, "
  376:             "e.g. '24h' or '3D', not <MonthEnd>"
  377:         )
  378:         with pytest.raises(ValueError, match=msg):
  379:             empty_series_dti.resample(freq)
  380:         return
  381:     elif freq == "ME" and isinstance(empty_series_dti.index, PeriodIndex):
  382:         # index is PeriodIndex, so convert to corresponding Period freq
  383:         freq = "M"
  384: 
  385:     msg = "Resampling with a PeriodIndex"
  386:     warn = None
  387:     if isinstance(empty_series_dti.index, PeriodIndex):
  388:         warn = FutureWarning
  389: 
  390:     with tm.assert_produces_warning(warn, match=msg):
  391:         rs = ser.resample(freq, group_keys=False)
  392: 
  393:     result = rs.apply(lambda x: 1)
  394:     with tm.assert_produces_warning(warn, match=msg):
  395:         expected = ser.resample(freq).apply("sum")
  396: 
  397:     tm.assert_series_equal(result, expected, check_dtype=False)
  398: 
  399: 
  400: @all_ts
  401: def test_resampler_is_iterable(series):
  402:     # GH 15314
  403:     freq = "h"
  404:     tg = Grouper(freq=freq, convention="start")
  405:     msg = "Resampling with a PeriodIndex"
  406:     warn = None
  407:     if isinstance(series.index, PeriodIndex):
  408:         warn = FutureWarning
  409: 
  410:     with tm.assert_produces_warning(warn, match=msg):
  411:         grouped = series.groupby(tg)
  412: 
  413:     with tm.assert_produces_warning(warn, match=msg):
  414:         resampled = series.resample(freq)
  415:     for (rk, rv), (gk, gv) in zip(resampled, grouped):
  416:         assert rk == gk
  417:         tm.assert_series_equal(rv, gv)
  418: 
  419: 
  420: @all_ts
  421: def test_resample_quantile(series):
  422:     # GH 15023
  423:     ser = series
  424:     q = 0.75
  425:     freq = "h"
  426: 
  427:     msg = "Resampling with a PeriodIndex"
  428:     warn = None
  429:     if isinstance(series.index, PeriodIndex):
  430:         warn = FutureWarning
  431:     with tm.assert_produces_warning(warn, match=msg):
  432:         result = ser.resample(freq).quantile(q)
  433:         expected = ser.resample(freq).agg(lambda x: x.quantile(q)).rename(ser.name)
  434:     tm.assert_series_equal(result, expected)
  435: 
  436: 
  437: @pytest.mark.parametrize("how", ["first", "last"])
  438: def test_first_last_skipna(any_real_nullable_dtype, skipna, how):
  439:     # GH#57019
  440:     if is_extension_array_dtype(any_real_nullable_dtype):
  441:         na_value = Series(dtype=any_real_nullable_dtype).dtype.na_value
  442:     else:
  443:         na_value = np.nan
  444:     df = DataFrame(
  445:         {
  446:             "a": [2, 1, 1, 2],
  447:             "b": [na_value, 3.0, na_value, 4.0],
  448:             "c": [na_value, 3.0, na_value, 4.0],
  449:         },
  450:         index=date_range("2020-01-01", periods=4, freq="D"),
  451:         dtype=any_real_nullable_dtype,
  452:     )
  453:     rs = df.resample("ME")
  454:     method = getattr(rs, how)
  455:     result = method(skipna=skipna)
  456: 
  457:     gb = df.groupby(df.shape[0] * [pd.to_datetime("2020-01-31")])
  458:     expected = getattr(gb, how)(skipna=skipna)
  459:     expected.index.freq = "ME"
  460:     tm.assert_frame_equal(result, expected)
