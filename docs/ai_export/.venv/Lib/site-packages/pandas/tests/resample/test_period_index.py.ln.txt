    1: from datetime import datetime
    2: import warnings
    3: 
    4: import dateutil
    5: import numpy as np
    6: import pytest
    7: import pytz
    8: 
    9: from pandas._libs.tslibs.ccalendar import (
   10:     DAYS,
   11:     MONTHS,
   12: )
   13: from pandas._libs.tslibs.period import IncompatibleFrequency
   14: from pandas.errors import InvalidIndexError
   15: 
   16: import pandas as pd
   17: from pandas import (
   18:     DataFrame,
   19:     Series,
   20:     Timestamp,
   21: )
   22: import pandas._testing as tm
   23: from pandas.core.indexes.datetimes import date_range
   24: from pandas.core.indexes.period import (
   25:     Period,
   26:     PeriodIndex,
   27:     period_range,
   28: )
   29: from pandas.core.resample import _get_period_range_edges
   30: 
   31: from pandas.tseries import offsets
   32: 
   33: pytestmark = pytest.mark.filterwarnings(
   34:     "ignore:Resampling with a PeriodIndex is deprecated:FutureWarning"
   35: )
   36: 
   37: 
   38: @pytest.fixture()
   39: def _index_factory():
   40:     return period_range
   41: 
   42: 
   43: @pytest.fixture
   44: def _series_name():
   45:     return "pi"
   46: 
   47: 
   48: @pytest.fixture
   49: def simple_period_range_series():
   50:     """
   51:     Series with period range index and random data for test purposes.
   52:     """
   53: 
   54:     def _simple_period_range_series(start, end, freq="D"):
   55:         with warnings.catch_warnings():
   56:             # suppress Period[B] deprecation warning
   57:             msg = "|".join(["Period with BDay freq", r"PeriodDtype\[B\] is deprecated"])
   58:             warnings.filterwarnings(
   59:                 "ignore",
   60:                 msg,
   61:                 category=FutureWarning,
   62:             )
   63:             rng = period_range(start, end, freq=freq)
   64:         return Series(np.random.default_rng(2).standard_normal(len(rng)), index=rng)
   65: 
   66:     return _simple_period_range_series
   67: 
   68: 
   69: class TestPeriodIndex:
   70:     @pytest.mark.parametrize("freq", ["2D", "1h", "2h"])
   71:     @pytest.mark.parametrize("kind", ["period", None, "timestamp"])
   72:     def test_asfreq(self, series_and_frame, freq, kind):
   73:         # GH 12884, 15944
   74:         # make sure .asfreq() returns PeriodIndex (except kind='timestamp')
   75: 
   76:         obj = series_and_frame
   77:         if kind == "timestamp":
   78:             expected = obj.to_timestamp().resample(freq).asfreq()
   79:         else:
   80:             start = obj.index[0].to_timestamp(how="start")
   81:             end = (obj.index[-1] + obj.index.freq).to_timestamp(how="start")
   82:             new_index = date_range(start=start, end=end, freq=freq, inclusive="left")
   83:             expected = obj.to_timestamp().reindex(new_index).to_period(freq)
   84:         msg = "The 'kind' keyword in (Series|DataFrame).resample is deprecated"
   85:         with tm.assert_produces_warning(FutureWarning, match=msg):
   86:             result = obj.resample(freq, kind=kind).asfreq()
   87:         tm.assert_almost_equal(result, expected)
   88: 
   89:     def test_asfreq_fill_value(self, series):
   90:         # test for fill value during resampling, issue 3715
   91: 
   92:         s = series
   93:         new_index = date_range(
   94:             s.index[0].to_timestamp(how="start"),
   95:             (s.index[-1]).to_timestamp(how="start"),
   96:             freq="1h",
   97:         )
   98:         expected = s.to_timestamp().reindex(new_index, fill_value=4.0)
   99:         msg = "The 'kind' keyword in Series.resample is deprecated"
  100:         with tm.assert_produces_warning(FutureWarning, match=msg):
  101:             result = s.resample("1h", kind="timestamp").asfreq(fill_value=4.0)
  102:         tm.assert_series_equal(result, expected)
  103: 
  104:         frame = s.to_frame("value")
  105:         new_index = date_range(
  106:             frame.index[0].to_timestamp(how="start"),
  107:             (frame.index[-1]).to_timestamp(how="start"),
  108:             freq="1h",
  109:         )
  110:         expected = frame.to_timestamp().reindex(new_index, fill_value=3.0)
  111:         msg = "The 'kind' keyword in DataFrame.resample is deprecated"
  112:         with tm.assert_produces_warning(FutureWarning, match=msg):
  113:             result = frame.resample("1h", kind="timestamp").asfreq(fill_value=3.0)
  114:         tm.assert_frame_equal(result, expected)
  115: 
  116:     @pytest.mark.parametrize("freq", ["h", "12h", "2D", "W"])
  117:     @pytest.mark.parametrize("kind", [None, "period", "timestamp"])
  118:     @pytest.mark.parametrize("kwargs", [{"on": "date"}, {"level": "d"}])
  119:     def test_selection(self, index, freq, kind, kwargs):
  120:         # This is a bug, these should be implemented
  121:         # GH 14008
  122:         rng = np.arange(len(index), dtype=np.int64)
  123:         df = DataFrame(
  124:             {"date": index, "a": rng},
  125:             index=pd.MultiIndex.from_arrays([rng, index], names=["v", "d"]),
  126:         )
  127:         msg = (
  128:             "Resampling from level= or on= selection with a PeriodIndex is "
  129:             r"not currently supported, use \.set_index\(\.\.\.\) to "
  130:             "explicitly set index"
  131:         )
  132:         depr_msg = "The 'kind' keyword in DataFrame.resample is deprecated"
  133:         with pytest.raises(NotImplementedError, match=msg):
  134:             with tm.assert_produces_warning(FutureWarning, match=depr_msg):
  135:                 df.resample(freq, kind=kind, **kwargs)
  136: 
  137:     @pytest.mark.parametrize("month", MONTHS)
  138:     @pytest.mark.parametrize("meth", ["ffill", "bfill"])
  139:     @pytest.mark.parametrize("conv", ["start", "end"])
  140:     @pytest.mark.parametrize(
  141:         ("offset", "period"), [("D", "D"), ("B", "B"), ("ME", "M"), ("QE", "Q")]
  142:     )
  143:     def test_annual_upsample_cases(
  144:         self, offset, period, conv, meth, month, simple_period_range_series
  145:     ):
  146:         ts = simple_period_range_series("1/1/1990", "12/31/1991", freq=f"Y-{month}")
  147:         warn = FutureWarning if period == "B" else None
  148:         msg = r"PeriodDtype\[B\] is deprecated"
  149:         if warn is None:
  150:             msg = "Resampling with a PeriodIndex is deprecated"
  151:             warn = FutureWarning
  152:         with tm.assert_produces_warning(warn, match=msg):
  153:             result = getattr(ts.resample(period, convention=conv), meth)()
  154:             expected = result.to_timestamp(period, how=conv)
  155:             expected = expected.asfreq(offset, meth).to_period()
  156:         tm.assert_series_equal(result, expected)
  157: 
  158:     def test_basic_downsample(self, simple_period_range_series):
  159:         ts = simple_period_range_series("1/1/1990", "6/30/1995", freq="M")
  160:         result = ts.resample("Y-DEC").mean()
  161: 
  162:         expected = ts.groupby(ts.index.year).mean()
  163:         expected.index = period_range("1/1/1990", "6/30/1995", freq="Y-DEC")
  164:         tm.assert_series_equal(result, expected)
  165: 
  166:         # this is ok
  167:         tm.assert_series_equal(ts.resample("Y-DEC").mean(), result)
  168:         tm.assert_series_equal(ts.resample("Y").mean(), result)
  169: 
  170:     @pytest.mark.parametrize(
  171:         "rule,expected_error_msg",
  172:         [
  173:             ("Y-DEC", "<YearEnd: month=12>"),
  174:             ("Q-MAR", "<QuarterEnd: startingMonth=3>"),
  175:             ("M", "<MonthEnd>"),
  176:             ("w-thu", "<Week: weekday=3>"),
  177:         ],
  178:     )
  179:     def test_not_subperiod(self, simple_period_range_series, rule, expected_error_msg):
  180:         # These are incompatible period rules for resampling
  181:         ts = simple_period_range_series("1/1/1990", "6/30/1995", freq="w-wed")
  182:         msg = (
  183:             "Frequency <Week: weekday=2> cannot be resampled to "
  184:             f"{expected_error_msg}, as they are not sub or super periods"
  185:         )
  186:         with pytest.raises(IncompatibleFrequency, match=msg):
  187:             ts.resample(rule).mean()
  188: 
  189:     @pytest.mark.parametrize("freq", ["D", "2D"])
  190:     def test_basic_upsample(self, freq, simple_period_range_series):
  191:         ts = simple_period_range_series("1/1/1990", "6/30/1995", freq="M")
  192:         result = ts.resample("Y-DEC").mean()
  193: 
  194:         msg = "The 'convention' keyword in Series.resample is deprecated"
  195:         with tm.assert_produces_warning(FutureWarning, match=msg):
  196:             resampled = result.resample(freq, convention="end").ffill()
  197:         expected = result.to_timestamp(freq, how="end")
  198:         expected = expected.asfreq(freq, "ffill").to_period(freq)
  199:         tm.assert_series_equal(resampled, expected)
  200: 
  201:     def test_upsample_with_limit(self):
  202:         rng = period_range("1/1/2000", periods=5, freq="Y")
  203:         ts = Series(np.random.default_rng(2).standard_normal(len(rng)), rng)
  204: 
  205:         msg = "The 'convention' keyword in Series.resample is deprecated"
  206:         with tm.assert_produces_warning(FutureWarning, match=msg):
  207:             result = ts.resample("M", convention="end").ffill(limit=2)
  208:         expected = ts.asfreq("M").reindex(result.index, method="ffill", limit=2)
  209:         tm.assert_series_equal(result, expected)
  210: 
  211:     def test_annual_upsample(self, simple_period_range_series):
  212:         ts = simple_period_range_series("1/1/1990", "12/31/1995", freq="Y-DEC")
  213:         df = DataFrame({"a": ts})
  214:         rdf = df.resample("D").ffill()
  215:         exp = df["a"].resample("D").ffill()
  216:         tm.assert_series_equal(rdf["a"], exp)
  217: 
  218:     def test_annual_upsample2(self):
  219:         rng = period_range("2000", "2003", freq="Y-DEC")
  220:         ts = Series([1, 2, 3, 4], index=rng)
  221: 
  222:         result = ts.resample("M").ffill()
  223:         ex_index = period_range("2000-01", "2003-12", freq="M")
  224: 
  225:         expected = ts.asfreq("M", how="start").reindex(ex_index, method="ffill")
  226:         tm.assert_series_equal(result, expected)
  227: 
  228:     @pytest.mark.parametrize("month", MONTHS)
  229:     @pytest.mark.parametrize("convention", ["start", "end"])
  230:     @pytest.mark.parametrize(
  231:         ("offset", "period"), [("D", "D"), ("B", "B"), ("ME", "M")]
  232:     )
  233:     def test_quarterly_upsample(
  234:         self, month, offset, period, convention, simple_period_range_series
  235:     ):
  236:         freq = f"Q-{month}"
  237:         ts = simple_period_range_series("1/1/1990", "12/31/1995", freq=freq)
  238:         warn = FutureWarning if period == "B" else None
  239:         msg = r"PeriodDtype\[B\] is deprecated"
  240:         if warn is None:
  241:             msg = "Resampling with a PeriodIndex is deprecated"
  242:             warn = FutureWarning
  243:         with tm.assert_produces_warning(warn, match=msg):
  244:             result = ts.resample(period, convention=convention).ffill()
  245:             expected = result.to_timestamp(period, how=convention)
  246:             expected = expected.asfreq(offset, "ffill").to_period()
  247:         tm.assert_series_equal(result, expected)
  248: 
  249:     @pytest.mark.parametrize("target", ["D", "B"])
  250:     @pytest.mark.parametrize("convention", ["start", "end"])
  251:     def test_monthly_upsample(self, target, convention, simple_period_range_series):
  252:         ts = simple_period_range_series("1/1/1990", "12/31/1995", freq="M")
  253: 
  254:         warn = None if target == "D" else FutureWarning
  255:         msg = r"PeriodDtype\[B\] is deprecated"
  256:         if warn is None:
  257:             msg = "Resampling with a PeriodIndex is deprecated"
  258:             warn = FutureWarning
  259:         with tm.assert_produces_warning(warn, match=msg):
  260:             result = ts.resample(target, convention=convention).ffill()
  261:             expected = result.to_timestamp(target, how=convention)
  262:             expected = expected.asfreq(target, "ffill").to_period()
  263:         tm.assert_series_equal(result, expected)
  264: 
  265:     def test_resample_basic(self):
  266:         # GH3609
  267:         s = Series(
  268:             range(100),
  269:             index=date_range("20130101", freq="s", periods=100, name="idx"),
  270:             dtype="float",
  271:         )
  272:         s[10:30] = np.nan
  273:         index = PeriodIndex(
  274:             [Period("2013-01-01 00:00", "min"), Period("2013-01-01 00:01", "min")],
  275:             name="idx",
  276:         )
  277:         expected = Series([34.5, 79.5], index=index)
  278:         msg = "The 'kind' keyword in Series.resample is deprecated"
  279:         with tm.assert_produces_warning(FutureWarning, match=msg):
  280:             result = s.to_period().resample("min", kind="period").mean()
  281:         tm.assert_series_equal(result, expected)
  282:         with tm.assert_produces_warning(FutureWarning, match=msg):
  283:             result2 = s.resample("min", kind="period").mean()
  284:         tm.assert_series_equal(result2, expected)
  285: 
  286:     @pytest.mark.parametrize(
  287:         "freq,expected_vals", [("M", [31, 29, 31, 9]), ("2M", [31 + 29, 31 + 9])]
  288:     )
  289:     def test_resample_count(self, freq, expected_vals):
  290:         # GH12774
  291:         series = Series(1, index=period_range(start="2000", periods=100))
  292:         result = series.resample(freq).count()
  293:         expected_index = period_range(
  294:             start="2000", freq=freq, periods=len(expected_vals)
  295:         )
  296:         expected = Series(expected_vals, index=expected_index)
  297:         tm.assert_series_equal(result, expected)
  298: 
  299:     def test_resample_same_freq(self, resample_method):
  300:         # GH12770
  301:         series = Series(range(3), index=period_range(start="2000", periods=3, freq="M"))
  302:         expected = series
  303: 
  304:         result = getattr(series.resample("M"), resample_method)()
  305:         tm.assert_series_equal(result, expected)
  306: 
  307:     def test_resample_incompat_freq(self):
  308:         msg = (
  309:             "Frequency <MonthEnd> cannot be resampled to <Week: weekday=6>, "
  310:             "as they are not sub or super periods"
  311:         )
  312:         pi = period_range(start="2000", periods=3, freq="M")
  313:         ser = Series(range(3), index=pi)
  314:         rs = ser.resample("W")
  315:         with pytest.raises(IncompatibleFrequency, match=msg):
  316:             # TODO: should this raise at the resample call instead of at the mean call?
  317:             rs.mean()
  318: 
  319:     @pytest.mark.parametrize(
  320:         "tz",
  321:         [
  322:             pytz.timezone("America/Los_Angeles"),
  323:             dateutil.tz.gettz("America/Los_Angeles"),
  324:         ],
  325:     )
  326:     def test_with_local_timezone(self, tz):
  327:         # see gh-5430
  328:         local_timezone = tz
  329: 
  330:         start = datetime(year=2013, month=11, day=1, hour=0, minute=0, tzinfo=pytz.utc)
  331:         # 1 day later
  332:         end = datetime(year=2013, month=11, day=2, hour=0, minute=0, tzinfo=pytz.utc)
  333: 
  334:         index = date_range(start, end, freq="h", name="idx")
  335: 
  336:         series = Series(1, index=index)
  337:         series = series.tz_convert(local_timezone)
  338:         msg = "The 'kind' keyword in Series.resample is deprecated"
  339:         with tm.assert_produces_warning(FutureWarning, match=msg):
  340:             result = series.resample("D", kind="period").mean()
  341: 
  342:         # Create the expected series
  343:         # Index is moved back a day with the timezone conversion from UTC to
  344:         # Pacific
  345:         expected_index = (
  346:             period_range(start=start, end=end, freq="D", name="idx") - offsets.Day()
  347:         )
  348:         expected = Series(1.0, index=expected_index)
  349:         tm.assert_series_equal(result, expected)
  350: 
  351:     @pytest.mark.parametrize(
  352:         "tz",
  353:         [
  354:             pytz.timezone("America/Los_Angeles"),
  355:             dateutil.tz.gettz("America/Los_Angeles"),
  356:         ],
  357:     )
  358:     def test_resample_with_tz(self, tz, unit):
  359:         # GH 13238
  360:         dti = date_range("2017-01-01", periods=48, freq="h", tz=tz, unit=unit)
  361:         ser = Series(2, index=dti)
  362:         result = ser.resample("D").mean()
  363:         exp_dti = pd.DatetimeIndex(
  364:             ["2017-01-01", "2017-01-02"], tz=tz, freq="D"
  365:         ).as_unit(unit)
  366:         expected = Series(
  367:             2.0,
  368:             index=exp_dti,
  369:         )
  370:         tm.assert_series_equal(result, expected)
  371:         # Especially assert that the timezone is LMT for pytz
  372:         assert result.index.tz == tz
  373: 
  374:     def test_resample_nonexistent_time_bin_edge(self):
  375:         # GH 19375
  376:         index = date_range("2017-03-12", "2017-03-12 1:45:00", freq="15min")
  377:         s = Series(np.zeros(len(index)), index=index)
  378:         expected = s.tz_localize("US/Pacific")
  379:         expected.index = pd.DatetimeIndex(expected.index, freq="900s")
  380:         result = expected.resample("900s").mean()
  381:         tm.assert_series_equal(result, expected)
  382: 
  383:     def test_resample_nonexistent_time_bin_edge2(self):
  384:         # GH 23742
  385:         index = date_range(start="2017-10-10", end="2017-10-20", freq="1h")
  386:         index = index.tz_localize("UTC").tz_convert("America/Sao_Paulo")
  387:         df = DataFrame(data=list(range(len(index))), index=index)
  388:         result = df.groupby(pd.Grouper(freq="1D")).count()
  389:         expected = date_range(
  390:             start="2017-10-09",
  391:             end="2017-10-20",
  392:             freq="D",
  393:             tz="America/Sao_Paulo",
  394:             nonexistent="shift_forward",
  395:             inclusive="left",
  396:         )
  397:         tm.assert_index_equal(result.index, expected)
  398: 
  399:     def test_resample_ambiguous_time_bin_edge(self):
  400:         # GH 10117
  401:         idx = date_range(
  402:             "2014-10-25 22:00:00",
  403:             "2014-10-26 00:30:00",
  404:             freq="30min",
  405:             tz="Europe/London",
  406:         )
  407:         expected = Series(np.zeros(len(idx)), index=idx)
  408:         result = expected.resample("30min").mean()
  409:         tm.assert_series_equal(result, expected)
  410: 
  411:     def test_fill_method_and_how_upsample(self):
  412:         # GH2073
  413:         s = Series(
  414:             np.arange(9, dtype="int64"),
  415:             index=date_range("2010-01-01", periods=9, freq="QE"),
  416:         )
  417:         last = s.resample("ME").ffill()
  418:         both = s.resample("ME").ffill().resample("ME").last().astype("int64")
  419:         tm.assert_series_equal(last, both)
  420: 
  421:     @pytest.mark.parametrize("day", DAYS)
  422:     @pytest.mark.parametrize("target", ["D", "B"])
  423:     @pytest.mark.parametrize("convention", ["start", "end"])
  424:     def test_weekly_upsample(self, day, target, convention, simple_period_range_series):
  425:         freq = f"W-{day}"
  426:         ts = simple_period_range_series("1/1/1990", "12/31/1995", freq=freq)
  427: 
  428:         warn = None if target == "D" else FutureWarning
  429:         msg = r"PeriodDtype\[B\] is deprecated"
  430:         if warn is None:
  431:             msg = "Resampling with a PeriodIndex is deprecated"
  432:             warn = FutureWarning
  433:         with tm.assert_produces_warning(warn, match=msg):
  434:             result = ts.resample(target, convention=convention).ffill()
  435:             expected = result.to_timestamp(target, how=convention)
  436:             expected = expected.asfreq(target, "ffill").to_period()
  437:         tm.assert_series_equal(result, expected)
  438: 
  439:     def test_resample_to_timestamps(self, simple_period_range_series):
  440:         ts = simple_period_range_series("1/1/1990", "12/31/1995", freq="M")
  441: 
  442:         msg = "The 'kind' keyword in Series.resample is deprecated"
  443:         with tm.assert_produces_warning(FutureWarning, match=msg):
  444:             result = ts.resample("Y-DEC", kind="timestamp").mean()
  445:         expected = ts.to_timestamp(how="start").resample("YE-DEC").mean()
  446:         tm.assert_series_equal(result, expected)
  447: 
  448:     @pytest.mark.parametrize("month", MONTHS)
  449:     def test_resample_to_quarterly(self, simple_period_range_series, month):
  450:         ts = simple_period_range_series("1990", "1992", freq=f"Y-{month}")
  451:         quar_ts = ts.resample(f"Q-{month}").ffill()
  452: 
  453:         stamps = ts.to_timestamp("D", how="start")
  454:         qdates = period_range(
  455:             ts.index[0].asfreq("D", "start"),
  456:             ts.index[-1].asfreq("D", "end"),
  457:             freq=f"Q-{month}",
  458:         )
  459: 
  460:         expected = stamps.reindex(qdates.to_timestamp("D", "s"), method="ffill")
  461:         expected.index = qdates
  462: 
  463:         tm.assert_series_equal(quar_ts, expected)
  464: 
  465:     @pytest.mark.parametrize("how", ["start", "end"])
  466:     def test_resample_to_quarterly_start_end(self, simple_period_range_series, how):
  467:         # conforms, but different month
  468:         ts = simple_period_range_series("1990", "1992", freq="Y-JUN")
  469:         msg = "The 'convention' keyword in Series.resample is deprecated"
  470:         with tm.assert_produces_warning(FutureWarning, match=msg):
  471:             result = ts.resample("Q-MAR", convention=how).ffill()
  472:         expected = ts.asfreq("Q-MAR", how=how)
  473:         expected = expected.reindex(result.index, method="ffill")
  474: 
  475:         # FIXME: don't leave commented-out
  476:         # .to_timestamp('D')
  477:         # expected = expected.resample('Q-MAR').ffill()
  478: 
  479:         tm.assert_series_equal(result, expected)
  480: 
  481:     def test_resample_fill_missing(self):
  482:         rng = PeriodIndex([2000, 2005, 2007, 2009], freq="Y")
  483: 
  484:         s = Series(np.random.default_rng(2).standard_normal(4), index=rng)
  485: 
  486:         stamps = s.to_timestamp()
  487:         filled = s.resample("Y").ffill()
  488:         expected = stamps.resample("YE").ffill().to_period("Y")
  489:         tm.assert_series_equal(filled, expected)
  490: 
  491:     def test_cant_fill_missing_dups(self):
  492:         rng = PeriodIndex([2000, 2005, 2005, 2007, 2007], freq="Y")
  493:         s = Series(np.random.default_rng(2).standard_normal(5), index=rng)
  494:         msg = "Reindexing only valid with uniquely valued Index objects"
  495:         with pytest.raises(InvalidIndexError, match=msg):
  496:             s.resample("Y").ffill()
  497: 
  498:     @pytest.mark.parametrize("freq", ["5min"])
  499:     @pytest.mark.parametrize("kind", ["period", None, "timestamp"])
  500:     def test_resample_5minute(self, freq, kind):
  501:         rng = period_range("1/1/2000", "1/5/2000", freq="min")
  502:         ts = Series(np.random.default_rng(2).standard_normal(len(rng)), index=rng)
  503:         expected = ts.to_timestamp().resample(freq).mean()
  504:         if kind != "timestamp":
  505:             expected = expected.to_period(freq)
  506:         msg = "The 'kind' keyword in Series.resample is deprecated"
  507:         with tm.assert_produces_warning(FutureWarning, match=msg):
  508:             result = ts.resample(freq, kind=kind).mean()
  509:         tm.assert_series_equal(result, expected)
  510: 
  511:     def test_upsample_daily_business_daily(self, simple_period_range_series):
  512:         ts = simple_period_range_series("1/1/2000", "2/1/2000", freq="B")
  513: 
  514:         result = ts.resample("D").asfreq()
  515:         expected = ts.asfreq("D").reindex(period_range("1/3/2000", "2/1/2000"))
  516:         tm.assert_series_equal(result, expected)
  517: 
  518:         ts = simple_period_range_series("1/1/2000", "2/1/2000")
  519:         msg = "The 'convention' keyword in Series.resample is deprecated"
  520:         with tm.assert_produces_warning(FutureWarning, match=msg):
  521:             result = ts.resample("h", convention="s").asfreq()
  522:         exp_rng = period_range("1/1/2000", "2/1/2000 23:00", freq="h")
  523:         expected = ts.asfreq("h", how="s").reindex(exp_rng)
  524:         tm.assert_series_equal(result, expected)
  525: 
  526:     def test_resample_irregular_sparse(self):
  527:         dr = date_range(start="1/1/2012", freq="5min", periods=1000)
  528:         s = Series(np.array(100), index=dr)
  529:         # subset the data.
  530:         subset = s[:"2012-01-04 06:55"]
  531: 
  532:         result = subset.resample("10min").apply(len)
  533:         expected = s.resample("10min").apply(len).loc[result.index]
  534:         tm.assert_series_equal(result, expected)
  535: 
  536:     def test_resample_weekly_all_na(self):
  537:         rng = date_range("1/1/2000", periods=10, freq="W-WED")
  538:         ts = Series(np.random.default_rng(2).standard_normal(len(rng)), index=rng)
  539: 
  540:         result = ts.resample("W-THU").asfreq()
  541: 
  542:         assert result.isna().all()
  543: 
  544:         result = ts.resample("W-THU").asfreq().ffill()[:-1]
  545:         expected = ts.asfreq("W-THU").ffill()
  546:         tm.assert_series_equal(result, expected)
  547: 
  548:     def test_resample_tz_localized(self, unit):
  549:         dr = date_range(start="2012-4-13", end="2012-5-1", unit=unit)
  550:         ts = Series(range(len(dr)), index=dr)
  551: 
  552:         ts_utc = ts.tz_localize("UTC")
  553:         ts_local = ts_utc.tz_convert("America/Los_Angeles")
  554: 
  555:         result = ts_local.resample("W").mean()
  556: 
  557:         ts_local_naive = ts_local.copy()
  558:         ts_local_naive.index = ts_local_naive.index.tz_localize(None)
  559: 
  560:         exp = ts_local_naive.resample("W").mean().tz_localize("America/Los_Angeles")
  561:         exp.index = pd.DatetimeIndex(exp.index, freq="W")
  562: 
  563:         tm.assert_series_equal(result, exp)
  564: 
  565:         # it works
  566:         result = ts_local.resample("D").mean()
  567: 
  568:     def test_resample_tz_localized2(self):
  569:         # #2245
  570:         idx = date_range(
  571:             "2001-09-20 15:59", "2001-09-20 16:00", freq="min", tz="Australia/Sydney"
  572:         )
  573:         s = Series([1, 2], index=idx)
  574: 
  575:         result = s.resample("D", closed="right", label="right").mean()
  576:         ex_index = date_range("2001-09-21", periods=1, freq="D", tz="Australia/Sydney")
  577:         expected = Series([1.5], index=ex_index)
  578: 
  579:         tm.assert_series_equal(result, expected)
  580: 
  581:         # for good measure
  582:         msg = "The 'kind' keyword in Series.resample is deprecated"
  583:         with tm.assert_produces_warning(FutureWarning, match=msg):
  584:             result = s.resample("D", kind="period").mean()
  585:         ex_index = period_range("2001-09-20", periods=1, freq="D")
  586:         expected = Series([1.5], index=ex_index)
  587:         tm.assert_series_equal(result, expected)
  588: 
  589:     def test_resample_tz_localized3(self):
  590:         # GH 6397
  591:         # comparing an offset that doesn't propagate tz's
  592:         rng = date_range("1/1/2011", periods=20000, freq="h")
  593:         rng = rng.tz_localize("EST")
  594:         ts = DataFrame(index=rng)
  595:         ts["first"] = np.random.default_rng(2).standard_normal(len(rng))
  596:         ts["second"] = np.cumsum(np.random.default_rng(2).standard_normal(len(rng)))
  597:         expected = DataFrame(
  598:             {
  599:                 "first": ts.resample("YE").sum()["first"],
  600:                 "second": ts.resample("YE").mean()["second"],
  601:             },
  602:             columns=["first", "second"],
  603:         )
  604:         result = (
  605:             ts.resample("YE")
  606:             .agg({"first": "sum", "second": "mean"})
  607:             .reindex(columns=["first", "second"])
  608:         )
  609:         tm.assert_frame_equal(result, expected)
  610: 
  611:     def test_closed_left_corner(self):
  612:         # #1465
  613:         s = Series(
  614:             np.random.default_rng(2).standard_normal(21),
  615:             index=date_range(start="1/1/2012 9:30", freq="1min", periods=21),
  616:         )
  617:         s.iloc[0] = np.nan
  618: 
  619:         result = s.resample("10min", closed="left", label="right").mean()
  620:         exp = s[1:].resample("10min", closed="left", label="right").mean()
  621:         tm.assert_series_equal(result, exp)
  622: 
  623:         result = s.resample("10min", closed="left", label="left").mean()
  624:         exp = s[1:].resample("10min", closed="left", label="left").mean()
  625: 
  626:         ex_index = date_range(start="1/1/2012 9:30", freq="10min", periods=3)
  627: 
  628:         tm.assert_index_equal(result.index, ex_index)
  629:         tm.assert_series_equal(result, exp)
  630: 
  631:     def test_quarterly_resampling(self):
  632:         rng = period_range("2000Q1", periods=10, freq="Q-DEC")
  633:         ts = Series(np.arange(10), index=rng)
  634: 
  635:         result = ts.resample("Y").mean()
  636:         exp = ts.to_timestamp().resample("YE").mean().to_period()
  637:         tm.assert_series_equal(result, exp)
  638: 
  639:     def test_resample_weekly_bug_1726(self):
  640:         # 8/6/12 is a Monday
  641:         ind = date_range(start="8/6/2012", end="8/26/2012", freq="D")
  642:         n = len(ind)
  643:         data = [[x] * 5 for x in range(n)]
  644:         df = DataFrame(data, columns=["open", "high", "low", "close", "vol"], index=ind)
  645: 
  646:         # it works!
  647:         df.resample("W-MON", closed="left", label="left").first()
  648: 
  649:     def test_resample_with_dst_time_change(self):
  650:         # GH 15549
  651:         index = (
  652:             pd.DatetimeIndex([1457537600000000000, 1458059600000000000])
  653:             .tz_localize("UTC")
  654:             .tz_convert("America/Chicago")
  655:         )
  656:         df = DataFrame([1, 2], index=index)
  657:         result = df.resample("12h", closed="right", label="right").last().ffill()
  658: 
  659:         expected_index_values = [
  660:             "2016-03-09 12:00:00-06:00",
  661:             "2016-03-10 00:00:00-06:00",
  662:             "2016-03-10 12:00:00-06:00",
  663:             "2016-03-11 00:00:00-06:00",
  664:             "2016-03-11 12:00:00-06:00",
  665:             "2016-03-12 00:00:00-06:00",
  666:             "2016-03-12 12:00:00-06:00",
  667:             "2016-03-13 00:00:00-06:00",
  668:             "2016-03-13 13:00:00-05:00",
  669:             "2016-03-14 01:00:00-05:00",
  670:             "2016-03-14 13:00:00-05:00",
  671:             "2016-03-15 01:00:00-05:00",
  672:             "2016-03-15 13:00:00-05:00",
  673:         ]
  674:         index = (
  675:             pd.to_datetime(expected_index_values, utc=True)
  676:             .tz_convert("America/Chicago")
  677:             .as_unit(index.unit)
  678:         )
  679:         index = pd.DatetimeIndex(index, freq="12h")
  680:         expected = DataFrame(
  681:             [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 2.0],
  682:             index=index,
  683:         )
  684:         tm.assert_frame_equal(result, expected)
  685: 
  686:     def test_resample_bms_2752(self):
  687:         # GH2753
  688:         timeseries = Series(
  689:             index=pd.bdate_range("20000101", "20000201"), dtype=np.float64
  690:         )
  691:         res1 = timeseries.resample("BMS").mean()
  692:         res2 = timeseries.resample("BMS").mean().resample("B").mean()
  693:         assert res1.index[0] == Timestamp("20000103")
  694:         assert res1.index[0] == res2.index[0]
  695: 
  696:     @pytest.mark.xfail(reason="Commented out for more than 3 years. Should this work?")
  697:     def test_monthly_convention_span(self):
  698:         rng = period_range("2000-01", periods=3, freq="ME")
  699:         ts = Series(np.arange(3), index=rng)
  700: 
  701:         # hacky way to get same thing
  702:         exp_index = period_range("2000-01-01", "2000-03-31", freq="D")
  703:         expected = ts.asfreq("D", how="end").reindex(exp_index)
  704:         expected = expected.fillna(method="bfill")
  705: 
  706:         result = ts.resample("D").mean()
  707: 
  708:         tm.assert_series_equal(result, expected)
  709: 
  710:     @pytest.mark.parametrize(
  711:         "from_freq, to_freq", [("D", "ME"), ("QE", "YE"), ("ME", "QE"), ("D", "W")]
  712:     )
  713:     def test_default_right_closed_label(self, from_freq, to_freq):
  714:         idx = date_range(start="8/15/2012", periods=100, freq=from_freq)
  715:         df = DataFrame(np.random.default_rng(2).standard_normal((len(idx), 2)), idx)
  716: 
  717:         resampled = df.resample(to_freq).mean()
  718:         tm.assert_frame_equal(
  719:             resampled, df.resample(to_freq, closed="right", label="right").mean()
  720:         )
  721: 
  722:     @pytest.mark.parametrize(
  723:         "from_freq, to_freq",
  724:         [("D", "MS"), ("QE", "YS"), ("ME", "QS"), ("h", "D"), ("min", "h")],
  725:     )
  726:     def test_default_left_closed_label(self, from_freq, to_freq):
  727:         idx = date_range(start="8/15/2012", periods=100, freq=from_freq)
  728:         df = DataFrame(np.random.default_rng(2).standard_normal((len(idx), 2)), idx)
  729: 
  730:         resampled = df.resample(to_freq).mean()
  731:         tm.assert_frame_equal(
  732:             resampled, df.resample(to_freq, closed="left", label="left").mean()
  733:         )
  734: 
  735:     def test_all_values_single_bin(self):
  736:         # GH#2070
  737:         index = period_range(start="2012-01-01", end="2012-12-31", freq="M")
  738:         ser = Series(np.random.default_rng(2).standard_normal(len(index)), index=index)
  739: 
  740:         result = ser.resample("Y").mean()
  741:         tm.assert_almost_equal(result.iloc[0], ser.mean())
  742: 
  743:     def test_evenly_divisible_with_no_extra_bins(self):
  744:         # GH#4076
  745:         # when the frequency is evenly divisible, sometimes extra bins
  746: 
  747:         df = DataFrame(
  748:             np.random.default_rng(2).standard_normal((9, 3)),
  749:             index=date_range("2000-1-1", periods=9),
  750:         )
  751:         result = df.resample("5D").mean()
  752:         expected = pd.concat([df.iloc[0:5].mean(), df.iloc[5:].mean()], axis=1).T
  753:         expected.index = pd.DatetimeIndex(
  754:             [Timestamp("2000-1-1"), Timestamp("2000-1-6")], dtype="M8[ns]", freq="5D"
  755:         )
  756:         tm.assert_frame_equal(result, expected)
  757: 
  758:     def test_evenly_divisible_with_no_extra_bins2(self):
  759:         index = date_range(start="2001-5-4", periods=28)
  760:         df = DataFrame(
  761:             [
  762:                 {
  763:                     "REST_KEY": 1,
  764:                     "DLY_TRN_QT": 80,
  765:                     "DLY_SLS_AMT": 90,
  766:                     "COOP_DLY_TRN_QT": 30,
  767:                     "COOP_DLY_SLS_AMT": 20,
  768:                 }
  769:             ]
  770:             * 28
  771:             + [
  772:                 {
  773:                     "REST_KEY": 2,
  774:                     "DLY_TRN_QT": 70,
  775:                     "DLY_SLS_AMT": 10,
  776:                     "COOP_DLY_TRN_QT": 50,
  777:                     "COOP_DLY_SLS_AMT": 20,
  778:                 }
  779:             ]
  780:             * 28,
  781:             index=index.append(index),
  782:         ).sort_index()
  783: 
  784:         index = date_range("2001-5-4", periods=4, freq="7D")
  785:         expected = DataFrame(
  786:             [
  787:                 {
  788:                     "REST_KEY": 14,
  789:                     "DLY_TRN_QT": 14,
  790:                     "DLY_SLS_AMT": 14,
  791:                     "COOP_DLY_TRN_QT": 14,
  792:                     "COOP_DLY_SLS_AMT": 14,
  793:                 }
  794:             ]
  795:             * 4,
  796:             index=index,
  797:         )
  798:         result = df.resample("7D").count()
  799:         tm.assert_frame_equal(result, expected)
  800: 
  801:         expected = DataFrame(
  802:             [
  803:                 {
  804:                     "REST_KEY": 21,
  805:                     "DLY_TRN_QT": 1050,
  806:                     "DLY_SLS_AMT": 700,
  807:                     "COOP_DLY_TRN_QT": 560,
  808:                     "COOP_DLY_SLS_AMT": 280,
  809:                 }
  810:             ]
  811:             * 4,
  812:             index=index,
  813:         )
  814:         result = df.resample("7D").sum()
  815:         tm.assert_frame_equal(result, expected)
  816: 
  817:     @pytest.mark.parametrize("freq, period_mult", [("h", 24), ("12h", 2)])
  818:     @pytest.mark.parametrize("kind", [None, "period"])
  819:     def test_upsampling_ohlc(self, freq, period_mult, kind):
  820:         # GH 13083
  821:         pi = period_range(start="2000", freq="D", periods=10)
  822:         s = Series(range(len(pi)), index=pi)
  823:         expected = s.to_timestamp().resample(freq).ohlc().to_period(freq)
  824: 
  825:         # timestamp-based resampling doesn't include all sub-periods
  826:         # of the last original period, so extend accordingly:
  827:         new_index = period_range(start="2000", freq=freq, periods=period_mult * len(pi))
  828:         expected = expected.reindex(new_index)
  829:         msg = "The 'kind' keyword in Series.resample is deprecated"
  830:         with tm.assert_produces_warning(FutureWarning, match=msg):
  831:             result = s.resample(freq, kind=kind).ohlc()
  832:         tm.assert_frame_equal(result, expected)
  833: 
  834:     @pytest.mark.parametrize(
  835:         "periods, values",
  836:         [
  837:             (
  838:                 [
  839:                     pd.NaT,
  840:                     "1970-01-01 00:00:00",
  841:                     pd.NaT,
  842:                     "1970-01-01 00:00:02",
  843:                     "1970-01-01 00:00:03",
  844:                 ],
  845:                 [2, 3, 5, 7, 11],
  846:             ),
  847:             (
  848:                 [
  849:                     pd.NaT,
  850:                     pd.NaT,
  851:                     "1970-01-01 00:00:00",
  852:                     pd.NaT,
  853:                     pd.NaT,
  854:                     pd.NaT,
  855:                     "1970-01-01 00:00:02",
  856:                     "1970-01-01 00:00:03",
  857:                     pd.NaT,
  858:                     pd.NaT,
  859:                 ],
  860:                 [1, 2, 3, 5, 6, 8, 7, 11, 12, 13],
  861:             ),
  862:         ],
  863:     )
  864:     @pytest.mark.parametrize(
  865:         "freq, expected_values",
  866:         [
  867:             ("1s", [3, np.nan, 7, 11]),
  868:             ("2s", [3, (7 + 11) / 2]),
  869:             ("3s", [(3 + 7) / 2, 11]),
  870:         ],
  871:     )
  872:     def test_resample_with_nat(self, periods, values, freq, expected_values):
  873:         # GH 13224
  874:         index = PeriodIndex(periods, freq="s")
  875:         frame = DataFrame(values, index=index)
  876: 
  877:         expected_index = period_range(
  878:             "1970-01-01 00:00:00", periods=len(expected_values), freq=freq
  879:         )
  880:         expected = DataFrame(expected_values, index=expected_index)
  881:         msg = "Resampling with a PeriodIndex is deprecated"
  882:         with tm.assert_produces_warning(FutureWarning, match=msg):
  883:             rs = frame.resample(freq)
  884:         result = rs.mean()
  885:         tm.assert_frame_equal(result, expected)
  886: 
  887:     def test_resample_with_only_nat(self):
  888:         # GH 13224
  889:         pi = PeriodIndex([pd.NaT] * 3, freq="s")
  890:         frame = DataFrame([2, 3, 5], index=pi, columns=["a"])
  891:         expected_index = PeriodIndex(data=[], freq=pi.freq)
  892:         expected = DataFrame(index=expected_index, columns=["a"], dtype="float64")
  893:         result = frame.resample("1s").mean()
  894:         tm.assert_frame_equal(result, expected)
  895: 
  896:     @pytest.mark.parametrize(
  897:         "start,end,start_freq,end_freq,offset",
  898:         [
  899:             ("19910905", "19910909 03:00", "h", "24h", "10h"),
  900:             ("19910905", "19910909 12:00", "h", "24h", "10h"),
  901:             ("19910905", "19910909 23:00", "h", "24h", "10h"),
  902:             ("19910905 10:00", "19910909", "h", "24h", "10h"),
  903:             ("19910905 10:00", "19910909 10:00", "h", "24h", "10h"),
  904:             ("19910905", "19910909 10:00", "h", "24h", "10h"),
  905:             ("19910905 12:00", "19910909", "h", "24h", "10h"),
  906:             ("19910905 12:00", "19910909 03:00", "h", "24h", "10h"),
  907:             ("19910905 12:00", "19910909 12:00", "h", "24h", "10h"),
  908:             ("19910905 12:00", "19910909 12:00", "h", "24h", "34h"),
  909:             ("19910905 12:00", "19910909 12:00", "h", "17h", "10h"),
  910:             ("19910905 12:00", "19910909 12:00", "h", "17h", "3h"),
  911:             ("19910905", "19910913 06:00", "2h", "24h", "10h"),
  912:             ("19910905", "19910905 01:39", "Min", "5Min", "3Min"),
  913:             ("19910905", "19910905 03:18", "2Min", "5Min", "3Min"),
  914:         ],
  915:     )
  916:     def test_resample_with_offset(self, start, end, start_freq, end_freq, offset):
  917:         # GH 23882 & 31809
  918:         pi = period_range(start, end, freq=start_freq)
  919:         ser = Series(np.arange(len(pi)), index=pi)
  920:         msg = "Resampling with a PeriodIndex is deprecated"
  921:         with tm.assert_produces_warning(FutureWarning, match=msg):
  922:             rs = ser.resample(end_freq, offset=offset)
  923:         result = rs.mean()
  924:         result = result.to_timestamp(end_freq)
  925: 
  926:         expected = ser.to_timestamp().resample(end_freq, offset=offset).mean()
  927:         tm.assert_series_equal(result, expected)
  928: 
  929:     def test_resample_with_offset_month(self):
  930:         # GH 23882 & 31809
  931:         pi = period_range("19910905 12:00", "19910909 1:00", freq="h")
  932:         ser = Series(np.arange(len(pi)), index=pi)
  933:         msg = "Resampling with a PeriodIndex is deprecated"
  934:         with tm.assert_produces_warning(FutureWarning, match=msg):
  935:             rs = ser.resample("M", offset="3h")
  936:         result = rs.mean()
  937:         result = result.to_timestamp("M")
  938:         expected = ser.to_timestamp().resample("ME", offset="3h").mean()
  939:         # TODO: is non-tick the relevant characteristic? (GH 33815)
  940:         expected.index = expected.index._with_freq(None)
  941:         tm.assert_series_equal(result, expected)
  942: 
  943:     @pytest.mark.parametrize(
  944:         "first,last,freq,freq_to_offset,exp_first,exp_last",
  945:         [
  946:             ("19910905", "19920406", "D", "D", "19910905", "19920406"),
  947:             ("19910905 00:00", "19920406 06:00", "D", "D", "19910905", "19920406"),
  948:             (
  949:                 "19910905 06:00",
  950:                 "19920406 06:00",
  951:                 "h",
  952:                 "h",
  953:                 "19910905 06:00",
  954:                 "19920406 06:00",
  955:             ),
  956:             ("19910906", "19920406", "M", "ME", "1991-09", "1992-04"),
  957:             ("19910831", "19920430", "M", "ME", "1991-08", "1992-04"),
  958:             ("1991-08", "1992-04", "M", "ME", "1991-08", "1992-04"),
  959:         ],
  960:     )
  961:     def test_get_period_range_edges(
  962:         self, first, last, freq, freq_to_offset, exp_first, exp_last
  963:     ):
  964:         first = Period(first)
  965:         last = Period(last)
  966: 
  967:         exp_first = Period(exp_first, freq=freq)
  968:         exp_last = Period(exp_last, freq=freq)
  969: 
  970:         freq = pd.tseries.frequencies.to_offset(freq_to_offset)
  971:         result = _get_period_range_edges(first, last, freq)
  972:         expected = (exp_first, exp_last)
  973:         assert result == expected
  974: 
  975:     def test_sum_min_count(self):
  976:         # GH 19974
  977:         index = date_range(start="2018", freq="ME", periods=6)
  978:         data = np.ones(6)
  979:         data[3:6] = np.nan
  980:         s = Series(data, index).to_period()
  981:         msg = "Resampling with a PeriodIndex is deprecated"
  982:         with tm.assert_produces_warning(FutureWarning, match=msg):
  983:             rs = s.resample("Q")
  984:         result = rs.sum(min_count=1)
  985:         expected = Series(
  986:             [3.0, np.nan], index=PeriodIndex(["2018Q1", "2018Q2"], freq="Q-DEC")
  987:         )
  988:         tm.assert_series_equal(result, expected)
  989: 
  990:     def test_resample_t_l_deprecated(self):
  991:         # GH#52536
  992:         msg_t = "'T' is deprecated and will be removed in a future version."
  993:         msg_l = "'L' is deprecated and will be removed in a future version."
  994: 
  995:         with tm.assert_produces_warning(FutureWarning, match=msg_l):
  996:             rng_l = period_range(
  997:                 "2020-01-01 00:00:00 00:00", "2020-01-01 00:00:00 00:01", freq="L"
  998:             )
  999:         ser = Series(np.arange(len(rng_l)), index=rng_l)
 1000: 
 1001:         rng = period_range(
 1002:             "2020-01-01 00:00:00 00:00", "2020-01-01 00:00:00 00:01", freq="min"
 1003:         )
 1004:         expected = Series([29999.5, 60000.0], index=rng)
 1005:         with tm.assert_produces_warning(FutureWarning, match=msg_t):
 1006:             result = ser.resample("T").mean()
 1007:         tm.assert_series_equal(result, expected)
 1008: 
 1009:     @pytest.mark.parametrize(
 1010:         "freq, freq_depr, freq_res, freq_depr_res, data",
 1011:         [
 1012:             ("2Q", "2q", "2Y", "2y", [0.5]),
 1013:             ("2M", "2m", "2Q", "2q", [1.0, 3.0]),
 1014:         ],
 1015:     )
 1016:     def test_resample_lowercase_frequency_deprecated(
 1017:         self, freq, freq_depr, freq_res, freq_depr_res, data
 1018:     ):
 1019:         depr_msg = f"'{freq_depr[1:]}' is deprecated and will be removed in a "
 1020:         f"future version. Please use '{freq[1:]}' instead."
 1021:         depr_msg_res = f"'{freq_depr_res[1:]}' is deprecated and will be removed in a "
 1022:         f"future version. Please use '{freq_res[1:]}' instead."
 1023: 
 1024:         with tm.assert_produces_warning(FutureWarning, match=depr_msg):
 1025:             rng_l = period_range("2020-01-01", "2020-08-01", freq=freq_depr)
 1026:         ser = Series(np.arange(len(rng_l)), index=rng_l)
 1027: 
 1028:         rng = period_range("2020-01-01", "2020-08-01", freq=freq_res)
 1029:         expected = Series(data=data, index=rng)
 1030: 
 1031:         with tm.assert_produces_warning(FutureWarning, match=depr_msg_res):
 1032:             result = ser.resample(freq_depr_res).mean()
 1033:         tm.assert_series_equal(result, expected)
 1034: 
 1035:     @pytest.mark.parametrize(
 1036:         "offset",
 1037:         [
 1038:             offsets.MonthBegin(),
 1039:             offsets.BYearBegin(2),
 1040:             offsets.BusinessHour(2),
 1041:         ],
 1042:     )
 1043:     def test_asfreq_invalid_period_offset(self, offset, series_and_frame):
 1044:         # GH#55785
 1045:         msg = f"Invalid offset: '{offset.base}' for converting time series "
 1046: 
 1047:         df = series_and_frame
 1048:         with pytest.raises(ValueError, match=msg):
 1049:             df.asfreq(freq=offset)
 1050: 
 1051: 
 1052: @pytest.mark.parametrize(
 1053:     "freq,freq_depr",
 1054:     [
 1055:         ("2M", "2ME"),
 1056:         ("2Q", "2QE"),
 1057:         ("2Q-FEB", "2QE-FEB"),
 1058:         ("2Y", "2YE"),
 1059:         ("2Y-MAR", "2YE-MAR"),
 1060:         ("2M", "2me"),
 1061:         ("2Q", "2qe"),
 1062:         ("2Y-MAR", "2ye-mar"),
 1063:     ],
 1064: )
 1065: def test_resample_frequency_ME_QE_YE_error_message(series_and_frame, freq, freq_depr):
 1066:     # GH#9586
 1067:     msg = f"for Period, please use '{freq[1:]}' instead of '{freq_depr[1:]}'"
 1068: 
 1069:     obj = series_and_frame
 1070:     with pytest.raises(ValueError, match=msg):
 1071:         obj.resample(freq_depr)
 1072: 
 1073: 
 1074: def test_corner_cases_period(simple_period_range_series):
 1075:     # miscellaneous test coverage
 1076:     len0pts = simple_period_range_series("2007-01", "2010-05", freq="M")[:0]
 1077:     # it works
 1078:     msg = "Resampling with a PeriodIndex is deprecated"
 1079:     with tm.assert_produces_warning(FutureWarning, match=msg):
 1080:         result = len0pts.resample("Y-DEC").mean()
 1081:     assert len(result) == 0
 1082: 
 1083: 
 1084: @pytest.mark.parametrize(
 1085:     "freq_depr",
 1086:     [
 1087:         "2BME",
 1088:         "2CBME",
 1089:         "2SME",
 1090:         "2BQE-FEB",
 1091:         "2BYE-MAR",
 1092:     ],
 1093: )
 1094: def test_resample_frequency_invalid_freq(series_and_frame, freq_depr):
 1095:     # GH#9586
 1096:     msg = f"Invalid frequency: {freq_depr[1:]}"
 1097: 
 1098:     obj = series_and_frame
 1099:     with pytest.raises(ValueError, match=msg):
 1100:         obj.resample(freq_depr)
