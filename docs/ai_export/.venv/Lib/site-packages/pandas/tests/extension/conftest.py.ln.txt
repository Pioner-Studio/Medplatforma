    1: import operator
    2: 
    3: import pytest
    4: 
    5: from pandas._config.config import _get_option
    6: 
    7: from pandas import (
    8:     Series,
    9:     options,
   10: )
   11: 
   12: 
   13: @pytest.fixture
   14: def dtype():
   15:     """A fixture providing the ExtensionDtype to validate."""
   16:     raise NotImplementedError
   17: 
   18: 
   19: @pytest.fixture
   20: def data():
   21:     """
   22:     Length-100 array for this type.
   23: 
   24:     * data[0] and data[1] should both be non missing
   25:     * data[0] and data[1] should not be equal
   26:     """
   27:     raise NotImplementedError
   28: 
   29: 
   30: @pytest.fixture
   31: def data_for_twos(dtype):
   32:     """
   33:     Length-100 array in which all the elements are two.
   34: 
   35:     Call pytest.skip in your fixture if the dtype does not support divmod.
   36:     """
   37:     if not (dtype._is_numeric or dtype.kind == "m"):
   38:         # Object-dtypes may want to allow this, but for the most part
   39:         #  only numeric and timedelta-like dtypes will need to implement this.
   40:         pytest.skip(f"{dtype} is not a numeric dtype")
   41: 
   42:     raise NotImplementedError
   43: 
   44: 
   45: @pytest.fixture
   46: def data_missing():
   47:     """Length-2 array with [NA, Valid]"""
   48:     raise NotImplementedError
   49: 
   50: 
   51: @pytest.fixture(params=["data", "data_missing"])
   52: def all_data(request, data, data_missing):
   53:     """Parametrized fixture giving 'data' and 'data_missing'"""
   54:     if request.param == "data":
   55:         return data
   56:     elif request.param == "data_missing":
   57:         return data_missing
   58: 
   59: 
   60: @pytest.fixture
   61: def data_repeated(data):
   62:     """
   63:     Generate many datasets.
   64: 
   65:     Parameters
   66:     ----------
   67:     data : fixture implementing `data`
   68: 
   69:     Returns
   70:     -------
   71:     Callable[[int], Generator]:
   72:         A callable that takes a `count` argument and
   73:         returns a generator yielding `count` datasets.
   74:     """
   75: 
   76:     def gen(count):
   77:         for _ in range(count):
   78:             yield data
   79: 
   80:     return gen
   81: 
   82: 
   83: @pytest.fixture
   84: def data_for_sorting():
   85:     """
   86:     Length-3 array with a known sort order.
   87: 
   88:     This should be three items [B, C, A] with
   89:     A < B < C
   90: 
   91:     For boolean dtypes (for which there are only 2 values available),
   92:     set B=C=True
   93:     """
   94:     raise NotImplementedError
   95: 
   96: 
   97: @pytest.fixture
   98: def data_missing_for_sorting():
   99:     """
  100:     Length-3 array with a known sort order.
  101: 
  102:     This should be three items [B, NA, A] with
  103:     A < B and NA missing.
  104:     """
  105:     raise NotImplementedError
  106: 
  107: 
  108: @pytest.fixture
  109: def na_cmp():
  110:     """
  111:     Binary operator for comparing NA values.
  112: 
  113:     Should return a function of two arguments that returns
  114:     True if both arguments are (scalar) NA for your type.
  115: 
  116:     By default, uses ``operator.is_``
  117:     """
  118:     return operator.is_
  119: 
  120: 
  121: @pytest.fixture
  122: def na_value(dtype):
  123:     """
  124:     The scalar missing value for this type. Default dtype.na_value.
  125: 
  126:     TODO: can be removed in 3.x (see https://github.com/pandas-dev/pandas/pull/54930)
  127:     """
  128:     return dtype.na_value
  129: 
  130: 
  131: @pytest.fixture
  132: def data_for_grouping():
  133:     """
  134:     Data for factorization, grouping, and unique tests.
  135: 
  136:     Expected to be like [B, B, NA, NA, A, A, B, C]
  137: 
  138:     Where A < B < C and NA is missing.
  139: 
  140:     If a dtype has _is_boolean = True, i.e. only 2 unique non-NA entries,
  141:     then set C=B.
  142:     """
  143:     raise NotImplementedError
  144: 
  145: 
  146: @pytest.fixture(params=[True, False])
  147: def box_in_series(request):
  148:     """Whether to box the data in a Series"""
  149:     return request.param
  150: 
  151: 
  152: @pytest.fixture(
  153:     params=[
  154:         lambda x: 1,
  155:         lambda x: [1] * len(x),
  156:         lambda x: Series([1] * len(x)),
  157:         lambda x: x,
  158:     ],
  159:     ids=["scalar", "list", "series", "object"],
  160: )
  161: def groupby_apply_op(request):
  162:     """
  163:     Functions to test groupby.apply().
  164:     """
  165:     return request.param
  166: 
  167: 
  168: @pytest.fixture(params=[True, False])
  169: def as_frame(request):
  170:     """
  171:     Boolean fixture to support Series and Series.to_frame() comparison testing.
  172:     """
  173:     return request.param
  174: 
  175: 
  176: @pytest.fixture(params=[True, False])
  177: def as_series(request):
  178:     """
  179:     Boolean fixture to support arr and Series(arr) comparison testing.
  180:     """
  181:     return request.param
  182: 
  183: 
  184: @pytest.fixture(params=[True, False])
  185: def use_numpy(request):
  186:     """
  187:     Boolean fixture to support comparison testing of ExtensionDtype array
  188:     and numpy array.
  189:     """
  190:     return request.param
  191: 
  192: 
  193: @pytest.fixture(params=["ffill", "bfill"])
  194: def fillna_method(request):
  195:     """
  196:     Parametrized fixture giving method parameters 'ffill' and 'bfill' for
  197:     Series.fillna(method=<method>) testing.
  198:     """
  199:     return request.param
  200: 
  201: 
  202: @pytest.fixture(params=[True, False])
  203: def as_array(request):
  204:     """
  205:     Boolean fixture to support ExtensionDtype _from_sequence method testing.
  206:     """
  207:     return request.param
  208: 
  209: 
  210: @pytest.fixture
  211: def invalid_scalar(data):
  212:     """
  213:     A scalar that *cannot* be held by this ExtensionArray.
  214: 
  215:     The default should work for most subclasses, but is not guaranteed.
  216: 
  217:     If the array can hold any item (i.e. object dtype), then use pytest.skip.
  218:     """
  219:     return object.__new__(object)
  220: 
  221: 
  222: @pytest.fixture
  223: def using_copy_on_write() -> bool:
  224:     """
  225:     Fixture to check if Copy-on-Write is enabled.
  226:     """
  227:     return (
  228:         options.mode.copy_on_write is True
  229:         and _get_option("mode.data_manager", silent=True) == "block"
  230:     )
