    1: from __future__ import annotations
    2: 
    3: import decimal
    4: import numbers
    5: import sys
    6: from typing import TYPE_CHECKING
    7: 
    8: import numpy as np
    9: 
   10: from pandas.core.dtypes.base import ExtensionDtype
   11: from pandas.core.dtypes.common import (
   12:     is_dtype_equal,
   13:     is_float,
   14:     is_integer,
   15:     pandas_dtype,
   16: )
   17: 
   18: import pandas as pd
   19: from pandas.api.extensions import (
   20:     no_default,
   21:     register_extension_dtype,
   22: )
   23: from pandas.api.types import (
   24:     is_list_like,
   25:     is_scalar,
   26: )
   27: from pandas.core import arraylike
   28: from pandas.core.algorithms import value_counts_internal as value_counts
   29: from pandas.core.arraylike import OpsMixin
   30: from pandas.core.arrays import (
   31:     ExtensionArray,
   32:     ExtensionScalarOpsMixin,
   33: )
   34: from pandas.core.indexers import check_array_indexer
   35: 
   36: if TYPE_CHECKING:
   37:     from pandas._typing import type_t
   38: 
   39: 
   40: @register_extension_dtype
   41: class DecimalDtype(ExtensionDtype):
   42:     type = decimal.Decimal
   43:     name = "decimal"
   44:     na_value = decimal.Decimal("NaN")
   45:     _metadata = ("context",)
   46: 
   47:     def __init__(self, context=None) -> None:
   48:         self.context = context or decimal.getcontext()
   49: 
   50:     def __repr__(self) -> str:
   51:         return f"DecimalDtype(context={self.context})"
   52: 
   53:     @classmethod
   54:     def construct_array_type(cls) -> type_t[DecimalArray]:
   55:         """
   56:         Return the array type associated with this dtype.
   57: 
   58:         Returns
   59:         -------
   60:         type
   61:         """
   62:         return DecimalArray
   63: 
   64:     @property
   65:     def _is_numeric(self) -> bool:
   66:         return True
   67: 
   68: 
   69: class DecimalArray(OpsMixin, ExtensionScalarOpsMixin, ExtensionArray):
   70:     __array_priority__ = 1000
   71: 
   72:     def __init__(self, values, dtype=None, copy=False, context=None) -> None:
   73:         for i, val in enumerate(values):
   74:             if is_float(val) or is_integer(val):
   75:                 if np.isnan(val):
   76:                     values[i] = DecimalDtype.na_value
   77:                 else:
   78:                     # error: Argument 1 has incompatible type "float | int |
   79:                     # integer[Any]"; expected "Decimal | float | str | tuple[int,
   80:                     # Sequence[int], int]"
   81:                     values[i] = DecimalDtype.type(val)  # type: ignore[arg-type]
   82:             elif not isinstance(val, decimal.Decimal):
   83:                 raise TypeError("All values must be of type " + str(decimal.Decimal))
   84:         values = np.asarray(values, dtype=object)
   85: 
   86:         self._data = values
   87:         # Some aliases for common attribute names to ensure pandas supports
   88:         # these
   89:         self._items = self.data = self._data
   90:         # those aliases are currently not working due to assumptions
   91:         # in internal code (GH-20735)
   92:         # self._values = self.values = self.data
   93:         self._dtype = DecimalDtype(context)
   94: 
   95:     @property
   96:     def dtype(self):
   97:         return self._dtype
   98: 
   99:     @classmethod
  100:     def _from_sequence(cls, scalars, *, dtype=None, copy=False):
  101:         return cls(scalars)
  102: 
  103:     @classmethod
  104:     def _from_sequence_of_strings(cls, strings, dtype=None, copy=False):
  105:         return cls._from_sequence(
  106:             [decimal.Decimal(x) for x in strings], dtype=dtype, copy=copy
  107:         )
  108: 
  109:     @classmethod
  110:     def _from_factorized(cls, values, original):
  111:         return cls(values)
  112: 
  113:     _HANDLED_TYPES = (decimal.Decimal, numbers.Number, np.ndarray)
  114: 
  115:     def to_numpy(
  116:         self,
  117:         dtype=None,
  118:         copy: bool = False,
  119:         na_value: object = no_default,
  120:         decimals=None,
  121:     ) -> np.ndarray:
  122:         result = np.asarray(self, dtype=dtype)
  123:         if decimals is not None:
  124:             result = np.asarray([round(x, decimals) for x in result])
  125:         return result
  126: 
  127:     def __array_ufunc__(self, ufunc: np.ufunc, method: str, *inputs, **kwargs):
  128:         #
  129:         if not all(
  130:             isinstance(t, self._HANDLED_TYPES + (DecimalArray,)) for t in inputs
  131:         ):
  132:             return NotImplemented
  133: 
  134:         result = arraylike.maybe_dispatch_ufunc_to_dunder_op(
  135:             self, ufunc, method, *inputs, **kwargs
  136:         )
  137:         if result is not NotImplemented:
  138:             # e.g. test_array_ufunc_series_scalar_other
  139:             return result
  140: 
  141:         if "out" in kwargs:
  142:             return arraylike.dispatch_ufunc_with_out(
  143:                 self, ufunc, method, *inputs, **kwargs
  144:             )
  145: 
  146:         inputs = tuple(x._data if isinstance(x, DecimalArray) else x for x in inputs)
  147:         result = getattr(ufunc, method)(*inputs, **kwargs)
  148: 
  149:         if method == "reduce":
  150:             result = arraylike.dispatch_reduction_ufunc(
  151:                 self, ufunc, method, *inputs, **kwargs
  152:             )
  153:             if result is not NotImplemented:
  154:                 return result
  155: 
  156:         def reconstruct(x):
  157:             if isinstance(x, (decimal.Decimal, numbers.Number)):
  158:                 return x
  159:             else:
  160:                 return type(self)._from_sequence(x, dtype=self.dtype)
  161: 
  162:         if ufunc.nout > 1:
  163:             return tuple(reconstruct(x) for x in result)
  164:         else:
  165:             return reconstruct(result)
  166: 
  167:     def __getitem__(self, item):
  168:         if isinstance(item, numbers.Integral):
  169:             return self._data[item]
  170:         else:
  171:             # array, slice.
  172:             item = pd.api.indexers.check_array_indexer(self, item)
  173:             return type(self)(self._data[item])
  174: 
  175:     def take(self, indexer, allow_fill=False, fill_value=None):
  176:         from pandas.api.extensions import take
  177: 
  178:         data = self._data
  179:         if allow_fill and fill_value is None:
  180:             fill_value = self.dtype.na_value
  181: 
  182:         result = take(data, indexer, fill_value=fill_value, allow_fill=allow_fill)
  183:         return self._from_sequence(result, dtype=self.dtype)
  184: 
  185:     def copy(self):
  186:         return type(self)(self._data.copy(), dtype=self.dtype)
  187: 
  188:     def astype(self, dtype, copy=True):
  189:         if is_dtype_equal(dtype, self._dtype):
  190:             if not copy:
  191:                 return self
  192:         dtype = pandas_dtype(dtype)
  193:         if isinstance(dtype, type(self.dtype)):
  194:             return type(self)(self._data, copy=copy, context=dtype.context)
  195: 
  196:         return super().astype(dtype, copy=copy)
  197: 
  198:     def __setitem__(self, key, value) -> None:
  199:         if is_list_like(value):
  200:             if is_scalar(key):
  201:                 raise ValueError("setting an array element with a sequence.")
  202:             value = [decimal.Decimal(v) for v in value]
  203:         else:
  204:             value = decimal.Decimal(value)
  205: 
  206:         key = check_array_indexer(self, key)
  207:         self._data[key] = value
  208: 
  209:     def __len__(self) -> int:
  210:         return len(self._data)
  211: 
  212:     def __contains__(self, item) -> bool | np.bool_:
  213:         if not isinstance(item, decimal.Decimal):
  214:             return False
  215:         elif item.is_nan():
  216:             return self.isna().any()
  217:         else:
  218:             return super().__contains__(item)
  219: 
  220:     @property
  221:     def nbytes(self) -> int:
  222:         n = len(self)
  223:         if n:
  224:             return n * sys.getsizeof(self[0])
  225:         return 0
  226: 
  227:     def isna(self):
  228:         return np.array([x.is_nan() for x in self._data], dtype=bool)
  229: 
  230:     @property
  231:     def _na_value(self):
  232:         return decimal.Decimal("NaN")
  233: 
  234:     def _formatter(self, boxed=False):
  235:         if boxed:
  236:             return "Decimal: {}".format
  237:         return repr
  238: 
  239:     @classmethod
  240:     def _concat_same_type(cls, to_concat):
  241:         return cls(np.concatenate([x._data for x in to_concat]))
  242: 
  243:     def _reduce(
  244:         self, name: str, *, skipna: bool = True, keepdims: bool = False, **kwargs
  245:     ):
  246:         if skipna and self.isna().any():
  247:             # If we don't have any NAs, we can ignore skipna
  248:             other = self[~self.isna()]
  249:             result = other._reduce(name, **kwargs)
  250:         elif name == "sum" and len(self) == 0:
  251:             # GH#29630 avoid returning int 0 or np.bool_(False) on old numpy
  252:             result = decimal.Decimal(0)
  253:         else:
  254:             try:
  255:                 op = getattr(self.data, name)
  256:             except AttributeError as err:
  257:                 raise NotImplementedError(
  258:                     f"decimal does not support the {name} operation"
  259:                 ) from err
  260:             result = op(axis=0)
  261: 
  262:         if keepdims:
  263:             return type(self)([result])
  264:         else:
  265:             return result
  266: 
  267:     def _cmp_method(self, other, op):
  268:         # For use with OpsMixin
  269:         def convert_values(param):
  270:             if isinstance(param, ExtensionArray) or is_list_like(param):
  271:                 ovalues = param
  272:             else:
  273:                 # Assume it's an object
  274:                 ovalues = [param] * len(self)
  275:             return ovalues
  276: 
  277:         lvalues = self
  278:         rvalues = convert_values(other)
  279: 
  280:         # If the operator is not defined for the underlying objects,
  281:         # a TypeError should be raised
  282:         res = [op(a, b) for (a, b) in zip(lvalues, rvalues)]
  283: 
  284:         return np.asarray(res, dtype=bool)
  285: 
  286:     def value_counts(self, dropna: bool = True):
  287:         return value_counts(self.to_numpy(), dropna=dropna)
  288: 
  289:     # We override fillna here to simulate a 3rd party EA that has done so. This
  290:     #  lets us test the deprecation telling authors to implement _pad_or_backfill
  291:     # Simulate a 3rd-party EA that has not yet updated to include a "copy"
  292:     #  keyword in its fillna method.
  293:     # error: Signature of "fillna" incompatible with supertype "ExtensionArray"
  294:     def fillna(  # type: ignore[override]
  295:         self,
  296:         value=None,
  297:         method=None,
  298:         limit: int | None = None,
  299:     ):
  300:         return super().fillna(value=value, method=method, limit=limit, copy=True)
  301: 
  302: 
  303: def to_decimal(values, context=None):
  304:     return DecimalArray([decimal.Decimal(x) for x in values], context=context)
  305: 
  306: 
  307: def make_data():
  308:     return [decimal.Decimal(val) for val in np.random.default_rng(2).random(100)]
  309: 
  310: 
  311: DecimalArray._add_arithmetic_ops()
