    1: """
    2: Test extension array for storing nested data in a pandas container.
    3: 
    4: The ListArray stores an ndarray of lists.
    5: """
    6: from __future__ import annotations
    7: 
    8: import numbers
    9: import string
   10: from typing import TYPE_CHECKING
   11: 
   12: import numpy as np
   13: 
   14: from pandas.core.dtypes.base import ExtensionDtype
   15: 
   16: import pandas as pd
   17: from pandas.api.types import (
   18:     is_object_dtype,
   19:     is_string_dtype,
   20: )
   21: from pandas.core.arrays import ExtensionArray
   22: 
   23: if TYPE_CHECKING:
   24:     from pandas._typing import type_t
   25: 
   26: 
   27: class ListDtype(ExtensionDtype):
   28:     type = list
   29:     name = "list"
   30:     na_value = np.nan
   31: 
   32:     @classmethod
   33:     def construct_array_type(cls) -> type_t[ListArray]:
   34:         """
   35:         Return the array type associated with this dtype.
   36: 
   37:         Returns
   38:         -------
   39:         type
   40:         """
   41:         return ListArray
   42: 
   43: 
   44: class ListArray(ExtensionArray):
   45:     dtype = ListDtype()
   46:     __array_priority__ = 1000
   47: 
   48:     def __init__(self, values, dtype=None, copy=False) -> None:
   49:         if not isinstance(values, np.ndarray):
   50:             raise TypeError("Need to pass a numpy array as values")
   51:         for val in values:
   52:             if not isinstance(val, self.dtype.type) and not pd.isna(val):
   53:                 raise TypeError("All values must be of type " + str(self.dtype.type))
   54:         self.data = values
   55: 
   56:     @classmethod
   57:     def _from_sequence(cls, scalars, *, dtype=None, copy=False):
   58:         data = np.empty(len(scalars), dtype=object)
   59:         data[:] = scalars
   60:         return cls(data)
   61: 
   62:     def __getitem__(self, item):
   63:         if isinstance(item, numbers.Integral):
   64:             return self.data[item]
   65:         else:
   66:             # slice, list-like, mask
   67:             return type(self)(self.data[item])
   68: 
   69:     def __len__(self) -> int:
   70:         return len(self.data)
   71: 
   72:     def isna(self):
   73:         return np.array(
   74:             [not isinstance(x, list) and np.isnan(x) for x in self.data], dtype=bool
   75:         )
   76: 
   77:     def take(self, indexer, allow_fill=False, fill_value=None):
   78:         # re-implement here, since NumPy has trouble setting
   79:         # sized objects like UserDicts into scalar slots of
   80:         # an ndarary.
   81:         indexer = np.asarray(indexer)
   82:         msg = (
   83:             "Index is out of bounds or cannot do a "
   84:             "non-empty take from an empty array."
   85:         )
   86: 
   87:         if allow_fill:
   88:             if fill_value is None:
   89:                 fill_value = self.dtype.na_value
   90:             # bounds check
   91:             if (indexer < -1).any():
   92:                 raise ValueError
   93:             try:
   94:                 output = [
   95:                     self.data[loc] if loc != -1 else fill_value for loc in indexer
   96:                 ]
   97:             except IndexError as err:
   98:                 raise IndexError(msg) from err
   99:         else:
  100:             try:
  101:                 output = [self.data[loc] for loc in indexer]
  102:             except IndexError as err:
  103:                 raise IndexError(msg) from err
  104: 
  105:         return self._from_sequence(output)
  106: 
  107:     def copy(self):
  108:         return type(self)(self.data[:])
  109: 
  110:     def astype(self, dtype, copy=True):
  111:         if isinstance(dtype, type(self.dtype)) and dtype == self.dtype:
  112:             if copy:
  113:                 return self.copy()
  114:             return self
  115:         elif is_string_dtype(dtype) and not is_object_dtype(dtype):
  116:             # numpy has problems with astype(str) for nested elements
  117:             return np.array([str(x) for x in self.data], dtype=dtype)
  118:         elif not copy:
  119:             return np.asarray(self.data, dtype=dtype)
  120:         else:
  121:             return np.array(self.data, dtype=dtype, copy=copy)
  122: 
  123:     @classmethod
  124:     def _concat_same_type(cls, to_concat):
  125:         data = np.concatenate([x.data for x in to_concat])
  126:         return cls(data)
  127: 
  128: 
  129: def make_data():
  130:     # TODO: Use a regular dict. See _NDFrameIndexer._setitem_with_indexer
  131:     rng = np.random.default_rng(2)
  132:     data = np.empty(100, dtype=object)
  133:     data[:] = [
  134:         [rng.choice(list(string.ascii_letters)) for _ in range(rng.integers(0, 10))]
  135:         for _ in range(100)
  136:     ]
  137:     return data
