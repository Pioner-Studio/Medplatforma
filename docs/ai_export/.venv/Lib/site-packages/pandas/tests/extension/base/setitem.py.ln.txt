    1: import numpy as np
    2: import pytest
    3: 
    4: import pandas as pd
    5: import pandas._testing as tm
    6: 
    7: 
    8: class BaseSetitemTests:
    9:     @pytest.fixture(
   10:         params=[
   11:             lambda x: x.index,
   12:             lambda x: list(x.index),
   13:             lambda x: slice(None),
   14:             lambda x: slice(0, len(x)),
   15:             lambda x: range(len(x)),
   16:             lambda x: list(range(len(x))),
   17:             lambda x: np.ones(len(x), dtype=bool),
   18:         ],
   19:         ids=[
   20:             "index",
   21:             "list[index]",
   22:             "null_slice",
   23:             "full_slice",
   24:             "range",
   25:             "list(range)",
   26:             "mask",
   27:         ],
   28:     )
   29:     def full_indexer(self, request):
   30:         """
   31:         Fixture for an indexer to pass to obj.loc to get/set the full length of the
   32:         object.
   33: 
   34:         In some cases, assumes that obj.index is the default RangeIndex.
   35:         """
   36:         return request.param
   37: 
   38:     @pytest.fixture(autouse=True)
   39:     def skip_if_immutable(self, dtype, request):
   40:         if dtype._is_immutable:
   41:             node = request.node
   42:             if node.name.split("[")[0] == "test_is_immutable":
   43:                 # This fixture is auto-used, but we want to not-skip
   44:                 # test_is_immutable.
   45:                 return
   46: 
   47:             # When BaseSetitemTests is mixed into ExtensionTests, we only
   48:             #  want this fixture to operate on the tests defined in this
   49:             #  class/file.
   50:             defined_in = node.function.__qualname__.split(".")[0]
   51:             if defined_in == "BaseSetitemTests":
   52:                 pytest.skip("__setitem__ test not applicable with immutable dtype")
   53: 
   54:     def test_is_immutable(self, data):
   55:         if data.dtype._is_immutable:
   56:             with pytest.raises(TypeError):
   57:                 data[0] = data[0]
   58:         else:
   59:             data[0] = data[1]
   60:             assert data[0] == data[1]
   61: 
   62:     def test_setitem_scalar_series(self, data, box_in_series):
   63:         if box_in_series:
   64:             data = pd.Series(data)
   65:         data[0] = data[1]
   66:         assert data[0] == data[1]
   67: 
   68:     def test_setitem_sequence(self, data, box_in_series):
   69:         if box_in_series:
   70:             data = pd.Series(data)
   71:         original = data.copy()
   72: 
   73:         data[[0, 1]] = [data[1], data[0]]
   74:         assert data[0] == original[1]
   75:         assert data[1] == original[0]
   76: 
   77:     def test_setitem_sequence_mismatched_length_raises(self, data, as_array):
   78:         ser = pd.Series(data)
   79:         original = ser.copy()
   80:         value = [data[0]]
   81:         if as_array:
   82:             value = data._from_sequence(value, dtype=data.dtype)
   83: 
   84:         xpr = "cannot set using a {} indexer with a different length"
   85:         with pytest.raises(ValueError, match=xpr.format("list-like")):
   86:             ser[[0, 1]] = value
   87:         # Ensure no modifications made before the exception
   88:         tm.assert_series_equal(ser, original)
   89: 
   90:         with pytest.raises(ValueError, match=xpr.format("slice")):
   91:             ser[slice(3)] = value
   92:         tm.assert_series_equal(ser, original)
   93: 
   94:     def test_setitem_empty_indexer(self, data, box_in_series):
   95:         if box_in_series:
   96:             data = pd.Series(data)
   97:         original = data.copy()
   98:         data[np.array([], dtype=int)] = []
   99:         tm.assert_equal(data, original)
  100: 
  101:     def test_setitem_sequence_broadcasts(self, data, box_in_series):
  102:         if box_in_series:
  103:             data = pd.Series(data)
  104:         data[[0, 1]] = data[2]
  105:         assert data[0] == data[2]
  106:         assert data[1] == data[2]
  107: 
  108:     @pytest.mark.parametrize("setter", ["loc", "iloc"])
  109:     def test_setitem_scalar(self, data, setter):
  110:         arr = pd.Series(data)
  111:         setter = getattr(arr, setter)
  112:         setter[0] = data[1]
  113:         assert arr[0] == data[1]
  114: 
  115:     def test_setitem_loc_scalar_mixed(self, data):
  116:         df = pd.DataFrame({"A": np.arange(len(data)), "B": data})
  117:         df.loc[0, "B"] = data[1]
  118:         assert df.loc[0, "B"] == data[1]
  119: 
  120:     def test_setitem_loc_scalar_single(self, data):
  121:         df = pd.DataFrame({"B": data})
  122:         df.loc[10, "B"] = data[1]
  123:         assert df.loc[10, "B"] == data[1]
  124: 
  125:     def test_setitem_loc_scalar_multiple_homogoneous(self, data):
  126:         df = pd.DataFrame({"A": data, "B": data})
  127:         df.loc[10, "B"] = data[1]
  128:         assert df.loc[10, "B"] == data[1]
  129: 
  130:     def test_setitem_iloc_scalar_mixed(self, data):
  131:         df = pd.DataFrame({"A": np.arange(len(data)), "B": data})
  132:         df.iloc[0, 1] = data[1]
  133:         assert df.loc[0, "B"] == data[1]
  134: 
  135:     def test_setitem_iloc_scalar_single(self, data):
  136:         df = pd.DataFrame({"B": data})
  137:         df.iloc[10, 0] = data[1]
  138:         assert df.loc[10, "B"] == data[1]
  139: 
  140:     def test_setitem_iloc_scalar_multiple_homogoneous(self, data):
  141:         df = pd.DataFrame({"A": data, "B": data})
  142:         df.iloc[10, 1] = data[1]
  143:         assert df.loc[10, "B"] == data[1]
  144: 
  145:     @pytest.mark.parametrize(
  146:         "mask",
  147:         [
  148:             np.array([True, True, True, False, False]),
  149:             pd.array([True, True, True, False, False], dtype="boolean"),
  150:             pd.array([True, True, True, pd.NA, pd.NA], dtype="boolean"),
  151:         ],
  152:         ids=["numpy-array", "boolean-array", "boolean-array-na"],
  153:     )
  154:     def test_setitem_mask(self, data, mask, box_in_series):
  155:         arr = data[:5].copy()
  156:         expected = arr.take([0, 0, 0, 3, 4])
  157:         if box_in_series:
  158:             arr = pd.Series(arr)
  159:             expected = pd.Series(expected)
  160:         arr[mask] = data[0]
  161:         tm.assert_equal(expected, arr)
  162: 
  163:     def test_setitem_mask_raises(self, data, box_in_series):
  164:         # wrong length
  165:         mask = np.array([True, False])
  166: 
  167:         if box_in_series:
  168:             data = pd.Series(data)
  169: 
  170:         with pytest.raises(IndexError, match="wrong length"):
  171:             data[mask] = data[0]
  172: 
  173:         mask = pd.array(mask, dtype="boolean")
  174:         with pytest.raises(IndexError, match="wrong length"):
  175:             data[mask] = data[0]
  176: 
  177:     def test_setitem_mask_boolean_array_with_na(self, data, box_in_series):
  178:         mask = pd.array(np.zeros(data.shape, dtype="bool"), dtype="boolean")
  179:         mask[:3] = True
  180:         mask[3:5] = pd.NA
  181: 
  182:         if box_in_series:
  183:             data = pd.Series(data)
  184: 
  185:         data[mask] = data[0]
  186: 
  187:         assert (data[:3] == data[0]).all()
  188: 
  189:     @pytest.mark.parametrize(
  190:         "idx",
  191:         [[0, 1, 2], pd.array([0, 1, 2], dtype="Int64"), np.array([0, 1, 2])],
  192:         ids=["list", "integer-array", "numpy-array"],
  193:     )
  194:     def test_setitem_integer_array(self, data, idx, box_in_series):
  195:         arr = data[:5].copy()
  196:         expected = data.take([0, 0, 0, 3, 4])
  197: 
  198:         if box_in_series:
  199:             arr = pd.Series(arr)
  200:             expected = pd.Series(expected)
  201: 
  202:         arr[idx] = arr[0]
  203:         tm.assert_equal(arr, expected)
  204: 
  205:     @pytest.mark.parametrize(
  206:         "idx, box_in_series",
  207:         [
  208:             ([0, 1, 2, pd.NA], False),
  209:             pytest.param(
  210:                 [0, 1, 2, pd.NA], True, marks=pytest.mark.xfail(reason="GH-31948")
  211:             ),
  212:             (pd.array([0, 1, 2, pd.NA], dtype="Int64"), False),
  213:             (pd.array([0, 1, 2, pd.NA], dtype="Int64"), False),
  214:         ],
  215:         ids=["list-False", "list-True", "integer-array-False", "integer-array-True"],
  216:     )
  217:     def test_setitem_integer_with_missing_raises(self, data, idx, box_in_series):
  218:         arr = data.copy()
  219: 
  220:         # TODO(xfail) this raises KeyError about labels not found (it tries label-based)
  221:         # for list of labels with Series
  222:         if box_in_series:
  223:             arr = pd.Series(data, index=[chr(100 + i) for i in range(len(data))])
  224: 
  225:         msg = "Cannot index with an integer indexer containing NA values"
  226:         with pytest.raises(ValueError, match=msg):
  227:             arr[idx] = arr[0]
  228: 
  229:     @pytest.mark.parametrize("as_callable", [True, False])
  230:     @pytest.mark.parametrize("setter", ["loc", None])
  231:     def test_setitem_mask_aligned(self, data, as_callable, setter):
  232:         ser = pd.Series(data)
  233:         mask = np.zeros(len(data), dtype=bool)
  234:         mask[:2] = True
  235: 
  236:         if as_callable:
  237:             mask2 = lambda x: mask
  238:         else:
  239:             mask2 = mask
  240: 
  241:         if setter:
  242:             # loc
  243:             target = getattr(ser, setter)
  244:         else:
  245:             # Series.__setitem__
  246:             target = ser
  247: 
  248:         target[mask2] = data[5:7]
  249: 
  250:         ser[mask2] = data[5:7]
  251:         assert ser[0] == data[5]
  252:         assert ser[1] == data[6]
  253: 
  254:     @pytest.mark.parametrize("setter", ["loc", None])
  255:     def test_setitem_mask_broadcast(self, data, setter):
  256:         ser = pd.Series(data)
  257:         mask = np.zeros(len(data), dtype=bool)
  258:         mask[:2] = True
  259: 
  260:         if setter:  # loc
  261:             target = getattr(ser, setter)
  262:         else:  # __setitem__
  263:             target = ser
  264: 
  265:         target[mask] = data[10]
  266:         assert ser[0] == data[10]
  267:         assert ser[1] == data[10]
  268: 
  269:     def test_setitem_expand_columns(self, data):
  270:         df = pd.DataFrame({"A": data})
  271:         result = df.copy()
  272:         result["B"] = 1
  273:         expected = pd.DataFrame({"A": data, "B": [1] * len(data)})
  274:         tm.assert_frame_equal(result, expected)
  275: 
  276:         result = df.copy()
  277:         result.loc[:, "B"] = 1
  278:         tm.assert_frame_equal(result, expected)
  279: 
  280:         # overwrite with new type
  281:         result["B"] = data
  282:         expected = pd.DataFrame({"A": data, "B": data})
  283:         tm.assert_frame_equal(result, expected)
  284: 
  285:     def test_setitem_expand_with_extension(self, data):
  286:         df = pd.DataFrame({"A": [1] * len(data)})
  287:         result = df.copy()
  288:         result["B"] = data
  289:         expected = pd.DataFrame({"A": [1] * len(data), "B": data})
  290:         tm.assert_frame_equal(result, expected)
  291: 
  292:         result = df.copy()
  293:         result.loc[:, "B"] = data
  294:         tm.assert_frame_equal(result, expected)
  295: 
  296:     def test_setitem_frame_invalid_length(self, data):
  297:         df = pd.DataFrame({"A": [1] * len(data)})
  298:         xpr = (
  299:             rf"Length of values \({len(data[:5])}\) "
  300:             rf"does not match length of index \({len(df)}\)"
  301:         )
  302:         with pytest.raises(ValueError, match=xpr):
  303:             df["B"] = data[:5]
  304: 
  305:     def test_setitem_tuple_index(self, data):
  306:         ser = pd.Series(data[:2], index=[(0, 0), (0, 1)])
  307:         expected = pd.Series(data.take([1, 1]), index=ser.index)
  308:         ser[(0, 0)] = data[1]
  309:         tm.assert_series_equal(ser, expected)
  310: 
  311:     def test_setitem_slice(self, data, box_in_series):
  312:         arr = data[:5].copy()
  313:         expected = data.take([0, 0, 0, 3, 4])
  314:         if box_in_series:
  315:             arr = pd.Series(arr)
  316:             expected = pd.Series(expected)
  317: 
  318:         arr[:3] = data[0]
  319:         tm.assert_equal(arr, expected)
  320: 
  321:     def test_setitem_loc_iloc_slice(self, data):
  322:         arr = data[:5].copy()
  323:         s = pd.Series(arr, index=["a", "b", "c", "d", "e"])
  324:         expected = pd.Series(data.take([0, 0, 0, 3, 4]), index=s.index)
  325: 
  326:         result = s.copy()
  327:         result.iloc[:3] = data[0]
  328:         tm.assert_equal(result, expected)
  329: 
  330:         result = s.copy()
  331:         result.loc[:"c"] = data[0]
  332:         tm.assert_equal(result, expected)
  333: 
  334:     def test_setitem_slice_mismatch_length_raises(self, data):
  335:         arr = data[:5]
  336:         with pytest.raises(ValueError):
  337:             arr[:1] = arr[:2]
  338: 
  339:     def test_setitem_slice_array(self, data):
  340:         arr = data[:5].copy()
  341:         arr[:5] = data[-5:]
  342:         tm.assert_extension_array_equal(arr, data[-5:])
  343: 
  344:     def test_setitem_scalar_key_sequence_raise(self, data):
  345:         arr = data[:5].copy()
  346:         with pytest.raises(ValueError):
  347:             arr[0] = arr[[0, 1]]
  348: 
  349:     def test_setitem_preserves_views(self, data):
  350:         # GH#28150 setitem shouldn't swap the underlying data
  351:         view1 = data.view()
  352:         view2 = data[:]
  353: 
  354:         data[0] = data[1]
  355:         assert view1[0] == data[1]
  356:         assert view2[0] == data[1]
  357: 
  358:     def test_setitem_with_expansion_dataframe_column(self, data, full_indexer):
  359:         # https://github.com/pandas-dev/pandas/issues/32395
  360:         df = expected = pd.DataFrame({0: pd.Series(data)})
  361:         result = pd.DataFrame(index=df.index)
  362: 
  363:         key = full_indexer(df)
  364:         result.loc[key, 0] = df[0]
  365: 
  366:         tm.assert_frame_equal(result, expected)
  367: 
  368:     def test_setitem_with_expansion_row(self, data, na_value):
  369:         df = pd.DataFrame({"data": data[:1]})
  370: 
  371:         df.loc[1, "data"] = data[1]
  372:         expected = pd.DataFrame({"data": data[:2]})
  373:         tm.assert_frame_equal(df, expected)
  374: 
  375:         # https://github.com/pandas-dev/pandas/issues/47284
  376:         df.loc[2, "data"] = na_value
  377:         expected = pd.DataFrame(
  378:             {"data": pd.Series([data[0], data[1], na_value], dtype=data.dtype)}
  379:         )
  380:         tm.assert_frame_equal(df, expected)
  381: 
  382:     def test_setitem_series(self, data, full_indexer):
  383:         # https://github.com/pandas-dev/pandas/issues/32395
  384:         ser = pd.Series(data, name="data")
  385:         result = pd.Series(index=ser.index, dtype=object, name="data")
  386: 
  387:         # because result has object dtype, the attempt to do setting inplace
  388:         #  is successful, and object dtype is retained
  389:         key = full_indexer(ser)
  390:         result.loc[key] = ser
  391: 
  392:         expected = pd.Series(
  393:             data.astype(object), index=ser.index, name="data", dtype=object
  394:         )
  395:         tm.assert_series_equal(result, expected)
  396: 
  397:     def test_setitem_frame_2d_values(self, data):
  398:         # GH#44514
  399:         df = pd.DataFrame({"A": data})
  400: 
  401:         # Avoiding using_array_manager fixture
  402:         #  https://github.com/pandas-dev/pandas/pull/44514#discussion_r754002410
  403:         using_array_manager = isinstance(df._mgr, pd.core.internals.ArrayManager)
  404:         using_copy_on_write = pd.options.mode.copy_on_write
  405: 
  406:         blk_data = df._mgr.arrays[0]
  407: 
  408:         orig = df.copy()
  409: 
  410:         df.iloc[:] = df.copy()
  411:         tm.assert_frame_equal(df, orig)
  412: 
  413:         df.iloc[:-1] = df.iloc[:-1].copy()
  414:         tm.assert_frame_equal(df, orig)
  415: 
  416:         df.iloc[:] = df.values
  417:         tm.assert_frame_equal(df, orig)
  418:         if not using_array_manager and not using_copy_on_write:
  419:             # GH#33457 Check that this setting occurred in-place
  420:             # FIXME(ArrayManager): this should work there too
  421:             assert df._mgr.arrays[0] is blk_data
  422: 
  423:         df.iloc[:-1] = df.values[:-1]
  424:         tm.assert_frame_equal(df, orig)
  425: 
  426:     def test_delitem_series(self, data):
  427:         # GH#40763
  428:         ser = pd.Series(data, name="data")
  429: 
  430:         taker = np.arange(len(ser))
  431:         taker = np.delete(taker, 1)
  432: 
  433:         expected = ser[taker]
  434:         del ser[1]
  435:         tm.assert_series_equal(ser, expected)
  436: 
  437:     def test_setitem_invalid(self, data, invalid_scalar):
  438:         msg = ""  # messages vary by subclass, so we do not test it
  439:         with pytest.raises((ValueError, TypeError), match=msg):
  440:             data[0] = invalid_scalar
  441: 
  442:         with pytest.raises((ValueError, TypeError), match=msg):
  443:             data[:] = invalid_scalar
  444: 
  445:     def test_setitem_2d_values(self, data):
  446:         # GH50085
  447:         original = data.copy()
  448:         df = pd.DataFrame({"a": data, "b": data})
  449:         df.loc[[0, 1], :] = df.loc[[1, 0], :].values
  450:         assert (df.loc[0, :] == original[1]).all()
  451:         assert (df.loc[1, :] == original[0]).all()
