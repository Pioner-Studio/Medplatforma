    1: import numpy as np
    2: import pytest
    3: 
    4: import pandas.util._test_decorators as td
    5: 
    6: import pandas as pd
    7: import pandas._testing as tm
    8: from pandas.core.internals.blocks import NumpyBlock
    9: 
   10: 
   11: class BaseCastingTests:
   12:     """Casting to and from ExtensionDtypes"""
   13: 
   14:     def test_astype_object_series(self, all_data):
   15:         ser = pd.Series(all_data, name="A")
   16:         result = ser.astype(object)
   17:         assert result.dtype == np.dtype(object)
   18:         if hasattr(result._mgr, "blocks"):
   19:             blk = result._mgr.blocks[0]
   20:             assert isinstance(blk, NumpyBlock)
   21:             assert blk.is_object
   22:         assert isinstance(result._mgr.array, np.ndarray)
   23:         assert result._mgr.array.dtype == np.dtype(object)
   24: 
   25:     def test_astype_object_frame(self, all_data):
   26:         df = pd.DataFrame({"A": all_data})
   27: 
   28:         result = df.astype(object)
   29:         if hasattr(result._mgr, "blocks"):
   30:             blk = result._mgr.blocks[0]
   31:             assert isinstance(blk, NumpyBlock), type(blk)
   32:             assert blk.is_object
   33:         assert isinstance(result._mgr.arrays[0], np.ndarray)
   34:         assert result._mgr.arrays[0].dtype == np.dtype(object)
   35: 
   36:         # check that we can compare the dtypes
   37:         comp = result.dtypes == df.dtypes
   38:         assert not comp.any()
   39: 
   40:     def test_tolist(self, data):
   41:         result = pd.Series(data).tolist()
   42:         expected = list(data)
   43:         assert result == expected
   44: 
   45:     def test_astype_str(self, data):
   46:         result = pd.Series(data[:5]).astype(str)
   47:         expected = pd.Series([str(x) for x in data[:5]], dtype=str)
   48:         tm.assert_series_equal(result, expected)
   49: 
   50:     @pytest.mark.parametrize(
   51:         "nullable_string_dtype",
   52:         [
   53:             "string[python]",
   54:             pytest.param("string[pyarrow]", marks=td.skip_if_no("pyarrow")),
   55:         ],
   56:     )
   57:     def test_astype_string(self, data, nullable_string_dtype):
   58:         # GH-33465, GH#45326 as of 2.0 we decode bytes instead of calling str(obj)
   59:         result = pd.Series(data[:5]).astype(nullable_string_dtype)
   60:         expected = pd.Series(
   61:             [str(x) if not isinstance(x, bytes) else x.decode() for x in data[:5]],
   62:             dtype=nullable_string_dtype,
   63:         )
   64:         tm.assert_series_equal(result, expected)
   65: 
   66:     def test_to_numpy(self, data):
   67:         expected = np.asarray(data)
   68: 
   69:         result = data.to_numpy()
   70:         tm.assert_equal(result, expected)
   71: 
   72:         result = pd.Series(data).to_numpy()
   73:         tm.assert_equal(result, expected)
   74: 
   75:     def test_astype_empty_dataframe(self, dtype):
   76:         # https://github.com/pandas-dev/pandas/issues/33113
   77:         df = pd.DataFrame()
   78:         result = df.astype(dtype)
   79:         tm.assert_frame_equal(result, df)
   80: 
   81:     @pytest.mark.parametrize("copy", [True, False])
   82:     def test_astype_own_type(self, data, copy):
   83:         # ensure that astype returns the original object for equal dtype and copy=False
   84:         # https://github.com/pandas-dev/pandas/issues/28488
   85:         result = data.astype(data.dtype, copy=copy)
   86:         assert (result is data) is (not copy)
   87:         tm.assert_extension_array_equal(result, data)
