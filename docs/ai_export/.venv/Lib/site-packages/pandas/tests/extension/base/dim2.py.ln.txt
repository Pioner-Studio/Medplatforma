    1: """
    2: Tests for 2D compatibility.
    3: """
    4: import numpy as np
    5: import pytest
    6: 
    7: from pandas._libs.missing import is_matching_na
    8: 
    9: from pandas.core.dtypes.common import (
   10:     is_bool_dtype,
   11:     is_integer_dtype,
   12: )
   13: 
   14: import pandas as pd
   15: import pandas._testing as tm
   16: from pandas.core.arrays.integer import NUMPY_INT_TO_DTYPE
   17: 
   18: 
   19: class Dim2CompatTests:
   20:     # Note: these are ONLY for ExtensionArray subclasses that support 2D arrays.
   21:     #  i.e. not for pyarrow-backed EAs.
   22: 
   23:     @pytest.fixture(autouse=True)
   24:     def skip_if_doesnt_support_2d(self, dtype, request):
   25:         if not dtype._supports_2d:
   26:             node = request.node
   27:             # In cases where we are mixed in to ExtensionTests, we only want to
   28:             #  skip tests that are defined in Dim2CompatTests
   29:             test_func = node._obj
   30:             if test_func.__qualname__.startswith("Dim2CompatTests"):
   31:                 # TODO: is there a less hacky way of checking this?
   32:                 pytest.skip(f"{dtype} does not support 2D.")
   33: 
   34:     def test_transpose(self, data):
   35:         arr2d = data.repeat(2).reshape(-1, 2)
   36:         shape = arr2d.shape
   37:         assert shape[0] != shape[-1]  # otherwise the rest of the test is useless
   38: 
   39:         assert arr2d.T.shape == shape[::-1]
   40: 
   41:     def test_frame_from_2d_array(self, data):
   42:         arr2d = data.repeat(2).reshape(-1, 2)
   43: 
   44:         df = pd.DataFrame(arr2d)
   45:         expected = pd.DataFrame({0: arr2d[:, 0], 1: arr2d[:, 1]})
   46:         tm.assert_frame_equal(df, expected)
   47: 
   48:     def test_swapaxes(self, data):
   49:         arr2d = data.repeat(2).reshape(-1, 2)
   50: 
   51:         result = arr2d.swapaxes(0, 1)
   52:         expected = arr2d.T
   53:         tm.assert_extension_array_equal(result, expected)
   54: 
   55:     def test_delete_2d(self, data):
   56:         arr2d = data.repeat(3).reshape(-1, 3)
   57: 
   58:         # axis = 0
   59:         result = arr2d.delete(1, axis=0)
   60:         expected = data.delete(1).repeat(3).reshape(-1, 3)
   61:         tm.assert_extension_array_equal(result, expected)
   62: 
   63:         # axis = 1
   64:         result = arr2d.delete(1, axis=1)
   65:         expected = data.repeat(2).reshape(-1, 2)
   66:         tm.assert_extension_array_equal(result, expected)
   67: 
   68:     def test_take_2d(self, data):
   69:         arr2d = data.reshape(-1, 1)
   70: 
   71:         result = arr2d.take([0, 0, -1], axis=0)
   72: 
   73:         expected = data.take([0, 0, -1]).reshape(-1, 1)
   74:         tm.assert_extension_array_equal(result, expected)
   75: 
   76:     def test_repr_2d(self, data):
   77:         # this could fail in a corner case where an element contained the name
   78:         res = repr(data.reshape(1, -1))
   79:         assert res.count(f"<{type(data).__name__}") == 1
   80: 
   81:         res = repr(data.reshape(-1, 1))
   82:         assert res.count(f"<{type(data).__name__}") == 1
   83: 
   84:     def test_reshape(self, data):
   85:         arr2d = data.reshape(-1, 1)
   86:         assert arr2d.shape == (data.size, 1)
   87:         assert len(arr2d) == len(data)
   88: 
   89:         arr2d = data.reshape((-1, 1))
   90:         assert arr2d.shape == (data.size, 1)
   91:         assert len(arr2d) == len(data)
   92: 
   93:         with pytest.raises(ValueError):
   94:             data.reshape((data.size, 2))
   95:         with pytest.raises(ValueError):
   96:             data.reshape(data.size, 2)
   97: 
   98:     def test_getitem_2d(self, data):
   99:         arr2d = data.reshape(1, -1)
  100: 
  101:         result = arr2d[0]
  102:         tm.assert_extension_array_equal(result, data)
  103: 
  104:         with pytest.raises(IndexError):
  105:             arr2d[1]
  106: 
  107:         with pytest.raises(IndexError):
  108:             arr2d[-2]
  109: 
  110:         result = arr2d[:]
  111:         tm.assert_extension_array_equal(result, arr2d)
  112: 
  113:         result = arr2d[:, :]
  114:         tm.assert_extension_array_equal(result, arr2d)
  115: 
  116:         result = arr2d[:, 0]
  117:         expected = data[[0]]
  118:         tm.assert_extension_array_equal(result, expected)
  119: 
  120:         # dimension-expanding getitem on 1D
  121:         result = data[:, np.newaxis]
  122:         tm.assert_extension_array_equal(result, arr2d.T)
  123: 
  124:     def test_iter_2d(self, data):
  125:         arr2d = data.reshape(1, -1)
  126: 
  127:         objs = list(iter(arr2d))
  128:         assert len(objs) == arr2d.shape[0]
  129: 
  130:         for obj in objs:
  131:             assert isinstance(obj, type(data))
  132:             assert obj.dtype == data.dtype
  133:             assert obj.ndim == 1
  134:             assert len(obj) == arr2d.shape[1]
  135: 
  136:     def test_tolist_2d(self, data):
  137:         arr2d = data.reshape(1, -1)
  138: 
  139:         result = arr2d.tolist()
  140:         expected = [data.tolist()]
  141: 
  142:         assert isinstance(result, list)
  143:         assert all(isinstance(x, list) for x in result)
  144: 
  145:         assert result == expected
  146: 
  147:     def test_concat_2d(self, data):
  148:         left = type(data)._concat_same_type([data, data]).reshape(-1, 2)
  149:         right = left.copy()
  150: 
  151:         # axis=0
  152:         result = left._concat_same_type([left, right], axis=0)
  153:         expected = data._concat_same_type([data] * 4).reshape(-1, 2)
  154:         tm.assert_extension_array_equal(result, expected)
  155: 
  156:         # axis=1
  157:         result = left._concat_same_type([left, right], axis=1)
  158:         assert result.shape == (len(data), 4)
  159:         tm.assert_extension_array_equal(result[:, :2], left)
  160:         tm.assert_extension_array_equal(result[:, 2:], right)
  161: 
  162:         # axis > 1 -> invalid
  163:         msg = "axis 2 is out of bounds for array of dimension 2"
  164:         with pytest.raises(ValueError, match=msg):
  165:             left._concat_same_type([left, right], axis=2)
  166: 
  167:     @pytest.mark.parametrize("method", ["backfill", "pad"])
  168:     def test_fillna_2d_method(self, data_missing, method):
  169:         # pad_or_backfill is always along axis=0
  170:         arr = data_missing.repeat(2).reshape(2, 2)
  171:         assert arr[0].isna().all()
  172:         assert not arr[1].isna().any()
  173: 
  174:         result = arr._pad_or_backfill(method=method, limit=None)
  175: 
  176:         expected = data_missing._pad_or_backfill(method=method).repeat(2).reshape(2, 2)
  177:         tm.assert_extension_array_equal(result, expected)
  178: 
  179:         # Reverse so that backfill is not a no-op.
  180:         arr2 = arr[::-1]
  181:         assert not arr2[0].isna().any()
  182:         assert arr2[1].isna().all()
  183: 
  184:         result2 = arr2._pad_or_backfill(method=method, limit=None)
  185: 
  186:         expected2 = (
  187:             data_missing[::-1]._pad_or_backfill(method=method).repeat(2).reshape(2, 2)
  188:         )
  189:         tm.assert_extension_array_equal(result2, expected2)
  190: 
  191:     @pytest.mark.parametrize("method", ["mean", "median", "var", "std", "sum", "prod"])
  192:     def test_reductions_2d_axis_none(self, data, method):
  193:         arr2d = data.reshape(1, -1)
  194: 
  195:         err_expected = None
  196:         err_result = None
  197:         try:
  198:             expected = getattr(data, method)()
  199:         except Exception as err:
  200:             # if the 1D reduction is invalid, the 2D reduction should be as well
  201:             err_expected = err
  202:             try:
  203:                 result = getattr(arr2d, method)(axis=None)
  204:             except Exception as err2:
  205:                 err_result = err2
  206: 
  207:         else:
  208:             result = getattr(arr2d, method)(axis=None)
  209: 
  210:         if err_result is not None or err_expected is not None:
  211:             assert type(err_result) == type(err_expected)
  212:             return
  213: 
  214:         assert is_matching_na(result, expected) or result == expected
  215: 
  216:     @pytest.mark.parametrize("method", ["mean", "median", "var", "std", "sum", "prod"])
  217:     @pytest.mark.parametrize("min_count", [0, 1])
  218:     def test_reductions_2d_axis0(self, data, method, min_count):
  219:         if min_count == 1 and method not in ["sum", "prod"]:
  220:             pytest.skip(f"min_count not relevant for {method}")
  221: 
  222:         arr2d = data.reshape(1, -1)
  223: 
  224:         kwargs = {}
  225:         if method in ["std", "var"]:
  226:             # pass ddof=0 so we get all-zero std instead of all-NA std
  227:             kwargs["ddof"] = 0
  228:         elif method in ["prod", "sum"]:
  229:             kwargs["min_count"] = min_count
  230: 
  231:         try:
  232:             result = getattr(arr2d, method)(axis=0, **kwargs)
  233:         except Exception as err:
  234:             try:
  235:                 getattr(data, method)()
  236:             except Exception as err2:
  237:                 assert type(err) == type(err2)
  238:                 return
  239:             else:
  240:                 raise AssertionError("Both reductions should raise or neither")
  241: 
  242:         def get_reduction_result_dtype(dtype):
  243:             # windows and 32bit builds will in some cases have int32/uint32
  244:             #  where other builds will have int64/uint64.
  245:             if dtype.itemsize == 8:
  246:                 return dtype
  247:             elif dtype.kind in "ib":
  248:                 return NUMPY_INT_TO_DTYPE[np.dtype(int)]
  249:             else:
  250:                 # i.e. dtype.kind == "u"
  251:                 return NUMPY_INT_TO_DTYPE[np.dtype("uint")]
  252: 
  253:         if method in ["sum", "prod"]:
  254:             # std and var are not dtype-preserving
  255:             expected = data
  256:             if data.dtype.kind in "iub":
  257:                 dtype = get_reduction_result_dtype(data.dtype)
  258:                 expected = data.astype(dtype)
  259:                 assert dtype == expected.dtype
  260: 
  261:             if min_count == 0:
  262:                 fill_value = 1 if method == "prod" else 0
  263:                 expected = expected.fillna(fill_value)
  264: 
  265:             tm.assert_extension_array_equal(result, expected)
  266:         elif method == "median":
  267:             # std and var are not dtype-preserving
  268:             expected = data
  269:             tm.assert_extension_array_equal(result, expected)
  270:         elif method in ["mean", "std", "var"]:
  271:             if is_integer_dtype(data) or is_bool_dtype(data):
  272:                 data = data.astype("Float64")
  273:             if method == "mean":
  274:                 tm.assert_extension_array_equal(result, data)
  275:             else:
  276:                 tm.assert_extension_array_equal(result, data - data)
  277: 
  278:     @pytest.mark.parametrize("method", ["mean", "median", "var", "std", "sum", "prod"])
  279:     def test_reductions_2d_axis1(self, data, method):
  280:         arr2d = data.reshape(1, -1)
  281: 
  282:         try:
  283:             result = getattr(arr2d, method)(axis=1)
  284:         except Exception as err:
  285:             try:
  286:                 getattr(data, method)()
  287:             except Exception as err2:
  288:                 assert type(err) == type(err2)
  289:                 return
  290:             else:
  291:                 raise AssertionError("Both reductions should raise or neither")
  292: 
  293:         # not necessarily type/dtype-preserving, so weaker assertions
  294:         assert result.shape == (1,)
  295:         expected_scalar = getattr(data, method)()
  296:         res = result[0]
  297:         assert is_matching_na(res, expected_scalar) or res == expected_scalar
  298: 
  299: 
  300: class NDArrayBacked2DTests(Dim2CompatTests):
  301:     # More specific tests for NDArrayBackedExtensionArray subclasses
  302: 
  303:     def test_copy_order(self, data):
  304:         # We should be matching numpy semantics for the "order" keyword in 'copy'
  305:         arr2d = data.repeat(2).reshape(-1, 2)
  306:         assert arr2d._ndarray.flags["C_CONTIGUOUS"]
  307: 
  308:         res = arr2d.copy()
  309:         assert res._ndarray.flags["C_CONTIGUOUS"]
  310: 
  311:         res = arr2d[::2, ::2].copy()
  312:         assert res._ndarray.flags["C_CONTIGUOUS"]
  313: 
  314:         res = arr2d.copy("F")
  315:         assert not res._ndarray.flags["C_CONTIGUOUS"]
  316:         assert res._ndarray.flags["F_CONTIGUOUS"]
  317: 
  318:         res = arr2d.copy("K")
  319:         assert res._ndarray.flags["C_CONTIGUOUS"]
  320: 
  321:         res = arr2d.T.copy("K")
  322:         assert not res._ndarray.flags["C_CONTIGUOUS"]
  323:         assert res._ndarray.flags["F_CONTIGUOUS"]
  324: 
  325:         # order not accepted by numpy
  326:         msg = r"order must be one of 'C', 'F', 'A', or 'K' \(got 'Q'\)"
  327:         with pytest.raises(ValueError, match=msg):
  328:             arr2d.copy("Q")
  329: 
  330:         # neither contiguity
  331:         arr_nc = arr2d[::2]
  332:         assert not arr_nc._ndarray.flags["C_CONTIGUOUS"]
  333:         assert not arr_nc._ndarray.flags["F_CONTIGUOUS"]
  334: 
  335:         assert arr_nc.copy()._ndarray.flags["C_CONTIGUOUS"]
  336:         assert not arr_nc.copy()._ndarray.flags["F_CONTIGUOUS"]
  337: 
  338:         assert arr_nc.copy("C")._ndarray.flags["C_CONTIGUOUS"]
  339:         assert not arr_nc.copy("C")._ndarray.flags["F_CONTIGUOUS"]
  340: 
  341:         assert not arr_nc.copy("F")._ndarray.flags["C_CONTIGUOUS"]
  342:         assert arr_nc.copy("F")._ndarray.flags["F_CONTIGUOUS"]
  343: 
  344:         assert arr_nc.copy("K")._ndarray.flags["C_CONTIGUOUS"]
  345:         assert not arr_nc.copy("K")._ndarray.flags["F_CONTIGUOUS"]
