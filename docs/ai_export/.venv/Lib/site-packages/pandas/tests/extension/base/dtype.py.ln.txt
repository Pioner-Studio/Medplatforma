    1: import numpy as np
    2: import pytest
    3: 
    4: import pandas as pd
    5: import pandas._testing as tm
    6: from pandas.api.types import (
    7:     infer_dtype,
    8:     is_object_dtype,
    9:     is_string_dtype,
   10: )
   11: 
   12: 
   13: class BaseDtypeTests:
   14:     """Base class for ExtensionDtype classes"""
   15: 
   16:     def test_name(self, dtype):
   17:         assert isinstance(dtype.name, str)
   18: 
   19:     def test_kind(self, dtype):
   20:         valid = set("biufcmMOSUV")
   21:         assert dtype.kind in valid
   22: 
   23:     def test_is_dtype_from_name(self, dtype):
   24:         result = type(dtype).is_dtype(dtype.name)
   25:         assert result is True
   26: 
   27:     def test_is_dtype_unboxes_dtype(self, data, dtype):
   28:         assert dtype.is_dtype(data) is True
   29: 
   30:     def test_is_dtype_from_self(self, dtype):
   31:         result = type(dtype).is_dtype(dtype)
   32:         assert result is True
   33: 
   34:     def test_is_dtype_other_input(self, dtype):
   35:         assert dtype.is_dtype([1, 2, 3]) is False
   36: 
   37:     def test_is_not_string_type(self, dtype):
   38:         assert not is_string_dtype(dtype)
   39: 
   40:     def test_is_not_object_type(self, dtype):
   41:         assert not is_object_dtype(dtype)
   42: 
   43:     def test_eq_with_str(self, dtype):
   44:         assert dtype == dtype.name
   45:         assert dtype != dtype.name + "-suffix"
   46: 
   47:     def test_eq_with_numpy_object(self, dtype):
   48:         assert dtype != np.dtype("object")
   49: 
   50:     def test_eq_with_self(self, dtype):
   51:         assert dtype == dtype
   52:         assert dtype != object()
   53: 
   54:     def test_array_type(self, data, dtype):
   55:         assert dtype.construct_array_type() is type(data)
   56: 
   57:     def test_check_dtype(self, data):
   58:         dtype = data.dtype
   59: 
   60:         # check equivalency for using .dtypes
   61:         df = pd.DataFrame(
   62:             {
   63:                 "A": pd.Series(data, dtype=dtype),
   64:                 "B": data,
   65:                 "C": pd.Series(["foo"] * len(data), dtype=object),
   66:                 "D": 1,
   67:             }
   68:         )
   69:         result = df.dtypes == str(dtype)
   70:         assert np.dtype("int64") != "Int64"
   71: 
   72:         expected = pd.Series([True, True, False, False], index=list("ABCD"))
   73: 
   74:         tm.assert_series_equal(result, expected)
   75: 
   76:         expected = pd.Series([True, True, False, False], index=list("ABCD"))
   77:         result = df.dtypes.apply(str) == str(dtype)
   78:         tm.assert_series_equal(result, expected)
   79: 
   80:     def test_hashable(self, dtype):
   81:         hash(dtype)  # no error
   82: 
   83:     def test_str(self, dtype):
   84:         assert str(dtype) == dtype.name
   85: 
   86:     def test_eq(self, dtype):
   87:         assert dtype == dtype.name
   88:         assert dtype != "anonther_type"
   89: 
   90:     def test_construct_from_string_own_name(self, dtype):
   91:         result = dtype.construct_from_string(dtype.name)
   92:         assert type(result) is type(dtype)
   93: 
   94:         # check OK as classmethod
   95:         result = type(dtype).construct_from_string(dtype.name)
   96:         assert type(result) is type(dtype)
   97: 
   98:     def test_construct_from_string_another_type_raises(self, dtype):
   99:         msg = f"Cannot construct a '{type(dtype).__name__}' from 'another_type'"
  100:         with pytest.raises(TypeError, match=msg):
  101:             type(dtype).construct_from_string("another_type")
  102: 
  103:     def test_construct_from_string_wrong_type_raises(self, dtype):
  104:         with pytest.raises(
  105:             TypeError,
  106:             match="'construct_from_string' expects a string, got <class 'int'>",
  107:         ):
  108:             type(dtype).construct_from_string(0)
  109: 
  110:     def test_get_common_dtype(self, dtype):
  111:         # in practice we will not typically call this with a 1-length list
  112:         # (we shortcut to just use that dtype as the common dtype), but
  113:         # still testing as good practice to have this working (and it is the
  114:         # only case we can test in general)
  115:         assert dtype._get_common_dtype([dtype]) == dtype
  116: 
  117:     @pytest.mark.parametrize("skipna", [True, False])
  118:     def test_infer_dtype(self, data, data_missing, skipna):
  119:         # only testing that this works without raising an error
  120:         res = infer_dtype(data, skipna=skipna)
  121:         assert isinstance(res, str)
  122:         res = infer_dtype(data_missing, skipna=skipna)
  123:         assert isinstance(res, str)
