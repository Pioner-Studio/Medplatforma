    1: """
    2: This file contains a minimal set of tests for compliance with the extension
    3: array interface test suite, and should contain no other tests.
    4: The test suite for the full functionality of the array is located in
    5: `pandas/tests/arrays/`.
    6: 
    7: The tests in this file are inherited from the BaseExtensionTests, and only
    8: minimal tweaks should be applied to get the tests passing (by overwriting a
    9: parent method).
   10: 
   11: Additional tests should either be added to one of the BaseExtensionTests
   12: classes (if they are relevant for the extension interface for all dtypes), or
   13: be added to the array-specific tests in `pandas/tests/arrays/`.
   14: 
   15: """
   16: import string
   17: 
   18: import numpy as np
   19: import pytest
   20: 
   21: from pandas._config import using_pyarrow_string_dtype
   22: 
   23: import pandas as pd
   24: from pandas import Categorical
   25: import pandas._testing as tm
   26: from pandas.api.types import CategoricalDtype
   27: from pandas.tests.extension import base
   28: 
   29: 
   30: def make_data():
   31:     while True:
   32:         values = np.random.default_rng(2).choice(list(string.ascii_letters), size=100)
   33:         # ensure we meet the requirements
   34:         # 1. first two not null
   35:         # 2. first and second are different
   36:         if values[0] != values[1]:
   37:             break
   38:     return values
   39: 
   40: 
   41: @pytest.fixture
   42: def dtype():
   43:     return CategoricalDtype()
   44: 
   45: 
   46: @pytest.fixture
   47: def data():
   48:     """Length-100 array for this type.
   49: 
   50:     * data[0] and data[1] should both be non missing
   51:     * data[0] and data[1] should not be equal
   52:     """
   53:     return Categorical(make_data())
   54: 
   55: 
   56: @pytest.fixture
   57: def data_missing():
   58:     """Length 2 array with [NA, Valid]"""
   59:     return Categorical([np.nan, "A"])
   60: 
   61: 
   62: @pytest.fixture
   63: def data_for_sorting():
   64:     return Categorical(["A", "B", "C"], categories=["C", "A", "B"], ordered=True)
   65: 
   66: 
   67: @pytest.fixture
   68: def data_missing_for_sorting():
   69:     return Categorical(["A", None, "B"], categories=["B", "A"], ordered=True)
   70: 
   71: 
   72: @pytest.fixture
   73: def data_for_grouping():
   74:     return Categorical(["a", "a", None, None, "b", "b", "a", "c"])
   75: 
   76: 
   77: class TestCategorical(base.ExtensionTests):
   78:     @pytest.mark.xfail(reason="Memory usage doesn't match")
   79:     def test_memory_usage(self, data):
   80:         # TODO: Is this deliberate?
   81:         super().test_memory_usage(data)
   82: 
   83:     def test_contains(self, data, data_missing):
   84:         # GH-37867
   85:         # na value handling in Categorical.__contains__ is deprecated.
   86:         # See base.BaseInterFaceTests.test_contains for more details.
   87: 
   88:         na_value = data.dtype.na_value
   89:         # ensure data without missing values
   90:         data = data[~data.isna()]
   91: 
   92:         # first elements are non-missing
   93:         assert data[0] in data
   94:         assert data_missing[0] in data_missing
   95: 
   96:         # check the presence of na_value
   97:         assert na_value in data_missing
   98:         assert na_value not in data
   99: 
  100:         # Categoricals can contain other nan-likes than na_value
  101:         for na_value_obj in tm.NULL_OBJECTS:
  102:             if na_value_obj is na_value:
  103:                 continue
  104:             assert na_value_obj not in data
  105:             # this section suffers from super method
  106:             if not using_pyarrow_string_dtype():
  107:                 assert na_value_obj in data_missing
  108: 
  109:     def test_empty(self, dtype):
  110:         cls = dtype.construct_array_type()
  111:         result = cls._empty((4,), dtype=dtype)
  112: 
  113:         assert isinstance(result, cls)
  114:         # the dtype we passed is not initialized, so will not match the
  115:         #  dtype on our result.
  116:         assert result.dtype == CategoricalDtype([])
  117: 
  118:     @pytest.mark.skip(reason="Backwards compatibility")
  119:     def test_getitem_scalar(self, data):
  120:         # CategoricalDtype.type isn't "correct" since it should
  121:         # be a parent of the elements (object). But don't want
  122:         # to break things by changing.
  123:         super().test_getitem_scalar(data)
  124: 
  125:     @pytest.mark.xfail(reason="Unobserved categories included")
  126:     def test_value_counts(self, all_data, dropna):
  127:         return super().test_value_counts(all_data, dropna)
  128: 
  129:     def test_combine_add(self, data_repeated):
  130:         # GH 20825
  131:         # When adding categoricals in combine, result is a string
  132:         orig_data1, orig_data2 = data_repeated(2)
  133:         s1 = pd.Series(orig_data1)
  134:         s2 = pd.Series(orig_data2)
  135:         result = s1.combine(s2, lambda x1, x2: x1 + x2)
  136:         expected = pd.Series(
  137:             [a + b for (a, b) in zip(list(orig_data1), list(orig_data2))]
  138:         )
  139:         tm.assert_series_equal(result, expected)
  140: 
  141:         val = s1.iloc[0]
  142:         result = s1.combine(val, lambda x1, x2: x1 + x2)
  143:         expected = pd.Series([a + val for a in list(orig_data1)])
  144:         tm.assert_series_equal(result, expected)
  145: 
  146:     @pytest.mark.parametrize("na_action", [None, "ignore"])
  147:     def test_map(self, data, na_action):
  148:         result = data.map(lambda x: x, na_action=na_action)
  149:         tm.assert_extension_array_equal(result, data)
  150: 
  151:     def test_arith_frame_with_scalar(self, data, all_arithmetic_operators, request):
  152:         # frame & scalar
  153:         op_name = all_arithmetic_operators
  154:         if op_name == "__rmod__":
  155:             request.applymarker(
  156:                 pytest.mark.xfail(
  157:                     reason="rmod never called when string is first argument"
  158:                 )
  159:             )
  160:         super().test_arith_frame_with_scalar(data, op_name)
  161: 
  162:     def test_arith_series_with_scalar(self, data, all_arithmetic_operators, request):
  163:         op_name = all_arithmetic_operators
  164:         if op_name == "__rmod__":
  165:             request.applymarker(
  166:                 pytest.mark.xfail(
  167:                     reason="rmod never called when string is first argument"
  168:                 )
  169:             )
  170:         super().test_arith_series_with_scalar(data, op_name)
  171: 
  172:     def _compare_other(self, ser: pd.Series, data, op, other):
  173:         op_name = f"__{op.__name__}__"
  174:         if op_name not in ["__eq__", "__ne__"]:
  175:             msg = "Unordered Categoricals can only compare equality or not"
  176:             with pytest.raises(TypeError, match=msg):
  177:                 op(data, other)
  178:         else:
  179:             return super()._compare_other(ser, data, op, other)
  180: 
  181:     @pytest.mark.xfail(reason="Categorical overrides __repr__")
  182:     @pytest.mark.parametrize("size", ["big", "small"])
  183:     def test_array_repr(self, data, size):
  184:         super().test_array_repr(data, size)
  185: 
  186:     @pytest.mark.xfail(reason="TBD")
  187:     @pytest.mark.parametrize("as_index", [True, False])
  188:     def test_groupby_extension_agg(self, as_index, data_for_grouping):
  189:         super().test_groupby_extension_agg(as_index, data_for_grouping)
  190: 
  191: 
  192: class Test2DCompat(base.NDArrayBacked2DTests):
  193:     def test_repr_2d(self, data):
  194:         # Categorical __repr__ doesn't include "Categorical", so we need
  195:         #  to special-case
  196:         res = repr(data.reshape(1, -1))
  197:         assert res.count("\nCategories") == 1
  198: 
  199:         res = repr(data.reshape(-1, 1))
  200:         assert res.count("\nCategories") == 1
