    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas.core.dtypes.cast import construct_1d_object_array_from_listlike
    5: from pandas.core.dtypes.common import is_extension_array_dtype
    6: from pandas.core.dtypes.dtypes import ExtensionDtype
    7: 
    8: import pandas as pd
    9: import pandas._testing as tm
   10: 
   11: 
   12: class BaseInterfaceTests:
   13:     """Tests that the basic interface is satisfied."""
   14: 
   15:     # ------------------------------------------------------------------------
   16:     # Interface
   17:     # ------------------------------------------------------------------------
   18: 
   19:     def test_len(self, data):
   20:         assert len(data) == 100
   21: 
   22:     def test_size(self, data):
   23:         assert data.size == 100
   24: 
   25:     def test_ndim(self, data):
   26:         assert data.ndim == 1
   27: 
   28:     def test_can_hold_na_valid(self, data):
   29:         # GH-20761
   30:         assert data._can_hold_na is True
   31: 
   32:     def test_contains(self, data, data_missing):
   33:         # GH-37867
   34:         # Tests for membership checks. Membership checks for nan-likes is tricky and
   35:         # the settled on rule is: `nan_like in arr` is True if nan_like is
   36:         # arr.dtype.na_value and arr.isna().any() is True. Else the check returns False.
   37: 
   38:         na_value = data.dtype.na_value
   39:         # ensure data without missing values
   40:         data = data[~data.isna()]
   41: 
   42:         # first elements are non-missing
   43:         assert data[0] in data
   44:         assert data_missing[0] in data_missing
   45: 
   46:         # check the presence of na_value
   47:         assert na_value in data_missing
   48:         assert na_value not in data
   49: 
   50:         # the data can never contain other nan-likes than na_value
   51:         for na_value_obj in tm.NULL_OBJECTS:
   52:             if na_value_obj is na_value or type(na_value_obj) == type(na_value):
   53:                 # type check for e.g. two instances of Decimal("NAN")
   54:                 continue
   55:             assert na_value_obj not in data
   56:             assert na_value_obj not in data_missing
   57: 
   58:     def test_memory_usage(self, data):
   59:         s = pd.Series(data)
   60:         result = s.memory_usage(index=False)
   61:         assert result == s.nbytes
   62: 
   63:     def test_array_interface(self, data):
   64:         result = np.array(data)
   65:         assert result[0] == data[0]
   66: 
   67:         result = np.array(data, dtype=object)
   68:         expected = np.array(list(data), dtype=object)
   69:         if expected.ndim > 1:
   70:             # nested data, explicitly construct as 1D
   71:             expected = construct_1d_object_array_from_listlike(list(data))
   72:         tm.assert_numpy_array_equal(result, expected)
   73: 
   74:     def test_is_extension_array_dtype(self, data):
   75:         assert is_extension_array_dtype(data)
   76:         assert is_extension_array_dtype(data.dtype)
   77:         assert is_extension_array_dtype(pd.Series(data))
   78:         assert isinstance(data.dtype, ExtensionDtype)
   79: 
   80:     def test_no_values_attribute(self, data):
   81:         # GH-20735: EA's with .values attribute give problems with internal
   82:         # code, disallowing this for now until solved
   83:         assert not hasattr(data, "values")
   84:         assert not hasattr(data, "_values")
   85: 
   86:     def test_is_numeric_honored(self, data):
   87:         result = pd.Series(data)
   88:         if hasattr(result._mgr, "blocks"):
   89:             assert result._mgr.blocks[0].is_numeric is data.dtype._is_numeric
   90: 
   91:     def test_isna_extension_array(self, data_missing):
   92:         # If your `isna` returns an ExtensionArray, you must also implement
   93:         # _reduce. At the *very* least, you must implement any and all
   94:         na = data_missing.isna()
   95:         if is_extension_array_dtype(na):
   96:             assert na._reduce("any")
   97:             assert na.any()
   98: 
   99:             assert not na._reduce("all")
  100:             assert not na.all()
  101: 
  102:             assert na.dtype._is_boolean
  103: 
  104:     def test_copy(self, data):
  105:         # GH#27083 removing deep keyword from EA.copy
  106:         assert data[0] != data[1]
  107:         result = data.copy()
  108: 
  109:         if data.dtype._is_immutable:
  110:             pytest.skip(f"test_copy assumes mutability and {data.dtype} is immutable")
  111: 
  112:         data[1] = data[0]
  113:         assert result[1] != result[0]
  114: 
  115:     def test_view(self, data):
  116:         # view with no dtype should return a shallow copy, *not* the same
  117:         #  object
  118:         assert data[1] != data[0]
  119: 
  120:         result = data.view()
  121:         assert result is not data
  122:         assert type(result) == type(data)
  123: 
  124:         if data.dtype._is_immutable:
  125:             pytest.skip(f"test_view assumes mutability and {data.dtype} is immutable")
  126: 
  127:         result[1] = result[0]
  128:         assert data[1] == data[0]
  129: 
  130:         # check specifically that the `dtype` kwarg is accepted
  131:         data.view(dtype=None)
  132: 
  133:     def test_tolist(self, data):
  134:         result = data.tolist()
  135:         expected = list(data)
  136:         assert isinstance(result, list)
  137:         assert result == expected
