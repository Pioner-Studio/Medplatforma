    1: """
    2: Test extension array for storing nested data in a pandas container.
    3: 
    4: The JSONArray stores lists of dictionaries. The storage mechanism is a list,
    5: not an ndarray.
    6: 
    7: Note
    8: ----
    9: We currently store lists of UserDicts. Pandas has a few places
   10: internally that specifically check for dicts, and does non-scalar things
   11: in that case. We *want* the dictionaries to be treated as scalars, so we
   12: hack around pandas by using UserDicts.
   13: """
   14: from __future__ import annotations
   15: 
   16: from collections import (
   17:     UserDict,
   18:     abc,
   19: )
   20: import itertools
   21: import numbers
   22: import string
   23: import sys
   24: from typing import (
   25:     TYPE_CHECKING,
   26:     Any,
   27: )
   28: 
   29: import numpy as np
   30: 
   31: from pandas.core.dtypes.cast import construct_1d_object_array_from_listlike
   32: from pandas.core.dtypes.common import (
   33:     is_bool_dtype,
   34:     is_list_like,
   35:     pandas_dtype,
   36: )
   37: 
   38: import pandas as pd
   39: from pandas.api.extensions import (
   40:     ExtensionArray,
   41:     ExtensionDtype,
   42: )
   43: from pandas.core.indexers import unpack_tuple_and_ellipses
   44: 
   45: if TYPE_CHECKING:
   46:     from collections.abc import Mapping
   47: 
   48:     from pandas._typing import type_t
   49: 
   50: 
   51: class JSONDtype(ExtensionDtype):
   52:     type = abc.Mapping
   53:     name = "json"
   54:     na_value: Mapping[str, Any] = UserDict()
   55: 
   56:     @classmethod
   57:     def construct_array_type(cls) -> type_t[JSONArray]:
   58:         """
   59:         Return the array type associated with this dtype.
   60: 
   61:         Returns
   62:         -------
   63:         type
   64:         """
   65:         return JSONArray
   66: 
   67: 
   68: class JSONArray(ExtensionArray):
   69:     dtype = JSONDtype()
   70:     __array_priority__ = 1000
   71: 
   72:     def __init__(self, values, dtype=None, copy=False) -> None:
   73:         for val in values:
   74:             if not isinstance(val, self.dtype.type):
   75:                 raise TypeError("All values must be of type " + str(self.dtype.type))
   76:         self.data = values
   77: 
   78:         # Some aliases for common attribute names to ensure pandas supports
   79:         # these
   80:         self._items = self._data = self.data
   81:         # those aliases are currently not working due to assumptions
   82:         # in internal code (GH-20735)
   83:         # self._values = self.values = self.data
   84: 
   85:     @classmethod
   86:     def _from_sequence(cls, scalars, *, dtype=None, copy=False):
   87:         return cls(scalars)
   88: 
   89:     @classmethod
   90:     def _from_factorized(cls, values, original):
   91:         return cls([UserDict(x) for x in values if x != ()])
   92: 
   93:     def __getitem__(self, item):
   94:         if isinstance(item, tuple):
   95:             item = unpack_tuple_and_ellipses(item)
   96: 
   97:         if isinstance(item, numbers.Integral):
   98:             return self.data[item]
   99:         elif isinstance(item, slice) and item == slice(None):
  100:             # Make sure we get a view
  101:             return type(self)(self.data)
  102:         elif isinstance(item, slice):
  103:             # slice
  104:             return type(self)(self.data[item])
  105:         elif not is_list_like(item):
  106:             # e.g. "foo" or 2.5
  107:             # exception message copied from numpy
  108:             raise IndexError(
  109:                 r"only integers, slices (`:`), ellipsis (`...`), numpy.newaxis "
  110:                 r"(`None`) and integer or boolean arrays are valid indices"
  111:             )
  112:         else:
  113:             item = pd.api.indexers.check_array_indexer(self, item)
  114:             if is_bool_dtype(item.dtype):
  115:                 return type(self)._from_sequence(
  116:                     [x for x, m in zip(self, item) if m], dtype=self.dtype
  117:                 )
  118:             # integer
  119:             return type(self)([self.data[i] for i in item])
  120: 
  121:     def __setitem__(self, key, value) -> None:
  122:         if isinstance(key, numbers.Integral):
  123:             self.data[key] = value
  124:         else:
  125:             if not isinstance(value, (type(self), abc.Sequence)):
  126:                 # broadcast value
  127:                 value = itertools.cycle([value])
  128: 
  129:             if isinstance(key, np.ndarray) and key.dtype == "bool":
  130:                 # masking
  131:                 for i, (k, v) in enumerate(zip(key, value)):
  132:                     if k:
  133:                         assert isinstance(v, self.dtype.type)
  134:                         self.data[i] = v
  135:             else:
  136:                 for k, v in zip(key, value):
  137:                     assert isinstance(v, self.dtype.type)
  138:                     self.data[k] = v
  139: 
  140:     def __len__(self) -> int:
  141:         return len(self.data)
  142: 
  143:     def __eq__(self, other):
  144:         return NotImplemented
  145: 
  146:     def __ne__(self, other):
  147:         return NotImplemented
  148: 
  149:     def __array__(self, dtype=None, copy=None):
  150:         if dtype is None:
  151:             dtype = object
  152:         if dtype == object:
  153:             # on py38 builds it looks like numpy is inferring to a non-1D array
  154:             return construct_1d_object_array_from_listlike(list(self))
  155:         return np.asarray(self.data, dtype=dtype)
  156: 
  157:     @property
  158:     def nbytes(self) -> int:
  159:         return sys.getsizeof(self.data)
  160: 
  161:     def isna(self):
  162:         return np.array([x == self.dtype.na_value for x in self.data], dtype=bool)
  163: 
  164:     def take(self, indexer, allow_fill=False, fill_value=None):
  165:         # re-implement here, since NumPy has trouble setting
  166:         # sized objects like UserDicts into scalar slots of
  167:         # an ndarary.
  168:         indexer = np.asarray(indexer)
  169:         msg = (
  170:             "Index is out of bounds or cannot do a "
  171:             "non-empty take from an empty array."
  172:         )
  173: 
  174:         if allow_fill:
  175:             if fill_value is None:
  176:                 fill_value = self.dtype.na_value
  177:             # bounds check
  178:             if (indexer < -1).any():
  179:                 raise ValueError
  180:             try:
  181:                 output = [
  182:                     self.data[loc] if loc != -1 else fill_value for loc in indexer
  183:                 ]
  184:             except IndexError as err:
  185:                 raise IndexError(msg) from err
  186:         else:
  187:             try:
  188:                 output = [self.data[loc] for loc in indexer]
  189:             except IndexError as err:
  190:                 raise IndexError(msg) from err
  191: 
  192:         return type(self)._from_sequence(output, dtype=self.dtype)
  193: 
  194:     def copy(self):
  195:         return type(self)(self.data[:])
  196: 
  197:     def astype(self, dtype, copy=True):
  198:         # NumPy has issues when all the dicts are the same length.
  199:         # np.array([UserDict(...), UserDict(...)]) fails,
  200:         # but np.array([{...}, {...}]) works, so cast.
  201:         from pandas.core.arrays.string_ import StringDtype
  202: 
  203:         dtype = pandas_dtype(dtype)
  204:         # needed to add this check for the Series constructor
  205:         if isinstance(dtype, type(self.dtype)) and dtype == self.dtype:
  206:             if copy:
  207:                 return self.copy()
  208:             return self
  209:         elif isinstance(dtype, StringDtype):
  210:             value = self.astype(str)  # numpy doesn't like nested dicts
  211:             arr_cls = dtype.construct_array_type()
  212:             return arr_cls._from_sequence(value, dtype=dtype, copy=False)
  213:         elif not copy:
  214:             return np.asarray([dict(x) for x in self], dtype=dtype)
  215:         else:
  216:             return np.array([dict(x) for x in self], dtype=dtype, copy=copy)
  217: 
  218:     def unique(self):
  219:         # Parent method doesn't work since np.array will try to infer
  220:         # a 2-dim object.
  221:         return type(self)([dict(x) for x in {tuple(d.items()) for d in self.data}])
  222: 
  223:     @classmethod
  224:     def _concat_same_type(cls, to_concat):
  225:         data = list(itertools.chain.from_iterable(x.data for x in to_concat))
  226:         return cls(data)
  227: 
  228:     def _values_for_factorize(self):
  229:         frozen = self._values_for_argsort()
  230:         if len(frozen) == 0:
  231:             # factorize_array expects 1-d array, this is a len-0 2-d array.
  232:             frozen = frozen.ravel()
  233:         return frozen, ()
  234: 
  235:     def _values_for_argsort(self):
  236:         # Bypass NumPy's shape inference to get a (N,) array of tuples.
  237:         frozen = [tuple(x.items()) for x in self]
  238:         return construct_1d_object_array_from_listlike(frozen)
  239: 
  240:     def _pad_or_backfill(self, *, method, limit=None, copy=True):
  241:         # GH#56616 - test EA method without limit_area argument
  242:         return super()._pad_or_backfill(method=method, limit=limit, copy=copy)
  243: 
  244: 
  245: def make_data():
  246:     # TODO: Use a regular dict. See _NDFrameIndexer._setitem_with_indexer
  247:     rng = np.random.default_rng(2)
  248:     return [
  249:         UserDict(
  250:             [
  251:                 (rng.choice(list(string.ascii_letters)), rng.integers(0, 100))
  252:                 for _ in range(rng.integers(0, 10))
  253:             ]
  254:         )
  255:         for _ in range(100)
  256:     ]
