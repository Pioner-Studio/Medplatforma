    1: import re
    2: 
    3: import pytest
    4: 
    5: from pandas.core.dtypes.common import (
    6:     is_bool_dtype,
    7:     is_numeric_dtype,
    8:     is_object_dtype,
    9:     is_string_dtype,
   10: )
   11: 
   12: import pandas as pd
   13: import pandas._testing as tm
   14: 
   15: 
   16: @pytest.mark.filterwarnings(
   17:     "ignore:The default of observed=False is deprecated:FutureWarning"
   18: )
   19: class BaseGroupbyTests:
   20:     """Groupby-specific tests."""
   21: 
   22:     def test_grouping_grouper(self, data_for_grouping):
   23:         df = pd.DataFrame(
   24:             {
   25:                 "A": pd.Series(
   26:                     ["B", "B", None, None, "A", "A", "B", "C"], dtype=object
   27:                 ),
   28:                 "B": data_for_grouping,
   29:             }
   30:         )
   31:         gr1 = df.groupby("A")._grouper.groupings[0]
   32:         gr2 = df.groupby("B")._grouper.groupings[0]
   33: 
   34:         tm.assert_numpy_array_equal(gr1.grouping_vector, df.A.values)
   35:         tm.assert_extension_array_equal(gr2.grouping_vector, data_for_grouping)
   36: 
   37:     @pytest.mark.parametrize("as_index", [True, False])
   38:     def test_groupby_extension_agg(self, as_index, data_for_grouping):
   39:         df = pd.DataFrame({"A": [1, 1, 2, 2, 3, 3, 1, 4], "B": data_for_grouping})
   40: 
   41:         is_bool = data_for_grouping.dtype._is_boolean
   42:         if is_bool:
   43:             # only 2 unique values, and the final entry has c==b
   44:             #  (see data_for_grouping docstring)
   45:             df = df.iloc[:-1]
   46: 
   47:         result = df.groupby("B", as_index=as_index).A.mean()
   48:         _, uniques = pd.factorize(data_for_grouping, sort=True)
   49: 
   50:         exp_vals = [3.0, 1.0, 4.0]
   51:         if is_bool:
   52:             exp_vals = exp_vals[:-1]
   53:         if as_index:
   54:             index = pd.Index(uniques, name="B")
   55:             expected = pd.Series(exp_vals, index=index, name="A")
   56:             tm.assert_series_equal(result, expected)
   57:         else:
   58:             expected = pd.DataFrame({"B": uniques, "A": exp_vals})
   59:             tm.assert_frame_equal(result, expected)
   60: 
   61:     def test_groupby_agg_extension(self, data_for_grouping):
   62:         # GH#38980 groupby agg on extension type fails for non-numeric types
   63:         df = pd.DataFrame({"A": [1, 1, 2, 2, 3, 3, 1, 4], "B": data_for_grouping})
   64: 
   65:         expected = df.iloc[[0, 2, 4, 7]]
   66:         expected = expected.set_index("A")
   67: 
   68:         result = df.groupby("A").agg({"B": "first"})
   69:         tm.assert_frame_equal(result, expected)
   70: 
   71:         result = df.groupby("A").agg("first")
   72:         tm.assert_frame_equal(result, expected)
   73: 
   74:         result = df.groupby("A").first()
   75:         tm.assert_frame_equal(result, expected)
   76: 
   77:     def test_groupby_extension_no_sort(self, data_for_grouping):
   78:         df = pd.DataFrame({"A": [1, 1, 2, 2, 3, 3, 1, 4], "B": data_for_grouping})
   79: 
   80:         is_bool = data_for_grouping.dtype._is_boolean
   81:         if is_bool:
   82:             # only 2 unique values, and the final entry has c==b
   83:             #  (see data_for_grouping docstring)
   84:             df = df.iloc[:-1]
   85: 
   86:         result = df.groupby("B", sort=False).A.mean()
   87:         _, index = pd.factorize(data_for_grouping, sort=False)
   88: 
   89:         index = pd.Index(index, name="B")
   90:         exp_vals = [1.0, 3.0, 4.0]
   91:         if is_bool:
   92:             exp_vals = exp_vals[:-1]
   93:         expected = pd.Series(exp_vals, index=index, name="A")
   94:         tm.assert_series_equal(result, expected)
   95: 
   96:     def test_groupby_extension_transform(self, data_for_grouping):
   97:         is_bool = data_for_grouping.dtype._is_boolean
   98: 
   99:         valid = data_for_grouping[~data_for_grouping.isna()]
  100:         df = pd.DataFrame({"A": [1, 1, 3, 3, 1, 4], "B": valid})
  101:         is_bool = data_for_grouping.dtype._is_boolean
  102:         if is_bool:
  103:             # only 2 unique values, and the final entry has c==b
  104:             #  (see data_for_grouping docstring)
  105:             df = df.iloc[:-1]
  106: 
  107:         result = df.groupby("B").A.transform(len)
  108:         expected = pd.Series([3, 3, 2, 2, 3, 1], name="A")
  109:         if is_bool:
  110:             expected = expected[:-1]
  111: 
  112:         tm.assert_series_equal(result, expected)
  113: 
  114:     def test_groupby_extension_apply(self, data_for_grouping, groupby_apply_op):
  115:         df = pd.DataFrame({"A": [1, 1, 2, 2, 3, 3, 1, 4], "B": data_for_grouping})
  116:         msg = "DataFrameGroupBy.apply operated on the grouping columns"
  117:         with tm.assert_produces_warning(DeprecationWarning, match=msg):
  118:             df.groupby("B", group_keys=False, observed=False).apply(groupby_apply_op)
  119:         df.groupby("B", group_keys=False, observed=False).A.apply(groupby_apply_op)
  120:         msg = "DataFrameGroupBy.apply operated on the grouping columns"
  121:         with tm.assert_produces_warning(DeprecationWarning, match=msg):
  122:             df.groupby("A", group_keys=False, observed=False).apply(groupby_apply_op)
  123:         df.groupby("A", group_keys=False, observed=False).B.apply(groupby_apply_op)
  124: 
  125:     def test_groupby_apply_identity(self, data_for_grouping):
  126:         df = pd.DataFrame({"A": [1, 1, 2, 2, 3, 3, 1, 4], "B": data_for_grouping})
  127:         result = df.groupby("A").B.apply(lambda x: x.array)
  128:         expected = pd.Series(
  129:             [
  130:                 df.B.iloc[[0, 1, 6]].array,
  131:                 df.B.iloc[[2, 3]].array,
  132:                 df.B.iloc[[4, 5]].array,
  133:                 df.B.iloc[[7]].array,
  134:             ],
  135:             index=pd.Index([1, 2, 3, 4], name="A"),
  136:             name="B",
  137:         )
  138:         tm.assert_series_equal(result, expected)
  139: 
  140:     def test_in_numeric_groupby(self, data_for_grouping):
  141:         df = pd.DataFrame(
  142:             {
  143:                 "A": [1, 1, 2, 2, 3, 3, 1, 4],
  144:                 "B": data_for_grouping,
  145:                 "C": [1, 1, 1, 1, 1, 1, 1, 1],
  146:             }
  147:         )
  148: 
  149:         dtype = data_for_grouping.dtype
  150:         if (
  151:             is_numeric_dtype(dtype)
  152:             or is_bool_dtype(dtype)
  153:             or dtype.name == "decimal"
  154:             or is_string_dtype(dtype)
  155:             or is_object_dtype(dtype)
  156:             or dtype.kind == "m"  # in particular duration[*][pyarrow]
  157:         ):
  158:             expected = pd.Index(["B", "C"])
  159:             result = df.groupby("A").sum().columns
  160:         else:
  161:             expected = pd.Index(["C"])
  162: 
  163:             msg = "|".join(
  164:                 [
  165:                     # period/datetime
  166:                     "does not support sum operations",
  167:                     # all others
  168:                     re.escape(f"agg function failed [how->sum,dtype->{dtype}"),
  169:                 ]
  170:             )
  171:             with pytest.raises(TypeError, match=msg):
  172:                 df.groupby("A").sum()
  173:             result = df.groupby("A").sum(numeric_only=True).columns
  174:         tm.assert_index_equal(result, expected)
