    1: """
    2: This file contains a minimal set of tests for compliance with the extension
    3: array interface test suite, and should contain no other tests.
    4: The test suite for the full functionality of the array is located in
    5: `pandas/tests/arrays/`.
    6: 
    7: The tests in this file are inherited from the BaseExtensionTests, and only
    8: minimal tweaks should be applied to get the tests passing (by overwriting a
    9: parent method).
   10: 
   11: Additional tests should either be added to one of the BaseExtensionTests
   12: classes (if they are relevant for the extension interface for all dtypes), or
   13: be added to the array-specific tests in `pandas/tests/arrays/`.
   14: 
   15: """
   16: from __future__ import annotations
   17: 
   18: import string
   19: from typing import cast
   20: 
   21: import numpy as np
   22: import pytest
   23: 
   24: import pandas as pd
   25: import pandas._testing as tm
   26: from pandas.api.types import is_string_dtype
   27: from pandas.core.arrays import ArrowStringArray
   28: from pandas.core.arrays.string_ import StringDtype
   29: from pandas.tests.extension import base
   30: 
   31: 
   32: def maybe_split_array(arr, chunked):
   33:     if not chunked:
   34:         return arr
   35:     elif arr.dtype.storage != "pyarrow":
   36:         return arr
   37: 
   38:     pa = pytest.importorskip("pyarrow")
   39: 
   40:     arrow_array = arr._pa_array
   41:     split = len(arrow_array) // 2
   42:     arrow_array = pa.chunked_array(
   43:         [*arrow_array[:split].chunks, *arrow_array[split:].chunks]
   44:     )
   45:     assert arrow_array.num_chunks == 2
   46:     return type(arr)(arrow_array)
   47: 
   48: 
   49: @pytest.fixture(params=[True, False])
   50: def chunked(request):
   51:     return request.param
   52: 
   53: 
   54: @pytest.fixture
   55: def dtype(string_storage):
   56:     return StringDtype(storage=string_storage)
   57: 
   58: 
   59: @pytest.fixture
   60: def data(dtype, chunked):
   61:     strings = np.random.default_rng(2).choice(list(string.ascii_letters), size=100)
   62:     while strings[0] == strings[1]:
   63:         strings = np.random.default_rng(2).choice(list(string.ascii_letters), size=100)
   64: 
   65:     arr = dtype.construct_array_type()._from_sequence(strings, dtype=dtype)
   66:     return maybe_split_array(arr, chunked)
   67: 
   68: 
   69: @pytest.fixture
   70: def data_missing(dtype, chunked):
   71:     """Length 2 array with [NA, Valid]"""
   72:     arr = dtype.construct_array_type()._from_sequence([pd.NA, "A"], dtype=dtype)
   73:     return maybe_split_array(arr, chunked)
   74: 
   75: 
   76: @pytest.fixture
   77: def data_for_sorting(dtype, chunked):
   78:     arr = dtype.construct_array_type()._from_sequence(["B", "C", "A"], dtype=dtype)
   79:     return maybe_split_array(arr, chunked)
   80: 
   81: 
   82: @pytest.fixture
   83: def data_missing_for_sorting(dtype, chunked):
   84:     arr = dtype.construct_array_type()._from_sequence(["B", pd.NA, "A"], dtype=dtype)
   85:     return maybe_split_array(arr, chunked)
   86: 
   87: 
   88: @pytest.fixture
   89: def data_for_grouping(dtype, chunked):
   90:     arr = dtype.construct_array_type()._from_sequence(
   91:         ["B", "B", pd.NA, pd.NA, "A", "A", "B", "C"], dtype=dtype
   92:     )
   93:     return maybe_split_array(arr, chunked)
   94: 
   95: 
   96: class TestStringArray(base.ExtensionTests):
   97:     def test_eq_with_str(self, dtype):
   98:         assert dtype == f"string[{dtype.storage}]"
   99:         super().test_eq_with_str(dtype)
  100: 
  101:     def test_is_not_string_type(self, dtype):
  102:         # Different from BaseDtypeTests.test_is_not_string_type
  103:         # because StringDtype is a string type
  104:         assert is_string_dtype(dtype)
  105: 
  106:     def test_view(self, data, request, arrow_string_storage):
  107:         if data.dtype.storage in arrow_string_storage:
  108:             pytest.skip(reason="2D support not implemented for ArrowStringArray")
  109:         super().test_view(data)
  110: 
  111:     def test_from_dtype(self, data):
  112:         # base test uses string representation of dtype
  113:         pass
  114: 
  115:     def test_transpose(self, data, request, arrow_string_storage):
  116:         if data.dtype.storage in arrow_string_storage:
  117:             pytest.skip(reason="2D support not implemented for ArrowStringArray")
  118:         super().test_transpose(data)
  119: 
  120:     def test_setitem_preserves_views(self, data, request, arrow_string_storage):
  121:         if data.dtype.storage in arrow_string_storage:
  122:             pytest.skip(reason="2D support not implemented for ArrowStringArray")
  123:         super().test_setitem_preserves_views(data)
  124: 
  125:     def test_dropna_array(self, data_missing):
  126:         result = data_missing.dropna()
  127:         expected = data_missing[[1]]
  128:         tm.assert_extension_array_equal(result, expected)
  129: 
  130:     def test_fillna_no_op_returns_copy(self, data):
  131:         data = data[~data.isna()]
  132: 
  133:         valid = data[0]
  134:         result = data.fillna(valid)
  135:         assert result is not data
  136:         tm.assert_extension_array_equal(result, data)
  137: 
  138:         result = data.fillna(method="backfill")
  139:         assert result is not data
  140:         tm.assert_extension_array_equal(result, data)
  141: 
  142:     def _get_expected_exception(
  143:         self, op_name: str, obj, other
  144:     ) -> type[Exception] | None:
  145:         if op_name in ["__divmod__", "__rdivmod__"]:
  146:             if isinstance(obj, pd.Series) and cast(
  147:                 StringDtype, tm.get_dtype(obj)
  148:             ).storage in [
  149:                 "pyarrow",
  150:                 "pyarrow_numpy",
  151:             ]:
  152:                 # TODO: re-raise as TypeError?
  153:                 return NotImplementedError
  154:             elif isinstance(other, pd.Series) and cast(
  155:                 StringDtype, tm.get_dtype(other)
  156:             ).storage in [
  157:                 "pyarrow",
  158:                 "pyarrow_numpy",
  159:             ]:
  160:                 # TODO: re-raise as TypeError?
  161:                 return NotImplementedError
  162:             return TypeError
  163:         elif op_name in ["__mod__", "__rmod__", "__pow__", "__rpow__"]:
  164:             if cast(StringDtype, tm.get_dtype(obj)).storage in [
  165:                 "pyarrow",
  166:                 "pyarrow_numpy",
  167:             ]:
  168:                 return NotImplementedError
  169:             return TypeError
  170:         elif op_name in ["__mul__", "__rmul__"]:
  171:             # Can only multiply strings by integers
  172:             return TypeError
  173:         elif op_name in [
  174:             "__truediv__",
  175:             "__rtruediv__",
  176:             "__floordiv__",
  177:             "__rfloordiv__",
  178:             "__sub__",
  179:             "__rsub__",
  180:         ]:
  181:             if cast(StringDtype, tm.get_dtype(obj)).storage in [
  182:                 "pyarrow",
  183:                 "pyarrow_numpy",
  184:             ]:
  185:                 import pyarrow as pa
  186: 
  187:                 # TODO: better to re-raise as TypeError?
  188:                 return pa.ArrowNotImplementedError
  189:             return TypeError
  190: 
  191:         return None
  192: 
  193:     def _supports_reduction(self, ser: pd.Series, op_name: str) -> bool:
  194:         return (
  195:             op_name in ["min", "max"]
  196:             or ser.dtype.storage == "pyarrow_numpy"  # type: ignore[union-attr]
  197:             and op_name in ("any", "all")
  198:         )
  199: 
  200:     def _cast_pointwise_result(self, op_name: str, obj, other, pointwise_result):
  201:         dtype = cast(StringDtype, tm.get_dtype(obj))
  202:         if op_name in ["__add__", "__radd__"]:
  203:             cast_to = dtype
  204:         elif dtype.storage == "pyarrow":
  205:             cast_to = "boolean[pyarrow]"  # type: ignore[assignment]
  206:         elif dtype.storage == "pyarrow_numpy":
  207:             cast_to = np.bool_  # type: ignore[assignment]
  208:         else:
  209:             cast_to = "boolean"  # type: ignore[assignment]
  210:         return pointwise_result.astype(cast_to)
  211: 
  212:     def test_compare_scalar(self, data, comparison_op):
  213:         ser = pd.Series(data)
  214:         self._compare_other(ser, data, comparison_op, "abc")
  215: 
  216:     @pytest.mark.filterwarnings("ignore:Falling back:pandas.errors.PerformanceWarning")
  217:     def test_groupby_extension_apply(self, data_for_grouping, groupby_apply_op):
  218:         super().test_groupby_extension_apply(data_for_grouping, groupby_apply_op)
  219: 
  220: 
  221: class Test2DCompat(base.Dim2CompatTests):
  222:     @pytest.fixture(autouse=True)
  223:     def arrow_not_supported(self, data):
  224:         if isinstance(data, ArrowStringArray):
  225:             pytest.skip(reason="2D support not implemented for ArrowStringArray")
  226: 
  227: 
  228: def test_searchsorted_with_na_raises(data_for_sorting, as_series):
  229:     # GH50447
  230:     b, c, a = data_for_sorting
  231:     arr = data_for_sorting.take([2, 0, 1])  # to get [a, b, c]
  232:     arr[-1] = pd.NA
  233: 
  234:     if as_series:
  235:         arr = pd.Series(arr)
  236: 
  237:     msg = (
  238:         "searchsorted requires array to be sorted, "
  239:         "which is impossible with NAs present."
  240:     )
  241:     with pytest.raises(ValueError, match=msg):
  242:         arr.searchsorted(b)
