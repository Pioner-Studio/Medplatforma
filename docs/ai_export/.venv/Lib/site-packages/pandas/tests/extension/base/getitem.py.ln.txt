    1: import numpy as np
    2: import pytest
    3: 
    4: import pandas as pd
    5: import pandas._testing as tm
    6: 
    7: 
    8: class BaseGetitemTests:
    9:     """Tests for ExtensionArray.__getitem__."""
   10: 
   11:     def test_iloc_series(self, data):
   12:         ser = pd.Series(data)
   13:         result = ser.iloc[:4]
   14:         expected = pd.Series(data[:4])
   15:         tm.assert_series_equal(result, expected)
   16: 
   17:         result = ser.iloc[[0, 1, 2, 3]]
   18:         tm.assert_series_equal(result, expected)
   19: 
   20:     def test_iloc_frame(self, data):
   21:         df = pd.DataFrame({"A": data, "B": np.arange(len(data), dtype="int64")})
   22:         expected = pd.DataFrame({"A": data[:4]})
   23: 
   24:         # slice -> frame
   25:         result = df.iloc[:4, [0]]
   26:         tm.assert_frame_equal(result, expected)
   27: 
   28:         # sequence -> frame
   29:         result = df.iloc[[0, 1, 2, 3], [0]]
   30:         tm.assert_frame_equal(result, expected)
   31: 
   32:         expected = pd.Series(data[:4], name="A")
   33: 
   34:         # slice -> series
   35:         result = df.iloc[:4, 0]
   36:         tm.assert_series_equal(result, expected)
   37: 
   38:         # sequence -> series
   39:         result = df.iloc[:4, 0]
   40:         tm.assert_series_equal(result, expected)
   41: 
   42:         # GH#32959 slice columns with step
   43:         result = df.iloc[:, ::2]
   44:         tm.assert_frame_equal(result, df[["A"]])
   45:         result = df[["B", "A"]].iloc[:, ::2]
   46:         tm.assert_frame_equal(result, df[["B"]])
   47: 
   48:     def test_iloc_frame_single_block(self, data):
   49:         # GH#32959 null slice along index, slice along columns with single-block
   50:         df = pd.DataFrame({"A": data})
   51: 
   52:         result = df.iloc[:, :]
   53:         tm.assert_frame_equal(result, df)
   54: 
   55:         result = df.iloc[:, :1]
   56:         tm.assert_frame_equal(result, df)
   57: 
   58:         result = df.iloc[:, :2]
   59:         tm.assert_frame_equal(result, df)
   60: 
   61:         result = df.iloc[:, ::2]
   62:         tm.assert_frame_equal(result, df)
   63: 
   64:         result = df.iloc[:, 1:2]
   65:         tm.assert_frame_equal(result, df.iloc[:, :0])
   66: 
   67:         result = df.iloc[:, -1:]
   68:         tm.assert_frame_equal(result, df)
   69: 
   70:     def test_loc_series(self, data):
   71:         ser = pd.Series(data)
   72:         result = ser.loc[:3]
   73:         expected = pd.Series(data[:4])
   74:         tm.assert_series_equal(result, expected)
   75: 
   76:         result = ser.loc[[0, 1, 2, 3]]
   77:         tm.assert_series_equal(result, expected)
   78: 
   79:     def test_loc_frame(self, data):
   80:         df = pd.DataFrame({"A": data, "B": np.arange(len(data), dtype="int64")})
   81:         expected = pd.DataFrame({"A": data[:4]})
   82: 
   83:         # slice -> frame
   84:         result = df.loc[:3, ["A"]]
   85:         tm.assert_frame_equal(result, expected)
   86: 
   87:         # sequence -> frame
   88:         result = df.loc[[0, 1, 2, 3], ["A"]]
   89:         tm.assert_frame_equal(result, expected)
   90: 
   91:         expected = pd.Series(data[:4], name="A")
   92: 
   93:         # slice -> series
   94:         result = df.loc[:3, "A"]
   95:         tm.assert_series_equal(result, expected)
   96: 
   97:         # sequence -> series
   98:         result = df.loc[:3, "A"]
   99:         tm.assert_series_equal(result, expected)
  100: 
  101:     def test_loc_iloc_frame_single_dtype(self, data):
  102:         # GH#27110 bug in ExtensionBlock.iget caused df.iloc[n] to incorrectly
  103:         #  return a scalar
  104:         df = pd.DataFrame({"A": data})
  105:         expected = pd.Series([data[2]], index=["A"], name=2, dtype=data.dtype)
  106: 
  107:         result = df.loc[2]
  108:         tm.assert_series_equal(result, expected)
  109: 
  110:         expected = pd.Series(
  111:             [data[-1]], index=["A"], name=len(data) - 1, dtype=data.dtype
  112:         )
  113:         result = df.iloc[-1]
  114:         tm.assert_series_equal(result, expected)
  115: 
  116:     def test_getitem_scalar(self, data):
  117:         result = data[0]
  118:         assert isinstance(result, data.dtype.type)
  119: 
  120:         result = pd.Series(data)[0]
  121:         assert isinstance(result, data.dtype.type)
  122: 
  123:     def test_getitem_invalid(self, data):
  124:         # TODO: box over scalar, [scalar], (scalar,)?
  125: 
  126:         msg = (
  127:             r"only integers, slices \(`:`\), ellipsis \(`...`\), numpy.newaxis "
  128:             r"\(`None`\) and integer or boolean arrays are valid indices"
  129:         )
  130:         with pytest.raises(IndexError, match=msg):
  131:             data["foo"]
  132:         with pytest.raises(IndexError, match=msg):
  133:             data[2.5]
  134: 
  135:         ub = len(data)
  136:         msg = "|".join(
  137:             [
  138:                 "list index out of range",  # json
  139:                 "index out of bounds",  # pyarrow
  140:                 "Out of bounds access",  # Sparse
  141:                 f"loc must be an integer between -{ub} and {ub}",  # Sparse
  142:                 f"index {ub+1} is out of bounds for axis 0 with size {ub}",
  143:                 f"index -{ub+1} is out of bounds for axis 0 with size {ub}",
  144:             ]
  145:         )
  146:         with pytest.raises(IndexError, match=msg):
  147:             data[ub + 1]
  148:         with pytest.raises(IndexError, match=msg):
  149:             data[-ub - 1]
  150: 
  151:     def test_getitem_scalar_na(self, data_missing, na_cmp, na_value):
  152:         result = data_missing[0]
  153:         assert na_cmp(result, na_value)
  154: 
  155:     def test_getitem_empty(self, data):
  156:         # Indexing with empty list
  157:         result = data[[]]
  158:         assert len(result) == 0
  159:         assert isinstance(result, type(data))
  160: 
  161:         expected = data[np.array([], dtype="int64")]
  162:         tm.assert_extension_array_equal(result, expected)
  163: 
  164:     def test_getitem_mask(self, data):
  165:         # Empty mask, raw array
  166:         mask = np.zeros(len(data), dtype=bool)
  167:         result = data[mask]
  168:         assert len(result) == 0
  169:         assert isinstance(result, type(data))
  170: 
  171:         # Empty mask, in series
  172:         mask = np.zeros(len(data), dtype=bool)
  173:         result = pd.Series(data)[mask]
  174:         assert len(result) == 0
  175:         assert result.dtype == data.dtype
  176: 
  177:         # non-empty mask, raw array
  178:         mask[0] = True
  179:         result = data[mask]
  180:         assert len(result) == 1
  181:         assert isinstance(result, type(data))
  182: 
  183:         # non-empty mask, in series
  184:         result = pd.Series(data)[mask]
  185:         assert len(result) == 1
  186:         assert result.dtype == data.dtype
  187: 
  188:     def test_getitem_mask_raises(self, data):
  189:         mask = np.array([True, False])
  190:         msg = f"Boolean index has wrong length: 2 instead of {len(data)}"
  191:         with pytest.raises(IndexError, match=msg):
  192:             data[mask]
  193: 
  194:         mask = pd.array(mask, dtype="boolean")
  195:         with pytest.raises(IndexError, match=msg):
  196:             data[mask]
  197: 
  198:     def test_getitem_boolean_array_mask(self, data):
  199:         mask = pd.array(np.zeros(data.shape, dtype="bool"), dtype="boolean")
  200:         result = data[mask]
  201:         assert len(result) == 0
  202:         assert isinstance(result, type(data))
  203: 
  204:         result = pd.Series(data)[mask]
  205:         assert len(result) == 0
  206:         assert result.dtype == data.dtype
  207: 
  208:         mask[:5] = True
  209:         expected = data.take([0, 1, 2, 3, 4])
  210:         result = data[mask]
  211:         tm.assert_extension_array_equal(result, expected)
  212: 
  213:         expected = pd.Series(expected)
  214:         result = pd.Series(data)[mask]
  215:         tm.assert_series_equal(result, expected)
  216: 
  217:     def test_getitem_boolean_na_treated_as_false(self, data):
  218:         # https://github.com/pandas-dev/pandas/issues/31503
  219:         mask = pd.array(np.zeros(data.shape, dtype="bool"), dtype="boolean")
  220:         mask[:2] = pd.NA
  221:         mask[2:4] = True
  222: 
  223:         result = data[mask]
  224:         expected = data[mask.fillna(False)]
  225: 
  226:         tm.assert_extension_array_equal(result, expected)
  227: 
  228:         s = pd.Series(data)
  229: 
  230:         result = s[mask]
  231:         expected = s[mask.fillna(False)]
  232: 
  233:         tm.assert_series_equal(result, expected)
  234: 
  235:     @pytest.mark.parametrize(
  236:         "idx",
  237:         [[0, 1, 2], pd.array([0, 1, 2], dtype="Int64"), np.array([0, 1, 2])],
  238:         ids=["list", "integer-array", "numpy-array"],
  239:     )
  240:     def test_getitem_integer_array(self, data, idx):
  241:         result = data[idx]
  242:         assert len(result) == 3
  243:         assert isinstance(result, type(data))
  244:         expected = data.take([0, 1, 2])
  245:         tm.assert_extension_array_equal(result, expected)
  246: 
  247:         expected = pd.Series(expected)
  248:         result = pd.Series(data)[idx]
  249:         tm.assert_series_equal(result, expected)
  250: 
  251:     @pytest.mark.parametrize(
  252:         "idx",
  253:         [[0, 1, 2, pd.NA], pd.array([0, 1, 2, pd.NA], dtype="Int64")],
  254:         ids=["list", "integer-array"],
  255:     )
  256:     def test_getitem_integer_with_missing_raises(self, data, idx):
  257:         msg = "Cannot index with an integer indexer containing NA values"
  258:         with pytest.raises(ValueError, match=msg):
  259:             data[idx]
  260: 
  261:     @pytest.mark.xfail(
  262:         reason="Tries label-based and raises KeyError; "
  263:         "in some cases raises when calling np.asarray"
  264:     )
  265:     @pytest.mark.parametrize(
  266:         "idx",
  267:         [[0, 1, 2, pd.NA], pd.array([0, 1, 2, pd.NA], dtype="Int64")],
  268:         ids=["list", "integer-array"],
  269:     )
  270:     def test_getitem_series_integer_with_missing_raises(self, data, idx):
  271:         msg = "Cannot index with an integer indexer containing NA values"
  272:         # TODO: this raises KeyError about labels not found (it tries label-based)
  273: 
  274:         ser = pd.Series(data, index=[chr(100 + i) for i in range(len(data))])
  275:         with pytest.raises(ValueError, match=msg):
  276:             ser[idx]
  277: 
  278:     def test_getitem_slice(self, data):
  279:         # getitem[slice] should return an array
  280:         result = data[slice(0)]  # empty
  281:         assert isinstance(result, type(data))
  282: 
  283:         result = data[slice(1)]  # scalar
  284:         assert isinstance(result, type(data))
  285: 
  286:     def test_getitem_ellipsis_and_slice(self, data):
  287:         # GH#40353 this is called from slice_block_rows
  288:         result = data[..., :]
  289:         tm.assert_extension_array_equal(result, data)
  290: 
  291:         result = data[:, ...]
  292:         tm.assert_extension_array_equal(result, data)
  293: 
  294:         result = data[..., :3]
  295:         tm.assert_extension_array_equal(result, data[:3])
  296: 
  297:         result = data[:3, ...]
  298:         tm.assert_extension_array_equal(result, data[:3])
  299: 
  300:         result = data[..., ::2]
  301:         tm.assert_extension_array_equal(result, data[::2])
  302: 
  303:         result = data[::2, ...]
  304:         tm.assert_extension_array_equal(result, data[::2])
  305: 
  306:     def test_get(self, data):
  307:         # GH 20882
  308:         s = pd.Series(data, index=[2 * i for i in range(len(data))])
  309:         assert s.get(4) == s.iloc[2]
  310: 
  311:         result = s.get([4, 6])
  312:         expected = s.iloc[[2, 3]]
  313:         tm.assert_series_equal(result, expected)
  314: 
  315:         result = s.get(slice(2))
  316:         expected = s.iloc[[0, 1]]
  317:         tm.assert_series_equal(result, expected)
  318: 
  319:         assert s.get(-1) is None
  320:         assert s.get(s.index.max() + 1) is None
  321: 
  322:         s = pd.Series(data[:6], index=list("abcdef"))
  323:         assert s.get("c") == s.iloc[2]
  324: 
  325:         result = s.get(slice("b", "d"))
  326:         expected = s.iloc[[1, 2, 3]]
  327:         tm.assert_series_equal(result, expected)
  328: 
  329:         result = s.get("Z")
  330:         assert result is None
  331: 
  332:         msg = "Series.__getitem__ treating keys as positions is deprecated"
  333:         with tm.assert_produces_warning(FutureWarning, match=msg):
  334:             assert s.get(4) == s.iloc[4]
  335:             assert s.get(-1) == s.iloc[-1]
  336:             assert s.get(len(s)) is None
  337: 
  338:         # GH 21257
  339:         s = pd.Series(data)
  340:         with tm.assert_produces_warning(None):
  341:             # GH#45324 make sure we aren't giving a spurious FutureWarning
  342:             s2 = s[::2]
  343:         assert s2.get(1) is None
  344: 
  345:     def test_take_sequence(self, data):
  346:         result = pd.Series(data)[[0, 1, 3]]
  347:         assert result.iloc[0] == data[0]
  348:         assert result.iloc[1] == data[1]
  349:         assert result.iloc[2] == data[3]
  350: 
  351:     def test_take(self, data, na_value, na_cmp):
  352:         result = data.take([0, -1])
  353:         assert result.dtype == data.dtype
  354:         assert result[0] == data[0]
  355:         assert result[1] == data[-1]
  356: 
  357:         result = data.take([0, -1], allow_fill=True, fill_value=na_value)
  358:         assert result[0] == data[0]
  359:         assert na_cmp(result[1], na_value)
  360: 
  361:         with pytest.raises(IndexError, match="out of bounds"):
  362:             data.take([len(data) + 1])
  363: 
  364:     def test_take_empty(self, data, na_value, na_cmp):
  365:         empty = data[:0]
  366: 
  367:         result = empty.take([-1], allow_fill=True)
  368:         assert na_cmp(result[0], na_value)
  369: 
  370:         msg = "cannot do a non-empty take from an empty axes|out of bounds"
  371: 
  372:         with pytest.raises(IndexError, match=msg):
  373:             empty.take([-1])
  374: 
  375:         with pytest.raises(IndexError, match="cannot do a non-empty take"):
  376:             empty.take([0, 1])
  377: 
  378:     def test_take_negative(self, data):
  379:         # https://github.com/pandas-dev/pandas/issues/20640
  380:         n = len(data)
  381:         result = data.take([0, -n, n - 1, -1])
  382:         expected = data.take([0, 0, n - 1, n - 1])
  383:         tm.assert_extension_array_equal(result, expected)
  384: 
  385:     def test_take_non_na_fill_value(self, data_missing):
  386:         fill_value = data_missing[1]  # valid
  387:         na = data_missing[0]
  388: 
  389:         arr = data_missing._from_sequence(
  390:             [na, fill_value, na], dtype=data_missing.dtype
  391:         )
  392:         result = arr.take([-1, 1], fill_value=fill_value, allow_fill=True)
  393:         expected = arr.take([1, 1])
  394:         tm.assert_extension_array_equal(result, expected)
  395: 
  396:     def test_take_pandas_style_negative_raises(self, data, na_value):
  397:         with pytest.raises(ValueError, match=""):
  398:             data.take([0, -2], fill_value=na_value, allow_fill=True)
  399: 
  400:     @pytest.mark.parametrize("allow_fill", [True, False])
  401:     def test_take_out_of_bounds_raises(self, data, allow_fill):
  402:         arr = data[:3]
  403: 
  404:         with pytest.raises(IndexError, match="out of bounds|out-of-bounds"):
  405:             arr.take(np.asarray([0, 3]), allow_fill=allow_fill)
  406: 
  407:     def test_take_series(self, data):
  408:         s = pd.Series(data)
  409:         result = s.take([0, -1])
  410:         expected = pd.Series(
  411:             data._from_sequence([data[0], data[len(data) - 1]], dtype=s.dtype),
  412:             index=[0, len(data) - 1],
  413:         )
  414:         tm.assert_series_equal(result, expected)
  415: 
  416:     def test_reindex(self, data, na_value):
  417:         s = pd.Series(data)
  418:         result = s.reindex([0, 1, 3])
  419:         expected = pd.Series(data.take([0, 1, 3]), index=[0, 1, 3])
  420:         tm.assert_series_equal(result, expected)
  421: 
  422:         n = len(data)
  423:         result = s.reindex([-1, 0, n])
  424:         expected = pd.Series(
  425:             data._from_sequence([na_value, data[0], na_value], dtype=s.dtype),
  426:             index=[-1, 0, n],
  427:         )
  428:         tm.assert_series_equal(result, expected)
  429: 
  430:         result = s.reindex([n, n + 1])
  431:         expected = pd.Series(
  432:             data._from_sequence([na_value, na_value], dtype=s.dtype), index=[n, n + 1]
  433:         )
  434:         tm.assert_series_equal(result, expected)
  435: 
  436:     def test_reindex_non_na_fill_value(self, data_missing):
  437:         valid = data_missing[1]
  438:         na = data_missing[0]
  439: 
  440:         arr = data_missing._from_sequence([na, valid], dtype=data_missing.dtype)
  441:         ser = pd.Series(arr)
  442:         result = ser.reindex([0, 1, 2], fill_value=valid)
  443:         expected = pd.Series(
  444:             data_missing._from_sequence([na, valid, valid], dtype=data_missing.dtype)
  445:         )
  446: 
  447:         tm.assert_series_equal(result, expected)
  448: 
  449:     def test_loc_len1(self, data):
  450:         # see GH-27785 take_nd with indexer of len 1 resulting in wrong ndim
  451:         df = pd.DataFrame({"A": data})
  452:         res = df.loc[[0], "A"]
  453:         assert res.ndim == 1
  454:         assert res._mgr.arrays[0].ndim == 1
  455:         if hasattr(res._mgr, "blocks"):
  456:             assert res._mgr._block.ndim == 1
  457: 
  458:     def test_item(self, data):
  459:         # https://github.com/pandas-dev/pandas/pull/30175
  460:         s = pd.Series(data)
  461:         result = s[:1].item()
  462:         assert result == data[0]
  463: 
  464:         msg = "can only convert an array of size 1 to a Python scalar"
  465:         with pytest.raises(ValueError, match=msg):
  466:             s[:0].item()
  467: 
  468:         with pytest.raises(ValueError, match=msg):
  469:             s.item()
