    1: from __future__ import annotations
    2: 
    3: import decimal
    4: import operator
    5: 
    6: import numpy as np
    7: import pytest
    8: 
    9: import pandas as pd
   10: import pandas._testing as tm
   11: from pandas.tests.extension import base
   12: from pandas.tests.extension.decimal.array import (
   13:     DecimalArray,
   14:     DecimalDtype,
   15:     make_data,
   16:     to_decimal,
   17: )
   18: 
   19: 
   20: @pytest.fixture
   21: def dtype():
   22:     return DecimalDtype()
   23: 
   24: 
   25: @pytest.fixture
   26: def data():
   27:     return DecimalArray(make_data())
   28: 
   29: 
   30: @pytest.fixture
   31: def data_for_twos():
   32:     return DecimalArray([decimal.Decimal(2) for _ in range(100)])
   33: 
   34: 
   35: @pytest.fixture
   36: def data_missing():
   37:     return DecimalArray([decimal.Decimal("NaN"), decimal.Decimal(1)])
   38: 
   39: 
   40: @pytest.fixture
   41: def data_for_sorting():
   42:     return DecimalArray(
   43:         [decimal.Decimal("1"), decimal.Decimal("2"), decimal.Decimal("0")]
   44:     )
   45: 
   46: 
   47: @pytest.fixture
   48: def data_missing_for_sorting():
   49:     return DecimalArray(
   50:         [decimal.Decimal("1"), decimal.Decimal("NaN"), decimal.Decimal("0")]
   51:     )
   52: 
   53: 
   54: @pytest.fixture
   55: def na_cmp():
   56:     return lambda x, y: x.is_nan() and y.is_nan()
   57: 
   58: 
   59: @pytest.fixture
   60: def data_for_grouping():
   61:     b = decimal.Decimal("1.0")
   62:     a = decimal.Decimal("0.0")
   63:     c = decimal.Decimal("2.0")
   64:     na = decimal.Decimal("NaN")
   65:     return DecimalArray([b, b, na, na, a, a, b, c])
   66: 
   67: 
   68: class TestDecimalArray(base.ExtensionTests):
   69:     def _get_expected_exception(
   70:         self, op_name: str, obj, other
   71:     ) -> type[Exception] | None:
   72:         return None
   73: 
   74:     def _supports_reduction(self, ser: pd.Series, op_name: str) -> bool:
   75:         return True
   76: 
   77:     def check_reduce(self, ser: pd.Series, op_name: str, skipna: bool):
   78:         if op_name == "count":
   79:             return super().check_reduce(ser, op_name, skipna)
   80:         else:
   81:             result = getattr(ser, op_name)(skipna=skipna)
   82:             expected = getattr(np.asarray(ser), op_name)()
   83:             tm.assert_almost_equal(result, expected)
   84: 
   85:     def test_reduce_series_numeric(self, data, all_numeric_reductions, skipna, request):
   86:         if all_numeric_reductions in ["kurt", "skew", "sem", "median"]:
   87:             mark = pytest.mark.xfail(raises=NotImplementedError)
   88:             request.applymarker(mark)
   89:         super().test_reduce_series_numeric(data, all_numeric_reductions, skipna)
   90: 
   91:     def test_reduce_frame(self, data, all_numeric_reductions, skipna, request):
   92:         op_name = all_numeric_reductions
   93:         if op_name in ["skew", "median"]:
   94:             mark = pytest.mark.xfail(raises=NotImplementedError)
   95:             request.applymarker(mark)
   96: 
   97:         return super().test_reduce_frame(data, all_numeric_reductions, skipna)
   98: 
   99:     def test_compare_scalar(self, data, comparison_op):
  100:         ser = pd.Series(data)
  101:         self._compare_other(ser, data, comparison_op, 0.5)
  102: 
  103:     def test_compare_array(self, data, comparison_op):
  104:         ser = pd.Series(data)
  105: 
  106:         alter = np.random.default_rng(2).choice([-1, 0, 1], len(data))
  107:         # Randomly double, halve or keep same value
  108:         other = pd.Series(data) * [decimal.Decimal(pow(2.0, i)) for i in alter]
  109:         self._compare_other(ser, data, comparison_op, other)
  110: 
  111:     def test_arith_series_with_array(self, data, all_arithmetic_operators):
  112:         op_name = all_arithmetic_operators
  113:         ser = pd.Series(data)
  114: 
  115:         context = decimal.getcontext()
  116:         divbyzerotrap = context.traps[decimal.DivisionByZero]
  117:         invalidoptrap = context.traps[decimal.InvalidOperation]
  118:         context.traps[decimal.DivisionByZero] = 0
  119:         context.traps[decimal.InvalidOperation] = 0
  120: 
  121:         # Decimal supports ops with int, but not float
  122:         other = pd.Series([int(d * 100) for d in data])
  123:         self.check_opname(ser, op_name, other)
  124: 
  125:         if "mod" not in op_name:
  126:             self.check_opname(ser, op_name, ser * 2)
  127: 
  128:         self.check_opname(ser, op_name, 0)
  129:         self.check_opname(ser, op_name, 5)
  130:         context.traps[decimal.DivisionByZero] = divbyzerotrap
  131:         context.traps[decimal.InvalidOperation] = invalidoptrap
  132: 
  133:     def test_fillna_frame(self, data_missing):
  134:         msg = "ExtensionArray.fillna added a 'copy' keyword"
  135:         with tm.assert_produces_warning(
  136:             DeprecationWarning, match=msg, check_stacklevel=False
  137:         ):
  138:             super().test_fillna_frame(data_missing)
  139: 
  140:     def test_fillna_limit_pad(self, data_missing):
  141:         msg = "ExtensionArray.fillna 'method' keyword is deprecated"
  142:         with tm.assert_produces_warning(
  143:             DeprecationWarning,
  144:             match=msg,
  145:             check_stacklevel=False,
  146:             raise_on_extra_warnings=False,
  147:         ):
  148:             super().test_fillna_limit_pad(data_missing)
  149: 
  150:         msg = "The 'method' keyword in DecimalArray.fillna is deprecated"
  151:         with tm.assert_produces_warning(
  152:             FutureWarning,
  153:             match=msg,
  154:             check_stacklevel=False,
  155:             raise_on_extra_warnings=False,
  156:         ):
  157:             super().test_fillna_limit_pad(data_missing)
  158: 
  159:     @pytest.mark.parametrize(
  160:         "limit_area, input_ilocs, expected_ilocs",
  161:         [
  162:             ("outside", [1, 0, 0, 0, 1], [1, 0, 0, 0, 1]),
  163:             ("outside", [1, 0, 1, 0, 1], [1, 0, 1, 0, 1]),
  164:             ("outside", [0, 1, 1, 1, 0], [0, 1, 1, 1, 1]),
  165:             ("outside", [0, 1, 0, 1, 0], [0, 1, 0, 1, 1]),
  166:             ("inside", [1, 0, 0, 0, 1], [1, 1, 1, 1, 1]),
  167:             ("inside", [1, 0, 1, 0, 1], [1, 1, 1, 1, 1]),
  168:             ("inside", [0, 1, 1, 1, 0], [0, 1, 1, 1, 0]),
  169:             ("inside", [0, 1, 0, 1, 0], [0, 1, 1, 1, 0]),
  170:         ],
  171:     )
  172:     def test_ffill_limit_area(
  173:         self, data_missing, limit_area, input_ilocs, expected_ilocs
  174:     ):
  175:         # GH#56616
  176:         msg = "ExtensionArray.fillna 'method' keyword is deprecated"
  177:         with tm.assert_produces_warning(
  178:             DeprecationWarning,
  179:             match=msg,
  180:             check_stacklevel=False,
  181:             raise_on_extra_warnings=False,
  182:         ):
  183:             msg = "DecimalArray does not implement limit_area"
  184:             with pytest.raises(NotImplementedError, match=msg):
  185:                 super().test_ffill_limit_area(
  186:                     data_missing, limit_area, input_ilocs, expected_ilocs
  187:                 )
  188: 
  189:     def test_fillna_limit_backfill(self, data_missing):
  190:         msg = "Series.fillna with 'method' is deprecated"
  191:         with tm.assert_produces_warning(
  192:             FutureWarning,
  193:             match=msg,
  194:             check_stacklevel=False,
  195:             raise_on_extra_warnings=False,
  196:         ):
  197:             super().test_fillna_limit_backfill(data_missing)
  198: 
  199:         msg = "ExtensionArray.fillna 'method' keyword is deprecated"
  200:         with tm.assert_produces_warning(
  201:             DeprecationWarning,
  202:             match=msg,
  203:             check_stacklevel=False,
  204:             raise_on_extra_warnings=False,
  205:         ):
  206:             super().test_fillna_limit_backfill(data_missing)
  207: 
  208:         msg = "The 'method' keyword in DecimalArray.fillna is deprecated"
  209:         with tm.assert_produces_warning(
  210:             FutureWarning,
  211:             match=msg,
  212:             check_stacklevel=False,
  213:             raise_on_extra_warnings=False,
  214:         ):
  215:             super().test_fillna_limit_backfill(data_missing)
  216: 
  217:     def test_fillna_no_op_returns_copy(self, data):
  218:         msg = "|".join(
  219:             [
  220:                 "ExtensionArray.fillna 'method' keyword is deprecated",
  221:                 "The 'method' keyword in DecimalArray.fillna is deprecated",
  222:             ]
  223:         )
  224:         with tm.assert_produces_warning(
  225:             (FutureWarning, DeprecationWarning), match=msg, check_stacklevel=False
  226:         ):
  227:             super().test_fillna_no_op_returns_copy(data)
  228: 
  229:     def test_fillna_series(self, data_missing):
  230:         msg = "ExtensionArray.fillna added a 'copy' keyword"
  231:         with tm.assert_produces_warning(
  232:             DeprecationWarning, match=msg, check_stacklevel=False
  233:         ):
  234:             super().test_fillna_series(data_missing)
  235: 
  236:     def test_fillna_series_method(self, data_missing, fillna_method):
  237:         msg = "|".join(
  238:             [
  239:                 "ExtensionArray.fillna 'method' keyword is deprecated",
  240:                 "The 'method' keyword in DecimalArray.fillna is deprecated",
  241:             ]
  242:         )
  243:         with tm.assert_produces_warning(
  244:             (FutureWarning, DeprecationWarning), match=msg, check_stacklevel=False
  245:         ):
  246:             super().test_fillna_series_method(data_missing, fillna_method)
  247: 
  248:     def test_fillna_copy_frame(self, data_missing, using_copy_on_write):
  249:         warn = DeprecationWarning if not using_copy_on_write else None
  250:         msg = "ExtensionArray.fillna added a 'copy' keyword"
  251:         with tm.assert_produces_warning(warn, match=msg, check_stacklevel=False):
  252:             super().test_fillna_copy_frame(data_missing)
  253: 
  254:     def test_fillna_copy_series(self, data_missing, using_copy_on_write):
  255:         warn = DeprecationWarning if not using_copy_on_write else None
  256:         msg = "ExtensionArray.fillna added a 'copy' keyword"
  257:         with tm.assert_produces_warning(warn, match=msg, check_stacklevel=False):
  258:             super().test_fillna_copy_series(data_missing)
  259: 
  260:     @pytest.mark.parametrize("dropna", [True, False])
  261:     def test_value_counts(self, all_data, dropna, request):
  262:         all_data = all_data[:10]
  263:         if dropna:
  264:             other = np.array(all_data[~all_data.isna()])
  265:         else:
  266:             other = all_data
  267: 
  268:         vcs = pd.Series(all_data).value_counts(dropna=dropna)
  269:         vcs_ex = pd.Series(other).value_counts(dropna=dropna)
  270: 
  271:         with decimal.localcontext() as ctx:
  272:             # avoid raising when comparing Decimal("NAN") < Decimal(2)
  273:             ctx.traps[decimal.InvalidOperation] = False
  274: 
  275:             result = vcs.sort_index()
  276:             expected = vcs_ex.sort_index()
  277: 
  278:         tm.assert_series_equal(result, expected)
  279: 
  280:     def test_series_repr(self, data):
  281:         # Overriding this base test to explicitly test that
  282:         # the custom _formatter is used
  283:         ser = pd.Series(data)
  284:         assert data.dtype.name in repr(ser)
  285:         assert "Decimal: " in repr(ser)
  286: 
  287:     @pytest.mark.xfail(reason="Inconsistent array-vs-scalar behavior")
  288:     @pytest.mark.parametrize("ufunc", [np.positive, np.negative, np.abs])
  289:     def test_unary_ufunc_dunder_equivalence(self, data, ufunc):
  290:         super().test_unary_ufunc_dunder_equivalence(data, ufunc)
  291: 
  292: 
  293: def test_take_na_value_other_decimal():
  294:     arr = DecimalArray([decimal.Decimal("1.0"), decimal.Decimal("2.0")])
  295:     result = arr.take([0, -1], allow_fill=True, fill_value=decimal.Decimal("-1.0"))
  296:     expected = DecimalArray([decimal.Decimal("1.0"), decimal.Decimal("-1.0")])
  297:     tm.assert_extension_array_equal(result, expected)
  298: 
  299: 
  300: def test_series_constructor_coerce_data_to_extension_dtype():
  301:     dtype = DecimalDtype()
  302:     ser = pd.Series([0, 1, 2], dtype=dtype)
  303: 
  304:     arr = DecimalArray(
  305:         [decimal.Decimal(0), decimal.Decimal(1), decimal.Decimal(2)],
  306:         dtype=dtype,
  307:     )
  308:     exp = pd.Series(arr)
  309:     tm.assert_series_equal(ser, exp)
  310: 
  311: 
  312: def test_series_constructor_with_dtype():
  313:     arr = DecimalArray([decimal.Decimal("10.0")])
  314:     result = pd.Series(arr, dtype=DecimalDtype())
  315:     expected = pd.Series(arr)
  316:     tm.assert_series_equal(result, expected)
  317: 
  318:     result = pd.Series(arr, dtype="int64")
  319:     expected = pd.Series([10])
  320:     tm.assert_series_equal(result, expected)
  321: 
  322: 
  323: def test_dataframe_constructor_with_dtype():
  324:     arr = DecimalArray([decimal.Decimal("10.0")])
  325: 
  326:     result = pd.DataFrame({"A": arr}, dtype=DecimalDtype())
  327:     expected = pd.DataFrame({"A": arr})
  328:     tm.assert_frame_equal(result, expected)
  329: 
  330:     arr = DecimalArray([decimal.Decimal("10.0")])
  331:     result = pd.DataFrame({"A": arr}, dtype="int64")
  332:     expected = pd.DataFrame({"A": [10]})
  333:     tm.assert_frame_equal(result, expected)
  334: 
  335: 
  336: @pytest.mark.parametrize("frame", [True, False])
  337: def test_astype_dispatches(frame):
  338:     # This is a dtype-specific test that ensures Series[decimal].astype
  339:     # gets all the way through to ExtensionArray.astype
  340:     # Designing a reliable smoke test that works for arbitrary data types
  341:     # is difficult.
  342:     data = pd.Series(DecimalArray([decimal.Decimal(2)]), name="a")
  343:     ctx = decimal.Context()
  344:     ctx.prec = 5
  345: 
  346:     if frame:
  347:         data = data.to_frame()
  348: 
  349:     result = data.astype(DecimalDtype(ctx))
  350: 
  351:     if frame:
  352:         result = result["a"]
  353: 
  354:     assert result.dtype.context.prec == ctx.prec
  355: 
  356: 
  357: class DecimalArrayWithoutFromSequence(DecimalArray):
  358:     """Helper class for testing error handling in _from_sequence."""
  359: 
  360:     @classmethod
  361:     def _from_sequence(cls, scalars, *, dtype=None, copy=False):
  362:         raise KeyError("For the test")
  363: 
  364: 
  365: class DecimalArrayWithoutCoercion(DecimalArrayWithoutFromSequence):
  366:     @classmethod
  367:     def _create_arithmetic_method(cls, op):
  368:         return cls._create_method(op, coerce_to_dtype=False)
  369: 
  370: 
  371: DecimalArrayWithoutCoercion._add_arithmetic_ops()
  372: 
  373: 
  374: def test_combine_from_sequence_raises(monkeypatch):
  375:     # https://github.com/pandas-dev/pandas/issues/22850
  376:     cls = DecimalArrayWithoutFromSequence
  377: 
  378:     @classmethod
  379:     def construct_array_type(cls):
  380:         return DecimalArrayWithoutFromSequence
  381: 
  382:     monkeypatch.setattr(DecimalDtype, "construct_array_type", construct_array_type)
  383: 
  384:     arr = cls([decimal.Decimal("1.0"), decimal.Decimal("2.0")])
  385:     ser = pd.Series(arr)
  386:     result = ser.combine(ser, operator.add)
  387: 
  388:     # note: object dtype
  389:     expected = pd.Series(
  390:         [decimal.Decimal("2.0"), decimal.Decimal("4.0")], dtype="object"
  391:     )
  392:     tm.assert_series_equal(result, expected)
  393: 
  394: 
  395: @pytest.mark.parametrize(
  396:     "class_", [DecimalArrayWithoutFromSequence, DecimalArrayWithoutCoercion]
  397: )
  398: def test_scalar_ops_from_sequence_raises(class_):
  399:     # op(EA, EA) should return an EA, or an ndarray if it's not possible
  400:     # to return an EA with the return values.
  401:     arr = class_([decimal.Decimal("1.0"), decimal.Decimal("2.0")])
  402:     result = arr + arr
  403:     expected = np.array(
  404:         [decimal.Decimal("2.0"), decimal.Decimal("4.0")], dtype="object"
  405:     )
  406:     tm.assert_numpy_array_equal(result, expected)
  407: 
  408: 
  409: @pytest.mark.parametrize(
  410:     "reverse, expected_div, expected_mod",
  411:     [(False, [0, 1, 1, 2], [1, 0, 1, 0]), (True, [2, 1, 0, 0], [0, 0, 2, 2])],
  412: )
  413: def test_divmod_array(reverse, expected_div, expected_mod):
  414:     # https://github.com/pandas-dev/pandas/issues/22930
  415:     arr = to_decimal([1, 2, 3, 4])
  416:     if reverse:
  417:         div, mod = divmod(2, arr)
  418:     else:
  419:         div, mod = divmod(arr, 2)
  420:     expected_div = to_decimal(expected_div)
  421:     expected_mod = to_decimal(expected_mod)
  422: 
  423:     tm.assert_extension_array_equal(div, expected_div)
  424:     tm.assert_extension_array_equal(mod, expected_mod)
  425: 
  426: 
  427: def test_ufunc_fallback(data):
  428:     a = data[:5]
  429:     s = pd.Series(a, index=range(3, 8))
  430:     result = np.abs(s)
  431:     expected = pd.Series(np.abs(a), index=range(3, 8))
  432:     tm.assert_series_equal(result, expected)
  433: 
  434: 
  435: def test_array_ufunc():
  436:     a = to_decimal([1, 2, 3])
  437:     result = np.exp(a)
  438:     expected = to_decimal(np.exp(a._data))
  439:     tm.assert_extension_array_equal(result, expected)
  440: 
  441: 
  442: def test_array_ufunc_series():
  443:     a = to_decimal([1, 2, 3])
  444:     s = pd.Series(a)
  445:     result = np.exp(s)
  446:     expected = pd.Series(to_decimal(np.exp(a._data)))
  447:     tm.assert_series_equal(result, expected)
  448: 
  449: 
  450: def test_array_ufunc_series_scalar_other():
  451:     # check _HANDLED_TYPES
  452:     a = to_decimal([1, 2, 3])
  453:     s = pd.Series(a)
  454:     result = np.add(s, decimal.Decimal(1))
  455:     expected = pd.Series(np.add(a, decimal.Decimal(1)))
  456:     tm.assert_series_equal(result, expected)
  457: 
  458: 
  459: def test_array_ufunc_series_defer():
  460:     a = to_decimal([1, 2, 3])
  461:     s = pd.Series(a)
  462: 
  463:     expected = pd.Series(to_decimal([2, 4, 6]))
  464:     r1 = np.add(s, a)
  465:     r2 = np.add(a, s)
  466: 
  467:     tm.assert_series_equal(r1, expected)
  468:     tm.assert_series_equal(r2, expected)
  469: 
  470: 
  471: def test_groupby_agg():
  472:     # Ensure that the result of agg is inferred to be decimal dtype
  473:     # https://github.com/pandas-dev/pandas/issues/29141
  474: 
  475:     data = make_data()[:5]
  476:     df = pd.DataFrame(
  477:         {"id1": [0, 0, 0, 1, 1], "id2": [0, 1, 0, 1, 1], "decimals": DecimalArray(data)}
  478:     )
  479: 
  480:     # single key, selected column
  481:     expected = pd.Series(to_decimal([data[0], data[3]]))
  482:     result = df.groupby("id1")["decimals"].agg(lambda x: x.iloc[0])
  483:     tm.assert_series_equal(result, expected, check_names=False)
  484:     result = df["decimals"].groupby(df["id1"]).agg(lambda x: x.iloc[0])
  485:     tm.assert_series_equal(result, expected, check_names=False)
  486: 
  487:     # multiple keys, selected column
  488:     expected = pd.Series(
  489:         to_decimal([data[0], data[1], data[3]]),
  490:         index=pd.MultiIndex.from_tuples([(0, 0), (0, 1), (1, 1)]),
  491:     )
  492:     result = df.groupby(["id1", "id2"])["decimals"].agg(lambda x: x.iloc[0])
  493:     tm.assert_series_equal(result, expected, check_names=False)
  494:     result = df["decimals"].groupby([df["id1"], df["id2"]]).agg(lambda x: x.iloc[0])
  495:     tm.assert_series_equal(result, expected, check_names=False)
  496: 
  497:     # multiple columns
  498:     expected = pd.DataFrame({"id2": [0, 1], "decimals": to_decimal([data[0], data[3]])})
  499:     result = df.groupby("id1").agg(lambda x: x.iloc[0])
  500:     tm.assert_frame_equal(result, expected, check_names=False)
  501: 
  502: 
  503: def test_groupby_agg_ea_method(monkeypatch):
  504:     # Ensure that the result of agg is inferred to be decimal dtype
  505:     # https://github.com/pandas-dev/pandas/issues/29141
  506: 
  507:     def DecimalArray__my_sum(self):
  508:         return np.sum(np.array(self))
  509: 
  510:     monkeypatch.setattr(DecimalArray, "my_sum", DecimalArray__my_sum, raising=False)
  511: 
  512:     data = make_data()[:5]
  513:     df = pd.DataFrame({"id": [0, 0, 0, 1, 1], "decimals": DecimalArray(data)})
  514:     expected = pd.Series(to_decimal([data[0] + data[1] + data[2], data[3] + data[4]]))
  515: 
  516:     result = df.groupby("id")["decimals"].agg(lambda x: x.values.my_sum())
  517:     tm.assert_series_equal(result, expected, check_names=False)
  518:     s = pd.Series(DecimalArray(data))
  519:     grouper = np.array([0, 0, 0, 1, 1], dtype=np.int64)
  520:     result = s.groupby(grouper).agg(lambda x: x.values.my_sum())
  521:     tm.assert_series_equal(result, expected, check_names=False)
  522: 
  523: 
  524: def test_indexing_no_materialize(monkeypatch):
  525:     # See https://github.com/pandas-dev/pandas/issues/29708
  526:     # Ensure that indexing operations do not materialize (convert to a numpy
  527:     # array) the ExtensionArray unnecessary
  528: 
  529:     def DecimalArray__array__(self, dtype=None):
  530:         raise Exception("tried to convert a DecimalArray to a numpy array")
  531: 
  532:     monkeypatch.setattr(DecimalArray, "__array__", DecimalArray__array__, raising=False)
  533: 
  534:     data = make_data()
  535:     s = pd.Series(DecimalArray(data))
  536:     df = pd.DataFrame({"a": s, "b": range(len(s))})
  537: 
  538:     # ensure the following operations do not raise an error
  539:     s[s > 0.5]
  540:     df[s > 0.5]
  541:     s.at[0]
  542:     df.at[0, "a"]
  543: 
  544: 
  545: def test_to_numpy_keyword():
  546:     # test the extra keyword
  547:     values = [decimal.Decimal("1.1111"), decimal.Decimal("2.2222")]
  548:     expected = np.array(
  549:         [decimal.Decimal("1.11"), decimal.Decimal("2.22")], dtype="object"
  550:     )
  551:     a = pd.array(values, dtype="decimal")
  552:     result = a.to_numpy(decimals=2)
  553:     tm.assert_numpy_array_equal(result, expected)
  554: 
  555:     result = pd.Series(a).to_numpy(decimals=2)
  556:     tm.assert_numpy_array_equal(result, expected)
  557: 
  558: 
  559: def test_array_copy_on_write(using_copy_on_write):
  560:     df = pd.DataFrame({"a": [decimal.Decimal(2), decimal.Decimal(3)]}, dtype="object")
  561:     df2 = df.astype(DecimalDtype())
  562:     df.iloc[0, 0] = 0
  563:     if using_copy_on_write:
  564:         expected = pd.DataFrame(
  565:             {"a": [decimal.Decimal(2), decimal.Decimal(3)]}, dtype=DecimalDtype()
  566:         )
  567:         tm.assert_equal(df2.values, expected.values)
