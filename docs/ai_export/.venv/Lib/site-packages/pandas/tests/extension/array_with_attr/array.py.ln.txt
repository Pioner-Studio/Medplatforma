    1: """
    2: Test extension array that has custom attribute information (not stored on the dtype).
    3: 
    4: """
    5: from __future__ import annotations
    6: 
    7: import numbers
    8: from typing import TYPE_CHECKING
    9: 
   10: import numpy as np
   11: 
   12: from pandas.core.dtypes.base import ExtensionDtype
   13: 
   14: import pandas as pd
   15: from pandas.core.arrays import ExtensionArray
   16: 
   17: if TYPE_CHECKING:
   18:     from pandas._typing import type_t
   19: 
   20: 
   21: class FloatAttrDtype(ExtensionDtype):
   22:     type = float
   23:     name = "float_attr"
   24:     na_value = np.nan
   25: 
   26:     @classmethod
   27:     def construct_array_type(cls) -> type_t[FloatAttrArray]:
   28:         """
   29:         Return the array type associated with this dtype.
   30: 
   31:         Returns
   32:         -------
   33:         type
   34:         """
   35:         return FloatAttrArray
   36: 
   37: 
   38: class FloatAttrArray(ExtensionArray):
   39:     dtype = FloatAttrDtype()
   40:     __array_priority__ = 1000
   41: 
   42:     def __init__(self, values, attr=None) -> None:
   43:         if not isinstance(values, np.ndarray):
   44:             raise TypeError("Need to pass a numpy array of float64 dtype as values")
   45:         if not values.dtype == "float64":
   46:             raise TypeError("Need to pass a numpy array of float64 dtype as values")
   47:         self.data = values
   48:         self.attr = attr
   49: 
   50:     @classmethod
   51:     def _from_sequence(cls, scalars, *, dtype=None, copy=False):
   52:         if not copy:
   53:             data = np.asarray(scalars, dtype="float64")
   54:         else:
   55:             data = np.array(scalars, dtype="float64", copy=copy)
   56:         return cls(data)
   57: 
   58:     def __getitem__(self, item):
   59:         if isinstance(item, numbers.Integral):
   60:             return self.data[item]
   61:         else:
   62:             # slice, list-like, mask
   63:             item = pd.api.indexers.check_array_indexer(self, item)
   64:             return type(self)(self.data[item], self.attr)
   65: 
   66:     def __len__(self) -> int:
   67:         return len(self.data)
   68: 
   69:     def isna(self):
   70:         return np.isnan(self.data)
   71: 
   72:     def take(self, indexer, allow_fill=False, fill_value=None):
   73:         from pandas.api.extensions import take
   74: 
   75:         data = self.data
   76:         if allow_fill and fill_value is None:
   77:             fill_value = self.dtype.na_value
   78: 
   79:         result = take(data, indexer, fill_value=fill_value, allow_fill=allow_fill)
   80:         return type(self)(result, self.attr)
   81: 
   82:     def copy(self):
   83:         return type(self)(self.data.copy(), self.attr)
   84: 
   85:     @classmethod
   86:     def _concat_same_type(cls, to_concat):
   87:         data = np.concatenate([x.data for x in to_concat])
   88:         attr = to_concat[0].attr if len(to_concat) else None
   89:         return cls(data, attr)
