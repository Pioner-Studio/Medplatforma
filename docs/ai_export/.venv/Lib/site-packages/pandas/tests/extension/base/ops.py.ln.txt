    1: from __future__ import annotations
    2: 
    3: from typing import final
    4: 
    5: import numpy as np
    6: import pytest
    7: 
    8: from pandas._config import using_pyarrow_string_dtype
    9: 
   10: from pandas.core.dtypes.common import is_string_dtype
   11: 
   12: import pandas as pd
   13: import pandas._testing as tm
   14: from pandas.core import ops
   15: 
   16: 
   17: class BaseOpsUtil:
   18:     series_scalar_exc: type[Exception] | None = TypeError
   19:     frame_scalar_exc: type[Exception] | None = TypeError
   20:     series_array_exc: type[Exception] | None = TypeError
   21:     divmod_exc: type[Exception] | None = TypeError
   22: 
   23:     def _get_expected_exception(
   24:         self, op_name: str, obj, other
   25:     ) -> type[Exception] | None:
   26:         # Find the Exception, if any we expect to raise calling
   27:         #  obj.__op_name__(other)
   28: 
   29:         # The self.obj_bar_exc pattern isn't great in part because it can depend
   30:         #  on op_name or dtypes, but we use it here for backward-compatibility.
   31:         if op_name in ["__divmod__", "__rdivmod__"]:
   32:             result = self.divmod_exc
   33:         elif isinstance(obj, pd.Series) and isinstance(other, pd.Series):
   34:             result = self.series_array_exc
   35:         elif isinstance(obj, pd.Series):
   36:             result = self.series_scalar_exc
   37:         else:
   38:             result = self.frame_scalar_exc
   39: 
   40:         if using_pyarrow_string_dtype() and result is not None:
   41:             import pyarrow as pa
   42: 
   43:             result = (  # type: ignore[assignment]
   44:                 result,
   45:                 pa.lib.ArrowNotImplementedError,
   46:                 NotImplementedError,
   47:             )
   48:         return result
   49: 
   50:     def _cast_pointwise_result(self, op_name: str, obj, other, pointwise_result):
   51:         # In _check_op we check that the result of a pointwise operation
   52:         #  (found via _combine) matches the result of the vectorized
   53:         #  operation obj.__op_name__(other).
   54:         #  In some cases pandas dtype inference on the scalar result may not
   55:         #  give a matching dtype even if both operations are behaving "correctly".
   56:         #  In these cases, do extra required casting here.
   57:         return pointwise_result
   58: 
   59:     def get_op_from_name(self, op_name: str):
   60:         return tm.get_op_from_name(op_name)
   61: 
   62:     # Subclasses are not expected to need to override check_opname, _check_op,
   63:     #  _check_divmod_op, or _combine.
   64:     #  Ideally any relevant overriding can be done in _cast_pointwise_result,
   65:     #  get_op_from_name, and the specification of `exc`. If you find a use
   66:     #  case that still requires overriding _check_op or _combine, please let
   67:     #  us know at github.com/pandas-dev/pandas/issues
   68:     @final
   69:     def check_opname(self, ser: pd.Series, op_name: str, other):
   70:         exc = self._get_expected_exception(op_name, ser, other)
   71:         op = self.get_op_from_name(op_name)
   72: 
   73:         self._check_op(ser, op, other, op_name, exc)
   74: 
   75:     # see comment on check_opname
   76:     @final
   77:     def _combine(self, obj, other, op):
   78:         if isinstance(obj, pd.DataFrame):
   79:             if len(obj.columns) != 1:
   80:                 raise NotImplementedError
   81:             expected = obj.iloc[:, 0].combine(other, op).to_frame()
   82:         else:
   83:             expected = obj.combine(other, op)
   84:         return expected
   85: 
   86:     # see comment on check_opname
   87:     @final
   88:     def _check_op(
   89:         self, ser: pd.Series, op, other, op_name: str, exc=NotImplementedError
   90:     ):
   91:         # Check that the Series/DataFrame arithmetic/comparison method matches
   92:         #  the pointwise result from _combine.
   93: 
   94:         if exc is None:
   95:             result = op(ser, other)
   96:             expected = self._combine(ser, other, op)
   97:             expected = self._cast_pointwise_result(op_name, ser, other, expected)
   98:             assert isinstance(result, type(ser))
   99:             tm.assert_equal(result, expected)
  100:         else:
  101:             with pytest.raises(exc):
  102:                 op(ser, other)
  103: 
  104:     # see comment on check_opname
  105:     @final
  106:     def _check_divmod_op(self, ser: pd.Series, op, other):
  107:         # check that divmod behavior matches behavior of floordiv+mod
  108:         if op is divmod:
  109:             exc = self._get_expected_exception("__divmod__", ser, other)
  110:         else:
  111:             exc = self._get_expected_exception("__rdivmod__", ser, other)
  112:         if exc is None:
  113:             result_div, result_mod = op(ser, other)
  114:             if op is divmod:
  115:                 expected_div, expected_mod = ser // other, ser % other
  116:             else:
  117:                 expected_div, expected_mod = other // ser, other % ser
  118:             tm.assert_series_equal(result_div, expected_div)
  119:             tm.assert_series_equal(result_mod, expected_mod)
  120:         else:
  121:             with pytest.raises(exc):
  122:                 divmod(ser, other)
  123: 
  124: 
  125: class BaseArithmeticOpsTests(BaseOpsUtil):
  126:     """
  127:     Various Series and DataFrame arithmetic ops methods.
  128: 
  129:     Subclasses supporting various ops should set the class variables
  130:     to indicate that they support ops of that kind
  131: 
  132:     * series_scalar_exc = TypeError
  133:     * frame_scalar_exc = TypeError
  134:     * series_array_exc = TypeError
  135:     * divmod_exc = TypeError
  136:     """
  137: 
  138:     series_scalar_exc: type[Exception] | None = TypeError
  139:     frame_scalar_exc: type[Exception] | None = TypeError
  140:     series_array_exc: type[Exception] | None = TypeError
  141:     divmod_exc: type[Exception] | None = TypeError
  142: 
  143:     def test_arith_series_with_scalar(self, data, all_arithmetic_operators):
  144:         # series & scalar
  145:         if all_arithmetic_operators == "__rmod__" and is_string_dtype(data.dtype):
  146:             pytest.skip("Skip testing Python string formatting")
  147: 
  148:         op_name = all_arithmetic_operators
  149:         ser = pd.Series(data)
  150:         self.check_opname(ser, op_name, ser.iloc[0])
  151: 
  152:     def test_arith_frame_with_scalar(self, data, all_arithmetic_operators):
  153:         # frame & scalar
  154:         if all_arithmetic_operators == "__rmod__" and is_string_dtype(data.dtype):
  155:             pytest.skip("Skip testing Python string formatting")
  156: 
  157:         op_name = all_arithmetic_operators
  158:         df = pd.DataFrame({"A": data})
  159:         self.check_opname(df, op_name, data[0])
  160: 
  161:     def test_arith_series_with_array(self, data, all_arithmetic_operators):
  162:         # ndarray & other series
  163:         op_name = all_arithmetic_operators
  164:         ser = pd.Series(data)
  165:         self.check_opname(ser, op_name, pd.Series([ser.iloc[0]] * len(ser)))
  166: 
  167:     def test_divmod(self, data):
  168:         ser = pd.Series(data)
  169:         self._check_divmod_op(ser, divmod, 1)
  170:         self._check_divmod_op(1, ops.rdivmod, ser)
  171: 
  172:     def test_divmod_series_array(self, data, data_for_twos):
  173:         ser = pd.Series(data)
  174:         self._check_divmod_op(ser, divmod, data)
  175: 
  176:         other = data_for_twos
  177:         self._check_divmod_op(other, ops.rdivmod, ser)
  178: 
  179:         other = pd.Series(other)
  180:         self._check_divmod_op(other, ops.rdivmod, ser)
  181: 
  182:     def test_add_series_with_extension_array(self, data):
  183:         # Check adding an ExtensionArray to a Series of the same dtype matches
  184:         # the behavior of adding the arrays directly and then wrapping in a
  185:         # Series.
  186: 
  187:         ser = pd.Series(data)
  188: 
  189:         exc = self._get_expected_exception("__add__", ser, data)
  190:         if exc is not None:
  191:             with pytest.raises(exc):
  192:                 ser + data
  193:             return
  194: 
  195:         result = ser + data
  196:         expected = pd.Series(data + data)
  197:         tm.assert_series_equal(result, expected)
  198: 
  199:     @pytest.mark.parametrize("box", [pd.Series, pd.DataFrame, pd.Index])
  200:     @pytest.mark.parametrize(
  201:         "op_name",
  202:         [
  203:             x
  204:             for x in tm.arithmetic_dunder_methods + tm.comparison_dunder_methods
  205:             if not x.startswith("__r")
  206:         ],
  207:     )
  208:     def test_direct_arith_with_ndframe_returns_not_implemented(
  209:         self, data, box, op_name
  210:     ):
  211:         # EAs should return NotImplemented for ops with Series/DataFrame/Index
  212:         # Pandas takes care of unboxing the series and calling the EA's op.
  213:         other = box(data)
  214: 
  215:         if hasattr(data, op_name):
  216:             result = getattr(data, op_name)(other)
  217:             assert result is NotImplemented
  218: 
  219: 
  220: class BaseComparisonOpsTests(BaseOpsUtil):
  221:     """Various Series and DataFrame comparison ops methods."""
  222: 
  223:     def _compare_other(self, ser: pd.Series, data, op, other):
  224:         if op.__name__ in ["eq", "ne"]:
  225:             # comparison should match point-wise comparisons
  226:             result = op(ser, other)
  227:             expected = ser.combine(other, op)
  228:             expected = self._cast_pointwise_result(op.__name__, ser, other, expected)
  229:             tm.assert_series_equal(result, expected)
  230: 
  231:         else:
  232:             exc = None
  233:             try:
  234:                 result = op(ser, other)
  235:             except Exception as err:
  236:                 exc = err
  237: 
  238:             if exc is None:
  239:                 # Didn't error, then should match pointwise behavior
  240:                 expected = ser.combine(other, op)
  241:                 expected = self._cast_pointwise_result(
  242:                     op.__name__, ser, other, expected
  243:                 )
  244:                 tm.assert_series_equal(result, expected)
  245:             else:
  246:                 with pytest.raises(type(exc)):
  247:                     ser.combine(other, op)
  248: 
  249:     def test_compare_scalar(self, data, comparison_op):
  250:         ser = pd.Series(data)
  251:         self._compare_other(ser, data, comparison_op, 0)
  252: 
  253:     def test_compare_array(self, data, comparison_op):
  254:         ser = pd.Series(data)
  255:         other = pd.Series([data[0]] * len(data), dtype=data.dtype)
  256:         self._compare_other(ser, data, comparison_op, other)
  257: 
  258: 
  259: class BaseUnaryOpsTests(BaseOpsUtil):
  260:     def test_invert(self, data):
  261:         ser = pd.Series(data, name="name")
  262:         try:
  263:             # 10 is an arbitrary choice here, just avoid iterating over
  264:             #  the whole array to trim test runtime
  265:             [~x for x in data[:10]]
  266:         except TypeError:
  267:             # scalars don't support invert -> we don't expect the vectorized
  268:             #  operation to succeed
  269:             with pytest.raises(TypeError):
  270:                 ~ser
  271:             with pytest.raises(TypeError):
  272:                 ~data
  273:         else:
  274:             # Note we do not reuse the pointwise result to construct expected
  275:             #  because python semantics for negating bools are weird see GH#54569
  276:             result = ~ser
  277:             expected = pd.Series(~data, name="name")
  278:             tm.assert_series_equal(result, expected)
  279: 
  280:     @pytest.mark.parametrize("ufunc", [np.positive, np.negative, np.abs])
  281:     def test_unary_ufunc_dunder_equivalence(self, data, ufunc):
  282:         # the dunder __pos__ works if and only if np.positive works,
  283:         #  same for __neg__/np.negative and __abs__/np.abs
  284:         attr = {np.positive: "__pos__", np.negative: "__neg__", np.abs: "__abs__"}[
  285:             ufunc
  286:         ]
  287: 
  288:         exc = None
  289:         try:
  290:             result = getattr(data, attr)()
  291:         except Exception as err:
  292:             exc = err
  293: 
  294:             # if __pos__ raised, then so should the ufunc
  295:             with pytest.raises((type(exc), TypeError)):
  296:                 ufunc(data)
  297:         else:
  298:             alt = ufunc(data)
  299:             tm.assert_extension_array_equal(result, alt)
