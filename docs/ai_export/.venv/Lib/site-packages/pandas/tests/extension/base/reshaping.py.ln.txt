    1: import itertools
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: import pandas as pd
    7: import pandas._testing as tm
    8: from pandas.api.extensions import ExtensionArray
    9: from pandas.core.internals.blocks import EABackedBlock
   10: 
   11: 
   12: class BaseReshapingTests:
   13:     """Tests for reshaping and concatenation."""
   14: 
   15:     @pytest.mark.parametrize("in_frame", [True, False])
   16:     def test_concat(self, data, in_frame):
   17:         wrapped = pd.Series(data)
   18:         if in_frame:
   19:             wrapped = pd.DataFrame(wrapped)
   20:         result = pd.concat([wrapped, wrapped], ignore_index=True)
   21: 
   22:         assert len(result) == len(data) * 2
   23: 
   24:         if in_frame:
   25:             dtype = result.dtypes[0]
   26:         else:
   27:             dtype = result.dtype
   28: 
   29:         assert dtype == data.dtype
   30:         if hasattr(result._mgr, "blocks"):
   31:             assert isinstance(result._mgr.blocks[0], EABackedBlock)
   32:         assert isinstance(result._mgr.arrays[0], ExtensionArray)
   33: 
   34:     @pytest.mark.parametrize("in_frame", [True, False])
   35:     def test_concat_all_na_block(self, data_missing, in_frame):
   36:         valid_block = pd.Series(data_missing.take([1, 1]), index=[0, 1])
   37:         na_block = pd.Series(data_missing.take([0, 0]), index=[2, 3])
   38:         if in_frame:
   39:             valid_block = pd.DataFrame({"a": valid_block})
   40:             na_block = pd.DataFrame({"a": na_block})
   41:         result = pd.concat([valid_block, na_block])
   42:         if in_frame:
   43:             expected = pd.DataFrame({"a": data_missing.take([1, 1, 0, 0])})
   44:             tm.assert_frame_equal(result, expected)
   45:         else:
   46:             expected = pd.Series(data_missing.take([1, 1, 0, 0]))
   47:             tm.assert_series_equal(result, expected)
   48: 
   49:     def test_concat_mixed_dtypes(self, data):
   50:         # https://github.com/pandas-dev/pandas/issues/20762
   51:         df1 = pd.DataFrame({"A": data[:3]})
   52:         df2 = pd.DataFrame({"A": [1, 2, 3]})
   53:         df3 = pd.DataFrame({"A": ["a", "b", "c"]}).astype("category")
   54:         dfs = [df1, df2, df3]
   55: 
   56:         # dataframes
   57:         result = pd.concat(dfs)
   58:         expected = pd.concat([x.astype(object) for x in dfs])
   59:         tm.assert_frame_equal(result, expected)
   60: 
   61:         # series
   62:         result = pd.concat([x["A"] for x in dfs])
   63:         expected = pd.concat([x["A"].astype(object) for x in dfs])
   64:         tm.assert_series_equal(result, expected)
   65: 
   66:         # simple test for just EA and one other
   67:         result = pd.concat([df1, df2.astype(object)])
   68:         expected = pd.concat([df1.astype("object"), df2.astype("object")])
   69:         tm.assert_frame_equal(result, expected)
   70: 
   71:         result = pd.concat([df1["A"], df2["A"].astype(object)])
   72:         expected = pd.concat([df1["A"].astype("object"), df2["A"].astype("object")])
   73:         tm.assert_series_equal(result, expected)
   74: 
   75:     def test_concat_columns(self, data, na_value):
   76:         df1 = pd.DataFrame({"A": data[:3]})
   77:         df2 = pd.DataFrame({"B": [1, 2, 3]})
   78: 
   79:         expected = pd.DataFrame({"A": data[:3], "B": [1, 2, 3]})
   80:         result = pd.concat([df1, df2], axis=1)
   81:         tm.assert_frame_equal(result, expected)
   82:         result = pd.concat([df1["A"], df2["B"]], axis=1)
   83:         tm.assert_frame_equal(result, expected)
   84: 
   85:         # non-aligned
   86:         df2 = pd.DataFrame({"B": [1, 2, 3]}, index=[1, 2, 3])
   87:         expected = pd.DataFrame(
   88:             {
   89:                 "A": data._from_sequence(list(data[:3]) + [na_value], dtype=data.dtype),
   90:                 "B": [np.nan, 1, 2, 3],
   91:             }
   92:         )
   93: 
   94:         result = pd.concat([df1, df2], axis=1)
   95:         tm.assert_frame_equal(result, expected)
   96:         result = pd.concat([df1["A"], df2["B"]], axis=1)
   97:         tm.assert_frame_equal(result, expected)
   98: 
   99:     def test_concat_extension_arrays_copy_false(self, data, na_value):
  100:         # GH 20756
  101:         df1 = pd.DataFrame({"A": data[:3]})
  102:         df2 = pd.DataFrame({"B": data[3:7]})
  103:         expected = pd.DataFrame(
  104:             {
  105:                 "A": data._from_sequence(list(data[:3]) + [na_value], dtype=data.dtype),
  106:                 "B": data[3:7],
  107:             }
  108:         )
  109:         result = pd.concat([df1, df2], axis=1, copy=False)
  110:         tm.assert_frame_equal(result, expected)
  111: 
  112:     def test_concat_with_reindex(self, data):
  113:         # GH-33027
  114:         a = pd.DataFrame({"a": data[:5]})
  115:         b = pd.DataFrame({"b": data[:5]})
  116:         result = pd.concat([a, b], ignore_index=True)
  117:         expected = pd.DataFrame(
  118:             {
  119:                 "a": data.take(list(range(5)) + ([-1] * 5), allow_fill=True),
  120:                 "b": data.take(([-1] * 5) + list(range(5)), allow_fill=True),
  121:             }
  122:         )
  123:         tm.assert_frame_equal(result, expected)
  124: 
  125:     def test_align(self, data, na_value):
  126:         a = data[:3]
  127:         b = data[2:5]
  128:         r1, r2 = pd.Series(a).align(pd.Series(b, index=[1, 2, 3]))
  129: 
  130:         # Assumes that the ctor can take a list of scalars of the type
  131:         e1 = pd.Series(data._from_sequence(list(a) + [na_value], dtype=data.dtype))
  132:         e2 = pd.Series(data._from_sequence([na_value] + list(b), dtype=data.dtype))
  133:         tm.assert_series_equal(r1, e1)
  134:         tm.assert_series_equal(r2, e2)
  135: 
  136:     def test_align_frame(self, data, na_value):
  137:         a = data[:3]
  138:         b = data[2:5]
  139:         r1, r2 = pd.DataFrame({"A": a}).align(pd.DataFrame({"A": b}, index=[1, 2, 3]))
  140: 
  141:         # Assumes that the ctor can take a list of scalars of the type
  142:         e1 = pd.DataFrame(
  143:             {"A": data._from_sequence(list(a) + [na_value], dtype=data.dtype)}
  144:         )
  145:         e2 = pd.DataFrame(
  146:             {"A": data._from_sequence([na_value] + list(b), dtype=data.dtype)}
  147:         )
  148:         tm.assert_frame_equal(r1, e1)
  149:         tm.assert_frame_equal(r2, e2)
  150: 
  151:     def test_align_series_frame(self, data, na_value):
  152:         # https://github.com/pandas-dev/pandas/issues/20576
  153:         ser = pd.Series(data, name="a")
  154:         df = pd.DataFrame({"col": np.arange(len(ser) + 1)})
  155:         r1, r2 = ser.align(df)
  156: 
  157:         e1 = pd.Series(
  158:             data._from_sequence(list(data) + [na_value], dtype=data.dtype),
  159:             name=ser.name,
  160:         )
  161: 
  162:         tm.assert_series_equal(r1, e1)
  163:         tm.assert_frame_equal(r2, df)
  164: 
  165:     def test_set_frame_expand_regular_with_extension(self, data):
  166:         df = pd.DataFrame({"A": [1] * len(data)})
  167:         df["B"] = data
  168:         expected = pd.DataFrame({"A": [1] * len(data), "B": data})
  169:         tm.assert_frame_equal(df, expected)
  170: 
  171:     def test_set_frame_expand_extension_with_regular(self, data):
  172:         df = pd.DataFrame({"A": data})
  173:         df["B"] = [1] * len(data)
  174:         expected = pd.DataFrame({"A": data, "B": [1] * len(data)})
  175:         tm.assert_frame_equal(df, expected)
  176: 
  177:     def test_set_frame_overwrite_object(self, data):
  178:         # https://github.com/pandas-dev/pandas/issues/20555
  179:         df = pd.DataFrame({"A": [1] * len(data)}, dtype=object)
  180:         df["A"] = data
  181:         assert df.dtypes["A"] == data.dtype
  182: 
  183:     def test_merge(self, data, na_value):
  184:         # GH-20743
  185:         df1 = pd.DataFrame({"ext": data[:3], "int1": [1, 2, 3], "key": [0, 1, 2]})
  186:         df2 = pd.DataFrame({"int2": [1, 2, 3, 4], "key": [0, 0, 1, 3]})
  187: 
  188:         res = pd.merge(df1, df2)
  189:         exp = pd.DataFrame(
  190:             {
  191:                 "int1": [1, 1, 2],
  192:                 "int2": [1, 2, 3],
  193:                 "key": [0, 0, 1],
  194:                 "ext": data._from_sequence(
  195:                     [data[0], data[0], data[1]], dtype=data.dtype
  196:                 ),
  197:             }
  198:         )
  199:         tm.assert_frame_equal(res, exp[["ext", "int1", "key", "int2"]])
  200: 
  201:         res = pd.merge(df1, df2, how="outer")
  202:         exp = pd.DataFrame(
  203:             {
  204:                 "int1": [1, 1, 2, 3, np.nan],
  205:                 "int2": [1, 2, 3, np.nan, 4],
  206:                 "key": [0, 0, 1, 2, 3],
  207:                 "ext": data._from_sequence(
  208:                     [data[0], data[0], data[1], data[2], na_value], dtype=data.dtype
  209:                 ),
  210:             }
  211:         )
  212:         tm.assert_frame_equal(res, exp[["ext", "int1", "key", "int2"]])
  213: 
  214:     def test_merge_on_extension_array(self, data):
  215:         # GH 23020
  216:         a, b = data[:2]
  217:         key = type(data)._from_sequence([a, b], dtype=data.dtype)
  218: 
  219:         df = pd.DataFrame({"key": key, "val": [1, 2]})
  220:         result = pd.merge(df, df, on="key")
  221:         expected = pd.DataFrame({"key": key, "val_x": [1, 2], "val_y": [1, 2]})
  222:         tm.assert_frame_equal(result, expected)
  223: 
  224:         # order
  225:         result = pd.merge(df.iloc[[1, 0]], df, on="key")
  226:         expected = expected.iloc[[1, 0]].reset_index(drop=True)
  227:         tm.assert_frame_equal(result, expected)
  228: 
  229:     def test_merge_on_extension_array_duplicates(self, data):
  230:         # GH 23020
  231:         a, b = data[:2]
  232:         key = type(data)._from_sequence([a, b, a], dtype=data.dtype)
  233:         df1 = pd.DataFrame({"key": key, "val": [1, 2, 3]})
  234:         df2 = pd.DataFrame({"key": key, "val": [1, 2, 3]})
  235: 
  236:         result = pd.merge(df1, df2, on="key")
  237:         expected = pd.DataFrame(
  238:             {
  239:                 "key": key.take([0, 0, 1, 2, 2]),
  240:                 "val_x": [1, 1, 2, 3, 3],
  241:                 "val_y": [1, 3, 2, 1, 3],
  242:             }
  243:         )
  244:         tm.assert_frame_equal(result, expected)
  245: 
  246:     @pytest.mark.filterwarnings(
  247:         "ignore:The previous implementation of stack is deprecated"
  248:     )
  249:     @pytest.mark.parametrize(
  250:         "columns",
  251:         [
  252:             ["A", "B"],
  253:             pd.MultiIndex.from_tuples(
  254:                 [("A", "a"), ("A", "b")], names=["outer", "inner"]
  255:             ),
  256:         ],
  257:     )
  258:     @pytest.mark.parametrize("future_stack", [True, False])
  259:     def test_stack(self, data, columns, future_stack):
  260:         df = pd.DataFrame({"A": data[:5], "B": data[:5]})
  261:         df.columns = columns
  262:         result = df.stack(future_stack=future_stack)
  263:         expected = df.astype(object).stack(future_stack=future_stack)
  264:         # we need a second astype(object), in case the constructor inferred
  265:         # object -> specialized, as is done for period.
  266:         expected = expected.astype(object)
  267: 
  268:         if isinstance(expected, pd.Series):
  269:             assert result.dtype == df.iloc[:, 0].dtype
  270:         else:
  271:             assert all(result.dtypes == df.iloc[:, 0].dtype)
  272: 
  273:         result = result.astype(object)
  274:         tm.assert_equal(result, expected)
  275: 
  276:     @pytest.mark.parametrize(
  277:         "index",
  278:         [
  279:             # Two levels, uniform.
  280:             pd.MultiIndex.from_product(([["A", "B"], ["a", "b"]]), names=["a", "b"]),
  281:             # non-uniform
  282:             pd.MultiIndex.from_tuples([("A", "a"), ("A", "b"), ("B", "b")]),
  283:             # three levels, non-uniform
  284:             pd.MultiIndex.from_product([("A", "B"), ("a", "b", "c"), (0, 1, 2)]),
  285:             pd.MultiIndex.from_tuples(
  286:                 [
  287:                     ("A", "a", 1),
  288:                     ("A", "b", 0),
  289:                     ("A", "a", 0),
  290:                     ("B", "a", 0),
  291:                     ("B", "c", 1),
  292:                 ]
  293:             ),
  294:         ],
  295:     )
  296:     @pytest.mark.parametrize("obj", ["series", "frame"])
  297:     def test_unstack(self, data, index, obj):
  298:         data = data[: len(index)]
  299:         if obj == "series":
  300:             ser = pd.Series(data, index=index)
  301:         else:
  302:             ser = pd.DataFrame({"A": data, "B": data}, index=index)
  303: 
  304:         n = index.nlevels
  305:         levels = list(range(n))
  306:         # [0, 1, 2]
  307:         # [(0,), (1,), (2,), (0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1)]
  308:         combinations = itertools.chain.from_iterable(
  309:             itertools.permutations(levels, i) for i in range(1, n)
  310:         )
  311: 
  312:         for level in combinations:
  313:             result = ser.unstack(level=level)
  314:             assert all(
  315:                 isinstance(result[col].array, type(data)) for col in result.columns
  316:             )
  317: 
  318:             if obj == "series":
  319:                 # We should get the same result with to_frame+unstack+droplevel
  320:                 df = ser.to_frame()
  321: 
  322:                 alt = df.unstack(level=level).droplevel(0, axis=1)
  323:                 tm.assert_frame_equal(result, alt)
  324: 
  325:             obj_ser = ser.astype(object)
  326: 
  327:             expected = obj_ser.unstack(level=level, fill_value=data.dtype.na_value)
  328:             if obj == "series":
  329:                 assert (expected.dtypes == object).all()
  330: 
  331:             result = result.astype(object)
  332:             tm.assert_frame_equal(result, expected)
  333: 
  334:     def test_ravel(self, data):
  335:         # as long as EA is 1D-only, ravel is a no-op
  336:         result = data.ravel()
  337:         assert type(result) == type(data)
  338: 
  339:         if data.dtype._is_immutable:
  340:             pytest.skip(f"test_ravel assumes mutability and {data.dtype} is immutable")
  341: 
  342:         # Check that we have a view, not a copy
  343:         result[0] = result[1]
  344:         assert data[0] == data[1]
  345: 
  346:     def test_transpose(self, data):
  347:         result = data.transpose()
  348:         assert type(result) == type(data)
  349: 
  350:         # check we get a new object
  351:         assert result is not data
  352: 
  353:         # If we ever _did_ support 2D, shape should be reversed
  354:         assert result.shape == data.shape[::-1]
  355: 
  356:         if data.dtype._is_immutable:
  357:             pytest.skip(
  358:                 f"test_transpose assumes mutability and {data.dtype} is immutable"
  359:             )
  360: 
  361:         # Check that we have a view, not a copy
  362:         result[0] = result[1]
  363:         assert data[0] == data[1]
  364: 
  365:     def test_transpose_frame(self, data):
  366:         df = pd.DataFrame({"A": data[:4], "B": data[:4]}, index=["a", "b", "c", "d"])
  367:         result = df.T
  368:         expected = pd.DataFrame(
  369:             {
  370:                 "a": type(data)._from_sequence([data[0]] * 2, dtype=data.dtype),
  371:                 "b": type(data)._from_sequence([data[1]] * 2, dtype=data.dtype),
  372:                 "c": type(data)._from_sequence([data[2]] * 2, dtype=data.dtype),
  373:                 "d": type(data)._from_sequence([data[3]] * 2, dtype=data.dtype),
  374:             },
  375:             index=["A", "B"],
  376:         )
  377:         tm.assert_frame_equal(result, expected)
  378:         tm.assert_frame_equal(np.transpose(np.transpose(df)), df)
  379:         tm.assert_frame_equal(np.transpose(np.transpose(df[["A"]])), df[["A"]])
