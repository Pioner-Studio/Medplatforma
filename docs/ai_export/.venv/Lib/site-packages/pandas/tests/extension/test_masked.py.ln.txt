    1: """
    2: This file contains a minimal set of tests for compliance with the extension
    3: array interface test suite, and should contain no other tests.
    4: The test suite for the full functionality of the array is located in
    5: `pandas/tests/arrays/`.
    6: 
    7: The tests in this file are inherited from the BaseExtensionTests, and only
    8: minimal tweaks should be applied to get the tests passing (by overwriting a
    9: parent method).
   10: 
   11: Additional tests should either be added to one of the BaseExtensionTests
   12: classes (if they are relevant for the extension interface for all dtypes), or
   13: be added to the array-specific tests in `pandas/tests/arrays/`.
   14: 
   15: """
   16: import warnings
   17: 
   18: import numpy as np
   19: import pytest
   20: 
   21: from pandas.compat import (
   22:     IS64,
   23:     is_platform_windows,
   24: )
   25: from pandas.compat.numpy import np_version_gt2
   26: 
   27: from pandas.core.dtypes.common import (
   28:     is_float_dtype,
   29:     is_signed_integer_dtype,
   30:     is_unsigned_integer_dtype,
   31: )
   32: 
   33: import pandas as pd
   34: import pandas._testing as tm
   35: from pandas.core.arrays.boolean import BooleanDtype
   36: from pandas.core.arrays.floating import (
   37:     Float32Dtype,
   38:     Float64Dtype,
   39: )
   40: from pandas.core.arrays.integer import (
   41:     Int8Dtype,
   42:     Int16Dtype,
   43:     Int32Dtype,
   44:     Int64Dtype,
   45:     UInt8Dtype,
   46:     UInt16Dtype,
   47:     UInt32Dtype,
   48:     UInt64Dtype,
   49: )
   50: from pandas.tests.extension import base
   51: 
   52: is_windows_or_32bit = (is_platform_windows() and not np_version_gt2) or not IS64
   53: 
   54: pytestmark = [
   55:     pytest.mark.filterwarnings(
   56:         "ignore:invalid value encountered in divide:RuntimeWarning"
   57:     ),
   58:     pytest.mark.filterwarnings("ignore:Mean of empty slice:RuntimeWarning"),
   59:     # overflow only relevant for Floating dtype cases cases
   60:     pytest.mark.filterwarnings("ignore:overflow encountered in reduce:RuntimeWarning"),
   61: ]
   62: 
   63: 
   64: def make_data():
   65:     return list(range(1, 9)) + [pd.NA] + list(range(10, 98)) + [pd.NA] + [99, 100]
   66: 
   67: 
   68: def make_float_data():
   69:     return (
   70:         list(np.arange(0.1, 0.9, 0.1))
   71:         + [pd.NA]
   72:         + list(np.arange(1, 9.8, 0.1))
   73:         + [pd.NA]
   74:         + [9.9, 10.0]
   75:     )
   76: 
   77: 
   78: def make_bool_data():
   79:     return [True, False] * 4 + [np.nan] + [True, False] * 44 + [np.nan] + [True, False]
   80: 
   81: 
   82: @pytest.fixture(
   83:     params=[
   84:         Int8Dtype,
   85:         Int16Dtype,
   86:         Int32Dtype,
   87:         Int64Dtype,
   88:         UInt8Dtype,
   89:         UInt16Dtype,
   90:         UInt32Dtype,
   91:         UInt64Dtype,
   92:         Float32Dtype,
   93:         Float64Dtype,
   94:         BooleanDtype,
   95:     ]
   96: )
   97: def dtype(request):
   98:     return request.param()
   99: 
  100: 
  101: @pytest.fixture
  102: def data(dtype):
  103:     if dtype.kind == "f":
  104:         data = make_float_data()
  105:     elif dtype.kind == "b":
  106:         data = make_bool_data()
  107:     else:
  108:         data = make_data()
  109:     return pd.array(data, dtype=dtype)
  110: 
  111: 
  112: @pytest.fixture
  113: def data_for_twos(dtype):
  114:     if dtype.kind == "b":
  115:         return pd.array(np.ones(100), dtype=dtype)
  116:     return pd.array(np.ones(100) * 2, dtype=dtype)
  117: 
  118: 
  119: @pytest.fixture
  120: def data_missing(dtype):
  121:     if dtype.kind == "f":
  122:         return pd.array([pd.NA, 0.1], dtype=dtype)
  123:     elif dtype.kind == "b":
  124:         return pd.array([np.nan, True], dtype=dtype)
  125:     return pd.array([pd.NA, 1], dtype=dtype)
  126: 
  127: 
  128: @pytest.fixture
  129: def data_for_sorting(dtype):
  130:     if dtype.kind == "f":
  131:         return pd.array([0.1, 0.2, 0.0], dtype=dtype)
  132:     elif dtype.kind == "b":
  133:         return pd.array([True, True, False], dtype=dtype)
  134:     return pd.array([1, 2, 0], dtype=dtype)
  135: 
  136: 
  137: @pytest.fixture
  138: def data_missing_for_sorting(dtype):
  139:     if dtype.kind == "f":
  140:         return pd.array([0.1, pd.NA, 0.0], dtype=dtype)
  141:     elif dtype.kind == "b":
  142:         return pd.array([True, np.nan, False], dtype=dtype)
  143:     return pd.array([1, pd.NA, 0], dtype=dtype)
  144: 
  145: 
  146: @pytest.fixture
  147: def na_cmp():
  148:     # we are pd.NA
  149:     return lambda x, y: x is pd.NA and y is pd.NA
  150: 
  151: 
  152: @pytest.fixture
  153: def data_for_grouping(dtype):
  154:     if dtype.kind == "f":
  155:         b = 0.1
  156:         a = 0.0
  157:         c = 0.2
  158:     elif dtype.kind == "b":
  159:         b = True
  160:         a = False
  161:         c = b
  162:     else:
  163:         b = 1
  164:         a = 0
  165:         c = 2
  166: 
  167:     na = pd.NA
  168:     return pd.array([b, b, na, na, a, a, b, c], dtype=dtype)
  169: 
  170: 
  171: class TestMaskedArrays(base.ExtensionTests):
  172:     @pytest.mark.parametrize("na_action", [None, "ignore"])
  173:     def test_map(self, data_missing, na_action):
  174:         result = data_missing.map(lambda x: x, na_action=na_action)
  175:         if data_missing.dtype == Float32Dtype():
  176:             # map roundtrips through objects, which converts to float64
  177:             expected = data_missing.to_numpy(dtype="float64", na_value=np.nan)
  178:         else:
  179:             expected = data_missing.to_numpy()
  180:         tm.assert_numpy_array_equal(result, expected)
  181: 
  182:     def test_map_na_action_ignore(self, data_missing_for_sorting):
  183:         zero = data_missing_for_sorting[2]
  184:         result = data_missing_for_sorting.map(lambda x: zero, na_action="ignore")
  185:         if data_missing_for_sorting.dtype.kind == "b":
  186:             expected = np.array([False, pd.NA, False], dtype=object)
  187:         else:
  188:             expected = np.array([zero, np.nan, zero])
  189:         tm.assert_numpy_array_equal(result, expected)
  190: 
  191:     def _get_expected_exception(self, op_name, obj, other):
  192:         try:
  193:             dtype = tm.get_dtype(obj)
  194:         except AttributeError:
  195:             # passed arguments reversed
  196:             dtype = tm.get_dtype(other)
  197: 
  198:         if dtype.kind == "b":
  199:             if op_name.strip("_").lstrip("r") in ["pow", "truediv", "floordiv"]:
  200:                 # match behavior with non-masked bool dtype
  201:                 return NotImplementedError
  202:             elif op_name in ["__sub__", "__rsub__"]:
  203:                 # exception message would include "numpy boolean subtract""
  204:                 return TypeError
  205:             return None
  206:         return None
  207: 
  208:     def _cast_pointwise_result(self, op_name: str, obj, other, pointwise_result):
  209:         sdtype = tm.get_dtype(obj)
  210:         expected = pointwise_result
  211: 
  212:         if op_name in ("eq", "ne", "le", "ge", "lt", "gt"):
  213:             return expected.astype("boolean")
  214: 
  215:         if sdtype.kind in "iu":
  216:             if op_name in ("__rtruediv__", "__truediv__", "__div__"):
  217:                 with warnings.catch_warnings():
  218:                     warnings.filterwarnings(
  219:                         "ignore",
  220:                         "Downcasting object dtype arrays",
  221:                         category=FutureWarning,
  222:                     )
  223:                     filled = expected.fillna(np.nan)
  224:                 expected = filled.astype("Float64")
  225:             else:
  226:                 # combine method result in 'biggest' (int64) dtype
  227:                 expected = expected.astype(sdtype)
  228:         elif sdtype.kind == "b":
  229:             if op_name in (
  230:                 "__floordiv__",
  231:                 "__rfloordiv__",
  232:                 "__pow__",
  233:                 "__rpow__",
  234:                 "__mod__",
  235:                 "__rmod__",
  236:             ):
  237:                 # combine keeps boolean type
  238:                 expected = expected.astype("Int8")
  239: 
  240:             elif op_name in ("__truediv__", "__rtruediv__"):
  241:                 # combine with bools does not generate the correct result
  242:                 #  (numpy behaviour for div is to regard the bools as numeric)
  243:                 op = self.get_op_from_name(op_name)
  244:                 expected = self._combine(obj.astype(float), other, op)
  245:                 expected = expected.astype("Float64")
  246: 
  247:             if op_name == "__rpow__":
  248:                 # for rpow, combine does not propagate NaN
  249:                 result = getattr(obj, op_name)(other)
  250:                 expected[result.isna()] = np.nan
  251:         else:
  252:             # combine method result in 'biggest' (float64) dtype
  253:             expected = expected.astype(sdtype)
  254:         return expected
  255: 
  256:     def test_divmod_series_array(self, data, data_for_twos, request):
  257:         if data.dtype.kind == "b":
  258:             mark = pytest.mark.xfail(
  259:                 reason="Inconsistency between floordiv and divmod; we raise for "
  260:                 "floordiv but not for divmod. This matches what we do for "
  261:                 "non-masked bool dtype."
  262:             )
  263:             request.applymarker(mark)
  264:         super().test_divmod_series_array(data, data_for_twos)
  265: 
  266:     def test_combine_le(self, data_repeated):
  267:         # TODO: patching self is a bad pattern here
  268:         orig_data1, orig_data2 = data_repeated(2)
  269:         if orig_data1.dtype.kind == "b":
  270:             self._combine_le_expected_dtype = "boolean"
  271:         else:
  272:             # TODO: can we make this boolean?
  273:             self._combine_le_expected_dtype = object
  274:         super().test_combine_le(data_repeated)
  275: 
  276:     def _supports_reduction(self, ser: pd.Series, op_name: str) -> bool:
  277:         if op_name in ["any", "all"] and ser.dtype.kind != "b":
  278:             pytest.skip(reason="Tested in tests/reductions/test_reductions.py")
  279:         return True
  280: 
  281:     def check_reduce(self, ser: pd.Series, op_name: str, skipna: bool):
  282:         # overwrite to ensure pd.NA is tested instead of np.nan
  283:         # https://github.com/pandas-dev/pandas/issues/30958
  284: 
  285:         cmp_dtype = "int64"
  286:         if ser.dtype.kind == "f":
  287:             # Item "dtype[Any]" of "Union[dtype[Any], ExtensionDtype]" has
  288:             # no attribute "numpy_dtype"
  289:             cmp_dtype = ser.dtype.numpy_dtype  # type: ignore[union-attr]
  290:         elif ser.dtype.kind == "b":
  291:             if op_name in ["min", "max"]:
  292:                 cmp_dtype = "bool"
  293: 
  294:         # TODO: prod with integer dtypes does *not* match the result we would
  295:         #  get if we used object for cmp_dtype. In that cae the object result
  296:         #  is a large integer while the non-object case overflows and returns 0
  297:         alt = ser.dropna().astype(cmp_dtype)
  298:         if op_name == "count":
  299:             result = getattr(ser, op_name)()
  300:             expected = getattr(alt, op_name)()
  301:         else:
  302:             result = getattr(ser, op_name)(skipna=skipna)
  303:             expected = getattr(alt, op_name)(skipna=skipna)
  304:             if not skipna and ser.isna().any() and op_name not in ["any", "all"]:
  305:                 expected = pd.NA
  306:         tm.assert_almost_equal(result, expected)
  307: 
  308:     def _get_expected_reduction_dtype(self, arr, op_name: str, skipna: bool):
  309:         if is_float_dtype(arr.dtype):
  310:             cmp_dtype = arr.dtype.name
  311:         elif op_name in ["mean", "median", "var", "std", "skew"]:
  312:             cmp_dtype = "Float64"
  313:         elif op_name in ["max", "min"]:
  314:             cmp_dtype = arr.dtype.name
  315:         elif arr.dtype in ["Int64", "UInt64"]:
  316:             cmp_dtype = arr.dtype.name
  317:         elif is_signed_integer_dtype(arr.dtype):
  318:             # TODO: Why does Window Numpy 2.0 dtype depend on skipna?
  319:             cmp_dtype = (
  320:                 "Int32"
  321:                 if (is_platform_windows() and (not np_version_gt2 or not skipna))
  322:                 or not IS64
  323:                 else "Int64"
  324:             )
  325:         elif is_unsigned_integer_dtype(arr.dtype):
  326:             cmp_dtype = (
  327:                 "UInt32"
  328:                 if (is_platform_windows() and (not np_version_gt2 or not skipna))
  329:                 or not IS64
  330:                 else "UInt64"
  331:             )
  332:         elif arr.dtype.kind == "b":
  333:             if op_name in ["mean", "median", "var", "std", "skew"]:
  334:                 cmp_dtype = "Float64"
  335:             elif op_name in ["min", "max"]:
  336:                 cmp_dtype = "boolean"
  337:             elif op_name in ["sum", "prod"]:
  338:                 cmp_dtype = (
  339:                     "Int32"
  340:                     if (is_platform_windows() and (not np_version_gt2 or not skipna))
  341:                     or not IS64
  342:                     else "Int64"
  343:                 )
  344:             else:
  345:                 raise TypeError("not supposed to reach this")
  346:         else:
  347:             raise TypeError("not supposed to reach this")
  348:         return cmp_dtype
  349: 
  350:     def _supports_accumulation(self, ser: pd.Series, op_name: str) -> bool:
  351:         return True
  352: 
  353:     def check_accumulate(self, ser: pd.Series, op_name: str, skipna: bool):
  354:         # overwrite to ensure pd.NA is tested instead of np.nan
  355:         # https://github.com/pandas-dev/pandas/issues/30958
  356:         length = 64
  357:         if is_windows_or_32bit:
  358:             # Item "ExtensionDtype" of "Union[dtype[Any], ExtensionDtype]" has
  359:             # no attribute "itemsize"
  360:             if not ser.dtype.itemsize == 8:  # type: ignore[union-attr]
  361:                 length = 32
  362: 
  363:         if ser.dtype.name.startswith("U"):
  364:             expected_dtype = f"UInt{length}"
  365:         elif ser.dtype.name.startswith("I"):
  366:             expected_dtype = f"Int{length}"
  367:         elif ser.dtype.name.startswith("F"):
  368:             # Incompatible types in assignment (expression has type
  369:             # "Union[dtype[Any], ExtensionDtype]", variable has type "str")
  370:             expected_dtype = ser.dtype  # type: ignore[assignment]
  371:         elif ser.dtype.kind == "b":
  372:             if op_name in ("cummin", "cummax"):
  373:                 expected_dtype = "boolean"
  374:             else:
  375:                 expected_dtype = f"Int{length}"
  376: 
  377:         if expected_dtype == "Float32" and op_name == "cumprod" and skipna:
  378:             # TODO: xfail?
  379:             pytest.skip(
  380:                 f"Float32 precision lead to large differences with op {op_name} "
  381:                 f"and skipna={skipna}"
  382:             )
  383: 
  384:         if op_name == "cumsum":
  385:             result = getattr(ser, op_name)(skipna=skipna)
  386:             expected = pd.Series(
  387:                 pd.array(
  388:                     getattr(ser.astype("float64"), op_name)(skipna=skipna),
  389:                     dtype=expected_dtype,
  390:                 )
  391:             )
  392:             tm.assert_series_equal(result, expected)
  393:         elif op_name in ["cummax", "cummin"]:
  394:             result = getattr(ser, op_name)(skipna=skipna)
  395:             expected = pd.Series(
  396:                 pd.array(
  397:                     getattr(ser.astype("float64"), op_name)(skipna=skipna),
  398:                     dtype=ser.dtype,
  399:                 )
  400:             )
  401:             tm.assert_series_equal(result, expected)
  402:         elif op_name == "cumprod":
  403:             result = getattr(ser[:12], op_name)(skipna=skipna)
  404:             expected = pd.Series(
  405:                 pd.array(
  406:                     getattr(ser[:12].astype("float64"), op_name)(skipna=skipna),
  407:                     dtype=expected_dtype,
  408:                 )
  409:             )
  410:             tm.assert_series_equal(result, expected)
  411: 
  412:         else:
  413:             raise NotImplementedError(f"{op_name} not supported")
  414: 
  415: 
  416: class Test2DCompat(base.Dim2CompatTests):
  417:     pass
