    1: """
    2: This file contains a minimal set of tests for compliance with the extension
    3: array interface test suite, and should contain no other tests.
    4: The test suite for the full functionality of the array is located in
    5: `pandas/tests/arrays/`.
    6: 
    7: The tests in this file are inherited from the BaseExtensionTests, and only
    8: minimal tweaks should be applied to get the tests passing (by overwriting a
    9: parent method).
   10: 
   11: Additional tests should either be added to one of the BaseExtensionTests
   12: classes (if they are relevant for the extension interface for all dtypes), or
   13: be added to the array-specific tests in `pandas/tests/arrays/`.
   14: 
   15: """
   16: import numpy as np
   17: import pytest
   18: 
   19: from pandas.core.dtypes.dtypes import DatetimeTZDtype
   20: 
   21: import pandas as pd
   22: import pandas._testing as tm
   23: from pandas.core.arrays import DatetimeArray
   24: from pandas.tests.extension import base
   25: 
   26: 
   27: @pytest.fixture(params=["US/Central"])
   28: def dtype(request):
   29:     return DatetimeTZDtype(unit="ns", tz=request.param)
   30: 
   31: 
   32: @pytest.fixture
   33: def data(dtype):
   34:     data = DatetimeArray._from_sequence(
   35:         pd.date_range("2000", periods=100, tz=dtype.tz), dtype=dtype
   36:     )
   37:     return data
   38: 
   39: 
   40: @pytest.fixture
   41: def data_missing(dtype):
   42:     return DatetimeArray._from_sequence(
   43:         np.array(["NaT", "2000-01-01"], dtype="datetime64[ns]"), dtype=dtype
   44:     )
   45: 
   46: 
   47: @pytest.fixture
   48: def data_for_sorting(dtype):
   49:     a = pd.Timestamp("2000-01-01")
   50:     b = pd.Timestamp("2000-01-02")
   51:     c = pd.Timestamp("2000-01-03")
   52:     return DatetimeArray._from_sequence(
   53:         np.array([b, c, a], dtype="datetime64[ns]"), dtype=dtype
   54:     )
   55: 
   56: 
   57: @pytest.fixture
   58: def data_missing_for_sorting(dtype):
   59:     a = pd.Timestamp("2000-01-01")
   60:     b = pd.Timestamp("2000-01-02")
   61:     return DatetimeArray._from_sequence(
   62:         np.array([b, "NaT", a], dtype="datetime64[ns]"), dtype=dtype
   63:     )
   64: 
   65: 
   66: @pytest.fixture
   67: def data_for_grouping(dtype):
   68:     """
   69:     Expected to be like [B, B, NA, NA, A, A, B, C]
   70: 
   71:     Where A < B < C and NA is missing
   72:     """
   73:     a = pd.Timestamp("2000-01-01")
   74:     b = pd.Timestamp("2000-01-02")
   75:     c = pd.Timestamp("2000-01-03")
   76:     na = "NaT"
   77:     return DatetimeArray._from_sequence(
   78:         np.array([b, b, na, na, a, a, b, c], dtype="datetime64[ns]"), dtype=dtype
   79:     )
   80: 
   81: 
   82: @pytest.fixture
   83: def na_cmp():
   84:     def cmp(a, b):
   85:         return a is pd.NaT and a is b
   86: 
   87:     return cmp
   88: 
   89: 
   90: # ----------------------------------------------------------------------------
   91: class TestDatetimeArray(base.ExtensionTests):
   92:     def _get_expected_exception(self, op_name, obj, other):
   93:         if op_name in ["__sub__", "__rsub__"]:
   94:             return None
   95:         return super()._get_expected_exception(op_name, obj, other)
   96: 
   97:     def _supports_accumulation(self, ser, op_name: str) -> bool:
   98:         return op_name in ["cummin", "cummax"]
   99: 
  100:     def _supports_reduction(self, obj, op_name: str) -> bool:
  101:         return op_name in ["min", "max", "median", "mean", "std", "any", "all"]
  102: 
  103:     @pytest.mark.parametrize("skipna", [True, False])
  104:     def test_reduce_series_boolean(self, data, all_boolean_reductions, skipna):
  105:         meth = all_boolean_reductions
  106:         msg = f"'{meth}' with datetime64 dtypes is deprecated and will raise in"
  107:         with tm.assert_produces_warning(
  108:             FutureWarning, match=msg, check_stacklevel=False
  109:         ):
  110:             super().test_reduce_series_boolean(data, all_boolean_reductions, skipna)
  111: 
  112:     def test_series_constructor(self, data):
  113:         # Series construction drops any .freq attr
  114:         data = data._with_freq(None)
  115:         super().test_series_constructor(data)
  116: 
  117:     @pytest.mark.parametrize("na_action", [None, "ignore"])
  118:     def test_map(self, data, na_action):
  119:         result = data.map(lambda x: x, na_action=na_action)
  120:         tm.assert_extension_array_equal(result, data)
  121: 
  122:     def check_reduce(self, ser: pd.Series, op_name: str, skipna: bool):
  123:         if op_name in ["median", "mean", "std"]:
  124:             alt = ser.astype("int64")
  125: 
  126:             res_op = getattr(ser, op_name)
  127:             exp_op = getattr(alt, op_name)
  128:             result = res_op(skipna=skipna)
  129:             expected = exp_op(skipna=skipna)
  130:             if op_name in ["mean", "median"]:
  131:                 # error: Item "dtype[Any]" of "dtype[Any] | ExtensionDtype"
  132:                 # has no attribute "tz"
  133:                 tz = ser.dtype.tz  # type: ignore[union-attr]
  134:                 expected = pd.Timestamp(expected, tz=tz)
  135:             else:
  136:                 expected = pd.Timedelta(expected)
  137:             tm.assert_almost_equal(result, expected)
  138: 
  139:         else:
  140:             return super().check_reduce(ser, op_name, skipna)
  141: 
  142: 
  143: class Test2DCompat(base.NDArrayBacked2DTests):
  144:     pass
