    1: from __future__ import annotations
    2: 
    3: import datetime as dt
    4: from typing import (
    5:     TYPE_CHECKING,
    6:     Any,
    7:     cast,
    8: )
    9: 
   10: import numpy as np
   11: 
   12: from pandas.core.dtypes.dtypes import register_extension_dtype
   13: 
   14: from pandas.api.extensions import (
   15:     ExtensionArray,
   16:     ExtensionDtype,
   17: )
   18: from pandas.api.types import pandas_dtype
   19: 
   20: if TYPE_CHECKING:
   21:     from collections.abc import Sequence
   22: 
   23:     from pandas._typing import (
   24:         Dtype,
   25:         PositionalIndexer,
   26:     )
   27: 
   28: 
   29: @register_extension_dtype
   30: class DateDtype(ExtensionDtype):
   31:     @property
   32:     def type(self):
   33:         return dt.date
   34: 
   35:     @property
   36:     def name(self):
   37:         return "DateDtype"
   38: 
   39:     @classmethod
   40:     def construct_from_string(cls, string: str):
   41:         if not isinstance(string, str):
   42:             raise TypeError(
   43:                 f"'construct_from_string' expects a string, got {type(string)}"
   44:             )
   45: 
   46:         if string == cls.__name__:
   47:             return cls()
   48:         else:
   49:             raise TypeError(f"Cannot construct a '{cls.__name__}' from '{string}'")
   50: 
   51:     @classmethod
   52:     def construct_array_type(cls):
   53:         return DateArray
   54: 
   55:     @property
   56:     def na_value(self):
   57:         return dt.date.min
   58: 
   59:     def __repr__(self) -> str:
   60:         return self.name
   61: 
   62: 
   63: class DateArray(ExtensionArray):
   64:     def __init__(
   65:         self,
   66:         dates: (
   67:             dt.date
   68:             | Sequence[dt.date]
   69:             | tuple[np.ndarray, np.ndarray, np.ndarray]
   70:             | np.ndarray
   71:         ),
   72:     ) -> None:
   73:         if isinstance(dates, dt.date):
   74:             self._year = np.array([dates.year])
   75:             self._month = np.array([dates.month])
   76:             self._day = np.array([dates.year])
   77:             return
   78: 
   79:         ldates = len(dates)
   80:         if isinstance(dates, list):
   81:             # pre-allocate the arrays since we know the size before hand
   82:             self._year = np.zeros(ldates, dtype=np.uint16)  # 65535 (0, 9999)
   83:             self._month = np.zeros(ldates, dtype=np.uint8)  # 255 (1, 31)
   84:             self._day = np.zeros(ldates, dtype=np.uint8)  # 255 (1, 12)
   85:             # populate them
   86:             for i, (y, m, d) in enumerate(
   87:                 (date.year, date.month, date.day) for date in dates
   88:             ):
   89:                 self._year[i] = y
   90:                 self._month[i] = m
   91:                 self._day[i] = d
   92: 
   93:         elif isinstance(dates, tuple):
   94:             # only support triples
   95:             if ldates != 3:
   96:                 raise ValueError("only triples are valid")
   97:             # check if all elements have the same type
   98:             if any(not isinstance(x, np.ndarray) for x in dates):
   99:                 raise TypeError("invalid type")
  100:             ly, lm, ld = (len(cast(np.ndarray, d)) for d in dates)
  101:             if not ly == lm == ld:
  102:                 raise ValueError(
  103:                     f"tuple members must have the same length: {(ly, lm, ld)}"
  104:                 )
  105:             self._year = dates[0].astype(np.uint16)
  106:             self._month = dates[1].astype(np.uint8)
  107:             self._day = dates[2].astype(np.uint8)
  108: 
  109:         elif isinstance(dates, np.ndarray) and dates.dtype == "U10":
  110:             self._year = np.zeros(ldates, dtype=np.uint16)  # 65535 (0, 9999)
  111:             self._month = np.zeros(ldates, dtype=np.uint8)  # 255 (1, 31)
  112:             self._day = np.zeros(ldates, dtype=np.uint8)  # 255 (1, 12)
  113: 
  114:             # error: "object_" object is not iterable
  115:             obj = np.char.split(dates, sep="-")
  116:             for (i,), (y, m, d) in np.ndenumerate(obj):  # type: ignore[misc]
  117:                 self._year[i] = int(y)
  118:                 self._month[i] = int(m)
  119:                 self._day[i] = int(d)
  120: 
  121:         else:
  122:             raise TypeError(f"{type(dates)} is not supported")
  123: 
  124:     @property
  125:     def dtype(self) -> ExtensionDtype:
  126:         return DateDtype()
  127: 
  128:     def astype(self, dtype, copy=True):
  129:         dtype = pandas_dtype(dtype)
  130: 
  131:         if isinstance(dtype, DateDtype):
  132:             data = self.copy() if copy else self
  133:         else:
  134:             data = self.to_numpy(dtype=dtype, copy=copy, na_value=dt.date.min)
  135: 
  136:         return data
  137: 
  138:     @property
  139:     def nbytes(self) -> int:
  140:         return self._year.nbytes + self._month.nbytes + self._day.nbytes
  141: 
  142:     def __len__(self) -> int:
  143:         return len(self._year)  # all 3 arrays are enforced to have the same length
  144: 
  145:     def __getitem__(self, item: PositionalIndexer):
  146:         if isinstance(item, int):
  147:             return dt.date(self._year[item], self._month[item], self._day[item])
  148:         else:
  149:             raise NotImplementedError("only ints are supported as indexes")
  150: 
  151:     def __setitem__(self, key: int | slice | np.ndarray, value: Any) -> None:
  152:         if not isinstance(key, int):
  153:             raise NotImplementedError("only ints are supported as indexes")
  154: 
  155:         if not isinstance(value, dt.date):
  156:             raise TypeError("you can only set datetime.date types")
  157: 
  158:         self._year[key] = value.year
  159:         self._month[key] = value.month
  160:         self._day[key] = value.day
  161: 
  162:     def __repr__(self) -> str:
  163:         return f"DateArray{list(zip(self._year, self._month, self._day))}"
  164: 
  165:     def copy(self) -> DateArray:
  166:         return DateArray((self._year.copy(), self._month.copy(), self._day.copy()))
  167: 
  168:     def isna(self) -> np.ndarray:
  169:         return np.logical_and(
  170:             np.logical_and(
  171:                 self._year == dt.date.min.year, self._month == dt.date.min.month
  172:             ),
  173:             self._day == dt.date.min.day,
  174:         )
  175: 
  176:     @classmethod
  177:     def _from_sequence(cls, scalars, *, dtype: Dtype | None = None, copy=False):
  178:         if isinstance(scalars, dt.date):
  179:             raise TypeError
  180:         elif isinstance(scalars, DateArray):
  181:             if dtype is not None:
  182:                 return scalars.astype(dtype, copy=copy)
  183:             if copy:
  184:                 return scalars.copy()
  185:             return scalars[:]
  186:         elif isinstance(scalars, np.ndarray):
  187:             scalars = scalars.astype("U10")  # 10 chars for yyyy-mm-dd
  188:             return DateArray(scalars)
