    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas.core.dtypes import dtypes
    5: from pandas.core.dtypes.common import is_extension_array_dtype
    6: 
    7: import pandas as pd
    8: import pandas._testing as tm
    9: from pandas.core.arrays import ExtensionArray
   10: 
   11: 
   12: class DummyDtype(dtypes.ExtensionDtype):
   13:     pass
   14: 
   15: 
   16: class DummyArray(ExtensionArray):
   17:     def __init__(self, data) -> None:
   18:         self.data = data
   19: 
   20:     def __array__(self, dtype=None, copy=None):
   21:         return self.data
   22: 
   23:     @property
   24:     def dtype(self):
   25:         return DummyDtype()
   26: 
   27:     def astype(self, dtype, copy=True):
   28:         # we don't support anything but a single dtype
   29:         if isinstance(dtype, DummyDtype):
   30:             if copy:
   31:                 return type(self)(self.data)
   32:             return self
   33:         elif not copy:
   34:             return np.asarray(self, dtype=dtype)
   35:         else:
   36:             return np.array(self, dtype=dtype, copy=copy)
   37: 
   38: 
   39: class TestExtensionArrayDtype:
   40:     @pytest.mark.parametrize(
   41:         "values",
   42:         [
   43:             pd.Categorical([]),
   44:             pd.Categorical([]).dtype,
   45:             pd.Series(pd.Categorical([])),
   46:             DummyDtype(),
   47:             DummyArray(np.array([1, 2])),
   48:         ],
   49:     )
   50:     def test_is_extension_array_dtype(self, values):
   51:         assert is_extension_array_dtype(values)
   52: 
   53:     @pytest.mark.parametrize("values", [np.array([]), pd.Series(np.array([]))])
   54:     def test_is_not_extension_array_dtype(self, values):
   55:         assert not is_extension_array_dtype(values)
   56: 
   57: 
   58: def test_astype():
   59:     arr = DummyArray(np.array([1, 2, 3]))
   60:     expected = np.array([1, 2, 3], dtype=object)
   61: 
   62:     result = arr.astype(object)
   63:     tm.assert_numpy_array_equal(result, expected)
   64: 
   65:     result = arr.astype("object")
   66:     tm.assert_numpy_array_equal(result, expected)
   67: 
   68: 
   69: def test_astype_no_copy():
   70:     arr = DummyArray(np.array([1, 2, 3], dtype=np.int64))
   71:     result = arr.astype(arr.dtype, copy=False)
   72: 
   73:     assert arr is result
   74: 
   75:     result = arr.astype(arr.dtype)
   76:     assert arr is not result
   77: 
   78: 
   79: @pytest.mark.parametrize("dtype", [dtypes.CategoricalDtype(), dtypes.IntervalDtype()])
   80: def test_is_extension_array_dtype(dtype):
   81:     assert isinstance(dtype, dtypes.ExtensionDtype)
   82:     assert is_extension_array_dtype(dtype)
   83: 
   84: 
   85: class CapturingStringArray(pd.arrays.StringArray):
   86:     """Extend StringArray to capture arguments to __getitem__"""
   87: 
   88:     def __getitem__(self, item):
   89:         self.last_item_arg = item
   90:         return super().__getitem__(item)
   91: 
   92: 
   93: def test_ellipsis_index():
   94:     # GH#42430 1D slices over extension types turn into N-dimensional slices
   95:     #  over ExtensionArrays
   96:     df = pd.DataFrame(
   97:         {"col1": CapturingStringArray(np.array(["hello", "world"], dtype=object))}
   98:     )
   99:     _ = df.iloc[:1]
  100: 
  101:     # String comparison because there's no native way to compare slices.
  102:     # Before the fix for GH#42430, last_item_arg would get set to the 2D slice
  103:     # (Ellipsis, slice(None, 1, None))
  104:     out = df["col1"].array.last_item_arg
  105:     assert str(out) == "slice(None, 1, None)"
