    1: """
    2: This file contains a minimal set of tests for compliance with the extension
    3: array interface test suite, and should contain no other tests.
    4: The test suite for the full functionality of the array is located in
    5: `pandas/tests/arrays/`.
    6: 
    7: The tests in this file are inherited from the BaseExtensionTests, and only
    8: minimal tweaks should be applied to get the tests passing (by overwriting a
    9: parent method).
   10: 
   11: Additional tests should either be added to one of the BaseExtensionTests
   12: classes (if they are relevant for the extension interface for all dtypes), or
   13: be added to the array-specific tests in `pandas/tests/arrays/`.
   14: 
   15: Note: we do not bother with base.BaseIndexTests because NumpyExtensionArray
   16: will never be held in an Index.
   17: """
   18: import numpy as np
   19: import pytest
   20: 
   21: from pandas.core.dtypes.dtypes import NumpyEADtype
   22: 
   23: import pandas as pd
   24: import pandas._testing as tm
   25: from pandas.api.types import is_object_dtype
   26: from pandas.core.arrays.numpy_ import NumpyExtensionArray
   27: from pandas.tests.extension import base
   28: 
   29: orig_assert_attr_equal = tm.assert_attr_equal
   30: 
   31: 
   32: def _assert_attr_equal(attr: str, left, right, obj: str = "Attributes"):
   33:     """
   34:     patch tm.assert_attr_equal so NumpyEADtype("object") is closed enough to
   35:     np.dtype("object")
   36:     """
   37:     if attr == "dtype":
   38:         lattr = getattr(left, "dtype", None)
   39:         rattr = getattr(right, "dtype", None)
   40:         if isinstance(lattr, NumpyEADtype) and not isinstance(rattr, NumpyEADtype):
   41:             left = left.astype(lattr.numpy_dtype)
   42:         elif isinstance(rattr, NumpyEADtype) and not isinstance(lattr, NumpyEADtype):
   43:             right = right.astype(rattr.numpy_dtype)
   44: 
   45:     orig_assert_attr_equal(attr, left, right, obj)
   46: 
   47: 
   48: @pytest.fixture(params=["float", "object"])
   49: def dtype(request):
   50:     return NumpyEADtype(np.dtype(request.param))
   51: 
   52: 
   53: @pytest.fixture
   54: def allow_in_pandas(monkeypatch):
   55:     """
   56:     A monkeypatch to tells pandas to let us in.
   57: 
   58:     By default, passing a NumpyExtensionArray to an index / series / frame
   59:     constructor will unbox that NumpyExtensionArray to an ndarray, and treat
   60:     it as a non-EA column. We don't want people using EAs without
   61:     reason.
   62: 
   63:     The mechanism for this is a check against ABCNumpyExtensionArray
   64:     in each constructor.
   65: 
   66:     But, for testing, we need to allow them in pandas. So we patch
   67:     the _typ of NumpyExtensionArray, so that we evade the ABCNumpyExtensionArray
   68:     check.
   69:     """
   70:     with monkeypatch.context() as m:
   71:         m.setattr(NumpyExtensionArray, "_typ", "extension")
   72:         m.setattr(tm.asserters, "assert_attr_equal", _assert_attr_equal)
   73:         yield
   74: 
   75: 
   76: @pytest.fixture
   77: def data(allow_in_pandas, dtype):
   78:     if dtype.numpy_dtype == "object":
   79:         return pd.Series([(i,) for i in range(100)]).array
   80:     return NumpyExtensionArray(np.arange(1, 101, dtype=dtype._dtype))
   81: 
   82: 
   83: @pytest.fixture
   84: def data_missing(allow_in_pandas, dtype):
   85:     if dtype.numpy_dtype == "object":
   86:         return NumpyExtensionArray(np.array([np.nan, (1,)], dtype=object))
   87:     return NumpyExtensionArray(np.array([np.nan, 1.0]))
   88: 
   89: 
   90: @pytest.fixture
   91: def na_cmp():
   92:     def cmp(a, b):
   93:         return np.isnan(a) and np.isnan(b)
   94: 
   95:     return cmp
   96: 
   97: 
   98: @pytest.fixture
   99: def data_for_sorting(allow_in_pandas, dtype):
  100:     """Length-3 array with a known sort order.
  101: 
  102:     This should be three items [B, C, A] with
  103:     A < B < C
  104:     """
  105:     if dtype.numpy_dtype == "object":
  106:         # Use an empty tuple for first element, then remove,
  107:         # to disable np.array's shape inference.
  108:         return NumpyExtensionArray(np.array([(), (2,), (3,), (1,)], dtype=object)[1:])
  109:     return NumpyExtensionArray(np.array([1, 2, 0]))
  110: 
  111: 
  112: @pytest.fixture
  113: def data_missing_for_sorting(allow_in_pandas, dtype):
  114:     """Length-3 array with a known sort order.
  115: 
  116:     This should be three items [B, NA, A] with
  117:     A < B and NA missing.
  118:     """
  119:     if dtype.numpy_dtype == "object":
  120:         return NumpyExtensionArray(np.array([(1,), np.nan, (0,)], dtype=object))
  121:     return NumpyExtensionArray(np.array([1, np.nan, 0]))
  122: 
  123: 
  124: @pytest.fixture
  125: def data_for_grouping(allow_in_pandas, dtype):
  126:     """Data for factorization, grouping, and unique tests.
  127: 
  128:     Expected to be like [B, B, NA, NA, A, A, B, C]
  129: 
  130:     Where A < B < C and NA is missing
  131:     """
  132:     if dtype.numpy_dtype == "object":
  133:         a, b, c = (1,), (2,), (3,)
  134:     else:
  135:         a, b, c = np.arange(3)
  136:     return NumpyExtensionArray(
  137:         np.array([b, b, np.nan, np.nan, a, a, b, c], dtype=dtype.numpy_dtype)
  138:     )
  139: 
  140: 
  141: @pytest.fixture
  142: def data_for_twos(dtype):
  143:     if dtype.kind == "O":
  144:         pytest.skip(f"{dtype} is not a numeric dtype")
  145:     arr = np.ones(100) * 2
  146:     return NumpyExtensionArray._from_sequence(arr, dtype=dtype)
  147: 
  148: 
  149: @pytest.fixture
  150: def skip_numpy_object(dtype, request):
  151:     """
  152:     Tests for NumpyExtensionArray with nested data. Users typically won't create
  153:     these objects via `pd.array`, but they can show up through `.array`
  154:     on a Series with nested data. Many of the base tests fail, as they aren't
  155:     appropriate for nested data.
  156: 
  157:     This fixture allows these tests to be skipped when used as a usefixtures
  158:     marker to either an individual test or a test class.
  159:     """
  160:     if dtype == "object":
  161:         mark = pytest.mark.xfail(reason="Fails for object dtype")
  162:         request.applymarker(mark)
  163: 
  164: 
  165: skip_nested = pytest.mark.usefixtures("skip_numpy_object")
  166: 
  167: 
  168: class TestNumpyExtensionArray(base.ExtensionTests):
  169:     @pytest.mark.skip(reason="We don't register our dtype")
  170:     # We don't want to register. This test should probably be split in two.
  171:     def test_from_dtype(self, data):
  172:         pass
  173: 
  174:     @skip_nested
  175:     def test_series_constructor_scalar_with_index(self, data, dtype):
  176:         # ValueError: Length of passed values is 1, index implies 3.
  177:         super().test_series_constructor_scalar_with_index(data, dtype)
  178: 
  179:     def test_check_dtype(self, data, request, using_infer_string):
  180:         if data.dtype.numpy_dtype == "object":
  181:             request.applymarker(
  182:                 pytest.mark.xfail(
  183:                     reason=f"NumpyExtensionArray expectedly clashes with a "
  184:                     f"NumPy name: {data.dtype.numpy_dtype}"
  185:                 )
  186:             )
  187:         super().test_check_dtype(data)
  188: 
  189:     def test_is_not_object_type(self, dtype, request):
  190:         if dtype.numpy_dtype == "object":
  191:             # Different from BaseDtypeTests.test_is_not_object_type
  192:             # because NumpyEADtype(object) is an object type
  193:             assert is_object_dtype(dtype)
  194:         else:
  195:             super().test_is_not_object_type(dtype)
  196: 
  197:     @skip_nested
  198:     def test_getitem_scalar(self, data):
  199:         # AssertionError
  200:         super().test_getitem_scalar(data)
  201: 
  202:     @skip_nested
  203:     def test_shift_fill_value(self, data):
  204:         # np.array shape inference. Shift implementation fails.
  205:         super().test_shift_fill_value(data)
  206: 
  207:     @skip_nested
  208:     def test_fillna_copy_frame(self, data_missing):
  209:         # The "scalar" for this array isn't a scalar.
  210:         super().test_fillna_copy_frame(data_missing)
  211: 
  212:     @skip_nested
  213:     def test_fillna_copy_series(self, data_missing):
  214:         # The "scalar" for this array isn't a scalar.
  215:         super().test_fillna_copy_series(data_missing)
  216: 
  217:     @skip_nested
  218:     def test_searchsorted(self, data_for_sorting, as_series):
  219:         # TODO: NumpyExtensionArray.searchsorted calls ndarray.searchsorted which
  220:         #  isn't quite what we want in nested data cases. Instead we need to
  221:         #  adapt something like libindex._bin_search.
  222:         super().test_searchsorted(data_for_sorting, as_series)
  223: 
  224:     @pytest.mark.xfail(reason="NumpyExtensionArray.diff may fail on dtype")
  225:     def test_diff(self, data, periods):
  226:         return super().test_diff(data, periods)
  227: 
  228:     def test_insert(self, data, request):
  229:         if data.dtype.numpy_dtype == object:
  230:             mark = pytest.mark.xfail(reason="Dimension mismatch in np.concatenate")
  231:             request.applymarker(mark)
  232: 
  233:         super().test_insert(data)
  234: 
  235:     @skip_nested
  236:     def test_insert_invalid(self, data, invalid_scalar):
  237:         # NumpyExtensionArray[object] can hold anything, so skip
  238:         super().test_insert_invalid(data, invalid_scalar)
  239: 
  240:     divmod_exc = None
  241:     series_scalar_exc = None
  242:     frame_scalar_exc = None
  243:     series_array_exc = None
  244: 
  245:     def test_divmod(self, data):
  246:         divmod_exc = None
  247:         if data.dtype.kind == "O":
  248:             divmod_exc = TypeError
  249:         self.divmod_exc = divmod_exc
  250:         super().test_divmod(data)
  251: 
  252:     def test_divmod_series_array(self, data):
  253:         ser = pd.Series(data)
  254:         exc = None
  255:         if data.dtype.kind == "O":
  256:             exc = TypeError
  257:             self.divmod_exc = exc
  258:         self._check_divmod_op(ser, divmod, data)
  259: 
  260:     def test_arith_series_with_scalar(self, data, all_arithmetic_operators, request):
  261:         opname = all_arithmetic_operators
  262:         series_scalar_exc = None
  263:         if data.dtype.numpy_dtype == object:
  264:             if opname in ["__mul__", "__rmul__"]:
  265:                 mark = pytest.mark.xfail(
  266:                     reason="the Series.combine step raises but not the Series method."
  267:                 )
  268:                 request.node.add_marker(mark)
  269:             series_scalar_exc = TypeError
  270:         self.series_scalar_exc = series_scalar_exc
  271:         super().test_arith_series_with_scalar(data, all_arithmetic_operators)
  272: 
  273:     def test_arith_series_with_array(self, data, all_arithmetic_operators):
  274:         opname = all_arithmetic_operators
  275:         series_array_exc = None
  276:         if data.dtype.numpy_dtype == object and opname not in ["__add__", "__radd__"]:
  277:             series_array_exc = TypeError
  278:         self.series_array_exc = series_array_exc
  279:         super().test_arith_series_with_array(data, all_arithmetic_operators)
  280: 
  281:     def test_arith_frame_with_scalar(self, data, all_arithmetic_operators, request):
  282:         opname = all_arithmetic_operators
  283:         frame_scalar_exc = None
  284:         if data.dtype.numpy_dtype == object:
  285:             if opname in ["__mul__", "__rmul__"]:
  286:                 mark = pytest.mark.xfail(
  287:                     reason="the Series.combine step raises but not the Series method."
  288:                 )
  289:                 request.node.add_marker(mark)
  290:             frame_scalar_exc = TypeError
  291:         self.frame_scalar_exc = frame_scalar_exc
  292:         super().test_arith_frame_with_scalar(data, all_arithmetic_operators)
  293: 
  294:     def _supports_reduction(self, ser: pd.Series, op_name: str) -> bool:
  295:         if ser.dtype.kind == "O":
  296:             return op_name in ["sum", "min", "max", "any", "all"]
  297:         return True
  298: 
  299:     def check_reduce(self, ser: pd.Series, op_name: str, skipna: bool):
  300:         res_op = getattr(ser, op_name)
  301:         # avoid coercing int -> float. Just cast to the actual numpy type.
  302:         # error: Item "ExtensionDtype" of "dtype[Any] | ExtensionDtype" has
  303:         # no attribute "numpy_dtype"
  304:         cmp_dtype = ser.dtype.numpy_dtype  # type: ignore[union-attr]
  305:         alt = ser.astype(cmp_dtype)
  306:         exp_op = getattr(alt, op_name)
  307:         if op_name == "count":
  308:             result = res_op()
  309:             expected = exp_op()
  310:         else:
  311:             result = res_op(skipna=skipna)
  312:             expected = exp_op(skipna=skipna)
  313:         tm.assert_almost_equal(result, expected)
  314: 
  315:     @pytest.mark.skip("TODO: tests not written yet")
  316:     @pytest.mark.parametrize("skipna", [True, False])
  317:     def test_reduce_frame(self, data, all_numeric_reductions, skipna):
  318:         pass
  319: 
  320:     @skip_nested
  321:     def test_fillna_series(self, data_missing):
  322:         # Non-scalar "scalar" values.
  323:         super().test_fillna_series(data_missing)
  324: 
  325:     @skip_nested
  326:     def test_fillna_frame(self, data_missing):
  327:         # Non-scalar "scalar" values.
  328:         super().test_fillna_frame(data_missing)
  329: 
  330:     @skip_nested
  331:     def test_setitem_invalid(self, data, invalid_scalar):
  332:         # object dtype can hold anything, so doesn't raise
  333:         super().test_setitem_invalid(data, invalid_scalar)
  334: 
  335:     @skip_nested
  336:     def test_setitem_sequence_broadcasts(self, data, box_in_series):
  337:         # ValueError: cannot set using a list-like indexer with a different
  338:         # length than the value
  339:         super().test_setitem_sequence_broadcasts(data, box_in_series)
  340: 
  341:     @skip_nested
  342:     @pytest.mark.parametrize("setter", ["loc", None])
  343:     def test_setitem_mask_broadcast(self, data, setter):
  344:         # ValueError: cannot set using a list-like indexer with a different
  345:         # length than the value
  346:         super().test_setitem_mask_broadcast(data, setter)
  347: 
  348:     @skip_nested
  349:     def test_setitem_scalar_key_sequence_raise(self, data):
  350:         # Failed: DID NOT RAISE <class 'ValueError'>
  351:         super().test_setitem_scalar_key_sequence_raise(data)
  352: 
  353:     # TODO: there is some issue with NumpyExtensionArray, therefore,
  354:     #   skip the setitem test for now, and fix it later (GH 31446)
  355: 
  356:     @skip_nested
  357:     @pytest.mark.parametrize(
  358:         "mask",
  359:         [
  360:             np.array([True, True, True, False, False]),
  361:             pd.array([True, True, True, False, False], dtype="boolean"),
  362:         ],
  363:         ids=["numpy-array", "boolean-array"],
  364:     )
  365:     def test_setitem_mask(self, data, mask, box_in_series):
  366:         super().test_setitem_mask(data, mask, box_in_series)
  367: 
  368:     @skip_nested
  369:     @pytest.mark.parametrize(
  370:         "idx",
  371:         [[0, 1, 2], pd.array([0, 1, 2], dtype="Int64"), np.array([0, 1, 2])],
  372:         ids=["list", "integer-array", "numpy-array"],
  373:     )
  374:     def test_setitem_integer_array(self, data, idx, box_in_series):
  375:         super().test_setitem_integer_array(data, idx, box_in_series)
  376: 
  377:     @pytest.mark.parametrize(
  378:         "idx, box_in_series",
  379:         [
  380:             ([0, 1, 2, pd.NA], False),
  381:             pytest.param([0, 1, 2, pd.NA], True, marks=pytest.mark.xfail),
  382:             (pd.array([0, 1, 2, pd.NA], dtype="Int64"), False),
  383:             (pd.array([0, 1, 2, pd.NA], dtype="Int64"), False),
  384:         ],
  385:         ids=["list-False", "list-True", "integer-array-False", "integer-array-True"],
  386:     )
  387:     def test_setitem_integer_with_missing_raises(self, data, idx, box_in_series):
  388:         super().test_setitem_integer_with_missing_raises(data, idx, box_in_series)
  389: 
  390:     @skip_nested
  391:     def test_setitem_slice(self, data, box_in_series):
  392:         super().test_setitem_slice(data, box_in_series)
  393: 
  394:     @skip_nested
  395:     def test_setitem_loc_iloc_slice(self, data):
  396:         super().test_setitem_loc_iloc_slice(data)
  397: 
  398:     def test_setitem_with_expansion_dataframe_column(self, data, full_indexer):
  399:         # https://github.com/pandas-dev/pandas/issues/32395
  400:         df = expected = pd.DataFrame({"data": pd.Series(data)})
  401:         result = pd.DataFrame(index=df.index)
  402: 
  403:         # because result has object dtype, the attempt to do setting inplace
  404:         #  is successful, and object dtype is retained
  405:         key = full_indexer(df)
  406:         result.loc[key, "data"] = df["data"]
  407: 
  408:         # base class method has expected = df; NumpyExtensionArray behaves oddly because
  409:         #  we patch _typ for these tests.
  410:         if data.dtype.numpy_dtype != object:
  411:             if not isinstance(key, slice) or key != slice(None):
  412:                 expected = pd.DataFrame({"data": data.to_numpy()})
  413:         tm.assert_frame_equal(result, expected, check_column_type=False)
  414: 
  415:     @pytest.mark.xfail(reason="NumpyEADtype is unpacked")
  416:     def test_index_from_listlike_with_dtype(self, data):
  417:         super().test_index_from_listlike_with_dtype(data)
  418: 
  419:     @skip_nested
  420:     @pytest.mark.parametrize("engine", ["c", "python"])
  421:     def test_EA_types(self, engine, data, request):
  422:         super().test_EA_types(engine, data, request)
  423: 
  424: 
  425: class Test2DCompat(base.NDArrayBacked2DTests):
  426:     pass
