    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas import DataFrame
    5: import pandas._testing as tm
    6: from pandas.tests.copy_view.util import get_array
    7: 
    8: 
    9: def test_assigning_to_same_variable_removes_references(using_copy_on_write):
   10:     df = DataFrame({"a": [1, 2, 3]})
   11:     df = df.reset_index()
   12:     if using_copy_on_write:
   13:         assert df._mgr._has_no_reference(1)
   14:     arr = get_array(df, "a")
   15:     df.iloc[0, 1] = 100  # Write into a
   16: 
   17:     assert np.shares_memory(arr, get_array(df, "a"))
   18: 
   19: 
   20: def test_setitem_dont_track_unnecessary_references(using_copy_on_write):
   21:     df = DataFrame({"a": [1, 2, 3], "b": 1, "c": 1})
   22: 
   23:     df["b"] = 100
   24:     arr = get_array(df, "a")
   25:     # We split the block in setitem, if we are not careful the new blocks will
   26:     # reference each other triggering a copy
   27:     df.iloc[0, 0] = 100
   28:     assert np.shares_memory(arr, get_array(df, "a"))
   29: 
   30: 
   31: def test_setitem_with_view_copies(using_copy_on_write, warn_copy_on_write):
   32:     df = DataFrame({"a": [1, 2, 3], "b": 1, "c": 1})
   33:     view = df[:]
   34:     expected = df.copy()
   35: 
   36:     df["b"] = 100
   37:     arr = get_array(df, "a")
   38:     with tm.assert_cow_warning(warn_copy_on_write):
   39:         df.iloc[0, 0] = 100  # Check that we correctly track reference
   40:     if using_copy_on_write:
   41:         assert not np.shares_memory(arr, get_array(df, "a"))
   42:         tm.assert_frame_equal(view, expected)
   43: 
   44: 
   45: def test_setitem_with_view_invalidated_does_not_copy(
   46:     using_copy_on_write, warn_copy_on_write, request
   47: ):
   48:     df = DataFrame({"a": [1, 2, 3], "b": 1, "c": 1})
   49:     view = df[:]
   50: 
   51:     df["b"] = 100
   52:     arr = get_array(df, "a")
   53:     view = None  # noqa: F841
   54:     # TODO(CoW-warn) false positive? -> block gets split because of `df["b"] = 100`
   55:     # which introduces additional refs, even when those of `view` go out of scopes
   56:     with tm.assert_cow_warning(warn_copy_on_write):
   57:         df.iloc[0, 0] = 100
   58:     if using_copy_on_write:
   59:         # Setitem split the block. Since the old block shared data with view
   60:         # all the new blocks are referencing view and each other. When view
   61:         # goes out of scope, they don't share data with any other block,
   62:         # so we should not trigger a copy
   63:         mark = pytest.mark.xfail(
   64:             reason="blk.delete does not track references correctly"
   65:         )
   66:         request.applymarker(mark)
   67:         assert np.shares_memory(arr, get_array(df, "a"))
   68: 
   69: 
   70: def test_out_of_scope(using_copy_on_write):
   71:     def func():
   72:         df = DataFrame({"a": [1, 2], "b": 1.5, "c": 1})
   73:         # create some subset
   74:         result = df[["a", "b"]]
   75:         return result
   76: 
   77:     result = func()
   78:     if using_copy_on_write:
   79:         assert not result._mgr.blocks[0].refs.has_reference()
   80:         assert not result._mgr.blocks[1].refs.has_reference()
   81: 
   82: 
   83: def test_delete(using_copy_on_write):
   84:     df = DataFrame(
   85:         np.random.default_rng(2).standard_normal((4, 3)), columns=["a", "b", "c"]
   86:     )
   87:     del df["b"]
   88:     if using_copy_on_write:
   89:         assert not df._mgr.blocks[0].refs.has_reference()
   90:         assert not df._mgr.blocks[1].refs.has_reference()
   91: 
   92:     df = df[["a"]]
   93:     if using_copy_on_write:
   94:         assert not df._mgr.blocks[0].refs.has_reference()
   95: 
   96: 
   97: def test_delete_reference(using_copy_on_write):
   98:     df = DataFrame(
   99:         np.random.default_rng(2).standard_normal((4, 3)), columns=["a", "b", "c"]
  100:     )
  101:     x = df[:]
  102:     del df["b"]
  103:     if using_copy_on_write:
  104:         assert df._mgr.blocks[0].refs.has_reference()
  105:         assert df._mgr.blocks[1].refs.has_reference()
  106:         assert x._mgr.blocks[0].refs.has_reference()
