    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas.compat import PY311
    5: from pandas.errors import (
    6:     ChainedAssignmentError,
    7:     SettingWithCopyWarning,
    8: )
    9: 
   10: from pandas import (
   11:     DataFrame,
   12:     option_context,
   13: )
   14: import pandas._testing as tm
   15: 
   16: 
   17: def test_methods_iloc_warn(using_copy_on_write):
   18:     if not using_copy_on_write:
   19:         df = DataFrame({"a": [1, 2, 3], "b": 1})
   20:         with tm.assert_cow_warning(match="A value"):
   21:             df.iloc[:, 0].replace(1, 5, inplace=True)
   22: 
   23:         with tm.assert_cow_warning(match="A value"):
   24:             df.iloc[:, 0].fillna(1, inplace=True)
   25: 
   26:         with tm.assert_cow_warning(match="A value"):
   27:             df.iloc[:, 0].interpolate(inplace=True)
   28: 
   29:         with tm.assert_cow_warning(match="A value"):
   30:             df.iloc[:, 0].ffill(inplace=True)
   31: 
   32:         with tm.assert_cow_warning(match="A value"):
   33:             df.iloc[:, 0].bfill(inplace=True)
   34: 
   35: 
   36: @pytest.mark.parametrize(
   37:     "func, args",
   38:     [
   39:         ("replace", (4, 5)),
   40:         ("fillna", (1,)),
   41:         ("interpolate", ()),
   42:         ("bfill", ()),
   43:         ("ffill", ()),
   44:     ],
   45: )
   46: def test_methods_iloc_getitem_item_cache(
   47:     func, args, using_copy_on_write, warn_copy_on_write
   48: ):
   49:     # ensure we don't incorrectly raise chained assignment warning because
   50:     # of the item cache / iloc not setting the item cache
   51:     df_orig = DataFrame({"a": [1, 2, 3], "b": 1})
   52: 
   53:     df = df_orig.copy()
   54:     ser = df.iloc[:, 0]
   55:     getattr(ser, func)(*args, inplace=True)
   56: 
   57:     # parent that holds item_cache is dead, so don't increase ref count
   58:     df = df_orig.copy()
   59:     ser = df.copy()["a"]
   60:     getattr(ser, func)(*args, inplace=True)
   61: 
   62:     df = df_orig.copy()
   63:     df["a"]  # populate the item_cache
   64:     ser = df.iloc[:, 0]  # iloc creates a new object
   65:     getattr(ser, func)(*args, inplace=True)
   66: 
   67:     df = df_orig.copy()
   68:     df["a"]  # populate the item_cache
   69:     ser = df["a"]
   70:     getattr(ser, func)(*args, inplace=True)
   71: 
   72:     df = df_orig.copy()
   73:     df["a"]  # populate the item_cache
   74:     # TODO(CoW-warn) because of the usage of *args, this doesn't warn on Py3.11+
   75:     if using_copy_on_write:
   76:         with tm.raises_chained_assignment_error(not PY311):
   77:             getattr(df["a"], func)(*args, inplace=True)
   78:     else:
   79:         with tm.assert_cow_warning(not PY311, match="A value"):
   80:             getattr(df["a"], func)(*args, inplace=True)
   81: 
   82:     df = df_orig.copy()
   83:     ser = df["a"]  # populate the item_cache and keep ref
   84:     if using_copy_on_write:
   85:         with tm.raises_chained_assignment_error(not PY311):
   86:             getattr(df["a"], func)(*args, inplace=True)
   87:     else:
   88:         # ideally also warns on the default mode, but the ser' _cacher
   89:         # messes up the refcount + even in warning mode this doesn't trigger
   90:         # the warning of Py3.1+ (see above)
   91:         with tm.assert_cow_warning(warn_copy_on_write and not PY311, match="A value"):
   92:             getattr(df["a"], func)(*args, inplace=True)
   93: 
   94: 
   95: def test_methods_iloc_getitem_item_cache_fillna(
   96:     using_copy_on_write, warn_copy_on_write
   97: ):
   98:     # ensure we don't incorrectly raise chained assignment warning because
   99:     # of the item cache / iloc not setting the item cache
  100:     df_orig = DataFrame({"a": [1, 2, 3], "b": 1})
  101: 
  102:     df = df_orig.copy()
  103:     ser = df.iloc[:, 0]
  104:     ser.fillna(1, inplace=True)
  105: 
  106:     # parent that holds item_cache is dead, so don't increase ref count
  107:     df = df_orig.copy()
  108:     ser = df.copy()["a"]
  109:     ser.fillna(1, inplace=True)
  110: 
  111:     df = df_orig.copy()
  112:     df["a"]  # populate the item_cache
  113:     ser = df.iloc[:, 0]  # iloc creates a new object
  114:     ser.fillna(1, inplace=True)
  115: 
  116:     df = df_orig.copy()
  117:     df["a"]  # populate the item_cache
  118:     ser = df["a"]
  119:     ser.fillna(1, inplace=True)
  120: 
  121:     df = df_orig.copy()
  122:     df["a"]  # populate the item_cache
  123:     if using_copy_on_write:
  124:         with tm.raises_chained_assignment_error():
  125:             df["a"].fillna(1, inplace=True)
  126:     else:
  127:         with tm.assert_cow_warning(match="A value"):
  128:             df["a"].fillna(1, inplace=True)
  129: 
  130:     df = df_orig.copy()
  131:     ser = df["a"]  # populate the item_cache and keep ref
  132:     if using_copy_on_write:
  133:         with tm.raises_chained_assignment_error():
  134:             df["a"].fillna(1, inplace=True)
  135:     else:
  136:         # TODO(CoW-warn) ideally also warns on the default mode, but the ser' _cacher
  137:         # messes up the refcount
  138:         with tm.assert_cow_warning(warn_copy_on_write, match="A value"):
  139:             df["a"].fillna(1, inplace=True)
  140: 
  141: 
  142: # TODO(CoW-warn) expand the cases
  143: @pytest.mark.parametrize(
  144:     "indexer", [0, [0, 1], slice(0, 2), np.array([True, False, True])]
  145: )
  146: def test_series_setitem(indexer, using_copy_on_write, warn_copy_on_write):
  147:     # ensure we only get a single warning for those typical cases of chained
  148:     # assignment
  149:     df = DataFrame({"a": [1, 2, 3], "b": 1})
  150: 
  151:     # using custom check instead of tm.assert_produces_warning because that doesn't
  152:     # fail if multiple warnings are raised
  153:     with pytest.warns() as record:
  154:         df["a"][indexer] = 0
  155:     assert len(record) == 1
  156:     if using_copy_on_write:
  157:         assert record[0].category == ChainedAssignmentError
  158:     else:
  159:         assert record[0].category == FutureWarning
  160:         assert "ChainedAssignmentError" in record[0].message.args[0]
  161: 
  162: 
  163: @pytest.mark.filterwarnings("ignore::pandas.errors.SettingWithCopyWarning")
  164: @pytest.mark.parametrize(
  165:     "indexer", ["a", ["a", "b"], slice(0, 2), np.array([True, False, True])]
  166: )
  167: def test_frame_setitem(indexer, using_copy_on_write):
  168:     df = DataFrame({"a": [1, 2, 3, 4, 5], "b": 1})
  169: 
  170:     extra_warnings = () if using_copy_on_write else (SettingWithCopyWarning,)
  171: 
  172:     with option_context("chained_assignment", "warn"):
  173:         with tm.raises_chained_assignment_error(extra_warnings=extra_warnings):
  174:             df[0:3][indexer] = 10
