    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas import (
    5:     NA,
    6:     ArrowDtype,
    7:     DataFrame,
    8:     Interval,
    9:     NaT,
   10:     Series,
   11:     Timestamp,
   12:     interval_range,
   13:     option_context,
   14: )
   15: import pandas._testing as tm
   16: from pandas.tests.copy_view.util import get_array
   17: 
   18: 
   19: @pytest.mark.parametrize("method", ["pad", "nearest", "linear"])
   20: def test_interpolate_no_op(using_copy_on_write, method):
   21:     df = DataFrame({"a": [1, 2]})
   22:     df_orig = df.copy()
   23: 
   24:     warn = None
   25:     if method == "pad":
   26:         warn = FutureWarning
   27:     msg = "DataFrame.interpolate with method=pad is deprecated"
   28:     with tm.assert_produces_warning(warn, match=msg):
   29:         result = df.interpolate(method=method)
   30: 
   31:     if using_copy_on_write:
   32:         assert np.shares_memory(get_array(result, "a"), get_array(df, "a"))
   33:     else:
   34:         assert not np.shares_memory(get_array(result, "a"), get_array(df, "a"))
   35: 
   36:     result.iloc[0, 0] = 100
   37: 
   38:     if using_copy_on_write:
   39:         assert not np.shares_memory(get_array(result, "a"), get_array(df, "a"))
   40:     tm.assert_frame_equal(df, df_orig)
   41: 
   42: 
   43: @pytest.mark.parametrize("func", ["ffill", "bfill"])
   44: def test_interp_fill_functions(using_copy_on_write, func):
   45:     # Check that these takes the same code paths as interpolate
   46:     df = DataFrame({"a": [1, 2]})
   47:     df_orig = df.copy()
   48: 
   49:     result = getattr(df, func)()
   50: 
   51:     if using_copy_on_write:
   52:         assert np.shares_memory(get_array(result, "a"), get_array(df, "a"))
   53:     else:
   54:         assert not np.shares_memory(get_array(result, "a"), get_array(df, "a"))
   55: 
   56:     result.iloc[0, 0] = 100
   57: 
   58:     if using_copy_on_write:
   59:         assert not np.shares_memory(get_array(result, "a"), get_array(df, "a"))
   60:     tm.assert_frame_equal(df, df_orig)
   61: 
   62: 
   63: @pytest.mark.parametrize("func", ["ffill", "bfill"])
   64: @pytest.mark.parametrize(
   65:     "vals", [[1, np.nan, 2], [Timestamp("2019-12-31"), NaT, Timestamp("2020-12-31")]]
   66: )
   67: def test_interpolate_triggers_copy(using_copy_on_write, vals, func):
   68:     df = DataFrame({"a": vals})
   69:     result = getattr(df, func)()
   70: 
   71:     assert not np.shares_memory(get_array(result, "a"), get_array(df, "a"))
   72:     if using_copy_on_write:
   73:         # Check that we don't have references when triggering a copy
   74:         assert result._mgr._has_no_reference(0)
   75: 
   76: 
   77: @pytest.mark.parametrize(
   78:     "vals", [[1, np.nan, 2], [Timestamp("2019-12-31"), NaT, Timestamp("2020-12-31")]]
   79: )
   80: def test_interpolate_inplace_no_reference_no_copy(using_copy_on_write, vals):
   81:     df = DataFrame({"a": vals})
   82:     arr = get_array(df, "a")
   83:     df.interpolate(method="linear", inplace=True)
   84: 
   85:     assert np.shares_memory(arr, get_array(df, "a"))
   86:     if using_copy_on_write:
   87:         # Check that we don't have references when triggering a copy
   88:         assert df._mgr._has_no_reference(0)
   89: 
   90: 
   91: @pytest.mark.parametrize(
   92:     "vals", [[1, np.nan, 2], [Timestamp("2019-12-31"), NaT, Timestamp("2020-12-31")]]
   93: )
   94: def test_interpolate_inplace_with_refs(using_copy_on_write, vals, warn_copy_on_write):
   95:     df = DataFrame({"a": [1, np.nan, 2]})
   96:     df_orig = df.copy()
   97:     arr = get_array(df, "a")
   98:     view = df[:]
   99:     with tm.assert_cow_warning(warn_copy_on_write):
  100:         df.interpolate(method="linear", inplace=True)
  101: 
  102:     if using_copy_on_write:
  103:         # Check that copy was triggered in interpolate and that we don't
  104:         # have any references left
  105:         assert not np.shares_memory(arr, get_array(df, "a"))
  106:         tm.assert_frame_equal(df_orig, view)
  107:         assert df._mgr._has_no_reference(0)
  108:         assert view._mgr._has_no_reference(0)
  109:     else:
  110:         assert np.shares_memory(arr, get_array(df, "a"))
  111: 
  112: 
  113: @pytest.mark.parametrize("func", ["ffill", "bfill"])
  114: @pytest.mark.parametrize("dtype", ["float64", "Float64"])
  115: def test_interp_fill_functions_inplace(
  116:     using_copy_on_write, func, warn_copy_on_write, dtype
  117: ):
  118:     # Check that these takes the same code paths as interpolate
  119:     df = DataFrame({"a": [1, np.nan, 2]}, dtype=dtype)
  120:     df_orig = df.copy()
  121:     arr = get_array(df, "a")
  122:     view = df[:]
  123: 
  124:     with tm.assert_cow_warning(warn_copy_on_write and dtype == "float64"):
  125:         getattr(df, func)(inplace=True)
  126: 
  127:     if using_copy_on_write:
  128:         # Check that copy was triggered in interpolate and that we don't
  129:         # have any references left
  130:         assert not np.shares_memory(arr, get_array(df, "a"))
  131:         tm.assert_frame_equal(df_orig, view)
  132:         assert df._mgr._has_no_reference(0)
  133:         assert view._mgr._has_no_reference(0)
  134:     else:
  135:         assert np.shares_memory(arr, get_array(df, "a")) is (dtype == "float64")
  136: 
  137: 
  138: def test_interpolate_cleaned_fill_method(using_copy_on_write):
  139:     # Check that "method is set to None" case works correctly
  140:     df = DataFrame({"a": ["a", np.nan, "c"], "b": 1})
  141:     df_orig = df.copy()
  142: 
  143:     msg = "DataFrame.interpolate with object dtype"
  144:     with tm.assert_produces_warning(FutureWarning, match=msg):
  145:         result = df.interpolate(method="linear")
  146: 
  147:     if using_copy_on_write:
  148:         assert np.shares_memory(get_array(result, "a"), get_array(df, "a"))
  149:     else:
  150:         assert not np.shares_memory(get_array(result, "a"), get_array(df, "a"))
  151: 
  152:     result.iloc[0, 0] = Timestamp("2021-12-31")
  153: 
  154:     if using_copy_on_write:
  155:         assert not np.shares_memory(get_array(result, "a"), get_array(df, "a"))
  156:     tm.assert_frame_equal(df, df_orig)
  157: 
  158: 
  159: def test_interpolate_object_convert_no_op(using_copy_on_write):
  160:     df = DataFrame({"a": ["a", "b", "c"], "b": 1})
  161:     arr_a = get_array(df, "a")
  162:     msg = "DataFrame.interpolate with method=pad is deprecated"
  163:     with tm.assert_produces_warning(FutureWarning, match=msg):
  164:         df.interpolate(method="pad", inplace=True)
  165: 
  166:     # Now CoW makes a copy, it should not!
  167:     if using_copy_on_write:
  168:         assert df._mgr._has_no_reference(0)
  169:         assert np.shares_memory(arr_a, get_array(df, "a"))
  170: 
  171: 
  172: def test_interpolate_object_convert_copies(using_copy_on_write):
  173:     df = DataFrame({"a": Series([1, 2], dtype=object), "b": 1})
  174:     arr_a = get_array(df, "a")
  175:     msg = "DataFrame.interpolate with method=pad is deprecated"
  176:     with tm.assert_produces_warning(FutureWarning, match=msg):
  177:         df.interpolate(method="pad", inplace=True)
  178: 
  179:     if using_copy_on_write:
  180:         assert df._mgr._has_no_reference(0)
  181:         assert not np.shares_memory(arr_a, get_array(df, "a"))
  182: 
  183: 
  184: def test_interpolate_downcast(using_copy_on_write):
  185:     df = DataFrame({"a": [1, np.nan, 2.5], "b": 1})
  186:     arr_a = get_array(df, "a")
  187:     msg = "DataFrame.interpolate with method=pad is deprecated"
  188:     with tm.assert_produces_warning(FutureWarning, match=msg):
  189:         df.interpolate(method="pad", inplace=True, downcast="infer")
  190: 
  191:     if using_copy_on_write:
  192:         assert df._mgr._has_no_reference(0)
  193:     assert np.shares_memory(arr_a, get_array(df, "a"))
  194: 
  195: 
  196: def test_interpolate_downcast_reference_triggers_copy(using_copy_on_write):
  197:     df = DataFrame({"a": [1, np.nan, 2.5], "b": 1})
  198:     df_orig = df.copy()
  199:     arr_a = get_array(df, "a")
  200:     view = df[:]
  201:     msg = "DataFrame.interpolate with method=pad is deprecated"
  202:     with tm.assert_produces_warning(FutureWarning, match=msg):
  203:         df.interpolate(method="pad", inplace=True, downcast="infer")
  204: 
  205:     if using_copy_on_write:
  206:         assert df._mgr._has_no_reference(0)
  207:         assert not np.shares_memory(arr_a, get_array(df, "a"))
  208:         tm.assert_frame_equal(df_orig, view)
  209:     else:
  210:         tm.assert_frame_equal(df, view)
  211: 
  212: 
  213: def test_fillna(using_copy_on_write):
  214:     df = DataFrame({"a": [1.5, np.nan], "b": 1})
  215:     df_orig = df.copy()
  216: 
  217:     df2 = df.fillna(5.5)
  218:     if using_copy_on_write:
  219:         assert np.shares_memory(get_array(df, "b"), get_array(df2, "b"))
  220:     else:
  221:         assert not np.shares_memory(get_array(df, "b"), get_array(df2, "b"))
  222: 
  223:     df2.iloc[0, 1] = 100
  224:     tm.assert_frame_equal(df_orig, df)
  225: 
  226: 
  227: def test_fillna_dict(using_copy_on_write):
  228:     df = DataFrame({"a": [1.5, np.nan], "b": 1})
  229:     df_orig = df.copy()
  230: 
  231:     df2 = df.fillna({"a": 100.5})
  232:     if using_copy_on_write:
  233:         assert np.shares_memory(get_array(df, "b"), get_array(df2, "b"))
  234:         assert not np.shares_memory(get_array(df, "a"), get_array(df2, "a"))
  235:     else:
  236:         assert not np.shares_memory(get_array(df, "b"), get_array(df2, "b"))
  237: 
  238:     df2.iloc[0, 1] = 100
  239:     tm.assert_frame_equal(df_orig, df)
  240: 
  241: 
  242: @pytest.mark.parametrize("downcast", [None, False])
  243: def test_fillna_inplace(using_copy_on_write, downcast):
  244:     df = DataFrame({"a": [1.5, np.nan], "b": 1})
  245:     arr_a = get_array(df, "a")
  246:     arr_b = get_array(df, "b")
  247: 
  248:     msg = "The 'downcast' keyword in fillna is deprecated"
  249:     with tm.assert_produces_warning(FutureWarning, match=msg):
  250:         df.fillna(5.5, inplace=True, downcast=downcast)
  251:     assert np.shares_memory(get_array(df, "a"), arr_a)
  252:     assert np.shares_memory(get_array(df, "b"), arr_b)
  253:     if using_copy_on_write:
  254:         assert df._mgr._has_no_reference(0)
  255:         assert df._mgr._has_no_reference(1)
  256: 
  257: 
  258: def test_fillna_inplace_reference(using_copy_on_write, warn_copy_on_write):
  259:     df = DataFrame({"a": [1.5, np.nan], "b": 1})
  260:     df_orig = df.copy()
  261:     arr_a = get_array(df, "a")
  262:     arr_b = get_array(df, "b")
  263:     view = df[:]
  264: 
  265:     with tm.assert_cow_warning(warn_copy_on_write):
  266:         df.fillna(5.5, inplace=True)
  267:     if using_copy_on_write:
  268:         assert not np.shares_memory(get_array(df, "a"), arr_a)
  269:         assert np.shares_memory(get_array(df, "b"), arr_b)
  270:         assert view._mgr._has_no_reference(0)
  271:         assert df._mgr._has_no_reference(0)
  272:         tm.assert_frame_equal(view, df_orig)
  273:     else:
  274:         assert np.shares_memory(get_array(df, "a"), arr_a)
  275:         assert np.shares_memory(get_array(df, "b"), arr_b)
  276:     expected = DataFrame({"a": [1.5, 5.5], "b": 1})
  277:     tm.assert_frame_equal(df, expected)
  278: 
  279: 
  280: def test_fillna_interval_inplace_reference(using_copy_on_write, warn_copy_on_write):
  281:     # Set dtype explicitly to avoid implicit cast when setting nan
  282:     ser = Series(
  283:         interval_range(start=0, end=5), name="a", dtype="interval[float64, right]"
  284:     )
  285:     ser.iloc[1] = np.nan
  286: 
  287:     ser_orig = ser.copy()
  288:     view = ser[:]
  289:     with tm.assert_cow_warning(warn_copy_on_write):
  290:         ser.fillna(value=Interval(left=0, right=5), inplace=True)
  291: 
  292:     if using_copy_on_write:
  293:         assert not np.shares_memory(
  294:             get_array(ser, "a").left.values, get_array(view, "a").left.values
  295:         )
  296:         tm.assert_series_equal(view, ser_orig)
  297:     else:
  298:         assert np.shares_memory(
  299:             get_array(ser, "a").left.values, get_array(view, "a").left.values
  300:         )
  301: 
  302: 
  303: def test_fillna_series_empty_arg(using_copy_on_write):
  304:     ser = Series([1, np.nan, 2])
  305:     ser_orig = ser.copy()
  306:     result = ser.fillna({})
  307: 
  308:     if using_copy_on_write:
  309:         assert np.shares_memory(get_array(ser), get_array(result))
  310:     else:
  311:         assert not np.shares_memory(get_array(ser), get_array(result))
  312: 
  313:     ser.iloc[0] = 100.5
  314:     tm.assert_series_equal(ser_orig, result)
  315: 
  316: 
  317: def test_fillna_series_empty_arg_inplace(using_copy_on_write):
  318:     ser = Series([1, np.nan, 2])
  319:     arr = get_array(ser)
  320:     ser.fillna({}, inplace=True)
  321: 
  322:     assert np.shares_memory(get_array(ser), arr)
  323:     if using_copy_on_write:
  324:         assert ser._mgr._has_no_reference(0)
  325: 
  326: 
  327: def test_fillna_ea_noop_shares_memory(
  328:     using_copy_on_write, any_numeric_ea_and_arrow_dtype
  329: ):
  330:     df = DataFrame({"a": [1, NA, 3], "b": 1}, dtype=any_numeric_ea_and_arrow_dtype)
  331:     df_orig = df.copy()
  332:     df2 = df.fillna(100)
  333: 
  334:     assert not np.shares_memory(get_array(df, "a"), get_array(df2, "a"))
  335: 
  336:     if using_copy_on_write:
  337:         assert np.shares_memory(get_array(df, "b"), get_array(df2, "b"))
  338:         assert not df2._mgr._has_no_reference(1)
  339:     elif isinstance(df.dtypes.iloc[0], ArrowDtype):
  340:         # arrow is immutable, so no-ops do not need to copy underlying array
  341:         assert np.shares_memory(get_array(df, "b"), get_array(df2, "b"))
  342:     else:
  343:         assert not np.shares_memory(get_array(df, "b"), get_array(df2, "b"))
  344: 
  345:     tm.assert_frame_equal(df_orig, df)
  346: 
  347:     df2.iloc[0, 1] = 100
  348:     if using_copy_on_write:
  349:         assert not np.shares_memory(get_array(df, "b"), get_array(df2, "b"))
  350:         assert df2._mgr._has_no_reference(1)
  351:         assert df._mgr._has_no_reference(1)
  352:     tm.assert_frame_equal(df_orig, df)
  353: 
  354: 
  355: def test_fillna_inplace_ea_noop_shares_memory(
  356:     using_copy_on_write, warn_copy_on_write, any_numeric_ea_and_arrow_dtype
  357: ):
  358:     df = DataFrame({"a": [1, NA, 3], "b": 1}, dtype=any_numeric_ea_and_arrow_dtype)
  359:     df_orig = df.copy()
  360:     view = df[:]
  361:     with tm.assert_cow_warning(warn_copy_on_write):
  362:         df.fillna(100, inplace=True)
  363: 
  364:     if isinstance(df["a"].dtype, ArrowDtype) or using_copy_on_write:
  365:         assert not np.shares_memory(get_array(df, "a"), get_array(view, "a"))
  366:     else:
  367:         # MaskedArray can actually respect inplace=True
  368:         assert np.shares_memory(get_array(df, "a"), get_array(view, "a"))
  369: 
  370:     assert np.shares_memory(get_array(df, "b"), get_array(view, "b"))
  371:     if using_copy_on_write:
  372:         assert not df._mgr._has_no_reference(1)
  373:         assert not view._mgr._has_no_reference(1)
  374: 
  375:     with tm.assert_cow_warning(
  376:         warn_copy_on_write and "pyarrow" not in any_numeric_ea_and_arrow_dtype
  377:     ):
  378:         df.iloc[0, 1] = 100
  379:     if isinstance(df["a"].dtype, ArrowDtype) or using_copy_on_write:
  380:         tm.assert_frame_equal(df_orig, view)
  381:     else:
  382:         # we actually have a view
  383:         tm.assert_frame_equal(df, view)
  384: 
  385: 
  386: def test_fillna_chained_assignment(using_copy_on_write):
  387:     df = DataFrame({"a": [1, np.nan, 2], "b": 1})
  388:     df_orig = df.copy()
  389:     if using_copy_on_write:
  390:         with tm.raises_chained_assignment_error():
  391:             df["a"].fillna(100, inplace=True)
  392:         tm.assert_frame_equal(df, df_orig)
  393: 
  394:         with tm.raises_chained_assignment_error():
  395:             df[["a"]].fillna(100, inplace=True)
  396:         tm.assert_frame_equal(df, df_orig)
  397:     else:
  398:         with tm.assert_produces_warning(None):
  399:             with option_context("mode.chained_assignment", None):
  400:                 df[["a"]].fillna(100, inplace=True)
  401: 
  402:         with tm.assert_produces_warning(None):
  403:             with option_context("mode.chained_assignment", None):
  404:                 df[df.a > 5].fillna(100, inplace=True)
  405: 
  406:         with tm.assert_produces_warning(FutureWarning, match="inplace method"):
  407:             df["a"].fillna(100, inplace=True)
  408: 
  409: 
  410: @pytest.mark.parametrize("func", ["interpolate", "ffill", "bfill"])
  411: def test_interpolate_chained_assignment(using_copy_on_write, func):
  412:     df = DataFrame({"a": [1, np.nan, 2], "b": 1})
  413:     df_orig = df.copy()
  414:     if using_copy_on_write:
  415:         with tm.raises_chained_assignment_error():
  416:             getattr(df["a"], func)(inplace=True)
  417:         tm.assert_frame_equal(df, df_orig)
  418: 
  419:         with tm.raises_chained_assignment_error():
  420:             getattr(df[["a"]], func)(inplace=True)
  421:         tm.assert_frame_equal(df, df_orig)
  422:     else:
  423:         with tm.assert_produces_warning(FutureWarning, match="inplace method"):
  424:             getattr(df["a"], func)(inplace=True)
  425: 
  426:         with tm.assert_produces_warning(None):
  427:             with option_context("mode.chained_assignment", None):
  428:                 getattr(df[["a"]], func)(inplace=True)
  429: 
  430:         with tm.assert_produces_warning(None):
  431:             with option_context("mode.chained_assignment", None):
  432:                 getattr(df[df["a"] > 1], func)(inplace=True)
