    1: import numpy as np
    2: import pytest
    3: 
    4: import pandas.util._test_decorators as td
    5: 
    6: import pandas as pd
    7: from pandas import DataFrame
    8: import pandas._testing as tm
    9: from pandas.tests.copy_view.util import get_array
   10: 
   11: 
   12: @td.skip_array_manager_invalid_test
   13: def test_consolidate(using_copy_on_write):
   14:     # create unconsolidated DataFrame
   15:     df = DataFrame({"a": [1, 2, 3], "b": [0.1, 0.2, 0.3]})
   16:     df["c"] = [4, 5, 6]
   17: 
   18:     # take a viewing subset
   19:     subset = df[:]
   20: 
   21:     # each block of subset references a block of df
   22:     assert all(blk.refs.has_reference() for blk in subset._mgr.blocks)
   23: 
   24:     # consolidate the two int64 blocks
   25:     subset._consolidate_inplace()
   26: 
   27:     # the float64 block still references the parent one because it still a view
   28:     assert subset._mgr.blocks[0].refs.has_reference()
   29:     # equivalent of assert np.shares_memory(df["b"].values, subset["b"].values)
   30:     # but avoids caching df["b"]
   31:     assert np.shares_memory(get_array(df, "b"), get_array(subset, "b"))
   32: 
   33:     # the new consolidated int64 block does not reference another
   34:     assert not subset._mgr.blocks[1].refs.has_reference()
   35: 
   36:     # the parent dataframe now also only is linked for the float column
   37:     assert not df._mgr.blocks[0].refs.has_reference()
   38:     assert df._mgr.blocks[1].refs.has_reference()
   39:     assert not df._mgr.blocks[2].refs.has_reference()
   40: 
   41:     # and modifying subset still doesn't modify parent
   42:     if using_copy_on_write:
   43:         subset.iloc[0, 1] = 0.0
   44:         assert not df._mgr.blocks[1].refs.has_reference()
   45:         assert df.loc[0, "b"] == 0.1
   46: 
   47: 
   48: @pytest.mark.single_cpu
   49: @td.skip_array_manager_invalid_test
   50: def test_switch_options():
   51:     # ensure we can switch the value of the option within one session
   52:     # (assuming data is constructed after switching)
   53: 
   54:     # using the option_context to ensure we set back to global option value
   55:     # after running the test
   56:     with pd.option_context("mode.copy_on_write", False):
   57:         df = DataFrame({"a": [1, 2, 3], "b": [0.1, 0.2, 0.3]})
   58:         subset = df[:]
   59:         subset.iloc[0, 0] = 0
   60:         # df updated with CoW disabled
   61:         assert df.iloc[0, 0] == 0
   62: 
   63:         pd.options.mode.copy_on_write = True
   64:         df = DataFrame({"a": [1, 2, 3], "b": [0.1, 0.2, 0.3]})
   65:         subset = df[:]
   66:         subset.iloc[0, 0] = 0
   67:         # df not updated with CoW enabled
   68:         assert df.iloc[0, 0] == 1
   69: 
   70:         pd.options.mode.copy_on_write = False
   71:         df = DataFrame({"a": [1, 2, 3], "b": [0.1, 0.2, 0.3]})
   72:         subset = df[:]
   73:         subset.iloc[0, 0] = 0
   74:         # df updated with CoW disabled
   75:         assert df.iloc[0, 0] == 0
   76: 
   77: 
   78: @td.skip_array_manager_invalid_test
   79: @pytest.mark.parametrize("dtype", [np.intp, np.int8])
   80: @pytest.mark.parametrize(
   81:     "locs, arr",
   82:     [
   83:         ([0], np.array([-1, -2, -3])),
   84:         ([1], np.array([-1, -2, -3])),
   85:         ([5], np.array([-1, -2, -3])),
   86:         ([0, 1], np.array([[-1, -2, -3], [-4, -5, -6]]).T),
   87:         ([0, 2], np.array([[-1, -2, -3], [-4, -5, -6]]).T),
   88:         ([0, 1, 2], np.array([[-1, -2, -3], [-4, -5, -6], [-4, -5, -6]]).T),
   89:         ([1, 2], np.array([[-1, -2, -3], [-4, -5, -6]]).T),
   90:         ([1, 3], np.array([[-1, -2, -3], [-4, -5, -6]]).T),
   91:         ([1, 3], np.array([[-1, -2, -3], [-4, -5, -6]]).T),
   92:     ],
   93: )
   94: def test_iset_splits_blocks_inplace(using_copy_on_write, locs, arr, dtype):
   95:     # Nothing currently calls iset with
   96:     # more than 1 loc with inplace=True (only happens with inplace=False)
   97:     # but ensure that it works
   98:     df = DataFrame(
   99:         {
  100:             "a": [1, 2, 3],
  101:             "b": [4, 5, 6],
  102:             "c": [7, 8, 9],
  103:             "d": [10, 11, 12],
  104:             "e": [13, 14, 15],
  105:             "f": ["a", "b", "c"],
  106:         },
  107:     )
  108:     arr = arr.astype(dtype)
  109:     df_orig = df.copy()
  110:     df2 = df.copy(deep=None)  # Trigger a CoW (if enabled, otherwise makes copy)
  111:     df2._mgr.iset(locs, arr, inplace=True)
  112: 
  113:     tm.assert_frame_equal(df, df_orig)
  114: 
  115:     if using_copy_on_write:
  116:         for i, col in enumerate(df.columns):
  117:             if i not in locs:
  118:                 assert np.shares_memory(get_array(df, col), get_array(df2, col))
  119:     else:
  120:         for col in df.columns:
  121:             assert not np.shares_memory(get_array(df, col), get_array(df2, col))
  122: 
  123: 
  124: def test_exponential_backoff():
  125:     # GH#55518
  126:     df = DataFrame({"a": [1, 2, 3]})
  127:     for i in range(490):
  128:         df.copy(deep=False)
  129: 
  130:     assert len(df._mgr.blocks[0].refs.referenced_blocks) == 491
  131: 
  132:     df = DataFrame({"a": [1, 2, 3]})
  133:     dfs = [df.copy(deep=False) for i in range(510)]
  134: 
  135:     for i in range(20):
  136:         df.copy(deep=False)
  137:     assert len(df._mgr.blocks[0].refs.referenced_blocks) == 531
  138:     assert df._mgr.blocks[0].refs.clear_counter == 1000
  139: 
  140:     for i in range(500):
  141:         df.copy(deep=False)
  142: 
  143:     # Don't reduce since we still have over 500 objects alive
  144:     assert df._mgr.blocks[0].refs.clear_counter == 1000
  145: 
  146:     dfs = dfs[:300]
  147:     for i in range(500):
  148:         df.copy(deep=False)
  149: 
  150:     # Reduce since there are less than 500 objects alive
  151:     assert df._mgr.blocks[0].refs.clear_counter == 500
