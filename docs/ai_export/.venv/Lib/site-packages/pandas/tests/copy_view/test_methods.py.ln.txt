    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas.errors import SettingWithCopyWarning
    5: 
    6: import pandas as pd
    7: from pandas import (
    8:     DataFrame,
    9:     Index,
   10:     MultiIndex,
   11:     Period,
   12:     Series,
   13:     Timestamp,
   14:     date_range,
   15:     option_context,
   16:     period_range,
   17: )
   18: import pandas._testing as tm
   19: from pandas.tests.copy_view.util import get_array
   20: 
   21: 
   22: def test_copy(using_copy_on_write):
   23:     df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6], "c": [0.1, 0.2, 0.3]})
   24:     df_copy = df.copy()
   25: 
   26:     # the deep copy by defaults takes a shallow copy of the Index
   27:     assert df_copy.index is not df.index
   28:     assert df_copy.columns is not df.columns
   29:     assert df_copy.index.is_(df.index)
   30:     assert df_copy.columns.is_(df.columns)
   31: 
   32:     # the deep copy doesn't share memory
   33:     assert not np.shares_memory(get_array(df_copy, "a"), get_array(df, "a"))
   34:     if using_copy_on_write:
   35:         assert not df_copy._mgr.blocks[0].refs.has_reference()
   36:         assert not df_copy._mgr.blocks[1].refs.has_reference()
   37: 
   38:     # mutating copy doesn't mutate original
   39:     df_copy.iloc[0, 0] = 0
   40:     assert df.iloc[0, 0] == 1
   41: 
   42: 
   43: def test_copy_shallow(using_copy_on_write, warn_copy_on_write):
   44:     df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6], "c": [0.1, 0.2, 0.3]})
   45:     df_copy = df.copy(deep=False)
   46: 
   47:     # the shallow copy also makes a shallow copy of the index
   48:     if using_copy_on_write:
   49:         assert df_copy.index is not df.index
   50:         assert df_copy.columns is not df.columns
   51:         assert df_copy.index.is_(df.index)
   52:         assert df_copy.columns.is_(df.columns)
   53:     else:
   54:         assert df_copy.index is df.index
   55:         assert df_copy.columns is df.columns
   56: 
   57:     # the shallow copy still shares memory
   58:     assert np.shares_memory(get_array(df_copy, "a"), get_array(df, "a"))
   59:     if using_copy_on_write:
   60:         assert df_copy._mgr.blocks[0].refs.has_reference()
   61:         assert df_copy._mgr.blocks[1].refs.has_reference()
   62: 
   63:     if using_copy_on_write:
   64:         # mutating shallow copy doesn't mutate original
   65:         df_copy.iloc[0, 0] = 0
   66:         assert df.iloc[0, 0] == 1
   67:         # mutating triggered a copy-on-write -> no longer shares memory
   68:         assert not np.shares_memory(get_array(df_copy, "a"), get_array(df, "a"))
   69:         # but still shares memory for the other columns/blocks
   70:         assert np.shares_memory(get_array(df_copy, "c"), get_array(df, "c"))
   71:     else:
   72:         # mutating shallow copy does mutate original
   73:         with tm.assert_cow_warning(warn_copy_on_write):
   74:             df_copy.iloc[0, 0] = 0
   75:         assert df.iloc[0, 0] == 0
   76:         # and still shares memory
   77:         assert np.shares_memory(get_array(df_copy, "a"), get_array(df, "a"))
   78: 
   79: 
   80: @pytest.mark.parametrize("copy", [True, None, False])
   81: @pytest.mark.parametrize(
   82:     "method",
   83:     [
   84:         lambda df, copy: df.rename(columns=str.lower, copy=copy),
   85:         lambda df, copy: df.reindex(columns=["a", "c"], copy=copy),
   86:         lambda df, copy: df.reindex_like(df, copy=copy),
   87:         lambda df, copy: df.align(df, copy=copy)[0],
   88:         lambda df, copy: df.set_axis(["a", "b", "c"], axis="index", copy=copy),
   89:         lambda df, copy: df.rename_axis(index="test", copy=copy),
   90:         lambda df, copy: df.rename_axis(columns="test", copy=copy),
   91:         lambda df, copy: df.astype({"b": "int64"}, copy=copy),
   92:         # lambda df, copy: df.swaplevel(0, 0, copy=copy),
   93:         lambda df, copy: df.swapaxes(0, 0, copy=copy),
   94:         lambda df, copy: df.truncate(0, 5, copy=copy),
   95:         lambda df, copy: df.infer_objects(copy=copy),
   96:         lambda df, copy: df.to_timestamp(copy=copy),
   97:         lambda df, copy: df.to_period(freq="D", copy=copy),
   98:         lambda df, copy: df.tz_localize("US/Central", copy=copy),
   99:         lambda df, copy: df.tz_convert("US/Central", copy=copy),
  100:         lambda df, copy: df.set_flags(allows_duplicate_labels=False, copy=copy),
  101:     ],
  102:     ids=[
  103:         "rename",
  104:         "reindex",
  105:         "reindex_like",
  106:         "align",
  107:         "set_axis",
  108:         "rename_axis0",
  109:         "rename_axis1",
  110:         "astype",
  111:         # "swaplevel",  # only series
  112:         "swapaxes",
  113:         "truncate",
  114:         "infer_objects",
  115:         "to_timestamp",
  116:         "to_period",
  117:         "tz_localize",
  118:         "tz_convert",
  119:         "set_flags",
  120:     ],
  121: )
  122: def test_methods_copy_keyword(
  123:     request, method, copy, using_copy_on_write, using_array_manager
  124: ):
  125:     index = None
  126:     if "to_timestamp" in request.node.callspec.id:
  127:         index = period_range("2012-01-01", freq="D", periods=3)
  128:     elif "to_period" in request.node.callspec.id:
  129:         index = date_range("2012-01-01", freq="D", periods=3)
  130:     elif "tz_localize" in request.node.callspec.id:
  131:         index = date_range("2012-01-01", freq="D", periods=3)
  132:     elif "tz_convert" in request.node.callspec.id:
  133:         index = date_range("2012-01-01", freq="D", periods=3, tz="Europe/Brussels")
  134: 
  135:     df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6], "c": [0.1, 0.2, 0.3]}, index=index)
  136: 
  137:     if "swapaxes" in request.node.callspec.id:
  138:         msg = "'DataFrame.swapaxes' is deprecated"
  139:         with tm.assert_produces_warning(FutureWarning, match=msg):
  140:             df2 = method(df, copy=copy)
  141:     else:
  142:         df2 = method(df, copy=copy)
  143: 
  144:     share_memory = using_copy_on_write or copy is False
  145: 
  146:     if request.node.callspec.id.startswith("reindex-"):
  147:         # TODO copy=False without CoW still returns a copy in this case
  148:         if not using_copy_on_write and not using_array_manager and copy is False:
  149:             share_memory = False
  150: 
  151:     if share_memory:
  152:         assert np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
  153:     else:
  154:         assert not np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
  155: 
  156: 
  157: @pytest.mark.parametrize("copy", [True, None, False])
  158: @pytest.mark.parametrize(
  159:     "method",
  160:     [
  161:         lambda ser, copy: ser.rename(index={0: 100}, copy=copy),
  162:         lambda ser, copy: ser.rename(None, copy=copy),
  163:         lambda ser, copy: ser.reindex(index=ser.index, copy=copy),
  164:         lambda ser, copy: ser.reindex_like(ser, copy=copy),
  165:         lambda ser, copy: ser.align(ser, copy=copy)[0],
  166:         lambda ser, copy: ser.set_axis(["a", "b", "c"], axis="index", copy=copy),
  167:         lambda ser, copy: ser.rename_axis(index="test", copy=copy),
  168:         lambda ser, copy: ser.astype("int64", copy=copy),
  169:         lambda ser, copy: ser.swaplevel(0, 1, copy=copy),
  170:         lambda ser, copy: ser.swapaxes(0, 0, copy=copy),
  171:         lambda ser, copy: ser.truncate(0, 5, copy=copy),
  172:         lambda ser, copy: ser.infer_objects(copy=copy),
  173:         lambda ser, copy: ser.to_timestamp(copy=copy),
  174:         lambda ser, copy: ser.to_period(freq="D", copy=copy),
  175:         lambda ser, copy: ser.tz_localize("US/Central", copy=copy),
  176:         lambda ser, copy: ser.tz_convert("US/Central", copy=copy),
  177:         lambda ser, copy: ser.set_flags(allows_duplicate_labels=False, copy=copy),
  178:     ],
  179:     ids=[
  180:         "rename (dict)",
  181:         "rename",
  182:         "reindex",
  183:         "reindex_like",
  184:         "align",
  185:         "set_axis",
  186:         "rename_axis0",
  187:         "astype",
  188:         "swaplevel",
  189:         "swapaxes",
  190:         "truncate",
  191:         "infer_objects",
  192:         "to_timestamp",
  193:         "to_period",
  194:         "tz_localize",
  195:         "tz_convert",
  196:         "set_flags",
  197:     ],
  198: )
  199: def test_methods_series_copy_keyword(request, method, copy, using_copy_on_write):
  200:     index = None
  201:     if "to_timestamp" in request.node.callspec.id:
  202:         index = period_range("2012-01-01", freq="D", periods=3)
  203:     elif "to_period" in request.node.callspec.id:
  204:         index = date_range("2012-01-01", freq="D", periods=3)
  205:     elif "tz_localize" in request.node.callspec.id:
  206:         index = date_range("2012-01-01", freq="D", periods=3)
  207:     elif "tz_convert" in request.node.callspec.id:
  208:         index = date_range("2012-01-01", freq="D", periods=3, tz="Europe/Brussels")
  209:     elif "swaplevel" in request.node.callspec.id:
  210:         index = MultiIndex.from_arrays([[1, 2, 3], [4, 5, 6]])
  211: 
  212:     ser = Series([1, 2, 3], index=index)
  213: 
  214:     if "swapaxes" in request.node.callspec.id:
  215:         msg = "'Series.swapaxes' is deprecated"
  216:         with tm.assert_produces_warning(FutureWarning, match=msg):
  217:             ser2 = method(ser, copy=copy)
  218:     else:
  219:         ser2 = method(ser, copy=copy)
  220: 
  221:     share_memory = using_copy_on_write or copy is False
  222: 
  223:     if share_memory:
  224:         assert np.shares_memory(get_array(ser2), get_array(ser))
  225:     else:
  226:         assert not np.shares_memory(get_array(ser2), get_array(ser))
  227: 
  228: 
  229: @pytest.mark.parametrize("copy", [True, None, False])
  230: def test_transpose_copy_keyword(using_copy_on_write, copy, using_array_manager):
  231:     df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6]})
  232:     result = df.transpose(copy=copy)
  233:     share_memory = using_copy_on_write or copy is False or copy is None
  234:     share_memory = share_memory and not using_array_manager
  235: 
  236:     if share_memory:
  237:         assert np.shares_memory(get_array(df, "a"), get_array(result, 0))
  238:     else:
  239:         assert not np.shares_memory(get_array(df, "a"), get_array(result, 0))
  240: 
  241: 
  242: # -----------------------------------------------------------------------------
  243: # DataFrame methods returning new DataFrame using shallow copy
  244: 
  245: 
  246: def test_reset_index(using_copy_on_write):
  247:     # Case: resetting the index (i.e. adding a new column) + mutating the
  248:     # resulting dataframe
  249:     df = DataFrame(
  250:         {"a": [1, 2, 3], "b": [4, 5, 6], "c": [0.1, 0.2, 0.3]}, index=[10, 11, 12]
  251:     )
  252:     df_orig = df.copy()
  253:     df2 = df.reset_index()
  254:     df2._mgr._verify_integrity()
  255: 
  256:     if using_copy_on_write:
  257:         # still shares memory (df2 is a shallow copy)
  258:         assert np.shares_memory(get_array(df2, "b"), get_array(df, "b"))
  259:         assert np.shares_memory(get_array(df2, "c"), get_array(df, "c"))
  260:     # mutating df2 triggers a copy-on-write for that column / block
  261:     df2.iloc[0, 2] = 0
  262:     assert not np.shares_memory(get_array(df2, "b"), get_array(df, "b"))
  263:     if using_copy_on_write:
  264:         assert np.shares_memory(get_array(df2, "c"), get_array(df, "c"))
  265:     tm.assert_frame_equal(df, df_orig)
  266: 
  267: 
  268: @pytest.mark.parametrize("index", [pd.RangeIndex(0, 2), Index([1, 2])])
  269: def test_reset_index_series_drop(using_copy_on_write, index):
  270:     ser = Series([1, 2], index=index)
  271:     ser_orig = ser.copy()
  272:     ser2 = ser.reset_index(drop=True)
  273:     if using_copy_on_write:
  274:         assert np.shares_memory(get_array(ser), get_array(ser2))
  275:         assert not ser._mgr._has_no_reference(0)
  276:     else:
  277:         assert not np.shares_memory(get_array(ser), get_array(ser2))
  278: 
  279:     ser2.iloc[0] = 100
  280:     tm.assert_series_equal(ser, ser_orig)
  281: 
  282: 
  283: def test_groupby_column_index_in_references():
  284:     df = DataFrame(
  285:         {"A": ["a", "b", "c", "d"], "B": [1, 2, 3, 4], "C": ["a", "a", "b", "b"]}
  286:     )
  287:     df = df.set_index("A")
  288:     key = df["C"]
  289:     result = df.groupby(key, observed=True).sum()
  290:     expected = df.groupby("C", observed=True).sum()
  291:     tm.assert_frame_equal(result, expected)
  292: 
  293: 
  294: def test_rename_columns(using_copy_on_write):
  295:     # Case: renaming columns returns a new dataframe
  296:     # + afterwards modifying the result
  297:     df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6], "c": [0.1, 0.2, 0.3]})
  298:     df_orig = df.copy()
  299:     df2 = df.rename(columns=str.upper)
  300: 
  301:     if using_copy_on_write:
  302:         assert np.shares_memory(get_array(df2, "A"), get_array(df, "a"))
  303:     df2.iloc[0, 0] = 0
  304:     assert not np.shares_memory(get_array(df2, "A"), get_array(df, "a"))
  305:     if using_copy_on_write:
  306:         assert np.shares_memory(get_array(df2, "C"), get_array(df, "c"))
  307:     expected = DataFrame({"A": [0, 2, 3], "B": [4, 5, 6], "C": [0.1, 0.2, 0.3]})
  308:     tm.assert_frame_equal(df2, expected)
  309:     tm.assert_frame_equal(df, df_orig)
  310: 
  311: 
  312: def test_rename_columns_modify_parent(using_copy_on_write):
  313:     # Case: renaming columns returns a new dataframe
  314:     # + afterwards modifying the original (parent) dataframe
  315:     df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6], "c": [0.1, 0.2, 0.3]})
  316:     df2 = df.rename(columns=str.upper)
  317:     df2_orig = df2.copy()
  318: 
  319:     if using_copy_on_write:
  320:         assert np.shares_memory(get_array(df2, "A"), get_array(df, "a"))
  321:     else:
  322:         assert not np.shares_memory(get_array(df2, "A"), get_array(df, "a"))
  323:     df.iloc[0, 0] = 0
  324:     assert not np.shares_memory(get_array(df2, "A"), get_array(df, "a"))
  325:     if using_copy_on_write:
  326:         assert np.shares_memory(get_array(df2, "C"), get_array(df, "c"))
  327:     expected = DataFrame({"a": [0, 2, 3], "b": [4, 5, 6], "c": [0.1, 0.2, 0.3]})
  328:     tm.assert_frame_equal(df, expected)
  329:     tm.assert_frame_equal(df2, df2_orig)
  330: 
  331: 
  332: def test_pipe(using_copy_on_write):
  333:     df = DataFrame({"a": [1, 2, 3], "b": 1.5})
  334:     df_orig = df.copy()
  335: 
  336:     def testfunc(df):
  337:         return df
  338: 
  339:     df2 = df.pipe(testfunc)
  340: 
  341:     assert np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
  342: 
  343:     # mutating df2 triggers a copy-on-write for that column
  344:     df2.iloc[0, 0] = 0
  345:     if using_copy_on_write:
  346:         tm.assert_frame_equal(df, df_orig)
  347:         assert not np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
  348:     else:
  349:         expected = DataFrame({"a": [0, 2, 3], "b": 1.5})
  350:         tm.assert_frame_equal(df, expected)
  351: 
  352:         assert np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
  353:     assert np.shares_memory(get_array(df2, "b"), get_array(df, "b"))
  354: 
  355: 
  356: def test_pipe_modify_df(using_copy_on_write):
  357:     df = DataFrame({"a": [1, 2, 3], "b": 1.5})
  358:     df_orig = df.copy()
  359: 
  360:     def testfunc(df):
  361:         df.iloc[0, 0] = 100
  362:         return df
  363: 
  364:     df2 = df.pipe(testfunc)
  365: 
  366:     assert np.shares_memory(get_array(df2, "b"), get_array(df, "b"))
  367: 
  368:     if using_copy_on_write:
  369:         tm.assert_frame_equal(df, df_orig)
  370:         assert not np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
  371:     else:
  372:         expected = DataFrame({"a": [100, 2, 3], "b": 1.5})
  373:         tm.assert_frame_equal(df, expected)
  374: 
  375:         assert np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
  376:     assert np.shares_memory(get_array(df2, "b"), get_array(df, "b"))
  377: 
  378: 
  379: def test_reindex_columns(using_copy_on_write):
  380:     # Case: reindexing the column returns a new dataframe
  381:     # + afterwards modifying the result
  382:     df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6], "c": [0.1, 0.2, 0.3]})
  383:     df_orig = df.copy()
  384:     df2 = df.reindex(columns=["a", "c"])
  385: 
  386:     if using_copy_on_write:
  387:         # still shares memory (df2 is a shallow copy)
  388:         assert np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
  389:     else:
  390:         assert not np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
  391:     # mutating df2 triggers a copy-on-write for that column
  392:     df2.iloc[0, 0] = 0
  393:     assert not np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
  394:     if using_copy_on_write:
  395:         assert np.shares_memory(get_array(df2, "c"), get_array(df, "c"))
  396:     tm.assert_frame_equal(df, df_orig)
  397: 
  398: 
  399: @pytest.mark.parametrize(
  400:     "index",
  401:     [
  402:         lambda idx: idx,
  403:         lambda idx: idx.view(),
  404:         lambda idx: idx.copy(),
  405:         lambda idx: list(idx),
  406:     ],
  407:     ids=["identical", "view", "copy", "values"],
  408: )
  409: def test_reindex_rows(index, using_copy_on_write):
  410:     # Case: reindexing the rows with an index that matches the current index
  411:     # can use a shallow copy
  412:     df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6], "c": [0.1, 0.2, 0.3]})
  413:     df_orig = df.copy()
  414:     df2 = df.reindex(index=index(df.index))
  415: 
  416:     if using_copy_on_write:
  417:         # still shares memory (df2 is a shallow copy)
  418:         assert np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
  419:     else:
  420:         assert not np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
  421:     # mutating df2 triggers a copy-on-write for that column
  422:     df2.iloc[0, 0] = 0
  423:     assert not np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
  424:     if using_copy_on_write:
  425:         assert np.shares_memory(get_array(df2, "c"), get_array(df, "c"))
  426:     tm.assert_frame_equal(df, df_orig)
  427: 
  428: 
  429: def test_drop_on_column(using_copy_on_write):
  430:     df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6], "c": [0.1, 0.2, 0.3]})
  431:     df_orig = df.copy()
  432:     df2 = df.drop(columns="a")
  433:     df2._mgr._verify_integrity()
  434: 
  435:     if using_copy_on_write:
  436:         assert np.shares_memory(get_array(df2, "b"), get_array(df, "b"))
  437:         assert np.shares_memory(get_array(df2, "c"), get_array(df, "c"))
  438:     else:
  439:         assert not np.shares_memory(get_array(df2, "b"), get_array(df, "b"))
  440:         assert not np.shares_memory(get_array(df2, "c"), get_array(df, "c"))
  441:     df2.iloc[0, 0] = 0
  442:     assert not np.shares_memory(get_array(df2, "b"), get_array(df, "b"))
  443:     if using_copy_on_write:
  444:         assert np.shares_memory(get_array(df2, "c"), get_array(df, "c"))
  445:     tm.assert_frame_equal(df, df_orig)
  446: 
  447: 
  448: def test_select_dtypes(using_copy_on_write):
  449:     # Case: selecting columns using `select_dtypes()` returns a new dataframe
  450:     # + afterwards modifying the result
  451:     df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6], "c": [0.1, 0.2, 0.3]})
  452:     df_orig = df.copy()
  453:     df2 = df.select_dtypes("int64")
  454:     df2._mgr._verify_integrity()
  455: 
  456:     if using_copy_on_write:
  457:         assert np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
  458:     else:
  459:         assert not np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
  460: 
  461:     # mutating df2 triggers a copy-on-write for that column/block
  462:     df2.iloc[0, 0] = 0
  463:     if using_copy_on_write:
  464:         assert not np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
  465:     tm.assert_frame_equal(df, df_orig)
  466: 
  467: 
  468: @pytest.mark.parametrize(
  469:     "filter_kwargs", [{"items": ["a"]}, {"like": "a"}, {"regex": "a"}]
  470: )
  471: def test_filter(using_copy_on_write, filter_kwargs):
  472:     # Case: selecting columns using `filter()` returns a new dataframe
  473:     # + afterwards modifying the result
  474:     df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6], "c": [0.1, 0.2, 0.3]})
  475:     df_orig = df.copy()
  476:     df2 = df.filter(**filter_kwargs)
  477:     if using_copy_on_write:
  478:         assert np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
  479:     else:
  480:         assert not np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
  481: 
  482:     # mutating df2 triggers a copy-on-write for that column/block
  483:     if using_copy_on_write:
  484:         df2.iloc[0, 0] = 0
  485:         assert not np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
  486:     tm.assert_frame_equal(df, df_orig)
  487: 
  488: 
  489: def test_shift_no_op(using_copy_on_write):
  490:     df = DataFrame(
  491:         [[1, 2], [3, 4], [5, 6]],
  492:         index=date_range("2020-01-01", "2020-01-03"),
  493:         columns=["a", "b"],
  494:     )
  495:     df_orig = df.copy()
  496:     df2 = df.shift(periods=0)
  497: 
  498:     if using_copy_on_write:
  499:         assert np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
  500:     else:
  501:         assert not np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
  502: 
  503:     df.iloc[0, 0] = 0
  504:     if using_copy_on_write:
  505:         assert not np.shares_memory(get_array(df, "a"), get_array(df2, "a"))
  506:         assert np.shares_memory(get_array(df, "b"), get_array(df2, "b"))
  507:     tm.assert_frame_equal(df2, df_orig)
  508: 
  509: 
  510: def test_shift_index(using_copy_on_write):
  511:     df = DataFrame(
  512:         [[1, 2], [3, 4], [5, 6]],
  513:         index=date_range("2020-01-01", "2020-01-03"),
  514:         columns=["a", "b"],
  515:     )
  516:     df2 = df.shift(periods=1, axis=0)
  517: 
  518:     assert not np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
  519: 
  520: 
  521: def test_shift_rows_freq(using_copy_on_write):
  522:     df = DataFrame(
  523:         [[1, 2], [3, 4], [5, 6]],
  524:         index=date_range("2020-01-01", "2020-01-03"),
  525:         columns=["a", "b"],
  526:     )
  527:     df_orig = df.copy()
  528:     df_orig.index = date_range("2020-01-02", "2020-01-04")
  529:     df2 = df.shift(periods=1, freq="1D")
  530: 
  531:     if using_copy_on_write:
  532:         assert np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
  533:     else:
  534:         assert not np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
  535: 
  536:     df.iloc[0, 0] = 0
  537:     if using_copy_on_write:
  538:         assert not np.shares_memory(get_array(df, "a"), get_array(df2, "a"))
  539:     tm.assert_frame_equal(df2, df_orig)
  540: 
  541: 
  542: def test_shift_columns(using_copy_on_write, warn_copy_on_write):
  543:     df = DataFrame(
  544:         [[1, 2], [3, 4], [5, 6]], columns=date_range("2020-01-01", "2020-01-02")
  545:     )
  546:     df2 = df.shift(periods=1, axis=1)
  547: 
  548:     assert np.shares_memory(get_array(df2, "2020-01-02"), get_array(df, "2020-01-01"))
  549:     with tm.assert_cow_warning(warn_copy_on_write):
  550:         df.iloc[0, 0] = 0
  551:     if using_copy_on_write:
  552:         assert not np.shares_memory(
  553:             get_array(df2, "2020-01-02"), get_array(df, "2020-01-01")
  554:         )
  555:         expected = DataFrame(
  556:             [[np.nan, 1], [np.nan, 3], [np.nan, 5]],
  557:             columns=date_range("2020-01-01", "2020-01-02"),
  558:         )
  559:         tm.assert_frame_equal(df2, expected)
  560: 
  561: 
  562: def test_pop(using_copy_on_write, warn_copy_on_write):
  563:     df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6], "c": [0.1, 0.2, 0.3]})
  564:     df_orig = df.copy()
  565:     view_original = df[:]
  566:     result = df.pop("a")
  567: 
  568:     assert np.shares_memory(result.values, get_array(view_original, "a"))
  569:     assert np.shares_memory(get_array(df, "b"), get_array(view_original, "b"))
  570: 
  571:     if using_copy_on_write:
  572:         result.iloc[0] = 0
  573:         assert not np.shares_memory(result.values, get_array(view_original, "a"))
  574:     with tm.assert_cow_warning(warn_copy_on_write):
  575:         df.iloc[0, 0] = 0
  576:     if using_copy_on_write:
  577:         assert not np.shares_memory(get_array(df, "b"), get_array(view_original, "b"))
  578:         tm.assert_frame_equal(view_original, df_orig)
  579:     else:
  580:         expected = DataFrame({"a": [1, 2, 3], "b": [0, 5, 6], "c": [0.1, 0.2, 0.3]})
  581:         tm.assert_frame_equal(view_original, expected)
  582: 
  583: 
  584: @pytest.mark.parametrize(
  585:     "func",
  586:     [
  587:         lambda x, y: x.align(y),
  588:         lambda x, y: x.align(y.a, axis=0),
  589:         lambda x, y: x.align(y.a.iloc[slice(0, 1)], axis=1),
  590:     ],
  591: )
  592: def test_align_frame(using_copy_on_write, func):
  593:     df = DataFrame({"a": [1, 2, 3], "b": "a"})
  594:     df_orig = df.copy()
  595:     df_changed = df[["b", "a"]].copy()
  596:     df2, _ = func(df, df_changed)
  597: 
  598:     if using_copy_on_write:
  599:         assert np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
  600:     else:
  601:         assert not np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
  602: 
  603:     df2.iloc[0, 0] = 0
  604:     if using_copy_on_write:
  605:         assert not np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
  606:     tm.assert_frame_equal(df, df_orig)
  607: 
  608: 
  609: def test_align_series(using_copy_on_write):
  610:     ser = Series([1, 2])
  611:     ser_orig = ser.copy()
  612:     ser_other = ser.copy()
  613:     ser2, ser_other_result = ser.align(ser_other)
  614: 
  615:     if using_copy_on_write:
  616:         assert np.shares_memory(ser2.values, ser.values)
  617:         assert np.shares_memory(ser_other_result.values, ser_other.values)
  618:     else:
  619:         assert not np.shares_memory(ser2.values, ser.values)
  620:         assert not np.shares_memory(ser_other_result.values, ser_other.values)
  621: 
  622:     ser2.iloc[0] = 0
  623:     ser_other_result.iloc[0] = 0
  624:     if using_copy_on_write:
  625:         assert not np.shares_memory(ser2.values, ser.values)
  626:         assert not np.shares_memory(ser_other_result.values, ser_other.values)
  627:     tm.assert_series_equal(ser, ser_orig)
  628:     tm.assert_series_equal(ser_other, ser_orig)
  629: 
  630: 
  631: def test_align_copy_false(using_copy_on_write):
  632:     df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6]})
  633:     df_orig = df.copy()
  634:     df2, df3 = df.align(df, copy=False)
  635: 
  636:     assert np.shares_memory(get_array(df, "b"), get_array(df2, "b"))
  637:     assert np.shares_memory(get_array(df, "a"), get_array(df2, "a"))
  638: 
  639:     if using_copy_on_write:
  640:         df2.loc[0, "a"] = 0
  641:         tm.assert_frame_equal(df, df_orig)  # Original is unchanged
  642: 
  643:         df3.loc[0, "a"] = 0
  644:         tm.assert_frame_equal(df, df_orig)  # Original is unchanged
  645: 
  646: 
  647: def test_align_with_series_copy_false(using_copy_on_write):
  648:     df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6]})
  649:     ser = Series([1, 2, 3], name="x")
  650:     ser_orig = ser.copy()
  651:     df_orig = df.copy()
  652:     df2, ser2 = df.align(ser, copy=False, axis=0)
  653: 
  654:     assert np.shares_memory(get_array(df, "b"), get_array(df2, "b"))
  655:     assert np.shares_memory(get_array(df, "a"), get_array(df2, "a"))
  656:     assert np.shares_memory(get_array(ser, "x"), get_array(ser2, "x"))
  657: 
  658:     if using_copy_on_write:
  659:         df2.loc[0, "a"] = 0
  660:         tm.assert_frame_equal(df, df_orig)  # Original is unchanged
  661: 
  662:         ser2.loc[0] = 0
  663:         tm.assert_series_equal(ser, ser_orig)  # Original is unchanged
  664: 
  665: 
  666: def test_to_frame(using_copy_on_write, warn_copy_on_write):
  667:     # Case: converting a Series to a DataFrame with to_frame
  668:     ser = Series([1, 2, 3])
  669:     ser_orig = ser.copy()
  670: 
  671:     df = ser[:].to_frame()
  672: 
  673:     # currently this always returns a "view"
  674:     assert np.shares_memory(ser.values, get_array(df, 0))
  675: 
  676:     with tm.assert_cow_warning(warn_copy_on_write):
  677:         df.iloc[0, 0] = 0
  678: 
  679:     if using_copy_on_write:
  680:         # mutating df triggers a copy-on-write for that column
  681:         assert not np.shares_memory(ser.values, get_array(df, 0))
  682:         tm.assert_series_equal(ser, ser_orig)
  683:     else:
  684:         # but currently select_dtypes() actually returns a view -> mutates parent
  685:         expected = ser_orig.copy()
  686:         expected.iloc[0] = 0
  687:         tm.assert_series_equal(ser, expected)
  688: 
  689:     # modify original series -> don't modify dataframe
  690:     df = ser[:].to_frame()
  691:     with tm.assert_cow_warning(warn_copy_on_write):
  692:         ser.iloc[0] = 0
  693: 
  694:     if using_copy_on_write:
  695:         tm.assert_frame_equal(df, ser_orig.to_frame())
  696:     else:
  697:         expected = ser_orig.copy().to_frame()
  698:         expected.iloc[0, 0] = 0
  699:         tm.assert_frame_equal(df, expected)
  700: 
  701: 
  702: @pytest.mark.parametrize("ax", ["index", "columns"])
  703: def test_swapaxes_noop(using_copy_on_write, ax):
  704:     df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6]})
  705:     df_orig = df.copy()
  706:     msg = "'DataFrame.swapaxes' is deprecated"
  707:     with tm.assert_produces_warning(FutureWarning, match=msg):
  708:         df2 = df.swapaxes(ax, ax)
  709: 
  710:     if using_copy_on_write:
  711:         assert np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
  712:     else:
  713:         assert not np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
  714: 
  715:     # mutating df2 triggers a copy-on-write for that column/block
  716:     df2.iloc[0, 0] = 0
  717:     if using_copy_on_write:
  718:         assert not np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
  719:     tm.assert_frame_equal(df, df_orig)
  720: 
  721: 
  722: def test_swapaxes_single_block(using_copy_on_write):
  723:     df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6]}, index=["x", "y", "z"])
  724:     df_orig = df.copy()
  725:     msg = "'DataFrame.swapaxes' is deprecated"
  726:     with tm.assert_produces_warning(FutureWarning, match=msg):
  727:         df2 = df.swapaxes("index", "columns")
  728: 
  729:     if using_copy_on_write:
  730:         assert np.shares_memory(get_array(df2, "x"), get_array(df, "a"))
  731:     else:
  732:         assert not np.shares_memory(get_array(df2, "x"), get_array(df, "a"))
  733: 
  734:     # mutating df2 triggers a copy-on-write for that column/block
  735:     df2.iloc[0, 0] = 0
  736:     if using_copy_on_write:
  737:         assert not np.shares_memory(get_array(df2, "x"), get_array(df, "a"))
  738:     tm.assert_frame_equal(df, df_orig)
  739: 
  740: 
  741: def test_swapaxes_read_only_array():
  742:     df = DataFrame({"a": [1, 2], "b": 3})
  743:     msg = "'DataFrame.swapaxes' is deprecated"
  744:     with tm.assert_produces_warning(FutureWarning, match=msg):
  745:         df = df.swapaxes(axis1="index", axis2="columns")
  746:     df.iloc[0, 0] = 100
  747:     expected = DataFrame({0: [100, 3], 1: [2, 3]}, index=["a", "b"])
  748:     tm.assert_frame_equal(df, expected)
  749: 
  750: 
  751: @pytest.mark.parametrize(
  752:     "method, idx",
  753:     [
  754:         (lambda df: df.copy(deep=False).copy(deep=False), 0),
  755:         (lambda df: df.reset_index().reset_index(), 2),
  756:         (lambda df: df.rename(columns=str.upper).rename(columns=str.lower), 0),
  757:         (lambda df: df.copy(deep=False).select_dtypes(include="number"), 0),
  758:     ],
  759:     ids=["shallow-copy", "reset_index", "rename", "select_dtypes"],
  760: )
  761: def test_chained_methods(request, method, idx, using_copy_on_write, warn_copy_on_write):
  762:     df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6], "c": [0.1, 0.2, 0.3]})
  763:     df_orig = df.copy()
  764: 
  765:     # when not using CoW, only the copy() variant actually gives a view
  766:     df2_is_view = not using_copy_on_write and request.node.callspec.id == "shallow-copy"
  767: 
  768:     # modify df2 -> don't modify df
  769:     df2 = method(df)
  770:     with tm.assert_cow_warning(warn_copy_on_write and df2_is_view):
  771:         df2.iloc[0, idx] = 0
  772:     if not df2_is_view:
  773:         tm.assert_frame_equal(df, df_orig)
  774: 
  775:     # modify df -> don't modify df2
  776:     df2 = method(df)
  777:     with tm.assert_cow_warning(warn_copy_on_write and df2_is_view):
  778:         df.iloc[0, 0] = 0
  779:     if not df2_is_view:
  780:         tm.assert_frame_equal(df2.iloc[:, idx:], df_orig)
  781: 
  782: 
  783: @pytest.mark.parametrize("obj", [Series([1, 2], name="a"), DataFrame({"a": [1, 2]})])
  784: def test_to_timestamp(using_copy_on_write, obj):
  785:     obj.index = Index([Period("2012-1-1", freq="D"), Period("2012-1-2", freq="D")])
  786: 
  787:     obj_orig = obj.copy()
  788:     obj2 = obj.to_timestamp()
  789: 
  790:     if using_copy_on_write:
  791:         assert np.shares_memory(get_array(obj2, "a"), get_array(obj, "a"))
  792:     else:
  793:         assert not np.shares_memory(get_array(obj2, "a"), get_array(obj, "a"))
  794: 
  795:     # mutating obj2 triggers a copy-on-write for that column / block
  796:     obj2.iloc[0] = 0
  797:     assert not np.shares_memory(get_array(obj2, "a"), get_array(obj, "a"))
  798:     tm.assert_equal(obj, obj_orig)
  799: 
  800: 
  801: @pytest.mark.parametrize("obj", [Series([1, 2], name="a"), DataFrame({"a": [1, 2]})])
  802: def test_to_period(using_copy_on_write, obj):
  803:     obj.index = Index([Timestamp("2019-12-31"), Timestamp("2020-12-31")])
  804: 
  805:     obj_orig = obj.copy()
  806:     obj2 = obj.to_period(freq="Y")
  807: 
  808:     if using_copy_on_write:
  809:         assert np.shares_memory(get_array(obj2, "a"), get_array(obj, "a"))
  810:     else:
  811:         assert not np.shares_memory(get_array(obj2, "a"), get_array(obj, "a"))
  812: 
  813:     # mutating obj2 triggers a copy-on-write for that column / block
  814:     obj2.iloc[0] = 0
  815:     assert not np.shares_memory(get_array(obj2, "a"), get_array(obj, "a"))
  816:     tm.assert_equal(obj, obj_orig)
  817: 
  818: 
  819: def test_set_index(using_copy_on_write):
  820:     # GH 49473
  821:     df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6], "c": [0.1, 0.2, 0.3]})
  822:     df_orig = df.copy()
  823:     df2 = df.set_index("a")
  824: 
  825:     if using_copy_on_write:
  826:         assert np.shares_memory(get_array(df2, "b"), get_array(df, "b"))
  827:     else:
  828:         assert not np.shares_memory(get_array(df2, "b"), get_array(df, "b"))
  829: 
  830:     # mutating df2 triggers a copy-on-write for that column / block
  831:     df2.iloc[0, 1] = 0
  832:     assert not np.shares_memory(get_array(df2, "c"), get_array(df, "c"))
  833:     tm.assert_frame_equal(df, df_orig)
  834: 
  835: 
  836: def test_set_index_mutating_parent_does_not_mutate_index():
  837:     df = DataFrame({"a": [1, 2, 3], "b": 1})
  838:     result = df.set_index("a")
  839:     expected = result.copy()
  840: 
  841:     df.iloc[0, 0] = 100
  842:     tm.assert_frame_equal(result, expected)
  843: 
  844: 
  845: def test_add_prefix(using_copy_on_write):
  846:     # GH 49473
  847:     df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6], "c": [0.1, 0.2, 0.3]})
  848:     df_orig = df.copy()
  849:     df2 = df.add_prefix("CoW_")
  850: 
  851:     if using_copy_on_write:
  852:         assert np.shares_memory(get_array(df2, "CoW_a"), get_array(df, "a"))
  853:     df2.iloc[0, 0] = 0
  854: 
  855:     assert not np.shares_memory(get_array(df2, "CoW_a"), get_array(df, "a"))
  856: 
  857:     if using_copy_on_write:
  858:         assert np.shares_memory(get_array(df2, "CoW_c"), get_array(df, "c"))
  859:     expected = DataFrame(
  860:         {"CoW_a": [0, 2, 3], "CoW_b": [4, 5, 6], "CoW_c": [0.1, 0.2, 0.3]}
  861:     )
  862:     tm.assert_frame_equal(df2, expected)
  863:     tm.assert_frame_equal(df, df_orig)
  864: 
  865: 
  866: def test_add_suffix(using_copy_on_write):
  867:     # GH 49473
  868:     df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6], "c": [0.1, 0.2, 0.3]})
  869:     df_orig = df.copy()
  870:     df2 = df.add_suffix("_CoW")
  871:     if using_copy_on_write:
  872:         assert np.shares_memory(get_array(df2, "a_CoW"), get_array(df, "a"))
  873:     df2.iloc[0, 0] = 0
  874:     assert not np.shares_memory(get_array(df2, "a_CoW"), get_array(df, "a"))
  875:     if using_copy_on_write:
  876:         assert np.shares_memory(get_array(df2, "c_CoW"), get_array(df, "c"))
  877:     expected = DataFrame(
  878:         {"a_CoW": [0, 2, 3], "b_CoW": [4, 5, 6], "c_CoW": [0.1, 0.2, 0.3]}
  879:     )
  880:     tm.assert_frame_equal(df2, expected)
  881:     tm.assert_frame_equal(df, df_orig)
  882: 
  883: 
  884: @pytest.mark.parametrize("axis, val", [(0, 5.5), (1, np.nan)])
  885: def test_dropna(using_copy_on_write, axis, val):
  886:     df = DataFrame({"a": [1, 2, 3], "b": [4, val, 6], "c": "d"})
  887:     df_orig = df.copy()
  888:     df2 = df.dropna(axis=axis)
  889: 
  890:     if using_copy_on_write:
  891:         assert np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
  892:     else:
  893:         assert not np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
  894: 
  895:     df2.iloc[0, 0] = 0
  896:     if using_copy_on_write:
  897:         assert not np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
  898:     tm.assert_frame_equal(df, df_orig)
  899: 
  900: 
  901: @pytest.mark.parametrize("val", [5, 5.5])
  902: def test_dropna_series(using_copy_on_write, val):
  903:     ser = Series([1, val, 4])
  904:     ser_orig = ser.copy()
  905:     ser2 = ser.dropna()
  906: 
  907:     if using_copy_on_write:
  908:         assert np.shares_memory(ser2.values, ser.values)
  909:     else:
  910:         assert not np.shares_memory(ser2.values, ser.values)
  911: 
  912:     ser2.iloc[0] = 0
  913:     if using_copy_on_write:
  914:         assert not np.shares_memory(ser2.values, ser.values)
  915:     tm.assert_series_equal(ser, ser_orig)
  916: 
  917: 
  918: @pytest.mark.parametrize(
  919:     "method",
  920:     [
  921:         lambda df: df.head(),
  922:         lambda df: df.head(2),
  923:         lambda df: df.tail(),
  924:         lambda df: df.tail(3),
  925:     ],
  926: )
  927: def test_head_tail(method, using_copy_on_write, warn_copy_on_write):
  928:     df = DataFrame({"a": [1, 2, 3], "b": [0.1, 0.2, 0.3]})
  929:     df_orig = df.copy()
  930:     df2 = method(df)
  931:     df2._mgr._verify_integrity()
  932: 
  933:     if using_copy_on_write:
  934:         # We are explicitly deviating for CoW here to make an eager copy (avoids
  935:         # tracking references for very cheap ops)
  936:         assert not np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
  937:         assert not np.shares_memory(get_array(df2, "b"), get_array(df, "b"))
  938: 
  939:     # modify df2 to trigger CoW for that block
  940:     with tm.assert_cow_warning(warn_copy_on_write):
  941:         df2.iloc[0, 0] = 0
  942:     if using_copy_on_write:
  943:         assert not np.shares_memory(get_array(df2, "b"), get_array(df, "b"))
  944:         assert not np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
  945:     else:
  946:         # without CoW enabled, head and tail return views. Mutating df2 also mutates df.
  947:         assert np.shares_memory(get_array(df2, "b"), get_array(df, "b"))
  948:         with tm.assert_cow_warning(warn_copy_on_write):
  949:             df2.iloc[0, 0] = 1
  950:     tm.assert_frame_equal(df, df_orig)
  951: 
  952: 
  953: def test_infer_objects(using_copy_on_write):
  954:     df = DataFrame({"a": [1, 2], "b": "c", "c": 1, "d": "x"})
  955:     df_orig = df.copy()
  956:     df2 = df.infer_objects()
  957: 
  958:     if using_copy_on_write:
  959:         assert np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
  960:         assert np.shares_memory(get_array(df2, "b"), get_array(df, "b"))
  961: 
  962:     else:
  963:         assert not np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
  964:         assert not np.shares_memory(get_array(df2, "b"), get_array(df, "b"))
  965: 
  966:     df2.iloc[0, 0] = 0
  967:     df2.iloc[0, 1] = "d"
  968:     if using_copy_on_write:
  969:         assert not np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
  970:         assert not np.shares_memory(get_array(df2, "b"), get_array(df, "b"))
  971:     tm.assert_frame_equal(df, df_orig)
  972: 
  973: 
  974: def test_infer_objects_no_reference(using_copy_on_write):
  975:     df = DataFrame(
  976:         {
  977:             "a": [1, 2],
  978:             "b": "c",
  979:             "c": 1,
  980:             "d": Series(
  981:                 [Timestamp("2019-12-31"), Timestamp("2020-12-31")], dtype="object"
  982:             ),
  983:             "e": "b",
  984:         }
  985:     )
  986:     df = df.infer_objects()
  987: 
  988:     arr_a = get_array(df, "a")
  989:     arr_b = get_array(df, "b")
  990:     arr_d = get_array(df, "d")
  991: 
  992:     df.iloc[0, 0] = 0
  993:     df.iloc[0, 1] = "d"
  994:     df.iloc[0, 3] = Timestamp("2018-12-31")
  995:     if using_copy_on_write:
  996:         assert np.shares_memory(arr_a, get_array(df, "a"))
  997:         # TODO(CoW): Block splitting causes references here
  998:         assert not np.shares_memory(arr_b, get_array(df, "b"))
  999:         assert np.shares_memory(arr_d, get_array(df, "d"))
 1000: 
 1001: 
 1002: def test_infer_objects_reference(using_copy_on_write):
 1003:     df = DataFrame(
 1004:         {
 1005:             "a": [1, 2],
 1006:             "b": "c",
 1007:             "c": 1,
 1008:             "d": Series(
 1009:                 [Timestamp("2019-12-31"), Timestamp("2020-12-31")], dtype="object"
 1010:             ),
 1011:         }
 1012:     )
 1013:     view = df[:]  # noqa: F841
 1014:     df = df.infer_objects()
 1015: 
 1016:     arr_a = get_array(df, "a")
 1017:     arr_b = get_array(df, "b")
 1018:     arr_d = get_array(df, "d")
 1019: 
 1020:     df.iloc[0, 0] = 0
 1021:     df.iloc[0, 1] = "d"
 1022:     df.iloc[0, 3] = Timestamp("2018-12-31")
 1023:     if using_copy_on_write:
 1024:         assert not np.shares_memory(arr_a, get_array(df, "a"))
 1025:         assert not np.shares_memory(arr_b, get_array(df, "b"))
 1026:         assert np.shares_memory(arr_d, get_array(df, "d"))
 1027: 
 1028: 
 1029: @pytest.mark.parametrize(
 1030:     "kwargs",
 1031:     [
 1032:         {"before": "a", "after": "b", "axis": 1},
 1033:         {"before": 0, "after": 1, "axis": 0},
 1034:     ],
 1035: )
 1036: def test_truncate(using_copy_on_write, kwargs):
 1037:     df = DataFrame({"a": [1, 2, 3], "b": 1, "c": 2})
 1038:     df_orig = df.copy()
 1039:     df2 = df.truncate(**kwargs)
 1040:     df2._mgr._verify_integrity()
 1041: 
 1042:     if using_copy_on_write:
 1043:         assert np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
 1044:     else:
 1045:         assert not np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
 1046: 
 1047:     df2.iloc[0, 0] = 0
 1048:     if using_copy_on_write:
 1049:         assert not np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
 1050:     tm.assert_frame_equal(df, df_orig)
 1051: 
 1052: 
 1053: @pytest.mark.parametrize("method", ["assign", "drop_duplicates"])
 1054: def test_assign_drop_duplicates(using_copy_on_write, method):
 1055:     df = DataFrame({"a": [1, 2, 3]})
 1056:     df_orig = df.copy()
 1057:     df2 = getattr(df, method)()
 1058:     df2._mgr._verify_integrity()
 1059: 
 1060:     if using_copy_on_write:
 1061:         assert np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
 1062:     else:
 1063:         assert not np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
 1064: 
 1065:     df2.iloc[0, 0] = 0
 1066:     if using_copy_on_write:
 1067:         assert not np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
 1068:     tm.assert_frame_equal(df, df_orig)
 1069: 
 1070: 
 1071: @pytest.mark.parametrize("obj", [Series([1, 2]), DataFrame({"a": [1, 2]})])
 1072: def test_take(using_copy_on_write, obj):
 1073:     # Check that no copy is made when we take all rows in original order
 1074:     obj_orig = obj.copy()
 1075:     obj2 = obj.take([0, 1])
 1076: 
 1077:     if using_copy_on_write:
 1078:         assert np.shares_memory(obj2.values, obj.values)
 1079:     else:
 1080:         assert not np.shares_memory(obj2.values, obj.values)
 1081: 
 1082:     obj2.iloc[0] = 0
 1083:     if using_copy_on_write:
 1084:         assert not np.shares_memory(obj2.values, obj.values)
 1085:     tm.assert_equal(obj, obj_orig)
 1086: 
 1087: 
 1088: @pytest.mark.parametrize("obj", [Series([1, 2]), DataFrame({"a": [1, 2]})])
 1089: def test_between_time(using_copy_on_write, obj):
 1090:     obj.index = date_range("2018-04-09", periods=2, freq="1D20min")
 1091:     obj_orig = obj.copy()
 1092:     obj2 = obj.between_time("0:00", "1:00")
 1093: 
 1094:     if using_copy_on_write:
 1095:         assert np.shares_memory(obj2.values, obj.values)
 1096:     else:
 1097:         assert not np.shares_memory(obj2.values, obj.values)
 1098: 
 1099:     obj2.iloc[0] = 0
 1100:     if using_copy_on_write:
 1101:         assert not np.shares_memory(obj2.values, obj.values)
 1102:     tm.assert_equal(obj, obj_orig)
 1103: 
 1104: 
 1105: def test_reindex_like(using_copy_on_write):
 1106:     df = DataFrame({"a": [1, 2], "b": "a"})
 1107:     other = DataFrame({"b": "a", "a": [1, 2]})
 1108: 
 1109:     df_orig = df.copy()
 1110:     df2 = df.reindex_like(other)
 1111: 
 1112:     if using_copy_on_write:
 1113:         assert np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
 1114:     else:
 1115:         assert not np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
 1116: 
 1117:     df2.iloc[0, 1] = 0
 1118:     if using_copy_on_write:
 1119:         assert not np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
 1120:     tm.assert_frame_equal(df, df_orig)
 1121: 
 1122: 
 1123: def test_sort_index(using_copy_on_write):
 1124:     # GH 49473
 1125:     ser = Series([1, 2, 3])
 1126:     ser_orig = ser.copy()
 1127:     ser2 = ser.sort_index()
 1128: 
 1129:     if using_copy_on_write:
 1130:         assert np.shares_memory(ser.values, ser2.values)
 1131:     else:
 1132:         assert not np.shares_memory(ser.values, ser2.values)
 1133: 
 1134:     # mutating ser triggers a copy-on-write for the column / block
 1135:     ser2.iloc[0] = 0
 1136:     assert not np.shares_memory(ser2.values, ser.values)
 1137:     tm.assert_series_equal(ser, ser_orig)
 1138: 
 1139: 
 1140: @pytest.mark.parametrize(
 1141:     "obj, kwargs",
 1142:     [(Series([1, 2, 3], name="a"), {}), (DataFrame({"a": [1, 2, 3]}), {"by": "a"})],
 1143: )
 1144: def test_sort_values(using_copy_on_write, obj, kwargs):
 1145:     obj_orig = obj.copy()
 1146:     obj2 = obj.sort_values(**kwargs)
 1147: 
 1148:     if using_copy_on_write:
 1149:         assert np.shares_memory(get_array(obj2, "a"), get_array(obj, "a"))
 1150:     else:
 1151:         assert not np.shares_memory(get_array(obj2, "a"), get_array(obj, "a"))
 1152: 
 1153:     # mutating df triggers a copy-on-write for the column / block
 1154:     obj2.iloc[0] = 0
 1155:     assert not np.shares_memory(get_array(obj2, "a"), get_array(obj, "a"))
 1156:     tm.assert_equal(obj, obj_orig)
 1157: 
 1158: 
 1159: @pytest.mark.parametrize(
 1160:     "obj, kwargs",
 1161:     [(Series([1, 2, 3], name="a"), {}), (DataFrame({"a": [1, 2, 3]}), {"by": "a"})],
 1162: )
 1163: def test_sort_values_inplace(using_copy_on_write, obj, kwargs, warn_copy_on_write):
 1164:     obj_orig = obj.copy()
 1165:     view = obj[:]
 1166:     obj.sort_values(inplace=True, **kwargs)
 1167: 
 1168:     assert np.shares_memory(get_array(obj, "a"), get_array(view, "a"))
 1169: 
 1170:     # mutating obj triggers a copy-on-write for the column / block
 1171:     with tm.assert_cow_warning(warn_copy_on_write):
 1172:         obj.iloc[0] = 0
 1173:     if using_copy_on_write:
 1174:         assert not np.shares_memory(get_array(obj, "a"), get_array(view, "a"))
 1175:         tm.assert_equal(view, obj_orig)
 1176:     else:
 1177:         assert np.shares_memory(get_array(obj, "a"), get_array(view, "a"))
 1178: 
 1179: 
 1180: @pytest.mark.parametrize("decimals", [-1, 0, 1])
 1181: def test_round(using_copy_on_write, warn_copy_on_write, decimals):
 1182:     df = DataFrame({"a": [1, 2], "b": "c"})
 1183:     df_orig = df.copy()
 1184:     df2 = df.round(decimals=decimals)
 1185: 
 1186:     if using_copy_on_write:
 1187:         assert np.shares_memory(get_array(df2, "b"), get_array(df, "b"))
 1188:         # TODO: Make inplace by using out parameter of ndarray.round?
 1189:         if decimals >= 0:
 1190:             # Ensure lazy copy if no-op
 1191:             assert np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
 1192:         else:
 1193:             assert not np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
 1194:     else:
 1195:         assert not np.shares_memory(get_array(df2, "b"), get_array(df, "b"))
 1196:         assert not np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
 1197: 
 1198:     df2.iloc[0, 1] = "d"
 1199:     df2.iloc[0, 0] = 4
 1200:     if using_copy_on_write:
 1201:         assert not np.shares_memory(get_array(df2, "b"), get_array(df, "b"))
 1202:         assert not np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
 1203:     tm.assert_frame_equal(df, df_orig)
 1204: 
 1205: 
 1206: def test_reorder_levels(using_copy_on_write):
 1207:     index = MultiIndex.from_tuples(
 1208:         [(1, 1), (1, 2), (2, 1), (2, 2)], names=["one", "two"]
 1209:     )
 1210:     df = DataFrame({"a": [1, 2, 3, 4]}, index=index)
 1211:     df_orig = df.copy()
 1212:     df2 = df.reorder_levels(order=["two", "one"])
 1213: 
 1214:     if using_copy_on_write:
 1215:         assert np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
 1216:     else:
 1217:         assert not np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
 1218: 
 1219:     df2.iloc[0, 0] = 0
 1220:     if using_copy_on_write:
 1221:         assert not np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
 1222:     tm.assert_frame_equal(df, df_orig)
 1223: 
 1224: 
 1225: def test_series_reorder_levels(using_copy_on_write):
 1226:     index = MultiIndex.from_tuples(
 1227:         [(1, 1), (1, 2), (2, 1), (2, 2)], names=["one", "two"]
 1228:     )
 1229:     ser = Series([1, 2, 3, 4], index=index)
 1230:     ser_orig = ser.copy()
 1231:     ser2 = ser.reorder_levels(order=["two", "one"])
 1232: 
 1233:     if using_copy_on_write:
 1234:         assert np.shares_memory(ser2.values, ser.values)
 1235:     else:
 1236:         assert not np.shares_memory(ser2.values, ser.values)
 1237: 
 1238:     ser2.iloc[0] = 0
 1239:     if using_copy_on_write:
 1240:         assert not np.shares_memory(ser2.values, ser.values)
 1241:     tm.assert_series_equal(ser, ser_orig)
 1242: 
 1243: 
 1244: @pytest.mark.parametrize("obj", [Series([1, 2, 3]), DataFrame({"a": [1, 2, 3]})])
 1245: def test_swaplevel(using_copy_on_write, obj):
 1246:     index = MultiIndex.from_tuples([(1, 1), (1, 2), (2, 1)], names=["one", "two"])
 1247:     obj.index = index
 1248:     obj_orig = obj.copy()
 1249:     obj2 = obj.swaplevel()
 1250: 
 1251:     if using_copy_on_write:
 1252:         assert np.shares_memory(obj2.values, obj.values)
 1253:     else:
 1254:         assert not np.shares_memory(obj2.values, obj.values)
 1255: 
 1256:     obj2.iloc[0] = 0
 1257:     if using_copy_on_write:
 1258:         assert not np.shares_memory(obj2.values, obj.values)
 1259:     tm.assert_equal(obj, obj_orig)
 1260: 
 1261: 
 1262: def test_frame_set_axis(using_copy_on_write):
 1263:     # GH 49473
 1264:     df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6], "c": [0.1, 0.2, 0.3]})
 1265:     df_orig = df.copy()
 1266:     df2 = df.set_axis(["a", "b", "c"], axis="index")
 1267: 
 1268:     if using_copy_on_write:
 1269:         assert np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
 1270:     else:
 1271:         assert not np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
 1272: 
 1273:     # mutating df2 triggers a copy-on-write for that column / block
 1274:     df2.iloc[0, 0] = 0
 1275:     assert not np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
 1276:     tm.assert_frame_equal(df, df_orig)
 1277: 
 1278: 
 1279: def test_series_set_axis(using_copy_on_write):
 1280:     # GH 49473
 1281:     ser = Series([1, 2, 3])
 1282:     ser_orig = ser.copy()
 1283:     ser2 = ser.set_axis(["a", "b", "c"], axis="index")
 1284: 
 1285:     if using_copy_on_write:
 1286:         assert np.shares_memory(ser, ser2)
 1287:     else:
 1288:         assert not np.shares_memory(ser, ser2)
 1289: 
 1290:     # mutating ser triggers a copy-on-write for the column / block
 1291:     ser2.iloc[0] = 0
 1292:     assert not np.shares_memory(ser2, ser)
 1293:     tm.assert_series_equal(ser, ser_orig)
 1294: 
 1295: 
 1296: def test_set_flags(using_copy_on_write, warn_copy_on_write):
 1297:     ser = Series([1, 2, 3])
 1298:     ser_orig = ser.copy()
 1299:     ser2 = ser.set_flags(allows_duplicate_labels=False)
 1300: 
 1301:     assert np.shares_memory(ser, ser2)
 1302: 
 1303:     # mutating ser triggers a copy-on-write for the column / block
 1304:     with tm.assert_cow_warning(warn_copy_on_write):
 1305:         ser2.iloc[0] = 0
 1306:     if using_copy_on_write:
 1307:         assert not np.shares_memory(ser2, ser)
 1308:         tm.assert_series_equal(ser, ser_orig)
 1309:     else:
 1310:         assert np.shares_memory(ser2, ser)
 1311:         expected = Series([0, 2, 3])
 1312:         tm.assert_series_equal(ser, expected)
 1313: 
 1314: 
 1315: @pytest.mark.parametrize("kwargs", [{"mapper": "test"}, {"index": "test"}])
 1316: def test_rename_axis(using_copy_on_write, kwargs):
 1317:     df = DataFrame({"a": [1, 2, 3, 4]}, index=Index([1, 2, 3, 4], name="a"))
 1318:     df_orig = df.copy()
 1319:     df2 = df.rename_axis(**kwargs)
 1320: 
 1321:     if using_copy_on_write:
 1322:         assert np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
 1323:     else:
 1324:         assert not np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
 1325: 
 1326:     df2.iloc[0, 0] = 0
 1327:     if using_copy_on_write:
 1328:         assert not np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
 1329:     tm.assert_frame_equal(df, df_orig)
 1330: 
 1331: 
 1332: @pytest.mark.parametrize(
 1333:     "func, tz", [("tz_convert", "Europe/Berlin"), ("tz_localize", None)]
 1334: )
 1335: def test_tz_convert_localize(using_copy_on_write, func, tz):
 1336:     # GH 49473
 1337:     ser = Series(
 1338:         [1, 2], index=date_range(start="2014-08-01 09:00", freq="h", periods=2, tz=tz)
 1339:     )
 1340:     ser_orig = ser.copy()
 1341:     ser2 = getattr(ser, func)("US/Central")
 1342: 
 1343:     if using_copy_on_write:
 1344:         assert np.shares_memory(ser.values, ser2.values)
 1345:     else:
 1346:         assert not np.shares_memory(ser.values, ser2.values)
 1347: 
 1348:     # mutating ser triggers a copy-on-write for the column / block
 1349:     ser2.iloc[0] = 0
 1350:     assert not np.shares_memory(ser2.values, ser.values)
 1351:     tm.assert_series_equal(ser, ser_orig)
 1352: 
 1353: 
 1354: def test_droplevel(using_copy_on_write):
 1355:     # GH 49473
 1356:     index = MultiIndex.from_tuples([(1, 1), (1, 2), (2, 1)], names=["one", "two"])
 1357:     df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6], "c": [7, 8, 9]}, index=index)
 1358:     df_orig = df.copy()
 1359:     df2 = df.droplevel(0)
 1360: 
 1361:     if using_copy_on_write:
 1362:         assert np.shares_memory(get_array(df2, "c"), get_array(df, "c"))
 1363:         assert np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
 1364:     else:
 1365:         assert not np.shares_memory(get_array(df2, "c"), get_array(df, "c"))
 1366:         assert not np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
 1367: 
 1368:     # mutating df2 triggers a copy-on-write for that column / block
 1369:     df2.iloc[0, 0] = 0
 1370: 
 1371:     assert not np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
 1372:     if using_copy_on_write:
 1373:         assert np.shares_memory(get_array(df2, "b"), get_array(df, "b"))
 1374: 
 1375:     tm.assert_frame_equal(df, df_orig)
 1376: 
 1377: 
 1378: def test_squeeze(using_copy_on_write, warn_copy_on_write):
 1379:     df = DataFrame({"a": [1, 2, 3]})
 1380:     df_orig = df.copy()
 1381:     series = df.squeeze()
 1382: 
 1383:     # Should share memory regardless of CoW since squeeze is just an iloc
 1384:     assert np.shares_memory(series.values, get_array(df, "a"))
 1385: 
 1386:     # mutating squeezed df triggers a copy-on-write for that column/block
 1387:     with tm.assert_cow_warning(warn_copy_on_write):
 1388:         series.iloc[0] = 0
 1389:     if using_copy_on_write:
 1390:         assert not np.shares_memory(series.values, get_array(df, "a"))
 1391:         tm.assert_frame_equal(df, df_orig)
 1392:     else:
 1393:         # Without CoW the original will be modified
 1394:         assert np.shares_memory(series.values, get_array(df, "a"))
 1395:         assert df.loc[0, "a"] == 0
 1396: 
 1397: 
 1398: def test_items(using_copy_on_write, warn_copy_on_write):
 1399:     df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6], "c": [7, 8, 9]})
 1400:     df_orig = df.copy()
 1401: 
 1402:     # Test this twice, since the second time, the item cache will be
 1403:     # triggered, and we want to make sure it still works then.
 1404:     for i in range(2):
 1405:         for name, ser in df.items():
 1406:             assert np.shares_memory(get_array(ser, name), get_array(df, name))
 1407: 
 1408:             # mutating df triggers a copy-on-write for that column / block
 1409:             with tm.assert_cow_warning(warn_copy_on_write):
 1410:                 ser.iloc[0] = 0
 1411: 
 1412:             if using_copy_on_write:
 1413:                 assert not np.shares_memory(get_array(ser, name), get_array(df, name))
 1414:                 tm.assert_frame_equal(df, df_orig)
 1415:             else:
 1416:                 # Original frame will be modified
 1417:                 assert df.loc[0, name] == 0
 1418: 
 1419: 
 1420: @pytest.mark.parametrize("dtype", ["int64", "Int64"])
 1421: def test_putmask(using_copy_on_write, dtype, warn_copy_on_write):
 1422:     df = DataFrame({"a": [1, 2], "b": 1, "c": 2}, dtype=dtype)
 1423:     view = df[:]
 1424:     df_orig = df.copy()
 1425:     with tm.assert_cow_warning(warn_copy_on_write):
 1426:         df[df == df] = 5
 1427: 
 1428:     if using_copy_on_write:
 1429:         assert not np.shares_memory(get_array(view, "a"), get_array(df, "a"))
 1430:         tm.assert_frame_equal(view, df_orig)
 1431:     else:
 1432:         # Without CoW the original will be modified
 1433:         assert np.shares_memory(get_array(view, "a"), get_array(df, "a"))
 1434:         assert view.iloc[0, 0] == 5
 1435: 
 1436: 
 1437: @pytest.mark.parametrize("dtype", ["int64", "Int64"])
 1438: def test_putmask_no_reference(using_copy_on_write, dtype):
 1439:     df = DataFrame({"a": [1, 2], "b": 1, "c": 2}, dtype=dtype)
 1440:     arr_a = get_array(df, "a")
 1441:     df[df == df] = 5
 1442: 
 1443:     if using_copy_on_write:
 1444:         assert np.shares_memory(arr_a, get_array(df, "a"))
 1445: 
 1446: 
 1447: @pytest.mark.parametrize("dtype", ["float64", "Float64"])
 1448: def test_putmask_aligns_rhs_no_reference(using_copy_on_write, dtype):
 1449:     df = DataFrame({"a": [1.5, 2], "b": 1.5}, dtype=dtype)
 1450:     arr_a = get_array(df, "a")
 1451:     df[df == df] = DataFrame({"a": [5.5, 5]})
 1452: 
 1453:     if using_copy_on_write:
 1454:         assert np.shares_memory(arr_a, get_array(df, "a"))
 1455: 
 1456: 
 1457: @pytest.mark.parametrize(
 1458:     "val, exp, warn", [(5.5, True, FutureWarning), (5, False, None)]
 1459: )
 1460: def test_putmask_dont_copy_some_blocks(
 1461:     using_copy_on_write, val, exp, warn, warn_copy_on_write
 1462: ):
 1463:     df = DataFrame({"a": [1, 2], "b": 1, "c": 1.5})
 1464:     view = df[:]
 1465:     df_orig = df.copy()
 1466:     indexer = DataFrame(
 1467:         [[True, False, False], [True, False, False]], columns=list("abc")
 1468:     )
 1469:     if warn_copy_on_write:
 1470:         with tm.assert_cow_warning():
 1471:             df[indexer] = val
 1472:     else:
 1473:         with tm.assert_produces_warning(warn, match="incompatible dtype"):
 1474:             df[indexer] = val
 1475: 
 1476:     if using_copy_on_write:
 1477:         assert not np.shares_memory(get_array(view, "a"), get_array(df, "a"))
 1478:         # TODO(CoW): Could split blocks to avoid copying the whole block
 1479:         assert np.shares_memory(get_array(view, "b"), get_array(df, "b")) is exp
 1480:         assert np.shares_memory(get_array(view, "c"), get_array(df, "c"))
 1481:         assert df._mgr._has_no_reference(1) is not exp
 1482:         assert not df._mgr._has_no_reference(2)
 1483:         tm.assert_frame_equal(view, df_orig)
 1484:     elif val == 5:
 1485:         # Without CoW the original will be modified, the other case upcasts, e.g. copy
 1486:         assert np.shares_memory(get_array(view, "a"), get_array(df, "a"))
 1487:         assert np.shares_memory(get_array(view, "c"), get_array(df, "c"))
 1488:         assert view.iloc[0, 0] == 5
 1489: 
 1490: 
 1491: @pytest.mark.parametrize("dtype", ["int64", "Int64"])
 1492: @pytest.mark.parametrize(
 1493:     "func",
 1494:     [
 1495:         lambda ser: ser.where(ser > 0, 10),
 1496:         lambda ser: ser.mask(ser <= 0, 10),
 1497:     ],
 1498: )
 1499: def test_where_mask_noop(using_copy_on_write, dtype, func):
 1500:     ser = Series([1, 2, 3], dtype=dtype)
 1501:     ser_orig = ser.copy()
 1502: 
 1503:     result = func(ser)
 1504: 
 1505:     if using_copy_on_write:
 1506:         assert np.shares_memory(get_array(ser), get_array(result))
 1507:     else:
 1508:         assert not np.shares_memory(get_array(ser), get_array(result))
 1509: 
 1510:     result.iloc[0] = 10
 1511:     if using_copy_on_write:
 1512:         assert not np.shares_memory(get_array(ser), get_array(result))
 1513:     tm.assert_series_equal(ser, ser_orig)
 1514: 
 1515: 
 1516: @pytest.mark.parametrize("dtype", ["int64", "Int64"])
 1517: @pytest.mark.parametrize(
 1518:     "func",
 1519:     [
 1520:         lambda ser: ser.where(ser < 0, 10),
 1521:         lambda ser: ser.mask(ser >= 0, 10),
 1522:     ],
 1523: )
 1524: def test_where_mask(using_copy_on_write, dtype, func):
 1525:     ser = Series([1, 2, 3], dtype=dtype)
 1526:     ser_orig = ser.copy()
 1527: 
 1528:     result = func(ser)
 1529: 
 1530:     assert not np.shares_memory(get_array(ser), get_array(result))
 1531:     tm.assert_series_equal(ser, ser_orig)
 1532: 
 1533: 
 1534: @pytest.mark.parametrize("dtype, val", [("int64", 10.5), ("Int64", 10)])
 1535: @pytest.mark.parametrize(
 1536:     "func",
 1537:     [
 1538:         lambda df, val: df.where(df < 0, val),
 1539:         lambda df, val: df.mask(df >= 0, val),
 1540:     ],
 1541: )
 1542: def test_where_mask_noop_on_single_column(using_copy_on_write, dtype, val, func):
 1543:     df = DataFrame({"a": [1, 2, 3], "b": [-4, -5, -6]}, dtype=dtype)
 1544:     df_orig = df.copy()
 1545: 
 1546:     result = func(df, val)
 1547: 
 1548:     if using_copy_on_write:
 1549:         assert np.shares_memory(get_array(df, "b"), get_array(result, "b"))
 1550:         assert not np.shares_memory(get_array(df, "a"), get_array(result, "a"))
 1551:     else:
 1552:         assert not np.shares_memory(get_array(df, "b"), get_array(result, "b"))
 1553: 
 1554:     result.iloc[0, 1] = 10
 1555:     if using_copy_on_write:
 1556:         assert not np.shares_memory(get_array(df, "b"), get_array(result, "b"))
 1557:     tm.assert_frame_equal(df, df_orig)
 1558: 
 1559: 
 1560: @pytest.mark.parametrize("func", ["mask", "where"])
 1561: def test_chained_where_mask(using_copy_on_write, func):
 1562:     df = DataFrame({"a": [1, 4, 2], "b": 1})
 1563:     df_orig = df.copy()
 1564:     if using_copy_on_write:
 1565:         with tm.raises_chained_assignment_error():
 1566:             getattr(df["a"], func)(df["a"] > 2, 5, inplace=True)
 1567:         tm.assert_frame_equal(df, df_orig)
 1568: 
 1569:         with tm.raises_chained_assignment_error():
 1570:             getattr(df[["a"]], func)(df["a"] > 2, 5, inplace=True)
 1571:         tm.assert_frame_equal(df, df_orig)
 1572:     else:
 1573:         with tm.assert_produces_warning(FutureWarning, match="inplace method"):
 1574:             getattr(df["a"], func)(df["a"] > 2, 5, inplace=True)
 1575: 
 1576:         with tm.assert_produces_warning(None):
 1577:             with option_context("mode.chained_assignment", None):
 1578:                 getattr(df[["a"]], func)(df["a"] > 2, 5, inplace=True)
 1579: 
 1580:         with tm.assert_produces_warning(None):
 1581:             with option_context("mode.chained_assignment", None):
 1582:                 getattr(df[df["a"] > 1], func)(df["a"] > 2, 5, inplace=True)
 1583: 
 1584: 
 1585: def test_asfreq_noop(using_copy_on_write):
 1586:     df = DataFrame(
 1587:         {"a": [0.0, None, 2.0, 3.0]},
 1588:         index=date_range("1/1/2000", periods=4, freq="min"),
 1589:     )
 1590:     df_orig = df.copy()
 1591:     df2 = df.asfreq(freq="min")
 1592: 
 1593:     if using_copy_on_write:
 1594:         assert np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
 1595:     else:
 1596:         assert not np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
 1597: 
 1598:     # mutating df2 triggers a copy-on-write for that column / block
 1599:     df2.iloc[0, 0] = 0
 1600: 
 1601:     assert not np.shares_memory(get_array(df2, "a"), get_array(df, "a"))
 1602:     tm.assert_frame_equal(df, df_orig)
 1603: 
 1604: 
 1605: def test_iterrows(using_copy_on_write):
 1606:     df = DataFrame({"a": 0, "b": 1}, index=[1, 2, 3])
 1607:     df_orig = df.copy()
 1608: 
 1609:     for _, sub in df.iterrows():
 1610:         sub.iloc[0] = 100
 1611:     if using_copy_on_write:
 1612:         tm.assert_frame_equal(df, df_orig)
 1613: 
 1614: 
 1615: def test_interpolate_creates_copy(using_copy_on_write, warn_copy_on_write):
 1616:     # GH#51126
 1617:     df = DataFrame({"a": [1.5, np.nan, 3]})
 1618:     view = df[:]
 1619:     expected = df.copy()
 1620: 
 1621:     with tm.assert_cow_warning(warn_copy_on_write):
 1622:         df.ffill(inplace=True)
 1623:     with tm.assert_cow_warning(warn_copy_on_write):
 1624:         df.iloc[0, 0] = 100.5
 1625: 
 1626:     if using_copy_on_write:
 1627:         tm.assert_frame_equal(view, expected)
 1628:     else:
 1629:         expected = DataFrame({"a": [100.5, 1.5, 3]})
 1630:         tm.assert_frame_equal(view, expected)
 1631: 
 1632: 
 1633: def test_isetitem(using_copy_on_write):
 1634:     df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6], "c": [7, 8, 9]})
 1635:     df_orig = df.copy()
 1636:     df2 = df.copy(deep=None)  # Trigger a CoW
 1637:     df2.isetitem(1, np.array([-1, -2, -3]))  # This is inplace
 1638: 
 1639:     if using_copy_on_write:
 1640:         assert np.shares_memory(get_array(df, "c"), get_array(df2, "c"))
 1641:         assert np.shares_memory(get_array(df, "a"), get_array(df2, "a"))
 1642:     else:
 1643:         assert not np.shares_memory(get_array(df, "c"), get_array(df2, "c"))
 1644:         assert not np.shares_memory(get_array(df, "a"), get_array(df2, "a"))
 1645: 
 1646:     df2.loc[0, "a"] = 0
 1647:     tm.assert_frame_equal(df, df_orig)  # Original is unchanged
 1648: 
 1649:     if using_copy_on_write:
 1650:         assert np.shares_memory(get_array(df, "c"), get_array(df2, "c"))
 1651:     else:
 1652:         assert not np.shares_memory(get_array(df, "c"), get_array(df2, "c"))
 1653: 
 1654: 
 1655: @pytest.mark.parametrize(
 1656:     "dtype", ["int64", "float64"], ids=["single-block", "mixed-block"]
 1657: )
 1658: def test_isetitem_series(using_copy_on_write, dtype):
 1659:     df = DataFrame({"a": [1, 2, 3], "b": np.array([4, 5, 6], dtype=dtype)})
 1660:     ser = Series([7, 8, 9])
 1661:     ser_orig = ser.copy()
 1662:     df.isetitem(0, ser)
 1663: 
 1664:     if using_copy_on_write:
 1665:         assert np.shares_memory(get_array(df, "a"), get_array(ser))
 1666:         assert not df._mgr._has_no_reference(0)
 1667: 
 1668:     # mutating dataframe doesn't update series
 1669:     df.loc[0, "a"] = 0
 1670:     tm.assert_series_equal(ser, ser_orig)
 1671: 
 1672:     # mutating series doesn't update dataframe
 1673:     df = DataFrame({"a": [1, 2, 3], "b": np.array([4, 5, 6], dtype=dtype)})
 1674:     ser = Series([7, 8, 9])
 1675:     df.isetitem(0, ser)
 1676: 
 1677:     ser.loc[0] = 0
 1678:     expected = DataFrame({"a": [7, 8, 9], "b": np.array([4, 5, 6], dtype=dtype)})
 1679:     tm.assert_frame_equal(df, expected)
 1680: 
 1681: 
 1682: def test_isetitem_frame(using_copy_on_write):
 1683:     df = DataFrame({"a": [1, 2, 3], "b": 1, "c": 2})
 1684:     rhs = DataFrame({"a": [4, 5, 6], "b": 2})
 1685:     df.isetitem([0, 1], rhs)
 1686:     if using_copy_on_write:
 1687:         assert np.shares_memory(get_array(df, "a"), get_array(rhs, "a"))
 1688:         assert np.shares_memory(get_array(df, "b"), get_array(rhs, "b"))
 1689:         assert not df._mgr._has_no_reference(0)
 1690:     else:
 1691:         assert not np.shares_memory(get_array(df, "a"), get_array(rhs, "a"))
 1692:         assert not np.shares_memory(get_array(df, "b"), get_array(rhs, "b"))
 1693:     expected = df.copy()
 1694:     rhs.iloc[0, 0] = 100
 1695:     rhs.iloc[0, 1] = 100
 1696:     tm.assert_frame_equal(df, expected)
 1697: 
 1698: 
 1699: @pytest.mark.parametrize("key", ["a", ["a"]])
 1700: def test_get(using_copy_on_write, warn_copy_on_write, key):
 1701:     df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6]})
 1702:     df_orig = df.copy()
 1703: 
 1704:     result = df.get(key)
 1705: 
 1706:     if using_copy_on_write:
 1707:         assert np.shares_memory(get_array(result, "a"), get_array(df, "a"))
 1708:         result.iloc[0] = 0
 1709:         assert not np.shares_memory(get_array(result, "a"), get_array(df, "a"))
 1710:         tm.assert_frame_equal(df, df_orig)
 1711:     else:
 1712:         # for non-CoW it depends on whether we got a Series or DataFrame if it
 1713:         # is a view or copy or triggers a warning or not
 1714:         if warn_copy_on_write:
 1715:             warn = FutureWarning if isinstance(key, str) else None
 1716:         else:
 1717:             warn = SettingWithCopyWarning if isinstance(key, list) else None
 1718:         with option_context("chained_assignment", "warn"):
 1719:             with tm.assert_produces_warning(warn):
 1720:                 result.iloc[0] = 0
 1721: 
 1722:         if isinstance(key, list):
 1723:             tm.assert_frame_equal(df, df_orig)
 1724:         else:
 1725:             assert df.iloc[0, 0] == 0
 1726: 
 1727: 
 1728: @pytest.mark.parametrize("axis, key", [(0, 0), (1, "a")])
 1729: @pytest.mark.parametrize(
 1730:     "dtype", ["int64", "float64"], ids=["single-block", "mixed-block"]
 1731: )
 1732: def test_xs(
 1733:     using_copy_on_write, warn_copy_on_write, using_array_manager, axis, key, dtype
 1734: ):
 1735:     single_block = (dtype == "int64") and not using_array_manager
 1736:     is_view = single_block or (using_array_manager and axis == 1)
 1737:     df = DataFrame(
 1738:         {"a": [1, 2, 3], "b": [4, 5, 6], "c": np.array([7, 8, 9], dtype=dtype)}
 1739:     )
 1740:     df_orig = df.copy()
 1741: 
 1742:     result = df.xs(key, axis=axis)
 1743: 
 1744:     if axis == 1 or single_block:
 1745:         assert np.shares_memory(get_array(df, "a"), get_array(result))
 1746:     elif using_copy_on_write:
 1747:         assert result._mgr._has_no_reference(0)
 1748: 
 1749:     if using_copy_on_write or (is_view and not warn_copy_on_write):
 1750:         result.iloc[0] = 0
 1751:     elif warn_copy_on_write:
 1752:         with tm.assert_cow_warning(single_block or axis == 1):
 1753:             result.iloc[0] = 0
 1754:     else:
 1755:         with option_context("chained_assignment", "warn"):
 1756:             with tm.assert_produces_warning(SettingWithCopyWarning):
 1757:                 result.iloc[0] = 0
 1758: 
 1759:     if using_copy_on_write or (not single_block and axis == 0):
 1760:         tm.assert_frame_equal(df, df_orig)
 1761:     else:
 1762:         assert df.iloc[0, 0] == 0
 1763: 
 1764: 
 1765: @pytest.mark.parametrize("axis", [0, 1])
 1766: @pytest.mark.parametrize("key, level", [("l1", 0), (2, 1)])
 1767: def test_xs_multiindex(
 1768:     using_copy_on_write, warn_copy_on_write, using_array_manager, key, level, axis
 1769: ):
 1770:     arr = np.arange(18).reshape(6, 3)
 1771:     index = MultiIndex.from_product([["l1", "l2"], [1, 2, 3]], names=["lev1", "lev2"])
 1772:     df = DataFrame(arr, index=index, columns=list("abc"))
 1773:     if axis == 1:
 1774:         df = df.transpose().copy()
 1775:     df_orig = df.copy()
 1776: 
 1777:     result = df.xs(key, level=level, axis=axis)
 1778: 
 1779:     if level == 0:
 1780:         assert np.shares_memory(
 1781:             get_array(df, df.columns[0]), get_array(result, result.columns[0])
 1782:         )
 1783: 
 1784:     if warn_copy_on_write:
 1785:         warn = FutureWarning if level == 0 else None
 1786:     elif not using_copy_on_write and not using_array_manager:
 1787:         warn = SettingWithCopyWarning
 1788:     else:
 1789:         warn = None
 1790:     with option_context("chained_assignment", "warn"):
 1791:         with tm.assert_produces_warning(warn):
 1792:             result.iloc[0, 0] = 0
 1793: 
 1794:     tm.assert_frame_equal(df, df_orig)
 1795: 
 1796: 
 1797: def test_update_frame(using_copy_on_write, warn_copy_on_write):
 1798:     df1 = DataFrame({"a": [1.0, 2.0, 3.0], "b": [4.0, 5.0, 6.0]})
 1799:     df2 = DataFrame({"b": [100.0]}, index=[1])
 1800:     df1_orig = df1.copy()
 1801:     view = df1[:]
 1802: 
 1803:     # TODO(CoW) better warning message?
 1804:     with tm.assert_cow_warning(warn_copy_on_write):
 1805:         df1.update(df2)
 1806: 
 1807:     expected = DataFrame({"a": [1.0, 2.0, 3.0], "b": [4.0, 100.0, 6.0]})
 1808:     tm.assert_frame_equal(df1, expected)
 1809:     if using_copy_on_write:
 1810:         # df1 is updated, but its view not
 1811:         tm.assert_frame_equal(view, df1_orig)
 1812:         assert np.shares_memory(get_array(df1, "a"), get_array(view, "a"))
 1813:         assert not np.shares_memory(get_array(df1, "b"), get_array(view, "b"))
 1814:     else:
 1815:         tm.assert_frame_equal(view, expected)
 1816: 
 1817: 
 1818: def test_update_series(using_copy_on_write, warn_copy_on_write):
 1819:     ser1 = Series([1.0, 2.0, 3.0])
 1820:     ser2 = Series([100.0], index=[1])
 1821:     ser1_orig = ser1.copy()
 1822:     view = ser1[:]
 1823: 
 1824:     if warn_copy_on_write:
 1825:         with tm.assert_cow_warning():
 1826:             ser1.update(ser2)
 1827:     else:
 1828:         ser1.update(ser2)
 1829: 
 1830:     expected = Series([1.0, 100.0, 3.0])
 1831:     tm.assert_series_equal(ser1, expected)
 1832:     if using_copy_on_write:
 1833:         # ser1 is updated, but its view not
 1834:         tm.assert_series_equal(view, ser1_orig)
 1835:     else:
 1836:         tm.assert_series_equal(view, expected)
 1837: 
 1838: 
 1839: def test_update_chained_assignment(using_copy_on_write):
 1840:     df = DataFrame({"a": [1, 2, 3]})
 1841:     ser2 = Series([100.0], index=[1])
 1842:     df_orig = df.copy()
 1843:     if using_copy_on_write:
 1844:         with tm.raises_chained_assignment_error():
 1845:             df["a"].update(ser2)
 1846:         tm.assert_frame_equal(df, df_orig)
 1847: 
 1848:         with tm.raises_chained_assignment_error():
 1849:             df[["a"]].update(ser2.to_frame())
 1850:         tm.assert_frame_equal(df, df_orig)
 1851:     else:
 1852:         with tm.assert_produces_warning(FutureWarning, match="inplace method"):
 1853:             df["a"].update(ser2)
 1854: 
 1855:         with tm.assert_produces_warning(None):
 1856:             with option_context("mode.chained_assignment", None):
 1857:                 df[["a"]].update(ser2.to_frame())
 1858: 
 1859:         with tm.assert_produces_warning(None):
 1860:             with option_context("mode.chained_assignment", None):
 1861:                 df[df["a"] > 1].update(ser2.to_frame())
 1862: 
 1863: 
 1864: def test_inplace_arithmetic_series(using_copy_on_write):
 1865:     ser = Series([1, 2, 3])
 1866:     ser_orig = ser.copy()
 1867:     data = get_array(ser)
 1868:     ser *= 2
 1869:     if using_copy_on_write:
 1870:         # https://github.com/pandas-dev/pandas/pull/55745
 1871:         # changed to NOT update inplace because there is no benefit (actual
 1872:         # operation already done non-inplace). This was only for the optics
 1873:         # of updating the backing array inplace, but we no longer want to make
 1874:         # that guarantee
 1875:         assert not np.shares_memory(get_array(ser), data)
 1876:         tm.assert_numpy_array_equal(data, get_array(ser_orig))
 1877:     else:
 1878:         assert np.shares_memory(get_array(ser), data)
 1879:         tm.assert_numpy_array_equal(data, get_array(ser))
 1880: 
 1881: 
 1882: def test_inplace_arithmetic_series_with_reference(
 1883:     using_copy_on_write, warn_copy_on_write
 1884: ):
 1885:     ser = Series([1, 2, 3])
 1886:     ser_orig = ser.copy()
 1887:     view = ser[:]
 1888:     with tm.assert_cow_warning(warn_copy_on_write):
 1889:         ser *= 2
 1890:     if using_copy_on_write:
 1891:         assert not np.shares_memory(get_array(ser), get_array(view))
 1892:         tm.assert_series_equal(ser_orig, view)
 1893:     else:
 1894:         assert np.shares_memory(get_array(ser), get_array(view))
 1895: 
 1896: 
 1897: @pytest.mark.parametrize("copy", [True, False])
 1898: def test_transpose(using_copy_on_write, copy, using_array_manager):
 1899:     df = DataFrame({"a": [1, 2, 3], "b": 1})
 1900:     df_orig = df.copy()
 1901:     result = df.transpose(copy=copy)
 1902: 
 1903:     if not copy and not using_array_manager or using_copy_on_write:
 1904:         assert np.shares_memory(get_array(df, "a"), get_array(result, 0))
 1905:     else:
 1906:         assert not np.shares_memory(get_array(df, "a"), get_array(result, 0))
 1907: 
 1908:     result.iloc[0, 0] = 100
 1909:     if using_copy_on_write:
 1910:         tm.assert_frame_equal(df, df_orig)
 1911: 
 1912: 
 1913: def test_transpose_different_dtypes(using_copy_on_write):
 1914:     df = DataFrame({"a": [1, 2, 3], "b": 1.5})
 1915:     df_orig = df.copy()
 1916:     result = df.T
 1917: 
 1918:     assert not np.shares_memory(get_array(df, "a"), get_array(result, 0))
 1919:     result.iloc[0, 0] = 100
 1920:     if using_copy_on_write:
 1921:         tm.assert_frame_equal(df, df_orig)
 1922: 
 1923: 
 1924: def test_transpose_ea_single_column(using_copy_on_write):
 1925:     df = DataFrame({"a": [1, 2, 3]}, dtype="Int64")
 1926:     result = df.T
 1927: 
 1928:     assert not np.shares_memory(get_array(df, "a"), get_array(result, 0))
 1929: 
 1930: 
 1931: def test_transform_frame(using_copy_on_write, warn_copy_on_write):
 1932:     df = DataFrame({"a": [1, 2, 3], "b": 1})
 1933:     df_orig = df.copy()
 1934: 
 1935:     def func(ser):
 1936:         ser.iloc[0] = 100
 1937:         return ser
 1938: 
 1939:     with tm.assert_cow_warning(warn_copy_on_write):
 1940:         df.transform(func)
 1941:     if using_copy_on_write:
 1942:         tm.assert_frame_equal(df, df_orig)
 1943: 
 1944: 
 1945: def test_transform_series(using_copy_on_write, warn_copy_on_write):
 1946:     ser = Series([1, 2, 3])
 1947:     ser_orig = ser.copy()
 1948: 
 1949:     def func(ser):
 1950:         ser.iloc[0] = 100
 1951:         return ser
 1952: 
 1953:     with tm.assert_cow_warning(warn_copy_on_write):
 1954:         ser.transform(func)
 1955:     if using_copy_on_write:
 1956:         tm.assert_series_equal(ser, ser_orig)
 1957: 
 1958: 
 1959: def test_count_read_only_array():
 1960:     df = DataFrame({"a": [1, 2], "b": 3})
 1961:     result = df.count()
 1962:     result.iloc[0] = 100
 1963:     expected = Series([100, 2], index=["a", "b"])
 1964:     tm.assert_series_equal(result, expected)
 1965: 
 1966: 
 1967: def test_series_view(using_copy_on_write, warn_copy_on_write):
 1968:     ser = Series([1, 2, 3])
 1969:     ser_orig = ser.copy()
 1970: 
 1971:     with tm.assert_produces_warning(FutureWarning, match="is deprecated"):
 1972:         ser2 = ser.view()
 1973:     assert np.shares_memory(get_array(ser), get_array(ser2))
 1974:     if using_copy_on_write:
 1975:         assert not ser2._mgr._has_no_reference(0)
 1976: 
 1977:     with tm.assert_cow_warning(warn_copy_on_write):
 1978:         ser2.iloc[0] = 100
 1979: 
 1980:     if using_copy_on_write:
 1981:         tm.assert_series_equal(ser_orig, ser)
 1982:     else:
 1983:         expected = Series([100, 2, 3])
 1984:         tm.assert_series_equal(ser, expected)
 1985: 
 1986: 
 1987: def test_insert_series(using_copy_on_write):
 1988:     df = DataFrame({"a": [1, 2, 3]})
 1989:     ser = Series([1, 2, 3])
 1990:     ser_orig = ser.copy()
 1991:     df.insert(loc=1, value=ser, column="b")
 1992:     if using_copy_on_write:
 1993:         assert np.shares_memory(get_array(ser), get_array(df, "b"))
 1994:         assert not df._mgr._has_no_reference(1)
 1995:     else:
 1996:         assert not np.shares_memory(get_array(ser), get_array(df, "b"))
 1997: 
 1998:     df.iloc[0, 1] = 100
 1999:     tm.assert_series_equal(ser, ser_orig)
 2000: 
 2001: 
 2002: def test_eval(using_copy_on_write):
 2003:     df = DataFrame({"a": [1, 2, 3], "b": 1})
 2004:     df_orig = df.copy()
 2005: 
 2006:     result = df.eval("c = a+b")
 2007:     if using_copy_on_write:
 2008:         assert np.shares_memory(get_array(df, "a"), get_array(result, "a"))
 2009:     else:
 2010:         assert not np.shares_memory(get_array(df, "a"), get_array(result, "a"))
 2011: 
 2012:     result.iloc[0, 0] = 100
 2013:     tm.assert_frame_equal(df, df_orig)
 2014: 
 2015: 
 2016: def test_eval_inplace(using_copy_on_write, warn_copy_on_write):
 2017:     df = DataFrame({"a": [1, 2, 3], "b": 1})
 2018:     df_orig = df.copy()
 2019:     df_view = df[:]
 2020: 
 2021:     df.eval("c = a+b", inplace=True)
 2022:     assert np.shares_memory(get_array(df, "a"), get_array(df_view, "a"))
 2023: 
 2024:     with tm.assert_cow_warning(warn_copy_on_write):
 2025:         df.iloc[0, 0] = 100
 2026:     if using_copy_on_write:
 2027:         tm.assert_frame_equal(df_view, df_orig)
 2028: 
 2029: 
 2030: def test_apply_modify_row(using_copy_on_write, warn_copy_on_write):
 2031:     # Case: applying a function on each row as a Series object, where the
 2032:     # function mutates the row object (which needs to trigger CoW if row is a view)
 2033:     df = DataFrame({"A": [1, 2], "B": [3, 4]})
 2034:     df_orig = df.copy()
 2035: 
 2036:     def transform(row):
 2037:         row["B"] = 100
 2038:         return row
 2039: 
 2040:     with tm.assert_cow_warning(warn_copy_on_write):
 2041:         df.apply(transform, axis=1)
 2042: 
 2043:     if using_copy_on_write:
 2044:         tm.assert_frame_equal(df, df_orig)
 2045:     else:
 2046:         assert df.loc[0, "B"] == 100
 2047: 
 2048:     # row Series is a copy
 2049:     df = DataFrame({"A": [1, 2], "B": ["b", "c"]})
 2050:     df_orig = df.copy()
 2051: 
 2052:     with tm.assert_produces_warning(None):
 2053:         df.apply(transform, axis=1)
 2054: 
 2055:     tm.assert_frame_equal(df, df_orig)
