    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas.errors import SettingWithCopyWarning
    5: 
    6: from pandas.core.dtypes.common import is_float_dtype
    7: 
    8: import pandas as pd
    9: from pandas import (
   10:     DataFrame,
   11:     Series,
   12: )
   13: import pandas._testing as tm
   14: from pandas.tests.copy_view.util import get_array
   15: 
   16: 
   17: @pytest.fixture(params=["numpy", "nullable"])
   18: def backend(request):
   19:     if request.param == "numpy":
   20: 
   21:         def make_dataframe(*args, **kwargs):
   22:             return DataFrame(*args, **kwargs)
   23: 
   24:         def make_series(*args, **kwargs):
   25:             return Series(*args, **kwargs)
   26: 
   27:     elif request.param == "nullable":
   28: 
   29:         def make_dataframe(*args, **kwargs):
   30:             df = DataFrame(*args, **kwargs)
   31:             df_nullable = df.convert_dtypes()
   32:             # convert_dtypes will try to cast float to int if there is no loss in
   33:             # precision -> undo that change
   34:             for col in df.columns:
   35:                 if is_float_dtype(df[col].dtype) and not is_float_dtype(
   36:                     df_nullable[col].dtype
   37:                 ):
   38:                     df_nullable[col] = df_nullable[col].astype("Float64")
   39:             # copy final result to ensure we start with a fully self-owning DataFrame
   40:             return df_nullable.copy()
   41: 
   42:         def make_series(*args, **kwargs):
   43:             ser = Series(*args, **kwargs)
   44:             return ser.convert_dtypes().copy()
   45: 
   46:     return request.param, make_dataframe, make_series
   47: 
   48: 
   49: # -----------------------------------------------------------------------------
   50: # Indexing operations taking subset + modifying the subset/parent
   51: 
   52: 
   53: def test_subset_column_selection(backend, using_copy_on_write):
   54:     # Case: taking a subset of the columns of a DataFrame
   55:     # + afterwards modifying the subset
   56:     _, DataFrame, _ = backend
   57:     df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6], "c": [0.1, 0.2, 0.3]})
   58:     df_orig = df.copy()
   59: 
   60:     subset = df[["a", "c"]]
   61: 
   62:     if using_copy_on_write:
   63:         # the subset shares memory ...
   64:         assert np.shares_memory(get_array(subset, "a"), get_array(df, "a"))
   65:         # ... but uses CoW when being modified
   66:         subset.iloc[0, 0] = 0
   67:     else:
   68:         assert not np.shares_memory(get_array(subset, "a"), get_array(df, "a"))
   69:         # INFO this no longer raise warning since pandas 1.4
   70:         # with pd.option_context("chained_assignment", "warn"):
   71:         #     with tm.assert_produces_warning(SettingWithCopyWarning):
   72:         subset.iloc[0, 0] = 0
   73: 
   74:     assert not np.shares_memory(get_array(subset, "a"), get_array(df, "a"))
   75: 
   76:     expected = DataFrame({"a": [0, 2, 3], "c": [0.1, 0.2, 0.3]})
   77:     tm.assert_frame_equal(subset, expected)
   78:     tm.assert_frame_equal(df, df_orig)
   79: 
   80: 
   81: def test_subset_column_selection_modify_parent(backend, using_copy_on_write):
   82:     # Case: taking a subset of the columns of a DataFrame
   83:     # + afterwards modifying the parent
   84:     _, DataFrame, _ = backend
   85:     df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6], "c": [0.1, 0.2, 0.3]})
   86: 
   87:     subset = df[["a", "c"]]
   88: 
   89:     if using_copy_on_write:
   90:         # the subset shares memory ...
   91:         assert np.shares_memory(get_array(subset, "a"), get_array(df, "a"))
   92:         # ... but parent uses CoW parent when it is modified
   93:     df.iloc[0, 0] = 0
   94: 
   95:     assert not np.shares_memory(get_array(subset, "a"), get_array(df, "a"))
   96:     if using_copy_on_write:
   97:         # different column/block still shares memory
   98:         assert np.shares_memory(get_array(subset, "c"), get_array(df, "c"))
   99: 
  100:     expected = DataFrame({"a": [1, 2, 3], "c": [0.1, 0.2, 0.3]})
  101:     tm.assert_frame_equal(subset, expected)
  102: 
  103: 
  104: def test_subset_row_slice(backend, using_copy_on_write, warn_copy_on_write):
  105:     # Case: taking a subset of the rows of a DataFrame using a slice
  106:     # + afterwards modifying the subset
  107:     _, DataFrame, _ = backend
  108:     df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6], "c": [0.1, 0.2, 0.3]})
  109:     df_orig = df.copy()
  110: 
  111:     subset = df[1:3]
  112:     subset._mgr._verify_integrity()
  113: 
  114:     assert np.shares_memory(get_array(subset, "a"), get_array(df, "a"))
  115: 
  116:     if using_copy_on_write:
  117:         subset.iloc[0, 0] = 0
  118:         assert not np.shares_memory(get_array(subset, "a"), get_array(df, "a"))
  119: 
  120:     else:
  121:         # INFO this no longer raise warning since pandas 1.4
  122:         # with pd.option_context("chained_assignment", "warn"):
  123:         #     with tm.assert_produces_warning(SettingWithCopyWarning):
  124:         with tm.assert_cow_warning(warn_copy_on_write):
  125:             subset.iloc[0, 0] = 0
  126: 
  127:     subset._mgr._verify_integrity()
  128: 
  129:     expected = DataFrame({"a": [0, 3], "b": [5, 6], "c": [0.2, 0.3]}, index=range(1, 3))
  130:     tm.assert_frame_equal(subset, expected)
  131:     if using_copy_on_write:
  132:         # original parent dataframe is not modified (CoW)
  133:         tm.assert_frame_equal(df, df_orig)
  134:     else:
  135:         # original parent dataframe is actually updated
  136:         df_orig.iloc[1, 0] = 0
  137:         tm.assert_frame_equal(df, df_orig)
  138: 
  139: 
  140: @pytest.mark.parametrize(
  141:     "dtype", ["int64", "float64"], ids=["single-block", "mixed-block"]
  142: )
  143: def test_subset_column_slice(
  144:     backend, using_copy_on_write, warn_copy_on_write, using_array_manager, dtype
  145: ):
  146:     # Case: taking a subset of the columns of a DataFrame using a slice
  147:     # + afterwards modifying the subset
  148:     dtype_backend, DataFrame, _ = backend
  149:     single_block = (
  150:         dtype == "int64" and dtype_backend == "numpy"
  151:     ) and not using_array_manager
  152:     df = DataFrame(
  153:         {"a": [1, 2, 3], "b": [4, 5, 6], "c": np.array([7, 8, 9], dtype=dtype)}
  154:     )
  155:     df_orig = df.copy()
  156: 
  157:     subset = df.iloc[:, 1:]
  158:     subset._mgr._verify_integrity()
  159: 
  160:     if using_copy_on_write:
  161:         assert np.shares_memory(get_array(subset, "b"), get_array(df, "b"))
  162: 
  163:         subset.iloc[0, 0] = 0
  164:         assert not np.shares_memory(get_array(subset, "b"), get_array(df, "b"))
  165:     elif warn_copy_on_write:
  166:         with tm.assert_cow_warning(single_block):
  167:             subset.iloc[0, 0] = 0
  168:     else:
  169:         # we only get a warning in case of a single block
  170:         warn = SettingWithCopyWarning if single_block else None
  171:         with pd.option_context("chained_assignment", "warn"):
  172:             with tm.assert_produces_warning(warn):
  173:                 subset.iloc[0, 0] = 0
  174: 
  175:     expected = DataFrame({"b": [0, 5, 6], "c": np.array([7, 8, 9], dtype=dtype)})
  176:     tm.assert_frame_equal(subset, expected)
  177:     # original parent dataframe is not modified (also not for BlockManager case,
  178:     # except for single block)
  179:     if not using_copy_on_write and (using_array_manager or single_block):
  180:         df_orig.iloc[0, 1] = 0
  181:         tm.assert_frame_equal(df, df_orig)
  182:     else:
  183:         tm.assert_frame_equal(df, df_orig)
  184: 
  185: 
  186: @pytest.mark.parametrize(
  187:     "dtype", ["int64", "float64"], ids=["single-block", "mixed-block"]
  188: )
  189: @pytest.mark.parametrize(
  190:     "row_indexer",
  191:     [slice(1, 2), np.array([False, True, True]), np.array([1, 2])],
  192:     ids=["slice", "mask", "array"],
  193: )
  194: @pytest.mark.parametrize(
  195:     "column_indexer",
  196:     [slice("b", "c"), np.array([False, True, True]), ["b", "c"]],
  197:     ids=["slice", "mask", "array"],
  198: )
  199: def test_subset_loc_rows_columns(
  200:     backend,
  201:     dtype,
  202:     row_indexer,
  203:     column_indexer,
  204:     using_array_manager,
  205:     using_copy_on_write,
  206:     warn_copy_on_write,
  207: ):
  208:     # Case: taking a subset of the rows+columns of a DataFrame using .loc
  209:     # + afterwards modifying the subset
  210:     # Generic test for several combinations of row/column indexers, not all
  211:     # of those could actually return a view / need CoW (so this test is not
  212:     # checking memory sharing, only ensuring subsequent mutation doesn't
  213:     # affect the parent dataframe)
  214:     dtype_backend, DataFrame, _ = backend
  215:     df = DataFrame(
  216:         {"a": [1, 2, 3], "b": [4, 5, 6], "c": np.array([7, 8, 9], dtype=dtype)}
  217:     )
  218:     df_orig = df.copy()
  219: 
  220:     subset = df.loc[row_indexer, column_indexer]
  221: 
  222:     # a few corner cases _do_ actually modify the parent (with both row and column
  223:     # slice, and in case of ArrayManager or BlockManager with single block)
  224:     mutate_parent = (
  225:         isinstance(row_indexer, slice)
  226:         and isinstance(column_indexer, slice)
  227:         and (
  228:             using_array_manager
  229:             or (
  230:                 dtype == "int64"
  231:                 and dtype_backend == "numpy"
  232:                 and not using_copy_on_write
  233:             )
  234:         )
  235:     )
  236: 
  237:     # modifying the subset never modifies the parent
  238:     with tm.assert_cow_warning(warn_copy_on_write and mutate_parent):
  239:         subset.iloc[0, 0] = 0
  240: 
  241:     expected = DataFrame(
  242:         {"b": [0, 6], "c": np.array([8, 9], dtype=dtype)}, index=range(1, 3)
  243:     )
  244:     tm.assert_frame_equal(subset, expected)
  245:     if mutate_parent:
  246:         df_orig.iloc[1, 1] = 0
  247:     tm.assert_frame_equal(df, df_orig)
  248: 
  249: 
  250: @pytest.mark.parametrize(
  251:     "dtype", ["int64", "float64"], ids=["single-block", "mixed-block"]
  252: )
  253: @pytest.mark.parametrize(
  254:     "row_indexer",
  255:     [slice(1, 3), np.array([False, True, True]), np.array([1, 2])],
  256:     ids=["slice", "mask", "array"],
  257: )
  258: @pytest.mark.parametrize(
  259:     "column_indexer",
  260:     [slice(1, 3), np.array([False, True, True]), [1, 2]],
  261:     ids=["slice", "mask", "array"],
  262: )
  263: def test_subset_iloc_rows_columns(
  264:     backend,
  265:     dtype,
  266:     row_indexer,
  267:     column_indexer,
  268:     using_array_manager,
  269:     using_copy_on_write,
  270:     warn_copy_on_write,
  271: ):
  272:     # Case: taking a subset of the rows+columns of a DataFrame using .iloc
  273:     # + afterwards modifying the subset
  274:     # Generic test for several combinations of row/column indexers, not all
  275:     # of those could actually return a view / need CoW (so this test is not
  276:     # checking memory sharing, only ensuring subsequent mutation doesn't
  277:     # affect the parent dataframe)
  278:     dtype_backend, DataFrame, _ = backend
  279:     df = DataFrame(
  280:         {"a": [1, 2, 3], "b": [4, 5, 6], "c": np.array([7, 8, 9], dtype=dtype)}
  281:     )
  282:     df_orig = df.copy()
  283: 
  284:     subset = df.iloc[row_indexer, column_indexer]
  285: 
  286:     # a few corner cases _do_ actually modify the parent (with both row and column
  287:     # slice, and in case of ArrayManager or BlockManager with single block)
  288:     mutate_parent = (
  289:         isinstance(row_indexer, slice)
  290:         and isinstance(column_indexer, slice)
  291:         and (
  292:             using_array_manager
  293:             or (
  294:                 dtype == "int64"
  295:                 and dtype_backend == "numpy"
  296:                 and not using_copy_on_write
  297:             )
  298:         )
  299:     )
  300: 
  301:     # modifying the subset never modifies the parent
  302:     with tm.assert_cow_warning(warn_copy_on_write and mutate_parent):
  303:         subset.iloc[0, 0] = 0
  304: 
  305:     expected = DataFrame(
  306:         {"b": [0, 6], "c": np.array([8, 9], dtype=dtype)}, index=range(1, 3)
  307:     )
  308:     tm.assert_frame_equal(subset, expected)
  309:     if mutate_parent:
  310:         df_orig.iloc[1, 1] = 0
  311:     tm.assert_frame_equal(df, df_orig)
  312: 
  313: 
  314: @pytest.mark.parametrize(
  315:     "indexer",
  316:     [slice(0, 2), np.array([True, True, False]), np.array([0, 1])],
  317:     ids=["slice", "mask", "array"],
  318: )
  319: def test_subset_set_with_row_indexer(
  320:     backend, indexer_si, indexer, using_copy_on_write, warn_copy_on_write
  321: ):
  322:     # Case: setting values with a row indexer on a viewing subset
  323:     # subset[indexer] = value and subset.iloc[indexer] = value
  324:     _, DataFrame, _ = backend
  325:     df = DataFrame({"a": [1, 2, 3, 4], "b": [4, 5, 6, 7], "c": [0.1, 0.2, 0.3, 0.4]})
  326:     df_orig = df.copy()
  327:     subset = df[1:4]
  328: 
  329:     if (
  330:         indexer_si is tm.setitem
  331:         and isinstance(indexer, np.ndarray)
  332:         and indexer.dtype == "int"
  333:     ):
  334:         pytest.skip("setitem with labels selects on columns")
  335: 
  336:     if using_copy_on_write:
  337:         indexer_si(subset)[indexer] = 0
  338:     elif warn_copy_on_write:
  339:         with tm.assert_cow_warning():
  340:             indexer_si(subset)[indexer] = 0
  341:     else:
  342:         # INFO iloc no longer raises warning since pandas 1.4
  343:         warn = SettingWithCopyWarning if indexer_si is tm.setitem else None
  344:         with pd.option_context("chained_assignment", "warn"):
  345:             with tm.assert_produces_warning(warn):
  346:                 indexer_si(subset)[indexer] = 0
  347: 
  348:     expected = DataFrame(
  349:         {"a": [0, 0, 4], "b": [0, 0, 7], "c": [0.0, 0.0, 0.4]}, index=range(1, 4)
  350:     )
  351:     tm.assert_frame_equal(subset, expected)
  352:     if using_copy_on_write:
  353:         # original parent dataframe is not modified (CoW)
  354:         tm.assert_frame_equal(df, df_orig)
  355:     else:
  356:         # original parent dataframe is actually updated
  357:         df_orig[1:3] = 0
  358:         tm.assert_frame_equal(df, df_orig)
  359: 
  360: 
  361: def test_subset_set_with_mask(backend, using_copy_on_write, warn_copy_on_write):
  362:     # Case: setting values with a mask on a viewing subset: subset[mask] = value
  363:     _, DataFrame, _ = backend
  364:     df = DataFrame({"a": [1, 2, 3, 4], "b": [4, 5, 6, 7], "c": [0.1, 0.2, 0.3, 0.4]})
  365:     df_orig = df.copy()
  366:     subset = df[1:4]
  367: 
  368:     mask = subset > 3
  369: 
  370:     if using_copy_on_write:
  371:         subset[mask] = 0
  372:     elif warn_copy_on_write:
  373:         with tm.assert_cow_warning():
  374:             subset[mask] = 0
  375:     else:
  376:         with pd.option_context("chained_assignment", "warn"):
  377:             with tm.assert_produces_warning(SettingWithCopyWarning):
  378:                 subset[mask] = 0
  379: 
  380:     expected = DataFrame(
  381:         {"a": [2, 3, 0], "b": [0, 0, 0], "c": [0.20, 0.3, 0.4]}, index=range(1, 4)
  382:     )
  383:     tm.assert_frame_equal(subset, expected)
  384:     if using_copy_on_write:
  385:         # original parent dataframe is not modified (CoW)
  386:         tm.assert_frame_equal(df, df_orig)
  387:     else:
  388:         # original parent dataframe is actually updated
  389:         df_orig.loc[3, "a"] = 0
  390:         df_orig.loc[1:3, "b"] = 0
  391:         tm.assert_frame_equal(df, df_orig)
  392: 
  393: 
  394: def test_subset_set_column(backend, using_copy_on_write, warn_copy_on_write):
  395:     # Case: setting a single column on a viewing subset -> subset[col] = value
  396:     dtype_backend, DataFrame, _ = backend
  397:     df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6], "c": [0.1, 0.2, 0.3]})
  398:     df_orig = df.copy()
  399:     subset = df[1:3]
  400: 
  401:     if dtype_backend == "numpy":
  402:         arr = np.array([10, 11], dtype="int64")
  403:     else:
  404:         arr = pd.array([10, 11], dtype="Int64")
  405: 
  406:     if using_copy_on_write or warn_copy_on_write:
  407:         subset["a"] = arr
  408:     else:
  409:         with pd.option_context("chained_assignment", "warn"):
  410:             with tm.assert_produces_warning(SettingWithCopyWarning):
  411:                 subset["a"] = arr
  412: 
  413:     subset._mgr._verify_integrity()
  414:     expected = DataFrame(
  415:         {"a": [10, 11], "b": [5, 6], "c": [0.2, 0.3]}, index=range(1, 3)
  416:     )
  417:     tm.assert_frame_equal(subset, expected)
  418:     tm.assert_frame_equal(df, df_orig)
  419: 
  420: 
  421: @pytest.mark.parametrize(
  422:     "dtype", ["int64", "float64"], ids=["single-block", "mixed-block"]
  423: )
  424: def test_subset_set_column_with_loc(
  425:     backend, using_copy_on_write, warn_copy_on_write, using_array_manager, dtype
  426: ):
  427:     # Case: setting a single column with loc on a viewing subset
  428:     # -> subset.loc[:, col] = value
  429:     _, DataFrame, _ = backend
  430:     df = DataFrame(
  431:         {"a": [1, 2, 3], "b": [4, 5, 6], "c": np.array([7, 8, 9], dtype=dtype)}
  432:     )
  433:     df_orig = df.copy()
  434:     subset = df[1:3]
  435: 
  436:     if using_copy_on_write:
  437:         subset.loc[:, "a"] = np.array([10, 11], dtype="int64")
  438:     elif warn_copy_on_write:
  439:         with tm.assert_cow_warning():
  440:             subset.loc[:, "a"] = np.array([10, 11], dtype="int64")
  441:     else:
  442:         with pd.option_context("chained_assignment", "warn"):
  443:             with tm.assert_produces_warning(
  444:                 None,
  445:                 raise_on_extra_warnings=not using_array_manager,
  446:             ):
  447:                 subset.loc[:, "a"] = np.array([10, 11], dtype="int64")
  448: 
  449:     subset._mgr._verify_integrity()
  450:     expected = DataFrame(
  451:         {"a": [10, 11], "b": [5, 6], "c": np.array([8, 9], dtype=dtype)},
  452:         index=range(1, 3),
  453:     )
  454:     tm.assert_frame_equal(subset, expected)
  455:     if using_copy_on_write:
  456:         # original parent dataframe is not modified (CoW)
  457:         tm.assert_frame_equal(df, df_orig)
  458:     else:
  459:         # original parent dataframe is actually updated
  460:         df_orig.loc[1:3, "a"] = np.array([10, 11], dtype="int64")
  461:         tm.assert_frame_equal(df, df_orig)
  462: 
  463: 
  464: def test_subset_set_column_with_loc2(
  465:     backend, using_copy_on_write, warn_copy_on_write, using_array_manager
  466: ):
  467:     # Case: setting a single column with loc on a viewing subset
  468:     # -> subset.loc[:, col] = value
  469:     # separate test for case of DataFrame of a single column -> takes a separate
  470:     # code path
  471:     _, DataFrame, _ = backend
  472:     df = DataFrame({"a": [1, 2, 3]})
  473:     df_orig = df.copy()
  474:     subset = df[1:3]
  475: 
  476:     if using_copy_on_write:
  477:         subset.loc[:, "a"] = 0
  478:     elif warn_copy_on_write:
  479:         with tm.assert_cow_warning():
  480:             subset.loc[:, "a"] = 0
  481:     else:
  482:         with pd.option_context("chained_assignment", "warn"):
  483:             with tm.assert_produces_warning(
  484:                 None,
  485:                 raise_on_extra_warnings=not using_array_manager,
  486:             ):
  487:                 subset.loc[:, "a"] = 0
  488: 
  489:     subset._mgr._verify_integrity()
  490:     expected = DataFrame({"a": [0, 0]}, index=range(1, 3))
  491:     tm.assert_frame_equal(subset, expected)
  492:     if using_copy_on_write:
  493:         # original parent dataframe is not modified (CoW)
  494:         tm.assert_frame_equal(df, df_orig)
  495:     else:
  496:         # original parent dataframe is actually updated
  497:         df_orig.loc[1:3, "a"] = 0
  498:         tm.assert_frame_equal(df, df_orig)
  499: 
  500: 
  501: @pytest.mark.parametrize(
  502:     "dtype", ["int64", "float64"], ids=["single-block", "mixed-block"]
  503: )
  504: def test_subset_set_columns(backend, using_copy_on_write, warn_copy_on_write, dtype):
  505:     # Case: setting multiple columns on a viewing subset
  506:     # -> subset[[col1, col2]] = value
  507:     dtype_backend, DataFrame, _ = backend
  508:     df = DataFrame(
  509:         {"a": [1, 2, 3], "b": [4, 5, 6], "c": np.array([7, 8, 9], dtype=dtype)}
  510:     )
  511:     df_orig = df.copy()
  512:     subset = df[1:3]
  513: 
  514:     if using_copy_on_write or warn_copy_on_write:
  515:         subset[["a", "c"]] = 0
  516:     else:
  517:         with pd.option_context("chained_assignment", "warn"):
  518:             with tm.assert_produces_warning(SettingWithCopyWarning):
  519:                 subset[["a", "c"]] = 0
  520: 
  521:     subset._mgr._verify_integrity()
  522:     if using_copy_on_write:
  523:         # first and third column should certainly have no references anymore
  524:         assert all(subset._mgr._has_no_reference(i) for i in [0, 2])
  525:     expected = DataFrame({"a": [0, 0], "b": [5, 6], "c": [0, 0]}, index=range(1, 3))
  526:     if dtype_backend == "nullable":
  527:         # there is not yet a global option, so overriding a column by setting a scalar
  528:         # defaults to numpy dtype even if original column was nullable
  529:         expected["a"] = expected["a"].astype("int64")
  530:         expected["c"] = expected["c"].astype("int64")
  531: 
  532:     tm.assert_frame_equal(subset, expected)
  533:     tm.assert_frame_equal(df, df_orig)
  534: 
  535: 
  536: @pytest.mark.parametrize(
  537:     "indexer",
  538:     [slice("a", "b"), np.array([True, True, False]), ["a", "b"]],
  539:     ids=["slice", "mask", "array"],
  540: )
  541: def test_subset_set_with_column_indexer(
  542:     backend, indexer, using_copy_on_write, warn_copy_on_write
  543: ):
  544:     # Case: setting multiple columns with a column indexer on a viewing subset
  545:     # -> subset.loc[:, [col1, col2]] = value
  546:     _, DataFrame, _ = backend
  547:     df = DataFrame({"a": [1, 2, 3], "b": [0.1, 0.2, 0.3], "c": [4, 5, 6]})
  548:     df_orig = df.copy()
  549:     subset = df[1:3]
  550: 
  551:     if using_copy_on_write:
  552:         subset.loc[:, indexer] = 0
  553:     elif warn_copy_on_write:
  554:         with tm.assert_cow_warning():
  555:             subset.loc[:, indexer] = 0
  556:     else:
  557:         with pd.option_context("chained_assignment", "warn"):
  558:             # As of 2.0, this setitem attempts (successfully) to set values
  559:             #  inplace, so the assignment is not chained.
  560:             subset.loc[:, indexer] = 0
  561: 
  562:     subset._mgr._verify_integrity()
  563:     expected = DataFrame({"a": [0, 0], "b": [0.0, 0.0], "c": [5, 6]}, index=range(1, 3))
  564:     tm.assert_frame_equal(subset, expected)
  565:     if using_copy_on_write:
  566:         tm.assert_frame_equal(df, df_orig)
  567:     else:
  568:         # pre-2.0, in the mixed case with BlockManager, only column "a"
  569:         #  would be mutated in the parent frame. this changed with the
  570:         #  enforcement of GH#45333
  571:         df_orig.loc[1:2, ["a", "b"]] = 0
  572:         tm.assert_frame_equal(df, df_orig)
  573: 
  574: 
  575: @pytest.mark.parametrize(
  576:     "method",
  577:     [
  578:         lambda df: df[["a", "b"]][0:2],
  579:         lambda df: df[0:2][["a", "b"]],
  580:         lambda df: df[["a", "b"]].iloc[0:2],
  581:         lambda df: df[["a", "b"]].loc[0:1],
  582:         lambda df: df[0:2].iloc[:, 0:2],
  583:         lambda df: df[0:2].loc[:, "a":"b"],  # type: ignore[misc]
  584:     ],
  585:     ids=[
  586:         "row-getitem-slice",
  587:         "column-getitem",
  588:         "row-iloc-slice",
  589:         "row-loc-slice",
  590:         "column-iloc-slice",
  591:         "column-loc-slice",
  592:     ],
  593: )
  594: @pytest.mark.parametrize(
  595:     "dtype", ["int64", "float64"], ids=["single-block", "mixed-block"]
  596: )
  597: def test_subset_chained_getitem(
  598:     request,
  599:     backend,
  600:     method,
  601:     dtype,
  602:     using_copy_on_write,
  603:     using_array_manager,
  604:     warn_copy_on_write,
  605: ):
  606:     # Case: creating a subset using multiple, chained getitem calls using views
  607:     # still needs to guarantee proper CoW behaviour
  608:     _, DataFrame, _ = backend
  609:     df = DataFrame(
  610:         {"a": [1, 2, 3], "b": [4, 5, 6], "c": np.array([7, 8, 9], dtype=dtype)}
  611:     )
  612:     df_orig = df.copy()
  613: 
  614:     # when not using CoW, it depends on whether we have a single block or not
  615:     # and whether we are slicing the columns -> in that case we have a view
  616:     test_callspec = request.node.callspec.id
  617:     if not using_array_manager:
  618:         subset_is_view = test_callspec in (
  619:             "numpy-single-block-column-iloc-slice",
  620:             "numpy-single-block-column-loc-slice",
  621:         )
  622:     else:
  623:         # with ArrayManager, it doesn't matter whether we have
  624:         # single vs mixed block or numpy vs nullable dtypes
  625:         subset_is_view = test_callspec.endswith(
  626:             ("column-iloc-slice", "column-loc-slice")
  627:         )
  628: 
  629:     # modify subset -> don't modify parent
  630:     subset = method(df)
  631: 
  632:     with tm.assert_cow_warning(warn_copy_on_write and subset_is_view):
  633:         subset.iloc[0, 0] = 0
  634:     if using_copy_on_write or (not subset_is_view):
  635:         tm.assert_frame_equal(df, df_orig)
  636:     else:
  637:         assert df.iloc[0, 0] == 0
  638: 
  639:     # modify parent -> don't modify subset
  640:     subset = method(df)
  641:     with tm.assert_cow_warning(warn_copy_on_write and subset_is_view):
  642:         df.iloc[0, 0] = 0
  643:     expected = DataFrame({"a": [1, 2], "b": [4, 5]})
  644:     if using_copy_on_write or not subset_is_view:
  645:         tm.assert_frame_equal(subset, expected)
  646:     else:
  647:         assert subset.iloc[0, 0] == 0
  648: 
  649: 
  650: @pytest.mark.parametrize(
  651:     "dtype", ["int64", "float64"], ids=["single-block", "mixed-block"]
  652: )
  653: def test_subset_chained_getitem_column(
  654:     backend, dtype, using_copy_on_write, warn_copy_on_write
  655: ):
  656:     # Case: creating a subset using multiple, chained getitem calls using views
  657:     # still needs to guarantee proper CoW behaviour
  658:     dtype_backend, DataFrame, Series = backend
  659:     df = DataFrame(
  660:         {"a": [1, 2, 3], "b": [4, 5, 6], "c": np.array([7, 8, 9], dtype=dtype)}
  661:     )
  662:     df_orig = df.copy()
  663: 
  664:     # modify subset -> don't modify parent
  665:     subset = df[:]["a"][0:2]
  666:     df._clear_item_cache()
  667:     with tm.assert_cow_warning(warn_copy_on_write):
  668:         subset.iloc[0] = 0
  669:     if using_copy_on_write:
  670:         tm.assert_frame_equal(df, df_orig)
  671:     else:
  672:         assert df.iloc[0, 0] == 0
  673: 
  674:     # modify parent -> don't modify subset
  675:     subset = df[:]["a"][0:2]
  676:     df._clear_item_cache()
  677:     with tm.assert_cow_warning(warn_copy_on_write):
  678:         df.iloc[0, 0] = 0
  679:     expected = Series([1, 2], name="a")
  680:     if using_copy_on_write:
  681:         tm.assert_series_equal(subset, expected)
  682:     else:
  683:         assert subset.iloc[0] == 0
  684: 
  685: 
  686: @pytest.mark.parametrize(
  687:     "method",
  688:     [
  689:         lambda s: s["a":"c"]["a":"b"],  # type: ignore[misc]
  690:         lambda s: s.iloc[0:3].iloc[0:2],
  691:         lambda s: s.loc["a":"c"].loc["a":"b"],  # type: ignore[misc]
  692:         lambda s: s.loc["a":"c"]  # type: ignore[misc]
  693:         .iloc[0:3]
  694:         .iloc[0:2]
  695:         .loc["a":"b"]  # type: ignore[misc]
  696:         .iloc[0:1],
  697:     ],
  698:     ids=["getitem", "iloc", "loc", "long-chain"],
  699: )
  700: def test_subset_chained_getitem_series(
  701:     backend, method, using_copy_on_write, warn_copy_on_write
  702: ):
  703:     # Case: creating a subset using multiple, chained getitem calls using views
  704:     # still needs to guarantee proper CoW behaviour
  705:     _, _, Series = backend
  706:     s = Series([1, 2, 3], index=["a", "b", "c"])
  707:     s_orig = s.copy()
  708: 
  709:     # modify subset -> don't modify parent
  710:     subset = method(s)
  711:     with tm.assert_cow_warning(warn_copy_on_write):
  712:         subset.iloc[0] = 0
  713:     if using_copy_on_write:
  714:         tm.assert_series_equal(s, s_orig)
  715:     else:
  716:         assert s.iloc[0] == 0
  717: 
  718:     # modify parent -> don't modify subset
  719:     subset = s.iloc[0:3].iloc[0:2]
  720:     with tm.assert_cow_warning(warn_copy_on_write):
  721:         s.iloc[0] = 0
  722:     expected = Series([1, 2], index=["a", "b"])
  723:     if using_copy_on_write:
  724:         tm.assert_series_equal(subset, expected)
  725:     else:
  726:         assert subset.iloc[0] == 0
  727: 
  728: 
  729: def test_subset_chained_single_block_row(
  730:     using_copy_on_write, using_array_manager, warn_copy_on_write
  731: ):
  732:     # not parametrizing this for dtype backend, since this explicitly tests single block
  733:     df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6], "c": [7, 8, 9]})
  734:     df_orig = df.copy()
  735: 
  736:     # modify subset -> don't modify parent
  737:     subset = df[:].iloc[0].iloc[0:2]
  738:     with tm.assert_cow_warning(warn_copy_on_write):
  739:         subset.iloc[0] = 0
  740:     if using_copy_on_write or using_array_manager:
  741:         tm.assert_frame_equal(df, df_orig)
  742:     else:
  743:         assert df.iloc[0, 0] == 0
  744: 
  745:     # modify parent -> don't modify subset
  746:     subset = df[:].iloc[0].iloc[0:2]
  747:     with tm.assert_cow_warning(warn_copy_on_write):
  748:         df.iloc[0, 0] = 0
  749:     expected = Series([1, 4], index=["a", "b"], name=0)
  750:     if using_copy_on_write or using_array_manager:
  751:         tm.assert_series_equal(subset, expected)
  752:     else:
  753:         assert subset.iloc[0] == 0
  754: 
  755: 
  756: @pytest.mark.parametrize(
  757:     "method",
  758:     [
  759:         lambda df: df[:],
  760:         lambda df: df.loc[:, :],
  761:         lambda df: df.loc[:],
  762:         lambda df: df.iloc[:, :],
  763:         lambda df: df.iloc[:],
  764:     ],
  765:     ids=["getitem", "loc", "loc-rows", "iloc", "iloc-rows"],
  766: )
  767: def test_null_slice(backend, method, using_copy_on_write, warn_copy_on_write):
  768:     # Case: also all variants of indexing with a null slice (:) should return
  769:     # new objects to ensure we correctly use CoW for the results
  770:     dtype_backend, DataFrame, _ = backend
  771:     df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6], "c": [7, 8, 9]})
  772:     df_orig = df.copy()
  773: 
  774:     df2 = method(df)
  775: 
  776:     # we always return new objects (shallow copy), regardless of CoW or not
  777:     assert df2 is not df
  778: 
  779:     # and those trigger CoW when mutated
  780:     with tm.assert_cow_warning(warn_copy_on_write):
  781:         df2.iloc[0, 0] = 0
  782:     if using_copy_on_write:
  783:         tm.assert_frame_equal(df, df_orig)
  784:     else:
  785:         assert df.iloc[0, 0] == 0
  786: 
  787: 
  788: @pytest.mark.parametrize(
  789:     "method",
  790:     [
  791:         lambda s: s[:],
  792:         lambda s: s.loc[:],
  793:         lambda s: s.iloc[:],
  794:     ],
  795:     ids=["getitem", "loc", "iloc"],
  796: )
  797: def test_null_slice_series(backend, method, using_copy_on_write, warn_copy_on_write):
  798:     _, _, Series = backend
  799:     s = Series([1, 2, 3], index=["a", "b", "c"])
  800:     s_orig = s.copy()
  801: 
  802:     s2 = method(s)
  803: 
  804:     # we always return new objects, regardless of CoW or not
  805:     assert s2 is not s
  806: 
  807:     # and those trigger CoW when mutated
  808:     with tm.assert_cow_warning(warn_copy_on_write):
  809:         s2.iloc[0] = 0
  810:     if using_copy_on_write:
  811:         tm.assert_series_equal(s, s_orig)
  812:     else:
  813:         assert s.iloc[0] == 0
  814: 
  815: 
  816: # TODO add more tests modifying the parent
  817: 
  818: 
  819: # -----------------------------------------------------------------------------
  820: # Series -- Indexing operations taking subset + modifying the subset/parent
  821: 
  822: 
  823: def test_series_getitem_slice(backend, using_copy_on_write, warn_copy_on_write):
  824:     # Case: taking a slice of a Series + afterwards modifying the subset
  825:     _, _, Series = backend
  826:     s = Series([1, 2, 3], index=["a", "b", "c"])
  827:     s_orig = s.copy()
  828: 
  829:     subset = s[:]
  830:     assert np.shares_memory(get_array(subset), get_array(s))
  831: 
  832:     with tm.assert_cow_warning(warn_copy_on_write):
  833:         subset.iloc[0] = 0
  834: 
  835:     if using_copy_on_write:
  836:         assert not np.shares_memory(get_array(subset), get_array(s))
  837: 
  838:     expected = Series([0, 2, 3], index=["a", "b", "c"])
  839:     tm.assert_series_equal(subset, expected)
  840: 
  841:     if using_copy_on_write:
  842:         # original parent series is not modified (CoW)
  843:         tm.assert_series_equal(s, s_orig)
  844:     else:
  845:         # original parent series is actually updated
  846:         assert s.iloc[0] == 0
  847: 
  848: 
  849: def test_series_getitem_ellipsis(using_copy_on_write, warn_copy_on_write):
  850:     # Case: taking a view of a Series using Ellipsis + afterwards modifying the subset
  851:     s = Series([1, 2, 3])
  852:     s_orig = s.copy()
  853: 
  854:     subset = s[...]
  855:     assert np.shares_memory(get_array(subset), get_array(s))
  856: 
  857:     with tm.assert_cow_warning(warn_copy_on_write):
  858:         subset.iloc[0] = 0
  859: 
  860:     if using_copy_on_write:
  861:         assert not np.shares_memory(get_array(subset), get_array(s))
  862: 
  863:     expected = Series([0, 2, 3])
  864:     tm.assert_series_equal(subset, expected)
  865: 
  866:     if using_copy_on_write:
  867:         # original parent series is not modified (CoW)
  868:         tm.assert_series_equal(s, s_orig)
  869:     else:
  870:         # original parent series is actually updated
  871:         assert s.iloc[0] == 0
  872: 
  873: 
  874: @pytest.mark.parametrize(
  875:     "indexer",
  876:     [slice(0, 2), np.array([True, True, False]), np.array([0, 1])],
  877:     ids=["slice", "mask", "array"],
  878: )
  879: def test_series_subset_set_with_indexer(
  880:     backend, indexer_si, indexer, using_copy_on_write, warn_copy_on_write
  881: ):
  882:     # Case: setting values in a viewing Series with an indexer
  883:     _, _, Series = backend
  884:     s = Series([1, 2, 3], index=["a", "b", "c"])
  885:     s_orig = s.copy()
  886:     subset = s[:]
  887: 
  888:     warn = None
  889:     msg = "Series.__setitem__ treating keys as positions is deprecated"
  890:     if (
  891:         indexer_si is tm.setitem
  892:         and isinstance(indexer, np.ndarray)
  893:         and indexer.dtype.kind == "i"
  894:     ):
  895:         warn = FutureWarning
  896:     if warn_copy_on_write:
  897:         with tm.assert_cow_warning(raise_on_extra_warnings=warn is not None):
  898:             indexer_si(subset)[indexer] = 0
  899:     else:
  900:         with tm.assert_produces_warning(warn, match=msg):
  901:             indexer_si(subset)[indexer] = 0
  902:     expected = Series([0, 0, 3], index=["a", "b", "c"])
  903:     tm.assert_series_equal(subset, expected)
  904: 
  905:     if using_copy_on_write:
  906:         tm.assert_series_equal(s, s_orig)
  907:     else:
  908:         tm.assert_series_equal(s, expected)
  909: 
  910: 
  911: # -----------------------------------------------------------------------------
  912: # del operator
  913: 
  914: 
  915: def test_del_frame(backend, using_copy_on_write, warn_copy_on_write):
  916:     # Case: deleting a column with `del` on a viewing child dataframe should
  917:     # not modify parent + update the references
  918:     dtype_backend, DataFrame, _ = backend
  919:     df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6], "c": [0.1, 0.2, 0.3]})
  920:     df_orig = df.copy()
  921:     df2 = df[:]
  922: 
  923:     assert np.shares_memory(get_array(df, "a"), get_array(df2, "a"))
  924: 
  925:     del df2["b"]
  926: 
  927:     assert np.shares_memory(get_array(df, "a"), get_array(df2, "a"))
  928:     tm.assert_frame_equal(df, df_orig)
  929:     tm.assert_frame_equal(df2, df_orig[["a", "c"]])
  930:     df2._mgr._verify_integrity()
  931: 
  932:     with tm.assert_cow_warning(warn_copy_on_write and dtype_backend == "numpy"):
  933:         df.loc[0, "b"] = 200
  934:     assert np.shares_memory(get_array(df, "a"), get_array(df2, "a"))
  935:     df_orig = df.copy()
  936: 
  937:     with tm.assert_cow_warning(warn_copy_on_write):
  938:         df2.loc[0, "a"] = 100
  939:     if using_copy_on_write:
  940:         # modifying child after deleting a column still doesn't update parent
  941:         tm.assert_frame_equal(df, df_orig)
  942:     else:
  943:         assert df.loc[0, "a"] == 100
  944: 
  945: 
  946: def test_del_series(backend):
  947:     _, _, Series = backend
  948:     s = Series([1, 2, 3], index=["a", "b", "c"])
  949:     s_orig = s.copy()
  950:     s2 = s[:]
  951: 
  952:     assert np.shares_memory(get_array(s), get_array(s2))
  953: 
  954:     del s2["a"]
  955: 
  956:     assert not np.shares_memory(get_array(s), get_array(s2))
  957:     tm.assert_series_equal(s, s_orig)
  958:     tm.assert_series_equal(s2, s_orig[["b", "c"]])
  959: 
  960:     # modifying s2 doesn't need copy on write (due to `del`, s2 is backed by new array)
  961:     values = s2.values
  962:     s2.loc["b"] = 100
  963:     assert values[0] == 100
  964: 
  965: 
  966: # -----------------------------------------------------------------------------
  967: # Accessing column as Series
  968: 
  969: 
  970: def test_column_as_series(
  971:     backend, using_copy_on_write, warn_copy_on_write, using_array_manager
  972: ):
  973:     # Case: selecting a single column now also uses Copy-on-Write
  974:     dtype_backend, DataFrame, Series = backend
  975:     df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6], "c": [0.1, 0.2, 0.3]})
  976:     df_orig = df.copy()
  977: 
  978:     s = df["a"]
  979: 
  980:     assert np.shares_memory(get_array(s, "a"), get_array(df, "a"))
  981: 
  982:     if using_copy_on_write or using_array_manager:
  983:         s[0] = 0
  984:     else:
  985:         if warn_copy_on_write:
  986:             with tm.assert_cow_warning():
  987:                 s[0] = 0
  988:         else:
  989:             warn = SettingWithCopyWarning if dtype_backend == "numpy" else None
  990:             with pd.option_context("chained_assignment", "warn"):
  991:                 with tm.assert_produces_warning(warn):
  992:                     s[0] = 0
  993: 
  994:     expected = Series([0, 2, 3], name="a")
  995:     tm.assert_series_equal(s, expected)
  996:     if using_copy_on_write:
  997:         # assert not np.shares_memory(s.values, get_array(df, "a"))
  998:         tm.assert_frame_equal(df, df_orig)
  999:         # ensure cached series on getitem is not the changed series
 1000:         tm.assert_series_equal(df["a"], df_orig["a"])
 1001:     else:
 1002:         df_orig.iloc[0, 0] = 0
 1003:         tm.assert_frame_equal(df, df_orig)
 1004: 
 1005: 
 1006: def test_column_as_series_set_with_upcast(
 1007:     backend, using_copy_on_write, using_array_manager, warn_copy_on_write
 1008: ):
 1009:     # Case: selecting a single column now also uses Copy-on-Write -> when
 1010:     # setting a value causes an upcast, we don't need to update the parent
 1011:     # DataFrame through the cache mechanism
 1012:     dtype_backend, DataFrame, Series = backend
 1013:     df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6], "c": [0.1, 0.2, 0.3]})
 1014:     df_orig = df.copy()
 1015: 
 1016:     s = df["a"]
 1017:     if dtype_backend == "nullable":
 1018:         with tm.assert_cow_warning(warn_copy_on_write):
 1019:             with pytest.raises(TypeError, match="Invalid value"):
 1020:                 s[0] = "foo"
 1021:         expected = Series([1, 2, 3], name="a")
 1022:     elif using_copy_on_write or warn_copy_on_write or using_array_manager:
 1023:         # TODO(CoW-warn) assert the FutureWarning for CoW is also raised
 1024:         with tm.assert_produces_warning(FutureWarning, match="incompatible dtype"):
 1025:             s[0] = "foo"
 1026:         expected = Series(["foo", 2, 3], dtype=object, name="a")
 1027:     else:
 1028:         with pd.option_context("chained_assignment", "warn"):
 1029:             msg = "|".join(
 1030:                 [
 1031:                     "A value is trying to be set on a copy of a slice from a DataFrame",
 1032:                     "Setting an item of incompatible dtype is deprecated",
 1033:                 ]
 1034:             )
 1035:             with tm.assert_produces_warning(
 1036:                 (SettingWithCopyWarning, FutureWarning), match=msg
 1037:             ):
 1038:                 s[0] = "foo"
 1039:         expected = Series(["foo", 2, 3], dtype=object, name="a")
 1040: 
 1041:     tm.assert_series_equal(s, expected)
 1042:     if using_copy_on_write:
 1043:         tm.assert_frame_equal(df, df_orig)
 1044:         # ensure cached series on getitem is not the changed series
 1045:         tm.assert_series_equal(df["a"], df_orig["a"])
 1046:     else:
 1047:         df_orig["a"] = expected
 1048:         tm.assert_frame_equal(df, df_orig)
 1049: 
 1050: 
 1051: @pytest.mark.parametrize(
 1052:     "method",
 1053:     [
 1054:         lambda df: df["a"],
 1055:         lambda df: df.loc[:, "a"],
 1056:         lambda df: df.iloc[:, 0],
 1057:     ],
 1058:     ids=["getitem", "loc", "iloc"],
 1059: )
 1060: def test_column_as_series_no_item_cache(
 1061:     request,
 1062:     backend,
 1063:     method,
 1064:     using_copy_on_write,
 1065:     warn_copy_on_write,
 1066:     using_array_manager,
 1067: ):
 1068:     # Case: selecting a single column (which now also uses Copy-on-Write to protect
 1069:     # the view) should always give a new object (i.e. not make use of a cache)
 1070:     dtype_backend, DataFrame, _ = backend
 1071:     df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6], "c": [0.1, 0.2, 0.3]})
 1072:     df_orig = df.copy()
 1073: 
 1074:     s1 = method(df)
 1075:     s2 = method(df)
 1076: 
 1077:     is_iloc = "iloc" in request.node.name
 1078:     if using_copy_on_write or warn_copy_on_write or is_iloc:
 1079:         assert s1 is not s2
 1080:     else:
 1081:         assert s1 is s2
 1082: 
 1083:     if using_copy_on_write or using_array_manager:
 1084:         s1.iloc[0] = 0
 1085:     elif warn_copy_on_write:
 1086:         with tm.assert_cow_warning():
 1087:             s1.iloc[0] = 0
 1088:     else:
 1089:         warn = SettingWithCopyWarning if dtype_backend == "numpy" else None
 1090:         with pd.option_context("chained_assignment", "warn"):
 1091:             with tm.assert_produces_warning(warn):
 1092:                 s1.iloc[0] = 0
 1093: 
 1094:     if using_copy_on_write:
 1095:         tm.assert_series_equal(s2, df_orig["a"])
 1096:         tm.assert_frame_equal(df, df_orig)
 1097:     else:
 1098:         assert s2.iloc[0] == 0
 1099: 
 1100: 
 1101: # TODO add tests for other indexing methods on the Series
 1102: 
 1103: 
 1104: def test_dataframe_add_column_from_series(backend, using_copy_on_write):
 1105:     # Case: adding a new column to a DataFrame from an existing column/series
 1106:     # -> delays copy under CoW
 1107:     _, DataFrame, Series = backend
 1108:     df = DataFrame({"a": [1, 2, 3], "b": [0.1, 0.2, 0.3]})
 1109: 
 1110:     s = Series([10, 11, 12])
 1111:     df["new"] = s
 1112:     if using_copy_on_write:
 1113:         assert np.shares_memory(get_array(df, "new"), get_array(s))
 1114:     else:
 1115:         assert not np.shares_memory(get_array(df, "new"), get_array(s))
 1116: 
 1117:     # editing series -> doesn't modify column in frame
 1118:     s[0] = 0
 1119:     expected = DataFrame({"a": [1, 2, 3], "b": [0.1, 0.2, 0.3], "new": [10, 11, 12]})
 1120:     tm.assert_frame_equal(df, expected)
 1121: 
 1122: 
 1123: @pytest.mark.parametrize("val", [100, "a"])
 1124: @pytest.mark.parametrize(
 1125:     "indexer_func, indexer",
 1126:     [
 1127:         (tm.loc, (0, "a")),
 1128:         (tm.iloc, (0, 0)),
 1129:         (tm.loc, ([0], "a")),
 1130:         (tm.iloc, ([0], 0)),
 1131:         (tm.loc, (slice(None), "a")),
 1132:         (tm.iloc, (slice(None), 0)),
 1133:     ],
 1134: )
 1135: @pytest.mark.parametrize(
 1136:     "col", [[0.1, 0.2, 0.3], [7, 8, 9]], ids=["mixed-block", "single-block"]
 1137: )
 1138: def test_set_value_copy_only_necessary_column(
 1139:     using_copy_on_write, warn_copy_on_write, indexer_func, indexer, val, col
 1140: ):
 1141:     # When setting inplace, only copy column that is modified instead of the whole
 1142:     # block (by splitting the block)
 1143:     df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6], "c": col})
 1144:     df_orig = df.copy()
 1145:     view = df[:]
 1146: 
 1147:     if val == "a" and not warn_copy_on_write:
 1148:         with tm.assert_produces_warning(
 1149:             FutureWarning, match="Setting an item of incompatible dtype is deprecated"
 1150:         ):
 1151:             indexer_func(df)[indexer] = val
 1152:     if val == "a" and warn_copy_on_write:
 1153:         with tm.assert_produces_warning(
 1154:             FutureWarning, match="incompatible dtype|Setting a value on a view"
 1155:         ):
 1156:             indexer_func(df)[indexer] = val
 1157:     else:
 1158:         with tm.assert_cow_warning(warn_copy_on_write and val == 100):
 1159:             indexer_func(df)[indexer] = val
 1160: 
 1161:     if using_copy_on_write:
 1162:         assert np.shares_memory(get_array(df, "b"), get_array(view, "b"))
 1163:         assert not np.shares_memory(get_array(df, "a"), get_array(view, "a"))
 1164:         tm.assert_frame_equal(view, df_orig)
 1165:     else:
 1166:         assert np.shares_memory(get_array(df, "c"), get_array(view, "c"))
 1167:         if val == "a":
 1168:             assert not np.shares_memory(get_array(df, "a"), get_array(view, "a"))
 1169:         else:
 1170:             assert np.shares_memory(get_array(df, "a"), get_array(view, "a"))
 1171: 
 1172: 
 1173: def test_series_midx_slice(using_copy_on_write, warn_copy_on_write):
 1174:     ser = Series([1, 2, 3], index=pd.MultiIndex.from_arrays([[1, 1, 2], [3, 4, 5]]))
 1175:     ser_orig = ser.copy()
 1176:     result = ser[1]
 1177:     assert np.shares_memory(get_array(ser), get_array(result))
 1178:     with tm.assert_cow_warning(warn_copy_on_write):
 1179:         result.iloc[0] = 100
 1180:     if using_copy_on_write:
 1181:         tm.assert_series_equal(ser, ser_orig)
 1182:     else:
 1183:         expected = Series(
 1184:             [100, 2, 3], index=pd.MultiIndex.from_arrays([[1, 1, 2], [3, 4, 5]])
 1185:         )
 1186:         tm.assert_series_equal(ser, expected)
 1187: 
 1188: 
 1189: def test_getitem_midx_slice(
 1190:     using_copy_on_write, warn_copy_on_write, using_array_manager
 1191: ):
 1192:     df = DataFrame({("a", "x"): [1, 2], ("a", "y"): 1, ("b", "x"): 2})
 1193:     df_orig = df.copy()
 1194:     new_df = df[("a",)]
 1195: 
 1196:     if using_copy_on_write:
 1197:         assert not new_df._mgr._has_no_reference(0)
 1198: 
 1199:     if not using_array_manager:
 1200:         assert np.shares_memory(get_array(df, ("a", "x")), get_array(new_df, "x"))
 1201:     if using_copy_on_write:
 1202:         new_df.iloc[0, 0] = 100
 1203:         tm.assert_frame_equal(df_orig, df)
 1204:     else:
 1205:         if warn_copy_on_write:
 1206:             with tm.assert_cow_warning():
 1207:                 new_df.iloc[0, 0] = 100
 1208:         else:
 1209:             with pd.option_context("chained_assignment", "warn"):
 1210:                 with tm.assert_produces_warning(SettingWithCopyWarning):
 1211:                     new_df.iloc[0, 0] = 100
 1212:         assert df.iloc[0, 0] == 100
 1213: 
 1214: 
 1215: def test_series_midx_tuples_slice(using_copy_on_write, warn_copy_on_write):
 1216:     ser = Series(
 1217:         [1, 2, 3],
 1218:         index=pd.MultiIndex.from_tuples([((1, 2), 3), ((1, 2), 4), ((2, 3), 4)]),
 1219:     )
 1220:     result = ser[(1, 2)]
 1221:     assert np.shares_memory(get_array(ser), get_array(result))
 1222:     with tm.assert_cow_warning(warn_copy_on_write):
 1223:         result.iloc[0] = 100
 1224:     if using_copy_on_write:
 1225:         expected = Series(
 1226:             [1, 2, 3],
 1227:             index=pd.MultiIndex.from_tuples([((1, 2), 3), ((1, 2), 4), ((2, 3), 4)]),
 1228:         )
 1229:         tm.assert_series_equal(ser, expected)
 1230: 
 1231: 
 1232: def test_midx_read_only_bool_indexer():
 1233:     # GH#56635
 1234:     def mklbl(prefix, n):
 1235:         return [f"{prefix}{i}" for i in range(n)]
 1236: 
 1237:     idx = pd.MultiIndex.from_product(
 1238:         [mklbl("A", 4), mklbl("B", 2), mklbl("C", 4), mklbl("D", 2)]
 1239:     )
 1240:     cols = pd.MultiIndex.from_tuples(
 1241:         [("a", "foo"), ("a", "bar"), ("b", "foo"), ("b", "bah")], names=["lvl0", "lvl1"]
 1242:     )
 1243:     df = DataFrame(1, index=idx, columns=cols).sort_index().sort_index(axis=1)
 1244: 
 1245:     mask = df[("a", "foo")] == 1
 1246:     expected_mask = mask.copy()
 1247:     result = df.loc[pd.IndexSlice[mask, :, ["C1", "C3"]], :]
 1248:     expected = df.loc[pd.IndexSlice[:, :, ["C1", "C3"]], :]
 1249:     tm.assert_frame_equal(result, expected)
 1250:     tm.assert_series_equal(mask, expected_mask)
 1251: 
 1252: 
 1253: def test_loc_enlarging_with_dataframe(using_copy_on_write):
 1254:     df = DataFrame({"a": [1, 2, 3]})
 1255:     rhs = DataFrame({"b": [1, 2, 3], "c": [4, 5, 6]})
 1256:     rhs_orig = rhs.copy()
 1257:     df.loc[:, ["b", "c"]] = rhs
 1258:     if using_copy_on_write:
 1259:         assert np.shares_memory(get_array(df, "b"), get_array(rhs, "b"))
 1260:         assert np.shares_memory(get_array(df, "c"), get_array(rhs, "c"))
 1261:         assert not df._mgr._has_no_reference(1)
 1262:     else:
 1263:         assert not np.shares_memory(get_array(df, "b"), get_array(rhs, "b"))
 1264: 
 1265:     df.iloc[0, 1] = 100
 1266:     tm.assert_frame_equal(rhs, rhs_orig)
