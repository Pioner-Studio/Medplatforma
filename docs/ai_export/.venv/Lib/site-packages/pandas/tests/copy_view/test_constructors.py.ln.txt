    1: import numpy as np
    2: import pytest
    3: 
    4: import pandas as pd
    5: from pandas import (
    6:     DataFrame,
    7:     DatetimeIndex,
    8:     Index,
    9:     Period,
   10:     PeriodIndex,
   11:     Series,
   12:     Timedelta,
   13:     TimedeltaIndex,
   14:     Timestamp,
   15: )
   16: import pandas._testing as tm
   17: from pandas.tests.copy_view.util import get_array
   18: 
   19: # -----------------------------------------------------------------------------
   20: # Copy/view behaviour for Series / DataFrame constructors
   21: 
   22: 
   23: @pytest.mark.parametrize("dtype", [None, "int64"])
   24: def test_series_from_series(dtype, using_copy_on_write, warn_copy_on_write):
   25:     # Case: constructing a Series from another Series object follows CoW rules:
   26:     # a new object is returned and thus mutations are not propagated
   27:     ser = Series([1, 2, 3], name="name")
   28: 
   29:     # default is copy=False -> new Series is a shallow copy / view of original
   30:     result = Series(ser, dtype=dtype)
   31: 
   32:     # the shallow copy still shares memory
   33:     assert np.shares_memory(get_array(ser), get_array(result))
   34: 
   35:     if using_copy_on_write:
   36:         assert result._mgr.blocks[0].refs.has_reference()
   37: 
   38:     if using_copy_on_write:
   39:         # mutating new series copy doesn't mutate original
   40:         result.iloc[0] = 0
   41:         assert ser.iloc[0] == 1
   42:         # mutating triggered a copy-on-write -> no longer shares memory
   43:         assert not np.shares_memory(get_array(ser), get_array(result))
   44:     else:
   45:         # mutating shallow copy does mutate original
   46:         with tm.assert_cow_warning(warn_copy_on_write):
   47:             result.iloc[0] = 0
   48:         assert ser.iloc[0] == 0
   49:         # and still shares memory
   50:         assert np.shares_memory(get_array(ser), get_array(result))
   51: 
   52:     # the same when modifying the parent
   53:     result = Series(ser, dtype=dtype)
   54: 
   55:     if using_copy_on_write:
   56:         # mutating original doesn't mutate new series
   57:         ser.iloc[0] = 0
   58:         assert result.iloc[0] == 1
   59:     else:
   60:         # mutating original does mutate shallow copy
   61:         with tm.assert_cow_warning(warn_copy_on_write):
   62:             ser.iloc[0] = 0
   63:         assert result.iloc[0] == 0
   64: 
   65: 
   66: def test_series_from_series_with_reindex(using_copy_on_write, warn_copy_on_write):
   67:     # Case: constructing a Series from another Series with specifying an index
   68:     # that potentially requires a reindex of the values
   69:     ser = Series([1, 2, 3], name="name")
   70: 
   71:     # passing an index that doesn't actually require a reindex of the values
   72:     # -> without CoW we get an actual mutating view
   73:     for index in [
   74:         ser.index,
   75:         ser.index.copy(),
   76:         list(ser.index),
   77:         ser.index.rename("idx"),
   78:     ]:
   79:         result = Series(ser, index=index)
   80:         assert np.shares_memory(ser.values, result.values)
   81:         with tm.assert_cow_warning(warn_copy_on_write):
   82:             result.iloc[0] = 0
   83:         if using_copy_on_write:
   84:             assert ser.iloc[0] == 1
   85:         else:
   86:             assert ser.iloc[0] == 0
   87: 
   88:     # ensure that if an actual reindex is needed, we don't have any refs
   89:     # (mutating the result wouldn't trigger CoW)
   90:     result = Series(ser, index=[0, 1, 2, 3])
   91:     assert not np.shares_memory(ser.values, result.values)
   92:     if using_copy_on_write:
   93:         assert not result._mgr.blocks[0].refs.has_reference()
   94: 
   95: 
   96: @pytest.mark.parametrize("fastpath", [False, True])
   97: @pytest.mark.parametrize("dtype", [None, "int64"])
   98: @pytest.mark.parametrize("idx", [None, pd.RangeIndex(start=0, stop=3, step=1)])
   99: @pytest.mark.parametrize(
  100:     "arr", [np.array([1, 2, 3], dtype="int64"), pd.array([1, 2, 3], dtype="Int64")]
  101: )
  102: def test_series_from_array(using_copy_on_write, idx, dtype, fastpath, arr):
  103:     if idx is None or dtype is not None:
  104:         fastpath = False
  105:     msg = "The 'fastpath' keyword in pd.Series is deprecated"
  106:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
  107:         ser = Series(arr, dtype=dtype, index=idx, fastpath=fastpath)
  108:     ser_orig = ser.copy()
  109:     data = getattr(arr, "_data", arr)
  110:     if using_copy_on_write:
  111:         assert not np.shares_memory(get_array(ser), data)
  112:     else:
  113:         assert np.shares_memory(get_array(ser), data)
  114: 
  115:     arr[0] = 100
  116:     if using_copy_on_write:
  117:         tm.assert_series_equal(ser, ser_orig)
  118:     else:
  119:         expected = Series([100, 2, 3], dtype=dtype if dtype is not None else arr.dtype)
  120:         tm.assert_series_equal(ser, expected)
  121: 
  122: 
  123: @pytest.mark.parametrize("copy", [True, False, None])
  124: def test_series_from_array_different_dtype(using_copy_on_write, copy):
  125:     arr = np.array([1, 2, 3], dtype="int64")
  126:     ser = Series(arr, dtype="int32", copy=copy)
  127:     assert not np.shares_memory(get_array(ser), arr)
  128: 
  129: 
  130: @pytest.mark.parametrize(
  131:     "idx",
  132:     [
  133:         Index([1, 2]),
  134:         DatetimeIndex([Timestamp("2019-12-31"), Timestamp("2020-12-31")]),
  135:         PeriodIndex([Period("2019-12-31"), Period("2020-12-31")]),
  136:         TimedeltaIndex([Timedelta("1 days"), Timedelta("2 days")]),
  137:     ],
  138: )
  139: def test_series_from_index(using_copy_on_write, idx):
  140:     ser = Series(idx)
  141:     expected = idx.copy(deep=True)
  142:     if using_copy_on_write:
  143:         assert np.shares_memory(get_array(ser), get_array(idx))
  144:         assert not ser._mgr._has_no_reference(0)
  145:     else:
  146:         assert not np.shares_memory(get_array(ser), get_array(idx))
  147:     ser.iloc[0] = ser.iloc[1]
  148:     tm.assert_index_equal(idx, expected)
  149: 
  150: 
  151: def test_series_from_index_different_dtypes(using_copy_on_write):
  152:     idx = Index([1, 2, 3], dtype="int64")
  153:     ser = Series(idx, dtype="int32")
  154:     assert not np.shares_memory(get_array(ser), get_array(idx))
  155:     if using_copy_on_write:
  156:         assert ser._mgr._has_no_reference(0)
  157: 
  158: 
  159: @pytest.mark.filterwarnings("ignore:Setting a value on a view:FutureWarning")
  160: @pytest.mark.parametrize("fastpath", [False, True])
  161: @pytest.mark.parametrize("dtype", [None, "int64"])
  162: @pytest.mark.parametrize("idx", [None, pd.RangeIndex(start=0, stop=3, step=1)])
  163: def test_series_from_block_manager(using_copy_on_write, idx, dtype, fastpath):
  164:     ser = Series([1, 2, 3], dtype="int64")
  165:     ser_orig = ser.copy()
  166:     msg = "The 'fastpath' keyword in pd.Series is deprecated"
  167:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
  168:         ser2 = Series(ser._mgr, dtype=dtype, fastpath=fastpath, index=idx)
  169:     assert np.shares_memory(get_array(ser), get_array(ser2))
  170:     if using_copy_on_write:
  171:         assert not ser2._mgr._has_no_reference(0)
  172: 
  173:     ser2.iloc[0] = 100
  174:     if using_copy_on_write:
  175:         tm.assert_series_equal(ser, ser_orig)
  176:     else:
  177:         expected = Series([100, 2, 3])
  178:         tm.assert_series_equal(ser, expected)
  179: 
  180: 
  181: def test_series_from_block_manager_different_dtype(using_copy_on_write):
  182:     ser = Series([1, 2, 3], dtype="int64")
  183:     msg = "Passing a SingleBlockManager to Series"
  184:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
  185:         ser2 = Series(ser._mgr, dtype="int32")
  186:     assert not np.shares_memory(get_array(ser), get_array(ser2))
  187:     if using_copy_on_write:
  188:         assert ser2._mgr._has_no_reference(0)
  189: 
  190: 
  191: @pytest.mark.parametrize("use_mgr", [True, False])
  192: @pytest.mark.parametrize("columns", [None, ["a"]])
  193: def test_dataframe_constructor_mgr_or_df(
  194:     using_copy_on_write, warn_copy_on_write, columns, use_mgr
  195: ):
  196:     df = DataFrame({"a": [1, 2, 3]})
  197:     df_orig = df.copy()
  198: 
  199:     if use_mgr:
  200:         data = df._mgr
  201:         warn = DeprecationWarning
  202:     else:
  203:         data = df
  204:         warn = None
  205:     msg = "Passing a BlockManager to DataFrame"
  206:     with tm.assert_produces_warning(warn, match=msg, check_stacklevel=False):
  207:         new_df = DataFrame(data)
  208: 
  209:     assert np.shares_memory(get_array(df, "a"), get_array(new_df, "a"))
  210:     with tm.assert_cow_warning(warn_copy_on_write and not use_mgr):
  211:         new_df.iloc[0] = 100
  212: 
  213:     if using_copy_on_write:
  214:         assert not np.shares_memory(get_array(df, "a"), get_array(new_df, "a"))
  215:         tm.assert_frame_equal(df, df_orig)
  216:     else:
  217:         assert np.shares_memory(get_array(df, "a"), get_array(new_df, "a"))
  218:         tm.assert_frame_equal(df, new_df)
  219: 
  220: 
  221: @pytest.mark.parametrize("dtype", [None, "int64", "Int64"])
  222: @pytest.mark.parametrize("index", [None, [0, 1, 2]])
  223: @pytest.mark.parametrize("columns", [None, ["a", "b"], ["a", "b", "c"]])
  224: def test_dataframe_from_dict_of_series(
  225:     request, using_copy_on_write, warn_copy_on_write, columns, index, dtype
  226: ):
  227:     # Case: constructing a DataFrame from Series objects with copy=False
  228:     # has to do a lazy following CoW rules
  229:     # (the default for DataFrame(dict) is still to copy to ensure consolidation)
  230:     s1 = Series([1, 2, 3])
  231:     s2 = Series([4, 5, 6])
  232:     s1_orig = s1.copy()
  233:     expected = DataFrame(
  234:         {"a": [1, 2, 3], "b": [4, 5, 6]}, index=index, columns=columns, dtype=dtype
  235:     )
  236: 
  237:     result = DataFrame(
  238:         {"a": s1, "b": s2}, index=index, columns=columns, dtype=dtype, copy=False
  239:     )
  240: 
  241:     # the shallow copy still shares memory
  242:     assert np.shares_memory(get_array(result, "a"), get_array(s1))
  243: 
  244:     # mutating the new dataframe doesn't mutate original
  245:     with tm.assert_cow_warning(warn_copy_on_write):
  246:         result.iloc[0, 0] = 10
  247:     if using_copy_on_write:
  248:         assert not np.shares_memory(get_array(result, "a"), get_array(s1))
  249:         tm.assert_series_equal(s1, s1_orig)
  250:     else:
  251:         assert s1.iloc[0] == 10
  252: 
  253:     # the same when modifying the parent series
  254:     s1 = Series([1, 2, 3])
  255:     s2 = Series([4, 5, 6])
  256:     result = DataFrame(
  257:         {"a": s1, "b": s2}, index=index, columns=columns, dtype=dtype, copy=False
  258:     )
  259:     with tm.assert_cow_warning(warn_copy_on_write):
  260:         s1.iloc[0] = 10
  261:     if using_copy_on_write:
  262:         assert not np.shares_memory(get_array(result, "a"), get_array(s1))
  263:         tm.assert_frame_equal(result, expected)
  264:     else:
  265:         assert result.iloc[0, 0] == 10
  266: 
  267: 
  268: @pytest.mark.parametrize("dtype", [None, "int64"])
  269: def test_dataframe_from_dict_of_series_with_reindex(dtype):
  270:     # Case: constructing a DataFrame from Series objects with copy=False
  271:     # and passing an index that requires an actual (no-view) reindex -> need
  272:     # to ensure the result doesn't have refs set up to unnecessarily trigger
  273:     # a copy on write
  274:     s1 = Series([1, 2, 3])
  275:     s2 = Series([4, 5, 6])
  276:     df = DataFrame({"a": s1, "b": s2}, index=[1, 2, 3], dtype=dtype, copy=False)
  277: 
  278:     # df should own its memory, so mutating shouldn't trigger a copy
  279:     arr_before = get_array(df, "a")
  280:     assert not np.shares_memory(arr_before, get_array(s1))
  281:     df.iloc[0, 0] = 100
  282:     arr_after = get_array(df, "a")
  283:     assert np.shares_memory(arr_before, arr_after)
  284: 
  285: 
  286: @pytest.mark.parametrize("cons", [Series, Index])
  287: @pytest.mark.parametrize(
  288:     "data, dtype", [([1, 2], None), ([1, 2], "int64"), (["a", "b"], None)]
  289: )
  290: def test_dataframe_from_series_or_index(
  291:     using_copy_on_write, warn_copy_on_write, data, dtype, cons
  292: ):
  293:     obj = cons(data, dtype=dtype)
  294:     obj_orig = obj.copy()
  295:     df = DataFrame(obj, dtype=dtype)
  296:     assert np.shares_memory(get_array(obj), get_array(df, 0))
  297:     if using_copy_on_write:
  298:         assert not df._mgr._has_no_reference(0)
  299: 
  300:     with tm.assert_cow_warning(warn_copy_on_write):
  301:         df.iloc[0, 0] = data[-1]
  302:     if using_copy_on_write:
  303:         tm.assert_equal(obj, obj_orig)
  304: 
  305: 
  306: @pytest.mark.parametrize("cons", [Series, Index])
  307: def test_dataframe_from_series_or_index_different_dtype(using_copy_on_write, cons):
  308:     obj = cons([1, 2], dtype="int64")
  309:     df = DataFrame(obj, dtype="int32")
  310:     assert not np.shares_memory(get_array(obj), get_array(df, 0))
  311:     if using_copy_on_write:
  312:         assert df._mgr._has_no_reference(0)
  313: 
  314: 
  315: def test_dataframe_from_series_infer_datetime(using_copy_on_write):
  316:     ser = Series([Timestamp("2019-12-31"), Timestamp("2020-12-31")], dtype=object)
  317:     with tm.assert_produces_warning(FutureWarning, match="Dtype inference"):
  318:         df = DataFrame(ser)
  319:     assert not np.shares_memory(get_array(ser), get_array(df, 0))
  320:     if using_copy_on_write:
  321:         assert df._mgr._has_no_reference(0)
  322: 
  323: 
  324: @pytest.mark.parametrize("index", [None, [0, 1, 2]])
  325: def test_dataframe_from_dict_of_series_with_dtype(index):
  326:     # Variant of above, but now passing a dtype that causes a copy
  327:     # -> need to ensure the result doesn't have refs set up to unnecessarily
  328:     # trigger a copy on write
  329:     s1 = Series([1.0, 2.0, 3.0])
  330:     s2 = Series([4, 5, 6])
  331:     df = DataFrame({"a": s1, "b": s2}, index=index, dtype="int64", copy=False)
  332: 
  333:     # df should own its memory, so mutating shouldn't trigger a copy
  334:     arr_before = get_array(df, "a")
  335:     assert not np.shares_memory(arr_before, get_array(s1))
  336:     df.iloc[0, 0] = 100
  337:     arr_after = get_array(df, "a")
  338:     assert np.shares_memory(arr_before, arr_after)
  339: 
  340: 
  341: @pytest.mark.parametrize("copy", [False, None, True])
  342: def test_frame_from_numpy_array(using_copy_on_write, copy, using_array_manager):
  343:     arr = np.array([[1, 2], [3, 4]])
  344:     df = DataFrame(arr, copy=copy)
  345: 
  346:     if (
  347:         using_copy_on_write
  348:         and copy is not False
  349:         or copy is True
  350:         or (using_array_manager and copy is None)
  351:     ):
  352:         assert not np.shares_memory(get_array(df, 0), arr)
  353:     else:
  354:         assert np.shares_memory(get_array(df, 0), arr)
  355: 
  356: 
  357: def test_dataframe_from_records_with_dataframe(using_copy_on_write, warn_copy_on_write):
  358:     df = DataFrame({"a": [1, 2, 3]})
  359:     df_orig = df.copy()
  360:     with tm.assert_produces_warning(FutureWarning):
  361:         df2 = DataFrame.from_records(df)
  362:     if using_copy_on_write:
  363:         assert not df._mgr._has_no_reference(0)
  364:     assert np.shares_memory(get_array(df, "a"), get_array(df2, "a"))
  365:     with tm.assert_cow_warning(warn_copy_on_write):
  366:         df2.iloc[0, 0] = 100
  367:     if using_copy_on_write:
  368:         tm.assert_frame_equal(df, df_orig)
  369:     else:
  370:         tm.assert_frame_equal(df, df2)
  371: 
  372: 
  373: def test_frame_from_dict_of_index(using_copy_on_write):
  374:     idx = Index([1, 2, 3])
  375:     expected = idx.copy(deep=True)
  376:     df = DataFrame({"a": idx}, copy=False)
  377:     assert np.shares_memory(get_array(df, "a"), idx._values)
  378:     if using_copy_on_write:
  379:         assert not df._mgr._has_no_reference(0)
  380: 
  381:         df.iloc[0, 0] = 100
  382:         tm.assert_index_equal(idx, expected)
