    1: import datetime
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: import pandas as pd
    7: from pandas import (
    8:     DataFrame,
    9:     MultiIndex,
   10:     Series,
   11: )
   12: import pandas._testing as tm
   13: 
   14: 
   15: class TestMultiLevel:
   16:     def test_reindex_level(self, multiindex_year_month_day_dataframe_random_data):
   17:         # axis=0
   18:         ymd = multiindex_year_month_day_dataframe_random_data
   19: 
   20:         month_sums = ymd.groupby("month").sum()
   21:         result = month_sums.reindex(ymd.index, level=1)
   22:         expected = ymd.groupby(level="month").transform("sum")
   23: 
   24:         tm.assert_frame_equal(result, expected)
   25: 
   26:         # Series
   27:         result = month_sums["A"].reindex(ymd.index, level=1)
   28:         expected = ymd["A"].groupby(level="month").transform("sum")
   29:         tm.assert_series_equal(result, expected, check_names=False)
   30: 
   31:         # axis=1
   32:         msg = "DataFrame.groupby with axis=1 is deprecated"
   33:         with tm.assert_produces_warning(FutureWarning, match=msg):
   34:             gb = ymd.T.groupby("month", axis=1)
   35: 
   36:         month_sums = gb.sum()
   37:         result = month_sums.reindex(columns=ymd.index, level=1)
   38:         expected = ymd.groupby(level="month").transform("sum").T
   39:         tm.assert_frame_equal(result, expected)
   40: 
   41:     def test_reindex(self, multiindex_dataframe_random_data):
   42:         frame = multiindex_dataframe_random_data
   43: 
   44:         expected = frame.iloc[[0, 3]]
   45:         reindexed = frame.loc[[("foo", "one"), ("bar", "one")]]
   46:         tm.assert_frame_equal(reindexed, expected)
   47: 
   48:     def test_reindex_preserve_levels(
   49:         self, multiindex_year_month_day_dataframe_random_data, using_copy_on_write
   50:     ):
   51:         ymd = multiindex_year_month_day_dataframe_random_data
   52: 
   53:         new_index = ymd.index[::10]
   54:         chunk = ymd.reindex(new_index)
   55:         if using_copy_on_write:
   56:             assert chunk.index.is_(new_index)
   57:         else:
   58:             assert chunk.index is new_index
   59: 
   60:         chunk = ymd.loc[new_index]
   61:         assert chunk.index.equals(new_index)
   62: 
   63:         ymdT = ymd.T
   64:         chunk = ymdT.reindex(columns=new_index)
   65:         if using_copy_on_write:
   66:             assert chunk.columns.is_(new_index)
   67:         else:
   68:             assert chunk.columns is new_index
   69: 
   70:         chunk = ymdT.loc[:, new_index]
   71:         assert chunk.columns.equals(new_index)
   72: 
   73:     def test_groupby_transform(self, multiindex_dataframe_random_data):
   74:         frame = multiindex_dataframe_random_data
   75: 
   76:         s = frame["A"]
   77:         grouper = s.index.get_level_values(0)
   78: 
   79:         grouped = s.groupby(grouper, group_keys=False)
   80: 
   81:         applied = grouped.apply(lambda x: x * 2)
   82:         expected = grouped.transform(lambda x: x * 2)
   83:         result = applied.reindex(expected.index)
   84:         tm.assert_series_equal(result, expected, check_names=False)
   85: 
   86:     def test_groupby_corner(self):
   87:         midx = MultiIndex(
   88:             levels=[["foo"], ["bar"], ["baz"]],
   89:             codes=[[0], [0], [0]],
   90:             names=["one", "two", "three"],
   91:         )
   92:         df = DataFrame(
   93:             [np.random.default_rng(2).random(4)],
   94:             columns=["a", "b", "c", "d"],
   95:             index=midx,
   96:         )
   97:         # should work
   98:         df.groupby(level="three")
   99: 
  100:     def test_groupby_level_no_obs(self):
  101:         # #1697
  102:         midx = MultiIndex.from_tuples(
  103:             [
  104:                 ("f1", "s1"),
  105:                 ("f1", "s2"),
  106:                 ("f2", "s1"),
  107:                 ("f2", "s2"),
  108:                 ("f3", "s1"),
  109:                 ("f3", "s2"),
  110:             ]
  111:         )
  112:         df = DataFrame([[1, 2, 3, 4, 5, 6], [7, 8, 9, 10, 11, 12]], columns=midx)
  113:         df1 = df.loc(axis=1)[df.columns.map(lambda u: u[0] in ["f2", "f3"])]
  114: 
  115:         msg = "DataFrame.groupby with axis=1 is deprecated"
  116:         with tm.assert_produces_warning(FutureWarning, match=msg):
  117:             grouped = df1.groupby(axis=1, level=0)
  118:         result = grouped.sum()
  119:         assert (result.columns == ["f2", "f3"]).all()
  120: 
  121:     def test_setitem_with_expansion_multiindex_columns(
  122:         self, multiindex_year_month_day_dataframe_random_data
  123:     ):
  124:         ymd = multiindex_year_month_day_dataframe_random_data
  125: 
  126:         df = ymd[:5].T
  127:         df[2000, 1, 10] = df[2000, 1, 7]
  128:         assert isinstance(df.columns, MultiIndex)
  129:         assert (df[2000, 1, 10] == df[2000, 1, 7]).all()
  130: 
  131:     def test_alignment(self):
  132:         x = Series(
  133:             data=[1, 2, 3], index=MultiIndex.from_tuples([("A", 1), ("A", 2), ("B", 3)])
  134:         )
  135: 
  136:         y = Series(
  137:             data=[4, 5, 6], index=MultiIndex.from_tuples([("Z", 1), ("Z", 2), ("B", 3)])
  138:         )
  139: 
  140:         res = x - y
  141:         exp_index = x.index.union(y.index)
  142:         exp = x.reindex(exp_index) - y.reindex(exp_index)
  143:         tm.assert_series_equal(res, exp)
  144: 
  145:         # hit non-monotonic code path
  146:         res = x[::-1] - y[::-1]
  147:         exp_index = x.index.union(y.index)
  148:         exp = x.reindex(exp_index) - y.reindex(exp_index)
  149:         tm.assert_series_equal(res, exp)
  150: 
  151:     def test_groupby_multilevel(self, multiindex_year_month_day_dataframe_random_data):
  152:         ymd = multiindex_year_month_day_dataframe_random_data
  153: 
  154:         result = ymd.groupby(level=[0, 1]).mean()
  155: 
  156:         k1 = ymd.index.get_level_values(0)
  157:         k2 = ymd.index.get_level_values(1)
  158: 
  159:         expected = ymd.groupby([k1, k2]).mean()
  160: 
  161:         # TODO groupby with level_values drops names
  162:         tm.assert_frame_equal(result, expected, check_names=False)
  163:         assert result.index.names == ymd.index.names[:2]
  164: 
  165:         result2 = ymd.groupby(level=ymd.index.names[:2]).mean()
  166:         tm.assert_frame_equal(result, result2)
  167: 
  168:     def test_multilevel_consolidate(self):
  169:         index = MultiIndex.from_tuples(
  170:             [("foo", "one"), ("foo", "two"), ("bar", "one"), ("bar", "two")]
  171:         )
  172:         df = DataFrame(
  173:             np.random.default_rng(2).standard_normal((4, 4)), index=index, columns=index
  174:         )
  175:         df["Totals", ""] = df.sum(1)
  176:         df = df._consolidate()
  177: 
  178:     def test_level_with_tuples(self):
  179:         index = MultiIndex(
  180:             levels=[[("foo", "bar", 0), ("foo", "baz", 0), ("foo", "qux", 0)], [0, 1]],
  181:             codes=[[0, 0, 1, 1, 2, 2], [0, 1, 0, 1, 0, 1]],
  182:         )
  183: 
  184:         series = Series(np.random.default_rng(2).standard_normal(6), index=index)
  185:         frame = DataFrame(np.random.default_rng(2).standard_normal((6, 4)), index=index)
  186: 
  187:         result = series[("foo", "bar", 0)]
  188:         result2 = series.loc[("foo", "bar", 0)]
  189:         expected = series[:2]
  190:         expected.index = expected.index.droplevel(0)
  191:         tm.assert_series_equal(result, expected)
  192:         tm.assert_series_equal(result2, expected)
  193: 
  194:         with pytest.raises(KeyError, match=r"^\(\('foo', 'bar', 0\), 2\)$"):
  195:             series[("foo", "bar", 0), 2]
  196: 
  197:         result = frame.loc[("foo", "bar", 0)]
  198:         result2 = frame.xs(("foo", "bar", 0))
  199:         expected = frame[:2]
  200:         expected.index = expected.index.droplevel(0)
  201:         tm.assert_frame_equal(result, expected)
  202:         tm.assert_frame_equal(result2, expected)
  203: 
  204:         index = MultiIndex(
  205:             levels=[[("foo", "bar"), ("foo", "baz"), ("foo", "qux")], [0, 1]],
  206:             codes=[[0, 0, 1, 1, 2, 2], [0, 1, 0, 1, 0, 1]],
  207:         )
  208: 
  209:         series = Series(np.random.default_rng(2).standard_normal(6), index=index)
  210:         frame = DataFrame(np.random.default_rng(2).standard_normal((6, 4)), index=index)
  211: 
  212:         result = series[("foo", "bar")]
  213:         result2 = series.loc[("foo", "bar")]
  214:         expected = series[:2]
  215:         expected.index = expected.index.droplevel(0)
  216:         tm.assert_series_equal(result, expected)
  217:         tm.assert_series_equal(result2, expected)
  218: 
  219:         result = frame.loc[("foo", "bar")]
  220:         result2 = frame.xs(("foo", "bar"))
  221:         expected = frame[:2]
  222:         expected.index = expected.index.droplevel(0)
  223:         tm.assert_frame_equal(result, expected)
  224:         tm.assert_frame_equal(result2, expected)
  225: 
  226:     def test_reindex_level_partial_selection(self, multiindex_dataframe_random_data):
  227:         frame = multiindex_dataframe_random_data
  228: 
  229:         result = frame.reindex(["foo", "qux"], level=0)
  230:         expected = frame.iloc[[0, 1, 2, 7, 8, 9]]
  231:         tm.assert_frame_equal(result, expected)
  232: 
  233:         result = frame.T.reindex(["foo", "qux"], axis=1, level=0)
  234:         tm.assert_frame_equal(result, expected.T)
  235: 
  236:         result = frame.loc[["foo", "qux"]]
  237:         tm.assert_frame_equal(result, expected)
  238: 
  239:         result = frame["A"].loc[["foo", "qux"]]
  240:         tm.assert_series_equal(result, expected["A"])
  241: 
  242:         result = frame.T.loc[:, ["foo", "qux"]]
  243:         tm.assert_frame_equal(result, expected.T)
  244: 
  245:     @pytest.mark.parametrize("d", [4, "d"])
  246:     def test_empty_frame_groupby_dtypes_consistency(self, d):
  247:         # GH 20888
  248:         group_keys = ["a", "b", "c"]
  249:         df = DataFrame({"a": [1], "b": [2], "c": [3], "d": [d]})
  250: 
  251:         g = df[df.a == 2].groupby(group_keys)
  252:         result = g.first().index
  253:         expected = MultiIndex(
  254:             levels=[[1], [2], [3]], codes=[[], [], []], names=["a", "b", "c"]
  255:         )
  256: 
  257:         tm.assert_index_equal(result, expected)
  258: 
  259:     def test_duplicate_groupby_issues(self):
  260:         idx_tp = [
  261:             ("600809", "20061231"),
  262:             ("600809", "20070331"),
  263:             ("600809", "20070630"),
  264:             ("600809", "20070331"),
  265:         ]
  266:         dt = ["demo", "demo", "demo", "demo"]
  267: 
  268:         idx = MultiIndex.from_tuples(idx_tp, names=["STK_ID", "RPT_Date"])
  269:         s = Series(dt, index=idx)
  270: 
  271:         result = s.groupby(s.index).first()
  272:         assert len(result) == 3
  273: 
  274:     def test_subsets_multiindex_dtype(self):
  275:         # GH 20757
  276:         data = [["x", 1]]
  277:         columns = [("a", "b", np.nan), ("a", "c", 0.0)]
  278:         df = DataFrame(data, columns=MultiIndex.from_tuples(columns))
  279:         expected = df.dtypes.a.b
  280:         result = df.a.b.dtypes
  281:         tm.assert_series_equal(result, expected)
  282: 
  283:     def test_datetime_object_multiindex(self):
  284:         data_dic = {
  285:             (0, datetime.date(2018, 3, 3)): {"A": 1, "B": 10},
  286:             (0, datetime.date(2018, 3, 4)): {"A": 2, "B": 11},
  287:             (1, datetime.date(2018, 3, 3)): {"A": 3, "B": 12},
  288:             (1, datetime.date(2018, 3, 4)): {"A": 4, "B": 13},
  289:         }
  290:         result = DataFrame.from_dict(data_dic, orient="index")
  291:         data = {"A": [1, 2, 3, 4], "B": [10, 11, 12, 13]}
  292:         index = [
  293:             [0, 0, 1, 1],
  294:             [
  295:                 datetime.date(2018, 3, 3),
  296:                 datetime.date(2018, 3, 4),
  297:                 datetime.date(2018, 3, 3),
  298:                 datetime.date(2018, 3, 4),
  299:             ],
  300:         ]
  301:         expected = DataFrame(data=data, index=index)
  302: 
  303:         tm.assert_frame_equal(result, expected)
  304: 
  305:     def test_multiindex_with_na(self):
  306:         df = DataFrame(
  307:             [
  308:                 ["A", np.nan, 1.23, 4.56],
  309:                 ["A", "G", 1.23, 4.56],
  310:                 ["A", "D", 9.87, 10.54],
  311:             ],
  312:             columns=["pivot_0", "pivot_1", "col_1", "col_2"],
  313:         ).set_index(["pivot_0", "pivot_1"])
  314: 
  315:         df.at[("A", "F"), "col_2"] = 0.0
  316: 
  317:         expected = DataFrame(
  318:             [
  319:                 ["A", np.nan, 1.23, 4.56],
  320:                 ["A", "G", 1.23, 4.56],
  321:                 ["A", "D", 9.87, 10.54],
  322:                 ["A", "F", np.nan, 0.0],
  323:             ],
  324:             columns=["pivot_0", "pivot_1", "col_1", "col_2"],
  325:         ).set_index(["pivot_0", "pivot_1"])
  326: 
  327:         tm.assert_frame_equal(df, expected)
  328: 
  329: 
  330: class TestSorted:
  331:     """everything you wanted to test about sorting"""
  332: 
  333:     def test_sort_non_lexsorted(self):
  334:         # degenerate case where we sort but don't
  335:         # have a satisfying result :<
  336:         # GH 15797
  337:         idx = MultiIndex(
  338:             [["A", "B", "C"], ["c", "b", "a"]], [[0, 1, 2, 0, 1, 2], [0, 2, 1, 1, 0, 2]]
  339:         )
  340: 
  341:         df = DataFrame({"col": range(len(idx))}, index=idx, dtype="int64")
  342:         assert df.index.is_monotonic_increasing is False
  343: 
  344:         sorted = df.sort_index()
  345:         assert sorted.index.is_monotonic_increasing is True
  346: 
  347:         expected = DataFrame(
  348:             {"col": [1, 4, 5, 2]},
  349:             index=MultiIndex.from_tuples(
  350:                 [("B", "a"), ("B", "c"), ("C", "a"), ("C", "b")]
  351:             ),
  352:             dtype="int64",
  353:         )
  354:         result = sorted.loc[pd.IndexSlice["B":"C", "a":"c"], :]
  355:         tm.assert_frame_equal(result, expected)
