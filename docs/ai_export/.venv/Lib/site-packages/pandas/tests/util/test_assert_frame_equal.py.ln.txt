    1: import pytest
    2: 
    3: import pandas as pd
    4: from pandas import DataFrame
    5: import pandas._testing as tm
    6: 
    7: 
    8: @pytest.fixture(params=[True, False])
    9: def by_blocks_fixture(request):
   10:     return request.param
   11: 
   12: 
   13: @pytest.fixture(params=["DataFrame", "Series"])
   14: def obj_fixture(request):
   15:     return request.param
   16: 
   17: 
   18: def _assert_frame_equal_both(a, b, **kwargs):
   19:     """
   20:     Check that two DataFrame equal.
   21: 
   22:     This check is performed commutatively.
   23: 
   24:     Parameters
   25:     ----------
   26:     a : DataFrame
   27:         The first DataFrame to compare.
   28:     b : DataFrame
   29:         The second DataFrame to compare.
   30:     kwargs : dict
   31:         The arguments passed to `tm.assert_frame_equal`.
   32:     """
   33:     tm.assert_frame_equal(a, b, **kwargs)
   34:     tm.assert_frame_equal(b, a, **kwargs)
   35: 
   36: 
   37: @pytest.mark.parametrize("check_like", [True, False])
   38: def test_frame_equal_row_order_mismatch(check_like, obj_fixture):
   39:     df1 = DataFrame({"A": [1, 2, 3], "B": [4, 5, 6]}, index=["a", "b", "c"])
   40:     df2 = DataFrame({"A": [3, 2, 1], "B": [6, 5, 4]}, index=["c", "b", "a"])
   41: 
   42:     if not check_like:  # Do not ignore row-column orderings.
   43:         msg = f"{obj_fixture}.index are different"
   44:         with pytest.raises(AssertionError, match=msg):
   45:             tm.assert_frame_equal(df1, df2, check_like=check_like, obj=obj_fixture)
   46:     else:
   47:         _assert_frame_equal_both(df1, df2, check_like=check_like, obj=obj_fixture)
   48: 
   49: 
   50: @pytest.mark.parametrize(
   51:     "df1,df2",
   52:     [
   53:         (DataFrame({"A": [1, 2, 3]}), DataFrame({"A": [1, 2, 3, 4]})),
   54:         (DataFrame({"A": [1, 2, 3], "B": [4, 5, 6]}), DataFrame({"A": [1, 2, 3]})),
   55:     ],
   56: )
   57: def test_frame_equal_shape_mismatch(df1, df2, obj_fixture):
   58:     msg = f"{obj_fixture} are different"
   59: 
   60:     with pytest.raises(AssertionError, match=msg):
   61:         tm.assert_frame_equal(df1, df2, obj=obj_fixture)
   62: 
   63: 
   64: @pytest.mark.parametrize(
   65:     "df1,df2,msg",
   66:     [
   67:         # Index
   68:         (
   69:             DataFrame.from_records({"a": [1, 2], "c": ["l1", "l2"]}, index=["a"]),
   70:             DataFrame.from_records({"a": [1.0, 2.0], "c": ["l1", "l2"]}, index=["a"]),
   71:             "DataFrame\\.index are different",
   72:         ),
   73:         # MultiIndex
   74:         (
   75:             DataFrame.from_records(
   76:                 {"a": [1, 2], "b": [2.1, 1.5], "c": ["l1", "l2"]}, index=["a", "b"]
   77:             ),
   78:             DataFrame.from_records(
   79:                 {"a": [1.0, 2.0], "b": [2.1, 1.5], "c": ["l1", "l2"]}, index=["a", "b"]
   80:             ),
   81:             "MultiIndex level \\[0\\] are different",
   82:         ),
   83:     ],
   84: )
   85: def test_frame_equal_index_dtype_mismatch(df1, df2, msg, check_index_type):
   86:     kwargs = {"check_index_type": check_index_type}
   87: 
   88:     if check_index_type:
   89:         with pytest.raises(AssertionError, match=msg):
   90:             tm.assert_frame_equal(df1, df2, **kwargs)
   91:     else:
   92:         tm.assert_frame_equal(df1, df2, **kwargs)
   93: 
   94: 
   95: def test_empty_dtypes(check_dtype):
   96:     columns = ["col1", "col2"]
   97:     df1 = DataFrame(columns=columns)
   98:     df2 = DataFrame(columns=columns)
   99: 
  100:     kwargs = {"check_dtype": check_dtype}
  101:     df1["col1"] = df1["col1"].astype("int64")
  102: 
  103:     if check_dtype:
  104:         msg = r"Attributes of DataFrame\..* are different"
  105:         with pytest.raises(AssertionError, match=msg):
  106:             tm.assert_frame_equal(df1, df2, **kwargs)
  107:     else:
  108:         tm.assert_frame_equal(df1, df2, **kwargs)
  109: 
  110: 
  111: @pytest.mark.parametrize("check_like", [True, False])
  112: def test_frame_equal_index_mismatch(check_like, obj_fixture, using_infer_string):
  113:     if using_infer_string:
  114:         dtype = "string"
  115:     else:
  116:         dtype = "object"
  117:     msg = f"""{obj_fixture}\\.index are different
  118: 
  119: {obj_fixture}\\.index values are different \\(33\\.33333 %\\)
  120: \\[left\\]:  Index\\(\\['a', 'b', 'c'\\], dtype='{dtype}'\\)
  121: \\[right\\]: Index\\(\\['a', 'b', 'd'\\], dtype='{dtype}'\\)
  122: At positional index 2, first diff: c != d"""
  123: 
  124:     df1 = DataFrame({"A": [1, 2, 3], "B": [4, 5, 6]}, index=["a", "b", "c"])
  125:     df2 = DataFrame({"A": [1, 2, 3], "B": [4, 5, 6]}, index=["a", "b", "d"])
  126: 
  127:     with pytest.raises(AssertionError, match=msg):
  128:         tm.assert_frame_equal(df1, df2, check_like=check_like, obj=obj_fixture)
  129: 
  130: 
  131: @pytest.mark.parametrize("check_like", [True, False])
  132: def test_frame_equal_columns_mismatch(check_like, obj_fixture, using_infer_string):
  133:     if using_infer_string:
  134:         dtype = "string"
  135:     else:
  136:         dtype = "object"
  137:     msg = f"""{obj_fixture}\\.columns are different
  138: 
  139: {obj_fixture}\\.columns values are different \\(50\\.0 %\\)
  140: \\[left\\]:  Index\\(\\['A', 'B'\\], dtype='{dtype}'\\)
  141: \\[right\\]: Index\\(\\['A', 'b'\\], dtype='{dtype}'\\)"""
  142: 
  143:     df1 = DataFrame({"A": [1, 2, 3], "B": [4, 5, 6]}, index=["a", "b", "c"])
  144:     df2 = DataFrame({"A": [1, 2, 3], "b": [4, 5, 6]}, index=["a", "b", "c"])
  145: 
  146:     with pytest.raises(AssertionError, match=msg):
  147:         tm.assert_frame_equal(df1, df2, check_like=check_like, obj=obj_fixture)
  148: 
  149: 
  150: def test_frame_equal_block_mismatch(by_blocks_fixture, obj_fixture):
  151:     obj = obj_fixture
  152:     msg = f"""{obj}\\.iloc\\[:, 1\\] \\(column name="B"\\) are different
  153: 
  154: {obj}\\.iloc\\[:, 1\\] \\(column name="B"\\) values are different \\(33\\.33333 %\\)
  155: \\[index\\]: \\[0, 1, 2\\]
  156: \\[left\\]:  \\[4, 5, 6\\]
  157: \\[right\\]: \\[4, 5, 7\\]"""
  158: 
  159:     df1 = DataFrame({"A": [1, 2, 3], "B": [4, 5, 6]})
  160:     df2 = DataFrame({"A": [1, 2, 3], "B": [4, 5, 7]})
  161: 
  162:     with pytest.raises(AssertionError, match=msg):
  163:         tm.assert_frame_equal(df1, df2, by_blocks=by_blocks_fixture, obj=obj_fixture)
  164: 
  165: 
  166: @pytest.mark.parametrize(
  167:     "df1,df2,msg",
  168:     [
  169:         (
  170:             DataFrame({"A": ["ГЎ", "Г ", "Г¤"], "E": ["Г©", "ГЁ", "Г«"]}),
  171:             DataFrame({"A": ["ГЎ", "Г ", "Г¤"], "E": ["Г©", "ГЁ", "eМЉ"]}),
  172:             """{obj}\\.iloc\\[:, 1\\] \\(column name="E"\\) are different
  173: 
  174: {obj}\\.iloc\\[:, 1\\] \\(column name="E"\\) values are different \\(33\\.33333 %\\)
  175: \\[index\\]: \\[0, 1, 2\\]
  176: \\[left\\]:  \\[Г©, ГЁ, Г«\\]
  177: \\[right\\]: \\[Г©, ГЁ, eМЉ\\]""",
  178:         ),
  179:         (
  180:             DataFrame({"A": ["ГЎ", "Г ", "Г¤"], "E": ["Г©", "ГЁ", "Г«"]}),
  181:             DataFrame({"A": ["a", "a", "a"], "E": ["e", "e", "e"]}),
  182:             """{obj}\\.iloc\\[:, 0\\] \\(column name="A"\\) are different
  183: 
  184: {obj}\\.iloc\\[:, 0\\] \\(column name="A"\\) values are different \\(100\\.0 %\\)
  185: \\[index\\]: \\[0, 1, 2\\]
  186: \\[left\\]:  \\[ГЎ, Г , Г¤\\]
  187: \\[right\\]: \\[a, a, a\\]""",
  188:         ),
  189:     ],
  190: )
  191: def test_frame_equal_unicode(df1, df2, msg, by_blocks_fixture, obj_fixture):
  192:     # see gh-20503
  193:     #
  194:     # Test ensures that `tm.assert_frame_equals` raises the right exception
  195:     # when comparing DataFrames containing differing unicode objects.
  196:     msg = msg.format(obj=obj_fixture)
  197:     with pytest.raises(AssertionError, match=msg):
  198:         tm.assert_frame_equal(df1, df2, by_blocks=by_blocks_fixture, obj=obj_fixture)
  199: 
  200: 
  201: def test_assert_frame_equal_extension_dtype_mismatch():
  202:     # https://github.com/pandas-dev/pandas/issues/32747
  203:     left = DataFrame({"a": [1, 2, 3]}, dtype="Int64")
  204:     right = left.astype(int)
  205: 
  206:     msg = (
  207:         "Attributes of DataFrame\\.iloc\\[:, 0\\] "
  208:         '\\(column name="a"\\) are different\n\n'
  209:         'Attribute "dtype" are different\n'
  210:         "\\[left\\]:  Int64\n"
  211:         "\\[right\\]: int[32|64]"
  212:     )
  213: 
  214:     tm.assert_frame_equal(left, right, check_dtype=False)
  215: 
  216:     with pytest.raises(AssertionError, match=msg):
  217:         tm.assert_frame_equal(left, right, check_dtype=True)
  218: 
  219: 
  220: def test_assert_frame_equal_interval_dtype_mismatch():
  221:     # https://github.com/pandas-dev/pandas/issues/32747
  222:     left = DataFrame({"a": [pd.Interval(0, 1)]}, dtype="interval")
  223:     right = left.astype(object)
  224: 
  225:     msg = (
  226:         "Attributes of DataFrame\\.iloc\\[:, 0\\] "
  227:         '\\(column name="a"\\) are different\n\n'
  228:         'Attribute "dtype" are different\n'
  229:         "\\[left\\]:  interval\\[int64, right\\]\n"
  230:         "\\[right\\]: object"
  231:     )
  232: 
  233:     tm.assert_frame_equal(left, right, check_dtype=False)
  234: 
  235:     with pytest.raises(AssertionError, match=msg):
  236:         tm.assert_frame_equal(left, right, check_dtype=True)
  237: 
  238: 
  239: def test_assert_frame_equal_ignore_extension_dtype_mismatch():
  240:     # https://github.com/pandas-dev/pandas/issues/35715
  241:     left = DataFrame({"a": [1, 2, 3]}, dtype="Int64")
  242:     right = DataFrame({"a": [1, 2, 3]}, dtype="Int32")
  243:     tm.assert_frame_equal(left, right, check_dtype=False)
  244: 
  245: 
  246: def test_assert_frame_equal_ignore_extension_dtype_mismatch_cross_class():
  247:     # https://github.com/pandas-dev/pandas/issues/35715
  248:     left = DataFrame({"a": [1, 2, 3]}, dtype="Int64")
  249:     right = DataFrame({"a": [1, 2, 3]}, dtype="int64")
  250:     tm.assert_frame_equal(left, right, check_dtype=False)
  251: 
  252: 
  253: @pytest.mark.parametrize(
  254:     "dtype",
  255:     [
  256:         ("timedelta64[ns]"),
  257:         ("datetime64[ns, UTC]"),
  258:         ("Period[D]"),
  259:     ],
  260: )
  261: def test_assert_frame_equal_datetime_like_dtype_mismatch(dtype):
  262:     df1 = DataFrame({"a": []}, dtype=dtype)
  263:     df2 = DataFrame({"a": []})
  264:     tm.assert_frame_equal(df1, df2, check_dtype=False)
  265: 
  266: 
  267: def test_allows_duplicate_labels():
  268:     left = DataFrame()
  269:     right = DataFrame().set_flags(allows_duplicate_labels=False)
  270:     tm.assert_frame_equal(left, left)
  271:     tm.assert_frame_equal(right, right)
  272:     tm.assert_frame_equal(left, right, check_flags=False)
  273:     tm.assert_frame_equal(right, left, check_flags=False)
  274: 
  275:     with pytest.raises(AssertionError, match="<Flags"):
  276:         tm.assert_frame_equal(left, right)
  277: 
  278:     with pytest.raises(AssertionError, match="<Flags"):
  279:         tm.assert_frame_equal(left, right)
  280: 
  281: 
  282: def test_assert_frame_equal_columns_mixed_dtype():
  283:     # GH#39168
  284:     df = DataFrame([[0, 1, 2]], columns=["foo", "bar", 42], index=[1, "test", 2])
  285:     tm.assert_frame_equal(df, df, check_like=True)
  286: 
  287: 
  288: def test_frame_equal_extension_dtype(frame_or_series, any_numeric_ea_dtype):
  289:     # GH#39410
  290:     obj = frame_or_series([1, 2], dtype=any_numeric_ea_dtype)
  291:     tm.assert_equal(obj, obj, check_exact=True)
  292: 
  293: 
  294: @pytest.mark.parametrize("indexer", [(0, 1), (1, 0)])
  295: def test_frame_equal_mixed_dtypes(frame_or_series, any_numeric_ea_dtype, indexer):
  296:     dtypes = (any_numeric_ea_dtype, "int64")
  297:     obj1 = frame_or_series([1, 2], dtype=dtypes[indexer[0]])
  298:     obj2 = frame_or_series([1, 2], dtype=dtypes[indexer[1]])
  299:     tm.assert_equal(obj1, obj2, check_exact=True, check_dtype=False)
  300: 
  301: 
  302: def test_assert_frame_equal_check_like_different_indexes():
  303:     # GH#39739
  304:     df1 = DataFrame(index=pd.Index([], dtype="object"))
  305:     df2 = DataFrame(index=pd.RangeIndex(start=0, stop=0, step=1))
  306:     with pytest.raises(AssertionError, match="DataFrame.index are different"):
  307:         tm.assert_frame_equal(df1, df2, check_like=True)
  308: 
  309: 
  310: def test_assert_frame_equal_checking_allow_dups_flag():
  311:     # GH#45554
  312:     left = DataFrame([[1, 2], [3, 4]])
  313:     left.flags.allows_duplicate_labels = False
  314: 
  315:     right = DataFrame([[1, 2], [3, 4]])
  316:     right.flags.allows_duplicate_labels = True
  317:     tm.assert_frame_equal(left, right, check_flags=False)
  318: 
  319:     with pytest.raises(AssertionError, match="allows_duplicate_labels"):
  320:         tm.assert_frame_equal(left, right, check_flags=True)
  321: 
  322: 
  323: def test_assert_frame_equal_check_like_categorical_midx():
  324:     # GH#48975
  325:     left = DataFrame(
  326:         [[1], [2], [3]],
  327:         index=pd.MultiIndex.from_arrays(
  328:             [
  329:                 pd.Categorical(["a", "b", "c"]),
  330:                 pd.Categorical(["a", "b", "c"]),
  331:             ]
  332:         ),
  333:     )
  334:     right = DataFrame(
  335:         [[3], [2], [1]],
  336:         index=pd.MultiIndex.from_arrays(
  337:             [
  338:                 pd.Categorical(["c", "b", "a"]),
  339:                 pd.Categorical(["c", "b", "a"]),
  340:             ]
  341:         ),
  342:     )
  343:     tm.assert_frame_equal(left, right, check_like=True)
  344: 
  345: 
  346: def test_assert_frame_equal_ea_column_definition_in_exception_mask():
  347:     # GH#50323
  348:     df1 = DataFrame({"a": pd.Series([pd.NA, 1], dtype="Int64")})
  349:     df2 = DataFrame({"a": pd.Series([1, 1], dtype="Int64")})
  350: 
  351:     msg = r'DataFrame.iloc\[:, 0\] \(column name="a"\) NA mask values are different'
  352:     with pytest.raises(AssertionError, match=msg):
  353:         tm.assert_frame_equal(df1, df2)
  354: 
  355: 
  356: def test_assert_frame_equal_ea_column_definition_in_exception():
  357:     # GH#50323
  358:     df1 = DataFrame({"a": pd.Series([pd.NA, 1], dtype="Int64")})
  359:     df2 = DataFrame({"a": pd.Series([pd.NA, 2], dtype="Int64")})
  360: 
  361:     msg = r'DataFrame.iloc\[:, 0\] \(column name="a"\) values are different'
  362:     with pytest.raises(AssertionError, match=msg):
  363:         tm.assert_frame_equal(df1, df2)
  364: 
  365:     with pytest.raises(AssertionError, match=msg):
  366:         tm.assert_frame_equal(df1, df2, check_exact=True)
  367: 
  368: 
  369: def test_assert_frame_equal_ts_column():
  370:     # GH#50323
  371:     df1 = DataFrame({"a": [pd.Timestamp("2019-12-31"), pd.Timestamp("2020-12-31")]})
  372:     df2 = DataFrame({"a": [pd.Timestamp("2020-12-31"), pd.Timestamp("2020-12-31")]})
  373: 
  374:     msg = r'DataFrame.iloc\[:, 0\] \(column name="a"\) values are different'
  375:     with pytest.raises(AssertionError, match=msg):
  376:         tm.assert_frame_equal(df1, df2)
  377: 
  378: 
  379: def test_assert_frame_equal_set():
  380:     # GH#51727
  381:     df1 = DataFrame({"set_column": [{1, 2, 3}, {4, 5, 6}]})
  382:     df2 = DataFrame({"set_column": [{1, 2, 3}, {4, 5, 6}]})
  383:     tm.assert_frame_equal(df1, df2)
  384: 
  385: 
  386: def test_assert_frame_equal_set_mismatch():
  387:     # GH#51727
  388:     df1 = DataFrame({"set_column": [{1, 2, 3}, {4, 5, 6}]})
  389:     df2 = DataFrame({"set_column": [{1, 2, 3}, {4, 5, 7}]})
  390: 
  391:     msg = r'DataFrame.iloc\[:, 0\] \(column name="set_column"\) values are different'
  392:     with pytest.raises(AssertionError, match=msg):
  393:         tm.assert_frame_equal(df1, df2)
