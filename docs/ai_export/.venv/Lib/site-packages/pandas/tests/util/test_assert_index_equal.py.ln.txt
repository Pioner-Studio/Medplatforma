    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas import (
    5:     NA,
    6:     Categorical,
    7:     CategoricalIndex,
    8:     Index,
    9:     MultiIndex,
   10:     NaT,
   11:     RangeIndex,
   12: )
   13: import pandas._testing as tm
   14: 
   15: 
   16: def test_index_equal_levels_mismatch():
   17:     msg = """Index are different
   18: 
   19: Index levels are different
   20: \\[left\\]:  1, Index\\(\\[1, 2, 3\\], dtype='int64'\\)
   21: \\[right\\]: 2, MultiIndex\\(\\[\\('A', 1\\),
   22:             \\('A', 2\\),
   23:             \\('B', 3\\),
   24:             \\('B', 4\\)\\],
   25:            \\)"""
   26: 
   27:     idx1 = Index([1, 2, 3])
   28:     idx2 = MultiIndex.from_tuples([("A", 1), ("A", 2), ("B", 3), ("B", 4)])
   29: 
   30:     with pytest.raises(AssertionError, match=msg):
   31:         tm.assert_index_equal(idx1, idx2, exact=False)
   32: 
   33: 
   34: def test_index_equal_values_mismatch(check_exact):
   35:     msg = """MultiIndex level \\[1\\] are different
   36: 
   37: MultiIndex level \\[1\\] values are different \\(25\\.0 %\\)
   38: \\[left\\]:  Index\\(\\[2, 2, 3, 4\\], dtype='int64'\\)
   39: \\[right\\]: Index\\(\\[1, 2, 3, 4\\], dtype='int64'\\)"""
   40: 
   41:     idx1 = MultiIndex.from_tuples([("A", 2), ("A", 2), ("B", 3), ("B", 4)])
   42:     idx2 = MultiIndex.from_tuples([("A", 1), ("A", 2), ("B", 3), ("B", 4)])
   43: 
   44:     with pytest.raises(AssertionError, match=msg):
   45:         tm.assert_index_equal(idx1, idx2, check_exact=check_exact)
   46: 
   47: 
   48: def test_index_equal_length_mismatch(check_exact):
   49:     msg = """Index are different
   50: 
   51: Index length are different
   52: \\[left\\]:  3, Index\\(\\[1, 2, 3\\], dtype='int64'\\)
   53: \\[right\\]: 4, Index\\(\\[1, 2, 3, 4\\], dtype='int64'\\)"""
   54: 
   55:     idx1 = Index([1, 2, 3])
   56:     idx2 = Index([1, 2, 3, 4])
   57: 
   58:     with pytest.raises(AssertionError, match=msg):
   59:         tm.assert_index_equal(idx1, idx2, check_exact=check_exact)
   60: 
   61: 
   62: @pytest.mark.parametrize("exact", [False, "equiv"])
   63: def test_index_equal_class(exact):
   64:     idx1 = Index([0, 1, 2])
   65:     idx2 = RangeIndex(3)
   66: 
   67:     tm.assert_index_equal(idx1, idx2, exact=exact)
   68: 
   69: 
   70: def test_int_float_index_equal_class_mismatch(check_exact):
   71:     msg = """Index are different
   72: 
   73: Attribute "inferred_type" are different
   74: \\[left\\]:  integer
   75: \\[right\\]: floating"""
   76: 
   77:     idx1 = Index([1, 2, 3])
   78:     idx2 = Index([1, 2, 3], dtype=np.float64)
   79: 
   80:     with pytest.raises(AssertionError, match=msg):
   81:         tm.assert_index_equal(idx1, idx2, exact=True, check_exact=check_exact)
   82: 
   83: 
   84: def test_range_index_equal_class_mismatch(check_exact):
   85:     msg = """Index are different
   86: 
   87: Index classes are different
   88: \\[left\\]:  Index\\(\\[1, 2, 3\\], dtype='int64'\\)
   89: \\[right\\]: """
   90: 
   91:     idx1 = Index([1, 2, 3])
   92:     idx2 = RangeIndex(range(3))
   93: 
   94:     with pytest.raises(AssertionError, match=msg):
   95:         tm.assert_index_equal(idx1, idx2, exact=True, check_exact=check_exact)
   96: 
   97: 
   98: def test_index_equal_values_close(check_exact):
   99:     idx1 = Index([1, 2, 3.0])
  100:     idx2 = Index([1, 2, 3.0000000001])
  101: 
  102:     if check_exact:
  103:         msg = """Index are different
  104: 
  105: Index values are different \\(33\\.33333 %\\)
  106: \\[left\\]:  Index\\(\\[1.0, 2.0, 3.0], dtype='float64'\\)
  107: \\[right\\]: Index\\(\\[1.0, 2.0, 3.0000000001\\], dtype='float64'\\)"""
  108: 
  109:         with pytest.raises(AssertionError, match=msg):
  110:             tm.assert_index_equal(idx1, idx2, check_exact=check_exact)
  111:     else:
  112:         tm.assert_index_equal(idx1, idx2, check_exact=check_exact)
  113: 
  114: 
  115: def test_index_equal_values_less_close(check_exact, rtol):
  116:     idx1 = Index([1, 2, 3.0])
  117:     idx2 = Index([1, 2, 3.0001])
  118:     kwargs = {"check_exact": check_exact, "rtol": rtol}
  119: 
  120:     if check_exact or rtol < 0.5e-3:
  121:         msg = """Index are different
  122: 
  123: Index values are different \\(33\\.33333 %\\)
  124: \\[left\\]:  Index\\(\\[1.0, 2.0, 3.0], dtype='float64'\\)
  125: \\[right\\]: Index\\(\\[1.0, 2.0, 3.0001\\], dtype='float64'\\)"""
  126: 
  127:         with pytest.raises(AssertionError, match=msg):
  128:             tm.assert_index_equal(idx1, idx2, **kwargs)
  129:     else:
  130:         tm.assert_index_equal(idx1, idx2, **kwargs)
  131: 
  132: 
  133: def test_index_equal_values_too_far(check_exact, rtol):
  134:     idx1 = Index([1, 2, 3])
  135:     idx2 = Index([1, 2, 4])
  136:     kwargs = {"check_exact": check_exact, "rtol": rtol}
  137: 
  138:     msg = """Index are different
  139: 
  140: Index values are different \\(33\\.33333 %\\)
  141: \\[left\\]:  Index\\(\\[1, 2, 3\\], dtype='int64'\\)
  142: \\[right\\]: Index\\(\\[1, 2, 4\\], dtype='int64'\\)"""
  143: 
  144:     with pytest.raises(AssertionError, match=msg):
  145:         tm.assert_index_equal(idx1, idx2, **kwargs)
  146: 
  147: 
  148: @pytest.mark.parametrize("check_order", [True, False])
  149: def test_index_equal_value_order_mismatch(check_exact, rtol, check_order):
  150:     idx1 = Index([1, 2, 3])
  151:     idx2 = Index([3, 2, 1])
  152: 
  153:     msg = """Index are different
  154: 
  155: Index values are different \\(66\\.66667 %\\)
  156: \\[left\\]:  Index\\(\\[1, 2, 3\\], dtype='int64'\\)
  157: \\[right\\]: Index\\(\\[3, 2, 1\\], dtype='int64'\\)"""
  158: 
  159:     if check_order:
  160:         with pytest.raises(AssertionError, match=msg):
  161:             tm.assert_index_equal(
  162:                 idx1, idx2, check_exact=check_exact, rtol=rtol, check_order=True
  163:             )
  164:     else:
  165:         tm.assert_index_equal(
  166:             idx1, idx2, check_exact=check_exact, rtol=rtol, check_order=False
  167:         )
  168: 
  169: 
  170: def test_index_equal_level_values_mismatch(check_exact, rtol):
  171:     idx1 = MultiIndex.from_tuples([("A", 2), ("A", 2), ("B", 3), ("B", 4)])
  172:     idx2 = MultiIndex.from_tuples([("A", 1), ("A", 2), ("B", 3), ("B", 4)])
  173:     kwargs = {"check_exact": check_exact, "rtol": rtol}
  174: 
  175:     msg = """MultiIndex level \\[1\\] are different
  176: 
  177: MultiIndex level \\[1\\] values are different \\(25\\.0 %\\)
  178: \\[left\\]:  Index\\(\\[2, 2, 3, 4\\], dtype='int64'\\)
  179: \\[right\\]: Index\\(\\[1, 2, 3, 4\\], dtype='int64'\\)"""
  180: 
  181:     with pytest.raises(AssertionError, match=msg):
  182:         tm.assert_index_equal(idx1, idx2, **kwargs)
  183: 
  184: 
  185: @pytest.mark.parametrize(
  186:     "name1,name2",
  187:     [(None, "x"), ("x", "x"), (np.nan, np.nan), (NaT, NaT), (np.nan, NaT)],
  188: )
  189: def test_index_equal_names(name1, name2):
  190:     idx1 = Index([1, 2, 3], name=name1)
  191:     idx2 = Index([1, 2, 3], name=name2)
  192: 
  193:     if name1 == name2 or name1 is name2:
  194:         tm.assert_index_equal(idx1, idx2)
  195:     else:
  196:         name1 = "'x'" if name1 == "x" else name1
  197:         name2 = "'x'" if name2 == "x" else name2
  198:         msg = f"""Index are different
  199: 
  200: Attribute "names" are different
  201: \\[left\\]:  \\[{name1}\\]
  202: \\[right\\]: \\[{name2}\\]"""
  203: 
  204:         with pytest.raises(AssertionError, match=msg):
  205:             tm.assert_index_equal(idx1, idx2)
  206: 
  207: 
  208: def test_index_equal_category_mismatch(check_categorical, using_infer_string):
  209:     if using_infer_string:
  210:         dtype = "string"
  211:     else:
  212:         dtype = "object"
  213:     msg = f"""Index are different
  214: 
  215: Attribute "dtype" are different
  216: \\[left\\]:  CategoricalDtype\\(categories=\\['a', 'b'\\], ordered=False, \
  217: categories_dtype={dtype}\\)
  218: \\[right\\]: CategoricalDtype\\(categories=\\['a', 'b', 'c'\\], \
  219: ordered=False, categories_dtype={dtype}\\)"""
  220: 
  221:     idx1 = Index(Categorical(["a", "b"]))
  222:     idx2 = Index(Categorical(["a", "b"], categories=["a", "b", "c"]))
  223: 
  224:     if check_categorical:
  225:         with pytest.raises(AssertionError, match=msg):
  226:             tm.assert_index_equal(idx1, idx2, check_categorical=check_categorical)
  227:     else:
  228:         tm.assert_index_equal(idx1, idx2, check_categorical=check_categorical)
  229: 
  230: 
  231: @pytest.mark.parametrize("exact", [False, True])
  232: def test_index_equal_range_categories(check_categorical, exact):
  233:     # GH41263
  234:     msg = """\
  235: Index are different
  236: 
  237: Index classes are different
  238: \\[left\\]:  RangeIndex\\(start=0, stop=10, step=1\\)
  239: \\[right\\]: Index\\(\\[0, 1, 2, 3, 4, 5, 6, 7, 8, 9\\], dtype='int64'\\)"""
  240: 
  241:     rcat = CategoricalIndex(RangeIndex(10))
  242:     icat = CategoricalIndex(list(range(10)))
  243: 
  244:     if check_categorical and exact:
  245:         with pytest.raises(AssertionError, match=msg):
  246:             tm.assert_index_equal(rcat, icat, check_categorical=True, exact=True)
  247:     else:
  248:         tm.assert_index_equal(
  249:             rcat, icat, check_categorical=check_categorical, exact=exact
  250:         )
  251: 
  252: 
  253: def test_assert_index_equal_different_inferred_types():
  254:     # GH#31884
  255:     msg = """\
  256: Index are different
  257: 
  258: Attribute "inferred_type" are different
  259: \\[left\\]:  mixed
  260: \\[right\\]: datetime"""
  261: 
  262:     idx1 = Index([NA, np.datetime64("nat")])
  263:     idx2 = Index([NA, NaT])
  264:     with pytest.raises(AssertionError, match=msg):
  265:         tm.assert_index_equal(idx1, idx2)
  266: 
  267: 
  268: def test_assert_index_equal_different_names_check_order_false():
  269:     # GH#47328
  270:     idx1 = Index([1, 3], name="a")
  271:     idx2 = Index([3, 1], name="b")
  272:     with pytest.raises(AssertionError, match='"names" are different'):
  273:         tm.assert_index_equal(idx1, idx2, check_order=False, check_names=True)
  274: 
  275: 
  276: def test_assert_index_equal_mixed_dtype():
  277:     # GH#39168
  278:     idx = Index(["foo", "bar", 42])
  279:     tm.assert_index_equal(idx, idx, check_order=False)
  280: 
  281: 
  282: def test_assert_index_equal_ea_dtype_order_false(any_numeric_ea_dtype):
  283:     # GH#47207
  284:     idx1 = Index([1, 3], dtype=any_numeric_ea_dtype)
  285:     idx2 = Index([3, 1], dtype=any_numeric_ea_dtype)
  286:     tm.assert_index_equal(idx1, idx2, check_order=False)
  287: 
  288: 
  289: def test_assert_index_equal_object_ints_order_false():
  290:     # GH#47207
  291:     idx1 = Index([1, 3], dtype="object")
  292:     idx2 = Index([3, 1], dtype="object")
  293:     tm.assert_index_equal(idx1, idx2, check_order=False)
  294: 
  295: 
  296: @pytest.mark.parametrize("check_categorical", [True, False])
  297: @pytest.mark.parametrize("check_names", [True, False])
  298: def test_assert_ea_index_equal_non_matching_na(check_names, check_categorical):
  299:     # GH#48608
  300:     idx1 = Index([1, 2], dtype="Int64")
  301:     idx2 = Index([1, NA], dtype="Int64")
  302:     with pytest.raises(AssertionError, match="50.0 %"):
  303:         tm.assert_index_equal(
  304:             idx1, idx2, check_names=check_names, check_categorical=check_categorical
  305:         )
  306: 
  307: 
  308: @pytest.mark.parametrize("check_categorical", [True, False])
  309: def test_assert_multi_index_dtype_check_categorical(check_categorical):
  310:     # GH#52126
  311:     idx1 = MultiIndex.from_arrays([Categorical(np.array([1, 2], dtype=np.uint64))])
  312:     idx2 = MultiIndex.from_arrays([Categorical(np.array([1, 2], dtype=np.int64))])
  313:     if check_categorical:
  314:         with pytest.raises(
  315:             AssertionError, match=r"^MultiIndex level \[0\] are different"
  316:         ):
  317:             tm.assert_index_equal(idx1, idx2, check_categorical=check_categorical)
  318:     else:
  319:         tm.assert_index_equal(idx1, idx2, check_categorical=check_categorical)
