    1: from copy import deepcopy
    2: from operator import methodcaller
    3: 
    4: import numpy as np
    5: import pytest
    6: 
    7: import pandas as pd
    8: from pandas import (
    9:     DataFrame,
   10:     MultiIndex,
   11:     Series,
   12:     date_range,
   13: )
   14: import pandas._testing as tm
   15: 
   16: 
   17: class TestDataFrame:
   18:     @pytest.mark.parametrize("func", ["_set_axis_name", "rename_axis"])
   19:     def test_set_axis_name(self, func):
   20:         df = DataFrame([[1, 2], [3, 4]])
   21: 
   22:         result = methodcaller(func, "foo")(df)
   23:         assert df.index.name is None
   24:         assert result.index.name == "foo"
   25: 
   26:         result = methodcaller(func, "cols", axis=1)(df)
   27:         assert df.columns.name is None
   28:         assert result.columns.name == "cols"
   29: 
   30:     @pytest.mark.parametrize("func", ["_set_axis_name", "rename_axis"])
   31:     def test_set_axis_name_mi(self, func):
   32:         df = DataFrame(
   33:             np.empty((3, 3)),
   34:             index=MultiIndex.from_tuples([("A", x) for x in list("aBc")]),
   35:             columns=MultiIndex.from_tuples([("C", x) for x in list("xyz")]),
   36:         )
   37: 
   38:         level_names = ["L1", "L2"]
   39: 
   40:         result = methodcaller(func, level_names)(df)
   41:         assert result.index.names == level_names
   42:         assert result.columns.names == [None, None]
   43: 
   44:         result = methodcaller(func, level_names, axis=1)(df)
   45:         assert result.columns.names == ["L1", "L2"]
   46:         assert result.index.names == [None, None]
   47: 
   48:     def test_nonzero_single_element(self):
   49:         # allow single item via bool method
   50:         msg_warn = (
   51:             "DataFrame.bool is now deprecated and will be removed "
   52:             "in future version of pandas"
   53:         )
   54:         df = DataFrame([[True]])
   55:         df1 = DataFrame([[False]])
   56:         with tm.assert_produces_warning(FutureWarning, match=msg_warn):
   57:             assert df.bool()
   58: 
   59:         with tm.assert_produces_warning(FutureWarning, match=msg_warn):
   60:             assert not df1.bool()
   61: 
   62:         df = DataFrame([[False, False]])
   63:         msg_err = "The truth value of a DataFrame is ambiguous"
   64:         with pytest.raises(ValueError, match=msg_err):
   65:             bool(df)
   66: 
   67:         with tm.assert_produces_warning(FutureWarning, match=msg_warn):
   68:             with pytest.raises(ValueError, match=msg_err):
   69:                 df.bool()
   70: 
   71:     def test_metadata_propagation_indiv_groupby(self):
   72:         # groupby
   73:         df = DataFrame(
   74:             {
   75:                 "A": ["foo", "bar", "foo", "bar", "foo", "bar", "foo", "foo"],
   76:                 "B": ["one", "one", "two", "three", "two", "two", "one", "three"],
   77:                 "C": np.random.default_rng(2).standard_normal(8),
   78:                 "D": np.random.default_rng(2).standard_normal(8),
   79:             }
   80:         )
   81:         result = df.groupby("A").sum()
   82:         tm.assert_metadata_equivalent(df, result)
   83: 
   84:     def test_metadata_propagation_indiv_resample(self):
   85:         # resample
   86:         df = DataFrame(
   87:             np.random.default_rng(2).standard_normal((1000, 2)),
   88:             index=date_range("20130101", periods=1000, freq="s"),
   89:         )
   90:         result = df.resample("1min")
   91:         tm.assert_metadata_equivalent(df, result)
   92: 
   93:     def test_metadata_propagation_indiv(self, monkeypatch):
   94:         # merging with override
   95:         # GH 6923
   96: 
   97:         def finalize(self, other, method=None, **kwargs):
   98:             for name in self._metadata:
   99:                 if method == "merge":
  100:                     left, right = other.left, other.right
  101:                     value = getattr(left, name, "") + "|" + getattr(right, name, "")
  102:                     object.__setattr__(self, name, value)
  103:                 elif method == "concat":
  104:                     value = "+".join(
  105:                         [getattr(o, name) for o in other.objs if getattr(o, name, None)]
  106:                     )
  107:                     object.__setattr__(self, name, value)
  108:                 else:
  109:                     object.__setattr__(self, name, getattr(other, name, ""))
  110: 
  111:             return self
  112: 
  113:         with monkeypatch.context() as m:
  114:             m.setattr(DataFrame, "_metadata", ["filename"])
  115:             m.setattr(DataFrame, "__finalize__", finalize)
  116: 
  117:             df1 = DataFrame(
  118:                 np.random.default_rng(2).integers(0, 4, (3, 2)), columns=["a", "b"]
  119:             )
  120:             df2 = DataFrame(
  121:                 np.random.default_rng(2).integers(0, 4, (3, 2)), columns=["c", "d"]
  122:             )
  123:             DataFrame._metadata = ["filename"]
  124:             df1.filename = "fname1.csv"
  125:             df2.filename = "fname2.csv"
  126: 
  127:             result = df1.merge(df2, left_on=["a"], right_on=["c"], how="inner")
  128:             assert result.filename == "fname1.csv|fname2.csv"
  129: 
  130:             # concat
  131:             # GH#6927
  132:             df1 = DataFrame(
  133:                 np.random.default_rng(2).integers(0, 4, (3, 2)), columns=list("ab")
  134:             )
  135:             df1.filename = "foo"
  136: 
  137:             result = pd.concat([df1, df1])
  138:             assert result.filename == "foo+foo"
  139: 
  140:     def test_set_attribute(self):
  141:         # Test for consistent setattr behavior when an attribute and a column
  142:         # have the same name (Issue #8994)
  143:         df = DataFrame({"x": [1, 2, 3]})
  144: 
  145:         df.y = 2
  146:         df["y"] = [2, 4, 6]
  147:         df.y = 5
  148: 
  149:         assert df.y == 5
  150:         tm.assert_series_equal(df["y"], Series([2, 4, 6], name="y"))
  151: 
  152:     def test_deepcopy_empty(self):
  153:         # This test covers empty frame copying with non-empty column sets
  154:         # as reported in issue GH15370
  155:         empty_frame = DataFrame(data=[], index=[], columns=["A"])
  156:         empty_frame_copy = deepcopy(empty_frame)
  157: 
  158:         tm.assert_frame_equal(empty_frame_copy, empty_frame)
  159: 
  160: 
  161: # formerly in Generic but only test DataFrame
  162: class TestDataFrame2:
  163:     @pytest.mark.parametrize("value", [1, "True", [1, 2, 3], 5.0])
  164:     def test_validate_bool_args(self, value):
  165:         df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6]})
  166: 
  167:         msg = 'For argument "inplace" expected type bool, received type'
  168:         with pytest.raises(ValueError, match=msg):
  169:             df.copy().rename_axis(mapper={"a": "x", "b": "y"}, axis=1, inplace=value)
  170: 
  171:         with pytest.raises(ValueError, match=msg):
  172:             df.copy().drop("a", axis=1, inplace=value)
  173: 
  174:         with pytest.raises(ValueError, match=msg):
  175:             df.copy().fillna(value=0, inplace=value)
  176: 
  177:         with pytest.raises(ValueError, match=msg):
  178:             df.copy().replace(to_replace=1, value=7, inplace=value)
  179: 
  180:         with pytest.raises(ValueError, match=msg):
  181:             df.copy().interpolate(inplace=value)
  182: 
  183:         with pytest.raises(ValueError, match=msg):
  184:             df.copy()._where(cond=df.a > 2, inplace=value)
  185: 
  186:         with pytest.raises(ValueError, match=msg):
  187:             df.copy().mask(cond=df.a > 2, inplace=value)
  188: 
  189:     def test_unexpected_keyword(self):
  190:         # GH8597
  191:         df = DataFrame(
  192:             np.random.default_rng(2).standard_normal((5, 2)), columns=["jim", "joe"]
  193:         )
  194:         ca = pd.Categorical([0, 0, 2, 2, 3, np.nan])
  195:         ts = df["joe"].copy()
  196:         ts[2] = np.nan
  197: 
  198:         msg = "unexpected keyword"
  199:         with pytest.raises(TypeError, match=msg):
  200:             df.drop("joe", axis=1, in_place=True)
  201: 
  202:         with pytest.raises(TypeError, match=msg):
  203:             df.reindex([1, 0], inplace=True)
  204: 
  205:         with pytest.raises(TypeError, match=msg):
  206:             ca.fillna(0, inplace=True)
  207: 
  208:         with pytest.raises(TypeError, match=msg):
  209:             ts.fillna(0, in_place=True)
