    1: """Tests dealing with the NDFrame.allows_duplicates."""
    2: import operator
    3: 
    4: import numpy as np
    5: import pytest
    6: 
    7: import pandas as pd
    8: import pandas._testing as tm
    9: 
   10: not_implemented = pytest.mark.xfail(reason="Not implemented.")
   11: 
   12: # ----------------------------------------------------------------------------
   13: # Preservation
   14: 
   15: 
   16: class TestPreserves:
   17:     @pytest.mark.parametrize(
   18:         "cls, data",
   19:         [
   20:             (pd.Series, np.array([])),
   21:             (pd.Series, [1, 2]),
   22:             (pd.DataFrame, {}),
   23:             (pd.DataFrame, {"A": [1, 2]}),
   24:         ],
   25:     )
   26:     def test_construction_ok(self, cls, data):
   27:         result = cls(data)
   28:         assert result.flags.allows_duplicate_labels is True
   29: 
   30:         result = cls(data).set_flags(allows_duplicate_labels=False)
   31:         assert result.flags.allows_duplicate_labels is False
   32: 
   33:     @pytest.mark.parametrize(
   34:         "func",
   35:         [
   36:             operator.itemgetter(["a"]),
   37:             operator.methodcaller("add", 1),
   38:             operator.methodcaller("rename", str.upper),
   39:             operator.methodcaller("rename", "name"),
   40:             operator.methodcaller("abs"),
   41:             np.abs,
   42:         ],
   43:     )
   44:     def test_preserved_series(self, func):
   45:         s = pd.Series([0, 1], index=["a", "b"]).set_flags(allows_duplicate_labels=False)
   46:         assert func(s).flags.allows_duplicate_labels is False
   47: 
   48:     @pytest.mark.parametrize(
   49:         "other", [pd.Series(0, index=["a", "b", "c"]), pd.Series(0, index=["a", "b"])]
   50:     )
   51:     # TODO: frame
   52:     @not_implemented
   53:     def test_align(self, other):
   54:         s = pd.Series([0, 1], index=["a", "b"]).set_flags(allows_duplicate_labels=False)
   55:         a, b = s.align(other)
   56:         assert a.flags.allows_duplicate_labels is False
   57:         assert b.flags.allows_duplicate_labels is False
   58: 
   59:     def test_preserved_frame(self):
   60:         df = pd.DataFrame({"A": [1, 2], "B": [3, 4]}, index=["a", "b"]).set_flags(
   61:             allows_duplicate_labels=False
   62:         )
   63:         assert df.loc[["a"]].flags.allows_duplicate_labels is False
   64:         assert df.loc[:, ["A", "B"]].flags.allows_duplicate_labels is False
   65: 
   66:     def test_to_frame(self):
   67:         ser = pd.Series(dtype=float).set_flags(allows_duplicate_labels=False)
   68:         assert ser.to_frame().flags.allows_duplicate_labels is False
   69: 
   70:     @pytest.mark.parametrize("func", ["add", "sub"])
   71:     @pytest.mark.parametrize("frame", [False, True])
   72:     @pytest.mark.parametrize("other", [1, pd.Series([1, 2], name="A")])
   73:     def test_binops(self, func, other, frame):
   74:         df = pd.Series([1, 2], name="A", index=["a", "b"]).set_flags(
   75:             allows_duplicate_labels=False
   76:         )
   77:         if frame:
   78:             df = df.to_frame()
   79:         if isinstance(other, pd.Series) and frame:
   80:             other = other.to_frame()
   81:         func = operator.methodcaller(func, other)
   82:         assert df.flags.allows_duplicate_labels is False
   83:         assert func(df).flags.allows_duplicate_labels is False
   84: 
   85:     def test_preserve_getitem(self):
   86:         df = pd.DataFrame({"A": [1, 2]}).set_flags(allows_duplicate_labels=False)
   87:         assert df[["A"]].flags.allows_duplicate_labels is False
   88:         assert df["A"].flags.allows_duplicate_labels is False
   89:         assert df.loc[0].flags.allows_duplicate_labels is False
   90:         assert df.loc[[0]].flags.allows_duplicate_labels is False
   91:         assert df.loc[0, ["A"]].flags.allows_duplicate_labels is False
   92: 
   93:     def test_ndframe_getitem_caching_issue(
   94:         self, request, using_copy_on_write, warn_copy_on_write
   95:     ):
   96:         if not (using_copy_on_write or warn_copy_on_write):
   97:             request.applymarker(pytest.mark.xfail(reason="Unclear behavior."))
   98:         # NDFrame.__getitem__ will cache the first df['A']. May need to
   99:         # invalidate that cache? Update the cached entries?
  100:         df = pd.DataFrame({"A": [0]}).set_flags(allows_duplicate_labels=False)
  101:         assert df["A"].flags.allows_duplicate_labels is False
  102:         df.flags.allows_duplicate_labels = True
  103:         assert df["A"].flags.allows_duplicate_labels is True
  104: 
  105:     @pytest.mark.parametrize(
  106:         "objs, kwargs",
  107:         [
  108:             # Series
  109:             (
  110:                 [
  111:                     pd.Series(1, index=["a", "b"]),
  112:                     pd.Series(2, index=["c", "d"]),
  113:                 ],
  114:                 {},
  115:             ),
  116:             (
  117:                 [
  118:                     pd.Series(1, index=["a", "b"]),
  119:                     pd.Series(2, index=["a", "b"]),
  120:                 ],
  121:                 {"ignore_index": True},
  122:             ),
  123:             (
  124:                 [
  125:                     pd.Series(1, index=["a", "b"]),
  126:                     pd.Series(2, index=["a", "b"]),
  127:                 ],
  128:                 {"axis": 1},
  129:             ),
  130:             # Frame
  131:             (
  132:                 [
  133:                     pd.DataFrame({"A": [1, 2]}, index=["a", "b"]),
  134:                     pd.DataFrame({"A": [1, 2]}, index=["c", "d"]),
  135:                 ],
  136:                 {},
  137:             ),
  138:             (
  139:                 [
  140:                     pd.DataFrame({"A": [1, 2]}, index=["a", "b"]),
  141:                     pd.DataFrame({"A": [1, 2]}, index=["a", "b"]),
  142:                 ],
  143:                 {"ignore_index": True},
  144:             ),
  145:             (
  146:                 [
  147:                     pd.DataFrame({"A": [1, 2]}, index=["a", "b"]),
  148:                     pd.DataFrame({"B": [1, 2]}, index=["a", "b"]),
  149:                 ],
  150:                 {"axis": 1},
  151:             ),
  152:             # Series / Frame
  153:             (
  154:                 [
  155:                     pd.DataFrame({"A": [1, 2]}, index=["a", "b"]),
  156:                     pd.Series([1, 2], index=["a", "b"], name="B"),
  157:                 ],
  158:                 {"axis": 1},
  159:             ),
  160:         ],
  161:     )
  162:     def test_concat(self, objs, kwargs):
  163:         objs = [x.set_flags(allows_duplicate_labels=False) for x in objs]
  164:         result = pd.concat(objs, **kwargs)
  165:         assert result.flags.allows_duplicate_labels is False
  166: 
  167:     @pytest.mark.parametrize(
  168:         "left, right, expected",
  169:         [
  170:             # false false false
  171:             pytest.param(
  172:                 pd.DataFrame({"A": [0, 1]}, index=["a", "b"]).set_flags(
  173:                     allows_duplicate_labels=False
  174:                 ),
  175:                 pd.DataFrame({"B": [0, 1]}, index=["a", "d"]).set_flags(
  176:                     allows_duplicate_labels=False
  177:                 ),
  178:                 False,
  179:                 marks=not_implemented,
  180:             ),
  181:             # false true false
  182:             pytest.param(
  183:                 pd.DataFrame({"A": [0, 1]}, index=["a", "b"]).set_flags(
  184:                     allows_duplicate_labels=False
  185:                 ),
  186:                 pd.DataFrame({"B": [0, 1]}, index=["a", "d"]),
  187:                 False,
  188:                 marks=not_implemented,
  189:             ),
  190:             # true true true
  191:             (
  192:                 pd.DataFrame({"A": [0, 1]}, index=["a", "b"]),
  193:                 pd.DataFrame({"B": [0, 1]}, index=["a", "d"]),
  194:                 True,
  195:             ),
  196:         ],
  197:     )
  198:     def test_merge(self, left, right, expected):
  199:         result = pd.merge(left, right, left_index=True, right_index=True)
  200:         assert result.flags.allows_duplicate_labels is expected
  201: 
  202:     @not_implemented
  203:     def test_groupby(self):
  204:         # XXX: This is under tested
  205:         # TODO:
  206:         #  - apply
  207:         #  - transform
  208:         #  - Should passing a grouper that disallows duplicates propagate?
  209:         df = pd.DataFrame({"A": [1, 2, 3]}).set_flags(allows_duplicate_labels=False)
  210:         result = df.groupby([0, 0, 1]).agg("count")
  211:         assert result.flags.allows_duplicate_labels is False
  212: 
  213:     @pytest.mark.parametrize("frame", [True, False])
  214:     @not_implemented
  215:     def test_window(self, frame):
  216:         df = pd.Series(
  217:             1,
  218:             index=pd.date_range("2000", periods=12),
  219:             name="A",
  220:             allows_duplicate_labels=False,
  221:         )
  222:         if frame:
  223:             df = df.to_frame()
  224:         assert df.rolling(3).mean().flags.allows_duplicate_labels is False
  225:         assert df.ewm(3).mean().flags.allows_duplicate_labels is False
  226:         assert df.expanding(3).mean().flags.allows_duplicate_labels is False
  227: 
  228: 
  229: # ----------------------------------------------------------------------------
  230: # Raises
  231: 
  232: 
  233: class TestRaises:
  234:     @pytest.mark.parametrize(
  235:         "cls, axes",
  236:         [
  237:             (pd.Series, {"index": ["a", "a"], "dtype": float}),
  238:             (pd.DataFrame, {"index": ["a", "a"]}),
  239:             (pd.DataFrame, {"index": ["a", "a"], "columns": ["b", "b"]}),
  240:             (pd.DataFrame, {"columns": ["b", "b"]}),
  241:         ],
  242:     )
  243:     def test_set_flags_with_duplicates(self, cls, axes):
  244:         result = cls(**axes)
  245:         assert result.flags.allows_duplicate_labels is True
  246: 
  247:         msg = "Index has duplicates."
  248:         with pytest.raises(pd.errors.DuplicateLabelError, match=msg):
  249:             cls(**axes).set_flags(allows_duplicate_labels=False)
  250: 
  251:     @pytest.mark.parametrize(
  252:         "data",
  253:         [
  254:             pd.Series(index=[0, 0], dtype=float),
  255:             pd.DataFrame(index=[0, 0]),
  256:             pd.DataFrame(columns=[0, 0]),
  257:         ],
  258:     )
  259:     def test_setting_allows_duplicate_labels_raises(self, data):
  260:         msg = "Index has duplicates."
  261:         with pytest.raises(pd.errors.DuplicateLabelError, match=msg):
  262:             data.flags.allows_duplicate_labels = False
  263: 
  264:         assert data.flags.allows_duplicate_labels is True
  265: 
  266:     def test_series_raises(self):
  267:         a = pd.Series(0, index=["a", "b"])
  268:         b = pd.Series([0, 1], index=["a", "b"]).set_flags(allows_duplicate_labels=False)
  269:         msg = "Index has duplicates."
  270:         with pytest.raises(pd.errors.DuplicateLabelError, match=msg):
  271:             pd.concat([a, b])
  272: 
  273:     @pytest.mark.parametrize(
  274:         "getter, target",
  275:         [
  276:             (operator.itemgetter(["A", "A"]), None),
  277:             # loc
  278:             (operator.itemgetter(["a", "a"]), "loc"),
  279:             pytest.param(operator.itemgetter(("a", ["A", "A"])), "loc"),
  280:             (operator.itemgetter((["a", "a"], "A")), "loc"),
  281:             # iloc
  282:             (operator.itemgetter([0, 0]), "iloc"),
  283:             pytest.param(operator.itemgetter((0, [0, 0])), "iloc"),
  284:             pytest.param(operator.itemgetter(([0, 0], 0)), "iloc"),
  285:         ],
  286:     )
  287:     def test_getitem_raises(self, getter, target):
  288:         df = pd.DataFrame({"A": [1, 2], "B": [3, 4]}, index=["a", "b"]).set_flags(
  289:             allows_duplicate_labels=False
  290:         )
  291:         if target:
  292:             # df, df.loc, or df.iloc
  293:             target = getattr(df, target)
  294:         else:
  295:             target = df
  296: 
  297:         msg = "Index has duplicates."
  298:         with pytest.raises(pd.errors.DuplicateLabelError, match=msg):
  299:             getter(target)
  300: 
  301:     @pytest.mark.parametrize(
  302:         "objs, kwargs",
  303:         [
  304:             (
  305:                 [
  306:                     pd.Series(1, index=[0, 1], name="a"),
  307:                     pd.Series(2, index=[0, 1], name="a"),
  308:                 ],
  309:                 {"axis": 1},
  310:             )
  311:         ],
  312:     )
  313:     def test_concat_raises(self, objs, kwargs):
  314:         objs = [x.set_flags(allows_duplicate_labels=False) for x in objs]
  315:         msg = "Index has duplicates."
  316:         with pytest.raises(pd.errors.DuplicateLabelError, match=msg):
  317:             pd.concat(objs, **kwargs)
  318: 
  319:     @not_implemented
  320:     def test_merge_raises(self):
  321:         a = pd.DataFrame({"A": [0, 1, 2]}, index=["a", "b", "c"]).set_flags(
  322:             allows_duplicate_labels=False
  323:         )
  324:         b = pd.DataFrame({"B": [0, 1, 2]}, index=["a", "b", "b"])
  325:         msg = "Index has duplicates."
  326:         with pytest.raises(pd.errors.DuplicateLabelError, match=msg):
  327:             pd.merge(a, b, left_index=True, right_index=True)
  328: 
  329: 
  330: @pytest.mark.parametrize(
  331:     "idx",
  332:     [
  333:         pd.Index([1, 1]),
  334:         pd.Index(["a", "a"]),
  335:         pd.Index([1.1, 1.1]),
  336:         pd.PeriodIndex([pd.Period("2000", "D")] * 2),
  337:         pd.DatetimeIndex([pd.Timestamp("2000")] * 2),
  338:         pd.TimedeltaIndex([pd.Timedelta("1D")] * 2),
  339:         pd.CategoricalIndex(["a", "a"]),
  340:         pd.IntervalIndex([pd.Interval(0, 1)] * 2),
  341:         pd.MultiIndex.from_tuples([("a", 1), ("a", 1)]),
  342:     ],
  343:     ids=lambda x: type(x).__name__,
  344: )
  345: def test_raises_basic(idx):
  346:     msg = "Index has duplicates."
  347:     with pytest.raises(pd.errors.DuplicateLabelError, match=msg):
  348:         pd.Series(1, index=idx).set_flags(allows_duplicate_labels=False)
  349: 
  350:     with pytest.raises(pd.errors.DuplicateLabelError, match=msg):
  351:         pd.DataFrame({"A": [1, 1]}, index=idx).set_flags(allows_duplicate_labels=False)
  352: 
  353:     with pytest.raises(pd.errors.DuplicateLabelError, match=msg):
  354:         pd.DataFrame([[1, 2]], columns=idx).set_flags(allows_duplicate_labels=False)
  355: 
  356: 
  357: def test_format_duplicate_labels_message():
  358:     idx = pd.Index(["a", "b", "a", "b", "c"])
  359:     result = idx._format_duplicate_message()
  360:     expected = pd.DataFrame(
  361:         {"positions": [[0, 2], [1, 3]]}, index=pd.Index(["a", "b"], name="label")
  362:     )
  363:     tm.assert_frame_equal(result, expected)
  364: 
  365: 
  366: def test_format_duplicate_labels_message_multi():
  367:     idx = pd.MultiIndex.from_product([["A"], ["a", "b", "a", "b", "c"]])
  368:     result = idx._format_duplicate_message()
  369:     expected = pd.DataFrame(
  370:         {"positions": [[0, 2], [1, 3]]},
  371:         index=pd.MultiIndex.from_product([["A"], ["a", "b"]]),
  372:     )
  373:     tm.assert_frame_equal(result, expected)
  374: 
  375: 
  376: def test_dataframe_insert_raises():
  377:     df = pd.DataFrame({"A": [1, 2]}).set_flags(allows_duplicate_labels=False)
  378:     msg = "Cannot specify"
  379:     with pytest.raises(ValueError, match=msg):
  380:         df.insert(0, "A", [3, 4], allow_duplicates=True)
  381: 
  382: 
  383: @pytest.mark.parametrize(
  384:     "method, frame_only",
  385:     [
  386:         (operator.methodcaller("set_index", "A", inplace=True), True),
  387:         (operator.methodcaller("reset_index", inplace=True), True),
  388:         (operator.methodcaller("rename", lambda x: x, inplace=True), False),
  389:     ],
  390: )
  391: def test_inplace_raises(method, frame_only):
  392:     df = pd.DataFrame({"A": [0, 0], "B": [1, 2]}).set_flags(
  393:         allows_duplicate_labels=False
  394:     )
  395:     s = df["A"]
  396:     s.flags.allows_duplicate_labels = False
  397:     msg = "Cannot specify"
  398: 
  399:     with pytest.raises(ValueError, match=msg):
  400:         method(df)
  401:     if not frame_only:
  402:         with pytest.raises(ValueError, match=msg):
  403:             method(s)
  404: 
  405: 
  406: def test_pickle():
  407:     a = pd.Series([1, 2]).set_flags(allows_duplicate_labels=False)
  408:     b = tm.round_trip_pickle(a)
  409:     tm.assert_series_equal(a, b)
  410: 
  411:     a = pd.DataFrame({"A": []}).set_flags(allows_duplicate_labels=False)
  412:     b = tm.round_trip_pickle(a)
  413:     tm.assert_frame_equal(a, b)
