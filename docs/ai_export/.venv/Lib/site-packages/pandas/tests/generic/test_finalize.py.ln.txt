    1: """
    2: An exhaustive list of pandas methods exercising NDFrame.__finalize__.
    3: """
    4: import operator
    5: import re
    6: 
    7: import numpy as np
    8: import pytest
    9: 
   10: import pandas as pd
   11: import pandas._testing as tm
   12: 
   13: # TODO:
   14: # * Binary methods (mul, div, etc.)
   15: # * Binary outputs (align, etc.)
   16: # * top-level methods (concat, merge, get_dummies, etc.)
   17: # * window
   18: # * cumulative reductions
   19: 
   20: not_implemented_mark = pytest.mark.xfail(reason="not implemented")
   21: 
   22: mi = pd.MultiIndex.from_product([["a", "b"], [0, 1]], names=["A", "B"])
   23: 
   24: frame_data = ({"A": [1]},)
   25: frame_mi_data = ({"A": [1, 2, 3, 4]}, mi)
   26: 
   27: 
   28: # Tuple of
   29: # - Callable: Constructor (Series, DataFrame)
   30: # - Tuple: Constructor args
   31: # - Callable: pass the constructed value with attrs set to this.
   32: 
   33: _all_methods = [
   34:     (pd.Series, ([0],), operator.methodcaller("take", [])),
   35:     (pd.Series, ([0],), operator.methodcaller("__getitem__", [True])),
   36:     (pd.Series, ([0],), operator.methodcaller("repeat", 2)),
   37:     (pd.Series, ([0],), operator.methodcaller("reset_index")),
   38:     (pd.Series, ([0],), operator.methodcaller("reset_index", drop=True)),
   39:     (pd.Series, ([0],), operator.methodcaller("to_frame")),
   40:     (pd.Series, ([0, 0],), operator.methodcaller("drop_duplicates")),
   41:     (pd.Series, ([0, 0],), operator.methodcaller("duplicated")),
   42:     (pd.Series, ([0, 0],), operator.methodcaller("round")),
   43:     (pd.Series, ([0, 0],), operator.methodcaller("rename", lambda x: x + 1)),
   44:     (pd.Series, ([0, 0],), operator.methodcaller("rename", "name")),
   45:     (pd.Series, ([0, 0],), operator.methodcaller("set_axis", ["a", "b"])),
   46:     (pd.Series, ([0, 0],), operator.methodcaller("reindex", [1, 0])),
   47:     (pd.Series, ([0, 0],), operator.methodcaller("drop", [0])),
   48:     (pd.Series, (pd.array([0, pd.NA]),), operator.methodcaller("fillna", 0)),
   49:     (pd.Series, ([0, 0],), operator.methodcaller("replace", {0: 1})),
   50:     (pd.Series, ([0, 0],), operator.methodcaller("shift")),
   51:     (pd.Series, ([0, 0],), operator.methodcaller("isin", [0, 1])),
   52:     (pd.Series, ([0, 0],), operator.methodcaller("between", 0, 2)),
   53:     (pd.Series, ([0, 0],), operator.methodcaller("isna")),
   54:     (pd.Series, ([0, 0],), operator.methodcaller("isnull")),
   55:     (pd.Series, ([0, 0],), operator.methodcaller("notna")),
   56:     (pd.Series, ([0, 0],), operator.methodcaller("notnull")),
   57:     (pd.Series, ([1],), operator.methodcaller("add", pd.Series([1]))),
   58:     # TODO: mul, div, etc.
   59:     (
   60:         pd.Series,
   61:         ([0], pd.period_range("2000", periods=1)),
   62:         operator.methodcaller("to_timestamp"),
   63:     ),
   64:     (
   65:         pd.Series,
   66:         ([0], pd.date_range("2000", periods=1)),
   67:         operator.methodcaller("to_period"),
   68:     ),
   69:     pytest.param(
   70:         (
   71:             pd.DataFrame,
   72:             frame_data,
   73:             operator.methodcaller("dot", pd.DataFrame(index=["A"])),
   74:         ),
   75:         marks=pytest.mark.xfail(reason="Implement binary finalize"),
   76:     ),
   77:     (pd.DataFrame, frame_data, operator.methodcaller("transpose")),
   78:     (pd.DataFrame, frame_data, operator.methodcaller("__getitem__", "A")),
   79:     (pd.DataFrame, frame_data, operator.methodcaller("__getitem__", ["A"])),
   80:     (pd.DataFrame, frame_data, operator.methodcaller("__getitem__", np.array([True]))),
   81:     (pd.DataFrame, ({("A", "a"): [1]},), operator.methodcaller("__getitem__", ["A"])),
   82:     (pd.DataFrame, frame_data, operator.methodcaller("query", "A == 1")),
   83:     (pd.DataFrame, frame_data, operator.methodcaller("eval", "A + 1", engine="python")),
   84:     (pd.DataFrame, frame_data, operator.methodcaller("select_dtypes", include="int")),
   85:     (pd.DataFrame, frame_data, operator.methodcaller("assign", b=1)),
   86:     (pd.DataFrame, frame_data, operator.methodcaller("set_axis", ["A"])),
   87:     (pd.DataFrame, frame_data, operator.methodcaller("reindex", [0, 1])),
   88:     (pd.DataFrame, frame_data, operator.methodcaller("drop", columns=["A"])),
   89:     (pd.DataFrame, frame_data, operator.methodcaller("drop", index=[0])),
   90:     (pd.DataFrame, frame_data, operator.methodcaller("rename", columns={"A": "a"})),
   91:     (pd.DataFrame, frame_data, operator.methodcaller("rename", index=lambda x: x)),
   92:     (pd.DataFrame, frame_data, operator.methodcaller("fillna", "A")),
   93:     (pd.DataFrame, frame_data, operator.methodcaller("fillna", method="ffill")),
   94:     (pd.DataFrame, frame_data, operator.methodcaller("set_index", "A")),
   95:     (pd.DataFrame, frame_data, operator.methodcaller("reset_index")),
   96:     (pd.DataFrame, frame_data, operator.methodcaller("isna")),
   97:     (pd.DataFrame, frame_data, operator.methodcaller("isnull")),
   98:     (pd.DataFrame, frame_data, operator.methodcaller("notna")),
   99:     (pd.DataFrame, frame_data, operator.methodcaller("notnull")),
  100:     (pd.DataFrame, frame_data, operator.methodcaller("dropna")),
  101:     (pd.DataFrame, frame_data, operator.methodcaller("drop_duplicates")),
  102:     (pd.DataFrame, frame_data, operator.methodcaller("duplicated")),
  103:     (pd.DataFrame, frame_data, operator.methodcaller("sort_values", by="A")),
  104:     (pd.DataFrame, frame_data, operator.methodcaller("sort_index")),
  105:     (pd.DataFrame, frame_data, operator.methodcaller("nlargest", 1, "A")),
  106:     (pd.DataFrame, frame_data, operator.methodcaller("nsmallest", 1, "A")),
  107:     (pd.DataFrame, frame_mi_data, operator.methodcaller("swaplevel")),
  108:     (
  109:         pd.DataFrame,
  110:         frame_data,
  111:         operator.methodcaller("add", pd.DataFrame(*frame_data)),
  112:     ),
  113:     # TODO: div, mul, etc.
  114:     (
  115:         pd.DataFrame,
  116:         frame_data,
  117:         operator.methodcaller("combine", pd.DataFrame(*frame_data), operator.add),
  118:     ),
  119:     (
  120:         pd.DataFrame,
  121:         frame_data,
  122:         operator.methodcaller("combine_first", pd.DataFrame(*frame_data)),
  123:     ),
  124:     pytest.param(
  125:         (
  126:             pd.DataFrame,
  127:             frame_data,
  128:             operator.methodcaller("update", pd.DataFrame(*frame_data)),
  129:         ),
  130:         marks=not_implemented_mark,
  131:     ),
  132:     (pd.DataFrame, frame_data, operator.methodcaller("pivot", columns="A")),
  133:     (
  134:         pd.DataFrame,
  135:         ({"A": [1], "B": [1]},),
  136:         operator.methodcaller("pivot_table", columns="A"),
  137:     ),
  138:     (
  139:         pd.DataFrame,
  140:         ({"A": [1], "B": [1]},),
  141:         operator.methodcaller("pivot_table", columns="A", aggfunc=["mean", "sum"]),
  142:     ),
  143:     (pd.DataFrame, frame_data, operator.methodcaller("stack")),
  144:     (pd.DataFrame, frame_data, operator.methodcaller("explode", "A")),
  145:     (pd.DataFrame, frame_mi_data, operator.methodcaller("unstack")),
  146:     (
  147:         pd.DataFrame,
  148:         ({"A": ["a", "b", "c"], "B": [1, 3, 5], "C": [2, 4, 6]},),
  149:         operator.methodcaller("melt", id_vars=["A"], value_vars=["B"]),
  150:     ),
  151:     (pd.DataFrame, frame_data, operator.methodcaller("map", lambda x: x)),
  152:     pytest.param(
  153:         (
  154:             pd.DataFrame,
  155:             frame_data,
  156:             operator.methodcaller("merge", pd.DataFrame({"A": [1]})),
  157:         ),
  158:         marks=not_implemented_mark,
  159:     ),
  160:     (pd.DataFrame, frame_data, operator.methodcaller("round", 2)),
  161:     (pd.DataFrame, frame_data, operator.methodcaller("corr")),
  162:     pytest.param(
  163:         (pd.DataFrame, frame_data, operator.methodcaller("cov")),
  164:         marks=[
  165:             pytest.mark.filterwarnings("ignore::RuntimeWarning"),
  166:         ],
  167:     ),
  168:     (
  169:         pd.DataFrame,
  170:         frame_data,
  171:         operator.methodcaller("corrwith", pd.DataFrame(*frame_data)),
  172:     ),
  173:     (pd.DataFrame, frame_data, operator.methodcaller("count")),
  174:     (pd.DataFrame, frame_data, operator.methodcaller("nunique")),
  175:     (pd.DataFrame, frame_data, operator.methodcaller("idxmin")),
  176:     (pd.DataFrame, frame_data, operator.methodcaller("idxmax")),
  177:     (pd.DataFrame, frame_data, operator.methodcaller("mode")),
  178:     (pd.Series, [0], operator.methodcaller("mode")),
  179:     (pd.DataFrame, frame_data, operator.methodcaller("median")),
  180:     (
  181:         pd.DataFrame,
  182:         frame_data,
  183:         operator.methodcaller("quantile", numeric_only=True),
  184:     ),
  185:     (
  186:         pd.DataFrame,
  187:         frame_data,
  188:         operator.methodcaller("quantile", q=[0.25, 0.75], numeric_only=True),
  189:     ),
  190:     (
  191:         pd.DataFrame,
  192:         ({"A": [pd.Timedelta(days=1), pd.Timedelta(days=2)]},),
  193:         operator.methodcaller("quantile", numeric_only=False),
  194:     ),
  195:     (
  196:         pd.DataFrame,
  197:         ({"A": [np.datetime64("2022-01-01"), np.datetime64("2022-01-02")]},),
  198:         operator.methodcaller("quantile", numeric_only=True),
  199:     ),
  200:     (
  201:         pd.DataFrame,
  202:         ({"A": [1]}, [pd.Period("2000", "D")]),
  203:         operator.methodcaller("to_timestamp"),
  204:     ),
  205:     (
  206:         pd.DataFrame,
  207:         ({"A": [1]}, [pd.Timestamp("2000")]),
  208:         operator.methodcaller("to_period", freq="D"),
  209:     ),
  210:     (pd.DataFrame, frame_mi_data, operator.methodcaller("isin", [1])),
  211:     (pd.DataFrame, frame_mi_data, operator.methodcaller("isin", pd.Series([1]))),
  212:     (
  213:         pd.DataFrame,
  214:         frame_mi_data,
  215:         operator.methodcaller("isin", pd.DataFrame({"A": [1]})),
  216:     ),
  217:     (pd.DataFrame, frame_mi_data, operator.methodcaller("droplevel", "A")),
  218:     (pd.DataFrame, frame_data, operator.methodcaller("pop", "A")),
  219:     # Squeeze on columns, otherwise we'll end up with a scalar
  220:     (pd.DataFrame, frame_data, operator.methodcaller("squeeze", axis="columns")),
  221:     (pd.Series, ([1, 2],), operator.methodcaller("squeeze")),
  222:     (pd.Series, ([1, 2],), operator.methodcaller("rename_axis", index="a")),
  223:     (pd.DataFrame, frame_data, operator.methodcaller("rename_axis", columns="a")),
  224:     # Unary ops
  225:     (pd.DataFrame, frame_data, operator.neg),
  226:     (pd.Series, [1], operator.neg),
  227:     (pd.DataFrame, frame_data, operator.pos),
  228:     (pd.Series, [1], operator.pos),
  229:     (pd.DataFrame, frame_data, operator.inv),
  230:     (pd.Series, [1], operator.inv),
  231:     (pd.DataFrame, frame_data, abs),
  232:     (pd.Series, [1], abs),
  233:     (pd.DataFrame, frame_data, round),
  234:     (pd.Series, [1], round),
  235:     (pd.DataFrame, frame_data, operator.methodcaller("take", [0, 0])),
  236:     (pd.DataFrame, frame_mi_data, operator.methodcaller("xs", "a")),
  237:     (pd.Series, (1, mi), operator.methodcaller("xs", "a")),
  238:     (pd.DataFrame, frame_data, operator.methodcaller("get", "A")),
  239:     (
  240:         pd.DataFrame,
  241:         frame_data,
  242:         operator.methodcaller("reindex_like", pd.DataFrame({"A": [1, 2, 3]})),
  243:     ),
  244:     (
  245:         pd.Series,
  246:         frame_data,
  247:         operator.methodcaller("reindex_like", pd.Series([0, 1, 2])),
  248:     ),
  249:     (pd.DataFrame, frame_data, operator.methodcaller("add_prefix", "_")),
  250:     (pd.DataFrame, frame_data, operator.methodcaller("add_suffix", "_")),
  251:     (pd.Series, (1, ["a", "b"]), operator.methodcaller("add_prefix", "_")),
  252:     (pd.Series, (1, ["a", "b"]), operator.methodcaller("add_suffix", "_")),
  253:     (pd.Series, ([3, 2],), operator.methodcaller("sort_values")),
  254:     (pd.Series, ([1] * 10,), operator.methodcaller("head")),
  255:     (pd.DataFrame, ({"A": [1] * 10},), operator.methodcaller("head")),
  256:     (pd.Series, ([1] * 10,), operator.methodcaller("tail")),
  257:     (pd.DataFrame, ({"A": [1] * 10},), operator.methodcaller("tail")),
  258:     (pd.Series, ([1, 2],), operator.methodcaller("sample", n=2, replace=True)),
  259:     (pd.DataFrame, (frame_data,), operator.methodcaller("sample", n=2, replace=True)),
  260:     (pd.Series, ([1, 2],), operator.methodcaller("astype", float)),
  261:     (pd.DataFrame, frame_data, operator.methodcaller("astype", float)),
  262:     (pd.Series, ([1, 2],), operator.methodcaller("copy")),
  263:     (pd.DataFrame, frame_data, operator.methodcaller("copy")),
  264:     (pd.Series, ([1, 2], None, object), operator.methodcaller("infer_objects")),
  265:     (
  266:         pd.DataFrame,
  267:         ({"A": np.array([1, 2], dtype=object)},),
  268:         operator.methodcaller("infer_objects"),
  269:     ),
  270:     (pd.Series, ([1, 2],), operator.methodcaller("convert_dtypes")),
  271:     (pd.DataFrame, frame_data, operator.methodcaller("convert_dtypes")),
  272:     (pd.Series, ([1, None, 3],), operator.methodcaller("interpolate")),
  273:     (pd.DataFrame, ({"A": [1, None, 3]},), operator.methodcaller("interpolate")),
  274:     (pd.Series, ([1, 2],), operator.methodcaller("clip", lower=1)),
  275:     (pd.DataFrame, frame_data, operator.methodcaller("clip", lower=1)),
  276:     (
  277:         pd.Series,
  278:         (1, pd.date_range("2000", periods=4)),
  279:         operator.methodcaller("asfreq", "h"),
  280:     ),
  281:     (
  282:         pd.DataFrame,
  283:         ({"A": [1, 1, 1, 1]}, pd.date_range("2000", periods=4)),
  284:         operator.methodcaller("asfreq", "h"),
  285:     ),
  286:     (
  287:         pd.Series,
  288:         (1, pd.date_range("2000", periods=4)),
  289:         operator.methodcaller("at_time", "12:00"),
  290:     ),
  291:     (
  292:         pd.DataFrame,
  293:         ({"A": [1, 1, 1, 1]}, pd.date_range("2000", periods=4)),
  294:         operator.methodcaller("at_time", "12:00"),
  295:     ),
  296:     (
  297:         pd.Series,
  298:         (1, pd.date_range("2000", periods=4)),
  299:         operator.methodcaller("between_time", "12:00", "13:00"),
  300:     ),
  301:     (
  302:         pd.DataFrame,
  303:         ({"A": [1, 1, 1, 1]}, pd.date_range("2000", periods=4)),
  304:         operator.methodcaller("between_time", "12:00", "13:00"),
  305:     ),
  306:     (
  307:         pd.Series,
  308:         (1, pd.date_range("2000", periods=4)),
  309:         operator.methodcaller("last", "3D"),
  310:     ),
  311:     (
  312:         pd.DataFrame,
  313:         ({"A": [1, 1, 1, 1]}, pd.date_range("2000", periods=4)),
  314:         operator.methodcaller("last", "3D"),
  315:     ),
  316:     (pd.Series, ([1, 2],), operator.methodcaller("rank")),
  317:     (pd.DataFrame, frame_data, operator.methodcaller("rank")),
  318:     (pd.Series, ([1, 2],), operator.methodcaller("where", np.array([True, False]))),
  319:     (pd.DataFrame, frame_data, operator.methodcaller("where", np.array([[True]]))),
  320:     (pd.Series, ([1, 2],), operator.methodcaller("mask", np.array([True, False]))),
  321:     (pd.DataFrame, frame_data, operator.methodcaller("mask", np.array([[True]]))),
  322:     (pd.Series, ([1, 2],), operator.methodcaller("truncate", before=0)),
  323:     (pd.DataFrame, frame_data, operator.methodcaller("truncate", before=0)),
  324:     (
  325:         pd.Series,
  326:         (1, pd.date_range("2000", periods=4, tz="UTC")),
  327:         operator.methodcaller("tz_convert", "CET"),
  328:     ),
  329:     (
  330:         pd.DataFrame,
  331:         ({"A": [1, 1, 1, 1]}, pd.date_range("2000", periods=4, tz="UTC")),
  332:         operator.methodcaller("tz_convert", "CET"),
  333:     ),
  334:     (
  335:         pd.Series,
  336:         (1, pd.date_range("2000", periods=4)),
  337:         operator.methodcaller("tz_localize", "CET"),
  338:     ),
  339:     (
  340:         pd.DataFrame,
  341:         ({"A": [1, 1, 1, 1]}, pd.date_range("2000", periods=4)),
  342:         operator.methodcaller("tz_localize", "CET"),
  343:     ),
  344:     (pd.Series, ([1, 2],), operator.methodcaller("describe")),
  345:     (pd.DataFrame, frame_data, operator.methodcaller("describe")),
  346:     (pd.Series, ([1, 2],), operator.methodcaller("pct_change")),
  347:     (pd.DataFrame, frame_data, operator.methodcaller("pct_change")),
  348:     (pd.Series, ([1],), operator.methodcaller("transform", lambda x: x - x.min())),
  349:     (
  350:         pd.DataFrame,
  351:         frame_mi_data,
  352:         operator.methodcaller("transform", lambda x: x - x.min()),
  353:     ),
  354:     (pd.Series, ([1],), operator.methodcaller("apply", lambda x: x)),
  355:     (pd.DataFrame, frame_mi_data, operator.methodcaller("apply", lambda x: x)),
  356:     # Cumulative reductions
  357:     (pd.Series, ([1],), operator.methodcaller("cumsum")),
  358:     (pd.DataFrame, frame_data, operator.methodcaller("cumsum")),
  359:     (pd.Series, ([1],), operator.methodcaller("cummin")),
  360:     (pd.DataFrame, frame_data, operator.methodcaller("cummin")),
  361:     (pd.Series, ([1],), operator.methodcaller("cummax")),
  362:     (pd.DataFrame, frame_data, operator.methodcaller("cummax")),
  363:     (pd.Series, ([1],), operator.methodcaller("cumprod")),
  364:     (pd.DataFrame, frame_data, operator.methodcaller("cumprod")),
  365:     # Reductions
  366:     (pd.DataFrame, frame_data, operator.methodcaller("any")),
  367:     (pd.DataFrame, frame_data, operator.methodcaller("all")),
  368:     (pd.DataFrame, frame_data, operator.methodcaller("min")),
  369:     (pd.DataFrame, frame_data, operator.methodcaller("max")),
  370:     (pd.DataFrame, frame_data, operator.methodcaller("sum")),
  371:     (pd.DataFrame, frame_data, operator.methodcaller("std")),
  372:     (pd.DataFrame, frame_data, operator.methodcaller("mean")),
  373:     (pd.DataFrame, frame_data, operator.methodcaller("prod")),
  374:     (pd.DataFrame, frame_data, operator.methodcaller("sem")),
  375:     (pd.DataFrame, frame_data, operator.methodcaller("skew")),
  376:     (pd.DataFrame, frame_data, operator.methodcaller("kurt")),
  377: ]
  378: 
  379: 
  380: def idfn(x):
  381:     xpr = re.compile(r"'(.*)?'")
  382:     m = xpr.search(str(x))
  383:     if m:
  384:         return m.group(1)
  385:     else:
  386:         return str(x)
  387: 
  388: 
  389: @pytest.fixture(params=_all_methods, ids=lambda x: idfn(x[-1]))
  390: def ndframe_method(request):
  391:     """
  392:     An NDFrame method returning an NDFrame.
  393:     """
  394:     return request.param
  395: 
  396: 
  397: @pytest.mark.filterwarnings(
  398:     "ignore:DataFrame.fillna with 'method' is deprecated:FutureWarning",
  399:     "ignore:last is deprecated:FutureWarning",
  400: )
  401: def test_finalize_called(ndframe_method):
  402:     cls, init_args, method = ndframe_method
  403:     ndframe = cls(*init_args)
  404: 
  405:     ndframe.attrs = {"a": 1}
  406:     result = method(ndframe)
  407: 
  408:     assert result.attrs == {"a": 1}
  409: 
  410: 
  411: @pytest.mark.parametrize(
  412:     "data",
  413:     [
  414:         pd.Series(1, pd.date_range("2000", periods=4)),
  415:         pd.DataFrame({"A": [1, 1, 1, 1]}, pd.date_range("2000", periods=4)),
  416:     ],
  417: )
  418: def test_finalize_first(data):
  419:     deprecated_msg = "first is deprecated"
  420: 
  421:     data.attrs = {"a": 1}
  422:     with tm.assert_produces_warning(FutureWarning, match=deprecated_msg):
  423:         result = data.first("3D")
  424:         assert result.attrs == {"a": 1}
  425: 
  426: 
  427: @pytest.mark.parametrize(
  428:     "data",
  429:     [
  430:         pd.Series(1, pd.date_range("2000", periods=4)),
  431:         pd.DataFrame({"A": [1, 1, 1, 1]}, pd.date_range("2000", periods=4)),
  432:     ],
  433: )
  434: def test_finalize_last(data):
  435:     # GH 53710
  436:     deprecated_msg = "last is deprecated"
  437: 
  438:     data.attrs = {"a": 1}
  439:     with tm.assert_produces_warning(FutureWarning, match=deprecated_msg):
  440:         result = data.last("3D")
  441:         assert result.attrs == {"a": 1}
  442: 
  443: 
  444: @not_implemented_mark
  445: def test_finalize_called_eval_numexpr():
  446:     pytest.importorskip("numexpr")
  447:     df = pd.DataFrame({"A": [1, 2]})
  448:     df.attrs["A"] = 1
  449:     result = df.eval("A + 1", engine="numexpr")
  450:     assert result.attrs == {"A": 1}
  451: 
  452: 
  453: # ----------------------------------------------------------------------------
  454: # Binary operations
  455: 
  456: 
  457: @pytest.mark.parametrize("annotate", ["left", "right", "both"])
  458: @pytest.mark.parametrize(
  459:     "args",
  460:     [
  461:         (1, pd.Series([1])),
  462:         (1, pd.DataFrame({"A": [1]})),
  463:         (pd.Series([1]), 1),
  464:         (pd.DataFrame({"A": [1]}), 1),
  465:         (pd.Series([1]), pd.Series([1])),
  466:         (pd.DataFrame({"A": [1]}), pd.DataFrame({"A": [1]})),
  467:         (pd.Series([1]), pd.DataFrame({"A": [1]})),
  468:         (pd.DataFrame({"A": [1]}), pd.Series([1])),
  469:     ],
  470:     ids=lambda x: f"({type(x[0]).__name__},{type(x[1]).__name__})",
  471: )
  472: def test_binops(request, args, annotate, all_binary_operators):
  473:     # This generates 624 tests... Is that needed?
  474:     left, right = args
  475:     if isinstance(left, (pd.DataFrame, pd.Series)):
  476:         left.attrs = {}
  477:     if isinstance(right, (pd.DataFrame, pd.Series)):
  478:         right.attrs = {}
  479: 
  480:     if annotate == "left" and isinstance(left, int):
  481:         pytest.skip("left is an int and doesn't support .attrs")
  482:     if annotate == "right" and isinstance(right, int):
  483:         pytest.skip("right is an int and doesn't support .attrs")
  484: 
  485:     if not (isinstance(left, int) or isinstance(right, int)) and annotate != "both":
  486:         if not all_binary_operators.__name__.startswith("r"):
  487:             if annotate == "right" and isinstance(left, type(right)):
  488:                 request.applymarker(
  489:                     pytest.mark.xfail(
  490:                         reason=f"{all_binary_operators} doesn't work when right has "
  491:                         f"attrs and both are {type(left)}"
  492:                     )
  493:                 )
  494:             if not isinstance(left, type(right)):
  495:                 if annotate == "left" and isinstance(left, pd.Series):
  496:                     request.applymarker(
  497:                         pytest.mark.xfail(
  498:                             reason=f"{all_binary_operators} doesn't work when the "
  499:                             "objects are different Series has attrs"
  500:                         )
  501:                     )
  502:                 elif annotate == "right" and isinstance(right, pd.Series):
  503:                     request.applymarker(
  504:                         pytest.mark.xfail(
  505:                             reason=f"{all_binary_operators} doesn't work when the "
  506:                             "objects are different Series has attrs"
  507:                         )
  508:                     )
  509:         else:
  510:             if annotate == "left" and isinstance(left, type(right)):
  511:                 request.applymarker(
  512:                     pytest.mark.xfail(
  513:                         reason=f"{all_binary_operators} doesn't work when left has "
  514:                         f"attrs and both are {type(left)}"
  515:                     )
  516:                 )
  517:             if not isinstance(left, type(right)):
  518:                 if annotate == "right" and isinstance(right, pd.Series):
  519:                     request.applymarker(
  520:                         pytest.mark.xfail(
  521:                             reason=f"{all_binary_operators} doesn't work when the "
  522:                             "objects are different Series has attrs"
  523:                         )
  524:                     )
  525:                 elif annotate == "left" and isinstance(left, pd.Series):
  526:                     request.applymarker(
  527:                         pytest.mark.xfail(
  528:                             reason=f"{all_binary_operators} doesn't work when the "
  529:                             "objects are different Series has attrs"
  530:                         )
  531:                     )
  532:     if annotate in {"left", "both"} and not isinstance(left, int):
  533:         left.attrs = {"a": 1}
  534:     if annotate in {"right", "both"} and not isinstance(right, int):
  535:         right.attrs = {"a": 1}
  536: 
  537:     is_cmp = all_binary_operators in [
  538:         operator.eq,
  539:         operator.ne,
  540:         operator.gt,
  541:         operator.ge,
  542:         operator.lt,
  543:         operator.le,
  544:     ]
  545:     if is_cmp and isinstance(left, pd.DataFrame) and isinstance(right, pd.Series):
  546:         # in 2.0 silent alignment on comparisons was removed xref GH#28759
  547:         left, right = left.align(right, axis=1, copy=False)
  548:     elif is_cmp and isinstance(left, pd.Series) and isinstance(right, pd.DataFrame):
  549:         right, left = right.align(left, axis=1, copy=False)
  550: 
  551:     result = all_binary_operators(left, right)
  552:     assert result.attrs == {"a": 1}
  553: 
  554: 
  555: # ----------------------------------------------------------------------------
  556: # Accessors
  557: 
  558: 
  559: @pytest.mark.parametrize(
  560:     "method",
  561:     [
  562:         operator.methodcaller("capitalize"),
  563:         operator.methodcaller("casefold"),
  564:         operator.methodcaller("cat", ["a"]),
  565:         operator.methodcaller("contains", "a"),
  566:         operator.methodcaller("count", "a"),
  567:         operator.methodcaller("encode", "utf-8"),
  568:         operator.methodcaller("endswith", "a"),
  569:         operator.methodcaller("extract", r"(\w)(\d)"),
  570:         operator.methodcaller("extract", r"(\w)(\d)", expand=False),
  571:         operator.methodcaller("find", "a"),
  572:         operator.methodcaller("findall", "a"),
  573:         operator.methodcaller("get", 0),
  574:         operator.methodcaller("index", "a"),
  575:         operator.methodcaller("len"),
  576:         operator.methodcaller("ljust", 4),
  577:         operator.methodcaller("lower"),
  578:         operator.methodcaller("lstrip"),
  579:         operator.methodcaller("match", r"\w"),
  580:         operator.methodcaller("normalize", "NFC"),
  581:         operator.methodcaller("pad", 4),
  582:         operator.methodcaller("partition", "a"),
  583:         operator.methodcaller("repeat", 2),
  584:         operator.methodcaller("replace", "a", "b"),
  585:         operator.methodcaller("rfind", "a"),
  586:         operator.methodcaller("rindex", "a"),
  587:         operator.methodcaller("rjust", 4),
  588:         operator.methodcaller("rpartition", "a"),
  589:         operator.methodcaller("rstrip"),
  590:         operator.methodcaller("slice", 4),
  591:         operator.methodcaller("slice_replace", 1, repl="a"),
  592:         operator.methodcaller("startswith", "a"),
  593:         operator.methodcaller("strip"),
  594:         operator.methodcaller("swapcase"),
  595:         operator.methodcaller("translate", {"a": "b"}),
  596:         operator.methodcaller("upper"),
  597:         operator.methodcaller("wrap", 4),
  598:         operator.methodcaller("zfill", 4),
  599:         operator.methodcaller("isalnum"),
  600:         operator.methodcaller("isalpha"),
  601:         operator.methodcaller("isdigit"),
  602:         operator.methodcaller("isspace"),
  603:         operator.methodcaller("islower"),
  604:         operator.methodcaller("isupper"),
  605:         operator.methodcaller("istitle"),
  606:         operator.methodcaller("isnumeric"),
  607:         operator.methodcaller("isdecimal"),
  608:         operator.methodcaller("get_dummies"),
  609:     ],
  610:     ids=idfn,
  611: )
  612: def test_string_method(method):
  613:     s = pd.Series(["a1"])
  614:     s.attrs = {"a": 1}
  615:     result = method(s.str)
  616:     assert result.attrs == {"a": 1}
  617: 
  618: 
  619: @pytest.mark.parametrize(
  620:     "method",
  621:     [
  622:         operator.methodcaller("to_period"),
  623:         operator.methodcaller("tz_localize", "CET"),
  624:         operator.methodcaller("normalize"),
  625:         operator.methodcaller("strftime", "%Y"),
  626:         operator.methodcaller("round", "h"),
  627:         operator.methodcaller("floor", "h"),
  628:         operator.methodcaller("ceil", "h"),
  629:         operator.methodcaller("month_name"),
  630:         operator.methodcaller("day_name"),
  631:     ],
  632:     ids=idfn,
  633: )
  634: def test_datetime_method(method):
  635:     s = pd.Series(pd.date_range("2000", periods=4))
  636:     s.attrs = {"a": 1}
  637:     result = method(s.dt)
  638:     assert result.attrs == {"a": 1}
  639: 
  640: 
  641: @pytest.mark.parametrize(
  642:     "attr",
  643:     [
  644:         "date",
  645:         "time",
  646:         "timetz",
  647:         "year",
  648:         "month",
  649:         "day",
  650:         "hour",
  651:         "minute",
  652:         "second",
  653:         "microsecond",
  654:         "nanosecond",
  655:         "dayofweek",
  656:         "day_of_week",
  657:         "dayofyear",
  658:         "day_of_year",
  659:         "quarter",
  660:         "is_month_start",
  661:         "is_month_end",
  662:         "is_quarter_start",
  663:         "is_quarter_end",
  664:         "is_year_start",
  665:         "is_year_end",
  666:         "is_leap_year",
  667:         "daysinmonth",
  668:         "days_in_month",
  669:     ],
  670: )
  671: def test_datetime_property(attr):
  672:     s = pd.Series(pd.date_range("2000", periods=4))
  673:     s.attrs = {"a": 1}
  674:     result = getattr(s.dt, attr)
  675:     assert result.attrs == {"a": 1}
  676: 
  677: 
  678: @pytest.mark.parametrize(
  679:     "attr", ["days", "seconds", "microseconds", "nanoseconds", "components"]
  680: )
  681: def test_timedelta_property(attr):
  682:     s = pd.Series(pd.timedelta_range("2000", periods=4))
  683:     s.attrs = {"a": 1}
  684:     result = getattr(s.dt, attr)
  685:     assert result.attrs == {"a": 1}
  686: 
  687: 
  688: @pytest.mark.parametrize("method", [operator.methodcaller("total_seconds")])
  689: def test_timedelta_methods(method):
  690:     s = pd.Series(pd.timedelta_range("2000", periods=4))
  691:     s.attrs = {"a": 1}
  692:     result = method(s.dt)
  693:     assert result.attrs == {"a": 1}
  694: 
  695: 
  696: @pytest.mark.parametrize(
  697:     "method",
  698:     [
  699:         operator.methodcaller("add_categories", ["c"]),
  700:         operator.methodcaller("as_ordered"),
  701:         operator.methodcaller("as_unordered"),
  702:         lambda x: getattr(x, "codes"),
  703:         operator.methodcaller("remove_categories", "a"),
  704:         operator.methodcaller("remove_unused_categories"),
  705:         operator.methodcaller("rename_categories", {"a": "A", "b": "B"}),
  706:         operator.methodcaller("reorder_categories", ["b", "a"]),
  707:         operator.methodcaller("set_categories", ["A", "B"]),
  708:     ],
  709: )
  710: @not_implemented_mark
  711: def test_categorical_accessor(method):
  712:     s = pd.Series(["a", "b"], dtype="category")
  713:     s.attrs = {"a": 1}
  714:     result = method(s.cat)
  715:     assert result.attrs == {"a": 1}
  716: 
  717: 
  718: # ----------------------------------------------------------------------------
  719: # Groupby
  720: 
  721: 
  722: @pytest.mark.parametrize(
  723:     "obj", [pd.Series([0, 0]), pd.DataFrame({"A": [0, 1], "B": [1, 2]})]
  724: )
  725: @pytest.mark.parametrize(
  726:     "method",
  727:     [
  728:         operator.methodcaller("sum"),
  729:         lambda x: x.apply(lambda y: y),
  730:         lambda x: x.agg("sum"),
  731:         lambda x: x.agg("mean"),
  732:         lambda x: x.agg("median"),
  733:     ],
  734: )
  735: def test_groupby_finalize(obj, method):
  736:     obj.attrs = {"a": 1}
  737:     result = method(obj.groupby([0, 0], group_keys=False))
  738:     assert result.attrs == {"a": 1}
  739: 
  740: 
  741: @pytest.mark.parametrize(
  742:     "obj", [pd.Series([0, 0]), pd.DataFrame({"A": [0, 1], "B": [1, 2]})]
  743: )
  744: @pytest.mark.parametrize(
  745:     "method",
  746:     [
  747:         lambda x: x.agg(["sum", "count"]),
  748:         lambda x: x.agg("std"),
  749:         lambda x: x.agg("var"),
  750:         lambda x: x.agg("sem"),
  751:         lambda x: x.agg("size"),
  752:         lambda x: x.agg("ohlc"),
  753:     ],
  754: )
  755: @not_implemented_mark
  756: def test_groupby_finalize_not_implemented(obj, method):
  757:     obj.attrs = {"a": 1}
  758:     result = method(obj.groupby([0, 0]))
  759:     assert result.attrs == {"a": 1}
  760: 
  761: 
  762: def test_finalize_frame_series_name():
  763:     # https://github.com/pandas-dev/pandas/pull/37186/files#r506978889
  764:     # ensure we don't copy the column `name` to the Series.
  765:     df = pd.DataFrame({"name": [1, 2]})
  766:     result = pd.Series([1, 2]).__finalize__(df)
  767:     assert result.name is None
