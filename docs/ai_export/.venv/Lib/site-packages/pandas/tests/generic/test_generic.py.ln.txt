    1: from copy import (
    2:     copy,
    3:     deepcopy,
    4: )
    5: 
    6: import numpy as np
    7: import pytest
    8: 
    9: from pandas.core.dtypes.common import is_scalar
   10: 
   11: from pandas import (
   12:     DataFrame,
   13:     Index,
   14:     Series,
   15:     date_range,
   16: )
   17: import pandas._testing as tm
   18: 
   19: # ----------------------------------------------------------------------
   20: # Generic types test cases
   21: 
   22: 
   23: def construct(box, shape, value=None, dtype=None, **kwargs):
   24:     """
   25:     construct an object for the given shape
   26:     if value is specified use that if its a scalar
   27:     if value is an array, repeat it as needed
   28:     """
   29:     if isinstance(shape, int):
   30:         shape = tuple([shape] * box._AXIS_LEN)
   31:     if value is not None:
   32:         if is_scalar(value):
   33:             if value == "empty":
   34:                 arr = None
   35:                 dtype = np.float64
   36: 
   37:                 # remove the info axis
   38:                 kwargs.pop(box._info_axis_name, None)
   39:             else:
   40:                 arr = np.empty(shape, dtype=dtype)
   41:                 arr.fill(value)
   42:         else:
   43:             fshape = np.prod(shape)
   44:             arr = value.ravel()
   45:             new_shape = fshape / arr.shape[0]
   46:             if fshape % arr.shape[0] != 0:
   47:                 raise Exception("invalid value passed in construct")
   48: 
   49:             arr = np.repeat(arr, new_shape).reshape(shape)
   50:     else:
   51:         arr = np.random.default_rng(2).standard_normal(shape)
   52:     return box(arr, dtype=dtype, **kwargs)
   53: 
   54: 
   55: class TestGeneric:
   56:     @pytest.mark.parametrize(
   57:         "func",
   58:         [
   59:             str.lower,
   60:             {x: x.lower() for x in list("ABCD")},
   61:             Series({x: x.lower() for x in list("ABCD")}),
   62:         ],
   63:     )
   64:     def test_rename(self, frame_or_series, func):
   65:         # single axis
   66:         idx = list("ABCD")
   67: 
   68:         for axis in frame_or_series._AXIS_ORDERS:
   69:             kwargs = {axis: idx}
   70:             obj = construct(frame_or_series, 4, **kwargs)
   71: 
   72:             # rename a single axis
   73:             result = obj.rename(**{axis: func})
   74:             expected = obj.copy()
   75:             setattr(expected, axis, list("abcd"))
   76:             tm.assert_equal(result, expected)
   77: 
   78:     def test_get_numeric_data(self, frame_or_series):
   79:         n = 4
   80:         kwargs = {
   81:             frame_or_series._get_axis_name(i): list(range(n))
   82:             for i in range(frame_or_series._AXIS_LEN)
   83:         }
   84: 
   85:         # get the numeric data
   86:         o = construct(frame_or_series, n, **kwargs)
   87:         result = o._get_numeric_data()
   88:         tm.assert_equal(result, o)
   89: 
   90:         # non-inclusion
   91:         result = o._get_bool_data()
   92:         expected = construct(frame_or_series, n, value="empty", **kwargs)
   93:         if isinstance(o, DataFrame):
   94:             # preserve columns dtype
   95:             expected.columns = o.columns[:0]
   96:         # https://github.com/pandas-dev/pandas/issues/50862
   97:         tm.assert_equal(result.reset_index(drop=True), expected)
   98: 
   99:         # get the bool data
  100:         arr = np.array([True, True, False, True])
  101:         o = construct(frame_or_series, n, value=arr, **kwargs)
  102:         result = o._get_numeric_data()
  103:         tm.assert_equal(result, o)
  104: 
  105:     def test_nonzero(self, frame_or_series):
  106:         # GH 4633
  107:         # look at the boolean/nonzero behavior for objects
  108:         obj = construct(frame_or_series, shape=4)
  109:         msg = f"The truth value of a {frame_or_series.__name__} is ambiguous"
  110:         with pytest.raises(ValueError, match=msg):
  111:             bool(obj == 0)
  112:         with pytest.raises(ValueError, match=msg):
  113:             bool(obj == 1)
  114:         with pytest.raises(ValueError, match=msg):
  115:             bool(obj)
  116: 
  117:         obj = construct(frame_or_series, shape=4, value=1)
  118:         with pytest.raises(ValueError, match=msg):
  119:             bool(obj == 0)
  120:         with pytest.raises(ValueError, match=msg):
  121:             bool(obj == 1)
  122:         with pytest.raises(ValueError, match=msg):
  123:             bool(obj)
  124: 
  125:         obj = construct(frame_or_series, shape=4, value=np.nan)
  126:         with pytest.raises(ValueError, match=msg):
  127:             bool(obj == 0)
  128:         with pytest.raises(ValueError, match=msg):
  129:             bool(obj == 1)
  130:         with pytest.raises(ValueError, match=msg):
  131:             bool(obj)
  132: 
  133:         # empty
  134:         obj = construct(frame_or_series, shape=0)
  135:         with pytest.raises(ValueError, match=msg):
  136:             bool(obj)
  137: 
  138:         # invalid behaviors
  139: 
  140:         obj1 = construct(frame_or_series, shape=4, value=1)
  141:         obj2 = construct(frame_or_series, shape=4, value=1)
  142: 
  143:         with pytest.raises(ValueError, match=msg):
  144:             if obj1:
  145:                 pass
  146: 
  147:         with pytest.raises(ValueError, match=msg):
  148:             obj1 and obj2
  149:         with pytest.raises(ValueError, match=msg):
  150:             obj1 or obj2
  151:         with pytest.raises(ValueError, match=msg):
  152:             not obj1
  153: 
  154:     def test_frame_or_series_compound_dtypes(self, frame_or_series):
  155:         # see gh-5191
  156:         # Compound dtypes should raise NotImplementedError.
  157: 
  158:         def f(dtype):
  159:             return construct(frame_or_series, shape=3, value=1, dtype=dtype)
  160: 
  161:         msg = (
  162:             "compound dtypes are not implemented "
  163:             f"in the {frame_or_series.__name__} constructor"
  164:         )
  165: 
  166:         with pytest.raises(NotImplementedError, match=msg):
  167:             f([("A", "datetime64[h]"), ("B", "str"), ("C", "int32")])
  168: 
  169:         # these work (though results may be unexpected)
  170:         f("int64")
  171:         f("float64")
  172:         f("M8[ns]")
  173: 
  174:     def test_metadata_propagation(self, frame_or_series):
  175:         # check that the metadata matches up on the resulting ops
  176: 
  177:         o = construct(frame_or_series, shape=3)
  178:         o.name = "foo"
  179:         o2 = construct(frame_or_series, shape=3)
  180:         o2.name = "bar"
  181: 
  182:         # ----------
  183:         # preserving
  184:         # ----------
  185: 
  186:         # simple ops with scalars
  187:         for op in ["__add__", "__sub__", "__truediv__", "__mul__"]:
  188:             result = getattr(o, op)(1)
  189:             tm.assert_metadata_equivalent(o, result)
  190: 
  191:         # ops with like
  192:         for op in ["__add__", "__sub__", "__truediv__", "__mul__"]:
  193:             result = getattr(o, op)(o)
  194:             tm.assert_metadata_equivalent(o, result)
  195: 
  196:         # simple boolean
  197:         for op in ["__eq__", "__le__", "__ge__"]:
  198:             v1 = getattr(o, op)(o)
  199:             tm.assert_metadata_equivalent(o, v1)
  200:             tm.assert_metadata_equivalent(o, v1 & v1)
  201:             tm.assert_metadata_equivalent(o, v1 | v1)
  202: 
  203:         # combine_first
  204:         result = o.combine_first(o2)
  205:         tm.assert_metadata_equivalent(o, result)
  206: 
  207:         # ---------------------------
  208:         # non-preserving (by default)
  209:         # ---------------------------
  210: 
  211:         # add non-like
  212:         result = o + o2
  213:         tm.assert_metadata_equivalent(result)
  214: 
  215:         # simple boolean
  216:         for op in ["__eq__", "__le__", "__ge__"]:
  217:             # this is a name matching op
  218:             v1 = getattr(o, op)(o)
  219:             v2 = getattr(o, op)(o2)
  220:             tm.assert_metadata_equivalent(v2)
  221:             tm.assert_metadata_equivalent(v1 & v2)
  222:             tm.assert_metadata_equivalent(v1 | v2)
  223: 
  224:     def test_size_compat(self, frame_or_series):
  225:         # GH8846
  226:         # size property should be defined
  227: 
  228:         o = construct(frame_or_series, shape=10)
  229:         assert o.size == np.prod(o.shape)
  230:         assert o.size == 10 ** len(o.axes)
  231: 
  232:     def test_split_compat(self, frame_or_series):
  233:         # xref GH8846
  234:         o = construct(frame_or_series, shape=10)
  235:         with tm.assert_produces_warning(
  236:             FutureWarning, match=".swapaxes' is deprecated", check_stacklevel=False
  237:         ):
  238:             assert len(np.array_split(o, 5)) == 5
  239:             assert len(np.array_split(o, 2)) == 2
  240: 
  241:     # See gh-12301
  242:     def test_stat_unexpected_keyword(self, frame_or_series):
  243:         obj = construct(frame_or_series, 5)
  244:         starwars = "Star Wars"
  245:         errmsg = "unexpected keyword"
  246: 
  247:         with pytest.raises(TypeError, match=errmsg):
  248:             obj.max(epic=starwars)  # stat_function
  249:         with pytest.raises(TypeError, match=errmsg):
  250:             obj.var(epic=starwars)  # stat_function_ddof
  251:         with pytest.raises(TypeError, match=errmsg):
  252:             obj.sum(epic=starwars)  # cum_function
  253:         with pytest.raises(TypeError, match=errmsg):
  254:             obj.any(epic=starwars)  # logical_function
  255: 
  256:     @pytest.mark.parametrize("func", ["sum", "cumsum", "any", "var"])
  257:     def test_api_compat(self, func, frame_or_series):
  258:         # GH 12021
  259:         # compat for __name__, __qualname__
  260: 
  261:         obj = construct(frame_or_series, 5)
  262:         f = getattr(obj, func)
  263:         assert f.__name__ == func
  264:         assert f.__qualname__.endswith(func)
  265: 
  266:     def test_stat_non_defaults_args(self, frame_or_series):
  267:         obj = construct(frame_or_series, 5)
  268:         out = np.array([0])
  269:         errmsg = "the 'out' parameter is not supported"
  270: 
  271:         with pytest.raises(ValueError, match=errmsg):
  272:             obj.max(out=out)  # stat_function
  273:         with pytest.raises(ValueError, match=errmsg):
  274:             obj.var(out=out)  # stat_function_ddof
  275:         with pytest.raises(ValueError, match=errmsg):
  276:             obj.sum(out=out)  # cum_function
  277:         with pytest.raises(ValueError, match=errmsg):
  278:             obj.any(out=out)  # logical_function
  279: 
  280:     def test_truncate_out_of_bounds(self, frame_or_series):
  281:         # GH11382
  282: 
  283:         # small
  284:         shape = [2000] + ([1] * (frame_or_series._AXIS_LEN - 1))
  285:         small = construct(frame_or_series, shape, dtype="int8", value=1)
  286:         tm.assert_equal(small.truncate(), small)
  287:         tm.assert_equal(small.truncate(before=0, after=3e3), small)
  288:         tm.assert_equal(small.truncate(before=-1, after=2e3), small)
  289: 
  290:         # big
  291:         shape = [2_000_000] + ([1] * (frame_or_series._AXIS_LEN - 1))
  292:         big = construct(frame_or_series, shape, dtype="int8", value=1)
  293:         tm.assert_equal(big.truncate(), big)
  294:         tm.assert_equal(big.truncate(before=0, after=3e6), big)
  295:         tm.assert_equal(big.truncate(before=-1, after=2e6), big)
  296: 
  297:     @pytest.mark.parametrize(
  298:         "func",
  299:         [copy, deepcopy, lambda x: x.copy(deep=False), lambda x: x.copy(deep=True)],
  300:     )
  301:     @pytest.mark.parametrize("shape", [0, 1, 2])
  302:     def test_copy_and_deepcopy(self, frame_or_series, shape, func):
  303:         # GH 15444
  304:         obj = construct(frame_or_series, shape)
  305:         obj_copy = func(obj)
  306:         assert obj_copy is not obj
  307:         tm.assert_equal(obj_copy, obj)
  308: 
  309:     def test_data_deprecated(self, frame_or_series):
  310:         obj = frame_or_series()
  311:         msg = "(Series|DataFrame)._data is deprecated"
  312:         with tm.assert_produces_warning(DeprecationWarning, match=msg):
  313:             mgr = obj._data
  314:         assert mgr is obj._mgr
  315: 
  316: 
  317: class TestNDFrame:
  318:     # tests that don't fit elsewhere
  319: 
  320:     @pytest.mark.parametrize(
  321:         "ser",
  322:         [
  323:             Series(range(10), dtype=np.float64),
  324:             Series([str(i) for i in range(10)], dtype=object),
  325:         ],
  326:     )
  327:     def test_squeeze_series_noop(self, ser):
  328:         # noop
  329:         tm.assert_series_equal(ser.squeeze(), ser)
  330: 
  331:     def test_squeeze_frame_noop(self):
  332:         # noop
  333:         df = DataFrame(np.eye(2))
  334:         tm.assert_frame_equal(df.squeeze(), df)
  335: 
  336:     def test_squeeze_frame_reindex(self):
  337:         # squeezing
  338:         df = DataFrame(
  339:             np.random.default_rng(2).standard_normal((10, 4)),
  340:             columns=Index(list("ABCD"), dtype=object),
  341:             index=date_range("2000-01-01", periods=10, freq="B"),
  342:         ).reindex(columns=["A"])
  343:         tm.assert_series_equal(df.squeeze(), df["A"])
  344: 
  345:     def test_squeeze_0_len_dim(self):
  346:         # don't fail with 0 length dimensions GH11229 & GH8999
  347:         empty_series = Series([], name="five", dtype=np.float64)
  348:         empty_frame = DataFrame([empty_series])
  349:         tm.assert_series_equal(empty_series, empty_series.squeeze())
  350:         tm.assert_series_equal(empty_series, empty_frame.squeeze())
  351: 
  352:     def test_squeeze_axis(self):
  353:         # axis argument
  354:         df = DataFrame(
  355:             np.random.default_rng(2).standard_normal((1, 4)),
  356:             columns=Index(list("ABCD"), dtype=object),
  357:             index=date_range("2000-01-01", periods=1, freq="B"),
  358:         ).iloc[:, :1]
  359:         assert df.shape == (1, 1)
  360:         tm.assert_series_equal(df.squeeze(axis=0), df.iloc[0])
  361:         tm.assert_series_equal(df.squeeze(axis="index"), df.iloc[0])
  362:         tm.assert_series_equal(df.squeeze(axis=1), df.iloc[:, 0])
  363:         tm.assert_series_equal(df.squeeze(axis="columns"), df.iloc[:, 0])
  364:         assert df.squeeze() == df.iloc[0, 0]
  365:         msg = "No axis named 2 for object type DataFrame"
  366:         with pytest.raises(ValueError, match=msg):
  367:             df.squeeze(axis=2)
  368:         msg = "No axis named x for object type DataFrame"
  369:         with pytest.raises(ValueError, match=msg):
  370:             df.squeeze(axis="x")
  371: 
  372:     def test_squeeze_axis_len_3(self):
  373:         df = DataFrame(
  374:             np.random.default_rng(2).standard_normal((3, 4)),
  375:             columns=Index(list("ABCD"), dtype=object),
  376:             index=date_range("2000-01-01", periods=3, freq="B"),
  377:         )
  378:         tm.assert_frame_equal(df.squeeze(axis=0), df)
  379: 
  380:     def test_numpy_squeeze(self):
  381:         s = Series(range(2), dtype=np.float64)
  382:         tm.assert_series_equal(np.squeeze(s), s)
  383: 
  384:         df = DataFrame(
  385:             np.random.default_rng(2).standard_normal((10, 4)),
  386:             columns=Index(list("ABCD"), dtype=object),
  387:             index=date_range("2000-01-01", periods=10, freq="B"),
  388:         ).reindex(columns=["A"])
  389:         tm.assert_series_equal(np.squeeze(df), df["A"])
  390: 
  391:     @pytest.mark.parametrize(
  392:         "ser",
  393:         [
  394:             Series(range(10), dtype=np.float64),
  395:             Series([str(i) for i in range(10)], dtype=object),
  396:         ],
  397:     )
  398:     def test_transpose_series(self, ser):
  399:         # calls implementation in pandas/core/base.py
  400:         tm.assert_series_equal(ser.transpose(), ser)
  401: 
  402:     def test_transpose_frame(self):
  403:         df = DataFrame(
  404:             np.random.default_rng(2).standard_normal((10, 4)),
  405:             columns=Index(list("ABCD"), dtype=object),
  406:             index=date_range("2000-01-01", periods=10, freq="B"),
  407:         )
  408:         tm.assert_frame_equal(df.transpose().transpose(), df)
  409: 
  410:     def test_numpy_transpose(self, frame_or_series):
  411:         obj = DataFrame(
  412:             np.random.default_rng(2).standard_normal((10, 4)),
  413:             columns=Index(list("ABCD"), dtype=object),
  414:             index=date_range("2000-01-01", periods=10, freq="B"),
  415:         )
  416:         obj = tm.get_obj(obj, frame_or_series)
  417: 
  418:         if frame_or_series is Series:
  419:             # 1D -> np.transpose is no-op
  420:             tm.assert_series_equal(np.transpose(obj), obj)
  421: 
  422:         # round-trip preserved
  423:         tm.assert_equal(np.transpose(np.transpose(obj)), obj)
  424: 
  425:         msg = "the 'axes' parameter is not supported"
  426:         with pytest.raises(ValueError, match=msg):
  427:             np.transpose(obj, axes=1)
  428: 
  429:     @pytest.mark.parametrize(
  430:         "ser",
  431:         [
  432:             Series(range(10), dtype=np.float64),
  433:             Series([str(i) for i in range(10)], dtype=object),
  434:         ],
  435:     )
  436:     def test_take_series(self, ser):
  437:         indices = [1, 5, -2, 6, 3, -1]
  438:         out = ser.take(indices)
  439:         expected = Series(
  440:             data=ser.values.take(indices),
  441:             index=ser.index.take(indices),
  442:             dtype=ser.dtype,
  443:         )
  444:         tm.assert_series_equal(out, expected)
  445: 
  446:     def test_take_frame(self):
  447:         indices = [1, 5, -2, 6, 3, -1]
  448:         df = DataFrame(
  449:             np.random.default_rng(2).standard_normal((10, 4)),
  450:             columns=Index(list("ABCD"), dtype=object),
  451:             index=date_range("2000-01-01", periods=10, freq="B"),
  452:         )
  453:         out = df.take(indices)
  454:         expected = DataFrame(
  455:             data=df.values.take(indices, axis=0),
  456:             index=df.index.take(indices),
  457:             columns=df.columns,
  458:         )
  459:         tm.assert_frame_equal(out, expected)
  460: 
  461:     def test_take_invalid_kwargs(self, frame_or_series):
  462:         indices = [-3, 2, 0, 1]
  463: 
  464:         obj = DataFrame(range(5))
  465:         obj = tm.get_obj(obj, frame_or_series)
  466: 
  467:         msg = r"take\(\) got an unexpected keyword argument 'foo'"
  468:         with pytest.raises(TypeError, match=msg):
  469:             obj.take(indices, foo=2)
  470: 
  471:         msg = "the 'out' parameter is not supported"
  472:         with pytest.raises(ValueError, match=msg):
  473:             obj.take(indices, out=indices)
  474: 
  475:         msg = "the 'mode' parameter is not supported"
  476:         with pytest.raises(ValueError, match=msg):
  477:             obj.take(indices, mode="clip")
  478: 
  479:     def test_axis_classmethods(self, frame_or_series):
  480:         box = frame_or_series
  481:         obj = box(dtype=object)
  482:         values = box._AXIS_TO_AXIS_NUMBER.keys()
  483:         for v in values:
  484:             assert obj._get_axis_number(v) == box._get_axis_number(v)
  485:             assert obj._get_axis_name(v) == box._get_axis_name(v)
  486:             assert obj._get_block_manager_axis(v) == box._get_block_manager_axis(v)
  487: 
  488:     def test_flags_identity(self, frame_or_series):
  489:         obj = Series([1, 2])
  490:         if frame_or_series is DataFrame:
  491:             obj = obj.to_frame()
  492: 
  493:         assert obj.flags is obj.flags
  494:         obj2 = obj.copy()
  495:         assert obj2.flags is not obj.flags
  496: 
  497:     def test_bool_dep(self) -> None:
  498:         # GH-51749
  499:         msg_warn = (
  500:             "DataFrame.bool is now deprecated and will be removed "
  501:             "in future version of pandas"
  502:         )
  503:         with tm.assert_produces_warning(FutureWarning, match=msg_warn):
  504:             DataFrame({"col": [False]}).bool()
