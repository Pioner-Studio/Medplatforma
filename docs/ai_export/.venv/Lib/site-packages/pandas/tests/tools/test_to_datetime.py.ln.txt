    1: """ test to_datetime """
    2: 
    3: import calendar
    4: from collections import deque
    5: from datetime import (
    6:     date,
    7:     datetime,
    8:     timedelta,
    9:     timezone,
   10: )
   11: from decimal import Decimal
   12: import locale
   13: 
   14: from dateutil.parser import parse
   15: from dateutil.tz.tz import tzoffset
   16: import numpy as np
   17: import pytest
   18: import pytz
   19: 
   20: from pandas._libs import tslib
   21: from pandas._libs.tslibs import (
   22:     iNaT,
   23:     parsing,
   24: )
   25: from pandas.errors import (
   26:     OutOfBoundsDatetime,
   27:     OutOfBoundsTimedelta,
   28: )
   29: import pandas.util._test_decorators as td
   30: 
   31: from pandas.core.dtypes.common import is_datetime64_ns_dtype
   32: 
   33: import pandas as pd
   34: from pandas import (
   35:     DataFrame,
   36:     DatetimeIndex,
   37:     Index,
   38:     NaT,
   39:     Series,
   40:     Timestamp,
   41:     date_range,
   42:     isna,
   43:     to_datetime,
   44: )
   45: import pandas._testing as tm
   46: from pandas.core.arrays import DatetimeArray
   47: from pandas.core.tools import datetimes as tools
   48: from pandas.core.tools.datetimes import start_caching_at
   49: 
   50: PARSING_ERR_MSG = (
   51:     r"You might want to try:\n"
   52:     r"    - passing `format` if your strings have a consistent format;\n"
   53:     r"    - passing `format=\'ISO8601\'` if your strings are all ISO8601 "
   54:     r"but not necessarily in exactly the same format;\n"
   55:     r"    - passing `format=\'mixed\'`, and the format will be inferred "
   56:     r"for each element individually. You might want to use `dayfirst` "
   57:     r"alongside this."
   58: )
   59: 
   60: pytestmark = pytest.mark.filterwarnings(
   61:     "ignore:errors='ignore' is deprecated:FutureWarning"
   62: )
   63: 
   64: 
   65: @pytest.fixture(params=[True, False])
   66: def cache(request):
   67:     """
   68:     cache keyword to pass to to_datetime.
   69:     """
   70:     return request.param
   71: 
   72: 
   73: class TestTimeConversionFormats:
   74:     @pytest.mark.parametrize("readonly", [True, False])
   75:     def test_to_datetime_readonly(self, readonly):
   76:         # GH#34857
   77:         arr = np.array([], dtype=object)
   78:         if readonly:
   79:             arr.setflags(write=False)
   80:         result = to_datetime(arr)
   81:         expected = to_datetime([])
   82:         tm.assert_index_equal(result, expected)
   83: 
   84:     @pytest.mark.parametrize(
   85:         "format, expected",
   86:         [
   87:             [
   88:                 "%d/%m/%Y",
   89:                 [Timestamp("20000101"), Timestamp("20000201"), Timestamp("20000301")],
   90:             ],
   91:             [
   92:                 "%m/%d/%Y",
   93:                 [Timestamp("20000101"), Timestamp("20000102"), Timestamp("20000103")],
   94:             ],
   95:         ],
   96:     )
   97:     def test_to_datetime_format(self, cache, index_or_series, format, expected):
   98:         values = index_or_series(["1/1/2000", "1/2/2000", "1/3/2000"])
   99:         result = to_datetime(values, format=format, cache=cache)
  100:         expected = index_or_series(expected)
  101:         tm.assert_equal(result, expected)
  102: 
  103:     @pytest.mark.parametrize(
  104:         "arg, expected, format",
  105:         [
  106:             ["1/1/2000", "20000101", "%d/%m/%Y"],
  107:             ["1/1/2000", "20000101", "%m/%d/%Y"],
  108:             ["1/2/2000", "20000201", "%d/%m/%Y"],
  109:             ["1/2/2000", "20000102", "%m/%d/%Y"],
  110:             ["1/3/2000", "20000301", "%d/%m/%Y"],
  111:             ["1/3/2000", "20000103", "%m/%d/%Y"],
  112:         ],
  113:     )
  114:     def test_to_datetime_format_scalar(self, cache, arg, expected, format):
  115:         result = to_datetime(arg, format=format, cache=cache)
  116:         expected = Timestamp(expected)
  117:         assert result == expected
  118: 
  119:     def test_to_datetime_format_YYYYMMDD(self, cache):
  120:         ser = Series([19801222, 19801222] + [19810105] * 5)
  121:         expected = Series([Timestamp(x) for x in ser.apply(str)])
  122: 
  123:         result = to_datetime(ser, format="%Y%m%d", cache=cache)
  124:         tm.assert_series_equal(result, expected)
  125: 
  126:         result = to_datetime(ser.apply(str), format="%Y%m%d", cache=cache)
  127:         tm.assert_series_equal(result, expected)
  128: 
  129:     def test_to_datetime_format_YYYYMMDD_with_nat(self, cache):
  130:         # Explicit cast to float to explicit cast when setting np.nan
  131:         ser = Series([19801222, 19801222] + [19810105] * 5, dtype="float")
  132:         # with NaT
  133:         expected = Series(
  134:             [Timestamp("19801222"), Timestamp("19801222")] + [Timestamp("19810105")] * 5
  135:         )
  136:         expected[2] = np.nan
  137:         ser[2] = np.nan
  138: 
  139:         result = to_datetime(ser, format="%Y%m%d", cache=cache)
  140:         tm.assert_series_equal(result, expected)
  141: 
  142:         # string with NaT
  143:         ser2 = ser.apply(str)
  144:         ser2[2] = "nat"
  145:         with pytest.raises(
  146:             ValueError,
  147:             match=(
  148:                 'unconverted data remains when parsing with format "%Y%m%d": ".0", '
  149:                 "at position 0"
  150:             ),
  151:         ):
  152:             # https://github.com/pandas-dev/pandas/issues/50051
  153:             to_datetime(ser2, format="%Y%m%d", cache=cache)
  154: 
  155:     def test_to_datetime_format_YYYYMM_with_nat(self, cache):
  156:         # https://github.com/pandas-dev/pandas/issues/50237
  157:         # Explicit cast to float to explicit cast when setting np.nan
  158:         ser = Series([198012, 198012] + [198101] * 5, dtype="float")
  159:         expected = Series(
  160:             [Timestamp("19801201"), Timestamp("19801201")] + [Timestamp("19810101")] * 5
  161:         )
  162:         expected[2] = np.nan
  163:         ser[2] = np.nan
  164:         result = to_datetime(ser, format="%Y%m", cache=cache)
  165:         tm.assert_series_equal(result, expected)
  166: 
  167:     def test_to_datetime_format_YYYYMMDD_ignore(self, cache):
  168:         # coercion
  169:         # GH 7930, GH 14487
  170:         ser = Series([20121231, 20141231, 99991231])
  171:         result = to_datetime(ser, format="%Y%m%d", errors="ignore", cache=cache)
  172:         expected = Series(
  173:             [20121231, 20141231, 99991231],
  174:             dtype=object,
  175:         )
  176:         tm.assert_series_equal(result, expected)
  177: 
  178:     def test_to_datetime_format_YYYYMMDD_ignore_with_outofbounds(self, cache):
  179:         # https://github.com/pandas-dev/pandas/issues/26493
  180:         result = to_datetime(
  181:             ["15010101", "20150101", np.nan],
  182:             format="%Y%m%d",
  183:             errors="ignore",
  184:             cache=cache,
  185:         )
  186:         expected = Index(["15010101", "20150101", np.nan], dtype=object)
  187:         tm.assert_index_equal(result, expected)
  188: 
  189:     def test_to_datetime_format_YYYYMMDD_coercion(self, cache):
  190:         # coercion
  191:         # GH 7930
  192:         ser = Series([20121231, 20141231, 99991231])
  193:         result = to_datetime(ser, format="%Y%m%d", errors="coerce", cache=cache)
  194:         expected = Series(["20121231", "20141231", "NaT"], dtype="M8[ns]")
  195:         tm.assert_series_equal(result, expected)
  196: 
  197:     @pytest.mark.parametrize(
  198:         "input_s",
  199:         [
  200:             # Null values with Strings
  201:             ["19801222", "20010112", None],
  202:             ["19801222", "20010112", np.nan],
  203:             ["19801222", "20010112", NaT],
  204:             ["19801222", "20010112", "NaT"],
  205:             # Null values with Integers
  206:             [19801222, 20010112, None],
  207:             [19801222, 20010112, np.nan],
  208:             [19801222, 20010112, NaT],
  209:             [19801222, 20010112, "NaT"],
  210:         ],
  211:     )
  212:     def test_to_datetime_format_YYYYMMDD_with_none(self, input_s):
  213:         # GH 30011
  214:         # format='%Y%m%d'
  215:         # with None
  216:         expected = Series([Timestamp("19801222"), Timestamp("20010112"), NaT])
  217:         result = Series(to_datetime(input_s, format="%Y%m%d"))
  218:         tm.assert_series_equal(result, expected)
  219: 
  220:     @pytest.mark.parametrize(
  221:         "input_s, expected",
  222:         [
  223:             # NaN before strings with invalid date values
  224:             [
  225:                 Series(["19801222", np.nan, "20010012", "10019999"]),
  226:                 Series([Timestamp("19801222"), np.nan, np.nan, np.nan]),
  227:             ],
  228:             # NaN after strings with invalid date values
  229:             [
  230:                 Series(["19801222", "20010012", "10019999", np.nan]),
  231:                 Series([Timestamp("19801222"), np.nan, np.nan, np.nan]),
  232:             ],
  233:             # NaN before integers with invalid date values
  234:             [
  235:                 Series([20190813, np.nan, 20010012, 20019999]),
  236:                 Series([Timestamp("20190813"), np.nan, np.nan, np.nan]),
  237:             ],
  238:             # NaN after integers with invalid date values
  239:             [
  240:                 Series([20190813, 20010012, np.nan, 20019999]),
  241:                 Series([Timestamp("20190813"), np.nan, np.nan, np.nan]),
  242:             ],
  243:         ],
  244:     )
  245:     def test_to_datetime_format_YYYYMMDD_overflow(self, input_s, expected):
  246:         # GH 25512
  247:         # format='%Y%m%d', errors='coerce'
  248:         result = to_datetime(input_s, format="%Y%m%d", errors="coerce")
  249:         tm.assert_series_equal(result, expected)
  250: 
  251:     @pytest.mark.parametrize(
  252:         "data, format, expected",
  253:         [
  254:             ([pd.NA], "%Y%m%d%H%M%S", DatetimeIndex(["NaT"])),
  255:             ([pd.NA], None, DatetimeIndex(["NaT"])),
  256:             (
  257:                 [pd.NA, "20210202202020"],
  258:                 "%Y%m%d%H%M%S",
  259:                 DatetimeIndex(["NaT", "2021-02-02 20:20:20"]),
  260:             ),
  261:             (["201010", pd.NA], "%y%m%d", DatetimeIndex(["2020-10-10", "NaT"])),
  262:             (["201010", pd.NA], "%d%m%y", DatetimeIndex(["2010-10-20", "NaT"])),
  263:             ([None, np.nan, pd.NA], None, DatetimeIndex(["NaT", "NaT", "NaT"])),
  264:             ([None, np.nan, pd.NA], "%Y%m%d", DatetimeIndex(["NaT", "NaT", "NaT"])),
  265:         ],
  266:     )
  267:     def test_to_datetime_with_NA(self, data, format, expected):
  268:         # GH#42957
  269:         result = to_datetime(data, format=format)
  270:         tm.assert_index_equal(result, expected)
  271: 
  272:     def test_to_datetime_with_NA_with_warning(self):
  273:         # GH#42957
  274:         result = to_datetime(["201010", pd.NA])
  275:         expected = DatetimeIndex(["2010-10-20", "NaT"])
  276:         tm.assert_index_equal(result, expected)
  277: 
  278:     def test_to_datetime_format_integer(self, cache):
  279:         # GH 10178
  280:         ser = Series([2000, 2001, 2002])
  281:         expected = Series([Timestamp(x) for x in ser.apply(str)])
  282: 
  283:         result = to_datetime(ser, format="%Y", cache=cache)
  284:         tm.assert_series_equal(result, expected)
  285: 
  286:         ser = Series([200001, 200105, 200206])
  287:         expected = Series([Timestamp(x[:4] + "-" + x[4:]) for x in ser.apply(str)])
  288: 
  289:         result = to_datetime(ser, format="%Y%m", cache=cache)
  290:         tm.assert_series_equal(result, expected)
  291: 
  292:     @pytest.mark.parametrize(
  293:         "int_date, expected",
  294:         [
  295:             # valid date, length == 8
  296:             [20121030, datetime(2012, 10, 30)],
  297:             # short valid date, length == 6
  298:             [199934, datetime(1999, 3, 4)],
  299:             # long integer date partially parsed to datetime(2012,1,1), length > 8
  300:             [2012010101, 2012010101],
  301:             # invalid date partially parsed to datetime(2012,9,9), length == 8
  302:             [20129930, 20129930],
  303:             # short integer date partially parsed to datetime(2012,9,9), length < 8
  304:             [2012993, 2012993],
  305:             # short invalid date, length == 4
  306:             [2121, 2121],
  307:         ],
  308:     )
  309:     def test_int_to_datetime_format_YYYYMMDD_typeerror(self, int_date, expected):
  310:         # GH 26583
  311:         result = to_datetime(int_date, format="%Y%m%d", errors="ignore")
  312:         assert result == expected
  313: 
  314:     def test_to_datetime_format_microsecond(self, cache):
  315:         month_abbr = calendar.month_abbr[4]
  316:         val = f"01-{month_abbr}-2011 00:00:01.978"
  317: 
  318:         format = "%d-%b-%Y %H:%M:%S.%f"
  319:         result = to_datetime(val, format=format, cache=cache)
  320:         exp = datetime.strptime(val, format)
  321:         assert result == exp
  322: 
  323:     @pytest.mark.parametrize(
  324:         "value, format, dt",
  325:         [
  326:             ["01/10/2010 15:20", "%m/%d/%Y %H:%M", Timestamp("2010-01-10 15:20")],
  327:             ["01/10/2010 05:43", "%m/%d/%Y %I:%M", Timestamp("2010-01-10 05:43")],
  328:             [
  329:                 "01/10/2010 13:56:01",
  330:                 "%m/%d/%Y %H:%M:%S",
  331:                 Timestamp("2010-01-10 13:56:01"),
  332:             ],
  333:             # The 3 tests below are locale-dependent.
  334:             # They pass, except when the machine locale is zh_CN or it_IT .
  335:             pytest.param(
  336:                 "01/10/2010 08:14 PM",
  337:                 "%m/%d/%Y %I:%M %p",
  338:                 Timestamp("2010-01-10 20:14"),
  339:                 marks=pytest.mark.xfail(
  340:                     locale.getlocale()[0] in ("zh_CN", "it_IT"),
  341:                     reason="fail on a CI build with LC_ALL=zh_CN.utf8/it_IT.utf8",
  342:                     strict=False,
  343:                 ),
  344:             ),
  345:             pytest.param(
  346:                 "01/10/2010 07:40 AM",
  347:                 "%m/%d/%Y %I:%M %p",
  348:                 Timestamp("2010-01-10 07:40"),
  349:                 marks=pytest.mark.xfail(
  350:                     locale.getlocale()[0] in ("zh_CN", "it_IT"),
  351:                     reason="fail on a CI build with LC_ALL=zh_CN.utf8/it_IT.utf8",
  352:                     strict=False,
  353:                 ),
  354:             ),
  355:             pytest.param(
  356:                 "01/10/2010 09:12:56 AM",
  357:                 "%m/%d/%Y %I:%M:%S %p",
  358:                 Timestamp("2010-01-10 09:12:56"),
  359:                 marks=pytest.mark.xfail(
  360:                     locale.getlocale()[0] in ("zh_CN", "it_IT"),
  361:                     reason="fail on a CI build with LC_ALL=zh_CN.utf8/it_IT.utf8",
  362:                     strict=False,
  363:                 ),
  364:             ),
  365:         ],
  366:     )
  367:     def test_to_datetime_format_time(self, cache, value, format, dt):
  368:         assert to_datetime(value, format=format, cache=cache) == dt
  369: 
  370:     @td.skip_if_not_us_locale
  371:     def test_to_datetime_with_non_exact(self, cache):
  372:         # GH 10834
  373:         # 8904
  374:         # exact kw
  375:         ser = Series(
  376:             ["19MAY11", "foobar19MAY11", "19MAY11:00:00:00", "19MAY11 00:00:00Z"]
  377:         )
  378:         result = to_datetime(ser, format="%d%b%y", exact=False, cache=cache)
  379:         expected = to_datetime(
  380:             ser.str.extract(r"(\d+\w+\d+)", expand=False), format="%d%b%y", cache=cache
  381:         )
  382:         tm.assert_series_equal(result, expected)
  383: 
  384:     @pytest.mark.parametrize(
  385:         "format, expected",
  386:         [
  387:             ("%Y-%m-%d", Timestamp(2000, 1, 3)),
  388:             ("%Y-%d-%m", Timestamp(2000, 3, 1)),
  389:             ("%Y-%m-%d %H", Timestamp(2000, 1, 3, 12)),
  390:             ("%Y-%d-%m %H", Timestamp(2000, 3, 1, 12)),
  391:             ("%Y-%m-%d %H:%M", Timestamp(2000, 1, 3, 12, 34)),
  392:             ("%Y-%d-%m %H:%M", Timestamp(2000, 3, 1, 12, 34)),
  393:             ("%Y-%m-%d %H:%M:%S", Timestamp(2000, 1, 3, 12, 34, 56)),
  394:             ("%Y-%d-%m %H:%M:%S", Timestamp(2000, 3, 1, 12, 34, 56)),
  395:             ("%Y-%m-%d %H:%M:%S.%f", Timestamp(2000, 1, 3, 12, 34, 56, 123456)),
  396:             ("%Y-%d-%m %H:%M:%S.%f", Timestamp(2000, 3, 1, 12, 34, 56, 123456)),
  397:             (
  398:                 "%Y-%m-%d %H:%M:%S.%f%z",
  399:                 Timestamp(2000, 1, 3, 12, 34, 56, 123456, tz="UTC+01:00"),
  400:             ),
  401:             (
  402:                 "%Y-%d-%m %H:%M:%S.%f%z",
  403:                 Timestamp(2000, 3, 1, 12, 34, 56, 123456, tz="UTC+01:00"),
  404:             ),
  405:         ],
  406:     )
  407:     def test_non_exact_doesnt_parse_whole_string(self, cache, format, expected):
  408:         # https://github.com/pandas-dev/pandas/issues/50412
  409:         # the formats alternate between ISO8601 and non-ISO8601 to check both paths
  410:         result = to_datetime(
  411:             "2000-01-03 12:34:56.123456+01:00", format=format, exact=False
  412:         )
  413:         assert result == expected
  414: 
  415:     @pytest.mark.parametrize(
  416:         "arg",
  417:         [
  418:             "2012-01-01 09:00:00.000000001",
  419:             "2012-01-01 09:00:00.000001",
  420:             "2012-01-01 09:00:00.001",
  421:             "2012-01-01 09:00:00.001000",
  422:             "2012-01-01 09:00:00.001000000",
  423:         ],
  424:     )
  425:     def test_parse_nanoseconds_with_formula(self, cache, arg):
  426:         # GH8989
  427:         # truncating the nanoseconds when a format was provided
  428:         expected = to_datetime(arg, cache=cache)
  429:         result = to_datetime(arg, format="%Y-%m-%d %H:%M:%S.%f", cache=cache)
  430:         assert result == expected
  431: 
  432:     @pytest.mark.parametrize(
  433:         "value,fmt,expected",
  434:         [
  435:             ["2009324", "%Y%W%w", Timestamp("2009-08-13")],
  436:             ["2013020", "%Y%U%w", Timestamp("2013-01-13")],
  437:         ],
  438:     )
  439:     def test_to_datetime_format_weeks(self, value, fmt, expected, cache):
  440:         assert to_datetime(value, format=fmt, cache=cache) == expected
  441: 
  442:     @pytest.mark.parametrize(
  443:         "fmt,dates,expected_dates",
  444:         [
  445:             [
  446:                 "%Y-%m-%d %H:%M:%S %Z",
  447:                 ["2010-01-01 12:00:00 UTC"] * 2,
  448:                 [Timestamp("2010-01-01 12:00:00", tz="UTC")] * 2,
  449:             ],
  450:             [
  451:                 "%Y-%m-%d %H:%M:%S%z",
  452:                 ["2010-01-01 12:00:00+0100"] * 2,
  453:                 [
  454:                     Timestamp(
  455:                         "2010-01-01 12:00:00", tzinfo=timezone(timedelta(minutes=60))
  456:                     )
  457:                 ]
  458:                 * 2,
  459:             ],
  460:             [
  461:                 "%Y-%m-%d %H:%M:%S %z",
  462:                 ["2010-01-01 12:00:00 +0100"] * 2,
  463:                 [
  464:                     Timestamp(
  465:                         "2010-01-01 12:00:00", tzinfo=timezone(timedelta(minutes=60))
  466:                     )
  467:                 ]
  468:                 * 2,
  469:             ],
  470:             [
  471:                 "%Y-%m-%d %H:%M:%S %z",
  472:                 ["2010-01-01 12:00:00 Z", "2010-01-01 12:00:00 Z"],
  473:                 [
  474:                     Timestamp(
  475:                         "2010-01-01 12:00:00", tzinfo=pytz.FixedOffset(0)
  476:                     ),  # pytz coerces to UTC
  477:                     Timestamp("2010-01-01 12:00:00", tzinfo=pytz.FixedOffset(0)),
  478:                 ],
  479:             ],
  480:         ],
  481:     )
  482:     def test_to_datetime_parse_tzname_or_tzoffset(self, fmt, dates, expected_dates):
  483:         # GH 13486
  484:         result = to_datetime(dates, format=fmt)
  485:         expected = Index(expected_dates)
  486:         tm.assert_equal(result, expected)
  487: 
  488:     @pytest.mark.parametrize(
  489:         "fmt,dates,expected_dates",
  490:         [
  491:             [
  492:                 "%Y-%m-%d %H:%M:%S %Z",
  493:                 [
  494:                     "2010-01-01 12:00:00 UTC",
  495:                     "2010-01-01 12:00:00 GMT",
  496:                     "2010-01-01 12:00:00 US/Pacific",
  497:                 ],
  498:                 [
  499:                     Timestamp("2010-01-01 12:00:00", tz="UTC"),
  500:                     Timestamp("2010-01-01 12:00:00", tz="GMT"),
  501:                     Timestamp("2010-01-01 12:00:00", tz="US/Pacific"),
  502:                 ],
  503:             ],
  504:             [
  505:                 "%Y-%m-%d %H:%M:%S %z",
  506:                 ["2010-01-01 12:00:00 +0100", "2010-01-01 12:00:00 -0100"],
  507:                 [
  508:                     Timestamp(
  509:                         "2010-01-01 12:00:00", tzinfo=timezone(timedelta(minutes=60))
  510:                     ),
  511:                     Timestamp(
  512:                         "2010-01-01 12:00:00", tzinfo=timezone(timedelta(minutes=-60))
  513:                     ),
  514:                 ],
  515:             ],
  516:         ],
  517:     )
  518:     def test_to_datetime_parse_tzname_or_tzoffset_utc_false_deprecated(
  519:         self, fmt, dates, expected_dates
  520:     ):
  521:         # GH 13486, 50887
  522:         msg = "parsing datetimes with mixed time zones will raise an error"
  523:         with tm.assert_produces_warning(FutureWarning, match=msg):
  524:             result = to_datetime(dates, format=fmt)
  525:         expected = Index(expected_dates)
  526:         tm.assert_equal(result, expected)
  527: 
  528:     def test_to_datetime_parse_tzname_or_tzoffset_different_tz_to_utc(self):
  529:         # GH 32792
  530:         dates = [
  531:             "2010-01-01 12:00:00 +0100",
  532:             "2010-01-01 12:00:00 -0100",
  533:             "2010-01-01 12:00:00 +0300",
  534:             "2010-01-01 12:00:00 +0400",
  535:         ]
  536:         expected_dates = [
  537:             "2010-01-01 11:00:00+00:00",
  538:             "2010-01-01 13:00:00+00:00",
  539:             "2010-01-01 09:00:00+00:00",
  540:             "2010-01-01 08:00:00+00:00",
  541:         ]
  542:         fmt = "%Y-%m-%d %H:%M:%S %z"
  543: 
  544:         result = to_datetime(dates, format=fmt, utc=True)
  545:         expected = DatetimeIndex(expected_dates)
  546:         tm.assert_index_equal(result, expected)
  547: 
  548:     @pytest.mark.parametrize(
  549:         "offset", ["+0", "-1foo", "UTCbar", ":10", "+01:000:01", ""]
  550:     )
  551:     def test_to_datetime_parse_timezone_malformed(self, offset):
  552:         fmt = "%Y-%m-%d %H:%M:%S %z"
  553:         date = "2010-01-01 12:00:00 " + offset
  554: 
  555:         msg = "|".join(
  556:             [
  557:                 r'^time data ".*" doesn\'t match format ".*", at position 0. '
  558:                 f"{PARSING_ERR_MSG}$",
  559:                 r'^unconverted data remains when parsing with format ".*": ".*", '
  560:                 f"at position 0. {PARSING_ERR_MSG}$",
  561:             ]
  562:         )
  563:         with pytest.raises(ValueError, match=msg):
  564:             to_datetime([date], format=fmt)
  565: 
  566:     def test_to_datetime_parse_timezone_keeps_name(self):
  567:         # GH 21697
  568:         fmt = "%Y-%m-%d %H:%M:%S %z"
  569:         arg = Index(["2010-01-01 12:00:00 Z"], name="foo")
  570:         result = to_datetime(arg, format=fmt)
  571:         expected = DatetimeIndex(["2010-01-01 12:00:00"], tz="UTC", name="foo")
  572:         tm.assert_index_equal(result, expected)
  573: 
  574: 
  575: class TestToDatetime:
  576:     @pytest.mark.filterwarnings("ignore:Could not infer format")
  577:     def test_to_datetime_overflow(self):
  578:         # we should get an OutOfBoundsDatetime, NOT OverflowError
  579:         # TODO: Timestamp raises ValueError("could not convert string to Timestamp")
  580:         #  can we make these more consistent?
  581:         arg = "08335394550"
  582:         msg = 'Parsing "08335394550" to datetime overflows, at position 0'
  583:         with pytest.raises(OutOfBoundsDatetime, match=msg):
  584:             to_datetime(arg)
  585: 
  586:         with pytest.raises(OutOfBoundsDatetime, match=msg):
  587:             to_datetime([arg])
  588: 
  589:         res = to_datetime(arg, errors="coerce")
  590:         assert res is NaT
  591:         res = to_datetime([arg], errors="coerce")
  592:         tm.assert_index_equal(res, Index([NaT]))
  593: 
  594:         res = to_datetime(arg, errors="ignore")
  595:         assert isinstance(res, str) and res == arg
  596:         res = to_datetime([arg], errors="ignore")
  597:         tm.assert_index_equal(res, Index([arg], dtype=object))
  598: 
  599:     def test_to_datetime_mixed_datetime_and_string(self):
  600:         # GH#47018 adapted old doctest with new behavior
  601:         d1 = datetime(2020, 1, 1, 17, tzinfo=timezone(-timedelta(hours=1)))
  602:         d2 = datetime(2020, 1, 1, 18, tzinfo=timezone(-timedelta(hours=1)))
  603:         res = to_datetime(["2020-01-01 17:00 -0100", d2])
  604:         expected = to_datetime([d1, d2]).tz_convert(timezone(timedelta(minutes=-60)))
  605:         tm.assert_index_equal(res, expected)
  606: 
  607:     def test_to_datetime_mixed_string_and_numeric(self):
  608:         # GH#55780 np.array(vals) would incorrectly cast the number to str
  609:         vals = ["2016-01-01", 0]
  610:         expected = DatetimeIndex([Timestamp(x) for x in vals])
  611:         result = to_datetime(vals, format="mixed")
  612:         result2 = to_datetime(vals[::-1], format="mixed")[::-1]
  613:         result3 = DatetimeIndex(vals)
  614:         result4 = DatetimeIndex(vals[::-1])[::-1]
  615: 
  616:         tm.assert_index_equal(result, expected)
  617:         tm.assert_index_equal(result2, expected)
  618:         tm.assert_index_equal(result3, expected)
  619:         tm.assert_index_equal(result4, expected)
  620: 
  621:     @pytest.mark.parametrize(
  622:         "format", ["%Y-%m-%d", "%Y-%d-%m"], ids=["ISO8601", "non-ISO8601"]
  623:     )
  624:     def test_to_datetime_mixed_date_and_string(self, format):
  625:         # https://github.com/pandas-dev/pandas/issues/50108
  626:         d1 = date(2020, 1, 2)
  627:         res = to_datetime(["2020-01-01", d1], format=format)
  628:         expected = DatetimeIndex(["2020-01-01", "2020-01-02"], dtype="M8[ns]")
  629:         tm.assert_index_equal(res, expected)
  630: 
  631:     @pytest.mark.parametrize(
  632:         "fmt",
  633:         ["%Y-%d-%m %H:%M:%S%z", "%Y-%m-%d %H:%M:%S%z"],
  634:         ids=["non-ISO8601 format", "ISO8601 format"],
  635:     )
  636:     @pytest.mark.parametrize(
  637:         "utc, args, expected",
  638:         [
  639:             pytest.param(
  640:                 True,
  641:                 ["2000-01-01 01:00:00-08:00", "2000-01-01 02:00:00-08:00"],
  642:                 DatetimeIndex(
  643:                     ["2000-01-01 09:00:00+00:00", "2000-01-01 10:00:00+00:00"],
  644:                     dtype="datetime64[ns, UTC]",
  645:                 ),
  646:                 id="all tz-aware, with utc",
  647:             ),
  648:             pytest.param(
  649:                 False,
  650:                 ["2000-01-01 01:00:00+00:00", "2000-01-01 02:00:00+00:00"],
  651:                 DatetimeIndex(
  652:                     ["2000-01-01 01:00:00+00:00", "2000-01-01 02:00:00+00:00"],
  653:                 ),
  654:                 id="all tz-aware, without utc",
  655:             ),
  656:             pytest.param(
  657:                 True,
  658:                 ["2000-01-01 01:00:00-08:00", "2000-01-01 02:00:00+00:00"],
  659:                 DatetimeIndex(
  660:                     ["2000-01-01 09:00:00+00:00", "2000-01-01 02:00:00+00:00"],
  661:                     dtype="datetime64[ns, UTC]",
  662:                 ),
  663:                 id="all tz-aware, mixed offsets, with utc",
  664:             ),
  665:             pytest.param(
  666:                 True,
  667:                 ["2000-01-01 01:00:00", "2000-01-01 02:00:00+00:00"],
  668:                 DatetimeIndex(
  669:                     ["2000-01-01 01:00:00+00:00", "2000-01-01 02:00:00+00:00"],
  670:                     dtype="datetime64[ns, UTC]",
  671:                 ),
  672:                 id="tz-aware string, naive pydatetime, with utc",
  673:             ),
  674:         ],
  675:     )
  676:     @pytest.mark.parametrize(
  677:         "constructor",
  678:         [Timestamp, lambda x: Timestamp(x).to_pydatetime()],
  679:     )
  680:     def test_to_datetime_mixed_datetime_and_string_with_format(
  681:         self, fmt, utc, args, expected, constructor
  682:     ):
  683:         # https://github.com/pandas-dev/pandas/issues/49298
  684:         # https://github.com/pandas-dev/pandas/issues/50254
  685:         # note: ISO8601 formats go down a fastpath, so we need to check both
  686:         # a ISO8601 format and a non-ISO8601 one
  687:         ts1 = constructor(args[0])
  688:         ts2 = args[1]
  689:         result = to_datetime([ts1, ts2], format=fmt, utc=utc)
  690:         tm.assert_index_equal(result, expected)
  691: 
  692:     @pytest.mark.parametrize(
  693:         "fmt",
  694:         ["%Y-%d-%m %H:%M:%S%z", "%Y-%m-%d %H:%M:%S%z"],
  695:         ids=["non-ISO8601 format", "ISO8601 format"],
  696:     )
  697:     @pytest.mark.parametrize(
  698:         "constructor",
  699:         [Timestamp, lambda x: Timestamp(x).to_pydatetime()],
  700:     )
  701:     def test_to_datetime_mixed_datetime_and_string_with_format_mixed_offsets_utc_false(
  702:         self, fmt, constructor
  703:     ):
  704:         # https://github.com/pandas-dev/pandas/issues/49298
  705:         # https://github.com/pandas-dev/pandas/issues/50254
  706:         # note: ISO8601 formats go down a fastpath, so we need to check both
  707:         # a ISO8601 format and a non-ISO8601 one
  708:         args = ["2000-01-01 01:00:00", "2000-01-01 02:00:00+00:00"]
  709:         ts1 = constructor(args[0])
  710:         ts2 = args[1]
  711:         msg = "parsing datetimes with mixed time zones will raise an error"
  712: 
  713:         expected = Index(
  714:             [
  715:                 Timestamp("2000-01-01 01:00:00"),
  716:                 Timestamp("2000-01-01 02:00:00+0000", tz="UTC"),
  717:             ],
  718:         )
  719:         with tm.assert_produces_warning(FutureWarning, match=msg):
  720:             result = to_datetime([ts1, ts2], format=fmt, utc=False)
  721:         tm.assert_index_equal(result, expected)
  722: 
  723:     @pytest.mark.parametrize(
  724:         "fmt, expected",
  725:         [
  726:             pytest.param(
  727:                 "%Y-%m-%d %H:%M:%S%z",
  728:                 Index(
  729:                     [
  730:                         Timestamp("2000-01-01 09:00:00+0100", tz="UTC+01:00"),
  731:                         Timestamp("2000-01-02 02:00:00+0200", tz="UTC+02:00"),
  732:                         NaT,
  733:                     ]
  734:                 ),
  735:                 id="ISO8601, non-UTC",
  736:             ),
  737:             pytest.param(
  738:                 "%Y-%d-%m %H:%M:%S%z",
  739:                 Index(
  740:                     [
  741:                         Timestamp("2000-01-01 09:00:00+0100", tz="UTC+01:00"),
  742:                         Timestamp("2000-02-01 02:00:00+0200", tz="UTC+02:00"),
  743:                         NaT,
  744:                     ]
  745:                 ),
  746:                 id="non-ISO8601, non-UTC",
  747:             ),
  748:         ],
  749:     )
  750:     def test_to_datetime_mixed_offsets_with_none_tz(self, fmt, expected):
  751:         # https://github.com/pandas-dev/pandas/issues/50071
  752:         msg = "parsing datetimes with mixed time zones will raise an error"
  753: 
  754:         with tm.assert_produces_warning(FutureWarning, match=msg):
  755:             result = to_datetime(
  756:                 ["2000-01-01 09:00:00+01:00", "2000-01-02 02:00:00+02:00", None],
  757:                 format=fmt,
  758:                 utc=False,
  759:             )
  760:         tm.assert_index_equal(result, expected)
  761: 
  762:     @pytest.mark.parametrize(
  763:         "fmt, expected",
  764:         [
  765:             pytest.param(
  766:                 "%Y-%m-%d %H:%M:%S%z",
  767:                 DatetimeIndex(
  768:                     ["2000-01-01 08:00:00+00:00", "2000-01-02 00:00:00+00:00", "NaT"],
  769:                     dtype="datetime64[ns, UTC]",
  770:                 ),
  771:                 id="ISO8601, UTC",
  772:             ),
  773:             pytest.param(
  774:                 "%Y-%d-%m %H:%M:%S%z",
  775:                 DatetimeIndex(
  776:                     ["2000-01-01 08:00:00+00:00", "2000-02-01 00:00:00+00:00", "NaT"],
  777:                     dtype="datetime64[ns, UTC]",
  778:                 ),
  779:                 id="non-ISO8601, UTC",
  780:             ),
  781:         ],
  782:     )
  783:     def test_to_datetime_mixed_offsets_with_none(self, fmt, expected):
  784:         # https://github.com/pandas-dev/pandas/issues/50071
  785:         result = to_datetime(
  786:             ["2000-01-01 09:00:00+01:00", "2000-01-02 02:00:00+02:00", None],
  787:             format=fmt,
  788:             utc=True,
  789:         )
  790:         tm.assert_index_equal(result, expected)
  791: 
  792:     @pytest.mark.parametrize(
  793:         "fmt",
  794:         ["%Y-%d-%m %H:%M:%S%z", "%Y-%m-%d %H:%M:%S%z"],
  795:         ids=["non-ISO8601 format", "ISO8601 format"],
  796:     )
  797:     @pytest.mark.parametrize(
  798:         "args",
  799:         [
  800:             pytest.param(
  801:                 ["2000-01-01 01:00:00-08:00", "2000-01-01 02:00:00-07:00"],
  802:                 id="all tz-aware, mixed timezones, without utc",
  803:             ),
  804:         ],
  805:     )
  806:     @pytest.mark.parametrize(
  807:         "constructor",
  808:         [Timestamp, lambda x: Timestamp(x).to_pydatetime()],
  809:     )
  810:     def test_to_datetime_mixed_datetime_and_string_with_format_raises(
  811:         self, fmt, args, constructor
  812:     ):
  813:         # https://github.com/pandas-dev/pandas/issues/49298
  814:         # note: ISO8601 formats go down a fastpath, so we need to check both
  815:         # a ISO8601 format and a non-ISO8601 one
  816:         ts1 = constructor(args[0])
  817:         ts2 = constructor(args[1])
  818:         with pytest.raises(
  819:             ValueError, match="cannot be converted to datetime64 unless utc=True"
  820:         ):
  821:             to_datetime([ts1, ts2], format=fmt, utc=False)
  822: 
  823:     def test_to_datetime_np_str(self):
  824:         # GH#32264
  825:         # GH#48969
  826:         value = np.str_("2019-02-04 10:18:46.297000+0000")
  827: 
  828:         ser = Series([value])
  829: 
  830:         exp = Timestamp("2019-02-04 10:18:46.297000", tz="UTC")
  831: 
  832:         assert to_datetime(value) == exp
  833:         assert to_datetime(ser.iloc[0]) == exp
  834: 
  835:         res = to_datetime([value])
  836:         expected = Index([exp])
  837:         tm.assert_index_equal(res, expected)
  838: 
  839:         res = to_datetime(ser)
  840:         expected = Series(expected)
  841:         tm.assert_series_equal(res, expected)
  842: 
  843:     @pytest.mark.parametrize(
  844:         "s, _format, dt",
  845:         [
  846:             ["2015-1-1", "%G-%V-%u", datetime(2014, 12, 29, 0, 0)],
  847:             ["2015-1-4", "%G-%V-%u", datetime(2015, 1, 1, 0, 0)],
  848:             ["2015-1-7", "%G-%V-%u", datetime(2015, 1, 4, 0, 0)],
  849:         ],
  850:     )
  851:     def test_to_datetime_iso_week_year_format(self, s, _format, dt):
  852:         # See GH#16607
  853:         assert to_datetime(s, format=_format) == dt
  854: 
  855:     @pytest.mark.parametrize(
  856:         "msg, s, _format",
  857:         [
  858:             [
  859:                 "ISO week directive '%V' is incompatible with the year directive "
  860:                 "'%Y'. Use the ISO year '%G' instead.",
  861:                 "1999 50",
  862:                 "%Y %V",
  863:             ],
  864:             [
  865:                 "ISO year directive '%G' must be used with the ISO week directive "
  866:                 "'%V' and a weekday directive '%A', '%a', '%w', or '%u'.",
  867:                 "1999 51",
  868:                 "%G %V",
  869:             ],
  870:             [
  871:                 "ISO year directive '%G' must be used with the ISO week directive "
  872:                 "'%V' and a weekday directive '%A', '%a', '%w', or '%u'.",
  873:                 "1999 Monday",
  874:                 "%G %A",
  875:             ],
  876:             [
  877:                 "ISO year directive '%G' must be used with the ISO week directive "
  878:                 "'%V' and a weekday directive '%A', '%a', '%w', or '%u'.",
  879:                 "1999 Mon",
  880:                 "%G %a",
  881:             ],
  882:             [
  883:                 "ISO year directive '%G' must be used with the ISO week directive "
  884:                 "'%V' and a weekday directive '%A', '%a', '%w', or '%u'.",
  885:                 "1999 6",
  886:                 "%G %w",
  887:             ],
  888:             [
  889:                 "ISO year directive '%G' must be used with the ISO week directive "
  890:                 "'%V' and a weekday directive '%A', '%a', '%w', or '%u'.",
  891:                 "1999 6",
  892:                 "%G %u",
  893:             ],
  894:             [
  895:                 "ISO year directive '%G' must be used with the ISO week directive "
  896:                 "'%V' and a weekday directive '%A', '%a', '%w', or '%u'.",
  897:                 "2051",
  898:                 "%G",
  899:             ],
  900:             [
  901:                 "Day of the year directive '%j' is not compatible with ISO year "
  902:                 "directive '%G'. Use '%Y' instead.",
  903:                 "1999 51 6 256",
  904:                 "%G %V %u %j",
  905:             ],
  906:             [
  907:                 "ISO week directive '%V' is incompatible with the year directive "
  908:                 "'%Y'. Use the ISO year '%G' instead.",
  909:                 "1999 51 Sunday",
  910:                 "%Y %V %A",
  911:             ],
  912:             [
  913:                 "ISO week directive '%V' is incompatible with the year directive "
  914:                 "'%Y'. Use the ISO year '%G' instead.",
  915:                 "1999 51 Sun",
  916:                 "%Y %V %a",
  917:             ],
  918:             [
  919:                 "ISO week directive '%V' is incompatible with the year directive "
  920:                 "'%Y'. Use the ISO year '%G' instead.",
  921:                 "1999 51 1",
  922:                 "%Y %V %w",
  923:             ],
  924:             [
  925:                 "ISO week directive '%V' is incompatible with the year directive "
  926:                 "'%Y'. Use the ISO year '%G' instead.",
  927:                 "1999 51 1",
  928:                 "%Y %V %u",
  929:             ],
  930:             [
  931:                 "ISO week directive '%V' must be used with the ISO year directive "
  932:                 "'%G' and a weekday directive '%A', '%a', '%w', or '%u'.",
  933:                 "20",
  934:                 "%V",
  935:             ],
  936:             [
  937:                 "ISO week directive '%V' must be used with the ISO year directive "
  938:                 "'%G' and a weekday directive '%A', '%a', '%w', or '%u'.",
  939:                 "1999 51 Sunday",
  940:                 "%V %A",
  941:             ],
  942:             [
  943:                 "ISO week directive '%V' must be used with the ISO year directive "
  944:                 "'%G' and a weekday directive '%A', '%a', '%w', or '%u'.",
  945:                 "1999 51 Sun",
  946:                 "%V %a",
  947:             ],
  948:             [
  949:                 "ISO week directive '%V' must be used with the ISO year directive "
  950:                 "'%G' and a weekday directive '%A', '%a', '%w', or '%u'.",
  951:                 "1999 51 1",
  952:                 "%V %w",
  953:             ],
  954:             [
  955:                 "ISO week directive '%V' must be used with the ISO year directive "
  956:                 "'%G' and a weekday directive '%A', '%a', '%w', or '%u'.",
  957:                 "1999 51 1",
  958:                 "%V %u",
  959:             ],
  960:             [
  961:                 "Day of the year directive '%j' is not compatible with ISO year "
  962:                 "directive '%G'. Use '%Y' instead.",
  963:                 "1999 50",
  964:                 "%G %j",
  965:             ],
  966:             [
  967:                 "ISO week directive '%V' must be used with the ISO year directive "
  968:                 "'%G' and a weekday directive '%A', '%a', '%w', or '%u'.",
  969:                 "20 Monday",
  970:                 "%V %A",
  971:             ],
  972:         ],
  973:     )
  974:     @pytest.mark.parametrize("errors", ["raise", "coerce", "ignore"])
  975:     def test_error_iso_week_year(self, msg, s, _format, errors):
  976:         # See GH#16607, GH#50308
  977:         # This test checks for errors thrown when giving the wrong format
  978:         # However, as discussed on PR#25541, overriding the locale
  979:         # causes a different error to be thrown due to the format being
  980:         # locale specific, but the test data is in english.
  981:         # Therefore, the tests only run when locale is not overwritten,
  982:         # as a sort of solution to this problem.
  983:         if locale.getlocale() != ("zh_CN", "UTF-8") and locale.getlocale() != (
  984:             "it_IT",
  985:             "UTF-8",
  986:         ):
  987:             with pytest.raises(ValueError, match=msg):
  988:                 to_datetime(s, format=_format, errors=errors)
  989: 
  990:     @pytest.mark.parametrize("tz", [None, "US/Central"])
  991:     def test_to_datetime_dtarr(self, tz):
  992:         # DatetimeArray
  993:         dti = date_range("1965-04-03", periods=19, freq="2W", tz=tz)
  994:         arr = dti._data
  995: 
  996:         result = to_datetime(arr)
  997:         assert result is arr
  998: 
  999:     # Doesn't work on Windows since tzpath not set correctly
 1000:     @td.skip_if_windows
 1001:     @pytest.mark.parametrize("arg_class", [Series, Index])
 1002:     @pytest.mark.parametrize("utc", [True, False])
 1003:     @pytest.mark.parametrize("tz", [None, "US/Central"])
 1004:     def test_to_datetime_arrow(self, tz, utc, arg_class):
 1005:         pa = pytest.importorskip("pyarrow")
 1006: 
 1007:         dti = date_range("1965-04-03", periods=19, freq="2W", tz=tz)
 1008:         dti = arg_class(dti)
 1009: 
 1010:         dti_arrow = dti.astype(pd.ArrowDtype(pa.timestamp(unit="ns", tz=tz)))
 1011: 
 1012:         result = to_datetime(dti_arrow, utc=utc)
 1013:         expected = to_datetime(dti, utc=utc).astype(
 1014:             pd.ArrowDtype(pa.timestamp(unit="ns", tz=tz if not utc else "UTC"))
 1015:         )
 1016:         if not utc and arg_class is not Series:
 1017:             # Doesn't hold for utc=True, since that will astype
 1018:             # to_datetime also returns a new object for series
 1019:             assert result is dti_arrow
 1020:         if arg_class is Series:
 1021:             tm.assert_series_equal(result, expected)
 1022:         else:
 1023:             tm.assert_index_equal(result, expected)
 1024: 
 1025:     def test_to_datetime_pydatetime(self):
 1026:         actual = to_datetime(datetime(2008, 1, 15))
 1027:         assert actual == datetime(2008, 1, 15)
 1028: 
 1029:     def test_to_datetime_YYYYMMDD(self):
 1030:         actual = to_datetime("20080115")
 1031:         assert actual == datetime(2008, 1, 15)
 1032: 
 1033:     def test_to_datetime_unparsable_ignore(self):
 1034:         # unparsable
 1035:         ser = "Month 1, 1999"
 1036:         assert to_datetime(ser, errors="ignore") == ser
 1037: 
 1038:     @td.skip_if_windows  # `tm.set_timezone` does not work in windows
 1039:     def test_to_datetime_now(self):
 1040:         # See GH#18666
 1041:         with tm.set_timezone("US/Eastern"):
 1042:             # GH#18705
 1043:             now = Timestamp("now").as_unit("ns")
 1044:             pdnow = to_datetime("now")
 1045:             pdnow2 = to_datetime(["now"])[0]
 1046: 
 1047:             # These should all be equal with infinite perf; this gives
 1048:             # a generous margin of 10 seconds
 1049:             assert abs(pdnow._value - now._value) < 1e10
 1050:             assert abs(pdnow2._value - now._value) < 1e10
 1051: 
 1052:             assert pdnow.tzinfo is None
 1053:             assert pdnow2.tzinfo is None
 1054: 
 1055:     @td.skip_if_windows  # `tm.set_timezone` does not work in windows
 1056:     @pytest.mark.parametrize("tz", ["Pacific/Auckland", "US/Samoa"])
 1057:     def test_to_datetime_today(self, tz):
 1058:         # See GH#18666
 1059:         # Test with one timezone far ahead of UTC and another far behind, so
 1060:         # one of these will _almost_ always be in a different day from UTC.
 1061:         # Unfortunately this test between 12 and 1 AM Samoa time
 1062:         # this both of these timezones _and_ UTC will all be in the same day,
 1063:         # so this test will not detect the regression introduced in #18666.
 1064:         with tm.set_timezone(tz):
 1065:             nptoday = np.datetime64("today").astype("datetime64[ns]").astype(np.int64)
 1066:             pdtoday = to_datetime("today")
 1067:             pdtoday2 = to_datetime(["today"])[0]
 1068: 
 1069:             tstoday = Timestamp("today").as_unit("ns")
 1070:             tstoday2 = Timestamp.today().as_unit("ns")
 1071: 
 1072:             # These should all be equal with infinite perf; this gives
 1073:             # a generous margin of 10 seconds
 1074:             assert abs(pdtoday.normalize()._value - nptoday) < 1e10
 1075:             assert abs(pdtoday2.normalize()._value - nptoday) < 1e10
 1076:             assert abs(pdtoday._value - tstoday._value) < 1e10
 1077:             assert abs(pdtoday._value - tstoday2._value) < 1e10
 1078: 
 1079:             assert pdtoday.tzinfo is None
 1080:             assert pdtoday2.tzinfo is None
 1081: 
 1082:     @pytest.mark.parametrize("arg", ["now", "today"])
 1083:     def test_to_datetime_today_now_unicode_bytes(self, arg):
 1084:         to_datetime([arg])
 1085: 
 1086:     @pytest.mark.parametrize(
 1087:         "format, expected_ds",
 1088:         [
 1089:             ("%Y-%m-%d %H:%M:%S%z", "2020-01-03"),
 1090:             ("%Y-%d-%m %H:%M:%S%z", "2020-03-01"),
 1091:             (None, "2020-01-03"),
 1092:         ],
 1093:     )
 1094:     @pytest.mark.parametrize(
 1095:         "string, attribute",
 1096:         [
 1097:             ("now", "utcnow"),
 1098:             ("today", "today"),
 1099:         ],
 1100:     )
 1101:     def test_to_datetime_now_with_format(self, format, expected_ds, string, attribute):
 1102:         # https://github.com/pandas-dev/pandas/issues/50359
 1103:         result = to_datetime(["2020-01-03 00:00:00Z", string], format=format, utc=True)
 1104:         expected = DatetimeIndex(
 1105:             [expected_ds, getattr(Timestamp, attribute)()], dtype="datetime64[ns, UTC]"
 1106:         )
 1107:         assert (expected - result).max().total_seconds() < 1
 1108: 
 1109:     @pytest.mark.parametrize(
 1110:         "dt", [np.datetime64("2000-01-01"), np.datetime64("2000-01-02")]
 1111:     )
 1112:     def test_to_datetime_dt64s(self, cache, dt):
 1113:         assert to_datetime(dt, cache=cache) == Timestamp(dt)
 1114: 
 1115:     @pytest.mark.parametrize(
 1116:         "arg, format",
 1117:         [
 1118:             ("2001-01-01", "%Y-%m-%d"),
 1119:             ("01-01-2001", "%d-%m-%Y"),
 1120:         ],
 1121:     )
 1122:     def test_to_datetime_dt64s_and_str(self, arg, format):
 1123:         # https://github.com/pandas-dev/pandas/issues/50036
 1124:         result = to_datetime([arg, np.datetime64("2020-01-01")], format=format)
 1125:         expected = DatetimeIndex(["2001-01-01", "2020-01-01"])
 1126:         tm.assert_index_equal(result, expected)
 1127: 
 1128:     @pytest.mark.parametrize(
 1129:         "dt", [np.datetime64("1000-01-01"), np.datetime64("5000-01-02")]
 1130:     )
 1131:     @pytest.mark.parametrize("errors", ["raise", "ignore", "coerce"])
 1132:     def test_to_datetime_dt64s_out_of_ns_bounds(self, cache, dt, errors):
 1133:         # GH#50369 We cast to the nearest supported reso, i.e. "s"
 1134:         ts = to_datetime(dt, errors=errors, cache=cache)
 1135:         assert isinstance(ts, Timestamp)
 1136:         assert ts.unit == "s"
 1137:         assert ts.asm8 == dt
 1138: 
 1139:         ts = Timestamp(dt)
 1140:         assert ts.unit == "s"
 1141:         assert ts.asm8 == dt
 1142: 
 1143:     @pytest.mark.skip_ubsan
 1144:     def test_to_datetime_dt64d_out_of_bounds(self, cache):
 1145:         dt64 = np.datetime64(np.iinfo(np.int64).max, "D")
 1146: 
 1147:         msg = "Out of bounds second timestamp: 25252734927768524-07-27"
 1148:         with pytest.raises(OutOfBoundsDatetime, match=msg):
 1149:             Timestamp(dt64)
 1150:         with pytest.raises(OutOfBoundsDatetime, match=msg):
 1151:             to_datetime(dt64, errors="raise", cache=cache)
 1152: 
 1153:         assert to_datetime(dt64, errors="coerce", cache=cache) is NaT
 1154: 
 1155:     @pytest.mark.parametrize("unit", ["s", "D"])
 1156:     def test_to_datetime_array_of_dt64s(self, cache, unit):
 1157:         # https://github.com/pandas-dev/pandas/issues/31491
 1158:         # Need at least 50 to ensure cache is used.
 1159:         dts = [
 1160:             np.datetime64("2000-01-01", unit),
 1161:             np.datetime64("2000-01-02", unit),
 1162:         ] * 30
 1163:         # Assuming all datetimes are in bounds, to_datetime() returns
 1164:         # an array that is equal to Timestamp() parsing
 1165:         result = to_datetime(dts, cache=cache)
 1166:         if cache:
 1167:             # FIXME: behavior should not depend on cache
 1168:             expected = DatetimeIndex([Timestamp(x).asm8 for x in dts], dtype="M8[s]")
 1169:         else:
 1170:             expected = DatetimeIndex([Timestamp(x).asm8 for x in dts], dtype="M8[ns]")
 1171: 
 1172:         tm.assert_index_equal(result, expected)
 1173: 
 1174:         # A list of datetimes where the last one is out of bounds
 1175:         dts_with_oob = dts + [np.datetime64("9999-01-01")]
 1176: 
 1177:         # As of GH#51978 we do not raise in this case
 1178:         to_datetime(dts_with_oob, errors="raise")
 1179: 
 1180:         result = to_datetime(dts_with_oob, errors="coerce", cache=cache)
 1181:         if not cache:
 1182:             # FIXME: shouldn't depend on cache!
 1183:             expected = DatetimeIndex(
 1184:                 [Timestamp(dts_with_oob[0]).asm8, Timestamp(dts_with_oob[1]).asm8] * 30
 1185:                 + [NaT],
 1186:             )
 1187:         else:
 1188:             expected = DatetimeIndex(np.array(dts_with_oob, dtype="M8[s]"))
 1189:         tm.assert_index_equal(result, expected)
 1190: 
 1191:         # With errors='ignore', out of bounds datetime64s
 1192:         # are converted to their .item(), which depending on the version of
 1193:         # numpy is either a python datetime.datetime or datetime.date
 1194:         result = to_datetime(dts_with_oob, errors="ignore", cache=cache)
 1195:         if not cache:
 1196:             # FIXME: shouldn't depend on cache!
 1197:             expected = Index(dts_with_oob)
 1198:         tm.assert_index_equal(result, expected)
 1199: 
 1200:     def test_out_of_bounds_errors_ignore(self):
 1201:         # https://github.com/pandas-dev/pandas/issues/50587
 1202:         result = to_datetime(np.datetime64("9999-01-01"), errors="ignore")
 1203:         expected = np.datetime64("9999-01-01")
 1204:         assert result == expected
 1205: 
 1206:     def test_out_of_bounds_errors_ignore2(self):
 1207:         # GH#12424
 1208:         msg = "errors='ignore' is deprecated"
 1209:         with tm.assert_produces_warning(FutureWarning, match=msg):
 1210:             res = to_datetime(
 1211:                 Series(["2362-01-01", np.nan], dtype=object), errors="ignore"
 1212:             )
 1213:         exp = Series(["2362-01-01", np.nan], dtype=object)
 1214:         tm.assert_series_equal(res, exp)
 1215: 
 1216:     def test_to_datetime_tz(self, cache):
 1217:         # xref 8260
 1218:         # uniform returns a DatetimeIndex
 1219:         arr = [
 1220:             Timestamp("2013-01-01 13:00:00-0800", tz="US/Pacific"),
 1221:             Timestamp("2013-01-02 14:00:00-0800", tz="US/Pacific"),
 1222:         ]
 1223:         result = to_datetime(arr, cache=cache)
 1224:         expected = DatetimeIndex(
 1225:             ["2013-01-01 13:00:00", "2013-01-02 14:00:00"], tz="US/Pacific"
 1226:         )
 1227:         tm.assert_index_equal(result, expected)
 1228: 
 1229:     def test_to_datetime_tz_mixed(self, cache):
 1230:         # mixed tzs will raise if errors='raise'
 1231:         # https://github.com/pandas-dev/pandas/issues/50585
 1232:         arr = [
 1233:             Timestamp("2013-01-01 13:00:00", tz="US/Pacific"),
 1234:             Timestamp("2013-01-02 14:00:00", tz="US/Eastern"),
 1235:         ]
 1236:         msg = (
 1237:             "Tz-aware datetime.datetime cannot be "
 1238:             "converted to datetime64 unless utc=True"
 1239:         )
 1240:         with pytest.raises(ValueError, match=msg):
 1241:             to_datetime(arr, cache=cache)
 1242: 
 1243:         depr_msg = "errors='ignore' is deprecated"
 1244:         with tm.assert_produces_warning(FutureWarning, match=depr_msg):
 1245:             result = to_datetime(arr, cache=cache, errors="ignore")
 1246:         expected = Index(
 1247:             [
 1248:                 Timestamp("2013-01-01 13:00:00-08:00"),
 1249:                 Timestamp("2013-01-02 14:00:00-05:00"),
 1250:             ],
 1251:             dtype="object",
 1252:         )
 1253:         tm.assert_index_equal(result, expected)
 1254:         result = to_datetime(arr, cache=cache, errors="coerce")
 1255:         expected = DatetimeIndex(
 1256:             ["2013-01-01 13:00:00-08:00", "NaT"], dtype="datetime64[ns, US/Pacific]"
 1257:         )
 1258:         tm.assert_index_equal(result, expected)
 1259: 
 1260:     def test_to_datetime_different_offsets(self, cache):
 1261:         # inspired by asv timeseries.ToDatetimeNONISO8601 benchmark
 1262:         # see GH-26097 for more
 1263:         ts_string_1 = "March 1, 2018 12:00:00+0400"
 1264:         ts_string_2 = "March 1, 2018 12:00:00+0500"
 1265:         arr = [ts_string_1] * 5 + [ts_string_2] * 5
 1266:         expected = Index([parse(x) for x in arr])
 1267:         msg = "parsing datetimes with mixed time zones will raise an error"
 1268:         with tm.assert_produces_warning(FutureWarning, match=msg):
 1269:             result = to_datetime(arr, cache=cache)
 1270:         tm.assert_index_equal(result, expected)
 1271: 
 1272:     def test_to_datetime_tz_pytz(self, cache):
 1273:         # see gh-8260
 1274:         us_eastern = pytz.timezone("US/Eastern")
 1275:         arr = np.array(
 1276:             [
 1277:                 us_eastern.localize(
 1278:                     datetime(year=2000, month=1, day=1, hour=3, minute=0)
 1279:                 ),
 1280:                 us_eastern.localize(
 1281:                     datetime(year=2000, month=6, day=1, hour=3, minute=0)
 1282:                 ),
 1283:             ],
 1284:             dtype=object,
 1285:         )
 1286:         result = to_datetime(arr, utc=True, cache=cache)
 1287:         expected = DatetimeIndex(
 1288:             ["2000-01-01 08:00:00+00:00", "2000-06-01 07:00:00+00:00"],
 1289:             dtype="datetime64[ns, UTC]",
 1290:             freq=None,
 1291:         )
 1292:         tm.assert_index_equal(result, expected)
 1293: 
 1294:     @pytest.mark.parametrize(
 1295:         "init_constructor, end_constructor",
 1296:         [
 1297:             (Index, DatetimeIndex),
 1298:             (list, DatetimeIndex),
 1299:             (np.array, DatetimeIndex),
 1300:             (Series, Series),
 1301:         ],
 1302:     )
 1303:     def test_to_datetime_utc_true(self, cache, init_constructor, end_constructor):
 1304:         # See gh-11934 & gh-6415
 1305:         data = ["20100102 121314", "20100102 121315"]
 1306:         expected_data = [
 1307:             Timestamp("2010-01-02 12:13:14", tz="utc"),
 1308:             Timestamp("2010-01-02 12:13:15", tz="utc"),
 1309:         ]
 1310: 
 1311:         result = to_datetime(
 1312:             init_constructor(data), format="%Y%m%d %H%M%S", utc=True, cache=cache
 1313:         )
 1314:         expected = end_constructor(expected_data)
 1315:         tm.assert_equal(result, expected)
 1316: 
 1317:     @pytest.mark.parametrize(
 1318:         "scalar, expected",
 1319:         [
 1320:             ["20100102 121314", Timestamp("2010-01-02 12:13:14", tz="utc")],
 1321:             ["20100102 121315", Timestamp("2010-01-02 12:13:15", tz="utc")],
 1322:         ],
 1323:     )
 1324:     def test_to_datetime_utc_true_scalar(self, cache, scalar, expected):
 1325:         # Test scalar case as well
 1326:         result = to_datetime(scalar, format="%Y%m%d %H%M%S", utc=True, cache=cache)
 1327:         assert result == expected
 1328: 
 1329:     def test_to_datetime_utc_true_with_series_single_value(self, cache):
 1330:         # GH 15760 UTC=True with Series
 1331:         ts = 1.5e18
 1332:         result = to_datetime(Series([ts]), utc=True, cache=cache)
 1333:         expected = Series([Timestamp(ts, tz="utc")])
 1334:         tm.assert_series_equal(result, expected)
 1335: 
 1336:     def test_to_datetime_utc_true_with_series_tzaware_string(self, cache):
 1337:         ts = "2013-01-01 00:00:00-01:00"
 1338:         expected_ts = "2013-01-01 01:00:00"
 1339:         data = Series([ts] * 3)
 1340:         result = to_datetime(data, utc=True, cache=cache)
 1341:         expected = Series([Timestamp(expected_ts, tz="utc")] * 3)
 1342:         tm.assert_series_equal(result, expected)
 1343: 
 1344:     @pytest.mark.parametrize(
 1345:         "date, dtype",
 1346:         [
 1347:             ("2013-01-01 01:00:00", "datetime64[ns]"),
 1348:             ("2013-01-01 01:00:00", "datetime64[ns, UTC]"),
 1349:         ],
 1350:     )
 1351:     def test_to_datetime_utc_true_with_series_datetime_ns(self, cache, date, dtype):
 1352:         expected = Series(
 1353:             [Timestamp("2013-01-01 01:00:00", tz="UTC")], dtype="M8[ns, UTC]"
 1354:         )
 1355:         result = to_datetime(Series([date], dtype=dtype), utc=True, cache=cache)
 1356:         tm.assert_series_equal(result, expected)
 1357: 
 1358:     def test_to_datetime_tz_psycopg2(self, request, cache):
 1359:         # xref 8260
 1360:         psycopg2_tz = pytest.importorskip("psycopg2.tz")
 1361: 
 1362:         # misc cases
 1363:         tz1 = psycopg2_tz.FixedOffsetTimezone(offset=-300, name=None)
 1364:         tz2 = psycopg2_tz.FixedOffsetTimezone(offset=-240, name=None)
 1365:         arr = np.array(
 1366:             [
 1367:                 datetime(2000, 1, 1, 3, 0, tzinfo=tz1),
 1368:                 datetime(2000, 6, 1, 3, 0, tzinfo=tz2),
 1369:             ],
 1370:             dtype=object,
 1371:         )
 1372: 
 1373:         result = to_datetime(arr, errors="coerce", utc=True, cache=cache)
 1374:         expected = DatetimeIndex(
 1375:             ["2000-01-01 08:00:00+00:00", "2000-06-01 07:00:00+00:00"],
 1376:             dtype="datetime64[ns, UTC]",
 1377:             freq=None,
 1378:         )
 1379:         tm.assert_index_equal(result, expected)
 1380: 
 1381:         # dtype coercion
 1382:         i = DatetimeIndex(
 1383:             ["2000-01-01 08:00:00"],
 1384:             tz=psycopg2_tz.FixedOffsetTimezone(offset=-300, name=None),
 1385:         )
 1386:         assert is_datetime64_ns_dtype(i)
 1387: 
 1388:         # tz coercion
 1389:         result = to_datetime(i, errors="coerce", cache=cache)
 1390:         tm.assert_index_equal(result, i)
 1391: 
 1392:         result = to_datetime(i, errors="coerce", utc=True, cache=cache)
 1393:         expected = DatetimeIndex(["2000-01-01 13:00:00"], dtype="datetime64[ns, UTC]")
 1394:         tm.assert_index_equal(result, expected)
 1395: 
 1396:     @pytest.mark.parametrize("arg", [True, False])
 1397:     def test_datetime_bool(self, cache, arg):
 1398:         # GH13176
 1399:         msg = r"dtype bool cannot be converted to datetime64\[ns\]"
 1400:         with pytest.raises(TypeError, match=msg):
 1401:             to_datetime(arg)
 1402:         assert to_datetime(arg, errors="coerce", cache=cache) is NaT
 1403:         assert to_datetime(arg, errors="ignore", cache=cache) is arg
 1404: 
 1405:     def test_datetime_bool_arrays_mixed(self, cache):
 1406:         msg = f"{type(cache)} is not convertible to datetime"
 1407:         with pytest.raises(TypeError, match=msg):
 1408:             to_datetime([False, datetime.today()], cache=cache)
 1409:         with pytest.raises(
 1410:             ValueError,
 1411:             match=(
 1412:                 r'^time data "True" doesn\'t match format "%Y%m%d", '
 1413:                 f"at position 1. {PARSING_ERR_MSG}$"
 1414:             ),
 1415:         ):
 1416:             to_datetime(["20130101", True], cache=cache)
 1417:         tm.assert_index_equal(
 1418:             to_datetime([0, False, NaT, 0.0], errors="coerce", cache=cache),
 1419:             DatetimeIndex(
 1420:                 [to_datetime(0, cache=cache), NaT, NaT, to_datetime(0, cache=cache)]
 1421:             ),
 1422:         )
 1423: 
 1424:     @pytest.mark.parametrize("arg", [bool, to_datetime])
 1425:     def test_datetime_invalid_datatype(self, arg):
 1426:         # GH13176
 1427:         msg = "is not convertible to datetime"
 1428:         with pytest.raises(TypeError, match=msg):
 1429:             to_datetime(arg)
 1430: 
 1431:     @pytest.mark.parametrize("errors", ["coerce", "raise", "ignore"])
 1432:     def test_invalid_format_raises(self, errors):
 1433:         # https://github.com/pandas-dev/pandas/issues/50255
 1434:         with pytest.raises(
 1435:             ValueError, match="':' is a bad directive in format 'H%:M%:S%"
 1436:         ):
 1437:             to_datetime(["00:00:00"], format="H%:M%:S%", errors=errors)
 1438: 
 1439:     @pytest.mark.parametrize("value", ["a", "00:01:99"])
 1440:     @pytest.mark.parametrize("format", [None, "%H:%M:%S"])
 1441:     def test_datetime_invalid_scalar(self, value, format):
 1442:         # GH24763
 1443:         res = to_datetime(value, errors="ignore", format=format)
 1444:         assert res == value
 1445: 
 1446:         res = to_datetime(value, errors="coerce", format=format)
 1447:         assert res is NaT
 1448: 
 1449:         msg = "|".join(
 1450:             [
 1451:                 r'^time data "a" doesn\'t match format "%H:%M:%S", at position 0. '
 1452:                 f"{PARSING_ERR_MSG}$",
 1453:                 r'^Given date string "a" not likely a datetime, at position 0$',
 1454:                 r'^unconverted data remains when parsing with format "%H:%M:%S": "9", '
 1455:                 f"at position 0. {PARSING_ERR_MSG}$",
 1456:                 r"^second must be in 0..59: 00:01:99, at position 0$",
 1457:             ]
 1458:         )
 1459:         with pytest.raises(ValueError, match=msg):
 1460:             to_datetime(value, errors="raise", format=format)
 1461: 
 1462:     @pytest.mark.parametrize("value", ["3000/12/11 00:00:00"])
 1463:     @pytest.mark.parametrize("format", [None, "%H:%M:%S"])
 1464:     def test_datetime_outofbounds_scalar(self, value, format):
 1465:         # GH24763
 1466:         res = to_datetime(value, errors="ignore", format=format)
 1467:         assert res == value
 1468: 
 1469:         res = to_datetime(value, errors="coerce", format=format)
 1470:         assert res is NaT
 1471: 
 1472:         if format is not None:
 1473:             msg = r'^time data ".*" doesn\'t match format ".*", at position 0.'
 1474:             with pytest.raises(ValueError, match=msg):
 1475:                 to_datetime(value, errors="raise", format=format)
 1476:         else:
 1477:             msg = "^Out of bounds .*, at position 0$"
 1478:             with pytest.raises(OutOfBoundsDatetime, match=msg):
 1479:                 to_datetime(value, errors="raise", format=format)
 1480: 
 1481:     @pytest.mark.parametrize(
 1482:         ("values"), [(["a"]), (["00:01:99"]), (["a", "b", "99:00:00"])]
 1483:     )
 1484:     @pytest.mark.parametrize("format", [(None), ("%H:%M:%S")])
 1485:     def test_datetime_invalid_index(self, values, format):
 1486:         # GH24763
 1487:         # Not great to have logic in tests, but this one's hard to
 1488:         # parametrise over
 1489:         if format is None and len(values) > 1:
 1490:             warn = UserWarning
 1491:         else:
 1492:             warn = None
 1493:         with tm.assert_produces_warning(
 1494:             warn, match="Could not infer format", raise_on_extra_warnings=False
 1495:         ):
 1496:             res = to_datetime(values, errors="ignore", format=format)
 1497:         tm.assert_index_equal(res, Index(values, dtype=object))
 1498: 
 1499:         with tm.assert_produces_warning(
 1500:             warn, match="Could not infer format", raise_on_extra_warnings=False
 1501:         ):
 1502:             res = to_datetime(values, errors="coerce", format=format)
 1503:         tm.assert_index_equal(res, DatetimeIndex([NaT] * len(values)))
 1504: 
 1505:         msg = "|".join(
 1506:             [
 1507:                 r'^Given date string "a" not likely a datetime, at position 0$',
 1508:                 r'^time data "a" doesn\'t match format "%H:%M:%S", at position 0. '
 1509:                 f"{PARSING_ERR_MSG}$",
 1510:                 r'^unconverted data remains when parsing with format "%H:%M:%S": "9", '
 1511:                 f"at position 0. {PARSING_ERR_MSG}$",
 1512:                 r"^second must be in 0..59: 00:01:99, at position 0$",
 1513:             ]
 1514:         )
 1515:         with pytest.raises(ValueError, match=msg):
 1516:             with tm.assert_produces_warning(
 1517:                 warn, match="Could not infer format", raise_on_extra_warnings=False
 1518:             ):
 1519:                 to_datetime(values, errors="raise", format=format)
 1520: 
 1521:     @pytest.mark.parametrize("utc", [True, None])
 1522:     @pytest.mark.parametrize("format", ["%Y%m%d %H:%M:%S", None])
 1523:     @pytest.mark.parametrize("constructor", [list, tuple, np.array, Index, deque])
 1524:     def test_to_datetime_cache(self, utc, format, constructor):
 1525:         date = "20130101 00:00:00"
 1526:         test_dates = [date] * 10**5
 1527:         data = constructor(test_dates)
 1528: 
 1529:         result = to_datetime(data, utc=utc, format=format, cache=True)
 1530:         expected = to_datetime(data, utc=utc, format=format, cache=False)
 1531: 
 1532:         tm.assert_index_equal(result, expected)
 1533: 
 1534:     def test_to_datetime_from_deque(self):
 1535:         # GH 29403
 1536:         result = to_datetime(deque([Timestamp("2010-06-02 09:30:00")] * 51))
 1537:         expected = to_datetime([Timestamp("2010-06-02 09:30:00")] * 51)
 1538:         tm.assert_index_equal(result, expected)
 1539: 
 1540:     @pytest.mark.parametrize("utc", [True, None])
 1541:     @pytest.mark.parametrize("format", ["%Y%m%d %H:%M:%S", None])
 1542:     def test_to_datetime_cache_series(self, utc, format):
 1543:         date = "20130101 00:00:00"
 1544:         test_dates = [date] * 10**5
 1545:         data = Series(test_dates)
 1546:         result = to_datetime(data, utc=utc, format=format, cache=True)
 1547:         expected = to_datetime(data, utc=utc, format=format, cache=False)
 1548:         tm.assert_series_equal(result, expected)
 1549: 
 1550:     def test_to_datetime_cache_scalar(self):
 1551:         date = "20130101 00:00:00"
 1552:         result = to_datetime(date, cache=True)
 1553:         expected = Timestamp("20130101 00:00:00")
 1554:         assert result == expected
 1555: 
 1556:     @pytest.mark.parametrize(
 1557:         "datetimelikes,expected_values",
 1558:         (
 1559:             (
 1560:                 (None, np.nan) + (NaT,) * start_caching_at,
 1561:                 (NaT,) * (start_caching_at + 2),
 1562:             ),
 1563:             (
 1564:                 (None, Timestamp("2012-07-26")) + (NaT,) * start_caching_at,
 1565:                 (NaT, Timestamp("2012-07-26")) + (NaT,) * start_caching_at,
 1566:             ),
 1567:             (
 1568:                 (None,)
 1569:                 + (NaT,) * start_caching_at
 1570:                 + ("2012 July 26", Timestamp("2012-07-26")),
 1571:                 (NaT,) * (start_caching_at + 1)
 1572:                 + (Timestamp("2012-07-26"), Timestamp("2012-07-26")),
 1573:             ),
 1574:         ),
 1575:     )
 1576:     def test_convert_object_to_datetime_with_cache(
 1577:         self, datetimelikes, expected_values
 1578:     ):
 1579:         # GH#39882
 1580:         ser = Series(
 1581:             datetimelikes,
 1582:             dtype="object",
 1583:         )
 1584:         result_series = to_datetime(ser, errors="coerce")
 1585:         expected_series = Series(
 1586:             expected_values,
 1587:             dtype="datetime64[ns]",
 1588:         )
 1589:         tm.assert_series_equal(result_series, expected_series)
 1590: 
 1591:     @pytest.mark.parametrize("cache", [True, False])
 1592:     @pytest.mark.parametrize(
 1593:         "input",
 1594:         [
 1595:             Series([NaT] * 20 + [None] * 20, dtype="object"),
 1596:             Series([NaT] * 60 + [None] * 60, dtype="object"),
 1597:             Series([None] * 20),
 1598:             Series([None] * 60),
 1599:             Series([""] * 20),
 1600:             Series([""] * 60),
 1601:             Series([pd.NA] * 20),
 1602:             Series([pd.NA] * 60),
 1603:             Series([np.nan] * 20),
 1604:             Series([np.nan] * 60),
 1605:         ],
 1606:     )
 1607:     def test_to_datetime_converts_null_like_to_nat(self, cache, input):
 1608:         # GH35888
 1609:         expected = Series([NaT] * len(input), dtype="M8[ns]")
 1610:         result = to_datetime(input, cache=cache)
 1611:         tm.assert_series_equal(result, expected)
 1612: 
 1613:     @pytest.mark.parametrize(
 1614:         "date, format",
 1615:         [
 1616:             ("2017-20", "%Y-%W"),
 1617:             ("20 Sunday", "%W %A"),
 1618:             ("20 Sun", "%W %a"),
 1619:             ("2017-21", "%Y-%U"),
 1620:             ("20 Sunday", "%U %A"),
 1621:             ("20 Sun", "%U %a"),
 1622:         ],
 1623:     )
 1624:     def test_week_without_day_and_calendar_year(self, date, format):
 1625:         # GH16774
 1626: 
 1627:         msg = "Cannot use '%W' or '%U' without day and year"
 1628:         with pytest.raises(ValueError, match=msg):
 1629:             to_datetime(date, format=format)
 1630: 
 1631:     def test_to_datetime_coerce(self):
 1632:         # GH 26122
 1633:         ts_strings = [
 1634:             "March 1, 2018 12:00:00+0400",
 1635:             "March 1, 2018 12:00:00+0500",
 1636:             "20100240",
 1637:         ]
 1638:         msg = "parsing datetimes with mixed time zones will raise an error"
 1639:         with tm.assert_produces_warning(FutureWarning, match=msg):
 1640:             result = to_datetime(ts_strings, errors="coerce")
 1641:         expected = Index(
 1642:             [
 1643:                 datetime(2018, 3, 1, 12, 0, tzinfo=tzoffset(None, 14400)),
 1644:                 datetime(2018, 3, 1, 12, 0, tzinfo=tzoffset(None, 18000)),
 1645:                 NaT,
 1646:             ]
 1647:         )
 1648:         tm.assert_index_equal(result, expected)
 1649: 
 1650:     @pytest.mark.parametrize(
 1651:         "string_arg, format",
 1652:         [("March 1, 2018", "%B %d, %Y"), ("2018-03-01", "%Y-%m-%d")],
 1653:     )
 1654:     @pytest.mark.parametrize(
 1655:         "outofbounds",
 1656:         [
 1657:             datetime(9999, 1, 1),
 1658:             date(9999, 1, 1),
 1659:             np.datetime64("9999-01-01"),
 1660:             "January 1, 9999",
 1661:             "9999-01-01",
 1662:         ],
 1663:     )
 1664:     def test_to_datetime_coerce_oob(self, string_arg, format, outofbounds):
 1665:         # https://github.com/pandas-dev/pandas/issues/50255
 1666:         ts_strings = [string_arg, outofbounds]
 1667:         result = to_datetime(ts_strings, errors="coerce", format=format)
 1668:         expected = DatetimeIndex([datetime(2018, 3, 1), NaT])
 1669:         tm.assert_index_equal(result, expected)
 1670: 
 1671:     @pytest.mark.parametrize(
 1672:         "errors, expected",
 1673:         [
 1674:             ("coerce", Index([NaT, NaT])),
 1675:             ("ignore", Index(["200622-12-31", "111111-24-11"], dtype=object)),
 1676:         ],
 1677:     )
 1678:     def test_to_datetime_malformed_no_raise(self, errors, expected):
 1679:         # GH 28299
 1680:         # GH 48633
 1681:         ts_strings = ["200622-12-31", "111111-24-11"]
 1682:         with tm.assert_produces_warning(
 1683:             UserWarning, match="Could not infer format", raise_on_extra_warnings=False
 1684:         ):
 1685:             result = to_datetime(ts_strings, errors=errors)
 1686:         tm.assert_index_equal(result, expected)
 1687: 
 1688:     def test_to_datetime_malformed_raise(self):
 1689:         # GH 48633
 1690:         ts_strings = ["200622-12-31", "111111-24-11"]
 1691:         msg = (
 1692:             'Parsed string "200622-12-31" gives an invalid tzoffset, which must '
 1693:             r"be between -timedelta\(hours=24\) and timedelta\(hours=24\), "
 1694:             "at position 0"
 1695:         )
 1696:         with pytest.raises(
 1697:             ValueError,
 1698:             match=msg,
 1699:         ):
 1700:             with tm.assert_produces_warning(
 1701:                 UserWarning, match="Could not infer format"
 1702:             ):
 1703:                 to_datetime(
 1704:                     ts_strings,
 1705:                     errors="raise",
 1706:                 )
 1707: 
 1708:     def test_iso_8601_strings_with_same_offset(self):
 1709:         # GH 17697, 11736
 1710:         ts_str = "2015-11-18 15:30:00+05:30"
 1711:         result = to_datetime(ts_str)
 1712:         expected = Timestamp(ts_str)
 1713:         assert result == expected
 1714: 
 1715:         expected = DatetimeIndex([Timestamp(ts_str)] * 2)
 1716:         result = to_datetime([ts_str] * 2)
 1717:         tm.assert_index_equal(result, expected)
 1718: 
 1719:         result = DatetimeIndex([ts_str] * 2)
 1720:         tm.assert_index_equal(result, expected)
 1721: 
 1722:     def test_iso_8601_strings_with_different_offsets(self):
 1723:         # GH 17697, 11736, 50887
 1724:         ts_strings = ["2015-11-18 15:30:00+05:30", "2015-11-18 16:30:00+06:30", NaT]
 1725:         msg = "parsing datetimes with mixed time zones will raise an error"
 1726:         with tm.assert_produces_warning(FutureWarning, match=msg):
 1727:             result = to_datetime(ts_strings)
 1728:         expected = np.array(
 1729:             [
 1730:                 datetime(2015, 11, 18, 15, 30, tzinfo=tzoffset(None, 19800)),
 1731:                 datetime(2015, 11, 18, 16, 30, tzinfo=tzoffset(None, 23400)),
 1732:                 NaT,
 1733:             ],
 1734:             dtype=object,
 1735:         )
 1736:         # GH 21864
 1737:         expected = Index(expected)
 1738:         tm.assert_index_equal(result, expected)
 1739: 
 1740:     def test_iso_8601_strings_with_different_offsets_utc(self):
 1741:         ts_strings = ["2015-11-18 15:30:00+05:30", "2015-11-18 16:30:00+06:30", NaT]
 1742:         result = to_datetime(ts_strings, utc=True)
 1743:         expected = DatetimeIndex(
 1744:             [Timestamp(2015, 11, 18, 10), Timestamp(2015, 11, 18, 10), NaT], tz="UTC"
 1745:         )
 1746:         tm.assert_index_equal(result, expected)
 1747: 
 1748:     def test_mixed_offsets_with_native_datetime_raises(self):
 1749:         # GH 25978
 1750: 
 1751:         vals = [
 1752:             "nan",
 1753:             Timestamp("1990-01-01"),
 1754:             "2015-03-14T16:15:14.123-08:00",
 1755:             "2019-03-04T21:56:32.620-07:00",
 1756:             None,
 1757:             "today",
 1758:             "now",
 1759:         ]
 1760:         ser = Series(vals)
 1761:         assert all(ser[i] is vals[i] for i in range(len(vals)))  # GH#40111
 1762: 
 1763:         now = Timestamp("now")
 1764:         today = Timestamp("today")
 1765:         msg = "parsing datetimes with mixed time zones will raise an error"
 1766:         with tm.assert_produces_warning(FutureWarning, match=msg):
 1767:             mixed = to_datetime(ser)
 1768:         expected = Series(
 1769:             [
 1770:                 "NaT",
 1771:                 Timestamp("1990-01-01"),
 1772:                 Timestamp("2015-03-14T16:15:14.123-08:00").to_pydatetime(),
 1773:                 Timestamp("2019-03-04T21:56:32.620-07:00").to_pydatetime(),
 1774:                 None,
 1775:             ],
 1776:             dtype=object,
 1777:         )
 1778:         tm.assert_series_equal(mixed[:-2], expected)
 1779:         # we'll check mixed[-1] and mixed[-2] match now and today to within
 1780:         # call-timing tolerances
 1781:         assert (now - mixed.iloc[-1]).total_seconds() <= 0.1
 1782:         assert (today - mixed.iloc[-2]).total_seconds() <= 0.1
 1783: 
 1784:         with pytest.raises(ValueError, match="Tz-aware datetime.datetime"):
 1785:             to_datetime(mixed)
 1786: 
 1787:     def test_non_iso_strings_with_tz_offset(self):
 1788:         result = to_datetime(["March 1, 2018 12:00:00+0400"] * 2)
 1789:         expected = DatetimeIndex(
 1790:             [datetime(2018, 3, 1, 12, tzinfo=timezone(timedelta(minutes=240)))] * 2
 1791:         )
 1792:         tm.assert_index_equal(result, expected)
 1793: 
 1794:     @pytest.mark.parametrize(
 1795:         "ts, expected",
 1796:         [
 1797:             (Timestamp("2018-01-01"), Timestamp("2018-01-01", tz="UTC")),
 1798:             (
 1799:                 Timestamp("2018-01-01", tz="US/Pacific"),
 1800:                 Timestamp("2018-01-01 08:00", tz="UTC"),
 1801:             ),
 1802:         ],
 1803:     )
 1804:     def test_timestamp_utc_true(self, ts, expected):
 1805:         # GH 24415
 1806:         result = to_datetime(ts, utc=True)
 1807:         assert result == expected
 1808: 
 1809:     @pytest.mark.parametrize("dt_str", ["00010101", "13000101", "30000101", "99990101"])
 1810:     def test_to_datetime_with_format_out_of_bounds(self, dt_str):
 1811:         # GH 9107
 1812:         msg = "Out of bounds nanosecond timestamp"
 1813:         with pytest.raises(OutOfBoundsDatetime, match=msg):
 1814:             to_datetime(dt_str, format="%Y%m%d")
 1815: 
 1816:     def test_to_datetime_utc(self):
 1817:         arr = np.array([parse("2012-06-13T01:39:00Z")], dtype=object)
 1818: 
 1819:         result = to_datetime(arr, utc=True)
 1820:         assert result.tz is timezone.utc
 1821: 
 1822:     def test_to_datetime_fixed_offset(self):
 1823:         from pandas.tests.indexes.datetimes.test_timezones import FixedOffset
 1824: 
 1825:         fixed_off = FixedOffset(-420, "-07:00")
 1826: 
 1827:         dates = [
 1828:             datetime(2000, 1, 1, tzinfo=fixed_off),
 1829:             datetime(2000, 1, 2, tzinfo=fixed_off),
 1830:             datetime(2000, 1, 3, tzinfo=fixed_off),
 1831:         ]
 1832:         result = to_datetime(dates)
 1833:         assert result.tz == fixed_off
 1834: 
 1835:     @pytest.mark.parametrize(
 1836:         "date",
 1837:         [
 1838:             ["2020-10-26 00:00:00+06:00", "2020-10-26 00:00:00+01:00"],
 1839:             ["2020-10-26 00:00:00+06:00", Timestamp("2018-01-01", tz="US/Pacific")],
 1840:             [
 1841:                 "2020-10-26 00:00:00+06:00",
 1842:                 datetime(2020, 1, 1, 18, tzinfo=pytz.timezone("Australia/Melbourne")),
 1843:             ],
 1844:         ],
 1845:     )
 1846:     def test_to_datetime_mixed_offsets_with_utc_false_deprecated(self, date):
 1847:         # GH 50887
 1848:         msg = "parsing datetimes with mixed time zones will raise an error"
 1849:         with tm.assert_produces_warning(FutureWarning, match=msg):
 1850:             to_datetime(date, utc=False)
 1851: 
 1852: 
 1853: class TestToDatetimeUnit:
 1854:     @pytest.mark.parametrize("unit", ["Y", "M"])
 1855:     @pytest.mark.parametrize("item", [150, float(150)])
 1856:     def test_to_datetime_month_or_year_unit_int(self, cache, unit, item, request):
 1857:         # GH#50870 Note we have separate tests that pd.Timestamp gets these right
 1858:         ts = Timestamp(item, unit=unit)
 1859:         expected = DatetimeIndex([ts], dtype="M8[ns]")
 1860: 
 1861:         result = to_datetime([item], unit=unit, cache=cache)
 1862:         tm.assert_index_equal(result, expected)
 1863: 
 1864:         result = to_datetime(np.array([item], dtype=object), unit=unit, cache=cache)
 1865:         tm.assert_index_equal(result, expected)
 1866: 
 1867:         result = to_datetime(np.array([item]), unit=unit, cache=cache)
 1868:         tm.assert_index_equal(result, expected)
 1869: 
 1870:         # with a nan!
 1871:         result = to_datetime(np.array([item, np.nan]), unit=unit, cache=cache)
 1872:         assert result.isna()[1]
 1873:         tm.assert_index_equal(result[:1], expected)
 1874: 
 1875:     @pytest.mark.parametrize("unit", ["Y", "M"])
 1876:     def test_to_datetime_month_or_year_unit_non_round_float(self, cache, unit):
 1877:         # GH#50301
 1878:         # Match Timestamp behavior in disallowing non-round floats with
 1879:         #  Y or M unit
 1880:         warn_msg = "strings will be parsed as datetime strings"
 1881:         msg = f"Conversion of non-round float with unit={unit} is ambiguous"
 1882:         with pytest.raises(ValueError, match=msg):
 1883:             to_datetime([1.5], unit=unit, errors="raise")
 1884:         with pytest.raises(ValueError, match=msg):
 1885:             to_datetime(np.array([1.5]), unit=unit, errors="raise")
 1886:         with pytest.raises(ValueError, match=msg):
 1887:             with tm.assert_produces_warning(FutureWarning, match=warn_msg):
 1888:                 to_datetime(["1.5"], unit=unit, errors="raise")
 1889: 
 1890:         # with errors="ignore" we also end up raising within the Timestamp
 1891:         #  constructor; this may not be ideal
 1892:         with pytest.raises(ValueError, match=msg):
 1893:             to_datetime([1.5], unit=unit, errors="ignore")
 1894: 
 1895:         res = to_datetime([1.5], unit=unit, errors="coerce")
 1896:         expected = Index([NaT], dtype="M8[ns]")
 1897:         tm.assert_index_equal(res, expected)
 1898: 
 1899:         with tm.assert_produces_warning(FutureWarning, match=warn_msg):
 1900:             res = to_datetime(["1.5"], unit=unit, errors="coerce")
 1901:         tm.assert_index_equal(res, expected)
 1902: 
 1903:         # round floats are OK
 1904:         res = to_datetime([1.0], unit=unit)
 1905:         expected = to_datetime([1], unit=unit)
 1906:         tm.assert_index_equal(res, expected)
 1907: 
 1908:     def test_unit(self, cache):
 1909:         # GH 11758
 1910:         # test proper behavior with errors
 1911:         msg = "cannot specify both format and unit"
 1912:         with pytest.raises(ValueError, match=msg):
 1913:             to_datetime([1], unit="D", format="%Y%m%d", cache=cache)
 1914: 
 1915:     def test_unit_str(self, cache):
 1916:         # GH 57051
 1917:         # Test that strs aren't dropping precision to 32-bit accidentally.
 1918:         with tm.assert_produces_warning(FutureWarning):
 1919:             res = to_datetime(["1704660000"], unit="s", origin="unix")
 1920:         expected = to_datetime([1704660000], unit="s", origin="unix")
 1921:         tm.assert_index_equal(res, expected)
 1922: 
 1923:     def test_unit_array_mixed_nans(self, cache):
 1924:         values = [11111111111111111, 1, 1.0, iNaT, NaT, np.nan, "NaT", ""]
 1925:         result = to_datetime(values, unit="D", errors="ignore", cache=cache)
 1926:         expected = Index(
 1927:             [
 1928:                 11111111111111111,
 1929:                 Timestamp("1970-01-02"),
 1930:                 Timestamp("1970-01-02"),
 1931:                 NaT,
 1932:                 NaT,
 1933:                 NaT,
 1934:                 NaT,
 1935:                 NaT,
 1936:             ],
 1937:             dtype=object,
 1938:         )
 1939:         tm.assert_index_equal(result, expected)
 1940: 
 1941:         result = to_datetime(values, unit="D", errors="coerce", cache=cache)
 1942:         expected = DatetimeIndex(
 1943:             ["NaT", "1970-01-02", "1970-01-02", "NaT", "NaT", "NaT", "NaT", "NaT"],
 1944:             dtype="M8[ns]",
 1945:         )
 1946:         tm.assert_index_equal(result, expected)
 1947: 
 1948:         msg = "cannot convert input 11111111111111111 with the unit 'D'"
 1949:         with pytest.raises(OutOfBoundsDatetime, match=msg):
 1950:             to_datetime(values, unit="D", errors="raise", cache=cache)
 1951: 
 1952:     def test_unit_array_mixed_nans_large_int(self, cache):
 1953:         values = [1420043460000000000000000, iNaT, NaT, np.nan, "NaT"]
 1954: 
 1955:         result = to_datetime(values, errors="ignore", unit="s", cache=cache)
 1956:         expected = Index([1420043460000000000000000, NaT, NaT, NaT, NaT], dtype=object)
 1957:         tm.assert_index_equal(result, expected)
 1958: 
 1959:         result = to_datetime(values, errors="coerce", unit="s", cache=cache)
 1960:         expected = DatetimeIndex(["NaT", "NaT", "NaT", "NaT", "NaT"], dtype="M8[ns]")
 1961:         tm.assert_index_equal(result, expected)
 1962: 
 1963:         msg = "cannot convert input 1420043460000000000000000 with the unit 's'"
 1964:         with pytest.raises(OutOfBoundsDatetime, match=msg):
 1965:             to_datetime(values, errors="raise", unit="s", cache=cache)
 1966: 
 1967:     def test_to_datetime_invalid_str_not_out_of_bounds_valuerror(self, cache):
 1968:         # if we have a string, then we raise a ValueError
 1969:         # and NOT an OutOfBoundsDatetime
 1970:         msg = "non convertible value foo with the unit 's'"
 1971:         with pytest.raises(ValueError, match=msg):
 1972:             to_datetime("foo", errors="raise", unit="s", cache=cache)
 1973: 
 1974:     @pytest.mark.parametrize("error", ["raise", "coerce", "ignore"])
 1975:     def test_unit_consistency(self, cache, error):
 1976:         # consistency of conversions
 1977:         expected = Timestamp("1970-05-09 14:25:11")
 1978:         result = to_datetime(11111111, unit="s", errors=error, cache=cache)
 1979:         assert result == expected
 1980:         assert isinstance(result, Timestamp)
 1981: 
 1982:     @pytest.mark.parametrize("errors", ["ignore", "raise", "coerce"])
 1983:     @pytest.mark.parametrize("dtype", ["float64", "int64"])
 1984:     def test_unit_with_numeric(self, cache, errors, dtype):
 1985:         # GH 13180
 1986:         # coercions from floats/ints are ok
 1987:         expected = DatetimeIndex(
 1988:             ["2015-06-19 05:33:20", "2015-05-27 22:33:20"], dtype="M8[ns]"
 1989:         )
 1990:         arr = np.array([1.434692e18, 1.432766e18]).astype(dtype)
 1991:         result = to_datetime(arr, errors=errors, cache=cache)
 1992:         tm.assert_index_equal(result, expected)
 1993: 
 1994:     @pytest.mark.parametrize(
 1995:         "exp, arr, warning",
 1996:         [
 1997:             [
 1998:                 ["NaT", "2015-06-19 05:33:20", "2015-05-27 22:33:20"],
 1999:                 ["foo", 1.434692e18, 1.432766e18],
 2000:                 UserWarning,
 2001:             ],
 2002:             [
 2003:                 ["2015-06-19 05:33:20", "2015-05-27 22:33:20", "NaT", "NaT"],
 2004:                 [1.434692e18, 1.432766e18, "foo", "NaT"],
 2005:                 None,
 2006:             ],
 2007:         ],
 2008:     )
 2009:     def test_unit_with_numeric_coerce(self, cache, exp, arr, warning):
 2010:         # but we want to make sure that we are coercing
 2011:         # if we have ints/strings
 2012:         expected = DatetimeIndex(exp, dtype="M8[ns]")
 2013:         with tm.assert_produces_warning(warning, match="Could not infer format"):
 2014:             result = to_datetime(arr, errors="coerce", cache=cache)
 2015:         tm.assert_index_equal(result, expected)
 2016: 
 2017:     @pytest.mark.parametrize(
 2018:         "arr",
 2019:         [
 2020:             [Timestamp("20130101"), 1.434692e18, 1.432766e18],
 2021:             [1.434692e18, 1.432766e18, Timestamp("20130101")],
 2022:         ],
 2023:     )
 2024:     def test_unit_mixed(self, cache, arr):
 2025:         # GH#50453 pre-2.0 with mixed numeric/datetimes and errors="coerce"
 2026:         #  the numeric entries would be coerced to NaT, was never clear exactly
 2027:         #  why.
 2028:         # mixed integers/datetimes
 2029:         expected = Index([Timestamp(x) for x in arr], dtype="M8[ns]")
 2030:         result = to_datetime(arr, errors="coerce", cache=cache)
 2031:         tm.assert_index_equal(result, expected)
 2032: 
 2033:         # GH#49037 pre-2.0 this raised, but it always worked with Series,
 2034:         #  was never clear why it was disallowed
 2035:         result = to_datetime(arr, errors="raise", cache=cache)
 2036:         tm.assert_index_equal(result, expected)
 2037: 
 2038:         result = DatetimeIndex(arr)
 2039:         tm.assert_index_equal(result, expected)
 2040: 
 2041:     def test_unit_rounding(self, cache):
 2042:         # GH 14156 & GH 20445: argument will incur floating point errors
 2043:         # but no premature rounding
 2044:         value = 1434743731.8770001
 2045:         result = to_datetime(value, unit="s", cache=cache)
 2046:         expected = Timestamp("2015-06-19 19:55:31.877000093")
 2047:         assert result == expected
 2048: 
 2049:         alt = Timestamp(value, unit="s")
 2050:         assert alt == result
 2051: 
 2052:     def test_unit_ignore_keeps_name(self, cache):
 2053:         # GH 21697
 2054:         expected = Index([15e9] * 2, name="name")
 2055:         result = to_datetime(expected, errors="ignore", unit="s", cache=cache)
 2056:         tm.assert_index_equal(result, expected)
 2057: 
 2058:     def test_to_datetime_errors_ignore_utc_true(self):
 2059:         # GH#23758
 2060:         result = to_datetime([1], unit="s", utc=True, errors="ignore")
 2061:         expected = DatetimeIndex(["1970-01-01 00:00:01"], dtype="M8[ns, UTC]")
 2062:         tm.assert_index_equal(result, expected)
 2063: 
 2064:     @pytest.mark.parametrize("dtype", [int, float])
 2065:     def test_to_datetime_unit(self, dtype):
 2066:         epoch = 1370745748
 2067:         ser = Series([epoch + t for t in range(20)]).astype(dtype)
 2068:         result = to_datetime(ser, unit="s")
 2069:         expected = Series(
 2070:             [
 2071:                 Timestamp("2013-06-09 02:42:28") + timedelta(seconds=t)
 2072:                 for t in range(20)
 2073:             ],
 2074:             dtype="M8[ns]",
 2075:         )
 2076:         tm.assert_series_equal(result, expected)
 2077: 
 2078:     @pytest.mark.parametrize("null", [iNaT, np.nan])
 2079:     def test_to_datetime_unit_with_nulls(self, null):
 2080:         epoch = 1370745748
 2081:         ser = Series([epoch + t for t in range(20)] + [null])
 2082:         result = to_datetime(ser, unit="s")
 2083:         expected = Series(
 2084:             [Timestamp("2013-06-09 02:42:28") + timedelta(seconds=t) for t in range(20)]
 2085:             + [NaT],
 2086:             dtype="M8[ns]",
 2087:         )
 2088:         tm.assert_series_equal(result, expected)
 2089: 
 2090:     def test_to_datetime_unit_fractional_seconds(self):
 2091:         # GH13834
 2092:         epoch = 1370745748
 2093:         ser = Series([epoch + t for t in np.arange(0, 2, 0.25)] + [iNaT]).astype(float)
 2094:         result = to_datetime(ser, unit="s")
 2095:         expected = Series(
 2096:             [
 2097:                 Timestamp("2013-06-09 02:42:28") + timedelta(seconds=t)
 2098:                 for t in np.arange(0, 2, 0.25)
 2099:             ]
 2100:             + [NaT],
 2101:             dtype="M8[ns]",
 2102:         )
 2103:         # GH20455 argument will incur floating point errors but no premature rounding
 2104:         result = result.round("ms")
 2105:         tm.assert_series_equal(result, expected)
 2106: 
 2107:     def test_to_datetime_unit_na_values(self):
 2108:         result = to_datetime([1, 2, "NaT", NaT, np.nan], unit="D")
 2109:         expected = DatetimeIndex(
 2110:             [Timestamp("1970-01-02"), Timestamp("1970-01-03")] + ["NaT"] * 3,
 2111:             dtype="M8[ns]",
 2112:         )
 2113:         tm.assert_index_equal(result, expected)
 2114: 
 2115:     @pytest.mark.parametrize("bad_val", ["foo", 111111111])
 2116:     def test_to_datetime_unit_invalid(self, bad_val):
 2117:         msg = f"{bad_val} with the unit 'D'"
 2118:         with pytest.raises(ValueError, match=msg):
 2119:             to_datetime([1, 2, bad_val], unit="D")
 2120: 
 2121:     @pytest.mark.parametrize("bad_val", ["foo", 111111111])
 2122:     def test_to_timestamp_unit_coerce(self, bad_val):
 2123:         # coerce we can process
 2124:         expected = DatetimeIndex(
 2125:             [Timestamp("1970-01-02"), Timestamp("1970-01-03")] + ["NaT"] * 1,
 2126:             dtype="M8[ns]",
 2127:         )
 2128:         result = to_datetime([1, 2, bad_val], unit="D", errors="coerce")
 2129:         tm.assert_index_equal(result, expected)
 2130: 
 2131:     def test_float_to_datetime_raise_near_bounds(self):
 2132:         # GH50183
 2133:         msg = "cannot convert input with unit 'D'"
 2134:         oneday_in_ns = 1e9 * 60 * 60 * 24
 2135:         tsmax_in_days = 2**63 / oneday_in_ns  # 2**63 ns, in days
 2136:         # just in bounds
 2137:         should_succeed = Series(
 2138:             [0, tsmax_in_days - 0.005, -tsmax_in_days + 0.005], dtype=float
 2139:         )
 2140:         expected = (should_succeed * oneday_in_ns).astype(np.int64)
 2141:         for error_mode in ["raise", "coerce", "ignore"]:
 2142:             result1 = to_datetime(should_succeed, unit="D", errors=error_mode)
 2143:             # Cast to `np.float64` so that `rtol` and inexact checking kick in
 2144:             # (`check_exact` doesn't take place for integer dtypes)
 2145:             tm.assert_almost_equal(
 2146:                 result1.astype(np.int64).astype(np.float64),
 2147:                 expected.astype(np.float64),
 2148:                 rtol=1e-10,
 2149:             )
 2150:         # just out of bounds
 2151:         should_fail1 = Series([0, tsmax_in_days + 0.005], dtype=float)
 2152:         should_fail2 = Series([0, -tsmax_in_days - 0.005], dtype=float)
 2153:         with pytest.raises(OutOfBoundsDatetime, match=msg):
 2154:             to_datetime(should_fail1, unit="D", errors="raise")
 2155:         with pytest.raises(OutOfBoundsDatetime, match=msg):
 2156:             to_datetime(should_fail2, unit="D", errors="raise")
 2157: 
 2158: 
 2159: class TestToDatetimeDataFrame:
 2160:     @pytest.fixture
 2161:     def df(self):
 2162:         return DataFrame(
 2163:             {
 2164:                 "year": [2015, 2016],
 2165:                 "month": [2, 3],
 2166:                 "day": [4, 5],
 2167:                 "hour": [6, 7],
 2168:                 "minute": [58, 59],
 2169:                 "second": [10, 11],
 2170:                 "ms": [1, 1],
 2171:                 "us": [2, 2],
 2172:                 "ns": [3, 3],
 2173:             }
 2174:         )
 2175: 
 2176:     def test_dataframe(self, df, cache):
 2177:         result = to_datetime(
 2178:             {"year": df["year"], "month": df["month"], "day": df["day"]}, cache=cache
 2179:         )
 2180:         expected = Series(
 2181:             [Timestamp("20150204 00:00:00"), Timestamp("20160305 00:0:00")]
 2182:         )
 2183:         tm.assert_series_equal(result, expected)
 2184: 
 2185:         # dict-like
 2186:         result = to_datetime(df[["year", "month", "day"]].to_dict(), cache=cache)
 2187:         tm.assert_series_equal(result, expected)
 2188: 
 2189:     def test_dataframe_dict_with_constructable(self, df, cache):
 2190:         # dict but with constructable
 2191:         df2 = df[["year", "month", "day"]].to_dict()
 2192:         df2["month"] = 2
 2193:         result = to_datetime(df2, cache=cache)
 2194:         expected2 = Series(
 2195:             [Timestamp("20150204 00:00:00"), Timestamp("20160205 00:0:00")]
 2196:         )
 2197:         tm.assert_series_equal(result, expected2)
 2198: 
 2199:     @pytest.mark.parametrize(
 2200:         "unit",
 2201:         [
 2202:             {
 2203:                 "year": "years",
 2204:                 "month": "months",
 2205:                 "day": "days",
 2206:                 "hour": "hours",
 2207:                 "minute": "minutes",
 2208:                 "second": "seconds",
 2209:             },
 2210:             {
 2211:                 "year": "year",
 2212:                 "month": "month",
 2213:                 "day": "day",
 2214:                 "hour": "hour",
 2215:                 "minute": "minute",
 2216:                 "second": "second",
 2217:             },
 2218:         ],
 2219:     )
 2220:     def test_dataframe_field_aliases_column_subset(self, df, cache, unit):
 2221:         # unit mappings
 2222:         result = to_datetime(df[list(unit.keys())].rename(columns=unit), cache=cache)
 2223:         expected = Series(
 2224:             [Timestamp("20150204 06:58:10"), Timestamp("20160305 07:59:11")],
 2225:             dtype="M8[ns]",
 2226:         )
 2227:         tm.assert_series_equal(result, expected)
 2228: 
 2229:     def test_dataframe_field_aliases(self, df, cache):
 2230:         d = {
 2231:             "year": "year",
 2232:             "month": "month",
 2233:             "day": "day",
 2234:             "hour": "hour",
 2235:             "minute": "minute",
 2236:             "second": "second",
 2237:             "ms": "ms",
 2238:             "us": "us",
 2239:             "ns": "ns",
 2240:         }
 2241: 
 2242:         result = to_datetime(df.rename(columns=d), cache=cache)
 2243:         expected = Series(
 2244:             [
 2245:                 Timestamp("20150204 06:58:10.001002003"),
 2246:                 Timestamp("20160305 07:59:11.001002003"),
 2247:             ]
 2248:         )
 2249:         tm.assert_series_equal(result, expected)
 2250: 
 2251:     def test_dataframe_str_dtype(self, df, cache):
 2252:         # coerce back to int
 2253:         result = to_datetime(df.astype(str), cache=cache)
 2254:         expected = Series(
 2255:             [
 2256:                 Timestamp("20150204 06:58:10.001002003"),
 2257:                 Timestamp("20160305 07:59:11.001002003"),
 2258:             ]
 2259:         )
 2260:         tm.assert_series_equal(result, expected)
 2261: 
 2262:     def test_dataframe_coerce(self, cache):
 2263:         # passing coerce
 2264:         df2 = DataFrame({"year": [2015, 2016], "month": [2, 20], "day": [4, 5]})
 2265: 
 2266:         msg = (
 2267:             r'^cannot assemble the datetimes: time data ".+" doesn\'t '
 2268:             r'match format "%Y%m%d", at position 1\.'
 2269:         )
 2270:         with pytest.raises(ValueError, match=msg):
 2271:             to_datetime(df2, cache=cache)
 2272: 
 2273:         result = to_datetime(df2, errors="coerce", cache=cache)
 2274:         expected = Series([Timestamp("20150204 00:00:00"), NaT])
 2275:         tm.assert_series_equal(result, expected)
 2276: 
 2277:     def test_dataframe_extra_keys_raisesm(self, df, cache):
 2278:         # extra columns
 2279:         msg = r"extra keys have been passed to the datetime assemblage: \[foo\]"
 2280:         with pytest.raises(ValueError, match=msg):
 2281:             df2 = df.copy()
 2282:             df2["foo"] = 1
 2283:             to_datetime(df2, cache=cache)
 2284: 
 2285:     @pytest.mark.parametrize(
 2286:         "cols",
 2287:         [
 2288:             ["year"],
 2289:             ["year", "month"],
 2290:             ["year", "month", "second"],
 2291:             ["month", "day"],
 2292:             ["year", "day", "second"],
 2293:         ],
 2294:     )
 2295:     def test_dataframe_missing_keys_raises(self, df, cache, cols):
 2296:         # not enough
 2297:         msg = (
 2298:             r"to assemble mappings requires at least that \[year, month, "
 2299:             r"day\] be specified: \[.+\] is missing"
 2300:         )
 2301:         with pytest.raises(ValueError, match=msg):
 2302:             to_datetime(df[cols], cache=cache)
 2303: 
 2304:     def test_dataframe_duplicate_columns_raises(self, cache):
 2305:         # duplicates
 2306:         msg = "cannot assemble with duplicate keys"
 2307:         df2 = DataFrame({"year": [2015, 2016], "month": [2, 20], "day": [4, 5]})
 2308:         df2.columns = ["year", "year", "day"]
 2309:         with pytest.raises(ValueError, match=msg):
 2310:             to_datetime(df2, cache=cache)
 2311: 
 2312:         df2 = DataFrame(
 2313:             {"year": [2015, 2016], "month": [2, 20], "day": [4, 5], "hour": [4, 5]}
 2314:         )
 2315:         df2.columns = ["year", "month", "day", "day"]
 2316:         with pytest.raises(ValueError, match=msg):
 2317:             to_datetime(df2, cache=cache)
 2318: 
 2319:     def test_dataframe_int16(self, cache):
 2320:         # GH#13451
 2321:         df = DataFrame({"year": [2015, 2016], "month": [2, 3], "day": [4, 5]})
 2322: 
 2323:         # int16
 2324:         result = to_datetime(df.astype("int16"), cache=cache)
 2325:         expected = Series(
 2326:             [Timestamp("20150204 00:00:00"), Timestamp("20160305 00:00:00")]
 2327:         )
 2328:         tm.assert_series_equal(result, expected)
 2329: 
 2330:     def test_dataframe_mixed(self, cache):
 2331:         # mixed dtypes
 2332:         df = DataFrame({"year": [2015, 2016], "month": [2, 3], "day": [4, 5]})
 2333:         df["month"] = df["month"].astype("int8")
 2334:         df["day"] = df["day"].astype("int8")
 2335:         result = to_datetime(df, cache=cache)
 2336:         expected = Series(
 2337:             [Timestamp("20150204 00:00:00"), Timestamp("20160305 00:00:00")]
 2338:         )
 2339:         tm.assert_series_equal(result, expected)
 2340: 
 2341:     def test_dataframe_float(self, cache):
 2342:         # float
 2343:         df = DataFrame({"year": [2000, 2001], "month": [1.5, 1], "day": [1, 1]})
 2344:         msg = (
 2345:             r"^cannot assemble the datetimes: unconverted data remains when parsing "
 2346:             r'with format ".*": "1", at position 0.'
 2347:         )
 2348:         with pytest.raises(ValueError, match=msg):
 2349:             to_datetime(df, cache=cache)
 2350: 
 2351:     def test_dataframe_utc_true(self):
 2352:         # GH#23760
 2353:         df = DataFrame({"year": [2015, 2016], "month": [2, 3], "day": [4, 5]})
 2354:         result = to_datetime(df, utc=True)
 2355:         expected = Series(
 2356:             np.array(["2015-02-04", "2016-03-05"], dtype="datetime64[ns]")
 2357:         ).dt.tz_localize("UTC")
 2358:         tm.assert_series_equal(result, expected)
 2359: 
 2360: 
 2361: class TestToDatetimeMisc:
 2362:     def test_to_datetime_barely_out_of_bounds(self):
 2363:         # GH#19529
 2364:         # GH#19382 close enough to bounds that dropping nanos would result
 2365:         # in an in-bounds datetime
 2366:         arr = np.array(["2262-04-11 23:47:16.854775808"], dtype=object)
 2367: 
 2368:         msg = "^Out of bounds nanosecond timestamp: .*, at position 0"
 2369:         with pytest.raises(OutOfBoundsDatetime, match=msg):
 2370:             to_datetime(arr)
 2371: 
 2372:     @pytest.mark.parametrize(
 2373:         "arg, exp_str",
 2374:         [
 2375:             ["2012-01-01 00:00:00", "2012-01-01 00:00:00"],
 2376:             ["20121001", "2012-10-01"],  # bad iso 8601
 2377:         ],
 2378:     )
 2379:     def test_to_datetime_iso8601(self, cache, arg, exp_str):
 2380:         result = to_datetime([arg], cache=cache)
 2381:         exp = Timestamp(exp_str)
 2382:         assert result[0] == exp
 2383: 
 2384:     @pytest.mark.parametrize(
 2385:         "input, format",
 2386:         [
 2387:             ("2012", "%Y-%m"),
 2388:             ("2012-01", "%Y-%m-%d"),
 2389:             ("2012-01-01", "%Y-%m-%d %H"),
 2390:             ("2012-01-01 10", "%Y-%m-%d %H:%M"),
 2391:             ("2012-01-01 10:00", "%Y-%m-%d %H:%M:%S"),
 2392:             ("2012-01-01 10:00:00", "%Y-%m-%d %H:%M:%S.%f"),
 2393:             ("2012-01-01 10:00:00.123", "%Y-%m-%d %H:%M:%S.%f%z"),
 2394:             (0, "%Y-%m-%d"),
 2395:         ],
 2396:     )
 2397:     @pytest.mark.parametrize("exact", [True, False])
 2398:     def test_to_datetime_iso8601_fails(self, input, format, exact):
 2399:         # https://github.com/pandas-dev/pandas/issues/12649
 2400:         # `format` is longer than the string, so this fails regardless of `exact`
 2401:         with pytest.raises(
 2402:             ValueError,
 2403:             match=(
 2404:                 rf"time data \"{input}\" doesn't match format "
 2405:                 rf"\"{format}\", at position 0"
 2406:             ),
 2407:         ):
 2408:             to_datetime(input, format=format, exact=exact)
 2409: 
 2410:     @pytest.mark.parametrize(
 2411:         "input, format",
 2412:         [
 2413:             ("2012-01-01", "%Y-%m"),
 2414:             ("2012-01-01 10", "%Y-%m-%d"),
 2415:             ("2012-01-01 10:00", "%Y-%m-%d %H"),
 2416:             ("2012-01-01 10:00:00", "%Y-%m-%d %H:%M"),
 2417:             (0, "%Y-%m-%d"),
 2418:         ],
 2419:     )
 2420:     def test_to_datetime_iso8601_exact_fails(self, input, format):
 2421:         # https://github.com/pandas-dev/pandas/issues/12649
 2422:         # `format` is shorter than the date string, so only fails with `exact=True`
 2423:         msg = "|".join(
 2424:             [
 2425:                 '^unconverted data remains when parsing with format ".*": ".*"'
 2426:                 f", at position 0. {PARSING_ERR_MSG}$",
 2427:                 f'^time data ".*" doesn\'t match format ".*", at position 0. '
 2428:                 f"{PARSING_ERR_MSG}$",
 2429:             ]
 2430:         )
 2431:         with pytest.raises(
 2432:             ValueError,
 2433:             match=(msg),
 2434:         ):
 2435:             to_datetime(input, format=format)
 2436: 
 2437:     @pytest.mark.parametrize(
 2438:         "input, format",
 2439:         [
 2440:             ("2012-01-01", "%Y-%m"),
 2441:             ("2012-01-01 00", "%Y-%m-%d"),
 2442:             ("2012-01-01 00:00", "%Y-%m-%d %H"),
 2443:             ("2012-01-01 00:00:00", "%Y-%m-%d %H:%M"),
 2444:         ],
 2445:     )
 2446:     def test_to_datetime_iso8601_non_exact(self, input, format):
 2447:         # https://github.com/pandas-dev/pandas/issues/12649
 2448:         expected = Timestamp(2012, 1, 1)
 2449:         result = to_datetime(input, format=format, exact=False)
 2450:         assert result == expected
 2451: 
 2452:     @pytest.mark.parametrize(
 2453:         "input, format",
 2454:         [
 2455:             ("2020-01", "%Y/%m"),
 2456:             ("2020-01-01", "%Y/%m/%d"),
 2457:             ("2020-01-01 00", "%Y/%m/%dT%H"),
 2458:             ("2020-01-01T00", "%Y/%m/%d %H"),
 2459:             ("2020-01-01 00:00", "%Y/%m/%dT%H:%M"),
 2460:             ("2020-01-01T00:00", "%Y/%m/%d %H:%M"),
 2461:             ("2020-01-01 00:00:00", "%Y/%m/%dT%H:%M:%S"),
 2462:             ("2020-01-01T00:00:00", "%Y/%m/%d %H:%M:%S"),
 2463:         ],
 2464:     )
 2465:     def test_to_datetime_iso8601_separator(self, input, format):
 2466:         # https://github.com/pandas-dev/pandas/issues/12649
 2467:         with pytest.raises(
 2468:             ValueError,
 2469:             match=(
 2470:                 rf"time data \"{input}\" doesn\'t match format "
 2471:                 rf"\"{format}\", at position 0"
 2472:             ),
 2473:         ):
 2474:             to_datetime(input, format=format)
 2475: 
 2476:     @pytest.mark.parametrize(
 2477:         "input, format",
 2478:         [
 2479:             ("2020-01", "%Y-%m"),
 2480:             ("2020-01-01", "%Y-%m-%d"),
 2481:             ("2020-01-01 00", "%Y-%m-%d %H"),
 2482:             ("2020-01-01T00", "%Y-%m-%dT%H"),
 2483:             ("2020-01-01 00:00", "%Y-%m-%d %H:%M"),
 2484:             ("2020-01-01T00:00", "%Y-%m-%dT%H:%M"),
 2485:             ("2020-01-01 00:00:00", "%Y-%m-%d %H:%M:%S"),
 2486:             ("2020-01-01T00:00:00", "%Y-%m-%dT%H:%M:%S"),
 2487:             ("2020-01-01T00:00:00.000", "%Y-%m-%dT%H:%M:%S.%f"),
 2488:             ("2020-01-01T00:00:00.000000", "%Y-%m-%dT%H:%M:%S.%f"),
 2489:             ("2020-01-01T00:00:00.000000000", "%Y-%m-%dT%H:%M:%S.%f"),
 2490:         ],
 2491:     )
 2492:     def test_to_datetime_iso8601_valid(self, input, format):
 2493:         # https://github.com/pandas-dev/pandas/issues/12649
 2494:         expected = Timestamp(2020, 1, 1)
 2495:         result = to_datetime(input, format=format)
 2496:         assert result == expected
 2497: 
 2498:     @pytest.mark.parametrize(
 2499:         "input, format",
 2500:         [
 2501:             ("2020-1", "%Y-%m"),
 2502:             ("2020-1-1", "%Y-%m-%d"),
 2503:             ("2020-1-1 0", "%Y-%m-%d %H"),
 2504:             ("2020-1-1T0", "%Y-%m-%dT%H"),
 2505:             ("2020-1-1 0:0", "%Y-%m-%d %H:%M"),
 2506:             ("2020-1-1T0:0", "%Y-%m-%dT%H:%M"),
 2507:             ("2020-1-1 0:0:0", "%Y-%m-%d %H:%M:%S"),
 2508:             ("2020-1-1T0:0:0", "%Y-%m-%dT%H:%M:%S"),
 2509:             ("2020-1-1T0:0:0.000", "%Y-%m-%dT%H:%M:%S.%f"),
 2510:             ("2020-1-1T0:0:0.000000", "%Y-%m-%dT%H:%M:%S.%f"),
 2511:             ("2020-1-1T0:0:0.000000000", "%Y-%m-%dT%H:%M:%S.%f"),
 2512:         ],
 2513:     )
 2514:     def test_to_datetime_iso8601_non_padded(self, input, format):
 2515:         # https://github.com/pandas-dev/pandas/issues/21422
 2516:         expected = Timestamp(2020, 1, 1)
 2517:         result = to_datetime(input, format=format)
 2518:         assert result == expected
 2519: 
 2520:     @pytest.mark.parametrize(
 2521:         "input, format",
 2522:         [
 2523:             ("2020-01-01T00:00:00.000000000+00:00", "%Y-%m-%dT%H:%M:%S.%f%z"),
 2524:             ("2020-01-01T00:00:00+00:00", "%Y-%m-%dT%H:%M:%S%z"),
 2525:             ("2020-01-01T00:00:00Z", "%Y-%m-%dT%H:%M:%S%z"),
 2526:         ],
 2527:     )
 2528:     def test_to_datetime_iso8601_with_timezone_valid(self, input, format):
 2529:         # https://github.com/pandas-dev/pandas/issues/12649
 2530:         expected = Timestamp(2020, 1, 1, tzinfo=pytz.UTC)
 2531:         result = to_datetime(input, format=format)
 2532:         assert result == expected
 2533: 
 2534:     def test_to_datetime_default(self, cache):
 2535:         rs = to_datetime("2001", cache=cache)
 2536:         xp = datetime(2001, 1, 1)
 2537:         assert rs == xp
 2538: 
 2539:     @pytest.mark.xfail(reason="fails to enforce dayfirst=True, which would raise")
 2540:     def test_to_datetime_respects_dayfirst(self, cache):
 2541:         # dayfirst is essentially broken
 2542: 
 2543:         # The msg here is not important since it isn't actually raised yet.
 2544:         msg = "Invalid date specified"
 2545:         with pytest.raises(ValueError, match=msg):
 2546:             # if dayfirst is respected, then this would parse as month=13, which
 2547:             #  would raise
 2548:             with tm.assert_produces_warning(UserWarning, match="Provide format"):
 2549:                 to_datetime("01-13-2012", dayfirst=True, cache=cache)
 2550: 
 2551:     def test_to_datetime_on_datetime64_series(self, cache):
 2552:         # #2699
 2553:         ser = Series(date_range("1/1/2000", periods=10))
 2554: 
 2555:         result = to_datetime(ser, cache=cache)
 2556:         assert result[0] == ser[0]
 2557: 
 2558:     def test_to_datetime_with_space_in_series(self, cache):
 2559:         # GH 6428
 2560:         ser = Series(["10/18/2006", "10/18/2008", " "])
 2561:         msg = (
 2562:             r'^time data " " doesn\'t match format "%m/%d/%Y", '
 2563:             rf"at position 2. {PARSING_ERR_MSG}$"
 2564:         )
 2565:         with pytest.raises(ValueError, match=msg):
 2566:             to_datetime(ser, errors="raise", cache=cache)
 2567:         result_coerce = to_datetime(ser, errors="coerce", cache=cache)
 2568:         expected_coerce = Series([datetime(2006, 10, 18), datetime(2008, 10, 18), NaT])
 2569:         tm.assert_series_equal(result_coerce, expected_coerce)
 2570:         result_ignore = to_datetime(ser, errors="ignore", cache=cache)
 2571:         tm.assert_series_equal(result_ignore, ser)
 2572: 
 2573:     @td.skip_if_not_us_locale
 2574:     def test_to_datetime_with_apply(self, cache):
 2575:         # this is only locale tested with US/None locales
 2576:         # GH 5195
 2577:         # with a format and coerce a single item to_datetime fails
 2578:         td = Series(["May 04", "Jun 02", "Dec 11"], index=[1, 2, 3])
 2579:         expected = to_datetime(td, format="%b %y", cache=cache)
 2580:         result = td.apply(to_datetime, format="%b %y", cache=cache)
 2581:         tm.assert_series_equal(result, expected)
 2582: 
 2583:     def test_to_datetime_timezone_name(self):
 2584:         # https://github.com/pandas-dev/pandas/issues/49748
 2585:         result = to_datetime("2020-01-01 00:00:00UTC", format="%Y-%m-%d %H:%M:%S%Z")
 2586:         expected = Timestamp(2020, 1, 1).tz_localize("UTC")
 2587:         assert result == expected
 2588: 
 2589:     @td.skip_if_not_us_locale
 2590:     @pytest.mark.parametrize("errors", ["raise", "coerce", "ignore"])
 2591:     def test_to_datetime_with_apply_with_empty_str(self, cache, errors):
 2592:         # this is only locale tested with US/None locales
 2593:         # GH 5195, GH50251
 2594:         # with a format and coerce a single item to_datetime fails
 2595:         td = Series(["May 04", "Jun 02", ""], index=[1, 2, 3])
 2596:         expected = to_datetime(td, format="%b %y", errors=errors, cache=cache)
 2597: 
 2598:         result = td.apply(
 2599:             lambda x: to_datetime(x, format="%b %y", errors="coerce", cache=cache)
 2600:         )
 2601:         tm.assert_series_equal(result, expected)
 2602: 
 2603:     def test_to_datetime_empty_stt(self, cache):
 2604:         # empty string
 2605:         result = to_datetime("", cache=cache)
 2606:         assert result is NaT
 2607: 
 2608:     def test_to_datetime_empty_str_list(self, cache):
 2609:         result = to_datetime(["", ""], cache=cache)
 2610:         assert isna(result).all()
 2611: 
 2612:     def test_to_datetime_zero(self, cache):
 2613:         # ints
 2614:         result = Timestamp(0)
 2615:         expected = to_datetime(0, cache=cache)
 2616:         assert result == expected
 2617: 
 2618:     def test_to_datetime_strings(self, cache):
 2619:         # GH 3888 (strings)
 2620:         expected = to_datetime(["2012"], cache=cache)[0]
 2621:         result = to_datetime("2012", cache=cache)
 2622:         assert result == expected
 2623: 
 2624:     def test_to_datetime_strings_variation(self, cache):
 2625:         array = ["2012", "20120101", "20120101 12:01:01"]
 2626:         expected = [to_datetime(dt_str, cache=cache) for dt_str in array]
 2627:         result = [Timestamp(date_str) for date_str in array]
 2628:         tm.assert_almost_equal(result, expected)
 2629: 
 2630:     @pytest.mark.parametrize("result", [Timestamp("2012"), to_datetime("2012")])
 2631:     def test_to_datetime_strings_vs_constructor(self, result):
 2632:         expected = Timestamp(2012, 1, 1)
 2633:         assert result == expected
 2634: 
 2635:     def test_to_datetime_unprocessable_input(self, cache):
 2636:         # GH 4928
 2637:         # GH 21864
 2638:         result = to_datetime([1, "1"], errors="ignore", cache=cache)
 2639: 
 2640:         expected = Index(np.array([1, "1"], dtype="O"))
 2641:         tm.assert_equal(result, expected)
 2642:         msg = '^Given date string "1" not likely a datetime, at position 1$'
 2643:         with pytest.raises(ValueError, match=msg):
 2644:             to_datetime([1, "1"], errors="raise", cache=cache)
 2645: 
 2646:     def test_to_datetime_unhashable_input(self, cache):
 2647:         series = Series([["a"]] * 100)
 2648:         result = to_datetime(series, errors="ignore", cache=cache)
 2649:         tm.assert_series_equal(series, result)
 2650: 
 2651:     def test_to_datetime_other_datetime64_units(self):
 2652:         # 5/25/2012
 2653:         scalar = np.int64(1337904000000000).view("M8[us]")
 2654:         as_obj = scalar.astype("O")
 2655: 
 2656:         index = DatetimeIndex([scalar])
 2657:         assert index[0] == scalar.astype("O")
 2658: 
 2659:         value = Timestamp(scalar)
 2660:         assert value == as_obj
 2661: 
 2662:     def test_to_datetime_list_of_integers(self):
 2663:         rng = date_range("1/1/2000", periods=20)
 2664:         rng = DatetimeIndex(rng.values)
 2665: 
 2666:         ints = list(rng.asi8)
 2667: 
 2668:         result = DatetimeIndex(ints)
 2669: 
 2670:         tm.assert_index_equal(rng, result)
 2671: 
 2672:     def test_to_datetime_overflow(self):
 2673:         # gh-17637
 2674:         # we are overflowing Timedelta range here
 2675:         msg = "Cannot cast 139999 days 00:00:00 to unit='ns' without overflow"
 2676:         with pytest.raises(OutOfBoundsTimedelta, match=msg):
 2677:             date_range(start="1/1/1700", freq="B", periods=100000)
 2678: 
 2679:     def test_string_invalid_operation(self, cache):
 2680:         invalid = np.array(["87156549591102612381000001219H5"], dtype=object)
 2681:         # GH #51084
 2682: 
 2683:         with pytest.raises(ValueError, match="Unknown datetime string format"):
 2684:             to_datetime(invalid, errors="raise", cache=cache)
 2685: 
 2686:     def test_string_na_nat_conversion(self, cache):
 2687:         # GH #999, #858
 2688: 
 2689:         strings = np.array(["1/1/2000", "1/2/2000", np.nan, "1/4/2000"], dtype=object)
 2690: 
 2691:         expected = np.empty(4, dtype="M8[ns]")
 2692:         for i, val in enumerate(strings):
 2693:             if isna(val):
 2694:                 expected[i] = iNaT
 2695:             else:
 2696:                 expected[i] = parse(val)
 2697: 
 2698:         result = tslib.array_to_datetime(strings)[0]
 2699:         tm.assert_almost_equal(result, expected)
 2700: 
 2701:         result2 = to_datetime(strings, cache=cache)
 2702:         assert isinstance(result2, DatetimeIndex)
 2703:         tm.assert_numpy_array_equal(result, result2.values)
 2704: 
 2705:     def test_string_na_nat_conversion_malformed(self, cache):
 2706:         malformed = np.array(["1/100/2000", np.nan], dtype=object)
 2707: 
 2708:         # GH 10636, default is now 'raise'
 2709:         msg = r"Unknown datetime string format"
 2710:         with pytest.raises(ValueError, match=msg):
 2711:             to_datetime(malformed, errors="raise", cache=cache)
 2712: 
 2713:         result = to_datetime(malformed, errors="ignore", cache=cache)
 2714:         # GH 21864
 2715:         expected = Index(malformed, dtype=object)
 2716:         tm.assert_index_equal(result, expected)
 2717: 
 2718:         with pytest.raises(ValueError, match=msg):
 2719:             to_datetime(malformed, errors="raise", cache=cache)
 2720: 
 2721:     def test_string_na_nat_conversion_with_name(self, cache):
 2722:         idx = ["a", "b", "c", "d", "e"]
 2723:         series = Series(
 2724:             ["1/1/2000", np.nan, "1/3/2000", np.nan, "1/5/2000"], index=idx, name="foo"
 2725:         )
 2726:         dseries = Series(
 2727:             [
 2728:                 to_datetime("1/1/2000", cache=cache),
 2729:                 np.nan,
 2730:                 to_datetime("1/3/2000", cache=cache),
 2731:                 np.nan,
 2732:                 to_datetime("1/5/2000", cache=cache),
 2733:             ],
 2734:             index=idx,
 2735:             name="foo",
 2736:         )
 2737: 
 2738:         result = to_datetime(series, cache=cache)
 2739:         dresult = to_datetime(dseries, cache=cache)
 2740: 
 2741:         expected = Series(np.empty(5, dtype="M8[ns]"), index=idx)
 2742:         for i in range(5):
 2743:             x = series.iloc[i]
 2744:             if isna(x):
 2745:                 expected.iloc[i] = NaT
 2746:             else:
 2747:                 expected.iloc[i] = to_datetime(x, cache=cache)
 2748: 
 2749:         tm.assert_series_equal(result, expected, check_names=False)
 2750:         assert result.name == "foo"
 2751: 
 2752:         tm.assert_series_equal(dresult, expected, check_names=False)
 2753:         assert dresult.name == "foo"
 2754: 
 2755:     @pytest.mark.parametrize(
 2756:         "unit",
 2757:         ["h", "m", "s", "ms", "us", "ns"],
 2758:     )
 2759:     def test_dti_constructor_numpy_timeunits(self, cache, unit):
 2760:         # GH 9114
 2761:         dtype = np.dtype(f"M8[{unit}]")
 2762:         base = to_datetime(["2000-01-01T00:00", "2000-01-02T00:00", "NaT"], cache=cache)
 2763: 
 2764:         values = base.values.astype(dtype)
 2765: 
 2766:         if unit in ["h", "m"]:
 2767:             # we cast to closest supported unit
 2768:             unit = "s"
 2769:         exp_dtype = np.dtype(f"M8[{unit}]")
 2770:         expected = DatetimeIndex(base.astype(exp_dtype))
 2771:         assert expected.dtype == exp_dtype
 2772: 
 2773:         tm.assert_index_equal(DatetimeIndex(values), expected)
 2774:         tm.assert_index_equal(to_datetime(values, cache=cache), expected)
 2775: 
 2776:     def test_dayfirst(self, cache):
 2777:         # GH 5917
 2778:         arr = ["10/02/2014", "11/02/2014", "12/02/2014"]
 2779:         expected = DatetimeIndex(
 2780:             [datetime(2014, 2, 10), datetime(2014, 2, 11), datetime(2014, 2, 12)]
 2781:         )
 2782:         idx1 = DatetimeIndex(arr, dayfirst=True)
 2783:         idx2 = DatetimeIndex(np.array(arr), dayfirst=True)
 2784:         idx3 = to_datetime(arr, dayfirst=True, cache=cache)
 2785:         idx4 = to_datetime(np.array(arr), dayfirst=True, cache=cache)
 2786:         idx5 = DatetimeIndex(Index(arr), dayfirst=True)
 2787:         idx6 = DatetimeIndex(Series(arr), dayfirst=True)
 2788:         tm.assert_index_equal(expected, idx1)
 2789:         tm.assert_index_equal(expected, idx2)
 2790:         tm.assert_index_equal(expected, idx3)
 2791:         tm.assert_index_equal(expected, idx4)
 2792:         tm.assert_index_equal(expected, idx5)
 2793:         tm.assert_index_equal(expected, idx6)
 2794: 
 2795:     def test_dayfirst_warnings_valid_input(self):
 2796:         # GH 12585
 2797:         warning_msg = (
 2798:             "Parsing dates in .* format when dayfirst=.* was specified. "
 2799:             "Pass `dayfirst=.*` or specify a format to silence this warning."
 2800:         )
 2801: 
 2802:         # CASE 1: valid input
 2803:         arr = ["31/12/2014", "10/03/2011"]
 2804:         expected = DatetimeIndex(
 2805:             ["2014-12-31", "2011-03-10"], dtype="datetime64[ns]", freq=None
 2806:         )
 2807: 
 2808:         # A. dayfirst arg correct, no warning
 2809:         res1 = to_datetime(arr, dayfirst=True)
 2810:         tm.assert_index_equal(expected, res1)
 2811: 
 2812:         # B. dayfirst arg incorrect, warning
 2813:         with tm.assert_produces_warning(UserWarning, match=warning_msg):
 2814:             res2 = to_datetime(arr, dayfirst=False)
 2815:         tm.assert_index_equal(expected, res2)
 2816: 
 2817:     def test_dayfirst_warnings_invalid_input(self):
 2818:         # CASE 2: invalid input
 2819:         # cannot consistently process with single format
 2820:         # ValueError *always* raised
 2821: 
 2822:         # first in DD/MM/YYYY, second in MM/DD/YYYY
 2823:         arr = ["31/12/2014", "03/30/2011"]
 2824: 
 2825:         with pytest.raises(
 2826:             ValueError,
 2827:             match=(
 2828:                 r'^time data "03/30/2011" doesn\'t match format '
 2829:                 rf'"%d/%m/%Y", at position 1. {PARSING_ERR_MSG}$'
 2830:             ),
 2831:         ):
 2832:             to_datetime(arr, dayfirst=True)
 2833: 
 2834:     @pytest.mark.parametrize("klass", [DatetimeIndex, DatetimeArray._from_sequence])
 2835:     def test_to_datetime_dta_tz(self, klass):
 2836:         # GH#27733
 2837:         dti = date_range("2015-04-05", periods=3).rename("foo")
 2838:         expected = dti.tz_localize("UTC")
 2839: 
 2840:         obj = klass(dti)
 2841:         expected = klass(expected)
 2842: 
 2843:         result = to_datetime(obj, utc=True)
 2844:         tm.assert_equal(result, expected)
 2845: 
 2846: 
 2847: class TestGuessDatetimeFormat:
 2848:     @pytest.mark.parametrize(
 2849:         "test_list",
 2850:         [
 2851:             [
 2852:                 "2011-12-30 00:00:00.000000",
 2853:                 "2011-12-30 00:00:00.000000",
 2854:                 "2011-12-30 00:00:00.000000",
 2855:             ],
 2856:             [np.nan, np.nan, "2011-12-30 00:00:00.000000"],
 2857:             ["", "2011-12-30 00:00:00.000000"],
 2858:             ["NaT", "2011-12-30 00:00:00.000000"],
 2859:             ["2011-12-30 00:00:00.000000", "random_string"],
 2860:             ["now", "2011-12-30 00:00:00.000000"],
 2861:             ["today", "2011-12-30 00:00:00.000000"],
 2862:         ],
 2863:     )
 2864:     def test_guess_datetime_format_for_array(self, test_list):
 2865:         expected_format = "%Y-%m-%d %H:%M:%S.%f"
 2866:         test_array = np.array(test_list, dtype=object)
 2867:         assert tools._guess_datetime_format_for_array(test_array) == expected_format
 2868: 
 2869:     @td.skip_if_not_us_locale
 2870:     def test_guess_datetime_format_for_array_all_nans(self):
 2871:         format_for_string_of_nans = tools._guess_datetime_format_for_array(
 2872:             np.array([np.nan, np.nan, np.nan], dtype="O")
 2873:         )
 2874:         assert format_for_string_of_nans is None
 2875: 
 2876: 
 2877: class TestToDatetimeInferFormat:
 2878:     @pytest.mark.parametrize(
 2879:         "test_format", ["%m-%d-%Y", "%m/%d/%Y %H:%M:%S.%f", "%Y-%m-%dT%H:%M:%S.%f"]
 2880:     )
 2881:     def test_to_datetime_infer_datetime_format_consistent_format(
 2882:         self, cache, test_format
 2883:     ):
 2884:         ser = Series(date_range("20000101", periods=50, freq="h"))
 2885: 
 2886:         s_as_dt_strings = ser.apply(lambda x: x.strftime(test_format))
 2887: 
 2888:         with_format = to_datetime(s_as_dt_strings, format=test_format, cache=cache)
 2889:         without_format = to_datetime(s_as_dt_strings, cache=cache)
 2890: 
 2891:         # Whether the format is explicitly passed, or
 2892:         # it is inferred, the results should all be the same
 2893:         tm.assert_series_equal(with_format, without_format)
 2894: 
 2895:     def test_to_datetime_inconsistent_format(self, cache):
 2896:         data = ["01/01/2011 00:00:00", "01-02-2011 00:00:00", "2011-01-03T00:00:00"]
 2897:         ser = Series(np.array(data))
 2898:         msg = (
 2899:             r'^time data "01-02-2011 00:00:00" doesn\'t match format '
 2900:             rf'"%m/%d/%Y %H:%M:%S", at position 1. {PARSING_ERR_MSG}$'
 2901:         )
 2902:         with pytest.raises(ValueError, match=msg):
 2903:             to_datetime(ser, cache=cache)
 2904: 
 2905:     def test_to_datetime_consistent_format(self, cache):
 2906:         data = ["Jan/01/2011", "Feb/01/2011", "Mar/01/2011"]
 2907:         ser = Series(np.array(data))
 2908:         result = to_datetime(ser, cache=cache)
 2909:         expected = Series(
 2910:             ["2011-01-01", "2011-02-01", "2011-03-01"], dtype="datetime64[ns]"
 2911:         )
 2912:         tm.assert_series_equal(result, expected)
 2913: 
 2914:     def test_to_datetime_series_with_nans(self, cache):
 2915:         ser = Series(
 2916:             np.array(
 2917:                 ["01/01/2011 00:00:00", np.nan, "01/03/2011 00:00:00", np.nan],
 2918:                 dtype=object,
 2919:             )
 2920:         )
 2921:         result = to_datetime(ser, cache=cache)
 2922:         expected = Series(
 2923:             ["2011-01-01", NaT, "2011-01-03", NaT], dtype="datetime64[ns]"
 2924:         )
 2925:         tm.assert_series_equal(result, expected)
 2926: 
 2927:     def test_to_datetime_series_start_with_nans(self, cache):
 2928:         ser = Series(
 2929:             np.array(
 2930:                 [
 2931:                     np.nan,
 2932:                     np.nan,
 2933:                     "01/01/2011 00:00:00",
 2934:                     "01/02/2011 00:00:00",
 2935:                     "01/03/2011 00:00:00",
 2936:                 ],
 2937:                 dtype=object,
 2938:             )
 2939:         )
 2940: 
 2941:         result = to_datetime(ser, cache=cache)
 2942:         expected = Series(
 2943:             [NaT, NaT, "2011-01-01", "2011-01-02", "2011-01-03"], dtype="datetime64[ns]"
 2944:         )
 2945:         tm.assert_series_equal(result, expected)
 2946: 
 2947:     @pytest.mark.parametrize(
 2948:         "tz_name, offset",
 2949:         [("UTC", 0), ("UTC-3", 180), ("UTC+3", -180)],
 2950:     )
 2951:     def test_infer_datetime_format_tz_name(self, tz_name, offset):
 2952:         # GH 33133
 2953:         ser = Series([f"2019-02-02 08:07:13 {tz_name}"])
 2954:         result = to_datetime(ser)
 2955:         tz = timezone(timedelta(minutes=offset))
 2956:         expected = Series([Timestamp("2019-02-02 08:07:13").tz_localize(tz)])
 2957:         tm.assert_series_equal(result, expected)
 2958: 
 2959:     @pytest.mark.parametrize(
 2960:         "ts,zero_tz",
 2961:         [
 2962:             ("2019-02-02 08:07:13", "Z"),
 2963:             ("2019-02-02 08:07:13", ""),
 2964:             ("2019-02-02 08:07:13.012345", "Z"),
 2965:             ("2019-02-02 08:07:13.012345", ""),
 2966:         ],
 2967:     )
 2968:     def test_infer_datetime_format_zero_tz(self, ts, zero_tz):
 2969:         # GH 41047
 2970:         ser = Series([ts + zero_tz])
 2971:         result = to_datetime(ser)
 2972:         tz = pytz.utc if zero_tz == "Z" else None
 2973:         expected = Series([Timestamp(ts, tz=tz)])
 2974:         tm.assert_series_equal(result, expected)
 2975: 
 2976:     @pytest.mark.parametrize("format", [None, "%Y-%m-%d"])
 2977:     def test_to_datetime_iso8601_noleading_0s(self, cache, format):
 2978:         # GH 11871
 2979:         ser = Series(["2014-1-1", "2014-2-2", "2015-3-3"])
 2980:         expected = Series(
 2981:             [
 2982:                 Timestamp("2014-01-01"),
 2983:                 Timestamp("2014-02-02"),
 2984:                 Timestamp("2015-03-03"),
 2985:             ]
 2986:         )
 2987:         result = to_datetime(ser, format=format, cache=cache)
 2988:         tm.assert_series_equal(result, expected)
 2989: 
 2990:     def test_parse_dates_infer_datetime_format_warning(self):
 2991:         # GH 49024
 2992:         with tm.assert_produces_warning(
 2993:             UserWarning,
 2994:             match="The argument 'infer_datetime_format' is deprecated",
 2995:         ):
 2996:             to_datetime(["10-10-2000"], infer_datetime_format=True)
 2997: 
 2998: 
 2999: class TestDaysInMonth:
 3000:     # tests for issue #10154
 3001: 
 3002:     @pytest.mark.parametrize(
 3003:         "arg, format",
 3004:         [
 3005:             ["2015-02-29", None],
 3006:             ["2015-02-29", "%Y-%m-%d"],
 3007:             ["2015-02-32", "%Y-%m-%d"],
 3008:             ["2015-04-31", "%Y-%m-%d"],
 3009:         ],
 3010:     )
 3011:     def test_day_not_in_month_coerce(self, cache, arg, format):
 3012:         assert isna(to_datetime(arg, errors="coerce", format=format, cache=cache))
 3013: 
 3014:     def test_day_not_in_month_raise(self, cache):
 3015:         msg = "day is out of range for month: 2015-02-29, at position 0"
 3016:         with pytest.raises(ValueError, match=msg):
 3017:             to_datetime("2015-02-29", errors="raise", cache=cache)
 3018: 
 3019:     @pytest.mark.parametrize(
 3020:         "arg, format, msg",
 3021:         [
 3022:             (
 3023:                 "2015-02-29",
 3024:                 "%Y-%m-%d",
 3025:                 f"^day is out of range for month, at position 0. {PARSING_ERR_MSG}$",
 3026:             ),
 3027:             (
 3028:                 "2015-29-02",
 3029:                 "%Y-%d-%m",
 3030:                 f"^day is out of range for month, at position 0. {PARSING_ERR_MSG}$",
 3031:             ),
 3032:             (
 3033:                 "2015-02-32",
 3034:                 "%Y-%m-%d",
 3035:                 '^unconverted data remains when parsing with format "%Y-%m-%d": "2", '
 3036:                 f"at position 0. {PARSING_ERR_MSG}$",
 3037:             ),
 3038:             (
 3039:                 "2015-32-02",
 3040:                 "%Y-%d-%m",
 3041:                 '^time data "2015-32-02" doesn\'t match format "%Y-%d-%m", '
 3042:                 f"at position 0. {PARSING_ERR_MSG}$",
 3043:             ),
 3044:             (
 3045:                 "2015-04-31",
 3046:                 "%Y-%m-%d",
 3047:                 f"^day is out of range for month, at position 0. {PARSING_ERR_MSG}$",
 3048:             ),
 3049:             (
 3050:                 "2015-31-04",
 3051:                 "%Y-%d-%m",
 3052:                 f"^day is out of range for month, at position 0. {PARSING_ERR_MSG}$",
 3053:             ),
 3054:         ],
 3055:     )
 3056:     def test_day_not_in_month_raise_value(self, cache, arg, format, msg):
 3057:         # https://github.com/pandas-dev/pandas/issues/50462
 3058:         with pytest.raises(ValueError, match=msg):
 3059:             to_datetime(arg, errors="raise", format=format, cache=cache)
 3060: 
 3061:     @pytest.mark.parametrize(
 3062:         "expected, format",
 3063:         [
 3064:             ["2015-02-29", None],
 3065:             ["2015-02-29", "%Y-%m-%d"],
 3066:             ["2015-02-29", "%Y-%m-%d"],
 3067:             ["2015-04-31", "%Y-%m-%d"],
 3068:         ],
 3069:     )
 3070:     def test_day_not_in_month_ignore(self, cache, expected, format):
 3071:         result = to_datetime(expected, errors="ignore", format=format, cache=cache)
 3072:         assert result == expected
 3073: 
 3074: 
 3075: class TestDatetimeParsingWrappers:
 3076:     @pytest.mark.parametrize(
 3077:         "date_str, expected",
 3078:         [
 3079:             ("2011-01-01", datetime(2011, 1, 1)),
 3080:             ("2Q2005", datetime(2005, 4, 1)),
 3081:             ("2Q05", datetime(2005, 4, 1)),
 3082:             ("2005Q1", datetime(2005, 1, 1)),
 3083:             ("05Q1", datetime(2005, 1, 1)),
 3084:             ("2011Q3", datetime(2011, 7, 1)),
 3085:             ("11Q3", datetime(2011, 7, 1)),
 3086:             ("3Q2011", datetime(2011, 7, 1)),
 3087:             ("3Q11", datetime(2011, 7, 1)),
 3088:             # quarterly without space
 3089:             ("2000Q4", datetime(2000, 10, 1)),
 3090:             ("00Q4", datetime(2000, 10, 1)),
 3091:             ("4Q2000", datetime(2000, 10, 1)),
 3092:             ("4Q00", datetime(2000, 10, 1)),
 3093:             ("2000q4", datetime(2000, 10, 1)),
 3094:             ("2000-Q4", datetime(2000, 10, 1)),
 3095:             ("00-Q4", datetime(2000, 10, 1)),
 3096:             ("4Q-2000", datetime(2000, 10, 1)),
 3097:             ("4Q-00", datetime(2000, 10, 1)),
 3098:             ("00q4", datetime(2000, 10, 1)),
 3099:             ("2005", datetime(2005, 1, 1)),
 3100:             ("2005-11", datetime(2005, 11, 1)),
 3101:             ("2005 11", datetime(2005, 11, 1)),
 3102:             ("11-2005", datetime(2005, 11, 1)),
 3103:             ("11 2005", datetime(2005, 11, 1)),
 3104:             ("200511", datetime(2020, 5, 11)),
 3105:             ("20051109", datetime(2005, 11, 9)),
 3106:             ("20051109 10:15", datetime(2005, 11, 9, 10, 15)),
 3107:             ("20051109 08H", datetime(2005, 11, 9, 8, 0)),
 3108:             ("2005-11-09 10:15", datetime(2005, 11, 9, 10, 15)),
 3109:             ("2005-11-09 08H", datetime(2005, 11, 9, 8, 0)),
 3110:             ("2005/11/09 10:15", datetime(2005, 11, 9, 10, 15)),
 3111:             ("2005/11/09 10:15:32", datetime(2005, 11, 9, 10, 15, 32)),
 3112:             ("2005/11/09 10:15:32 AM", datetime(2005, 11, 9, 10, 15, 32)),
 3113:             ("2005/11/09 10:15:32 PM", datetime(2005, 11, 9, 22, 15, 32)),
 3114:             ("2005/11/09 08H", datetime(2005, 11, 9, 8, 0)),
 3115:             ("Thu Sep 25 10:36:28 2003", datetime(2003, 9, 25, 10, 36, 28)),
 3116:             ("Thu Sep 25 2003", datetime(2003, 9, 25)),
 3117:             ("Sep 25 2003", datetime(2003, 9, 25)),
 3118:             ("January 1 2014", datetime(2014, 1, 1)),
 3119:             # GH#10537
 3120:             ("2014-06", datetime(2014, 6, 1)),
 3121:             ("06-2014", datetime(2014, 6, 1)),
 3122:             ("2014-6", datetime(2014, 6, 1)),
 3123:             ("6-2014", datetime(2014, 6, 1)),
 3124:             ("20010101 12", datetime(2001, 1, 1, 12)),
 3125:             ("20010101 1234", datetime(2001, 1, 1, 12, 34)),
 3126:             ("20010101 123456", datetime(2001, 1, 1, 12, 34, 56)),
 3127:         ],
 3128:     )
 3129:     def test_parsers(self, date_str, expected, cache):
 3130:         # dateutil >= 2.5.0 defaults to yearfirst=True
 3131:         # https://github.com/dateutil/dateutil/issues/217
 3132:         yearfirst = True
 3133: 
 3134:         result1, _ = parsing.parse_datetime_string_with_reso(
 3135:             date_str, yearfirst=yearfirst
 3136:         )
 3137:         result2 = to_datetime(date_str, yearfirst=yearfirst)
 3138:         result3 = to_datetime([date_str], yearfirst=yearfirst)
 3139:         # result5 is used below
 3140:         result4 = to_datetime(
 3141:             np.array([date_str], dtype=object), yearfirst=yearfirst, cache=cache
 3142:         )
 3143:         result6 = DatetimeIndex([date_str], yearfirst=yearfirst)
 3144:         # result7 is used below
 3145:         result8 = DatetimeIndex(Index([date_str]), yearfirst=yearfirst)
 3146:         result9 = DatetimeIndex(Series([date_str]), yearfirst=yearfirst)
 3147: 
 3148:         for res in [result1, result2]:
 3149:             assert res == expected
 3150:         for res in [result3, result4, result6, result8, result9]:
 3151:             exp = DatetimeIndex([Timestamp(expected)])
 3152:             tm.assert_index_equal(res, exp)
 3153: 
 3154:         # these really need to have yearfirst, but we don't support
 3155:         if not yearfirst:
 3156:             result5 = Timestamp(date_str)
 3157:             assert result5 == expected
 3158:             result7 = date_range(date_str, freq="S", periods=1, yearfirst=yearfirst)
 3159:             assert result7 == expected
 3160: 
 3161:     def test_na_values_with_cache(
 3162:         self, cache, unique_nulls_fixture, unique_nulls_fixture2
 3163:     ):
 3164:         # GH22305
 3165:         expected = Index([NaT, NaT], dtype="datetime64[ns]")
 3166:         result = to_datetime([unique_nulls_fixture, unique_nulls_fixture2], cache=cache)
 3167:         tm.assert_index_equal(result, expected)
 3168: 
 3169:     def test_parsers_nat(self):
 3170:         # Test that each of several string-accepting methods return pd.NaT
 3171:         result1, _ = parsing.parse_datetime_string_with_reso("NaT")
 3172:         result2 = to_datetime("NaT")
 3173:         result3 = Timestamp("NaT")
 3174:         result4 = DatetimeIndex(["NaT"])[0]
 3175:         assert result1 is NaT
 3176:         assert result2 is NaT
 3177:         assert result3 is NaT
 3178:         assert result4 is NaT
 3179: 
 3180:     @pytest.mark.parametrize(
 3181:         "date_str, dayfirst, yearfirst, expected",
 3182:         [
 3183:             ("10-11-12", False, False, datetime(2012, 10, 11)),
 3184:             ("10-11-12", True, False, datetime(2012, 11, 10)),
 3185:             ("10-11-12", False, True, datetime(2010, 11, 12)),
 3186:             ("10-11-12", True, True, datetime(2010, 12, 11)),
 3187:             ("20/12/21", False, False, datetime(2021, 12, 20)),
 3188:             ("20/12/21", True, False, datetime(2021, 12, 20)),
 3189:             ("20/12/21", False, True, datetime(2020, 12, 21)),
 3190:             ("20/12/21", True, True, datetime(2020, 12, 21)),
 3191:         ],
 3192:     )
 3193:     def test_parsers_dayfirst_yearfirst(
 3194:         self, cache, date_str, dayfirst, yearfirst, expected
 3195:     ):
 3196:         # OK
 3197:         # 2.5.1 10-11-12   [dayfirst=0, yearfirst=0] -> 2012-10-11 00:00:00
 3198:         # 2.5.2 10-11-12   [dayfirst=0, yearfirst=1] -> 2012-10-11 00:00:00
 3199:         # 2.5.3 10-11-12   [dayfirst=0, yearfirst=0] -> 2012-10-11 00:00:00
 3200: 
 3201:         # OK
 3202:         # 2.5.1 10-11-12   [dayfirst=0, yearfirst=1] -> 2010-11-12 00:00:00
 3203:         # 2.5.2 10-11-12   [dayfirst=0, yearfirst=1] -> 2010-11-12 00:00:00
 3204:         # 2.5.3 10-11-12   [dayfirst=0, yearfirst=1] -> 2010-11-12 00:00:00
 3205: 
 3206:         # bug fix in 2.5.2
 3207:         # 2.5.1 10-11-12   [dayfirst=1, yearfirst=1] -> 2010-11-12 00:00:00
 3208:         # 2.5.2 10-11-12   [dayfirst=1, yearfirst=1] -> 2010-12-11 00:00:00
 3209:         # 2.5.3 10-11-12   [dayfirst=1, yearfirst=1] -> 2010-12-11 00:00:00
 3210: 
 3211:         # OK
 3212:         # 2.5.1 10-11-12   [dayfirst=1, yearfirst=0] -> 2012-11-10 00:00:00
 3213:         # 2.5.2 10-11-12   [dayfirst=1, yearfirst=0] -> 2012-11-10 00:00:00
 3214:         # 2.5.3 10-11-12   [dayfirst=1, yearfirst=0] -> 2012-11-10 00:00:00
 3215: 
 3216:         # OK
 3217:         # 2.5.1 20/12/21   [dayfirst=0, yearfirst=0] -> 2021-12-20 00:00:00
 3218:         # 2.5.2 20/12/21   [dayfirst=0, yearfirst=0] -> 2021-12-20 00:00:00
 3219:         # 2.5.3 20/12/21   [dayfirst=0, yearfirst=0] -> 2021-12-20 00:00:00
 3220: 
 3221:         # OK
 3222:         # 2.5.1 20/12/21   [dayfirst=0, yearfirst=1] -> 2020-12-21 00:00:00
 3223:         # 2.5.2 20/12/21   [dayfirst=0, yearfirst=1] -> 2020-12-21 00:00:00
 3224:         # 2.5.3 20/12/21   [dayfirst=0, yearfirst=1] -> 2020-12-21 00:00:00
 3225: 
 3226:         # revert of bug in 2.5.2
 3227:         # 2.5.1 20/12/21   [dayfirst=1, yearfirst=1] -> 2020-12-21 00:00:00
 3228:         # 2.5.2 20/12/21   [dayfirst=1, yearfirst=1] -> month must be in 1..12
 3229:         # 2.5.3 20/12/21   [dayfirst=1, yearfirst=1] -> 2020-12-21 00:00:00
 3230: 
 3231:         # OK
 3232:         # 2.5.1 20/12/21   [dayfirst=1, yearfirst=0] -> 2021-12-20 00:00:00
 3233:         # 2.5.2 20/12/21   [dayfirst=1, yearfirst=0] -> 2021-12-20 00:00:00
 3234:         # 2.5.3 20/12/21   [dayfirst=1, yearfirst=0] -> 2021-12-20 00:00:00
 3235: 
 3236:         # str : dayfirst, yearfirst, expected
 3237: 
 3238:         # compare with dateutil result
 3239:         dateutil_result = parse(date_str, dayfirst=dayfirst, yearfirst=yearfirst)
 3240:         assert dateutil_result == expected
 3241: 
 3242:         result1, _ = parsing.parse_datetime_string_with_reso(
 3243:             date_str, dayfirst=dayfirst, yearfirst=yearfirst
 3244:         )
 3245: 
 3246:         # we don't support dayfirst/yearfirst here:
 3247:         if not dayfirst and not yearfirst:
 3248:             result2 = Timestamp(date_str)
 3249:             assert result2 == expected
 3250: 
 3251:         result3 = to_datetime(
 3252:             date_str, dayfirst=dayfirst, yearfirst=yearfirst, cache=cache
 3253:         )
 3254: 
 3255:         result4 = DatetimeIndex([date_str], dayfirst=dayfirst, yearfirst=yearfirst)[0]
 3256: 
 3257:         assert result1 == expected
 3258:         assert result3 == expected
 3259:         assert result4 == expected
 3260: 
 3261:     @pytest.mark.parametrize(
 3262:         "date_str, exp_def",
 3263:         [["10:15", datetime(1, 1, 1, 10, 15)], ["9:05", datetime(1, 1, 1, 9, 5)]],
 3264:     )
 3265:     def test_parsers_timestring(self, date_str, exp_def):
 3266:         # must be the same as dateutil result
 3267:         exp_now = parse(date_str)
 3268: 
 3269:         result1, _ = parsing.parse_datetime_string_with_reso(date_str)
 3270:         result2 = to_datetime(date_str)
 3271:         result3 = to_datetime([date_str])
 3272:         result4 = Timestamp(date_str)
 3273:         result5 = DatetimeIndex([date_str])[0]
 3274:         # parse time string return time string based on default date
 3275:         # others are not, and can't be changed because it is used in
 3276:         # time series plot
 3277:         assert result1 == exp_def
 3278:         assert result2 == exp_now
 3279:         assert result3 == exp_now
 3280:         assert result4 == exp_now
 3281:         assert result5 == exp_now
 3282: 
 3283:     @pytest.mark.parametrize(
 3284:         "dt_string, tz, dt_string_repr",
 3285:         [
 3286:             (
 3287:                 "2013-01-01 05:45+0545",
 3288:                 timezone(timedelta(minutes=345)),
 3289:                 "Timestamp('2013-01-01 05:45:00+0545', tz='UTC+05:45')",
 3290:             ),
 3291:             (
 3292:                 "2013-01-01 05:30+0530",
 3293:                 timezone(timedelta(minutes=330)),
 3294:                 "Timestamp('2013-01-01 05:30:00+0530', tz='UTC+05:30')",
 3295:             ),
 3296:         ],
 3297:     )
 3298:     def test_parsers_timezone_minute_offsets_roundtrip(
 3299:         self, cache, dt_string, tz, dt_string_repr
 3300:     ):
 3301:         # GH11708
 3302:         base = to_datetime("2013-01-01 00:00:00", cache=cache)
 3303:         base = base.tz_localize("UTC").tz_convert(tz)
 3304:         dt_time = to_datetime(dt_string, cache=cache)
 3305:         assert base == dt_time
 3306:         assert dt_string_repr == repr(dt_time)
 3307: 
 3308: 
 3309: @pytest.fixture(params=["D", "s", "ms", "us", "ns"])
 3310: def units(request):
 3311:     """Day and some time units.
 3312: 
 3313:     * D
 3314:     * s
 3315:     * ms
 3316:     * us
 3317:     * ns
 3318:     """
 3319:     return request.param
 3320: 
 3321: 
 3322: @pytest.fixture
 3323: def epoch_1960():
 3324:     """Timestamp at 1960-01-01."""
 3325:     return Timestamp("1960-01-01")
 3326: 
 3327: 
 3328: @pytest.fixture
 3329: def units_from_epochs():
 3330:     return list(range(5))
 3331: 
 3332: 
 3333: @pytest.fixture(params=["timestamp", "pydatetime", "datetime64", "str_1960"])
 3334: def epochs(epoch_1960, request):
 3335:     """Timestamp at 1960-01-01 in various forms.
 3336: 
 3337:     * Timestamp
 3338:     * datetime.datetime
 3339:     * numpy.datetime64
 3340:     * str
 3341:     """
 3342:     assert request.param in {"timestamp", "pydatetime", "datetime64", "str_1960"}
 3343:     if request.param == "timestamp":
 3344:         return epoch_1960
 3345:     elif request.param == "pydatetime":
 3346:         return epoch_1960.to_pydatetime()
 3347:     elif request.param == "datetime64":
 3348:         return epoch_1960.to_datetime64()
 3349:     else:
 3350:         return str(epoch_1960)
 3351: 
 3352: 
 3353: @pytest.fixture
 3354: def julian_dates():
 3355:     return date_range("2014-1-1", periods=10).to_julian_date().values
 3356: 
 3357: 
 3358: class TestOrigin:
 3359:     def test_origin_and_unit(self):
 3360:         # GH#42624
 3361:         ts = to_datetime(1, unit="s", origin=1)
 3362:         expected = Timestamp("1970-01-01 00:00:02")
 3363:         assert ts == expected
 3364: 
 3365:         ts = to_datetime(1, unit="s", origin=1_000_000_000)
 3366:         expected = Timestamp("2001-09-09 01:46:41")
 3367:         assert ts == expected
 3368: 
 3369:     def test_julian(self, julian_dates):
 3370:         # gh-11276, gh-11745
 3371:         # for origin as julian
 3372: 
 3373:         result = Series(to_datetime(julian_dates, unit="D", origin="julian"))
 3374:         expected = Series(
 3375:             to_datetime(julian_dates - Timestamp(0).to_julian_date(), unit="D")
 3376:         )
 3377:         tm.assert_series_equal(result, expected)
 3378: 
 3379:     def test_unix(self):
 3380:         result = Series(to_datetime([0, 1, 2], unit="D", origin="unix"))
 3381:         expected = Series(
 3382:             [Timestamp("1970-01-01"), Timestamp("1970-01-02"), Timestamp("1970-01-03")],
 3383:             dtype="M8[ns]",
 3384:         )
 3385:         tm.assert_series_equal(result, expected)
 3386: 
 3387:     def test_julian_round_trip(self):
 3388:         result = to_datetime(2456658, origin="julian", unit="D")
 3389:         assert result.to_julian_date() == 2456658
 3390: 
 3391:         # out-of-bounds
 3392:         msg = "1 is Out of Bounds for origin='julian'"
 3393:         with pytest.raises(ValueError, match=msg):
 3394:             to_datetime(1, origin="julian", unit="D")
 3395: 
 3396:     def test_invalid_unit(self, units, julian_dates):
 3397:         # checking for invalid combination of origin='julian' and unit != D
 3398:         if units != "D":
 3399:             msg = "unit must be 'D' for origin='julian'"
 3400:             with pytest.raises(ValueError, match=msg):
 3401:                 to_datetime(julian_dates, unit=units, origin="julian")
 3402: 
 3403:     @pytest.mark.parametrize("unit", ["ns", "D"])
 3404:     def test_invalid_origin(self, unit):
 3405:         # need to have a numeric specified
 3406:         msg = "it must be numeric with a unit specified"
 3407:         with pytest.raises(ValueError, match=msg):
 3408:             to_datetime("2005-01-01", origin="1960-01-01", unit=unit)
 3409: 
 3410:     def test_epoch(self, units, epochs, epoch_1960, units_from_epochs):
 3411:         expected = Series(
 3412:             [pd.Timedelta(x, unit=units) + epoch_1960 for x in units_from_epochs]
 3413:         )
 3414: 
 3415:         result = Series(to_datetime(units_from_epochs, unit=units, origin=epochs))
 3416:         tm.assert_series_equal(result, expected)
 3417: 
 3418:     @pytest.mark.parametrize(
 3419:         "origin, exc",
 3420:         [
 3421:             ("random_string", ValueError),
 3422:             ("epoch", ValueError),
 3423:             ("13-24-1990", ValueError),
 3424:             (datetime(1, 1, 1), OutOfBoundsDatetime),
 3425:         ],
 3426:     )
 3427:     def test_invalid_origins(self, origin, exc, units, units_from_epochs):
 3428:         msg = "|".join(
 3429:             [
 3430:                 f"origin {origin} is Out of Bounds",
 3431:                 f"origin {origin} cannot be converted to a Timestamp",
 3432:                 "Cannot cast .* to unit='ns' without overflow",
 3433:             ]
 3434:         )
 3435:         with pytest.raises(exc, match=msg):
 3436:             to_datetime(units_from_epochs, unit=units, origin=origin)
 3437: 
 3438:     def test_invalid_origins_tzinfo(self):
 3439:         # GH16842
 3440:         with pytest.raises(ValueError, match="must be tz-naive"):
 3441:             to_datetime(1, unit="D", origin=datetime(2000, 1, 1, tzinfo=pytz.utc))
 3442: 
 3443:     def test_incorrect_value_exception(self):
 3444:         # GH47495
 3445:         msg = (
 3446:             "Unknown datetime string format, unable to parse: yesterday, at position 1"
 3447:         )
 3448:         with pytest.raises(ValueError, match=msg):
 3449:             to_datetime(["today", "yesterday"])
 3450: 
 3451:     @pytest.mark.parametrize(
 3452:         "format, warning",
 3453:         [
 3454:             (None, UserWarning),
 3455:             ("%Y-%m-%d %H:%M:%S", None),
 3456:             ("%Y-%d-%m %H:%M:%S", None),
 3457:         ],
 3458:     )
 3459:     def test_to_datetime_out_of_bounds_with_format_arg(self, format, warning):
 3460:         # see gh-23830
 3461:         msg = r"^Out of bounds nanosecond timestamp: 2417-10-10 00:00:00, at position 0"
 3462:         with pytest.raises(OutOfBoundsDatetime, match=msg):
 3463:             to_datetime("2417-10-10 00:00:00", format=format)
 3464: 
 3465:     @pytest.mark.parametrize(
 3466:         "arg, origin, expected_str",
 3467:         [
 3468:             [200 * 365, "unix", "2169-11-13 00:00:00"],
 3469:             [200 * 365, "1870-01-01", "2069-11-13 00:00:00"],
 3470:             [300 * 365, "1870-01-01", "2169-10-20 00:00:00"],
 3471:         ],
 3472:     )
 3473:     def test_processing_order(self, arg, origin, expected_str):
 3474:         # make sure we handle out-of-bounds *before*
 3475:         # constructing the dates
 3476: 
 3477:         result = to_datetime(arg, unit="D", origin=origin)
 3478:         expected = Timestamp(expected_str)
 3479:         assert result == expected
 3480: 
 3481:         result = to_datetime(200 * 365, unit="D", origin="1870-01-01")
 3482:         expected = Timestamp("2069-11-13 00:00:00")
 3483:         assert result == expected
 3484: 
 3485:         result = to_datetime(300 * 365, unit="D", origin="1870-01-01")
 3486:         expected = Timestamp("2169-10-20 00:00:00")
 3487:         assert result == expected
 3488: 
 3489:     @pytest.mark.parametrize(
 3490:         "offset,utc,exp",
 3491:         [
 3492:             ["Z", True, "2019-01-01T00:00:00.000Z"],
 3493:             ["Z", None, "2019-01-01T00:00:00.000Z"],
 3494:             ["-01:00", True, "2019-01-01T01:00:00.000Z"],
 3495:             ["-01:00", None, "2019-01-01T00:00:00.000-01:00"],
 3496:         ],
 3497:     )
 3498:     def test_arg_tz_ns_unit(self, offset, utc, exp):
 3499:         # GH 25546
 3500:         arg = "2019-01-01T00:00:00.000" + offset
 3501:         result = to_datetime([arg], unit="ns", utc=utc)
 3502:         expected = to_datetime([exp]).as_unit("ns")
 3503:         tm.assert_index_equal(result, expected)
 3504: 
 3505: 
 3506: class TestShouldCache:
 3507:     @pytest.mark.parametrize(
 3508:         "listlike,do_caching",
 3509:         [
 3510:             ([1, 2, 3, 4, 5, 6, 7, 8, 9, 0], False),
 3511:             ([1, 1, 1, 1, 4, 5, 6, 7, 8, 9], True),
 3512:         ],
 3513:     )
 3514:     def test_should_cache(self, listlike, do_caching):
 3515:         assert (
 3516:             tools.should_cache(listlike, check_count=len(listlike), unique_share=0.7)
 3517:             == do_caching
 3518:         )
 3519: 
 3520:     @pytest.mark.parametrize(
 3521:         "unique_share,check_count, err_message",
 3522:         [
 3523:             (0.5, 11, r"check_count must be in next bounds: \[0; len\(arg\)\]"),
 3524:             (10, 2, r"unique_share must be in next bounds: \(0; 1\)"),
 3525:         ],
 3526:     )
 3527:     def test_should_cache_errors(self, unique_share, check_count, err_message):
 3528:         arg = [5] * 10
 3529: 
 3530:         with pytest.raises(AssertionError, match=err_message):
 3531:             tools.should_cache(arg, unique_share, check_count)
 3532: 
 3533:     @pytest.mark.parametrize(
 3534:         "listlike",
 3535:         [
 3536:             (deque([Timestamp("2010-06-02 09:30:00")] * 51)),
 3537:             ([Timestamp("2010-06-02 09:30:00")] * 51),
 3538:             (tuple([Timestamp("2010-06-02 09:30:00")] * 51)),
 3539:         ],
 3540:     )
 3541:     def test_no_slicing_errors_in_should_cache(self, listlike):
 3542:         # GH#29403
 3543:         assert tools.should_cache(listlike) is True
 3544: 
 3545: 
 3546: def test_nullable_integer_to_datetime():
 3547:     # Test for #30050
 3548:     ser = Series([1, 2, None, 2**61, None])
 3549:     ser = ser.astype("Int64")
 3550:     ser_copy = ser.copy()
 3551: 
 3552:     res = to_datetime(ser, unit="ns")
 3553: 
 3554:     expected = Series(
 3555:         [
 3556:             np.datetime64("1970-01-01 00:00:00.000000001"),
 3557:             np.datetime64("1970-01-01 00:00:00.000000002"),
 3558:             np.datetime64("NaT"),
 3559:             np.datetime64("2043-01-25 23:56:49.213693952"),
 3560:             np.datetime64("NaT"),
 3561:         ]
 3562:     )
 3563:     tm.assert_series_equal(res, expected)
 3564:     # Check that ser isn't mutated
 3565:     tm.assert_series_equal(ser, ser_copy)
 3566: 
 3567: 
 3568: @pytest.mark.parametrize("klass", [np.array, list])
 3569: def test_na_to_datetime(nulls_fixture, klass):
 3570:     if isinstance(nulls_fixture, Decimal):
 3571:         with pytest.raises(TypeError, match="not convertible to datetime"):
 3572:             to_datetime(klass([nulls_fixture]))
 3573: 
 3574:     else:
 3575:         result = to_datetime(klass([nulls_fixture]))
 3576: 
 3577:         assert result[0] is NaT
 3578: 
 3579: 
 3580: @pytest.mark.parametrize("errors", ["raise", "coerce", "ignore"])
 3581: @pytest.mark.parametrize(
 3582:     "args, format",
 3583:     [
 3584:         (["03/24/2016", "03/25/2016", ""], "%m/%d/%Y"),
 3585:         (["2016-03-24", "2016-03-25", ""], "%Y-%m-%d"),
 3586:     ],
 3587:     ids=["non-ISO8601", "ISO8601"],
 3588: )
 3589: def test_empty_string_datetime(errors, args, format):
 3590:     # GH13044, GH50251
 3591:     td = Series(args)
 3592: 
 3593:     # coerce empty string to pd.NaT
 3594:     result = to_datetime(td, format=format, errors=errors)
 3595:     expected = Series(["2016-03-24", "2016-03-25", NaT], dtype="datetime64[ns]")
 3596:     tm.assert_series_equal(expected, result)
 3597: 
 3598: 
 3599: def test_empty_string_datetime_coerce__unit():
 3600:     # GH13044
 3601:     # coerce empty string to pd.NaT
 3602:     result = to_datetime([1, ""], unit="s", errors="coerce")
 3603:     expected = DatetimeIndex(["1970-01-01 00:00:01", "NaT"], dtype="datetime64[ns]")
 3604:     tm.assert_index_equal(expected, result)
 3605: 
 3606:     # verify that no exception is raised even when errors='raise' is set
 3607:     result = to_datetime([1, ""], unit="s", errors="raise")
 3608:     tm.assert_index_equal(expected, result)
 3609: 
 3610: 
 3611: @pytest.mark.parametrize("cache", [True, False])
 3612: def test_to_datetime_monotonic_increasing_index(cache):
 3613:     # GH28238
 3614:     cstart = start_caching_at
 3615:     times = date_range(Timestamp("1980"), periods=cstart, freq="YS")
 3616:     times = times.to_frame(index=False, name="DT").sample(n=cstart, random_state=1)
 3617:     times.index = times.index.to_series().astype(float) / 1000
 3618:     result = to_datetime(times.iloc[:, 0], cache=cache)
 3619:     expected = times.iloc[:, 0]
 3620:     tm.assert_series_equal(result, expected)
 3621: 
 3622: 
 3623: @pytest.mark.parametrize(
 3624:     "series_length",
 3625:     [40, start_caching_at, (start_caching_at + 1), (start_caching_at + 5)],
 3626: )
 3627: def test_to_datetime_cache_coerce_50_lines_outofbounds(series_length):
 3628:     # GH#45319
 3629:     ser = Series(
 3630:         [datetime.fromisoformat("1446-04-12 00:00:00+00:00")]
 3631:         + ([datetime.fromisoformat("1991-10-20 00:00:00+00:00")] * series_length),
 3632:         dtype=object,
 3633:     )
 3634:     result1 = to_datetime(ser, errors="coerce", utc=True)
 3635: 
 3636:     expected1 = Series(
 3637:         [NaT] + ([Timestamp("1991-10-20 00:00:00+00:00")] * series_length)
 3638:     )
 3639: 
 3640:     tm.assert_series_equal(result1, expected1)
 3641: 
 3642:     result2 = to_datetime(ser, errors="ignore", utc=True)
 3643: 
 3644:     expected2 = Series(
 3645:         [datetime.fromisoformat("1446-04-12 00:00:00+00:00")]
 3646:         + ([datetime.fromisoformat("1991-10-20 00:00:00+00:00")] * series_length)
 3647:     )
 3648: 
 3649:     tm.assert_series_equal(result2, expected2)
 3650: 
 3651:     with pytest.raises(OutOfBoundsDatetime, match="Out of bounds nanosecond timestamp"):
 3652:         to_datetime(ser, errors="raise", utc=True)
 3653: 
 3654: 
 3655: def test_to_datetime_format_f_parse_nanos():
 3656:     # GH 48767
 3657:     timestamp = "15/02/2020 02:03:04.123456789"
 3658:     timestamp_format = "%d/%m/%Y %H:%M:%S.%f"
 3659:     result = to_datetime(timestamp, format=timestamp_format)
 3660:     expected = Timestamp(
 3661:         year=2020,
 3662:         month=2,
 3663:         day=15,
 3664:         hour=2,
 3665:         minute=3,
 3666:         second=4,
 3667:         microsecond=123456,
 3668:         nanosecond=789,
 3669:     )
 3670:     assert result == expected
 3671: 
 3672: 
 3673: def test_to_datetime_mixed_iso8601():
 3674:     # https://github.com/pandas-dev/pandas/issues/50411
 3675:     result = to_datetime(["2020-01-01", "2020-01-01 05:00:00"], format="ISO8601")
 3676:     expected = DatetimeIndex(["2020-01-01 00:00:00", "2020-01-01 05:00:00"])
 3677:     tm.assert_index_equal(result, expected)
 3678: 
 3679: 
 3680: def test_to_datetime_mixed_other():
 3681:     # https://github.com/pandas-dev/pandas/issues/50411
 3682:     result = to_datetime(["01/11/2000", "12 January 2000"], format="mixed")
 3683:     expected = DatetimeIndex(["2000-01-11", "2000-01-12"])
 3684:     tm.assert_index_equal(result, expected)
 3685: 
 3686: 
 3687: @pytest.mark.parametrize("exact", [True, False])
 3688: @pytest.mark.parametrize("format", ["ISO8601", "mixed"])
 3689: def test_to_datetime_mixed_or_iso_exact(exact, format):
 3690:     msg = "Cannot use 'exact' when 'format' is 'mixed' or 'ISO8601'"
 3691:     with pytest.raises(ValueError, match=msg):
 3692:         to_datetime(["2020-01-01"], exact=exact, format=format)
 3693: 
 3694: 
 3695: def test_to_datetime_mixed_not_necessarily_iso8601_raise():
 3696:     # https://github.com/pandas-dev/pandas/issues/50411
 3697:     with pytest.raises(
 3698:         ValueError, match="Time data 01-01-2000 is not ISO8601 format, at position 1"
 3699:     ):
 3700:         to_datetime(["2020-01-01", "01-01-2000"], format="ISO8601")
 3701: 
 3702: 
 3703: @pytest.mark.parametrize(
 3704:     ("errors", "expected"),
 3705:     [
 3706:         ("coerce", DatetimeIndex(["2020-01-01 00:00:00", NaT])),
 3707:         ("ignore", Index(["2020-01-01", "01-01-2000"], dtype=object)),
 3708:     ],
 3709: )
 3710: def test_to_datetime_mixed_not_necessarily_iso8601_coerce(errors, expected):
 3711:     # https://github.com/pandas-dev/pandas/issues/50411
 3712:     result = to_datetime(["2020-01-01", "01-01-2000"], format="ISO8601", errors=errors)
 3713:     tm.assert_index_equal(result, expected)
 3714: 
 3715: 
 3716: def test_ignoring_unknown_tz_deprecated():
 3717:     # GH#18702, GH#51476
 3718:     dtstr = "2014 Jan 9 05:15 FAKE"
 3719:     msg = 'un-recognized timezone "FAKE". Dropping unrecognized timezones is deprecated'
 3720:     with tm.assert_produces_warning(FutureWarning, match=msg):
 3721:         res = Timestamp(dtstr)
 3722:     assert res == Timestamp(dtstr[:-5])
 3723: 
 3724:     with tm.assert_produces_warning(FutureWarning):
 3725:         res = to_datetime(dtstr)
 3726:     assert res == to_datetime(dtstr[:-5])
 3727:     with tm.assert_produces_warning(FutureWarning):
 3728:         res = to_datetime([dtstr])
 3729:     tm.assert_index_equal(res, to_datetime([dtstr[:-5]]))
 3730: 
 3731: 
 3732: def test_from_numeric_arrow_dtype(any_numeric_ea_dtype):
 3733:     # GH 52425
 3734:     pytest.importorskip("pyarrow")
 3735:     ser = Series([1, 2], dtype=f"{any_numeric_ea_dtype.lower()}[pyarrow]")
 3736:     result = to_datetime(ser)
 3737:     expected = Series([1, 2], dtype="datetime64[ns]")
 3738:     tm.assert_series_equal(result, expected)
 3739: 
 3740: 
 3741: def test_to_datetime_with_empty_str_utc_false_format_mixed():
 3742:     # GH 50887
 3743:     vals = ["2020-01-01 00:00+00:00", ""]
 3744:     result = to_datetime(vals, format="mixed")
 3745:     expected = Index([Timestamp("2020-01-01 00:00+00:00"), "NaT"], dtype="M8[ns, UTC]")
 3746:     tm.assert_index_equal(result, expected)
 3747: 
 3748:     # Check that a couple of other similar paths work the same way
 3749:     alt = to_datetime(vals)
 3750:     tm.assert_index_equal(alt, expected)
 3751:     alt2 = DatetimeIndex(vals)
 3752:     tm.assert_index_equal(alt2, expected)
 3753: 
 3754: 
 3755: def test_to_datetime_with_empty_str_utc_false_offsets_and_format_mixed():
 3756:     # GH 50887
 3757:     msg = "parsing datetimes with mixed time zones will raise an error"
 3758: 
 3759:     with tm.assert_produces_warning(FutureWarning, match=msg):
 3760:         to_datetime(
 3761:             ["2020-01-01 00:00+00:00", "2020-01-01 00:00+02:00", ""], format="mixed"
 3762:         )
 3763: 
 3764: 
 3765: def test_to_datetime_mixed_tzs_mixed_types():
 3766:     # GH#55793, GH#55693 mismatched tzs but one is str and other is
 3767:     #  datetime object
 3768:     ts = Timestamp("2016-01-02 03:04:05", tz="US/Pacific")
 3769:     dtstr = "2023-10-30 15:06+01"
 3770:     arr = [ts, dtstr]
 3771: 
 3772:     msg = (
 3773:         "Mixed timezones detected. pass utc=True in to_datetime or tz='UTC' "
 3774:         "in DatetimeIndex to convert to a common timezone"
 3775:     )
 3776:     with pytest.raises(ValueError, match=msg):
 3777:         to_datetime(arr)
 3778:     with pytest.raises(ValueError, match=msg):
 3779:         to_datetime(arr, format="mixed")
 3780:     with pytest.raises(ValueError, match=msg):
 3781:         DatetimeIndex(arr)
 3782: 
 3783: 
 3784: def test_to_datetime_mixed_types_matching_tzs():
 3785:     # GH#55793
 3786:     dtstr = "2023-11-01 09:22:03-07:00"
 3787:     ts = Timestamp(dtstr)
 3788:     arr = [ts, dtstr]
 3789:     res1 = to_datetime(arr)
 3790:     res2 = to_datetime(arr[::-1])[::-1]
 3791:     res3 = to_datetime(arr, format="mixed")
 3792:     res4 = DatetimeIndex(arr)
 3793: 
 3794:     expected = DatetimeIndex([ts, ts])
 3795:     tm.assert_index_equal(res1, expected)
 3796:     tm.assert_index_equal(res2, expected)
 3797:     tm.assert_index_equal(res3, expected)
 3798:     tm.assert_index_equal(res4, expected)
 3799: 
 3800: 
 3801: dtstr = "2020-01-01 00:00+00:00"
 3802: ts = Timestamp(dtstr)
 3803: 
 3804: 
 3805: @pytest.mark.filterwarnings("ignore:Could not infer format:UserWarning")
 3806: @pytest.mark.parametrize(
 3807:     "aware_val",
 3808:     [dtstr, Timestamp(dtstr)],
 3809:     ids=lambda x: type(x).__name__,
 3810: )
 3811: @pytest.mark.parametrize(
 3812:     "naive_val",
 3813:     [dtstr[:-6], ts.tz_localize(None), ts.date(), ts.asm8, ts.value, float(ts.value)],
 3814:     ids=lambda x: type(x).__name__,
 3815: )
 3816: @pytest.mark.parametrize("naive_first", [True, False])
 3817: def test_to_datetime_mixed_awareness_mixed_types(aware_val, naive_val, naive_first):
 3818:     # GH#55793, GH#55693
 3819:     # Empty string parses to NaT
 3820:     vals = [aware_val, naive_val, ""]
 3821: 
 3822:     vec = vals
 3823:     if naive_first:
 3824:         # alas, the behavior is order-dependent, so we test both ways
 3825:         vec = [naive_val, aware_val, ""]
 3826: 
 3827:     # both_strs-> paths that were previously already deprecated with warning
 3828:     #  issued in _array_to_datetime_object
 3829:     both_strs = isinstance(aware_val, str) and isinstance(naive_val, str)
 3830:     has_numeric = isinstance(naive_val, (int, float))
 3831: 
 3832:     depr_msg = "In a future version of pandas, parsing datetimes with mixed time zones"
 3833: 
 3834:     first_non_null = next(x for x in vec if x != "")
 3835:     # if first_non_null is a not a string, _guess_datetime_format_for_array
 3836:     #  doesn't guess a format so we don't go through array_strptime
 3837:     if not isinstance(first_non_null, str):
 3838:         # that case goes through array_strptime which has different behavior
 3839:         msg = "Cannot mix tz-aware with tz-naive values"
 3840:         if naive_first and isinstance(aware_val, Timestamp):
 3841:             if isinstance(naive_val, Timestamp):
 3842:                 msg = "Tz-aware datetime.datetime cannot be converted to datetime64"
 3843:             with pytest.raises(ValueError, match=msg):
 3844:                 to_datetime(vec)
 3845:         else:
 3846:             with pytest.raises(ValueError, match=msg):
 3847:                 to_datetime(vec)
 3848: 
 3849:         # No warning/error with utc=True
 3850:         to_datetime(vec, utc=True)
 3851: 
 3852:     elif has_numeric and vec.index(aware_val) < vec.index(naive_val):
 3853:         msg = "time data .* doesn't match format"
 3854:         with pytest.raises(ValueError, match=msg):
 3855:             to_datetime(vec)
 3856:         with pytest.raises(ValueError, match=msg):
 3857:             to_datetime(vec, utc=True)
 3858: 
 3859:     elif both_strs and vec.index(aware_val) < vec.index(naive_val):
 3860:         msg = r"time data \"2020-01-01 00:00\" doesn't match format"
 3861:         with pytest.raises(ValueError, match=msg):
 3862:             to_datetime(vec)
 3863:         with pytest.raises(ValueError, match=msg):
 3864:             to_datetime(vec, utc=True)
 3865: 
 3866:     elif both_strs and vec.index(naive_val) < vec.index(aware_val):
 3867:         msg = "unconverted data remains when parsing with format"
 3868:         with pytest.raises(ValueError, match=msg):
 3869:             to_datetime(vec)
 3870:         with pytest.raises(ValueError, match=msg):
 3871:             to_datetime(vec, utc=True)
 3872: 
 3873:     else:
 3874:         with tm.assert_produces_warning(FutureWarning, match=depr_msg):
 3875:             to_datetime(vec)
 3876: 
 3877:         # No warning/error with utc=True
 3878:         to_datetime(vec, utc=True)
 3879: 
 3880:     if both_strs:
 3881:         with tm.assert_produces_warning(FutureWarning, match=depr_msg):
 3882:             to_datetime(vec, format="mixed")
 3883:         with tm.assert_produces_warning(FutureWarning, match=depr_msg):
 3884:             msg = "DatetimeIndex has mixed timezones"
 3885:             with pytest.raises(TypeError, match=msg):
 3886:                 DatetimeIndex(vec)
 3887:     else:
 3888:         msg = "Cannot mix tz-aware with tz-naive values"
 3889:         if naive_first and isinstance(aware_val, Timestamp):
 3890:             if isinstance(naive_val, Timestamp):
 3891:                 msg = "Tz-aware datetime.datetime cannot be converted to datetime64"
 3892:             with pytest.raises(ValueError, match=msg):
 3893:                 to_datetime(vec, format="mixed")
 3894:             with pytest.raises(ValueError, match=msg):
 3895:                 DatetimeIndex(vec)
 3896:         else:
 3897:             with pytest.raises(ValueError, match=msg):
 3898:                 to_datetime(vec, format="mixed")
 3899:             with pytest.raises(ValueError, match=msg):
 3900:                 DatetimeIndex(vec)
