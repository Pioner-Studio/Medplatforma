    1: from datetime import (
    2:     time,
    3:     timedelta,
    4: )
    5: 
    6: import numpy as np
    7: import pytest
    8: 
    9: from pandas.compat import IS64
   10: from pandas.errors import OutOfBoundsTimedelta
   11: 
   12: import pandas as pd
   13: from pandas import (
   14:     Series,
   15:     TimedeltaIndex,
   16:     isna,
   17:     to_timedelta,
   18: )
   19: import pandas._testing as tm
   20: from pandas.core.arrays import TimedeltaArray
   21: 
   22: 
   23: class TestTimedeltas:
   24:     def test_to_timedelta_dt64_raises(self):
   25:         # Passing datetime64-dtype data to TimedeltaIndex is no longer
   26:         #  supported GH#29794
   27:         msg = r"dtype datetime64\[ns\] cannot be converted to timedelta64\[ns\]"
   28: 
   29:         ser = Series([pd.NaT])
   30:         with pytest.raises(TypeError, match=msg):
   31:             to_timedelta(ser)
   32:         with pytest.raises(TypeError, match=msg):
   33:             ser.to_frame().apply(to_timedelta)
   34: 
   35:     @pytest.mark.parametrize("readonly", [True, False])
   36:     def test_to_timedelta_readonly(self, readonly):
   37:         # GH#34857
   38:         arr = np.array([], dtype=object)
   39:         if readonly:
   40:             arr.setflags(write=False)
   41:         result = to_timedelta(arr)
   42:         expected = to_timedelta([])
   43:         tm.assert_index_equal(result, expected)
   44: 
   45:     def test_to_timedelta_null(self):
   46:         result = to_timedelta(["", ""])
   47:         assert isna(result).all()
   48: 
   49:     def test_to_timedelta_same_np_timedelta64(self):
   50:         # pass thru
   51:         result = to_timedelta(np.array([np.timedelta64(1, "s")]))
   52:         expected = pd.Index(np.array([np.timedelta64(1, "s")]))
   53:         tm.assert_index_equal(result, expected)
   54: 
   55:     def test_to_timedelta_series(self):
   56:         # Series
   57:         expected = Series([timedelta(days=1), timedelta(days=1, seconds=1)])
   58:         result = to_timedelta(Series(["1d", "1days 00:00:01"]))
   59:         tm.assert_series_equal(result, expected)
   60: 
   61:     def test_to_timedelta_units(self):
   62:         # with units
   63:         result = TimedeltaIndex(
   64:             [np.timedelta64(0, "ns"), np.timedelta64(10, "s").astype("m8[ns]")]
   65:         )
   66:         expected = to_timedelta([0, 10], unit="s")
   67:         tm.assert_index_equal(result, expected)
   68: 
   69:     @pytest.mark.parametrize(
   70:         "dtype, unit",
   71:         [
   72:             ["int64", "s"],
   73:             ["int64", "m"],
   74:             ["int64", "h"],
   75:             ["timedelta64[s]", "s"],
   76:             ["timedelta64[D]", "D"],
   77:         ],
   78:     )
   79:     def test_to_timedelta_units_dtypes(self, dtype, unit):
   80:         # arrays of various dtypes
   81:         arr = np.array([1] * 5, dtype=dtype)
   82:         result = to_timedelta(arr, unit=unit)
   83:         exp_dtype = "m8[ns]" if dtype == "int64" else "m8[s]"
   84:         expected = TimedeltaIndex([np.timedelta64(1, unit)] * 5, dtype=exp_dtype)
   85:         tm.assert_index_equal(result, expected)
   86: 
   87:     def test_to_timedelta_oob_non_nano(self):
   88:         arr = np.array([pd.NaT._value + 1], dtype="timedelta64[m]")
   89: 
   90:         msg = (
   91:             "Cannot convert -9223372036854775807 minutes to "
   92:             r"timedelta64\[s\] without overflow"
   93:         )
   94:         with pytest.raises(OutOfBoundsTimedelta, match=msg):
   95:             to_timedelta(arr)
   96: 
   97:         with pytest.raises(OutOfBoundsTimedelta, match=msg):
   98:             TimedeltaIndex(arr)
   99: 
  100:         with pytest.raises(OutOfBoundsTimedelta, match=msg):
  101:             TimedeltaArray._from_sequence(arr, dtype="m8[s]")
  102: 
  103:     @pytest.mark.parametrize(
  104:         "arg", [np.arange(10).reshape(2, 5), pd.DataFrame(np.arange(10).reshape(2, 5))]
  105:     )
  106:     @pytest.mark.parametrize("errors", ["ignore", "raise", "coerce"])
  107:     @pytest.mark.filterwarnings("ignore:errors='ignore' is deprecated:FutureWarning")
  108:     def test_to_timedelta_dataframe(self, arg, errors):
  109:         # GH 11776
  110:         with pytest.raises(TypeError, match="1-d array"):
  111:             to_timedelta(arg, errors=errors)
  112: 
  113:     def test_to_timedelta_invalid_errors(self):
  114:         # bad value for errors parameter
  115:         msg = "errors must be one of"
  116:         with pytest.raises(ValueError, match=msg):
  117:             to_timedelta(["foo"], errors="never")
  118: 
  119:     @pytest.mark.parametrize("arg", [[1, 2], 1])
  120:     def test_to_timedelta_invalid_unit(self, arg):
  121:         # these will error
  122:         msg = "invalid unit abbreviation: foo"
  123:         with pytest.raises(ValueError, match=msg):
  124:             to_timedelta(arg, unit="foo")
  125: 
  126:     def test_to_timedelta_time(self):
  127:         # time not supported ATM
  128:         msg = (
  129:             "Value must be Timedelta, string, integer, float, timedelta or convertible"
  130:         )
  131:         with pytest.raises(ValueError, match=msg):
  132:             to_timedelta(time(second=1))
  133:         assert to_timedelta(time(second=1), errors="coerce") is pd.NaT
  134: 
  135:     def test_to_timedelta_bad_value(self):
  136:         msg = "Could not convert 'foo' to NumPy timedelta"
  137:         with pytest.raises(ValueError, match=msg):
  138:             to_timedelta(["foo", "bar"])
  139: 
  140:     def test_to_timedelta_bad_value_coerce(self):
  141:         tm.assert_index_equal(
  142:             TimedeltaIndex([pd.NaT, pd.NaT]),
  143:             to_timedelta(["foo", "bar"], errors="coerce"),
  144:         )
  145: 
  146:         tm.assert_index_equal(
  147:             TimedeltaIndex(["1 day", pd.NaT, "1 min"]),
  148:             to_timedelta(["1 day", "bar", "1 min"], errors="coerce"),
  149:         )
  150: 
  151:     def test_to_timedelta_invalid_errors_ignore(self):
  152:         # gh-13613: these should not error because errors='ignore'
  153:         msg = "errors='ignore' is deprecated"
  154:         invalid_data = "apple"
  155: 
  156:         with tm.assert_produces_warning(FutureWarning, match=msg):
  157:             result = to_timedelta(invalid_data, errors="ignore")
  158:         assert invalid_data == result
  159: 
  160:         invalid_data = ["apple", "1 days"]
  161:         expected = np.array(invalid_data, dtype=object)
  162: 
  163:         with tm.assert_produces_warning(FutureWarning, match=msg):
  164:             result = to_timedelta(invalid_data, errors="ignore")
  165:         tm.assert_numpy_array_equal(expected, result)
  166: 
  167:         invalid_data = pd.Index(["apple", "1 days"])
  168:         with tm.assert_produces_warning(FutureWarning, match=msg):
  169:             result = to_timedelta(invalid_data, errors="ignore")
  170:         tm.assert_index_equal(invalid_data, result)
  171: 
  172:         invalid_data = Series(["apple", "1 days"])
  173:         with tm.assert_produces_warning(FutureWarning, match=msg):
  174:             result = to_timedelta(invalid_data, errors="ignore")
  175:         tm.assert_series_equal(invalid_data, result)
  176: 
  177:     @pytest.mark.parametrize(
  178:         "val, errors",
  179:         [
  180:             ("1M", True),
  181:             ("1 M", True),
  182:             ("1Y", True),
  183:             ("1 Y", True),
  184:             ("1y", True),
  185:             ("1 y", True),
  186:             ("1m", False),
  187:             ("1 m", False),
  188:             ("1 day", False),
  189:             ("2day", False),
  190:         ],
  191:     )
  192:     def test_unambiguous_timedelta_values(self, val, errors):
  193:         # GH36666 Deprecate use of strings denoting units with 'M', 'Y', 'm' or 'y'
  194:         # in pd.to_timedelta
  195:         msg = "Units 'M', 'Y' and 'y' do not represent unambiguous timedelta"
  196:         if errors:
  197:             with pytest.raises(ValueError, match=msg):
  198:                 to_timedelta(val)
  199:         else:
  200:             # check it doesn't raise
  201:             to_timedelta(val)
  202: 
  203:     def test_to_timedelta_via_apply(self):
  204:         # GH 5458
  205:         expected = Series([np.timedelta64(1, "s")])
  206:         result = Series(["00:00:01"]).apply(to_timedelta)
  207:         tm.assert_series_equal(result, expected)
  208: 
  209:         result = Series([to_timedelta("00:00:01")])
  210:         tm.assert_series_equal(result, expected)
  211: 
  212:     def test_to_timedelta_inference_without_warning(self):
  213:         # GH#41731 inference produces a warning in the Series constructor,
  214:         #  but _not_ in to_timedelta
  215:         vals = ["00:00:01", pd.NaT]
  216:         with tm.assert_produces_warning(None):
  217:             result = to_timedelta(vals)
  218: 
  219:         expected = TimedeltaIndex([pd.Timedelta(seconds=1), pd.NaT])
  220:         tm.assert_index_equal(result, expected)
  221: 
  222:     def test_to_timedelta_on_missing_values(self):
  223:         # GH5438
  224:         timedelta_NaT = np.timedelta64("NaT")
  225: 
  226:         actual = to_timedelta(Series(["00:00:01", np.nan]))
  227:         expected = Series(
  228:             [np.timedelta64(1000000000, "ns"), timedelta_NaT],
  229:             dtype=f"{tm.ENDIAN}m8[ns]",
  230:         )
  231:         tm.assert_series_equal(actual, expected)
  232: 
  233:         ser = Series(["00:00:01", pd.NaT], dtype="m8[ns]")
  234:         actual = to_timedelta(ser)
  235:         tm.assert_series_equal(actual, expected)
  236: 
  237:     @pytest.mark.parametrize("val", [np.nan, pd.NaT, pd.NA])
  238:     def test_to_timedelta_on_missing_values_scalar(self, val):
  239:         actual = to_timedelta(val)
  240:         assert actual._value == np.timedelta64("NaT").astype("int64")
  241: 
  242:     @pytest.mark.parametrize("val", [np.nan, pd.NaT, pd.NA])
  243:     def test_to_timedelta_on_missing_values_list(self, val):
  244:         actual = to_timedelta([val])
  245:         assert actual[0]._value == np.timedelta64("NaT").astype("int64")
  246: 
  247:     @pytest.mark.xfail(not IS64, reason="Floating point error")
  248:     def test_to_timedelta_float(self):
  249:         # https://github.com/pandas-dev/pandas/issues/25077
  250:         arr = np.arange(0, 1, 1e-6)[-10:]
  251:         result = to_timedelta(arr, unit="s")
  252:         expected_asi8 = np.arange(999990000, 10**9, 1000, dtype="int64")
  253:         tm.assert_numpy_array_equal(result.asi8, expected_asi8)
  254: 
  255:     def test_to_timedelta_coerce_strings_unit(self):
  256:         arr = np.array([1, 2, "error"], dtype=object)
  257:         result = to_timedelta(arr, unit="ns", errors="coerce")
  258:         expected = to_timedelta([1, 2, pd.NaT], unit="ns")
  259:         tm.assert_index_equal(result, expected)
  260: 
  261:     def test_to_timedelta_ignore_strings_unit(self):
  262:         arr = np.array([1, 2, "error"], dtype=object)
  263:         msg = "errors='ignore' is deprecated"
  264:         with tm.assert_produces_warning(FutureWarning, match=msg):
  265:             result = to_timedelta(arr, unit="ns", errors="ignore")
  266:         tm.assert_numpy_array_equal(result, arr)
  267: 
  268:     @pytest.mark.parametrize(
  269:         "expected_val, result_val", [[timedelta(days=2), 2], [None, None]]
  270:     )
  271:     def test_to_timedelta_nullable_int64_dtype(self, expected_val, result_val):
  272:         # GH 35574
  273:         expected = Series([timedelta(days=1), expected_val])
  274:         result = to_timedelta(Series([1, result_val], dtype="Int64"), unit="days")
  275: 
  276:         tm.assert_series_equal(result, expected)
  277: 
  278:     @pytest.mark.parametrize(
  279:         ("input", "expected"),
  280:         [
  281:             ("8:53:08.71800000001", "8:53:08.718"),
  282:             ("8:53:08.718001", "8:53:08.718001"),
  283:             ("8:53:08.7180000001", "8:53:08.7180000001"),
  284:             ("-8:53:08.71800000001", "-8:53:08.718"),
  285:             ("8:53:08.7180000089", "8:53:08.718000008"),
  286:         ],
  287:     )
  288:     @pytest.mark.parametrize("func", [pd.Timedelta, to_timedelta])
  289:     def test_to_timedelta_precision_over_nanos(self, input, expected, func):
  290:         # GH: 36738
  291:         expected = pd.Timedelta(expected)
  292:         result = func(input)
  293:         assert result == expected
  294: 
  295:     def test_to_timedelta_zerodim(self, fixed_now_ts):
  296:         # ndarray.item() incorrectly returns int for dt64[ns] and td64[ns]
  297:         dt64 = fixed_now_ts.to_datetime64()
  298:         arg = np.array(dt64)
  299: 
  300:         msg = (
  301:             "Value must be Timedelta, string, integer, float, timedelta "
  302:             "or convertible, not datetime64"
  303:         )
  304:         with pytest.raises(ValueError, match=msg):
  305:             to_timedelta(arg)
  306: 
  307:         arg2 = arg.view("m8[ns]")
  308:         result = to_timedelta(arg2)
  309:         assert isinstance(result, pd.Timedelta)
  310:         assert result._value == dt64.view("i8")
  311: 
  312:     def test_to_timedelta_numeric_ea(self, any_numeric_ea_dtype):
  313:         # GH#48796
  314:         ser = Series([1, pd.NA], dtype=any_numeric_ea_dtype)
  315:         result = to_timedelta(ser)
  316:         expected = Series([pd.Timedelta(1, unit="ns"), pd.NaT])
  317:         tm.assert_series_equal(result, expected)
  318: 
  319:     def test_to_timedelta_fraction(self):
  320:         result = to_timedelta(1.0 / 3, unit="h")
  321:         expected = pd.Timedelta("0 days 00:19:59.999999998")
  322:         assert result == expected
  323: 
  324: 
  325: def test_from_numeric_arrow_dtype(any_numeric_ea_dtype):
  326:     # GH 52425
  327:     pytest.importorskip("pyarrow")
  328:     ser = Series([1, 2], dtype=f"{any_numeric_ea_dtype.lower()}[pyarrow]")
  329:     result = to_timedelta(ser)
  330:     expected = Series([1, 2], dtype="timedelta64[ns]")
  331:     tm.assert_series_equal(result, expected)
  332: 
  333: 
  334: @pytest.mark.parametrize("unit", ["ns", "ms"])
  335: def test_from_timedelta_arrow_dtype(unit):
  336:     # GH 54298
  337:     pytest.importorskip("pyarrow")
  338:     expected = Series([timedelta(1)], dtype=f"duration[{unit}][pyarrow]")
  339:     result = to_timedelta(expected)
  340:     tm.assert_series_equal(result, expected)
