    1: import decimal
    2: 
    3: import numpy as np
    4: from numpy import iinfo
    5: import pytest
    6: 
    7: import pandas.util._test_decorators as td
    8: 
    9: import pandas as pd
   10: from pandas import (
   11:     ArrowDtype,
   12:     DataFrame,
   13:     Index,
   14:     Series,
   15:     option_context,
   16:     to_numeric,
   17: )
   18: import pandas._testing as tm
   19: 
   20: 
   21: @pytest.fixture(params=[None, "ignore", "raise", "coerce"])
   22: def errors(request):
   23:     return request.param
   24: 
   25: 
   26: @pytest.fixture(params=[True, False])
   27: def signed(request):
   28:     return request.param
   29: 
   30: 
   31: @pytest.fixture(params=[lambda x: x, str], ids=["identity", "str"])
   32: def transform(request):
   33:     return request.param
   34: 
   35: 
   36: @pytest.fixture(params=[47393996303418497800, 100000000000000000000])
   37: def large_val(request):
   38:     return request.param
   39: 
   40: 
   41: @pytest.fixture(params=[True, False])
   42: def multiple_elts(request):
   43:     return request.param
   44: 
   45: 
   46: @pytest.fixture(
   47:     params=[
   48:         (lambda x: Index(x, name="idx"), tm.assert_index_equal),
   49:         (lambda x: Series(x, name="ser"), tm.assert_series_equal),
   50:         (lambda x: np.array(Index(x).values), tm.assert_numpy_array_equal),
   51:     ]
   52: )
   53: def transform_assert_equal(request):
   54:     return request.param
   55: 
   56: 
   57: @pytest.mark.parametrize(
   58:     "input_kwargs,result_kwargs",
   59:     [
   60:         ({}, {"dtype": np.int64}),
   61:         ({"errors": "coerce", "downcast": "integer"}, {"dtype": np.int8}),
   62:     ],
   63: )
   64: def test_empty(input_kwargs, result_kwargs):
   65:     # see gh-16302
   66:     ser = Series([], dtype=object)
   67:     result = to_numeric(ser, **input_kwargs)
   68: 
   69:     expected = Series([], **result_kwargs)
   70:     tm.assert_series_equal(result, expected)
   71: 
   72: 
   73: @pytest.mark.parametrize(
   74:     "infer_string", [False, pytest.param(True, marks=td.skip_if_no("pyarrow"))]
   75: )
   76: @pytest.mark.parametrize("last_val", ["7", 7])
   77: def test_series(last_val, infer_string):
   78:     with option_context("future.infer_string", infer_string):
   79:         ser = Series(["1", "-3.14", last_val])
   80:         result = to_numeric(ser)
   81: 
   82:     expected = Series([1, -3.14, 7])
   83:     tm.assert_series_equal(result, expected)
   84: 
   85: 
   86: @pytest.mark.parametrize(
   87:     "data",
   88:     [
   89:         [1, 3, 4, 5],
   90:         [1.0, 3.0, 4.0, 5.0],
   91:         # Bool is regarded as numeric.
   92:         [True, False, True, True],
   93:     ],
   94: )
   95: def test_series_numeric(data):
   96:     ser = Series(data, index=list("ABCD"), name="EFG")
   97: 
   98:     result = to_numeric(ser)
   99:     tm.assert_series_equal(result, ser)
  100: 
  101: 
  102: @pytest.mark.parametrize(
  103:     "data,msg",
  104:     [
  105:         ([1, -3.14, "apple"], 'Unable to parse string "apple" at position 2'),
  106:         (
  107:             ["orange", 1, -3.14, "apple"],
  108:             'Unable to parse string "orange" at position 0',
  109:         ),
  110:     ],
  111: )
  112: def test_error(data, msg):
  113:     ser = Series(data)
  114: 
  115:     with pytest.raises(ValueError, match=msg):
  116:         to_numeric(ser, errors="raise")
  117: 
  118: 
  119: @pytest.mark.parametrize(
  120:     "errors,exp_data", [("ignore", [1, -3.14, "apple"]), ("coerce", [1, -3.14, np.nan])]
  121: )
  122: @pytest.mark.filterwarnings("ignore:errors='ignore' is deprecated:FutureWarning")
  123: def test_ignore_error(errors, exp_data):
  124:     ser = Series([1, -3.14, "apple"])
  125:     result = to_numeric(ser, errors=errors)
  126: 
  127:     expected = Series(exp_data)
  128:     tm.assert_series_equal(result, expected)
  129: 
  130: 
  131: @pytest.mark.parametrize(
  132:     "errors,exp",
  133:     [
  134:         ("raise", 'Unable to parse string "apple" at position 2'),
  135:         ("ignore", [True, False, "apple"]),
  136:         # Coerces to float.
  137:         ("coerce", [1.0, 0.0, np.nan]),
  138:     ],
  139: )
  140: @pytest.mark.filterwarnings("ignore:errors='ignore' is deprecated:FutureWarning")
  141: def test_bool_handling(errors, exp):
  142:     ser = Series([True, False, "apple"])
  143: 
  144:     if isinstance(exp, str):
  145:         with pytest.raises(ValueError, match=exp):
  146:             to_numeric(ser, errors=errors)
  147:     else:
  148:         result = to_numeric(ser, errors=errors)
  149:         expected = Series(exp)
  150: 
  151:         tm.assert_series_equal(result, expected)
  152: 
  153: 
  154: def test_list():
  155:     ser = ["1", "-3.14", "7"]
  156:     res = to_numeric(ser)
  157: 
  158:     expected = np.array([1, -3.14, 7])
  159:     tm.assert_numpy_array_equal(res, expected)
  160: 
  161: 
  162: @pytest.mark.parametrize(
  163:     "data,arr_kwargs",
  164:     [
  165:         ([1, 3, 4, 5], {"dtype": np.int64}),
  166:         ([1.0, 3.0, 4.0, 5.0], {}),
  167:         # Boolean is regarded as numeric.
  168:         ([True, False, True, True], {}),
  169:     ],
  170: )
  171: def test_list_numeric(data, arr_kwargs):
  172:     result = to_numeric(data)
  173:     expected = np.array(data, **arr_kwargs)
  174:     tm.assert_numpy_array_equal(result, expected)
  175: 
  176: 
  177: @pytest.mark.parametrize("kwargs", [{"dtype": "O"}, {}])
  178: def test_numeric(kwargs):
  179:     data = [1, -3.14, 7]
  180: 
  181:     ser = Series(data, **kwargs)
  182:     result = to_numeric(ser)
  183: 
  184:     expected = Series(data)
  185:     tm.assert_series_equal(result, expected)
  186: 
  187: 
  188: @pytest.mark.parametrize(
  189:     "columns",
  190:     [
  191:         # One column.
  192:         "a",
  193:         # Multiple columns.
  194:         ["a", "b"],
  195:     ],
  196: )
  197: def test_numeric_df_columns(columns):
  198:     # see gh-14827
  199:     df = DataFrame(
  200:         {
  201:             "a": [1.2, decimal.Decimal(3.14), decimal.Decimal("infinity"), "0.1"],
  202:             "b": [1.0, 2.0, 3.0, 4.0],
  203:         }
  204:     )
  205: 
  206:     expected = DataFrame({"a": [1.2, 3.14, np.inf, 0.1], "b": [1.0, 2.0, 3.0, 4.0]})
  207: 
  208:     df_copy = df.copy()
  209:     df_copy[columns] = df_copy[columns].apply(to_numeric)
  210: 
  211:     tm.assert_frame_equal(df_copy, expected)
  212: 
  213: 
  214: @pytest.mark.parametrize(
  215:     "data,exp_data",
  216:     [
  217:         (
  218:             [[decimal.Decimal(3.14), 1.0], decimal.Decimal(1.6), 0.1],
  219:             [[3.14, 1.0], 1.6, 0.1],
  220:         ),
  221:         ([np.array([decimal.Decimal(3.14), 1.0]), 0.1], [[3.14, 1.0], 0.1]),
  222:     ],
  223: )
  224: def test_numeric_embedded_arr_likes(data, exp_data):
  225:     # Test to_numeric with embedded lists and arrays
  226:     df = DataFrame({"a": data})
  227:     df["a"] = df["a"].apply(to_numeric)
  228: 
  229:     expected = DataFrame({"a": exp_data})
  230:     tm.assert_frame_equal(df, expected)
  231: 
  232: 
  233: def test_all_nan():
  234:     ser = Series(["a", "b", "c"])
  235:     result = to_numeric(ser, errors="coerce")
  236: 
  237:     expected = Series([np.nan, np.nan, np.nan])
  238:     tm.assert_series_equal(result, expected)
  239: 
  240: 
  241: @pytest.mark.filterwarnings("ignore:errors='ignore' is deprecated:FutureWarning")
  242: def test_type_check(errors):
  243:     # see gh-11776
  244:     df = DataFrame({"a": [1, -3.14, 7], "b": ["4", "5", "6"]})
  245:     kwargs = {"errors": errors} if errors is not None else {}
  246:     with pytest.raises(TypeError, match="1-d array"):
  247:         to_numeric(df, **kwargs)
  248: 
  249: 
  250: @pytest.mark.parametrize("val", [1, 1.1, 20001])
  251: def test_scalar(val, signed, transform):
  252:     val = -val if signed else val
  253:     assert to_numeric(transform(val)) == float(val)
  254: 
  255: 
  256: @pytest.mark.filterwarnings("ignore:errors='ignore' is deprecated:FutureWarning")
  257: def test_really_large_scalar(large_val, signed, transform, errors):
  258:     # see gh-24910
  259:     kwargs = {"errors": errors} if errors is not None else {}
  260:     val = -large_val if signed else large_val
  261: 
  262:     val = transform(val)
  263:     val_is_string = isinstance(val, str)
  264: 
  265:     if val_is_string and errors in (None, "raise"):
  266:         msg = "Integer out of range. at position 0"
  267:         with pytest.raises(ValueError, match=msg):
  268:             to_numeric(val, **kwargs)
  269:     else:
  270:         expected = float(val) if (errors == "coerce" and val_is_string) else val
  271:         tm.assert_almost_equal(to_numeric(val, **kwargs), expected)
  272: 
  273: 
  274: @pytest.mark.filterwarnings("ignore:errors='ignore' is deprecated:FutureWarning")
  275: def test_really_large_in_arr(large_val, signed, transform, multiple_elts, errors):
  276:     # see gh-24910
  277:     kwargs = {"errors": errors} if errors is not None else {}
  278:     val = -large_val if signed else large_val
  279:     val = transform(val)
  280: 
  281:     extra_elt = "string"
  282:     arr = [val] + multiple_elts * [extra_elt]
  283: 
  284:     val_is_string = isinstance(val, str)
  285:     coercing = errors == "coerce"
  286: 
  287:     if errors in (None, "raise") and (val_is_string or multiple_elts):
  288:         if val_is_string:
  289:             msg = "Integer out of range. at position 0"
  290:         else:
  291:             msg = 'Unable to parse string "string" at position 1'
  292: 
  293:         with pytest.raises(ValueError, match=msg):
  294:             to_numeric(arr, **kwargs)
  295:     else:
  296:         result = to_numeric(arr, **kwargs)
  297: 
  298:         exp_val = float(val) if (coercing and val_is_string) else val
  299:         expected = [exp_val]
  300: 
  301:         if multiple_elts:
  302:             if coercing:
  303:                 expected.append(np.nan)
  304:                 exp_dtype = float
  305:             else:
  306:                 expected.append(extra_elt)
  307:                 exp_dtype = object
  308:         else:
  309:             exp_dtype = float if isinstance(exp_val, (int, float)) else object
  310: 
  311:         tm.assert_almost_equal(result, np.array(expected, dtype=exp_dtype))
  312: 
  313: 
  314: @pytest.mark.filterwarnings("ignore:errors='ignore' is deprecated:FutureWarning")
  315: def test_really_large_in_arr_consistent(large_val, signed, multiple_elts, errors):
  316:     # see gh-24910
  317:     #
  318:     # Even if we discover that we have to hold float, does not mean
  319:     # we should be lenient on subsequent elements that fail to be integer.
  320:     kwargs = {"errors": errors} if errors is not None else {}
  321:     arr = [str(-large_val if signed else large_val)]
  322: 
  323:     if multiple_elts:
  324:         arr.insert(0, large_val)
  325: 
  326:     if errors in (None, "raise"):
  327:         index = int(multiple_elts)
  328:         msg = f"Integer out of range. at position {index}"
  329: 
  330:         with pytest.raises(ValueError, match=msg):
  331:             to_numeric(arr, **kwargs)
  332:     else:
  333:         result = to_numeric(arr, **kwargs)
  334: 
  335:         if errors == "coerce":
  336:             expected = [float(i) for i in arr]
  337:             exp_dtype = float
  338:         else:
  339:             expected = arr
  340:             exp_dtype = object
  341: 
  342:         tm.assert_almost_equal(result, np.array(expected, dtype=exp_dtype))
  343: 
  344: 
  345: @pytest.mark.parametrize(
  346:     "errors,checker",
  347:     [
  348:         ("raise", 'Unable to parse string "fail" at position 0'),
  349:         ("ignore", lambda x: x == "fail"),
  350:         ("coerce", lambda x: np.isnan(x)),
  351:     ],
  352: )
  353: @pytest.mark.filterwarnings("ignore:errors='ignore' is deprecated:FutureWarning")
  354: def test_scalar_fail(errors, checker):
  355:     scalar = "fail"
  356: 
  357:     if isinstance(checker, str):
  358:         with pytest.raises(ValueError, match=checker):
  359:             to_numeric(scalar, errors=errors)
  360:     else:
  361:         assert checker(to_numeric(scalar, errors=errors))
  362: 
  363: 
  364: @pytest.mark.parametrize("data", [[1, 2, 3], [1.0, np.nan, 3, np.nan]])
  365: def test_numeric_dtypes(data, transform_assert_equal):
  366:     transform, assert_equal = transform_assert_equal
  367:     data = transform(data)
  368: 
  369:     result = to_numeric(data)
  370:     assert_equal(result, data)
  371: 
  372: 
  373: @pytest.mark.parametrize(
  374:     "data,exp",
  375:     [
  376:         (["1", "2", "3"], np.array([1, 2, 3], dtype="int64")),
  377:         (["1.5", "2.7", "3.4"], np.array([1.5, 2.7, 3.4])),
  378:     ],
  379: )
  380: def test_str(data, exp, transform_assert_equal):
  381:     transform, assert_equal = transform_assert_equal
  382:     result = to_numeric(transform(data))
  383: 
  384:     expected = transform(exp)
  385:     assert_equal(result, expected)
  386: 
  387: 
  388: def test_datetime_like(tz_naive_fixture, transform_assert_equal):
  389:     transform, assert_equal = transform_assert_equal
  390:     idx = pd.date_range("20130101", periods=3, tz=tz_naive_fixture)
  391: 
  392:     result = to_numeric(transform(idx))
  393:     expected = transform(idx.asi8)
  394:     assert_equal(result, expected)
  395: 
  396: 
  397: def test_timedelta(transform_assert_equal):
  398:     transform, assert_equal = transform_assert_equal
  399:     idx = pd.timedelta_range("1 days", periods=3, freq="D")
  400: 
  401:     result = to_numeric(transform(idx))
  402:     expected = transform(idx.asi8)
  403:     assert_equal(result, expected)
  404: 
  405: 
  406: def test_period(request, transform_assert_equal):
  407:     transform, assert_equal = transform_assert_equal
  408: 
  409:     idx = pd.period_range("2011-01", periods=3, freq="M", name="")
  410:     inp = transform(idx)
  411: 
  412:     if not isinstance(inp, Index):
  413:         request.applymarker(
  414:             pytest.mark.xfail(reason="Missing PeriodDtype support in to_numeric")
  415:         )
  416:     result = to_numeric(inp)
  417:     expected = transform(idx.asi8)
  418:     assert_equal(result, expected)
  419: 
  420: 
  421: @pytest.mark.parametrize(
  422:     "errors,expected",
  423:     [
  424:         ("raise", "Invalid object type at position 0"),
  425:         ("ignore", Series([[10.0, 2], 1.0, "apple"])),
  426:         ("coerce", Series([np.nan, 1.0, np.nan])),
  427:     ],
  428: )
  429: @pytest.mark.filterwarnings("ignore:errors='ignore' is deprecated:FutureWarning")
  430: def test_non_hashable(errors, expected):
  431:     # see gh-13324
  432:     ser = Series([[10.0, 2], 1.0, "apple"])
  433: 
  434:     if isinstance(expected, str):
  435:         with pytest.raises(TypeError, match=expected):
  436:             to_numeric(ser, errors=errors)
  437:     else:
  438:         result = to_numeric(ser, errors=errors)
  439:         tm.assert_series_equal(result, expected)
  440: 
  441: 
  442: def test_downcast_invalid_cast():
  443:     # see gh-13352
  444:     data = ["1", 2, 3]
  445:     invalid_downcast = "unsigned-integer"
  446:     msg = "invalid downcasting method provided"
  447: 
  448:     with pytest.raises(ValueError, match=msg):
  449:         to_numeric(data, downcast=invalid_downcast)
  450: 
  451: 
  452: def test_errors_invalid_value():
  453:     # see gh-26466
  454:     data = ["1", 2, 3]
  455:     invalid_error_value = "invalid"
  456:     msg = "invalid error value specified"
  457: 
  458:     with pytest.raises(ValueError, match=msg):
  459:         to_numeric(data, errors=invalid_error_value)
  460: 
  461: 
  462: @pytest.mark.parametrize(
  463:     "data",
  464:     [
  465:         ["1", 2, 3],
  466:         [1, 2, 3],
  467:         np.array(["1970-01-02", "1970-01-03", "1970-01-04"], dtype="datetime64[D]"),
  468:     ],
  469: )
  470: @pytest.mark.parametrize(
  471:     "kwargs,exp_dtype",
  472:     [
  473:         # Basic function tests.
  474:         ({}, np.int64),
  475:         ({"downcast": None}, np.int64),
  476:         # Support below np.float32 is rare and far between.
  477:         ({"downcast": "float"}, np.dtype(np.float32).char),
  478:         # Basic dtype support.
  479:         ({"downcast": "unsigned"}, np.dtype(np.typecodes["UnsignedInteger"][0])),
  480:     ],
  481: )
  482: def test_downcast_basic(data, kwargs, exp_dtype):
  483:     # see gh-13352
  484:     result = to_numeric(data, **kwargs)
  485:     expected = np.array([1, 2, 3], dtype=exp_dtype)
  486:     tm.assert_numpy_array_equal(result, expected)
  487: 
  488: 
  489: @pytest.mark.parametrize("signed_downcast", ["integer", "signed"])
  490: @pytest.mark.parametrize(
  491:     "data",
  492:     [
  493:         ["1", 2, 3],
  494:         [1, 2, 3],
  495:         np.array(["1970-01-02", "1970-01-03", "1970-01-04"], dtype="datetime64[D]"),
  496:     ],
  497: )
  498: def test_signed_downcast(data, signed_downcast):
  499:     # see gh-13352
  500:     smallest_int_dtype = np.dtype(np.typecodes["Integer"][0])
  501:     expected = np.array([1, 2, 3], dtype=smallest_int_dtype)
  502: 
  503:     res = to_numeric(data, downcast=signed_downcast)
  504:     tm.assert_numpy_array_equal(res, expected)
  505: 
  506: 
  507: def test_ignore_downcast_invalid_data():
  508:     # If we can't successfully cast the given
  509:     # data to a numeric dtype, do not bother
  510:     # with the downcast parameter.
  511:     data = ["foo", 2, 3]
  512:     expected = np.array(data, dtype=object)
  513: 
  514:     msg = "errors='ignore' is deprecated"
  515:     with tm.assert_produces_warning(FutureWarning, match=msg):
  516:         res = to_numeric(data, errors="ignore", downcast="unsigned")
  517:     tm.assert_numpy_array_equal(res, expected)
  518: 
  519: 
  520: def test_ignore_downcast_neg_to_unsigned():
  521:     # Cannot cast to an unsigned integer
  522:     # because we have a negative number.
  523:     data = ["-1", 2, 3]
  524:     expected = np.array([-1, 2, 3], dtype=np.int64)
  525: 
  526:     res = to_numeric(data, downcast="unsigned")
  527:     tm.assert_numpy_array_equal(res, expected)
  528: 
  529: 
  530: # Warning in 32 bit platforms
  531: @pytest.mark.filterwarnings("ignore:invalid value encountered in cast:RuntimeWarning")
  532: @pytest.mark.parametrize("downcast", ["integer", "signed", "unsigned"])
  533: @pytest.mark.parametrize(
  534:     "data,expected",
  535:     [
  536:         (["1.1", 2, 3], np.array([1.1, 2, 3], dtype=np.float64)),
  537:         (
  538:             [10000.0, 20000, 3000, 40000.36, 50000, 50000.00],
  539:             np.array(
  540:                 [10000.0, 20000, 3000, 40000.36, 50000, 50000.00], dtype=np.float64
  541:             ),
  542:         ),
  543:     ],
  544: )
  545: def test_ignore_downcast_cannot_convert_float(data, expected, downcast):
  546:     # Cannot cast to an integer (signed or unsigned)
  547:     # because we have a float number.
  548:     res = to_numeric(data, downcast=downcast)
  549:     tm.assert_numpy_array_equal(res, expected)
  550: 
  551: 
  552: @pytest.mark.parametrize(
  553:     "downcast,expected_dtype",
  554:     [("integer", np.int16), ("signed", np.int16), ("unsigned", np.uint16)],
  555: )
  556: def test_downcast_not8bit(downcast, expected_dtype):
  557:     # the smallest integer dtype need not be np.(u)int8
  558:     data = ["256", 257, 258]
  559: 
  560:     expected = np.array([256, 257, 258], dtype=expected_dtype)
  561:     res = to_numeric(data, downcast=downcast)
  562:     tm.assert_numpy_array_equal(res, expected)
  563: 
  564: 
  565: @pytest.mark.parametrize(
  566:     "dtype,downcast,min_max",
  567:     [
  568:         ("int8", "integer", [iinfo(np.int8).min, iinfo(np.int8).max]),
  569:         ("int16", "integer", [iinfo(np.int16).min, iinfo(np.int16).max]),
  570:         ("int32", "integer", [iinfo(np.int32).min, iinfo(np.int32).max]),
  571:         ("int64", "integer", [iinfo(np.int64).min, iinfo(np.int64).max]),
  572:         ("uint8", "unsigned", [iinfo(np.uint8).min, iinfo(np.uint8).max]),
  573:         ("uint16", "unsigned", [iinfo(np.uint16).min, iinfo(np.uint16).max]),
  574:         ("uint32", "unsigned", [iinfo(np.uint32).min, iinfo(np.uint32).max]),
  575:         ("uint64", "unsigned", [iinfo(np.uint64).min, iinfo(np.uint64).max]),
  576:         ("int16", "integer", [iinfo(np.int8).min, iinfo(np.int8).max + 1]),
  577:         ("int32", "integer", [iinfo(np.int16).min, iinfo(np.int16).max + 1]),
  578:         ("int64", "integer", [iinfo(np.int32).min, iinfo(np.int32).max + 1]),
  579:         ("int16", "integer", [iinfo(np.int8).min - 1, iinfo(np.int16).max]),
  580:         ("int32", "integer", [iinfo(np.int16).min - 1, iinfo(np.int32).max]),
  581:         ("int64", "integer", [iinfo(np.int32).min - 1, iinfo(np.int64).max]),
  582:         ("uint16", "unsigned", [iinfo(np.uint8).min, iinfo(np.uint8).max + 1]),
  583:         ("uint32", "unsigned", [iinfo(np.uint16).min, iinfo(np.uint16).max + 1]),
  584:         ("uint64", "unsigned", [iinfo(np.uint32).min, iinfo(np.uint32).max + 1]),
  585:     ],
  586: )
  587: def test_downcast_limits(dtype, downcast, min_max):
  588:     # see gh-14404: test the limits of each downcast.
  589:     series = to_numeric(Series(min_max), downcast=downcast)
  590:     assert series.dtype == dtype
  591: 
  592: 
  593: def test_downcast_float64_to_float32():
  594:     # GH-43693: Check float64 preservation when >= 16,777,217
  595:     series = Series([16777217.0, np.finfo(np.float64).max, np.nan], dtype=np.float64)
  596:     result = to_numeric(series, downcast="float")
  597: 
  598:     assert series.dtype == result.dtype
  599: 
  600: 
  601: @pytest.mark.parametrize(
  602:     "ser,expected",
  603:     [
  604:         (
  605:             Series([0, 9223372036854775808]),
  606:             Series([0, 9223372036854775808], dtype=np.uint64),
  607:         )
  608:     ],
  609: )
  610: def test_downcast_uint64(ser, expected):
  611:     # see gh-14422:
  612:     # BUG: to_numeric doesn't work uint64 numbers
  613: 
  614:     result = to_numeric(ser, downcast="unsigned")
  615: 
  616:     tm.assert_series_equal(result, expected)
  617: 
  618: 
  619: @pytest.mark.parametrize(
  620:     "data,exp_data",
  621:     [
  622:         (
  623:             [200, 300, "", "NaN", 30000000000000000000],
  624:             [200, 300, np.nan, np.nan, 30000000000000000000],
  625:         ),
  626:         (
  627:             ["12345678901234567890", "1234567890", "ITEM"],
  628:             [12345678901234567890, 1234567890, np.nan],
  629:         ),
  630:     ],
  631: )
  632: def test_coerce_uint64_conflict(data, exp_data):
  633:     # see gh-17007 and gh-17125
  634:     #
  635:     # Still returns float despite the uint64-nan conflict,
  636:     # which would normally force the casting to object.
  637:     result = to_numeric(Series(data), errors="coerce")
  638:     expected = Series(exp_data, dtype=float)
  639:     tm.assert_series_equal(result, expected)
  640: 
  641: 
  642: @pytest.mark.parametrize(
  643:     "errors,exp",
  644:     [
  645:         ("ignore", Series(["12345678901234567890", "1234567890", "ITEM"])),
  646:         ("raise", "Unable to parse string"),
  647:     ],
  648: )
  649: @pytest.mark.filterwarnings("ignore:errors='ignore' is deprecated:FutureWarning")
  650: def test_non_coerce_uint64_conflict(errors, exp):
  651:     # see gh-17007 and gh-17125
  652:     #
  653:     # For completeness.
  654:     ser = Series(["12345678901234567890", "1234567890", "ITEM"])
  655: 
  656:     if isinstance(exp, str):
  657:         with pytest.raises(ValueError, match=exp):
  658:             to_numeric(ser, errors=errors)
  659:     else:
  660:         result = to_numeric(ser, errors=errors)
  661:         tm.assert_series_equal(result, ser)
  662: 
  663: 
  664: @pytest.mark.parametrize("dc1", ["integer", "float", "unsigned"])
  665: @pytest.mark.parametrize("dc2", ["integer", "float", "unsigned"])
  666: def test_downcast_empty(dc1, dc2):
  667:     # GH32493
  668: 
  669:     tm.assert_numpy_array_equal(
  670:         to_numeric([], downcast=dc1),
  671:         to_numeric([], downcast=dc2),
  672:         check_dtype=False,
  673:     )
  674: 
  675: 
  676: def test_failure_to_convert_uint64_string_to_NaN():
  677:     # GH 32394
  678:     result = to_numeric("uint64", errors="coerce")
  679:     assert np.isnan(result)
  680: 
  681:     ser = Series([32, 64, np.nan])
  682:     result = to_numeric(Series(["32", "64", "uint64"]), errors="coerce")
  683:     tm.assert_series_equal(result, ser)
  684: 
  685: 
  686: @pytest.mark.parametrize(
  687:     "strrep",
  688:     [
  689:         "243.164",
  690:         "245.968",
  691:         "249.585",
  692:         "259.745",
  693:         "265.742",
  694:         "272.567",
  695:         "279.196",
  696:         "280.366",
  697:         "275.034",
  698:         "271.351",
  699:         "272.889",
  700:         "270.627",
  701:         "280.828",
  702:         "290.383",
  703:         "308.153",
  704:         "319.945",
  705:         "336.0",
  706:         "344.09",
  707:         "351.385",
  708:         "356.178",
  709:         "359.82",
  710:         "361.03",
  711:         "367.701",
  712:         "380.812",
  713:         "387.98",
  714:         "391.749",
  715:         "391.171",
  716:         "385.97",
  717:         "385.345",
  718:         "386.121",
  719:         "390.996",
  720:         "399.734",
  721:         "413.073",
  722:         "421.532",
  723:         "430.221",
  724:         "437.092",
  725:         "439.746",
  726:         "446.01",
  727:         "451.191",
  728:         "460.463",
  729:         "469.779",
  730:         "472.025",
  731:         "479.49",
  732:         "474.864",
  733:         "467.54",
  734:         "471.978",
  735:     ],
  736: )
  737: def test_precision_float_conversion(strrep):
  738:     # GH 31364
  739:     result = to_numeric(strrep)
  740: 
  741:     assert result == float(strrep)
  742: 
  743: 
  744: @pytest.mark.parametrize(
  745:     "values, expected",
  746:     [
  747:         (["1", "2", None], Series([1, 2, np.nan], dtype="Int64")),
  748:         (["1", "2", "3"], Series([1, 2, 3], dtype="Int64")),
  749:         (["1", "2", 3], Series([1, 2, 3], dtype="Int64")),
  750:         (["1", "2", 3.5], Series([1, 2, 3.5], dtype="Float64")),
  751:         (["1", None, 3.5], Series([1, np.nan, 3.5], dtype="Float64")),
  752:         (["1", "2", "3.5"], Series([1, 2, 3.5], dtype="Float64")),
  753:     ],
  754: )
  755: def test_to_numeric_from_nullable_string(values, nullable_string_dtype, expected):
  756:     # https://github.com/pandas-dev/pandas/issues/37262
  757:     s = Series(values, dtype=nullable_string_dtype)
  758:     result = to_numeric(s)
  759:     tm.assert_series_equal(result, expected)
  760: 
  761: 
  762: def test_to_numeric_from_nullable_string_coerce(nullable_string_dtype):
  763:     # GH#52146
  764:     values = ["a", "1"]
  765:     ser = Series(values, dtype=nullable_string_dtype)
  766:     result = to_numeric(ser, errors="coerce")
  767:     expected = Series([pd.NA, 1], dtype="Int64")
  768:     tm.assert_series_equal(result, expected)
  769: 
  770: 
  771: def test_to_numeric_from_nullable_string_ignore(nullable_string_dtype):
  772:     # GH#52146
  773:     values = ["a", "1"]
  774:     ser = Series(values, dtype=nullable_string_dtype)
  775:     expected = ser.copy()
  776:     msg = "errors='ignore' is deprecated"
  777:     with tm.assert_produces_warning(FutureWarning, match=msg):
  778:         result = to_numeric(ser, errors="ignore")
  779:     tm.assert_series_equal(result, expected)
  780: 
  781: 
  782: @pytest.mark.parametrize(
  783:     "data, input_dtype, downcast, expected_dtype",
  784:     (
  785:         ([1, 1], "Int64", "integer", "Int8"),
  786:         ([1.0, pd.NA], "Float64", "integer", "Int8"),
  787:         ([1.0, 1.1], "Float64", "integer", "Float64"),
  788:         ([1, pd.NA], "Int64", "integer", "Int8"),
  789:         ([450, 300], "Int64", "integer", "Int16"),
  790:         ([1, 1], "Float64", "integer", "Int8"),
  791:         ([np.iinfo(np.int64).max - 1, 1], "Int64", "integer", "Int64"),
  792:         ([1, 1], "Int64", "signed", "Int8"),
  793:         ([1.0, 1.0], "Float32", "signed", "Int8"),
  794:         ([1.0, 1.1], "Float64", "signed", "Float64"),
  795:         ([1, pd.NA], "Int64", "signed", "Int8"),
  796:         ([450, -300], "Int64", "signed", "Int16"),
  797:         ([np.iinfo(np.uint64).max - 1, 1], "UInt64", "signed", "UInt64"),
  798:         ([1, 1], "Int64", "unsigned", "UInt8"),
  799:         ([1.0, 1.0], "Float32", "unsigned", "UInt8"),
  800:         ([1.0, 1.1], "Float64", "unsigned", "Float64"),
  801:         ([1, pd.NA], "Int64", "unsigned", "UInt8"),
  802:         ([450, -300], "Int64", "unsigned", "Int64"),
  803:         ([-1, -1], "Int32", "unsigned", "Int32"),
  804:         ([1, 1], "Float64", "float", "Float32"),
  805:         ([1, 1.1], "Float64", "float", "Float32"),
  806:         ([1, 1], "Float32", "float", "Float32"),
  807:         ([1, 1.1], "Float32", "float", "Float32"),
  808:     ),
  809: )
  810: def test_downcast_nullable_numeric(data, input_dtype, downcast, expected_dtype):
  811:     arr = pd.array(data, dtype=input_dtype)
  812:     result = to_numeric(arr, downcast=downcast)
  813:     expected = pd.array(data, dtype=expected_dtype)
  814:     tm.assert_extension_array_equal(result, expected)
  815: 
  816: 
  817: def test_downcast_nullable_mask_is_copied():
  818:     # GH38974
  819: 
  820:     arr = pd.array([1, 2, pd.NA], dtype="Int64")
  821: 
  822:     result = to_numeric(arr, downcast="integer")
  823:     expected = pd.array([1, 2, pd.NA], dtype="Int8")
  824:     tm.assert_extension_array_equal(result, expected)
  825: 
  826:     arr[1] = pd.NA  # should not modify result
  827:     tm.assert_extension_array_equal(result, expected)
  828: 
  829: 
  830: def test_to_numeric_scientific_notation():
  831:     # GH 15898
  832:     result = to_numeric("1.7e+308")
  833:     expected = np.float64(1.7e308)
  834:     assert result == expected
  835: 
  836: 
  837: @pytest.mark.parametrize("val", [9876543210.0, 2.0**128])
  838: def test_to_numeric_large_float_not_downcast_to_float_32(val):
  839:     # GH 19729
  840:     expected = Series([val])
  841:     result = to_numeric(expected, downcast="float")
  842:     tm.assert_series_equal(result, expected)
  843: 
  844: 
  845: @pytest.mark.parametrize(
  846:     "val, dtype", [(1, "Int64"), (1.5, "Float64"), (True, "boolean")]
  847: )
  848: def test_to_numeric_dtype_backend(val, dtype):
  849:     # GH#50505
  850:     ser = Series([val], dtype=object)
  851:     result = to_numeric(ser, dtype_backend="numpy_nullable")
  852:     expected = Series([val], dtype=dtype)
  853:     tm.assert_series_equal(result, expected)
  854: 
  855: 
  856: @pytest.mark.parametrize(
  857:     "val, dtype",
  858:     [
  859:         (1, "Int64"),
  860:         (1.5, "Float64"),
  861:         (True, "boolean"),
  862:         (1, "int64[pyarrow]"),
  863:         (1.5, "float64[pyarrow]"),
  864:         (True, "bool[pyarrow]"),
  865:     ],
  866: )
  867: def test_to_numeric_dtype_backend_na(val, dtype):
  868:     # GH#50505
  869:     if "pyarrow" in dtype:
  870:         pytest.importorskip("pyarrow")
  871:         dtype_backend = "pyarrow"
  872:     else:
  873:         dtype_backend = "numpy_nullable"
  874:     ser = Series([val, None], dtype=object)
  875:     result = to_numeric(ser, dtype_backend=dtype_backend)
  876:     expected = Series([val, pd.NA], dtype=dtype)
  877:     tm.assert_series_equal(result, expected)
  878: 
  879: 
  880: @pytest.mark.parametrize(
  881:     "val, dtype, downcast",
  882:     [
  883:         (1, "Int8", "integer"),
  884:         (1.5, "Float32", "float"),
  885:         (1, "Int8", "signed"),
  886:         (1, "int8[pyarrow]", "integer"),
  887:         (1.5, "float[pyarrow]", "float"),
  888:         (1, "int8[pyarrow]", "signed"),
  889:     ],
  890: )
  891: def test_to_numeric_dtype_backend_downcasting(val, dtype, downcast):
  892:     # GH#50505
  893:     if "pyarrow" in dtype:
  894:         pytest.importorskip("pyarrow")
  895:         dtype_backend = "pyarrow"
  896:     else:
  897:         dtype_backend = "numpy_nullable"
  898:     ser = Series([val, None], dtype=object)
  899:     result = to_numeric(ser, dtype_backend=dtype_backend, downcast=downcast)
  900:     expected = Series([val, pd.NA], dtype=dtype)
  901:     tm.assert_series_equal(result, expected)
  902: 
  903: 
  904: @pytest.mark.parametrize(
  905:     "smaller, dtype_backend",
  906:     [["UInt8", "numpy_nullable"], ["uint8[pyarrow]", "pyarrow"]],
  907: )
  908: def test_to_numeric_dtype_backend_downcasting_uint(smaller, dtype_backend):
  909:     # GH#50505
  910:     if dtype_backend == "pyarrow":
  911:         pytest.importorskip("pyarrow")
  912:     ser = Series([1, pd.NA], dtype="UInt64")
  913:     result = to_numeric(ser, dtype_backend=dtype_backend, downcast="unsigned")
  914:     expected = Series([1, pd.NA], dtype=smaller)
  915:     tm.assert_series_equal(result, expected)
  916: 
  917: 
  918: @pytest.mark.parametrize(
  919:     "dtype",
  920:     [
  921:         "Int64",
  922:         "UInt64",
  923:         "Float64",
  924:         "boolean",
  925:         "int64[pyarrow]",
  926:         "uint64[pyarrow]",
  927:         "float64[pyarrow]",
  928:         "bool[pyarrow]",
  929:     ],
  930: )
  931: def test_to_numeric_dtype_backend_already_nullable(dtype):
  932:     # GH#50505
  933:     if "pyarrow" in dtype:
  934:         pytest.importorskip("pyarrow")
  935:     ser = Series([1, pd.NA], dtype=dtype)
  936:     result = to_numeric(ser, dtype_backend="numpy_nullable")
  937:     expected = Series([1, pd.NA], dtype=dtype)
  938:     tm.assert_series_equal(result, expected)
  939: 
  940: 
  941: def test_to_numeric_dtype_backend_error(dtype_backend):
  942:     # GH#50505
  943:     ser = Series(["a", "b", ""])
  944:     expected = ser.copy()
  945:     with pytest.raises(ValueError, match="Unable to parse string"):
  946:         to_numeric(ser, dtype_backend=dtype_backend)
  947: 
  948:     msg = "errors='ignore' is deprecated"
  949:     with tm.assert_produces_warning(FutureWarning, match=msg):
  950:         result = to_numeric(ser, dtype_backend=dtype_backend, errors="ignore")
  951:     tm.assert_series_equal(result, expected)
  952: 
  953:     result = to_numeric(ser, dtype_backend=dtype_backend, errors="coerce")
  954:     if dtype_backend == "pyarrow":
  955:         dtype = "double[pyarrow]"
  956:     else:
  957:         dtype = "Float64"
  958:     expected = Series([np.nan, np.nan, np.nan], dtype=dtype)
  959:     tm.assert_series_equal(result, expected)
  960: 
  961: 
  962: def test_invalid_dtype_backend():
  963:     ser = Series([1, 2, 3])
  964:     msg = (
  965:         "dtype_backend numpy is invalid, only 'numpy_nullable' and "
  966:         "'pyarrow' are allowed."
  967:     )
  968:     with pytest.raises(ValueError, match=msg):
  969:         to_numeric(ser, dtype_backend="numpy")
  970: 
  971: 
  972: def test_coerce_pyarrow_backend():
  973:     # GH 52588
  974:     pa = pytest.importorskip("pyarrow")
  975:     ser = Series(list("12x"), dtype=ArrowDtype(pa.string()))
  976:     result = to_numeric(ser, errors="coerce", dtype_backend="pyarrow")
  977:     expected = Series([1, 2, None], dtype=ArrowDtype(pa.int64()))
  978:     tm.assert_series_equal(result, expected)
