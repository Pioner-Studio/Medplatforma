    1: from datetime import datetime
    2: 
    3: import numpy as np
    4: import pytest
    5: from pytz import UTC
    6: 
    7: from pandas._libs.tslibs import (
    8:     OutOfBoundsTimedelta,
    9:     astype_overflowsafe,
   10:     conversion,
   11:     iNaT,
   12:     timezones,
   13:     tz_convert_from_utc,
   14:     tzconversion,
   15: )
   16: 
   17: from pandas import (
   18:     Timestamp,
   19:     date_range,
   20: )
   21: import pandas._testing as tm
   22: 
   23: 
   24: def _compare_utc_to_local(tz_didx):
   25:     def f(x):
   26:         return tzconversion.tz_convert_from_utc_single(x, tz_didx.tz)
   27: 
   28:     result = tz_convert_from_utc(tz_didx.asi8, tz_didx.tz)
   29:     expected = np.vectorize(f)(tz_didx.asi8)
   30: 
   31:     tm.assert_numpy_array_equal(result, expected)
   32: 
   33: 
   34: def _compare_local_to_utc(tz_didx, naive_didx):
   35:     # Check that tz_localize behaves the same vectorized and pointwise.
   36:     err1 = err2 = None
   37:     try:
   38:         result = tzconversion.tz_localize_to_utc(naive_didx.asi8, tz_didx.tz)
   39:         err1 = None
   40:     except Exception as err:
   41:         err1 = err
   42: 
   43:     try:
   44:         expected = naive_didx.map(lambda x: x.tz_localize(tz_didx.tz)).asi8
   45:     except Exception as err:
   46:         err2 = err
   47: 
   48:     if err1 is not None:
   49:         assert type(err1) == type(err2)
   50:     else:
   51:         assert err2 is None
   52:         tm.assert_numpy_array_equal(result, expected)
   53: 
   54: 
   55: def test_tz_localize_to_utc_copies():
   56:     # GH#46460
   57:     arr = np.arange(5, dtype="i8")
   58:     result = tz_convert_from_utc(arr, tz=UTC)
   59:     tm.assert_numpy_array_equal(result, arr)
   60:     assert not np.shares_memory(arr, result)
   61: 
   62:     result = tz_convert_from_utc(arr, tz=None)
   63:     tm.assert_numpy_array_equal(result, arr)
   64:     assert not np.shares_memory(arr, result)
   65: 
   66: 
   67: def test_tz_convert_single_matches_tz_convert_hourly(tz_aware_fixture):
   68:     tz = tz_aware_fixture
   69:     tz_didx = date_range("2014-03-01", "2015-01-10", freq="h", tz=tz)
   70:     naive_didx = date_range("2014-03-01", "2015-01-10", freq="h")
   71: 
   72:     _compare_utc_to_local(tz_didx)
   73:     _compare_local_to_utc(tz_didx, naive_didx)
   74: 
   75: 
   76: @pytest.mark.parametrize("freq", ["D", "YE"])
   77: def test_tz_convert_single_matches_tz_convert(tz_aware_fixture, freq):
   78:     tz = tz_aware_fixture
   79:     tz_didx = date_range("2018-01-01", "2020-01-01", freq=freq, tz=tz)
   80:     naive_didx = date_range("2018-01-01", "2020-01-01", freq=freq)
   81: 
   82:     _compare_utc_to_local(tz_didx)
   83:     _compare_local_to_utc(tz_didx, naive_didx)
   84: 
   85: 
   86: @pytest.mark.parametrize(
   87:     "arr",
   88:     [
   89:         pytest.param(np.array([], dtype=np.int64), id="empty"),
   90:         pytest.param(np.array([iNaT], dtype=np.int64), id="all_nat"),
   91:     ],
   92: )
   93: def test_tz_convert_corner(arr):
   94:     result = tz_convert_from_utc(arr, timezones.maybe_get_tz("Asia/Tokyo"))
   95:     tm.assert_numpy_array_equal(result, arr)
   96: 
   97: 
   98: def test_tz_convert_readonly():
   99:     # GH#35530
  100:     arr = np.array([0], dtype=np.int64)
  101:     arr.setflags(write=False)
  102:     result = tz_convert_from_utc(arr, UTC)
  103:     tm.assert_numpy_array_equal(result, arr)
  104: 
  105: 
  106: @pytest.mark.parametrize("copy", [True, False])
  107: @pytest.mark.parametrize("dtype", ["M8[ns]", "M8[s]"])
  108: def test_length_zero_copy(dtype, copy):
  109:     arr = np.array([], dtype=dtype)
  110:     result = astype_overflowsafe(arr, copy=copy, dtype=np.dtype("M8[ns]"))
  111:     if copy:
  112:         assert not np.shares_memory(result, arr)
  113:     elif arr.dtype == result.dtype:
  114:         assert result is arr
  115:     else:
  116:         assert not np.shares_memory(result, arr)
  117: 
  118: 
  119: def test_ensure_datetime64ns_bigendian():
  120:     # GH#29684
  121:     arr = np.array([np.datetime64(1, "ms")], dtype=">M8[ms]")
  122:     result = astype_overflowsafe(arr, dtype=np.dtype("M8[ns]"))
  123: 
  124:     expected = np.array([np.datetime64(1, "ms")], dtype="M8[ns]")
  125:     tm.assert_numpy_array_equal(result, expected)
  126: 
  127: 
  128: def test_ensure_timedelta64ns_overflows():
  129:     arr = np.arange(10).astype("m8[Y]") * 100
  130:     msg = r"Cannot convert 300 years to timedelta64\[ns\] without overflow"
  131:     with pytest.raises(OutOfBoundsTimedelta, match=msg):
  132:         astype_overflowsafe(arr, dtype=np.dtype("m8[ns]"))
  133: 
  134: 
  135: class SubDatetime(datetime):
  136:     pass
  137: 
  138: 
  139: @pytest.mark.parametrize(
  140:     "dt, expected",
  141:     [
  142:         pytest.param(
  143:             Timestamp("2000-01-01"), Timestamp("2000-01-01", tz=UTC), id="timestamp"
  144:         ),
  145:         pytest.param(
  146:             datetime(2000, 1, 1), datetime(2000, 1, 1, tzinfo=UTC), id="datetime"
  147:         ),
  148:         pytest.param(
  149:             SubDatetime(2000, 1, 1),
  150:             SubDatetime(2000, 1, 1, tzinfo=UTC),
  151:             id="subclassed_datetime",
  152:         ),
  153:     ],
  154: )
  155: def test_localize_pydatetime_dt_types(dt, expected):
  156:     # GH 25851
  157:     # ensure that subclassed datetime works with
  158:     # localize_pydatetime
  159:     result = conversion.localize_pydatetime(dt, UTC)
  160:     assert result == expected
