    1: """
    2: Tests for Timestamp parsing, aimed at pandas/_libs/tslibs/parsing.pyx
    3: """
    4: from datetime import datetime
    5: import re
    6: 
    7: from dateutil.parser import parse as du_parse
    8: from dateutil.tz import tzlocal
    9: from hypothesis import given
   10: import numpy as np
   11: import pytest
   12: 
   13: from pandas._libs.tslibs import (
   14:     parsing,
   15:     strptime,
   16: )
   17: from pandas._libs.tslibs.parsing import parse_datetime_string_with_reso
   18: from pandas.compat import (
   19:     ISMUSL,
   20:     is_platform_windows,
   21: )
   22: import pandas.util._test_decorators as td
   23: 
   24: import pandas._testing as tm
   25: from pandas._testing._hypothesis import DATETIME_NO_TZ
   26: 
   27: 
   28: @pytest.mark.skipif(
   29:     is_platform_windows() or ISMUSL,
   30:     reason="TZ setting incorrect on Windows and MUSL Linux",
   31: )
   32: def test_parsing_tzlocal_deprecated():
   33:     # GH#50791
   34:     msg = (
   35:         "Parsing 'EST' as tzlocal.*"
   36:         "Pass the 'tz' keyword or call tz_localize after construction instead"
   37:     )
   38:     dtstr = "Jan 15 2004 03:00 EST"
   39: 
   40:     with tm.set_timezone("US/Eastern"):
   41:         with tm.assert_produces_warning(FutureWarning, match=msg):
   42:             res, _ = parse_datetime_string_with_reso(dtstr)
   43: 
   44:         assert isinstance(res.tzinfo, tzlocal)
   45: 
   46:         with tm.assert_produces_warning(FutureWarning, match=msg):
   47:             res = parsing.py_parse_datetime_string(dtstr)
   48:         assert isinstance(res.tzinfo, tzlocal)
   49: 
   50: 
   51: def test_parse_datetime_string_with_reso():
   52:     (parsed, reso) = parse_datetime_string_with_reso("4Q1984")
   53:     (parsed_lower, reso_lower) = parse_datetime_string_with_reso("4q1984")
   54: 
   55:     assert reso == reso_lower
   56:     assert parsed == parsed_lower
   57: 
   58: 
   59: def test_parse_datetime_string_with_reso_nanosecond_reso():
   60:     # GH#46811
   61:     parsed, reso = parse_datetime_string_with_reso("2022-04-20 09:19:19.123456789")
   62:     assert reso == "nanosecond"
   63: 
   64: 
   65: def test_parse_datetime_string_with_reso_invalid_type():
   66:     # Raise on invalid input, don't just return it
   67:     msg = "Argument 'date_string' has incorrect type (expected str, got tuple)"
   68:     with pytest.raises(TypeError, match=re.escape(msg)):
   69:         parse_datetime_string_with_reso((4, 5))
   70: 
   71: 
   72: @pytest.mark.parametrize(
   73:     "dashed,normal", [("1988-Q2", "1988Q2"), ("2Q-1988", "2Q1988")]
   74: )
   75: def test_parse_time_quarter_with_dash(dashed, normal):
   76:     # see gh-9688
   77:     (parsed_dash, reso_dash) = parse_datetime_string_with_reso(dashed)
   78:     (parsed, reso) = parse_datetime_string_with_reso(normal)
   79: 
   80:     assert parsed_dash == parsed
   81:     assert reso_dash == reso
   82: 
   83: 
   84: @pytest.mark.parametrize("dashed", ["-2Q1992", "2-Q1992", "4-4Q1992"])
   85: def test_parse_time_quarter_with_dash_error(dashed):
   86:     msg = f"Unknown datetime string format, unable to parse: {dashed}"
   87: 
   88:     with pytest.raises(parsing.DateParseError, match=msg):
   89:         parse_datetime_string_with_reso(dashed)
   90: 
   91: 
   92: @pytest.mark.parametrize(
   93:     "date_string,expected",
   94:     [
   95:         ("123.1234", False),
   96:         ("-50000", False),
   97:         ("999", False),
   98:         ("m", False),
   99:         ("T", False),
  100:         ("Mon Sep 16, 2013", True),
  101:         ("2012-01-01", True),
  102:         ("01/01/2012", True),
  103:         ("01012012", True),
  104:         ("0101", True),
  105:         ("1-1", True),
  106:     ],
  107: )
  108: def test_does_not_convert_mixed_integer(date_string, expected):
  109:     assert parsing._does_string_look_like_datetime(date_string) is expected
  110: 
  111: 
  112: @pytest.mark.parametrize(
  113:     "date_str,kwargs,msg",
  114:     [
  115:         (
  116:             "2013Q5",
  117:             {},
  118:             (
  119:                 "Incorrect quarterly string is given, "
  120:                 "quarter must be between 1 and 4: 2013Q5"
  121:             ),
  122:         ),
  123:         # see gh-5418
  124:         (
  125:             "2013Q1",
  126:             {"freq": "INVLD-L-DEC-SAT"},
  127:             (
  128:                 "Unable to retrieve month information "
  129:                 "from given freq: INVLD-L-DEC-SAT"
  130:             ),
  131:         ),
  132:     ],
  133: )
  134: def test_parsers_quarterly_with_freq_error(date_str, kwargs, msg):
  135:     with pytest.raises(parsing.DateParseError, match=msg):
  136:         parsing.parse_datetime_string_with_reso(date_str, **kwargs)
  137: 
  138: 
  139: @pytest.mark.parametrize(
  140:     "date_str,freq,expected",
  141:     [
  142:         ("2013Q2", None, datetime(2013, 4, 1)),
  143:         ("2013Q2", "Y-APR", datetime(2012, 8, 1)),
  144:         ("2013-Q2", "Y-DEC", datetime(2013, 4, 1)),
  145:     ],
  146: )
  147: def test_parsers_quarterly_with_freq(date_str, freq, expected):
  148:     result, _ = parsing.parse_datetime_string_with_reso(date_str, freq=freq)
  149:     assert result == expected
  150: 
  151: 
  152: @pytest.mark.parametrize(
  153:     "date_str", ["2Q 2005", "2Q-200Y", "2Q-200", "22Q2005", "2Q200.", "6Q-20"]
  154: )
  155: def test_parsers_quarter_invalid(date_str):
  156:     if date_str == "6Q-20":
  157:         msg = (
  158:             "Incorrect quarterly string is given, quarter "
  159:             f"must be between 1 and 4: {date_str}"
  160:         )
  161:     else:
  162:         msg = f"Unknown datetime string format, unable to parse: {date_str}"
  163: 
  164:     with pytest.raises(ValueError, match=msg):
  165:         parsing.parse_datetime_string_with_reso(date_str)
  166: 
  167: 
  168: @pytest.mark.parametrize(
  169:     "date_str,expected",
  170:     [("201101", datetime(2011, 1, 1, 0, 0)), ("200005", datetime(2000, 5, 1, 0, 0))],
  171: )
  172: def test_parsers_month_freq(date_str, expected):
  173:     result, _ = parsing.parse_datetime_string_with_reso(date_str, freq="ME")
  174:     assert result == expected
  175: 
  176: 
  177: @td.skip_if_not_us_locale
  178: @pytest.mark.parametrize(
  179:     "string,fmt",
  180:     [
  181:         ("20111230", "%Y%m%d"),
  182:         ("201112300000", "%Y%m%d%H%M"),
  183:         ("20111230000000", "%Y%m%d%H%M%S"),
  184:         ("20111230T00", "%Y%m%dT%H"),
  185:         ("20111230T0000", "%Y%m%dT%H%M"),
  186:         ("20111230T000000", "%Y%m%dT%H%M%S"),
  187:         ("2011-12-30", "%Y-%m-%d"),
  188:         ("2011", "%Y"),
  189:         ("2011-01", "%Y-%m"),
  190:         ("30-12-2011", "%d-%m-%Y"),
  191:         ("2011-12-30 00:00:00", "%Y-%m-%d %H:%M:%S"),
  192:         ("2011-12-30T00:00:00", "%Y-%m-%dT%H:%M:%S"),
  193:         ("2011-12-30T00:00:00UTC", "%Y-%m-%dT%H:%M:%S%Z"),
  194:         ("2011-12-30T00:00:00Z", "%Y-%m-%dT%H:%M:%S%z"),
  195:         ("2011-12-30T00:00:00+9", "%Y-%m-%dT%H:%M:%S%z"),
  196:         ("2011-12-30T00:00:00+09", "%Y-%m-%dT%H:%M:%S%z"),
  197:         ("2011-12-30T00:00:00+090", None),
  198:         ("2011-12-30T00:00:00+0900", "%Y-%m-%dT%H:%M:%S%z"),
  199:         ("2011-12-30T00:00:00-0900", "%Y-%m-%dT%H:%M:%S%z"),
  200:         ("2011-12-30T00:00:00+09:00", "%Y-%m-%dT%H:%M:%S%z"),
  201:         ("2011-12-30T00:00:00+09:000", None),
  202:         ("2011-12-30T00:00:00+9:0", "%Y-%m-%dT%H:%M:%S%z"),
  203:         ("2011-12-30T00:00:00+09:", None),
  204:         ("2011-12-30T00:00:00.000000UTC", "%Y-%m-%dT%H:%M:%S.%f%Z"),
  205:         ("2011-12-30T00:00:00.000000Z", "%Y-%m-%dT%H:%M:%S.%f%z"),
  206:         ("2011-12-30T00:00:00.000000+9", "%Y-%m-%dT%H:%M:%S.%f%z"),
  207:         ("2011-12-30T00:00:00.000000+09", "%Y-%m-%dT%H:%M:%S.%f%z"),
  208:         ("2011-12-30T00:00:00.000000+090", None),
  209:         ("2011-12-30T00:00:00.000000+0900", "%Y-%m-%dT%H:%M:%S.%f%z"),
  210:         ("2011-12-30T00:00:00.000000-0900", "%Y-%m-%dT%H:%M:%S.%f%z"),
  211:         ("2011-12-30T00:00:00.000000+09:00", "%Y-%m-%dT%H:%M:%S.%f%z"),
  212:         ("2011-12-30T00:00:00.000000+09:000", None),
  213:         ("2011-12-30T00:00:00.000000+9:0", "%Y-%m-%dT%H:%M:%S.%f%z"),
  214:         ("2011-12-30T00:00:00.000000+09:", None),
  215:         ("2011-12-30 00:00:00.000000", "%Y-%m-%d %H:%M:%S.%f"),
  216:         ("Tue 24 Aug 2021 01:30:48", "%a %d %b %Y %H:%M:%S"),
  217:         ("Tuesday 24 Aug 2021 01:30:48", "%A %d %b %Y %H:%M:%S"),
  218:         ("Tue 24 Aug 2021 01:30:48 AM", "%a %d %b %Y %I:%M:%S %p"),
  219:         ("Tuesday 24 Aug 2021 01:30:48 AM", "%A %d %b %Y %I:%M:%S %p"),
  220:         ("27.03.2003 14:55:00.000", "%d.%m.%Y %H:%M:%S.%f"),  # GH50317
  221:     ],
  222: )
  223: def test_guess_datetime_format_with_parseable_formats(string, fmt):
  224:     with tm.maybe_produces_warning(
  225:         UserWarning, fmt is not None and re.search(r"%d.*%m", fmt)
  226:     ):
  227:         result = parsing.guess_datetime_format(string)
  228:     assert result == fmt
  229: 
  230: 
  231: @pytest.mark.parametrize("dayfirst,expected", [(True, "%d/%m/%Y"), (False, "%m/%d/%Y")])
  232: def test_guess_datetime_format_with_dayfirst(dayfirst, expected):
  233:     ambiguous_string = "01/01/2011"
  234:     result = parsing.guess_datetime_format(ambiguous_string, dayfirst=dayfirst)
  235:     assert result == expected
  236: 
  237: 
  238: @td.skip_if_not_us_locale
  239: @pytest.mark.parametrize(
  240:     "string,fmt",
  241:     [
  242:         ("30/Dec/2011", "%d/%b/%Y"),
  243:         ("30/December/2011", "%d/%B/%Y"),
  244:         ("30/Dec/2011 00:00:00", "%d/%b/%Y %H:%M:%S"),
  245:     ],
  246: )
  247: def test_guess_datetime_format_with_locale_specific_formats(string, fmt):
  248:     result = parsing.guess_datetime_format(string)
  249:     assert result == fmt
  250: 
  251: 
  252: @pytest.mark.parametrize(
  253:     "invalid_dt",
  254:     [
  255:         "01/2013",
  256:         "12:00:00",
  257:         "1/1/1/1",
  258:         "this_is_not_a_datetime",
  259:         "51a",
  260:         "13/2019",
  261:         "202001",  # YYYYMM isn't ISO8601
  262:         "2020/01",  # YYYY/MM isn't ISO8601 either
  263:         "87156549591102612381000001219H5",
  264:     ],
  265: )
  266: def test_guess_datetime_format_invalid_inputs(invalid_dt):
  267:     # A datetime string must include a year, month and a day for it to be
  268:     # guessable, in addition to being a string that looks like a datetime.
  269:     assert parsing.guess_datetime_format(invalid_dt) is None
  270: 
  271: 
  272: @pytest.mark.parametrize("invalid_type_dt", [9, datetime(2011, 1, 1)])
  273: def test_guess_datetime_format_wrong_type_inputs(invalid_type_dt):
  274:     # A datetime string must include a year, month and a day for it to be
  275:     # guessable, in addition to being a string that looks like a datetime.
  276:     with pytest.raises(
  277:         TypeError,
  278:         match=r"^Argument 'dt_str' has incorrect type \(expected str, got .*\)$",
  279:     ):
  280:         parsing.guess_datetime_format(invalid_type_dt)
  281: 
  282: 
  283: @pytest.mark.parametrize(
  284:     "string,fmt,dayfirst,warning",
  285:     [
  286:         ("2011-1-1", "%Y-%m-%d", False, None),
  287:         ("2011-1-1", "%Y-%d-%m", True, None),
  288:         ("1/1/2011", "%m/%d/%Y", False, None),
  289:         ("1/1/2011", "%d/%m/%Y", True, None),
  290:         ("30-1-2011", "%d-%m-%Y", False, UserWarning),
  291:         ("30-1-2011", "%d-%m-%Y", True, None),
  292:         ("2011-1-1 0:0:0", "%Y-%m-%d %H:%M:%S", False, None),
  293:         ("2011-1-1 0:0:0", "%Y-%d-%m %H:%M:%S", True, None),
  294:         ("2011-1-3T00:00:0", "%Y-%m-%dT%H:%M:%S", False, None),
  295:         ("2011-1-3T00:00:0", "%Y-%d-%mT%H:%M:%S", True, None),
  296:         ("2011-1-1 00:00:00", "%Y-%m-%d %H:%M:%S", False, None),
  297:         ("2011-1-1 00:00:00", "%Y-%d-%m %H:%M:%S", True, None),
  298:     ],
  299: )
  300: def test_guess_datetime_format_no_padding(string, fmt, dayfirst, warning):
  301:     # see gh-11142
  302:     msg = (
  303:         rf"Parsing dates in {fmt} format when dayfirst=False \(the default\) "
  304:         "was specified. "
  305:         "Pass `dayfirst=True` or specify a format to silence this warning."
  306:     )
  307:     with tm.assert_produces_warning(warning, match=msg):
  308:         result = parsing.guess_datetime_format(string, dayfirst=dayfirst)
  309:     assert result == fmt
  310: 
  311: 
  312: def test_try_parse_dates():
  313:     arr = np.array(["5/1/2000", "6/1/2000", "7/1/2000"], dtype=object)
  314:     result = parsing.try_parse_dates(arr, parser=lambda x: du_parse(x, dayfirst=True))
  315: 
  316:     expected = np.array([du_parse(d, dayfirst=True) for d in arr])
  317:     tm.assert_numpy_array_equal(result, expected)
  318: 
  319: 
  320: def test_parse_datetime_string_with_reso_check_instance_type_raise_exception():
  321:     # issue 20684
  322:     msg = "Argument 'date_string' has incorrect type (expected str, got tuple)"
  323:     with pytest.raises(TypeError, match=re.escape(msg)):
  324:         parse_datetime_string_with_reso((1, 2, 3))
  325: 
  326:     result = parse_datetime_string_with_reso("2019")
  327:     expected = (datetime(2019, 1, 1), "year")
  328:     assert result == expected
  329: 
  330: 
  331: @pytest.mark.parametrize(
  332:     "fmt,expected",
  333:     [
  334:         ("%Y %m %d %H:%M:%S", True),
  335:         ("%Y/%m/%d %H:%M:%S", True),
  336:         (r"%Y\%m\%d %H:%M:%S", True),
  337:         ("%Y-%m-%d %H:%M:%S", True),
  338:         ("%Y.%m.%d %H:%M:%S", True),
  339:         ("%Y%m%d %H:%M:%S", True),
  340:         ("%Y-%m-%dT%H:%M:%S", True),
  341:         ("%Y-%m-%dT%H:%M:%S%z", True),
  342:         ("%Y-%m-%dT%H:%M:%S%Z", False),
  343:         ("%Y-%m-%dT%H:%M:%S.%f", True),
  344:         ("%Y-%m-%dT%H:%M:%S.%f%z", True),
  345:         ("%Y-%m-%dT%H:%M:%S.%f%Z", False),
  346:         ("%Y%m%d", True),
  347:         ("%Y%m", False),
  348:         ("%Y", True),
  349:         ("%Y-%m-%d", True),
  350:         ("%Y-%m", True),
  351:     ],
  352: )
  353: def test_is_iso_format(fmt, expected):
  354:     # see gh-41047
  355:     result = strptime._test_format_is_iso(fmt)
  356:     assert result == expected
  357: 
  358: 
  359: @pytest.mark.parametrize(
  360:     "input",
  361:     [
  362:         "2018-01-01T00:00:00.123456789",
  363:         "2018-01-01T00:00:00.123456",
  364:         "2018-01-01T00:00:00.123",
  365:     ],
  366: )
  367: def test_guess_datetime_format_f(input):
  368:     # https://github.com/pandas-dev/pandas/issues/49043
  369:     result = parsing.guess_datetime_format(input)
  370:     expected = "%Y-%m-%dT%H:%M:%S.%f"
  371:     assert result == expected
  372: 
  373: 
  374: def _helper_hypothesis_delimited_date(call, date_string, **kwargs):
  375:     msg, result = None, None
  376:     try:
  377:         result = call(date_string, **kwargs)
  378:     except ValueError as err:
  379:         msg = str(err)
  380:     return msg, result
  381: 
  382: 
  383: @given(DATETIME_NO_TZ)
  384: @pytest.mark.parametrize("delimiter", list(" -./"))
  385: @pytest.mark.parametrize("dayfirst", [True, False])
  386: @pytest.mark.parametrize(
  387:     "date_format",
  388:     ["%d %m %Y", "%m %d %Y", "%m %Y", "%Y %m %d", "%y %m %d", "%Y%m%d", "%y%m%d"],
  389: )
  390: def test_hypothesis_delimited_date(
  391:     request, date_format, dayfirst, delimiter, test_datetime
  392: ):
  393:     if date_format == "%m %Y" and delimiter == ".":
  394:         request.applymarker(
  395:             pytest.mark.xfail(
  396:                 reason="parse_datetime_string cannot reliably tell whether "
  397:                 "e.g. %m.%Y is a float or a date"
  398:             )
  399:         )
  400:     date_string = test_datetime.strftime(date_format.replace(" ", delimiter))
  401: 
  402:     except_out_dateutil, result = _helper_hypothesis_delimited_date(
  403:         parsing.py_parse_datetime_string, date_string, dayfirst=dayfirst
  404:     )
  405:     except_in_dateutil, expected = _helper_hypothesis_delimited_date(
  406:         du_parse,
  407:         date_string,
  408:         default=datetime(1, 1, 1),
  409:         dayfirst=dayfirst,
  410:         yearfirst=False,
  411:     )
  412: 
  413:     assert except_out_dateutil == except_in_dateutil
  414:     assert result == expected
