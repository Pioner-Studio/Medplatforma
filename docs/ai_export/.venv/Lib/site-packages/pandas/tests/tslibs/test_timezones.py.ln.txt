    1: from datetime import (
    2:     datetime,
    3:     timedelta,
    4:     timezone,
    5: )
    6: 
    7: import dateutil.tz
    8: import pytest
    9: import pytz
   10: 
   11: from pandas._libs.tslibs import (
   12:     conversion,
   13:     timezones,
   14: )
   15: from pandas.compat import is_platform_windows
   16: 
   17: from pandas import Timestamp
   18: 
   19: 
   20: def test_is_utc(utc_fixture):
   21:     tz = timezones.maybe_get_tz(utc_fixture)
   22:     assert timezones.is_utc(tz)
   23: 
   24: 
   25: @pytest.mark.parametrize("tz_name", list(pytz.common_timezones))
   26: def test_cache_keys_are_distinct_for_pytz_vs_dateutil(tz_name):
   27:     tz_p = timezones.maybe_get_tz(tz_name)
   28:     tz_d = timezones.maybe_get_tz("dateutil/" + tz_name)
   29: 
   30:     if tz_d is None:
   31:         pytest.skip(tz_name + ": dateutil does not know about this one")
   32: 
   33:     if not (tz_name == "UTC" and is_platform_windows()):
   34:         # they both end up as tzwin("UTC") on windows
   35:         assert timezones._p_tz_cache_key(tz_p) != timezones._p_tz_cache_key(tz_d)
   36: 
   37: 
   38: def test_tzlocal_repr():
   39:     # see gh-13583
   40:     ts = Timestamp("2011-01-01", tz=dateutil.tz.tzlocal())
   41:     assert ts.tz == dateutil.tz.tzlocal()
   42:     assert "tz='tzlocal()')" in repr(ts)
   43: 
   44: 
   45: def test_tzlocal_maybe_get_tz():
   46:     # see gh-13583
   47:     tz = timezones.maybe_get_tz("tzlocal()")
   48:     assert tz == dateutil.tz.tzlocal()
   49: 
   50: 
   51: def test_tzlocal_offset():
   52:     # see gh-13583
   53:     #
   54:     # Get offset using normal datetime for test.
   55:     ts = Timestamp("2011-01-01", tz=dateutil.tz.tzlocal())
   56: 
   57:     offset = dateutil.tz.tzlocal().utcoffset(datetime(2011, 1, 1))
   58:     offset = offset.total_seconds()
   59: 
   60:     assert ts._value + offset == Timestamp("2011-01-01")._value
   61: 
   62: 
   63: def test_tzlocal_is_not_utc():
   64:     # even if the machine running the test is localized to UTC
   65:     tz = dateutil.tz.tzlocal()
   66:     assert not timezones.is_utc(tz)
   67: 
   68:     assert not timezones.tz_compare(tz, dateutil.tz.tzutc())
   69: 
   70: 
   71: def test_tz_compare_utc(utc_fixture, utc_fixture2):
   72:     tz = timezones.maybe_get_tz(utc_fixture)
   73:     tz2 = timezones.maybe_get_tz(utc_fixture2)
   74:     assert timezones.tz_compare(tz, tz2)
   75: 
   76: 
   77: @pytest.fixture(
   78:     params=[
   79:         (pytz.timezone("US/Eastern"), lambda tz, x: tz.localize(x)),
   80:         (dateutil.tz.gettz("US/Eastern"), lambda tz, x: x.replace(tzinfo=tz)),
   81:     ]
   82: )
   83: def infer_setup(request):
   84:     eastern, localize = request.param
   85: 
   86:     start_naive = datetime(2001, 1, 1)
   87:     end_naive = datetime(2009, 1, 1)
   88: 
   89:     start = localize(eastern, start_naive)
   90:     end = localize(eastern, end_naive)
   91: 
   92:     return eastern, localize, start, end, start_naive, end_naive
   93: 
   94: 
   95: def test_infer_tz_compat(infer_setup):
   96:     eastern, _, start, end, start_naive, end_naive = infer_setup
   97: 
   98:     assert (
   99:         timezones.infer_tzinfo(start, end)
  100:         is conversion.localize_pydatetime(start_naive, eastern).tzinfo
  101:     )
  102:     assert (
  103:         timezones.infer_tzinfo(start, None)
  104:         is conversion.localize_pydatetime(start_naive, eastern).tzinfo
  105:     )
  106:     assert (
  107:         timezones.infer_tzinfo(None, end)
  108:         is conversion.localize_pydatetime(end_naive, eastern).tzinfo
  109:     )
  110: 
  111: 
  112: def test_infer_tz_utc_localize(infer_setup):
  113:     _, _, start, end, start_naive, end_naive = infer_setup
  114:     utc = pytz.utc
  115: 
  116:     start = utc.localize(start_naive)
  117:     end = utc.localize(end_naive)
  118: 
  119:     assert timezones.infer_tzinfo(start, end) is utc
  120: 
  121: 
  122: @pytest.mark.parametrize("ordered", [True, False])
  123: def test_infer_tz_mismatch(infer_setup, ordered):
  124:     eastern, _, _, _, start_naive, end_naive = infer_setup
  125:     msg = "Inputs must both have the same timezone"
  126: 
  127:     utc = pytz.utc
  128:     start = utc.localize(start_naive)
  129:     end = conversion.localize_pydatetime(end_naive, eastern)
  130: 
  131:     args = (start, end) if ordered else (end, start)
  132: 
  133:     with pytest.raises(AssertionError, match=msg):
  134:         timezones.infer_tzinfo(*args)
  135: 
  136: 
  137: def test_maybe_get_tz_invalid_types():
  138:     with pytest.raises(TypeError, match="<class 'float'>"):
  139:         timezones.maybe_get_tz(44.0)
  140: 
  141:     with pytest.raises(TypeError, match="<class 'module'>"):
  142:         timezones.maybe_get_tz(pytz)
  143: 
  144:     msg = "<class 'pandas._libs.tslibs.timestamps.Timestamp'>"
  145:     with pytest.raises(TypeError, match=msg):
  146:         timezones.maybe_get_tz(Timestamp("2021-01-01", tz="UTC"))
  147: 
  148: 
  149: def test_maybe_get_tz_offset_only():
  150:     # see gh-36004
  151: 
  152:     # timezone.utc
  153:     tz = timezones.maybe_get_tz(timezone.utc)
  154:     assert tz == timezone(timedelta(hours=0, minutes=0))
  155: 
  156:     # without UTC+- prefix
  157:     tz = timezones.maybe_get_tz("+01:15")
  158:     assert tz == timezone(timedelta(hours=1, minutes=15))
  159: 
  160:     tz = timezones.maybe_get_tz("-01:15")
  161:     assert tz == timezone(-timedelta(hours=1, minutes=15))
  162: 
  163:     # with UTC+- prefix
  164:     tz = timezones.maybe_get_tz("UTC+02:45")
  165:     assert tz == timezone(timedelta(hours=2, minutes=45))
  166: 
  167:     tz = timezones.maybe_get_tz("UTC-02:45")
  168:     assert tz == timezone(-timedelta(hours=2, minutes=45))
