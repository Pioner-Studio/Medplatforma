    1: from datetime import (
    2:     date,
    3:     datetime,
    4:     timedelta,
    5:     timezone,
    6: )
    7: 
    8: from dateutil.tz.tz import tzoffset
    9: import numpy as np
   10: import pytest
   11: 
   12: from pandas._libs import (
   13:     NaT,
   14:     iNaT,
   15:     tslib,
   16: )
   17: from pandas._libs.tslibs.dtypes import NpyDatetimeUnit
   18: from pandas._libs.tslibs.np_datetime import OutOfBoundsDatetime
   19: 
   20: from pandas import Timestamp
   21: import pandas._testing as tm
   22: 
   23: creso_infer = NpyDatetimeUnit.NPY_FR_GENERIC.value
   24: 
   25: 
   26: class TestArrayToDatetimeResolutionInference:
   27:     # TODO: tests that include tzs, ints
   28: 
   29:     def test_infer_all_nat(self):
   30:         arr = np.array([NaT, np.nan], dtype=object)
   31:         result, tz = tslib.array_to_datetime(arr, creso=creso_infer)
   32:         assert tz is None
   33:         assert result.dtype == "M8[s]"
   34: 
   35:     def test_infer_homogeoneous_datetimes(self):
   36:         dt = datetime(2023, 10, 27, 18, 3, 5, 678000)
   37:         arr = np.array([dt, dt, dt], dtype=object)
   38:         result, tz = tslib.array_to_datetime(arr, creso=creso_infer)
   39:         assert tz is None
   40:         expected = np.array([dt, dt, dt], dtype="M8[us]")
   41:         tm.assert_numpy_array_equal(result, expected)
   42: 
   43:     def test_infer_homogeoneous_date_objects(self):
   44:         dt = datetime(2023, 10, 27, 18, 3, 5, 678000)
   45:         dt2 = dt.date()
   46:         arr = np.array([None, dt2, dt2, dt2], dtype=object)
   47:         result, tz = tslib.array_to_datetime(arr, creso=creso_infer)
   48:         assert tz is None
   49:         expected = np.array([np.datetime64("NaT"), dt2, dt2, dt2], dtype="M8[s]")
   50:         tm.assert_numpy_array_equal(result, expected)
   51: 
   52:     def test_infer_homogeoneous_dt64(self):
   53:         dt = datetime(2023, 10, 27, 18, 3, 5, 678000)
   54:         dt64 = np.datetime64(dt, "ms")
   55:         arr = np.array([None, dt64, dt64, dt64], dtype=object)
   56:         result, tz = tslib.array_to_datetime(arr, creso=creso_infer)
   57:         assert tz is None
   58:         expected = np.array([np.datetime64("NaT"), dt64, dt64, dt64], dtype="M8[ms]")
   59:         tm.assert_numpy_array_equal(result, expected)
   60: 
   61:     def test_infer_homogeoneous_timestamps(self):
   62:         dt = datetime(2023, 10, 27, 18, 3, 5, 678000)
   63:         ts = Timestamp(dt).as_unit("ns")
   64:         arr = np.array([None, ts, ts, ts], dtype=object)
   65:         result, tz = tslib.array_to_datetime(arr, creso=creso_infer)
   66:         assert tz is None
   67:         expected = np.array([np.datetime64("NaT")] + [ts.asm8] * 3, dtype="M8[ns]")
   68:         tm.assert_numpy_array_equal(result, expected)
   69: 
   70:     def test_infer_homogeoneous_datetimes_strings(self):
   71:         item = "2023-10-27 18:03:05.678000"
   72:         arr = np.array([None, item, item, item], dtype=object)
   73:         result, tz = tslib.array_to_datetime(arr, creso=creso_infer)
   74:         assert tz is None
   75:         expected = np.array([np.datetime64("NaT"), item, item, item], dtype="M8[us]")
   76:         tm.assert_numpy_array_equal(result, expected)
   77: 
   78:     def test_infer_heterogeneous(self):
   79:         dtstr = "2023-10-27 18:03:05.678000"
   80: 
   81:         arr = np.array([dtstr, dtstr[:-3], dtstr[:-7], None], dtype=object)
   82:         result, tz = tslib.array_to_datetime(arr, creso=creso_infer)
   83:         assert tz is None
   84:         expected = np.array(arr, dtype="M8[us]")
   85:         tm.assert_numpy_array_equal(result, expected)
   86: 
   87:         result, tz = tslib.array_to_datetime(arr[::-1], creso=creso_infer)
   88:         assert tz is None
   89:         tm.assert_numpy_array_equal(result, expected[::-1])
   90: 
   91:     @pytest.mark.parametrize(
   92:         "item", [float("nan"), NaT.value, float(NaT.value), "NaT", ""]
   93:     )
   94:     def test_infer_with_nat_int_float_str(self, item):
   95:         # floats/ints get inferred to nanos *unless* they are NaN/iNaT,
   96:         # similar NaT string gets treated like NaT scalar (ignored for resolution)
   97:         dt = datetime(2023, 11, 15, 15, 5, 6)
   98: 
   99:         arr = np.array([dt, item], dtype=object)
  100:         result, tz = tslib.array_to_datetime(arr, creso=creso_infer)
  101:         assert tz is None
  102:         expected = np.array([dt, np.datetime64("NaT")], dtype="M8[us]")
  103:         tm.assert_numpy_array_equal(result, expected)
  104: 
  105:         result2, tz2 = tslib.array_to_datetime(arr[::-1], creso=creso_infer)
  106:         assert tz2 is None
  107:         tm.assert_numpy_array_equal(result2, expected[::-1])
  108: 
  109: 
  110: class TestArrayToDatetimeWithTZResolutionInference:
  111:     def test_array_to_datetime_with_tz_resolution(self):
  112:         tz = tzoffset("custom", 3600)
  113:         vals = np.array(["2016-01-01 02:03:04.567", NaT], dtype=object)
  114:         res = tslib.array_to_datetime_with_tz(vals, tz, False, False, creso_infer)
  115:         assert res.dtype == "M8[ms]"
  116: 
  117:         vals2 = np.array([datetime(2016, 1, 1, 2, 3, 4), NaT], dtype=object)
  118:         res2 = tslib.array_to_datetime_with_tz(vals2, tz, False, False, creso_infer)
  119:         assert res2.dtype == "M8[us]"
  120: 
  121:         vals3 = np.array([NaT, np.datetime64(12345, "s")], dtype=object)
  122:         res3 = tslib.array_to_datetime_with_tz(vals3, tz, False, False, creso_infer)
  123:         assert res3.dtype == "M8[s]"
  124: 
  125:     def test_array_to_datetime_with_tz_resolution_all_nat(self):
  126:         tz = tzoffset("custom", 3600)
  127:         vals = np.array(["NaT"], dtype=object)
  128:         res = tslib.array_to_datetime_with_tz(vals, tz, False, False, creso_infer)
  129:         assert res.dtype == "M8[s]"
  130: 
  131:         vals2 = np.array([NaT, NaT], dtype=object)
  132:         res2 = tslib.array_to_datetime_with_tz(vals2, tz, False, False, creso_infer)
  133:         assert res2.dtype == "M8[s]"
  134: 
  135: 
  136: @pytest.mark.parametrize(
  137:     "data,expected",
  138:     [
  139:         (
  140:             ["01-01-2013", "01-02-2013"],
  141:             [
  142:                 "2013-01-01T00:00:00.000000000",
  143:                 "2013-01-02T00:00:00.000000000",
  144:             ],
  145:         ),
  146:         (
  147:             ["Mon Sep 16 2013", "Tue Sep 17 2013"],
  148:             [
  149:                 "2013-09-16T00:00:00.000000000",
  150:                 "2013-09-17T00:00:00.000000000",
  151:             ],
  152:         ),
  153:     ],
  154: )
  155: def test_parsing_valid_dates(data, expected):
  156:     arr = np.array(data, dtype=object)
  157:     result, _ = tslib.array_to_datetime(arr)
  158: 
  159:     expected = np.array(expected, dtype="M8[ns]")
  160:     tm.assert_numpy_array_equal(result, expected)
  161: 
  162: 
  163: @pytest.mark.parametrize(
  164:     "dt_string, expected_tz",
  165:     [
  166:         ["01-01-2013 08:00:00+08:00", 480],
  167:         ["2013-01-01T08:00:00.000000000+0800", 480],
  168:         ["2012-12-31T16:00:00.000000000-0800", -480],
  169:         ["12-31-2012 23:00:00-01:00", -60],
  170:     ],
  171: )
  172: def test_parsing_timezone_offsets(dt_string, expected_tz):
  173:     # All of these datetime strings with offsets are equivalent
  174:     # to the same datetime after the timezone offset is added.
  175:     arr = np.array(["01-01-2013 00:00:00"], dtype=object)
  176:     expected, _ = tslib.array_to_datetime(arr)
  177: 
  178:     arr = np.array([dt_string], dtype=object)
  179:     result, result_tz = tslib.array_to_datetime(arr)
  180: 
  181:     tm.assert_numpy_array_equal(result, expected)
  182:     assert result_tz == timezone(timedelta(minutes=expected_tz))
  183: 
  184: 
  185: def test_parsing_non_iso_timezone_offset():
  186:     dt_string = "01-01-2013T00:00:00.000000000+0000"
  187:     arr = np.array([dt_string], dtype=object)
  188: 
  189:     with tm.assert_produces_warning(None):
  190:         # GH#50949 should not get tzlocal-deprecation warning here
  191:         result, result_tz = tslib.array_to_datetime(arr)
  192:     expected = np.array([np.datetime64("2013-01-01 00:00:00.000000000")])
  193: 
  194:     tm.assert_numpy_array_equal(result, expected)
  195:     assert result_tz is timezone.utc
  196: 
  197: 
  198: def test_parsing_different_timezone_offsets():
  199:     # see gh-17697
  200:     data = ["2015-11-18 15:30:00+05:30", "2015-11-18 15:30:00+06:30"]
  201:     data = np.array(data, dtype=object)
  202: 
  203:     msg = "parsing datetimes with mixed time zones will raise an error"
  204:     with tm.assert_produces_warning(FutureWarning, match=msg):
  205:         result, result_tz = tslib.array_to_datetime(data)
  206:     expected = np.array(
  207:         [
  208:             datetime(2015, 11, 18, 15, 30, tzinfo=tzoffset(None, 19800)),
  209:             datetime(2015, 11, 18, 15, 30, tzinfo=tzoffset(None, 23400)),
  210:         ],
  211:         dtype=object,
  212:     )
  213: 
  214:     tm.assert_numpy_array_equal(result, expected)
  215:     assert result_tz is None
  216: 
  217: 
  218: @pytest.mark.parametrize(
  219:     "data", [["-352.737091", "183.575577"], ["1", "2", "3", "4", "5"]]
  220: )
  221: def test_number_looking_strings_not_into_datetime(data):
  222:     # see gh-4601
  223:     #
  224:     # These strings don't look like datetimes, so
  225:     # they shouldn't be attempted to be converted.
  226:     arr = np.array(data, dtype=object)
  227:     result, _ = tslib.array_to_datetime(arr, errors="ignore")
  228: 
  229:     tm.assert_numpy_array_equal(result, arr)
  230: 
  231: 
  232: @pytest.mark.parametrize(
  233:     "invalid_date",
  234:     [
  235:         date(1000, 1, 1),
  236:         datetime(1000, 1, 1),
  237:         "1000-01-01",
  238:         "Jan 1, 1000",
  239:         np.datetime64("1000-01-01"),
  240:     ],
  241: )
  242: @pytest.mark.parametrize("errors", ["coerce", "raise"])
  243: def test_coerce_outside_ns_bounds(invalid_date, errors):
  244:     arr = np.array([invalid_date], dtype="object")
  245:     kwargs = {"values": arr, "errors": errors}
  246: 
  247:     if errors == "raise":
  248:         msg = "^Out of bounds nanosecond timestamp: .*, at position 0$"
  249: 
  250:         with pytest.raises(OutOfBoundsDatetime, match=msg):
  251:             tslib.array_to_datetime(**kwargs)
  252:     else:  # coerce.
  253:         result, _ = tslib.array_to_datetime(**kwargs)
  254:         expected = np.array([iNaT], dtype="M8[ns]")
  255: 
  256:         tm.assert_numpy_array_equal(result, expected)
  257: 
  258: 
  259: def test_coerce_outside_ns_bounds_one_valid():
  260:     arr = np.array(["1/1/1000", "1/1/2000"], dtype=object)
  261:     result, _ = tslib.array_to_datetime(arr, errors="coerce")
  262: 
  263:     expected = [iNaT, "2000-01-01T00:00:00.000000000"]
  264:     expected = np.array(expected, dtype="M8[ns]")
  265: 
  266:     tm.assert_numpy_array_equal(result, expected)
  267: 
  268: 
  269: @pytest.mark.parametrize("errors", ["ignore", "coerce"])
  270: def test_coerce_of_invalid_datetimes(errors):
  271:     arr = np.array(["01-01-2013", "not_a_date", "1"], dtype=object)
  272:     kwargs = {"values": arr, "errors": errors}
  273: 
  274:     if errors == "ignore":
  275:         # Without coercing, the presence of any invalid
  276:         # dates prevents any values from being converted.
  277:         result, _ = tslib.array_to_datetime(**kwargs)
  278:         tm.assert_numpy_array_equal(result, arr)
  279:     else:  # coerce.
  280:         # With coercing, the invalid dates becomes iNaT
  281:         result, _ = tslib.array_to_datetime(arr, errors="coerce")
  282:         expected = ["2013-01-01T00:00:00.000000000", iNaT, iNaT]
  283: 
  284:         tm.assert_numpy_array_equal(result, np.array(expected, dtype="M8[ns]"))
  285: 
  286: 
  287: def test_to_datetime_barely_out_of_bounds():
  288:     # see gh-19382, gh-19529
  289:     #
  290:     # Close enough to bounds that dropping nanos
  291:     # would result in an in-bounds datetime.
  292:     arr = np.array(["2262-04-11 23:47:16.854775808"], dtype=object)
  293:     msg = "^Out of bounds nanosecond timestamp: 2262-04-11 23:47:16, at position 0$"
  294: 
  295:     with pytest.raises(tslib.OutOfBoundsDatetime, match=msg):
  296:         tslib.array_to_datetime(arr)
  297: 
  298: 
  299: @pytest.mark.parametrize(
  300:     "timestamp",
  301:     [
  302:         # Close enough to bounds that scaling micros to nanos overflows
  303:         # but adding nanos would result in an in-bounds datetime.
  304:         "1677-09-21T00:12:43.145224193",
  305:         "1677-09-21T00:12:43.145224999",
  306:         # this always worked
  307:         "1677-09-21T00:12:43.145225000",
  308:     ],
  309: )
  310: def test_to_datetime_barely_inside_bounds(timestamp):
  311:     # see gh-57150
  312:     result, _ = tslib.array_to_datetime(np.array([timestamp], dtype=object))
  313:     tm.assert_numpy_array_equal(result, np.array([timestamp], dtype="M8[ns]"))
  314: 
  315: 
  316: class SubDatetime(datetime):
  317:     pass
  318: 
  319: 
  320: @pytest.mark.parametrize(
  321:     "data,expected",
  322:     [
  323:         ([SubDatetime(2000, 1, 1)], ["2000-01-01T00:00:00.000000000"]),
  324:         ([datetime(2000, 1, 1)], ["2000-01-01T00:00:00.000000000"]),
  325:         ([Timestamp(2000, 1, 1)], ["2000-01-01T00:00:00.000000000"]),
  326:     ],
  327: )
  328: def test_datetime_subclass(data, expected):
  329:     # GH 25851
  330:     # ensure that subclassed datetime works with
  331:     # array_to_datetime
  332: 
  333:     arr = np.array(data, dtype=object)
  334:     result, _ = tslib.array_to_datetime(arr)
  335: 
  336:     expected = np.array(expected, dtype="M8[ns]")
  337:     tm.assert_numpy_array_equal(result, expected)
