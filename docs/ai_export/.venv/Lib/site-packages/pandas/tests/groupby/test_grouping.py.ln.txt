    1: """
    2: test where we are determining what we are grouping, or getting groups
    3: """
    4: from datetime import (
    5:     date,
    6:     timedelta,
    7: )
    8: 
    9: import numpy as np
   10: import pytest
   11: 
   12: import pandas as pd
   13: from pandas import (
   14:     CategoricalIndex,
   15:     DataFrame,
   16:     Grouper,
   17:     Index,
   18:     MultiIndex,
   19:     Series,
   20:     Timestamp,
   21:     date_range,
   22:     period_range,
   23: )
   24: import pandas._testing as tm
   25: from pandas.core.groupby.grouper import Grouping
   26: 
   27: # selection
   28: # --------------------------------
   29: 
   30: 
   31: class TestSelection:
   32:     def test_select_bad_cols(self):
   33:         df = DataFrame([[1, 2]], columns=["A", "B"])
   34:         g = df.groupby("A")
   35:         with pytest.raises(KeyError, match="\"Columns not found: 'C'\""):
   36:             g[["C"]]
   37: 
   38:         with pytest.raises(KeyError, match="^[^A]+$"):
   39:             # A should not be referenced as a bad column...
   40:             # will have to rethink regex if you change message!
   41:             g[["A", "C"]]
   42: 
   43:     def test_groupby_duplicated_column_errormsg(self):
   44:         # GH7511
   45:         df = DataFrame(
   46:             columns=["A", "B", "A", "C"], data=[range(4), range(2, 6), range(0, 8, 2)]
   47:         )
   48: 
   49:         msg = "Grouper for 'A' not 1-dimensional"
   50:         with pytest.raises(ValueError, match=msg):
   51:             df.groupby("A")
   52:         with pytest.raises(ValueError, match=msg):
   53:             df.groupby(["A", "B"])
   54: 
   55:         grouped = df.groupby("B")
   56:         c = grouped.count()
   57:         assert c.columns.nlevels == 1
   58:         assert c.columns.size == 3
   59: 
   60:     def test_column_select_via_attr(self, df):
   61:         result = df.groupby("A").C.sum()
   62:         expected = df.groupby("A")["C"].sum()
   63:         tm.assert_series_equal(result, expected)
   64: 
   65:         df["mean"] = 1.5
   66:         result = df.groupby("A").mean(numeric_only=True)
   67:         expected = df.groupby("A")[["C", "D", "mean"]].agg("mean")
   68:         tm.assert_frame_equal(result, expected)
   69: 
   70:     def test_getitem_list_of_columns(self):
   71:         df = DataFrame(
   72:             {
   73:                 "A": ["foo", "bar", "foo", "bar", "foo", "bar", "foo", "foo"],
   74:                 "B": ["one", "one", "two", "three", "two", "two", "one", "three"],
   75:                 "C": np.random.default_rng(2).standard_normal(8),
   76:                 "D": np.random.default_rng(2).standard_normal(8),
   77:                 "E": np.random.default_rng(2).standard_normal(8),
   78:             }
   79:         )
   80: 
   81:         result = df.groupby("A")[["C", "D"]].mean()
   82:         result2 = df.groupby("A")[df.columns[2:4]].mean()
   83: 
   84:         expected = df.loc[:, ["A", "C", "D"]].groupby("A").mean()
   85: 
   86:         tm.assert_frame_equal(result, expected)
   87:         tm.assert_frame_equal(result2, expected)
   88: 
   89:     def test_getitem_numeric_column_names(self):
   90:         # GH #13731
   91:         df = DataFrame(
   92:             {
   93:                 0: list("abcd") * 2,
   94:                 2: np.random.default_rng(2).standard_normal(8),
   95:                 4: np.random.default_rng(2).standard_normal(8),
   96:                 6: np.random.default_rng(2).standard_normal(8),
   97:             }
   98:         )
   99:         result = df.groupby(0)[df.columns[1:3]].mean()
  100:         result2 = df.groupby(0)[[2, 4]].mean()
  101: 
  102:         expected = df.loc[:, [0, 2, 4]].groupby(0).mean()
  103: 
  104:         tm.assert_frame_equal(result, expected)
  105:         tm.assert_frame_equal(result2, expected)
  106: 
  107:         # per GH 23566 enforced deprecation raises a ValueError
  108:         with pytest.raises(ValueError, match="Cannot subset columns with a tuple"):
  109:             df.groupby(0)[2, 4].mean()
  110: 
  111:     def test_getitem_single_tuple_of_columns_raises(self, df):
  112:         # per GH 23566 enforced deprecation raises a ValueError
  113:         with pytest.raises(ValueError, match="Cannot subset columns with a tuple"):
  114:             df.groupby("A")["C", "D"].mean()
  115: 
  116:     def test_getitem_single_column(self):
  117:         df = DataFrame(
  118:             {
  119:                 "A": ["foo", "bar", "foo", "bar", "foo", "bar", "foo", "foo"],
  120:                 "B": ["one", "one", "two", "three", "two", "two", "one", "three"],
  121:                 "C": np.random.default_rng(2).standard_normal(8),
  122:                 "D": np.random.default_rng(2).standard_normal(8),
  123:                 "E": np.random.default_rng(2).standard_normal(8),
  124:             }
  125:         )
  126: 
  127:         result = df.groupby("A")["C"].mean()
  128: 
  129:         as_frame = df.loc[:, ["A", "C"]].groupby("A").mean()
  130:         as_series = as_frame.iloc[:, 0]
  131:         expected = as_series
  132: 
  133:         tm.assert_series_equal(result, expected)
  134: 
  135:     @pytest.mark.parametrize(
  136:         "func", [lambda x: x.sum(), lambda x: x.agg(lambda y: y.sum())]
  137:     )
  138:     def test_getitem_from_grouper(self, func):
  139:         # GH 50383
  140:         df = DataFrame({"a": [1, 1, 2], "b": 3, "c": 4, "d": 5})
  141:         gb = df.groupby(["a", "b"])[["a", "c"]]
  142: 
  143:         idx = MultiIndex.from_tuples([(1, 3), (2, 3)], names=["a", "b"])
  144:         expected = DataFrame({"a": [2, 2], "c": [8, 4]}, index=idx)
  145:         result = func(gb)
  146: 
  147:         tm.assert_frame_equal(result, expected)
  148: 
  149:     def test_indices_grouped_by_tuple_with_lambda(self):
  150:         # GH 36158
  151:         df = DataFrame(
  152:             {
  153:                 "Tuples": (
  154:                     (x, y)
  155:                     for x in [0, 1]
  156:                     for y in np.random.default_rng(2).integers(3, 5, 5)
  157:                 )
  158:             }
  159:         )
  160: 
  161:         gb = df.groupby("Tuples")
  162:         gb_lambda = df.groupby(lambda x: df.iloc[x, 0])
  163: 
  164:         expected = gb.indices
  165:         result = gb_lambda.indices
  166: 
  167:         tm.assert_dict_equal(result, expected)
  168: 
  169: 
  170: # grouping
  171: # --------------------------------
  172: 
  173: 
  174: class TestGrouping:
  175:     @pytest.mark.parametrize(
  176:         "index",
  177:         [
  178:             Index(list("abcde")),
  179:             Index(np.arange(5)),
  180:             Index(np.arange(5, dtype=float)),
  181:             date_range("2020-01-01", periods=5),
  182:             period_range("2020-01-01", periods=5),
  183:         ],
  184:     )
  185:     def test_grouper_index_types(self, index):
  186:         # related GH5375
  187:         # groupby misbehaving when using a Floatlike index
  188:         df = DataFrame(np.arange(10).reshape(5, 2), columns=list("AB"), index=index)
  189: 
  190:         df.groupby(list("abcde"), group_keys=False).apply(lambda x: x)
  191: 
  192:         df.index = df.index[::-1]
  193:         df.groupby(list("abcde"), group_keys=False).apply(lambda x: x)
  194: 
  195:     def test_grouper_multilevel_freq(self):
  196:         # GH 7885
  197:         # with level and freq specified in a Grouper
  198:         d0 = date.today() - timedelta(days=14)
  199:         dates = date_range(d0, date.today())
  200:         date_index = MultiIndex.from_product([dates, dates], names=["foo", "bar"])
  201:         df = DataFrame(np.random.default_rng(2).integers(0, 100, 225), index=date_index)
  202: 
  203:         # Check string level
  204:         expected = (
  205:             df.reset_index()
  206:             .groupby([Grouper(key="foo", freq="W"), Grouper(key="bar", freq="W")])
  207:             .sum()
  208:         )
  209:         # reset index changes columns dtype to object
  210:         expected.columns = Index([0], dtype="int64")
  211: 
  212:         result = df.groupby(
  213:             [Grouper(level="foo", freq="W"), Grouper(level="bar", freq="W")]
  214:         ).sum()
  215:         tm.assert_frame_equal(result, expected)
  216: 
  217:         # Check integer level
  218:         result = df.groupby(
  219:             [Grouper(level=0, freq="W"), Grouper(level=1, freq="W")]
  220:         ).sum()
  221:         tm.assert_frame_equal(result, expected)
  222: 
  223:     def test_grouper_creation_bug(self):
  224:         # GH 8795
  225:         df = DataFrame({"A": [0, 0, 1, 1, 2, 2], "B": [1, 2, 3, 4, 5, 6]})
  226:         g = df.groupby("A")
  227:         expected = g.sum()
  228: 
  229:         g = df.groupby(Grouper(key="A"))
  230:         result = g.sum()
  231:         tm.assert_frame_equal(result, expected)
  232: 
  233:         msg = "Grouper axis keyword is deprecated and will be removed"
  234:         with tm.assert_produces_warning(FutureWarning, match=msg):
  235:             gpr = Grouper(key="A", axis=0)
  236:         g = df.groupby(gpr)
  237:         result = g.sum()
  238:         tm.assert_frame_equal(result, expected)
  239: 
  240:         msg = "DataFrameGroupBy.apply operated on the grouping columns"
  241:         with tm.assert_produces_warning(DeprecationWarning, match=msg):
  242:             result = g.apply(lambda x: x.sum())
  243:         expected["A"] = [0, 2, 4]
  244:         expected = expected.loc[:, ["A", "B"]]
  245:         tm.assert_frame_equal(result, expected)
  246: 
  247:     def test_grouper_creation_bug2(self):
  248:         # GH14334
  249:         # Grouper(key=...) may be passed in a list
  250:         df = DataFrame(
  251:             {"A": [0, 0, 0, 1, 1, 1], "B": [1, 1, 2, 2, 3, 3], "C": [1, 2, 3, 4, 5, 6]}
  252:         )
  253:         # Group by single column
  254:         expected = df.groupby("A").sum()
  255:         g = df.groupby([Grouper(key="A")])
  256:         result = g.sum()
  257:         tm.assert_frame_equal(result, expected)
  258: 
  259:         # Group by two columns
  260:         # using a combination of strings and Grouper objects
  261:         expected = df.groupby(["A", "B"]).sum()
  262: 
  263:         # Group with two Grouper objects
  264:         g = df.groupby([Grouper(key="A"), Grouper(key="B")])
  265:         result = g.sum()
  266:         tm.assert_frame_equal(result, expected)
  267: 
  268:         # Group with a string and a Grouper object
  269:         g = df.groupby(["A", Grouper(key="B")])
  270:         result = g.sum()
  271:         tm.assert_frame_equal(result, expected)
  272: 
  273:         # Group with a Grouper object and a string
  274:         g = df.groupby([Grouper(key="A"), "B"])
  275:         result = g.sum()
  276:         tm.assert_frame_equal(result, expected)
  277: 
  278:     def test_grouper_creation_bug3(self, unit):
  279:         # GH8866
  280:         dti = date_range("20130101", periods=2, unit=unit)
  281:         mi = MultiIndex.from_product(
  282:             [list("ab"), range(2), dti],
  283:             names=["one", "two", "three"],
  284:         )
  285:         ser = Series(
  286:             np.arange(8, dtype="int64"),
  287:             index=mi,
  288:         )
  289:         result = ser.groupby(Grouper(level="three", freq="ME")).sum()
  290:         exp_dti = pd.DatetimeIndex(
  291:             [Timestamp("2013-01-31")], freq="ME", name="three"
  292:         ).as_unit(unit)
  293:         expected = Series(
  294:             [28],
  295:             index=exp_dti,
  296:         )
  297:         tm.assert_series_equal(result, expected)
  298: 
  299:         # just specifying a level breaks
  300:         result = ser.groupby(Grouper(level="one")).sum()
  301:         expected = ser.groupby(level="one").sum()
  302:         tm.assert_series_equal(result, expected)
  303: 
  304:     @pytest.mark.parametrize("func", [False, True])
  305:     def test_grouper_returning_tuples(self, func):
  306:         # GH 22257 , both with dict and with callable
  307:         df = DataFrame({"X": ["A", "B", "A", "B"], "Y": [1, 4, 3, 2]})
  308:         mapping = dict(zip(range(4), [("C", 5), ("D", 6)] * 2))
  309: 
  310:         if func:
  311:             gb = df.groupby(by=lambda idx: mapping[idx], sort=False)
  312:         else:
  313:             gb = df.groupby(by=mapping, sort=False)
  314: 
  315:         name, expected = next(iter(gb))
  316:         assert name == ("C", 5)
  317:         result = gb.get_group(name)
  318: 
  319:         tm.assert_frame_equal(result, expected)
  320: 
  321:     def test_grouper_column_and_index(self):
  322:         # GH 14327
  323: 
  324:         # Grouping a multi-index frame by a column and an index level should
  325:         # be equivalent to resetting the index and grouping by two columns
  326:         idx = MultiIndex.from_tuples(
  327:             [("a", 1), ("a", 2), ("a", 3), ("b", 1), ("b", 2), ("b", 3)]
  328:         )
  329:         idx.names = ["outer", "inner"]
  330:         df_multi = DataFrame(
  331:             {"A": np.arange(6), "B": ["one", "one", "two", "two", "one", "one"]},
  332:             index=idx,
  333:         )
  334:         result = df_multi.groupby(["B", Grouper(level="inner")]).mean(numeric_only=True)
  335:         expected = (
  336:             df_multi.reset_index().groupby(["B", "inner"]).mean(numeric_only=True)
  337:         )
  338:         tm.assert_frame_equal(result, expected)
  339: 
  340:         # Test the reverse grouping order
  341:         result = df_multi.groupby([Grouper(level="inner"), "B"]).mean(numeric_only=True)
  342:         expected = (
  343:             df_multi.reset_index().groupby(["inner", "B"]).mean(numeric_only=True)
  344:         )
  345:         tm.assert_frame_equal(result, expected)
  346: 
  347:         # Grouping a single-index frame by a column and the index should
  348:         # be equivalent to resetting the index and grouping by two columns
  349:         df_single = df_multi.reset_index("outer")
  350:         result = df_single.groupby(["B", Grouper(level="inner")]).mean(
  351:             numeric_only=True
  352:         )
  353:         expected = (
  354:             df_single.reset_index().groupby(["B", "inner"]).mean(numeric_only=True)
  355:         )
  356:         tm.assert_frame_equal(result, expected)
  357: 
  358:         # Test the reverse grouping order
  359:         result = df_single.groupby([Grouper(level="inner"), "B"]).mean(
  360:             numeric_only=True
  361:         )
  362:         expected = (
  363:             df_single.reset_index().groupby(["inner", "B"]).mean(numeric_only=True)
  364:         )
  365:         tm.assert_frame_equal(result, expected)
  366: 
  367:     def test_groupby_levels_and_columns(self):
  368:         # GH9344, GH9049
  369:         idx_names = ["x", "y"]
  370:         idx = MultiIndex.from_tuples([(1, 1), (1, 2), (3, 4), (5, 6)], names=idx_names)
  371:         df = DataFrame(np.arange(12).reshape(-1, 3), index=idx)
  372: 
  373:         by_levels = df.groupby(level=idx_names).mean()
  374:         # reset_index changes columns dtype to object
  375:         by_columns = df.reset_index().groupby(idx_names).mean()
  376: 
  377:         # without casting, by_columns.columns is object-dtype
  378:         by_columns.columns = by_columns.columns.astype(np.int64)
  379:         tm.assert_frame_equal(by_levels, by_columns)
  380: 
  381:     def test_groupby_categorical_index_and_columns(self, observed):
  382:         # GH18432, adapted for GH25871
  383:         columns = ["A", "B", "A", "B"]
  384:         categories = ["B", "A"]
  385:         data = np.array(
  386:             [[1, 2, 1, 2], [1, 2, 1, 2], [1, 2, 1, 2], [1, 2, 1, 2], [1, 2, 1, 2]], int
  387:         )
  388:         cat_columns = CategoricalIndex(columns, categories=categories, ordered=True)
  389:         df = DataFrame(data=data, columns=cat_columns)
  390:         depr_msg = "DataFrame.groupby with axis=1 is deprecated"
  391:         with tm.assert_produces_warning(FutureWarning, match=depr_msg):
  392:             result = df.groupby(axis=1, level=0, observed=observed).sum()
  393:         expected_data = np.array([[4, 2], [4, 2], [4, 2], [4, 2], [4, 2]], int)
  394:         expected_columns = CategoricalIndex(
  395:             categories, categories=categories, ordered=True
  396:         )
  397:         expected = DataFrame(data=expected_data, columns=expected_columns)
  398:         tm.assert_frame_equal(result, expected)
  399: 
  400:         # test transposed version
  401:         df = DataFrame(data.T, index=cat_columns)
  402:         msg = "The 'axis' keyword in DataFrame.groupby is deprecated"
  403:         with tm.assert_produces_warning(FutureWarning, match=msg):
  404:             result = df.groupby(axis=0, level=0, observed=observed).sum()
  405:         expected = DataFrame(data=expected_data.T, index=expected_columns)
  406:         tm.assert_frame_equal(result, expected)
  407: 
  408:     def test_grouper_getting_correct_binner(self):
  409:         # GH 10063
  410:         # using a non-time-based grouper and a time-based grouper
  411:         # and specifying levels
  412:         df = DataFrame(
  413:             {"A": 1},
  414:             index=MultiIndex.from_product(
  415:                 [list("ab"), date_range("20130101", periods=80)], names=["one", "two"]
  416:             ),
  417:         )
  418:         result = df.groupby(
  419:             [Grouper(level="one"), Grouper(level="two", freq="ME")]
  420:         ).sum()
  421:         expected = DataFrame(
  422:             {"A": [31, 28, 21, 31, 28, 21]},
  423:             index=MultiIndex.from_product(
  424:                 [list("ab"), date_range("20130101", freq="ME", periods=3)],
  425:                 names=["one", "two"],
  426:             ),
  427:         )
  428:         tm.assert_frame_equal(result, expected)
  429: 
  430:     def test_grouper_iter(self, df):
  431:         gb = df.groupby("A")
  432:         msg = "DataFrameGroupBy.grouper is deprecated"
  433:         with tm.assert_produces_warning(FutureWarning, match=msg):
  434:             grouper = gb.grouper
  435:         result = sorted(grouper)
  436:         expected = ["bar", "foo"]
  437:         assert result == expected
  438: 
  439:     def test_empty_groups(self, df):
  440:         # see gh-1048
  441:         with pytest.raises(ValueError, match="No group keys passed!"):
  442:             df.groupby([])
  443: 
  444:     def test_groupby_grouper(self, df):
  445:         grouped = df.groupby("A")
  446:         msg = "DataFrameGroupBy.grouper is deprecated"
  447:         with tm.assert_produces_warning(FutureWarning, match=msg):
  448:             grouper = grouped.grouper
  449:         result = df.groupby(grouper).mean(numeric_only=True)
  450:         expected = grouped.mean(numeric_only=True)
  451:         tm.assert_frame_equal(result, expected)
  452: 
  453:     def test_groupby_dict_mapping(self):
  454:         # GH #679
  455:         s = Series({"T1": 5})
  456:         result = s.groupby({"T1": "T2"}).agg("sum")
  457:         expected = s.groupby(["T2"]).agg("sum")
  458:         tm.assert_series_equal(result, expected)
  459: 
  460:         s = Series([1.0, 2.0, 3.0, 4.0], index=list("abcd"))
  461:         mapping = {"a": 0, "b": 0, "c": 1, "d": 1}
  462: 
  463:         result = s.groupby(mapping).mean()
  464:         result2 = s.groupby(mapping).agg("mean")
  465:         exp_key = np.array([0, 0, 1, 1], dtype=np.int64)
  466:         expected = s.groupby(exp_key).mean()
  467:         expected2 = s.groupby(exp_key).mean()
  468:         tm.assert_series_equal(result, expected)
  469:         tm.assert_series_equal(result, result2)
  470:         tm.assert_series_equal(result, expected2)
  471: 
  472:     @pytest.mark.parametrize(
  473:         "index",
  474:         [
  475:             [0, 1, 2, 3],
  476:             ["a", "b", "c", "d"],
  477:             [Timestamp(2021, 7, 28 + i) for i in range(4)],
  478:         ],
  479:     )
  480:     def test_groupby_series_named_with_tuple(self, frame_or_series, index):
  481:         # GH 42731
  482:         obj = frame_or_series([1, 2, 3, 4], index=index)
  483:         groups = Series([1, 0, 1, 0], index=index, name=("a", "a"))
  484:         result = obj.groupby(groups).last()
  485:         expected = frame_or_series([4, 3])
  486:         expected.index.name = ("a", "a")
  487:         tm.assert_equal(result, expected)
  488: 
  489:     def test_groupby_grouper_f_sanity_checked(self):
  490:         dates = date_range("01-Jan-2013", periods=12, freq="MS")
  491:         ts = Series(np.random.default_rng(2).standard_normal(12), index=dates)
  492: 
  493:         # GH51979
  494:         # simple check that the passed function doesn't operates on the whole index
  495:         msg = "'Timestamp' object is not subscriptable"
  496:         with pytest.raises(TypeError, match=msg):
  497:             ts.groupby(lambda key: key[0:6])
  498: 
  499:         result = ts.groupby(lambda x: x).sum()
  500:         expected = ts.groupby(ts.index).sum()
  501:         expected.index.freq = None
  502:         tm.assert_series_equal(result, expected)
  503: 
  504:     def test_groupby_with_datetime_key(self):
  505:         # GH 51158
  506:         df = DataFrame(
  507:             {
  508:                 "id": ["a", "b"] * 3,
  509:                 "b": date_range("2000-01-01", "2000-01-03", freq="9h"),
  510:             }
  511:         )
  512:         grouper = Grouper(key="b", freq="D")
  513:         gb = df.groupby([grouper, "id"])
  514: 
  515:         # test number of groups
  516:         expected = {
  517:             (Timestamp("2000-01-01"), "a"): [0, 2],
  518:             (Timestamp("2000-01-01"), "b"): [1],
  519:             (Timestamp("2000-01-02"), "a"): [4],
  520:             (Timestamp("2000-01-02"), "b"): [3, 5],
  521:         }
  522:         tm.assert_dict_equal(gb.groups, expected)
  523: 
  524:         # test number of group keys
  525:         assert len(gb.groups.keys()) == 4
  526: 
  527:     def test_grouping_error_on_multidim_input(self, df):
  528:         msg = "Grouper for '<class 'pandas.core.frame.DataFrame'>' not 1-dimensional"
  529:         with pytest.raises(ValueError, match=msg):
  530:             Grouping(df.index, df[["A", "A"]])
  531: 
  532:     def test_multiindex_passthru(self):
  533:         # GH 7997
  534:         # regression from 0.14.1
  535:         df = DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
  536:         df.columns = MultiIndex.from_tuples([(0, 1), (1, 1), (2, 1)])
  537: 
  538:         depr_msg = "DataFrame.groupby with axis=1 is deprecated"
  539:         with tm.assert_produces_warning(FutureWarning, match=depr_msg):
  540:             gb = df.groupby(axis=1, level=[0, 1])
  541:         result = gb.first()
  542:         tm.assert_frame_equal(result, df)
  543: 
  544:     def test_multiindex_negative_level(self, multiindex_dataframe_random_data):
  545:         # GH 13901
  546:         result = multiindex_dataframe_random_data.groupby(level=-1).sum()
  547:         expected = multiindex_dataframe_random_data.groupby(level="second").sum()
  548:         tm.assert_frame_equal(result, expected)
  549: 
  550:         result = multiindex_dataframe_random_data.groupby(level=-2).sum()
  551:         expected = multiindex_dataframe_random_data.groupby(level="first").sum()
  552:         tm.assert_frame_equal(result, expected)
  553: 
  554:         result = multiindex_dataframe_random_data.groupby(level=[-2, -1]).sum()
  555:         expected = multiindex_dataframe_random_data.sort_index()
  556:         tm.assert_frame_equal(result, expected)
  557: 
  558:         result = multiindex_dataframe_random_data.groupby(level=[-1, "first"]).sum()
  559:         expected = multiindex_dataframe_random_data.groupby(
  560:             level=["second", "first"]
  561:         ).sum()
  562:         tm.assert_frame_equal(result, expected)
  563: 
  564:     def test_multifunc_select_col_integer_cols(self, df):
  565:         df.columns = np.arange(len(df.columns))
  566: 
  567:         # it works!
  568:         msg = "Passing a dictionary to SeriesGroupBy.agg is deprecated"
  569:         with tm.assert_produces_warning(FutureWarning, match=msg):
  570:             df.groupby(1, as_index=False)[2].agg({"Q": np.mean})
  571: 
  572:     def test_multiindex_columns_empty_level(self):
  573:         lst = [["count", "values"], ["to filter", ""]]
  574:         midx = MultiIndex.from_tuples(lst)
  575: 
  576:         df = DataFrame([[1, "A"]], columns=midx)
  577: 
  578:         grouped = df.groupby("to filter").groups
  579:         assert grouped["A"] == [0]
  580: 
  581:         grouped = df.groupby([("to filter", "")]).groups
  582:         assert grouped["A"] == [0]
  583: 
  584:         df = DataFrame([[1, "A"], [2, "B"]], columns=midx)
  585: 
  586:         expected = df.groupby("to filter").groups
  587:         result = df.groupby([("to filter", "")]).groups
  588:         assert result == expected
  589: 
  590:         df = DataFrame([[1, "A"], [2, "A"]], columns=midx)
  591: 
  592:         expected = df.groupby("to filter").groups
  593:         result = df.groupby([("to filter", "")]).groups
  594:         tm.assert_dict_equal(result, expected)
  595: 
  596:     def test_groupby_multiindex_tuple(self):
  597:         # GH 17979
  598:         df = DataFrame(
  599:             [[1, 2, 3, 4], [3, 4, 5, 6], [1, 4, 2, 3]],
  600:             columns=MultiIndex.from_arrays([["a", "b", "b", "c"], [1, 1, 2, 2]]),
  601:         )
  602:         expected = df.groupby([("b", 1)]).groups
  603:         result = df.groupby(("b", 1)).groups
  604:         tm.assert_dict_equal(expected, result)
  605: 
  606:         df2 = DataFrame(
  607:             df.values,
  608:             columns=MultiIndex.from_arrays(
  609:                 [["a", "b", "b", "c"], ["d", "d", "e", "e"]]
  610:             ),
  611:         )
  612:         expected = df2.groupby([("b", "d")]).groups
  613:         result = df.groupby(("b", 1)).groups
  614:         tm.assert_dict_equal(expected, result)
  615: 
  616:         df3 = DataFrame(df.values, columns=[("a", "d"), ("b", "d"), ("b", "e"), "c"])
  617:         expected = df3.groupby([("b", "d")]).groups
  618:         result = df.groupby(("b", 1)).groups
  619:         tm.assert_dict_equal(expected, result)
  620: 
  621:     def test_groupby_multiindex_partial_indexing_equivalence(self):
  622:         # GH 17977
  623:         df = DataFrame(
  624:             [[1, 2, 3, 4], [3, 4, 5, 6], [1, 4, 2, 3]],
  625:             columns=MultiIndex.from_arrays([["a", "b", "b", "c"], [1, 1, 2, 2]]),
  626:         )
  627: 
  628:         expected_mean = df.groupby([("a", 1)])[[("b", 1), ("b", 2)]].mean()
  629:         result_mean = df.groupby([("a", 1)])["b"].mean()
  630:         tm.assert_frame_equal(expected_mean, result_mean)
  631: 
  632:         expected_sum = df.groupby([("a", 1)])[[("b", 1), ("b", 2)]].sum()
  633:         result_sum = df.groupby([("a", 1)])["b"].sum()
  634:         tm.assert_frame_equal(expected_sum, result_sum)
  635: 
  636:         expected_count = df.groupby([("a", 1)])[[("b", 1), ("b", 2)]].count()
  637:         result_count = df.groupby([("a", 1)])["b"].count()
  638:         tm.assert_frame_equal(expected_count, result_count)
  639: 
  640:         expected_min = df.groupby([("a", 1)])[[("b", 1), ("b", 2)]].min()
  641:         result_min = df.groupby([("a", 1)])["b"].min()
  642:         tm.assert_frame_equal(expected_min, result_min)
  643: 
  644:         expected_max = df.groupby([("a", 1)])[[("b", 1), ("b", 2)]].max()
  645:         result_max = df.groupby([("a", 1)])["b"].max()
  646:         tm.assert_frame_equal(expected_max, result_max)
  647: 
  648:         expected_groups = df.groupby([("a", 1)])[[("b", 1), ("b", 2)]].groups
  649:         result_groups = df.groupby([("a", 1)])["b"].groups
  650:         tm.assert_dict_equal(expected_groups, result_groups)
  651: 
  652:     @pytest.mark.parametrize("sort", [True, False])
  653:     def test_groupby_level(self, sort, multiindex_dataframe_random_data, df):
  654:         # GH 17537
  655:         frame = multiindex_dataframe_random_data
  656:         deleveled = frame.reset_index()
  657: 
  658:         result0 = frame.groupby(level=0, sort=sort).sum()
  659:         result1 = frame.groupby(level=1, sort=sort).sum()
  660: 
  661:         expected0 = frame.groupby(deleveled["first"].values, sort=sort).sum()
  662:         expected1 = frame.groupby(deleveled["second"].values, sort=sort).sum()
  663: 
  664:         expected0.index.name = "first"
  665:         expected1.index.name = "second"
  666: 
  667:         assert result0.index.name == "first"
  668:         assert result1.index.name == "second"
  669: 
  670:         tm.assert_frame_equal(result0, expected0)
  671:         tm.assert_frame_equal(result1, expected1)
  672:         assert result0.index.name == frame.index.names[0]
  673:         assert result1.index.name == frame.index.names[1]
  674: 
  675:         # groupby level name
  676:         result0 = frame.groupby(level="first", sort=sort).sum()
  677:         result1 = frame.groupby(level="second", sort=sort).sum()
  678:         tm.assert_frame_equal(result0, expected0)
  679:         tm.assert_frame_equal(result1, expected1)
  680: 
  681:         # axis=1
  682:         msg = "DataFrame.groupby with axis=1 is deprecated"
  683:         with tm.assert_produces_warning(FutureWarning, match=msg):
  684:             result0 = frame.T.groupby(level=0, axis=1, sort=sort).sum()
  685:             result1 = frame.T.groupby(level=1, axis=1, sort=sort).sum()
  686:         tm.assert_frame_equal(result0, expected0.T)
  687:         tm.assert_frame_equal(result1, expected1.T)
  688: 
  689:         # raise exception for non-MultiIndex
  690:         msg = "level > 0 or level < -1 only valid with MultiIndex"
  691:         with pytest.raises(ValueError, match=msg):
  692:             df.groupby(level=1)
  693: 
  694:     def test_groupby_level_index_names(self, axis):
  695:         # GH4014 this used to raise ValueError since 'exp'>1 (in py2)
  696:         df = DataFrame({"exp": ["A"] * 3 + ["B"] * 3, "var1": range(6)}).set_index(
  697:             "exp"
  698:         )
  699:         if axis in (1, "columns"):
  700:             df = df.T
  701:             depr_msg = "DataFrame.groupby with axis=1 is deprecated"
  702:         else:
  703:             depr_msg = "The 'axis' keyword in DataFrame.groupby is deprecated"
  704:         with tm.assert_produces_warning(FutureWarning, match=depr_msg):
  705:             df.groupby(level="exp", axis=axis)
  706:         msg = f"level name foo is not the name of the {df._get_axis_name(axis)}"
  707:         with pytest.raises(ValueError, match=msg):
  708:             with tm.assert_produces_warning(FutureWarning, match=depr_msg):
  709:                 df.groupby(level="foo", axis=axis)
  710: 
  711:     @pytest.mark.parametrize("sort", [True, False])
  712:     def test_groupby_level_with_nas(self, sort):
  713:         # GH 17537
  714:         index = MultiIndex(
  715:             levels=[[1, 0], [0, 1, 2, 3]],
  716:             codes=[[1, 1, 1, 1, 0, 0, 0, 0], [0, 1, 2, 3, 0, 1, 2, 3]],
  717:         )
  718: 
  719:         # factorizing doesn't confuse things
  720:         s = Series(np.arange(8.0), index=index)
  721:         result = s.groupby(level=0, sort=sort).sum()
  722:         expected = Series([6.0, 22.0], index=[0, 1])
  723:         tm.assert_series_equal(result, expected)
  724: 
  725:         index = MultiIndex(
  726:             levels=[[1, 0], [0, 1, 2, 3]],
  727:             codes=[[1, 1, 1, 1, -1, 0, 0, 0], [0, 1, 2, 3, 0, 1, 2, 3]],
  728:         )
  729: 
  730:         # factorizing doesn't confuse things
  731:         s = Series(np.arange(8.0), index=index)
  732:         result = s.groupby(level=0, sort=sort).sum()
  733:         expected = Series([6.0, 18.0], index=[0.0, 1.0])
  734:         tm.assert_series_equal(result, expected)
  735: 
  736:     def test_groupby_args(self, multiindex_dataframe_random_data):
  737:         # PR8618 and issue 8015
  738:         frame = multiindex_dataframe_random_data
  739: 
  740:         msg = "You have to supply one of 'by' and 'level'"
  741:         with pytest.raises(TypeError, match=msg):
  742:             frame.groupby()
  743: 
  744:         msg = "You have to supply one of 'by' and 'level'"
  745:         with pytest.raises(TypeError, match=msg):
  746:             frame.groupby(by=None, level=None)
  747: 
  748:     @pytest.mark.parametrize(
  749:         "sort,labels",
  750:         [
  751:             [True, [2, 2, 2, 0, 0, 1, 1, 3, 3, 3]],
  752:             [False, [0, 0, 0, 1, 1, 2, 2, 3, 3, 3]],
  753:         ],
  754:     )
  755:     def test_level_preserve_order(self, sort, labels, multiindex_dataframe_random_data):
  756:         # GH 17537
  757:         grouped = multiindex_dataframe_random_data.groupby(level=0, sort=sort)
  758:         exp_labels = np.array(labels, np.intp)
  759:         tm.assert_almost_equal(grouped._grouper.codes[0], exp_labels)
  760: 
  761:     def test_grouping_labels(self, multiindex_dataframe_random_data):
  762:         grouped = multiindex_dataframe_random_data.groupby(
  763:             multiindex_dataframe_random_data.index.get_level_values(0)
  764:         )
  765:         exp_labels = np.array([2, 2, 2, 0, 0, 1, 1, 3, 3, 3], dtype=np.intp)
  766:         tm.assert_almost_equal(grouped._grouper.codes[0], exp_labels)
  767: 
  768:     def test_list_grouper_with_nat(self):
  769:         # GH 14715
  770:         df = DataFrame({"date": date_range("1/1/2011", periods=365, freq="D")})
  771:         df.iloc[-1] = pd.NaT
  772:         grouper = Grouper(key="date", freq="YS")
  773: 
  774:         # Grouper in a list grouping
  775:         result = df.groupby([grouper])
  776:         expected = {Timestamp("2011-01-01"): Index(list(range(364)))}
  777:         tm.assert_dict_equal(result.groups, expected)
  778: 
  779:         # Test case without a list
  780:         result = df.groupby(grouper)
  781:         expected = {Timestamp("2011-01-01"): 365}
  782:         tm.assert_dict_equal(result.groups, expected)
  783: 
  784:     @pytest.mark.parametrize(
  785:         "func,expected",
  786:         [
  787:             (
  788:                 "transform",
  789:                 Series(name=2, dtype=np.float64),
  790:             ),
  791:             (
  792:                 "agg",
  793:                 Series(
  794:                     name=2, dtype=np.float64, index=Index([], dtype=np.float64, name=1)
  795:                 ),
  796:             ),
  797:             (
  798:                 "apply",
  799:                 Series(
  800:                     name=2, dtype=np.float64, index=Index([], dtype=np.float64, name=1)
  801:                 ),
  802:             ),
  803:         ],
  804:     )
  805:     def test_evaluate_with_empty_groups(self, func, expected):
  806:         # 26208
  807:         # test transform'ing empty groups
  808:         # (not testing other agg fns, because they return
  809:         # different index objects.
  810:         df = DataFrame({1: [], 2: []})
  811:         g = df.groupby(1, group_keys=False)
  812:         result = getattr(g[2], func)(lambda x: x)
  813:         tm.assert_series_equal(result, expected)
  814: 
  815:     def test_groupby_empty(self):
  816:         # https://github.com/pandas-dev/pandas/issues/27190
  817:         s = Series([], name="name", dtype="float64")
  818:         gr = s.groupby([])
  819: 
  820:         result = gr.mean()
  821:         expected = s.set_axis(Index([], dtype=np.intp))
  822:         tm.assert_series_equal(result, expected)
  823: 
  824:         # check group properties
  825:         assert len(gr._grouper.groupings) == 1
  826:         tm.assert_numpy_array_equal(
  827:             gr._grouper.group_info[0], np.array([], dtype=np.dtype(np.intp))
  828:         )
  829: 
  830:         tm.assert_numpy_array_equal(
  831:             gr._grouper.group_info[1], np.array([], dtype=np.dtype(np.intp))
  832:         )
  833: 
  834:         assert gr._grouper.group_info[2] == 0
  835: 
  836:         # check name
  837:         gb = s.groupby(s)
  838:         msg = "SeriesGroupBy.grouper is deprecated"
  839:         with tm.assert_produces_warning(FutureWarning, match=msg):
  840:             grouper = gb.grouper
  841:         result = grouper.names
  842:         expected = ["name"]
  843:         assert result == expected
  844: 
  845:     def test_groupby_level_index_value_all_na(self):
  846:         # issue 20519
  847:         df = DataFrame(
  848:             [["x", np.nan, 10], [None, np.nan, 20]], columns=["A", "B", "C"]
  849:         ).set_index(["A", "B"])
  850:         result = df.groupby(level=["A", "B"]).sum()
  851:         expected = DataFrame(
  852:             data=[],
  853:             index=MultiIndex(
  854:                 levels=[Index(["x"], dtype="object"), Index([], dtype="float64")],
  855:                 codes=[[], []],
  856:                 names=["A", "B"],
  857:             ),
  858:             columns=["C"],
  859:             dtype="int64",
  860:         )
  861:         tm.assert_frame_equal(result, expected)
  862: 
  863:     def test_groupby_multiindex_level_empty(self):
  864:         # https://github.com/pandas-dev/pandas/issues/31670
  865:         df = DataFrame(
  866:             [[123, "a", 1.0], [123, "b", 2.0]], columns=["id", "category", "value"]
  867:         )
  868:         df = df.set_index(["id", "category"])
  869:         empty = df[df.value < 0]
  870:         result = empty.groupby("id").sum()
  871:         expected = DataFrame(
  872:             dtype="float64",
  873:             columns=["value"],
  874:             index=Index([], dtype=np.int64, name="id"),
  875:         )
  876:         tm.assert_frame_equal(result, expected)
  877: 
  878: 
  879: # get_group
  880: # --------------------------------
  881: 
  882: 
  883: class TestGetGroup:
  884:     def test_get_group(self):
  885:         # GH 5267
  886:         # be datelike friendly
  887:         df = DataFrame(
  888:             {
  889:                 "DATE": pd.to_datetime(
  890:                     [
  891:                         "10-Oct-2013",
  892:                         "10-Oct-2013",
  893:                         "10-Oct-2013",
  894:                         "11-Oct-2013",
  895:                         "11-Oct-2013",
  896:                         "11-Oct-2013",
  897:                     ]
  898:                 ),
  899:                 "label": ["foo", "foo", "bar", "foo", "foo", "bar"],
  900:                 "VAL": [1, 2, 3, 4, 5, 6],
  901:             }
  902:         )
  903: 
  904:         g = df.groupby("DATE")
  905:         key = next(iter(g.groups))
  906:         result1 = g.get_group(key)
  907:         result2 = g.get_group(Timestamp(key).to_pydatetime())
  908:         result3 = g.get_group(str(Timestamp(key)))
  909:         tm.assert_frame_equal(result1, result2)
  910:         tm.assert_frame_equal(result1, result3)
  911: 
  912:         g = df.groupby(["DATE", "label"])
  913: 
  914:         key = next(iter(g.groups))
  915:         result1 = g.get_group(key)
  916:         result2 = g.get_group((Timestamp(key[0]).to_pydatetime(), key[1]))
  917:         result3 = g.get_group((str(Timestamp(key[0])), key[1]))
  918:         tm.assert_frame_equal(result1, result2)
  919:         tm.assert_frame_equal(result1, result3)
  920: 
  921:         # must pass a same-length tuple with multiple keys
  922:         msg = "must supply a tuple to get_group with multiple grouping keys"
  923:         with pytest.raises(ValueError, match=msg):
  924:             g.get_group("foo")
  925:         with pytest.raises(ValueError, match=msg):
  926:             g.get_group("foo")
  927:         msg = "must supply a same-length tuple to get_group with multiple grouping keys"
  928:         with pytest.raises(ValueError, match=msg):
  929:             g.get_group(("foo", "bar", "baz"))
  930: 
  931:     def test_get_group_empty_bins(self, observed):
  932:         d = DataFrame([3, 1, 7, 6])
  933:         bins = [0, 5, 10, 15]
  934:         g = d.groupby(pd.cut(d[0], bins), observed=observed)
  935: 
  936:         # TODO: should prob allow a str of Interval work as well
  937:         # IOW '(0, 5]'
  938:         result = g.get_group(pd.Interval(0, 5))
  939:         expected = DataFrame([3, 1], index=[0, 1])
  940:         tm.assert_frame_equal(result, expected)
  941: 
  942:         msg = r"Interval\(10, 15, closed='right'\)"
  943:         with pytest.raises(KeyError, match=msg):
  944:             g.get_group(pd.Interval(10, 15))
  945: 
  946:     def test_get_group_grouped_by_tuple(self):
  947:         # GH 8121
  948:         df = DataFrame([[(1,), (1, 2), (1,), (1, 2)]], index=["ids"]).T
  949:         gr = df.groupby("ids")
  950:         expected = DataFrame({"ids": [(1,), (1,)]}, index=[0, 2])
  951:         result = gr.get_group((1,))
  952:         tm.assert_frame_equal(result, expected)
  953: 
  954:         dt = pd.to_datetime(["2010-01-01", "2010-01-02", "2010-01-01", "2010-01-02"])
  955:         df = DataFrame({"ids": [(x,) for x in dt]})
  956:         gr = df.groupby("ids")
  957:         result = gr.get_group(("2010-01-01",))
  958:         expected = DataFrame({"ids": [(dt[0],), (dt[0],)]}, index=[0, 2])
  959:         tm.assert_frame_equal(result, expected)
  960: 
  961:     def test_get_group_grouped_by_tuple_with_lambda(self):
  962:         # GH 36158
  963:         df = DataFrame(
  964:             {
  965:                 "Tuples": (
  966:                     (x, y)
  967:                     for x in [0, 1]
  968:                     for y in np.random.default_rng(2).integers(3, 5, 5)
  969:                 )
  970:             }
  971:         )
  972: 
  973:         gb = df.groupby("Tuples")
  974:         gb_lambda = df.groupby(lambda x: df.iloc[x, 0])
  975: 
  976:         expected = gb.get_group(next(iter(gb.groups.keys())))
  977:         result = gb_lambda.get_group(next(iter(gb_lambda.groups.keys())))
  978: 
  979:         tm.assert_frame_equal(result, expected)
  980: 
  981:     def test_groupby_with_empty(self):
  982:         index = pd.DatetimeIndex(())
  983:         data = ()
  984:         series = Series(data, index, dtype=object)
  985:         grouper = Grouper(freq="D")
  986:         grouped = series.groupby(grouper)
  987:         assert next(iter(grouped), None) is None
  988: 
  989:     def test_groupby_with_single_column(self):
  990:         df = DataFrame({"a": list("abssbab")})
  991:         tm.assert_frame_equal(df.groupby("a").get_group("a"), df.iloc[[0, 5]])
  992:         # GH 13530
  993:         exp = DataFrame(index=Index(["a", "b", "s"], name="a"), columns=[])
  994:         tm.assert_frame_equal(df.groupby("a").count(), exp)
  995:         tm.assert_frame_equal(df.groupby("a").sum(), exp)
  996: 
  997:         exp = df.iloc[[3, 4, 5]]
  998:         tm.assert_frame_equal(df.groupby("a").nth(1), exp)
  999: 
 1000:     def test_gb_key_len_equal_axis_len(self):
 1001:         # GH16843
 1002:         # test ensures that index and column keys are recognized correctly
 1003:         # when number of keys equals axis length of groupby
 1004:         df = DataFrame(
 1005:             [["foo", "bar", "B", 1], ["foo", "bar", "B", 2], ["foo", "baz", "C", 3]],
 1006:             columns=["first", "second", "third", "one"],
 1007:         )
 1008:         df = df.set_index(["first", "second"])
 1009:         df = df.groupby(["first", "second", "third"]).size()
 1010:         assert df.loc[("foo", "bar", "B")] == 2
 1011:         assert df.loc[("foo", "baz", "C")] == 1
 1012: 
 1013: 
 1014: # groups & iteration
 1015: # --------------------------------
 1016: 
 1017: 
 1018: class TestIteration:
 1019:     def test_groups(self, df):
 1020:         grouped = df.groupby(["A"])
 1021:         groups = grouped.groups
 1022:         assert groups is grouped.groups  # caching works
 1023: 
 1024:         for k, v in grouped.groups.items():
 1025:             assert (df.loc[v]["A"] == k).all()
 1026: 
 1027:         grouped = df.groupby(["A", "B"])
 1028:         groups = grouped.groups
 1029:         assert groups is grouped.groups  # caching works
 1030: 
 1031:         for k, v in grouped.groups.items():
 1032:             assert (df.loc[v]["A"] == k[0]).all()
 1033:             assert (df.loc[v]["B"] == k[1]).all()
 1034: 
 1035:     def test_grouping_is_iterable(self, tsframe):
 1036:         # this code path isn't used anywhere else
 1037:         # not sure it's useful
 1038:         grouped = tsframe.groupby([lambda x: x.weekday(), lambda x: x.year])
 1039: 
 1040:         # test it works
 1041:         for g in grouped._grouper.groupings[0]:
 1042:             pass
 1043: 
 1044:     def test_multi_iter(self):
 1045:         s = Series(np.arange(6))
 1046:         k1 = np.array(["a", "a", "a", "b", "b", "b"])
 1047:         k2 = np.array(["1", "2", "1", "2", "1", "2"])
 1048: 
 1049:         grouped = s.groupby([k1, k2])
 1050: 
 1051:         iterated = list(grouped)
 1052:         expected = [
 1053:             ("a", "1", s[[0, 2]]),
 1054:             ("a", "2", s[[1]]),
 1055:             ("b", "1", s[[4]]),
 1056:             ("b", "2", s[[3, 5]]),
 1057:         ]
 1058:         for i, ((one, two), three) in enumerate(iterated):
 1059:             e1, e2, e3 = expected[i]
 1060:             assert e1 == one
 1061:             assert e2 == two
 1062:             tm.assert_series_equal(three, e3)
 1063: 
 1064:     def test_multi_iter_frame(self, three_group):
 1065:         k1 = np.array(["b", "b", "b", "a", "a", "a"])
 1066:         k2 = np.array(["1", "2", "1", "2", "1", "2"])
 1067:         df = DataFrame(
 1068:             {
 1069:                 "v1": np.random.default_rng(2).standard_normal(6),
 1070:                 "v2": np.random.default_rng(2).standard_normal(6),
 1071:                 "k1": k1,
 1072:                 "k2": k2,
 1073:             },
 1074:             index=["one", "two", "three", "four", "five", "six"],
 1075:         )
 1076: 
 1077:         grouped = df.groupby(["k1", "k2"])
 1078: 
 1079:         # things get sorted!
 1080:         iterated = list(grouped)
 1081:         idx = df.index
 1082:         expected = [
 1083:             ("a", "1", df.loc[idx[[4]]]),
 1084:             ("a", "2", df.loc[idx[[3, 5]]]),
 1085:             ("b", "1", df.loc[idx[[0, 2]]]),
 1086:             ("b", "2", df.loc[idx[[1]]]),
 1087:         ]
 1088:         for i, ((one, two), three) in enumerate(iterated):
 1089:             e1, e2, e3 = expected[i]
 1090:             assert e1 == one
 1091:             assert e2 == two
 1092:             tm.assert_frame_equal(three, e3)
 1093: 
 1094:         # don't iterate through groups with no data
 1095:         df["k1"] = np.array(["b", "b", "b", "a", "a", "a"])
 1096:         df["k2"] = np.array(["1", "1", "1", "2", "2", "2"])
 1097:         grouped = df.groupby(["k1", "k2"])
 1098:         # calling `dict` on a DataFrameGroupBy leads to a TypeError,
 1099:         # we need to use a dictionary comprehension here
 1100:         # pylint: disable-next=unnecessary-comprehension
 1101:         groups = {key: gp for key, gp in grouped}  # noqa: C416
 1102:         assert len(groups) == 2
 1103: 
 1104:         # axis = 1
 1105:         three_levels = three_group.groupby(["A", "B", "C"]).mean()
 1106:         depr_msg = "DataFrame.groupby with axis=1 is deprecated"
 1107:         with tm.assert_produces_warning(FutureWarning, match=depr_msg):
 1108:             grouped = three_levels.T.groupby(axis=1, level=(1, 2))
 1109:         for key, group in grouped:
 1110:             pass
 1111: 
 1112:     def test_dictify(self, df):
 1113:         dict(iter(df.groupby("A")))
 1114:         dict(iter(df.groupby(["A", "B"])))
 1115:         dict(iter(df["C"].groupby(df["A"])))
 1116:         dict(iter(df["C"].groupby([df["A"], df["B"]])))
 1117:         dict(iter(df.groupby("A")["C"]))
 1118:         dict(iter(df.groupby(["A", "B"])["C"]))
 1119: 
 1120:     def test_groupby_with_small_elem(self):
 1121:         # GH 8542
 1122:         # length=2
 1123:         df = DataFrame(
 1124:             {"event": ["start", "start"], "change": [1234, 5678]},
 1125:             index=pd.DatetimeIndex(["2014-09-10", "2013-10-10"]),
 1126:         )
 1127:         grouped = df.groupby([Grouper(freq="ME"), "event"])
 1128:         assert len(grouped.groups) == 2
 1129:         assert grouped.ngroups == 2
 1130:         assert (Timestamp("2014-09-30"), "start") in grouped.groups
 1131:         assert (Timestamp("2013-10-31"), "start") in grouped.groups
 1132: 
 1133:         res = grouped.get_group((Timestamp("2014-09-30"), "start"))
 1134:         tm.assert_frame_equal(res, df.iloc[[0], :])
 1135:         res = grouped.get_group((Timestamp("2013-10-31"), "start"))
 1136:         tm.assert_frame_equal(res, df.iloc[[1], :])
 1137: 
 1138:         df = DataFrame(
 1139:             {"event": ["start", "start", "start"], "change": [1234, 5678, 9123]},
 1140:             index=pd.DatetimeIndex(["2014-09-10", "2013-10-10", "2014-09-15"]),
 1141:         )
 1142:         grouped = df.groupby([Grouper(freq="ME"), "event"])
 1143:         assert len(grouped.groups) == 2
 1144:         assert grouped.ngroups == 2
 1145:         assert (Timestamp("2014-09-30"), "start") in grouped.groups
 1146:         assert (Timestamp("2013-10-31"), "start") in grouped.groups
 1147: 
 1148:         res = grouped.get_group((Timestamp("2014-09-30"), "start"))
 1149:         tm.assert_frame_equal(res, df.iloc[[0, 2], :])
 1150:         res = grouped.get_group((Timestamp("2013-10-31"), "start"))
 1151:         tm.assert_frame_equal(res, df.iloc[[1], :])
 1152: 
 1153:         # length=3
 1154:         df = DataFrame(
 1155:             {"event": ["start", "start", "start"], "change": [1234, 5678, 9123]},
 1156:             index=pd.DatetimeIndex(["2014-09-10", "2013-10-10", "2014-08-05"]),
 1157:         )
 1158:         grouped = df.groupby([Grouper(freq="ME"), "event"])
 1159:         assert len(grouped.groups) == 3
 1160:         assert grouped.ngroups == 3
 1161:         assert (Timestamp("2014-09-30"), "start") in grouped.groups
 1162:         assert (Timestamp("2013-10-31"), "start") in grouped.groups
 1163:         assert (Timestamp("2014-08-31"), "start") in grouped.groups
 1164: 
 1165:         res = grouped.get_group((Timestamp("2014-09-30"), "start"))
 1166:         tm.assert_frame_equal(res, df.iloc[[0], :])
 1167:         res = grouped.get_group((Timestamp("2013-10-31"), "start"))
 1168:         tm.assert_frame_equal(res, df.iloc[[1], :])
 1169:         res = grouped.get_group((Timestamp("2014-08-31"), "start"))
 1170:         tm.assert_frame_equal(res, df.iloc[[2], :])
 1171: 
 1172:     def test_grouping_string_repr(self):
 1173:         # GH 13394
 1174:         mi = MultiIndex.from_arrays([list("AAB"), list("aba")])
 1175:         df = DataFrame([[1, 2, 3]], columns=mi)
 1176:         gr = df.groupby(df[("A", "a")])
 1177: 
 1178:         result = gr._grouper.groupings[0].__repr__()
 1179:         expected = "Grouping(('A', 'a'))"
 1180:         assert result == expected
 1181: 
 1182: 
 1183: def test_grouping_by_key_is_in_axis():
 1184:     # GH#50413 - Groupers specified by key are in-axis
 1185:     df = DataFrame({"a": [1, 1, 2], "b": [1, 1, 2], "c": [3, 4, 5]}).set_index("a")
 1186:     gb = df.groupby([Grouper(level="a"), Grouper(key="b")], as_index=False)
 1187:     assert not gb._grouper.groupings[0].in_axis
 1188:     assert gb._grouper.groupings[1].in_axis
 1189: 
 1190:     # Currently only in-axis groupings are including in the result when as_index=False;
 1191:     # This is likely to change in the future.
 1192:     msg = "A grouping .* was excluded from the result"
 1193:     with tm.assert_produces_warning(FutureWarning, match=msg):
 1194:         result = gb.sum()
 1195:     expected = DataFrame({"b": [1, 2], "c": [7, 5]})
 1196:     tm.assert_frame_equal(result, expected)
 1197: 
 1198: 
 1199: def test_grouper_groups():
 1200:     # GH#51182 check Grouper.groups does not raise AttributeError
 1201:     df = DataFrame({"a": [1, 2, 3], "b": 1})
 1202:     grper = Grouper(key="a")
 1203:     gb = df.groupby(grper)
 1204: 
 1205:     msg = "Use GroupBy.groups instead"
 1206:     with tm.assert_produces_warning(FutureWarning, match=msg):
 1207:         res = grper.groups
 1208:     assert res is gb.groups
 1209: 
 1210:     msg = "Use GroupBy.grouper instead"
 1211:     with tm.assert_produces_warning(FutureWarning, match=msg):
 1212:         res = grper.grouper
 1213:     assert res is gb._grouper
 1214: 
 1215:     msg = "Grouper.obj is deprecated and will be removed"
 1216:     with tm.assert_produces_warning(FutureWarning, match=msg):
 1217:         res = grper.obj
 1218:     assert res is gb.obj
 1219: 
 1220:     msg = "Use Resampler.ax instead"
 1221:     with tm.assert_produces_warning(FutureWarning, match=msg):
 1222:         grper.ax
 1223: 
 1224:     msg = "Grouper.indexer is deprecated"
 1225:     with tm.assert_produces_warning(FutureWarning, match=msg):
 1226:         grper.indexer
 1227: 
 1228: 
 1229: @pytest.mark.parametrize("attr", ["group_index", "result_index", "group_arraylike"])
 1230: def test_depr_grouping_attrs(attr):
 1231:     # GH#56148
 1232:     df = DataFrame({"a": [1, 1, 2], "b": [3, 4, 5]})
 1233:     gb = df.groupby("a")
 1234:     msg = f"{attr} is deprecated"
 1235:     with tm.assert_produces_warning(FutureWarning, match=msg):
 1236:         getattr(gb._grouper.groupings[0], attr)
