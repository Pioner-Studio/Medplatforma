    1: # Test GroupBy._positional_selector positional grouped indexing GH#42864
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: import pandas as pd
    7: import pandas._testing as tm
    8: 
    9: 
   10: @pytest.mark.parametrize(
   11:     "arg, expected_rows",
   12:     [
   13:         [0, [0, 1, 4]],
   14:         [2, [5]],
   15:         [5, []],
   16:         [-1, [3, 4, 7]],
   17:         [-2, [1, 6]],
   18:         [-6, []],
   19:     ],
   20: )
   21: def test_int(slice_test_df, slice_test_grouped, arg, expected_rows):
   22:     # Test single integer
   23:     result = slice_test_grouped._positional_selector[arg]
   24:     expected = slice_test_df.iloc[expected_rows]
   25: 
   26:     tm.assert_frame_equal(result, expected)
   27: 
   28: 
   29: def test_slice(slice_test_df, slice_test_grouped):
   30:     # Test single slice
   31:     result = slice_test_grouped._positional_selector[0:3:2]
   32:     expected = slice_test_df.iloc[[0, 1, 4, 5]]
   33: 
   34:     tm.assert_frame_equal(result, expected)
   35: 
   36: 
   37: @pytest.mark.parametrize(
   38:     "arg, expected_rows",
   39:     [
   40:         [[0, 2], [0, 1, 4, 5]],
   41:         [[0, 2, -1], [0, 1, 3, 4, 5, 7]],
   42:         [range(0, 3, 2), [0, 1, 4, 5]],
   43:         [{0, 2}, [0, 1, 4, 5]],
   44:     ],
   45:     ids=[
   46:         "list",
   47:         "negative",
   48:         "range",
   49:         "set",
   50:     ],
   51: )
   52: def test_list(slice_test_df, slice_test_grouped, arg, expected_rows):
   53:     # Test lists of integers and integer valued iterables
   54:     result = slice_test_grouped._positional_selector[arg]
   55:     expected = slice_test_df.iloc[expected_rows]
   56: 
   57:     tm.assert_frame_equal(result, expected)
   58: 
   59: 
   60: def test_ints(slice_test_df, slice_test_grouped):
   61:     # Test tuple of ints
   62:     result = slice_test_grouped._positional_selector[0, 2, -1]
   63:     expected = slice_test_df.iloc[[0, 1, 3, 4, 5, 7]]
   64: 
   65:     tm.assert_frame_equal(result, expected)
   66: 
   67: 
   68: def test_slices(slice_test_df, slice_test_grouped):
   69:     # Test tuple of slices
   70:     result = slice_test_grouped._positional_selector[:2, -2:]
   71:     expected = slice_test_df.iloc[[0, 1, 2, 3, 4, 6, 7]]
   72: 
   73:     tm.assert_frame_equal(result, expected)
   74: 
   75: 
   76: def test_mix(slice_test_df, slice_test_grouped):
   77:     # Test mixed tuple of ints and slices
   78:     result = slice_test_grouped._positional_selector[0, 1, -2:]
   79:     expected = slice_test_df.iloc[[0, 1, 2, 3, 4, 6, 7]]
   80: 
   81:     tm.assert_frame_equal(result, expected)
   82: 
   83: 
   84: @pytest.mark.parametrize(
   85:     "arg, expected_rows",
   86:     [
   87:         [0, [0, 1, 4]],
   88:         [[0, 2, -1], [0, 1, 3, 4, 5, 7]],
   89:         [(slice(None, 2), slice(-2, None)), [0, 1, 2, 3, 4, 6, 7]],
   90:     ],
   91: )
   92: def test_as_index(slice_test_df, arg, expected_rows):
   93:     # Test the default as_index behaviour
   94:     result = slice_test_df.groupby("Group", sort=False)._positional_selector[arg]
   95:     expected = slice_test_df.iloc[expected_rows]
   96: 
   97:     tm.assert_frame_equal(result, expected)
   98: 
   99: 
  100: def test_doc_examples():
  101:     # Test the examples in the documentation
  102:     df = pd.DataFrame(
  103:         [["a", 1], ["a", 2], ["a", 3], ["b", 4], ["b", 5]], columns=["A", "B"]
  104:     )
  105: 
  106:     grouped = df.groupby("A", as_index=False)
  107: 
  108:     result = grouped._positional_selector[1:2]
  109:     expected = pd.DataFrame([["a", 2], ["b", 5]], columns=["A", "B"], index=[1, 4])
  110: 
  111:     tm.assert_frame_equal(result, expected)
  112: 
  113:     result = grouped._positional_selector[1, -1]
  114:     expected = pd.DataFrame(
  115:         [["a", 2], ["a", 3], ["b", 5]], columns=["A", "B"], index=[1, 2, 4]
  116:     )
  117: 
  118:     tm.assert_frame_equal(result, expected)
  119: 
  120: 
  121: @pytest.fixture()
  122: def multiindex_data():
  123:     rng = np.random.default_rng(2)
  124:     ndates = 100
  125:     nitems = 20
  126:     dates = pd.date_range("20130101", periods=ndates, freq="D")
  127:     items = [f"item {i}" for i in range(nitems)]
  128: 
  129:     data = {}
  130:     for date in dates:
  131:         nitems_for_date = nitems - rng.integers(0, 12)
  132:         levels = [
  133:             (item, rng.integers(0, 10000) / 100, rng.integers(0, 10000) / 100)
  134:             for item in items[:nitems_for_date]
  135:         ]
  136:         levels.sort(key=lambda x: x[1])
  137:         data[date] = levels
  138: 
  139:     return data
  140: 
  141: 
  142: def _make_df_from_data(data):
  143:     rows = {}
  144:     for date in data:
  145:         for level in data[date]:
  146:             rows[(date, level[0])] = {"A": level[1], "B": level[2]}
  147: 
  148:     df = pd.DataFrame.from_dict(rows, orient="index")
  149:     df.index.names = ("Date", "Item")
  150:     return df
  151: 
  152: 
  153: def test_multiindex(multiindex_data):
  154:     # Test the multiindex mentioned as the use-case in the documentation
  155:     df = _make_df_from_data(multiindex_data)
  156:     result = df.groupby("Date", as_index=False).nth(slice(3, -3))
  157: 
  158:     sliced = {date: multiindex_data[date][3:-3] for date in multiindex_data}
  159:     expected = _make_df_from_data(sliced)
  160: 
  161:     tm.assert_frame_equal(result, expected)
  162: 
  163: 
  164: @pytest.mark.parametrize("arg", [1, 5, 30, 1000, -1, -5, -30, -1000])
  165: @pytest.mark.parametrize("method", ["head", "tail"])
  166: @pytest.mark.parametrize("simulated", [True, False])
  167: def test_against_head_and_tail(arg, method, simulated):
  168:     # Test gives the same results as grouped head and tail
  169:     n_groups = 100
  170:     n_rows_per_group = 30
  171: 
  172:     data = {
  173:         "group": [
  174:             f"group {g}" for j in range(n_rows_per_group) for g in range(n_groups)
  175:         ],
  176:         "value": [
  177:             f"group {g} row {j}"
  178:             for j in range(n_rows_per_group)
  179:             for g in range(n_groups)
  180:         ],
  181:     }
  182:     df = pd.DataFrame(data)
  183:     grouped = df.groupby("group", as_index=False)
  184:     size = arg if arg >= 0 else n_rows_per_group + arg
  185: 
  186:     if method == "head":
  187:         result = grouped._positional_selector[:arg]
  188: 
  189:         if simulated:
  190:             indices = [
  191:                 j * n_groups + i
  192:                 for j in range(size)
  193:                 for i in range(n_groups)
  194:                 if j * n_groups + i < n_groups * n_rows_per_group
  195:             ]
  196:             expected = df.iloc[indices]
  197: 
  198:         else:
  199:             expected = grouped.head(arg)
  200: 
  201:     else:
  202:         result = grouped._positional_selector[-arg:]
  203: 
  204:         if simulated:
  205:             indices = [
  206:                 (n_rows_per_group + j - size) * n_groups + i
  207:                 for j in range(size)
  208:                 for i in range(n_groups)
  209:                 if (n_rows_per_group + j - size) * n_groups + i >= 0
  210:             ]
  211:             expected = df.iloc[indices]
  212: 
  213:         else:
  214:             expected = grouped.tail(arg)
  215: 
  216:     tm.assert_frame_equal(result, expected)
  217: 
  218: 
  219: @pytest.mark.parametrize("start", [None, 0, 1, 10, -1, -10])
  220: @pytest.mark.parametrize("stop", [None, 0, 1, 10, -1, -10])
  221: @pytest.mark.parametrize("step", [None, 1, 5])
  222: def test_against_df_iloc(start, stop, step):
  223:     # Test that a single group gives the same results as DataFrame.iloc
  224:     n_rows = 30
  225: 
  226:     data = {
  227:         "group": ["group 0"] * n_rows,
  228:         "value": list(range(n_rows)),
  229:     }
  230:     df = pd.DataFrame(data)
  231:     grouped = df.groupby("group", as_index=False)
  232: 
  233:     result = grouped._positional_selector[start:stop:step]
  234:     expected = df.iloc[start:stop:step]
  235: 
  236:     tm.assert_frame_equal(result, expected)
  237: 
  238: 
  239: def test_series():
  240:     # Test grouped Series
  241:     ser = pd.Series([1, 2, 3, 4, 5], index=["a", "a", "a", "b", "b"])
  242:     grouped = ser.groupby(level=0)
  243:     result = grouped._positional_selector[1:2]
  244:     expected = pd.Series([2, 5], index=["a", "b"])
  245: 
  246:     tm.assert_series_equal(result, expected)
  247: 
  248: 
  249: @pytest.mark.parametrize("step", [1, 2, 3, 4, 5])
  250: def test_step(step):
  251:     # Test slice with various step values
  252:     data = [["x", f"x{i}"] for i in range(5)]
  253:     data += [["y", f"y{i}"] for i in range(4)]
  254:     data += [["z", f"z{i}"] for i in range(3)]
  255:     df = pd.DataFrame(data, columns=["A", "B"])
  256: 
  257:     grouped = df.groupby("A", as_index=False)
  258: 
  259:     result = grouped._positional_selector[::step]
  260: 
  261:     data = [["x", f"x{i}"] for i in range(0, 5, step)]
  262:     data += [["y", f"y{i}"] for i in range(0, 4, step)]
  263:     data += [["z", f"z{i}"] for i in range(0, 3, step)]
  264: 
  265:     index = [0 + i for i in range(0, 5, step)]
  266:     index += [5 + i for i in range(0, 4, step)]
  267:     index += [9 + i for i in range(0, 3, step)]
  268: 
  269:     expected = pd.DataFrame(data, columns=["A", "B"], index=index)
  270: 
  271:     tm.assert_frame_equal(result, expected)
  272: 
  273: 
  274: @pytest.fixture()
  275: def column_group_df():
  276:     return pd.DataFrame(
  277:         [[0, 1, 2, 3, 4, 5, 6], [0, 0, 1, 0, 1, 0, 2]],
  278:         columns=["A", "B", "C", "D", "E", "F", "G"],
  279:     )
  280: 
  281: 
  282: def test_column_axis(column_group_df):
  283:     msg = "DataFrame.groupby with axis=1"
  284:     with tm.assert_produces_warning(FutureWarning, match=msg):
  285:         g = column_group_df.groupby(column_group_df.iloc[1], axis=1)
  286:     result = g._positional_selector[1:-1]
  287:     expected = column_group_df.iloc[:, [1, 3]]
  288: 
  289:     tm.assert_frame_equal(result, expected)
  290: 
  291: 
  292: def test_columns_on_iter():
  293:     # GitHub issue #44821
  294:     df = pd.DataFrame({k: range(10) for k in "ABC"})
  295: 
  296:     # Group-by and select columns
  297:     cols = ["A", "B"]
  298:     for _, dg in df.groupby(df.A < 4)[cols]:
  299:         tm.assert_index_equal(dg.columns, pd.Index(cols))
  300:         assert "C" not in dg.columns
  301: 
  302: 
  303: @pytest.mark.parametrize("func", [list, pd.Index, pd.Series, np.array])
  304: def test_groupby_duplicated_columns(func):
  305:     # GH#44924
  306:     df = pd.DataFrame(
  307:         {
  308:             "A": [1, 2],
  309:             "B": [3, 3],
  310:             "C": ["G", "G"],
  311:         }
  312:     )
  313:     result = df.groupby("C")[func(["A", "B", "A"])].mean()
  314:     expected = pd.DataFrame(
  315:         [[1.5, 3.0, 1.5]], columns=["A", "B", "A"], index=pd.Index(["G"], name="C")
  316:     )
  317:     tm.assert_frame_equal(result, expected)
  318: 
  319: 
  320: def test_groupby_get_nonexisting_groups():
  321:     # GH#32492
  322:     df = pd.DataFrame(
  323:         data={
  324:             "A": ["a1", "a2", None],
  325:             "B": ["b1", "b2", "b1"],
  326:             "val": [1, 2, 3],
  327:         }
  328:     )
  329:     grps = df.groupby(by=["A", "B"])
  330: 
  331:     msg = "('a2', 'b1')"
  332:     with pytest.raises(KeyError, match=msg):
  333:         grps.get_group(("a2", "b1"))
