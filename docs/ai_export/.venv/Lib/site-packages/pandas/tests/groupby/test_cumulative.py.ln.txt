    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas.errors import UnsupportedFunctionCall
    5: import pandas.util._test_decorators as td
    6: 
    7: import pandas as pd
    8: from pandas import (
    9:     DataFrame,
   10:     Series,
   11: )
   12: import pandas._testing as tm
   13: 
   14: 
   15: @pytest.fixture(
   16:     params=[np.int32, np.int64, np.float32, np.float64, "Int64", "Float64"],
   17:     ids=["np.int32", "np.int64", "np.float32", "np.float64", "Int64", "Float64"],
   18: )
   19: def dtypes_for_minmax(request):
   20:     """
   21:     Fixture of dtypes with min and max values used for testing
   22:     cummin and cummax
   23:     """
   24:     dtype = request.param
   25: 
   26:     np_type = dtype
   27:     if dtype == "Int64":
   28:         np_type = np.int64
   29:     elif dtype == "Float64":
   30:         np_type = np.float64
   31: 
   32:     min_val = (
   33:         np.iinfo(np_type).min
   34:         if np.dtype(np_type).kind == "i"
   35:         else np.finfo(np_type).min
   36:     )
   37:     max_val = (
   38:         np.iinfo(np_type).max
   39:         if np.dtype(np_type).kind == "i"
   40:         else np.finfo(np_type).max
   41:     )
   42: 
   43:     return (dtype, min_val, max_val)
   44: 
   45: 
   46: def test_groupby_cumprod():
   47:     # GH 4095
   48:     df = DataFrame({"key": ["b"] * 10, "value": 2})
   49: 
   50:     actual = df.groupby("key")["value"].cumprod()
   51:     expected = df.groupby("key", group_keys=False)["value"].apply(lambda x: x.cumprod())
   52:     expected.name = "value"
   53:     tm.assert_series_equal(actual, expected)
   54: 
   55:     df = DataFrame({"key": ["b"] * 100, "value": 2})
   56:     df["value"] = df["value"].astype(float)
   57:     actual = df.groupby("key")["value"].cumprod()
   58:     expected = df.groupby("key", group_keys=False)["value"].apply(lambda x: x.cumprod())
   59:     expected.name = "value"
   60:     tm.assert_series_equal(actual, expected)
   61: 
   62: 
   63: @pytest.mark.skip_ubsan
   64: def test_groupby_cumprod_overflow():
   65:     # GH#37493 if we overflow we return garbage consistent with numpy
   66:     df = DataFrame({"key": ["b"] * 4, "value": 100_000})
   67:     actual = df.groupby("key")["value"].cumprod()
   68:     expected = Series(
   69:         [100_000, 10_000_000_000, 1_000_000_000_000_000, 7766279631452241920],
   70:         name="value",
   71:     )
   72:     tm.assert_series_equal(actual, expected)
   73: 
   74:     numpy_result = df.groupby("key", group_keys=False)["value"].apply(
   75:         lambda x: x.cumprod()
   76:     )
   77:     numpy_result.name = "value"
   78:     tm.assert_series_equal(actual, numpy_result)
   79: 
   80: 
   81: def test_groupby_cumprod_nan_influences_other_columns():
   82:     # GH#48064
   83:     df = DataFrame(
   84:         {
   85:             "a": 1,
   86:             "b": [1, np.nan, 2],
   87:             "c": [1, 2, 3.0],
   88:         }
   89:     )
   90:     result = df.groupby("a").cumprod(numeric_only=True, skipna=False)
   91:     expected = DataFrame({"b": [1, np.nan, np.nan], "c": [1, 2, 6.0]})
   92:     tm.assert_frame_equal(result, expected)
   93: 
   94: 
   95: def test_cummin(dtypes_for_minmax):
   96:     dtype = dtypes_for_minmax[0]
   97:     min_val = dtypes_for_minmax[1]
   98: 
   99:     # GH 15048
  100:     base_df = DataFrame({"A": [1, 1, 1, 1, 2, 2, 2, 2], "B": [3, 4, 3, 2, 2, 3, 2, 1]})
  101:     expected_mins = [3, 3, 3, 2, 2, 2, 2, 1]
  102: 
  103:     df = base_df.astype(dtype)
  104: 
  105:     expected = DataFrame({"B": expected_mins}).astype(dtype)
  106:     result = df.groupby("A").cummin()
  107:     tm.assert_frame_equal(result, expected)
  108:     result = df.groupby("A", group_keys=False).B.apply(lambda x: x.cummin()).to_frame()
  109:     tm.assert_frame_equal(result, expected)
  110: 
  111:     # Test w/ min value for dtype
  112:     df.loc[[2, 6], "B"] = min_val
  113:     df.loc[[1, 5], "B"] = min_val + 1
  114:     expected.loc[[2, 3, 6, 7], "B"] = min_val
  115:     expected.loc[[1, 5], "B"] = min_val + 1  # should not be rounded to min_val
  116:     result = df.groupby("A").cummin()
  117:     tm.assert_frame_equal(result, expected, check_exact=True)
  118:     expected = (
  119:         df.groupby("A", group_keys=False).B.apply(lambda x: x.cummin()).to_frame()
  120:     )
  121:     tm.assert_frame_equal(result, expected, check_exact=True)
  122: 
  123:     # Test nan in some values
  124:     # Explicit cast to float to avoid implicit cast when setting nan
  125:     base_df = base_df.astype({"B": "float"})
  126:     base_df.loc[[0, 2, 4, 6], "B"] = np.nan
  127:     expected = DataFrame({"B": [np.nan, 4, np.nan, 2, np.nan, 3, np.nan, 1]})
  128:     result = base_df.groupby("A").cummin()
  129:     tm.assert_frame_equal(result, expected)
  130:     expected = (
  131:         base_df.groupby("A", group_keys=False).B.apply(lambda x: x.cummin()).to_frame()
  132:     )
  133:     tm.assert_frame_equal(result, expected)
  134: 
  135:     # GH 15561
  136:     df = DataFrame({"a": [1], "b": pd.to_datetime(["2001"])})
  137:     expected = Series(pd.to_datetime("2001"), index=[0], name="b")
  138: 
  139:     result = df.groupby("a")["b"].cummin()
  140:     tm.assert_series_equal(expected, result)
  141: 
  142:     # GH 15635
  143:     df = DataFrame({"a": [1, 2, 1], "b": [1, 2, 2]})
  144:     result = df.groupby("a").b.cummin()
  145:     expected = Series([1, 2, 1], name="b")
  146:     tm.assert_series_equal(result, expected)
  147: 
  148: 
  149: @pytest.mark.parametrize("method", ["cummin", "cummax"])
  150: @pytest.mark.parametrize("dtype", ["UInt64", "Int64", "Float64", "float", "boolean"])
  151: def test_cummin_max_all_nan_column(method, dtype):
  152:     base_df = DataFrame({"A": [1, 1, 1, 1, 2, 2, 2, 2], "B": [np.nan] * 8})
  153:     base_df["B"] = base_df["B"].astype(dtype)
  154:     grouped = base_df.groupby("A")
  155: 
  156:     expected = DataFrame({"B": [np.nan] * 8}, dtype=dtype)
  157:     result = getattr(grouped, method)()
  158:     tm.assert_frame_equal(expected, result)
  159: 
  160:     result = getattr(grouped["B"], method)().to_frame()
  161:     tm.assert_frame_equal(expected, result)
  162: 
  163: 
  164: def test_cummax(dtypes_for_minmax):
  165:     dtype = dtypes_for_minmax[0]
  166:     max_val = dtypes_for_minmax[2]
  167: 
  168:     # GH 15048
  169:     base_df = DataFrame({"A": [1, 1, 1, 1, 2, 2, 2, 2], "B": [3, 4, 3, 2, 2, 3, 2, 1]})
  170:     expected_maxs = [3, 4, 4, 4, 2, 3, 3, 3]
  171: 
  172:     df = base_df.astype(dtype)
  173: 
  174:     expected = DataFrame({"B": expected_maxs}).astype(dtype)
  175:     result = df.groupby("A").cummax()
  176:     tm.assert_frame_equal(result, expected)
  177:     result = df.groupby("A", group_keys=False).B.apply(lambda x: x.cummax()).to_frame()
  178:     tm.assert_frame_equal(result, expected)
  179: 
  180:     # Test w/ max value for dtype
  181:     df.loc[[2, 6], "B"] = max_val
  182:     expected.loc[[2, 3, 6, 7], "B"] = max_val
  183:     result = df.groupby("A").cummax()
  184:     tm.assert_frame_equal(result, expected)
  185:     expected = (
  186:         df.groupby("A", group_keys=False).B.apply(lambda x: x.cummax()).to_frame()
  187:     )
  188:     tm.assert_frame_equal(result, expected)
  189: 
  190:     # Test nan in some values
  191:     # Explicit cast to float to avoid implicit cast when setting nan
  192:     base_df = base_df.astype({"B": "float"})
  193:     base_df.loc[[0, 2, 4, 6], "B"] = np.nan
  194:     expected = DataFrame({"B": [np.nan, 4, np.nan, 4, np.nan, 3, np.nan, 3]})
  195:     result = base_df.groupby("A").cummax()
  196:     tm.assert_frame_equal(result, expected)
  197:     expected = (
  198:         base_df.groupby("A", group_keys=False).B.apply(lambda x: x.cummax()).to_frame()
  199:     )
  200:     tm.assert_frame_equal(result, expected)
  201: 
  202:     # GH 15561
  203:     df = DataFrame({"a": [1], "b": pd.to_datetime(["2001"])})
  204:     expected = Series(pd.to_datetime("2001"), index=[0], name="b")
  205: 
  206:     result = df.groupby("a")["b"].cummax()
  207:     tm.assert_series_equal(expected, result)
  208: 
  209:     # GH 15635
  210:     df = DataFrame({"a": [1, 2, 1], "b": [2, 1, 1]})
  211:     result = df.groupby("a").b.cummax()
  212:     expected = Series([2, 1, 2], name="b")
  213:     tm.assert_series_equal(result, expected)
  214: 
  215: 
  216: def test_cummax_i8_at_implementation_bound():
  217:     # the minimum value used to be treated as NPY_NAT+1 instead of NPY_NAT
  218:     #  for int64 dtype GH#46382
  219:     ser = Series([pd.NaT._value + n for n in range(5)])
  220:     df = DataFrame({"A": 1, "B": ser, "C": ser._values.view("M8[ns]")})
  221:     gb = df.groupby("A")
  222: 
  223:     res = gb.cummax()
  224:     exp = df[["B", "C"]]
  225:     tm.assert_frame_equal(res, exp)
  226: 
  227: 
  228: @pytest.mark.parametrize("method", ["cummin", "cummax"])
  229: @pytest.mark.parametrize("dtype", ["float", "Int64", "Float64"])
  230: @pytest.mark.parametrize(
  231:     "groups,expected_data",
  232:     [
  233:         ([1, 1, 1], [1, None, None]),
  234:         ([1, 2, 3], [1, None, 2]),
  235:         ([1, 3, 3], [1, None, None]),
  236:     ],
  237: )
  238: def test_cummin_max_skipna(method, dtype, groups, expected_data):
  239:     # GH-34047
  240:     df = DataFrame({"a": Series([1, None, 2], dtype=dtype)})
  241:     orig = df.copy()
  242:     gb = df.groupby(groups)["a"]
  243: 
  244:     result = getattr(gb, method)(skipna=False)
  245:     expected = Series(expected_data, dtype=dtype, name="a")
  246: 
  247:     # check we didn't accidentally alter df
  248:     tm.assert_frame_equal(df, orig)
  249: 
  250:     tm.assert_series_equal(result, expected)
  251: 
  252: 
  253: @pytest.mark.parametrize("method", ["cummin", "cummax"])
  254: def test_cummin_max_skipna_multiple_cols(method):
  255:     # Ensure missing value in "a" doesn't cause "b" to be nan-filled
  256:     df = DataFrame({"a": [np.nan, 2.0, 2.0], "b": [2.0, 2.0, 2.0]})
  257:     gb = df.groupby([1, 1, 1])[["a", "b"]]
  258: 
  259:     result = getattr(gb, method)(skipna=False)
  260:     expected = DataFrame({"a": [np.nan, np.nan, np.nan], "b": [2.0, 2.0, 2.0]})
  261: 
  262:     tm.assert_frame_equal(result, expected)
  263: 
  264: 
  265: @pytest.mark.parametrize("func", ["cumprod", "cumsum"])
  266: def test_numpy_compat(func):
  267:     # see gh-12811
  268:     df = DataFrame({"A": [1, 2, 1], "B": [1, 2, 3]})
  269:     g = df.groupby("A")
  270: 
  271:     msg = "numpy operations are not valid with groupby"
  272: 
  273:     with pytest.raises(UnsupportedFunctionCall, match=msg):
  274:         getattr(g, func)(1, 2, 3)
  275:     with pytest.raises(UnsupportedFunctionCall, match=msg):
  276:         getattr(g, func)(foo=1)
  277: 
  278: 
  279: @td.skip_if_32bit
  280: @pytest.mark.parametrize("method", ["cummin", "cummax"])
  281: @pytest.mark.parametrize(
  282:     "dtype,val", [("UInt64", np.iinfo("uint64").max), ("Int64", 2**53 + 1)]
  283: )
  284: def test_nullable_int_not_cast_as_float(method, dtype, val):
  285:     data = [val, pd.NA]
  286:     df = DataFrame({"grp": [1, 1], "b": data}, dtype=dtype)
  287:     grouped = df.groupby("grp")
  288: 
  289:     result = grouped.transform(method)
  290:     expected = DataFrame({"b": data}, dtype=dtype)
  291: 
  292:     tm.assert_frame_equal(result, expected)
  293: 
  294: 
  295: def test_cython_api2():
  296:     # this takes the fast apply path
  297: 
  298:     # cumsum (GH5614)
  299:     df = DataFrame([[1, 2, np.nan], [1, np.nan, 9], [3, 4, 9]], columns=["A", "B", "C"])
  300:     expected = DataFrame([[2, np.nan], [np.nan, 9], [4, 9]], columns=["B", "C"])
  301:     result = df.groupby("A").cumsum()
  302:     tm.assert_frame_equal(result, expected)
  303: 
  304:     # GH 5755 - cumsum is a transformer and should ignore as_index
  305:     result = df.groupby("A", as_index=False).cumsum()
  306:     tm.assert_frame_equal(result, expected)
  307: 
  308:     # GH 13994
  309:     msg = "DataFrameGroupBy.cumsum with axis=1 is deprecated"
  310:     with tm.assert_produces_warning(FutureWarning, match=msg):
  311:         result = df.groupby("A").cumsum(axis=1)
  312:     expected = df.cumsum(axis=1)
  313:     tm.assert_frame_equal(result, expected)
  314: 
  315:     msg = "DataFrameGroupBy.cumprod with axis=1 is deprecated"
  316:     with tm.assert_produces_warning(FutureWarning, match=msg):
  317:         result = df.groupby("A").cumprod(axis=1)
  318:     expected = df.cumprod(axis=1)
  319:     tm.assert_frame_equal(result, expected)
