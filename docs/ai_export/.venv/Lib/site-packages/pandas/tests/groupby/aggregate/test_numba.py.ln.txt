    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas.errors import NumbaUtilError
    5: 
    6: from pandas import (
    7:     DataFrame,
    8:     Index,
    9:     NamedAgg,
   10:     Series,
   11:     option_context,
   12: )
   13: import pandas._testing as tm
   14: 
   15: pytestmark = pytest.mark.single_cpu
   16: 
   17: 
   18: def test_correct_function_signature():
   19:     pytest.importorskip("numba")
   20: 
   21:     def incorrect_function(x):
   22:         return sum(x) * 2.7
   23: 
   24:     data = DataFrame(
   25:         {"key": ["a", "a", "b", "b", "a"], "data": [1.0, 2.0, 3.0, 4.0, 5.0]},
   26:         columns=["key", "data"],
   27:     )
   28:     with pytest.raises(NumbaUtilError, match="The first 2"):
   29:         data.groupby("key").agg(incorrect_function, engine="numba")
   30: 
   31:     with pytest.raises(NumbaUtilError, match="The first 2"):
   32:         data.groupby("key")["data"].agg(incorrect_function, engine="numba")
   33: 
   34: 
   35: def test_check_nopython_kwargs():
   36:     pytest.importorskip("numba")
   37: 
   38:     def incorrect_function(values, index):
   39:         return sum(values) * 2.7
   40: 
   41:     data = DataFrame(
   42:         {"key": ["a", "a", "b", "b", "a"], "data": [1.0, 2.0, 3.0, 4.0, 5.0]},
   43:         columns=["key", "data"],
   44:     )
   45:     with pytest.raises(NumbaUtilError, match="numba does not support"):
   46:         data.groupby("key").agg(incorrect_function, engine="numba", a=1)
   47: 
   48:     with pytest.raises(NumbaUtilError, match="numba does not support"):
   49:         data.groupby("key")["data"].agg(incorrect_function, engine="numba", a=1)
   50: 
   51: 
   52: @pytest.mark.filterwarnings("ignore")
   53: # Filter warnings when parallel=True and the function can't be parallelized by Numba
   54: @pytest.mark.parametrize("jit", [True, False])
   55: @pytest.mark.parametrize("pandas_obj", ["Series", "DataFrame"])
   56: @pytest.mark.parametrize("as_index", [True, False])
   57: def test_numba_vs_cython(jit, pandas_obj, nogil, parallel, nopython, as_index):
   58:     pytest.importorskip("numba")
   59: 
   60:     def func_numba(values, index):
   61:         return np.mean(values) * 2.7
   62: 
   63:     if jit:
   64:         # Test accepted jitted functions
   65:         import numba
   66: 
   67:         func_numba = numba.jit(func_numba)
   68: 
   69:     data = DataFrame(
   70:         {0: ["a", "a", "b", "b", "a"], 1: [1.0, 2.0, 3.0, 4.0, 5.0]}, columns=[0, 1]
   71:     )
   72:     engine_kwargs = {"nogil": nogil, "parallel": parallel, "nopython": nopython}
   73:     grouped = data.groupby(0, as_index=as_index)
   74:     if pandas_obj == "Series":
   75:         grouped = grouped[1]
   76: 
   77:     result = grouped.agg(func_numba, engine="numba", engine_kwargs=engine_kwargs)
   78:     expected = grouped.agg(lambda x: np.mean(x) * 2.7, engine="cython")
   79: 
   80:     tm.assert_equal(result, expected)
   81: 
   82: 
   83: @pytest.mark.filterwarnings("ignore")
   84: # Filter warnings when parallel=True and the function can't be parallelized by Numba
   85: @pytest.mark.parametrize("jit", [True, False])
   86: @pytest.mark.parametrize("pandas_obj", ["Series", "DataFrame"])
   87: def test_cache(jit, pandas_obj, nogil, parallel, nopython):
   88:     # Test that the functions are cached correctly if we switch functions
   89:     pytest.importorskip("numba")
   90: 
   91:     def func_1(values, index):
   92:         return np.mean(values) - 3.4
   93: 
   94:     def func_2(values, index):
   95:         return np.mean(values) * 2.7
   96: 
   97:     if jit:
   98:         import numba
   99: 
  100:         func_1 = numba.jit(func_1)
  101:         func_2 = numba.jit(func_2)
  102: 
  103:     data = DataFrame(
  104:         {0: ["a", "a", "b", "b", "a"], 1: [1.0, 2.0, 3.0, 4.0, 5.0]}, columns=[0, 1]
  105:     )
  106:     engine_kwargs = {"nogil": nogil, "parallel": parallel, "nopython": nopython}
  107:     grouped = data.groupby(0)
  108:     if pandas_obj == "Series":
  109:         grouped = grouped[1]
  110: 
  111:     result = grouped.agg(func_1, engine="numba", engine_kwargs=engine_kwargs)
  112:     expected = grouped.agg(lambda x: np.mean(x) - 3.4, engine="cython")
  113:     tm.assert_equal(result, expected)
  114: 
  115:     # Add func_2 to the cache
  116:     result = grouped.agg(func_2, engine="numba", engine_kwargs=engine_kwargs)
  117:     expected = grouped.agg(lambda x: np.mean(x) * 2.7, engine="cython")
  118:     tm.assert_equal(result, expected)
  119: 
  120:     # Retest func_1 which should use the cache
  121:     result = grouped.agg(func_1, engine="numba", engine_kwargs=engine_kwargs)
  122:     expected = grouped.agg(lambda x: np.mean(x) - 3.4, engine="cython")
  123:     tm.assert_equal(result, expected)
  124: 
  125: 
  126: def test_use_global_config():
  127:     pytest.importorskip("numba")
  128: 
  129:     def func_1(values, index):
  130:         return np.mean(values) - 3.4
  131: 
  132:     data = DataFrame(
  133:         {0: ["a", "a", "b", "b", "a"], 1: [1.0, 2.0, 3.0, 4.0, 5.0]}, columns=[0, 1]
  134:     )
  135:     grouped = data.groupby(0)
  136:     expected = grouped.agg(func_1, engine="numba")
  137:     with option_context("compute.use_numba", True):
  138:         result = grouped.agg(func_1, engine=None)
  139:     tm.assert_frame_equal(expected, result)
  140: 
  141: 
  142: @pytest.mark.parametrize(
  143:     "agg_kwargs",
  144:     [
  145:         {"func": ["min", "max"]},
  146:         {"func": "min"},
  147:         {"func": {1: ["min", "max"], 2: "sum"}},
  148:         {"bmin": NamedAgg(column=1, aggfunc="min")},
  149:     ],
  150: )
  151: def test_multifunc_numba_vs_cython_frame(agg_kwargs):
  152:     pytest.importorskip("numba")
  153:     data = DataFrame(
  154:         {
  155:             0: ["a", "a", "b", "b", "a"],
  156:             1: [1.0, 2.0, 3.0, 4.0, 5.0],
  157:             2: [1, 2, 3, 4, 5],
  158:         },
  159:         columns=[0, 1, 2],
  160:     )
  161:     grouped = data.groupby(0)
  162:     result = grouped.agg(**agg_kwargs, engine="numba")
  163:     expected = grouped.agg(**agg_kwargs, engine="cython")
  164:     tm.assert_frame_equal(result, expected)
  165: 
  166: 
  167: @pytest.mark.parametrize(
  168:     "agg_kwargs,expected_func",
  169:     [
  170:         ({"func": lambda values, index: values.sum()}, "sum"),
  171:         # FIXME
  172:         pytest.param(
  173:             {
  174:                 "func": [
  175:                     lambda values, index: values.sum(),
  176:                     lambda values, index: values.min(),
  177:                 ]
  178:             },
  179:             ["sum", "min"],
  180:             marks=pytest.mark.xfail(
  181:                 reason="This doesn't work yet! Fails in nopython pipeline!"
  182:             ),
  183:         ),
  184:     ],
  185: )
  186: def test_multifunc_numba_udf_frame(agg_kwargs, expected_func):
  187:     pytest.importorskip("numba")
  188:     data = DataFrame(
  189:         {
  190:             0: ["a", "a", "b", "b", "a"],
  191:             1: [1.0, 2.0, 3.0, 4.0, 5.0],
  192:             2: [1, 2, 3, 4, 5],
  193:         },
  194:         columns=[0, 1, 2],
  195:     )
  196:     grouped = data.groupby(0)
  197:     result = grouped.agg(**agg_kwargs, engine="numba")
  198:     expected = grouped.agg(expected_func, engine="cython")
  199:     # check_dtype can be removed if GH 44952 is addressed
  200:     # Currently, UDFs still always return float64 while reductions can preserve dtype
  201:     tm.assert_frame_equal(result, expected, check_dtype=False)
  202: 
  203: 
  204: @pytest.mark.parametrize(
  205:     "agg_kwargs",
  206:     [{"func": ["min", "max"]}, {"func": "min"}, {"min_val": "min", "max_val": "max"}],
  207: )
  208: def test_multifunc_numba_vs_cython_series(agg_kwargs):
  209:     pytest.importorskip("numba")
  210:     labels = ["a", "a", "b", "b", "a"]
  211:     data = Series([1.0, 2.0, 3.0, 4.0, 5.0])
  212:     grouped = data.groupby(labels)
  213:     agg_kwargs["engine"] = "numba"
  214:     result = grouped.agg(**agg_kwargs)
  215:     agg_kwargs["engine"] = "cython"
  216:     expected = grouped.agg(**agg_kwargs)
  217:     if isinstance(expected, DataFrame):
  218:         tm.assert_frame_equal(result, expected)
  219:     else:
  220:         tm.assert_series_equal(result, expected)
  221: 
  222: 
  223: @pytest.mark.single_cpu
  224: @pytest.mark.parametrize(
  225:     "data,agg_kwargs",
  226:     [
  227:         (Series([1.0, 2.0, 3.0, 4.0, 5.0]), {"func": ["min", "max"]}),
  228:         (Series([1.0, 2.0, 3.0, 4.0, 5.0]), {"func": "min"}),
  229:         (
  230:             DataFrame(
  231:                 {1: [1.0, 2.0, 3.0, 4.0, 5.0], 2: [1, 2, 3, 4, 5]}, columns=[1, 2]
  232:             ),
  233:             {"func": ["min", "max"]},
  234:         ),
  235:         (
  236:             DataFrame(
  237:                 {1: [1.0, 2.0, 3.0, 4.0, 5.0], 2: [1, 2, 3, 4, 5]}, columns=[1, 2]
  238:             ),
  239:             {"func": "min"},
  240:         ),
  241:         (
  242:             DataFrame(
  243:                 {1: [1.0, 2.0, 3.0, 4.0, 5.0], 2: [1, 2, 3, 4, 5]}, columns=[1, 2]
  244:             ),
  245:             {"func": {1: ["min", "max"], 2: "sum"}},
  246:         ),
  247:         (
  248:             DataFrame(
  249:                 {1: [1.0, 2.0, 3.0, 4.0, 5.0], 2: [1, 2, 3, 4, 5]}, columns=[1, 2]
  250:             ),
  251:             {"min_col": NamedAgg(column=1, aggfunc="min")},
  252:         ),
  253:     ],
  254: )
  255: def test_multifunc_numba_kwarg_propagation(data, agg_kwargs):
  256:     pytest.importorskip("numba")
  257:     labels = ["a", "a", "b", "b", "a"]
  258:     grouped = data.groupby(labels)
  259:     result = grouped.agg(**agg_kwargs, engine="numba", engine_kwargs={"parallel": True})
  260:     expected = grouped.agg(**agg_kwargs, engine="numba")
  261:     if isinstance(expected, DataFrame):
  262:         tm.assert_frame_equal(result, expected)
  263:     else:
  264:         tm.assert_series_equal(result, expected)
  265: 
  266: 
  267: def test_args_not_cached():
  268:     # GH 41647
  269:     pytest.importorskip("numba")
  270: 
  271:     def sum_last(values, index, n):
  272:         return values[-n:].sum()
  273: 
  274:     df = DataFrame({"id": [0, 0, 1, 1], "x": [1, 1, 1, 1]})
  275:     grouped_x = df.groupby("id")["x"]
  276:     result = grouped_x.agg(sum_last, 1, engine="numba")
  277:     expected = Series([1.0] * 2, name="x", index=Index([0, 1], name="id"))
  278:     tm.assert_series_equal(result, expected)
  279: 
  280:     result = grouped_x.agg(sum_last, 2, engine="numba")
  281:     expected = Series([2.0] * 2, name="x", index=Index([0, 1], name="id"))
  282:     tm.assert_series_equal(result, expected)
  283: 
  284: 
  285: def test_index_data_correctly_passed():
  286:     # GH 43133
  287:     pytest.importorskip("numba")
  288: 
  289:     def f(values, index):
  290:         return np.mean(index)
  291: 
  292:     df = DataFrame({"group": ["A", "A", "B"], "v": [4, 5, 6]}, index=[-1, -2, -3])
  293:     result = df.groupby("group").aggregate(f, engine="numba")
  294:     expected = DataFrame(
  295:         [-1.5, -3.0], columns=["v"], index=Index(["A", "B"], name="group")
  296:     )
  297:     tm.assert_frame_equal(result, expected)
  298: 
  299: 
  300: def test_engine_kwargs_not_cached():
  301:     # If the user passes a different set of engine_kwargs don't return the same
  302:     # jitted function
  303:     pytest.importorskip("numba")
  304:     nogil = True
  305:     parallel = False
  306:     nopython = True
  307: 
  308:     def func_kwargs(values, index):
  309:         return nogil + parallel + nopython
  310: 
  311:     engine_kwargs = {"nopython": nopython, "nogil": nogil, "parallel": parallel}
  312:     df = DataFrame({"value": [0, 0, 0]})
  313:     result = df.groupby(level=0).aggregate(
  314:         func_kwargs, engine="numba", engine_kwargs=engine_kwargs
  315:     )
  316:     expected = DataFrame({"value": [2.0, 2.0, 2.0]})
  317:     tm.assert_frame_equal(result, expected)
  318: 
  319:     nogil = False
  320:     engine_kwargs = {"nopython": nopython, "nogil": nogil, "parallel": parallel}
  321:     result = df.groupby(level=0).aggregate(
  322:         func_kwargs, engine="numba", engine_kwargs=engine_kwargs
  323:     )
  324:     expected = DataFrame({"value": [1.0, 1.0, 1.0]})
  325:     tm.assert_frame_equal(result, expected)
  326: 
  327: 
  328: @pytest.mark.filterwarnings("ignore")
  329: def test_multiindex_one_key(nogil, parallel, nopython):
  330:     pytest.importorskip("numba")
  331: 
  332:     def numba_func(values, index):
  333:         return 1
  334: 
  335:     df = DataFrame([{"A": 1, "B": 2, "C": 3}]).set_index(["A", "B"])
  336:     engine_kwargs = {"nopython": nopython, "nogil": nogil, "parallel": parallel}
  337:     result = df.groupby("A").agg(
  338:         numba_func, engine="numba", engine_kwargs=engine_kwargs
  339:     )
  340:     expected = DataFrame([1.0], index=Index([1], name="A"), columns=["C"])
  341:     tm.assert_frame_equal(result, expected)
  342: 
  343: 
  344: def test_multiindex_multi_key_not_supported(nogil, parallel, nopython):
  345:     pytest.importorskip("numba")
  346: 
  347:     def numba_func(values, index):
  348:         return 1
  349: 
  350:     df = DataFrame([{"A": 1, "B": 2, "C": 3}]).set_index(["A", "B"])
  351:     engine_kwargs = {"nopython": nopython, "nogil": nogil, "parallel": parallel}
  352:     with pytest.raises(NotImplementedError, match="more than 1 grouping labels"):
  353:         df.groupby(["A", "B"]).agg(
  354:             numba_func, engine="numba", engine_kwargs=engine_kwargs
  355:         )
  356: 
  357: 
  358: def test_multilabel_numba_vs_cython(numba_supported_reductions):
  359:     pytest.importorskip("numba")
  360:     reduction, kwargs = numba_supported_reductions
  361:     df = DataFrame(
  362:         {
  363:             "A": ["foo", "bar", "foo", "bar", "foo", "bar", "foo", "foo"],
  364:             "B": ["one", "one", "two", "three", "two", "two", "one", "three"],
  365:             "C": np.random.default_rng(2).standard_normal(8),
  366:             "D": np.random.default_rng(2).standard_normal(8),
  367:         }
  368:     )
  369:     gb = df.groupby(["A", "B"])
  370:     res_agg = gb.agg(reduction, engine="numba", **kwargs)
  371:     expected_agg = gb.agg(reduction, engine="cython", **kwargs)
  372:     tm.assert_frame_equal(res_agg, expected_agg)
  373:     # Test that calling the aggregation directly also works
  374:     direct_res = getattr(gb, reduction)(engine="numba", **kwargs)
  375:     direct_expected = getattr(gb, reduction)(engine="cython", **kwargs)
  376:     tm.assert_frame_equal(direct_res, direct_expected)
  377: 
  378: 
  379: def test_multilabel_udf_numba_vs_cython():
  380:     pytest.importorskip("numba")
  381:     df = DataFrame(
  382:         {
  383:             "A": ["foo", "bar", "foo", "bar", "foo", "bar", "foo", "foo"],
  384:             "B": ["one", "one", "two", "three", "two", "two", "one", "three"],
  385:             "C": np.random.default_rng(2).standard_normal(8),
  386:             "D": np.random.default_rng(2).standard_normal(8),
  387:         }
  388:     )
  389:     gb = df.groupby(["A", "B"])
  390:     result = gb.agg(lambda values, index: values.min(), engine="numba")
  391:     expected = gb.agg(lambda x: x.min(), engine="cython")
  392:     tm.assert_frame_equal(result, expected)
