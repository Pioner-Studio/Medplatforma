    1: # Only tests that raise an error and have no better location should go here.
    2: # Tests for specific groupby methods should go in their respective
    3: # test file.
    4: 
    5: import datetime
    6: import re
    7: 
    8: import numpy as np
    9: import pytest
   10: 
   11: from pandas import (
   12:     Categorical,
   13:     DataFrame,
   14:     Grouper,
   15:     Series,
   16: )
   17: import pandas._testing as tm
   18: from pandas.tests.groupby import get_groupby_method_args
   19: 
   20: 
   21: @pytest.fixture(
   22:     params=[
   23:         "a",
   24:         ["a"],
   25:         ["a", "b"],
   26:         Grouper(key="a"),
   27:         lambda x: x % 2,
   28:         [0, 0, 0, 1, 2, 2, 2, 3, 3],
   29:         np.array([0, 0, 0, 1, 2, 2, 2, 3, 3]),
   30:         dict(zip(range(9), [0, 0, 0, 1, 2, 2, 2, 3, 3])),
   31:         Series([1, 1, 1, 1, 1, 2, 2, 2, 2]),
   32:         [Series([1, 1, 1, 1, 1, 2, 2, 2, 2]), Series([3, 3, 4, 4, 4, 4, 4, 3, 3])],
   33:     ]
   34: )
   35: def by(request):
   36:     return request.param
   37: 
   38: 
   39: @pytest.fixture(params=[True, False])
   40: def groupby_series(request):
   41:     return request.param
   42: 
   43: 
   44: @pytest.fixture
   45: def df_with_string_col():
   46:     df = DataFrame(
   47:         {
   48:             "a": [1, 1, 1, 1, 1, 2, 2, 2, 2],
   49:             "b": [3, 3, 4, 4, 4, 4, 4, 3, 3],
   50:             "c": range(9),
   51:             "d": list("xyzwtyuio"),
   52:         }
   53:     )
   54:     return df
   55: 
   56: 
   57: @pytest.fixture
   58: def df_with_datetime_col():
   59:     df = DataFrame(
   60:         {
   61:             "a": [1, 1, 1, 1, 1, 2, 2, 2, 2],
   62:             "b": [3, 3, 4, 4, 4, 4, 4, 3, 3],
   63:             "c": range(9),
   64:             "d": datetime.datetime(2005, 1, 1, 10, 30, 23, 540000),
   65:         }
   66:     )
   67:     return df
   68: 
   69: 
   70: @pytest.fixture
   71: def df_with_timedelta_col():
   72:     df = DataFrame(
   73:         {
   74:             "a": [1, 1, 1, 1, 1, 2, 2, 2, 2],
   75:             "b": [3, 3, 4, 4, 4, 4, 4, 3, 3],
   76:             "c": range(9),
   77:             "d": datetime.timedelta(days=1),
   78:         }
   79:     )
   80:     return df
   81: 
   82: 
   83: @pytest.fixture
   84: def df_with_cat_col():
   85:     df = DataFrame(
   86:         {
   87:             "a": [1, 1, 1, 1, 1, 2, 2, 2, 2],
   88:             "b": [3, 3, 4, 4, 4, 4, 4, 3, 3],
   89:             "c": range(9),
   90:             "d": Categorical(
   91:                 ["a", "a", "a", "a", "b", "b", "b", "b", "c"],
   92:                 categories=["a", "b", "c", "d"],
   93:                 ordered=True,
   94:             ),
   95:         }
   96:     )
   97:     return df
   98: 
   99: 
  100: def _call_and_check(klass, msg, how, gb, groupby_func, args, warn_msg=""):
  101:     warn_klass = None if warn_msg == "" else FutureWarning
  102:     with tm.assert_produces_warning(warn_klass, match=warn_msg):
  103:         if klass is None:
  104:             if how == "method":
  105:                 getattr(gb, groupby_func)(*args)
  106:             elif how == "agg":
  107:                 gb.agg(groupby_func, *args)
  108:             else:
  109:                 gb.transform(groupby_func, *args)
  110:         else:
  111:             with pytest.raises(klass, match=msg):
  112:                 if how == "method":
  113:                     getattr(gb, groupby_func)(*args)
  114:                 elif how == "agg":
  115:                     gb.agg(groupby_func, *args)
  116:                 else:
  117:                     gb.transform(groupby_func, *args)
  118: 
  119: 
  120: @pytest.mark.parametrize("how", ["method", "agg", "transform"])
  121: def test_groupby_raises_string(
  122:     how, by, groupby_series, groupby_func, df_with_string_col
  123: ):
  124:     df = df_with_string_col
  125:     args = get_groupby_method_args(groupby_func, df)
  126:     gb = df.groupby(by=by)
  127: 
  128:     if groupby_series:
  129:         gb = gb["d"]
  130: 
  131:         if groupby_func == "corrwith":
  132:             assert not hasattr(gb, "corrwith")
  133:             return
  134: 
  135:     klass, msg = {
  136:         "all": (None, ""),
  137:         "any": (None, ""),
  138:         "bfill": (None, ""),
  139:         "corrwith": (TypeError, "Could not convert"),
  140:         "count": (None, ""),
  141:         "cumcount": (None, ""),
  142:         "cummax": (
  143:             (NotImplementedError, TypeError),
  144:             "(function|cummax) is not (implemented|supported) for (this|object) dtype",
  145:         ),
  146:         "cummin": (
  147:             (NotImplementedError, TypeError),
  148:             "(function|cummin) is not (implemented|supported) for (this|object) dtype",
  149:         ),
  150:         "cumprod": (
  151:             (NotImplementedError, TypeError),
  152:             "(function|cumprod) is not (implemented|supported) for (this|object) dtype",
  153:         ),
  154:         "cumsum": (
  155:             (NotImplementedError, TypeError),
  156:             "(function|cumsum) is not (implemented|supported) for (this|object) dtype",
  157:         ),
  158:         "diff": (TypeError, "unsupported operand type"),
  159:         "ffill": (None, ""),
  160:         "fillna": (None, ""),
  161:         "first": (None, ""),
  162:         "idxmax": (None, ""),
  163:         "idxmin": (None, ""),
  164:         "last": (None, ""),
  165:         "max": (None, ""),
  166:         "mean": (
  167:             TypeError,
  168:             re.escape("agg function failed [how->mean,dtype->object]"),
  169:         ),
  170:         "median": (
  171:             TypeError,
  172:             re.escape("agg function failed [how->median,dtype->object]"),
  173:         ),
  174:         "min": (None, ""),
  175:         "ngroup": (None, ""),
  176:         "nunique": (None, ""),
  177:         "pct_change": (TypeError, "unsupported operand type"),
  178:         "prod": (
  179:             TypeError,
  180:             re.escape("agg function failed [how->prod,dtype->object]"),
  181:         ),
  182:         "quantile": (TypeError, "cannot be performed against 'object' dtypes!"),
  183:         "rank": (None, ""),
  184:         "sem": (ValueError, "could not convert string to float"),
  185:         "shift": (None, ""),
  186:         "size": (None, ""),
  187:         "skew": (ValueError, "could not convert string to float"),
  188:         "std": (ValueError, "could not convert string to float"),
  189:         "sum": (None, ""),
  190:         "var": (
  191:             TypeError,
  192:             re.escape("agg function failed [how->var,dtype->"),
  193:         ),
  194:     }[groupby_func]
  195: 
  196:     if groupby_func == "fillna":
  197:         kind = "Series" if groupby_series else "DataFrame"
  198:         warn_msg = f"{kind}GroupBy.fillna is deprecated"
  199:     else:
  200:         warn_msg = ""
  201:     _call_and_check(klass, msg, how, gb, groupby_func, args, warn_msg)
  202: 
  203: 
  204: @pytest.mark.parametrize("how", ["agg", "transform"])
  205: def test_groupby_raises_string_udf(how, by, groupby_series, df_with_string_col):
  206:     df = df_with_string_col
  207:     gb = df.groupby(by=by)
  208: 
  209:     if groupby_series:
  210:         gb = gb["d"]
  211: 
  212:     def func(x):
  213:         raise TypeError("Test error message")
  214: 
  215:     with pytest.raises(TypeError, match="Test error message"):
  216:         getattr(gb, how)(func)
  217: 
  218: 
  219: @pytest.mark.parametrize("how", ["agg", "transform"])
  220: @pytest.mark.parametrize("groupby_func_np", [np.sum, np.mean])
  221: def test_groupby_raises_string_np(
  222:     how, by, groupby_series, groupby_func_np, df_with_string_col
  223: ):
  224:     # GH#50749
  225:     df = df_with_string_col
  226:     gb = df.groupby(by=by)
  227: 
  228:     if groupby_series:
  229:         gb = gb["d"]
  230: 
  231:     klass, msg = {
  232:         np.sum: (None, ""),
  233:         np.mean: (
  234:             TypeError,
  235:             re.escape("agg function failed [how->mean,dtype->object]"),
  236:         ),
  237:     }[groupby_func_np]
  238: 
  239:     if groupby_series:
  240:         warn_msg = "using SeriesGroupBy.[sum|mean]"
  241:     else:
  242:         warn_msg = "using DataFrameGroupBy.[sum|mean]"
  243:     _call_and_check(klass, msg, how, gb, groupby_func_np, (), warn_msg=warn_msg)
  244: 
  245: 
  246: @pytest.mark.parametrize("how", ["method", "agg", "transform"])
  247: def test_groupby_raises_datetime(
  248:     how, by, groupby_series, groupby_func, df_with_datetime_col
  249: ):
  250:     df = df_with_datetime_col
  251:     args = get_groupby_method_args(groupby_func, df)
  252:     gb = df.groupby(by=by)
  253: 
  254:     if groupby_series:
  255:         gb = gb["d"]
  256: 
  257:         if groupby_func == "corrwith":
  258:             assert not hasattr(gb, "corrwith")
  259:             return
  260: 
  261:     klass, msg = {
  262:         "all": (None, ""),
  263:         "any": (None, ""),
  264:         "bfill": (None, ""),
  265:         "corrwith": (TypeError, "cannot perform __mul__ with this index type"),
  266:         "count": (None, ""),
  267:         "cumcount": (None, ""),
  268:         "cummax": (None, ""),
  269:         "cummin": (None, ""),
  270:         "cumprod": (TypeError, "datetime64 type does not support cumprod operations"),
  271:         "cumsum": (TypeError, "datetime64 type does not support cumsum operations"),
  272:         "diff": (None, ""),
  273:         "ffill": (None, ""),
  274:         "fillna": (None, ""),
  275:         "first": (None, ""),
  276:         "idxmax": (None, ""),
  277:         "idxmin": (None, ""),
  278:         "last": (None, ""),
  279:         "max": (None, ""),
  280:         "mean": (None, ""),
  281:         "median": (None, ""),
  282:         "min": (None, ""),
  283:         "ngroup": (None, ""),
  284:         "nunique": (None, ""),
  285:         "pct_change": (TypeError, "cannot perform __truediv__ with this index type"),
  286:         "prod": (TypeError, "datetime64 type does not support prod"),
  287:         "quantile": (None, ""),
  288:         "rank": (None, ""),
  289:         "sem": (None, ""),
  290:         "shift": (None, ""),
  291:         "size": (None, ""),
  292:         "skew": (
  293:             TypeError,
  294:             "|".join(
  295:                 [
  296:                     r"dtype datetime64\[ns\] does not support reduction",
  297:                     "datetime64 type does not support skew operations",
  298:                 ]
  299:             ),
  300:         ),
  301:         "std": (None, ""),
  302:         "sum": (TypeError, "datetime64 type does not support sum operations"),
  303:         "var": (TypeError, "datetime64 type does not support var operations"),
  304:     }[groupby_func]
  305: 
  306:     if groupby_func in ["any", "all"]:
  307:         warn_msg = f"'{groupby_func}' with datetime64 dtypes is deprecated"
  308:     elif groupby_func == "fillna":
  309:         kind = "Series" if groupby_series else "DataFrame"
  310:         warn_msg = f"{kind}GroupBy.fillna is deprecated"
  311:     else:
  312:         warn_msg = ""
  313:     _call_and_check(klass, msg, how, gb, groupby_func, args, warn_msg=warn_msg)
  314: 
  315: 
  316: @pytest.mark.parametrize("how", ["agg", "transform"])
  317: def test_groupby_raises_datetime_udf(how, by, groupby_series, df_with_datetime_col):
  318:     df = df_with_datetime_col
  319:     gb = df.groupby(by=by)
  320: 
  321:     if groupby_series:
  322:         gb = gb["d"]
  323: 
  324:     def func(x):
  325:         raise TypeError("Test error message")
  326: 
  327:     with pytest.raises(TypeError, match="Test error message"):
  328:         getattr(gb, how)(func)
  329: 
  330: 
  331: @pytest.mark.parametrize("how", ["agg", "transform"])
  332: @pytest.mark.parametrize("groupby_func_np", [np.sum, np.mean])
  333: def test_groupby_raises_datetime_np(
  334:     how, by, groupby_series, groupby_func_np, df_with_datetime_col
  335: ):
  336:     # GH#50749
  337:     df = df_with_datetime_col
  338:     gb = df.groupby(by=by)
  339: 
  340:     if groupby_series:
  341:         gb = gb["d"]
  342: 
  343:     klass, msg = {
  344:         np.sum: (TypeError, "datetime64 type does not support sum operations"),
  345:         np.mean: (None, ""),
  346:     }[groupby_func_np]
  347: 
  348:     if groupby_series:
  349:         warn_msg = "using SeriesGroupBy.[sum|mean]"
  350:     else:
  351:         warn_msg = "using DataFrameGroupBy.[sum|mean]"
  352:     _call_and_check(klass, msg, how, gb, groupby_func_np, (), warn_msg=warn_msg)
  353: 
  354: 
  355: @pytest.mark.parametrize("func", ["prod", "cumprod", "skew", "var"])
  356: def test_groupby_raises_timedelta(func, df_with_timedelta_col):
  357:     df = df_with_timedelta_col
  358:     gb = df.groupby(by="a")
  359: 
  360:     _call_and_check(
  361:         TypeError,
  362:         "timedelta64 type does not support .* operations",
  363:         "method",
  364:         gb,
  365:         func,
  366:         [],
  367:     )
  368: 
  369: 
  370: @pytest.mark.parametrize("how", ["method", "agg", "transform"])
  371: def test_groupby_raises_category(
  372:     how, by, groupby_series, groupby_func, using_copy_on_write, df_with_cat_col
  373: ):
  374:     # GH#50749
  375:     df = df_with_cat_col
  376:     args = get_groupby_method_args(groupby_func, df)
  377:     gb = df.groupby(by=by)
  378: 
  379:     if groupby_series:
  380:         gb = gb["d"]
  381: 
  382:         if groupby_func == "corrwith":
  383:             assert not hasattr(gb, "corrwith")
  384:             return
  385: 
  386:     klass, msg = {
  387:         "all": (None, ""),
  388:         "any": (None, ""),
  389:         "bfill": (None, ""),
  390:         "corrwith": (
  391:             TypeError,
  392:             r"unsupported operand type\(s\) for \*: 'Categorical' and 'int'",
  393:         ),
  394:         "count": (None, ""),
  395:         "cumcount": (None, ""),
  396:         "cummax": (
  397:             (NotImplementedError, TypeError),
  398:             "(category type does not support cummax operations|"
  399:             "category dtype not supported|"
  400:             "cummax is not supported for category dtype)",
  401:         ),
  402:         "cummin": (
  403:             (NotImplementedError, TypeError),
  404:             "(category type does not support cummin operations|"
  405:             "category dtype not supported|"
  406:             "cummin is not supported for category dtype)",
  407:         ),
  408:         "cumprod": (
  409:             (NotImplementedError, TypeError),
  410:             "(category type does not support cumprod operations|"
  411:             "category dtype not supported|"
  412:             "cumprod is not supported for category dtype)",
  413:         ),
  414:         "cumsum": (
  415:             (NotImplementedError, TypeError),
  416:             "(category type does not support cumsum operations|"
  417:             "category dtype not supported|"
  418:             "cumsum is not supported for category dtype)",
  419:         ),
  420:         "diff": (
  421:             TypeError,
  422:             r"unsupported operand type\(s\) for -: 'Categorical' and 'Categorical'",
  423:         ),
  424:         "ffill": (None, ""),
  425:         "fillna": (
  426:             TypeError,
  427:             r"Cannot setitem on a Categorical with a new category \(0\), "
  428:             "set the categories first",
  429:         )
  430:         if not using_copy_on_write
  431:         else (None, ""),  # no-op with CoW
  432:         "first": (None, ""),
  433:         "idxmax": (None, ""),
  434:         "idxmin": (None, ""),
  435:         "last": (None, ""),
  436:         "max": (None, ""),
  437:         "mean": (
  438:             TypeError,
  439:             "|".join(
  440:                 [
  441:                     "'Categorical' .* does not support reduction 'mean'",
  442:                     "category dtype does not support aggregation 'mean'",
  443:                 ]
  444:             ),
  445:         ),
  446:         "median": (
  447:             TypeError,
  448:             "|".join(
  449:                 [
  450:                     "'Categorical' .* does not support reduction 'median'",
  451:                     "category dtype does not support aggregation 'median'",
  452:                 ]
  453:             ),
  454:         ),
  455:         "min": (None, ""),
  456:         "ngroup": (None, ""),
  457:         "nunique": (None, ""),
  458:         "pct_change": (
  459:             TypeError,
  460:             r"unsupported operand type\(s\) for /: 'Categorical' and 'Categorical'",
  461:         ),
  462:         "prod": (TypeError, "category type does not support prod operations"),
  463:         "quantile": (TypeError, "No matching signature found"),
  464:         "rank": (None, ""),
  465:         "sem": (
  466:             TypeError,
  467:             "|".join(
  468:                 [
  469:                     "'Categorical' .* does not support reduction 'sem'",
  470:                     "category dtype does not support aggregation 'sem'",
  471:                 ]
  472:             ),
  473:         ),
  474:         "shift": (None, ""),
  475:         "size": (None, ""),
  476:         "skew": (
  477:             TypeError,
  478:             "|".join(
  479:                 [
  480:                     "dtype category does not support reduction 'skew'",
  481:                     "category type does not support skew operations",
  482:                 ]
  483:             ),
  484:         ),
  485:         "std": (
  486:             TypeError,
  487:             "|".join(
  488:                 [
  489:                     "'Categorical' .* does not support reduction 'std'",
  490:                     "category dtype does not support aggregation 'std'",
  491:                 ]
  492:             ),
  493:         ),
  494:         "sum": (TypeError, "category type does not support sum operations"),
  495:         "var": (
  496:             TypeError,
  497:             "|".join(
  498:                 [
  499:                     "'Categorical' .* does not support reduction 'var'",
  500:                     "category dtype does not support aggregation 'var'",
  501:                 ]
  502:             ),
  503:         ),
  504:     }[groupby_func]
  505: 
  506:     if groupby_func == "fillna":
  507:         kind = "Series" if groupby_series else "DataFrame"
  508:         warn_msg = f"{kind}GroupBy.fillna is deprecated"
  509:     else:
  510:         warn_msg = ""
  511:     _call_and_check(klass, msg, how, gb, groupby_func, args, warn_msg)
  512: 
  513: 
  514: @pytest.mark.parametrize("how", ["agg", "transform"])
  515: def test_groupby_raises_category_udf(how, by, groupby_series, df_with_cat_col):
  516:     # GH#50749
  517:     df = df_with_cat_col
  518:     gb = df.groupby(by=by)
  519: 
  520:     if groupby_series:
  521:         gb = gb["d"]
  522: 
  523:     def func(x):
  524:         raise TypeError("Test error message")
  525: 
  526:     with pytest.raises(TypeError, match="Test error message"):
  527:         getattr(gb, how)(func)
  528: 
  529: 
  530: @pytest.mark.parametrize("how", ["agg", "transform"])
  531: @pytest.mark.parametrize("groupby_func_np", [np.sum, np.mean])
  532: def test_groupby_raises_category_np(
  533:     how, by, groupby_series, groupby_func_np, df_with_cat_col
  534: ):
  535:     # GH#50749
  536:     df = df_with_cat_col
  537:     gb = df.groupby(by=by)
  538: 
  539:     if groupby_series:
  540:         gb = gb["d"]
  541: 
  542:     klass, msg = {
  543:         np.sum: (TypeError, "category type does not support sum operations"),
  544:         np.mean: (
  545:             TypeError,
  546:             "category dtype does not support aggregation 'mean'",
  547:         ),
  548:     }[groupby_func_np]
  549: 
  550:     if groupby_series:
  551:         warn_msg = "using SeriesGroupBy.[sum|mean]"
  552:     else:
  553:         warn_msg = "using DataFrameGroupBy.[sum|mean]"
  554:     _call_and_check(klass, msg, how, gb, groupby_func_np, (), warn_msg=warn_msg)
  555: 
  556: 
  557: @pytest.mark.parametrize("how", ["method", "agg", "transform"])
  558: def test_groupby_raises_category_on_category(
  559:     how,
  560:     by,
  561:     groupby_series,
  562:     groupby_func,
  563:     observed,
  564:     using_copy_on_write,
  565:     df_with_cat_col,
  566: ):
  567:     # GH#50749
  568:     df = df_with_cat_col
  569:     df["a"] = Categorical(
  570:         ["a", "a", "a", "a", "b", "b", "b", "b", "c"],
  571:         categories=["a", "b", "c", "d"],
  572:         ordered=True,
  573:     )
  574:     args = get_groupby_method_args(groupby_func, df)
  575:     gb = df.groupby(by=by, observed=observed)
  576: 
  577:     if groupby_series:
  578:         gb = gb["d"]
  579: 
  580:         if groupby_func == "corrwith":
  581:             assert not hasattr(gb, "corrwith")
  582:             return
  583: 
  584:     empty_groups = not observed and any(group.empty for group in gb.groups.values())
  585:     if (
  586:         not observed
  587:         and how != "transform"
  588:         and isinstance(by, list)
  589:         and isinstance(by[0], str)
  590:         and by == ["a", "b"]
  591:     ):
  592:         assert not empty_groups
  593:         # TODO: empty_groups should be true due to unobserved categorical combinations
  594:         empty_groups = True
  595:     if how == "transform":
  596:         # empty groups will be ignored
  597:         empty_groups = False
  598: 
  599:     klass, msg = {
  600:         "all": (None, ""),
  601:         "any": (None, ""),
  602:         "bfill": (None, ""),
  603:         "corrwith": (
  604:             TypeError,
  605:             r"unsupported operand type\(s\) for \*: 'Categorical' and 'int'",
  606:         ),
  607:         "count": (None, ""),
  608:         "cumcount": (None, ""),
  609:         "cummax": (
  610:             (NotImplementedError, TypeError),
  611:             "(cummax is not supported for category dtype|"
  612:             "category dtype not supported|"
  613:             "category type does not support cummax operations)",
  614:         ),
  615:         "cummin": (
  616:             (NotImplementedError, TypeError),
  617:             "(cummin is not supported for category dtype|"
  618:             "category dtype not supported|"
  619:             "category type does not support cummin operations)",
  620:         ),
  621:         "cumprod": (
  622:             (NotImplementedError, TypeError),
  623:             "(cumprod is not supported for category dtype|"
  624:             "category dtype not supported|"
  625:             "category type does not support cumprod operations)",
  626:         ),
  627:         "cumsum": (
  628:             (NotImplementedError, TypeError),
  629:             "(cumsum is not supported for category dtype|"
  630:             "category dtype not supported|"
  631:             "category type does not support cumsum operations)",
  632:         ),
  633:         "diff": (TypeError, "unsupported operand type"),
  634:         "ffill": (None, ""),
  635:         "fillna": (
  636:             TypeError,
  637:             r"Cannot setitem on a Categorical with a new category \(0\), "
  638:             "set the categories first",
  639:         )
  640:         if not using_copy_on_write
  641:         else (None, ""),  # no-op with CoW
  642:         "first": (None, ""),
  643:         "idxmax": (ValueError, "empty group due to unobserved categories")
  644:         if empty_groups
  645:         else (None, ""),
  646:         "idxmin": (ValueError, "empty group due to unobserved categories")
  647:         if empty_groups
  648:         else (None, ""),
  649:         "last": (None, ""),
  650:         "max": (None, ""),
  651:         "mean": (TypeError, "category dtype does not support aggregation 'mean'"),
  652:         "median": (TypeError, "category dtype does not support aggregation 'median'"),
  653:         "min": (None, ""),
  654:         "ngroup": (None, ""),
  655:         "nunique": (None, ""),
  656:         "pct_change": (TypeError, "unsupported operand type"),
  657:         "prod": (TypeError, "category type does not support prod operations"),
  658:         "quantile": (TypeError, ""),
  659:         "rank": (None, ""),
  660:         "sem": (
  661:             TypeError,
  662:             "|".join(
  663:                 [
  664:                     "'Categorical' .* does not support reduction 'sem'",
  665:                     "category dtype does not support aggregation 'sem'",
  666:                 ]
  667:             ),
  668:         ),
  669:         "shift": (None, ""),
  670:         "size": (None, ""),
  671:         "skew": (
  672:             TypeError,
  673:             "|".join(
  674:                 [
  675:                     "category type does not support skew operations",
  676:                     "dtype category does not support reduction 'skew'",
  677:                 ]
  678:             ),
  679:         ),
  680:         "std": (
  681:             TypeError,
  682:             "|".join(
  683:                 [
  684:                     "'Categorical' .* does not support reduction 'std'",
  685:                     "category dtype does not support aggregation 'std'",
  686:                 ]
  687:             ),
  688:         ),
  689:         "sum": (TypeError, "category type does not support sum operations"),
  690:         "var": (
  691:             TypeError,
  692:             "|".join(
  693:                 [
  694:                     "'Categorical' .* does not support reduction 'var'",
  695:                     "category dtype does not support aggregation 'var'",
  696:                 ]
  697:             ),
  698:         ),
  699:     }[groupby_func]
  700: 
  701:     if groupby_func == "fillna":
  702:         kind = "Series" if groupby_series else "DataFrame"
  703:         warn_msg = f"{kind}GroupBy.fillna is deprecated"
  704:     else:
  705:         warn_msg = ""
  706:     _call_and_check(klass, msg, how, gb, groupby_func, args, warn_msg)
  707: 
  708: 
  709: def test_subsetting_columns_axis_1_raises():
  710:     # GH 35443
  711:     df = DataFrame({"a": [1], "b": [2], "c": [3]})
  712:     msg = "DataFrame.groupby with axis=1 is deprecated"
  713:     with tm.assert_produces_warning(FutureWarning, match=msg):
  714:         gb = df.groupby("a", axis=1)
  715:     with pytest.raises(ValueError, match="Cannot subset columns when using axis=1"):
  716:         gb["b"]
