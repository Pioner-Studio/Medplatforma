    1: """
    2: test .agg behavior / note that .apply is tested generally in test_groupby.py
    3: """
    4: import datetime
    5: import functools
    6: from functools import partial
    7: import re
    8: 
    9: import numpy as np
   10: import pytest
   11: 
   12: from pandas.errors import SpecificationError
   13: 
   14: from pandas.core.dtypes.common import is_integer_dtype
   15: 
   16: import pandas as pd
   17: from pandas import (
   18:     DataFrame,
   19:     Index,
   20:     MultiIndex,
   21:     Series,
   22:     concat,
   23:     to_datetime,
   24: )
   25: import pandas._testing as tm
   26: from pandas.core.groupby.grouper import Grouping
   27: 
   28: 
   29: def test_groupby_agg_no_extra_calls():
   30:     # GH#31760
   31:     df = DataFrame({"key": ["a", "b", "c", "c"], "value": [1, 2, 3, 4]})
   32:     gb = df.groupby("key")["value"]
   33: 
   34:     def dummy_func(x):
   35:         assert len(x) != 0
   36:         return x.sum()
   37: 
   38:     gb.agg(dummy_func)
   39: 
   40: 
   41: def test_agg_regression1(tsframe):
   42:     grouped = tsframe.groupby([lambda x: x.year, lambda x: x.month])
   43:     result = grouped.agg("mean")
   44:     expected = grouped.mean()
   45:     tm.assert_frame_equal(result, expected)
   46: 
   47: 
   48: def test_agg_must_agg(df):
   49:     grouped = df.groupby("A")["C"]
   50: 
   51:     msg = "Must produce aggregated value"
   52:     with pytest.raises(Exception, match=msg):
   53:         grouped.agg(lambda x: x.describe())
   54:     with pytest.raises(Exception, match=msg):
   55:         grouped.agg(lambda x: x.index[:2])
   56: 
   57: 
   58: def test_agg_ser_multi_key(df):
   59:     f = lambda x: x.sum()
   60:     results = df.C.groupby([df.A, df.B]).aggregate(f)
   61:     expected = df.groupby(["A", "B"]).sum()["C"]
   62:     tm.assert_series_equal(results, expected)
   63: 
   64: 
   65: def test_groupby_aggregation_mixed_dtype():
   66:     # GH 6212
   67:     expected = DataFrame(
   68:         {
   69:             "v1": [5, 5, 7, np.nan, 3, 3, 4, 1],
   70:             "v2": [55, 55, 77, np.nan, 33, 33, 44, 11],
   71:         },
   72:         index=MultiIndex.from_tuples(
   73:             [
   74:                 (1, 95),
   75:                 (1, 99),
   76:                 (2, 95),
   77:                 (2, 99),
   78:                 ("big", "damp"),
   79:                 ("blue", "dry"),
   80:                 ("red", "red"),
   81:                 ("red", "wet"),
   82:             ],
   83:             names=["by1", "by2"],
   84:         ),
   85:     )
   86: 
   87:     df = DataFrame(
   88:         {
   89:             "v1": [1, 3, 5, 7, 8, 3, 5, np.nan, 4, 5, 7, 9],
   90:             "v2": [11, 33, 55, 77, 88, 33, 55, np.nan, 44, 55, 77, 99],
   91:             "by1": ["red", "blue", 1, 2, np.nan, "big", 1, 2, "red", 1, np.nan, 12],
   92:             "by2": [
   93:                 "wet",
   94:                 "dry",
   95:                 99,
   96:                 95,
   97:                 np.nan,
   98:                 "damp",
   99:                 95,
  100:                 99,
  101:                 "red",
  102:                 99,
  103:                 np.nan,
  104:                 np.nan,
  105:             ],
  106:         }
  107:     )
  108: 
  109:     g = df.groupby(["by1", "by2"])
  110:     result = g[["v1", "v2"]].mean()
  111:     tm.assert_frame_equal(result, expected)
  112: 
  113: 
  114: def test_groupby_aggregation_multi_level_column():
  115:     # GH 29772
  116:     lst = [
  117:         [True, True, True, False],
  118:         [True, False, np.nan, False],
  119:         [True, True, np.nan, False],
  120:         [True, True, np.nan, False],
  121:     ]
  122:     df = DataFrame(
  123:         data=lst,
  124:         columns=MultiIndex.from_tuples([("A", 0), ("A", 1), ("B", 0), ("B", 1)]),
  125:     )
  126: 
  127:     msg = "DataFrame.groupby with axis=1 is deprecated"
  128:     with tm.assert_produces_warning(FutureWarning, match=msg):
  129:         gb = df.groupby(level=1, axis=1)
  130:     result = gb.sum(numeric_only=False)
  131:     expected = DataFrame({0: [2.0, True, True, True], 1: [1, 0, 1, 1]})
  132: 
  133:     tm.assert_frame_equal(result, expected)
  134: 
  135: 
  136: def test_agg_apply_corner(ts, tsframe):
  137:     # nothing to group, all NA
  138:     grouped = ts.groupby(ts * np.nan, group_keys=False)
  139:     assert ts.dtype == np.float64
  140: 
  141:     # groupby float64 values results in a float64 Index
  142:     exp = Series([], dtype=np.float64, index=Index([], dtype=np.float64))
  143:     tm.assert_series_equal(grouped.sum(), exp)
  144:     tm.assert_series_equal(grouped.agg("sum"), exp)
  145:     tm.assert_series_equal(grouped.apply("sum"), exp, check_index_type=False)
  146: 
  147:     # DataFrame
  148:     grouped = tsframe.groupby(tsframe["A"] * np.nan, group_keys=False)
  149:     exp_df = DataFrame(
  150:         columns=tsframe.columns,
  151:         dtype=float,
  152:         index=Index([], name="A", dtype=np.float64),
  153:     )
  154:     tm.assert_frame_equal(grouped.sum(), exp_df)
  155:     tm.assert_frame_equal(grouped.agg("sum"), exp_df)
  156: 
  157:     msg = "The behavior of DataFrame.sum with axis=None is deprecated"
  158:     with tm.assert_produces_warning(FutureWarning, match=msg, check_stacklevel=False):
  159:         res = grouped.apply(np.sum)
  160:     tm.assert_frame_equal(res, exp_df)
  161: 
  162: 
  163: def test_agg_grouping_is_list_tuple(ts):
  164:     df = DataFrame(
  165:         np.random.default_rng(2).standard_normal((30, 4)),
  166:         columns=Index(list("ABCD"), dtype=object),
  167:         index=pd.date_range("2000-01-01", periods=30, freq="B"),
  168:     )
  169: 
  170:     grouped = df.groupby(lambda x: x.year)
  171:     grouper = grouped._grouper.groupings[0].grouping_vector
  172:     grouped._grouper.groupings[0] = Grouping(ts.index, list(grouper))
  173: 
  174:     result = grouped.agg("mean")
  175:     expected = grouped.mean()
  176:     tm.assert_frame_equal(result, expected)
  177: 
  178:     grouped._grouper.groupings[0] = Grouping(ts.index, tuple(grouper))
  179: 
  180:     result = grouped.agg("mean")
  181:     expected = grouped.mean()
  182:     tm.assert_frame_equal(result, expected)
  183: 
  184: 
  185: def test_agg_python_multiindex(multiindex_dataframe_random_data):
  186:     grouped = multiindex_dataframe_random_data.groupby(["A", "B"])
  187: 
  188:     result = grouped.agg("mean")
  189:     expected = grouped.mean()
  190:     tm.assert_frame_equal(result, expected)
  191: 
  192: 
  193: @pytest.mark.parametrize(
  194:     "groupbyfunc", [lambda x: x.weekday(), [lambda x: x.month, lambda x: x.weekday()]]
  195: )
  196: def test_aggregate_str_func(tsframe, groupbyfunc):
  197:     grouped = tsframe.groupby(groupbyfunc)
  198: 
  199:     # single series
  200:     result = grouped["A"].agg("std")
  201:     expected = grouped["A"].std()
  202:     tm.assert_series_equal(result, expected)
  203: 
  204:     # group frame by function name
  205:     result = grouped.aggregate("var")
  206:     expected = grouped.var()
  207:     tm.assert_frame_equal(result, expected)
  208: 
  209:     # group frame by function dict
  210:     result = grouped.agg({"A": "var", "B": "std", "C": "mean", "D": "sem"})
  211:     expected = DataFrame(
  212:         {
  213:             "A": grouped["A"].var(),
  214:             "B": grouped["B"].std(),
  215:             "C": grouped["C"].mean(),
  216:             "D": grouped["D"].sem(),
  217:         }
  218:     )
  219:     tm.assert_frame_equal(result, expected)
  220: 
  221: 
  222: def test_std_masked_dtype(any_numeric_ea_dtype):
  223:     # GH#35516
  224:     df = DataFrame(
  225:         {
  226:             "a": [2, 1, 1, 1, 2, 2, 1],
  227:             "b": Series([pd.NA, 1, 2, 1, 1, 1, 2], dtype="Float64"),
  228:         }
  229:     )
  230:     result = df.groupby("a").std()
  231:     expected = DataFrame(
  232:         {"b": [0.57735, 0]}, index=Index([1, 2], name="a"), dtype="Float64"
  233:     )
  234:     tm.assert_frame_equal(result, expected)
  235: 
  236: 
  237: def test_agg_str_with_kwarg_axis_1_raises(df, reduction_func):
  238:     gb = df.groupby(level=0)
  239:     warn_msg = f"DataFrameGroupBy.{reduction_func} with axis=1 is deprecated"
  240:     if reduction_func in ("idxmax", "idxmin"):
  241:         error = TypeError
  242:         msg = "'[<>]' not supported between instances of 'float' and 'str'"
  243:         warn = FutureWarning
  244:     else:
  245:         error = ValueError
  246:         msg = f"Operation {reduction_func} does not support axis=1"
  247:         warn = None
  248:     with pytest.raises(error, match=msg):
  249:         with tm.assert_produces_warning(warn, match=warn_msg):
  250:             gb.agg(reduction_func, axis=1)
  251: 
  252: 
  253: @pytest.mark.parametrize(
  254:     "func, expected, dtype, result_dtype_dict",
  255:     [
  256:         ("sum", [5, 7, 9], "int64", {}),
  257:         ("std", [4.5**0.5] * 3, int, {"i": float, "j": float, "k": float}),
  258:         ("var", [4.5] * 3, int, {"i": float, "j": float, "k": float}),
  259:         ("sum", [5, 7, 9], "Int64", {"j": "int64"}),
  260:         ("std", [4.5**0.5] * 3, "Int64", {"i": float, "j": float, "k": float}),
  261:         ("var", [4.5] * 3, "Int64", {"i": "float64", "j": "float64", "k": "float64"}),
  262:     ],
  263: )
  264: def test_multiindex_groupby_mixed_cols_axis1(func, expected, dtype, result_dtype_dict):
  265:     # GH#43209
  266:     df = DataFrame(
  267:         [[1, 2, 3, 4, 5, 6]] * 3,
  268:         columns=MultiIndex.from_product([["a", "b"], ["i", "j", "k"]]),
  269:     ).astype({("a", "j"): dtype, ("b", "j"): dtype})
  270: 
  271:     msg = "DataFrame.groupby with axis=1 is deprecated"
  272:     with tm.assert_produces_warning(FutureWarning, match=msg):
  273:         gb = df.groupby(level=1, axis=1)
  274:     result = gb.agg(func)
  275:     expected = DataFrame([expected] * 3, columns=["i", "j", "k"]).astype(
  276:         result_dtype_dict
  277:     )
  278: 
  279:     tm.assert_frame_equal(result, expected)
  280: 
  281: 
  282: @pytest.mark.parametrize(
  283:     "func, expected_data, result_dtype_dict",
  284:     [
  285:         ("sum", [[2, 4], [10, 12], [18, 20]], {10: "int64", 20: "int64"}),
  286:         # std should ideally return Int64 / Float64 #43330
  287:         ("std", [[2**0.5] * 2] * 3, "float64"),
  288:         ("var", [[2] * 2] * 3, {10: "float64", 20: "float64"}),
  289:     ],
  290: )
  291: def test_groupby_mixed_cols_axis1(func, expected_data, result_dtype_dict):
  292:     # GH#43209
  293:     df = DataFrame(
  294:         np.arange(12).reshape(3, 4),
  295:         index=Index([0, 1, 0], name="y"),
  296:         columns=Index([10, 20, 10, 20], name="x"),
  297:         dtype="int64",
  298:     ).astype({10: "Int64"})
  299: 
  300:     msg = "DataFrame.groupby with axis=1 is deprecated"
  301:     with tm.assert_produces_warning(FutureWarning, match=msg):
  302:         gb = df.groupby("x", axis=1)
  303:     result = gb.agg(func)
  304:     expected = DataFrame(
  305:         data=expected_data,
  306:         index=Index([0, 1, 0], name="y"),
  307:         columns=Index([10, 20], name="x"),
  308:     ).astype(result_dtype_dict)
  309:     tm.assert_frame_equal(result, expected)
  310: 
  311: 
  312: def test_aggregate_item_by_item(df):
  313:     grouped = df.groupby("A")
  314: 
  315:     aggfun_0 = lambda ser: ser.size
  316:     result = grouped.agg(aggfun_0)
  317:     foosum = (df.A == "foo").sum()
  318:     barsum = (df.A == "bar").sum()
  319:     K = len(result.columns)
  320: 
  321:     # GH5782
  322:     exp = Series(np.array([foosum] * K), index=list("BCD"), name="foo")
  323:     tm.assert_series_equal(result.xs("foo"), exp)
  324: 
  325:     exp = Series(np.array([barsum] * K), index=list("BCD"), name="bar")
  326:     tm.assert_almost_equal(result.xs("bar"), exp)
  327: 
  328:     def aggfun_1(ser):
  329:         return ser.size
  330: 
  331:     result = DataFrame().groupby(df.A).agg(aggfun_1)
  332:     assert isinstance(result, DataFrame)
  333:     assert len(result) == 0
  334: 
  335: 
  336: def test_wrap_agg_out(three_group):
  337:     grouped = three_group.groupby(["A", "B"])
  338: 
  339:     def func(ser):
  340:         if ser.dtype == object:
  341:             raise TypeError("Test error message")
  342:         return ser.sum()
  343: 
  344:     with pytest.raises(TypeError, match="Test error message"):
  345:         grouped.aggregate(func)
  346:     result = grouped[["D", "E", "F"]].aggregate(func)
  347:     exp_grouped = three_group.loc[:, ["A", "B", "D", "E", "F"]]
  348:     expected = exp_grouped.groupby(["A", "B"]).aggregate(func)
  349:     tm.assert_frame_equal(result, expected)
  350: 
  351: 
  352: def test_agg_multiple_functions_maintain_order(df):
  353:     # GH #610
  354:     funcs = [("mean", np.mean), ("max", np.max), ("min", np.min)]
  355:     msg = "is currently using SeriesGroupBy.mean"
  356:     with tm.assert_produces_warning(FutureWarning, match=msg):
  357:         result = df.groupby("A")["C"].agg(funcs)
  358:     exp_cols = Index(["mean", "max", "min"])
  359: 
  360:     tm.assert_index_equal(result.columns, exp_cols)
  361: 
  362: 
  363: def test_series_index_name(df):
  364:     grouped = df.loc[:, ["C"]].groupby(df["A"])
  365:     result = grouped.agg(lambda x: x.mean())
  366:     assert result.index.name == "A"
  367: 
  368: 
  369: def test_agg_multiple_functions_same_name():
  370:     # GH 30880
  371:     df = DataFrame(
  372:         np.random.default_rng(2).standard_normal((1000, 3)),
  373:         index=pd.date_range("1/1/2012", freq="s", periods=1000),
  374:         columns=["A", "B", "C"],
  375:     )
  376:     result = df.resample("3min").agg(
  377:         {"A": [partial(np.quantile, q=0.9999), partial(np.quantile, q=0.1111)]}
  378:     )
  379:     expected_index = pd.date_range("1/1/2012", freq="3min", periods=6)
  380:     expected_columns = MultiIndex.from_tuples([("A", "quantile"), ("A", "quantile")])
  381:     expected_values = np.array(
  382:         [df.resample("3min").A.quantile(q=q).values for q in [0.9999, 0.1111]]
  383:     ).T
  384:     expected = DataFrame(
  385:         expected_values, columns=expected_columns, index=expected_index
  386:     )
  387:     tm.assert_frame_equal(result, expected)
  388: 
  389: 
  390: def test_agg_multiple_functions_same_name_with_ohlc_present():
  391:     # GH 30880
  392:     # ohlc expands dimensions, so different test to the above is required.
  393:     df = DataFrame(
  394:         np.random.default_rng(2).standard_normal((1000, 3)),
  395:         index=pd.date_range("1/1/2012", freq="s", periods=1000, name="dti"),
  396:         columns=Index(["A", "B", "C"], name="alpha"),
  397:     )
  398:     result = df.resample("3min").agg(
  399:         {"A": ["ohlc", partial(np.quantile, q=0.9999), partial(np.quantile, q=0.1111)]}
  400:     )
  401:     expected_index = pd.date_range("1/1/2012", freq="3min", periods=6, name="dti")
  402:     expected_columns = MultiIndex.from_tuples(
  403:         [
  404:             ("A", "ohlc", "open"),
  405:             ("A", "ohlc", "high"),
  406:             ("A", "ohlc", "low"),
  407:             ("A", "ohlc", "close"),
  408:             ("A", "quantile", "A"),
  409:             ("A", "quantile", "A"),
  410:         ],
  411:         names=["alpha", None, None],
  412:     )
  413:     non_ohlc_expected_values = np.array(
  414:         [df.resample("3min").A.quantile(q=q).values for q in [0.9999, 0.1111]]
  415:     ).T
  416:     expected_values = np.hstack(
  417:         [df.resample("3min").A.ohlc(), non_ohlc_expected_values]
  418:     )
  419:     expected = DataFrame(
  420:         expected_values, columns=expected_columns, index=expected_index
  421:     )
  422:     tm.assert_frame_equal(result, expected)
  423: 
  424: 
  425: def test_multiple_functions_tuples_and_non_tuples(df):
  426:     # #1359
  427:     # Columns B and C would cause partial failure
  428:     df = df.drop(columns=["B", "C"])
  429: 
  430:     funcs = [("foo", "mean"), "std"]
  431:     ex_funcs = [("foo", "mean"), ("std", "std")]
  432: 
  433:     result = df.groupby("A")["D"].agg(funcs)
  434:     expected = df.groupby("A")["D"].agg(ex_funcs)
  435:     tm.assert_frame_equal(result, expected)
  436: 
  437:     result = df.groupby("A").agg(funcs)
  438:     expected = df.groupby("A").agg(ex_funcs)
  439:     tm.assert_frame_equal(result, expected)
  440: 
  441: 
  442: def test_more_flexible_frame_multi_function(df):
  443:     grouped = df.groupby("A")
  444: 
  445:     exmean = grouped.agg({"C": "mean", "D": "mean"})
  446:     exstd = grouped.agg({"C": "std", "D": "std"})
  447: 
  448:     expected = concat([exmean, exstd], keys=["mean", "std"], axis=1)
  449:     expected = expected.swaplevel(0, 1, axis=1).sort_index(level=0, axis=1)
  450: 
  451:     d = {"C": ["mean", "std"], "D": ["mean", "std"]}
  452:     result = grouped.aggregate(d)
  453: 
  454:     tm.assert_frame_equal(result, expected)
  455: 
  456:     # be careful
  457:     result = grouped.aggregate({"C": "mean", "D": ["mean", "std"]})
  458:     expected = grouped.aggregate({"C": "mean", "D": ["mean", "std"]})
  459:     tm.assert_frame_equal(result, expected)
  460: 
  461:     def numpymean(x):
  462:         return np.mean(x)
  463: 
  464:     def numpystd(x):
  465:         return np.std(x, ddof=1)
  466: 
  467:     # this uses column selection & renaming
  468:     msg = r"nested renamer is not supported"
  469:     with pytest.raises(SpecificationError, match=msg):
  470:         d = {"C": "mean", "D": {"foo": "mean", "bar": "std"}}
  471:         grouped.aggregate(d)
  472: 
  473:     # But without renaming, these functions are OK
  474:     d = {"C": ["mean"], "D": [numpymean, numpystd]}
  475:     grouped.aggregate(d)
  476: 
  477: 
  478: def test_multi_function_flexible_mix(df):
  479:     # GH #1268
  480:     grouped = df.groupby("A")
  481: 
  482:     # Expected
  483:     d = {"C": {"foo": "mean", "bar": "std"}, "D": {"sum": "sum"}}
  484:     # this uses column selection & renaming
  485:     msg = r"nested renamer is not supported"
  486:     with pytest.raises(SpecificationError, match=msg):
  487:         grouped.aggregate(d)
  488: 
  489:     # Test 1
  490:     d = {"C": {"foo": "mean", "bar": "std"}, "D": "sum"}
  491:     # this uses column selection & renaming
  492:     with pytest.raises(SpecificationError, match=msg):
  493:         grouped.aggregate(d)
  494: 
  495:     # Test 2
  496:     d = {"C": {"foo": "mean", "bar": "std"}, "D": "sum"}
  497:     # this uses column selection & renaming
  498:     with pytest.raises(SpecificationError, match=msg):
  499:         grouped.aggregate(d)
  500: 
  501: 
  502: def test_groupby_agg_coercing_bools():
  503:     # issue 14873
  504:     dat = DataFrame({"a": [1, 1, 2, 2], "b": [0, 1, 2, 3], "c": [None, None, 1, 1]})
  505:     gp = dat.groupby("a")
  506: 
  507:     index = Index([1, 2], name="a")
  508: 
  509:     result = gp["b"].aggregate(lambda x: (x != 0).all())
  510:     expected = Series([False, True], index=index, name="b")
  511:     tm.assert_series_equal(result, expected)
  512: 
  513:     result = gp["c"].aggregate(lambda x: x.isnull().all())
  514:     expected = Series([True, False], index=index, name="c")
  515:     tm.assert_series_equal(result, expected)
  516: 
  517: 
  518: def test_groupby_agg_dict_with_getitem():
  519:     # issue 25471
  520:     dat = DataFrame({"A": ["A", "A", "B", "B", "B"], "B": [1, 2, 1, 1, 2]})
  521:     result = dat.groupby("A")[["B"]].agg({"B": "sum"})
  522: 
  523:     expected = DataFrame({"B": [3, 4]}, index=["A", "B"]).rename_axis("A", axis=0)
  524: 
  525:     tm.assert_frame_equal(result, expected)
  526: 
  527: 
  528: def test_groupby_agg_dict_dup_columns():
  529:     # GH#55006
  530:     df = DataFrame(
  531:         [[1, 2, 3, 4], [1, 3, 4, 5], [2, 4, 5, 6]],
  532:         columns=["a", "b", "c", "c"],
  533:     )
  534:     gb = df.groupby("a")
  535:     result = gb.agg({"b": "sum"})
  536:     expected = DataFrame({"b": [5, 4]}, index=Index([1, 2], name="a"))
  537:     tm.assert_frame_equal(result, expected)
  538: 
  539: 
  540: @pytest.mark.parametrize(
  541:     "op",
  542:     [
  543:         lambda x: x.sum(),
  544:         lambda x: x.cumsum(),
  545:         lambda x: x.transform("sum"),
  546:         lambda x: x.transform("cumsum"),
  547:         lambda x: x.agg("sum"),
  548:         lambda x: x.agg("cumsum"),
  549:     ],
  550: )
  551: def test_bool_agg_dtype(op):
  552:     # GH 7001
  553:     # Bool sum aggregations result in int
  554:     df = DataFrame({"a": [1, 1], "b": [False, True]})
  555:     s = df.set_index("a")["b"]
  556: 
  557:     result = op(df.groupby("a"))["b"].dtype
  558:     assert is_integer_dtype(result)
  559: 
  560:     result = op(s.groupby("a")).dtype
  561:     assert is_integer_dtype(result)
  562: 
  563: 
  564: @pytest.mark.parametrize(
  565:     "keys, agg_index",
  566:     [
  567:         (["a"], Index([1], name="a")),
  568:         (["a", "b"], MultiIndex([[1], [2]], [[0], [0]], names=["a", "b"])),
  569:     ],
  570: )
  571: @pytest.mark.parametrize(
  572:     "input_dtype", ["bool", "int32", "int64", "float32", "float64"]
  573: )
  574: @pytest.mark.parametrize(
  575:     "result_dtype", ["bool", "int32", "int64", "float32", "float64"]
  576: )
  577: @pytest.mark.parametrize("method", ["apply", "aggregate", "transform"])
  578: def test_callable_result_dtype_frame(
  579:     keys, agg_index, input_dtype, result_dtype, method
  580: ):
  581:     # GH 21240
  582:     df = DataFrame({"a": [1], "b": [2], "c": [True]})
  583:     df["c"] = df["c"].astype(input_dtype)
  584:     op = getattr(df.groupby(keys)[["c"]], method)
  585:     result = op(lambda x: x.astype(result_dtype).iloc[0])
  586:     expected_index = pd.RangeIndex(0, 1) if method == "transform" else agg_index
  587:     expected = DataFrame({"c": [df["c"].iloc[0]]}, index=expected_index).astype(
  588:         result_dtype
  589:     )
  590:     if method == "apply":
  591:         expected.columns.names = [0]
  592:     tm.assert_frame_equal(result, expected)
  593: 
  594: 
  595: @pytest.mark.parametrize(
  596:     "keys, agg_index",
  597:     [
  598:         (["a"], Index([1], name="a")),
  599:         (["a", "b"], MultiIndex([[1], [2]], [[0], [0]], names=["a", "b"])),
  600:     ],
  601: )
  602: @pytest.mark.parametrize("input", [True, 1, 1.0])
  603: @pytest.mark.parametrize("dtype", [bool, int, float])
  604: @pytest.mark.parametrize("method", ["apply", "aggregate", "transform"])
  605: def test_callable_result_dtype_series(keys, agg_index, input, dtype, method):
  606:     # GH 21240
  607:     df = DataFrame({"a": [1], "b": [2], "c": [input]})
  608:     op = getattr(df.groupby(keys)["c"], method)
  609:     result = op(lambda x: x.astype(dtype).iloc[0])
  610:     expected_index = pd.RangeIndex(0, 1) if method == "transform" else agg_index
  611:     expected = Series([df["c"].iloc[0]], index=expected_index, name="c").astype(dtype)
  612:     tm.assert_series_equal(result, expected)
  613: 
  614: 
  615: def test_order_aggregate_multiple_funcs():
  616:     # GH 25692
  617:     df = DataFrame({"A": [1, 1, 2, 2], "B": [1, 2, 3, 4]})
  618: 
  619:     res = df.groupby("A").agg(["sum", "max", "mean", "ohlc", "min"])
  620:     result = res.columns.levels[1]
  621: 
  622:     expected = Index(["sum", "max", "mean", "ohlc", "min"])
  623: 
  624:     tm.assert_index_equal(result, expected)
  625: 
  626: 
  627: def test_ohlc_ea_dtypes(any_numeric_ea_dtype):
  628:     # GH#37493
  629:     df = DataFrame(
  630:         {"a": [1, 1, 2, 3, 4, 4], "b": [22, 11, pd.NA, 10, 20, pd.NA]},
  631:         dtype=any_numeric_ea_dtype,
  632:     )
  633:     gb = df.groupby("a")
  634:     result = gb.ohlc()
  635:     expected = DataFrame(
  636:         [[22, 22, 11, 11], [pd.NA] * 4, [10] * 4, [20] * 4],
  637:         columns=MultiIndex.from_product([["b"], ["open", "high", "low", "close"]]),
  638:         index=Index([1, 2, 3, 4], dtype=any_numeric_ea_dtype, name="a"),
  639:         dtype=any_numeric_ea_dtype,
  640:     )
  641:     tm.assert_frame_equal(result, expected)
  642: 
  643:     gb2 = df.groupby("a", as_index=False)
  644:     result2 = gb2.ohlc()
  645:     expected2 = expected.reset_index()
  646:     tm.assert_frame_equal(result2, expected2)
  647: 
  648: 
  649: @pytest.mark.parametrize("dtype", [np.int64, np.uint64])
  650: @pytest.mark.parametrize("how", ["first", "last", "min", "max", "mean", "median"])
  651: def test_uint64_type_handling(dtype, how):
  652:     # GH 26310
  653:     df = DataFrame({"x": 6903052872240755750, "y": [1, 2]})
  654:     expected = df.groupby("y").agg({"x": how})
  655:     df.x = df.x.astype(dtype)
  656:     result = df.groupby("y").agg({"x": how})
  657:     if how not in ("mean", "median"):
  658:         # mean and median always result in floats
  659:         result.x = result.x.astype(np.int64)
  660:     tm.assert_frame_equal(result, expected, check_exact=True)
  661: 
  662: 
  663: def test_func_duplicates_raises():
  664:     # GH28426
  665:     msg = "Function names"
  666:     df = DataFrame({"A": [0, 0, 1, 1], "B": [1, 2, 3, 4]})
  667:     with pytest.raises(SpecificationError, match=msg):
  668:         df.groupby("A").agg(["min", "min"])
  669: 
  670: 
  671: @pytest.mark.parametrize(
  672:     "index",
  673:     [
  674:         pd.CategoricalIndex(list("abc")),
  675:         pd.interval_range(0, 3),
  676:         pd.period_range("2020", periods=3, freq="D"),
  677:         MultiIndex.from_tuples([("a", 0), ("a", 1), ("b", 0)]),
  678:     ],
  679: )
  680: def test_agg_index_has_complex_internals(index):
  681:     # GH 31223
  682:     df = DataFrame({"group": [1, 1, 2], "value": [0, 1, 0]}, index=index)
  683:     result = df.groupby("group").agg({"value": Series.nunique})
  684:     expected = DataFrame({"group": [1, 2], "value": [2, 1]}).set_index("group")
  685:     tm.assert_frame_equal(result, expected)
  686: 
  687: 
  688: def test_agg_split_block():
  689:     # https://github.com/pandas-dev/pandas/issues/31522
  690:     df = DataFrame(
  691:         {
  692:             "key1": ["a", "a", "b", "b", "a"],
  693:             "key2": ["one", "two", "one", "two", "one"],
  694:             "key3": ["three", "three", "three", "six", "six"],
  695:         }
  696:     )
  697:     result = df.groupby("key1").min()
  698:     expected = DataFrame(
  699:         {"key2": ["one", "one"], "key3": ["six", "six"]},
  700:         index=Index(["a", "b"], name="key1"),
  701:     )
  702:     tm.assert_frame_equal(result, expected)
  703: 
  704: 
  705: def test_agg_split_object_part_datetime():
  706:     # https://github.com/pandas-dev/pandas/pull/31616
  707:     df = DataFrame(
  708:         {
  709:             "A": pd.date_range("2000", periods=4),
  710:             "B": ["a", "b", "c", "d"],
  711:             "C": [1, 2, 3, 4],
  712:             "D": ["b", "c", "d", "e"],
  713:             "E": pd.date_range("2000", periods=4),
  714:             "F": [1, 2, 3, 4],
  715:         }
  716:     ).astype(object)
  717:     result = df.groupby([0, 0, 0, 0]).min()
  718:     expected = DataFrame(
  719:         {
  720:             "A": [pd.Timestamp("2000")],
  721:             "B": ["a"],
  722:             "C": [1],
  723:             "D": ["b"],
  724:             "E": [pd.Timestamp("2000")],
  725:             "F": [1],
  726:         },
  727:         index=np.array([0]),
  728:         dtype=object,
  729:     )
  730:     tm.assert_frame_equal(result, expected)
  731: 
  732: 
  733: class TestNamedAggregationSeries:
  734:     def test_series_named_agg(self):
  735:         df = Series([1, 2, 3, 4])
  736:         gr = df.groupby([0, 0, 1, 1])
  737:         result = gr.agg(a="sum", b="min")
  738:         expected = DataFrame(
  739:             {"a": [3, 7], "b": [1, 3]}, columns=["a", "b"], index=np.array([0, 1])
  740:         )
  741:         tm.assert_frame_equal(result, expected)
  742: 
  743:         result = gr.agg(b="min", a="sum")
  744:         expected = expected[["b", "a"]]
  745:         tm.assert_frame_equal(result, expected)
  746: 
  747:     def test_no_args_raises(self):
  748:         gr = Series([1, 2]).groupby([0, 1])
  749:         with pytest.raises(TypeError, match="Must provide"):
  750:             gr.agg()
  751: 
  752:         # but we do allow this
  753:         result = gr.agg([])
  754:         expected = DataFrame(columns=[])
  755:         tm.assert_frame_equal(result, expected)
  756: 
  757:     def test_series_named_agg_duplicates_no_raises(self):
  758:         # GH28426
  759:         gr = Series([1, 2, 3]).groupby([0, 0, 1])
  760:         grouped = gr.agg(a="sum", b="sum")
  761:         expected = DataFrame({"a": [3, 3], "b": [3, 3]}, index=np.array([0, 1]))
  762:         tm.assert_frame_equal(expected, grouped)
  763: 
  764:     def test_mangled(self):
  765:         gr = Series([1, 2, 3]).groupby([0, 0, 1])
  766:         result = gr.agg(a=lambda x: 0, b=lambda x: 1)
  767:         expected = DataFrame({"a": [0, 0], "b": [1, 1]}, index=np.array([0, 1]))
  768:         tm.assert_frame_equal(result, expected)
  769: 
  770:     @pytest.mark.parametrize(
  771:         "inp",
  772:         [
  773:             pd.NamedAgg(column="anything", aggfunc="min"),
  774:             ("anything", "min"),
  775:             ["anything", "min"],
  776:         ],
  777:     )
  778:     def test_named_agg_nametuple(self, inp):
  779:         # GH34422
  780:         s = Series([1, 1, 2, 2, 3, 3, 4, 5])
  781:         msg = f"func is expected but received {type(inp).__name__}"
  782:         with pytest.raises(TypeError, match=msg):
  783:             s.groupby(s.values).agg(a=inp)
  784: 
  785: 
  786: class TestNamedAggregationDataFrame:
  787:     def test_agg_relabel(self):
  788:         df = DataFrame(
  789:             {"group": ["a", "a", "b", "b"], "A": [0, 1, 2, 3], "B": [5, 6, 7, 8]}
  790:         )
  791:         result = df.groupby("group").agg(a_max=("A", "max"), b_max=("B", "max"))
  792:         expected = DataFrame(
  793:             {"a_max": [1, 3], "b_max": [6, 8]},
  794:             index=Index(["a", "b"], name="group"),
  795:             columns=["a_max", "b_max"],
  796:         )
  797:         tm.assert_frame_equal(result, expected)
  798: 
  799:         # order invariance
  800:         p98 = functools.partial(np.percentile, q=98)
  801:         result = df.groupby("group").agg(
  802:             b_min=("B", "min"),
  803:             a_min=("A", "min"),
  804:             a_mean=("A", "mean"),
  805:             a_max=("A", "max"),
  806:             b_max=("B", "max"),
  807:             a_98=("A", p98),
  808:         )
  809:         expected = DataFrame(
  810:             {
  811:                 "b_min": [5, 7],
  812:                 "a_min": [0, 2],
  813:                 "a_mean": [0.5, 2.5],
  814:                 "a_max": [1, 3],
  815:                 "b_max": [6, 8],
  816:                 "a_98": [0.98, 2.98],
  817:             },
  818:             index=Index(["a", "b"], name="group"),
  819:             columns=["b_min", "a_min", "a_mean", "a_max", "b_max", "a_98"],
  820:         )
  821:         tm.assert_frame_equal(result, expected)
  822: 
  823:     def test_agg_relabel_non_identifier(self):
  824:         df = DataFrame(
  825:             {"group": ["a", "a", "b", "b"], "A": [0, 1, 2, 3], "B": [5, 6, 7, 8]}
  826:         )
  827: 
  828:         result = df.groupby("group").agg(**{"my col": ("A", "max")})
  829:         expected = DataFrame({"my col": [1, 3]}, index=Index(["a", "b"], name="group"))
  830:         tm.assert_frame_equal(result, expected)
  831: 
  832:     def test_duplicate_no_raises(self):
  833:         # GH 28426, if use same input function on same column,
  834:         # no error should raise
  835:         df = DataFrame({"A": [0, 0, 1, 1], "B": [1, 2, 3, 4]})
  836: 
  837:         grouped = df.groupby("A").agg(a=("B", "min"), b=("B", "min"))
  838:         expected = DataFrame({"a": [1, 3], "b": [1, 3]}, index=Index([0, 1], name="A"))
  839:         tm.assert_frame_equal(grouped, expected)
  840: 
  841:         quant50 = functools.partial(np.percentile, q=50)
  842:         quant70 = functools.partial(np.percentile, q=70)
  843:         quant50.__name__ = "quant50"
  844:         quant70.__name__ = "quant70"
  845: 
  846:         test = DataFrame({"col1": ["a", "a", "b", "b", "b"], "col2": [1, 2, 3, 4, 5]})
  847: 
  848:         grouped = test.groupby("col1").agg(
  849:             quantile_50=("col2", quant50), quantile_70=("col2", quant70)
  850:         )
  851:         expected = DataFrame(
  852:             {"quantile_50": [1.5, 4.0], "quantile_70": [1.7, 4.4]},
  853:             index=Index(["a", "b"], name="col1"),
  854:         )
  855:         tm.assert_frame_equal(grouped, expected)
  856: 
  857:     def test_agg_relabel_with_level(self):
  858:         df = DataFrame(
  859:             {"A": [0, 0, 1, 1], "B": [1, 2, 3, 4]},
  860:             index=MultiIndex.from_product([["A", "B"], ["a", "b"]]),
  861:         )
  862:         result = df.groupby(level=0).agg(
  863:             aa=("A", "max"), bb=("A", "min"), cc=("B", "mean")
  864:         )
  865:         expected = DataFrame(
  866:             {"aa": [0, 1], "bb": [0, 1], "cc": [1.5, 3.5]}, index=["A", "B"]
  867:         )
  868:         tm.assert_frame_equal(result, expected)
  869: 
  870:     def test_agg_relabel_other_raises(self):
  871:         df = DataFrame({"A": [0, 0, 1], "B": [1, 2, 3]})
  872:         grouped = df.groupby("A")
  873:         match = "Must provide"
  874:         with pytest.raises(TypeError, match=match):
  875:             grouped.agg(foo=1)
  876: 
  877:         with pytest.raises(TypeError, match=match):
  878:             grouped.agg()
  879: 
  880:         with pytest.raises(TypeError, match=match):
  881:             grouped.agg(a=("B", "max"), b=(1, 2, 3))
  882: 
  883:     def test_missing_raises(self):
  884:         df = DataFrame({"A": [0, 1], "B": [1, 2]})
  885:         match = re.escape("Column(s) ['C'] do not exist")
  886:         with pytest.raises(KeyError, match=match):
  887:             df.groupby("A").agg(c=("C", "sum"))
  888: 
  889:     def test_agg_namedtuple(self):
  890:         df = DataFrame({"A": [0, 1], "B": [1, 2]})
  891:         result = df.groupby("A").agg(
  892:             b=pd.NamedAgg("B", "sum"), c=pd.NamedAgg(column="B", aggfunc="count")
  893:         )
  894:         expected = df.groupby("A").agg(b=("B", "sum"), c=("B", "count"))
  895:         tm.assert_frame_equal(result, expected)
  896: 
  897:     def test_mangled(self):
  898:         df = DataFrame({"A": [0, 1], "B": [1, 2], "C": [3, 4]})
  899:         result = df.groupby("A").agg(b=("B", lambda x: 0), c=("C", lambda x: 1))
  900:         expected = DataFrame({"b": [0, 0], "c": [1, 1]}, index=Index([0, 1], name="A"))
  901:         tm.assert_frame_equal(result, expected)
  902: 
  903: 
  904: @pytest.mark.parametrize(
  905:     "agg_col1, agg_col2, agg_col3, agg_result1, agg_result2, agg_result3",
  906:     [
  907:         (
  908:             (("y", "A"), "max"),
  909:             (("y", "A"), np.mean),
  910:             (("y", "B"), "mean"),
  911:             [1, 3],
  912:             [0.5, 2.5],
  913:             [5.5, 7.5],
  914:         ),
  915:         (
  916:             (("y", "A"), lambda x: max(x)),
  917:             (("y", "A"), lambda x: 1),
  918:             (("y", "B"), np.mean),
  919:             [1, 3],
  920:             [1, 1],
  921:             [5.5, 7.5],
  922:         ),
  923:         (
  924:             pd.NamedAgg(("y", "A"), "max"),
  925:             pd.NamedAgg(("y", "B"), np.mean),
  926:             pd.NamedAgg(("y", "A"), lambda x: 1),
  927:             [1, 3],
  928:             [5.5, 7.5],
  929:             [1, 1],
  930:         ),
  931:     ],
  932: )
  933: def test_agg_relabel_multiindex_column(
  934:     agg_col1, agg_col2, agg_col3, agg_result1, agg_result2, agg_result3
  935: ):
  936:     # GH 29422, add tests for multiindex column cases
  937:     df = DataFrame(
  938:         {"group": ["a", "a", "b", "b"], "A": [0, 1, 2, 3], "B": [5, 6, 7, 8]}
  939:     )
  940:     df.columns = MultiIndex.from_tuples([("x", "group"), ("y", "A"), ("y", "B")])
  941:     idx = Index(["a", "b"], name=("x", "group"))
  942: 
  943:     result = df.groupby(("x", "group")).agg(a_max=(("y", "A"), "max"))
  944:     expected = DataFrame({"a_max": [1, 3]}, index=idx)
  945:     tm.assert_frame_equal(result, expected)
  946: 
  947:     msg = "is currently using SeriesGroupBy.mean"
  948:     with tm.assert_produces_warning(FutureWarning, match=msg):
  949:         result = df.groupby(("x", "group")).agg(
  950:             col_1=agg_col1, col_2=agg_col2, col_3=agg_col3
  951:         )
  952:     expected = DataFrame(
  953:         {"col_1": agg_result1, "col_2": agg_result2, "col_3": agg_result3}, index=idx
  954:     )
  955:     tm.assert_frame_equal(result, expected)
  956: 
  957: 
  958: def test_agg_relabel_multiindex_raises_not_exist():
  959:     # GH 29422, add test for raises scenario when aggregate column does not exist
  960:     df = DataFrame(
  961:         {"group": ["a", "a", "b", "b"], "A": [0, 1, 2, 3], "B": [5, 6, 7, 8]}
  962:     )
  963:     df.columns = MultiIndex.from_tuples([("x", "group"), ("y", "A"), ("y", "B")])
  964: 
  965:     with pytest.raises(KeyError, match="do not exist"):
  966:         df.groupby(("x", "group")).agg(a=(("Y", "a"), "max"))
  967: 
  968: 
  969: def test_agg_relabel_multiindex_duplicates():
  970:     # GH29422, add test for raises scenario when getting duplicates
  971:     # GH28426, after this change, duplicates should also work if the relabelling is
  972:     # different
  973:     df = DataFrame(
  974:         {"group": ["a", "a", "b", "b"], "A": [0, 1, 2, 3], "B": [5, 6, 7, 8]}
  975:     )
  976:     df.columns = MultiIndex.from_tuples([("x", "group"), ("y", "A"), ("y", "B")])
  977: 
  978:     result = df.groupby(("x", "group")).agg(
  979:         a=(("y", "A"), "min"), b=(("y", "A"), "min")
  980:     )
  981:     idx = Index(["a", "b"], name=("x", "group"))
  982:     expected = DataFrame({"a": [0, 2], "b": [0, 2]}, index=idx)
  983:     tm.assert_frame_equal(result, expected)
  984: 
  985: 
  986: @pytest.mark.parametrize("kwargs", [{"c": ["min"]}, {"b": [], "c": ["min"]}])
  987: def test_groupby_aggregate_empty_key(kwargs):
  988:     # GH: 32580
  989:     df = DataFrame({"a": [1, 1, 2], "b": [1, 2, 3], "c": [1, 2, 4]})
  990:     result = df.groupby("a").agg(kwargs)
  991:     expected = DataFrame(
  992:         [1, 4],
  993:         index=Index([1, 2], dtype="int64", name="a"),
  994:         columns=MultiIndex.from_tuples([["c", "min"]]),
  995:     )
  996:     tm.assert_frame_equal(result, expected)
  997: 
  998: 
  999: def test_groupby_aggregate_empty_key_empty_return():
 1000:     # GH: 32580 Check if everything works, when return is empty
 1001:     df = DataFrame({"a": [1, 1, 2], "b": [1, 2, 3], "c": [1, 2, 4]})
 1002:     result = df.groupby("a").agg({"b": []})
 1003:     expected = DataFrame(columns=MultiIndex(levels=[["b"], []], codes=[[], []]))
 1004:     tm.assert_frame_equal(result, expected)
 1005: 
 1006: 
 1007: def test_groupby_aggregate_empty_with_multiindex_frame():
 1008:     # GH 39178
 1009:     df = DataFrame(columns=["a", "b", "c"])
 1010:     result = df.groupby(["a", "b"], group_keys=False).agg(d=("c", list))
 1011:     expected = DataFrame(
 1012:         columns=["d"], index=MultiIndex([[], []], [[], []], names=["a", "b"])
 1013:     )
 1014:     tm.assert_frame_equal(result, expected)
 1015: 
 1016: 
 1017: def test_grouby_agg_loses_results_with_as_index_false_relabel():
 1018:     # GH 32240: When the aggregate function relabels column names and
 1019:     # as_index=False is specified, the results are dropped.
 1020: 
 1021:     df = DataFrame(
 1022:         {"key": ["x", "y", "z", "x", "y", "z"], "val": [1.0, 0.8, 2.0, 3.0, 3.6, 0.75]}
 1023:     )
 1024: 
 1025:     grouped = df.groupby("key", as_index=False)
 1026:     result = grouped.agg(min_val=pd.NamedAgg(column="val", aggfunc="min"))
 1027:     expected = DataFrame({"key": ["x", "y", "z"], "min_val": [1.0, 0.8, 0.75]})
 1028:     tm.assert_frame_equal(result, expected)
 1029: 
 1030: 
 1031: def test_grouby_agg_loses_results_with_as_index_false_relabel_multiindex():
 1032:     # GH 32240: When the aggregate function relabels column names and
 1033:     # as_index=False is specified, the results are dropped. Check if
 1034:     # multiindex is returned in the right order
 1035: 
 1036:     df = DataFrame(
 1037:         {
 1038:             "key": ["x", "y", "x", "y", "x", "x"],
 1039:             "key1": ["a", "b", "c", "b", "a", "c"],
 1040:             "val": [1.0, 0.8, 2.0, 3.0, 3.6, 0.75],
 1041:         }
 1042:     )
 1043: 
 1044:     grouped = df.groupby(["key", "key1"], as_index=False)
 1045:     result = grouped.agg(min_val=pd.NamedAgg(column="val", aggfunc="min"))
 1046:     expected = DataFrame(
 1047:         {"key": ["x", "x", "y"], "key1": ["a", "c", "b"], "min_val": [1.0, 0.75, 0.8]}
 1048:     )
 1049:     tm.assert_frame_equal(result, expected)
 1050: 
 1051: 
 1052: @pytest.mark.parametrize(
 1053:     "func", [lambda s: s.mean(), lambda s: np.mean(s), lambda s: np.nanmean(s)]
 1054: )
 1055: def test_multiindex_custom_func(func):
 1056:     # GH 31777
 1057:     data = [[1, 4, 2], [5, 7, 1]]
 1058:     df = DataFrame(
 1059:         data,
 1060:         columns=MultiIndex.from_arrays(
 1061:             [[1, 1, 2], [3, 4, 3]], names=["Sisko", "Janeway"]
 1062:         ),
 1063:     )
 1064:     result = df.groupby(np.array([0, 1])).agg(func)
 1065:     expected_dict = {
 1066:         (1, 3): {0: 1.0, 1: 5.0},
 1067:         (1, 4): {0: 4.0, 1: 7.0},
 1068:         (2, 3): {0: 2.0, 1: 1.0},
 1069:     }
 1070:     expected = DataFrame(expected_dict, index=np.array([0, 1]), columns=df.columns)
 1071:     tm.assert_frame_equal(result, expected)
 1072: 
 1073: 
 1074: def myfunc(s):
 1075:     return np.percentile(s, q=0.90)
 1076: 
 1077: 
 1078: @pytest.mark.parametrize("func", [lambda s: np.percentile(s, q=0.90), myfunc])
 1079: def test_lambda_named_agg(func):
 1080:     # see gh-28467
 1081:     animals = DataFrame(
 1082:         {
 1083:             "kind": ["cat", "dog", "cat", "dog"],
 1084:             "height": [9.1, 6.0, 9.5, 34.0],
 1085:             "weight": [7.9, 7.5, 9.9, 198.0],
 1086:         }
 1087:     )
 1088: 
 1089:     result = animals.groupby("kind").agg(
 1090:         mean_height=("height", "mean"), perc90=("height", func)
 1091:     )
 1092:     expected = DataFrame(
 1093:         [[9.3, 9.1036], [20.0, 6.252]],
 1094:         columns=["mean_height", "perc90"],
 1095:         index=Index(["cat", "dog"], name="kind"),
 1096:     )
 1097: 
 1098:     tm.assert_frame_equal(result, expected)
 1099: 
 1100: 
 1101: def test_aggregate_mixed_types():
 1102:     # GH 16916
 1103:     df = DataFrame(
 1104:         data=np.array([0] * 9).reshape(3, 3), columns=list("XYZ"), index=list("abc")
 1105:     )
 1106:     df["grouping"] = ["group 1", "group 1", 2]
 1107:     result = df.groupby("grouping").aggregate(lambda x: x.tolist())
 1108:     expected_data = [[[0], [0], [0]], [[0, 0], [0, 0], [0, 0]]]
 1109:     expected = DataFrame(
 1110:         expected_data,
 1111:         index=Index([2, "group 1"], dtype="object", name="grouping"),
 1112:         columns=Index(["X", "Y", "Z"], dtype="object"),
 1113:     )
 1114:     tm.assert_frame_equal(result, expected)
 1115: 
 1116: 
 1117: @pytest.mark.xfail(reason="Not implemented;see GH 31256")
 1118: def test_aggregate_udf_na_extension_type():
 1119:     # https://github.com/pandas-dev/pandas/pull/31359
 1120:     # This is currently failing to cast back to Int64Dtype.
 1121:     # The presence of the NA causes two problems
 1122:     # 1. NA is not an instance of Int64Dtype.type (numpy.int64)
 1123:     # 2. The presence of an NA forces object type, so the non-NA values is
 1124:     #    a Python int rather than a NumPy int64. Python ints aren't
 1125:     #    instances of numpy.int64.
 1126:     def aggfunc(x):
 1127:         if all(x > 2):
 1128:             return 1
 1129:         else:
 1130:             return pd.NA
 1131: 
 1132:     df = DataFrame({"A": pd.array([1, 2, 3])})
 1133:     result = df.groupby([1, 1, 2]).agg(aggfunc)
 1134:     expected = DataFrame({"A": pd.array([1, pd.NA], dtype="Int64")}, index=[1, 2])
 1135:     tm.assert_frame_equal(result, expected)
 1136: 
 1137: 
 1138: class TestLambdaMangling:
 1139:     def test_basic(self):
 1140:         df = DataFrame({"A": [0, 0, 1, 1], "B": [1, 2, 3, 4]})
 1141:         result = df.groupby("A").agg({"B": [lambda x: 0, lambda x: 1]})
 1142: 
 1143:         expected = DataFrame(
 1144:             {("B", "<lambda_0>"): [0, 0], ("B", "<lambda_1>"): [1, 1]},
 1145:             index=Index([0, 1], name="A"),
 1146:         )
 1147:         tm.assert_frame_equal(result, expected)
 1148: 
 1149:     def test_mangle_series_groupby(self):
 1150:         gr = Series([1, 2, 3, 4]).groupby([0, 0, 1, 1])
 1151:         result = gr.agg([lambda x: 0, lambda x: 1])
 1152:         exp_data = {"<lambda_0>": [0, 0], "<lambda_1>": [1, 1]}
 1153:         expected = DataFrame(exp_data, index=np.array([0, 1]))
 1154:         tm.assert_frame_equal(result, expected)
 1155: 
 1156:     @pytest.mark.xfail(reason="GH-26611. kwargs for multi-agg.")
 1157:     def test_with_kwargs(self):
 1158:         f1 = lambda x, y, b=1: x.sum() + y + b
 1159:         f2 = lambda x, y, b=2: x.sum() + y * b
 1160:         result = Series([1, 2]).groupby([0, 0]).agg([f1, f2], 0)
 1161:         expected = DataFrame({"<lambda_0>": [4], "<lambda_1>": [6]})
 1162:         tm.assert_frame_equal(result, expected)
 1163: 
 1164:         result = Series([1, 2]).groupby([0, 0]).agg([f1, f2], 0, b=10)
 1165:         expected = DataFrame({"<lambda_0>": [13], "<lambda_1>": [30]})
 1166:         tm.assert_frame_equal(result, expected)
 1167: 
 1168:     def test_agg_with_one_lambda(self):
 1169:         # GH 25719, write tests for DataFrameGroupby.agg with only one lambda
 1170:         df = DataFrame(
 1171:             {
 1172:                 "kind": ["cat", "dog", "cat", "dog"],
 1173:                 "height": [9.1, 6.0, 9.5, 34.0],
 1174:                 "weight": [7.9, 7.5, 9.9, 198.0],
 1175:             }
 1176:         )
 1177: 
 1178:         columns = ["height_sqr_min", "height_max", "weight_max"]
 1179:         expected = DataFrame(
 1180:             {
 1181:                 "height_sqr_min": [82.81, 36.00],
 1182:                 "height_max": [9.5, 34.0],
 1183:                 "weight_max": [9.9, 198.0],
 1184:             },
 1185:             index=Index(["cat", "dog"], name="kind"),
 1186:             columns=columns,
 1187:         )
 1188: 
 1189:         # check pd.NameAgg case
 1190:         result1 = df.groupby(by="kind").agg(
 1191:             height_sqr_min=pd.NamedAgg(
 1192:                 column="height", aggfunc=lambda x: np.min(x**2)
 1193:             ),
 1194:             height_max=pd.NamedAgg(column="height", aggfunc="max"),
 1195:             weight_max=pd.NamedAgg(column="weight", aggfunc="max"),
 1196:         )
 1197:         tm.assert_frame_equal(result1, expected)
 1198: 
 1199:         # check agg(key=(col, aggfunc)) case
 1200:         result2 = df.groupby(by="kind").agg(
 1201:             height_sqr_min=("height", lambda x: np.min(x**2)),
 1202:             height_max=("height", "max"),
 1203:             weight_max=("weight", "max"),
 1204:         )
 1205:         tm.assert_frame_equal(result2, expected)
 1206: 
 1207:     def test_agg_multiple_lambda(self):
 1208:         # GH25719, test for DataFrameGroupby.agg with multiple lambdas
 1209:         # with mixed aggfunc
 1210:         df = DataFrame(
 1211:             {
 1212:                 "kind": ["cat", "dog", "cat", "dog"],
 1213:                 "height": [9.1, 6.0, 9.5, 34.0],
 1214:                 "weight": [7.9, 7.5, 9.9, 198.0],
 1215:             }
 1216:         )
 1217:         columns = [
 1218:             "height_sqr_min",
 1219:             "height_max",
 1220:             "weight_max",
 1221:             "height_max_2",
 1222:             "weight_min",
 1223:         ]
 1224:         expected = DataFrame(
 1225:             {
 1226:                 "height_sqr_min": [82.81, 36.00],
 1227:                 "height_max": [9.5, 34.0],
 1228:                 "weight_max": [9.9, 198.0],
 1229:                 "height_max_2": [9.5, 34.0],
 1230:                 "weight_min": [7.9, 7.5],
 1231:             },
 1232:             index=Index(["cat", "dog"], name="kind"),
 1233:             columns=columns,
 1234:         )
 1235: 
 1236:         # check agg(key=(col, aggfunc)) case
 1237:         result1 = df.groupby(by="kind").agg(
 1238:             height_sqr_min=("height", lambda x: np.min(x**2)),
 1239:             height_max=("height", "max"),
 1240:             weight_max=("weight", "max"),
 1241:             height_max_2=("height", lambda x: np.max(x)),
 1242:             weight_min=("weight", lambda x: np.min(x)),
 1243:         )
 1244:         tm.assert_frame_equal(result1, expected)
 1245: 
 1246:         # check pd.NamedAgg case
 1247:         result2 = df.groupby(by="kind").agg(
 1248:             height_sqr_min=pd.NamedAgg(
 1249:                 column="height", aggfunc=lambda x: np.min(x**2)
 1250:             ),
 1251:             height_max=pd.NamedAgg(column="height", aggfunc="max"),
 1252:             weight_max=pd.NamedAgg(column="weight", aggfunc="max"),
 1253:             height_max_2=pd.NamedAgg(column="height", aggfunc=lambda x: np.max(x)),
 1254:             weight_min=pd.NamedAgg(column="weight", aggfunc=lambda x: np.min(x)),
 1255:         )
 1256:         tm.assert_frame_equal(result2, expected)
 1257: 
 1258: 
 1259: def test_groupby_get_by_index():
 1260:     # GH 33439
 1261:     df = DataFrame({"A": ["S", "W", "W"], "B": [1.0, 1.0, 2.0]})
 1262:     res = df.groupby("A").agg({"B": lambda x: x.get(x.index[-1])})
 1263:     expected = DataFrame({"A": ["S", "W"], "B": [1.0, 2.0]}).set_index("A")
 1264:     tm.assert_frame_equal(res, expected)
 1265: 
 1266: 
 1267: @pytest.mark.parametrize(
 1268:     "grp_col_dict, exp_data",
 1269:     [
 1270:         ({"nr": "min", "cat_ord": "min"}, {"nr": [1, 5], "cat_ord": ["a", "c"]}),
 1271:         ({"cat_ord": "min"}, {"cat_ord": ["a", "c"]}),
 1272:         ({"nr": "min"}, {"nr": [1, 5]}),
 1273:     ],
 1274: )
 1275: def test_groupby_single_agg_cat_cols(grp_col_dict, exp_data):
 1276:     # test single aggregations on ordered categorical cols GHGH27800
 1277: 
 1278:     # create the result dataframe
 1279:     input_df = DataFrame(
 1280:         {
 1281:             "nr": [1, 2, 3, 4, 5, 6, 7, 8],
 1282:             "cat_ord": list("aabbccdd"),
 1283:             "cat": list("aaaabbbb"),
 1284:         }
 1285:     )
 1286: 
 1287:     input_df = input_df.astype({"cat": "category", "cat_ord": "category"})
 1288:     input_df["cat_ord"] = input_df["cat_ord"].cat.as_ordered()
 1289:     result_df = input_df.groupby("cat", observed=False).agg(grp_col_dict)
 1290: 
 1291:     # create expected dataframe
 1292:     cat_index = pd.CategoricalIndex(
 1293:         ["a", "b"], categories=["a", "b"], ordered=False, name="cat", dtype="category"
 1294:     )
 1295: 
 1296:     expected_df = DataFrame(data=exp_data, index=cat_index)
 1297: 
 1298:     if "cat_ord" in expected_df:
 1299:         # ordered categorical columns should be preserved
 1300:         dtype = input_df["cat_ord"].dtype
 1301:         expected_df["cat_ord"] = expected_df["cat_ord"].astype(dtype)
 1302: 
 1303:     tm.assert_frame_equal(result_df, expected_df)
 1304: 
 1305: 
 1306: @pytest.mark.parametrize(
 1307:     "grp_col_dict, exp_data",
 1308:     [
 1309:         ({"nr": ["min", "max"], "cat_ord": "min"}, [(1, 4, "a"), (5, 8, "c")]),
 1310:         ({"nr": "min", "cat_ord": ["min", "max"]}, [(1, "a", "b"), (5, "c", "d")]),
 1311:         ({"cat_ord": ["min", "max"]}, [("a", "b"), ("c", "d")]),
 1312:     ],
 1313: )
 1314: def test_groupby_combined_aggs_cat_cols(grp_col_dict, exp_data):
 1315:     # test combined aggregations on ordered categorical cols GH27800
 1316: 
 1317:     # create the result dataframe
 1318:     input_df = DataFrame(
 1319:         {
 1320:             "nr": [1, 2, 3, 4, 5, 6, 7, 8],
 1321:             "cat_ord": list("aabbccdd"),
 1322:             "cat": list("aaaabbbb"),
 1323:         }
 1324:     )
 1325: 
 1326:     input_df = input_df.astype({"cat": "category", "cat_ord": "category"})
 1327:     input_df["cat_ord"] = input_df["cat_ord"].cat.as_ordered()
 1328:     result_df = input_df.groupby("cat", observed=False).agg(grp_col_dict)
 1329: 
 1330:     # create expected dataframe
 1331:     cat_index = pd.CategoricalIndex(
 1332:         ["a", "b"], categories=["a", "b"], ordered=False, name="cat", dtype="category"
 1333:     )
 1334: 
 1335:     # unpack the grp_col_dict to create the multi-index tuple
 1336:     # this tuple will be used to create the expected dataframe index
 1337:     multi_index_list = []
 1338:     for k, v in grp_col_dict.items():
 1339:         if isinstance(v, list):
 1340:             multi_index_list.extend([k, value] for value in v)
 1341:         else:
 1342:             multi_index_list.append([k, v])
 1343:     multi_index = MultiIndex.from_tuples(tuple(multi_index_list))
 1344: 
 1345:     expected_df = DataFrame(data=exp_data, columns=multi_index, index=cat_index)
 1346:     for col in expected_df.columns:
 1347:         if isinstance(col, tuple) and "cat_ord" in col:
 1348:             # ordered categorical should be preserved
 1349:             expected_df[col] = expected_df[col].astype(input_df["cat_ord"].dtype)
 1350: 
 1351:     tm.assert_frame_equal(result_df, expected_df)
 1352: 
 1353: 
 1354: def test_nonagg_agg():
 1355:     # GH 35490 - Single/Multiple agg of non-agg function give same results
 1356:     # TODO: agg should raise for functions that don't aggregate
 1357:     df = DataFrame({"a": [1, 1, 2, 2], "b": [1, 2, 2, 1]})
 1358:     g = df.groupby("a")
 1359: 
 1360:     result = g.agg(["cumsum"])
 1361:     result.columns = result.columns.droplevel(-1)
 1362:     expected = g.agg("cumsum")
 1363: 
 1364:     tm.assert_frame_equal(result, expected)
 1365: 
 1366: 
 1367: def test_aggregate_datetime_objects():
 1368:     # https://github.com/pandas-dev/pandas/issues/36003
 1369:     # ensure we don't raise an error but keep object dtype for out-of-bounds
 1370:     # datetimes
 1371:     df = DataFrame(
 1372:         {
 1373:             "A": ["X", "Y"],
 1374:             "B": [
 1375:                 datetime.datetime(2005, 1, 1, 10, 30, 23, 540000),
 1376:                 datetime.datetime(3005, 1, 1, 10, 30, 23, 540000),
 1377:             ],
 1378:         }
 1379:     )
 1380:     result = df.groupby("A").B.max()
 1381:     expected = df.set_index("A")["B"]
 1382:     tm.assert_series_equal(result, expected)
 1383: 
 1384: 
 1385: def test_groupby_index_object_dtype():
 1386:     # GH 40014
 1387:     df = DataFrame({"c0": ["x", "x", "x"], "c1": ["x", "x", "y"], "p": [0, 1, 2]})
 1388:     df.index = df.index.astype("O")
 1389:     grouped = df.groupby(["c0", "c1"])
 1390:     res = grouped.p.agg(lambda x: all(x > 0))
 1391:     # Check that providing a user-defined function in agg()
 1392:     # produces the correct index shape when using an object-typed index.
 1393:     expected_index = MultiIndex.from_tuples(
 1394:         [("x", "x"), ("x", "y")], names=("c0", "c1")
 1395:     )
 1396:     expected = Series([False, True], index=expected_index, name="p")
 1397:     tm.assert_series_equal(res, expected)
 1398: 
 1399: 
 1400: def test_timeseries_groupby_agg():
 1401:     # GH#43290
 1402: 
 1403:     def func(ser):
 1404:         if ser.isna().all():
 1405:             return None
 1406:         return np.sum(ser)
 1407: 
 1408:     df = DataFrame([1.0], index=[pd.Timestamp("2018-01-16 00:00:00+00:00")])
 1409:     res = df.groupby(lambda x: 1).agg(func)
 1410: 
 1411:     expected = DataFrame([[1.0]], index=[1])
 1412:     tm.assert_frame_equal(res, expected)
 1413: 
 1414: 
 1415: def test_groupby_agg_precision(any_real_numeric_dtype):
 1416:     if any_real_numeric_dtype in tm.ALL_INT_NUMPY_DTYPES:
 1417:         max_value = np.iinfo(any_real_numeric_dtype).max
 1418:     if any_real_numeric_dtype in tm.FLOAT_NUMPY_DTYPES:
 1419:         max_value = np.finfo(any_real_numeric_dtype).max
 1420:     if any_real_numeric_dtype in tm.FLOAT_EA_DTYPES:
 1421:         max_value = np.finfo(any_real_numeric_dtype.lower()).max
 1422:     if any_real_numeric_dtype in tm.ALL_INT_EA_DTYPES:
 1423:         max_value = np.iinfo(any_real_numeric_dtype.lower()).max
 1424: 
 1425:     df = DataFrame(
 1426:         {
 1427:             "key1": ["a"],
 1428:             "key2": ["b"],
 1429:             "key3": pd.array([max_value], dtype=any_real_numeric_dtype),
 1430:         }
 1431:     )
 1432:     arrays = [["a"], ["b"]]
 1433:     index = MultiIndex.from_arrays(arrays, names=("key1", "key2"))
 1434: 
 1435:     expected = DataFrame(
 1436:         {"key3": pd.array([max_value], dtype=any_real_numeric_dtype)}, index=index
 1437:     )
 1438:     result = df.groupby(["key1", "key2"]).agg(lambda x: x)
 1439:     tm.assert_frame_equal(result, expected)
 1440: 
 1441: 
 1442: def test_groupby_aggregate_directory(reduction_func):
 1443:     # GH#32793
 1444:     if reduction_func in ["corrwith", "nth"]:
 1445:         return None
 1446: 
 1447:     obj = DataFrame([[0, 1], [0, np.nan]])
 1448: 
 1449:     result_reduced_series = obj.groupby(0).agg(reduction_func)
 1450:     result_reduced_frame = obj.groupby(0).agg({1: reduction_func})
 1451: 
 1452:     if reduction_func in ["size", "ngroup"]:
 1453:         # names are different: None / 1
 1454:         tm.assert_series_equal(
 1455:             result_reduced_series, result_reduced_frame[1], check_names=False
 1456:         )
 1457:     else:
 1458:         tm.assert_frame_equal(result_reduced_series, result_reduced_frame)
 1459:         tm.assert_series_equal(
 1460:             result_reduced_series.dtypes, result_reduced_frame.dtypes
 1461:         )
 1462: 
 1463: 
 1464: def test_group_mean_timedelta_nat():
 1465:     # GH43132
 1466:     data = Series(["1 day", "3 days", "NaT"], dtype="timedelta64[ns]")
 1467:     expected = Series(["2 days"], dtype="timedelta64[ns]", index=np.array([0]))
 1468: 
 1469:     result = data.groupby([0, 0, 0]).mean()
 1470: 
 1471:     tm.assert_series_equal(result, expected)
 1472: 
 1473: 
 1474: @pytest.mark.parametrize(
 1475:     "input_data, expected_output",
 1476:     [
 1477:         (  # no timezone
 1478:             ["2021-01-01T00:00", "NaT", "2021-01-01T02:00"],
 1479:             ["2021-01-01T01:00"],
 1480:         ),
 1481:         (  # timezone
 1482:             ["2021-01-01T00:00-0100", "NaT", "2021-01-01T02:00-0100"],
 1483:             ["2021-01-01T01:00-0100"],
 1484:         ),
 1485:     ],
 1486: )
 1487: def test_group_mean_datetime64_nat(input_data, expected_output):
 1488:     # GH43132
 1489:     data = to_datetime(Series(input_data))
 1490:     expected = to_datetime(Series(expected_output, index=np.array([0])))
 1491: 
 1492:     result = data.groupby([0, 0, 0]).mean()
 1493:     tm.assert_series_equal(result, expected)
 1494: 
 1495: 
 1496: @pytest.mark.parametrize(
 1497:     "func, output", [("mean", [8 + 18j, 10 + 22j]), ("sum", [40 + 90j, 50 + 110j])]
 1498: )
 1499: def test_groupby_complex(func, output):
 1500:     # GH#43701
 1501:     data = Series(np.arange(20).reshape(10, 2).dot([1, 2j]))
 1502:     result = data.groupby(data.index % 2).agg(func)
 1503:     expected = Series(output)
 1504:     tm.assert_series_equal(result, expected)
 1505: 
 1506: 
 1507: @pytest.mark.parametrize("func", ["min", "max", "var"])
 1508: def test_groupby_complex_raises(func):
 1509:     # GH#43701
 1510:     data = Series(np.arange(20).reshape(10, 2).dot([1, 2j]))
 1511:     msg = "No matching signature found"
 1512:     with pytest.raises(TypeError, match=msg):
 1513:         data.groupby(data.index % 2).agg(func)
 1514: 
 1515: 
 1516: @pytest.mark.parametrize(
 1517:     "func", [["min"], ["mean", "max"], {"b": "sum"}, {"b": "prod", "c": "median"}]
 1518: )
 1519: def test_multi_axis_1_raises(func):
 1520:     # GH#46995
 1521:     df = DataFrame({"a": [1, 1, 2], "b": [3, 4, 5], "c": [6, 7, 8]})
 1522:     msg = "DataFrame.groupby with axis=1 is deprecated"
 1523:     with tm.assert_produces_warning(FutureWarning, match=msg):
 1524:         gb = df.groupby("a", axis=1)
 1525:     with pytest.raises(NotImplementedError, match="axis other than 0 is not supported"):
 1526:         gb.agg(func)
 1527: 
 1528: 
 1529: @pytest.mark.parametrize(
 1530:     "test, constant",
 1531:     [
 1532:         ([[20, "A"], [20, "B"], [10, "C"]], {0: [10, 20], 1: ["C", ["A", "B"]]}),
 1533:         ([[20, "A"], [20, "B"], [30, "C"]], {0: [20, 30], 1: [["A", "B"], "C"]}),
 1534:         ([["a", 1], ["a", 1], ["b", 2], ["b", 3]], {0: ["a", "b"], 1: [1, [2, 3]]}),
 1535:         pytest.param(
 1536:             [["a", 1], ["a", 2], ["b", 3], ["b", 3]],
 1537:             {0: ["a", "b"], 1: [[1, 2], 3]},
 1538:             marks=pytest.mark.xfail,
 1539:         ),
 1540:     ],
 1541: )
 1542: def test_agg_of_mode_list(test, constant):
 1543:     # GH#25581
 1544:     df1 = DataFrame(test)
 1545:     result = df1.groupby(0).agg(Series.mode)
 1546:     # Mode usually only returns 1 value, but can return a list in the case of a tie.
 1547: 
 1548:     expected = DataFrame(constant)
 1549:     expected = expected.set_index(0)
 1550: 
 1551:     tm.assert_frame_equal(result, expected)
 1552: 
 1553: 
 1554: def test_dataframe_groupy_agg_list_like_func_with_args():
 1555:     # GH#50624
 1556:     df = DataFrame({"x": [1, 2, 3], "y": ["a", "b", "c"]})
 1557:     gb = df.groupby("y")
 1558: 
 1559:     def foo1(x, a=1, c=0):
 1560:         return x.sum() + a + c
 1561: 
 1562:     def foo2(x, b=2, c=0):
 1563:         return x.sum() + b + c
 1564: 
 1565:     msg = r"foo1\(\) got an unexpected keyword argument 'b'"
 1566:     with pytest.raises(TypeError, match=msg):
 1567:         gb.agg([foo1, foo2], 3, b=3, c=4)
 1568: 
 1569:     result = gb.agg([foo1, foo2], 3, c=4)
 1570:     expected = DataFrame(
 1571:         [[8, 8], [9, 9], [10, 10]],
 1572:         index=Index(["a", "b", "c"], name="y"),
 1573:         columns=MultiIndex.from_tuples([("x", "foo1"), ("x", "foo2")]),
 1574:     )
 1575:     tm.assert_frame_equal(result, expected)
 1576: 
 1577: 
 1578: def test_series_groupy_agg_list_like_func_with_args():
 1579:     # GH#50624
 1580:     s = Series([1, 2, 3])
 1581:     sgb = s.groupby(s)
 1582: 
 1583:     def foo1(x, a=1, c=0):
 1584:         return x.sum() + a + c
 1585: 
 1586:     def foo2(x, b=2, c=0):
 1587:         return x.sum() + b + c
 1588: 
 1589:     msg = r"foo1\(\) got an unexpected keyword argument 'b'"
 1590:     with pytest.raises(TypeError, match=msg):
 1591:         sgb.agg([foo1, foo2], 3, b=3, c=4)
 1592: 
 1593:     result = sgb.agg([foo1, foo2], 3, c=4)
 1594:     expected = DataFrame(
 1595:         [[8, 8], [9, 9], [10, 10]], index=Index([1, 2, 3]), columns=["foo1", "foo2"]
 1596:     )
 1597:     tm.assert_frame_equal(result, expected)
 1598: 
 1599: 
 1600: def test_agg_groupings_selection():
 1601:     # GH#51186 - a selected grouping should be in the output of agg
 1602:     df = DataFrame({"a": [1, 1, 2], "b": [3, 3, 4], "c": [5, 6, 7]})
 1603:     gb = df.groupby(["a", "b"])
 1604:     selected_gb = gb[["b", "c"]]
 1605:     result = selected_gb.agg(lambda x: x.sum())
 1606:     index = MultiIndex(
 1607:         levels=[[1, 2], [3, 4]], codes=[[0, 1], [0, 1]], names=["a", "b"]
 1608:     )
 1609:     expected = DataFrame({"b": [6, 4], "c": [11, 7]}, index=index)
 1610:     tm.assert_frame_equal(result, expected)
 1611: 
 1612: 
 1613: def test_agg_multiple_with_as_index_false_subset_to_a_single_column():
 1614:     # GH#50724
 1615:     df = DataFrame({"a": [1, 1, 2], "b": [3, 4, 5]})
 1616:     gb = df.groupby("a", as_index=False)["b"]
 1617:     result = gb.agg(["sum", "mean"])
 1618:     expected = DataFrame({"a": [1, 2], "sum": [7, 5], "mean": [3.5, 5.0]})
 1619:     tm.assert_frame_equal(result, expected)
 1620: 
 1621: 
 1622: def test_agg_with_as_index_false_with_list():
 1623:     # GH#52849
 1624:     df = DataFrame({"a1": [0, 0, 1], "a2": [2, 3, 3], "b": [4, 5, 6]})
 1625:     gb = df.groupby(by=["a1", "a2"], as_index=False)
 1626:     result = gb.agg(["sum"])
 1627: 
 1628:     expected = DataFrame(
 1629:         data=[[0, 2, 4], [0, 3, 5], [1, 3, 6]],
 1630:         columns=MultiIndex.from_tuples([("a1", ""), ("a2", ""), ("b", "sum")]),
 1631:     )
 1632:     tm.assert_frame_equal(result, expected)
 1633: 
 1634: 
 1635: def test_groupby_agg_extension_timedelta_cumsum_with_named_aggregation():
 1636:     # GH#41720
 1637:     expected = DataFrame(
 1638:         {
 1639:             "td": {
 1640:                 0: pd.Timedelta("0 days 01:00:00"),
 1641:                 1: pd.Timedelta("0 days 01:15:00"),
 1642:                 2: pd.Timedelta("0 days 01:15:00"),
 1643:             }
 1644:         }
 1645:     )
 1646:     df = DataFrame(
 1647:         {
 1648:             "td": Series(
 1649:                 ["0 days 01:00:00", "0 days 00:15:00", "0 days 01:15:00"],
 1650:                 dtype="timedelta64[ns]",
 1651:             ),
 1652:             "grps": ["a", "a", "b"],
 1653:         }
 1654:     )
 1655:     gb = df.groupby("grps")
 1656:     result = gb.agg(td=("td", "cumsum"))
 1657:     tm.assert_frame_equal(result, expected)
 1658: 
 1659: 
 1660: def test_groupby_aggregation_empty_group():
 1661:     # https://github.com/pandas-dev/pandas/issues/18869
 1662:     def func(x):
 1663:         if len(x) == 0:
 1664:             raise ValueError("length must not be 0")
 1665:         return len(x)
 1666: 
 1667:     df = DataFrame(
 1668:         {"A": pd.Categorical(["a", "a"], categories=["a", "b", "c"]), "B": [1, 1]}
 1669:     )
 1670:     msg = "length must not be 0"
 1671:     with pytest.raises(ValueError, match=msg):
 1672:         df.groupby("A", observed=False).agg(func)
