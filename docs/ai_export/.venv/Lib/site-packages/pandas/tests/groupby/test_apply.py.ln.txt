    1: from datetime import (
    2:     date,
    3:     datetime,
    4: )
    5: 
    6: import numpy as np
    7: import pytest
    8: 
    9: import pandas as pd
   10: from pandas import (
   11:     DataFrame,
   12:     Index,
   13:     MultiIndex,
   14:     Series,
   15:     bdate_range,
   16: )
   17: import pandas._testing as tm
   18: from pandas.tests.groupby import get_groupby_method_args
   19: 
   20: 
   21: def test_apply_func_that_appends_group_to_list_without_copy():
   22:     # GH: 17718
   23: 
   24:     df = DataFrame(1, index=list(range(10)) * 10, columns=[0]).reset_index()
   25:     groups = []
   26: 
   27:     def store(group):
   28:         groups.append(group)
   29: 
   30:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
   31:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
   32:         df.groupby("index").apply(store)
   33:     expected_value = DataFrame(
   34:         {"index": [0] * 10, 0: [1] * 10}, index=pd.RangeIndex(0, 100, 10)
   35:     )
   36: 
   37:     tm.assert_frame_equal(groups[0], expected_value)
   38: 
   39: 
   40: def test_apply_index_date(using_infer_string):
   41:     # GH 5788
   42:     ts = [
   43:         "2011-05-16 00:00",
   44:         "2011-05-16 01:00",
   45:         "2011-05-16 02:00",
   46:         "2011-05-16 03:00",
   47:         "2011-05-17 02:00",
   48:         "2011-05-17 03:00",
   49:         "2011-05-17 04:00",
   50:         "2011-05-17 05:00",
   51:         "2011-05-18 02:00",
   52:         "2011-05-18 03:00",
   53:         "2011-05-18 04:00",
   54:         "2011-05-18 05:00",
   55:     ]
   56:     df = DataFrame(
   57:         {
   58:             "value": [
   59:                 1.40893,
   60:                 1.40760,
   61:                 1.40750,
   62:                 1.40649,
   63:                 1.40893,
   64:                 1.40760,
   65:                 1.40750,
   66:                 1.40649,
   67:                 1.40893,
   68:                 1.40760,
   69:                 1.40750,
   70:                 1.40649,
   71:             ],
   72:         },
   73:         index=Index(pd.to_datetime(ts), name="date_time"),
   74:     )
   75:     expected = df.groupby(df.index.date).idxmax()
   76:     result = df.groupby(df.index.date).apply(lambda x: x.idxmax())
   77:     tm.assert_frame_equal(result, expected)
   78: 
   79: 
   80: def test_apply_index_date_object(using_infer_string):
   81:     # GH 5789
   82:     # don't auto coerce dates
   83:     ts = [
   84:         "2011-05-16 00:00",
   85:         "2011-05-16 01:00",
   86:         "2011-05-16 02:00",
   87:         "2011-05-16 03:00",
   88:         "2011-05-17 02:00",
   89:         "2011-05-17 03:00",
   90:         "2011-05-17 04:00",
   91:         "2011-05-17 05:00",
   92:         "2011-05-18 02:00",
   93:         "2011-05-18 03:00",
   94:         "2011-05-18 04:00",
   95:         "2011-05-18 05:00",
   96:     ]
   97:     df = DataFrame([row.split() for row in ts], columns=["date", "time"])
   98:     df["value"] = [
   99:         1.40893,
  100:         1.40760,
  101:         1.40750,
  102:         1.40649,
  103:         1.40893,
  104:         1.40760,
  105:         1.40750,
  106:         1.40649,
  107:         1.40893,
  108:         1.40760,
  109:         1.40750,
  110:         1.40649,
  111:     ]
  112:     dtype = "string[pyarrow_numpy]" if using_infer_string else object
  113:     exp_idx = Index(
  114:         ["2011-05-16", "2011-05-17", "2011-05-18"], dtype=dtype, name="date"
  115:     )
  116:     expected = Series(["00:00", "02:00", "02:00"], index=exp_idx)
  117:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
  118:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
  119:         result = df.groupby("date", group_keys=False).apply(
  120:             lambda x: x["time"][x["value"].idxmax()]
  121:         )
  122:     tm.assert_series_equal(result, expected)
  123: 
  124: 
  125: def test_apply_trivial(using_infer_string):
  126:     # GH 20066
  127:     # trivial apply: ignore input and return a constant dataframe.
  128:     df = DataFrame(
  129:         {"key": ["a", "a", "b", "b", "a"], "data": [1.0, 2.0, 3.0, 4.0, 5.0]},
  130:         columns=["key", "data"],
  131:     )
  132:     dtype = "string" if using_infer_string else "object"
  133:     expected = pd.concat([df.iloc[1:], df.iloc[1:]], axis=1, keys=["float64", dtype])
  134: 
  135:     msg = "DataFrame.groupby with axis=1 is deprecated"
  136:     with tm.assert_produces_warning(FutureWarning, match=msg):
  137:         gb = df.groupby([str(x) for x in df.dtypes], axis=1)
  138:     result = gb.apply(lambda x: df.iloc[1:])
  139: 
  140:     tm.assert_frame_equal(result, expected)
  141: 
  142: 
  143: def test_apply_trivial_fail(using_infer_string):
  144:     # GH 20066
  145:     df = DataFrame(
  146:         {"key": ["a", "a", "b", "b", "a"], "data": [1.0, 2.0, 3.0, 4.0, 5.0]},
  147:         columns=["key", "data"],
  148:     )
  149:     dtype = "string" if using_infer_string else "object"
  150:     expected = pd.concat([df, df], axis=1, keys=["float64", dtype])
  151:     msg = "DataFrame.groupby with axis=1 is deprecated"
  152:     with tm.assert_produces_warning(FutureWarning, match=msg):
  153:         gb = df.groupby([str(x) for x in df.dtypes], axis=1, group_keys=True)
  154:     result = gb.apply(lambda x: df)
  155: 
  156:     tm.assert_frame_equal(result, expected)
  157: 
  158: 
  159: @pytest.mark.parametrize(
  160:     "df, group_names",
  161:     [
  162:         (DataFrame({"a": [1, 1, 1, 2, 3], "b": ["a", "a", "a", "b", "c"]}), [1, 2, 3]),
  163:         (DataFrame({"a": [0, 0, 1, 1], "b": [0, 1, 0, 1]}), [0, 1]),
  164:         (DataFrame({"a": [1]}), [1]),
  165:         (DataFrame({"a": [1, 1, 1, 2, 2, 1, 1, 2], "b": range(8)}), [1, 2]),
  166:         (DataFrame({"a": [1, 2, 3, 1, 2, 3], "two": [4, 5, 6, 7, 8, 9]}), [1, 2, 3]),
  167:         (
  168:             DataFrame(
  169:                 {
  170:                     "a": list("aaabbbcccc"),
  171:                     "B": [3, 4, 3, 6, 5, 2, 1, 9, 5, 4],
  172:                     "C": [4, 0, 2, 2, 2, 7, 8, 6, 2, 8],
  173:                 }
  174:             ),
  175:             ["a", "b", "c"],
  176:         ),
  177:         (DataFrame([[1, 2, 3], [2, 2, 3]], columns=["a", "b", "c"]), [1, 2]),
  178:     ],
  179:     ids=[
  180:         "GH2936",
  181:         "GH7739 & GH10519",
  182:         "GH10519",
  183:         "GH2656",
  184:         "GH12155",
  185:         "GH20084",
  186:         "GH21417",
  187:     ],
  188: )
  189: def test_group_apply_once_per_group(df, group_names):
  190:     # GH2936, GH7739, GH10519, GH2656, GH12155, GH20084, GH21417
  191: 
  192:     # This test should ensure that a function is only evaluated
  193:     # once per group. Previously the function has been evaluated twice
  194:     # on the first group to check if the Cython index slider is safe to use
  195:     # This test ensures that the side effect (append to list) is only triggered
  196:     # once per group
  197: 
  198:     names = []
  199:     # cannot parameterize over the functions since they need external
  200:     # `names` to detect side effects
  201: 
  202:     def f_copy(group):
  203:         # this takes the fast apply path
  204:         names.append(group.name)
  205:         return group.copy()
  206: 
  207:     def f_nocopy(group):
  208:         # this takes the slow apply path
  209:         names.append(group.name)
  210:         return group
  211: 
  212:     def f_scalar(group):
  213:         # GH7739, GH2656
  214:         names.append(group.name)
  215:         return 0
  216: 
  217:     def f_none(group):
  218:         # GH10519, GH12155, GH21417
  219:         names.append(group.name)
  220: 
  221:     def f_constant_df(group):
  222:         # GH2936, GH20084
  223:         names.append(group.name)
  224:         return DataFrame({"a": [1], "b": [1]})
  225: 
  226:     for func in [f_copy, f_nocopy, f_scalar, f_none, f_constant_df]:
  227:         del names[:]
  228: 
  229:         msg = "DataFrameGroupBy.apply operated on the grouping columns"
  230:         with tm.assert_produces_warning(DeprecationWarning, match=msg):
  231:             df.groupby("a", group_keys=False).apply(func)
  232:         assert names == group_names
  233: 
  234: 
  235: def test_group_apply_once_per_group2(capsys):
  236:     # GH: 31111
  237:     # groupby-apply need to execute len(set(group_by_columns)) times
  238: 
  239:     expected = 2  # Number of times `apply` should call a function for the current test
  240: 
  241:     df = DataFrame(
  242:         {
  243:             "group_by_column": [0, 0, 0, 0, 1, 1, 1, 1],
  244:             "test_column": ["0", "2", "4", "6", "8", "10", "12", "14"],
  245:         },
  246:         index=["0", "2", "4", "6", "8", "10", "12", "14"],
  247:     )
  248: 
  249:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
  250:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
  251:         df.groupby("group_by_column", group_keys=False).apply(
  252:             lambda df: print("function_called")
  253:         )
  254: 
  255:     result = capsys.readouterr().out.count("function_called")
  256:     # If `groupby` behaves unexpectedly, this test will break
  257:     assert result == expected
  258: 
  259: 
  260: def test_apply_fast_slow_identical():
  261:     # GH 31613
  262: 
  263:     df = DataFrame({"A": [0, 0, 1], "b": range(3)})
  264: 
  265:     # For simple index structures we check for fast/slow apply using
  266:     # an identity check on in/output
  267:     def slow(group):
  268:         return group
  269: 
  270:     def fast(group):
  271:         return group.copy()
  272: 
  273:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
  274:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
  275:         fast_df = df.groupby("A", group_keys=False).apply(fast)
  276:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
  277:         slow_df = df.groupby("A", group_keys=False).apply(slow)
  278: 
  279:     tm.assert_frame_equal(fast_df, slow_df)
  280: 
  281: 
  282: @pytest.mark.parametrize(
  283:     "func",
  284:     [
  285:         lambda x: x,
  286:         lambda x: x[:],
  287:         lambda x: x.copy(deep=False),
  288:         lambda x: x.copy(deep=True),
  289:     ],
  290: )
  291: def test_groupby_apply_identity_maybecopy_index_identical(func):
  292:     # GH 14927
  293:     # Whether the function returns a copy of the input data or not should not
  294:     # have an impact on the index structure of the result since this is not
  295:     # transparent to the user
  296: 
  297:     df = DataFrame({"g": [1, 2, 2, 2], "a": [1, 2, 3, 4], "b": [5, 6, 7, 8]})
  298: 
  299:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
  300:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
  301:         result = df.groupby("g", group_keys=False).apply(func)
  302:     tm.assert_frame_equal(result, df)
  303: 
  304: 
  305: def test_apply_with_mixed_dtype():
  306:     # GH3480, apply with mixed dtype on axis=1 breaks in 0.11
  307:     df = DataFrame(
  308:         {
  309:             "foo1": np.random.default_rng(2).standard_normal(6),
  310:             "foo2": ["one", "two", "two", "three", "one", "two"],
  311:         }
  312:     )
  313:     result = df.apply(lambda x: x, axis=1).dtypes
  314:     expected = df.dtypes
  315:     tm.assert_series_equal(result, expected)
  316: 
  317:     # GH 3610 incorrect dtype conversion with as_index=False
  318:     df = DataFrame({"c1": [1, 2, 6, 6, 8]})
  319:     df["c2"] = df.c1 / 2.0
  320:     result1 = df.groupby("c2").mean().reset_index().c2
  321:     result2 = df.groupby("c2", as_index=False).mean().c2
  322:     tm.assert_series_equal(result1, result2)
  323: 
  324: 
  325: def test_groupby_as_index_apply():
  326:     # GH #4648 and #3417
  327:     df = DataFrame(
  328:         {
  329:             "item_id": ["b", "b", "a", "c", "a", "b"],
  330:             "user_id": [1, 2, 1, 1, 3, 1],
  331:             "time": range(6),
  332:         }
  333:     )
  334: 
  335:     g_as = df.groupby("user_id", as_index=True)
  336:     g_not_as = df.groupby("user_id", as_index=False)
  337: 
  338:     res_as = g_as.head(2).index
  339:     res_not_as = g_not_as.head(2).index
  340:     exp = Index([0, 1, 2, 4])
  341:     tm.assert_index_equal(res_as, exp)
  342:     tm.assert_index_equal(res_not_as, exp)
  343: 
  344:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
  345:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
  346:         res_as_apply = g_as.apply(lambda x: x.head(2)).index
  347:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
  348:         res_not_as_apply = g_not_as.apply(lambda x: x.head(2)).index
  349: 
  350:     # apply doesn't maintain the original ordering
  351:     # changed in GH5610 as the as_index=False returns a MI here
  352:     exp_not_as_apply = MultiIndex.from_tuples([(0, 0), (0, 2), (1, 1), (2, 4)])
  353:     tp = [(1, 0), (1, 2), (2, 1), (3, 4)]
  354:     exp_as_apply = MultiIndex.from_tuples(tp, names=["user_id", None])
  355: 
  356:     tm.assert_index_equal(res_as_apply, exp_as_apply)
  357:     tm.assert_index_equal(res_not_as_apply, exp_not_as_apply)
  358: 
  359:     ind = Index(list("abcde"))
  360:     df = DataFrame([[1, 2], [2, 3], [1, 4], [1, 5], [2, 6]], index=ind)
  361:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
  362:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
  363:         res = df.groupby(0, as_index=False, group_keys=False).apply(lambda x: x).index
  364:     tm.assert_index_equal(res, ind)
  365: 
  366: 
  367: def test_apply_concat_preserve_names(three_group):
  368:     grouped = three_group.groupby(["A", "B"])
  369: 
  370:     def desc(group):
  371:         result = group.describe()
  372:         result.index.name = "stat"
  373:         return result
  374: 
  375:     def desc2(group):
  376:         result = group.describe()
  377:         result.index.name = "stat"
  378:         result = result[: len(group)]
  379:         # weirdo
  380:         return result
  381: 
  382:     def desc3(group):
  383:         result = group.describe()
  384: 
  385:         # names are different
  386:         result.index.name = f"stat_{len(group):d}"
  387: 
  388:         result = result[: len(group)]
  389:         # weirdo
  390:         return result
  391: 
  392:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
  393:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
  394:         result = grouped.apply(desc)
  395:     assert result.index.names == ("A", "B", "stat")
  396: 
  397:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
  398:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
  399:         result2 = grouped.apply(desc2)
  400:     assert result2.index.names == ("A", "B", "stat")
  401: 
  402:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
  403:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
  404:         result3 = grouped.apply(desc3)
  405:     assert result3.index.names == ("A", "B", None)
  406: 
  407: 
  408: def test_apply_series_to_frame():
  409:     def f(piece):
  410:         with np.errstate(invalid="ignore"):
  411:             logged = np.log(piece)
  412:         return DataFrame(
  413:             {"value": piece, "demeaned": piece - piece.mean(), "logged": logged}
  414:         )
  415: 
  416:     dr = bdate_range("1/1/2000", periods=100)
  417:     ts = Series(np.random.default_rng(2).standard_normal(100), index=dr)
  418: 
  419:     grouped = ts.groupby(lambda x: x.month, group_keys=False)
  420:     result = grouped.apply(f)
  421: 
  422:     assert isinstance(result, DataFrame)
  423:     assert not hasattr(result, "name")  # GH49907
  424:     tm.assert_index_equal(result.index, ts.index)
  425: 
  426: 
  427: def test_apply_series_yield_constant(df):
  428:     result = df.groupby(["A", "B"])["C"].apply(len)
  429:     assert result.index.names[:2] == ("A", "B")
  430: 
  431: 
  432: def test_apply_frame_yield_constant(df):
  433:     # GH13568
  434:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
  435:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
  436:         result = df.groupby(["A", "B"]).apply(len)
  437:     assert isinstance(result, Series)
  438:     assert result.name is None
  439: 
  440:     result = df.groupby(["A", "B"])[["C", "D"]].apply(len)
  441:     assert isinstance(result, Series)
  442:     assert result.name is None
  443: 
  444: 
  445: def test_apply_frame_to_series(df):
  446:     grouped = df.groupby(["A", "B"])
  447:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
  448:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
  449:         result = grouped.apply(len)
  450:     expected = grouped.count()["C"]
  451:     tm.assert_index_equal(result.index, expected.index)
  452:     tm.assert_numpy_array_equal(result.values, expected.values)
  453: 
  454: 
  455: def test_apply_frame_not_as_index_column_name(df):
  456:     # GH 35964 - path within _wrap_applied_output not hit by a test
  457:     grouped = df.groupby(["A", "B"], as_index=False)
  458:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
  459:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
  460:         result = grouped.apply(len)
  461:     expected = grouped.count().rename(columns={"C": np.nan}).drop(columns="D")
  462:     # TODO(GH#34306): Use assert_frame_equal when column name is not np.nan
  463:     tm.assert_index_equal(result.index, expected.index)
  464:     tm.assert_numpy_array_equal(result.values, expected.values)
  465: 
  466: 
  467: def test_apply_frame_concat_series():
  468:     def trans(group):
  469:         return group.groupby("B")["C"].sum().sort_values().iloc[:2]
  470: 
  471:     def trans2(group):
  472:         grouped = group.groupby(df.reindex(group.index)["B"])
  473:         return grouped.sum().sort_values().iloc[:2]
  474: 
  475:     df = DataFrame(
  476:         {
  477:             "A": np.random.default_rng(2).integers(0, 5, 1000),
  478:             "B": np.random.default_rng(2).integers(0, 5, 1000),
  479:             "C": np.random.default_rng(2).standard_normal(1000),
  480:         }
  481:     )
  482: 
  483:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
  484:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
  485:         result = df.groupby("A").apply(trans)
  486:     exp = df.groupby("A")["C"].apply(trans2)
  487:     tm.assert_series_equal(result, exp, check_names=False)
  488:     assert result.name == "C"
  489: 
  490: 
  491: def test_apply_transform(ts):
  492:     grouped = ts.groupby(lambda x: x.month, group_keys=False)
  493:     result = grouped.apply(lambda x: x * 2)
  494:     expected = grouped.transform(lambda x: x * 2)
  495:     tm.assert_series_equal(result, expected)
  496: 
  497: 
  498: def test_apply_multikey_corner(tsframe):
  499:     grouped = tsframe.groupby([lambda x: x.year, lambda x: x.month])
  500: 
  501:     def f(group):
  502:         return group.sort_values("A")[-5:]
  503: 
  504:     result = grouped.apply(f)
  505:     for key, group in grouped:
  506:         tm.assert_frame_equal(result.loc[key], f(group))
  507: 
  508: 
  509: @pytest.mark.parametrize("group_keys", [True, False])
  510: def test_apply_chunk_view(group_keys):
  511:     # Low level tinkering could be unsafe, make sure not
  512:     df = DataFrame({"key": [1, 1, 1, 2, 2, 2, 3, 3, 3], "value": range(9)})
  513: 
  514:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
  515:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
  516:         result = df.groupby("key", group_keys=group_keys).apply(lambda x: x.iloc[:2])
  517:     expected = df.take([0, 1, 3, 4, 6, 7])
  518:     if group_keys:
  519:         expected.index = MultiIndex.from_arrays(
  520:             [[1, 1, 2, 2, 3, 3], expected.index], names=["key", None]
  521:         )
  522: 
  523:     tm.assert_frame_equal(result, expected)
  524: 
  525: 
  526: def test_apply_no_name_column_conflict():
  527:     df = DataFrame(
  528:         {
  529:             "name": [1, 1, 1, 1, 1, 1, 2, 2, 2, 2],
  530:             "name2": [0, 0, 0, 1, 1, 1, 0, 0, 1, 1],
  531:             "value": range(9, -1, -1),
  532:         }
  533:     )
  534: 
  535:     # it works! #2605
  536:     grouped = df.groupby(["name", "name2"])
  537:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
  538:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
  539:         grouped.apply(lambda x: x.sort_values("value", inplace=True))
  540: 
  541: 
  542: def test_apply_typecast_fail():
  543:     df = DataFrame(
  544:         {
  545:             "d": [1.0, 1.0, 1.0, 2.0, 2.0, 2.0],
  546:             "c": np.tile(["a", "b", "c"], 2),
  547:             "v": np.arange(1.0, 7.0),
  548:         }
  549:     )
  550: 
  551:     def f(group):
  552:         v = group["v"]
  553:         group["v2"] = (v - v.min()) / (v.max() - v.min())
  554:         return group
  555: 
  556:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
  557:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
  558:         result = df.groupby("d", group_keys=False).apply(f)
  559: 
  560:     expected = df.copy()
  561:     expected["v2"] = np.tile([0.0, 0.5, 1], 2)
  562: 
  563:     tm.assert_frame_equal(result, expected)
  564: 
  565: 
  566: def test_apply_multiindex_fail():
  567:     index = MultiIndex.from_arrays([[0, 0, 0, 1, 1, 1], [1, 2, 3, 1, 2, 3]])
  568:     df = DataFrame(
  569:         {
  570:             "d": [1.0, 1.0, 1.0, 2.0, 2.0, 2.0],
  571:             "c": np.tile(["a", "b", "c"], 2),
  572:             "v": np.arange(1.0, 7.0),
  573:         },
  574:         index=index,
  575:     )
  576: 
  577:     def f(group):
  578:         v = group["v"]
  579:         group["v2"] = (v - v.min()) / (v.max() - v.min())
  580:         return group
  581: 
  582:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
  583:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
  584:         result = df.groupby("d", group_keys=False).apply(f)
  585: 
  586:     expected = df.copy()
  587:     expected["v2"] = np.tile([0.0, 0.5, 1], 2)
  588: 
  589:     tm.assert_frame_equal(result, expected)
  590: 
  591: 
  592: def test_apply_corner(tsframe):
  593:     result = tsframe.groupby(lambda x: x.year, group_keys=False).apply(lambda x: x * 2)
  594:     expected = tsframe * 2
  595:     tm.assert_frame_equal(result, expected)
  596: 
  597: 
  598: def test_apply_without_copy():
  599:     # GH 5545
  600:     # returning a non-copy in an applied function fails
  601: 
  602:     data = DataFrame(
  603:         {
  604:             "id_field": [100, 100, 200, 300],
  605:             "category": ["a", "b", "c", "c"],
  606:             "value": [1, 2, 3, 4],
  607:         }
  608:     )
  609: 
  610:     def filt1(x):
  611:         if x.shape[0] == 1:
  612:             return x.copy()
  613:         else:
  614:             return x[x.category == "c"]
  615: 
  616:     def filt2(x):
  617:         if x.shape[0] == 1:
  618:             return x
  619:         else:
  620:             return x[x.category == "c"]
  621: 
  622:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
  623:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
  624:         expected = data.groupby("id_field").apply(filt1)
  625:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
  626:         result = data.groupby("id_field").apply(filt2)
  627:     tm.assert_frame_equal(result, expected)
  628: 
  629: 
  630: @pytest.mark.parametrize("test_series", [True, False])
  631: def test_apply_with_duplicated_non_sorted_axis(test_series):
  632:     # GH 30667
  633:     df = DataFrame(
  634:         [["x", "p"], ["x", "p"], ["x", "o"]], columns=["X", "Y"], index=[1, 2, 2]
  635:     )
  636:     if test_series:
  637:         ser = df.set_index("Y")["X"]
  638:         result = ser.groupby(level=0, group_keys=False).apply(lambda x: x)
  639: 
  640:         # not expecting the order to remain the same for duplicated axis
  641:         result = result.sort_index()
  642:         expected = ser.sort_index()
  643:         tm.assert_series_equal(result, expected)
  644:     else:
  645:         msg = "DataFrameGroupBy.apply operated on the grouping columns"
  646:         with tm.assert_produces_warning(DeprecationWarning, match=msg):
  647:             result = df.groupby("Y", group_keys=False).apply(lambda x: x)
  648: 
  649:         # not expecting the order to remain the same for duplicated axis
  650:         result = result.sort_values("Y")
  651:         expected = df.sort_values("Y")
  652:         tm.assert_frame_equal(result, expected)
  653: 
  654: 
  655: def test_apply_reindex_values():
  656:     # GH: 26209
  657:     # reindexing from a single column of a groupby object with duplicate indices caused
  658:     # a ValueError (cannot reindex from duplicate axis) in 0.24.2, the problem was
  659:     # solved in #30679
  660:     values = [1, 2, 3, 4]
  661:     indices = [1, 1, 2, 2]
  662:     df = DataFrame({"group": ["Group1", "Group2"] * 2, "value": values}, index=indices)
  663:     expected = Series(values, index=indices, name="value")
  664: 
  665:     def reindex_helper(x):
  666:         return x.reindex(np.arange(x.index.min(), x.index.max() + 1))
  667: 
  668:     # the following group by raised a ValueError
  669:     result = df.groupby("group", group_keys=False).value.apply(reindex_helper)
  670:     tm.assert_series_equal(expected, result)
  671: 
  672: 
  673: def test_apply_corner_cases():
  674:     # #535, can't use sliding iterator
  675: 
  676:     N = 1000
  677:     labels = np.random.default_rng(2).integers(0, 100, size=N)
  678:     df = DataFrame(
  679:         {
  680:             "key": labels,
  681:             "value1": np.random.default_rng(2).standard_normal(N),
  682:             "value2": ["foo", "bar", "baz", "qux"] * (N // 4),
  683:         }
  684:     )
  685: 
  686:     grouped = df.groupby("key", group_keys=False)
  687: 
  688:     def f(g):
  689:         g["value3"] = g["value1"] * 2
  690:         return g
  691: 
  692:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
  693:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
  694:         result = grouped.apply(f)
  695:     assert "value3" in result
  696: 
  697: 
  698: def test_apply_numeric_coercion_when_datetime():
  699:     # In the past, group-by/apply operations have been over-eager
  700:     # in converting dtypes to numeric, in the presence of datetime
  701:     # columns.  Various GH issues were filed, the reproductions
  702:     # for which are here.
  703: 
  704:     # GH 15670
  705:     df = DataFrame(
  706:         {"Number": [1, 2], "Date": ["2017-03-02"] * 2, "Str": ["foo", "inf"]}
  707:     )
  708:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
  709:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
  710:         expected = df.groupby(["Number"]).apply(lambda x: x.iloc[0])
  711:     df.Date = pd.to_datetime(df.Date)
  712:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
  713:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
  714:         result = df.groupby(["Number"]).apply(lambda x: x.iloc[0])
  715:     tm.assert_series_equal(result["Str"], expected["Str"])
  716: 
  717:     # GH 15421
  718:     df = DataFrame(
  719:         {"A": [10, 20, 30], "B": ["foo", "3", "4"], "T": [pd.Timestamp("12:31:22")] * 3}
  720:     )
  721: 
  722:     def get_B(g):
  723:         return g.iloc[0][["B"]]
  724: 
  725:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
  726:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
  727:         result = df.groupby("A").apply(get_B)["B"]
  728:     expected = df.B
  729:     expected.index = df.A
  730:     tm.assert_series_equal(result, expected)
  731: 
  732:     # GH 14423
  733:     def predictions(tool):
  734:         out = Series(index=["p1", "p2", "useTime"], dtype=object)
  735:         if "step1" in list(tool.State):
  736:             out["p1"] = str(tool[tool.State == "step1"].Machine.values[0])
  737:         if "step2" in list(tool.State):
  738:             out["p2"] = str(tool[tool.State == "step2"].Machine.values[0])
  739:             out["useTime"] = str(tool[tool.State == "step2"].oTime.values[0])
  740:         return out
  741: 
  742:     df1 = DataFrame(
  743:         {
  744:             "Key": ["B", "B", "A", "A"],
  745:             "State": ["step1", "step2", "step1", "step2"],
  746:             "oTime": ["", "2016-09-19 05:24:33", "", "2016-09-19 23:59:04"],
  747:             "Machine": ["23", "36L", "36R", "36R"],
  748:         }
  749:     )
  750:     df2 = df1.copy()
  751:     df2.oTime = pd.to_datetime(df2.oTime)
  752:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
  753:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
  754:         expected = df1.groupby("Key").apply(predictions).p1
  755:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
  756:         result = df2.groupby("Key").apply(predictions).p1
  757:     tm.assert_series_equal(expected, result)
  758: 
  759: 
  760: def test_apply_aggregating_timedelta_and_datetime():
  761:     # Regression test for GH 15562
  762:     # The following groupby caused ValueErrors and IndexErrors pre 0.20.0
  763: 
  764:     df = DataFrame(
  765:         {
  766:             "clientid": ["A", "B", "C"],
  767:             "datetime": [np.datetime64("2017-02-01 00:00:00")] * 3,
  768:         }
  769:     )
  770:     df["time_delta_zero"] = df.datetime - df.datetime
  771:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
  772:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
  773:         result = df.groupby("clientid").apply(
  774:             lambda ddf: Series(
  775:                 {"clientid_age": ddf.time_delta_zero.min(), "date": ddf.datetime.min()}
  776:             )
  777:         )
  778:     expected = DataFrame(
  779:         {
  780:             "clientid": ["A", "B", "C"],
  781:             "clientid_age": [np.timedelta64(0, "D")] * 3,
  782:             "date": [np.datetime64("2017-02-01 00:00:00")] * 3,
  783:         }
  784:     ).set_index("clientid")
  785: 
  786:     tm.assert_frame_equal(result, expected)
  787: 
  788: 
  789: def test_apply_groupby_datetimeindex():
  790:     # GH 26182
  791:     # groupby apply failed on dataframe with DatetimeIndex
  792: 
  793:     data = [["A", 10], ["B", 20], ["B", 30], ["C", 40], ["C", 50]]
  794:     df = DataFrame(
  795:         data, columns=["Name", "Value"], index=pd.date_range("2020-09-01", "2020-09-05")
  796:     )
  797: 
  798:     result = df.groupby("Name").sum()
  799: 
  800:     expected = DataFrame({"Name": ["A", "B", "C"], "Value": [10, 50, 90]})
  801:     expected.set_index("Name", inplace=True)
  802: 
  803:     tm.assert_frame_equal(result, expected)
  804: 
  805: 
  806: def test_time_field_bug():
  807:     # Test a fix for the following error related to GH issue 11324 When
  808:     # non-key fields in a group-by dataframe contained time-based fields
  809:     # that were not returned by the apply function, an exception would be
  810:     # raised.
  811: 
  812:     df = DataFrame({"a": 1, "b": [datetime.now() for nn in range(10)]})
  813: 
  814:     def func_with_no_date(batch):
  815:         return Series({"c": 2})
  816: 
  817:     def func_with_date(batch):
  818:         return Series({"b": datetime(2015, 1, 1), "c": 2})
  819: 
  820:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
  821:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
  822:         dfg_no_conversion = df.groupby(by=["a"]).apply(func_with_no_date)
  823:     dfg_no_conversion_expected = DataFrame({"c": 2}, index=[1])
  824:     dfg_no_conversion_expected.index.name = "a"
  825: 
  826:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
  827:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
  828:         dfg_conversion = df.groupby(by=["a"]).apply(func_with_date)
  829:     dfg_conversion_expected = DataFrame(
  830:         {"b": pd.Timestamp(2015, 1, 1).as_unit("ns"), "c": 2}, index=[1]
  831:     )
  832:     dfg_conversion_expected.index.name = "a"
  833: 
  834:     tm.assert_frame_equal(dfg_no_conversion, dfg_no_conversion_expected)
  835:     tm.assert_frame_equal(dfg_conversion, dfg_conversion_expected)
  836: 
  837: 
  838: def test_gb_apply_list_of_unequal_len_arrays():
  839:     # GH1738
  840:     df = DataFrame(
  841:         {
  842:             "group1": ["a", "a", "a", "b", "b", "b", "a", "a", "a", "b", "b", "b"],
  843:             "group2": ["c", "c", "d", "d", "d", "e", "c", "c", "d", "d", "d", "e"],
  844:             "weight": [1.1, 2, 3, 4, 5, 6, 2, 4, 6, 8, 1, 2],
  845:             "value": [7.1, 8, 9, 10, 11, 12, 8, 7, 6, 5, 4, 3],
  846:         }
  847:     )
  848:     df = df.set_index(["group1", "group2"])
  849:     df_grouped = df.groupby(level=["group1", "group2"], sort=True)
  850: 
  851:     def noddy(value, weight):
  852:         out = np.array(value * weight).repeat(3)
  853:         return out
  854: 
  855:     # the kernel function returns arrays of unequal length
  856:     # pandas sniffs the first one, sees it's an array and not
  857:     # a list, and assumed the rest are of equal length
  858:     # and so tries a vstack
  859: 
  860:     # don't die
  861:     df_grouped.apply(lambda x: noddy(x.value, x.weight))
  862: 
  863: 
  864: def test_groupby_apply_all_none():
  865:     # Tests to make sure no errors if apply function returns all None
  866:     # values. Issue 9684.
  867:     test_df = DataFrame({"groups": [0, 0, 1, 1], "random_vars": [8, 7, 4, 5]})
  868: 
  869:     def test_func(x):
  870:         pass
  871: 
  872:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
  873:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
  874:         result = test_df.groupby("groups").apply(test_func)
  875:     expected = DataFrame()
  876:     tm.assert_frame_equal(result, expected)
  877: 
  878: 
  879: def test_groupby_apply_none_first():
  880:     # GH 12824. Tests if apply returns None first.
  881:     test_df1 = DataFrame({"groups": [1, 1, 1, 2], "vars": [0, 1, 2, 3]})
  882:     test_df2 = DataFrame({"groups": [1, 2, 2, 2], "vars": [0, 1, 2, 3]})
  883: 
  884:     def test_func(x):
  885:         if x.shape[0] < 2:
  886:             return None
  887:         return x.iloc[[0, -1]]
  888: 
  889:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
  890:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
  891:         result1 = test_df1.groupby("groups").apply(test_func)
  892:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
  893:         result2 = test_df2.groupby("groups").apply(test_func)
  894:     index1 = MultiIndex.from_arrays([[1, 1], [0, 2]], names=["groups", None])
  895:     index2 = MultiIndex.from_arrays([[2, 2], [1, 3]], names=["groups", None])
  896:     expected1 = DataFrame({"groups": [1, 1], "vars": [0, 2]}, index=index1)
  897:     expected2 = DataFrame({"groups": [2, 2], "vars": [1, 3]}, index=index2)
  898:     tm.assert_frame_equal(result1, expected1)
  899:     tm.assert_frame_equal(result2, expected2)
  900: 
  901: 
  902: def test_groupby_apply_return_empty_chunk():
  903:     # GH 22221: apply filter which returns some empty groups
  904:     df = DataFrame({"value": [0, 1], "group": ["filled", "empty"]})
  905:     groups = df.groupby("group")
  906:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
  907:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
  908:         result = groups.apply(lambda group: group[group.value != 1]["value"])
  909:     expected = Series(
  910:         [0],
  911:         name="value",
  912:         index=MultiIndex.from_product(
  913:             [["empty", "filled"], [0]], names=["group", None]
  914:         ).drop("empty"),
  915:     )
  916:     tm.assert_series_equal(result, expected)
  917: 
  918: 
  919: def test_apply_with_mixed_types():
  920:     # gh-20949
  921:     df = DataFrame({"A": "a a b".split(), "B": [1, 2, 3], "C": [4, 6, 5]})
  922:     g = df.groupby("A", group_keys=False)
  923: 
  924:     result = g.transform(lambda x: x / x.sum())
  925:     expected = DataFrame({"B": [1 / 3.0, 2 / 3.0, 1], "C": [0.4, 0.6, 1.0]})
  926:     tm.assert_frame_equal(result, expected)
  927: 
  928:     result = g.apply(lambda x: x / x.sum())
  929:     tm.assert_frame_equal(result, expected)
  930: 
  931: 
  932: def test_func_returns_object():
  933:     # GH 28652
  934:     df = DataFrame({"a": [1, 2]}, index=Index([1, 2]))
  935:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
  936:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
  937:         result = df.groupby("a").apply(lambda g: g.index)
  938:     expected = Series([Index([1]), Index([2])], index=Index([1, 2], name="a"))
  939: 
  940:     tm.assert_series_equal(result, expected)
  941: 
  942: 
  943: @pytest.mark.parametrize(
  944:     "group_column_dtlike",
  945:     [datetime.today(), datetime.today().date(), datetime.today().time()],
  946: )
  947: def test_apply_datetime_issue(group_column_dtlike, using_infer_string):
  948:     # GH-28247
  949:     # groupby-apply throws an error if one of the columns in the DataFrame
  950:     #   is a datetime object and the column labels are different from
  951:     #   standard int values in range(len(num_columns))
  952: 
  953:     df = DataFrame({"a": ["foo"], "b": [group_column_dtlike]})
  954:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
  955:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
  956:         result = df.groupby("a").apply(lambda x: Series(["spam"], index=[42]))
  957: 
  958:     dtype = "string" if using_infer_string else "object"
  959:     expected = DataFrame(["spam"], Index(["foo"], dtype=dtype, name="a"), columns=[42])
  960:     tm.assert_frame_equal(result, expected)
  961: 
  962: 
  963: def test_apply_series_return_dataframe_groups():
  964:     # GH 10078
  965:     tdf = DataFrame(
  966:         {
  967:             "day": {
  968:                 0: pd.Timestamp("2015-02-24 00:00:00"),
  969:                 1: pd.Timestamp("2015-02-24 00:00:00"),
  970:                 2: pd.Timestamp("2015-02-24 00:00:00"),
  971:                 3: pd.Timestamp("2015-02-24 00:00:00"),
  972:                 4: pd.Timestamp("2015-02-24 00:00:00"),
  973:             },
  974:             "userAgent": {
  975:                 0: "some UA string",
  976:                 1: "some UA string",
  977:                 2: "some UA string",
  978:                 3: "another UA string",
  979:                 4: "some UA string",
  980:             },
  981:             "userId": {
  982:                 0: "17661101",
  983:                 1: "17661101",
  984:                 2: "17661101",
  985:                 3: "17661101",
  986:                 4: "17661101",
  987:             },
  988:         }
  989:     )
  990: 
  991:     def most_common_values(df):
  992:         return Series({c: s.value_counts().index[0] for c, s in df.items()})
  993: 
  994:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
  995:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
  996:         result = tdf.groupby("day").apply(most_common_values)["userId"]
  997:     expected = Series(
  998:         ["17661101"], index=pd.DatetimeIndex(["2015-02-24"], name="day"), name="userId"
  999:     )
 1000:     tm.assert_series_equal(result, expected)
 1001: 
 1002: 
 1003: @pytest.mark.parametrize("category", [False, True])
 1004: def test_apply_multi_level_name(category):
 1005:     # https://github.com/pandas-dev/pandas/issues/31068
 1006:     b = [1, 2] * 5
 1007:     if category:
 1008:         b = pd.Categorical(b, categories=[1, 2, 3])
 1009:         expected_index = pd.CategoricalIndex([1, 2, 3], categories=[1, 2, 3], name="B")
 1010:         expected_values = [20, 25, 0]
 1011:     else:
 1012:         expected_index = Index([1, 2], name="B")
 1013:         expected_values = [20, 25]
 1014:     expected = DataFrame(
 1015:         {"C": expected_values, "D": expected_values}, index=expected_index
 1016:     )
 1017: 
 1018:     df = DataFrame(
 1019:         {"A": np.arange(10), "B": b, "C": list(range(10)), "D": list(range(10))}
 1020:     ).set_index(["A", "B"])
 1021:     result = df.groupby("B", observed=False).apply(lambda x: x.sum())
 1022:     tm.assert_frame_equal(result, expected)
 1023:     assert df.index.names == ["A", "B"]
 1024: 
 1025: 
 1026: def test_groupby_apply_datetime_result_dtypes(using_infer_string):
 1027:     # GH 14849
 1028:     data = DataFrame.from_records(
 1029:         [
 1030:             (pd.Timestamp(2016, 1, 1), "red", "dark", 1, "8"),
 1031:             (pd.Timestamp(2015, 1, 1), "green", "stormy", 2, "9"),
 1032:             (pd.Timestamp(2014, 1, 1), "blue", "bright", 3, "10"),
 1033:             (pd.Timestamp(2013, 1, 1), "blue", "calm", 4, "potato"),
 1034:         ],
 1035:         columns=["observation", "color", "mood", "intensity", "score"],
 1036:     )
 1037:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
 1038:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
 1039:         result = data.groupby("color").apply(lambda g: g.iloc[0]).dtypes
 1040:     dtype = "string" if using_infer_string else object
 1041:     expected = Series(
 1042:         [np.dtype("datetime64[ns]"), dtype, dtype, np.int64, dtype],
 1043:         index=["observation", "color", "mood", "intensity", "score"],
 1044:     )
 1045:     tm.assert_series_equal(result, expected)
 1046: 
 1047: 
 1048: @pytest.mark.parametrize(
 1049:     "index",
 1050:     [
 1051:         pd.CategoricalIndex(list("abc")),
 1052:         pd.interval_range(0, 3),
 1053:         pd.period_range("2020", periods=3, freq="D"),
 1054:         MultiIndex.from_tuples([("a", 0), ("a", 1), ("b", 0)]),
 1055:     ],
 1056: )
 1057: def test_apply_index_has_complex_internals(index):
 1058:     # GH 31248
 1059:     df = DataFrame({"group": [1, 1, 2], "value": [0, 1, 0]}, index=index)
 1060:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
 1061:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
 1062:         result = df.groupby("group", group_keys=False).apply(lambda x: x)
 1063:     tm.assert_frame_equal(result, df)
 1064: 
 1065: 
 1066: @pytest.mark.parametrize(
 1067:     "function, expected_values",
 1068:     [
 1069:         (lambda x: x.index.to_list(), [[0, 1], [2, 3]]),
 1070:         (lambda x: set(x.index.to_list()), [{0, 1}, {2, 3}]),
 1071:         (lambda x: tuple(x.index.to_list()), [(0, 1), (2, 3)]),
 1072:         (
 1073:             lambda x: dict(enumerate(x.index.to_list())),
 1074:             [{0: 0, 1: 1}, {0: 2, 1: 3}],
 1075:         ),
 1076:         (
 1077:             lambda x: [{n: i} for (n, i) in enumerate(x.index.to_list())],
 1078:             [[{0: 0}, {1: 1}], [{0: 2}, {1: 3}]],
 1079:         ),
 1080:     ],
 1081: )
 1082: def test_apply_function_returns_non_pandas_non_scalar(function, expected_values):
 1083:     # GH 31441
 1084:     df = DataFrame(["A", "A", "B", "B"], columns=["groups"])
 1085:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
 1086:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
 1087:         result = df.groupby("groups").apply(function)
 1088:     expected = Series(expected_values, index=Index(["A", "B"], name="groups"))
 1089:     tm.assert_series_equal(result, expected)
 1090: 
 1091: 
 1092: def test_apply_function_returns_numpy_array():
 1093:     # GH 31605
 1094:     def fct(group):
 1095:         return group["B"].values.flatten()
 1096: 
 1097:     df = DataFrame({"A": ["a", "a", "b", "none"], "B": [1, 2, 3, np.nan]})
 1098: 
 1099:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
 1100:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
 1101:         result = df.groupby("A").apply(fct)
 1102:     expected = Series(
 1103:         [[1.0, 2.0], [3.0], [np.nan]], index=Index(["a", "b", "none"], name="A")
 1104:     )
 1105:     tm.assert_series_equal(result, expected)
 1106: 
 1107: 
 1108: @pytest.mark.parametrize("function", [lambda gr: gr.index, lambda gr: gr.index + 1 - 1])
 1109: def test_apply_function_index_return(function):
 1110:     # GH: 22541
 1111:     df = DataFrame([1, 2, 2, 2, 1, 2, 3, 1, 3, 1], columns=["id"])
 1112:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
 1113:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
 1114:         result = df.groupby("id").apply(function)
 1115:     expected = Series(
 1116:         [Index([0, 4, 7, 9]), Index([1, 2, 3, 5]), Index([6, 8])],
 1117:         index=Index([1, 2, 3], name="id"),
 1118:     )
 1119:     tm.assert_series_equal(result, expected)
 1120: 
 1121: 
 1122: def test_apply_function_with_indexing_return_column():
 1123:     # GH#7002, GH#41480, GH#49256
 1124:     df = DataFrame(
 1125:         {
 1126:             "foo1": ["one", "two", "two", "three", "one", "two"],
 1127:             "foo2": [1, 2, 4, 4, 5, 6],
 1128:         }
 1129:     )
 1130:     result = df.groupby("foo1", as_index=False).apply(lambda x: x.mean())
 1131:     expected = DataFrame(
 1132:         {
 1133:             "foo1": ["one", "three", "two"],
 1134:             "foo2": [3.0, 4.0, 4.0],
 1135:         }
 1136:     )
 1137:     tm.assert_frame_equal(result, expected)
 1138: 
 1139: 
 1140: @pytest.mark.parametrize(
 1141:     "udf",
 1142:     [(lambda x: x.copy()), (lambda x: x.copy().rename(lambda y: y + 1))],
 1143: )
 1144: @pytest.mark.parametrize("group_keys", [True, False])
 1145: def test_apply_result_type(group_keys, udf):
 1146:     # https://github.com/pandas-dev/pandas/issues/34809
 1147:     # We'd like to control whether the group keys end up in the index
 1148:     # regardless of whether the UDF happens to be a transform.
 1149:     df = DataFrame({"A": ["a", "b"], "B": [1, 2]})
 1150:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
 1151:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
 1152:         df_result = df.groupby("A", group_keys=group_keys).apply(udf)
 1153:     series_result = df.B.groupby(df.A, group_keys=group_keys).apply(udf)
 1154: 
 1155:     if group_keys:
 1156:         assert df_result.index.nlevels == 2
 1157:         assert series_result.index.nlevels == 2
 1158:     else:
 1159:         assert df_result.index.nlevels == 1
 1160:         assert series_result.index.nlevels == 1
 1161: 
 1162: 
 1163: def test_result_order_group_keys_false():
 1164:     # GH 34998
 1165:     # apply result order should not depend on whether index is the same or just equal
 1166:     df = DataFrame({"A": [2, 1, 2], "B": [1, 2, 3]})
 1167:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
 1168:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
 1169:         result = df.groupby("A", group_keys=False).apply(lambda x: x)
 1170:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
 1171:         expected = df.groupby("A", group_keys=False).apply(lambda x: x.copy())
 1172:     tm.assert_frame_equal(result, expected)
 1173: 
 1174: 
 1175: def test_apply_with_timezones_aware():
 1176:     # GH: 27212
 1177:     dates = ["2001-01-01"] * 2 + ["2001-01-02"] * 2 + ["2001-01-03"] * 2
 1178:     index_no_tz = pd.DatetimeIndex(dates)
 1179:     index_tz = pd.DatetimeIndex(dates, tz="UTC")
 1180:     df1 = DataFrame({"x": list(range(2)) * 3, "y": range(6), "t": index_no_tz})
 1181:     df2 = DataFrame({"x": list(range(2)) * 3, "y": range(6), "t": index_tz})
 1182: 
 1183:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
 1184:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
 1185:         result1 = df1.groupby("x", group_keys=False).apply(
 1186:             lambda df: df[["x", "y"]].copy()
 1187:         )
 1188:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
 1189:         result2 = df2.groupby("x", group_keys=False).apply(
 1190:             lambda df: df[["x", "y"]].copy()
 1191:         )
 1192: 
 1193:     tm.assert_frame_equal(result1, result2)
 1194: 
 1195: 
 1196: def test_apply_is_unchanged_when_other_methods_are_called_first(reduction_func):
 1197:     # GH #34656
 1198:     # GH #34271
 1199:     df = DataFrame(
 1200:         {
 1201:             "a": [99, 99, 99, 88, 88, 88],
 1202:             "b": [1, 2, 3, 4, 5, 6],
 1203:             "c": [10, 20, 30, 40, 50, 60],
 1204:         }
 1205:     )
 1206: 
 1207:     expected = DataFrame(
 1208:         {"b": [15, 6], "c": [150, 60]},
 1209:         index=Index([88, 99], name="a"),
 1210:     )
 1211: 
 1212:     # Check output when no other methods are called before .apply()
 1213:     grp = df.groupby(by="a")
 1214:     msg = "The behavior of DataFrame.sum with axis=None is deprecated"
 1215:     with tm.assert_produces_warning(FutureWarning, match=msg, check_stacklevel=False):
 1216:         result = grp.apply(sum, include_groups=False)
 1217:     tm.assert_frame_equal(result, expected)
 1218: 
 1219:     # Check output when another method is called before .apply()
 1220:     grp = df.groupby(by="a")
 1221:     args = get_groupby_method_args(reduction_func, df)
 1222:     _ = getattr(grp, reduction_func)(*args)
 1223:     with tm.assert_produces_warning(FutureWarning, match=msg, check_stacklevel=False):
 1224:         result = grp.apply(sum, include_groups=False)
 1225:     tm.assert_frame_equal(result, expected)
 1226: 
 1227: 
 1228: def test_apply_with_date_in_multiindex_does_not_convert_to_timestamp():
 1229:     # GH 29617
 1230: 
 1231:     df = DataFrame(
 1232:         {
 1233:             "A": ["a", "a", "a", "b"],
 1234:             "B": [
 1235:                 date(2020, 1, 10),
 1236:                 date(2020, 1, 10),
 1237:                 date(2020, 2, 10),
 1238:                 date(2020, 2, 10),
 1239:             ],
 1240:             "C": [1, 2, 3, 4],
 1241:         },
 1242:         index=Index([100, 101, 102, 103], name="idx"),
 1243:     )
 1244: 
 1245:     grp = df.groupby(["A", "B"])
 1246:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
 1247:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
 1248:         result = grp.apply(lambda x: x.head(1))
 1249: 
 1250:     expected = df.iloc[[0, 2, 3]]
 1251:     expected = expected.reset_index()
 1252:     expected.index = MultiIndex.from_frame(expected[["A", "B", "idx"]])
 1253:     expected = expected.drop(columns="idx")
 1254: 
 1255:     tm.assert_frame_equal(result, expected)
 1256:     for val in result.index.levels[1]:
 1257:         assert type(val) is date
 1258: 
 1259: 
 1260: def test_apply_by_cols_equals_apply_by_rows_transposed():
 1261:     # GH 16646
 1262:     # Operating on the columns, or transposing and operating on the rows
 1263:     # should give the same result. There was previously a bug where the
 1264:     # by_rows operation would work fine, but by_cols would throw a ValueError
 1265: 
 1266:     df = DataFrame(
 1267:         np.random.default_rng(2).random([6, 4]),
 1268:         columns=MultiIndex.from_product([["A", "B"], [1, 2]]),
 1269:     )
 1270: 
 1271:     msg = "The 'axis' keyword in DataFrame.groupby is deprecated"
 1272:     with tm.assert_produces_warning(FutureWarning, match=msg):
 1273:         gb = df.T.groupby(axis=0, level=0)
 1274:     by_rows = gb.apply(lambda x: x.droplevel(axis=0, level=0))
 1275: 
 1276:     msg = "DataFrame.groupby with axis=1 is deprecated"
 1277:     with tm.assert_produces_warning(FutureWarning, match=msg):
 1278:         gb2 = df.groupby(axis=1, level=0)
 1279:     by_cols = gb2.apply(lambda x: x.droplevel(axis=1, level=0))
 1280: 
 1281:     tm.assert_frame_equal(by_cols, by_rows.T)
 1282:     tm.assert_frame_equal(by_cols, df)
 1283: 
 1284: 
 1285: @pytest.mark.parametrize("dropna", [True, False])
 1286: def test_apply_dropna_with_indexed_same(dropna):
 1287:     # GH 38227
 1288:     # GH#43205
 1289:     df = DataFrame(
 1290:         {
 1291:             "col": [1, 2, 3, 4, 5],
 1292:             "group": ["a", np.nan, np.nan, "b", "b"],
 1293:         },
 1294:         index=list("xxyxz"),
 1295:     )
 1296:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
 1297:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
 1298:         result = df.groupby("group", dropna=dropna, group_keys=False).apply(lambda x: x)
 1299:     expected = df.dropna() if dropna else df.iloc[[0, 3, 1, 2, 4]]
 1300:     tm.assert_frame_equal(result, expected)
 1301: 
 1302: 
 1303: @pytest.mark.parametrize(
 1304:     "as_index, expected",
 1305:     [
 1306:         [
 1307:             False,
 1308:             DataFrame(
 1309:                 [[1, 1, 1], [2, 2, 1]], columns=Index(["a", "b", None], dtype=object)
 1310:             ),
 1311:         ],
 1312:         [
 1313:             True,
 1314:             Series(
 1315:                 [1, 1], index=MultiIndex.from_tuples([(1, 1), (2, 2)], names=["a", "b"])
 1316:             ),
 1317:         ],
 1318:     ],
 1319: )
 1320: def test_apply_as_index_constant_lambda(as_index, expected):
 1321:     # GH 13217
 1322:     df = DataFrame({"a": [1, 1, 2, 2], "b": [1, 1, 2, 2], "c": [1, 1, 1, 1]})
 1323:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
 1324:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
 1325:         result = df.groupby(["a", "b"], as_index=as_index).apply(lambda x: 1)
 1326:     tm.assert_equal(result, expected)
 1327: 
 1328: 
 1329: def test_sort_index_groups():
 1330:     # GH 20420
 1331:     df = DataFrame(
 1332:         {"A": [1, 2, 3, 4, 5], "B": [6, 7, 8, 9, 0], "C": [1, 1, 1, 2, 2]},
 1333:         index=range(5),
 1334:     )
 1335:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
 1336:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
 1337:         result = df.groupby("C").apply(lambda x: x.A.sort_index())
 1338:     expected = Series(
 1339:         range(1, 6),
 1340:         index=MultiIndex.from_tuples(
 1341:             [(1, 0), (1, 1), (1, 2), (2, 3), (2, 4)], names=["C", None]
 1342:         ),
 1343:         name="A",
 1344:     )
 1345:     tm.assert_series_equal(result, expected)
 1346: 
 1347: 
 1348: def test_positional_slice_groups_datetimelike():
 1349:     # GH 21651
 1350:     expected = DataFrame(
 1351:         {
 1352:             "date": pd.date_range("2010-01-01", freq="12h", periods=5),
 1353:             "vals": range(5),
 1354:             "let": list("abcde"),
 1355:         }
 1356:     )
 1357:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
 1358:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
 1359:         result = expected.groupby(
 1360:             [expected.let, expected.date.dt.date], group_keys=False
 1361:         ).apply(lambda x: x.iloc[0:])
 1362:     tm.assert_frame_equal(result, expected)
 1363: 
 1364: 
 1365: def test_groupby_apply_shape_cache_safety():
 1366:     # GH#42702 this fails if we cache_readonly Block.shape
 1367:     df = DataFrame({"A": ["a", "a", "b"], "B": [1, 2, 3], "C": [4, 6, 5]})
 1368:     gb = df.groupby("A")
 1369:     result = gb[["B", "C"]].apply(lambda x: x.astype(float).max() - x.min())
 1370: 
 1371:     expected = DataFrame(
 1372:         {"B": [1.0, 0.0], "C": [2.0, 0.0]}, index=Index(["a", "b"], name="A")
 1373:     )
 1374:     tm.assert_frame_equal(result, expected)
 1375: 
 1376: 
 1377: def test_groupby_apply_to_series_name():
 1378:     # GH52444
 1379:     df = DataFrame.from_dict(
 1380:         {
 1381:             "a": ["a", "b", "a", "b"],
 1382:             "b1": ["aa", "ac", "ac", "ad"],
 1383:             "b2": ["aa", "aa", "aa", "ac"],
 1384:         }
 1385:     )
 1386:     grp = df.groupby("a")[["b1", "b2"]]
 1387:     result = grp.apply(lambda x: x.unstack().value_counts())
 1388: 
 1389:     expected_idx = MultiIndex.from_arrays(
 1390:         arrays=[["a", "a", "b", "b", "b"], ["aa", "ac", "ac", "ad", "aa"]],
 1391:         names=["a", None],
 1392:     )
 1393:     expected = Series([3, 1, 2, 1, 1], index=expected_idx, name="count")
 1394:     tm.assert_series_equal(result, expected)
 1395: 
 1396: 
 1397: @pytest.mark.parametrize("dropna", [True, False])
 1398: def test_apply_na(dropna):
 1399:     # GH#28984
 1400:     df = DataFrame(
 1401:         {"grp": [1, 1, 2, 2], "y": [1, 0, 2, 5], "z": [1, 2, np.nan, np.nan]}
 1402:     )
 1403:     dfgrp = df.groupby("grp", dropna=dropna)
 1404:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
 1405:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
 1406:         result = dfgrp.apply(lambda grp_df: grp_df.nlargest(1, "z"))
 1407:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
 1408:         expected = dfgrp.apply(lambda x: x.sort_values("z", ascending=False).head(1))
 1409:     tm.assert_frame_equal(result, expected)
 1410: 
 1411: 
 1412: def test_apply_empty_string_nan_coerce_bug():
 1413:     # GH#24903
 1414:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
 1415:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
 1416:         result = (
 1417:             DataFrame(
 1418:                 {
 1419:                     "a": [1, 1, 2, 2],
 1420:                     "b": ["", "", "", ""],
 1421:                     "c": pd.to_datetime([1, 2, 3, 4], unit="s"),
 1422:                 }
 1423:             )
 1424:             .groupby(["a", "b"])
 1425:             .apply(lambda df: df.iloc[-1])
 1426:         )
 1427:     expected = DataFrame(
 1428:         [[1, "", pd.to_datetime(2, unit="s")], [2, "", pd.to_datetime(4, unit="s")]],
 1429:         columns=["a", "b", "c"],
 1430:         index=MultiIndex.from_tuples([(1, ""), (2, "")], names=["a", "b"]),
 1431:     )
 1432:     tm.assert_frame_equal(result, expected)
 1433: 
 1434: 
 1435: @pytest.mark.parametrize("index_values", [[1, 2, 3], [1.0, 2.0, 3.0]])
 1436: def test_apply_index_key_error_bug(index_values):
 1437:     # GH 44310
 1438:     result = DataFrame(
 1439:         {
 1440:             "a": ["aa", "a2", "a3"],
 1441:             "b": [1, 2, 3],
 1442:         },
 1443:         index=Index(index_values),
 1444:     )
 1445:     expected = DataFrame(
 1446:         {
 1447:             "b_mean": [2.0, 3.0, 1.0],
 1448:         },
 1449:         index=Index(["a2", "a3", "aa"], name="a"),
 1450:     )
 1451:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
 1452:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
 1453:         result = result.groupby("a").apply(
 1454:             lambda df: Series([df["b"].mean()], index=["b_mean"])
 1455:         )
 1456:     tm.assert_frame_equal(result, expected)
 1457: 
 1458: 
 1459: @pytest.mark.parametrize(
 1460:     "arg,idx",
 1461:     [
 1462:         [
 1463:             [
 1464:                 1,
 1465:                 2,
 1466:                 3,
 1467:             ],
 1468:             [
 1469:                 0.1,
 1470:                 0.3,
 1471:                 0.2,
 1472:             ],
 1473:         ],
 1474:         [
 1475:             [
 1476:                 1,
 1477:                 2,
 1478:                 3,
 1479:             ],
 1480:             [
 1481:                 0.1,
 1482:                 0.2,
 1483:                 0.3,
 1484:             ],
 1485:         ],
 1486:         [
 1487:             [
 1488:                 1,
 1489:                 4,
 1490:                 3,
 1491:             ],
 1492:             [
 1493:                 0.1,
 1494:                 0.4,
 1495:                 0.2,
 1496:             ],
 1497:         ],
 1498:     ],
 1499: )
 1500: def test_apply_nonmonotonic_float_index(arg, idx):
 1501:     # GH 34455
 1502:     expected = DataFrame({"col": arg}, index=idx)
 1503:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
 1504:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
 1505:         result = expected.groupby("col", group_keys=False).apply(lambda x: x)
 1506:     tm.assert_frame_equal(result, expected)
 1507: 
 1508: 
 1509: @pytest.mark.parametrize("args, kwargs", [([True], {}), ([], {"numeric_only": True})])
 1510: def test_apply_str_with_args(df, args, kwargs):
 1511:     # GH#46479
 1512:     gb = df.groupby("A")
 1513:     result = gb.apply("sum", *args, **kwargs)
 1514:     expected = gb.sum(numeric_only=True)
 1515:     tm.assert_frame_equal(result, expected)
 1516: 
 1517: 
 1518: @pytest.mark.parametrize("name", ["some_name", None])
 1519: def test_result_name_when_one_group(name):
 1520:     # GH 46369
 1521:     ser = Series([1, 2], name=name)
 1522:     result = ser.groupby(["a", "a"], group_keys=False).apply(lambda x: x)
 1523:     expected = Series([1, 2], name=name)
 1524: 
 1525:     tm.assert_series_equal(result, expected)
 1526: 
 1527: 
 1528: @pytest.mark.parametrize(
 1529:     "method, op",
 1530:     [
 1531:         ("apply", lambda gb: gb.values[-1]),
 1532:         ("apply", lambda gb: gb["b"].iloc[0]),
 1533:         ("agg", "skew"),
 1534:         ("agg", "prod"),
 1535:         ("agg", "sum"),
 1536:     ],
 1537: )
 1538: def test_empty_df(method, op):
 1539:     # GH 47985
 1540:     empty_df = DataFrame({"a": [], "b": []})
 1541:     gb = empty_df.groupby("a", group_keys=True)
 1542:     group = getattr(gb, "b")
 1543: 
 1544:     result = getattr(group, method)(op)
 1545:     expected = Series(
 1546:         [], name="b", dtype="float64", index=Index([], dtype="float64", name="a")
 1547:     )
 1548: 
 1549:     tm.assert_series_equal(result, expected)
 1550: 
 1551: 
 1552: @pytest.mark.parametrize("include_groups", [True, False])
 1553: def test_include_groups(include_groups):
 1554:     # GH#7155
 1555:     df = DataFrame({"a": [1, 1, 2], "b": [3, 4, 5]})
 1556:     gb = df.groupby("a")
 1557:     warn = DeprecationWarning if include_groups else None
 1558:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
 1559:     with tm.assert_produces_warning(warn, match=msg):
 1560:         result = gb.apply(lambda x: x.sum(), include_groups=include_groups)
 1561:     expected = DataFrame({"a": [2, 2], "b": [7, 5]}, index=Index([1, 2], name="a"))
 1562:     if not include_groups:
 1563:         expected = expected[["b"]]
 1564:     tm.assert_frame_equal(result, expected)
 1565: 
 1566: 
 1567: @pytest.mark.parametrize("f", [max, min, sum])
 1568: @pytest.mark.parametrize("keys", ["jim", ["jim", "joe"]])  # Single key  # Multi-key
 1569: def test_builtins_apply(keys, f):
 1570:     # see gh-8155
 1571:     rs = np.random.default_rng(2)
 1572:     df = DataFrame(rs.integers(1, 7, (10, 2)), columns=["jim", "joe"])
 1573:     df["jolie"] = rs.standard_normal(10)
 1574: 
 1575:     gb = df.groupby(keys)
 1576: 
 1577:     fname = f.__name__
 1578: 
 1579:     warn = None if f is not sum else FutureWarning
 1580:     msg = "The behavior of DataFrame.sum with axis=None is deprecated"
 1581:     with tm.assert_produces_warning(
 1582:         warn, match=msg, check_stacklevel=False, raise_on_extra_warnings=False
 1583:     ):
 1584:         # Also warns on deprecation GH#53425
 1585:         result = gb.apply(f)
 1586:     ngroups = len(df.drop_duplicates(subset=keys))
 1587: 
 1588:     assert_msg = f"invalid frame shape: {result.shape} (expected ({ngroups}, 3))"
 1589:     assert result.shape == (ngroups, 3), assert_msg
 1590: 
 1591:     npfunc = lambda x: getattr(np, fname)(x, axis=0)  # numpy's equivalent function
 1592:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
 1593:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
 1594:         expected = gb.apply(npfunc)
 1595:     tm.assert_frame_equal(result, expected)
 1596: 
 1597:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
 1598:         expected2 = gb.apply(lambda x: npfunc(x))
 1599:     tm.assert_frame_equal(result, expected2)
 1600: 
 1601:     if f != sum:
 1602:         expected = gb.agg(fname).reset_index()
 1603:         expected.set_index(keys, inplace=True, drop=False)
 1604:         tm.assert_frame_equal(result, expected, check_dtype=False)
 1605: 
 1606:     tm.assert_series_equal(getattr(result, fname)(axis=0), getattr(df, fname)(axis=0))
