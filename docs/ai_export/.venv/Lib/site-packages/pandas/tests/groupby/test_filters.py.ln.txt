    1: from string import ascii_lowercase
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: import pandas as pd
    7: from pandas import (
    8:     DataFrame,
    9:     Series,
   10:     Timestamp,
   11: )
   12: import pandas._testing as tm
   13: 
   14: 
   15: def test_filter_series():
   16:     s = Series([1, 3, 20, 5, 22, 24, 7])
   17:     expected_odd = Series([1, 3, 5, 7], index=[0, 1, 3, 6])
   18:     expected_even = Series([20, 22, 24], index=[2, 4, 5])
   19:     grouper = s.apply(lambda x: x % 2)
   20:     grouped = s.groupby(grouper)
   21:     tm.assert_series_equal(grouped.filter(lambda x: x.mean() < 10), expected_odd)
   22:     tm.assert_series_equal(grouped.filter(lambda x: x.mean() > 10), expected_even)
   23:     # Test dropna=False.
   24:     tm.assert_series_equal(
   25:         grouped.filter(lambda x: x.mean() < 10, dropna=False),
   26:         expected_odd.reindex(s.index),
   27:     )
   28:     tm.assert_series_equal(
   29:         grouped.filter(lambda x: x.mean() > 10, dropna=False),
   30:         expected_even.reindex(s.index),
   31:     )
   32: 
   33: 
   34: def test_filter_single_column_df():
   35:     df = DataFrame([1, 3, 20, 5, 22, 24, 7])
   36:     expected_odd = DataFrame([1, 3, 5, 7], index=[0, 1, 3, 6])
   37:     expected_even = DataFrame([20, 22, 24], index=[2, 4, 5])
   38:     grouper = df[0].apply(lambda x: x % 2)
   39:     grouped = df.groupby(grouper)
   40:     tm.assert_frame_equal(grouped.filter(lambda x: x.mean() < 10), expected_odd)
   41:     tm.assert_frame_equal(grouped.filter(lambda x: x.mean() > 10), expected_even)
   42:     # Test dropna=False.
   43:     tm.assert_frame_equal(
   44:         grouped.filter(lambda x: x.mean() < 10, dropna=False),
   45:         expected_odd.reindex(df.index),
   46:     )
   47:     tm.assert_frame_equal(
   48:         grouped.filter(lambda x: x.mean() > 10, dropna=False),
   49:         expected_even.reindex(df.index),
   50:     )
   51: 
   52: 
   53: def test_filter_multi_column_df():
   54:     df = DataFrame({"A": [1, 12, 12, 1], "B": [1, 1, 1, 1]})
   55:     grouper = df["A"].apply(lambda x: x % 2)
   56:     grouped = df.groupby(grouper)
   57:     expected = DataFrame({"A": [12, 12], "B": [1, 1]}, index=[1, 2])
   58:     tm.assert_frame_equal(
   59:         grouped.filter(lambda x: x["A"].sum() - x["B"].sum() > 10), expected
   60:     )
   61: 
   62: 
   63: def test_filter_mixed_df():
   64:     df = DataFrame({"A": [1, 12, 12, 1], "B": "a b c d".split()})
   65:     grouper = df["A"].apply(lambda x: x % 2)
   66:     grouped = df.groupby(grouper)
   67:     expected = DataFrame({"A": [12, 12], "B": ["b", "c"]}, index=[1, 2])
   68:     tm.assert_frame_equal(grouped.filter(lambda x: x["A"].sum() > 10), expected)
   69: 
   70: 
   71: def test_filter_out_all_groups():
   72:     s = Series([1, 3, 20, 5, 22, 24, 7])
   73:     grouper = s.apply(lambda x: x % 2)
   74:     grouped = s.groupby(grouper)
   75:     tm.assert_series_equal(grouped.filter(lambda x: x.mean() > 1000), s[[]])
   76:     df = DataFrame({"A": [1, 12, 12, 1], "B": "a b c d".split()})
   77:     grouper = df["A"].apply(lambda x: x % 2)
   78:     grouped = df.groupby(grouper)
   79:     tm.assert_frame_equal(grouped.filter(lambda x: x["A"].sum() > 1000), df.loc[[]])
   80: 
   81: 
   82: def test_filter_out_no_groups():
   83:     s = Series([1, 3, 20, 5, 22, 24, 7])
   84:     grouper = s.apply(lambda x: x % 2)
   85:     grouped = s.groupby(grouper)
   86:     filtered = grouped.filter(lambda x: x.mean() > 0)
   87:     tm.assert_series_equal(filtered, s)
   88:     df = DataFrame({"A": [1, 12, 12, 1], "B": "a b c d".split()})
   89:     grouper = df["A"].apply(lambda x: x % 2)
   90:     grouped = df.groupby(grouper)
   91:     filtered = grouped.filter(lambda x: x["A"].mean() > 0)
   92:     tm.assert_frame_equal(filtered, df)
   93: 
   94: 
   95: def test_filter_out_all_groups_in_df():
   96:     # GH12768
   97:     df = DataFrame({"a": [1, 1, 2], "b": [1, 2, 0]})
   98:     res = df.groupby("a")
   99:     res = res.filter(lambda x: x["b"].sum() > 5, dropna=False)
  100:     expected = DataFrame({"a": [np.nan] * 3, "b": [np.nan] * 3})
  101:     tm.assert_frame_equal(expected, res)
  102: 
  103:     df = DataFrame({"a": [1, 1, 2], "b": [1, 2, 0]})
  104:     res = df.groupby("a")
  105:     res = res.filter(lambda x: x["b"].sum() > 5, dropna=True)
  106:     expected = DataFrame({"a": [], "b": []}, dtype="int64")
  107:     tm.assert_frame_equal(expected, res)
  108: 
  109: 
  110: def test_filter_condition_raises():
  111:     def raise_if_sum_is_zero(x):
  112:         if x.sum() == 0:
  113:             raise ValueError
  114:         return x.sum() > 0
  115: 
  116:     s = Series([-1, 0, 1, 2])
  117:     grouper = s.apply(lambda x: x % 2)
  118:     grouped = s.groupby(grouper)
  119:     msg = "the filter must return a boolean result"
  120:     with pytest.raises(TypeError, match=msg):
  121:         grouped.filter(raise_if_sum_is_zero)
  122: 
  123: 
  124: def test_filter_with_axis_in_groupby():
  125:     # issue 11041
  126:     index = pd.MultiIndex.from_product([range(10), [0, 1]])
  127:     data = DataFrame(np.arange(100).reshape(-1, 20), columns=index, dtype="int64")
  128: 
  129:     msg = "DataFrame.groupby with axis=1"
  130:     with tm.assert_produces_warning(FutureWarning, match=msg):
  131:         gb = data.groupby(level=0, axis=1)
  132:     result = gb.filter(lambda x: x.iloc[0, 0] > 10)
  133:     expected = data.iloc[:, 12:20]
  134:     tm.assert_frame_equal(result, expected)
  135: 
  136: 
  137: def test_filter_bad_shapes():
  138:     df = DataFrame({"A": np.arange(8), "B": list("aabbbbcc"), "C": np.arange(8)})
  139:     s = df["B"]
  140:     g_df = df.groupby("B")
  141:     g_s = s.groupby(s)
  142: 
  143:     f = lambda x: x
  144:     msg = "filter function returned a DataFrame, but expected a scalar bool"
  145:     with pytest.raises(TypeError, match=msg):
  146:         g_df.filter(f)
  147:     msg = "the filter must return a boolean result"
  148:     with pytest.raises(TypeError, match=msg):
  149:         g_s.filter(f)
  150: 
  151:     f = lambda x: x == 1
  152:     msg = "filter function returned a DataFrame, but expected a scalar bool"
  153:     with pytest.raises(TypeError, match=msg):
  154:         g_df.filter(f)
  155:     msg = "the filter must return a boolean result"
  156:     with pytest.raises(TypeError, match=msg):
  157:         g_s.filter(f)
  158: 
  159:     f = lambda x: np.outer(x, x)
  160:     msg = "can't multiply sequence by non-int of type 'str'"
  161:     with pytest.raises(TypeError, match=msg):
  162:         g_df.filter(f)
  163:     msg = "the filter must return a boolean result"
  164:     with pytest.raises(TypeError, match=msg):
  165:         g_s.filter(f)
  166: 
  167: 
  168: def test_filter_nan_is_false():
  169:     df = DataFrame({"A": np.arange(8), "B": list("aabbbbcc"), "C": np.arange(8)})
  170:     s = df["B"]
  171:     g_df = df.groupby(df["B"])
  172:     g_s = s.groupby(s)
  173: 
  174:     f = lambda x: np.nan
  175:     tm.assert_frame_equal(g_df.filter(f), df.loc[[]])
  176:     tm.assert_series_equal(g_s.filter(f), s[[]])
  177: 
  178: 
  179: def test_filter_pdna_is_false():
  180:     # in particular, dont raise in filter trying to call bool(pd.NA)
  181:     df = DataFrame({"A": np.arange(8), "B": list("aabbbbcc"), "C": np.arange(8)})
  182:     ser = df["B"]
  183:     g_df = df.groupby(df["B"])
  184:     g_s = ser.groupby(ser)
  185: 
  186:     func = lambda x: pd.NA
  187:     res = g_df.filter(func)
  188:     tm.assert_frame_equal(res, df.loc[[]])
  189:     res = g_s.filter(func)
  190:     tm.assert_series_equal(res, ser[[]])
  191: 
  192: 
  193: def test_filter_against_workaround_ints():
  194:     # Series of ints
  195:     s = Series(np.random.default_rng(2).integers(0, 100, 100))
  196:     grouper = s.apply(lambda x: np.round(x, -1))
  197:     grouped = s.groupby(grouper)
  198:     f = lambda x: x.mean() > 10
  199: 
  200:     old_way = s[grouped.transform(f).astype("bool")]
  201:     new_way = grouped.filter(f)
  202:     tm.assert_series_equal(new_way.sort_values(), old_way.sort_values())
  203: 
  204: 
  205: def test_filter_against_workaround_floats():
  206:     # Series of floats
  207:     s = 100 * Series(np.random.default_rng(2).random(100))
  208:     grouper = s.apply(lambda x: np.round(x, -1))
  209:     grouped = s.groupby(grouper)
  210:     f = lambda x: x.mean() > 10
  211:     old_way = s[grouped.transform(f).astype("bool")]
  212:     new_way = grouped.filter(f)
  213:     tm.assert_series_equal(new_way.sort_values(), old_way.sort_values())
  214: 
  215: 
  216: def test_filter_against_workaround_dataframe():
  217:     # Set up DataFrame of ints, floats, strings.
  218:     letters = np.array(list(ascii_lowercase))
  219:     N = 100
  220:     random_letters = letters.take(
  221:         np.random.default_rng(2).integers(0, 26, N, dtype=int)
  222:     )
  223:     df = DataFrame(
  224:         {
  225:             "ints": Series(np.random.default_rng(2).integers(0, 100, N)),
  226:             "floats": N / 10 * Series(np.random.default_rng(2).random(N)),
  227:             "letters": Series(random_letters),
  228:         }
  229:     )
  230: 
  231:     # Group by ints; filter on floats.
  232:     grouped = df.groupby("ints")
  233:     old_way = df[grouped.floats.transform(lambda x: x.mean() > N / 20).astype("bool")]
  234:     new_way = grouped.filter(lambda x: x["floats"].mean() > N / 20)
  235:     tm.assert_frame_equal(new_way, old_way)
  236: 
  237:     # Group by floats (rounded); filter on strings.
  238:     grouper = df.floats.apply(lambda x: np.round(x, -1))
  239:     grouped = df.groupby(grouper)
  240:     old_way = df[grouped.letters.transform(lambda x: len(x) < N / 10).astype("bool")]
  241:     new_way = grouped.filter(lambda x: len(x.letters) < N / 10)
  242:     tm.assert_frame_equal(new_way, old_way)
  243: 
  244:     # Group by strings; filter on ints.
  245:     grouped = df.groupby("letters")
  246:     old_way = df[grouped.ints.transform(lambda x: x.mean() > N / 20).astype("bool")]
  247:     new_way = grouped.filter(lambda x: x["ints"].mean() > N / 20)
  248:     tm.assert_frame_equal(new_way, old_way)
  249: 
  250: 
  251: def test_filter_using_len():
  252:     # BUG GH4447
  253:     df = DataFrame({"A": np.arange(8), "B": list("aabbbbcc"), "C": np.arange(8)})
  254:     grouped = df.groupby("B")
  255:     actual = grouped.filter(lambda x: len(x) > 2)
  256:     expected = DataFrame(
  257:         {"A": np.arange(2, 6), "B": list("bbbb"), "C": np.arange(2, 6)},
  258:         index=np.arange(2, 6, dtype=np.int64),
  259:     )
  260:     tm.assert_frame_equal(actual, expected)
  261: 
  262:     actual = grouped.filter(lambda x: len(x) > 4)
  263:     expected = df.loc[[]]
  264:     tm.assert_frame_equal(actual, expected)
  265: 
  266:     # Series have always worked properly, but we'll test anyway.
  267:     s = df["B"]
  268:     grouped = s.groupby(s)
  269:     actual = grouped.filter(lambda x: len(x) > 2)
  270:     expected = Series(4 * ["b"], index=np.arange(2, 6, dtype=np.int64), name="B")
  271:     tm.assert_series_equal(actual, expected)
  272: 
  273:     actual = grouped.filter(lambda x: len(x) > 4)
  274:     expected = s[[]]
  275:     tm.assert_series_equal(actual, expected)
  276: 
  277: 
  278: def test_filter_maintains_ordering():
  279:     # Simple case: index is sequential. #4621
  280:     df = DataFrame(
  281:         {"pid": [1, 1, 1, 2, 2, 3, 3, 3], "tag": [23, 45, 62, 24, 45, 34, 25, 62]}
  282:     )
  283:     s = df["pid"]
  284:     grouped = df.groupby("tag")
  285:     actual = grouped.filter(lambda x: len(x) > 1)
  286:     expected = df.iloc[[1, 2, 4, 7]]
  287:     tm.assert_frame_equal(actual, expected)
  288: 
  289:     grouped = s.groupby(df["tag"])
  290:     actual = grouped.filter(lambda x: len(x) > 1)
  291:     expected = s.iloc[[1, 2, 4, 7]]
  292:     tm.assert_series_equal(actual, expected)
  293: 
  294:     # Now index is sequentially decreasing.
  295:     df.index = np.arange(len(df) - 1, -1, -1)
  296:     s = df["pid"]
  297:     grouped = df.groupby("tag")
  298:     actual = grouped.filter(lambda x: len(x) > 1)
  299:     expected = df.iloc[[1, 2, 4, 7]]
  300:     tm.assert_frame_equal(actual, expected)
  301: 
  302:     grouped = s.groupby(df["tag"])
  303:     actual = grouped.filter(lambda x: len(x) > 1)
  304:     expected = s.iloc[[1, 2, 4, 7]]
  305:     tm.assert_series_equal(actual, expected)
  306: 
  307:     # Index is shuffled.
  308:     SHUFFLED = [4, 6, 7, 2, 1, 0, 5, 3]
  309:     df.index = df.index[SHUFFLED]
  310:     s = df["pid"]
  311:     grouped = df.groupby("tag")
  312:     actual = grouped.filter(lambda x: len(x) > 1)
  313:     expected = df.iloc[[1, 2, 4, 7]]
  314:     tm.assert_frame_equal(actual, expected)
  315: 
  316:     grouped = s.groupby(df["tag"])
  317:     actual = grouped.filter(lambda x: len(x) > 1)
  318:     expected = s.iloc[[1, 2, 4, 7]]
  319:     tm.assert_series_equal(actual, expected)
  320: 
  321: 
  322: def test_filter_multiple_timestamp():
  323:     # GH 10114
  324:     df = DataFrame(
  325:         {
  326:             "A": np.arange(5, dtype="int64"),
  327:             "B": ["foo", "bar", "foo", "bar", "bar"],
  328:             "C": Timestamp("20130101"),
  329:         }
  330:     )
  331: 
  332:     grouped = df.groupby(["B", "C"])
  333: 
  334:     result = grouped["A"].filter(lambda x: True)
  335:     tm.assert_series_equal(df["A"], result)
  336: 
  337:     result = grouped["A"].transform(len)
  338:     expected = Series([2, 3, 2, 3, 3], name="A")
  339:     tm.assert_series_equal(result, expected)
  340: 
  341:     result = grouped.filter(lambda x: True)
  342:     tm.assert_frame_equal(df, result)
  343: 
  344:     result = grouped.transform("sum")
  345:     expected = DataFrame({"A": [2, 8, 2, 8, 8]})
  346:     tm.assert_frame_equal(result, expected)
  347: 
  348:     result = grouped.transform(len)
  349:     expected = DataFrame({"A": [2, 3, 2, 3, 3]})
  350:     tm.assert_frame_equal(result, expected)
  351: 
  352: 
  353: def test_filter_and_transform_with_non_unique_int_index():
  354:     # GH4620
  355:     index = [1, 1, 1, 2, 1, 1, 0, 1]
  356:     df = DataFrame(
  357:         {"pid": [1, 1, 1, 2, 2, 3, 3, 3], "tag": [23, 45, 62, 24, 45, 34, 25, 62]},
  358:         index=index,
  359:     )
  360:     grouped_df = df.groupby("tag")
  361:     ser = df["pid"]
  362:     grouped_ser = ser.groupby(df["tag"])
  363:     expected_indexes = [1, 2, 4, 7]
  364: 
  365:     # Filter DataFrame
  366:     actual = grouped_df.filter(lambda x: len(x) > 1)
  367:     expected = df.iloc[expected_indexes]
  368:     tm.assert_frame_equal(actual, expected)
  369: 
  370:     actual = grouped_df.filter(lambda x: len(x) > 1, dropna=False)
  371:     # Cast to avoid upcast when setting nan below
  372:     expected = df.copy().astype("float64")
  373:     expected.iloc[[0, 3, 5, 6]] = np.nan
  374:     tm.assert_frame_equal(actual, expected)
  375: 
  376:     # Filter Series
  377:     actual = grouped_ser.filter(lambda x: len(x) > 1)
  378:     expected = ser.take(expected_indexes)
  379:     tm.assert_series_equal(actual, expected)
  380: 
  381:     actual = grouped_ser.filter(lambda x: len(x) > 1, dropna=False)
  382:     expected = Series([np.nan, 1, 1, np.nan, 2, np.nan, np.nan, 3], index, name="pid")
  383:     # ^ made manually because this can get confusing!
  384:     tm.assert_series_equal(actual, expected)
  385: 
  386:     # Transform Series
  387:     actual = grouped_ser.transform(len)
  388:     expected = Series([1, 2, 2, 1, 2, 1, 1, 2], index, name="pid")
  389:     tm.assert_series_equal(actual, expected)
  390: 
  391:     # Transform (a column from) DataFrameGroupBy
  392:     actual = grouped_df.pid.transform(len)
  393:     tm.assert_series_equal(actual, expected)
  394: 
  395: 
  396: def test_filter_and_transform_with_multiple_non_unique_int_index():
  397:     # GH4620
  398:     index = [1, 1, 1, 2, 0, 0, 0, 1]
  399:     df = DataFrame(
  400:         {"pid": [1, 1, 1, 2, 2, 3, 3, 3], "tag": [23, 45, 62, 24, 45, 34, 25, 62]},
  401:         index=index,
  402:     )
  403:     grouped_df = df.groupby("tag")
  404:     ser = df["pid"]
  405:     grouped_ser = ser.groupby(df["tag"])
  406:     expected_indexes = [1, 2, 4, 7]
  407: 
  408:     # Filter DataFrame
  409:     actual = grouped_df.filter(lambda x: len(x) > 1)
  410:     expected = df.iloc[expected_indexes]
  411:     tm.assert_frame_equal(actual, expected)
  412: 
  413:     actual = grouped_df.filter(lambda x: len(x) > 1, dropna=False)
  414:     # Cast to avoid upcast when setting nan below
  415:     expected = df.copy().astype("float64")
  416:     expected.iloc[[0, 3, 5, 6]] = np.nan
  417:     tm.assert_frame_equal(actual, expected)
  418: 
  419:     # Filter Series
  420:     actual = grouped_ser.filter(lambda x: len(x) > 1)
  421:     expected = ser.take(expected_indexes)
  422:     tm.assert_series_equal(actual, expected)
  423: 
  424:     actual = grouped_ser.filter(lambda x: len(x) > 1, dropna=False)
  425:     expected = Series([np.nan, 1, 1, np.nan, 2, np.nan, np.nan, 3], index, name="pid")
  426:     # ^ made manually because this can get confusing!
  427:     tm.assert_series_equal(actual, expected)
  428: 
  429:     # Transform Series
  430:     actual = grouped_ser.transform(len)
  431:     expected = Series([1, 2, 2, 1, 2, 1, 1, 2], index, name="pid")
  432:     tm.assert_series_equal(actual, expected)
  433: 
  434:     # Transform (a column from) DataFrameGroupBy
  435:     actual = grouped_df.pid.transform(len)
  436:     tm.assert_series_equal(actual, expected)
  437: 
  438: 
  439: def test_filter_and_transform_with_non_unique_float_index():
  440:     # GH4620
  441:     index = np.array([1, 1, 1, 2, 1, 1, 0, 1], dtype=float)
  442:     df = DataFrame(
  443:         {"pid": [1, 1, 1, 2, 2, 3, 3, 3], "tag": [23, 45, 62, 24, 45, 34, 25, 62]},
  444:         index=index,
  445:     )
  446:     grouped_df = df.groupby("tag")
  447:     ser = df["pid"]
  448:     grouped_ser = ser.groupby(df["tag"])
  449:     expected_indexes = [1, 2, 4, 7]
  450: 
  451:     # Filter DataFrame
  452:     actual = grouped_df.filter(lambda x: len(x) > 1)
  453:     expected = df.iloc[expected_indexes]
  454:     tm.assert_frame_equal(actual, expected)
  455: 
  456:     actual = grouped_df.filter(lambda x: len(x) > 1, dropna=False)
  457:     # Cast to avoid upcast when setting nan below
  458:     expected = df.copy().astype("float64")
  459:     expected.iloc[[0, 3, 5, 6]] = np.nan
  460:     tm.assert_frame_equal(actual, expected)
  461: 
  462:     # Filter Series
  463:     actual = grouped_ser.filter(lambda x: len(x) > 1)
  464:     expected = ser.take(expected_indexes)
  465:     tm.assert_series_equal(actual, expected)
  466: 
  467:     actual = grouped_ser.filter(lambda x: len(x) > 1, dropna=False)
  468:     expected = Series([np.nan, 1, 1, np.nan, 2, np.nan, np.nan, 3], index, name="pid")
  469:     # ^ made manually because this can get confusing!
  470:     tm.assert_series_equal(actual, expected)
  471: 
  472:     # Transform Series
  473:     actual = grouped_ser.transform(len)
  474:     expected = Series([1, 2, 2, 1, 2, 1, 1, 2], index, name="pid")
  475:     tm.assert_series_equal(actual, expected)
  476: 
  477:     # Transform (a column from) DataFrameGroupBy
  478:     actual = grouped_df.pid.transform(len)
  479:     tm.assert_series_equal(actual, expected)
  480: 
  481: 
  482: def test_filter_and_transform_with_non_unique_timestamp_index():
  483:     # GH4620
  484:     t0 = Timestamp("2013-09-30 00:05:00")
  485:     t1 = Timestamp("2013-10-30 00:05:00")
  486:     t2 = Timestamp("2013-11-30 00:05:00")
  487:     index = [t1, t1, t1, t2, t1, t1, t0, t1]
  488:     df = DataFrame(
  489:         {"pid": [1, 1, 1, 2, 2, 3, 3, 3], "tag": [23, 45, 62, 24, 45, 34, 25, 62]},
  490:         index=index,
  491:     )
  492:     grouped_df = df.groupby("tag")
  493:     ser = df["pid"]
  494:     grouped_ser = ser.groupby(df["tag"])
  495:     expected_indexes = [1, 2, 4, 7]
  496: 
  497:     # Filter DataFrame
  498:     actual = grouped_df.filter(lambda x: len(x) > 1)
  499:     expected = df.iloc[expected_indexes]
  500:     tm.assert_frame_equal(actual, expected)
  501: 
  502:     actual = grouped_df.filter(lambda x: len(x) > 1, dropna=False)
  503:     # Cast to avoid upcast when setting nan below
  504:     expected = df.copy().astype("float64")
  505:     expected.iloc[[0, 3, 5, 6]] = np.nan
  506:     tm.assert_frame_equal(actual, expected)
  507: 
  508:     # Filter Series
  509:     actual = grouped_ser.filter(lambda x: len(x) > 1)
  510:     expected = ser.take(expected_indexes)
  511:     tm.assert_series_equal(actual, expected)
  512: 
  513:     actual = grouped_ser.filter(lambda x: len(x) > 1, dropna=False)
  514:     expected = Series([np.nan, 1, 1, np.nan, 2, np.nan, np.nan, 3], index, name="pid")
  515:     # ^ made manually because this can get confusing!
  516:     tm.assert_series_equal(actual, expected)
  517: 
  518:     # Transform Series
  519:     actual = grouped_ser.transform(len)
  520:     expected = Series([1, 2, 2, 1, 2, 1, 1, 2], index, name="pid")
  521:     tm.assert_series_equal(actual, expected)
  522: 
  523:     # Transform (a column from) DataFrameGroupBy
  524:     actual = grouped_df.pid.transform(len)
  525:     tm.assert_series_equal(actual, expected)
  526: 
  527: 
  528: def test_filter_and_transform_with_non_unique_string_index():
  529:     # GH4620
  530:     index = list("bbbcbbab")
  531:     df = DataFrame(
  532:         {"pid": [1, 1, 1, 2, 2, 3, 3, 3], "tag": [23, 45, 62, 24, 45, 34, 25, 62]},
  533:         index=index,
  534:     )
  535:     grouped_df = df.groupby("tag")
  536:     ser = df["pid"]
  537:     grouped_ser = ser.groupby(df["tag"])
  538:     expected_indexes = [1, 2, 4, 7]
  539: 
  540:     # Filter DataFrame
  541:     actual = grouped_df.filter(lambda x: len(x) > 1)
  542:     expected = df.iloc[expected_indexes]
  543:     tm.assert_frame_equal(actual, expected)
  544: 
  545:     actual = grouped_df.filter(lambda x: len(x) > 1, dropna=False)
  546:     # Cast to avoid upcast when setting nan below
  547:     expected = df.copy().astype("float64")
  548:     expected.iloc[[0, 3, 5, 6]] = np.nan
  549:     tm.assert_frame_equal(actual, expected)
  550: 
  551:     # Filter Series
  552:     actual = grouped_ser.filter(lambda x: len(x) > 1)
  553:     expected = ser.take(expected_indexes)
  554:     tm.assert_series_equal(actual, expected)
  555: 
  556:     actual = grouped_ser.filter(lambda x: len(x) > 1, dropna=False)
  557:     expected = Series([np.nan, 1, 1, np.nan, 2, np.nan, np.nan, 3], index, name="pid")
  558:     # ^ made manually because this can get confusing!
  559:     tm.assert_series_equal(actual, expected)
  560: 
  561:     # Transform Series
  562:     actual = grouped_ser.transform(len)
  563:     expected = Series([1, 2, 2, 1, 2, 1, 1, 2], index, name="pid")
  564:     tm.assert_series_equal(actual, expected)
  565: 
  566:     # Transform (a column from) DataFrameGroupBy
  567:     actual = grouped_df.pid.transform(len)
  568:     tm.assert_series_equal(actual, expected)
  569: 
  570: 
  571: def test_filter_has_access_to_grouped_cols():
  572:     df = DataFrame([[1, 2], [1, 3], [5, 6]], columns=["A", "B"])
  573:     g = df.groupby("A")
  574:     # previously didn't have access to col A #????
  575:     filt = g.filter(lambda x: x["A"].sum() == 2)
  576:     tm.assert_frame_equal(filt, df.iloc[[0, 1]])
  577: 
  578: 
  579: def test_filter_enforces_scalarness():
  580:     df = DataFrame(
  581:         [
  582:             ["best", "a", "x"],
  583:             ["worst", "b", "y"],
  584:             ["best", "c", "x"],
  585:             ["best", "d", "y"],
  586:             ["worst", "d", "y"],
  587:             ["worst", "d", "y"],
  588:             ["best", "d", "z"],
  589:         ],
  590:         columns=["a", "b", "c"],
  591:     )
  592:     with pytest.raises(TypeError, match="filter function returned a.*"):
  593:         df.groupby("c").filter(lambda g: g["a"] == "best")
  594: 
  595: 
  596: def test_filter_non_bool_raises():
  597:     df = DataFrame(
  598:         [
  599:             ["best", "a", 1],
  600:             ["worst", "b", 1],
  601:             ["best", "c", 1],
  602:             ["best", "d", 1],
  603:             ["worst", "d", 1],
  604:             ["worst", "d", 1],
  605:             ["best", "d", 1],
  606:         ],
  607:         columns=["a", "b", "c"],
  608:     )
  609:     with pytest.raises(TypeError, match="filter function returned a.*"):
  610:         df.groupby("a").filter(lambda g: g.c.mean())
  611: 
  612: 
  613: def test_filter_dropna_with_empty_groups():
  614:     # GH 10780
  615:     data = Series(np.random.default_rng(2).random(9), index=np.repeat([1, 2, 3], 3))
  616:     grouped = data.groupby(level=0)
  617:     result_false = grouped.filter(lambda x: x.mean() > 1, dropna=False)
  618:     expected_false = Series([np.nan] * 9, index=np.repeat([1, 2, 3], 3))
  619:     tm.assert_series_equal(result_false, expected_false)
  620: 
  621:     result_true = grouped.filter(lambda x: x.mean() > 1, dropna=True)
  622:     expected_true = Series(index=pd.Index([], dtype=int), dtype=np.float64)
  623:     tm.assert_series_equal(result_true, expected_true)
  624: 
  625: 
  626: def test_filter_consistent_result_before_after_agg_func():
  627:     # GH 17091
  628:     df = DataFrame({"data": range(6), "key": list("ABCABC")})
  629:     grouper = df.groupby("key")
  630:     result = grouper.filter(lambda x: True)
  631:     expected = DataFrame({"data": range(6), "key": list("ABCABC")})
  632:     tm.assert_frame_equal(result, expected)
  633: 
  634:     grouper.sum()
  635:     result = grouper.filter(lambda x: True)
  636:     tm.assert_frame_equal(result, expected)
