    1: import re
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: from pandas._libs import lib
    7: 
    8: import pandas as pd
    9: from pandas import (
   10:     DataFrame,
   11:     Index,
   12:     Series,
   13:     Timestamp,
   14:     date_range,
   15: )
   16: import pandas._testing as tm
   17: from pandas.tests.groupby import get_groupby_method_args
   18: 
   19: 
   20: class TestNumericOnly:
   21:     # make sure that we are passing thru kwargs to our agg functions
   22: 
   23:     @pytest.fixture
   24:     def df(self):
   25:         # GH3668
   26:         # GH5724
   27:         df = DataFrame(
   28:             {
   29:                 "group": [1, 1, 2],
   30:                 "int": [1, 2, 3],
   31:                 "float": [4.0, 5.0, 6.0],
   32:                 "string": list("abc"),
   33:                 "category_string": Series(list("abc")).astype("category"),
   34:                 "category_int": [7, 8, 9],
   35:                 "datetime": date_range("20130101", periods=3),
   36:                 "datetimetz": date_range("20130101", periods=3, tz="US/Eastern"),
   37:                 "timedelta": pd.timedelta_range("1 s", periods=3, freq="s"),
   38:             },
   39:             columns=[
   40:                 "group",
   41:                 "int",
   42:                 "float",
   43:                 "string",
   44:                 "category_string",
   45:                 "category_int",
   46:                 "datetime",
   47:                 "datetimetz",
   48:                 "timedelta",
   49:             ],
   50:         )
   51:         return df
   52: 
   53:     @pytest.mark.parametrize("method", ["mean", "median"])
   54:     def test_averages(self, df, method):
   55:         # mean / median
   56:         expected_columns_numeric = Index(["int", "float", "category_int"])
   57: 
   58:         gb = df.groupby("group")
   59:         expected = DataFrame(
   60:             {
   61:                 "category_int": [7.5, 9],
   62:                 "float": [4.5, 6.0],
   63:                 "timedelta": [pd.Timedelta("1.5s"), pd.Timedelta("3s")],
   64:                 "int": [1.5, 3],
   65:                 "datetime": [
   66:                     Timestamp("2013-01-01 12:00:00"),
   67:                     Timestamp("2013-01-03 00:00:00"),
   68:                 ],
   69:                 "datetimetz": [
   70:                     Timestamp("2013-01-01 12:00:00", tz="US/Eastern"),
   71:                     Timestamp("2013-01-03 00:00:00", tz="US/Eastern"),
   72:                 ],
   73:             },
   74:             index=Index([1, 2], name="group"),
   75:             columns=[
   76:                 "int",
   77:                 "float",
   78:                 "category_int",
   79:             ],
   80:         )
   81: 
   82:         result = getattr(gb, method)(numeric_only=True)
   83:         tm.assert_frame_equal(result.reindex_like(expected), expected)
   84: 
   85:         expected_columns = expected.columns
   86: 
   87:         self._check(df, method, expected_columns, expected_columns_numeric)
   88: 
   89:     @pytest.mark.parametrize("method", ["min", "max"])
   90:     def test_extrema(self, df, method):
   91:         # TODO: min, max *should* handle
   92:         # categorical (ordered) dtype
   93: 
   94:         expected_columns = Index(
   95:             [
   96:                 "int",
   97:                 "float",
   98:                 "string",
   99:                 "category_int",
  100:                 "datetime",
  101:                 "datetimetz",
  102:                 "timedelta",
  103:             ]
  104:         )
  105:         expected_columns_numeric = expected_columns
  106: 
  107:         self._check(df, method, expected_columns, expected_columns_numeric)
  108: 
  109:     @pytest.mark.parametrize("method", ["first", "last"])
  110:     def test_first_last(self, df, method):
  111:         expected_columns = Index(
  112:             [
  113:                 "int",
  114:                 "float",
  115:                 "string",
  116:                 "category_string",
  117:                 "category_int",
  118:                 "datetime",
  119:                 "datetimetz",
  120:                 "timedelta",
  121:             ]
  122:         )
  123:         expected_columns_numeric = expected_columns
  124: 
  125:         self._check(df, method, expected_columns, expected_columns_numeric)
  126: 
  127:     @pytest.mark.parametrize("method", ["sum", "cumsum"])
  128:     def test_sum_cumsum(self, df, method):
  129:         expected_columns_numeric = Index(["int", "float", "category_int"])
  130:         expected_columns = Index(
  131:             ["int", "float", "string", "category_int", "timedelta"]
  132:         )
  133:         if method == "cumsum":
  134:             # cumsum loses string
  135:             expected_columns = Index(["int", "float", "category_int", "timedelta"])
  136: 
  137:         self._check(df, method, expected_columns, expected_columns_numeric)
  138: 
  139:     @pytest.mark.parametrize("method", ["prod", "cumprod"])
  140:     def test_prod_cumprod(self, df, method):
  141:         expected_columns = Index(["int", "float", "category_int"])
  142:         expected_columns_numeric = expected_columns
  143: 
  144:         self._check(df, method, expected_columns, expected_columns_numeric)
  145: 
  146:     @pytest.mark.parametrize("method", ["cummin", "cummax"])
  147:     def test_cummin_cummax(self, df, method):
  148:         # like min, max, but don't include strings
  149:         expected_columns = Index(
  150:             ["int", "float", "category_int", "datetime", "datetimetz", "timedelta"]
  151:         )
  152: 
  153:         # GH#15561: numeric_only=False set by default like min/max
  154:         expected_columns_numeric = expected_columns
  155: 
  156:         self._check(df, method, expected_columns, expected_columns_numeric)
  157: 
  158:     def _check(self, df, method, expected_columns, expected_columns_numeric):
  159:         gb = df.groupby("group")
  160: 
  161:         # object dtypes for transformations are not implemented in Cython and
  162:         # have no Python fallback
  163:         exception = NotImplementedError if method.startswith("cum") else TypeError
  164: 
  165:         if method in ("min", "max", "cummin", "cummax", "cumsum", "cumprod"):
  166:             # The methods default to numeric_only=False and raise TypeError
  167:             msg = "|".join(
  168:                 [
  169:                     "Categorical is not ordered",
  170:                     f"Cannot perform {method} with non-ordered Categorical",
  171:                     re.escape(f"agg function failed [how->{method},dtype->object]"),
  172:                     # cumsum/cummin/cummax/cumprod
  173:                     "function is not implemented for this dtype",
  174:                 ]
  175:             )
  176:             with pytest.raises(exception, match=msg):
  177:                 getattr(gb, method)()
  178:         elif method in ("sum", "mean", "median", "prod"):
  179:             msg = "|".join(
  180:                 [
  181:                     "category type does not support sum operations",
  182:                     re.escape(f"agg function failed [how->{method},dtype->object]"),
  183:                     re.escape(f"agg function failed [how->{method},dtype->string]"),
  184:                 ]
  185:             )
  186:             with pytest.raises(exception, match=msg):
  187:                 getattr(gb, method)()
  188:         else:
  189:             result = getattr(gb, method)()
  190:             tm.assert_index_equal(result.columns, expected_columns_numeric)
  191: 
  192:         if method not in ("first", "last"):
  193:             msg = "|".join(
  194:                 [
  195:                     "Categorical is not ordered",
  196:                     "category type does not support",
  197:                     "function is not implemented for this dtype",
  198:                     f"Cannot perform {method} with non-ordered Categorical",
  199:                     re.escape(f"agg function failed [how->{method},dtype->object]"),
  200:                     re.escape(f"agg function failed [how->{method},dtype->string]"),
  201:                 ]
  202:             )
  203:             with pytest.raises(exception, match=msg):
  204:                 getattr(gb, method)(numeric_only=False)
  205:         else:
  206:             result = getattr(gb, method)(numeric_only=False)
  207:             tm.assert_index_equal(result.columns, expected_columns)
  208: 
  209: 
  210: @pytest.mark.parametrize("numeric_only", [True, False, None])
  211: def test_axis1_numeric_only(request, groupby_func, numeric_only, using_infer_string):
  212:     if groupby_func in ("idxmax", "idxmin"):
  213:         pytest.skip("idxmax and idx_min tested in test_idxmin_idxmax_axis1")
  214:     if groupby_func in ("corrwith", "skew"):
  215:         msg = "GH#47723 groupby.corrwith and skew do not correctly implement axis=1"
  216:         request.applymarker(pytest.mark.xfail(reason=msg))
  217: 
  218:     df = DataFrame(
  219:         np.random.default_rng(2).standard_normal((10, 4)), columns=["A", "B", "C", "D"]
  220:     )
  221:     df["E"] = "x"
  222:     groups = [1, 2, 3, 1, 2, 3, 1, 2, 3, 4]
  223:     gb = df.groupby(groups)
  224:     method = getattr(gb, groupby_func)
  225:     args = get_groupby_method_args(groupby_func, df)
  226:     kwargs = {"axis": 1}
  227:     if numeric_only is not None:
  228:         # when numeric_only is None we don't pass any argument
  229:         kwargs["numeric_only"] = numeric_only
  230: 
  231:     # Functions without numeric_only and axis args
  232:     no_args = ("cumprod", "cumsum", "diff", "fillna", "pct_change", "rank", "shift")
  233:     # Functions with axis args
  234:     has_axis = (
  235:         "cumprod",
  236:         "cumsum",
  237:         "diff",
  238:         "pct_change",
  239:         "rank",
  240:         "shift",
  241:         "cummax",
  242:         "cummin",
  243:         "idxmin",
  244:         "idxmax",
  245:         "fillna",
  246:     )
  247:     warn_msg = f"DataFrameGroupBy.{groupby_func} with axis=1 is deprecated"
  248:     if numeric_only is not None and groupby_func in no_args:
  249:         msg = "got an unexpected keyword argument 'numeric_only'"
  250:         if groupby_func in ["cumprod", "cumsum"]:
  251:             with pytest.raises(TypeError, match=msg):
  252:                 with tm.assert_produces_warning(FutureWarning, match=warn_msg):
  253:                     method(*args, **kwargs)
  254:         else:
  255:             with pytest.raises(TypeError, match=msg):
  256:                 method(*args, **kwargs)
  257:     elif groupby_func not in has_axis:
  258:         msg = "got an unexpected keyword argument 'axis'"
  259:         with pytest.raises(TypeError, match=msg):
  260:             method(*args, **kwargs)
  261:     # fillna and shift are successful even on object dtypes
  262:     elif (numeric_only is None or not numeric_only) and groupby_func not in (
  263:         "fillna",
  264:         "shift",
  265:     ):
  266:         msgs = (
  267:             # cummax, cummin, rank
  268:             "not supported between instances of",
  269:             # cumprod
  270:             "can't multiply sequence by non-int of type 'float'",
  271:             # cumsum, diff, pct_change
  272:             "unsupported operand type",
  273:             "has no kernel",
  274:         )
  275:         if using_infer_string:
  276:             import pyarrow as pa
  277: 
  278:             errs = (TypeError, pa.lib.ArrowNotImplementedError)
  279:         else:
  280:             errs = TypeError
  281:         with pytest.raises(errs, match=f"({'|'.join(msgs)})"):
  282:             with tm.assert_produces_warning(FutureWarning, match=warn_msg):
  283:                 method(*args, **kwargs)
  284:     else:
  285:         with tm.assert_produces_warning(FutureWarning, match=warn_msg):
  286:             result = method(*args, **kwargs)
  287: 
  288:         df_expected = df.drop(columns="E").T if numeric_only else df.T
  289:         expected = getattr(df_expected, groupby_func)(*args).T
  290:         if groupby_func == "shift" and not numeric_only:
  291:             # shift with axis=1 leaves the leftmost column as numeric
  292:             # but transposing for expected gives us object dtype
  293:             expected = expected.astype(float)
  294: 
  295:         tm.assert_equal(result, expected)
  296: 
  297: 
  298: @pytest.mark.parametrize(
  299:     "kernel, has_arg",
  300:     [
  301:         ("all", False),
  302:         ("any", False),
  303:         ("bfill", False),
  304:         ("corr", True),
  305:         ("corrwith", True),
  306:         ("cov", True),
  307:         ("cummax", True),
  308:         ("cummin", True),
  309:         ("cumprod", True),
  310:         ("cumsum", True),
  311:         ("diff", False),
  312:         ("ffill", False),
  313:         ("fillna", False),
  314:         ("first", True),
  315:         ("idxmax", True),
  316:         ("idxmin", True),
  317:         ("last", True),
  318:         ("max", True),
  319:         ("mean", True),
  320:         ("median", True),
  321:         ("min", True),
  322:         ("nth", False),
  323:         ("nunique", False),
  324:         ("pct_change", False),
  325:         ("prod", True),
  326:         ("quantile", True),
  327:         ("sem", True),
  328:         ("skew", True),
  329:         ("std", True),
  330:         ("sum", True),
  331:         ("var", True),
  332:     ],
  333: )
  334: @pytest.mark.parametrize("numeric_only", [True, False, lib.no_default])
  335: @pytest.mark.parametrize("keys", [["a1"], ["a1", "a2"]])
  336: def test_numeric_only(kernel, has_arg, numeric_only, keys):
  337:     # GH#46072
  338:     # drops_nuisance: Whether the op drops nuisance columns even when numeric_only=False
  339:     # has_arg: Whether the op has a numeric_only arg
  340:     df = DataFrame({"a1": [1, 1], "a2": [2, 2], "a3": [5, 6], "b": 2 * [object]})
  341: 
  342:     args = get_groupby_method_args(kernel, df)
  343:     kwargs = {} if numeric_only is lib.no_default else {"numeric_only": numeric_only}
  344: 
  345:     gb = df.groupby(keys)
  346:     method = getattr(gb, kernel)
  347:     if has_arg and numeric_only is True:
  348:         # Cases where b does not appear in the result
  349:         result = method(*args, **kwargs)
  350:         assert "b" not in result.columns
  351:     elif (
  352:         # kernels that work on any dtype and have numeric_only arg
  353:         kernel in ("first", "last")
  354:         or (
  355:             # kernels that work on any dtype and don't have numeric_only arg
  356:             kernel in ("any", "all", "bfill", "ffill", "fillna", "nth", "nunique")
  357:             and numeric_only is lib.no_default
  358:         )
  359:     ):
  360:         warn = FutureWarning if kernel == "fillna" else None
  361:         msg = "DataFrameGroupBy.fillna is deprecated"
  362:         with tm.assert_produces_warning(warn, match=msg):
  363:             result = method(*args, **kwargs)
  364:         assert "b" in result.columns
  365:     elif has_arg:
  366:         assert numeric_only is not True
  367:         # kernels that are successful on any dtype were above; this will fail
  368: 
  369:         # object dtypes for transformations are not implemented in Cython and
  370:         # have no Python fallback
  371:         exception = NotImplementedError if kernel.startswith("cum") else TypeError
  372: 
  373:         msg = "|".join(
  374:             [
  375:                 "not allowed for this dtype",
  376:                 "cannot be performed against 'object' dtypes",
  377:                 # On PY39 message is "a number"; on PY310 and after is "a real number"
  378:                 "must be a string or a.* number",
  379:                 "unsupported operand type",
  380:                 "function is not implemented for this dtype",
  381:                 re.escape(f"agg function failed [how->{kernel},dtype->object]"),
  382:             ]
  383:         )
  384:         if kernel == "idxmin":
  385:             msg = "'<' not supported between instances of 'type' and 'type'"
  386:         elif kernel == "idxmax":
  387:             msg = "'>' not supported between instances of 'type' and 'type'"
  388:         with pytest.raises(exception, match=msg):
  389:             method(*args, **kwargs)
  390:     elif not has_arg and numeric_only is not lib.no_default:
  391:         with pytest.raises(
  392:             TypeError, match="got an unexpected keyword argument 'numeric_only'"
  393:         ):
  394:             method(*args, **kwargs)
  395:     else:
  396:         assert kernel in ("diff", "pct_change")
  397:         assert numeric_only is lib.no_default
  398:         # Doesn't have numeric_only argument and fails on nuisance columns
  399:         with pytest.raises(TypeError, match=r"unsupported operand type"):
  400:             method(*args, **kwargs)
  401: 
  402: 
  403: @pytest.mark.filterwarnings("ignore:Downcasting object dtype arrays:FutureWarning")
  404: @pytest.mark.parametrize("dtype", [bool, int, float, object])
  405: def test_deprecate_numeric_only_series(dtype, groupby_func, request):
  406:     # GH#46560
  407:     grouper = [0, 0, 1]
  408: 
  409:     ser = Series([1, 0, 0], dtype=dtype)
  410:     gb = ser.groupby(grouper)
  411: 
  412:     if groupby_func == "corrwith":
  413:         # corrwith is not implemented on SeriesGroupBy
  414:         assert not hasattr(gb, groupby_func)
  415:         return
  416: 
  417:     method = getattr(gb, groupby_func)
  418: 
  419:     expected_ser = Series([1, 0, 0])
  420:     expected_gb = expected_ser.groupby(grouper)
  421:     expected_method = getattr(expected_gb, groupby_func)
  422: 
  423:     args = get_groupby_method_args(groupby_func, ser)
  424: 
  425:     fails_on_numeric_object = (
  426:         "corr",
  427:         "cov",
  428:         "cummax",
  429:         "cummin",
  430:         "cumprod",
  431:         "cumsum",
  432:         "quantile",
  433:     )
  434:     # ops that give an object result on object input
  435:     obj_result = (
  436:         "first",
  437:         "last",
  438:         "nth",
  439:         "bfill",
  440:         "ffill",
  441:         "shift",
  442:         "sum",
  443:         "diff",
  444:         "pct_change",
  445:         "var",
  446:         "mean",
  447:         "median",
  448:         "min",
  449:         "max",
  450:         "prod",
  451:         "skew",
  452:     )
  453: 
  454:     # Test default behavior; kernels that fail may be enabled in the future but kernels
  455:     # that succeed should not be allowed to fail (without deprecation, at least)
  456:     if groupby_func in fails_on_numeric_object and dtype is object:
  457:         if groupby_func == "quantile":
  458:             msg = "cannot be performed against 'object' dtypes"
  459:         else:
  460:             msg = "is not supported for object dtype"
  461:         warn = FutureWarning if groupby_func == "fillna" else None
  462:         warn_msg = "DataFrameGroupBy.fillna is deprecated"
  463:         with tm.assert_produces_warning(warn, match=warn_msg):
  464:             with pytest.raises(TypeError, match=msg):
  465:                 method(*args)
  466:     elif dtype is object:
  467:         warn = FutureWarning if groupby_func == "fillna" else None
  468:         warn_msg = "SeriesGroupBy.fillna is deprecated"
  469:         with tm.assert_produces_warning(warn, match=warn_msg):
  470:             result = method(*args)
  471:         with tm.assert_produces_warning(warn, match=warn_msg):
  472:             expected = expected_method(*args)
  473:         if groupby_func in obj_result:
  474:             expected = expected.astype(object)
  475:         tm.assert_series_equal(result, expected)
  476: 
  477:     has_numeric_only = (
  478:         "first",
  479:         "last",
  480:         "max",
  481:         "mean",
  482:         "median",
  483:         "min",
  484:         "prod",
  485:         "quantile",
  486:         "sem",
  487:         "skew",
  488:         "std",
  489:         "sum",
  490:         "var",
  491:         "cummax",
  492:         "cummin",
  493:         "cumprod",
  494:         "cumsum",
  495:     )
  496:     if groupby_func not in has_numeric_only:
  497:         msg = "got an unexpected keyword argument 'numeric_only'"
  498:         with pytest.raises(TypeError, match=msg):
  499:             method(*args, numeric_only=True)
  500:     elif dtype is object:
  501:         msg = "|".join(
  502:             [
  503:                 "SeriesGroupBy.sem called with numeric_only=True and dtype object",
  504:                 "Series.skew does not allow numeric_only=True with non-numeric",
  505:                 "cum(sum|prod|min|max) is not supported for object dtype",
  506:                 r"Cannot use numeric_only=True with SeriesGroupBy\..* and non-numeric",
  507:             ]
  508:         )
  509:         with pytest.raises(TypeError, match=msg):
  510:             method(*args, numeric_only=True)
  511:     elif dtype == bool and groupby_func == "quantile":
  512:         msg = "Allowing bool dtype in SeriesGroupBy.quantile"
  513:         with tm.assert_produces_warning(FutureWarning, match=msg):
  514:             # GH#51424
  515:             result = method(*args, numeric_only=True)
  516:             expected = method(*args, numeric_only=False)
  517:         tm.assert_series_equal(result, expected)
  518:     else:
  519:         result = method(*args, numeric_only=True)
  520:         expected = method(*args, numeric_only=False)
  521:         tm.assert_series_equal(result, expected)
