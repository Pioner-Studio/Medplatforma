    1: import numpy as np
    2: import pytest
    3: 
    4: import pandas as pd
    5: from pandas import (
    6:     DataFrame,
    7:     Index,
    8: )
    9: import pandas._testing as tm
   10: 
   11: 
   12: @pytest.mark.parametrize(
   13:     "interpolation", ["linear", "lower", "higher", "nearest", "midpoint"]
   14: )
   15: @pytest.mark.parametrize(
   16:     "a_vals,b_vals",
   17:     [
   18:         # Ints
   19:         ([1, 2, 3, 4, 5], [5, 4, 3, 2, 1]),
   20:         ([1, 2, 3, 4], [4, 3, 2, 1]),
   21:         ([1, 2, 3, 4, 5], [4, 3, 2, 1]),
   22:         # Floats
   23:         ([1.0, 2.0, 3.0, 4.0, 5.0], [5.0, 4.0, 3.0, 2.0, 1.0]),
   24:         # Missing data
   25:         ([1.0, np.nan, 3.0, np.nan, 5.0], [5.0, np.nan, 3.0, np.nan, 1.0]),
   26:         ([np.nan, 4.0, np.nan, 2.0, np.nan], [np.nan, 4.0, np.nan, 2.0, np.nan]),
   27:         # Timestamps
   28:         (
   29:             pd.date_range("1/1/18", freq="D", periods=5),
   30:             pd.date_range("1/1/18", freq="D", periods=5)[::-1],
   31:         ),
   32:         (
   33:             pd.date_range("1/1/18", freq="D", periods=5).as_unit("s"),
   34:             pd.date_range("1/1/18", freq="D", periods=5)[::-1].as_unit("s"),
   35:         ),
   36:         # All NA
   37:         ([np.nan] * 5, [np.nan] * 5),
   38:     ],
   39: )
   40: @pytest.mark.parametrize("q", [0, 0.25, 0.5, 0.75, 1])
   41: def test_quantile(interpolation, a_vals, b_vals, q, request):
   42:     if (
   43:         interpolation == "nearest"
   44:         and q == 0.5
   45:         and isinstance(b_vals, list)
   46:         and b_vals == [4, 3, 2, 1]
   47:     ):
   48:         request.applymarker(
   49:             pytest.mark.xfail(
   50:                 reason="Unclear numpy expectation for nearest "
   51:                 "result with equidistant data"
   52:             )
   53:         )
   54:     all_vals = pd.concat([pd.Series(a_vals), pd.Series(b_vals)])
   55: 
   56:     a_expected = pd.Series(a_vals).quantile(q, interpolation=interpolation)
   57:     b_expected = pd.Series(b_vals).quantile(q, interpolation=interpolation)
   58: 
   59:     df = DataFrame({"key": ["a"] * len(a_vals) + ["b"] * len(b_vals), "val": all_vals})
   60: 
   61:     expected = DataFrame(
   62:         [a_expected, b_expected], columns=["val"], index=Index(["a", "b"], name="key")
   63:     )
   64:     if all_vals.dtype.kind == "M" and expected.dtypes.values[0].kind == "M":
   65:         # TODO(non-nano): this should be unnecessary once array_to_datetime
   66:         #  correctly infers non-nano from Timestamp.unit
   67:         expected = expected.astype(all_vals.dtype)
   68:     result = df.groupby("key").quantile(q, interpolation=interpolation)
   69: 
   70:     tm.assert_frame_equal(result, expected)
   71: 
   72: 
   73: def test_quantile_array():
   74:     # https://github.com/pandas-dev/pandas/issues/27526
   75:     df = DataFrame({"A": [0, 1, 2, 3, 4]})
   76:     key = np.array([0, 0, 1, 1, 1], dtype=np.int64)
   77:     result = df.groupby(key).quantile([0.25])
   78: 
   79:     index = pd.MultiIndex.from_product([[0, 1], [0.25]])
   80:     expected = DataFrame({"A": [0.25, 2.50]}, index=index)
   81:     tm.assert_frame_equal(result, expected)
   82: 
   83:     df = DataFrame({"A": [0, 1, 2, 3], "B": [4, 5, 6, 7]})
   84:     index = pd.MultiIndex.from_product([[0, 1], [0.25, 0.75]])
   85: 
   86:     key = np.array([0, 0, 1, 1], dtype=np.int64)
   87:     result = df.groupby(key).quantile([0.25, 0.75])
   88:     expected = DataFrame(
   89:         {"A": [0.25, 0.75, 2.25, 2.75], "B": [4.25, 4.75, 6.25, 6.75]}, index=index
   90:     )
   91:     tm.assert_frame_equal(result, expected)
   92: 
   93: 
   94: def test_quantile_array2():
   95:     # https://github.com/pandas-dev/pandas/pull/28085#issuecomment-524066959
   96:     arr = np.random.default_rng(2).integers(0, 5, size=(10, 3), dtype=np.int64)
   97:     df = DataFrame(arr, columns=list("ABC"))
   98:     result = df.groupby("A").quantile([0.3, 0.7])
   99:     expected = DataFrame(
  100:         {
  101:             "B": [2.0, 2.0, 2.3, 2.7, 0.3, 0.7, 3.2, 4.0, 0.3, 0.7],
  102:             "C": [1.0, 1.0, 1.9, 3.0999999999999996, 0.3, 0.7, 2.6, 3.0, 1.2, 2.8],
  103:         },
  104:         index=pd.MultiIndex.from_product(
  105:             [[0, 1, 2, 3, 4], [0.3, 0.7]], names=["A", None]
  106:         ),
  107:     )
  108:     tm.assert_frame_equal(result, expected)
  109: 
  110: 
  111: def test_quantile_array_no_sort():
  112:     df = DataFrame({"A": [0, 1, 2], "B": [3, 4, 5]})
  113:     key = np.array([1, 0, 1], dtype=np.int64)
  114:     result = df.groupby(key, sort=False).quantile([0.25, 0.5, 0.75])
  115:     expected = DataFrame(
  116:         {"A": [0.5, 1.0, 1.5, 1.0, 1.0, 1.0], "B": [3.5, 4.0, 4.5, 4.0, 4.0, 4.0]},
  117:         index=pd.MultiIndex.from_product([[1, 0], [0.25, 0.5, 0.75]]),
  118:     )
  119:     tm.assert_frame_equal(result, expected)
  120: 
  121:     result = df.groupby(key, sort=False).quantile([0.75, 0.25])
  122:     expected = DataFrame(
  123:         {"A": [1.5, 0.5, 1.0, 1.0], "B": [4.5, 3.5, 4.0, 4.0]},
  124:         index=pd.MultiIndex.from_product([[1, 0], [0.75, 0.25]]),
  125:     )
  126:     tm.assert_frame_equal(result, expected)
  127: 
  128: 
  129: def test_quantile_array_multiple_levels():
  130:     df = DataFrame(
  131:         {"A": [0, 1, 2], "B": [3, 4, 5], "c": ["a", "a", "a"], "d": ["a", "a", "b"]}
  132:     )
  133:     result = df.groupby(["c", "d"]).quantile([0.25, 0.75])
  134:     index = pd.MultiIndex.from_tuples(
  135:         [("a", "a", 0.25), ("a", "a", 0.75), ("a", "b", 0.25), ("a", "b", 0.75)],
  136:         names=["c", "d", None],
  137:     )
  138:     expected = DataFrame(
  139:         {"A": [0.25, 0.75, 2.0, 2.0], "B": [3.25, 3.75, 5.0, 5.0]}, index=index
  140:     )
  141:     tm.assert_frame_equal(result, expected)
  142: 
  143: 
  144: @pytest.mark.parametrize("frame_size", [(2, 3), (100, 10)])
  145: @pytest.mark.parametrize("groupby", [[0], [0, 1]])
  146: @pytest.mark.parametrize("q", [[0.5, 0.6]])
  147: def test_groupby_quantile_with_arraylike_q_and_int_columns(frame_size, groupby, q):
  148:     # GH30289
  149:     nrow, ncol = frame_size
  150:     df = DataFrame(np.array([ncol * [_ % 4] for _ in range(nrow)]), columns=range(ncol))
  151: 
  152:     idx_levels = [np.arange(min(nrow, 4))] * len(groupby) + [q]
  153:     idx_codes = [[x for x in range(min(nrow, 4)) for _ in q]] * len(groupby) + [
  154:         list(range(len(q))) * min(nrow, 4)
  155:     ]
  156:     expected_index = pd.MultiIndex(
  157:         levels=idx_levels, codes=idx_codes, names=groupby + [None]
  158:     )
  159:     expected_values = [
  160:         [float(x)] * (ncol - len(groupby)) for x in range(min(nrow, 4)) for _ in q
  161:     ]
  162:     expected_columns = [x for x in range(ncol) if x not in groupby]
  163:     expected = DataFrame(
  164:         expected_values, index=expected_index, columns=expected_columns
  165:     )
  166:     result = df.groupby(groupby).quantile(q)
  167: 
  168:     tm.assert_frame_equal(result, expected)
  169: 
  170: 
  171: def test_quantile_raises():
  172:     df = DataFrame([["foo", "a"], ["foo", "b"], ["foo", "c"]], columns=["key", "val"])
  173: 
  174:     with pytest.raises(TypeError, match="cannot be performed against 'object' dtypes"):
  175:         df.groupby("key").quantile()
  176: 
  177: 
  178: def test_quantile_out_of_bounds_q_raises():
  179:     # https://github.com/pandas-dev/pandas/issues/27470
  180:     df = DataFrame({"a": [0, 0, 0, 1, 1, 1], "b": range(6)})
  181:     g = df.groupby([0, 0, 0, 1, 1, 1])
  182:     with pytest.raises(ValueError, match="Got '50.0' instead"):
  183:         g.quantile(50)
  184: 
  185:     with pytest.raises(ValueError, match="Got '-1.0' instead"):
  186:         g.quantile(-1)
  187: 
  188: 
  189: def test_quantile_missing_group_values_no_segfaults():
  190:     # GH 28662
  191:     data = np.array([1.0, np.nan, 1.0])
  192:     df = DataFrame({"key": data, "val": range(3)})
  193: 
  194:     # Random segfaults; would have been guaranteed in loop
  195:     grp = df.groupby("key")
  196:     for _ in range(100):
  197:         grp.quantile()
  198: 
  199: 
  200: @pytest.mark.parametrize(
  201:     "key, val, expected_key, expected_val",
  202:     [
  203:         ([1.0, np.nan, 3.0, np.nan], range(4), [1.0, 3.0], [0.0, 2.0]),
  204:         ([1.0, np.nan, 2.0, 2.0], range(4), [1.0, 2.0], [0.0, 2.5]),
  205:         (["a", "b", "b", np.nan], range(4), ["a", "b"], [0, 1.5]),
  206:         ([0], [42], [0], [42.0]),
  207:         ([], [], np.array([], dtype="float64"), np.array([], dtype="float64")),
  208:     ],
  209: )
  210: def test_quantile_missing_group_values_correct_results(
  211:     key, val, expected_key, expected_val
  212: ):
  213:     # GH 28662, GH 33200, GH 33569
  214:     df = DataFrame({"key": key, "val": val})
  215: 
  216:     expected = DataFrame(
  217:         expected_val, index=Index(expected_key, name="key"), columns=["val"]
  218:     )
  219: 
  220:     grp = df.groupby("key")
  221: 
  222:     result = grp.quantile(0.5)
  223:     tm.assert_frame_equal(result, expected)
  224: 
  225:     result = grp.quantile()
  226:     tm.assert_frame_equal(result, expected)
  227: 
  228: 
  229: @pytest.mark.parametrize(
  230:     "values",
  231:     [
  232:         pd.array([1, 0, None] * 2, dtype="Int64"),
  233:         pd.array([True, False, None] * 2, dtype="boolean"),
  234:     ],
  235: )
  236: @pytest.mark.parametrize("q", [0.5, [0.0, 0.5, 1.0]])
  237: def test_groupby_quantile_nullable_array(values, q):
  238:     # https://github.com/pandas-dev/pandas/issues/33136
  239:     df = DataFrame({"a": ["x"] * 3 + ["y"] * 3, "b": values})
  240:     result = df.groupby("a")["b"].quantile(q)
  241: 
  242:     if isinstance(q, list):
  243:         idx = pd.MultiIndex.from_product((["x", "y"], q), names=["a", None])
  244:         true_quantiles = [0.0, 0.5, 1.0]
  245:     else:
  246:         idx = Index(["x", "y"], name="a")
  247:         true_quantiles = [0.5]
  248: 
  249:     expected = pd.Series(true_quantiles * 2, index=idx, name="b", dtype="Float64")
  250:     tm.assert_series_equal(result, expected)
  251: 
  252: 
  253: @pytest.mark.parametrize("q", [0.5, [0.0, 0.5, 1.0]])
  254: @pytest.mark.parametrize("numeric_only", [True, False])
  255: def test_groupby_quantile_raises_on_invalid_dtype(q, numeric_only):
  256:     df = DataFrame({"a": [1], "b": [2.0], "c": ["x"]})
  257:     if numeric_only:
  258:         result = df.groupby("a").quantile(q, numeric_only=numeric_only)
  259:         expected = df.groupby("a")[["b"]].quantile(q)
  260:         tm.assert_frame_equal(result, expected)
  261:     else:
  262:         with pytest.raises(
  263:             TypeError, match="'quantile' cannot be performed against 'object' dtypes!"
  264:         ):
  265:             df.groupby("a").quantile(q, numeric_only=numeric_only)
  266: 
  267: 
  268: def test_groupby_quantile_NA_float(any_float_dtype):
  269:     # GH#42849
  270:     df = DataFrame({"x": [1, 1], "y": [0.2, np.nan]}, dtype=any_float_dtype)
  271:     result = df.groupby("x")["y"].quantile(0.5)
  272:     exp_index = Index([1.0], dtype=any_float_dtype, name="x")
  273: 
  274:     if any_float_dtype in ["Float32", "Float64"]:
  275:         expected_dtype = any_float_dtype
  276:     else:
  277:         expected_dtype = None
  278: 
  279:     expected = pd.Series([0.2], dtype=expected_dtype, index=exp_index, name="y")
  280:     tm.assert_series_equal(result, expected)
  281: 
  282:     result = df.groupby("x")["y"].quantile([0.5, 0.75])
  283:     expected = pd.Series(
  284:         [0.2] * 2,
  285:         index=pd.MultiIndex.from_product((exp_index, [0.5, 0.75]), names=["x", None]),
  286:         name="y",
  287:         dtype=expected_dtype,
  288:     )
  289:     tm.assert_series_equal(result, expected)
  290: 
  291: 
  292: def test_groupby_quantile_NA_int(any_int_ea_dtype):
  293:     # GH#42849
  294:     df = DataFrame({"x": [1, 1], "y": [2, 5]}, dtype=any_int_ea_dtype)
  295:     result = df.groupby("x")["y"].quantile(0.5)
  296:     expected = pd.Series(
  297:         [3.5],
  298:         dtype="Float64",
  299:         index=Index([1], name="x", dtype=any_int_ea_dtype),
  300:         name="y",
  301:     )
  302:     tm.assert_series_equal(expected, result)
  303: 
  304:     result = df.groupby("x").quantile(0.5)
  305:     expected = DataFrame(
  306:         {"y": 3.5}, dtype="Float64", index=Index([1], name="x", dtype=any_int_ea_dtype)
  307:     )
  308:     tm.assert_frame_equal(result, expected)
  309: 
  310: 
  311: @pytest.mark.parametrize(
  312:     "interpolation, val1, val2", [("lower", 2, 2), ("higher", 2, 3), ("nearest", 2, 2)]
  313: )
  314: def test_groupby_quantile_all_na_group_masked(
  315:     interpolation, val1, val2, any_numeric_ea_dtype
  316: ):
  317:     # GH#37493
  318:     df = DataFrame(
  319:         {"a": [1, 1, 1, 2], "b": [1, 2, 3, pd.NA]}, dtype=any_numeric_ea_dtype
  320:     )
  321:     result = df.groupby("a").quantile(q=[0.5, 0.7], interpolation=interpolation)
  322:     expected = DataFrame(
  323:         {"b": [val1, val2, pd.NA, pd.NA]},
  324:         dtype=any_numeric_ea_dtype,
  325:         index=pd.MultiIndex.from_arrays(
  326:             [pd.Series([1, 1, 2, 2], dtype=any_numeric_ea_dtype), [0.5, 0.7, 0.5, 0.7]],
  327:             names=["a", None],
  328:         ),
  329:     )
  330:     tm.assert_frame_equal(result, expected)
  331: 
  332: 
  333: @pytest.mark.parametrize("interpolation", ["midpoint", "linear"])
  334: def test_groupby_quantile_all_na_group_masked_interp(
  335:     interpolation, any_numeric_ea_dtype
  336: ):
  337:     # GH#37493
  338:     df = DataFrame(
  339:         {"a": [1, 1, 1, 2], "b": [1, 2, 3, pd.NA]}, dtype=any_numeric_ea_dtype
  340:     )
  341:     result = df.groupby("a").quantile(q=[0.5, 0.75], interpolation=interpolation)
  342: 
  343:     if any_numeric_ea_dtype == "Float32":
  344:         expected_dtype = any_numeric_ea_dtype
  345:     else:
  346:         expected_dtype = "Float64"
  347: 
  348:     expected = DataFrame(
  349:         {"b": [2.0, 2.5, pd.NA, pd.NA]},
  350:         dtype=expected_dtype,
  351:         index=pd.MultiIndex.from_arrays(
  352:             [
  353:                 pd.Series([1, 1, 2, 2], dtype=any_numeric_ea_dtype),
  354:                 [0.5, 0.75, 0.5, 0.75],
  355:             ],
  356:             names=["a", None],
  357:         ),
  358:     )
  359:     tm.assert_frame_equal(result, expected)
  360: 
  361: 
  362: @pytest.mark.parametrize("dtype", ["Float64", "Float32"])
  363: def test_groupby_quantile_allNA_column(dtype):
  364:     # GH#42849
  365:     df = DataFrame({"x": [1, 1], "y": [pd.NA] * 2}, dtype=dtype)
  366:     result = df.groupby("x")["y"].quantile(0.5)
  367:     expected = pd.Series(
  368:         [np.nan], dtype=dtype, index=Index([1.0], dtype=dtype), name="y"
  369:     )
  370:     expected.index.name = "x"
  371:     tm.assert_series_equal(expected, result)
  372: 
  373: 
  374: def test_groupby_timedelta_quantile():
  375:     # GH: 29485
  376:     df = DataFrame(
  377:         {"value": pd.to_timedelta(np.arange(4), unit="s"), "group": [1, 1, 2, 2]}
  378:     )
  379:     result = df.groupby("group").quantile(0.99)
  380:     expected = DataFrame(
  381:         {
  382:             "value": [
  383:                 pd.Timedelta("0 days 00:00:00.990000"),
  384:                 pd.Timedelta("0 days 00:00:02.990000"),
  385:             ]
  386:         },
  387:         index=Index([1, 2], name="group"),
  388:     )
  389:     tm.assert_frame_equal(result, expected)
  390: 
  391: 
  392: def test_columns_groupby_quantile():
  393:     # GH 33795
  394:     df = DataFrame(
  395:         np.arange(12).reshape(3, -1),
  396:         index=list("XYZ"),
  397:         columns=pd.Series(list("ABAB"), name="col"),
  398:     )
  399:     msg = "DataFrame.groupby with axis=1 is deprecated"
  400:     with tm.assert_produces_warning(FutureWarning, match=msg):
  401:         gb = df.groupby("col", axis=1)
  402:     result = gb.quantile(q=[0.8, 0.2])
  403:     expected = DataFrame(
  404:         [
  405:             [1.6, 0.4, 2.6, 1.4],
  406:             [5.6, 4.4, 6.6, 5.4],
  407:             [9.6, 8.4, 10.6, 9.4],
  408:         ],
  409:         index=list("XYZ"),
  410:         columns=pd.MultiIndex.from_tuples(
  411:             [("A", 0.8), ("A", 0.2), ("B", 0.8), ("B", 0.2)], names=["col", None]
  412:         ),
  413:     )
  414: 
  415:     tm.assert_frame_equal(result, expected)
  416: 
  417: 
  418: def test_timestamp_groupby_quantile(unit):
  419:     # GH 33168
  420:     dti = pd.date_range(
  421:         start="2020-04-19 00:00:00", freq="1min", periods=100, tz="UTC", unit=unit
  422:     ).floor("1h")
  423:     df = DataFrame(
  424:         {
  425:             "timestamp": dti,
  426:             "category": list(range(1, 101)),
  427:             "value": list(range(101, 201)),
  428:         }
  429:     )
  430: 
  431:     result = df.groupby("timestamp").quantile([0.2, 0.8])
  432: 
  433:     mi = pd.MultiIndex.from_product([dti[::99], [0.2, 0.8]], names=("timestamp", None))
  434:     expected = DataFrame(
  435:         [
  436:             {"category": 12.8, "value": 112.8},
  437:             {"category": 48.2, "value": 148.2},
  438:             {"category": 68.8, "value": 168.8},
  439:             {"category": 92.2, "value": 192.2},
  440:         ],
  441:         index=mi,
  442:     )
  443: 
  444:     tm.assert_frame_equal(result, expected)
  445: 
  446: 
  447: def test_groupby_quantile_dt64tz_period():
  448:     # GH#51373
  449:     dti = pd.date_range("2016-01-01", periods=1000)
  450:     df = pd.Series(dti).to_frame().copy()
  451:     df[1] = dti.tz_localize("US/Pacific")
  452:     df[2] = dti.to_period("D")
  453:     df[3] = dti - dti[0]
  454:     df.iloc[-1] = pd.NaT
  455: 
  456:     by = np.tile(np.arange(5), 200)
  457:     gb = df.groupby(by)
  458: 
  459:     result = gb.quantile(0.5)
  460: 
  461:     # Check that we match the group-by-group result
  462:     exp = {i: df.iloc[i::5].quantile(0.5) for i in range(5)}
  463:     expected = DataFrame(exp).T.infer_objects()
  464:     expected.index = expected.index.astype(int)
  465: 
  466:     tm.assert_frame_equal(result, expected)
  467: 
  468: 
  469: def test_groupby_quantile_nonmulti_levels_order():
  470:     # Non-regression test for GH #53009
  471:     ind = pd.MultiIndex.from_tuples(
  472:         [
  473:             (0, "a", "B"),
  474:             (0, "a", "A"),
  475:             (0, "b", "B"),
  476:             (0, "b", "A"),
  477:             (1, "a", "B"),
  478:             (1, "a", "A"),
  479:             (1, "b", "B"),
  480:             (1, "b", "A"),
  481:         ],
  482:         names=["sample", "cat0", "cat1"],
  483:     )
  484:     ser = pd.Series(range(8), index=ind)
  485:     result = ser.groupby(level="cat1", sort=False).quantile([0.2, 0.8])
  486: 
  487:     qind = pd.MultiIndex.from_tuples(
  488:         [("B", 0.2), ("B", 0.8), ("A", 0.2), ("A", 0.8)], names=["cat1", None]
  489:     )
  490:     expected = pd.Series([1.2, 4.8, 2.2, 5.8], index=qind)
  491: 
  492:     tm.assert_series_equal(result, expected)
  493: 
  494:     # We need to check that index levels are not sorted
  495:     expected_levels = pd.core.indexes.frozen.FrozenList([["B", "A"], [0.2, 0.8]])
  496:     tm.assert_equal(result.index.levels, expected_levels)
