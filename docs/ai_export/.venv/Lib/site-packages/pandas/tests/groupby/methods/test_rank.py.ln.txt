    1: from datetime import datetime
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: import pandas as pd
    7: from pandas import (
    8:     DataFrame,
    9:     NaT,
   10:     Series,
   11:     concat,
   12: )
   13: import pandas._testing as tm
   14: 
   15: 
   16: def test_rank_unordered_categorical_typeerror():
   17:     # GH#51034 should be TypeError, not NotImplementedError
   18:     cat = pd.Categorical([], ordered=False)
   19:     ser = Series(cat)
   20:     df = ser.to_frame()
   21: 
   22:     msg = "Cannot perform rank with non-ordered Categorical"
   23: 
   24:     gb = ser.groupby(cat, observed=False)
   25:     with pytest.raises(TypeError, match=msg):
   26:         gb.rank()
   27: 
   28:     gb2 = df.groupby(cat, observed=False)
   29:     with pytest.raises(TypeError, match=msg):
   30:         gb2.rank()
   31: 
   32: 
   33: def test_rank_apply():
   34:     lev1 = np.array(["a" * 10] * 100, dtype=object)
   35:     lev2 = np.array(["b" * 10] * 130, dtype=object)
   36:     lab1 = np.random.default_rng(2).integers(0, 100, size=500, dtype=int)
   37:     lab2 = np.random.default_rng(2).integers(0, 130, size=500, dtype=int)
   38: 
   39:     df = DataFrame(
   40:         {
   41:             "value": np.random.default_rng(2).standard_normal(500),
   42:             "key1": lev1.take(lab1),
   43:             "key2": lev2.take(lab2),
   44:         }
   45:     )
   46: 
   47:     result = df.groupby(["key1", "key2"]).value.rank()
   48: 
   49:     expected = [piece.value.rank() for key, piece in df.groupby(["key1", "key2"])]
   50:     expected = concat(expected, axis=0)
   51:     expected = expected.reindex(result.index)
   52:     tm.assert_series_equal(result, expected)
   53: 
   54:     result = df.groupby(["key1", "key2"]).value.rank(pct=True)
   55: 
   56:     expected = [
   57:         piece.value.rank(pct=True) for key, piece in df.groupby(["key1", "key2"])
   58:     ]
   59:     expected = concat(expected, axis=0)
   60:     expected = expected.reindex(result.index)
   61:     tm.assert_series_equal(result, expected)
   62: 
   63: 
   64: @pytest.mark.parametrize("grps", [["qux"], ["qux", "quux"]])
   65: @pytest.mark.parametrize(
   66:     "vals",
   67:     [
   68:         np.array([2, 2, 8, 2, 6], dtype=dtype)
   69:         for dtype in ["i8", "i4", "i2", "i1", "u8", "u4", "u2", "u1", "f8", "f4", "f2"]
   70:     ]
   71:     + [
   72:         [
   73:             pd.Timestamp("2018-01-02"),
   74:             pd.Timestamp("2018-01-02"),
   75:             pd.Timestamp("2018-01-08"),
   76:             pd.Timestamp("2018-01-02"),
   77:             pd.Timestamp("2018-01-06"),
   78:         ],
   79:         [
   80:             pd.Timestamp("2018-01-02", tz="US/Pacific"),
   81:             pd.Timestamp("2018-01-02", tz="US/Pacific"),
   82:             pd.Timestamp("2018-01-08", tz="US/Pacific"),
   83:             pd.Timestamp("2018-01-02", tz="US/Pacific"),
   84:             pd.Timestamp("2018-01-06", tz="US/Pacific"),
   85:         ],
   86:         [
   87:             pd.Timestamp("2018-01-02") - pd.Timestamp(0),
   88:             pd.Timestamp("2018-01-02") - pd.Timestamp(0),
   89:             pd.Timestamp("2018-01-08") - pd.Timestamp(0),
   90:             pd.Timestamp("2018-01-02") - pd.Timestamp(0),
   91:             pd.Timestamp("2018-01-06") - pd.Timestamp(0),
   92:         ],
   93:         [
   94:             pd.Timestamp("2018-01-02").to_period("D"),
   95:             pd.Timestamp("2018-01-02").to_period("D"),
   96:             pd.Timestamp("2018-01-08").to_period("D"),
   97:             pd.Timestamp("2018-01-02").to_period("D"),
   98:             pd.Timestamp("2018-01-06").to_period("D"),
   99:         ],
  100:     ],
  101:     ids=lambda x: type(x[0]),
  102: )
  103: @pytest.mark.parametrize(
  104:     "ties_method,ascending,pct,exp",
  105:     [
  106:         ("average", True, False, [2.0, 2.0, 5.0, 2.0, 4.0]),
  107:         ("average", True, True, [0.4, 0.4, 1.0, 0.4, 0.8]),
  108:         ("average", False, False, [4.0, 4.0, 1.0, 4.0, 2.0]),
  109:         ("average", False, True, [0.8, 0.8, 0.2, 0.8, 0.4]),
  110:         ("min", True, False, [1.0, 1.0, 5.0, 1.0, 4.0]),
  111:         ("min", True, True, [0.2, 0.2, 1.0, 0.2, 0.8]),
  112:         ("min", False, False, [3.0, 3.0, 1.0, 3.0, 2.0]),
  113:         ("min", False, True, [0.6, 0.6, 0.2, 0.6, 0.4]),
  114:         ("max", True, False, [3.0, 3.0, 5.0, 3.0, 4.0]),
  115:         ("max", True, True, [0.6, 0.6, 1.0, 0.6, 0.8]),
  116:         ("max", False, False, [5.0, 5.0, 1.0, 5.0, 2.0]),
  117:         ("max", False, True, [1.0, 1.0, 0.2, 1.0, 0.4]),
  118:         ("first", True, False, [1.0, 2.0, 5.0, 3.0, 4.0]),
  119:         ("first", True, True, [0.2, 0.4, 1.0, 0.6, 0.8]),
  120:         ("first", False, False, [3.0, 4.0, 1.0, 5.0, 2.0]),
  121:         ("first", False, True, [0.6, 0.8, 0.2, 1.0, 0.4]),
  122:         ("dense", True, False, [1.0, 1.0, 3.0, 1.0, 2.0]),
  123:         ("dense", True, True, [1.0 / 3.0, 1.0 / 3.0, 3.0 / 3.0, 1.0 / 3.0, 2.0 / 3.0]),
  124:         ("dense", False, False, [3.0, 3.0, 1.0, 3.0, 2.0]),
  125:         ("dense", False, True, [3.0 / 3.0, 3.0 / 3.0, 1.0 / 3.0, 3.0 / 3.0, 2.0 / 3.0]),
  126:     ],
  127: )
  128: def test_rank_args(grps, vals, ties_method, ascending, pct, exp):
  129:     key = np.repeat(grps, len(vals))
  130: 
  131:     orig_vals = vals
  132:     vals = list(vals) * len(grps)
  133:     if isinstance(orig_vals, np.ndarray):
  134:         vals = np.array(vals, dtype=orig_vals.dtype)
  135: 
  136:     df = DataFrame({"key": key, "val": vals})
  137:     result = df.groupby("key").rank(method=ties_method, ascending=ascending, pct=pct)
  138: 
  139:     exp_df = DataFrame(exp * len(grps), columns=["val"])
  140:     tm.assert_frame_equal(result, exp_df)
  141: 
  142: 
  143: @pytest.mark.parametrize("grps", [["qux"], ["qux", "quux"]])
  144: @pytest.mark.parametrize(
  145:     "vals", [[-np.inf, -np.inf, np.nan, 1.0, np.nan, np.inf, np.inf]]
  146: )
  147: @pytest.mark.parametrize(
  148:     "ties_method,ascending,na_option,exp",
  149:     [
  150:         ("average", True, "keep", [1.5, 1.5, np.nan, 3, np.nan, 4.5, 4.5]),
  151:         ("average", True, "top", [3.5, 3.5, 1.5, 5.0, 1.5, 6.5, 6.5]),
  152:         ("average", True, "bottom", [1.5, 1.5, 6.5, 3.0, 6.5, 4.5, 4.5]),
  153:         ("average", False, "keep", [4.5, 4.5, np.nan, 3, np.nan, 1.5, 1.5]),
  154:         ("average", False, "top", [6.5, 6.5, 1.5, 5.0, 1.5, 3.5, 3.5]),
  155:         ("average", False, "bottom", [4.5, 4.5, 6.5, 3.0, 6.5, 1.5, 1.5]),
  156:         ("min", True, "keep", [1.0, 1.0, np.nan, 3.0, np.nan, 4.0, 4.0]),
  157:         ("min", True, "top", [3.0, 3.0, 1.0, 5.0, 1.0, 6.0, 6.0]),
  158:         ("min", True, "bottom", [1.0, 1.0, 6.0, 3.0, 6.0, 4.0, 4.0]),
  159:         ("min", False, "keep", [4.0, 4.0, np.nan, 3.0, np.nan, 1.0, 1.0]),
  160:         ("min", False, "top", [6.0, 6.0, 1.0, 5.0, 1.0, 3.0, 3.0]),
  161:         ("min", False, "bottom", [4.0, 4.0, 6.0, 3.0, 6.0, 1.0, 1.0]),
  162:         ("max", True, "keep", [2.0, 2.0, np.nan, 3.0, np.nan, 5.0, 5.0]),
  163:         ("max", True, "top", [4.0, 4.0, 2.0, 5.0, 2.0, 7.0, 7.0]),
  164:         ("max", True, "bottom", [2.0, 2.0, 7.0, 3.0, 7.0, 5.0, 5.0]),
  165:         ("max", False, "keep", [5.0, 5.0, np.nan, 3.0, np.nan, 2.0, 2.0]),
  166:         ("max", False, "top", [7.0, 7.0, 2.0, 5.0, 2.0, 4.0, 4.0]),
  167:         ("max", False, "bottom", [5.0, 5.0, 7.0, 3.0, 7.0, 2.0, 2.0]),
  168:         ("first", True, "keep", [1.0, 2.0, np.nan, 3.0, np.nan, 4.0, 5.0]),
  169:         ("first", True, "top", [3.0, 4.0, 1.0, 5.0, 2.0, 6.0, 7.0]),
  170:         ("first", True, "bottom", [1.0, 2.0, 6.0, 3.0, 7.0, 4.0, 5.0]),
  171:         ("first", False, "keep", [4.0, 5.0, np.nan, 3.0, np.nan, 1.0, 2.0]),
  172:         ("first", False, "top", [6.0, 7.0, 1.0, 5.0, 2.0, 3.0, 4.0]),
  173:         ("first", False, "bottom", [4.0, 5.0, 6.0, 3.0, 7.0, 1.0, 2.0]),
  174:         ("dense", True, "keep", [1.0, 1.0, np.nan, 2.0, np.nan, 3.0, 3.0]),
  175:         ("dense", True, "top", [2.0, 2.0, 1.0, 3.0, 1.0, 4.0, 4.0]),
  176:         ("dense", True, "bottom", [1.0, 1.0, 4.0, 2.0, 4.0, 3.0, 3.0]),
  177:         ("dense", False, "keep", [3.0, 3.0, np.nan, 2.0, np.nan, 1.0, 1.0]),
  178:         ("dense", False, "top", [4.0, 4.0, 1.0, 3.0, 1.0, 2.0, 2.0]),
  179:         ("dense", False, "bottom", [3.0, 3.0, 4.0, 2.0, 4.0, 1.0, 1.0]),
  180:     ],
  181: )
  182: def test_infs_n_nans(grps, vals, ties_method, ascending, na_option, exp):
  183:     # GH 20561
  184:     key = np.repeat(grps, len(vals))
  185:     vals = vals * len(grps)
  186:     df = DataFrame({"key": key, "val": vals})
  187:     result = df.groupby("key").rank(
  188:         method=ties_method, ascending=ascending, na_option=na_option
  189:     )
  190:     exp_df = DataFrame(exp * len(grps), columns=["val"])
  191:     tm.assert_frame_equal(result, exp_df)
  192: 
  193: 
  194: @pytest.mark.parametrize("grps", [["qux"], ["qux", "quux"]])
  195: @pytest.mark.parametrize(
  196:     "vals",
  197:     [
  198:         np.array([2, 2, np.nan, 8, 2, 6, np.nan, np.nan], dtype=dtype)
  199:         for dtype in ["f8", "f4", "f2"]
  200:     ]
  201:     + [
  202:         [
  203:             pd.Timestamp("2018-01-02"),
  204:             pd.Timestamp("2018-01-02"),
  205:             np.nan,
  206:             pd.Timestamp("2018-01-08"),
  207:             pd.Timestamp("2018-01-02"),
  208:             pd.Timestamp("2018-01-06"),
  209:             np.nan,
  210:             np.nan,
  211:         ],
  212:         [
  213:             pd.Timestamp("2018-01-02", tz="US/Pacific"),
  214:             pd.Timestamp("2018-01-02", tz="US/Pacific"),
  215:             np.nan,
  216:             pd.Timestamp("2018-01-08", tz="US/Pacific"),
  217:             pd.Timestamp("2018-01-02", tz="US/Pacific"),
  218:             pd.Timestamp("2018-01-06", tz="US/Pacific"),
  219:             np.nan,
  220:             np.nan,
  221:         ],
  222:         [
  223:             pd.Timestamp("2018-01-02") - pd.Timestamp(0),
  224:             pd.Timestamp("2018-01-02") - pd.Timestamp(0),
  225:             np.nan,
  226:             pd.Timestamp("2018-01-08") - pd.Timestamp(0),
  227:             pd.Timestamp("2018-01-02") - pd.Timestamp(0),
  228:             pd.Timestamp("2018-01-06") - pd.Timestamp(0),
  229:             np.nan,
  230:             np.nan,
  231:         ],
  232:         [
  233:             pd.Timestamp("2018-01-02").to_period("D"),
  234:             pd.Timestamp("2018-01-02").to_period("D"),
  235:             np.nan,
  236:             pd.Timestamp("2018-01-08").to_period("D"),
  237:             pd.Timestamp("2018-01-02").to_period("D"),
  238:             pd.Timestamp("2018-01-06").to_period("D"),
  239:             np.nan,
  240:             np.nan,
  241:         ],
  242:     ],
  243:     ids=lambda x: type(x[0]),
  244: )
  245: @pytest.mark.parametrize(
  246:     "ties_method,ascending,na_option,pct,exp",
  247:     [
  248:         (
  249:             "average",
  250:             True,
  251:             "keep",
  252:             False,
  253:             [2.0, 2.0, np.nan, 5.0, 2.0, 4.0, np.nan, np.nan],
  254:         ),
  255:         (
  256:             "average",
  257:             True,
  258:             "keep",
  259:             True,
  260:             [0.4, 0.4, np.nan, 1.0, 0.4, 0.8, np.nan, np.nan],
  261:         ),
  262:         (
  263:             "average",
  264:             False,
  265:             "keep",
  266:             False,
  267:             [4.0, 4.0, np.nan, 1.0, 4.0, 2.0, np.nan, np.nan],
  268:         ),
  269:         (
  270:             "average",
  271:             False,
  272:             "keep",
  273:             True,
  274:             [0.8, 0.8, np.nan, 0.2, 0.8, 0.4, np.nan, np.nan],
  275:         ),
  276:         ("min", True, "keep", False, [1.0, 1.0, np.nan, 5.0, 1.0, 4.0, np.nan, np.nan]),
  277:         ("min", True, "keep", True, [0.2, 0.2, np.nan, 1.0, 0.2, 0.8, np.nan, np.nan]),
  278:         (
  279:             "min",
  280:             False,
  281:             "keep",
  282:             False,
  283:             [3.0, 3.0, np.nan, 1.0, 3.0, 2.0, np.nan, np.nan],
  284:         ),
  285:         ("min", False, "keep", True, [0.6, 0.6, np.nan, 0.2, 0.6, 0.4, np.nan, np.nan]),
  286:         ("max", True, "keep", False, [3.0, 3.0, np.nan, 5.0, 3.0, 4.0, np.nan, np.nan]),
  287:         ("max", True, "keep", True, [0.6, 0.6, np.nan, 1.0, 0.6, 0.8, np.nan, np.nan]),
  288:         (
  289:             "max",
  290:             False,
  291:             "keep",
  292:             False,
  293:             [5.0, 5.0, np.nan, 1.0, 5.0, 2.0, np.nan, np.nan],
  294:         ),
  295:         ("max", False, "keep", True, [1.0, 1.0, np.nan, 0.2, 1.0, 0.4, np.nan, np.nan]),
  296:         (
  297:             "first",
  298:             True,
  299:             "keep",
  300:             False,
  301:             [1.0, 2.0, np.nan, 5.0, 3.0, 4.0, np.nan, np.nan],
  302:         ),
  303:         (
  304:             "first",
  305:             True,
  306:             "keep",
  307:             True,
  308:             [0.2, 0.4, np.nan, 1.0, 0.6, 0.8, np.nan, np.nan],
  309:         ),
  310:         (
  311:             "first",
  312:             False,
  313:             "keep",
  314:             False,
  315:             [3.0, 4.0, np.nan, 1.0, 5.0, 2.0, np.nan, np.nan],
  316:         ),
  317:         (
  318:             "first",
  319:             False,
  320:             "keep",
  321:             True,
  322:             [0.6, 0.8, np.nan, 0.2, 1.0, 0.4, np.nan, np.nan],
  323:         ),
  324:         (
  325:             "dense",
  326:             True,
  327:             "keep",
  328:             False,
  329:             [1.0, 1.0, np.nan, 3.0, 1.0, 2.0, np.nan, np.nan],
  330:         ),
  331:         (
  332:             "dense",
  333:             True,
  334:             "keep",
  335:             True,
  336:             [
  337:                 1.0 / 3.0,
  338:                 1.0 / 3.0,
  339:                 np.nan,
  340:                 3.0 / 3.0,
  341:                 1.0 / 3.0,
  342:                 2.0 / 3.0,
  343:                 np.nan,
  344:                 np.nan,
  345:             ],
  346:         ),
  347:         (
  348:             "dense",
  349:             False,
  350:             "keep",
  351:             False,
  352:             [3.0, 3.0, np.nan, 1.0, 3.0, 2.0, np.nan, np.nan],
  353:         ),
  354:         (
  355:             "dense",
  356:             False,
  357:             "keep",
  358:             True,
  359:             [
  360:                 3.0 / 3.0,
  361:                 3.0 / 3.0,
  362:                 np.nan,
  363:                 1.0 / 3.0,
  364:                 3.0 / 3.0,
  365:                 2.0 / 3.0,
  366:                 np.nan,
  367:                 np.nan,
  368:             ],
  369:         ),
  370:         ("average", True, "bottom", False, [2.0, 2.0, 7.0, 5.0, 2.0, 4.0, 7.0, 7.0]),
  371:         (
  372:             "average",
  373:             True,
  374:             "bottom",
  375:             True,
  376:             [0.25, 0.25, 0.875, 0.625, 0.25, 0.5, 0.875, 0.875],
  377:         ),
  378:         ("average", False, "bottom", False, [4.0, 4.0, 7.0, 1.0, 4.0, 2.0, 7.0, 7.0]),
  379:         (
  380:             "average",
  381:             False,
  382:             "bottom",
  383:             True,
  384:             [0.5, 0.5, 0.875, 0.125, 0.5, 0.25, 0.875, 0.875],
  385:         ),
  386:         ("min", True, "bottom", False, [1.0, 1.0, 6.0, 5.0, 1.0, 4.0, 6.0, 6.0]),
  387:         (
  388:             "min",
  389:             True,
  390:             "bottom",
  391:             True,
  392:             [0.125, 0.125, 0.75, 0.625, 0.125, 0.5, 0.75, 0.75],
  393:         ),
  394:         ("min", False, "bottom", False, [3.0, 3.0, 6.0, 1.0, 3.0, 2.0, 6.0, 6.0]),
  395:         (
  396:             "min",
  397:             False,
  398:             "bottom",
  399:             True,
  400:             [0.375, 0.375, 0.75, 0.125, 0.375, 0.25, 0.75, 0.75],
  401:         ),
  402:         ("max", True, "bottom", False, [3.0, 3.0, 8.0, 5.0, 3.0, 4.0, 8.0, 8.0]),
  403:         ("max", True, "bottom", True, [0.375, 0.375, 1.0, 0.625, 0.375, 0.5, 1.0, 1.0]),
  404:         ("max", False, "bottom", False, [5.0, 5.0, 8.0, 1.0, 5.0, 2.0, 8.0, 8.0]),
  405:         (
  406:             "max",
  407:             False,
  408:             "bottom",
  409:             True,
  410:             [0.625, 0.625, 1.0, 0.125, 0.625, 0.25, 1.0, 1.0],
  411:         ),
  412:         ("first", True, "bottom", False, [1.0, 2.0, 6.0, 5.0, 3.0, 4.0, 7.0, 8.0]),
  413:         (
  414:             "first",
  415:             True,
  416:             "bottom",
  417:             True,
  418:             [0.125, 0.25, 0.75, 0.625, 0.375, 0.5, 0.875, 1.0],
  419:         ),
  420:         ("first", False, "bottom", False, [3.0, 4.0, 6.0, 1.0, 5.0, 2.0, 7.0, 8.0]),
  421:         (
  422:             "first",
  423:             False,
  424:             "bottom",
  425:             True,
  426:             [0.375, 0.5, 0.75, 0.125, 0.625, 0.25, 0.875, 1.0],
  427:         ),
  428:         ("dense", True, "bottom", False, [1.0, 1.0, 4.0, 3.0, 1.0, 2.0, 4.0, 4.0]),
  429:         ("dense", True, "bottom", True, [0.25, 0.25, 1.0, 0.75, 0.25, 0.5, 1.0, 1.0]),
  430:         ("dense", False, "bottom", False, [3.0, 3.0, 4.0, 1.0, 3.0, 2.0, 4.0, 4.0]),
  431:         ("dense", False, "bottom", True, [0.75, 0.75, 1.0, 0.25, 0.75, 0.5, 1.0, 1.0]),
  432:     ],
  433: )
  434: def test_rank_args_missing(grps, vals, ties_method, ascending, na_option, pct, exp):
  435:     key = np.repeat(grps, len(vals))
  436: 
  437:     orig_vals = vals
  438:     vals = list(vals) * len(grps)
  439:     if isinstance(orig_vals, np.ndarray):
  440:         vals = np.array(vals, dtype=orig_vals.dtype)
  441: 
  442:     df = DataFrame({"key": key, "val": vals})
  443:     result = df.groupby("key").rank(
  444:         method=ties_method, ascending=ascending, na_option=na_option, pct=pct
  445:     )
  446: 
  447:     exp_df = DataFrame(exp * len(grps), columns=["val"])
  448:     tm.assert_frame_equal(result, exp_df)
  449: 
  450: 
  451: @pytest.mark.parametrize(
  452:     "pct,exp", [(False, [3.0, 3.0, 3.0, 3.0, 3.0]), (True, [0.6, 0.6, 0.6, 0.6, 0.6])]
  453: )
  454: def test_rank_resets_each_group(pct, exp):
  455:     df = DataFrame(
  456:         {"key": ["a", "a", "a", "a", "a", "b", "b", "b", "b", "b"], "val": [1] * 10}
  457:     )
  458:     result = df.groupby("key").rank(pct=pct)
  459:     exp_df = DataFrame(exp * 2, columns=["val"])
  460:     tm.assert_frame_equal(result, exp_df)
  461: 
  462: 
  463: @pytest.mark.parametrize(
  464:     "dtype", ["int64", "int32", "uint64", "uint32", "float64", "float32"]
  465: )
  466: @pytest.mark.parametrize("upper", [True, False])
  467: def test_rank_avg_even_vals(dtype, upper):
  468:     if upper:
  469:         # use IntegerDtype/FloatingDtype
  470:         dtype = dtype[0].upper() + dtype[1:]
  471:         dtype = dtype.replace("Ui", "UI")
  472:     df = DataFrame({"key": ["a"] * 4, "val": [1] * 4})
  473:     df["val"] = df["val"].astype(dtype)
  474:     assert df["val"].dtype == dtype
  475: 
  476:     result = df.groupby("key").rank()
  477:     exp_df = DataFrame([2.5, 2.5, 2.5, 2.5], columns=["val"])
  478:     if upper:
  479:         exp_df = exp_df.astype("Float64")
  480:     tm.assert_frame_equal(result, exp_df)
  481: 
  482: 
  483: @pytest.mark.parametrize("ties_method", ["average", "min", "max", "first", "dense"])
  484: @pytest.mark.parametrize("ascending", [True, False])
  485: @pytest.mark.parametrize("na_option", ["keep", "top", "bottom"])
  486: @pytest.mark.parametrize("pct", [True, False])
  487: @pytest.mark.parametrize(
  488:     "vals", [["bar", "bar", "foo", "bar", "baz"], ["bar", np.nan, "foo", np.nan, "baz"]]
  489: )
  490: def test_rank_object_dtype(ties_method, ascending, na_option, pct, vals):
  491:     df = DataFrame({"key": ["foo"] * 5, "val": vals})
  492:     mask = df["val"].isna()
  493: 
  494:     gb = df.groupby("key")
  495:     res = gb.rank(method=ties_method, ascending=ascending, na_option=na_option, pct=pct)
  496: 
  497:     # construct our expected by using numeric values with the same ordering
  498:     if mask.any():
  499:         df2 = DataFrame({"key": ["foo"] * 5, "val": [0, np.nan, 2, np.nan, 1]})
  500:     else:
  501:         df2 = DataFrame({"key": ["foo"] * 5, "val": [0, 0, 2, 0, 1]})
  502: 
  503:     gb2 = df2.groupby("key")
  504:     alt = gb2.rank(
  505:         method=ties_method, ascending=ascending, na_option=na_option, pct=pct
  506:     )
  507: 
  508:     tm.assert_frame_equal(res, alt)
  509: 
  510: 
  511: @pytest.mark.parametrize("na_option", [True, "bad", 1])
  512: @pytest.mark.parametrize("ties_method", ["average", "min", "max", "first", "dense"])
  513: @pytest.mark.parametrize("ascending", [True, False])
  514: @pytest.mark.parametrize("pct", [True, False])
  515: @pytest.mark.parametrize(
  516:     "vals",
  517:     [
  518:         ["bar", "bar", "foo", "bar", "baz"],
  519:         ["bar", np.nan, "foo", np.nan, "baz"],
  520:         [1, np.nan, 2, np.nan, 3],
  521:     ],
  522: )
  523: def test_rank_naoption_raises(ties_method, ascending, na_option, pct, vals):
  524:     df = DataFrame({"key": ["foo"] * 5, "val": vals})
  525:     msg = "na_option must be one of 'keep', 'top', or 'bottom'"
  526: 
  527:     with pytest.raises(ValueError, match=msg):
  528:         df.groupby("key").rank(
  529:             method=ties_method, ascending=ascending, na_option=na_option, pct=pct
  530:         )
  531: 
  532: 
  533: def test_rank_empty_group():
  534:     # see gh-22519
  535:     column = "A"
  536:     df = DataFrame({"A": [0, 1, 0], "B": [1.0, np.nan, 2.0]})
  537: 
  538:     result = df.groupby(column).B.rank(pct=True)
  539:     expected = Series([0.5, np.nan, 1.0], name="B")
  540:     tm.assert_series_equal(result, expected)
  541: 
  542:     result = df.groupby(column).rank(pct=True)
  543:     expected = DataFrame({"B": [0.5, np.nan, 1.0]})
  544:     tm.assert_frame_equal(result, expected)
  545: 
  546: 
  547: @pytest.mark.parametrize(
  548:     "input_key,input_value,output_value",
  549:     [
  550:         ([1, 2], [1, 1], [1.0, 1.0]),
  551:         ([1, 1, 2, 2], [1, 2, 1, 2], [0.5, 1.0, 0.5, 1.0]),
  552:         ([1, 1, 2, 2], [1, 2, 1, np.nan], [0.5, 1.0, 1.0, np.nan]),
  553:         ([1, 1, 2], [1, 2, np.nan], [0.5, 1.0, np.nan]),
  554:     ],
  555: )
  556: def test_rank_zero_div(input_key, input_value, output_value):
  557:     # GH 23666
  558:     df = DataFrame({"A": input_key, "B": input_value})
  559: 
  560:     result = df.groupby("A").rank(method="dense", pct=True)
  561:     expected = DataFrame({"B": output_value})
  562:     tm.assert_frame_equal(result, expected)
  563: 
  564: 
  565: def test_rank_min_int():
  566:     # GH-32859
  567:     df = DataFrame(
  568:         {
  569:             "grp": [1, 1, 2],
  570:             "int_col": [
  571:                 np.iinfo(np.int64).min,
  572:                 np.iinfo(np.int64).max,
  573:                 np.iinfo(np.int64).min,
  574:             ],
  575:             "datetimelike": [NaT, datetime(2001, 1, 1), NaT],
  576:         }
  577:     )
  578: 
  579:     result = df.groupby("grp").rank()
  580:     expected = DataFrame(
  581:         {"int_col": [1.0, 2.0, 1.0], "datetimelike": [np.nan, 1.0, np.nan]}
  582:     )
  583: 
  584:     tm.assert_frame_equal(result, expected)
  585: 
  586: 
  587: @pytest.mark.parametrize("use_nan", [True, False])
  588: def test_rank_pct_equal_values_on_group_transition(use_nan):
  589:     # GH#40518
  590:     fill_value = np.nan if use_nan else 3
  591:     df = DataFrame(
  592:         [
  593:             [-1, 1],
  594:             [-1, 2],
  595:             [1, fill_value],
  596:             [-1, fill_value],
  597:         ],
  598:         columns=["group", "val"],
  599:     )
  600:     result = df.groupby(["group"])["val"].rank(
  601:         method="dense",
  602:         pct=True,
  603:     )
  604:     if use_nan:
  605:         expected = Series([0.5, 1, np.nan, np.nan], name="val")
  606:     else:
  607:         expected = Series([1 / 3, 2 / 3, 1, 1], name="val")
  608: 
  609:     tm.assert_series_equal(result, expected)
  610: 
  611: 
  612: def test_rank_multiindex():
  613:     # GH27721
  614:     df = concat(
  615:         {
  616:             "a": DataFrame({"col1": [3, 4], "col2": [1, 2]}),
  617:             "b": DataFrame({"col3": [5, 6], "col4": [7, 8]}),
  618:         },
  619:         axis=1,
  620:     )
  621: 
  622:     msg = "DataFrame.groupby with axis=1 is deprecated"
  623:     with tm.assert_produces_warning(FutureWarning, match=msg):
  624:         gb = df.groupby(level=0, axis=1)
  625:     msg = "DataFrameGroupBy.rank with axis=1 is deprecated"
  626:     with tm.assert_produces_warning(FutureWarning, match=msg):
  627:         result = gb.rank(axis=1)
  628: 
  629:     expected = concat(
  630:         [
  631:             df["a"].rank(axis=1),
  632:             df["b"].rank(axis=1),
  633:         ],
  634:         axis=1,
  635:         keys=["a", "b"],
  636:     )
  637:     tm.assert_frame_equal(result, expected)
  638: 
  639: 
  640: def test_groupby_axis0_rank_axis1():
  641:     # GH#41320
  642:     df = DataFrame(
  643:         {0: [1, 3, 5, 7], 1: [2, 4, 6, 8], 2: [1.5, 3.5, 5.5, 7.5]},
  644:         index=["a", "a", "b", "b"],
  645:     )
  646:     msg = "The 'axis' keyword in DataFrame.groupby is deprecated"
  647:     with tm.assert_produces_warning(FutureWarning, match=msg):
  648:         gb = df.groupby(level=0, axis=0)
  649: 
  650:     msg = "DataFrameGroupBy.rank with axis=1 is deprecated"
  651:     with tm.assert_produces_warning(FutureWarning, match=msg):
  652:         res = gb.rank(axis=1)
  653: 
  654:     # This should match what we get when "manually" operating group-by-group
  655:     expected = concat([df.loc["a"].rank(axis=1), df.loc["b"].rank(axis=1)], axis=0)
  656:     tm.assert_frame_equal(res, expected)
  657: 
  658:     # check that we haven't accidentally written a case that coincidentally
  659:     # matches rank(axis=0)
  660:     msg = "The 'axis' keyword in DataFrameGroupBy.rank"
  661:     with tm.assert_produces_warning(FutureWarning, match=msg):
  662:         alt = gb.rank(axis=0)
  663:     assert not alt.equals(expected)
  664: 
  665: 
  666: def test_groupby_axis0_cummax_axis1():
  667:     # case where groupby axis is 0 and axis keyword in transform is 1
  668: 
  669:     # df has mixed dtype -> multiple blocks
  670:     df = DataFrame(
  671:         {0: [1, 3, 5, 7], 1: [2, 4, 6, 8], 2: [1.5, 3.5, 5.5, 7.5]},
  672:         index=["a", "a", "b", "b"],
  673:     )
  674:     msg = "The 'axis' keyword in DataFrame.groupby is deprecated"
  675:     with tm.assert_produces_warning(FutureWarning, match=msg):
  676:         gb = df.groupby(level=0, axis=0)
  677: 
  678:     msg = "DataFrameGroupBy.cummax with axis=1 is deprecated"
  679:     with tm.assert_produces_warning(FutureWarning, match=msg):
  680:         cmax = gb.cummax(axis=1)
  681:     expected = df[[0, 1]].astype(np.float64)
  682:     expected[2] = expected[1]
  683:     tm.assert_frame_equal(cmax, expected)
  684: 
  685: 
  686: def test_non_unique_index():
  687:     # GH 16577
  688:     df = DataFrame(
  689:         {"A": [1.0, 2.0, 3.0, np.nan], "value": 1.0},
  690:         index=[pd.Timestamp("20170101", tz="US/Eastern")] * 4,
  691:     )
  692:     result = df.groupby([df.index, "A"]).value.rank(ascending=True, pct=True)
  693:     expected = Series(
  694:         [1.0, 1.0, 1.0, np.nan],
  695:         index=[pd.Timestamp("20170101", tz="US/Eastern")] * 4,
  696:         name="value",
  697:     )
  698:     tm.assert_series_equal(result, expected)
  699: 
  700: 
  701: def test_rank_categorical():
  702:     cat = pd.Categorical(["a", "a", "b", np.nan, "c", "b"], ordered=True)
  703:     cat2 = pd.Categorical([1, 2, 3, np.nan, 4, 5], ordered=True)
  704: 
  705:     df = DataFrame({"col1": [0, 1, 0, 1, 0, 1], "col2": cat, "col3": cat2})
  706: 
  707:     gb = df.groupby("col1")
  708: 
  709:     res = gb.rank()
  710: 
  711:     expected = df.astype(object).groupby("col1").rank()
  712:     tm.assert_frame_equal(res, expected)
  713: 
  714: 
  715: @pytest.mark.parametrize("na_option", ["top", "bottom"])
  716: def test_groupby_op_with_nullables(na_option):
  717:     # GH 54206
  718:     df = DataFrame({"x": [None]}, dtype="Float64")
  719:     result = df.groupby("x", dropna=False)["x"].rank(method="min", na_option=na_option)
  720:     expected = Series([1.0], dtype="Float64", name=result.name)
  721:     tm.assert_series_equal(result, expected)
