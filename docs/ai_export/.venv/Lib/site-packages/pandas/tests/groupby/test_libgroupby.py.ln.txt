    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas._libs import groupby as libgroupby
    5: from pandas._libs.groupby import (
    6:     group_cumprod,
    7:     group_cumsum,
    8:     group_mean,
    9:     group_sum,
   10:     group_var,
   11: )
   12: 
   13: from pandas.core.dtypes.common import ensure_platform_int
   14: 
   15: from pandas import isna
   16: import pandas._testing as tm
   17: 
   18: 
   19: class GroupVarTestMixin:
   20:     def test_group_var_generic_1d(self):
   21:         prng = np.random.default_rng(2)
   22: 
   23:         out = (np.nan * np.ones((5, 1))).astype(self.dtype)
   24:         counts = np.zeros(5, dtype="int64")
   25:         values = 10 * prng.random((15, 1)).astype(self.dtype)
   26:         labels = np.tile(np.arange(5), (3,)).astype("intp")
   27: 
   28:         expected_out = (
   29:             np.squeeze(values).reshape((5, 3), order="F").std(axis=1, ddof=1) ** 2
   30:         )[:, np.newaxis]
   31:         expected_counts = counts + 3
   32: 
   33:         self.algo(out, counts, values, labels)
   34:         assert np.allclose(out, expected_out, self.rtol)
   35:         tm.assert_numpy_array_equal(counts, expected_counts)
   36: 
   37:     def test_group_var_generic_1d_flat_labels(self):
   38:         prng = np.random.default_rng(2)
   39: 
   40:         out = (np.nan * np.ones((1, 1))).astype(self.dtype)
   41:         counts = np.zeros(1, dtype="int64")
   42:         values = 10 * prng.random((5, 1)).astype(self.dtype)
   43:         labels = np.zeros(5, dtype="intp")
   44: 
   45:         expected_out = np.array([[values.std(ddof=1) ** 2]])
   46:         expected_counts = counts + 5
   47: 
   48:         self.algo(out, counts, values, labels)
   49: 
   50:         assert np.allclose(out, expected_out, self.rtol)
   51:         tm.assert_numpy_array_equal(counts, expected_counts)
   52: 
   53:     def test_group_var_generic_2d_all_finite(self):
   54:         prng = np.random.default_rng(2)
   55: 
   56:         out = (np.nan * np.ones((5, 2))).astype(self.dtype)
   57:         counts = np.zeros(5, dtype="int64")
   58:         values = 10 * prng.random((10, 2)).astype(self.dtype)
   59:         labels = np.tile(np.arange(5), (2,)).astype("intp")
   60: 
   61:         expected_out = np.std(values.reshape(2, 5, 2), ddof=1, axis=0) ** 2
   62:         expected_counts = counts + 2
   63: 
   64:         self.algo(out, counts, values, labels)
   65:         assert np.allclose(out, expected_out, self.rtol)
   66:         tm.assert_numpy_array_equal(counts, expected_counts)
   67: 
   68:     def test_group_var_generic_2d_some_nan(self):
   69:         prng = np.random.default_rng(2)
   70: 
   71:         out = (np.nan * np.ones((5, 2))).astype(self.dtype)
   72:         counts = np.zeros(5, dtype="int64")
   73:         values = 10 * prng.random((10, 2)).astype(self.dtype)
   74:         values[:, 1] = np.nan
   75:         labels = np.tile(np.arange(5), (2,)).astype("intp")
   76: 
   77:         expected_out = np.vstack(
   78:             [
   79:                 values[:, 0].reshape(5, 2, order="F").std(ddof=1, axis=1) ** 2,
   80:                 np.nan * np.ones(5),
   81:             ]
   82:         ).T.astype(self.dtype)
   83:         expected_counts = counts + 2
   84: 
   85:         self.algo(out, counts, values, labels)
   86:         tm.assert_almost_equal(out, expected_out, rtol=0.5e-06)
   87:         tm.assert_numpy_array_equal(counts, expected_counts)
   88: 
   89:     def test_group_var_constant(self):
   90:         # Regression test from GH 10448.
   91: 
   92:         out = np.array([[np.nan]], dtype=self.dtype)
   93:         counts = np.array([0], dtype="int64")
   94:         values = 0.832845131556193 * np.ones((3, 1), dtype=self.dtype)
   95:         labels = np.zeros(3, dtype="intp")
   96: 
   97:         self.algo(out, counts, values, labels)
   98: 
   99:         assert counts[0] == 3
  100:         assert out[0, 0] >= 0
  101:         tm.assert_almost_equal(out[0, 0], 0.0)
  102: 
  103: 
  104: class TestGroupVarFloat64(GroupVarTestMixin):
  105:     __test__ = True
  106: 
  107:     algo = staticmethod(group_var)
  108:     dtype = np.float64
  109:     rtol = 1e-5
  110: 
  111:     def test_group_var_large_inputs(self):
  112:         prng = np.random.default_rng(2)
  113: 
  114:         out = np.array([[np.nan]], dtype=self.dtype)
  115:         counts = np.array([0], dtype="int64")
  116:         values = (prng.random(10**6) + 10**12).astype(self.dtype)
  117:         values.shape = (10**6, 1)
  118:         labels = np.zeros(10**6, dtype="intp")
  119: 
  120:         self.algo(out, counts, values, labels)
  121: 
  122:         assert counts[0] == 10**6
  123:         tm.assert_almost_equal(out[0, 0], 1.0 / 12, rtol=0.5e-3)
  124: 
  125: 
  126: class TestGroupVarFloat32(GroupVarTestMixin):
  127:     __test__ = True
  128: 
  129:     algo = staticmethod(group_var)
  130:     dtype = np.float32
  131:     rtol = 1e-2
  132: 
  133: 
  134: @pytest.mark.parametrize("dtype", ["float32", "float64"])
  135: def test_group_ohlc(dtype):
  136:     obj = np.array(np.random.default_rng(2).standard_normal(20), dtype=dtype)
  137: 
  138:     bins = np.array([6, 12, 20])
  139:     out = np.zeros((3, 4), dtype)
  140:     counts = np.zeros(len(out), dtype=np.int64)
  141:     labels = ensure_platform_int(np.repeat(np.arange(3), np.diff(np.r_[0, bins])))
  142: 
  143:     func = libgroupby.group_ohlc
  144:     func(out, counts, obj[:, None], labels)
  145: 
  146:     def _ohlc(group):
  147:         if isna(group).all():
  148:             return np.repeat(np.nan, 4)
  149:         return [group[0], group.max(), group.min(), group[-1]]
  150: 
  151:     expected = np.array([_ohlc(obj[:6]), _ohlc(obj[6:12]), _ohlc(obj[12:])])
  152: 
  153:     tm.assert_almost_equal(out, expected)
  154:     tm.assert_numpy_array_equal(counts, np.array([6, 6, 8], dtype=np.int64))
  155: 
  156:     obj[:6] = np.nan
  157:     func(out, counts, obj[:, None], labels)
  158:     expected[0] = np.nan
  159:     tm.assert_almost_equal(out, expected)
  160: 
  161: 
  162: def _check_cython_group_transform_cumulative(pd_op, np_op, dtype):
  163:     """
  164:     Check a group transform that executes a cumulative function.
  165: 
  166:     Parameters
  167:     ----------
  168:     pd_op : callable
  169:         The pandas cumulative function.
  170:     np_op : callable
  171:         The analogous one in NumPy.
  172:     dtype : type
  173:         The specified dtype of the data.
  174:     """
  175:     is_datetimelike = False
  176: 
  177:     data = np.array([[1], [2], [3], [4]], dtype=dtype)
  178:     answer = np.zeros_like(data)
  179: 
  180:     labels = np.array([0, 0, 0, 0], dtype=np.intp)
  181:     ngroups = 1
  182:     pd_op(answer, data, labels, ngroups, is_datetimelike)
  183: 
  184:     tm.assert_numpy_array_equal(np_op(data), answer[:, 0], check_dtype=False)
  185: 
  186: 
  187: @pytest.mark.parametrize("np_dtype", ["int64", "uint64", "float32", "float64"])
  188: def test_cython_group_transform_cumsum(np_dtype):
  189:     # see gh-4095
  190:     dtype = np.dtype(np_dtype).type
  191:     pd_op, np_op = group_cumsum, np.cumsum
  192:     _check_cython_group_transform_cumulative(pd_op, np_op, dtype)
  193: 
  194: 
  195: def test_cython_group_transform_cumprod():
  196:     # see gh-4095
  197:     dtype = np.float64
  198:     pd_op, np_op = group_cumprod, np.cumprod
  199:     _check_cython_group_transform_cumulative(pd_op, np_op, dtype)
  200: 
  201: 
  202: def test_cython_group_transform_algos():
  203:     # see gh-4095
  204:     is_datetimelike = False
  205: 
  206:     # with nans
  207:     labels = np.array([0, 0, 0, 0, 0], dtype=np.intp)
  208:     ngroups = 1
  209: 
  210:     data = np.array([[1], [2], [3], [np.nan], [4]], dtype="float64")
  211:     actual = np.zeros_like(data)
  212:     actual.fill(np.nan)
  213:     group_cumprod(actual, data, labels, ngroups, is_datetimelike)
  214:     expected = np.array([1, 2, 6, np.nan, 24], dtype="float64")
  215:     tm.assert_numpy_array_equal(actual[:, 0], expected)
  216: 
  217:     actual = np.zeros_like(data)
  218:     actual.fill(np.nan)
  219:     group_cumsum(actual, data, labels, ngroups, is_datetimelike)
  220:     expected = np.array([1, 3, 6, np.nan, 10], dtype="float64")
  221:     tm.assert_numpy_array_equal(actual[:, 0], expected)
  222: 
  223:     # timedelta
  224:     is_datetimelike = True
  225:     data = np.array([np.timedelta64(1, "ns")] * 5, dtype="m8[ns]")[:, None]
  226:     actual = np.zeros_like(data, dtype="int64")
  227:     group_cumsum(actual, data.view("int64"), labels, ngroups, is_datetimelike)
  228:     expected = np.array(
  229:         [
  230:             np.timedelta64(1, "ns"),
  231:             np.timedelta64(2, "ns"),
  232:             np.timedelta64(3, "ns"),
  233:             np.timedelta64(4, "ns"),
  234:             np.timedelta64(5, "ns"),
  235:         ]
  236:     )
  237:     tm.assert_numpy_array_equal(actual[:, 0].view("m8[ns]"), expected)
  238: 
  239: 
  240: def test_cython_group_mean_datetimelike():
  241:     actual = np.zeros(shape=(1, 1), dtype="float64")
  242:     counts = np.array([0], dtype="int64")
  243:     data = (
  244:         np.array(
  245:             [np.timedelta64(2, "ns"), np.timedelta64(4, "ns"), np.timedelta64("NaT")],
  246:             dtype="m8[ns]",
  247:         )[:, None]
  248:         .view("int64")
  249:         .astype("float64")
  250:     )
  251:     labels = np.zeros(len(data), dtype=np.intp)
  252: 
  253:     group_mean(actual, counts, data, labels, is_datetimelike=True)
  254: 
  255:     tm.assert_numpy_array_equal(actual[:, 0], np.array([3], dtype="float64"))
  256: 
  257: 
  258: def test_cython_group_mean_wrong_min_count():
  259:     actual = np.zeros(shape=(1, 1), dtype="float64")
  260:     counts = np.zeros(1, dtype="int64")
  261:     data = np.zeros(1, dtype="float64")[:, None]
  262:     labels = np.zeros(1, dtype=np.intp)
  263: 
  264:     with pytest.raises(AssertionError, match="min_count"):
  265:         group_mean(actual, counts, data, labels, is_datetimelike=True, min_count=0)
  266: 
  267: 
  268: def test_cython_group_mean_not_datetimelike_but_has_NaT_values():
  269:     actual = np.zeros(shape=(1, 1), dtype="float64")
  270:     counts = np.array([0], dtype="int64")
  271:     data = (
  272:         np.array(
  273:             [np.timedelta64("NaT"), np.timedelta64("NaT")],
  274:             dtype="m8[ns]",
  275:         )[:, None]
  276:         .view("int64")
  277:         .astype("float64")
  278:     )
  279:     labels = np.zeros(len(data), dtype=np.intp)
  280: 
  281:     group_mean(actual, counts, data, labels, is_datetimelike=False)
  282: 
  283:     tm.assert_numpy_array_equal(
  284:         actual[:, 0], np.array(np.divide(np.add(data[0], data[1]), 2), dtype="float64")
  285:     )
  286: 
  287: 
  288: def test_cython_group_mean_Inf_at_begining_and_end():
  289:     # GH 50367
  290:     actual = np.array([[np.nan, np.nan], [np.nan, np.nan]], dtype="float64")
  291:     counts = np.array([0, 0], dtype="int64")
  292:     data = np.array(
  293:         [[np.inf, 1.0], [1.0, 2.0], [2.0, 3.0], [3.0, 4.0], [4.0, 5.0], [5, np.inf]],
  294:         dtype="float64",
  295:     )
  296:     labels = np.array([0, 1, 0, 1, 0, 1], dtype=np.intp)
  297: 
  298:     group_mean(actual, counts, data, labels, is_datetimelike=False)
  299: 
  300:     expected = np.array([[np.inf, 3], [3, np.inf]], dtype="float64")
  301: 
  302:     tm.assert_numpy_array_equal(
  303:         actual,
  304:         expected,
  305:     )
  306: 
  307: 
  308: @pytest.mark.parametrize(
  309:     "values, out",
  310:     [
  311:         ([[np.inf], [np.inf], [np.inf]], [[np.inf], [np.inf]]),
  312:         ([[np.inf], [np.inf], [-np.inf]], [[np.inf], [np.nan]]),
  313:         ([[np.inf], [-np.inf], [np.inf]], [[np.inf], [np.nan]]),
  314:         ([[np.inf], [-np.inf], [-np.inf]], [[np.inf], [-np.inf]]),
  315:     ],
  316: )
  317: def test_cython_group_sum_Inf_at_begining_and_end(values, out):
  318:     # GH #53606
  319:     actual = np.array([[np.nan], [np.nan]], dtype="float64")
  320:     counts = np.array([0, 0], dtype="int64")
  321:     data = np.array(values, dtype="float64")
  322:     labels = np.array([0, 1, 1], dtype=np.intp)
  323: 
  324:     group_sum(actual, counts, data, labels, None, is_datetimelike=False)
  325: 
  326:     expected = np.array(out, dtype="float64")
  327: 
  328:     tm.assert_numpy_array_equal(
  329:         actual,
  330:         expected,
  331:     )
