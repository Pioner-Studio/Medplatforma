    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas.errors import NumbaUtilError
    5: 
    6: from pandas import (
    7:     DataFrame,
    8:     Series,
    9:     option_context,
   10: )
   11: import pandas._testing as tm
   12: 
   13: pytestmark = pytest.mark.single_cpu
   14: 
   15: 
   16: def test_correct_function_signature():
   17:     pytest.importorskip("numba")
   18: 
   19:     def incorrect_function(x):
   20:         return x + 1
   21: 
   22:     data = DataFrame(
   23:         {"key": ["a", "a", "b", "b", "a"], "data": [1.0, 2.0, 3.0, 4.0, 5.0]},
   24:         columns=["key", "data"],
   25:     )
   26:     with pytest.raises(NumbaUtilError, match="The first 2"):
   27:         data.groupby("key").transform(incorrect_function, engine="numba")
   28: 
   29:     with pytest.raises(NumbaUtilError, match="The first 2"):
   30:         data.groupby("key")["data"].transform(incorrect_function, engine="numba")
   31: 
   32: 
   33: def test_check_nopython_kwargs():
   34:     pytest.importorskip("numba")
   35: 
   36:     def incorrect_function(values, index):
   37:         return values + 1
   38: 
   39:     data = DataFrame(
   40:         {"key": ["a", "a", "b", "b", "a"], "data": [1.0, 2.0, 3.0, 4.0, 5.0]},
   41:         columns=["key", "data"],
   42:     )
   43:     with pytest.raises(NumbaUtilError, match="numba does not support"):
   44:         data.groupby("key").transform(incorrect_function, engine="numba", a=1)
   45: 
   46:     with pytest.raises(NumbaUtilError, match="numba does not support"):
   47:         data.groupby("key")["data"].transform(incorrect_function, engine="numba", a=1)
   48: 
   49: 
   50: @pytest.mark.filterwarnings("ignore")
   51: # Filter warnings when parallel=True and the function can't be parallelized by Numba
   52: @pytest.mark.parametrize("jit", [True, False])
   53: @pytest.mark.parametrize("pandas_obj", ["Series", "DataFrame"])
   54: @pytest.mark.parametrize("as_index", [True, False])
   55: def test_numba_vs_cython(jit, pandas_obj, nogil, parallel, nopython, as_index):
   56:     pytest.importorskip("numba")
   57: 
   58:     def func(values, index):
   59:         return values + 1
   60: 
   61:     if jit:
   62:         # Test accepted jitted functions
   63:         import numba
   64: 
   65:         func = numba.jit(func)
   66: 
   67:     data = DataFrame(
   68:         {0: ["a", "a", "b", "b", "a"], 1: [1.0, 2.0, 3.0, 4.0, 5.0]}, columns=[0, 1]
   69:     )
   70:     engine_kwargs = {"nogil": nogil, "parallel": parallel, "nopython": nopython}
   71:     grouped = data.groupby(0, as_index=as_index)
   72:     if pandas_obj == "Series":
   73:         grouped = grouped[1]
   74: 
   75:     result = grouped.transform(func, engine="numba", engine_kwargs=engine_kwargs)
   76:     expected = grouped.transform(lambda x: x + 1, engine="cython")
   77: 
   78:     tm.assert_equal(result, expected)
   79: 
   80: 
   81: @pytest.mark.filterwarnings("ignore")
   82: # Filter warnings when parallel=True and the function can't be parallelized by Numba
   83: @pytest.mark.parametrize("jit", [True, False])
   84: @pytest.mark.parametrize("pandas_obj", ["Series", "DataFrame"])
   85: def test_cache(jit, pandas_obj, nogil, parallel, nopython):
   86:     # Test that the functions are cached correctly if we switch functions
   87:     pytest.importorskip("numba")
   88: 
   89:     def func_1(values, index):
   90:         return values + 1
   91: 
   92:     def func_2(values, index):
   93:         return values * 5
   94: 
   95:     if jit:
   96:         import numba
   97: 
   98:         func_1 = numba.jit(func_1)
   99:         func_2 = numba.jit(func_2)
  100: 
  101:     data = DataFrame(
  102:         {0: ["a", "a", "b", "b", "a"], 1: [1.0, 2.0, 3.0, 4.0, 5.0]}, columns=[0, 1]
  103:     )
  104:     engine_kwargs = {"nogil": nogil, "parallel": parallel, "nopython": nopython}
  105:     grouped = data.groupby(0)
  106:     if pandas_obj == "Series":
  107:         grouped = grouped[1]
  108: 
  109:     result = grouped.transform(func_1, engine="numba", engine_kwargs=engine_kwargs)
  110:     expected = grouped.transform(lambda x: x + 1, engine="cython")
  111:     tm.assert_equal(result, expected)
  112: 
  113:     result = grouped.transform(func_2, engine="numba", engine_kwargs=engine_kwargs)
  114:     expected = grouped.transform(lambda x: x * 5, engine="cython")
  115:     tm.assert_equal(result, expected)
  116: 
  117:     # Retest func_1 which should use the cache
  118:     result = grouped.transform(func_1, engine="numba", engine_kwargs=engine_kwargs)
  119:     expected = grouped.transform(lambda x: x + 1, engine="cython")
  120:     tm.assert_equal(result, expected)
  121: 
  122: 
  123: def test_use_global_config():
  124:     pytest.importorskip("numba")
  125: 
  126:     def func_1(values, index):
  127:         return values + 1
  128: 
  129:     data = DataFrame(
  130:         {0: ["a", "a", "b", "b", "a"], 1: [1.0, 2.0, 3.0, 4.0, 5.0]}, columns=[0, 1]
  131:     )
  132:     grouped = data.groupby(0)
  133:     expected = grouped.transform(func_1, engine="numba")
  134:     with option_context("compute.use_numba", True):
  135:         result = grouped.transform(func_1, engine=None)
  136:     tm.assert_frame_equal(expected, result)
  137: 
  138: 
  139: # TODO: Test more than just reductions (e.g. actually test transformations once we have
  140: @pytest.mark.parametrize(
  141:     "agg_func", [["min", "max"], "min", {"B": ["min", "max"], "C": "sum"}]
  142: )
  143: def test_string_cython_vs_numba(agg_func, numba_supported_reductions):
  144:     pytest.importorskip("numba")
  145:     agg_func, kwargs = numba_supported_reductions
  146:     data = DataFrame(
  147:         {0: ["a", "a", "b", "b", "a"], 1: [1.0, 2.0, 3.0, 4.0, 5.0]}, columns=[0, 1]
  148:     )
  149:     grouped = data.groupby(0)
  150: 
  151:     result = grouped.transform(agg_func, engine="numba", **kwargs)
  152:     expected = grouped.transform(agg_func, engine="cython", **kwargs)
  153:     tm.assert_frame_equal(result, expected)
  154: 
  155:     result = grouped[1].transform(agg_func, engine="numba", **kwargs)
  156:     expected = grouped[1].transform(agg_func, engine="cython", **kwargs)
  157:     tm.assert_series_equal(result, expected)
  158: 
  159: 
  160: def test_args_not_cached():
  161:     # GH 41647
  162:     pytest.importorskip("numba")
  163: 
  164:     def sum_last(values, index, n):
  165:         return values[-n:].sum()
  166: 
  167:     df = DataFrame({"id": [0, 0, 1, 1], "x": [1, 1, 1, 1]})
  168:     grouped_x = df.groupby("id")["x"]
  169:     result = grouped_x.transform(sum_last, 1, engine="numba")
  170:     expected = Series([1.0] * 4, name="x")
  171:     tm.assert_series_equal(result, expected)
  172: 
  173:     result = grouped_x.transform(sum_last, 2, engine="numba")
  174:     expected = Series([2.0] * 4, name="x")
  175:     tm.assert_series_equal(result, expected)
  176: 
  177: 
  178: def test_index_data_correctly_passed():
  179:     # GH 43133
  180:     pytest.importorskip("numba")
  181: 
  182:     def f(values, index):
  183:         return index - 1
  184: 
  185:     df = DataFrame({"group": ["A", "A", "B"], "v": [4, 5, 6]}, index=[-1, -2, -3])
  186:     result = df.groupby("group").transform(f, engine="numba")
  187:     expected = DataFrame([-4.0, -3.0, -2.0], columns=["v"], index=[-1, -2, -3])
  188:     tm.assert_frame_equal(result, expected)
  189: 
  190: 
  191: def test_engine_kwargs_not_cached():
  192:     # If the user passes a different set of engine_kwargs don't return the same
  193:     # jitted function
  194:     pytest.importorskip("numba")
  195:     nogil = True
  196:     parallel = False
  197:     nopython = True
  198: 
  199:     def func_kwargs(values, index):
  200:         return nogil + parallel + nopython
  201: 
  202:     engine_kwargs = {"nopython": nopython, "nogil": nogil, "parallel": parallel}
  203:     df = DataFrame({"value": [0, 0, 0]})
  204:     result = df.groupby(level=0).transform(
  205:         func_kwargs, engine="numba", engine_kwargs=engine_kwargs
  206:     )
  207:     expected = DataFrame({"value": [2.0, 2.0, 2.0]})
  208:     tm.assert_frame_equal(result, expected)
  209: 
  210:     nogil = False
  211:     engine_kwargs = {"nopython": nopython, "nogil": nogil, "parallel": parallel}
  212:     result = df.groupby(level=0).transform(
  213:         func_kwargs, engine="numba", engine_kwargs=engine_kwargs
  214:     )
  215:     expected = DataFrame({"value": [1.0, 1.0, 1.0]})
  216:     tm.assert_frame_equal(result, expected)
  217: 
  218: 
  219: @pytest.mark.filterwarnings("ignore")
  220: def test_multiindex_one_key(nogil, parallel, nopython):
  221:     pytest.importorskip("numba")
  222: 
  223:     def numba_func(values, index):
  224:         return 1
  225: 
  226:     df = DataFrame([{"A": 1, "B": 2, "C": 3}]).set_index(["A", "B"])
  227:     engine_kwargs = {"nopython": nopython, "nogil": nogil, "parallel": parallel}
  228:     result = df.groupby("A").transform(
  229:         numba_func, engine="numba", engine_kwargs=engine_kwargs
  230:     )
  231:     expected = DataFrame([{"A": 1, "B": 2, "C": 1.0}]).set_index(["A", "B"])
  232:     tm.assert_frame_equal(result, expected)
  233: 
  234: 
  235: def test_multiindex_multi_key_not_supported(nogil, parallel, nopython):
  236:     pytest.importorskip("numba")
  237: 
  238:     def numba_func(values, index):
  239:         return 1
  240: 
  241:     df = DataFrame([{"A": 1, "B": 2, "C": 3}]).set_index(["A", "B"])
  242:     engine_kwargs = {"nopython": nopython, "nogil": nogil, "parallel": parallel}
  243:     with pytest.raises(NotImplementedError, match="more than 1 grouping labels"):
  244:         df.groupby(["A", "B"]).transform(
  245:             numba_func, engine="numba", engine_kwargs=engine_kwargs
  246:         )
  247: 
  248: 
  249: def test_multilabel_numba_vs_cython(numba_supported_reductions):
  250:     pytest.importorskip("numba")
  251:     reduction, kwargs = numba_supported_reductions
  252:     df = DataFrame(
  253:         {
  254:             "A": ["foo", "bar", "foo", "bar", "foo", "bar", "foo", "foo"],
  255:             "B": ["one", "one", "two", "three", "two", "two", "one", "three"],
  256:             "C": np.random.default_rng(2).standard_normal(8),
  257:             "D": np.random.default_rng(2).standard_normal(8),
  258:         }
  259:     )
  260:     gb = df.groupby(["A", "B"])
  261:     res_agg = gb.transform(reduction, engine="numba", **kwargs)
  262:     expected_agg = gb.transform(reduction, engine="cython", **kwargs)
  263:     tm.assert_frame_equal(res_agg, expected_agg)
  264: 
  265: 
  266: def test_multilabel_udf_numba_vs_cython():
  267:     pytest.importorskip("numba")
  268:     df = DataFrame(
  269:         {
  270:             "A": ["foo", "bar", "foo", "bar", "foo", "bar", "foo", "foo"],
  271:             "B": ["one", "one", "two", "three", "two", "two", "one", "three"],
  272:             "C": np.random.default_rng(2).standard_normal(8),
  273:             "D": np.random.default_rng(2).standard_normal(8),
  274:         }
  275:     )
  276:     gb = df.groupby(["A", "B"])
  277:     result = gb.transform(
  278:         lambda values, index: (values - values.min()) / (values.max() - values.min()),
  279:         engine="numba",
  280:     )
  281:     expected = gb.transform(
  282:         lambda x: (x - x.min()) / (x.max() - x.min()), engine="cython"
  283:     )
  284:     tm.assert_frame_equal(result, expected)
