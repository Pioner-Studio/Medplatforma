    1: import numpy as np
    2: 
    3: import pandas as pd
    4: import pandas._testing as tm
    5: 
    6: 
    7: def test_group_by_copy():
    8:     # GH#44803
    9:     df = pd.DataFrame(
   10:         {
   11:             "name": ["Alice", "Bob", "Carl"],
   12:             "age": [20, 21, 20],
   13:         }
   14:     ).set_index("name")
   15: 
   16:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
   17:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
   18:         grp_by_same_value = df.groupby(["age"], group_keys=False).apply(
   19:             lambda group: group
   20:         )
   21:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
   22:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
   23:         grp_by_copy = df.groupby(["age"], group_keys=False).apply(
   24:             lambda group: group.copy()
   25:         )
   26:     tm.assert_frame_equal(grp_by_same_value, grp_by_copy)
   27: 
   28: 
   29: def test_mutate_groups():
   30:     # GH3380
   31: 
   32:     df = pd.DataFrame(
   33:         {
   34:             "cat1": ["a"] * 8 + ["b"] * 6,
   35:             "cat2": ["c"] * 2
   36:             + ["d"] * 2
   37:             + ["e"] * 2
   38:             + ["f"] * 2
   39:             + ["c"] * 2
   40:             + ["d"] * 2
   41:             + ["e"] * 2,
   42:             "cat3": [f"g{x}" for x in range(1, 15)],
   43:             "val": np.random.default_rng(2).integers(100, size=14),
   44:         }
   45:     )
   46: 
   47:     def f_copy(x):
   48:         x = x.copy()
   49:         x["rank"] = x.val.rank(method="min")
   50:         return x.groupby("cat2")["rank"].min()
   51: 
   52:     def f_no_copy(x):
   53:         x["rank"] = x.val.rank(method="min")
   54:         return x.groupby("cat2")["rank"].min()
   55: 
   56:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
   57:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
   58:         grpby_copy = df.groupby("cat1").apply(f_copy)
   59:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
   60:         grpby_no_copy = df.groupby("cat1").apply(f_no_copy)
   61:     tm.assert_series_equal(grpby_copy, grpby_no_copy)
   62: 
   63: 
   64: def test_no_mutate_but_looks_like():
   65:     # GH 8467
   66:     # first show's mutation indicator
   67:     # second does not, but should yield the same results
   68:     df = pd.DataFrame({"key": [1, 1, 1, 2, 2, 2, 3, 3, 3], "value": range(9)})
   69: 
   70:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
   71:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
   72:         result1 = df.groupby("key", group_keys=True).apply(lambda x: x[:].key)
   73:     with tm.assert_produces_warning(DeprecationWarning, match=msg):
   74:         result2 = df.groupby("key", group_keys=True).apply(lambda x: x.key)
   75:     tm.assert_series_equal(result1, result2)
   76: 
   77: 
   78: def test_apply_function_with_indexing(warn_copy_on_write):
   79:     # GH: 33058
   80:     df = pd.DataFrame(
   81:         {"col1": ["A", "A", "A", "B", "B", "B"], "col2": [1, 2, 3, 4, 5, 6]}
   82:     )
   83: 
   84:     def fn(x):
   85:         x.loc[x.index[-1], "col2"] = 0
   86:         return x.col2
   87: 
   88:     msg = "DataFrameGroupBy.apply operated on the grouping columns"
   89:     with tm.assert_produces_warning(
   90:         DeprecationWarning, match=msg, raise_on_extra_warnings=not warn_copy_on_write
   91:     ):
   92:         result = df.groupby(["col1"], as_index=False).apply(fn)
   93:     expected = pd.Series(
   94:         [1, 2, 0, 4, 5, 0],
   95:         index=pd.MultiIndex.from_tuples(
   96:             [(0, 0), (0, 1), (0, 2), (1, 3), (1, 4), (1, 5)]
   97:         ),
   98:         name="col2",
   99:     )
  100:     tm.assert_series_equal(result, expected)
  101: 
  102: 
  103: def test_apply_mutate_columns_multiindex():
  104:     # GH 12652
  105:     df = pd.DataFrame(
  106:         {
  107:             ("C", "julian"): [1, 2, 3],
  108:             ("B", "geoffrey"): [1, 2, 3],
  109:             ("A", "julian"): [1, 2, 3],
  110:             ("B", "julian"): [1, 2, 3],
  111:             ("A", "geoffrey"): [1, 2, 3],
  112:             ("C", "geoffrey"): [1, 2, 3],
  113:         },
  114:         columns=pd.MultiIndex.from_tuples(
  115:             [
  116:                 ("A", "julian"),
  117:                 ("A", "geoffrey"),
  118:                 ("B", "julian"),
  119:                 ("B", "geoffrey"),
  120:                 ("C", "julian"),
  121:                 ("C", "geoffrey"),
  122:             ]
  123:         ),
  124:     )
  125: 
  126:     def add_column(grouped):
  127:         name = grouped.columns[0][1]
  128:         grouped["sum", name] = grouped.sum(axis=1)
  129:         return grouped
  130: 
  131:     msg = "DataFrame.groupby with axis=1 is deprecated"
  132:     with tm.assert_produces_warning(FutureWarning, match=msg):
  133:         gb = df.groupby(level=1, axis=1)
  134:     result = gb.apply(add_column)
  135:     expected = pd.DataFrame(
  136:         [
  137:             [1, 1, 1, 3, 1, 1, 1, 3],
  138:             [2, 2, 2, 6, 2, 2, 2, 6],
  139:             [
  140:                 3,
  141:                 3,
  142:                 3,
  143:                 9,
  144:                 3,
  145:                 3,
  146:                 3,
  147:                 9,
  148:             ],
  149:         ],
  150:         columns=pd.MultiIndex.from_tuples(
  151:             [
  152:                 ("geoffrey", "A", "geoffrey"),
  153:                 ("geoffrey", "B", "geoffrey"),
  154:                 ("geoffrey", "C", "geoffrey"),
  155:                 ("geoffrey", "sum", "geoffrey"),
  156:                 ("julian", "A", "julian"),
  157:                 ("julian", "B", "julian"),
  158:                 ("julian", "C", "julian"),
  159:                 ("julian", "sum", "julian"),
  160:             ]
  161:         ),
  162:     )
  163:     tm.assert_frame_equal(result, expected)
