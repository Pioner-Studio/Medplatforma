    1: from collections import (
    2:     Counter,
    3:     defaultdict,
    4: )
    5: from decimal import Decimal
    6: import math
    7: 
    8: import numpy as np
    9: import pytest
   10: 
   11: import pandas as pd
   12: from pandas import (
   13:     DataFrame,
   14:     Index,
   15:     MultiIndex,
   16:     Series,
   17:     bdate_range,
   18:     date_range,
   19:     isna,
   20:     timedelta_range,
   21: )
   22: import pandas._testing as tm
   23: 
   24: 
   25: def test_series_map_box_timedelta():
   26:     # GH#11349
   27:     ser = Series(timedelta_range("1 day 1 s", periods=5, freq="h"))
   28: 
   29:     def f(x):
   30:         return x.total_seconds()
   31: 
   32:     ser.map(f)
   33: 
   34: 
   35: def test_map_callable(datetime_series):
   36:     with np.errstate(all="ignore"):
   37:         tm.assert_series_equal(datetime_series.map(np.sqrt), np.sqrt(datetime_series))
   38: 
   39:     # map function element-wise
   40:     tm.assert_series_equal(datetime_series.map(math.exp), np.exp(datetime_series))
   41: 
   42:     # empty series
   43:     s = Series(dtype=object, name="foo", index=Index([], name="bar"))
   44:     rs = s.map(lambda x: x)
   45:     tm.assert_series_equal(s, rs)
   46: 
   47:     # check all metadata (GH 9322)
   48:     assert s is not rs
   49:     assert s.index is rs.index
   50:     assert s.dtype == rs.dtype
   51:     assert s.name == rs.name
   52: 
   53:     # index but no data
   54:     s = Series(index=[1, 2, 3], dtype=np.float64)
   55:     rs = s.map(lambda x: x)
   56:     tm.assert_series_equal(s, rs)
   57: 
   58: 
   59: def test_map_same_length_inference_bug():
   60:     s = Series([1, 2])
   61: 
   62:     def f(x):
   63:         return (x, x + 1)
   64: 
   65:     s = Series([1, 2, 3])
   66:     result = s.map(f)
   67:     expected = Series([(1, 2), (2, 3), (3, 4)])
   68:     tm.assert_series_equal(result, expected)
   69: 
   70:     s = Series(["foo,bar"])
   71:     result = s.map(lambda x: x.split(","))
   72:     expected = Series([("foo", "bar")])
   73:     tm.assert_series_equal(result, expected)
   74: 
   75: 
   76: def test_series_map_box_timestamps():
   77:     # GH#2689, GH#2627
   78:     ser = Series(date_range("1/1/2000", periods=3))
   79: 
   80:     def func(x):
   81:         return (x.hour, x.day, x.month)
   82: 
   83:     result = ser.map(func)
   84:     expected = Series([(0, 1, 1), (0, 2, 1), (0, 3, 1)])
   85:     tm.assert_series_equal(result, expected)
   86: 
   87: 
   88: def test_map_series_stringdtype(any_string_dtype, using_infer_string):
   89:     # map test on StringDType, GH#40823
   90:     ser1 = Series(
   91:         data=["cat", "dog", "rabbit"],
   92:         index=["id1", "id2", "id3"],
   93:         dtype=any_string_dtype,
   94:     )
   95:     ser2 = Series(["id3", "id2", "id1", "id7000"], dtype=any_string_dtype)
   96:     result = ser2.map(ser1)
   97: 
   98:     item = pd.NA
   99:     if ser2.dtype == object:
  100:         item = np.nan
  101: 
  102:     expected = Series(data=["rabbit", "dog", "cat", item], dtype=any_string_dtype)
  103:     if using_infer_string and any_string_dtype == "object":
  104:         expected = expected.astype("string[pyarrow_numpy]")
  105: 
  106:     tm.assert_series_equal(result, expected)
  107: 
  108: 
  109: @pytest.mark.parametrize(
  110:     "data, expected_dtype",
  111:     [(["1-1", "1-1", np.nan], "category"), (["1-1", "1-2", np.nan], object)],
  112: )
  113: def test_map_categorical_with_nan_values(data, expected_dtype, using_infer_string):
  114:     # GH 20714 bug fixed in: GH 24275
  115:     def func(val):
  116:         return val.split("-")[0]
  117: 
  118:     s = Series(data, dtype="category")
  119: 
  120:     result = s.map(func, na_action="ignore")
  121:     if using_infer_string and expected_dtype == object:
  122:         expected_dtype = "string[pyarrow_numpy]"
  123:     expected = Series(["1", "1", np.nan], dtype=expected_dtype)
  124:     tm.assert_series_equal(result, expected)
  125: 
  126: 
  127: def test_map_empty_integer_series():
  128:     # GH52384
  129:     s = Series([], dtype=int)
  130:     result = s.map(lambda x: x)
  131:     tm.assert_series_equal(result, s)
  132: 
  133: 
  134: def test_map_empty_integer_series_with_datetime_index():
  135:     # GH 21245
  136:     s = Series([], index=date_range(start="2018-01-01", periods=0), dtype=int)
  137:     result = s.map(lambda x: x)
  138:     tm.assert_series_equal(result, s)
  139: 
  140: 
  141: @pytest.mark.parametrize("func", [str, lambda x: str(x)])
  142: def test_map_simple_str_callables_same_as_astype(
  143:     string_series, func, using_infer_string
  144: ):
  145:     # test that we are evaluating row-by-row first
  146:     # before vectorized evaluation
  147:     result = string_series.map(func)
  148:     expected = string_series.astype(
  149:         str if not using_infer_string else "string[pyarrow_numpy]"
  150:     )
  151:     tm.assert_series_equal(result, expected)
  152: 
  153: 
  154: def test_list_raises(string_series):
  155:     with pytest.raises(TypeError, match="'list' object is not callable"):
  156:         string_series.map([lambda x: x])
  157: 
  158: 
  159: def test_map():
  160:     data = {
  161:         "A": [0.0, 1.0, 2.0, 3.0, 4.0],
  162:         "B": [0.0, 1.0, 0.0, 1.0, 0.0],
  163:         "C": ["foo1", "foo2", "foo3", "foo4", "foo5"],
  164:         "D": bdate_range("1/1/2009", periods=5),
  165:     }
  166: 
  167:     source = Series(data["B"], index=data["C"])
  168:     target = Series(data["C"][:4], index=data["D"][:4])
  169: 
  170:     merged = target.map(source)
  171: 
  172:     for k, v in merged.items():
  173:         assert v == source[target[k]]
  174: 
  175:     # input could be a dict
  176:     merged = target.map(source.to_dict())
  177: 
  178:     for k, v in merged.items():
  179:         assert v == source[target[k]]
  180: 
  181: 
  182: def test_map_datetime(datetime_series):
  183:     # function
  184:     result = datetime_series.map(lambda x: x * 2)
  185:     tm.assert_series_equal(result, datetime_series * 2)
  186: 
  187: 
  188: def test_map_category():
  189:     # GH 10324
  190:     a = Series([1, 2, 3, 4])
  191:     b = Series(["even", "odd", "even", "odd"], dtype="category")
  192:     c = Series(["even", "odd", "even", "odd"])
  193: 
  194:     exp = Series(["odd", "even", "odd", np.nan], dtype="category")
  195:     tm.assert_series_equal(a.map(b), exp)
  196:     exp = Series(["odd", "even", "odd", np.nan])
  197:     tm.assert_series_equal(a.map(c), exp)
  198: 
  199: 
  200: def test_map_category_numeric():
  201:     a = Series(["a", "b", "c", "d"])
  202:     b = Series([1, 2, 3, 4], index=pd.CategoricalIndex(["b", "c", "d", "e"]))
  203:     c = Series([1, 2, 3, 4], index=Index(["b", "c", "d", "e"]))
  204: 
  205:     exp = Series([np.nan, 1, 2, 3])
  206:     tm.assert_series_equal(a.map(b), exp)
  207:     exp = Series([np.nan, 1, 2, 3])
  208:     tm.assert_series_equal(a.map(c), exp)
  209: 
  210: 
  211: def test_map_category_string():
  212:     a = Series(["a", "b", "c", "d"])
  213:     b = Series(
  214:         ["B", "C", "D", "E"],
  215:         dtype="category",
  216:         index=pd.CategoricalIndex(["b", "c", "d", "e"]),
  217:     )
  218:     c = Series(["B", "C", "D", "E"], index=Index(["b", "c", "d", "e"]))
  219: 
  220:     exp = Series(
  221:         pd.Categorical([np.nan, "B", "C", "D"], categories=["B", "C", "D", "E"])
  222:     )
  223:     tm.assert_series_equal(a.map(b), exp)
  224:     exp = Series([np.nan, "B", "C", "D"])
  225:     tm.assert_series_equal(a.map(c), exp)
  226: 
  227: 
  228: def test_map_empty(request, index):
  229:     if isinstance(index, MultiIndex):
  230:         request.applymarker(
  231:             pytest.mark.xfail(
  232:                 reason="Initializing a Series from a MultiIndex is not supported"
  233:             )
  234:         )
  235: 
  236:     s = Series(index)
  237:     result = s.map({})
  238: 
  239:     expected = Series(np.nan, index=s.index)
  240:     tm.assert_series_equal(result, expected)
  241: 
  242: 
  243: def test_map_compat():
  244:     # related GH 8024
  245:     s = Series([True, True, False], index=[1, 2, 3])
  246:     result = s.map({True: "foo", False: "bar"})
  247:     expected = Series(["foo", "foo", "bar"], index=[1, 2, 3])
  248:     tm.assert_series_equal(result, expected)
  249: 
  250: 
  251: def test_map_int():
  252:     left = Series({"a": 1.0, "b": 2.0, "c": 3.0, "d": 4})
  253:     right = Series({1: 11, 2: 22, 3: 33})
  254: 
  255:     assert left.dtype == np.float64
  256:     assert issubclass(right.dtype.type, np.integer)
  257: 
  258:     merged = left.map(right)
  259:     assert merged.dtype == np.float64
  260:     assert isna(merged["d"])
  261:     assert not isna(merged["c"])
  262: 
  263: 
  264: def test_map_type_inference():
  265:     s = Series(range(3))
  266:     s2 = s.map(lambda x: np.where(x == 0, 0, 1))
  267:     assert issubclass(s2.dtype.type, np.integer)
  268: 
  269: 
  270: def test_map_decimal(string_series):
  271:     result = string_series.map(lambda x: Decimal(str(x)))
  272:     assert result.dtype == np.object_
  273:     assert isinstance(result.iloc[0], Decimal)
  274: 
  275: 
  276: def test_map_na_exclusion():
  277:     s = Series([1.5, np.nan, 3, np.nan, 5])
  278: 
  279:     result = s.map(lambda x: x * 2, na_action="ignore")
  280:     exp = s * 2
  281:     tm.assert_series_equal(result, exp)
  282: 
  283: 
  284: def test_map_dict_with_tuple_keys():
  285:     """
  286:     Due to new MultiIndex-ing behaviour in v0.14.0,
  287:     dicts with tuple keys passed to map were being
  288:     converted to a multi-index, preventing tuple values
  289:     from being mapped properly.
  290:     """
  291:     # GH 18496
  292:     df = DataFrame({"a": [(1,), (2,), (3, 4), (5, 6)]})
  293:     label_mappings = {(1,): "A", (2,): "B", (3, 4): "A", (5, 6): "B"}
  294: 
  295:     df["labels"] = df["a"].map(label_mappings)
  296:     df["expected_labels"] = Series(["A", "B", "A", "B"], index=df.index)
  297:     # All labels should be filled now
  298:     tm.assert_series_equal(df["labels"], df["expected_labels"], check_names=False)
  299: 
  300: 
  301: def test_map_counter():
  302:     s = Series(["a", "b", "c"], index=[1, 2, 3])
  303:     counter = Counter()
  304:     counter["b"] = 5
  305:     counter["c"] += 1
  306:     result = s.map(counter)
  307:     expected = Series([0, 5, 1], index=[1, 2, 3])
  308:     tm.assert_series_equal(result, expected)
  309: 
  310: 
  311: def test_map_defaultdict():
  312:     s = Series([1, 2, 3], index=["a", "b", "c"])
  313:     default_dict = defaultdict(lambda: "blank")
  314:     default_dict[1] = "stuff"
  315:     result = s.map(default_dict)
  316:     expected = Series(["stuff", "blank", "blank"], index=["a", "b", "c"])
  317:     tm.assert_series_equal(result, expected)
  318: 
  319: 
  320: def test_map_dict_na_key():
  321:     # https://github.com/pandas-dev/pandas/issues/17648
  322:     # Checks that np.nan key is appropriately mapped
  323:     s = Series([1, 2, np.nan])
  324:     expected = Series(["a", "b", "c"])
  325:     result = s.map({1: "a", 2: "b", np.nan: "c"})
  326:     tm.assert_series_equal(result, expected)
  327: 
  328: 
  329: @pytest.mark.parametrize("na_action", [None, "ignore"])
  330: def test_map_defaultdict_na_key(na_action):
  331:     # GH 48813
  332:     s = Series([1, 2, np.nan])
  333:     default_map = defaultdict(lambda: "missing", {1: "a", 2: "b", np.nan: "c"})
  334:     result = s.map(default_map, na_action=na_action)
  335:     expected = Series({0: "a", 1: "b", 2: "c" if na_action is None else np.nan})
  336:     tm.assert_series_equal(result, expected)
  337: 
  338: 
  339: @pytest.mark.parametrize("na_action", [None, "ignore"])
  340: def test_map_defaultdict_missing_key(na_action):
  341:     # GH 48813
  342:     s = Series([1, 2, np.nan])
  343:     default_map = defaultdict(lambda: "missing", {1: "a", 2: "b", 3: "c"})
  344:     result = s.map(default_map, na_action=na_action)
  345:     expected = Series({0: "a", 1: "b", 2: "missing" if na_action is None else np.nan})
  346:     tm.assert_series_equal(result, expected)
  347: 
  348: 
  349: @pytest.mark.parametrize("na_action", [None, "ignore"])
  350: def test_map_defaultdict_unmutated(na_action):
  351:     # GH 48813
  352:     s = Series([1, 2, np.nan])
  353:     default_map = defaultdict(lambda: "missing", {1: "a", 2: "b", np.nan: "c"})
  354:     expected_default_map = default_map.copy()
  355:     s.map(default_map, na_action=na_action)
  356:     assert default_map == expected_default_map
  357: 
  358: 
  359: @pytest.mark.parametrize("arg_func", [dict, Series])
  360: def test_map_dict_ignore_na(arg_func):
  361:     # GH#47527
  362:     mapping = arg_func({1: 10, np.nan: 42})
  363:     ser = Series([1, np.nan, 2])
  364:     result = ser.map(mapping, na_action="ignore")
  365:     expected = Series([10, np.nan, np.nan])
  366:     tm.assert_series_equal(result, expected)
  367: 
  368: 
  369: def test_map_defaultdict_ignore_na():
  370:     # GH#47527
  371:     mapping = defaultdict(int, {1: 10, np.nan: 42})
  372:     ser = Series([1, np.nan, 2])
  373:     result = ser.map(mapping)
  374:     expected = Series([10, 42, 0])
  375:     tm.assert_series_equal(result, expected)
  376: 
  377: 
  378: @pytest.mark.parametrize(
  379:     "na_action, expected",
  380:     [(None, Series([10.0, 42.0, np.nan])), ("ignore", Series([10, np.nan, np.nan]))],
  381: )
  382: def test_map_categorical_na_ignore(na_action, expected):
  383:     # GH#47527
  384:     values = pd.Categorical([1, np.nan, 2], categories=[10, 1, 2])
  385:     ser = Series(values)
  386:     result = ser.map({1: 10, np.nan: 42}, na_action=na_action)
  387:     tm.assert_series_equal(result, expected)
  388: 
  389: 
  390: def test_map_dict_subclass_with_missing():
  391:     """
  392:     Test Series.map with a dictionary subclass that defines __missing__,
  393:     i.e. sets a default value (GH #15999).
  394:     """
  395: 
  396:     class DictWithMissing(dict):
  397:         def __missing__(self, key):
  398:             return "missing"
  399: 
  400:     s = Series([1, 2, 3])
  401:     dictionary = DictWithMissing({3: "three"})
  402:     result = s.map(dictionary)
  403:     expected = Series(["missing", "missing", "three"])
  404:     tm.assert_series_equal(result, expected)
  405: 
  406: 
  407: def test_map_dict_subclass_without_missing():
  408:     class DictWithoutMissing(dict):
  409:         pass
  410: 
  411:     s = Series([1, 2, 3])
  412:     dictionary = DictWithoutMissing({3: "three"})
  413:     result = s.map(dictionary)
  414:     expected = Series([np.nan, np.nan, "three"])
  415:     tm.assert_series_equal(result, expected)
  416: 
  417: 
  418: def test_map_abc_mapping(non_dict_mapping_subclass):
  419:     # https://github.com/pandas-dev/pandas/issues/29733
  420:     # Check collections.abc.Mapping support as mapper for Series.map
  421:     s = Series([1, 2, 3])
  422:     not_a_dictionary = non_dict_mapping_subclass({3: "three"})
  423:     result = s.map(not_a_dictionary)
  424:     expected = Series([np.nan, np.nan, "three"])
  425:     tm.assert_series_equal(result, expected)
  426: 
  427: 
  428: def test_map_abc_mapping_with_missing(non_dict_mapping_subclass):
  429:     # https://github.com/pandas-dev/pandas/issues/29733
  430:     # Check collections.abc.Mapping support as mapper for Series.map
  431:     class NonDictMappingWithMissing(non_dict_mapping_subclass):
  432:         def __missing__(self, key):
  433:             return "missing"
  434: 
  435:     s = Series([1, 2, 3])
  436:     not_a_dictionary = NonDictMappingWithMissing({3: "three"})
  437:     result = s.map(not_a_dictionary)
  438:     # __missing__ is a dict concept, not a Mapping concept,
  439:     # so it should not change the result!
  440:     expected = Series([np.nan, np.nan, "three"])
  441:     tm.assert_series_equal(result, expected)
  442: 
  443: 
  444: def test_map_box_dt64(unit):
  445:     vals = [pd.Timestamp("2011-01-01"), pd.Timestamp("2011-01-02")]
  446:     ser = Series(vals).dt.as_unit(unit)
  447:     assert ser.dtype == f"datetime64[{unit}]"
  448:     # boxed value must be Timestamp instance
  449:     res = ser.map(lambda x: f"{type(x).__name__}_{x.day}_{x.tz}")
  450:     exp = Series(["Timestamp_1_None", "Timestamp_2_None"])
  451:     tm.assert_series_equal(res, exp)
  452: 
  453: 
  454: def test_map_box_dt64tz(unit):
  455:     vals = [
  456:         pd.Timestamp("2011-01-01", tz="US/Eastern"),
  457:         pd.Timestamp("2011-01-02", tz="US/Eastern"),
  458:     ]
  459:     ser = Series(vals).dt.as_unit(unit)
  460:     assert ser.dtype == f"datetime64[{unit}, US/Eastern]"
  461:     res = ser.map(lambda x: f"{type(x).__name__}_{x.day}_{x.tz}")
  462:     exp = Series(["Timestamp_1_US/Eastern", "Timestamp_2_US/Eastern"])
  463:     tm.assert_series_equal(res, exp)
  464: 
  465: 
  466: def test_map_box_td64(unit):
  467:     # timedelta
  468:     vals = [pd.Timedelta("1 days"), pd.Timedelta("2 days")]
  469:     ser = Series(vals).dt.as_unit(unit)
  470:     assert ser.dtype == f"timedelta64[{unit}]"
  471:     res = ser.map(lambda x: f"{type(x).__name__}_{x.days}")
  472:     exp = Series(["Timedelta_1", "Timedelta_2"])
  473:     tm.assert_series_equal(res, exp)
  474: 
  475: 
  476: def test_map_box_period():
  477:     # period
  478:     vals = [pd.Period("2011-01-01", freq="M"), pd.Period("2011-01-02", freq="M")]
  479:     ser = Series(vals)
  480:     assert ser.dtype == "Period[M]"
  481:     res = ser.map(lambda x: f"{type(x).__name__}_{x.freqstr}")
  482:     exp = Series(["Period_M", "Period_M"])
  483:     tm.assert_series_equal(res, exp)
  484: 
  485: 
  486: @pytest.mark.parametrize("na_action", [None, "ignore"])
  487: def test_map_categorical(na_action, using_infer_string):
  488:     values = pd.Categorical(list("ABBABCD"), categories=list("DCBA"), ordered=True)
  489:     s = Series(values, name="XX", index=list("abcdefg"))
  490: 
  491:     result = s.map(lambda x: x.lower(), na_action=na_action)
  492:     exp_values = pd.Categorical(list("abbabcd"), categories=list("dcba"), ordered=True)
  493:     exp = Series(exp_values, name="XX", index=list("abcdefg"))
  494:     tm.assert_series_equal(result, exp)
  495:     tm.assert_categorical_equal(result.values, exp_values)
  496: 
  497:     result = s.map(lambda x: "A", na_action=na_action)
  498:     exp = Series(["A"] * 7, name="XX", index=list("abcdefg"))
  499:     tm.assert_series_equal(result, exp)
  500:     assert result.dtype == object if not using_infer_string else "string"
  501: 
  502: 
  503: @pytest.mark.parametrize(
  504:     "na_action, expected",
  505:     (
  506:         [None, Series(["A", "B", "nan"], name="XX")],
  507:         [
  508:             "ignore",
  509:             Series(
  510:                 ["A", "B", np.nan],
  511:                 name="XX",
  512:                 dtype=pd.CategoricalDtype(list("DCBA"), True),
  513:             ),
  514:         ],
  515:     ),
  516: )
  517: def test_map_categorical_na_action(na_action, expected):
  518:     dtype = pd.CategoricalDtype(list("DCBA"), ordered=True)
  519:     values = pd.Categorical(list("AB") + [np.nan], dtype=dtype)
  520:     s = Series(values, name="XX")
  521:     result = s.map(str, na_action=na_action)
  522:     tm.assert_series_equal(result, expected)
  523: 
  524: 
  525: def test_map_datetimetz():
  526:     values = date_range("2011-01-01", "2011-01-02", freq="h").tz_localize("Asia/Tokyo")
  527:     s = Series(values, name="XX")
  528: 
  529:     # keep tz
  530:     result = s.map(lambda x: x + pd.offsets.Day())
  531:     exp_values = date_range("2011-01-02", "2011-01-03", freq="h").tz_localize(
  532:         "Asia/Tokyo"
  533:     )
  534:     exp = Series(exp_values, name="XX")
  535:     tm.assert_series_equal(result, exp)
  536: 
  537:     result = s.map(lambda x: x.hour)
  538:     exp = Series(list(range(24)) + [0], name="XX", dtype=np.int64)
  539:     tm.assert_series_equal(result, exp)
  540: 
  541:     # not vectorized
  542:     def f(x):
  543:         if not isinstance(x, pd.Timestamp):
  544:             raise ValueError
  545:         return str(x.tz)
  546: 
  547:     result = s.map(f)
  548:     exp = Series(["Asia/Tokyo"] * 25, name="XX")
  549:     tm.assert_series_equal(result, exp)
  550: 
  551: 
  552: @pytest.mark.parametrize(
  553:     "vals,mapping,exp",
  554:     [
  555:         (list("abc"), {np.nan: "not NaN"}, [np.nan] * 3 + ["not NaN"]),
  556:         (list("abc"), {"a": "a letter"}, ["a letter"] + [np.nan] * 3),
  557:         (list(range(3)), {0: 42}, [42] + [np.nan] * 3),
  558:     ],
  559: )
  560: def test_map_missing_mixed(vals, mapping, exp, using_infer_string):
  561:     # GH20495
  562:     s = Series(vals + [np.nan])
  563:     result = s.map(mapping)
  564:     exp = Series(exp)
  565:     if using_infer_string and mapping == {np.nan: "not NaN"}:
  566:         exp.iloc[-1] = np.nan
  567:     tm.assert_series_equal(result, exp)
  568: 
  569: 
  570: def test_map_scalar_on_date_time_index_aware_series():
  571:     # GH 25959
  572:     # Calling map on a localized time series should not cause an error
  573:     series = Series(
  574:         np.arange(10, dtype=np.float64),
  575:         index=date_range("2020-01-01", periods=10, tz="UTC"),
  576:         name="ts",
  577:     )
  578:     result = Series(series.index).map(lambda x: 1)
  579:     tm.assert_series_equal(result, Series(np.ones(len(series)), dtype="int64"))
  580: 
  581: 
  582: def test_map_float_to_string_precision():
  583:     # GH 13228
  584:     ser = Series(1 / 3)
  585:     result = ser.map(lambda val: str(val)).to_dict()
  586:     expected = {0: "0.3333333333333333"}
  587:     assert result == expected
  588: 
  589: 
  590: def test_map_to_timedelta():
  591:     list_of_valid_strings = ["00:00:01", "00:00:02"]
  592:     a = pd.to_timedelta(list_of_valid_strings)
  593:     b = Series(list_of_valid_strings).map(pd.to_timedelta)
  594:     tm.assert_series_equal(Series(a), b)
  595: 
  596:     list_of_strings = ["00:00:01", np.nan, pd.NaT, pd.NaT]
  597: 
  598:     a = pd.to_timedelta(list_of_strings)
  599:     ser = Series(list_of_strings)
  600:     b = ser.map(pd.to_timedelta)
  601:     tm.assert_series_equal(Series(a), b)
  602: 
  603: 
  604: def test_map_type():
  605:     # GH 46719
  606:     s = Series([3, "string", float], index=["a", "b", "c"])
  607:     result = s.map(type)
  608:     expected = Series([int, str, type], index=["a", "b", "c"])
  609:     tm.assert_series_equal(result, expected)
