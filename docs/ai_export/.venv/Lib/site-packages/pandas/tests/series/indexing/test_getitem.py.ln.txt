    1: """
    2: Series.__getitem__ test classes are organized by the type of key passed.
    3: """
    4: from datetime import (
    5:     date,
    6:     datetime,
    7:     time,
    8: )
    9: 
   10: import numpy as np
   11: import pytest
   12: 
   13: from pandas._libs.tslibs import (
   14:     conversion,
   15:     timezones,
   16: )
   17: 
   18: from pandas.core.dtypes.common import is_scalar
   19: 
   20: import pandas as pd
   21: from pandas import (
   22:     Categorical,
   23:     DataFrame,
   24:     DatetimeIndex,
   25:     Index,
   26:     Series,
   27:     Timestamp,
   28:     date_range,
   29:     period_range,
   30:     timedelta_range,
   31: )
   32: import pandas._testing as tm
   33: from pandas.core.indexing import IndexingError
   34: 
   35: from pandas.tseries.offsets import BDay
   36: 
   37: 
   38: class TestSeriesGetitemScalars:
   39:     def test_getitem_object_index_float_string(self):
   40:         # GH#17286
   41:         ser = Series([1] * 4, index=Index(["a", "b", "c", 1.0]))
   42:         assert ser["a"] == 1
   43:         assert ser[1.0] == 1
   44: 
   45:     def test_getitem_float_keys_tuple_values(self):
   46:         # see GH#13509
   47: 
   48:         # unique Index
   49:         ser = Series([(1, 1), (2, 2), (3, 3)], index=[0.0, 0.1, 0.2], name="foo")
   50:         result = ser[0.0]
   51:         assert result == (1, 1)
   52: 
   53:         # non-unique Index
   54:         expected = Series([(1, 1), (2, 2)], index=[0.0, 0.0], name="foo")
   55:         ser = Series([(1, 1), (2, 2), (3, 3)], index=[0.0, 0.0, 0.2], name="foo")
   56: 
   57:         result = ser[0.0]
   58:         tm.assert_series_equal(result, expected)
   59: 
   60:     def test_getitem_unrecognized_scalar(self):
   61:         # GH#32684 a scalar key that is not recognized by lib.is_scalar
   62: 
   63:         # a series that might be produced via `frame.dtypes`
   64:         ser = Series([1, 2], index=[np.dtype("O"), np.dtype("i8")])
   65: 
   66:         key = ser.index[1]
   67: 
   68:         result = ser[key]
   69:         assert result == 2
   70: 
   71:     def test_getitem_negative_out_of_bounds(self):
   72:         ser = Series(["a"] * 10, index=["a"] * 10)
   73: 
   74:         msg = "index -11 is out of bounds for axis 0 with size 10|index out of bounds"
   75:         warn_msg = "Series.__getitem__ treating keys as positions is deprecated"
   76:         with pytest.raises(IndexError, match=msg):
   77:             with tm.assert_produces_warning(FutureWarning, match=warn_msg):
   78:                 ser[-11]
   79: 
   80:     def test_getitem_out_of_bounds_indexerror(self, datetime_series):
   81:         # don't segfault, GH#495
   82:         msg = r"index \d+ is out of bounds for axis 0 with size \d+"
   83:         warn_msg = "Series.__getitem__ treating keys as positions is deprecated"
   84:         with pytest.raises(IndexError, match=msg):
   85:             with tm.assert_produces_warning(FutureWarning, match=warn_msg):
   86:                 datetime_series[len(datetime_series)]
   87: 
   88:     def test_getitem_out_of_bounds_empty_rangeindex_keyerror(self):
   89:         # GH#917
   90:         # With a RangeIndex, an int key gives a KeyError
   91:         ser = Series([], dtype=object)
   92:         with pytest.raises(KeyError, match="-1"):
   93:             ser[-1]
   94: 
   95:     def test_getitem_keyerror_with_integer_index(self, any_int_numpy_dtype):
   96:         dtype = any_int_numpy_dtype
   97:         ser = Series(
   98:             np.random.default_rng(2).standard_normal(6),
   99:             index=Index([0, 0, 1, 1, 2, 2], dtype=dtype),
  100:         )
  101: 
  102:         with pytest.raises(KeyError, match=r"^5$"):
  103:             ser[5]
  104: 
  105:         with pytest.raises(KeyError, match=r"^'c'$"):
  106:             ser["c"]
  107: 
  108:         # not monotonic
  109:         ser = Series(
  110:             np.random.default_rng(2).standard_normal(6), index=[2, 2, 0, 0, 1, 1]
  111:         )
  112: 
  113:         with pytest.raises(KeyError, match=r"^5$"):
  114:             ser[5]
  115: 
  116:         with pytest.raises(KeyError, match=r"^'c'$"):
  117:             ser["c"]
  118: 
  119:     def test_getitem_int64(self, datetime_series):
  120:         idx = np.int64(5)
  121:         msg = "Series.__getitem__ treating keys as positions is deprecated"
  122:         with tm.assert_produces_warning(FutureWarning, match=msg):
  123:             res = datetime_series[idx]
  124:         assert res == datetime_series.iloc[5]
  125: 
  126:     def test_getitem_full_range(self):
  127:         # github.com/pandas-dev/pandas/commit/4f433773141d2eb384325714a2776bcc5b2e20f7
  128:         ser = Series(range(5), index=list(range(5)))
  129:         result = ser[list(range(5))]
  130:         tm.assert_series_equal(result, ser)
  131: 
  132:     # ------------------------------------------------------------------
  133:     # Series with DatetimeIndex
  134: 
  135:     @pytest.mark.parametrize("tzstr", ["Europe/Berlin", "dateutil/Europe/Berlin"])
  136:     def test_getitem_pydatetime_tz(self, tzstr):
  137:         tz = timezones.maybe_get_tz(tzstr)
  138: 
  139:         index = date_range(
  140:             start="2012-12-24 16:00", end="2012-12-24 18:00", freq="h", tz=tzstr
  141:         )
  142:         ts = Series(index=index, data=index.hour)
  143:         time_pandas = Timestamp("2012-12-24 17:00", tz=tzstr)
  144: 
  145:         dt = datetime(2012, 12, 24, 17, 0)
  146:         time_datetime = conversion.localize_pydatetime(dt, tz)
  147:         assert ts[time_pandas] == ts[time_datetime]
  148: 
  149:     @pytest.mark.parametrize("tz", ["US/Eastern", "dateutil/US/Eastern"])
  150:     def test_string_index_alias_tz_aware(self, tz):
  151:         rng = date_range("1/1/2000", periods=10, tz=tz)
  152:         ser = Series(np.random.default_rng(2).standard_normal(len(rng)), index=rng)
  153: 
  154:         result = ser["1/3/2000"]
  155:         tm.assert_almost_equal(result, ser.iloc[2])
  156: 
  157:     def test_getitem_time_object(self):
  158:         rng = date_range("1/1/2000", "1/5/2000", freq="5min")
  159:         ts = Series(np.random.default_rng(2).standard_normal(len(rng)), index=rng)
  160: 
  161:         mask = (rng.hour == 9) & (rng.minute == 30)
  162:         result = ts[time(9, 30)]
  163:         expected = ts[mask]
  164:         result.index = result.index._with_freq(None)
  165:         tm.assert_series_equal(result, expected)
  166: 
  167:     # ------------------------------------------------------------------
  168:     # Series with CategoricalIndex
  169: 
  170:     def test_getitem_scalar_categorical_index(self):
  171:         cats = Categorical([Timestamp("12-31-1999"), Timestamp("12-31-2000")])
  172: 
  173:         ser = Series([1, 2], index=cats)
  174: 
  175:         expected = ser.iloc[0]
  176:         result = ser[cats[0]]
  177:         assert result == expected
  178: 
  179:     def test_getitem_numeric_categorical_listlike_matches_scalar(self):
  180:         # GH#15470
  181:         ser = Series(["a", "b", "c"], index=pd.CategoricalIndex([2, 1, 0]))
  182: 
  183:         # 0 is treated as a label
  184:         assert ser[0] == "c"
  185: 
  186:         # the listlike analogue should also be treated as labels
  187:         res = ser[[0]]
  188:         expected = ser.iloc[-1:]
  189:         tm.assert_series_equal(res, expected)
  190: 
  191:         res2 = ser[[0, 1, 2]]
  192:         tm.assert_series_equal(res2, ser.iloc[::-1])
  193: 
  194:     def test_getitem_integer_categorical_not_positional(self):
  195:         # GH#14865
  196:         ser = Series(["a", "b", "c"], index=Index([1, 2, 3], dtype="category"))
  197:         assert ser.get(3) == "c"
  198:         assert ser[3] == "c"
  199: 
  200:     def test_getitem_str_with_timedeltaindex(self):
  201:         rng = timedelta_range("1 day 10:11:12", freq="h", periods=500)
  202:         ser = Series(np.arange(len(rng)), index=rng)
  203: 
  204:         key = "6 days, 23:11:12"
  205:         indexer = rng.get_loc(key)
  206:         assert indexer == 133
  207: 
  208:         result = ser[key]
  209:         assert result == ser.iloc[133]
  210: 
  211:         msg = r"^Timedelta\('50 days 00:00:00'\)$"
  212:         with pytest.raises(KeyError, match=msg):
  213:             rng.get_loc("50 days")
  214:         with pytest.raises(KeyError, match=msg):
  215:             ser["50 days"]
  216: 
  217:     def test_getitem_bool_index_positional(self):
  218:         # GH#48653
  219:         ser = Series({True: 1, False: 0})
  220:         msg = "Series.__getitem__ treating keys as positions is deprecated"
  221:         with tm.assert_produces_warning(FutureWarning, match=msg):
  222:             result = ser[0]
  223:         assert result == 1
  224: 
  225: 
  226: class TestSeriesGetitemSlices:
  227:     def test_getitem_partial_str_slice_with_datetimeindex(self):
  228:         # GH#34860
  229:         arr = date_range("1/1/2008", "1/1/2009")
  230:         ser = arr.to_series()
  231:         result = ser["2008"]
  232: 
  233:         rng = date_range(start="2008-01-01", end="2008-12-31")
  234:         expected = Series(rng, index=rng)
  235: 
  236:         tm.assert_series_equal(result, expected)
  237: 
  238:     def test_getitem_slice_strings_with_datetimeindex(self):
  239:         idx = DatetimeIndex(
  240:             ["1/1/2000", "1/2/2000", "1/2/2000", "1/3/2000", "1/4/2000"]
  241:         )
  242: 
  243:         ts = Series(np.random.default_rng(2).standard_normal(len(idx)), index=idx)
  244: 
  245:         result = ts["1/2/2000":]
  246:         expected = ts[1:]
  247:         tm.assert_series_equal(result, expected)
  248: 
  249:         result = ts["1/2/2000":"1/3/2000"]
  250:         expected = ts[1:4]
  251:         tm.assert_series_equal(result, expected)
  252: 
  253:     def test_getitem_partial_str_slice_with_timedeltaindex(self):
  254:         rng = timedelta_range("1 day 10:11:12", freq="h", periods=500)
  255:         ser = Series(np.arange(len(rng)), index=rng)
  256: 
  257:         result = ser["5 day":"6 day"]
  258:         expected = ser.iloc[86:134]
  259:         tm.assert_series_equal(result, expected)
  260: 
  261:         result = ser["5 day":]
  262:         expected = ser.iloc[86:]
  263:         tm.assert_series_equal(result, expected)
  264: 
  265:         result = ser[:"6 day"]
  266:         expected = ser.iloc[:134]
  267:         tm.assert_series_equal(result, expected)
  268: 
  269:     def test_getitem_partial_str_slice_high_reso_with_timedeltaindex(self):
  270:         # higher reso
  271:         rng = timedelta_range("1 day 10:11:12", freq="us", periods=2000)
  272:         ser = Series(np.arange(len(rng)), index=rng)
  273: 
  274:         result = ser["1 day 10:11:12":]
  275:         expected = ser.iloc[0:]
  276:         tm.assert_series_equal(result, expected)
  277: 
  278:         result = ser["1 day 10:11:12.001":]
  279:         expected = ser.iloc[1000:]
  280:         tm.assert_series_equal(result, expected)
  281: 
  282:         result = ser["1 days, 10:11:12.001001"]
  283:         assert result == ser.iloc[1001]
  284: 
  285:     def test_getitem_slice_2d(self, datetime_series):
  286:         # GH#30588 multi-dimensional indexing deprecated
  287:         with pytest.raises(ValueError, match="Multi-dimensional indexing"):
  288:             datetime_series[:, np.newaxis]
  289: 
  290:     def test_getitem_median_slice_bug(self):
  291:         index = date_range("20090415", "20090519", freq="2B")
  292:         ser = Series(np.random.default_rng(2).standard_normal(13), index=index)
  293: 
  294:         indexer = [slice(6, 7, None)]
  295:         msg = "Indexing with a single-item list"
  296:         with pytest.raises(ValueError, match=msg):
  297:             # GH#31299
  298:             ser[indexer]
  299:         # but we're OK with a single-element tuple
  300:         result = ser[(indexer[0],)]
  301:         expected = ser[indexer[0]]
  302:         tm.assert_series_equal(result, expected)
  303: 
  304:     @pytest.mark.parametrize(
  305:         "slc, positions",
  306:         [
  307:             [slice(date(2018, 1, 1), None), [0, 1, 2]],
  308:             [slice(date(2019, 1, 2), None), [2]],
  309:             [slice(date(2020, 1, 1), None), []],
  310:             [slice(None, date(2020, 1, 1)), [0, 1, 2]],
  311:             [slice(None, date(2019, 1, 1)), [0]],
  312:         ],
  313:     )
  314:     def test_getitem_slice_date(self, slc, positions):
  315:         # https://github.com/pandas-dev/pandas/issues/31501
  316:         ser = Series(
  317:             [0, 1, 2],
  318:             DatetimeIndex(["2019-01-01", "2019-01-01T06:00:00", "2019-01-02"]),
  319:         )
  320:         result = ser[slc]
  321:         expected = ser.take(positions)
  322:         tm.assert_series_equal(result, expected)
  323: 
  324:     def test_getitem_slice_float_raises(self, datetime_series):
  325:         msg = (
  326:             "cannot do slice indexing on DatetimeIndex with these indexers "
  327:             r"\[{key}\] of type float"
  328:         )
  329:         with pytest.raises(TypeError, match=msg.format(key=r"4\.0")):
  330:             datetime_series[4.0:10.0]
  331: 
  332:         with pytest.raises(TypeError, match=msg.format(key=r"4\.5")):
  333:             datetime_series[4.5:10.0]
  334: 
  335:     def test_getitem_slice_bug(self):
  336:         ser = Series(range(10), index=list(range(10)))
  337:         result = ser[-12:]
  338:         tm.assert_series_equal(result, ser)
  339: 
  340:         result = ser[-7:]
  341:         tm.assert_series_equal(result, ser[3:])
  342: 
  343:         result = ser[:-12]
  344:         tm.assert_series_equal(result, ser[:0])
  345: 
  346:     def test_getitem_slice_integers(self):
  347:         ser = Series(
  348:             np.random.default_rng(2).standard_normal(8),
  349:             index=[2, 4, 6, 8, 10, 12, 14, 16],
  350:         )
  351: 
  352:         result = ser[:4]
  353:         expected = Series(ser.values[:4], index=[2, 4, 6, 8])
  354:         tm.assert_series_equal(result, expected)
  355: 
  356: 
  357: class TestSeriesGetitemListLike:
  358:     @pytest.mark.parametrize("box", [list, np.array, Index, Series])
  359:     def test_getitem_no_matches(self, box):
  360:         # GH#33462 we expect the same behavior for list/ndarray/Index/Series
  361:         ser = Series(["A", "B"])
  362: 
  363:         key = Series(["C"], dtype=object)
  364:         key = box(key)
  365: 
  366:         msg = (
  367:             r"None of \[Index\(\['C'\], dtype='object|string'\)\] are in the \[index\]"
  368:         )
  369:         with pytest.raises(KeyError, match=msg):
  370:             ser[key]
  371: 
  372:     def test_getitem_intlist_intindex_periodvalues(self):
  373:         ser = Series(period_range("2000-01-01", periods=10, freq="D"))
  374: 
  375:         result = ser[[2, 4]]
  376:         exp = Series(
  377:             [pd.Period("2000-01-03", freq="D"), pd.Period("2000-01-05", freq="D")],
  378:             index=[2, 4],
  379:             dtype="Period[D]",
  380:         )
  381:         tm.assert_series_equal(result, exp)
  382:         assert result.dtype == "Period[D]"
  383: 
  384:     @pytest.mark.parametrize("box", [list, np.array, Index])
  385:     def test_getitem_intlist_intervalindex_non_int(self, box):
  386:         # GH#33404 fall back to positional since ints are unambiguous
  387:         dti = date_range("2000-01-03", periods=3)._with_freq(None)
  388:         ii = pd.IntervalIndex.from_breaks(dti)
  389:         ser = Series(range(len(ii)), index=ii)
  390: 
  391:         expected = ser.iloc[:1]
  392:         key = box([0])
  393:         msg = "Series.__getitem__ treating keys as positions is deprecated"
  394:         with tm.assert_produces_warning(FutureWarning, match=msg):
  395:             result = ser[key]
  396:         tm.assert_series_equal(result, expected)
  397: 
  398:     @pytest.mark.parametrize("box", [list, np.array, Index])
  399:     @pytest.mark.parametrize("dtype", [np.int64, np.float64, np.uint64])
  400:     def test_getitem_intlist_multiindex_numeric_level(self, dtype, box):
  401:         # GH#33404 do _not_ fall back to positional since ints are ambiguous
  402:         idx = Index(range(4)).astype(dtype)
  403:         dti = date_range("2000-01-03", periods=3)
  404:         mi = pd.MultiIndex.from_product([idx, dti])
  405:         ser = Series(range(len(mi))[::-1], index=mi)
  406: 
  407:         key = box([5])
  408:         with pytest.raises(KeyError, match="5"):
  409:             ser[key]
  410: 
  411:     def test_getitem_uint_array_key(self, any_unsigned_int_numpy_dtype):
  412:         # GH #37218
  413:         ser = Series([1, 2, 3])
  414:         key = np.array([4], dtype=any_unsigned_int_numpy_dtype)
  415: 
  416:         with pytest.raises(KeyError, match="4"):
  417:             ser[key]
  418:         with pytest.raises(KeyError, match="4"):
  419:             ser.loc[key]
  420: 
  421: 
  422: class TestGetitemBooleanMask:
  423:     def test_getitem_boolean(self, string_series):
  424:         ser = string_series
  425:         mask = ser > ser.median()
  426: 
  427:         # passing list is OK
  428:         result = ser[list(mask)]
  429:         expected = ser[mask]
  430:         tm.assert_series_equal(result, expected)
  431:         tm.assert_index_equal(result.index, ser.index[mask])
  432: 
  433:     def test_getitem_boolean_empty(self):
  434:         ser = Series([], dtype=np.int64)
  435:         ser.index.name = "index_name"
  436:         ser = ser[ser.isna()]
  437:         assert ser.index.name == "index_name"
  438:         assert ser.dtype == np.int64
  439: 
  440:         # GH#5877
  441:         # indexing with empty series
  442:         ser = Series(["A", "B"], dtype=object)
  443:         expected = Series(dtype=object, index=Index([], dtype="int64"))
  444:         result = ser[Series([], dtype=object)]
  445:         tm.assert_series_equal(result, expected)
  446: 
  447:         # invalid because of the boolean indexer
  448:         # that's empty or not-aligned
  449:         msg = (
  450:             r"Unalignable boolean Series provided as indexer \(index of "
  451:             r"the boolean Series and of the indexed object do not match"
  452:         )
  453:         with pytest.raises(IndexingError, match=msg):
  454:             ser[Series([], dtype=bool)]
  455: 
  456:         with pytest.raises(IndexingError, match=msg):
  457:             ser[Series([True], dtype=bool)]
  458: 
  459:     def test_getitem_boolean_object(self, string_series):
  460:         # using column from DataFrame
  461: 
  462:         ser = string_series
  463:         mask = ser > ser.median()
  464:         omask = mask.astype(object)
  465: 
  466:         # getitem
  467:         result = ser[omask]
  468:         expected = ser[mask]
  469:         tm.assert_series_equal(result, expected)
  470: 
  471:         # setitem
  472:         s2 = ser.copy()
  473:         cop = ser.copy()
  474:         cop[omask] = 5
  475:         s2[mask] = 5
  476:         tm.assert_series_equal(cop, s2)
  477: 
  478:         # nans raise exception
  479:         omask[5:10] = np.nan
  480:         msg = "Cannot mask with non-boolean array containing NA / NaN values"
  481:         with pytest.raises(ValueError, match=msg):
  482:             ser[omask]
  483:         with pytest.raises(ValueError, match=msg):
  484:             ser[omask] = 5
  485: 
  486:     def test_getitem_boolean_dt64_copies(self):
  487:         # GH#36210
  488:         dti = date_range("2016-01-01", periods=4, tz="US/Pacific")
  489:         key = np.array([True, True, False, False])
  490: 
  491:         ser = Series(dti._data)
  492: 
  493:         res = ser[key]
  494:         assert res._values._ndarray.base is None
  495: 
  496:         # compare with numeric case for reference
  497:         ser2 = Series(range(4))
  498:         res2 = ser2[key]
  499:         assert res2._values.base is None
  500: 
  501:     def test_getitem_boolean_corner(self, datetime_series):
  502:         ts = datetime_series
  503:         mask_shifted = ts.shift(1, freq=BDay()) > ts.median()
  504: 
  505:         msg = (
  506:             r"Unalignable boolean Series provided as indexer \(index of "
  507:             r"the boolean Series and of the indexed object do not match"
  508:         )
  509:         with pytest.raises(IndexingError, match=msg):
  510:             ts[mask_shifted]
  511: 
  512:         with pytest.raises(IndexingError, match=msg):
  513:             ts.loc[mask_shifted]
  514: 
  515:     def test_getitem_boolean_different_order(self, string_series):
  516:         ordered = string_series.sort_values()
  517: 
  518:         sel = string_series[ordered > 0]
  519:         exp = string_series[string_series > 0]
  520:         tm.assert_series_equal(sel, exp)
  521: 
  522:     def test_getitem_boolean_contiguous_preserve_freq(self):
  523:         rng = date_range("1/1/2000", "3/1/2000", freq="B")
  524: 
  525:         mask = np.zeros(len(rng), dtype=bool)
  526:         mask[10:20] = True
  527: 
  528:         masked = rng[mask]
  529:         expected = rng[10:20]
  530:         assert expected.freq == rng.freq
  531:         tm.assert_index_equal(masked, expected)
  532: 
  533:         mask[22] = True
  534:         masked = rng[mask]
  535:         assert masked.freq is None
  536: 
  537: 
  538: class TestGetitemCallable:
  539:     def test_getitem_callable(self):
  540:         # GH#12533
  541:         ser = Series(4, index=list("ABCD"))
  542:         result = ser[lambda x: "A"]
  543:         assert result == ser.loc["A"]
  544: 
  545:         result = ser[lambda x: ["A", "B"]]
  546:         expected = ser.loc[["A", "B"]]
  547:         tm.assert_series_equal(result, expected)
  548: 
  549:         result = ser[lambda x: [True, False, True, True]]
  550:         expected = ser.iloc[[0, 2, 3]]
  551:         tm.assert_series_equal(result, expected)
  552: 
  553: 
  554: def test_getitem_generator(string_series):
  555:     gen = (x > 0 for x in string_series)
  556:     result = string_series[gen]
  557:     result2 = string_series[iter(string_series > 0)]
  558:     expected = string_series[string_series > 0]
  559:     tm.assert_series_equal(result, expected)
  560:     tm.assert_series_equal(result2, expected)
  561: 
  562: 
  563: @pytest.mark.parametrize(
  564:     "series",
  565:     [
  566:         Series([0, 1]),
  567:         Series(date_range("2012-01-01", periods=2)),
  568:         Series(date_range("2012-01-01", periods=2, tz="CET")),
  569:     ],
  570: )
  571: def test_getitem_ndim_deprecated(series):
  572:     with pytest.raises(ValueError, match="Multi-dimensional indexing"):
  573:         series[:, None]
  574: 
  575: 
  576: def test_getitem_multilevel_scalar_slice_not_implemented(
  577:     multiindex_year_month_day_dataframe_random_data,
  578: ):
  579:     # not implementing this for now
  580:     df = multiindex_year_month_day_dataframe_random_data
  581:     ser = df["A"]
  582: 
  583:     msg = r"\(2000, slice\(3, 4, None\)\)"
  584:     with pytest.raises(TypeError, match=msg):
  585:         ser[2000, 3:4]
  586: 
  587: 
  588: def test_getitem_dataframe_raises():
  589:     rng = list(range(10))
  590:     ser = Series(10, index=rng)
  591:     df = DataFrame(rng, index=rng)
  592:     msg = (
  593:         "Indexing a Series with DataFrame is not supported, "
  594:         "use the appropriate DataFrame column"
  595:     )
  596:     with pytest.raises(TypeError, match=msg):
  597:         ser[df > 5]
  598: 
  599: 
  600: def test_getitem_assignment_series_alignment():
  601:     # https://github.com/pandas-dev/pandas/issues/37427
  602:     # with getitem, when assigning with a Series, it is not first aligned
  603:     ser = Series(range(10))
  604:     idx = np.array([2, 4, 9])
  605:     ser[idx] = Series([10, 11, 12])
  606:     expected = Series([0, 1, 10, 3, 11, 5, 6, 7, 8, 12])
  607:     tm.assert_series_equal(ser, expected)
  608: 
  609: 
  610: def test_getitem_duplicate_index_mistyped_key_raises_keyerror():
  611:     # GH#29189 float_index.get_loc(None) should raise KeyError, not TypeError
  612:     ser = Series([2, 5, 6, 8], index=[2.0, 4.0, 4.0, 5.0])
  613:     with pytest.raises(KeyError, match="None"):
  614:         ser[None]
  615: 
  616:     with pytest.raises(KeyError, match="None"):
  617:         ser.index.get_loc(None)
  618: 
  619:     with pytest.raises(KeyError, match="None"):
  620:         ser.index._engine.get_loc(None)
  621: 
  622: 
  623: def test_getitem_1tuple_slice_without_multiindex():
  624:     ser = Series(range(5))
  625:     key = (slice(3),)
  626: 
  627:     result = ser[key]
  628:     expected = ser[key[0]]
  629:     tm.assert_series_equal(result, expected)
  630: 
  631: 
  632: def test_getitem_preserve_name(datetime_series):
  633:     result = datetime_series[datetime_series > 0]
  634:     assert result.name == datetime_series.name
  635: 
  636:     msg = "Series.__getitem__ treating keys as positions is deprecated"
  637:     with tm.assert_produces_warning(FutureWarning, match=msg):
  638:         result = datetime_series[[0, 2, 4]]
  639:     assert result.name == datetime_series.name
  640: 
  641:     result = datetime_series[5:10]
  642:     assert result.name == datetime_series.name
  643: 
  644: 
  645: def test_getitem_with_integer_labels():
  646:     # integer indexes, be careful
  647:     ser = Series(
  648:         np.random.default_rng(2).standard_normal(10), index=list(range(0, 20, 2))
  649:     )
  650:     inds = [0, 2, 5, 7, 8]
  651:     arr_inds = np.array([0, 2, 5, 7, 8])
  652:     with pytest.raises(KeyError, match="not in index"):
  653:         ser[inds]
  654: 
  655:     with pytest.raises(KeyError, match="not in index"):
  656:         ser[arr_inds]
  657: 
  658: 
  659: def test_getitem_missing(datetime_series):
  660:     # missing
  661:     d = datetime_series.index[0] - BDay()
  662:     msg = r"Timestamp\('1999-12-31 00:00:00'\)"
  663:     with pytest.raises(KeyError, match=msg):
  664:         datetime_series[d]
  665: 
  666: 
  667: def test_getitem_fancy(string_series, object_series):
  668:     msg = "Series.__getitem__ treating keys as positions is deprecated"
  669:     with tm.assert_produces_warning(FutureWarning, match=msg):
  670:         slice1 = string_series[[1, 2, 3]]
  671:         slice2 = object_series[[1, 2, 3]]
  672:     assert string_series.index[2] == slice1.index[1]
  673:     assert object_series.index[2] == slice2.index[1]
  674:     assert string_series.iloc[2] == slice1.iloc[1]
  675:     assert object_series.iloc[2] == slice2.iloc[1]
  676: 
  677: 
  678: def test_getitem_box_float64(datetime_series):
  679:     msg = "Series.__getitem__ treating keys as positions is deprecated"
  680:     with tm.assert_produces_warning(FutureWarning, match=msg):
  681:         value = datetime_series[5]
  682:     assert isinstance(value, np.float64)
  683: 
  684: 
  685: def test_getitem_unordered_dup():
  686:     obj = Series(range(5), index=["c", "a", "a", "b", "b"])
  687:     assert is_scalar(obj["c"])
  688:     assert obj["c"] == 0
  689: 
  690: 
  691: def test_getitem_dups():
  692:     ser = Series(range(5), index=["A", "A", "B", "C", "C"], dtype=np.int64)
  693:     expected = Series([3, 4], index=["C", "C"], dtype=np.int64)
  694:     result = ser["C"]
  695:     tm.assert_series_equal(result, expected)
  696: 
  697: 
  698: def test_getitem_categorical_str():
  699:     # GH#31765
  700:     ser = Series(range(5), index=Categorical(["a", "b", "c", "a", "b"]))
  701:     result = ser["a"]
  702:     expected = ser.iloc[[0, 3]]
  703:     tm.assert_series_equal(result, expected)
  704: 
  705: 
  706: def test_slice_can_reorder_not_uniquely_indexed():
  707:     ser = Series(1, index=["a", "a", "b", "b", "c"])
  708:     ser[::-1]  # it works!
  709: 
  710: 
  711: @pytest.mark.parametrize("index_vals", ["aabcd", "aadcb"])
  712: def test_duplicated_index_getitem_positional_indexer(index_vals):
  713:     # GH 11747
  714:     s = Series(range(5), index=list(index_vals))
  715: 
  716:     msg = "Series.__getitem__ treating keys as positions is deprecated"
  717:     with tm.assert_produces_warning(FutureWarning, match=msg):
  718:         result = s[3]
  719:     assert result == 3
  720: 
  721: 
  722: class TestGetitemDeprecatedIndexers:
  723:     @pytest.mark.parametrize("key", [{1}, {1: 1}])
  724:     def test_getitem_dict_and_set_deprecated(self, key):
  725:         # GH#42825 enforced in 2.0
  726:         ser = Series([1, 2, 3])
  727:         with pytest.raises(TypeError, match="as an indexer is not supported"):
  728:             ser[key]
  729: 
  730:     @pytest.mark.parametrize("key", [{1}, {1: 1}])
  731:     def test_setitem_dict_and_set_disallowed(self, key):
  732:         # GH#42825 enforced in 2.0
  733:         ser = Series([1, 2, 3])
  734:         with pytest.raises(TypeError, match="as an indexer is not supported"):
  735:             ser[key] = 1
