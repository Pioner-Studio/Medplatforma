    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas import (
    5:     DatetimeIndex,
    6:     IntervalIndex,
    7:     MultiIndex,
    8:     Series,
    9: )
   10: import pandas._testing as tm
   11: 
   12: 
   13: @pytest.fixture(params=["quicksort", "mergesort", "heapsort", "stable"])
   14: def sort_kind(request):
   15:     return request.param
   16: 
   17: 
   18: class TestSeriesSortIndex:
   19:     def test_sort_index_name(self, datetime_series):
   20:         result = datetime_series.sort_index(ascending=False)
   21:         assert result.name == datetime_series.name
   22: 
   23:     def test_sort_index(self, datetime_series):
   24:         datetime_series.index = datetime_series.index._with_freq(None)
   25: 
   26:         rindex = list(datetime_series.index)
   27:         np.random.default_rng(2).shuffle(rindex)
   28: 
   29:         random_order = datetime_series.reindex(rindex)
   30:         sorted_series = random_order.sort_index()
   31:         tm.assert_series_equal(sorted_series, datetime_series)
   32: 
   33:         # descending
   34:         sorted_series = random_order.sort_index(ascending=False)
   35:         tm.assert_series_equal(
   36:             sorted_series, datetime_series.reindex(datetime_series.index[::-1])
   37:         )
   38: 
   39:         # compat on level
   40:         sorted_series = random_order.sort_index(level=0)
   41:         tm.assert_series_equal(sorted_series, datetime_series)
   42: 
   43:         # compat on axis
   44:         sorted_series = random_order.sort_index(axis=0)
   45:         tm.assert_series_equal(sorted_series, datetime_series)
   46: 
   47:         msg = "No axis named 1 for object type Series"
   48:         with pytest.raises(ValueError, match=msg):
   49:             random_order.sort_values(axis=1)
   50: 
   51:         sorted_series = random_order.sort_index(level=0, axis=0)
   52:         tm.assert_series_equal(sorted_series, datetime_series)
   53: 
   54:         with pytest.raises(ValueError, match=msg):
   55:             random_order.sort_index(level=0, axis=1)
   56: 
   57:     def test_sort_index_inplace(self, datetime_series):
   58:         datetime_series.index = datetime_series.index._with_freq(None)
   59: 
   60:         # For GH#11402
   61:         rindex = list(datetime_series.index)
   62:         np.random.default_rng(2).shuffle(rindex)
   63: 
   64:         # descending
   65:         random_order = datetime_series.reindex(rindex)
   66:         result = random_order.sort_index(ascending=False, inplace=True)
   67: 
   68:         assert result is None
   69:         expected = datetime_series.reindex(datetime_series.index[::-1])
   70:         expected.index = expected.index._with_freq(None)
   71:         tm.assert_series_equal(random_order, expected)
   72: 
   73:         # ascending
   74:         random_order = datetime_series.reindex(rindex)
   75:         result = random_order.sort_index(ascending=True, inplace=True)
   76: 
   77:         assert result is None
   78:         expected = datetime_series.copy()
   79:         expected.index = expected.index._with_freq(None)
   80:         tm.assert_series_equal(random_order, expected)
   81: 
   82:     def test_sort_index_level(self):
   83:         mi = MultiIndex.from_tuples([[1, 1, 3], [1, 1, 1]], names=list("ABC"))
   84:         s = Series([1, 2], mi)
   85:         backwards = s.iloc[[1, 0]]
   86: 
   87:         res = s.sort_index(level="A")
   88:         tm.assert_series_equal(backwards, res)
   89: 
   90:         res = s.sort_index(level=["A", "B"])
   91:         tm.assert_series_equal(backwards, res)
   92: 
   93:         res = s.sort_index(level="A", sort_remaining=False)
   94:         tm.assert_series_equal(s, res)
   95: 
   96:         res = s.sort_index(level=["A", "B"], sort_remaining=False)
   97:         tm.assert_series_equal(s, res)
   98: 
   99:     @pytest.mark.parametrize("level", ["A", 0])  # GH#21052
  100:     def test_sort_index_multiindex(self, level):
  101:         mi = MultiIndex.from_tuples([[1, 1, 3], [1, 1, 1]], names=list("ABC"))
  102:         s = Series([1, 2], mi)
  103:         backwards = s.iloc[[1, 0]]
  104: 
  105:         # implicit sort_remaining=True
  106:         res = s.sort_index(level=level)
  107:         tm.assert_series_equal(backwards, res)
  108: 
  109:         # GH#13496
  110:         # sort has no effect without remaining lvls
  111:         res = s.sort_index(level=level, sort_remaining=False)
  112:         tm.assert_series_equal(s, res)
  113: 
  114:     def test_sort_index_kind(self, sort_kind):
  115:         # GH#14444 & GH#13589:  Add support for sort algo choosing
  116:         series = Series(index=[3, 2, 1, 4, 3], dtype=object)
  117:         expected_series = Series(index=[1, 2, 3, 3, 4], dtype=object)
  118: 
  119:         index_sorted_series = series.sort_index(kind=sort_kind)
  120:         tm.assert_series_equal(expected_series, index_sorted_series)
  121: 
  122:     def test_sort_index_na_position(self):
  123:         series = Series(index=[3, 2, 1, 4, 3, np.nan], dtype=object)
  124:         expected_series_first = Series(index=[np.nan, 1, 2, 3, 3, 4], dtype=object)
  125: 
  126:         index_sorted_series = series.sort_index(na_position="first")
  127:         tm.assert_series_equal(expected_series_first, index_sorted_series)
  128: 
  129:         expected_series_last = Series(index=[1, 2, 3, 3, 4, np.nan], dtype=object)
  130: 
  131:         index_sorted_series = series.sort_index(na_position="last")
  132:         tm.assert_series_equal(expected_series_last, index_sorted_series)
  133: 
  134:     def test_sort_index_intervals(self):
  135:         s = Series(
  136:             [np.nan, 1, 2, 3], IntervalIndex.from_arrays([0, 1, 2, 3], [1, 2, 3, 4])
  137:         )
  138: 
  139:         result = s.sort_index()
  140:         expected = s
  141:         tm.assert_series_equal(result, expected)
  142: 
  143:         result = s.sort_index(ascending=False)
  144:         expected = Series(
  145:             [3, 2, 1, np.nan], IntervalIndex.from_arrays([3, 2, 1, 0], [4, 3, 2, 1])
  146:         )
  147:         tm.assert_series_equal(result, expected)
  148: 
  149:     @pytest.mark.parametrize("inplace", [True, False])
  150:     @pytest.mark.parametrize(
  151:         "original_list, sorted_list, ascending, ignore_index, output_index",
  152:         [
  153:             ([2, 3, 6, 1], [2, 3, 6, 1], True, True, [0, 1, 2, 3]),
  154:             ([2, 3, 6, 1], [2, 3, 6, 1], True, False, [0, 1, 2, 3]),
  155:             ([2, 3, 6, 1], [1, 6, 3, 2], False, True, [0, 1, 2, 3]),
  156:             ([2, 3, 6, 1], [1, 6, 3, 2], False, False, [3, 2, 1, 0]),
  157:         ],
  158:     )
  159:     def test_sort_index_ignore_index(
  160:         self, inplace, original_list, sorted_list, ascending, ignore_index, output_index
  161:     ):
  162:         # GH 30114
  163:         ser = Series(original_list)
  164:         expected = Series(sorted_list, index=output_index)
  165:         kwargs = {
  166:             "ascending": ascending,
  167:             "ignore_index": ignore_index,
  168:             "inplace": inplace,
  169:         }
  170: 
  171:         if inplace:
  172:             result_ser = ser.copy()
  173:             result_ser.sort_index(**kwargs)
  174:         else:
  175:             result_ser = ser.sort_index(**kwargs)
  176: 
  177:         tm.assert_series_equal(result_ser, expected)
  178:         tm.assert_series_equal(ser, Series(original_list))
  179: 
  180:     def test_sort_index_ascending_list(self):
  181:         # GH#16934
  182: 
  183:         # Set up a Series with a three level MultiIndex
  184:         arrays = [
  185:             ["bar", "bar", "baz", "baz", "foo", "foo", "qux", "qux"],
  186:             ["one", "two", "one", "two", "one", "two", "one", "two"],
  187:             [4, 3, 2, 1, 4, 3, 2, 1],
  188:         ]
  189:         tuples = zip(*arrays)
  190:         mi = MultiIndex.from_tuples(tuples, names=["first", "second", "third"])
  191:         ser = Series(range(8), index=mi)
  192: 
  193:         # Sort with boolean ascending
  194:         result = ser.sort_index(level=["third", "first"], ascending=False)
  195:         expected = ser.iloc[[4, 0, 5, 1, 6, 2, 7, 3]]
  196:         tm.assert_series_equal(result, expected)
  197: 
  198:         # Sort with list of boolean ascending
  199:         result = ser.sort_index(level=["third", "first"], ascending=[False, True])
  200:         expected = ser.iloc[[0, 4, 1, 5, 2, 6, 3, 7]]
  201:         tm.assert_series_equal(result, expected)
  202: 
  203:     @pytest.mark.parametrize(
  204:         "ascending",
  205:         [
  206:             None,
  207:             (True, None),
  208:             (False, "True"),
  209:         ],
  210:     )
  211:     def test_sort_index_ascending_bad_value_raises(self, ascending):
  212:         ser = Series(range(10), index=[0, 3, 2, 1, 4, 5, 7, 6, 8, 9])
  213:         match = 'For argument "ascending" expected type bool'
  214:         with pytest.raises(ValueError, match=match):
  215:             ser.sort_index(ascending=ascending)
  216: 
  217: 
  218: class TestSeriesSortIndexKey:
  219:     def test_sort_index_multiindex_key(self):
  220:         mi = MultiIndex.from_tuples([[1, 1, 3], [1, 1, 1]], names=list("ABC"))
  221:         s = Series([1, 2], mi)
  222:         backwards = s.iloc[[1, 0]]
  223: 
  224:         result = s.sort_index(level="C", key=lambda x: -x)
  225:         tm.assert_series_equal(s, result)
  226: 
  227:         result = s.sort_index(level="C", key=lambda x: x)  # nothing happens
  228:         tm.assert_series_equal(backwards, result)
  229: 
  230:     def test_sort_index_multiindex_key_multi_level(self):
  231:         mi = MultiIndex.from_tuples([[1, 1, 3], [1, 1, 1]], names=list("ABC"))
  232:         s = Series([1, 2], mi)
  233:         backwards = s.iloc[[1, 0]]
  234: 
  235:         result = s.sort_index(level=["A", "C"], key=lambda x: -x)
  236:         tm.assert_series_equal(s, result)
  237: 
  238:         result = s.sort_index(level=["A", "C"], key=lambda x: x)  # nothing happens
  239:         tm.assert_series_equal(backwards, result)
  240: 
  241:     def test_sort_index_key(self):
  242:         series = Series(np.arange(6, dtype="int64"), index=list("aaBBca"))
  243: 
  244:         result = series.sort_index()
  245:         expected = series.iloc[[2, 3, 0, 1, 5, 4]]
  246:         tm.assert_series_equal(result, expected)
  247: 
  248:         result = series.sort_index(key=lambda x: x.str.lower())
  249:         expected = series.iloc[[0, 1, 5, 2, 3, 4]]
  250:         tm.assert_series_equal(result, expected)
  251: 
  252:         result = series.sort_index(key=lambda x: x.str.lower(), ascending=False)
  253:         expected = series.iloc[[4, 2, 3, 0, 1, 5]]
  254:         tm.assert_series_equal(result, expected)
  255: 
  256:     def test_sort_index_key_int(self):
  257:         series = Series(np.arange(6, dtype="int64"), index=np.arange(6, dtype="int64"))
  258: 
  259:         result = series.sort_index()
  260:         tm.assert_series_equal(result, series)
  261: 
  262:         result = series.sort_index(key=lambda x: -x)
  263:         expected = series.sort_index(ascending=False)
  264:         tm.assert_series_equal(result, expected)
  265: 
  266:         result = series.sort_index(key=lambda x: 2 * x)
  267:         tm.assert_series_equal(result, series)
  268: 
  269:     def test_sort_index_kind_key(self, sort_kind, sort_by_key):
  270:         # GH #14444 & #13589:  Add support for sort algo choosing
  271:         series = Series(index=[3, 2, 1, 4, 3], dtype=object)
  272:         expected_series = Series(index=[1, 2, 3, 3, 4], dtype=object)
  273: 
  274:         index_sorted_series = series.sort_index(kind=sort_kind, key=sort_by_key)
  275:         tm.assert_series_equal(expected_series, index_sorted_series)
  276: 
  277:     def test_sort_index_kind_neg_key(self, sort_kind):
  278:         # GH #14444 & #13589:  Add support for sort algo choosing
  279:         series = Series(index=[3, 2, 1, 4, 3], dtype=object)
  280:         expected_series = Series(index=[4, 3, 3, 2, 1], dtype=object)
  281: 
  282:         index_sorted_series = series.sort_index(kind=sort_kind, key=lambda x: -x)
  283:         tm.assert_series_equal(expected_series, index_sorted_series)
  284: 
  285:     def test_sort_index_na_position_key(self, sort_by_key):
  286:         series = Series(index=[3, 2, 1, 4, 3, np.nan], dtype=object)
  287:         expected_series_first = Series(index=[np.nan, 1, 2, 3, 3, 4], dtype=object)
  288: 
  289:         index_sorted_series = series.sort_index(na_position="first", key=sort_by_key)
  290:         tm.assert_series_equal(expected_series_first, index_sorted_series)
  291: 
  292:         expected_series_last = Series(index=[1, 2, 3, 3, 4, np.nan], dtype=object)
  293: 
  294:         index_sorted_series = series.sort_index(na_position="last", key=sort_by_key)
  295:         tm.assert_series_equal(expected_series_last, index_sorted_series)
  296: 
  297:     def test_changes_length_raises(self):
  298:         s = Series([1, 2, 3])
  299:         with pytest.raises(ValueError, match="change the shape"):
  300:             s.sort_index(key=lambda x: x[:1])
  301: 
  302:     def test_sort_values_key_type(self):
  303:         s = Series([1, 2, 3], DatetimeIndex(["2008-10-24", "2008-11-23", "2007-12-22"]))
  304: 
  305:         result = s.sort_index(key=lambda x: x.month)
  306:         expected = s.iloc[[0, 1, 2]]
  307:         tm.assert_series_equal(result, expected)
  308: 
  309:         result = s.sort_index(key=lambda x: x.day)
  310:         expected = s.iloc[[2, 1, 0]]
  311:         tm.assert_series_equal(result, expected)
  312: 
  313:         result = s.sort_index(key=lambda x: x.year)
  314:         expected = s.iloc[[2, 0, 1]]
  315:         tm.assert_series_equal(result, expected)
  316: 
  317:         result = s.sort_index(key=lambda x: x.month_name())
  318:         expected = s.iloc[[2, 1, 0]]
  319:         tm.assert_series_equal(result, expected)
  320: 
  321:     @pytest.mark.parametrize(
  322:         "ascending",
  323:         [
  324:             [True, False],
  325:             [False, True],
  326:         ],
  327:     )
  328:     def test_sort_index_multi_already_monotonic(self, ascending):
  329:         # GH 56049
  330:         mi = MultiIndex.from_product([[1, 2], [3, 4]])
  331:         ser = Series(range(len(mi)), index=mi)
  332:         result = ser.sort_index(ascending=ascending)
  333:         if ascending == [True, False]:
  334:             expected = ser.take([1, 0, 3, 2])
  335:         elif ascending == [False, True]:
  336:             expected = ser.take([2, 3, 0, 1])
  337:         tm.assert_series_equal(result, expected)
