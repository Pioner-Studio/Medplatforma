    1: from datetime import datetime
    2: 
    3: import numpy as np
    4: 
    5: import pandas as pd
    6: from pandas import (
    7:     Period,
    8:     Series,
    9:     date_range,
   10:     period_range,
   11:     to_datetime,
   12: )
   13: import pandas._testing as tm
   14: 
   15: 
   16: class TestCombineFirst:
   17:     def test_combine_first_period_datetime(self):
   18:         # GH#3367
   19:         didx = date_range(start="1950-01-31", end="1950-07-31", freq="ME")
   20:         pidx = period_range(start=Period("1950-1"), end=Period("1950-7"), freq="M")
   21:         # check to be consistent with DatetimeIndex
   22:         for idx in [didx, pidx]:
   23:             a = Series([1, np.nan, np.nan, 4, 5, np.nan, 7], index=idx)
   24:             b = Series([9, 9, 9, 9, 9, 9, 9], index=idx)
   25: 
   26:             result = a.combine_first(b)
   27:             expected = Series([1, 9, 9, 4, 5, 9, 7], index=idx, dtype=np.float64)
   28:             tm.assert_series_equal(result, expected)
   29: 
   30:     def test_combine_first_name(self, datetime_series):
   31:         result = datetime_series.combine_first(datetime_series[:5])
   32:         assert result.name == datetime_series.name
   33: 
   34:     def test_combine_first(self):
   35:         values = np.arange(20, dtype=np.float64)
   36:         series = Series(values, index=np.arange(20, dtype=np.int64))
   37: 
   38:         series_copy = series * 2
   39:         series_copy[::2] = np.nan
   40: 
   41:         # nothing used from the input
   42:         combined = series.combine_first(series_copy)
   43: 
   44:         tm.assert_series_equal(combined, series)
   45: 
   46:         # Holes filled from input
   47:         combined = series_copy.combine_first(series)
   48:         assert np.isfinite(combined).all()
   49: 
   50:         tm.assert_series_equal(combined[::2], series[::2])
   51:         tm.assert_series_equal(combined[1::2], series_copy[1::2])
   52: 
   53:         # mixed types
   54:         index = pd.Index([str(i) for i in range(20)])
   55:         floats = Series(np.random.default_rng(2).standard_normal(20), index=index)
   56:         strings = Series([str(i) for i in range(10)], index=index[::2], dtype=object)
   57: 
   58:         combined = strings.combine_first(floats)
   59: 
   60:         tm.assert_series_equal(strings, combined.loc[index[::2]])
   61:         tm.assert_series_equal(floats[1::2].astype(object), combined.loc[index[1::2]])
   62: 
   63:         # corner case
   64:         ser = Series([1.0, 2, 3], index=[0, 1, 2])
   65:         empty = Series([], index=[], dtype=object)
   66:         msg = "The behavior of array concatenation with empty entries is deprecated"
   67:         with tm.assert_produces_warning(FutureWarning, match=msg):
   68:             result = ser.combine_first(empty)
   69:         ser.index = ser.index.astype("O")
   70:         tm.assert_series_equal(ser, result)
   71: 
   72:     def test_combine_first_dt64(self, unit):
   73:         s0 = to_datetime(Series(["2010", np.nan])).dt.as_unit(unit)
   74:         s1 = to_datetime(Series([np.nan, "2011"])).dt.as_unit(unit)
   75:         rs = s0.combine_first(s1)
   76:         xp = to_datetime(Series(["2010", "2011"])).dt.as_unit(unit)
   77:         tm.assert_series_equal(rs, xp)
   78: 
   79:         s0 = to_datetime(Series(["2010", np.nan])).dt.as_unit(unit)
   80:         s1 = Series([np.nan, "2011"])
   81:         rs = s0.combine_first(s1)
   82: 
   83:         xp = Series([datetime(2010, 1, 1), "2011"], dtype="datetime64[ns]")
   84: 
   85:         tm.assert_series_equal(rs, xp)
   86: 
   87:     def test_combine_first_dt_tz_values(self, tz_naive_fixture):
   88:         ser1 = Series(
   89:             pd.DatetimeIndex(["20150101", "20150102", "20150103"], tz=tz_naive_fixture),
   90:             name="ser1",
   91:         )
   92:         ser2 = Series(
   93:             pd.DatetimeIndex(["20160514", "20160515", "20160516"], tz=tz_naive_fixture),
   94:             index=[2, 3, 4],
   95:             name="ser2",
   96:         )
   97:         result = ser1.combine_first(ser2)
   98:         exp_vals = pd.DatetimeIndex(
   99:             ["20150101", "20150102", "20150103", "20160515", "20160516"],
  100:             tz=tz_naive_fixture,
  101:         )
  102:         exp = Series(exp_vals, name="ser1")
  103:         tm.assert_series_equal(exp, result)
  104: 
  105:     def test_combine_first_timezone_series_with_empty_series(self):
  106:         # GH 41800
  107:         time_index = date_range(
  108:             datetime(2021, 1, 1, 1),
  109:             datetime(2021, 1, 1, 10),
  110:             freq="h",
  111:             tz="Europe/Rome",
  112:         )
  113:         s1 = Series(range(10), index=time_index)
  114:         s2 = Series(index=time_index)
  115:         msg = "The behavior of array concatenation with empty entries is deprecated"
  116:         with tm.assert_produces_warning(FutureWarning, match=msg):
  117:             result = s1.combine_first(s2)
  118:         tm.assert_series_equal(result, s1)
  119: 
  120:     def test_combine_first_preserves_dtype(self):
  121:         # GH51764
  122:         s1 = Series([1666880195890293744, 1666880195890293837])
  123:         s2 = Series([1, 2, 3])
  124:         result = s1.combine_first(s2)
  125:         expected = Series([1666880195890293744, 1666880195890293837, 3])
  126:         tm.assert_series_equal(result, expected)
  127: 
  128:     def test_combine_mixed_timezone(self):
  129:         # GH 26283
  130:         uniform_tz = Series({pd.Timestamp("2019-05-01", tz="UTC"): 1.0})
  131:         multi_tz = Series(
  132:             {
  133:                 pd.Timestamp("2019-05-01 01:00:00+0100", tz="Europe/London"): 2.0,
  134:                 pd.Timestamp("2019-05-02", tz="UTC"): 3.0,
  135:             }
  136:         )
  137: 
  138:         result = uniform_tz.combine_first(multi_tz)
  139:         expected = Series(
  140:             [1.0, 3.0],
  141:             index=pd.Index(
  142:                 [
  143:                     pd.Timestamp("2019-05-01 00:00:00+00:00", tz="UTC"),
  144:                     pd.Timestamp("2019-05-02 00:00:00+00:00", tz="UTC"),
  145:                 ],
  146:                 dtype="object",
  147:             ),
  148:         )
  149:         tm.assert_series_equal(result, expected)
