    1: from datetime import timedelta
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: from pandas._libs import iNaT
    7: 
    8: import pandas as pd
    9: from pandas import (
   10:     Categorical,
   11:     Index,
   12:     NaT,
   13:     Series,
   14:     isna,
   15: )
   16: import pandas._testing as tm
   17: 
   18: 
   19: class TestSeriesMissingData:
   20:     def test_categorical_nan_handling(self):
   21:         # NaNs are represented as -1 in labels
   22:         s = Series(Categorical(["a", "b", np.nan, "a"]))
   23:         tm.assert_index_equal(s.cat.categories, Index(["a", "b"]))
   24:         tm.assert_numpy_array_equal(
   25:             s.values.codes, np.array([0, 1, -1, 0], dtype=np.int8)
   26:         )
   27: 
   28:     def test_isna_for_inf(self):
   29:         s = Series(["a", np.inf, np.nan, pd.NA, 1.0])
   30:         msg = "use_inf_as_na option is deprecated"
   31:         with tm.assert_produces_warning(FutureWarning, match=msg):
   32:             with pd.option_context("mode.use_inf_as_na", True):
   33:                 r = s.isna()
   34:                 dr = s.dropna()
   35:         e = Series([False, True, True, True, False])
   36:         de = Series(["a", 1.0], index=[0, 4])
   37:         tm.assert_series_equal(r, e)
   38:         tm.assert_series_equal(dr, de)
   39: 
   40:     def test_timedelta64_nan(self):
   41:         td = Series([timedelta(days=i) for i in range(10)])
   42: 
   43:         # nan ops on timedeltas
   44:         td1 = td.copy()
   45:         td1[0] = np.nan
   46:         assert isna(td1[0])
   47:         assert td1[0]._value == iNaT
   48:         td1[0] = td[0]
   49:         assert not isna(td1[0])
   50: 
   51:         # GH#16674 iNaT is treated as an integer when given by the user
   52:         with tm.assert_produces_warning(FutureWarning, match="incompatible dtype"):
   53:             td1[1] = iNaT
   54:         assert not isna(td1[1])
   55:         assert td1.dtype == np.object_
   56:         assert td1[1] == iNaT
   57:         td1[1] = td[1]
   58:         assert not isna(td1[1])
   59: 
   60:         td1[2] = NaT
   61:         assert isna(td1[2])
   62:         assert td1[2]._value == iNaT
   63:         td1[2] = td[2]
   64:         assert not isna(td1[2])
   65: 
   66:         # boolean setting
   67:         # GH#2899 boolean setting
   68:         td3 = np.timedelta64(timedelta(days=3))
   69:         td7 = np.timedelta64(timedelta(days=7))
   70:         td[(td > td3) & (td < td7)] = np.nan
   71:         assert isna(td).sum() == 3
   72: 
   73:     @pytest.mark.xfail(
   74:         reason="Chained inequality raises when trying to define 'selector'"
   75:     )
   76:     def test_logical_range_select(self, datetime_series):
   77:         # NumPy limitation =(
   78:         # https://github.com/pandas-dev/pandas/commit/9030dc021f07c76809848925cb34828f6c8484f3
   79: 
   80:         selector = -0.5 <= datetime_series <= 0.5
   81:         expected = (datetime_series >= -0.5) & (datetime_series <= 0.5)
   82:         tm.assert_series_equal(selector, expected)
   83: 
   84:     def test_valid(self, datetime_series):
   85:         ts = datetime_series.copy()
   86:         ts.index = ts.index._with_freq(None)
   87:         ts[::2] = np.nan
   88: 
   89:         result = ts.dropna()
   90:         assert len(result) == ts.count()
   91:         tm.assert_series_equal(result, ts[1::2])
   92:         tm.assert_series_equal(result, ts[pd.notna(ts)])
   93: 
   94: 
   95: def test_hasnans_uncached_for_series():
   96:     # GH#19700
   97:     # set float64 dtype to avoid upcast when setting nan
   98:     idx = Index([0, 1], dtype="float64")
   99:     assert idx.hasnans is False
  100:     assert "hasnans" in idx._cache
  101:     ser = idx.to_series()
  102:     assert ser.hasnans is False
  103:     assert not hasattr(ser, "_cache")
  104:     ser.iloc[-1] = np.nan
  105:     assert ser.hasnans is True
