    1: import re
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: from pandas._config import using_pyarrow_string_dtype
    7: 
    8: import pandas as pd
    9: import pandas._testing as tm
   10: from pandas.core.arrays import IntervalArray
   11: 
   12: 
   13: class TestSeriesReplace:
   14:     def test_replace_explicit_none(self):
   15:         # GH#36984 if the user explicitly passes value=None, give it to them
   16:         ser = pd.Series([0, 0, ""], dtype=object)
   17:         result = ser.replace("", None)
   18:         expected = pd.Series([0, 0, None], dtype=object)
   19:         tm.assert_series_equal(result, expected)
   20: 
   21:         # Cast column 2 to object to avoid implicit cast when setting entry to ""
   22:         df = pd.DataFrame(np.zeros((3, 3))).astype({2: object})
   23:         df.iloc[2, 2] = ""
   24:         result = df.replace("", None)
   25:         expected = pd.DataFrame(
   26:             {
   27:                 0: np.zeros(3),
   28:                 1: np.zeros(3),
   29:                 2: np.array([0.0, 0.0, None], dtype=object),
   30:             }
   31:         )
   32:         assert expected.iloc[2, 2] is None
   33:         tm.assert_frame_equal(result, expected)
   34: 
   35:         # GH#19998 same thing with object dtype
   36:         ser = pd.Series([10, 20, 30, "a", "a", "b", "a"])
   37:         result = ser.replace("a", None)
   38:         expected = pd.Series([10, 20, 30, None, None, "b", None])
   39:         assert expected.iloc[-1] is None
   40:         tm.assert_series_equal(result, expected)
   41: 
   42:     def test_replace_noop_doesnt_downcast(self):
   43:         # GH#44498
   44:         ser = pd.Series([None, None, pd.Timestamp("2021-12-16 17:31")], dtype=object)
   45:         res = ser.replace({np.nan: None})  # should be a no-op
   46:         tm.assert_series_equal(res, ser)
   47:         assert res.dtype == object
   48: 
   49:         # same thing but different calling convention
   50:         res = ser.replace(np.nan, None)
   51:         tm.assert_series_equal(res, ser)
   52:         assert res.dtype == object
   53: 
   54:     def test_replace(self):
   55:         N = 50
   56:         ser = pd.Series(np.random.default_rng(2).standard_normal(N))
   57:         ser[0:4] = np.nan
   58:         ser[6:10] = 0
   59: 
   60:         # replace list with a single value
   61:         return_value = ser.replace([np.nan], -1, inplace=True)
   62:         assert return_value is None
   63: 
   64:         exp = ser.fillna(-1)
   65:         tm.assert_series_equal(ser, exp)
   66: 
   67:         rs = ser.replace(0.0, np.nan)
   68:         ser[ser == 0.0] = np.nan
   69:         tm.assert_series_equal(rs, ser)
   70: 
   71:         ser = pd.Series(
   72:             np.fabs(np.random.default_rng(2).standard_normal(N)),
   73:             pd.date_range("2020-01-01", periods=N),
   74:             dtype=object,
   75:         )
   76:         ser[:5] = np.nan
   77:         ser[6:10] = "foo"
   78:         ser[20:30] = "bar"
   79: 
   80:         # replace list with a single value
   81:         msg = "Downcasting behavior in `replace`"
   82:         with tm.assert_produces_warning(FutureWarning, match=msg):
   83:             rs = ser.replace([np.nan, "foo", "bar"], -1)
   84: 
   85:         assert (rs[:5] == -1).all()
   86:         assert (rs[6:10] == -1).all()
   87:         assert (rs[20:30] == -1).all()
   88:         assert (pd.isna(ser[:5])).all()
   89: 
   90:         # replace with different values
   91:         with tm.assert_produces_warning(FutureWarning, match=msg):
   92:             rs = ser.replace({np.nan: -1, "foo": -2, "bar": -3})
   93: 
   94:         assert (rs[:5] == -1).all()
   95:         assert (rs[6:10] == -2).all()
   96:         assert (rs[20:30] == -3).all()
   97:         assert (pd.isna(ser[:5])).all()
   98: 
   99:         # replace with different values with 2 lists
  100:         with tm.assert_produces_warning(FutureWarning, match=msg):
  101:             rs2 = ser.replace([np.nan, "foo", "bar"], [-1, -2, -3])
  102:         tm.assert_series_equal(rs, rs2)
  103: 
  104:         # replace inplace
  105:         with tm.assert_produces_warning(FutureWarning, match=msg):
  106:             return_value = ser.replace([np.nan, "foo", "bar"], -1, inplace=True)
  107:         assert return_value is None
  108: 
  109:         assert (ser[:5] == -1).all()
  110:         assert (ser[6:10] == -1).all()
  111:         assert (ser[20:30] == -1).all()
  112: 
  113:     def test_replace_nan_with_inf(self):
  114:         ser = pd.Series([np.nan, 0, np.inf])
  115:         tm.assert_series_equal(ser.replace(np.nan, 0), ser.fillna(0))
  116: 
  117:         ser = pd.Series([np.nan, 0, "foo", "bar", np.inf, None, pd.NaT])
  118:         tm.assert_series_equal(ser.replace(np.nan, 0), ser.fillna(0))
  119:         filled = ser.copy()
  120:         filled[4] = 0
  121:         tm.assert_series_equal(ser.replace(np.inf, 0), filled)
  122: 
  123:     def test_replace_listlike_value_listlike_target(self, datetime_series):
  124:         ser = pd.Series(datetime_series.index)
  125:         tm.assert_series_equal(ser.replace(np.nan, 0), ser.fillna(0))
  126: 
  127:         # malformed
  128:         msg = r"Replacement lists must match in length\. Expecting 3 got 2"
  129:         with pytest.raises(ValueError, match=msg):
  130:             ser.replace([1, 2, 3], [np.nan, 0])
  131: 
  132:         # ser is dt64 so can't hold 1 or 2, so this replace is a no-op
  133:         result = ser.replace([1, 2], [np.nan, 0])
  134:         tm.assert_series_equal(result, ser)
  135: 
  136:         ser = pd.Series([0, 1, 2, 3, 4])
  137:         result = ser.replace([0, 1, 2, 3, 4], [4, 3, 2, 1, 0])
  138:         tm.assert_series_equal(result, pd.Series([4, 3, 2, 1, 0]))
  139: 
  140:     def test_replace_gh5319(self):
  141:         # API change from 0.12?
  142:         # GH 5319
  143:         ser = pd.Series([0, np.nan, 2, 3, 4])
  144:         expected = ser.ffill()
  145:         msg = (
  146:             "Series.replace without 'value' and with non-dict-like "
  147:             "'to_replace' is deprecated"
  148:         )
  149:         with tm.assert_produces_warning(FutureWarning, match=msg):
  150:             result = ser.replace([np.nan])
  151:         tm.assert_series_equal(result, expected)
  152: 
  153:         ser = pd.Series([0, np.nan, 2, 3, 4])
  154:         expected = ser.ffill()
  155:         with tm.assert_produces_warning(FutureWarning, match=msg):
  156:             result = ser.replace(np.nan)
  157:         tm.assert_series_equal(result, expected)
  158: 
  159:     def test_replace_datetime64(self):
  160:         # GH 5797
  161:         ser = pd.Series(pd.date_range("20130101", periods=5))
  162:         expected = ser.copy()
  163:         expected.loc[2] = pd.Timestamp("20120101")
  164:         result = ser.replace({pd.Timestamp("20130103"): pd.Timestamp("20120101")})
  165:         tm.assert_series_equal(result, expected)
  166:         result = ser.replace(pd.Timestamp("20130103"), pd.Timestamp("20120101"))
  167:         tm.assert_series_equal(result, expected)
  168: 
  169:     def test_replace_nat_with_tz(self):
  170:         # GH 11792: Test with replacing NaT in a list with tz data
  171:         ts = pd.Timestamp("2015/01/01", tz="UTC")
  172:         s = pd.Series([pd.NaT, pd.Timestamp("2015/01/01", tz="UTC")])
  173:         result = s.replace([np.nan, pd.NaT], pd.Timestamp.min)
  174:         expected = pd.Series([pd.Timestamp.min, ts], dtype=object)
  175:         tm.assert_series_equal(expected, result)
  176: 
  177:     def test_replace_timedelta_td64(self):
  178:         tdi = pd.timedelta_range(0, periods=5)
  179:         ser = pd.Series(tdi)
  180: 
  181:         # Using a single dict argument means we go through replace_list
  182:         result = ser.replace({ser[1]: ser[3]})
  183: 
  184:         expected = pd.Series([ser[0], ser[3], ser[2], ser[3], ser[4]])
  185:         tm.assert_series_equal(result, expected)
  186: 
  187:     def test_replace_with_single_list(self):
  188:         ser = pd.Series([0, 1, 2, 3, 4])
  189:         msg2 = (
  190:             "Series.replace without 'value' and with non-dict-like "
  191:             "'to_replace' is deprecated"
  192:         )
  193:         with tm.assert_produces_warning(FutureWarning, match=msg2):
  194:             result = ser.replace([1, 2, 3])
  195:         tm.assert_series_equal(result, pd.Series([0, 0, 0, 0, 4]))
  196: 
  197:         s = ser.copy()
  198:         with tm.assert_produces_warning(FutureWarning, match=msg2):
  199:             return_value = s.replace([1, 2, 3], inplace=True)
  200:         assert return_value is None
  201:         tm.assert_series_equal(s, pd.Series([0, 0, 0, 0, 4]))
  202: 
  203:         # make sure things don't get corrupted when fillna call fails
  204:         s = ser.copy()
  205:         msg = (
  206:             r"Invalid fill method\. Expecting pad \(ffill\) or backfill "
  207:             r"\(bfill\)\. Got crash_cymbal"
  208:         )
  209:         msg3 = "The 'method' keyword in Series.replace is deprecated"
  210:         with pytest.raises(ValueError, match=msg):
  211:             with tm.assert_produces_warning(FutureWarning, match=msg3):
  212:                 return_value = s.replace([1, 2, 3], inplace=True, method="crash_cymbal")
  213:             assert return_value is None
  214:         tm.assert_series_equal(s, ser)
  215: 
  216:     def test_replace_mixed_types(self):
  217:         ser = pd.Series(np.arange(5), dtype="int64")
  218: 
  219:         def check_replace(to_rep, val, expected):
  220:             sc = ser.copy()
  221:             result = ser.replace(to_rep, val)
  222:             return_value = sc.replace(to_rep, val, inplace=True)
  223:             assert return_value is None
  224:             tm.assert_series_equal(expected, result)
  225:             tm.assert_series_equal(expected, sc)
  226: 
  227:         # 3.0 can still be held in our int64 series, so we do not upcast GH#44940
  228:         tr, v = [3], [3.0]
  229:         check_replace(tr, v, ser)
  230:         # Note this matches what we get with the scalars 3 and 3.0
  231:         check_replace(tr[0], v[0], ser)
  232: 
  233:         # MUST upcast to float
  234:         e = pd.Series([0, 1, 2, 3.5, 4])
  235:         tr, v = [3], [3.5]
  236:         check_replace(tr, v, e)
  237: 
  238:         # casts to object
  239:         e = pd.Series([0, 1, 2, 3.5, "a"])
  240:         tr, v = [3, 4], [3.5, "a"]
  241:         check_replace(tr, v, e)
  242: 
  243:         # again casts to object
  244:         e = pd.Series([0, 1, 2, 3.5, pd.Timestamp("20130101")])
  245:         tr, v = [3, 4], [3.5, pd.Timestamp("20130101")]
  246:         check_replace(tr, v, e)
  247: 
  248:         # casts to object
  249:         e = pd.Series([0, 1, 2, 3.5, True], dtype="object")
  250:         tr, v = [3, 4], [3.5, True]
  251:         check_replace(tr, v, e)
  252: 
  253:         # test an object with dates + floats + integers + strings
  254:         dr = pd.Series(pd.date_range("1/1/2001", "1/10/2001", freq="D"))
  255:         result = dr.astype(object).replace([dr[0], dr[1], dr[2]], [1.0, 2, "a"])
  256:         expected = pd.Series([1.0, 2, "a"] + dr[3:].tolist(), dtype=object)
  257:         tm.assert_series_equal(result, expected)
  258: 
  259:     def test_replace_bool_with_string_no_op(self):
  260:         s = pd.Series([True, False, True])
  261:         result = s.replace("fun", "in-the-sun")
  262:         tm.assert_series_equal(s, result)
  263: 
  264:     def test_replace_bool_with_string(self):
  265:         # nonexistent elements
  266:         s = pd.Series([True, False, True])
  267:         result = s.replace(True, "2u")
  268:         expected = pd.Series(["2u", False, "2u"])
  269:         tm.assert_series_equal(expected, result)
  270: 
  271:     def test_replace_bool_with_bool(self):
  272:         s = pd.Series([True, False, True])
  273:         result = s.replace(True, False)
  274:         expected = pd.Series([False] * len(s))
  275:         tm.assert_series_equal(expected, result)
  276: 
  277:     def test_replace_with_dict_with_bool_keys(self):
  278:         s = pd.Series([True, False, True])
  279:         result = s.replace({"asdf": "asdb", True: "yes"})
  280:         expected = pd.Series(["yes", False, "yes"])
  281:         tm.assert_series_equal(result, expected)
  282: 
  283:     def test_replace_Int_with_na(self, any_int_ea_dtype):
  284:         # GH 38267
  285:         result = pd.Series([0, None], dtype=any_int_ea_dtype).replace(0, pd.NA)
  286:         expected = pd.Series([pd.NA, pd.NA], dtype=any_int_ea_dtype)
  287:         tm.assert_series_equal(result, expected)
  288:         result = pd.Series([0, 1], dtype=any_int_ea_dtype).replace(0, pd.NA)
  289:         result.replace(1, pd.NA, inplace=True)
  290:         tm.assert_series_equal(result, expected)
  291: 
  292:     def test_replace2(self):
  293:         N = 50
  294:         ser = pd.Series(
  295:             np.fabs(np.random.default_rng(2).standard_normal(N)),
  296:             pd.date_range("2020-01-01", periods=N),
  297:             dtype=object,
  298:         )
  299:         ser[:5] = np.nan
  300:         ser[6:10] = "foo"
  301:         ser[20:30] = "bar"
  302: 
  303:         # replace list with a single value
  304:         msg = "Downcasting behavior in `replace`"
  305:         with tm.assert_produces_warning(FutureWarning, match=msg):
  306:             rs = ser.replace([np.nan, "foo", "bar"], -1)
  307: 
  308:         assert (rs[:5] == -1).all()
  309:         assert (rs[6:10] == -1).all()
  310:         assert (rs[20:30] == -1).all()
  311:         assert (pd.isna(ser[:5])).all()
  312: 
  313:         # replace with different values
  314:         with tm.assert_produces_warning(FutureWarning, match=msg):
  315:             rs = ser.replace({np.nan: -1, "foo": -2, "bar": -3})
  316: 
  317:         assert (rs[:5] == -1).all()
  318:         assert (rs[6:10] == -2).all()
  319:         assert (rs[20:30] == -3).all()
  320:         assert (pd.isna(ser[:5])).all()
  321: 
  322:         # replace with different values with 2 lists
  323:         with tm.assert_produces_warning(FutureWarning, match=msg):
  324:             rs2 = ser.replace([np.nan, "foo", "bar"], [-1, -2, -3])
  325:         tm.assert_series_equal(rs, rs2)
  326: 
  327:         # replace inplace
  328:         with tm.assert_produces_warning(FutureWarning, match=msg):
  329:             return_value = ser.replace([np.nan, "foo", "bar"], -1, inplace=True)
  330:         assert return_value is None
  331:         assert (ser[:5] == -1).all()
  332:         assert (ser[6:10] == -1).all()
  333:         assert (ser[20:30] == -1).all()
  334: 
  335:     @pytest.mark.parametrize("inplace", [True, False])
  336:     def test_replace_cascade(self, inplace):
  337:         # Test that replaced values are not replaced again
  338:         # GH #50778
  339:         ser = pd.Series([1, 2, 3])
  340:         expected = pd.Series([2, 3, 4])
  341: 
  342:         res = ser.replace([1, 2, 3], [2, 3, 4], inplace=inplace)
  343:         if inplace:
  344:             tm.assert_series_equal(ser, expected)
  345:         else:
  346:             tm.assert_series_equal(res, expected)
  347: 
  348:     def test_replace_with_dictlike_and_string_dtype(self, nullable_string_dtype):
  349:         # GH 32621, GH#44940
  350:         ser = pd.Series(["one", "two", np.nan], dtype=nullable_string_dtype)
  351:         expected = pd.Series(["1", "2", np.nan], dtype=nullable_string_dtype)
  352:         result = ser.replace({"one": "1", "two": "2"})
  353:         tm.assert_series_equal(expected, result)
  354: 
  355:     def test_replace_with_empty_dictlike(self):
  356:         # GH 15289
  357:         s = pd.Series(list("abcd"))
  358:         tm.assert_series_equal(s, s.replace({}))
  359: 
  360:         empty_series = pd.Series([])
  361:         tm.assert_series_equal(s, s.replace(empty_series))
  362: 
  363:     def test_replace_string_with_number(self):
  364:         # GH 15743
  365:         s = pd.Series([1, 2, 3])
  366:         result = s.replace("2", np.nan)
  367:         expected = pd.Series([1, 2, 3])
  368:         tm.assert_series_equal(expected, result)
  369: 
  370:     def test_replace_replacer_equals_replacement(self):
  371:         # GH 20656
  372:         # make sure all replacers are matching against original values
  373:         s = pd.Series(["a", "b"])
  374:         expected = pd.Series(["b", "a"])
  375:         result = s.replace({"a": "b", "b": "a"})
  376:         tm.assert_series_equal(expected, result)
  377: 
  378:     def test_replace_unicode_with_number(self):
  379:         # GH 15743
  380:         s = pd.Series([1, 2, 3])
  381:         result = s.replace("2", np.nan)
  382:         expected = pd.Series([1, 2, 3])
  383:         tm.assert_series_equal(expected, result)
  384: 
  385:     def test_replace_mixed_types_with_string(self):
  386:         # Testing mixed
  387:         s = pd.Series([1, 2, 3, "4", 4, 5])
  388:         msg = "Downcasting behavior in `replace`"
  389:         with tm.assert_produces_warning(FutureWarning, match=msg):
  390:             result = s.replace([2, "4"], np.nan)
  391:         expected = pd.Series([1, np.nan, 3, np.nan, 4, 5])
  392:         tm.assert_series_equal(expected, result)
  393: 
  394:     @pytest.mark.xfail(using_pyarrow_string_dtype(), reason="can't fill 0 in string")
  395:     @pytest.mark.parametrize(
  396:         "categorical, numeric",
  397:         [
  398:             (pd.Categorical(["A"], categories=["A", "B"]), [1]),
  399:             (pd.Categorical(["A", "B"], categories=["A", "B"]), [1, 2]),
  400:         ],
  401:     )
  402:     def test_replace_categorical(self, categorical, numeric):
  403:         # GH 24971, GH#23305
  404:         ser = pd.Series(categorical)
  405:         msg = "Downcasting behavior in `replace`"
  406:         msg = "with CategoricalDtype is deprecated"
  407:         with tm.assert_produces_warning(FutureWarning, match=msg):
  408:             result = ser.replace({"A": 1, "B": 2})
  409:         expected = pd.Series(numeric).astype("category")
  410:         if 2 not in expected.cat.categories:
  411:             # i.e. categories should be [1, 2] even if there are no "B"s present
  412:             # GH#44940
  413:             expected = expected.cat.add_categories(2)
  414:         tm.assert_series_equal(expected, result)
  415: 
  416:     @pytest.mark.parametrize(
  417:         "data, data_exp", [(["a", "b", "c"], ["b", "b", "c"]), (["a"], ["b"])]
  418:     )
  419:     def test_replace_categorical_inplace(self, data, data_exp):
  420:         # GH 53358
  421:         result = pd.Series(data, dtype="category")
  422:         msg = "with CategoricalDtype is deprecated"
  423:         with tm.assert_produces_warning(FutureWarning, match=msg):
  424:             result.replace(to_replace="a", value="b", inplace=True)
  425:         expected = pd.Series(data_exp, dtype="category")
  426:         tm.assert_series_equal(result, expected)
  427: 
  428:     def test_replace_categorical_single(self):
  429:         # GH 26988
  430:         dti = pd.date_range("2016-01-01", periods=3, tz="US/Pacific")
  431:         s = pd.Series(dti)
  432:         c = s.astype("category")
  433: 
  434:         expected = c.copy()
  435:         expected = expected.cat.add_categories("foo")
  436:         expected[2] = "foo"
  437:         expected = expected.cat.remove_unused_categories()
  438:         assert c[2] != "foo"
  439: 
  440:         msg = "with CategoricalDtype is deprecated"
  441:         with tm.assert_produces_warning(FutureWarning, match=msg):
  442:             result = c.replace(c[2], "foo")
  443:         tm.assert_series_equal(expected, result)
  444:         assert c[2] != "foo"  # ensure non-inplace call does not alter original
  445: 
  446:         msg = "with CategoricalDtype is deprecated"
  447:         with tm.assert_produces_warning(FutureWarning, match=msg):
  448:             return_value = c.replace(c[2], "foo", inplace=True)
  449:         assert return_value is None
  450:         tm.assert_series_equal(expected, c)
  451: 
  452:         first_value = c[0]
  453:         msg = "with CategoricalDtype is deprecated"
  454:         with tm.assert_produces_warning(FutureWarning, match=msg):
  455:             return_value = c.replace(c[1], c[0], inplace=True)
  456:         assert return_value is None
  457:         assert c[0] == c[1] == first_value  # test replacing with existing value
  458: 
  459:     def test_replace_with_no_overflowerror(self):
  460:         # GH 25616
  461:         # casts to object without Exception from OverflowError
  462:         s = pd.Series([0, 1, 2, 3, 4])
  463:         result = s.replace([3], ["100000000000000000000"])
  464:         expected = pd.Series([0, 1, 2, "100000000000000000000", 4])
  465:         tm.assert_series_equal(result, expected)
  466: 
  467:         s = pd.Series([0, "100000000000000000000", "100000000000000000001"])
  468:         result = s.replace(["100000000000000000000"], [1])
  469:         expected = pd.Series([0, 1, "100000000000000000001"])
  470:         tm.assert_series_equal(result, expected)
  471: 
  472:     @pytest.mark.parametrize(
  473:         "ser, to_replace, exp",
  474:         [
  475:             ([1, 2, 3], {1: 2, 2: 3, 3: 4}, [2, 3, 4]),
  476:             (["1", "2", "3"], {"1": "2", "2": "3", "3": "4"}, ["2", "3", "4"]),
  477:         ],
  478:     )
  479:     def test_replace_commutative(self, ser, to_replace, exp):
  480:         # GH 16051
  481:         # DataFrame.replace() overwrites when values are non-numeric
  482: 
  483:         series = pd.Series(ser)
  484: 
  485:         expected = pd.Series(exp)
  486:         result = series.replace(to_replace)
  487: 
  488:         tm.assert_series_equal(result, expected)
  489: 
  490:     @pytest.mark.parametrize(
  491:         "ser, exp", [([1, 2, 3], [1, True, 3]), (["x", 2, 3], ["x", True, 3])]
  492:     )
  493:     def test_replace_no_cast(self, ser, exp):
  494:         # GH 9113
  495:         # BUG: replace int64 dtype with bool coerces to int64
  496: 
  497:         series = pd.Series(ser)
  498:         result = series.replace(2, True)
  499:         expected = pd.Series(exp)
  500: 
  501:         tm.assert_series_equal(result, expected)
  502: 
  503:     def test_replace_invalid_to_replace(self):
  504:         # GH 18634
  505:         # API: replace() should raise an exception if invalid argument is given
  506:         series = pd.Series(["a", "b", "c "])
  507:         msg = (
  508:             r"Expecting 'to_replace' to be either a scalar, array-like, "
  509:             r"dict or None, got invalid type.*"
  510:         )
  511:         msg2 = (
  512:             "Series.replace without 'value' and with non-dict-like "
  513:             "'to_replace' is deprecated"
  514:         )
  515:         with pytest.raises(TypeError, match=msg):
  516:             with tm.assert_produces_warning(FutureWarning, match=msg2):
  517:                 series.replace(lambda x: x.strip())
  518: 
  519:     @pytest.mark.parametrize("frame", [False, True])
  520:     def test_replace_nonbool_regex(self, frame):
  521:         obj = pd.Series(["a", "b", "c "])
  522:         if frame:
  523:             obj = obj.to_frame()
  524: 
  525:         msg = "'to_replace' must be 'None' if 'regex' is not a bool"
  526:         with pytest.raises(ValueError, match=msg):
  527:             obj.replace(to_replace=["a"], regex="foo")
  528: 
  529:     @pytest.mark.parametrize("frame", [False, True])
  530:     def test_replace_empty_copy(self, frame):
  531:         obj = pd.Series([], dtype=np.float64)
  532:         if frame:
  533:             obj = obj.to_frame()
  534: 
  535:         res = obj.replace(4, 5, inplace=True)
  536:         assert res is None
  537: 
  538:         res = obj.replace(4, 5, inplace=False)
  539:         tm.assert_equal(res, obj)
  540:         assert res is not obj
  541: 
  542:     def test_replace_only_one_dictlike_arg(self, fixed_now_ts):
  543:         # GH#33340
  544: 
  545:         ser = pd.Series([1, 2, "A", fixed_now_ts, True])
  546:         to_replace = {0: 1, 2: "A"}
  547:         value = "foo"
  548:         msg = "Series.replace cannot use dict-like to_replace and non-None value"
  549:         with pytest.raises(ValueError, match=msg):
  550:             ser.replace(to_replace, value)
  551: 
  552:         to_replace = 1
  553:         value = {0: "foo", 2: "bar"}
  554:         msg = "Series.replace cannot use dict-value and non-None to_replace"
  555:         with pytest.raises(ValueError, match=msg):
  556:             ser.replace(to_replace, value)
  557: 
  558:     def test_replace_extension_other(self, frame_or_series):
  559:         # https://github.com/pandas-dev/pandas/issues/34530
  560:         obj = frame_or_series(pd.array([1, 2, 3], dtype="Int64"))
  561:         result = obj.replace("", "")  # no exception
  562:         # should not have changed dtype
  563:         tm.assert_equal(obj, result)
  564: 
  565:     def _check_replace_with_method(self, ser: pd.Series):
  566:         df = ser.to_frame()
  567: 
  568:         msg1 = "The 'method' keyword in Series.replace is deprecated"
  569:         with tm.assert_produces_warning(FutureWarning, match=msg1):
  570:             res = ser.replace(ser[1], method="pad")
  571:         expected = pd.Series([ser[0], ser[0]] + list(ser[2:]), dtype=ser.dtype)
  572:         tm.assert_series_equal(res, expected)
  573: 
  574:         msg2 = "The 'method' keyword in DataFrame.replace is deprecated"
  575:         with tm.assert_produces_warning(FutureWarning, match=msg2):
  576:             res_df = df.replace(ser[1], method="pad")
  577:         tm.assert_frame_equal(res_df, expected.to_frame())
  578: 
  579:         ser2 = ser.copy()
  580:         with tm.assert_produces_warning(FutureWarning, match=msg1):
  581:             res2 = ser2.replace(ser[1], method="pad", inplace=True)
  582:         assert res2 is None
  583:         tm.assert_series_equal(ser2, expected)
  584: 
  585:         with tm.assert_produces_warning(FutureWarning, match=msg2):
  586:             res_df2 = df.replace(ser[1], method="pad", inplace=True)
  587:         assert res_df2 is None
  588:         tm.assert_frame_equal(df, expected.to_frame())
  589: 
  590:     def test_replace_ea_dtype_with_method(self, any_numeric_ea_dtype):
  591:         arr = pd.array([1, 2, pd.NA, 4], dtype=any_numeric_ea_dtype)
  592:         ser = pd.Series(arr)
  593: 
  594:         self._check_replace_with_method(ser)
  595: 
  596:     @pytest.mark.parametrize("as_categorical", [True, False])
  597:     def test_replace_interval_with_method(self, as_categorical):
  598:         # in particular interval that can't hold NA
  599: 
  600:         idx = pd.IntervalIndex.from_breaks(range(4))
  601:         ser = pd.Series(idx)
  602:         if as_categorical:
  603:             ser = ser.astype("category")
  604: 
  605:         self._check_replace_with_method(ser)
  606: 
  607:     @pytest.mark.parametrize("as_period", [True, False])
  608:     @pytest.mark.parametrize("as_categorical", [True, False])
  609:     def test_replace_datetimelike_with_method(self, as_period, as_categorical):
  610:         idx = pd.date_range("2016-01-01", periods=5, tz="US/Pacific")
  611:         if as_period:
  612:             idx = idx.tz_localize(None).to_period("D")
  613: 
  614:         ser = pd.Series(idx)
  615:         ser.iloc[-2] = pd.NaT
  616:         if as_categorical:
  617:             ser = ser.astype("category")
  618: 
  619:         self._check_replace_with_method(ser)
  620: 
  621:     def test_replace_with_compiled_regex(self):
  622:         # https://github.com/pandas-dev/pandas/issues/35680
  623:         s = pd.Series(["a", "b", "c"])
  624:         regex = re.compile("^a$")
  625:         result = s.replace({regex: "z"}, regex=True)
  626:         expected = pd.Series(["z", "b", "c"])
  627:         tm.assert_series_equal(result, expected)
  628: 
  629:     def test_pandas_replace_na(self):
  630:         # GH#43344
  631:         ser = pd.Series(["AA", "BB", "CC", "DD", "EE", "", pd.NA], dtype="string")
  632:         regex_mapping = {
  633:             "AA": "CC",
  634:             "BB": "CC",
  635:             "EE": "CC",
  636:             "CC": "CC-REPL",
  637:         }
  638:         result = ser.replace(regex_mapping, regex=True)
  639:         exp = pd.Series(["CC", "CC", "CC-REPL", "DD", "CC", "", pd.NA], dtype="string")
  640:         tm.assert_series_equal(result, exp)
  641: 
  642:     @pytest.mark.parametrize(
  643:         "dtype, input_data, to_replace, expected_data",
  644:         [
  645:             ("bool", [True, False], {True: False}, [False, False]),
  646:             ("int64", [1, 2], {1: 10, 2: 20}, [10, 20]),
  647:             ("Int64", [1, 2], {1: 10, 2: 20}, [10, 20]),
  648:             ("float64", [1.1, 2.2], {1.1: 10.1, 2.2: 20.5}, [10.1, 20.5]),
  649:             ("Float64", [1.1, 2.2], {1.1: 10.1, 2.2: 20.5}, [10.1, 20.5]),
  650:             ("string", ["one", "two"], {"one": "1", "two": "2"}, ["1", "2"]),
  651:             (
  652:                 pd.IntervalDtype("int64"),
  653:                 IntervalArray([pd.Interval(1, 2), pd.Interval(2, 3)]),
  654:                 {pd.Interval(1, 2): pd.Interval(10, 20)},
  655:                 IntervalArray([pd.Interval(10, 20), pd.Interval(2, 3)]),
  656:             ),
  657:             (
  658:                 pd.IntervalDtype("float64"),
  659:                 IntervalArray([pd.Interval(1.0, 2.7), pd.Interval(2.8, 3.1)]),
  660:                 {pd.Interval(1.0, 2.7): pd.Interval(10.6, 20.8)},
  661:                 IntervalArray([pd.Interval(10.6, 20.8), pd.Interval(2.8, 3.1)]),
  662:             ),
  663:             (
  664:                 pd.PeriodDtype("M"),
  665:                 [pd.Period("2020-05", freq="M")],
  666:                 {pd.Period("2020-05", freq="M"): pd.Period("2020-06", freq="M")},
  667:                 [pd.Period("2020-06", freq="M")],
  668:             ),
  669:         ],
  670:     )
  671:     def test_replace_dtype(self, dtype, input_data, to_replace, expected_data):
  672:         # GH#33484
  673:         ser = pd.Series(input_data, dtype=dtype)
  674:         result = ser.replace(to_replace)
  675:         expected = pd.Series(expected_data, dtype=dtype)
  676:         tm.assert_series_equal(result, expected)
  677: 
  678:     def test_replace_string_dtype(self):
  679:         # GH#40732, GH#44940
  680:         ser = pd.Series(["one", "two", np.nan], dtype="string")
  681:         res = ser.replace({"one": "1", "two": "2"})
  682:         expected = pd.Series(["1", "2", np.nan], dtype="string")
  683:         tm.assert_series_equal(res, expected)
  684: 
  685:         # GH#31644
  686:         ser2 = pd.Series(["A", np.nan], dtype="string")
  687:         res2 = ser2.replace("A", "B")
  688:         expected2 = pd.Series(["B", np.nan], dtype="string")
  689:         tm.assert_series_equal(res2, expected2)
  690: 
  691:         ser3 = pd.Series(["A", "B"], dtype="string")
  692:         res3 = ser3.replace("A", pd.NA)
  693:         expected3 = pd.Series([pd.NA, "B"], dtype="string")
  694:         tm.assert_series_equal(res3, expected3)
  695: 
  696:     def test_replace_string_dtype_list_to_replace(self):
  697:         # GH#41215, GH#44940
  698:         ser = pd.Series(["abc", "def"], dtype="string")
  699:         res = ser.replace(["abc", "any other string"], "xyz")
  700:         expected = pd.Series(["xyz", "def"], dtype="string")
  701:         tm.assert_series_equal(res, expected)
  702: 
  703:     def test_replace_string_dtype_regex(self):
  704:         # GH#31644
  705:         ser = pd.Series(["A", "B"], dtype="string")
  706:         res = ser.replace(r".", "C", regex=True)
  707:         expected = pd.Series(["C", "C"], dtype="string")
  708:         tm.assert_series_equal(res, expected)
  709: 
  710:     def test_replace_nullable_numeric(self):
  711:         # GH#40732, GH#44940
  712: 
  713:         floats = pd.Series([1.0, 2.0, 3.999, 4.4], dtype=pd.Float64Dtype())
  714:         assert floats.replace({1.0: 9}).dtype == floats.dtype
  715:         assert floats.replace(1.0, 9).dtype == floats.dtype
  716:         assert floats.replace({1.0: 9.0}).dtype == floats.dtype
  717:         assert floats.replace(1.0, 9.0).dtype == floats.dtype
  718: 
  719:         res = floats.replace(to_replace=[1.0, 2.0], value=[9.0, 10.0])
  720:         assert res.dtype == floats.dtype
  721: 
  722:         ints = pd.Series([1, 2, 3, 4], dtype=pd.Int64Dtype())
  723:         assert ints.replace({1: 9}).dtype == ints.dtype
  724:         assert ints.replace(1, 9).dtype == ints.dtype
  725:         assert ints.replace({1: 9.0}).dtype == ints.dtype
  726:         assert ints.replace(1, 9.0).dtype == ints.dtype
  727: 
  728:         # nullable (for now) raises instead of casting
  729:         with pytest.raises(TypeError, match="Invalid value"):
  730:             ints.replace({1: 9.5})
  731:         with pytest.raises(TypeError, match="Invalid value"):
  732:             ints.replace(1, 9.5)
  733: 
  734:     @pytest.mark.xfail(using_pyarrow_string_dtype(), reason="can't fill 1 in string")
  735:     @pytest.mark.parametrize("regex", [False, True])
  736:     def test_replace_regex_dtype_series(self, regex):
  737:         # GH-48644
  738:         series = pd.Series(["0"])
  739:         expected = pd.Series([1])
  740:         msg = "Downcasting behavior in `replace`"
  741:         with tm.assert_produces_warning(FutureWarning, match=msg):
  742:             result = series.replace(to_replace="0", value=1, regex=regex)
  743:         tm.assert_series_equal(result, expected)
  744: 
  745:     def test_replace_different_int_types(self, any_int_numpy_dtype):
  746:         # GH#45311
  747:         labs = pd.Series([1, 1, 1, 0, 0, 2, 2, 2], dtype=any_int_numpy_dtype)
  748: 
  749:         maps = pd.Series([0, 2, 1], dtype=any_int_numpy_dtype)
  750:         map_dict = dict(zip(maps.values, maps.index))
  751: 
  752:         result = labs.replace(map_dict)
  753:         expected = labs.replace({0: 0, 2: 1, 1: 2})
  754:         tm.assert_series_equal(result, expected)
  755: 
  756:     @pytest.mark.parametrize("val", [2, np.nan, 2.0])
  757:     def test_replace_value_none_dtype_numeric(self, val):
  758:         # GH#48231
  759:         ser = pd.Series([1, val])
  760:         result = ser.replace(val, None)
  761:         expected = pd.Series([1, None], dtype=object)
  762:         tm.assert_series_equal(result, expected)
  763: 
  764:     def test_replace_change_dtype_series(self, using_infer_string):
  765:         # GH#25797
  766:         df = pd.DataFrame.from_dict({"Test": ["0.5", True, "0.6"]})
  767:         warn = FutureWarning if using_infer_string else None
  768:         with tm.assert_produces_warning(warn, match="Downcasting"):
  769:             df["Test"] = df["Test"].replace([True], [np.nan])
  770:         expected = pd.DataFrame.from_dict({"Test": ["0.5", np.nan, "0.6"]})
  771:         tm.assert_frame_equal(df, expected)
  772: 
  773:         df = pd.DataFrame.from_dict({"Test": ["0.5", None, "0.6"]})
  774:         df["Test"] = df["Test"].replace([None], [np.nan])
  775:         tm.assert_frame_equal(df, expected)
  776: 
  777:         df = pd.DataFrame.from_dict({"Test": ["0.5", None, "0.6"]})
  778:         df["Test"] = df["Test"].fillna(np.nan)
  779:         tm.assert_frame_equal(df, expected)
  780: 
  781:     @pytest.mark.parametrize("dtype", ["object", "Int64"])
  782:     def test_replace_na_in_obj_column(self, dtype):
  783:         # GH#47480
  784:         ser = pd.Series([0, 1, pd.NA], dtype=dtype)
  785:         expected = pd.Series([0, 2, pd.NA], dtype=dtype)
  786:         result = ser.replace(to_replace=1, value=2)
  787:         tm.assert_series_equal(result, expected)
  788: 
  789:         ser.replace(to_replace=1, value=2, inplace=True)
  790:         tm.assert_series_equal(ser, expected)
  791: 
  792:     @pytest.mark.parametrize("val", [0, 0.5])
  793:     def test_replace_numeric_column_with_na(self, val):
  794:         # GH#50758
  795:         ser = pd.Series([val, 1])
  796:         expected = pd.Series([val, pd.NA])
  797:         result = ser.replace(to_replace=1, value=pd.NA)
  798:         tm.assert_series_equal(result, expected)
  799: 
  800:         ser.replace(to_replace=1, value=pd.NA, inplace=True)
  801:         tm.assert_series_equal(ser, expected)
  802: 
  803:     def test_replace_ea_float_with_bool(self):
  804:         # GH#55398
  805:         ser = pd.Series([0.0], dtype="Float64")
  806:         expected = ser.copy()
  807:         result = ser.replace(False, 1.0)
  808:         tm.assert_series_equal(result, expected)
  809: 
  810:         ser = pd.Series([False], dtype="boolean")
  811:         expected = ser.copy()
  812:         result = ser.replace(0.0, True)
  813:         tm.assert_series_equal(result, expected)
