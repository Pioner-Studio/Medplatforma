    1: from collections import deque
    2: import re
    3: import string
    4: 
    5: import numpy as np
    6: import pytest
    7: 
    8: import pandas.util._test_decorators as td
    9: 
   10: import pandas as pd
   11: import pandas._testing as tm
   12: from pandas.arrays import SparseArray
   13: 
   14: 
   15: @pytest.fixture(params=[np.add, np.logaddexp])
   16: def ufunc(request):
   17:     # dunder op
   18:     return request.param
   19: 
   20: 
   21: @pytest.fixture(params=[True, False], ids=["sparse", "dense"])
   22: def sparse(request):
   23:     return request.param
   24: 
   25: 
   26: @pytest.fixture
   27: def arrays_for_binary_ufunc():
   28:     """
   29:     A pair of random, length-100 integer-dtype arrays, that are mostly 0.
   30:     """
   31:     a1 = np.random.default_rng(2).integers(0, 10, 100, dtype="int64")
   32:     a2 = np.random.default_rng(2).integers(0, 10, 100, dtype="int64")
   33:     a1[::3] = 0
   34:     a2[::4] = 0
   35:     return a1, a2
   36: 
   37: 
   38: @pytest.mark.parametrize("ufunc", [np.positive, np.floor, np.exp])
   39: def test_unary_ufunc(ufunc, sparse):
   40:     # Test that ufunc(pd.Series) == pd.Series(ufunc)
   41:     arr = np.random.default_rng(2).integers(0, 10, 10, dtype="int64")
   42:     arr[::2] = 0
   43:     if sparse:
   44:         arr = SparseArray(arr, dtype=pd.SparseDtype("int64", 0))
   45: 
   46:     index = list(string.ascii_letters[:10])
   47:     name = "name"
   48:     series = pd.Series(arr, index=index, name=name)
   49: 
   50:     result = ufunc(series)
   51:     expected = pd.Series(ufunc(arr), index=index, name=name)
   52:     tm.assert_series_equal(result, expected)
   53: 
   54: 
   55: @pytest.mark.parametrize("flip", [True, False], ids=["flipped", "straight"])
   56: def test_binary_ufunc_with_array(flip, sparse, ufunc, arrays_for_binary_ufunc):
   57:     # Test that ufunc(pd.Series(a), array) == pd.Series(ufunc(a, b))
   58:     a1, a2 = arrays_for_binary_ufunc
   59:     if sparse:
   60:         a1 = SparseArray(a1, dtype=pd.SparseDtype("int64", 0))
   61:         a2 = SparseArray(a2, dtype=pd.SparseDtype("int64", 0))
   62: 
   63:     name = "name"  # op(pd.Series, array) preserves the name.
   64:     series = pd.Series(a1, name=name)
   65:     other = a2
   66: 
   67:     array_args = (a1, a2)
   68:     series_args = (series, other)  # ufunc(series, array)
   69: 
   70:     if flip:
   71:         array_args = reversed(array_args)
   72:         series_args = reversed(series_args)  # ufunc(array, series)
   73: 
   74:     expected = pd.Series(ufunc(*array_args), name=name)
   75:     result = ufunc(*series_args)
   76:     tm.assert_series_equal(result, expected)
   77: 
   78: 
   79: @pytest.mark.parametrize("flip", [True, False], ids=["flipped", "straight"])
   80: def test_binary_ufunc_with_index(flip, sparse, ufunc, arrays_for_binary_ufunc):
   81:     # Test that
   82:     #   * func(pd.Series(a), pd.Series(b)) == pd.Series(ufunc(a, b))
   83:     #   * ufunc(Index, pd.Series) dispatches to pd.Series (returns a pd.Series)
   84:     a1, a2 = arrays_for_binary_ufunc
   85:     if sparse:
   86:         a1 = SparseArray(a1, dtype=pd.SparseDtype("int64", 0))
   87:         a2 = SparseArray(a2, dtype=pd.SparseDtype("int64", 0))
   88: 
   89:     name = "name"  # op(pd.Series, array) preserves the name.
   90:     series = pd.Series(a1, name=name)
   91: 
   92:     other = pd.Index(a2, name=name).astype("int64")
   93: 
   94:     array_args = (a1, a2)
   95:     series_args = (series, other)  # ufunc(series, array)
   96: 
   97:     if flip:
   98:         array_args = reversed(array_args)
   99:         series_args = reversed(series_args)  # ufunc(array, series)
  100: 
  101:     expected = pd.Series(ufunc(*array_args), name=name)
  102:     result = ufunc(*series_args)
  103:     tm.assert_series_equal(result, expected)
  104: 
  105: 
  106: @pytest.mark.parametrize("shuffle", [True, False], ids=["unaligned", "aligned"])
  107: @pytest.mark.parametrize("flip", [True, False], ids=["flipped", "straight"])
  108: def test_binary_ufunc_with_series(
  109:     flip, shuffle, sparse, ufunc, arrays_for_binary_ufunc
  110: ):
  111:     # Test that
  112:     #   * func(pd.Series(a), pd.Series(b)) == pd.Series(ufunc(a, b))
  113:     #   with alignment between the indices
  114:     a1, a2 = arrays_for_binary_ufunc
  115:     if sparse:
  116:         a1 = SparseArray(a1, dtype=pd.SparseDtype("int64", 0))
  117:         a2 = SparseArray(a2, dtype=pd.SparseDtype("int64", 0))
  118: 
  119:     name = "name"  # op(pd.Series, array) preserves the name.
  120:     series = pd.Series(a1, name=name)
  121:     other = pd.Series(a2, name=name)
  122: 
  123:     idx = np.random.default_rng(2).permutation(len(a1))
  124: 
  125:     if shuffle:
  126:         other = other.take(idx)
  127:         if flip:
  128:             index = other.align(series)[0].index
  129:         else:
  130:             index = series.align(other)[0].index
  131:     else:
  132:         index = series.index
  133: 
  134:     array_args = (a1, a2)
  135:     series_args = (series, other)  # ufunc(series, array)
  136: 
  137:     if flip:
  138:         array_args = tuple(reversed(array_args))
  139:         series_args = tuple(reversed(series_args))  # ufunc(array, series)
  140: 
  141:     expected = pd.Series(ufunc(*array_args), index=index, name=name)
  142:     result = ufunc(*series_args)
  143:     tm.assert_series_equal(result, expected)
  144: 
  145: 
  146: @pytest.mark.parametrize("flip", [True, False])
  147: def test_binary_ufunc_scalar(ufunc, sparse, flip, arrays_for_binary_ufunc):
  148:     # Test that
  149:     #   * ufunc(pd.Series, scalar) == pd.Series(ufunc(array, scalar))
  150:     #   * ufunc(pd.Series, scalar) == ufunc(scalar, pd.Series)
  151:     arr, _ = arrays_for_binary_ufunc
  152:     if sparse:
  153:         arr = SparseArray(arr)
  154:     other = 2
  155:     series = pd.Series(arr, name="name")
  156: 
  157:     series_args = (series, other)
  158:     array_args = (arr, other)
  159: 
  160:     if flip:
  161:         series_args = tuple(reversed(series_args))
  162:         array_args = tuple(reversed(array_args))
  163: 
  164:     expected = pd.Series(ufunc(*array_args), name="name")
  165:     result = ufunc(*series_args)
  166: 
  167:     tm.assert_series_equal(result, expected)
  168: 
  169: 
  170: @pytest.mark.parametrize("ufunc", [np.divmod])  # TODO: np.modf, np.frexp
  171: @pytest.mark.parametrize("shuffle", [True, False])
  172: @pytest.mark.filterwarnings("ignore:divide by zero:RuntimeWarning")
  173: def test_multiple_output_binary_ufuncs(ufunc, sparse, shuffle, arrays_for_binary_ufunc):
  174:     # Test that
  175:     #  the same conditions from binary_ufunc_scalar apply to
  176:     #  ufuncs with multiple outputs.
  177: 
  178:     a1, a2 = arrays_for_binary_ufunc
  179:     # work around https://github.com/pandas-dev/pandas/issues/26987
  180:     a1[a1 == 0] = 1
  181:     a2[a2 == 0] = 1
  182: 
  183:     if sparse:
  184:         a1 = SparseArray(a1, dtype=pd.SparseDtype("int64", 0))
  185:         a2 = SparseArray(a2, dtype=pd.SparseDtype("int64", 0))
  186: 
  187:     s1 = pd.Series(a1)
  188:     s2 = pd.Series(a2)
  189: 
  190:     if shuffle:
  191:         # ensure we align before applying the ufunc
  192:         s2 = s2.sample(frac=1)
  193: 
  194:     expected = ufunc(a1, a2)
  195:     assert isinstance(expected, tuple)
  196: 
  197:     result = ufunc(s1, s2)
  198:     assert isinstance(result, tuple)
  199:     tm.assert_series_equal(result[0], pd.Series(expected[0]))
  200:     tm.assert_series_equal(result[1], pd.Series(expected[1]))
  201: 
  202: 
  203: def test_multiple_output_ufunc(sparse, arrays_for_binary_ufunc):
  204:     # Test that the same conditions from unary input apply to multi-output
  205:     # ufuncs
  206:     arr, _ = arrays_for_binary_ufunc
  207: 
  208:     if sparse:
  209:         arr = SparseArray(arr)
  210: 
  211:     series = pd.Series(arr, name="name")
  212:     result = np.modf(series)
  213:     expected = np.modf(arr)
  214: 
  215:     assert isinstance(result, tuple)
  216:     assert isinstance(expected, tuple)
  217: 
  218:     tm.assert_series_equal(result[0], pd.Series(expected[0], name="name"))
  219:     tm.assert_series_equal(result[1], pd.Series(expected[1], name="name"))
  220: 
  221: 
  222: def test_binary_ufunc_drops_series_name(ufunc, sparse, arrays_for_binary_ufunc):
  223:     # Drop the names when they differ.
  224:     a1, a2 = arrays_for_binary_ufunc
  225:     s1 = pd.Series(a1, name="a")
  226:     s2 = pd.Series(a2, name="b")
  227: 
  228:     result = ufunc(s1, s2)
  229:     assert result.name is None
  230: 
  231: 
  232: def test_object_series_ok():
  233:     class Dummy:
  234:         def __init__(self, value) -> None:
  235:             self.value = value
  236: 
  237:         def __add__(self, other):
  238:             return self.value + other.value
  239: 
  240:     arr = np.array([Dummy(0), Dummy(1)])
  241:     ser = pd.Series(arr)
  242:     tm.assert_series_equal(np.add(ser, ser), pd.Series(np.add(ser, arr)))
  243:     tm.assert_series_equal(np.add(ser, Dummy(1)), pd.Series(np.add(ser, Dummy(1))))
  244: 
  245: 
  246: @pytest.fixture(
  247:     params=[
  248:         pd.array([1, 3, 2], dtype=np.int64),
  249:         pd.array([1, 3, 2], dtype="Int64"),
  250:         pd.array([1, 3, 2], dtype="Float32"),
  251:         pd.array([1, 10, 2], dtype="Sparse[int]"),
  252:         pd.to_datetime(["2000", "2010", "2001"]),
  253:         pd.to_datetime(["2000", "2010", "2001"]).tz_localize("CET"),
  254:         pd.to_datetime(["2000", "2010", "2001"]).to_period(freq="D"),
  255:         pd.to_timedelta(["1 Day", "3 Days", "2 Days"]),
  256:         pd.IntervalIndex([pd.Interval(0, 1), pd.Interval(2, 3), pd.Interval(1, 2)]),
  257:     ],
  258:     ids=lambda x: str(x.dtype),
  259: )
  260: def values_for_np_reduce(request):
  261:     # min/max tests assume that these are monotonic increasing
  262:     return request.param
  263: 
  264: 
  265: class TestNumpyReductions:
  266:     # TODO: cases with NAs, axis kwarg for DataFrame
  267: 
  268:     def test_multiply(self, values_for_np_reduce, box_with_array, request):
  269:         box = box_with_array
  270:         values = values_for_np_reduce
  271: 
  272:         with tm.assert_produces_warning(None):
  273:             obj = box(values)
  274: 
  275:         if isinstance(values, pd.core.arrays.SparseArray):
  276:             mark = pytest.mark.xfail(reason="SparseArray has no 'prod'")
  277:             request.applymarker(mark)
  278: 
  279:         if values.dtype.kind in "iuf":
  280:             result = np.multiply.reduce(obj)
  281:             if box is pd.DataFrame:
  282:                 expected = obj.prod(numeric_only=False)
  283:                 tm.assert_series_equal(result, expected)
  284:             elif box is pd.Index:
  285:                 # Index has no 'prod'
  286:                 expected = obj._values.prod()
  287:                 assert result == expected
  288:             else:
  289:                 expected = obj.prod()
  290:                 assert result == expected
  291:         else:
  292:             msg = "|".join(
  293:                 [
  294:                     "does not support reduction",
  295:                     "unsupported operand type",
  296:                     "ufunc 'multiply' cannot use operands",
  297:                 ]
  298:             )
  299:             with pytest.raises(TypeError, match=msg):
  300:                 np.multiply.reduce(obj)
  301: 
  302:     def test_add(self, values_for_np_reduce, box_with_array):
  303:         box = box_with_array
  304:         values = values_for_np_reduce
  305: 
  306:         with tm.assert_produces_warning(None):
  307:             obj = box(values)
  308: 
  309:         if values.dtype.kind in "miuf":
  310:             result = np.add.reduce(obj)
  311:             if box is pd.DataFrame:
  312:                 expected = obj.sum(numeric_only=False)
  313:                 tm.assert_series_equal(result, expected)
  314:             elif box is pd.Index:
  315:                 # Index has no 'sum'
  316:                 expected = obj._values.sum()
  317:                 assert result == expected
  318:             else:
  319:                 expected = obj.sum()
  320:                 assert result == expected
  321:         else:
  322:             msg = "|".join(
  323:                 [
  324:                     "does not support reduction",
  325:                     "unsupported operand type",
  326:                     "ufunc 'add' cannot use operands",
  327:                 ]
  328:             )
  329:             with pytest.raises(TypeError, match=msg):
  330:                 np.add.reduce(obj)
  331: 
  332:     def test_max(self, values_for_np_reduce, box_with_array):
  333:         box = box_with_array
  334:         values = values_for_np_reduce
  335: 
  336:         same_type = True
  337:         if box is pd.Index and values.dtype.kind in ["i", "f"]:
  338:             # ATM Index casts to object, so we get python ints/floats
  339:             same_type = False
  340: 
  341:         with tm.assert_produces_warning(None):
  342:             obj = box(values)
  343: 
  344:         result = np.maximum.reduce(obj)
  345:         if box is pd.DataFrame:
  346:             # TODO: cases with axis kwarg
  347:             expected = obj.max(numeric_only=False)
  348:             tm.assert_series_equal(result, expected)
  349:         else:
  350:             expected = values[1]
  351:             assert result == expected
  352:             if same_type:
  353:                 # check we have e.g. Timestamp instead of dt64
  354:                 assert type(result) == type(expected)
  355: 
  356:     def test_min(self, values_for_np_reduce, box_with_array):
  357:         box = box_with_array
  358:         values = values_for_np_reduce
  359: 
  360:         same_type = True
  361:         if box is pd.Index and values.dtype.kind in ["i", "f"]:
  362:             # ATM Index casts to object, so we get python ints/floats
  363:             same_type = False
  364: 
  365:         with tm.assert_produces_warning(None):
  366:             obj = box(values)
  367: 
  368:         result = np.minimum.reduce(obj)
  369:         if box is pd.DataFrame:
  370:             expected = obj.min(numeric_only=False)
  371:             tm.assert_series_equal(result, expected)
  372:         else:
  373:             expected = values[0]
  374:             assert result == expected
  375:             if same_type:
  376:                 # check we have e.g. Timestamp instead of dt64
  377:                 assert type(result) == type(expected)
  378: 
  379: 
  380: @pytest.mark.parametrize("type_", [list, deque, tuple])
  381: def test_binary_ufunc_other_types(type_):
  382:     a = pd.Series([1, 2, 3], name="name")
  383:     b = type_([3, 4, 5])
  384: 
  385:     result = np.add(a, b)
  386:     expected = pd.Series(np.add(a.to_numpy(), b), name="name")
  387:     tm.assert_series_equal(result, expected)
  388: 
  389: 
  390: def test_object_dtype_ok():
  391:     class Thing:
  392:         def __init__(self, value) -> None:
  393:             self.value = value
  394: 
  395:         def __add__(self, other):
  396:             other = getattr(other, "value", other)
  397:             return type(self)(self.value + other)
  398: 
  399:         def __eq__(self, other) -> bool:
  400:             return type(other) is Thing and self.value == other.value
  401: 
  402:         def __repr__(self) -> str:
  403:             return f"Thing({self.value})"
  404: 
  405:     s = pd.Series([Thing(1), Thing(2)])
  406:     result = np.add(s, Thing(1))
  407:     expected = pd.Series([Thing(2), Thing(3)])
  408:     tm.assert_series_equal(result, expected)
  409: 
  410: 
  411: def test_outer():
  412:     # https://github.com/pandas-dev/pandas/issues/27186
  413:     ser = pd.Series([1, 2, 3])
  414:     obj = np.array([1, 2, 3])
  415: 
  416:     with pytest.raises(NotImplementedError, match=""):
  417:         np.subtract.outer(ser, obj)
  418: 
  419: 
  420: def test_np_matmul():
  421:     # GH26650
  422:     df1 = pd.DataFrame(data=[[-1, 1, 10]])
  423:     df2 = pd.DataFrame(data=[-1, 1, 10])
  424:     expected = pd.DataFrame(data=[102])
  425: 
  426:     result = np.matmul(df1, df2)
  427:     tm.assert_frame_equal(expected, result)
  428: 
  429: 
  430: def test_array_ufuncs_for_many_arguments():
  431:     # GH39853
  432:     def add3(x, y, z):
  433:         return x + y + z
  434: 
  435:     ufunc = np.frompyfunc(add3, 3, 1)
  436:     ser = pd.Series([1, 2])
  437: 
  438:     result = ufunc(ser, ser, 1)
  439:     expected = pd.Series([3, 5], dtype=object)
  440:     tm.assert_series_equal(result, expected)
  441: 
  442:     df = pd.DataFrame([[1, 2]])
  443: 
  444:     msg = (
  445:         "Cannot apply ufunc <ufunc 'add3 (vectorized)'> "
  446:         "to mixed DataFrame and Series inputs."
  447:     )
  448:     with pytest.raises(NotImplementedError, match=re.escape(msg)):
  449:         ufunc(ser, ser, df)
  450: 
  451: 
  452: # TODO(CoW) see https://github.com/pandas-dev/pandas/pull/51082
  453: @td.skip_copy_on_write_not_yet_implemented
  454: def test_np_fix():
  455:     # np.fix is not a ufunc but is composed of several ufunc calls under the hood
  456:     # with `out` and `where` keywords
  457:     ser = pd.Series([-1.5, -0.5, 0.5, 1.5])
  458:     result = np.fix(ser)
  459:     expected = pd.Series([-1.0, -0.0, 0.0, 1.0])
  460:     tm.assert_series_equal(result, expected)
