    1: import numpy as np
    2: import pytest
    3: 
    4: import pandas as pd
    5: from pandas import (
    6:     Series,
    7:     date_range,
    8: )
    9: import pandas._testing as tm
   10: from pandas.core import algorithms
   11: from pandas.core.arrays import PeriodArray
   12: 
   13: 
   14: class TestSeriesIsIn:
   15:     def test_isin(self):
   16:         s = Series(["A", "B", "C", "a", "B", "B", "A", "C"])
   17: 
   18:         result = s.isin(["A", "C"])
   19:         expected = Series([True, False, True, False, False, False, True, True])
   20:         tm.assert_series_equal(result, expected)
   21: 
   22:         # GH#16012
   23:         # This specific issue has to have a series over 1e6 in len, but the
   24:         # comparison array (in_list) must be large enough so that numpy doesn't
   25:         # do a manual masking trick that will avoid this issue altogether
   26:         s = Series(list("abcdefghijk" * 10**5))
   27:         # If numpy doesn't do the manual comparison/mask, these
   28:         # unorderable mixed types are what cause the exception in numpy
   29:         in_list = [-1, "a", "b", "G", "Y", "Z", "E", "K", "E", "S", "I", "R", "R"] * 6
   30: 
   31:         assert s.isin(in_list).sum() == 200000
   32: 
   33:     def test_isin_with_string_scalar(self):
   34:         # GH#4763
   35:         s = Series(["A", "B", "C", "a", "B", "B", "A", "C"])
   36:         msg = (
   37:             r"only list-like objects are allowed to be passed to isin\(\), "
   38:             r"you passed a `str`"
   39:         )
   40:         with pytest.raises(TypeError, match=msg):
   41:             s.isin("a")
   42: 
   43:         s = Series(["aaa", "b", "c"])
   44:         with pytest.raises(TypeError, match=msg):
   45:             s.isin("aaa")
   46: 
   47:     def test_isin_datetimelike_mismatched_reso(self):
   48:         expected = Series([True, True, False, False, False])
   49: 
   50:         ser = Series(date_range("jan-01-2013", "jan-05-2013"))
   51: 
   52:         # fails on dtype conversion in the first place
   53:         day_values = np.asarray(ser[0:2].values).astype("datetime64[D]")
   54:         result = ser.isin(day_values)
   55:         tm.assert_series_equal(result, expected)
   56: 
   57:         dta = ser[:2]._values.astype("M8[s]")
   58:         result = ser.isin(dta)
   59:         tm.assert_series_equal(result, expected)
   60: 
   61:     def test_isin_datetimelike_mismatched_reso_list(self):
   62:         expected = Series([True, True, False, False, False])
   63: 
   64:         ser = Series(date_range("jan-01-2013", "jan-05-2013"))
   65: 
   66:         dta = ser[:2]._values.astype("M8[s]")
   67:         result = ser.isin(list(dta))
   68:         tm.assert_series_equal(result, expected)
   69: 
   70:     def test_isin_with_i8(self):
   71:         # GH#5021
   72: 
   73:         expected = Series([True, True, False, False, False])
   74:         expected2 = Series([False, True, False, False, False])
   75: 
   76:         # datetime64[ns]
   77:         s = Series(date_range("jan-01-2013", "jan-05-2013"))
   78: 
   79:         result = s.isin(s[0:2])
   80:         tm.assert_series_equal(result, expected)
   81: 
   82:         result = s.isin(s[0:2].values)
   83:         tm.assert_series_equal(result, expected)
   84: 
   85:         result = s.isin([s[1]])
   86:         tm.assert_series_equal(result, expected2)
   87: 
   88:         result = s.isin([np.datetime64(s[1])])
   89:         tm.assert_series_equal(result, expected2)
   90: 
   91:         result = s.isin(set(s[0:2]))
   92:         tm.assert_series_equal(result, expected)
   93: 
   94:         # timedelta64[ns]
   95:         s = Series(pd.to_timedelta(range(5), unit="d"))
   96:         result = s.isin(s[0:2])
   97:         tm.assert_series_equal(result, expected)
   98: 
   99:     @pytest.mark.parametrize("empty", [[], Series(dtype=object), np.array([])])
  100:     def test_isin_empty(self, empty):
  101:         # see GH#16991
  102:         s = Series(["a", "b"])
  103:         expected = Series([False, False])
  104: 
  105:         result = s.isin(empty)
  106:         tm.assert_series_equal(expected, result)
  107: 
  108:     def test_isin_read_only(self):
  109:         # https://github.com/pandas-dev/pandas/issues/37174
  110:         arr = np.array([1, 2, 3])
  111:         arr.setflags(write=False)
  112:         s = Series([1, 2, 3])
  113:         result = s.isin(arr)
  114:         expected = Series([True, True, True])
  115:         tm.assert_series_equal(result, expected)
  116: 
  117:     @pytest.mark.parametrize("dtype", [object, None])
  118:     def test_isin_dt64_values_vs_ints(self, dtype):
  119:         # GH#36621 dont cast integers to datetimes for isin
  120:         dti = date_range("2013-01-01", "2013-01-05")
  121:         ser = Series(dti)
  122: 
  123:         comps = np.asarray([1356998400000000000], dtype=dtype)
  124: 
  125:         res = dti.isin(comps)
  126:         expected = np.array([False] * len(dti), dtype=bool)
  127:         tm.assert_numpy_array_equal(res, expected)
  128: 
  129:         res = ser.isin(comps)
  130:         tm.assert_series_equal(res, Series(expected))
  131: 
  132:         res = pd.core.algorithms.isin(ser, comps)
  133:         tm.assert_numpy_array_equal(res, expected)
  134: 
  135:     def test_isin_tzawareness_mismatch(self):
  136:         dti = date_range("2013-01-01", "2013-01-05")
  137:         ser = Series(dti)
  138: 
  139:         other = dti.tz_localize("UTC")
  140: 
  141:         res = dti.isin(other)
  142:         expected = np.array([False] * len(dti), dtype=bool)
  143:         tm.assert_numpy_array_equal(res, expected)
  144: 
  145:         res = ser.isin(other)
  146:         tm.assert_series_equal(res, Series(expected))
  147: 
  148:         res = pd.core.algorithms.isin(ser, other)
  149:         tm.assert_numpy_array_equal(res, expected)
  150: 
  151:     def test_isin_period_freq_mismatch(self):
  152:         dti = date_range("2013-01-01", "2013-01-05")
  153:         pi = dti.to_period("M")
  154:         ser = Series(pi)
  155: 
  156:         # We construct another PeriodIndex with the same i8 values
  157:         #  but different dtype
  158:         dtype = dti.to_period("Y").dtype
  159:         other = PeriodArray._simple_new(pi.asi8, dtype=dtype)
  160: 
  161:         res = pi.isin(other)
  162:         expected = np.array([False] * len(pi), dtype=bool)
  163:         tm.assert_numpy_array_equal(res, expected)
  164: 
  165:         res = ser.isin(other)
  166:         tm.assert_series_equal(res, Series(expected))
  167: 
  168:         res = pd.core.algorithms.isin(ser, other)
  169:         tm.assert_numpy_array_equal(res, expected)
  170: 
  171:     @pytest.mark.parametrize("values", [[-9.0, 0.0], [-9, 0]])
  172:     def test_isin_float_in_int_series(self, values):
  173:         # GH#19356 GH#21804
  174:         ser = Series(values)
  175:         result = ser.isin([-9, -0.5])
  176:         expected = Series([True, False])
  177:         tm.assert_series_equal(result, expected)
  178: 
  179:     @pytest.mark.parametrize("dtype", ["boolean", "Int64", "Float64"])
  180:     @pytest.mark.parametrize(
  181:         "data,values,expected",
  182:         [
  183:             ([0, 1, 0], [1], [False, True, False]),
  184:             ([0, 1, 0], [1, pd.NA], [False, True, False]),
  185:             ([0, pd.NA, 0], [1, 0], [True, False, True]),
  186:             ([0, 1, pd.NA], [1, pd.NA], [False, True, True]),
  187:             ([0, 1, pd.NA], [1, np.nan], [False, True, False]),
  188:             ([0, pd.NA, pd.NA], [np.nan, pd.NaT, None], [False, False, False]),
  189:         ],
  190:     )
  191:     def test_isin_masked_types(self, dtype, data, values, expected):
  192:         # GH#42405
  193:         ser = Series(data, dtype=dtype)
  194: 
  195:         result = ser.isin(values)
  196:         expected = Series(expected, dtype="boolean")
  197: 
  198:         tm.assert_series_equal(result, expected)
  199: 
  200: 
  201: def test_isin_large_series_mixed_dtypes_and_nan(monkeypatch):
  202:     # https://github.com/pandas-dev/pandas/issues/37094
  203:     # combination of object dtype for the values
  204:     # and > _MINIMUM_COMP_ARR_LEN elements
  205:     min_isin_comp = 5
  206:     ser = Series([1, 2, np.nan] * min_isin_comp)
  207:     with monkeypatch.context() as m:
  208:         m.setattr(algorithms, "_MINIMUM_COMP_ARR_LEN", min_isin_comp)
  209:         result = ser.isin({"foo", "bar"})
  210:     expected = Series([False] * 3 * min_isin_comp)
  211:     tm.assert_series_equal(result, expected)
  212: 
  213: 
  214: @pytest.mark.parametrize(
  215:     "array,expected",
  216:     [
  217:         (
  218:             [0, 1j, 1j, 1, 1 + 1j, 1 + 2j, 1 + 1j],
  219:             Series([False, True, True, False, True, True, True], dtype=bool),
  220:         )
  221:     ],
  222: )
  223: def test_isin_complex_numbers(array, expected):
  224:     # GH 17927
  225:     result = Series(array).isin([1j, 1 + 1j, 1 + 2j])
  226:     tm.assert_series_equal(result, expected)
  227: 
  228: 
  229: @pytest.mark.parametrize(
  230:     "data,is_in",
  231:     [([1, [2]], [1]), (["simple str", [{"values": 3}]], ["simple str"])],
  232: )
  233: def test_isin_filtering_with_mixed_object_types(data, is_in):
  234:     # GH 20883
  235: 
  236:     ser = Series(data)
  237:     result = ser.isin(is_in)
  238:     expected = Series([True, False])
  239: 
  240:     tm.assert_series_equal(result, expected)
  241: 
  242: 
  243: @pytest.mark.parametrize("data", [[1, 2, 3], [1.0, 2.0, 3.0]])
  244: @pytest.mark.parametrize("isin", [[1, 2], [1.0, 2.0]])
  245: def test_isin_filtering_on_iterable(data, isin):
  246:     # GH 50234
  247: 
  248:     ser = Series(data)
  249:     result = ser.isin(i for i in isin)
  250:     expected_result = Series([True, True, False])
  251: 
  252:     tm.assert_series_equal(result, expected_result)
