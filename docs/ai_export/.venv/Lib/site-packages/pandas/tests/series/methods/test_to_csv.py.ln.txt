    1: from datetime import datetime
    2: from io import StringIO
    3: 
    4: import numpy as np
    5: import pytest
    6: 
    7: import pandas as pd
    8: from pandas import Series
    9: import pandas._testing as tm
   10: 
   11: from pandas.io.common import get_handle
   12: 
   13: 
   14: class TestSeriesToCSV:
   15:     def read_csv(self, path, **kwargs):
   16:         params = {"index_col": 0, "header": None}
   17:         params.update(**kwargs)
   18: 
   19:         header = params.get("header")
   20:         out = pd.read_csv(path, **params).squeeze("columns")
   21: 
   22:         if header is None:
   23:             out.name = out.index.name = None
   24: 
   25:         return out
   26: 
   27:     def test_from_csv(self, datetime_series, string_series):
   28:         # freq doesn't round-trip
   29:         datetime_series.index = datetime_series.index._with_freq(None)
   30: 
   31:         with tm.ensure_clean() as path:
   32:             datetime_series.to_csv(path, header=False)
   33:             ts = self.read_csv(path, parse_dates=True)
   34:             tm.assert_series_equal(datetime_series, ts, check_names=False)
   35: 
   36:             assert ts.name is None
   37:             assert ts.index.name is None
   38: 
   39:             # see gh-10483
   40:             datetime_series.to_csv(path, header=True)
   41:             ts_h = self.read_csv(path, header=0)
   42:             assert ts_h.name == "ts"
   43: 
   44:             string_series.to_csv(path, header=False)
   45:             series = self.read_csv(path)
   46:             tm.assert_series_equal(string_series, series, check_names=False)
   47: 
   48:             assert series.name is None
   49:             assert series.index.name is None
   50: 
   51:             string_series.to_csv(path, header=True)
   52:             series_h = self.read_csv(path, header=0)
   53:             assert series_h.name == "series"
   54: 
   55:             with open(path, "w", encoding="utf-8") as outfile:
   56:                 outfile.write("1998-01-01|1.0\n1999-01-01|2.0")
   57: 
   58:             series = self.read_csv(path, sep="|", parse_dates=True)
   59:             check_series = Series(
   60:                 {datetime(1998, 1, 1): 1.0, datetime(1999, 1, 1): 2.0}
   61:             )
   62:             tm.assert_series_equal(check_series, series)
   63: 
   64:             series = self.read_csv(path, sep="|", parse_dates=False)
   65:             check_series = Series({"1998-01-01": 1.0, "1999-01-01": 2.0})
   66:             tm.assert_series_equal(check_series, series)
   67: 
   68:     def test_to_csv(self, datetime_series):
   69:         with tm.ensure_clean() as path:
   70:             datetime_series.to_csv(path, header=False)
   71: 
   72:             with open(path, newline=None, encoding="utf-8") as f:
   73:                 lines = f.readlines()
   74:             assert lines[1] != "\n"
   75: 
   76:             datetime_series.to_csv(path, index=False, header=False)
   77:             arr = np.loadtxt(path)
   78:             tm.assert_almost_equal(arr, datetime_series.values)
   79: 
   80:     def test_to_csv_unicode_index(self):
   81:         buf = StringIO()
   82:         s = Series(["\u05d0", "d2"], index=["\u05d0", "\u05d1"])
   83: 
   84:         s.to_csv(buf, encoding="UTF-8", header=False)
   85:         buf.seek(0)
   86: 
   87:         s2 = self.read_csv(buf, index_col=0, encoding="UTF-8")
   88:         tm.assert_series_equal(s, s2)
   89: 
   90:     def test_to_csv_float_format(self):
   91:         with tm.ensure_clean() as filename:
   92:             ser = Series([0.123456, 0.234567, 0.567567])
   93:             ser.to_csv(filename, float_format="%.2f", header=False)
   94: 
   95:             rs = self.read_csv(filename)
   96:             xp = Series([0.12, 0.23, 0.57])
   97:             tm.assert_series_equal(rs, xp)
   98: 
   99:     def test_to_csv_list_entries(self):
  100:         s = Series(["jack and jill", "jesse and frank"])
  101: 
  102:         split = s.str.split(r"\s+and\s+")
  103: 
  104:         buf = StringIO()
  105:         split.to_csv(buf, header=False)
  106: 
  107:     def test_to_csv_path_is_none(self):
  108:         # GH 8215
  109:         # Series.to_csv() was returning None, inconsistent with
  110:         # DataFrame.to_csv() which returned string
  111:         s = Series([1, 2, 3])
  112:         csv_str = s.to_csv(path_or_buf=None, header=False)
  113:         assert isinstance(csv_str, str)
  114: 
  115:     @pytest.mark.parametrize(
  116:         "s,encoding",
  117:         [
  118:             (
  119:                 Series([0.123456, 0.234567, 0.567567], index=["A", "B", "C"], name="X"),
  120:                 None,
  121:             ),
  122:             # GH 21241, 21118
  123:             (Series(["abc", "def", "ghi"], name="X"), "ascii"),
  124:             (Series(["123", "дЅ еҐЅ", "дё–з•Њ"], name="дё­ж–‡"), "gb2312"),
  125:             (
  126:                 Series(["123", "О“ОµО№О¬ ПѓОїП…", "ОљПЊПѓОјОµ"], name="О•О»О»О·ОЅО№ОєО¬"),  # noqa: RUF001
  127:                 "cp737",
  128:             ),
  129:         ],
  130:     )
  131:     def test_to_csv_compression(self, s, encoding, compression):
  132:         with tm.ensure_clean() as filename:
  133:             s.to_csv(filename, compression=compression, encoding=encoding, header=True)
  134:             # test the round trip - to_csv -> read_csv
  135:             result = pd.read_csv(
  136:                 filename,
  137:                 compression=compression,
  138:                 encoding=encoding,
  139:                 index_col=0,
  140:             ).squeeze("columns")
  141:             tm.assert_series_equal(s, result)
  142: 
  143:             # test the round trip using file handle - to_csv -> read_csv
  144:             with get_handle(
  145:                 filename, "w", compression=compression, encoding=encoding
  146:             ) as handles:
  147:                 s.to_csv(handles.handle, encoding=encoding, header=True)
  148: 
  149:             result = pd.read_csv(
  150:                 filename,
  151:                 compression=compression,
  152:                 encoding=encoding,
  153:                 index_col=0,
  154:             ).squeeze("columns")
  155:             tm.assert_series_equal(s, result)
  156: 
  157:             # explicitly ensure file was compressed
  158:             with tm.decompress_file(filename, compression) as fh:
  159:                 text = fh.read().decode(encoding or "utf8")
  160:                 assert s.name in text
  161: 
  162:             with tm.decompress_file(filename, compression) as fh:
  163:                 tm.assert_series_equal(
  164:                     s,
  165:                     pd.read_csv(fh, index_col=0, encoding=encoding).squeeze("columns"),
  166:                 )
  167: 
  168:     def test_to_csv_interval_index(self, using_infer_string):
  169:         # GH 28210
  170:         s = Series(["foo", "bar", "baz"], index=pd.interval_range(0, 3))
  171: 
  172:         with tm.ensure_clean("__tmp_to_csv_interval_index__.csv") as path:
  173:             s.to_csv(path, header=False)
  174:             result = self.read_csv(path, index_col=0)
  175: 
  176:             # can't roundtrip intervalindex via read_csv so check string repr (GH 23595)
  177:             expected = s.copy()
  178:             if using_infer_string:
  179:                 expected.index = expected.index.astype("string[pyarrow_numpy]")
  180:             else:
  181:                 expected.index = expected.index.astype(str)
  182:             tm.assert_series_equal(result, expected)
