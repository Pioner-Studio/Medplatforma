    1: from datetime import datetime
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: import pandas as pd
    7: from pandas import (
    8:     Series,
    9:     Timestamp,
   10:     isna,
   11:     notna,
   12: )
   13: import pandas._testing as tm
   14: 
   15: 
   16: class TestSeriesClip:
   17:     def test_clip(self, datetime_series):
   18:         val = datetime_series.median()
   19: 
   20:         assert datetime_series.clip(lower=val).min() == val
   21:         assert datetime_series.clip(upper=val).max() == val
   22: 
   23:         result = datetime_series.clip(-0.5, 0.5)
   24:         expected = np.clip(datetime_series, -0.5, 0.5)
   25:         tm.assert_series_equal(result, expected)
   26:         assert isinstance(expected, Series)
   27: 
   28:     def test_clip_types_and_nulls(self):
   29:         sers = [
   30:             Series([np.nan, 1.0, 2.0, 3.0]),
   31:             Series([None, "a", "b", "c"]),
   32:             Series(pd.to_datetime([np.nan, 1, 2, 3], unit="D")),
   33:         ]
   34: 
   35:         for s in sers:
   36:             thresh = s[2]
   37:             lower = s.clip(lower=thresh)
   38:             upper = s.clip(upper=thresh)
   39:             assert lower[notna(lower)].min() == thresh
   40:             assert upper[notna(upper)].max() == thresh
   41:             assert list(isna(s)) == list(isna(lower))
   42:             assert list(isna(s)) == list(isna(upper))
   43: 
   44:     def test_series_clipping_with_na_values(self, any_numeric_ea_dtype, nulls_fixture):
   45:         # Ensure that clipping method can handle NA values with out failing
   46:         # GH#40581
   47: 
   48:         if nulls_fixture is pd.NaT:
   49:             # constructor will raise, see
   50:             #  test_constructor_mismatched_null_nullable_dtype
   51:             pytest.skip("See test_constructor_mismatched_null_nullable_dtype")
   52: 
   53:         ser = Series([nulls_fixture, 1.0, 3.0], dtype=any_numeric_ea_dtype)
   54:         s_clipped_upper = ser.clip(upper=2.0)
   55:         s_clipped_lower = ser.clip(lower=2.0)
   56: 
   57:         expected_upper = Series([nulls_fixture, 1.0, 2.0], dtype=any_numeric_ea_dtype)
   58:         expected_lower = Series([nulls_fixture, 2.0, 3.0], dtype=any_numeric_ea_dtype)
   59: 
   60:         tm.assert_series_equal(s_clipped_upper, expected_upper)
   61:         tm.assert_series_equal(s_clipped_lower, expected_lower)
   62: 
   63:     def test_clip_with_na_args(self):
   64:         """Should process np.nan argument as None"""
   65:         # GH#17276
   66:         s = Series([1, 2, 3])
   67: 
   68:         tm.assert_series_equal(s.clip(np.nan), Series([1, 2, 3]))
   69:         tm.assert_series_equal(s.clip(upper=np.nan, lower=np.nan), Series([1, 2, 3]))
   70: 
   71:         # GH#19992
   72:         msg = "Downcasting behavior in Series and DataFrame methods 'where'"
   73:         # TODO: avoid this warning here?  seems like we should never be upcasting
   74:         #  in the first place?
   75:         with tm.assert_produces_warning(FutureWarning, match=msg):
   76:             res = s.clip(lower=[0, 4, np.nan])
   77:         tm.assert_series_equal(res, Series([1, 4, 3]))
   78:         with tm.assert_produces_warning(FutureWarning, match=msg):
   79:             res = s.clip(upper=[1, np.nan, 1])
   80:         tm.assert_series_equal(res, Series([1, 2, 1]))
   81: 
   82:         # GH#40420
   83:         s = Series([1, 2, 3])
   84:         result = s.clip(0, [np.nan, np.nan, np.nan])
   85:         tm.assert_series_equal(s, result)
   86: 
   87:     def test_clip_against_series(self):
   88:         # GH#6966
   89: 
   90:         s = Series([1.0, 1.0, 4.0])
   91: 
   92:         lower = Series([1.0, 2.0, 3.0])
   93:         upper = Series([1.5, 2.5, 3.5])
   94: 
   95:         tm.assert_series_equal(s.clip(lower, upper), Series([1.0, 2.0, 3.5]))
   96:         tm.assert_series_equal(s.clip(1.5, upper), Series([1.5, 1.5, 3.5]))
   97: 
   98:     @pytest.mark.parametrize("inplace", [True, False])
   99:     @pytest.mark.parametrize("upper", [[1, 2, 3], np.asarray([1, 2, 3])])
  100:     def test_clip_against_list_like(self, inplace, upper):
  101:         # GH#15390
  102:         original = Series([5, 6, 7])
  103:         result = original.clip(upper=upper, inplace=inplace)
  104:         expected = Series([1, 2, 3])
  105: 
  106:         if inplace:
  107:             result = original
  108:         tm.assert_series_equal(result, expected, check_exact=True)
  109: 
  110:     def test_clip_with_datetimes(self):
  111:         # GH#11838
  112:         # naive and tz-aware datetimes
  113: 
  114:         t = Timestamp("2015-12-01 09:30:30")
  115:         s = Series([Timestamp("2015-12-01 09:30:00"), Timestamp("2015-12-01 09:31:00")])
  116:         result = s.clip(upper=t)
  117:         expected = Series(
  118:             [Timestamp("2015-12-01 09:30:00"), Timestamp("2015-12-01 09:30:30")]
  119:         )
  120:         tm.assert_series_equal(result, expected)
  121: 
  122:         t = Timestamp("2015-12-01 09:30:30", tz="US/Eastern")
  123:         s = Series(
  124:             [
  125:                 Timestamp("2015-12-01 09:30:00", tz="US/Eastern"),
  126:                 Timestamp("2015-12-01 09:31:00", tz="US/Eastern"),
  127:             ]
  128:         )
  129:         result = s.clip(upper=t)
  130:         expected = Series(
  131:             [
  132:                 Timestamp("2015-12-01 09:30:00", tz="US/Eastern"),
  133:                 Timestamp("2015-12-01 09:30:30", tz="US/Eastern"),
  134:             ]
  135:         )
  136:         tm.assert_series_equal(result, expected)
  137: 
  138:     @pytest.mark.parametrize("dtype", [object, "M8[us]"])
  139:     def test_clip_with_timestamps_and_oob_datetimes(self, dtype):
  140:         # GH-42794
  141:         ser = Series([datetime(1, 1, 1), datetime(9999, 9, 9)], dtype=dtype)
  142: 
  143:         result = ser.clip(lower=Timestamp.min, upper=Timestamp.max)
  144:         expected = Series([Timestamp.min, Timestamp.max], dtype=dtype)
  145: 
  146:         tm.assert_series_equal(result, expected)
