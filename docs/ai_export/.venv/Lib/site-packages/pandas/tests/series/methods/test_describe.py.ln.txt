    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas.compat.numpy import np_version_gte1p25
    5: 
    6: from pandas.core.dtypes.common import (
    7:     is_complex_dtype,
    8:     is_extension_array_dtype,
    9: )
   10: 
   11: from pandas import (
   12:     NA,
   13:     Period,
   14:     Series,
   15:     Timedelta,
   16:     Timestamp,
   17:     date_range,
   18: )
   19: import pandas._testing as tm
   20: 
   21: 
   22: class TestSeriesDescribe:
   23:     def test_describe_ints(self):
   24:         ser = Series([0, 1, 2, 3, 4], name="int_data")
   25:         result = ser.describe()
   26:         expected = Series(
   27:             [5, 2, ser.std(), 0, 1, 2, 3, 4],
   28:             name="int_data",
   29:             index=["count", "mean", "std", "min", "25%", "50%", "75%", "max"],
   30:         )
   31:         tm.assert_series_equal(result, expected)
   32: 
   33:     def test_describe_bools(self):
   34:         ser = Series([True, True, False, False, False], name="bool_data")
   35:         result = ser.describe()
   36:         expected = Series(
   37:             [5, 2, False, 3], name="bool_data", index=["count", "unique", "top", "freq"]
   38:         )
   39:         tm.assert_series_equal(result, expected)
   40: 
   41:     def test_describe_strs(self):
   42:         ser = Series(["a", "a", "b", "c", "d"], name="str_data")
   43:         result = ser.describe()
   44:         expected = Series(
   45:             [5, 4, "a", 2], name="str_data", index=["count", "unique", "top", "freq"]
   46:         )
   47:         tm.assert_series_equal(result, expected)
   48: 
   49:     def test_describe_timedelta64(self):
   50:         ser = Series(
   51:             [
   52:                 Timedelta("1 days"),
   53:                 Timedelta("2 days"),
   54:                 Timedelta("3 days"),
   55:                 Timedelta("4 days"),
   56:                 Timedelta("5 days"),
   57:             ],
   58:             name="timedelta_data",
   59:         )
   60:         result = ser.describe()
   61:         expected = Series(
   62:             [5, ser[2], ser.std(), ser[0], ser[1], ser[2], ser[3], ser[4]],
   63:             name="timedelta_data",
   64:             index=["count", "mean", "std", "min", "25%", "50%", "75%", "max"],
   65:         )
   66:         tm.assert_series_equal(result, expected)
   67: 
   68:     def test_describe_period(self):
   69:         ser = Series(
   70:             [Period("2020-01", "M"), Period("2020-01", "M"), Period("2019-12", "M")],
   71:             name="period_data",
   72:         )
   73:         result = ser.describe()
   74:         expected = Series(
   75:             [3, 2, ser[0], 2],
   76:             name="period_data",
   77:             index=["count", "unique", "top", "freq"],
   78:         )
   79:         tm.assert_series_equal(result, expected)
   80: 
   81:     def test_describe_empty_object(self):
   82:         # https://github.com/pandas-dev/pandas/issues/27183
   83:         s = Series([None, None], dtype=object)
   84:         result = s.describe()
   85:         expected = Series(
   86:             [0, 0, np.nan, np.nan],
   87:             dtype=object,
   88:             index=["count", "unique", "top", "freq"],
   89:         )
   90:         tm.assert_series_equal(result, expected)
   91: 
   92:         result = s[:0].describe()
   93:         tm.assert_series_equal(result, expected)
   94:         # ensure NaN, not None
   95:         assert np.isnan(result.iloc[2])
   96:         assert np.isnan(result.iloc[3])
   97: 
   98:     def test_describe_with_tz(self, tz_naive_fixture):
   99:         # GH 21332
  100:         tz = tz_naive_fixture
  101:         name = str(tz_naive_fixture)
  102:         start = Timestamp(2018, 1, 1)
  103:         end = Timestamp(2018, 1, 5)
  104:         s = Series(date_range(start, end, tz=tz), name=name)
  105:         result = s.describe()
  106:         expected = Series(
  107:             [
  108:                 5,
  109:                 Timestamp(2018, 1, 3).tz_localize(tz),
  110:                 start.tz_localize(tz),
  111:                 s[1],
  112:                 s[2],
  113:                 s[3],
  114:                 end.tz_localize(tz),
  115:             ],
  116:             name=name,
  117:             index=["count", "mean", "min", "25%", "50%", "75%", "max"],
  118:         )
  119:         tm.assert_series_equal(result, expected)
  120: 
  121:     def test_describe_with_tz_numeric(self):
  122:         name = tz = "CET"
  123:         start = Timestamp(2018, 1, 1)
  124:         end = Timestamp(2018, 1, 5)
  125:         s = Series(date_range(start, end, tz=tz), name=name)
  126: 
  127:         result = s.describe()
  128: 
  129:         expected = Series(
  130:             [
  131:                 5,
  132:                 Timestamp("2018-01-03 00:00:00", tz=tz),
  133:                 Timestamp("2018-01-01 00:00:00", tz=tz),
  134:                 Timestamp("2018-01-02 00:00:00", tz=tz),
  135:                 Timestamp("2018-01-03 00:00:00", tz=tz),
  136:                 Timestamp("2018-01-04 00:00:00", tz=tz),
  137:                 Timestamp("2018-01-05 00:00:00", tz=tz),
  138:             ],
  139:             name=name,
  140:             index=["count", "mean", "min", "25%", "50%", "75%", "max"],
  141:         )
  142:         tm.assert_series_equal(result, expected)
  143: 
  144:     def test_datetime_is_numeric_includes_datetime(self):
  145:         s = Series(date_range("2012", periods=3))
  146:         result = s.describe()
  147:         expected = Series(
  148:             [
  149:                 3,
  150:                 Timestamp("2012-01-02"),
  151:                 Timestamp("2012-01-01"),
  152:                 Timestamp("2012-01-01T12:00:00"),
  153:                 Timestamp("2012-01-02"),
  154:                 Timestamp("2012-01-02T12:00:00"),
  155:                 Timestamp("2012-01-03"),
  156:             ],
  157:             index=["count", "mean", "min", "25%", "50%", "75%", "max"],
  158:         )
  159:         tm.assert_series_equal(result, expected)
  160: 
  161:     @pytest.mark.filterwarnings("ignore:Casting complex values to real discards")
  162:     def test_numeric_result_dtype(self, any_numeric_dtype):
  163:         # GH#48340 - describe should always return float on non-complex numeric input
  164:         if is_extension_array_dtype(any_numeric_dtype):
  165:             dtype = "Float64"
  166:         else:
  167:             dtype = "complex128" if is_complex_dtype(any_numeric_dtype) else None
  168: 
  169:         ser = Series([0, 1], dtype=any_numeric_dtype)
  170:         if dtype == "complex128" and np_version_gte1p25:
  171:             with pytest.raises(
  172:                 TypeError, match=r"^a must be an array of real numbers$"
  173:             ):
  174:                 ser.describe()
  175:             return
  176:         result = ser.describe()
  177:         expected = Series(
  178:             [
  179:                 2.0,
  180:                 0.5,
  181:                 ser.std(),
  182:                 0,
  183:                 0.25,
  184:                 0.5,
  185:                 0.75,
  186:                 1.0,
  187:             ],
  188:             index=["count", "mean", "std", "min", "25%", "50%", "75%", "max"],
  189:             dtype=dtype,
  190:         )
  191:         tm.assert_series_equal(result, expected)
  192: 
  193:     def test_describe_one_element_ea(self):
  194:         # GH#52515
  195:         ser = Series([0.0], dtype="Float64")
  196:         with tm.assert_produces_warning(None):
  197:             result = ser.describe()
  198:         expected = Series(
  199:             [1, 0, NA, 0, 0, 0, 0, 0],
  200:             dtype="Float64",
  201:             index=["count", "mean", "std", "min", "25%", "50%", "75%", "max"],
  202:         )
  203:         tm.assert_series_equal(result, expected)
