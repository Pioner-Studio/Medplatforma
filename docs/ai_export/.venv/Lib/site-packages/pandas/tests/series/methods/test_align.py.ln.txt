    1: from datetime import timezone
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: import pandas as pd
    7: from pandas import (
    8:     Series,
    9:     date_range,
   10:     period_range,
   11: )
   12: import pandas._testing as tm
   13: 
   14: 
   15: @pytest.mark.parametrize(
   16:     "first_slice,second_slice",
   17:     [
   18:         [[2, None], [None, -5]],
   19:         [[None, 0], [None, -5]],
   20:         [[None, -5], [None, 0]],
   21:         [[None, 0], [None, 0]],
   22:     ],
   23: )
   24: @pytest.mark.parametrize("fill", [None, -1])
   25: def test_align(datetime_series, first_slice, second_slice, join_type, fill):
   26:     a = datetime_series[slice(*first_slice)]
   27:     b = datetime_series[slice(*second_slice)]
   28: 
   29:     aa, ab = a.align(b, join=join_type, fill_value=fill)
   30: 
   31:     join_index = a.index.join(b.index, how=join_type)
   32:     if fill is not None:
   33:         diff_a = aa.index.difference(join_index)
   34:         diff_b = ab.index.difference(join_index)
   35:         if len(diff_a) > 0:
   36:             assert (aa.reindex(diff_a) == fill).all()
   37:         if len(diff_b) > 0:
   38:             assert (ab.reindex(diff_b) == fill).all()
   39: 
   40:     ea = a.reindex(join_index)
   41:     eb = b.reindex(join_index)
   42: 
   43:     if fill is not None:
   44:         ea = ea.fillna(fill)
   45:         eb = eb.fillna(fill)
   46: 
   47:     tm.assert_series_equal(aa, ea)
   48:     tm.assert_series_equal(ab, eb)
   49:     assert aa.name == "ts"
   50:     assert ea.name == "ts"
   51:     assert ab.name == "ts"
   52:     assert eb.name == "ts"
   53: 
   54: 
   55: @pytest.mark.parametrize(
   56:     "first_slice,second_slice",
   57:     [
   58:         [[2, None], [None, -5]],
   59:         [[None, 0], [None, -5]],
   60:         [[None, -5], [None, 0]],
   61:         [[None, 0], [None, 0]],
   62:     ],
   63: )
   64: @pytest.mark.parametrize("method", ["pad", "bfill"])
   65: @pytest.mark.parametrize("limit", [None, 1])
   66: def test_align_fill_method(
   67:     datetime_series, first_slice, second_slice, join_type, method, limit
   68: ):
   69:     a = datetime_series[slice(*first_slice)]
   70:     b = datetime_series[slice(*second_slice)]
   71: 
   72:     msg = (
   73:         "The 'method', 'limit', and 'fill_axis' keywords in Series.align "
   74:         "are deprecated"
   75:     )
   76:     with tm.assert_produces_warning(FutureWarning, match=msg):
   77:         aa, ab = a.align(b, join=join_type, method=method, limit=limit)
   78: 
   79:     join_index = a.index.join(b.index, how=join_type)
   80:     ea = a.reindex(join_index)
   81:     eb = b.reindex(join_index)
   82: 
   83:     msg2 = "Series.fillna with 'method' is deprecated"
   84:     with tm.assert_produces_warning(FutureWarning, match=msg2):
   85:         ea = ea.fillna(method=method, limit=limit)
   86:         eb = eb.fillna(method=method, limit=limit)
   87: 
   88:     tm.assert_series_equal(aa, ea)
   89:     tm.assert_series_equal(ab, eb)
   90: 
   91: 
   92: def test_align_nocopy(datetime_series, using_copy_on_write):
   93:     b = datetime_series[:5].copy()
   94: 
   95:     # do copy
   96:     a = datetime_series.copy()
   97:     ra, _ = a.align(b, join="left")
   98:     ra[:5] = 5
   99:     assert not (a[:5] == 5).any()
  100: 
  101:     # do not copy
  102:     a = datetime_series.copy()
  103:     ra, _ = a.align(b, join="left", copy=False)
  104:     ra[:5] = 5
  105:     if using_copy_on_write:
  106:         assert not (a[:5] == 5).any()
  107:     else:
  108:         assert (a[:5] == 5).all()
  109: 
  110:     # do copy
  111:     a = datetime_series.copy()
  112:     b = datetime_series[:5].copy()
  113:     _, rb = a.align(b, join="right")
  114:     rb[:3] = 5
  115:     assert not (b[:3] == 5).any()
  116: 
  117:     # do not copy
  118:     a = datetime_series.copy()
  119:     b = datetime_series[:5].copy()
  120:     _, rb = a.align(b, join="right", copy=False)
  121:     rb[:2] = 5
  122:     if using_copy_on_write:
  123:         assert not (b[:2] == 5).any()
  124:     else:
  125:         assert (b[:2] == 5).all()
  126: 
  127: 
  128: def test_align_same_index(datetime_series, using_copy_on_write):
  129:     a, b = datetime_series.align(datetime_series, copy=False)
  130:     if not using_copy_on_write:
  131:         assert a.index is datetime_series.index
  132:         assert b.index is datetime_series.index
  133:     else:
  134:         assert a.index.is_(datetime_series.index)
  135:         assert b.index.is_(datetime_series.index)
  136: 
  137:     a, b = datetime_series.align(datetime_series, copy=True)
  138:     assert a.index is not datetime_series.index
  139:     assert b.index is not datetime_series.index
  140:     assert a.index.is_(datetime_series.index)
  141:     assert b.index.is_(datetime_series.index)
  142: 
  143: 
  144: def test_align_multiindex():
  145:     # GH 10665
  146: 
  147:     midx = pd.MultiIndex.from_product(
  148:         [range(2), range(3), range(2)], names=("a", "b", "c")
  149:     )
  150:     idx = pd.Index(range(2), name="b")
  151:     s1 = Series(np.arange(12, dtype="int64"), index=midx)
  152:     s2 = Series(np.arange(2, dtype="int64"), index=idx)
  153: 
  154:     # these must be the same results (but flipped)
  155:     res1l, res1r = s1.align(s2, join="left")
  156:     res2l, res2r = s2.align(s1, join="right")
  157: 
  158:     expl = s1
  159:     tm.assert_series_equal(expl, res1l)
  160:     tm.assert_series_equal(expl, res2r)
  161:     expr = Series([0, 0, 1, 1, np.nan, np.nan] * 2, index=midx)
  162:     tm.assert_series_equal(expr, res1r)
  163:     tm.assert_series_equal(expr, res2l)
  164: 
  165:     res1l, res1r = s1.align(s2, join="right")
  166:     res2l, res2r = s2.align(s1, join="left")
  167: 
  168:     exp_idx = pd.MultiIndex.from_product(
  169:         [range(2), range(2), range(2)], names=("a", "b", "c")
  170:     )
  171:     expl = Series([0, 1, 2, 3, 6, 7, 8, 9], index=exp_idx)
  172:     tm.assert_series_equal(expl, res1l)
  173:     tm.assert_series_equal(expl, res2r)
  174:     expr = Series([0, 0, 1, 1] * 2, index=exp_idx)
  175:     tm.assert_series_equal(expr, res1r)
  176:     tm.assert_series_equal(expr, res2l)
  177: 
  178: 
  179: @pytest.mark.parametrize("method", ["backfill", "bfill", "pad", "ffill", None])
  180: def test_align_with_dataframe_method(method):
  181:     # GH31788
  182:     ser = Series(range(3), index=range(3))
  183:     df = pd.DataFrame(0.0, index=range(3), columns=range(3))
  184: 
  185:     msg = (
  186:         "The 'method', 'limit', and 'fill_axis' keywords in Series.align "
  187:         "are deprecated"
  188:     )
  189:     with tm.assert_produces_warning(FutureWarning, match=msg):
  190:         result_ser, result_df = ser.align(df, method=method)
  191:     tm.assert_series_equal(result_ser, ser)
  192:     tm.assert_frame_equal(result_df, df)
  193: 
  194: 
  195: def test_align_dt64tzindex_mismatched_tzs():
  196:     idx1 = date_range("2001", periods=5, freq="h", tz="US/Eastern")
  197:     ser = Series(np.random.default_rng(2).standard_normal(len(idx1)), index=idx1)
  198:     ser_central = ser.tz_convert("US/Central")
  199:     # different timezones convert to UTC
  200: 
  201:     new1, new2 = ser.align(ser_central)
  202:     assert new1.index.tz is timezone.utc
  203:     assert new2.index.tz is timezone.utc
  204: 
  205: 
  206: def test_align_periodindex(join_type):
  207:     rng = period_range("1/1/2000", "1/1/2010", freq="Y")
  208:     ts = Series(np.random.default_rng(2).standard_normal(len(rng)), index=rng)
  209: 
  210:     # TODO: assert something?
  211:     ts.align(ts[::2], join=join_type)
  212: 
  213: 
  214: def test_align_left_fewer_levels():
  215:     # GH#45224
  216:     left = Series([2], index=pd.MultiIndex.from_tuples([(1, 3)], names=["a", "c"]))
  217:     right = Series(
  218:         [1], index=pd.MultiIndex.from_tuples([(1, 2, 3)], names=["a", "b", "c"])
  219:     )
  220:     result_left, result_right = left.align(right)
  221: 
  222:     expected_right = Series(
  223:         [1], index=pd.MultiIndex.from_tuples([(1, 3, 2)], names=["a", "c", "b"])
  224:     )
  225:     expected_left = Series(
  226:         [2], index=pd.MultiIndex.from_tuples([(1, 3, 2)], names=["a", "c", "b"])
  227:     )
  228:     tm.assert_series_equal(result_left, expected_left)
  229:     tm.assert_series_equal(result_right, expected_right)
  230: 
  231: 
  232: def test_align_left_different_named_levels():
  233:     # GH#45224
  234:     left = Series(
  235:         [2], index=pd.MultiIndex.from_tuples([(1, 4, 3)], names=["a", "d", "c"])
  236:     )
  237:     right = Series(
  238:         [1], index=pd.MultiIndex.from_tuples([(1, 2, 3)], names=["a", "b", "c"])
  239:     )
  240:     result_left, result_right = left.align(right)
  241: 
  242:     expected_left = Series(
  243:         [2], index=pd.MultiIndex.from_tuples([(1, 4, 3, 2)], names=["a", "d", "c", "b"])
  244:     )
  245:     expected_right = Series(
  246:         [1], index=pd.MultiIndex.from_tuples([(1, 4, 3, 2)], names=["a", "d", "c", "b"])
  247:     )
  248:     tm.assert_series_equal(result_left, expected_left)
  249:     tm.assert_series_equal(result_right, expected_right)
