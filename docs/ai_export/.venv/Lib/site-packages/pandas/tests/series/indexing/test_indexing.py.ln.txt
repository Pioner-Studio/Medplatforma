    1: """ test get/set & misc """
    2: from datetime import timedelta
    3: import re
    4: 
    5: import numpy as np
    6: import pytest
    7: 
    8: from pandas.errors import IndexingError
    9: 
   10: from pandas import (
   11:     NA,
   12:     DataFrame,
   13:     Index,
   14:     IndexSlice,
   15:     MultiIndex,
   16:     NaT,
   17:     Series,
   18:     Timedelta,
   19:     Timestamp,
   20:     concat,
   21:     date_range,
   22:     isna,
   23:     period_range,
   24:     timedelta_range,
   25: )
   26: import pandas._testing as tm
   27: 
   28: 
   29: def test_basic_indexing():
   30:     s = Series(
   31:         np.random.default_rng(2).standard_normal(5), index=["a", "b", "a", "a", "b"]
   32:     )
   33: 
   34:     warn_msg = "Series.__[sg]etitem__ treating keys as positions is deprecated"
   35:     msg = "index 5 is out of bounds for axis 0 with size 5"
   36:     with pytest.raises(IndexError, match=msg):
   37:         with tm.assert_produces_warning(FutureWarning, match=warn_msg):
   38:             s[5]
   39:     with pytest.raises(IndexError, match=msg):
   40:         with tm.assert_produces_warning(FutureWarning, match=warn_msg):
   41:             s[5] = 0
   42: 
   43:     with pytest.raises(KeyError, match=r"^'c'$"):
   44:         s["c"]
   45: 
   46:     s = s.sort_index()
   47: 
   48:     with pytest.raises(IndexError, match=msg):
   49:         with tm.assert_produces_warning(FutureWarning, match=warn_msg):
   50:             s[5]
   51:     msg = r"index 5 is out of bounds for axis (0|1) with size 5|^5$"
   52:     with pytest.raises(IndexError, match=msg):
   53:         with tm.assert_produces_warning(FutureWarning, match=warn_msg):
   54:             s[5] = 0
   55: 
   56: 
   57: def test_getitem_numeric_should_not_fallback_to_positional(any_numeric_dtype):
   58:     # GH51053
   59:     dtype = any_numeric_dtype
   60:     idx = Index([1, 0, 1], dtype=dtype)
   61:     ser = Series(range(3), index=idx)
   62:     result = ser[1]
   63:     expected = Series([0, 2], index=Index([1, 1], dtype=dtype))
   64:     tm.assert_series_equal(result, expected, check_exact=True)
   65: 
   66: 
   67: def test_setitem_numeric_should_not_fallback_to_positional(any_numeric_dtype):
   68:     # GH51053
   69:     dtype = any_numeric_dtype
   70:     idx = Index([1, 0, 1], dtype=dtype)
   71:     ser = Series(range(3), index=idx)
   72:     ser[1] = 10
   73:     expected = Series([10, 1, 10], index=idx)
   74:     tm.assert_series_equal(ser, expected, check_exact=True)
   75: 
   76: 
   77: def test_basic_getitem_with_labels(datetime_series):
   78:     indices = datetime_series.index[[5, 10, 15]]
   79: 
   80:     result = datetime_series[indices]
   81:     expected = datetime_series.reindex(indices)
   82:     tm.assert_series_equal(result, expected)
   83: 
   84:     result = datetime_series[indices[0] : indices[2]]
   85:     expected = datetime_series.loc[indices[0] : indices[2]]
   86:     tm.assert_series_equal(result, expected)
   87: 
   88: 
   89: def test_basic_getitem_dt64tz_values():
   90:     # GH12089
   91:     # with tz for values
   92:     ser = Series(
   93:         date_range("2011-01-01", periods=3, tz="US/Eastern"), index=["a", "b", "c"]
   94:     )
   95:     expected = Timestamp("2011-01-01", tz="US/Eastern")
   96:     result = ser.loc["a"]
   97:     assert result == expected
   98:     result = ser.iloc[0]
   99:     assert result == expected
  100:     result = ser["a"]
  101:     assert result == expected
  102: 
  103: 
  104: def test_getitem_setitem_ellipsis(using_copy_on_write, warn_copy_on_write):
  105:     s = Series(np.random.default_rng(2).standard_normal(10))
  106: 
  107:     result = s[...]
  108:     tm.assert_series_equal(result, s)
  109: 
  110:     with tm.assert_cow_warning(warn_copy_on_write):
  111:         s[...] = 5
  112:     if not using_copy_on_write:
  113:         assert (result == 5).all()
  114: 
  115: 
  116: @pytest.mark.parametrize(
  117:     "result_1, duplicate_item, expected_1",
  118:     [
  119:         [
  120:             Series({1: 12, 2: [1, 2, 2, 3]}),
  121:             Series({1: 313}),
  122:             Series({1: 12}, dtype=object),
  123:         ],
  124:         [
  125:             Series({1: [1, 2, 3], 2: [1, 2, 2, 3]}),
  126:             Series({1: [1, 2, 3]}),
  127:             Series({1: [1, 2, 3]}),
  128:         ],
  129:     ],
  130: )
  131: def test_getitem_with_duplicates_indices(result_1, duplicate_item, expected_1):
  132:     # GH 17610
  133:     result = result_1._append(duplicate_item)
  134:     expected = expected_1._append(duplicate_item)
  135:     tm.assert_series_equal(result[1], expected)
  136:     assert result[2] == result_1[2]
  137: 
  138: 
  139: def test_getitem_setitem_integers():
  140:     # caused bug without test
  141:     s = Series([1, 2, 3], ["a", "b", "c"])
  142: 
  143:     assert s.iloc[0] == s["a"]
  144:     s.iloc[0] = 5
  145:     tm.assert_almost_equal(s["a"], 5)
  146: 
  147: 
  148: def test_series_box_timestamp():
  149:     rng = date_range("20090415", "20090519", freq="B")
  150:     ser = Series(rng)
  151:     assert isinstance(ser[0], Timestamp)
  152:     assert isinstance(ser.at[1], Timestamp)
  153:     assert isinstance(ser.iat[2], Timestamp)
  154:     assert isinstance(ser.loc[3], Timestamp)
  155:     assert isinstance(ser.iloc[4], Timestamp)
  156: 
  157:     ser = Series(rng, index=rng)
  158:     msg = "Series.__getitem__ treating keys as positions is deprecated"
  159:     with tm.assert_produces_warning(FutureWarning, match=msg):
  160:         assert isinstance(ser[0], Timestamp)
  161:     assert isinstance(ser.at[rng[1]], Timestamp)
  162:     assert isinstance(ser.iat[2], Timestamp)
  163:     assert isinstance(ser.loc[rng[3]], Timestamp)
  164:     assert isinstance(ser.iloc[4], Timestamp)
  165: 
  166: 
  167: def test_series_box_timedelta():
  168:     rng = timedelta_range("1 day 1 s", periods=5, freq="h")
  169:     ser = Series(rng)
  170:     assert isinstance(ser[0], Timedelta)
  171:     assert isinstance(ser.at[1], Timedelta)
  172:     assert isinstance(ser.iat[2], Timedelta)
  173:     assert isinstance(ser.loc[3], Timedelta)
  174:     assert isinstance(ser.iloc[4], Timedelta)
  175: 
  176: 
  177: def test_getitem_ambiguous_keyerror(indexer_sl):
  178:     ser = Series(range(10), index=list(range(0, 20, 2)))
  179:     with pytest.raises(KeyError, match=r"^1$"):
  180:         indexer_sl(ser)[1]
  181: 
  182: 
  183: def test_getitem_dups_with_missing(indexer_sl):
  184:     # breaks reindex, so need to use .loc internally
  185:     # GH 4246
  186:     ser = Series([1, 2, 3, 4], ["foo", "bar", "foo", "bah"])
  187:     with pytest.raises(KeyError, match=re.escape("['bam'] not in index")):
  188:         indexer_sl(ser)[["foo", "bar", "bah", "bam"]]
  189: 
  190: 
  191: def test_setitem_ambiguous_keyerror(indexer_sl):
  192:     s = Series(range(10), index=list(range(0, 20, 2)))
  193: 
  194:     # equivalent of an append
  195:     s2 = s.copy()
  196:     indexer_sl(s2)[1] = 5
  197:     expected = concat([s, Series([5], index=[1])])
  198:     tm.assert_series_equal(s2, expected)
  199: 
  200: 
  201: def test_setitem(datetime_series):
  202:     datetime_series[datetime_series.index[5]] = np.nan
  203:     datetime_series.iloc[[1, 2, 17]] = np.nan
  204:     datetime_series.iloc[6] = np.nan
  205:     assert np.isnan(datetime_series.iloc[6])
  206:     assert np.isnan(datetime_series.iloc[2])
  207:     datetime_series[np.isnan(datetime_series)] = 5
  208:     assert not np.isnan(datetime_series.iloc[2])
  209: 
  210: 
  211: def test_setslice(datetime_series):
  212:     sl = datetime_series[5:20]
  213:     assert len(sl) == len(sl.index)
  214:     assert sl.index.is_unique is True
  215: 
  216: 
  217: def test_basic_getitem_setitem_corner(datetime_series):
  218:     # invalid tuples, e.g. td.ts[:, None] vs. td.ts[:, 2]
  219:     msg = "key of type tuple not found and not a MultiIndex"
  220:     with pytest.raises(KeyError, match=msg):
  221:         datetime_series[:, 2]
  222:     with pytest.raises(KeyError, match=msg):
  223:         datetime_series[:, 2] = 2
  224: 
  225:     # weird lists. [slice(0, 5)] raises but not two slices
  226:     msg = "Indexing with a single-item list"
  227:     with pytest.raises(ValueError, match=msg):
  228:         # GH#31299
  229:         datetime_series[[slice(None, 5)]]
  230: 
  231:     # but we're OK with a single-element tuple
  232:     result = datetime_series[(slice(None, 5),)]
  233:     expected = datetime_series[:5]
  234:     tm.assert_series_equal(result, expected)
  235: 
  236:     # OK
  237:     msg = r"unhashable type(: 'slice')?"
  238:     with pytest.raises(TypeError, match=msg):
  239:         datetime_series[[5, [None, None]]]
  240:     with pytest.raises(TypeError, match=msg):
  241:         datetime_series[[5, [None, None]]] = 2
  242: 
  243: 
  244: def test_slice(string_series, object_series, using_copy_on_write, warn_copy_on_write):
  245:     original = string_series.copy()
  246:     numSlice = string_series[10:20]
  247:     numSliceEnd = string_series[-10:]
  248:     objSlice = object_series[10:20]
  249: 
  250:     assert string_series.index[9] not in numSlice.index
  251:     assert object_series.index[9] not in objSlice.index
  252: 
  253:     assert len(numSlice) == len(numSlice.index)
  254:     assert string_series[numSlice.index[0]] == numSlice[numSlice.index[0]]
  255: 
  256:     assert numSlice.index[1] == string_series.index[11]
  257:     tm.assert_numpy_array_equal(np.array(numSliceEnd), np.array(string_series)[-10:])
  258: 
  259:     # Test return view.
  260:     sl = string_series[10:20]
  261:     with tm.assert_cow_warning(warn_copy_on_write):
  262:         sl[:] = 0
  263: 
  264:     if using_copy_on_write:
  265:         # Doesn't modify parent (CoW)
  266:         tm.assert_series_equal(string_series, original)
  267:     else:
  268:         assert (string_series[10:20] == 0).all()
  269: 
  270: 
  271: def test_timedelta_assignment():
  272:     # GH 8209
  273:     s = Series([], dtype=object)
  274:     s.loc["B"] = timedelta(1)
  275:     tm.assert_series_equal(s, Series(Timedelta("1 days"), index=["B"]))
  276: 
  277:     s = s.reindex(s.index.insert(0, "A"))
  278:     tm.assert_series_equal(s, Series([np.nan, Timedelta("1 days")], index=["A", "B"]))
  279: 
  280:     s.loc["A"] = timedelta(1)
  281:     expected = Series(Timedelta("1 days"), index=["A", "B"])
  282:     tm.assert_series_equal(s, expected)
  283: 
  284: 
  285: def test_underlying_data_conversion(using_copy_on_write):
  286:     # GH 4080
  287:     df = DataFrame({c: [1, 2, 3] for c in ["a", "b", "c"]})
  288:     return_value = df.set_index(["a", "b", "c"], inplace=True)
  289:     assert return_value is None
  290:     s = Series([1], index=[(2, 2, 2)])
  291:     df["val"] = 0
  292:     df_original = df.copy()
  293:     df
  294: 
  295:     if using_copy_on_write:
  296:         with tm.raises_chained_assignment_error():
  297:             df["val"].update(s)
  298:         expected = df_original
  299:     else:
  300:         with tm.assert_produces_warning(FutureWarning, match="inplace method"):
  301:             df["val"].update(s)
  302:         expected = DataFrame(
  303:             {"a": [1, 2, 3], "b": [1, 2, 3], "c": [1, 2, 3], "val": [0, 1, 0]}
  304:         )
  305:         return_value = expected.set_index(["a", "b", "c"], inplace=True)
  306:         assert return_value is None
  307:     tm.assert_frame_equal(df, expected)
  308: 
  309: 
  310: def test_preserve_refs(datetime_series):
  311:     seq = datetime_series.iloc[[5, 10, 15]]
  312:     seq.iloc[1] = np.nan
  313:     assert not np.isnan(datetime_series.iloc[10])
  314: 
  315: 
  316: def test_multilevel_preserve_name(lexsorted_two_level_string_multiindex, indexer_sl):
  317:     index = lexsorted_two_level_string_multiindex
  318:     ser = Series(
  319:         np.random.default_rng(2).standard_normal(len(index)), index=index, name="sth"
  320:     )
  321: 
  322:     result = indexer_sl(ser)["foo"]
  323:     assert result.name == ser.name
  324: 
  325: 
  326: # miscellaneous methods
  327: 
  328: 
  329: @pytest.mark.parametrize(
  330:     "index",
  331:     [
  332:         date_range("2014-01-01", periods=20, freq="MS"),
  333:         period_range("2014-01", periods=20, freq="M"),
  334:         timedelta_range("0", periods=20, freq="h"),
  335:     ],
  336: )
  337: def test_slice_with_negative_step(index):
  338:     keystr1 = str(index[9])
  339:     keystr2 = str(index[13])
  340: 
  341:     ser = Series(np.arange(20), index)
  342:     SLC = IndexSlice
  343: 
  344:     for key in [keystr1, index[9]]:
  345:         tm.assert_indexing_slices_equivalent(ser, SLC[key::-1], SLC[9::-1])
  346:         tm.assert_indexing_slices_equivalent(ser, SLC[:key:-1], SLC[:8:-1])
  347: 
  348:         for key2 in [keystr2, index[13]]:
  349:             tm.assert_indexing_slices_equivalent(ser, SLC[key2:key:-1], SLC[13:8:-1])
  350:             tm.assert_indexing_slices_equivalent(ser, SLC[key:key2:-1], SLC[0:0:-1])
  351: 
  352: 
  353: def test_tuple_index():
  354:     # GH 35534 - Selecting values when a Series has an Index of tuples
  355:     s = Series([1, 2], index=[("a",), ("b",)])
  356:     assert s[("a",)] == 1
  357:     assert s[("b",)] == 2
  358:     s[("b",)] = 3
  359:     assert s[("b",)] == 3
  360: 
  361: 
  362: def test_frozenset_index():
  363:     # GH35747 - Selecting values when a Series has an Index of frozenset
  364:     idx0, idx1 = frozenset("a"), frozenset("b")
  365:     s = Series([1, 2], index=[idx0, idx1])
  366:     assert s[idx0] == 1
  367:     assert s[idx1] == 2
  368:     s[idx1] = 3
  369:     assert s[idx1] == 3
  370: 
  371: 
  372: def test_loc_setitem_all_false_indexer():
  373:     # GH#45778
  374:     ser = Series([1, 2], index=["a", "b"])
  375:     expected = ser.copy()
  376:     rhs = Series([6, 7], index=["a", "b"])
  377:     ser.loc[ser > 100] = rhs
  378:     tm.assert_series_equal(ser, expected)
  379: 
  380: 
  381: def test_loc_boolean_indexer_non_matching_index():
  382:     # GH#46551
  383:     ser = Series([1])
  384:     result = ser.loc[Series([NA, False], dtype="boolean")]
  385:     expected = Series([], dtype="int64")
  386:     tm.assert_series_equal(result, expected)
  387: 
  388: 
  389: def test_loc_boolean_indexer_miss_matching_index():
  390:     # GH#46551
  391:     ser = Series([1])
  392:     indexer = Series([NA, False], dtype="boolean", index=[1, 2])
  393:     with pytest.raises(IndexingError, match="Unalignable"):
  394:         ser.loc[indexer]
  395: 
  396: 
  397: def test_loc_setitem_nested_data_enlargement():
  398:     # GH#48614
  399:     df = DataFrame({"a": [1]})
  400:     ser = Series({"label": df})
  401:     ser.loc["new_label"] = df
  402:     expected = Series({"label": df, "new_label": df})
  403:     tm.assert_series_equal(ser, expected)
  404: 
  405: 
  406: def test_loc_ea_numeric_index_oob_slice_end():
  407:     # GH#50161
  408:     ser = Series(1, index=Index([0, 1, 2], dtype="Int64"))
  409:     result = ser.loc[2:3]
  410:     expected = Series(1, index=Index([2], dtype="Int64"))
  411:     tm.assert_series_equal(result, expected)
  412: 
  413: 
  414: def test_getitem_bool_int_key():
  415:     # GH#48653
  416:     ser = Series({True: 1, False: 0})
  417:     with pytest.raises(KeyError, match="0"):
  418:         ser.loc[0]
  419: 
  420: 
  421: @pytest.mark.parametrize("val", [{}, {"b": "x"}])
  422: @pytest.mark.parametrize("indexer", [[], [False, False], slice(0, -1), np.array([])])
  423: def test_setitem_empty_indexer(indexer, val):
  424:     # GH#45981
  425:     df = DataFrame({"a": [1, 2], **val})
  426:     expected = df.copy()
  427:     df.loc[indexer] = 1.5
  428:     tm.assert_frame_equal(df, expected)
  429: 
  430: 
  431: class TestDeprecatedIndexers:
  432:     @pytest.mark.parametrize("key", [{1}, {1: 1}])
  433:     def test_getitem_dict_and_set_deprecated(self, key):
  434:         # GH#42825 enforced in 2.0
  435:         ser = Series([1, 2])
  436:         with pytest.raises(TypeError, match="as an indexer is not supported"):
  437:             ser.loc[key]
  438: 
  439:     @pytest.mark.parametrize("key", [{1}, {1: 1}, ({1}, 2), ({1: 1}, 2)])
  440:     def test_getitem_dict_and_set_deprecated_multiindex(self, key):
  441:         # GH#42825 enforced in 2.0
  442:         ser = Series([1, 2], index=MultiIndex.from_tuples([(1, 2), (3, 4)]))
  443:         with pytest.raises(TypeError, match="as an indexer is not supported"):
  444:             ser.loc[key]
  445: 
  446:     @pytest.mark.parametrize("key", [{1}, {1: 1}])
  447:     def test_setitem_dict_and_set_disallowed(self, key):
  448:         # GH#42825 enforced in 2.0
  449:         ser = Series([1, 2])
  450:         with pytest.raises(TypeError, match="as an indexer is not supported"):
  451:             ser.loc[key] = 1
  452: 
  453:     @pytest.mark.parametrize("key", [{1}, {1: 1}, ({1}, 2), ({1: 1}, 2)])
  454:     def test_setitem_dict_and_set_disallowed_multiindex(self, key):
  455:         # GH#42825 enforced in 2.0
  456:         ser = Series([1, 2], index=MultiIndex.from_tuples([(1, 2), (3, 4)]))
  457:         with pytest.raises(TypeError, match="as an indexer is not supported"):
  458:             ser.loc[key] = 1
  459: 
  460: 
  461: class TestSetitemValidation:
  462:     # This is adapted from pandas/tests/arrays/masked/test_indexing.py
  463:     # but checks for warnings instead of errors.
  464:     def _check_setitem_invalid(self, ser, invalid, indexer, warn):
  465:         msg = "Setting an item of incompatible dtype is deprecated"
  466:         msg = re.escape(msg)
  467: 
  468:         orig_ser = ser.copy()
  469: 
  470:         with tm.assert_produces_warning(warn, match=msg):
  471:             ser[indexer] = invalid
  472:             ser = orig_ser.copy()
  473: 
  474:         with tm.assert_produces_warning(warn, match=msg):
  475:             ser.iloc[indexer] = invalid
  476:             ser = orig_ser.copy()
  477: 
  478:         with tm.assert_produces_warning(warn, match=msg):
  479:             ser.loc[indexer] = invalid
  480:             ser = orig_ser.copy()
  481: 
  482:         with tm.assert_produces_warning(warn, match=msg):
  483:             ser[:] = invalid
  484: 
  485:     _invalid_scalars = [
  486:         1 + 2j,
  487:         "True",
  488:         "1",
  489:         "1.0",
  490:         NaT,
  491:         np.datetime64("NaT"),
  492:         np.timedelta64("NaT"),
  493:     ]
  494:     _indexers = [0, [0], slice(0, 1), [True, False, False], slice(None, None, None)]
  495: 
  496:     @pytest.mark.parametrize(
  497:         "invalid", _invalid_scalars + [1, 1.0, np.int64(1), np.float64(1)]
  498:     )
  499:     @pytest.mark.parametrize("indexer", _indexers)
  500:     def test_setitem_validation_scalar_bool(self, invalid, indexer):
  501:         ser = Series([True, False, False], dtype="bool")
  502:         self._check_setitem_invalid(ser, invalid, indexer, FutureWarning)
  503: 
  504:     @pytest.mark.parametrize("invalid", _invalid_scalars + [True, 1.5, np.float64(1.5)])
  505:     @pytest.mark.parametrize("indexer", _indexers)
  506:     def test_setitem_validation_scalar_int(self, invalid, any_int_numpy_dtype, indexer):
  507:         ser = Series([1, 2, 3], dtype=any_int_numpy_dtype)
  508:         if isna(invalid) and invalid is not NaT and not np.isnat(invalid):
  509:             warn = None
  510:         else:
  511:             warn = FutureWarning
  512:         self._check_setitem_invalid(ser, invalid, indexer, warn)
  513: 
  514:     @pytest.mark.parametrize("invalid", _invalid_scalars + [True])
  515:     @pytest.mark.parametrize("indexer", _indexers)
  516:     def test_setitem_validation_scalar_float(self, invalid, float_numpy_dtype, indexer):
  517:         ser = Series([1, 2, None], dtype=float_numpy_dtype)
  518:         self._check_setitem_invalid(ser, invalid, indexer, FutureWarning)
