    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas import (
    5:     Categorical,
    6:     DataFrame,
    7:     Index,
    8:     Series,
    9:     Timestamp,
   10:     date_range,
   11:     period_range,
   12:     timedelta_range,
   13: )
   14: import pandas._testing as tm
   15: from pandas.core.arrays.categorical import CategoricalAccessor
   16: from pandas.core.indexes.accessors import Properties
   17: 
   18: 
   19: class TestCatAccessor:
   20:     @pytest.mark.parametrize(
   21:         "method",
   22:         [
   23:             lambda x: x.cat.set_categories([1, 2, 3]),
   24:             lambda x: x.cat.reorder_categories([2, 3, 1], ordered=True),
   25:             lambda x: x.cat.rename_categories([1, 2, 3]),
   26:             lambda x: x.cat.remove_unused_categories(),
   27:             lambda x: x.cat.remove_categories([2]),
   28:             lambda x: x.cat.add_categories([4]),
   29:             lambda x: x.cat.as_ordered(),
   30:             lambda x: x.cat.as_unordered(),
   31:         ],
   32:     )
   33:     def test_getname_categorical_accessor(self, method):
   34:         # GH#17509
   35:         ser = Series([1, 2, 3], name="A").astype("category")
   36:         expected = "A"
   37:         result = method(ser).name
   38:         assert result == expected
   39: 
   40:     def test_cat_accessor(self):
   41:         ser = Series(Categorical(["a", "b", np.nan, "a"]))
   42:         tm.assert_index_equal(ser.cat.categories, Index(["a", "b"]))
   43:         assert not ser.cat.ordered, False
   44: 
   45:         exp = Categorical(["a", "b", np.nan, "a"], categories=["b", "a"])
   46: 
   47:         res = ser.cat.set_categories(["b", "a"])
   48:         tm.assert_categorical_equal(res.values, exp)
   49: 
   50:         ser[:] = "a"
   51:         ser = ser.cat.remove_unused_categories()
   52:         tm.assert_index_equal(ser.cat.categories, Index(["a"]))
   53: 
   54:     def test_cat_accessor_api(self):
   55:         # GH#9322
   56: 
   57:         assert Series.cat is CategoricalAccessor
   58:         ser = Series(list("aabbcde")).astype("category")
   59:         assert isinstance(ser.cat, CategoricalAccessor)
   60: 
   61:         invalid = Series([1])
   62:         with pytest.raises(AttributeError, match="only use .cat accessor"):
   63:             invalid.cat
   64:         assert not hasattr(invalid, "cat")
   65: 
   66:     def test_cat_accessor_no_new_attributes(self):
   67:         # https://github.com/pandas-dev/pandas/issues/10673
   68:         cat = Series(list("aabbcde")).astype("category")
   69:         with pytest.raises(AttributeError, match="You cannot add any new attribute"):
   70:             cat.cat.xlabel = "a"
   71: 
   72:     def test_categorical_delegations(self):
   73:         # invalid accessor
   74:         msg = r"Can only use \.cat accessor with a 'category' dtype"
   75:         with pytest.raises(AttributeError, match=msg):
   76:             Series([1, 2, 3]).cat
   77:         with pytest.raises(AttributeError, match=msg):
   78:             Series([1, 2, 3]).cat()
   79:         with pytest.raises(AttributeError, match=msg):
   80:             Series(["a", "b", "c"]).cat
   81:         with pytest.raises(AttributeError, match=msg):
   82:             Series(np.arange(5.0)).cat
   83:         with pytest.raises(AttributeError, match=msg):
   84:             Series([Timestamp("20130101")]).cat
   85: 
   86:         # Series should delegate calls to '.categories', '.codes', '.ordered'
   87:         # and the methods '.set_categories()' 'drop_unused_categories()' to the
   88:         # categorical
   89:         ser = Series(Categorical(["a", "b", "c", "a"], ordered=True))
   90:         exp_categories = Index(["a", "b", "c"])
   91:         tm.assert_index_equal(ser.cat.categories, exp_categories)
   92:         ser = ser.cat.rename_categories([1, 2, 3])
   93:         exp_categories = Index([1, 2, 3])
   94:         tm.assert_index_equal(ser.cat.categories, exp_categories)
   95: 
   96:         exp_codes = Series([0, 1, 2, 0], dtype="int8")
   97:         tm.assert_series_equal(ser.cat.codes, exp_codes)
   98: 
   99:         assert ser.cat.ordered
  100:         ser = ser.cat.as_unordered()
  101:         assert not ser.cat.ordered
  102: 
  103:         ser = ser.cat.as_ordered()
  104:         assert ser.cat.ordered
  105: 
  106:         # reorder
  107:         ser = Series(Categorical(["a", "b", "c", "a"], ordered=True))
  108:         exp_categories = Index(["c", "b", "a"])
  109:         exp_values = np.array(["a", "b", "c", "a"], dtype=np.object_)
  110:         ser = ser.cat.set_categories(["c", "b", "a"])
  111:         tm.assert_index_equal(ser.cat.categories, exp_categories)
  112:         tm.assert_numpy_array_equal(ser.values.__array__(), exp_values)
  113:         tm.assert_numpy_array_equal(ser.__array__(), exp_values)
  114: 
  115:         # remove unused categories
  116:         ser = Series(Categorical(["a", "b", "b", "a"], categories=["a", "b", "c"]))
  117:         exp_categories = Index(["a", "b"])
  118:         exp_values = np.array(["a", "b", "b", "a"], dtype=np.object_)
  119:         ser = ser.cat.remove_unused_categories()
  120:         tm.assert_index_equal(ser.cat.categories, exp_categories)
  121:         tm.assert_numpy_array_equal(ser.values.__array__(), exp_values)
  122:         tm.assert_numpy_array_equal(ser.__array__(), exp_values)
  123: 
  124:         # This method is likely to be confused, so test that it raises an error
  125:         # on wrong inputs:
  126:         msg = "'Series' object has no attribute 'set_categories'"
  127:         with pytest.raises(AttributeError, match=msg):
  128:             ser.set_categories([4, 3, 2, 1])
  129: 
  130:         # right: ser.cat.set_categories([4,3,2,1])
  131: 
  132:         # GH#18862 (let Series.cat.rename_categories take callables)
  133:         ser = Series(Categorical(["a", "b", "c", "a"], ordered=True))
  134:         result = ser.cat.rename_categories(lambda x: x.upper())
  135:         expected = Series(
  136:             Categorical(["A", "B", "C", "A"], categories=["A", "B", "C"], ordered=True)
  137:         )
  138:         tm.assert_series_equal(result, expected)
  139: 
  140:     @pytest.mark.parametrize(
  141:         "idx",
  142:         [
  143:             date_range("1/1/2015", periods=5),
  144:             date_range("1/1/2015", periods=5, tz="MET"),
  145:             period_range("1/1/2015", freq="D", periods=5),
  146:             timedelta_range("1 days", "10 days"),
  147:         ],
  148:     )
  149:     def test_dt_accessor_api_for_categorical(self, idx):
  150:         # https://github.com/pandas-dev/pandas/issues/10661
  151: 
  152:         ser = Series(idx)
  153:         cat = ser.astype("category")
  154: 
  155:         # only testing field (like .day)
  156:         # and bool (is_month_start)
  157:         attr_names = type(ser._values)._datetimelike_ops
  158: 
  159:         assert isinstance(cat.dt, Properties)
  160: 
  161:         special_func_defs = [
  162:             ("strftime", ("%Y-%m-%d",), {}),
  163:             ("round", ("D",), {}),
  164:             ("floor", ("D",), {}),
  165:             ("ceil", ("D",), {}),
  166:             ("asfreq", ("D",), {}),
  167:             ("as_unit", ("s"), {}),
  168:         ]
  169:         if idx.dtype == "M8[ns]":
  170:             # exclude dt64tz since that is already localized and would raise
  171:             tup = ("tz_localize", ("UTC",), {})
  172:             special_func_defs.append(tup)
  173:         elif idx.dtype.kind == "M":
  174:             # exclude dt64 since that is not localized so would raise
  175:             tup = ("tz_convert", ("EST",), {})
  176:             special_func_defs.append(tup)
  177: 
  178:         _special_func_names = [f[0] for f in special_func_defs]
  179: 
  180:         _ignore_names = ["components", "tz_localize", "tz_convert"]
  181: 
  182:         func_names = [
  183:             fname
  184:             for fname in dir(ser.dt)
  185:             if not (
  186:                 fname.startswith("_")
  187:                 or fname in attr_names
  188:                 or fname in _special_func_names
  189:                 or fname in _ignore_names
  190:             )
  191:         ]
  192: 
  193:         func_defs = [(fname, (), {}) for fname in func_names]
  194:         func_defs.extend(
  195:             f_def for f_def in special_func_defs if f_def[0] in dir(ser.dt)
  196:         )
  197: 
  198:         for func, args, kwargs in func_defs:
  199:             warn_cls = []
  200:             if func == "to_period" and getattr(idx, "tz", None) is not None:
  201:                 # dropping TZ
  202:                 warn_cls.append(UserWarning)
  203:             if func == "to_pydatetime":
  204:                 # deprecated to return Index[object]
  205:                 warn_cls.append(FutureWarning)
  206:             if warn_cls:
  207:                 warn_cls = tuple(warn_cls)
  208:             else:
  209:                 warn_cls = None
  210:             with tm.assert_produces_warning(warn_cls):
  211:                 res = getattr(cat.dt, func)(*args, **kwargs)
  212:                 exp = getattr(ser.dt, func)(*args, **kwargs)
  213: 
  214:             tm.assert_equal(res, exp)
  215: 
  216:         for attr in attr_names:
  217:             res = getattr(cat.dt, attr)
  218:             exp = getattr(ser.dt, attr)
  219: 
  220:             tm.assert_equal(res, exp)
  221: 
  222:     def test_dt_accessor_api_for_categorical_invalid(self):
  223:         invalid = Series([1, 2, 3]).astype("category")
  224:         msg = "Can only use .dt accessor with datetimelike"
  225: 
  226:         with pytest.raises(AttributeError, match=msg):
  227:             invalid.dt
  228:         assert not hasattr(invalid, "str")
  229: 
  230:     def test_set_categories_setitem(self):
  231:         # GH#43334
  232: 
  233:         df = DataFrame({"Survived": [1, 0, 1], "Sex": [0, 1, 1]}, dtype="category")
  234: 
  235:         df["Survived"] = df["Survived"].cat.rename_categories(["No", "Yes"])
  236:         df["Sex"] = df["Sex"].cat.rename_categories(["female", "male"])
  237: 
  238:         # values should not be coerced to NaN
  239:         assert list(df["Sex"]) == ["female", "male", "male"]
  240:         assert list(df["Survived"]) == ["Yes", "No", "Yes"]
  241: 
  242:         df["Sex"] = Categorical(df["Sex"], categories=["female", "male"], ordered=False)
  243:         df["Survived"] = Categorical(
  244:             df["Survived"], categories=["No", "Yes"], ordered=False
  245:         )
  246: 
  247:         # values should not be coerced to NaN
  248:         assert list(df["Sex"]) == ["female", "male", "male"]
  249:         assert list(df["Survived"]) == ["Yes", "No", "Yes"]
  250: 
  251:     def test_categorical_of_booleans_is_boolean(self):
  252:         # https://github.com/pandas-dev/pandas/issues/46313
  253:         df = DataFrame(
  254:             {"int_cat": [1, 2, 3], "bool_cat": [True, False, False]}, dtype="category"
  255:         )
  256:         value = df["bool_cat"].cat.categories.dtype
  257:         expected = np.dtype(np.bool_)
  258:         assert value is expected
