    1: import numpy as np
    2: import pytest
    3: 
    4: import pandas as pd
    5: import pandas._testing as tm
    6: 
    7: 
    8: @pytest.mark.parametrize("align_axis", [0, 1, "index", "columns"])
    9: def test_compare_axis(align_axis):
   10:     # GH#30429
   11:     s1 = pd.Series(["a", "b", "c"])
   12:     s2 = pd.Series(["x", "b", "z"])
   13: 
   14:     result = s1.compare(s2, align_axis=align_axis)
   15: 
   16:     if align_axis in (1, "columns"):
   17:         indices = pd.Index([0, 2])
   18:         columns = pd.Index(["self", "other"])
   19:         expected = pd.DataFrame(
   20:             [["a", "x"], ["c", "z"]], index=indices, columns=columns
   21:         )
   22:         tm.assert_frame_equal(result, expected)
   23:     else:
   24:         indices = pd.MultiIndex.from_product([[0, 2], ["self", "other"]])
   25:         expected = pd.Series(["a", "x", "c", "z"], index=indices)
   26:         tm.assert_series_equal(result, expected)
   27: 
   28: 
   29: @pytest.mark.parametrize(
   30:     "keep_shape, keep_equal",
   31:     [
   32:         (True, False),
   33:         (False, True),
   34:         (True, True),
   35:         # False, False case is already covered in test_compare_axis
   36:     ],
   37: )
   38: def test_compare_various_formats(keep_shape, keep_equal):
   39:     s1 = pd.Series(["a", "b", "c"])
   40:     s2 = pd.Series(["x", "b", "z"])
   41: 
   42:     result = s1.compare(s2, keep_shape=keep_shape, keep_equal=keep_equal)
   43: 
   44:     if keep_shape:
   45:         indices = pd.Index([0, 1, 2])
   46:         columns = pd.Index(["self", "other"])
   47:         if keep_equal:
   48:             expected = pd.DataFrame(
   49:                 [["a", "x"], ["b", "b"], ["c", "z"]], index=indices, columns=columns
   50:             )
   51:         else:
   52:             expected = pd.DataFrame(
   53:                 [["a", "x"], [np.nan, np.nan], ["c", "z"]],
   54:                 index=indices,
   55:                 columns=columns,
   56:             )
   57:     else:
   58:         indices = pd.Index([0, 2])
   59:         columns = pd.Index(["self", "other"])
   60:         expected = pd.DataFrame(
   61:             [["a", "x"], ["c", "z"]], index=indices, columns=columns
   62:         )
   63:     tm.assert_frame_equal(result, expected)
   64: 
   65: 
   66: def test_compare_with_equal_nulls():
   67:     # We want to make sure two NaNs are considered the same
   68:     # and dropped where applicable
   69:     s1 = pd.Series(["a", "b", np.nan])
   70:     s2 = pd.Series(["x", "b", np.nan])
   71: 
   72:     result = s1.compare(s2)
   73:     expected = pd.DataFrame([["a", "x"]], columns=["self", "other"])
   74:     tm.assert_frame_equal(result, expected)
   75: 
   76: 
   77: def test_compare_with_non_equal_nulls():
   78:     # We want to make sure the relevant NaNs do not get dropped
   79:     s1 = pd.Series(["a", "b", "c"])
   80:     s2 = pd.Series(["x", "b", np.nan])
   81: 
   82:     result = s1.compare(s2, align_axis=0)
   83: 
   84:     indices = pd.MultiIndex.from_product([[0, 2], ["self", "other"]])
   85:     expected = pd.Series(["a", "x", "c", np.nan], index=indices)
   86:     tm.assert_series_equal(result, expected)
   87: 
   88: 
   89: def test_compare_multi_index():
   90:     index = pd.MultiIndex.from_arrays([[0, 0, 1], [0, 1, 2]])
   91:     s1 = pd.Series(["a", "b", "c"], index=index)
   92:     s2 = pd.Series(["x", "b", "z"], index=index)
   93: 
   94:     result = s1.compare(s2, align_axis=0)
   95: 
   96:     indices = pd.MultiIndex.from_arrays(
   97:         [[0, 0, 1, 1], [0, 0, 2, 2], ["self", "other", "self", "other"]]
   98:     )
   99:     expected = pd.Series(["a", "x", "c", "z"], index=indices)
  100:     tm.assert_series_equal(result, expected)
  101: 
  102: 
  103: def test_compare_unaligned_objects():
  104:     # test Series with different indices
  105:     msg = "Can only compare identically-labeled Series objects"
  106:     with pytest.raises(ValueError, match=msg):
  107:         ser1 = pd.Series([1, 2, 3], index=["a", "b", "c"])
  108:         ser2 = pd.Series([1, 2, 3], index=["a", "b", "d"])
  109:         ser1.compare(ser2)
  110: 
  111:     # test Series with different lengths
  112:     msg = "Can only compare identically-labeled Series objects"
  113:     with pytest.raises(ValueError, match=msg):
  114:         ser1 = pd.Series([1, 2, 3])
  115:         ser2 = pd.Series([1, 2, 3, 4])
  116:         ser1.compare(ser2)
  117: 
  118: 
  119: def test_compare_datetime64_and_string():
  120:     # Issue https://github.com/pandas-dev/pandas/issues/45506
  121:     # Catch OverflowError when comparing datetime64 and string
  122:     data = [
  123:         {"a": "2015-07-01", "b": "08335394550"},
  124:         {"a": "2015-07-02", "b": "+49 (0) 0345 300033"},
  125:         {"a": "2015-07-03", "b": "+49(0)2598 04457"},
  126:         {"a": "2015-07-04", "b": "0741470003"},
  127:         {"a": "2015-07-05", "b": "04181 83668"},
  128:     ]
  129:     dtypes = {"a": "datetime64[ns]", "b": "string"}
  130:     df = pd.DataFrame(data=data).astype(dtypes)
  131: 
  132:     result_eq1 = df["a"].eq(df["b"])
  133:     result_eq2 = df["a"] == df["b"]
  134:     result_neq = df["a"] != df["b"]
  135: 
  136:     expected_eq = pd.Series([False] * 5)  # For .eq and ==
  137:     expected_neq = pd.Series([True] * 5)  # For !=
  138: 
  139:     tm.assert_series_equal(result_eq1, expected_eq)
  140:     tm.assert_series_equal(result_eq2, expected_eq)
  141:     tm.assert_series_equal(result_neq, expected_neq)
