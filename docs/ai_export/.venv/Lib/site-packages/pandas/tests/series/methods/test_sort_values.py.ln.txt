    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas import (
    5:     Categorical,
    6:     DataFrame,
    7:     Series,
    8: )
    9: import pandas._testing as tm
   10: 
   11: 
   12: class TestSeriesSortValues:
   13:     def test_sort_values(self, datetime_series, using_copy_on_write):
   14:         # check indexes are reordered corresponding with the values
   15:         ser = Series([3, 2, 4, 1], ["A", "B", "C", "D"])
   16:         expected = Series([1, 2, 3, 4], ["D", "B", "A", "C"])
   17:         result = ser.sort_values()
   18:         tm.assert_series_equal(expected, result)
   19: 
   20:         ts = datetime_series.copy()
   21:         ts[:5] = np.nan
   22:         vals = ts.values
   23: 
   24:         result = ts.sort_values()
   25:         assert np.isnan(result[-5:]).all()
   26:         tm.assert_numpy_array_equal(result[:-5].values, np.sort(vals[5:]))
   27: 
   28:         # na_position
   29:         result = ts.sort_values(na_position="first")
   30:         assert np.isnan(result[:5]).all()
   31:         tm.assert_numpy_array_equal(result[5:].values, np.sort(vals[5:]))
   32: 
   33:         # something object-type
   34:         ser = Series(["A", "B"], [1, 2])
   35:         # no failure
   36:         ser.sort_values()
   37: 
   38:         # ascending=False
   39:         ordered = ts.sort_values(ascending=False)
   40:         expected = np.sort(ts.dropna().values)[::-1]
   41:         tm.assert_almost_equal(expected, ordered.dropna().values)
   42:         ordered = ts.sort_values(ascending=False, na_position="first")
   43:         tm.assert_almost_equal(expected, ordered.dropna().values)
   44: 
   45:         # ascending=[False] should behave the same as ascending=False
   46:         ordered = ts.sort_values(ascending=[False])
   47:         expected = ts.sort_values(ascending=False)
   48:         tm.assert_series_equal(expected, ordered)
   49:         ordered = ts.sort_values(ascending=[False], na_position="first")
   50:         expected = ts.sort_values(ascending=False, na_position="first")
   51:         tm.assert_series_equal(expected, ordered)
   52: 
   53:         msg = 'For argument "ascending" expected type bool, received type NoneType.'
   54:         with pytest.raises(ValueError, match=msg):
   55:             ts.sort_values(ascending=None)
   56:         msg = r"Length of ascending \(0\) must be 1 for Series"
   57:         with pytest.raises(ValueError, match=msg):
   58:             ts.sort_values(ascending=[])
   59:         msg = r"Length of ascending \(3\) must be 1 for Series"
   60:         with pytest.raises(ValueError, match=msg):
   61:             ts.sort_values(ascending=[1, 2, 3])
   62:         msg = r"Length of ascending \(2\) must be 1 for Series"
   63:         with pytest.raises(ValueError, match=msg):
   64:             ts.sort_values(ascending=[False, False])
   65:         msg = 'For argument "ascending" expected type bool, received type str.'
   66:         with pytest.raises(ValueError, match=msg):
   67:             ts.sort_values(ascending="foobar")
   68: 
   69:         # inplace=True
   70:         ts = datetime_series.copy()
   71:         return_value = ts.sort_values(ascending=False, inplace=True)
   72:         assert return_value is None
   73:         tm.assert_series_equal(ts, datetime_series.sort_values(ascending=False))
   74:         tm.assert_index_equal(
   75:             ts.index, datetime_series.sort_values(ascending=False).index
   76:         )
   77: 
   78:         # GH#5856/5853
   79:         # Series.sort_values operating on a view
   80:         df = DataFrame(np.random.default_rng(2).standard_normal((10, 4)))
   81:         s = df.iloc[:, 0]
   82: 
   83:         msg = (
   84:             "This Series is a view of some other array, to sort in-place "
   85:             "you must create a copy"
   86:         )
   87:         if using_copy_on_write:
   88:             s.sort_values(inplace=True)
   89:             tm.assert_series_equal(s, df.iloc[:, 0].sort_values())
   90:         else:
   91:             with pytest.raises(ValueError, match=msg):
   92:                 s.sort_values(inplace=True)
   93: 
   94:     def test_sort_values_categorical(self):
   95:         c = Categorical(["a", "b", "b", "a"], ordered=False)
   96:         cat = Series(c.copy())
   97: 
   98:         # sort in the categories order
   99:         expected = Series(
  100:             Categorical(["a", "a", "b", "b"], ordered=False), index=[0, 3, 1, 2]
  101:         )
  102:         result = cat.sort_values()
  103:         tm.assert_series_equal(result, expected)
  104: 
  105:         cat = Series(Categorical(["a", "c", "b", "d"], ordered=True))
  106:         res = cat.sort_values()
  107:         exp = np.array(["a", "b", "c", "d"], dtype=np.object_)
  108:         tm.assert_numpy_array_equal(res.__array__(), exp)
  109: 
  110:         cat = Series(
  111:             Categorical(
  112:                 ["a", "c", "b", "d"], categories=["a", "b", "c", "d"], ordered=True
  113:             )
  114:         )
  115:         res = cat.sort_values()
  116:         exp = np.array(["a", "b", "c", "d"], dtype=np.object_)
  117:         tm.assert_numpy_array_equal(res.__array__(), exp)
  118: 
  119:         res = cat.sort_values(ascending=False)
  120:         exp = np.array(["d", "c", "b", "a"], dtype=np.object_)
  121:         tm.assert_numpy_array_equal(res.__array__(), exp)
  122: 
  123:         raw_cat1 = Categorical(
  124:             ["a", "b", "c", "d"], categories=["a", "b", "c", "d"], ordered=False
  125:         )
  126:         raw_cat2 = Categorical(
  127:             ["a", "b", "c", "d"], categories=["d", "c", "b", "a"], ordered=True
  128:         )
  129:         s = ["a", "b", "c", "d"]
  130:         df = DataFrame(
  131:             {"unsort": raw_cat1, "sort": raw_cat2, "string": s, "values": [1, 2, 3, 4]}
  132:         )
  133: 
  134:         # Cats must be sorted in a dataframe
  135:         res = df.sort_values(by=["string"], ascending=False)
  136:         exp = np.array(["d", "c", "b", "a"], dtype=np.object_)
  137:         tm.assert_numpy_array_equal(res["sort"].values.__array__(), exp)
  138:         assert res["sort"].dtype == "category"
  139: 
  140:         res = df.sort_values(by=["sort"], ascending=False)
  141:         exp = df.sort_values(by=["string"], ascending=True)
  142:         tm.assert_series_equal(res["values"], exp["values"])
  143:         assert res["sort"].dtype == "category"
  144:         assert res["unsort"].dtype == "category"
  145: 
  146:         # unordered cat, but we allow this
  147:         df.sort_values(by=["unsort"], ascending=False)
  148: 
  149:         # multi-columns sort
  150:         # GH#7848
  151:         df = DataFrame(
  152:             {"id": [6, 5, 4, 3, 2, 1], "raw_grade": ["a", "b", "b", "a", "a", "e"]}
  153:         )
  154:         df["grade"] = Categorical(df["raw_grade"], ordered=True)
  155:         df["grade"] = df["grade"].cat.set_categories(["b", "e", "a"])
  156: 
  157:         # sorts 'grade' according to the order of the categories
  158:         result = df.sort_values(by=["grade"])
  159:         expected = df.iloc[[1, 2, 5, 0, 3, 4]]
  160:         tm.assert_frame_equal(result, expected)
  161: 
  162:         # multi
  163:         result = df.sort_values(by=["grade", "id"])
  164:         expected = df.iloc[[2, 1, 5, 4, 3, 0]]
  165:         tm.assert_frame_equal(result, expected)
  166: 
  167:     @pytest.mark.parametrize("inplace", [True, False])
  168:     @pytest.mark.parametrize(
  169:         "original_list, sorted_list, ignore_index, output_index",
  170:         [
  171:             ([2, 3, 6, 1], [6, 3, 2, 1], True, [0, 1, 2, 3]),
  172:             ([2, 3, 6, 1], [6, 3, 2, 1], False, [2, 1, 0, 3]),
  173:         ],
  174:     )
  175:     def test_sort_values_ignore_index(
  176:         self, inplace, original_list, sorted_list, ignore_index, output_index
  177:     ):
  178:         # GH 30114
  179:         ser = Series(original_list)
  180:         expected = Series(sorted_list, index=output_index)
  181:         kwargs = {"ignore_index": ignore_index, "inplace": inplace}
  182: 
  183:         if inplace:
  184:             result_ser = ser.copy()
  185:             result_ser.sort_values(ascending=False, **kwargs)
  186:         else:
  187:             result_ser = ser.sort_values(ascending=False, **kwargs)
  188: 
  189:         tm.assert_series_equal(result_ser, expected)
  190:         tm.assert_series_equal(ser, Series(original_list))
  191: 
  192:     def test_mergesort_descending_stability(self):
  193:         # GH 28697
  194:         s = Series([1, 2, 1, 3], ["first", "b", "second", "c"])
  195:         result = s.sort_values(ascending=False, kind="mergesort")
  196:         expected = Series([3, 2, 1, 1], ["c", "b", "first", "second"])
  197:         tm.assert_series_equal(result, expected)
  198: 
  199:     def test_sort_values_validate_ascending_for_value_error(self):
  200:         # GH41634
  201:         ser = Series([23, 7, 21])
  202: 
  203:         msg = 'For argument "ascending" expected type bool, received type str.'
  204:         with pytest.raises(ValueError, match=msg):
  205:             ser.sort_values(ascending="False")
  206: 
  207:     @pytest.mark.parametrize("ascending", [False, 0, 1, True])
  208:     def test_sort_values_validate_ascending_functional(self, ascending):
  209:         # GH41634
  210:         ser = Series([23, 7, 21])
  211:         expected = np.sort(ser.values)
  212: 
  213:         sorted_ser = ser.sort_values(ascending=ascending)
  214:         if not ascending:
  215:             expected = expected[::-1]
  216: 
  217:         result = sorted_ser.values
  218:         tm.assert_numpy_array_equal(result, expected)
  219: 
  220: 
  221: class TestSeriesSortingKey:
  222:     def test_sort_values_key(self):
  223:         series = Series(np.array(["Hello", "goodbye"]))
  224: 
  225:         result = series.sort_values(axis=0)
  226:         expected = series
  227:         tm.assert_series_equal(result, expected)
  228: 
  229:         result = series.sort_values(axis=0, key=lambda x: x.str.lower())
  230:         expected = series[::-1]
  231:         tm.assert_series_equal(result, expected)
  232: 
  233:     def test_sort_values_key_nan(self):
  234:         series = Series(np.array([0, 5, np.nan, 3, 2, np.nan]))
  235: 
  236:         result = series.sort_values(axis=0)
  237:         expected = series.iloc[[0, 4, 3, 1, 2, 5]]
  238:         tm.assert_series_equal(result, expected)
  239: 
  240:         result = series.sort_values(axis=0, key=lambda x: x + 5)
  241:         expected = series.iloc[[0, 4, 3, 1, 2, 5]]
  242:         tm.assert_series_equal(result, expected)
  243: 
  244:         result = series.sort_values(axis=0, key=lambda x: -x, ascending=False)
  245:         expected = series.iloc[[0, 4, 3, 1, 2, 5]]
  246:         tm.assert_series_equal(result, expected)
