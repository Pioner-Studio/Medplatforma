    1: import numpy as np
    2: import pytest
    3: 
    4: import pandas.util._test_decorators as td
    5: 
    6: import pandas as pd
    7: from pandas import (
    8:     Index,
    9:     MultiIndex,
   10:     Series,
   11:     date_range,
   12:     isna,
   13: )
   14: import pandas._testing as tm
   15: 
   16: 
   17: @pytest.fixture(
   18:     params=[
   19:         "linear",
   20:         "index",
   21:         "values",
   22:         "nearest",
   23:         "slinear",
   24:         "zero",
   25:         "quadratic",
   26:         "cubic",
   27:         "barycentric",
   28:         "krogh",
   29:         "polynomial",
   30:         "spline",
   31:         "piecewise_polynomial",
   32:         "from_derivatives",
   33:         "pchip",
   34:         "akima",
   35:         "cubicspline",
   36:     ]
   37: )
   38: def nontemporal_method(request):
   39:     """Fixture that returns an (method name, required kwargs) pair.
   40: 
   41:     This fixture does not include method 'time' as a parameterization; that
   42:     method requires a Series with a DatetimeIndex, and is generally tested
   43:     separately from these non-temporal methods.
   44:     """
   45:     method = request.param
   46:     kwargs = {"order": 1} if method in ("spline", "polynomial") else {}
   47:     return method, kwargs
   48: 
   49: 
   50: @pytest.fixture(
   51:     params=[
   52:         "linear",
   53:         "slinear",
   54:         "zero",
   55:         "quadratic",
   56:         "cubic",
   57:         "barycentric",
   58:         "krogh",
   59:         "polynomial",
   60:         "spline",
   61:         "piecewise_polynomial",
   62:         "from_derivatives",
   63:         "pchip",
   64:         "akima",
   65:         "cubicspline",
   66:     ]
   67: )
   68: def interp_methods_ind(request):
   69:     """Fixture that returns a (method name, required kwargs) pair to
   70:     be tested for various Index types.
   71: 
   72:     This fixture does not include methods - 'time', 'index', 'nearest',
   73:     'values' as a parameterization
   74:     """
   75:     method = request.param
   76:     kwargs = {"order": 1} if method in ("spline", "polynomial") else {}
   77:     return method, kwargs
   78: 
   79: 
   80: class TestSeriesInterpolateData:
   81:     @pytest.mark.xfail(reason="EA.fillna does not handle 'linear' method")
   82:     def test_interpolate_period_values(self):
   83:         orig = Series(date_range("2012-01-01", periods=5))
   84:         ser = orig.copy()
   85:         ser[2] = pd.NaT
   86: 
   87:         # period cast
   88:         ser_per = ser.dt.to_period("D")
   89:         res_per = ser_per.interpolate()
   90:         expected_per = orig.dt.to_period("D")
   91:         tm.assert_series_equal(res_per, expected_per)
   92: 
   93:     def test_interpolate(self, datetime_series):
   94:         ts = Series(np.arange(len(datetime_series), dtype=float), datetime_series.index)
   95: 
   96:         ts_copy = ts.copy()
   97:         ts_copy[5:10] = np.nan
   98: 
   99:         linear_interp = ts_copy.interpolate(method="linear")
  100:         tm.assert_series_equal(linear_interp, ts)
  101: 
  102:         ord_ts = Series(
  103:             [d.toordinal() for d in datetime_series.index], index=datetime_series.index
  104:         ).astype(float)
  105: 
  106:         ord_ts_copy = ord_ts.copy()
  107:         ord_ts_copy[5:10] = np.nan
  108: 
  109:         time_interp = ord_ts_copy.interpolate(method="time")
  110:         tm.assert_series_equal(time_interp, ord_ts)
  111: 
  112:     def test_interpolate_time_raises_for_non_timeseries(self):
  113:         # When method='time' is used on a non-TimeSeries that contains a null
  114:         # value, a ValueError should be raised.
  115:         non_ts = Series([0, 1, 2, np.nan])
  116:         msg = "time-weighted interpolation only works on Series.* with a DatetimeIndex"
  117:         with pytest.raises(ValueError, match=msg):
  118:             non_ts.interpolate(method="time")
  119: 
  120:     def test_interpolate_cubicspline(self):
  121:         pytest.importorskip("scipy")
  122:         ser = Series([10, 11, 12, 13])
  123: 
  124:         expected = Series(
  125:             [11.00, 11.25, 11.50, 11.75, 12.00, 12.25, 12.50, 12.75, 13.00],
  126:             index=Index([1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 2.5, 2.75, 3.0]),
  127:         )
  128:         # interpolate at new_index
  129:         new_index = ser.index.union(Index([1.25, 1.5, 1.75, 2.25, 2.5, 2.75])).astype(
  130:             float
  131:         )
  132:         result = ser.reindex(new_index).interpolate(method="cubicspline").loc[1:3]
  133:         tm.assert_series_equal(result, expected)
  134: 
  135:     def test_interpolate_pchip(self):
  136:         pytest.importorskip("scipy")
  137:         ser = Series(np.sort(np.random.default_rng(2).uniform(size=100)))
  138: 
  139:         # interpolate at new_index
  140:         new_index = ser.index.union(
  141:             Index([49.25, 49.5, 49.75, 50.25, 50.5, 50.75])
  142:         ).astype(float)
  143:         interp_s = ser.reindex(new_index).interpolate(method="pchip")
  144:         # does not blow up, GH5977
  145:         interp_s.loc[49:51]
  146: 
  147:     def test_interpolate_akima(self):
  148:         pytest.importorskip("scipy")
  149:         ser = Series([10, 11, 12, 13])
  150: 
  151:         # interpolate at new_index where `der` is zero
  152:         expected = Series(
  153:             [11.00, 11.25, 11.50, 11.75, 12.00, 12.25, 12.50, 12.75, 13.00],
  154:             index=Index([1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 2.5, 2.75, 3.0]),
  155:         )
  156:         new_index = ser.index.union(Index([1.25, 1.5, 1.75, 2.25, 2.5, 2.75])).astype(
  157:             float
  158:         )
  159:         interp_s = ser.reindex(new_index).interpolate(method="akima")
  160:         tm.assert_series_equal(interp_s.loc[1:3], expected)
  161: 
  162:         # interpolate at new_index where `der` is a non-zero int
  163:         expected = Series(
  164:             [11.0, 1.0, 1.0, 1.0, 12.0, 1.0, 1.0, 1.0, 13.0],
  165:             index=Index([1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 2.5, 2.75, 3.0]),
  166:         )
  167:         new_index = ser.index.union(Index([1.25, 1.5, 1.75, 2.25, 2.5, 2.75])).astype(
  168:             float
  169:         )
  170:         interp_s = ser.reindex(new_index).interpolate(method="akima", der=1)
  171:         tm.assert_series_equal(interp_s.loc[1:3], expected)
  172: 
  173:     def test_interpolate_piecewise_polynomial(self):
  174:         pytest.importorskip("scipy")
  175:         ser = Series([10, 11, 12, 13])
  176: 
  177:         expected = Series(
  178:             [11.00, 11.25, 11.50, 11.75, 12.00, 12.25, 12.50, 12.75, 13.00],
  179:             index=Index([1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 2.5, 2.75, 3.0]),
  180:         )
  181:         # interpolate at new_index
  182:         new_index = ser.index.union(Index([1.25, 1.5, 1.75, 2.25, 2.5, 2.75])).astype(
  183:             float
  184:         )
  185:         interp_s = ser.reindex(new_index).interpolate(method="piecewise_polynomial")
  186:         tm.assert_series_equal(interp_s.loc[1:3], expected)
  187: 
  188:     def test_interpolate_from_derivatives(self):
  189:         pytest.importorskip("scipy")
  190:         ser = Series([10, 11, 12, 13])
  191: 
  192:         expected = Series(
  193:             [11.00, 11.25, 11.50, 11.75, 12.00, 12.25, 12.50, 12.75, 13.00],
  194:             index=Index([1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 2.5, 2.75, 3.0]),
  195:         )
  196:         # interpolate at new_index
  197:         new_index = ser.index.union(Index([1.25, 1.5, 1.75, 2.25, 2.5, 2.75])).astype(
  198:             float
  199:         )
  200:         interp_s = ser.reindex(new_index).interpolate(method="from_derivatives")
  201:         tm.assert_series_equal(interp_s.loc[1:3], expected)
  202: 
  203:     @pytest.mark.parametrize(
  204:         "kwargs",
  205:         [
  206:             {},
  207:             pytest.param(
  208:                 {"method": "polynomial", "order": 1}, marks=td.skip_if_no("scipy")
  209:             ),
  210:         ],
  211:     )
  212:     def test_interpolate_corners(self, kwargs):
  213:         s = Series([np.nan, np.nan])
  214:         tm.assert_series_equal(s.interpolate(**kwargs), s)
  215: 
  216:         s = Series([], dtype=object).interpolate()
  217:         tm.assert_series_equal(s.interpolate(**kwargs), s)
  218: 
  219:     def test_interpolate_index_values(self):
  220:         s = Series(np.nan, index=np.sort(np.random.default_rng(2).random(30)))
  221:         s.loc[::3] = np.random.default_rng(2).standard_normal(10)
  222: 
  223:         vals = s.index.values.astype(float)
  224: 
  225:         result = s.interpolate(method="index")
  226: 
  227:         expected = s.copy()
  228:         bad = isna(expected.values)
  229:         good = ~bad
  230:         expected = Series(
  231:             np.interp(vals[bad], vals[good], s.values[good]), index=s.index[bad]
  232:         )
  233: 
  234:         tm.assert_series_equal(result[bad], expected)
  235: 
  236:         # 'values' is synonymous with 'index' for the method kwarg
  237:         other_result = s.interpolate(method="values")
  238: 
  239:         tm.assert_series_equal(other_result, result)
  240:         tm.assert_series_equal(other_result[bad], expected)
  241: 
  242:     def test_interpolate_non_ts(self):
  243:         s = Series([1, 3, np.nan, np.nan, np.nan, 11])
  244:         msg = (
  245:             "time-weighted interpolation only works on Series or DataFrames "
  246:             "with a DatetimeIndex"
  247:         )
  248:         with pytest.raises(ValueError, match=msg):
  249:             s.interpolate(method="time")
  250: 
  251:     @pytest.mark.parametrize(
  252:         "kwargs",
  253:         [
  254:             {},
  255:             pytest.param(
  256:                 {"method": "polynomial", "order": 1}, marks=td.skip_if_no("scipy")
  257:             ),
  258:         ],
  259:     )
  260:     def test_nan_interpolate(self, kwargs):
  261:         s = Series([0, 1, np.nan, 3])
  262:         result = s.interpolate(**kwargs)
  263:         expected = Series([0.0, 1.0, 2.0, 3.0])
  264:         tm.assert_series_equal(result, expected)
  265: 
  266:     def test_nan_irregular_index(self):
  267:         s = Series([1, 2, np.nan, 4], index=[1, 3, 5, 9])
  268:         result = s.interpolate()
  269:         expected = Series([1.0, 2.0, 3.0, 4.0], index=[1, 3, 5, 9])
  270:         tm.assert_series_equal(result, expected)
  271: 
  272:     def test_nan_str_index(self):
  273:         s = Series([0, 1, 2, np.nan], index=list("abcd"))
  274:         result = s.interpolate()
  275:         expected = Series([0.0, 1.0, 2.0, 2.0], index=list("abcd"))
  276:         tm.assert_series_equal(result, expected)
  277: 
  278:     def test_interp_quad(self):
  279:         pytest.importorskip("scipy")
  280:         sq = Series([1, 4, np.nan, 16], index=[1, 2, 3, 4])
  281:         result = sq.interpolate(method="quadratic")
  282:         expected = Series([1.0, 4.0, 9.0, 16.0], index=[1, 2, 3, 4])
  283:         tm.assert_series_equal(result, expected)
  284: 
  285:     def test_interp_scipy_basic(self):
  286:         pytest.importorskip("scipy")
  287:         s = Series([1, 3, np.nan, 12, np.nan, 25])
  288:         # slinear
  289:         expected = Series([1.0, 3.0, 7.5, 12.0, 18.5, 25.0])
  290:         result = s.interpolate(method="slinear")
  291:         tm.assert_series_equal(result, expected)
  292: 
  293:         msg = "The 'downcast' keyword in Series.interpolate is deprecated"
  294:         with tm.assert_produces_warning(FutureWarning, match=msg):
  295:             result = s.interpolate(method="slinear", downcast="infer")
  296:         tm.assert_series_equal(result, expected)
  297:         # nearest
  298:         expected = Series([1, 3, 3, 12, 12, 25])
  299:         result = s.interpolate(method="nearest")
  300:         tm.assert_series_equal(result, expected.astype("float"))
  301: 
  302:         with tm.assert_produces_warning(FutureWarning, match=msg):
  303:             result = s.interpolate(method="nearest", downcast="infer")
  304:         tm.assert_series_equal(result, expected)
  305:         # zero
  306:         expected = Series([1, 3, 3, 12, 12, 25])
  307:         result = s.interpolate(method="zero")
  308:         tm.assert_series_equal(result, expected.astype("float"))
  309: 
  310:         with tm.assert_produces_warning(FutureWarning, match=msg):
  311:             result = s.interpolate(method="zero", downcast="infer")
  312:         tm.assert_series_equal(result, expected)
  313:         # quadratic
  314:         # GH #15662.
  315:         expected = Series([1, 3.0, 6.823529, 12.0, 18.058824, 25.0])
  316:         result = s.interpolate(method="quadratic")
  317:         tm.assert_series_equal(result, expected)
  318: 
  319:         with tm.assert_produces_warning(FutureWarning, match=msg):
  320:             result = s.interpolate(method="quadratic", downcast="infer")
  321:         tm.assert_series_equal(result, expected)
  322:         # cubic
  323:         expected = Series([1.0, 3.0, 6.8, 12.0, 18.2, 25.0])
  324:         result = s.interpolate(method="cubic")
  325:         tm.assert_series_equal(result, expected)
  326: 
  327:     def test_interp_limit(self):
  328:         s = Series([1, 3, np.nan, np.nan, np.nan, 11])
  329: 
  330:         expected = Series([1.0, 3.0, 5.0, 7.0, np.nan, 11.0])
  331:         result = s.interpolate(method="linear", limit=2)
  332:         tm.assert_series_equal(result, expected)
  333: 
  334:     @pytest.mark.parametrize("limit", [-1, 0])
  335:     def test_interpolate_invalid_nonpositive_limit(self, nontemporal_method, limit):
  336:         # GH 9217: make sure limit is greater than zero.
  337:         s = Series([1, 2, np.nan, 4])
  338:         method, kwargs = nontemporal_method
  339:         with pytest.raises(ValueError, match="Limit must be greater than 0"):
  340:             s.interpolate(limit=limit, method=method, **kwargs)
  341: 
  342:     def test_interpolate_invalid_float_limit(self, nontemporal_method):
  343:         # GH 9217: make sure limit is an integer.
  344:         s = Series([1, 2, np.nan, 4])
  345:         method, kwargs = nontemporal_method
  346:         limit = 2.0
  347:         with pytest.raises(ValueError, match="Limit must be an integer"):
  348:             s.interpolate(limit=limit, method=method, **kwargs)
  349: 
  350:     @pytest.mark.parametrize("invalid_method", [None, "nonexistent_method"])
  351:     def test_interp_invalid_method(self, invalid_method):
  352:         s = Series([1, 3, np.nan, 12, np.nan, 25])
  353: 
  354:         msg = f"method must be one of.* Got '{invalid_method}' instead"
  355:         if invalid_method is None:
  356:             msg = "'method' should be a string, not None"
  357:         with pytest.raises(ValueError, match=msg):
  358:             s.interpolate(method=invalid_method)
  359: 
  360:         # When an invalid method and invalid limit (such as -1) are
  361:         # provided, the error message reflects the invalid method.
  362:         with pytest.raises(ValueError, match=msg):
  363:             s.interpolate(method=invalid_method, limit=-1)
  364: 
  365:     def test_interp_invalid_method_and_value(self):
  366:         # GH#36624
  367:         ser = Series([1, 3, np.nan, 12, np.nan, 25])
  368: 
  369:         msg = "'fill_value' is not a valid keyword for Series.interpolate"
  370:         msg2 = "Series.interpolate with method=pad"
  371:         with pytest.raises(ValueError, match=msg):
  372:             with tm.assert_produces_warning(FutureWarning, match=msg2):
  373:                 ser.interpolate(fill_value=3, method="pad")
  374: 
  375:     def test_interp_limit_forward(self):
  376:         s = Series([1, 3, np.nan, np.nan, np.nan, 11])
  377: 
  378:         # Provide 'forward' (the default) explicitly here.
  379:         expected = Series([1.0, 3.0, 5.0, 7.0, np.nan, 11.0])
  380: 
  381:         result = s.interpolate(method="linear", limit=2, limit_direction="forward")
  382:         tm.assert_series_equal(result, expected)
  383: 
  384:         result = s.interpolate(method="linear", limit=2, limit_direction="FORWARD")
  385:         tm.assert_series_equal(result, expected)
  386: 
  387:     def test_interp_unlimited(self):
  388:         # these test are for issue #16282 default Limit=None is unlimited
  389:         s = Series([np.nan, 1.0, 3.0, np.nan, np.nan, np.nan, 11.0, np.nan])
  390:         expected = Series([1.0, 1.0, 3.0, 5.0, 7.0, 9.0, 11.0, 11.0])
  391:         result = s.interpolate(method="linear", limit_direction="both")
  392:         tm.assert_series_equal(result, expected)
  393: 
  394:         expected = Series([np.nan, 1.0, 3.0, 5.0, 7.0, 9.0, 11.0, 11.0])
  395:         result = s.interpolate(method="linear", limit_direction="forward")
  396:         tm.assert_series_equal(result, expected)
  397: 
  398:         expected = Series([1.0, 1.0, 3.0, 5.0, 7.0, 9.0, 11.0, np.nan])
  399:         result = s.interpolate(method="linear", limit_direction="backward")
  400:         tm.assert_series_equal(result, expected)
  401: 
  402:     def test_interp_limit_bad_direction(self):
  403:         s = Series([1, 3, np.nan, np.nan, np.nan, 11])
  404: 
  405:         msg = (
  406:             r"Invalid limit_direction: expecting one of \['forward', "
  407:             r"'backward', 'both'\], got 'abc'"
  408:         )
  409:         with pytest.raises(ValueError, match=msg):
  410:             s.interpolate(method="linear", limit=2, limit_direction="abc")
  411: 
  412:         # raises an error even if no limit is specified.
  413:         with pytest.raises(ValueError, match=msg):
  414:             s.interpolate(method="linear", limit_direction="abc")
  415: 
  416:     # limit_area introduced GH #16284
  417:     def test_interp_limit_area(self):
  418:         # These tests are for issue #9218 -- fill NaNs in both directions.
  419:         s = Series([np.nan, np.nan, 3, np.nan, np.nan, np.nan, 7, np.nan, np.nan])
  420: 
  421:         expected = Series([np.nan, np.nan, 3.0, 4.0, 5.0, 6.0, 7.0, np.nan, np.nan])
  422:         result = s.interpolate(method="linear", limit_area="inside")
  423:         tm.assert_series_equal(result, expected)
  424: 
  425:         expected = Series(
  426:             [np.nan, np.nan, 3.0, 4.0, np.nan, np.nan, 7.0, np.nan, np.nan]
  427:         )
  428:         result = s.interpolate(method="linear", limit_area="inside", limit=1)
  429:         tm.assert_series_equal(result, expected)
  430: 
  431:         expected = Series([np.nan, np.nan, 3.0, 4.0, np.nan, 6.0, 7.0, np.nan, np.nan])
  432:         result = s.interpolate(
  433:             method="linear", limit_area="inside", limit_direction="both", limit=1
  434:         )
  435:         tm.assert_series_equal(result, expected)
  436: 
  437:         expected = Series([np.nan, np.nan, 3.0, np.nan, np.nan, np.nan, 7.0, 7.0, 7.0])
  438:         result = s.interpolate(method="linear", limit_area="outside")
  439:         tm.assert_series_equal(result, expected)
  440: 
  441:         expected = Series(
  442:             [np.nan, np.nan, 3.0, np.nan, np.nan, np.nan, 7.0, 7.0, np.nan]
  443:         )
  444:         result = s.interpolate(method="linear", limit_area="outside", limit=1)
  445:         tm.assert_series_equal(result, expected)
  446: 
  447:         expected = Series([np.nan, 3.0, 3.0, np.nan, np.nan, np.nan, 7.0, 7.0, np.nan])
  448:         result = s.interpolate(
  449:             method="linear", limit_area="outside", limit_direction="both", limit=1
  450:         )
  451:         tm.assert_series_equal(result, expected)
  452: 
  453:         expected = Series([3.0, 3.0, 3.0, np.nan, np.nan, np.nan, 7.0, np.nan, np.nan])
  454:         result = s.interpolate(
  455:             method="linear", limit_area="outside", limit_direction="backward"
  456:         )
  457:         tm.assert_series_equal(result, expected)
  458: 
  459:         # raises an error even if limit type is wrong.
  460:         msg = r"Invalid limit_area: expecting one of \['inside', 'outside'\], got abc"
  461:         with pytest.raises(ValueError, match=msg):
  462:             s.interpolate(method="linear", limit_area="abc")
  463: 
  464:     @pytest.mark.parametrize(
  465:         "method, limit_direction, expected",
  466:         [
  467:             ("pad", "backward", "forward"),
  468:             ("ffill", "backward", "forward"),
  469:             ("backfill", "forward", "backward"),
  470:             ("bfill", "forward", "backward"),
  471:             ("pad", "both", "forward"),
  472:             ("ffill", "both", "forward"),
  473:             ("backfill", "both", "backward"),
  474:             ("bfill", "both", "backward"),
  475:         ],
  476:     )
  477:     def test_interp_limit_direction_raises(self, method, limit_direction, expected):
  478:         # https://github.com/pandas-dev/pandas/pull/34746
  479:         s = Series([1, 2, 3])
  480: 
  481:         msg = f"`limit_direction` must be '{expected}' for method `{method}`"
  482:         msg2 = "Series.interpolate with method="
  483:         with pytest.raises(ValueError, match=msg):
  484:             with tm.assert_produces_warning(FutureWarning, match=msg2):
  485:                 s.interpolate(method=method, limit_direction=limit_direction)
  486: 
  487:     @pytest.mark.parametrize(
  488:         "data, expected_data, kwargs",
  489:         (
  490:             (
  491:                 [np.nan, np.nan, 3, np.nan, np.nan, np.nan, 7, np.nan, np.nan],
  492:                 [np.nan, np.nan, 3.0, 3.0, 3.0, 3.0, 7.0, np.nan, np.nan],
  493:                 {"method": "pad", "limit_area": "inside"},
  494:             ),
  495:             (
  496:                 [np.nan, np.nan, 3, np.nan, np.nan, np.nan, 7, np.nan, np.nan],
  497:                 [np.nan, np.nan, 3.0, 3.0, np.nan, np.nan, 7.0, np.nan, np.nan],
  498:                 {"method": "pad", "limit_area": "inside", "limit": 1},
  499:             ),
  500:             (
  501:                 [np.nan, np.nan, 3, np.nan, np.nan, np.nan, 7, np.nan, np.nan],
  502:                 [np.nan, np.nan, 3.0, np.nan, np.nan, np.nan, 7.0, 7.0, 7.0],
  503:                 {"method": "pad", "limit_area": "outside"},
  504:             ),
  505:             (
  506:                 [np.nan, np.nan, 3, np.nan, np.nan, np.nan, 7, np.nan, np.nan],
  507:                 [np.nan, np.nan, 3.0, np.nan, np.nan, np.nan, 7.0, 7.0, np.nan],
  508:                 {"method": "pad", "limit_area": "outside", "limit": 1},
  509:             ),
  510:             (
  511:                 [np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan],
  512:                 [np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan],
  513:                 {"method": "pad", "limit_area": "outside", "limit": 1},
  514:             ),
  515:             (
  516:                 range(5),
  517:                 range(5),
  518:                 {"method": "pad", "limit_area": "outside", "limit": 1},
  519:             ),
  520:         ),
  521:     )
  522:     def test_interp_limit_area_with_pad(self, data, expected_data, kwargs):
  523:         # GH26796
  524: 
  525:         s = Series(data)
  526:         expected = Series(expected_data)
  527:         msg = "Series.interpolate with method=pad"
  528:         with tm.assert_produces_warning(FutureWarning, match=msg):
  529:             result = s.interpolate(**kwargs)
  530:         tm.assert_series_equal(result, expected)
  531: 
  532:     @pytest.mark.parametrize(
  533:         "data, expected_data, kwargs",
  534:         (
  535:             (
  536:                 [np.nan, np.nan, 3, np.nan, np.nan, np.nan, 7, np.nan, np.nan],
  537:                 [np.nan, np.nan, 3.0, 7.0, 7.0, 7.0, 7.0, np.nan, np.nan],
  538:                 {"method": "bfill", "limit_area": "inside"},
  539:             ),
  540:             (
  541:                 [np.nan, np.nan, 3, np.nan, np.nan, np.nan, 7, np.nan, np.nan],
  542:                 [np.nan, np.nan, 3.0, np.nan, np.nan, 7.0, 7.0, np.nan, np.nan],
  543:                 {"method": "bfill", "limit_area": "inside", "limit": 1},
  544:             ),
  545:             (
  546:                 [np.nan, np.nan, 3, np.nan, np.nan, np.nan, 7, np.nan, np.nan],
  547:                 [3.0, 3.0, 3.0, np.nan, np.nan, np.nan, 7.0, np.nan, np.nan],
  548:                 {"method": "bfill", "limit_area": "outside"},
  549:             ),
  550:             (
  551:                 [np.nan, np.nan, 3, np.nan, np.nan, np.nan, 7, np.nan, np.nan],
  552:                 [np.nan, 3.0, 3.0, np.nan, np.nan, np.nan, 7.0, np.nan, np.nan],
  553:                 {"method": "bfill", "limit_area": "outside", "limit": 1},
  554:             ),
  555:         ),
  556:     )
  557:     def test_interp_limit_area_with_backfill(self, data, expected_data, kwargs):
  558:         # GH26796
  559: 
  560:         s = Series(data)
  561:         expected = Series(expected_data)
  562:         msg = "Series.interpolate with method=bfill"
  563:         with tm.assert_produces_warning(FutureWarning, match=msg):
  564:             result = s.interpolate(**kwargs)
  565:         tm.assert_series_equal(result, expected)
  566: 
  567:     def test_interp_limit_direction(self):
  568:         # These tests are for issue #9218 -- fill NaNs in both directions.
  569:         s = Series([1, 3, np.nan, np.nan, np.nan, 11])
  570: 
  571:         expected = Series([1.0, 3.0, np.nan, 7.0, 9.0, 11.0])
  572:         result = s.interpolate(method="linear", limit=2, limit_direction="backward")
  573:         tm.assert_series_equal(result, expected)
  574: 
  575:         expected = Series([1.0, 3.0, 5.0, np.nan, 9.0, 11.0])
  576:         result = s.interpolate(method="linear", limit=1, limit_direction="both")
  577:         tm.assert_series_equal(result, expected)
  578: 
  579:         # Check that this works on a longer series of nans.
  580:         s = Series([1, 3, np.nan, np.nan, np.nan, 7, 9, np.nan, np.nan, 12, np.nan])
  581: 
  582:         expected = Series([1.0, 3.0, 4.0, 5.0, 6.0, 7.0, 9.0, 10.0, 11.0, 12.0, 12.0])
  583:         result = s.interpolate(method="linear", limit=2, limit_direction="both")
  584:         tm.assert_series_equal(result, expected)
  585: 
  586:         expected = Series(
  587:             [1.0, 3.0, 4.0, np.nan, 6.0, 7.0, 9.0, 10.0, 11.0, 12.0, 12.0]
  588:         )
  589:         result = s.interpolate(method="linear", limit=1, limit_direction="both")
  590:         tm.assert_series_equal(result, expected)
  591: 
  592:     def test_interp_limit_to_ends(self):
  593:         # These test are for issue #10420 -- flow back to beginning.
  594:         s = Series([np.nan, np.nan, 5, 7, 9, np.nan])
  595: 
  596:         expected = Series([5.0, 5.0, 5.0, 7.0, 9.0, np.nan])
  597:         result = s.interpolate(method="linear", limit=2, limit_direction="backward")
  598:         tm.assert_series_equal(result, expected)
  599: 
  600:         expected = Series([5.0, 5.0, 5.0, 7.0, 9.0, 9.0])
  601:         result = s.interpolate(method="linear", limit=2, limit_direction="both")
  602:         tm.assert_series_equal(result, expected)
  603: 
  604:     def test_interp_limit_before_ends(self):
  605:         # These test are for issue #11115 -- limit ends properly.
  606:         s = Series([np.nan, np.nan, 5, 7, np.nan, np.nan])
  607: 
  608:         expected = Series([np.nan, np.nan, 5.0, 7.0, 7.0, np.nan])
  609:         result = s.interpolate(method="linear", limit=1, limit_direction="forward")
  610:         tm.assert_series_equal(result, expected)
  611: 
  612:         expected = Series([np.nan, 5.0, 5.0, 7.0, np.nan, np.nan])
  613:         result = s.interpolate(method="linear", limit=1, limit_direction="backward")
  614:         tm.assert_series_equal(result, expected)
  615: 
  616:         expected = Series([np.nan, 5.0, 5.0, 7.0, 7.0, np.nan])
  617:         result = s.interpolate(method="linear", limit=1, limit_direction="both")
  618:         tm.assert_series_equal(result, expected)
  619: 
  620:     def test_interp_all_good(self):
  621:         pytest.importorskip("scipy")
  622:         s = Series([1, 2, 3])
  623:         result = s.interpolate(method="polynomial", order=1)
  624:         tm.assert_series_equal(result, s)
  625: 
  626:         # non-scipy
  627:         result = s.interpolate()
  628:         tm.assert_series_equal(result, s)
  629: 
  630:     @pytest.mark.parametrize(
  631:         "check_scipy", [False, pytest.param(True, marks=td.skip_if_no("scipy"))]
  632:     )
  633:     def test_interp_multiIndex(self, check_scipy):
  634:         idx = MultiIndex.from_tuples([(0, "a"), (1, "b"), (2, "c")])
  635:         s = Series([1, 2, np.nan], index=idx)
  636: 
  637:         expected = s.copy()
  638:         expected.loc[2] = 2
  639:         result = s.interpolate()
  640:         tm.assert_series_equal(result, expected)
  641: 
  642:         msg = "Only `method=linear` interpolation is supported on MultiIndexes"
  643:         if check_scipy:
  644:             with pytest.raises(ValueError, match=msg):
  645:                 s.interpolate(method="polynomial", order=1)
  646: 
  647:     def test_interp_nonmono_raise(self):
  648:         pytest.importorskip("scipy")
  649:         s = Series([1, np.nan, 3], index=[0, 2, 1])
  650:         msg = "krogh interpolation requires that the index be monotonic"
  651:         with pytest.raises(ValueError, match=msg):
  652:             s.interpolate(method="krogh")
  653: 
  654:     @pytest.mark.parametrize("method", ["nearest", "pad"])
  655:     def test_interp_datetime64(self, method, tz_naive_fixture):
  656:         pytest.importorskip("scipy")
  657:         df = Series(
  658:             [1, np.nan, 3], index=date_range("1/1/2000", periods=3, tz=tz_naive_fixture)
  659:         )
  660:         warn = None if method == "nearest" else FutureWarning
  661:         msg = "Series.interpolate with method=pad is deprecated"
  662:         with tm.assert_produces_warning(warn, match=msg):
  663:             result = df.interpolate(method=method)
  664:         if warn is not None:
  665:             # check the "use ffill instead" is equivalent
  666:             alt = df.ffill()
  667:             tm.assert_series_equal(result, alt)
  668: 
  669:         expected = Series(
  670:             [1.0, 1.0, 3.0],
  671:             index=date_range("1/1/2000", periods=3, tz=tz_naive_fixture),
  672:         )
  673:         tm.assert_series_equal(result, expected)
  674: 
  675:     def test_interp_pad_datetime64tz_values(self):
  676:         # GH#27628 missing.interpolate_2d should handle datetimetz values
  677:         dti = date_range("2015-04-05", periods=3, tz="US/Central")
  678:         ser = Series(dti)
  679:         ser[1] = pd.NaT
  680: 
  681:         msg = "Series.interpolate with method=pad is deprecated"
  682:         with tm.assert_produces_warning(FutureWarning, match=msg):
  683:             result = ser.interpolate(method="pad")
  684:         # check the "use ffill instead" is equivalent
  685:         alt = ser.ffill()
  686:         tm.assert_series_equal(result, alt)
  687: 
  688:         expected = Series(dti)
  689:         expected[1] = expected[0]
  690:         tm.assert_series_equal(result, expected)
  691: 
  692:     def test_interp_limit_no_nans(self):
  693:         # GH 7173
  694:         s = Series([1.0, 2.0, 3.0])
  695:         result = s.interpolate(limit=1)
  696:         expected = s
  697:         tm.assert_series_equal(result, expected)
  698: 
  699:     @pytest.mark.parametrize("method", ["polynomial", "spline"])
  700:     def test_no_order(self, method):
  701:         # see GH-10633, GH-24014
  702:         pytest.importorskip("scipy")
  703:         s = Series([0, 1, np.nan, 3])
  704:         msg = "You must specify the order of the spline or polynomial"
  705:         with pytest.raises(ValueError, match=msg):
  706:             s.interpolate(method=method)
  707: 
  708:     @pytest.mark.parametrize("order", [-1, -1.0, 0, 0.0, np.nan])
  709:     def test_interpolate_spline_invalid_order(self, order):
  710:         pytest.importorskip("scipy")
  711:         s = Series([0, 1, np.nan, 3])
  712:         msg = "order needs to be specified and greater than 0"
  713:         with pytest.raises(ValueError, match=msg):
  714:             s.interpolate(method="spline", order=order)
  715: 
  716:     def test_spline(self):
  717:         pytest.importorskip("scipy")
  718:         s = Series([1, 2, np.nan, 4, 5, np.nan, 7])
  719:         result = s.interpolate(method="spline", order=1)
  720:         expected = Series([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0])
  721:         tm.assert_series_equal(result, expected)
  722: 
  723:     def test_spline_extrapolate(self):
  724:         pytest.importorskip("scipy")
  725:         s = Series([1, 2, 3, 4, np.nan, 6, np.nan])
  726:         result3 = s.interpolate(method="spline", order=1, ext=3)
  727:         expected3 = Series([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 6.0])
  728:         tm.assert_series_equal(result3, expected3)
  729: 
  730:         result1 = s.interpolate(method="spline", order=1, ext=0)
  731:         expected1 = Series([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0])
  732:         tm.assert_series_equal(result1, expected1)
  733: 
  734:     def test_spline_smooth(self):
  735:         pytest.importorskip("scipy")
  736:         s = Series([1, 2, np.nan, 4, 5.1, np.nan, 7])
  737:         assert (
  738:             s.interpolate(method="spline", order=3, s=0)[5]
  739:             != s.interpolate(method="spline", order=3)[5]
  740:         )
  741: 
  742:     def test_spline_interpolation(self):
  743:         # Explicit cast to float to avoid implicit cast when setting np.nan
  744:         pytest.importorskip("scipy")
  745:         s = Series(np.arange(10) ** 2, dtype="float")
  746:         s[np.random.default_rng(2).integers(0, 9, 3)] = np.nan
  747:         result1 = s.interpolate(method="spline", order=1)
  748:         expected1 = s.interpolate(method="spline", order=1)
  749:         tm.assert_series_equal(result1, expected1)
  750: 
  751:     def test_interp_timedelta64(self):
  752:         # GH 6424
  753:         df = Series([1, np.nan, 3], index=pd.to_timedelta([1, 2, 3]))
  754:         result = df.interpolate(method="time")
  755:         expected = Series([1.0, 2.0, 3.0], index=pd.to_timedelta([1, 2, 3]))
  756:         tm.assert_series_equal(result, expected)
  757: 
  758:         # test for non uniform spacing
  759:         df = Series([1, np.nan, 3], index=pd.to_timedelta([1, 2, 4]))
  760:         result = df.interpolate(method="time")
  761:         expected = Series([1.0, 1.666667, 3.0], index=pd.to_timedelta([1, 2, 4]))
  762:         tm.assert_series_equal(result, expected)
  763: 
  764:     def test_series_interpolate_method_values(self):
  765:         # GH#1646
  766:         rng = date_range("1/1/2000", "1/20/2000", freq="D")
  767:         ts = Series(np.random.default_rng(2).standard_normal(len(rng)), index=rng)
  768: 
  769:         ts[::2] = np.nan
  770: 
  771:         result = ts.interpolate(method="values")
  772:         exp = ts.interpolate()
  773:         tm.assert_series_equal(result, exp)
  774: 
  775:     def test_series_interpolate_intraday(self):
  776:         # #1698
  777:         index = date_range("1/1/2012", periods=4, freq="12D")
  778:         ts = Series([0, 12, 24, 36], index)
  779:         new_index = index.append(index + pd.DateOffset(days=1)).sort_values()
  780: 
  781:         exp = ts.reindex(new_index).interpolate(method="time")
  782: 
  783:         index = date_range("1/1/2012", periods=4, freq="12h")
  784:         ts = Series([0, 12, 24, 36], index)
  785:         new_index = index.append(index + pd.DateOffset(hours=1)).sort_values()
  786:         result = ts.reindex(new_index).interpolate(method="time")
  787: 
  788:         tm.assert_numpy_array_equal(result.values, exp.values)
  789: 
  790:     @pytest.mark.parametrize(
  791:         "ind",
  792:         [
  793:             ["a", "b", "c", "d"],
  794:             pd.period_range(start="2019-01-01", periods=4),
  795:             pd.interval_range(start=0, end=4),
  796:         ],
  797:     )
  798:     def test_interp_non_timedelta_index(self, interp_methods_ind, ind):
  799:         # gh 21662
  800:         df = pd.DataFrame([0, 1, np.nan, 3], index=ind)
  801: 
  802:         method, kwargs = interp_methods_ind
  803:         if method == "pchip":
  804:             pytest.importorskip("scipy")
  805: 
  806:         if method == "linear":
  807:             result = df[0].interpolate(**kwargs)
  808:             expected = Series([0.0, 1.0, 2.0, 3.0], name=0, index=ind)
  809:             tm.assert_series_equal(result, expected)
  810:         else:
  811:             expected_error = (
  812:                 "Index column must be numeric or datetime type when "
  813:                 f"using {method} method other than linear. "
  814:                 "Try setting a numeric or datetime index column before "
  815:                 "interpolating."
  816:             )
  817:             with pytest.raises(ValueError, match=expected_error):
  818:                 df[0].interpolate(method=method, **kwargs)
  819: 
  820:     def test_interpolate_timedelta_index(self, request, interp_methods_ind):
  821:         """
  822:         Tests for non numerical index types  - object, period, timedelta
  823:         Note that all methods except time, index, nearest and values
  824:         are tested here.
  825:         """
  826:         # gh 21662
  827:         pytest.importorskip("scipy")
  828:         ind = pd.timedelta_range(start=1, periods=4)
  829:         df = pd.DataFrame([0, 1, np.nan, 3], index=ind)
  830: 
  831:         method, kwargs = interp_methods_ind
  832: 
  833:         if method in {"cubic", "zero"}:
  834:             request.applymarker(
  835:                 pytest.mark.xfail(
  836:                     reason=f"{method} interpolation is not supported for TimedeltaIndex"
  837:                 )
  838:             )
  839:         result = df[0].interpolate(method=method, **kwargs)
  840:         expected = Series([0.0, 1.0, 2.0, 3.0], name=0, index=ind)
  841:         tm.assert_series_equal(result, expected)
  842: 
  843:     @pytest.mark.parametrize(
  844:         "ascending, expected_values",
  845:         [(True, [1, 2, 3, 9, 10]), (False, [10, 9, 3, 2, 1])],
  846:     )
  847:     def test_interpolate_unsorted_index(self, ascending, expected_values):
  848:         # GH 21037
  849:         ts = Series(data=[10, 9, np.nan, 2, 1], index=[10, 9, 3, 2, 1])
  850:         result = ts.sort_index(ascending=ascending).interpolate(method="index")
  851:         expected = Series(data=expected_values, index=expected_values, dtype=float)
  852:         tm.assert_series_equal(result, expected)
  853: 
  854:     def test_interpolate_asfreq_raises(self):
  855:         ser = Series(["a", None, "b"], dtype=object)
  856:         msg2 = "Series.interpolate with object dtype"
  857:         msg = "Invalid fill method"
  858:         with pytest.raises(ValueError, match=msg):
  859:             with tm.assert_produces_warning(FutureWarning, match=msg2):
  860:                 ser.interpolate(method="asfreq")
  861: 
  862:     def test_interpolate_fill_value(self):
  863:         # GH#54920
  864:         pytest.importorskip("scipy")
  865:         ser = Series([np.nan, 0, 1, np.nan, 3, np.nan])
  866:         result = ser.interpolate(method="nearest", fill_value=0)
  867:         expected = Series([np.nan, 0, 1, 1, 3, 0])
  868:         tm.assert_series_equal(result, expected)
