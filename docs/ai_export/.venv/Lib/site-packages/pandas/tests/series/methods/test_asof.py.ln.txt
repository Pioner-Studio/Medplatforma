    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas._libs.tslibs import IncompatibleFrequency
    5: 
    6: from pandas import (
    7:     DatetimeIndex,
    8:     PeriodIndex,
    9:     Series,
   10:     Timestamp,
   11:     date_range,
   12:     isna,
   13:     notna,
   14:     offsets,
   15:     period_range,
   16: )
   17: import pandas._testing as tm
   18: 
   19: 
   20: class TestSeriesAsof:
   21:     def test_asof_nanosecond_index_access(self):
   22:         ts = Timestamp("20130101").as_unit("ns")._value
   23:         dti = DatetimeIndex([ts + 50 + i for i in range(100)])
   24:         ser = Series(np.random.default_rng(2).standard_normal(100), index=dti)
   25: 
   26:         first_value = ser.asof(ser.index[0])
   27: 
   28:         # GH#46903 previously incorrectly was "day"
   29:         assert dti.resolution == "nanosecond"
   30: 
   31:         # this used to not work bc parsing was done by dateutil that didn't
   32:         #  handle nanoseconds
   33:         assert first_value == ser["2013-01-01 00:00:00.000000050"]
   34: 
   35:         expected_ts = np.datetime64("2013-01-01 00:00:00.000000050", "ns")
   36:         assert first_value == ser[Timestamp(expected_ts)]
   37: 
   38:     def test_basic(self):
   39:         # array or list or dates
   40:         N = 50
   41:         rng = date_range("1/1/1990", periods=N, freq="53s")
   42:         ts = Series(np.random.default_rng(2).standard_normal(N), index=rng)
   43:         ts.iloc[15:30] = np.nan
   44:         dates = date_range("1/1/1990", periods=N * 3, freq="25s")
   45: 
   46:         result = ts.asof(dates)
   47:         assert notna(result).all()
   48:         lb = ts.index[14]
   49:         ub = ts.index[30]
   50: 
   51:         result = ts.asof(list(dates))
   52:         assert notna(result).all()
   53:         lb = ts.index[14]
   54:         ub = ts.index[30]
   55: 
   56:         mask = (result.index >= lb) & (result.index < ub)
   57:         rs = result[mask]
   58:         assert (rs == ts[lb]).all()
   59: 
   60:         val = result[result.index[result.index >= ub][0]]
   61:         assert ts[ub] == val
   62: 
   63:     def test_scalar(self):
   64:         N = 30
   65:         rng = date_range("1/1/1990", periods=N, freq="53s")
   66:         # Explicit cast to float avoid implicit cast when setting nan
   67:         ts = Series(np.arange(N), index=rng, dtype="float")
   68:         ts.iloc[5:10] = np.nan
   69:         ts.iloc[15:20] = np.nan
   70: 
   71:         val1 = ts.asof(ts.index[7])
   72:         val2 = ts.asof(ts.index[19])
   73: 
   74:         assert val1 == ts.iloc[4]
   75:         assert val2 == ts.iloc[14]
   76: 
   77:         # accepts strings
   78:         val1 = ts.asof(str(ts.index[7]))
   79:         assert val1 == ts.iloc[4]
   80: 
   81:         # in there
   82:         result = ts.asof(ts.index[3])
   83:         assert result == ts.iloc[3]
   84: 
   85:         # no as of value
   86:         d = ts.index[0] - offsets.BDay()
   87:         assert np.isnan(ts.asof(d))
   88: 
   89:     def test_with_nan(self):
   90:         # basic asof test
   91:         rng = date_range("1/1/2000", "1/2/2000", freq="4h")
   92:         s = Series(np.arange(len(rng)), index=rng)
   93:         r = s.resample("2h").mean()
   94: 
   95:         result = r.asof(r.index)
   96:         expected = Series(
   97:             [0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6.0],
   98:             index=date_range("1/1/2000", "1/2/2000", freq="2h"),
   99:         )
  100:         tm.assert_series_equal(result, expected)
  101: 
  102:         r.iloc[3:5] = np.nan
  103:         result = r.asof(r.index)
  104:         expected = Series(
  105:             [0, 0, 1, 1, 1, 1, 3, 3, 4, 4, 5, 5, 6.0],
  106:             index=date_range("1/1/2000", "1/2/2000", freq="2h"),
  107:         )
  108:         tm.assert_series_equal(result, expected)
  109: 
  110:         r.iloc[-3:] = np.nan
  111:         result = r.asof(r.index)
  112:         expected = Series(
  113:             [0, 0, 1, 1, 1, 1, 3, 3, 4, 4, 4, 4, 4.0],
  114:             index=date_range("1/1/2000", "1/2/2000", freq="2h"),
  115:         )
  116:         tm.assert_series_equal(result, expected)
  117: 
  118:     def test_periodindex(self):
  119:         # array or list or dates
  120:         N = 50
  121:         rng = period_range("1/1/1990", periods=N, freq="h")
  122:         ts = Series(np.random.default_rng(2).standard_normal(N), index=rng)
  123:         ts.iloc[15:30] = np.nan
  124:         dates = date_range("1/1/1990", periods=N * 3, freq="37min")
  125: 
  126:         result = ts.asof(dates)
  127:         assert notna(result).all()
  128:         lb = ts.index[14]
  129:         ub = ts.index[30]
  130: 
  131:         result = ts.asof(list(dates))
  132:         assert notna(result).all()
  133:         lb = ts.index[14]
  134:         ub = ts.index[30]
  135: 
  136:         pix = PeriodIndex(result.index.values, freq="h")
  137:         mask = (pix >= lb) & (pix < ub)
  138:         rs = result[mask]
  139:         assert (rs == ts[lb]).all()
  140: 
  141:         ts.iloc[5:10] = np.nan
  142:         ts.iloc[15:20] = np.nan
  143: 
  144:         val1 = ts.asof(ts.index[7])
  145:         val2 = ts.asof(ts.index[19])
  146: 
  147:         assert val1 == ts.iloc[4]
  148:         assert val2 == ts.iloc[14]
  149: 
  150:         # accepts strings
  151:         val1 = ts.asof(str(ts.index[7]))
  152:         assert val1 == ts.iloc[4]
  153: 
  154:         # in there
  155:         assert ts.asof(ts.index[3]) == ts.iloc[3]
  156: 
  157:         # no as of value
  158:         d = ts.index[0].to_timestamp() - offsets.BDay()
  159:         assert isna(ts.asof(d))
  160: 
  161:         # Mismatched freq
  162:         msg = "Input has different freq"
  163:         with pytest.raises(IncompatibleFrequency, match=msg):
  164:             ts.asof(rng.asfreq("D"))
  165: 
  166:     def test_errors(self):
  167:         s = Series(
  168:             [1, 2, 3],
  169:             index=[Timestamp("20130101"), Timestamp("20130103"), Timestamp("20130102")],
  170:         )
  171: 
  172:         # non-monotonic
  173:         assert not s.index.is_monotonic_increasing
  174:         with pytest.raises(ValueError, match="requires a sorted index"):
  175:             s.asof(s.index[0])
  176: 
  177:         # subset with Series
  178:         N = 10
  179:         rng = date_range("1/1/1990", periods=N, freq="53s")
  180:         s = Series(np.random.default_rng(2).standard_normal(N), index=rng)
  181:         with pytest.raises(ValueError, match="not valid for Series"):
  182:             s.asof(s.index[0], subset="foo")
  183: 
  184:     def test_all_nans(self):
  185:         # GH 15713
  186:         # series is all nans
  187: 
  188:         # testing non-default indexes
  189:         N = 50
  190:         rng = date_range("1/1/1990", periods=N, freq="53s")
  191: 
  192:         dates = date_range("1/1/1990", periods=N * 3, freq="25s")
  193:         result = Series(np.nan, index=rng).asof(dates)
  194:         expected = Series(np.nan, index=dates)
  195:         tm.assert_series_equal(result, expected)
  196: 
  197:         # testing scalar input
  198:         date = date_range("1/1/1990", periods=N * 3, freq="25s")[0]
  199:         result = Series(np.nan, index=rng).asof(date)
  200:         assert isna(result)
  201: 
  202:         # test name is propagated
  203:         result = Series(np.nan, index=[1, 2, 3, 4], name="test").asof([4, 5])
  204:         expected = Series(np.nan, index=[4, 5], name="test")
  205:         tm.assert_series_equal(result, expected)
