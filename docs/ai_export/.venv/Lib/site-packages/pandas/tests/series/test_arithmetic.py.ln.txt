    1: from datetime import (
    2:     date,
    3:     timedelta,
    4:     timezone,
    5: )
    6: from decimal import Decimal
    7: import operator
    8: 
    9: import numpy as np
   10: import pytest
   11: 
   12: from pandas._libs import lib
   13: from pandas._libs.tslibs import IncompatibleFrequency
   14: 
   15: import pandas as pd
   16: from pandas import (
   17:     Categorical,
   18:     DatetimeTZDtype,
   19:     Index,
   20:     Series,
   21:     Timedelta,
   22:     bdate_range,
   23:     date_range,
   24:     isna,
   25: )
   26: import pandas._testing as tm
   27: from pandas.core import ops
   28: from pandas.core.computation import expressions as expr
   29: from pandas.core.computation.check import NUMEXPR_INSTALLED
   30: 
   31: 
   32: @pytest.fixture(autouse=True, params=[0, 1000000], ids=["numexpr", "python"])
   33: def switch_numexpr_min_elements(request, monkeypatch):
   34:     with monkeypatch.context() as m:
   35:         m.setattr(expr, "_MIN_ELEMENTS", request.param)
   36:         yield
   37: 
   38: 
   39: def _permute(obj):
   40:     return obj.take(np.random.default_rng(2).permutation(len(obj)))
   41: 
   42: 
   43: class TestSeriesFlexArithmetic:
   44:     @pytest.mark.parametrize(
   45:         "ts",
   46:         [
   47:             (lambda x: x, lambda x: x * 2, False),
   48:             (lambda x: x, lambda x: x[::2], False),
   49:             (lambda x: x, lambda x: 5, True),
   50:             (
   51:                 lambda x: Series(range(10), dtype=np.float64),
   52:                 lambda x: Series(range(10), dtype=np.float64),
   53:                 True,
   54:             ),
   55:         ],
   56:     )
   57:     @pytest.mark.parametrize(
   58:         "opname", ["add", "sub", "mul", "floordiv", "truediv", "pow"]
   59:     )
   60:     def test_flex_method_equivalence(self, opname, ts):
   61:         # check that Series.{opname} behaves like Series.__{opname}__,
   62:         tser = Series(
   63:             np.arange(20, dtype=np.float64),
   64:             index=date_range("2020-01-01", periods=20),
   65:             name="ts",
   66:         )
   67: 
   68:         series = ts[0](tser)
   69:         other = ts[1](tser)
   70:         check_reverse = ts[2]
   71: 
   72:         op = getattr(Series, opname)
   73:         alt = getattr(operator, opname)
   74: 
   75:         result = op(series, other)
   76:         expected = alt(series, other)
   77:         tm.assert_almost_equal(result, expected)
   78:         if check_reverse:
   79:             rop = getattr(Series, "r" + opname)
   80:             result = rop(series, other)
   81:             expected = alt(other, series)
   82:             tm.assert_almost_equal(result, expected)
   83: 
   84:     def test_flex_method_subclass_metadata_preservation(self, all_arithmetic_operators):
   85:         # GH 13208
   86:         class MySeries(Series):
   87:             _metadata = ["x"]
   88: 
   89:             @property
   90:             def _constructor(self):
   91:                 return MySeries
   92: 
   93:         opname = all_arithmetic_operators
   94:         op = getattr(Series, opname)
   95:         m = MySeries([1, 2, 3], name="test")
   96:         m.x = 42
   97:         result = op(m, 1)
   98:         assert result.x == 42
   99: 
  100:     def test_flex_add_scalar_fill_value(self):
  101:         # GH12723
  102:         ser = Series([0, 1, np.nan, 3, 4, 5])
  103: 
  104:         exp = ser.fillna(0).add(2)
  105:         res = ser.add(2, fill_value=0)
  106:         tm.assert_series_equal(res, exp)
  107: 
  108:     pairings = [(Series.div, operator.truediv, 1), (Series.rdiv, ops.rtruediv, 1)]
  109:     for op in ["add", "sub", "mul", "pow", "truediv", "floordiv"]:
  110:         fv = 0
  111:         lop = getattr(Series, op)
  112:         lequiv = getattr(operator, op)
  113:         rop = getattr(Series, "r" + op)
  114:         # bind op at definition time...
  115:         requiv = lambda x, y, op=op: getattr(operator, op)(y, x)
  116:         pairings.append((lop, lequiv, fv))
  117:         pairings.append((rop, requiv, fv))
  118: 
  119:     @pytest.mark.parametrize("op, equiv_op, fv", pairings)
  120:     def test_operators_combine(self, op, equiv_op, fv):
  121:         def _check_fill(meth, op, a, b, fill_value=0):
  122:             exp_index = a.index.union(b.index)
  123:             a = a.reindex(exp_index)
  124:             b = b.reindex(exp_index)
  125: 
  126:             amask = isna(a)
  127:             bmask = isna(b)
  128: 
  129:             exp_values = []
  130:             for i in range(len(exp_index)):
  131:                 with np.errstate(all="ignore"):
  132:                     if amask[i]:
  133:                         if bmask[i]:
  134:                             exp_values.append(np.nan)
  135:                             continue
  136:                         exp_values.append(op(fill_value, b[i]))
  137:                     elif bmask[i]:
  138:                         if amask[i]:
  139:                             exp_values.append(np.nan)
  140:                             continue
  141:                         exp_values.append(op(a[i], fill_value))
  142:                     else:
  143:                         exp_values.append(op(a[i], b[i]))
  144: 
  145:             result = meth(a, b, fill_value=fill_value)
  146:             expected = Series(exp_values, exp_index)
  147:             tm.assert_series_equal(result, expected)
  148: 
  149:         a = Series([np.nan, 1.0, 2.0, 3.0, np.nan], index=np.arange(5))
  150:         b = Series([np.nan, 1, np.nan, 3, np.nan, 4.0], index=np.arange(6))
  151: 
  152:         result = op(a, b)
  153:         exp = equiv_op(a, b)
  154:         tm.assert_series_equal(result, exp)
  155:         _check_fill(op, equiv_op, a, b, fill_value=fv)
  156:         # should accept axis=0 or axis='rows'
  157:         op(a, b, axis=0)
  158: 
  159: 
  160: class TestSeriesArithmetic:
  161:     # Some of these may end up in tests/arithmetic, but are not yet sorted
  162: 
  163:     def test_add_series_with_period_index(self):
  164:         rng = pd.period_range("1/1/2000", "1/1/2010", freq="Y")
  165:         ts = Series(np.random.default_rng(2).standard_normal(len(rng)), index=rng)
  166: 
  167:         result = ts + ts[::2]
  168:         expected = ts + ts
  169:         expected.iloc[1::2] = np.nan
  170:         tm.assert_series_equal(result, expected)
  171: 
  172:         result = ts + _permute(ts[::2])
  173:         tm.assert_series_equal(result, expected)
  174: 
  175:         msg = "Input has different freq=D from Period\\(freq=Y-DEC\\)"
  176:         with pytest.raises(IncompatibleFrequency, match=msg):
  177:             ts + ts.asfreq("D", how="end")
  178: 
  179:     @pytest.mark.parametrize(
  180:         "target_add,input_value,expected_value",
  181:         [
  182:             ("!", ["hello", "world"], ["hello!", "world!"]),
  183:             ("m", ["hello", "world"], ["hellom", "worldm"]),
  184:         ],
  185:     )
  186:     def test_string_addition(self, target_add, input_value, expected_value):
  187:         # GH28658 - ensure adding 'm' does not raise an error
  188:         a = Series(input_value)
  189: 
  190:         result = a + target_add
  191:         expected = Series(expected_value)
  192:         tm.assert_series_equal(result, expected)
  193: 
  194:     def test_divmod(self):
  195:         # GH#25557
  196:         a = Series([1, 1, 1, np.nan], index=["a", "b", "c", "d"])
  197:         b = Series([2, np.nan, 1, np.nan], index=["a", "b", "d", "e"])
  198: 
  199:         result = a.divmod(b)
  200:         expected = divmod(a, b)
  201:         tm.assert_series_equal(result[0], expected[0])
  202:         tm.assert_series_equal(result[1], expected[1])
  203: 
  204:         result = a.rdivmod(b)
  205:         expected = divmod(b, a)
  206:         tm.assert_series_equal(result[0], expected[0])
  207:         tm.assert_series_equal(result[1], expected[1])
  208: 
  209:     @pytest.mark.parametrize("index", [None, range(9)])
  210:     def test_series_integer_mod(self, index):
  211:         # GH#24396
  212:         s1 = Series(range(1, 10))
  213:         s2 = Series("foo", index=index)
  214: 
  215:         msg = "not all arguments converted during string formatting|mod not"
  216: 
  217:         with pytest.raises((TypeError, NotImplementedError), match=msg):
  218:             s2 % s1
  219: 
  220:     def test_add_with_duplicate_index(self):
  221:         # GH14227
  222:         s1 = Series([1, 2], index=[1, 1])
  223:         s2 = Series([10, 10], index=[1, 2])
  224:         result = s1 + s2
  225:         expected = Series([11, 12, np.nan], index=[1, 1, 2])
  226:         tm.assert_series_equal(result, expected)
  227: 
  228:     def test_add_na_handling(self):
  229:         ser = Series(
  230:             [Decimal("1.3"), Decimal("2.3")], index=[date(2012, 1, 1), date(2012, 1, 2)]
  231:         )
  232: 
  233:         result = ser + ser.shift(1)
  234:         result2 = ser.shift(1) + ser
  235:         assert isna(result.iloc[0])
  236:         assert isna(result2.iloc[0])
  237: 
  238:     def test_add_corner_cases(self, datetime_series):
  239:         empty = Series([], index=Index([]), dtype=np.float64)
  240: 
  241:         result = datetime_series + empty
  242:         assert np.isnan(result).all()
  243: 
  244:         result = empty + empty.copy()
  245:         assert len(result) == 0
  246: 
  247:     def test_add_float_plus_int(self, datetime_series):
  248:         # float + int
  249:         int_ts = datetime_series.astype(int)[:-5]
  250:         added = datetime_series + int_ts
  251:         expected = Series(
  252:             datetime_series.values[:-5] + int_ts.values,
  253:             index=datetime_series.index[:-5],
  254:             name="ts",
  255:         )
  256:         tm.assert_series_equal(added[:-5], expected)
  257: 
  258:     def test_mul_empty_int_corner_case(self):
  259:         s1 = Series([], [], dtype=np.int32)
  260:         s2 = Series({"x": 0.0})
  261:         tm.assert_series_equal(s1 * s2, Series([np.nan], index=["x"]))
  262: 
  263:     def test_sub_datetimelike_align(self):
  264:         # GH#7500
  265:         # datetimelike ops need to align
  266:         dt = Series(date_range("2012-1-1", periods=3, freq="D"))
  267:         dt.iloc[2] = np.nan
  268:         dt2 = dt[::-1]
  269: 
  270:         expected = Series([timedelta(0), timedelta(0), pd.NaT])
  271:         # name is reset
  272:         result = dt2 - dt
  273:         tm.assert_series_equal(result, expected)
  274: 
  275:         expected = Series(expected, name=0)
  276:         result = (dt2.to_frame() - dt.to_frame())[0]
  277:         tm.assert_series_equal(result, expected)
  278: 
  279:     def test_alignment_doesnt_change_tz(self):
  280:         # GH#33671
  281:         dti = date_range("2016-01-01", periods=10, tz="CET")
  282:         dti_utc = dti.tz_convert("UTC")
  283:         ser = Series(10, index=dti)
  284:         ser_utc = Series(10, index=dti_utc)
  285: 
  286:         # we don't care about the result, just that original indexes are unchanged
  287:         ser * ser_utc
  288: 
  289:         assert ser.index is dti
  290:         assert ser_utc.index is dti_utc
  291: 
  292:     def test_alignment_categorical(self):
  293:         # GH13365
  294:         cat = Categorical(["3z53", "3z53", "LoJG", "LoJG", "LoJG", "N503"])
  295:         ser1 = Series(2, index=cat)
  296:         ser2 = Series(2, index=cat[:-1])
  297:         result = ser1 * ser2
  298: 
  299:         exp_index = ["3z53"] * 4 + ["LoJG"] * 9 + ["N503"]
  300:         exp_index = pd.CategoricalIndex(exp_index, categories=cat.categories)
  301:         exp_values = [4.0] * 13 + [np.nan]
  302:         expected = Series(exp_values, exp_index)
  303: 
  304:         tm.assert_series_equal(result, expected)
  305: 
  306:     def test_arithmetic_with_duplicate_index(self):
  307:         # GH#8363
  308:         # integer ops with a non-unique index
  309:         index = [2, 2, 3, 3, 4]
  310:         ser = Series(np.arange(1, 6, dtype="int64"), index=index)
  311:         other = Series(np.arange(5, dtype="int64"), index=index)
  312:         result = ser - other
  313:         expected = Series(1, index=[2, 2, 3, 3, 4])
  314:         tm.assert_series_equal(result, expected)
  315: 
  316:         # GH#8363
  317:         # datetime ops with a non-unique index
  318:         ser = Series(date_range("20130101 09:00:00", periods=5), index=index)
  319:         other = Series(date_range("20130101", periods=5), index=index)
  320:         result = ser - other
  321:         expected = Series(Timedelta("9 hours"), index=[2, 2, 3, 3, 4])
  322:         tm.assert_series_equal(result, expected)
  323: 
  324:     def test_masked_and_non_masked_propagate_na(self):
  325:         # GH#45810
  326:         ser1 = Series([0, np.nan], dtype="float")
  327:         ser2 = Series([0, 1], dtype="Int64")
  328:         result = ser1 * ser2
  329:         expected = Series([0, pd.NA], dtype="Float64")
  330:         tm.assert_series_equal(result, expected)
  331: 
  332:     def test_mask_div_propagate_na_for_non_na_dtype(self):
  333:         # GH#42630
  334:         ser1 = Series([15, pd.NA, 5, 4], dtype="Int64")
  335:         ser2 = Series([15, 5, np.nan, 4])
  336:         result = ser1 / ser2
  337:         expected = Series([1.0, pd.NA, pd.NA, 1.0], dtype="Float64")
  338:         tm.assert_series_equal(result, expected)
  339: 
  340:         result = ser2 / ser1
  341:         tm.assert_series_equal(result, expected)
  342: 
  343:     @pytest.mark.parametrize("val, dtype", [(3, "Int64"), (3.5, "Float64")])
  344:     def test_add_list_to_masked_array(self, val, dtype):
  345:         # GH#22962
  346:         ser = Series([1, None, 3], dtype="Int64")
  347:         result = ser + [1, None, val]
  348:         expected = Series([2, None, 3 + val], dtype=dtype)
  349:         tm.assert_series_equal(result, expected)
  350: 
  351:         result = [1, None, val] + ser
  352:         tm.assert_series_equal(result, expected)
  353: 
  354:     def test_add_list_to_masked_array_boolean(self, request):
  355:         # GH#22962
  356:         warning = (
  357:             UserWarning
  358:             if request.node.callspec.id == "numexpr" and NUMEXPR_INSTALLED
  359:             else None
  360:         )
  361:         ser = Series([True, None, False], dtype="boolean")
  362:         with tm.assert_produces_warning(warning):
  363:             result = ser + [True, None, True]
  364:         expected = Series([True, None, True], dtype="boolean")
  365:         tm.assert_series_equal(result, expected)
  366: 
  367:         with tm.assert_produces_warning(warning):
  368:             result = [True, None, True] + ser
  369:         tm.assert_series_equal(result, expected)
  370: 
  371: 
  372: # ------------------------------------------------------------------
  373: # Comparisons
  374: 
  375: 
  376: class TestSeriesFlexComparison:
  377:     @pytest.mark.parametrize("axis", [0, None, "index"])
  378:     def test_comparison_flex_basic(self, axis, comparison_op):
  379:         left = Series(np.random.default_rng(2).standard_normal(10))
  380:         right = Series(np.random.default_rng(2).standard_normal(10))
  381:         result = getattr(left, comparison_op.__name__)(right, axis=axis)
  382:         expected = comparison_op(left, right)
  383:         tm.assert_series_equal(result, expected)
  384: 
  385:     def test_comparison_bad_axis(self, comparison_op):
  386:         left = Series(np.random.default_rng(2).standard_normal(10))
  387:         right = Series(np.random.default_rng(2).standard_normal(10))
  388: 
  389:         msg = "No axis named 1 for object type"
  390:         with pytest.raises(ValueError, match=msg):
  391:             getattr(left, comparison_op.__name__)(right, axis=1)
  392: 
  393:     @pytest.mark.parametrize(
  394:         "values, op",
  395:         [
  396:             ([False, False, True, False], "eq"),
  397:             ([True, True, False, True], "ne"),
  398:             ([False, False, True, False], "le"),
  399:             ([False, False, False, False], "lt"),
  400:             ([False, True, True, False], "ge"),
  401:             ([False, True, False, False], "gt"),
  402:         ],
  403:     )
  404:     def test_comparison_flex_alignment(self, values, op):
  405:         left = Series([1, 3, 2], index=list("abc"))
  406:         right = Series([2, 2, 2], index=list("bcd"))
  407:         result = getattr(left, op)(right)
  408:         expected = Series(values, index=list("abcd"))
  409:         tm.assert_series_equal(result, expected)
  410: 
  411:     @pytest.mark.parametrize(
  412:         "values, op, fill_value",
  413:         [
  414:             ([False, False, True, True], "eq", 2),
  415:             ([True, True, False, False], "ne", 2),
  416:             ([False, False, True, True], "le", 0),
  417:             ([False, False, False, True], "lt", 0),
  418:             ([True, True, True, False], "ge", 0),
  419:             ([True, True, False, False], "gt", 0),
  420:         ],
  421:     )
  422:     def test_comparison_flex_alignment_fill(self, values, op, fill_value):
  423:         left = Series([1, 3, 2], index=list("abc"))
  424:         right = Series([2, 2, 2], index=list("bcd"))
  425:         result = getattr(left, op)(right, fill_value=fill_value)
  426:         expected = Series(values, index=list("abcd"))
  427:         tm.assert_series_equal(result, expected)
  428: 
  429: 
  430: class TestSeriesComparison:
  431:     def test_comparison_different_length(self):
  432:         a = Series(["a", "b", "c"])
  433:         b = Series(["b", "a"])
  434:         msg = "only compare identically-labeled Series"
  435:         with pytest.raises(ValueError, match=msg):
  436:             a < b
  437: 
  438:         a = Series([1, 2])
  439:         b = Series([2, 3, 4])
  440:         with pytest.raises(ValueError, match=msg):
  441:             a == b
  442: 
  443:     @pytest.mark.parametrize("opname", ["eq", "ne", "gt", "lt", "ge", "le"])
  444:     def test_ser_flex_cmp_return_dtypes(self, opname):
  445:         # GH#15115
  446:         ser = Series([1, 3, 2], index=range(3))
  447:         const = 2
  448:         result = getattr(ser, opname)(const).dtypes
  449:         expected = np.dtype("bool")
  450:         assert result == expected
  451: 
  452:     @pytest.mark.parametrize("opname", ["eq", "ne", "gt", "lt", "ge", "le"])
  453:     def test_ser_flex_cmp_return_dtypes_empty(self, opname):
  454:         # GH#15115 empty Series case
  455:         ser = Series([1, 3, 2], index=range(3))
  456:         empty = ser.iloc[:0]
  457:         const = 2
  458:         result = getattr(empty, opname)(const).dtypes
  459:         expected = np.dtype("bool")
  460:         assert result == expected
  461: 
  462:     @pytest.mark.parametrize(
  463:         "names", [(None, None, None), ("foo", "bar", None), ("baz", "baz", "baz")]
  464:     )
  465:     def test_ser_cmp_result_names(self, names, comparison_op):
  466:         # datetime64 dtype
  467:         op = comparison_op
  468:         dti = date_range("1949-06-07 03:00:00", freq="h", periods=5, name=names[0])
  469:         ser = Series(dti).rename(names[1])
  470:         result = op(ser, dti)
  471:         assert result.name == names[2]
  472: 
  473:         # datetime64tz dtype
  474:         dti = dti.tz_localize("US/Central")
  475:         dti = pd.DatetimeIndex(dti, freq="infer")  # freq not preserved by tz_localize
  476:         ser = Series(dti).rename(names[1])
  477:         result = op(ser, dti)
  478:         assert result.name == names[2]
  479: 
  480:         # timedelta64 dtype
  481:         tdi = dti - dti.shift(1)
  482:         ser = Series(tdi).rename(names[1])
  483:         result = op(ser, tdi)
  484:         assert result.name == names[2]
  485: 
  486:         # interval dtype
  487:         if op in [operator.eq, operator.ne]:
  488:             # interval dtype comparisons not yet implemented
  489:             ii = pd.interval_range(start=0, periods=5, name=names[0])
  490:             ser = Series(ii).rename(names[1])
  491:             result = op(ser, ii)
  492:             assert result.name == names[2]
  493: 
  494:         # categorical
  495:         if op in [operator.eq, operator.ne]:
  496:             # categorical dtype comparisons raise for inequalities
  497:             cidx = tdi.astype("category")
  498:             ser = Series(cidx).rename(names[1])
  499:             result = op(ser, cidx)
  500:             assert result.name == names[2]
  501: 
  502:     def test_comparisons(self, using_infer_string):
  503:         s = Series(["a", "b", "c"])
  504:         s2 = Series([False, True, False])
  505: 
  506:         # it works!
  507:         exp = Series([False, False, False])
  508:         if using_infer_string:
  509:             import pyarrow as pa
  510: 
  511:             msg = "has no kernel"
  512:             # TODO(3.0) GH56008
  513:             with pytest.raises(pa.lib.ArrowNotImplementedError, match=msg):
  514:                 s == s2
  515:             with tm.assert_produces_warning(
  516:                 DeprecationWarning, match="comparison", check_stacklevel=False
  517:             ):
  518:                 with pytest.raises(pa.lib.ArrowNotImplementedError, match=msg):
  519:                     s2 == s
  520:         else:
  521:             tm.assert_series_equal(s == s2, exp)
  522:             tm.assert_series_equal(s2 == s, exp)
  523: 
  524:     # -----------------------------------------------------------------
  525:     # Categorical Dtype Comparisons
  526: 
  527:     def test_categorical_comparisons(self):
  528:         # GH#8938
  529:         # allow equality comparisons
  530:         a = Series(list("abc"), dtype="category")
  531:         b = Series(list("abc"), dtype="object")
  532:         c = Series(["a", "b", "cc"], dtype="object")
  533:         d = Series(list("acb"), dtype="object")
  534:         e = Categorical(list("abc"))
  535:         f = Categorical(list("acb"))
  536: 
  537:         # vs scalar
  538:         assert not (a == "a").all()
  539:         assert ((a != "a") == ~(a == "a")).all()
  540: 
  541:         assert not ("a" == a).all()
  542:         assert (a == "a")[0]
  543:         assert ("a" == a)[0]
  544:         assert not ("a" != a)[0]
  545: 
  546:         # vs list-like
  547:         assert (a == a).all()
  548:         assert not (a != a).all()
  549: 
  550:         assert (a == list(a)).all()
  551:         assert (a == b).all()
  552:         assert (b == a).all()
  553:         assert ((~(a == b)) == (a != b)).all()
  554:         assert ((~(b == a)) == (b != a)).all()
  555: 
  556:         assert not (a == c).all()
  557:         assert not (c == a).all()
  558:         assert not (a == d).all()
  559:         assert not (d == a).all()
  560: 
  561:         # vs a cat-like
  562:         assert (a == e).all()
  563:         assert (e == a).all()
  564:         assert not (a == f).all()
  565:         assert not (f == a).all()
  566: 
  567:         assert (~(a == e) == (a != e)).all()
  568:         assert (~(e == a) == (e != a)).all()
  569:         assert (~(a == f) == (a != f)).all()
  570:         assert (~(f == a) == (f != a)).all()
  571: 
  572:         # non-equality is not comparable
  573:         msg = "can only compare equality or not"
  574:         with pytest.raises(TypeError, match=msg):
  575:             a < b
  576:         with pytest.raises(TypeError, match=msg):
  577:             b < a
  578:         with pytest.raises(TypeError, match=msg):
  579:             a > b
  580:         with pytest.raises(TypeError, match=msg):
  581:             b > a
  582: 
  583:     def test_unequal_categorical_comparison_raises_type_error(self):
  584:         # unequal comparison should raise for unordered cats
  585:         cat = Series(Categorical(list("abc")))
  586:         msg = "can only compare equality or not"
  587:         with pytest.raises(TypeError, match=msg):
  588:             cat > "b"
  589: 
  590:         cat = Series(Categorical(list("abc"), ordered=False))
  591:         with pytest.raises(TypeError, match=msg):
  592:             cat > "b"
  593: 
  594:         # https://github.com/pandas-dev/pandas/issues/9836#issuecomment-92123057
  595:         # and following comparisons with scalars not in categories should raise
  596:         # for unequal comps, but not for equal/not equal
  597:         cat = Series(Categorical(list("abc"), ordered=True))
  598: 
  599:         msg = "Invalid comparison between dtype=category and str"
  600:         with pytest.raises(TypeError, match=msg):
  601:             cat < "d"
  602:         with pytest.raises(TypeError, match=msg):
  603:             cat > "d"
  604:         with pytest.raises(TypeError, match=msg):
  605:             "d" < cat
  606:         with pytest.raises(TypeError, match=msg):
  607:             "d" > cat
  608: 
  609:         tm.assert_series_equal(cat == "d", Series([False, False, False]))
  610:         tm.assert_series_equal(cat != "d", Series([True, True, True]))
  611: 
  612:     # -----------------------------------------------------------------
  613: 
  614:     def test_comparison_tuples(self):
  615:         # GH#11339
  616:         # comparisons vs tuple
  617:         s = Series([(1, 1), (1, 2)])
  618: 
  619:         result = s == (1, 2)
  620:         expected = Series([False, True])
  621:         tm.assert_series_equal(result, expected)
  622: 
  623:         result = s != (1, 2)
  624:         expected = Series([True, False])
  625:         tm.assert_series_equal(result, expected)
  626: 
  627:         result = s == (0, 0)
  628:         expected = Series([False, False])
  629:         tm.assert_series_equal(result, expected)
  630: 
  631:         result = s != (0, 0)
  632:         expected = Series([True, True])
  633:         tm.assert_series_equal(result, expected)
  634: 
  635:         s = Series([(1, 1), (1, 1)])
  636: 
  637:         result = s == (1, 1)
  638:         expected = Series([True, True])
  639:         tm.assert_series_equal(result, expected)
  640: 
  641:         result = s != (1, 1)
  642:         expected = Series([False, False])
  643:         tm.assert_series_equal(result, expected)
  644: 
  645:     def test_comparison_frozenset(self):
  646:         ser = Series([frozenset([1]), frozenset([1, 2])])
  647: 
  648:         result = ser == frozenset([1])
  649:         expected = Series([True, False])
  650:         tm.assert_series_equal(result, expected)
  651: 
  652:     def test_comparison_operators_with_nas(self, comparison_op):
  653:         ser = Series(bdate_range("1/1/2000", periods=10), dtype=object)
  654:         ser[::2] = np.nan
  655: 
  656:         # test that comparisons work
  657:         val = ser[5]
  658: 
  659:         result = comparison_op(ser, val)
  660:         expected = comparison_op(ser.dropna(), val).reindex(ser.index)
  661: 
  662:         msg = "Downcasting object dtype arrays"
  663:         with tm.assert_produces_warning(FutureWarning, match=msg):
  664:             if comparison_op is operator.ne:
  665:                 expected = expected.fillna(True).astype(bool)
  666:             else:
  667:                 expected = expected.fillna(False).astype(bool)
  668: 
  669:         tm.assert_series_equal(result, expected)
  670: 
  671:     def test_ne(self):
  672:         ts = Series([3, 4, 5, 6, 7], [3, 4, 5, 6, 7], dtype=float)
  673:         expected = np.array([True, True, False, True, True])
  674:         tm.assert_numpy_array_equal(ts.index != 5, expected)
  675:         tm.assert_numpy_array_equal(~(ts.index == 5), expected)
  676: 
  677:     @pytest.mark.parametrize(
  678:         "left, right",
  679:         [
  680:             (
  681:                 Series([1, 2, 3], index=list("ABC"), name="x"),
  682:                 Series([2, 2, 2], index=list("ABD"), name="x"),
  683:             ),
  684:             (
  685:                 Series([1, 2, 3], index=list("ABC"), name="x"),
  686:                 Series([2, 2, 2, 2], index=list("ABCD"), name="x"),
  687:             ),
  688:         ],
  689:     )
  690:     def test_comp_ops_df_compat(self, left, right, frame_or_series):
  691:         # GH 1134
  692:         # GH 50083 to clarify that index and columns must be identically labeled
  693:         if frame_or_series is not Series:
  694:             msg = (
  695:                 rf"Can only compare identically-labeled \(both index and columns\) "
  696:                 f"{frame_or_series.__name__} objects"
  697:             )
  698:             left = left.to_frame()
  699:             right = right.to_frame()
  700:         else:
  701:             msg = (
  702:                 f"Can only compare identically-labeled {frame_or_series.__name__} "
  703:                 f"objects"
  704:             )
  705: 
  706:         with pytest.raises(ValueError, match=msg):
  707:             left == right
  708:         with pytest.raises(ValueError, match=msg):
  709:             right == left
  710: 
  711:         with pytest.raises(ValueError, match=msg):
  712:             left != right
  713:         with pytest.raises(ValueError, match=msg):
  714:             right != left
  715: 
  716:         with pytest.raises(ValueError, match=msg):
  717:             left < right
  718:         with pytest.raises(ValueError, match=msg):
  719:             right < left
  720: 
  721:     def test_compare_series_interval_keyword(self):
  722:         # GH#25338
  723:         ser = Series(["IntervalA", "IntervalB", "IntervalC"])
  724:         result = ser == "IntervalA"
  725:         expected = Series([True, False, False])
  726:         tm.assert_series_equal(result, expected)
  727: 
  728: 
  729: # ------------------------------------------------------------------
  730: # Unsorted
  731: #  These arithmetic tests were previously in other files, eventually
  732: #  should be parametrized and put into tests.arithmetic
  733: 
  734: 
  735: class TestTimeSeriesArithmetic:
  736:     def test_series_add_tz_mismatch_converts_to_utc(self):
  737:         rng = date_range("1/1/2011", periods=100, freq="h", tz="utc")
  738: 
  739:         perm = np.random.default_rng(2).permutation(100)[:90]
  740:         ser1 = Series(
  741:             np.random.default_rng(2).standard_normal(90),
  742:             index=rng.take(perm).tz_convert("US/Eastern"),
  743:         )
  744: 
  745:         perm = np.random.default_rng(2).permutation(100)[:90]
  746:         ser2 = Series(
  747:             np.random.default_rng(2).standard_normal(90),
  748:             index=rng.take(perm).tz_convert("Europe/Berlin"),
  749:         )
  750: 
  751:         result = ser1 + ser2
  752: 
  753:         uts1 = ser1.tz_convert("utc")
  754:         uts2 = ser2.tz_convert("utc")
  755:         expected = uts1 + uts2
  756: 
  757:         # sort since input indexes are not equal
  758:         expected = expected.sort_index()
  759: 
  760:         assert result.index.tz is timezone.utc
  761:         tm.assert_series_equal(result, expected)
  762: 
  763:     def test_series_add_aware_naive_raises(self):
  764:         rng = date_range("1/1/2011", periods=10, freq="h")
  765:         ser = Series(np.random.default_rng(2).standard_normal(len(rng)), index=rng)
  766: 
  767:         ser_utc = ser.tz_localize("utc")
  768: 
  769:         msg = "Cannot join tz-naive with tz-aware DatetimeIndex"
  770:         with pytest.raises(Exception, match=msg):
  771:             ser + ser_utc
  772: 
  773:         with pytest.raises(Exception, match=msg):
  774:             ser_utc + ser
  775: 
  776:     # TODO: belongs in tests/arithmetic?
  777:     def test_datetime_understood(self, unit):
  778:         # Ensures it doesn't fail to create the right series
  779:         # reported in issue#16726
  780:         series = Series(date_range("2012-01-01", periods=3, unit=unit))
  781:         offset = pd.offsets.DateOffset(days=6)
  782:         result = series - offset
  783:         exp_dti = pd.to_datetime(["2011-12-26", "2011-12-27", "2011-12-28"]).as_unit(
  784:             unit
  785:         )
  786:         expected = Series(exp_dti)
  787:         tm.assert_series_equal(result, expected)
  788: 
  789:     def test_align_date_objects_with_datetimeindex(self):
  790:         rng = date_range("1/1/2000", periods=20)
  791:         ts = Series(np.random.default_rng(2).standard_normal(20), index=rng)
  792: 
  793:         ts_slice = ts[5:]
  794:         ts2 = ts_slice.copy()
  795:         ts2.index = [x.date() for x in ts2.index]
  796: 
  797:         result = ts + ts2
  798:         result2 = ts2 + ts
  799:         expected = ts + ts[5:]
  800:         expected.index = expected.index._with_freq(None)
  801:         tm.assert_series_equal(result, expected)
  802:         tm.assert_series_equal(result2, expected)
  803: 
  804: 
  805: class TestNamePreservation:
  806:     @pytest.mark.parametrize("box", [list, tuple, np.array, Index, Series, pd.array])
  807:     @pytest.mark.parametrize("flex", [True, False])
  808:     def test_series_ops_name_retention(self, flex, box, names, all_binary_operators):
  809:         # GH#33930 consistent name-retention
  810:         op = all_binary_operators
  811: 
  812:         left = Series(range(10), name=names[0])
  813:         right = Series(range(10), name=names[1])
  814: 
  815:         name = op.__name__.strip("_")
  816:         is_logical = name in ["and", "rand", "xor", "rxor", "or", "ror"]
  817: 
  818:         msg = (
  819:             r"Logical ops \(and, or, xor\) between Pandas objects and "
  820:             "dtype-less sequences"
  821:         )
  822:         warn = None
  823:         if box in [list, tuple] and is_logical:
  824:             warn = FutureWarning
  825: 
  826:         right = box(right)
  827:         if flex:
  828:             if is_logical:
  829:                 # Series doesn't have these as flex methods
  830:                 return
  831:             result = getattr(left, name)(right)
  832:         else:
  833:             # GH#37374 logical ops behaving as set ops deprecated
  834:             with tm.assert_produces_warning(warn, match=msg):
  835:                 result = op(left, right)
  836: 
  837:         assert isinstance(result, Series)
  838:         if box in [Index, Series]:
  839:             assert result.name is names[2] or result.name == names[2]
  840:         else:
  841:             assert result.name is names[0] or result.name == names[0]
  842: 
  843:     def test_binop_maybe_preserve_name(self, datetime_series):
  844:         # names match, preserve
  845:         result = datetime_series * datetime_series
  846:         assert result.name == datetime_series.name
  847:         result = datetime_series.mul(datetime_series)
  848:         assert result.name == datetime_series.name
  849: 
  850:         result = datetime_series * datetime_series[:-2]
  851:         assert result.name == datetime_series.name
  852: 
  853:         # names don't match, don't preserve
  854:         cp = datetime_series.copy()
  855:         cp.name = "something else"
  856:         result = datetime_series + cp
  857:         assert result.name is None
  858:         result = datetime_series.add(cp)
  859:         assert result.name is None
  860: 
  861:         ops = ["add", "sub", "mul", "div", "truediv", "floordiv", "mod", "pow"]
  862:         ops = ops + ["r" + op for op in ops]
  863:         for op in ops:
  864:             # names match, preserve
  865:             ser = datetime_series.copy()
  866:             result = getattr(ser, op)(ser)
  867:             assert result.name == datetime_series.name
  868: 
  869:             # names don't match, don't preserve
  870:             cp = datetime_series.copy()
  871:             cp.name = "changed"
  872:             result = getattr(ser, op)(cp)
  873:             assert result.name is None
  874: 
  875:     def test_scalarop_preserve_name(self, datetime_series):
  876:         result = datetime_series * 2
  877:         assert result.name == datetime_series.name
  878: 
  879: 
  880: class TestInplaceOperations:
  881:     @pytest.mark.parametrize(
  882:         "dtype1, dtype2, dtype_expected, dtype_mul",
  883:         (
  884:             ("Int64", "Int64", "Int64", "Int64"),
  885:             ("float", "float", "float", "float"),
  886:             ("Int64", "float", "Float64", "Float64"),
  887:             ("Int64", "Float64", "Float64", "Float64"),
  888:         ),
  889:     )
  890:     def test_series_inplace_ops(self, dtype1, dtype2, dtype_expected, dtype_mul):
  891:         # GH 37910
  892: 
  893:         ser1 = Series([1], dtype=dtype1)
  894:         ser2 = Series([2], dtype=dtype2)
  895:         ser1 += ser2
  896:         expected = Series([3], dtype=dtype_expected)
  897:         tm.assert_series_equal(ser1, expected)
  898: 
  899:         ser1 -= ser2
  900:         expected = Series([1], dtype=dtype_expected)
  901:         tm.assert_series_equal(ser1, expected)
  902: 
  903:         ser1 *= ser2
  904:         expected = Series([2], dtype=dtype_mul)
  905:         tm.assert_series_equal(ser1, expected)
  906: 
  907: 
  908: def test_none_comparison(request, series_with_simple_index):
  909:     series = series_with_simple_index
  910: 
  911:     if len(series) < 1:
  912:         request.applymarker(
  913:             pytest.mark.xfail(reason="Test doesn't make sense on empty data")
  914:         )
  915: 
  916:     # bug brought up by #1079
  917:     # changed from TypeError in 0.17.0
  918:     series.iloc[0] = np.nan
  919: 
  920:     # noinspection PyComparisonWithNone
  921:     result = series == None  # noqa: E711
  922:     assert not result.iat[0]
  923:     assert not result.iat[1]
  924: 
  925:     # noinspection PyComparisonWithNone
  926:     result = series != None  # noqa: E711
  927:     assert result.iat[0]
  928:     assert result.iat[1]
  929: 
  930:     result = None == series  # noqa: E711
  931:     assert not result.iat[0]
  932:     assert not result.iat[1]
  933: 
  934:     result = None != series  # noqa: E711
  935:     assert result.iat[0]
  936:     assert result.iat[1]
  937: 
  938:     if lib.is_np_dtype(series.dtype, "M") or isinstance(series.dtype, DatetimeTZDtype):
  939:         # Following DatetimeIndex (and Timestamp) convention,
  940:         # inequality comparisons with Series[datetime64] raise
  941:         msg = "Invalid comparison"
  942:         with pytest.raises(TypeError, match=msg):
  943:             None > series
  944:         with pytest.raises(TypeError, match=msg):
  945:             series > None
  946:     else:
  947:         result = None > series
  948:         assert not result.iat[0]
  949:         assert not result.iat[1]
  950: 
  951:         result = series < None
  952:         assert not result.iat[0]
  953:         assert not result.iat[1]
  954: 
  955: 
  956: def test_series_varied_multiindex_alignment():
  957:     # GH 20414
  958:     s1 = Series(
  959:         range(8),
  960:         index=pd.MultiIndex.from_product(
  961:             [list("ab"), list("xy"), [1, 2]], names=["ab", "xy", "num"]
  962:         ),
  963:     )
  964:     s2 = Series(
  965:         [1000 * i for i in range(1, 5)],
  966:         index=pd.MultiIndex.from_product([list("xy"), [1, 2]], names=["xy", "num"]),
  967:     )
  968:     result = s1.loc[pd.IndexSlice[["a"], :, :]] + s2
  969:     expected = Series(
  970:         [1000, 2001, 3002, 4003],
  971:         index=pd.MultiIndex.from_tuples(
  972:             [("a", "x", 1), ("a", "x", 2), ("a", "y", 1), ("a", "y", 2)],
  973:             names=["ab", "xy", "num"],
  974:         ),
  975:     )
  976:     tm.assert_series_equal(result, expected)
  977: 
  978: 
  979: def test_rmod_consistent_large_series():
  980:     # GH 29602
  981:     result = Series([2] * 10001).rmod(-1)
  982:     expected = Series([1] * 10001)
  983: 
  984:     tm.assert_series_equal(result, expected)
