    1: from datetime import (
    2:     datetime,
    3:     timedelta,
    4: )
    5: 
    6: import numpy as np
    7: import pytest
    8: 
    9: from pandas._config import using_pyarrow_string_dtype
   10: 
   11: import pandas as pd
   12: from pandas import (
   13:     Categorical,
   14:     DataFrame,
   15:     Index,
   16:     Series,
   17:     date_range,
   18:     option_context,
   19:     period_range,
   20:     timedelta_range,
   21: )
   22: import pandas._testing as tm
   23: 
   24: 
   25: class TestSeriesRepr:
   26:     def test_multilevel_name_print_0(self):
   27:         # GH#55415 None does not get printed, but 0 does
   28:         # (matching DataFrame and flat index behavior)
   29:         mi = pd.MultiIndex.from_product([range(2, 3), range(3, 4)], names=[0, None])
   30:         ser = Series(1.5, index=mi)
   31: 
   32:         res = repr(ser)
   33:         expected = "0   \n2  3    1.5\ndtype: float64"
   34:         assert res == expected
   35: 
   36:     def test_multilevel_name_print(self, lexsorted_two_level_string_multiindex):
   37:         index = lexsorted_two_level_string_multiindex
   38:         ser = Series(range(len(index)), index=index, name="sth")
   39:         expected = [
   40:             "first  second",
   41:             "foo    one       0",
   42:             "       two       1",
   43:             "       three     2",
   44:             "bar    one       3",
   45:             "       two       4",
   46:             "baz    two       5",
   47:             "       three     6",
   48:             "qux    one       7",
   49:             "       two       8",
   50:             "       three     9",
   51:             "Name: sth, dtype: int64",
   52:         ]
   53:         expected = "\n".join(expected)
   54:         assert repr(ser) == expected
   55: 
   56:     def test_small_name_printing(self):
   57:         # Test small Series.
   58:         s = Series([0, 1, 2])
   59: 
   60:         s.name = "test"
   61:         assert "Name: test" in repr(s)
   62: 
   63:         s.name = None
   64:         assert "Name:" not in repr(s)
   65: 
   66:     def test_big_name_printing(self):
   67:         # Test big Series (diff code path).
   68:         s = Series(range(1000))
   69: 
   70:         s.name = "test"
   71:         assert "Name: test" in repr(s)
   72: 
   73:         s.name = None
   74:         assert "Name:" not in repr(s)
   75: 
   76:     def test_empty_name_printing(self):
   77:         s = Series(index=date_range("20010101", "20020101"), name="test", dtype=object)
   78:         assert "Name: test" in repr(s)
   79: 
   80:     @pytest.mark.parametrize("args", [(), (0, -1)])
   81:     def test_float_range(self, args):
   82:         str(
   83:             Series(
   84:                 np.random.default_rng(2).standard_normal(1000),
   85:                 index=np.arange(1000, *args),
   86:             )
   87:         )
   88: 
   89:     def test_empty_object(self):
   90:         # empty
   91:         str(Series(dtype=object))
   92: 
   93:     def test_string(self, string_series):
   94:         str(string_series)
   95:         str(string_series.astype(int))
   96: 
   97:         # with NaNs
   98:         string_series[5:7] = np.nan
   99:         str(string_series)
  100: 
  101:     def test_object(self, object_series):
  102:         str(object_series)
  103: 
  104:     def test_datetime(self, datetime_series):
  105:         str(datetime_series)
  106:         # with Nones
  107:         ots = datetime_series.astype("O")
  108:         ots[::2] = None
  109:         repr(ots)
  110: 
  111:     @pytest.mark.parametrize(
  112:         "name",
  113:         [
  114:             "",
  115:             1,
  116:             1.2,
  117:             "foo",
  118:             "\u03B1\u03B2\u03B3",
  119:             "loooooooooooooooooooooooooooooooooooooooooooooooooooong",
  120:             ("foo", "bar", "baz"),
  121:             (1, 2),
  122:             ("foo", 1, 2.3),
  123:             ("\u03B1", "\u03B2", "\u03B3"),
  124:             ("\u03B1", "bar"),
  125:         ],
  126:     )
  127:     def test_various_names(self, name, string_series):
  128:         # various names
  129:         string_series.name = name
  130:         repr(string_series)
  131: 
  132:     def test_tuple_name(self):
  133:         biggie = Series(
  134:             np.random.default_rng(2).standard_normal(1000),
  135:             index=np.arange(1000),
  136:             name=("foo", "bar", "baz"),
  137:         )
  138:         repr(biggie)
  139: 
  140:     @pytest.mark.parametrize("arg", [100, 1001])
  141:     def test_tidy_repr_name_0(self, arg):
  142:         # tidy repr
  143:         ser = Series(np.random.default_rng(2).standard_normal(arg), name=0)
  144:         rep_str = repr(ser)
  145:         assert "Name: 0" in rep_str
  146: 
  147:     @pytest.mark.xfail(
  148:         using_pyarrow_string_dtype(), reason="TODO: investigate why this is failing"
  149:     )
  150:     def test_newline(self):
  151:         ser = Series(["a\n\r\tb"], name="a\n\r\td", index=["a\n\r\tf"])
  152:         assert "\t" not in repr(ser)
  153:         assert "\r" not in repr(ser)
  154:         assert "a\n" not in repr(ser)
  155: 
  156:     @pytest.mark.parametrize(
  157:         "name, expected",
  158:         [
  159:             ["foo", "Series([], Name: foo, dtype: int64)"],
  160:             [None, "Series([], dtype: int64)"],
  161:         ],
  162:     )
  163:     def test_empty_int64(self, name, expected):
  164:         # with empty series (#4651)
  165:         s = Series([], dtype=np.int64, name=name)
  166:         assert repr(s) == expected
  167: 
  168:     def test_repr_bool_fails(self, capsys):
  169:         s = Series(
  170:             [
  171:                 DataFrame(np.random.default_rng(2).standard_normal((2, 2)))
  172:                 for i in range(5)
  173:             ]
  174:         )
  175: 
  176:         # It works (with no Cython exception barf)!
  177:         repr(s)
  178: 
  179:         captured = capsys.readouterr()
  180:         assert captured.err == ""
  181: 
  182:     def test_repr_name_iterable_indexable(self):
  183:         s = Series([1, 2, 3], name=np.int64(3))
  184: 
  185:         # it works!
  186:         repr(s)
  187: 
  188:         s.name = ("\u05d0",) * 2
  189:         repr(s)
  190: 
  191:     def test_repr_max_rows(self):
  192:         # GH 6863
  193:         with option_context("display.max_rows", None):
  194:             str(Series(range(1001)))  # should not raise exception
  195: 
  196:     def test_unicode_string_with_unicode(self):
  197:         df = Series(["\u05d0"], name="\u05d1")
  198:         str(df)
  199: 
  200:         ser = Series(["\u03c3"] * 10)
  201:         repr(ser)
  202: 
  203:         ser2 = Series(["\u05d0"] * 1000)
  204:         ser2.name = "title1"
  205:         repr(ser2)
  206: 
  207:     def test_str_to_bytes_raises(self):
  208:         # GH 26447
  209:         df = Series(["abc"], name="abc")
  210:         msg = "^'str' object cannot be interpreted as an integer$"
  211:         with pytest.raises(TypeError, match=msg):
  212:             bytes(df)
  213: 
  214:     def test_timeseries_repr_object_dtype(self):
  215:         index = Index(
  216:             [datetime(2000, 1, 1) + timedelta(i) for i in range(1000)], dtype=object
  217:         )
  218:         ts = Series(np.random.default_rng(2).standard_normal(len(index)), index)
  219:         repr(ts)
  220: 
  221:         ts = Series(
  222:             np.arange(20, dtype=np.float64), index=date_range("2020-01-01", periods=20)
  223:         )
  224:         assert repr(ts).splitlines()[-1].startswith("Freq:")
  225: 
  226:         ts2 = ts.iloc[np.random.default_rng(2).integers(0, len(ts) - 1, 400)]
  227:         repr(ts2).splitlines()[-1]
  228: 
  229:     def test_latex_repr(self):
  230:         pytest.importorskip("jinja2")  # uses Styler implementation
  231:         result = r"""\begin{tabular}{ll}
  232: \toprule
  233:  & 0 \\
  234: \midrule
  235: 0 & $\alpha$ \\
  236: 1 & b \\
  237: 2 & c \\
  238: \bottomrule
  239: \end{tabular}
  240: """
  241:         with option_context(
  242:             "styler.format.escape", None, "styler.render.repr", "latex"
  243:         ):
  244:             s = Series([r"$\alpha$", "b", "c"])
  245:             assert result == s._repr_latex_()
  246: 
  247:         assert s._repr_latex_() is None
  248: 
  249:     def test_index_repr_in_frame_with_nan(self):
  250:         # see gh-25061
  251:         i = Index([1, np.nan])
  252:         s = Series([1, 2], index=i)
  253:         exp = """1.0    1\nNaN    2\ndtype: int64"""
  254: 
  255:         assert repr(s) == exp
  256: 
  257:     def test_format_pre_1900_dates(self):
  258:         rng = date_range("1/1/1850", "1/1/1950", freq="YE-DEC")
  259:         msg = "DatetimeIndex.format is deprecated"
  260:         with tm.assert_produces_warning(FutureWarning, match=msg):
  261:             rng.format()
  262:         ts = Series(1, index=rng)
  263:         repr(ts)
  264: 
  265:     def test_series_repr_nat(self):
  266:         series = Series([0, 1000, 2000, pd.NaT._value], dtype="M8[ns]")
  267: 
  268:         result = repr(series)
  269:         expected = (
  270:             "0   1970-01-01 00:00:00.000000\n"
  271:             "1   1970-01-01 00:00:00.000001\n"
  272:             "2   1970-01-01 00:00:00.000002\n"
  273:             "3                          NaT\n"
  274:             "dtype: datetime64[ns]"
  275:         )
  276:         assert result == expected
  277: 
  278:     def test_float_repr(self):
  279:         # GH#35603
  280:         # check float format when cast to object
  281:         ser = Series([1.0]).astype(object)
  282:         expected = "0    1.0\ndtype: object"
  283:         assert repr(ser) == expected
  284: 
  285:     def test_different_null_objects(self):
  286:         # GH#45263
  287:         ser = Series([1, 2, 3, 4], [True, None, np.nan, pd.NaT])
  288:         result = repr(ser)
  289:         expected = "True    1\nNone    2\nNaN     3\nNaT     4\ndtype: int64"
  290:         assert result == expected
  291: 
  292: 
  293: class TestCategoricalRepr:
  294:     def test_categorical_repr_unicode(self):
  295:         # see gh-21002
  296: 
  297:         class County:
  298:             name = "San SebastiГЎn"
  299:             state = "PR"
  300: 
  301:             def __repr__(self) -> str:
  302:                 return self.name + ", " + self.state
  303: 
  304:         cat = Categorical([County() for _ in range(61)])
  305:         idx = Index(cat)
  306:         ser = idx.to_series()
  307: 
  308:         repr(ser)
  309:         str(ser)
  310: 
  311:     def test_categorical_repr(self, using_infer_string):
  312:         a = Series(Categorical([1, 2, 3, 4]))
  313:         exp = (
  314:             "0    1\n1    2\n2    3\n3    4\n"
  315:             "dtype: category\nCategories (4, int64): [1, 2, 3, 4]"
  316:         )
  317: 
  318:         assert exp == a.__str__()
  319: 
  320:         a = Series(Categorical(["a", "b"] * 25))
  321:         if using_infer_string:
  322:             exp = (
  323:                 "0     a\n1     b\n"
  324:                 "     ..\n"
  325:                 "48    a\n49    b\n"
  326:                 "Length: 50, dtype: category\nCategories (2, string): [a, b]"
  327:             )
  328:         else:
  329:             exp = (
  330:                 "0     a\n1     b\n"
  331:                 "     ..\n"
  332:                 "48    a\n49    b\n"
  333:                 "Length: 50, dtype: category\nCategories (2, object): ['a', 'b']"
  334:             )
  335:         with option_context("display.max_rows", 5):
  336:             assert exp == repr(a)
  337: 
  338:         levs = list("abcdefghijklmnopqrstuvwxyz")
  339:         a = Series(Categorical(["a", "b"], categories=levs, ordered=True))
  340:         if using_infer_string:
  341:             exp = (
  342:                 "0    a\n1    b\n"
  343:                 "dtype: category\n"
  344:                 "Categories (26, string): [a < b < c < d ... w < x < y < z]"
  345:             )
  346:         else:
  347:             exp = (
  348:                 "0    a\n1    b\n"
  349:                 "dtype: category\n"
  350:                 "Categories (26, object): ['a' < 'b' < 'c' < 'd' ... "
  351:                 "'w' < 'x' < 'y' < 'z']"
  352:             )
  353:         assert exp == a.__str__()
  354: 
  355:     def test_categorical_series_repr(self):
  356:         s = Series(Categorical([1, 2, 3]))
  357:         exp = """0    1
  358: 1    2
  359: 2    3
  360: dtype: category
  361: Categories (3, int64): [1, 2, 3]"""
  362: 
  363:         assert repr(s) == exp
  364: 
  365:         s = Series(Categorical(np.arange(10)))
  366:         exp = f"""0    0
  367: 1    1
  368: 2    2
  369: 3    3
  370: 4    4
  371: 5    5
  372: 6    6
  373: 7    7
  374: 8    8
  375: 9    9
  376: dtype: category
  377: Categories (10, {np.dtype(int)}): [0, 1, 2, 3, ..., 6, 7, 8, 9]"""
  378: 
  379:         assert repr(s) == exp
  380: 
  381:     def test_categorical_series_repr_ordered(self):
  382:         s = Series(Categorical([1, 2, 3], ordered=True))
  383:         exp = """0    1
  384: 1    2
  385: 2    3
  386: dtype: category
  387: Categories (3, int64): [1 < 2 < 3]"""
  388: 
  389:         assert repr(s) == exp
  390: 
  391:         s = Series(Categorical(np.arange(10), ordered=True))
  392:         exp = f"""0    0
  393: 1    1
  394: 2    2
  395: 3    3
  396: 4    4
  397: 5    5
  398: 6    6
  399: 7    7
  400: 8    8
  401: 9    9
  402: dtype: category
  403: Categories (10, {np.dtype(int)}): [0 < 1 < 2 < 3 ... 6 < 7 < 8 < 9]"""
  404: 
  405:         assert repr(s) == exp
  406: 
  407:     def test_categorical_series_repr_datetime(self):
  408:         idx = date_range("2011-01-01 09:00", freq="h", periods=5)
  409:         s = Series(Categorical(idx))
  410:         exp = """0   2011-01-01 09:00:00
  411: 1   2011-01-01 10:00:00
  412: 2   2011-01-01 11:00:00
  413: 3   2011-01-01 12:00:00
  414: 4   2011-01-01 13:00:00
  415: dtype: category
  416: Categories (5, datetime64[ns]): [2011-01-01 09:00:00, 2011-01-01 10:00:00, 2011-01-01 11:00:00,
  417:                                  2011-01-01 12:00:00, 2011-01-01 13:00:00]"""  # noqa: E501
  418: 
  419:         assert repr(s) == exp
  420: 
  421:         idx = date_range("2011-01-01 09:00", freq="h", periods=5, tz="US/Eastern")
  422:         s = Series(Categorical(idx))
  423:         exp = """0   2011-01-01 09:00:00-05:00
  424: 1   2011-01-01 10:00:00-05:00
  425: 2   2011-01-01 11:00:00-05:00
  426: 3   2011-01-01 12:00:00-05:00
  427: 4   2011-01-01 13:00:00-05:00
  428: dtype: category
  429: Categories (5, datetime64[ns, US/Eastern]): [2011-01-01 09:00:00-05:00, 2011-01-01 10:00:00-05:00,
  430:                                              2011-01-01 11:00:00-05:00, 2011-01-01 12:00:00-05:00,
  431:                                              2011-01-01 13:00:00-05:00]"""  # noqa: E501
  432: 
  433:         assert repr(s) == exp
  434: 
  435:     def test_categorical_series_repr_datetime_ordered(self):
  436:         idx = date_range("2011-01-01 09:00", freq="h", periods=5)
  437:         s = Series(Categorical(idx, ordered=True))
  438:         exp = """0   2011-01-01 09:00:00
  439: 1   2011-01-01 10:00:00
  440: 2   2011-01-01 11:00:00
  441: 3   2011-01-01 12:00:00
  442: 4   2011-01-01 13:00:00
  443: dtype: category
  444: Categories (5, datetime64[ns]): [2011-01-01 09:00:00 < 2011-01-01 10:00:00 < 2011-01-01 11:00:00 <
  445:                                  2011-01-01 12:00:00 < 2011-01-01 13:00:00]"""  # noqa: E501
  446: 
  447:         assert repr(s) == exp
  448: 
  449:         idx = date_range("2011-01-01 09:00", freq="h", periods=5, tz="US/Eastern")
  450:         s = Series(Categorical(idx, ordered=True))
  451:         exp = """0   2011-01-01 09:00:00-05:00
  452: 1   2011-01-01 10:00:00-05:00
  453: 2   2011-01-01 11:00:00-05:00
  454: 3   2011-01-01 12:00:00-05:00
  455: 4   2011-01-01 13:00:00-05:00
  456: dtype: category
  457: Categories (5, datetime64[ns, US/Eastern]): [2011-01-01 09:00:00-05:00 < 2011-01-01 10:00:00-05:00 <
  458:                                              2011-01-01 11:00:00-05:00 < 2011-01-01 12:00:00-05:00 <
  459:                                              2011-01-01 13:00:00-05:00]"""  # noqa: E501
  460: 
  461:         assert repr(s) == exp
  462: 
  463:     def test_categorical_series_repr_period(self):
  464:         idx = period_range("2011-01-01 09:00", freq="h", periods=5)
  465:         s = Series(Categorical(idx))
  466:         exp = """0    2011-01-01 09:00
  467: 1    2011-01-01 10:00
  468: 2    2011-01-01 11:00
  469: 3    2011-01-01 12:00
  470: 4    2011-01-01 13:00
  471: dtype: category
  472: Categories (5, period[h]): [2011-01-01 09:00, 2011-01-01 10:00, 2011-01-01 11:00, 2011-01-01 12:00,
  473:                             2011-01-01 13:00]"""  # noqa: E501
  474: 
  475:         assert repr(s) == exp
  476: 
  477:         idx = period_range("2011-01", freq="M", periods=5)
  478:         s = Series(Categorical(idx))
  479:         exp = """0    2011-01
  480: 1    2011-02
  481: 2    2011-03
  482: 3    2011-04
  483: 4    2011-05
  484: dtype: category
  485: Categories (5, period[M]): [2011-01, 2011-02, 2011-03, 2011-04, 2011-05]"""
  486: 
  487:         assert repr(s) == exp
  488: 
  489:     def test_categorical_series_repr_period_ordered(self):
  490:         idx = period_range("2011-01-01 09:00", freq="h", periods=5)
  491:         s = Series(Categorical(idx, ordered=True))
  492:         exp = """0    2011-01-01 09:00
  493: 1    2011-01-01 10:00
  494: 2    2011-01-01 11:00
  495: 3    2011-01-01 12:00
  496: 4    2011-01-01 13:00
  497: dtype: category
  498: Categories (5, period[h]): [2011-01-01 09:00 < 2011-01-01 10:00 < 2011-01-01 11:00 < 2011-01-01 12:00 <
  499:                             2011-01-01 13:00]"""  # noqa: E501
  500: 
  501:         assert repr(s) == exp
  502: 
  503:         idx = period_range("2011-01", freq="M", periods=5)
  504:         s = Series(Categorical(idx, ordered=True))
  505:         exp = """0    2011-01
  506: 1    2011-02
  507: 2    2011-03
  508: 3    2011-04
  509: 4    2011-05
  510: dtype: category
  511: Categories (5, period[M]): [2011-01 < 2011-02 < 2011-03 < 2011-04 < 2011-05]"""
  512: 
  513:         assert repr(s) == exp
  514: 
  515:     def test_categorical_series_repr_timedelta(self):
  516:         idx = timedelta_range("1 days", periods=5)
  517:         s = Series(Categorical(idx))
  518:         exp = """0   1 days
  519: 1   2 days
  520: 2   3 days
  521: 3   4 days
  522: 4   5 days
  523: dtype: category
  524: Categories (5, timedelta64[ns]): [1 days, 2 days, 3 days, 4 days, 5 days]"""
  525: 
  526:         assert repr(s) == exp
  527: 
  528:         idx = timedelta_range("1 hours", periods=10)
  529:         s = Series(Categorical(idx))
  530:         exp = """0   0 days 01:00:00
  531: 1   1 days 01:00:00
  532: 2   2 days 01:00:00
  533: 3   3 days 01:00:00
  534: 4   4 days 01:00:00
  535: 5   5 days 01:00:00
  536: 6   6 days 01:00:00
  537: 7   7 days 01:00:00
  538: 8   8 days 01:00:00
  539: 9   9 days 01:00:00
  540: dtype: category
  541: Categories (10, timedelta64[ns]): [0 days 01:00:00, 1 days 01:00:00, 2 days 01:00:00,
  542:                                    3 days 01:00:00, ..., 6 days 01:00:00, 7 days 01:00:00,
  543:                                    8 days 01:00:00, 9 days 01:00:00]"""  # noqa: E501
  544: 
  545:         assert repr(s) == exp
  546: 
  547:     def test_categorical_series_repr_timedelta_ordered(self):
  548:         idx = timedelta_range("1 days", periods=5)
  549:         s = Series(Categorical(idx, ordered=True))
  550:         exp = """0   1 days
  551: 1   2 days
  552: 2   3 days
  553: 3   4 days
  554: 4   5 days
  555: dtype: category
  556: Categories (5, timedelta64[ns]): [1 days < 2 days < 3 days < 4 days < 5 days]"""
  557: 
  558:         assert repr(s) == exp
  559: 
  560:         idx = timedelta_range("1 hours", periods=10)
  561:         s = Series(Categorical(idx, ordered=True))
  562:         exp = """0   0 days 01:00:00
  563: 1   1 days 01:00:00
  564: 2   2 days 01:00:00
  565: 3   3 days 01:00:00
  566: 4   4 days 01:00:00
  567: 5   5 days 01:00:00
  568: 6   6 days 01:00:00
  569: 7   7 days 01:00:00
  570: 8   8 days 01:00:00
  571: 9   9 days 01:00:00
  572: dtype: category
  573: Categories (10, timedelta64[ns]): [0 days 01:00:00 < 1 days 01:00:00 < 2 days 01:00:00 <
  574:                                    3 days 01:00:00 ... 6 days 01:00:00 < 7 days 01:00:00 <
  575:                                    8 days 01:00:00 < 9 days 01:00:00]"""  # noqa: E501
  576: 
  577:         assert repr(s) == exp
