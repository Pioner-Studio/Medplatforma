    1: import numpy as np
    2: import pytest
    3: 
    4: import pandas.util._test_decorators as td
    5: 
    6: from pandas import (
    7:     CategoricalDtype,
    8:     DataFrame,
    9:     NaT,
   10:     Series,
   11:     Timestamp,
   12: )
   13: import pandas._testing as tm
   14: 
   15: 
   16: class TestUpdate:
   17:     def test_update(self, using_copy_on_write):
   18:         s = Series([1.5, np.nan, 3.0, 4.0, np.nan])
   19:         s2 = Series([np.nan, 3.5, np.nan, 5.0])
   20:         s.update(s2)
   21: 
   22:         expected = Series([1.5, 3.5, 3.0, 5.0, np.nan])
   23:         tm.assert_series_equal(s, expected)
   24: 
   25:         # GH 3217
   26:         df = DataFrame([{"a": 1}, {"a": 3, "b": 2}])
   27:         df["c"] = np.nan
   28:         # Cast to object to avoid upcast when setting "foo"
   29:         df["c"] = df["c"].astype(object)
   30:         df_orig = df.copy()
   31: 
   32:         if using_copy_on_write:
   33:             with tm.raises_chained_assignment_error():
   34:                 df["c"].update(Series(["foo"], index=[0]))
   35:             expected = df_orig
   36:         else:
   37:             with tm.assert_produces_warning(FutureWarning, match="inplace method"):
   38:                 df["c"].update(Series(["foo"], index=[0]))
   39:             expected = DataFrame(
   40:                 [[1, np.nan, "foo"], [3, 2.0, np.nan]], columns=["a", "b", "c"]
   41:             )
   42:             expected["c"] = expected["c"].astype(object)
   43:         tm.assert_frame_equal(df, expected)
   44: 
   45:     @pytest.mark.parametrize(
   46:         "other, dtype, expected, warn",
   47:         [
   48:             # other is int
   49:             ([61, 63], "int32", Series([10, 61, 12], dtype="int32"), None),
   50:             ([61, 63], "int64", Series([10, 61, 12]), None),
   51:             ([61, 63], float, Series([10.0, 61.0, 12.0]), None),
   52:             ([61, 63], object, Series([10, 61, 12], dtype=object), None),
   53:             # other is float, but can be cast to int
   54:             ([61.0, 63.0], "int32", Series([10, 61, 12], dtype="int32"), None),
   55:             ([61.0, 63.0], "int64", Series([10, 61, 12]), None),
   56:             ([61.0, 63.0], float, Series([10.0, 61.0, 12.0]), None),
   57:             ([61.0, 63.0], object, Series([10, 61.0, 12], dtype=object), None),
   58:             # others is float, cannot be cast to int
   59:             ([61.1, 63.1], "int32", Series([10.0, 61.1, 12.0]), FutureWarning),
   60:             ([61.1, 63.1], "int64", Series([10.0, 61.1, 12.0]), FutureWarning),
   61:             ([61.1, 63.1], float, Series([10.0, 61.1, 12.0]), None),
   62:             ([61.1, 63.1], object, Series([10, 61.1, 12], dtype=object), None),
   63:             # other is object, cannot be cast
   64:             ([(61,), (63,)], "int32", Series([10, (61,), 12]), FutureWarning),
   65:             ([(61,), (63,)], "int64", Series([10, (61,), 12]), FutureWarning),
   66:             ([(61,), (63,)], float, Series([10.0, (61,), 12.0]), FutureWarning),
   67:             ([(61,), (63,)], object, Series([10, (61,), 12]), None),
   68:         ],
   69:     )
   70:     def test_update_dtypes(self, other, dtype, expected, warn):
   71:         ser = Series([10, 11, 12], dtype=dtype)
   72:         other = Series(other, index=[1, 3])
   73:         with tm.assert_produces_warning(warn, match="item of incompatible dtype"):
   74:             ser.update(other)
   75: 
   76:         tm.assert_series_equal(ser, expected)
   77: 
   78:     @pytest.mark.parametrize(
   79:         "series, other, expected",
   80:         [
   81:             # update by key
   82:             (
   83:                 Series({"a": 1, "b": 2, "c": 3, "d": 4}),
   84:                 {"b": 5, "c": np.nan},
   85:                 Series({"a": 1, "b": 5, "c": 3, "d": 4}),
   86:             ),
   87:             # update by position
   88:             (Series([1, 2, 3, 4]), [np.nan, 5, 1], Series([1, 5, 1, 4])),
   89:         ],
   90:     )
   91:     def test_update_from_non_series(self, series, other, expected):
   92:         # GH 33215
   93:         series.update(other)
   94:         tm.assert_series_equal(series, expected)
   95: 
   96:     @pytest.mark.parametrize(
   97:         "data, other, expected, dtype",
   98:         [
   99:             (["a", None], [None, "b"], ["a", "b"], "string[python]"),
  100:             pytest.param(
  101:                 ["a", None],
  102:                 [None, "b"],
  103:                 ["a", "b"],
  104:                 "string[pyarrow]",
  105:                 marks=td.skip_if_no("pyarrow"),
  106:             ),
  107:             ([1, None], [None, 2], [1, 2], "Int64"),
  108:             ([True, None], [None, False], [True, False], "boolean"),
  109:             (
  110:                 ["a", None],
  111:                 [None, "b"],
  112:                 ["a", "b"],
  113:                 CategoricalDtype(categories=["a", "b"]),
  114:             ),
  115:             (
  116:                 [Timestamp(year=2020, month=1, day=1, tz="Europe/London"), NaT],
  117:                 [NaT, Timestamp(year=2020, month=1, day=1, tz="Europe/London")],
  118:                 [Timestamp(year=2020, month=1, day=1, tz="Europe/London")] * 2,
  119:                 "datetime64[ns, Europe/London]",
  120:             ),
  121:         ],
  122:     )
  123:     def test_update_extension_array_series(self, data, other, expected, dtype):
  124:         result = Series(data, dtype=dtype)
  125:         other = Series(other, dtype=dtype)
  126:         expected = Series(expected, dtype=dtype)
  127: 
  128:         result.update(other)
  129:         tm.assert_series_equal(result, expected)
  130: 
  131:     def test_update_with_categorical_type(self):
  132:         # GH 25744
  133:         dtype = CategoricalDtype(["a", "b", "c", "d"])
  134:         s1 = Series(["a", "b", "c"], index=[1, 2, 3], dtype=dtype)
  135:         s2 = Series(["b", "a"], index=[1, 2], dtype=dtype)
  136:         s1.update(s2)
  137:         result = s1
  138:         expected = Series(["b", "a", "c"], index=[1, 2, 3], dtype=dtype)
  139:         tm.assert_series_equal(result, expected)
