    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas.core.dtypes.common import is_integer
    5: 
    6: import pandas as pd
    7: from pandas import (
    8:     Index,
    9:     Series,
   10: )
   11: import pandas._testing as tm
   12: from pandas.core.indexes.datetimes import Timestamp
   13: 
   14: 
   15: class TestSeriesQuantile:
   16:     def test_quantile(self, datetime_series):
   17:         q = datetime_series.quantile(0.1)
   18:         assert q == np.percentile(datetime_series.dropna(), 10)
   19: 
   20:         q = datetime_series.quantile(0.9)
   21:         assert q == np.percentile(datetime_series.dropna(), 90)
   22: 
   23:         # object dtype
   24:         q = Series(datetime_series, dtype=object).quantile(0.9)
   25:         assert q == np.percentile(datetime_series.dropna(), 90)
   26: 
   27:         # datetime64[ns] dtype
   28:         dts = datetime_series.index.to_series()
   29:         q = dts.quantile(0.2)
   30:         assert q == Timestamp("2000-01-10 19:12:00")
   31: 
   32:         # timedelta64[ns] dtype
   33:         tds = dts.diff()
   34:         q = tds.quantile(0.25)
   35:         assert q == pd.to_timedelta("24:00:00")
   36: 
   37:         # GH7661
   38:         result = Series([np.timedelta64("NaT")]).sum()
   39:         assert result == pd.Timedelta(0)
   40: 
   41:         msg = "percentiles should all be in the interval \\[0, 1\\]"
   42:         for invalid in [-1, 2, [0.5, -1], [0.5, 2]]:
   43:             with pytest.raises(ValueError, match=msg):
   44:                 datetime_series.quantile(invalid)
   45: 
   46:         s = Series(np.random.default_rng(2).standard_normal(100))
   47:         percentile_array = [-0.5, 0.25, 1.5]
   48:         with pytest.raises(ValueError, match=msg):
   49:             s.quantile(percentile_array)
   50: 
   51:     def test_quantile_multi(self, datetime_series, unit):
   52:         datetime_series.index = datetime_series.index.as_unit(unit)
   53:         qs = [0.1, 0.9]
   54:         result = datetime_series.quantile(qs)
   55:         expected = Series(
   56:             [
   57:                 np.percentile(datetime_series.dropna(), 10),
   58:                 np.percentile(datetime_series.dropna(), 90),
   59:             ],
   60:             index=qs,
   61:             name=datetime_series.name,
   62:         )
   63:         tm.assert_series_equal(result, expected)
   64: 
   65:         dts = datetime_series.index.to_series()
   66:         dts.name = "xxx"
   67:         result = dts.quantile((0.2, 0.2))
   68:         expected = Series(
   69:             [Timestamp("2000-01-10 19:12:00"), Timestamp("2000-01-10 19:12:00")],
   70:             index=[0.2, 0.2],
   71:             name="xxx",
   72:             dtype=f"M8[{unit}]",
   73:         )
   74:         tm.assert_series_equal(result, expected)
   75: 
   76:         result = datetime_series.quantile([])
   77:         expected = Series(
   78:             [], name=datetime_series.name, index=Index([], dtype=float), dtype="float64"
   79:         )
   80:         tm.assert_series_equal(result, expected)
   81: 
   82:     def test_quantile_interpolation(self, datetime_series):
   83:         # see gh-10174
   84: 
   85:         # interpolation = linear (default case)
   86:         q = datetime_series.quantile(0.1, interpolation="linear")
   87:         assert q == np.percentile(datetime_series.dropna(), 10)
   88:         q1 = datetime_series.quantile(0.1)
   89:         assert q1 == np.percentile(datetime_series.dropna(), 10)
   90: 
   91:         # test with and without interpolation keyword
   92:         assert q == q1
   93: 
   94:     def test_quantile_interpolation_dtype(self):
   95:         # GH #10174
   96: 
   97:         # interpolation = linear (default case)
   98:         q = Series([1, 3, 4]).quantile(0.5, interpolation="lower")
   99:         assert q == np.percentile(np.array([1, 3, 4]), 50)
  100:         assert is_integer(q)
  101: 
  102:         q = Series([1, 3, 4]).quantile(0.5, interpolation="higher")
  103:         assert q == np.percentile(np.array([1, 3, 4]), 50)
  104:         assert is_integer(q)
  105: 
  106:     def test_quantile_nan(self):
  107:         # GH 13098
  108:         ser = Series([1, 2, 3, 4, np.nan])
  109:         result = ser.quantile(0.5)
  110:         expected = 2.5
  111:         assert result == expected
  112: 
  113:         # all nan/empty
  114:         s1 = Series([], dtype=object)
  115:         cases = [s1, Series([np.nan, np.nan])]
  116: 
  117:         for ser in cases:
  118:             res = ser.quantile(0.5)
  119:             assert np.isnan(res)
  120: 
  121:             res = ser.quantile([0.5])
  122:             tm.assert_series_equal(res, Series([np.nan], index=[0.5]))
  123: 
  124:             res = ser.quantile([0.2, 0.3])
  125:             tm.assert_series_equal(res, Series([np.nan, np.nan], index=[0.2, 0.3]))
  126: 
  127:     @pytest.mark.parametrize(
  128:         "case",
  129:         [
  130:             [
  131:                 Timestamp("2011-01-01"),
  132:                 Timestamp("2011-01-02"),
  133:                 Timestamp("2011-01-03"),
  134:             ],
  135:             [
  136:                 Timestamp("2011-01-01", tz="US/Eastern"),
  137:                 Timestamp("2011-01-02", tz="US/Eastern"),
  138:                 Timestamp("2011-01-03", tz="US/Eastern"),
  139:             ],
  140:             [pd.Timedelta("1 days"), pd.Timedelta("2 days"), pd.Timedelta("3 days")],
  141:             # NaT
  142:             [
  143:                 Timestamp("2011-01-01"),
  144:                 Timestamp("2011-01-02"),
  145:                 Timestamp("2011-01-03"),
  146:                 pd.NaT,
  147:             ],
  148:             [
  149:                 Timestamp("2011-01-01", tz="US/Eastern"),
  150:                 Timestamp("2011-01-02", tz="US/Eastern"),
  151:                 Timestamp("2011-01-03", tz="US/Eastern"),
  152:                 pd.NaT,
  153:             ],
  154:             [
  155:                 pd.Timedelta("1 days"),
  156:                 pd.Timedelta("2 days"),
  157:                 pd.Timedelta("3 days"),
  158:                 pd.NaT,
  159:             ],
  160:         ],
  161:     )
  162:     def test_quantile_box(self, case):
  163:         ser = Series(case, name="XXX")
  164:         res = ser.quantile(0.5)
  165:         assert res == case[1]
  166: 
  167:         res = ser.quantile([0.5])
  168:         exp = Series([case[1]], index=[0.5], name="XXX")
  169:         tm.assert_series_equal(res, exp)
  170: 
  171:     def test_datetime_timedelta_quantiles(self):
  172:         # covers #9694
  173:         assert pd.isna(Series([], dtype="M8[ns]").quantile(0.5))
  174:         assert pd.isna(Series([], dtype="m8[ns]").quantile(0.5))
  175: 
  176:     def test_quantile_nat(self):
  177:         res = Series([pd.NaT, pd.NaT]).quantile(0.5)
  178:         assert res is pd.NaT
  179: 
  180:         res = Series([pd.NaT, pd.NaT]).quantile([0.5])
  181:         tm.assert_series_equal(res, Series([pd.NaT], index=[0.5]))
  182: 
  183:     @pytest.mark.parametrize(
  184:         "values, dtype",
  185:         [([0, 0, 0, 1, 2, 3], "Sparse[int]"), ([0.0, None, 1.0, 2.0], "Sparse[float]")],
  186:     )
  187:     def test_quantile_sparse(self, values, dtype):
  188:         ser = Series(values, dtype=dtype)
  189:         result = ser.quantile([0.5])
  190:         expected = Series(np.asarray(ser)).quantile([0.5]).astype("Sparse[float]")
  191:         tm.assert_series_equal(result, expected)
  192: 
  193:     def test_quantile_empty_float64(self):
  194:         # floats
  195:         ser = Series([], dtype="float64")
  196: 
  197:         res = ser.quantile(0.5)
  198:         assert np.isnan(res)
  199: 
  200:         res = ser.quantile([0.5])
  201:         exp = Series([np.nan], index=[0.5])
  202:         tm.assert_series_equal(res, exp)
  203: 
  204:     def test_quantile_empty_int64(self):
  205:         # int
  206:         ser = Series([], dtype="int64")
  207: 
  208:         res = ser.quantile(0.5)
  209:         assert np.isnan(res)
  210: 
  211:         res = ser.quantile([0.5])
  212:         exp = Series([np.nan], index=[0.5])
  213:         tm.assert_series_equal(res, exp)
  214: 
  215:     def test_quantile_empty_dt64(self):
  216:         # datetime
  217:         ser = Series([], dtype="datetime64[ns]")
  218: 
  219:         res = ser.quantile(0.5)
  220:         assert res is pd.NaT
  221: 
  222:         res = ser.quantile([0.5])
  223:         exp = Series([pd.NaT], index=[0.5], dtype=ser.dtype)
  224:         tm.assert_series_equal(res, exp)
  225: 
  226:     @pytest.mark.parametrize("dtype", [int, float, "Int64"])
  227:     def test_quantile_dtypes(self, dtype):
  228:         result = Series([1, 2, 3], dtype=dtype).quantile(np.arange(0, 1, 0.25))
  229:         expected = Series(np.arange(1, 3, 0.5), index=np.arange(0, 1, 0.25))
  230:         if dtype == "Int64":
  231:             expected = expected.astype("Float64")
  232:         tm.assert_series_equal(result, expected)
  233: 
  234:     def test_quantile_all_na(self, any_int_ea_dtype):
  235:         # GH#50681
  236:         ser = Series([pd.NA, pd.NA], dtype=any_int_ea_dtype)
  237:         with tm.assert_produces_warning(None):
  238:             result = ser.quantile([0.1, 0.5])
  239:         expected = Series([pd.NA, pd.NA], dtype=any_int_ea_dtype, index=[0.1, 0.5])
  240:         tm.assert_series_equal(result, expected)
  241: 
  242:     def test_quantile_dtype_size(self, any_int_ea_dtype):
  243:         # GH#50681
  244:         ser = Series([pd.NA, pd.NA, 1], dtype=any_int_ea_dtype)
  245:         result = ser.quantile([0.1, 0.5])
  246:         expected = Series([1, 1], dtype=any_int_ea_dtype, index=[0.1, 0.5])
  247:         tm.assert_series_equal(result, expected)
