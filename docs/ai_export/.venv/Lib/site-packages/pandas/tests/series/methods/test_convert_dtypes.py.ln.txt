    1: from itertools import product
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: from pandas._libs import lib
    7: 
    8: import pandas as pd
    9: import pandas._testing as tm
   10: 
   11: # Each test case consists of a tuple with the data and dtype to create the
   12: # test Series, the default dtype for the expected result (which is valid
   13: # for most cases), and the specific cases where the result deviates from
   14: # this default. Those overrides are defined as a dict with (keyword, val) as
   15: # dictionary key. In case of multiple items, the last override takes precedence.
   16: 
   17: 
   18: @pytest.fixture(
   19:     params=[
   20:         (
   21:             # data
   22:             [1, 2, 3],
   23:             # original dtype
   24:             np.dtype("int32"),
   25:             # default expected dtype
   26:             "Int32",
   27:             # exceptions on expected dtype
   28:             {("convert_integer", False): np.dtype("int32")},
   29:         ),
   30:         (
   31:             [1, 2, 3],
   32:             np.dtype("int64"),
   33:             "Int64",
   34:             {("convert_integer", False): np.dtype("int64")},
   35:         ),
   36:         (
   37:             ["x", "y", "z"],
   38:             np.dtype("O"),
   39:             pd.StringDtype(),
   40:             {("convert_string", False): np.dtype("O")},
   41:         ),
   42:         (
   43:             [True, False, np.nan],
   44:             np.dtype("O"),
   45:             pd.BooleanDtype(),
   46:             {("convert_boolean", False): np.dtype("O")},
   47:         ),
   48:         (
   49:             ["h", "i", np.nan],
   50:             np.dtype("O"),
   51:             pd.StringDtype(),
   52:             {("convert_string", False): np.dtype("O")},
   53:         ),
   54:         (  # GH32117
   55:             ["h", "i", 1],
   56:             np.dtype("O"),
   57:             np.dtype("O"),
   58:             {},
   59:         ),
   60:         (
   61:             [10, np.nan, 20],
   62:             np.dtype("float"),
   63:             "Int64",
   64:             {
   65:                 ("convert_integer", False, "convert_floating", True): "Float64",
   66:                 ("convert_integer", False, "convert_floating", False): np.dtype(
   67:                     "float"
   68:                 ),
   69:             },
   70:         ),
   71:         (
   72:             [np.nan, 100.5, 200],
   73:             np.dtype("float"),
   74:             "Float64",
   75:             {("convert_floating", False): np.dtype("float")},
   76:         ),
   77:         (
   78:             [3, 4, 5],
   79:             "Int8",
   80:             "Int8",
   81:             {},
   82:         ),
   83:         (
   84:             [[1, 2], [3, 4], [5]],
   85:             None,
   86:             np.dtype("O"),
   87:             {},
   88:         ),
   89:         (
   90:             [4, 5, 6],
   91:             np.dtype("uint32"),
   92:             "UInt32",
   93:             {("convert_integer", False): np.dtype("uint32")},
   94:         ),
   95:         (
   96:             [-10, 12, 13],
   97:             np.dtype("i1"),
   98:             "Int8",
   99:             {("convert_integer", False): np.dtype("i1")},
  100:         ),
  101:         (
  102:             [1.2, 1.3],
  103:             np.dtype("float32"),
  104:             "Float32",
  105:             {("convert_floating", False): np.dtype("float32")},
  106:         ),
  107:         (
  108:             [1, 2.0],
  109:             object,
  110:             "Int64",
  111:             {
  112:                 ("convert_integer", False): "Float64",
  113:                 ("convert_integer", False, "convert_floating", False): np.dtype(
  114:                     "float"
  115:                 ),
  116:                 ("infer_objects", False): np.dtype("object"),
  117:             },
  118:         ),
  119:         (
  120:             [1, 2.5],
  121:             object,
  122:             "Float64",
  123:             {
  124:                 ("convert_floating", False): np.dtype("float"),
  125:                 ("infer_objects", False): np.dtype("object"),
  126:             },
  127:         ),
  128:         (["a", "b"], pd.CategoricalDtype(), pd.CategoricalDtype(), {}),
  129:         (
  130:             pd.to_datetime(["2020-01-14 10:00", "2020-01-15 11:11"]).as_unit("s"),
  131:             pd.DatetimeTZDtype(tz="UTC"),
  132:             pd.DatetimeTZDtype(tz="UTC"),
  133:             {},
  134:         ),
  135:         (
  136:             pd.to_datetime(["2020-01-14 10:00", "2020-01-15 11:11"]).as_unit("ms"),
  137:             pd.DatetimeTZDtype(tz="UTC"),
  138:             pd.DatetimeTZDtype(tz="UTC"),
  139:             {},
  140:         ),
  141:         (
  142:             pd.to_datetime(["2020-01-14 10:00", "2020-01-15 11:11"]).as_unit("us"),
  143:             pd.DatetimeTZDtype(tz="UTC"),
  144:             pd.DatetimeTZDtype(tz="UTC"),
  145:             {},
  146:         ),
  147:         (
  148:             pd.to_datetime(["2020-01-14 10:00", "2020-01-15 11:11"]).as_unit("ns"),
  149:             pd.DatetimeTZDtype(tz="UTC"),
  150:             pd.DatetimeTZDtype(tz="UTC"),
  151:             {},
  152:         ),
  153:         (
  154:             pd.to_datetime(["2020-01-14 10:00", "2020-01-15 11:11"]).as_unit("ns"),
  155:             "datetime64[ns]",
  156:             np.dtype("datetime64[ns]"),
  157:             {},
  158:         ),
  159:         (
  160:             pd.to_datetime(["2020-01-14 10:00", "2020-01-15 11:11"]).as_unit("ns"),
  161:             object,
  162:             np.dtype("datetime64[ns]"),
  163:             {("infer_objects", False): np.dtype("object")},
  164:         ),
  165:         (
  166:             pd.period_range("1/1/2011", freq="M", periods=3),
  167:             None,
  168:             pd.PeriodDtype("M"),
  169:             {},
  170:         ),
  171:         (
  172:             pd.arrays.IntervalArray([pd.Interval(0, 1), pd.Interval(1, 5)]),
  173:             None,
  174:             pd.IntervalDtype("int64", "right"),
  175:             {},
  176:         ),
  177:     ]
  178: )
  179: def test_cases(request):
  180:     return request.param
  181: 
  182: 
  183: class TestSeriesConvertDtypes:
  184:     @pytest.mark.parametrize("params", product(*[(True, False)] * 5))
  185:     def test_convert_dtypes(
  186:         self,
  187:         test_cases,
  188:         params,
  189:         using_infer_string,
  190:     ):
  191:         data, maindtype, expected_default, expected_other = test_cases
  192:         if (
  193:             hasattr(data, "dtype")
  194:             and lib.is_np_dtype(data.dtype, "M")
  195:             and isinstance(maindtype, pd.DatetimeTZDtype)
  196:         ):
  197:             # this astype is deprecated in favor of tz_localize
  198:             msg = "Cannot use .astype to convert from timezone-naive dtype"
  199:             with pytest.raises(TypeError, match=msg):
  200:                 pd.Series(data, dtype=maindtype)
  201:             return
  202: 
  203:         if maindtype is not None:
  204:             series = pd.Series(data, dtype=maindtype)
  205:         else:
  206:             series = pd.Series(data)
  207: 
  208:         result = series.convert_dtypes(*params)
  209: 
  210:         param_names = [
  211:             "infer_objects",
  212:             "convert_string",
  213:             "convert_integer",
  214:             "convert_boolean",
  215:             "convert_floating",
  216:         ]
  217:         params_dict = dict(zip(param_names, params))
  218: 
  219:         expected_dtype = expected_default
  220:         for spec, dtype in expected_other.items():
  221:             if all(params_dict[key] is val for key, val in zip(spec[::2], spec[1::2])):
  222:                 expected_dtype = dtype
  223:         if (
  224:             using_infer_string
  225:             and expected_default == "string"
  226:             and expected_dtype == object
  227:             and params[0]
  228:             and not params[1]
  229:         ):
  230:             # If we would convert with convert strings then infer_objects converts
  231:             # with the option
  232:             expected_dtype = "string[pyarrow_numpy]"
  233: 
  234:         expected = pd.Series(data, dtype=expected_dtype)
  235:         tm.assert_series_equal(result, expected)
  236: 
  237:         # Test that it is a copy
  238:         copy = series.copy(deep=True)
  239: 
  240:         if result.notna().sum() > 0 and result.dtype in ["interval[int64, right]"]:
  241:             with tm.assert_produces_warning(FutureWarning, match="incompatible dtype"):
  242:                 result[result.notna()] = np.nan
  243:         else:
  244:             result[result.notna()] = np.nan
  245: 
  246:         # Make sure original not changed
  247:         tm.assert_series_equal(series, copy)
  248: 
  249:     def test_convert_string_dtype(self, nullable_string_dtype):
  250:         # https://github.com/pandas-dev/pandas/issues/31731 -> converting columns
  251:         # that are already string dtype
  252:         df = pd.DataFrame(
  253:             {"A": ["a", "b", pd.NA], "B": ["Г¤", "Г¶", "Гј"]}, dtype=nullable_string_dtype
  254:         )
  255:         result = df.convert_dtypes()
  256:         tm.assert_frame_equal(df, result)
  257: 
  258:     def test_convert_bool_dtype(self):
  259:         # GH32287
  260:         df = pd.DataFrame({"A": pd.array([True])})
  261:         tm.assert_frame_equal(df, df.convert_dtypes())
  262: 
  263:     def test_convert_byte_string_dtype(self):
  264:         # GH-43183
  265:         byte_str = b"binary-string"
  266: 
  267:         df = pd.DataFrame(data={"A": byte_str}, index=[0])
  268:         result = df.convert_dtypes()
  269:         expected = df
  270:         tm.assert_frame_equal(result, expected)
  271: 
  272:     @pytest.mark.parametrize(
  273:         "infer_objects, dtype", [(True, "Int64"), (False, "object")]
  274:     )
  275:     def test_convert_dtype_object_with_na(self, infer_objects, dtype):
  276:         # GH#48791
  277:         ser = pd.Series([1, pd.NA])
  278:         result = ser.convert_dtypes(infer_objects=infer_objects)
  279:         expected = pd.Series([1, pd.NA], dtype=dtype)
  280:         tm.assert_series_equal(result, expected)
  281: 
  282:     @pytest.mark.parametrize(
  283:         "infer_objects, dtype", [(True, "Float64"), (False, "object")]
  284:     )
  285:     def test_convert_dtype_object_with_na_float(self, infer_objects, dtype):
  286:         # GH#48791
  287:         ser = pd.Series([1.5, pd.NA])
  288:         result = ser.convert_dtypes(infer_objects=infer_objects)
  289:         expected = pd.Series([1.5, pd.NA], dtype=dtype)
  290:         tm.assert_series_equal(result, expected)
  291: 
  292:     def test_convert_dtypes_pyarrow_to_np_nullable(self):
  293:         # GH 53648
  294:         pytest.importorskip("pyarrow")
  295:         ser = pd.Series(range(2), dtype="int32[pyarrow]")
  296:         result = ser.convert_dtypes(dtype_backend="numpy_nullable")
  297:         expected = pd.Series(range(2), dtype="Int32")
  298:         tm.assert_series_equal(result, expected)
  299: 
  300:     def test_convert_dtypes_pyarrow_null(self):
  301:         # GH#55346
  302:         pa = pytest.importorskip("pyarrow")
  303:         ser = pd.Series([None, None])
  304:         result = ser.convert_dtypes(dtype_backend="pyarrow")
  305:         expected = pd.Series([None, None], dtype=pd.ArrowDtype(pa.null()))
  306:         tm.assert_series_equal(result, expected)
