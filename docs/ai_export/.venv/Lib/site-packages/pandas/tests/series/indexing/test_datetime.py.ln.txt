    1: """
    2: Also test support for datetime64[ns] in Series / DataFrame
    3: """
    4: from datetime import (
    5:     datetime,
    6:     timedelta,
    7: )
    8: import re
    9: 
   10: from dateutil.tz import (
   11:     gettz,
   12:     tzutc,
   13: )
   14: import numpy as np
   15: import pytest
   16: import pytz
   17: 
   18: from pandas._libs import index as libindex
   19: 
   20: import pandas as pd
   21: from pandas import (
   22:     DataFrame,
   23:     Series,
   24:     Timestamp,
   25:     date_range,
   26:     period_range,
   27: )
   28: import pandas._testing as tm
   29: 
   30: 
   31: def test_fancy_getitem():
   32:     dti = date_range(
   33:         freq="WOM-1FRI", start=datetime(2005, 1, 1), end=datetime(2010, 1, 1)
   34:     )
   35: 
   36:     s = Series(np.arange(len(dti)), index=dti)
   37: 
   38:     msg = "Series.__getitem__ treating keys as positions is deprecated"
   39:     with tm.assert_produces_warning(FutureWarning, match=msg):
   40:         assert s[48] == 48
   41:     assert s["1/2/2009"] == 48
   42:     assert s["2009-1-2"] == 48
   43:     assert s[datetime(2009, 1, 2)] == 48
   44:     assert s[Timestamp(datetime(2009, 1, 2))] == 48
   45:     with pytest.raises(KeyError, match=r"^'2009-1-3'$"):
   46:         s["2009-1-3"]
   47:     tm.assert_series_equal(
   48:         s["3/6/2009":"2009-06-05"], s[datetime(2009, 3, 6) : datetime(2009, 6, 5)]
   49:     )
   50: 
   51: 
   52: def test_fancy_setitem():
   53:     dti = date_range(
   54:         freq="WOM-1FRI", start=datetime(2005, 1, 1), end=datetime(2010, 1, 1)
   55:     )
   56: 
   57:     s = Series(np.arange(len(dti)), index=dti)
   58: 
   59:     msg = "Series.__setitem__ treating keys as positions is deprecated"
   60:     with tm.assert_produces_warning(FutureWarning, match=msg):
   61:         s[48] = -1
   62:     assert s.iloc[48] == -1
   63:     s["1/2/2009"] = -2
   64:     assert s.iloc[48] == -2
   65:     s["1/2/2009":"2009-06-05"] = -3
   66:     assert (s[48:54] == -3).all()
   67: 
   68: 
   69: @pytest.mark.parametrize("tz_source", ["pytz", "dateutil"])
   70: def test_getitem_setitem_datetime_tz(tz_source):
   71:     if tz_source == "pytz":
   72:         tzget = pytz.timezone
   73:     else:
   74:         # handle special case for utc in dateutil
   75:         tzget = lambda x: tzutc() if x == "UTC" else gettz(x)
   76: 
   77:     N = 50
   78:     # testing with timezone, GH #2785
   79:     rng = date_range("1/1/1990", periods=N, freq="h", tz=tzget("US/Eastern"))
   80:     ts = Series(np.random.default_rng(2).standard_normal(N), index=rng)
   81: 
   82:     # also test Timestamp tz handling, GH #2789
   83:     result = ts.copy()
   84:     result["1990-01-01 09:00:00+00:00"] = 0
   85:     result["1990-01-01 09:00:00+00:00"] = ts.iloc[4]
   86:     tm.assert_series_equal(result, ts)
   87: 
   88:     result = ts.copy()
   89:     result["1990-01-01 03:00:00-06:00"] = 0
   90:     result["1990-01-01 03:00:00-06:00"] = ts.iloc[4]
   91:     tm.assert_series_equal(result, ts)
   92: 
   93:     # repeat with datetimes
   94:     result = ts.copy()
   95:     result[datetime(1990, 1, 1, 9, tzinfo=tzget("UTC"))] = 0
   96:     result[datetime(1990, 1, 1, 9, tzinfo=tzget("UTC"))] = ts.iloc[4]
   97:     tm.assert_series_equal(result, ts)
   98: 
   99:     result = ts.copy()
  100:     dt = Timestamp(1990, 1, 1, 3).tz_localize(tzget("US/Central"))
  101:     dt = dt.to_pydatetime()
  102:     result[dt] = 0
  103:     result[dt] = ts.iloc[4]
  104:     tm.assert_series_equal(result, ts)
  105: 
  106: 
  107: def test_getitem_setitem_datetimeindex():
  108:     N = 50
  109:     # testing with timezone, GH #2785
  110:     rng = date_range("1/1/1990", periods=N, freq="h", tz="US/Eastern")
  111:     ts = Series(np.random.default_rng(2).standard_normal(N), index=rng)
  112: 
  113:     result = ts["1990-01-01 04:00:00"]
  114:     expected = ts.iloc[4]
  115:     assert result == expected
  116: 
  117:     result = ts.copy()
  118:     result["1990-01-01 04:00:00"] = 0
  119:     result["1990-01-01 04:00:00"] = ts.iloc[4]
  120:     tm.assert_series_equal(result, ts)
  121: 
  122:     result = ts["1990-01-01 04:00:00":"1990-01-01 07:00:00"]
  123:     expected = ts[4:8]
  124:     tm.assert_series_equal(result, expected)
  125: 
  126:     result = ts.copy()
  127:     result["1990-01-01 04:00:00":"1990-01-01 07:00:00"] = 0
  128:     result["1990-01-01 04:00:00":"1990-01-01 07:00:00"] = ts[4:8]
  129:     tm.assert_series_equal(result, ts)
  130: 
  131:     lb = "1990-01-01 04:00:00"
  132:     rb = "1990-01-01 07:00:00"
  133:     # GH#18435 strings get a pass from tzawareness compat
  134:     result = ts[(ts.index >= lb) & (ts.index <= rb)]
  135:     expected = ts[4:8]
  136:     tm.assert_series_equal(result, expected)
  137: 
  138:     lb = "1990-01-01 04:00:00-0500"
  139:     rb = "1990-01-01 07:00:00-0500"
  140:     result = ts[(ts.index >= lb) & (ts.index <= rb)]
  141:     expected = ts[4:8]
  142:     tm.assert_series_equal(result, expected)
  143: 
  144:     # But we do not give datetimes a pass on tzawareness compat
  145:     msg = "Cannot compare tz-naive and tz-aware datetime-like objects"
  146:     naive = datetime(1990, 1, 1, 4)
  147:     for key in [naive, Timestamp(naive), np.datetime64(naive, "ns")]:
  148:         with pytest.raises(KeyError, match=re.escape(repr(key))):
  149:             # GH#36148 as of 2.0 we require tzawareness-compat
  150:             ts[key]
  151: 
  152:     result = ts.copy()
  153:     # GH#36148 as of 2.0 we do not ignore tzawareness mismatch in indexing,
  154:     #  so setting it as a new key casts to object rather than matching
  155:     #  rng[4]
  156:     result[naive] = ts.iloc[4]
  157:     assert result.index.dtype == object
  158:     tm.assert_index_equal(result.index[:-1], rng.astype(object))
  159:     assert result.index[-1] == naive
  160: 
  161:     msg = "Cannot compare tz-naive and tz-aware datetime-like objects"
  162:     with pytest.raises(TypeError, match=msg):
  163:         # GH#36148 require tzawareness compat as of 2.0
  164:         ts[naive : datetime(1990, 1, 1, 7)]
  165: 
  166:     result = ts.copy()
  167:     with pytest.raises(TypeError, match=msg):
  168:         # GH#36148 require tzawareness compat as of 2.0
  169:         result[naive : datetime(1990, 1, 1, 7)] = 0
  170:     with pytest.raises(TypeError, match=msg):
  171:         # GH#36148 require tzawareness compat as of 2.0
  172:         result[naive : datetime(1990, 1, 1, 7)] = 99
  173:     # the __setitems__ here failed, so result should still match ts
  174:     tm.assert_series_equal(result, ts)
  175: 
  176:     lb = naive
  177:     rb = datetime(1990, 1, 1, 7)
  178:     msg = r"Invalid comparison between dtype=datetime64\[ns, US/Eastern\] and datetime"
  179:     with pytest.raises(TypeError, match=msg):
  180:         # tznaive vs tzaware comparison is invalid
  181:         # see GH#18376, GH#18162
  182:         ts[(ts.index >= lb) & (ts.index <= rb)]
  183: 
  184:     lb = Timestamp(naive).tz_localize(rng.tzinfo)
  185:     rb = Timestamp(datetime(1990, 1, 1, 7)).tz_localize(rng.tzinfo)
  186:     result = ts[(ts.index >= lb) & (ts.index <= rb)]
  187:     expected = ts[4:8]
  188:     tm.assert_series_equal(result, expected)
  189: 
  190:     result = ts[ts.index[4]]
  191:     expected = ts.iloc[4]
  192:     assert result == expected
  193: 
  194:     result = ts[ts.index[4:8]]
  195:     expected = ts[4:8]
  196:     tm.assert_series_equal(result, expected)
  197: 
  198:     result = ts.copy()
  199:     result[ts.index[4:8]] = 0
  200:     result.iloc[4:8] = ts.iloc[4:8]
  201:     tm.assert_series_equal(result, ts)
  202: 
  203:     # also test partial date slicing
  204:     result = ts["1990-01-02"]
  205:     expected = ts[24:48]
  206:     tm.assert_series_equal(result, expected)
  207: 
  208:     result = ts.copy()
  209:     result["1990-01-02"] = 0
  210:     result["1990-01-02"] = ts[24:48]
  211:     tm.assert_series_equal(result, ts)
  212: 
  213: 
  214: def test_getitem_setitem_periodindex():
  215:     N = 50
  216:     rng = period_range("1/1/1990", periods=N, freq="h")
  217:     ts = Series(np.random.default_rng(2).standard_normal(N), index=rng)
  218: 
  219:     result = ts["1990-01-01 04"]
  220:     expected = ts.iloc[4]
  221:     assert result == expected
  222: 
  223:     result = ts.copy()
  224:     result["1990-01-01 04"] = 0
  225:     result["1990-01-01 04"] = ts.iloc[4]
  226:     tm.assert_series_equal(result, ts)
  227: 
  228:     result = ts["1990-01-01 04":"1990-01-01 07"]
  229:     expected = ts[4:8]
  230:     tm.assert_series_equal(result, expected)
  231: 
  232:     result = ts.copy()
  233:     result["1990-01-01 04":"1990-01-01 07"] = 0
  234:     result["1990-01-01 04":"1990-01-01 07"] = ts[4:8]
  235:     tm.assert_series_equal(result, ts)
  236: 
  237:     lb = "1990-01-01 04"
  238:     rb = "1990-01-01 07"
  239:     result = ts[(ts.index >= lb) & (ts.index <= rb)]
  240:     expected = ts[4:8]
  241:     tm.assert_series_equal(result, expected)
  242: 
  243:     # GH 2782
  244:     result = ts[ts.index[4]]
  245:     expected = ts.iloc[4]
  246:     assert result == expected
  247: 
  248:     result = ts[ts.index[4:8]]
  249:     expected = ts[4:8]
  250:     tm.assert_series_equal(result, expected)
  251: 
  252:     result = ts.copy()
  253:     result[ts.index[4:8]] = 0
  254:     result.iloc[4:8] = ts.iloc[4:8]
  255:     tm.assert_series_equal(result, ts)
  256: 
  257: 
  258: def test_datetime_indexing():
  259:     index = date_range("1/1/2000", "1/7/2000")
  260:     index = index.repeat(3)
  261: 
  262:     s = Series(len(index), index=index)
  263:     stamp = Timestamp("1/8/2000")
  264: 
  265:     with pytest.raises(KeyError, match=re.escape(repr(stamp))):
  266:         s[stamp]
  267:     s[stamp] = 0
  268:     assert s[stamp] == 0
  269: 
  270:     # not monotonic
  271:     s = Series(len(index), index=index)
  272:     s = s[::-1]
  273: 
  274:     with pytest.raises(KeyError, match=re.escape(repr(stamp))):
  275:         s[stamp]
  276:     s[stamp] = 0
  277:     assert s[stamp] == 0
  278: 
  279: 
  280: # test duplicates in time series
  281: 
  282: 
  283: def test_indexing_with_duplicate_datetimeindex(
  284:     rand_series_with_duplicate_datetimeindex,
  285: ):
  286:     ts = rand_series_with_duplicate_datetimeindex
  287: 
  288:     uniques = ts.index.unique()
  289:     for date in uniques:
  290:         result = ts[date]
  291: 
  292:         mask = ts.index == date
  293:         total = (ts.index == date).sum()
  294:         expected = ts[mask]
  295:         if total > 1:
  296:             tm.assert_series_equal(result, expected)
  297:         else:
  298:             tm.assert_almost_equal(result, expected.iloc[0])
  299: 
  300:         cp = ts.copy()
  301:         cp[date] = 0
  302:         expected = Series(np.where(mask, 0, ts), index=ts.index)
  303:         tm.assert_series_equal(cp, expected)
  304: 
  305:     key = datetime(2000, 1, 6)
  306:     with pytest.raises(KeyError, match=re.escape(repr(key))):
  307:         ts[key]
  308: 
  309:     # new index
  310:     ts[datetime(2000, 1, 6)] = 0
  311:     assert ts[datetime(2000, 1, 6)] == 0
  312: 
  313: 
  314: def test_loc_getitem_over_size_cutoff(monkeypatch):
  315:     # #1821
  316: 
  317:     monkeypatch.setattr(libindex, "_SIZE_CUTOFF", 1000)
  318: 
  319:     # create large list of non periodic datetime
  320:     dates = []
  321:     sec = timedelta(seconds=1)
  322:     half_sec = timedelta(microseconds=500000)
  323:     d = datetime(2011, 12, 5, 20, 30)
  324:     n = 1100
  325:     for i in range(n):
  326:         dates.append(d)
  327:         dates.append(d + sec)
  328:         dates.append(d + sec + half_sec)
  329:         dates.append(d + sec + sec + half_sec)
  330:         d += 3 * sec
  331: 
  332:     # duplicate some values in the list
  333:     duplicate_positions = np.random.default_rng(2).integers(0, len(dates) - 1, 20)
  334:     for p in duplicate_positions:
  335:         dates[p + 1] = dates[p]
  336: 
  337:     df = DataFrame(
  338:         np.random.default_rng(2).standard_normal((len(dates), 4)),
  339:         index=dates,
  340:         columns=list("ABCD"),
  341:     )
  342: 
  343:     pos = n * 3
  344:     timestamp = df.index[pos]
  345:     assert timestamp in df.index
  346: 
  347:     # it works!
  348:     df.loc[timestamp]
  349:     assert len(df.loc[[timestamp]]) > 0
  350: 
  351: 
  352: def test_indexing_over_size_cutoff_period_index(monkeypatch):
  353:     # GH 27136
  354: 
  355:     monkeypatch.setattr(libindex, "_SIZE_CUTOFF", 1000)
  356: 
  357:     n = 1100
  358:     idx = period_range("1/1/2000", freq="min", periods=n)
  359:     assert idx._engine.over_size_threshold
  360: 
  361:     s = Series(np.random.default_rng(2).standard_normal(len(idx)), index=idx)
  362: 
  363:     pos = n - 1
  364:     timestamp = idx[pos]
  365:     assert timestamp in s.index
  366: 
  367:     # it works!
  368:     s[timestamp]
  369:     assert len(s.loc[[timestamp]]) > 0
  370: 
  371: 
  372: def test_indexing_unordered():
  373:     # GH 2437
  374:     rng = date_range(start="2011-01-01", end="2011-01-15")
  375:     ts = Series(np.random.default_rng(2).random(len(rng)), index=rng)
  376:     ts2 = pd.concat([ts[0:4], ts[-4:], ts[4:-4]])
  377: 
  378:     for t in ts.index:
  379:         expected = ts[t]
  380:         result = ts2[t]
  381:         assert expected == result
  382: 
  383:     # GH 3448 (ranges)
  384:     def compare(slobj):
  385:         result = ts2[slobj].copy()
  386:         result = result.sort_index()
  387:         expected = ts[slobj]
  388:         expected.index = expected.index._with_freq(None)
  389:         tm.assert_series_equal(result, expected)
  390: 
  391:     for key in [
  392:         slice("2011-01-01", "2011-01-15"),
  393:         slice("2010-12-30", "2011-01-15"),
  394:         slice("2011-01-01", "2011-01-16"),
  395:         # partial ranges
  396:         slice("2011-01-01", "2011-01-6"),
  397:         slice("2011-01-06", "2011-01-8"),
  398:         slice("2011-01-06", "2011-01-12"),
  399:     ]:
  400:         with pytest.raises(
  401:             KeyError, match="Value based partial slicing on non-monotonic"
  402:         ):
  403:             compare(key)
  404: 
  405:     # single values
  406:     result = ts2["2011"].sort_index()
  407:     expected = ts["2011"]
  408:     expected.index = expected.index._with_freq(None)
  409:     tm.assert_series_equal(result, expected)
  410: 
  411: 
  412: def test_indexing_unordered2():
  413:     # diff freq
  414:     rng = date_range(datetime(2005, 1, 1), periods=20, freq="ME")
  415:     ts = Series(np.arange(len(rng)), index=rng)
  416:     ts = ts.take(np.random.default_rng(2).permutation(20))
  417: 
  418:     result = ts["2005"]
  419:     for t in result.index:
  420:         assert t.year == 2005
  421: 
  422: 
  423: def test_indexing():
  424:     idx = date_range("2001-1-1", periods=20, freq="ME")
  425:     ts = Series(np.random.default_rng(2).random(len(idx)), index=idx)
  426: 
  427:     # getting
  428: 
  429:     # GH 3070, make sure semantics work on Series/Frame
  430:     result = ts["2001"]
  431:     tm.assert_series_equal(result, ts.iloc[:12])
  432: 
  433:     df = DataFrame({"A": ts.copy()})
  434: 
  435:     # GH#36179 pre-2.0 df["2001"] operated as slicing on rows. in 2.0 it behaves
  436:     #  like any other key, so raises
  437:     with pytest.raises(KeyError, match="2001"):
  438:         df["2001"]
  439: 
  440:     # setting
  441:     ts = Series(np.random.default_rng(2).random(len(idx)), index=idx)
  442:     expected = ts.copy()
  443:     expected.iloc[:12] = 1
  444:     ts["2001"] = 1
  445:     tm.assert_series_equal(ts, expected)
  446: 
  447:     expected = df.copy()
  448:     expected.iloc[:12, 0] = 1
  449:     df.loc["2001", "A"] = 1
  450:     tm.assert_frame_equal(df, expected)
  451: 
  452: 
  453: def test_getitem_str_month_with_datetimeindex():
  454:     # GH3546 (not including times on the last day)
  455:     idx = date_range(start="2013-05-31 00:00", end="2013-05-31 23:00", freq="h")
  456:     ts = Series(range(len(idx)), index=idx)
  457:     expected = ts["2013-05"]
  458:     tm.assert_series_equal(expected, ts)
  459: 
  460:     idx = date_range(start="2013-05-31 00:00", end="2013-05-31 23:59", freq="s")
  461:     ts = Series(range(len(idx)), index=idx)
  462:     expected = ts["2013-05"]
  463:     tm.assert_series_equal(expected, ts)
  464: 
  465: 
  466: def test_getitem_str_year_with_datetimeindex():
  467:     idx = [
  468:         Timestamp("2013-05-31 00:00"),
  469:         Timestamp(datetime(2013, 5, 31, 23, 59, 59, 999999)),
  470:     ]
  471:     ts = Series(range(len(idx)), index=idx)
  472:     expected = ts["2013"]
  473:     tm.assert_series_equal(expected, ts)
  474: 
  475: 
  476: def test_getitem_str_second_with_datetimeindex():
  477:     # GH14826, indexing with a seconds resolution string / datetime object
  478:     df = DataFrame(
  479:         np.random.default_rng(2).random((5, 5)),
  480:         columns=["open", "high", "low", "close", "volume"],
  481:         index=date_range("2012-01-02 18:01:00", periods=5, tz="US/Central", freq="s"),
  482:     )
  483: 
  484:     # this is a single date, so will raise
  485:     with pytest.raises(KeyError, match=r"^'2012-01-02 18:01:02'$"):
  486:         df["2012-01-02 18:01:02"]
  487: 
  488:     msg = r"Timestamp\('2012-01-02 18:01:02-0600', tz='US/Central'\)"
  489:     with pytest.raises(KeyError, match=msg):
  490:         df[df.index[2]]
  491: 
  492: 
  493: def test_compare_datetime_with_all_none():
  494:     # GH#54870
  495:     ser = Series(["2020-01-01", "2020-01-02"], dtype="datetime64[ns]")
  496:     ser2 = Series([None, None])
  497:     result = ser > ser2
  498:     expected = Series([False, False])
  499:     tm.assert_series_equal(result, expected)
