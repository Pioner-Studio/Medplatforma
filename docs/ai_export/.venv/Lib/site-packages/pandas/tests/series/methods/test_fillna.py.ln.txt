    1: from datetime import (
    2:     datetime,
    3:     timedelta,
    4:     timezone,
    5: )
    6: 
    7: import numpy as np
    8: import pytest
    9: import pytz
   10: 
   11: from pandas import (
   12:     Categorical,
   13:     DataFrame,
   14:     DatetimeIndex,
   15:     NaT,
   16:     Period,
   17:     Series,
   18:     Timedelta,
   19:     Timestamp,
   20:     date_range,
   21:     isna,
   22:     timedelta_range,
   23: )
   24: import pandas._testing as tm
   25: from pandas.core.arrays import period_array
   26: 
   27: 
   28: @pytest.mark.filterwarnings(
   29:     "ignore:(Series|DataFrame).fillna with 'method' is deprecated:FutureWarning"
   30: )
   31: class TestSeriesFillNA:
   32:     def test_fillna_nat(self):
   33:         series = Series([0, 1, 2, NaT._value], dtype="M8[ns]")
   34: 
   35:         filled = series.fillna(method="pad")
   36:         filled2 = series.fillna(value=series.values[2])
   37: 
   38:         expected = series.copy()
   39:         expected.iloc[3] = expected.iloc[2]
   40: 
   41:         tm.assert_series_equal(filled, expected)
   42:         tm.assert_series_equal(filled2, expected)
   43: 
   44:         df = DataFrame({"A": series})
   45:         filled = df.fillna(method="pad")
   46:         filled2 = df.fillna(value=series.values[2])
   47:         expected = DataFrame({"A": expected})
   48:         tm.assert_frame_equal(filled, expected)
   49:         tm.assert_frame_equal(filled2, expected)
   50: 
   51:         series = Series([NaT._value, 0, 1, 2], dtype="M8[ns]")
   52: 
   53:         filled = series.fillna(method="bfill")
   54:         filled2 = series.fillna(value=series[1])
   55: 
   56:         expected = series.copy()
   57:         expected[0] = expected[1]
   58: 
   59:         tm.assert_series_equal(filled, expected)
   60:         tm.assert_series_equal(filled2, expected)
   61: 
   62:         df = DataFrame({"A": series})
   63:         filled = df.fillna(method="bfill")
   64:         filled2 = df.fillna(value=series[1])
   65:         expected = DataFrame({"A": expected})
   66:         tm.assert_frame_equal(filled, expected)
   67:         tm.assert_frame_equal(filled2, expected)
   68: 
   69:     def test_fillna_value_or_method(self, datetime_series):
   70:         msg = "Cannot specify both 'value' and 'method'"
   71:         with pytest.raises(ValueError, match=msg):
   72:             datetime_series.fillna(value=0, method="ffill")
   73: 
   74:     def test_fillna(self):
   75:         ts = Series(
   76:             [0.0, 1.0, 2.0, 3.0, 4.0], index=date_range("2020-01-01", periods=5)
   77:         )
   78: 
   79:         tm.assert_series_equal(ts, ts.fillna(method="ffill"))
   80: 
   81:         ts.iloc[2] = np.nan
   82: 
   83:         exp = Series([0.0, 1.0, 1.0, 3.0, 4.0], index=ts.index)
   84:         tm.assert_series_equal(ts.fillna(method="ffill"), exp)
   85: 
   86:         exp = Series([0.0, 1.0, 3.0, 3.0, 4.0], index=ts.index)
   87:         tm.assert_series_equal(ts.fillna(method="backfill"), exp)
   88: 
   89:         exp = Series([0.0, 1.0, 5.0, 3.0, 4.0], index=ts.index)
   90:         tm.assert_series_equal(ts.fillna(value=5), exp)
   91: 
   92:         msg = "Must specify a fill 'value' or 'method'"
   93:         with pytest.raises(ValueError, match=msg):
   94:             ts.fillna()
   95: 
   96:     def test_fillna_nonscalar(self):
   97:         # GH#5703
   98:         s1 = Series([np.nan])
   99:         s2 = Series([1])
  100:         result = s1.fillna(s2)
  101:         expected = Series([1.0])
  102:         tm.assert_series_equal(result, expected)
  103:         result = s1.fillna({})
  104:         tm.assert_series_equal(result, s1)
  105:         result = s1.fillna(Series((), dtype=object))
  106:         tm.assert_series_equal(result, s1)
  107:         result = s2.fillna(s1)
  108:         tm.assert_series_equal(result, s2)
  109:         result = s1.fillna({0: 1})
  110:         tm.assert_series_equal(result, expected)
  111:         result = s1.fillna({1: 1})
  112:         tm.assert_series_equal(result, Series([np.nan]))
  113:         result = s1.fillna({0: 1, 1: 1})
  114:         tm.assert_series_equal(result, expected)
  115:         result = s1.fillna(Series({0: 1, 1: 1}))
  116:         tm.assert_series_equal(result, expected)
  117:         result = s1.fillna(Series({0: 1, 1: 1}, index=[4, 5]))
  118:         tm.assert_series_equal(result, s1)
  119: 
  120:     def test_fillna_aligns(self):
  121:         s1 = Series([0, 1, 2], list("abc"))
  122:         s2 = Series([0, np.nan, 2], list("bac"))
  123:         result = s2.fillna(s1)
  124:         expected = Series([0, 0, 2.0], list("bac"))
  125:         tm.assert_series_equal(result, expected)
  126: 
  127:     def test_fillna_limit(self):
  128:         ser = Series(np.nan, index=[0, 1, 2])
  129:         result = ser.fillna(999, limit=1)
  130:         expected = Series([999, np.nan, np.nan], index=[0, 1, 2])
  131:         tm.assert_series_equal(result, expected)
  132: 
  133:         result = ser.fillna(999, limit=2)
  134:         expected = Series([999, 999, np.nan], index=[0, 1, 2])
  135:         tm.assert_series_equal(result, expected)
  136: 
  137:     def test_fillna_dont_cast_strings(self):
  138:         # GH#9043
  139:         # make sure a string representation of int/float values can be filled
  140:         # correctly without raising errors or being converted
  141:         vals = ["0", "1.5", "-0.3"]
  142:         for val in vals:
  143:             ser = Series([0, 1, np.nan, np.nan, 4], dtype="float64")
  144:             result = ser.fillna(val)
  145:             expected = Series([0, 1, val, val, 4], dtype="object")
  146:             tm.assert_series_equal(result, expected)
  147: 
  148:     def test_fillna_consistency(self):
  149:         # GH#16402
  150:         # fillna with a tz aware to a tz-naive, should result in object
  151: 
  152:         ser = Series([Timestamp("20130101"), NaT])
  153: 
  154:         result = ser.fillna(Timestamp("20130101", tz="US/Eastern"))
  155:         expected = Series(
  156:             [Timestamp("20130101"), Timestamp("2013-01-01", tz="US/Eastern")],
  157:             dtype="object",
  158:         )
  159:         tm.assert_series_equal(result, expected)
  160: 
  161:         result = ser.where([True, False], Timestamp("20130101", tz="US/Eastern"))
  162:         tm.assert_series_equal(result, expected)
  163: 
  164:         result = ser.where([True, False], Timestamp("20130101", tz="US/Eastern"))
  165:         tm.assert_series_equal(result, expected)
  166: 
  167:         # with a non-datetime
  168:         result = ser.fillna("foo")
  169:         expected = Series([Timestamp("20130101"), "foo"])
  170:         tm.assert_series_equal(result, expected)
  171: 
  172:         # assignment
  173:         ser2 = ser.copy()
  174:         with tm.assert_produces_warning(FutureWarning, match="incompatible dtype"):
  175:             ser2[1] = "foo"
  176:         tm.assert_series_equal(ser2, expected)
  177: 
  178:     def test_fillna_downcast(self):
  179:         # GH#15277
  180:         # infer int64 from float64
  181:         ser = Series([1.0, np.nan])
  182:         msg = "The 'downcast' keyword in fillna is deprecated"
  183:         with tm.assert_produces_warning(FutureWarning, match=msg):
  184:             result = ser.fillna(0, downcast="infer")
  185:         expected = Series([1, 0])
  186:         tm.assert_series_equal(result, expected)
  187: 
  188:         # infer int64 from float64 when fillna value is a dict
  189:         ser = Series([1.0, np.nan])
  190:         with tm.assert_produces_warning(FutureWarning, match=msg):
  191:             result = ser.fillna({1: 0}, downcast="infer")
  192:         expected = Series([1, 0])
  193:         tm.assert_series_equal(result, expected)
  194: 
  195:     def test_fillna_downcast_infer_objects_to_numeric(self):
  196:         # GH#44241 if we have object-dtype, 'downcast="infer"' should
  197:         #  _actually_ infer
  198: 
  199:         arr = np.arange(5).astype(object)
  200:         arr[3] = np.nan
  201: 
  202:         ser = Series(arr)
  203: 
  204:         msg = "The 'downcast' keyword in fillna is deprecated"
  205:         with tm.assert_produces_warning(FutureWarning, match=msg):
  206:             res = ser.fillna(3, downcast="infer")
  207:         expected = Series(np.arange(5), dtype=np.int64)
  208:         tm.assert_series_equal(res, expected)
  209: 
  210:         msg = "The 'downcast' keyword in ffill is deprecated"
  211:         with tm.assert_produces_warning(FutureWarning, match=msg):
  212:             res = ser.ffill(downcast="infer")
  213:         expected = Series([0, 1, 2, 2, 4], dtype=np.int64)
  214:         tm.assert_series_equal(res, expected)
  215: 
  216:         msg = "The 'downcast' keyword in bfill is deprecated"
  217:         with tm.assert_produces_warning(FutureWarning, match=msg):
  218:             res = ser.bfill(downcast="infer")
  219:         expected = Series([0, 1, 2, 4, 4], dtype=np.int64)
  220:         tm.assert_series_equal(res, expected)
  221: 
  222:         # with a non-round float present, we will downcast to float64
  223:         ser[2] = 2.5
  224: 
  225:         expected = Series([0, 1, 2.5, 3, 4], dtype=np.float64)
  226:         msg = "The 'downcast' keyword in fillna is deprecated"
  227:         with tm.assert_produces_warning(FutureWarning, match=msg):
  228:             res = ser.fillna(3, downcast="infer")
  229:         tm.assert_series_equal(res, expected)
  230: 
  231:         msg = "The 'downcast' keyword in ffill is deprecated"
  232:         with tm.assert_produces_warning(FutureWarning, match=msg):
  233:             res = ser.ffill(downcast="infer")
  234:         expected = Series([0, 1, 2.5, 2.5, 4], dtype=np.float64)
  235:         tm.assert_series_equal(res, expected)
  236: 
  237:         msg = "The 'downcast' keyword in bfill is deprecated"
  238:         with tm.assert_produces_warning(FutureWarning, match=msg):
  239:             res = ser.bfill(downcast="infer")
  240:         expected = Series([0, 1, 2.5, 4, 4], dtype=np.float64)
  241:         tm.assert_series_equal(res, expected)
  242: 
  243:     def test_timedelta_fillna(self, frame_or_series, unit):
  244:         # GH#3371
  245:         ser = Series(
  246:             [
  247:                 Timestamp("20130101"),
  248:                 Timestamp("20130101"),
  249:                 Timestamp("20130102"),
  250:                 Timestamp("20130103 9:01:01"),
  251:             ],
  252:             dtype=f"M8[{unit}]",
  253:         )
  254:         td = ser.diff()
  255:         obj = frame_or_series(td).copy()
  256: 
  257:         # reg fillna
  258:         result = obj.fillna(Timedelta(seconds=0))
  259:         expected = Series(
  260:             [
  261:                 timedelta(0),
  262:                 timedelta(0),
  263:                 timedelta(1),
  264:                 timedelta(days=1, seconds=9 * 3600 + 60 + 1),
  265:             ],
  266:             dtype=f"m8[{unit}]",
  267:         )
  268:         expected = frame_or_series(expected)
  269:         tm.assert_equal(result, expected)
  270: 
  271:         # GH#45746 pre-1.? ints were interpreted as seconds.  then that was
  272:         #  deprecated and changed to raise. In 2.0 it casts to common dtype,
  273:         #  consistent with every other dtype's behavior
  274:         res = obj.fillna(1)
  275:         expected = obj.astype(object).fillna(1)
  276:         tm.assert_equal(res, expected)
  277: 
  278:         result = obj.fillna(Timedelta(seconds=1))
  279:         expected = Series(
  280:             [
  281:                 timedelta(seconds=1),
  282:                 timedelta(0),
  283:                 timedelta(1),
  284:                 timedelta(days=1, seconds=9 * 3600 + 60 + 1),
  285:             ],
  286:             dtype=f"m8[{unit}]",
  287:         )
  288:         expected = frame_or_series(expected)
  289:         tm.assert_equal(result, expected)
  290: 
  291:         result = obj.fillna(timedelta(days=1, seconds=1))
  292:         expected = Series(
  293:             [
  294:                 timedelta(days=1, seconds=1),
  295:                 timedelta(0),
  296:                 timedelta(1),
  297:                 timedelta(days=1, seconds=9 * 3600 + 60 + 1),
  298:             ],
  299:             dtype=f"m8[{unit}]",
  300:         )
  301:         expected = frame_or_series(expected)
  302:         tm.assert_equal(result, expected)
  303: 
  304:         result = obj.fillna(np.timedelta64(10**9))
  305:         expected = Series(
  306:             [
  307:                 timedelta(seconds=1),
  308:                 timedelta(0),
  309:                 timedelta(1),
  310:                 timedelta(days=1, seconds=9 * 3600 + 60 + 1),
  311:             ],
  312:             dtype=f"m8[{unit}]",
  313:         )
  314:         expected = frame_or_series(expected)
  315:         tm.assert_equal(result, expected)
  316: 
  317:         result = obj.fillna(NaT)
  318:         expected = Series(
  319:             [
  320:                 NaT,
  321:                 timedelta(0),
  322:                 timedelta(1),
  323:                 timedelta(days=1, seconds=9 * 3600 + 60 + 1),
  324:             ],
  325:             dtype=f"m8[{unit}]",
  326:         )
  327:         expected = frame_or_series(expected)
  328:         tm.assert_equal(result, expected)
  329: 
  330:         # ffill
  331:         td[2] = np.nan
  332:         obj = frame_or_series(td).copy()
  333:         result = obj.ffill()
  334:         expected = td.fillna(Timedelta(seconds=0))
  335:         expected[0] = np.nan
  336:         expected = frame_or_series(expected)
  337: 
  338:         tm.assert_equal(result, expected)
  339: 
  340:         # bfill
  341:         td[2] = np.nan
  342:         obj = frame_or_series(td)
  343:         result = obj.bfill()
  344:         expected = td.fillna(Timedelta(seconds=0))
  345:         expected[2] = timedelta(days=1, seconds=9 * 3600 + 60 + 1)
  346:         expected = frame_or_series(expected)
  347:         tm.assert_equal(result, expected)
  348: 
  349:     def test_datetime64_fillna(self):
  350:         ser = Series(
  351:             [
  352:                 Timestamp("20130101"),
  353:                 Timestamp("20130101"),
  354:                 Timestamp("20130102"),
  355:                 Timestamp("20130103 9:01:01"),
  356:             ]
  357:         )
  358:         ser[2] = np.nan
  359: 
  360:         # ffill
  361:         result = ser.ffill()
  362:         expected = Series(
  363:             [
  364:                 Timestamp("20130101"),
  365:                 Timestamp("20130101"),
  366:                 Timestamp("20130101"),
  367:                 Timestamp("20130103 9:01:01"),
  368:             ]
  369:         )
  370:         tm.assert_series_equal(result, expected)
  371: 
  372:         # bfill
  373:         result = ser.bfill()
  374:         expected = Series(
  375:             [
  376:                 Timestamp("20130101"),
  377:                 Timestamp("20130101"),
  378:                 Timestamp("20130103 9:01:01"),
  379:                 Timestamp("20130103 9:01:01"),
  380:             ]
  381:         )
  382:         tm.assert_series_equal(result, expected)
  383: 
  384:     @pytest.mark.parametrize(
  385:         "scalar",
  386:         [
  387:             False,
  388:             pytest.param(
  389:                 True,
  390:                 marks=pytest.mark.xfail(
  391:                     reason="GH#56410 scalar case not yet addressed"
  392:                 ),
  393:             ),
  394:         ],
  395:     )
  396:     @pytest.mark.parametrize("tz", [None, "UTC"])
  397:     def test_datetime64_fillna_mismatched_reso_no_rounding(self, tz, scalar):
  398:         # GH#56410
  399:         dti = date_range("2016-01-01", periods=3, unit="s", tz=tz)
  400:         item = Timestamp("2016-02-03 04:05:06.789", tz=tz)
  401:         vec = date_range(item, periods=3, unit="ms")
  402: 
  403:         exp_dtype = "M8[ms]" if tz is None else "M8[ms, UTC]"
  404:         expected = Series([item, dti[1], dti[2]], dtype=exp_dtype)
  405: 
  406:         ser = Series(dti)
  407:         ser[0] = NaT
  408:         ser2 = ser.copy()
  409: 
  410:         res = ser.fillna(item)
  411:         res2 = ser2.fillna(Series(vec))
  412: 
  413:         if scalar:
  414:             tm.assert_series_equal(res, expected)
  415:         else:
  416:             tm.assert_series_equal(res2, expected)
  417: 
  418:     @pytest.mark.parametrize(
  419:         "scalar",
  420:         [
  421:             False,
  422:             pytest.param(
  423:                 True,
  424:                 marks=pytest.mark.xfail(
  425:                     reason="GH#56410 scalar case not yet addressed"
  426:                 ),
  427:             ),
  428:         ],
  429:     )
  430:     def test_timedelta64_fillna_mismatched_reso_no_rounding(self, scalar):
  431:         # GH#56410
  432:         tdi = date_range("2016-01-01", periods=3, unit="s") - Timestamp("1970-01-01")
  433:         item = Timestamp("2016-02-03 04:05:06.789") - Timestamp("1970-01-01")
  434:         vec = timedelta_range(item, periods=3, unit="ms")
  435: 
  436:         expected = Series([item, tdi[1], tdi[2]], dtype="m8[ms]")
  437: 
  438:         ser = Series(tdi)
  439:         ser[0] = NaT
  440:         ser2 = ser.copy()
  441: 
  442:         res = ser.fillna(item)
  443:         res2 = ser2.fillna(Series(vec))
  444: 
  445:         if scalar:
  446:             tm.assert_series_equal(res, expected)
  447:         else:
  448:             tm.assert_series_equal(res2, expected)
  449: 
  450:     def test_datetime64_fillna_backfill(self):
  451:         # GH#6587
  452:         # make sure that we are treating as integer when filling
  453:         ser = Series([NaT, NaT, "2013-08-05 15:30:00.000001"], dtype="M8[ns]")
  454: 
  455:         expected = Series(
  456:             [
  457:                 "2013-08-05 15:30:00.000001",
  458:                 "2013-08-05 15:30:00.000001",
  459:                 "2013-08-05 15:30:00.000001",
  460:             ],
  461:             dtype="M8[ns]",
  462:         )
  463:         result = ser.fillna(method="backfill")
  464:         tm.assert_series_equal(result, expected)
  465: 
  466:     @pytest.mark.parametrize("tz", ["US/Eastern", "Asia/Tokyo"])
  467:     def test_datetime64_tz_fillna(self, tz, unit):
  468:         # DatetimeLikeBlock
  469:         ser = Series(
  470:             [
  471:                 Timestamp("2011-01-01 10:00"),
  472:                 NaT,
  473:                 Timestamp("2011-01-03 10:00"),
  474:                 NaT,
  475:             ],
  476:             dtype=f"M8[{unit}]",
  477:         )
  478:         null_loc = Series([False, True, False, True])
  479: 
  480:         result = ser.fillna(Timestamp("2011-01-02 10:00"))
  481:         expected = Series(
  482:             [
  483:                 Timestamp("2011-01-01 10:00"),
  484:                 Timestamp("2011-01-02 10:00"),
  485:                 Timestamp("2011-01-03 10:00"),
  486:                 Timestamp("2011-01-02 10:00"),
  487:             ],
  488:             dtype=f"M8[{unit}]",
  489:         )
  490:         tm.assert_series_equal(expected, result)
  491:         # check s is not changed
  492:         tm.assert_series_equal(isna(ser), null_loc)
  493: 
  494:         result = ser.fillna(Timestamp("2011-01-02 10:00", tz=tz))
  495:         expected = Series(
  496:             [
  497:                 Timestamp("2011-01-01 10:00"),
  498:                 Timestamp("2011-01-02 10:00", tz=tz),
  499:                 Timestamp("2011-01-03 10:00"),
  500:                 Timestamp("2011-01-02 10:00", tz=tz),
  501:             ]
  502:         )
  503:         tm.assert_series_equal(expected, result)
  504:         tm.assert_series_equal(isna(ser), null_loc)
  505: 
  506:         result = ser.fillna("AAA")
  507:         expected = Series(
  508:             [
  509:                 Timestamp("2011-01-01 10:00"),
  510:                 "AAA",
  511:                 Timestamp("2011-01-03 10:00"),
  512:                 "AAA",
  513:             ],
  514:             dtype=object,
  515:         )
  516:         tm.assert_series_equal(expected, result)
  517:         tm.assert_series_equal(isna(ser), null_loc)
  518: 
  519:         result = ser.fillna(
  520:             {
  521:                 1: Timestamp("2011-01-02 10:00", tz=tz),
  522:                 3: Timestamp("2011-01-04 10:00"),
  523:             }
  524:         )
  525:         expected = Series(
  526:             [
  527:                 Timestamp("2011-01-01 10:00"),
  528:                 Timestamp("2011-01-02 10:00", tz=tz),
  529:                 Timestamp("2011-01-03 10:00"),
  530:                 Timestamp("2011-01-04 10:00"),
  531:             ]
  532:         )
  533:         tm.assert_series_equal(expected, result)
  534:         tm.assert_series_equal(isna(ser), null_loc)
  535: 
  536:         result = ser.fillna(
  537:             {1: Timestamp("2011-01-02 10:00"), 3: Timestamp("2011-01-04 10:00")}
  538:         )
  539:         expected = Series(
  540:             [
  541:                 Timestamp("2011-01-01 10:00"),
  542:                 Timestamp("2011-01-02 10:00"),
  543:                 Timestamp("2011-01-03 10:00"),
  544:                 Timestamp("2011-01-04 10:00"),
  545:             ],
  546:             dtype=f"M8[{unit}]",
  547:         )
  548:         tm.assert_series_equal(expected, result)
  549:         tm.assert_series_equal(isna(ser), null_loc)
  550: 
  551:         # DatetimeTZBlock
  552:         idx = DatetimeIndex(
  553:             ["2011-01-01 10:00", NaT, "2011-01-03 10:00", NaT], tz=tz
  554:         ).as_unit(unit)
  555:         ser = Series(idx)
  556:         assert ser.dtype == f"datetime64[{unit}, {tz}]"
  557:         tm.assert_series_equal(isna(ser), null_loc)
  558: 
  559:         result = ser.fillna(Timestamp("2011-01-02 10:00"))
  560:         expected = Series(
  561:             [
  562:                 Timestamp("2011-01-01 10:00", tz=tz),
  563:                 Timestamp("2011-01-02 10:00"),
  564:                 Timestamp("2011-01-03 10:00", tz=tz),
  565:                 Timestamp("2011-01-02 10:00"),
  566:             ]
  567:         )
  568:         tm.assert_series_equal(expected, result)
  569:         tm.assert_series_equal(isna(ser), null_loc)
  570: 
  571:         result = ser.fillna(Timestamp("2011-01-02 10:00", tz=tz))
  572:         idx = DatetimeIndex(
  573:             [
  574:                 "2011-01-01 10:00",
  575:                 "2011-01-02 10:00",
  576:                 "2011-01-03 10:00",
  577:                 "2011-01-02 10:00",
  578:             ],
  579:             tz=tz,
  580:         ).as_unit(unit)
  581:         expected = Series(idx)
  582:         tm.assert_series_equal(expected, result)
  583:         tm.assert_series_equal(isna(ser), null_loc)
  584: 
  585:         result = ser.fillna(Timestamp("2011-01-02 10:00", tz=tz).to_pydatetime())
  586:         idx = DatetimeIndex(
  587:             [
  588:                 "2011-01-01 10:00",
  589:                 "2011-01-02 10:00",
  590:                 "2011-01-03 10:00",
  591:                 "2011-01-02 10:00",
  592:             ],
  593:             tz=tz,
  594:         ).as_unit(unit)
  595:         expected = Series(idx)
  596:         tm.assert_series_equal(expected, result)
  597:         tm.assert_series_equal(isna(ser), null_loc)
  598: 
  599:         result = ser.fillna("AAA")
  600:         expected = Series(
  601:             [
  602:                 Timestamp("2011-01-01 10:00", tz=tz),
  603:                 "AAA",
  604:                 Timestamp("2011-01-03 10:00", tz=tz),
  605:                 "AAA",
  606:             ],
  607:             dtype=object,
  608:         )
  609:         tm.assert_series_equal(expected, result)
  610:         tm.assert_series_equal(isna(ser), null_loc)
  611: 
  612:         result = ser.fillna(
  613:             {
  614:                 1: Timestamp("2011-01-02 10:00", tz=tz),
  615:                 3: Timestamp("2011-01-04 10:00"),
  616:             }
  617:         )
  618:         expected = Series(
  619:             [
  620:                 Timestamp("2011-01-01 10:00", tz=tz),
  621:                 Timestamp("2011-01-02 10:00", tz=tz),
  622:                 Timestamp("2011-01-03 10:00", tz=tz),
  623:                 Timestamp("2011-01-04 10:00"),
  624:             ]
  625:         )
  626:         tm.assert_series_equal(expected, result)
  627:         tm.assert_series_equal(isna(ser), null_loc)
  628: 
  629:         result = ser.fillna(
  630:             {
  631:                 1: Timestamp("2011-01-02 10:00", tz=tz),
  632:                 3: Timestamp("2011-01-04 10:00", tz=tz),
  633:             }
  634:         )
  635:         expected = Series(
  636:             [
  637:                 Timestamp("2011-01-01 10:00", tz=tz),
  638:                 Timestamp("2011-01-02 10:00", tz=tz),
  639:                 Timestamp("2011-01-03 10:00", tz=tz),
  640:                 Timestamp("2011-01-04 10:00", tz=tz),
  641:             ]
  642:         ).dt.as_unit(unit)
  643:         tm.assert_series_equal(expected, result)
  644:         tm.assert_series_equal(isna(ser), null_loc)
  645: 
  646:         # filling with a naive/other zone, coerce to object
  647:         result = ser.fillna(Timestamp("20130101"))
  648:         expected = Series(
  649:             [
  650:                 Timestamp("2011-01-01 10:00", tz=tz),
  651:                 Timestamp("2013-01-01"),
  652:                 Timestamp("2011-01-03 10:00", tz=tz),
  653:                 Timestamp("2013-01-01"),
  654:             ]
  655:         )
  656:         tm.assert_series_equal(expected, result)
  657:         tm.assert_series_equal(isna(ser), null_loc)
  658: 
  659:         # pre-2.0 fillna with mixed tzs would cast to object, in 2.0
  660:         #  it retains dtype.
  661:         result = ser.fillna(Timestamp("20130101", tz="US/Pacific"))
  662:         expected = Series(
  663:             [
  664:                 Timestamp("2011-01-01 10:00", tz=tz),
  665:                 Timestamp("2013-01-01", tz="US/Pacific").tz_convert(tz),
  666:                 Timestamp("2011-01-03 10:00", tz=tz),
  667:                 Timestamp("2013-01-01", tz="US/Pacific").tz_convert(tz),
  668:             ]
  669:         ).dt.as_unit(unit)
  670:         tm.assert_series_equal(expected, result)
  671:         tm.assert_series_equal(isna(ser), null_loc)
  672: 
  673:     def test_fillna_dt64tz_with_method(self):
  674:         # with timezone
  675:         # GH#15855
  676:         ser = Series([Timestamp("2012-11-11 00:00:00+01:00"), NaT])
  677:         exp = Series(
  678:             [
  679:                 Timestamp("2012-11-11 00:00:00+01:00"),
  680:                 Timestamp("2012-11-11 00:00:00+01:00"),
  681:             ]
  682:         )
  683:         tm.assert_series_equal(ser.fillna(method="pad"), exp)
  684: 
  685:         ser = Series([NaT, Timestamp("2012-11-11 00:00:00+01:00")])
  686:         exp = Series(
  687:             [
  688:                 Timestamp("2012-11-11 00:00:00+01:00"),
  689:                 Timestamp("2012-11-11 00:00:00+01:00"),
  690:             ]
  691:         )
  692:         tm.assert_series_equal(ser.fillna(method="bfill"), exp)
  693: 
  694:     def test_fillna_pytimedelta(self):
  695:         # GH#8209
  696:         ser = Series([np.nan, Timedelta("1 days")], index=["A", "B"])
  697: 
  698:         result = ser.fillna(timedelta(1))
  699:         expected = Series(Timedelta("1 days"), index=["A", "B"])
  700:         tm.assert_series_equal(result, expected)
  701: 
  702:     def test_fillna_period(self):
  703:         # GH#13737
  704:         ser = Series([Period("2011-01", freq="M"), Period("NaT", freq="M")])
  705: 
  706:         res = ser.fillna(Period("2012-01", freq="M"))
  707:         exp = Series([Period("2011-01", freq="M"), Period("2012-01", freq="M")])
  708:         tm.assert_series_equal(res, exp)
  709:         assert res.dtype == "Period[M]"
  710: 
  711:     def test_fillna_dt64_timestamp(self, frame_or_series):
  712:         ser = Series(
  713:             [
  714:                 Timestamp("20130101"),
  715:                 Timestamp("20130101"),
  716:                 Timestamp("20130102"),
  717:                 Timestamp("20130103 9:01:01"),
  718:             ]
  719:         )
  720:         ser[2] = np.nan
  721:         obj = frame_or_series(ser)
  722: 
  723:         # reg fillna
  724:         result = obj.fillna(Timestamp("20130104"))
  725:         expected = Series(
  726:             [
  727:                 Timestamp("20130101"),
  728:                 Timestamp("20130101"),
  729:                 Timestamp("20130104"),
  730:                 Timestamp("20130103 9:01:01"),
  731:             ]
  732:         )
  733:         expected = frame_or_series(expected)
  734:         tm.assert_equal(result, expected)
  735: 
  736:         result = obj.fillna(NaT)
  737:         expected = obj
  738:         tm.assert_equal(result, expected)
  739: 
  740:     def test_fillna_dt64_non_nao(self):
  741:         # GH#27419
  742:         ser = Series([Timestamp("2010-01-01"), NaT, Timestamp("2000-01-01")])
  743:         val = np.datetime64("1975-04-05", "ms")
  744: 
  745:         result = ser.fillna(val)
  746:         expected = Series(
  747:             [Timestamp("2010-01-01"), Timestamp("1975-04-05"), Timestamp("2000-01-01")]
  748:         )
  749:         tm.assert_series_equal(result, expected)
  750: 
  751:     def test_fillna_numeric_inplace(self):
  752:         x = Series([np.nan, 1.0, np.nan, 3.0, np.nan], ["z", "a", "b", "c", "d"])
  753:         y = x.copy()
  754: 
  755:         return_value = y.fillna(value=0, inplace=True)
  756:         assert return_value is None
  757: 
  758:         expected = x.fillna(value=0)
  759:         tm.assert_series_equal(y, expected)
  760: 
  761:     # ---------------------------------------------------------------
  762:     # CategoricalDtype
  763: 
  764:     @pytest.mark.parametrize(
  765:         "fill_value, expected_output",
  766:         [
  767:             ("a", ["a", "a", "b", "a", "a"]),
  768:             ({1: "a", 3: "b", 4: "b"}, ["a", "a", "b", "b", "b"]),
  769:             ({1: "a"}, ["a", "a", "b", np.nan, np.nan]),
  770:             ({1: "a", 3: "b"}, ["a", "a", "b", "b", np.nan]),
  771:             (Series("a"), ["a", np.nan, "b", np.nan, np.nan]),
  772:             (Series("a", index=[1]), ["a", "a", "b", np.nan, np.nan]),
  773:             (Series({1: "a", 3: "b"}), ["a", "a", "b", "b", np.nan]),
  774:             (Series(["a", "b"], index=[3, 4]), ["a", np.nan, "b", "a", "b"]),
  775:         ],
  776:     )
  777:     def test_fillna_categorical(self, fill_value, expected_output):
  778:         # GH#17033
  779:         # Test fillna for a Categorical series
  780:         data = ["a", np.nan, "b", np.nan, np.nan]
  781:         ser = Series(Categorical(data, categories=["a", "b"]))
  782:         exp = Series(Categorical(expected_output, categories=["a", "b"]))
  783:         result = ser.fillna(fill_value)
  784:         tm.assert_series_equal(result, exp)
  785: 
  786:     @pytest.mark.parametrize(
  787:         "fill_value, expected_output",
  788:         [
  789:             (Series(["a", "b", "c", "d", "e"]), ["a", "b", "b", "d", "e"]),
  790:             (Series(["b", "d", "a", "d", "a"]), ["a", "d", "b", "d", "a"]),
  791:             (
  792:                 Series(
  793:                     Categorical(
  794:                         ["b", "d", "a", "d", "a"], categories=["b", "c", "d", "e", "a"]
  795:                     )
  796:                 ),
  797:                 ["a", "d", "b", "d", "a"],
  798:             ),
  799:         ],
  800:     )
  801:     def test_fillna_categorical_with_new_categories(self, fill_value, expected_output):
  802:         # GH#26215
  803:         data = ["a", np.nan, "b", np.nan, np.nan]
  804:         ser = Series(Categorical(data, categories=["a", "b", "c", "d", "e"]))
  805:         exp = Series(Categorical(expected_output, categories=["a", "b", "c", "d", "e"]))
  806:         result = ser.fillna(fill_value)
  807:         tm.assert_series_equal(result, exp)
  808: 
  809:     def test_fillna_categorical_raises(self):
  810:         data = ["a", np.nan, "b", np.nan, np.nan]
  811:         ser = Series(Categorical(data, categories=["a", "b"]))
  812:         cat = ser._values
  813: 
  814:         msg = "Cannot setitem on a Categorical with a new category"
  815:         with pytest.raises(TypeError, match=msg):
  816:             ser.fillna("d")
  817: 
  818:         msg2 = "Length of 'value' does not match."
  819:         with pytest.raises(ValueError, match=msg2):
  820:             cat.fillna(Series("d"))
  821: 
  822:         with pytest.raises(TypeError, match=msg):
  823:             ser.fillna({1: "d", 3: "a"})
  824: 
  825:         msg = '"value" parameter must be a scalar or dict, but you passed a "list"'
  826:         with pytest.raises(TypeError, match=msg):
  827:             ser.fillna(["a", "b"])
  828: 
  829:         msg = '"value" parameter must be a scalar or dict, but you passed a "tuple"'
  830:         with pytest.raises(TypeError, match=msg):
  831:             ser.fillna(("a", "b"))
  832: 
  833:         msg = (
  834:             '"value" parameter must be a scalar, dict '
  835:             'or Series, but you passed a "DataFrame"'
  836:         )
  837:         with pytest.raises(TypeError, match=msg):
  838:             ser.fillna(DataFrame({1: ["a"], 3: ["b"]}))
  839: 
  840:     @pytest.mark.parametrize("dtype", [float, "float32", "float64"])
  841:     @pytest.mark.parametrize("fill_type", tm.ALL_REAL_NUMPY_DTYPES)
  842:     @pytest.mark.parametrize("scalar", [True, False])
  843:     def test_fillna_float_casting(self, dtype, fill_type, scalar):
  844:         # GH-43424
  845:         ser = Series([np.nan, 1.2], dtype=dtype)
  846:         fill_values = Series([2, 2], dtype=fill_type)
  847:         if scalar:
  848:             fill_values = fill_values.dtype.type(2)
  849: 
  850:         result = ser.fillna(fill_values)
  851:         expected = Series([2.0, 1.2], dtype=dtype)
  852:         tm.assert_series_equal(result, expected)
  853: 
  854:         ser = Series([np.nan, 1.2], dtype=dtype)
  855:         mask = ser.isna().to_numpy()
  856:         ser[mask] = fill_values
  857:         tm.assert_series_equal(ser, expected)
  858: 
  859:         ser = Series([np.nan, 1.2], dtype=dtype)
  860:         ser.mask(mask, fill_values, inplace=True)
  861:         tm.assert_series_equal(ser, expected)
  862: 
  863:         ser = Series([np.nan, 1.2], dtype=dtype)
  864:         res = ser.where(~mask, fill_values)
  865:         tm.assert_series_equal(res, expected)
  866: 
  867:     def test_fillna_f32_upcast_with_dict(self):
  868:         # GH-43424
  869:         ser = Series([np.nan, 1.2], dtype=np.float32)
  870:         result = ser.fillna({0: 1})
  871:         expected = Series([1.0, 1.2], dtype=np.float32)
  872:         tm.assert_series_equal(result, expected)
  873: 
  874:     # ---------------------------------------------------------------
  875:     # Invalid Usages
  876: 
  877:     def test_fillna_invalid_method(self, datetime_series):
  878:         try:
  879:             datetime_series.fillna(method="ffil")
  880:         except ValueError as inst:
  881:             assert "ffil" in str(inst)
  882: 
  883:     def test_fillna_listlike_invalid(self):
  884:         ser = Series(np.random.default_rng(2).integers(-100, 100, 50))
  885:         msg = '"value" parameter must be a scalar or dict, but you passed a "list"'
  886:         with pytest.raises(TypeError, match=msg):
  887:             ser.fillna([1, 2])
  888: 
  889:         msg = '"value" parameter must be a scalar or dict, but you passed a "tuple"'
  890:         with pytest.raises(TypeError, match=msg):
  891:             ser.fillna((1, 2))
  892: 
  893:     def test_fillna_method_and_limit_invalid(self):
  894:         # related GH#9217, make sure limit is an int and greater than 0
  895:         ser = Series([1, 2, 3, None])
  896:         msg = "|".join(
  897:             [
  898:                 r"Cannot specify both 'value' and 'method'\.",
  899:                 "Limit must be greater than 0",
  900:                 "Limit must be an integer",
  901:             ]
  902:         )
  903:         for limit in [-1, 0, 1.0, 2.0]:
  904:             for method in ["backfill", "bfill", "pad", "ffill", None]:
  905:                 with pytest.raises(ValueError, match=msg):
  906:                     ser.fillna(1, limit=limit, method=method)
  907: 
  908:     def test_fillna_datetime64_with_timezone_tzinfo(self):
  909:         # https://github.com/pandas-dev/pandas/issues/38851
  910:         # different tzinfos representing UTC treated as equal
  911:         ser = Series(date_range("2020", periods=3, tz="UTC"))
  912:         expected = ser.copy()
  913:         ser[1] = NaT
  914:         result = ser.fillna(datetime(2020, 1, 2, tzinfo=timezone.utc))
  915:         tm.assert_series_equal(result, expected)
  916: 
  917:         # pre-2.0 we cast to object with mixed tzs, in 2.0 we retain dtype
  918:         ts = Timestamp("2000-01-01", tz="US/Pacific")
  919:         ser2 = Series(ser._values.tz_convert("dateutil/US/Pacific"))
  920:         assert ser2.dtype.kind == "M"
  921:         result = ser2.fillna(ts)
  922:         expected = Series(
  923:             [ser2[0], ts.tz_convert(ser2.dtype.tz), ser2[2]],
  924:             dtype=ser2.dtype,
  925:         )
  926:         tm.assert_series_equal(result, expected)
  927: 
  928:     @pytest.mark.parametrize(
  929:         "input, input_fillna, expected_data, expected_categories",
  930:         [
  931:             (["A", "B", None, "A"], "B", ["A", "B", "B", "A"], ["A", "B"]),
  932:             (["A", "B", np.nan, "A"], "B", ["A", "B", "B", "A"], ["A", "B"]),
  933:         ],
  934:     )
  935:     def test_fillna_categorical_accept_same_type(
  936:         self, input, input_fillna, expected_data, expected_categories
  937:     ):
  938:         # GH32414
  939:         cat = Categorical(input)
  940:         ser = Series(cat).fillna(input_fillna)
  941:         filled = cat.fillna(ser)
  942:         result = cat.fillna(filled)
  943:         expected = Categorical(expected_data, categories=expected_categories)
  944:         tm.assert_categorical_equal(result, expected)
  945: 
  946: 
  947: @pytest.mark.filterwarnings(
  948:     "ignore:Series.fillna with 'method' is deprecated:FutureWarning"
  949: )
  950: class TestFillnaPad:
  951:     def test_fillna_bug(self):
  952:         ser = Series([np.nan, 1.0, np.nan, 3.0, np.nan], ["z", "a", "b", "c", "d"])
  953:         filled = ser.fillna(method="ffill")
  954:         expected = Series([np.nan, 1.0, 1.0, 3.0, 3.0], ser.index)
  955:         tm.assert_series_equal(filled, expected)
  956: 
  957:         filled = ser.fillna(method="bfill")
  958:         expected = Series([1.0, 1.0, 3.0, 3.0, np.nan], ser.index)
  959:         tm.assert_series_equal(filled, expected)
  960: 
  961:     def test_ffill(self):
  962:         ts = Series(
  963:             [0.0, 1.0, 2.0, 3.0, 4.0], index=date_range("2020-01-01", periods=5)
  964:         )
  965:         ts.iloc[2] = np.nan
  966:         tm.assert_series_equal(ts.ffill(), ts.fillna(method="ffill"))
  967: 
  968:     def test_ffill_mixed_dtypes_without_missing_data(self):
  969:         # GH#14956
  970:         series = Series([datetime(2015, 1, 1, tzinfo=pytz.utc), 1])
  971:         result = series.ffill()
  972:         tm.assert_series_equal(series, result)
  973: 
  974:     def test_bfill(self):
  975:         ts = Series(
  976:             [0.0, 1.0, 2.0, 3.0, 4.0], index=date_range("2020-01-01", periods=5)
  977:         )
  978:         ts.iloc[2] = np.nan
  979:         tm.assert_series_equal(ts.bfill(), ts.fillna(method="bfill"))
  980: 
  981:     def test_pad_nan(self):
  982:         x = Series(
  983:             [np.nan, 1.0, np.nan, 3.0, np.nan], ["z", "a", "b", "c", "d"], dtype=float
  984:         )
  985: 
  986:         return_value = x.fillna(method="pad", inplace=True)
  987:         assert return_value is None
  988: 
  989:         expected = Series(
  990:             [np.nan, 1.0, 1.0, 3.0, 3.0], ["z", "a", "b", "c", "d"], dtype=float
  991:         )
  992:         tm.assert_series_equal(x[1:], expected[1:])
  993:         assert np.isnan(x.iloc[0]), np.isnan(expected.iloc[0])
  994: 
  995:     def test_series_fillna_limit(self):
  996:         index = np.arange(10)
  997:         s = Series(np.random.default_rng(2).standard_normal(10), index=index)
  998: 
  999:         result = s[:2].reindex(index)
 1000:         result = result.fillna(method="pad", limit=5)
 1001: 
 1002:         expected = s[:2].reindex(index).fillna(method="pad")
 1003:         expected[-3:] = np.nan
 1004:         tm.assert_series_equal(result, expected)
 1005: 
 1006:         result = s[-2:].reindex(index)
 1007:         result = result.fillna(method="bfill", limit=5)
 1008: 
 1009:         expected = s[-2:].reindex(index).fillna(method="backfill")
 1010:         expected[:3] = np.nan
 1011:         tm.assert_series_equal(result, expected)
 1012: 
 1013:     def test_series_pad_backfill_limit(self):
 1014:         index = np.arange(10)
 1015:         s = Series(np.random.default_rng(2).standard_normal(10), index=index)
 1016: 
 1017:         result = s[:2].reindex(index, method="pad", limit=5)
 1018: 
 1019:         expected = s[:2].reindex(index).fillna(method="pad")
 1020:         expected[-3:] = np.nan
 1021:         tm.assert_series_equal(result, expected)
 1022: 
 1023:         result = s[-2:].reindex(index, method="backfill", limit=5)
 1024: 
 1025:         expected = s[-2:].reindex(index).fillna(method="backfill")
 1026:         expected[:3] = np.nan
 1027:         tm.assert_series_equal(result, expected)
 1028: 
 1029:     def test_fillna_int(self):
 1030:         ser = Series(np.random.default_rng(2).integers(-100, 100, 50))
 1031:         return_value = ser.fillna(method="ffill", inplace=True)
 1032:         assert return_value is None
 1033:         tm.assert_series_equal(ser.fillna(method="ffill", inplace=False), ser)
 1034: 
 1035:     def test_datetime64tz_fillna_round_issue(self):
 1036:         # GH#14872
 1037: 
 1038:         data = Series(
 1039:             [NaT, NaT, datetime(2016, 12, 12, 22, 24, 6, 100001, tzinfo=pytz.utc)]
 1040:         )
 1041: 
 1042:         filled = data.bfill()
 1043: 
 1044:         expected = Series(
 1045:             [
 1046:                 datetime(2016, 12, 12, 22, 24, 6, 100001, tzinfo=pytz.utc),
 1047:                 datetime(2016, 12, 12, 22, 24, 6, 100001, tzinfo=pytz.utc),
 1048:                 datetime(2016, 12, 12, 22, 24, 6, 100001, tzinfo=pytz.utc),
 1049:             ]
 1050:         )
 1051: 
 1052:         tm.assert_series_equal(filled, expected)
 1053: 
 1054:     def test_fillna_parr(self):
 1055:         # GH-24537
 1056:         dti = date_range(
 1057:             Timestamp.max - Timedelta(nanoseconds=10), periods=5, freq="ns"
 1058:         )
 1059:         ser = Series(dti.to_period("ns"))
 1060:         ser[2] = NaT
 1061:         arr = period_array(
 1062:             [
 1063:                 Timestamp("2262-04-11 23:47:16.854775797"),
 1064:                 Timestamp("2262-04-11 23:47:16.854775798"),
 1065:                 Timestamp("2262-04-11 23:47:16.854775798"),
 1066:                 Timestamp("2262-04-11 23:47:16.854775800"),
 1067:                 Timestamp("2262-04-11 23:47:16.854775801"),
 1068:             ],
 1069:             freq="ns",
 1070:         )
 1071:         expected = Series(arr)
 1072: 
 1073:         filled = ser.ffill()
 1074: 
 1075:         tm.assert_series_equal(filled, expected)
 1076: 
 1077:     @pytest.mark.parametrize("func", ["pad", "backfill"])
 1078:     def test_pad_backfill_deprecated(self, func):
 1079:         # GH#33396
 1080:         ser = Series([1, 2, 3])
 1081:         with tm.assert_produces_warning(FutureWarning):
 1082:             getattr(ser, func)()
 1083: 
 1084: 
 1085: @pytest.mark.parametrize(
 1086:     "data, expected_data, method, kwargs",
 1087:     (
 1088:         (
 1089:             [np.nan, np.nan, 3, np.nan, np.nan, np.nan, 7, np.nan, np.nan],
 1090:             [np.nan, np.nan, 3.0, 3.0, 3.0, 3.0, 7.0, np.nan, np.nan],
 1091:             "ffill",
 1092:             {"limit_area": "inside"},
 1093:         ),
 1094:         (
 1095:             [np.nan, np.nan, 3, np.nan, np.nan, np.nan, 7, np.nan, np.nan],
 1096:             [np.nan, np.nan, 3.0, 3.0, np.nan, np.nan, 7.0, np.nan, np.nan],
 1097:             "ffill",
 1098:             {"limit_area": "inside", "limit": 1},
 1099:         ),
 1100:         (
 1101:             [np.nan, np.nan, 3, np.nan, np.nan, np.nan, 7, np.nan, np.nan],
 1102:             [np.nan, np.nan, 3.0, np.nan, np.nan, np.nan, 7.0, 7.0, 7.0],
 1103:             "ffill",
 1104:             {"limit_area": "outside"},
 1105:         ),
 1106:         (
 1107:             [np.nan, np.nan, 3, np.nan, np.nan, np.nan, 7, np.nan, np.nan],
 1108:             [np.nan, np.nan, 3.0, np.nan, np.nan, np.nan, 7.0, 7.0, np.nan],
 1109:             "ffill",
 1110:             {"limit_area": "outside", "limit": 1},
 1111:         ),
 1112:         (
 1113:             [np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan],
 1114:             [np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan],
 1115:             "ffill",
 1116:             {"limit_area": "outside", "limit": 1},
 1117:         ),
 1118:         (
 1119:             range(5),
 1120:             range(5),
 1121:             "ffill",
 1122:             {"limit_area": "outside", "limit": 1},
 1123:         ),
 1124:         (
 1125:             [np.nan, np.nan, 3, np.nan, np.nan, np.nan, 7, np.nan, np.nan],
 1126:             [np.nan, np.nan, 3.0, 7.0, 7.0, 7.0, 7.0, np.nan, np.nan],
 1127:             "bfill",
 1128:             {"limit_area": "inside"},
 1129:         ),
 1130:         (
 1131:             [np.nan, np.nan, 3, np.nan, np.nan, np.nan, 7, np.nan, np.nan],
 1132:             [np.nan, np.nan, 3.0, np.nan, np.nan, 7.0, 7.0, np.nan, np.nan],
 1133:             "bfill",
 1134:             {"limit_area": "inside", "limit": 1},
 1135:         ),
 1136:         (
 1137:             [np.nan, np.nan, 3, np.nan, np.nan, np.nan, 7, np.nan, np.nan],
 1138:             [3.0, 3.0, 3.0, np.nan, np.nan, np.nan, 7.0, np.nan, np.nan],
 1139:             "bfill",
 1140:             {"limit_area": "outside"},
 1141:         ),
 1142:         (
 1143:             [np.nan, np.nan, 3, np.nan, np.nan, np.nan, 7, np.nan, np.nan],
 1144:             [np.nan, 3.0, 3.0, np.nan, np.nan, np.nan, 7.0, np.nan, np.nan],
 1145:             "bfill",
 1146:             {"limit_area": "outside", "limit": 1},
 1147:         ),
 1148:     ),
 1149: )
 1150: def test_ffill_bfill_limit_area(data, expected_data, method, kwargs):
 1151:     # GH#56492
 1152:     s = Series(data)
 1153:     expected = Series(expected_data)
 1154:     result = getattr(s, method)(**kwargs)
 1155:     tm.assert_series_equal(result, expected)
