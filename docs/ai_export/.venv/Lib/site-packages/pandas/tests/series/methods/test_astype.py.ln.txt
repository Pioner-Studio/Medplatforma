    1: from datetime import (
    2:     datetime,
    3:     timedelta,
    4: )
    5: from importlib import reload
    6: import string
    7: import sys
    8: 
    9: import numpy as np
   10: import pytest
   11: 
   12: from pandas._libs.tslibs import iNaT
   13: import pandas.util._test_decorators as td
   14: 
   15: from pandas import (
   16:     NA,
   17:     Categorical,
   18:     CategoricalDtype,
   19:     DatetimeTZDtype,
   20:     Index,
   21:     Interval,
   22:     NaT,
   23:     Series,
   24:     Timedelta,
   25:     Timestamp,
   26:     cut,
   27:     date_range,
   28:     to_datetime,
   29: )
   30: import pandas._testing as tm
   31: 
   32: 
   33: def rand_str(nchars: int) -> str:
   34:     """
   35:     Generate one random byte string.
   36:     """
   37:     RANDS_CHARS = np.array(
   38:         list(string.ascii_letters + string.digits), dtype=(np.str_, 1)
   39:     )
   40:     return "".join(np.random.default_rng(2).choice(RANDS_CHARS, nchars))
   41: 
   42: 
   43: class TestAstypeAPI:
   44:     def test_astype_unitless_dt64_raises(self):
   45:         # GH#47844
   46:         ser = Series(["1970-01-01", "1970-01-01", "1970-01-01"], dtype="datetime64[ns]")
   47:         df = ser.to_frame()
   48: 
   49:         msg = "Casting to unit-less dtype 'datetime64' is not supported"
   50:         with pytest.raises(TypeError, match=msg):
   51:             ser.astype(np.datetime64)
   52:         with pytest.raises(TypeError, match=msg):
   53:             df.astype(np.datetime64)
   54:         with pytest.raises(TypeError, match=msg):
   55:             ser.astype("datetime64")
   56:         with pytest.raises(TypeError, match=msg):
   57:             df.astype("datetime64")
   58: 
   59:     def test_arg_for_errors_in_astype(self):
   60:         # see GH#14878
   61:         ser = Series([1, 2, 3])
   62: 
   63:         msg = (
   64:             r"Expected value of kwarg 'errors' to be one of \['raise', "
   65:             r"'ignore'\]\. Supplied value is 'False'"
   66:         )
   67:         with pytest.raises(ValueError, match=msg):
   68:             ser.astype(np.float64, errors=False)
   69: 
   70:         ser.astype(np.int8, errors="raise")
   71: 
   72:     @pytest.mark.parametrize("dtype_class", [dict, Series])
   73:     def test_astype_dict_like(self, dtype_class):
   74:         # see GH#7271
   75:         ser = Series(range(0, 10, 2), name="abc")
   76: 
   77:         dt1 = dtype_class({"abc": str})
   78:         result = ser.astype(dt1)
   79:         expected = Series(["0", "2", "4", "6", "8"], name="abc", dtype=object)
   80:         tm.assert_series_equal(result, expected)
   81: 
   82:         dt2 = dtype_class({"abc": "float64"})
   83:         result = ser.astype(dt2)
   84:         expected = Series([0.0, 2.0, 4.0, 6.0, 8.0], dtype="float64", name="abc")
   85:         tm.assert_series_equal(result, expected)
   86: 
   87:         dt3 = dtype_class({"abc": str, "def": str})
   88:         msg = (
   89:             "Only the Series name can be used for the key in Series dtype "
   90:             r"mappings\."
   91:         )
   92:         with pytest.raises(KeyError, match=msg):
   93:             ser.astype(dt3)
   94: 
   95:         dt4 = dtype_class({0: str})
   96:         with pytest.raises(KeyError, match=msg):
   97:             ser.astype(dt4)
   98: 
   99:         # GH#16717
  100:         # if dtypes provided is empty, it should error
  101:         if dtype_class is Series:
  102:             dt5 = dtype_class({}, dtype=object)
  103:         else:
  104:             dt5 = dtype_class({})
  105: 
  106:         with pytest.raises(KeyError, match=msg):
  107:             ser.astype(dt5)
  108: 
  109: 
  110: class TestAstype:
  111:     @pytest.mark.parametrize("tz", [None, "UTC", "US/Pacific"])
  112:     def test_astype_object_to_dt64_non_nano(self, tz):
  113:         # GH#55756, GH#54620
  114:         ts = Timestamp("2999-01-01")
  115:         dtype = "M8[us]"
  116:         if tz is not None:
  117:             dtype = f"M8[us, {tz}]"
  118:         vals = [ts, "2999-01-02 03:04:05.678910", 2500]
  119:         ser = Series(vals, dtype=object)
  120:         result = ser.astype(dtype)
  121: 
  122:         # The 2500 is interpreted as microseconds, consistent with what
  123:         #  we would get if we created DatetimeIndexes from vals[:2] and vals[2:]
  124:         #  and concated the results.
  125:         pointwise = [
  126:             vals[0].tz_localize(tz),
  127:             Timestamp(vals[1], tz=tz),
  128:             to_datetime(vals[2], unit="us", utc=True).tz_convert(tz),
  129:         ]
  130:         exp_vals = [x.as_unit("us").asm8 for x in pointwise]
  131:         exp_arr = np.array(exp_vals, dtype="M8[us]")
  132:         expected = Series(exp_arr, dtype="M8[us]")
  133:         if tz is not None:
  134:             expected = expected.dt.tz_localize("UTC").dt.tz_convert(tz)
  135:         tm.assert_series_equal(result, expected)
  136: 
  137:     def test_astype_mixed_object_to_dt64tz(self):
  138:         # pre-2.0 this raised ValueError bc of tz mismatch
  139:         # xref GH#32581
  140:         ts = Timestamp("2016-01-04 05:06:07", tz="US/Pacific")
  141:         ts2 = ts.tz_convert("Asia/Tokyo")
  142: 
  143:         ser = Series([ts, ts2], dtype=object)
  144:         res = ser.astype("datetime64[ns, Europe/Brussels]")
  145:         expected = Series(
  146:             [ts.tz_convert("Europe/Brussels"), ts2.tz_convert("Europe/Brussels")],
  147:             dtype="datetime64[ns, Europe/Brussels]",
  148:         )
  149:         tm.assert_series_equal(res, expected)
  150: 
  151:     @pytest.mark.parametrize("dtype", np.typecodes["All"])
  152:     def test_astype_empty_constructor_equality(self, dtype):
  153:         # see GH#15524
  154: 
  155:         if dtype not in (
  156:             "S",
  157:             "V",  # poor support (if any) currently
  158:             "M",
  159:             "m",  # Generic timestamps raise a ValueError. Already tested.
  160:         ):
  161:             init_empty = Series([], dtype=dtype)
  162:             as_type_empty = Series([]).astype(dtype)
  163:             tm.assert_series_equal(init_empty, as_type_empty)
  164: 
  165:     @pytest.mark.parametrize("dtype", [str, np.str_])
  166:     @pytest.mark.parametrize(
  167:         "series",
  168:         [
  169:             Series([string.digits * 10, rand_str(63), rand_str(64), rand_str(1000)]),
  170:             Series([string.digits * 10, rand_str(63), rand_str(64), np.nan, 1.0]),
  171:         ],
  172:     )
  173:     def test_astype_str_map(self, dtype, series, using_infer_string):
  174:         # see GH#4405
  175:         result = series.astype(dtype)
  176:         expected = series.map(str)
  177:         if using_infer_string:
  178:             expected = expected.astype(object)
  179:         tm.assert_series_equal(result, expected)
  180: 
  181:     def test_astype_float_to_period(self):
  182:         result = Series([np.nan]).astype("period[D]")
  183:         expected = Series([NaT], dtype="period[D]")
  184:         tm.assert_series_equal(result, expected)
  185: 
  186:     def test_astype_no_pandas_dtype(self):
  187:         # https://github.com/pandas-dev/pandas/pull/24866
  188:         ser = Series([1, 2], dtype="int64")
  189:         # Don't have NumpyEADtype in the public API, so we use `.array.dtype`,
  190:         # which is a NumpyEADtype.
  191:         result = ser.astype(ser.array.dtype)
  192:         tm.assert_series_equal(result, ser)
  193: 
  194:     @pytest.mark.parametrize("dtype", [np.datetime64, np.timedelta64])
  195:     def test_astype_generic_timestamp_no_frequency(self, dtype, request):
  196:         # see GH#15524, GH#15987
  197:         data = [1]
  198:         ser = Series(data)
  199: 
  200:         if np.dtype(dtype).name not in ["timedelta64", "datetime64"]:
  201:             mark = pytest.mark.xfail(reason="GH#33890 Is assigned ns unit")
  202:             request.applymarker(mark)
  203: 
  204:         msg = (
  205:             rf"The '{dtype.__name__}' dtype has no unit\. "
  206:             rf"Please pass in '{dtype.__name__}\[ns\]' instead."
  207:         )
  208:         with pytest.raises(ValueError, match=msg):
  209:             ser.astype(dtype)
  210: 
  211:     def test_astype_dt64_to_str(self):
  212:         # GH#10442 : testing astype(str) is correct for Series/DatetimeIndex
  213:         dti = date_range("2012-01-01", periods=3)
  214:         result = Series(dti).astype(str)
  215:         expected = Series(["2012-01-01", "2012-01-02", "2012-01-03"], dtype=object)
  216:         tm.assert_series_equal(result, expected)
  217: 
  218:     def test_astype_dt64tz_to_str(self):
  219:         # GH#10442 : testing astype(str) is correct for Series/DatetimeIndex
  220:         dti_tz = date_range("2012-01-01", periods=3, tz="US/Eastern")
  221:         result = Series(dti_tz).astype(str)
  222:         expected = Series(
  223:             [
  224:                 "2012-01-01 00:00:00-05:00",
  225:                 "2012-01-02 00:00:00-05:00",
  226:                 "2012-01-03 00:00:00-05:00",
  227:             ],
  228:             dtype=object,
  229:         )
  230:         tm.assert_series_equal(result, expected)
  231: 
  232:     def test_astype_datetime(self, unit):
  233:         ser = Series(iNaT, dtype=f"M8[{unit}]", index=range(5))
  234: 
  235:         ser = ser.astype("O")
  236:         assert ser.dtype == np.object_
  237: 
  238:         ser = Series([datetime(2001, 1, 2, 0, 0)])
  239: 
  240:         ser = ser.astype("O")
  241:         assert ser.dtype == np.object_
  242: 
  243:         ser = Series(
  244:             [datetime(2001, 1, 2, 0, 0) for i in range(3)], dtype=f"M8[{unit}]"
  245:         )
  246: 
  247:         ser[1] = np.nan
  248:         assert ser.dtype == f"M8[{unit}]"
  249: 
  250:         ser = ser.astype("O")
  251:         assert ser.dtype == np.object_
  252: 
  253:     def test_astype_datetime64tz(self):
  254:         ser = Series(date_range("20130101", periods=3, tz="US/Eastern"))
  255: 
  256:         # astype
  257:         result = ser.astype(object)
  258:         expected = Series(ser.astype(object), dtype=object)
  259:         tm.assert_series_equal(result, expected)
  260: 
  261:         result = Series(ser.values).dt.tz_localize("UTC").dt.tz_convert(ser.dt.tz)
  262:         tm.assert_series_equal(result, ser)
  263: 
  264:         # astype - object, preserves on construction
  265:         result = Series(ser.astype(object))
  266:         expected = ser.astype(object)
  267:         tm.assert_series_equal(result, expected)
  268: 
  269:         # astype - datetime64[ns, tz]
  270:         msg = "Cannot use .astype to convert from timezone-naive"
  271:         with pytest.raises(TypeError, match=msg):
  272:             # dt64->dt64tz astype deprecated
  273:             Series(ser.values).astype("datetime64[ns, US/Eastern]")
  274: 
  275:         with pytest.raises(TypeError, match=msg):
  276:             # dt64->dt64tz astype deprecated
  277:             Series(ser.values).astype(ser.dtype)
  278: 
  279:         result = ser.astype("datetime64[ns, CET]")
  280:         expected = Series(date_range("20130101 06:00:00", periods=3, tz="CET"))
  281:         tm.assert_series_equal(result, expected)
  282: 
  283:     def test_astype_str_cast_dt64(self):
  284:         # see GH#9757
  285:         ts = Series([Timestamp("2010-01-04 00:00:00")])
  286:         res = ts.astype(str)
  287: 
  288:         expected = Series(["2010-01-04"], dtype=object)
  289:         tm.assert_series_equal(res, expected)
  290: 
  291:         ts = Series([Timestamp("2010-01-04 00:00:00", tz="US/Eastern")])
  292:         res = ts.astype(str)
  293: 
  294:         expected = Series(["2010-01-04 00:00:00-05:00"], dtype=object)
  295:         tm.assert_series_equal(res, expected)
  296: 
  297:     def test_astype_str_cast_td64(self):
  298:         # see GH#9757
  299: 
  300:         td = Series([Timedelta(1, unit="d")])
  301:         ser = td.astype(str)
  302: 
  303:         expected = Series(["1 days"], dtype=object)
  304:         tm.assert_series_equal(ser, expected)
  305: 
  306:     def test_dt64_series_astype_object(self):
  307:         dt64ser = Series(date_range("20130101", periods=3))
  308:         result = dt64ser.astype(object)
  309:         assert isinstance(result.iloc[0], datetime)
  310:         assert result.dtype == np.object_
  311: 
  312:     def test_td64_series_astype_object(self):
  313:         tdser = Series(["59 Days", "59 Days", "NaT"], dtype="timedelta64[ns]")
  314:         result = tdser.astype(object)
  315:         assert isinstance(result.iloc[0], timedelta)
  316:         assert result.dtype == np.object_
  317: 
  318:     @pytest.mark.parametrize(
  319:         "data, dtype",
  320:         [
  321:             (["x", "y", "z"], "string[python]"),
  322:             pytest.param(
  323:                 ["x", "y", "z"],
  324:                 "string[pyarrow]",
  325:                 marks=td.skip_if_no("pyarrow"),
  326:             ),
  327:             (["x", "y", "z"], "category"),
  328:             (3 * [Timestamp("2020-01-01", tz="UTC")], None),
  329:             (3 * [Interval(0, 1)], None),
  330:         ],
  331:     )
  332:     @pytest.mark.parametrize("errors", ["raise", "ignore"])
  333:     def test_astype_ignores_errors_for_extension_dtypes(self, data, dtype, errors):
  334:         # https://github.com/pandas-dev/pandas/issues/35471
  335:         ser = Series(data, dtype=dtype)
  336:         if errors == "ignore":
  337:             expected = ser
  338:             result = ser.astype(float, errors="ignore")
  339:             tm.assert_series_equal(result, expected)
  340:         else:
  341:             msg = "(Cannot cast)|(could not convert)"
  342:             with pytest.raises((ValueError, TypeError), match=msg):
  343:                 ser.astype(float, errors=errors)
  344: 
  345:     @pytest.mark.parametrize("dtype", [np.float16, np.float32, np.float64])
  346:     def test_astype_from_float_to_str(self, dtype):
  347:         # https://github.com/pandas-dev/pandas/issues/36451
  348:         ser = Series([0.1], dtype=dtype)
  349:         result = ser.astype(str)
  350:         expected = Series(["0.1"], dtype=object)
  351:         tm.assert_series_equal(result, expected)
  352: 
  353:     @pytest.mark.parametrize(
  354:         "value, string_value",
  355:         [
  356:             (None, "None"),
  357:             (np.nan, "nan"),
  358:             (NA, "<NA>"),
  359:         ],
  360:     )
  361:     def test_astype_to_str_preserves_na(self, value, string_value):
  362:         # https://github.com/pandas-dev/pandas/issues/36904
  363:         ser = Series(["a", "b", value], dtype=object)
  364:         result = ser.astype(str)
  365:         expected = Series(["a", "b", string_value], dtype=object)
  366:         tm.assert_series_equal(result, expected)
  367: 
  368:     @pytest.mark.parametrize("dtype", ["float32", "float64", "int64", "int32"])
  369:     def test_astype(self, dtype):
  370:         ser = Series(np.random.default_rng(2).standard_normal(5), name="foo")
  371:         as_typed = ser.astype(dtype)
  372: 
  373:         assert as_typed.dtype == dtype
  374:         assert as_typed.name == ser.name
  375: 
  376:     @pytest.mark.parametrize("value", [np.nan, np.inf])
  377:     @pytest.mark.parametrize("dtype", [np.int32, np.int64])
  378:     def test_astype_cast_nan_inf_int(self, dtype, value):
  379:         # gh-14265: check NaN and inf raise error when converting to int
  380:         msg = "Cannot convert non-finite values \\(NA or inf\\) to integer"
  381:         ser = Series([value])
  382: 
  383:         with pytest.raises(ValueError, match=msg):
  384:             ser.astype(dtype)
  385: 
  386:     @pytest.mark.parametrize("dtype", [int, np.int8, np.int64])
  387:     def test_astype_cast_object_int_fail(self, dtype):
  388:         arr = Series(["car", "house", "tree", "1"])
  389:         msg = r"invalid literal for int\(\) with base 10: 'car'"
  390:         with pytest.raises(ValueError, match=msg):
  391:             arr.astype(dtype)
  392: 
  393:     def test_astype_float_to_uint_negatives_raise(
  394:         self, float_numpy_dtype, any_unsigned_int_numpy_dtype
  395:     ):
  396:         # GH#45151 We don't cast negative numbers to nonsense values
  397:         # TODO: same for EA float/uint dtypes, signed integers?
  398:         arr = np.arange(5).astype(float_numpy_dtype) - 3  # includes negatives
  399:         ser = Series(arr)
  400: 
  401:         msg = "Cannot losslessly cast from .* to .*"
  402:         with pytest.raises(ValueError, match=msg):
  403:             ser.astype(any_unsigned_int_numpy_dtype)
  404: 
  405:         with pytest.raises(ValueError, match=msg):
  406:             ser.to_frame().astype(any_unsigned_int_numpy_dtype)
  407: 
  408:         with pytest.raises(ValueError, match=msg):
  409:             # We currently catch and re-raise in Index.astype
  410:             Index(ser).astype(any_unsigned_int_numpy_dtype)
  411: 
  412:         with pytest.raises(ValueError, match=msg):
  413:             ser.array.astype(any_unsigned_int_numpy_dtype)
  414: 
  415:     def test_astype_cast_object_int(self):
  416:         arr = Series(["1", "2", "3", "4"], dtype=object)
  417:         result = arr.astype(int)
  418: 
  419:         tm.assert_series_equal(result, Series(np.arange(1, 5)))
  420: 
  421:     def test_astype_unicode(self, using_infer_string):
  422:         # see GH#7758: A bit of magic is required to set
  423:         # default encoding to utf-8
  424:         digits = string.digits
  425:         test_series = [
  426:             Series([digits * 10, rand_str(63), rand_str(64), rand_str(1000)]),
  427:             Series(["гѓ‡гѓјг‚їгѓјг‚µг‚¤г‚Ёгѓіг‚№гЂЃгЃЉе‰ЌгЃЇг‚‚гЃ†ж­»г‚“гЃ§гЃ„г‚‹"]),
  428:         ]
  429: 
  430:         former_encoding = None
  431: 
  432:         if sys.getdefaultencoding() == "utf-8":
  433:             # GH#45326 as of 2.0 Series.astype matches Index.astype by handling
  434:             #  bytes with obj.decode() instead of str(obj)
  435:             item = "й‡ЋиЏњйЈџгЃ№гЃЄгЃ„гЃЁг‚„гЃ°гЃ„"
  436:             ser = Series([item.encode()])
  437:             result = ser.astype(np.str_)
  438:             expected = Series([item], dtype=object)
  439:             tm.assert_series_equal(result, expected)
  440: 
  441:         for ser in test_series:
  442:             res = ser.astype(np.str_)
  443:             expec = ser.map(str)
  444:             if using_infer_string:
  445:                 expec = expec.astype(object)
  446:             tm.assert_series_equal(res, expec)
  447: 
  448:         # Restore the former encoding
  449:         if former_encoding is not None and former_encoding != "utf-8":
  450:             reload(sys)
  451:             sys.setdefaultencoding(former_encoding)
  452: 
  453:     def test_astype_bytes(self):
  454:         # GH#39474
  455:         result = Series(["foo", "bar", "baz"]).astype(bytes)
  456:         assert result.dtypes == np.dtype("S3")
  457: 
  458:     def test_astype_nan_to_bool(self):
  459:         # GH#43018
  460:         ser = Series(np.nan, dtype="object")
  461:         result = ser.astype("bool")
  462:         expected = Series(True, dtype="bool")
  463:         tm.assert_series_equal(result, expected)
  464: 
  465:     @pytest.mark.parametrize(
  466:         "dtype",
  467:         tm.ALL_INT_EA_DTYPES + tm.FLOAT_EA_DTYPES,
  468:     )
  469:     def test_astype_ea_to_datetimetzdtype(self, dtype):
  470:         # GH37553
  471:         ser = Series([4, 0, 9], dtype=dtype)
  472:         result = ser.astype(DatetimeTZDtype(tz="US/Pacific"))
  473: 
  474:         expected = Series(
  475:             {
  476:                 0: Timestamp("1969-12-31 16:00:00.000000004-08:00", tz="US/Pacific"),
  477:                 1: Timestamp("1969-12-31 16:00:00.000000000-08:00", tz="US/Pacific"),
  478:                 2: Timestamp("1969-12-31 16:00:00.000000009-08:00", tz="US/Pacific"),
  479:             }
  480:         )
  481: 
  482:         tm.assert_series_equal(result, expected)
  483: 
  484:     def test_astype_retain_attrs(self, any_numpy_dtype):
  485:         # GH#44414
  486:         ser = Series([0, 1, 2, 3])
  487:         ser.attrs["Location"] = "Michigan"
  488: 
  489:         result = ser.astype(any_numpy_dtype).attrs
  490:         expected = ser.attrs
  491: 
  492:         tm.assert_dict_equal(expected, result)
  493: 
  494: 
  495: class TestAstypeString:
  496:     @pytest.mark.parametrize(
  497:         "data, dtype",
  498:         [
  499:             ([True, NA], "boolean"),
  500:             (["A", NA], "category"),
  501:             (["2020-10-10", "2020-10-10"], "datetime64[ns]"),
  502:             (["2020-10-10", "2020-10-10", NaT], "datetime64[ns]"),
  503:             (
  504:                 ["2012-01-01 00:00:00-05:00", NaT],
  505:                 "datetime64[ns, US/Eastern]",
  506:             ),
  507:             ([1, None], "UInt16"),
  508:             (["1/1/2021", "2/1/2021"], "period[M]"),
  509:             (["1/1/2021", "2/1/2021", NaT], "period[M]"),
  510:             (["1 Day", "59 Days", NaT], "timedelta64[ns]"),
  511:             # currently no way to parse IntervalArray from a list of strings
  512:         ],
  513:     )
  514:     def test_astype_string_to_extension_dtype_roundtrip(
  515:         self, data, dtype, request, nullable_string_dtype
  516:     ):
  517:         if dtype == "boolean":
  518:             mark = pytest.mark.xfail(
  519:                 reason="TODO StringArray.astype() with missing values #GH40566"
  520:             )
  521:             request.applymarker(mark)
  522:         # GH-40351
  523:         ser = Series(data, dtype=dtype)
  524: 
  525:         # Note: just passing .astype(dtype) fails for dtype="category"
  526:         #  with bc ser.dtype.categories will be object dtype whereas
  527:         #  result.dtype.categories will have string dtype
  528:         result = ser.astype(nullable_string_dtype).astype(ser.dtype)
  529:         tm.assert_series_equal(result, ser)
  530: 
  531: 
  532: class TestAstypeCategorical:
  533:     def test_astype_categorical_to_other(self):
  534:         cat = Categorical([f"{i} - {i + 499}" for i in range(0, 10000, 500)])
  535:         ser = Series(np.random.default_rng(2).integers(0, 10000, 100)).sort_values()
  536:         ser = cut(ser, range(0, 10500, 500), right=False, labels=cat)
  537: 
  538:         expected = ser
  539:         tm.assert_series_equal(ser.astype("category"), expected)
  540:         tm.assert_series_equal(ser.astype(CategoricalDtype()), expected)
  541:         msg = r"Cannot cast object|string dtype to float64"
  542:         with pytest.raises(ValueError, match=msg):
  543:             ser.astype("float64")
  544: 
  545:         cat = Series(Categorical(["a", "b", "b", "a", "a", "c", "c", "c"]))
  546:         exp = Series(["a", "b", "b", "a", "a", "c", "c", "c"], dtype=object)
  547:         tm.assert_series_equal(cat.astype("str"), exp)
  548:         s2 = Series(Categorical(["1", "2", "3", "4"]))
  549:         exp2 = Series([1, 2, 3, 4]).astype("int")
  550:         tm.assert_series_equal(s2.astype("int"), exp2)
  551: 
  552:         # object don't sort correctly, so just compare that we have the same
  553:         # values
  554:         def cmp(a, b):
  555:             tm.assert_almost_equal(np.sort(np.unique(a)), np.sort(np.unique(b)))
  556: 
  557:         expected = Series(np.array(ser.values), name="value_group")
  558:         cmp(ser.astype("object"), expected)
  559:         cmp(ser.astype(np.object_), expected)
  560: 
  561:         # array conversion
  562:         tm.assert_almost_equal(np.array(ser), np.array(ser.values))
  563: 
  564:         tm.assert_series_equal(ser.astype("category"), ser)
  565:         tm.assert_series_equal(ser.astype(CategoricalDtype()), ser)
  566: 
  567:         roundtrip_expected = ser.cat.set_categories(
  568:             ser.cat.categories.sort_values()
  569:         ).cat.remove_unused_categories()
  570:         result = ser.astype("object").astype("category")
  571:         tm.assert_series_equal(result, roundtrip_expected)
  572:         result = ser.astype("object").astype(CategoricalDtype())
  573:         tm.assert_series_equal(result, roundtrip_expected)
  574: 
  575:     def test_astype_categorical_invalid_conversions(self):
  576:         # invalid conversion (these are NOT a dtype)
  577:         cat = Categorical([f"{i} - {i + 499}" for i in range(0, 10000, 500)])
  578:         ser = Series(np.random.default_rng(2).integers(0, 10000, 100)).sort_values()
  579:         ser = cut(ser, range(0, 10500, 500), right=False, labels=cat)
  580: 
  581:         msg = (
  582:             "dtype '<class 'pandas.core.arrays.categorical.Categorical'>' "
  583:             "not understood"
  584:         )
  585:         with pytest.raises(TypeError, match=msg):
  586:             ser.astype(Categorical)
  587:         with pytest.raises(TypeError, match=msg):
  588:             ser.astype("object").astype(Categorical)
  589: 
  590:     def test_astype_categoricaldtype(self):
  591:         ser = Series(["a", "b", "a"])
  592:         result = ser.astype(CategoricalDtype(["a", "b"], ordered=True))
  593:         expected = Series(Categorical(["a", "b", "a"], ordered=True))
  594:         tm.assert_series_equal(result, expected)
  595: 
  596:         result = ser.astype(CategoricalDtype(["a", "b"], ordered=False))
  597:         expected = Series(Categorical(["a", "b", "a"], ordered=False))
  598:         tm.assert_series_equal(result, expected)
  599: 
  600:         result = ser.astype(CategoricalDtype(["a", "b", "c"], ordered=False))
  601:         expected = Series(
  602:             Categorical(["a", "b", "a"], categories=["a", "b", "c"], ordered=False)
  603:         )
  604:         tm.assert_series_equal(result, expected)
  605:         tm.assert_index_equal(result.cat.categories, Index(["a", "b", "c"]))
  606: 
  607:     @pytest.mark.parametrize("name", [None, "foo"])
  608:     @pytest.mark.parametrize("dtype_ordered", [True, False])
  609:     @pytest.mark.parametrize("series_ordered", [True, False])
  610:     def test_astype_categorical_to_categorical(
  611:         self, name, dtype_ordered, series_ordered
  612:     ):
  613:         # GH#10696, GH#18593
  614:         s_data = list("abcaacbab")
  615:         s_dtype = CategoricalDtype(list("bac"), ordered=series_ordered)
  616:         ser = Series(s_data, dtype=s_dtype, name=name)
  617: 
  618:         # unspecified categories
  619:         dtype = CategoricalDtype(ordered=dtype_ordered)
  620:         result = ser.astype(dtype)
  621:         exp_dtype = CategoricalDtype(s_dtype.categories, dtype_ordered)
  622:         expected = Series(s_data, name=name, dtype=exp_dtype)
  623:         tm.assert_series_equal(result, expected)
  624: 
  625:         # different categories
  626:         dtype = CategoricalDtype(list("adc"), dtype_ordered)
  627:         result = ser.astype(dtype)
  628:         expected = Series(s_data, name=name, dtype=dtype)
  629:         tm.assert_series_equal(result, expected)
  630: 
  631:         if dtype_ordered is False:
  632:             # not specifying ordered, so only test once
  633:             expected = ser
  634:             result = ser.astype("category")
  635:             tm.assert_series_equal(result, expected)
  636: 
  637:     def test_astype_bool_missing_to_categorical(self):
  638:         # GH-19182
  639:         ser = Series([True, False, np.nan])
  640:         assert ser.dtypes == np.object_
  641: 
  642:         result = ser.astype(CategoricalDtype(categories=[True, False]))
  643:         expected = Series(Categorical([True, False, np.nan], categories=[True, False]))
  644:         tm.assert_series_equal(result, expected)
  645: 
  646:     def test_astype_categories_raises(self):
  647:         # deprecated GH#17636, removed in GH#27141
  648:         ser = Series(["a", "b", "a"])
  649:         with pytest.raises(TypeError, match="got an unexpected"):
  650:             ser.astype("category", categories=["a", "b"], ordered=True)
  651: 
  652:     @pytest.mark.parametrize("items", [["a", "b", "c", "a"], [1, 2, 3, 1]])
  653:     def test_astype_from_categorical(self, items):
  654:         ser = Series(items)
  655:         exp = Series(Categorical(items))
  656:         res = ser.astype("category")
  657:         tm.assert_series_equal(res, exp)
  658: 
  659:     def test_astype_from_categorical_with_keywords(self):
  660:         # with keywords
  661:         lst = ["a", "b", "c", "a"]
  662:         ser = Series(lst)
  663:         exp = Series(Categorical(lst, ordered=True))
  664:         res = ser.astype(CategoricalDtype(None, ordered=True))
  665:         tm.assert_series_equal(res, exp)
  666: 
  667:         exp = Series(Categorical(lst, categories=list("abcdef"), ordered=True))
  668:         res = ser.astype(CategoricalDtype(list("abcdef"), ordered=True))
  669:         tm.assert_series_equal(res, exp)
  670: 
  671:     def test_astype_timedelta64_with_np_nan(self):
  672:         # GH45798
  673:         result = Series([Timedelta(1), np.nan], dtype="timedelta64[ns]")
  674:         expected = Series([Timedelta(1), NaT], dtype="timedelta64[ns]")
  675:         tm.assert_series_equal(result, expected)
  676: 
  677:     @td.skip_if_no("pyarrow")
  678:     def test_astype_int_na_string(self):
  679:         # GH#57418
  680:         ser = Series([12, NA], dtype="Int64[pyarrow]")
  681:         result = ser.astype("string[pyarrow]")
  682:         expected = Series(["12", NA], dtype="string[pyarrow]")
  683:         tm.assert_series_equal(result, expected)
