    1: from datetime import datetime
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: import pandas as pd
    7: from pandas import (
    8:     DataFrame,
    9:     Index,
   10:     MultiIndex,
   11:     RangeIndex,
   12:     Series,
   13:     date_range,
   14:     option_context,
   15: )
   16: import pandas._testing as tm
   17: 
   18: 
   19: class TestResetIndex:
   20:     def test_reset_index_dti_round_trip(self):
   21:         dti = date_range(start="1/1/2001", end="6/1/2001", freq="D")._with_freq(None)
   22:         d1 = DataFrame({"v": np.random.default_rng(2).random(len(dti))}, index=dti)
   23:         d2 = d1.reset_index()
   24:         assert d2.dtypes.iloc[0] == np.dtype("M8[ns]")
   25:         d3 = d2.set_index("index")
   26:         tm.assert_frame_equal(d1, d3, check_names=False)
   27: 
   28:         # GH#2329
   29:         stamp = datetime(2012, 11, 22)
   30:         df = DataFrame([[stamp, 12.1]], columns=["Date", "Value"])
   31:         df = df.set_index("Date")
   32: 
   33:         assert df.index[0] == stamp
   34:         assert df.reset_index()["Date"].iloc[0] == stamp
   35: 
   36:     def test_reset_index(self):
   37:         df = DataFrame(
   38:             1.1 * np.arange(120).reshape((30, 4)),
   39:             columns=Index(list("ABCD"), dtype=object),
   40:             index=Index([f"i-{i}" for i in range(30)], dtype=object),
   41:         )[:5]
   42:         ser = df.stack(future_stack=True)
   43:         ser.index.names = ["hash", "category"]
   44: 
   45:         ser.name = "value"
   46:         df = ser.reset_index()
   47:         assert "value" in df
   48: 
   49:         df = ser.reset_index(name="value2")
   50:         assert "value2" in df
   51: 
   52:         # check inplace
   53:         s = ser.reset_index(drop=True)
   54:         s2 = ser
   55:         return_value = s2.reset_index(drop=True, inplace=True)
   56:         assert return_value is None
   57:         tm.assert_series_equal(s, s2)
   58: 
   59:         # level
   60:         index = MultiIndex(
   61:             levels=[["bar"], ["one", "two", "three"], [0, 1]],
   62:             codes=[[0, 0, 0, 0, 0, 0], [0, 1, 2, 0, 1, 2], [0, 1, 0, 1, 0, 1]],
   63:         )
   64:         s = Series(np.random.default_rng(2).standard_normal(6), index=index)
   65:         rs = s.reset_index(level=1)
   66:         assert len(rs.columns) == 2
   67: 
   68:         rs = s.reset_index(level=[0, 2], drop=True)
   69:         tm.assert_index_equal(rs.index, Index(index.get_level_values(1)))
   70:         assert isinstance(rs, Series)
   71: 
   72:     def test_reset_index_name(self):
   73:         s = Series([1, 2, 3], index=Index(range(3), name="x"))
   74:         assert s.reset_index().index.name is None
   75:         assert s.reset_index(drop=True).index.name is None
   76: 
   77:     def test_reset_index_level(self):
   78:         df = DataFrame([[1, 2, 3], [4, 5, 6]], columns=["A", "B", "C"])
   79: 
   80:         for levels in ["A", "B"], [0, 1]:
   81:             # With MultiIndex
   82:             s = df.set_index(["A", "B"])["C"]
   83: 
   84:             result = s.reset_index(level=levels[0])
   85:             tm.assert_frame_equal(result, df.set_index("B"))
   86: 
   87:             result = s.reset_index(level=levels[:1])
   88:             tm.assert_frame_equal(result, df.set_index("B"))
   89: 
   90:             result = s.reset_index(level=levels)
   91:             tm.assert_frame_equal(result, df)
   92: 
   93:             result = df.set_index(["A", "B"]).reset_index(level=levels, drop=True)
   94:             tm.assert_frame_equal(result, df[["C"]])
   95: 
   96:             with pytest.raises(KeyError, match="Level E "):
   97:                 s.reset_index(level=["A", "E"])
   98: 
   99:             # With single-level Index
  100:             s = df.set_index("A")["B"]
  101: 
  102:             result = s.reset_index(level=levels[0])
  103:             tm.assert_frame_equal(result, df[["A", "B"]])
  104: 
  105:             result = s.reset_index(level=levels[:1])
  106:             tm.assert_frame_equal(result, df[["A", "B"]])
  107: 
  108:             result = s.reset_index(level=levels[0], drop=True)
  109:             tm.assert_series_equal(result, df["B"])
  110: 
  111:             with pytest.raises(IndexError, match="Too many levels"):
  112:                 s.reset_index(level=[0, 1, 2])
  113: 
  114:         # Check that .reset_index([],drop=True) doesn't fail
  115:         result = Series(range(4)).reset_index([], drop=True)
  116:         expected = Series(range(4))
  117:         tm.assert_series_equal(result, expected)
  118: 
  119:     def test_reset_index_range(self):
  120:         # GH 12071
  121:         s = Series(range(2), name="A", dtype="int64")
  122:         series_result = s.reset_index()
  123:         assert isinstance(series_result.index, RangeIndex)
  124:         series_expected = DataFrame(
  125:             [[0, 0], [1, 1]], columns=["index", "A"], index=RangeIndex(stop=2)
  126:         )
  127:         tm.assert_frame_equal(series_result, series_expected)
  128: 
  129:     def test_reset_index_drop_errors(self):
  130:         #  GH 20925
  131: 
  132:         # KeyError raised for series index when passed level name is missing
  133:         s = Series(range(4))
  134:         with pytest.raises(KeyError, match="does not match index name"):
  135:             s.reset_index("wrong", drop=True)
  136:         with pytest.raises(KeyError, match="does not match index name"):
  137:             s.reset_index("wrong")
  138: 
  139:         # KeyError raised for series when level to be dropped is missing
  140:         s = Series(range(4), index=MultiIndex.from_product([[1, 2]] * 2))
  141:         with pytest.raises(KeyError, match="not found"):
  142:             s.reset_index("wrong", drop=True)
  143: 
  144:     def test_reset_index_with_drop(self):
  145:         arrays = [
  146:             ["bar", "bar", "baz", "baz", "qux", "qux", "foo", "foo"],
  147:             ["one", "two", "one", "two", "one", "two", "one", "two"],
  148:         ]
  149:         tuples = zip(*arrays)
  150:         index = MultiIndex.from_tuples(tuples)
  151:         data = np.random.default_rng(2).standard_normal(8)
  152:         ser = Series(data, index=index)
  153:         ser.iloc[3] = np.nan
  154: 
  155:         deleveled = ser.reset_index()
  156:         assert isinstance(deleveled, DataFrame)
  157:         assert len(deleveled.columns) == len(ser.index.levels) + 1
  158:         assert deleveled.index.name == ser.index.name
  159: 
  160:         deleveled = ser.reset_index(drop=True)
  161:         assert isinstance(deleveled, Series)
  162:         assert deleveled.index.name == ser.index.name
  163: 
  164:     def test_reset_index_inplace_and_drop_ignore_name(self):
  165:         # GH#44575
  166:         ser = Series(range(2), name="old")
  167:         ser.reset_index(name="new", drop=True, inplace=True)
  168:         expected = Series(range(2), name="old")
  169:         tm.assert_series_equal(ser, expected)
  170: 
  171:     def test_reset_index_drop_infer_string(self):
  172:         # GH#56160
  173:         pytest.importorskip("pyarrow")
  174:         ser = Series(["a", "b", "c"], dtype=object)
  175:         with option_context("future.infer_string", True):
  176:             result = ser.reset_index(drop=True)
  177:         tm.assert_series_equal(result, ser)
  178: 
  179: 
  180: @pytest.mark.parametrize(
  181:     "array, dtype",
  182:     [
  183:         (["a", "b"], object),
  184:         (
  185:             pd.period_range("12-1-2000", periods=2, freq="Q-DEC"),
  186:             pd.PeriodDtype(freq="Q-DEC"),
  187:         ),
  188:     ],
  189: )
  190: def test_reset_index_dtypes_on_empty_series_with_multiindex(
  191:     array, dtype, using_infer_string
  192: ):
  193:     # GH 19602 - Preserve dtype on empty Series with MultiIndex
  194:     idx = MultiIndex.from_product([[0, 1], [0.5, 1.0], array])
  195:     result = Series(dtype=object, index=idx)[:0].reset_index().dtypes
  196:     exp = "string" if using_infer_string else object
  197:     expected = Series(
  198:         {
  199:             "level_0": np.int64,
  200:             "level_1": np.float64,
  201:             "level_2": exp if dtype == object else dtype,
  202:             0: object,
  203:         }
  204:     )
  205:     tm.assert_series_equal(result, expected)
  206: 
  207: 
  208: @pytest.mark.parametrize(
  209:     "names, expected_names",
  210:     [
  211:         (["A", "A"], ["A", "A"]),
  212:         (["level_1", None], ["level_1", "level_1"]),
  213:     ],
  214: )
  215: @pytest.mark.parametrize("allow_duplicates", [False, True])
  216: def test_column_name_duplicates(names, expected_names, allow_duplicates):
  217:     # GH#44755 reset_index with duplicate column labels
  218:     s = Series([1], index=MultiIndex.from_arrays([[1], [1]], names=names))
  219:     if allow_duplicates:
  220:         result = s.reset_index(allow_duplicates=True)
  221:         expected = DataFrame([[1, 1, 1]], columns=expected_names + [0])
  222:         tm.assert_frame_equal(result, expected)
  223:     else:
  224:         with pytest.raises(ValueError, match="cannot insert"):
  225:             s.reset_index()
