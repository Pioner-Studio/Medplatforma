    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas._config import using_pyarrow_string_dtype
    5: 
    6: import pandas.util._test_decorators as td
    7: 
    8: from pandas import (
    9:     NA,
   10:     Categorical,
   11:     Float64Dtype,
   12:     Index,
   13:     MultiIndex,
   14:     NaT,
   15:     Period,
   16:     PeriodIndex,
   17:     RangeIndex,
   18:     Series,
   19:     Timedelta,
   20:     Timestamp,
   21:     date_range,
   22:     isna,
   23: )
   24: import pandas._testing as tm
   25: 
   26: 
   27: @pytest.mark.xfail(
   28:     using_pyarrow_string_dtype(), reason="share memory doesn't work for arrow"
   29: )
   30: def test_reindex(datetime_series, string_series):
   31:     identity = string_series.reindex(string_series.index)
   32: 
   33:     assert np.may_share_memory(string_series.index, identity.index)
   34: 
   35:     assert identity.index.is_(string_series.index)
   36:     assert identity.index.identical(string_series.index)
   37: 
   38:     subIndex = string_series.index[10:20]
   39:     subSeries = string_series.reindex(subIndex)
   40: 
   41:     for idx, val in subSeries.items():
   42:         assert val == string_series[idx]
   43: 
   44:     subIndex2 = datetime_series.index[10:20]
   45:     subTS = datetime_series.reindex(subIndex2)
   46: 
   47:     for idx, val in subTS.items():
   48:         assert val == datetime_series[idx]
   49:     stuffSeries = datetime_series.reindex(subIndex)
   50: 
   51:     assert np.isnan(stuffSeries).all()
   52: 
   53:     # This is extremely important for the Cython code to not screw up
   54:     nonContigIndex = datetime_series.index[::2]
   55:     subNonContig = datetime_series.reindex(nonContigIndex)
   56:     for idx, val in subNonContig.items():
   57:         assert val == datetime_series[idx]
   58: 
   59:     # return a copy the same index here
   60:     result = datetime_series.reindex()
   61:     assert result is not datetime_series
   62: 
   63: 
   64: def test_reindex_nan():
   65:     ts = Series([2, 3, 5, 7], index=[1, 4, np.nan, 8])
   66: 
   67:     i, j = [np.nan, 1, np.nan, 8, 4, np.nan], [2, 0, 2, 3, 1, 2]
   68:     tm.assert_series_equal(ts.reindex(i), ts.iloc[j])
   69: 
   70:     ts.index = ts.index.astype("object")
   71: 
   72:     # reindex coerces index.dtype to float, loc/iloc doesn't
   73:     tm.assert_series_equal(ts.reindex(i), ts.iloc[j], check_index_type=False)
   74: 
   75: 
   76: def test_reindex_series_add_nat():
   77:     rng = date_range("1/1/2000 00:00:00", periods=10, freq="10s")
   78:     series = Series(rng)
   79: 
   80:     result = series.reindex(range(15))
   81:     assert np.issubdtype(result.dtype, np.dtype("M8[ns]"))
   82: 
   83:     mask = result.isna()
   84:     assert mask[-5:].all()
   85:     assert not mask[:-5].any()
   86: 
   87: 
   88: def test_reindex_with_datetimes():
   89:     rng = date_range("1/1/2000", periods=20)
   90:     ts = Series(np.random.default_rng(2).standard_normal(20), index=rng)
   91: 
   92:     result = ts.reindex(list(ts.index[5:10]))
   93:     expected = ts[5:10]
   94:     expected.index = expected.index._with_freq(None)
   95:     tm.assert_series_equal(result, expected)
   96: 
   97:     result = ts[list(ts.index[5:10])]
   98:     tm.assert_series_equal(result, expected)
   99: 
  100: 
  101: def test_reindex_corner(datetime_series):
  102:     # (don't forget to fix this) I think it's fixed
  103:     empty = Series(index=[])
  104:     empty.reindex(datetime_series.index, method="pad")  # it works
  105: 
  106:     # corner case: pad empty series
  107:     reindexed = empty.reindex(datetime_series.index, method="pad")
  108: 
  109:     # pass non-Index
  110:     reindexed = datetime_series.reindex(list(datetime_series.index))
  111:     datetime_series.index = datetime_series.index._with_freq(None)
  112:     tm.assert_series_equal(datetime_series, reindexed)
  113: 
  114:     # bad fill method
  115:     ts = datetime_series[::2]
  116:     msg = (
  117:         r"Invalid fill method\. Expecting pad \(ffill\), backfill "
  118:         r"\(bfill\) or nearest\. Got foo"
  119:     )
  120:     with pytest.raises(ValueError, match=msg):
  121:         ts.reindex(datetime_series.index, method="foo")
  122: 
  123: 
  124: def test_reindex_pad():
  125:     s = Series(np.arange(10), dtype="int64")
  126:     s2 = s[::2]
  127: 
  128:     reindexed = s2.reindex(s.index, method="pad")
  129:     reindexed2 = s2.reindex(s.index, method="ffill")
  130:     tm.assert_series_equal(reindexed, reindexed2)
  131: 
  132:     expected = Series([0, 0, 2, 2, 4, 4, 6, 6, 8, 8])
  133:     tm.assert_series_equal(reindexed, expected)
  134: 
  135: 
  136: def test_reindex_pad2():
  137:     # GH4604
  138:     s = Series([1, 2, 3, 4, 5], index=["a", "b", "c", "d", "e"])
  139:     new_index = ["a", "g", "c", "f"]
  140:     expected = Series([1, 1, 3, 3], index=new_index)
  141: 
  142:     # this changes dtype because the ffill happens after
  143:     result = s.reindex(new_index).ffill()
  144:     tm.assert_series_equal(result, expected.astype("float64"))
  145: 
  146:     msg = "The 'downcast' keyword in ffill is deprecated"
  147:     with tm.assert_produces_warning(FutureWarning, match=msg):
  148:         result = s.reindex(new_index).ffill(downcast="infer")
  149:     tm.assert_series_equal(result, expected)
  150: 
  151:     expected = Series([1, 5, 3, 5], index=new_index)
  152:     result = s.reindex(new_index, method="ffill")
  153:     tm.assert_series_equal(result, expected)
  154: 
  155: 
  156: def test_reindex_inference():
  157:     # inference of new dtype
  158:     s = Series([True, False, False, True], index=list("abcd"))
  159:     new_index = "agc"
  160:     msg = "Downcasting object dtype arrays on"
  161:     with tm.assert_produces_warning(FutureWarning, match=msg):
  162:         result = s.reindex(list(new_index)).ffill()
  163:     expected = Series([True, True, False], index=list(new_index))
  164:     tm.assert_series_equal(result, expected)
  165: 
  166: 
  167: def test_reindex_downcasting():
  168:     # GH4618 shifted series downcasting
  169:     s = Series(False, index=range(5))
  170:     msg = "Downcasting object dtype arrays on"
  171:     with tm.assert_produces_warning(FutureWarning, match=msg):
  172:         result = s.shift(1).bfill()
  173:     expected = Series(False, index=range(5))
  174:     tm.assert_series_equal(result, expected)
  175: 
  176: 
  177: def test_reindex_nearest():
  178:     s = Series(np.arange(10, dtype="int64"))
  179:     target = [0.1, 0.9, 1.5, 2.0]
  180:     result = s.reindex(target, method="nearest")
  181:     expected = Series(np.around(target).astype("int64"), target)
  182:     tm.assert_series_equal(expected, result)
  183: 
  184:     result = s.reindex(target, method="nearest", tolerance=0.2)
  185:     expected = Series([0, 1, np.nan, 2], target)
  186:     tm.assert_series_equal(expected, result)
  187: 
  188:     result = s.reindex(target, method="nearest", tolerance=[0.3, 0.01, 0.4, 3])
  189:     expected = Series([0, np.nan, np.nan, 2], target)
  190:     tm.assert_series_equal(expected, result)
  191: 
  192: 
  193: def test_reindex_int(datetime_series):
  194:     ts = datetime_series[::2]
  195:     int_ts = Series(np.zeros(len(ts), dtype=int), index=ts.index)
  196: 
  197:     # this should work fine
  198:     reindexed_int = int_ts.reindex(datetime_series.index)
  199: 
  200:     # if NaNs introduced
  201:     assert reindexed_int.dtype == np.float64
  202: 
  203:     # NO NaNs introduced
  204:     reindexed_int = int_ts.reindex(int_ts.index[::2])
  205:     assert reindexed_int.dtype == np.dtype(int)
  206: 
  207: 
  208: def test_reindex_bool(datetime_series):
  209:     # A series other than float, int, string, or object
  210:     ts = datetime_series[::2]
  211:     bool_ts = Series(np.zeros(len(ts), dtype=bool), index=ts.index)
  212: 
  213:     # this should work fine
  214:     reindexed_bool = bool_ts.reindex(datetime_series.index)
  215: 
  216:     # if NaNs introduced
  217:     assert reindexed_bool.dtype == np.object_
  218: 
  219:     # NO NaNs introduced
  220:     reindexed_bool = bool_ts.reindex(bool_ts.index[::2])
  221:     assert reindexed_bool.dtype == np.bool_
  222: 
  223: 
  224: def test_reindex_bool_pad(datetime_series):
  225:     # fail
  226:     ts = datetime_series[5:]
  227:     bool_ts = Series(np.zeros(len(ts), dtype=bool), index=ts.index)
  228:     filled_bool = bool_ts.reindex(datetime_series.index, method="pad")
  229:     assert isna(filled_bool[:5]).all()
  230: 
  231: 
  232: def test_reindex_categorical():
  233:     index = date_range("20000101", periods=3)
  234: 
  235:     # reindexing to an invalid Categorical
  236:     s = Series(["a", "b", "c"], dtype="category")
  237:     result = s.reindex(index)
  238:     expected = Series(
  239:         Categorical(values=[np.nan, np.nan, np.nan], categories=["a", "b", "c"])
  240:     )
  241:     expected.index = index
  242:     tm.assert_series_equal(result, expected)
  243: 
  244:     # partial reindexing
  245:     expected = Series(Categorical(values=["b", "c"], categories=["a", "b", "c"]))
  246:     expected.index = [1, 2]
  247:     result = s.reindex([1, 2])
  248:     tm.assert_series_equal(result, expected)
  249: 
  250:     expected = Series(Categorical(values=["c", np.nan], categories=["a", "b", "c"]))
  251:     expected.index = [2, 3]
  252:     result = s.reindex([2, 3])
  253:     tm.assert_series_equal(result, expected)
  254: 
  255: 
  256: def test_reindex_astype_order_consistency():
  257:     # GH#17444
  258:     ser = Series([1, 2, 3], index=[2, 0, 1])
  259:     new_index = [0, 1, 2]
  260:     temp_dtype = "category"
  261:     new_dtype = str
  262:     result = ser.reindex(new_index).astype(temp_dtype).astype(new_dtype)
  263:     expected = ser.astype(temp_dtype).reindex(new_index).astype(new_dtype)
  264:     tm.assert_series_equal(result, expected)
  265: 
  266: 
  267: def test_reindex_fill_value():
  268:     # -----------------------------------------------------------
  269:     # floats
  270:     floats = Series([1.0, 2.0, 3.0])
  271:     result = floats.reindex([1, 2, 3])
  272:     expected = Series([2.0, 3.0, np.nan], index=[1, 2, 3])
  273:     tm.assert_series_equal(result, expected)
  274: 
  275:     result = floats.reindex([1, 2, 3], fill_value=0)
  276:     expected = Series([2.0, 3.0, 0], index=[1, 2, 3])
  277:     tm.assert_series_equal(result, expected)
  278: 
  279:     # -----------------------------------------------------------
  280:     # ints
  281:     ints = Series([1, 2, 3])
  282: 
  283:     result = ints.reindex([1, 2, 3])
  284:     expected = Series([2.0, 3.0, np.nan], index=[1, 2, 3])
  285:     tm.assert_series_equal(result, expected)
  286: 
  287:     # don't upcast
  288:     result = ints.reindex([1, 2, 3], fill_value=0)
  289:     expected = Series([2, 3, 0], index=[1, 2, 3])
  290:     assert issubclass(result.dtype.type, np.integer)
  291:     tm.assert_series_equal(result, expected)
  292: 
  293:     # -----------------------------------------------------------
  294:     # objects
  295:     objects = Series([1, 2, 3], dtype=object)
  296: 
  297:     result = objects.reindex([1, 2, 3])
  298:     expected = Series([2, 3, np.nan], index=[1, 2, 3], dtype=object)
  299:     tm.assert_series_equal(result, expected)
  300: 
  301:     result = objects.reindex([1, 2, 3], fill_value="foo")
  302:     expected = Series([2, 3, "foo"], index=[1, 2, 3], dtype=object)
  303:     tm.assert_series_equal(result, expected)
  304: 
  305:     # ------------------------------------------------------------
  306:     # bools
  307:     bools = Series([True, False, True])
  308: 
  309:     result = bools.reindex([1, 2, 3])
  310:     expected = Series([False, True, np.nan], index=[1, 2, 3], dtype=object)
  311:     tm.assert_series_equal(result, expected)
  312: 
  313:     result = bools.reindex([1, 2, 3], fill_value=False)
  314:     expected = Series([False, True, False], index=[1, 2, 3])
  315:     tm.assert_series_equal(result, expected)
  316: 
  317: 
  318: @td.skip_array_manager_not_yet_implemented
  319: @pytest.mark.parametrize("dtype", ["datetime64[ns]", "timedelta64[ns]"])
  320: @pytest.mark.parametrize("fill_value", ["string", 0, Timedelta(0)])
  321: def test_reindex_fill_value_datetimelike_upcast(dtype, fill_value, using_array_manager):
  322:     # https://github.com/pandas-dev/pandas/issues/42921
  323:     if dtype == "timedelta64[ns]" and fill_value == Timedelta(0):
  324:         # use the scalar that is not compatible with the dtype for this test
  325:         fill_value = Timestamp(0)
  326: 
  327:     ser = Series([NaT], dtype=dtype)
  328: 
  329:     result = ser.reindex([0, 1], fill_value=fill_value)
  330:     expected = Series([NaT, fill_value], index=[0, 1], dtype=object)
  331:     tm.assert_series_equal(result, expected)
  332: 
  333: 
  334: def test_reindex_datetimeindexes_tz_naive_and_aware():
  335:     # GH 8306
  336:     idx = date_range("20131101", tz="America/Chicago", periods=7)
  337:     newidx = date_range("20131103", periods=10, freq="h")
  338:     s = Series(range(7), index=idx)
  339:     msg = (
  340:         r"Cannot compare dtypes datetime64\[ns, America/Chicago\] "
  341:         r"and datetime64\[ns\]"
  342:     )
  343:     with pytest.raises(TypeError, match=msg):
  344:         s.reindex(newidx, method="ffill")
  345: 
  346: 
  347: def test_reindex_empty_series_tz_dtype():
  348:     # GH 20869
  349:     result = Series(dtype="datetime64[ns, UTC]").reindex([0, 1])
  350:     expected = Series([NaT] * 2, dtype="datetime64[ns, UTC]")
  351:     tm.assert_equal(result, expected)
  352: 
  353: 
  354: @pytest.mark.parametrize(
  355:     "p_values, o_values, values, expected_values",
  356:     [
  357:         (
  358:             [Period("2019Q1", "Q-DEC"), Period("2019Q2", "Q-DEC")],
  359:             [Period("2019Q1", "Q-DEC"), Period("2019Q2", "Q-DEC"), "All"],
  360:             [1.0, 1.0],
  361:             [1.0, 1.0, np.nan],
  362:         ),
  363:         (
  364:             [Period("2019Q1", "Q-DEC"), Period("2019Q2", "Q-DEC")],
  365:             [Period("2019Q1", "Q-DEC"), Period("2019Q2", "Q-DEC")],
  366:             [1.0, 1.0],
  367:             [1.0, 1.0],
  368:         ),
  369:     ],
  370: )
  371: def test_reindex_periodindex_with_object(p_values, o_values, values, expected_values):
  372:     # GH#28337
  373:     period_index = PeriodIndex(p_values)
  374:     object_index = Index(o_values)
  375: 
  376:     ser = Series(values, index=period_index)
  377:     result = ser.reindex(object_index)
  378:     expected = Series(expected_values, index=object_index)
  379:     tm.assert_series_equal(result, expected)
  380: 
  381: 
  382: def test_reindex_too_many_args():
  383:     # GH 40980
  384:     ser = Series([1, 2])
  385:     msg = r"reindex\(\) takes from 1 to 2 positional arguments but 3 were given"
  386:     with pytest.raises(TypeError, match=msg):
  387:         ser.reindex([2, 3], False)
  388: 
  389: 
  390: def test_reindex_double_index():
  391:     # GH 40980
  392:     ser = Series([1, 2])
  393:     msg = r"reindex\(\) got multiple values for argument 'index'"
  394:     with pytest.raises(TypeError, match=msg):
  395:         ser.reindex([2, 3], index=[3, 4])
  396: 
  397: 
  398: def test_reindex_no_posargs():
  399:     # GH 40980
  400:     ser = Series([1, 2])
  401:     result = ser.reindex(index=[1, 0])
  402:     expected = Series([2, 1], index=[1, 0])
  403:     tm.assert_series_equal(result, expected)
  404: 
  405: 
  406: @pytest.mark.parametrize("values", [[["a"], ["x"]], [[], []]])
  407: def test_reindex_empty_with_level(values):
  408:     # GH41170
  409:     ser = Series(
  410:         range(len(values[0])), index=MultiIndex.from_arrays(values), dtype="object"
  411:     )
  412:     result = ser.reindex(np.array(["b"]), level=0)
  413:     expected = Series(
  414:         index=MultiIndex(levels=[["b"], values[1]], codes=[[], []]), dtype="object"
  415:     )
  416:     tm.assert_series_equal(result, expected)
  417: 
  418: 
  419: def test_reindex_missing_category():
  420:     # GH#18185
  421:     ser = Series([1, 2, 3, 1], dtype="category")
  422:     msg = r"Cannot setitem on a Categorical with a new category \(-1\)"
  423:     with pytest.raises(TypeError, match=msg):
  424:         ser.reindex([1, 2, 3, 4, 5], fill_value=-1)
  425: 
  426: 
  427: def test_reindexing_with_float64_NA_log():
  428:     # GH 47055
  429:     s = Series([1.0, NA], dtype=Float64Dtype())
  430:     s_reindex = s.reindex(range(3))
  431:     result = s_reindex.values._data
  432:     expected = np.array([1, np.nan, np.nan])
  433:     tm.assert_numpy_array_equal(result, expected)
  434:     with tm.assert_produces_warning(None):
  435:         result_log = np.log(s_reindex)
  436:         expected_log = Series([0, np.nan, np.nan], dtype=Float64Dtype())
  437:         tm.assert_series_equal(result_log, expected_log)
  438: 
  439: 
  440: @pytest.mark.parametrize("dtype", ["timedelta64", "datetime64"])
  441: def test_reindex_expand_nonnano_nat(dtype):
  442:     # GH 53497
  443:     ser = Series(np.array([1], dtype=f"{dtype}[s]"))
  444:     result = ser.reindex(RangeIndex(2))
  445:     expected = Series(
  446:         np.array([1, getattr(np, dtype)("nat", "s")], dtype=f"{dtype}[s]")
  447:     )
  448:     tm.assert_series_equal(result, expected)
