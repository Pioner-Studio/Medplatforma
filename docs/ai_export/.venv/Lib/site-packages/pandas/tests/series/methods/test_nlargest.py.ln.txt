    1: """
    2: Note: for naming purposes, most tests are title with as e.g. "test_nlargest_foo"
    3: but are implicitly also testing nsmallest_foo.
    4: """
    5: from itertools import product
    6: 
    7: import numpy as np
    8: import pytest
    9: 
   10: import pandas as pd
   11: from pandas import Series
   12: import pandas._testing as tm
   13: 
   14: main_dtypes = [
   15:     "datetime",
   16:     "datetimetz",
   17:     "timedelta",
   18:     "int8",
   19:     "int16",
   20:     "int32",
   21:     "int64",
   22:     "float32",
   23:     "float64",
   24:     "uint8",
   25:     "uint16",
   26:     "uint32",
   27:     "uint64",
   28: ]
   29: 
   30: 
   31: @pytest.fixture
   32: def s_main_dtypes():
   33:     """
   34:     A DataFrame with many dtypes
   35: 
   36:     * datetime
   37:     * datetimetz
   38:     * timedelta
   39:     * [u]int{8,16,32,64}
   40:     * float{32,64}
   41: 
   42:     The columns are the name of the dtype.
   43:     """
   44:     df = pd.DataFrame(
   45:         {
   46:             "datetime": pd.to_datetime(["2003", "2002", "2001", "2002", "2005"]),
   47:             "datetimetz": pd.to_datetime(
   48:                 ["2003", "2002", "2001", "2002", "2005"]
   49:             ).tz_localize("US/Eastern"),
   50:             "timedelta": pd.to_timedelta(["3d", "2d", "1d", "2d", "5d"]),
   51:         }
   52:     )
   53: 
   54:     for dtype in [
   55:         "int8",
   56:         "int16",
   57:         "int32",
   58:         "int64",
   59:         "float32",
   60:         "float64",
   61:         "uint8",
   62:         "uint16",
   63:         "uint32",
   64:         "uint64",
   65:     ]:
   66:         df[dtype] = Series([3, 2, 1, 2, 5], dtype=dtype)
   67: 
   68:     return df
   69: 
   70: 
   71: @pytest.fixture(params=main_dtypes)
   72: def s_main_dtypes_split(request, s_main_dtypes):
   73:     """Each series in s_main_dtypes."""
   74:     return s_main_dtypes[request.param]
   75: 
   76: 
   77: def assert_check_nselect_boundary(vals, dtype, method):
   78:     # helper function for 'test_boundary_{dtype}' tests
   79:     ser = Series(vals, dtype=dtype)
   80:     result = getattr(ser, method)(3)
   81:     expected_idxr = [0, 1, 2] if method == "nsmallest" else [3, 2, 1]
   82:     expected = ser.loc[expected_idxr]
   83:     tm.assert_series_equal(result, expected)
   84: 
   85: 
   86: class TestSeriesNLargestNSmallest:
   87:     @pytest.mark.parametrize(
   88:         "r",
   89:         [
   90:             Series([3.0, 2, 1, 2, "5"], dtype="object"),
   91:             Series([3.0, 2, 1, 2, 5], dtype="object"),
   92:             # not supported on some archs
   93:             # Series([3., 2, 1, 2, 5], dtype='complex256'),
   94:             Series([3.0, 2, 1, 2, 5], dtype="complex128"),
   95:             Series(list("abcde")),
   96:             Series(list("abcde"), dtype="category"),
   97:         ],
   98:     )
   99:     def test_nlargest_error(self, r):
  100:         dt = r.dtype
  101:         msg = f"Cannot use method 'n(largest|smallest)' with dtype {dt}"
  102:         args = 2, len(r), 0, -1
  103:         methods = r.nlargest, r.nsmallest
  104:         for method, arg in product(methods, args):
  105:             with pytest.raises(TypeError, match=msg):
  106:                 method(arg)
  107: 
  108:     def test_nsmallest_nlargest(self, s_main_dtypes_split):
  109:         # float, int, datetime64 (use i8), timedelts64 (same),
  110:         # object that are numbers, object that are strings
  111:         ser = s_main_dtypes_split
  112: 
  113:         tm.assert_series_equal(ser.nsmallest(2), ser.iloc[[2, 1]])
  114:         tm.assert_series_equal(ser.nsmallest(2, keep="last"), ser.iloc[[2, 3]])
  115: 
  116:         empty = ser.iloc[0:0]
  117:         tm.assert_series_equal(ser.nsmallest(0), empty)
  118:         tm.assert_series_equal(ser.nsmallest(-1), empty)
  119:         tm.assert_series_equal(ser.nlargest(0), empty)
  120:         tm.assert_series_equal(ser.nlargest(-1), empty)
  121: 
  122:         tm.assert_series_equal(ser.nsmallest(len(ser)), ser.sort_values())
  123:         tm.assert_series_equal(ser.nsmallest(len(ser) + 1), ser.sort_values())
  124:         tm.assert_series_equal(ser.nlargest(len(ser)), ser.iloc[[4, 0, 1, 3, 2]])
  125:         tm.assert_series_equal(ser.nlargest(len(ser) + 1), ser.iloc[[4, 0, 1, 3, 2]])
  126: 
  127:     def test_nlargest_misc(self):
  128:         ser = Series([3.0, np.nan, 1, 2, 5])
  129:         result = ser.nlargest()
  130:         expected = ser.iloc[[4, 0, 3, 2, 1]]
  131:         tm.assert_series_equal(result, expected)
  132:         result = ser.nsmallest()
  133:         expected = ser.iloc[[2, 3, 0, 4, 1]]
  134:         tm.assert_series_equal(result, expected)
  135: 
  136:         msg = 'keep must be either "first", "last"'
  137:         with pytest.raises(ValueError, match=msg):
  138:             ser.nsmallest(keep="invalid")
  139:         with pytest.raises(ValueError, match=msg):
  140:             ser.nlargest(keep="invalid")
  141: 
  142:         # GH#15297
  143:         ser = Series([1] * 5, index=[1, 2, 3, 4, 5])
  144:         expected_first = Series([1] * 3, index=[1, 2, 3])
  145:         expected_last = Series([1] * 3, index=[5, 4, 3])
  146: 
  147:         result = ser.nsmallest(3)
  148:         tm.assert_series_equal(result, expected_first)
  149: 
  150:         result = ser.nsmallest(3, keep="last")
  151:         tm.assert_series_equal(result, expected_last)
  152: 
  153:         result = ser.nlargest(3)
  154:         tm.assert_series_equal(result, expected_first)
  155: 
  156:         result = ser.nlargest(3, keep="last")
  157:         tm.assert_series_equal(result, expected_last)
  158: 
  159:     @pytest.mark.parametrize("n", range(1, 5))
  160:     def test_nlargest_n(self, n):
  161:         # GH 13412
  162:         ser = Series([1, 4, 3, 2], index=[0, 0, 1, 1])
  163:         result = ser.nlargest(n)
  164:         expected = ser.sort_values(ascending=False).head(n)
  165:         tm.assert_series_equal(result, expected)
  166: 
  167:         result = ser.nsmallest(n)
  168:         expected = ser.sort_values().head(n)
  169:         tm.assert_series_equal(result, expected)
  170: 
  171:     def test_nlargest_boundary_integer(self, nselect_method, any_int_numpy_dtype):
  172:         # GH#21426
  173:         dtype_info = np.iinfo(any_int_numpy_dtype)
  174:         min_val, max_val = dtype_info.min, dtype_info.max
  175:         vals = [min_val, min_val + 1, max_val - 1, max_val]
  176:         assert_check_nselect_boundary(vals, any_int_numpy_dtype, nselect_method)
  177: 
  178:     def test_nlargest_boundary_float(self, nselect_method, float_numpy_dtype):
  179:         # GH#21426
  180:         dtype_info = np.finfo(float_numpy_dtype)
  181:         min_val, max_val = dtype_info.min, dtype_info.max
  182:         min_2nd, max_2nd = np.nextafter([min_val, max_val], 0, dtype=float_numpy_dtype)
  183:         vals = [min_val, min_2nd, max_2nd, max_val]
  184:         assert_check_nselect_boundary(vals, float_numpy_dtype, nselect_method)
  185: 
  186:     @pytest.mark.parametrize("dtype", ["datetime64[ns]", "timedelta64[ns]"])
  187:     def test_nlargest_boundary_datetimelike(self, nselect_method, dtype):
  188:         # GH#21426
  189:         # use int64 bounds and +1 to min_val since true minimum is NaT
  190:         # (include min_val/NaT at end to maintain same expected_idxr)
  191:         dtype_info = np.iinfo("int64")
  192:         min_val, max_val = dtype_info.min, dtype_info.max
  193:         vals = [min_val + 1, min_val + 2, max_val - 1, max_val, min_val]
  194:         assert_check_nselect_boundary(vals, dtype, nselect_method)
  195: 
  196:     def test_nlargest_duplicate_keep_all_ties(self):
  197:         # see GH#16818
  198:         ser = Series([10, 9, 8, 7, 7, 7, 7, 6])
  199:         result = ser.nlargest(4, keep="all")
  200:         expected = Series([10, 9, 8, 7, 7, 7, 7])
  201:         tm.assert_series_equal(result, expected)
  202: 
  203:         result = ser.nsmallest(2, keep="all")
  204:         expected = Series([6, 7, 7, 7, 7], index=[7, 3, 4, 5, 6])
  205:         tm.assert_series_equal(result, expected)
  206: 
  207:     @pytest.mark.parametrize(
  208:         "data,expected", [([True, False], [True]), ([True, False, True, True], [True])]
  209:     )
  210:     def test_nlargest_boolean(self, data, expected):
  211:         # GH#26154 : ensure True > False
  212:         ser = Series(data)
  213:         result = ser.nlargest(1)
  214:         expected = Series(expected)
  215:         tm.assert_series_equal(result, expected)
  216: 
  217:     def test_nlargest_nullable(self, any_numeric_ea_dtype):
  218:         # GH#42816
  219:         dtype = any_numeric_ea_dtype
  220:         if dtype.startswith("UInt"):
  221:             # Can't cast from negative float to uint on some platforms
  222:             arr = np.random.default_rng(2).integers(1, 10, 10)
  223:         else:
  224:             arr = np.random.default_rng(2).standard_normal(10)
  225:         arr = arr.astype(dtype.lower(), copy=False)
  226: 
  227:         ser = Series(arr.copy(), dtype=dtype)
  228:         ser[1] = pd.NA
  229:         result = ser.nlargest(5)
  230: 
  231:         expected = (
  232:             Series(np.delete(arr, 1), index=ser.index.delete(1))
  233:             .nlargest(5)
  234:             .astype(dtype)
  235:         )
  236:         tm.assert_series_equal(result, expected)
  237: 
  238:     def test_nsmallest_nan_when_keep_is_all(self):
  239:         # GH#46589
  240:         s = Series([1, 2, 3, 3, 3, None])
  241:         result = s.nsmallest(3, keep="all")
  242:         expected = Series([1.0, 2.0, 3.0, 3.0, 3.0])
  243:         tm.assert_series_equal(result, expected)
  244: 
  245:         s = Series([1, 2, None, None, None])
  246:         result = s.nsmallest(3, keep="all")
  247:         expected = Series([1, 2, None, None, None])
  248:         tm.assert_series_equal(result, expected)
