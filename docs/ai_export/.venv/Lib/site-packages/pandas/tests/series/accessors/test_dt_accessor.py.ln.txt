    1: import calendar
    2: from datetime import (
    3:     date,
    4:     datetime,
    5:     time,
    6: )
    7: import locale
    8: import unicodedata
    9: 
   10: import numpy as np
   11: import pytest
   12: import pytz
   13: 
   14: from pandas._libs.tslibs.timezones import maybe_get_tz
   15: from pandas.errors import SettingWithCopyError
   16: 
   17: from pandas.core.dtypes.common import (
   18:     is_integer_dtype,
   19:     is_list_like,
   20: )
   21: 
   22: import pandas as pd
   23: from pandas import (
   24:     DataFrame,
   25:     DatetimeIndex,
   26:     Index,
   27:     Period,
   28:     PeriodIndex,
   29:     Series,
   30:     TimedeltaIndex,
   31:     date_range,
   32:     period_range,
   33:     timedelta_range,
   34: )
   35: import pandas._testing as tm
   36: from pandas.core.arrays import (
   37:     DatetimeArray,
   38:     PeriodArray,
   39:     TimedeltaArray,
   40: )
   41: 
   42: ok_for_period = PeriodArray._datetimelike_ops
   43: ok_for_period_methods = ["strftime", "to_timestamp", "asfreq"]
   44: ok_for_dt = DatetimeArray._datetimelike_ops
   45: ok_for_dt_methods = [
   46:     "to_period",
   47:     "to_pydatetime",
   48:     "tz_localize",
   49:     "tz_convert",
   50:     "normalize",
   51:     "strftime",
   52:     "round",
   53:     "floor",
   54:     "ceil",
   55:     "day_name",
   56:     "month_name",
   57:     "isocalendar",
   58:     "as_unit",
   59: ]
   60: ok_for_td = TimedeltaArray._datetimelike_ops
   61: ok_for_td_methods = [
   62:     "components",
   63:     "to_pytimedelta",
   64:     "total_seconds",
   65:     "round",
   66:     "floor",
   67:     "ceil",
   68:     "as_unit",
   69: ]
   70: 
   71: 
   72: def get_dir(ser):
   73:     # check limited display api
   74:     results = [r for r in ser.dt.__dir__() if not r.startswith("_")]
   75:     return sorted(set(results))
   76: 
   77: 
   78: class TestSeriesDatetimeValues:
   79:     def _compare(self, ser, name):
   80:         # GH 7207, 11128
   81:         # test .dt namespace accessor
   82: 
   83:         def get_expected(ser, prop):
   84:             result = getattr(Index(ser._values), prop)
   85:             if isinstance(result, np.ndarray):
   86:                 if is_integer_dtype(result):
   87:                     result = result.astype("int64")
   88:             elif not is_list_like(result) or isinstance(result, DataFrame):
   89:                 return result
   90:             return Series(result, index=ser.index, name=ser.name)
   91: 
   92:         left = getattr(ser.dt, name)
   93:         right = get_expected(ser, name)
   94:         if not (is_list_like(left) and is_list_like(right)):
   95:             assert left == right
   96:         elif isinstance(left, DataFrame):
   97:             tm.assert_frame_equal(left, right)
   98:         else:
   99:             tm.assert_series_equal(left, right)
  100: 
  101:     @pytest.mark.parametrize("freq", ["D", "s", "ms"])
  102:     def test_dt_namespace_accessor_datetime64(self, freq):
  103:         # GH#7207, GH#11128
  104:         # test .dt namespace accessor
  105: 
  106:         # datetimeindex
  107:         dti = date_range("20130101", periods=5, freq=freq)
  108:         ser = Series(dti, name="xxx")
  109: 
  110:         for prop in ok_for_dt:
  111:             # we test freq below
  112:             if prop != "freq":
  113:                 self._compare(ser, prop)
  114: 
  115:         for prop in ok_for_dt_methods:
  116:             getattr(ser.dt, prop)
  117: 
  118:         msg = "The behavior of DatetimeProperties.to_pydatetime is deprecated"
  119:         with tm.assert_produces_warning(FutureWarning, match=msg):
  120:             result = ser.dt.to_pydatetime()
  121:         assert isinstance(result, np.ndarray)
  122:         assert result.dtype == object
  123: 
  124:         result = ser.dt.tz_localize("US/Eastern")
  125:         exp_values = DatetimeIndex(ser.values).tz_localize("US/Eastern")
  126:         expected = Series(exp_values, index=ser.index, name="xxx")
  127:         tm.assert_series_equal(result, expected)
  128: 
  129:         tz_result = result.dt.tz
  130:         assert str(tz_result) == "US/Eastern"
  131:         freq_result = ser.dt.freq
  132:         assert freq_result == DatetimeIndex(ser.values, freq="infer").freq
  133: 
  134:         # let's localize, then convert
  135:         result = ser.dt.tz_localize("UTC").dt.tz_convert("US/Eastern")
  136:         exp_values = (
  137:             DatetimeIndex(ser.values).tz_localize("UTC").tz_convert("US/Eastern")
  138:         )
  139:         expected = Series(exp_values, index=ser.index, name="xxx")
  140:         tm.assert_series_equal(result, expected)
  141: 
  142:     def test_dt_namespace_accessor_datetime64tz(self):
  143:         # GH#7207, GH#11128
  144:         # test .dt namespace accessor
  145: 
  146:         # datetimeindex with tz
  147:         dti = date_range("20130101", periods=5, tz="US/Eastern")
  148:         ser = Series(dti, name="xxx")
  149:         for prop in ok_for_dt:
  150:             # we test freq below
  151:             if prop != "freq":
  152:                 self._compare(ser, prop)
  153: 
  154:         for prop in ok_for_dt_methods:
  155:             getattr(ser.dt, prop)
  156: 
  157:         msg = "The behavior of DatetimeProperties.to_pydatetime is deprecated"
  158:         with tm.assert_produces_warning(FutureWarning, match=msg):
  159:             result = ser.dt.to_pydatetime()
  160:         assert isinstance(result, np.ndarray)
  161:         assert result.dtype == object
  162: 
  163:         result = ser.dt.tz_convert("CET")
  164:         expected = Series(ser._values.tz_convert("CET"), index=ser.index, name="xxx")
  165:         tm.assert_series_equal(result, expected)
  166: 
  167:         tz_result = result.dt.tz
  168:         assert str(tz_result) == "CET"
  169:         freq_result = ser.dt.freq
  170:         assert freq_result == DatetimeIndex(ser.values, freq="infer").freq
  171: 
  172:     def test_dt_namespace_accessor_timedelta(self):
  173:         # GH#7207, GH#11128
  174:         # test .dt namespace accessor
  175: 
  176:         # timedelta index
  177:         cases = [
  178:             Series(
  179:                 timedelta_range("1 day", periods=5), index=list("abcde"), name="xxx"
  180:             ),
  181:             Series(timedelta_range("1 day 01:23:45", periods=5, freq="s"), name="xxx"),
  182:             Series(
  183:                 timedelta_range("2 days 01:23:45.012345", periods=5, freq="ms"),
  184:                 name="xxx",
  185:             ),
  186:         ]
  187:         for ser in cases:
  188:             for prop in ok_for_td:
  189:                 # we test freq below
  190:                 if prop != "freq":
  191:                     self._compare(ser, prop)
  192: 
  193:             for prop in ok_for_td_methods:
  194:                 getattr(ser.dt, prop)
  195: 
  196:             result = ser.dt.components
  197:             assert isinstance(result, DataFrame)
  198:             tm.assert_index_equal(result.index, ser.index)
  199: 
  200:             result = ser.dt.to_pytimedelta()
  201:             assert isinstance(result, np.ndarray)
  202:             assert result.dtype == object
  203: 
  204:             result = ser.dt.total_seconds()
  205:             assert isinstance(result, Series)
  206:             assert result.dtype == "float64"
  207: 
  208:             freq_result = ser.dt.freq
  209:             assert freq_result == TimedeltaIndex(ser.values, freq="infer").freq
  210: 
  211:     def test_dt_namespace_accessor_period(self):
  212:         # GH#7207, GH#11128
  213:         # test .dt namespace accessor
  214: 
  215:         # periodindex
  216:         pi = period_range("20130101", periods=5, freq="D")
  217:         ser = Series(pi, name="xxx")
  218: 
  219:         for prop in ok_for_period:
  220:             # we test freq below
  221:             if prop != "freq":
  222:                 self._compare(ser, prop)
  223: 
  224:         for prop in ok_for_period_methods:
  225:             getattr(ser.dt, prop)
  226: 
  227:         freq_result = ser.dt.freq
  228:         assert freq_result == PeriodIndex(ser.values).freq
  229: 
  230:     def test_dt_namespace_accessor_index_and_values(self):
  231:         # both
  232:         index = date_range("20130101", periods=3, freq="D")
  233:         dti = date_range("20140204", periods=3, freq="s")
  234:         ser = Series(dti, index=index, name="xxx")
  235:         exp = Series(
  236:             np.array([2014, 2014, 2014], dtype="int32"), index=index, name="xxx"
  237:         )
  238:         tm.assert_series_equal(ser.dt.year, exp)
  239: 
  240:         exp = Series(np.array([2, 2, 2], dtype="int32"), index=index, name="xxx")
  241:         tm.assert_series_equal(ser.dt.month, exp)
  242: 
  243:         exp = Series(np.array([0, 1, 2], dtype="int32"), index=index, name="xxx")
  244:         tm.assert_series_equal(ser.dt.second, exp)
  245: 
  246:         exp = Series([ser.iloc[0]] * 3, index=index, name="xxx")
  247:         tm.assert_series_equal(ser.dt.normalize(), exp)
  248: 
  249:     def test_dt_accessor_limited_display_api(self):
  250:         # tznaive
  251:         ser = Series(date_range("20130101", periods=5, freq="D"), name="xxx")
  252:         results = get_dir(ser)
  253:         tm.assert_almost_equal(results, sorted(set(ok_for_dt + ok_for_dt_methods)))
  254: 
  255:         # tzaware
  256:         ser = Series(date_range("2015-01-01", "2016-01-01", freq="min"), name="xxx")
  257:         ser = ser.dt.tz_localize("UTC").dt.tz_convert("America/Chicago")
  258:         results = get_dir(ser)
  259:         tm.assert_almost_equal(results, sorted(set(ok_for_dt + ok_for_dt_methods)))
  260: 
  261:         # Period
  262:         idx = period_range("20130101", periods=5, freq="D", name="xxx").astype(object)
  263:         with tm.assert_produces_warning(FutureWarning, match="Dtype inference"):
  264:             ser = Series(idx)
  265:         results = get_dir(ser)
  266:         tm.assert_almost_equal(
  267:             results, sorted(set(ok_for_period + ok_for_period_methods))
  268:         )
  269: 
  270:     def test_dt_accessor_ambiguous_freq_conversions(self):
  271:         # GH#11295
  272:         # ambiguous time error on the conversions
  273:         ser = Series(date_range("2015-01-01", "2016-01-01", freq="min"), name="xxx")
  274:         ser = ser.dt.tz_localize("UTC").dt.tz_convert("America/Chicago")
  275: 
  276:         exp_values = date_range(
  277:             "2015-01-01", "2016-01-01", freq="min", tz="UTC"
  278:         ).tz_convert("America/Chicago")
  279:         # freq not preserved by tz_localize above
  280:         exp_values = exp_values._with_freq(None)
  281:         expected = Series(exp_values, name="xxx")
  282:         tm.assert_series_equal(ser, expected)
  283: 
  284:     def test_dt_accessor_not_writeable(self, using_copy_on_write, warn_copy_on_write):
  285:         # no setting allowed
  286:         ser = Series(date_range("20130101", periods=5, freq="D"), name="xxx")
  287:         with pytest.raises(ValueError, match="modifications"):
  288:             ser.dt.hour = 5
  289: 
  290:         # trying to set a copy
  291:         msg = "modifications to a property of a datetimelike.+not supported"
  292:         with pd.option_context("chained_assignment", "raise"):
  293:             if using_copy_on_write:
  294:                 with tm.raises_chained_assignment_error():
  295:                     ser.dt.hour[0] = 5
  296:             elif warn_copy_on_write:
  297:                 with tm.assert_produces_warning(
  298:                     FutureWarning, match="ChainedAssignmentError"
  299:                 ):
  300:                     ser.dt.hour[0] = 5
  301:             else:
  302:                 with pytest.raises(SettingWithCopyError, match=msg):
  303:                     ser.dt.hour[0] = 5
  304: 
  305:     @pytest.mark.parametrize(
  306:         "method, dates",
  307:         [
  308:             ["round", ["2012-01-02", "2012-01-02", "2012-01-01"]],
  309:             ["floor", ["2012-01-01", "2012-01-01", "2012-01-01"]],
  310:             ["ceil", ["2012-01-02", "2012-01-02", "2012-01-02"]],
  311:         ],
  312:     )
  313:     def test_dt_round(self, method, dates):
  314:         # round
  315:         ser = Series(
  316:             pd.to_datetime(
  317:                 ["2012-01-01 13:00:00", "2012-01-01 12:01:00", "2012-01-01 08:00:00"]
  318:             ),
  319:             name="xxx",
  320:         )
  321:         result = getattr(ser.dt, method)("D")
  322:         expected = Series(pd.to_datetime(dates), name="xxx")
  323:         tm.assert_series_equal(result, expected)
  324: 
  325:     def test_dt_round_tz(self):
  326:         ser = Series(
  327:             pd.to_datetime(
  328:                 ["2012-01-01 13:00:00", "2012-01-01 12:01:00", "2012-01-01 08:00:00"]
  329:             ),
  330:             name="xxx",
  331:         )
  332:         result = ser.dt.tz_localize("UTC").dt.tz_convert("US/Eastern").dt.round("D")
  333: 
  334:         exp_values = pd.to_datetime(
  335:             ["2012-01-01", "2012-01-01", "2012-01-01"]
  336:         ).tz_localize("US/Eastern")
  337:         expected = Series(exp_values, name="xxx")
  338:         tm.assert_series_equal(result, expected)
  339: 
  340:     @pytest.mark.parametrize("method", ["ceil", "round", "floor"])
  341:     def test_dt_round_tz_ambiguous(self, method):
  342:         # GH 18946 round near "fall back" DST
  343:         df1 = DataFrame(
  344:             [
  345:                 pd.to_datetime("2017-10-29 02:00:00+02:00", utc=True),
  346:                 pd.to_datetime("2017-10-29 02:00:00+01:00", utc=True),
  347:                 pd.to_datetime("2017-10-29 03:00:00+01:00", utc=True),
  348:             ],
  349:             columns=["date"],
  350:         )
  351:         df1["date"] = df1["date"].dt.tz_convert("Europe/Madrid")
  352:         # infer
  353:         result = getattr(df1.date.dt, method)("h", ambiguous="infer")
  354:         expected = df1["date"]
  355:         tm.assert_series_equal(result, expected)
  356: 
  357:         # bool-array
  358:         result = getattr(df1.date.dt, method)("h", ambiguous=[True, False, False])
  359:         tm.assert_series_equal(result, expected)
  360: 
  361:         # NaT
  362:         result = getattr(df1.date.dt, method)("h", ambiguous="NaT")
  363:         expected = df1["date"].copy()
  364:         expected.iloc[0:2] = pd.NaT
  365:         tm.assert_series_equal(result, expected)
  366: 
  367:         # raise
  368:         with tm.external_error_raised(pytz.AmbiguousTimeError):
  369:             getattr(df1.date.dt, method)("h", ambiguous="raise")
  370: 
  371:     @pytest.mark.parametrize(
  372:         "method, ts_str, freq",
  373:         [
  374:             ["ceil", "2018-03-11 01:59:00-0600", "5min"],
  375:             ["round", "2018-03-11 01:59:00-0600", "5min"],
  376:             ["floor", "2018-03-11 03:01:00-0500", "2h"],
  377:         ],
  378:     )
  379:     def test_dt_round_tz_nonexistent(self, method, ts_str, freq):
  380:         # GH 23324 round near "spring forward" DST
  381:         ser = Series([pd.Timestamp(ts_str, tz="America/Chicago")])
  382:         result = getattr(ser.dt, method)(freq, nonexistent="shift_forward")
  383:         expected = Series([pd.Timestamp("2018-03-11 03:00:00", tz="America/Chicago")])
  384:         tm.assert_series_equal(result, expected)
  385: 
  386:         result = getattr(ser.dt, method)(freq, nonexistent="NaT")
  387:         expected = Series([pd.NaT]).dt.tz_localize(result.dt.tz)
  388:         tm.assert_series_equal(result, expected)
  389: 
  390:         with pytest.raises(pytz.NonExistentTimeError, match="2018-03-11 02:00:00"):
  391:             getattr(ser.dt, method)(freq, nonexistent="raise")
  392: 
  393:     @pytest.mark.parametrize("freq", ["ns", "us", "1000us"])
  394:     def test_dt_round_nonnano_higher_resolution_no_op(self, freq):
  395:         # GH 52761
  396:         ser = Series(
  397:             ["2020-05-31 08:00:00", "2000-12-31 04:00:05", "1800-03-14 07:30:20"],
  398:             dtype="datetime64[ms]",
  399:         )
  400:         expected = ser.copy()
  401:         result = ser.dt.round(freq)
  402:         tm.assert_series_equal(result, expected)
  403: 
  404:         assert not np.shares_memory(ser.array._ndarray, result.array._ndarray)
  405: 
  406:     def test_dt_namespace_accessor_categorical(self):
  407:         # GH 19468
  408:         dti = DatetimeIndex(["20171111", "20181212"]).repeat(2)
  409:         ser = Series(pd.Categorical(dti), name="foo")
  410:         result = ser.dt.year
  411:         expected = Series([2017, 2017, 2018, 2018], dtype="int32", name="foo")
  412:         tm.assert_series_equal(result, expected)
  413: 
  414:     def test_dt_tz_localize_categorical(self, tz_aware_fixture):
  415:         # GH 27952
  416:         tz = tz_aware_fixture
  417:         datetimes = Series(
  418:             ["2019-01-01", "2019-01-01", "2019-01-02"], dtype="datetime64[ns]"
  419:         )
  420:         categorical = datetimes.astype("category")
  421:         result = categorical.dt.tz_localize(tz)
  422:         expected = datetimes.dt.tz_localize(tz)
  423:         tm.assert_series_equal(result, expected)
  424: 
  425:     def test_dt_tz_convert_categorical(self, tz_aware_fixture):
  426:         # GH 27952
  427:         tz = tz_aware_fixture
  428:         datetimes = Series(
  429:             ["2019-01-01", "2019-01-01", "2019-01-02"], dtype="datetime64[ns, MET]"
  430:         )
  431:         categorical = datetimes.astype("category")
  432:         result = categorical.dt.tz_convert(tz)
  433:         expected = datetimes.dt.tz_convert(tz)
  434:         tm.assert_series_equal(result, expected)
  435: 
  436:     @pytest.mark.parametrize("accessor", ["year", "month", "day"])
  437:     def test_dt_other_accessors_categorical(self, accessor):
  438:         # GH 27952
  439:         datetimes = Series(
  440:             ["2018-01-01", "2018-01-01", "2019-01-02"], dtype="datetime64[ns]"
  441:         )
  442:         categorical = datetimes.astype("category")
  443:         result = getattr(categorical.dt, accessor)
  444:         expected = getattr(datetimes.dt, accessor)
  445:         tm.assert_series_equal(result, expected)
  446: 
  447:     def test_dt_accessor_no_new_attributes(self):
  448:         # https://github.com/pandas-dev/pandas/issues/10673
  449:         ser = Series(date_range("20130101", periods=5, freq="D"))
  450:         with pytest.raises(AttributeError, match="You cannot add any new attribute"):
  451:             ser.dt.xlabel = "a"
  452: 
  453:     # error: Unsupported operand types for + ("List[None]" and "List[str]")
  454:     @pytest.mark.parametrize(
  455:         "time_locale", [None] + tm.get_locales()  # type: ignore[operator]
  456:     )
  457:     def test_dt_accessor_datetime_name_accessors(self, time_locale):
  458:         # Test Monday -> Sunday and January -> December, in that sequence
  459:         if time_locale is None:
  460:             # If the time_locale is None, day-name and month_name should
  461:             # return the english attributes
  462:             expected_days = [
  463:                 "Monday",
  464:                 "Tuesday",
  465:                 "Wednesday",
  466:                 "Thursday",
  467:                 "Friday",
  468:                 "Saturday",
  469:                 "Sunday",
  470:             ]
  471:             expected_months = [
  472:                 "January",
  473:                 "February",
  474:                 "March",
  475:                 "April",
  476:                 "May",
  477:                 "June",
  478:                 "July",
  479:                 "August",
  480:                 "September",
  481:                 "October",
  482:                 "November",
  483:                 "December",
  484:             ]
  485:         else:
  486:             with tm.set_locale(time_locale, locale.LC_TIME):
  487:                 expected_days = calendar.day_name[:]
  488:                 expected_months = calendar.month_name[1:]
  489: 
  490:         ser = Series(date_range(freq="D", start=datetime(1998, 1, 1), periods=365))
  491:         english_days = [
  492:             "Monday",
  493:             "Tuesday",
  494:             "Wednesday",
  495:             "Thursday",
  496:             "Friday",
  497:             "Saturday",
  498:             "Sunday",
  499:         ]
  500:         for day, name, eng_name in zip(range(4, 11), expected_days, english_days):
  501:             name = name.capitalize()
  502:             assert ser.dt.day_name(locale=time_locale)[day] == name
  503:             assert ser.dt.day_name(locale=None)[day] == eng_name
  504:         ser = pd.concat([ser, Series([pd.NaT])])
  505:         assert np.isnan(ser.dt.day_name(locale=time_locale).iloc[-1])
  506: 
  507:         ser = Series(date_range(freq="ME", start="2012", end="2013"))
  508:         result = ser.dt.month_name(locale=time_locale)
  509:         expected = Series([month.capitalize() for month in expected_months])
  510: 
  511:         # work around https://github.com/pandas-dev/pandas/issues/22342
  512:         result = result.str.normalize("NFD")
  513:         expected = expected.str.normalize("NFD")
  514: 
  515:         tm.assert_series_equal(result, expected)
  516: 
  517:         for s_date, expected in zip(ser, expected_months):
  518:             result = s_date.month_name(locale=time_locale)
  519:             expected = expected.capitalize()
  520: 
  521:             result = unicodedata.normalize("NFD", result)
  522:             expected = unicodedata.normalize("NFD", expected)
  523: 
  524:             assert result == expected
  525: 
  526:         ser = pd.concat([ser, Series([pd.NaT])])
  527:         assert np.isnan(ser.dt.month_name(locale=time_locale).iloc[-1])
  528: 
  529:     def test_strftime(self):
  530:         # GH 10086
  531:         ser = Series(date_range("20130101", periods=5))
  532:         result = ser.dt.strftime("%Y/%m/%d")
  533:         expected = Series(
  534:             ["2013/01/01", "2013/01/02", "2013/01/03", "2013/01/04", "2013/01/05"]
  535:         )
  536:         tm.assert_series_equal(result, expected)
  537: 
  538:         ser = Series(date_range("2015-02-03 11:22:33.4567", periods=5))
  539:         result = ser.dt.strftime("%Y/%m/%d %H-%M-%S")
  540:         expected = Series(
  541:             [
  542:                 "2015/02/03 11-22-33",
  543:                 "2015/02/04 11-22-33",
  544:                 "2015/02/05 11-22-33",
  545:                 "2015/02/06 11-22-33",
  546:                 "2015/02/07 11-22-33",
  547:             ]
  548:         )
  549:         tm.assert_series_equal(result, expected)
  550: 
  551:         ser = Series(period_range("20130101", periods=5))
  552:         result = ser.dt.strftime("%Y/%m/%d")
  553:         expected = Series(
  554:             ["2013/01/01", "2013/01/02", "2013/01/03", "2013/01/04", "2013/01/05"]
  555:         )
  556:         tm.assert_series_equal(result, expected)
  557: 
  558:         ser = Series(period_range("2015-02-03 11:22:33.4567", periods=5, freq="s"))
  559:         result = ser.dt.strftime("%Y/%m/%d %H-%M-%S")
  560:         expected = Series(
  561:             [
  562:                 "2015/02/03 11-22-33",
  563:                 "2015/02/03 11-22-34",
  564:                 "2015/02/03 11-22-35",
  565:                 "2015/02/03 11-22-36",
  566:                 "2015/02/03 11-22-37",
  567:             ]
  568:         )
  569:         tm.assert_series_equal(result, expected)
  570: 
  571:     def test_strftime_dt64_days(self):
  572:         ser = Series(date_range("20130101", periods=5))
  573:         ser.iloc[0] = pd.NaT
  574:         result = ser.dt.strftime("%Y/%m/%d")
  575:         expected = Series(
  576:             [np.nan, "2013/01/02", "2013/01/03", "2013/01/04", "2013/01/05"]
  577:         )
  578:         tm.assert_series_equal(result, expected)
  579: 
  580:         datetime_index = date_range("20150301", periods=5)
  581:         result = datetime_index.strftime("%Y/%m/%d")
  582: 
  583:         expected = Index(
  584:             ["2015/03/01", "2015/03/02", "2015/03/03", "2015/03/04", "2015/03/05"],
  585:             dtype=np.object_,
  586:         )
  587:         # dtype may be S10 or U10 depending on python version
  588:         tm.assert_index_equal(result, expected)
  589: 
  590:     def test_strftime_period_days(self, using_infer_string):
  591:         period_index = period_range("20150301", periods=5)
  592:         result = period_index.strftime("%Y/%m/%d")
  593:         expected = Index(
  594:             ["2015/03/01", "2015/03/02", "2015/03/03", "2015/03/04", "2015/03/05"],
  595:             dtype="=U10",
  596:         )
  597:         if using_infer_string:
  598:             expected = expected.astype("string[pyarrow_numpy]")
  599:         tm.assert_index_equal(result, expected)
  600: 
  601:     def test_strftime_dt64_microsecond_resolution(self):
  602:         ser = Series([datetime(2013, 1, 1, 2, 32, 59), datetime(2013, 1, 2, 14, 32, 1)])
  603:         result = ser.dt.strftime("%Y-%m-%d %H:%M:%S")
  604:         expected = Series(["2013-01-01 02:32:59", "2013-01-02 14:32:01"])
  605:         tm.assert_series_equal(result, expected)
  606: 
  607:     def test_strftime_period_hours(self):
  608:         ser = Series(period_range("20130101", periods=4, freq="h"))
  609:         result = ser.dt.strftime("%Y/%m/%d %H:%M:%S")
  610:         expected = Series(
  611:             [
  612:                 "2013/01/01 00:00:00",
  613:                 "2013/01/01 01:00:00",
  614:                 "2013/01/01 02:00:00",
  615:                 "2013/01/01 03:00:00",
  616:             ]
  617:         )
  618:         tm.assert_series_equal(result, expected)
  619: 
  620:     def test_strftime_period_minutes(self):
  621:         ser = Series(period_range("20130101", periods=4, freq="ms"))
  622:         result = ser.dt.strftime("%Y/%m/%d %H:%M:%S.%l")
  623:         expected = Series(
  624:             [
  625:                 "2013/01/01 00:00:00.000",
  626:                 "2013/01/01 00:00:00.001",
  627:                 "2013/01/01 00:00:00.002",
  628:                 "2013/01/01 00:00:00.003",
  629:             ]
  630:         )
  631:         tm.assert_series_equal(result, expected)
  632: 
  633:     @pytest.mark.parametrize(
  634:         "data",
  635:         [
  636:             DatetimeIndex(["2019-01-01", pd.NaT]),
  637:             PeriodIndex(["2019-01-01", pd.NaT], dtype="period[D]"),
  638:         ],
  639:     )
  640:     def test_strftime_nat(self, data):
  641:         # GH 29578
  642:         ser = Series(data)
  643:         result = ser.dt.strftime("%Y-%m-%d")
  644:         expected = Series(["2019-01-01", np.nan])
  645:         tm.assert_series_equal(result, expected)
  646: 
  647:     @pytest.mark.parametrize(
  648:         "data", [DatetimeIndex([pd.NaT]), PeriodIndex([pd.NaT], dtype="period[D]")]
  649:     )
  650:     def test_strftime_all_nat(self, data):
  651:         # https://github.com/pandas-dev/pandas/issues/45858
  652:         ser = Series(data)
  653:         with tm.assert_produces_warning(None):
  654:             result = ser.dt.strftime("%Y-%m-%d")
  655:         expected = Series([np.nan], dtype=object)
  656:         tm.assert_series_equal(result, expected)
  657: 
  658:     def test_valid_dt_with_missing_values(self):
  659:         # GH 8689
  660:         ser = Series(date_range("20130101", periods=5, freq="D"))
  661:         ser.iloc[2] = pd.NaT
  662: 
  663:         for attr in ["microsecond", "nanosecond", "second", "minute", "hour", "day"]:
  664:             expected = getattr(ser.dt, attr).copy()
  665:             expected.iloc[2] = np.nan
  666:             result = getattr(ser.dt, attr)
  667:             tm.assert_series_equal(result, expected)
  668: 
  669:         result = ser.dt.date
  670:         expected = Series(
  671:             [
  672:                 date(2013, 1, 1),
  673:                 date(2013, 1, 2),
  674:                 pd.NaT,
  675:                 date(2013, 1, 4),
  676:                 date(2013, 1, 5),
  677:             ],
  678:             dtype="object",
  679:         )
  680:         tm.assert_series_equal(result, expected)
  681: 
  682:         result = ser.dt.time
  683:         expected = Series([time(0), time(0), pd.NaT, time(0), time(0)], dtype="object")
  684:         tm.assert_series_equal(result, expected)
  685: 
  686:     def test_dt_accessor_api(self):
  687:         # GH 9322
  688:         from pandas.core.indexes.accessors import (
  689:             CombinedDatetimelikeProperties,
  690:             DatetimeProperties,
  691:         )
  692: 
  693:         assert Series.dt is CombinedDatetimelikeProperties
  694: 
  695:         ser = Series(date_range("2000-01-01", periods=3))
  696:         assert isinstance(ser.dt, DatetimeProperties)
  697: 
  698:     @pytest.mark.parametrize(
  699:         "ser",
  700:         [
  701:             Series(np.arange(5)),
  702:             Series(list("abcde")),
  703:             Series(np.random.default_rng(2).standard_normal(5)),
  704:         ],
  705:     )
  706:     def test_dt_accessor_invalid(self, ser):
  707:         # GH#9322 check that series with incorrect dtypes don't have attr
  708:         with pytest.raises(AttributeError, match="only use .dt accessor"):
  709:             ser.dt
  710:         assert not hasattr(ser, "dt")
  711: 
  712:     def test_dt_accessor_updates_on_inplace(self):
  713:         ser = Series(date_range("2018-01-01", periods=10))
  714:         ser[2] = None
  715:         return_value = ser.fillna(pd.Timestamp("2018-01-01"), inplace=True)
  716:         assert return_value is None
  717:         result = ser.dt.date
  718:         assert result[0] == result[2]
  719: 
  720:     def test_date_tz(self):
  721:         # GH11757
  722:         rng = DatetimeIndex(
  723:             ["2014-04-04 23:56", "2014-07-18 21:24", "2015-11-22 22:14"],
  724:             tz="US/Eastern",
  725:         )
  726:         ser = Series(rng)
  727:         expected = Series([date(2014, 4, 4), date(2014, 7, 18), date(2015, 11, 22)])
  728:         tm.assert_series_equal(ser.dt.date, expected)
  729:         tm.assert_series_equal(ser.apply(lambda x: x.date()), expected)
  730: 
  731:     def test_dt_timetz_accessor(self, tz_naive_fixture):
  732:         # GH21358
  733:         tz = maybe_get_tz(tz_naive_fixture)
  734: 
  735:         dtindex = DatetimeIndex(
  736:             ["2014-04-04 23:56", "2014-07-18 21:24", "2015-11-22 22:14"], tz=tz
  737:         )
  738:         ser = Series(dtindex)
  739:         expected = Series(
  740:             [time(23, 56, tzinfo=tz), time(21, 24, tzinfo=tz), time(22, 14, tzinfo=tz)]
  741:         )
  742:         result = ser.dt.timetz
  743:         tm.assert_series_equal(result, expected)
  744: 
  745:     @pytest.mark.parametrize(
  746:         "input_series, expected_output",
  747:         [
  748:             [["2020-01-01"], [[2020, 1, 3]]],
  749:             [[pd.NaT], [[np.nan, np.nan, np.nan]]],
  750:             [["2019-12-31", "2019-12-29"], [[2020, 1, 2], [2019, 52, 7]]],
  751:             [["2010-01-01", pd.NaT], [[2009, 53, 5], [np.nan, np.nan, np.nan]]],
  752:             # see GH#36032
  753:             [["2016-01-08", "2016-01-04"], [[2016, 1, 5], [2016, 1, 1]]],
  754:             [["2016-01-07", "2016-01-01"], [[2016, 1, 4], [2015, 53, 5]]],
  755:         ],
  756:     )
  757:     def test_isocalendar(self, input_series, expected_output):
  758:         result = pd.to_datetime(Series(input_series)).dt.isocalendar()
  759:         expected_frame = DataFrame(
  760:             expected_output, columns=["year", "week", "day"], dtype="UInt32"
  761:         )
  762:         tm.assert_frame_equal(result, expected_frame)
  763: 
  764:     def test_hour_index(self):
  765:         dt_series = Series(
  766:             date_range(start="2021-01-01", periods=5, freq="h"),
  767:             index=[2, 6, 7, 8, 11],
  768:             dtype="category",
  769:         )
  770:         result = dt_series.dt.hour
  771:         expected = Series(
  772:             [0, 1, 2, 3, 4],
  773:             dtype="int32",
  774:             index=[2, 6, 7, 8, 11],
  775:         )
  776:         tm.assert_series_equal(result, expected)
  777: 
  778: 
  779: class TestSeriesPeriodValuesDtAccessor:
  780:     @pytest.mark.parametrize(
  781:         "input_vals",
  782:         [
  783:             [Period("2016-01", freq="M"), Period("2016-02", freq="M")],
  784:             [Period("2016-01-01", freq="D"), Period("2016-01-02", freq="D")],
  785:             [
  786:                 Period("2016-01-01 00:00:00", freq="h"),
  787:                 Period("2016-01-01 01:00:00", freq="h"),
  788:             ],
  789:             [
  790:                 Period("2016-01-01 00:00:00", freq="M"),
  791:                 Period("2016-01-01 00:01:00", freq="M"),
  792:             ],
  793:             [
  794:                 Period("2016-01-01 00:00:00", freq="s"),
  795:                 Period("2016-01-01 00:00:01", freq="s"),
  796:             ],
  797:         ],
  798:     )
  799:     def test_end_time_timevalues(self, input_vals):
  800:         # GH#17157
  801:         # Check that the time part of the Period is adjusted by end_time
  802:         # when using the dt accessor on a Series
  803:         input_vals = PeriodArray._from_sequence(np.asarray(input_vals))
  804: 
  805:         ser = Series(input_vals)
  806:         result = ser.dt.end_time
  807:         expected = ser.apply(lambda x: x.end_time)
  808:         tm.assert_series_equal(result, expected)
  809: 
  810:     @pytest.mark.parametrize("input_vals", [("2001"), ("NaT")])
  811:     def test_to_period(self, input_vals):
  812:         # GH#21205
  813:         expected = Series([input_vals], dtype="Period[D]")
  814:         result = Series([input_vals], dtype="datetime64[ns]").dt.to_period("D")
  815:         tm.assert_series_equal(result, expected)
  816: 
  817: 
  818: def test_normalize_pre_epoch_dates():
  819:     # GH: 36294
  820:     ser = pd.to_datetime(Series(["1969-01-01 09:00:00", "2016-01-01 09:00:00"]))
  821:     result = ser.dt.normalize()
  822:     expected = pd.to_datetime(Series(["1969-01-01", "2016-01-01"]))
  823:     tm.assert_series_equal(result, expected)
  824: 
  825: 
  826: def test_day_attribute_non_nano_beyond_int32():
  827:     # GH 52386
  828:     data = np.array(
  829:         [
  830:             136457654736252,
  831:             134736784364431,
  832:             245345345545332,
  833:             223432411,
  834:             2343241,
  835:             3634548734,
  836:             23234,
  837:         ],
  838:         dtype="timedelta64[s]",
  839:     )
  840:     ser = Series(data)
  841:     result = ser.dt.days
  842:     expected = Series([1579371003, 1559453522, 2839645203, 2586, 27, 42066, 0])
  843:     tm.assert_series_equal(result, expected)
