    1: import numpy as np
    2: import pytest
    3: 
    4: import pandas as pd
    5: from pandas import Series
    6: import pandas._testing as tm
    7: 
    8: 
    9: @pytest.mark.parametrize("operation, expected", [("min", "a"), ("max", "b")])
   10: def test_reductions_series_strings(operation, expected):
   11:     # GH#31746
   12:     ser = Series(["a", "b"], dtype="string")
   13:     res_operation_serie = getattr(ser, operation)()
   14:     assert res_operation_serie == expected
   15: 
   16: 
   17: @pytest.mark.parametrize("as_period", [True, False])
   18: def test_mode_extension_dtype(as_period):
   19:     # GH#41927 preserve dt64tz dtype
   20:     ser = Series([pd.Timestamp(1979, 4, n) for n in range(1, 5)])
   21: 
   22:     if as_period:
   23:         ser = ser.dt.to_period("D")
   24:     else:
   25:         ser = ser.dt.tz_localize("US/Central")
   26: 
   27:     res = ser.mode()
   28:     assert res.dtype == ser.dtype
   29:     tm.assert_series_equal(res, ser)
   30: 
   31: 
   32: def test_mode_nullable_dtype(any_numeric_ea_dtype):
   33:     # GH#55340
   34:     ser = Series([1, 3, 2, pd.NA, 3, 2, pd.NA], dtype=any_numeric_ea_dtype)
   35:     result = ser.mode(dropna=False)
   36:     expected = Series([2, 3, pd.NA], dtype=any_numeric_ea_dtype)
   37:     tm.assert_series_equal(result, expected)
   38: 
   39:     result = ser.mode(dropna=True)
   40:     expected = Series([2, 3], dtype=any_numeric_ea_dtype)
   41:     tm.assert_series_equal(result, expected)
   42: 
   43:     ser[-1] = pd.NA
   44: 
   45:     result = ser.mode(dropna=True)
   46:     expected = Series([2, 3], dtype=any_numeric_ea_dtype)
   47:     tm.assert_series_equal(result, expected)
   48: 
   49:     result = ser.mode(dropna=False)
   50:     expected = Series([pd.NA], dtype=any_numeric_ea_dtype)
   51:     tm.assert_series_equal(result, expected)
   52: 
   53: 
   54: def test_mode_infer_string():
   55:     # GH#56183
   56:     pytest.importorskip("pyarrow")
   57:     ser = Series(["a", "b"], dtype=object)
   58:     with pd.option_context("future.infer_string", True):
   59:         result = ser.mode()
   60:     expected = Series(["a", "b"], dtype=object)
   61:     tm.assert_series_equal(result, expected)
   62: 
   63: 
   64: def test_reductions_td64_with_nat():
   65:     # GH#8617
   66:     ser = Series([0, pd.NaT], dtype="m8[ns]")
   67:     exp = ser[0]
   68:     assert ser.median() == exp
   69:     assert ser.min() == exp
   70:     assert ser.max() == exp
   71: 
   72: 
   73: @pytest.mark.parametrize("skipna", [True, False])
   74: def test_td64_sum_empty(skipna):
   75:     # GH#37151
   76:     ser = Series([], dtype="timedelta64[ns]")
   77: 
   78:     result = ser.sum(skipna=skipna)
   79:     assert isinstance(result, pd.Timedelta)
   80:     assert result == pd.Timedelta(0)
   81: 
   82: 
   83: def test_td64_summation_overflow():
   84:     # GH#9442
   85:     ser = Series(pd.date_range("20130101", periods=100000, freq="h"))
   86:     ser[0] += pd.Timedelta("1s 1ms")
   87: 
   88:     # mean
   89:     result = (ser - ser.min()).mean()
   90:     expected = pd.Timedelta((pd.TimedeltaIndex(ser - ser.min()).asi8 / len(ser)).sum())
   91: 
   92:     # the computation is converted to float so
   93:     # might be some loss of precision
   94:     assert np.allclose(result._value / 1000, expected._value / 1000)
   95: 
   96:     # sum
   97:     msg = "overflow in timedelta operation"
   98:     with pytest.raises(ValueError, match=msg):
   99:         (ser - ser.min()).sum()
  100: 
  101:     s1 = ser[0:10000]
  102:     with pytest.raises(ValueError, match=msg):
  103:         (s1 - s1.min()).sum()
  104:     s2 = ser[0:1000]
  105:     (s2 - s2.min()).sum()
  106: 
  107: 
  108: def test_prod_numpy16_bug():
  109:     ser = Series([1.0, 1.0, 1.0], index=range(3))
  110:     result = ser.prod()
  111: 
  112:     assert not isinstance(result, Series)
  113: 
  114: 
  115: @pytest.mark.parametrize("func", [np.any, np.all])
  116: @pytest.mark.parametrize("kwargs", [{"keepdims": True}, {"out": object()}])
  117: def test_validate_any_all_out_keepdims_raises(kwargs, func):
  118:     ser = Series([1, 2])
  119:     param = next(iter(kwargs))
  120:     name = func.__name__
  121: 
  122:     msg = (
  123:         f"the '{param}' parameter is not "
  124:         "supported in the pandas "
  125:         rf"implementation of {name}\(\)"
  126:     )
  127:     with pytest.raises(ValueError, match=msg):
  128:         func(ser, **kwargs)
  129: 
  130: 
  131: def test_validate_sum_initial():
  132:     ser = Series([1, 2])
  133:     msg = (
  134:         r"the 'initial' parameter is not "
  135:         r"supported in the pandas "
  136:         r"implementation of sum\(\)"
  137:     )
  138:     with pytest.raises(ValueError, match=msg):
  139:         np.sum(ser, initial=10)
  140: 
  141: 
  142: def test_validate_median_initial():
  143:     ser = Series([1, 2])
  144:     msg = (
  145:         r"the 'overwrite_input' parameter is not "
  146:         r"supported in the pandas "
  147:         r"implementation of median\(\)"
  148:     )
  149:     with pytest.raises(ValueError, match=msg):
  150:         # It seems like np.median doesn't dispatch, so we use the
  151:         # method instead of the ufunc.
  152:         ser.median(overwrite_input=True)
  153: 
  154: 
  155: def test_validate_stat_keepdims():
  156:     ser = Series([1, 2])
  157:     msg = (
  158:         r"the 'keepdims' parameter is not "
  159:         r"supported in the pandas "
  160:         r"implementation of sum\(\)"
  161:     )
  162:     with pytest.raises(ValueError, match=msg):
  163:         np.sum(ser, keepdims=True)
  164: 
  165: 
  166: def test_mean_with_convertible_string_raises(using_array_manager, using_infer_string):
  167:     # GH#44008
  168:     ser = Series(["1", "2"])
  169:     if using_infer_string:
  170:         msg = "does not support"
  171:         with pytest.raises(TypeError, match=msg):
  172:             ser.sum()
  173:     else:
  174:         assert ser.sum() == "12"
  175:     msg = "Could not convert string '12' to numeric|does not support"
  176:     with pytest.raises(TypeError, match=msg):
  177:         ser.mean()
  178: 
  179:     df = ser.to_frame()
  180:     if not using_array_manager:
  181:         msg = r"Could not convert \['12'\] to numeric|does not support"
  182:     with pytest.raises(TypeError, match=msg):
  183:         df.mean()
  184: 
  185: 
  186: def test_mean_dont_convert_j_to_complex(using_array_manager):
  187:     # GH#36703
  188:     df = pd.DataFrame([{"db": "J", "numeric": 123}])
  189:     if using_array_manager:
  190:         msg = "Could not convert string 'J' to numeric"
  191:     else:
  192:         msg = r"Could not convert \['J'\] to numeric|does not support"
  193:     with pytest.raises(TypeError, match=msg):
  194:         df.mean()
  195: 
  196:     with pytest.raises(TypeError, match=msg):
  197:         df.agg("mean")
  198: 
  199:     msg = "Could not convert string 'J' to numeric|does not support"
  200:     with pytest.raises(TypeError, match=msg):
  201:         df["db"].mean()
  202:     msg = "Could not convert string 'J' to numeric|ufunc 'divide'"
  203:     with pytest.raises(TypeError, match=msg):
  204:         np.mean(df["db"].astype("string").array)
  205: 
  206: 
  207: def test_median_with_convertible_string_raises(using_array_manager):
  208:     # GH#34671 this _could_ return a string "2", but definitely not float 2.0
  209:     msg = r"Cannot convert \['1' '2' '3'\] to numeric|does not support"
  210:     ser = Series(["1", "2", "3"])
  211:     with pytest.raises(TypeError, match=msg):
  212:         ser.median()
  213: 
  214:     if not using_array_manager:
  215:         msg = r"Cannot convert \[\['1' '2' '3'\]\] to numeric|does not support"
  216:     df = ser.to_frame()
  217:     with pytest.raises(TypeError, match=msg):
  218:         df.median()
