    1: import re
    2: 
    3: import pytest
    4: 
    5: from pandas.compat.pyarrow import (
    6:     pa_version_under11p0,
    7:     pa_version_under13p0,
    8: )
    9: 
   10: from pandas import (
   11:     ArrowDtype,
   12:     DataFrame,
   13:     Index,
   14:     Series,
   15: )
   16: import pandas._testing as tm
   17: 
   18: pa = pytest.importorskip("pyarrow")
   19: pc = pytest.importorskip("pyarrow.compute")
   20: 
   21: 
   22: def test_struct_accessor_dtypes():
   23:     ser = Series(
   24:         [],
   25:         dtype=ArrowDtype(
   26:             pa.struct(
   27:                 [
   28:                     ("int_col", pa.int64()),
   29:                     ("string_col", pa.string()),
   30:                     (
   31:                         "struct_col",
   32:                         pa.struct(
   33:                             [
   34:                                 ("int_col", pa.int64()),
   35:                                 ("float_col", pa.float64()),
   36:                             ]
   37:                         ),
   38:                     ),
   39:                 ]
   40:             )
   41:         ),
   42:     )
   43:     actual = ser.struct.dtypes
   44:     expected = Series(
   45:         [
   46:             ArrowDtype(pa.int64()),
   47:             ArrowDtype(pa.string()),
   48:             ArrowDtype(
   49:                 pa.struct(
   50:                     [
   51:                         ("int_col", pa.int64()),
   52:                         ("float_col", pa.float64()),
   53:                     ]
   54:                 )
   55:             ),
   56:         ],
   57:         index=Index(["int_col", "string_col", "struct_col"]),
   58:     )
   59:     tm.assert_series_equal(actual, expected)
   60: 
   61: 
   62: @pytest.mark.skipif(pa_version_under13p0, reason="pyarrow>=13.0.0 required")
   63: def test_struct_accessor_field():
   64:     index = Index([-100, 42, 123])
   65:     ser = Series(
   66:         [
   67:             {"rice": 1.0, "maize": -1, "wheat": "a"},
   68:             {"rice": 2.0, "maize": 0, "wheat": "b"},
   69:             {"rice": 3.0, "maize": 1, "wheat": "c"},
   70:         ],
   71:         dtype=ArrowDtype(
   72:             pa.struct(
   73:                 [
   74:                     ("rice", pa.float64()),
   75:                     ("maize", pa.int64()),
   76:                     ("wheat", pa.string()),
   77:                 ]
   78:             )
   79:         ),
   80:         index=index,
   81:     )
   82:     by_name = ser.struct.field("maize")
   83:     by_name_expected = Series(
   84:         [-1, 0, 1],
   85:         dtype=ArrowDtype(pa.int64()),
   86:         index=index,
   87:         name="maize",
   88:     )
   89:     tm.assert_series_equal(by_name, by_name_expected)
   90: 
   91:     by_index = ser.struct.field(2)
   92:     by_index_expected = Series(
   93:         ["a", "b", "c"],
   94:         dtype=ArrowDtype(pa.string()),
   95:         index=index,
   96:         name="wheat",
   97:     )
   98:     tm.assert_series_equal(by_index, by_index_expected)
   99: 
  100: 
  101: def test_struct_accessor_field_with_invalid_name_or_index():
  102:     ser = Series([], dtype=ArrowDtype(pa.struct([("field", pa.int64())])))
  103: 
  104:     with pytest.raises(ValueError, match="name_or_index must be an int, str,"):
  105:         ser.struct.field(1.1)
  106: 
  107: 
  108: @pytest.mark.skipif(pa_version_under11p0, reason="pyarrow>=11.0.0 required")
  109: def test_struct_accessor_explode():
  110:     index = Index([-100, 42, 123])
  111:     ser = Series(
  112:         [
  113:             {"painted": 1, "snapping": {"sea": "green"}},
  114:             {"painted": 2, "snapping": {"sea": "leatherback"}},
  115:             {"painted": 3, "snapping": {"sea": "hawksbill"}},
  116:         ],
  117:         dtype=ArrowDtype(
  118:             pa.struct(
  119:                 [
  120:                     ("painted", pa.int64()),
  121:                     ("snapping", pa.struct([("sea", pa.string())])),
  122:                 ]
  123:             )
  124:         ),
  125:         index=index,
  126:     )
  127:     actual = ser.struct.explode()
  128:     expected = DataFrame(
  129:         {
  130:             "painted": Series([1, 2, 3], index=index, dtype=ArrowDtype(pa.int64())),
  131:             "snapping": Series(
  132:                 [{"sea": "green"}, {"sea": "leatherback"}, {"sea": "hawksbill"}],
  133:                 index=index,
  134:                 dtype=ArrowDtype(pa.struct([("sea", pa.string())])),
  135:             ),
  136:         },
  137:     )
  138:     tm.assert_frame_equal(actual, expected)
  139: 
  140: 
  141: @pytest.mark.parametrize(
  142:     "invalid",
  143:     [
  144:         pytest.param(Series([1, 2, 3], dtype="int64"), id="int64"),
  145:         pytest.param(
  146:             Series(["a", "b", "c"], dtype="string[pyarrow]"), id="string-pyarrow"
  147:         ),
  148:     ],
  149: )
  150: def test_struct_accessor_api_for_invalid(invalid):
  151:     with pytest.raises(
  152:         AttributeError,
  153:         match=re.escape(
  154:             "Can only use the '.struct' accessor with 'struct[pyarrow]' dtype, "
  155:             f"not {invalid.dtype}."
  156:         ),
  157:     ):
  158:         invalid.struct
  159: 
  160: 
  161: @pytest.mark.parametrize(
  162:     ["indices", "name"],
  163:     [
  164:         (0, "int_col"),
  165:         ([1, 2], "str_col"),
  166:         (pc.field("int_col"), "int_col"),
  167:         ("int_col", "int_col"),
  168:         (b"string_col", b"string_col"),
  169:         ([b"string_col"], "string_col"),
  170:     ],
  171: )
  172: @pytest.mark.skipif(pa_version_under13p0, reason="pyarrow>=13.0.0 required")
  173: def test_struct_accessor_field_expanded(indices, name):
  174:     arrow_type = pa.struct(
  175:         [
  176:             ("int_col", pa.int64()),
  177:             (
  178:                 "struct_col",
  179:                 pa.struct(
  180:                     [
  181:                         ("int_col", pa.int64()),
  182:                         ("float_col", pa.float64()),
  183:                         ("str_col", pa.string()),
  184:                     ]
  185:                 ),
  186:             ),
  187:             (b"string_col", pa.string()),
  188:         ]
  189:     )
  190: 
  191:     data = pa.array([], type=arrow_type)
  192:     ser = Series(data, dtype=ArrowDtype(arrow_type))
  193:     expected = pc.struct_field(data, indices)
  194:     result = ser.struct.field(indices)
  195:     tm.assert_equal(result.array._pa_array.combine_chunks(), expected)
  196:     assert result.name == name
