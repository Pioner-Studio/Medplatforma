    1: import numpy as np
    2: import pytest
    3: 
    4: import pandas as pd
    5: from pandas import (
    6:     Categorical,
    7:     CategoricalIndex,
    8:     Index,
    9:     Series,
   10: )
   11: import pandas._testing as tm
   12: 
   13: 
   14: class TestSeriesValueCounts:
   15:     def test_value_counts_datetime(self, unit):
   16:         # most dtypes are tested in tests/base
   17:         values = [
   18:             pd.Timestamp("2011-01-01 09:00"),
   19:             pd.Timestamp("2011-01-01 10:00"),
   20:             pd.Timestamp("2011-01-01 11:00"),
   21:             pd.Timestamp("2011-01-01 09:00"),
   22:             pd.Timestamp("2011-01-01 09:00"),
   23:             pd.Timestamp("2011-01-01 11:00"),
   24:         ]
   25: 
   26:         exp_idx = pd.DatetimeIndex(
   27:             ["2011-01-01 09:00", "2011-01-01 11:00", "2011-01-01 10:00"],
   28:             name="xxx",
   29:         ).as_unit(unit)
   30:         exp = Series([3, 2, 1], index=exp_idx, name="count")
   31: 
   32:         ser = Series(values, name="xxx").dt.as_unit(unit)
   33:         tm.assert_series_equal(ser.value_counts(), exp)
   34:         # check DatetimeIndex outputs the same result
   35:         idx = pd.DatetimeIndex(values, name="xxx").as_unit(unit)
   36:         tm.assert_series_equal(idx.value_counts(), exp)
   37: 
   38:         # normalize
   39:         exp = Series(np.array([3.0, 2.0, 1]) / 6.0, index=exp_idx, name="proportion")
   40:         tm.assert_series_equal(ser.value_counts(normalize=True), exp)
   41:         tm.assert_series_equal(idx.value_counts(normalize=True), exp)
   42: 
   43:     def test_value_counts_datetime_tz(self, unit):
   44:         values = [
   45:             pd.Timestamp("2011-01-01 09:00", tz="US/Eastern"),
   46:             pd.Timestamp("2011-01-01 10:00", tz="US/Eastern"),
   47:             pd.Timestamp("2011-01-01 11:00", tz="US/Eastern"),
   48:             pd.Timestamp("2011-01-01 09:00", tz="US/Eastern"),
   49:             pd.Timestamp("2011-01-01 09:00", tz="US/Eastern"),
   50:             pd.Timestamp("2011-01-01 11:00", tz="US/Eastern"),
   51:         ]
   52: 
   53:         exp_idx = pd.DatetimeIndex(
   54:             ["2011-01-01 09:00", "2011-01-01 11:00", "2011-01-01 10:00"],
   55:             tz="US/Eastern",
   56:             name="xxx",
   57:         ).as_unit(unit)
   58:         exp = Series([3, 2, 1], index=exp_idx, name="count")
   59: 
   60:         ser = Series(values, name="xxx").dt.as_unit(unit)
   61:         tm.assert_series_equal(ser.value_counts(), exp)
   62:         idx = pd.DatetimeIndex(values, name="xxx").as_unit(unit)
   63:         tm.assert_series_equal(idx.value_counts(), exp)
   64: 
   65:         exp = Series(np.array([3.0, 2.0, 1]) / 6.0, index=exp_idx, name="proportion")
   66:         tm.assert_series_equal(ser.value_counts(normalize=True), exp)
   67:         tm.assert_series_equal(idx.value_counts(normalize=True), exp)
   68: 
   69:     def test_value_counts_period(self):
   70:         values = [
   71:             pd.Period("2011-01", freq="M"),
   72:             pd.Period("2011-02", freq="M"),
   73:             pd.Period("2011-03", freq="M"),
   74:             pd.Period("2011-01", freq="M"),
   75:             pd.Period("2011-01", freq="M"),
   76:             pd.Period("2011-03", freq="M"),
   77:         ]
   78: 
   79:         exp_idx = pd.PeriodIndex(
   80:             ["2011-01", "2011-03", "2011-02"], freq="M", name="xxx"
   81:         )
   82:         exp = Series([3, 2, 1], index=exp_idx, name="count")
   83: 
   84:         ser = Series(values, name="xxx")
   85:         tm.assert_series_equal(ser.value_counts(), exp)
   86:         # check DatetimeIndex outputs the same result
   87:         idx = pd.PeriodIndex(values, name="xxx")
   88:         tm.assert_series_equal(idx.value_counts(), exp)
   89: 
   90:         # normalize
   91:         exp = Series(np.array([3.0, 2.0, 1]) / 6.0, index=exp_idx, name="proportion")
   92:         tm.assert_series_equal(ser.value_counts(normalize=True), exp)
   93:         tm.assert_series_equal(idx.value_counts(normalize=True), exp)
   94: 
   95:     def test_value_counts_categorical_ordered(self):
   96:         # most dtypes are tested in tests/base
   97:         values = Categorical([1, 2, 3, 1, 1, 3], ordered=True)
   98: 
   99:         exp_idx = CategoricalIndex(
  100:             [1, 3, 2], categories=[1, 2, 3], ordered=True, name="xxx"
  101:         )
  102:         exp = Series([3, 2, 1], index=exp_idx, name="count")
  103: 
  104:         ser = Series(values, name="xxx")
  105:         tm.assert_series_equal(ser.value_counts(), exp)
  106:         # check CategoricalIndex outputs the same result
  107:         idx = CategoricalIndex(values, name="xxx")
  108:         tm.assert_series_equal(idx.value_counts(), exp)
  109: 
  110:         # normalize
  111:         exp = Series(np.array([3.0, 2.0, 1]) / 6.0, index=exp_idx, name="proportion")
  112:         tm.assert_series_equal(ser.value_counts(normalize=True), exp)
  113:         tm.assert_series_equal(idx.value_counts(normalize=True), exp)
  114: 
  115:     def test_value_counts_categorical_not_ordered(self):
  116:         values = Categorical([1, 2, 3, 1, 1, 3], ordered=False)
  117: 
  118:         exp_idx = CategoricalIndex(
  119:             [1, 3, 2], categories=[1, 2, 3], ordered=False, name="xxx"
  120:         )
  121:         exp = Series([3, 2, 1], index=exp_idx, name="count")
  122: 
  123:         ser = Series(values, name="xxx")
  124:         tm.assert_series_equal(ser.value_counts(), exp)
  125:         # check CategoricalIndex outputs the same result
  126:         idx = CategoricalIndex(values, name="xxx")
  127:         tm.assert_series_equal(idx.value_counts(), exp)
  128: 
  129:         # normalize
  130:         exp = Series(np.array([3.0, 2.0, 1]) / 6.0, index=exp_idx, name="proportion")
  131:         tm.assert_series_equal(ser.value_counts(normalize=True), exp)
  132:         tm.assert_series_equal(idx.value_counts(normalize=True), exp)
  133: 
  134:     def test_value_counts_categorical(self):
  135:         # GH#12835
  136:         cats = Categorical(list("abcccb"), categories=list("cabd"))
  137:         ser = Series(cats, name="xxx")
  138:         res = ser.value_counts(sort=False)
  139: 
  140:         exp_index = CategoricalIndex(
  141:             list("cabd"), categories=cats.categories, name="xxx"
  142:         )
  143:         exp = Series([3, 1, 2, 0], name="count", index=exp_index)
  144:         tm.assert_series_equal(res, exp)
  145: 
  146:         res = ser.value_counts(sort=True)
  147: 
  148:         exp_index = CategoricalIndex(
  149:             list("cbad"), categories=cats.categories, name="xxx"
  150:         )
  151:         exp = Series([3, 2, 1, 0], name="count", index=exp_index)
  152:         tm.assert_series_equal(res, exp)
  153: 
  154:         # check object dtype handles the Series.name as the same
  155:         # (tested in tests/base)
  156:         ser = Series(["a", "b", "c", "c", "c", "b"], name="xxx")
  157:         res = ser.value_counts()
  158:         exp = Series([3, 2, 1], name="count", index=Index(["c", "b", "a"], name="xxx"))
  159:         tm.assert_series_equal(res, exp)
  160: 
  161:     def test_value_counts_categorical_with_nan(self):
  162:         # see GH#9443
  163: 
  164:         # sanity check
  165:         ser = Series(["a", "b", "a"], dtype="category")
  166:         exp = Series([2, 1], index=CategoricalIndex(["a", "b"]), name="count")
  167: 
  168:         res = ser.value_counts(dropna=True)
  169:         tm.assert_series_equal(res, exp)
  170: 
  171:         res = ser.value_counts(dropna=True)
  172:         tm.assert_series_equal(res, exp)
  173: 
  174:         # same Series via two different constructions --> same behaviour
  175:         series = [
  176:             Series(["a", "b", None, "a", None, None], dtype="category"),
  177:             Series(
  178:                 Categorical(["a", "b", None, "a", None, None], categories=["a", "b"])
  179:             ),
  180:         ]
  181: 
  182:         for ser in series:
  183:             # None is a NaN value, so we exclude its count here
  184:             exp = Series([2, 1], index=CategoricalIndex(["a", "b"]), name="count")
  185:             res = ser.value_counts(dropna=True)
  186:             tm.assert_series_equal(res, exp)
  187: 
  188:             # we don't exclude the count of None and sort by counts
  189:             exp = Series(
  190:                 [3, 2, 1], index=CategoricalIndex([np.nan, "a", "b"]), name="count"
  191:             )
  192:             res = ser.value_counts(dropna=False)
  193:             tm.assert_series_equal(res, exp)
  194: 
  195:             # When we aren't sorting by counts, and np.nan isn't a
  196:             # category, it should be last.
  197:             exp = Series(
  198:                 [2, 1, 3], index=CategoricalIndex(["a", "b", np.nan]), name="count"
  199:             )
  200:             res = ser.value_counts(dropna=False, sort=False)
  201:             tm.assert_series_equal(res, exp)
  202: 
  203:     @pytest.mark.parametrize(
  204:         "ser, dropna, exp",
  205:         [
  206:             (
  207:                 Series([False, True, True, pd.NA]),
  208:                 False,
  209:                 Series([2, 1, 1], index=[True, False, pd.NA], name="count"),
  210:             ),
  211:             (
  212:                 Series([False, True, True, pd.NA]),
  213:                 True,
  214:                 Series([2, 1], index=Index([True, False], dtype=object), name="count"),
  215:             ),
  216:             (
  217:                 Series(range(3), index=[True, False, np.nan]).index,
  218:                 False,
  219:                 Series([1, 1, 1], index=[True, False, np.nan], name="count"),
  220:             ),
  221:         ],
  222:     )
  223:     def test_value_counts_bool_with_nan(self, ser, dropna, exp):
  224:         # GH32146
  225:         out = ser.value_counts(dropna=dropna)
  226:         tm.assert_series_equal(out, exp)
  227: 
  228:     @pytest.mark.parametrize(
  229:         "input_array,expected",
  230:         [
  231:             (
  232:                 [1 + 1j, 1 + 1j, 1, 3j, 3j, 3j],
  233:                 Series(
  234:                     [3, 2, 1],
  235:                     index=Index([3j, 1 + 1j, 1], dtype=np.complex128),
  236:                     name="count",
  237:                 ),
  238:             ),
  239:             (
  240:                 np.array([1 + 1j, 1 + 1j, 1, 3j, 3j, 3j], dtype=np.complex64),
  241:                 Series(
  242:                     [3, 2, 1],
  243:                     index=Index([3j, 1 + 1j, 1], dtype=np.complex64),
  244:                     name="count",
  245:                 ),
  246:             ),
  247:         ],
  248:     )
  249:     def test_value_counts_complex_numbers(self, input_array, expected):
  250:         # GH 17927
  251:         result = Series(input_array).value_counts()
  252:         tm.assert_series_equal(result, expected)
  253: 
  254:     def test_value_counts_masked(self):
  255:         # GH#54984
  256:         dtype = "Int64"
  257:         ser = Series([1, 2, None, 2, None, 3], dtype=dtype)
  258:         result = ser.value_counts(dropna=False)
  259:         expected = Series(
  260:             [2, 2, 1, 1],
  261:             index=Index([2, None, 1, 3], dtype=dtype),
  262:             dtype=dtype,
  263:             name="count",
  264:         )
  265:         tm.assert_series_equal(result, expected)
  266: 
  267:         result = ser.value_counts(dropna=True)
  268:         expected = Series(
  269:             [2, 1, 1], index=Index([2, 1, 3], dtype=dtype), dtype=dtype, name="count"
  270:         )
  271:         tm.assert_series_equal(result, expected)
