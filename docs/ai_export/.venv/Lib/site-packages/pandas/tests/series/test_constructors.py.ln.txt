    1: from collections import OrderedDict
    2: from collections.abc import Iterator
    3: from datetime import (
    4:     datetime,
    5:     timedelta,
    6: )
    7: 
    8: from dateutil.tz import tzoffset
    9: import numpy as np
   10: from numpy import ma
   11: import pytest
   12: 
   13: from pandas._libs import (
   14:     iNaT,
   15:     lib,
   16: )
   17: from pandas.compat.numpy import np_version_gt2
   18: from pandas.errors import IntCastingNaNError
   19: import pandas.util._test_decorators as td
   20: 
   21: from pandas.core.dtypes.dtypes import CategoricalDtype
   22: 
   23: import pandas as pd
   24: from pandas import (
   25:     Categorical,
   26:     DataFrame,
   27:     DatetimeIndex,
   28:     DatetimeTZDtype,
   29:     Index,
   30:     Interval,
   31:     IntervalIndex,
   32:     MultiIndex,
   33:     NaT,
   34:     Period,
   35:     RangeIndex,
   36:     Series,
   37:     Timestamp,
   38:     date_range,
   39:     isna,
   40:     period_range,
   41:     timedelta_range,
   42: )
   43: import pandas._testing as tm
   44: from pandas.core.arrays import (
   45:     IntegerArray,
   46:     IntervalArray,
   47:     period_array,
   48: )
   49: from pandas.core.internals.blocks import NumpyBlock
   50: 
   51: 
   52: class TestSeriesConstructors:
   53:     def test_from_ints_with_non_nano_dt64_dtype(self, index_or_series):
   54:         values = np.arange(10)
   55: 
   56:         res = index_or_series(values, dtype="M8[s]")
   57:         expected = index_or_series(values.astype("M8[s]"))
   58:         tm.assert_equal(res, expected)
   59: 
   60:         res = index_or_series(list(values), dtype="M8[s]")
   61:         tm.assert_equal(res, expected)
   62: 
   63:     def test_from_na_value_and_interval_of_datetime_dtype(self):
   64:         # GH#41805
   65:         ser = Series([None], dtype="interval[datetime64[ns]]")
   66:         assert ser.isna().all()
   67:         assert ser.dtype == "interval[datetime64[ns], right]"
   68: 
   69:     def test_infer_with_date_and_datetime(self):
   70:         # GH#49341 pre-2.0 we inferred datetime-and-date to datetime64, which
   71:         #  was inconsistent with Index behavior
   72:         ts = Timestamp(2016, 1, 1)
   73:         vals = [ts.to_pydatetime(), ts.date()]
   74: 
   75:         ser = Series(vals)
   76:         expected = Series(vals, dtype=object)
   77:         tm.assert_series_equal(ser, expected)
   78: 
   79:         idx = Index(vals)
   80:         expected = Index(vals, dtype=object)
   81:         tm.assert_index_equal(idx, expected)
   82: 
   83:     def test_unparsable_strings_with_dt64_dtype(self):
   84:         # pre-2.0 these would be silently ignored and come back with object dtype
   85:         vals = ["aa"]
   86:         msg = "^Unknown datetime string format, unable to parse: aa, at position 0$"
   87:         with pytest.raises(ValueError, match=msg):
   88:             Series(vals, dtype="datetime64[ns]")
   89: 
   90:         with pytest.raises(ValueError, match=msg):
   91:             Series(np.array(vals, dtype=object), dtype="datetime64[ns]")
   92: 
   93:     @pytest.mark.parametrize(
   94:         "constructor",
   95:         [
   96:             # NOTE: some overlap with test_constructor_empty but that test does not
   97:             # test for None or an empty generator.
   98:             # test_constructor_pass_none tests None but only with the index also
   99:             # passed.
  100:             (lambda idx: Series(index=idx)),
  101:             (lambda idx: Series(None, index=idx)),
  102:             (lambda idx: Series({}, index=idx)),
  103:             (lambda idx: Series((), index=idx)),
  104:             (lambda idx: Series([], index=idx)),
  105:             (lambda idx: Series((_ for _ in []), index=idx)),
  106:             (lambda idx: Series(data=None, index=idx)),
  107:             (lambda idx: Series(data={}, index=idx)),
  108:             (lambda idx: Series(data=(), index=idx)),
  109:             (lambda idx: Series(data=[], index=idx)),
  110:             (lambda idx: Series(data=(_ for _ in []), index=idx)),
  111:         ],
  112:     )
  113:     @pytest.mark.parametrize("empty_index", [None, []])
  114:     def test_empty_constructor(self, constructor, empty_index):
  115:         # GH 49573 (addition of empty_index parameter)
  116:         expected = Series(index=empty_index)
  117:         result = constructor(empty_index)
  118: 
  119:         assert result.dtype == object
  120:         assert len(result.index) == 0
  121:         tm.assert_series_equal(result, expected, check_index_type=True)
  122: 
  123:     def test_invalid_dtype(self):
  124:         # GH15520
  125:         msg = "not understood"
  126:         invalid_list = [Timestamp, "Timestamp", list]
  127:         for dtype in invalid_list:
  128:             with pytest.raises(TypeError, match=msg):
  129:                 Series([], name="time", dtype=dtype)
  130: 
  131:     def test_invalid_compound_dtype(self):
  132:         # GH#13296
  133:         c_dtype = np.dtype([("a", "i8"), ("b", "f4")])
  134:         cdt_arr = np.array([(1, 0.4), (256, -13)], dtype=c_dtype)
  135: 
  136:         with pytest.raises(ValueError, match="Use DataFrame instead"):
  137:             Series(cdt_arr, index=["A", "B"])
  138: 
  139:     def test_scalar_conversion(self):
  140:         # Pass in scalar is disabled
  141:         scalar = Series(0.5)
  142:         assert not isinstance(scalar, float)
  143: 
  144:     def test_scalar_extension_dtype(self, ea_scalar_and_dtype):
  145:         # GH 28401
  146: 
  147:         ea_scalar, ea_dtype = ea_scalar_and_dtype
  148: 
  149:         ser = Series(ea_scalar, index=range(3))
  150:         expected = Series([ea_scalar] * 3, dtype=ea_dtype)
  151: 
  152:         assert ser.dtype == ea_dtype
  153:         tm.assert_series_equal(ser, expected)
  154: 
  155:     def test_constructor(self, datetime_series, using_infer_string):
  156:         empty_series = Series()
  157:         assert datetime_series.index._is_all_dates
  158: 
  159:         # Pass in Series
  160:         derived = Series(datetime_series)
  161:         assert derived.index._is_all_dates
  162: 
  163:         tm.assert_index_equal(derived.index, datetime_series.index)
  164:         # Ensure new index is not created
  165:         assert id(datetime_series.index) == id(derived.index)
  166: 
  167:         # Mixed type Series
  168:         mixed = Series(["hello", np.nan], index=[0, 1])
  169:         assert mixed.dtype == np.object_ if not using_infer_string else "string"
  170:         assert np.isnan(mixed[1])
  171: 
  172:         assert not empty_series.index._is_all_dates
  173:         assert not Series().index._is_all_dates
  174: 
  175:         # exception raised is of type ValueError GH35744
  176:         with pytest.raises(
  177:             ValueError,
  178:             match=r"Data must be 1-dimensional, got ndarray of shape \(3, 3\) instead",
  179:         ):
  180:             Series(np.random.default_rng(2).standard_normal((3, 3)), index=np.arange(3))
  181: 
  182:         mixed.name = "Series"
  183:         rs = Series(mixed).name
  184:         xp = "Series"
  185:         assert rs == xp
  186: 
  187:         # raise on MultiIndex GH4187
  188:         m = MultiIndex.from_arrays([[1, 2], [3, 4]])
  189:         msg = "initializing a Series from a MultiIndex is not supported"
  190:         with pytest.raises(NotImplementedError, match=msg):
  191:             Series(m)
  192: 
  193:     def test_constructor_index_ndim_gt_1_raises(self):
  194:         # GH#18579
  195:         df = DataFrame([[1, 2], [3, 4], [5, 6]], index=[3, 6, 9])
  196:         with pytest.raises(ValueError, match="Index data must be 1-dimensional"):
  197:             Series([1, 3, 2], index=df)
  198: 
  199:     @pytest.mark.parametrize("input_class", [list, dict, OrderedDict])
  200:     def test_constructor_empty(self, input_class, using_infer_string):
  201:         empty = Series()
  202:         empty2 = Series(input_class())
  203: 
  204:         # these are Index() and RangeIndex() which don't compare type equal
  205:         # but are just .equals
  206:         tm.assert_series_equal(empty, empty2, check_index_type=False)
  207: 
  208:         # With explicit dtype:
  209:         empty = Series(dtype="float64")
  210:         empty2 = Series(input_class(), dtype="float64")
  211:         tm.assert_series_equal(empty, empty2, check_index_type=False)
  212: 
  213:         # GH 18515 : with dtype=category:
  214:         empty = Series(dtype="category")
  215:         empty2 = Series(input_class(), dtype="category")
  216:         tm.assert_series_equal(empty, empty2, check_index_type=False)
  217: 
  218:         if input_class is not list:
  219:             # With index:
  220:             empty = Series(index=range(10))
  221:             empty2 = Series(input_class(), index=range(10))
  222:             tm.assert_series_equal(empty, empty2)
  223: 
  224:             # With index and dtype float64:
  225:             empty = Series(np.nan, index=range(10))
  226:             empty2 = Series(input_class(), index=range(10), dtype="float64")
  227:             tm.assert_series_equal(empty, empty2)
  228: 
  229:             # GH 19853 : with empty string, index and dtype str
  230:             empty = Series("", dtype=str, index=range(3))
  231:             if using_infer_string:
  232:                 empty2 = Series("", index=range(3), dtype=object)
  233:             else:
  234:                 empty2 = Series("", index=range(3))
  235:             tm.assert_series_equal(empty, empty2)
  236: 
  237:     @pytest.mark.parametrize("input_arg", [np.nan, float("nan")])
  238:     def test_constructor_nan(self, input_arg):
  239:         empty = Series(dtype="float64", index=range(10))
  240:         empty2 = Series(input_arg, index=range(10))
  241: 
  242:         tm.assert_series_equal(empty, empty2, check_index_type=False)
  243: 
  244:     @pytest.mark.parametrize(
  245:         "dtype",
  246:         ["f8", "i8", "M8[ns]", "m8[ns]", "category", "object", "datetime64[ns, UTC]"],
  247:     )
  248:     @pytest.mark.parametrize("index", [None, Index([])])
  249:     def test_constructor_dtype_only(self, dtype, index):
  250:         # GH-20865
  251:         result = Series(dtype=dtype, index=index)
  252:         assert result.dtype == dtype
  253:         assert len(result) == 0
  254: 
  255:     def test_constructor_no_data_index_order(self):
  256:         result = Series(index=["b", "a", "c"])
  257:         assert result.index.tolist() == ["b", "a", "c"]
  258: 
  259:     def test_constructor_no_data_string_type(self):
  260:         # GH 22477
  261:         result = Series(index=[1], dtype=str)
  262:         assert np.isnan(result.iloc[0])
  263: 
  264:     @pytest.mark.parametrize("item", ["entry", "Сђ", 13])
  265:     def test_constructor_string_element_string_type(self, item):
  266:         # GH 22477
  267:         result = Series(item, index=[1], dtype=str)
  268:         assert result.iloc[0] == str(item)
  269: 
  270:     def test_constructor_dtype_str_na_values(self, string_dtype):
  271:         # https://github.com/pandas-dev/pandas/issues/21083
  272:         ser = Series(["x", None], dtype=string_dtype)
  273:         result = ser.isna()
  274:         expected = Series([False, True])
  275:         tm.assert_series_equal(result, expected)
  276:         assert ser.iloc[1] is None
  277: 
  278:         ser = Series(["x", np.nan], dtype=string_dtype)
  279:         assert np.isnan(ser.iloc[1])
  280: 
  281:     def test_constructor_series(self):
  282:         index1 = ["d", "b", "a", "c"]
  283:         index2 = sorted(index1)
  284:         s1 = Series([4, 7, -5, 3], index=index1)
  285:         s2 = Series(s1, index=index2)
  286: 
  287:         tm.assert_series_equal(s2, s1.sort_index())
  288: 
  289:     def test_constructor_iterable(self):
  290:         # GH 21987
  291:         class Iter:
  292:             def __iter__(self) -> Iterator:
  293:                 yield from range(10)
  294: 
  295:         expected = Series(list(range(10)), dtype="int64")
  296:         result = Series(Iter(), dtype="int64")
  297:         tm.assert_series_equal(result, expected)
  298: 
  299:     def test_constructor_sequence(self):
  300:         # GH 21987
  301:         expected = Series(list(range(10)), dtype="int64")
  302:         result = Series(range(10), dtype="int64")
  303:         tm.assert_series_equal(result, expected)
  304: 
  305:     def test_constructor_single_str(self):
  306:         # GH 21987
  307:         expected = Series(["abc"])
  308:         result = Series("abc")
  309:         tm.assert_series_equal(result, expected)
  310: 
  311:     def test_constructor_list_like(self):
  312:         # make sure that we are coercing different
  313:         # list-likes to standard dtypes and not
  314:         # platform specific
  315:         expected = Series([1, 2, 3], dtype="int64")
  316:         for obj in [[1, 2, 3], (1, 2, 3), np.array([1, 2, 3], dtype="int64")]:
  317:             result = Series(obj, index=[0, 1, 2])
  318:             tm.assert_series_equal(result, expected)
  319: 
  320:     def test_constructor_boolean_index(self):
  321:         # GH#18579
  322:         s1 = Series([1, 2, 3], index=[4, 5, 6])
  323: 
  324:         index = s1 == 2
  325:         result = Series([1, 3, 2], index=index)
  326:         expected = Series([1, 3, 2], index=[False, True, False])
  327:         tm.assert_series_equal(result, expected)
  328: 
  329:     @pytest.mark.parametrize("dtype", ["bool", "int32", "int64", "float64"])
  330:     def test_constructor_index_dtype(self, dtype):
  331:         # GH 17088
  332: 
  333:         s = Series(Index([0, 2, 4]), dtype=dtype)
  334:         assert s.dtype == dtype
  335: 
  336:     @pytest.mark.parametrize(
  337:         "input_vals",
  338:         [
  339:             ([1, 2]),
  340:             (["1", "2"]),
  341:             (list(date_range("1/1/2011", periods=2, freq="h"))),
  342:             (list(date_range("1/1/2011", periods=2, freq="h", tz="US/Eastern"))),
  343:             ([Interval(left=0, right=5)]),
  344:         ],
  345:     )
  346:     def test_constructor_list_str(self, input_vals, string_dtype):
  347:         # GH 16605
  348:         # Ensure that data elements from a list are converted to strings
  349:         # when dtype is str, 'str', or 'U'
  350:         result = Series(input_vals, dtype=string_dtype)
  351:         expected = Series(input_vals).astype(string_dtype)
  352:         tm.assert_series_equal(result, expected)
  353: 
  354:     def test_constructor_list_str_na(self, string_dtype):
  355:         result = Series([1.0, 2.0, np.nan], dtype=string_dtype)
  356:         expected = Series(["1.0", "2.0", np.nan], dtype=object)
  357:         tm.assert_series_equal(result, expected)
  358:         assert np.isnan(result[2])
  359: 
  360:     def test_constructor_generator(self):
  361:         gen = (i for i in range(10))
  362: 
  363:         result = Series(gen)
  364:         exp = Series(range(10))
  365:         tm.assert_series_equal(result, exp)
  366: 
  367:         # same but with non-default index
  368:         gen = (i for i in range(10))
  369:         result = Series(gen, index=range(10, 20))
  370:         exp.index = range(10, 20)
  371:         tm.assert_series_equal(result, exp)
  372: 
  373:     def test_constructor_map(self):
  374:         # GH8909
  375:         m = (x for x in range(10))
  376: 
  377:         result = Series(m)
  378:         exp = Series(range(10))
  379:         tm.assert_series_equal(result, exp)
  380: 
  381:         # same but with non-default index
  382:         m = (x for x in range(10))
  383:         result = Series(m, index=range(10, 20))
  384:         exp.index = range(10, 20)
  385:         tm.assert_series_equal(result, exp)
  386: 
  387:     def test_constructor_categorical(self):
  388:         cat = Categorical([0, 1, 2, 0, 1, 2], ["a", "b", "c"])
  389:         res = Series(cat)
  390:         tm.assert_categorical_equal(res.values, cat)
  391: 
  392:         # can cast to a new dtype
  393:         result = Series(Categorical([1, 2, 3]), dtype="int64")
  394:         expected = Series([1, 2, 3], dtype="int64")
  395:         tm.assert_series_equal(result, expected)
  396: 
  397:     def test_construct_from_categorical_with_dtype(self):
  398:         # GH12574
  399:         ser = Series(Categorical([1, 2, 3]), dtype="category")
  400:         assert isinstance(ser.dtype, CategoricalDtype)
  401: 
  402:     def test_construct_intlist_values_category_dtype(self):
  403:         ser = Series([1, 2, 3], dtype="category")
  404:         assert isinstance(ser.dtype, CategoricalDtype)
  405: 
  406:     def test_constructor_categorical_with_coercion(self):
  407:         factor = Categorical(["a", "b", "b", "a", "a", "c", "c", "c"])
  408:         # test basic creation / coercion of categoricals
  409:         s = Series(factor, name="A")
  410:         assert s.dtype == "category"
  411:         assert len(s) == len(factor)
  412: 
  413:         # in a frame
  414:         df = DataFrame({"A": factor})
  415:         result = df["A"]
  416:         tm.assert_series_equal(result, s)
  417:         result = df.iloc[:, 0]
  418:         tm.assert_series_equal(result, s)
  419:         assert len(df) == len(factor)
  420: 
  421:         df = DataFrame({"A": s})
  422:         result = df["A"]
  423:         tm.assert_series_equal(result, s)
  424:         assert len(df) == len(factor)
  425: 
  426:         # multiples
  427:         df = DataFrame({"A": s, "B": s, "C": 1})
  428:         result1 = df["A"]
  429:         result2 = df["B"]
  430:         tm.assert_series_equal(result1, s)
  431:         tm.assert_series_equal(result2, s, check_names=False)
  432:         assert result2.name == "B"
  433:         assert len(df) == len(factor)
  434: 
  435:     def test_constructor_categorical_with_coercion2(self):
  436:         # GH8623
  437:         x = DataFrame(
  438:             [[1, "John P. Doe"], [2, "Jane Dove"], [1, "John P. Doe"]],
  439:             columns=["person_id", "person_name"],
  440:         )
  441:         x["person_name"] = Categorical(x.person_name)  # doing this breaks transform
  442: 
  443:         expected = x.iloc[0].person_name
  444:         result = x.person_name.iloc[0]
  445:         assert result == expected
  446: 
  447:         result = x.person_name[0]
  448:         assert result == expected
  449: 
  450:         result = x.person_name.loc[0]
  451:         assert result == expected
  452: 
  453:     def test_constructor_series_to_categorical(self):
  454:         # see GH#16524: test conversion of Series to Categorical
  455:         series = Series(["a", "b", "c"])
  456: 
  457:         result = Series(series, dtype="category")
  458:         expected = Series(["a", "b", "c"], dtype="category")
  459: 
  460:         tm.assert_series_equal(result, expected)
  461: 
  462:     def test_constructor_categorical_dtype(self):
  463:         result = Series(
  464:             ["a", "b"], dtype=CategoricalDtype(["a", "b", "c"], ordered=True)
  465:         )
  466:         assert isinstance(result.dtype, CategoricalDtype)
  467:         tm.assert_index_equal(result.cat.categories, Index(["a", "b", "c"]))
  468:         assert result.cat.ordered
  469: 
  470:         result = Series(["a", "b"], dtype=CategoricalDtype(["b", "a"]))
  471:         assert isinstance(result.dtype, CategoricalDtype)
  472:         tm.assert_index_equal(result.cat.categories, Index(["b", "a"]))
  473:         assert result.cat.ordered is False
  474: 
  475:         # GH 19565 - Check broadcasting of scalar with Categorical dtype
  476:         result = Series(
  477:             "a", index=[0, 1], dtype=CategoricalDtype(["a", "b"], ordered=True)
  478:         )
  479:         expected = Series(
  480:             ["a", "a"], index=[0, 1], dtype=CategoricalDtype(["a", "b"], ordered=True)
  481:         )
  482:         tm.assert_series_equal(result, expected)
  483: 
  484:     def test_constructor_categorical_string(self):
  485:         # GH 26336: the string 'category' maintains existing CategoricalDtype
  486:         cdt = CategoricalDtype(categories=list("dabc"), ordered=True)
  487:         expected = Series(list("abcabc"), dtype=cdt)
  488: 
  489:         # Series(Categorical, dtype='category') keeps existing dtype
  490:         cat = Categorical(list("abcabc"), dtype=cdt)
  491:         result = Series(cat, dtype="category")
  492:         tm.assert_series_equal(result, expected)
  493: 
  494:         # Series(Series[Categorical], dtype='category') keeps existing dtype
  495:         result = Series(result, dtype="category")
  496:         tm.assert_series_equal(result, expected)
  497: 
  498:     def test_categorical_sideeffects_free(self):
  499:         # Passing a categorical to a Series and then changing values in either
  500:         # the series or the categorical should not change the values in the
  501:         # other one, IF you specify copy!
  502:         cat = Categorical(["a", "b", "c", "a"])
  503:         s = Series(cat, copy=True)
  504:         assert s.cat is not cat
  505:         s = s.cat.rename_categories([1, 2, 3])
  506:         exp_s = np.array([1, 2, 3, 1], dtype=np.int64)
  507:         exp_cat = np.array(["a", "b", "c", "a"], dtype=np.object_)
  508:         tm.assert_numpy_array_equal(s.__array__(), exp_s)
  509:         tm.assert_numpy_array_equal(cat.__array__(), exp_cat)
  510: 
  511:         # setting
  512:         s[0] = 2
  513:         exp_s2 = np.array([2, 2, 3, 1], dtype=np.int64)
  514:         tm.assert_numpy_array_equal(s.__array__(), exp_s2)
  515:         tm.assert_numpy_array_equal(cat.__array__(), exp_cat)
  516: 
  517:         # however, copy is False by default
  518:         # so this WILL change values
  519:         cat = Categorical(["a", "b", "c", "a"])
  520:         s = Series(cat, copy=False)
  521:         assert s.values is cat
  522:         s = s.cat.rename_categories([1, 2, 3])
  523:         assert s.values is not cat
  524:         exp_s = np.array([1, 2, 3, 1], dtype=np.int64)
  525:         tm.assert_numpy_array_equal(s.__array__(), exp_s)
  526: 
  527:         s[0] = 2
  528:         exp_s2 = np.array([2, 2, 3, 1], dtype=np.int64)
  529:         tm.assert_numpy_array_equal(s.__array__(), exp_s2)
  530: 
  531:     def test_unordered_compare_equal(self):
  532:         left = Series(["a", "b", "c"], dtype=CategoricalDtype(["a", "b"]))
  533:         right = Series(Categorical(["a", "b", np.nan], categories=["a", "b"]))
  534:         tm.assert_series_equal(left, right)
  535: 
  536:     def test_constructor_maskedarray(self):
  537:         data = ma.masked_all((3,), dtype=float)
  538:         result = Series(data)
  539:         expected = Series([np.nan, np.nan, np.nan])
  540:         tm.assert_series_equal(result, expected)
  541: 
  542:         data[0] = 0.0
  543:         data[2] = 2.0
  544:         index = ["a", "b", "c"]
  545:         result = Series(data, index=index)
  546:         expected = Series([0.0, np.nan, 2.0], index=index)
  547:         tm.assert_series_equal(result, expected)
  548: 
  549:         data[1] = 1.0
  550:         result = Series(data, index=index)
  551:         expected = Series([0.0, 1.0, 2.0], index=index)
  552:         tm.assert_series_equal(result, expected)
  553: 
  554:         data = ma.masked_all((3,), dtype=int)
  555:         result = Series(data)
  556:         expected = Series([np.nan, np.nan, np.nan], dtype=float)
  557:         tm.assert_series_equal(result, expected)
  558: 
  559:         data[0] = 0
  560:         data[2] = 2
  561:         index = ["a", "b", "c"]
  562:         result = Series(data, index=index)
  563:         expected = Series([0, np.nan, 2], index=index, dtype=float)
  564:         tm.assert_series_equal(result, expected)
  565: 
  566:         data[1] = 1
  567:         result = Series(data, index=index)
  568:         expected = Series([0, 1, 2], index=index, dtype=int)
  569:         with pytest.raises(AssertionError, match="Series classes are different"):
  570:             # TODO should this be raising at all?
  571:             # https://github.com/pandas-dev/pandas/issues/56131
  572:             tm.assert_series_equal(result, expected)
  573: 
  574:         data = ma.masked_all((3,), dtype=bool)
  575:         result = Series(data)
  576:         expected = Series([np.nan, np.nan, np.nan], dtype=object)
  577:         tm.assert_series_equal(result, expected)
  578: 
  579:         data[0] = True
  580:         data[2] = False
  581:         index = ["a", "b", "c"]
  582:         result = Series(data, index=index)
  583:         expected = Series([True, np.nan, False], index=index, dtype=object)
  584:         tm.assert_series_equal(result, expected)
  585: 
  586:         data[1] = True
  587:         result = Series(data, index=index)
  588:         expected = Series([True, True, False], index=index, dtype=bool)
  589:         with pytest.raises(AssertionError, match="Series classes are different"):
  590:             # TODO should this be raising at all?
  591:             # https://github.com/pandas-dev/pandas/issues/56131
  592:             tm.assert_series_equal(result, expected)
  593: 
  594:         data = ma.masked_all((3,), dtype="M8[ns]")
  595:         result = Series(data)
  596:         expected = Series([iNaT, iNaT, iNaT], dtype="M8[ns]")
  597:         tm.assert_series_equal(result, expected)
  598: 
  599:         data[0] = datetime(2001, 1, 1)
  600:         data[2] = datetime(2001, 1, 3)
  601:         index = ["a", "b", "c"]
  602:         result = Series(data, index=index)
  603:         expected = Series(
  604:             [datetime(2001, 1, 1), iNaT, datetime(2001, 1, 3)],
  605:             index=index,
  606:             dtype="M8[ns]",
  607:         )
  608:         tm.assert_series_equal(result, expected)
  609: 
  610:         data[1] = datetime(2001, 1, 2)
  611:         result = Series(data, index=index)
  612:         expected = Series(
  613:             [datetime(2001, 1, 1), datetime(2001, 1, 2), datetime(2001, 1, 3)],
  614:             index=index,
  615:             dtype="M8[ns]",
  616:         )
  617:         tm.assert_series_equal(result, expected)
  618: 
  619:     def test_constructor_maskedarray_hardened(self):
  620:         # Check numpy masked arrays with hard masks -- from GH24574
  621:         data = ma.masked_all((3,), dtype=float).harden_mask()
  622:         result = Series(data)
  623:         expected = Series([np.nan, np.nan, np.nan])
  624:         tm.assert_series_equal(result, expected)
  625: 
  626:     def test_series_ctor_plus_datetimeindex(self, using_copy_on_write):
  627:         rng = date_range("20090415", "20090519", freq="B")
  628:         data = {k: 1 for k in rng}
  629: 
  630:         result = Series(data, index=rng)
  631:         if using_copy_on_write:
  632:             assert result.index.is_(rng)
  633:         else:
  634:             assert result.index is rng
  635: 
  636:     def test_constructor_default_index(self):
  637:         s = Series([0, 1, 2])
  638:         tm.assert_index_equal(s.index, Index(range(3)), exact=True)
  639: 
  640:     @pytest.mark.parametrize(
  641:         "input",
  642:         [
  643:             [1, 2, 3],
  644:             (1, 2, 3),
  645:             list(range(3)),
  646:             Categorical(["a", "b", "a"]),
  647:             (i for i in range(3)),
  648:             (x for x in range(3)),
  649:         ],
  650:     )
  651:     def test_constructor_index_mismatch(self, input):
  652:         # GH 19342
  653:         # test that construction of a Series with an index of different length
  654:         # raises an error
  655:         msg = r"Length of values \(3\) does not match length of index \(4\)"
  656:         with pytest.raises(ValueError, match=msg):
  657:             Series(input, index=np.arange(4))
  658: 
  659:     def test_constructor_numpy_scalar(self):
  660:         # GH 19342
  661:         # construction with a numpy scalar
  662:         # should not raise
  663:         result = Series(np.array(100), index=np.arange(4), dtype="int64")
  664:         expected = Series(100, index=np.arange(4), dtype="int64")
  665:         tm.assert_series_equal(result, expected)
  666: 
  667:     def test_constructor_broadcast_list(self):
  668:         # GH 19342
  669:         # construction with single-element container and index
  670:         # should raise
  671:         msg = r"Length of values \(1\) does not match length of index \(3\)"
  672:         with pytest.raises(ValueError, match=msg):
  673:             Series(["foo"], index=["a", "b", "c"])
  674: 
  675:     def test_constructor_corner(self):
  676:         df = DataFrame(range(5), index=date_range("2020-01-01", periods=5))
  677:         objs = [df, df]
  678:         s = Series(objs, index=[0, 1])
  679:         assert isinstance(s, Series)
  680: 
  681:     def test_constructor_sanitize(self):
  682:         s = Series(np.array([1.0, 1.0, 8.0]), dtype="i8")
  683:         assert s.dtype == np.dtype("i8")
  684: 
  685:         msg = r"Cannot convert non-finite values \(NA or inf\) to integer"
  686:         with pytest.raises(IntCastingNaNError, match=msg):
  687:             Series(np.array([1.0, 1.0, np.nan]), copy=True, dtype="i8")
  688: 
  689:     def test_constructor_copy(self):
  690:         # GH15125
  691:         # test dtype parameter has no side effects on copy=True
  692:         for data in [[1.0], np.array([1.0])]:
  693:             x = Series(data)
  694:             y = Series(x, copy=True, dtype=float)
  695: 
  696:             # copy=True maintains original data in Series
  697:             tm.assert_series_equal(x, y)
  698: 
  699:             # changes to origin of copy does not affect the copy
  700:             x[0] = 2.0
  701:             assert not x.equals(y)
  702:             assert x[0] == 2.0
  703:             assert y[0] == 1.0
  704: 
  705:     @td.skip_array_manager_invalid_test  # TODO(ArrayManager) rewrite test
  706:     @pytest.mark.parametrize(
  707:         "index",
  708:         [
  709:             date_range("20170101", periods=3, tz="US/Eastern"),
  710:             date_range("20170101", periods=3),
  711:             timedelta_range("1 day", periods=3),
  712:             period_range("2012Q1", periods=3, freq="Q"),
  713:             Index(list("abc")),
  714:             Index([1, 2, 3]),
  715:             RangeIndex(0, 3),
  716:         ],
  717:         ids=lambda x: type(x).__name__,
  718:     )
  719:     def test_constructor_limit_copies(self, index):
  720:         # GH 17449
  721:         # limit copies of input
  722:         s = Series(index)
  723: 
  724:         # we make 1 copy; this is just a smoke test here
  725:         assert s._mgr.blocks[0].values is not index
  726: 
  727:     def test_constructor_shallow_copy(self):
  728:         # constructing a Series from Series with copy=False should still
  729:         # give a "shallow" copy (share data, not attributes)
  730:         # https://github.com/pandas-dev/pandas/issues/49523
  731:         s = Series([1, 2, 3])
  732:         s_orig = s.copy()
  733:         s2 = Series(s)
  734:         assert s2._mgr is not s._mgr
  735:         # Overwriting index of s2 doesn't change s
  736:         s2.index = ["a", "b", "c"]
  737:         tm.assert_series_equal(s, s_orig)
  738: 
  739:     def test_constructor_pass_none(self):
  740:         s = Series(None, index=range(5))
  741:         assert s.dtype == np.float64
  742: 
  743:         s = Series(None, index=range(5), dtype=object)
  744:         assert s.dtype == np.object_
  745: 
  746:         # GH 7431
  747:         # inference on the index
  748:         s = Series(index=np.array([None]))
  749:         expected = Series(index=Index([None]))
  750:         tm.assert_series_equal(s, expected)
  751: 
  752:     def test_constructor_pass_nan_nat(self):
  753:         # GH 13467
  754:         exp = Series([np.nan, np.nan], dtype=np.float64)
  755:         assert exp.dtype == np.float64
  756:         tm.assert_series_equal(Series([np.nan, np.nan]), exp)
  757:         tm.assert_series_equal(Series(np.array([np.nan, np.nan])), exp)
  758: 
  759:         exp = Series([NaT, NaT])
  760:         assert exp.dtype == "datetime64[ns]"
  761:         tm.assert_series_equal(Series([NaT, NaT]), exp)
  762:         tm.assert_series_equal(Series(np.array([NaT, NaT])), exp)
  763: 
  764:         tm.assert_series_equal(Series([NaT, np.nan]), exp)
  765:         tm.assert_series_equal(Series(np.array([NaT, np.nan])), exp)
  766: 
  767:         tm.assert_series_equal(Series([np.nan, NaT]), exp)
  768:         tm.assert_series_equal(Series(np.array([np.nan, NaT])), exp)
  769: 
  770:     def test_constructor_cast(self):
  771:         msg = "could not convert string to float"
  772:         with pytest.raises(ValueError, match=msg):
  773:             Series(["a", "b", "c"], dtype=float)
  774: 
  775:     def test_constructor_signed_int_overflow_raises(self):
  776:         # GH#41734 disallow silent overflow, enforced in 2.0
  777:         if np_version_gt2:
  778:             msg = "The elements provided in the data cannot all be casted to the dtype"
  779:             err = OverflowError
  780:         else:
  781:             msg = "Values are too large to be losslessly converted"
  782:             err = ValueError
  783:         with pytest.raises(err, match=msg):
  784:             Series([1, 200, 923442], dtype="int8")
  785: 
  786:         with pytest.raises(err, match=msg):
  787:             Series([1, 200, 923442], dtype="uint8")
  788: 
  789:     @pytest.mark.parametrize(
  790:         "values",
  791:         [
  792:             np.array([1], dtype=np.uint16),
  793:             np.array([1], dtype=np.uint32),
  794:             np.array([1], dtype=np.uint64),
  795:             [np.uint16(1)],
  796:             [np.uint32(1)],
  797:             [np.uint64(1)],
  798:         ],
  799:     )
  800:     def test_constructor_numpy_uints(self, values):
  801:         # GH#47294
  802:         value = values[0]
  803:         result = Series(values)
  804: 
  805:         assert result[0].dtype == value.dtype
  806:         assert result[0] == value
  807: 
  808:     def test_constructor_unsigned_dtype_overflow(self, any_unsigned_int_numpy_dtype):
  809:         # see gh-15832
  810:         if np_version_gt2:
  811:             msg = (
  812:                 f"The elements provided in the data cannot "
  813:                 f"all be casted to the dtype {any_unsigned_int_numpy_dtype}"
  814:             )
  815:         else:
  816:             msg = "Trying to coerce negative values to unsigned integers"
  817:         with pytest.raises(OverflowError, match=msg):
  818:             Series([-1], dtype=any_unsigned_int_numpy_dtype)
  819: 
  820:     def test_constructor_floating_data_int_dtype(self, frame_or_series):
  821:         # GH#40110
  822:         arr = np.random.default_rng(2).standard_normal(2)
  823: 
  824:         # Long-standing behavior (for Series, new in 2.0 for DataFrame)
  825:         #  has been to ignore the dtype on these;
  826:         #  not clear if this is what we want long-term
  827:         # expected = frame_or_series(arr)
  828: 
  829:         # GH#49599 as of 2.0 we raise instead of silently retaining float dtype
  830:         msg = "Trying to coerce float values to integer"
  831:         with pytest.raises(ValueError, match=msg):
  832:             frame_or_series(arr, dtype="i8")
  833: 
  834:         with pytest.raises(ValueError, match=msg):
  835:             frame_or_series(list(arr), dtype="i8")
  836: 
  837:         # pre-2.0, when we had NaNs, we silently ignored the integer dtype
  838:         arr[0] = np.nan
  839:         # expected = frame_or_series(arr)
  840: 
  841:         msg = r"Cannot convert non-finite values \(NA or inf\) to integer"
  842:         with pytest.raises(IntCastingNaNError, match=msg):
  843:             frame_or_series(arr, dtype="i8")
  844: 
  845:         exc = IntCastingNaNError
  846:         if frame_or_series is Series:
  847:             # TODO: try to align these
  848:             exc = ValueError
  849:             msg = "cannot convert float NaN to integer"
  850:         with pytest.raises(exc, match=msg):
  851:             # same behavior if we pass list instead of the ndarray
  852:             frame_or_series(list(arr), dtype="i8")
  853: 
  854:         # float array that can be losslessly cast to integers
  855:         arr = np.array([1.0, 2.0], dtype="float64")
  856:         expected = frame_or_series(arr.astype("i8"))
  857: 
  858:         obj = frame_or_series(arr, dtype="i8")
  859:         tm.assert_equal(obj, expected)
  860: 
  861:         obj = frame_or_series(list(arr), dtype="i8")
  862:         tm.assert_equal(obj, expected)
  863: 
  864:     def test_constructor_coerce_float_fail(self, any_int_numpy_dtype):
  865:         # see gh-15832
  866:         # Updated: make sure we treat this list the same as we would treat
  867:         #  the equivalent ndarray
  868:         # GH#49599 pre-2.0 we silently retained float dtype, in 2.0 we raise
  869:         vals = [1, 2, 3.5]
  870: 
  871:         msg = "Trying to coerce float values to integer"
  872:         with pytest.raises(ValueError, match=msg):
  873:             Series(vals, dtype=any_int_numpy_dtype)
  874:         with pytest.raises(ValueError, match=msg):
  875:             Series(np.array(vals), dtype=any_int_numpy_dtype)
  876: 
  877:     def test_constructor_coerce_float_valid(self, float_numpy_dtype):
  878:         s = Series([1, 2, 3.5], dtype=float_numpy_dtype)
  879:         expected = Series([1, 2, 3.5]).astype(float_numpy_dtype)
  880:         tm.assert_series_equal(s, expected)
  881: 
  882:     def test_constructor_invalid_coerce_ints_with_float_nan(self, any_int_numpy_dtype):
  883:         # GH 22585
  884:         # Updated: make sure we treat this list the same as we would treat the
  885:         # equivalent ndarray
  886:         vals = [1, 2, np.nan]
  887:         # pre-2.0 this would return with a float dtype, in 2.0 we raise
  888: 
  889:         msg = "cannot convert float NaN to integer"
  890:         with pytest.raises(ValueError, match=msg):
  891:             Series(vals, dtype=any_int_numpy_dtype)
  892:         msg = r"Cannot convert non-finite values \(NA or inf\) to integer"
  893:         with pytest.raises(IntCastingNaNError, match=msg):
  894:             Series(np.array(vals), dtype=any_int_numpy_dtype)
  895: 
  896:     def test_constructor_dtype_no_cast(self, using_copy_on_write, warn_copy_on_write):
  897:         # see gh-1572
  898:         s = Series([1, 2, 3])
  899:         s2 = Series(s, dtype=np.int64)
  900: 
  901:         warn = FutureWarning if warn_copy_on_write else None
  902:         with tm.assert_produces_warning(warn):
  903:             s2[1] = 5
  904:         if using_copy_on_write:
  905:             assert s[1] == 2
  906:         else:
  907:             assert s[1] == 5
  908: 
  909:     def test_constructor_datelike_coercion(self):
  910:         # GH 9477
  911:         # incorrectly inferring on dateimelike looking when object dtype is
  912:         # specified
  913:         s = Series([Timestamp("20130101"), "NOV"], dtype=object)
  914:         assert s.iloc[0] == Timestamp("20130101")
  915:         assert s.iloc[1] == "NOV"
  916:         assert s.dtype == object
  917: 
  918:     def test_constructor_datelike_coercion2(self):
  919:         # the dtype was being reset on the slicing and re-inferred to datetime
  920:         # even thought the blocks are mixed
  921:         belly = "216 3T19".split()
  922:         wing1 = "2T15 4H19".split()
  923:         wing2 = "416 4T20".split()
  924:         mat = pd.to_datetime("2016-01-22 2019-09-07".split())
  925:         df = DataFrame({"wing1": wing1, "wing2": wing2, "mat": mat}, index=belly)
  926: 
  927:         result = df.loc["3T19"]
  928:         assert result.dtype == object
  929:         result = df.loc["216"]
  930:         assert result.dtype == object
  931: 
  932:     def test_constructor_mixed_int_and_timestamp(self, frame_or_series):
  933:         # specifically Timestamp with nanos, not datetimes
  934:         objs = [Timestamp(9), 10, NaT._value]
  935:         result = frame_or_series(objs, dtype="M8[ns]")
  936: 
  937:         expected = frame_or_series([Timestamp(9), Timestamp(10), NaT])
  938:         tm.assert_equal(result, expected)
  939: 
  940:     def test_constructor_datetimes_with_nulls(self):
  941:         # gh-15869
  942:         for arr in [
  943:             np.array([None, None, None, None, datetime.now(), None]),
  944:             np.array([None, None, datetime.now(), None]),
  945:         ]:
  946:             result = Series(arr)
  947:             assert result.dtype == "M8[ns]"
  948: 
  949:     def test_constructor_dtype_datetime64(self):
  950:         s = Series(iNaT, dtype="M8[ns]", index=range(5))
  951:         assert isna(s).all()
  952: 
  953:         # in theory this should be all nulls, but since
  954:         # we are not specifying a dtype is ambiguous
  955:         s = Series(iNaT, index=range(5))
  956:         assert not isna(s).all()
  957: 
  958:         s = Series(np.nan, dtype="M8[ns]", index=range(5))
  959:         assert isna(s).all()
  960: 
  961:         s = Series([datetime(2001, 1, 2, 0, 0), iNaT], dtype="M8[ns]")
  962:         assert isna(s[1])
  963:         assert s.dtype == "M8[ns]"
  964: 
  965:         s = Series([datetime(2001, 1, 2, 0, 0), np.nan], dtype="M8[ns]")
  966:         assert isna(s[1])
  967:         assert s.dtype == "M8[ns]"
  968: 
  969:     def test_constructor_dtype_datetime64_10(self):
  970:         # GH3416
  971:         pydates = [datetime(2013, 1, 1), datetime(2013, 1, 2), datetime(2013, 1, 3)]
  972:         dates = [np.datetime64(x) for x in pydates]
  973: 
  974:         ser = Series(dates)
  975:         assert ser.dtype == "M8[ns]"
  976: 
  977:         ser.iloc[0] = np.nan
  978:         assert ser.dtype == "M8[ns]"
  979: 
  980:         # GH3414 related
  981:         expected = Series(pydates, dtype="datetime64[ms]")
  982: 
  983:         result = Series(Series(dates).astype(np.int64) / 1000000, dtype="M8[ms]")
  984:         tm.assert_series_equal(result, expected)
  985: 
  986:         result = Series(dates, dtype="datetime64[ms]")
  987:         tm.assert_series_equal(result, expected)
  988: 
  989:         expected = Series(
  990:             [NaT, datetime(2013, 1, 2), datetime(2013, 1, 3)], dtype="datetime64[ns]"
  991:         )
  992:         result = Series([np.nan] + dates[1:], dtype="datetime64[ns]")
  993:         tm.assert_series_equal(result, expected)
  994: 
  995:     def test_constructor_dtype_datetime64_11(self):
  996:         pydates = [datetime(2013, 1, 1), datetime(2013, 1, 2), datetime(2013, 1, 3)]
  997:         dates = [np.datetime64(x) for x in pydates]
  998: 
  999:         dts = Series(dates, dtype="datetime64[ns]")
 1000: 
 1001:         # valid astype
 1002:         dts.astype("int64")
 1003: 
 1004:         # invalid casting
 1005:         msg = r"Converting from datetime64\[ns\] to int32 is not supported"
 1006:         with pytest.raises(TypeError, match=msg):
 1007:             dts.astype("int32")
 1008: 
 1009:         # ints are ok
 1010:         # we test with np.int64 to get similar results on
 1011:         # windows / 32-bit platforms
 1012:         result = Series(dts, dtype=np.int64)
 1013:         expected = Series(dts.astype(np.int64))
 1014:         tm.assert_series_equal(result, expected)
 1015: 
 1016:     def test_constructor_dtype_datetime64_9(self):
 1017:         # invalid dates can be help as object
 1018:         result = Series([datetime(2, 1, 1)])
 1019:         assert result[0] == datetime(2, 1, 1, 0, 0)
 1020: 
 1021:         result = Series([datetime(3000, 1, 1)])
 1022:         assert result[0] == datetime(3000, 1, 1, 0, 0)
 1023: 
 1024:     def test_constructor_dtype_datetime64_8(self):
 1025:         # don't mix types
 1026:         result = Series([Timestamp("20130101"), 1], index=["a", "b"])
 1027:         assert result["a"] == Timestamp("20130101")
 1028:         assert result["b"] == 1
 1029: 
 1030:     def test_constructor_dtype_datetime64_7(self):
 1031:         # GH6529
 1032:         # coerce datetime64 non-ns properly
 1033:         dates = date_range("01-Jan-2015", "01-Dec-2015", freq="ME")
 1034:         values2 = dates.view(np.ndarray).astype("datetime64[ns]")
 1035:         expected = Series(values2, index=dates)
 1036: 
 1037:         for unit in ["s", "D", "ms", "us", "ns"]:
 1038:             dtype = np.dtype(f"M8[{unit}]")
 1039:             values1 = dates.view(np.ndarray).astype(dtype)
 1040:             result = Series(values1, dates)
 1041:             if unit == "D":
 1042:                 # for unit="D" we cast to nearest-supported reso, i.e. "s"
 1043:                 dtype = np.dtype("M8[s]")
 1044:             assert result.dtype == dtype
 1045:             tm.assert_series_equal(result, expected.astype(dtype))
 1046: 
 1047:         # GH 13876
 1048:         # coerce to non-ns to object properly
 1049:         expected = Series(values2, index=dates, dtype=object)
 1050:         for dtype in ["s", "D", "ms", "us", "ns"]:
 1051:             values1 = dates.view(np.ndarray).astype(f"M8[{dtype}]")
 1052:             result = Series(values1, index=dates, dtype=object)
 1053:             tm.assert_series_equal(result, expected)
 1054: 
 1055:         # leave datetime.date alone
 1056:         dates2 = np.array([d.date() for d in dates.to_pydatetime()], dtype=object)
 1057:         series1 = Series(dates2, dates)
 1058:         tm.assert_numpy_array_equal(series1.values, dates2)
 1059:         assert series1.dtype == object
 1060: 
 1061:     def test_constructor_dtype_datetime64_6(self):
 1062:         # as of 2.0, these no longer infer datetime64 based on the strings,
 1063:         #  matching the Index behavior
 1064: 
 1065:         ser = Series([None, NaT, "2013-08-05 15:30:00.000001"])
 1066:         assert ser.dtype == object
 1067: 
 1068:         ser = Series([np.nan, NaT, "2013-08-05 15:30:00.000001"])
 1069:         assert ser.dtype == object
 1070: 
 1071:         ser = Series([NaT, None, "2013-08-05 15:30:00.000001"])
 1072:         assert ser.dtype == object
 1073: 
 1074:         ser = Series([NaT, np.nan, "2013-08-05 15:30:00.000001"])
 1075:         assert ser.dtype == object
 1076: 
 1077:     def test_constructor_dtype_datetime64_5(self):
 1078:         # tz-aware (UTC and other tz's)
 1079:         # GH 8411
 1080:         dr = date_range("20130101", periods=3)
 1081:         assert Series(dr).iloc[0].tz is None
 1082:         dr = date_range("20130101", periods=3, tz="UTC")
 1083:         assert str(Series(dr).iloc[0].tz) == "UTC"
 1084:         dr = date_range("20130101", periods=3, tz="US/Eastern")
 1085:         assert str(Series(dr).iloc[0].tz) == "US/Eastern"
 1086: 
 1087:     def test_constructor_dtype_datetime64_4(self):
 1088:         # non-convertible
 1089:         ser = Series([1479596223000, -1479590, NaT])
 1090:         assert ser.dtype == "object"
 1091:         assert ser[2] is NaT
 1092:         assert "NaT" in str(ser)
 1093: 
 1094:     def test_constructor_dtype_datetime64_3(self):
 1095:         # if we passed a NaT it remains
 1096:         ser = Series([datetime(2010, 1, 1), datetime(2, 1, 1), NaT])
 1097:         assert ser.dtype == "object"
 1098:         assert ser[2] is NaT
 1099:         assert "NaT" in str(ser)
 1100: 
 1101:     def test_constructor_dtype_datetime64_2(self):
 1102:         # if we passed a nan it remains
 1103:         ser = Series([datetime(2010, 1, 1), datetime(2, 1, 1), np.nan])
 1104:         assert ser.dtype == "object"
 1105:         assert ser[2] is np.nan
 1106:         assert "NaN" in str(ser)
 1107: 
 1108:     def test_constructor_with_datetime_tz(self):
 1109:         # 8260
 1110:         # support datetime64 with tz
 1111: 
 1112:         dr = date_range("20130101", periods=3, tz="US/Eastern")
 1113:         s = Series(dr)
 1114:         assert s.dtype.name == "datetime64[ns, US/Eastern]"
 1115:         assert s.dtype == "datetime64[ns, US/Eastern]"
 1116:         assert isinstance(s.dtype, DatetimeTZDtype)
 1117:         assert "datetime64[ns, US/Eastern]" in str(s)
 1118: 
 1119:         # export
 1120:         result = s.values
 1121:         assert isinstance(result, np.ndarray)
 1122:         assert result.dtype == "datetime64[ns]"
 1123: 
 1124:         exp = DatetimeIndex(result)
 1125:         exp = exp.tz_localize("UTC").tz_convert(tz=s.dt.tz)
 1126:         tm.assert_index_equal(dr, exp)
 1127: 
 1128:         # indexing
 1129:         result = s.iloc[0]
 1130:         assert result == Timestamp("2013-01-01 00:00:00-0500", tz="US/Eastern")
 1131:         result = s[0]
 1132:         assert result == Timestamp("2013-01-01 00:00:00-0500", tz="US/Eastern")
 1133: 
 1134:         result = s[Series([True, True, False], index=s.index)]
 1135:         tm.assert_series_equal(result, s[0:2])
 1136: 
 1137:         result = s.iloc[0:1]
 1138:         tm.assert_series_equal(result, Series(dr[0:1]))
 1139: 
 1140:         # concat
 1141:         result = pd.concat([s.iloc[0:1], s.iloc[1:]])
 1142:         tm.assert_series_equal(result, s)
 1143: 
 1144:         # short str
 1145:         assert "datetime64[ns, US/Eastern]" in str(s)
 1146: 
 1147:         # formatting with NaT
 1148:         result = s.shift()
 1149:         assert "datetime64[ns, US/Eastern]" in str(result)
 1150:         assert "NaT" in str(result)
 1151: 
 1152:         result = DatetimeIndex(s, freq="infer")
 1153:         tm.assert_index_equal(result, dr)
 1154: 
 1155:     def test_constructor_with_datetime_tz5(self):
 1156:         # long str
 1157:         ser = Series(date_range("20130101", periods=1000, tz="US/Eastern"))
 1158:         assert "datetime64[ns, US/Eastern]" in str(ser)
 1159: 
 1160:     def test_constructor_with_datetime_tz4(self):
 1161:         # inference
 1162:         ser = Series(
 1163:             [
 1164:                 Timestamp("2013-01-01 13:00:00-0800", tz="US/Pacific"),
 1165:                 Timestamp("2013-01-02 14:00:00-0800", tz="US/Pacific"),
 1166:             ]
 1167:         )
 1168:         assert ser.dtype == "datetime64[ns, US/Pacific]"
 1169:         assert lib.infer_dtype(ser, skipna=True) == "datetime64"
 1170: 
 1171:     def test_constructor_with_datetime_tz3(self):
 1172:         ser = Series(
 1173:             [
 1174:                 Timestamp("2013-01-01 13:00:00-0800", tz="US/Pacific"),
 1175:                 Timestamp("2013-01-02 14:00:00-0800", tz="US/Eastern"),
 1176:             ]
 1177:         )
 1178:         assert ser.dtype == "object"
 1179:         assert lib.infer_dtype(ser, skipna=True) == "datetime"
 1180: 
 1181:     def test_constructor_with_datetime_tz2(self):
 1182:         # with all NaT
 1183:         ser = Series(NaT, index=[0, 1], dtype="datetime64[ns, US/Eastern]")
 1184:         dti = DatetimeIndex(["NaT", "NaT"], tz="US/Eastern").as_unit("ns")
 1185:         expected = Series(dti)
 1186:         tm.assert_series_equal(ser, expected)
 1187: 
 1188:     def test_constructor_no_partial_datetime_casting(self):
 1189:         # GH#40111
 1190:         vals = [
 1191:             "nan",
 1192:             Timestamp("1990-01-01"),
 1193:             "2015-03-14T16:15:14.123-08:00",
 1194:             "2019-03-04T21:56:32.620-07:00",
 1195:             None,
 1196:         ]
 1197:         ser = Series(vals)
 1198:         assert all(ser[i] is vals[i] for i in range(len(vals)))
 1199: 
 1200:     @pytest.mark.parametrize("arr_dtype", [np.int64, np.float64])
 1201:     @pytest.mark.parametrize("kind", ["M", "m"])
 1202:     @pytest.mark.parametrize("unit", ["ns", "us", "ms", "s", "h", "m", "D"])
 1203:     def test_construction_to_datetimelike_unit(self, arr_dtype, kind, unit):
 1204:         # tests all units
 1205:         # gh-19223
 1206:         # TODO: GH#19223 was about .astype, doesn't belong here
 1207:         dtype = f"{kind}8[{unit}]"
 1208:         arr = np.array([1, 2, 3], dtype=arr_dtype)
 1209:         ser = Series(arr)
 1210:         result = ser.astype(dtype)
 1211: 
 1212:         expected = Series(arr.astype(dtype))
 1213: 
 1214:         if unit in ["ns", "us", "ms", "s"]:
 1215:             assert result.dtype == dtype
 1216:             assert expected.dtype == dtype
 1217:         else:
 1218:             # Otherwise we cast to nearest-supported unit, i.e. seconds
 1219:             assert result.dtype == f"{kind}8[s]"
 1220:             assert expected.dtype == f"{kind}8[s]"
 1221: 
 1222:         tm.assert_series_equal(result, expected)
 1223: 
 1224:     @pytest.mark.parametrize("arg", ["2013-01-01 00:00:00", NaT, np.nan, None])
 1225:     def test_constructor_with_naive_string_and_datetimetz_dtype(self, arg):
 1226:         # GH 17415: With naive string
 1227:         result = Series([arg], dtype="datetime64[ns, CET]")
 1228:         expected = Series(Timestamp(arg)).dt.tz_localize("CET")
 1229:         tm.assert_series_equal(result, expected)
 1230: 
 1231:     def test_constructor_datetime64_bigendian(self):
 1232:         # GH#30976
 1233:         ms = np.datetime64(1, "ms")
 1234:         arr = np.array([np.datetime64(1, "ms")], dtype=">M8[ms]")
 1235: 
 1236:         result = Series(arr)
 1237:         expected = Series([Timestamp(ms)]).astype("M8[ms]")
 1238:         assert expected.dtype == "M8[ms]"
 1239:         tm.assert_series_equal(result, expected)
 1240: 
 1241:     @pytest.mark.parametrize("interval_constructor", [IntervalIndex, IntervalArray])
 1242:     def test_construction_interval(self, interval_constructor):
 1243:         # construction from interval & array of intervals
 1244:         intervals = interval_constructor.from_breaks(np.arange(3), closed="right")
 1245:         result = Series(intervals)
 1246:         assert result.dtype == "interval[int64, right]"
 1247:         tm.assert_index_equal(Index(result.values), Index(intervals))
 1248: 
 1249:     @pytest.mark.parametrize(
 1250:         "data_constructor", [list, np.array], ids=["list", "ndarray[object]"]
 1251:     )
 1252:     def test_constructor_infer_interval(self, data_constructor):
 1253:         # GH 23563: consistent closed results in interval dtype
 1254:         data = [Interval(0, 1), Interval(0, 2), None]
 1255:         result = Series(data_constructor(data))
 1256:         expected = Series(IntervalArray(data))
 1257:         assert result.dtype == "interval[float64, right]"
 1258:         tm.assert_series_equal(result, expected)
 1259: 
 1260:     @pytest.mark.parametrize(
 1261:         "data_constructor", [list, np.array], ids=["list", "ndarray[object]"]
 1262:     )
 1263:     def test_constructor_interval_mixed_closed(self, data_constructor):
 1264:         # GH 23563: mixed closed results in object dtype (not interval dtype)
 1265:         data = [Interval(0, 1, closed="both"), Interval(0, 2, closed="neither")]
 1266:         result = Series(data_constructor(data))
 1267:         assert result.dtype == object
 1268:         assert result.tolist() == data
 1269: 
 1270:     def test_construction_consistency(self):
 1271:         # make sure that we are not re-localizing upon construction
 1272:         # GH 14928
 1273:         ser = Series(date_range("20130101", periods=3, tz="US/Eastern"))
 1274: 
 1275:         result = Series(ser, dtype=ser.dtype)
 1276:         tm.assert_series_equal(result, ser)
 1277: 
 1278:         result = Series(ser.dt.tz_convert("UTC"), dtype=ser.dtype)
 1279:         tm.assert_series_equal(result, ser)
 1280: 
 1281:         # Pre-2.0 dt64 values were treated as utc, which was inconsistent
 1282:         #  with DatetimeIndex, which treats them as wall times, see GH#33401
 1283:         result = Series(ser.values, dtype=ser.dtype)
 1284:         expected = Series(ser.values).dt.tz_localize(ser.dtype.tz)
 1285:         tm.assert_series_equal(result, expected)
 1286: 
 1287:         with tm.assert_produces_warning(None):
 1288:             # one suggested alternative to the deprecated (changed in 2.0) usage
 1289:             middle = Series(ser.values).dt.tz_localize("UTC")
 1290:             result = middle.dt.tz_convert(ser.dtype.tz)
 1291:         tm.assert_series_equal(result, ser)
 1292: 
 1293:         with tm.assert_produces_warning(None):
 1294:             # the other suggested alternative to the deprecated usage
 1295:             result = Series(ser.values.view("int64"), dtype=ser.dtype)
 1296:         tm.assert_series_equal(result, ser)
 1297: 
 1298:     @pytest.mark.parametrize(
 1299:         "data_constructor", [list, np.array], ids=["list", "ndarray[object]"]
 1300:     )
 1301:     def test_constructor_infer_period(self, data_constructor):
 1302:         data = [Period("2000", "D"), Period("2001", "D"), None]
 1303:         result = Series(data_constructor(data))
 1304:         expected = Series(period_array(data))
 1305:         tm.assert_series_equal(result, expected)
 1306:         assert result.dtype == "Period[D]"
 1307: 
 1308:     @pytest.mark.xfail(reason="PeriodDtype Series not supported yet")
 1309:     def test_construct_from_ints_including_iNaT_scalar_period_dtype(self):
 1310:         series = Series([0, 1000, 2000, pd._libs.iNaT], dtype="period[D]")
 1311: 
 1312:         val = series[3]
 1313:         assert isna(val)
 1314: 
 1315:         series[2] = val
 1316:         assert isna(series[2])
 1317: 
 1318:     def test_constructor_period_incompatible_frequency(self):
 1319:         data = [Period("2000", "D"), Period("2001", "Y")]
 1320:         result = Series(data)
 1321:         assert result.dtype == object
 1322:         assert result.tolist() == data
 1323: 
 1324:     def test_constructor_periodindex(self):
 1325:         # GH7932
 1326:         # converting a PeriodIndex when put in a Series
 1327: 
 1328:         pi = period_range("20130101", periods=5, freq="D")
 1329:         s = Series(pi)
 1330:         assert s.dtype == "Period[D]"
 1331:         with tm.assert_produces_warning(FutureWarning, match="Dtype inference"):
 1332:             expected = Series(pi.astype(object))
 1333:         tm.assert_series_equal(s, expected)
 1334: 
 1335:     def test_constructor_dict(self):
 1336:         d = {"a": 0.0, "b": 1.0, "c": 2.0}
 1337: 
 1338:         result = Series(d)
 1339:         expected = Series(d, index=sorted(d.keys()))
 1340:         tm.assert_series_equal(result, expected)
 1341: 
 1342:         result = Series(d, index=["b", "c", "d", "a"])
 1343:         expected = Series([1, 2, np.nan, 0], index=["b", "c", "d", "a"])
 1344:         tm.assert_series_equal(result, expected)
 1345: 
 1346:         pidx = period_range("2020-01-01", periods=10, freq="D")
 1347:         d = {pidx[0]: 0, pidx[1]: 1}
 1348:         result = Series(d, index=pidx)
 1349:         expected = Series(np.nan, pidx, dtype=np.float64)
 1350:         expected.iloc[0] = 0
 1351:         expected.iloc[1] = 1
 1352:         tm.assert_series_equal(result, expected)
 1353: 
 1354:     def test_constructor_dict_list_value_explicit_dtype(self):
 1355:         # GH 18625
 1356:         d = {"a": [[2], [3], [4]]}
 1357:         result = Series(d, index=["a"], dtype="object")
 1358:         expected = Series(d, index=["a"])
 1359:         tm.assert_series_equal(result, expected)
 1360: 
 1361:     def test_constructor_dict_order(self):
 1362:         # GH19018
 1363:         # initialization ordering: by insertion order
 1364:         d = {"b": 1, "a": 0, "c": 2}
 1365:         result = Series(d)
 1366:         expected = Series([1, 0, 2], index=list("bac"))
 1367:         tm.assert_series_equal(result, expected)
 1368: 
 1369:     def test_constructor_dict_extension(self, ea_scalar_and_dtype, request):
 1370:         ea_scalar, ea_dtype = ea_scalar_and_dtype
 1371:         if isinstance(ea_scalar, Timestamp):
 1372:             mark = pytest.mark.xfail(
 1373:                 reason="Construction from dict goes through "
 1374:                 "maybe_convert_objects which casts to nano"
 1375:             )
 1376:             request.applymarker(mark)
 1377:         d = {"a": ea_scalar}
 1378:         result = Series(d, index=["a"])
 1379:         expected = Series(ea_scalar, index=["a"], dtype=ea_dtype)
 1380: 
 1381:         assert result.dtype == ea_dtype
 1382: 
 1383:         tm.assert_series_equal(result, expected)
 1384: 
 1385:     @pytest.mark.parametrize("value", [2, np.nan, None, float("nan")])
 1386:     def test_constructor_dict_nan_key(self, value):
 1387:         # GH 18480
 1388:         d = {1: "a", value: "b", float("nan"): "c", 4: "d"}
 1389:         result = Series(d).sort_values()
 1390:         expected = Series(["a", "b", "c", "d"], index=[1, value, np.nan, 4])
 1391:         tm.assert_series_equal(result, expected)
 1392: 
 1393:         # MultiIndex:
 1394:         d = {(1, 1): "a", (2, np.nan): "b", (3, value): "c"}
 1395:         result = Series(d).sort_values()
 1396:         expected = Series(
 1397:             ["a", "b", "c"], index=Index([(1, 1), (2, np.nan), (3, value)])
 1398:         )
 1399:         tm.assert_series_equal(result, expected)
 1400: 
 1401:     def test_constructor_dict_datetime64_index(self):
 1402:         # GH 9456
 1403: 
 1404:         dates_as_str = ["1984-02-19", "1988-11-06", "1989-12-03", "1990-03-15"]
 1405:         values = [42544017.198965244, 1234565, 40512335.181958228, -1]
 1406: 
 1407:         def create_data(constructor):
 1408:             return dict(zip((constructor(x) for x in dates_as_str), values))
 1409: 
 1410:         data_datetime64 = create_data(np.datetime64)
 1411:         data_datetime = create_data(lambda x: datetime.strptime(x, "%Y-%m-%d"))
 1412:         data_Timestamp = create_data(Timestamp)
 1413: 
 1414:         expected = Series(values, (Timestamp(x) for x in dates_as_str))
 1415: 
 1416:         result_datetime64 = Series(data_datetime64)
 1417:         result_datetime = Series(data_datetime)
 1418:         result_Timestamp = Series(data_Timestamp)
 1419: 
 1420:         tm.assert_series_equal(result_datetime64, expected)
 1421:         tm.assert_series_equal(result_datetime, expected)
 1422:         tm.assert_series_equal(result_Timestamp, expected)
 1423: 
 1424:     def test_constructor_dict_tuple_indexer(self):
 1425:         # GH 12948
 1426:         data = {(1, 1, None): -1.0}
 1427:         result = Series(data)
 1428:         expected = Series(
 1429:             -1.0, index=MultiIndex(levels=[[1], [1], [np.nan]], codes=[[0], [0], [-1]])
 1430:         )
 1431:         tm.assert_series_equal(result, expected)
 1432: 
 1433:     def test_constructor_mapping(self, non_dict_mapping_subclass):
 1434:         # GH 29788
 1435:         ndm = non_dict_mapping_subclass({3: "three"})
 1436:         result = Series(ndm)
 1437:         expected = Series(["three"], index=[3])
 1438: 
 1439:         tm.assert_series_equal(result, expected)
 1440: 
 1441:     def test_constructor_list_of_tuples(self):
 1442:         data = [(1, 1), (2, 2), (2, 3)]
 1443:         s = Series(data)
 1444:         assert list(s) == data
 1445: 
 1446:     def test_constructor_tuple_of_tuples(self):
 1447:         data = ((1, 1), (2, 2), (2, 3))
 1448:         s = Series(data)
 1449:         assert tuple(s) == data
 1450: 
 1451:     def test_constructor_dict_of_tuples(self):
 1452:         data = {(1, 2): 3, (None, 5): 6}
 1453:         result = Series(data).sort_values()
 1454:         expected = Series([3, 6], index=MultiIndex.from_tuples([(1, 2), (None, 5)]))
 1455:         tm.assert_series_equal(result, expected)
 1456: 
 1457:     # https://github.com/pandas-dev/pandas/issues/22698
 1458:     @pytest.mark.filterwarnings("ignore:elementwise comparison:FutureWarning")
 1459:     def test_fromDict(self, using_infer_string):
 1460:         data = {"a": 0, "b": 1, "c": 2, "d": 3}
 1461: 
 1462:         series = Series(data)
 1463:         tm.assert_is_sorted(series.index)
 1464: 
 1465:         data = {"a": 0, "b": "1", "c": "2", "d": datetime.now()}
 1466:         series = Series(data)
 1467:         assert series.dtype == np.object_
 1468: 
 1469:         data = {"a": 0, "b": "1", "c": "2", "d": "3"}
 1470:         series = Series(data)
 1471:         assert series.dtype == np.object_ if not using_infer_string else "string"
 1472: 
 1473:         data = {"a": "0", "b": "1"}
 1474:         series = Series(data, dtype=float)
 1475:         assert series.dtype == np.float64
 1476: 
 1477:     def test_fromValue(self, datetime_series, using_infer_string):
 1478:         nans = Series(np.nan, index=datetime_series.index, dtype=np.float64)
 1479:         assert nans.dtype == np.float64
 1480:         assert len(nans) == len(datetime_series)
 1481: 
 1482:         strings = Series("foo", index=datetime_series.index)
 1483:         assert strings.dtype == np.object_ if not using_infer_string else "string"
 1484:         assert len(strings) == len(datetime_series)
 1485: 
 1486:         d = datetime.now()
 1487:         dates = Series(d, index=datetime_series.index)
 1488:         assert dates.dtype == "M8[us]"
 1489:         assert len(dates) == len(datetime_series)
 1490: 
 1491:         # GH12336
 1492:         # Test construction of categorical series from value
 1493:         categorical = Series(0, index=datetime_series.index, dtype="category")
 1494:         expected = Series(0, index=datetime_series.index).astype("category")
 1495:         assert categorical.dtype == "category"
 1496:         assert len(categorical) == len(datetime_series)
 1497:         tm.assert_series_equal(categorical, expected)
 1498: 
 1499:     def test_constructor_dtype_timedelta64(self):
 1500:         # basic
 1501:         td = Series([timedelta(days=i) for i in range(3)])
 1502:         assert td.dtype == "timedelta64[ns]"
 1503: 
 1504:         td = Series([timedelta(days=1)])
 1505:         assert td.dtype == "timedelta64[ns]"
 1506: 
 1507:         td = Series([timedelta(days=1), timedelta(days=2), np.timedelta64(1, "s")])
 1508: 
 1509:         assert td.dtype == "timedelta64[ns]"
 1510: 
 1511:         # mixed with NaT
 1512:         td = Series([timedelta(days=1), NaT], dtype="m8[ns]")
 1513:         assert td.dtype == "timedelta64[ns]"
 1514: 
 1515:         td = Series([timedelta(days=1), np.nan], dtype="m8[ns]")
 1516:         assert td.dtype == "timedelta64[ns]"
 1517: 
 1518:         td = Series([np.timedelta64(300000000), NaT], dtype="m8[ns]")
 1519:         assert td.dtype == "timedelta64[ns]"
 1520: 
 1521:         # improved inference
 1522:         # GH5689
 1523:         td = Series([np.timedelta64(300000000), NaT])
 1524:         assert td.dtype == "timedelta64[ns]"
 1525: 
 1526:         # because iNaT is int, not coerced to timedelta
 1527:         td = Series([np.timedelta64(300000000), iNaT])
 1528:         assert td.dtype == "object"
 1529: 
 1530:         td = Series([np.timedelta64(300000000), np.nan])
 1531:         assert td.dtype == "timedelta64[ns]"
 1532: 
 1533:         td = Series([NaT, np.timedelta64(300000000)])
 1534:         assert td.dtype == "timedelta64[ns]"
 1535: 
 1536:         td = Series([np.timedelta64(1, "s")])
 1537:         assert td.dtype == "timedelta64[ns]"
 1538: 
 1539:         # valid astype
 1540:         td.astype("int64")
 1541: 
 1542:         # invalid casting
 1543:         msg = r"Converting from timedelta64\[ns\] to int32 is not supported"
 1544:         with pytest.raises(TypeError, match=msg):
 1545:             td.astype("int32")
 1546: 
 1547:         # this is an invalid casting
 1548:         msg = "|".join(
 1549:             [
 1550:                 "Could not convert object to NumPy timedelta",
 1551:                 "Could not convert 'foo' to NumPy timedelta",
 1552:             ]
 1553:         )
 1554:         with pytest.raises(ValueError, match=msg):
 1555:             Series([timedelta(days=1), "foo"], dtype="m8[ns]")
 1556: 
 1557:         # leave as object here
 1558:         td = Series([timedelta(days=i) for i in range(3)] + ["foo"])
 1559:         assert td.dtype == "object"
 1560: 
 1561:         # as of 2.0, these no longer infer timedelta64 based on the strings,
 1562:         #  matching Index behavior
 1563:         ser = Series([None, NaT, "1 Day"])
 1564:         assert ser.dtype == object
 1565: 
 1566:         ser = Series([np.nan, NaT, "1 Day"])
 1567:         assert ser.dtype == object
 1568: 
 1569:         ser = Series([NaT, None, "1 Day"])
 1570:         assert ser.dtype == object
 1571: 
 1572:         ser = Series([NaT, np.nan, "1 Day"])
 1573:         assert ser.dtype == object
 1574: 
 1575:     # GH 16406
 1576:     def test_constructor_mixed_tz(self):
 1577:         s = Series([Timestamp("20130101"), Timestamp("20130101", tz="US/Eastern")])
 1578:         expected = Series(
 1579:             [Timestamp("20130101"), Timestamp("20130101", tz="US/Eastern")],
 1580:             dtype="object",
 1581:         )
 1582:         tm.assert_series_equal(s, expected)
 1583: 
 1584:     def test_NaT_scalar(self):
 1585:         series = Series([0, 1000, 2000, iNaT], dtype="M8[ns]")
 1586: 
 1587:         val = series[3]
 1588:         assert isna(val)
 1589: 
 1590:         series[2] = val
 1591:         assert isna(series[2])
 1592: 
 1593:     def test_NaT_cast(self):
 1594:         # GH10747
 1595:         result = Series([np.nan]).astype("M8[ns]")
 1596:         expected = Series([NaT], dtype="M8[ns]")
 1597:         tm.assert_series_equal(result, expected)
 1598: 
 1599:     def test_constructor_name_hashable(self):
 1600:         for n in [777, 777.0, "name", datetime(2001, 11, 11), (1,), "\u05D0"]:
 1601:             for data in [[1, 2, 3], np.ones(3), {"a": 0, "b": 1}]:
 1602:                 s = Series(data, name=n)
 1603:                 assert s.name == n
 1604: 
 1605:     def test_constructor_name_unhashable(self):
 1606:         msg = r"Series\.name must be a hashable type"
 1607:         for n in [["name_list"], np.ones(2), {1: 2}]:
 1608:             for data in [["name_list"], np.ones(2), {1: 2}]:
 1609:                 with pytest.raises(TypeError, match=msg):
 1610:                     Series(data, name=n)
 1611: 
 1612:     def test_auto_conversion(self):
 1613:         series = Series(list(date_range("1/1/2000", periods=10)))
 1614:         assert series.dtype == "M8[ns]"
 1615: 
 1616:     def test_convert_non_ns(self):
 1617:         # convert from a numpy array of non-ns timedelta64
 1618:         arr = np.array([1, 2, 3], dtype="timedelta64[s]")
 1619:         ser = Series(arr)
 1620:         assert ser.dtype == arr.dtype
 1621: 
 1622:         tdi = timedelta_range("00:00:01", periods=3, freq="s").as_unit("s")
 1623:         expected = Series(tdi)
 1624:         assert expected.dtype == arr.dtype
 1625:         tm.assert_series_equal(ser, expected)
 1626: 
 1627:         # convert from a numpy array of non-ns datetime64
 1628:         arr = np.array(
 1629:             ["2013-01-01", "2013-01-02", "2013-01-03"], dtype="datetime64[D]"
 1630:         )
 1631:         ser = Series(arr)
 1632:         expected = Series(date_range("20130101", periods=3, freq="D"), dtype="M8[s]")
 1633:         assert expected.dtype == "M8[s]"
 1634:         tm.assert_series_equal(ser, expected)
 1635: 
 1636:         arr = np.array(
 1637:             ["2013-01-01 00:00:01", "2013-01-01 00:00:02", "2013-01-01 00:00:03"],
 1638:             dtype="datetime64[s]",
 1639:         )
 1640:         ser = Series(arr)
 1641:         expected = Series(
 1642:             date_range("20130101 00:00:01", periods=3, freq="s"), dtype="M8[s]"
 1643:         )
 1644:         assert expected.dtype == "M8[s]"
 1645:         tm.assert_series_equal(ser, expected)
 1646: 
 1647:     @pytest.mark.parametrize(
 1648:         "index",
 1649:         [
 1650:             date_range("1/1/2000", periods=10),
 1651:             timedelta_range("1 day", periods=10),
 1652:             period_range("2000-Q1", periods=10, freq="Q"),
 1653:         ],
 1654:         ids=lambda x: type(x).__name__,
 1655:     )
 1656:     def test_constructor_cant_cast_datetimelike(self, index):
 1657:         # floats are not ok
 1658:         # strip Index to convert PeriodIndex -> Period
 1659:         # We don't care whether the error message says
 1660:         # PeriodIndex or PeriodArray
 1661:         msg = f"Cannot cast {type(index).__name__.rstrip('Index')}.*? to "
 1662: 
 1663:         with pytest.raises(TypeError, match=msg):
 1664:             Series(index, dtype=float)
 1665: 
 1666:         # ints are ok
 1667:         # we test with np.int64 to get similar results on
 1668:         # windows / 32-bit platforms
 1669:         result = Series(index, dtype=np.int64)
 1670:         expected = Series(index.astype(np.int64))
 1671:         tm.assert_series_equal(result, expected)
 1672: 
 1673:     @pytest.mark.parametrize(
 1674:         "index",
 1675:         [
 1676:             date_range("1/1/2000", periods=10),
 1677:             timedelta_range("1 day", periods=10),
 1678:             period_range("2000-Q1", periods=10, freq="Q"),
 1679:         ],
 1680:         ids=lambda x: type(x).__name__,
 1681:     )
 1682:     def test_constructor_cast_object(self, index):
 1683:         s = Series(index, dtype=object)
 1684:         exp = Series(index).astype(object)
 1685:         tm.assert_series_equal(s, exp)
 1686: 
 1687:         s = Series(Index(index, dtype=object), dtype=object)
 1688:         exp = Series(index).astype(object)
 1689:         tm.assert_series_equal(s, exp)
 1690: 
 1691:         s = Series(index.astype(object), dtype=object)
 1692:         exp = Series(index).astype(object)
 1693:         tm.assert_series_equal(s, exp)
 1694: 
 1695:     @pytest.mark.parametrize("dtype", [np.datetime64, np.timedelta64])
 1696:     def test_constructor_generic_timestamp_no_frequency(self, dtype, request):
 1697:         # see gh-15524, gh-15987
 1698:         msg = "dtype has no unit. Please pass in"
 1699: 
 1700:         if np.dtype(dtype).name not in ["timedelta64", "datetime64"]:
 1701:             mark = pytest.mark.xfail(reason="GH#33890 Is assigned ns unit")
 1702:             request.applymarker(mark)
 1703: 
 1704:         with pytest.raises(ValueError, match=msg):
 1705:             Series([], dtype=dtype)
 1706: 
 1707:     @pytest.mark.parametrize("unit", ["ps", "as", "fs", "Y", "M", "W", "D", "h", "m"])
 1708:     @pytest.mark.parametrize("kind", ["m", "M"])
 1709:     def test_constructor_generic_timestamp_bad_frequency(self, kind, unit):
 1710:         # see gh-15524, gh-15987
 1711:         # as of 2.0 we raise on any non-supported unit rather than silently
 1712:         #  cast to nanos; previously we only raised for frequencies higher
 1713:         #  than ns
 1714:         dtype = f"{kind}8[{unit}]"
 1715: 
 1716:         msg = "dtype=.* is not supported. Supported resolutions are"
 1717:         with pytest.raises(TypeError, match=msg):
 1718:             Series([], dtype=dtype)
 1719: 
 1720:         with pytest.raises(TypeError, match=msg):
 1721:             # pre-2.0 the DataFrame cast raised but the Series case did not
 1722:             DataFrame([[0]], dtype=dtype)
 1723: 
 1724:     @pytest.mark.parametrize("dtype", [None, "uint8", "category"])
 1725:     def test_constructor_range_dtype(self, dtype):
 1726:         # GH 16804
 1727:         expected = Series([0, 1, 2, 3, 4], dtype=dtype or "int64")
 1728:         result = Series(range(5), dtype=dtype)
 1729:         tm.assert_series_equal(result, expected)
 1730: 
 1731:     def test_constructor_range_overflows(self):
 1732:         # GH#30173 range objects that overflow int64
 1733:         rng = range(2**63, 2**63 + 4)
 1734:         ser = Series(rng)
 1735:         expected = Series(list(rng))
 1736:         tm.assert_series_equal(ser, expected)
 1737:         assert list(ser) == list(rng)
 1738:         assert ser.dtype == np.uint64
 1739: 
 1740:         rng2 = range(2**63 + 4, 2**63, -1)
 1741:         ser2 = Series(rng2)
 1742:         expected2 = Series(list(rng2))
 1743:         tm.assert_series_equal(ser2, expected2)
 1744:         assert list(ser2) == list(rng2)
 1745:         assert ser2.dtype == np.uint64
 1746: 
 1747:         rng3 = range(-(2**63), -(2**63) - 4, -1)
 1748:         ser3 = Series(rng3)
 1749:         expected3 = Series(list(rng3))
 1750:         tm.assert_series_equal(ser3, expected3)
 1751:         assert list(ser3) == list(rng3)
 1752:         assert ser3.dtype == object
 1753: 
 1754:         rng4 = range(2**73, 2**73 + 4)
 1755:         ser4 = Series(rng4)
 1756:         expected4 = Series(list(rng4))
 1757:         tm.assert_series_equal(ser4, expected4)
 1758:         assert list(ser4) == list(rng4)
 1759:         assert ser4.dtype == object
 1760: 
 1761:     def test_constructor_tz_mixed_data(self):
 1762:         # GH 13051
 1763:         dt_list = [
 1764:             Timestamp("2016-05-01 02:03:37"),
 1765:             Timestamp("2016-04-30 19:03:37-0700", tz="US/Pacific"),
 1766:         ]
 1767:         result = Series(dt_list)
 1768:         expected = Series(dt_list, dtype=object)
 1769:         tm.assert_series_equal(result, expected)
 1770: 
 1771:     @pytest.mark.parametrize("pydt", [True, False])
 1772:     def test_constructor_data_aware_dtype_naive(self, tz_aware_fixture, pydt):
 1773:         # GH#25843, GH#41555, GH#33401
 1774:         tz = tz_aware_fixture
 1775:         ts = Timestamp("2019", tz=tz)
 1776:         if pydt:
 1777:             ts = ts.to_pydatetime()
 1778: 
 1779:         msg = (
 1780:             "Cannot convert timezone-aware data to timezone-naive dtype. "
 1781:             r"Use pd.Series\(values\).dt.tz_localize\(None\) instead."
 1782:         )
 1783:         with pytest.raises(ValueError, match=msg):
 1784:             Series([ts], dtype="datetime64[ns]")
 1785: 
 1786:         with pytest.raises(ValueError, match=msg):
 1787:             Series(np.array([ts], dtype=object), dtype="datetime64[ns]")
 1788: 
 1789:         with pytest.raises(ValueError, match=msg):
 1790:             Series({0: ts}, dtype="datetime64[ns]")
 1791: 
 1792:         msg = "Cannot unbox tzaware Timestamp to tznaive dtype"
 1793:         with pytest.raises(TypeError, match=msg):
 1794:             Series(ts, index=[0], dtype="datetime64[ns]")
 1795: 
 1796:     def test_constructor_datetime64(self):
 1797:         rng = date_range("1/1/2000 00:00:00", "1/1/2000 1:59:50", freq="10s")
 1798:         dates = np.asarray(rng)
 1799: 
 1800:         series = Series(dates)
 1801:         assert np.issubdtype(series.dtype, np.dtype("M8[ns]"))
 1802: 
 1803:     def test_constructor_datetimelike_scalar_to_string_dtype(
 1804:         self, nullable_string_dtype
 1805:     ):
 1806:         # https://github.com/pandas-dev/pandas/pull/33846
 1807:         result = Series("M", index=[1, 2, 3], dtype=nullable_string_dtype)
 1808:         expected = Series(["M", "M", "M"], index=[1, 2, 3], dtype=nullable_string_dtype)
 1809:         tm.assert_series_equal(result, expected)
 1810: 
 1811:     @pytest.mark.parametrize(
 1812:         "values",
 1813:         [
 1814:             [np.datetime64("2012-01-01"), np.datetime64("2013-01-01")],
 1815:             ["2012-01-01", "2013-01-01"],
 1816:         ],
 1817:     )
 1818:     def test_constructor_sparse_datetime64(self, values):
 1819:         # https://github.com/pandas-dev/pandas/issues/35762
 1820:         dtype = pd.SparseDtype("datetime64[ns]")
 1821:         result = Series(values, dtype=dtype)
 1822:         arr = pd.arrays.SparseArray(values, dtype=dtype)
 1823:         expected = Series(arr)
 1824:         tm.assert_series_equal(result, expected)
 1825: 
 1826:     def test_construction_from_ordered_collection(self):
 1827:         # https://github.com/pandas-dev/pandas/issues/36044
 1828:         result = Series({"a": 1, "b": 2}.keys())
 1829:         expected = Series(["a", "b"])
 1830:         tm.assert_series_equal(result, expected)
 1831: 
 1832:         result = Series({"a": 1, "b": 2}.values())
 1833:         expected = Series([1, 2])
 1834:         tm.assert_series_equal(result, expected)
 1835: 
 1836:     def test_construction_from_large_int_scalar_no_overflow(self):
 1837:         # https://github.com/pandas-dev/pandas/issues/36291
 1838:         n = 1_000_000_000_000_000_000_000
 1839:         result = Series(n, index=[0])
 1840:         expected = Series(n)
 1841:         tm.assert_series_equal(result, expected)
 1842: 
 1843:     def test_constructor_list_of_periods_infers_period_dtype(self):
 1844:         series = Series(list(period_range("2000-01-01", periods=10, freq="D")))
 1845:         assert series.dtype == "Period[D]"
 1846: 
 1847:         series = Series(
 1848:             [Period("2011-01-01", freq="D"), Period("2011-02-01", freq="D")]
 1849:         )
 1850:         assert series.dtype == "Period[D]"
 1851: 
 1852:     def test_constructor_subclass_dict(self, dict_subclass):
 1853:         data = dict_subclass((x, 10.0 * x) for x in range(10))
 1854:         series = Series(data)
 1855:         expected = Series(dict(data.items()))
 1856:         tm.assert_series_equal(series, expected)
 1857: 
 1858:     def test_constructor_ordereddict(self):
 1859:         # GH3283
 1860:         data = OrderedDict(
 1861:             (f"col{i}", np.random.default_rng(2).random()) for i in range(12)
 1862:         )
 1863: 
 1864:         series = Series(data)
 1865:         expected = Series(list(data.values()), list(data.keys()))
 1866:         tm.assert_series_equal(series, expected)
 1867: 
 1868:         # Test with subclass
 1869:         class A(OrderedDict):
 1870:             pass
 1871: 
 1872:         series = Series(A(data))
 1873:         tm.assert_series_equal(series, expected)
 1874: 
 1875:     def test_constructor_dict_multiindex(self):
 1876:         d = {("a", "a"): 0.0, ("b", "a"): 1.0, ("b", "c"): 2.0}
 1877:         _d = sorted(d.items())
 1878:         result = Series(d)
 1879:         expected = Series(
 1880:             [x[1] for x in _d], index=MultiIndex.from_tuples([x[0] for x in _d])
 1881:         )
 1882:         tm.assert_series_equal(result, expected)
 1883: 
 1884:         d["z"] = 111.0
 1885:         _d.insert(0, ("z", d["z"]))
 1886:         result = Series(d)
 1887:         expected = Series(
 1888:             [x[1] for x in _d], index=Index([x[0] for x in _d], tupleize_cols=False)
 1889:         )
 1890:         result = result.reindex(index=expected.index)
 1891:         tm.assert_series_equal(result, expected)
 1892: 
 1893:     def test_constructor_dict_multiindex_reindex_flat(self):
 1894:         # construction involves reindexing with a MultiIndex corner case
 1895:         data = {("i", "i"): 0, ("i", "j"): 1, ("j", "i"): 2, "j": np.nan}
 1896:         expected = Series(data)
 1897: 
 1898:         result = Series(expected[:-1].to_dict(), index=expected.index)
 1899:         tm.assert_series_equal(result, expected)
 1900: 
 1901:     def test_constructor_dict_timedelta_index(self):
 1902:         # GH #12169 : Resample category data with timedelta index
 1903:         # construct Series from dict as data and TimedeltaIndex as index
 1904:         # will result NaN in result Series data
 1905:         expected = Series(
 1906:             data=["A", "B", "C"], index=pd.to_timedelta([0, 10, 20], unit="s")
 1907:         )
 1908: 
 1909:         result = Series(
 1910:             data={
 1911:                 pd.to_timedelta(0, unit="s"): "A",
 1912:                 pd.to_timedelta(10, unit="s"): "B",
 1913:                 pd.to_timedelta(20, unit="s"): "C",
 1914:             },
 1915:             index=pd.to_timedelta([0, 10, 20], unit="s"),
 1916:         )
 1917:         tm.assert_series_equal(result, expected)
 1918: 
 1919:     def test_constructor_infer_index_tz(self):
 1920:         values = [188.5, 328.25]
 1921:         tzinfo = tzoffset(None, 7200)
 1922:         index = [
 1923:             datetime(2012, 5, 11, 11, tzinfo=tzinfo),
 1924:             datetime(2012, 5, 11, 12, tzinfo=tzinfo),
 1925:         ]
 1926:         series = Series(data=values, index=index)
 1927: 
 1928:         assert series.index.tz == tzinfo
 1929: 
 1930:         # it works! GH#2443
 1931:         repr(series.index[0])
 1932: 
 1933:     def test_constructor_with_pandas_dtype(self):
 1934:         # going through 2D->1D path
 1935:         vals = [(1,), (2,), (3,)]
 1936:         ser = Series(vals)
 1937:         dtype = ser.array.dtype  # NumpyEADtype
 1938:         ser2 = Series(vals, dtype=dtype)
 1939:         tm.assert_series_equal(ser, ser2)
 1940: 
 1941:     def test_constructor_int_dtype_missing_values(self):
 1942:         # GH#43017
 1943:         result = Series(index=[0], dtype="int64")
 1944:         expected = Series(np.nan, index=[0], dtype="float64")
 1945:         tm.assert_series_equal(result, expected)
 1946: 
 1947:     def test_constructor_bool_dtype_missing_values(self):
 1948:         # GH#43018
 1949:         result = Series(index=[0], dtype="bool")
 1950:         expected = Series(True, index=[0], dtype="bool")
 1951:         tm.assert_series_equal(result, expected)
 1952: 
 1953:     def test_constructor_int64_dtype(self, any_int_dtype):
 1954:         # GH#44923
 1955:         result = Series(["0", "1", "2"], dtype=any_int_dtype)
 1956:         expected = Series([0, 1, 2], dtype=any_int_dtype)
 1957:         tm.assert_series_equal(result, expected)
 1958: 
 1959:     def test_constructor_raise_on_lossy_conversion_of_strings(self):
 1960:         # GH#44923
 1961:         if not np_version_gt2:
 1962:             raises = pytest.raises(
 1963:                 ValueError, match="string values cannot be losslessly cast to int8"
 1964:             )
 1965:         else:
 1966:             raises = pytest.raises(
 1967:                 OverflowError, match="The elements provided in the data"
 1968:             )
 1969:         with raises:
 1970:             Series(["128"], dtype="int8")
 1971: 
 1972:     def test_constructor_dtype_timedelta_alternative_construct(self):
 1973:         # GH#35465
 1974:         result = Series([1000000, 200000, 3000000], dtype="timedelta64[ns]")
 1975:         expected = Series(pd.to_timedelta([1000000, 200000, 3000000], unit="ns"))
 1976:         tm.assert_series_equal(result, expected)
 1977: 
 1978:     @pytest.mark.xfail(
 1979:         reason="Not clear what the correct expected behavior should be with "
 1980:         "integers now that we support non-nano. ATM (2022-10-08) we treat ints "
 1981:         "as nanoseconds, then cast to the requested dtype. xref #48312"
 1982:     )
 1983:     def test_constructor_dtype_timedelta_ns_s(self):
 1984:         # GH#35465
 1985:         result = Series([1000000, 200000, 3000000], dtype="timedelta64[ns]")
 1986:         expected = Series([1000000, 200000, 3000000], dtype="timedelta64[s]")
 1987:         tm.assert_series_equal(result, expected)
 1988: 
 1989:     @pytest.mark.xfail(
 1990:         reason="Not clear what the correct expected behavior should be with "
 1991:         "integers now that we support non-nano. ATM (2022-10-08) we treat ints "
 1992:         "as nanoseconds, then cast to the requested dtype. xref #48312"
 1993:     )
 1994:     def test_constructor_dtype_timedelta_ns_s_astype_int64(self):
 1995:         # GH#35465
 1996:         result = Series([1000000, 200000, 3000000], dtype="timedelta64[ns]").astype(
 1997:             "int64"
 1998:         )
 1999:         expected = Series([1000000, 200000, 3000000], dtype="timedelta64[s]").astype(
 2000:             "int64"
 2001:         )
 2002:         tm.assert_series_equal(result, expected)
 2003: 
 2004:     @pytest.mark.filterwarnings(
 2005:         "ignore:elementwise comparison failed:DeprecationWarning"
 2006:     )
 2007:     @pytest.mark.parametrize("func", [Series, DataFrame, Index, pd.array])
 2008:     def test_constructor_mismatched_null_nullable_dtype(
 2009:         self, func, any_numeric_ea_dtype
 2010:     ):
 2011:         # GH#44514
 2012:         msg = "|".join(
 2013:             [
 2014:                 "cannot safely cast non-equivalent object",
 2015:                 r"int\(\) argument must be a string, a bytes-like object "
 2016:                 "or a (real )?number",
 2017:                 r"Cannot cast array data from dtype\('O'\) to dtype\('float64'\) "
 2018:                 "according to the rule 'safe'",
 2019:                 "object cannot be converted to a FloatingDtype",
 2020:                 "'values' contains non-numeric NA",
 2021:             ]
 2022:         )
 2023: 
 2024:         for null in tm.NP_NAT_OBJECTS + [NaT]:
 2025:             with pytest.raises(TypeError, match=msg):
 2026:                 func([null, 1.0, 3.0], dtype=any_numeric_ea_dtype)
 2027: 
 2028:     def test_series_constructor_ea_int_from_bool(self):
 2029:         # GH#42137
 2030:         result = Series([True, False, True, pd.NA], dtype="Int64")
 2031:         expected = Series([1, 0, 1, pd.NA], dtype="Int64")
 2032:         tm.assert_series_equal(result, expected)
 2033: 
 2034:         result = Series([True, False, True], dtype="Int64")
 2035:         expected = Series([1, 0, 1], dtype="Int64")
 2036:         tm.assert_series_equal(result, expected)
 2037: 
 2038:     def test_series_constructor_ea_int_from_string_bool(self):
 2039:         # GH#42137
 2040:         with pytest.raises(ValueError, match="invalid literal"):
 2041:             Series(["True", "False", "True", pd.NA], dtype="Int64")
 2042: 
 2043:     @pytest.mark.parametrize("val", [1, 1.0])
 2044:     def test_series_constructor_overflow_uint_ea(self, val):
 2045:         # GH#38798
 2046:         max_val = np.iinfo(np.uint64).max - 1
 2047:         result = Series([max_val, val], dtype="UInt64")
 2048:         expected = Series(np.array([max_val, 1], dtype="uint64"), dtype="UInt64")
 2049:         tm.assert_series_equal(result, expected)
 2050: 
 2051:     @pytest.mark.parametrize("val", [1, 1.0])
 2052:     def test_series_constructor_overflow_uint_ea_with_na(self, val):
 2053:         # GH#38798
 2054:         max_val = np.iinfo(np.uint64).max - 1
 2055:         result = Series([max_val, val, pd.NA], dtype="UInt64")
 2056:         expected = Series(
 2057:             IntegerArray(
 2058:                 np.array([max_val, 1, 0], dtype="uint64"),
 2059:                 np.array([0, 0, 1], dtype=np.bool_),
 2060:             )
 2061:         )
 2062:         tm.assert_series_equal(result, expected)
 2063: 
 2064:     def test_series_constructor_overflow_uint_with_nan(self):
 2065:         # GH#38798
 2066:         max_val = np.iinfo(np.uint64).max - 1
 2067:         result = Series([max_val, np.nan], dtype="UInt64")
 2068:         expected = Series(
 2069:             IntegerArray(
 2070:                 np.array([max_val, 1], dtype="uint64"),
 2071:                 np.array([0, 1], dtype=np.bool_),
 2072:             )
 2073:         )
 2074:         tm.assert_series_equal(result, expected)
 2075: 
 2076:     def test_series_constructor_ea_all_na(self):
 2077:         # GH#38798
 2078:         result = Series([np.nan, np.nan], dtype="UInt64")
 2079:         expected = Series(
 2080:             IntegerArray(
 2081:                 np.array([1, 1], dtype="uint64"),
 2082:                 np.array([1, 1], dtype=np.bool_),
 2083:             )
 2084:         )
 2085:         tm.assert_series_equal(result, expected)
 2086: 
 2087:     def test_series_from_index_dtype_equal_does_not_copy(self):
 2088:         # GH#52008
 2089:         idx = Index([1, 2, 3])
 2090:         expected = idx.copy(deep=True)
 2091:         ser = Series(idx, dtype="int64")
 2092:         ser.iloc[0] = 100
 2093:         tm.assert_index_equal(idx, expected)
 2094: 
 2095:     def test_series_string_inference(self):
 2096:         # GH#54430
 2097:         pytest.importorskip("pyarrow")
 2098:         dtype = "string[pyarrow_numpy]"
 2099:         expected = Series(["a", "b"], dtype=dtype)
 2100:         with pd.option_context("future.infer_string", True):
 2101:             ser = Series(["a", "b"])
 2102:         tm.assert_series_equal(ser, expected)
 2103: 
 2104:         expected = Series(["a", 1], dtype="object")
 2105:         with pd.option_context("future.infer_string", True):
 2106:             ser = Series(["a", 1])
 2107:         tm.assert_series_equal(ser, expected)
 2108: 
 2109:     @pytest.mark.parametrize("na_value", [None, np.nan, pd.NA])
 2110:     def test_series_string_with_na_inference(self, na_value):
 2111:         # GH#54430
 2112:         pytest.importorskip("pyarrow")
 2113:         dtype = "string[pyarrow_numpy]"
 2114:         expected = Series(["a", na_value], dtype=dtype)
 2115:         with pd.option_context("future.infer_string", True):
 2116:             ser = Series(["a", na_value])
 2117:         tm.assert_series_equal(ser, expected)
 2118: 
 2119:     def test_series_string_inference_scalar(self):
 2120:         # GH#54430
 2121:         pytest.importorskip("pyarrow")
 2122:         expected = Series("a", index=[1], dtype="string[pyarrow_numpy]")
 2123:         with pd.option_context("future.infer_string", True):
 2124:             ser = Series("a", index=[1])
 2125:         tm.assert_series_equal(ser, expected)
 2126: 
 2127:     def test_series_string_inference_array_string_dtype(self):
 2128:         # GH#54496
 2129:         pytest.importorskip("pyarrow")
 2130:         expected = Series(["a", "b"], dtype="string[pyarrow_numpy]")
 2131:         with pd.option_context("future.infer_string", True):
 2132:             ser = Series(np.array(["a", "b"]))
 2133:         tm.assert_series_equal(ser, expected)
 2134: 
 2135:     def test_series_string_inference_storage_definition(self):
 2136:         # GH#54793
 2137:         pytest.importorskip("pyarrow")
 2138:         expected = Series(["a", "b"], dtype="string[pyarrow_numpy]")
 2139:         with pd.option_context("future.infer_string", True):
 2140:             result = Series(["a", "b"], dtype="string")
 2141:         tm.assert_series_equal(result, expected)
 2142: 
 2143:     def test_series_constructor_infer_string_scalar(self):
 2144:         # GH#55537
 2145:         with pd.option_context("future.infer_string", True):
 2146:             ser = Series("a", index=[1, 2], dtype="string[python]")
 2147:         expected = Series(["a", "a"], index=[1, 2], dtype="string[python]")
 2148:         tm.assert_series_equal(ser, expected)
 2149:         assert ser.dtype.storage == "python"
 2150: 
 2151:     def test_series_string_inference_na_first(self):
 2152:         # GH#55655
 2153:         pytest.importorskip("pyarrow")
 2154:         expected = Series([pd.NA, "b"], dtype="string[pyarrow_numpy]")
 2155:         with pd.option_context("future.infer_string", True):
 2156:             result = Series([pd.NA, "b"])
 2157:         tm.assert_series_equal(result, expected)
 2158: 
 2159:     def test_inference_on_pandas_objects(self):
 2160:         # GH#56012
 2161:         ser = Series([Timestamp("2019-12-31")], dtype=object)
 2162:         with tm.assert_produces_warning(None):
 2163:             # This doesn't do inference
 2164:             result = Series(ser)
 2165:         assert result.dtype == np.object_
 2166: 
 2167:         idx = Index([Timestamp("2019-12-31")], dtype=object)
 2168: 
 2169:         with tm.assert_produces_warning(FutureWarning, match="Dtype inference"):
 2170:             result = Series(idx)
 2171:         assert result.dtype != np.object_
 2172: 
 2173: 
 2174: class TestSeriesConstructorIndexCoercion:
 2175:     def test_series_constructor_datetimelike_index_coercion(self):
 2176:         idx = date_range("2020-01-01", periods=5)
 2177:         ser = Series(
 2178:             np.random.default_rng(2).standard_normal(len(idx)), idx.astype(object)
 2179:         )
 2180:         # as of 2.0, we no longer silently cast the object-dtype index
 2181:         #  to DatetimeIndex GH#39307, GH#23598
 2182:         assert not isinstance(ser.index, DatetimeIndex)
 2183: 
 2184:     @pytest.mark.parametrize("container", [None, np.array, Series, Index])
 2185:     @pytest.mark.parametrize("data", [1.0, range(4)])
 2186:     def test_series_constructor_infer_multiindex(self, container, data):
 2187:         indexes = [["a", "a", "b", "b"], ["x", "y", "x", "y"]]
 2188:         if container is not None:
 2189:             indexes = [container(ind) for ind in indexes]
 2190: 
 2191:         multi = Series(data, index=indexes)
 2192:         assert isinstance(multi.index, MultiIndex)
 2193: 
 2194:     # TODO: make this not cast to object in pandas 3.0
 2195:     @pytest.mark.skipif(
 2196:         not np_version_gt2, reason="StringDType only available in numpy 2 and above"
 2197:     )
 2198:     @pytest.mark.parametrize(
 2199:         "data",
 2200:         [
 2201:             ["a", "b", "c"],
 2202:             ["a", "b", np.nan],
 2203:         ],
 2204:     )
 2205:     def test_np_string_array_object_cast(self, data):
 2206:         from numpy.dtypes import StringDType
 2207: 
 2208:         arr = np.array(data, dtype=StringDType())
 2209:         res = Series(arr)
 2210:         assert res.dtype == np.object_
 2211:         assert (res == data).all()
 2212: 
 2213: 
 2214: class TestSeriesConstructorInternals:
 2215:     def test_constructor_no_pandas_array(self, using_array_manager):
 2216:         ser = Series([1, 2, 3])
 2217:         result = Series(ser.array)
 2218:         tm.assert_series_equal(ser, result)
 2219:         if not using_array_manager:
 2220:             assert isinstance(result._mgr.blocks[0], NumpyBlock)
 2221:             assert result._mgr.blocks[0].is_numeric
 2222: 
 2223:     @td.skip_array_manager_invalid_test
 2224:     def test_from_array(self):
 2225:         result = Series(pd.array(["1h", "2h"], dtype="timedelta64[ns]"))
 2226:         assert result._mgr.blocks[0].is_extension is False
 2227: 
 2228:         result = Series(pd.array(["2015"], dtype="datetime64[ns]"))
 2229:         assert result._mgr.blocks[0].is_extension is False
 2230: 
 2231:     @td.skip_array_manager_invalid_test
 2232:     def test_from_list_dtype(self):
 2233:         result = Series(["1h", "2h"], dtype="timedelta64[ns]")
 2234:         assert result._mgr.blocks[0].is_extension is False
 2235: 
 2236:         result = Series(["2015"], dtype="datetime64[ns]")
 2237:         assert result._mgr.blocks[0].is_extension is False
 2238: 
 2239: 
 2240: def test_constructor(rand_series_with_duplicate_datetimeindex):
 2241:     dups = rand_series_with_duplicate_datetimeindex
 2242:     assert isinstance(dups, Series)
 2243:     assert isinstance(dups.index, DatetimeIndex)
 2244: 
 2245: 
 2246: @pytest.mark.parametrize(
 2247:     "input_dict,expected",
 2248:     [
 2249:         ({0: 0}, np.array([[0]], dtype=np.int64)),
 2250:         ({"a": "a"}, np.array([["a"]], dtype=object)),
 2251:         ({1: 1}, np.array([[1]], dtype=np.int64)),
 2252:     ],
 2253: )
 2254: def test_numpy_array(input_dict, expected):
 2255:     result = np.array([Series(input_dict)])
 2256:     tm.assert_numpy_array_equal(result, expected)
 2257: 
 2258: 
 2259: def test_index_ordered_dict_keys():
 2260:     # GH 22077
 2261: 
 2262:     param_index = OrderedDict(
 2263:         [
 2264:             ((("a", "b"), ("c", "d")), 1),
 2265:             ((("a", None), ("c", "d")), 2),
 2266:         ]
 2267:     )
 2268:     series = Series([1, 2], index=param_index.keys())
 2269:     expected = Series(
 2270:         [1, 2],
 2271:         index=MultiIndex.from_tuples(
 2272:             [(("a", "b"), ("c", "d")), (("a", None), ("c", "d"))]
 2273:         ),
 2274:     )
 2275:     tm.assert_series_equal(series, expected)
 2276: 
 2277: 
 2278: @pytest.mark.parametrize(
 2279:     "input_list",
 2280:     [
 2281:         [1, complex("nan"), 2],
 2282:         [1 + 1j, complex("nan"), 2 + 2j],
 2283:     ],
 2284: )
 2285: def test_series_with_complex_nan(input_list):
 2286:     # GH#53627
 2287:     ser = Series(input_list)
 2288:     result = Series(ser.array)
 2289:     assert ser.dtype == "complex128"
 2290:     tm.assert_series_equal(ser, result)
