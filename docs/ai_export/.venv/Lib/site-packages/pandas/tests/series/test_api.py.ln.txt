    1: import inspect
    2: import pydoc
    3: 
    4: import numpy as np
    5: import pytest
    6: 
    7: import pandas as pd
    8: from pandas import (
    9:     DataFrame,
   10:     Index,
   11:     Series,
   12:     date_range,
   13:     period_range,
   14:     timedelta_range,
   15: )
   16: import pandas._testing as tm
   17: 
   18: 
   19: class TestSeriesMisc:
   20:     def test_tab_completion(self):
   21:         # GH 9910
   22:         s = Series(list("abcd"))
   23:         # Series of str values should have .str but not .dt/.cat in __dir__
   24:         assert "str" in dir(s)
   25:         assert "dt" not in dir(s)
   26:         assert "cat" not in dir(s)
   27: 
   28:     def test_tab_completion_dt(self):
   29:         # similarly for .dt
   30:         s = Series(date_range("1/1/2015", periods=5))
   31:         assert "dt" in dir(s)
   32:         assert "str" not in dir(s)
   33:         assert "cat" not in dir(s)
   34: 
   35:     def test_tab_completion_cat(self):
   36:         # Similarly for .cat, but with the twist that str and dt should be
   37:         # there if the categories are of that type first cat and str.
   38:         s = Series(list("abbcd"), dtype="category")
   39:         assert "cat" in dir(s)
   40:         assert "str" in dir(s)  # as it is a string categorical
   41:         assert "dt" not in dir(s)
   42: 
   43:     def test_tab_completion_cat_str(self):
   44:         # similar to cat and str
   45:         s = Series(date_range("1/1/2015", periods=5)).astype("category")
   46:         assert "cat" in dir(s)
   47:         assert "str" not in dir(s)
   48:         assert "dt" in dir(s)  # as it is a datetime categorical
   49: 
   50:     def test_tab_completion_with_categorical(self):
   51:         # test the tab completion display
   52:         ok_for_cat = [
   53:             "categories",
   54:             "codes",
   55:             "ordered",
   56:             "set_categories",
   57:             "add_categories",
   58:             "remove_categories",
   59:             "rename_categories",
   60:             "reorder_categories",
   61:             "remove_unused_categories",
   62:             "as_ordered",
   63:             "as_unordered",
   64:         ]
   65: 
   66:         s = Series(list("aabbcde")).astype("category")
   67:         results = sorted({r for r in s.cat.__dir__() if not r.startswith("_")})
   68:         tm.assert_almost_equal(results, sorted(set(ok_for_cat)))
   69: 
   70:     @pytest.mark.parametrize(
   71:         "index",
   72:         [
   73:             Index(list("ab") * 5, dtype="category"),
   74:             Index([str(i) for i in range(10)]),
   75:             Index(["foo", "bar", "baz"] * 2),
   76:             date_range("2020-01-01", periods=10),
   77:             period_range("2020-01-01", periods=10, freq="D"),
   78:             timedelta_range("1 day", periods=10),
   79:             Index(np.arange(10), dtype=np.uint64),
   80:             Index(np.arange(10), dtype=np.int64),
   81:             Index(np.arange(10), dtype=np.float64),
   82:             Index([True, False]),
   83:             Index([f"a{i}" for i in range(101)]),
   84:             pd.MultiIndex.from_tuples(zip("ABCD", "EFGH")),
   85:             pd.MultiIndex.from_tuples(zip([0, 1, 2, 3], "EFGH")),
   86:         ],
   87:     )
   88:     def test_index_tab_completion(self, index):
   89:         # dir contains string-like values of the Index.
   90:         s = Series(index=index, dtype=object)
   91:         dir_s = dir(s)
   92:         for i, x in enumerate(s.index.unique(level=0)):
   93:             if i < 100:
   94:                 assert not isinstance(x, str) or not x.isidentifier() or x in dir_s
   95:             else:
   96:                 assert x not in dir_s
   97: 
   98:     @pytest.mark.parametrize("ser", [Series(dtype=object), Series([1])])
   99:     def test_not_hashable(self, ser):
  100:         msg = "unhashable type: 'Series'"
  101:         with pytest.raises(TypeError, match=msg):
  102:             hash(ser)
  103: 
  104:     def test_contains(self, datetime_series):
  105:         tm.assert_contains_all(datetime_series.index, datetime_series)
  106: 
  107:     def test_axis_alias(self):
  108:         s = Series([1, 2, np.nan])
  109:         tm.assert_series_equal(s.dropna(axis="rows"), s.dropna(axis="index"))
  110:         assert s.dropna().sum("rows") == 3
  111:         assert s._get_axis_number("rows") == 0
  112:         assert s._get_axis_name("rows") == "index"
  113: 
  114:     def test_class_axis(self):
  115:         # https://github.com/pandas-dev/pandas/issues/18147
  116:         # no exception and no empty docstring
  117:         assert pydoc.getdoc(Series.index)
  118: 
  119:     def test_ndarray_compat(self):
  120:         # test numpy compat with Series as sub-class of NDFrame
  121:         tsdf = DataFrame(
  122:             np.random.default_rng(2).standard_normal((1000, 3)),
  123:             columns=["A", "B", "C"],
  124:             index=date_range("1/1/2000", periods=1000),
  125:         )
  126: 
  127:         def f(x):
  128:             return x[x.idxmax()]
  129: 
  130:         result = tsdf.apply(f)
  131:         expected = tsdf.max()
  132:         tm.assert_series_equal(result, expected)
  133: 
  134:     def test_ndarray_compat_like_func(self):
  135:         # using an ndarray like function
  136:         s = Series(np.random.default_rng(2).standard_normal(10))
  137:         result = Series(np.ones_like(s))
  138:         expected = Series(1, index=range(10), dtype="float64")
  139:         tm.assert_series_equal(result, expected)
  140: 
  141:     def test_ndarray_compat_ravel(self):
  142:         # ravel
  143:         s = Series(np.random.default_rng(2).standard_normal(10))
  144:         with tm.assert_produces_warning(FutureWarning, match="ravel is deprecated"):
  145:             result = s.ravel(order="F")
  146:         tm.assert_almost_equal(result, s.values.ravel(order="F"))
  147: 
  148:     def test_empty_method(self):
  149:         s_empty = Series(dtype=object)
  150:         assert s_empty.empty
  151: 
  152:     @pytest.mark.parametrize("dtype", ["int64", object])
  153:     def test_empty_method_full_series(self, dtype):
  154:         full_series = Series(index=[1], dtype=dtype)
  155:         assert not full_series.empty
  156: 
  157:     @pytest.mark.parametrize("dtype", [None, "Int64"])
  158:     def test_integer_series_size(self, dtype):
  159:         # GH 25580
  160:         s = Series(range(9), dtype=dtype)
  161:         assert s.size == 9
  162: 
  163:     def test_attrs(self):
  164:         s = Series([0, 1], name="abc")
  165:         assert s.attrs == {}
  166:         s.attrs["version"] = 1
  167:         result = s + 1
  168:         assert result.attrs == {"version": 1}
  169: 
  170:     def test_inspect_getmembers(self):
  171:         # GH38782
  172:         pytest.importorskip("jinja2")
  173:         ser = Series(dtype=object)
  174:         msg = "Series._data is deprecated"
  175:         with tm.assert_produces_warning(
  176:             DeprecationWarning, match=msg, check_stacklevel=False
  177:         ):
  178:             inspect.getmembers(ser)
  179: 
  180:     def test_unknown_attribute(self):
  181:         # GH#9680
  182:         tdi = timedelta_range(start=0, periods=10, freq="1s")
  183:         ser = Series(np.random.default_rng(2).normal(size=10), index=tdi)
  184:         assert "foo" not in ser.__dict__
  185:         msg = "'Series' object has no attribute 'foo'"
  186:         with pytest.raises(AttributeError, match=msg):
  187:             ser.foo
  188: 
  189:     @pytest.mark.parametrize("op", ["year", "day", "second", "weekday"])
  190:     def test_datetime_series_no_datelike_attrs(self, op, datetime_series):
  191:         # GH#7206
  192:         msg = f"'Series' object has no attribute '{op}'"
  193:         with pytest.raises(AttributeError, match=msg):
  194:             getattr(datetime_series, op)
  195: 
  196:     def test_series_datetimelike_attribute_access(self):
  197:         # attribute access should still work!
  198:         ser = Series({"year": 2000, "month": 1, "day": 10})
  199:         assert ser.year == 2000
  200:         assert ser.month == 1
  201:         assert ser.day == 10
  202: 
  203:     def test_series_datetimelike_attribute_access_invalid(self):
  204:         ser = Series({"year": 2000, "month": 1, "day": 10})
  205:         msg = "'Series' object has no attribute 'weekday'"
  206:         with pytest.raises(AttributeError, match=msg):
  207:             ser.weekday
  208: 
  209:     @pytest.mark.filterwarnings("ignore:Downcasting object dtype arrays:FutureWarning")
  210:     @pytest.mark.parametrize(
  211:         "kernel, has_numeric_only",
  212:         [
  213:             ("skew", True),
  214:             ("var", True),
  215:             ("all", False),
  216:             ("prod", True),
  217:             ("any", False),
  218:             ("idxmin", False),
  219:             ("quantile", False),
  220:             ("idxmax", False),
  221:             ("min", True),
  222:             ("sem", True),
  223:             ("mean", True),
  224:             ("nunique", False),
  225:             ("max", True),
  226:             ("sum", True),
  227:             ("count", False),
  228:             ("median", True),
  229:             ("std", True),
  230:             ("backfill", False),
  231:             ("rank", True),
  232:             ("pct_change", False),
  233:             ("cummax", False),
  234:             ("shift", False),
  235:             ("diff", False),
  236:             ("cumsum", False),
  237:             ("cummin", False),
  238:             ("cumprod", False),
  239:             ("fillna", False),
  240:             ("ffill", False),
  241:             ("pad", False),
  242:             ("bfill", False),
  243:             ("sample", False),
  244:             ("tail", False),
  245:             ("take", False),
  246:             ("head", False),
  247:             ("cov", False),
  248:             ("corr", False),
  249:         ],
  250:     )
  251:     @pytest.mark.parametrize("dtype", [bool, int, float, object])
  252:     def test_numeric_only(self, kernel, has_numeric_only, dtype):
  253:         # GH#47500
  254:         ser = Series([0, 1, 1], dtype=dtype)
  255:         if kernel == "corrwith":
  256:             args = (ser,)
  257:         elif kernel == "corr":
  258:             args = (ser,)
  259:         elif kernel == "cov":
  260:             args = (ser,)
  261:         elif kernel == "nth":
  262:             args = (0,)
  263:         elif kernel == "fillna":
  264:             args = (True,)
  265:         elif kernel == "fillna":
  266:             args = ("ffill",)
  267:         elif kernel == "take":
  268:             args = ([0],)
  269:         elif kernel == "quantile":
  270:             args = (0.5,)
  271:         else:
  272:             args = ()
  273:         method = getattr(ser, kernel)
  274:         if not has_numeric_only:
  275:             msg = (
  276:                 "(got an unexpected keyword argument 'numeric_only'"
  277:                 "|too many arguments passed in)"
  278:             )
  279:             with pytest.raises(TypeError, match=msg):
  280:                 method(*args, numeric_only=True)
  281:         elif dtype is object:
  282:             msg = f"Series.{kernel} does not allow numeric_only=True with non-numeric"
  283:             with pytest.raises(TypeError, match=msg):
  284:                 method(*args, numeric_only=True)
  285:         else:
  286:             result = method(*args, numeric_only=True)
  287:             expected = method(*args, numeric_only=False)
  288:             if isinstance(expected, Series):
  289:                 # transformer
  290:                 tm.assert_series_equal(result, expected)
  291:             else:
  292:                 # reducer
  293:                 assert result == expected
  294: 
  295: 
  296: @pytest.mark.parametrize("converter", [int, float, complex])
  297: def test_float_int_deprecated(converter):
  298:     # GH 51101
  299:     with tm.assert_produces_warning(FutureWarning):
  300:         assert converter(Series([1])) == converter(1)
