    1: from itertools import chain
    2: import operator
    3: 
    4: import numpy as np
    5: import pytest
    6: 
    7: from pandas._libs.algos import (
    8:     Infinity,
    9:     NegInfinity,
   10: )
   11: import pandas.util._test_decorators as td
   12: 
   13: from pandas import (
   14:     NA,
   15:     NaT,
   16:     Series,
   17:     Timestamp,
   18:     date_range,
   19: )
   20: import pandas._testing as tm
   21: from pandas.api.types import CategoricalDtype
   22: 
   23: 
   24: @pytest.fixture
   25: def ser():
   26:     return Series([1, 3, 4, 2, np.nan, 2, 1, 5, np.nan, 3])
   27: 
   28: 
   29: @pytest.fixture(
   30:     params=[
   31:         ["average", np.array([1.5, 5.5, 7.0, 3.5, np.nan, 3.5, 1.5, 8.0, np.nan, 5.5])],
   32:         ["min", np.array([1, 5, 7, 3, np.nan, 3, 1, 8, np.nan, 5])],
   33:         ["max", np.array([2, 6, 7, 4, np.nan, 4, 2, 8, np.nan, 6])],
   34:         ["first", np.array([1, 5, 7, 3, np.nan, 4, 2, 8, np.nan, 6])],
   35:         ["dense", np.array([1, 3, 4, 2, np.nan, 2, 1, 5, np.nan, 3])],
   36:     ]
   37: )
   38: def results(request):
   39:     return request.param
   40: 
   41: 
   42: @pytest.fixture(
   43:     params=[
   44:         "object",
   45:         "float64",
   46:         "int64",
   47:         "Float64",
   48:         "Int64",
   49:         pytest.param("float64[pyarrow]", marks=td.skip_if_no("pyarrow")),
   50:         pytest.param("int64[pyarrow]", marks=td.skip_if_no("pyarrow")),
   51:     ]
   52: )
   53: def dtype(request):
   54:     return request.param
   55: 
   56: 
   57: class TestSeriesRank:
   58:     def test_rank(self, datetime_series):
   59:         sp_stats = pytest.importorskip("scipy.stats")
   60: 
   61:         datetime_series[::2] = np.nan
   62:         datetime_series[:10:3] = 4.0
   63: 
   64:         ranks = datetime_series.rank()
   65:         oranks = datetime_series.astype("O").rank()
   66: 
   67:         tm.assert_series_equal(ranks, oranks)
   68: 
   69:         mask = np.isnan(datetime_series)
   70:         filled = datetime_series.fillna(np.inf)
   71: 
   72:         # rankdata returns a ndarray
   73:         exp = Series(sp_stats.rankdata(filled), index=filled.index, name="ts")
   74:         exp[mask] = np.nan
   75: 
   76:         tm.assert_series_equal(ranks, exp)
   77: 
   78:         iseries = Series(np.arange(5).repeat(2))
   79: 
   80:         iranks = iseries.rank()
   81:         exp = iseries.astype(float).rank()
   82:         tm.assert_series_equal(iranks, exp)
   83:         iseries = Series(np.arange(5)) + 1.0
   84:         exp = iseries / 5.0
   85:         iranks = iseries.rank(pct=True)
   86: 
   87:         tm.assert_series_equal(iranks, exp)
   88: 
   89:         iseries = Series(np.repeat(1, 100))
   90:         exp = Series(np.repeat(0.505, 100))
   91:         iranks = iseries.rank(pct=True)
   92:         tm.assert_series_equal(iranks, exp)
   93: 
   94:         # Explicit cast to float to avoid implicit cast when setting nan
   95:         iseries = iseries.astype("float")
   96:         iseries[1] = np.nan
   97:         exp = Series(np.repeat(50.0 / 99.0, 100))
   98:         exp[1] = np.nan
   99:         iranks = iseries.rank(pct=True)
  100:         tm.assert_series_equal(iranks, exp)
  101: 
  102:         iseries = Series(np.arange(5)) + 1.0
  103:         iseries[4] = np.nan
  104:         exp = iseries / 4.0
  105:         iranks = iseries.rank(pct=True)
  106:         tm.assert_series_equal(iranks, exp)
  107: 
  108:         iseries = Series(np.repeat(np.nan, 100))
  109:         exp = iseries.copy()
  110:         iranks = iseries.rank(pct=True)
  111:         tm.assert_series_equal(iranks, exp)
  112: 
  113:         # Explicit cast to float to avoid implicit cast when setting nan
  114:         iseries = Series(np.arange(5), dtype="float") + 1
  115:         iseries[4] = np.nan
  116:         exp = iseries / 4.0
  117:         iranks = iseries.rank(pct=True)
  118:         tm.assert_series_equal(iranks, exp)
  119: 
  120:         rng = date_range("1/1/1990", periods=5)
  121:         # Explicit cast to float to avoid implicit cast when setting nan
  122:         iseries = Series(np.arange(5), rng, dtype="float") + 1
  123:         iseries.iloc[4] = np.nan
  124:         exp = iseries / 4.0
  125:         iranks = iseries.rank(pct=True)
  126:         tm.assert_series_equal(iranks, exp)
  127: 
  128:         iseries = Series([1e-50, 1e-100, 1e-20, 1e-2, 1e-20 + 1e-30, 1e-1])
  129:         exp = Series([2, 1, 3, 5, 4, 6.0])
  130:         iranks = iseries.rank()
  131:         tm.assert_series_equal(iranks, exp)
  132: 
  133:         # GH 5968
  134:         iseries = Series(["3 day", "1 day 10m", "-2 day", NaT], dtype="m8[ns]")
  135:         exp = Series([3, 2, 1, np.nan])
  136:         iranks = iseries.rank()
  137:         tm.assert_series_equal(iranks, exp)
  138: 
  139:         values = np.array(
  140:             [-50, -1, -1e-20, -1e-25, -1e-50, 0, 1e-40, 1e-20, 1e-10, 2, 40],
  141:             dtype="float64",
  142:         )
  143:         random_order = np.random.default_rng(2).permutation(len(values))
  144:         iseries = Series(values[random_order])
  145:         exp = Series(random_order + 1.0, dtype="float64")
  146:         iranks = iseries.rank()
  147:         tm.assert_series_equal(iranks, exp)
  148: 
  149:     def test_rank_categorical(self):
  150:         # GH issue #15420 rank incorrectly orders ordered categories
  151: 
  152:         # Test ascending/descending ranking for ordered categoricals
  153:         exp = Series([1.0, 2.0, 3.0, 4.0, 5.0, 6.0])
  154:         exp_desc = Series([6.0, 5.0, 4.0, 3.0, 2.0, 1.0])
  155:         ordered = Series(
  156:             ["first", "second", "third", "fourth", "fifth", "sixth"]
  157:         ).astype(
  158:             CategoricalDtype(
  159:                 categories=["first", "second", "third", "fourth", "fifth", "sixth"],
  160:                 ordered=True,
  161:             )
  162:         )
  163:         tm.assert_series_equal(ordered.rank(), exp)
  164:         tm.assert_series_equal(ordered.rank(ascending=False), exp_desc)
  165: 
  166:         # Unordered categoricals should be ranked as objects
  167:         unordered = Series(
  168:             ["first", "second", "third", "fourth", "fifth", "sixth"]
  169:         ).astype(
  170:             CategoricalDtype(
  171:                 categories=["first", "second", "third", "fourth", "fifth", "sixth"],
  172:                 ordered=False,
  173:             )
  174:         )
  175:         exp_unordered = Series([2.0, 4.0, 6.0, 3.0, 1.0, 5.0])
  176:         res = unordered.rank()
  177:         tm.assert_series_equal(res, exp_unordered)
  178: 
  179:         unordered1 = Series([1, 2, 3, 4, 5, 6]).astype(
  180:             CategoricalDtype([1, 2, 3, 4, 5, 6], False)
  181:         )
  182:         exp_unordered1 = Series([1.0, 2.0, 3.0, 4.0, 5.0, 6.0])
  183:         res1 = unordered1.rank()
  184:         tm.assert_series_equal(res1, exp_unordered1)
  185: 
  186:         # Test na_option for rank data
  187:         na_ser = Series(
  188:             ["first", "second", "third", "fourth", "fifth", "sixth", np.nan]
  189:         ).astype(
  190:             CategoricalDtype(
  191:                 ["first", "second", "third", "fourth", "fifth", "sixth", "seventh"],
  192:                 True,
  193:             )
  194:         )
  195: 
  196:         exp_top = Series([2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 1.0])
  197:         exp_bot = Series([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0])
  198:         exp_keep = Series([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, np.nan])
  199: 
  200:         tm.assert_series_equal(na_ser.rank(na_option="top"), exp_top)
  201:         tm.assert_series_equal(na_ser.rank(na_option="bottom"), exp_bot)
  202:         tm.assert_series_equal(na_ser.rank(na_option="keep"), exp_keep)
  203: 
  204:         # Test na_option for rank data with ascending False
  205:         exp_top = Series([7.0, 6.0, 5.0, 4.0, 3.0, 2.0, 1.0])
  206:         exp_bot = Series([6.0, 5.0, 4.0, 3.0, 2.0, 1.0, 7.0])
  207:         exp_keep = Series([6.0, 5.0, 4.0, 3.0, 2.0, 1.0, np.nan])
  208: 
  209:         tm.assert_series_equal(na_ser.rank(na_option="top", ascending=False), exp_top)
  210:         tm.assert_series_equal(
  211:             na_ser.rank(na_option="bottom", ascending=False), exp_bot
  212:         )
  213:         tm.assert_series_equal(na_ser.rank(na_option="keep", ascending=False), exp_keep)
  214: 
  215:         # Test invalid values for na_option
  216:         msg = "na_option must be one of 'keep', 'top', or 'bottom'"
  217: 
  218:         with pytest.raises(ValueError, match=msg):
  219:             na_ser.rank(na_option="bad", ascending=False)
  220: 
  221:         # invalid type
  222:         with pytest.raises(ValueError, match=msg):
  223:             na_ser.rank(na_option=True, ascending=False)
  224: 
  225:         # Test with pct=True
  226:         na_ser = Series(["first", "second", "third", "fourth", np.nan]).astype(
  227:             CategoricalDtype(["first", "second", "third", "fourth"], True)
  228:         )
  229:         exp_top = Series([0.4, 0.6, 0.8, 1.0, 0.2])
  230:         exp_bot = Series([0.2, 0.4, 0.6, 0.8, 1.0])
  231:         exp_keep = Series([0.25, 0.5, 0.75, 1.0, np.nan])
  232: 
  233:         tm.assert_series_equal(na_ser.rank(na_option="top", pct=True), exp_top)
  234:         tm.assert_series_equal(na_ser.rank(na_option="bottom", pct=True), exp_bot)
  235:         tm.assert_series_equal(na_ser.rank(na_option="keep", pct=True), exp_keep)
  236: 
  237:     def test_rank_signature(self):
  238:         s = Series([0, 1])
  239:         s.rank(method="average")
  240:         msg = "No axis named average for object type Series"
  241:         with pytest.raises(ValueError, match=msg):
  242:             s.rank("average")
  243: 
  244:     @pytest.mark.parametrize("dtype", [None, object])
  245:     def test_rank_tie_methods(self, ser, results, dtype):
  246:         method, exp = results
  247:         ser = ser if dtype is None else ser.astype(dtype)
  248:         result = ser.rank(method=method)
  249:         tm.assert_series_equal(result, Series(exp))
  250: 
  251:     @pytest.mark.parametrize("ascending", [True, False])
  252:     @pytest.mark.parametrize("method", ["average", "min", "max", "first", "dense"])
  253:     @pytest.mark.parametrize("na_option", ["top", "bottom", "keep"])
  254:     @pytest.mark.parametrize(
  255:         "dtype, na_value, pos_inf, neg_inf",
  256:         [
  257:             ("object", None, Infinity(), NegInfinity()),
  258:             ("float64", np.nan, np.inf, -np.inf),
  259:             ("Float64", NA, np.inf, -np.inf),
  260:             pytest.param(
  261:                 "float64[pyarrow]",
  262:                 NA,
  263:                 np.inf,
  264:                 -np.inf,
  265:                 marks=td.skip_if_no("pyarrow"),
  266:             ),
  267:         ],
  268:     )
  269:     def test_rank_tie_methods_on_infs_nans(
  270:         self, method, na_option, ascending, dtype, na_value, pos_inf, neg_inf
  271:     ):
  272:         pytest.importorskip("scipy")
  273:         if dtype == "float64[pyarrow]":
  274:             if method == "average":
  275:                 exp_dtype = "float64[pyarrow]"
  276:             else:
  277:                 exp_dtype = "uint64[pyarrow]"
  278:         else:
  279:             exp_dtype = "float64"
  280: 
  281:         chunk = 3
  282:         in_arr = [neg_inf] * chunk + [na_value] * chunk + [pos_inf] * chunk
  283:         iseries = Series(in_arr, dtype=dtype)
  284:         exp_ranks = {
  285:             "average": ([2, 2, 2], [5, 5, 5], [8, 8, 8]),
  286:             "min": ([1, 1, 1], [4, 4, 4], [7, 7, 7]),
  287:             "max": ([3, 3, 3], [6, 6, 6], [9, 9, 9]),
  288:             "first": ([1, 2, 3], [4, 5, 6], [7, 8, 9]),
  289:             "dense": ([1, 1, 1], [2, 2, 2], [3, 3, 3]),
  290:         }
  291:         ranks = exp_ranks[method]
  292:         if na_option == "top":
  293:             order = [ranks[1], ranks[0], ranks[2]]
  294:         elif na_option == "bottom":
  295:             order = [ranks[0], ranks[2], ranks[1]]
  296:         else:
  297:             order = [ranks[0], [np.nan] * chunk, ranks[1]]
  298:         expected = order if ascending else order[::-1]
  299:         expected = list(chain.from_iterable(expected))
  300:         result = iseries.rank(method=method, na_option=na_option, ascending=ascending)
  301:         tm.assert_series_equal(result, Series(expected, dtype=exp_dtype))
  302: 
  303:     def test_rank_desc_mix_nans_infs(self):
  304:         # GH 19538
  305:         # check descending ranking when mix nans and infs
  306:         iseries = Series([1, np.nan, np.inf, -np.inf, 25])
  307:         result = iseries.rank(ascending=False)
  308:         exp = Series([3, np.nan, 1, 4, 2], dtype="float64")
  309:         tm.assert_series_equal(result, exp)
  310: 
  311:     @pytest.mark.parametrize("method", ["average", "min", "max", "first", "dense"])
  312:     @pytest.mark.parametrize(
  313:         "op, value",
  314:         [
  315:             [operator.add, 0],
  316:             [operator.add, 1e6],
  317:             [operator.mul, 1e-6],
  318:         ],
  319:     )
  320:     def test_rank_methods_series(self, method, op, value):
  321:         sp_stats = pytest.importorskip("scipy.stats")
  322: 
  323:         xs = np.random.default_rng(2).standard_normal(9)
  324:         xs = np.concatenate([xs[i:] for i in range(0, 9, 2)])  # add duplicates
  325:         np.random.default_rng(2).shuffle(xs)
  326: 
  327:         index = [chr(ord("a") + i) for i in range(len(xs))]
  328:         vals = op(xs, value)
  329:         ts = Series(vals, index=index)
  330:         result = ts.rank(method=method)
  331:         sprank = sp_stats.rankdata(vals, method if method != "first" else "ordinal")
  332:         expected = Series(sprank, index=index).astype("float64")
  333:         tm.assert_series_equal(result, expected)
  334: 
  335:     @pytest.mark.parametrize(
  336:         "ser, exp",
  337:         [
  338:             ([1], [1]),
  339:             ([2], [1]),
  340:             ([0], [1]),
  341:             ([2, 2], [1, 1]),
  342:             ([1, 2, 3], [1, 2, 3]),
  343:             ([4, 2, 1], [3, 2, 1]),
  344:             ([1, 1, 5, 5, 3], [1, 1, 3, 3, 2]),
  345:             ([-5, -4, -3, -2, -1], [1, 2, 3, 4, 5]),
  346:         ],
  347:     )
  348:     def test_rank_dense_method(self, dtype, ser, exp):
  349:         s = Series(ser).astype(dtype)
  350:         result = s.rank(method="dense")
  351:         expected = Series(exp).astype(result.dtype)
  352:         tm.assert_series_equal(result, expected)
  353: 
  354:     def test_rank_descending(self, ser, results, dtype):
  355:         method, _ = results
  356:         if "i" in dtype:
  357:             s = ser.dropna()
  358:         else:
  359:             s = ser.astype(dtype)
  360: 
  361:         res = s.rank(ascending=False)
  362:         expected = (s.max() - s).rank()
  363:         tm.assert_series_equal(res, expected)
  364: 
  365:         expected = (s.max() - s).rank(method=method)
  366:         res2 = s.rank(method=method, ascending=False)
  367:         tm.assert_series_equal(res2, expected)
  368: 
  369:     def test_rank_int(self, ser, results):
  370:         method, exp = results
  371:         s = ser.dropna().astype("i8")
  372: 
  373:         result = s.rank(method=method)
  374:         expected = Series(exp).dropna()
  375:         expected.index = result.index
  376:         tm.assert_series_equal(result, expected)
  377: 
  378:     def test_rank_object_bug(self):
  379:         # GH 13445
  380: 
  381:         # smoke tests
  382:         Series([np.nan] * 32).astype(object).rank(ascending=True)
  383:         Series([np.nan] * 32).astype(object).rank(ascending=False)
  384: 
  385:     def test_rank_modify_inplace(self):
  386:         # GH 18521
  387:         # Check rank does not mutate series
  388:         s = Series([Timestamp("2017-01-05 10:20:27.569000"), NaT])
  389:         expected = s.copy()
  390: 
  391:         s.rank()
  392:         result = s
  393:         tm.assert_series_equal(result, expected)
  394: 
  395:     def test_rank_ea_small_values(self):
  396:         # GH#52471
  397:         ser = Series(
  398:             [5.4954145e29, -9.791984e-21, 9.3715776e-26, NA, 1.8790257e-28],
  399:             dtype="Float64",
  400:         )
  401:         result = ser.rank(method="min")
  402:         expected = Series([4, 1, 3, np.nan, 2])
  403:         tm.assert_series_equal(result, expected)
  404: 
  405: 
  406: # GH15630, pct should be on 100% basis when method='dense'
  407: 
  408: 
  409: @pytest.mark.parametrize(
  410:     "ser, exp",
  411:     [
  412:         ([1], [1.0]),
  413:         ([1, 2], [1.0 / 2, 2.0 / 2]),
  414:         ([2, 2], [1.0, 1.0]),
  415:         ([1, 2, 3], [1.0 / 3, 2.0 / 3, 3.0 / 3]),
  416:         ([1, 2, 2], [1.0 / 2, 2.0 / 2, 2.0 / 2]),
  417:         ([4, 2, 1], [3.0 / 3, 2.0 / 3, 1.0 / 3]),
  418:         ([1, 1, 5, 5, 3], [1.0 / 3, 1.0 / 3, 3.0 / 3, 3.0 / 3, 2.0 / 3]),
  419:         ([1, 1, 3, 3, 5, 5], [1.0 / 3, 1.0 / 3, 2.0 / 3, 2.0 / 3, 3.0 / 3, 3.0 / 3]),
  420:         ([-5, -4, -3, -2, -1], [1.0 / 5, 2.0 / 5, 3.0 / 5, 4.0 / 5, 5.0 / 5]),
  421:     ],
  422: )
  423: def test_rank_dense_pct(dtype, ser, exp):
  424:     s = Series(ser).astype(dtype)
  425:     result = s.rank(method="dense", pct=True)
  426:     expected = Series(exp).astype(result.dtype)
  427:     tm.assert_series_equal(result, expected)
  428: 
  429: 
  430: @pytest.mark.parametrize(
  431:     "ser, exp",
  432:     [
  433:         ([1], [1.0]),
  434:         ([1, 2], [1.0 / 2, 2.0 / 2]),
  435:         ([2, 2], [1.0 / 2, 1.0 / 2]),
  436:         ([1, 2, 3], [1.0 / 3, 2.0 / 3, 3.0 / 3]),
  437:         ([1, 2, 2], [1.0 / 3, 2.0 / 3, 2.0 / 3]),
  438:         ([4, 2, 1], [3.0 / 3, 2.0 / 3, 1.0 / 3]),
  439:         ([1, 1, 5, 5, 3], [1.0 / 5, 1.0 / 5, 4.0 / 5, 4.0 / 5, 3.0 / 5]),
  440:         ([1, 1, 3, 3, 5, 5], [1.0 / 6, 1.0 / 6, 3.0 / 6, 3.0 / 6, 5.0 / 6, 5.0 / 6]),
  441:         ([-5, -4, -3, -2, -1], [1.0 / 5, 2.0 / 5, 3.0 / 5, 4.0 / 5, 5.0 / 5]),
  442:     ],
  443: )
  444: def test_rank_min_pct(dtype, ser, exp):
  445:     s = Series(ser).astype(dtype)
  446:     result = s.rank(method="min", pct=True)
  447:     expected = Series(exp).astype(result.dtype)
  448:     tm.assert_series_equal(result, expected)
  449: 
  450: 
  451: @pytest.mark.parametrize(
  452:     "ser, exp",
  453:     [
  454:         ([1], [1.0]),
  455:         ([1, 2], [1.0 / 2, 2.0 / 2]),
  456:         ([2, 2], [1.0, 1.0]),
  457:         ([1, 2, 3], [1.0 / 3, 2.0 / 3, 3.0 / 3]),
  458:         ([1, 2, 2], [1.0 / 3, 3.0 / 3, 3.0 / 3]),
  459:         ([4, 2, 1], [3.0 / 3, 2.0 / 3, 1.0 / 3]),
  460:         ([1, 1, 5, 5, 3], [2.0 / 5, 2.0 / 5, 5.0 / 5, 5.0 / 5, 3.0 / 5]),
  461:         ([1, 1, 3, 3, 5, 5], [2.0 / 6, 2.0 / 6, 4.0 / 6, 4.0 / 6, 6.0 / 6, 6.0 / 6]),
  462:         ([-5, -4, -3, -2, -1], [1.0 / 5, 2.0 / 5, 3.0 / 5, 4.0 / 5, 5.0 / 5]),
  463:     ],
  464: )
  465: def test_rank_max_pct(dtype, ser, exp):
  466:     s = Series(ser).astype(dtype)
  467:     result = s.rank(method="max", pct=True)
  468:     expected = Series(exp).astype(result.dtype)
  469:     tm.assert_series_equal(result, expected)
  470: 
  471: 
  472: @pytest.mark.parametrize(
  473:     "ser, exp",
  474:     [
  475:         ([1], [1.0]),
  476:         ([1, 2], [1.0 / 2, 2.0 / 2]),
  477:         ([2, 2], [1.5 / 2, 1.5 / 2]),
  478:         ([1, 2, 3], [1.0 / 3, 2.0 / 3, 3.0 / 3]),
  479:         ([1, 2, 2], [1.0 / 3, 2.5 / 3, 2.5 / 3]),
  480:         ([4, 2, 1], [3.0 / 3, 2.0 / 3, 1.0 / 3]),
  481:         ([1, 1, 5, 5, 3], [1.5 / 5, 1.5 / 5, 4.5 / 5, 4.5 / 5, 3.0 / 5]),
  482:         ([1, 1, 3, 3, 5, 5], [1.5 / 6, 1.5 / 6, 3.5 / 6, 3.5 / 6, 5.5 / 6, 5.5 / 6]),
  483:         ([-5, -4, -3, -2, -1], [1.0 / 5, 2.0 / 5, 3.0 / 5, 4.0 / 5, 5.0 / 5]),
  484:     ],
  485: )
  486: def test_rank_average_pct(dtype, ser, exp):
  487:     s = Series(ser).astype(dtype)
  488:     result = s.rank(method="average", pct=True)
  489:     expected = Series(exp).astype(result.dtype)
  490:     tm.assert_series_equal(result, expected)
  491: 
  492: 
  493: @pytest.mark.parametrize(
  494:     "ser, exp",
  495:     [
  496:         ([1], [1.0]),
  497:         ([1, 2], [1.0 / 2, 2.0 / 2]),
  498:         ([2, 2], [1.0 / 2, 2.0 / 2.0]),
  499:         ([1, 2, 3], [1.0 / 3, 2.0 / 3, 3.0 / 3]),
  500:         ([1, 2, 2], [1.0 / 3, 2.0 / 3, 3.0 / 3]),
  501:         ([4, 2, 1], [3.0 / 3, 2.0 / 3, 1.0 / 3]),
  502:         ([1, 1, 5, 5, 3], [1.0 / 5, 2.0 / 5, 4.0 / 5, 5.0 / 5, 3.0 / 5]),
  503:         ([1, 1, 3, 3, 5, 5], [1.0 / 6, 2.0 / 6, 3.0 / 6, 4.0 / 6, 5.0 / 6, 6.0 / 6]),
  504:         ([-5, -4, -3, -2, -1], [1.0 / 5, 2.0 / 5, 3.0 / 5, 4.0 / 5, 5.0 / 5]),
  505:     ],
  506: )
  507: def test_rank_first_pct(dtype, ser, exp):
  508:     s = Series(ser).astype(dtype)
  509:     result = s.rank(method="first", pct=True)
  510:     expected = Series(exp).astype(result.dtype)
  511:     tm.assert_series_equal(result, expected)
  512: 
  513: 
  514: @pytest.mark.single_cpu
  515: def test_pct_max_many_rows():
  516:     # GH 18271
  517:     s = Series(np.arange(2**24 + 1))
  518:     result = s.rank(pct=True).max()
  519:     assert result == 1
