    1: from datetime import (
    2:     date,
    3:     datetime,
    4: )
    5: from decimal import Decimal
    6: 
    7: import numpy as np
    8: import pytest
    9: 
   10: from pandas.compat.numpy import np_version_gte1p24
   11: from pandas.errors import IndexingError
   12: 
   13: from pandas.core.dtypes.common import is_list_like
   14: 
   15: from pandas import (
   16:     NA,
   17:     Categorical,
   18:     DataFrame,
   19:     DatetimeIndex,
   20:     Index,
   21:     Interval,
   22:     IntervalIndex,
   23:     MultiIndex,
   24:     NaT,
   25:     Period,
   26:     Series,
   27:     Timedelta,
   28:     Timestamp,
   29:     array,
   30:     concat,
   31:     date_range,
   32:     interval_range,
   33:     period_range,
   34:     timedelta_range,
   35: )
   36: import pandas._testing as tm
   37: 
   38: from pandas.tseries.offsets import BDay
   39: 
   40: 
   41: class TestSetitemDT64Values:
   42:     def test_setitem_none_nan(self):
   43:         series = Series(date_range("1/1/2000", periods=10))
   44:         series[3] = None
   45:         assert series[3] is NaT
   46: 
   47:         series[3:5] = None
   48:         assert series[4] is NaT
   49: 
   50:         series[5] = np.nan
   51:         assert series[5] is NaT
   52: 
   53:         series[5:7] = np.nan
   54:         assert series[6] is NaT
   55: 
   56:     def test_setitem_multiindex_empty_slice(self):
   57:         # https://github.com/pandas-dev/pandas/issues/35878
   58:         idx = MultiIndex.from_tuples([("a", 1), ("b", 2)])
   59:         result = Series([1, 2], index=idx)
   60:         expected = result.copy()
   61:         result.loc[[]] = 0
   62:         tm.assert_series_equal(result, expected)
   63: 
   64:     def test_setitem_with_string_index(self):
   65:         # GH#23451
   66:         # Set object dtype to avoid upcast when setting date.today()
   67:         ser = Series([1, 2, 3], index=["Date", "b", "other"], dtype=object)
   68:         ser["Date"] = date.today()
   69:         assert ser.Date == date.today()
   70:         assert ser["Date"] == date.today()
   71: 
   72:     def test_setitem_tuple_with_datetimetz_values(self):
   73:         # GH#20441
   74:         arr = date_range("2017", periods=4, tz="US/Eastern")
   75:         index = [(0, 1), (0, 2), (0, 3), (0, 4)]
   76:         result = Series(arr, index=index)
   77:         expected = result.copy()
   78:         result[(0, 1)] = np.nan
   79:         expected.iloc[0] = np.nan
   80:         tm.assert_series_equal(result, expected)
   81: 
   82:     @pytest.mark.parametrize("tz", ["US/Eastern", "UTC", "Asia/Tokyo"])
   83:     def test_setitem_with_tz(self, tz, indexer_sli):
   84:         orig = Series(date_range("2016-01-01", freq="h", periods=3, tz=tz))
   85:         assert orig.dtype == f"datetime64[ns, {tz}]"
   86: 
   87:         exp = Series(
   88:             [
   89:                 Timestamp("2016-01-01 00:00", tz=tz),
   90:                 Timestamp("2011-01-01 00:00", tz=tz),
   91:                 Timestamp("2016-01-01 02:00", tz=tz),
   92:             ],
   93:             dtype=orig.dtype,
   94:         )
   95: 
   96:         # scalar
   97:         ser = orig.copy()
   98:         indexer_sli(ser)[1] = Timestamp("2011-01-01", tz=tz)
   99:         tm.assert_series_equal(ser, exp)
  100: 
  101:         # vector
  102:         vals = Series(
  103:             [Timestamp("2011-01-01", tz=tz), Timestamp("2012-01-01", tz=tz)],
  104:             index=[1, 2],
  105:             dtype=orig.dtype,
  106:         )
  107:         assert vals.dtype == f"datetime64[ns, {tz}]"
  108: 
  109:         exp = Series(
  110:             [
  111:                 Timestamp("2016-01-01 00:00", tz=tz),
  112:                 Timestamp("2011-01-01 00:00", tz=tz),
  113:                 Timestamp("2012-01-01 00:00", tz=tz),
  114:             ],
  115:             dtype=orig.dtype,
  116:         )
  117: 
  118:         ser = orig.copy()
  119:         indexer_sli(ser)[[1, 2]] = vals
  120:         tm.assert_series_equal(ser, exp)
  121: 
  122:     def test_setitem_with_tz_dst(self, indexer_sli):
  123:         # GH#14146 trouble setting values near DST boundary
  124:         tz = "US/Eastern"
  125:         orig = Series(date_range("2016-11-06", freq="h", periods=3, tz=tz))
  126:         assert orig.dtype == f"datetime64[ns, {tz}]"
  127: 
  128:         exp = Series(
  129:             [
  130:                 Timestamp("2016-11-06 00:00-04:00", tz=tz),
  131:                 Timestamp("2011-01-01 00:00-05:00", tz=tz),
  132:                 Timestamp("2016-11-06 01:00-05:00", tz=tz),
  133:             ],
  134:             dtype=orig.dtype,
  135:         )
  136: 
  137:         # scalar
  138:         ser = orig.copy()
  139:         indexer_sli(ser)[1] = Timestamp("2011-01-01", tz=tz)
  140:         tm.assert_series_equal(ser, exp)
  141: 
  142:         # vector
  143:         vals = Series(
  144:             [Timestamp("2011-01-01", tz=tz), Timestamp("2012-01-01", tz=tz)],
  145:             index=[1, 2],
  146:             dtype=orig.dtype,
  147:         )
  148:         assert vals.dtype == f"datetime64[ns, {tz}]"
  149: 
  150:         exp = Series(
  151:             [
  152:                 Timestamp("2016-11-06 00:00", tz=tz),
  153:                 Timestamp("2011-01-01 00:00", tz=tz),
  154:                 Timestamp("2012-01-01 00:00", tz=tz),
  155:             ],
  156:             dtype=orig.dtype,
  157:         )
  158: 
  159:         ser = orig.copy()
  160:         indexer_sli(ser)[[1, 2]] = vals
  161:         tm.assert_series_equal(ser, exp)
  162: 
  163:     def test_object_series_setitem_dt64array_exact_match(self):
  164:         # make sure the dt64 isn't cast by numpy to integers
  165:         # https://github.com/numpy/numpy/issues/12550
  166: 
  167:         ser = Series({"X": np.nan}, dtype=object)
  168: 
  169:         indexer = [True]
  170: 
  171:         # "exact_match" -> size of array being set matches size of ser
  172:         value = np.array([4], dtype="M8[ns]")
  173: 
  174:         ser.iloc[indexer] = value
  175: 
  176:         expected = Series([value[0]], index=["X"], dtype=object)
  177:         assert all(isinstance(x, np.datetime64) for x in expected.values)
  178: 
  179:         tm.assert_series_equal(ser, expected)
  180: 
  181: 
  182: class TestSetitemScalarIndexer:
  183:     def test_setitem_negative_out_of_bounds(self):
  184:         ser = Series(["a"] * 10, index=["a"] * 10)
  185: 
  186:         # string index falls back to positional
  187:         msg = "index -11|-1 is out of bounds for axis 0 with size 10"
  188:         warn_msg = "Series.__setitem__ treating keys as positions is deprecated"
  189:         with pytest.raises(IndexError, match=msg):
  190:             with tm.assert_produces_warning(FutureWarning, match=warn_msg):
  191:                 ser[-11] = "foo"
  192: 
  193:     @pytest.mark.parametrize("indexer", [tm.loc, tm.at])
  194:     @pytest.mark.parametrize("ser_index", [0, 1])
  195:     def test_setitem_series_object_dtype(self, indexer, ser_index):
  196:         # GH#38303
  197:         ser = Series([0, 0], dtype="object")
  198:         idxr = indexer(ser)
  199:         idxr[0] = Series([42], index=[ser_index])
  200:         expected = Series([Series([42], index=[ser_index]), 0], dtype="object")
  201:         tm.assert_series_equal(ser, expected)
  202: 
  203:     @pytest.mark.parametrize("index, exp_value", [(0, 42), (1, np.nan)])
  204:     def test_setitem_series(self, index, exp_value):
  205:         # GH#38303
  206:         ser = Series([0, 0])
  207:         ser.loc[0] = Series([42], index=[index])
  208:         expected = Series([exp_value, 0])
  209:         tm.assert_series_equal(ser, expected)
  210: 
  211: 
  212: class TestSetitemSlices:
  213:     def test_setitem_slice_float_raises(self, datetime_series):
  214:         msg = (
  215:             "cannot do slice indexing on DatetimeIndex with these indexers "
  216:             r"\[{key}\] of type float"
  217:         )
  218:         with pytest.raises(TypeError, match=msg.format(key=r"4\.0")):
  219:             datetime_series[4.0:10.0] = 0
  220: 
  221:         with pytest.raises(TypeError, match=msg.format(key=r"4\.5")):
  222:             datetime_series[4.5:10.0] = 0
  223: 
  224:     def test_setitem_slice(self):
  225:         ser = Series(range(10), index=list(range(10)))
  226:         ser[-12:] = 0
  227:         assert (ser == 0).all()
  228: 
  229:         ser[:-12] = 5
  230:         assert (ser == 0).all()
  231: 
  232:     def test_setitem_slice_integers(self):
  233:         ser = Series(
  234:             np.random.default_rng(2).standard_normal(8),
  235:             index=[2, 4, 6, 8, 10, 12, 14, 16],
  236:         )
  237: 
  238:         ser[:4] = 0
  239:         assert (ser[:4] == 0).all()
  240:         assert not (ser[4:] == 0).any()
  241: 
  242:     def test_setitem_slicestep(self):
  243:         # caught this bug when writing tests
  244:         series = Series(
  245:             np.arange(20, dtype=np.float64), index=np.arange(20, dtype=np.int64)
  246:         )
  247: 
  248:         series[::2] = 0
  249:         assert (series[::2] == 0).all()
  250: 
  251:     def test_setitem_multiindex_slice(self, indexer_sli):
  252:         # GH 8856
  253:         mi = MultiIndex.from_product(([0, 1], list("abcde")))
  254:         result = Series(np.arange(10, dtype=np.int64), mi)
  255:         indexer_sli(result)[::4] = 100
  256:         expected = Series([100, 1, 2, 3, 100, 5, 6, 7, 100, 9], mi)
  257:         tm.assert_series_equal(result, expected)
  258: 
  259: 
  260: class TestSetitemBooleanMask:
  261:     def test_setitem_mask_cast(self):
  262:         # GH#2746
  263:         # need to upcast
  264:         ser = Series([1, 2], index=[1, 2], dtype="int64")
  265:         ser[[True, False]] = Series([0], index=[1], dtype="int64")
  266:         expected = Series([0, 2], index=[1, 2], dtype="int64")
  267: 
  268:         tm.assert_series_equal(ser, expected)
  269: 
  270:     def test_setitem_mask_align_and_promote(self):
  271:         # GH#8387: test that changing types does not break alignment
  272:         ts = Series(
  273:             np.random.default_rng(2).standard_normal(100), index=np.arange(100, 0, -1)
  274:         ).round(5)
  275:         mask = ts > 0
  276:         left = ts.copy()
  277:         right = ts[mask].copy().map(str)
  278:         with tm.assert_produces_warning(
  279:             FutureWarning, match="item of incompatible dtype"
  280:         ):
  281:             left[mask] = right
  282:         expected = ts.map(lambda t: str(t) if t > 0 else t)
  283:         tm.assert_series_equal(left, expected)
  284: 
  285:     def test_setitem_mask_promote_strs(self):
  286:         ser = Series([0, 1, 2, 0])
  287:         mask = ser > 0
  288:         ser2 = ser[mask].map(str)
  289:         with tm.assert_produces_warning(
  290:             FutureWarning, match="item of incompatible dtype"
  291:         ):
  292:             ser[mask] = ser2
  293: 
  294:         expected = Series([0, "1", "2", 0])
  295:         tm.assert_series_equal(ser, expected)
  296: 
  297:     def test_setitem_mask_promote(self):
  298:         ser = Series([0, "foo", "bar", 0])
  299:         mask = Series([False, True, True, False])
  300:         ser2 = ser[mask]
  301:         ser[mask] = ser2
  302: 
  303:         expected = Series([0, "foo", "bar", 0])
  304:         tm.assert_series_equal(ser, expected)
  305: 
  306:     def test_setitem_boolean(self, string_series):
  307:         mask = string_series > string_series.median()
  308: 
  309:         # similar indexed series
  310:         result = string_series.copy()
  311:         result[mask] = string_series * 2
  312:         expected = string_series * 2
  313:         tm.assert_series_equal(result[mask], expected[mask])
  314: 
  315:         # needs alignment
  316:         result = string_series.copy()
  317:         result[mask] = (string_series * 2)[0:5]
  318:         expected = (string_series * 2)[0:5].reindex_like(string_series)
  319:         expected[-mask] = string_series[mask]
  320:         tm.assert_series_equal(result[mask], expected[mask])
  321: 
  322:     def test_setitem_boolean_corner(self, datetime_series):
  323:         ts = datetime_series
  324:         mask_shifted = ts.shift(1, freq=BDay()) > ts.median()
  325: 
  326:         msg = (
  327:             r"Unalignable boolean Series provided as indexer \(index of "
  328:             r"the boolean Series and of the indexed object do not match"
  329:         )
  330:         with pytest.raises(IndexingError, match=msg):
  331:             ts[mask_shifted] = 1
  332: 
  333:         with pytest.raises(IndexingError, match=msg):
  334:             ts.loc[mask_shifted] = 1
  335: 
  336:     def test_setitem_boolean_different_order(self, string_series):
  337:         ordered = string_series.sort_values()
  338: 
  339:         copy = string_series.copy()
  340:         copy[ordered > 0] = 0
  341: 
  342:         expected = string_series.copy()
  343:         expected[expected > 0] = 0
  344: 
  345:         tm.assert_series_equal(copy, expected)
  346: 
  347:     @pytest.mark.parametrize("func", [list, np.array, Series])
  348:     def test_setitem_boolean_python_list(self, func):
  349:         # GH19406
  350:         ser = Series([None, "b", None])
  351:         mask = func([True, False, True])
  352:         ser[mask] = ["a", "c"]
  353:         expected = Series(["a", "b", "c"])
  354:         tm.assert_series_equal(ser, expected)
  355: 
  356:     def test_setitem_boolean_nullable_int_types(self, any_numeric_ea_dtype):
  357:         # GH: 26468
  358:         ser = Series([5, 6, 7, 8], dtype=any_numeric_ea_dtype)
  359:         ser[ser > 6] = Series(range(4), dtype=any_numeric_ea_dtype)
  360:         expected = Series([5, 6, 2, 3], dtype=any_numeric_ea_dtype)
  361:         tm.assert_series_equal(ser, expected)
  362: 
  363:         ser = Series([5, 6, 7, 8], dtype=any_numeric_ea_dtype)
  364:         ser.loc[ser > 6] = Series(range(4), dtype=any_numeric_ea_dtype)
  365:         tm.assert_series_equal(ser, expected)
  366: 
  367:         ser = Series([5, 6, 7, 8], dtype=any_numeric_ea_dtype)
  368:         loc_ser = Series(range(4), dtype=any_numeric_ea_dtype)
  369:         ser.loc[ser > 6] = loc_ser.loc[loc_ser > 1]
  370:         tm.assert_series_equal(ser, expected)
  371: 
  372:     def test_setitem_with_bool_mask_and_values_matching_n_trues_in_length(self):
  373:         # GH#30567
  374:         ser = Series([None] * 10)
  375:         mask = [False] * 3 + [True] * 5 + [False] * 2
  376:         ser[mask] = range(5)
  377:         result = ser
  378:         expected = Series([None] * 3 + list(range(5)) + [None] * 2, dtype=object)
  379:         tm.assert_series_equal(result, expected)
  380: 
  381:     def test_setitem_nan_with_bool(self):
  382:         # GH 13034
  383:         result = Series([True, False, True])
  384:         with tm.assert_produces_warning(
  385:             FutureWarning, match="item of incompatible dtype"
  386:         ):
  387:             result[0] = np.nan
  388:         expected = Series([np.nan, False, True], dtype=object)
  389:         tm.assert_series_equal(result, expected)
  390: 
  391:     def test_setitem_mask_smallint_upcast(self):
  392:         orig = Series([1, 2, 3], dtype="int8")
  393:         alt = np.array([999, 1000, 1001], dtype=np.int64)
  394: 
  395:         mask = np.array([True, False, True])
  396: 
  397:         ser = orig.copy()
  398:         with tm.assert_produces_warning(
  399:             FutureWarning, match="item of incompatible dtype"
  400:         ):
  401:             ser[mask] = Series(alt)
  402:         expected = Series([999, 2, 1001])
  403:         tm.assert_series_equal(ser, expected)
  404: 
  405:         ser2 = orig.copy()
  406:         with tm.assert_produces_warning(
  407:             FutureWarning, match="item of incompatible dtype"
  408:         ):
  409:             ser2.mask(mask, alt, inplace=True)
  410:         tm.assert_series_equal(ser2, expected)
  411: 
  412:         ser3 = orig.copy()
  413:         res = ser3.where(~mask, Series(alt))
  414:         tm.assert_series_equal(res, expected)
  415: 
  416:     def test_setitem_mask_smallint_no_upcast(self):
  417:         # like test_setitem_mask_smallint_upcast, but while we can't hold 'alt',
  418:         #  we *can* hold alt[mask] without casting
  419:         orig = Series([1, 2, 3], dtype="uint8")
  420:         alt = Series([245, 1000, 246], dtype=np.int64)
  421: 
  422:         mask = np.array([True, False, True])
  423: 
  424:         ser = orig.copy()
  425:         ser[mask] = alt
  426:         expected = Series([245, 2, 246], dtype="uint8")
  427:         tm.assert_series_equal(ser, expected)
  428: 
  429:         ser2 = orig.copy()
  430:         ser2.mask(mask, alt, inplace=True)
  431:         tm.assert_series_equal(ser2, expected)
  432: 
  433:         # TODO: ser.where(~mask, alt) unnecessarily upcasts to int64
  434:         ser3 = orig.copy()
  435:         res = ser3.where(~mask, alt)
  436:         tm.assert_series_equal(res, expected, check_dtype=False)
  437: 
  438: 
  439: class TestSetitemViewCopySemantics:
  440:     def test_setitem_invalidates_datetime_index_freq(self, using_copy_on_write):
  441:         # GH#24096 altering a datetime64tz Series inplace invalidates the
  442:         #  `freq` attribute on the underlying DatetimeIndex
  443: 
  444:         dti = date_range("20130101", periods=3, tz="US/Eastern")
  445:         ts = dti[1]
  446:         ser = Series(dti)
  447:         assert ser._values is not dti
  448:         if using_copy_on_write:
  449:             assert ser._values._ndarray.base is dti._data._ndarray.base
  450:         else:
  451:             assert ser._values._ndarray.base is not dti._data._ndarray.base
  452:         assert dti.freq == "D"
  453:         ser.iloc[1] = NaT
  454:         assert ser._values.freq is None
  455: 
  456:         # check that the DatetimeIndex was not altered in place
  457:         assert ser._values is not dti
  458:         assert ser._values._ndarray.base is not dti._data._ndarray.base
  459:         assert dti[1] == ts
  460:         assert dti.freq == "D"
  461: 
  462:     def test_dt64tz_setitem_does_not_mutate_dti(self, using_copy_on_write):
  463:         # GH#21907, GH#24096
  464:         dti = date_range("2016-01-01", periods=10, tz="US/Pacific")
  465:         ts = dti[0]
  466:         ser = Series(dti)
  467:         assert ser._values is not dti
  468:         if using_copy_on_write:
  469:             assert ser._values._ndarray.base is dti._data._ndarray.base
  470:             assert ser._mgr.arrays[0]._ndarray.base is dti._data._ndarray.base
  471:         else:
  472:             assert ser._values._ndarray.base is not dti._data._ndarray.base
  473:             assert ser._mgr.arrays[0]._ndarray.base is not dti._data._ndarray.base
  474: 
  475:         assert ser._mgr.arrays[0] is not dti
  476: 
  477:         ser[::3] = NaT
  478:         assert ser[0] is NaT
  479:         assert dti[0] == ts
  480: 
  481: 
  482: class TestSetitemCallable:
  483:     def test_setitem_callable_key(self):
  484:         # GH#12533
  485:         ser = Series([1, 2, 3, 4], index=list("ABCD"))
  486:         ser[lambda x: "A"] = -1
  487: 
  488:         expected = Series([-1, 2, 3, 4], index=list("ABCD"))
  489:         tm.assert_series_equal(ser, expected)
  490: 
  491:     def test_setitem_callable_other(self):
  492:         # GH#13299
  493:         inc = lambda x: x + 1
  494: 
  495:         # set object dtype to avoid upcast when setting inc
  496:         ser = Series([1, 2, -1, 4], dtype=object)
  497:         ser[ser < 0] = inc
  498: 
  499:         expected = Series([1, 2, inc, 4])
  500:         tm.assert_series_equal(ser, expected)
  501: 
  502: 
  503: class TestSetitemWithExpansion:
  504:     def test_setitem_empty_series(self):
  505:         # GH#10193
  506:         key = Timestamp("2012-01-01")
  507:         series = Series(dtype=object)
  508:         series[key] = 47
  509:         expected = Series(47, [key])
  510:         tm.assert_series_equal(series, expected)
  511: 
  512:     def test_setitem_empty_series_datetimeindex_preserves_freq(self):
  513:         # GH#33573 our index should retain its freq
  514:         dti = DatetimeIndex([], freq="D", dtype="M8[ns]")
  515:         series = Series([], index=dti, dtype=object)
  516:         key = Timestamp("2012-01-01")
  517:         series[key] = 47
  518:         expected = Series(47, DatetimeIndex([key], freq="D").as_unit("ns"))
  519:         tm.assert_series_equal(series, expected)
  520:         assert series.index.freq == expected.index.freq
  521: 
  522:     def test_setitem_empty_series_timestamp_preserves_dtype(self):
  523:         # GH 21881
  524:         timestamp = Timestamp(1412526600000000000)
  525:         series = Series([timestamp], index=["timestamp"], dtype=object)
  526:         expected = series["timestamp"]
  527: 
  528:         series = Series([], dtype=object)
  529:         series["anything"] = 300.0
  530:         series["timestamp"] = timestamp
  531:         result = series["timestamp"]
  532:         assert result == expected
  533: 
  534:     @pytest.mark.parametrize(
  535:         "td",
  536:         [
  537:             Timedelta("9 days"),
  538:             Timedelta("9 days").to_timedelta64(),
  539:             Timedelta("9 days").to_pytimedelta(),
  540:         ],
  541:     )
  542:     def test_append_timedelta_does_not_cast(self, td, using_infer_string, request):
  543:         # GH#22717 inserting a Timedelta should _not_ cast to int64
  544:         if using_infer_string and not isinstance(td, Timedelta):
  545:             # TODO: GH#56010
  546:             request.applymarker(pytest.mark.xfail(reason="inferred as string"))
  547: 
  548:         expected = Series(["x", td], index=[0, "td"], dtype=object)
  549: 
  550:         ser = Series(["x"])
  551:         ser["td"] = td
  552:         tm.assert_series_equal(ser, expected)
  553:         assert isinstance(ser["td"], Timedelta)
  554: 
  555:         ser = Series(["x"])
  556:         ser.loc["td"] = Timedelta("9 days")
  557:         tm.assert_series_equal(ser, expected)
  558:         assert isinstance(ser["td"], Timedelta)
  559: 
  560:     def test_setitem_with_expansion_type_promotion(self):
  561:         # GH#12599
  562:         ser = Series(dtype=object)
  563:         ser["a"] = Timestamp("2016-01-01")
  564:         ser["b"] = 3.0
  565:         ser["c"] = "foo"
  566:         expected = Series([Timestamp("2016-01-01"), 3.0, "foo"], index=["a", "b", "c"])
  567:         tm.assert_series_equal(ser, expected)
  568: 
  569:     def test_setitem_not_contained(self, string_series):
  570:         # set item that's not contained
  571:         ser = string_series.copy()
  572:         assert "foobar" not in ser.index
  573:         ser["foobar"] = 1
  574: 
  575:         app = Series([1], index=["foobar"], name="series")
  576:         expected = concat([string_series, app])
  577:         tm.assert_series_equal(ser, expected)
  578: 
  579:     def test_setitem_keep_precision(self, any_numeric_ea_dtype):
  580:         # GH#32346
  581:         ser = Series([1, 2], dtype=any_numeric_ea_dtype)
  582:         ser[2] = 10
  583:         expected = Series([1, 2, 10], dtype=any_numeric_ea_dtype)
  584:         tm.assert_series_equal(ser, expected)
  585: 
  586:     @pytest.mark.parametrize(
  587:         "na, target_na, dtype, target_dtype, indexer, warn",
  588:         [
  589:             (NA, NA, "Int64", "Int64", 1, None),
  590:             (NA, NA, "Int64", "Int64", 2, None),
  591:             (NA, np.nan, "int64", "float64", 1, None),
  592:             (NA, np.nan, "int64", "float64", 2, None),
  593:             (NaT, NaT, "int64", "object", 1, FutureWarning),
  594:             (NaT, NaT, "int64", "object", 2, None),
  595:             (np.nan, NA, "Int64", "Int64", 1, None),
  596:             (np.nan, NA, "Int64", "Int64", 2, None),
  597:             (np.nan, NA, "Float64", "Float64", 1, None),
  598:             (np.nan, NA, "Float64", "Float64", 2, None),
  599:             (np.nan, np.nan, "int64", "float64", 1, None),
  600:             (np.nan, np.nan, "int64", "float64", 2, None),
  601:         ],
  602:     )
  603:     def test_setitem_enlarge_with_na(
  604:         self, na, target_na, dtype, target_dtype, indexer, warn
  605:     ):
  606:         # GH#32346
  607:         ser = Series([1, 2], dtype=dtype)
  608:         with tm.assert_produces_warning(warn, match="incompatible dtype"):
  609:             ser[indexer] = na
  610:         expected_values = [1, target_na] if indexer == 1 else [1, 2, target_na]
  611:         expected = Series(expected_values, dtype=target_dtype)
  612:         tm.assert_series_equal(ser, expected)
  613: 
  614:     def test_setitem_enlargement_object_none(self, nulls_fixture, using_infer_string):
  615:         # GH#48665
  616:         ser = Series(["a", "b"])
  617:         ser[3] = nulls_fixture
  618:         dtype = (
  619:             "string[pyarrow_numpy]"
  620:             if using_infer_string and not isinstance(nulls_fixture, Decimal)
  621:             else object
  622:         )
  623:         expected = Series(["a", "b", nulls_fixture], index=[0, 1, 3], dtype=dtype)
  624:         tm.assert_series_equal(ser, expected)
  625:         if using_infer_string:
  626:             ser[3] is np.nan
  627:         else:
  628:             assert ser[3] is nulls_fixture
  629: 
  630: 
  631: def test_setitem_scalar_into_readonly_backing_data():
  632:     # GH#14359: test that you cannot mutate a read only buffer
  633: 
  634:     array = np.zeros(5)
  635:     array.flags.writeable = False  # make the array immutable
  636:     series = Series(array, copy=False)
  637: 
  638:     for n in series.index:
  639:         msg = "assignment destination is read-only"
  640:         with pytest.raises(ValueError, match=msg):
  641:             series[n] = 1
  642: 
  643:         assert array[n] == 0
  644: 
  645: 
  646: def test_setitem_slice_into_readonly_backing_data():
  647:     # GH#14359: test that you cannot mutate a read only buffer
  648: 
  649:     array = np.zeros(5)
  650:     array.flags.writeable = False  # make the array immutable
  651:     series = Series(array, copy=False)
  652: 
  653:     msg = "assignment destination is read-only"
  654:     with pytest.raises(ValueError, match=msg):
  655:         series[1:3] = 1
  656: 
  657:     assert not array.any()
  658: 
  659: 
  660: def test_setitem_categorical_assigning_ops():
  661:     orig = Series(Categorical(["b", "b"], categories=["a", "b"]))
  662:     ser = orig.copy()
  663:     ser[:] = "a"
  664:     exp = Series(Categorical(["a", "a"], categories=["a", "b"]))
  665:     tm.assert_series_equal(ser, exp)
  666: 
  667:     ser = orig.copy()
  668:     ser[1] = "a"
  669:     exp = Series(Categorical(["b", "a"], categories=["a", "b"]))
  670:     tm.assert_series_equal(ser, exp)
  671: 
  672:     ser = orig.copy()
  673:     ser[ser.index > 0] = "a"
  674:     exp = Series(Categorical(["b", "a"], categories=["a", "b"]))
  675:     tm.assert_series_equal(ser, exp)
  676: 
  677:     ser = orig.copy()
  678:     ser[[False, True]] = "a"
  679:     exp = Series(Categorical(["b", "a"], categories=["a", "b"]))
  680:     tm.assert_series_equal(ser, exp)
  681: 
  682:     ser = orig.copy()
  683:     ser.index = ["x", "y"]
  684:     ser["y"] = "a"
  685:     exp = Series(Categorical(["b", "a"], categories=["a", "b"]), index=["x", "y"])
  686:     tm.assert_series_equal(ser, exp)
  687: 
  688: 
  689: def test_setitem_nan_into_categorical():
  690:     # ensure that one can set something to np.nan
  691:     ser = Series(Categorical([1, 2, 3]))
  692:     exp = Series(Categorical([1, np.nan, 3], categories=[1, 2, 3]))
  693:     ser[1] = np.nan
  694:     tm.assert_series_equal(ser, exp)
  695: 
  696: 
  697: class TestSetitemCasting:
  698:     @pytest.mark.parametrize("unique", [True, False])
  699:     @pytest.mark.parametrize("val", [3, 3.0, "3"], ids=type)
  700:     def test_setitem_non_bool_into_bool(self, val, indexer_sli, unique):
  701:         # dont cast these 3-like values to bool
  702:         ser = Series([True, False])
  703:         if not unique:
  704:             ser.index = [1, 1]
  705: 
  706:         with tm.assert_produces_warning(FutureWarning, match="incompatible dtype"):
  707:             indexer_sli(ser)[1] = val
  708:         assert type(ser.iloc[1]) == type(val)
  709: 
  710:         expected = Series([True, val], dtype=object, index=ser.index)
  711:         if not unique and indexer_sli is not tm.iloc:
  712:             expected = Series([val, val], dtype=object, index=[1, 1])
  713:         tm.assert_series_equal(ser, expected)
  714: 
  715:     def test_setitem_boolean_array_into_npbool(self):
  716:         # GH#45462
  717:         ser = Series([True, False, True])
  718:         values = ser._values
  719:         arr = array([True, False, None])
  720: 
  721:         ser[:2] = arr[:2]  # no NAs -> can set inplace
  722:         assert ser._values is values
  723: 
  724:         with tm.assert_produces_warning(FutureWarning, match="incompatible dtype"):
  725:             ser[1:] = arr[1:]  # has an NA -> cast to boolean dtype
  726:         expected = Series(arr)
  727:         tm.assert_series_equal(ser, expected)
  728: 
  729: 
  730: class SetitemCastingEquivalents:
  731:     """
  732:     Check each of several methods that _should_ be equivalent to `obj[key] = val`
  733: 
  734:     We assume that
  735:         - obj.index is the default Index(range(len(obj)))
  736:         - the setitem does not expand the obj
  737:     """
  738: 
  739:     @pytest.fixture
  740:     def is_inplace(self, obj, expected):
  741:         """
  742:         Whether we expect the setting to be in-place or not.
  743:         """
  744:         return expected.dtype == obj.dtype
  745: 
  746:     def check_indexer(self, obj, key, expected, val, indexer, is_inplace):
  747:         orig = obj
  748:         obj = obj.copy()
  749:         arr = obj._values
  750: 
  751:         indexer(obj)[key] = val
  752:         tm.assert_series_equal(obj, expected)
  753: 
  754:         self._check_inplace(is_inplace, orig, arr, obj)
  755: 
  756:     def _check_inplace(self, is_inplace, orig, arr, obj):
  757:         if is_inplace is None:
  758:             # We are not (yet) checking whether setting is inplace or not
  759:             pass
  760:         elif is_inplace:
  761:             if arr.dtype.kind in ["m", "M"]:
  762:                 # We may not have the same DTA/TDA, but will have the same
  763:                 #  underlying data
  764:                 assert arr._ndarray is obj._values._ndarray
  765:             else:
  766:                 assert obj._values is arr
  767:         else:
  768:             # otherwise original array should be unchanged
  769:             tm.assert_equal(arr, orig._values)
  770: 
  771:     def test_int_key(self, obj, key, expected, warn, val, indexer_sli, is_inplace):
  772:         if not isinstance(key, int):
  773:             pytest.skip("Not relevant for int key")
  774: 
  775:         with tm.assert_produces_warning(warn, match="incompatible dtype"):
  776:             self.check_indexer(obj, key, expected, val, indexer_sli, is_inplace)
  777: 
  778:         if indexer_sli is tm.loc:
  779:             with tm.assert_produces_warning(warn, match="incompatible dtype"):
  780:                 self.check_indexer(obj, key, expected, val, tm.at, is_inplace)
  781:         elif indexer_sli is tm.iloc:
  782:             with tm.assert_produces_warning(warn, match="incompatible dtype"):
  783:                 self.check_indexer(obj, key, expected, val, tm.iat, is_inplace)
  784: 
  785:         rng = range(key, key + 1)
  786:         with tm.assert_produces_warning(warn, match="incompatible dtype"):
  787:             self.check_indexer(obj, rng, expected, val, indexer_sli, is_inplace)
  788: 
  789:         if indexer_sli is not tm.loc:
  790:             # Note: no .loc because that handles slice edges differently
  791:             slc = slice(key, key + 1)
  792:             with tm.assert_produces_warning(warn, match="incompatible dtype"):
  793:                 self.check_indexer(obj, slc, expected, val, indexer_sli, is_inplace)
  794: 
  795:         ilkey = [key]
  796:         with tm.assert_produces_warning(warn, match="incompatible dtype"):
  797:             self.check_indexer(obj, ilkey, expected, val, indexer_sli, is_inplace)
  798: 
  799:         indkey = np.array(ilkey)
  800:         with tm.assert_produces_warning(warn, match="incompatible dtype"):
  801:             self.check_indexer(obj, indkey, expected, val, indexer_sli, is_inplace)
  802: 
  803:         genkey = (x for x in [key])
  804:         with tm.assert_produces_warning(warn, match="incompatible dtype"):
  805:             self.check_indexer(obj, genkey, expected, val, indexer_sli, is_inplace)
  806: 
  807:     def test_slice_key(self, obj, key, expected, warn, val, indexer_sli, is_inplace):
  808:         if not isinstance(key, slice):
  809:             pytest.skip("Not relevant for slice key")
  810: 
  811:         if indexer_sli is not tm.loc:
  812:             # Note: no .loc because that handles slice edges differently
  813:             with tm.assert_produces_warning(warn, match="incompatible dtype"):
  814:                 self.check_indexer(obj, key, expected, val, indexer_sli, is_inplace)
  815: 
  816:         ilkey = list(range(len(obj)))[key]
  817:         with tm.assert_produces_warning(warn, match="incompatible dtype"):
  818:             self.check_indexer(obj, ilkey, expected, val, indexer_sli, is_inplace)
  819: 
  820:         indkey = np.array(ilkey)
  821:         with tm.assert_produces_warning(warn, match="incompatible dtype"):
  822:             self.check_indexer(obj, indkey, expected, val, indexer_sli, is_inplace)
  823: 
  824:         genkey = (x for x in indkey)
  825:         with tm.assert_produces_warning(warn, match="incompatible dtype"):
  826:             self.check_indexer(obj, genkey, expected, val, indexer_sli, is_inplace)
  827: 
  828:     def test_mask_key(self, obj, key, expected, warn, val, indexer_sli):
  829:         # setitem with boolean mask
  830:         mask = np.zeros(obj.shape, dtype=bool)
  831:         mask[key] = True
  832: 
  833:         obj = obj.copy()
  834: 
  835:         if is_list_like(val) and len(val) < mask.sum():
  836:             msg = "boolean index did not match indexed array along dimension"
  837:             with pytest.raises(IndexError, match=msg):
  838:                 indexer_sli(obj)[mask] = val
  839:             return
  840: 
  841:         with tm.assert_produces_warning(warn, match="incompatible dtype"):
  842:             indexer_sli(obj)[mask] = val
  843:         tm.assert_series_equal(obj, expected)
  844: 
  845:     def test_series_where(self, obj, key, expected, warn, val, is_inplace):
  846:         mask = np.zeros(obj.shape, dtype=bool)
  847:         mask[key] = True
  848: 
  849:         if is_list_like(val) and len(val) < len(obj):
  850:             # Series.where is not valid here
  851:             msg = "operands could not be broadcast together with shapes"
  852:             with pytest.raises(ValueError, match=msg):
  853:                 obj.where(~mask, val)
  854:             return
  855: 
  856:         orig = obj
  857:         obj = obj.copy()
  858:         arr = obj._values
  859: 
  860:         res = obj.where(~mask, val)
  861: 
  862:         if val is NA and res.dtype == object:
  863:             expected = expected.fillna(NA)
  864:         elif val is None and res.dtype == object:
  865:             assert expected.dtype == object
  866:             expected = expected.copy()
  867:             expected[expected.isna()] = None
  868:         tm.assert_series_equal(res, expected)
  869: 
  870:         self._check_inplace(is_inplace, orig, arr, obj)
  871: 
  872:     def test_index_where(self, obj, key, expected, warn, val, using_infer_string):
  873:         mask = np.zeros(obj.shape, dtype=bool)
  874:         mask[key] = True
  875: 
  876:         if using_infer_string and obj.dtype == object:
  877:             with pytest.raises(TypeError, match="Scalar must"):
  878:                 Index(obj).where(~mask, val)
  879:         else:
  880:             res = Index(obj).where(~mask, val)
  881:             expected_idx = Index(expected, dtype=expected.dtype)
  882:             tm.assert_index_equal(res, expected_idx)
  883: 
  884:     def test_index_putmask(self, obj, key, expected, warn, val, using_infer_string):
  885:         mask = np.zeros(obj.shape, dtype=bool)
  886:         mask[key] = True
  887: 
  888:         if using_infer_string and obj.dtype == object:
  889:             with pytest.raises(TypeError, match="Scalar must"):
  890:                 Index(obj).putmask(mask, val)
  891:         else:
  892:             res = Index(obj).putmask(mask, val)
  893:             tm.assert_index_equal(res, Index(expected, dtype=expected.dtype))
  894: 
  895: 
  896: @pytest.mark.parametrize(
  897:     "obj,expected,key,warn",
  898:     [
  899:         pytest.param(
  900:             # GH#45568 setting a valid NA value into IntervalDtype[int] should
  901:             #  cast to IntervalDtype[float]
  902:             Series(interval_range(1, 5)),
  903:             Series(
  904:                 [Interval(1, 2), np.nan, Interval(3, 4), Interval(4, 5)],
  905:                 dtype="interval[float64]",
  906:             ),
  907:             1,
  908:             FutureWarning,
  909:             id="interval_int_na_value",
  910:         ),
  911:         pytest.param(
  912:             # these induce dtype changes
  913:             Series([2, 3, 4, 5, 6, 7, 8, 9, 10]),
  914:             Series([np.nan, 3, np.nan, 5, np.nan, 7, np.nan, 9, np.nan]),
  915:             slice(None, None, 2),
  916:             None,
  917:             id="int_series_slice_key_step",
  918:         ),
  919:         pytest.param(
  920:             Series([True, True, False, False]),
  921:             Series([np.nan, True, np.nan, False], dtype=object),
  922:             slice(None, None, 2),
  923:             FutureWarning,
  924:             id="bool_series_slice_key_step",
  925:         ),
  926:         pytest.param(
  927:             # these induce dtype changes
  928:             Series(np.arange(10)),
  929:             Series([np.nan, np.nan, np.nan, np.nan, np.nan, 5, 6, 7, 8, 9]),
  930:             slice(None, 5),
  931:             None,
  932:             id="int_series_slice_key",
  933:         ),
  934:         pytest.param(
  935:             # changes dtype GH#4463
  936:             Series([1, 2, 3]),
  937:             Series([np.nan, 2, 3]),
  938:             0,
  939:             None,
  940:             id="int_series_int_key",
  941:         ),
  942:         pytest.param(
  943:             # changes dtype GH#4463
  944:             Series([False]),
  945:             Series([np.nan], dtype=object),
  946:             # TODO: maybe go to float64 since we are changing the _whole_ Series?
  947:             0,
  948:             FutureWarning,
  949:             id="bool_series_int_key_change_all",
  950:         ),
  951:         pytest.param(
  952:             # changes dtype GH#4463
  953:             Series([False, True]),
  954:             Series([np.nan, True], dtype=object),
  955:             0,
  956:             FutureWarning,
  957:             id="bool_series_int_key",
  958:         ),
  959:     ],
  960: )
  961: class TestSetitemCastingEquivalents(SetitemCastingEquivalents):
  962:     @pytest.fixture(params=[np.nan, np.float64("NaN"), None, NA])
  963:     def val(self, request):
  964:         """
  965:         NA values that should generally be valid_na for *all* dtypes.
  966: 
  967:         Include both python float NaN and np.float64; only np.float64 has a
  968:         `dtype` attribute.
  969:         """
  970:         return request.param
  971: 
  972: 
  973: class TestSetitemTimedelta64IntoNumeric(SetitemCastingEquivalents):
  974:     # timedelta64 should not be treated as integers when setting into
  975:     #  numeric Series
  976: 
  977:     @pytest.fixture
  978:     def val(self):
  979:         td = np.timedelta64(4, "ns")
  980:         return td
  981:         # TODO: could also try np.full((1,), td)
  982: 
  983:     @pytest.fixture(params=[complex, int, float])
  984:     def dtype(self, request):
  985:         return request.param
  986: 
  987:     @pytest.fixture
  988:     def obj(self, dtype):
  989:         arr = np.arange(5).astype(dtype)
  990:         ser = Series(arr)
  991:         return ser
  992: 
  993:     @pytest.fixture
  994:     def expected(self, dtype):
  995:         arr = np.arange(5).astype(dtype)
  996:         ser = Series(arr)
  997:         ser = ser.astype(object)
  998:         ser.iloc[0] = np.timedelta64(4, "ns")
  999:         return ser
 1000: 
 1001:     @pytest.fixture
 1002:     def key(self):
 1003:         return 0
 1004: 
 1005:     @pytest.fixture
 1006:     def warn(self):
 1007:         return FutureWarning
 1008: 
 1009: 
 1010: class TestSetitemDT64IntoInt(SetitemCastingEquivalents):
 1011:     # GH#39619 dont cast dt64 to int when doing this setitem
 1012: 
 1013:     @pytest.fixture(params=["M8[ns]", "m8[ns]"])
 1014:     def dtype(self, request):
 1015:         return request.param
 1016: 
 1017:     @pytest.fixture
 1018:     def scalar(self, dtype):
 1019:         val = np.datetime64("2021-01-18 13:25:00", "ns")
 1020:         if dtype == "m8[ns]":
 1021:             val = val - val
 1022:         return val
 1023: 
 1024:     @pytest.fixture
 1025:     def expected(self, scalar):
 1026:         expected = Series([scalar, scalar, 3], dtype=object)
 1027:         assert isinstance(expected[0], type(scalar))
 1028:         return expected
 1029: 
 1030:     @pytest.fixture
 1031:     def obj(self):
 1032:         return Series([1, 2, 3])
 1033: 
 1034:     @pytest.fixture
 1035:     def key(self):
 1036:         return slice(None, -1)
 1037: 
 1038:     @pytest.fixture(params=[None, list, np.array])
 1039:     def val(self, scalar, request):
 1040:         box = request.param
 1041:         if box is None:
 1042:             return scalar
 1043:         return box([scalar, scalar])
 1044: 
 1045:     @pytest.fixture
 1046:     def warn(self):
 1047:         return FutureWarning
 1048: 
 1049: 
 1050: class TestSetitemNAPeriodDtype(SetitemCastingEquivalents):
 1051:     # Setting compatible NA values into Series with PeriodDtype
 1052: 
 1053:     @pytest.fixture
 1054:     def expected(self, key):
 1055:         exp = Series(period_range("2000-01-01", periods=10, freq="D"))
 1056:         exp._values.view("i8")[key] = NaT._value
 1057:         assert exp[key] is NaT or all(x is NaT for x in exp[key])
 1058:         return exp
 1059: 
 1060:     @pytest.fixture
 1061:     def obj(self):
 1062:         return Series(period_range("2000-01-01", periods=10, freq="D"))
 1063: 
 1064:     @pytest.fixture(params=[3, slice(3, 5)])
 1065:     def key(self, request):
 1066:         return request.param
 1067: 
 1068:     @pytest.fixture(params=[None, np.nan])
 1069:     def val(self, request):
 1070:         return request.param
 1071: 
 1072:     @pytest.fixture
 1073:     def warn(self):
 1074:         return None
 1075: 
 1076: 
 1077: class TestSetitemNADatetimeLikeDtype(SetitemCastingEquivalents):
 1078:     # some nat-like values should be cast to datetime64/timedelta64 when
 1079:     #  inserting into a datetime64/timedelta64 series.  Others should coerce
 1080:     #  to object and retain their dtypes.
 1081:     # GH#18586 for td64 and boolean mask case
 1082: 
 1083:     @pytest.fixture(
 1084:         params=["m8[ns]", "M8[ns]", "datetime64[ns, UTC]", "datetime64[ns, US/Central]"]
 1085:     )
 1086:     def dtype(self, request):
 1087:         return request.param
 1088: 
 1089:     @pytest.fixture
 1090:     def obj(self, dtype):
 1091:         i8vals = date_range("2016-01-01", periods=3).asi8
 1092:         idx = Index(i8vals, dtype=dtype)
 1093:         assert idx.dtype == dtype
 1094:         return Series(idx)
 1095: 
 1096:     @pytest.fixture(
 1097:         params=[
 1098:             None,
 1099:             np.nan,
 1100:             NaT,
 1101:             np.timedelta64("NaT", "ns"),
 1102:             np.datetime64("NaT", "ns"),
 1103:         ]
 1104:     )
 1105:     def val(self, request):
 1106:         return request.param
 1107: 
 1108:     @pytest.fixture
 1109:     def is_inplace(self, val, obj):
 1110:         # td64   -> cast to object iff val is datetime64("NaT")
 1111:         # dt64   -> cast to object iff val is timedelta64("NaT")
 1112:         # dt64tz -> cast to object with anything _but_ NaT
 1113:         return val is NaT or val is None or val is np.nan or obj.dtype == val.dtype
 1114: 
 1115:     @pytest.fixture
 1116:     def expected(self, obj, val, is_inplace):
 1117:         dtype = obj.dtype if is_inplace else object
 1118:         expected = Series([val] + list(obj[1:]), dtype=dtype)
 1119:         return expected
 1120: 
 1121:     @pytest.fixture
 1122:     def key(self):
 1123:         return 0
 1124: 
 1125:     @pytest.fixture
 1126:     def warn(self, is_inplace):
 1127:         return None if is_inplace else FutureWarning
 1128: 
 1129: 
 1130: class TestSetitemMismatchedTZCastsToObject(SetitemCastingEquivalents):
 1131:     # GH#24024
 1132:     @pytest.fixture
 1133:     def obj(self):
 1134:         return Series(date_range("2000", periods=2, tz="US/Central"))
 1135: 
 1136:     @pytest.fixture
 1137:     def val(self):
 1138:         return Timestamp("2000", tz="US/Eastern")
 1139: 
 1140:     @pytest.fixture
 1141:     def key(self):
 1142:         return 0
 1143: 
 1144:     @pytest.fixture
 1145:     def expected(self, obj, val):
 1146:         # pre-2.0 this would cast to object, in 2.0 we cast the val to
 1147:         #  the target tz
 1148:         expected = Series(
 1149:             [
 1150:                 val.tz_convert("US/Central"),
 1151:                 Timestamp("2000-01-02 00:00:00-06:00", tz="US/Central"),
 1152:             ],
 1153:             dtype=obj.dtype,
 1154:         )
 1155:         return expected
 1156: 
 1157:     @pytest.fixture
 1158:     def warn(self):
 1159:         return None
 1160: 
 1161: 
 1162: @pytest.mark.parametrize(
 1163:     "obj,expected,warn",
 1164:     [
 1165:         # For numeric series, we should coerce to NaN.
 1166:         (Series([1, 2, 3]), Series([np.nan, 2, 3]), None),
 1167:         (Series([1.0, 2.0, 3.0]), Series([np.nan, 2.0, 3.0]), None),
 1168:         # For datetime series, we should coerce to NaT.
 1169:         (
 1170:             Series([datetime(2000, 1, 1), datetime(2000, 1, 2), datetime(2000, 1, 3)]),
 1171:             Series([NaT, datetime(2000, 1, 2), datetime(2000, 1, 3)]),
 1172:             None,
 1173:         ),
 1174:         # For objects, we should preserve the None value.
 1175:         (Series(["foo", "bar", "baz"]), Series([None, "bar", "baz"]), None),
 1176:     ],
 1177: )
 1178: class TestSeriesNoneCoercion(SetitemCastingEquivalents):
 1179:     @pytest.fixture
 1180:     def key(self):
 1181:         return 0
 1182: 
 1183:     @pytest.fixture
 1184:     def val(self):
 1185:         return None
 1186: 
 1187: 
 1188: class TestSetitemFloatIntervalWithIntIntervalValues(SetitemCastingEquivalents):
 1189:     # GH#44201 Cast to shared IntervalDtype rather than object
 1190: 
 1191:     def test_setitem_example(self):
 1192:         # Just a case here to make obvious what this test class is aimed at
 1193:         idx = IntervalIndex.from_breaks(range(4))
 1194:         obj = Series(idx)
 1195:         val = Interval(0.5, 1.5)
 1196: 
 1197:         with tm.assert_produces_warning(
 1198:             FutureWarning, match="Setting an item of incompatible dtype"
 1199:         ):
 1200:             obj[0] = val
 1201:         assert obj.dtype == "Interval[float64, right]"
 1202: 
 1203:     @pytest.fixture
 1204:     def obj(self):
 1205:         idx = IntervalIndex.from_breaks(range(4))
 1206:         return Series(idx)
 1207: 
 1208:     @pytest.fixture
 1209:     def val(self):
 1210:         return Interval(0.5, 1.5)
 1211: 
 1212:     @pytest.fixture
 1213:     def key(self):
 1214:         return 0
 1215: 
 1216:     @pytest.fixture
 1217:     def expected(self, obj, val):
 1218:         data = [val] + list(obj[1:])
 1219:         idx = IntervalIndex(data, dtype="Interval[float64]")
 1220:         return Series(idx)
 1221: 
 1222:     @pytest.fixture
 1223:     def warn(self):
 1224:         return FutureWarning
 1225: 
 1226: 
 1227: class TestSetitemRangeIntoIntegerSeries(SetitemCastingEquivalents):
 1228:     # GH#44261 Setting a range with sufficiently-small integers into
 1229:     #  small-itemsize integer dtypes should not need to upcast
 1230: 
 1231:     @pytest.fixture
 1232:     def obj(self, any_int_numpy_dtype):
 1233:         dtype = np.dtype(any_int_numpy_dtype)
 1234:         ser = Series(range(5), dtype=dtype)
 1235:         return ser
 1236: 
 1237:     @pytest.fixture
 1238:     def val(self):
 1239:         return range(2, 4)
 1240: 
 1241:     @pytest.fixture
 1242:     def key(self):
 1243:         return slice(0, 2)
 1244: 
 1245:     @pytest.fixture
 1246:     def expected(self, any_int_numpy_dtype):
 1247:         dtype = np.dtype(any_int_numpy_dtype)
 1248:         exp = Series([2, 3, 2, 3, 4], dtype=dtype)
 1249:         return exp
 1250: 
 1251:     @pytest.fixture
 1252:     def warn(self):
 1253:         return None
 1254: 
 1255: 
 1256: @pytest.mark.parametrize(
 1257:     "val, warn",
 1258:     [
 1259:         (np.array([2.0, 3.0]), None),
 1260:         (np.array([2.5, 3.5]), FutureWarning),
 1261:         (
 1262:             np.array([2**65, 2**65 + 1], dtype=np.float64),
 1263:             FutureWarning,
 1264:         ),  # all ints, but can't cast
 1265:     ],
 1266: )
 1267: class TestSetitemFloatNDarrayIntoIntegerSeries(SetitemCastingEquivalents):
 1268:     @pytest.fixture
 1269:     def obj(self):
 1270:         return Series(range(5), dtype=np.int64)
 1271: 
 1272:     @pytest.fixture
 1273:     def key(self):
 1274:         return slice(0, 2)
 1275: 
 1276:     @pytest.fixture
 1277:     def expected(self, val):
 1278:         if val[0] == 2:
 1279:             # NB: this condition is based on currently-hardcoded "val" cases
 1280:             dtype = np.int64
 1281:         else:
 1282:             dtype = np.float64
 1283:         res_values = np.array(range(5), dtype=dtype)
 1284:         res_values[:2] = val
 1285:         return Series(res_values)
 1286: 
 1287: 
 1288: @pytest.mark.parametrize("val", [512, np.int16(512)])
 1289: class TestSetitemIntoIntegerSeriesNeedsUpcast(SetitemCastingEquivalents):
 1290:     @pytest.fixture
 1291:     def obj(self):
 1292:         return Series([1, 2, 3], dtype=np.int8)
 1293: 
 1294:     @pytest.fixture
 1295:     def key(self):
 1296:         return 1
 1297: 
 1298:     @pytest.fixture
 1299:     def expected(self):
 1300:         return Series([1, 512, 3], dtype=np.int16)
 1301: 
 1302:     @pytest.fixture
 1303:     def warn(self):
 1304:         return FutureWarning
 1305: 
 1306: 
 1307: @pytest.mark.parametrize("val", [2**33 + 1.0, 2**33 + 1.1, 2**62])
 1308: class TestSmallIntegerSetitemUpcast(SetitemCastingEquivalents):
 1309:     # https://github.com/pandas-dev/pandas/issues/39584#issuecomment-941212124
 1310:     @pytest.fixture
 1311:     def obj(self):
 1312:         return Series([1, 2, 3], dtype="i4")
 1313: 
 1314:     @pytest.fixture
 1315:     def key(self):
 1316:         return 0
 1317: 
 1318:     @pytest.fixture
 1319:     def expected(self, val):
 1320:         if val % 1 != 0:
 1321:             dtype = "f8"
 1322:         else:
 1323:             dtype = "i8"
 1324:         return Series([val, 2, 3], dtype=dtype)
 1325: 
 1326:     @pytest.fixture
 1327:     def warn(self):
 1328:         return FutureWarning
 1329: 
 1330: 
 1331: class CoercionTest(SetitemCastingEquivalents):
 1332:     # Tests ported from tests.indexing.test_coercion
 1333: 
 1334:     @pytest.fixture
 1335:     def key(self):
 1336:         return 1
 1337: 
 1338:     @pytest.fixture
 1339:     def expected(self, obj, key, val, exp_dtype):
 1340:         vals = list(obj)
 1341:         vals[key] = val
 1342:         return Series(vals, dtype=exp_dtype)
 1343: 
 1344: 
 1345: @pytest.mark.parametrize(
 1346:     "val,exp_dtype,warn",
 1347:     [(np.int32(1), np.int8, None), (np.int16(2**9), np.int16, FutureWarning)],
 1348: )
 1349: class TestCoercionInt8(CoercionTest):
 1350:     # previously test_setitem_series_int8 in tests.indexing.test_coercion
 1351:     @pytest.fixture
 1352:     def obj(self):
 1353:         return Series([1, 2, 3, 4], dtype=np.int8)
 1354: 
 1355: 
 1356: @pytest.mark.parametrize("val", [1, 1.1, 1 + 1j, True])
 1357: @pytest.mark.parametrize("exp_dtype", [object])
 1358: class TestCoercionObject(CoercionTest):
 1359:     # previously test_setitem_series_object in tests.indexing.test_coercion
 1360:     @pytest.fixture
 1361:     def obj(self):
 1362:         return Series(["a", "b", "c", "d"], dtype=object)
 1363: 
 1364:     @pytest.fixture
 1365:     def warn(self):
 1366:         return None
 1367: 
 1368: 
 1369: @pytest.mark.parametrize(
 1370:     "val,exp_dtype,warn",
 1371:     [
 1372:         (1, np.complex128, None),
 1373:         (1.1, np.complex128, None),
 1374:         (1 + 1j, np.complex128, None),
 1375:         (True, object, FutureWarning),
 1376:     ],
 1377: )
 1378: class TestCoercionComplex(CoercionTest):
 1379:     # previously test_setitem_series_complex128 in tests.indexing.test_coercion
 1380:     @pytest.fixture
 1381:     def obj(self):
 1382:         return Series([1 + 1j, 2 + 2j, 3 + 3j, 4 + 4j])
 1383: 
 1384: 
 1385: @pytest.mark.parametrize(
 1386:     "val,exp_dtype,warn",
 1387:     [
 1388:         (1, object, FutureWarning),
 1389:         ("3", object, FutureWarning),
 1390:         (3, object, FutureWarning),
 1391:         (1.1, object, FutureWarning),
 1392:         (1 + 1j, object, FutureWarning),
 1393:         (True, bool, None),
 1394:     ],
 1395: )
 1396: class TestCoercionBool(CoercionTest):
 1397:     # previously test_setitem_series_bool in tests.indexing.test_coercion
 1398:     @pytest.fixture
 1399:     def obj(self):
 1400:         return Series([True, False, True, False], dtype=bool)
 1401: 
 1402: 
 1403: @pytest.mark.parametrize(
 1404:     "val,exp_dtype,warn",
 1405:     [
 1406:         (1, np.int64, None),
 1407:         (1.1, np.float64, FutureWarning),
 1408:         (1 + 1j, np.complex128, FutureWarning),
 1409:         (True, object, FutureWarning),
 1410:     ],
 1411: )
 1412: class TestCoercionInt64(CoercionTest):
 1413:     # previously test_setitem_series_int64 in tests.indexing.test_coercion
 1414:     @pytest.fixture
 1415:     def obj(self):
 1416:         return Series([1, 2, 3, 4])
 1417: 
 1418: 
 1419: @pytest.mark.parametrize(
 1420:     "val,exp_dtype,warn",
 1421:     [
 1422:         (1, np.float64, None),
 1423:         (1.1, np.float64, None),
 1424:         (1 + 1j, np.complex128, FutureWarning),
 1425:         (True, object, FutureWarning),
 1426:     ],
 1427: )
 1428: class TestCoercionFloat64(CoercionTest):
 1429:     # previously test_setitem_series_float64 in tests.indexing.test_coercion
 1430:     @pytest.fixture
 1431:     def obj(self):
 1432:         return Series([1.1, 2.2, 3.3, 4.4])
 1433: 
 1434: 
 1435: @pytest.mark.parametrize(
 1436:     "val,exp_dtype,warn",
 1437:     [
 1438:         (1, np.float32, None),
 1439:         pytest.param(
 1440:             1.1,
 1441:             np.float32,
 1442:             None,
 1443:             marks=pytest.mark.xfail(
 1444:                 (
 1445:                     not np_version_gte1p24
 1446:                     or (np_version_gte1p24 and np._get_promotion_state() != "weak")
 1447:                 ),
 1448:                 reason="np.float32(1.1) ends up as 1.100000023841858, so "
 1449:                 "np_can_hold_element raises and we cast to float64",
 1450:             ),
 1451:         ),
 1452:         (1 + 1j, np.complex128, FutureWarning),
 1453:         (True, object, FutureWarning),
 1454:         (np.uint8(2), np.float32, None),
 1455:         (np.uint32(2), np.float32, None),
 1456:         # float32 cannot hold np.iinfo(np.uint32).max exactly
 1457:         # (closest it can hold is 4294967300.0 which off by 5.0), so
 1458:         # we cast to float64
 1459:         (np.uint32(np.iinfo(np.uint32).max), np.float64, FutureWarning),
 1460:         (np.uint64(2), np.float32, None),
 1461:         (np.int64(2), np.float32, None),
 1462:     ],
 1463: )
 1464: class TestCoercionFloat32(CoercionTest):
 1465:     @pytest.fixture
 1466:     def obj(self):
 1467:         return Series([1.1, 2.2, 3.3, 4.4], dtype=np.float32)
 1468: 
 1469:     def test_slice_key(self, obj, key, expected, warn, val, indexer_sli, is_inplace):
 1470:         super().test_slice_key(obj, key, expected, warn, val, indexer_sli, is_inplace)
 1471: 
 1472:         if isinstance(val, float):
 1473:             # the xfail would xpass bc test_slice_key short-circuits
 1474:             raise AssertionError("xfail not relevant for this test.")
 1475: 
 1476: 
 1477: @pytest.mark.parametrize(
 1478:     "val,exp_dtype,warn",
 1479:     [
 1480:         (Timestamp("2012-01-01"), "datetime64[ns]", None),
 1481:         (1, object, FutureWarning),
 1482:         ("x", object, FutureWarning),
 1483:     ],
 1484: )
 1485: class TestCoercionDatetime64(CoercionTest):
 1486:     # previously test_setitem_series_datetime64 in tests.indexing.test_coercion
 1487: 
 1488:     @pytest.fixture
 1489:     def obj(self):
 1490:         return Series(date_range("2011-01-01", freq="D", periods=4))
 1491: 
 1492:     @pytest.fixture
 1493:     def warn(self):
 1494:         return None
 1495: 
 1496: 
 1497: @pytest.mark.parametrize(
 1498:     "val,exp_dtype,warn",
 1499:     [
 1500:         (Timestamp("2012-01-01", tz="US/Eastern"), "datetime64[ns, US/Eastern]", None),
 1501:         # pre-2.0, a mis-matched tz would end up casting to object
 1502:         (Timestamp("2012-01-01", tz="US/Pacific"), "datetime64[ns, US/Eastern]", None),
 1503:         (Timestamp("2012-01-01"), object, FutureWarning),
 1504:         (1, object, FutureWarning),
 1505:     ],
 1506: )
 1507: class TestCoercionDatetime64TZ(CoercionTest):
 1508:     # previously test_setitem_series_datetime64tz in tests.indexing.test_coercion
 1509:     @pytest.fixture
 1510:     def obj(self):
 1511:         tz = "US/Eastern"
 1512:         return Series(date_range("2011-01-01", freq="D", periods=4, tz=tz))
 1513: 
 1514:     @pytest.fixture
 1515:     def warn(self):
 1516:         return None
 1517: 
 1518: 
 1519: @pytest.mark.parametrize(
 1520:     "val,exp_dtype,warn",
 1521:     [
 1522:         (Timedelta("12 day"), "timedelta64[ns]", None),
 1523:         (1, object, FutureWarning),
 1524:         ("x", object, FutureWarning),
 1525:     ],
 1526: )
 1527: class TestCoercionTimedelta64(CoercionTest):
 1528:     # previously test_setitem_series_timedelta64 in tests.indexing.test_coercion
 1529:     @pytest.fixture
 1530:     def obj(self):
 1531:         return Series(timedelta_range("1 day", periods=4))
 1532: 
 1533:     @pytest.fixture
 1534:     def warn(self):
 1535:         return None
 1536: 
 1537: 
 1538: @pytest.mark.parametrize(
 1539:     "val", ["foo", Period("2016", freq="Y"), Interval(1, 2, closed="both")]
 1540: )
 1541: @pytest.mark.parametrize("exp_dtype", [object])
 1542: class TestPeriodIntervalCoercion(CoercionTest):
 1543:     # GH#45768
 1544:     @pytest.fixture(
 1545:         params=[
 1546:             period_range("2016-01-01", periods=3, freq="D"),
 1547:             interval_range(1, 5),
 1548:         ]
 1549:     )
 1550:     def obj(self, request):
 1551:         return Series(request.param)
 1552: 
 1553:     @pytest.fixture
 1554:     def warn(self):
 1555:         return FutureWarning
 1556: 
 1557: 
 1558: def test_20643():
 1559:     # closed by GH#45121
 1560:     orig = Series([0, 1, 2], index=["a", "b", "c"])
 1561: 
 1562:     expected = Series([0, 2.7, 2], index=["a", "b", "c"])
 1563: 
 1564:     ser = orig.copy()
 1565:     with tm.assert_produces_warning(FutureWarning, match="incompatible dtype"):
 1566:         ser.at["b"] = 2.7
 1567:     tm.assert_series_equal(ser, expected)
 1568: 
 1569:     ser = orig.copy()
 1570:     with tm.assert_produces_warning(FutureWarning, match="incompatible dtype"):
 1571:         ser.loc["b"] = 2.7
 1572:     tm.assert_series_equal(ser, expected)
 1573: 
 1574:     ser = orig.copy()
 1575:     with tm.assert_produces_warning(FutureWarning, match="incompatible dtype"):
 1576:         ser["b"] = 2.7
 1577:     tm.assert_series_equal(ser, expected)
 1578: 
 1579:     ser = orig.copy()
 1580:     with tm.assert_produces_warning(FutureWarning, match="incompatible dtype"):
 1581:         ser.iat[1] = 2.7
 1582:     tm.assert_series_equal(ser, expected)
 1583: 
 1584:     ser = orig.copy()
 1585:     with tm.assert_produces_warning(FutureWarning, match="incompatible dtype"):
 1586:         ser.iloc[1] = 2.7
 1587:     tm.assert_series_equal(ser, expected)
 1588: 
 1589:     orig_df = orig.to_frame("A")
 1590:     expected_df = expected.to_frame("A")
 1591: 
 1592:     df = orig_df.copy()
 1593:     with tm.assert_produces_warning(FutureWarning, match="incompatible dtype"):
 1594:         df.at["b", "A"] = 2.7
 1595:     tm.assert_frame_equal(df, expected_df)
 1596: 
 1597:     df = orig_df.copy()
 1598:     with tm.assert_produces_warning(FutureWarning, match="incompatible dtype"):
 1599:         df.loc["b", "A"] = 2.7
 1600:     tm.assert_frame_equal(df, expected_df)
 1601: 
 1602:     df = orig_df.copy()
 1603:     with tm.assert_produces_warning(FutureWarning, match="incompatible dtype"):
 1604:         df.iloc[1, 0] = 2.7
 1605:     tm.assert_frame_equal(df, expected_df)
 1606: 
 1607:     df = orig_df.copy()
 1608:     with tm.assert_produces_warning(FutureWarning, match="incompatible dtype"):
 1609:         df.iat[1, 0] = 2.7
 1610:     tm.assert_frame_equal(df, expected_df)
 1611: 
 1612: 
 1613: def test_20643_comment():
 1614:     # https://github.com/pandas-dev/pandas/issues/20643#issuecomment-431244590
 1615:     # fixed sometime prior to GH#45121
 1616:     orig = Series([0, 1, 2], index=["a", "b", "c"])
 1617:     expected = Series([np.nan, 1, 2], index=["a", "b", "c"])
 1618: 
 1619:     ser = orig.copy()
 1620:     ser.iat[0] = None
 1621:     tm.assert_series_equal(ser, expected)
 1622: 
 1623:     ser = orig.copy()
 1624:     ser.iloc[0] = None
 1625:     tm.assert_series_equal(ser, expected)
 1626: 
 1627: 
 1628: def test_15413():
 1629:     # fixed by GH#45121
 1630:     ser = Series([1, 2, 3])
 1631: 
 1632:     with tm.assert_produces_warning(FutureWarning, match="incompatible dtype"):
 1633:         ser[ser == 2] += 0.5
 1634:     expected = Series([1, 2.5, 3])
 1635:     tm.assert_series_equal(ser, expected)
 1636: 
 1637:     ser = Series([1, 2, 3])
 1638:     with tm.assert_produces_warning(FutureWarning, match="incompatible dtype"):
 1639:         ser[1] += 0.5
 1640:     tm.assert_series_equal(ser, expected)
 1641: 
 1642:     ser = Series([1, 2, 3])
 1643:     with tm.assert_produces_warning(FutureWarning, match="incompatible dtype"):
 1644:         ser.loc[1] += 0.5
 1645:     tm.assert_series_equal(ser, expected)
 1646: 
 1647:     ser = Series([1, 2, 3])
 1648:     with tm.assert_produces_warning(FutureWarning, match="incompatible dtype"):
 1649:         ser.iloc[1] += 0.5
 1650:     tm.assert_series_equal(ser, expected)
 1651: 
 1652:     ser = Series([1, 2, 3])
 1653:     with tm.assert_produces_warning(FutureWarning, match="incompatible dtype"):
 1654:         ser.iat[1] += 0.5
 1655:     tm.assert_series_equal(ser, expected)
 1656: 
 1657:     ser = Series([1, 2, 3])
 1658:     with tm.assert_produces_warning(FutureWarning, match="incompatible dtype"):
 1659:         ser.at[1] += 0.5
 1660:     tm.assert_series_equal(ser, expected)
 1661: 
 1662: 
 1663: def test_32878_int_itemsize():
 1664:     # Fixed by GH#45121
 1665:     arr = np.arange(5).astype("i4")
 1666:     ser = Series(arr)
 1667:     val = np.int64(np.iinfo(np.int64).max)
 1668:     with tm.assert_produces_warning(FutureWarning, match="incompatible dtype"):
 1669:         ser[0] = val
 1670:     expected = Series([val, 1, 2, 3, 4], dtype=np.int64)
 1671:     tm.assert_series_equal(ser, expected)
 1672: 
 1673: 
 1674: def test_32878_complex_itemsize():
 1675:     arr = np.arange(5).astype("c8")
 1676:     ser = Series(arr)
 1677:     val = np.finfo(np.float64).max
 1678:     val = val.astype("c16")
 1679: 
 1680:     # GH#32878 used to coerce val to inf+0.000000e+00j
 1681:     with tm.assert_produces_warning(FutureWarning, match="incompatible dtype"):
 1682:         ser[0] = val
 1683:     assert ser[0] == val
 1684:     expected = Series([val, 1, 2, 3, 4], dtype="c16")
 1685:     tm.assert_series_equal(ser, expected)
 1686: 
 1687: 
 1688: def test_37692(indexer_al):
 1689:     # GH#37692
 1690:     ser = Series([1, 2, 3], index=["a", "b", "c"])
 1691:     with tm.assert_produces_warning(FutureWarning, match="incompatible dtype"):
 1692:         indexer_al(ser)["b"] = "test"
 1693:     expected = Series([1, "test", 3], index=["a", "b", "c"], dtype=object)
 1694:     tm.assert_series_equal(ser, expected)
 1695: 
 1696: 
 1697: def test_setitem_bool_int_float_consistency(indexer_sli):
 1698:     # GH#21513
 1699:     # bool-with-int and bool-with-float both upcast to object
 1700:     #  int-with-float and float-with-int are both non-casting so long
 1701:     #  as the setitem can be done losslessly
 1702:     for dtype in [np.float64, np.int64]:
 1703:         ser = Series(0, index=range(3), dtype=dtype)
 1704:         with tm.assert_produces_warning(FutureWarning, match="incompatible dtype"):
 1705:             indexer_sli(ser)[0] = True
 1706:         assert ser.dtype == object
 1707: 
 1708:         ser = Series(0, index=range(3), dtype=bool)
 1709:         with tm.assert_produces_warning(FutureWarning, match="incompatible dtype"):
 1710:             ser[0] = dtype(1)
 1711:         assert ser.dtype == object
 1712: 
 1713:     # 1.0 can be held losslessly, so no casting
 1714:     ser = Series(0, index=range(3), dtype=np.int64)
 1715:     indexer_sli(ser)[0] = np.float64(1.0)
 1716:     assert ser.dtype == np.int64
 1717: 
 1718:     # 1 can be held losslessly, so no casting
 1719:     ser = Series(0, index=range(3), dtype=np.float64)
 1720:     indexer_sli(ser)[0] = np.int64(1)
 1721: 
 1722: 
 1723: def test_setitem_positional_with_casting():
 1724:     # GH#45070 case where in __setitem__ we get a KeyError, then when
 1725:     #  we fallback we *also* get a ValueError if we try to set inplace.
 1726:     ser = Series([1, 2, 3], index=["a", "b", "c"])
 1727: 
 1728:     warn_msg = "Series.__setitem__ treating keys as positions is deprecated"
 1729:     with tm.assert_produces_warning(FutureWarning, match=warn_msg):
 1730:         ser[0] = "X"
 1731:     expected = Series(["X", 2, 3], index=["a", "b", "c"], dtype=object)
 1732:     tm.assert_series_equal(ser, expected)
 1733: 
 1734: 
 1735: def test_setitem_positional_float_into_int_coerces():
 1736:     # Case where we hit a KeyError and then trying to set in-place incorrectly
 1737:     #  casts a float to an int
 1738:     ser = Series([1, 2, 3], index=["a", "b", "c"])
 1739: 
 1740:     warn_msg = "Series.__setitem__ treating keys as positions is deprecated"
 1741:     with tm.assert_produces_warning(FutureWarning, match=warn_msg):
 1742:         ser[0] = 1.5
 1743:     expected = Series([1.5, 2, 3], index=["a", "b", "c"])
 1744:     tm.assert_series_equal(ser, expected)
 1745: 
 1746: 
 1747: def test_setitem_int_not_positional():
 1748:     # GH#42215 deprecated falling back to positional on __setitem__ with an
 1749:     #  int not contained in the index; enforced in 2.0
 1750:     ser = Series([1, 2, 3, 4], index=[1.1, 2.1, 3.0, 4.1])
 1751:     assert not ser.index._should_fallback_to_positional
 1752:     # assert not ser.index.astype(object)._should_fallback_to_positional
 1753: 
 1754:     # 3.0 is in our index, so post-enforcement behavior is unchanged
 1755:     ser[3] = 10
 1756:     expected = Series([1, 2, 10, 4], index=ser.index)
 1757:     tm.assert_series_equal(ser, expected)
 1758: 
 1759:     # pre-enforcement `ser[5] = 5` raised IndexError
 1760:     ser[5] = 5
 1761:     expected = Series([1, 2, 10, 4, 5], index=[1.1, 2.1, 3.0, 4.1, 5.0])
 1762:     tm.assert_series_equal(ser, expected)
 1763: 
 1764:     ii = IntervalIndex.from_breaks(range(10))[::2]
 1765:     ser2 = Series(range(len(ii)), index=ii)
 1766:     exp_index = ii.astype(object).append(Index([4]))
 1767:     expected2 = Series([0, 1, 2, 3, 4, 9], index=exp_index)
 1768:     # pre-enforcement `ser2[4] = 9` interpreted 4 as positional
 1769:     ser2[4] = 9
 1770:     tm.assert_series_equal(ser2, expected2)
 1771: 
 1772:     mi = MultiIndex.from_product([ser.index, ["A", "B"]])
 1773:     ser3 = Series(range(len(mi)), index=mi)
 1774:     expected3 = ser3.copy()
 1775:     expected3.loc[4] = 99
 1776:     # pre-enforcement `ser3[4] = 99` interpreted 4 as positional
 1777:     ser3[4] = 99
 1778:     tm.assert_series_equal(ser3, expected3)
 1779: 
 1780: 
 1781: def test_setitem_with_bool_indexer():
 1782:     # GH#42530
 1783: 
 1784:     df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6]})
 1785:     result = df.pop("b").copy()
 1786:     result[[True, False, False]] = 9
 1787:     expected = Series(data=[9, 5, 6], name="b")
 1788:     tm.assert_series_equal(result, expected)
 1789: 
 1790:     df.loc[[True, False, False], "a"] = 10
 1791:     expected = DataFrame({"a": [10, 2, 3]})
 1792:     tm.assert_frame_equal(df, expected)
 1793: 
 1794: 
 1795: @pytest.mark.parametrize("size", range(2, 6))
 1796: @pytest.mark.parametrize(
 1797:     "mask", [[True, False, False, False, False], [True, False], [False]]
 1798: )
 1799: @pytest.mark.parametrize(
 1800:     "item", [2.0, np.nan, np.finfo(float).max, np.finfo(float).min]
 1801: )
 1802: # Test numpy arrays, lists and tuples as the input to be
 1803: # broadcast
 1804: @pytest.mark.parametrize(
 1805:     "box", [lambda x: np.array([x]), lambda x: [x], lambda x: (x,)]
 1806: )
 1807: def test_setitem_bool_indexer_dont_broadcast_length1_values(size, mask, item, box):
 1808:     # GH#44265
 1809:     # see also tests.series.indexing.test_where.test_broadcast
 1810: 
 1811:     selection = np.resize(mask, size)
 1812: 
 1813:     data = np.arange(size, dtype=float)
 1814: 
 1815:     ser = Series(data)
 1816: 
 1817:     if selection.sum() != 1:
 1818:         msg = (
 1819:             "cannot set using a list-like indexer with a different "
 1820:             "length than the value"
 1821:         )
 1822:         with pytest.raises(ValueError, match=msg):
 1823:             # GH#44265
 1824:             ser[selection] = box(item)
 1825:     else:
 1826:         # In this corner case setting is equivalent to setting with the unboxed
 1827:         #  item
 1828:         ser[selection] = box(item)
 1829: 
 1830:         expected = Series(np.arange(size, dtype=float))
 1831:         expected[selection] = item
 1832:         tm.assert_series_equal(ser, expected)
 1833: 
 1834: 
 1835: def test_setitem_empty_mask_dont_upcast_dt64():
 1836:     dti = date_range("2016-01-01", periods=3)
 1837:     ser = Series(dti)
 1838:     orig = ser.copy()
 1839:     mask = np.zeros(3, dtype=bool)
 1840: 
 1841:     ser[mask] = "foo"
 1842:     assert ser.dtype == dti.dtype  # no-op -> dont upcast
 1843:     tm.assert_series_equal(ser, orig)
 1844: 
 1845:     ser.mask(mask, "foo", inplace=True)
 1846:     assert ser.dtype == dti.dtype  # no-op -> dont upcast
 1847:     tm.assert_series_equal(ser, orig)
