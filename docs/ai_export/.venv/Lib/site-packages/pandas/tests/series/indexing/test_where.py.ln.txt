    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas._config import using_pyarrow_string_dtype
    5: 
    6: from pandas.core.dtypes.common import is_integer
    7: 
    8: import pandas as pd
    9: from pandas import (
   10:     Series,
   11:     Timestamp,
   12:     date_range,
   13:     isna,
   14: )
   15: import pandas._testing as tm
   16: 
   17: 
   18: def test_where_unsafe_int(any_signed_int_numpy_dtype):
   19:     s = Series(np.arange(10), dtype=any_signed_int_numpy_dtype)
   20:     mask = s < 5
   21: 
   22:     s[mask] = range(2, 7)
   23:     expected = Series(
   24:         list(range(2, 7)) + list(range(5, 10)),
   25:         dtype=any_signed_int_numpy_dtype,
   26:     )
   27: 
   28:     tm.assert_series_equal(s, expected)
   29: 
   30: 
   31: def test_where_unsafe_float(float_numpy_dtype):
   32:     s = Series(np.arange(10), dtype=float_numpy_dtype)
   33:     mask = s < 5
   34: 
   35:     s[mask] = range(2, 7)
   36:     data = list(range(2, 7)) + list(range(5, 10))
   37:     expected = Series(data, dtype=float_numpy_dtype)
   38: 
   39:     tm.assert_series_equal(s, expected)
   40: 
   41: 
   42: @pytest.mark.parametrize(
   43:     "dtype,expected_dtype",
   44:     [
   45:         (np.int8, np.float64),
   46:         (np.int16, np.float64),
   47:         (np.int32, np.float64),
   48:         (np.int64, np.float64),
   49:         (np.float32, np.float32),
   50:         (np.float64, np.float64),
   51:     ],
   52: )
   53: def test_where_unsafe_upcast(dtype, expected_dtype):
   54:     # see gh-9743
   55:     s = Series(np.arange(10), dtype=dtype)
   56:     values = [2.5, 3.5, 4.5, 5.5, 6.5]
   57:     mask = s < 5
   58:     expected = Series(values + list(range(5, 10)), dtype=expected_dtype)
   59:     warn = (
   60:         None
   61:         if np.dtype(dtype).kind == np.dtype(expected_dtype).kind == "f"
   62:         else FutureWarning
   63:     )
   64:     with tm.assert_produces_warning(warn, match="incompatible dtype"):
   65:         s[mask] = values
   66:     tm.assert_series_equal(s, expected)
   67: 
   68: 
   69: def test_where_unsafe():
   70:     # see gh-9731
   71:     s = Series(np.arange(10), dtype="int64")
   72:     values = [2.5, 3.5, 4.5, 5.5]
   73: 
   74:     mask = s > 5
   75:     expected = Series(list(range(6)) + values, dtype="float64")
   76: 
   77:     with tm.assert_produces_warning(FutureWarning, match="incompatible dtype"):
   78:         s[mask] = values
   79:     tm.assert_series_equal(s, expected)
   80: 
   81:     # see gh-3235
   82:     s = Series(np.arange(10), dtype="int64")
   83:     mask = s < 5
   84:     s[mask] = range(2, 7)
   85:     expected = Series(list(range(2, 7)) + list(range(5, 10)), dtype="int64")
   86:     tm.assert_series_equal(s, expected)
   87:     assert s.dtype == expected.dtype
   88: 
   89:     s = Series(np.arange(10), dtype="int64")
   90:     mask = s > 5
   91:     s[mask] = [0] * 4
   92:     expected = Series([0, 1, 2, 3, 4, 5] + [0] * 4, dtype="int64")
   93:     tm.assert_series_equal(s, expected)
   94: 
   95:     s = Series(np.arange(10))
   96:     mask = s > 5
   97: 
   98:     msg = "cannot set using a list-like indexer with a different length than the value"
   99:     with pytest.raises(ValueError, match=msg):
  100:         s[mask] = [5, 4, 3, 2, 1]
  101: 
  102:     with pytest.raises(ValueError, match=msg):
  103:         s[mask] = [0] * 5
  104: 
  105:     # dtype changes
  106:     s = Series([1, 2, 3, 4])
  107:     result = s.where(s > 2, np.nan)
  108:     expected = Series([np.nan, np.nan, 3, 4])
  109:     tm.assert_series_equal(result, expected)
  110: 
  111:     # GH 4667
  112:     # setting with None changes dtype
  113:     s = Series(range(10)).astype(float)
  114:     s[8] = None
  115:     result = s[8]
  116:     assert isna(result)
  117: 
  118:     s = Series(range(10)).astype(float)
  119:     s[s > 8] = None
  120:     result = s[isna(s)]
  121:     expected = Series(np.nan, index=[9])
  122:     tm.assert_series_equal(result, expected)
  123: 
  124: 
  125: def test_where():
  126:     s = Series(np.random.default_rng(2).standard_normal(5))
  127:     cond = s > 0
  128: 
  129:     rs = s.where(cond).dropna()
  130:     rs2 = s[cond]
  131:     tm.assert_series_equal(rs, rs2)
  132: 
  133:     rs = s.where(cond, -s)
  134:     tm.assert_series_equal(rs, s.abs())
  135: 
  136:     rs = s.where(cond)
  137:     assert s.shape == rs.shape
  138:     assert rs is not s
  139: 
  140:     # test alignment
  141:     cond = Series([True, False, False, True, False], index=s.index)
  142:     s2 = -(s.abs())
  143: 
  144:     expected = s2[cond].reindex(s2.index[:3]).reindex(s2.index)
  145:     rs = s2.where(cond[:3])
  146:     tm.assert_series_equal(rs, expected)
  147: 
  148:     expected = s2.abs()
  149:     expected.iloc[0] = s2[0]
  150:     rs = s2.where(cond[:3], -s2)
  151:     tm.assert_series_equal(rs, expected)
  152: 
  153: 
  154: def test_where_error():
  155:     s = Series(np.random.default_rng(2).standard_normal(5))
  156:     cond = s > 0
  157: 
  158:     msg = "Array conditional must be same shape as self"
  159:     with pytest.raises(ValueError, match=msg):
  160:         s.where(1)
  161:     with pytest.raises(ValueError, match=msg):
  162:         s.where(cond[:3].values, -s)
  163: 
  164:     # GH 2745
  165:     s = Series([1, 2])
  166:     s[[True, False]] = [0, 1]
  167:     expected = Series([0, 2])
  168:     tm.assert_series_equal(s, expected)
  169: 
  170:     # failures
  171:     msg = "cannot set using a list-like indexer with a different length than the value"
  172:     with pytest.raises(ValueError, match=msg):
  173:         s[[True, False]] = [0, 2, 3]
  174: 
  175:     with pytest.raises(ValueError, match=msg):
  176:         s[[True, False]] = []
  177: 
  178: 
  179: @pytest.mark.parametrize("klass", [list, tuple, np.array, Series])
  180: def test_where_array_like(klass):
  181:     # see gh-15414
  182:     s = Series([1, 2, 3])
  183:     cond = [False, True, True]
  184:     expected = Series([np.nan, 2, 3])
  185: 
  186:     result = s.where(klass(cond))
  187:     tm.assert_series_equal(result, expected)
  188: 
  189: 
  190: @pytest.mark.parametrize(
  191:     "cond",
  192:     [
  193:         [1, 0, 1],
  194:         Series([2, 5, 7]),
  195:         ["True", "False", "True"],
  196:         [Timestamp("2017-01-01"), pd.NaT, Timestamp("2017-01-02")],
  197:     ],
  198: )
  199: def test_where_invalid_input(cond):
  200:     # see gh-15414: only boolean arrays accepted
  201:     s = Series([1, 2, 3])
  202:     msg = "Boolean array expected for the condition"
  203: 
  204:     with pytest.raises(ValueError, match=msg):
  205:         s.where(cond)
  206: 
  207:     msg = "Array conditional must be same shape as self"
  208:     with pytest.raises(ValueError, match=msg):
  209:         s.where([True])
  210: 
  211: 
  212: def test_where_ndframe_align():
  213:     msg = "Array conditional must be same shape as self"
  214:     s = Series([1, 2, 3])
  215: 
  216:     cond = [True]
  217:     with pytest.raises(ValueError, match=msg):
  218:         s.where(cond)
  219: 
  220:     expected = Series([1, np.nan, np.nan])
  221: 
  222:     out = s.where(Series(cond))
  223:     tm.assert_series_equal(out, expected)
  224: 
  225:     cond = np.array([False, True, False, True])
  226:     with pytest.raises(ValueError, match=msg):
  227:         s.where(cond)
  228: 
  229:     expected = Series([np.nan, 2, np.nan])
  230: 
  231:     out = s.where(Series(cond))
  232:     tm.assert_series_equal(out, expected)
  233: 
  234: 
  235: @pytest.mark.xfail(using_pyarrow_string_dtype(), reason="can't set ints into string")
  236: def test_where_setitem_invalid():
  237:     # GH 2702
  238:     # make sure correct exceptions are raised on invalid list assignment
  239: 
  240:     msg = (
  241:         lambda x: f"cannot set using a {x} indexer with a "
  242:         "different length than the value"
  243:     )
  244:     # slice
  245:     s = Series(list("abc"))
  246: 
  247:     with pytest.raises(ValueError, match=msg("slice")):
  248:         s[0:3] = list(range(27))
  249: 
  250:     s[0:3] = list(range(3))
  251:     expected = Series([0, 1, 2])
  252:     tm.assert_series_equal(s.astype(np.int64), expected)
  253: 
  254:     # slice with step
  255:     s = Series(list("abcdef"))
  256: 
  257:     with pytest.raises(ValueError, match=msg("slice")):
  258:         s[0:4:2] = list(range(27))
  259: 
  260:     s = Series(list("abcdef"))
  261:     s[0:4:2] = list(range(2))
  262:     expected = Series([0, "b", 1, "d", "e", "f"])
  263:     tm.assert_series_equal(s, expected)
  264: 
  265:     # neg slices
  266:     s = Series(list("abcdef"))
  267: 
  268:     with pytest.raises(ValueError, match=msg("slice")):
  269:         s[:-1] = list(range(27))
  270: 
  271:     s[-3:-1] = list(range(2))
  272:     expected = Series(["a", "b", "c", 0, 1, "f"])
  273:     tm.assert_series_equal(s, expected)
  274: 
  275:     # list
  276:     s = Series(list("abc"))
  277: 
  278:     with pytest.raises(ValueError, match=msg("list-like")):
  279:         s[[0, 1, 2]] = list(range(27))
  280: 
  281:     s = Series(list("abc"))
  282: 
  283:     with pytest.raises(ValueError, match=msg("list-like")):
  284:         s[[0, 1, 2]] = list(range(2))
  285: 
  286:     # scalar
  287:     s = Series(list("abc"))
  288:     s[0] = list(range(10))
  289:     expected = Series([list(range(10)), "b", "c"])
  290:     tm.assert_series_equal(s, expected)
  291: 
  292: 
  293: @pytest.mark.parametrize("size", range(2, 6))
  294: @pytest.mark.parametrize(
  295:     "mask", [[True, False, False, False, False], [True, False], [False]]
  296: )
  297: @pytest.mark.parametrize(
  298:     "item", [2.0, np.nan, np.finfo(float).max, np.finfo(float).min]
  299: )
  300: # Test numpy arrays, lists and tuples as the input to be
  301: # broadcast
  302: @pytest.mark.parametrize(
  303:     "box", [lambda x: np.array([x]), lambda x: [x], lambda x: (x,)]
  304: )
  305: def test_broadcast(size, mask, item, box):
  306:     # GH#8801, GH#4195
  307:     selection = np.resize(mask, size)
  308: 
  309:     data = np.arange(size, dtype=float)
  310: 
  311:     # Construct the expected series by taking the source
  312:     # data or item based on the selection
  313:     expected = Series(
  314:         [item if use_item else data[i] for i, use_item in enumerate(selection)]
  315:     )
  316: 
  317:     s = Series(data)
  318: 
  319:     s[selection] = item
  320:     tm.assert_series_equal(s, expected)
  321: 
  322:     s = Series(data)
  323:     result = s.where(~selection, box(item))
  324:     tm.assert_series_equal(result, expected)
  325: 
  326:     s = Series(data)
  327:     result = s.mask(selection, box(item))
  328:     tm.assert_series_equal(result, expected)
  329: 
  330: 
  331: def test_where_inplace():
  332:     s = Series(np.random.default_rng(2).standard_normal(5))
  333:     cond = s > 0
  334: 
  335:     rs = s.copy()
  336: 
  337:     rs.where(cond, inplace=True)
  338:     tm.assert_series_equal(rs.dropna(), s[cond])
  339:     tm.assert_series_equal(rs, s.where(cond))
  340: 
  341:     rs = s.copy()
  342:     rs.where(cond, -s, inplace=True)
  343:     tm.assert_series_equal(rs, s.where(cond, -s))
  344: 
  345: 
  346: def test_where_dups():
  347:     # GH 4550
  348:     # where crashes with dups in index
  349:     s1 = Series(list(range(3)))
  350:     s2 = Series(list(range(3)))
  351:     comb = pd.concat([s1, s2])
  352:     result = comb.where(comb < 2)
  353:     expected = Series([0, 1, np.nan, 0, 1, np.nan], index=[0, 1, 2, 0, 1, 2])
  354:     tm.assert_series_equal(result, expected)
  355: 
  356:     # GH 4548
  357:     # inplace updating not working with dups
  358:     comb[comb < 1] = 5
  359:     expected = Series([5, 1, 2, 5, 1, 2], index=[0, 1, 2, 0, 1, 2])
  360:     tm.assert_series_equal(comb, expected)
  361: 
  362:     comb[comb < 2] += 10
  363:     expected = Series([5, 11, 2, 5, 11, 2], index=[0, 1, 2, 0, 1, 2])
  364:     tm.assert_series_equal(comb, expected)
  365: 
  366: 
  367: def test_where_numeric_with_string():
  368:     # GH 9280
  369:     s = Series([1, 2, 3])
  370:     w = s.where(s > 1, "X")
  371: 
  372:     assert not is_integer(w[0])
  373:     assert is_integer(w[1])
  374:     assert is_integer(w[2])
  375:     assert isinstance(w[0], str)
  376:     assert w.dtype == "object"
  377: 
  378:     w = s.where(s > 1, ["X", "Y", "Z"])
  379:     assert not is_integer(w[0])
  380:     assert is_integer(w[1])
  381:     assert is_integer(w[2])
  382:     assert isinstance(w[0], str)
  383:     assert w.dtype == "object"
  384: 
  385:     w = s.where(s > 1, np.array(["X", "Y", "Z"]))
  386:     assert not is_integer(w[0])
  387:     assert is_integer(w[1])
  388:     assert is_integer(w[2])
  389:     assert isinstance(w[0], str)
  390:     assert w.dtype == "object"
  391: 
  392: 
  393: @pytest.mark.parametrize("dtype", ["timedelta64[ns]", "datetime64[ns]"])
  394: def test_where_datetimelike_coerce(dtype):
  395:     ser = Series([1, 2], dtype=dtype)
  396:     expected = Series([10, 10])
  397:     mask = np.array([False, False])
  398: 
  399:     msg = "Downcasting behavior in Series and DataFrame methods 'where'"
  400:     with tm.assert_produces_warning(FutureWarning, match=msg):
  401:         rs = ser.where(mask, [10, 10])
  402:     tm.assert_series_equal(rs, expected)
  403: 
  404:     with tm.assert_produces_warning(FutureWarning, match=msg):
  405:         rs = ser.where(mask, 10)
  406:     tm.assert_series_equal(rs, expected)
  407: 
  408:     with tm.assert_produces_warning(FutureWarning, match=msg):
  409:         rs = ser.where(mask, 10.0)
  410:     tm.assert_series_equal(rs, expected)
  411: 
  412:     with tm.assert_produces_warning(FutureWarning, match=msg):
  413:         rs = ser.where(mask, [10.0, 10.0])
  414:     tm.assert_series_equal(rs, expected)
  415: 
  416:     rs = ser.where(mask, [10.0, np.nan])
  417:     expected = Series([10, np.nan], dtype="object")
  418:     tm.assert_series_equal(rs, expected)
  419: 
  420: 
  421: def test_where_datetimetz():
  422:     # GH 15701
  423:     timestamps = ["2016-12-31 12:00:04+00:00", "2016-12-31 12:00:04.010000+00:00"]
  424:     ser = Series([Timestamp(t) for t in timestamps], dtype="datetime64[ns, UTC]")
  425:     rs = ser.where(Series([False, True]))
  426:     expected = Series([pd.NaT, ser[1]], dtype="datetime64[ns, UTC]")
  427:     tm.assert_series_equal(rs, expected)
  428: 
  429: 
  430: def test_where_sparse():
  431:     # GH#17198 make sure we dont get an AttributeError for sp_index
  432:     ser = Series(pd.arrays.SparseArray([1, 2]))
  433:     result = ser.where(ser >= 2, 0)
  434:     expected = Series(pd.arrays.SparseArray([0, 2]))
  435:     tm.assert_series_equal(result, expected)
  436: 
  437: 
  438: def test_where_empty_series_and_empty_cond_having_non_bool_dtypes():
  439:     # https://github.com/pandas-dev/pandas/issues/34592
  440:     ser = Series([], dtype=float)
  441:     result = ser.where([])
  442:     tm.assert_series_equal(result, ser)
  443: 
  444: 
  445: def test_where_categorical(frame_or_series):
  446:     # https://github.com/pandas-dev/pandas/issues/18888
  447:     exp = frame_or_series(
  448:         pd.Categorical(["A", "A", "B", "B", np.nan], categories=["A", "B", "C"]),
  449:         dtype="category",
  450:     )
  451:     df = frame_or_series(["A", "A", "B", "B", "C"], dtype="category")
  452:     res = df.where(df != "C")
  453:     tm.assert_equal(exp, res)
  454: 
  455: 
  456: def test_where_datetimelike_categorical(tz_naive_fixture):
  457:     # GH#37682
  458:     tz = tz_naive_fixture
  459: 
  460:     dr = date_range("2001-01-01", periods=3, tz=tz)._with_freq(None)
  461:     lvals = pd.DatetimeIndex([dr[0], dr[1], pd.NaT])
  462:     rvals = pd.Categorical([dr[0], pd.NaT, dr[2]])
  463: 
  464:     mask = np.array([True, True, False])
  465: 
  466:     # DatetimeIndex.where
  467:     res = lvals.where(mask, rvals)
  468:     tm.assert_index_equal(res, dr)
  469: 
  470:     # DatetimeArray.where
  471:     res = lvals._data._where(mask, rvals)
  472:     tm.assert_datetime_array_equal(res, dr._data)
  473: 
  474:     # Series.where
  475:     res = Series(lvals).where(mask, rvals)
  476:     tm.assert_series_equal(res, Series(dr))
  477: 
  478:     # DataFrame.where
  479:     res = pd.DataFrame(lvals).where(mask[:, None], pd.DataFrame(rvals))
  480: 
  481:     tm.assert_frame_equal(res, pd.DataFrame(dr))
