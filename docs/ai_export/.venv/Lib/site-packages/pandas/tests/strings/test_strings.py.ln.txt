    1: from datetime import (
    2:     datetime,
    3:     timedelta,
    4: )
    5: 
    6: import numpy as np
    7: import pytest
    8: 
    9: from pandas import (
   10:     DataFrame,
   11:     Index,
   12:     MultiIndex,
   13:     Series,
   14: )
   15: import pandas._testing as tm
   16: from pandas.core.strings.accessor import StringMethods
   17: from pandas.tests.strings import object_pyarrow_numpy
   18: 
   19: 
   20: @pytest.mark.parametrize("pattern", [0, True, Series(["foo", "bar"])])
   21: def test_startswith_endswith_non_str_patterns(pattern):
   22:     # GH3485
   23:     ser = Series(["foo", "bar"])
   24:     msg = f"expected a string or tuple, not {type(pattern).__name__}"
   25:     with pytest.raises(TypeError, match=msg):
   26:         ser.str.startswith(pattern)
   27:     with pytest.raises(TypeError, match=msg):
   28:         ser.str.endswith(pattern)
   29: 
   30: 
   31: def test_iter_raises():
   32:     # GH 54173
   33:     ser = Series(["foo", "bar"])
   34:     with pytest.raises(TypeError, match="'StringMethods' object is not iterable"):
   35:         iter(ser.str)
   36: 
   37: 
   38: # test integer/float dtypes (inferred by constructor) and mixed
   39: 
   40: 
   41: def test_count(any_string_dtype):
   42:     ser = Series(["foo", "foofoo", np.nan, "foooofooofommmfoo"], dtype=any_string_dtype)
   43:     result = ser.str.count("f[o]+")
   44:     expected_dtype = np.float64 if any_string_dtype in object_pyarrow_numpy else "Int64"
   45:     expected = Series([1, 2, np.nan, 4], dtype=expected_dtype)
   46:     tm.assert_series_equal(result, expected)
   47: 
   48: 
   49: def test_count_mixed_object():
   50:     ser = Series(
   51:         ["a", np.nan, "b", True, datetime.today(), "foo", None, 1, 2.0],
   52:         dtype=object,
   53:     )
   54:     result = ser.str.count("a")
   55:     expected = Series([1, np.nan, 0, np.nan, np.nan, 0, np.nan, np.nan, np.nan])
   56:     tm.assert_series_equal(result, expected)
   57: 
   58: 
   59: def test_repeat(any_string_dtype):
   60:     ser = Series(["a", "b", np.nan, "c", np.nan, "d"], dtype=any_string_dtype)
   61: 
   62:     result = ser.str.repeat(3)
   63:     expected = Series(
   64:         ["aaa", "bbb", np.nan, "ccc", np.nan, "ddd"], dtype=any_string_dtype
   65:     )
   66:     tm.assert_series_equal(result, expected)
   67: 
   68:     result = ser.str.repeat([1, 2, 3, 4, 5, 6])
   69:     expected = Series(
   70:         ["a", "bb", np.nan, "cccc", np.nan, "dddddd"], dtype=any_string_dtype
   71:     )
   72:     tm.assert_series_equal(result, expected)
   73: 
   74: 
   75: def test_repeat_mixed_object():
   76:     ser = Series(["a", np.nan, "b", True, datetime.today(), "foo", None, 1, 2.0])
   77:     result = ser.str.repeat(3)
   78:     expected = Series(
   79:         ["aaa", np.nan, "bbb", np.nan, np.nan, "foofoofoo", None, np.nan, np.nan],
   80:         dtype=object,
   81:     )
   82:     tm.assert_series_equal(result, expected)
   83: 
   84: 
   85: @pytest.mark.parametrize("arg, repeat", [[None, 4], ["b", None]])
   86: def test_repeat_with_null(any_string_dtype, arg, repeat):
   87:     # GH: 31632
   88:     ser = Series(["a", arg], dtype=any_string_dtype)
   89:     result = ser.str.repeat([3, repeat])
   90:     expected = Series(["aaa", None], dtype=any_string_dtype)
   91:     tm.assert_series_equal(result, expected)
   92: 
   93: 
   94: def test_empty_str_methods(any_string_dtype):
   95:     empty_str = empty = Series(dtype=any_string_dtype)
   96:     if any_string_dtype in object_pyarrow_numpy:
   97:         empty_int = Series(dtype="int64")
   98:         empty_bool = Series(dtype=bool)
   99:     else:
  100:         empty_int = Series(dtype="Int64")
  101:         empty_bool = Series(dtype="boolean")
  102:     empty_object = Series(dtype=object)
  103:     empty_bytes = Series(dtype=object)
  104:     empty_df = DataFrame()
  105: 
  106:     # GH7241
  107:     # (extract) on empty series
  108: 
  109:     tm.assert_series_equal(empty_str, empty.str.cat(empty))
  110:     assert "" == empty.str.cat()
  111:     tm.assert_series_equal(empty_str, empty.str.title())
  112:     tm.assert_series_equal(empty_int, empty.str.count("a"))
  113:     tm.assert_series_equal(empty_bool, empty.str.contains("a"))
  114:     tm.assert_series_equal(empty_bool, empty.str.startswith("a"))
  115:     tm.assert_series_equal(empty_bool, empty.str.endswith("a"))
  116:     tm.assert_series_equal(empty_str, empty.str.lower())
  117:     tm.assert_series_equal(empty_str, empty.str.upper())
  118:     tm.assert_series_equal(empty_str, empty.str.replace("a", "b"))
  119:     tm.assert_series_equal(empty_str, empty.str.repeat(3))
  120:     tm.assert_series_equal(empty_bool, empty.str.match("^a"))
  121:     tm.assert_frame_equal(
  122:         DataFrame(columns=[0], dtype=any_string_dtype),
  123:         empty.str.extract("()", expand=True),
  124:     )
  125:     tm.assert_frame_equal(
  126:         DataFrame(columns=[0, 1], dtype=any_string_dtype),
  127:         empty.str.extract("()()", expand=True),
  128:     )
  129:     tm.assert_series_equal(empty_str, empty.str.extract("()", expand=False))
  130:     tm.assert_frame_equal(
  131:         DataFrame(columns=[0, 1], dtype=any_string_dtype),
  132:         empty.str.extract("()()", expand=False),
  133:     )
  134:     tm.assert_frame_equal(empty_df.set_axis([], axis=1), empty.str.get_dummies())
  135:     tm.assert_series_equal(empty_str, empty_str.str.join(""))
  136:     tm.assert_series_equal(empty_int, empty.str.len())
  137:     tm.assert_series_equal(empty_object, empty_str.str.findall("a"))
  138:     tm.assert_series_equal(empty_int, empty.str.find("a"))
  139:     tm.assert_series_equal(empty_int, empty.str.rfind("a"))
  140:     tm.assert_series_equal(empty_str, empty.str.pad(42))
  141:     tm.assert_series_equal(empty_str, empty.str.center(42))
  142:     tm.assert_series_equal(empty_object, empty.str.split("a"))
  143:     tm.assert_series_equal(empty_object, empty.str.rsplit("a"))
  144:     tm.assert_series_equal(empty_object, empty.str.partition("a", expand=False))
  145:     tm.assert_frame_equal(empty_df, empty.str.partition("a"))
  146:     tm.assert_series_equal(empty_object, empty.str.rpartition("a", expand=False))
  147:     tm.assert_frame_equal(empty_df, empty.str.rpartition("a"))
  148:     tm.assert_series_equal(empty_str, empty.str.slice(stop=1))
  149:     tm.assert_series_equal(empty_str, empty.str.slice(step=1))
  150:     tm.assert_series_equal(empty_str, empty.str.strip())
  151:     tm.assert_series_equal(empty_str, empty.str.lstrip())
  152:     tm.assert_series_equal(empty_str, empty.str.rstrip())
  153:     tm.assert_series_equal(empty_str, empty.str.wrap(42))
  154:     tm.assert_series_equal(empty_str, empty.str.get(0))
  155:     tm.assert_series_equal(empty_object, empty_bytes.str.decode("ascii"))
  156:     tm.assert_series_equal(empty_bytes, empty.str.encode("ascii"))
  157:     # ismethods should always return boolean (GH 29624)
  158:     tm.assert_series_equal(empty_bool, empty.str.isalnum())
  159:     tm.assert_series_equal(empty_bool, empty.str.isalpha())
  160:     tm.assert_series_equal(empty_bool, empty.str.isdigit())
  161:     tm.assert_series_equal(empty_bool, empty.str.isspace())
  162:     tm.assert_series_equal(empty_bool, empty.str.islower())
  163:     tm.assert_series_equal(empty_bool, empty.str.isupper())
  164:     tm.assert_series_equal(empty_bool, empty.str.istitle())
  165:     tm.assert_series_equal(empty_bool, empty.str.isnumeric())
  166:     tm.assert_series_equal(empty_bool, empty.str.isdecimal())
  167:     tm.assert_series_equal(empty_str, empty.str.capitalize())
  168:     tm.assert_series_equal(empty_str, empty.str.swapcase())
  169:     tm.assert_series_equal(empty_str, empty.str.normalize("NFC"))
  170: 
  171:     table = str.maketrans("a", "b")
  172:     tm.assert_series_equal(empty_str, empty.str.translate(table))
  173: 
  174: 
  175: @pytest.mark.parametrize(
  176:     "method, expected",
  177:     [
  178:         ("isalnum", [True, True, True, True, True, False, True, True, False, False]),
  179:         ("isalpha", [True, True, True, False, False, False, True, False, False, False]),
  180:         (
  181:             "isdigit",
  182:             [False, False, False, True, False, False, False, True, False, False],
  183:         ),
  184:         (
  185:             "isnumeric",
  186:             [False, False, False, True, False, False, False, True, False, False],
  187:         ),
  188:         (
  189:             "isspace",
  190:             [False, False, False, False, False, False, False, False, False, True],
  191:         ),
  192:         (
  193:             "islower",
  194:             [False, True, False, False, False, False, False, False, False, False],
  195:         ),
  196:         (
  197:             "isupper",
  198:             [True, False, False, False, True, False, True, False, False, False],
  199:         ),
  200:         (
  201:             "istitle",
  202:             [True, False, True, False, True, False, False, False, False, False],
  203:         ),
  204:     ],
  205: )
  206: def test_ismethods(method, expected, any_string_dtype):
  207:     ser = Series(
  208:         ["A", "b", "Xy", "4", "3A", "", "TT", "55", "-", "  "], dtype=any_string_dtype
  209:     )
  210:     expected_dtype = "bool" if any_string_dtype in object_pyarrow_numpy else "boolean"
  211:     expected = Series(expected, dtype=expected_dtype)
  212:     result = getattr(ser.str, method)()
  213:     tm.assert_series_equal(result, expected)
  214: 
  215:     # compare with standard library
  216:     expected = [getattr(item, method)() for item in ser]
  217:     assert list(result) == expected
  218: 
  219: 
  220: @pytest.mark.parametrize(
  221:     "method, expected",
  222:     [
  223:         ("isnumeric", [False, True, True, False, True, True, False]),
  224:         ("isdecimal", [False, True, False, False, False, True, False]),
  225:     ],
  226: )
  227: def test_isnumeric_unicode(method, expected, any_string_dtype):
  228:     # 0x00bc: Вј VULGAR FRACTION ONE QUARTER
  229:     # 0x2605: в… not number
  230:     # 0x1378: бЌё ETHIOPIC NUMBER SEVENTY
  231:     # 0xFF13: пј“ Em 3  # noqa: RUF003
  232:     ser = Series(
  233:         ["A", "3", "Вј", "в…", "бЌё", "пј“", "four"], dtype=any_string_dtype  # noqa: RUF001
  234:     )
  235:     expected_dtype = "bool" if any_string_dtype in object_pyarrow_numpy else "boolean"
  236:     expected = Series(expected, dtype=expected_dtype)
  237:     result = getattr(ser.str, method)()
  238:     tm.assert_series_equal(result, expected)
  239: 
  240:     # compare with standard library
  241:     expected = [getattr(item, method)() for item in ser]
  242:     assert list(result) == expected
  243: 
  244: 
  245: @pytest.mark.parametrize(
  246:     "method, expected",
  247:     [
  248:         ("isnumeric", [False, np.nan, True, False, np.nan, True, False]),
  249:         ("isdecimal", [False, np.nan, False, False, np.nan, True, False]),
  250:     ],
  251: )
  252: def test_isnumeric_unicode_missing(method, expected, any_string_dtype):
  253:     values = ["A", np.nan, "Вј", "в…", np.nan, "пј“", "four"]  # noqa: RUF001
  254:     ser = Series(values, dtype=any_string_dtype)
  255:     expected_dtype = "object" if any_string_dtype in object_pyarrow_numpy else "boolean"
  256:     expected = Series(expected, dtype=expected_dtype)
  257:     result = getattr(ser.str, method)()
  258:     tm.assert_series_equal(result, expected)
  259: 
  260: 
  261: def test_spilt_join_roundtrip(any_string_dtype):
  262:     ser = Series(["a_b_c", "c_d_e", np.nan, "f_g_h"], dtype=any_string_dtype)
  263:     result = ser.str.split("_").str.join("_")
  264:     expected = ser.astype(object)
  265:     tm.assert_series_equal(result, expected)
  266: 
  267: 
  268: def test_spilt_join_roundtrip_mixed_object():
  269:     ser = Series(
  270:         ["a_b", np.nan, "asdf_cas_asdf", True, datetime.today(), "foo", None, 1, 2.0]
  271:     )
  272:     result = ser.str.split("_").str.join("_")
  273:     expected = Series(
  274:         ["a_b", np.nan, "asdf_cas_asdf", np.nan, np.nan, "foo", None, np.nan, np.nan],
  275:         dtype=object,
  276:     )
  277:     tm.assert_series_equal(result, expected)
  278: 
  279: 
  280: def test_len(any_string_dtype):
  281:     ser = Series(
  282:         ["foo", "fooo", "fooooo", np.nan, "fooooooo", "foo\n", "гЃ‚"],
  283:         dtype=any_string_dtype,
  284:     )
  285:     result = ser.str.len()
  286:     expected_dtype = "float64" if any_string_dtype in object_pyarrow_numpy else "Int64"
  287:     expected = Series([3, 4, 6, np.nan, 8, 4, 1], dtype=expected_dtype)
  288:     tm.assert_series_equal(result, expected)
  289: 
  290: 
  291: def test_len_mixed():
  292:     ser = Series(
  293:         ["a_b", np.nan, "asdf_cas_asdf", True, datetime.today(), "foo", None, 1, 2.0]
  294:     )
  295:     result = ser.str.len()
  296:     expected = Series([3, np.nan, 13, np.nan, np.nan, 3, np.nan, np.nan, np.nan])
  297:     tm.assert_series_equal(result, expected)
  298: 
  299: 
  300: @pytest.mark.parametrize(
  301:     "method,sub,start,end,expected",
  302:     [
  303:         ("index", "EF", None, None, [4, 3, 1, 0]),
  304:         ("rindex", "EF", None, None, [4, 5, 7, 4]),
  305:         ("index", "EF", 3, None, [4, 3, 7, 4]),
  306:         ("rindex", "EF", 3, None, [4, 5, 7, 4]),
  307:         ("index", "E", 4, 8, [4, 5, 7, 4]),
  308:         ("rindex", "E", 0, 5, [4, 3, 1, 4]),
  309:     ],
  310: )
  311: def test_index(method, sub, start, end, index_or_series, any_string_dtype, expected):
  312:     obj = index_or_series(
  313:         ["ABCDEFG", "BCDEFEF", "DEFGHIJEF", "EFGHEF"], dtype=any_string_dtype
  314:     )
  315:     expected_dtype = np.int64 if any_string_dtype in object_pyarrow_numpy else "Int64"
  316:     expected = index_or_series(expected, dtype=expected_dtype)
  317: 
  318:     result = getattr(obj.str, method)(sub, start, end)
  319: 
  320:     if index_or_series is Series:
  321:         tm.assert_series_equal(result, expected)
  322:     else:
  323:         tm.assert_index_equal(result, expected)
  324: 
  325:     # compare with standard library
  326:     expected = [getattr(item, method)(sub, start, end) for item in obj]
  327:     assert list(result) == expected
  328: 
  329: 
  330: def test_index_not_found_raises(index_or_series, any_string_dtype):
  331:     obj = index_or_series(
  332:         ["ABCDEFG", "BCDEFEF", "DEFGHIJEF", "EFGHEF"], dtype=any_string_dtype
  333:     )
  334:     with pytest.raises(ValueError, match="substring not found"):
  335:         obj.str.index("DE")
  336: 
  337: 
  338: @pytest.mark.parametrize("method", ["index", "rindex"])
  339: def test_index_wrong_type_raises(index_or_series, any_string_dtype, method):
  340:     obj = index_or_series([], dtype=any_string_dtype)
  341:     msg = "expected a string object, not int"
  342: 
  343:     with pytest.raises(TypeError, match=msg):
  344:         getattr(obj.str, method)(0)
  345: 
  346: 
  347: @pytest.mark.parametrize(
  348:     "method, exp",
  349:     [
  350:         ["index", [1, 1, 0]],
  351:         ["rindex", [3, 1, 2]],
  352:     ],
  353: )
  354: def test_index_missing(any_string_dtype, method, exp):
  355:     ser = Series(["abcb", "ab", "bcbe", np.nan], dtype=any_string_dtype)
  356:     expected_dtype = np.float64 if any_string_dtype in object_pyarrow_numpy else "Int64"
  357: 
  358:     result = getattr(ser.str, method)("b")
  359:     expected = Series(exp + [np.nan], dtype=expected_dtype)
  360:     tm.assert_series_equal(result, expected)
  361: 
  362: 
  363: def test_pipe_failures(any_string_dtype):
  364:     # #2119
  365:     ser = Series(["A|B|C"], dtype=any_string_dtype)
  366: 
  367:     result = ser.str.split("|")
  368:     expected = Series([["A", "B", "C"]], dtype=object)
  369:     tm.assert_series_equal(result, expected)
  370: 
  371:     result = ser.str.replace("|", " ", regex=False)
  372:     expected = Series(["A B C"], dtype=any_string_dtype)
  373:     tm.assert_series_equal(result, expected)
  374: 
  375: 
  376: @pytest.mark.parametrize(
  377:     "start, stop, step, expected",
  378:     [
  379:         (2, 5, None, ["foo", "bar", np.nan, "baz"]),
  380:         (0, 3, -1, ["", "", np.nan, ""]),
  381:         (None, None, -1, ["owtoofaa", "owtrabaa", np.nan, "xuqzabaa"]),
  382:         (3, 10, 2, ["oto", "ato", np.nan, "aqx"]),
  383:         (3, 0, -1, ["ofa", "aba", np.nan, "aba"]),
  384:     ],
  385: )
  386: def test_slice(start, stop, step, expected, any_string_dtype):
  387:     ser = Series(["aafootwo", "aabartwo", np.nan, "aabazqux"], dtype=any_string_dtype)
  388:     result = ser.str.slice(start, stop, step)
  389:     expected = Series(expected, dtype=any_string_dtype)
  390:     tm.assert_series_equal(result, expected)
  391: 
  392: 
  393: @pytest.mark.parametrize(
  394:     "start, stop, step, expected",
  395:     [
  396:         (2, 5, None, ["foo", np.nan, "bar", np.nan, np.nan, None, np.nan, np.nan]),
  397:         (4, 1, -1, ["oof", np.nan, "rab", np.nan, np.nan, None, np.nan, np.nan]),
  398:     ],
  399: )
  400: def test_slice_mixed_object(start, stop, step, expected):
  401:     ser = Series(["aafootwo", np.nan, "aabartwo", True, datetime.today(), None, 1, 2.0])
  402:     result = ser.str.slice(start, stop, step)
  403:     expected = Series(expected, dtype=object)
  404:     tm.assert_series_equal(result, expected)
  405: 
  406: 
  407: @pytest.mark.parametrize(
  408:     "start,stop,repl,expected",
  409:     [
  410:         (2, 3, None, ["shrt", "a it longer", "evnlongerthanthat", "", np.nan]),
  411:         (2, 3, "z", ["shzrt", "a zit longer", "evznlongerthanthat", "z", np.nan]),
  412:         (2, 2, "z", ["shzort", "a zbit longer", "evzenlongerthanthat", "z", np.nan]),
  413:         (2, 1, "z", ["shzort", "a zbit longer", "evzenlongerthanthat", "z", np.nan]),
  414:         (-1, None, "z", ["shorz", "a bit longez", "evenlongerthanthaz", "z", np.nan]),
  415:         (None, -2, "z", ["zrt", "zer", "zat", "z", np.nan]),
  416:         (6, 8, "z", ["shortz", "a bit znger", "evenlozerthanthat", "z", np.nan]),
  417:         (-10, 3, "z", ["zrt", "a zit longer", "evenlongzerthanthat", "z", np.nan]),
  418:     ],
  419: )
  420: def test_slice_replace(start, stop, repl, expected, any_string_dtype):
  421:     ser = Series(
  422:         ["short", "a bit longer", "evenlongerthanthat", "", np.nan],
  423:         dtype=any_string_dtype,
  424:     )
  425:     expected = Series(expected, dtype=any_string_dtype)
  426:     result = ser.str.slice_replace(start, stop, repl)
  427:     tm.assert_series_equal(result, expected)
  428: 
  429: 
  430: @pytest.mark.parametrize(
  431:     "method, exp",
  432:     [
  433:         ["strip", ["aa", "bb", np.nan, "cc"]],
  434:         ["lstrip", ["aa   ", "bb \n", np.nan, "cc  "]],
  435:         ["rstrip", ["  aa", " bb", np.nan, "cc"]],
  436:     ],
  437: )
  438: def test_strip_lstrip_rstrip(any_string_dtype, method, exp):
  439:     ser = Series(["  aa   ", " bb \n", np.nan, "cc  "], dtype=any_string_dtype)
  440: 
  441:     result = getattr(ser.str, method)()
  442:     expected = Series(exp, dtype=any_string_dtype)
  443:     tm.assert_series_equal(result, expected)
  444: 
  445: 
  446: @pytest.mark.parametrize(
  447:     "method, exp",
  448:     [
  449:         ["strip", ["aa", np.nan, "bb"]],
  450:         ["lstrip", ["aa  ", np.nan, "bb \t\n"]],
  451:         ["rstrip", ["  aa", np.nan, " bb"]],
  452:     ],
  453: )
  454: def test_strip_lstrip_rstrip_mixed_object(method, exp):
  455:     ser = Series(["  aa  ", np.nan, " bb \t\n", True, datetime.today(), None, 1, 2.0])
  456: 
  457:     result = getattr(ser.str, method)()
  458:     expected = Series(exp + [np.nan, np.nan, None, np.nan, np.nan], dtype=object)
  459:     tm.assert_series_equal(result, expected)
  460: 
  461: 
  462: @pytest.mark.parametrize(
  463:     "method, exp",
  464:     [
  465:         ["strip", ["ABC", " BNSD", "LDFJH "]],
  466:         ["lstrip", ["ABCxx", " BNSD", "LDFJH xx"]],
  467:         ["rstrip", ["xxABC", "xx BNSD", "LDFJH "]],
  468:     ],
  469: )
  470: def test_strip_lstrip_rstrip_args(any_string_dtype, method, exp):
  471:     ser = Series(["xxABCxx", "xx BNSD", "LDFJH xx"], dtype=any_string_dtype)
  472: 
  473:     result = getattr(ser.str, method)("x")
  474:     expected = Series(exp, dtype=any_string_dtype)
  475:     tm.assert_series_equal(result, expected)
  476: 
  477: 
  478: @pytest.mark.parametrize(
  479:     "prefix, expected", [("a", ["b", " b c", "bc"]), ("ab", ["", "a b c", "bc"])]
  480: )
  481: def test_removeprefix(any_string_dtype, prefix, expected):
  482:     ser = Series(["ab", "a b c", "bc"], dtype=any_string_dtype)
  483:     result = ser.str.removeprefix(prefix)
  484:     ser_expected = Series(expected, dtype=any_string_dtype)
  485:     tm.assert_series_equal(result, ser_expected)
  486: 
  487: 
  488: @pytest.mark.parametrize(
  489:     "suffix, expected", [("c", ["ab", "a b ", "b"]), ("bc", ["ab", "a b c", ""])]
  490: )
  491: def test_removesuffix(any_string_dtype, suffix, expected):
  492:     ser = Series(["ab", "a b c", "bc"], dtype=any_string_dtype)
  493:     result = ser.str.removesuffix(suffix)
  494:     ser_expected = Series(expected, dtype=any_string_dtype)
  495:     tm.assert_series_equal(result, ser_expected)
  496: 
  497: 
  498: def test_string_slice_get_syntax(any_string_dtype):
  499:     ser = Series(
  500:         ["YYY", "B", "C", "YYYYYYbYYY", "BYYYcYYY", np.nan, "CYYYBYYY", "dog", "cYYYt"],
  501:         dtype=any_string_dtype,
  502:     )
  503: 
  504:     result = ser.str[0]
  505:     expected = ser.str.get(0)
  506:     tm.assert_series_equal(result, expected)
  507: 
  508:     result = ser.str[:3]
  509:     expected = ser.str.slice(stop=3)
  510:     tm.assert_series_equal(result, expected)
  511: 
  512:     result = ser.str[2::-1]
  513:     expected = ser.str.slice(start=2, step=-1)
  514:     tm.assert_series_equal(result, expected)
  515: 
  516: 
  517: def test_string_slice_out_of_bounds_nested():
  518:     ser = Series([(1, 2), (1,), (3, 4, 5)])
  519:     result = ser.str[1]
  520:     expected = Series([2, np.nan, 4])
  521:     tm.assert_series_equal(result, expected)
  522: 
  523: 
  524: def test_string_slice_out_of_bounds(any_string_dtype):
  525:     ser = Series(["foo", "b", "ba"], dtype=any_string_dtype)
  526:     result = ser.str[1]
  527:     expected = Series(["o", np.nan, "a"], dtype=any_string_dtype)
  528:     tm.assert_series_equal(result, expected)
  529: 
  530: 
  531: def test_encode_decode(any_string_dtype):
  532:     ser = Series(["a", "b", "a\xe4"], dtype=any_string_dtype).str.encode("utf-8")
  533:     result = ser.str.decode("utf-8")
  534:     expected = ser.map(lambda x: x.decode("utf-8")).astype(object)
  535:     tm.assert_series_equal(result, expected)
  536: 
  537: 
  538: def test_encode_errors_kwarg(any_string_dtype):
  539:     ser = Series(["a", "b", "a\x9d"], dtype=any_string_dtype)
  540: 
  541:     msg = (
  542:         r"'charmap' codec can't encode character '\\x9d' in position 1: "
  543:         "character maps to <undefined>"
  544:     )
  545:     with pytest.raises(UnicodeEncodeError, match=msg):
  546:         ser.str.encode("cp1252")
  547: 
  548:     result = ser.str.encode("cp1252", "ignore")
  549:     expected = ser.map(lambda x: x.encode("cp1252", "ignore"))
  550:     tm.assert_series_equal(result, expected)
  551: 
  552: 
  553: def test_decode_errors_kwarg():
  554:     ser = Series([b"a", b"b", b"a\x9d"])
  555: 
  556:     msg = (
  557:         "'charmap' codec can't decode byte 0x9d in position 1: "
  558:         "character maps to <undefined>"
  559:     )
  560:     with pytest.raises(UnicodeDecodeError, match=msg):
  561:         ser.str.decode("cp1252")
  562: 
  563:     result = ser.str.decode("cp1252", "ignore")
  564:     expected = ser.map(lambda x: x.decode("cp1252", "ignore")).astype(object)
  565:     tm.assert_series_equal(result, expected)
  566: 
  567: 
  568: @pytest.mark.parametrize(
  569:     "form, expected",
  570:     [
  571:         ("NFKC", ["ABC", "ABC", "123", np.nan, "г‚ўг‚¤г‚Ё"]),
  572:         ("NFC", ["ABC", "пјЎпјўпјЈ", "пј‘пј’пј“", np.nan, "пЅ±пЅІпЅґ"]),  # noqa: RUF001
  573:     ],
  574: )
  575: def test_normalize(form, expected, any_string_dtype):
  576:     ser = Series(
  577:         ["ABC", "пјЎпјўпјЈ", "пј‘пј’пј“", np.nan, "пЅ±пЅІпЅґ"],  # noqa: RUF001
  578:         index=["a", "b", "c", "d", "e"],
  579:         dtype=any_string_dtype,
  580:     )
  581:     expected = Series(expected, index=["a", "b", "c", "d", "e"], dtype=any_string_dtype)
  582:     result = ser.str.normalize(form)
  583:     tm.assert_series_equal(result, expected)
  584: 
  585: 
  586: def test_normalize_bad_arg_raises(any_string_dtype):
  587:     ser = Series(
  588:         ["ABC", "пјЎпјўпјЈ", "пј‘пј’пј“", np.nan, "пЅ±пЅІпЅґ"],  # noqa: RUF001
  589:         index=["a", "b", "c", "d", "e"],
  590:         dtype=any_string_dtype,
  591:     )
  592:     with pytest.raises(ValueError, match="invalid normalization form"):
  593:         ser.str.normalize("xxx")
  594: 
  595: 
  596: def test_normalize_index():
  597:     idx = Index(["пјЎпјўпјЈ", "пј‘пј’пј“", "пЅ±пЅІпЅґ"])  # noqa: RUF001
  598:     expected = Index(["ABC", "123", "г‚ўг‚¤г‚Ё"])
  599:     result = idx.str.normalize("NFKC")
  600:     tm.assert_index_equal(result, expected)
  601: 
  602: 
  603: @pytest.mark.parametrize(
  604:     "values,inferred_type",
  605:     [
  606:         (["a", "b"], "string"),
  607:         (["a", "b", 1], "mixed-integer"),
  608:         (["a", "b", 1.3], "mixed"),
  609:         (["a", "b", 1.3, 1], "mixed-integer"),
  610:         (["aa", datetime(2011, 1, 1)], "mixed"),
  611:     ],
  612: )
  613: def test_index_str_accessor_visibility(values, inferred_type, index_or_series):
  614:     obj = index_or_series(values)
  615:     if index_or_series is Index:
  616:         assert obj.inferred_type == inferred_type
  617: 
  618:     assert isinstance(obj.str, StringMethods)
  619: 
  620: 
  621: @pytest.mark.parametrize(
  622:     "values,inferred_type",
  623:     [
  624:         ([1, np.nan], "floating"),
  625:         ([datetime(2011, 1, 1)], "datetime64"),
  626:         ([timedelta(1)], "timedelta64"),
  627:     ],
  628: )
  629: def test_index_str_accessor_non_string_values_raises(
  630:     values, inferred_type, index_or_series
  631: ):
  632:     obj = index_or_series(values)
  633:     if index_or_series is Index:
  634:         assert obj.inferred_type == inferred_type
  635: 
  636:     msg = "Can only use .str accessor with string values"
  637:     with pytest.raises(AttributeError, match=msg):
  638:         obj.str
  639: 
  640: 
  641: def test_index_str_accessor_multiindex_raises():
  642:     # MultiIndex has mixed dtype, but not allow to use accessor
  643:     idx = MultiIndex.from_tuples([("a", "b"), ("a", "b")])
  644:     assert idx.inferred_type == "mixed"
  645: 
  646:     msg = "Can only use .str accessor with Index, not MultiIndex"
  647:     with pytest.raises(AttributeError, match=msg):
  648:         idx.str
  649: 
  650: 
  651: def test_str_accessor_no_new_attributes(any_string_dtype):
  652:     # https://github.com/pandas-dev/pandas/issues/10673
  653:     ser = Series(list("aabbcde"), dtype=any_string_dtype)
  654:     with pytest.raises(AttributeError, match="You cannot add any new attribute"):
  655:         ser.str.xlabel = "a"
  656: 
  657: 
  658: def test_cat_on_bytes_raises():
  659:     lhs = Series(np.array(list("abc"), "S1").astype(object))
  660:     rhs = Series(np.array(list("def"), "S1").astype(object))
  661:     msg = "Cannot use .str.cat with values of inferred dtype 'bytes'"
  662:     with pytest.raises(TypeError, match=msg):
  663:         lhs.str.cat(rhs)
  664: 
  665: 
  666: def test_str_accessor_in_apply_func():
  667:     # https://github.com/pandas-dev/pandas/issues/38979
  668:     df = DataFrame(zip("abc", "def"))
  669:     expected = Series(["A/D", "B/E", "C/F"])
  670:     result = df.apply(lambda f: "/".join(f.str.upper()), axis=1)
  671:     tm.assert_series_equal(result, expected)
  672: 
  673: 
  674: def test_zfill():
  675:     # https://github.com/pandas-dev/pandas/issues/20868
  676:     value = Series(["-1", "1", "1000", 10, np.nan])
  677:     expected = Series(["-01", "001", "1000", np.nan, np.nan], dtype=object)
  678:     tm.assert_series_equal(value.str.zfill(3), expected)
  679: 
  680:     value = Series(["-2", "+5"])
  681:     expected = Series(["-0002", "+0005"])
  682:     tm.assert_series_equal(value.str.zfill(5), expected)
  683: 
  684: 
  685: def test_zfill_with_non_integer_argument():
  686:     value = Series(["-2", "+5"])
  687:     wid = "a"
  688:     msg = f"width must be of integer type, not {type(wid).__name__}"
  689:     with pytest.raises(TypeError, match=msg):
  690:         value.str.zfill(wid)
  691: 
  692: 
  693: def test_zfill_with_leading_sign():
  694:     value = Series(["-cat", "-1", "+dog"])
  695:     expected = Series(["-0cat", "-0001", "+0dog"])
  696:     tm.assert_series_equal(value.str.zfill(5), expected)
  697: 
  698: 
  699: def test_get_with_dict_label():
  700:     # GH47911
  701:     s = Series(
  702:         [
  703:             {"name": "Hello", "value": "World"},
  704:             {"name": "Goodbye", "value": "Planet"},
  705:             {"value": "Sea"},
  706:         ]
  707:     )
  708:     result = s.str.get("name")
  709:     expected = Series(["Hello", "Goodbye", None], dtype=object)
  710:     tm.assert_series_equal(result, expected)
  711:     result = s.str.get("value")
  712:     expected = Series(["World", "Planet", "Sea"], dtype=object)
  713:     tm.assert_series_equal(result, expected)
  714: 
  715: 
  716: def test_series_str_decode():
  717:     # GH 22613
  718:     result = Series([b"x", b"y"]).str.decode(encoding="UTF-8", errors="strict")
  719:     expected = Series(["x", "y"], dtype="object")
  720:     tm.assert_series_equal(result, expected)
