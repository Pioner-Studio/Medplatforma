    1: from datetime import datetime
    2: import re
    3: 
    4: import numpy as np
    5: import pytest
    6: 
    7: from pandas.core.dtypes.dtypes import ArrowDtype
    8: 
    9: from pandas import (
   10:     DataFrame,
   11:     Index,
   12:     MultiIndex,
   13:     Series,
   14:     _testing as tm,
   15: )
   16: 
   17: 
   18: def test_extract_expand_kwarg_wrong_type_raises(any_string_dtype):
   19:     # TODO: should this raise TypeError
   20:     values = Series(["fooBAD__barBAD", np.nan, "foo"], dtype=any_string_dtype)
   21:     with pytest.raises(ValueError, match="expand must be True or False"):
   22:         values.str.extract(".*(BAD[_]+).*(BAD)", expand=None)
   23: 
   24: 
   25: def test_extract_expand_kwarg(any_string_dtype):
   26:     s = Series(["fooBAD__barBAD", np.nan, "foo"], dtype=any_string_dtype)
   27:     expected = DataFrame(["BAD__", np.nan, np.nan], dtype=any_string_dtype)
   28: 
   29:     result = s.str.extract(".*(BAD[_]+).*")
   30:     tm.assert_frame_equal(result, expected)
   31: 
   32:     result = s.str.extract(".*(BAD[_]+).*", expand=True)
   33:     tm.assert_frame_equal(result, expected)
   34: 
   35:     expected = DataFrame(
   36:         [["BAD__", "BAD"], [np.nan, np.nan], [np.nan, np.nan]], dtype=any_string_dtype
   37:     )
   38:     result = s.str.extract(".*(BAD[_]+).*(BAD)", expand=False)
   39:     tm.assert_frame_equal(result, expected)
   40: 
   41: 
   42: def test_extract_expand_False_mixed_object():
   43:     ser = Series(
   44:         ["aBAD_BAD", np.nan, "BAD_b_BAD", True, datetime.today(), "foo", None, 1, 2.0]
   45:     )
   46: 
   47:     # two groups
   48:     result = ser.str.extract(".*(BAD[_]+).*(BAD)", expand=False)
   49:     er = [np.nan, np.nan]  # empty row
   50:     expected = DataFrame(
   51:         [["BAD_", "BAD"], er, ["BAD_", "BAD"], er, er, er, er, er, er], dtype=object
   52:     )
   53:     tm.assert_frame_equal(result, expected)
   54: 
   55:     # single group
   56:     result = ser.str.extract(".*(BAD[_]+).*BAD", expand=False)
   57:     expected = Series(
   58:         ["BAD_", np.nan, "BAD_", np.nan, np.nan, np.nan, None, np.nan, np.nan],
   59:         dtype=object,
   60:     )
   61:     tm.assert_series_equal(result, expected)
   62: 
   63: 
   64: def test_extract_expand_index_raises():
   65:     # GH9980
   66:     # Index only works with one regex group since
   67:     # multi-group would expand to a frame
   68:     idx = Index(["A1", "A2", "A3", "A4", "B5"])
   69:     msg = "only one regex group is supported with Index"
   70:     with pytest.raises(ValueError, match=msg):
   71:         idx.str.extract("([AB])([123])", expand=False)
   72: 
   73: 
   74: def test_extract_expand_no_capture_groups_raises(index_or_series, any_string_dtype):
   75:     s_or_idx = index_or_series(["A1", "B2", "C3"], dtype=any_string_dtype)
   76:     msg = "pattern contains no capture groups"
   77: 
   78:     # no groups
   79:     with pytest.raises(ValueError, match=msg):
   80:         s_or_idx.str.extract("[ABC][123]", expand=False)
   81: 
   82:     # only non-capturing groups
   83:     with pytest.raises(ValueError, match=msg):
   84:         s_or_idx.str.extract("(?:[AB]).*", expand=False)
   85: 
   86: 
   87: def test_extract_expand_single_capture_group(index_or_series, any_string_dtype):
   88:     # single group renames series/index properly
   89:     s_or_idx = index_or_series(["A1", "A2"], dtype=any_string_dtype)
   90:     result = s_or_idx.str.extract(r"(?P<uno>A)\d", expand=False)
   91: 
   92:     expected = index_or_series(["A", "A"], name="uno", dtype=any_string_dtype)
   93:     if index_or_series == Series:
   94:         tm.assert_series_equal(result, expected)
   95:     else:
   96:         tm.assert_index_equal(result, expected)
   97: 
   98: 
   99: def test_extract_expand_capture_groups(any_string_dtype):
  100:     s = Series(["A1", "B2", "C3"], dtype=any_string_dtype)
  101:     # one group, no matches
  102:     result = s.str.extract("(_)", expand=False)
  103:     expected = Series([np.nan, np.nan, np.nan], dtype=any_string_dtype)
  104:     tm.assert_series_equal(result, expected)
  105: 
  106:     # two groups, no matches
  107:     result = s.str.extract("(_)(_)", expand=False)
  108:     expected = DataFrame(
  109:         [[np.nan, np.nan], [np.nan, np.nan], [np.nan, np.nan]], dtype=any_string_dtype
  110:     )
  111:     tm.assert_frame_equal(result, expected)
  112: 
  113:     # one group, some matches
  114:     result = s.str.extract("([AB])[123]", expand=False)
  115:     expected = Series(["A", "B", np.nan], dtype=any_string_dtype)
  116:     tm.assert_series_equal(result, expected)
  117: 
  118:     # two groups, some matches
  119:     result = s.str.extract("([AB])([123])", expand=False)
  120:     expected = DataFrame(
  121:         [["A", "1"], ["B", "2"], [np.nan, np.nan]], dtype=any_string_dtype
  122:     )
  123:     tm.assert_frame_equal(result, expected)
  124: 
  125:     # one named group
  126:     result = s.str.extract("(?P<letter>[AB])", expand=False)
  127:     expected = Series(["A", "B", np.nan], name="letter", dtype=any_string_dtype)
  128:     tm.assert_series_equal(result, expected)
  129: 
  130:     # two named groups
  131:     result = s.str.extract("(?P<letter>[AB])(?P<number>[123])", expand=False)
  132:     expected = DataFrame(
  133:         [["A", "1"], ["B", "2"], [np.nan, np.nan]],
  134:         columns=["letter", "number"],
  135:         dtype=any_string_dtype,
  136:     )
  137:     tm.assert_frame_equal(result, expected)
  138: 
  139:     # mix named and unnamed groups
  140:     result = s.str.extract("([AB])(?P<number>[123])", expand=False)
  141:     expected = DataFrame(
  142:         [["A", "1"], ["B", "2"], [np.nan, np.nan]],
  143:         columns=[0, "number"],
  144:         dtype=any_string_dtype,
  145:     )
  146:     tm.assert_frame_equal(result, expected)
  147: 
  148:     # one normal group, one non-capturing group
  149:     result = s.str.extract("([AB])(?:[123])", expand=False)
  150:     expected = Series(["A", "B", np.nan], dtype=any_string_dtype)
  151:     tm.assert_series_equal(result, expected)
  152: 
  153:     # two normal groups, one non-capturing group
  154:     s = Series(["A11", "B22", "C33"], dtype=any_string_dtype)
  155:     result = s.str.extract("([AB])([123])(?:[123])", expand=False)
  156:     expected = DataFrame(
  157:         [["A", "1"], ["B", "2"], [np.nan, np.nan]], dtype=any_string_dtype
  158:     )
  159:     tm.assert_frame_equal(result, expected)
  160: 
  161:     # one optional group followed by one normal group
  162:     s = Series(["A1", "B2", "3"], dtype=any_string_dtype)
  163:     result = s.str.extract("(?P<letter>[AB])?(?P<number>[123])", expand=False)
  164:     expected = DataFrame(
  165:         [["A", "1"], ["B", "2"], [np.nan, "3"]],
  166:         columns=["letter", "number"],
  167:         dtype=any_string_dtype,
  168:     )
  169:     tm.assert_frame_equal(result, expected)
  170: 
  171:     # one normal group followed by one optional group
  172:     s = Series(["A1", "B2", "C"], dtype=any_string_dtype)
  173:     result = s.str.extract("(?P<letter>[ABC])(?P<number>[123])?", expand=False)
  174:     expected = DataFrame(
  175:         [["A", "1"], ["B", "2"], ["C", np.nan]],
  176:         columns=["letter", "number"],
  177:         dtype=any_string_dtype,
  178:     )
  179:     tm.assert_frame_equal(result, expected)
  180: 
  181: 
  182: def test_extract_expand_capture_groups_index(index, any_string_dtype):
  183:     # https://github.com/pandas-dev/pandas/issues/6348
  184:     # not passing index to the extractor
  185:     data = ["A1", "B2", "C"]
  186: 
  187:     if len(index) == 0:
  188:         pytest.skip("Test requires len(index) > 0")
  189:     while len(index) < len(data):
  190:         index = index.repeat(2)
  191: 
  192:     index = index[: len(data)]
  193:     ser = Series(data, index=index, dtype=any_string_dtype)
  194: 
  195:     result = ser.str.extract(r"(\d)", expand=False)
  196:     expected = Series(["1", "2", np.nan], index=index, dtype=any_string_dtype)
  197:     tm.assert_series_equal(result, expected)
  198: 
  199:     result = ser.str.extract(r"(?P<letter>\D)(?P<number>\d)?", expand=False)
  200:     expected = DataFrame(
  201:         [["A", "1"], ["B", "2"], ["C", np.nan]],
  202:         columns=["letter", "number"],
  203:         index=index,
  204:         dtype=any_string_dtype,
  205:     )
  206:     tm.assert_frame_equal(result, expected)
  207: 
  208: 
  209: def test_extract_single_series_name_is_preserved(any_string_dtype):
  210:     s = Series(["a3", "b3", "c2"], name="bob", dtype=any_string_dtype)
  211:     result = s.str.extract(r"(?P<sue>[a-z])", expand=False)
  212:     expected = Series(["a", "b", "c"], name="sue", dtype=any_string_dtype)
  213:     tm.assert_series_equal(result, expected)
  214: 
  215: 
  216: def test_extract_expand_True(any_string_dtype):
  217:     # Contains tests like those in test_match and some others.
  218:     s = Series(["fooBAD__barBAD", np.nan, "foo"], dtype=any_string_dtype)
  219: 
  220:     result = s.str.extract(".*(BAD[_]+).*(BAD)", expand=True)
  221:     expected = DataFrame(
  222:         [["BAD__", "BAD"], [np.nan, np.nan], [np.nan, np.nan]], dtype=any_string_dtype
  223:     )
  224:     tm.assert_frame_equal(result, expected)
  225: 
  226: 
  227: def test_extract_expand_True_mixed_object():
  228:     er = [np.nan, np.nan]  # empty row
  229:     mixed = Series(
  230:         [
  231:             "aBAD_BAD",
  232:             np.nan,
  233:             "BAD_b_BAD",
  234:             True,
  235:             datetime.today(),
  236:             "foo",
  237:             None,
  238:             1,
  239:             2.0,
  240:         ]
  241:     )
  242: 
  243:     result = mixed.str.extract(".*(BAD[_]+).*(BAD)", expand=True)
  244:     expected = DataFrame(
  245:         [["BAD_", "BAD"], er, ["BAD_", "BAD"], er, er, er, er, er, er], dtype=object
  246:     )
  247:     tm.assert_frame_equal(result, expected)
  248: 
  249: 
  250: def test_extract_expand_True_single_capture_group_raises(
  251:     index_or_series, any_string_dtype
  252: ):
  253:     # these should work for both Series and Index
  254:     # no groups
  255:     s_or_idx = index_or_series(["A1", "B2", "C3"], dtype=any_string_dtype)
  256:     msg = "pattern contains no capture groups"
  257:     with pytest.raises(ValueError, match=msg):
  258:         s_or_idx.str.extract("[ABC][123]", expand=True)
  259: 
  260:     # only non-capturing groups
  261:     with pytest.raises(ValueError, match=msg):
  262:         s_or_idx.str.extract("(?:[AB]).*", expand=True)
  263: 
  264: 
  265: def test_extract_expand_True_single_capture_group(index_or_series, any_string_dtype):
  266:     # single group renames series/index properly
  267:     s_or_idx = index_or_series(["A1", "A2"], dtype=any_string_dtype)
  268:     result = s_or_idx.str.extract(r"(?P<uno>A)\d", expand=True)
  269:     expected = DataFrame({"uno": ["A", "A"]}, dtype=any_string_dtype)
  270:     tm.assert_frame_equal(result, expected)
  271: 
  272: 
  273: @pytest.mark.parametrize("name", [None, "series_name"])
  274: def test_extract_series(name, any_string_dtype):
  275:     # extract should give the same result whether or not the series has a name.
  276:     s = Series(["A1", "B2", "C3"], name=name, dtype=any_string_dtype)
  277: 
  278:     # one group, no matches
  279:     result = s.str.extract("(_)", expand=True)
  280:     expected = DataFrame([np.nan, np.nan, np.nan], dtype=any_string_dtype)
  281:     tm.assert_frame_equal(result, expected)
  282: 
  283:     # two groups, no matches
  284:     result = s.str.extract("(_)(_)", expand=True)
  285:     expected = DataFrame(
  286:         [[np.nan, np.nan], [np.nan, np.nan], [np.nan, np.nan]], dtype=any_string_dtype
  287:     )
  288:     tm.assert_frame_equal(result, expected)
  289: 
  290:     # one group, some matches
  291:     result = s.str.extract("([AB])[123]", expand=True)
  292:     expected = DataFrame(["A", "B", np.nan], dtype=any_string_dtype)
  293:     tm.assert_frame_equal(result, expected)
  294: 
  295:     # two groups, some matches
  296:     result = s.str.extract("([AB])([123])", expand=True)
  297:     expected = DataFrame(
  298:         [["A", "1"], ["B", "2"], [np.nan, np.nan]], dtype=any_string_dtype
  299:     )
  300:     tm.assert_frame_equal(result, expected)
  301: 
  302:     # one named group
  303:     result = s.str.extract("(?P<letter>[AB])", expand=True)
  304:     expected = DataFrame({"letter": ["A", "B", np.nan]}, dtype=any_string_dtype)
  305:     tm.assert_frame_equal(result, expected)
  306: 
  307:     # two named groups
  308:     result = s.str.extract("(?P<letter>[AB])(?P<number>[123])", expand=True)
  309:     expected = DataFrame(
  310:         [["A", "1"], ["B", "2"], [np.nan, np.nan]],
  311:         columns=["letter", "number"],
  312:         dtype=any_string_dtype,
  313:     )
  314:     tm.assert_frame_equal(result, expected)
  315: 
  316:     # mix named and unnamed groups
  317:     result = s.str.extract("([AB])(?P<number>[123])", expand=True)
  318:     expected = DataFrame(
  319:         [["A", "1"], ["B", "2"], [np.nan, np.nan]],
  320:         columns=[0, "number"],
  321:         dtype=any_string_dtype,
  322:     )
  323:     tm.assert_frame_equal(result, expected)
  324: 
  325:     # one normal group, one non-capturing group
  326:     result = s.str.extract("([AB])(?:[123])", expand=True)
  327:     expected = DataFrame(["A", "B", np.nan], dtype=any_string_dtype)
  328:     tm.assert_frame_equal(result, expected)
  329: 
  330: 
  331: def test_extract_optional_groups(any_string_dtype):
  332:     # two normal groups, one non-capturing group
  333:     s = Series(["A11", "B22", "C33"], dtype=any_string_dtype)
  334:     result = s.str.extract("([AB])([123])(?:[123])", expand=True)
  335:     expected = DataFrame(
  336:         [["A", "1"], ["B", "2"], [np.nan, np.nan]], dtype=any_string_dtype
  337:     )
  338:     tm.assert_frame_equal(result, expected)
  339: 
  340:     # one optional group followed by one normal group
  341:     s = Series(["A1", "B2", "3"], dtype=any_string_dtype)
  342:     result = s.str.extract("(?P<letter>[AB])?(?P<number>[123])", expand=True)
  343:     expected = DataFrame(
  344:         [["A", "1"], ["B", "2"], [np.nan, "3"]],
  345:         columns=["letter", "number"],
  346:         dtype=any_string_dtype,
  347:     )
  348:     tm.assert_frame_equal(result, expected)
  349: 
  350:     # one normal group followed by one optional group
  351:     s = Series(["A1", "B2", "C"], dtype=any_string_dtype)
  352:     result = s.str.extract("(?P<letter>[ABC])(?P<number>[123])?", expand=True)
  353:     expected = DataFrame(
  354:         [["A", "1"], ["B", "2"], ["C", np.nan]],
  355:         columns=["letter", "number"],
  356:         dtype=any_string_dtype,
  357:     )
  358:     tm.assert_frame_equal(result, expected)
  359: 
  360: 
  361: def test_extract_dataframe_capture_groups_index(index, any_string_dtype):
  362:     # GH6348
  363:     # not passing index to the extractor
  364: 
  365:     data = ["A1", "B2", "C"]
  366: 
  367:     if len(index) < len(data):
  368:         pytest.skip(f"Index needs more than {len(data)} values")
  369: 
  370:     index = index[: len(data)]
  371:     s = Series(data, index=index, dtype=any_string_dtype)
  372: 
  373:     result = s.str.extract(r"(\d)", expand=True)
  374:     expected = DataFrame(["1", "2", np.nan], index=index, dtype=any_string_dtype)
  375:     tm.assert_frame_equal(result, expected)
  376: 
  377:     result = s.str.extract(r"(?P<letter>\D)(?P<number>\d)?", expand=True)
  378:     expected = DataFrame(
  379:         [["A", "1"], ["B", "2"], ["C", np.nan]],
  380:         columns=["letter", "number"],
  381:         index=index,
  382:         dtype=any_string_dtype,
  383:     )
  384:     tm.assert_frame_equal(result, expected)
  385: 
  386: 
  387: def test_extract_single_group_returns_frame(any_string_dtype):
  388:     # GH11386 extract should always return DataFrame, even when
  389:     # there is only one group. Prior to v0.18.0, extract returned
  390:     # Series when there was only one group in the regex.
  391:     s = Series(["a3", "b3", "c2"], name="series_name", dtype=any_string_dtype)
  392:     result = s.str.extract(r"(?P<letter>[a-z])", expand=True)
  393:     expected = DataFrame({"letter": ["a", "b", "c"]}, dtype=any_string_dtype)
  394:     tm.assert_frame_equal(result, expected)
  395: 
  396: 
  397: def test_extractall(any_string_dtype):
  398:     data = [
  399:         "dave@google.com",
  400:         "tdhock5@gmail.com",
  401:         "maudelaperriere@gmail.com",
  402:         "rob@gmail.com some text steve@gmail.com",
  403:         "a@b.com some text c@d.com and e@f.com",
  404:         np.nan,
  405:         "",
  406:     ]
  407:     expected_tuples = [
  408:         ("dave", "google", "com"),
  409:         ("tdhock5", "gmail", "com"),
  410:         ("maudelaperriere", "gmail", "com"),
  411:         ("rob", "gmail", "com"),
  412:         ("steve", "gmail", "com"),
  413:         ("a", "b", "com"),
  414:         ("c", "d", "com"),
  415:         ("e", "f", "com"),
  416:     ]
  417:     pat = r"""
  418:     (?P<user>[a-z0-9]+)
  419:     @
  420:     (?P<domain>[a-z]+)
  421:     \.
  422:     (?P<tld>[a-z]{2,4})
  423:     """
  424:     expected_columns = ["user", "domain", "tld"]
  425:     s = Series(data, dtype=any_string_dtype)
  426:     # extractall should return a DataFrame with one row for each match, indexed by the
  427:     # subject from which the match came.
  428:     expected_index = MultiIndex.from_tuples(
  429:         [(0, 0), (1, 0), (2, 0), (3, 0), (3, 1), (4, 0), (4, 1), (4, 2)],
  430:         names=(None, "match"),
  431:     )
  432:     expected = DataFrame(
  433:         expected_tuples, expected_index, expected_columns, dtype=any_string_dtype
  434:     )
  435:     result = s.str.extractall(pat, flags=re.VERBOSE)
  436:     tm.assert_frame_equal(result, expected)
  437: 
  438:     # The index of the input Series should be used to construct the index of the output
  439:     # DataFrame:
  440:     mi = MultiIndex.from_tuples(
  441:         [
  442:             ("single", "Dave"),
  443:             ("single", "Toby"),
  444:             ("single", "Maude"),
  445:             ("multiple", "robAndSteve"),
  446:             ("multiple", "abcdef"),
  447:             ("none", "missing"),
  448:             ("none", "empty"),
  449:         ]
  450:     )
  451:     s = Series(data, index=mi, dtype=any_string_dtype)
  452:     expected_index = MultiIndex.from_tuples(
  453:         [
  454:             ("single", "Dave", 0),
  455:             ("single", "Toby", 0),
  456:             ("single", "Maude", 0),
  457:             ("multiple", "robAndSteve", 0),
  458:             ("multiple", "robAndSteve", 1),
  459:             ("multiple", "abcdef", 0),
  460:             ("multiple", "abcdef", 1),
  461:             ("multiple", "abcdef", 2),
  462:         ],
  463:         names=(None, None, "match"),
  464:     )
  465:     expected = DataFrame(
  466:         expected_tuples, expected_index, expected_columns, dtype=any_string_dtype
  467:     )
  468:     result = s.str.extractall(pat, flags=re.VERBOSE)
  469:     tm.assert_frame_equal(result, expected)
  470: 
  471:     # MultiIndexed subject with names.
  472:     s = Series(data, index=mi, dtype=any_string_dtype)
  473:     s.index.names = ("matches", "description")
  474:     expected_index.names = ("matches", "description", "match")
  475:     expected = DataFrame(
  476:         expected_tuples, expected_index, expected_columns, dtype=any_string_dtype
  477:     )
  478:     result = s.str.extractall(pat, flags=re.VERBOSE)
  479:     tm.assert_frame_equal(result, expected)
  480: 
  481: 
  482: @pytest.mark.parametrize(
  483:     "pat,expected_names",
  484:     [
  485:         # optional groups.
  486:         ("(?P<letter>[AB])?(?P<number>[123])", ["letter", "number"]),
  487:         # only one of two groups has a name.
  488:         ("([AB])?(?P<number>[123])", [0, "number"]),
  489:     ],
  490: )
  491: def test_extractall_column_names(pat, expected_names, any_string_dtype):
  492:     s = Series(["", "A1", "32"], dtype=any_string_dtype)
  493: 
  494:     result = s.str.extractall(pat)
  495:     expected = DataFrame(
  496:         [("A", "1"), (np.nan, "3"), (np.nan, "2")],
  497:         index=MultiIndex.from_tuples([(1, 0), (2, 0), (2, 1)], names=(None, "match")),
  498:         columns=expected_names,
  499:         dtype=any_string_dtype,
  500:     )
  501:     tm.assert_frame_equal(result, expected)
  502: 
  503: 
  504: def test_extractall_single_group(any_string_dtype):
  505:     s = Series(["a3", "b3", "d4c2"], name="series_name", dtype=any_string_dtype)
  506:     expected_index = MultiIndex.from_tuples(
  507:         [(0, 0), (1, 0), (2, 0), (2, 1)], names=(None, "match")
  508:     )
  509: 
  510:     # extractall(one named group) returns DataFrame with one named column.
  511:     result = s.str.extractall(r"(?P<letter>[a-z])")
  512:     expected = DataFrame(
  513:         {"letter": ["a", "b", "d", "c"]}, index=expected_index, dtype=any_string_dtype
  514:     )
  515:     tm.assert_frame_equal(result, expected)
  516: 
  517:     # extractall(one un-named group) returns DataFrame with one un-named column.
  518:     result = s.str.extractall(r"([a-z])")
  519:     expected = DataFrame(
  520:         ["a", "b", "d", "c"], index=expected_index, dtype=any_string_dtype
  521:     )
  522:     tm.assert_frame_equal(result, expected)
  523: 
  524: 
  525: def test_extractall_single_group_with_quantifier(any_string_dtype):
  526:     # GH#13382
  527:     # extractall(one un-named group with quantifier) returns DataFrame with one un-named
  528:     # column.
  529:     s = Series(["ab3", "abc3", "d4cd2"], name="series_name", dtype=any_string_dtype)
  530:     result = s.str.extractall(r"([a-z]+)")
  531:     expected = DataFrame(
  532:         ["ab", "abc", "d", "cd"],
  533:         index=MultiIndex.from_tuples(
  534:             [(0, 0), (1, 0), (2, 0), (2, 1)], names=(None, "match")
  535:         ),
  536:         dtype=any_string_dtype,
  537:     )
  538:     tm.assert_frame_equal(result, expected)
  539: 
  540: 
  541: @pytest.mark.parametrize(
  542:     "data, names",
  543:     [
  544:         ([], (None,)),
  545:         ([], ("i1",)),
  546:         ([], (None, "i2")),
  547:         ([], ("i1", "i2")),
  548:         (["a3", "b3", "d4c2"], (None,)),
  549:         (["a3", "b3", "d4c2"], ("i1", "i2")),
  550:         (["a3", "b3", "d4c2"], (None, "i2")),
  551:         (["a3", "b3", "d4c2"], ("i1", "i2")),
  552:     ],
  553: )
  554: def test_extractall_no_matches(data, names, any_string_dtype):
  555:     # GH19075 extractall with no matches should return a valid MultiIndex
  556:     n = len(data)
  557:     if len(names) == 1:
  558:         index = Index(range(n), name=names[0])
  559:     else:
  560:         tuples = (tuple([i] * (n - 1)) for i in range(n))
  561:         index = MultiIndex.from_tuples(tuples, names=names)
  562:     s = Series(data, name="series_name", index=index, dtype=any_string_dtype)
  563:     expected_index = MultiIndex.from_tuples([], names=(names + ("match",)))
  564: 
  565:     # one un-named group.
  566:     result = s.str.extractall("(z)")
  567:     expected = DataFrame(columns=[0], index=expected_index, dtype=any_string_dtype)
  568:     tm.assert_frame_equal(result, expected)
  569: 
  570:     # two un-named groups.
  571:     result = s.str.extractall("(z)(z)")
  572:     expected = DataFrame(columns=[0, 1], index=expected_index, dtype=any_string_dtype)
  573:     tm.assert_frame_equal(result, expected)
  574: 
  575:     # one named group.
  576:     result = s.str.extractall("(?P<first>z)")
  577:     expected = DataFrame(
  578:         columns=["first"], index=expected_index, dtype=any_string_dtype
  579:     )
  580:     tm.assert_frame_equal(result, expected)
  581: 
  582:     # two named groups.
  583:     result = s.str.extractall("(?P<first>z)(?P<second>z)")
  584:     expected = DataFrame(
  585:         columns=["first", "second"], index=expected_index, dtype=any_string_dtype
  586:     )
  587:     tm.assert_frame_equal(result, expected)
  588: 
  589:     # one named, one un-named.
  590:     result = s.str.extractall("(z)(?P<second>z)")
  591:     expected = DataFrame(
  592:         columns=[0, "second"], index=expected_index, dtype=any_string_dtype
  593:     )
  594:     tm.assert_frame_equal(result, expected)
  595: 
  596: 
  597: def test_extractall_stringindex(any_string_dtype):
  598:     s = Series(["a1a2", "b1", "c1"], name="xxx", dtype=any_string_dtype)
  599:     result = s.str.extractall(r"[ab](?P<digit>\d)")
  600:     expected = DataFrame(
  601:         {"digit": ["1", "2", "1"]},
  602:         index=MultiIndex.from_tuples([(0, 0), (0, 1), (1, 0)], names=[None, "match"]),
  603:         dtype=any_string_dtype,
  604:     )
  605:     tm.assert_frame_equal(result, expected)
  606: 
  607:     # index should return the same result as the default index without name thus
  608:     # index.name doesn't affect to the result
  609:     if any_string_dtype == "object":
  610:         for idx in [
  611:             Index(["a1a2", "b1", "c1"], dtype=object),
  612:             Index(["a1a2", "b1", "c1"], name="xxx", dtype=object),
  613:         ]:
  614:             result = idx.str.extractall(r"[ab](?P<digit>\d)")
  615:             tm.assert_frame_equal(result, expected)
  616: 
  617:     s = Series(
  618:         ["a1a2", "b1", "c1"],
  619:         name="s_name",
  620:         index=Index(["XX", "yy", "zz"], name="idx_name"),
  621:         dtype=any_string_dtype,
  622:     )
  623:     result = s.str.extractall(r"[ab](?P<digit>\d)")
  624:     expected = DataFrame(
  625:         {"digit": ["1", "2", "1"]},
  626:         index=MultiIndex.from_tuples(
  627:             [("XX", 0), ("XX", 1), ("yy", 0)], names=["idx_name", "match"]
  628:         ),
  629:         dtype=any_string_dtype,
  630:     )
  631:     tm.assert_frame_equal(result, expected)
  632: 
  633: 
  634: def test_extractall_no_capture_groups_raises(any_string_dtype):
  635:     # Does not make sense to use extractall with a regex that has no capture groups.
  636:     # (it returns DataFrame with one column for each capture group)
  637:     s = Series(["a3", "b3", "d4c2"], name="series_name", dtype=any_string_dtype)
  638:     with pytest.raises(ValueError, match="no capture groups"):
  639:         s.str.extractall(r"[a-z]")
  640: 
  641: 
  642: def test_extract_index_one_two_groups():
  643:     s = Series(["a3", "b3", "d4c2"], index=["A3", "B3", "D4"], name="series_name")
  644:     r = s.index.str.extract(r"([A-Z])", expand=True)
  645:     e = DataFrame(["A", "B", "D"])
  646:     tm.assert_frame_equal(r, e)
  647: 
  648:     # Prior to v0.18.0, index.str.extract(regex with one group)
  649:     # returned Index. With more than one group, extract raised an
  650:     # error (GH9980). Now extract always returns DataFrame.
  651:     r = s.index.str.extract(r"(?P<letter>[A-Z])(?P<digit>[0-9])", expand=True)
  652:     e_list = [("A", "3"), ("B", "3"), ("D", "4")]
  653:     e = DataFrame(e_list, columns=["letter", "digit"])
  654:     tm.assert_frame_equal(r, e)
  655: 
  656: 
  657: def test_extractall_same_as_extract(any_string_dtype):
  658:     s = Series(["a3", "b3", "c2"], name="series_name", dtype=any_string_dtype)
  659: 
  660:     pattern_two_noname = r"([a-z])([0-9])"
  661:     extract_two_noname = s.str.extract(pattern_two_noname, expand=True)
  662:     has_multi_index = s.str.extractall(pattern_two_noname)
  663:     no_multi_index = has_multi_index.xs(0, level="match")
  664:     tm.assert_frame_equal(extract_two_noname, no_multi_index)
  665: 
  666:     pattern_two_named = r"(?P<letter>[a-z])(?P<digit>[0-9])"
  667:     extract_two_named = s.str.extract(pattern_two_named, expand=True)
  668:     has_multi_index = s.str.extractall(pattern_two_named)
  669:     no_multi_index = has_multi_index.xs(0, level="match")
  670:     tm.assert_frame_equal(extract_two_named, no_multi_index)
  671: 
  672:     pattern_one_named = r"(?P<group_name>[a-z])"
  673:     extract_one_named = s.str.extract(pattern_one_named, expand=True)
  674:     has_multi_index = s.str.extractall(pattern_one_named)
  675:     no_multi_index = has_multi_index.xs(0, level="match")
  676:     tm.assert_frame_equal(extract_one_named, no_multi_index)
  677: 
  678:     pattern_one_noname = r"([a-z])"
  679:     extract_one_noname = s.str.extract(pattern_one_noname, expand=True)
  680:     has_multi_index = s.str.extractall(pattern_one_noname)
  681:     no_multi_index = has_multi_index.xs(0, level="match")
  682:     tm.assert_frame_equal(extract_one_noname, no_multi_index)
  683: 
  684: 
  685: def test_extractall_same_as_extract_subject_index(any_string_dtype):
  686:     # same as above tests, but s has an MultiIndex.
  687:     mi = MultiIndex.from_tuples(
  688:         [("A", "first"), ("B", "second"), ("C", "third")],
  689:         names=("capital", "ordinal"),
  690:     )
  691:     s = Series(["a3", "b3", "c2"], index=mi, name="series_name", dtype=any_string_dtype)
  692: 
  693:     pattern_two_noname = r"([a-z])([0-9])"
  694:     extract_two_noname = s.str.extract(pattern_two_noname, expand=True)
  695:     has_match_index = s.str.extractall(pattern_two_noname)
  696:     no_match_index = has_match_index.xs(0, level="match")
  697:     tm.assert_frame_equal(extract_two_noname, no_match_index)
  698: 
  699:     pattern_two_named = r"(?P<letter>[a-z])(?P<digit>[0-9])"
  700:     extract_two_named = s.str.extract(pattern_two_named, expand=True)
  701:     has_match_index = s.str.extractall(pattern_two_named)
  702:     no_match_index = has_match_index.xs(0, level="match")
  703:     tm.assert_frame_equal(extract_two_named, no_match_index)
  704: 
  705:     pattern_one_named = r"(?P<group_name>[a-z])"
  706:     extract_one_named = s.str.extract(pattern_one_named, expand=True)
  707:     has_match_index = s.str.extractall(pattern_one_named)
  708:     no_match_index = has_match_index.xs(0, level="match")
  709:     tm.assert_frame_equal(extract_one_named, no_match_index)
  710: 
  711:     pattern_one_noname = r"([a-z])"
  712:     extract_one_noname = s.str.extract(pattern_one_noname, expand=True)
  713:     has_match_index = s.str.extractall(pattern_one_noname)
  714:     no_match_index = has_match_index.xs(0, level="match")
  715:     tm.assert_frame_equal(extract_one_noname, no_match_index)
  716: 
  717: 
  718: def test_extractall_preserves_dtype():
  719:     # Ensure that when extractall is called on a series with specific dtypes set, that
  720:     # the dtype is preserved in the resulting DataFrame's column.
  721:     pa = pytest.importorskip("pyarrow")
  722: 
  723:     result = Series(["abc", "ab"], dtype=ArrowDtype(pa.string())).str.extractall("(ab)")
  724:     assert result.dtypes[0] == "string[pyarrow]"
