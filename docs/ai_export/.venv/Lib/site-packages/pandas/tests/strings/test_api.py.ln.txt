    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas import (
    5:     CategoricalDtype,
    6:     DataFrame,
    7:     Index,
    8:     MultiIndex,
    9:     Series,
   10:     _testing as tm,
   11:     option_context,
   12: )
   13: from pandas.core.strings.accessor import StringMethods
   14: 
   15: # subset of the full set from pandas/conftest.py
   16: _any_allowed_skipna_inferred_dtype = [
   17:     ("string", ["a", np.nan, "c"]),
   18:     ("bytes", [b"a", np.nan, b"c"]),
   19:     ("empty", [np.nan, np.nan, np.nan]),
   20:     ("empty", []),
   21:     ("mixed-integer", ["a", np.nan, 2]),
   22: ]
   23: ids, _ = zip(*_any_allowed_skipna_inferred_dtype)  # use inferred type as id
   24: 
   25: 
   26: @pytest.fixture(params=_any_allowed_skipna_inferred_dtype, ids=ids)
   27: def any_allowed_skipna_inferred_dtype(request):
   28:     """
   29:     Fixture for all (inferred) dtypes allowed in StringMethods.__init__
   30: 
   31:     The covered (inferred) types are:
   32:     * 'string'
   33:     * 'empty'
   34:     * 'bytes'
   35:     * 'mixed'
   36:     * 'mixed-integer'
   37: 
   38:     Returns
   39:     -------
   40:     inferred_dtype : str
   41:         The string for the inferred dtype from _libs.lib.infer_dtype
   42:     values : np.ndarray
   43:         An array of object dtype that will be inferred to have
   44:         `inferred_dtype`
   45: 
   46:     Examples
   47:     --------
   48:     >>> from pandas._libs import lib
   49:     >>>
   50:     >>> def test_something(any_allowed_skipna_inferred_dtype):
   51:     ...     inferred_dtype, values = any_allowed_skipna_inferred_dtype
   52:     ...     # will pass
   53:     ...     assert lib.infer_dtype(values, skipna=True) == inferred_dtype
   54:     ...
   55:     ...     # constructor for .str-accessor will also pass
   56:     ...     Series(values).str
   57:     """
   58:     inferred_dtype, values = request.param
   59:     values = np.array(values, dtype=object)  # object dtype to avoid casting
   60: 
   61:     # correctness of inference tested in tests/dtypes/test_inference.py
   62:     return inferred_dtype, values
   63: 
   64: 
   65: def test_api(any_string_dtype):
   66:     # GH 6106, GH 9322
   67:     assert Series.str is StringMethods
   68:     assert isinstance(Series([""], dtype=any_string_dtype).str, StringMethods)
   69: 
   70: 
   71: def test_api_mi_raises():
   72:     # GH 23679
   73:     mi = MultiIndex.from_arrays([["a", "b", "c"]])
   74:     msg = "Can only use .str accessor with Index, not MultiIndex"
   75:     with pytest.raises(AttributeError, match=msg):
   76:         mi.str
   77:     assert not hasattr(mi, "str")
   78: 
   79: 
   80: @pytest.mark.parametrize("dtype", [object, "category"])
   81: def test_api_per_dtype(index_or_series, dtype, any_skipna_inferred_dtype):
   82:     # one instance of parametrized fixture
   83:     box = index_or_series
   84:     inferred_dtype, values = any_skipna_inferred_dtype
   85: 
   86:     t = box(values, dtype=dtype)  # explicit dtype to avoid casting
   87: 
   88:     types_passing_constructor = [
   89:         "string",
   90:         "unicode",
   91:         "empty",
   92:         "bytes",
   93:         "mixed",
   94:         "mixed-integer",
   95:     ]
   96:     if inferred_dtype in types_passing_constructor:
   97:         # GH 6106
   98:         assert isinstance(t.str, StringMethods)
   99:     else:
  100:         # GH 9184, GH 23011, GH 23163
  101:         msg = "Can only use .str accessor with string values.*"
  102:         with pytest.raises(AttributeError, match=msg):
  103:             t.str
  104:         assert not hasattr(t, "str")
  105: 
  106: 
  107: @pytest.mark.parametrize("dtype", [object, "category"])
  108: def test_api_per_method(
  109:     index_or_series,
  110:     dtype,
  111:     any_allowed_skipna_inferred_dtype,
  112:     any_string_method,
  113:     request,
  114: ):
  115:     # this test does not check correctness of the different methods,
  116:     # just that the methods work on the specified (inferred) dtypes,
  117:     # and raise on all others
  118:     box = index_or_series
  119: 
  120:     # one instance of each parametrized fixture
  121:     inferred_dtype, values = any_allowed_skipna_inferred_dtype
  122:     method_name, args, kwargs = any_string_method
  123: 
  124:     reason = None
  125:     if box is Index and values.size == 0:
  126:         if method_name in ["partition", "rpartition"] and kwargs.get("expand", True):
  127:             raises = TypeError
  128:             reason = "Method cannot deal with empty Index"
  129:         elif method_name == "split" and kwargs.get("expand", None):
  130:             raises = TypeError
  131:             reason = "Split fails on empty Series when expand=True"
  132:         elif method_name == "get_dummies":
  133:             raises = ValueError
  134:             reason = "Need to fortify get_dummies corner cases"
  135: 
  136:     elif (
  137:         box is Index
  138:         and inferred_dtype == "empty"
  139:         and dtype == object
  140:         and method_name == "get_dummies"
  141:     ):
  142:         raises = ValueError
  143:         reason = "Need to fortify get_dummies corner cases"
  144: 
  145:     if reason is not None:
  146:         mark = pytest.mark.xfail(raises=raises, reason=reason)
  147:         request.applymarker(mark)
  148: 
  149:     t = box(values, dtype=dtype)  # explicit dtype to avoid casting
  150:     method = getattr(t.str, method_name)
  151: 
  152:     bytes_allowed = method_name in ["decode", "get", "len", "slice"]
  153:     # as of v0.23.4, all methods except 'cat' are very lenient with the
  154:     # allowed data types, just returning NaN for entries that error.
  155:     # This could be changed with an 'errors'-kwarg to the `str`-accessor,
  156:     # see discussion in GH 13877
  157:     mixed_allowed = method_name not in ["cat"]
  158: 
  159:     allowed_types = (
  160:         ["string", "unicode", "empty"]
  161:         + ["bytes"] * bytes_allowed
  162:         + ["mixed", "mixed-integer"] * mixed_allowed
  163:     )
  164: 
  165:     if inferred_dtype in allowed_types:
  166:         # xref GH 23555, GH 23556
  167:         with option_context("future.no_silent_downcasting", True):
  168:             method(*args, **kwargs)  # works!
  169:     else:
  170:         # GH 23011, GH 23163
  171:         msg = (
  172:             f"Cannot use .str.{method_name} with values of "
  173:             f"inferred dtype {repr(inferred_dtype)}."
  174:         )
  175:         with pytest.raises(TypeError, match=msg):
  176:             method(*args, **kwargs)
  177: 
  178: 
  179: def test_api_for_categorical(any_string_method, any_string_dtype):
  180:     # https://github.com/pandas-dev/pandas/issues/10661
  181:     s = Series(list("aabb"), dtype=any_string_dtype)
  182:     s = s + " " + s
  183:     c = s.astype("category")
  184:     c = c.astype(CategoricalDtype(c.dtype.categories.astype("object")))
  185:     assert isinstance(c.str, StringMethods)
  186: 
  187:     method_name, args, kwargs = any_string_method
  188: 
  189:     result = getattr(c.str, method_name)(*args, **kwargs)
  190:     expected = getattr(s.astype("object").str, method_name)(*args, **kwargs)
  191: 
  192:     if isinstance(result, DataFrame):
  193:         tm.assert_frame_equal(result, expected)
  194:     elif isinstance(result, Series):
  195:         tm.assert_series_equal(result, expected)
  196:     else:
  197:         # str.cat(others=None) returns string, for example
  198:         assert result == expected
