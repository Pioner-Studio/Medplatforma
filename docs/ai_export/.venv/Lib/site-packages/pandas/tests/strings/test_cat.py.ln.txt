    1: import re
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: import pandas.util._test_decorators as td
    7: 
    8: from pandas import (
    9:     DataFrame,
   10:     Index,
   11:     MultiIndex,
   12:     Series,
   13:     _testing as tm,
   14:     concat,
   15:     option_context,
   16: )
   17: 
   18: 
   19: @pytest.mark.parametrize("other", [None, Series, Index])
   20: def test_str_cat_name(index_or_series, other):
   21:     # GH 21053
   22:     box = index_or_series
   23:     values = ["a", "b"]
   24:     if other:
   25:         other = other(values)
   26:     else:
   27:         other = values
   28:     result = box(values, name="name").str.cat(other, sep=",")
   29:     assert result.name == "name"
   30: 
   31: 
   32: @pytest.mark.parametrize(
   33:     "infer_string", [False, pytest.param(True, marks=td.skip_if_no("pyarrow"))]
   34: )
   35: def test_str_cat(index_or_series, infer_string):
   36:     with option_context("future.infer_string", infer_string):
   37:         box = index_or_series
   38:         # test_cat above tests "str_cat" from ndarray;
   39:         # here testing "str.cat" from Series/Index to ndarray/list
   40:         s = box(["a", "a", "b", "b", "c", np.nan])
   41: 
   42:         # single array
   43:         result = s.str.cat()
   44:         expected = "aabbc"
   45:         assert result == expected
   46: 
   47:         result = s.str.cat(na_rep="-")
   48:         expected = "aabbc-"
   49:         assert result == expected
   50: 
   51:         result = s.str.cat(sep="_", na_rep="NA")
   52:         expected = "a_a_b_b_c_NA"
   53:         assert result == expected
   54: 
   55:         t = np.array(["a", np.nan, "b", "d", "foo", np.nan], dtype=object)
   56:         expected = box(["aa", "a-", "bb", "bd", "cfoo", "--"])
   57: 
   58:         # Series/Index with array
   59:         result = s.str.cat(t, na_rep="-")
   60:         tm.assert_equal(result, expected)
   61: 
   62:         # Series/Index with list
   63:         result = s.str.cat(list(t), na_rep="-")
   64:         tm.assert_equal(result, expected)
   65: 
   66:         # errors for incorrect lengths
   67:         rgx = r"If `others` contains arrays or lists \(or other list-likes.*"
   68:         z = Series(["1", "2", "3"])
   69: 
   70:         with pytest.raises(ValueError, match=rgx):
   71:             s.str.cat(z.values)
   72: 
   73:         with pytest.raises(ValueError, match=rgx):
   74:             s.str.cat(list(z))
   75: 
   76: 
   77: def test_str_cat_raises_intuitive_error(index_or_series):
   78:     # GH 11334
   79:     box = index_or_series
   80:     s = box(["a", "b", "c", "d"])
   81:     message = "Did you mean to supply a `sep` keyword?"
   82:     with pytest.raises(ValueError, match=message):
   83:         s.str.cat("|")
   84:     with pytest.raises(ValueError, match=message):
   85:         s.str.cat("    ")
   86: 
   87: 
   88: @pytest.mark.parametrize(
   89:     "infer_string", [False, pytest.param(True, marks=td.skip_if_no("pyarrow"))]
   90: )
   91: @pytest.mark.parametrize("sep", ["", None])
   92: @pytest.mark.parametrize("dtype_target", ["object", "category"])
   93: @pytest.mark.parametrize("dtype_caller", ["object", "category"])
   94: def test_str_cat_categorical(
   95:     index_or_series, dtype_caller, dtype_target, sep, infer_string
   96: ):
   97:     box = index_or_series
   98: 
   99:     with option_context("future.infer_string", infer_string):
  100:         s = Index(["a", "a", "b", "a"], dtype=dtype_caller)
  101:         s = s if box == Index else Series(s, index=s, dtype=s.dtype)
  102:         t = Index(["b", "a", "b", "c"], dtype=dtype_target)
  103: 
  104:         expected = Index(
  105:             ["ab", "aa", "bb", "ac"], dtype=object if dtype_caller == "object" else None
  106:         )
  107:         expected = (
  108:             expected
  109:             if box == Index
  110:             else Series(
  111:                 expected, index=Index(s, dtype=dtype_caller), dtype=expected.dtype
  112:             )
  113:         )
  114: 
  115:         # Series/Index with unaligned Index -> t.values
  116:         result = s.str.cat(t.values, sep=sep)
  117:         tm.assert_equal(result, expected)
  118: 
  119:         # Series/Index with Series having matching Index
  120:         t = Series(t.values, index=Index(s, dtype=dtype_caller))
  121:         result = s.str.cat(t, sep=sep)
  122:         tm.assert_equal(result, expected)
  123: 
  124:         # Series/Index with Series.values
  125:         result = s.str.cat(t.values, sep=sep)
  126:         tm.assert_equal(result, expected)
  127: 
  128:         # Series/Index with Series having different Index
  129:         t = Series(t.values, index=t.values)
  130:         expected = Index(
  131:             ["aa", "aa", "bb", "bb", "aa"],
  132:             dtype=object if dtype_caller == "object" else None,
  133:         )
  134:         dtype = object if dtype_caller == "object" else s.dtype.categories.dtype
  135:         expected = (
  136:             expected
  137:             if box == Index
  138:             else Series(
  139:                 expected,
  140:                 index=Index(expected.str[:1], dtype=dtype),
  141:                 dtype=expected.dtype,
  142:             )
  143:         )
  144: 
  145:         result = s.str.cat(t, sep=sep)
  146:         tm.assert_equal(result, expected)
  147: 
  148: 
  149: @pytest.mark.parametrize(
  150:     "data",
  151:     [[1, 2, 3], [0.1, 0.2, 0.3], [1, 2, "b"]],
  152:     ids=["integers", "floats", "mixed"],
  153: )
  154: # without dtype=object, np.array would cast [1, 2, 'b'] to ['1', '2', 'b']
  155: @pytest.mark.parametrize(
  156:     "box",
  157:     [Series, Index, list, lambda x: np.array(x, dtype=object)],
  158:     ids=["Series", "Index", "list", "np.array"],
  159: )
  160: def test_str_cat_wrong_dtype_raises(box, data):
  161:     # GH 22722
  162:     s = Series(["a", "b", "c"])
  163:     t = box(data)
  164: 
  165:     msg = "Concatenation requires list-likes containing only strings.*"
  166:     with pytest.raises(TypeError, match=msg):
  167:         # need to use outer and na_rep, as otherwise Index would not raise
  168:         s.str.cat(t, join="outer", na_rep="-")
  169: 
  170: 
  171: def test_str_cat_mixed_inputs(index_or_series):
  172:     box = index_or_series
  173:     s = Index(["a", "b", "c", "d"])
  174:     s = s if box == Index else Series(s, index=s)
  175: 
  176:     t = Series(["A", "B", "C", "D"], index=s.values)
  177:     d = concat([t, Series(s, index=s)], axis=1)
  178: 
  179:     expected = Index(["aAa", "bBb", "cCc", "dDd"])
  180:     expected = expected if box == Index else Series(expected.values, index=s.values)
  181: 
  182:     # Series/Index with DataFrame
  183:     result = s.str.cat(d)
  184:     tm.assert_equal(result, expected)
  185: 
  186:     # Series/Index with two-dimensional ndarray
  187:     result = s.str.cat(d.values)
  188:     tm.assert_equal(result, expected)
  189: 
  190:     # Series/Index with list of Series
  191:     result = s.str.cat([t, s])
  192:     tm.assert_equal(result, expected)
  193: 
  194:     # Series/Index with mixed list of Series/array
  195:     result = s.str.cat([t, s.values])
  196:     tm.assert_equal(result, expected)
  197: 
  198:     # Series/Index with list of Series; different indexes
  199:     t.index = ["b", "c", "d", "a"]
  200:     expected = box(["aDa", "bAb", "cBc", "dCd"])
  201:     expected = expected if box == Index else Series(expected.values, index=s.values)
  202:     result = s.str.cat([t, s])
  203:     tm.assert_equal(result, expected)
  204: 
  205:     # Series/Index with mixed list; different index
  206:     result = s.str.cat([t, s.values])
  207:     tm.assert_equal(result, expected)
  208: 
  209:     # Series/Index with DataFrame; different indexes
  210:     d.index = ["b", "c", "d", "a"]
  211:     expected = box(["aDd", "bAa", "cBb", "dCc"])
  212:     expected = expected if box == Index else Series(expected.values, index=s.values)
  213:     result = s.str.cat(d)
  214:     tm.assert_equal(result, expected)
  215: 
  216:     # errors for incorrect lengths
  217:     rgx = r"If `others` contains arrays or lists \(or other list-likes.*"
  218:     z = Series(["1", "2", "3"])
  219:     e = concat([z, z], axis=1)
  220: 
  221:     # two-dimensional ndarray
  222:     with pytest.raises(ValueError, match=rgx):
  223:         s.str.cat(e.values)
  224: 
  225:     # list of list-likes
  226:     with pytest.raises(ValueError, match=rgx):
  227:         s.str.cat([z.values, s.values])
  228: 
  229:     # mixed list of Series/list-like
  230:     with pytest.raises(ValueError, match=rgx):
  231:         s.str.cat([z.values, s])
  232: 
  233:     # errors for incorrect arguments in list-like
  234:     rgx = "others must be Series, Index, DataFrame,.*"
  235:     # make sure None/NaN do not crash checks in _get_series_list
  236:     u = Series(["a", np.nan, "c", None])
  237: 
  238:     # mix of string and Series
  239:     with pytest.raises(TypeError, match=rgx):
  240:         s.str.cat([u, "u"])
  241: 
  242:     # DataFrame in list
  243:     with pytest.raises(TypeError, match=rgx):
  244:         s.str.cat([u, d])
  245: 
  246:     # 2-dim ndarray in list
  247:     with pytest.raises(TypeError, match=rgx):
  248:         s.str.cat([u, d.values])
  249: 
  250:     # nested lists
  251:     with pytest.raises(TypeError, match=rgx):
  252:         s.str.cat([u, [u, d]])
  253: 
  254:     # forbidden input type: set
  255:     # GH 23009
  256:     with pytest.raises(TypeError, match=rgx):
  257:         s.str.cat(set(u))
  258: 
  259:     # forbidden input type: set in list
  260:     # GH 23009
  261:     with pytest.raises(TypeError, match=rgx):
  262:         s.str.cat([u, set(u)])
  263: 
  264:     # other forbidden input type, e.g. int
  265:     with pytest.raises(TypeError, match=rgx):
  266:         s.str.cat(1)
  267: 
  268:     # nested list-likes
  269:     with pytest.raises(TypeError, match=rgx):
  270:         s.str.cat(iter([t.values, list(s)]))
  271: 
  272: 
  273: @pytest.mark.parametrize("join", ["left", "outer", "inner", "right"])
  274: def test_str_cat_align_indexed(index_or_series, join):
  275:     # https://github.com/pandas-dev/pandas/issues/18657
  276:     box = index_or_series
  277: 
  278:     s = Series(["a", "b", "c", "d"], index=["a", "b", "c", "d"])
  279:     t = Series(["D", "A", "E", "B"], index=["d", "a", "e", "b"])
  280:     sa, ta = s.align(t, join=join)
  281:     # result after manual alignment of inputs
  282:     expected = sa.str.cat(ta, na_rep="-")
  283: 
  284:     if box == Index:
  285:         s = Index(s)
  286:         sa = Index(sa)
  287:         expected = Index(expected)
  288: 
  289:     result = s.str.cat(t, join=join, na_rep="-")
  290:     tm.assert_equal(result, expected)
  291: 
  292: 
  293: @pytest.mark.parametrize("join", ["left", "outer", "inner", "right"])
  294: def test_str_cat_align_mixed_inputs(join):
  295:     s = Series(["a", "b", "c", "d"])
  296:     t = Series(["d", "a", "e", "b"], index=[3, 0, 4, 1])
  297:     d = concat([t, t], axis=1)
  298: 
  299:     expected_outer = Series(["aaa", "bbb", "c--", "ddd", "-ee"])
  300:     expected = expected_outer.loc[s.index.join(t.index, how=join)]
  301: 
  302:     # list of Series
  303:     result = s.str.cat([t, t], join=join, na_rep="-")
  304:     tm.assert_series_equal(result, expected)
  305: 
  306:     # DataFrame
  307:     result = s.str.cat(d, join=join, na_rep="-")
  308:     tm.assert_series_equal(result, expected)
  309: 
  310:     # mixed list of indexed/unindexed
  311:     u = np.array(["A", "B", "C", "D"])
  312:     expected_outer = Series(["aaA", "bbB", "c-C", "ddD", "-e-"])
  313:     # joint index of rhs [t, u]; u will be forced have index of s
  314:     rhs_idx = (
  315:         t.index.intersection(s.index)
  316:         if join == "inner"
  317:         else t.index.union(s.index)
  318:         if join == "outer"
  319:         else t.index.append(s.index.difference(t.index))
  320:     )
  321: 
  322:     expected = expected_outer.loc[s.index.join(rhs_idx, how=join)]
  323:     result = s.str.cat([t, u], join=join, na_rep="-")
  324:     tm.assert_series_equal(result, expected)
  325: 
  326:     with pytest.raises(TypeError, match="others must be Series,.*"):
  327:         # nested lists are forbidden
  328:         s.str.cat([t, list(u)], join=join)
  329: 
  330:     # errors for incorrect lengths
  331:     rgx = r"If `others` contains arrays or lists \(or other list-likes.*"
  332:     z = Series(["1", "2", "3"]).values
  333: 
  334:     # unindexed object of wrong length
  335:     with pytest.raises(ValueError, match=rgx):
  336:         s.str.cat(z, join=join)
  337: 
  338:     # unindexed object of wrong length in list
  339:     with pytest.raises(ValueError, match=rgx):
  340:         s.str.cat([t, z], join=join)
  341: 
  342: 
  343: def test_str_cat_all_na(index_or_series, index_or_series2):
  344:     # GH 24044
  345:     box = index_or_series
  346:     other = index_or_series2
  347: 
  348:     # check that all NaNs in caller / target work
  349:     s = Index(["a", "b", "c", "d"])
  350:     s = s if box == Index else Series(s, index=s)
  351:     t = other([np.nan] * 4, dtype=object)
  352:     # add index of s for alignment
  353:     t = t if other == Index else Series(t, index=s)
  354: 
  355:     # all-NA target
  356:     if box == Series:
  357:         expected = Series([np.nan] * 4, index=s.index, dtype=s.dtype)
  358:     else:  # box == Index
  359:         # TODO: Strimg option, this should return string dtype
  360:         expected = Index([np.nan] * 4, dtype=object)
  361:     result = s.str.cat(t, join="left")
  362:     tm.assert_equal(result, expected)
  363: 
  364:     # all-NA caller (only for Series)
  365:     if other == Series:
  366:         expected = Series([np.nan] * 4, dtype=object, index=t.index)
  367:         result = t.str.cat(s, join="left")
  368:         tm.assert_series_equal(result, expected)
  369: 
  370: 
  371: def test_str_cat_special_cases():
  372:     s = Series(["a", "b", "c", "d"])
  373:     t = Series(["d", "a", "e", "b"], index=[3, 0, 4, 1])
  374: 
  375:     # iterator of elements with different types
  376:     expected = Series(["aaa", "bbb", "c-c", "ddd", "-e-"])
  377:     result = s.str.cat(iter([t, s.values]), join="outer", na_rep="-")
  378:     tm.assert_series_equal(result, expected)
  379: 
  380:     # right-align with different indexes in others
  381:     expected = Series(["aa-", "d-d"], index=[0, 3])
  382:     result = s.str.cat([t.loc[[0]], t.loc[[3]]], join="right", na_rep="-")
  383:     tm.assert_series_equal(result, expected)
  384: 
  385: 
  386: def test_cat_on_filtered_index():
  387:     df = DataFrame(
  388:         index=MultiIndex.from_product(
  389:             [[2011, 2012], [1, 2, 3]], names=["year", "month"]
  390:         )
  391:     )
  392: 
  393:     df = df.reset_index()
  394:     df = df[df.month > 1]
  395: 
  396:     str_year = df.year.astype("str")
  397:     str_month = df.month.astype("str")
  398:     str_both = str_year.str.cat(str_month, sep=" ")
  399: 
  400:     assert str_both.loc[1] == "2011 2"
  401: 
  402:     str_multiple = str_year.str.cat([str_month, str_month], sep=" ")
  403: 
  404:     assert str_multiple.loc[1] == "2011 2 2"
  405: 
  406: 
  407: @pytest.mark.parametrize("klass", [tuple, list, np.array, Series, Index])
  408: def test_cat_different_classes(klass):
  409:     # https://github.com/pandas-dev/pandas/issues/33425
  410:     s = Series(["a", "b", "c"])
  411:     result = s.str.cat(klass(["x", "y", "z"]))
  412:     expected = Series(["ax", "by", "cz"])
  413:     tm.assert_series_equal(result, expected)
  414: 
  415: 
  416: def test_cat_on_series_dot_str():
  417:     # GH 28277
  418:     ps = Series(["AbC", "de", "FGHI", "j", "kLLLm"])
  419: 
  420:     message = re.escape(
  421:         "others must be Series, Index, DataFrame, np.ndarray "
  422:         "or list-like (either containing only strings or "
  423:         "containing only objects of type Series/Index/"
  424:         "np.ndarray[1-dim])"
  425:     )
  426:     with pytest.raises(TypeError, match=message):
  427:         ps.str.cat(others=ps.str)
