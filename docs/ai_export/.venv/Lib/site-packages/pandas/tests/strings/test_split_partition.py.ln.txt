    1: from datetime import datetime
    2: import re
    3: 
    4: import numpy as np
    5: import pytest
    6: 
    7: import pandas as pd
    8: from pandas import (
    9:     DataFrame,
   10:     Index,
   11:     MultiIndex,
   12:     Series,
   13:     _testing as tm,
   14: )
   15: from pandas.tests.strings import (
   16:     _convert_na_value,
   17:     object_pyarrow_numpy,
   18: )
   19: 
   20: 
   21: @pytest.mark.parametrize("method", ["split", "rsplit"])
   22: def test_split(any_string_dtype, method):
   23:     values = Series(["a_b_c", "c_d_e", np.nan, "f_g_h"], dtype=any_string_dtype)
   24: 
   25:     result = getattr(values.str, method)("_")
   26:     exp = Series([["a", "b", "c"], ["c", "d", "e"], np.nan, ["f", "g", "h"]])
   27:     exp = _convert_na_value(values, exp)
   28:     tm.assert_series_equal(result, exp)
   29: 
   30: 
   31: @pytest.mark.parametrize("method", ["split", "rsplit"])
   32: def test_split_more_than_one_char(any_string_dtype, method):
   33:     # more than one char
   34:     values = Series(["a__b__c", "c__d__e", np.nan, "f__g__h"], dtype=any_string_dtype)
   35:     result = getattr(values.str, method)("__")
   36:     exp = Series([["a", "b", "c"], ["c", "d", "e"], np.nan, ["f", "g", "h"]])
   37:     exp = _convert_na_value(values, exp)
   38:     tm.assert_series_equal(result, exp)
   39: 
   40:     result = getattr(values.str, method)("__", expand=False)
   41:     tm.assert_series_equal(result, exp)
   42: 
   43: 
   44: def test_split_more_regex_split(any_string_dtype):
   45:     # regex split
   46:     values = Series(["a,b_c", "c_d,e", np.nan, "f,g,h"], dtype=any_string_dtype)
   47:     result = values.str.split("[,_]")
   48:     exp = Series([["a", "b", "c"], ["c", "d", "e"], np.nan, ["f", "g", "h"]])
   49:     exp = _convert_na_value(values, exp)
   50:     tm.assert_series_equal(result, exp)
   51: 
   52: 
   53: def test_split_regex(any_string_dtype):
   54:     # GH 43563
   55:     # explicit regex = True split
   56:     values = Series("xxxjpgzzz.jpg", dtype=any_string_dtype)
   57:     result = values.str.split(r"\.jpg", regex=True)
   58:     exp = Series([["xxxjpgzzz", ""]])
   59:     tm.assert_series_equal(result, exp)
   60: 
   61: 
   62: def test_split_regex_explicit(any_string_dtype):
   63:     # explicit regex = True split with compiled regex
   64:     regex_pat = re.compile(r".jpg")
   65:     values = Series("xxxjpgzzz.jpg", dtype=any_string_dtype)
   66:     result = values.str.split(regex_pat)
   67:     exp = Series([["xx", "zzz", ""]])
   68:     tm.assert_series_equal(result, exp)
   69: 
   70:     # explicit regex = False split
   71:     result = values.str.split(r"\.jpg", regex=False)
   72:     exp = Series([["xxxjpgzzz.jpg"]])
   73:     tm.assert_series_equal(result, exp)
   74: 
   75:     # non explicit regex split, pattern length == 1
   76:     result = values.str.split(r".")
   77:     exp = Series([["xxxjpgzzz", "jpg"]])
   78:     tm.assert_series_equal(result, exp)
   79: 
   80:     # non explicit regex split, pattern length != 1
   81:     result = values.str.split(r".jpg")
   82:     exp = Series([["xx", "zzz", ""]])
   83:     tm.assert_series_equal(result, exp)
   84: 
   85:     # regex=False with pattern compiled regex raises error
   86:     with pytest.raises(
   87:         ValueError,
   88:         match="Cannot use a compiled regex as replacement pattern with regex=False",
   89:     ):
   90:         values.str.split(regex_pat, regex=False)
   91: 
   92: 
   93: @pytest.mark.parametrize("expand", [None, False])
   94: @pytest.mark.parametrize("method", ["split", "rsplit"])
   95: def test_split_object_mixed(expand, method):
   96:     mixed = Series(["a_b_c", np.nan, "d_e_f", True, datetime.today(), None, 1, 2.0])
   97:     result = getattr(mixed.str, method)("_", expand=expand)
   98:     exp = Series(
   99:         [
  100:             ["a", "b", "c"],
  101:             np.nan,
  102:             ["d", "e", "f"],
  103:             np.nan,
  104:             np.nan,
  105:             None,
  106:             np.nan,
  107:             np.nan,
  108:         ]
  109:     )
  110:     assert isinstance(result, Series)
  111:     tm.assert_almost_equal(result, exp)
  112: 
  113: 
  114: @pytest.mark.parametrize("method", ["split", "rsplit"])
  115: @pytest.mark.parametrize("n", [None, 0])
  116: def test_split_n(any_string_dtype, method, n):
  117:     s = Series(["a b", pd.NA, "b c"], dtype=any_string_dtype)
  118:     expected = Series([["a", "b"], pd.NA, ["b", "c"]])
  119:     result = getattr(s.str, method)(" ", n=n)
  120:     expected = _convert_na_value(s, expected)
  121:     tm.assert_series_equal(result, expected)
  122: 
  123: 
  124: def test_rsplit(any_string_dtype):
  125:     # regex split is not supported by rsplit
  126:     values = Series(["a,b_c", "c_d,e", np.nan, "f,g,h"], dtype=any_string_dtype)
  127:     result = values.str.rsplit("[,_]")
  128:     exp = Series([["a,b_c"], ["c_d,e"], np.nan, ["f,g,h"]])
  129:     exp = _convert_na_value(values, exp)
  130:     tm.assert_series_equal(result, exp)
  131: 
  132: 
  133: def test_rsplit_max_number(any_string_dtype):
  134:     # setting max number of splits, make sure it's from reverse
  135:     values = Series(["a_b_c", "c_d_e", np.nan, "f_g_h"], dtype=any_string_dtype)
  136:     result = values.str.rsplit("_", n=1)
  137:     exp = Series([["a_b", "c"], ["c_d", "e"], np.nan, ["f_g", "h"]])
  138:     exp = _convert_na_value(values, exp)
  139:     tm.assert_series_equal(result, exp)
  140: 
  141: 
  142: def test_split_blank_string(any_string_dtype):
  143:     # expand blank split GH 20067
  144:     values = Series([""], name="test", dtype=any_string_dtype)
  145:     result = values.str.split(expand=True)
  146:     exp = DataFrame([[]], dtype=any_string_dtype)  # NOTE: this is NOT an empty df
  147:     tm.assert_frame_equal(result, exp)
  148: 
  149: 
  150: def test_split_blank_string_with_non_empty(any_string_dtype):
  151:     values = Series(["a b c", "a b", "", " "], name="test", dtype=any_string_dtype)
  152:     result = values.str.split(expand=True)
  153:     exp = DataFrame(
  154:         [
  155:             ["a", "b", "c"],
  156:             ["a", "b", None],
  157:             [None, None, None],
  158:             [None, None, None],
  159:         ],
  160:         dtype=any_string_dtype,
  161:     )
  162:     tm.assert_frame_equal(result, exp)
  163: 
  164: 
  165: @pytest.mark.parametrize("method", ["split", "rsplit"])
  166: def test_split_noargs(any_string_dtype, method):
  167:     # #1859
  168:     s = Series(["Wes McKinney", "Travis  Oliphant"], dtype=any_string_dtype)
  169:     result = getattr(s.str, method)()
  170:     expected = ["Travis", "Oliphant"]
  171:     assert result[1] == expected
  172: 
  173: 
  174: @pytest.mark.parametrize(
  175:     "data, pat",
  176:     [
  177:         (["bd asdf jfg", "kjasdflqw asdfnfk"], None),
  178:         (["bd asdf jfg", "kjasdflqw asdfnfk"], "asdf"),
  179:         (["bd_asdf_jfg", "kjasdflqw_asdfnfk"], "_"),
  180:     ],
  181: )
  182: @pytest.mark.parametrize("n", [-1, 0])
  183: def test_split_maxsplit(data, pat, any_string_dtype, n):
  184:     # re.split 0, str.split -1
  185:     s = Series(data, dtype=any_string_dtype)
  186: 
  187:     result = s.str.split(pat=pat, n=n)
  188:     xp = s.str.split(pat=pat)
  189:     tm.assert_series_equal(result, xp)
  190: 
  191: 
  192: @pytest.mark.parametrize(
  193:     "data, pat, expected",
  194:     [
  195:         (
  196:             ["split once", "split once too!"],
  197:             None,
  198:             Series({0: ["split", "once"], 1: ["split", "once too!"]}),
  199:         ),
  200:         (
  201:             ["split_once", "split_once_too!"],
  202:             "_",
  203:             Series({0: ["split", "once"], 1: ["split", "once_too!"]}),
  204:         ),
  205:     ],
  206: )
  207: def test_split_no_pat_with_nonzero_n(data, pat, expected, any_string_dtype):
  208:     s = Series(data, dtype=any_string_dtype)
  209:     result = s.str.split(pat=pat, n=1)
  210:     tm.assert_series_equal(expected, result, check_index_type=False)
  211: 
  212: 
  213: def test_split_to_dataframe_no_splits(any_string_dtype):
  214:     s = Series(["nosplit", "alsonosplit"], dtype=any_string_dtype)
  215:     result = s.str.split("_", expand=True)
  216:     exp = DataFrame({0: Series(["nosplit", "alsonosplit"], dtype=any_string_dtype)})
  217:     tm.assert_frame_equal(result, exp)
  218: 
  219: 
  220: def test_split_to_dataframe(any_string_dtype):
  221:     s = Series(["some_equal_splits", "with_no_nans"], dtype=any_string_dtype)
  222:     result = s.str.split("_", expand=True)
  223:     exp = DataFrame(
  224:         {0: ["some", "with"], 1: ["equal", "no"], 2: ["splits", "nans"]},
  225:         dtype=any_string_dtype,
  226:     )
  227:     tm.assert_frame_equal(result, exp)
  228: 
  229: 
  230: def test_split_to_dataframe_unequal_splits(any_string_dtype):
  231:     s = Series(
  232:         ["some_unequal_splits", "one_of_these_things_is_not"], dtype=any_string_dtype
  233:     )
  234:     result = s.str.split("_", expand=True)
  235:     exp = DataFrame(
  236:         {
  237:             0: ["some", "one"],
  238:             1: ["unequal", "of"],
  239:             2: ["splits", "these"],
  240:             3: [None, "things"],
  241:             4: [None, "is"],
  242:             5: [None, "not"],
  243:         },
  244:         dtype=any_string_dtype,
  245:     )
  246:     tm.assert_frame_equal(result, exp)
  247: 
  248: 
  249: def test_split_to_dataframe_with_index(any_string_dtype):
  250:     s = Series(
  251:         ["some_splits", "with_index"], index=["preserve", "me"], dtype=any_string_dtype
  252:     )
  253:     result = s.str.split("_", expand=True)
  254:     exp = DataFrame(
  255:         {0: ["some", "with"], 1: ["splits", "index"]},
  256:         index=["preserve", "me"],
  257:         dtype=any_string_dtype,
  258:     )
  259:     tm.assert_frame_equal(result, exp)
  260: 
  261:     with pytest.raises(ValueError, match="expand must be"):
  262:         s.str.split("_", expand="not_a_boolean")
  263: 
  264: 
  265: def test_split_to_multiindex_expand_no_splits():
  266:     # https://github.com/pandas-dev/pandas/issues/23677
  267: 
  268:     idx = Index(["nosplit", "alsonosplit", np.nan])
  269:     result = idx.str.split("_", expand=True)
  270:     exp = idx
  271:     tm.assert_index_equal(result, exp)
  272:     assert result.nlevels == 1
  273: 
  274: 
  275: def test_split_to_multiindex_expand():
  276:     idx = Index(["some_equal_splits", "with_no_nans", np.nan, None])
  277:     result = idx.str.split("_", expand=True)
  278:     exp = MultiIndex.from_tuples(
  279:         [
  280:             ("some", "equal", "splits"),
  281:             ("with", "no", "nans"),
  282:             [np.nan, np.nan, np.nan],
  283:             [None, None, None],
  284:         ]
  285:     )
  286:     tm.assert_index_equal(result, exp)
  287:     assert result.nlevels == 3
  288: 
  289: 
  290: def test_split_to_multiindex_expand_unequal_splits():
  291:     idx = Index(["some_unequal_splits", "one_of_these_things_is_not", np.nan, None])
  292:     result = idx.str.split("_", expand=True)
  293:     exp = MultiIndex.from_tuples(
  294:         [
  295:             ("some", "unequal", "splits", np.nan, np.nan, np.nan),
  296:             ("one", "of", "these", "things", "is", "not"),
  297:             (np.nan, np.nan, np.nan, np.nan, np.nan, np.nan),
  298:             (None, None, None, None, None, None),
  299:         ]
  300:     )
  301:     tm.assert_index_equal(result, exp)
  302:     assert result.nlevels == 6
  303: 
  304:     with pytest.raises(ValueError, match="expand must be"):
  305:         idx.str.split("_", expand="not_a_boolean")
  306: 
  307: 
  308: def test_rsplit_to_dataframe_expand_no_splits(any_string_dtype):
  309:     s = Series(["nosplit", "alsonosplit"], dtype=any_string_dtype)
  310:     result = s.str.rsplit("_", expand=True)
  311:     exp = DataFrame({0: Series(["nosplit", "alsonosplit"])}, dtype=any_string_dtype)
  312:     tm.assert_frame_equal(result, exp)
  313: 
  314: 
  315: def test_rsplit_to_dataframe_expand(any_string_dtype):
  316:     s = Series(["some_equal_splits", "with_no_nans"], dtype=any_string_dtype)
  317:     result = s.str.rsplit("_", expand=True)
  318:     exp = DataFrame(
  319:         {0: ["some", "with"], 1: ["equal", "no"], 2: ["splits", "nans"]},
  320:         dtype=any_string_dtype,
  321:     )
  322:     tm.assert_frame_equal(result, exp)
  323: 
  324:     result = s.str.rsplit("_", expand=True, n=2)
  325:     exp = DataFrame(
  326:         {0: ["some", "with"], 1: ["equal", "no"], 2: ["splits", "nans"]},
  327:         dtype=any_string_dtype,
  328:     )
  329:     tm.assert_frame_equal(result, exp)
  330: 
  331:     result = s.str.rsplit("_", expand=True, n=1)
  332:     exp = DataFrame(
  333:         {0: ["some_equal", "with_no"], 1: ["splits", "nans"]}, dtype=any_string_dtype
  334:     )
  335:     tm.assert_frame_equal(result, exp)
  336: 
  337: 
  338: def test_rsplit_to_dataframe_expand_with_index(any_string_dtype):
  339:     s = Series(
  340:         ["some_splits", "with_index"], index=["preserve", "me"], dtype=any_string_dtype
  341:     )
  342:     result = s.str.rsplit("_", expand=True)
  343:     exp = DataFrame(
  344:         {0: ["some", "with"], 1: ["splits", "index"]},
  345:         index=["preserve", "me"],
  346:         dtype=any_string_dtype,
  347:     )
  348:     tm.assert_frame_equal(result, exp)
  349: 
  350: 
  351: def test_rsplit_to_multiindex_expand_no_split():
  352:     idx = Index(["nosplit", "alsonosplit"])
  353:     result = idx.str.rsplit("_", expand=True)
  354:     exp = idx
  355:     tm.assert_index_equal(result, exp)
  356:     assert result.nlevels == 1
  357: 
  358: 
  359: def test_rsplit_to_multiindex_expand():
  360:     idx = Index(["some_equal_splits", "with_no_nans"])
  361:     result = idx.str.rsplit("_", expand=True)
  362:     exp = MultiIndex.from_tuples([("some", "equal", "splits"), ("with", "no", "nans")])
  363:     tm.assert_index_equal(result, exp)
  364:     assert result.nlevels == 3
  365: 
  366: 
  367: def test_rsplit_to_multiindex_expand_n():
  368:     idx = Index(["some_equal_splits", "with_no_nans"])
  369:     result = idx.str.rsplit("_", expand=True, n=1)
  370:     exp = MultiIndex.from_tuples([("some_equal", "splits"), ("with_no", "nans")])
  371:     tm.assert_index_equal(result, exp)
  372:     assert result.nlevels == 2
  373: 
  374: 
  375: def test_split_nan_expand(any_string_dtype):
  376:     # gh-18450
  377:     s = Series(["foo,bar,baz", np.nan], dtype=any_string_dtype)
  378:     result = s.str.split(",", expand=True)
  379:     exp = DataFrame(
  380:         [["foo", "bar", "baz"], [np.nan, np.nan, np.nan]], dtype=any_string_dtype
  381:     )
  382:     tm.assert_frame_equal(result, exp)
  383: 
  384:     # check that these are actually np.nan/pd.NA and not None
  385:     # TODO see GH 18463
  386:     # tm.assert_frame_equal does not differentiate
  387:     if any_string_dtype in object_pyarrow_numpy:
  388:         assert all(np.isnan(x) for x in result.iloc[1])
  389:     else:
  390:         assert all(x is pd.NA for x in result.iloc[1])
  391: 
  392: 
  393: def test_split_with_name_series(any_string_dtype):
  394:     # GH 12617
  395: 
  396:     # should preserve name
  397:     s = Series(["a,b", "c,d"], name="xxx", dtype=any_string_dtype)
  398:     res = s.str.split(",")
  399:     exp = Series([["a", "b"], ["c", "d"]], name="xxx")
  400:     tm.assert_series_equal(res, exp)
  401: 
  402:     res = s.str.split(",", expand=True)
  403:     exp = DataFrame([["a", "b"], ["c", "d"]], dtype=any_string_dtype)
  404:     tm.assert_frame_equal(res, exp)
  405: 
  406: 
  407: def test_split_with_name_index():
  408:     # GH 12617
  409:     idx = Index(["a,b", "c,d"], name="xxx")
  410:     res = idx.str.split(",")
  411:     exp = Index([["a", "b"], ["c", "d"]], name="xxx")
  412:     assert res.nlevels == 1
  413:     tm.assert_index_equal(res, exp)
  414: 
  415:     res = idx.str.split(",", expand=True)
  416:     exp = MultiIndex.from_tuples([("a", "b"), ("c", "d")])
  417:     assert res.nlevels == 2
  418:     tm.assert_index_equal(res, exp)
  419: 
  420: 
  421: @pytest.mark.parametrize(
  422:     "method, exp",
  423:     [
  424:         [
  425:             "partition",
  426:             [
  427:                 ("a", "__", "b__c"),
  428:                 ("c", "__", "d__e"),
  429:                 np.nan,
  430:                 ("f", "__", "g__h"),
  431:                 None,
  432:             ],
  433:         ],
  434:         [
  435:             "rpartition",
  436:             [
  437:                 ("a__b", "__", "c"),
  438:                 ("c__d", "__", "e"),
  439:                 np.nan,
  440:                 ("f__g", "__", "h"),
  441:                 None,
  442:             ],
  443:         ],
  444:     ],
  445: )
  446: def test_partition_series_more_than_one_char(method, exp, any_string_dtype):
  447:     # https://github.com/pandas-dev/pandas/issues/23558
  448:     # more than one char
  449:     s = Series(["a__b__c", "c__d__e", np.nan, "f__g__h", None], dtype=any_string_dtype)
  450:     result = getattr(s.str, method)("__", expand=False)
  451:     expected = Series(exp)
  452:     expected = _convert_na_value(s, expected)
  453:     tm.assert_series_equal(result, expected)
  454: 
  455: 
  456: @pytest.mark.parametrize(
  457:     "method, exp",
  458:     [
  459:         [
  460:             "partition",
  461:             [("a", " ", "b c"), ("c", " ", "d e"), np.nan, ("f", " ", "g h"), None],
  462:         ],
  463:         [
  464:             "rpartition",
  465:             [("a b", " ", "c"), ("c d", " ", "e"), np.nan, ("f g", " ", "h"), None],
  466:         ],
  467:     ],
  468: )
  469: def test_partition_series_none(any_string_dtype, method, exp):
  470:     # https://github.com/pandas-dev/pandas/issues/23558
  471:     # None
  472:     s = Series(["a b c", "c d e", np.nan, "f g h", None], dtype=any_string_dtype)
  473:     result = getattr(s.str, method)(expand=False)
  474:     expected = Series(exp)
  475:     expected = _convert_na_value(s, expected)
  476:     tm.assert_series_equal(result, expected)
  477: 
  478: 
  479: @pytest.mark.parametrize(
  480:     "method, exp",
  481:     [
  482:         [
  483:             "partition",
  484:             [("abc", "", ""), ("cde", "", ""), np.nan, ("fgh", "", ""), None],
  485:         ],
  486:         [
  487:             "rpartition",
  488:             [("", "", "abc"), ("", "", "cde"), np.nan, ("", "", "fgh"), None],
  489:         ],
  490:     ],
  491: )
  492: def test_partition_series_not_split(any_string_dtype, method, exp):
  493:     # https://github.com/pandas-dev/pandas/issues/23558
  494:     # Not split
  495:     s = Series(["abc", "cde", np.nan, "fgh", None], dtype=any_string_dtype)
  496:     result = getattr(s.str, method)("_", expand=False)
  497:     expected = Series(exp)
  498:     expected = _convert_na_value(s, expected)
  499:     tm.assert_series_equal(result, expected)
  500: 
  501: 
  502: @pytest.mark.parametrize(
  503:     "method, exp",
  504:     [
  505:         [
  506:             "partition",
  507:             [("a", "_", "b_c"), ("c", "_", "d_e"), np.nan, ("f", "_", "g_h")],
  508:         ],
  509:         [
  510:             "rpartition",
  511:             [("a_b", "_", "c"), ("c_d", "_", "e"), np.nan, ("f_g", "_", "h")],
  512:         ],
  513:     ],
  514: )
  515: def test_partition_series_unicode(any_string_dtype, method, exp):
  516:     # https://github.com/pandas-dev/pandas/issues/23558
  517:     # unicode
  518:     s = Series(["a_b_c", "c_d_e", np.nan, "f_g_h"], dtype=any_string_dtype)
  519: 
  520:     result = getattr(s.str, method)("_", expand=False)
  521:     expected = Series(exp)
  522:     expected = _convert_na_value(s, expected)
  523:     tm.assert_series_equal(result, expected)
  524: 
  525: 
  526: @pytest.mark.parametrize("method", ["partition", "rpartition"])
  527: def test_partition_series_stdlib(any_string_dtype, method):
  528:     # https://github.com/pandas-dev/pandas/issues/23558
  529:     # compare to standard lib
  530:     s = Series(["A_B_C", "B_C_D", "E_F_G", "EFGHEF"], dtype=any_string_dtype)
  531:     result = getattr(s.str, method)("_", expand=False).tolist()
  532:     assert result == [getattr(v, method)("_") for v in s]
  533: 
  534: 
  535: @pytest.mark.parametrize(
  536:     "method, expand, exp, exp_levels",
  537:     [
  538:         [
  539:             "partition",
  540:             False,
  541:             np.array(
  542:                 [("a", "_", "b_c"), ("c", "_", "d_e"), ("f", "_", "g_h"), np.nan, None],
  543:                 dtype=object,
  544:             ),
  545:             1,
  546:         ],
  547:         [
  548:             "rpartition",
  549:             False,
  550:             np.array(
  551:                 [("a_b", "_", "c"), ("c_d", "_", "e"), ("f_g", "_", "h"), np.nan, None],
  552:                 dtype=object,
  553:             ),
  554:             1,
  555:         ],
  556:     ],
  557: )
  558: def test_partition_index(method, expand, exp, exp_levels):
  559:     # https://github.com/pandas-dev/pandas/issues/23558
  560: 
  561:     values = Index(["a_b_c", "c_d_e", "f_g_h", np.nan, None])
  562: 
  563:     result = getattr(values.str, method)("_", expand=expand)
  564:     exp = Index(exp)
  565:     tm.assert_index_equal(result, exp)
  566:     assert result.nlevels == exp_levels
  567: 
  568: 
  569: @pytest.mark.parametrize(
  570:     "method, exp",
  571:     [
  572:         [
  573:             "partition",
  574:             {
  575:                 0: ["a", "c", np.nan, "f", None],
  576:                 1: ["_", "_", np.nan, "_", None],
  577:                 2: ["b_c", "d_e", np.nan, "g_h", None],
  578:             },
  579:         ],
  580:         [
  581:             "rpartition",
  582:             {
  583:                 0: ["a_b", "c_d", np.nan, "f_g", None],
  584:                 1: ["_", "_", np.nan, "_", None],
  585:                 2: ["c", "e", np.nan, "h", None],
  586:             },
  587:         ],
  588:     ],
  589: )
  590: def test_partition_to_dataframe(any_string_dtype, method, exp):
  591:     # https://github.com/pandas-dev/pandas/issues/23558
  592: 
  593:     s = Series(["a_b_c", "c_d_e", np.nan, "f_g_h", None], dtype=any_string_dtype)
  594:     result = getattr(s.str, method)("_")
  595:     expected = DataFrame(
  596:         exp,
  597:         dtype=any_string_dtype,
  598:     )
  599:     tm.assert_frame_equal(result, expected)
  600: 
  601: 
  602: @pytest.mark.parametrize(
  603:     "method, exp",
  604:     [
  605:         [
  606:             "partition",
  607:             {
  608:                 0: ["a", "c", np.nan, "f", None],
  609:                 1: ["_", "_", np.nan, "_", None],
  610:                 2: ["b_c", "d_e", np.nan, "g_h", None],
  611:             },
  612:         ],
  613:         [
  614:             "rpartition",
  615:             {
  616:                 0: ["a_b", "c_d", np.nan, "f_g", None],
  617:                 1: ["_", "_", np.nan, "_", None],
  618:                 2: ["c", "e", np.nan, "h", None],
  619:             },
  620:         ],
  621:     ],
  622: )
  623: def test_partition_to_dataframe_from_series(any_string_dtype, method, exp):
  624:     # https://github.com/pandas-dev/pandas/issues/23558
  625:     s = Series(["a_b_c", "c_d_e", np.nan, "f_g_h", None], dtype=any_string_dtype)
  626:     result = getattr(s.str, method)("_", expand=True)
  627:     expected = DataFrame(
  628:         exp,
  629:         dtype=any_string_dtype,
  630:     )
  631:     tm.assert_frame_equal(result, expected)
  632: 
  633: 
  634: def test_partition_with_name(any_string_dtype):
  635:     # GH 12617
  636: 
  637:     s = Series(["a,b", "c,d"], name="xxx", dtype=any_string_dtype)
  638:     result = s.str.partition(",")
  639:     expected = DataFrame(
  640:         {0: ["a", "c"], 1: [",", ","], 2: ["b", "d"]}, dtype=any_string_dtype
  641:     )
  642:     tm.assert_frame_equal(result, expected)
  643: 
  644: 
  645: def test_partition_with_name_expand(any_string_dtype):
  646:     # GH 12617
  647:     # should preserve name
  648:     s = Series(["a,b", "c,d"], name="xxx", dtype=any_string_dtype)
  649:     result = s.str.partition(",", expand=False)
  650:     expected = Series([("a", ",", "b"), ("c", ",", "d")], name="xxx")
  651:     tm.assert_series_equal(result, expected)
  652: 
  653: 
  654: def test_partition_index_with_name():
  655:     idx = Index(["a,b", "c,d"], name="xxx")
  656:     result = idx.str.partition(",")
  657:     expected = MultiIndex.from_tuples([("a", ",", "b"), ("c", ",", "d")])
  658:     assert result.nlevels == 3
  659:     tm.assert_index_equal(result, expected)
  660: 
  661: 
  662: def test_partition_index_with_name_expand_false():
  663:     idx = Index(["a,b", "c,d"], name="xxx")
  664:     # should preserve name
  665:     result = idx.str.partition(",", expand=False)
  666:     expected = Index(np.array([("a", ",", "b"), ("c", ",", "d")]), name="xxx")
  667:     assert result.nlevels == 1
  668:     tm.assert_index_equal(result, expected)
  669: 
  670: 
  671: @pytest.mark.parametrize("method", ["partition", "rpartition"])
  672: def test_partition_sep_kwarg(any_string_dtype, method):
  673:     # GH 22676; depr kwarg "pat" in favor of "sep"
  674:     s = Series(["a_b_c", "c_d_e", np.nan, "f_g_h"], dtype=any_string_dtype)
  675: 
  676:     expected = getattr(s.str, method)(sep="_")
  677:     result = getattr(s.str, method)("_")
  678:     tm.assert_frame_equal(result, expected)
  679: 
  680: 
  681: def test_get():
  682:     ser = Series(["a_b_c", "c_d_e", np.nan, "f_g_h"])
  683:     result = ser.str.split("_").str.get(1)
  684:     expected = Series(["b", "d", np.nan, "g"], dtype=object)
  685:     tm.assert_series_equal(result, expected)
  686: 
  687: 
  688: def test_get_mixed_object():
  689:     ser = Series(["a_b_c", np.nan, "c_d_e", True, datetime.today(), None, 1, 2.0])
  690:     result = ser.str.split("_").str.get(1)
  691:     expected = Series(
  692:         ["b", np.nan, "d", np.nan, np.nan, None, np.nan, np.nan], dtype=object
  693:     )
  694:     tm.assert_series_equal(result, expected)
  695: 
  696: 
  697: @pytest.mark.parametrize("idx", [2, -3])
  698: def test_get_bounds(idx):
  699:     ser = Series(["1_2_3_4_5", "6_7_8_9_10", "11_12"])
  700:     result = ser.str.split("_").str.get(idx)
  701:     expected = Series(["3", "8", np.nan], dtype=object)
  702:     tm.assert_series_equal(result, expected)
  703: 
  704: 
  705: @pytest.mark.parametrize(
  706:     "idx, exp", [[2, [3, 3, np.nan, "b"]], [-1, [3, 3, np.nan, np.nan]]]
  707: )
  708: def test_get_complex(idx, exp):
  709:     # GH 20671, getting value not in dict raising `KeyError`
  710:     ser = Series([(1, 2, 3), [1, 2, 3], {1, 2, 3}, {1: "a", 2: "b", 3: "c"}])
  711: 
  712:     result = ser.str.get(idx)
  713:     expected = Series(exp)
  714:     tm.assert_series_equal(result, expected)
  715: 
  716: 
  717: @pytest.mark.parametrize("to_type", [tuple, list, np.array])
  718: def test_get_complex_nested(to_type):
  719:     ser = Series([to_type([to_type([1, 2])])])
  720: 
  721:     result = ser.str.get(0)
  722:     expected = Series([to_type([1, 2])])
  723:     tm.assert_series_equal(result, expected)
  724: 
  725:     result = ser.str.get(1)
  726:     expected = Series([np.nan])
  727:     tm.assert_series_equal(result, expected)
  728: 
  729: 
  730: def test_get_strings(any_string_dtype):
  731:     ser = Series(["a", "ab", np.nan, "abc"], dtype=any_string_dtype)
  732:     result = ser.str.get(2)
  733:     expected = Series([np.nan, np.nan, np.nan, "c"], dtype=any_string_dtype)
  734:     tm.assert_series_equal(result, expected)
