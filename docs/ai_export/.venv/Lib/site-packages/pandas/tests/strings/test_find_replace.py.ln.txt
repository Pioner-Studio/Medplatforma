    1: from datetime import datetime
    2: import re
    3: 
    4: import numpy as np
    5: import pytest
    6: 
    7: from pandas.errors import PerformanceWarning
    8: import pandas.util._test_decorators as td
    9: 
   10: import pandas as pd
   11: from pandas import (
   12:     Series,
   13:     _testing as tm,
   14: )
   15: from pandas.tests.strings import (
   16:     _convert_na_value,
   17:     object_pyarrow_numpy,
   18: )
   19: 
   20: # --------------------------------------------------------------------------------------
   21: # str.contains
   22: # --------------------------------------------------------------------------------------
   23: 
   24: 
   25: def using_pyarrow(dtype):
   26:     return dtype in ("string[pyarrow]", "string[pyarrow_numpy]")
   27: 
   28: 
   29: def test_contains(any_string_dtype):
   30:     values = np.array(
   31:         ["foo", np.nan, "fooommm__foo", "mmm_", "foommm[_]+bar"], dtype=np.object_
   32:     )
   33:     values = Series(values, dtype=any_string_dtype)
   34:     pat = "mmm[_]+"
   35: 
   36:     result = values.str.contains(pat)
   37:     expected_dtype = "object" if any_string_dtype in object_pyarrow_numpy else "boolean"
   38:     expected = Series(
   39:         np.array([False, np.nan, True, True, False], dtype=np.object_),
   40:         dtype=expected_dtype,
   41:     )
   42:     tm.assert_series_equal(result, expected)
   43: 
   44:     result = values.str.contains(pat, regex=False)
   45:     expected = Series(
   46:         np.array([False, np.nan, False, False, True], dtype=np.object_),
   47:         dtype=expected_dtype,
   48:     )
   49:     tm.assert_series_equal(result, expected)
   50: 
   51:     values = Series(
   52:         np.array(["foo", "xyz", "fooommm__foo", "mmm_"], dtype=object),
   53:         dtype=any_string_dtype,
   54:     )
   55:     result = values.str.contains(pat)
   56:     expected_dtype = np.bool_ if any_string_dtype in object_pyarrow_numpy else "boolean"
   57:     expected = Series(np.array([False, False, True, True]), dtype=expected_dtype)
   58:     tm.assert_series_equal(result, expected)
   59: 
   60:     # case insensitive using regex
   61:     values = Series(
   62:         np.array(["Foo", "xYz", "fOOomMm__fOo", "MMM_"], dtype=object),
   63:         dtype=any_string_dtype,
   64:     )
   65: 
   66:     result = values.str.contains("FOO|mmm", case=False)
   67:     expected = Series(np.array([True, False, True, True]), dtype=expected_dtype)
   68:     tm.assert_series_equal(result, expected)
   69: 
   70:     # case insensitive without regex
   71:     result = values.str.contains("foo", regex=False, case=False)
   72:     expected = Series(np.array([True, False, True, False]), dtype=expected_dtype)
   73:     tm.assert_series_equal(result, expected)
   74: 
   75:     # unicode
   76:     values = Series(
   77:         np.array(["foo", np.nan, "fooommm__foo", "mmm_"], dtype=np.object_),
   78:         dtype=any_string_dtype,
   79:     )
   80:     pat = "mmm[_]+"
   81: 
   82:     result = values.str.contains(pat)
   83:     expected_dtype = "object" if any_string_dtype in object_pyarrow_numpy else "boolean"
   84:     expected = Series(
   85:         np.array([False, np.nan, True, True], dtype=np.object_), dtype=expected_dtype
   86:     )
   87:     tm.assert_series_equal(result, expected)
   88: 
   89:     result = values.str.contains(pat, na=False)
   90:     expected_dtype = np.bool_ if any_string_dtype in object_pyarrow_numpy else "boolean"
   91:     expected = Series(np.array([False, False, True, True]), dtype=expected_dtype)
   92:     tm.assert_series_equal(result, expected)
   93: 
   94:     values = Series(
   95:         np.array(["foo", "xyz", "fooommm__foo", "mmm_"], dtype=np.object_),
   96:         dtype=any_string_dtype,
   97:     )
   98:     result = values.str.contains(pat)
   99:     expected = Series(np.array([False, False, True, True]), dtype=expected_dtype)
  100:     tm.assert_series_equal(result, expected)
  101: 
  102: 
  103: def test_contains_object_mixed():
  104:     mixed = Series(
  105:         np.array(
  106:             ["a", np.nan, "b", True, datetime.today(), "foo", None, 1, 2.0],
  107:             dtype=object,
  108:         )
  109:     )
  110:     result = mixed.str.contains("o")
  111:     expected = Series(
  112:         np.array(
  113:             [False, np.nan, False, np.nan, np.nan, True, None, np.nan, np.nan],
  114:             dtype=np.object_,
  115:         )
  116:     )
  117:     tm.assert_series_equal(result, expected)
  118: 
  119: 
  120: def test_contains_na_kwarg_for_object_category():
  121:     # gh 22158
  122: 
  123:     # na for category
  124:     values = Series(["a", "b", "c", "a", np.nan], dtype="category")
  125:     result = values.str.contains("a", na=True)
  126:     expected = Series([True, False, False, True, True])
  127:     tm.assert_series_equal(result, expected)
  128: 
  129:     result = values.str.contains("a", na=False)
  130:     expected = Series([True, False, False, True, False])
  131:     tm.assert_series_equal(result, expected)
  132: 
  133:     # na for objects
  134:     values = Series(["a", "b", "c", "a", np.nan])
  135:     result = values.str.contains("a", na=True)
  136:     expected = Series([True, False, False, True, True])
  137:     tm.assert_series_equal(result, expected)
  138: 
  139:     result = values.str.contains("a", na=False)
  140:     expected = Series([True, False, False, True, False])
  141:     tm.assert_series_equal(result, expected)
  142: 
  143: 
  144: @pytest.mark.parametrize(
  145:     "na, expected",
  146:     [
  147:         (None, pd.NA),
  148:         (True, True),
  149:         (False, False),
  150:         (0, False),
  151:         (3, True),
  152:         (np.nan, pd.NA),
  153:     ],
  154: )
  155: @pytest.mark.parametrize("regex", [True, False])
  156: def test_contains_na_kwarg_for_nullable_string_dtype(
  157:     nullable_string_dtype, na, expected, regex
  158: ):
  159:     # https://github.com/pandas-dev/pandas/pull/41025#issuecomment-824062416
  160: 
  161:     values = Series(["a", "b", "c", "a", np.nan], dtype=nullable_string_dtype)
  162:     result = values.str.contains("a", na=na, regex=regex)
  163:     expected = Series([True, False, False, True, expected], dtype="boolean")
  164:     tm.assert_series_equal(result, expected)
  165: 
  166: 
  167: def test_contains_moar(any_string_dtype):
  168:     # PR #1179
  169:     s = Series(
  170:         ["A", "B", "C", "Aaba", "Baca", "", np.nan, "CABA", "dog", "cat"],
  171:         dtype=any_string_dtype,
  172:     )
  173: 
  174:     result = s.str.contains("a")
  175:     expected_dtype = "object" if any_string_dtype in object_pyarrow_numpy else "boolean"
  176:     expected = Series(
  177:         [False, False, False, True, True, False, np.nan, False, False, True],
  178:         dtype=expected_dtype,
  179:     )
  180:     tm.assert_series_equal(result, expected)
  181: 
  182:     result = s.str.contains("a", case=False)
  183:     expected = Series(
  184:         [True, False, False, True, True, False, np.nan, True, False, True],
  185:         dtype=expected_dtype,
  186:     )
  187:     tm.assert_series_equal(result, expected)
  188: 
  189:     result = s.str.contains("Aa")
  190:     expected = Series(
  191:         [False, False, False, True, False, False, np.nan, False, False, False],
  192:         dtype=expected_dtype,
  193:     )
  194:     tm.assert_series_equal(result, expected)
  195: 
  196:     result = s.str.contains("ba")
  197:     expected = Series(
  198:         [False, False, False, True, False, False, np.nan, False, False, False],
  199:         dtype=expected_dtype,
  200:     )
  201:     tm.assert_series_equal(result, expected)
  202: 
  203:     result = s.str.contains("ba", case=False)
  204:     expected = Series(
  205:         [False, False, False, True, True, False, np.nan, True, False, False],
  206:         dtype=expected_dtype,
  207:     )
  208:     tm.assert_series_equal(result, expected)
  209: 
  210: 
  211: def test_contains_nan(any_string_dtype):
  212:     # PR #14171
  213:     s = Series([np.nan, np.nan, np.nan], dtype=any_string_dtype)
  214: 
  215:     result = s.str.contains("foo", na=False)
  216:     expected_dtype = np.bool_ if any_string_dtype in object_pyarrow_numpy else "boolean"
  217:     expected = Series([False, False, False], dtype=expected_dtype)
  218:     tm.assert_series_equal(result, expected)
  219: 
  220:     result = s.str.contains("foo", na=True)
  221:     expected = Series([True, True, True], dtype=expected_dtype)
  222:     tm.assert_series_equal(result, expected)
  223: 
  224:     result = s.str.contains("foo", na="foo")
  225:     if any_string_dtype == "object":
  226:         expected = Series(["foo", "foo", "foo"], dtype=np.object_)
  227:     elif any_string_dtype == "string[pyarrow_numpy]":
  228:         expected = Series([True, True, True], dtype=np.bool_)
  229:     else:
  230:         expected = Series([True, True, True], dtype="boolean")
  231:     tm.assert_series_equal(result, expected)
  232: 
  233:     result = s.str.contains("foo")
  234:     expected_dtype = "object" if any_string_dtype in object_pyarrow_numpy else "boolean"
  235:     expected = Series([np.nan, np.nan, np.nan], dtype=expected_dtype)
  236:     tm.assert_series_equal(result, expected)
  237: 
  238: 
  239: # --------------------------------------------------------------------------------------
  240: # str.startswith
  241: # --------------------------------------------------------------------------------------
  242: 
  243: 
  244: @pytest.mark.parametrize("pat", ["foo", ("foo", "baz")])
  245: @pytest.mark.parametrize("dtype", ["object", "category"])
  246: @pytest.mark.parametrize("null_value", [None, np.nan, pd.NA])
  247: @pytest.mark.parametrize("na", [True, False])
  248: def test_startswith(pat, dtype, null_value, na):
  249:     # add category dtype parametrizations for GH-36241
  250:     values = Series(
  251:         ["om", null_value, "foo_nom", "nom", "bar_foo", null_value, "foo"],
  252:         dtype=dtype,
  253:     )
  254: 
  255:     result = values.str.startswith(pat)
  256:     exp = Series([False, np.nan, True, False, False, np.nan, True])
  257:     if dtype == "object" and null_value is pd.NA:
  258:         # GH#18463
  259:         exp = exp.fillna(null_value)
  260:     elif dtype == "object" and null_value is None:
  261:         exp[exp.isna()] = None
  262:     tm.assert_series_equal(result, exp)
  263: 
  264:     result = values.str.startswith(pat, na=na)
  265:     exp = Series([False, na, True, False, False, na, True])
  266:     tm.assert_series_equal(result, exp)
  267: 
  268:     # mixed
  269:     mixed = np.array(
  270:         ["a", np.nan, "b", True, datetime.today(), "foo", None, 1, 2.0],
  271:         dtype=np.object_,
  272:     )
  273:     rs = Series(mixed).str.startswith("f")
  274:     xp = Series([False, np.nan, False, np.nan, np.nan, True, None, np.nan, np.nan])
  275:     tm.assert_series_equal(rs, xp)
  276: 
  277: 
  278: @pytest.mark.parametrize("na", [None, True, False])
  279: def test_startswith_nullable_string_dtype(nullable_string_dtype, na):
  280:     values = Series(
  281:         ["om", None, "foo_nom", "nom", "bar_foo", None, "foo", "regex", "rege."],
  282:         dtype=nullable_string_dtype,
  283:     )
  284:     result = values.str.startswith("foo", na=na)
  285:     exp = Series(
  286:         [False, na, True, False, False, na, True, False, False], dtype="boolean"
  287:     )
  288:     tm.assert_series_equal(result, exp)
  289: 
  290:     result = values.str.startswith("rege.", na=na)
  291:     exp = Series(
  292:         [False, na, False, False, False, na, False, False, True], dtype="boolean"
  293:     )
  294:     tm.assert_series_equal(result, exp)
  295: 
  296: 
  297: # --------------------------------------------------------------------------------------
  298: # str.endswith
  299: # --------------------------------------------------------------------------------------
  300: 
  301: 
  302: @pytest.mark.parametrize("pat", ["foo", ("foo", "baz")])
  303: @pytest.mark.parametrize("dtype", ["object", "category"])
  304: @pytest.mark.parametrize("null_value", [None, np.nan, pd.NA])
  305: @pytest.mark.parametrize("na", [True, False])
  306: def test_endswith(pat, dtype, null_value, na):
  307:     # add category dtype parametrizations for GH-36241
  308:     values = Series(
  309:         ["om", null_value, "foo_nom", "nom", "bar_foo", null_value, "foo"],
  310:         dtype=dtype,
  311:     )
  312: 
  313:     result = values.str.endswith(pat)
  314:     exp = Series([False, np.nan, False, False, True, np.nan, True])
  315:     if dtype == "object" and null_value is pd.NA:
  316:         # GH#18463
  317:         exp = exp.fillna(null_value)
  318:     elif dtype == "object" and null_value is None:
  319:         exp[exp.isna()] = None
  320:     tm.assert_series_equal(result, exp)
  321: 
  322:     result = values.str.endswith(pat, na=na)
  323:     exp = Series([False, na, False, False, True, na, True])
  324:     tm.assert_series_equal(result, exp)
  325: 
  326:     # mixed
  327:     mixed = np.array(
  328:         ["a", np.nan, "b", True, datetime.today(), "foo", None, 1, 2.0],
  329:         dtype=object,
  330:     )
  331:     rs = Series(mixed).str.endswith("f")
  332:     xp = Series([False, np.nan, False, np.nan, np.nan, False, None, np.nan, np.nan])
  333:     tm.assert_series_equal(rs, xp)
  334: 
  335: 
  336: @pytest.mark.parametrize("na", [None, True, False])
  337: def test_endswith_nullable_string_dtype(nullable_string_dtype, na):
  338:     values = Series(
  339:         ["om", None, "foo_nom", "nom", "bar_foo", None, "foo", "regex", "rege."],
  340:         dtype=nullable_string_dtype,
  341:     )
  342:     result = values.str.endswith("foo", na=na)
  343:     exp = Series(
  344:         [False, na, False, False, True, na, True, False, False], dtype="boolean"
  345:     )
  346:     tm.assert_series_equal(result, exp)
  347: 
  348:     result = values.str.endswith("rege.", na=na)
  349:     exp = Series(
  350:         [False, na, False, False, False, na, False, False, True], dtype="boolean"
  351:     )
  352:     tm.assert_series_equal(result, exp)
  353: 
  354: 
  355: # --------------------------------------------------------------------------------------
  356: # str.replace
  357: # --------------------------------------------------------------------------------------
  358: 
  359: 
  360: def test_replace(any_string_dtype):
  361:     ser = Series(["fooBAD__barBAD", np.nan], dtype=any_string_dtype)
  362: 
  363:     result = ser.str.replace("BAD[_]*", "", regex=True)
  364:     expected = Series(["foobar", np.nan], dtype=any_string_dtype)
  365:     tm.assert_series_equal(result, expected)
  366: 
  367: 
  368: def test_replace_max_replacements(any_string_dtype):
  369:     ser = Series(["fooBAD__barBAD", np.nan], dtype=any_string_dtype)
  370: 
  371:     expected = Series(["foobarBAD", np.nan], dtype=any_string_dtype)
  372:     result = ser.str.replace("BAD[_]*", "", n=1, regex=True)
  373:     tm.assert_series_equal(result, expected)
  374: 
  375:     expected = Series(["foo__barBAD", np.nan], dtype=any_string_dtype)
  376:     result = ser.str.replace("BAD", "", n=1, regex=False)
  377:     tm.assert_series_equal(result, expected)
  378: 
  379: 
  380: def test_replace_mixed_object():
  381:     ser = Series(
  382:         ["aBAD", np.nan, "bBAD", True, datetime.today(), "fooBAD", None, 1, 2.0]
  383:     )
  384:     result = Series(ser).str.replace("BAD[_]*", "", regex=True)
  385:     expected = Series(
  386:         ["a", np.nan, "b", np.nan, np.nan, "foo", None, np.nan, np.nan], dtype=object
  387:     )
  388:     tm.assert_series_equal(result, expected)
  389: 
  390: 
  391: def test_replace_unicode(any_string_dtype):
  392:     ser = Series([b"abcd,\xc3\xa0".decode("utf-8")], dtype=any_string_dtype)
  393:     expected = Series([b"abcd, \xc3\xa0".decode("utf-8")], dtype=any_string_dtype)
  394:     with tm.maybe_produces_warning(PerformanceWarning, using_pyarrow(any_string_dtype)):
  395:         result = ser.str.replace(r"(?<=\w),(?=\w)", ", ", flags=re.UNICODE, regex=True)
  396:     tm.assert_series_equal(result, expected)
  397: 
  398: 
  399: @pytest.mark.parametrize("repl", [None, 3, {"a": "b"}])
  400: @pytest.mark.parametrize("data", [["a", "b", None], ["a", "b", "c", "ad"]])
  401: def test_replace_wrong_repl_type_raises(any_string_dtype, index_or_series, repl, data):
  402:     # https://github.com/pandas-dev/pandas/issues/13438
  403:     msg = "repl must be a string or callable"
  404:     obj = index_or_series(data, dtype=any_string_dtype)
  405:     with pytest.raises(TypeError, match=msg):
  406:         obj.str.replace("a", repl)
  407: 
  408: 
  409: def test_replace_callable(any_string_dtype):
  410:     # GH 15055
  411:     ser = Series(["fooBAD__barBAD", np.nan], dtype=any_string_dtype)
  412: 
  413:     # test with callable
  414:     repl = lambda m: m.group(0).swapcase()
  415:     with tm.maybe_produces_warning(PerformanceWarning, using_pyarrow(any_string_dtype)):
  416:         result = ser.str.replace("[a-z][A-Z]{2}", repl, n=2, regex=True)
  417:     expected = Series(["foObaD__baRbaD", np.nan], dtype=any_string_dtype)
  418:     tm.assert_series_equal(result, expected)
  419: 
  420: 
  421: @pytest.mark.parametrize(
  422:     "repl", [lambda: None, lambda m, x: None, lambda m, x, y=None: None]
  423: )
  424: def test_replace_callable_raises(any_string_dtype, repl):
  425:     # GH 15055
  426:     values = Series(["fooBAD__barBAD", np.nan], dtype=any_string_dtype)
  427: 
  428:     # test with wrong number of arguments, raising an error
  429:     msg = (
  430:         r"((takes)|(missing)) (?(2)from \d+ to )?\d+ "
  431:         r"(?(3)required )positional arguments?"
  432:     )
  433:     with pytest.raises(TypeError, match=msg):
  434:         with tm.maybe_produces_warning(
  435:             PerformanceWarning, using_pyarrow(any_string_dtype)
  436:         ):
  437:             values.str.replace("a", repl, regex=True)
  438: 
  439: 
  440: def test_replace_callable_named_groups(any_string_dtype):
  441:     # test regex named groups
  442:     ser = Series(["Foo Bar Baz", np.nan], dtype=any_string_dtype)
  443:     pat = r"(?P<first>\w+) (?P<middle>\w+) (?P<last>\w+)"
  444:     repl = lambda m: m.group("middle").swapcase()
  445:     with tm.maybe_produces_warning(PerformanceWarning, using_pyarrow(any_string_dtype)):
  446:         result = ser.str.replace(pat, repl, regex=True)
  447:     expected = Series(["bAR", np.nan], dtype=any_string_dtype)
  448:     tm.assert_series_equal(result, expected)
  449: 
  450: 
  451: def test_replace_compiled_regex(any_string_dtype):
  452:     # GH 15446
  453:     ser = Series(["fooBAD__barBAD", np.nan], dtype=any_string_dtype)
  454: 
  455:     # test with compiled regex
  456:     pat = re.compile(r"BAD_*")
  457:     with tm.maybe_produces_warning(PerformanceWarning, using_pyarrow(any_string_dtype)):
  458:         result = ser.str.replace(pat, "", regex=True)
  459:     expected = Series(["foobar", np.nan], dtype=any_string_dtype)
  460:     tm.assert_series_equal(result, expected)
  461: 
  462:     with tm.maybe_produces_warning(PerformanceWarning, using_pyarrow(any_string_dtype)):
  463:         result = ser.str.replace(pat, "", n=1, regex=True)
  464:     expected = Series(["foobarBAD", np.nan], dtype=any_string_dtype)
  465:     tm.assert_series_equal(result, expected)
  466: 
  467: 
  468: def test_replace_compiled_regex_mixed_object():
  469:     pat = re.compile(r"BAD_*")
  470:     ser = Series(
  471:         ["aBAD", np.nan, "bBAD", True, datetime.today(), "fooBAD", None, 1, 2.0]
  472:     )
  473:     result = Series(ser).str.replace(pat, "", regex=True)
  474:     expected = Series(
  475:         ["a", np.nan, "b", np.nan, np.nan, "foo", None, np.nan, np.nan], dtype=object
  476:     )
  477:     tm.assert_series_equal(result, expected)
  478: 
  479: 
  480: def test_replace_compiled_regex_unicode(any_string_dtype):
  481:     ser = Series([b"abcd,\xc3\xa0".decode("utf-8")], dtype=any_string_dtype)
  482:     expected = Series([b"abcd, \xc3\xa0".decode("utf-8")], dtype=any_string_dtype)
  483:     pat = re.compile(r"(?<=\w),(?=\w)", flags=re.UNICODE)
  484:     with tm.maybe_produces_warning(PerformanceWarning, using_pyarrow(any_string_dtype)):
  485:         result = ser.str.replace(pat, ", ", regex=True)
  486:     tm.assert_series_equal(result, expected)
  487: 
  488: 
  489: def test_replace_compiled_regex_raises(any_string_dtype):
  490:     # case and flags provided to str.replace will have no effect
  491:     # and will produce warnings
  492:     ser = Series(["fooBAD__barBAD__bad", np.nan], dtype=any_string_dtype)
  493:     pat = re.compile(r"BAD_*")
  494: 
  495:     msg = "case and flags cannot be set when pat is a compiled regex"
  496: 
  497:     with pytest.raises(ValueError, match=msg):
  498:         ser.str.replace(pat, "", flags=re.IGNORECASE, regex=True)
  499: 
  500:     with pytest.raises(ValueError, match=msg):
  501:         ser.str.replace(pat, "", case=False, regex=True)
  502: 
  503:     with pytest.raises(ValueError, match=msg):
  504:         ser.str.replace(pat, "", case=True, regex=True)
  505: 
  506: 
  507: def test_replace_compiled_regex_callable(any_string_dtype):
  508:     # test with callable
  509:     ser = Series(["fooBAD__barBAD", np.nan], dtype=any_string_dtype)
  510:     repl = lambda m: m.group(0).swapcase()
  511:     pat = re.compile("[a-z][A-Z]{2}")
  512:     with tm.maybe_produces_warning(PerformanceWarning, using_pyarrow(any_string_dtype)):
  513:         result = ser.str.replace(pat, repl, n=2, regex=True)
  514:     expected = Series(["foObaD__baRbaD", np.nan], dtype=any_string_dtype)
  515:     tm.assert_series_equal(result, expected)
  516: 
  517: 
  518: @pytest.mark.parametrize(
  519:     "regex,expected", [(True, ["bao", "bao", np.nan]), (False, ["bao", "foo", np.nan])]
  520: )
  521: def test_replace_literal(regex, expected, any_string_dtype):
  522:     # GH16808 literal replace (regex=False vs regex=True)
  523:     ser = Series(["f.o", "foo", np.nan], dtype=any_string_dtype)
  524:     expected = Series(expected, dtype=any_string_dtype)
  525:     result = ser.str.replace("f.", "ba", regex=regex)
  526:     tm.assert_series_equal(result, expected)
  527: 
  528: 
  529: def test_replace_literal_callable_raises(any_string_dtype):
  530:     ser = Series([], dtype=any_string_dtype)
  531:     repl = lambda m: m.group(0).swapcase()
  532: 
  533:     msg = "Cannot use a callable replacement when regex=False"
  534:     with pytest.raises(ValueError, match=msg):
  535:         ser.str.replace("abc", repl, regex=False)
  536: 
  537: 
  538: def test_replace_literal_compiled_raises(any_string_dtype):
  539:     ser = Series([], dtype=any_string_dtype)
  540:     pat = re.compile("[a-z][A-Z]{2}")
  541: 
  542:     msg = "Cannot use a compiled regex as replacement pattern with regex=False"
  543:     with pytest.raises(ValueError, match=msg):
  544:         ser.str.replace(pat, "", regex=False)
  545: 
  546: 
  547: def test_replace_moar(any_string_dtype):
  548:     # PR #1179
  549:     ser = Series(
  550:         ["A", "B", "C", "Aaba", "Baca", "", np.nan, "CABA", "dog", "cat"],
  551:         dtype=any_string_dtype,
  552:     )
  553: 
  554:     result = ser.str.replace("A", "YYY")
  555:     expected = Series(
  556:         ["YYY", "B", "C", "YYYaba", "Baca", "", np.nan, "CYYYBYYY", "dog", "cat"],
  557:         dtype=any_string_dtype,
  558:     )
  559:     tm.assert_series_equal(result, expected)
  560: 
  561:     with tm.maybe_produces_warning(PerformanceWarning, using_pyarrow(any_string_dtype)):
  562:         result = ser.str.replace("A", "YYY", case=False)
  563:     expected = Series(
  564:         [
  565:             "YYY",
  566:             "B",
  567:             "C",
  568:             "YYYYYYbYYY",
  569:             "BYYYcYYY",
  570:             "",
  571:             np.nan,
  572:             "CYYYBYYY",
  573:             "dog",
  574:             "cYYYt",
  575:         ],
  576:         dtype=any_string_dtype,
  577:     )
  578:     tm.assert_series_equal(result, expected)
  579: 
  580:     with tm.maybe_produces_warning(PerformanceWarning, using_pyarrow(any_string_dtype)):
  581:         result = ser.str.replace("^.a|dog", "XX-XX ", case=False, regex=True)
  582:     expected = Series(
  583:         [
  584:             "A",
  585:             "B",
  586:             "C",
  587:             "XX-XX ba",
  588:             "XX-XX ca",
  589:             "",
  590:             np.nan,
  591:             "XX-XX BA",
  592:             "XX-XX ",
  593:             "XX-XX t",
  594:         ],
  595:         dtype=any_string_dtype,
  596:     )
  597:     tm.assert_series_equal(result, expected)
  598: 
  599: 
  600: def test_replace_not_case_sensitive_not_regex(any_string_dtype):
  601:     # https://github.com/pandas-dev/pandas/issues/41602
  602:     ser = Series(["A.", "a.", "Ab", "ab", np.nan], dtype=any_string_dtype)
  603: 
  604:     with tm.maybe_produces_warning(PerformanceWarning, using_pyarrow(any_string_dtype)):
  605:         result = ser.str.replace("a", "c", case=False, regex=False)
  606:     expected = Series(["c.", "c.", "cb", "cb", np.nan], dtype=any_string_dtype)
  607:     tm.assert_series_equal(result, expected)
  608: 
  609:     with tm.maybe_produces_warning(PerformanceWarning, using_pyarrow(any_string_dtype)):
  610:         result = ser.str.replace("a.", "c.", case=False, regex=False)
  611:     expected = Series(["c.", "c.", "Ab", "ab", np.nan], dtype=any_string_dtype)
  612:     tm.assert_series_equal(result, expected)
  613: 
  614: 
  615: def test_replace_regex(any_string_dtype):
  616:     # https://github.com/pandas-dev/pandas/pull/24809
  617:     s = Series(["a", "b", "ac", np.nan, ""], dtype=any_string_dtype)
  618:     result = s.str.replace("^.$", "a", regex=True)
  619:     expected = Series(["a", "a", "ac", np.nan, ""], dtype=any_string_dtype)
  620:     tm.assert_series_equal(result, expected)
  621: 
  622: 
  623: @pytest.mark.parametrize("regex", [True, False])
  624: def test_replace_regex_single_character(regex, any_string_dtype):
  625:     # https://github.com/pandas-dev/pandas/pull/24809, enforced in 2.0
  626:     # GH 24804
  627:     s = Series(["a.b", ".", "b", np.nan, ""], dtype=any_string_dtype)
  628: 
  629:     result = s.str.replace(".", "a", regex=regex)
  630:     if regex:
  631:         expected = Series(["aaa", "a", "a", np.nan, ""], dtype=any_string_dtype)
  632:     else:
  633:         expected = Series(["aab", "a", "b", np.nan, ""], dtype=any_string_dtype)
  634:     tm.assert_series_equal(result, expected)
  635: 
  636: 
  637: # --------------------------------------------------------------------------------------
  638: # str.match
  639: # --------------------------------------------------------------------------------------
  640: 
  641: 
  642: def test_match(any_string_dtype):
  643:     # New match behavior introduced in 0.13
  644:     expected_dtype = "object" if any_string_dtype in object_pyarrow_numpy else "boolean"
  645: 
  646:     values = Series(["fooBAD__barBAD", np.nan, "foo"], dtype=any_string_dtype)
  647:     result = values.str.match(".*(BAD[_]+).*(BAD)")
  648:     expected = Series([True, np.nan, False], dtype=expected_dtype)
  649:     tm.assert_series_equal(result, expected)
  650: 
  651:     values = Series(
  652:         ["fooBAD__barBAD", "BAD_BADleroybrown", np.nan, "foo"], dtype=any_string_dtype
  653:     )
  654:     result = values.str.match(".*BAD[_]+.*BAD")
  655:     expected = Series([True, True, np.nan, False], dtype=expected_dtype)
  656:     tm.assert_series_equal(result, expected)
  657: 
  658:     result = values.str.match("BAD[_]+.*BAD")
  659:     expected = Series([False, True, np.nan, False], dtype=expected_dtype)
  660:     tm.assert_series_equal(result, expected)
  661: 
  662:     values = Series(
  663:         ["fooBAD__barBAD", "^BAD_BADleroybrown", np.nan, "foo"], dtype=any_string_dtype
  664:     )
  665:     result = values.str.match("^BAD[_]+.*BAD")
  666:     expected = Series([False, False, np.nan, False], dtype=expected_dtype)
  667:     tm.assert_series_equal(result, expected)
  668: 
  669:     result = values.str.match("\\^BAD[_]+.*BAD")
  670:     expected = Series([False, True, np.nan, False], dtype=expected_dtype)
  671:     tm.assert_series_equal(result, expected)
  672: 
  673: 
  674: def test_match_mixed_object():
  675:     mixed = Series(
  676:         [
  677:             "aBAD_BAD",
  678:             np.nan,
  679:             "BAD_b_BAD",
  680:             True,
  681:             datetime.today(),
  682:             "foo",
  683:             None,
  684:             1,
  685:             2.0,
  686:         ]
  687:     )
  688:     result = Series(mixed).str.match(".*(BAD[_]+).*(BAD)")
  689:     expected = Series([True, np.nan, True, np.nan, np.nan, False, None, np.nan, np.nan])
  690:     assert isinstance(result, Series)
  691:     tm.assert_series_equal(result, expected)
  692: 
  693: 
  694: def test_match_na_kwarg(any_string_dtype):
  695:     # GH #6609
  696:     s = Series(["a", "b", np.nan], dtype=any_string_dtype)
  697: 
  698:     result = s.str.match("a", na=False)
  699:     expected_dtype = np.bool_ if any_string_dtype in object_pyarrow_numpy else "boolean"
  700:     expected = Series([True, False, False], dtype=expected_dtype)
  701:     tm.assert_series_equal(result, expected)
  702: 
  703:     result = s.str.match("a")
  704:     expected_dtype = "object" if any_string_dtype in object_pyarrow_numpy else "boolean"
  705:     expected = Series([True, False, np.nan], dtype=expected_dtype)
  706:     tm.assert_series_equal(result, expected)
  707: 
  708: 
  709: def test_match_case_kwarg(any_string_dtype):
  710:     values = Series(["ab", "AB", "abc", "ABC"], dtype=any_string_dtype)
  711:     result = values.str.match("ab", case=False)
  712:     expected_dtype = np.bool_ if any_string_dtype in object_pyarrow_numpy else "boolean"
  713:     expected = Series([True, True, True, True], dtype=expected_dtype)
  714:     tm.assert_series_equal(result, expected)
  715: 
  716: 
  717: # --------------------------------------------------------------------------------------
  718: # str.fullmatch
  719: # --------------------------------------------------------------------------------------
  720: 
  721: 
  722: def test_fullmatch(any_string_dtype):
  723:     # GH 32806
  724:     ser = Series(
  725:         ["fooBAD__barBAD", "BAD_BADleroybrown", np.nan, "foo"], dtype=any_string_dtype
  726:     )
  727:     result = ser.str.fullmatch(".*BAD[_]+.*BAD")
  728:     expected_dtype = "object" if any_string_dtype in object_pyarrow_numpy else "boolean"
  729:     expected = Series([True, False, np.nan, False], dtype=expected_dtype)
  730:     tm.assert_series_equal(result, expected)
  731: 
  732: 
  733: def test_fullmatch_dollar_literal(any_string_dtype):
  734:     # GH 56652
  735:     ser = Series(["foo", "foo$foo", np.nan, "foo$"], dtype=any_string_dtype)
  736:     result = ser.str.fullmatch("foo\\$")
  737:     expected_dtype = "object" if any_string_dtype in object_pyarrow_numpy else "boolean"
  738:     expected = Series([False, False, np.nan, True], dtype=expected_dtype)
  739:     tm.assert_series_equal(result, expected)
  740: 
  741: 
  742: def test_fullmatch_na_kwarg(any_string_dtype):
  743:     ser = Series(
  744:         ["fooBAD__barBAD", "BAD_BADleroybrown", np.nan, "foo"], dtype=any_string_dtype
  745:     )
  746:     result = ser.str.fullmatch(".*BAD[_]+.*BAD", na=False)
  747:     expected_dtype = np.bool_ if any_string_dtype in object_pyarrow_numpy else "boolean"
  748:     expected = Series([True, False, False, False], dtype=expected_dtype)
  749:     tm.assert_series_equal(result, expected)
  750: 
  751: 
  752: def test_fullmatch_case_kwarg(any_string_dtype):
  753:     ser = Series(["ab", "AB", "abc", "ABC"], dtype=any_string_dtype)
  754:     expected_dtype = np.bool_ if any_string_dtype in object_pyarrow_numpy else "boolean"
  755: 
  756:     expected = Series([True, False, False, False], dtype=expected_dtype)
  757: 
  758:     result = ser.str.fullmatch("ab", case=True)
  759:     tm.assert_series_equal(result, expected)
  760: 
  761:     expected = Series([True, True, False, False], dtype=expected_dtype)
  762: 
  763:     result = ser.str.fullmatch("ab", case=False)
  764:     tm.assert_series_equal(result, expected)
  765: 
  766:     with tm.maybe_produces_warning(PerformanceWarning, using_pyarrow(any_string_dtype)):
  767:         result = ser.str.fullmatch("ab", flags=re.IGNORECASE)
  768:     tm.assert_series_equal(result, expected)
  769: 
  770: 
  771: # --------------------------------------------------------------------------------------
  772: # str.findall
  773: # --------------------------------------------------------------------------------------
  774: 
  775: 
  776: def test_findall(any_string_dtype):
  777:     ser = Series(["fooBAD__barBAD", np.nan, "foo", "BAD"], dtype=any_string_dtype)
  778:     result = ser.str.findall("BAD[_]*")
  779:     expected = Series([["BAD__", "BAD"], np.nan, [], ["BAD"]])
  780:     expected = _convert_na_value(ser, expected)
  781:     tm.assert_series_equal(result, expected)
  782: 
  783: 
  784: def test_findall_mixed_object():
  785:     ser = Series(
  786:         [
  787:             "fooBAD__barBAD",
  788:             np.nan,
  789:             "foo",
  790:             True,
  791:             datetime.today(),
  792:             "BAD",
  793:             None,
  794:             1,
  795:             2.0,
  796:         ]
  797:     )
  798: 
  799:     result = ser.str.findall("BAD[_]*")
  800:     expected = Series(
  801:         [
  802:             ["BAD__", "BAD"],
  803:             np.nan,
  804:             [],
  805:             np.nan,
  806:             np.nan,
  807:             ["BAD"],
  808:             None,
  809:             np.nan,
  810:             np.nan,
  811:         ]
  812:     )
  813: 
  814:     tm.assert_series_equal(result, expected)
  815: 
  816: 
  817: # --------------------------------------------------------------------------------------
  818: # str.find
  819: # --------------------------------------------------------------------------------------
  820: 
  821: 
  822: def test_find(any_string_dtype):
  823:     ser = Series(
  824:         ["ABCDEFG", "BCDEFEF", "DEFGHIJEF", "EFGHEF", "XXXX"], dtype=any_string_dtype
  825:     )
  826:     expected_dtype = np.int64 if any_string_dtype in object_pyarrow_numpy else "Int64"
  827: 
  828:     result = ser.str.find("EF")
  829:     expected = Series([4, 3, 1, 0, -1], dtype=expected_dtype)
  830:     tm.assert_series_equal(result, expected)
  831:     expected = np.array([v.find("EF") for v in np.array(ser)], dtype=np.int64)
  832:     tm.assert_numpy_array_equal(np.array(result, dtype=np.int64), expected)
  833: 
  834:     result = ser.str.rfind("EF")
  835:     expected = Series([4, 5, 7, 4, -1], dtype=expected_dtype)
  836:     tm.assert_series_equal(result, expected)
  837:     expected = np.array([v.rfind("EF") for v in np.array(ser)], dtype=np.int64)
  838:     tm.assert_numpy_array_equal(np.array(result, dtype=np.int64), expected)
  839: 
  840:     result = ser.str.find("EF", 3)
  841:     expected = Series([4, 3, 7, 4, -1], dtype=expected_dtype)
  842:     tm.assert_series_equal(result, expected)
  843:     expected = np.array([v.find("EF", 3) for v in np.array(ser)], dtype=np.int64)
  844:     tm.assert_numpy_array_equal(np.array(result, dtype=np.int64), expected)
  845: 
  846:     result = ser.str.rfind("EF", 3)
  847:     expected = Series([4, 5, 7, 4, -1], dtype=expected_dtype)
  848:     tm.assert_series_equal(result, expected)
  849:     expected = np.array([v.rfind("EF", 3) for v in np.array(ser)], dtype=np.int64)
  850:     tm.assert_numpy_array_equal(np.array(result, dtype=np.int64), expected)
  851: 
  852:     result = ser.str.find("EF", 3, 6)
  853:     expected = Series([4, 3, -1, 4, -1], dtype=expected_dtype)
  854:     tm.assert_series_equal(result, expected)
  855:     expected = np.array([v.find("EF", 3, 6) for v in np.array(ser)], dtype=np.int64)
  856:     tm.assert_numpy_array_equal(np.array(result, dtype=np.int64), expected)
  857: 
  858:     result = ser.str.rfind("EF", 3, 6)
  859:     expected = Series([4, 3, -1, 4, -1], dtype=expected_dtype)
  860:     tm.assert_series_equal(result, expected)
  861:     expected = np.array([v.rfind("EF", 3, 6) for v in np.array(ser)], dtype=np.int64)
  862:     tm.assert_numpy_array_equal(np.array(result, dtype=np.int64), expected)
  863: 
  864: 
  865: def test_find_bad_arg_raises(any_string_dtype):
  866:     ser = Series([], dtype=any_string_dtype)
  867:     with pytest.raises(TypeError, match="expected a string object, not int"):
  868:         ser.str.find(0)
  869: 
  870:     with pytest.raises(TypeError, match="expected a string object, not int"):
  871:         ser.str.rfind(0)
  872: 
  873: 
  874: def test_find_nan(any_string_dtype):
  875:     ser = Series(
  876:         ["ABCDEFG", np.nan, "DEFGHIJEF", np.nan, "XXXX"], dtype=any_string_dtype
  877:     )
  878:     expected_dtype = np.float64 if any_string_dtype in object_pyarrow_numpy else "Int64"
  879: 
  880:     result = ser.str.find("EF")
  881:     expected = Series([4, np.nan, 1, np.nan, -1], dtype=expected_dtype)
  882:     tm.assert_series_equal(result, expected)
  883: 
  884:     result = ser.str.rfind("EF")
  885:     expected = Series([4, np.nan, 7, np.nan, -1], dtype=expected_dtype)
  886:     tm.assert_series_equal(result, expected)
  887: 
  888:     result = ser.str.find("EF", 3)
  889:     expected = Series([4, np.nan, 7, np.nan, -1], dtype=expected_dtype)
  890:     tm.assert_series_equal(result, expected)
  891: 
  892:     result = ser.str.rfind("EF", 3)
  893:     expected = Series([4, np.nan, 7, np.nan, -1], dtype=expected_dtype)
  894:     tm.assert_series_equal(result, expected)
  895: 
  896:     result = ser.str.find("EF", 3, 6)
  897:     expected = Series([4, np.nan, -1, np.nan, -1], dtype=expected_dtype)
  898:     tm.assert_series_equal(result, expected)
  899: 
  900:     result = ser.str.rfind("EF", 3, 6)
  901:     expected = Series([4, np.nan, -1, np.nan, -1], dtype=expected_dtype)
  902:     tm.assert_series_equal(result, expected)
  903: 
  904: 
  905: # --------------------------------------------------------------------------------------
  906: # str.translate
  907: # --------------------------------------------------------------------------------------
  908: 
  909: 
  910: @pytest.mark.parametrize(
  911:     "infer_string", [False, pytest.param(True, marks=td.skip_if_no("pyarrow"))]
  912: )
  913: def test_translate(index_or_series, any_string_dtype, infer_string):
  914:     obj = index_or_series(
  915:         ["abcdefg", "abcc", "cdddfg", "cdefggg"], dtype=any_string_dtype
  916:     )
  917:     table = str.maketrans("abc", "cde")
  918:     result = obj.str.translate(table)
  919:     expected = index_or_series(
  920:         ["cdedefg", "cdee", "edddfg", "edefggg"], dtype=any_string_dtype
  921:     )
  922:     tm.assert_equal(result, expected)
  923: 
  924: 
  925: def test_translate_mixed_object():
  926:     # Series with non-string values
  927:     s = Series(["a", "b", "c", 1.2])
  928:     table = str.maketrans("abc", "cde")
  929:     expected = Series(["c", "d", "e", np.nan], dtype=object)
  930:     result = s.str.translate(table)
  931:     tm.assert_series_equal(result, expected)
  932: 
  933: 
  934: # --------------------------------------------------------------------------------------
  935: 
  936: 
  937: def test_flags_kwarg(any_string_dtype):
  938:     data = {
  939:         "Dave": "dave@google.com",
  940:         "Steve": "steve@gmail.com",
  941:         "Rob": "rob@gmail.com",
  942:         "Wes": np.nan,
  943:     }
  944:     data = Series(data, dtype=any_string_dtype)
  945: 
  946:     pat = r"([A-Z0-9._%+-]+)@([A-Z0-9.-]+)\.([A-Z]{2,4})"
  947: 
  948:     use_pyarrow = using_pyarrow(any_string_dtype)
  949: 
  950:     result = data.str.extract(pat, flags=re.IGNORECASE, expand=True)
  951:     assert result.iloc[0].tolist() == ["dave", "google", "com"]
  952: 
  953:     with tm.maybe_produces_warning(PerformanceWarning, use_pyarrow):
  954:         result = data.str.match(pat, flags=re.IGNORECASE)
  955:     assert result.iloc[0]
  956: 
  957:     with tm.maybe_produces_warning(PerformanceWarning, use_pyarrow):
  958:         result = data.str.fullmatch(pat, flags=re.IGNORECASE)
  959:     assert result.iloc[0]
  960: 
  961:     result = data.str.findall(pat, flags=re.IGNORECASE)
  962:     assert result.iloc[0][0] == ("dave", "google", "com")
  963: 
  964:     result = data.str.count(pat, flags=re.IGNORECASE)
  965:     assert result.iloc[0] == 1
  966: 
  967:     msg = "has match groups"
  968:     with tm.assert_produces_warning(
  969:         UserWarning, match=msg, raise_on_extra_warnings=not use_pyarrow
  970:     ):
  971:         result = data.str.contains(pat, flags=re.IGNORECASE)
  972:     assert result.iloc[0]
