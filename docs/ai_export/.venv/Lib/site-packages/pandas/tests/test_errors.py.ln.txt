    1: import pytest
    2: 
    3: from pandas.errors import (
    4:     AbstractMethodError,
    5:     UndefinedVariableError,
    6: )
    7: 
    8: import pandas as pd
    9: 
   10: 
   11: @pytest.mark.parametrize(
   12:     "exc",
   13:     [
   14:         "AttributeConflictWarning",
   15:         "CSSWarning",
   16:         "CategoricalConversionWarning",
   17:         "ClosedFileError",
   18:         "DataError",
   19:         "DatabaseError",
   20:         "DtypeWarning",
   21:         "EmptyDataError",
   22:         "IncompatibilityWarning",
   23:         "IndexingError",
   24:         "InvalidColumnName",
   25:         "InvalidComparison",
   26:         "InvalidVersion",
   27:         "LossySetitemError",
   28:         "MergeError",
   29:         "NoBufferPresent",
   30:         "NumExprClobberingError",
   31:         "NumbaUtilError",
   32:         "OptionError",
   33:         "OutOfBoundsDatetime",
   34:         "ParserError",
   35:         "ParserWarning",
   36:         "PerformanceWarning",
   37:         "PossibleDataLossError",
   38:         "PossiblePrecisionLoss",
   39:         "PyperclipException",
   40:         "SettingWithCopyError",
   41:         "SettingWithCopyWarning",
   42:         "SpecificationError",
   43:         "UnsortedIndexError",
   44:         "UnsupportedFunctionCall",
   45:         "ValueLabelTypeMismatch",
   46:     ],
   47: )
   48: def test_exception_importable(exc):
   49:     from pandas import errors
   50: 
   51:     err = getattr(errors, exc)
   52:     assert err is not None
   53: 
   54:     # check that we can raise on them
   55: 
   56:     msg = "^$"
   57: 
   58:     with pytest.raises(err, match=msg):
   59:         raise err()
   60: 
   61: 
   62: def test_catch_oob():
   63:     from pandas import errors
   64: 
   65:     msg = "Cannot cast 1500-01-01 00:00:00 to unit='ns' without overflow"
   66:     with pytest.raises(errors.OutOfBoundsDatetime, match=msg):
   67:         pd.Timestamp("15000101").as_unit("ns")
   68: 
   69: 
   70: @pytest.mark.parametrize(
   71:     "is_local",
   72:     [
   73:         True,
   74:         False,
   75:     ],
   76: )
   77: def test_catch_undefined_variable_error(is_local):
   78:     variable_name = "x"
   79:     if is_local:
   80:         msg = f"local variable '{variable_name}' is not defined"
   81:     else:
   82:         msg = f"name '{variable_name}' is not defined"
   83: 
   84:     with pytest.raises(UndefinedVariableError, match=msg):
   85:         raise UndefinedVariableError(variable_name, is_local)
   86: 
   87: 
   88: class Foo:
   89:     @classmethod
   90:     def classmethod(cls):
   91:         raise AbstractMethodError(cls, methodtype="classmethod")
   92: 
   93:     @property
   94:     def property(self):
   95:         raise AbstractMethodError(self, methodtype="property")
   96: 
   97:     def method(self):
   98:         raise AbstractMethodError(self)
   99: 
  100: 
  101: def test_AbstractMethodError_classmethod():
  102:     xpr = "This classmethod must be defined in the concrete class Foo"
  103:     with pytest.raises(AbstractMethodError, match=xpr):
  104:         Foo.classmethod()
  105: 
  106:     xpr = "This property must be defined in the concrete class Foo"
  107:     with pytest.raises(AbstractMethodError, match=xpr):
  108:         Foo().property
  109: 
  110:     xpr = "This method must be defined in the concrete class Foo"
  111:     with pytest.raises(AbstractMethodError, match=xpr):
  112:         Foo().method()
