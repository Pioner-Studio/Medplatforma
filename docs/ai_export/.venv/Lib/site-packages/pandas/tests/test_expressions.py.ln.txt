    1: import operator
    2: import re
    3: 
    4: import numpy as np
    5: import pytest
    6: 
    7: from pandas import option_context
    8: import pandas._testing as tm
    9: from pandas.core.api import (
   10:     DataFrame,
   11:     Index,
   12:     Series,
   13: )
   14: from pandas.core.computation import expressions as expr
   15: 
   16: 
   17: @pytest.fixture
   18: def _frame():
   19:     return DataFrame(
   20:         np.random.default_rng(2).standard_normal((10001, 4)),
   21:         columns=list("ABCD"),
   22:         dtype="float64",
   23:     )
   24: 
   25: 
   26: @pytest.fixture
   27: def _frame2():
   28:     return DataFrame(
   29:         np.random.default_rng(2).standard_normal((100, 4)),
   30:         columns=list("ABCD"),
   31:         dtype="float64",
   32:     )
   33: 
   34: 
   35: @pytest.fixture
   36: def _mixed(_frame):
   37:     return DataFrame(
   38:         {
   39:             "A": _frame["A"].copy(),
   40:             "B": _frame["B"].astype("float32"),
   41:             "C": _frame["C"].astype("int64"),
   42:             "D": _frame["D"].astype("int32"),
   43:         }
   44:     )
   45: 
   46: 
   47: @pytest.fixture
   48: def _mixed2(_frame2):
   49:     return DataFrame(
   50:         {
   51:             "A": _frame2["A"].copy(),
   52:             "B": _frame2["B"].astype("float32"),
   53:             "C": _frame2["C"].astype("int64"),
   54:             "D": _frame2["D"].astype("int32"),
   55:         }
   56:     )
   57: 
   58: 
   59: @pytest.fixture
   60: def _integer():
   61:     return DataFrame(
   62:         np.random.default_rng(2).integers(1, 100, size=(10001, 4)),
   63:         columns=list("ABCD"),
   64:         dtype="int64",
   65:     )
   66: 
   67: 
   68: @pytest.fixture
   69: def _integer_integers(_integer):
   70:     # integers to get a case with zeros
   71:     return _integer * np.random.default_rng(2).integers(0, 2, size=np.shape(_integer))
   72: 
   73: 
   74: @pytest.fixture
   75: def _integer2():
   76:     return DataFrame(
   77:         np.random.default_rng(2).integers(1, 100, size=(101, 4)),
   78:         columns=list("ABCD"),
   79:         dtype="int64",
   80:     )
   81: 
   82: 
   83: @pytest.fixture
   84: def _array(_frame):
   85:     return _frame["A"].values.copy()
   86: 
   87: 
   88: @pytest.fixture
   89: def _array2(_frame2):
   90:     return _frame2["A"].values.copy()
   91: 
   92: 
   93: @pytest.fixture
   94: def _array_mixed(_mixed):
   95:     return _mixed["D"].values.copy()
   96: 
   97: 
   98: @pytest.fixture
   99: def _array_mixed2(_mixed2):
  100:     return _mixed2["D"].values.copy()
  101: 
  102: 
  103: @pytest.mark.skipif(not expr.USE_NUMEXPR, reason="not using numexpr")
  104: class TestExpressions:
  105:     @staticmethod
  106:     def call_op(df, other, flex: bool, opname: str):
  107:         if flex:
  108:             op = lambda x, y: getattr(x, opname)(y)
  109:             op.__name__ = opname
  110:         else:
  111:             op = getattr(operator, opname)
  112: 
  113:         with option_context("compute.use_numexpr", False):
  114:             expected = op(df, other)
  115: 
  116:         expr.get_test_result()
  117: 
  118:         result = op(df, other)
  119:         return result, expected
  120: 
  121:     @pytest.mark.parametrize(
  122:         "fixture",
  123:         [
  124:             "_integer",
  125:             "_integer2",
  126:             "_integer_integers",
  127:             "_frame",
  128:             "_frame2",
  129:             "_mixed",
  130:             "_mixed2",
  131:         ],
  132:     )
  133:     @pytest.mark.parametrize("flex", [True, False])
  134:     @pytest.mark.parametrize(
  135:         "arith", ["add", "sub", "mul", "mod", "truediv", "floordiv"]
  136:     )
  137:     def test_run_arithmetic(self, request, fixture, flex, arith, monkeypatch):
  138:         df = request.getfixturevalue(fixture)
  139:         with monkeypatch.context() as m:
  140:             m.setattr(expr, "_MIN_ELEMENTS", 0)
  141:             result, expected = self.call_op(df, df, flex, arith)
  142: 
  143:             if arith == "truediv":
  144:                 assert all(x.kind == "f" for x in expected.dtypes.values)
  145:             tm.assert_equal(expected, result)
  146: 
  147:             for i in range(len(df.columns)):
  148:                 result, expected = self.call_op(
  149:                     df.iloc[:, i], df.iloc[:, i], flex, arith
  150:                 )
  151:                 if arith == "truediv":
  152:                     assert expected.dtype.kind == "f"
  153:                 tm.assert_equal(expected, result)
  154: 
  155:     @pytest.mark.parametrize(
  156:         "fixture",
  157:         [
  158:             "_integer",
  159:             "_integer2",
  160:             "_integer_integers",
  161:             "_frame",
  162:             "_frame2",
  163:             "_mixed",
  164:             "_mixed2",
  165:         ],
  166:     )
  167:     @pytest.mark.parametrize("flex", [True, False])
  168:     def test_run_binary(self, request, fixture, flex, comparison_op, monkeypatch):
  169:         """
  170:         tests solely that the result is the same whether or not numexpr is
  171:         enabled.  Need to test whether the function does the correct thing
  172:         elsewhere.
  173:         """
  174:         df = request.getfixturevalue(fixture)
  175:         arith = comparison_op.__name__
  176:         with option_context("compute.use_numexpr", False):
  177:             other = df.copy() + 1
  178: 
  179:         with monkeypatch.context() as m:
  180:             m.setattr(expr, "_MIN_ELEMENTS", 0)
  181:             expr.set_test_mode(True)
  182: 
  183:             result, expected = self.call_op(df, other, flex, arith)
  184: 
  185:             used_numexpr = expr.get_test_result()
  186:             assert used_numexpr, "Did not use numexpr as expected."
  187:             tm.assert_equal(expected, result)
  188: 
  189:             for i in range(len(df.columns)):
  190:                 binary_comp = other.iloc[:, i] + 1
  191:                 self.call_op(df.iloc[:, i], binary_comp, flex, "add")
  192: 
  193:     def test_invalid(self):
  194:         array = np.random.default_rng(2).standard_normal(1_000_001)
  195:         array2 = np.random.default_rng(2).standard_normal(100)
  196: 
  197:         # no op
  198:         result = expr._can_use_numexpr(operator.add, None, array, array, "evaluate")
  199:         assert not result
  200: 
  201:         # min elements
  202:         result = expr._can_use_numexpr(operator.add, "+", array2, array2, "evaluate")
  203:         assert not result
  204: 
  205:         # ok, we only check on first part of expression
  206:         result = expr._can_use_numexpr(operator.add, "+", array, array2, "evaluate")
  207:         assert result
  208: 
  209:     @pytest.mark.filterwarnings("ignore:invalid value encountered in:RuntimeWarning")
  210:     @pytest.mark.parametrize(
  211:         "opname,op_str",
  212:         [("add", "+"), ("sub", "-"), ("mul", "*"), ("truediv", "/"), ("pow", "**")],
  213:     )
  214:     @pytest.mark.parametrize(
  215:         "left_fix,right_fix", [("_array", "_array2"), ("_array_mixed", "_array_mixed2")]
  216:     )
  217:     def test_binary_ops(self, request, opname, op_str, left_fix, right_fix):
  218:         left = request.getfixturevalue(left_fix)
  219:         right = request.getfixturevalue(right_fix)
  220: 
  221:         def testit(left, right, opname, op_str):
  222:             if opname == "pow":
  223:                 left = np.abs(left)
  224: 
  225:             op = getattr(operator, opname)
  226: 
  227:             # array has 0s
  228:             result = expr.evaluate(op, left, left, use_numexpr=True)
  229:             expected = expr.evaluate(op, left, left, use_numexpr=False)
  230:             tm.assert_numpy_array_equal(result, expected)
  231: 
  232:             result = expr._can_use_numexpr(op, op_str, right, right, "evaluate")
  233:             assert not result
  234: 
  235:         with option_context("compute.use_numexpr", False):
  236:             testit(left, right, opname, op_str)
  237: 
  238:         expr.set_numexpr_threads(1)
  239:         testit(left, right, opname, op_str)
  240:         expr.set_numexpr_threads()
  241:         testit(left, right, opname, op_str)
  242: 
  243:     @pytest.mark.parametrize(
  244:         "left_fix,right_fix", [("_array", "_array2"), ("_array_mixed", "_array_mixed2")]
  245:     )
  246:     def test_comparison_ops(self, request, comparison_op, left_fix, right_fix):
  247:         left = request.getfixturevalue(left_fix)
  248:         right = request.getfixturevalue(right_fix)
  249: 
  250:         def testit():
  251:             f12 = left + 1
  252:             f22 = right + 1
  253: 
  254:             op = comparison_op
  255: 
  256:             result = expr.evaluate(op, left, f12, use_numexpr=True)
  257:             expected = expr.evaluate(op, left, f12, use_numexpr=False)
  258:             tm.assert_numpy_array_equal(result, expected)
  259: 
  260:             result = expr._can_use_numexpr(op, op, right, f22, "evaluate")
  261:             assert not result
  262: 
  263:         with option_context("compute.use_numexpr", False):
  264:             testit()
  265: 
  266:         expr.set_numexpr_threads(1)
  267:         testit()
  268:         expr.set_numexpr_threads()
  269:         testit()
  270: 
  271:     @pytest.mark.parametrize("cond", [True, False])
  272:     @pytest.mark.parametrize("fixture", ["_frame", "_frame2", "_mixed", "_mixed2"])
  273:     def test_where(self, request, cond, fixture):
  274:         df = request.getfixturevalue(fixture)
  275: 
  276:         def testit():
  277:             c = np.empty(df.shape, dtype=np.bool_)
  278:             c.fill(cond)
  279:             result = expr.where(c, df.values, df.values + 1)
  280:             expected = np.where(c, df.values, df.values + 1)
  281:             tm.assert_numpy_array_equal(result, expected)
  282: 
  283:         with option_context("compute.use_numexpr", False):
  284:             testit()
  285: 
  286:         expr.set_numexpr_threads(1)
  287:         testit()
  288:         expr.set_numexpr_threads()
  289:         testit()
  290: 
  291:     @pytest.mark.parametrize(
  292:         "op_str,opname", [("/", "truediv"), ("//", "floordiv"), ("**", "pow")]
  293:     )
  294:     def test_bool_ops_raise_on_arithmetic(self, op_str, opname):
  295:         df = DataFrame(
  296:             {
  297:                 "a": np.random.default_rng(2).random(10) > 0.5,
  298:                 "b": np.random.default_rng(2).random(10) > 0.5,
  299:             }
  300:         )
  301: 
  302:         msg = f"operator '{opname}' not implemented for bool dtypes"
  303:         f = getattr(operator, opname)
  304:         err_msg = re.escape(msg)
  305: 
  306:         with pytest.raises(NotImplementedError, match=err_msg):
  307:             f(df, df)
  308: 
  309:         with pytest.raises(NotImplementedError, match=err_msg):
  310:             f(df.a, df.b)
  311: 
  312:         with pytest.raises(NotImplementedError, match=err_msg):
  313:             f(df.a, True)
  314: 
  315:         with pytest.raises(NotImplementedError, match=err_msg):
  316:             f(False, df.a)
  317: 
  318:         with pytest.raises(NotImplementedError, match=err_msg):
  319:             f(False, df)
  320: 
  321:         with pytest.raises(NotImplementedError, match=err_msg):
  322:             f(df, True)
  323: 
  324:     @pytest.mark.parametrize(
  325:         "op_str,opname", [("+", "add"), ("*", "mul"), ("-", "sub")]
  326:     )
  327:     def test_bool_ops_warn_on_arithmetic(self, op_str, opname):
  328:         n = 10
  329:         df = DataFrame(
  330:             {
  331:                 "a": np.random.default_rng(2).random(n) > 0.5,
  332:                 "b": np.random.default_rng(2).random(n) > 0.5,
  333:             }
  334:         )
  335: 
  336:         subs = {"+": "|", "*": "&", "-": "^"}
  337:         sub_funcs = {"|": "or_", "&": "and_", "^": "xor"}
  338: 
  339:         f = getattr(operator, opname)
  340:         fe = getattr(operator, sub_funcs[subs[op_str]])
  341: 
  342:         if op_str == "-":
  343:             # raises TypeError
  344:             return
  345: 
  346:         with tm.use_numexpr(True, min_elements=5):
  347:             with tm.assert_produces_warning():
  348:                 r = f(df, df)
  349:                 e = fe(df, df)
  350:                 tm.assert_frame_equal(r, e)
  351: 
  352:             with tm.assert_produces_warning():
  353:                 r = f(df.a, df.b)
  354:                 e = fe(df.a, df.b)
  355:                 tm.assert_series_equal(r, e)
  356: 
  357:             with tm.assert_produces_warning():
  358:                 r = f(df.a, True)
  359:                 e = fe(df.a, True)
  360:                 tm.assert_series_equal(r, e)
  361: 
  362:             with tm.assert_produces_warning():
  363:                 r = f(False, df.a)
  364:                 e = fe(False, df.a)
  365:                 tm.assert_series_equal(r, e)
  366: 
  367:             with tm.assert_produces_warning():
  368:                 r = f(False, df)
  369:                 e = fe(False, df)
  370:                 tm.assert_frame_equal(r, e)
  371: 
  372:             with tm.assert_produces_warning():
  373:                 r = f(df, True)
  374:                 e = fe(df, True)
  375:                 tm.assert_frame_equal(r, e)
  376: 
  377:     @pytest.mark.parametrize(
  378:         "test_input,expected",
  379:         [
  380:             (
  381:                 DataFrame(
  382:                     [[0, 1, 2, "aa"], [0, 1, 2, "aa"]], columns=["a", "b", "c", "dtype"]
  383:                 ),
  384:                 DataFrame([[False, False], [False, False]], columns=["a", "dtype"]),
  385:             ),
  386:             (
  387:                 DataFrame(
  388:                     [[0, 3, 2, "aa"], [0, 4, 2, "aa"], [0, 1, 1, "bb"]],
  389:                     columns=["a", "b", "c", "dtype"],
  390:                 ),
  391:                 DataFrame(
  392:                     [[False, False], [False, False], [False, False]],
  393:                     columns=["a", "dtype"],
  394:                 ),
  395:             ),
  396:         ],
  397:     )
  398:     def test_bool_ops_column_name_dtype(self, test_input, expected):
  399:         # GH 22383 - .ne fails if columns containing column name 'dtype'
  400:         result = test_input.loc[:, ["a", "dtype"]].ne(test_input.loc[:, ["a", "dtype"]])
  401:         tm.assert_frame_equal(result, expected)
  402: 
  403:     @pytest.mark.parametrize(
  404:         "arith", ("add", "sub", "mul", "mod", "truediv", "floordiv")
  405:     )
  406:     @pytest.mark.parametrize("axis", (0, 1))
  407:     def test_frame_series_axis(self, axis, arith, _frame, monkeypatch):
  408:         # GH#26736 Dataframe.floordiv(Series, axis=1) fails
  409: 
  410:         df = _frame
  411:         if axis == 1:
  412:             other = df.iloc[0, :]
  413:         else:
  414:             other = df.iloc[:, 0]
  415: 
  416:         with monkeypatch.context() as m:
  417:             m.setattr(expr, "_MIN_ELEMENTS", 0)
  418: 
  419:             op_func = getattr(df, arith)
  420: 
  421:             with option_context("compute.use_numexpr", False):
  422:                 expected = op_func(other, axis=axis)
  423: 
  424:             result = op_func(other, axis=axis)
  425:             tm.assert_frame_equal(expected, result)
  426: 
  427:     @pytest.mark.parametrize(
  428:         "op",
  429:         [
  430:             "__mod__",
  431:             "__rmod__",
  432:             "__floordiv__",
  433:             "__rfloordiv__",
  434:         ],
  435:     )
  436:     @pytest.mark.parametrize("box", [DataFrame, Series, Index])
  437:     @pytest.mark.parametrize("scalar", [-5, 5])
  438:     def test_python_semantics_with_numexpr_installed(
  439:         self, op, box, scalar, monkeypatch
  440:     ):
  441:         # https://github.com/pandas-dev/pandas/issues/36047
  442:         with monkeypatch.context() as m:
  443:             m.setattr(expr, "_MIN_ELEMENTS", 0)
  444:             data = np.arange(-50, 50)
  445:             obj = box(data)
  446:             method = getattr(obj, op)
  447:             result = method(scalar)
  448: 
  449:             # compare result with numpy
  450:             with option_context("compute.use_numexpr", False):
  451:                 expected = method(scalar)
  452: 
  453:             tm.assert_equal(result, expected)
  454: 
  455:             # compare result element-wise with Python
  456:             for i, elem in enumerate(data):
  457:                 if box == DataFrame:
  458:                     scalar_result = result.iloc[i, 0]
  459:                 else:
  460:                     scalar_result = result[i]
  461:                 try:
  462:                     expected = getattr(int(elem), op)(scalar)
  463:                 except ZeroDivisionError:
  464:                     pass
  465:                 else:
  466:                     assert scalar_result == expected
