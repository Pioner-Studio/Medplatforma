    1: import sys
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: from pandas._config import using_pyarrow_string_dtype
    7: 
    8: from pandas.compat import PYPY
    9: 
   10: from pandas.core.dtypes.common import (
   11:     is_dtype_equal,
   12:     is_object_dtype,
   13: )
   14: 
   15: import pandas as pd
   16: from pandas import (
   17:     Index,
   18:     Series,
   19: )
   20: import pandas._testing as tm
   21: 
   22: 
   23: def test_isnull_notnull_docstrings():
   24:     # GH#41855 make sure its clear these are aliases
   25:     doc = pd.DataFrame.notnull.__doc__
   26:     assert doc.startswith("\nDataFrame.notnull is an alias for DataFrame.notna.\n")
   27:     doc = pd.DataFrame.isnull.__doc__
   28:     assert doc.startswith("\nDataFrame.isnull is an alias for DataFrame.isna.\n")
   29: 
   30:     doc = Series.notnull.__doc__
   31:     assert doc.startswith("\nSeries.notnull is an alias for Series.notna.\n")
   32:     doc = Series.isnull.__doc__
   33:     assert doc.startswith("\nSeries.isnull is an alias for Series.isna.\n")
   34: 
   35: 
   36: @pytest.mark.parametrize(
   37:     "op_name, op",
   38:     [
   39:         ("add", "+"),
   40:         ("sub", "-"),
   41:         ("mul", "*"),
   42:         ("mod", "%"),
   43:         ("pow", "**"),
   44:         ("truediv", "/"),
   45:         ("floordiv", "//"),
   46:     ],
   47: )
   48: def test_binary_ops_docstring(frame_or_series, op_name, op):
   49:     # not using the all_arithmetic_functions fixture with _get_opstr
   50:     # as _get_opstr is used internally in the dynamic implementation of the docstring
   51:     klass = frame_or_series
   52: 
   53:     operand1 = klass.__name__.lower()
   54:     operand2 = "other"
   55:     expected_str = " ".join([operand1, op, operand2])
   56:     assert expected_str in getattr(klass, op_name).__doc__
   57: 
   58:     # reverse version of the binary ops
   59:     expected_str = " ".join([operand2, op, operand1])
   60:     assert expected_str in getattr(klass, "r" + op_name).__doc__
   61: 
   62: 
   63: def test_ndarray_compat_properties(index_or_series_obj):
   64:     obj = index_or_series_obj
   65: 
   66:     # Check that we work.
   67:     for p in ["shape", "dtype", "T", "nbytes"]:
   68:         assert getattr(obj, p, None) is not None
   69: 
   70:     # deprecated properties
   71:     for p in ["strides", "itemsize", "base", "data"]:
   72:         assert not hasattr(obj, p)
   73: 
   74:     msg = "can only convert an array of size 1 to a Python scalar"
   75:     with pytest.raises(ValueError, match=msg):
   76:         obj.item()  # len > 1
   77: 
   78:     assert obj.ndim == 1
   79:     assert obj.size == len(obj)
   80: 
   81:     assert Index([1]).item() == 1
   82:     assert Series([1]).item() == 1
   83: 
   84: 
   85: @pytest.mark.skipif(
   86:     PYPY or using_pyarrow_string_dtype(),
   87:     reason="not relevant for PyPy doesn't work properly for arrow strings",
   88: )
   89: def test_memory_usage(index_or_series_memory_obj):
   90:     obj = index_or_series_memory_obj
   91:     # Clear index caches so that len(obj) == 0 report 0 memory usage
   92:     if isinstance(obj, Series):
   93:         is_ser = True
   94:         obj.index._engine.clear_mapping()
   95:     else:
   96:         is_ser = False
   97:         obj._engine.clear_mapping()
   98: 
   99:     res = obj.memory_usage()
  100:     res_deep = obj.memory_usage(deep=True)
  101: 
  102:     is_object = is_object_dtype(obj) or (is_ser and is_object_dtype(obj.index))
  103:     is_categorical = isinstance(obj.dtype, pd.CategoricalDtype) or (
  104:         is_ser and isinstance(obj.index.dtype, pd.CategoricalDtype)
  105:     )
  106:     is_object_string = is_dtype_equal(obj, "string[python]") or (
  107:         is_ser and is_dtype_equal(obj.index.dtype, "string[python]")
  108:     )
  109: 
  110:     if len(obj) == 0:
  111:         expected = 0
  112:         assert res_deep == res == expected
  113:     elif is_object or is_categorical or is_object_string:
  114:         # only deep will pick them up
  115:         assert res_deep > res
  116:     else:
  117:         assert res == res_deep
  118: 
  119:     # sys.getsizeof will call the .memory_usage with
  120:     # deep=True, and add on some GC overhead
  121:     diff = res_deep - sys.getsizeof(obj)
  122:     assert abs(diff) < 100
  123: 
  124: 
  125: def test_memory_usage_components_series(series_with_simple_index):
  126:     series = series_with_simple_index
  127:     total_usage = series.memory_usage(index=True)
  128:     non_index_usage = series.memory_usage(index=False)
  129:     index_usage = series.index.memory_usage()
  130:     assert total_usage == non_index_usage + index_usage
  131: 
  132: 
  133: @pytest.mark.parametrize("dtype", tm.NARROW_NP_DTYPES)
  134: def test_memory_usage_components_narrow_series(dtype):
  135:     series = Series(range(5), dtype=dtype, index=[f"i-{i}" for i in range(5)], name="a")
  136:     total_usage = series.memory_usage(index=True)
  137:     non_index_usage = series.memory_usage(index=False)
  138:     index_usage = series.index.memory_usage()
  139:     assert total_usage == non_index_usage + index_usage
  140: 
  141: 
  142: def test_searchsorted(request, index_or_series_obj):
  143:     # numpy.searchsorted calls obj.searchsorted under the hood.
  144:     # See gh-12238
  145:     obj = index_or_series_obj
  146: 
  147:     if isinstance(obj, pd.MultiIndex):
  148:         # See gh-14833
  149:         request.applymarker(
  150:             pytest.mark.xfail(
  151:                 reason="np.searchsorted doesn't work on pd.MultiIndex: GH 14833"
  152:             )
  153:         )
  154:     elif obj.dtype.kind == "c" and isinstance(obj, Index):
  155:         # TODO: Should Series cases also raise? Looks like they use numpy
  156:         #  comparison semantics https://github.com/numpy/numpy/issues/15981
  157:         mark = pytest.mark.xfail(reason="complex objects are not comparable")
  158:         request.applymarker(mark)
  159: 
  160:     max_obj = max(obj, default=0)
  161:     index = np.searchsorted(obj, max_obj)
  162:     assert 0 <= index <= len(obj)
  163: 
  164:     index = np.searchsorted(obj, max_obj, sorter=range(len(obj)))
  165:     assert 0 <= index <= len(obj)
  166: 
  167: 
  168: def test_access_by_position(index_flat):
  169:     index = index_flat
  170: 
  171:     if len(index) == 0:
  172:         pytest.skip("Test doesn't make sense on empty data")
  173: 
  174:     series = Series(index)
  175:     assert index[0] == series.iloc[0]
  176:     assert index[5] == series.iloc[5]
  177:     assert index[-1] == series.iloc[-1]
  178: 
  179:     size = len(index)
  180:     assert index[-1] == index[size - 1]
  181: 
  182:     msg = f"index {size} is out of bounds for axis 0 with size {size}"
  183:     if is_dtype_equal(index.dtype, "string[pyarrow]") or is_dtype_equal(
  184:         index.dtype, "string[pyarrow_numpy]"
  185:     ):
  186:         msg = "index out of bounds"
  187:     with pytest.raises(IndexError, match=msg):
  188:         index[size]
  189:     msg = "single positional indexer is out-of-bounds"
  190:     with pytest.raises(IndexError, match=msg):
  191:         series.iloc[size]
