    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas.core.dtypes.dtypes import DatetimeTZDtype
    5: 
    6: import pandas as pd
    7: from pandas import (
    8:     CategoricalIndex,
    9:     Series,
   10:     Timedelta,
   11:     Timestamp,
   12:     date_range,
   13: )
   14: import pandas._testing as tm
   15: from pandas.core.arrays import (
   16:     DatetimeArray,
   17:     IntervalArray,
   18:     NumpyExtensionArray,
   19:     PeriodArray,
   20:     SparseArray,
   21:     TimedeltaArray,
   22: )
   23: from pandas.core.arrays.string_arrow import ArrowStringArrayNumpySemantics
   24: 
   25: 
   26: class TestToIterable:
   27:     # test that we convert an iterable to python types
   28: 
   29:     dtypes = [
   30:         ("int8", int),
   31:         ("int16", int),
   32:         ("int32", int),
   33:         ("int64", int),
   34:         ("uint8", int),
   35:         ("uint16", int),
   36:         ("uint32", int),
   37:         ("uint64", int),
   38:         ("float16", float),
   39:         ("float32", float),
   40:         ("float64", float),
   41:         ("datetime64[ns]", Timestamp),
   42:         ("datetime64[ns, US/Eastern]", Timestamp),
   43:         ("timedelta64[ns]", Timedelta),
   44:     ]
   45: 
   46:     @pytest.mark.parametrize("dtype, rdtype", dtypes)
   47:     @pytest.mark.parametrize(
   48:         "method",
   49:         [
   50:             lambda x: x.tolist(),
   51:             lambda x: x.to_list(),
   52:             lambda x: list(x),
   53:             lambda x: list(x.__iter__()),
   54:         ],
   55:         ids=["tolist", "to_list", "list", "iter"],
   56:     )
   57:     def test_iterable(self, index_or_series, method, dtype, rdtype):
   58:         # gh-10904
   59:         # gh-13258
   60:         # coerce iteration to underlying python / pandas types
   61:         typ = index_or_series
   62:         if dtype == "float16" and issubclass(typ, pd.Index):
   63:             with pytest.raises(NotImplementedError, match="float16 indexes are not "):
   64:                 typ([1], dtype=dtype)
   65:             return
   66:         s = typ([1], dtype=dtype)
   67:         result = method(s)[0]
   68:         assert isinstance(result, rdtype)
   69: 
   70:     @pytest.mark.parametrize(
   71:         "dtype, rdtype, obj",
   72:         [
   73:             ("object", object, "a"),
   74:             ("object", int, 1),
   75:             ("category", object, "a"),
   76:             ("category", int, 1),
   77:         ],
   78:     )
   79:     @pytest.mark.parametrize(
   80:         "method",
   81:         [
   82:             lambda x: x.tolist(),
   83:             lambda x: x.to_list(),
   84:             lambda x: list(x),
   85:             lambda x: list(x.__iter__()),
   86:         ],
   87:         ids=["tolist", "to_list", "list", "iter"],
   88:     )
   89:     def test_iterable_object_and_category(
   90:         self, index_or_series, method, dtype, rdtype, obj
   91:     ):
   92:         # gh-10904
   93:         # gh-13258
   94:         # coerce iteration to underlying python / pandas types
   95:         typ = index_or_series
   96:         s = typ([obj], dtype=dtype)
   97:         result = method(s)[0]
   98:         assert isinstance(result, rdtype)
   99: 
  100:     @pytest.mark.parametrize("dtype, rdtype", dtypes)
  101:     def test_iterable_items(self, dtype, rdtype):
  102:         # gh-13258
  103:         # test if items yields the correct boxed scalars
  104:         # this only applies to series
  105:         s = Series([1], dtype=dtype)
  106:         _, result = next(iter(s.items()))
  107:         assert isinstance(result, rdtype)
  108: 
  109:         _, result = next(iter(s.items()))
  110:         assert isinstance(result, rdtype)
  111: 
  112:     @pytest.mark.parametrize(
  113:         "dtype, rdtype", dtypes + [("object", int), ("category", int)]
  114:     )
  115:     def test_iterable_map(self, index_or_series, dtype, rdtype):
  116:         # gh-13236
  117:         # coerce iteration to underlying python / pandas types
  118:         typ = index_or_series
  119:         if dtype == "float16" and issubclass(typ, pd.Index):
  120:             with pytest.raises(NotImplementedError, match="float16 indexes are not "):
  121:                 typ([1], dtype=dtype)
  122:             return
  123:         s = typ([1], dtype=dtype)
  124:         result = s.map(type)[0]
  125:         if not isinstance(rdtype, tuple):
  126:             rdtype = (rdtype,)
  127:         assert result in rdtype
  128: 
  129:     @pytest.mark.parametrize(
  130:         "method",
  131:         [
  132:             lambda x: x.tolist(),
  133:             lambda x: x.to_list(),
  134:             lambda x: list(x),
  135:             lambda x: list(x.__iter__()),
  136:         ],
  137:         ids=["tolist", "to_list", "list", "iter"],
  138:     )
  139:     def test_categorial_datetimelike(self, method):
  140:         i = CategoricalIndex([Timestamp("1999-12-31"), Timestamp("2000-12-31")])
  141: 
  142:         result = method(i)[0]
  143:         assert isinstance(result, Timestamp)
  144: 
  145:     def test_iter_box_dt64(self, unit):
  146:         vals = [Timestamp("2011-01-01"), Timestamp("2011-01-02")]
  147:         ser = Series(vals).dt.as_unit(unit)
  148:         assert ser.dtype == f"datetime64[{unit}]"
  149:         for res, exp in zip(ser, vals):
  150:             assert isinstance(res, Timestamp)
  151:             assert res.tz is None
  152:             assert res == exp
  153:             assert res.unit == unit
  154: 
  155:     def test_iter_box_dt64tz(self, unit):
  156:         vals = [
  157:             Timestamp("2011-01-01", tz="US/Eastern"),
  158:             Timestamp("2011-01-02", tz="US/Eastern"),
  159:         ]
  160:         ser = Series(vals).dt.as_unit(unit)
  161: 
  162:         assert ser.dtype == f"datetime64[{unit}, US/Eastern]"
  163:         for res, exp in zip(ser, vals):
  164:             assert isinstance(res, Timestamp)
  165:             assert res.tz == exp.tz
  166:             assert res == exp
  167:             assert res.unit == unit
  168: 
  169:     def test_iter_box_timedelta64(self, unit):
  170:         # timedelta
  171:         vals = [Timedelta("1 days"), Timedelta("2 days")]
  172:         ser = Series(vals).dt.as_unit(unit)
  173:         assert ser.dtype == f"timedelta64[{unit}]"
  174:         for res, exp in zip(ser, vals):
  175:             assert isinstance(res, Timedelta)
  176:             assert res == exp
  177:             assert res.unit == unit
  178: 
  179:     def test_iter_box_period(self):
  180:         # period
  181:         vals = [pd.Period("2011-01-01", freq="M"), pd.Period("2011-01-02", freq="M")]
  182:         s = Series(vals)
  183:         assert s.dtype == "Period[M]"
  184:         for res, exp in zip(s, vals):
  185:             assert isinstance(res, pd.Period)
  186:             assert res.freq == "ME"
  187:             assert res == exp
  188: 
  189: 
  190: @pytest.mark.parametrize(
  191:     "arr, expected_type, dtype",
  192:     [
  193:         (np.array([0, 1], dtype=np.int64), np.ndarray, "int64"),
  194:         (np.array(["a", "b"]), np.ndarray, "object"),
  195:         (pd.Categorical(["a", "b"]), pd.Categorical, "category"),
  196:         (
  197:             pd.DatetimeIndex(["2017", "2018"], tz="US/Central"),
  198:             DatetimeArray,
  199:             "datetime64[ns, US/Central]",
  200:         ),
  201:         (
  202:             pd.PeriodIndex([2018, 2019], freq="Y"),
  203:             PeriodArray,
  204:             pd.core.dtypes.dtypes.PeriodDtype("Y-DEC"),
  205:         ),
  206:         (pd.IntervalIndex.from_breaks([0, 1, 2]), IntervalArray, "interval"),
  207:         (
  208:             pd.DatetimeIndex(["2017", "2018"]),
  209:             DatetimeArray,
  210:             "datetime64[ns]",
  211:         ),
  212:         (
  213:             pd.TimedeltaIndex([10**10]),
  214:             TimedeltaArray,
  215:             "m8[ns]",
  216:         ),
  217:     ],
  218: )
  219: def test_values_consistent(arr, expected_type, dtype, using_infer_string):
  220:     if using_infer_string and dtype == "object":
  221:         expected_type = ArrowStringArrayNumpySemantics
  222:     l_values = Series(arr)._values
  223:     r_values = pd.Index(arr)._values
  224:     assert type(l_values) is expected_type
  225:     assert type(l_values) is type(r_values)
  226: 
  227:     tm.assert_equal(l_values, r_values)
  228: 
  229: 
  230: @pytest.mark.parametrize("arr", [np.array([1, 2, 3])])
  231: def test_numpy_array(arr):
  232:     ser = Series(arr)
  233:     result = ser.array
  234:     expected = NumpyExtensionArray(arr)
  235:     tm.assert_extension_array_equal(result, expected)
  236: 
  237: 
  238: def test_numpy_array_all_dtypes(any_numpy_dtype):
  239:     ser = Series(dtype=any_numpy_dtype)
  240:     result = ser.array
  241:     if np.dtype(any_numpy_dtype).kind == "M":
  242:         assert isinstance(result, DatetimeArray)
  243:     elif np.dtype(any_numpy_dtype).kind == "m":
  244:         assert isinstance(result, TimedeltaArray)
  245:     else:
  246:         assert isinstance(result, NumpyExtensionArray)
  247: 
  248: 
  249: @pytest.mark.parametrize(
  250:     "arr, attr",
  251:     [
  252:         (pd.Categorical(["a", "b"]), "_codes"),
  253:         (PeriodArray._from_sequence(["2000", "2001"], dtype="period[D]"), "_ndarray"),
  254:         (pd.array([0, np.nan], dtype="Int64"), "_data"),
  255:         (IntervalArray.from_breaks([0, 1]), "_left"),
  256:         (SparseArray([0, 1]), "_sparse_values"),
  257:         (
  258:             DatetimeArray._from_sequence(np.array([1, 2], dtype="datetime64[ns]")),
  259:             "_ndarray",
  260:         ),
  261:         # tz-aware Datetime
  262:         (
  263:             DatetimeArray._from_sequence(
  264:                 np.array(
  265:                     ["2000-01-01T12:00:00", "2000-01-02T12:00:00"], dtype="M8[ns]"
  266:                 ),
  267:                 dtype=DatetimeTZDtype(tz="US/Central"),
  268:             ),
  269:             "_ndarray",
  270:         ),
  271:     ],
  272: )
  273: def test_array(arr, attr, index_or_series, request):
  274:     box = index_or_series
  275: 
  276:     result = box(arr, copy=False).array
  277: 
  278:     if attr:
  279:         arr = getattr(arr, attr)
  280:         result = getattr(result, attr)
  281: 
  282:     assert result is arr
  283: 
  284: 
  285: def test_array_multiindex_raises():
  286:     idx = pd.MultiIndex.from_product([["A"], ["a", "b"]])
  287:     msg = "MultiIndex has no single backing array"
  288:     with pytest.raises(ValueError, match=msg):
  289:         idx.array
  290: 
  291: 
  292: @pytest.mark.parametrize(
  293:     "arr, expected",
  294:     [
  295:         (np.array([1, 2], dtype=np.int64), np.array([1, 2], dtype=np.int64)),
  296:         (pd.Categorical(["a", "b"]), np.array(["a", "b"], dtype=object)),
  297:         (
  298:             pd.core.arrays.period_array(["2000", "2001"], freq="D"),
  299:             np.array([pd.Period("2000", freq="D"), pd.Period("2001", freq="D")]),
  300:         ),
  301:         (pd.array([0, np.nan], dtype="Int64"), np.array([0, np.nan])),
  302:         (
  303:             IntervalArray.from_breaks([0, 1, 2]),
  304:             np.array([pd.Interval(0, 1), pd.Interval(1, 2)], dtype=object),
  305:         ),
  306:         (SparseArray([0, 1]), np.array([0, 1], dtype=np.int64)),
  307:         # tz-naive datetime
  308:         (
  309:             DatetimeArray._from_sequence(np.array(["2000", "2001"], dtype="M8[ns]")),
  310:             np.array(["2000", "2001"], dtype="M8[ns]"),
  311:         ),
  312:         # tz-aware stays tz`-aware
  313:         (
  314:             DatetimeArray._from_sequence(
  315:                 np.array(["2000-01-01T06:00:00", "2000-01-02T06:00:00"], dtype="M8[ns]")
  316:             )
  317:             .tz_localize("UTC")
  318:             .tz_convert("US/Central"),
  319:             np.array(
  320:                 [
  321:                     Timestamp("2000-01-01", tz="US/Central"),
  322:                     Timestamp("2000-01-02", tz="US/Central"),
  323:                 ]
  324:             ),
  325:         ),
  326:         # Timedelta
  327:         (
  328:             TimedeltaArray._from_sequence(
  329:                 np.array([0, 3600000000000], dtype="i8").view("m8[ns]")
  330:             ),
  331:             np.array([0, 3600000000000], dtype="m8[ns]"),
  332:         ),
  333:         # GH#26406 tz is preserved in Categorical[dt64tz]
  334:         (
  335:             pd.Categorical(date_range("2016-01-01", periods=2, tz="US/Pacific")),
  336:             np.array(
  337:                 [
  338:                     Timestamp("2016-01-01", tz="US/Pacific"),
  339:                     Timestamp("2016-01-02", tz="US/Pacific"),
  340:                 ]
  341:             ),
  342:         ),
  343:     ],
  344: )
  345: def test_to_numpy(arr, expected, index_or_series_or_array, request):
  346:     box = index_or_series_or_array
  347: 
  348:     with tm.assert_produces_warning(None):
  349:         thing = box(arr)
  350: 
  351:     result = thing.to_numpy()
  352:     tm.assert_numpy_array_equal(result, expected)
  353: 
  354:     result = np.asarray(thing)
  355:     tm.assert_numpy_array_equal(result, expected)
  356: 
  357: 
  358: @pytest.mark.parametrize("as_series", [True, False])
  359: @pytest.mark.parametrize(
  360:     "arr", [np.array([1, 2, 3], dtype="int64"), np.array(["a", "b", "c"], dtype=object)]
  361: )
  362: def test_to_numpy_copy(arr, as_series, using_infer_string):
  363:     obj = pd.Index(arr, copy=False)
  364:     if as_series:
  365:         obj = Series(obj.values, copy=False)
  366: 
  367:     # no copy by default
  368:     result = obj.to_numpy()
  369:     if using_infer_string and arr.dtype == object:
  370:         assert np.shares_memory(arr, result) is False
  371:     else:
  372:         assert np.shares_memory(arr, result) is True
  373: 
  374:     result = obj.to_numpy(copy=False)
  375:     if using_infer_string and arr.dtype == object:
  376:         assert np.shares_memory(arr, result) is False
  377:     else:
  378:         assert np.shares_memory(arr, result) is True
  379: 
  380:     # copy=True
  381:     result = obj.to_numpy(copy=True)
  382:     assert np.shares_memory(arr, result) is False
  383: 
  384: 
  385: @pytest.mark.parametrize("as_series", [True, False])
  386: def test_to_numpy_dtype(as_series, unit):
  387:     tz = "US/Eastern"
  388:     obj = pd.DatetimeIndex(["2000", "2001"], tz=tz)
  389:     if as_series:
  390:         obj = Series(obj)
  391: 
  392:     # preserve tz by default
  393:     result = obj.to_numpy()
  394:     expected = np.array(
  395:         [Timestamp("2000", tz=tz), Timestamp("2001", tz=tz)], dtype=object
  396:     )
  397:     tm.assert_numpy_array_equal(result, expected)
  398: 
  399:     result = obj.to_numpy(dtype="object")
  400:     tm.assert_numpy_array_equal(result, expected)
  401: 
  402:     result = obj.to_numpy(dtype="M8[ns]")
  403:     expected = np.array(["2000-01-01T05", "2001-01-01T05"], dtype="M8[ns]")
  404:     tm.assert_numpy_array_equal(result, expected)
  405: 
  406: 
  407: @pytest.mark.parametrize(
  408:     "values, dtype, na_value, expected",
  409:     [
  410:         ([1, 2, None], "float64", 0, [1.0, 2.0, 0.0]),
  411:         (
  412:             [Timestamp("2000"), Timestamp("2000"), pd.NaT],
  413:             None,
  414:             Timestamp("2000"),
  415:             [np.datetime64("2000-01-01T00:00:00.000000000")] * 3,
  416:         ),
  417:     ],
  418: )
  419: def test_to_numpy_na_value_numpy_dtype(
  420:     index_or_series, values, dtype, na_value, expected
  421: ):
  422:     obj = index_or_series(values)
  423:     result = obj.to_numpy(dtype=dtype, na_value=na_value)
  424:     expected = np.array(expected)
  425:     tm.assert_numpy_array_equal(result, expected)
  426: 
  427: 
  428: @pytest.mark.parametrize(
  429:     "data, multiindex, dtype, na_value, expected",
  430:     [
  431:         (
  432:             [1, 2, None, 4],
  433:             [(0, "a"), (0, "b"), (1, "b"), (1, "c")],
  434:             float,
  435:             None,
  436:             [1.0, 2.0, np.nan, 4.0],
  437:         ),
  438:         (
  439:             [1, 2, None, 4],
  440:             [(0, "a"), (0, "b"), (1, "b"), (1, "c")],
  441:             float,
  442:             np.nan,
  443:             [1.0, 2.0, np.nan, 4.0],
  444:         ),
  445:         (
  446:             [1.0, 2.0, np.nan, 4.0],
  447:             [("a", 0), ("a", 1), ("a", 2), ("b", 0)],
  448:             int,
  449:             0,
  450:             [1, 2, 0, 4],
  451:         ),
  452:         (
  453:             [Timestamp("2000"), Timestamp("2000"), pd.NaT],
  454:             [(0, Timestamp("2021")), (0, Timestamp("2022")), (1, Timestamp("2000"))],
  455:             None,
  456:             Timestamp("2000"),
  457:             [np.datetime64("2000-01-01T00:00:00.000000000")] * 3,
  458:         ),
  459:     ],
  460: )
  461: def test_to_numpy_multiindex_series_na_value(
  462:     data, multiindex, dtype, na_value, expected
  463: ):
  464:     index = pd.MultiIndex.from_tuples(multiindex)
  465:     series = Series(data, index=index)
  466:     result = series.to_numpy(dtype=dtype, na_value=na_value)
  467:     expected = np.array(expected)
  468:     tm.assert_numpy_array_equal(result, expected)
  469: 
  470: 
  471: def test_to_numpy_kwargs_raises():
  472:     # numpy
  473:     s = Series([1, 2, 3])
  474:     msg = r"to_numpy\(\) got an unexpected keyword argument 'foo'"
  475:     with pytest.raises(TypeError, match=msg):
  476:         s.to_numpy(foo=True)
  477: 
  478:     # extension
  479:     s = Series([1, 2, 3], dtype="Int64")
  480:     with pytest.raises(TypeError, match=msg):
  481:         s.to_numpy(foo=True)
  482: 
  483: 
  484: @pytest.mark.parametrize(
  485:     "data",
  486:     [
  487:         {"a": [1, 2, 3], "b": [1, 2, None]},
  488:         {"a": np.array([1, 2, 3]), "b": np.array([1, 2, np.nan])},
  489:         {"a": pd.array([1, 2, 3]), "b": pd.array([1, 2, None])},
  490:     ],
  491: )
  492: @pytest.mark.parametrize("dtype, na_value", [(float, np.nan), (object, None)])
  493: def test_to_numpy_dataframe_na_value(data, dtype, na_value):
  494:     # https://github.com/pandas-dev/pandas/issues/33820
  495:     df = pd.DataFrame(data)
  496:     result = df.to_numpy(dtype=dtype, na_value=na_value)
  497:     expected = np.array([[1, 1], [2, 2], [3, na_value]], dtype=dtype)
  498:     tm.assert_numpy_array_equal(result, expected)
  499: 
  500: 
  501: @pytest.mark.parametrize(
  502:     "data, expected",
  503:     [
  504:         (
  505:             {"a": pd.array([1, 2, None])},
  506:             np.array([[1.0], [2.0], [np.nan]], dtype=float),
  507:         ),
  508:         (
  509:             {"a": [1, 2, 3], "b": [1, 2, 3]},
  510:             np.array([[1, 1], [2, 2], [3, 3]], dtype=float),
  511:         ),
  512:     ],
  513: )
  514: def test_to_numpy_dataframe_single_block(data, expected):
  515:     # https://github.com/pandas-dev/pandas/issues/33820
  516:     df = pd.DataFrame(data)
  517:     result = df.to_numpy(dtype=float, na_value=np.nan)
  518:     tm.assert_numpy_array_equal(result, expected)
  519: 
  520: 
  521: def test_to_numpy_dataframe_single_block_no_mutate():
  522:     # https://github.com/pandas-dev/pandas/issues/33820
  523:     result = pd.DataFrame(np.array([1.0, 2.0, np.nan]))
  524:     expected = pd.DataFrame(np.array([1.0, 2.0, np.nan]))
  525:     result.to_numpy(na_value=0.0)
  526:     tm.assert_frame_equal(result, expected)
  527: 
  528: 
  529: class TestAsArray:
  530:     @pytest.mark.parametrize("tz", [None, "US/Central"])
  531:     def test_asarray_object_dt64(self, tz):
  532:         ser = Series(date_range("2000", periods=2, tz=tz))
  533: 
  534:         with tm.assert_produces_warning(None):
  535:             # Future behavior (for tzaware case) with no warning
  536:             result = np.asarray(ser, dtype=object)
  537: 
  538:         expected = np.array(
  539:             [Timestamp("2000-01-01", tz=tz), Timestamp("2000-01-02", tz=tz)]
  540:         )
  541:         tm.assert_numpy_array_equal(result, expected)
  542: 
  543:     def test_asarray_tz_naive(self):
  544:         # This shouldn't produce a warning.
  545:         ser = Series(date_range("2000", periods=2))
  546:         expected = np.array(["2000-01-01", "2000-01-02"], dtype="M8[ns]")
  547:         result = np.asarray(ser)
  548: 
  549:         tm.assert_numpy_array_equal(result, expected)
  550: 
  551:     def test_asarray_tz_aware(self):
  552:         tz = "US/Central"
  553:         ser = Series(date_range("2000", periods=2, tz=tz))
  554:         expected = np.array(["2000-01-01T06", "2000-01-02T06"], dtype="M8[ns]")
  555:         result = np.asarray(ser, dtype="datetime64[ns]")
  556: 
  557:         tm.assert_numpy_array_equal(result, expected)
  558: 
  559:         # Old behavior with no warning
  560:         result = np.asarray(ser, dtype="M8[ns]")
  561: 
  562:         tm.assert_numpy_array_equal(result, expected)
