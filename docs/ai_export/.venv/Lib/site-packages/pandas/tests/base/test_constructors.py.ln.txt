    1: from datetime import datetime
    2: import sys
    3: 
    4: import numpy as np
    5: import pytest
    6: 
    7: from pandas.compat import PYPY
    8: 
    9: import pandas as pd
   10: from pandas import (
   11:     DataFrame,
   12:     Index,
   13:     Series,
   14: )
   15: import pandas._testing as tm
   16: from pandas.core.accessor import PandasDelegate
   17: from pandas.core.base import (
   18:     NoNewAttributesMixin,
   19:     PandasObject,
   20: )
   21: 
   22: 
   23: def series_via_frame_from_dict(x, **kwargs):
   24:     return DataFrame({"a": x}, **kwargs)["a"]
   25: 
   26: 
   27: def series_via_frame_from_scalar(x, **kwargs):
   28:     return DataFrame(x, **kwargs)[0]
   29: 
   30: 
   31: @pytest.fixture(
   32:     params=[
   33:         Series,
   34:         series_via_frame_from_dict,
   35:         series_via_frame_from_scalar,
   36:         Index,
   37:     ],
   38:     ids=["Series", "DataFrame-dict", "DataFrame-array", "Index"],
   39: )
   40: def constructor(request):
   41:     return request.param
   42: 
   43: 
   44: class TestPandasDelegate:
   45:     class Delegator:
   46:         _properties = ["prop"]
   47:         _methods = ["test_method"]
   48: 
   49:         def _set_prop(self, value):
   50:             self.prop = value
   51: 
   52:         def _get_prop(self):
   53:             return self.prop
   54: 
   55:         prop = property(_get_prop, _set_prop, doc="foo property")
   56: 
   57:         def test_method(self, *args, **kwargs):
   58:             """a test method"""
   59: 
   60:     class Delegate(PandasDelegate, PandasObject):
   61:         def __init__(self, obj) -> None:
   62:             self.obj = obj
   63: 
   64:     def test_invalid_delegation(self):
   65:         # these show that in order for the delegation to work
   66:         # the _delegate_* methods need to be overridden to not raise
   67:         # a TypeError
   68: 
   69:         self.Delegate._add_delegate_accessors(
   70:             delegate=self.Delegator,
   71:             accessors=self.Delegator._properties,
   72:             typ="property",
   73:         )
   74:         self.Delegate._add_delegate_accessors(
   75:             delegate=self.Delegator, accessors=self.Delegator._methods, typ="method"
   76:         )
   77: 
   78:         delegate = self.Delegate(self.Delegator())
   79: 
   80:         msg = "You cannot access the property prop"
   81:         with pytest.raises(TypeError, match=msg):
   82:             delegate.prop
   83: 
   84:         msg = "The property prop cannot be set"
   85:         with pytest.raises(TypeError, match=msg):
   86:             delegate.prop = 5
   87: 
   88:         msg = "You cannot access the property prop"
   89:         with pytest.raises(TypeError, match=msg):
   90:             delegate.prop
   91: 
   92:     @pytest.mark.skipif(PYPY, reason="not relevant for PyPy")
   93:     def test_memory_usage(self):
   94:         # Delegate does not implement memory_usage.
   95:         # Check that we fall back to in-built `__sizeof__`
   96:         # GH 12924
   97:         delegate = self.Delegate(self.Delegator())
   98:         sys.getsizeof(delegate)
   99: 
  100: 
  101: class TestNoNewAttributesMixin:
  102:     def test_mixin(self):
  103:         class T(NoNewAttributesMixin):
  104:             pass
  105: 
  106:         t = T()
  107:         assert not hasattr(t, "__frozen")
  108: 
  109:         t.a = "test"
  110:         assert t.a == "test"
  111: 
  112:         t._freeze()
  113:         assert "__frozen" in dir(t)
  114:         assert getattr(t, "__frozen")
  115:         msg = "You cannot add any new attribute"
  116:         with pytest.raises(AttributeError, match=msg):
  117:             t.b = "test"
  118: 
  119:         assert not hasattr(t, "b")
  120: 
  121: 
  122: class TestConstruction:
  123:     # test certain constructor behaviours on dtype inference across Series,
  124:     # Index and DataFrame
  125: 
  126:     @pytest.mark.parametrize(
  127:         "a",
  128:         [
  129:             np.array(["2263-01-01"], dtype="datetime64[D]"),
  130:             np.array([datetime(2263, 1, 1)], dtype=object),
  131:             np.array([np.datetime64("2263-01-01", "D")], dtype=object),
  132:             np.array(["2263-01-01"], dtype=object),
  133:         ],
  134:         ids=[
  135:             "datetime64[D]",
  136:             "object-datetime.datetime",
  137:             "object-numpy-scalar",
  138:             "object-string",
  139:         ],
  140:     )
  141:     def test_constructor_datetime_outofbound(
  142:         self, a, constructor, request, using_infer_string
  143:     ):
  144:         # GH-26853 (+ bug GH-26206 out of bound non-ns unit)
  145: 
  146:         # No dtype specified (dtype inference)
  147:         # datetime64[non-ns] raise error, other cases result in object dtype
  148:         # and preserve original data
  149:         if a.dtype.kind == "M":
  150:             # Can't fit in nanosecond bounds -> get the nearest supported unit
  151:             result = constructor(a)
  152:             assert result.dtype == "M8[s]"
  153:         else:
  154:             result = constructor(a)
  155:             if using_infer_string and "object-string" in request.node.callspec.id:
  156:                 assert result.dtype == "string"
  157:             else:
  158:                 assert result.dtype == "object"
  159:             tm.assert_numpy_array_equal(result.to_numpy(), a)
  160: 
  161:         # Explicit dtype specified
  162:         # Forced conversion fails for all -> all cases raise error
  163:         msg = "Out of bounds|Out of bounds .* present at position 0"
  164:         with pytest.raises(pd.errors.OutOfBoundsDatetime, match=msg):
  165:             constructor(a, dtype="datetime64[ns]")
  166: 
  167:     def test_constructor_datetime_nonns(self, constructor):
  168:         arr = np.array(["2020-01-01T00:00:00.000000"], dtype="datetime64[us]")
  169:         dta = pd.core.arrays.DatetimeArray._simple_new(arr, dtype=arr.dtype)
  170:         expected = constructor(dta)
  171:         assert expected.dtype == arr.dtype
  172: 
  173:         result = constructor(arr)
  174:         tm.assert_equal(result, expected)
  175: 
  176:         # https://github.com/pandas-dev/pandas/issues/34843
  177:         arr.flags.writeable = False
  178:         result = constructor(arr)
  179:         tm.assert_equal(result, expected)
