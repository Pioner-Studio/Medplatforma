    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas._config import using_pyarrow_string_dtype
    5: 
    6: import pandas as pd
    7: import pandas._testing as tm
    8: from pandas.tests.base.common import allow_na_ops
    9: 
   10: 
   11: @pytest.mark.filterwarnings(r"ignore:PeriodDtype\[B\] is deprecated:FutureWarning")
   12: def test_unique(index_or_series_obj):
   13:     obj = index_or_series_obj
   14:     obj = np.repeat(obj, range(1, len(obj) + 1))
   15:     result = obj.unique()
   16: 
   17:     # dict.fromkeys preserves the order
   18:     unique_values = list(dict.fromkeys(obj.values))
   19:     if isinstance(obj, pd.MultiIndex):
   20:         expected = pd.MultiIndex.from_tuples(unique_values)
   21:         expected.names = obj.names
   22:         tm.assert_index_equal(result, expected, exact=True)
   23:     elif isinstance(obj, pd.Index):
   24:         expected = pd.Index(unique_values, dtype=obj.dtype)
   25:         if isinstance(obj.dtype, pd.DatetimeTZDtype):
   26:             expected = expected.normalize()
   27:         tm.assert_index_equal(result, expected, exact=True)
   28:     else:
   29:         expected = np.array(unique_values)
   30:         tm.assert_numpy_array_equal(result, expected)
   31: 
   32: 
   33: @pytest.mark.filterwarnings(r"ignore:PeriodDtype\[B\] is deprecated:FutureWarning")
   34: @pytest.mark.parametrize("null_obj", [np.nan, None])
   35: def test_unique_null(null_obj, index_or_series_obj):
   36:     obj = index_or_series_obj
   37: 
   38:     if not allow_na_ops(obj):
   39:         pytest.skip("type doesn't allow for NA operations")
   40:     elif len(obj) < 1:
   41:         pytest.skip("Test doesn't make sense on empty data")
   42:     elif isinstance(obj, pd.MultiIndex):
   43:         pytest.skip(f"MultiIndex can't hold '{null_obj}'")
   44: 
   45:     values = obj._values
   46:     values[0:2] = null_obj
   47: 
   48:     klass = type(obj)
   49:     repeated_values = np.repeat(values, range(1, len(values) + 1))
   50:     obj = klass(repeated_values, dtype=obj.dtype)
   51:     result = obj.unique()
   52: 
   53:     unique_values_raw = dict.fromkeys(obj.values)
   54:     # because np.nan == np.nan is False, but None == None is True
   55:     # np.nan would be duplicated, whereas None wouldn't
   56:     unique_values_not_null = [val for val in unique_values_raw if not pd.isnull(val)]
   57:     unique_values = [null_obj] + unique_values_not_null
   58: 
   59:     if isinstance(obj, pd.Index):
   60:         expected = pd.Index(unique_values, dtype=obj.dtype)
   61:         if isinstance(obj.dtype, pd.DatetimeTZDtype):
   62:             result = result.normalize()
   63:             expected = expected.normalize()
   64:         tm.assert_index_equal(result, expected, exact=True)
   65:     else:
   66:         expected = np.array(unique_values, dtype=obj.dtype)
   67:         tm.assert_numpy_array_equal(result, expected)
   68: 
   69: 
   70: def test_nunique(index_or_series_obj):
   71:     obj = index_or_series_obj
   72:     obj = np.repeat(obj, range(1, len(obj) + 1))
   73:     expected = len(obj.unique())
   74:     assert obj.nunique(dropna=False) == expected
   75: 
   76: 
   77: @pytest.mark.parametrize("null_obj", [np.nan, None])
   78: def test_nunique_null(null_obj, index_or_series_obj):
   79:     obj = index_or_series_obj
   80: 
   81:     if not allow_na_ops(obj):
   82:         pytest.skip("type doesn't allow for NA operations")
   83:     elif isinstance(obj, pd.MultiIndex):
   84:         pytest.skip(f"MultiIndex can't hold '{null_obj}'")
   85: 
   86:     values = obj._values
   87:     values[0:2] = null_obj
   88: 
   89:     klass = type(obj)
   90:     repeated_values = np.repeat(values, range(1, len(values) + 1))
   91:     obj = klass(repeated_values, dtype=obj.dtype)
   92: 
   93:     if isinstance(obj, pd.CategoricalIndex):
   94:         assert obj.nunique() == len(obj.categories)
   95:         assert obj.nunique(dropna=False) == len(obj.categories) + 1
   96:     else:
   97:         num_unique_values = len(obj.unique())
   98:         assert obj.nunique() == max(0, num_unique_values - 1)
   99:         assert obj.nunique(dropna=False) == max(0, num_unique_values)
  100: 
  101: 
  102: @pytest.mark.single_cpu
  103: @pytest.mark.xfail(using_pyarrow_string_dtype(), reason="decoding fails")
  104: def test_unique_bad_unicode(index_or_series):
  105:     # regression test for #34550
  106:     uval = "\ud83d"  # smiley emoji
  107: 
  108:     obj = index_or_series([uval] * 2)
  109:     result = obj.unique()
  110: 
  111:     if isinstance(obj, pd.Index):
  112:         expected = pd.Index(["\ud83d"], dtype=object)
  113:         tm.assert_index_equal(result, expected, exact=True)
  114:     else:
  115:         expected = np.array(["\ud83d"], dtype=object)
  116:         tm.assert_numpy_array_equal(result, expected)
  117: 
  118: 
  119: @pytest.mark.parametrize("dropna", [True, False])
  120: def test_nunique_dropna(dropna):
  121:     # GH37566
  122:     ser = pd.Series(["yes", "yes", pd.NA, np.nan, None, pd.NaT])
  123:     res = ser.nunique(dropna)
  124:     assert res == 1 if dropna else 5
