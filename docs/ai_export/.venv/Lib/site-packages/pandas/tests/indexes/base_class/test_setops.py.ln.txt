    1: from datetime import datetime
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: import pandas as pd
    7: from pandas import (
    8:     Index,
    9:     Series,
   10: )
   11: import pandas._testing as tm
   12: from pandas.core.algorithms import safe_sort
   13: 
   14: 
   15: def equal_contents(arr1, arr2) -> bool:
   16:     """
   17:     Checks if the set of unique elements of arr1 and arr2 are equivalent.
   18:     """
   19:     return frozenset(arr1) == frozenset(arr2)
   20: 
   21: 
   22: class TestIndexSetOps:
   23:     @pytest.mark.parametrize(
   24:         "method", ["union", "intersection", "difference", "symmetric_difference"]
   25:     )
   26:     def test_setops_sort_validation(self, method):
   27:         idx1 = Index(["a", "b"])
   28:         idx2 = Index(["b", "c"])
   29: 
   30:         with pytest.raises(ValueError, match="The 'sort' keyword only takes"):
   31:             getattr(idx1, method)(idx2, sort=2)
   32: 
   33:         # sort=True is supported as of GH#??
   34:         getattr(idx1, method)(idx2, sort=True)
   35: 
   36:     def test_setops_preserve_object_dtype(self):
   37:         idx = Index([1, 2, 3], dtype=object)
   38:         result = idx.intersection(idx[1:])
   39:         expected = idx[1:]
   40:         tm.assert_index_equal(result, expected)
   41: 
   42:         # if other is not monotonic increasing, intersection goes through
   43:         #  a different route
   44:         result = idx.intersection(idx[1:][::-1])
   45:         tm.assert_index_equal(result, expected)
   46: 
   47:         result = idx._union(idx[1:], sort=None)
   48:         expected = idx
   49:         tm.assert_numpy_array_equal(result, expected.values)
   50: 
   51:         result = idx.union(idx[1:], sort=None)
   52:         tm.assert_index_equal(result, expected)
   53: 
   54:         # if other is not monotonic increasing, _union goes through
   55:         #  a different route
   56:         result = idx._union(idx[1:][::-1], sort=None)
   57:         tm.assert_numpy_array_equal(result, expected.values)
   58: 
   59:         result = idx.union(idx[1:][::-1], sort=None)
   60:         tm.assert_index_equal(result, expected)
   61: 
   62:     def test_union_base(self):
   63:         index = Index([0, "a", 1, "b", 2, "c"])
   64:         first = index[3:]
   65:         second = index[:5]
   66: 
   67:         result = first.union(second)
   68: 
   69:         expected = Index([0, 1, 2, "a", "b", "c"])
   70:         tm.assert_index_equal(result, expected)
   71: 
   72:     @pytest.mark.parametrize("klass", [np.array, Series, list])
   73:     def test_union_different_type_base(self, klass):
   74:         # GH 10149
   75:         index = Index([0, "a", 1, "b", 2, "c"])
   76:         first = index[3:]
   77:         second = index[:5]
   78: 
   79:         result = first.union(klass(second.values))
   80: 
   81:         assert equal_contents(result, index)
   82: 
   83:     def test_union_sort_other_incomparable(self):
   84:         # https://github.com/pandas-dev/pandas/issues/24959
   85:         idx = Index([1, pd.Timestamp("2000")])
   86:         # default (sort=None)
   87:         with tm.assert_produces_warning(RuntimeWarning):
   88:             result = idx.union(idx[:1])
   89: 
   90:         tm.assert_index_equal(result, idx)
   91: 
   92:         # sort=None
   93:         with tm.assert_produces_warning(RuntimeWarning):
   94:             result = idx.union(idx[:1], sort=None)
   95:         tm.assert_index_equal(result, idx)
   96: 
   97:         # sort=False
   98:         result = idx.union(idx[:1], sort=False)
   99:         tm.assert_index_equal(result, idx)
  100: 
  101:     def test_union_sort_other_incomparable_true(self):
  102:         idx = Index([1, pd.Timestamp("2000")])
  103:         with pytest.raises(TypeError, match=".*"):
  104:             idx.union(idx[:1], sort=True)
  105: 
  106:     def test_intersection_equal_sort_true(self):
  107:         idx = Index(["c", "a", "b"])
  108:         sorted_ = Index(["a", "b", "c"])
  109:         tm.assert_index_equal(idx.intersection(idx, sort=True), sorted_)
  110: 
  111:     def test_intersection_base(self, sort):
  112:         # (same results for py2 and py3 but sortedness not tested elsewhere)
  113:         index = Index([0, "a", 1, "b", 2, "c"])
  114:         first = index[:5]
  115:         second = index[:3]
  116: 
  117:         expected = Index([0, 1, "a"]) if sort is None else Index([0, "a", 1])
  118:         result = first.intersection(second, sort=sort)
  119:         tm.assert_index_equal(result, expected)
  120: 
  121:     @pytest.mark.parametrize("klass", [np.array, Series, list])
  122:     def test_intersection_different_type_base(self, klass, sort):
  123:         # GH 10149
  124:         index = Index([0, "a", 1, "b", 2, "c"])
  125:         first = index[:5]
  126:         second = index[:3]
  127: 
  128:         result = first.intersection(klass(second.values), sort=sort)
  129:         assert equal_contents(result, second)
  130: 
  131:     def test_intersection_nosort(self):
  132:         result = Index(["c", "b", "a"]).intersection(["b", "a"])
  133:         expected = Index(["b", "a"])
  134:         tm.assert_index_equal(result, expected)
  135: 
  136:     def test_intersection_equal_sort(self):
  137:         idx = Index(["c", "a", "b"])
  138:         tm.assert_index_equal(idx.intersection(idx, sort=False), idx)
  139:         tm.assert_index_equal(idx.intersection(idx, sort=None), idx)
  140: 
  141:     def test_intersection_str_dates(self, sort):
  142:         dt_dates = [datetime(2012, 2, 9), datetime(2012, 2, 22)]
  143: 
  144:         i1 = Index(dt_dates, dtype=object)
  145:         i2 = Index(["aa"], dtype=object)
  146:         result = i2.intersection(i1, sort=sort)
  147: 
  148:         assert len(result) == 0
  149: 
  150:     @pytest.mark.parametrize(
  151:         "index2,expected_arr",
  152:         [(Index(["B", "D"]), ["B"]), (Index(["B", "D", "A"]), ["A", "B"])],
  153:     )
  154:     def test_intersection_non_monotonic_non_unique(self, index2, expected_arr, sort):
  155:         # non-monotonic non-unique
  156:         index1 = Index(["A", "B", "A", "C"])
  157:         expected = Index(expected_arr)
  158:         result = index1.intersection(index2, sort=sort)
  159:         if sort is None:
  160:             expected = expected.sort_values()
  161:         tm.assert_index_equal(result, expected)
  162: 
  163:     def test_difference_base(self, sort):
  164:         # (same results for py2 and py3 but sortedness not tested elsewhere)
  165:         index = Index([0, "a", 1, "b", 2, "c"])
  166:         first = index[:4]
  167:         second = index[3:]
  168: 
  169:         result = first.difference(second, sort)
  170:         expected = Index([0, "a", 1])
  171:         if sort is None:
  172:             expected = Index(safe_sort(expected))
  173:         tm.assert_index_equal(result, expected)
  174: 
  175:     def test_symmetric_difference(self):
  176:         # (same results for py2 and py3 but sortedness not tested elsewhere)
  177:         index = Index([0, "a", 1, "b", 2, "c"])
  178:         first = index[:4]
  179:         second = index[3:]
  180: 
  181:         result = first.symmetric_difference(second)
  182:         expected = Index([0, 1, 2, "a", "c"])
  183:         tm.assert_index_equal(result, expected)
  184: 
  185:     @pytest.mark.parametrize(
  186:         "method,expected,sort",
  187:         [
  188:             (
  189:                 "intersection",
  190:                 np.array(
  191:                     [(1, "A"), (2, "A"), (1, "B"), (2, "B")],
  192:                     dtype=[("num", int), ("let", "S1")],
  193:                 ),
  194:                 False,
  195:             ),
  196:             (
  197:                 "intersection",
  198:                 np.array(
  199:                     [(1, "A"), (1, "B"), (2, "A"), (2, "B")],
  200:                     dtype=[("num", int), ("let", "S1")],
  201:                 ),
  202:                 None,
  203:             ),
  204:             (
  205:                 "union",
  206:                 np.array(
  207:                     [(1, "A"), (1, "B"), (1, "C"), (2, "A"), (2, "B"), (2, "C")],
  208:                     dtype=[("num", int), ("let", "S1")],
  209:                 ),
  210:                 None,
  211:             ),
  212:         ],
  213:     )
  214:     def test_tuple_union_bug(self, method, expected, sort):
  215:         index1 = Index(
  216:             np.array(
  217:                 [(1, "A"), (2, "A"), (1, "B"), (2, "B")],
  218:                 dtype=[("num", int), ("let", "S1")],
  219:             )
  220:         )
  221:         index2 = Index(
  222:             np.array(
  223:                 [(1, "A"), (2, "A"), (1, "B"), (2, "B"), (1, "C"), (2, "C")],
  224:                 dtype=[("num", int), ("let", "S1")],
  225:             )
  226:         )
  227: 
  228:         result = getattr(index1, method)(index2, sort=sort)
  229:         assert result.ndim == 1
  230: 
  231:         expected = Index(expected)
  232:         tm.assert_index_equal(result, expected)
  233: 
  234:     @pytest.mark.parametrize("first_list", [["b", "a"], []])
  235:     @pytest.mark.parametrize("second_list", [["a", "b"], []])
  236:     @pytest.mark.parametrize(
  237:         "first_name, second_name, expected_name",
  238:         [("A", "B", None), (None, "B", None), ("A", None, None)],
  239:     )
  240:     def test_union_name_preservation(
  241:         self, first_list, second_list, first_name, second_name, expected_name, sort
  242:     ):
  243:         first = Index(first_list, name=first_name)
  244:         second = Index(second_list, name=second_name)
  245:         union = first.union(second, sort=sort)
  246: 
  247:         vals = set(first_list).union(second_list)
  248: 
  249:         if sort is None and len(first_list) > 0 and len(second_list) > 0:
  250:             expected = Index(sorted(vals), name=expected_name)
  251:             tm.assert_index_equal(union, expected)
  252:         else:
  253:             expected = Index(vals, name=expected_name)
  254:             tm.assert_index_equal(union.sort_values(), expected.sort_values())
  255: 
  256:     @pytest.mark.parametrize(
  257:         "diff_type, expected",
  258:         [["difference", [1, "B"]], ["symmetric_difference", [1, 2, "B", "C"]]],
  259:     )
  260:     def test_difference_object_type(self, diff_type, expected):
  261:         # GH 13432
  262:         idx1 = Index([0, 1, "A", "B"])
  263:         idx2 = Index([0, 2, "A", "C"])
  264:         result = getattr(idx1, diff_type)(idx2)
  265:         expected = Index(expected)
  266:         tm.assert_index_equal(result, expected)
