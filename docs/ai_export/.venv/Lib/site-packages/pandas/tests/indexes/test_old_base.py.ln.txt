    1: from __future__ import annotations
    2: 
    3: from datetime import datetime
    4: import weakref
    5: 
    6: import numpy as np
    7: import pytest
    8: 
    9: from pandas._config import using_pyarrow_string_dtype
   10: 
   11: from pandas._libs.tslibs import Timestamp
   12: 
   13: from pandas.core.dtypes.common import (
   14:     is_integer_dtype,
   15:     is_numeric_dtype,
   16: )
   17: from pandas.core.dtypes.dtypes import CategoricalDtype
   18: 
   19: import pandas as pd
   20: from pandas import (
   21:     CategoricalIndex,
   22:     DatetimeIndex,
   23:     DatetimeTZDtype,
   24:     Index,
   25:     IntervalIndex,
   26:     MultiIndex,
   27:     PeriodIndex,
   28:     RangeIndex,
   29:     Series,
   30:     TimedeltaIndex,
   31:     isna,
   32:     period_range,
   33: )
   34: import pandas._testing as tm
   35: import pandas.core.algorithms as algos
   36: from pandas.core.arrays import BaseMaskedArray
   37: 
   38: 
   39: class TestBase:
   40:     @pytest.fixture(
   41:         params=[
   42:             RangeIndex(start=0, stop=20, step=2),
   43:             Index(np.arange(5, dtype=np.float64)),
   44:             Index(np.arange(5, dtype=np.float32)),
   45:             Index(np.arange(5, dtype=np.uint64)),
   46:             Index(range(0, 20, 2), dtype=np.int64),
   47:             Index(range(0, 20, 2), dtype=np.int32),
   48:             Index(range(0, 20, 2), dtype=np.int16),
   49:             Index(range(0, 20, 2), dtype=np.int8),
   50:             Index(list("abcde")),
   51:             Index([0, "a", 1, "b", 2, "c"]),
   52:             period_range("20130101", periods=5, freq="D"),
   53:             TimedeltaIndex(
   54:                 [
   55:                     "0 days 01:00:00",
   56:                     "1 days 01:00:00",
   57:                     "2 days 01:00:00",
   58:                     "3 days 01:00:00",
   59:                     "4 days 01:00:00",
   60:                 ],
   61:                 dtype="timedelta64[ns]",
   62:                 freq="D",
   63:             ),
   64:             DatetimeIndex(
   65:                 ["2013-01-01", "2013-01-02", "2013-01-03", "2013-01-04", "2013-01-05"],
   66:                 dtype="datetime64[ns]",
   67:                 freq="D",
   68:             ),
   69:             IntervalIndex.from_breaks(range(11), closed="right"),
   70:         ]
   71:     )
   72:     def simple_index(self, request):
   73:         return request.param
   74: 
   75:     def test_pickle_compat_construction(self, simple_index):
   76:         # need an object to create with
   77:         if isinstance(simple_index, RangeIndex):
   78:             pytest.skip("RangeIndex() is a valid constructor")
   79:         msg = "|".join(
   80:             [
   81:                 r"Index\(\.\.\.\) must be called with a collection of some "
   82:                 r"kind, None was passed",
   83:                 r"DatetimeIndex\(\) must be called with a collection of some "
   84:                 r"kind, None was passed",
   85:                 r"TimedeltaIndex\(\) must be called with a collection of some "
   86:                 r"kind, None was passed",
   87:                 r"__new__\(\) missing 1 required positional argument: 'data'",
   88:                 r"__new__\(\) takes at least 2 arguments \(1 given\)",
   89:             ]
   90:         )
   91:         with pytest.raises(TypeError, match=msg):
   92:             type(simple_index)()
   93: 
   94:     def test_shift(self, simple_index):
   95:         # GH8083 test the base class for shift
   96:         if isinstance(simple_index, (DatetimeIndex, TimedeltaIndex, PeriodIndex)):
   97:             pytest.skip("Tested in test_ops/test_arithmetic")
   98:         idx = simple_index
   99:         msg = (
  100:             f"This method is only implemented for DatetimeIndex, PeriodIndex and "
  101:             f"TimedeltaIndex; Got type {type(idx).__name__}"
  102:         )
  103:         with pytest.raises(NotImplementedError, match=msg):
  104:             idx.shift(1)
  105:         with pytest.raises(NotImplementedError, match=msg):
  106:             idx.shift(1, 2)
  107: 
  108:     def test_constructor_name_unhashable(self, simple_index):
  109:         # GH#29069 check that name is hashable
  110:         # See also same-named test in tests.series.test_constructors
  111:         idx = simple_index
  112:         with pytest.raises(TypeError, match="Index.name must be a hashable type"):
  113:             type(idx)(idx, name=[])
  114: 
  115:     def test_create_index_existing_name(self, simple_index):
  116:         # GH11193, when an existing index is passed, and a new name is not
  117:         # specified, the new index should inherit the previous object name
  118:         expected = simple_index.copy()
  119:         if not isinstance(expected, MultiIndex):
  120:             expected.name = "foo"
  121:             result = Index(expected)
  122:             tm.assert_index_equal(result, expected)
  123: 
  124:             result = Index(expected, name="bar")
  125:             expected.name = "bar"
  126:             tm.assert_index_equal(result, expected)
  127:         else:
  128:             expected.names = ["foo", "bar"]
  129:             result = Index(expected)
  130:             tm.assert_index_equal(
  131:                 result,
  132:                 Index(
  133:                     Index(
  134:                         [
  135:                             ("foo", "one"),
  136:                             ("foo", "two"),
  137:                             ("bar", "one"),
  138:                             ("baz", "two"),
  139:                             ("qux", "one"),
  140:                             ("qux", "two"),
  141:                         ],
  142:                         dtype="object",
  143:                     ),
  144:                     names=["foo", "bar"],
  145:                 ),
  146:             )
  147: 
  148:             result = Index(expected, names=["A", "B"])
  149:             tm.assert_index_equal(
  150:                 result,
  151:                 Index(
  152:                     Index(
  153:                         [
  154:                             ("foo", "one"),
  155:                             ("foo", "two"),
  156:                             ("bar", "one"),
  157:                             ("baz", "two"),
  158:                             ("qux", "one"),
  159:                             ("qux", "two"),
  160:                         ],
  161:                         dtype="object",
  162:                     ),
  163:                     names=["A", "B"],
  164:                 ),
  165:             )
  166: 
  167:     def test_numeric_compat(self, simple_index):
  168:         idx = simple_index
  169:         # Check that this doesn't cover MultiIndex case, if/when it does,
  170:         #  we can remove multi.test_compat.test_numeric_compat
  171:         assert not isinstance(idx, MultiIndex)
  172:         if type(idx) is Index:
  173:             pytest.skip("Not applicable for Index")
  174:         if is_numeric_dtype(simple_index.dtype) or isinstance(
  175:             simple_index, TimedeltaIndex
  176:         ):
  177:             pytest.skip("Tested elsewhere.")
  178: 
  179:         typ = type(idx._data).__name__
  180:         cls = type(idx).__name__
  181:         lmsg = "|".join(
  182:             [
  183:                 rf"unsupported operand type\(s\) for \*: '{typ}' and 'int'",
  184:                 "cannot perform (__mul__|__truediv__|__floordiv__) with "
  185:                 f"this index type: ({cls}|{typ})",
  186:             ]
  187:         )
  188:         with pytest.raises(TypeError, match=lmsg):
  189:             idx * 1
  190:         rmsg = "|".join(
  191:             [
  192:                 rf"unsupported operand type\(s\) for \*: 'int' and '{typ}'",
  193:                 "cannot perform (__rmul__|__rtruediv__|__rfloordiv__) with "
  194:                 f"this index type: ({cls}|{typ})",
  195:             ]
  196:         )
  197:         with pytest.raises(TypeError, match=rmsg):
  198:             1 * idx
  199: 
  200:         div_err = lmsg.replace("*", "/")
  201:         with pytest.raises(TypeError, match=div_err):
  202:             idx / 1
  203:         div_err = rmsg.replace("*", "/")
  204:         with pytest.raises(TypeError, match=div_err):
  205:             1 / idx
  206: 
  207:         floordiv_err = lmsg.replace("*", "//")
  208:         with pytest.raises(TypeError, match=floordiv_err):
  209:             idx // 1
  210:         floordiv_err = rmsg.replace("*", "//")
  211:         with pytest.raises(TypeError, match=floordiv_err):
  212:             1 // idx
  213: 
  214:     def test_logical_compat(self, simple_index):
  215:         if simple_index.dtype in (object, "string"):
  216:             pytest.skip("Tested elsewhere.")
  217:         idx = simple_index
  218:         if idx.dtype.kind in "iufcbm":
  219:             assert idx.all() == idx._values.all()
  220:             assert idx.all() == idx.to_series().all()
  221:             assert idx.any() == idx._values.any()
  222:             assert idx.any() == idx.to_series().any()
  223:         else:
  224:             msg = "cannot perform (any|all)"
  225:             if isinstance(idx, IntervalIndex):
  226:                 msg = (
  227:                     r"'IntervalArray' with dtype interval\[.*\] does "
  228:                     "not support reduction '(any|all)'"
  229:                 )
  230:             with pytest.raises(TypeError, match=msg):
  231:                 idx.all()
  232:             with pytest.raises(TypeError, match=msg):
  233:                 idx.any()
  234: 
  235:     def test_repr_roundtrip(self, simple_index):
  236:         if isinstance(simple_index, IntervalIndex):
  237:             pytest.skip(f"Not a valid repr for {type(simple_index).__name__}")
  238:         idx = simple_index
  239:         tm.assert_index_equal(eval(repr(idx)), idx)
  240: 
  241:     def test_repr_max_seq_item_setting(self, simple_index):
  242:         # GH10182
  243:         if isinstance(simple_index, IntervalIndex):
  244:             pytest.skip(f"Not a valid repr for {type(simple_index).__name__}")
  245:         idx = simple_index
  246:         idx = idx.repeat(50)
  247:         with pd.option_context("display.max_seq_items", None):
  248:             repr(idx)
  249:             assert "..." not in str(idx)
  250: 
  251:     @pytest.mark.filterwarnings(r"ignore:PeriodDtype\[B\] is deprecated:FutureWarning")
  252:     def test_ensure_copied_data(self, index):
  253:         # Check the "copy" argument of each Index.__new__ is honoured
  254:         # GH12309
  255:         init_kwargs = {}
  256:         if isinstance(index, PeriodIndex):
  257:             # Needs "freq" specification:
  258:             init_kwargs["freq"] = index.freq
  259:         elif isinstance(index, (RangeIndex, MultiIndex, CategoricalIndex)):
  260:             pytest.skip(
  261:                 "RangeIndex cannot be initialized from data, "
  262:                 "MultiIndex and CategoricalIndex are tested separately"
  263:             )
  264:         elif index.dtype == object and index.inferred_type == "boolean":
  265:             init_kwargs["dtype"] = index.dtype
  266: 
  267:         index_type = type(index)
  268:         result = index_type(index.values, copy=True, **init_kwargs)
  269:         if isinstance(index.dtype, DatetimeTZDtype):
  270:             result = result.tz_localize("UTC").tz_convert(index.tz)
  271:         if isinstance(index, (DatetimeIndex, TimedeltaIndex)):
  272:             index = index._with_freq(None)
  273: 
  274:         tm.assert_index_equal(index, result)
  275: 
  276:         if isinstance(index, PeriodIndex):
  277:             # .values an object array of Period, thus copied
  278:             depr_msg = "The 'ordinal' keyword in PeriodIndex is deprecated"
  279:             with tm.assert_produces_warning(FutureWarning, match=depr_msg):
  280:                 result = index_type(ordinal=index.asi8, copy=False, **init_kwargs)
  281:             tm.assert_numpy_array_equal(index.asi8, result.asi8, check_same="same")
  282:         elif isinstance(index, IntervalIndex):
  283:             # checked in test_interval.py
  284:             pass
  285:         elif type(index) is Index and not isinstance(index.dtype, np.dtype):
  286:             result = index_type(index.values, copy=False, **init_kwargs)
  287:             tm.assert_index_equal(result, index)
  288: 
  289:             if isinstance(index._values, BaseMaskedArray):
  290:                 assert np.shares_memory(index._values._data, result._values._data)
  291:                 tm.assert_numpy_array_equal(
  292:                     index._values._data, result._values._data, check_same="same"
  293:                 )
  294:                 assert np.shares_memory(index._values._mask, result._values._mask)
  295:                 tm.assert_numpy_array_equal(
  296:                     index._values._mask, result._values._mask, check_same="same"
  297:                 )
  298:             elif index.dtype == "string[python]":
  299:                 assert np.shares_memory(index._values._ndarray, result._values._ndarray)
  300:                 tm.assert_numpy_array_equal(
  301:                     index._values._ndarray, result._values._ndarray, check_same="same"
  302:                 )
  303:             elif index.dtype in ("string[pyarrow]", "string[pyarrow_numpy]"):
  304:                 assert tm.shares_memory(result._values, index._values)
  305:             else:
  306:                 raise NotImplementedError(index.dtype)
  307:         else:
  308:             result = index_type(index.values, copy=False, **init_kwargs)
  309:             tm.assert_numpy_array_equal(index.values, result.values, check_same="same")
  310: 
  311:     def test_memory_usage(self, index):
  312:         index._engine.clear_mapping()
  313:         result = index.memory_usage()
  314:         if index.empty:
  315:             # we report 0 for no-length
  316:             assert result == 0
  317:             return
  318: 
  319:         # non-zero length
  320:         index.get_loc(index[0])
  321:         result2 = index.memory_usage()
  322:         result3 = index.memory_usage(deep=True)
  323: 
  324:         # RangeIndex, IntervalIndex
  325:         # don't have engines
  326:         # Index[EA] has engine but it does not have a Hashtable .mapping
  327:         if not isinstance(index, (RangeIndex, IntervalIndex)) and not (
  328:             type(index) is Index and not isinstance(index.dtype, np.dtype)
  329:         ):
  330:             assert result2 > result
  331: 
  332:         if index.inferred_type == "object":
  333:             assert result3 > result2
  334: 
  335:     def test_argsort(self, index):
  336:         if isinstance(index, CategoricalIndex):
  337:             pytest.skip(f"{type(self).__name__} separately tested")
  338: 
  339:         result = index.argsort()
  340:         expected = np.array(index).argsort()
  341:         tm.assert_numpy_array_equal(result, expected, check_dtype=False)
  342: 
  343:     def test_numpy_argsort(self, index):
  344:         result = np.argsort(index)
  345:         expected = index.argsort()
  346:         tm.assert_numpy_array_equal(result, expected)
  347: 
  348:         result = np.argsort(index, kind="mergesort")
  349:         expected = index.argsort(kind="mergesort")
  350:         tm.assert_numpy_array_equal(result, expected)
  351: 
  352:         # these are the only two types that perform
  353:         # pandas compatibility input validation - the
  354:         # rest already perform separate (or no) such
  355:         # validation via their 'values' attribute as
  356:         # defined in pandas.core.indexes/base.py - they
  357:         # cannot be changed at the moment due to
  358:         # backwards compatibility concerns
  359:         if isinstance(index, (CategoricalIndex, RangeIndex)):
  360:             msg = "the 'axis' parameter is not supported"
  361:             with pytest.raises(ValueError, match=msg):
  362:                 np.argsort(index, axis=1)
  363: 
  364:             msg = "the 'order' parameter is not supported"
  365:             with pytest.raises(ValueError, match=msg):
  366:                 np.argsort(index, order=("a", "b"))
  367: 
  368:     def test_repeat(self, simple_index):
  369:         rep = 2
  370:         idx = simple_index.copy()
  371:         new_index_cls = idx._constructor
  372:         expected = new_index_cls(idx.values.repeat(rep), name=idx.name)
  373:         tm.assert_index_equal(idx.repeat(rep), expected)
  374: 
  375:         idx = simple_index
  376:         rep = np.arange(len(idx))
  377:         expected = new_index_cls(idx.values.repeat(rep), name=idx.name)
  378:         tm.assert_index_equal(idx.repeat(rep), expected)
  379: 
  380:     def test_numpy_repeat(self, simple_index):
  381:         rep = 2
  382:         idx = simple_index
  383:         expected = idx.repeat(rep)
  384:         tm.assert_index_equal(np.repeat(idx, rep), expected)
  385: 
  386:         msg = "the 'axis' parameter is not supported"
  387:         with pytest.raises(ValueError, match=msg):
  388:             np.repeat(idx, rep, axis=0)
  389: 
  390:     def test_where(self, listlike_box, simple_index):
  391:         if isinstance(simple_index, (IntervalIndex, PeriodIndex)) or is_numeric_dtype(
  392:             simple_index.dtype
  393:         ):
  394:             pytest.skip("Tested elsewhere.")
  395:         klass = listlike_box
  396: 
  397:         idx = simple_index
  398:         if isinstance(idx, (DatetimeIndex, TimedeltaIndex)):
  399:             # where does not preserve freq
  400:             idx = idx._with_freq(None)
  401: 
  402:         cond = [True] * len(idx)
  403:         result = idx.where(klass(cond))
  404:         expected = idx
  405:         tm.assert_index_equal(result, expected)
  406: 
  407:         cond = [False] + [True] * len(idx[1:])
  408:         expected = Index([idx._na_value] + idx[1:].tolist(), dtype=idx.dtype)
  409:         result = idx.where(klass(cond))
  410:         tm.assert_index_equal(result, expected)
  411: 
  412:     def test_insert_base(self, index):
  413:         trimmed = index[1:4]
  414: 
  415:         if not len(index):
  416:             pytest.skip("Not applicable for empty index")
  417: 
  418:         # test 0th element
  419:         warn = None
  420:         if index.dtype == object and index.inferred_type == "boolean":
  421:             # GH#51363
  422:             warn = FutureWarning
  423:         msg = "The behavior of Index.insert with object-dtype is deprecated"
  424:         with tm.assert_produces_warning(warn, match=msg):
  425:             result = trimmed.insert(0, index[0])
  426:         assert index[0:4].equals(result)
  427: 
  428:     @pytest.mark.skipif(
  429:         using_pyarrow_string_dtype(),
  430:         reason="completely different behavior, tested elsewher",
  431:     )
  432:     def test_insert_out_of_bounds(self, index):
  433:         # TypeError/IndexError matches what np.insert raises in these cases
  434: 
  435:         if len(index) > 0:
  436:             err = TypeError
  437:         else:
  438:             err = IndexError
  439:         if len(index) == 0:
  440:             # 0 vs 0.5 in error message varies with numpy version
  441:             msg = "index (0|0.5) is out of bounds for axis 0 with size 0"
  442:         else:
  443:             msg = "slice indices must be integers or None or have an __index__ method"
  444:         with pytest.raises(err, match=msg):
  445:             index.insert(0.5, "foo")
  446: 
  447:         msg = "|".join(
  448:             [
  449:                 r"index -?\d+ is out of bounds for axis 0 with size \d+",
  450:                 "loc must be an integer between",
  451:             ]
  452:         )
  453:         with pytest.raises(IndexError, match=msg):
  454:             index.insert(len(index) + 1, 1)
  455: 
  456:         with pytest.raises(IndexError, match=msg):
  457:             index.insert(-len(index) - 1, 1)
  458: 
  459:     def test_delete_base(self, index):
  460:         if not len(index):
  461:             pytest.skip("Not applicable for empty index")
  462: 
  463:         if isinstance(index, RangeIndex):
  464:             # tested in class
  465:             pytest.skip(f"{type(self).__name__} tested elsewhere")
  466: 
  467:         expected = index[1:]
  468:         result = index.delete(0)
  469:         assert result.equals(expected)
  470:         assert result.name == expected.name
  471: 
  472:         expected = index[:-1]
  473:         result = index.delete(-1)
  474:         assert result.equals(expected)
  475:         assert result.name == expected.name
  476: 
  477:         length = len(index)
  478:         msg = f"index {length} is out of bounds for axis 0 with size {length}"
  479:         with pytest.raises(IndexError, match=msg):
  480:             index.delete(length)
  481: 
  482:     @pytest.mark.filterwarnings(r"ignore:PeriodDtype\[B\] is deprecated:FutureWarning")
  483:     def test_equals(self, index):
  484:         if isinstance(index, IntervalIndex):
  485:             pytest.skip(f"{type(index).__name__} tested elsewhere")
  486: 
  487:         is_ea_idx = type(index) is Index and not isinstance(index.dtype, np.dtype)
  488: 
  489:         assert index.equals(index)
  490:         assert index.equals(index.copy())
  491:         if not is_ea_idx:
  492:             # doesn't hold for e.g. IntegerDtype
  493:             assert index.equals(index.astype(object))
  494: 
  495:         assert not index.equals(list(index))
  496:         assert not index.equals(np.array(index))
  497: 
  498:         # Cannot pass in non-int64 dtype to RangeIndex
  499:         if not isinstance(index, RangeIndex) and not is_ea_idx:
  500:             same_values = Index(index, dtype=object)
  501:             assert index.equals(same_values)
  502:             assert same_values.equals(index)
  503: 
  504:         if index.nlevels == 1:
  505:             # do not test MultiIndex
  506:             assert not index.equals(Series(index))
  507: 
  508:     def test_equals_op(self, simple_index):
  509:         # GH9947, GH10637
  510:         index_a = simple_index
  511: 
  512:         n = len(index_a)
  513:         index_b = index_a[0:-1]
  514:         index_c = index_a[0:-1].append(index_a[-2:-1])
  515:         index_d = index_a[0:1]
  516: 
  517:         msg = "Lengths must match|could not be broadcast"
  518:         with pytest.raises(ValueError, match=msg):
  519:             index_a == index_b
  520:         expected1 = np.array([True] * n)
  521:         expected2 = np.array([True] * (n - 1) + [False])
  522:         tm.assert_numpy_array_equal(index_a == index_a, expected1)
  523:         tm.assert_numpy_array_equal(index_a == index_c, expected2)
  524: 
  525:         # test comparisons with numpy arrays
  526:         array_a = np.array(index_a)
  527:         array_b = np.array(index_a[0:-1])
  528:         array_c = np.array(index_a[0:-1].append(index_a[-2:-1]))
  529:         array_d = np.array(index_a[0:1])
  530:         with pytest.raises(ValueError, match=msg):
  531:             index_a == array_b
  532:         tm.assert_numpy_array_equal(index_a == array_a, expected1)
  533:         tm.assert_numpy_array_equal(index_a == array_c, expected2)
  534: 
  535:         # test comparisons with Series
  536:         series_a = Series(array_a)
  537:         series_b = Series(array_b)
  538:         series_c = Series(array_c)
  539:         series_d = Series(array_d)
  540:         with pytest.raises(ValueError, match=msg):
  541:             index_a == series_b
  542: 
  543:         tm.assert_numpy_array_equal(index_a == series_a, expected1)
  544:         tm.assert_numpy_array_equal(index_a == series_c, expected2)
  545: 
  546:         # cases where length is 1 for one of them
  547:         with pytest.raises(ValueError, match="Lengths must match"):
  548:             index_a == index_d
  549:         with pytest.raises(ValueError, match="Lengths must match"):
  550:             index_a == series_d
  551:         with pytest.raises(ValueError, match="Lengths must match"):
  552:             index_a == array_d
  553:         msg = "Can only compare identically-labeled Series objects"
  554:         with pytest.raises(ValueError, match=msg):
  555:             series_a == series_d
  556:         with pytest.raises(ValueError, match="Lengths must match"):
  557:             series_a == array_d
  558: 
  559:         # comparing with a scalar should broadcast; note that we are excluding
  560:         # MultiIndex because in this case each item in the index is a tuple of
  561:         # length 2, and therefore is considered an array of length 2 in the
  562:         # comparison instead of a scalar
  563:         if not isinstance(index_a, MultiIndex):
  564:             expected3 = np.array([False] * (len(index_a) - 2) + [True, False])
  565:             # assuming the 2nd to last item is unique in the data
  566:             item = index_a[-2]
  567:             tm.assert_numpy_array_equal(index_a == item, expected3)
  568:             tm.assert_series_equal(series_a == item, Series(expected3))
  569: 
  570:     def test_format(self, simple_index):
  571:         # GH35439
  572:         if is_numeric_dtype(simple_index.dtype) or isinstance(
  573:             simple_index, DatetimeIndex
  574:         ):
  575:             pytest.skip("Tested elsewhere.")
  576:         idx = simple_index
  577:         expected = [str(x) for x in idx]
  578:         msg = r"Index\.format is deprecated"
  579:         with tm.assert_produces_warning(FutureWarning, match=msg):
  580:             assert idx.format() == expected
  581: 
  582:     def test_format_empty(self, simple_index):
  583:         # GH35712
  584:         if isinstance(simple_index, (PeriodIndex, RangeIndex)):
  585:             pytest.skip("Tested elsewhere")
  586:         empty_idx = type(simple_index)([])
  587:         msg = r"Index\.format is deprecated"
  588:         with tm.assert_produces_warning(FutureWarning, match=msg):
  589:             assert empty_idx.format() == []
  590:         with tm.assert_produces_warning(FutureWarning, match=msg):
  591:             assert empty_idx.format(name=True) == [""]
  592: 
  593:     def test_fillna(self, index):
  594:         # GH 11343
  595:         if len(index) == 0:
  596:             pytest.skip("Not relevant for empty index")
  597:         elif index.dtype == bool:
  598:             pytest.skip(f"{index.dtype} cannot hold NAs")
  599:         elif isinstance(index, Index) and is_integer_dtype(index.dtype):
  600:             pytest.skip(f"Not relevant for Index with {index.dtype}")
  601:         elif isinstance(index, MultiIndex):
  602:             idx = index.copy(deep=True)
  603:             msg = "isna is not defined for MultiIndex"
  604:             with pytest.raises(NotImplementedError, match=msg):
  605:                 idx.fillna(idx[0])
  606:         else:
  607:             idx = index.copy(deep=True)
  608:             result = idx.fillna(idx[0])
  609:             tm.assert_index_equal(result, idx)
  610:             assert result is not idx
  611: 
  612:             msg = "'value' must be a scalar, passed: "
  613:             with pytest.raises(TypeError, match=msg):
  614:                 idx.fillna([idx[0]])
  615: 
  616:             idx = index.copy(deep=True)
  617:             values = idx._values
  618: 
  619:             values[1] = np.nan
  620: 
  621:             idx = type(index)(values)
  622: 
  623:             msg = "does not support 'downcast'"
  624:             msg2 = r"The 'downcast' keyword in .*Index\.fillna is deprecated"
  625:             with tm.assert_produces_warning(FutureWarning, match=msg2):
  626:                 with pytest.raises(NotImplementedError, match=msg):
  627:                     # For now at least, we only raise if there are NAs present
  628:                     idx.fillna(idx[0], downcast="infer")
  629: 
  630:             expected = np.array([False] * len(idx), dtype=bool)
  631:             expected[1] = True
  632:             tm.assert_numpy_array_equal(idx._isnan, expected)
  633:             assert idx.hasnans is True
  634: 
  635:     def test_nulls(self, index):
  636:         # this is really a smoke test for the methods
  637:         # as these are adequately tested for function elsewhere
  638:         if len(index) == 0:
  639:             tm.assert_numpy_array_equal(index.isna(), np.array([], dtype=bool))
  640:         elif isinstance(index, MultiIndex):
  641:             idx = index.copy()
  642:             msg = "isna is not defined for MultiIndex"
  643:             with pytest.raises(NotImplementedError, match=msg):
  644:                 idx.isna()
  645:         elif not index.hasnans:
  646:             tm.assert_numpy_array_equal(index.isna(), np.zeros(len(index), dtype=bool))
  647:             tm.assert_numpy_array_equal(index.notna(), np.ones(len(index), dtype=bool))
  648:         else:
  649:             result = isna(index)
  650:             tm.assert_numpy_array_equal(index.isna(), result)
  651:             tm.assert_numpy_array_equal(index.notna(), ~result)
  652: 
  653:     def test_empty(self, simple_index):
  654:         # GH 15270
  655:         idx = simple_index
  656:         assert not idx.empty
  657:         assert idx[:0].empty
  658: 
  659:     def test_join_self_unique(self, join_type, simple_index):
  660:         idx = simple_index
  661:         if idx.is_unique:
  662:             joined = idx.join(idx, how=join_type)
  663:             expected = simple_index
  664:             if join_type == "outer":
  665:                 expected = algos.safe_sort(expected)
  666:             tm.assert_index_equal(joined, expected)
  667: 
  668:     def test_map(self, simple_index):
  669:         # callable
  670:         if isinstance(simple_index, (TimedeltaIndex, PeriodIndex)):
  671:             pytest.skip("Tested elsewhere.")
  672:         idx = simple_index
  673: 
  674:         result = idx.map(lambda x: x)
  675:         # RangeIndex are equivalent to the similar Index with int64 dtype
  676:         tm.assert_index_equal(result, idx, exact="equiv")
  677: 
  678:     @pytest.mark.parametrize(
  679:         "mapper",
  680:         [
  681:             lambda values, index: {i: e for e, i in zip(values, index)},
  682:             lambda values, index: Series(values, index),
  683:         ],
  684:     )
  685:     @pytest.mark.filterwarnings(r"ignore:PeriodDtype\[B\] is deprecated:FutureWarning")
  686:     def test_map_dictlike(self, mapper, simple_index, request):
  687:         idx = simple_index
  688:         if isinstance(idx, (DatetimeIndex, TimedeltaIndex, PeriodIndex)):
  689:             pytest.skip("Tested elsewhere.")
  690: 
  691:         identity = mapper(idx.values, idx)
  692: 
  693:         result = idx.map(identity)
  694:         # RangeIndex are equivalent to the similar Index with int64 dtype
  695:         tm.assert_index_equal(result, idx, exact="equiv")
  696: 
  697:         # empty mappable
  698:         dtype = None
  699:         if idx.dtype.kind == "f":
  700:             dtype = idx.dtype
  701: 
  702:         expected = Index([np.nan] * len(idx), dtype=dtype)
  703:         result = idx.map(mapper(expected, idx))
  704:         tm.assert_index_equal(result, expected)
  705: 
  706:     def test_map_str(self, simple_index):
  707:         # GH 31202
  708:         if isinstance(simple_index, CategoricalIndex):
  709:             pytest.skip("See test_map.py")
  710:         idx = simple_index
  711:         result = idx.map(str)
  712:         expected = Index([str(x) for x in idx])
  713:         tm.assert_index_equal(result, expected)
  714: 
  715:     @pytest.mark.parametrize("copy", [True, False])
  716:     @pytest.mark.parametrize("name", [None, "foo"])
  717:     @pytest.mark.parametrize("ordered", [True, False])
  718:     def test_astype_category(self, copy, name, ordered, simple_index):
  719:         # GH 18630
  720:         idx = simple_index
  721:         if name:
  722:             idx = idx.rename(name)
  723: 
  724:         # standard categories
  725:         dtype = CategoricalDtype(ordered=ordered)
  726:         result = idx.astype(dtype, copy=copy)
  727:         expected = CategoricalIndex(idx, name=name, ordered=ordered)
  728:         tm.assert_index_equal(result, expected, exact=True)
  729: 
  730:         # non-standard categories
  731:         dtype = CategoricalDtype(idx.unique().tolist()[:-1], ordered)
  732:         result = idx.astype(dtype, copy=copy)
  733:         expected = CategoricalIndex(idx, name=name, dtype=dtype)
  734:         tm.assert_index_equal(result, expected, exact=True)
  735: 
  736:         if ordered is False:
  737:             # dtype='category' defaults to ordered=False, so only test once
  738:             result = idx.astype("category", copy=copy)
  739:             expected = CategoricalIndex(idx, name=name)
  740:             tm.assert_index_equal(result, expected, exact=True)
  741: 
  742:     def test_is_unique(self, simple_index):
  743:         # initialize a unique index
  744:         index = simple_index.drop_duplicates()
  745:         assert index.is_unique is True
  746: 
  747:         # empty index should be unique
  748:         index_empty = index[:0]
  749:         assert index_empty.is_unique is True
  750: 
  751:         # test basic dupes
  752:         index_dup = index.insert(0, index[0])
  753:         assert index_dup.is_unique is False
  754: 
  755:         # single NA should be unique
  756:         index_na = index.insert(0, np.nan)
  757:         assert index_na.is_unique is True
  758: 
  759:         # multiple NA should not be unique
  760:         index_na_dup = index_na.insert(0, np.nan)
  761:         assert index_na_dup.is_unique is False
  762: 
  763:     @pytest.mark.arm_slow
  764:     def test_engine_reference_cycle(self, simple_index):
  765:         # GH27585
  766:         index = simple_index.copy()
  767:         ref = weakref.ref(index)
  768:         index._engine
  769:         del index
  770:         assert ref() is None
  771: 
  772:     def test_getitem_2d_deprecated(self, simple_index):
  773:         # GH#30588, GH#31479
  774:         if isinstance(simple_index, IntervalIndex):
  775:             pytest.skip("Tested elsewhere")
  776:         idx = simple_index
  777:         msg = "Multi-dimensional indexing|too many|only"
  778:         with pytest.raises((ValueError, IndexError), match=msg):
  779:             idx[:, None]
  780: 
  781:         if not isinstance(idx, RangeIndex):
  782:             # GH#44051 RangeIndex already raised pre-2.0 with a different message
  783:             with pytest.raises((ValueError, IndexError), match=msg):
  784:                 idx[True]
  785:             with pytest.raises((ValueError, IndexError), match=msg):
  786:                 idx[False]
  787:         else:
  788:             msg = "only integers, slices"
  789:             with pytest.raises(IndexError, match=msg):
  790:                 idx[True]
  791:             with pytest.raises(IndexError, match=msg):
  792:                 idx[False]
  793: 
  794:     def test_copy_shares_cache(self, simple_index):
  795:         # GH32898, GH36840
  796:         idx = simple_index
  797:         idx.get_loc(idx[0])  # populates the _cache.
  798:         copy = idx.copy()
  799: 
  800:         assert copy._cache is idx._cache
  801: 
  802:     def test_shallow_copy_shares_cache(self, simple_index):
  803:         # GH32669, GH36840
  804:         idx = simple_index
  805:         idx.get_loc(idx[0])  # populates the _cache.
  806:         shallow_copy = idx._view()
  807: 
  808:         assert shallow_copy._cache is idx._cache
  809: 
  810:         shallow_copy = idx._shallow_copy(idx._data)
  811:         assert shallow_copy._cache is not idx._cache
  812:         assert shallow_copy._cache == {}
  813: 
  814:     def test_index_groupby(self, simple_index):
  815:         idx = simple_index[:5]
  816:         to_groupby = np.array([1, 2, np.nan, 2, 1])
  817:         tm.assert_dict_equal(
  818:             idx.groupby(to_groupby), {1.0: idx[[0, 4]], 2.0: idx[[1, 3]]}
  819:         )
  820: 
  821:         to_groupby = DatetimeIndex(
  822:             [
  823:                 datetime(2011, 11, 1),
  824:                 datetime(2011, 12, 1),
  825:                 pd.NaT,
  826:                 datetime(2011, 12, 1),
  827:                 datetime(2011, 11, 1),
  828:             ],
  829:             tz="UTC",
  830:         ).values
  831: 
  832:         ex_keys = [Timestamp("2011-11-01"), Timestamp("2011-12-01")]
  833:         expected = {ex_keys[0]: idx[[0, 4]], ex_keys[1]: idx[[1, 3]]}
  834:         tm.assert_dict_equal(idx.groupby(to_groupby), expected)
  835: 
  836:     def test_append_preserves_dtype(self, simple_index):
  837:         # In particular Index with dtype float32
  838:         index = simple_index
  839:         N = len(index)
  840: 
  841:         result = index.append(index)
  842:         assert result.dtype == index.dtype
  843:         tm.assert_index_equal(result[:N], index, check_exact=True)
  844:         tm.assert_index_equal(result[N:], index, check_exact=True)
  845: 
  846:         alt = index.take(list(range(N)) * 2)
  847:         tm.assert_index_equal(result, alt, check_exact=True)
  848: 
  849:     def test_inv(self, simple_index, using_infer_string):
  850:         idx = simple_index
  851: 
  852:         if idx.dtype.kind in ["i", "u"]:
  853:             res = ~idx
  854:             expected = Index(~idx.values, name=idx.name)
  855:             tm.assert_index_equal(res, expected)
  856: 
  857:             # check that we are matching Series behavior
  858:             res2 = ~Series(idx)
  859:             tm.assert_series_equal(res2, Series(expected))
  860:         else:
  861:             if idx.dtype.kind == "f":
  862:                 err = TypeError
  863:                 msg = "ufunc 'invert' not supported for the input types"
  864:             elif using_infer_string and idx.dtype == "string":
  865:                 import pyarrow as pa
  866: 
  867:                 err = pa.lib.ArrowNotImplementedError
  868:                 msg = "has no kernel"
  869:             else:
  870:                 err = TypeError
  871:                 msg = "bad operand"
  872:             with pytest.raises(err, match=msg):
  873:                 ~idx
  874: 
  875:             # check that we get the same behavior with Series
  876:             with pytest.raises(err, match=msg):
  877:                 ~Series(idx)
  878: 
  879:     def test_is_boolean_is_deprecated(self, simple_index):
  880:         # GH50042
  881:         idx = simple_index
  882:         with tm.assert_produces_warning(FutureWarning):
  883:             idx.is_boolean()
  884: 
  885:     def test_is_floating_is_deprecated(self, simple_index):
  886:         # GH50042
  887:         idx = simple_index
  888:         with tm.assert_produces_warning(FutureWarning):
  889:             idx.is_floating()
  890: 
  891:     def test_is_integer_is_deprecated(self, simple_index):
  892:         # GH50042
  893:         idx = simple_index
  894:         with tm.assert_produces_warning(FutureWarning):
  895:             idx.is_integer()
  896: 
  897:     def test_holds_integer_deprecated(self, simple_index):
  898:         # GH50243
  899:         idx = simple_index
  900:         msg = f"{type(idx).__name__}.holds_integer is deprecated. "
  901:         with tm.assert_produces_warning(FutureWarning, match=msg):
  902:             idx.holds_integer()
  903: 
  904:     def test_is_numeric_is_deprecated(self, simple_index):
  905:         # GH50042
  906:         idx = simple_index
  907:         with tm.assert_produces_warning(
  908:             FutureWarning,
  909:             match=f"{type(idx).__name__}.is_numeric is deprecated. ",
  910:         ):
  911:             idx.is_numeric()
  912: 
  913:     def test_is_categorical_is_deprecated(self, simple_index):
  914:         # GH50042
  915:         idx = simple_index
  916:         with tm.assert_produces_warning(
  917:             FutureWarning,
  918:             match=r"Use pandas\.api\.types\.is_categorical_dtype instead",
  919:         ):
  920:             idx.is_categorical()
  921: 
  922:     def test_is_interval_is_deprecated(self, simple_index):
  923:         # GH50042
  924:         idx = simple_index
  925:         with tm.assert_produces_warning(FutureWarning):
  926:             idx.is_interval()
  927: 
  928:     def test_is_object_is_deprecated(self, simple_index):
  929:         # GH50042
  930:         idx = simple_index
  931:         with tm.assert_produces_warning(FutureWarning):
  932:             idx.is_object()
  933: 
  934: 
  935: class TestNumericBase:
  936:     @pytest.fixture(
  937:         params=[
  938:             RangeIndex(start=0, stop=20, step=2),
  939:             Index(np.arange(5, dtype=np.float64)),
  940:             Index(np.arange(5, dtype=np.float32)),
  941:             Index(np.arange(5, dtype=np.uint64)),
  942:             Index(range(0, 20, 2), dtype=np.int64),
  943:             Index(range(0, 20, 2), dtype=np.int32),
  944:             Index(range(0, 20, 2), dtype=np.int16),
  945:             Index(range(0, 20, 2), dtype=np.int8),
  946:         ]
  947:     )
  948:     def simple_index(self, request):
  949:         return request.param
  950: 
  951:     def test_constructor_unwraps_index(self, simple_index):
  952:         if isinstance(simple_index, RangeIndex):
  953:             pytest.skip("Tested elsewhere.")
  954:         index_cls = type(simple_index)
  955:         dtype = simple_index.dtype
  956: 
  957:         idx = Index([1, 2], dtype=dtype)
  958:         result = index_cls(idx)
  959:         expected = np.array([1, 2], dtype=idx.dtype)
  960:         tm.assert_numpy_array_equal(result._data, expected)
  961: 
  962:     def test_can_hold_identifiers(self, simple_index):
  963:         idx = simple_index
  964:         key = idx[0]
  965:         assert idx._can_hold_identifiers_and_holds_name(key) is False
  966: 
  967:     def test_view(self, simple_index):
  968:         if isinstance(simple_index, RangeIndex):
  969:             pytest.skip("Tested elsewhere.")
  970:         index_cls = type(simple_index)
  971:         dtype = simple_index.dtype
  972: 
  973:         idx = index_cls([], dtype=dtype, name="Foo")
  974:         idx_view = idx.view()
  975:         assert idx_view.name == "Foo"
  976: 
  977:         idx_view = idx.view(dtype)
  978:         tm.assert_index_equal(idx, index_cls(idx_view, name="Foo"), exact=True)
  979: 
  980:         msg = "Passing a type in .*Index.view is deprecated"
  981:         with tm.assert_produces_warning(FutureWarning, match=msg):
  982:             idx_view = idx.view(index_cls)
  983:         tm.assert_index_equal(idx, index_cls(idx_view, name="Foo"), exact=True)
  984: 
  985:     def test_format(self, simple_index):
  986:         # GH35439
  987:         if isinstance(simple_index, DatetimeIndex):
  988:             pytest.skip("Tested elsewhere")
  989:         idx = simple_index
  990:         max_width = max(len(str(x)) for x in idx)
  991:         expected = [str(x).ljust(max_width) for x in idx]
  992:         msg = r"Index\.format is deprecated"
  993:         with tm.assert_produces_warning(FutureWarning, match=msg):
  994:             assert idx.format() == expected
  995: 
  996:     def test_insert_non_na(self, simple_index):
  997:         # GH#43921 inserting an element that we know we can hold should
  998:         #  not change dtype or type (except for RangeIndex)
  999:         index = simple_index
 1000: 
 1001:         result = index.insert(0, index[0])
 1002: 
 1003:         expected = Index([index[0]] + list(index), dtype=index.dtype)
 1004:         tm.assert_index_equal(result, expected, exact=True)
 1005: 
 1006:     def test_insert_na(self, nulls_fixture, simple_index):
 1007:         # GH 18295 (test missing)
 1008:         index = simple_index
 1009:         na_val = nulls_fixture
 1010: 
 1011:         if na_val is pd.NaT:
 1012:             expected = Index([index[0], pd.NaT] + list(index[1:]), dtype=object)
 1013:         else:
 1014:             expected = Index([index[0], np.nan] + list(index[1:]))
 1015:             # GH#43921 we preserve float dtype
 1016:             if index.dtype.kind == "f":
 1017:                 expected = Index(expected, dtype=index.dtype)
 1018: 
 1019:         result = index.insert(1, na_val)
 1020:         tm.assert_index_equal(result, expected, exact=True)
 1021: 
 1022:     def test_arithmetic_explicit_conversions(self, simple_index):
 1023:         # GH 8608
 1024:         # add/sub are overridden explicitly for Float/Int Index
 1025:         index_cls = type(simple_index)
 1026:         if index_cls is RangeIndex:
 1027:             idx = RangeIndex(5)
 1028:         else:
 1029:             idx = index_cls(np.arange(5, dtype="int64"))
 1030: 
 1031:         # float conversions
 1032:         arr = np.arange(5, dtype="int64") * 3.2
 1033:         expected = Index(arr, dtype=np.float64)
 1034:         fidx = idx * 3.2
 1035:         tm.assert_index_equal(fidx, expected)
 1036:         fidx = 3.2 * idx
 1037:         tm.assert_index_equal(fidx, expected)
 1038: 
 1039:         # interops with numpy arrays
 1040:         expected = Index(arr, dtype=np.float64)
 1041:         a = np.zeros(5, dtype="float64")
 1042:         result = fidx - a
 1043:         tm.assert_index_equal(result, expected)
 1044: 
 1045:         expected = Index(-arr, dtype=np.float64)
 1046:         a = np.zeros(5, dtype="float64")
 1047:         result = a - fidx
 1048:         tm.assert_index_equal(result, expected)
 1049: 
 1050:     @pytest.mark.parametrize("complex_dtype", [np.complex64, np.complex128])
 1051:     def test_astype_to_complex(self, complex_dtype, simple_index):
 1052:         result = simple_index.astype(complex_dtype)
 1053: 
 1054:         assert type(result) is Index and result.dtype == complex_dtype
 1055: 
 1056:     def test_cast_string(self, simple_index):
 1057:         if isinstance(simple_index, RangeIndex):
 1058:             pytest.skip("casting of strings not relevant for RangeIndex")
 1059:         result = type(simple_index)(["0", "1", "2"], dtype=simple_index.dtype)
 1060:         expected = type(simple_index)([0, 1, 2], dtype=simple_index.dtype)
 1061:         tm.assert_index_equal(result, expected)
