    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas.errors import InvalidIndexError
    5: 
    6: from pandas import (
    7:     NA,
    8:     Index,
    9:     RangeIndex,
   10:     Series,
   11:     Timestamp,
   12: )
   13: import pandas._testing as tm
   14: from pandas.core.arrays import (
   15:     ArrowExtensionArray,
   16:     FloatingArray,
   17: )
   18: 
   19: 
   20: @pytest.fixture
   21: def index_large():
   22:     # large values used in Index[uint64] tests where no compat needed with Int64/Float64
   23:     large = [2**63, 2**63 + 10, 2**63 + 15, 2**63 + 20, 2**63 + 25]
   24:     return Index(large, dtype=np.uint64)
   25: 
   26: 
   27: class TestGetLoc:
   28:     def test_get_loc(self):
   29:         index = Index([0, 1, 2])
   30:         assert index.get_loc(1) == 1
   31: 
   32:     def test_get_loc_raises_bad_label(self):
   33:         index = Index([0, 1, 2])
   34:         with pytest.raises(InvalidIndexError, match=r"\[1, 2\]"):
   35:             index.get_loc([1, 2])
   36: 
   37:     def test_get_loc_float64(self):
   38:         idx = Index([0.0, 1.0, 2.0], dtype=np.float64)
   39: 
   40:         with pytest.raises(KeyError, match="^'foo'$"):
   41:             idx.get_loc("foo")
   42:         with pytest.raises(KeyError, match=r"^1\.5$"):
   43:             idx.get_loc(1.5)
   44:         with pytest.raises(KeyError, match="^True$"):
   45:             idx.get_loc(True)
   46:         with pytest.raises(KeyError, match="^False$"):
   47:             idx.get_loc(False)
   48: 
   49:     def test_get_loc_na(self):
   50:         idx = Index([np.nan, 1, 2], dtype=np.float64)
   51:         assert idx.get_loc(1) == 1
   52:         assert idx.get_loc(np.nan) == 0
   53: 
   54:         idx = Index([np.nan, 1, np.nan], dtype=np.float64)
   55:         assert idx.get_loc(1) == 1
   56: 
   57:         # representable by slice [0:2:2]
   58:         msg = "'Cannot get left slice bound for non-unique label: nan'"
   59:         with pytest.raises(KeyError, match=msg):
   60:             idx.slice_locs(np.nan)
   61:         # not representable by slice
   62:         idx = Index([np.nan, 1, np.nan, np.nan], dtype=np.float64)
   63:         assert idx.get_loc(1) == 1
   64:         msg = "'Cannot get left slice bound for non-unique label: nan"
   65:         with pytest.raises(KeyError, match=msg):
   66:             idx.slice_locs(np.nan)
   67: 
   68:     def test_get_loc_missing_nan(self):
   69:         # GH#8569
   70:         idx = Index([1, 2], dtype=np.float64)
   71:         assert idx.get_loc(1) == 0
   72:         with pytest.raises(KeyError, match=r"^3$"):
   73:             idx.get_loc(3)
   74:         with pytest.raises(KeyError, match="^nan$"):
   75:             idx.get_loc(np.nan)
   76:         with pytest.raises(InvalidIndexError, match=r"\[nan\]"):
   77:             # listlike/non-hashable raises TypeError
   78:             idx.get_loc([np.nan])
   79: 
   80:     @pytest.mark.parametrize("vals", [[1], [1.0], [Timestamp("2019-12-31")], ["test"]])
   81:     def test_get_loc_float_index_nan_with_method(self, vals):
   82:         # GH#39382
   83:         idx = Index(vals)
   84:         with pytest.raises(KeyError, match="nan"):
   85:             idx.get_loc(np.nan)
   86: 
   87:     @pytest.mark.parametrize("dtype", ["f8", "i8", "u8"])
   88:     def test_get_loc_numericindex_none_raises(self, dtype):
   89:         # case that goes through searchsorted and key is non-comparable to values
   90:         arr = np.arange(10**7, dtype=dtype)
   91:         idx = Index(arr)
   92:         with pytest.raises(KeyError, match="None"):
   93:             idx.get_loc(None)
   94: 
   95:     def test_get_loc_overflows(self):
   96:         # unique but non-monotonic goes through IndexEngine.mapping.get_item
   97:         idx = Index([0, 2, 1])
   98: 
   99:         val = np.iinfo(np.int64).max + 1
  100: 
  101:         with pytest.raises(KeyError, match=str(val)):
  102:             idx.get_loc(val)
  103:         with pytest.raises(KeyError, match=str(val)):
  104:             idx._engine.get_loc(val)
  105: 
  106: 
  107: class TestGetIndexer:
  108:     def test_get_indexer(self):
  109:         index1 = Index([1, 2, 3, 4, 5])
  110:         index2 = Index([2, 4, 6])
  111: 
  112:         r1 = index1.get_indexer(index2)
  113:         e1 = np.array([1, 3, -1], dtype=np.intp)
  114:         tm.assert_almost_equal(r1, e1)
  115: 
  116:     @pytest.mark.parametrize("reverse", [True, False])
  117:     @pytest.mark.parametrize(
  118:         "expected,method",
  119:         [
  120:             (np.array([-1, 0, 0, 1, 1], dtype=np.intp), "pad"),
  121:             (np.array([-1, 0, 0, 1, 1], dtype=np.intp), "ffill"),
  122:             (np.array([0, 0, 1, 1, 2], dtype=np.intp), "backfill"),
  123:             (np.array([0, 0, 1, 1, 2], dtype=np.intp), "bfill"),
  124:         ],
  125:     )
  126:     def test_get_indexer_methods(self, reverse, expected, method):
  127:         index1 = Index([1, 2, 3, 4, 5])
  128:         index2 = Index([2, 4, 6])
  129: 
  130:         if reverse:
  131:             index1 = index1[::-1]
  132:             expected = expected[::-1]
  133: 
  134:         result = index2.get_indexer(index1, method=method)
  135:         tm.assert_almost_equal(result, expected)
  136: 
  137:     def test_get_indexer_invalid(self):
  138:         # GH10411
  139:         index = Index(np.arange(10))
  140: 
  141:         with pytest.raises(ValueError, match="tolerance argument"):
  142:             index.get_indexer([1, 0], tolerance=1)
  143: 
  144:         with pytest.raises(ValueError, match="limit argument"):
  145:             index.get_indexer([1, 0], limit=1)
  146: 
  147:     @pytest.mark.parametrize(
  148:         "method, tolerance, indexer, expected",
  149:         [
  150:             ("pad", None, [0, 5, 9], [0, 5, 9]),
  151:             ("backfill", None, [0, 5, 9], [0, 5, 9]),
  152:             ("nearest", None, [0, 5, 9], [0, 5, 9]),
  153:             ("pad", 0, [0, 5, 9], [0, 5, 9]),
  154:             ("backfill", 0, [0, 5, 9], [0, 5, 9]),
  155:             ("nearest", 0, [0, 5, 9], [0, 5, 9]),
  156:             ("pad", None, [0.2, 1.8, 8.5], [0, 1, 8]),
  157:             ("backfill", None, [0.2, 1.8, 8.5], [1, 2, 9]),
  158:             ("nearest", None, [0.2, 1.8, 8.5], [0, 2, 9]),
  159:             ("pad", 1, [0.2, 1.8, 8.5], [0, 1, 8]),
  160:             ("backfill", 1, [0.2, 1.8, 8.5], [1, 2, 9]),
  161:             ("nearest", 1, [0.2, 1.8, 8.5], [0, 2, 9]),
  162:             ("pad", 0.2, [0.2, 1.8, 8.5], [0, -1, -1]),
  163:             ("backfill", 0.2, [0.2, 1.8, 8.5], [-1, 2, -1]),
  164:             ("nearest", 0.2, [0.2, 1.8, 8.5], [0, 2, -1]),
  165:         ],
  166:     )
  167:     def test_get_indexer_nearest(self, method, tolerance, indexer, expected):
  168:         index = Index(np.arange(10))
  169: 
  170:         actual = index.get_indexer(indexer, method=method, tolerance=tolerance)
  171:         tm.assert_numpy_array_equal(actual, np.array(expected, dtype=np.intp))
  172: 
  173:     @pytest.mark.parametrize("listtype", [list, tuple, Series, np.array])
  174:     @pytest.mark.parametrize(
  175:         "tolerance, expected",
  176:         list(
  177:             zip(
  178:                 [[0.3, 0.3, 0.1], [0.2, 0.1, 0.1], [0.1, 0.5, 0.5]],
  179:                 [[0, 2, -1], [0, -1, -1], [-1, 2, 9]],
  180:             )
  181:         ),
  182:     )
  183:     def test_get_indexer_nearest_listlike_tolerance(
  184:         self, tolerance, expected, listtype
  185:     ):
  186:         index = Index(np.arange(10))
  187: 
  188:         actual = index.get_indexer(
  189:             [0.2, 1.8, 8.5], method="nearest", tolerance=listtype(tolerance)
  190:         )
  191:         tm.assert_numpy_array_equal(actual, np.array(expected, dtype=np.intp))
  192: 
  193:     def test_get_indexer_nearest_error(self):
  194:         index = Index(np.arange(10))
  195:         with pytest.raises(ValueError, match="limit argument"):
  196:             index.get_indexer([1, 0], method="nearest", limit=1)
  197: 
  198:         with pytest.raises(ValueError, match="tolerance size must match"):
  199:             index.get_indexer([1, 0], method="nearest", tolerance=[1, 2, 3])
  200: 
  201:     @pytest.mark.parametrize(
  202:         "method,expected",
  203:         [("pad", [8, 7, 0]), ("backfill", [9, 8, 1]), ("nearest", [9, 7, 0])],
  204:     )
  205:     def test_get_indexer_nearest_decreasing(self, method, expected):
  206:         index = Index(np.arange(10))[::-1]
  207: 
  208:         actual = index.get_indexer([0, 5, 9], method=method)
  209:         tm.assert_numpy_array_equal(actual, np.array([9, 4, 0], dtype=np.intp))
  210: 
  211:         actual = index.get_indexer([0.2, 1.8, 8.5], method=method)
  212:         tm.assert_numpy_array_equal(actual, np.array(expected, dtype=np.intp))
  213: 
  214:     @pytest.mark.parametrize("idx_dtype", ["int64", "float64", "uint64", "range"])
  215:     @pytest.mark.parametrize("method", ["get_indexer", "get_indexer_non_unique"])
  216:     def test_get_indexer_numeric_index_boolean_target(self, method, idx_dtype):
  217:         # GH 16877
  218: 
  219:         if idx_dtype == "range":
  220:             numeric_index = RangeIndex(4)
  221:         else:
  222:             numeric_index = Index(np.arange(4, dtype=idx_dtype))
  223: 
  224:         other = Index([True, False, True])
  225: 
  226:         result = getattr(numeric_index, method)(other)
  227:         expected = np.array([-1, -1, -1], dtype=np.intp)
  228:         if method == "get_indexer":
  229:             tm.assert_numpy_array_equal(result, expected)
  230:         else:
  231:             missing = np.arange(3, dtype=np.intp)
  232:             tm.assert_numpy_array_equal(result[0], expected)
  233:             tm.assert_numpy_array_equal(result[1], missing)
  234: 
  235:     @pytest.mark.parametrize("method", ["pad", "backfill", "nearest"])
  236:     def test_get_indexer_with_method_numeric_vs_bool(self, method):
  237:         left = Index([1, 2, 3])
  238:         right = Index([True, False])
  239: 
  240:         with pytest.raises(TypeError, match="Cannot compare"):
  241:             left.get_indexer(right, method=method)
  242: 
  243:         with pytest.raises(TypeError, match="Cannot compare"):
  244:             right.get_indexer(left, method=method)
  245: 
  246:     def test_get_indexer_numeric_vs_bool(self):
  247:         left = Index([1, 2, 3])
  248:         right = Index([True, False])
  249: 
  250:         res = left.get_indexer(right)
  251:         expected = -1 * np.ones(len(right), dtype=np.intp)
  252:         tm.assert_numpy_array_equal(res, expected)
  253: 
  254:         res = right.get_indexer(left)
  255:         expected = -1 * np.ones(len(left), dtype=np.intp)
  256:         tm.assert_numpy_array_equal(res, expected)
  257: 
  258:         res = left.get_indexer_non_unique(right)[0]
  259:         expected = -1 * np.ones(len(right), dtype=np.intp)
  260:         tm.assert_numpy_array_equal(res, expected)
  261: 
  262:         res = right.get_indexer_non_unique(left)[0]
  263:         expected = -1 * np.ones(len(left), dtype=np.intp)
  264:         tm.assert_numpy_array_equal(res, expected)
  265: 
  266:     def test_get_indexer_float64(self):
  267:         idx = Index([0.0, 1.0, 2.0], dtype=np.float64)
  268:         tm.assert_numpy_array_equal(
  269:             idx.get_indexer(idx), np.array([0, 1, 2], dtype=np.intp)
  270:         )
  271: 
  272:         target = [-0.1, 0.5, 1.1]
  273:         tm.assert_numpy_array_equal(
  274:             idx.get_indexer(target, "pad"), np.array([-1, 0, 1], dtype=np.intp)
  275:         )
  276:         tm.assert_numpy_array_equal(
  277:             idx.get_indexer(target, "backfill"), np.array([0, 1, 2], dtype=np.intp)
  278:         )
  279:         tm.assert_numpy_array_equal(
  280:             idx.get_indexer(target, "nearest"), np.array([0, 1, 1], dtype=np.intp)
  281:         )
  282: 
  283:     def test_get_indexer_nan(self):
  284:         # GH#7820
  285:         result = Index([1, 2, np.nan], dtype=np.float64).get_indexer([np.nan])
  286:         expected = np.array([2], dtype=np.intp)
  287:         tm.assert_numpy_array_equal(result, expected)
  288: 
  289:     def test_get_indexer_int64(self):
  290:         index = Index(range(0, 20, 2), dtype=np.int64)
  291:         target = Index(np.arange(10), dtype=np.int64)
  292:         indexer = index.get_indexer(target)
  293:         expected = np.array([0, -1, 1, -1, 2, -1, 3, -1, 4, -1], dtype=np.intp)
  294:         tm.assert_numpy_array_equal(indexer, expected)
  295: 
  296:         target = Index(np.arange(10), dtype=np.int64)
  297:         indexer = index.get_indexer(target, method="pad")
  298:         expected = np.array([0, 0, 1, 1, 2, 2, 3, 3, 4, 4], dtype=np.intp)
  299:         tm.assert_numpy_array_equal(indexer, expected)
  300: 
  301:         target = Index(np.arange(10), dtype=np.int64)
  302:         indexer = index.get_indexer(target, method="backfill")
  303:         expected = np.array([0, 1, 1, 2, 2, 3, 3, 4, 4, 5], dtype=np.intp)
  304:         tm.assert_numpy_array_equal(indexer, expected)
  305: 
  306:     def test_get_indexer_uint64(self, index_large):
  307:         target = Index(np.arange(10).astype("uint64") * 5 + 2**63)
  308:         indexer = index_large.get_indexer(target)
  309:         expected = np.array([0, -1, 1, 2, 3, 4, -1, -1, -1, -1], dtype=np.intp)
  310:         tm.assert_numpy_array_equal(indexer, expected)
  311: 
  312:         target = Index(np.arange(10).astype("uint64") * 5 + 2**63)
  313:         indexer = index_large.get_indexer(target, method="pad")
  314:         expected = np.array([0, 0, 1, 2, 3, 4, 4, 4, 4, 4], dtype=np.intp)
  315:         tm.assert_numpy_array_equal(indexer, expected)
  316: 
  317:         target = Index(np.arange(10).astype("uint64") * 5 + 2**63)
  318:         indexer = index_large.get_indexer(target, method="backfill")
  319:         expected = np.array([0, 1, 1, 2, 3, 4, -1, -1, -1, -1], dtype=np.intp)
  320:         tm.assert_numpy_array_equal(indexer, expected)
  321: 
  322:     @pytest.mark.parametrize("val, val2", [(4, 5), (4, 4), (4, NA), (NA, NA)])
  323:     def test_get_loc_masked(self, val, val2, any_numeric_ea_and_arrow_dtype):
  324:         # GH#39133
  325:         idx = Index([1, 2, 3, val, val2], dtype=any_numeric_ea_and_arrow_dtype)
  326:         result = idx.get_loc(2)
  327:         assert result == 1
  328: 
  329:         with pytest.raises(KeyError, match="9"):
  330:             idx.get_loc(9)
  331: 
  332:     def test_get_loc_masked_na(self, any_numeric_ea_and_arrow_dtype):
  333:         # GH#39133
  334:         idx = Index([1, 2, NA], dtype=any_numeric_ea_and_arrow_dtype)
  335:         result = idx.get_loc(NA)
  336:         assert result == 2
  337: 
  338:         idx = Index([1, 2, NA, NA], dtype=any_numeric_ea_and_arrow_dtype)
  339:         result = idx.get_loc(NA)
  340:         tm.assert_numpy_array_equal(result, np.array([False, False, True, True]))
  341: 
  342:         idx = Index([1, 2, 3], dtype=any_numeric_ea_and_arrow_dtype)
  343:         with pytest.raises(KeyError, match="NA"):
  344:             idx.get_loc(NA)
  345: 
  346:     def test_get_loc_masked_na_and_nan(self):
  347:         # GH#39133
  348:         idx = Index(
  349:             FloatingArray(
  350:                 np.array([1, 2, 1, np.nan]), mask=np.array([False, False, True, False])
  351:             )
  352:         )
  353:         result = idx.get_loc(NA)
  354:         assert result == 2
  355:         result = idx.get_loc(np.nan)
  356:         assert result == 3
  357: 
  358:         idx = Index(
  359:             FloatingArray(np.array([1, 2, 1.0]), mask=np.array([False, False, True]))
  360:         )
  361:         result = idx.get_loc(NA)
  362:         assert result == 2
  363:         with pytest.raises(KeyError, match="nan"):
  364:             idx.get_loc(np.nan)
  365: 
  366:         idx = Index(
  367:             FloatingArray(
  368:                 np.array([1, 2, np.nan]), mask=np.array([False, False, False])
  369:             )
  370:         )
  371:         result = idx.get_loc(np.nan)
  372:         assert result == 2
  373:         with pytest.raises(KeyError, match="NA"):
  374:             idx.get_loc(NA)
  375: 
  376:     @pytest.mark.parametrize("val", [4, 2])
  377:     def test_get_indexer_masked_na(self, any_numeric_ea_and_arrow_dtype, val):
  378:         # GH#39133
  379:         idx = Index([1, 2, NA, 3, val], dtype=any_numeric_ea_and_arrow_dtype)
  380:         result = idx.get_indexer_for([1, NA, 5])
  381:         expected = np.array([0, 2, -1])
  382:         tm.assert_numpy_array_equal(result, expected, check_dtype=False)
  383: 
  384:     @pytest.mark.parametrize("dtype", ["boolean", "bool[pyarrow]"])
  385:     def test_get_indexer_masked_na_boolean(self, dtype):
  386:         # GH#39133
  387:         if dtype == "bool[pyarrow]":
  388:             pytest.importorskip("pyarrow")
  389:         idx = Index([True, False, NA], dtype=dtype)
  390:         result = idx.get_loc(False)
  391:         assert result == 1
  392:         result = idx.get_loc(NA)
  393:         assert result == 2
  394: 
  395:     def test_get_indexer_arrow_dictionary_target(self):
  396:         pa = pytest.importorskip("pyarrow")
  397:         target = Index(
  398:             ArrowExtensionArray(
  399:                 pa.array([1, 2], type=pa.dictionary(pa.int8(), pa.int8()))
  400:             )
  401:         )
  402:         idx = Index([1])
  403: 
  404:         result = idx.get_indexer(target)
  405:         expected = np.array([0, -1], dtype=np.int64)
  406:         tm.assert_numpy_array_equal(result, expected)
  407: 
  408:         result_1, result_2 = idx.get_indexer_non_unique(target)
  409:         expected_1, expected_2 = np.array([0, -1], dtype=np.int64), np.array(
  410:             [1], dtype=np.int64
  411:         )
  412:         tm.assert_numpy_array_equal(result_1, expected_1)
  413:         tm.assert_numpy_array_equal(result_2, expected_2)
  414: 
  415: 
  416: class TestWhere:
  417:     @pytest.mark.parametrize(
  418:         "index",
  419:         [
  420:             Index(np.arange(5, dtype="float64")),
  421:             Index(range(0, 20, 2), dtype=np.int64),
  422:             Index(np.arange(5, dtype="uint64")),
  423:         ],
  424:     )
  425:     def test_where(self, listlike_box, index):
  426:         cond = [True] * len(index)
  427:         expected = index
  428:         result = index.where(listlike_box(cond))
  429: 
  430:         cond = [False] + [True] * (len(index) - 1)
  431:         expected = Index([index._na_value] + index[1:].tolist(), dtype=np.float64)
  432:         result = index.where(listlike_box(cond))
  433:         tm.assert_index_equal(result, expected)
  434: 
  435:     def test_where_uint64(self):
  436:         idx = Index([0, 6, 2], dtype=np.uint64)
  437:         mask = np.array([False, True, False])
  438:         other = np.array([1], dtype=np.int64)
  439: 
  440:         expected = Index([1, 6, 1], dtype=np.uint64)
  441: 
  442:         result = idx.where(mask, other)
  443:         tm.assert_index_equal(result, expected)
  444: 
  445:         result = idx.putmask(~mask, other)
  446:         tm.assert_index_equal(result, expected)
  447: 
  448:     def test_where_infers_type_instead_of_trying_to_convert_string_to_float(self):
  449:         # GH 32413
  450:         index = Index([1, np.nan])
  451:         cond = index.notna()
  452:         other = Index(["a", "b"], dtype="string")
  453: 
  454:         expected = Index([1.0, "b"])
  455:         result = index.where(cond, other)
  456: 
  457:         tm.assert_index_equal(result, expected)
  458: 
  459: 
  460: class TestTake:
  461:     @pytest.mark.parametrize("idx_dtype", [np.float64, np.int64, np.uint64])
  462:     def test_take_preserve_name(self, idx_dtype):
  463:         index = Index([1, 2, 3, 4], dtype=idx_dtype, name="foo")
  464:         taken = index.take([3, 0, 1])
  465:         assert index.name == taken.name
  466: 
  467:     def test_take_fill_value_float64(self):
  468:         # GH 12631
  469:         idx = Index([1.0, 2.0, 3.0], name="xxx", dtype=np.float64)
  470:         result = idx.take(np.array([1, 0, -1]))
  471:         expected = Index([2.0, 1.0, 3.0], dtype=np.float64, name="xxx")
  472:         tm.assert_index_equal(result, expected)
  473: 
  474:         # fill_value
  475:         result = idx.take(np.array([1, 0, -1]), fill_value=True)
  476:         expected = Index([2.0, 1.0, np.nan], dtype=np.float64, name="xxx")
  477:         tm.assert_index_equal(result, expected)
  478: 
  479:         # allow_fill=False
  480:         result = idx.take(np.array([1, 0, -1]), allow_fill=False, fill_value=True)
  481:         expected = Index([2.0, 1.0, 3.0], dtype=np.float64, name="xxx")
  482:         tm.assert_index_equal(result, expected)
  483: 
  484:         msg = (
  485:             "When allow_fill=True and fill_value is not None, "
  486:             "all indices must be >= -1"
  487:         )
  488:         with pytest.raises(ValueError, match=msg):
  489:             idx.take(np.array([1, 0, -2]), fill_value=True)
  490:         with pytest.raises(ValueError, match=msg):
  491:             idx.take(np.array([1, 0, -5]), fill_value=True)
  492: 
  493:         msg = "index -5 is out of bounds for (axis 0 with )?size 3"
  494:         with pytest.raises(IndexError, match=msg):
  495:             idx.take(np.array([1, -5]))
  496: 
  497:     @pytest.mark.parametrize("dtype", [np.int64, np.uint64])
  498:     def test_take_fill_value_ints(self, dtype):
  499:         # see gh-12631
  500:         idx = Index([1, 2, 3], dtype=dtype, name="xxx")
  501:         result = idx.take(np.array([1, 0, -1]))
  502:         expected = Index([2, 1, 3], dtype=dtype, name="xxx")
  503:         tm.assert_index_equal(result, expected)
  504: 
  505:         name = type(idx).__name__
  506:         msg = f"Unable to fill values because {name} cannot contain NA"
  507: 
  508:         # fill_value=True
  509:         with pytest.raises(ValueError, match=msg):
  510:             idx.take(np.array([1, 0, -1]), fill_value=True)
  511: 
  512:         # allow_fill=False
  513:         result = idx.take(np.array([1, 0, -1]), allow_fill=False, fill_value=True)
  514:         expected = Index([2, 1, 3], dtype=dtype, name="xxx")
  515:         tm.assert_index_equal(result, expected)
  516: 
  517:         with pytest.raises(ValueError, match=msg):
  518:             idx.take(np.array([1, 0, -2]), fill_value=True)
  519:         with pytest.raises(ValueError, match=msg):
  520:             idx.take(np.array([1, 0, -5]), fill_value=True)
  521: 
  522:         msg = "index -5 is out of bounds for (axis 0 with )?size 3"
  523:         with pytest.raises(IndexError, match=msg):
  524:             idx.take(np.array([1, -5]))
  525: 
  526: 
  527: class TestContains:
  528:     @pytest.mark.parametrize("dtype", [np.float64, np.int64, np.uint64])
  529:     def test_contains_none(self, dtype):
  530:         # GH#35788 should return False, not raise TypeError
  531:         index = Index([0, 1, 2, 3, 4], dtype=dtype)
  532:         assert None not in index
  533: 
  534:     def test_contains_float64_nans(self):
  535:         index = Index([1.0, 2.0, np.nan], dtype=np.float64)
  536:         assert np.nan in index
  537: 
  538:     def test_contains_float64_not_nans(self):
  539:         index = Index([1.0, 2.0, np.nan], dtype=np.float64)
  540:         assert 1.0 in index
  541: 
  542: 
  543: class TestSliceLocs:
  544:     @pytest.mark.parametrize("dtype", [int, float])
  545:     def test_slice_locs(self, dtype):
  546:         index = Index(np.array([0, 1, 2, 5, 6, 7, 9, 10], dtype=dtype))
  547:         n = len(index)
  548: 
  549:         assert index.slice_locs(start=2) == (2, n)
  550:         assert index.slice_locs(start=3) == (3, n)
  551:         assert index.slice_locs(3, 8) == (3, 6)
  552:         assert index.slice_locs(5, 10) == (3, n)
  553:         assert index.slice_locs(end=8) == (0, 6)
  554:         assert index.slice_locs(end=9) == (0, 7)
  555: 
  556:         # reversed
  557:         index2 = index[::-1]
  558:         assert index2.slice_locs(8, 2) == (2, 6)
  559:         assert index2.slice_locs(7, 3) == (2, 5)
  560: 
  561:     @pytest.mark.parametrize("dtype", [int, float])
  562:     def test_slice_locs_float_locs(self, dtype):
  563:         index = Index(np.array([0, 1, 2, 5, 6, 7, 9, 10], dtype=dtype))
  564:         n = len(index)
  565:         assert index.slice_locs(5.0, 10.0) == (3, n)
  566:         assert index.slice_locs(4.5, 10.5) == (3, 8)
  567: 
  568:         index2 = index[::-1]
  569:         assert index2.slice_locs(8.5, 1.5) == (2, 6)
  570:         assert index2.slice_locs(10.5, -1) == (0, n)
  571: 
  572:     @pytest.mark.parametrize("dtype", [int, float])
  573:     def test_slice_locs_dup_numeric(self, dtype):
  574:         index = Index(np.array([10, 12, 12, 14], dtype=dtype))
  575:         assert index.slice_locs(12, 12) == (1, 3)
  576:         assert index.slice_locs(11, 13) == (1, 3)
  577: 
  578:         index2 = index[::-1]
  579:         assert index2.slice_locs(12, 12) == (1, 3)
  580:         assert index2.slice_locs(13, 11) == (1, 3)
  581: 
  582:     def test_slice_locs_na(self):
  583:         index = Index([np.nan, 1, 2])
  584:         assert index.slice_locs(1) == (1, 3)
  585:         assert index.slice_locs(np.nan) == (0, 3)
  586: 
  587:         index = Index([0, np.nan, np.nan, 1, 2])
  588:         assert index.slice_locs(np.nan) == (1, 5)
  589: 
  590:     def test_slice_locs_na_raises(self):
  591:         index = Index([np.nan, 1, 2])
  592:         with pytest.raises(KeyError, match=""):
  593:             index.slice_locs(start=1.5)
  594: 
  595:         with pytest.raises(KeyError, match=""):
  596:             index.slice_locs(end=1.5)
  597: 
  598: 
  599: class TestGetSliceBounds:
  600:     @pytest.mark.parametrize("side, expected", [("left", 4), ("right", 5)])
  601:     def test_get_slice_bounds_within(self, side, expected):
  602:         index = Index(range(6))
  603:         result = index.get_slice_bound(4, side=side)
  604:         assert result == expected
  605: 
  606:     @pytest.mark.parametrize("side", ["left", "right"])
  607:     @pytest.mark.parametrize("bound, expected", [(-1, 0), (10, 6)])
  608:     def test_get_slice_bounds_outside(self, side, expected, bound):
  609:         index = Index(range(6))
  610:         result = index.get_slice_bound(bound, side=side)
  611:         assert result == expected
