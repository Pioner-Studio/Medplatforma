    1: import datetime as dt
    2: from datetime import date
    3: import re
    4: 
    5: import numpy as np
    6: import pytest
    7: 
    8: from pandas.compat.numpy import np_long
    9: 
   10: import pandas as pd
   11: from pandas import (
   12:     DataFrame,
   13:     DatetimeIndex,
   14:     Index,
   15:     Timestamp,
   16:     date_range,
   17:     offsets,
   18: )
   19: import pandas._testing as tm
   20: 
   21: 
   22: class TestDatetimeIndex:
   23:     def test_is_(self):
   24:         dti = date_range(start="1/1/2005", end="12/1/2005", freq="ME")
   25:         assert dti.is_(dti)
   26:         assert dti.is_(dti.view())
   27:         assert not dti.is_(dti.copy())
   28: 
   29:     def test_time_overflow_for_32bit_machines(self):
   30:         # GH8943.  On some machines NumPy defaults to np.int32 (for example,
   31:         # 32-bit Linux machines).  In the function _generate_regular_range
   32:         # found in tseries/index.py, `periods` gets multiplied by `strides`
   33:         # (which has value 1e9) and since the max value for np.int32 is ~2e9,
   34:         # and since those machines won't promote np.int32 to np.int64, we get
   35:         # overflow.
   36:         periods = np_long(1000)
   37: 
   38:         idx1 = date_range(start="2000", periods=periods, freq="s")
   39:         assert len(idx1) == periods
   40: 
   41:         idx2 = date_range(end="2000", periods=periods, freq="s")
   42:         assert len(idx2) == periods
   43: 
   44:     def test_nat(self):
   45:         assert DatetimeIndex([np.nan])[0] is pd.NaT
   46: 
   47:     def test_week_of_month_frequency(self):
   48:         # GH 5348: "ValueError: Could not evaluate WOM-1SUN" shouldn't raise
   49:         d1 = date(2002, 9, 1)
   50:         d2 = date(2013, 10, 27)
   51:         d3 = date(2012, 9, 30)
   52:         idx1 = DatetimeIndex([d1, d2])
   53:         idx2 = DatetimeIndex([d3])
   54:         result_append = idx1.append(idx2)
   55:         expected = DatetimeIndex([d1, d2, d3])
   56:         tm.assert_index_equal(result_append, expected)
   57:         result_union = idx1.union(idx2)
   58:         expected = DatetimeIndex([d1, d3, d2])
   59:         tm.assert_index_equal(result_union, expected)
   60: 
   61:     def test_append_nondatetimeindex(self):
   62:         rng = date_range("1/1/2000", periods=10)
   63:         idx = Index(["a", "b", "c", "d"])
   64: 
   65:         result = rng.append(idx)
   66:         assert isinstance(result[0], Timestamp)
   67: 
   68:     def test_misc_coverage(self):
   69:         rng = date_range("1/1/2000", periods=5)
   70:         result = rng.groupby(rng.day)
   71:         assert isinstance(next(iter(result.values()))[0], Timestamp)
   72: 
   73:     # TODO: belongs in frame groupby tests?
   74:     def test_groupby_function_tuple_1677(self):
   75:         df = DataFrame(
   76:             np.random.default_rng(2).random(100),
   77:             index=date_range("1/1/2000", periods=100),
   78:         )
   79:         monthly_group = df.groupby(lambda x: (x.year, x.month))
   80: 
   81:         result = monthly_group.mean()
   82:         assert isinstance(result.index[0], tuple)
   83: 
   84:     def assert_index_parameters(self, index):
   85:         assert index.freq == "40960ns"
   86:         assert index.inferred_freq == "40960ns"
   87: 
   88:     def test_ns_index(self):
   89:         nsamples = 400
   90:         ns = int(1e9 / 24414)
   91:         dtstart = np.datetime64("2012-09-20T00:00:00")
   92: 
   93:         dt = dtstart + np.arange(nsamples) * np.timedelta64(ns, "ns")
   94:         freq = ns * offsets.Nano()
   95:         index = DatetimeIndex(dt, freq=freq, name="time")
   96:         self.assert_index_parameters(index)
   97: 
   98:         new_index = date_range(start=index[0], end=index[-1], freq=index.freq)
   99:         self.assert_index_parameters(new_index)
  100: 
  101:     def test_asarray_tz_naive(self):
  102:         # This shouldn't produce a warning.
  103:         idx = date_range("2000", periods=2)
  104:         # M8[ns] by default
  105:         result = np.asarray(idx)
  106: 
  107:         expected = np.array(["2000-01-01", "2000-01-02"], dtype="M8[ns]")
  108:         tm.assert_numpy_array_equal(result, expected)
  109: 
  110:         # optionally, object
  111:         result = np.asarray(idx, dtype=object)
  112: 
  113:         expected = np.array([Timestamp("2000-01-01"), Timestamp("2000-01-02")])
  114:         tm.assert_numpy_array_equal(result, expected)
  115: 
  116:     def test_asarray_tz_aware(self):
  117:         tz = "US/Central"
  118:         idx = date_range("2000", periods=2, tz=tz)
  119:         expected = np.array(["2000-01-01T06", "2000-01-02T06"], dtype="M8[ns]")
  120:         result = np.asarray(idx, dtype="datetime64[ns]")
  121: 
  122:         tm.assert_numpy_array_equal(result, expected)
  123: 
  124:         # Old behavior with no warning
  125:         result = np.asarray(idx, dtype="M8[ns]")
  126: 
  127:         tm.assert_numpy_array_equal(result, expected)
  128: 
  129:         # Future behavior with no warning
  130:         expected = np.array(
  131:             [Timestamp("2000-01-01", tz=tz), Timestamp("2000-01-02", tz=tz)]
  132:         )
  133:         result = np.asarray(idx, dtype=object)
  134: 
  135:         tm.assert_numpy_array_equal(result, expected)
  136: 
  137:     def test_CBH_deprecated(self):
  138:         msg = "'CBH' is deprecated and will be removed in a future version."
  139: 
  140:         with tm.assert_produces_warning(FutureWarning, match=msg):
  141:             expected = date_range(
  142:                 dt.datetime(2022, 12, 11), dt.datetime(2022, 12, 13), freq="CBH"
  143:             )
  144:         result = DatetimeIndex(
  145:             [
  146:                 "2022-12-12 09:00:00",
  147:                 "2022-12-12 10:00:00",
  148:                 "2022-12-12 11:00:00",
  149:                 "2022-12-12 12:00:00",
  150:                 "2022-12-12 13:00:00",
  151:                 "2022-12-12 14:00:00",
  152:                 "2022-12-12 15:00:00",
  153:                 "2022-12-12 16:00:00",
  154:             ],
  155:             dtype="datetime64[ns]",
  156:             freq="cbh",
  157:         )
  158: 
  159:         tm.assert_index_equal(result, expected)
  160: 
  161:     @pytest.mark.parametrize(
  162:         "freq_depr, expected_values, expected_freq",
  163:         [
  164:             (
  165:                 "AS-AUG",
  166:                 ["2021-08-01", "2022-08-01", "2023-08-01"],
  167:                 "YS-AUG",
  168:             ),
  169:             (
  170:                 "1BAS-MAY",
  171:                 ["2021-05-03", "2022-05-02", "2023-05-01"],
  172:                 "1BYS-MAY",
  173:             ),
  174:         ],
  175:     )
  176:     def test_AS_BAS_deprecated(self, freq_depr, expected_values, expected_freq):
  177:         # GH#55479
  178:         freq_msg = re.split("[0-9]*", freq_depr, maxsplit=1)[1]
  179:         msg = f"'{freq_msg}' is deprecated and will be removed in a future version."
  180: 
  181:         with tm.assert_produces_warning(FutureWarning, match=msg):
  182:             expected = date_range(
  183:                 dt.datetime(2020, 12, 1), dt.datetime(2023, 12, 1), freq=freq_depr
  184:             )
  185:         result = DatetimeIndex(
  186:             expected_values,
  187:             dtype="datetime64[ns]",
  188:             freq=expected_freq,
  189:         )
  190: 
  191:         tm.assert_index_equal(result, expected)
  192: 
  193:     @pytest.mark.parametrize(
  194:         "freq, expected_values, freq_depr",
  195:         [
  196:             ("2BYE-MAR", ["2016-03-31"], "2BA-MAR"),
  197:             ("2BYE-JUN", ["2016-06-30"], "2BY-JUN"),
  198:             ("2BME", ["2016-02-29", "2016-04-29", "2016-06-30"], "2BM"),
  199:             ("2BQE", ["2016-03-31"], "2BQ"),
  200:             ("1BQE-MAR", ["2016-03-31", "2016-06-30"], "1BQ-MAR"),
  201:         ],
  202:     )
  203:     def test_BM_BQ_BY_deprecated(self, freq, expected_values, freq_depr):
  204:         # GH#52064
  205:         msg = f"'{freq_depr[1:]}' is deprecated and will be removed "
  206:         f"in a future version, please use '{freq[1:]}' instead."
  207: 
  208:         with tm.assert_produces_warning(FutureWarning, match=msg):
  209:             expected = date_range(start="2016-02-21", end="2016-08-21", freq=freq_depr)
  210:         result = DatetimeIndex(
  211:             data=expected_values,
  212:             dtype="datetime64[ns]",
  213:             freq=freq,
  214:         )
  215: 
  216:         tm.assert_index_equal(result, expected)
