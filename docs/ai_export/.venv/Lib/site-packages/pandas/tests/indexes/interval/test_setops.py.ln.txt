    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas import (
    5:     Index,
    6:     IntervalIndex,
    7:     Timestamp,
    8:     interval_range,
    9: )
   10: import pandas._testing as tm
   11: 
   12: 
   13: def monotonic_index(start, end, dtype="int64", closed="right"):
   14:     return IntervalIndex.from_breaks(np.arange(start, end, dtype=dtype), closed=closed)
   15: 
   16: 
   17: def empty_index(dtype="int64", closed="right"):
   18:     return IntervalIndex(np.array([], dtype=dtype), closed=closed)
   19: 
   20: 
   21: class TestIntervalIndex:
   22:     def test_union(self, closed, sort):
   23:         index = monotonic_index(0, 11, closed=closed)
   24:         other = monotonic_index(5, 13, closed=closed)
   25: 
   26:         expected = monotonic_index(0, 13, closed=closed)
   27:         result = index[::-1].union(other, sort=sort)
   28:         if sort in (None, True):
   29:             tm.assert_index_equal(result, expected)
   30:         else:
   31:             tm.assert_index_equal(result.sort_values(), expected)
   32: 
   33:         result = other[::-1].union(index, sort=sort)
   34:         if sort in (None, True):
   35:             tm.assert_index_equal(result, expected)
   36:         else:
   37:             tm.assert_index_equal(result.sort_values(), expected)
   38: 
   39:         tm.assert_index_equal(index.union(index, sort=sort), index)
   40:         tm.assert_index_equal(index.union(index[:1], sort=sort), index)
   41: 
   42:     def test_union_empty_result(self, closed, sort):
   43:         # GH 19101: empty result, same dtype
   44:         index = empty_index(dtype="int64", closed=closed)
   45:         result = index.union(index, sort=sort)
   46:         tm.assert_index_equal(result, index)
   47: 
   48:         # GH 19101: empty result, different numeric dtypes -> common dtype is f8
   49:         other = empty_index(dtype="float64", closed=closed)
   50:         result = index.union(other, sort=sort)
   51:         expected = other
   52:         tm.assert_index_equal(result, expected)
   53: 
   54:         other = index.union(index, sort=sort)
   55:         tm.assert_index_equal(result, expected)
   56: 
   57:         other = empty_index(dtype="uint64", closed=closed)
   58:         result = index.union(other, sort=sort)
   59:         tm.assert_index_equal(result, expected)
   60: 
   61:         result = other.union(index, sort=sort)
   62:         tm.assert_index_equal(result, expected)
   63: 
   64:     def test_intersection(self, closed, sort):
   65:         index = monotonic_index(0, 11, closed=closed)
   66:         other = monotonic_index(5, 13, closed=closed)
   67: 
   68:         expected = monotonic_index(5, 11, closed=closed)
   69:         result = index[::-1].intersection(other, sort=sort)
   70:         if sort in (None, True):
   71:             tm.assert_index_equal(result, expected)
   72:         else:
   73:             tm.assert_index_equal(result.sort_values(), expected)
   74: 
   75:         result = other[::-1].intersection(index, sort=sort)
   76:         if sort in (None, True):
   77:             tm.assert_index_equal(result, expected)
   78:         else:
   79:             tm.assert_index_equal(result.sort_values(), expected)
   80: 
   81:         tm.assert_index_equal(index.intersection(index, sort=sort), index)
   82: 
   83:         # GH 26225: nested intervals
   84:         index = IntervalIndex.from_tuples([(1, 2), (1, 3), (1, 4), (0, 2)])
   85:         other = IntervalIndex.from_tuples([(1, 2), (1, 3)])
   86:         expected = IntervalIndex.from_tuples([(1, 2), (1, 3)])
   87:         result = index.intersection(other)
   88:         tm.assert_index_equal(result, expected)
   89: 
   90:         # GH 26225
   91:         index = IntervalIndex.from_tuples([(0, 3), (0, 2)])
   92:         other = IntervalIndex.from_tuples([(0, 2), (1, 3)])
   93:         expected = IntervalIndex.from_tuples([(0, 2)])
   94:         result = index.intersection(other)
   95:         tm.assert_index_equal(result, expected)
   96: 
   97:         # GH 26225: duplicate nan element
   98:         index = IntervalIndex([np.nan, np.nan])
   99:         other = IntervalIndex([np.nan])
  100:         expected = IntervalIndex([np.nan])
  101:         result = index.intersection(other)
  102:         tm.assert_index_equal(result, expected)
  103: 
  104:     def test_intersection_empty_result(self, closed, sort):
  105:         index = monotonic_index(0, 11, closed=closed)
  106: 
  107:         # GH 19101: empty result, same dtype
  108:         other = monotonic_index(300, 314, closed=closed)
  109:         expected = empty_index(dtype="int64", closed=closed)
  110:         result = index.intersection(other, sort=sort)
  111:         tm.assert_index_equal(result, expected)
  112: 
  113:         # GH 19101: empty result, different numeric dtypes -> common dtype is float64
  114:         other = monotonic_index(300, 314, dtype="float64", closed=closed)
  115:         result = index.intersection(other, sort=sort)
  116:         expected = other[:0]
  117:         tm.assert_index_equal(result, expected)
  118: 
  119:         other = monotonic_index(300, 314, dtype="uint64", closed=closed)
  120:         result = index.intersection(other, sort=sort)
  121:         tm.assert_index_equal(result, expected)
  122: 
  123:     def test_intersection_duplicates(self):
  124:         # GH#38743
  125:         index = IntervalIndex.from_tuples([(1, 2), (1, 2), (2, 3), (3, 4)])
  126:         other = IntervalIndex.from_tuples([(1, 2), (2, 3)])
  127:         expected = IntervalIndex.from_tuples([(1, 2), (2, 3)])
  128:         result = index.intersection(other)
  129:         tm.assert_index_equal(result, expected)
  130: 
  131:     def test_difference(self, closed, sort):
  132:         index = IntervalIndex.from_arrays([1, 0, 3, 2], [1, 2, 3, 4], closed=closed)
  133:         result = index.difference(index[:1], sort=sort)
  134:         expected = index[1:]
  135:         if sort is None:
  136:             expected = expected.sort_values()
  137:         tm.assert_index_equal(result, expected)
  138: 
  139:         # GH 19101: empty result, same dtype
  140:         result = index.difference(index, sort=sort)
  141:         expected = empty_index(dtype="int64", closed=closed)
  142:         tm.assert_index_equal(result, expected)
  143: 
  144:         # GH 19101: empty result, different dtypes
  145:         other = IntervalIndex.from_arrays(
  146:             index.left.astype("float64"), index.right, closed=closed
  147:         )
  148:         result = index.difference(other, sort=sort)
  149:         tm.assert_index_equal(result, expected)
  150: 
  151:     def test_symmetric_difference(self, closed, sort):
  152:         index = monotonic_index(0, 11, closed=closed)
  153:         result = index[1:].symmetric_difference(index[:-1], sort=sort)
  154:         expected = IntervalIndex([index[0], index[-1]])
  155:         if sort in (None, True):
  156:             tm.assert_index_equal(result, expected)
  157:         else:
  158:             tm.assert_index_equal(result.sort_values(), expected)
  159: 
  160:         # GH 19101: empty result, same dtype
  161:         result = index.symmetric_difference(index, sort=sort)
  162:         expected = empty_index(dtype="int64", closed=closed)
  163:         if sort in (None, True):
  164:             tm.assert_index_equal(result, expected)
  165:         else:
  166:             tm.assert_index_equal(result.sort_values(), expected)
  167: 
  168:         # GH 19101: empty result, different dtypes
  169:         other = IntervalIndex.from_arrays(
  170:             index.left.astype("float64"), index.right, closed=closed
  171:         )
  172:         result = index.symmetric_difference(other, sort=sort)
  173:         expected = empty_index(dtype="float64", closed=closed)
  174:         tm.assert_index_equal(result, expected)
  175: 
  176:     @pytest.mark.filterwarnings("ignore:'<' not supported between:RuntimeWarning")
  177:     @pytest.mark.parametrize(
  178:         "op_name", ["union", "intersection", "difference", "symmetric_difference"]
  179:     )
  180:     def test_set_incompatible_types(self, closed, op_name, sort):
  181:         index = monotonic_index(0, 11, closed=closed)
  182:         set_op = getattr(index, op_name)
  183: 
  184:         # TODO: standardize return type of non-union setops type(self vs other)
  185:         # non-IntervalIndex
  186:         if op_name == "difference":
  187:             expected = index
  188:         else:
  189:             expected = getattr(index.astype("O"), op_name)(Index([1, 2, 3]))
  190:         result = set_op(Index([1, 2, 3]), sort=sort)
  191:         tm.assert_index_equal(result, expected)
  192: 
  193:         # mixed closed -> cast to object
  194:         for other_closed in {"right", "left", "both", "neither"} - {closed}:
  195:             other = monotonic_index(0, 11, closed=other_closed)
  196:             expected = getattr(index.astype(object), op_name)(other, sort=sort)
  197:             if op_name == "difference":
  198:                 expected = index
  199:             result = set_op(other, sort=sort)
  200:             tm.assert_index_equal(result, expected)
  201: 
  202:         # GH 19016: incompatible dtypes -> cast to object
  203:         other = interval_range(Timestamp("20180101"), periods=9, closed=closed)
  204:         expected = getattr(index.astype(object), op_name)(other, sort=sort)
  205:         if op_name == "difference":
  206:             expected = index
  207:         result = set_op(other, sort=sort)
  208:         tm.assert_index_equal(result, expected)
