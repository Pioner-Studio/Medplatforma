    1: """
    2: Tests for DatetimeIndex methods behaving like their Timestamp counterparts
    3: """
    4: 
    5: import calendar
    6: from datetime import (
    7:     date,
    8:     datetime,
    9:     time,
   10: )
   11: import locale
   12: import unicodedata
   13: 
   14: import numpy as np
   15: import pytest
   16: 
   17: from pandas._libs.tslibs import timezones
   18: 
   19: from pandas import (
   20:     DatetimeIndex,
   21:     Index,
   22:     NaT,
   23:     Timestamp,
   24:     date_range,
   25:     offsets,
   26: )
   27: import pandas._testing as tm
   28: from pandas.core.arrays import DatetimeArray
   29: 
   30: 
   31: class TestDatetimeIndexOps:
   32:     def test_dti_no_millisecond_field(self):
   33:         msg = "type object 'DatetimeIndex' has no attribute 'millisecond'"
   34:         with pytest.raises(AttributeError, match=msg):
   35:             DatetimeIndex.millisecond
   36: 
   37:         msg = "'DatetimeIndex' object has no attribute 'millisecond'"
   38:         with pytest.raises(AttributeError, match=msg):
   39:             DatetimeIndex([]).millisecond
   40: 
   41:     def test_dti_time(self):
   42:         rng = date_range("1/1/2000", freq="12min", periods=10)
   43:         result = Index(rng).time
   44:         expected = [t.time() for t in rng]
   45:         assert (result == expected).all()
   46: 
   47:     def test_dti_date(self):
   48:         rng = date_range("1/1/2000", freq="12h", periods=10)
   49:         result = Index(rng).date
   50:         expected = [t.date() for t in rng]
   51:         assert (result == expected).all()
   52: 
   53:     @pytest.mark.parametrize(
   54:         "dtype",
   55:         [None, "datetime64[ns, CET]", "datetime64[ns, EST]", "datetime64[ns, UTC]"],
   56:     )
   57:     def test_dti_date2(self, dtype):
   58:         # Regression test for GH#21230
   59:         expected = np.array([date(2018, 6, 4), NaT])
   60: 
   61:         index = DatetimeIndex(["2018-06-04 10:00:00", NaT], dtype=dtype)
   62:         result = index.date
   63: 
   64:         tm.assert_numpy_array_equal(result, expected)
   65: 
   66:     @pytest.mark.parametrize(
   67:         "dtype",
   68:         [None, "datetime64[ns, CET]", "datetime64[ns, EST]", "datetime64[ns, UTC]"],
   69:     )
   70:     def test_dti_time2(self, dtype):
   71:         # Regression test for GH#21267
   72:         expected = np.array([time(10, 20, 30), NaT])
   73: 
   74:         index = DatetimeIndex(["2018-06-04 10:20:30", NaT], dtype=dtype)
   75:         result = index.time
   76: 
   77:         tm.assert_numpy_array_equal(result, expected)
   78: 
   79:     def test_dti_timetz(self, tz_naive_fixture):
   80:         # GH#21358
   81:         tz = timezones.maybe_get_tz(tz_naive_fixture)
   82: 
   83:         expected = np.array([time(10, 20, 30, tzinfo=tz), NaT])
   84: 
   85:         index = DatetimeIndex(["2018-06-04 10:20:30", NaT], tz=tz)
   86:         result = index.timetz
   87: 
   88:         tm.assert_numpy_array_equal(result, expected)
   89: 
   90:     @pytest.mark.parametrize(
   91:         "field",
   92:         [
   93:             "dayofweek",
   94:             "day_of_week",
   95:             "dayofyear",
   96:             "day_of_year",
   97:             "quarter",
   98:             "days_in_month",
   99:             "is_month_start",
  100:             "is_month_end",
  101:             "is_quarter_start",
  102:             "is_quarter_end",
  103:             "is_year_start",
  104:             "is_year_end",
  105:         ],
  106:     )
  107:     def test_dti_timestamp_fields(self, field):
  108:         # extra fields from DatetimeIndex like quarter and week
  109:         idx = date_range("2020-01-01", periods=10)
  110:         expected = getattr(idx, field)[-1]
  111: 
  112:         result = getattr(Timestamp(idx[-1]), field)
  113:         assert result == expected
  114: 
  115:     def test_dti_nanosecond(self):
  116:         dti = DatetimeIndex(np.arange(10))
  117:         expected = Index(np.arange(10, dtype=np.int32))
  118: 
  119:         tm.assert_index_equal(dti.nanosecond, expected)
  120: 
  121:     @pytest.mark.parametrize("prefix", ["", "dateutil/"])
  122:     def test_dti_hour_tzaware(self, prefix):
  123:         strdates = ["1/1/2012", "3/1/2012", "4/1/2012"]
  124:         rng = DatetimeIndex(strdates, tz=prefix + "US/Eastern")
  125:         assert (rng.hour == 0).all()
  126: 
  127:         # a more unusual time zone, GH#1946
  128:         dr = date_range(
  129:             "2011-10-02 00:00", freq="h", periods=10, tz=prefix + "America/Atikokan"
  130:         )
  131: 
  132:         expected = Index(np.arange(10, dtype=np.int32))
  133:         tm.assert_index_equal(dr.hour, expected)
  134: 
  135:     # GH#12806
  136:     # error: Unsupported operand types for + ("List[None]" and "List[str]")
  137:     @pytest.mark.parametrize(
  138:         "time_locale", [None] + tm.get_locales()  # type: ignore[operator]
  139:     )
  140:     def test_day_name_month_name(self, time_locale):
  141:         # Test Monday -> Sunday and January -> December, in that sequence
  142:         if time_locale is None:
  143:             # If the time_locale is None, day-name and month_name should
  144:             # return the english attributes
  145:             expected_days = [
  146:                 "Monday",
  147:                 "Tuesday",
  148:                 "Wednesday",
  149:                 "Thursday",
  150:                 "Friday",
  151:                 "Saturday",
  152:                 "Sunday",
  153:             ]
  154:             expected_months = [
  155:                 "January",
  156:                 "February",
  157:                 "March",
  158:                 "April",
  159:                 "May",
  160:                 "June",
  161:                 "July",
  162:                 "August",
  163:                 "September",
  164:                 "October",
  165:                 "November",
  166:                 "December",
  167:             ]
  168:         else:
  169:             with tm.set_locale(time_locale, locale.LC_TIME):
  170:                 expected_days = calendar.day_name[:]
  171:                 expected_months = calendar.month_name[1:]
  172: 
  173:         # GH#11128
  174:         dti = date_range(freq="D", start=datetime(1998, 1, 1), periods=365)
  175:         english_days = [
  176:             "Monday",
  177:             "Tuesday",
  178:             "Wednesday",
  179:             "Thursday",
  180:             "Friday",
  181:             "Saturday",
  182:             "Sunday",
  183:         ]
  184:         for day, name, eng_name in zip(range(4, 11), expected_days, english_days):
  185:             name = name.capitalize()
  186:             assert dti.day_name(locale=time_locale)[day] == name
  187:             assert dti.day_name(locale=None)[day] == eng_name
  188:             ts = Timestamp(datetime(2016, 4, day))
  189:             assert ts.day_name(locale=time_locale) == name
  190:         dti = dti.append(DatetimeIndex([NaT]))
  191:         assert np.isnan(dti.day_name(locale=time_locale)[-1])
  192:         ts = Timestamp(NaT)
  193:         assert np.isnan(ts.day_name(locale=time_locale))
  194: 
  195:         # GH#12805
  196:         dti = date_range(freq="ME", start="2012", end="2013")
  197:         result = dti.month_name(locale=time_locale)
  198:         expected = Index([month.capitalize() for month in expected_months])
  199: 
  200:         # work around different normalization schemes GH#22342
  201:         result = result.str.normalize("NFD")
  202:         expected = expected.str.normalize("NFD")
  203: 
  204:         tm.assert_index_equal(result, expected)
  205: 
  206:         for item, expected in zip(dti, expected_months):
  207:             result = item.month_name(locale=time_locale)
  208:             expected = expected.capitalize()
  209: 
  210:             result = unicodedata.normalize("NFD", result)
  211:             expected = unicodedata.normalize("NFD", result)
  212: 
  213:             assert result == expected
  214:         dti = dti.append(DatetimeIndex([NaT]))
  215:         assert np.isnan(dti.month_name(locale=time_locale)[-1])
  216: 
  217:     def test_dti_week(self):
  218:         # GH#6538: Check that DatetimeIndex and its TimeStamp elements
  219:         # return the same weekofyear accessor close to new year w/ tz
  220:         dates = ["2013/12/29", "2013/12/30", "2013/12/31"]
  221:         dates = DatetimeIndex(dates, tz="Europe/Brussels")
  222:         expected = [52, 1, 1]
  223:         assert dates.isocalendar().week.tolist() == expected
  224:         assert [d.weekofyear for d in dates] == expected
  225: 
  226:     @pytest.mark.parametrize("tz", [None, "US/Eastern"])
  227:     def test_dti_fields(self, tz):
  228:         # GH#13303
  229:         dti = date_range(freq="D", start=datetime(1998, 1, 1), periods=365, tz=tz)
  230:         assert dti.year[0] == 1998
  231:         assert dti.month[0] == 1
  232:         assert dti.day[0] == 1
  233:         assert dti.hour[0] == 0
  234:         assert dti.minute[0] == 0
  235:         assert dti.second[0] == 0
  236:         assert dti.microsecond[0] == 0
  237:         assert dti.dayofweek[0] == 3
  238: 
  239:         assert dti.dayofyear[0] == 1
  240:         assert dti.dayofyear[120] == 121
  241: 
  242:         assert dti.isocalendar().week.iloc[0] == 1
  243:         assert dti.isocalendar().week.iloc[120] == 18
  244: 
  245:         assert dti.quarter[0] == 1
  246:         assert dti.quarter[120] == 2
  247: 
  248:         assert dti.days_in_month[0] == 31
  249:         assert dti.days_in_month[90] == 30
  250: 
  251:         assert dti.is_month_start[0]
  252:         assert not dti.is_month_start[1]
  253:         assert dti.is_month_start[31]
  254:         assert dti.is_quarter_start[0]
  255:         assert dti.is_quarter_start[90]
  256:         assert dti.is_year_start[0]
  257:         assert not dti.is_year_start[364]
  258:         assert not dti.is_month_end[0]
  259:         assert dti.is_month_end[30]
  260:         assert not dti.is_month_end[31]
  261:         assert dti.is_month_end[364]
  262:         assert not dti.is_quarter_end[0]
  263:         assert not dti.is_quarter_end[30]
  264:         assert dti.is_quarter_end[89]
  265:         assert dti.is_quarter_end[364]
  266:         assert not dti.is_year_end[0]
  267:         assert dti.is_year_end[364]
  268: 
  269:         assert len(dti.year) == 365
  270:         assert len(dti.month) == 365
  271:         assert len(dti.day) == 365
  272:         assert len(dti.hour) == 365
  273:         assert len(dti.minute) == 365
  274:         assert len(dti.second) == 365
  275:         assert len(dti.microsecond) == 365
  276:         assert len(dti.dayofweek) == 365
  277:         assert len(dti.dayofyear) == 365
  278:         assert len(dti.isocalendar()) == 365
  279:         assert len(dti.quarter) == 365
  280:         assert len(dti.is_month_start) == 365
  281:         assert len(dti.is_month_end) == 365
  282:         assert len(dti.is_quarter_start) == 365
  283:         assert len(dti.is_quarter_end) == 365
  284:         assert len(dti.is_year_start) == 365
  285:         assert len(dti.is_year_end) == 365
  286: 
  287:         dti.name = "name"
  288: 
  289:         # non boolean accessors -> return Index
  290:         for accessor in DatetimeArray._field_ops:
  291:             res = getattr(dti, accessor)
  292:             assert len(res) == 365
  293:             assert isinstance(res, Index)
  294:             assert res.name == "name"
  295: 
  296:         # boolean accessors -> return array
  297:         for accessor in DatetimeArray._bool_ops:
  298:             res = getattr(dti, accessor)
  299:             assert len(res) == 365
  300:             assert isinstance(res, np.ndarray)
  301: 
  302:         # test boolean indexing
  303:         res = dti[dti.is_quarter_start]
  304:         exp = dti[[0, 90, 181, 273]]
  305:         tm.assert_index_equal(res, exp)
  306:         res = dti[dti.is_leap_year]
  307:         exp = DatetimeIndex([], freq="D", tz=dti.tz, name="name").as_unit("ns")
  308:         tm.assert_index_equal(res, exp)
  309: 
  310:     def test_dti_is_year_quarter_start(self):
  311:         dti = date_range(freq="BQE-FEB", start=datetime(1998, 1, 1), periods=4)
  312: 
  313:         assert sum(dti.is_quarter_start) == 0
  314:         assert sum(dti.is_quarter_end) == 4
  315:         assert sum(dti.is_year_start) == 0
  316:         assert sum(dti.is_year_end) == 1
  317: 
  318:     def test_dti_is_month_start(self):
  319:         dti = DatetimeIndex(["2000-01-01", "2000-01-02", "2000-01-03"])
  320: 
  321:         assert dti.is_month_start[0] == 1
  322: 
  323:     def test_dti_is_month_start_custom(self):
  324:         # Ensure is_start/end accessors throw ValueError for CustomBusinessDay,
  325:         bday_egypt = offsets.CustomBusinessDay(weekmask="Sun Mon Tue Wed Thu")
  326:         dti = date_range(datetime(2013, 4, 30), periods=5, freq=bday_egypt)
  327:         msg = "Custom business days is not supported by is_month_start"
  328:         with pytest.raises(ValueError, match=msg):
  329:             dti.is_month_start
