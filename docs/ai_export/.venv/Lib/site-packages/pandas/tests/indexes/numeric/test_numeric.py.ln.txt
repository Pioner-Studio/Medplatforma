    1: import numpy as np
    2: import pytest
    3: 
    4: import pandas as pd
    5: from pandas import (
    6:     Index,
    7:     Series,
    8: )
    9: import pandas._testing as tm
   10: 
   11: 
   12: class TestFloatNumericIndex:
   13:     @pytest.fixture(params=[np.float64, np.float32])
   14:     def dtype(self, request):
   15:         return request.param
   16: 
   17:     @pytest.fixture
   18:     def simple_index(self, dtype):
   19:         values = np.arange(5, dtype=dtype)
   20:         return Index(values)
   21: 
   22:     @pytest.fixture(
   23:         params=[
   24:             [1.5, 2, 3, 4, 5],
   25:             [0.0, 2.5, 5.0, 7.5, 10.0],
   26:             [5, 4, 3, 2, 1.5],
   27:             [10.0, 7.5, 5.0, 2.5, 0.0],
   28:         ],
   29:         ids=["mixed", "float", "mixed_dec", "float_dec"],
   30:     )
   31:     def index(self, request, dtype):
   32:         return Index(request.param, dtype=dtype)
   33: 
   34:     @pytest.fixture
   35:     def mixed_index(self, dtype):
   36:         return Index([1.5, 2, 3, 4, 5], dtype=dtype)
   37: 
   38:     @pytest.fixture
   39:     def float_index(self, dtype):
   40:         return Index([0.0, 2.5, 5.0, 7.5, 10.0], dtype=dtype)
   41: 
   42:     def test_repr_roundtrip(self, index):
   43:         tm.assert_index_equal(eval(repr(index)), index, exact=True)
   44: 
   45:     def check_coerce(self, a, b, is_float_index=True):
   46:         assert a.equals(b)
   47:         tm.assert_index_equal(a, b, exact=False)
   48:         if is_float_index:
   49:             assert isinstance(b, Index)
   50:         else:
   51:             assert type(b) is Index
   52: 
   53:     def test_constructor_from_list_no_dtype(self):
   54:         index = Index([1.5, 2.5, 3.5])
   55:         assert index.dtype == np.float64
   56: 
   57:     def test_constructor(self, dtype):
   58:         index_cls = Index
   59: 
   60:         # explicit construction
   61:         index = index_cls([1, 2, 3, 4, 5], dtype=dtype)
   62: 
   63:         assert isinstance(index, index_cls)
   64:         assert index.dtype == dtype
   65: 
   66:         expected = np.array([1, 2, 3, 4, 5], dtype=dtype)
   67:         tm.assert_numpy_array_equal(index.values, expected)
   68: 
   69:         index = index_cls(np.array([1, 2, 3, 4, 5]), dtype=dtype)
   70:         assert isinstance(index, index_cls)
   71:         assert index.dtype == dtype
   72: 
   73:         index = index_cls([1.0, 2, 3, 4, 5], dtype=dtype)
   74:         assert isinstance(index, index_cls)
   75:         assert index.dtype == dtype
   76: 
   77:         index = index_cls(np.array([1.0, 2, 3, 4, 5]), dtype=dtype)
   78:         assert isinstance(index, index_cls)
   79:         assert index.dtype == dtype
   80: 
   81:         index = index_cls([1.0, 2, 3, 4, 5], dtype=dtype)
   82:         assert isinstance(index, index_cls)
   83:         assert index.dtype == dtype
   84: 
   85:         index = index_cls(np.array([1.0, 2, 3, 4, 5]), dtype=dtype)
   86:         assert isinstance(index, index_cls)
   87:         assert index.dtype == dtype
   88: 
   89:         # nan handling
   90:         result = index_cls([np.nan, np.nan], dtype=dtype)
   91:         assert pd.isna(result.values).all()
   92: 
   93:         result = index_cls(np.array([np.nan]), dtype=dtype)
   94:         assert pd.isna(result.values).all()
   95: 
   96:     def test_constructor_invalid(self):
   97:         index_cls = Index
   98:         cls_name = index_cls.__name__
   99:         # invalid
  100:         msg = (
  101:             rf"{cls_name}\(\.\.\.\) must be called with a collection of "
  102:             r"some kind, 0\.0 was passed"
  103:         )
  104:         with pytest.raises(TypeError, match=msg):
  105:             index_cls(0.0)
  106: 
  107:     def test_constructor_coerce(self, mixed_index, float_index):
  108:         self.check_coerce(mixed_index, Index([1.5, 2, 3, 4, 5]))
  109:         self.check_coerce(float_index, Index(np.arange(5) * 2.5))
  110: 
  111:         result = Index(np.array(np.arange(5) * 2.5, dtype=object))
  112:         assert result.dtype == object  # as of 2.0 to match Series
  113:         self.check_coerce(float_index, result.astype("float64"))
  114: 
  115:     def test_constructor_explicit(self, mixed_index, float_index):
  116:         # these don't auto convert
  117:         self.check_coerce(
  118:             float_index, Index((np.arange(5) * 2.5), dtype=object), is_float_index=False
  119:         )
  120:         self.check_coerce(
  121:             mixed_index, Index([1.5, 2, 3, 4, 5], dtype=object), is_float_index=False
  122:         )
  123: 
  124:     def test_type_coercion_fail(self, any_int_numpy_dtype):
  125:         # see gh-15832
  126:         msg = "Trying to coerce float values to integers"
  127:         with pytest.raises(ValueError, match=msg):
  128:             Index([1, 2, 3.5], dtype=any_int_numpy_dtype)
  129: 
  130:     def test_equals_numeric(self):
  131:         index_cls = Index
  132: 
  133:         idx = index_cls([1.0, 2.0])
  134:         assert idx.equals(idx)
  135:         assert idx.identical(idx)
  136: 
  137:         idx2 = index_cls([1.0, 2.0])
  138:         assert idx.equals(idx2)
  139: 
  140:         idx = index_cls([1.0, np.nan])
  141:         assert idx.equals(idx)
  142:         assert idx.identical(idx)
  143: 
  144:         idx2 = index_cls([1.0, np.nan])
  145:         assert idx.equals(idx2)
  146: 
  147:     @pytest.mark.parametrize(
  148:         "other",
  149:         (
  150:             Index([1, 2], dtype=np.int64),
  151:             Index([1.0, 2.0], dtype=object),
  152:             Index([1, 2], dtype=object),
  153:         ),
  154:     )
  155:     def test_equals_numeric_other_index_type(self, other):
  156:         idx = Index([1.0, 2.0])
  157:         assert idx.equals(other)
  158:         assert other.equals(idx)
  159: 
  160:     @pytest.mark.parametrize(
  161:         "vals",
  162:         [
  163:             pd.date_range("2016-01-01", periods=3),
  164:             pd.timedelta_range("1 Day", periods=3),
  165:         ],
  166:     )
  167:     def test_lookups_datetimelike_values(self, vals, dtype):
  168:         # If we have datetime64 or timedelta64 values, make sure they are
  169:         #  wrapped correctly  GH#31163
  170:         ser = Series(vals, index=range(3, 6))
  171:         ser.index = ser.index.astype(dtype)
  172: 
  173:         expected = vals[1]
  174: 
  175:         result = ser[4.0]
  176:         assert isinstance(result, type(expected)) and result == expected
  177:         result = ser[4]
  178:         assert isinstance(result, type(expected)) and result == expected
  179: 
  180:         result = ser.loc[4.0]
  181:         assert isinstance(result, type(expected)) and result == expected
  182:         result = ser.loc[4]
  183:         assert isinstance(result, type(expected)) and result == expected
  184: 
  185:         result = ser.at[4.0]
  186:         assert isinstance(result, type(expected)) and result == expected
  187:         # GH#31329 .at[4] should cast to 4.0, matching .loc behavior
  188:         result = ser.at[4]
  189:         assert isinstance(result, type(expected)) and result == expected
  190: 
  191:         result = ser.iloc[1]
  192:         assert isinstance(result, type(expected)) and result == expected
  193: 
  194:         result = ser.iat[1]
  195:         assert isinstance(result, type(expected)) and result == expected
  196: 
  197:     def test_doesnt_contain_all_the_things(self):
  198:         idx = Index([np.nan])
  199:         assert not idx.isin([0]).item()
  200:         assert not idx.isin([1]).item()
  201:         assert idx.isin([np.nan]).item()
  202: 
  203:     def test_nan_multiple_containment(self):
  204:         index_cls = Index
  205: 
  206:         idx = index_cls([1.0, np.nan])
  207:         tm.assert_numpy_array_equal(idx.isin([1.0]), np.array([True, False]))
  208:         tm.assert_numpy_array_equal(idx.isin([2.0, np.pi]), np.array([False, False]))
  209:         tm.assert_numpy_array_equal(idx.isin([np.nan]), np.array([False, True]))
  210:         tm.assert_numpy_array_equal(idx.isin([1.0, np.nan]), np.array([True, True]))
  211:         idx = index_cls([1.0, 2.0])
  212:         tm.assert_numpy_array_equal(idx.isin([np.nan]), np.array([False, False]))
  213: 
  214:     def test_fillna_float64(self):
  215:         index_cls = Index
  216:         # GH 11343
  217:         idx = Index([1.0, np.nan, 3.0], dtype=float, name="x")
  218:         # can't downcast
  219:         exp = Index([1.0, 0.1, 3.0], name="x")
  220:         tm.assert_index_equal(idx.fillna(0.1), exp, exact=True)
  221: 
  222:         # downcast
  223:         exp = index_cls([1.0, 2.0, 3.0], name="x")
  224:         tm.assert_index_equal(idx.fillna(2), exp)
  225: 
  226:         # object
  227:         exp = Index([1.0, "obj", 3.0], name="x")
  228:         tm.assert_index_equal(idx.fillna("obj"), exp, exact=True)
  229: 
  230:     def test_logical_compat(self, simple_index):
  231:         idx = simple_index
  232:         assert idx.all() == idx.values.all()
  233:         assert idx.any() == idx.values.any()
  234: 
  235:         assert idx.all() == idx.to_series().all()
  236:         assert idx.any() == idx.to_series().any()
  237: 
  238: 
  239: class TestNumericInt:
  240:     @pytest.fixture(params=[np.int64, np.int32, np.int16, np.int8, np.uint64])
  241:     def dtype(self, request):
  242:         return request.param
  243: 
  244:     @pytest.fixture
  245:     def simple_index(self, dtype):
  246:         return Index(range(0, 20, 2), dtype=dtype)
  247: 
  248:     def test_is_monotonic(self):
  249:         index_cls = Index
  250: 
  251:         index = index_cls([1, 2, 3, 4])
  252:         assert index.is_monotonic_increasing is True
  253:         assert index.is_monotonic_increasing is True
  254:         assert index._is_strictly_monotonic_increasing is True
  255:         assert index.is_monotonic_decreasing is False
  256:         assert index._is_strictly_monotonic_decreasing is False
  257: 
  258:         index = index_cls([4, 3, 2, 1])
  259:         assert index.is_monotonic_increasing is False
  260:         assert index._is_strictly_monotonic_increasing is False
  261:         assert index._is_strictly_monotonic_decreasing is True
  262: 
  263:         index = index_cls([1])
  264:         assert index.is_monotonic_increasing is True
  265:         assert index.is_monotonic_increasing is True
  266:         assert index.is_monotonic_decreasing is True
  267:         assert index._is_strictly_monotonic_increasing is True
  268:         assert index._is_strictly_monotonic_decreasing is True
  269: 
  270:     def test_is_strictly_monotonic(self):
  271:         index_cls = Index
  272: 
  273:         index = index_cls([1, 1, 2, 3])
  274:         assert index.is_monotonic_increasing is True
  275:         assert index._is_strictly_monotonic_increasing is False
  276: 
  277:         index = index_cls([3, 2, 1, 1])
  278:         assert index.is_monotonic_decreasing is True
  279:         assert index._is_strictly_monotonic_decreasing is False
  280: 
  281:         index = index_cls([1, 1])
  282:         assert index.is_monotonic_increasing
  283:         assert index.is_monotonic_decreasing
  284:         assert not index._is_strictly_monotonic_increasing
  285:         assert not index._is_strictly_monotonic_decreasing
  286: 
  287:     def test_logical_compat(self, simple_index):
  288:         idx = simple_index
  289:         assert idx.all() == idx.values.all()
  290:         assert idx.any() == idx.values.any()
  291: 
  292:     def test_identical(self, simple_index, dtype):
  293:         index = simple_index
  294: 
  295:         idx = Index(index.copy())
  296:         assert idx.identical(index)
  297: 
  298:         same_values_different_type = Index(idx, dtype=object)
  299:         assert not idx.identical(same_values_different_type)
  300: 
  301:         idx = index.astype(dtype=object)
  302:         idx = idx.rename("foo")
  303:         same_values = Index(idx, dtype=object)
  304:         assert same_values.identical(idx)
  305: 
  306:         assert not idx.identical(index)
  307:         assert Index(same_values, name="foo", dtype=object).identical(idx)
  308: 
  309:         assert not index.astype(dtype=object).identical(index.astype(dtype=dtype))
  310: 
  311:     def test_cant_or_shouldnt_cast(self, dtype):
  312:         msg = r"invalid literal for int\(\) with base 10: 'foo'"
  313: 
  314:         # can't
  315:         data = ["foo", "bar", "baz"]
  316:         with pytest.raises(ValueError, match=msg):
  317:             Index(data, dtype=dtype)
  318: 
  319:     def test_view_index(self, simple_index):
  320:         index = simple_index
  321:         msg = "Passing a type in .*Index.view is deprecated"
  322:         with tm.assert_produces_warning(FutureWarning, match=msg):
  323:             index.view(Index)
  324: 
  325:     def test_prevent_casting(self, simple_index):
  326:         index = simple_index
  327:         result = index.astype("O")
  328:         assert result.dtype == np.object_
  329: 
  330: 
  331: class TestIntNumericIndex:
  332:     @pytest.fixture(params=[np.int64, np.int32, np.int16, np.int8])
  333:     def dtype(self, request):
  334:         return request.param
  335: 
  336:     def test_constructor_from_list_no_dtype(self):
  337:         index = Index([1, 2, 3])
  338:         assert index.dtype == np.int64
  339: 
  340:     def test_constructor(self, dtype):
  341:         index_cls = Index
  342: 
  343:         # scalar raise Exception
  344:         msg = (
  345:             rf"{index_cls.__name__}\(\.\.\.\) must be called with a collection of some "
  346:             "kind, 5 was passed"
  347:         )
  348:         with pytest.raises(TypeError, match=msg):
  349:             index_cls(5)
  350: 
  351:         # copy
  352:         # pass list, coerce fine
  353:         index = index_cls([-5, 0, 1, 2], dtype=dtype)
  354:         arr = index.values.copy()
  355:         new_index = index_cls(arr, copy=True)
  356:         tm.assert_index_equal(new_index, index, exact=True)
  357:         val = int(arr[0]) + 3000
  358: 
  359:         # this should not change index
  360:         if dtype != np.int8:
  361:             # NEP 50 won't allow assignment that would overflow
  362:             arr[0] = val
  363:             assert new_index[0] != val
  364: 
  365:         if dtype == np.int64:
  366:             # pass list, coerce fine
  367:             index = index_cls([-5, 0, 1, 2], dtype=dtype)
  368:             expected = Index([-5, 0, 1, 2], dtype=dtype)
  369:             tm.assert_index_equal(index, expected)
  370: 
  371:             # from iterable
  372:             index = index_cls(iter([-5, 0, 1, 2]), dtype=dtype)
  373:             expected = index_cls([-5, 0, 1, 2], dtype=dtype)
  374:             tm.assert_index_equal(index, expected, exact=True)
  375: 
  376:             # interpret list-like
  377:             expected = index_cls([5, 0], dtype=dtype)
  378:             for cls in [Index, index_cls]:
  379:                 for idx in [
  380:                     cls([5, 0], dtype=dtype),
  381:                     cls(np.array([5, 0]), dtype=dtype),
  382:                     cls(Series([5, 0]), dtype=dtype),
  383:                 ]:
  384:                     tm.assert_index_equal(idx, expected)
  385: 
  386:     def test_constructor_corner(self, dtype):
  387:         index_cls = Index
  388: 
  389:         arr = np.array([1, 2, 3, 4], dtype=object)
  390: 
  391:         index = index_cls(arr, dtype=dtype)
  392:         assert index.values.dtype == index.dtype
  393:         if dtype == np.int64:
  394:             without_dtype = Index(arr)
  395:             # as of 2.0 we do not infer a dtype when we get an object-dtype
  396:             #  ndarray of numbers, matching Series behavior
  397:             assert without_dtype.dtype == object
  398: 
  399:             tm.assert_index_equal(index, without_dtype.astype(np.int64))
  400: 
  401:         # preventing casting
  402:         arr = np.array([1, "2", 3, "4"], dtype=object)
  403:         msg = "Trying to coerce float values to integers"
  404:         with pytest.raises(ValueError, match=msg):
  405:             index_cls(arr, dtype=dtype)
  406: 
  407:     def test_constructor_coercion_signed_to_unsigned(
  408:         self,
  409:         any_unsigned_int_numpy_dtype,
  410:     ):
  411:         # see gh-15832
  412:         msg = "|".join(
  413:             [
  414:                 "Trying to coerce negative values to unsigned integers",
  415:                 "The elements provided in the data cannot all be casted",
  416:             ]
  417:         )
  418:         with pytest.raises(OverflowError, match=msg):
  419:             Index([-1], dtype=any_unsigned_int_numpy_dtype)
  420: 
  421:     def test_constructor_np_signed(self, any_signed_int_numpy_dtype):
  422:         # GH#47475
  423:         scalar = np.dtype(any_signed_int_numpy_dtype).type(1)
  424:         result = Index([scalar])
  425:         expected = Index([1], dtype=any_signed_int_numpy_dtype)
  426:         tm.assert_index_equal(result, expected, exact=True)
  427: 
  428:     def test_constructor_np_unsigned(self, any_unsigned_int_numpy_dtype):
  429:         # GH#47475
  430:         scalar = np.dtype(any_unsigned_int_numpy_dtype).type(1)
  431:         result = Index([scalar])
  432:         expected = Index([1], dtype=any_unsigned_int_numpy_dtype)
  433:         tm.assert_index_equal(result, expected, exact=True)
  434: 
  435:     def test_coerce_list(self):
  436:         # coerce things
  437:         arr = Index([1, 2, 3, 4])
  438:         assert isinstance(arr, Index)
  439: 
  440:         # but not if explicit dtype passed
  441:         arr = Index([1, 2, 3, 4], dtype=object)
  442:         assert type(arr) is Index
  443: 
  444: 
  445: class TestFloat16Index:
  446:     # float 16 indexes not supported
  447:     # GH 49535
  448:     def test_constructor(self):
  449:         index_cls = Index
  450:         dtype = np.float16
  451: 
  452:         msg = "float16 indexes are not supported"
  453: 
  454:         # explicit construction
  455:         with pytest.raises(NotImplementedError, match=msg):
  456:             index_cls([1, 2, 3, 4, 5], dtype=dtype)
  457: 
  458:         with pytest.raises(NotImplementedError, match=msg):
  459:             index_cls(np.array([1, 2, 3, 4, 5]), dtype=dtype)
  460: 
  461:         with pytest.raises(NotImplementedError, match=msg):
  462:             index_cls([1.0, 2, 3, 4, 5], dtype=dtype)
  463: 
  464:         with pytest.raises(NotImplementedError, match=msg):
  465:             index_cls(np.array([1.0, 2, 3, 4, 5]), dtype=dtype)
  466: 
  467:         with pytest.raises(NotImplementedError, match=msg):
  468:             index_cls([1.0, 2, 3, 4, 5], dtype=dtype)
  469: 
  470:         with pytest.raises(NotImplementedError, match=msg):
  471:             index_cls(np.array([1.0, 2, 3, 4, 5]), dtype=dtype)
  472: 
  473:         # nan handling
  474:         with pytest.raises(NotImplementedError, match=msg):
  475:             index_cls([np.nan, np.nan], dtype=dtype)
  476: 
  477:         with pytest.raises(NotImplementedError, match=msg):
  478:             index_cls(np.array([np.nan]), dtype=dtype)
  479: 
  480: 
  481: @pytest.mark.parametrize(
  482:     "box",
  483:     [list, lambda x: np.array(x, dtype=object), lambda x: Index(x, dtype=object)],
  484: )
  485: def test_uint_index_does_not_convert_to_float64(box):
  486:     # https://github.com/pandas-dev/pandas/issues/28279
  487:     # https://github.com/pandas-dev/pandas/issues/28023
  488:     series = Series(
  489:         [0, 1, 2, 3, 4, 5],
  490:         index=[
  491:             7606741985629028552,
  492:             17876870360202815256,
  493:             17876870360202815256,
  494:             13106359306506049338,
  495:             8991270399732411471,
  496:             8991270399732411472,
  497:         ],
  498:     )
  499: 
  500:     result = series.loc[box([7606741985629028552, 17876870360202815256])]
  501: 
  502:     expected = Index(
  503:         [7606741985629028552, 17876870360202815256, 17876870360202815256],
  504:         dtype="uint64",
  505:     )
  506:     tm.assert_index_equal(result.index, expected)
  507: 
  508:     tm.assert_equal(result, series.iloc[:3])
  509: 
  510: 
  511: def test_float64_index_equals():
  512:     # https://github.com/pandas-dev/pandas/issues/35217
  513:     float_index = Index([1.0, 2, 3])
  514:     string_index = Index(["1", "2", "3"])
  515: 
  516:     result = float_index.equals(string_index)
  517:     assert result is False
  518: 
  519:     result = string_index.equals(float_index)
  520:     assert result is False
  521: 
  522: 
  523: def test_map_dtype_inference_unsigned_to_signed():
  524:     # GH#44609 cases where we don't retain dtype
  525:     idx = Index([1, 2, 3], dtype=np.uint64)
  526:     result = idx.map(lambda x: -x)
  527:     expected = Index([-1, -2, -3], dtype=np.int64)
  528:     tm.assert_index_equal(result, expected)
  529: 
  530: 
  531: def test_map_dtype_inference_overflows():
  532:     # GH#44609 case where we have to upcast
  533:     idx = Index(np.array([1, 2, 3], dtype=np.int8))
  534:     result = idx.map(lambda x: x * 1000)
  535:     # TODO: we could plausibly try to infer down to int16 here
  536:     expected = Index([1000, 2000, 3000], dtype=np.int64)
  537:     tm.assert_index_equal(result, expected)
  538: 
  539: 
  540: def test_view_to_datetimelike():
  541:     # GH#55710
  542:     idx = Index([1, 2, 3])
  543:     res = idx.view("m8[s]")
  544:     expected = pd.TimedeltaIndex(idx.values.view("m8[s]"))
  545:     tm.assert_index_equal(res, expected)
  546: 
  547:     res2 = idx.view("m8[D]")
  548:     expected2 = idx.values.view("m8[D]")
  549:     tm.assert_numpy_array_equal(res2, expected2)
  550: 
  551:     res3 = idx.view("M8[h]")
  552:     expected3 = idx.values.view("M8[h]")
  553:     tm.assert_numpy_array_equal(res3, expected3)
