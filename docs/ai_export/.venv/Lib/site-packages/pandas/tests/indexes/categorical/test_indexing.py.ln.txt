    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas.errors import InvalidIndexError
    5: 
    6: import pandas as pd
    7: from pandas import (
    8:     CategoricalIndex,
    9:     Index,
   10:     IntervalIndex,
   11:     Timestamp,
   12: )
   13: import pandas._testing as tm
   14: 
   15: 
   16: class TestTake:
   17:     def test_take_fill_value(self):
   18:         # GH 12631
   19: 
   20:         # numeric category
   21:         idx = CategoricalIndex([1, 2, 3], name="xxx")
   22:         result = idx.take(np.array([1, 0, -1]))
   23:         expected = CategoricalIndex([2, 1, 3], name="xxx")
   24:         tm.assert_index_equal(result, expected)
   25:         tm.assert_categorical_equal(result.values, expected.values)
   26: 
   27:         # fill_value
   28:         result = idx.take(np.array([1, 0, -1]), fill_value=True)
   29:         expected = CategoricalIndex([2, 1, np.nan], categories=[1, 2, 3], name="xxx")
   30:         tm.assert_index_equal(result, expected)
   31:         tm.assert_categorical_equal(result.values, expected.values)
   32: 
   33:         # allow_fill=False
   34:         result = idx.take(np.array([1, 0, -1]), allow_fill=False, fill_value=True)
   35:         expected = CategoricalIndex([2, 1, 3], name="xxx")
   36:         tm.assert_index_equal(result, expected)
   37:         tm.assert_categorical_equal(result.values, expected.values)
   38: 
   39:         # object category
   40:         idx = CategoricalIndex(
   41:             list("CBA"), categories=list("ABC"), ordered=True, name="xxx"
   42:         )
   43:         result = idx.take(np.array([1, 0, -1]))
   44:         expected = CategoricalIndex(
   45:             list("BCA"), categories=list("ABC"), ordered=True, name="xxx"
   46:         )
   47:         tm.assert_index_equal(result, expected)
   48:         tm.assert_categorical_equal(result.values, expected.values)
   49: 
   50:         # fill_value
   51:         result = idx.take(np.array([1, 0, -1]), fill_value=True)
   52:         expected = CategoricalIndex(
   53:             ["B", "C", np.nan], categories=list("ABC"), ordered=True, name="xxx"
   54:         )
   55:         tm.assert_index_equal(result, expected)
   56:         tm.assert_categorical_equal(result.values, expected.values)
   57: 
   58:         # allow_fill=False
   59:         result = idx.take(np.array([1, 0, -1]), allow_fill=False, fill_value=True)
   60:         expected = CategoricalIndex(
   61:             list("BCA"), categories=list("ABC"), ordered=True, name="xxx"
   62:         )
   63:         tm.assert_index_equal(result, expected)
   64:         tm.assert_categorical_equal(result.values, expected.values)
   65: 
   66:         msg = (
   67:             "When allow_fill=True and fill_value is not None, "
   68:             "all indices must be >= -1"
   69:         )
   70:         with pytest.raises(ValueError, match=msg):
   71:             idx.take(np.array([1, 0, -2]), fill_value=True)
   72:         with pytest.raises(ValueError, match=msg):
   73:             idx.take(np.array([1, 0, -5]), fill_value=True)
   74: 
   75:         msg = "index -5 is out of bounds for (axis 0 with )?size 3"
   76:         with pytest.raises(IndexError, match=msg):
   77:             idx.take(np.array([1, -5]))
   78: 
   79:     def test_take_fill_value_datetime(self):
   80:         # datetime category
   81:         idx = pd.DatetimeIndex(["2011-01-01", "2011-02-01", "2011-03-01"], name="xxx")
   82:         idx = CategoricalIndex(idx)
   83:         result = idx.take(np.array([1, 0, -1]))
   84:         expected = pd.DatetimeIndex(
   85:             ["2011-02-01", "2011-01-01", "2011-03-01"], name="xxx"
   86:         )
   87:         expected = CategoricalIndex(expected)
   88:         tm.assert_index_equal(result, expected)
   89: 
   90:         # fill_value
   91:         result = idx.take(np.array([1, 0, -1]), fill_value=True)
   92:         expected = pd.DatetimeIndex(["2011-02-01", "2011-01-01", "NaT"], name="xxx")
   93:         exp_cats = pd.DatetimeIndex(["2011-01-01", "2011-02-01", "2011-03-01"])
   94:         expected = CategoricalIndex(expected, categories=exp_cats)
   95:         tm.assert_index_equal(result, expected)
   96: 
   97:         # allow_fill=False
   98:         result = idx.take(np.array([1, 0, -1]), allow_fill=False, fill_value=True)
   99:         expected = pd.DatetimeIndex(
  100:             ["2011-02-01", "2011-01-01", "2011-03-01"], name="xxx"
  101:         )
  102:         expected = CategoricalIndex(expected)
  103:         tm.assert_index_equal(result, expected)
  104: 
  105:         msg = (
  106:             "When allow_fill=True and fill_value is not None, "
  107:             "all indices must be >= -1"
  108:         )
  109:         with pytest.raises(ValueError, match=msg):
  110:             idx.take(np.array([1, 0, -2]), fill_value=True)
  111:         with pytest.raises(ValueError, match=msg):
  112:             idx.take(np.array([1, 0, -5]), fill_value=True)
  113: 
  114:         msg = "index -5 is out of bounds for (axis 0 with )?size 3"
  115:         with pytest.raises(IndexError, match=msg):
  116:             idx.take(np.array([1, -5]))
  117: 
  118:     def test_take_invalid_kwargs(self):
  119:         idx = CategoricalIndex([1, 2, 3], name="foo")
  120:         indices = [1, 0, -1]
  121: 
  122:         msg = r"take\(\) got an unexpected keyword argument 'foo'"
  123:         with pytest.raises(TypeError, match=msg):
  124:             idx.take(indices, foo=2)
  125: 
  126:         msg = "the 'out' parameter is not supported"
  127:         with pytest.raises(ValueError, match=msg):
  128:             idx.take(indices, out=indices)
  129: 
  130:         msg = "the 'mode' parameter is not supported"
  131:         with pytest.raises(ValueError, match=msg):
  132:             idx.take(indices, mode="clip")
  133: 
  134: 
  135: class TestGetLoc:
  136:     def test_get_loc(self):
  137:         # GH 12531
  138:         cidx1 = CategoricalIndex(list("abcde"), categories=list("edabc"))
  139:         idx1 = Index(list("abcde"))
  140:         assert cidx1.get_loc("a") == idx1.get_loc("a")
  141:         assert cidx1.get_loc("e") == idx1.get_loc("e")
  142: 
  143:         for i in [cidx1, idx1]:
  144:             with pytest.raises(KeyError, match="'NOT-EXIST'"):
  145:                 i.get_loc("NOT-EXIST")
  146: 
  147:         # non-unique
  148:         cidx2 = CategoricalIndex(list("aacded"), categories=list("edabc"))
  149:         idx2 = Index(list("aacded"))
  150: 
  151:         # results in bool array
  152:         res = cidx2.get_loc("d")
  153:         tm.assert_numpy_array_equal(res, idx2.get_loc("d"))
  154:         tm.assert_numpy_array_equal(
  155:             res, np.array([False, False, False, True, False, True])
  156:         )
  157:         # unique element results in scalar
  158:         res = cidx2.get_loc("e")
  159:         assert res == idx2.get_loc("e")
  160:         assert res == 4
  161: 
  162:         for i in [cidx2, idx2]:
  163:             with pytest.raises(KeyError, match="'NOT-EXIST'"):
  164:                 i.get_loc("NOT-EXIST")
  165: 
  166:         # non-unique, sliceable
  167:         cidx3 = CategoricalIndex(list("aabbb"), categories=list("abc"))
  168:         idx3 = Index(list("aabbb"))
  169: 
  170:         # results in slice
  171:         res = cidx3.get_loc("a")
  172:         assert res == idx3.get_loc("a")
  173:         assert res == slice(0, 2, None)
  174: 
  175:         res = cidx3.get_loc("b")
  176:         assert res == idx3.get_loc("b")
  177:         assert res == slice(2, 5, None)
  178: 
  179:         for i in [cidx3, idx3]:
  180:             with pytest.raises(KeyError, match="'c'"):
  181:                 i.get_loc("c")
  182: 
  183:     def test_get_loc_unique(self):
  184:         cidx = CategoricalIndex(list("abc"))
  185:         result = cidx.get_loc("b")
  186:         assert result == 1
  187: 
  188:     def test_get_loc_monotonic_nonunique(self):
  189:         cidx = CategoricalIndex(list("abbc"))
  190:         result = cidx.get_loc("b")
  191:         expected = slice(1, 3, None)
  192:         assert result == expected
  193: 
  194:     def test_get_loc_nonmonotonic_nonunique(self):
  195:         cidx = CategoricalIndex(list("abcb"))
  196:         result = cidx.get_loc("b")
  197:         expected = np.array([False, True, False, True], dtype=bool)
  198:         tm.assert_numpy_array_equal(result, expected)
  199: 
  200:     def test_get_loc_nan(self):
  201:         # GH#41933
  202:         ci = CategoricalIndex(["A", "B", np.nan])
  203:         res = ci.get_loc(np.nan)
  204: 
  205:         assert res == 2
  206: 
  207: 
  208: class TestGetIndexer:
  209:     def test_get_indexer_base(self):
  210:         # Determined by cat ordering.
  211:         idx = CategoricalIndex(list("cab"), categories=list("cab"))
  212:         expected = np.arange(len(idx), dtype=np.intp)
  213: 
  214:         actual = idx.get_indexer(idx)
  215:         tm.assert_numpy_array_equal(expected, actual)
  216: 
  217:         with pytest.raises(ValueError, match="Invalid fill method"):
  218:             idx.get_indexer(idx, method="invalid")
  219: 
  220:     def test_get_indexer_requires_unique(self):
  221:         ci = CategoricalIndex(list("aabbca"), categories=list("cab"), ordered=False)
  222:         oidx = Index(np.array(ci))
  223: 
  224:         msg = "Reindexing only valid with uniquely valued Index objects"
  225: 
  226:         for n in [1, 2, 5, len(ci)]:
  227:             finder = oidx[np.random.default_rng(2).integers(0, len(ci), size=n)]
  228: 
  229:             with pytest.raises(InvalidIndexError, match=msg):
  230:                 ci.get_indexer(finder)
  231: 
  232:         # see gh-17323
  233:         #
  234:         # Even when indexer is equal to the
  235:         # members in the index, we should
  236:         # respect duplicates instead of taking
  237:         # the fast-track path.
  238:         for finder in [list("aabbca"), list("aababca")]:
  239:             with pytest.raises(InvalidIndexError, match=msg):
  240:                 ci.get_indexer(finder)
  241: 
  242:     def test_get_indexer_non_unique(self):
  243:         idx1 = CategoricalIndex(list("aabcde"), categories=list("edabc"))
  244:         idx2 = CategoricalIndex(list("abf"))
  245: 
  246:         for indexer in [idx2, list("abf"), Index(list("abf"))]:
  247:             msg = "Reindexing only valid with uniquely valued Index objects"
  248:             with pytest.raises(InvalidIndexError, match=msg):
  249:                 idx1.get_indexer(indexer)
  250: 
  251:             r1, _ = idx1.get_indexer_non_unique(indexer)
  252:             expected = np.array([0, 1, 2, -1], dtype=np.intp)
  253:             tm.assert_almost_equal(r1, expected)
  254: 
  255:     def test_get_indexer_method(self):
  256:         idx1 = CategoricalIndex(list("aabcde"), categories=list("edabc"))
  257:         idx2 = CategoricalIndex(list("abf"))
  258: 
  259:         msg = "method pad not yet implemented for CategoricalIndex"
  260:         with pytest.raises(NotImplementedError, match=msg):
  261:             idx2.get_indexer(idx1, method="pad")
  262:         msg = "method backfill not yet implemented for CategoricalIndex"
  263:         with pytest.raises(NotImplementedError, match=msg):
  264:             idx2.get_indexer(idx1, method="backfill")
  265: 
  266:         msg = "method nearest not yet implemented for CategoricalIndex"
  267:         with pytest.raises(NotImplementedError, match=msg):
  268:             idx2.get_indexer(idx1, method="nearest")
  269: 
  270:     def test_get_indexer_array(self):
  271:         arr = np.array(
  272:             [Timestamp("1999-12-31 00:00:00"), Timestamp("2000-12-31 00:00:00")],
  273:             dtype=object,
  274:         )
  275:         cats = [Timestamp("1999-12-31 00:00:00"), Timestamp("2000-12-31 00:00:00")]
  276:         ci = CategoricalIndex(cats, categories=cats, ordered=False, dtype="category")
  277:         result = ci.get_indexer(arr)
  278:         expected = np.array([0, 1], dtype="intp")
  279:         tm.assert_numpy_array_equal(result, expected)
  280: 
  281:     def test_get_indexer_same_categories_same_order(self):
  282:         ci = CategoricalIndex(["a", "b"], categories=["a", "b"])
  283: 
  284:         result = ci.get_indexer(CategoricalIndex(["b", "b"], categories=["a", "b"]))
  285:         expected = np.array([1, 1], dtype="intp")
  286:         tm.assert_numpy_array_equal(result, expected)
  287: 
  288:     def test_get_indexer_same_categories_different_order(self):
  289:         # https://github.com/pandas-dev/pandas/issues/19551
  290:         ci = CategoricalIndex(["a", "b"], categories=["a", "b"])
  291: 
  292:         result = ci.get_indexer(CategoricalIndex(["b", "b"], categories=["b", "a"]))
  293:         expected = np.array([1, 1], dtype="intp")
  294:         tm.assert_numpy_array_equal(result, expected)
  295: 
  296:     def test_get_indexer_nans_in_index_and_target(self):
  297:         # GH 45361
  298:         ci = CategoricalIndex([1, 2, np.nan, 3])
  299:         other1 = [2, 3, 4, np.nan]
  300:         res1 = ci.get_indexer(other1)
  301:         expected1 = np.array([1, 3, -1, 2], dtype=np.intp)
  302:         tm.assert_numpy_array_equal(res1, expected1)
  303:         other2 = [1, 4, 2, 3]
  304:         res2 = ci.get_indexer(other2)
  305:         expected2 = np.array([0, -1, 1, 3], dtype=np.intp)
  306:         tm.assert_numpy_array_equal(res2, expected2)
  307: 
  308: 
  309: class TestWhere:
  310:     def test_where(self, listlike_box):
  311:         klass = listlike_box
  312: 
  313:         i = CategoricalIndex(list("aabbca"), categories=list("cab"), ordered=False)
  314:         cond = [True] * len(i)
  315:         expected = i
  316:         result = i.where(klass(cond))
  317:         tm.assert_index_equal(result, expected)
  318: 
  319:         cond = [False] + [True] * (len(i) - 1)
  320:         expected = CategoricalIndex([np.nan] + i[1:].tolist(), categories=i.categories)
  321:         result = i.where(klass(cond))
  322:         tm.assert_index_equal(result, expected)
  323: 
  324:     def test_where_non_categories(self):
  325:         ci = CategoricalIndex(["a", "b", "c", "d"])
  326:         mask = np.array([True, False, True, False])
  327: 
  328:         result = ci.where(mask, 2)
  329:         expected = Index(["a", 2, "c", 2], dtype=object)
  330:         tm.assert_index_equal(result, expected)
  331: 
  332:         msg = "Cannot setitem on a Categorical with a new category"
  333:         with pytest.raises(TypeError, match=msg):
  334:             # Test the Categorical method directly
  335:             ci._data._where(mask, 2)
  336: 
  337: 
  338: class TestContains:
  339:     def test_contains(self):
  340:         ci = CategoricalIndex(list("aabbca"), categories=list("cabdef"), ordered=False)
  341: 
  342:         assert "a" in ci
  343:         assert "z" not in ci
  344:         assert "e" not in ci
  345:         assert np.nan not in ci
  346: 
  347:         # assert codes NOT in index
  348:         assert 0 not in ci
  349:         assert 1 not in ci
  350: 
  351:     def test_contains_nan(self):
  352:         ci = CategoricalIndex(list("aabbca") + [np.nan], categories=list("cabdef"))
  353:         assert np.nan in ci
  354: 
  355:     @pytest.mark.parametrize("unwrap", [True, False])
  356:     def test_contains_na_dtype(self, unwrap):
  357:         dti = pd.date_range("2016-01-01", periods=100).insert(0, pd.NaT)
  358:         pi = dti.to_period("D")
  359:         tdi = dti - dti[-1]
  360:         ci = CategoricalIndex(dti)
  361: 
  362:         obj = ci
  363:         if unwrap:
  364:             obj = ci._data
  365: 
  366:         assert np.nan in obj
  367:         assert None in obj
  368:         assert pd.NaT in obj
  369:         assert np.datetime64("NaT") in obj
  370:         assert np.timedelta64("NaT") not in obj
  371: 
  372:         obj2 = CategoricalIndex(tdi)
  373:         if unwrap:
  374:             obj2 = obj2._data
  375: 
  376:         assert np.nan in obj2
  377:         assert None in obj2
  378:         assert pd.NaT in obj2
  379:         assert np.datetime64("NaT") not in obj2
  380:         assert np.timedelta64("NaT") in obj2
  381: 
  382:         obj3 = CategoricalIndex(pi)
  383:         if unwrap:
  384:             obj3 = obj3._data
  385: 
  386:         assert np.nan in obj3
  387:         assert None in obj3
  388:         assert pd.NaT in obj3
  389:         assert np.datetime64("NaT") not in obj3
  390:         assert np.timedelta64("NaT") not in obj3
  391: 
  392:     @pytest.mark.parametrize(
  393:         "item, expected",
  394:         [
  395:             (pd.Interval(0, 1), True),
  396:             (1.5, True),
  397:             (pd.Interval(0.5, 1.5), False),
  398:             ("a", False),
  399:             (Timestamp(1), False),
  400:             (pd.Timedelta(1), False),
  401:         ],
  402:         ids=str,
  403:     )
  404:     def test_contains_interval(self, item, expected):
  405:         # GH 23705
  406:         ci = CategoricalIndex(IntervalIndex.from_breaks(range(3)))
  407:         result = item in ci
  408:         assert result is expected
  409: 
  410:     def test_contains_list(self):
  411:         # GH#21729
  412:         idx = CategoricalIndex([1, 2, 3])
  413: 
  414:         assert "a" not in idx
  415: 
  416:         with pytest.raises(TypeError, match="unhashable type"):
  417:             ["a"] in idx
  418: 
  419:         with pytest.raises(TypeError, match="unhashable type"):
  420:             ["a", "b"] in idx
