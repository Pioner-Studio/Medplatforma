    1: """
    2: Tests for the Index constructor conducting inference.
    3: """
    4: from datetime import (
    5:     datetime,
    6:     timedelta,
    7:     timezone,
    8: )
    9: from decimal import Decimal
   10: 
   11: import numpy as np
   12: import pytest
   13: 
   14: from pandas._libs.tslibs.timezones import maybe_get_tz
   15: 
   16: from pandas import (
   17:     NA,
   18:     Categorical,
   19:     CategoricalIndex,
   20:     DatetimeIndex,
   21:     Index,
   22:     IntervalIndex,
   23:     MultiIndex,
   24:     NaT,
   25:     PeriodIndex,
   26:     Series,
   27:     TimedeltaIndex,
   28:     Timestamp,
   29:     array,
   30:     date_range,
   31:     period_range,
   32:     timedelta_range,
   33: )
   34: import pandas._testing as tm
   35: 
   36: 
   37: class TestIndexConstructorInference:
   38:     def test_object_all_bools(self):
   39:         # GH#49594 match Series behavior on ndarray[object] of all bools
   40:         arr = np.array([True, False], dtype=object)
   41:         res = Index(arr)
   42:         assert res.dtype == object
   43: 
   44:         # since the point is matching Series behavior, let's double check
   45:         assert Series(arr).dtype == object
   46: 
   47:     def test_object_all_complex(self):
   48:         # GH#49594 match Series behavior on ndarray[object] of all complex
   49:         arr = np.array([complex(1), complex(2)], dtype=object)
   50:         res = Index(arr)
   51:         assert res.dtype == object
   52: 
   53:         # since the point is matching Series behavior, let's double check
   54:         assert Series(arr).dtype == object
   55: 
   56:     @pytest.mark.parametrize("val", [NaT, None, np.nan, float("nan")])
   57:     def test_infer_nat(self, val):
   58:         # GH#49340 all NaT/None/nan and at least 1 NaT -> datetime64[ns],
   59:         #  matching Series behavior
   60:         values = [NaT, val]
   61: 
   62:         idx = Index(values)
   63:         assert idx.dtype == "datetime64[ns]" and idx.isna().all()
   64: 
   65:         idx = Index(values[::-1])
   66:         assert idx.dtype == "datetime64[ns]" and idx.isna().all()
   67: 
   68:         idx = Index(np.array(values, dtype=object))
   69:         assert idx.dtype == "datetime64[ns]" and idx.isna().all()
   70: 
   71:         idx = Index(np.array(values, dtype=object)[::-1])
   72:         assert idx.dtype == "datetime64[ns]" and idx.isna().all()
   73: 
   74:     @pytest.mark.parametrize("na_value", [None, np.nan])
   75:     @pytest.mark.parametrize("vtype", [list, tuple, iter])
   76:     def test_construction_list_tuples_nan(self, na_value, vtype):
   77:         # GH#18505 : valid tuples containing NaN
   78:         values = [(1, "two"), (3.0, na_value)]
   79:         result = Index(vtype(values))
   80:         expected = MultiIndex.from_tuples(values)
   81:         tm.assert_index_equal(result, expected)
   82: 
   83:     @pytest.mark.parametrize(
   84:         "dtype",
   85:         [int, "int64", "int32", "int16", "int8", "uint64", "uint32", "uint16", "uint8"],
   86:     )
   87:     def test_constructor_int_dtype_float(self, dtype):
   88:         # GH#18400
   89:         expected = Index([0, 1, 2, 3], dtype=dtype)
   90:         result = Index([0.0, 1.0, 2.0, 3.0], dtype=dtype)
   91:         tm.assert_index_equal(result, expected)
   92: 
   93:     @pytest.mark.parametrize("cast_index", [True, False])
   94:     @pytest.mark.parametrize(
   95:         "vals", [[True, False, True], np.array([True, False, True], dtype=bool)]
   96:     )
   97:     def test_constructor_dtypes_to_object(self, cast_index, vals):
   98:         if cast_index:
   99:             index = Index(vals, dtype=bool)
  100:         else:
  101:             index = Index(vals)
  102: 
  103:         assert type(index) is Index
  104:         assert index.dtype == bool
  105: 
  106:     def test_constructor_categorical_to_object(self):
  107:         # GH#32167 Categorical data and dtype=object should return object-dtype
  108:         ci = CategoricalIndex(range(5))
  109:         result = Index(ci, dtype=object)
  110:         assert not isinstance(result, CategoricalIndex)
  111: 
  112:     def test_constructor_infer_periodindex(self):
  113:         xp = period_range("2012-1-1", freq="M", periods=3)
  114:         rs = Index(xp)
  115:         tm.assert_index_equal(rs, xp)
  116:         assert isinstance(rs, PeriodIndex)
  117: 
  118:     def test_from_list_of_periods(self):
  119:         rng = period_range("1/1/2000", periods=20, freq="D")
  120:         periods = list(rng)
  121: 
  122:         result = Index(periods)
  123:         assert isinstance(result, PeriodIndex)
  124: 
  125:     @pytest.mark.parametrize("pos", [0, 1])
  126:     @pytest.mark.parametrize(
  127:         "klass,dtype,ctor",
  128:         [
  129:             (DatetimeIndex, "datetime64[ns]", np.datetime64("nat")),
  130:             (TimedeltaIndex, "timedelta64[ns]", np.timedelta64("nat")),
  131:         ],
  132:     )
  133:     def test_constructor_infer_nat_dt_like(
  134:         self, pos, klass, dtype, ctor, nulls_fixture, request
  135:     ):
  136:         if isinstance(nulls_fixture, Decimal):
  137:             # We dont cast these to datetime64/timedelta64
  138:             pytest.skip(
  139:                 f"We don't cast {type(nulls_fixture).__name__} to "
  140:                 "datetime64/timedelta64"
  141:             )
  142: 
  143:         expected = klass([NaT, NaT])
  144:         assert expected.dtype == dtype
  145:         data = [ctor]
  146:         data.insert(pos, nulls_fixture)
  147: 
  148:         warn = None
  149:         if nulls_fixture is NA:
  150:             expected = Index([NA, NaT])
  151:             mark = pytest.mark.xfail(reason="Broken with np.NaT ctor; see GH 31884")
  152:             request.applymarker(mark)
  153:             # GH#35942 numpy will emit a DeprecationWarning within the
  154:             #  assert_index_equal calls.  Since we can't do anything
  155:             #  about it until GH#31884 is fixed, we suppress that warning.
  156:             warn = DeprecationWarning
  157: 
  158:         result = Index(data)
  159: 
  160:         with tm.assert_produces_warning(warn):
  161:             tm.assert_index_equal(result, expected)
  162: 
  163:         result = Index(np.array(data, dtype=object))
  164: 
  165:         with tm.assert_produces_warning(warn):
  166:             tm.assert_index_equal(result, expected)
  167: 
  168:     @pytest.mark.parametrize("swap_objs", [True, False])
  169:     def test_constructor_mixed_nat_objs_infers_object(self, swap_objs):
  170:         # mixed np.datetime64/timedelta64 nat results in object
  171:         data = [np.datetime64("nat"), np.timedelta64("nat")]
  172:         if swap_objs:
  173:             data = data[::-1]
  174: 
  175:         expected = Index(data, dtype=object)
  176:         tm.assert_index_equal(Index(data), expected)
  177:         tm.assert_index_equal(Index(np.array(data, dtype=object)), expected)
  178: 
  179:     @pytest.mark.parametrize("swap_objs", [True, False])
  180:     def test_constructor_datetime_and_datetime64(self, swap_objs):
  181:         data = [Timestamp(2021, 6, 8, 9, 42), np.datetime64("now")]
  182:         if swap_objs:
  183:             data = data[::-1]
  184:         expected = DatetimeIndex(data)
  185: 
  186:         tm.assert_index_equal(Index(data), expected)
  187:         tm.assert_index_equal(Index(np.array(data, dtype=object)), expected)
  188: 
  189:     def test_constructor_datetimes_mixed_tzs(self):
  190:         # https://github.com/pandas-dev/pandas/pull/55793/files#r1383719998
  191:         tz = maybe_get_tz("US/Central")
  192:         dt1 = datetime(2020, 1, 1, tzinfo=tz)
  193:         dt2 = datetime(2020, 1, 1, tzinfo=timezone.utc)
  194:         result = Index([dt1, dt2])
  195:         expected = Index([dt1, dt2], dtype=object)
  196:         tm.assert_index_equal(result, expected)
  197: 
  198: 
  199: class TestDtypeEnforced:
  200:     # check we don't silently ignore the dtype keyword
  201: 
  202:     def test_constructor_object_dtype_with_ea_data(self, any_numeric_ea_dtype):
  203:         # GH#45206
  204:         arr = array([0], dtype=any_numeric_ea_dtype)
  205: 
  206:         idx = Index(arr, dtype=object)
  207:         assert idx.dtype == object
  208: 
  209:     @pytest.mark.parametrize("dtype", [object, "float64", "uint64", "category"])
  210:     def test_constructor_range_values_mismatched_dtype(self, dtype):
  211:         rng = Index(range(5))
  212: 
  213:         result = Index(rng, dtype=dtype)
  214:         assert result.dtype == dtype
  215: 
  216:         result = Index(range(5), dtype=dtype)
  217:         assert result.dtype == dtype
  218: 
  219:     @pytest.mark.parametrize("dtype", [object, "float64", "uint64", "category"])
  220:     def test_constructor_categorical_values_mismatched_non_ea_dtype(self, dtype):
  221:         cat = Categorical([1, 2, 3])
  222: 
  223:         result = Index(cat, dtype=dtype)
  224:         assert result.dtype == dtype
  225: 
  226:     def test_constructor_categorical_values_mismatched_dtype(self):
  227:         dti = date_range("2016-01-01", periods=3)
  228:         cat = Categorical(dti)
  229:         result = Index(cat, dti.dtype)
  230:         tm.assert_index_equal(result, dti)
  231: 
  232:         dti2 = dti.tz_localize("Asia/Tokyo")
  233:         cat2 = Categorical(dti2)
  234:         result = Index(cat2, dti2.dtype)
  235:         tm.assert_index_equal(result, dti2)
  236: 
  237:         ii = IntervalIndex.from_breaks(range(5))
  238:         cat3 = Categorical(ii)
  239:         result = Index(cat3, dtype=ii.dtype)
  240:         tm.assert_index_equal(result, ii)
  241: 
  242:     def test_constructor_ea_values_mismatched_categorical_dtype(self):
  243:         dti = date_range("2016-01-01", periods=3)
  244:         result = Index(dti, dtype="category")
  245:         expected = CategoricalIndex(dti)
  246:         tm.assert_index_equal(result, expected)
  247: 
  248:         dti2 = date_range("2016-01-01", periods=3, tz="US/Pacific")
  249:         result = Index(dti2, dtype="category")
  250:         expected = CategoricalIndex(dti2)
  251:         tm.assert_index_equal(result, expected)
  252: 
  253:     def test_constructor_period_values_mismatched_dtype(self):
  254:         pi = period_range("2016-01-01", periods=3, freq="D")
  255:         result = Index(pi, dtype="category")
  256:         expected = CategoricalIndex(pi)
  257:         tm.assert_index_equal(result, expected)
  258: 
  259:     def test_constructor_timedelta64_values_mismatched_dtype(self):
  260:         # check we don't silently ignore the dtype keyword
  261:         tdi = timedelta_range("4 Days", periods=5)
  262:         result = Index(tdi, dtype="category")
  263:         expected = CategoricalIndex(tdi)
  264:         tm.assert_index_equal(result, expected)
  265: 
  266:     def test_constructor_interval_values_mismatched_dtype(self):
  267:         dti = date_range("2016-01-01", periods=3)
  268:         ii = IntervalIndex.from_breaks(dti)
  269:         result = Index(ii, dtype="category")
  270:         expected = CategoricalIndex(ii)
  271:         tm.assert_index_equal(result, expected)
  272: 
  273:     def test_constructor_datetime64_values_mismatched_period_dtype(self):
  274:         dti = date_range("2016-01-01", periods=3)
  275:         result = Index(dti, dtype="Period[D]")
  276:         expected = dti.to_period("D")
  277:         tm.assert_index_equal(result, expected)
  278: 
  279:     @pytest.mark.parametrize("dtype", ["int64", "uint64"])
  280:     def test_constructor_int_dtype_nan_raises(self, dtype):
  281:         # see GH#15187
  282:         data = [np.nan]
  283:         msg = "cannot convert"
  284:         with pytest.raises(ValueError, match=msg):
  285:             Index(data, dtype=dtype)
  286: 
  287:     @pytest.mark.parametrize(
  288:         "vals",
  289:         [
  290:             [1, 2, 3],
  291:             np.array([1, 2, 3]),
  292:             np.array([1, 2, 3], dtype=int),
  293:             # below should coerce
  294:             [1.0, 2.0, 3.0],
  295:             np.array([1.0, 2.0, 3.0], dtype=float),
  296:         ],
  297:     )
  298:     def test_constructor_dtypes_to_int(self, vals, any_int_numpy_dtype):
  299:         dtype = any_int_numpy_dtype
  300:         index = Index(vals, dtype=dtype)
  301:         assert index.dtype == dtype
  302: 
  303:     @pytest.mark.parametrize(
  304:         "vals",
  305:         [
  306:             [1, 2, 3],
  307:             [1.0, 2.0, 3.0],
  308:             np.array([1.0, 2.0, 3.0]),
  309:             np.array([1, 2, 3], dtype=int),
  310:             np.array([1.0, 2.0, 3.0], dtype=float),
  311:         ],
  312:     )
  313:     def test_constructor_dtypes_to_float(self, vals, float_numpy_dtype):
  314:         dtype = float_numpy_dtype
  315:         index = Index(vals, dtype=dtype)
  316:         assert index.dtype == dtype
  317: 
  318:     @pytest.mark.parametrize(
  319:         "vals",
  320:         [
  321:             [1, 2, 3],
  322:             np.array([1, 2, 3], dtype=int),
  323:             np.array(["2011-01-01", "2011-01-02"], dtype="datetime64[ns]"),
  324:             [datetime(2011, 1, 1), datetime(2011, 1, 2)],
  325:         ],
  326:     )
  327:     def test_constructor_dtypes_to_categorical(self, vals):
  328:         index = Index(vals, dtype="category")
  329:         assert isinstance(index, CategoricalIndex)
  330: 
  331:     @pytest.mark.parametrize("cast_index", [True, False])
  332:     @pytest.mark.parametrize(
  333:         "vals",
  334:         [
  335:             Index(np.array([np.datetime64("2011-01-01"), np.datetime64("2011-01-02")])),
  336:             Index([datetime(2011, 1, 1), datetime(2011, 1, 2)]),
  337:         ],
  338:     )
  339:     def test_constructor_dtypes_to_datetime(self, cast_index, vals):
  340:         if cast_index:
  341:             index = Index(vals, dtype=object)
  342:             assert isinstance(index, Index)
  343:             assert index.dtype == object
  344:         else:
  345:             index = Index(vals)
  346:             assert isinstance(index, DatetimeIndex)
  347: 
  348:     @pytest.mark.parametrize("cast_index", [True, False])
  349:     @pytest.mark.parametrize(
  350:         "vals",
  351:         [
  352:             np.array([np.timedelta64(1, "D"), np.timedelta64(1, "D")]),
  353:             [timedelta(1), timedelta(1)],
  354:         ],
  355:     )
  356:     def test_constructor_dtypes_to_timedelta(self, cast_index, vals):
  357:         if cast_index:
  358:             index = Index(vals, dtype=object)
  359:             assert isinstance(index, Index)
  360:             assert index.dtype == object
  361:         else:
  362:             index = Index(vals)
  363:             assert isinstance(index, TimedeltaIndex)
  364: 
  365:     def test_pass_timedeltaindex_to_index(self):
  366:         rng = timedelta_range("1 days", "10 days")
  367:         idx = Index(rng, dtype=object)
  368: 
  369:         expected = Index(rng.to_pytimedelta(), dtype=object)
  370: 
  371:         tm.assert_numpy_array_equal(idx.values, expected.values)
  372: 
  373:     def test_pass_datetimeindex_to_index(self):
  374:         # GH#1396
  375:         rng = date_range("1/1/2000", "3/1/2000")
  376:         idx = Index(rng, dtype=object)
  377: 
  378:         expected = Index(rng.to_pydatetime(), dtype=object)
  379: 
  380:         tm.assert_numpy_array_equal(idx.values, expected.values)
  381: 
  382: 
  383: class TestIndexConstructorUnwrapping:
  384:     # Test passing different arraylike values to pd.Index
  385: 
  386:     @pytest.mark.parametrize("klass", [Index, DatetimeIndex])
  387:     def test_constructor_from_series_dt64(self, klass):
  388:         stamps = [Timestamp("20110101"), Timestamp("20120101"), Timestamp("20130101")]
  389:         expected = DatetimeIndex(stamps)
  390:         ser = Series(stamps)
  391:         result = klass(ser)
  392:         tm.assert_index_equal(result, expected)
  393: 
  394:     def test_constructor_no_pandas_array(self):
  395:         ser = Series([1, 2, 3])
  396:         result = Index(ser.array)
  397:         expected = Index([1, 2, 3])
  398:         tm.assert_index_equal(result, expected)
  399: 
  400:     @pytest.mark.parametrize(
  401:         "array",
  402:         [
  403:             np.arange(5),
  404:             np.array(["a", "b", "c"]),
  405:             date_range("2000-01-01", periods=3).values,
  406:         ],
  407:     )
  408:     def test_constructor_ndarray_like(self, array):
  409:         # GH#5460#issuecomment-44474502
  410:         # it should be possible to convert any object that satisfies the numpy
  411:         # ndarray interface directly into an Index
  412:         class ArrayLike:
  413:             def __init__(self, array) -> None:
  414:                 self.array = array
  415: 
  416:             def __array__(self, dtype=None, copy=None) -> np.ndarray:
  417:                 return self.array
  418: 
  419:         expected = Index(array)
  420:         result = Index(ArrayLike(array))
  421:         tm.assert_index_equal(result, expected)
  422: 
  423: 
  424: class TestIndexConstructionErrors:
  425:     def test_constructor_overflow_int64(self):
  426:         # see GH#15832
  427:         msg = (
  428:             "The elements provided in the data cannot "
  429:             "all be casted to the dtype int64"
  430:         )
  431:         with pytest.raises(OverflowError, match=msg):
  432:             Index([np.iinfo(np.uint64).max - 1], dtype="int64")
