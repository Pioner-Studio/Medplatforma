    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas._libs.tslibs.period import IncompatibleFrequency
    5: 
    6: from pandas.core.dtypes.dtypes import PeriodDtype
    7: 
    8: from pandas import (
    9:     Index,
   10:     NaT,
   11:     Period,
   12:     PeriodIndex,
   13:     Series,
   14:     date_range,
   15:     offsets,
   16:     period_range,
   17: )
   18: import pandas._testing as tm
   19: from pandas.core.arrays import PeriodArray
   20: 
   21: 
   22: class TestPeriodIndexDisallowedFreqs:
   23:     @pytest.mark.parametrize(
   24:         "freq,freq_depr",
   25:         [
   26:             ("2M", "2ME"),
   27:             ("2Q-MAR", "2QE-MAR"),
   28:             ("2Y-FEB", "2YE-FEB"),
   29:             ("2M", "2me"),
   30:             ("2Q-MAR", "2qe-MAR"),
   31:             ("2Y-FEB", "2yE-feb"),
   32:         ],
   33:     )
   34:     def test_period_index_offsets_frequency_error_message(self, freq, freq_depr):
   35:         # GH#52064
   36:         msg = f"for Period, please use '{freq[1:]}' instead of '{freq_depr[1:]}'"
   37: 
   38:         with pytest.raises(ValueError, match=msg):
   39:             PeriodIndex(["2020-01-01", "2020-01-02"], freq=freq_depr)
   40: 
   41:         with pytest.raises(ValueError, match=msg):
   42:             period_range(start="2020-01-01", end="2020-01-02", freq=freq_depr)
   43: 
   44:     @pytest.mark.parametrize("freq_depr", ["2SME", "2sme", "2CBME", "2BYE", "2Bye"])
   45:     def test_period_index_frequency_invalid_freq(self, freq_depr):
   46:         # GH#9586
   47:         msg = f"Invalid frequency: {freq_depr[1:]}"
   48: 
   49:         with pytest.raises(ValueError, match=msg):
   50:             period_range("2020-01", "2020-05", freq=freq_depr)
   51:         with pytest.raises(ValueError, match=msg):
   52:             PeriodIndex(["2020-01", "2020-05"], freq=freq_depr)
   53: 
   54:     @pytest.mark.parametrize("freq", ["2BQE-SEP", "2BYE-MAR", "2BME"])
   55:     def test_period_index_from_datetime_index_invalid_freq(self, freq):
   56:         # GH#56899
   57:         msg = f"Invalid frequency: {freq[1:]}"
   58: 
   59:         rng = date_range("01-Jan-2012", periods=8, freq=freq)
   60:         with pytest.raises(ValueError, match=msg):
   61:             rng.to_period()
   62: 
   63: 
   64: class TestPeriodIndex:
   65:     def test_from_ordinals(self):
   66:         Period(ordinal=-1000, freq="Y")
   67:         Period(ordinal=0, freq="Y")
   68: 
   69:         msg = "The 'ordinal' keyword in PeriodIndex is deprecated"
   70:         with tm.assert_produces_warning(FutureWarning, match=msg):
   71:             idx1 = PeriodIndex(ordinal=[-1, 0, 1], freq="Y")
   72:         with tm.assert_produces_warning(FutureWarning, match=msg):
   73:             idx2 = PeriodIndex(ordinal=np.array([-1, 0, 1]), freq="Y")
   74:         tm.assert_index_equal(idx1, idx2)
   75: 
   76:         alt1 = PeriodIndex.from_ordinals([-1, 0, 1], freq="Y")
   77:         tm.assert_index_equal(alt1, idx1)
   78: 
   79:         alt2 = PeriodIndex.from_ordinals(np.array([-1, 0, 1]), freq="Y")
   80:         tm.assert_index_equal(alt2, idx2)
   81: 
   82:     def test_keyword_mismatch(self):
   83:         # GH#55961 we should get exactly one of data/ordinals/**fields
   84:         per = Period("2016-01-01", "D")
   85:         depr_msg1 = "The 'ordinal' keyword in PeriodIndex is deprecated"
   86:         depr_msg2 = "Constructing PeriodIndex from fields is deprecated"
   87: 
   88:         err_msg1 = "Cannot pass both data and ordinal"
   89:         with pytest.raises(ValueError, match=err_msg1):
   90:             with tm.assert_produces_warning(FutureWarning, match=depr_msg1):
   91:                 PeriodIndex(data=[per], ordinal=[per.ordinal], freq=per.freq)
   92: 
   93:         err_msg2 = "Cannot pass both data and fields"
   94:         with pytest.raises(ValueError, match=err_msg2):
   95:             with tm.assert_produces_warning(FutureWarning, match=depr_msg2):
   96:                 PeriodIndex(data=[per], year=[per.year], freq=per.freq)
   97: 
   98:         err_msg3 = "Cannot pass both ordinal and fields"
   99:         with pytest.raises(ValueError, match=err_msg3):
  100:             with tm.assert_produces_warning(FutureWarning, match=depr_msg2):
  101:                 PeriodIndex(ordinal=[per.ordinal], year=[per.year], freq=per.freq)
  102: 
  103:     def test_construction_base_constructor(self):
  104:         # GH 13664
  105:         arr = [Period("2011-01", freq="M"), NaT, Period("2011-03", freq="M")]
  106:         tm.assert_index_equal(Index(arr), PeriodIndex(arr))
  107:         tm.assert_index_equal(Index(np.array(arr)), PeriodIndex(np.array(arr)))
  108: 
  109:         arr = [np.nan, NaT, Period("2011-03", freq="M")]
  110:         tm.assert_index_equal(Index(arr), PeriodIndex(arr))
  111:         tm.assert_index_equal(Index(np.array(arr)), PeriodIndex(np.array(arr)))
  112: 
  113:         arr = [Period("2011-01", freq="M"), NaT, Period("2011-03", freq="D")]
  114:         tm.assert_index_equal(Index(arr), Index(arr, dtype=object))
  115: 
  116:         tm.assert_index_equal(Index(np.array(arr)), Index(np.array(arr), dtype=object))
  117: 
  118:     def test_base_constructor_with_period_dtype(self):
  119:         dtype = PeriodDtype("D")
  120:         values = ["2011-01-01", "2012-03-04", "2014-05-01"]
  121:         result = Index(values, dtype=dtype)
  122: 
  123:         expected = PeriodIndex(values, dtype=dtype)
  124:         tm.assert_index_equal(result, expected)
  125: 
  126:     @pytest.mark.parametrize(
  127:         "values_constructor", [list, np.array, PeriodIndex, PeriodArray._from_sequence]
  128:     )
  129:     def test_index_object_dtype(self, values_constructor):
  130:         # Index(periods, dtype=object) is an Index (not an PeriodIndex)
  131:         periods = [
  132:             Period("2011-01", freq="M"),
  133:             NaT,
  134:             Period("2011-03", freq="M"),
  135:         ]
  136:         values = values_constructor(periods)
  137:         result = Index(values, dtype=object)
  138: 
  139:         assert type(result) is Index
  140:         tm.assert_numpy_array_equal(result.values, np.array(values))
  141: 
  142:     def test_constructor_use_start_freq(self):
  143:         # GH #1118
  144:         msg1 = "Period with BDay freq is deprecated"
  145:         with tm.assert_produces_warning(FutureWarning, match=msg1):
  146:             p = Period("4/2/2012", freq="B")
  147:         msg2 = r"PeriodDtype\[B\] is deprecated"
  148:         with tm.assert_produces_warning(FutureWarning, match=msg2):
  149:             expected = period_range(start="4/2/2012", periods=10, freq="B")
  150: 
  151:         with tm.assert_produces_warning(FutureWarning, match=msg2):
  152:             index = period_range(start=p, periods=10)
  153:         tm.assert_index_equal(index, expected)
  154: 
  155:     def test_constructor_field_arrays(self):
  156:         # GH #1264
  157: 
  158:         years = np.arange(1990, 2010).repeat(4)[2:-2]
  159:         quarters = np.tile(np.arange(1, 5), 20)[2:-2]
  160: 
  161:         depr_msg = "Constructing PeriodIndex from fields is deprecated"
  162:         with tm.assert_produces_warning(FutureWarning, match=depr_msg):
  163:             index = PeriodIndex(year=years, quarter=quarters, freq="Q-DEC")
  164:         expected = period_range("1990Q3", "2009Q2", freq="Q-DEC")
  165:         tm.assert_index_equal(index, expected)
  166: 
  167:         with tm.assert_produces_warning(FutureWarning, match=depr_msg):
  168:             index2 = PeriodIndex(year=years, quarter=quarters, freq="2Q-DEC")
  169:         tm.assert_numpy_array_equal(index.asi8, index2.asi8)
  170: 
  171:         with tm.assert_produces_warning(FutureWarning, match=depr_msg):
  172:             index = PeriodIndex(year=years, quarter=quarters)
  173:         tm.assert_index_equal(index, expected)
  174: 
  175:         years = [2007, 2007, 2007]
  176:         months = [1, 2]
  177: 
  178:         msg = "Mismatched Period array lengths"
  179:         with pytest.raises(ValueError, match=msg):
  180:             with tm.assert_produces_warning(FutureWarning, match=depr_msg):
  181:                 PeriodIndex(year=years, month=months, freq="M")
  182:         with pytest.raises(ValueError, match=msg):
  183:             with tm.assert_produces_warning(FutureWarning, match=depr_msg):
  184:                 PeriodIndex(year=years, month=months, freq="2M")
  185: 
  186:         years = [2007, 2007, 2007]
  187:         months = [1, 2, 3]
  188:         with tm.assert_produces_warning(FutureWarning, match=depr_msg):
  189:             idx = PeriodIndex(year=years, month=months, freq="M")
  190:         exp = period_range("2007-01", periods=3, freq="M")
  191:         tm.assert_index_equal(idx, exp)
  192: 
  193:     def test_constructor_nano(self):
  194:         idx = period_range(
  195:             start=Period(ordinal=1, freq="ns"),
  196:             end=Period(ordinal=4, freq="ns"),
  197:             freq="ns",
  198:         )
  199:         exp = PeriodIndex(
  200:             [
  201:                 Period(ordinal=1, freq="ns"),
  202:                 Period(ordinal=2, freq="ns"),
  203:                 Period(ordinal=3, freq="ns"),
  204:                 Period(ordinal=4, freq="ns"),
  205:             ],
  206:             freq="ns",
  207:         )
  208:         tm.assert_index_equal(idx, exp)
  209: 
  210:     def test_constructor_arrays_negative_year(self):
  211:         years = np.arange(1960, 2000, dtype=np.int64).repeat(4)
  212:         quarters = np.tile(np.array([1, 2, 3, 4], dtype=np.int64), 40)
  213: 
  214:         msg = "Constructing PeriodIndex from fields is deprecated"
  215:         with tm.assert_produces_warning(FutureWarning, match=msg):
  216:             pindex = PeriodIndex(year=years, quarter=quarters)
  217: 
  218:         tm.assert_index_equal(pindex.year, Index(years))
  219:         tm.assert_index_equal(pindex.quarter, Index(quarters))
  220: 
  221:         alt = PeriodIndex.from_fields(year=years, quarter=quarters)
  222:         tm.assert_index_equal(alt, pindex)
  223: 
  224:     def test_constructor_invalid_quarters(self):
  225:         depr_msg = "Constructing PeriodIndex from fields is deprecated"
  226:         msg = "Quarter must be 1 <= q <= 4"
  227:         with pytest.raises(ValueError, match=msg):
  228:             with tm.assert_produces_warning(FutureWarning, match=depr_msg):
  229:                 PeriodIndex(
  230:                     year=range(2000, 2004), quarter=list(range(4)), freq="Q-DEC"
  231:                 )
  232: 
  233:     def test_period_range_fractional_period(self):
  234:         msg = "Non-integer 'periods' in pd.date_range, pd.timedelta_range"
  235:         with tm.assert_produces_warning(FutureWarning, match=msg):
  236:             result = period_range("2007-01", periods=10.5, freq="M")
  237:         exp = period_range("2007-01", periods=10, freq="M")
  238:         tm.assert_index_equal(result, exp)
  239: 
  240:     def test_constructor_with_without_freq(self):
  241:         # GH53687
  242:         start = Period("2002-01-01 00:00", freq="30min")
  243:         exp = period_range(start=start, periods=5, freq=start.freq)
  244:         result = period_range(start=start, periods=5)
  245:         tm.assert_index_equal(exp, result)
  246: 
  247:     def test_constructor_fromarraylike(self):
  248:         idx = period_range("2007-01", periods=20, freq="M")
  249: 
  250:         # values is an array of Period, thus can retrieve freq
  251:         tm.assert_index_equal(PeriodIndex(idx.values), idx)
  252:         tm.assert_index_equal(PeriodIndex(list(idx.values)), idx)
  253: 
  254:         msg = "freq not specified and cannot be inferred"
  255:         with pytest.raises(ValueError, match=msg):
  256:             PeriodIndex(idx.asi8)
  257:         with pytest.raises(ValueError, match=msg):
  258:             PeriodIndex(list(idx.asi8))
  259: 
  260:         msg = "'Period' object is not iterable"
  261:         with pytest.raises(TypeError, match=msg):
  262:             PeriodIndex(data=Period("2007", freq="Y"))
  263: 
  264:         result = PeriodIndex(iter(idx))
  265:         tm.assert_index_equal(result, idx)
  266: 
  267:         result = PeriodIndex(idx)
  268:         tm.assert_index_equal(result, idx)
  269: 
  270:         result = PeriodIndex(idx, freq="M")
  271:         tm.assert_index_equal(result, idx)
  272: 
  273:         result = PeriodIndex(idx, freq=offsets.MonthEnd())
  274:         tm.assert_index_equal(result, idx)
  275:         assert result.freq == "ME"
  276: 
  277:         result = PeriodIndex(idx, freq="2M")
  278:         tm.assert_index_equal(result, idx.asfreq("2M"))
  279:         assert result.freq == "2ME"
  280: 
  281:         result = PeriodIndex(idx, freq=offsets.MonthEnd(2))
  282:         tm.assert_index_equal(result, idx.asfreq("2M"))
  283:         assert result.freq == "2ME"
  284: 
  285:         result = PeriodIndex(idx, freq="D")
  286:         exp = idx.asfreq("D", "e")
  287:         tm.assert_index_equal(result, exp)
  288: 
  289:     def test_constructor_datetime64arr(self):
  290:         vals = np.arange(100000, 100000 + 10000, 100, dtype=np.int64)
  291:         vals = vals.view(np.dtype("M8[us]"))
  292: 
  293:         pi = PeriodIndex(vals, freq="D")
  294: 
  295:         expected = PeriodIndex(vals.astype("M8[ns]"), freq="D")
  296:         tm.assert_index_equal(pi, expected)
  297: 
  298:     @pytest.mark.parametrize("box", [None, "series", "index"])
  299:     def test_constructor_datetime64arr_ok(self, box):
  300:         # https://github.com/pandas-dev/pandas/issues/23438
  301:         data = date_range("2017", periods=4, freq="ME")
  302:         if box is None:
  303:             data = data._values
  304:         elif box == "series":
  305:             data = Series(data)
  306: 
  307:         result = PeriodIndex(data, freq="D")
  308:         expected = PeriodIndex(
  309:             ["2017-01-31", "2017-02-28", "2017-03-31", "2017-04-30"], freq="D"
  310:         )
  311:         tm.assert_index_equal(result, expected)
  312: 
  313:     def test_constructor_dtype(self):
  314:         # passing a dtype with a tz should localize
  315:         idx = PeriodIndex(["2013-01", "2013-03"], dtype="period[M]")
  316:         exp = PeriodIndex(["2013-01", "2013-03"], freq="M")
  317:         tm.assert_index_equal(idx, exp)
  318:         assert idx.dtype == "period[M]"
  319: 
  320:         idx = PeriodIndex(["2013-01-05", "2013-03-05"], dtype="period[3D]")
  321:         exp = PeriodIndex(["2013-01-05", "2013-03-05"], freq="3D")
  322:         tm.assert_index_equal(idx, exp)
  323:         assert idx.dtype == "period[3D]"
  324: 
  325:         # if we already have a freq and its not the same, then asfreq
  326:         # (not changed)
  327:         idx = PeriodIndex(["2013-01-01", "2013-01-02"], freq="D")
  328: 
  329:         res = PeriodIndex(idx, dtype="period[M]")
  330:         exp = PeriodIndex(["2013-01", "2013-01"], freq="M")
  331:         tm.assert_index_equal(res, exp)
  332:         assert res.dtype == "period[M]"
  333: 
  334:         res = PeriodIndex(idx, freq="M")
  335:         tm.assert_index_equal(res, exp)
  336:         assert res.dtype == "period[M]"
  337: 
  338:         msg = "specified freq and dtype are different"
  339:         with pytest.raises(IncompatibleFrequency, match=msg):
  340:             PeriodIndex(["2011-01"], freq="M", dtype="period[D]")
  341: 
  342:     def test_constructor_empty(self):
  343:         idx = PeriodIndex([], freq="M")
  344:         assert isinstance(idx, PeriodIndex)
  345:         assert len(idx) == 0
  346:         assert idx.freq == "ME"
  347: 
  348:         with pytest.raises(ValueError, match="freq not specified"):
  349:             PeriodIndex([])
  350: 
  351:     def test_constructor_pi_nat(self):
  352:         idx = PeriodIndex(
  353:             [Period("2011-01", freq="M"), NaT, Period("2011-01", freq="M")]
  354:         )
  355:         exp = PeriodIndex(["2011-01", "NaT", "2011-01"], freq="M")
  356:         tm.assert_index_equal(idx, exp)
  357: 
  358:         idx = PeriodIndex(
  359:             np.array([Period("2011-01", freq="M"), NaT, Period("2011-01", freq="M")])
  360:         )
  361:         tm.assert_index_equal(idx, exp)
  362: 
  363:         idx = PeriodIndex(
  364:             [NaT, NaT, Period("2011-01", freq="M"), Period("2011-01", freq="M")]
  365:         )
  366:         exp = PeriodIndex(["NaT", "NaT", "2011-01", "2011-01"], freq="M")
  367:         tm.assert_index_equal(idx, exp)
  368: 
  369:         idx = PeriodIndex(
  370:             np.array(
  371:                 [NaT, NaT, Period("2011-01", freq="M"), Period("2011-01", freq="M")]
  372:             )
  373:         )
  374:         tm.assert_index_equal(idx, exp)
  375: 
  376:         idx = PeriodIndex([NaT, NaT, "2011-01", "2011-01"], freq="M")
  377:         tm.assert_index_equal(idx, exp)
  378: 
  379:         with pytest.raises(ValueError, match="freq not specified"):
  380:             PeriodIndex([NaT, NaT])
  381: 
  382:         with pytest.raises(ValueError, match="freq not specified"):
  383:             PeriodIndex(np.array([NaT, NaT]))
  384: 
  385:         with pytest.raises(ValueError, match="freq not specified"):
  386:             PeriodIndex(["NaT", "NaT"])
  387: 
  388:         with pytest.raises(ValueError, match="freq not specified"):
  389:             PeriodIndex(np.array(["NaT", "NaT"]))
  390: 
  391:     def test_constructor_incompat_freq(self):
  392:         msg = "Input has different freq=D from PeriodIndex\\(freq=M\\)"
  393: 
  394:         with pytest.raises(IncompatibleFrequency, match=msg):
  395:             PeriodIndex([Period("2011-01", freq="M"), NaT, Period("2011-01", freq="D")])
  396: 
  397:         with pytest.raises(IncompatibleFrequency, match=msg):
  398:             PeriodIndex(
  399:                 np.array(
  400:                     [Period("2011-01", freq="M"), NaT, Period("2011-01", freq="D")]
  401:                 )
  402:             )
  403: 
  404:         # first element is NaT
  405:         with pytest.raises(IncompatibleFrequency, match=msg):
  406:             PeriodIndex([NaT, Period("2011-01", freq="M"), Period("2011-01", freq="D")])
  407: 
  408:         with pytest.raises(IncompatibleFrequency, match=msg):
  409:             PeriodIndex(
  410:                 np.array(
  411:                     [NaT, Period("2011-01", freq="M"), Period("2011-01", freq="D")]
  412:                 )
  413:             )
  414: 
  415:     def test_constructor_mixed(self):
  416:         idx = PeriodIndex(["2011-01", NaT, Period("2011-01", freq="M")])
  417:         exp = PeriodIndex(["2011-01", "NaT", "2011-01"], freq="M")
  418:         tm.assert_index_equal(idx, exp)
  419: 
  420:         idx = PeriodIndex(["NaT", NaT, Period("2011-01", freq="M")])
  421:         exp = PeriodIndex(["NaT", "NaT", "2011-01"], freq="M")
  422:         tm.assert_index_equal(idx, exp)
  423: 
  424:         idx = PeriodIndex([Period("2011-01-01", freq="D"), NaT, "2012-01-01"])
  425:         exp = PeriodIndex(["2011-01-01", "NaT", "2012-01-01"], freq="D")
  426:         tm.assert_index_equal(idx, exp)
  427: 
  428:     @pytest.mark.parametrize("floats", [[1.1, 2.1], np.array([1.1, 2.1])])
  429:     def test_constructor_floats(self, floats):
  430:         msg = "PeriodIndex does not allow floating point in construction"
  431:         with pytest.raises(TypeError, match=msg):
  432:             PeriodIndex(floats)
  433: 
  434:     def test_constructor_year_and_quarter(self):
  435:         year = Series([2001, 2002, 2003])
  436:         quarter = year - 2000
  437:         msg = "Constructing PeriodIndex from fields is deprecated"
  438:         with tm.assert_produces_warning(FutureWarning, match=msg):
  439:             idx = PeriodIndex(year=year, quarter=quarter)
  440:         strs = [f"{t[0]:d}Q{t[1]:d}" for t in zip(quarter, year)]
  441:         lops = list(map(Period, strs))
  442:         p = PeriodIndex(lops)
  443:         tm.assert_index_equal(p, idx)
  444: 
  445:     def test_constructor_freq_mult(self):
  446:         # GH #7811
  447:         pidx = period_range(start="2014-01", freq="2M", periods=4)
  448:         expected = PeriodIndex(["2014-01", "2014-03", "2014-05", "2014-07"], freq="2M")
  449:         tm.assert_index_equal(pidx, expected)
  450: 
  451:         pidx = period_range(start="2014-01-02", end="2014-01-15", freq="3D")
  452:         expected = PeriodIndex(
  453:             ["2014-01-02", "2014-01-05", "2014-01-08", "2014-01-11", "2014-01-14"],
  454:             freq="3D",
  455:         )
  456:         tm.assert_index_equal(pidx, expected)
  457: 
  458:         pidx = period_range(end="2014-01-01 17:00", freq="4h", periods=3)
  459:         expected = PeriodIndex(
  460:             ["2014-01-01 09:00", "2014-01-01 13:00", "2014-01-01 17:00"], freq="4h"
  461:         )
  462:         tm.assert_index_equal(pidx, expected)
  463: 
  464:         msg = "Frequency must be positive, because it represents span: -1M"
  465:         with pytest.raises(ValueError, match=msg):
  466:             PeriodIndex(["2011-01"], freq="-1M")
  467: 
  468:         msg = "Frequency must be positive, because it represents span: 0M"
  469:         with pytest.raises(ValueError, match=msg):
  470:             PeriodIndex(["2011-01"], freq="0M")
  471: 
  472:         msg = "Frequency must be positive, because it represents span: 0M"
  473:         with pytest.raises(ValueError, match=msg):
  474:             period_range("2011-01", periods=3, freq="0M")
  475: 
  476:     @pytest.mark.parametrize(
  477:         "freq_offset, freq_period",
  478:         [
  479:             ("YE", "Y"),
  480:             ("ME", "M"),
  481:             ("D", "D"),
  482:             ("min", "min"),
  483:             ("s", "s"),
  484:         ],
  485:     )
  486:     @pytest.mark.parametrize("mult", [1, 2, 3, 4, 5])
  487:     def test_constructor_freq_mult_dti_compat(self, mult, freq_offset, freq_period):
  488:         freqstr_offset = str(mult) + freq_offset
  489:         freqstr_period = str(mult) + freq_period
  490:         pidx = period_range(start="2014-04-01", freq=freqstr_period, periods=10)
  491:         expected = date_range(
  492:             start="2014-04-01", freq=freqstr_offset, periods=10
  493:         ).to_period(freqstr_period)
  494:         tm.assert_index_equal(pidx, expected)
  495: 
  496:     @pytest.mark.parametrize("mult", [1, 2, 3, 4, 5])
  497:     def test_constructor_freq_mult_dti_compat_month(self, mult):
  498:         pidx = period_range(start="2014-04-01", freq=f"{mult}M", periods=10)
  499:         expected = date_range(
  500:             start="2014-04-01", freq=f"{mult}ME", periods=10
  501:         ).to_period(f"{mult}M")
  502:         tm.assert_index_equal(pidx, expected)
  503: 
  504:     def test_constructor_freq_combined(self):
  505:         for freq in ["1D1h", "1h1D"]:
  506:             pidx = PeriodIndex(["2016-01-01", "2016-01-02"], freq=freq)
  507:             expected = PeriodIndex(["2016-01-01 00:00", "2016-01-02 00:00"], freq="25h")
  508:         for freq in ["1D1h", "1h1D"]:
  509:             pidx = period_range(start="2016-01-01", periods=2, freq=freq)
  510:             expected = PeriodIndex(["2016-01-01 00:00", "2016-01-02 01:00"], freq="25h")
  511:             tm.assert_index_equal(pidx, expected)
  512: 
  513:     def test_period_range_length(self):
  514:         pi = period_range(freq="Y", start="1/1/2001", end="12/1/2009")
  515:         assert len(pi) == 9
  516: 
  517:         pi = period_range(freq="Q", start="1/1/2001", end="12/1/2009")
  518:         assert len(pi) == 4 * 9
  519: 
  520:         pi = period_range(freq="M", start="1/1/2001", end="12/1/2009")
  521:         assert len(pi) == 12 * 9
  522: 
  523:         pi = period_range(freq="D", start="1/1/2001", end="12/31/2009")
  524:         assert len(pi) == 365 * 9 + 2
  525: 
  526:         msg = "Period with BDay freq is deprecated"
  527:         with tm.assert_produces_warning(FutureWarning, match=msg):
  528:             pi = period_range(freq="B", start="1/1/2001", end="12/31/2009")
  529:         assert len(pi) == 261 * 9
  530: 
  531:         pi = period_range(freq="h", start="1/1/2001", end="12/31/2001 23:00")
  532:         assert len(pi) == 365 * 24
  533: 
  534:         pi = period_range(freq="Min", start="1/1/2001", end="1/1/2001 23:59")
  535:         assert len(pi) == 24 * 60
  536: 
  537:         pi = period_range(freq="s", start="1/1/2001", end="1/1/2001 23:59:59")
  538:         assert len(pi) == 24 * 60 * 60
  539: 
  540:         with tm.assert_produces_warning(FutureWarning, match=msg):
  541:             start = Period("02-Apr-2005", "B")
  542:             i1 = period_range(start=start, periods=20)
  543:         assert len(i1) == 20
  544:         assert i1.freq == start.freq
  545:         assert i1[0] == start
  546: 
  547:         end_intv = Period("2006-12-31", "W")
  548:         i1 = period_range(end=end_intv, periods=10)
  549:         assert len(i1) == 10
  550:         assert i1.freq == end_intv.freq
  551:         assert i1[-1] == end_intv
  552: 
  553:         msg = "'w' is deprecated and will be removed in a future version."
  554:         with tm.assert_produces_warning(FutureWarning, match=msg):
  555:             end_intv = Period("2006-12-31", "1w")
  556:         i2 = period_range(end=end_intv, periods=10)
  557:         assert len(i1) == len(i2)
  558:         assert (i1 == i2).all()
  559:         assert i1.freq == i2.freq
  560: 
  561:     def test_infer_freq_from_first_element(self):
  562:         msg = "Period with BDay freq is deprecated"
  563:         with tm.assert_produces_warning(FutureWarning, match=msg):
  564:             start = Period("02-Apr-2005", "B")
  565:             end_intv = Period("2005-05-01", "B")
  566:             period_range(start=start, end=end_intv)
  567: 
  568:             # infer freq from first element
  569:             i2 = PeriodIndex([end_intv, Period("2005-05-05", "B")])
  570:         assert len(i2) == 2
  571:         assert i2[0] == end_intv
  572: 
  573:         with tm.assert_produces_warning(FutureWarning, match=msg):
  574:             i2 = PeriodIndex(np.array([end_intv, Period("2005-05-05", "B")]))
  575:         assert len(i2) == 2
  576:         assert i2[0] == end_intv
  577: 
  578:     def test_mixed_freq_raises(self):
  579:         # Mixed freq should fail
  580:         msg = "Period with BDay freq is deprecated"
  581:         with tm.assert_produces_warning(FutureWarning, match=msg):
  582:             end_intv = Period("2005-05-01", "B")
  583: 
  584:         msg = "'w' is deprecated and will be removed in a future version."
  585:         with tm.assert_produces_warning(FutureWarning, match=msg):
  586:             vals = [end_intv, Period("2006-12-31", "w")]
  587:         msg = r"Input has different freq=W-SUN from PeriodIndex\(freq=B\)"
  588:         depr_msg = r"PeriodDtype\[B\] is deprecated"
  589:         with pytest.raises(IncompatibleFrequency, match=msg):
  590:             with tm.assert_produces_warning(FutureWarning, match=depr_msg):
  591:                 PeriodIndex(vals)
  592:         vals = np.array(vals)
  593:         with pytest.raises(IncompatibleFrequency, match=msg):
  594:             with tm.assert_produces_warning(FutureWarning, match=depr_msg):
  595:                 PeriodIndex(vals)
  596: 
  597:     @pytest.mark.parametrize(
  598:         "freq", ["M", "Q", "Y", "D", "B", "min", "s", "ms", "us", "ns", "h"]
  599:     )
  600:     @pytest.mark.filterwarnings(
  601:         r"ignore:Period with BDay freq is deprecated:FutureWarning"
  602:     )
  603:     @pytest.mark.filterwarnings(r"ignore:PeriodDtype\[B\] is deprecated:FutureWarning")
  604:     def test_recreate_from_data(self, freq):
  605:         org = period_range(start="2001/04/01", freq=freq, periods=1)
  606:         idx = PeriodIndex(org.values, freq=freq)
  607:         tm.assert_index_equal(idx, org)
  608: 
  609:     def test_map_with_string_constructor(self):
  610:         raw = [2005, 2007, 2009]
  611:         index = PeriodIndex(raw, freq="Y")
  612: 
  613:         expected = Index([str(num) for num in raw])
  614:         res = index.map(str)
  615: 
  616:         # should return an Index
  617:         assert isinstance(res, Index)
  618: 
  619:         # preserve element types
  620:         assert all(isinstance(resi, str) for resi in res)
  621: 
  622:         # lastly, values should compare equal
  623:         tm.assert_index_equal(res, expected)
  624: 
  625: 
  626: class TestSimpleNew:
  627:     def test_constructor_simple_new(self):
  628:         idx = period_range("2007-01", name="p", periods=2, freq="M")
  629: 
  630:         with pytest.raises(AssertionError, match="<class .*PeriodIndex'>"):
  631:             idx._simple_new(idx, name="p")
  632: 
  633:         result = idx._simple_new(idx._data, name="p")
  634:         tm.assert_index_equal(result, idx)
  635: 
  636:         msg = "Should be numpy array of type i8"
  637:         with pytest.raises(AssertionError, match=msg):
  638:             # Need ndarray, not int64 Index
  639:             type(idx._data)._simple_new(Index(idx.asi8), dtype=idx.dtype)
  640: 
  641:         arr = type(idx._data)._simple_new(idx.asi8, dtype=idx.dtype)
  642:         result = idx._simple_new(arr, name="p")
  643:         tm.assert_index_equal(result, idx)
  644: 
  645:     def test_constructor_simple_new_empty(self):
  646:         # GH13079
  647:         idx = PeriodIndex([], freq="M", name="p")
  648:         with pytest.raises(AssertionError, match="<class .*PeriodIndex'>"):
  649:             idx._simple_new(idx, name="p")
  650: 
  651:         result = idx._simple_new(idx._data, name="p")
  652:         tm.assert_index_equal(result, idx)
  653: 
  654:     @pytest.mark.parametrize("floats", [[1.1, 2.1], np.array([1.1, 2.1])])
  655:     def test_period_index_simple_new_disallows_floats(self, floats):
  656:         with pytest.raises(AssertionError, match="<class "):
  657:             PeriodIndex._simple_new(floats)
  658: 
  659: 
  660: class TestShallowCopy:
  661:     def test_shallow_copy_empty(self):
  662:         # GH#13067
  663:         idx = PeriodIndex([], freq="M")
  664:         result = idx._view()
  665:         expected = idx
  666: 
  667:         tm.assert_index_equal(result, expected)
  668: 
  669:     def test_shallow_copy_disallow_i8(self):
  670:         # GH#24391
  671:         pi = period_range("2018-01-01", periods=3, freq="2D")
  672:         with pytest.raises(AssertionError, match="ndarray"):
  673:             pi._shallow_copy(pi.asi8)
  674: 
  675:     def test_shallow_copy_requires_disallow_period_index(self):
  676:         pi = period_range("2018-01-01", periods=3, freq="2D")
  677:         with pytest.raises(AssertionError, match="PeriodIndex"):
  678:             pi._shallow_copy(pi)
  679: 
  680: 
  681: class TestSeriesPeriod:
  682:     def test_constructor_cant_cast_period(self):
  683:         msg = "Cannot cast PeriodIndex to dtype float64"
  684:         with pytest.raises(TypeError, match=msg):
  685:             Series(period_range("2000-01-01", periods=10, freq="D"), dtype=float)
  686: 
  687:     def test_constructor_cast_object(self):
  688:         pi = period_range("1/1/2000", periods=10)
  689:         ser = Series(pi, dtype=PeriodDtype("D"))
  690:         exp = Series(pi)
  691:         tm.assert_series_equal(ser, exp)
