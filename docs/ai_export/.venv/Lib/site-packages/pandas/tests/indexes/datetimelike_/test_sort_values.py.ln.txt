    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas import (
    5:     DatetimeIndex,
    6:     Index,
    7:     NaT,
    8:     PeriodIndex,
    9:     TimedeltaIndex,
   10:     timedelta_range,
   11: )
   12: import pandas._testing as tm
   13: 
   14: 
   15: def check_freq_ascending(ordered, orig, ascending):
   16:     """
   17:     Check the expected freq on a PeriodIndex/DatetimeIndex/TimedeltaIndex
   18:     when the original index is generated (or generate-able) with
   19:     period_range/date_range/timedelta_range.
   20:     """
   21:     if isinstance(ordered, PeriodIndex):
   22:         assert ordered.freq == orig.freq
   23:     elif isinstance(ordered, (DatetimeIndex, TimedeltaIndex)):
   24:         if ascending:
   25:             assert ordered.freq.n == orig.freq.n
   26:         else:
   27:             assert ordered.freq.n == -1 * orig.freq.n
   28: 
   29: 
   30: def check_freq_nonmonotonic(ordered, orig):
   31:     """
   32:     Check the expected freq on a PeriodIndex/DatetimeIndex/TimedeltaIndex
   33:     when the original index is _not_ generated (or generate-able) with
   34:     period_range/date_range//timedelta_range.
   35:     """
   36:     if isinstance(ordered, PeriodIndex):
   37:         assert ordered.freq == orig.freq
   38:     elif isinstance(ordered, (DatetimeIndex, TimedeltaIndex)):
   39:         assert ordered.freq is None
   40: 
   41: 
   42: class TestSortValues:
   43:     @pytest.fixture(params=[DatetimeIndex, TimedeltaIndex, PeriodIndex])
   44:     def non_monotonic_idx(self, request):
   45:         if request.param is DatetimeIndex:
   46:             return DatetimeIndex(["2000-01-04", "2000-01-01", "2000-01-02"])
   47:         elif request.param is PeriodIndex:
   48:             dti = DatetimeIndex(["2000-01-04", "2000-01-01", "2000-01-02"])
   49:             return dti.to_period("D")
   50:         else:
   51:             return TimedeltaIndex(
   52:                 ["1 day 00:00:05", "1 day 00:00:01", "1 day 00:00:02"]
   53:             )
   54: 
   55:     def test_argmin_argmax(self, non_monotonic_idx):
   56:         assert non_monotonic_idx.argmin() == 1
   57:         assert non_monotonic_idx.argmax() == 0
   58: 
   59:     def test_sort_values(self, non_monotonic_idx):
   60:         idx = non_monotonic_idx
   61:         ordered = idx.sort_values()
   62:         assert ordered.is_monotonic_increasing
   63:         ordered = idx.sort_values(ascending=False)
   64:         assert ordered[::-1].is_monotonic_increasing
   65: 
   66:         ordered, dexer = idx.sort_values(return_indexer=True)
   67:         assert ordered.is_monotonic_increasing
   68:         tm.assert_numpy_array_equal(dexer, np.array([1, 2, 0], dtype=np.intp))
   69: 
   70:         ordered, dexer = idx.sort_values(return_indexer=True, ascending=False)
   71:         assert ordered[::-1].is_monotonic_increasing
   72:         tm.assert_numpy_array_equal(dexer, np.array([0, 2, 1], dtype=np.intp))
   73: 
   74:     def check_sort_values_with_freq(self, idx):
   75:         ordered = idx.sort_values()
   76:         tm.assert_index_equal(ordered, idx)
   77:         check_freq_ascending(ordered, idx, True)
   78: 
   79:         ordered = idx.sort_values(ascending=False)
   80:         expected = idx[::-1]
   81:         tm.assert_index_equal(ordered, expected)
   82:         check_freq_ascending(ordered, idx, False)
   83: 
   84:         ordered, indexer = idx.sort_values(return_indexer=True)
   85:         tm.assert_index_equal(ordered, idx)
   86:         tm.assert_numpy_array_equal(indexer, np.array([0, 1, 2], dtype=np.intp))
   87:         check_freq_ascending(ordered, idx, True)
   88: 
   89:         ordered, indexer = idx.sort_values(return_indexer=True, ascending=False)
   90:         expected = idx[::-1]
   91:         tm.assert_index_equal(ordered, expected)
   92:         tm.assert_numpy_array_equal(indexer, np.array([2, 1, 0], dtype=np.intp))
   93:         check_freq_ascending(ordered, idx, False)
   94: 
   95:     @pytest.mark.parametrize("freq", ["D", "h"])
   96:     def test_sort_values_with_freq_timedeltaindex(self, freq):
   97:         # GH#10295
   98:         idx = timedelta_range(start=f"1{freq}", periods=3, freq=freq).rename("idx")
   99: 
  100:         self.check_sort_values_with_freq(idx)
  101: 
  102:     @pytest.mark.parametrize(
  103:         "idx",
  104:         [
  105:             DatetimeIndex(
  106:                 ["2011-01-01", "2011-01-02", "2011-01-03"], freq="D", name="idx"
  107:             ),
  108:             DatetimeIndex(
  109:                 ["2011-01-01 09:00", "2011-01-01 10:00", "2011-01-01 11:00"],
  110:                 freq="h",
  111:                 name="tzidx",
  112:                 tz="Asia/Tokyo",
  113:             ),
  114:         ],
  115:     )
  116:     def test_sort_values_with_freq_datetimeindex(self, idx):
  117:         self.check_sort_values_with_freq(idx)
  118: 
  119:     @pytest.mark.parametrize("freq", ["D", "2D", "4D"])
  120:     def test_sort_values_with_freq_periodindex(self, freq):
  121:         # here with_freq refers to being period_range-like
  122:         idx = PeriodIndex(
  123:             ["2011-01-01", "2011-01-02", "2011-01-03"], freq=freq, name="idx"
  124:         )
  125:         self.check_sort_values_with_freq(idx)
  126: 
  127:     @pytest.mark.parametrize(
  128:         "idx",
  129:         [
  130:             PeriodIndex(["2011", "2012", "2013"], name="pidx", freq="Y"),
  131:             Index([2011, 2012, 2013], name="idx"),  # for compatibility check
  132:         ],
  133:     )
  134:     def test_sort_values_with_freq_periodindex2(self, idx):
  135:         # here with_freq indicates this is period_range-like
  136:         self.check_sort_values_with_freq(idx)
  137: 
  138:     def check_sort_values_without_freq(self, idx, expected):
  139:         ordered = idx.sort_values(na_position="first")
  140:         tm.assert_index_equal(ordered, expected)
  141:         check_freq_nonmonotonic(ordered, idx)
  142: 
  143:         if not idx.isna().any():
  144:             ordered = idx.sort_values()
  145:             tm.assert_index_equal(ordered, expected)
  146:             check_freq_nonmonotonic(ordered, idx)
  147: 
  148:         ordered = idx.sort_values(ascending=False)
  149:         tm.assert_index_equal(ordered, expected[::-1])
  150:         check_freq_nonmonotonic(ordered, idx)
  151: 
  152:         ordered, indexer = idx.sort_values(return_indexer=True, na_position="first")
  153:         tm.assert_index_equal(ordered, expected)
  154: 
  155:         exp = np.array([0, 4, 3, 1, 2], dtype=np.intp)
  156:         tm.assert_numpy_array_equal(indexer, exp)
  157:         check_freq_nonmonotonic(ordered, idx)
  158: 
  159:         if not idx.isna().any():
  160:             ordered, indexer = idx.sort_values(return_indexer=True)
  161:             tm.assert_index_equal(ordered, expected)
  162: 
  163:             exp = np.array([0, 4, 3, 1, 2], dtype=np.intp)
  164:             tm.assert_numpy_array_equal(indexer, exp)
  165:             check_freq_nonmonotonic(ordered, idx)
  166: 
  167:         ordered, indexer = idx.sort_values(return_indexer=True, ascending=False)
  168:         tm.assert_index_equal(ordered, expected[::-1])
  169: 
  170:         exp = np.array([2, 1, 3, 0, 4], dtype=np.intp)
  171:         tm.assert_numpy_array_equal(indexer, exp)
  172:         check_freq_nonmonotonic(ordered, idx)
  173: 
  174:     def test_sort_values_without_freq_timedeltaindex(self):
  175:         # GH#10295
  176: 
  177:         idx = TimedeltaIndex(
  178:             ["1 hour", "3 hour", "5 hour", "2 hour ", "1 hour"], name="idx1"
  179:         )
  180:         expected = TimedeltaIndex(
  181:             ["1 hour", "1 hour", "2 hour", "3 hour", "5 hour"], name="idx1"
  182:         )
  183:         self.check_sort_values_without_freq(idx, expected)
  184: 
  185:     @pytest.mark.parametrize(
  186:         "index_dates,expected_dates",
  187:         [
  188:             (
  189:                 ["2011-01-01", "2011-01-03", "2011-01-05", "2011-01-02", "2011-01-01"],
  190:                 ["2011-01-01", "2011-01-01", "2011-01-02", "2011-01-03", "2011-01-05"],
  191:             ),
  192:             (
  193:                 ["2011-01-01", "2011-01-03", "2011-01-05", "2011-01-02", "2011-01-01"],
  194:                 ["2011-01-01", "2011-01-01", "2011-01-02", "2011-01-03", "2011-01-05"],
  195:             ),
  196:             (
  197:                 [NaT, "2011-01-03", "2011-01-05", "2011-01-02", NaT],
  198:                 [NaT, NaT, "2011-01-02", "2011-01-03", "2011-01-05"],
  199:             ),
  200:         ],
  201:     )
  202:     def test_sort_values_without_freq_datetimeindex(
  203:         self, index_dates, expected_dates, tz_naive_fixture
  204:     ):
  205:         tz = tz_naive_fixture
  206: 
  207:         # without freq
  208:         idx = DatetimeIndex(index_dates, tz=tz, name="idx")
  209:         expected = DatetimeIndex(expected_dates, tz=tz, name="idx")
  210: 
  211:         self.check_sort_values_without_freq(idx, expected)
  212: 
  213:     @pytest.mark.parametrize(
  214:         "idx,expected",
  215:         [
  216:             (
  217:                 PeriodIndex(
  218:                     [
  219:                         "2011-01-01",
  220:                         "2011-01-03",
  221:                         "2011-01-05",
  222:                         "2011-01-02",
  223:                         "2011-01-01",
  224:                     ],
  225:                     freq="D",
  226:                     name="idx1",
  227:                 ),
  228:                 PeriodIndex(
  229:                     [
  230:                         "2011-01-01",
  231:                         "2011-01-01",
  232:                         "2011-01-02",
  233:                         "2011-01-03",
  234:                         "2011-01-05",
  235:                     ],
  236:                     freq="D",
  237:                     name="idx1",
  238:                 ),
  239:             ),
  240:             (
  241:                 PeriodIndex(
  242:                     [
  243:                         "2011-01-01",
  244:                         "2011-01-03",
  245:                         "2011-01-05",
  246:                         "2011-01-02",
  247:                         "2011-01-01",
  248:                     ],
  249:                     freq="D",
  250:                     name="idx2",
  251:                 ),
  252:                 PeriodIndex(
  253:                     [
  254:                         "2011-01-01",
  255:                         "2011-01-01",
  256:                         "2011-01-02",
  257:                         "2011-01-03",
  258:                         "2011-01-05",
  259:                     ],
  260:                     freq="D",
  261:                     name="idx2",
  262:                 ),
  263:             ),
  264:             (
  265:                 PeriodIndex(
  266:                     [NaT, "2011-01-03", "2011-01-05", "2011-01-02", NaT],
  267:                     freq="D",
  268:                     name="idx3",
  269:                 ),
  270:                 PeriodIndex(
  271:                     [NaT, NaT, "2011-01-02", "2011-01-03", "2011-01-05"],
  272:                     freq="D",
  273:                     name="idx3",
  274:                 ),
  275:             ),
  276:             (
  277:                 PeriodIndex(
  278:                     ["2011", "2013", "2015", "2012", "2011"], name="pidx", freq="Y"
  279:                 ),
  280:                 PeriodIndex(
  281:                     ["2011", "2011", "2012", "2013", "2015"], name="pidx", freq="Y"
  282:                 ),
  283:             ),
  284:             (
  285:                 # For compatibility check
  286:                 Index([2011, 2013, 2015, 2012, 2011], name="idx"),
  287:                 Index([2011, 2011, 2012, 2013, 2015], name="idx"),
  288:             ),
  289:         ],
  290:     )
  291:     def test_sort_values_without_freq_periodindex(self, idx, expected):
  292:         # here without_freq means not generateable by period_range
  293:         self.check_sort_values_without_freq(idx, expected)
  294: 
  295:     def test_sort_values_without_freq_periodindex_nat(self):
  296:         # doesn't quite fit into check_sort_values_without_freq
  297:         idx = PeriodIndex(["2011", "2013", "NaT", "2011"], name="pidx", freq="D")
  298:         expected = PeriodIndex(["NaT", "2011", "2011", "2013"], name="pidx", freq="D")
  299: 
  300:         ordered = idx.sort_values(na_position="first")
  301:         tm.assert_index_equal(ordered, expected)
  302:         check_freq_nonmonotonic(ordered, idx)
  303: 
  304:         ordered = idx.sort_values(ascending=False)
  305:         tm.assert_index_equal(ordered, expected[::-1])
  306:         check_freq_nonmonotonic(ordered, idx)
  307: 
  308: 
  309: def test_order_stability_compat():
  310:     # GH#35922. sort_values is stable both for normal and datetime-like Index
  311:     pidx = PeriodIndex(["2011", "2013", "2015", "2012", "2011"], name="pidx", freq="Y")
  312:     iidx = Index([2011, 2013, 2015, 2012, 2011], name="idx")
  313:     ordered1, indexer1 = pidx.sort_values(return_indexer=True, ascending=False)
  314:     ordered2, indexer2 = iidx.sort_values(return_indexer=True, ascending=False)
  315:     tm.assert_numpy_array_equal(indexer1, indexer2)
