    1: from datetime import (
    2:     datetime,
    3:     timezone,
    4: )
    5: 
    6: import numpy as np
    7: import pytest
    8: 
    9: from pandas import (
   10:     DataFrame,
   11:     DatetimeIndex,
   12:     Index,
   13:     Timestamp,
   14:     date_range,
   15:     period_range,
   16:     to_datetime,
   17: )
   18: import pandas._testing as tm
   19: 
   20: from pandas.tseries.offsets import (
   21:     BDay,
   22:     BMonthEnd,
   23: )
   24: 
   25: 
   26: class TestJoin:
   27:     def test_does_not_convert_mixed_integer(self):
   28:         df = DataFrame(np.ones((3, 2)), columns=date_range("2020-01-01", periods=2))
   29:         cols = df.columns.join(df.index, how="outer")
   30:         joined = cols.join(df.columns)
   31:         assert cols.dtype == np.dtype("O")
   32:         assert cols.dtype == joined.dtype
   33:         tm.assert_numpy_array_equal(cols.values, joined.values)
   34: 
   35:     def test_join_self(self, join_type):
   36:         index = date_range("1/1/2000", periods=10)
   37:         joined = index.join(index, how=join_type)
   38:         assert index is joined
   39: 
   40:     def test_join_with_period_index(self, join_type):
   41:         df = DataFrame(
   42:             np.ones((10, 2)),
   43:             index=date_range("2020-01-01", periods=10),
   44:             columns=period_range("2020-01-01", periods=2),
   45:         )
   46:         s = df.iloc[:5, 0]
   47: 
   48:         expected = df.columns.astype("O").join(s.index, how=join_type)
   49:         result = df.columns.join(s.index, how=join_type)
   50:         tm.assert_index_equal(expected, result)
   51: 
   52:     def test_join_object_index(self):
   53:         rng = date_range("1/1/2000", periods=10)
   54:         idx = Index(["a", "b", "c", "d"])
   55: 
   56:         result = rng.join(idx, how="outer")
   57:         assert isinstance(result[0], Timestamp)
   58: 
   59:     def test_join_utc_convert(self, join_type):
   60:         rng = date_range("1/1/2011", periods=100, freq="h", tz="utc")
   61: 
   62:         left = rng.tz_convert("US/Eastern")
   63:         right = rng.tz_convert("Europe/Berlin")
   64: 
   65:         result = left.join(left[:-5], how=join_type)
   66:         assert isinstance(result, DatetimeIndex)
   67:         assert result.tz == left.tz
   68: 
   69:         result = left.join(right[:-5], how=join_type)
   70:         assert isinstance(result, DatetimeIndex)
   71:         assert result.tz is timezone.utc
   72: 
   73:     def test_datetimeindex_union_join_empty(self, sort):
   74:         dti = date_range(start="1/1/2001", end="2/1/2001", freq="D")
   75:         empty = Index([])
   76: 
   77:         result = dti.union(empty, sort=sort)
   78:         expected = dti.astype("O")
   79:         tm.assert_index_equal(result, expected)
   80: 
   81:         result = dti.join(empty)
   82:         assert isinstance(result, DatetimeIndex)
   83:         tm.assert_index_equal(result, dti)
   84: 
   85:     def test_join_nonunique(self):
   86:         idx1 = to_datetime(["2012-11-06 16:00:11.477563", "2012-11-06 16:00:11.477563"])
   87:         idx2 = to_datetime(["2012-11-06 15:11:09.006507", "2012-11-06 15:11:09.006507"])
   88:         rs = idx1.join(idx2, how="outer")
   89:         assert rs.is_monotonic_increasing
   90: 
   91:     @pytest.mark.parametrize("freq", ["B", "C"])
   92:     def test_outer_join(self, freq):
   93:         # should just behave as union
   94:         start, end = datetime(2009, 1, 1), datetime(2010, 1, 1)
   95:         rng = date_range(start=start, end=end, freq=freq)
   96: 
   97:         # overlapping
   98:         left = rng[:10]
   99:         right = rng[5:10]
  100: 
  101:         the_join = left.join(right, how="outer")
  102:         assert isinstance(the_join, DatetimeIndex)
  103: 
  104:         # non-overlapping, gap in middle
  105:         left = rng[:5]
  106:         right = rng[10:]
  107: 
  108:         the_join = left.join(right, how="outer")
  109:         assert isinstance(the_join, DatetimeIndex)
  110:         assert the_join.freq is None
  111: 
  112:         # non-overlapping, no gap
  113:         left = rng[:5]
  114:         right = rng[5:10]
  115: 
  116:         the_join = left.join(right, how="outer")
  117:         assert isinstance(the_join, DatetimeIndex)
  118: 
  119:         # overlapping, but different offset
  120:         other = date_range(start, end, freq=BMonthEnd())
  121: 
  122:         the_join = rng.join(other, how="outer")
  123:         assert isinstance(the_join, DatetimeIndex)
  124:         assert the_join.freq is None
  125: 
  126:     def test_naive_aware_conflicts(self):
  127:         start, end = datetime(2009, 1, 1), datetime(2010, 1, 1)
  128:         naive = date_range(start, end, freq=BDay(), tz=None)
  129:         aware = date_range(start, end, freq=BDay(), tz="Asia/Hong_Kong")
  130: 
  131:         msg = "tz-naive.*tz-aware"
  132:         with pytest.raises(TypeError, match=msg):
  133:             naive.join(aware)
  134: 
  135:         with pytest.raises(TypeError, match=msg):
  136:             aware.join(naive)
  137: 
  138:     @pytest.mark.parametrize("tz", [None, "US/Pacific"])
  139:     def test_join_preserves_freq(self, tz):
  140:         # GH#32157
  141:         dti = date_range("2016-01-01", periods=10, tz=tz)
  142:         result = dti[:5].join(dti[5:], how="outer")
  143:         assert result.freq == dti.freq
  144:         tm.assert_index_equal(result, dti)
  145: 
  146:         result = dti[:5].join(dti[6:], how="outer")
  147:         assert result.freq is None
  148:         expected = dti.delete(5)
  149:         tm.assert_index_equal(result, expected)
