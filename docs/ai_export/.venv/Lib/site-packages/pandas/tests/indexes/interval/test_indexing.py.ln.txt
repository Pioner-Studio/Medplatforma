    1: import re
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: from pandas.errors import InvalidIndexError
    7: 
    8: from pandas import (
    9:     NA,
   10:     CategoricalIndex,
   11:     DatetimeIndex,
   12:     Index,
   13:     Interval,
   14:     IntervalIndex,
   15:     MultiIndex,
   16:     NaT,
   17:     Timedelta,
   18:     Timestamp,
   19:     array,
   20:     date_range,
   21:     interval_range,
   22:     isna,
   23:     period_range,
   24:     timedelta_range,
   25: )
   26: import pandas._testing as tm
   27: 
   28: 
   29: class TestGetItem:
   30:     def test_getitem(self, closed):
   31:         idx = IntervalIndex.from_arrays((0, 1, np.nan), (1, 2, np.nan), closed=closed)
   32:         assert idx[0] == Interval(0.0, 1.0, closed=closed)
   33:         assert idx[1] == Interval(1.0, 2.0, closed=closed)
   34:         assert isna(idx[2])
   35: 
   36:         result = idx[0:1]
   37:         expected = IntervalIndex.from_arrays((0.0,), (1.0,), closed=closed)
   38:         tm.assert_index_equal(result, expected)
   39: 
   40:         result = idx[0:2]
   41:         expected = IntervalIndex.from_arrays((0.0, 1), (1.0, 2.0), closed=closed)
   42:         tm.assert_index_equal(result, expected)
   43: 
   44:         result = idx[1:3]
   45:         expected = IntervalIndex.from_arrays(
   46:             (1.0, np.nan), (2.0, np.nan), closed=closed
   47:         )
   48:         tm.assert_index_equal(result, expected)
   49: 
   50:     def test_getitem_2d_deprecated(self):
   51:         # GH#30588 multi-dim indexing is deprecated, but raising is also acceptable
   52:         idx = IntervalIndex.from_breaks(range(11), closed="right")
   53:         with pytest.raises(ValueError, match="multi-dimensional indexing not allowed"):
   54:             idx[:, None]
   55:         with pytest.raises(ValueError, match="multi-dimensional indexing not allowed"):
   56:             # GH#44051
   57:             idx[True]
   58:         with pytest.raises(ValueError, match="multi-dimensional indexing not allowed"):
   59:             # GH#44051
   60:             idx[False]
   61: 
   62: 
   63: class TestWhere:
   64:     def test_where(self, listlike_box):
   65:         klass = listlike_box
   66: 
   67:         idx = IntervalIndex.from_breaks(range(11), closed="right")
   68:         cond = [True] * len(idx)
   69:         expected = idx
   70:         result = expected.where(klass(cond))
   71:         tm.assert_index_equal(result, expected)
   72: 
   73:         cond = [False] + [True] * len(idx[1:])
   74:         expected = IntervalIndex([np.nan] + idx[1:].tolist())
   75:         result = idx.where(klass(cond))
   76:         tm.assert_index_equal(result, expected)
   77: 
   78: 
   79: class TestTake:
   80:     def test_take(self, closed):
   81:         index = IntervalIndex.from_breaks(range(11), closed=closed)
   82: 
   83:         result = index.take(range(10))
   84:         tm.assert_index_equal(result, index)
   85: 
   86:         result = index.take([0, 0, 1])
   87:         expected = IntervalIndex.from_arrays([0, 0, 1], [1, 1, 2], closed=closed)
   88:         tm.assert_index_equal(result, expected)
   89: 
   90: 
   91: class TestGetLoc:
   92:     @pytest.mark.parametrize("side", ["right", "left", "both", "neither"])
   93:     def test_get_loc_interval(self, closed, side):
   94:         idx = IntervalIndex.from_tuples([(0, 1), (2, 3)], closed=closed)
   95: 
   96:         for bound in [[0, 1], [1, 2], [2, 3], [3, 4], [0, 2], [2.5, 3], [-1, 4]]:
   97:             # if get_loc is supplied an interval, it should only search
   98:             # for exact matches, not overlaps or covers, else KeyError.
   99:             msg = re.escape(f"Interval({bound[0]}, {bound[1]}, closed='{side}')")
  100:             if closed == side:
  101:                 if bound == [0, 1]:
  102:                     assert idx.get_loc(Interval(0, 1, closed=side)) == 0
  103:                 elif bound == [2, 3]:
  104:                     assert idx.get_loc(Interval(2, 3, closed=side)) == 1
  105:                 else:
  106:                     with pytest.raises(KeyError, match=msg):
  107:                         idx.get_loc(Interval(*bound, closed=side))
  108:             else:
  109:                 with pytest.raises(KeyError, match=msg):
  110:                     idx.get_loc(Interval(*bound, closed=side))
  111: 
  112:     @pytest.mark.parametrize("scalar", [-0.5, 0, 0.5, 1, 1.5, 2, 2.5, 3, 3.5])
  113:     def test_get_loc_scalar(self, closed, scalar):
  114:         # correct = {side: {query: answer}}.
  115:         # If query is not in the dict, that query should raise a KeyError
  116:         correct = {
  117:             "right": {0.5: 0, 1: 0, 2.5: 1, 3: 1},
  118:             "left": {0: 0, 0.5: 0, 2: 1, 2.5: 1},
  119:             "both": {0: 0, 0.5: 0, 1: 0, 2: 1, 2.5: 1, 3: 1},
  120:             "neither": {0.5: 0, 2.5: 1},
  121:         }
  122: 
  123:         idx = IntervalIndex.from_tuples([(0, 1), (2, 3)], closed=closed)
  124: 
  125:         # if get_loc is supplied a scalar, it should return the index of
  126:         # the interval which contains the scalar, or KeyError.
  127:         if scalar in correct[closed].keys():
  128:             assert idx.get_loc(scalar) == correct[closed][scalar]
  129:         else:
  130:             with pytest.raises(KeyError, match=str(scalar)):
  131:                 idx.get_loc(scalar)
  132: 
  133:     @pytest.mark.parametrize("scalar", [-1, 0, 0.5, 3, 4.5, 5, 6])
  134:     def test_get_loc_length_one_scalar(self, scalar, closed):
  135:         # GH 20921
  136:         index = IntervalIndex.from_tuples([(0, 5)], closed=closed)
  137:         if scalar in index[0]:
  138:             result = index.get_loc(scalar)
  139:             assert result == 0
  140:         else:
  141:             with pytest.raises(KeyError, match=str(scalar)):
  142:                 index.get_loc(scalar)
  143: 
  144:     @pytest.mark.parametrize("other_closed", ["left", "right", "both", "neither"])
  145:     @pytest.mark.parametrize("left, right", [(0, 5), (-1, 4), (-1, 6), (6, 7)])
  146:     def test_get_loc_length_one_interval(self, left, right, closed, other_closed):
  147:         # GH 20921
  148:         index = IntervalIndex.from_tuples([(0, 5)], closed=closed)
  149:         interval = Interval(left, right, closed=other_closed)
  150:         if interval == index[0]:
  151:             result = index.get_loc(interval)
  152:             assert result == 0
  153:         else:
  154:             with pytest.raises(
  155:                 KeyError,
  156:                 match=re.escape(f"Interval({left}, {right}, closed='{other_closed}')"),
  157:             ):
  158:                 index.get_loc(interval)
  159: 
  160:     # Make consistent with test_interval_new.py (see #16316, #16386)
  161:     @pytest.mark.parametrize(
  162:         "breaks",
  163:         [
  164:             date_range("20180101", periods=4),
  165:             date_range("20180101", periods=4, tz="US/Eastern"),
  166:             timedelta_range("0 days", periods=4),
  167:         ],
  168:         ids=lambda x: str(x.dtype),
  169:     )
  170:     def test_get_loc_datetimelike_nonoverlapping(self, breaks):
  171:         # GH 20636
  172:         # nonoverlapping = IntervalIndex method and no i8 conversion
  173:         index = IntervalIndex.from_breaks(breaks)
  174: 
  175:         value = index[0].mid
  176:         result = index.get_loc(value)
  177:         expected = 0
  178:         assert result == expected
  179: 
  180:         interval = Interval(index[0].left, index[0].right)
  181:         result = index.get_loc(interval)
  182:         expected = 0
  183:         assert result == expected
  184: 
  185:     @pytest.mark.parametrize(
  186:         "arrays",
  187:         [
  188:             (date_range("20180101", periods=4), date_range("20180103", periods=4)),
  189:             (
  190:                 date_range("20180101", periods=4, tz="US/Eastern"),
  191:                 date_range("20180103", periods=4, tz="US/Eastern"),
  192:             ),
  193:             (
  194:                 timedelta_range("0 days", periods=4),
  195:                 timedelta_range("2 days", periods=4),
  196:             ),
  197:         ],
  198:         ids=lambda x: str(x[0].dtype),
  199:     )
  200:     def test_get_loc_datetimelike_overlapping(self, arrays):
  201:         # GH 20636
  202:         index = IntervalIndex.from_arrays(*arrays)
  203: 
  204:         value = index[0].mid + Timedelta("12 hours")
  205:         result = index.get_loc(value)
  206:         expected = slice(0, 2, None)
  207:         assert result == expected
  208: 
  209:         interval = Interval(index[0].left, index[0].right)
  210:         result = index.get_loc(interval)
  211:         expected = 0
  212:         assert result == expected
  213: 
  214:     @pytest.mark.parametrize(
  215:         "values",
  216:         [
  217:             date_range("2018-01-04", periods=4, freq="-1D"),
  218:             date_range("2018-01-04", periods=4, freq="-1D", tz="US/Eastern"),
  219:             timedelta_range("3 days", periods=4, freq="-1D"),
  220:             np.arange(3.0, -1.0, -1.0),
  221:             np.arange(3, -1, -1),
  222:         ],
  223:         ids=lambda x: str(x.dtype),
  224:     )
  225:     def test_get_loc_decreasing(self, values):
  226:         # GH 25860
  227:         index = IntervalIndex.from_arrays(values[1:], values[:-1])
  228:         result = index.get_loc(index[0])
  229:         expected = 0
  230:         assert result == expected
  231: 
  232:     @pytest.mark.parametrize("key", [[5], (2, 3)])
  233:     def test_get_loc_non_scalar_errors(self, key):
  234:         # GH 31117
  235:         idx = IntervalIndex.from_tuples([(1, 3), (2, 4), (3, 5), (7, 10), (3, 10)])
  236: 
  237:         msg = str(key)
  238:         with pytest.raises(InvalidIndexError, match=msg):
  239:             idx.get_loc(key)
  240: 
  241:     def test_get_indexer_with_nans(self):
  242:         # GH#41831
  243:         index = IntervalIndex([np.nan, Interval(1, 2), np.nan])
  244: 
  245:         expected = np.array([True, False, True])
  246:         for key in [None, np.nan, NA]:
  247:             assert key in index
  248:             result = index.get_loc(key)
  249:             tm.assert_numpy_array_equal(result, expected)
  250: 
  251:         for key in [NaT, np.timedelta64("NaT", "ns"), np.datetime64("NaT", "ns")]:
  252:             with pytest.raises(KeyError, match=str(key)):
  253:                 index.get_loc(key)
  254: 
  255: 
  256: class TestGetIndexer:
  257:     @pytest.mark.parametrize(
  258:         "query, expected",
  259:         [
  260:             ([Interval(2, 4, closed="right")], [1]),
  261:             ([Interval(2, 4, closed="left")], [-1]),
  262:             ([Interval(2, 4, closed="both")], [-1]),
  263:             ([Interval(2, 4, closed="neither")], [-1]),
  264:             ([Interval(1, 4, closed="right")], [-1]),
  265:             ([Interval(0, 4, closed="right")], [-1]),
  266:             ([Interval(0.5, 1.5, closed="right")], [-1]),
  267:             ([Interval(2, 4, closed="right"), Interval(0, 1, closed="right")], [1, -1]),
  268:             ([Interval(2, 4, closed="right"), Interval(2, 4, closed="right")], [1, 1]),
  269:             ([Interval(5, 7, closed="right"), Interval(2, 4, closed="right")], [2, 1]),
  270:             ([Interval(2, 4, closed="right"), Interval(2, 4, closed="left")], [1, -1]),
  271:         ],
  272:     )
  273:     def test_get_indexer_with_interval(self, query, expected):
  274:         tuples = [(0, 2), (2, 4), (5, 7)]
  275:         index = IntervalIndex.from_tuples(tuples, closed="right")
  276: 
  277:         result = index.get_indexer(query)
  278:         expected = np.array(expected, dtype="intp")
  279:         tm.assert_numpy_array_equal(result, expected)
  280: 
  281:     @pytest.mark.parametrize(
  282:         "query, expected",
  283:         [
  284:             ([-0.5], [-1]),
  285:             ([0], [-1]),
  286:             ([0.5], [0]),
  287:             ([1], [0]),
  288:             ([1.5], [1]),
  289:             ([2], [1]),
  290:             ([2.5], [-1]),
  291:             ([3], [-1]),
  292:             ([3.5], [2]),
  293:             ([4], [2]),
  294:             ([4.5], [-1]),
  295:             ([1, 2], [0, 1]),
  296:             ([1, 2, 3], [0, 1, -1]),
  297:             ([1, 2, 3, 4], [0, 1, -1, 2]),
  298:             ([1, 2, 3, 4, 2], [0, 1, -1, 2, 1]),
  299:         ],
  300:     )
  301:     def test_get_indexer_with_int_and_float(self, query, expected):
  302:         tuples = [(0, 1), (1, 2), (3, 4)]
  303:         index = IntervalIndex.from_tuples(tuples, closed="right")
  304: 
  305:         result = index.get_indexer(query)
  306:         expected = np.array(expected, dtype="intp")
  307:         tm.assert_numpy_array_equal(result, expected)
  308: 
  309:     @pytest.mark.parametrize("item", [[3], np.arange(0.5, 5, 0.5)])
  310:     def test_get_indexer_length_one(self, item, closed):
  311:         # GH 17284
  312:         index = IntervalIndex.from_tuples([(0, 5)], closed=closed)
  313:         result = index.get_indexer(item)
  314:         expected = np.array([0] * len(item), dtype="intp")
  315:         tm.assert_numpy_array_equal(result, expected)
  316: 
  317:     @pytest.mark.parametrize("size", [1, 5])
  318:     def test_get_indexer_length_one_interval(self, size, closed):
  319:         # GH 17284
  320:         index = IntervalIndex.from_tuples([(0, 5)], closed=closed)
  321:         result = index.get_indexer([Interval(0, 5, closed)] * size)
  322:         expected = np.array([0] * size, dtype="intp")
  323:         tm.assert_numpy_array_equal(result, expected)
  324: 
  325:     @pytest.mark.parametrize(
  326:         "target",
  327:         [
  328:             IntervalIndex.from_tuples([(7, 8), (1, 2), (3, 4), (0, 1)]),
  329:             IntervalIndex.from_tuples([(0, 1), (1, 2), (3, 4), np.nan]),
  330:             IntervalIndex.from_tuples([(0, 1), (1, 2), (3, 4)], closed="both"),
  331:             [-1, 0, 0.5, 1, 2, 2.5, np.nan],
  332:             ["foo", "foo", "bar", "baz"],
  333:         ],
  334:     )
  335:     def test_get_indexer_categorical(self, target, ordered):
  336:         # GH 30063: categorical and non-categorical results should be consistent
  337:         index = IntervalIndex.from_tuples([(0, 1), (1, 2), (3, 4)])
  338:         categorical_target = CategoricalIndex(target, ordered=ordered)
  339: 
  340:         result = index.get_indexer(categorical_target)
  341:         expected = index.get_indexer(target)
  342:         tm.assert_numpy_array_equal(result, expected)
  343: 
  344:     def test_get_indexer_categorical_with_nans(self):
  345:         # GH#41934 nans in both index and in target
  346:         ii = IntervalIndex.from_breaks(range(5))
  347:         ii2 = ii.append(IntervalIndex([np.nan]))
  348:         ci2 = CategoricalIndex(ii2)
  349: 
  350:         result = ii2.get_indexer(ci2)
  351:         expected = np.arange(5, dtype=np.intp)
  352:         tm.assert_numpy_array_equal(result, expected)
  353: 
  354:         # not-all-matches
  355:         result = ii2[1:].get_indexer(ci2[::-1])
  356:         expected = np.array([3, 2, 1, 0, -1], dtype=np.intp)
  357:         tm.assert_numpy_array_equal(result, expected)
  358: 
  359:         # non-unique target, non-unique nans
  360:         result = ii2.get_indexer(ci2.append(ci2))
  361:         expected = np.array([0, 1, 2, 3, 4, 0, 1, 2, 3, 4], dtype=np.intp)
  362:         tm.assert_numpy_array_equal(result, expected)
  363: 
  364:     def test_get_indexer_datetime(self):
  365:         ii = IntervalIndex.from_breaks(date_range("2018-01-01", periods=4))
  366:         # TODO: with mismatched resolution get_indexer currently raises;
  367:         #  this should probably coerce?
  368:         target = DatetimeIndex(["2018-01-02"], dtype="M8[ns]")
  369:         result = ii.get_indexer(target)
  370:         expected = np.array([0], dtype=np.intp)
  371:         tm.assert_numpy_array_equal(result, expected)
  372: 
  373:         result = ii.get_indexer(target.astype(str))
  374:         tm.assert_numpy_array_equal(result, expected)
  375: 
  376:         # https://github.com/pandas-dev/pandas/issues/47772
  377:         result = ii.get_indexer(target.asi8)
  378:         expected = np.array([-1], dtype=np.intp)
  379:         tm.assert_numpy_array_equal(result, expected)
  380: 
  381:     @pytest.mark.parametrize(
  382:         "tuples, closed",
  383:         [
  384:             ([(0, 2), (1, 3), (3, 4)], "neither"),
  385:             ([(0, 5), (1, 4), (6, 7)], "left"),
  386:             ([(0, 1), (0, 1), (1, 2)], "right"),
  387:             ([(0, 1), (2, 3), (3, 4)], "both"),
  388:         ],
  389:     )
  390:     def test_get_indexer_errors(self, tuples, closed):
  391:         # IntervalIndex needs non-overlapping for uniqueness when querying
  392:         index = IntervalIndex.from_tuples(tuples, closed=closed)
  393: 
  394:         msg = (
  395:             "cannot handle overlapping indices; use "
  396:             "IntervalIndex.get_indexer_non_unique"
  397:         )
  398:         with pytest.raises(InvalidIndexError, match=msg):
  399:             index.get_indexer([0, 2])
  400: 
  401:     @pytest.mark.parametrize(
  402:         "query, expected",
  403:         [
  404:             ([-0.5], ([-1], [0])),
  405:             ([0], ([0], [])),
  406:             ([0.5], ([0], [])),
  407:             ([1], ([0, 1], [])),
  408:             ([1.5], ([0, 1], [])),
  409:             ([2], ([0, 1, 2], [])),
  410:             ([2.5], ([1, 2], [])),
  411:             ([3], ([2], [])),
  412:             ([3.5], ([2], [])),
  413:             ([4], ([-1], [0])),
  414:             ([4.5], ([-1], [0])),
  415:             ([1, 2], ([0, 1, 0, 1, 2], [])),
  416:             ([1, 2, 3], ([0, 1, 0, 1, 2, 2], [])),
  417:             ([1, 2, 3, 4], ([0, 1, 0, 1, 2, 2, -1], [3])),
  418:             ([1, 2, 3, 4, 2], ([0, 1, 0, 1, 2, 2, -1, 0, 1, 2], [3])),
  419:         ],
  420:     )
  421:     def test_get_indexer_non_unique_with_int_and_float(self, query, expected):
  422:         tuples = [(0, 2.5), (1, 3), (2, 4)]
  423:         index = IntervalIndex.from_tuples(tuples, closed="left")
  424: 
  425:         result_indexer, result_missing = index.get_indexer_non_unique(query)
  426:         expected_indexer = np.array(expected[0], dtype="intp")
  427:         expected_missing = np.array(expected[1], dtype="intp")
  428: 
  429:         tm.assert_numpy_array_equal(result_indexer, expected_indexer)
  430:         tm.assert_numpy_array_equal(result_missing, expected_missing)
  431: 
  432:         # TODO we may also want to test get_indexer for the case when
  433:         # the intervals are duplicated, decreasing, non-monotonic, etc..
  434: 
  435:     def test_get_indexer_non_monotonic(self):
  436:         # GH 16410
  437:         idx1 = IntervalIndex.from_tuples([(2, 3), (4, 5), (0, 1)])
  438:         idx2 = IntervalIndex.from_tuples([(0, 1), (2, 3), (6, 7), (8, 9)])
  439:         result = idx1.get_indexer(idx2)
  440:         expected = np.array([2, 0, -1, -1], dtype=np.intp)
  441:         tm.assert_numpy_array_equal(result, expected)
  442: 
  443:         result = idx1.get_indexer(idx1[1:])
  444:         expected = np.array([1, 2], dtype=np.intp)
  445:         tm.assert_numpy_array_equal(result, expected)
  446: 
  447:     def test_get_indexer_with_nans(self):
  448:         # GH#41831
  449:         index = IntervalIndex([np.nan, np.nan])
  450:         other = IntervalIndex([np.nan])
  451: 
  452:         assert not index._index_as_unique
  453: 
  454:         result = index.get_indexer_for(other)
  455:         expected = np.array([0, 1], dtype=np.intp)
  456:         tm.assert_numpy_array_equal(result, expected)
  457: 
  458:     def test_get_index_non_unique_non_monotonic(self):
  459:         # GH#44084 (root cause)
  460:         index = IntervalIndex.from_tuples(
  461:             [(0.0, 1.0), (1.0, 2.0), (0.0, 1.0), (1.0, 2.0)]
  462:         )
  463: 
  464:         result, _ = index.get_indexer_non_unique([Interval(1.0, 2.0)])
  465:         expected = np.array([1, 3], dtype=np.intp)
  466:         tm.assert_numpy_array_equal(result, expected)
  467: 
  468:     def test_get_indexer_multiindex_with_intervals(self):
  469:         # GH#44084 (MultiIndex case as reported)
  470:         interval_index = IntervalIndex.from_tuples(
  471:             [(2.0, 3.0), (0.0, 1.0), (1.0, 2.0)], name="interval"
  472:         )
  473:         foo_index = Index([1, 2, 3], name="foo")
  474: 
  475:         multi_index = MultiIndex.from_product([foo_index, interval_index])
  476: 
  477:         result = multi_index.get_level_values("interval").get_indexer_for(
  478:             [Interval(0.0, 1.0)]
  479:         )
  480:         expected = np.array([1, 4, 7], dtype=np.intp)
  481:         tm.assert_numpy_array_equal(result, expected)
  482: 
  483:     @pytest.mark.parametrize("box", [IntervalIndex, array, list])
  484:     def test_get_indexer_interval_index(self, box):
  485:         # GH#30178
  486:         rng = period_range("2022-07-01", freq="D", periods=3)
  487:         idx = box(interval_range(Timestamp("2022-07-01"), freq="3D", periods=3))
  488: 
  489:         actual = rng.get_indexer(idx)
  490:         expected = np.array([-1, -1, -1], dtype=np.intp)
  491:         tm.assert_numpy_array_equal(actual, expected)
  492: 
  493:     def test_get_indexer_read_only(self):
  494:         idx = interval_range(start=0, end=5)
  495:         arr = np.array([1, 2])
  496:         arr.flags.writeable = False
  497:         result = idx.get_indexer(arr)
  498:         expected = np.array([0, 1])
  499:         tm.assert_numpy_array_equal(result, expected, check_dtype=False)
  500: 
  501:         result = idx.get_indexer_non_unique(arr)[0]
  502:         tm.assert_numpy_array_equal(result, expected, check_dtype=False)
  503: 
  504: 
  505: class TestSliceLocs:
  506:     def test_slice_locs_with_interval(self):
  507:         # increasing monotonically
  508:         index = IntervalIndex.from_tuples([(0, 2), (1, 3), (2, 4)])
  509: 
  510:         assert index.slice_locs(start=Interval(0, 2), end=Interval(2, 4)) == (0, 3)
  511:         assert index.slice_locs(start=Interval(0, 2)) == (0, 3)
  512:         assert index.slice_locs(end=Interval(2, 4)) == (0, 3)
  513:         assert index.slice_locs(end=Interval(0, 2)) == (0, 1)
  514:         assert index.slice_locs(start=Interval(2, 4), end=Interval(0, 2)) == (2, 1)
  515: 
  516:         # decreasing monotonically
  517:         index = IntervalIndex.from_tuples([(2, 4), (1, 3), (0, 2)])
  518: 
  519:         assert index.slice_locs(start=Interval(0, 2), end=Interval(2, 4)) == (2, 1)
  520:         assert index.slice_locs(start=Interval(0, 2)) == (2, 3)
  521:         assert index.slice_locs(end=Interval(2, 4)) == (0, 1)
  522:         assert index.slice_locs(end=Interval(0, 2)) == (0, 3)
  523:         assert index.slice_locs(start=Interval(2, 4), end=Interval(0, 2)) == (0, 3)
  524: 
  525:         # sorted duplicates
  526:         index = IntervalIndex.from_tuples([(0, 2), (0, 2), (2, 4)])
  527: 
  528:         assert index.slice_locs(start=Interval(0, 2), end=Interval(2, 4)) == (0, 3)
  529:         assert index.slice_locs(start=Interval(0, 2)) == (0, 3)
  530:         assert index.slice_locs(end=Interval(2, 4)) == (0, 3)
  531:         assert index.slice_locs(end=Interval(0, 2)) == (0, 2)
  532:         assert index.slice_locs(start=Interval(2, 4), end=Interval(0, 2)) == (2, 2)
  533: 
  534:         # unsorted duplicates
  535:         index = IntervalIndex.from_tuples([(0, 2), (2, 4), (0, 2)])
  536: 
  537:         with pytest.raises(
  538:             KeyError,
  539:             match=re.escape(
  540:                 '"Cannot get left slice bound for non-unique label: '
  541:                 "Interval(0, 2, closed='right')\""
  542:             ),
  543:         ):
  544:             index.slice_locs(start=Interval(0, 2), end=Interval(2, 4))
  545: 
  546:         with pytest.raises(
  547:             KeyError,
  548:             match=re.escape(
  549:                 '"Cannot get left slice bound for non-unique label: '
  550:                 "Interval(0, 2, closed='right')\""
  551:             ),
  552:         ):
  553:             index.slice_locs(start=Interval(0, 2))
  554: 
  555:         assert index.slice_locs(end=Interval(2, 4)) == (0, 2)
  556: 
  557:         with pytest.raises(
  558:             KeyError,
  559:             match=re.escape(
  560:                 '"Cannot get right slice bound for non-unique label: '
  561:                 "Interval(0, 2, closed='right')\""
  562:             ),
  563:         ):
  564:             index.slice_locs(end=Interval(0, 2))
  565: 
  566:         with pytest.raises(
  567:             KeyError,
  568:             match=re.escape(
  569:                 '"Cannot get right slice bound for non-unique label: '
  570:                 "Interval(0, 2, closed='right')\""
  571:             ),
  572:         ):
  573:             index.slice_locs(start=Interval(2, 4), end=Interval(0, 2))
  574: 
  575:         # another unsorted duplicates
  576:         index = IntervalIndex.from_tuples([(0, 2), (0, 2), (2, 4), (1, 3)])
  577: 
  578:         assert index.slice_locs(start=Interval(0, 2), end=Interval(2, 4)) == (0, 3)
  579:         assert index.slice_locs(start=Interval(0, 2)) == (0, 4)
  580:         assert index.slice_locs(end=Interval(2, 4)) == (0, 3)
  581:         assert index.slice_locs(end=Interval(0, 2)) == (0, 2)
  582:         assert index.slice_locs(start=Interval(2, 4), end=Interval(0, 2)) == (2, 2)
  583: 
  584:     def test_slice_locs_with_ints_and_floats_succeeds(self):
  585:         # increasing non-overlapping
  586:         index = IntervalIndex.from_tuples([(0, 1), (1, 2), (3, 4)])
  587: 
  588:         assert index.slice_locs(0, 1) == (0, 1)
  589:         assert index.slice_locs(0, 2) == (0, 2)
  590:         assert index.slice_locs(0, 3) == (0, 2)
  591:         assert index.slice_locs(3, 1) == (2, 1)
  592:         assert index.slice_locs(3, 4) == (2, 3)
  593:         assert index.slice_locs(0, 4) == (0, 3)
  594: 
  595:         # decreasing non-overlapping
  596:         index = IntervalIndex.from_tuples([(3, 4), (1, 2), (0, 1)])
  597:         assert index.slice_locs(0, 1) == (3, 3)
  598:         assert index.slice_locs(0, 2) == (3, 2)
  599:         assert index.slice_locs(0, 3) == (3, 1)
  600:         assert index.slice_locs(3, 1) == (1, 3)
  601:         assert index.slice_locs(3, 4) == (1, 1)
  602:         assert index.slice_locs(0, 4) == (3, 1)
  603: 
  604:     @pytest.mark.parametrize("query", [[0, 1], [0, 2], [0, 3], [0, 4]])
  605:     @pytest.mark.parametrize(
  606:         "tuples",
  607:         [
  608:             [(0, 2), (1, 3), (2, 4)],
  609:             [(2, 4), (1, 3), (0, 2)],
  610:             [(0, 2), (0, 2), (2, 4)],
  611:             [(0, 2), (2, 4), (0, 2)],
  612:             [(0, 2), (0, 2), (2, 4), (1, 3)],
  613:         ],
  614:     )
  615:     def test_slice_locs_with_ints_and_floats_errors(self, tuples, query):
  616:         start, stop = query
  617:         index = IntervalIndex.from_tuples(tuples)
  618:         with pytest.raises(
  619:             KeyError,
  620:             match=(
  621:                 "'can only get slices from an IntervalIndex if bounds are "
  622:                 "non-overlapping and all monotonic increasing or decreasing'"
  623:             ),
  624:         ):
  625:             index.slice_locs(start, stop)
  626: 
  627: 
  628: class TestPutmask:
  629:     @pytest.mark.parametrize("tz", ["US/Pacific", None])
  630:     def test_putmask_dt64(self, tz):
  631:         # GH#37968
  632:         dti = date_range("2016-01-01", periods=9, tz=tz)
  633:         idx = IntervalIndex.from_breaks(dti)
  634:         mask = np.zeros(idx.shape, dtype=bool)
  635:         mask[0:3] = True
  636: 
  637:         result = idx.putmask(mask, idx[-1])
  638:         expected = IntervalIndex([idx[-1]] * 3 + list(idx[3:]))
  639:         tm.assert_index_equal(result, expected)
  640: 
  641:     def test_putmask_td64(self):
  642:         # GH#37968
  643:         dti = date_range("2016-01-01", periods=9)
  644:         tdi = dti - dti[0]
  645:         idx = IntervalIndex.from_breaks(tdi)
  646:         mask = np.zeros(idx.shape, dtype=bool)
  647:         mask[0:3] = True
  648: 
  649:         result = idx.putmask(mask, idx[-1])
  650:         expected = IntervalIndex([idx[-1]] * 3 + list(idx[3:]))
  651:         tm.assert_index_equal(result, expected)
  652: 
  653: 
  654: class TestContains:
  655:     # .__contains__, not .contains
  656: 
  657:     def test_contains_dunder(self):
  658:         index = IntervalIndex.from_arrays([0, 1], [1, 2], closed="right")
  659: 
  660:         # __contains__ requires perfect matches to intervals.
  661:         assert 0 not in index
  662:         assert 1 not in index
  663:         assert 2 not in index
  664: 
  665:         assert Interval(0, 1, closed="right") in index
  666:         assert Interval(0, 2, closed="right") not in index
  667:         assert Interval(0, 0.5, closed="right") not in index
  668:         assert Interval(3, 5, closed="right") not in index
  669:         assert Interval(-1, 0, closed="left") not in index
  670:         assert Interval(0, 1, closed="left") not in index
  671:         assert Interval(0, 1, closed="both") not in index
