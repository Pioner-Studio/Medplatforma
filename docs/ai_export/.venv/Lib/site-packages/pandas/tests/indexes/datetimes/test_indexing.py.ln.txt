    1: from datetime import (
    2:     date,
    3:     datetime,
    4:     time,
    5:     timedelta,
    6: )
    7: 
    8: import numpy as np
    9: import pytest
   10: 
   11: from pandas._libs import index as libindex
   12: from pandas.compat.numpy import np_long
   13: 
   14: import pandas as pd
   15: from pandas import (
   16:     DatetimeIndex,
   17:     Index,
   18:     Timestamp,
   19:     bdate_range,
   20:     date_range,
   21:     notna,
   22: )
   23: import pandas._testing as tm
   24: 
   25: from pandas.tseries.frequencies import to_offset
   26: 
   27: START, END = datetime(2009, 1, 1), datetime(2010, 1, 1)
   28: 
   29: 
   30: class TestGetItem:
   31:     def test_getitem_slice_keeps_name(self):
   32:         # GH4226
   33:         st = Timestamp("2013-07-01 00:00:00", tz="America/Los_Angeles")
   34:         et = Timestamp("2013-07-02 00:00:00", tz="America/Los_Angeles")
   35:         dr = date_range(st, et, freq="h", name="timebucket")
   36:         assert dr[1:].name == dr.name
   37: 
   38:     @pytest.mark.parametrize("tz", [None, "Asia/Tokyo"])
   39:     def test_getitem(self, tz):
   40:         idx = date_range("2011-01-01", "2011-01-31", freq="D", tz=tz, name="idx")
   41: 
   42:         result = idx[0]
   43:         assert result == Timestamp("2011-01-01", tz=idx.tz)
   44: 
   45:         result = idx[0:5]
   46:         expected = date_range(
   47:             "2011-01-01", "2011-01-05", freq="D", tz=idx.tz, name="idx"
   48:         )
   49:         tm.assert_index_equal(result, expected)
   50:         assert result.freq == expected.freq
   51: 
   52:         result = idx[0:10:2]
   53:         expected = date_range(
   54:             "2011-01-01", "2011-01-09", freq="2D", tz=idx.tz, name="idx"
   55:         )
   56:         tm.assert_index_equal(result, expected)
   57:         assert result.freq == expected.freq
   58: 
   59:         result = idx[-20:-5:3]
   60:         expected = date_range(
   61:             "2011-01-12", "2011-01-24", freq="3D", tz=idx.tz, name="idx"
   62:         )
   63:         tm.assert_index_equal(result, expected)
   64:         assert result.freq == expected.freq
   65: 
   66:         result = idx[4::-1]
   67:         expected = DatetimeIndex(
   68:             ["2011-01-05", "2011-01-04", "2011-01-03", "2011-01-02", "2011-01-01"],
   69:             dtype=idx.dtype,
   70:             freq="-1D",
   71:             name="idx",
   72:         )
   73:         tm.assert_index_equal(result, expected)
   74:         assert result.freq == expected.freq
   75: 
   76:     @pytest.mark.parametrize("freq", ["B", "C"])
   77:     def test_dti_business_getitem(self, freq):
   78:         rng = bdate_range(START, END, freq=freq)
   79:         smaller = rng[:5]
   80:         exp = DatetimeIndex(rng.view(np.ndarray)[:5], freq=freq)
   81:         tm.assert_index_equal(smaller, exp)
   82:         assert smaller.freq == exp.freq
   83:         assert smaller.freq == rng.freq
   84: 
   85:         sliced = rng[::5]
   86:         assert sliced.freq == to_offset(freq) * 5
   87: 
   88:         fancy_indexed = rng[[4, 3, 2, 1, 0]]
   89:         assert len(fancy_indexed) == 5
   90:         assert isinstance(fancy_indexed, DatetimeIndex)
   91:         assert fancy_indexed.freq is None
   92: 
   93:         # 32-bit vs. 64-bit platforms
   94:         assert rng[4] == rng[np_long(4)]
   95: 
   96:     @pytest.mark.parametrize("freq", ["B", "C"])
   97:     def test_dti_business_getitem_matplotlib_hackaround(self, freq):
   98:         rng = bdate_range(START, END, freq=freq)
   99:         with pytest.raises(ValueError, match="Multi-dimensional indexing"):
  100:             # GH#30588 multi-dimensional indexing deprecated
  101:             rng[:, None]
  102: 
  103:     def test_getitem_int_list(self):
  104:         dti = date_range(start="1/1/2005", end="12/1/2005", freq="ME")
  105:         dti2 = dti[[1, 3, 5]]
  106: 
  107:         v1 = dti2[0]
  108:         v2 = dti2[1]
  109:         v3 = dti2[2]
  110: 
  111:         assert v1 == Timestamp("2/28/2005")
  112:         assert v2 == Timestamp("4/30/2005")
  113:         assert v3 == Timestamp("6/30/2005")
  114: 
  115:         # getitem with non-slice drops freq
  116:         assert dti2.freq is None
  117: 
  118: 
  119: class TestWhere:
  120:     def test_where_doesnt_retain_freq(self):
  121:         dti = date_range("20130101", periods=3, freq="D", name="idx")
  122:         cond = [True, True, False]
  123:         expected = DatetimeIndex([dti[0], dti[1], dti[0]], freq=None, name="idx")
  124: 
  125:         result = dti.where(cond, dti[::-1])
  126:         tm.assert_index_equal(result, expected)
  127: 
  128:     def test_where_other(self):
  129:         # other is ndarray or Index
  130:         i = date_range("20130101", periods=3, tz="US/Eastern")
  131: 
  132:         for arr in [np.nan, pd.NaT]:
  133:             result = i.where(notna(i), other=arr)
  134:             expected = i
  135:             tm.assert_index_equal(result, expected)
  136: 
  137:         i2 = i.copy()
  138:         i2 = Index([pd.NaT, pd.NaT] + i[2:].tolist())
  139:         result = i.where(notna(i2), i2)
  140:         tm.assert_index_equal(result, i2)
  141: 
  142:         i2 = i.copy()
  143:         i2 = Index([pd.NaT, pd.NaT] + i[2:].tolist())
  144:         result = i.where(notna(i2), i2._values)
  145:         tm.assert_index_equal(result, i2)
  146: 
  147:     def test_where_invalid_dtypes(self):
  148:         dti = date_range("20130101", periods=3, tz="US/Eastern")
  149: 
  150:         tail = dti[2:].tolist()
  151:         i2 = Index([pd.NaT, pd.NaT] + tail)
  152: 
  153:         mask = notna(i2)
  154: 
  155:         # passing tz-naive ndarray to tzaware DTI
  156:         result = dti.where(mask, i2.values)
  157:         expected = Index([pd.NaT.asm8, pd.NaT.asm8] + tail, dtype=object)
  158:         tm.assert_index_equal(result, expected)
  159: 
  160:         # passing tz-aware DTI to tznaive DTI
  161:         naive = dti.tz_localize(None)
  162:         result = naive.where(mask, i2)
  163:         expected = Index([i2[0], i2[1]] + naive[2:].tolist(), dtype=object)
  164:         tm.assert_index_equal(result, expected)
  165: 
  166:         pi = i2.tz_localize(None).to_period("D")
  167:         result = dti.where(mask, pi)
  168:         expected = Index([pi[0], pi[1]] + tail, dtype=object)
  169:         tm.assert_index_equal(result, expected)
  170: 
  171:         tda = i2.asi8.view("timedelta64[ns]")
  172:         result = dti.where(mask, tda)
  173:         expected = Index([tda[0], tda[1]] + tail, dtype=object)
  174:         assert isinstance(expected[0], np.timedelta64)
  175:         tm.assert_index_equal(result, expected)
  176: 
  177:         result = dti.where(mask, i2.asi8)
  178:         expected = Index([pd.NaT._value, pd.NaT._value] + tail, dtype=object)
  179:         assert isinstance(expected[0], int)
  180:         tm.assert_index_equal(result, expected)
  181: 
  182:         # non-matching scalar
  183:         td = pd.Timedelta(days=4)
  184:         result = dti.where(mask, td)
  185:         expected = Index([td, td] + tail, dtype=object)
  186:         assert expected[0] is td
  187:         tm.assert_index_equal(result, expected)
  188: 
  189:     def test_where_mismatched_nat(self, tz_aware_fixture):
  190:         tz = tz_aware_fixture
  191:         dti = date_range("2013-01-01", periods=3, tz=tz)
  192:         cond = np.array([True, False, True])
  193: 
  194:         tdnat = np.timedelta64("NaT", "ns")
  195:         expected = Index([dti[0], tdnat, dti[2]], dtype=object)
  196:         assert expected[1] is tdnat
  197: 
  198:         result = dti.where(cond, tdnat)
  199:         tm.assert_index_equal(result, expected)
  200: 
  201:     def test_where_tz(self):
  202:         i = date_range("20130101", periods=3, tz="US/Eastern")
  203:         result = i.where(notna(i))
  204:         expected = i
  205:         tm.assert_index_equal(result, expected)
  206: 
  207:         i2 = i.copy()
  208:         i2 = Index([pd.NaT, pd.NaT] + i[2:].tolist())
  209:         result = i.where(notna(i2))
  210:         expected = i2
  211:         tm.assert_index_equal(result, expected)
  212: 
  213: 
  214: class TestTake:
  215:     @pytest.mark.parametrize("tzstr", ["US/Eastern", "dateutil/US/Eastern"])
  216:     def test_dti_take_dont_lose_meta(self, tzstr):
  217:         rng = date_range("1/1/2000", periods=20, tz=tzstr)
  218: 
  219:         result = rng.take(range(5))
  220:         assert result.tz == rng.tz
  221:         assert result.freq == rng.freq
  222: 
  223:     def test_take_nan_first_datetime(self):
  224:         index = DatetimeIndex([pd.NaT, Timestamp("20130101"), Timestamp("20130102")])
  225:         result = index.take([-1, 0, 1])
  226:         expected = DatetimeIndex([index[-1], index[0], index[1]])
  227:         tm.assert_index_equal(result, expected)
  228: 
  229:     @pytest.mark.parametrize("tz", [None, "Asia/Tokyo"])
  230:     def test_take(self, tz):
  231:         # GH#10295
  232:         idx = date_range("2011-01-01", "2011-01-31", freq="D", name="idx", tz=tz)
  233: 
  234:         result = idx.take([0])
  235:         assert result == Timestamp("2011-01-01", tz=idx.tz)
  236: 
  237:         result = idx.take([0, 1, 2])
  238:         expected = date_range(
  239:             "2011-01-01", "2011-01-03", freq="D", tz=idx.tz, name="idx"
  240:         )
  241:         tm.assert_index_equal(result, expected)
  242:         assert result.freq == expected.freq
  243: 
  244:         result = idx.take([0, 2, 4])
  245:         expected = date_range(
  246:             "2011-01-01", "2011-01-05", freq="2D", tz=idx.tz, name="idx"
  247:         )
  248:         tm.assert_index_equal(result, expected)
  249:         assert result.freq == expected.freq
  250: 
  251:         result = idx.take([7, 4, 1])
  252:         expected = date_range(
  253:             "2011-01-08", "2011-01-02", freq="-3D", tz=idx.tz, name="idx"
  254:         )
  255:         tm.assert_index_equal(result, expected)
  256:         assert result.freq == expected.freq
  257: 
  258:         result = idx.take([3, 2, 5])
  259:         expected = DatetimeIndex(
  260:             ["2011-01-04", "2011-01-03", "2011-01-06"],
  261:             dtype=idx.dtype,
  262:             freq=None,
  263:             name="idx",
  264:         )
  265:         tm.assert_index_equal(result, expected)
  266:         assert result.freq is None
  267: 
  268:         result = idx.take([-3, 2, 5])
  269:         expected = DatetimeIndex(
  270:             ["2011-01-29", "2011-01-03", "2011-01-06"],
  271:             dtype=idx.dtype,
  272:             freq=None,
  273:             name="idx",
  274:         )
  275:         tm.assert_index_equal(result, expected)
  276:         assert result.freq is None
  277: 
  278:     def test_take_invalid_kwargs(self):
  279:         idx = date_range("2011-01-01", "2011-01-31", freq="D", name="idx")
  280:         indices = [1, 6, 5, 9, 10, 13, 15, 3]
  281: 
  282:         msg = r"take\(\) got an unexpected keyword argument 'foo'"
  283:         with pytest.raises(TypeError, match=msg):
  284:             idx.take(indices, foo=2)
  285: 
  286:         msg = "the 'out' parameter is not supported"
  287:         with pytest.raises(ValueError, match=msg):
  288:             idx.take(indices, out=indices)
  289: 
  290:         msg = "the 'mode' parameter is not supported"
  291:         with pytest.raises(ValueError, match=msg):
  292:             idx.take(indices, mode="clip")
  293: 
  294:     # TODO: This method came from test_datetime; de-dup with version above
  295:     @pytest.mark.parametrize("tz", [None, "US/Eastern", "Asia/Tokyo"])
  296:     def test_take2(self, tz):
  297:         dates = [
  298:             datetime(2010, 1, 1, 14),
  299:             datetime(2010, 1, 1, 15),
  300:             datetime(2010, 1, 1, 17),
  301:             datetime(2010, 1, 1, 21),
  302:         ]
  303: 
  304:         idx = date_range(
  305:             start="2010-01-01 09:00",
  306:             end="2010-02-01 09:00",
  307:             freq="h",
  308:             tz=tz,
  309:             name="idx",
  310:         )
  311:         expected = DatetimeIndex(dates, freq=None, name="idx", dtype=idx.dtype)
  312: 
  313:         taken1 = idx.take([5, 6, 8, 12])
  314:         taken2 = idx[[5, 6, 8, 12]]
  315: 
  316:         for taken in [taken1, taken2]:
  317:             tm.assert_index_equal(taken, expected)
  318:             assert isinstance(taken, DatetimeIndex)
  319:             assert taken.freq is None
  320:             assert taken.tz == expected.tz
  321:             assert taken.name == expected.name
  322: 
  323:     def test_take_fill_value(self):
  324:         # GH#12631
  325:         idx = DatetimeIndex(["2011-01-01", "2011-02-01", "2011-03-01"], name="xxx")
  326:         result = idx.take(np.array([1, 0, -1]))
  327:         expected = DatetimeIndex(["2011-02-01", "2011-01-01", "2011-03-01"], name="xxx")
  328:         tm.assert_index_equal(result, expected)
  329: 
  330:         # fill_value
  331:         result = idx.take(np.array([1, 0, -1]), fill_value=True)
  332:         expected = DatetimeIndex(["2011-02-01", "2011-01-01", "NaT"], name="xxx")
  333:         tm.assert_index_equal(result, expected)
  334: 
  335:         # allow_fill=False
  336:         result = idx.take(np.array([1, 0, -1]), allow_fill=False, fill_value=True)
  337:         expected = DatetimeIndex(["2011-02-01", "2011-01-01", "2011-03-01"], name="xxx")
  338:         tm.assert_index_equal(result, expected)
  339: 
  340:         msg = (
  341:             "When allow_fill=True and fill_value is not None, "
  342:             "all indices must be >= -1"
  343:         )
  344:         with pytest.raises(ValueError, match=msg):
  345:             idx.take(np.array([1, 0, -2]), fill_value=True)
  346:         with pytest.raises(ValueError, match=msg):
  347:             idx.take(np.array([1, 0, -5]), fill_value=True)
  348: 
  349:         msg = "out of bounds"
  350:         with pytest.raises(IndexError, match=msg):
  351:             idx.take(np.array([1, -5]))
  352: 
  353:     def test_take_fill_value_with_timezone(self):
  354:         idx = DatetimeIndex(
  355:             ["2011-01-01", "2011-02-01", "2011-03-01"], name="xxx", tz="US/Eastern"
  356:         )
  357:         result = idx.take(np.array([1, 0, -1]))
  358:         expected = DatetimeIndex(
  359:             ["2011-02-01", "2011-01-01", "2011-03-01"], name="xxx", tz="US/Eastern"
  360:         )
  361:         tm.assert_index_equal(result, expected)
  362: 
  363:         # fill_value
  364:         result = idx.take(np.array([1, 0, -1]), fill_value=True)
  365:         expected = DatetimeIndex(
  366:             ["2011-02-01", "2011-01-01", "NaT"], name="xxx", tz="US/Eastern"
  367:         )
  368:         tm.assert_index_equal(result, expected)
  369: 
  370:         # allow_fill=False
  371:         result = idx.take(np.array([1, 0, -1]), allow_fill=False, fill_value=True)
  372:         expected = DatetimeIndex(
  373:             ["2011-02-01", "2011-01-01", "2011-03-01"], name="xxx", tz="US/Eastern"
  374:         )
  375:         tm.assert_index_equal(result, expected)
  376: 
  377:         msg = (
  378:             "When allow_fill=True and fill_value is not None, "
  379:             "all indices must be >= -1"
  380:         )
  381:         with pytest.raises(ValueError, match=msg):
  382:             idx.take(np.array([1, 0, -2]), fill_value=True)
  383:         with pytest.raises(ValueError, match=msg):
  384:             idx.take(np.array([1, 0, -5]), fill_value=True)
  385: 
  386:         msg = "out of bounds"
  387:         with pytest.raises(IndexError, match=msg):
  388:             idx.take(np.array([1, -5]))
  389: 
  390: 
  391: class TestGetLoc:
  392:     def test_get_loc_key_unit_mismatch(self):
  393:         idx = date_range("2000-01-01", periods=3)
  394:         key = idx[1].as_unit("ms")
  395:         loc = idx.get_loc(key)
  396:         assert loc == 1
  397:         assert key in idx
  398: 
  399:     def test_get_loc_key_unit_mismatch_not_castable(self):
  400:         dta = date_range("2000-01-01", periods=3)._data.astype("M8[s]")
  401:         dti = DatetimeIndex(dta)
  402:         key = dta[0].as_unit("ns") + pd.Timedelta(1)
  403: 
  404:         with pytest.raises(
  405:             KeyError, match=r"Timestamp\('2000-01-01 00:00:00.000000001'\)"
  406:         ):
  407:             dti.get_loc(key)
  408: 
  409:         assert key not in dti
  410: 
  411:     def test_get_loc_time_obj(self):
  412:         # time indexing
  413:         idx = date_range("2000-01-01", periods=24, freq="h")
  414: 
  415:         result = idx.get_loc(time(12))
  416:         expected = np.array([12])
  417:         tm.assert_numpy_array_equal(result, expected, check_dtype=False)
  418: 
  419:         result = idx.get_loc(time(12, 30))
  420:         expected = np.array([])
  421:         tm.assert_numpy_array_equal(result, expected, check_dtype=False)
  422: 
  423:     @pytest.mark.parametrize("offset", [-10, 10])
  424:     def test_get_loc_time_obj2(self, monkeypatch, offset):
  425:         # GH#8667
  426:         size_cutoff = 50
  427:         n = size_cutoff + offset
  428:         key = time(15, 11, 30)
  429:         start = key.hour * 3600 + key.minute * 60 + key.second
  430:         step = 24 * 3600
  431: 
  432:         with monkeypatch.context():
  433:             monkeypatch.setattr(libindex, "_SIZE_CUTOFF", size_cutoff)
  434:             idx = date_range("2014-11-26", periods=n, freq="s")
  435:             ts = pd.Series(np.random.default_rng(2).standard_normal(n), index=idx)
  436:             locs = np.arange(start, n, step, dtype=np.intp)
  437: 
  438:             result = ts.index.get_loc(key)
  439:             tm.assert_numpy_array_equal(result, locs)
  440:             tm.assert_series_equal(ts[key], ts.iloc[locs])
  441: 
  442:             left, right = ts.copy(), ts.copy()
  443:             left[key] *= -10
  444:             right.iloc[locs] *= -10
  445:             tm.assert_series_equal(left, right)
  446: 
  447:     def test_get_loc_time_nat(self):
  448:         # GH#35114
  449:         # Case where key's total microseconds happens to match iNaT % 1e6 // 1000
  450:         tic = time(minute=12, second=43, microsecond=145224)
  451:         dti = DatetimeIndex([pd.NaT])
  452: 
  453:         loc = dti.get_loc(tic)
  454:         expected = np.array([], dtype=np.intp)
  455:         tm.assert_numpy_array_equal(loc, expected)
  456: 
  457:     def test_get_loc_nat(self):
  458:         # GH#20464
  459:         index = DatetimeIndex(["1/3/2000", "NaT"])
  460:         assert index.get_loc(pd.NaT) == 1
  461: 
  462:         assert index.get_loc(None) == 1
  463: 
  464:         assert index.get_loc(np.nan) == 1
  465: 
  466:         assert index.get_loc(pd.NA) == 1
  467: 
  468:         assert index.get_loc(np.datetime64("NaT")) == 1
  469: 
  470:         with pytest.raises(KeyError, match="NaT"):
  471:             index.get_loc(np.timedelta64("NaT"))
  472: 
  473:     @pytest.mark.parametrize("key", [pd.Timedelta(0), pd.Timedelta(1), timedelta(0)])
  474:     def test_get_loc_timedelta_invalid_key(self, key):
  475:         # GH#20464
  476:         dti = date_range("1970-01-01", periods=10)
  477:         msg = "Cannot index DatetimeIndex with [Tt]imedelta"
  478:         with pytest.raises(TypeError, match=msg):
  479:             dti.get_loc(key)
  480: 
  481:     def test_get_loc_reasonable_key_error(self):
  482:         # GH#1062
  483:         index = DatetimeIndex(["1/3/2000"])
  484:         with pytest.raises(KeyError, match="2000"):
  485:             index.get_loc("1/1/2000")
  486: 
  487:     def test_get_loc_year_str(self):
  488:         rng = date_range("1/1/2000", "1/1/2010")
  489: 
  490:         result = rng.get_loc("2009")
  491:         expected = slice(3288, 3653)
  492:         assert result == expected
  493: 
  494: 
  495: class TestContains:
  496:     def test_dti_contains_with_duplicates(self):
  497:         d = datetime(2011, 12, 5, 20, 30)
  498:         ix = DatetimeIndex([d, d])
  499:         assert d in ix
  500: 
  501:     @pytest.mark.parametrize(
  502:         "vals",
  503:         [
  504:             [0, 1, 0],
  505:             [0, 0, -1],
  506:             [0, -1, -1],
  507:             ["2015", "2015", "2016"],
  508:             ["2015", "2015", "2014"],
  509:         ],
  510:     )
  511:     def test_contains_nonunique(self, vals):
  512:         # GH#9512
  513:         idx = DatetimeIndex(vals)
  514:         assert idx[0] in idx
  515: 
  516: 
  517: class TestGetIndexer:
  518:     def test_get_indexer_date_objs(self):
  519:         rng = date_range("1/1/2000", periods=20)
  520: 
  521:         result = rng.get_indexer(rng.map(lambda x: x.date()))
  522:         expected = rng.get_indexer(rng)
  523:         tm.assert_numpy_array_equal(result, expected)
  524: 
  525:     def test_get_indexer(self):
  526:         idx = date_range("2000-01-01", periods=3)
  527:         exp = np.array([0, 1, 2], dtype=np.intp)
  528:         tm.assert_numpy_array_equal(idx.get_indexer(idx), exp)
  529: 
  530:         target = idx[0] + pd.to_timedelta(["-1 hour", "12 hours", "1 day 1 hour"])
  531:         tm.assert_numpy_array_equal(
  532:             idx.get_indexer(target, "pad"), np.array([-1, 0, 1], dtype=np.intp)
  533:         )
  534:         tm.assert_numpy_array_equal(
  535:             idx.get_indexer(target, "backfill"), np.array([0, 1, 2], dtype=np.intp)
  536:         )
  537:         tm.assert_numpy_array_equal(
  538:             idx.get_indexer(target, "nearest"), np.array([0, 1, 1], dtype=np.intp)
  539:         )
  540:         tm.assert_numpy_array_equal(
  541:             idx.get_indexer(target, "nearest", tolerance=pd.Timedelta("1 hour")),
  542:             np.array([0, -1, 1], dtype=np.intp),
  543:         )
  544:         tol_raw = [
  545:             pd.Timedelta("1 hour"),
  546:             pd.Timedelta("1 hour"),
  547:             pd.Timedelta("1 hour").to_timedelta64(),
  548:         ]
  549:         tm.assert_numpy_array_equal(
  550:             idx.get_indexer(
  551:                 target, "nearest", tolerance=[np.timedelta64(x) for x in tol_raw]
  552:             ),
  553:             np.array([0, -1, 1], dtype=np.intp),
  554:         )
  555:         tol_bad = [
  556:             pd.Timedelta("2 hour").to_timedelta64(),
  557:             pd.Timedelta("1 hour").to_timedelta64(),
  558:             "foo",
  559:         ]
  560:         msg = "Could not convert 'foo' to NumPy timedelta"
  561:         with pytest.raises(ValueError, match=msg):
  562:             idx.get_indexer(target, "nearest", tolerance=tol_bad)
  563:         with pytest.raises(ValueError, match="abbreviation w/o a number"):
  564:             idx.get_indexer(idx[[0]], method="nearest", tolerance="foo")
  565: 
  566:     @pytest.mark.parametrize(
  567:         "target",
  568:         [
  569:             [date(2020, 1, 1), Timestamp("2020-01-02")],
  570:             [Timestamp("2020-01-01"), date(2020, 1, 2)],
  571:         ],
  572:     )
  573:     def test_get_indexer_mixed_dtypes(self, target):
  574:         # https://github.com/pandas-dev/pandas/issues/33741
  575:         values = DatetimeIndex([Timestamp("2020-01-01"), Timestamp("2020-01-02")])
  576:         result = values.get_indexer(target)
  577:         expected = np.array([0, 1], dtype=np.intp)
  578:         tm.assert_numpy_array_equal(result, expected)
  579: 
  580:     @pytest.mark.parametrize(
  581:         "target, positions",
  582:         [
  583:             ([date(9999, 1, 1), Timestamp("2020-01-01")], [-1, 0]),
  584:             ([Timestamp("2020-01-01"), date(9999, 1, 1)], [0, -1]),
  585:             ([date(9999, 1, 1), date(9999, 1, 1)], [-1, -1]),
  586:         ],
  587:     )
  588:     def test_get_indexer_out_of_bounds_date(self, target, positions):
  589:         values = DatetimeIndex([Timestamp("2020-01-01"), Timestamp("2020-01-02")])
  590: 
  591:         result = values.get_indexer(target)
  592:         expected = np.array(positions, dtype=np.intp)
  593:         tm.assert_numpy_array_equal(result, expected)
  594: 
  595:     def test_get_indexer_pad_requires_monotonicity(self):
  596:         rng = date_range("1/1/2000", "3/1/2000", freq="B")
  597: 
  598:         # neither monotonic increasing or decreasing
  599:         rng2 = rng[[1, 0, 2]]
  600: 
  601:         msg = "index must be monotonic increasing or decreasing"
  602:         with pytest.raises(ValueError, match=msg):
  603:             rng2.get_indexer(rng, method="pad")
  604: 
  605: 
  606: class TestMaybeCastSliceBound:
  607:     def test_maybe_cast_slice_bounds_empty(self):
  608:         # GH#14354
  609:         empty_idx = date_range(freq="1h", periods=0, end="2015")
  610: 
  611:         right = empty_idx._maybe_cast_slice_bound("2015-01-02", "right")
  612:         exp = Timestamp("2015-01-02 23:59:59.999999999")
  613:         assert right == exp
  614: 
  615:         left = empty_idx._maybe_cast_slice_bound("2015-01-02", "left")
  616:         exp = Timestamp("2015-01-02 00:00:00")
  617:         assert left == exp
  618: 
  619:     def test_maybe_cast_slice_duplicate_monotonic(self):
  620:         # https://github.com/pandas-dev/pandas/issues/16515
  621:         idx = DatetimeIndex(["2017", "2017"])
  622:         result = idx._maybe_cast_slice_bound("2017-01-01", "left")
  623:         expected = Timestamp("2017-01-01")
  624:         assert result == expected
  625: 
  626: 
  627: class TestGetSliceBounds:
  628:     @pytest.mark.parametrize("box", [date, datetime, Timestamp])
  629:     @pytest.mark.parametrize("side, expected", [("left", 4), ("right", 5)])
  630:     def test_get_slice_bounds_datetime_within(
  631:         self, box, side, expected, tz_aware_fixture
  632:     ):
  633:         # GH 35690
  634:         tz = tz_aware_fixture
  635:         index = bdate_range("2000-01-03", "2000-02-11").tz_localize(tz)
  636:         key = box(year=2000, month=1, day=7)
  637: 
  638:         if tz is not None:
  639:             with pytest.raises(TypeError, match="Cannot compare tz-naive"):
  640:                 # GH#36148 we require tzawareness-compat as of 2.0
  641:                 index.get_slice_bound(key, side=side)
  642:         else:
  643:             result = index.get_slice_bound(key, side=side)
  644:             assert result == expected
  645: 
  646:     @pytest.mark.parametrize("box", [datetime, Timestamp])
  647:     @pytest.mark.parametrize("side", ["left", "right"])
  648:     @pytest.mark.parametrize("year, expected", [(1999, 0), (2020, 30)])
  649:     def test_get_slice_bounds_datetime_outside(
  650:         self, box, side, year, expected, tz_aware_fixture
  651:     ):
  652:         # GH 35690
  653:         tz = tz_aware_fixture
  654:         index = bdate_range("2000-01-03", "2000-02-11").tz_localize(tz)
  655:         key = box(year=year, month=1, day=7)
  656: 
  657:         if tz is not None:
  658:             with pytest.raises(TypeError, match="Cannot compare tz-naive"):
  659:                 # GH#36148 we require tzawareness-compat as of 2.0
  660:                 index.get_slice_bound(key, side=side)
  661:         else:
  662:             result = index.get_slice_bound(key, side=side)
  663:             assert result == expected
  664: 
  665:     @pytest.mark.parametrize("box", [datetime, Timestamp])
  666:     def test_slice_datetime_locs(self, box, tz_aware_fixture):
  667:         # GH 34077
  668:         tz = tz_aware_fixture
  669:         index = DatetimeIndex(["2010-01-01", "2010-01-03"]).tz_localize(tz)
  670:         key = box(2010, 1, 1)
  671: 
  672:         if tz is not None:
  673:             with pytest.raises(TypeError, match="Cannot compare tz-naive"):
  674:                 # GH#36148 we require tzawareness-compat as of 2.0
  675:                 index.slice_locs(key, box(2010, 1, 2))
  676:         else:
  677:             result = index.slice_locs(key, box(2010, 1, 2))
  678:             expected = (0, 1)
  679:             assert result == expected
  680: 
  681: 
  682: class TestIndexerBetweenTime:
  683:     def test_indexer_between_time(self):
  684:         # GH#11818
  685:         rng = date_range("1/1/2000", "1/5/2000", freq="5min")
  686:         msg = r"Cannot convert arg \[datetime\.datetime\(2010, 1, 2, 1, 0\)\] to a time"
  687:         with pytest.raises(ValueError, match=msg):
  688:             rng.indexer_between_time(datetime(2010, 1, 2, 1), datetime(2010, 1, 2, 5))
  689: 
  690:     @pytest.mark.parametrize("unit", ["us", "ms", "s"])
  691:     def test_indexer_between_time_non_nano(self, unit):
  692:         # For simple cases like this, the non-nano indexer_between_time
  693:         #  should match the nano result
  694: 
  695:         rng = date_range("1/1/2000", "1/5/2000", freq="5min")
  696:         arr_nano = rng._data._ndarray
  697: 
  698:         arr = arr_nano.astype(f"M8[{unit}]")
  699: 
  700:         dta = type(rng._data)._simple_new(arr, dtype=arr.dtype)
  701:         dti = DatetimeIndex(dta)
  702:         assert dti.dtype == arr.dtype
  703: 
  704:         tic = time(1, 25)
  705:         toc = time(2, 29)
  706: 
  707:         result = dti.indexer_between_time(tic, toc)
  708:         expected = rng.indexer_between_time(tic, toc)
  709:         tm.assert_numpy_array_equal(result, expected)
  710: 
  711:         # case with non-zero micros in arguments
  712:         tic = time(1, 25, 0, 45678)
  713:         toc = time(2, 29, 0, 1234)
  714: 
  715:         result = dti.indexer_between_time(tic, toc)
  716:         expected = rng.indexer_between_time(tic, toc)
  717:         tm.assert_numpy_array_equal(result, expected)
