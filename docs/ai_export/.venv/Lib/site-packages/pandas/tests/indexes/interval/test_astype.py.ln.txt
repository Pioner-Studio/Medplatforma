    1: import re
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: from pandas.core.dtypes.dtypes import (
    7:     CategoricalDtype,
    8:     IntervalDtype,
    9: )
   10: 
   11: from pandas import (
   12:     CategoricalIndex,
   13:     Index,
   14:     IntervalIndex,
   15:     NaT,
   16:     Timedelta,
   17:     Timestamp,
   18:     interval_range,
   19: )
   20: import pandas._testing as tm
   21: 
   22: 
   23: class AstypeTests:
   24:     """Tests common to IntervalIndex with any subtype"""
   25: 
   26:     def test_astype_idempotent(self, index):
   27:         result = index.astype("interval")
   28:         tm.assert_index_equal(result, index)
   29: 
   30:         result = index.astype(index.dtype)
   31:         tm.assert_index_equal(result, index)
   32: 
   33:     def test_astype_object(self, index):
   34:         result = index.astype(object)
   35:         expected = Index(index.values, dtype="object")
   36:         tm.assert_index_equal(result, expected)
   37:         assert not result.equals(index)
   38: 
   39:     def test_astype_category(self, index):
   40:         result = index.astype("category")
   41:         expected = CategoricalIndex(index.values)
   42:         tm.assert_index_equal(result, expected)
   43: 
   44:         result = index.astype(CategoricalDtype())
   45:         tm.assert_index_equal(result, expected)
   46: 
   47:         # non-default params
   48:         categories = index.dropna().unique().values[:-1]
   49:         dtype = CategoricalDtype(categories=categories, ordered=True)
   50:         result = index.astype(dtype)
   51:         expected = CategoricalIndex(index.values, categories=categories, ordered=True)
   52:         tm.assert_index_equal(result, expected)
   53: 
   54:     @pytest.mark.parametrize(
   55:         "dtype",
   56:         [
   57:             "int64",
   58:             "uint64",
   59:             "float64",
   60:             "complex128",
   61:             "period[M]",
   62:             "timedelta64",
   63:             "timedelta64[ns]",
   64:             "datetime64",
   65:             "datetime64[ns]",
   66:             "datetime64[ns, US/Eastern]",
   67:         ],
   68:     )
   69:     def test_astype_cannot_cast(self, index, dtype):
   70:         msg = "Cannot cast IntervalIndex to dtype"
   71:         with pytest.raises(TypeError, match=msg):
   72:             index.astype(dtype)
   73: 
   74:     def test_astype_invalid_dtype(self, index):
   75:         msg = "data type [\"']fake_dtype[\"'] not understood"
   76:         with pytest.raises(TypeError, match=msg):
   77:             index.astype("fake_dtype")
   78: 
   79: 
   80: class TestIntSubtype(AstypeTests):
   81:     """Tests specific to IntervalIndex with integer-like subtype"""
   82: 
   83:     indexes = [
   84:         IntervalIndex.from_breaks(np.arange(-10, 11, dtype="int64")),
   85:         IntervalIndex.from_breaks(np.arange(100, dtype="uint64"), closed="left"),
   86:     ]
   87: 
   88:     @pytest.fixture(params=indexes)
   89:     def index(self, request):
   90:         return request.param
   91: 
   92:     @pytest.mark.parametrize(
   93:         "subtype", ["float64", "datetime64[ns]", "timedelta64[ns]"]
   94:     )
   95:     def test_subtype_conversion(self, index, subtype):
   96:         dtype = IntervalDtype(subtype, index.closed)
   97:         result = index.astype(dtype)
   98:         expected = IntervalIndex.from_arrays(
   99:             index.left.astype(subtype), index.right.astype(subtype), closed=index.closed
  100:         )
  101:         tm.assert_index_equal(result, expected)
  102: 
  103:     @pytest.mark.parametrize(
  104:         "subtype_start, subtype_end", [("int64", "uint64"), ("uint64", "int64")]
  105:     )
  106:     def test_subtype_integer(self, subtype_start, subtype_end):
  107:         index = IntervalIndex.from_breaks(np.arange(100, dtype=subtype_start))
  108:         dtype = IntervalDtype(subtype_end, index.closed)
  109:         result = index.astype(dtype)
  110:         expected = IntervalIndex.from_arrays(
  111:             index.left.astype(subtype_end),
  112:             index.right.astype(subtype_end),
  113:             closed=index.closed,
  114:         )
  115:         tm.assert_index_equal(result, expected)
  116: 
  117:     @pytest.mark.xfail(reason="GH#15832")
  118:     def test_subtype_integer_errors(self):
  119:         # int64 -> uint64 fails with negative values
  120:         index = interval_range(-10, 10)
  121:         dtype = IntervalDtype("uint64", "right")
  122: 
  123:         # Until we decide what the exception message _should_ be, we
  124:         #  assert something that it should _not_ be.
  125:         #  We should _not_ be getting a message suggesting that the -10
  126:         #  has been wrapped around to a large-positive integer
  127:         msg = "^(?!(left side of interval must be <= right side))"
  128:         with pytest.raises(ValueError, match=msg):
  129:             index.astype(dtype)
  130: 
  131: 
  132: class TestFloatSubtype(AstypeTests):
  133:     """Tests specific to IntervalIndex with float subtype"""
  134: 
  135:     indexes = [
  136:         interval_range(-10.0, 10.0, closed="neither"),
  137:         IntervalIndex.from_arrays(
  138:             [-1.5, np.nan, 0.0, 0.0, 1.5], [-0.5, np.nan, 1.0, 1.0, 3.0], closed="both"
  139:         ),
  140:     ]
  141: 
  142:     @pytest.fixture(params=indexes)
  143:     def index(self, request):
  144:         return request.param
  145: 
  146:     @pytest.mark.parametrize("subtype", ["int64", "uint64"])
  147:     def test_subtype_integer(self, subtype):
  148:         index = interval_range(0.0, 10.0)
  149:         dtype = IntervalDtype(subtype, "right")
  150:         result = index.astype(dtype)
  151:         expected = IntervalIndex.from_arrays(
  152:             index.left.astype(subtype), index.right.astype(subtype), closed=index.closed
  153:         )
  154:         tm.assert_index_equal(result, expected)
  155: 
  156:         # raises with NA
  157:         msg = r"Cannot convert non-finite values \(NA or inf\) to integer"
  158:         with pytest.raises(ValueError, match=msg):
  159:             index.insert(0, np.nan).astype(dtype)
  160: 
  161:     @pytest.mark.parametrize("subtype", ["int64", "uint64"])
  162:     def test_subtype_integer_with_non_integer_borders(self, subtype):
  163:         index = interval_range(0.0, 3.0, freq=0.25)
  164:         dtype = IntervalDtype(subtype, "right")
  165:         result = index.astype(dtype)
  166:         expected = IntervalIndex.from_arrays(
  167:             index.left.astype(subtype), index.right.astype(subtype), closed=index.closed
  168:         )
  169:         tm.assert_index_equal(result, expected)
  170: 
  171:     def test_subtype_integer_errors(self):
  172:         # float64 -> uint64 fails with negative values
  173:         index = interval_range(-10.0, 10.0)
  174:         dtype = IntervalDtype("uint64", "right")
  175:         msg = re.escape(
  176:             "Cannot convert interval[float64, right] to interval[uint64, right]; "
  177:             "subtypes are incompatible"
  178:         )
  179:         with pytest.raises(TypeError, match=msg):
  180:             index.astype(dtype)
  181: 
  182:     @pytest.mark.parametrize("subtype", ["datetime64[ns]", "timedelta64[ns]"])
  183:     def test_subtype_datetimelike(self, index, subtype):
  184:         dtype = IntervalDtype(subtype, "right")
  185:         msg = "Cannot convert .* to .*; subtypes are incompatible"
  186:         with pytest.raises(TypeError, match=msg):
  187:             index.astype(dtype)
  188: 
  189: 
  190: class TestDatetimelikeSubtype(AstypeTests):
  191:     """Tests specific to IntervalIndex with datetime-like subtype"""
  192: 
  193:     indexes = [
  194:         interval_range(Timestamp("2018-01-01"), periods=10, closed="neither"),
  195:         interval_range(Timestamp("2018-01-01"), periods=10).insert(2, NaT),
  196:         interval_range(Timestamp("2018-01-01", tz="US/Eastern"), periods=10),
  197:         interval_range(Timedelta("0 days"), periods=10, closed="both"),
  198:         interval_range(Timedelta("0 days"), periods=10).insert(2, NaT),
  199:     ]
  200: 
  201:     @pytest.fixture(params=indexes)
  202:     def index(self, request):
  203:         return request.param
  204: 
  205:     @pytest.mark.parametrize("subtype", ["int64", "uint64"])
  206:     def test_subtype_integer(self, index, subtype):
  207:         dtype = IntervalDtype(subtype, "right")
  208: 
  209:         if subtype != "int64":
  210:             msg = (
  211:                 r"Cannot convert interval\[(timedelta64|datetime64)\[ns.*\], .*\] "
  212:                 r"to interval\[uint64, .*\]"
  213:             )
  214:             with pytest.raises(TypeError, match=msg):
  215:                 index.astype(dtype)
  216:             return
  217: 
  218:         result = index.astype(dtype)
  219:         new_left = index.left.astype(subtype)
  220:         new_right = index.right.astype(subtype)
  221: 
  222:         expected = IntervalIndex.from_arrays(new_left, new_right, closed=index.closed)
  223:         tm.assert_index_equal(result, expected)
  224: 
  225:     def test_subtype_float(self, index):
  226:         dtype = IntervalDtype("float64", "right")
  227:         msg = "Cannot convert .* to .*; subtypes are incompatible"
  228:         with pytest.raises(TypeError, match=msg):
  229:             index.astype(dtype)
  230: 
  231:     def test_subtype_datetimelike(self):
  232:         # datetime -> timedelta raises
  233:         dtype = IntervalDtype("timedelta64[ns]", "right")
  234:         msg = "Cannot convert .* to .*; subtypes are incompatible"
  235: 
  236:         index = interval_range(Timestamp("2018-01-01"), periods=10)
  237:         with pytest.raises(TypeError, match=msg):
  238:             index.astype(dtype)
  239: 
  240:         index = interval_range(Timestamp("2018-01-01", tz="CET"), periods=10)
  241:         with pytest.raises(TypeError, match=msg):
  242:             index.astype(dtype)
  243: 
  244:         # timedelta -> datetime raises
  245:         dtype = IntervalDtype("datetime64[ns]", "right")
  246:         index = interval_range(Timedelta("0 days"), periods=10)
  247:         with pytest.raises(TypeError, match=msg):
  248:             index.astype(dtype)
