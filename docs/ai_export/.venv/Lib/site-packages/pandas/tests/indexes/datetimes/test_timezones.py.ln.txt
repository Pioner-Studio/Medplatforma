    1: """
    2: Tests for DatetimeIndex timezone-related methods
    3: """
    4: from datetime import (
    5:     datetime,
    6:     timedelta,
    7:     timezone,
    8:     tzinfo,
    9: )
   10: 
   11: from dateutil.tz import gettz
   12: import numpy as np
   13: import pytest
   14: import pytz
   15: 
   16: from pandas._libs.tslibs import (
   17:     conversion,
   18:     timezones,
   19: )
   20: 
   21: import pandas as pd
   22: from pandas import (
   23:     DatetimeIndex,
   24:     Timestamp,
   25:     bdate_range,
   26:     date_range,
   27:     isna,
   28:     to_datetime,
   29: )
   30: import pandas._testing as tm
   31: 
   32: 
   33: class FixedOffset(tzinfo):
   34:     """Fixed offset in minutes east from UTC."""
   35: 
   36:     def __init__(self, offset, name) -> None:
   37:         self.__offset = timedelta(minutes=offset)
   38:         self.__name = name
   39: 
   40:     def utcoffset(self, dt):
   41:         return self.__offset
   42: 
   43:     def tzname(self, dt):
   44:         return self.__name
   45: 
   46:     def dst(self, dt):
   47:         return timedelta(0)
   48: 
   49: 
   50: fixed_off_no_name = FixedOffset(-330, None)
   51: 
   52: 
   53: class TestDatetimeIndexTimezones:
   54:     # -------------------------------------------------------------
   55:     # Unsorted
   56: 
   57:     def test_dti_drop_dont_lose_tz(self):
   58:         # GH#2621
   59:         ind = date_range("2012-12-01", periods=10, tz="utc")
   60:         ind = ind.drop(ind[-1])
   61: 
   62:         assert ind.tz is not None
   63: 
   64:     def test_dti_tz_conversion_freq(self, tz_naive_fixture):
   65:         # GH25241
   66:         t3 = DatetimeIndex(["2019-01-01 10:00"], freq="h")
   67:         assert t3.tz_localize(tz=tz_naive_fixture).freq == t3.freq
   68:         t4 = DatetimeIndex(["2019-01-02 12:00"], tz="UTC", freq="min")
   69:         assert t4.tz_convert(tz="UTC").freq == t4.freq
   70: 
   71:     def test_drop_dst_boundary(self):
   72:         # see gh-18031
   73:         tz = "Europe/Brussels"
   74:         freq = "15min"
   75: 
   76:         start = Timestamp("201710290100", tz=tz)
   77:         end = Timestamp("201710290300", tz=tz)
   78:         index = date_range(start=start, end=end, freq=freq)
   79: 
   80:         expected = DatetimeIndex(
   81:             [
   82:                 "201710290115",
   83:                 "201710290130",
   84:                 "201710290145",
   85:                 "201710290200",
   86:                 "201710290215",
   87:                 "201710290230",
   88:                 "201710290245",
   89:                 "201710290200",
   90:                 "201710290215",
   91:                 "201710290230",
   92:                 "201710290245",
   93:                 "201710290300",
   94:             ],
   95:             dtype="M8[ns, Europe/Brussels]",
   96:             freq=freq,
   97:             ambiguous=[
   98:                 True,
   99:                 True,
  100:                 True,
  101:                 True,
  102:                 True,
  103:                 True,
  104:                 True,
  105:                 False,
  106:                 False,
  107:                 False,
  108:                 False,
  109:                 False,
  110:             ],
  111:         )
  112:         result = index.drop(index[0])
  113:         tm.assert_index_equal(result, expected)
  114: 
  115:     def test_date_range_localize(self, unit):
  116:         rng = date_range(
  117:             "3/11/2012 03:00", periods=15, freq="h", tz="US/Eastern", unit=unit
  118:         )
  119:         rng2 = DatetimeIndex(
  120:             ["3/11/2012 03:00", "3/11/2012 04:00"], dtype=f"M8[{unit}, US/Eastern]"
  121:         )
  122:         rng3 = date_range("3/11/2012 03:00", periods=15, freq="h", unit=unit)
  123:         rng3 = rng3.tz_localize("US/Eastern")
  124: 
  125:         tm.assert_index_equal(rng._with_freq(None), rng3)
  126: 
  127:         # DST transition time
  128:         val = rng[0]
  129:         exp = Timestamp("3/11/2012 03:00", tz="US/Eastern")
  130: 
  131:         assert val.hour == 3
  132:         assert exp.hour == 3
  133:         assert val == exp  # same UTC value
  134:         tm.assert_index_equal(rng[:2], rng2)
  135: 
  136:     def test_date_range_localize2(self, unit):
  137:         # Right before the DST transition
  138:         rng = date_range(
  139:             "3/11/2012 00:00", periods=2, freq="h", tz="US/Eastern", unit=unit
  140:         )
  141:         rng2 = DatetimeIndex(
  142:             ["3/11/2012 00:00", "3/11/2012 01:00"],
  143:             dtype=f"M8[{unit}, US/Eastern]",
  144:             freq="h",
  145:         )
  146:         tm.assert_index_equal(rng, rng2)
  147:         exp = Timestamp("3/11/2012 00:00", tz="US/Eastern")
  148:         assert exp.hour == 0
  149:         assert rng[0] == exp
  150:         exp = Timestamp("3/11/2012 01:00", tz="US/Eastern")
  151:         assert exp.hour == 1
  152:         assert rng[1] == exp
  153: 
  154:         rng = date_range(
  155:             "3/11/2012 00:00", periods=10, freq="h", tz="US/Eastern", unit=unit
  156:         )
  157:         assert rng[2].hour == 3
  158: 
  159:     def test_timestamp_equality_different_timezones(self):
  160:         utc_range = date_range("1/1/2000", periods=20, tz="UTC")
  161:         eastern_range = utc_range.tz_convert("US/Eastern")
  162:         berlin_range = utc_range.tz_convert("Europe/Berlin")
  163: 
  164:         for a, b, c in zip(utc_range, eastern_range, berlin_range):
  165:             assert a == b
  166:             assert b == c
  167:             assert a == c
  168: 
  169:         assert (utc_range == eastern_range).all()
  170:         assert (utc_range == berlin_range).all()
  171:         assert (berlin_range == eastern_range).all()
  172: 
  173:     def test_dti_equals_with_tz(self):
  174:         left = date_range("1/1/2011", periods=100, freq="h", tz="utc")
  175:         right = date_range("1/1/2011", periods=100, freq="h", tz="US/Eastern")
  176: 
  177:         assert not left.equals(right)
  178: 
  179:     @pytest.mark.parametrize("tzstr", ["US/Eastern", "dateutil/US/Eastern"])
  180:     def test_dti_tz_nat(self, tzstr):
  181:         idx = DatetimeIndex([Timestamp("2013-1-1", tz=tzstr), pd.NaT])
  182: 
  183:         assert isna(idx[1])
  184:         assert idx[0].tzinfo is not None
  185: 
  186:     @pytest.mark.parametrize("tzstr", ["US/Eastern", "dateutil/US/Eastern"])
  187:     def test_utc_box_timestamp_and_localize(self, tzstr):
  188:         tz = timezones.maybe_get_tz(tzstr)
  189: 
  190:         rng = date_range("3/11/2012", "3/12/2012", freq="h", tz="utc")
  191:         rng_eastern = rng.tz_convert(tzstr)
  192: 
  193:         expected = rng[-1].astimezone(tz)
  194: 
  195:         stamp = rng_eastern[-1]
  196:         assert stamp == expected
  197:         assert stamp.tzinfo == expected.tzinfo
  198: 
  199:         # right tzinfo
  200:         rng = date_range("3/13/2012", "3/14/2012", freq="h", tz="utc")
  201:         rng_eastern = rng.tz_convert(tzstr)
  202:         # test not valid for dateutil timezones.
  203:         # assert 'EDT' in repr(rng_eastern[0].tzinfo)
  204:         assert "EDT" in repr(rng_eastern[0].tzinfo) or "tzfile" in repr(
  205:             rng_eastern[0].tzinfo
  206:         )
  207: 
  208:     @pytest.mark.parametrize("tz", [pytz.timezone("US/Central"), gettz("US/Central")])
  209:     def test_with_tz(self, tz):
  210:         # just want it to work
  211:         start = datetime(2011, 3, 12, tzinfo=pytz.utc)
  212:         dr = bdate_range(start, periods=50, freq=pd.offsets.Hour())
  213:         assert dr.tz is pytz.utc
  214: 
  215:         # DateRange with naive datetimes
  216:         dr = bdate_range("1/1/2005", "1/1/2009", tz=pytz.utc)
  217:         dr = bdate_range("1/1/2005", "1/1/2009", tz=tz)
  218: 
  219:         # normalized
  220:         central = dr.tz_convert(tz)
  221:         assert central.tz is tz
  222:         naive = central[0].to_pydatetime().replace(tzinfo=None)
  223:         comp = conversion.localize_pydatetime(naive, tz).tzinfo
  224:         assert central[0].tz is comp
  225: 
  226:         # compare vs a localized tz
  227:         naive = dr[0].to_pydatetime().replace(tzinfo=None)
  228:         comp = conversion.localize_pydatetime(naive, tz).tzinfo
  229:         assert central[0].tz is comp
  230: 
  231:         # datetimes with tzinfo set
  232:         dr = bdate_range(
  233:             datetime(2005, 1, 1, tzinfo=pytz.utc), datetime(2009, 1, 1, tzinfo=pytz.utc)
  234:         )
  235:         msg = "Start and end cannot both be tz-aware with different timezones"
  236:         with pytest.raises(Exception, match=msg):
  237:             bdate_range(datetime(2005, 1, 1, tzinfo=pytz.utc), "1/1/2009", tz=tz)
  238: 
  239:     @pytest.mark.parametrize("tz", [pytz.timezone("US/Eastern"), gettz("US/Eastern")])
  240:     def test_dti_convert_tz_aware_datetime_datetime(self, tz):
  241:         # GH#1581
  242:         dates = [datetime(2000, 1, 1), datetime(2000, 1, 2), datetime(2000, 1, 3)]
  243: 
  244:         dates_aware = [conversion.localize_pydatetime(x, tz) for x in dates]
  245:         result = DatetimeIndex(dates_aware).as_unit("ns")
  246:         assert timezones.tz_compare(result.tz, tz)
  247: 
  248:         converted = to_datetime(dates_aware, utc=True).as_unit("ns")
  249:         ex_vals = np.array([Timestamp(x).as_unit("ns")._value for x in dates_aware])
  250:         tm.assert_numpy_array_equal(converted.asi8, ex_vals)
  251:         assert converted.tz is timezone.utc
