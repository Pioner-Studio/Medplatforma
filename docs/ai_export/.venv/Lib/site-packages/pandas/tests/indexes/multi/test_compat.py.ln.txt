    1: import numpy as np
    2: import pytest
    3: 
    4: import pandas as pd
    5: from pandas import MultiIndex
    6: import pandas._testing as tm
    7: 
    8: 
    9: def test_numeric_compat(idx):
   10:     with pytest.raises(TypeError, match="cannot perform __mul__"):
   11:         idx * 1
   12: 
   13:     with pytest.raises(TypeError, match="cannot perform __rmul__"):
   14:         1 * idx
   15: 
   16:     div_err = "cannot perform __truediv__"
   17:     with pytest.raises(TypeError, match=div_err):
   18:         idx / 1
   19: 
   20:     div_err = div_err.replace(" __", " __r")
   21:     with pytest.raises(TypeError, match=div_err):
   22:         1 / idx
   23: 
   24:     with pytest.raises(TypeError, match="cannot perform __floordiv__"):
   25:         idx // 1
   26: 
   27:     with pytest.raises(TypeError, match="cannot perform __rfloordiv__"):
   28:         1 // idx
   29: 
   30: 
   31: @pytest.mark.parametrize("method", ["all", "any", "__invert__"])
   32: def test_logical_compat(idx, method):
   33:     msg = f"cannot perform {method}"
   34: 
   35:     with pytest.raises(TypeError, match=msg):
   36:         getattr(idx, method)()
   37: 
   38: 
   39: def test_inplace_mutation_resets_values():
   40:     levels = [["a", "b", "c"], [4]]
   41:     levels2 = [[1, 2, 3], ["a"]]
   42:     codes = [[0, 1, 0, 2, 2, 0], [0, 0, 0, 0, 0, 0]]
   43: 
   44:     mi1 = MultiIndex(levels=levels, codes=codes)
   45:     mi2 = MultiIndex(levels=levels2, codes=codes)
   46: 
   47:     # instantiating MultiIndex should not access/cache _.values
   48:     assert "_values" not in mi1._cache
   49:     assert "_values" not in mi2._cache
   50: 
   51:     vals = mi1.values.copy()
   52:     vals2 = mi2.values.copy()
   53: 
   54:     # accessing .values should cache ._values
   55:     assert mi1._values is mi1._cache["_values"]
   56:     assert mi1.values is mi1._cache["_values"]
   57:     assert isinstance(mi1._cache["_values"], np.ndarray)
   58: 
   59:     # Make sure level setting works
   60:     new_vals = mi1.set_levels(levels2).values
   61:     tm.assert_almost_equal(vals2, new_vals)
   62: 
   63:     #  Doesn't drop _values from _cache [implementation detail]
   64:     tm.assert_almost_equal(mi1._cache["_values"], vals)
   65: 
   66:     # ...and values is still same too
   67:     tm.assert_almost_equal(mi1.values, vals)
   68: 
   69:     # Make sure label setting works too
   70:     codes2 = [[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]]
   71:     exp_values = np.empty((6,), dtype=object)
   72:     exp_values[:] = [(1, "a")] * 6
   73: 
   74:     # Must be 1d array of tuples
   75:     assert exp_values.shape == (6,)
   76: 
   77:     new_mi = mi2.set_codes(codes2)
   78:     assert "_values" not in new_mi._cache
   79:     new_values = new_mi.values
   80:     assert "_values" in new_mi._cache
   81: 
   82:     # Shouldn't change cache
   83:     tm.assert_almost_equal(mi2._cache["_values"], vals2)
   84: 
   85:     # Should have correct values
   86:     tm.assert_almost_equal(exp_values, new_values)
   87: 
   88: 
   89: def test_boxable_categorical_values():
   90:     cat = pd.Categorical(pd.date_range("2012-01-01", periods=3, freq="h"))
   91:     result = MultiIndex.from_product([["a", "b", "c"], cat]).values
   92:     expected = pd.Series(
   93:         [
   94:             ("a", pd.Timestamp("2012-01-01 00:00:00")),
   95:             ("a", pd.Timestamp("2012-01-01 01:00:00")),
   96:             ("a", pd.Timestamp("2012-01-01 02:00:00")),
   97:             ("b", pd.Timestamp("2012-01-01 00:00:00")),
   98:             ("b", pd.Timestamp("2012-01-01 01:00:00")),
   99:             ("b", pd.Timestamp("2012-01-01 02:00:00")),
  100:             ("c", pd.Timestamp("2012-01-01 00:00:00")),
  101:             ("c", pd.Timestamp("2012-01-01 01:00:00")),
  102:             ("c", pd.Timestamp("2012-01-01 02:00:00")),
  103:         ]
  104:     ).values
  105:     tm.assert_numpy_array_equal(result, expected)
  106:     result = pd.DataFrame({"a": ["a", "b", "c"], "b": cat, "c": np.array(cat)}).values
  107:     expected = pd.DataFrame(
  108:         {
  109:             "a": ["a", "b", "c"],
  110:             "b": [
  111:                 pd.Timestamp("2012-01-01 00:00:00"),
  112:                 pd.Timestamp("2012-01-01 01:00:00"),
  113:                 pd.Timestamp("2012-01-01 02:00:00"),
  114:             ],
  115:             "c": [
  116:                 pd.Timestamp("2012-01-01 00:00:00"),
  117:                 pd.Timestamp("2012-01-01 01:00:00"),
  118:                 pd.Timestamp("2012-01-01 02:00:00"),
  119:             ],
  120:         }
  121:     ).values
  122:     tm.assert_numpy_array_equal(result, expected)
