    1: from datetime import (
    2:     datetime,
    3:     timedelta,
    4: )
    5: 
    6: import dateutil.tz
    7: from dateutil.tz import gettz
    8: import numpy as np
    9: import pytest
   10: import pytz
   11: 
   12: from pandas import (
   13:     DatetimeIndex,
   14:     Timestamp,
   15:     bdate_range,
   16:     date_range,
   17:     offsets,
   18:     to_datetime,
   19: )
   20: import pandas._testing as tm
   21: 
   22: try:
   23:     from zoneinfo import ZoneInfo
   24: except ImportError:
   25:     # Cannot assign to a type  [misc]
   26:     ZoneInfo = None  # type: ignore[misc, assignment]
   27: 
   28: 
   29: easts = [pytz.timezone("US/Eastern"), gettz("US/Eastern")]
   30: if ZoneInfo is not None:
   31:     try:
   32:         tz = ZoneInfo("US/Eastern")
   33:     except KeyError:
   34:         # no tzdata
   35:         pass
   36:     else:
   37:         easts.append(tz)
   38: 
   39: 
   40: class TestTZLocalize:
   41:     def test_tz_localize_invalidates_freq(self):
   42:         # we only preserve freq in unambiguous cases
   43: 
   44:         # if localized to US/Eastern, this crosses a DST transition
   45:         dti = date_range("2014-03-08 23:00", "2014-03-09 09:00", freq="h")
   46:         assert dti.freq == "h"
   47: 
   48:         result = dti.tz_localize(None)  # no-op
   49:         assert result.freq == "h"
   50: 
   51:         result = dti.tz_localize("UTC")  # unambiguous freq preservation
   52:         assert result.freq == "h"
   53: 
   54:         result = dti.tz_localize("US/Eastern", nonexistent="shift_forward")
   55:         assert result.freq is None
   56:         assert result.inferred_freq is None  # i.e. we are not _too_ strict here
   57: 
   58:         # Case where we _can_ keep freq because we're length==1
   59:         dti2 = dti[:1]
   60:         result = dti2.tz_localize("US/Eastern")
   61:         assert result.freq == "h"
   62: 
   63:     def test_tz_localize_utc_copies(self, utc_fixture):
   64:         # GH#46460
   65:         times = ["2015-03-08 01:00", "2015-03-08 02:00", "2015-03-08 03:00"]
   66:         index = DatetimeIndex(times)
   67: 
   68:         res = index.tz_localize(utc_fixture)
   69:         assert not tm.shares_memory(res, index)
   70: 
   71:         res2 = index._data.tz_localize(utc_fixture)
   72:         assert not tm.shares_memory(index._data, res2)
   73: 
   74:     def test_dti_tz_localize_nonexistent_raise_coerce(self):
   75:         # GH#13057
   76:         times = ["2015-03-08 01:00", "2015-03-08 02:00", "2015-03-08 03:00"]
   77:         index = DatetimeIndex(times)
   78:         tz = "US/Eastern"
   79:         with pytest.raises(pytz.NonExistentTimeError, match="|".join(times)):
   80:             index.tz_localize(tz=tz)
   81: 
   82:         with pytest.raises(pytz.NonExistentTimeError, match="|".join(times)):
   83:             index.tz_localize(tz=tz, nonexistent="raise")
   84: 
   85:         result = index.tz_localize(tz=tz, nonexistent="NaT")
   86:         test_times = ["2015-03-08 01:00-05:00", "NaT", "2015-03-08 03:00-04:00"]
   87:         dti = to_datetime(test_times, utc=True)
   88:         expected = dti.tz_convert("US/Eastern")
   89:         tm.assert_index_equal(result, expected)
   90: 
   91:     @pytest.mark.parametrize("tz", easts)
   92:     def test_dti_tz_localize_ambiguous_infer(self, tz):
   93:         # November 6, 2011, fall back, repeat 2 AM hour
   94:         # With no repeated hours, we cannot infer the transition
   95:         dr = date_range(datetime(2011, 11, 6, 0), periods=5, freq=offsets.Hour())
   96:         with pytest.raises(pytz.AmbiguousTimeError, match="Cannot infer dst time"):
   97:             dr.tz_localize(tz)
   98: 
   99:     @pytest.mark.parametrize("tz", easts)
  100:     def test_dti_tz_localize_ambiguous_infer2(self, tz, unit):
  101:         # With repeated hours, we can infer the transition
  102:         dr = date_range(
  103:             datetime(2011, 11, 6, 0), periods=5, freq=offsets.Hour(), tz=tz, unit=unit
  104:         )
  105:         times = [
  106:             "11/06/2011 00:00",
  107:             "11/06/2011 01:00",
  108:             "11/06/2011 01:00",
  109:             "11/06/2011 02:00",
  110:             "11/06/2011 03:00",
  111:         ]
  112:         di = DatetimeIndex(times).as_unit(unit)
  113:         result = di.tz_localize(tz, ambiguous="infer")
  114:         expected = dr._with_freq(None)
  115:         tm.assert_index_equal(result, expected)
  116:         result2 = DatetimeIndex(times, tz=tz, ambiguous="infer").as_unit(unit)
  117:         tm.assert_index_equal(result2, expected)
  118: 
  119:     @pytest.mark.parametrize("tz", easts)
  120:     def test_dti_tz_localize_ambiguous_infer3(self, tz):
  121:         # When there is no dst transition, nothing special happens
  122:         dr = date_range(datetime(2011, 6, 1, 0), periods=10, freq=offsets.Hour())
  123:         localized = dr.tz_localize(tz)
  124:         localized_infer = dr.tz_localize(tz, ambiguous="infer")
  125:         tm.assert_index_equal(localized, localized_infer)
  126: 
  127:     @pytest.mark.parametrize("tz", easts)
  128:     def test_dti_tz_localize_ambiguous_times(self, tz):
  129:         # March 13, 2011, spring forward, skip from 2 AM to 3 AM
  130:         dr = date_range(datetime(2011, 3, 13, 1, 30), periods=3, freq=offsets.Hour())
  131:         with pytest.raises(pytz.NonExistentTimeError, match="2011-03-13 02:30:00"):
  132:             dr.tz_localize(tz)
  133: 
  134:         # after dst transition, it works
  135:         dr = date_range(
  136:             datetime(2011, 3, 13, 3, 30), periods=3, freq=offsets.Hour(), tz=tz
  137:         )
  138: 
  139:         # November 6, 2011, fall back, repeat 2 AM hour
  140:         dr = date_range(datetime(2011, 11, 6, 1, 30), periods=3, freq=offsets.Hour())
  141:         with pytest.raises(pytz.AmbiguousTimeError, match="Cannot infer dst time"):
  142:             dr.tz_localize(tz)
  143: 
  144:         # UTC is OK
  145:         dr = date_range(
  146:             datetime(2011, 3, 13), periods=48, freq=offsets.Minute(30), tz=pytz.utc
  147:         )
  148: 
  149:     @pytest.mark.parametrize("tzstr", ["US/Eastern", "dateutil/US/Eastern"])
  150:     def test_dti_tz_localize_pass_dates_to_utc(self, tzstr):
  151:         strdates = ["1/1/2012", "3/1/2012", "4/1/2012"]
  152: 
  153:         idx = DatetimeIndex(strdates)
  154:         conv = idx.tz_localize(tzstr)
  155: 
  156:         fromdates = DatetimeIndex(strdates, tz=tzstr)
  157: 
  158:         assert conv.tz == fromdates.tz
  159:         tm.assert_numpy_array_equal(conv.values, fromdates.values)
  160: 
  161:     @pytest.mark.parametrize("prefix", ["", "dateutil/"])
  162:     def test_dti_tz_localize(self, prefix):
  163:         tzstr = prefix + "US/Eastern"
  164:         dti = date_range(start="1/1/2005", end="1/1/2005 0:00:30.256", freq="ms")
  165:         dti2 = dti.tz_localize(tzstr)
  166: 
  167:         dti_utc = date_range(
  168:             start="1/1/2005 05:00", end="1/1/2005 5:00:30.256", freq="ms", tz="utc"
  169:         )
  170: 
  171:         tm.assert_numpy_array_equal(dti2.values, dti_utc.values)
  172: 
  173:         dti3 = dti2.tz_convert(prefix + "US/Pacific")
  174:         tm.assert_numpy_array_equal(dti3.values, dti_utc.values)
  175: 
  176:         dti = date_range(start="11/6/2011 1:59", end="11/6/2011 2:00", freq="ms")
  177:         with pytest.raises(pytz.AmbiguousTimeError, match="Cannot infer dst time"):
  178:             dti.tz_localize(tzstr)
  179: 
  180:         dti = date_range(start="3/13/2011 1:59", end="3/13/2011 2:00", freq="ms")
  181:         with pytest.raises(pytz.NonExistentTimeError, match="2011-03-13 02:00:00"):
  182:             dti.tz_localize(tzstr)
  183: 
  184:     @pytest.mark.parametrize(
  185:         "tz",
  186:         [
  187:             "US/Eastern",
  188:             "dateutil/US/Eastern",
  189:             pytz.timezone("US/Eastern"),
  190:             gettz("US/Eastern"),
  191:         ],
  192:     )
  193:     def test_dti_tz_localize_utc_conversion(self, tz):
  194:         # Localizing to time zone should:
  195:         #  1) check for DST ambiguities
  196:         #  2) convert to UTC
  197: 
  198:         rng = date_range("3/10/2012", "3/11/2012", freq="30min")
  199: 
  200:         converted = rng.tz_localize(tz)
  201:         expected_naive = rng + offsets.Hour(5)
  202:         tm.assert_numpy_array_equal(converted.asi8, expected_naive.asi8)
  203: 
  204:         # DST ambiguity, this should fail
  205:         rng = date_range("3/11/2012", "3/12/2012", freq="30min")
  206:         # Is this really how it should fail??
  207:         with pytest.raises(pytz.NonExistentTimeError, match="2012-03-11 02:00:00"):
  208:             rng.tz_localize(tz)
  209: 
  210:     def test_dti_tz_localize_roundtrip(self, tz_aware_fixture):
  211:         # note: this tz tests that a tz-naive index can be localized
  212:         # and de-localized successfully, when there are no DST transitions
  213:         # in the range.
  214:         idx = date_range(start="2014-06-01", end="2014-08-30", freq="15min")
  215:         tz = tz_aware_fixture
  216:         localized = idx.tz_localize(tz)
  217:         # can't localize a tz-aware object
  218:         with pytest.raises(
  219:             TypeError, match="Already tz-aware, use tz_convert to convert"
  220:         ):
  221:             localized.tz_localize(tz)
  222:         reset = localized.tz_localize(None)
  223:         assert reset.tzinfo is None
  224:         expected = idx._with_freq(None)
  225:         tm.assert_index_equal(reset, expected)
  226: 
  227:     def test_dti_tz_localize_naive(self):
  228:         rng = date_range("1/1/2011", periods=100, freq="h")
  229: 
  230:         conv = rng.tz_localize("US/Pacific")
  231:         exp = date_range("1/1/2011", periods=100, freq="h", tz="US/Pacific")
  232: 
  233:         tm.assert_index_equal(conv, exp._with_freq(None))
  234: 
  235:     def test_dti_tz_localize_tzlocal(self):
  236:         # GH#13583
  237:         offset = dateutil.tz.tzlocal().utcoffset(datetime(2011, 1, 1))
  238:         offset = int(offset.total_seconds() * 1000000000)
  239: 
  240:         dti = date_range(start="2001-01-01", end="2001-03-01")
  241:         dti2 = dti.tz_localize(dateutil.tz.tzlocal())
  242:         tm.assert_numpy_array_equal(dti2.asi8 + offset, dti.asi8)
  243: 
  244:         dti = date_range(start="2001-01-01", end="2001-03-01", tz=dateutil.tz.tzlocal())
  245:         dti2 = dti.tz_localize(None)
  246:         tm.assert_numpy_array_equal(dti2.asi8 - offset, dti.asi8)
  247: 
  248:     @pytest.mark.parametrize("tz", easts)
  249:     def test_dti_tz_localize_ambiguous_nat(self, tz):
  250:         times = [
  251:             "11/06/2011 00:00",
  252:             "11/06/2011 01:00",
  253:             "11/06/2011 01:00",
  254:             "11/06/2011 02:00",
  255:             "11/06/2011 03:00",
  256:         ]
  257:         di = DatetimeIndex(times)
  258:         localized = di.tz_localize(tz, ambiguous="NaT")
  259: 
  260:         times = [
  261:             "11/06/2011 00:00",
  262:             np.nan,
  263:             np.nan,
  264:             "11/06/2011 02:00",
  265:             "11/06/2011 03:00",
  266:         ]
  267:         di_test = DatetimeIndex(times, tz="US/Eastern")
  268: 
  269:         # left dtype is datetime64[ns, US/Eastern]
  270:         # right is datetime64[ns, tzfile('/usr/share/zoneinfo/US/Eastern')]
  271:         tm.assert_numpy_array_equal(di_test.values, localized.values)
  272: 
  273:     @pytest.mark.parametrize("tz", easts)
  274:     def test_dti_tz_localize_ambiguous_flags(self, tz, unit):
  275:         # November 6, 2011, fall back, repeat 2 AM hour
  276: 
  277:         # Pass in flags to determine right dst transition
  278:         dr = date_range(
  279:             datetime(2011, 11, 6, 0), periods=5, freq=offsets.Hour(), tz=tz, unit=unit
  280:         )
  281:         times = [
  282:             "11/06/2011 00:00",
  283:             "11/06/2011 01:00",
  284:             "11/06/2011 01:00",
  285:             "11/06/2011 02:00",
  286:             "11/06/2011 03:00",
  287:         ]
  288: 
  289:         # Test tz_localize
  290:         di = DatetimeIndex(times).as_unit(unit)
  291:         is_dst = [1, 1, 0, 0, 0]
  292:         localized = di.tz_localize(tz, ambiguous=is_dst)
  293:         expected = dr._with_freq(None)
  294:         tm.assert_index_equal(expected, localized)
  295: 
  296:         result = DatetimeIndex(times, tz=tz, ambiguous=is_dst).as_unit(unit)
  297:         tm.assert_index_equal(result, expected)
  298: 
  299:         localized = di.tz_localize(tz, ambiguous=np.array(is_dst))
  300:         tm.assert_index_equal(dr, localized)
  301: 
  302:         localized = di.tz_localize(tz, ambiguous=np.array(is_dst).astype("bool"))
  303:         tm.assert_index_equal(dr, localized)
  304: 
  305:         # Test constructor
  306:         localized = DatetimeIndex(times, tz=tz, ambiguous=is_dst).as_unit(unit)
  307:         tm.assert_index_equal(dr, localized)
  308: 
  309:         # Test duplicate times where inferring the dst fails
  310:         times += times
  311:         di = DatetimeIndex(times).as_unit(unit)
  312: 
  313:         # When the sizes are incompatible, make sure error is raised
  314:         msg = "Length of ambiguous bool-array must be the same size as vals"
  315:         with pytest.raises(Exception, match=msg):
  316:             di.tz_localize(tz, ambiguous=is_dst)
  317: 
  318:         # When sizes are compatible and there are repeats ('infer' won't work)
  319:         is_dst = np.hstack((is_dst, is_dst))
  320:         localized = di.tz_localize(tz, ambiguous=is_dst)
  321:         dr = dr.append(dr)
  322:         tm.assert_index_equal(dr, localized)
  323: 
  324:     @pytest.mark.parametrize("tz", easts)
  325:     def test_dti_tz_localize_ambiguous_flags2(self, tz, unit):
  326:         # When there is no dst transition, nothing special happens
  327:         dr = date_range(datetime(2011, 6, 1, 0), periods=10, freq=offsets.Hour())
  328:         is_dst = np.array([1] * 10)
  329:         localized = dr.tz_localize(tz)
  330:         localized_is_dst = dr.tz_localize(tz, ambiguous=is_dst)
  331:         tm.assert_index_equal(localized, localized_is_dst)
  332: 
  333:     def test_dti_tz_localize_bdate_range(self):
  334:         dr = bdate_range("1/1/2009", "1/1/2010")
  335:         dr_utc = bdate_range("1/1/2009", "1/1/2010", tz=pytz.utc)
  336:         localized = dr.tz_localize(pytz.utc)
  337:         tm.assert_index_equal(dr_utc, localized)
  338: 
  339:     @pytest.mark.parametrize(
  340:         "start_ts, tz, end_ts, shift",
  341:         [
  342:             ["2015-03-29 02:20:00", "Europe/Warsaw", "2015-03-29 03:00:00", "forward"],
  343:             [
  344:                 "2015-03-29 02:20:00",
  345:                 "Europe/Warsaw",
  346:                 "2015-03-29 01:59:59.999999999",
  347:                 "backward",
  348:             ],
  349:             [
  350:                 "2015-03-29 02:20:00",
  351:                 "Europe/Warsaw",
  352:                 "2015-03-29 03:20:00",
  353:                 timedelta(hours=1),
  354:             ],
  355:             [
  356:                 "2015-03-29 02:20:00",
  357:                 "Europe/Warsaw",
  358:                 "2015-03-29 01:20:00",
  359:                 timedelta(hours=-1),
  360:             ],
  361:             ["2018-03-11 02:33:00", "US/Pacific", "2018-03-11 03:00:00", "forward"],
  362:             [
  363:                 "2018-03-11 02:33:00",
  364:                 "US/Pacific",
  365:                 "2018-03-11 01:59:59.999999999",
  366:                 "backward",
  367:             ],
  368:             [
  369:                 "2018-03-11 02:33:00",
  370:                 "US/Pacific",
  371:                 "2018-03-11 03:33:00",
  372:                 timedelta(hours=1),
  373:             ],
  374:             [
  375:                 "2018-03-11 02:33:00",
  376:                 "US/Pacific",
  377:                 "2018-03-11 01:33:00",
  378:                 timedelta(hours=-1),
  379:             ],
  380:         ],
  381:     )
  382:     @pytest.mark.parametrize("tz_type", ["", "dateutil/"])
  383:     def test_dti_tz_localize_nonexistent_shift(
  384:         self, start_ts, tz, end_ts, shift, tz_type, unit
  385:     ):
  386:         # GH#8917
  387:         tz = tz_type + tz
  388:         if isinstance(shift, str):
  389:             shift = "shift_" + shift
  390:         dti = DatetimeIndex([Timestamp(start_ts)]).as_unit(unit)
  391:         result = dti.tz_localize(tz, nonexistent=shift)
  392:         expected = DatetimeIndex([Timestamp(end_ts)]).tz_localize(tz).as_unit(unit)
  393:         tm.assert_index_equal(result, expected)
  394: 
  395:     @pytest.mark.parametrize("offset", [-1, 1])
  396:     def test_dti_tz_localize_nonexistent_shift_invalid(self, offset, warsaw):
  397:         # GH#8917
  398:         tz = warsaw
  399:         dti = DatetimeIndex([Timestamp("2015-03-29 02:20:00")])
  400:         msg = "The provided timedelta will relocalize on a nonexistent time"
  401:         with pytest.raises(ValueError, match=msg):
  402:             dti.tz_localize(tz, nonexistent=timedelta(seconds=offset))
