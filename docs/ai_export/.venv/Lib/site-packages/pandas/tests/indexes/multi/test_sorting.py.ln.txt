    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas.errors import (
    5:     PerformanceWarning,
    6:     UnsortedIndexError,
    7: )
    8: 
    9: from pandas import (
   10:     CategoricalIndex,
   11:     DataFrame,
   12:     Index,
   13:     MultiIndex,
   14:     RangeIndex,
   15:     Series,
   16:     Timestamp,
   17: )
   18: import pandas._testing as tm
   19: from pandas.core.indexes.frozen import FrozenList
   20: 
   21: 
   22: def test_sortlevel(idx):
   23:     tuples = list(idx)
   24:     np.random.default_rng(2).shuffle(tuples)
   25: 
   26:     index = MultiIndex.from_tuples(tuples)
   27: 
   28:     sorted_idx, _ = index.sortlevel(0)
   29:     expected = MultiIndex.from_tuples(sorted(tuples))
   30:     assert sorted_idx.equals(expected)
   31: 
   32:     sorted_idx, _ = index.sortlevel(0, ascending=False)
   33:     assert sorted_idx.equals(expected[::-1])
   34: 
   35:     sorted_idx, _ = index.sortlevel(1)
   36:     by1 = sorted(tuples, key=lambda x: (x[1], x[0]))
   37:     expected = MultiIndex.from_tuples(by1)
   38:     assert sorted_idx.equals(expected)
   39: 
   40:     sorted_idx, _ = index.sortlevel(1, ascending=False)
   41:     assert sorted_idx.equals(expected[::-1])
   42: 
   43: 
   44: def test_sortlevel_not_sort_remaining():
   45:     mi = MultiIndex.from_tuples([[1, 1, 3], [1, 1, 1]], names=list("ABC"))
   46:     sorted_idx, _ = mi.sortlevel("A", sort_remaining=False)
   47:     assert sorted_idx.equals(mi)
   48: 
   49: 
   50: def test_sortlevel_deterministic():
   51:     tuples = [
   52:         ("bar", "one"),
   53:         ("foo", "two"),
   54:         ("qux", "two"),
   55:         ("foo", "one"),
   56:         ("baz", "two"),
   57:         ("qux", "one"),
   58:     ]
   59: 
   60:     index = MultiIndex.from_tuples(tuples)
   61: 
   62:     sorted_idx, _ = index.sortlevel(0)
   63:     expected = MultiIndex.from_tuples(sorted(tuples))
   64:     assert sorted_idx.equals(expected)
   65: 
   66:     sorted_idx, _ = index.sortlevel(0, ascending=False)
   67:     assert sorted_idx.equals(expected[::-1])
   68: 
   69:     sorted_idx, _ = index.sortlevel(1)
   70:     by1 = sorted(tuples, key=lambda x: (x[1], x[0]))
   71:     expected = MultiIndex.from_tuples(by1)
   72:     assert sorted_idx.equals(expected)
   73: 
   74:     sorted_idx, _ = index.sortlevel(1, ascending=False)
   75:     assert sorted_idx.equals(expected[::-1])
   76: 
   77: 
   78: def test_sortlevel_na_position():
   79:     # GH#51612
   80:     midx = MultiIndex.from_tuples([(1, np.nan), (1, 1)])
   81:     result = midx.sortlevel(level=[0, 1], na_position="last")[0]
   82:     expected = MultiIndex.from_tuples([(1, 1), (1, np.nan)])
   83:     tm.assert_index_equal(result, expected)
   84: 
   85: 
   86: def test_numpy_argsort(idx):
   87:     result = np.argsort(idx)
   88:     expected = idx.argsort()
   89:     tm.assert_numpy_array_equal(result, expected)
   90: 
   91:     # these are the only two types that perform
   92:     # pandas compatibility input validation - the
   93:     # rest already perform separate (or no) such
   94:     # validation via their 'values' attribute as
   95:     # defined in pandas.core.indexes/base.py - they
   96:     # cannot be changed at the moment due to
   97:     # backwards compatibility concerns
   98:     if isinstance(type(idx), (CategoricalIndex, RangeIndex)):
   99:         msg = "the 'axis' parameter is not supported"
  100:         with pytest.raises(ValueError, match=msg):
  101:             np.argsort(idx, axis=1)
  102: 
  103:         msg = "the 'kind' parameter is not supported"
  104:         with pytest.raises(ValueError, match=msg):
  105:             np.argsort(idx, kind="mergesort")
  106: 
  107:         msg = "the 'order' parameter is not supported"
  108:         with pytest.raises(ValueError, match=msg):
  109:             np.argsort(idx, order=("a", "b"))
  110: 
  111: 
  112: def test_unsortedindex():
  113:     # GH 11897
  114:     mi = MultiIndex.from_tuples(
  115:         [("z", "a"), ("x", "a"), ("y", "b"), ("x", "b"), ("y", "a"), ("z", "b")],
  116:         names=["one", "two"],
  117:     )
  118:     df = DataFrame([[i, 10 * i] for i in range(6)], index=mi, columns=["one", "two"])
  119: 
  120:     # GH 16734: not sorted, but no real slicing
  121:     result = df.loc(axis=0)["z", "a"]
  122:     expected = df.iloc[0]
  123:     tm.assert_series_equal(result, expected)
  124: 
  125:     msg = (
  126:         "MultiIndex slicing requires the index to be lexsorted: "
  127:         r"slicing on levels \[1\], lexsort depth 0"
  128:     )
  129:     with pytest.raises(UnsortedIndexError, match=msg):
  130:         df.loc(axis=0)["z", slice("a")]
  131:     df.sort_index(inplace=True)
  132:     assert len(df.loc(axis=0)["z", :]) == 2
  133: 
  134:     with pytest.raises(KeyError, match="'q'"):
  135:         df.loc(axis=0)["q", :]
  136: 
  137: 
  138: def test_unsortedindex_doc_examples():
  139:     # https://pandas.pydata.org/pandas-docs/stable/advanced.html#sorting-a-multiindex
  140:     dfm = DataFrame(
  141:         {
  142:             "jim": [0, 0, 1, 1],
  143:             "joe": ["x", "x", "z", "y"],
  144:             "jolie": np.random.default_rng(2).random(4),
  145:         }
  146:     )
  147: 
  148:     dfm = dfm.set_index(["jim", "joe"])
  149:     with tm.assert_produces_warning(PerformanceWarning):
  150:         dfm.loc[(1, "z")]
  151: 
  152:     msg = r"Key length \(2\) was greater than MultiIndex lexsort depth \(1\)"
  153:     with pytest.raises(UnsortedIndexError, match=msg):
  154:         dfm.loc[(0, "y"):(1, "z")]
  155: 
  156:     assert not dfm.index._is_lexsorted()
  157:     assert dfm.index._lexsort_depth == 1
  158: 
  159:     # sort it
  160:     dfm = dfm.sort_index()
  161:     dfm.loc[(1, "z")]
  162:     dfm.loc[(0, "y"):(1, "z")]
  163: 
  164:     assert dfm.index._is_lexsorted()
  165:     assert dfm.index._lexsort_depth == 2
  166: 
  167: 
  168: def test_reconstruct_sort():
  169:     # starts off lexsorted & monotonic
  170:     mi = MultiIndex.from_arrays([["A", "A", "B", "B", "B"], [1, 2, 1, 2, 3]])
  171:     assert mi.is_monotonic_increasing
  172:     recons = mi._sort_levels_monotonic()
  173:     assert recons.is_monotonic_increasing
  174:     assert mi is recons
  175: 
  176:     assert mi.equals(recons)
  177:     assert Index(mi.values).equals(Index(recons.values))
  178: 
  179:     # cannot convert to lexsorted
  180:     mi = MultiIndex.from_tuples(
  181:         [("z", "a"), ("x", "a"), ("y", "b"), ("x", "b"), ("y", "a"), ("z", "b")],
  182:         names=["one", "two"],
  183:     )
  184:     assert not mi.is_monotonic_increasing
  185:     recons = mi._sort_levels_monotonic()
  186:     assert not recons.is_monotonic_increasing
  187:     assert mi.equals(recons)
  188:     assert Index(mi.values).equals(Index(recons.values))
  189: 
  190:     # cannot convert to lexsorted
  191:     mi = MultiIndex(
  192:         levels=[["b", "d", "a"], [1, 2, 3]],
  193:         codes=[[0, 1, 0, 2], [2, 0, 0, 1]],
  194:         names=["col1", "col2"],
  195:     )
  196:     assert not mi.is_monotonic_increasing
  197:     recons = mi._sort_levels_monotonic()
  198:     assert not recons.is_monotonic_increasing
  199:     assert mi.equals(recons)
  200:     assert Index(mi.values).equals(Index(recons.values))
  201: 
  202: 
  203: def test_reconstruct_remove_unused():
  204:     # xref to GH 2770
  205:     df = DataFrame(
  206:         [["deleteMe", 1, 9], ["keepMe", 2, 9], ["keepMeToo", 3, 9]],
  207:         columns=["first", "second", "third"],
  208:     )
  209:     df2 = df.set_index(["first", "second"], drop=False)
  210:     df2 = df2[df2["first"] != "deleteMe"]
  211: 
  212:     # removed levels are there
  213:     expected = MultiIndex(
  214:         levels=[["deleteMe", "keepMe", "keepMeToo"], [1, 2, 3]],
  215:         codes=[[1, 2], [1, 2]],
  216:         names=["first", "second"],
  217:     )
  218:     result = df2.index
  219:     tm.assert_index_equal(result, expected)
  220: 
  221:     expected = MultiIndex(
  222:         levels=[["keepMe", "keepMeToo"], [2, 3]],
  223:         codes=[[0, 1], [0, 1]],
  224:         names=["first", "second"],
  225:     )
  226:     result = df2.index.remove_unused_levels()
  227:     tm.assert_index_equal(result, expected)
  228: 
  229:     # idempotent
  230:     result2 = result.remove_unused_levels()
  231:     tm.assert_index_equal(result2, expected)
  232:     assert result2.is_(result)
  233: 
  234: 
  235: @pytest.mark.parametrize(
  236:     "first_type,second_type", [("int64", "int64"), ("datetime64[D]", "str")]
  237: )
  238: def test_remove_unused_levels_large(first_type, second_type):
  239:     # GH16556
  240: 
  241:     # because tests should be deterministic (and this test in particular
  242:     # checks that levels are removed, which is not the case for every
  243:     # random input):
  244:     rng = np.random.default_rng(10)  # seed is arbitrary value that works
  245: 
  246:     size = 1 << 16
  247:     df = DataFrame(
  248:         {
  249:             "first": rng.integers(0, 1 << 13, size).astype(first_type),
  250:             "second": rng.integers(0, 1 << 10, size).astype(second_type),
  251:             "third": rng.random(size),
  252:         }
  253:     )
  254:     df = df.groupby(["first", "second"]).sum()
  255:     df = df[df.third < 0.1]
  256: 
  257:     result = df.index.remove_unused_levels()
  258:     assert len(result.levels[0]) < len(df.index.levels[0])
  259:     assert len(result.levels[1]) < len(df.index.levels[1])
  260:     assert result.equals(df.index)
  261: 
  262:     expected = df.reset_index().set_index(["first", "second"]).index
  263:     tm.assert_index_equal(result, expected)
  264: 
  265: 
  266: @pytest.mark.parametrize("level0", [["a", "d", "b"], ["a", "d", "b", "unused"]])
  267: @pytest.mark.parametrize(
  268:     "level1", [["w", "x", "y", "z"], ["w", "x", "y", "z", "unused"]]
  269: )
  270: def test_remove_unused_nan(level0, level1):
  271:     # GH 18417
  272:     mi = MultiIndex(levels=[level0, level1], codes=[[0, 2, -1, 1, -1], [0, 1, 2, 3, 2]])
  273: 
  274:     result = mi.remove_unused_levels()
  275:     tm.assert_index_equal(result, mi)
  276:     for level in 0, 1:
  277:         assert "unused" not in result.levels[level]
  278: 
  279: 
  280: def test_argsort(idx):
  281:     result = idx.argsort()
  282:     expected = idx.values.argsort()
  283:     tm.assert_numpy_array_equal(result, expected)
  284: 
  285: 
  286: def test_remove_unused_levels_with_nan():
  287:     # GH 37510
  288:     idx = Index([(1, np.nan), (3, 4)]).rename(["id1", "id2"])
  289:     idx = idx.set_levels(["a", np.nan], level="id1")
  290:     idx = idx.remove_unused_levels()
  291:     result = idx.levels
  292:     expected = FrozenList([["a", np.nan], [4]])
  293:     assert str(result) == str(expected)
  294: 
  295: 
  296: def test_sort_values_nan():
  297:     # GH48495, GH48626
  298:     midx = MultiIndex(levels=[["A", "B", "C"], ["D"]], codes=[[1, 0, 2], [-1, -1, 0]])
  299:     result = midx.sort_values()
  300:     expected = MultiIndex(
  301:         levels=[["A", "B", "C"], ["D"]], codes=[[0, 1, 2], [-1, -1, 0]]
  302:     )
  303:     tm.assert_index_equal(result, expected)
  304: 
  305: 
  306: def test_sort_values_incomparable():
  307:     # GH48495
  308:     mi = MultiIndex.from_arrays(
  309:         [
  310:             [1, Timestamp("2000-01-01")],
  311:             [3, 4],
  312:         ]
  313:     )
  314:     match = "'<' not supported between instances of 'Timestamp' and 'int'"
  315:     with pytest.raises(TypeError, match=match):
  316:         mi.sort_values()
  317: 
  318: 
  319: @pytest.mark.parametrize("na_position", ["first", "last"])
  320: @pytest.mark.parametrize("dtype", ["float64", "Int64", "Float64"])
  321: def test_sort_values_with_na_na_position(dtype, na_position):
  322:     # 51612
  323:     arrays = [
  324:         Series([1, 1, 2], dtype=dtype),
  325:         Series([1, None, 3], dtype=dtype),
  326:     ]
  327:     index = MultiIndex.from_arrays(arrays)
  328:     result = index.sort_values(na_position=na_position)
  329:     if na_position == "first":
  330:         arrays = [
  331:             Series([1, 1, 2], dtype=dtype),
  332:             Series([None, 1, 3], dtype=dtype),
  333:         ]
  334:     else:
  335:         arrays = [
  336:             Series([1, 1, 2], dtype=dtype),
  337:             Series([1, None, 3], dtype=dtype),
  338:         ]
  339:     expected = MultiIndex.from_arrays(arrays)
  340:     tm.assert_index_equal(result, expected)
  341: 
  342: 
  343: def test_sort_unnecessary_warning():
  344:     # GH#55386
  345:     midx = MultiIndex.from_tuples([(1.5, 2), (3.5, 3), (0, 1)])
  346:     midx = midx.set_levels([2.5, np.nan, 1], level=0)
  347:     result = midx.sort_values()
  348:     expected = MultiIndex.from_tuples([(1, 3), (2.5, 1), (np.nan, 2)])
  349:     tm.assert_index_equal(result, expected)
