    1: import numpy as np
    2: import pytest
    3: 
    4: import pandas as pd
    5: from pandas import (
    6:     CategoricalIndex,
    7:     DataFrame,
    8:     Index,
    9:     IntervalIndex,
   10:     MultiIndex,
   11:     Series,
   12: )
   13: import pandas._testing as tm
   14: from pandas.api.types import (
   15:     is_float_dtype,
   16:     is_unsigned_integer_dtype,
   17: )
   18: 
   19: 
   20: @pytest.mark.parametrize("case", [0.5, "xxx"])
   21: @pytest.mark.parametrize(
   22:     "method", ["intersection", "union", "difference", "symmetric_difference"]
   23: )
   24: def test_set_ops_error_cases(idx, case, sort, method):
   25:     # non-iterable input
   26:     msg = "Input must be Index or array-like"
   27:     with pytest.raises(TypeError, match=msg):
   28:         getattr(idx, method)(case, sort=sort)
   29: 
   30: 
   31: @pytest.mark.parametrize("klass", [MultiIndex, np.array, Series, list])
   32: def test_intersection_base(idx, sort, klass):
   33:     first = idx[2::-1]  # first 3 elements reversed
   34:     second = idx[:5]
   35: 
   36:     if klass is not MultiIndex:
   37:         second = klass(second.values)
   38: 
   39:     intersect = first.intersection(second, sort=sort)
   40:     if sort is None:
   41:         expected = first.sort_values()
   42:     else:
   43:         expected = first
   44:     tm.assert_index_equal(intersect, expected)
   45: 
   46:     msg = "other must be a MultiIndex or a list of tuples"
   47:     with pytest.raises(TypeError, match=msg):
   48:         first.intersection([1, 2, 3], sort=sort)
   49: 
   50: 
   51: @pytest.mark.arm_slow
   52: @pytest.mark.parametrize("klass", [MultiIndex, np.array, Series, list])
   53: def test_union_base(idx, sort, klass):
   54:     first = idx[::-1]
   55:     second = idx[:5]
   56: 
   57:     if klass is not MultiIndex:
   58:         second = klass(second.values)
   59: 
   60:     union = first.union(second, sort=sort)
   61:     if sort is None:
   62:         expected = first.sort_values()
   63:     else:
   64:         expected = first
   65:     tm.assert_index_equal(union, expected)
   66: 
   67:     msg = "other must be a MultiIndex or a list of tuples"
   68:     with pytest.raises(TypeError, match=msg):
   69:         first.union([1, 2, 3], sort=sort)
   70: 
   71: 
   72: def test_difference_base(idx, sort):
   73:     second = idx[4:]
   74:     answer = idx[:4]
   75:     result = idx.difference(second, sort=sort)
   76: 
   77:     if sort is None:
   78:         answer = answer.sort_values()
   79: 
   80:     assert result.equals(answer)
   81:     tm.assert_index_equal(result, answer)
   82: 
   83:     # GH 10149
   84:     cases = [klass(second.values) for klass in [np.array, Series, list]]
   85:     for case in cases:
   86:         result = idx.difference(case, sort=sort)
   87:         tm.assert_index_equal(result, answer)
   88: 
   89:     msg = "other must be a MultiIndex or a list of tuples"
   90:     with pytest.raises(TypeError, match=msg):
   91:         idx.difference([1, 2, 3], sort=sort)
   92: 
   93: 
   94: def test_symmetric_difference(idx, sort):
   95:     first = idx[1:]
   96:     second = idx[:-1]
   97:     answer = idx[[-1, 0]]
   98:     result = first.symmetric_difference(second, sort=sort)
   99: 
  100:     if sort is None:
  101:         answer = answer.sort_values()
  102: 
  103:     tm.assert_index_equal(result, answer)
  104: 
  105:     # GH 10149
  106:     cases = [klass(second.values) for klass in [np.array, Series, list]]
  107:     for case in cases:
  108:         result = first.symmetric_difference(case, sort=sort)
  109:         tm.assert_index_equal(result, answer)
  110: 
  111:     msg = "other must be a MultiIndex or a list of tuples"
  112:     with pytest.raises(TypeError, match=msg):
  113:         first.symmetric_difference([1, 2, 3], sort=sort)
  114: 
  115: 
  116: def test_multiindex_symmetric_difference():
  117:     # GH 13490
  118:     idx = MultiIndex.from_product([["a", "b"], ["A", "B"]], names=["a", "b"])
  119:     result = idx.symmetric_difference(idx)
  120:     assert result.names == idx.names
  121: 
  122:     idx2 = idx.copy().rename(["A", "B"])
  123:     result = idx.symmetric_difference(idx2)
  124:     assert result.names == [None, None]
  125: 
  126: 
  127: def test_empty(idx):
  128:     # GH 15270
  129:     assert not idx.empty
  130:     assert idx[:0].empty
  131: 
  132: 
  133: def test_difference(idx, sort):
  134:     first = idx
  135:     result = first.difference(idx[-3:], sort=sort)
  136:     vals = idx[:-3].values
  137: 
  138:     if sort is None:
  139:         vals = sorted(vals)
  140: 
  141:     expected = MultiIndex.from_tuples(vals, sortorder=0, names=idx.names)
  142: 
  143:     assert isinstance(result, MultiIndex)
  144:     assert result.equals(expected)
  145:     assert result.names == idx.names
  146:     tm.assert_index_equal(result, expected)
  147: 
  148:     # empty difference: reflexive
  149:     result = idx.difference(idx, sort=sort)
  150:     expected = idx[:0]
  151:     assert result.equals(expected)
  152:     assert result.names == idx.names
  153: 
  154:     # empty difference: superset
  155:     result = idx[-3:].difference(idx, sort=sort)
  156:     expected = idx[:0]
  157:     assert result.equals(expected)
  158:     assert result.names == idx.names
  159: 
  160:     # empty difference: degenerate
  161:     result = idx[:0].difference(idx, sort=sort)
  162:     expected = idx[:0]
  163:     assert result.equals(expected)
  164:     assert result.names == idx.names
  165: 
  166:     # names not the same
  167:     chunklet = idx[-3:]
  168:     chunklet.names = ["foo", "baz"]
  169:     result = first.difference(chunklet, sort=sort)
  170:     assert result.names == (None, None)
  171: 
  172:     # empty, but non-equal
  173:     result = idx.difference(idx.sortlevel(1)[0], sort=sort)
  174:     assert len(result) == 0
  175: 
  176:     # raise Exception called with non-MultiIndex
  177:     result = first.difference(first.values, sort=sort)
  178:     assert result.equals(first[:0])
  179: 
  180:     # name from empty array
  181:     result = first.difference([], sort=sort)
  182:     assert first.equals(result)
  183:     assert first.names == result.names
  184: 
  185:     # name from non-empty array
  186:     result = first.difference([("foo", "one")], sort=sort)
  187:     expected = MultiIndex.from_tuples(
  188:         [("bar", "one"), ("baz", "two"), ("foo", "two"), ("qux", "one"), ("qux", "two")]
  189:     )
  190:     expected.names = first.names
  191:     assert first.names == result.names
  192: 
  193:     msg = "other must be a MultiIndex or a list of tuples"
  194:     with pytest.raises(TypeError, match=msg):
  195:         first.difference([1, 2, 3, 4, 5], sort=sort)
  196: 
  197: 
  198: def test_difference_sort_special():
  199:     # GH-24959
  200:     idx = MultiIndex.from_product([[1, 0], ["a", "b"]])
  201:     # sort=None, the default
  202:     result = idx.difference([])
  203:     tm.assert_index_equal(result, idx)
  204: 
  205: 
  206: def test_difference_sort_special_true():
  207:     idx = MultiIndex.from_product([[1, 0], ["a", "b"]])
  208:     result = idx.difference([], sort=True)
  209:     expected = MultiIndex.from_product([[0, 1], ["a", "b"]])
  210:     tm.assert_index_equal(result, expected)
  211: 
  212: 
  213: def test_difference_sort_incomparable():
  214:     # GH-24959
  215:     idx = MultiIndex.from_product([[1, pd.Timestamp("2000"), 2], ["a", "b"]])
  216: 
  217:     other = MultiIndex.from_product([[3, pd.Timestamp("2000"), 4], ["c", "d"]])
  218:     # sort=None, the default
  219:     msg = "sort order is undefined for incomparable objects"
  220:     with tm.assert_produces_warning(RuntimeWarning, match=msg):
  221:         result = idx.difference(other)
  222:     tm.assert_index_equal(result, idx)
  223: 
  224:     # sort=False
  225:     result = idx.difference(other, sort=False)
  226:     tm.assert_index_equal(result, idx)
  227: 
  228: 
  229: def test_difference_sort_incomparable_true():
  230:     idx = MultiIndex.from_product([[1, pd.Timestamp("2000"), 2], ["a", "b"]])
  231:     other = MultiIndex.from_product([[3, pd.Timestamp("2000"), 4], ["c", "d"]])
  232: 
  233:     # TODO: this is raising in constructing a Categorical when calling
  234:     #  algos.safe_sort. Should we catch and re-raise with a better message?
  235:     msg = "'values' is not ordered, please explicitly specify the categories order "
  236:     with pytest.raises(TypeError, match=msg):
  237:         idx.difference(other, sort=True)
  238: 
  239: 
  240: def test_union(idx, sort):
  241:     piece1 = idx[:5][::-1]
  242:     piece2 = idx[3:]
  243: 
  244:     the_union = piece1.union(piece2, sort=sort)
  245: 
  246:     if sort in (None, False):
  247:         tm.assert_index_equal(the_union.sort_values(), idx.sort_values())
  248:     else:
  249:         tm.assert_index_equal(the_union, idx)
  250: 
  251:     # corner case, pass self or empty thing:
  252:     the_union = idx.union(idx, sort=sort)
  253:     tm.assert_index_equal(the_union, idx)
  254: 
  255:     the_union = idx.union(idx[:0], sort=sort)
  256:     tm.assert_index_equal(the_union, idx)
  257: 
  258:     tuples = idx.values
  259:     result = idx[:4].union(tuples[4:], sort=sort)
  260:     if sort is None:
  261:         tm.assert_index_equal(result.sort_values(), idx.sort_values())
  262:     else:
  263:         assert result.equals(idx)
  264: 
  265: 
  266: def test_union_with_regular_index(idx, using_infer_string):
  267:     other = Index(["A", "B", "C"])
  268: 
  269:     result = other.union(idx)
  270:     assert ("foo", "one") in result
  271:     assert "B" in result
  272: 
  273:     if using_infer_string:
  274:         with pytest.raises(NotImplementedError, match="Can only union"):
  275:             idx.union(other)
  276:     else:
  277:         msg = "The values in the array are unorderable"
  278:         with tm.assert_produces_warning(RuntimeWarning, match=msg):
  279:             result2 = idx.union(other)
  280:         # This is more consistent now, if sorting fails then we don't sort at all
  281:         # in the MultiIndex case.
  282:         assert not result.equals(result2)
  283: 
  284: 
  285: def test_intersection(idx, sort):
  286:     piece1 = idx[:5][::-1]
  287:     piece2 = idx[3:]
  288: 
  289:     the_int = piece1.intersection(piece2, sort=sort)
  290: 
  291:     if sort in (None, True):
  292:         tm.assert_index_equal(the_int, idx[3:5])
  293:     else:
  294:         tm.assert_index_equal(the_int.sort_values(), idx[3:5])
  295: 
  296:     # corner case, pass self
  297:     the_int = idx.intersection(idx, sort=sort)
  298:     tm.assert_index_equal(the_int, idx)
  299: 
  300:     # empty intersection: disjoint
  301:     empty = idx[:2].intersection(idx[2:], sort=sort)
  302:     expected = idx[:0]
  303:     assert empty.equals(expected)
  304: 
  305:     tuples = idx.values
  306:     result = idx.intersection(tuples)
  307:     assert result.equals(idx)
  308: 
  309: 
  310: @pytest.mark.parametrize(
  311:     "method", ["intersection", "union", "difference", "symmetric_difference"]
  312: )
  313: def test_setop_with_categorical(idx, sort, method):
  314:     other = idx.to_flat_index().astype("category")
  315:     res_names = [None] * idx.nlevels
  316: 
  317:     result = getattr(idx, method)(other, sort=sort)
  318:     expected = getattr(idx, method)(idx, sort=sort).rename(res_names)
  319:     tm.assert_index_equal(result, expected)
  320: 
  321:     result = getattr(idx, method)(other[:5], sort=sort)
  322:     expected = getattr(idx, method)(idx[:5], sort=sort).rename(res_names)
  323:     tm.assert_index_equal(result, expected)
  324: 
  325: 
  326: def test_intersection_non_object(idx, sort):
  327:     other = Index(range(3), name="foo")
  328: 
  329:     result = idx.intersection(other, sort=sort)
  330:     expected = MultiIndex(levels=idx.levels, codes=[[]] * idx.nlevels, names=None)
  331:     tm.assert_index_equal(result, expected, exact=True)
  332: 
  333:     # if we pass a length-0 ndarray (i.e. no name, we retain our idx.name)
  334:     result = idx.intersection(np.asarray(other)[:0], sort=sort)
  335:     expected = MultiIndex(levels=idx.levels, codes=[[]] * idx.nlevels, names=idx.names)
  336:     tm.assert_index_equal(result, expected, exact=True)
  337: 
  338:     msg = "other must be a MultiIndex or a list of tuples"
  339:     with pytest.raises(TypeError, match=msg):
  340:         # With non-zero length non-index, we try and fail to convert to tuples
  341:         idx.intersection(np.asarray(other), sort=sort)
  342: 
  343: 
  344: def test_intersect_equal_sort():
  345:     # GH-24959
  346:     idx = MultiIndex.from_product([[1, 0], ["a", "b"]])
  347:     tm.assert_index_equal(idx.intersection(idx, sort=False), idx)
  348:     tm.assert_index_equal(idx.intersection(idx, sort=None), idx)
  349: 
  350: 
  351: def test_intersect_equal_sort_true():
  352:     idx = MultiIndex.from_product([[1, 0], ["a", "b"]])
  353:     expected = MultiIndex.from_product([[0, 1], ["a", "b"]])
  354:     result = idx.intersection(idx, sort=True)
  355:     tm.assert_index_equal(result, expected)
  356: 
  357: 
  358: @pytest.mark.parametrize("slice_", [slice(None), slice(0)])
  359: def test_union_sort_other_empty(slice_):
  360:     # https://github.com/pandas-dev/pandas/issues/24959
  361:     idx = MultiIndex.from_product([[1, 0], ["a", "b"]])
  362: 
  363:     # default, sort=None
  364:     other = idx[slice_]
  365:     tm.assert_index_equal(idx.union(other), idx)
  366:     tm.assert_index_equal(other.union(idx), idx)
  367: 
  368:     # sort=False
  369:     tm.assert_index_equal(idx.union(other, sort=False), idx)
  370: 
  371: 
  372: def test_union_sort_other_empty_sort():
  373:     idx = MultiIndex.from_product([[1, 0], ["a", "b"]])
  374:     other = idx[:0]
  375:     result = idx.union(other, sort=True)
  376:     expected = MultiIndex.from_product([[0, 1], ["a", "b"]])
  377:     tm.assert_index_equal(result, expected)
  378: 
  379: 
  380: def test_union_sort_other_incomparable():
  381:     # https://github.com/pandas-dev/pandas/issues/24959
  382:     idx = MultiIndex.from_product([[1, pd.Timestamp("2000")], ["a", "b"]])
  383: 
  384:     # default, sort=None
  385:     with tm.assert_produces_warning(RuntimeWarning):
  386:         result = idx.union(idx[:1])
  387:     tm.assert_index_equal(result, idx)
  388: 
  389:     # sort=False
  390:     result = idx.union(idx[:1], sort=False)
  391:     tm.assert_index_equal(result, idx)
  392: 
  393: 
  394: def test_union_sort_other_incomparable_sort():
  395:     idx = MultiIndex.from_product([[1, pd.Timestamp("2000")], ["a", "b"]])
  396:     msg = "'<' not supported between instances of 'Timestamp' and 'int'"
  397:     with pytest.raises(TypeError, match=msg):
  398:         idx.union(idx[:1], sort=True)
  399: 
  400: 
  401: def test_union_non_object_dtype_raises():
  402:     # GH#32646 raise NotImplementedError instead of less-informative error
  403:     mi = MultiIndex.from_product([["a", "b"], [1, 2]])
  404: 
  405:     idx = mi.levels[1]
  406: 
  407:     msg = "Can only union MultiIndex with MultiIndex or Index of tuples"
  408:     with pytest.raises(NotImplementedError, match=msg):
  409:         mi.union(idx)
  410: 
  411: 
  412: def test_union_empty_self_different_names():
  413:     # GH#38423
  414:     mi = MultiIndex.from_arrays([[]])
  415:     mi2 = MultiIndex.from_arrays([[1, 2], [3, 4]], names=["a", "b"])
  416:     result = mi.union(mi2)
  417:     expected = MultiIndex.from_arrays([[1, 2], [3, 4]])
  418:     tm.assert_index_equal(result, expected)
  419: 
  420: 
  421: def test_union_multiindex_empty_rangeindex():
  422:     # GH#41234
  423:     mi = MultiIndex.from_arrays([[1, 2], [3, 4]], names=["a", "b"])
  424:     ri = pd.RangeIndex(0)
  425: 
  426:     result_left = mi.union(ri)
  427:     tm.assert_index_equal(mi, result_left, check_names=False)
  428: 
  429:     result_right = ri.union(mi)
  430:     tm.assert_index_equal(mi, result_right, check_names=False)
  431: 
  432: 
  433: @pytest.mark.parametrize(
  434:     "method", ["union", "intersection", "difference", "symmetric_difference"]
  435: )
  436: def test_setops_sort_validation(method):
  437:     idx1 = MultiIndex.from_product([["a", "b"], [1, 2]])
  438:     idx2 = MultiIndex.from_product([["b", "c"], [1, 2]])
  439: 
  440:     with pytest.raises(ValueError, match="The 'sort' keyword only takes"):
  441:         getattr(idx1, method)(idx2, sort=2)
  442: 
  443:     # sort=True is supported as of GH#?
  444:     getattr(idx1, method)(idx2, sort=True)
  445: 
  446: 
  447: @pytest.mark.parametrize("val", [pd.NA, 100])
  448: def test_difference_keep_ea_dtypes(any_numeric_ea_dtype, val):
  449:     # GH#48606
  450:     midx = MultiIndex.from_arrays(
  451:         [Series([1, 2], dtype=any_numeric_ea_dtype), [2, 1]], names=["a", None]
  452:     )
  453:     midx2 = MultiIndex.from_arrays(
  454:         [Series([1, 2, val], dtype=any_numeric_ea_dtype), [1, 1, 3]]
  455:     )
  456:     result = midx.difference(midx2)
  457:     expected = MultiIndex.from_arrays([Series([1], dtype=any_numeric_ea_dtype), [2]])
  458:     tm.assert_index_equal(result, expected)
  459: 
  460:     result = midx.difference(midx.sort_values(ascending=False))
  461:     expected = MultiIndex.from_arrays(
  462:         [Series([], dtype=any_numeric_ea_dtype), Series([], dtype=np.int64)],
  463:         names=["a", None],
  464:     )
  465:     tm.assert_index_equal(result, expected)
  466: 
  467: 
  468: @pytest.mark.parametrize("val", [pd.NA, 5])
  469: def test_symmetric_difference_keeping_ea_dtype(any_numeric_ea_dtype, val):
  470:     # GH#48607
  471:     midx = MultiIndex.from_arrays(
  472:         [Series([1, 2], dtype=any_numeric_ea_dtype), [2, 1]], names=["a", None]
  473:     )
  474:     midx2 = MultiIndex.from_arrays(
  475:         [Series([1, 2, val], dtype=any_numeric_ea_dtype), [1, 1, 3]]
  476:     )
  477:     result = midx.symmetric_difference(midx2)
  478:     expected = MultiIndex.from_arrays(
  479:         [Series([1, 1, val], dtype=any_numeric_ea_dtype), [1, 2, 3]]
  480:     )
  481:     tm.assert_index_equal(result, expected)
  482: 
  483: 
  484: @pytest.mark.parametrize(
  485:     ("tuples", "exp_tuples"),
  486:     [
  487:         ([("val1", "test1")], [("val1", "test1")]),
  488:         ([("val1", "test1"), ("val1", "test1")], [("val1", "test1")]),
  489:         (
  490:             [("val2", "test2"), ("val1", "test1")],
  491:             [("val2", "test2"), ("val1", "test1")],
  492:         ),
  493:     ],
  494: )
  495: def test_intersect_with_duplicates(tuples, exp_tuples):
  496:     # GH#36915
  497:     left = MultiIndex.from_tuples(tuples, names=["first", "second"])
  498:     right = MultiIndex.from_tuples(
  499:         [("val1", "test1"), ("val1", "test1"), ("val2", "test2")],
  500:         names=["first", "second"],
  501:     )
  502:     result = left.intersection(right)
  503:     expected = MultiIndex.from_tuples(exp_tuples, names=["first", "second"])
  504:     tm.assert_index_equal(result, expected)
  505: 
  506: 
  507: @pytest.mark.parametrize(
  508:     "data, names, expected",
  509:     [
  510:         ((1,), None, [None, None]),
  511:         ((1,), ["a"], [None, None]),
  512:         ((1,), ["b"], [None, None]),
  513:         ((1, 2), ["c", "d"], [None, None]),
  514:         ((1, 2), ["b", "a"], [None, None]),
  515:         ((1, 2, 3), ["a", "b", "c"], [None, None]),
  516:         ((1, 2), ["a", "c"], ["a", None]),
  517:         ((1, 2), ["c", "b"], [None, "b"]),
  518:         ((1, 2), ["a", "b"], ["a", "b"]),
  519:         ((1, 2), [None, "b"], [None, "b"]),
  520:     ],
  521: )
  522: def test_maybe_match_names(data, names, expected):
  523:     # GH#38323
  524:     mi = MultiIndex.from_tuples([], names=["a", "b"])
  525:     mi2 = MultiIndex.from_tuples([data], names=names)
  526:     result = mi._maybe_match_names(mi2)
  527:     assert result == expected
  528: 
  529: 
  530: def test_intersection_equal_different_names():
  531:     # GH#30302
  532:     mi1 = MultiIndex.from_arrays([[1, 2], [3, 4]], names=["c", "b"])
  533:     mi2 = MultiIndex.from_arrays([[1, 2], [3, 4]], names=["a", "b"])
  534: 
  535:     result = mi1.intersection(mi2)
  536:     expected = MultiIndex.from_arrays([[1, 2], [3, 4]], names=[None, "b"])
  537:     tm.assert_index_equal(result, expected)
  538: 
  539: 
  540: def test_intersection_different_names():
  541:     # GH#38323
  542:     mi = MultiIndex.from_arrays([[1], [3]], names=["c", "b"])
  543:     mi2 = MultiIndex.from_arrays([[1], [3]])
  544:     result = mi.intersection(mi2)
  545:     tm.assert_index_equal(result, mi2)
  546: 
  547: 
  548: def test_intersection_with_missing_values_on_both_sides(nulls_fixture):
  549:     # GH#38623
  550:     mi1 = MultiIndex.from_arrays([[3, nulls_fixture, 4, nulls_fixture], [1, 2, 4, 2]])
  551:     mi2 = MultiIndex.from_arrays([[3, nulls_fixture, 3], [1, 2, 4]])
  552:     result = mi1.intersection(mi2)
  553:     expected = MultiIndex.from_arrays([[3, nulls_fixture], [1, 2]])
  554:     tm.assert_index_equal(result, expected)
  555: 
  556: 
  557: def test_union_with_missing_values_on_both_sides(nulls_fixture):
  558:     # GH#38623
  559:     mi1 = MultiIndex.from_arrays([[1, nulls_fixture]])
  560:     mi2 = MultiIndex.from_arrays([[1, nulls_fixture, 3]])
  561:     result = mi1.union(mi2)
  562:     expected = MultiIndex.from_arrays([[1, 3, nulls_fixture]])
  563:     tm.assert_index_equal(result, expected)
  564: 
  565: 
  566: @pytest.mark.parametrize("dtype", ["float64", "Float64"])
  567: @pytest.mark.parametrize("sort", [None, False])
  568: def test_union_nan_got_duplicated(dtype, sort):
  569:     # GH#38977, GH#49010
  570:     mi1 = MultiIndex.from_arrays([pd.array([1.0, np.nan], dtype=dtype), [2, 3]])
  571:     mi2 = MultiIndex.from_arrays([pd.array([1.0, np.nan, 3.0], dtype=dtype), [2, 3, 4]])
  572:     result = mi1.union(mi2, sort=sort)
  573:     if sort is None:
  574:         expected = MultiIndex.from_arrays(
  575:             [pd.array([1.0, 3.0, np.nan], dtype=dtype), [2, 4, 3]]
  576:         )
  577:     else:
  578:         expected = mi2
  579:     tm.assert_index_equal(result, expected)
  580: 
  581: 
  582: @pytest.mark.parametrize("val", [4, 1])
  583: def test_union_keep_ea_dtype(any_numeric_ea_dtype, val):
  584:     # GH#48505
  585: 
  586:     arr1 = Series([val, 2], dtype=any_numeric_ea_dtype)
  587:     arr2 = Series([2, 1], dtype=any_numeric_ea_dtype)
  588:     midx = MultiIndex.from_arrays([arr1, [1, 2]], names=["a", None])
  589:     midx2 = MultiIndex.from_arrays([arr2, [2, 1]])
  590:     result = midx.union(midx2)
  591:     if val == 4:
  592:         expected = MultiIndex.from_arrays(
  593:             [Series([1, 2, 4], dtype=any_numeric_ea_dtype), [1, 2, 1]]
  594:         )
  595:     else:
  596:         expected = MultiIndex.from_arrays(
  597:             [Series([1, 2], dtype=any_numeric_ea_dtype), [1, 2]]
  598:         )
  599:     tm.assert_index_equal(result, expected)
  600: 
  601: 
  602: @pytest.mark.parametrize("dupe_val", [3, pd.NA])
  603: def test_union_with_duplicates_keep_ea_dtype(dupe_val, any_numeric_ea_dtype):
  604:     # GH48900
  605:     mi1 = MultiIndex.from_arrays(
  606:         [
  607:             Series([1, dupe_val, 2], dtype=any_numeric_ea_dtype),
  608:             Series([1, dupe_val, 2], dtype=any_numeric_ea_dtype),
  609:         ]
  610:     )
  611:     mi2 = MultiIndex.from_arrays(
  612:         [
  613:             Series([2, dupe_val, dupe_val], dtype=any_numeric_ea_dtype),
  614:             Series([2, dupe_val, dupe_val], dtype=any_numeric_ea_dtype),
  615:         ]
  616:     )
  617:     result = mi1.union(mi2)
  618:     expected = MultiIndex.from_arrays(
  619:         [
  620:             Series([1, 2, dupe_val, dupe_val], dtype=any_numeric_ea_dtype),
  621:             Series([1, 2, dupe_val, dupe_val], dtype=any_numeric_ea_dtype),
  622:         ]
  623:     )
  624:     tm.assert_index_equal(result, expected)
  625: 
  626: 
  627: @pytest.mark.filterwarnings(r"ignore:PeriodDtype\[B\] is deprecated:FutureWarning")
  628: def test_union_duplicates(index, request):
  629:     # GH#38977
  630:     if index.empty or isinstance(index, (IntervalIndex, CategoricalIndex)):
  631:         pytest.skip(f"No duplicates in an empty {type(index).__name__}")
  632: 
  633:     values = index.unique().values.tolist()
  634:     mi1 = MultiIndex.from_arrays([values, [1] * len(values)])
  635:     mi2 = MultiIndex.from_arrays([[values[0]] + values, [1] * (len(values) + 1)])
  636:     result = mi2.union(mi1)
  637:     expected = mi2.sort_values()
  638:     tm.assert_index_equal(result, expected)
  639: 
  640:     if (
  641:         is_unsigned_integer_dtype(mi2.levels[0])
  642:         and (mi2.get_level_values(0) < 2**63).all()
  643:     ):
  644:         # GH#47294 - union uses lib.fast_zip, converting data to Python integers
  645:         # and loses type information. Result is then unsigned only when values are
  646:         # sufficiently large to require unsigned dtype. This happens only if other
  647:         # has dups or one of both have missing values
  648:         expected = expected.set_levels(
  649:             [expected.levels[0].astype(np.int64), expected.levels[1]]
  650:         )
  651:     elif is_float_dtype(mi2.levels[0]):
  652:         # mi2 has duplicates witch is a different path than above, Fix that path
  653:         # to use correct float dtype?
  654:         expected = expected.set_levels(
  655:             [expected.levels[0].astype(float), expected.levels[1]]
  656:         )
  657: 
  658:     result = mi1.union(mi2)
  659:     tm.assert_index_equal(result, expected)
  660: 
  661: 
  662: def test_union_keep_dtype_precision(any_real_numeric_dtype):
  663:     # GH#48498
  664:     arr1 = Series([4, 1, 1], dtype=any_real_numeric_dtype)
  665:     arr2 = Series([1, 4], dtype=any_real_numeric_dtype)
  666:     midx = MultiIndex.from_arrays([arr1, [2, 1, 1]], names=["a", None])
  667:     midx2 = MultiIndex.from_arrays([arr2, [1, 2]], names=["a", None])
  668: 
  669:     result = midx.union(midx2)
  670:     expected = MultiIndex.from_arrays(
  671:         ([Series([1, 1, 4], dtype=any_real_numeric_dtype), [1, 1, 2]]),
  672:         names=["a", None],
  673:     )
  674:     tm.assert_index_equal(result, expected)
  675: 
  676: 
  677: def test_union_keep_ea_dtype_with_na(any_numeric_ea_dtype):
  678:     # GH#48498
  679:     arr1 = Series([4, pd.NA], dtype=any_numeric_ea_dtype)
  680:     arr2 = Series([1, pd.NA], dtype=any_numeric_ea_dtype)
  681:     midx = MultiIndex.from_arrays([arr1, [2, 1]], names=["a", None])
  682:     midx2 = MultiIndex.from_arrays([arr2, [1, 2]])
  683:     result = midx.union(midx2)
  684:     expected = MultiIndex.from_arrays(
  685:         [Series([1, 4, pd.NA, pd.NA], dtype=any_numeric_ea_dtype), [1, 2, 1, 2]]
  686:     )
  687:     tm.assert_index_equal(result, expected)
  688: 
  689: 
  690: @pytest.mark.parametrize(
  691:     "levels1, levels2, codes1, codes2, names",
  692:     [
  693:         (
  694:             [["a", "b", "c"], [0, ""]],
  695:             [["c", "d", "b"], [""]],
  696:             [[0, 1, 2], [1, 1, 1]],
  697:             [[0, 1, 2], [0, 0, 0]],
  698:             ["name1", "name2"],
  699:         ),
  700:     ],
  701: )
  702: def test_intersection_lexsort_depth(levels1, levels2, codes1, codes2, names):
  703:     # GH#25169
  704:     mi1 = MultiIndex(levels=levels1, codes=codes1, names=names)
  705:     mi2 = MultiIndex(levels=levels2, codes=codes2, names=names)
  706:     mi_int = mi1.intersection(mi2)
  707:     assert mi_int._lexsort_depth == 2
  708: 
  709: 
  710: @pytest.mark.parametrize(
  711:     "a",
  712:     [pd.Categorical(["a", "b"], categories=["a", "b"]), ["a", "b"]],
  713: )
  714: @pytest.mark.parametrize(
  715:     "b",
  716:     [
  717:         pd.Categorical(["a", "b"], categories=["b", "a"], ordered=True),
  718:         pd.Categorical(["a", "b"], categories=["b", "a"]),
  719:     ],
  720: )
  721: def test_intersection_with_non_lex_sorted_categories(a, b):
  722:     # GH#49974
  723:     other = ["1", "2"]
  724: 
  725:     df1 = DataFrame({"x": a, "y": other})
  726:     df2 = DataFrame({"x": b, "y": other})
  727: 
  728:     expected = MultiIndex.from_arrays([a, other], names=["x", "y"])
  729: 
  730:     res1 = MultiIndex.from_frame(df1).intersection(
  731:         MultiIndex.from_frame(df2.sort_values(["x", "y"]))
  732:     )
  733:     res2 = MultiIndex.from_frame(df1).intersection(MultiIndex.from_frame(df2))
  734:     res3 = MultiIndex.from_frame(df1.sort_values(["x", "y"])).intersection(
  735:         MultiIndex.from_frame(df2)
  736:     )
  737:     res4 = MultiIndex.from_frame(df1.sort_values(["x", "y"])).intersection(
  738:         MultiIndex.from_frame(df2.sort_values(["x", "y"]))
  739:     )
  740: 
  741:     tm.assert_index_equal(res1, expected)
  742:     tm.assert_index_equal(res2, expected)
  743:     tm.assert_index_equal(res3, expected)
  744:     tm.assert_index_equal(res4, expected)
  745: 
  746: 
  747: @pytest.mark.parametrize("val", [pd.NA, 100])
  748: def test_intersection_keep_ea_dtypes(val, any_numeric_ea_dtype):
  749:     # GH#48604
  750:     midx = MultiIndex.from_arrays(
  751:         [Series([1, 2], dtype=any_numeric_ea_dtype), [2, 1]], names=["a", None]
  752:     )
  753:     midx2 = MultiIndex.from_arrays(
  754:         [Series([1, 2, val], dtype=any_numeric_ea_dtype), [1, 1, 3]]
  755:     )
  756:     result = midx.intersection(midx2)
  757:     expected = MultiIndex.from_arrays([Series([2], dtype=any_numeric_ea_dtype), [1]])
  758:     tm.assert_index_equal(result, expected)
  759: 
  760: 
  761: def test_union_with_na_when_constructing_dataframe():
  762:     # GH43222
  763:     series1 = Series(
  764:         (1,),
  765:         index=MultiIndex.from_arrays(
  766:             [Series([None], dtype="string"), Series([None], dtype="string")]
  767:         ),
  768:     )
  769:     series2 = Series((10, 20), index=MultiIndex.from_tuples(((None, None), ("a", "b"))))
  770:     result = DataFrame([series1, series2])
  771:     expected = DataFrame({(np.nan, np.nan): [1.0, 10.0], ("a", "b"): [np.nan, 20.0]})
  772:     tm.assert_frame_equal(result, expected)
