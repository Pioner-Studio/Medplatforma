    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas.core.dtypes.common import is_any_real_numeric_dtype
    5: 
    6: import pandas as pd
    7: from pandas import (
    8:     Index,
    9:     MultiIndex,
   10:     Series,
   11: )
   12: import pandas._testing as tm
   13: 
   14: 
   15: def test_equals(idx):
   16:     assert idx.equals(idx)
   17:     assert idx.equals(idx.copy())
   18:     assert idx.equals(idx.astype(object))
   19:     assert idx.equals(idx.to_flat_index())
   20:     assert idx.equals(idx.to_flat_index().astype("category"))
   21: 
   22:     assert not idx.equals(list(idx))
   23:     assert not idx.equals(np.array(idx))
   24: 
   25:     same_values = Index(idx, dtype=object)
   26:     assert idx.equals(same_values)
   27:     assert same_values.equals(idx)
   28: 
   29:     if idx.nlevels == 1:
   30:         # do not test MultiIndex
   31:         assert not idx.equals(Series(idx))
   32: 
   33: 
   34: def test_equals_op(idx):
   35:     # GH9947, GH10637
   36:     index_a = idx
   37: 
   38:     n = len(index_a)
   39:     index_b = index_a[0:-1]
   40:     index_c = index_a[0:-1].append(index_a[-2:-1])
   41:     index_d = index_a[0:1]
   42:     with pytest.raises(ValueError, match="Lengths must match"):
   43:         index_a == index_b
   44:     expected1 = np.array([True] * n)
   45:     expected2 = np.array([True] * (n - 1) + [False])
   46:     tm.assert_numpy_array_equal(index_a == index_a, expected1)
   47:     tm.assert_numpy_array_equal(index_a == index_c, expected2)
   48: 
   49:     # test comparisons with numpy arrays
   50:     array_a = np.array(index_a)
   51:     array_b = np.array(index_a[0:-1])
   52:     array_c = np.array(index_a[0:-1].append(index_a[-2:-1]))
   53:     array_d = np.array(index_a[0:1])
   54:     with pytest.raises(ValueError, match="Lengths must match"):
   55:         index_a == array_b
   56:     tm.assert_numpy_array_equal(index_a == array_a, expected1)
   57:     tm.assert_numpy_array_equal(index_a == array_c, expected2)
   58: 
   59:     # test comparisons with Series
   60:     series_a = Series(array_a)
   61:     series_b = Series(array_b)
   62:     series_c = Series(array_c)
   63:     series_d = Series(array_d)
   64:     with pytest.raises(ValueError, match="Lengths must match"):
   65:         index_a == series_b
   66: 
   67:     tm.assert_numpy_array_equal(index_a == series_a, expected1)
   68:     tm.assert_numpy_array_equal(index_a == series_c, expected2)
   69: 
   70:     # cases where length is 1 for one of them
   71:     with pytest.raises(ValueError, match="Lengths must match"):
   72:         index_a == index_d
   73:     with pytest.raises(ValueError, match="Lengths must match"):
   74:         index_a == series_d
   75:     with pytest.raises(ValueError, match="Lengths must match"):
   76:         index_a == array_d
   77:     msg = "Can only compare identically-labeled Series objects"
   78:     with pytest.raises(ValueError, match=msg):
   79:         series_a == series_d
   80:     with pytest.raises(ValueError, match="Lengths must match"):
   81:         series_a == array_d
   82: 
   83:     # comparing with a scalar should broadcast; note that we are excluding
   84:     # MultiIndex because in this case each item in the index is a tuple of
   85:     # length 2, and therefore is considered an array of length 2 in the
   86:     # comparison instead of a scalar
   87:     if not isinstance(index_a, MultiIndex):
   88:         expected3 = np.array([False] * (len(index_a) - 2) + [True, False])
   89:         # assuming the 2nd to last item is unique in the data
   90:         item = index_a[-2]
   91:         tm.assert_numpy_array_equal(index_a == item, expected3)
   92:         tm.assert_series_equal(series_a == item, Series(expected3))
   93: 
   94: 
   95: def test_compare_tuple():
   96:     # GH#21517
   97:     mi = MultiIndex.from_product([[1, 2]] * 2)
   98: 
   99:     all_false = np.array([False, False, False, False])
  100: 
  101:     result = mi == mi[0]
  102:     expected = np.array([True, False, False, False])
  103:     tm.assert_numpy_array_equal(result, expected)
  104: 
  105:     result = mi != mi[0]
  106:     tm.assert_numpy_array_equal(result, ~expected)
  107: 
  108:     result = mi < mi[0]
  109:     tm.assert_numpy_array_equal(result, all_false)
  110: 
  111:     result = mi <= mi[0]
  112:     tm.assert_numpy_array_equal(result, expected)
  113: 
  114:     result = mi > mi[0]
  115:     tm.assert_numpy_array_equal(result, ~expected)
  116: 
  117:     result = mi >= mi[0]
  118:     tm.assert_numpy_array_equal(result, ~all_false)
  119: 
  120: 
  121: def test_compare_tuple_strs():
  122:     # GH#34180
  123: 
  124:     mi = MultiIndex.from_tuples([("a", "b"), ("b", "c"), ("c", "a")])
  125: 
  126:     result = mi == ("c", "a")
  127:     expected = np.array([False, False, True])
  128:     tm.assert_numpy_array_equal(result, expected)
  129: 
  130:     result = mi == ("c",)
  131:     expected = np.array([False, False, False])
  132:     tm.assert_numpy_array_equal(result, expected)
  133: 
  134: 
  135: def test_equals_multi(idx):
  136:     assert idx.equals(idx)
  137:     assert not idx.equals(idx.values)
  138:     assert idx.equals(Index(idx.values))
  139: 
  140:     assert idx.equal_levels(idx)
  141:     assert not idx.equals(idx[:-1])
  142:     assert not idx.equals(idx[-1])
  143: 
  144:     # different number of levels
  145:     index = MultiIndex(
  146:         levels=[Index(list(range(4))), Index(list(range(4))), Index(list(range(4)))],
  147:         codes=[
  148:             np.array([0, 0, 1, 2, 2, 2, 3, 3]),
  149:             np.array([0, 1, 0, 0, 0, 1, 0, 1]),
  150:             np.array([1, 0, 1, 1, 0, 0, 1, 0]),
  151:         ],
  152:     )
  153: 
  154:     index2 = MultiIndex(levels=index.levels[:-1], codes=index.codes[:-1])
  155:     assert not index.equals(index2)
  156:     assert not index.equal_levels(index2)
  157: 
  158:     # levels are different
  159:     major_axis = Index(list(range(4)))
  160:     minor_axis = Index(list(range(2)))
  161: 
  162:     major_codes = np.array([0, 0, 1, 2, 2, 3])
  163:     minor_codes = np.array([0, 1, 0, 0, 1, 0])
  164: 
  165:     index = MultiIndex(
  166:         levels=[major_axis, minor_axis], codes=[major_codes, minor_codes]
  167:     )
  168:     assert not idx.equals(index)
  169:     assert not idx.equal_levels(index)
  170: 
  171:     # some of the labels are different
  172:     major_axis = Index(["foo", "bar", "baz", "qux"])
  173:     minor_axis = Index(["one", "two"])
  174: 
  175:     major_codes = np.array([0, 0, 2, 2, 3, 3])
  176:     minor_codes = np.array([0, 1, 0, 1, 0, 1])
  177: 
  178:     index = MultiIndex(
  179:         levels=[major_axis, minor_axis], codes=[major_codes, minor_codes]
  180:     )
  181:     assert not idx.equals(index)
  182: 
  183: 
  184: def test_identical(idx):
  185:     mi = idx.copy()
  186:     mi2 = idx.copy()
  187:     assert mi.identical(mi2)
  188: 
  189:     mi = mi.set_names(["new1", "new2"])
  190:     assert mi.equals(mi2)
  191:     assert not mi.identical(mi2)
  192: 
  193:     mi2 = mi2.set_names(["new1", "new2"])
  194:     assert mi.identical(mi2)
  195: 
  196:     mi4 = Index(mi.tolist(), tupleize_cols=False)
  197:     assert not mi.identical(mi4)
  198:     assert mi.equals(mi4)
  199: 
  200: 
  201: def test_equals_operator(idx):
  202:     # GH9785
  203:     assert (idx == idx).all()
  204: 
  205: 
  206: def test_equals_missing_values():
  207:     # make sure take is not using -1
  208:     i = MultiIndex.from_tuples([(0, pd.NaT), (0, pd.Timestamp("20130101"))])
  209:     result = i[0:1].equals(i[0])
  210:     assert not result
  211:     result = i[1:2].equals(i[1])
  212:     assert not result
  213: 
  214: 
  215: def test_equals_missing_values_differently_sorted():
  216:     # GH#38439
  217:     mi1 = MultiIndex.from_tuples([(81.0, np.nan), (np.nan, np.nan)])
  218:     mi2 = MultiIndex.from_tuples([(np.nan, np.nan), (81.0, np.nan)])
  219:     assert not mi1.equals(mi2)
  220: 
  221:     mi2 = MultiIndex.from_tuples([(81.0, np.nan), (np.nan, np.nan)])
  222:     assert mi1.equals(mi2)
  223: 
  224: 
  225: def test_is_():
  226:     mi = MultiIndex.from_tuples(zip(range(10), range(10)))
  227:     assert mi.is_(mi)
  228:     assert mi.is_(mi.view())
  229:     assert mi.is_(mi.view().view().view().view())
  230:     mi2 = mi.view()
  231:     # names are metadata, they don't change id
  232:     mi2.names = ["A", "B"]
  233:     assert mi2.is_(mi)
  234:     assert mi.is_(mi2)
  235: 
  236:     assert not mi.is_(mi.set_names(["C", "D"]))
  237:     # levels are inherent properties, they change identity
  238:     mi3 = mi2.set_levels([list(range(10)), list(range(10))])
  239:     assert not mi3.is_(mi2)
  240:     # shouldn't change
  241:     assert mi2.is_(mi)
  242:     mi4 = mi3.view()
  243: 
  244:     # GH 17464 - Remove duplicate MultiIndex levels
  245:     mi4 = mi4.set_levels([list(range(10)), list(range(10))])
  246:     assert not mi4.is_(mi3)
  247:     mi5 = mi.view()
  248:     mi5 = mi5.set_levels(mi5.levels)
  249:     assert not mi5.is_(mi)
  250: 
  251: 
  252: def test_is_all_dates(idx):
  253:     assert not idx._is_all_dates
  254: 
  255: 
  256: def test_is_numeric(idx):
  257:     # MultiIndex is never numeric
  258:     assert not is_any_real_numeric_dtype(idx)
  259: 
  260: 
  261: def test_multiindex_compare():
  262:     # GH 21149
  263:     # Ensure comparison operations for MultiIndex with nlevels == 1
  264:     # behave consistently with those for MultiIndex with nlevels > 1
  265: 
  266:     midx = MultiIndex.from_product([[0, 1]])
  267: 
  268:     # Equality self-test: MultiIndex object vs self
  269:     expected = Series([True, True])
  270:     result = Series(midx == midx)
  271:     tm.assert_series_equal(result, expected)
  272: 
  273:     # Greater than comparison: MultiIndex object vs self
  274:     expected = Series([False, False])
  275:     result = Series(midx > midx)
  276:     tm.assert_series_equal(result, expected)
  277: 
  278: 
  279: def test_equals_ea_int_regular_int():
  280:     # GH#46026
  281:     mi1 = MultiIndex.from_arrays([Index([1, 2], dtype="Int64"), [3, 4]])
  282:     mi2 = MultiIndex.from_arrays([[1, 2], [3, 4]])
  283:     assert not mi1.equals(mi2)
  284:     assert not mi2.equals(mi1)
