    1: from datetime import datetime
    2: import re
    3: 
    4: import numpy as np
    5: import pytest
    6: 
    7: from pandas import (
    8:     Index,
    9:     NaT,
   10:     Timedelta,
   11:     TimedeltaIndex,
   12:     Timestamp,
   13:     notna,
   14:     offsets,
   15:     timedelta_range,
   16:     to_timedelta,
   17: )
   18: import pandas._testing as tm
   19: 
   20: 
   21: class TestGetItem:
   22:     def test_getitem_slice_keeps_name(self):
   23:         # GH#4226
   24:         tdi = timedelta_range("1d", "5d", freq="h", name="timebucket")
   25:         assert tdi[1:].name == tdi.name
   26: 
   27:     def test_getitem(self):
   28:         idx1 = timedelta_range("1 day", "31 day", freq="D", name="idx")
   29: 
   30:         for idx in [idx1]:
   31:             result = idx[0]
   32:             assert result == Timedelta("1 day")
   33: 
   34:             result = idx[0:5]
   35:             expected = timedelta_range("1 day", "5 day", freq="D", name="idx")
   36:             tm.assert_index_equal(result, expected)
   37:             assert result.freq == expected.freq
   38: 
   39:             result = idx[0:10:2]
   40:             expected = timedelta_range("1 day", "9 day", freq="2D", name="idx")
   41:             tm.assert_index_equal(result, expected)
   42:             assert result.freq == expected.freq
   43: 
   44:             result = idx[-20:-5:3]
   45:             expected = timedelta_range("12 day", "24 day", freq="3D", name="idx")
   46:             tm.assert_index_equal(result, expected)
   47:             assert result.freq == expected.freq
   48: 
   49:             result = idx[4::-1]
   50:             expected = TimedeltaIndex(
   51:                 ["5 day", "4 day", "3 day", "2 day", "1 day"], freq="-1D", name="idx"
   52:             )
   53:             tm.assert_index_equal(result, expected)
   54:             assert result.freq == expected.freq
   55: 
   56:     @pytest.mark.parametrize(
   57:         "key",
   58:         [
   59:             Timestamp("1970-01-01"),
   60:             Timestamp("1970-01-02"),
   61:             datetime(1970, 1, 1),
   62:             Timestamp("1970-01-03").to_datetime64(),
   63:             # non-matching NA values
   64:             np.datetime64("NaT"),
   65:         ],
   66:     )
   67:     def test_timestamp_invalid_key(self, key):
   68:         # GH#20464
   69:         tdi = timedelta_range(0, periods=10)
   70:         with pytest.raises(KeyError, match=re.escape(repr(key))):
   71:             tdi.get_loc(key)
   72: 
   73: 
   74: class TestGetLoc:
   75:     def test_get_loc_key_unit_mismatch(self):
   76:         idx = to_timedelta(["0 days", "1 days", "2 days"])
   77:         key = idx[1].as_unit("ms")
   78:         loc = idx.get_loc(key)
   79:         assert loc == 1
   80: 
   81:     def test_get_loc_key_unit_mismatch_not_castable(self):
   82:         tdi = to_timedelta(["0 days", "1 days", "2 days"]).astype("m8[s]")
   83:         assert tdi.dtype == "m8[s]"
   84:         key = tdi[0].as_unit("ns") + Timedelta(1)
   85: 
   86:         with pytest.raises(KeyError, match=r"Timedelta\('0 days 00:00:00.000000001'\)"):
   87:             tdi.get_loc(key)
   88: 
   89:         assert key not in tdi
   90: 
   91:     def test_get_loc(self):
   92:         idx = to_timedelta(["0 days", "1 days", "2 days"])
   93: 
   94:         # GH 16909
   95:         assert idx.get_loc(idx[1].to_timedelta64()) == 1
   96: 
   97:         # GH 16896
   98:         assert idx.get_loc("0 days") == 0
   99: 
  100:     def test_get_loc_nat(self):
  101:         tidx = TimedeltaIndex(["1 days 01:00:00", "NaT", "2 days 01:00:00"])
  102: 
  103:         assert tidx.get_loc(NaT) == 1
  104:         assert tidx.get_loc(None) == 1
  105:         assert tidx.get_loc(float("nan")) == 1
  106:         assert tidx.get_loc(np.nan) == 1
  107: 
  108: 
  109: class TestGetIndexer:
  110:     def test_get_indexer(self):
  111:         idx = to_timedelta(["0 days", "1 days", "2 days"])
  112:         tm.assert_numpy_array_equal(
  113:             idx.get_indexer(idx), np.array([0, 1, 2], dtype=np.intp)
  114:         )
  115: 
  116:         target = to_timedelta(["-1 hour", "12 hours", "1 day 1 hour"])
  117:         tm.assert_numpy_array_equal(
  118:             idx.get_indexer(target, "pad"), np.array([-1, 0, 1], dtype=np.intp)
  119:         )
  120:         tm.assert_numpy_array_equal(
  121:             idx.get_indexer(target, "backfill"), np.array([0, 1, 2], dtype=np.intp)
  122:         )
  123:         tm.assert_numpy_array_equal(
  124:             idx.get_indexer(target, "nearest"), np.array([0, 1, 1], dtype=np.intp)
  125:         )
  126: 
  127:         res = idx.get_indexer(target, "nearest", tolerance=Timedelta("1 hour"))
  128:         tm.assert_numpy_array_equal(res, np.array([0, -1, 1], dtype=np.intp))
  129: 
  130: 
  131: class TestWhere:
  132:     def test_where_doesnt_retain_freq(self):
  133:         tdi = timedelta_range("1 day", periods=3, freq="D", name="idx")
  134:         cond = [True, True, False]
  135:         expected = TimedeltaIndex([tdi[0], tdi[1], tdi[0]], freq=None, name="idx")
  136: 
  137:         result = tdi.where(cond, tdi[::-1])
  138:         tm.assert_index_equal(result, expected)
  139: 
  140:     def test_where_invalid_dtypes(self, fixed_now_ts):
  141:         tdi = timedelta_range("1 day", periods=3, freq="D", name="idx")
  142: 
  143:         tail = tdi[2:].tolist()
  144:         i2 = Index([NaT, NaT] + tail)
  145:         mask = notna(i2)
  146: 
  147:         expected = Index([NaT._value, NaT._value] + tail, dtype=object, name="idx")
  148:         assert isinstance(expected[0], int)
  149:         result = tdi.where(mask, i2.asi8)
  150:         tm.assert_index_equal(result, expected)
  151: 
  152:         ts = i2 + fixed_now_ts
  153:         expected = Index([ts[0], ts[1]] + tail, dtype=object, name="idx")
  154:         result = tdi.where(mask, ts)
  155:         tm.assert_index_equal(result, expected)
  156: 
  157:         per = (i2 + fixed_now_ts).to_period("D")
  158:         expected = Index([per[0], per[1]] + tail, dtype=object, name="idx")
  159:         result = tdi.where(mask, per)
  160:         tm.assert_index_equal(result, expected)
  161: 
  162:         ts = fixed_now_ts
  163:         expected = Index([ts, ts] + tail, dtype=object, name="idx")
  164:         result = tdi.where(mask, ts)
  165:         tm.assert_index_equal(result, expected)
  166: 
  167:     def test_where_mismatched_nat(self):
  168:         tdi = timedelta_range("1 day", periods=3, freq="D", name="idx")
  169:         cond = np.array([True, False, False])
  170: 
  171:         dtnat = np.datetime64("NaT", "ns")
  172:         expected = Index([tdi[0], dtnat, dtnat], dtype=object, name="idx")
  173:         assert expected[2] is dtnat
  174:         result = tdi.where(cond, dtnat)
  175:         tm.assert_index_equal(result, expected)
  176: 
  177: 
  178: class TestTake:
  179:     def test_take(self):
  180:         # GH 10295
  181:         idx1 = timedelta_range("1 day", "31 day", freq="D", name="idx")
  182: 
  183:         for idx in [idx1]:
  184:             result = idx.take([0])
  185:             assert result == Timedelta("1 day")
  186: 
  187:             result = idx.take([-1])
  188:             assert result == Timedelta("31 day")
  189: 
  190:             result = idx.take([0, 1, 2])
  191:             expected = timedelta_range("1 day", "3 day", freq="D", name="idx")
  192:             tm.assert_index_equal(result, expected)
  193:             assert result.freq == expected.freq
  194: 
  195:             result = idx.take([0, 2, 4])
  196:             expected = timedelta_range("1 day", "5 day", freq="2D", name="idx")
  197:             tm.assert_index_equal(result, expected)
  198:             assert result.freq == expected.freq
  199: 
  200:             result = idx.take([7, 4, 1])
  201:             expected = timedelta_range("8 day", "2 day", freq="-3D", name="idx")
  202:             tm.assert_index_equal(result, expected)
  203:             assert result.freq == expected.freq
  204: 
  205:             result = idx.take([3, 2, 5])
  206:             expected = TimedeltaIndex(["4 day", "3 day", "6 day"], name="idx")
  207:             tm.assert_index_equal(result, expected)
  208:             assert result.freq is None
  209: 
  210:             result = idx.take([-3, 2, 5])
  211:             expected = TimedeltaIndex(["29 day", "3 day", "6 day"], name="idx")
  212:             tm.assert_index_equal(result, expected)
  213:             assert result.freq is None
  214: 
  215:     def test_take_invalid_kwargs(self):
  216:         idx = timedelta_range("1 day", "31 day", freq="D", name="idx")
  217:         indices = [1, 6, 5, 9, 10, 13, 15, 3]
  218: 
  219:         msg = r"take\(\) got an unexpected keyword argument 'foo'"
  220:         with pytest.raises(TypeError, match=msg):
  221:             idx.take(indices, foo=2)
  222: 
  223:         msg = "the 'out' parameter is not supported"
  224:         with pytest.raises(ValueError, match=msg):
  225:             idx.take(indices, out=indices)
  226: 
  227:         msg = "the 'mode' parameter is not supported"
  228:         with pytest.raises(ValueError, match=msg):
  229:             idx.take(indices, mode="clip")
  230: 
  231:     def test_take_equiv_getitem(self):
  232:         tds = ["1day 02:00:00", "1 day 04:00:00", "1 day 10:00:00"]
  233:         idx = timedelta_range(start="1d", end="2d", freq="h", name="idx")
  234:         expected = TimedeltaIndex(tds, freq=None, name="idx")
  235: 
  236:         taken1 = idx.take([2, 4, 10])
  237:         taken2 = idx[[2, 4, 10]]
  238: 
  239:         for taken in [taken1, taken2]:
  240:             tm.assert_index_equal(taken, expected)
  241:             assert isinstance(taken, TimedeltaIndex)
  242:             assert taken.freq is None
  243:             assert taken.name == expected.name
  244: 
  245:     def test_take_fill_value(self):
  246:         # GH 12631
  247:         idx = TimedeltaIndex(["1 days", "2 days", "3 days"], name="xxx")
  248:         result = idx.take(np.array([1, 0, -1]))
  249:         expected = TimedeltaIndex(["2 days", "1 days", "3 days"], name="xxx")
  250:         tm.assert_index_equal(result, expected)
  251: 
  252:         # fill_value
  253:         result = idx.take(np.array([1, 0, -1]), fill_value=True)
  254:         expected = TimedeltaIndex(["2 days", "1 days", "NaT"], name="xxx")
  255:         tm.assert_index_equal(result, expected)
  256: 
  257:         # allow_fill=False
  258:         result = idx.take(np.array([1, 0, -1]), allow_fill=False, fill_value=True)
  259:         expected = TimedeltaIndex(["2 days", "1 days", "3 days"], name="xxx")
  260:         tm.assert_index_equal(result, expected)
  261: 
  262:         msg = (
  263:             "When allow_fill=True and fill_value is not None, "
  264:             "all indices must be >= -1"
  265:         )
  266:         with pytest.raises(ValueError, match=msg):
  267:             idx.take(np.array([1, 0, -2]), fill_value=True)
  268:         with pytest.raises(ValueError, match=msg):
  269:             idx.take(np.array([1, 0, -5]), fill_value=True)
  270: 
  271:         msg = "index -5 is out of bounds for (axis 0 with )?size 3"
  272:         with pytest.raises(IndexError, match=msg):
  273:             idx.take(np.array([1, -5]))
  274: 
  275: 
  276: class TestMaybeCastSliceBound:
  277:     @pytest.fixture(params=["increasing", "decreasing", None])
  278:     def monotonic(self, request):
  279:         return request.param
  280: 
  281:     @pytest.fixture
  282:     def tdi(self, monotonic):
  283:         tdi = timedelta_range("1 Day", periods=10)
  284:         if monotonic == "decreasing":
  285:             tdi = tdi[::-1]
  286:         elif monotonic is None:
  287:             taker = np.arange(10, dtype=np.intp)
  288:             np.random.default_rng(2).shuffle(taker)
  289:             tdi = tdi.take(taker)
  290:         return tdi
  291: 
  292:     def test_maybe_cast_slice_bound_invalid_str(self, tdi):
  293:         # test the low-level _maybe_cast_slice_bound and that we get the
  294:         #  expected exception+message all the way up the stack
  295:         msg = (
  296:             "cannot do slice indexing on TimedeltaIndex with these "
  297:             r"indexers \[foo\] of type str"
  298:         )
  299:         with pytest.raises(TypeError, match=msg):
  300:             tdi._maybe_cast_slice_bound("foo", side="left")
  301:         with pytest.raises(TypeError, match=msg):
  302:             tdi.get_slice_bound("foo", side="left")
  303:         with pytest.raises(TypeError, match=msg):
  304:             tdi.slice_locs("foo", None, None)
  305: 
  306:     def test_slice_invalid_str_with_timedeltaindex(
  307:         self, tdi, frame_or_series, indexer_sl
  308:     ):
  309:         obj = frame_or_series(range(10), index=tdi)
  310: 
  311:         msg = (
  312:             "cannot do slice indexing on TimedeltaIndex with these "
  313:             r"indexers \[foo\] of type str"
  314:         )
  315:         with pytest.raises(TypeError, match=msg):
  316:             indexer_sl(obj)["foo":]
  317:         with pytest.raises(TypeError, match=msg):
  318:             indexer_sl(obj)["foo":-1]
  319:         with pytest.raises(TypeError, match=msg):
  320:             indexer_sl(obj)[:"foo"]
  321:         with pytest.raises(TypeError, match=msg):
  322:             indexer_sl(obj)[tdi[0] : "foo"]
  323: 
  324: 
  325: class TestContains:
  326:     def test_contains_nonunique(self):
  327:         # GH#9512
  328:         for vals in (
  329:             [0, 1, 0],
  330:             [0, 0, -1],
  331:             [0, -1, -1],
  332:             ["00:01:00", "00:01:00", "00:02:00"],
  333:             ["00:01:00", "00:01:00", "00:00:01"],
  334:         ):
  335:             idx = TimedeltaIndex(vals)
  336:             assert idx[0] in idx
  337: 
  338:     def test_contains(self):
  339:         # Checking for any NaT-like objects
  340:         # GH#13603
  341:         td = to_timedelta(range(5), unit="d") + offsets.Hour(1)
  342:         for v in [NaT, None, float("nan"), np.nan]:
  343:             assert v not in td
  344: 
  345:         td = to_timedelta([NaT])
  346:         for v in [NaT, None, float("nan"), np.nan]:
  347:             assert v in td
