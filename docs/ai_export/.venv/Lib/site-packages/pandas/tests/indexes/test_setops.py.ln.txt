    1: """
    2: The tests in this package are to ensure the proper resultant dtypes of
    3: set operations.
    4: """
    5: from datetime import datetime
    6: import operator
    7: 
    8: import numpy as np
    9: import pytest
   10: 
   11: from pandas._libs import lib
   12: 
   13: from pandas.core.dtypes.cast import find_common_type
   14: 
   15: from pandas import (
   16:     CategoricalDtype,
   17:     CategoricalIndex,
   18:     DatetimeTZDtype,
   19:     Index,
   20:     MultiIndex,
   21:     PeriodDtype,
   22:     RangeIndex,
   23:     Series,
   24:     Timestamp,
   25: )
   26: import pandas._testing as tm
   27: from pandas.api.types import (
   28:     is_signed_integer_dtype,
   29:     pandas_dtype,
   30: )
   31: 
   32: 
   33: def equal_contents(arr1, arr2) -> bool:
   34:     """
   35:     Checks if the set of unique elements of arr1 and arr2 are equivalent.
   36:     """
   37:     return frozenset(arr1) == frozenset(arr2)
   38: 
   39: 
   40: @pytest.fixture(
   41:     params=tm.ALL_REAL_NUMPY_DTYPES
   42:     + [
   43:         "object",
   44:         "category",
   45:         "datetime64[ns]",
   46:         "timedelta64[ns]",
   47:     ]
   48: )
   49: def any_dtype_for_small_pos_integer_indexes(request):
   50:     """
   51:     Dtypes that can be given to an Index with small positive integers.
   52: 
   53:     This means that for any dtype `x` in the params list, `Index([1, 2, 3], dtype=x)` is
   54:     valid and gives the correct Index (sub-)class.
   55:     """
   56:     return request.param
   57: 
   58: 
   59: def test_union_same_types(index):
   60:     # Union with a non-unique, non-monotonic index raises error
   61:     # Only needed for bool index factory
   62:     idx1 = index.sort_values()
   63:     idx2 = index.sort_values()
   64:     assert idx1.union(idx2).dtype == idx1.dtype
   65: 
   66: 
   67: def test_union_different_types(index_flat, index_flat2, request):
   68:     # This test only considers combinations of indices
   69:     # GH 23525
   70:     idx1 = index_flat
   71:     idx2 = index_flat2
   72: 
   73:     if (
   74:         not idx1.is_unique
   75:         and not idx2.is_unique
   76:         and idx1.dtype.kind == "i"
   77:         and idx2.dtype.kind == "b"
   78:     ) or (
   79:         not idx2.is_unique
   80:         and not idx1.is_unique
   81:         and idx2.dtype.kind == "i"
   82:         and idx1.dtype.kind == "b"
   83:     ):
   84:         # Each condition had idx[1|2].is_monotonic_decreasing
   85:         # but failed when e.g.
   86:         # idx1 = Index(
   87:         # [True, True, True, True, True, True, True, True, False, False], dtype='bool'
   88:         # )
   89:         # idx2 = Index([0, 0, 1, 1, 2, 2], dtype='int64')
   90:         mark = pytest.mark.xfail(
   91:             reason="GH#44000 True==1", raises=ValueError, strict=False
   92:         )
   93:         request.applymarker(mark)
   94: 
   95:     common_dtype = find_common_type([idx1.dtype, idx2.dtype])
   96: 
   97:     warn = None
   98:     msg = "'<' not supported between"
   99:     if not len(idx1) or not len(idx2):
  100:         pass
  101:     elif (idx1.dtype.kind == "c" and (not lib.is_np_dtype(idx2.dtype, "iufc"))) or (
  102:         idx2.dtype.kind == "c" and (not lib.is_np_dtype(idx1.dtype, "iufc"))
  103:     ):
  104:         # complex objects non-sortable
  105:         warn = RuntimeWarning
  106:     elif (
  107:         isinstance(idx1.dtype, PeriodDtype) and isinstance(idx2.dtype, CategoricalDtype)
  108:     ) or (
  109:         isinstance(idx2.dtype, PeriodDtype) and isinstance(idx1.dtype, CategoricalDtype)
  110:     ):
  111:         warn = FutureWarning
  112:         msg = r"PeriodDtype\[B\] is deprecated"
  113:         mark = pytest.mark.xfail(
  114:             reason="Warning not produced on all builds",
  115:             raises=AssertionError,
  116:             strict=False,
  117:         )
  118:         request.applymarker(mark)
  119: 
  120:     any_uint64 = np.uint64 in (idx1.dtype, idx2.dtype)
  121:     idx1_signed = is_signed_integer_dtype(idx1.dtype)
  122:     idx2_signed = is_signed_integer_dtype(idx2.dtype)
  123: 
  124:     # Union with a non-unique, non-monotonic index raises error
  125:     # This applies to the boolean index
  126:     idx1 = idx1.sort_values()
  127:     idx2 = idx2.sort_values()
  128: 
  129:     with tm.assert_produces_warning(warn, match=msg):
  130:         res1 = idx1.union(idx2)
  131:         res2 = idx2.union(idx1)
  132: 
  133:     if any_uint64 and (idx1_signed or idx2_signed):
  134:         assert res1.dtype == np.dtype("O")
  135:         assert res2.dtype == np.dtype("O")
  136:     else:
  137:         assert res1.dtype == common_dtype
  138:         assert res2.dtype == common_dtype
  139: 
  140: 
  141: @pytest.mark.parametrize(
  142:     "idx1,idx2",
  143:     [
  144:         (Index(np.arange(5), dtype=np.int64), RangeIndex(5)),
  145:         (Index(np.arange(5), dtype=np.float64), Index(np.arange(5), dtype=np.int64)),
  146:         (Index(np.arange(5), dtype=np.float64), RangeIndex(5)),
  147:         (Index(np.arange(5), dtype=np.float64), Index(np.arange(5), dtype=np.uint64)),
  148:     ],
  149: )
  150: def test_compatible_inconsistent_pairs(idx1, idx2):
  151:     # GH 23525
  152:     res1 = idx1.union(idx2)
  153:     res2 = idx2.union(idx1)
  154: 
  155:     assert res1.dtype in (idx1.dtype, idx2.dtype)
  156:     assert res2.dtype in (idx1.dtype, idx2.dtype)
  157: 
  158: 
  159: @pytest.mark.parametrize(
  160:     "left, right, expected",
  161:     [
  162:         ("int64", "int64", "int64"),
  163:         ("int64", "uint64", "object"),
  164:         ("int64", "float64", "float64"),
  165:         ("uint64", "float64", "float64"),
  166:         ("uint64", "uint64", "uint64"),
  167:         ("float64", "float64", "float64"),
  168:         ("datetime64[ns]", "int64", "object"),
  169:         ("datetime64[ns]", "uint64", "object"),
  170:         ("datetime64[ns]", "float64", "object"),
  171:         ("datetime64[ns, CET]", "int64", "object"),
  172:         ("datetime64[ns, CET]", "uint64", "object"),
  173:         ("datetime64[ns, CET]", "float64", "object"),
  174:         ("Period[D]", "int64", "object"),
  175:         ("Period[D]", "uint64", "object"),
  176:         ("Period[D]", "float64", "object"),
  177:     ],
  178: )
  179: @pytest.mark.parametrize("names", [("foo", "foo", "foo"), ("foo", "bar", None)])
  180: def test_union_dtypes(left, right, expected, names):
  181:     left = pandas_dtype(left)
  182:     right = pandas_dtype(right)
  183:     a = Index([], dtype=left, name=names[0])
  184:     b = Index([], dtype=right, name=names[1])
  185:     result = a.union(b)
  186:     assert result.dtype == expected
  187:     assert result.name == names[2]
  188: 
  189:     # Testing name retention
  190:     # TODO: pin down desired dtype; do we want it to be commutative?
  191:     result = a.intersection(b)
  192:     assert result.name == names[2]
  193: 
  194: 
  195: @pytest.mark.parametrize("values", [[1, 2, 2, 3], [3, 3]])
  196: def test_intersection_duplicates(values):
  197:     # GH#31326
  198:     a = Index(values)
  199:     b = Index([3, 3])
  200:     result = a.intersection(b)
  201:     expected = Index([3])
  202:     tm.assert_index_equal(result, expected)
  203: 
  204: 
  205: class TestSetOps:
  206:     # Set operation tests shared by all indexes in the `index` fixture
  207:     @pytest.mark.parametrize("case", [0.5, "xxx"])
  208:     @pytest.mark.parametrize(
  209:         "method", ["intersection", "union", "difference", "symmetric_difference"]
  210:     )
  211:     def test_set_ops_error_cases(self, case, method, index):
  212:         # non-iterable input
  213:         msg = "Input must be Index or array-like"
  214:         with pytest.raises(TypeError, match=msg):
  215:             getattr(index, method)(case)
  216: 
  217:     @pytest.mark.filterwarnings(r"ignore:PeriodDtype\[B\] is deprecated:FutureWarning")
  218:     def test_intersection_base(self, index):
  219:         if isinstance(index, CategoricalIndex):
  220:             pytest.skip(f"Not relevant for {type(index).__name__}")
  221: 
  222:         first = index[:5].unique()
  223:         second = index[:3].unique()
  224:         intersect = first.intersection(second)
  225:         tm.assert_index_equal(intersect, second)
  226: 
  227:         if isinstance(index.dtype, DatetimeTZDtype):
  228:             # The second.values below will drop tz, so the rest of this test
  229:             #  is not applicable.
  230:             return
  231: 
  232:         # GH#10149
  233:         cases = [second.to_numpy(), second.to_series(), second.to_list()]
  234:         for case in cases:
  235:             result = first.intersection(case)
  236:             assert equal_contents(result, second)
  237: 
  238:         if isinstance(index, MultiIndex):
  239:             msg = "other must be a MultiIndex or a list of tuples"
  240:             with pytest.raises(TypeError, match=msg):
  241:                 first.intersection([1, 2, 3])
  242: 
  243:     @pytest.mark.filterwarnings(
  244:         "ignore:Falling back on a non-pyarrow:pandas.errors.PerformanceWarning"
  245:     )
  246:     @pytest.mark.filterwarnings(r"ignore:PeriodDtype\[B\] is deprecated:FutureWarning")
  247:     def test_union_base(self, index):
  248:         index = index.unique()
  249:         first = index[3:]
  250:         second = index[:5]
  251:         everything = index
  252: 
  253:         union = first.union(second)
  254:         tm.assert_index_equal(union.sort_values(), everything.sort_values())
  255: 
  256:         if isinstance(index.dtype, DatetimeTZDtype):
  257:             # The second.values below will drop tz, so the rest of this test
  258:             #  is not applicable.
  259:             return
  260: 
  261:         # GH#10149
  262:         cases = [second.to_numpy(), second.to_series(), second.to_list()]
  263:         for case in cases:
  264:             result = first.union(case)
  265:             assert equal_contents(result, everything)
  266: 
  267:         if isinstance(index, MultiIndex):
  268:             msg = "other must be a MultiIndex or a list of tuples"
  269:             with pytest.raises(TypeError, match=msg):
  270:                 first.union([1, 2, 3])
  271: 
  272:     @pytest.mark.filterwarnings(r"ignore:PeriodDtype\[B\] is deprecated:FutureWarning")
  273:     @pytest.mark.filterwarnings(
  274:         "ignore:Falling back on a non-pyarrow:pandas.errors.PerformanceWarning"
  275:     )
  276:     def test_difference_base(self, sort, index):
  277:         first = index[2:]
  278:         second = index[:4]
  279:         if index.inferred_type == "boolean":
  280:             # i think (TODO: be sure) there assumptions baked in about
  281:             #  the index fixture that don't hold here?
  282:             answer = set(first).difference(set(second))
  283:         elif isinstance(index, CategoricalIndex):
  284:             answer = []
  285:         else:
  286:             answer = index[4:]
  287:         result = first.difference(second, sort)
  288:         assert equal_contents(result, answer)
  289: 
  290:         # GH#10149
  291:         cases = [second.to_numpy(), second.to_series(), second.to_list()]
  292:         for case in cases:
  293:             result = first.difference(case, sort)
  294:             assert equal_contents(result, answer)
  295: 
  296:         if isinstance(index, MultiIndex):
  297:             msg = "other must be a MultiIndex or a list of tuples"
  298:             with pytest.raises(TypeError, match=msg):
  299:                 first.difference([1, 2, 3], sort)
  300: 
  301:     @pytest.mark.filterwarnings(r"ignore:PeriodDtype\[B\] is deprecated:FutureWarning")
  302:     @pytest.mark.filterwarnings(
  303:         "ignore:Falling back on a non-pyarrow:pandas.errors.PerformanceWarning"
  304:     )
  305:     def test_symmetric_difference(self, index):
  306:         if isinstance(index, CategoricalIndex):
  307:             pytest.skip(f"Not relevant for {type(index).__name__}")
  308:         if len(index) < 2:
  309:             pytest.skip("Too few values for test")
  310:         if index[0] in index[1:] or index[-1] in index[:-1]:
  311:             # index fixture has e.g. an index of bools that does not satisfy this,
  312:             #  another with [0, 0, 1, 1, 2, 2]
  313:             pytest.skip("Index values no not satisfy test condition.")
  314: 
  315:         first = index[1:]
  316:         second = index[:-1]
  317:         answer = index[[0, -1]]
  318:         result = first.symmetric_difference(second)
  319:         tm.assert_index_equal(result.sort_values(), answer.sort_values())
  320: 
  321:         # GH#10149
  322:         cases = [second.to_numpy(), second.to_series(), second.to_list()]
  323:         for case in cases:
  324:             result = first.symmetric_difference(case)
  325:             assert equal_contents(result, answer)
  326: 
  327:         if isinstance(index, MultiIndex):
  328:             msg = "other must be a MultiIndex or a list of tuples"
  329:             with pytest.raises(TypeError, match=msg):
  330:                 first.symmetric_difference([1, 2, 3])
  331: 
  332:     @pytest.mark.parametrize(
  333:         "fname, sname, expected_name",
  334:         [
  335:             ("A", "A", "A"),
  336:             ("A", "B", None),
  337:             ("A", None, None),
  338:             (None, "B", None),
  339:             (None, None, None),
  340:         ],
  341:     )
  342:     def test_corner_union(self, index_flat, fname, sname, expected_name):
  343:         # GH#9943, GH#9862
  344:         # Test unions with various name combinations
  345:         # Do not test MultiIndex or repeats
  346:         if not index_flat.is_unique:
  347:             index = index_flat.unique()
  348:         else:
  349:             index = index_flat
  350: 
  351:         # Test copy.union(copy)
  352:         first = index.copy().set_names(fname)
  353:         second = index.copy().set_names(sname)
  354:         union = first.union(second)
  355:         expected = index.copy().set_names(expected_name)
  356:         tm.assert_index_equal(union, expected)
  357: 
  358:         # Test copy.union(empty)
  359:         first = index.copy().set_names(fname)
  360:         second = index.drop(index).set_names(sname)
  361:         union = first.union(second)
  362:         expected = index.copy().set_names(expected_name)
  363:         tm.assert_index_equal(union, expected)
  364: 
  365:         # Test empty.union(copy)
  366:         first = index.drop(index).set_names(fname)
  367:         second = index.copy().set_names(sname)
  368:         union = first.union(second)
  369:         expected = index.copy().set_names(expected_name)
  370:         tm.assert_index_equal(union, expected)
  371: 
  372:         # Test empty.union(empty)
  373:         first = index.drop(index).set_names(fname)
  374:         second = index.drop(index).set_names(sname)
  375:         union = first.union(second)
  376:         expected = index.drop(index).set_names(expected_name)
  377:         tm.assert_index_equal(union, expected)
  378: 
  379:     @pytest.mark.parametrize(
  380:         "fname, sname, expected_name",
  381:         [
  382:             ("A", "A", "A"),
  383:             ("A", "B", None),
  384:             ("A", None, None),
  385:             (None, "B", None),
  386:             (None, None, None),
  387:         ],
  388:     )
  389:     def test_union_unequal(self, index_flat, fname, sname, expected_name):
  390:         if not index_flat.is_unique:
  391:             index = index_flat.unique()
  392:         else:
  393:             index = index_flat
  394: 
  395:         # test copy.union(subset) - need sort for unicode and string
  396:         first = index.copy().set_names(fname)
  397:         second = index[1:].set_names(sname)
  398:         union = first.union(second).sort_values()
  399:         expected = index.set_names(expected_name).sort_values()
  400:         tm.assert_index_equal(union, expected)
  401: 
  402:     @pytest.mark.parametrize(
  403:         "fname, sname, expected_name",
  404:         [
  405:             ("A", "A", "A"),
  406:             ("A", "B", None),
  407:             ("A", None, None),
  408:             (None, "B", None),
  409:             (None, None, None),
  410:         ],
  411:     )
  412:     def test_corner_intersect(self, index_flat, fname, sname, expected_name):
  413:         # GH#35847
  414:         # Test intersections with various name combinations
  415:         if not index_flat.is_unique:
  416:             index = index_flat.unique()
  417:         else:
  418:             index = index_flat
  419: 
  420:         # Test copy.intersection(copy)
  421:         first = index.copy().set_names(fname)
  422:         second = index.copy().set_names(sname)
  423:         intersect = first.intersection(second)
  424:         expected = index.copy().set_names(expected_name)
  425:         tm.assert_index_equal(intersect, expected)
  426: 
  427:         # Test copy.intersection(empty)
  428:         first = index.copy().set_names(fname)
  429:         second = index.drop(index).set_names(sname)
  430:         intersect = first.intersection(second)
  431:         expected = index.drop(index).set_names(expected_name)
  432:         tm.assert_index_equal(intersect, expected)
  433: 
  434:         # Test empty.intersection(copy)
  435:         first = index.drop(index).set_names(fname)
  436:         second = index.copy().set_names(sname)
  437:         intersect = first.intersection(second)
  438:         expected = index.drop(index).set_names(expected_name)
  439:         tm.assert_index_equal(intersect, expected)
  440: 
  441:         # Test empty.intersection(empty)
  442:         first = index.drop(index).set_names(fname)
  443:         second = index.drop(index).set_names(sname)
  444:         intersect = first.intersection(second)
  445:         expected = index.drop(index).set_names(expected_name)
  446:         tm.assert_index_equal(intersect, expected)
  447: 
  448:     @pytest.mark.parametrize(
  449:         "fname, sname, expected_name",
  450:         [
  451:             ("A", "A", "A"),
  452:             ("A", "B", None),
  453:             ("A", None, None),
  454:             (None, "B", None),
  455:             (None, None, None),
  456:         ],
  457:     )
  458:     def test_intersect_unequal(self, index_flat, fname, sname, expected_name):
  459:         if not index_flat.is_unique:
  460:             index = index_flat.unique()
  461:         else:
  462:             index = index_flat
  463: 
  464:         # test copy.intersection(subset) - need sort for unicode and string
  465:         first = index.copy().set_names(fname)
  466:         second = index[1:].set_names(sname)
  467:         intersect = first.intersection(second).sort_values()
  468:         expected = index[1:].set_names(expected_name).sort_values()
  469:         tm.assert_index_equal(intersect, expected)
  470: 
  471:     @pytest.mark.filterwarnings(r"ignore:PeriodDtype\[B\] is deprecated:FutureWarning")
  472:     def test_intersection_name_retention_with_nameless(self, index):
  473:         if isinstance(index, MultiIndex):
  474:             index = index.rename(list(range(index.nlevels)))
  475:         else:
  476:             index = index.rename("foo")
  477: 
  478:         other = np.asarray(index)
  479: 
  480:         result = index.intersection(other)
  481:         assert result.name == index.name
  482: 
  483:         # empty other, same dtype
  484:         result = index.intersection(other[:0])
  485:         assert result.name == index.name
  486: 
  487:         # empty `self`
  488:         result = index[:0].intersection(other)
  489:         assert result.name == index.name
  490: 
  491:     def test_difference_preserves_type_empty(self, index, sort):
  492:         # GH#20040
  493:         # If taking difference of a set and itself, it
  494:         # needs to preserve the type of the index
  495:         if not index.is_unique:
  496:             pytest.skip("Not relevant since index is not unique")
  497:         result = index.difference(index, sort=sort)
  498:         expected = index[:0]
  499:         tm.assert_index_equal(result, expected, exact=True)
  500: 
  501:     def test_difference_name_retention_equals(self, index, names):
  502:         if isinstance(index, MultiIndex):
  503:             names = [[x] * index.nlevels for x in names]
  504:         index = index.rename(names[0])
  505:         other = index.rename(names[1])
  506: 
  507:         assert index.equals(other)
  508: 
  509:         result = index.difference(other)
  510:         expected = index[:0].rename(names[2])
  511:         tm.assert_index_equal(result, expected)
  512: 
  513:     def test_intersection_difference_match_empty(self, index, sort):
  514:         # GH#20040
  515:         # Test that the intersection of an index with an
  516:         # empty index produces the same index as the difference
  517:         # of an index with itself.  Test for all types
  518:         if not index.is_unique:
  519:             pytest.skip("Not relevant because index is not unique")
  520:         inter = index.intersection(index[:0])
  521:         diff = index.difference(index, sort=sort)
  522:         tm.assert_index_equal(inter, diff, exact=True)
  523: 
  524: 
  525: @pytest.mark.filterwarnings(r"ignore:PeriodDtype\[B\] is deprecated:FutureWarning")
  526: @pytest.mark.filterwarnings(
  527:     "ignore:Falling back on a non-pyarrow:pandas.errors.PerformanceWarning"
  528: )
  529: @pytest.mark.parametrize(
  530:     "method", ["intersection", "union", "difference", "symmetric_difference"]
  531: )
  532: def test_setop_with_categorical(index_flat, sort, method):
  533:     # MultiIndex tested separately in tests.indexes.multi.test_setops
  534:     index = index_flat
  535: 
  536:     other = index.astype("category")
  537:     exact = "equiv" if isinstance(index, RangeIndex) else True
  538: 
  539:     result = getattr(index, method)(other, sort=sort)
  540:     expected = getattr(index, method)(index, sort=sort)
  541:     tm.assert_index_equal(result, expected, exact=exact)
  542: 
  543:     result = getattr(index, method)(other[:5], sort=sort)
  544:     expected = getattr(index, method)(index[:5], sort=sort)
  545:     tm.assert_index_equal(result, expected, exact=exact)
  546: 
  547: 
  548: def test_intersection_duplicates_all_indexes(index):
  549:     # GH#38743
  550:     if index.empty:
  551:         # No duplicates in empty indexes
  552:         pytest.skip("Not relevant for empty Index")
  553: 
  554:     idx = index
  555:     idx_non_unique = idx[[0, 0, 1, 2]]
  556: 
  557:     assert idx.intersection(idx_non_unique).equals(idx_non_unique.intersection(idx))
  558:     assert idx.intersection(idx_non_unique).is_unique
  559: 
  560: 
  561: def test_union_duplicate_index_subsets_of_each_other(
  562:     any_dtype_for_small_pos_integer_indexes,
  563: ):
  564:     # GH#31326
  565:     dtype = any_dtype_for_small_pos_integer_indexes
  566:     a = Index([1, 2, 2, 3], dtype=dtype)
  567:     b = Index([3, 3, 4], dtype=dtype)
  568: 
  569:     expected = Index([1, 2, 2, 3, 3, 4], dtype=dtype)
  570:     if isinstance(a, CategoricalIndex):
  571:         expected = Index([1, 2, 2, 3, 3, 4])
  572:     result = a.union(b)
  573:     tm.assert_index_equal(result, expected)
  574:     result = a.union(b, sort=False)
  575:     tm.assert_index_equal(result, expected)
  576: 
  577: 
  578: def test_union_with_duplicate_index_and_non_monotonic(
  579:     any_dtype_for_small_pos_integer_indexes,
  580: ):
  581:     # GH#36289
  582:     dtype = any_dtype_for_small_pos_integer_indexes
  583:     a = Index([1, 0, 0], dtype=dtype)
  584:     b = Index([0, 1], dtype=dtype)
  585:     expected = Index([0, 0, 1], dtype=dtype)
  586: 
  587:     result = a.union(b)
  588:     tm.assert_index_equal(result, expected)
  589: 
  590:     result = b.union(a)
  591:     tm.assert_index_equal(result, expected)
  592: 
  593: 
  594: def test_union_duplicate_index_different_dtypes():
  595:     # GH#36289
  596:     a = Index([1, 2, 2, 3])
  597:     b = Index(["1", "0", "0"])
  598:     expected = Index([1, 2, 2, 3, "1", "0", "0"])
  599:     result = a.union(b, sort=False)
  600:     tm.assert_index_equal(result, expected)
  601: 
  602: 
  603: def test_union_same_value_duplicated_in_both():
  604:     # GH#36289
  605:     a = Index([0, 0, 1])
  606:     b = Index([0, 0, 1, 2])
  607:     result = a.union(b)
  608:     expected = Index([0, 0, 1, 2])
  609:     tm.assert_index_equal(result, expected)
  610: 
  611: 
  612: @pytest.mark.parametrize("dup", [1, np.nan])
  613: def test_union_nan_in_both(dup):
  614:     # GH#36289
  615:     a = Index([np.nan, 1, 2, 2])
  616:     b = Index([np.nan, dup, 1, 2])
  617:     result = a.union(b, sort=False)
  618:     expected = Index([np.nan, dup, 1.0, 2.0, 2.0])
  619:     tm.assert_index_equal(result, expected)
  620: 
  621: 
  622: def test_union_rangeindex_sort_true():
  623:     # GH 53490
  624:     idx1 = RangeIndex(1, 100, 6)
  625:     idx2 = RangeIndex(1, 50, 3)
  626:     result = idx1.union(idx2, sort=True)
  627:     expected = Index(
  628:         [
  629:             1,
  630:             4,
  631:             7,
  632:             10,
  633:             13,
  634:             16,
  635:             19,
  636:             22,
  637:             25,
  638:             28,
  639:             31,
  640:             34,
  641:             37,
  642:             40,
  643:             43,
  644:             46,
  645:             49,
  646:             55,
  647:             61,
  648:             67,
  649:             73,
  650:             79,
  651:             85,
  652:             91,
  653:             97,
  654:         ]
  655:     )
  656:     tm.assert_index_equal(result, expected)
  657: 
  658: 
  659: def test_union_with_duplicate_index_not_subset_and_non_monotonic(
  660:     any_dtype_for_small_pos_integer_indexes,
  661: ):
  662:     # GH#36289
  663:     dtype = any_dtype_for_small_pos_integer_indexes
  664:     a = Index([1, 0, 2], dtype=dtype)
  665:     b = Index([0, 0, 1], dtype=dtype)
  666:     expected = Index([0, 0, 1, 2], dtype=dtype)
  667:     if isinstance(a, CategoricalIndex):
  668:         expected = Index([0, 0, 1, 2])
  669: 
  670:     result = a.union(b)
  671:     tm.assert_index_equal(result, expected)
  672: 
  673:     result = b.union(a)
  674:     tm.assert_index_equal(result, expected)
  675: 
  676: 
  677: def test_union_int_categorical_with_nan():
  678:     ci = CategoricalIndex([1, 2, np.nan])
  679:     assert ci.categories.dtype.kind == "i"
  680: 
  681:     idx = Index([1, 2])
  682: 
  683:     result = idx.union(ci)
  684:     expected = Index([1, 2, np.nan], dtype=np.float64)
  685:     tm.assert_index_equal(result, expected)
  686: 
  687:     result = ci.union(idx)
  688:     tm.assert_index_equal(result, expected)
  689: 
  690: 
  691: class TestSetOpsUnsorted:
  692:     # These may eventually belong in a dtype-specific test_setops, or
  693:     #  parametrized over a more general fixture
  694:     def test_intersect_str_dates(self):
  695:         dt_dates = [datetime(2012, 2, 9), datetime(2012, 2, 22)]
  696: 
  697:         index1 = Index(dt_dates, dtype=object)
  698:         index2 = Index(["aa"], dtype=object)
  699:         result = index2.intersection(index1)
  700: 
  701:         expected = Index([], dtype=object)
  702:         tm.assert_index_equal(result, expected)
  703: 
  704:     @pytest.mark.parametrize("index", ["string"], indirect=True)
  705:     def test_intersection(self, index, sort):
  706:         first = index[:20]
  707:         second = index[:10]
  708:         intersect = first.intersection(second, sort=sort)
  709:         if sort in (None, False):
  710:             tm.assert_index_equal(intersect.sort_values(), second.sort_values())
  711:         else:
  712:             tm.assert_index_equal(intersect, second)
  713: 
  714:         # Corner cases
  715:         inter = first.intersection(first, sort=sort)
  716:         assert inter is first
  717: 
  718:     @pytest.mark.parametrize(
  719:         "index2,keeps_name",
  720:         [
  721:             (Index([3, 4, 5, 6, 7], name="index"), True),  # preserve same name
  722:             (Index([3, 4, 5, 6, 7], name="other"), False),  # drop diff names
  723:             (Index([3, 4, 5, 6, 7]), False),
  724:         ],
  725:     )
  726:     def test_intersection_name_preservation(self, index2, keeps_name, sort):
  727:         index1 = Index([1, 2, 3, 4, 5], name="index")
  728:         expected = Index([3, 4, 5])
  729:         result = index1.intersection(index2, sort)
  730: 
  731:         if keeps_name:
  732:             expected.name = "index"
  733: 
  734:         assert result.name == expected.name
  735:         tm.assert_index_equal(result, expected)
  736: 
  737:     @pytest.mark.parametrize("index", ["string"], indirect=True)
  738:     @pytest.mark.parametrize(
  739:         "first_name,second_name,expected_name",
  740:         [("A", "A", "A"), ("A", "B", None), (None, "B", None)],
  741:     )
  742:     def test_intersection_name_preservation2(
  743:         self, index, first_name, second_name, expected_name, sort
  744:     ):
  745:         first = index[5:20]
  746:         second = index[:10]
  747:         first.name = first_name
  748:         second.name = second_name
  749:         intersect = first.intersection(second, sort=sort)
  750:         assert intersect.name == expected_name
  751: 
  752:     def test_chained_union(self, sort):
  753:         # Chained unions handles names correctly
  754:         i1 = Index([1, 2], name="i1")
  755:         i2 = Index([5, 6], name="i2")
  756:         i3 = Index([3, 4], name="i3")
  757:         union = i1.union(i2.union(i3, sort=sort), sort=sort)
  758:         expected = i1.union(i2, sort=sort).union(i3, sort=sort)
  759:         tm.assert_index_equal(union, expected)
  760: 
  761:         j1 = Index([1, 2], name="j1")
  762:         j2 = Index([], name="j2")
  763:         j3 = Index([], name="j3")
  764:         union = j1.union(j2.union(j3, sort=sort), sort=sort)
  765:         expected = j1.union(j2, sort=sort).union(j3, sort=sort)
  766:         tm.assert_index_equal(union, expected)
  767: 
  768:     @pytest.mark.parametrize("index", ["string"], indirect=True)
  769:     def test_union(self, index, sort):
  770:         first = index[5:20]
  771:         second = index[:10]
  772:         everything = index[:20]
  773: 
  774:         union = first.union(second, sort=sort)
  775:         if sort in (None, False):
  776:             tm.assert_index_equal(union.sort_values(), everything.sort_values())
  777:         else:
  778:             tm.assert_index_equal(union, everything)
  779: 
  780:     @pytest.mark.parametrize("klass", [np.array, Series, list])
  781:     @pytest.mark.parametrize("index", ["string"], indirect=True)
  782:     def test_union_from_iterables(self, index, klass, sort):
  783:         # GH#10149
  784:         first = index[5:20]
  785:         second = index[:10]
  786:         everything = index[:20]
  787: 
  788:         case = klass(second.values)
  789:         result = first.union(case, sort=sort)
  790:         if sort in (None, False):
  791:             tm.assert_index_equal(result.sort_values(), everything.sort_values())
  792:         else:
  793:             tm.assert_index_equal(result, everything)
  794: 
  795:     @pytest.mark.parametrize("index", ["string"], indirect=True)
  796:     def test_union_identity(self, index, sort):
  797:         first = index[5:20]
  798: 
  799:         union = first.union(first, sort=sort)
  800:         # i.e. identity is not preserved when sort is True
  801:         assert (union is first) is (not sort)
  802: 
  803:         # This should no longer be the same object, since [] is not consistent,
  804:         # both objects will be recast to dtype('O')
  805:         union = first.union(Index([], dtype=first.dtype), sort=sort)
  806:         assert (union is first) is (not sort)
  807: 
  808:         union = Index([], dtype=first.dtype).union(first, sort=sort)
  809:         assert (union is first) is (not sort)
  810: 
  811:     @pytest.mark.parametrize("index", ["string"], indirect=True)
  812:     @pytest.mark.parametrize("second_name,expected", [(None, None), ("name", "name")])
  813:     def test_difference_name_preservation(self, index, second_name, expected, sort):
  814:         first = index[5:20]
  815:         second = index[:10]
  816:         answer = index[10:20]
  817: 
  818:         first.name = "name"
  819:         second.name = second_name
  820:         result = first.difference(second, sort=sort)
  821: 
  822:         if sort is True:
  823:             tm.assert_index_equal(result, answer)
  824:         else:
  825:             answer.name = second_name
  826:             tm.assert_index_equal(result.sort_values(), answer.sort_values())
  827: 
  828:         if expected is None:
  829:             assert result.name is None
  830:         else:
  831:             assert result.name == expected
  832: 
  833:     def test_difference_empty_arg(self, index, sort):
  834:         first = index.copy()
  835:         first = first[5:20]
  836:         first.name = "name"
  837:         result = first.difference([], sort)
  838:         expected = index[5:20].unique()
  839:         expected.name = "name"
  840:         tm.assert_index_equal(result, expected)
  841: 
  842:     def test_difference_should_not_compare(self):
  843:         # GH 55113
  844:         left = Index([1, 1])
  845:         right = Index([True])
  846:         result = left.difference(right)
  847:         expected = Index([1])
  848:         tm.assert_index_equal(result, expected)
  849: 
  850:     @pytest.mark.parametrize("index", ["string"], indirect=True)
  851:     def test_difference_identity(self, index, sort):
  852:         first = index[5:20]
  853:         first.name = "name"
  854:         result = first.difference(first, sort)
  855: 
  856:         assert len(result) == 0
  857:         assert result.name == first.name
  858: 
  859:     @pytest.mark.parametrize("index", ["string"], indirect=True)
  860:     def test_difference_sort(self, index, sort):
  861:         first = index[5:20]
  862:         second = index[:10]
  863: 
  864:         result = first.difference(second, sort)
  865:         expected = index[10:20]
  866: 
  867:         if sort is None:
  868:             expected = expected.sort_values()
  869: 
  870:         tm.assert_index_equal(result, expected)
  871: 
  872:     @pytest.mark.parametrize("opname", ["difference", "symmetric_difference"])
  873:     def test_difference_incomparable(self, opname):
  874:         a = Index([3, Timestamp("2000"), 1])
  875:         b = Index([2, Timestamp("1999"), 1])
  876:         op = operator.methodcaller(opname, b)
  877: 
  878:         with tm.assert_produces_warning(RuntimeWarning):
  879:             # sort=None, the default
  880:             result = op(a)
  881:         expected = Index([3, Timestamp("2000"), 2, Timestamp("1999")])
  882:         if opname == "difference":
  883:             expected = expected[:2]
  884:         tm.assert_index_equal(result, expected)
  885: 
  886:         # sort=False
  887:         op = operator.methodcaller(opname, b, sort=False)
  888:         result = op(a)
  889:         tm.assert_index_equal(result, expected)
  890: 
  891:     @pytest.mark.parametrize("opname", ["difference", "symmetric_difference"])
  892:     def test_difference_incomparable_true(self, opname):
  893:         a = Index([3, Timestamp("2000"), 1])
  894:         b = Index([2, Timestamp("1999"), 1])
  895:         op = operator.methodcaller(opname, b, sort=True)
  896: 
  897:         msg = "'<' not supported between instances of 'Timestamp' and 'int'"
  898:         with pytest.raises(TypeError, match=msg):
  899:             op(a)
  900: 
  901:     def test_symmetric_difference_mi(self, sort):
  902:         index1 = MultiIndex.from_tuples(zip(["foo", "bar", "baz"], [1, 2, 3]))
  903:         index2 = MultiIndex.from_tuples([("foo", 1), ("bar", 3)])
  904:         result = index1.symmetric_difference(index2, sort=sort)
  905:         expected = MultiIndex.from_tuples([("bar", 2), ("baz", 3), ("bar", 3)])
  906:         if sort is None:
  907:             expected = expected.sort_values()
  908:         tm.assert_index_equal(result, expected)
  909: 
  910:     @pytest.mark.parametrize(
  911:         "index2,expected",
  912:         [
  913:             (Index([0, 1, np.nan]), Index([2.0, 3.0, 0.0])),
  914:             (Index([0, 1]), Index([np.nan, 2.0, 3.0, 0.0])),
  915:         ],
  916:     )
  917:     def test_symmetric_difference_missing(self, index2, expected, sort):
  918:         # GH#13514 change: {nan} - {nan} == {}
  919:         # (GH#6444, sorting of nans, is no longer an issue)
  920:         index1 = Index([1, np.nan, 2, 3])
  921: 
  922:         result = index1.symmetric_difference(index2, sort=sort)
  923:         if sort is None:
  924:             expected = expected.sort_values()
  925:         tm.assert_index_equal(result, expected)
  926: 
  927:     def test_symmetric_difference_non_index(self, sort):
  928:         index1 = Index([1, 2, 3, 4], name="index1")
  929:         index2 = np.array([2, 3, 4, 5])
  930:         expected = Index([1, 5], name="index1")
  931:         result = index1.symmetric_difference(index2, sort=sort)
  932:         if sort in (None, True):
  933:             tm.assert_index_equal(result, expected)
  934:         else:
  935:             tm.assert_index_equal(result.sort_values(), expected)
  936:         assert result.name == "index1"
  937: 
  938:         result = index1.symmetric_difference(index2, result_name="new_name", sort=sort)
  939:         expected.name = "new_name"
  940:         if sort in (None, True):
  941:             tm.assert_index_equal(result, expected)
  942:         else:
  943:             tm.assert_index_equal(result.sort_values(), expected)
  944:         assert result.name == "new_name"
  945: 
  946:     def test_union_ea_dtypes(self, any_numeric_ea_and_arrow_dtype):
  947:         # GH#51365
  948:         idx = Index([1, 2, 3], dtype=any_numeric_ea_and_arrow_dtype)
  949:         idx2 = Index([3, 4, 5], dtype=any_numeric_ea_and_arrow_dtype)
  950:         result = idx.union(idx2)
  951:         expected = Index([1, 2, 3, 4, 5], dtype=any_numeric_ea_and_arrow_dtype)
  952:         tm.assert_index_equal(result, expected)
  953: 
  954:     def test_union_string_array(self, any_string_dtype):
  955:         idx1 = Index(["a"], dtype=any_string_dtype)
  956:         idx2 = Index(["b"], dtype=any_string_dtype)
  957:         result = idx1.union(idx2)
  958:         expected = Index(["a", "b"], dtype=any_string_dtype)
  959:         tm.assert_index_equal(result, expected)
