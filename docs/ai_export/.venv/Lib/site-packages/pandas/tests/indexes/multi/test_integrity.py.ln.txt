    1: import re
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: from pandas._libs import index as libindex
    7: 
    8: from pandas.core.dtypes.cast import construct_1d_object_array_from_listlike
    9: 
   10: import pandas as pd
   11: from pandas import (
   12:     Index,
   13:     IntervalIndex,
   14:     MultiIndex,
   15:     RangeIndex,
   16: )
   17: import pandas._testing as tm
   18: 
   19: 
   20: def test_labels_dtypes():
   21:     # GH 8456
   22:     i = MultiIndex.from_tuples([("A", 1), ("A", 2)])
   23:     assert i.codes[0].dtype == "int8"
   24:     assert i.codes[1].dtype == "int8"
   25: 
   26:     i = MultiIndex.from_product([["a"], range(40)])
   27:     assert i.codes[1].dtype == "int8"
   28:     i = MultiIndex.from_product([["a"], range(400)])
   29:     assert i.codes[1].dtype == "int16"
   30:     i = MultiIndex.from_product([["a"], range(40000)])
   31:     assert i.codes[1].dtype == "int32"
   32: 
   33:     i = MultiIndex.from_product([["a"], range(1000)])
   34:     assert (i.codes[0] >= 0).all()
   35:     assert (i.codes[1] >= 0).all()
   36: 
   37: 
   38: def test_values_boxed():
   39:     tuples = [
   40:         (1, pd.Timestamp("2000-01-01")),
   41:         (2, pd.NaT),
   42:         (3, pd.Timestamp("2000-01-03")),
   43:         (1, pd.Timestamp("2000-01-04")),
   44:         (2, pd.Timestamp("2000-01-02")),
   45:         (3, pd.Timestamp("2000-01-03")),
   46:     ]
   47:     result = MultiIndex.from_tuples(tuples)
   48:     expected = construct_1d_object_array_from_listlike(tuples)
   49:     tm.assert_numpy_array_equal(result.values, expected)
   50:     # Check that code branches for boxed values produce identical results
   51:     tm.assert_numpy_array_equal(result.values[:4], result[:4].values)
   52: 
   53: 
   54: def test_values_multiindex_datetimeindex():
   55:     # Test to ensure we hit the boxing / nobox part of MI.values
   56:     ints = np.arange(10**18, 10**18 + 5)
   57:     naive = pd.DatetimeIndex(ints)
   58: 
   59:     aware = pd.DatetimeIndex(ints, tz="US/Central")
   60: 
   61:     idx = MultiIndex.from_arrays([naive, aware])
   62:     result = idx.values
   63: 
   64:     outer = pd.DatetimeIndex([x[0] for x in result])
   65:     tm.assert_index_equal(outer, naive)
   66: 
   67:     inner = pd.DatetimeIndex([x[1] for x in result])
   68:     tm.assert_index_equal(inner, aware)
   69: 
   70:     # n_lev > n_lab
   71:     result = idx[:2].values
   72: 
   73:     outer = pd.DatetimeIndex([x[0] for x in result])
   74:     tm.assert_index_equal(outer, naive[:2])
   75: 
   76:     inner = pd.DatetimeIndex([x[1] for x in result])
   77:     tm.assert_index_equal(inner, aware[:2])
   78: 
   79: 
   80: def test_values_multiindex_periodindex():
   81:     # Test to ensure we hit the boxing / nobox part of MI.values
   82:     ints = np.arange(2007, 2012)
   83:     pidx = pd.PeriodIndex(ints, freq="D")
   84: 
   85:     idx = MultiIndex.from_arrays([ints, pidx])
   86:     result = idx.values
   87: 
   88:     outer = Index([x[0] for x in result])
   89:     tm.assert_index_equal(outer, Index(ints, dtype=np.int64))
   90: 
   91:     inner = pd.PeriodIndex([x[1] for x in result])
   92:     tm.assert_index_equal(inner, pidx)
   93: 
   94:     # n_lev > n_lab
   95:     result = idx[:2].values
   96: 
   97:     outer = Index([x[0] for x in result])
   98:     tm.assert_index_equal(outer, Index(ints[:2], dtype=np.int64))
   99: 
  100:     inner = pd.PeriodIndex([x[1] for x in result])
  101:     tm.assert_index_equal(inner, pidx[:2])
  102: 
  103: 
  104: def test_consistency():
  105:     # need to construct an overflow
  106:     major_axis = list(range(70000))
  107:     minor_axis = list(range(10))
  108: 
  109:     major_codes = np.arange(70000)
  110:     minor_codes = np.repeat(range(10), 7000)
  111: 
  112:     # the fact that is works means it's consistent
  113:     index = MultiIndex(
  114:         levels=[major_axis, minor_axis], codes=[major_codes, minor_codes]
  115:     )
  116: 
  117:     # inconsistent
  118:     major_codes = np.array([0, 0, 1, 1, 1, 2, 2, 3, 3])
  119:     minor_codes = np.array([0, 1, 0, 1, 1, 0, 1, 0, 1])
  120:     index = MultiIndex(
  121:         levels=[major_axis, minor_axis], codes=[major_codes, minor_codes]
  122:     )
  123: 
  124:     assert index.is_unique is False
  125: 
  126: 
  127: @pytest.mark.slow
  128: def test_hash_collisions(monkeypatch):
  129:     # non-smoke test that we don't get hash collisions
  130:     size_cutoff = 50
  131:     with monkeypatch.context() as m:
  132:         m.setattr(libindex, "_SIZE_CUTOFF", size_cutoff)
  133:         index = MultiIndex.from_product(
  134:             [np.arange(8), np.arange(8)], names=["one", "two"]
  135:         )
  136:         result = index.get_indexer(index.values)
  137:         tm.assert_numpy_array_equal(result, np.arange(len(index), dtype="intp"))
  138: 
  139:         for i in [0, 1, len(index) - 2, len(index) - 1]:
  140:             result = index.get_loc(index[i])
  141:             assert result == i
  142: 
  143: 
  144: def test_dims():
  145:     pass
  146: 
  147: 
  148: def test_take_invalid_kwargs():
  149:     vals = [["A", "B"], [pd.Timestamp("2011-01-01"), pd.Timestamp("2011-01-02")]]
  150:     idx = MultiIndex.from_product(vals, names=["str", "dt"])
  151:     indices = [1, 2]
  152: 
  153:     msg = r"take\(\) got an unexpected keyword argument 'foo'"
  154:     with pytest.raises(TypeError, match=msg):
  155:         idx.take(indices, foo=2)
  156: 
  157:     msg = "the 'out' parameter is not supported"
  158:     with pytest.raises(ValueError, match=msg):
  159:         idx.take(indices, out=indices)
  160: 
  161:     msg = "the 'mode' parameter is not supported"
  162:     with pytest.raises(ValueError, match=msg):
  163:         idx.take(indices, mode="clip")
  164: 
  165: 
  166: def test_isna_behavior(idx):
  167:     # should not segfault GH5123
  168:     # NOTE: if MI representation changes, may make sense to allow
  169:     # isna(MI)
  170:     msg = "isna is not defined for MultiIndex"
  171:     with pytest.raises(NotImplementedError, match=msg):
  172:         pd.isna(idx)
  173: 
  174: 
  175: def test_large_multiindex_error(monkeypatch):
  176:     # GH12527
  177:     size_cutoff = 50
  178:     with monkeypatch.context() as m:
  179:         m.setattr(libindex, "_SIZE_CUTOFF", size_cutoff)
  180:         df_below_cutoff = pd.DataFrame(
  181:             1,
  182:             index=MultiIndex.from_product([[1, 2], range(size_cutoff - 1)]),
  183:             columns=["dest"],
  184:         )
  185:         with pytest.raises(KeyError, match=r"^\(-1, 0\)$"):
  186:             df_below_cutoff.loc[(-1, 0), "dest"]
  187:         with pytest.raises(KeyError, match=r"^\(3, 0\)$"):
  188:             df_below_cutoff.loc[(3, 0), "dest"]
  189:         df_above_cutoff = pd.DataFrame(
  190:             1,
  191:             index=MultiIndex.from_product([[1, 2], range(size_cutoff + 1)]),
  192:             columns=["dest"],
  193:         )
  194:         with pytest.raises(KeyError, match=r"^\(-1, 0\)$"):
  195:             df_above_cutoff.loc[(-1, 0), "dest"]
  196:         with pytest.raises(KeyError, match=r"^\(3, 0\)$"):
  197:             df_above_cutoff.loc[(3, 0), "dest"]
  198: 
  199: 
  200: def test_mi_hashtable_populated_attribute_error(monkeypatch):
  201:     # GH 18165
  202:     monkeypatch.setattr(libindex, "_SIZE_CUTOFF", 50)
  203:     r = range(50)
  204:     df = pd.DataFrame({"a": r, "b": r}, index=MultiIndex.from_arrays([r, r]))
  205: 
  206:     msg = "'Series' object has no attribute 'foo'"
  207:     with pytest.raises(AttributeError, match=msg):
  208:         df["a"].foo()
  209: 
  210: 
  211: def test_can_hold_identifiers(idx):
  212:     key = idx[0]
  213:     assert idx._can_hold_identifiers_and_holds_name(key) is True
  214: 
  215: 
  216: def test_metadata_immutable(idx):
  217:     levels, codes = idx.levels, idx.codes
  218:     # shouldn't be able to set at either the top level or base level
  219:     mutable_regex = re.compile("does not support mutable operations")
  220:     with pytest.raises(TypeError, match=mutable_regex):
  221:         levels[0] = levels[0]
  222:     with pytest.raises(TypeError, match=mutable_regex):
  223:         levels[0][0] = levels[0][0]
  224:     # ditto for labels
  225:     with pytest.raises(TypeError, match=mutable_regex):
  226:         codes[0] = codes[0]
  227:     with pytest.raises(ValueError, match="assignment destination is read-only"):
  228:         codes[0][0] = codes[0][0]
  229:     # and for names
  230:     names = idx.names
  231:     with pytest.raises(TypeError, match=mutable_regex):
  232:         names[0] = names[0]
  233: 
  234: 
  235: def test_level_setting_resets_attributes():
  236:     ind = MultiIndex.from_arrays([["A", "A", "B", "B", "B"], [1, 2, 1, 2, 3]])
  237:     assert ind.is_monotonic_increasing
  238:     ind = ind.set_levels([["A", "B"], [1, 3, 2]])
  239:     # if this fails, probably didn't reset the cache correctly.
  240:     assert not ind.is_monotonic_increasing
  241: 
  242: 
  243: def test_rangeindex_fallback_coercion_bug():
  244:     # GH 12893
  245:     df1 = pd.DataFrame(np.arange(100).reshape((10, 10)))
  246:     df2 = pd.DataFrame(np.arange(100).reshape((10, 10)))
  247:     df = pd.concat(
  248:         {"df1": df1.stack(future_stack=True), "df2": df2.stack(future_stack=True)},
  249:         axis=1,
  250:     )
  251:     df.index.names = ["fizz", "buzz"]
  252: 
  253:     expected = pd.DataFrame(
  254:         {"df2": np.arange(100), "df1": np.arange(100)},
  255:         index=MultiIndex.from_product([range(10), range(10)], names=["fizz", "buzz"]),
  256:     )
  257:     tm.assert_frame_equal(df, expected, check_like=True)
  258: 
  259:     result = df.index.get_level_values("fizz")
  260:     expected = Index(np.arange(10, dtype=np.int64), name="fizz").repeat(10)
  261:     tm.assert_index_equal(result, expected)
  262: 
  263:     result = df.index.get_level_values("buzz")
  264:     expected = Index(np.tile(np.arange(10, dtype=np.int64), 10), name="buzz")
  265:     tm.assert_index_equal(result, expected)
  266: 
  267: 
  268: def test_memory_usage(idx):
  269:     result = idx.memory_usage()
  270:     if len(idx):
  271:         idx.get_loc(idx[0])
  272:         result2 = idx.memory_usage()
  273:         result3 = idx.memory_usage(deep=True)
  274: 
  275:         # RangeIndex, IntervalIndex
  276:         # don't have engines
  277:         if not isinstance(idx, (RangeIndex, IntervalIndex)):
  278:             assert result2 > result
  279: 
  280:         if idx.inferred_type == "object":
  281:             assert result3 > result2
  282: 
  283:     else:
  284:         # we report 0 for no-length
  285:         assert result == 0
  286: 
  287: 
  288: def test_nlevels(idx):
  289:     assert idx.nlevels == 2
