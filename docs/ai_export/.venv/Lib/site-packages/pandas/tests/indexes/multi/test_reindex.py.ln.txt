    1: import numpy as np
    2: import pytest
    3: 
    4: import pandas as pd
    5: from pandas import (
    6:     Index,
    7:     MultiIndex,
    8: )
    9: import pandas._testing as tm
   10: 
   11: 
   12: def test_reindex(idx):
   13:     result, indexer = idx.reindex(list(idx[:4]))
   14:     assert isinstance(result, MultiIndex)
   15:     assert result.names == ["first", "second"]
   16:     assert [level.name for level in result.levels] == ["first", "second"]
   17: 
   18:     result, indexer = idx.reindex(list(idx))
   19:     assert isinstance(result, MultiIndex)
   20:     assert indexer is None
   21:     assert result.names == ["first", "second"]
   22:     assert [level.name for level in result.levels] == ["first", "second"]
   23: 
   24: 
   25: def test_reindex_level(idx):
   26:     index = Index(["one"])
   27: 
   28:     target, indexer = idx.reindex(index, level="second")
   29:     target2, indexer2 = index.reindex(idx, level="second")
   30: 
   31:     exp_index = idx.join(index, level="second", how="right")
   32:     exp_index2 = idx.join(index, level="second", how="left")
   33: 
   34:     assert target.equals(exp_index)
   35:     exp_indexer = np.array([0, 2, 4])
   36:     tm.assert_numpy_array_equal(indexer, exp_indexer, check_dtype=False)
   37: 
   38:     assert target2.equals(exp_index2)
   39:     exp_indexer2 = np.array([0, -1, 0, -1, 0, -1])
   40:     tm.assert_numpy_array_equal(indexer2, exp_indexer2, check_dtype=False)
   41: 
   42:     with pytest.raises(TypeError, match="Fill method not supported"):
   43:         idx.reindex(idx, method="pad", level="second")
   44: 
   45: 
   46: def test_reindex_preserves_names_when_target_is_list_or_ndarray(idx):
   47:     # GH6552
   48:     idx = idx.copy()
   49:     target = idx.copy()
   50:     idx.names = target.names = [None, None]
   51: 
   52:     other_dtype = MultiIndex.from_product([[1, 2], [3, 4]])
   53: 
   54:     # list & ndarray cases
   55:     assert idx.reindex([])[0].names == [None, None]
   56:     assert idx.reindex(np.array([]))[0].names == [None, None]
   57:     assert idx.reindex(target.tolist())[0].names == [None, None]
   58:     assert idx.reindex(target.values)[0].names == [None, None]
   59:     assert idx.reindex(other_dtype.tolist())[0].names == [None, None]
   60:     assert idx.reindex(other_dtype.values)[0].names == [None, None]
   61: 
   62:     idx.names = ["foo", "bar"]
   63:     assert idx.reindex([])[0].names == ["foo", "bar"]
   64:     assert idx.reindex(np.array([]))[0].names == ["foo", "bar"]
   65:     assert idx.reindex(target.tolist())[0].names == ["foo", "bar"]
   66:     assert idx.reindex(target.values)[0].names == ["foo", "bar"]
   67:     assert idx.reindex(other_dtype.tolist())[0].names == ["foo", "bar"]
   68:     assert idx.reindex(other_dtype.values)[0].names == ["foo", "bar"]
   69: 
   70: 
   71: def test_reindex_lvl_preserves_names_when_target_is_list_or_array():
   72:     # GH7774
   73:     idx = MultiIndex.from_product([[0, 1], ["a", "b"]], names=["foo", "bar"])
   74:     assert idx.reindex([], level=0)[0].names == ["foo", "bar"]
   75:     assert idx.reindex([], level=1)[0].names == ["foo", "bar"]
   76: 
   77: 
   78: def test_reindex_lvl_preserves_type_if_target_is_empty_list_or_array(
   79:     using_infer_string,
   80: ):
   81:     # GH7774
   82:     idx = MultiIndex.from_product([[0, 1], ["a", "b"]])
   83:     assert idx.reindex([], level=0)[0].levels[0].dtype.type == np.int64
   84:     exp = np.object_ if not using_infer_string else str
   85:     assert idx.reindex([], level=1)[0].levels[1].dtype.type == exp
   86: 
   87:     # case with EA levels
   88:     cat = pd.Categorical(["foo", "bar"])
   89:     dti = pd.date_range("2016-01-01", periods=2, tz="US/Pacific")
   90:     mi = MultiIndex.from_product([cat, dti])
   91:     assert mi.reindex([], level=0)[0].levels[0].dtype == cat.dtype
   92:     assert mi.reindex([], level=1)[0].levels[1].dtype == dti.dtype
   93: 
   94: 
   95: def test_reindex_base(idx):
   96:     expected = np.arange(idx.size, dtype=np.intp)
   97: 
   98:     actual = idx.get_indexer(idx)
   99:     tm.assert_numpy_array_equal(expected, actual)
  100: 
  101:     with pytest.raises(ValueError, match="Invalid fill method"):
  102:         idx.get_indexer(idx, method="invalid")
  103: 
  104: 
  105: def test_reindex_non_unique():
  106:     idx = MultiIndex.from_tuples([(0, 0), (1, 1), (1, 1), (2, 2)])
  107:     a = pd.Series(np.arange(4), index=idx)
  108:     new_idx = MultiIndex.from_tuples([(0, 0), (1, 1), (2, 2)])
  109: 
  110:     msg = "cannot handle a non-unique multi-index!"
  111:     with pytest.raises(ValueError, match=msg):
  112:         a.reindex(new_idx)
  113: 
  114: 
  115: @pytest.mark.parametrize("values", [[["a"], ["x"]], [[], []]])
  116: def test_reindex_empty_with_level(values):
  117:     # GH41170
  118:     idx = MultiIndex.from_arrays(values)
  119:     result, result_indexer = idx.reindex(np.array(["b"]), level=0)
  120:     expected = MultiIndex(levels=[["b"], values[1]], codes=[[], []])
  121:     expected_indexer = np.array([], dtype=result_indexer.dtype)
  122:     tm.assert_index_equal(result, expected)
  123:     tm.assert_numpy_array_equal(result_indexer, expected_indexer)
  124: 
  125: 
  126: def test_reindex_not_all_tuples():
  127:     keys = [("i", "i"), ("i", "j"), ("j", "i"), "j"]
  128:     mi = MultiIndex.from_tuples(keys[:-1])
  129:     idx = Index(keys)
  130:     res, indexer = mi.reindex(idx)
  131: 
  132:     tm.assert_index_equal(res, idx)
  133:     expected = np.array([0, 1, 2, -1], dtype=np.intp)
  134:     tm.assert_numpy_array_equal(indexer, expected)
  135: 
  136: 
  137: def test_reindex_limit_arg_with_multiindex():
  138:     # GH21247
  139: 
  140:     idx = MultiIndex.from_tuples([(3, "A"), (4, "A"), (4, "B")])
  141: 
  142:     df = pd.Series([0.02, 0.01, 0.012], index=idx)
  143: 
  144:     new_idx = MultiIndex.from_tuples(
  145:         [
  146:             (3, "A"),
  147:             (3, "B"),
  148:             (4, "A"),
  149:             (4, "B"),
  150:             (4, "C"),
  151:             (5, "B"),
  152:             (5, "C"),
  153:             (6, "B"),
  154:             (6, "C"),
  155:         ]
  156:     )
  157: 
  158:     with pytest.raises(
  159:         ValueError,
  160:         match="limit argument only valid if doing pad, backfill or nearest reindexing",
  161:     ):
  162:         df.reindex(new_idx, fill_value=0, limit=1)
  163: 
  164: 
  165: def test_reindex_with_none_in_nested_multiindex():
  166:     # GH42883
  167:     index = MultiIndex.from_tuples([(("a", None), 1), (("b", None), 2)])
  168:     index2 = MultiIndex.from_tuples([(("b", None), 2), (("a", None), 1)])
  169:     df1_dtype = pd.DataFrame([1, 2], index=index)
  170:     df2_dtype = pd.DataFrame([2, 1], index=index2)
  171: 
  172:     result = df1_dtype.reindex_like(df2_dtype)
  173:     expected = df2_dtype
  174:     tm.assert_frame_equal(result, expected)
