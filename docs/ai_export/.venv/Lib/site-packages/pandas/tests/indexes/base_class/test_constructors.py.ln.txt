    1: import numpy as np
    2: import pytest
    3: 
    4: import pandas as pd
    5: from pandas import (
    6:     Index,
    7:     MultiIndex,
    8:     Series,
    9: )
   10: import pandas._testing as tm
   11: 
   12: 
   13: class TestIndexConstructor:
   14:     # Tests for the Index constructor, specifically for cases that do
   15:     #  not return a subclass
   16: 
   17:     @pytest.mark.parametrize("value", [1, np.int64(1)])
   18:     def test_constructor_corner(self, value):
   19:         # corner case
   20:         msg = (
   21:             r"Index\(\.\.\.\) must be called with a collection of some "
   22:             f"kind, {value} was passed"
   23:         )
   24:         with pytest.raises(TypeError, match=msg):
   25:             Index(value)
   26: 
   27:     @pytest.mark.parametrize("index_vals", [[("A", 1), "B"], ["B", ("A", 1)]])
   28:     def test_construction_list_mixed_tuples(self, index_vals):
   29:         # see gh-10697: if we are constructing from a mixed list of tuples,
   30:         # make sure that we are independent of the sorting order.
   31:         index = Index(index_vals)
   32:         assert isinstance(index, Index)
   33:         assert not isinstance(index, MultiIndex)
   34: 
   35:     def test_constructor_cast(self):
   36:         msg = "could not convert string to float"
   37:         with pytest.raises(ValueError, match=msg):
   38:             Index(["a", "b", "c"], dtype=float)
   39: 
   40:     @pytest.mark.parametrize("tuple_list", [[()], [(), ()]])
   41:     def test_construct_empty_tuples(self, tuple_list):
   42:         # GH #45608
   43:         result = Index(tuple_list)
   44:         expected = MultiIndex.from_tuples(tuple_list)
   45: 
   46:         tm.assert_index_equal(result, expected)
   47: 
   48:     def test_index_string_inference(self):
   49:         # GH#54430
   50:         pytest.importorskip("pyarrow")
   51:         dtype = "string[pyarrow_numpy]"
   52:         expected = Index(["a", "b"], dtype=dtype)
   53:         with pd.option_context("future.infer_string", True):
   54:             ser = Index(["a", "b"])
   55:         tm.assert_index_equal(ser, expected)
   56: 
   57:         expected = Index(["a", 1], dtype="object")
   58:         with pd.option_context("future.infer_string", True):
   59:             ser = Index(["a", 1])
   60:         tm.assert_index_equal(ser, expected)
   61: 
   62:     def test_inference_on_pandas_objects(self):
   63:         # GH#56012
   64:         idx = Index([pd.Timestamp("2019-12-31")], dtype=object)
   65:         with tm.assert_produces_warning(FutureWarning, match="Dtype inference"):
   66:             result = Index(idx)
   67:         assert result.dtype != np.object_
   68: 
   69:         ser = Series([pd.Timestamp("2019-12-31")], dtype=object)
   70: 
   71:         with tm.assert_produces_warning(FutureWarning, match="Dtype inference"):
   72:             result = Index(ser)
   73:         assert result.dtype != np.object_
   74: 
   75:     def test_constructor_not_read_only(self):
   76:         # GH#57130
   77:         ser = Series([1, 2], dtype=object)
   78:         with pd.option_context("mode.copy_on_write", True):
   79:             idx = Index(ser)
   80:             assert idx._values.flags.writeable
