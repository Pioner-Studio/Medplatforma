    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas import (
    5:     DataFrame,
    6:     PeriodIndex,
    7:     Series,
    8:     date_range,
    9:     period_range,
   10: )
   11: import pandas._testing as tm
   12: 
   13: 
   14: class TestPeriodIndex:
   15:     def test_getitem_periodindex_duplicates_string_slice(
   16:         self, using_copy_on_write, warn_copy_on_write
   17:     ):
   18:         # monotonic
   19:         idx = PeriodIndex([2000, 2007, 2007, 2009, 2009], freq="Y-JUN")
   20:         ts = Series(np.random.default_rng(2).standard_normal(len(idx)), index=idx)
   21:         original = ts.copy()
   22: 
   23:         result = ts["2007"]
   24:         expected = ts[1:3]
   25:         tm.assert_series_equal(result, expected)
   26:         with tm.assert_cow_warning(warn_copy_on_write):
   27:             result[:] = 1
   28:         if using_copy_on_write:
   29:             tm.assert_series_equal(ts, original)
   30:         else:
   31:             assert (ts[1:3] == 1).all()
   32: 
   33:         # not monotonic
   34:         idx = PeriodIndex([2000, 2007, 2007, 2009, 2007], freq="Y-JUN")
   35:         ts = Series(np.random.default_rng(2).standard_normal(len(idx)), index=idx)
   36: 
   37:         result = ts["2007"]
   38:         expected = ts[idx == "2007"]
   39:         tm.assert_series_equal(result, expected)
   40: 
   41:     def test_getitem_periodindex_quarter_string(self):
   42:         pi = PeriodIndex(["2Q05", "3Q05", "4Q05", "1Q06", "2Q06"], freq="Q")
   43:         ser = Series(np.random.default_rng(2).random(len(pi)), index=pi).cumsum()
   44:         # Todo: fix these accessors!
   45:         assert ser["05Q4"] == ser.iloc[2]
   46: 
   47:     def test_pindex_slice_index(self):
   48:         pi = period_range(start="1/1/10", end="12/31/12", freq="M")
   49:         s = Series(np.random.default_rng(2).random(len(pi)), index=pi)
   50:         res = s["2010"]
   51:         exp = s[0:12]
   52:         tm.assert_series_equal(res, exp)
   53:         res = s["2011"]
   54:         exp = s[12:24]
   55:         tm.assert_series_equal(res, exp)
   56: 
   57:     @pytest.mark.parametrize("make_range", [date_range, period_range])
   58:     def test_range_slice_day(self, make_range):
   59:         # GH#6716
   60:         idx = make_range(start="2013/01/01", freq="D", periods=400)
   61: 
   62:         msg = "slice indices must be integers or None or have an __index__ method"
   63:         # slices against index should raise IndexError
   64:         values = [
   65:             "2014",
   66:             "2013/02",
   67:             "2013/01/02",
   68:             "2013/02/01 9H",
   69:             "2013/02/01 09:00",
   70:         ]
   71:         for v in values:
   72:             with pytest.raises(TypeError, match=msg):
   73:                 idx[v:]
   74: 
   75:         s = Series(np.random.default_rng(2).random(len(idx)), index=idx)
   76: 
   77:         tm.assert_series_equal(s["2013/01/02":], s[1:])
   78:         tm.assert_series_equal(s["2013/01/02":"2013/01/05"], s[1:5])
   79:         tm.assert_series_equal(s["2013/02":], s[31:])
   80:         tm.assert_series_equal(s["2014":], s[365:])
   81: 
   82:         invalid = ["2013/02/01 9H", "2013/02/01 09:00"]
   83:         for v in invalid:
   84:             with pytest.raises(TypeError, match=msg):
   85:                 idx[v:]
   86: 
   87:     @pytest.mark.parametrize("make_range", [date_range, period_range])
   88:     def test_range_slice_seconds(self, make_range):
   89:         # GH#6716
   90:         idx = make_range(start="2013/01/01 09:00:00", freq="s", periods=4000)
   91:         msg = "slice indices must be integers or None or have an __index__ method"
   92: 
   93:         # slices against index should raise IndexError
   94:         values = [
   95:             "2014",
   96:             "2013/02",
   97:             "2013/01/02",
   98:             "2013/02/01 9H",
   99:             "2013/02/01 09:00",
  100:         ]
  101:         for v in values:
  102:             with pytest.raises(TypeError, match=msg):
  103:                 idx[v:]
  104: 
  105:         s = Series(np.random.default_rng(2).random(len(idx)), index=idx)
  106: 
  107:         tm.assert_series_equal(s["2013/01/01 09:05":"2013/01/01 09:10"], s[300:660])
  108:         tm.assert_series_equal(s["2013/01/01 10:00":"2013/01/01 10:05"], s[3600:3960])
  109:         tm.assert_series_equal(s["2013/01/01 10H":], s[3600:])
  110:         tm.assert_series_equal(s[:"2013/01/01 09:30"], s[:1860])
  111:         for d in ["2013/01/01", "2013/01", "2013"]:
  112:             tm.assert_series_equal(s[d:], s)
  113: 
  114:     @pytest.mark.parametrize("make_range", [date_range, period_range])
  115:     def test_range_slice_outofbounds(self, make_range):
  116:         # GH#5407
  117:         idx = make_range(start="2013/10/01", freq="D", periods=10)
  118: 
  119:         df = DataFrame({"units": [100 + i for i in range(10)]}, index=idx)
  120:         empty = DataFrame(index=idx[:0], columns=["units"])
  121:         empty["units"] = empty["units"].astype("int64")
  122: 
  123:         tm.assert_frame_equal(df["2013/09/01":"2013/09/30"], empty)
  124:         tm.assert_frame_equal(df["2013/09/30":"2013/10/02"], df.iloc[:2])
  125:         tm.assert_frame_equal(df["2013/10/01":"2013/10/02"], df.iloc[:2])
  126:         tm.assert_frame_equal(df["2013/10/02":"2013/09/30"], empty)
  127:         tm.assert_frame_equal(df["2013/10/15":"2013/10/17"], empty)
  128:         tm.assert_frame_equal(df["2013-06":"2013-09"], empty)
  129:         tm.assert_frame_equal(df["2013-11":"2013-12"], empty)
  130: 
  131:     @pytest.mark.parametrize("make_range", [date_range, period_range])
  132:     def test_maybe_cast_slice_bound(self, make_range, frame_or_series):
  133:         idx = make_range(start="2013/10/01", freq="D", periods=10)
  134: 
  135:         obj = DataFrame({"units": [100 + i for i in range(10)]}, index=idx)
  136:         obj = tm.get_obj(obj, frame_or_series)
  137: 
  138:         msg = (
  139:             f"cannot do slice indexing on {type(idx).__name__} with "
  140:             r"these indexers \[foo\] of type str"
  141:         )
  142: 
  143:         # Check the lower-level calls are raising where expected.
  144:         with pytest.raises(TypeError, match=msg):
  145:             idx._maybe_cast_slice_bound("foo", "left")
  146:         with pytest.raises(TypeError, match=msg):
  147:             idx.get_slice_bound("foo", "left")
  148: 
  149:         with pytest.raises(TypeError, match=msg):
  150:             obj["2013/09/30":"foo"]
  151:         with pytest.raises(TypeError, match=msg):
  152:             obj["foo":"2013/09/30"]
  153:         with pytest.raises(TypeError, match=msg):
  154:             obj.loc["2013/09/30":"foo"]
  155:         with pytest.raises(TypeError, match=msg):
  156:             obj.loc["foo":"2013/09/30"]
  157: 
  158:     def test_partial_slice_doesnt_require_monotonicity(self):
  159:         # See also: DatetimeIndex test ofm the same name
  160:         dti = date_range("2014-01-01", periods=30, freq="30D")
  161:         pi = dti.to_period("D")
  162: 
  163:         ser_montonic = Series(np.arange(30), index=pi)
  164: 
  165:         shuffler = list(range(0, 30, 2)) + list(range(1, 31, 2))
  166:         ser = ser_montonic.iloc[shuffler]
  167:         nidx = ser.index
  168: 
  169:         # Manually identified locations of year==2014
  170:         indexer_2014 = np.array(
  171:             [0, 1, 2, 3, 4, 5, 6, 15, 16, 17, 18, 19, 20], dtype=np.intp
  172:         )
  173:         assert (nidx[indexer_2014].year == 2014).all()
  174:         assert not (nidx[~indexer_2014].year == 2014).any()
  175: 
  176:         result = nidx.get_loc("2014")
  177:         tm.assert_numpy_array_equal(result, indexer_2014)
  178: 
  179:         expected = ser.iloc[indexer_2014]
  180:         result = ser.loc["2014"]
  181:         tm.assert_series_equal(result, expected)
  182: 
  183:         result = ser["2014"]
  184:         tm.assert_series_equal(result, expected)
  185: 
  186:         # Manually identified locations where ser.index is within Mat 2015
  187:         indexer_may2015 = np.array([23], dtype=np.intp)
  188:         assert nidx[23].year == 2015 and nidx[23].month == 5
  189: 
  190:         result = nidx.get_loc("May 2015")
  191:         tm.assert_numpy_array_equal(result, indexer_may2015)
  192: 
  193:         expected = ser.iloc[indexer_may2015]
  194:         result = ser.loc["May 2015"]
  195:         tm.assert_series_equal(result, expected)
  196: 
  197:         result = ser["May 2015"]
  198:         tm.assert_series_equal(result, expected)
