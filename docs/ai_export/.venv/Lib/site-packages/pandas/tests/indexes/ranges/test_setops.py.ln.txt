    1: from datetime import (
    2:     datetime,
    3:     timedelta,
    4: )
    5: 
    6: from hypothesis import (
    7:     assume,
    8:     given,
    9:     strategies as st,
   10: )
   11: import numpy as np
   12: import pytest
   13: 
   14: from pandas import (
   15:     Index,
   16:     RangeIndex,
   17: )
   18: import pandas._testing as tm
   19: 
   20: 
   21: class TestRangeIndexSetOps:
   22:     @pytest.mark.parametrize("dtype", [None, "int64", "uint64"])
   23:     def test_intersection_mismatched_dtype(self, dtype):
   24:         # check that we cast to float, not object
   25:         index = RangeIndex(start=0, stop=20, step=2, name="foo")
   26:         index = Index(index, dtype=dtype)
   27: 
   28:         flt = index.astype(np.float64)
   29: 
   30:         # bc index.equals(flt), we go through fastpath and get RangeIndex back
   31:         result = index.intersection(flt)
   32:         tm.assert_index_equal(result, index, exact=True)
   33: 
   34:         result = flt.intersection(index)
   35:         tm.assert_index_equal(result, flt, exact=True)
   36: 
   37:         # neither empty, not-equals
   38:         result = index.intersection(flt[1:])
   39:         tm.assert_index_equal(result, flt[1:], exact=True)
   40: 
   41:         result = flt[1:].intersection(index)
   42:         tm.assert_index_equal(result, flt[1:], exact=True)
   43: 
   44:         # empty other
   45:         result = index.intersection(flt[:0])
   46:         tm.assert_index_equal(result, flt[:0], exact=True)
   47: 
   48:         result = flt[:0].intersection(index)
   49:         tm.assert_index_equal(result, flt[:0], exact=True)
   50: 
   51:     def test_intersection_empty(self, sort, names):
   52:         # name retention on empty intersections
   53:         index = RangeIndex(start=0, stop=20, step=2, name=names[0])
   54: 
   55:         # empty other
   56:         result = index.intersection(index[:0].rename(names[1]), sort=sort)
   57:         tm.assert_index_equal(result, index[:0].rename(names[2]), exact=True)
   58: 
   59:         # empty self
   60:         result = index[:0].intersection(index.rename(names[1]), sort=sort)
   61:         tm.assert_index_equal(result, index[:0].rename(names[2]), exact=True)
   62: 
   63:     def test_intersection(self, sort):
   64:         # intersect with Index with dtype int64
   65:         index = RangeIndex(start=0, stop=20, step=2)
   66:         other = Index(np.arange(1, 6))
   67:         result = index.intersection(other, sort=sort)
   68:         expected = Index(np.sort(np.intersect1d(index.values, other.values)))
   69:         tm.assert_index_equal(result, expected)
   70: 
   71:         result = other.intersection(index, sort=sort)
   72:         expected = Index(
   73:             np.sort(np.asarray(np.intersect1d(index.values, other.values)))
   74:         )
   75:         tm.assert_index_equal(result, expected)
   76: 
   77:         # intersect with increasing RangeIndex
   78:         other = RangeIndex(1, 6)
   79:         result = index.intersection(other, sort=sort)
   80:         expected = Index(np.sort(np.intersect1d(index.values, other.values)))
   81:         tm.assert_index_equal(result, expected, exact="equiv")
   82: 
   83:         # intersect with decreasing RangeIndex
   84:         other = RangeIndex(5, 0, -1)
   85:         result = index.intersection(other, sort=sort)
   86:         expected = Index(np.sort(np.intersect1d(index.values, other.values)))
   87:         tm.assert_index_equal(result, expected, exact="equiv")
   88: 
   89:         # reversed (GH 17296)
   90:         result = other.intersection(index, sort=sort)
   91:         tm.assert_index_equal(result, expected, exact="equiv")
   92: 
   93:         # GH 17296: intersect two decreasing RangeIndexes
   94:         first = RangeIndex(10, -2, -2)
   95:         other = RangeIndex(5, -4, -1)
   96:         expected = first.astype(int).intersection(other.astype(int), sort=sort)
   97:         result = first.intersection(other, sort=sort).astype(int)
   98:         tm.assert_index_equal(result, expected)
   99: 
  100:         # reversed
  101:         result = other.intersection(first, sort=sort).astype(int)
  102:         tm.assert_index_equal(result, expected)
  103: 
  104:         index = RangeIndex(5, name="foo")
  105: 
  106:         # intersect of non-overlapping indices
  107:         other = RangeIndex(5, 10, 1, name="foo")
  108:         result = index.intersection(other, sort=sort)
  109:         expected = RangeIndex(0, 0, 1, name="foo")
  110:         tm.assert_index_equal(result, expected)
  111: 
  112:         other = RangeIndex(-1, -5, -1)
  113:         result = index.intersection(other, sort=sort)
  114:         expected = RangeIndex(0, 0, 1)
  115:         tm.assert_index_equal(result, expected)
  116: 
  117:         # intersection of empty indices
  118:         other = RangeIndex(0, 0, 1)
  119:         result = index.intersection(other, sort=sort)
  120:         expected = RangeIndex(0, 0, 1)
  121:         tm.assert_index_equal(result, expected)
  122: 
  123:         result = other.intersection(index, sort=sort)
  124:         tm.assert_index_equal(result, expected)
  125: 
  126:     def test_intersection_non_overlapping_gcd(self, sort, names):
  127:         # intersection of non-overlapping values based on start value and gcd
  128:         index = RangeIndex(1, 10, 2, name=names[0])
  129:         other = RangeIndex(0, 10, 4, name=names[1])
  130:         result = index.intersection(other, sort=sort)
  131:         expected = RangeIndex(0, 0, 1, name=names[2])
  132:         tm.assert_index_equal(result, expected)
  133: 
  134:     def test_union_noncomparable(self, sort):
  135:         # corner case, Index with non-int64 dtype
  136:         index = RangeIndex(start=0, stop=20, step=2)
  137:         other = Index([datetime.now() + timedelta(i) for i in range(4)], dtype=object)
  138:         result = index.union(other, sort=sort)
  139:         expected = Index(np.concatenate((index, other)))
  140:         tm.assert_index_equal(result, expected)
  141: 
  142:         result = other.union(index, sort=sort)
  143:         expected = Index(np.concatenate((other, index)))
  144:         tm.assert_index_equal(result, expected)
  145: 
  146:     @pytest.mark.parametrize(
  147:         "idx1, idx2, expected_sorted, expected_notsorted",
  148:         [
  149:             (
  150:                 RangeIndex(0, 10, 1),
  151:                 RangeIndex(0, 10, 1),
  152:                 RangeIndex(0, 10, 1),
  153:                 RangeIndex(0, 10, 1),
  154:             ),
  155:             (
  156:                 RangeIndex(0, 10, 1),
  157:                 RangeIndex(5, 20, 1),
  158:                 RangeIndex(0, 20, 1),
  159:                 RangeIndex(0, 20, 1),
  160:             ),
  161:             (
  162:                 RangeIndex(0, 10, 1),
  163:                 RangeIndex(10, 20, 1),
  164:                 RangeIndex(0, 20, 1),
  165:                 RangeIndex(0, 20, 1),
  166:             ),
  167:             (
  168:                 RangeIndex(0, -10, -1),
  169:                 RangeIndex(0, -10, -1),
  170:                 RangeIndex(0, -10, -1),
  171:                 RangeIndex(0, -10, -1),
  172:             ),
  173:             (
  174:                 RangeIndex(0, -10, -1),
  175:                 RangeIndex(-10, -20, -1),
  176:                 RangeIndex(-19, 1, 1),
  177:                 RangeIndex(0, -20, -1),
  178:             ),
  179:             (
  180:                 RangeIndex(0, 10, 2),
  181:                 RangeIndex(1, 10, 2),
  182:                 RangeIndex(0, 10, 1),
  183:                 Index(list(range(0, 10, 2)) + list(range(1, 10, 2))),
  184:             ),
  185:             (
  186:                 RangeIndex(0, 11, 2),
  187:                 RangeIndex(1, 12, 2),
  188:                 RangeIndex(0, 12, 1),
  189:                 Index(list(range(0, 11, 2)) + list(range(1, 12, 2))),
  190:             ),
  191:             (
  192:                 RangeIndex(0, 21, 4),
  193:                 RangeIndex(-2, 24, 4),
  194:                 RangeIndex(-2, 24, 2),
  195:                 Index(list(range(0, 21, 4)) + list(range(-2, 24, 4))),
  196:             ),
  197:             (
  198:                 RangeIndex(0, -20, -2),
  199:                 RangeIndex(-1, -21, -2),
  200:                 RangeIndex(-19, 1, 1),
  201:                 Index(list(range(0, -20, -2)) + list(range(-1, -21, -2))),
  202:             ),
  203:             (
  204:                 RangeIndex(0, 100, 5),
  205:                 RangeIndex(0, 100, 20),
  206:                 RangeIndex(0, 100, 5),
  207:                 RangeIndex(0, 100, 5),
  208:             ),
  209:             (
  210:                 RangeIndex(0, -100, -5),
  211:                 RangeIndex(5, -100, -20),
  212:                 RangeIndex(-95, 10, 5),
  213:                 Index(list(range(0, -100, -5)) + [5]),
  214:             ),
  215:             (
  216:                 RangeIndex(0, -11, -1),
  217:                 RangeIndex(1, -12, -4),
  218:                 RangeIndex(-11, 2, 1),
  219:                 Index(list(range(0, -11, -1)) + [1, -11]),
  220:             ),
  221:             (RangeIndex(0), RangeIndex(0), RangeIndex(0), RangeIndex(0)),
  222:             (
  223:                 RangeIndex(0, -10, -2),
  224:                 RangeIndex(0),
  225:                 RangeIndex(0, -10, -2),
  226:                 RangeIndex(0, -10, -2),
  227:             ),
  228:             (
  229:                 RangeIndex(0, 100, 2),
  230:                 RangeIndex(100, 150, 200),
  231:                 RangeIndex(0, 102, 2),
  232:                 RangeIndex(0, 102, 2),
  233:             ),
  234:             (
  235:                 RangeIndex(0, -100, -2),
  236:                 RangeIndex(-100, 50, 102),
  237:                 RangeIndex(-100, 4, 2),
  238:                 Index(list(range(0, -100, -2)) + [-100, 2]),
  239:             ),
  240:             (
  241:                 RangeIndex(0, -100, -1),
  242:                 RangeIndex(0, -50, -3),
  243:                 RangeIndex(-99, 1, 1),
  244:                 RangeIndex(0, -100, -1),
  245:             ),
  246:             (
  247:                 RangeIndex(0, 1, 1),
  248:                 RangeIndex(5, 6, 10),
  249:                 RangeIndex(0, 6, 5),
  250:                 RangeIndex(0, 10, 5),
  251:             ),
  252:             (
  253:                 RangeIndex(0, 10, 5),
  254:                 RangeIndex(-5, -6, -20),
  255:                 RangeIndex(-5, 10, 5),
  256:                 Index([0, 5, -5]),
  257:             ),
  258:             (
  259:                 RangeIndex(0, 3, 1),
  260:                 RangeIndex(4, 5, 1),
  261:                 Index([0, 1, 2, 4]),
  262:                 Index([0, 1, 2, 4]),
  263:             ),
  264:             (
  265:                 RangeIndex(0, 10, 1),
  266:                 Index([], dtype=np.int64),
  267:                 RangeIndex(0, 10, 1),
  268:                 RangeIndex(0, 10, 1),
  269:             ),
  270:             (
  271:                 RangeIndex(0),
  272:                 Index([1, 5, 6]),
  273:                 Index([1, 5, 6]),
  274:                 Index([1, 5, 6]),
  275:             ),
  276:             # GH 43885
  277:             (
  278:                 RangeIndex(0, 10),
  279:                 RangeIndex(0, 5),
  280:                 RangeIndex(0, 10),
  281:                 RangeIndex(0, 10),
  282:             ),
  283:         ],
  284:         ids=lambda x: repr(x) if isinstance(x, RangeIndex) else x,
  285:     )
  286:     def test_union_sorted(self, idx1, idx2, expected_sorted, expected_notsorted):
  287:         res1 = idx1.union(idx2, sort=None)
  288:         tm.assert_index_equal(res1, expected_sorted, exact=True)
  289: 
  290:         res1 = idx1.union(idx2, sort=False)
  291:         tm.assert_index_equal(res1, expected_notsorted, exact=True)
  292: 
  293:         res2 = idx2.union(idx1, sort=None)
  294:         res3 = Index(idx1._values, name=idx1.name).union(idx2, sort=None)
  295:         tm.assert_index_equal(res2, expected_sorted, exact=True)
  296:         tm.assert_index_equal(res3, expected_sorted, exact="equiv")
  297: 
  298:     def test_union_same_step_misaligned(self):
  299:         # GH#44019
  300:         left = RangeIndex(range(0, 20, 4))
  301:         right = RangeIndex(range(1, 21, 4))
  302: 
  303:         result = left.union(right)
  304:         expected = Index([0, 1, 4, 5, 8, 9, 12, 13, 16, 17])
  305:         tm.assert_index_equal(result, expected, exact=True)
  306: 
  307:     def test_difference(self):
  308:         # GH#12034 Cases where we operate against another RangeIndex and may
  309:         #  get back another RangeIndex
  310:         obj = RangeIndex.from_range(range(1, 10), name="foo")
  311: 
  312:         result = obj.difference(obj)
  313:         expected = RangeIndex.from_range(range(0), name="foo")
  314:         tm.assert_index_equal(result, expected, exact=True)
  315: 
  316:         result = obj.difference(expected.rename("bar"))
  317:         tm.assert_index_equal(result, obj.rename(None), exact=True)
  318: 
  319:         result = obj.difference(obj[:3])
  320:         tm.assert_index_equal(result, obj[3:], exact=True)
  321: 
  322:         result = obj.difference(obj[-3:])
  323:         tm.assert_index_equal(result, obj[:-3], exact=True)
  324: 
  325:         # Flipping the step of 'other' doesn't affect the result, but
  326:         #  flipping the stepof 'self' does when sort=None
  327:         result = obj[::-1].difference(obj[-3:])
  328:         tm.assert_index_equal(result, obj[:-3], exact=True)
  329: 
  330:         result = obj[::-1].difference(obj[-3:], sort=False)
  331:         tm.assert_index_equal(result, obj[:-3][::-1], exact=True)
  332: 
  333:         result = obj[::-1].difference(obj[-3:][::-1])
  334:         tm.assert_index_equal(result, obj[:-3], exact=True)
  335: 
  336:         result = obj[::-1].difference(obj[-3:][::-1], sort=False)
  337:         tm.assert_index_equal(result, obj[:-3][::-1], exact=True)
  338: 
  339:         result = obj.difference(obj[2:6])
  340:         expected = Index([1, 2, 7, 8, 9], name="foo")
  341:         tm.assert_index_equal(result, expected, exact=True)
  342: 
  343:     def test_difference_sort(self):
  344:         # GH#44085 ensure we respect the sort keyword
  345: 
  346:         idx = Index(range(4))[::-1]
  347:         other = Index(range(3, 4))
  348: 
  349:         result = idx.difference(other)
  350:         expected = Index(range(3))
  351:         tm.assert_index_equal(result, expected, exact=True)
  352: 
  353:         result = idx.difference(other, sort=False)
  354:         expected = expected[::-1]
  355:         tm.assert_index_equal(result, expected, exact=True)
  356: 
  357:         # case where the intersection is empty
  358:         other = range(10, 12)
  359:         result = idx.difference(other, sort=None)
  360:         expected = idx[::-1]
  361:         tm.assert_index_equal(result, expected, exact=True)
  362: 
  363:     def test_difference_mismatched_step(self):
  364:         obj = RangeIndex.from_range(range(1, 10), name="foo")
  365: 
  366:         result = obj.difference(obj[::2])
  367:         expected = obj[1::2]
  368:         tm.assert_index_equal(result, expected, exact=True)
  369: 
  370:         result = obj[::-1].difference(obj[::2], sort=False)
  371:         tm.assert_index_equal(result, expected[::-1], exact=True)
  372: 
  373:         result = obj.difference(obj[1::2])
  374:         expected = obj[::2]
  375:         tm.assert_index_equal(result, expected, exact=True)
  376: 
  377:         result = obj[::-1].difference(obj[1::2], sort=False)
  378:         tm.assert_index_equal(result, expected[::-1], exact=True)
  379: 
  380:     def test_difference_interior_overlap_endpoints_preserved(self):
  381:         left = RangeIndex(range(4))
  382:         right = RangeIndex(range(1, 3))
  383: 
  384:         result = left.difference(right)
  385:         expected = RangeIndex(0, 4, 3)
  386:         assert expected.tolist() == [0, 3]
  387:         tm.assert_index_equal(result, expected, exact=True)
  388: 
  389:     def test_difference_endpoints_overlap_interior_preserved(self):
  390:         left = RangeIndex(-8, 20, 7)
  391:         right = RangeIndex(13, -9, -3)
  392: 
  393:         result = left.difference(right)
  394:         expected = RangeIndex(-1, 13, 7)
  395:         assert expected.tolist() == [-1, 6]
  396:         tm.assert_index_equal(result, expected, exact=True)
  397: 
  398:     def test_difference_interior_non_preserving(self):
  399:         # case with intersection of length 1 but RangeIndex is not preserved
  400:         idx = Index(range(10))
  401: 
  402:         other = idx[3:4]
  403:         result = idx.difference(other)
  404:         expected = Index([0, 1, 2, 4, 5, 6, 7, 8, 9])
  405:         tm.assert_index_equal(result, expected, exact=True)
  406: 
  407:         # case with other.step / self.step > 2
  408:         other = idx[::3]
  409:         result = idx.difference(other)
  410:         expected = Index([1, 2, 4, 5, 7, 8])
  411:         tm.assert_index_equal(result, expected, exact=True)
  412: 
  413:         # cases with only reaching one end of left
  414:         obj = Index(range(20))
  415:         other = obj[:10:2]
  416:         result = obj.difference(other)
  417:         expected = Index([1, 3, 5, 7, 9] + list(range(10, 20)))
  418:         tm.assert_index_equal(result, expected, exact=True)
  419: 
  420:         other = obj[1:11:2]
  421:         result = obj.difference(other)
  422:         expected = Index([0, 2, 4, 6, 8, 10] + list(range(11, 20)))
  423:         tm.assert_index_equal(result, expected, exact=True)
  424: 
  425:     def test_symmetric_difference(self):
  426:         # GH#12034 Cases where we operate against another RangeIndex and may
  427:         #  get back another RangeIndex
  428:         left = RangeIndex.from_range(range(1, 10), name="foo")
  429: 
  430:         result = left.symmetric_difference(left)
  431:         expected = RangeIndex.from_range(range(0), name="foo")
  432:         tm.assert_index_equal(result, expected)
  433: 
  434:         result = left.symmetric_difference(expected.rename("bar"))
  435:         tm.assert_index_equal(result, left.rename(None))
  436: 
  437:         result = left[:-2].symmetric_difference(left[2:])
  438:         expected = Index([1, 2, 8, 9], name="foo")
  439:         tm.assert_index_equal(result, expected, exact=True)
  440: 
  441:         right = RangeIndex.from_range(range(10, 15))
  442: 
  443:         result = left.symmetric_difference(right)
  444:         expected = RangeIndex.from_range(range(1, 15))
  445:         tm.assert_index_equal(result, expected)
  446: 
  447:         result = left.symmetric_difference(right[1:])
  448:         expected = Index([1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 13, 14])
  449:         tm.assert_index_equal(result, expected, exact=True)
  450: 
  451: 
  452: def assert_range_or_not_is_rangelike(index):
  453:     """
  454:     Check that we either have a RangeIndex or that this index *cannot*
  455:     be represented as a RangeIndex.
  456:     """
  457:     if not isinstance(index, RangeIndex) and len(index) > 0:
  458:         diff = index[:-1] - index[1:]
  459:         assert not (diff == diff[0]).all()
  460: 
  461: 
  462: @given(
  463:     st.integers(-20, 20),
  464:     st.integers(-20, 20),
  465:     st.integers(-20, 20),
  466:     st.integers(-20, 20),
  467:     st.integers(-20, 20),
  468:     st.integers(-20, 20),
  469: )
  470: def test_range_difference(start1, stop1, step1, start2, stop2, step2):
  471:     # test that
  472:     #  a) we match Index[int64].difference and
  473:     #  b) we return RangeIndex whenever it is possible to do so.
  474:     assume(step1 != 0)
  475:     assume(step2 != 0)
  476: 
  477:     left = RangeIndex(start1, stop1, step1)
  478:     right = RangeIndex(start2, stop2, step2)
  479: 
  480:     result = left.difference(right, sort=None)
  481:     assert_range_or_not_is_rangelike(result)
  482: 
  483:     left_int64 = Index(left.to_numpy())
  484:     right_int64 = Index(right.to_numpy())
  485: 
  486:     alt = left_int64.difference(right_int64, sort=None)
  487:     tm.assert_index_equal(result, alt, exact="equiv")
  488: 
  489:     result = left.difference(right, sort=False)
  490:     assert_range_or_not_is_rangelike(result)
  491: 
  492:     alt = left_int64.difference(right_int64, sort=False)
  493:     tm.assert_index_equal(result, alt, exact="equiv")
