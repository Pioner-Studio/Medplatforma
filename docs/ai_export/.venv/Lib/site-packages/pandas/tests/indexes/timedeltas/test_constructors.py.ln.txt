    1: from datetime import timedelta
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: import pandas as pd
    7: from pandas import (
    8:     Timedelta,
    9:     TimedeltaIndex,
   10:     timedelta_range,
   11:     to_timedelta,
   12: )
   13: import pandas._testing as tm
   14: from pandas.core.arrays.timedeltas import TimedeltaArray
   15: 
   16: 
   17: class TestTimedeltaIndex:
   18:     def test_closed_deprecated(self):
   19:         # GH#52628
   20:         msg = "The 'closed' keyword"
   21:         with tm.assert_produces_warning(FutureWarning, match=msg):
   22:             TimedeltaIndex([], closed=True)
   23: 
   24:     def test_array_of_dt64_nat_raises(self):
   25:         # GH#39462
   26:         nat = np.datetime64("NaT", "ns")
   27:         arr = np.array([nat], dtype=object)
   28: 
   29:         msg = "Invalid type for timedelta scalar"
   30:         with pytest.raises(TypeError, match=msg):
   31:             TimedeltaIndex(arr)
   32: 
   33:         with pytest.raises(TypeError, match=msg):
   34:             TimedeltaArray._from_sequence(arr, dtype="m8[ns]")
   35: 
   36:         with pytest.raises(TypeError, match=msg):
   37:             to_timedelta(arr)
   38: 
   39:     @pytest.mark.parametrize("unit", ["Y", "y", "M"])
   40:     def test_unit_m_y_raises(self, unit):
   41:         msg = "Units 'M', 'Y', and 'y' are no longer supported"
   42:         depr_msg = "The 'unit' keyword in TimedeltaIndex construction is deprecated"
   43:         with pytest.raises(ValueError, match=msg):
   44:             with tm.assert_produces_warning(FutureWarning, match=depr_msg):
   45:                 TimedeltaIndex([1, 3, 7], unit)
   46: 
   47:     def test_int64_nocopy(self):
   48:         # GH#23539 check that a copy isn't made when we pass int64 data
   49:         #  and copy=False
   50:         arr = np.arange(10, dtype=np.int64)
   51:         tdi = TimedeltaIndex(arr, copy=False)
   52:         assert tdi._data._ndarray.base is arr
   53: 
   54:     def test_infer_from_tdi(self):
   55:         # GH#23539
   56:         # fast-path for inferring a frequency if the passed data already
   57:         #  has one
   58:         tdi = timedelta_range("1 second", periods=10**7, freq="1s")
   59: 
   60:         result = TimedeltaIndex(tdi, freq="infer")
   61:         assert result.freq == tdi.freq
   62: 
   63:         # check that inferred_freq was not called by checking that the
   64:         #  value has not been cached
   65:         assert "inferred_freq" not in getattr(result, "_cache", {})
   66: 
   67:     def test_infer_from_tdi_mismatch(self):
   68:         # GH#23539
   69:         # fast-path for invalidating a frequency if the passed data already
   70:         #  has one and it does not match the `freq` input
   71:         tdi = timedelta_range("1 second", periods=100, freq="1s")
   72: 
   73:         depr_msg = "TimedeltaArray.__init__ is deprecated"
   74:         msg = (
   75:             "Inferred frequency .* from passed values does "
   76:             "not conform to passed frequency"
   77:         )
   78:         with pytest.raises(ValueError, match=msg):
   79:             TimedeltaIndex(tdi, freq="D")
   80: 
   81:         with pytest.raises(ValueError, match=msg):
   82:             # GH#23789
   83:             with tm.assert_produces_warning(FutureWarning, match=depr_msg):
   84:                 TimedeltaArray(tdi, freq="D")
   85: 
   86:         with pytest.raises(ValueError, match=msg):
   87:             TimedeltaIndex(tdi._data, freq="D")
   88: 
   89:         with pytest.raises(ValueError, match=msg):
   90:             with tm.assert_produces_warning(FutureWarning, match=depr_msg):
   91:                 TimedeltaArray(tdi._data, freq="D")
   92: 
   93:     def test_dt64_data_invalid(self):
   94:         # GH#23539
   95:         # passing tz-aware DatetimeIndex raises, naive or ndarray[datetime64]
   96:         #  raise as of GH#29794
   97:         dti = pd.date_range("2016-01-01", periods=3)
   98: 
   99:         msg = "cannot be converted to timedelta64"
  100:         with pytest.raises(TypeError, match=msg):
  101:             TimedeltaIndex(dti.tz_localize("Europe/Brussels"))
  102: 
  103:         with pytest.raises(TypeError, match=msg):
  104:             TimedeltaIndex(dti)
  105: 
  106:         with pytest.raises(TypeError, match=msg):
  107:             TimedeltaIndex(np.asarray(dti))
  108: 
  109:     def test_float64_ns_rounded(self):
  110:         # GH#23539 without specifying a unit, floats are regarded as nanos,
  111:         #  and fractional portions are truncated
  112:         tdi = TimedeltaIndex([2.3, 9.7])
  113:         expected = TimedeltaIndex([2, 9])
  114:         tm.assert_index_equal(tdi, expected)
  115: 
  116:         # integral floats are non-lossy
  117:         tdi = TimedeltaIndex([2.0, 9.0])
  118:         expected = TimedeltaIndex([2, 9])
  119:         tm.assert_index_equal(tdi, expected)
  120: 
  121:         # NaNs get converted to NaT
  122:         tdi = TimedeltaIndex([2.0, np.nan])
  123:         expected = TimedeltaIndex([Timedelta(nanoseconds=2), pd.NaT])
  124:         tm.assert_index_equal(tdi, expected)
  125: 
  126:     def test_float64_unit_conversion(self):
  127:         # GH#23539
  128:         tdi = to_timedelta([1.5, 2.25], unit="D")
  129:         expected = TimedeltaIndex([Timedelta(days=1.5), Timedelta(days=2.25)])
  130:         tm.assert_index_equal(tdi, expected)
  131: 
  132:     def test_construction_base_constructor(self):
  133:         arr = [Timedelta("1 days"), pd.NaT, Timedelta("3 days")]
  134:         tm.assert_index_equal(pd.Index(arr), TimedeltaIndex(arr))
  135:         tm.assert_index_equal(pd.Index(np.array(arr)), TimedeltaIndex(np.array(arr)))
  136: 
  137:         arr = [np.nan, pd.NaT, Timedelta("1 days")]
  138:         tm.assert_index_equal(pd.Index(arr), TimedeltaIndex(arr))
  139:         tm.assert_index_equal(pd.Index(np.array(arr)), TimedeltaIndex(np.array(arr)))
  140: 
  141:     @pytest.mark.filterwarnings(
  142:         "ignore:The 'unit' keyword in TimedeltaIndex construction:FutureWarning"
  143:     )
  144:     def test_constructor(self):
  145:         expected = TimedeltaIndex(
  146:             [
  147:                 "1 days",
  148:                 "1 days 00:00:05",
  149:                 "2 days",
  150:                 "2 days 00:00:02",
  151:                 "0 days 00:00:03",
  152:             ]
  153:         )
  154:         result = TimedeltaIndex(
  155:             [
  156:                 "1 days",
  157:                 "1 days, 00:00:05",
  158:                 np.timedelta64(2, "D"),
  159:                 timedelta(days=2, seconds=2),
  160:                 pd.offsets.Second(3),
  161:             ]
  162:         )
  163:         tm.assert_index_equal(result, expected)
  164: 
  165:         expected = TimedeltaIndex(
  166:             ["0 days 00:00:00", "0 days 00:00:01", "0 days 00:00:02"]
  167:         )
  168:         result = TimedeltaIndex(range(3), unit="s")
  169:         tm.assert_index_equal(result, expected)
  170:         expected = TimedeltaIndex(
  171:             ["0 days 00:00:00", "0 days 00:00:05", "0 days 00:00:09"]
  172:         )
  173:         result = TimedeltaIndex([0, 5, 9], unit="s")
  174:         tm.assert_index_equal(result, expected)
  175:         expected = TimedeltaIndex(
  176:             ["0 days 00:00:00.400", "0 days 00:00:00.450", "0 days 00:00:01.200"]
  177:         )
  178:         result = TimedeltaIndex([400, 450, 1200], unit="ms")
  179:         tm.assert_index_equal(result, expected)
  180: 
  181:     def test_constructor_iso(self):
  182:         # GH #21877
  183:         expected = timedelta_range("1s", periods=9, freq="s")
  184:         durations = [f"P0DT0H0M{i}S" for i in range(1, 10)]
  185:         result = to_timedelta(durations)
  186:         tm.assert_index_equal(result, expected)
  187: 
  188:     def test_timedelta_range_fractional_period(self):
  189:         msg = "Non-integer 'periods' in pd.date_range, pd.timedelta_range"
  190:         with tm.assert_produces_warning(FutureWarning, match=msg):
  191:             rng = timedelta_range("1 days", periods=10.5)
  192:         exp = timedelta_range("1 days", periods=10)
  193:         tm.assert_index_equal(rng, exp)
  194: 
  195:     def test_constructor_coverage(self):
  196:         msg = "periods must be a number, got foo"
  197:         with pytest.raises(TypeError, match=msg):
  198:             timedelta_range(start="1 days", periods="foo", freq="D")
  199: 
  200:         msg = (
  201:             r"TimedeltaIndex\(\.\.\.\) must be called with a collection of some kind, "
  202:             "'1 days' was passed"
  203:         )
  204:         with pytest.raises(TypeError, match=msg):
  205:             TimedeltaIndex("1 days")
  206: 
  207:         # generator expression
  208:         gen = (timedelta(i) for i in range(10))
  209:         result = TimedeltaIndex(gen)
  210:         expected = TimedeltaIndex([timedelta(i) for i in range(10)])
  211:         tm.assert_index_equal(result, expected)
  212: 
  213:         # NumPy string array
  214:         strings = np.array(["1 days", "2 days", "3 days"])
  215:         result = TimedeltaIndex(strings)
  216:         expected = to_timedelta([1, 2, 3], unit="d")
  217:         tm.assert_index_equal(result, expected)
  218: 
  219:         from_ints = TimedeltaIndex(expected.asi8)
  220:         tm.assert_index_equal(from_ints, expected)
  221: 
  222:         # non-conforming freq
  223:         msg = (
  224:             "Inferred frequency None from passed values does not conform to "
  225:             "passed frequency D"
  226:         )
  227:         with pytest.raises(ValueError, match=msg):
  228:             TimedeltaIndex(["1 days", "2 days", "4 days"], freq="D")
  229: 
  230:         msg = (
  231:             "Of the four parameters: start, end, periods, and freq, exactly "
  232:             "three must be specified"
  233:         )
  234:         with pytest.raises(ValueError, match=msg):
  235:             timedelta_range(periods=10, freq="D")
  236: 
  237:     def test_constructor_name(self):
  238:         idx = timedelta_range(start="1 days", periods=1, freq="D", name="TEST")
  239:         assert idx.name == "TEST"
  240: 
  241:         # GH10025
  242:         idx2 = TimedeltaIndex(idx, name="something else")
  243:         assert idx2.name == "something else"
  244: 
  245:     def test_constructor_no_precision_raises(self):
  246:         # GH-24753, GH-24739
  247: 
  248:         msg = "with no precision is not allowed"
  249:         with pytest.raises(ValueError, match=msg):
  250:             TimedeltaIndex(["2000"], dtype="timedelta64")
  251: 
  252:         msg = "The 'timedelta64' dtype has no unit. Please pass in"
  253:         with pytest.raises(ValueError, match=msg):
  254:             pd.Index(["2000"], dtype="timedelta64")
  255: 
  256:     def test_constructor_wrong_precision_raises(self):
  257:         msg = "Supported timedelta64 resolutions are 's', 'ms', 'us', 'ns'"
  258:         with pytest.raises(ValueError, match=msg):
  259:             TimedeltaIndex(["2000"], dtype="timedelta64[D]")
  260: 
  261:         # "timedelta64[us]" was unsupported pre-2.0, but now this works.
  262:         tdi = TimedeltaIndex(["2000"], dtype="timedelta64[us]")
  263:         assert tdi.dtype == "m8[us]"
  264: 
  265:     def test_explicit_none_freq(self):
  266:         # Explicitly passing freq=None is respected
  267:         tdi = timedelta_range(1, periods=5)
  268:         assert tdi.freq is not None
  269: 
  270:         result = TimedeltaIndex(tdi, freq=None)
  271:         assert result.freq is None
  272: 
  273:         result = TimedeltaIndex(tdi._data, freq=None)
  274:         assert result.freq is None
  275: 
  276:         msg = "TimedeltaArray.__init__ is deprecated"
  277:         with tm.assert_produces_warning(FutureWarning, match=msg):
  278:             tda = TimedeltaArray(tdi, freq=None)
  279:         assert tda.freq is None
  280: 
  281:     def test_from_categorical(self):
  282:         tdi = timedelta_range(1, periods=5)
  283: 
  284:         cat = pd.Categorical(tdi)
  285: 
  286:         result = TimedeltaIndex(cat)
  287:         tm.assert_index_equal(result, tdi)
  288: 
  289:         ci = pd.CategoricalIndex(tdi)
  290:         result = TimedeltaIndex(ci)
  291:         tm.assert_index_equal(result, tdi)
