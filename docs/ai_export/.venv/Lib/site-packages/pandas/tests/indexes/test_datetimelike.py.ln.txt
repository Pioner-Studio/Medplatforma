    1: """ generic datetimelike tests """
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: import pandas as pd
    7: import pandas._testing as tm
    8: 
    9: 
   10: class TestDatetimeLike:
   11:     @pytest.fixture(
   12:         params=[
   13:             pd.period_range("20130101", periods=5, freq="D"),
   14:             pd.TimedeltaIndex(
   15:                 [
   16:                     "0 days 01:00:00",
   17:                     "1 days 01:00:00",
   18:                     "2 days 01:00:00",
   19:                     "3 days 01:00:00",
   20:                     "4 days 01:00:00",
   21:                 ],
   22:                 dtype="timedelta64[ns]",
   23:                 freq="D",
   24:             ),
   25:             pd.DatetimeIndex(
   26:                 ["2013-01-01", "2013-01-02", "2013-01-03", "2013-01-04", "2013-01-05"],
   27:                 dtype="datetime64[ns]",
   28:                 freq="D",
   29:             ),
   30:         ]
   31:     )
   32:     def simple_index(self, request):
   33:         return request.param
   34: 
   35:     def test_isin(self, simple_index):
   36:         index = simple_index[:4]
   37:         result = index.isin(index)
   38:         assert result.all()
   39: 
   40:         result = index.isin(list(index))
   41:         assert result.all()
   42: 
   43:         result = index.isin([index[2], 5])
   44:         expected = np.array([False, False, True, False])
   45:         tm.assert_numpy_array_equal(result, expected)
   46: 
   47:     def test_argsort_matches_array(self, simple_index):
   48:         idx = simple_index
   49:         idx = idx.insert(1, pd.NaT)
   50: 
   51:         result = idx.argsort()
   52:         expected = idx._data.argsort()
   53:         tm.assert_numpy_array_equal(result, expected)
   54: 
   55:     def test_can_hold_identifiers(self, simple_index):
   56:         idx = simple_index
   57:         key = idx[0]
   58:         assert idx._can_hold_identifiers_and_holds_name(key) is False
   59: 
   60:     def test_shift_identity(self, simple_index):
   61:         idx = simple_index
   62:         tm.assert_index_equal(idx, idx.shift(0))
   63: 
   64:     def test_shift_empty(self, simple_index):
   65:         # GH#14811
   66:         idx = simple_index[:0]
   67:         tm.assert_index_equal(idx, idx.shift(1))
   68: 
   69:     def test_str(self, simple_index):
   70:         # test the string repr
   71:         idx = simple_index.copy()
   72:         idx.name = "foo"
   73:         assert f"length={len(idx)}" not in str(idx)
   74:         assert "'foo'" in str(idx)
   75:         assert type(idx).__name__ in str(idx)
   76: 
   77:         if hasattr(idx, "tz"):
   78:             if idx.tz is not None:
   79:                 assert idx.tz in str(idx)
   80:         if isinstance(idx, pd.PeriodIndex):
   81:             assert f"dtype='period[{idx.freqstr}]'" in str(idx)
   82:         else:
   83:             assert f"freq='{idx.freqstr}'" in str(idx)
   84: 
   85:     def test_view(self, simple_index):
   86:         idx = simple_index
   87: 
   88:         idx_view = idx.view("i8")
   89:         result = type(simple_index)(idx)
   90:         tm.assert_index_equal(result, idx)
   91: 
   92:         msg = "Passing a type in .*Index.view is deprecated"
   93:         with tm.assert_produces_warning(FutureWarning, match=msg):
   94:             idx_view = idx.view(type(simple_index))
   95:         result = type(simple_index)(idx)
   96:         tm.assert_index_equal(result, idx_view)
   97: 
   98:     def test_map_callable(self, simple_index):
   99:         index = simple_index
  100:         expected = index + index.freq
  101:         result = index.map(lambda x: x + index.freq)
  102:         tm.assert_index_equal(result, expected)
  103: 
  104:         # map to NaT
  105:         result = index.map(lambda x: pd.NaT if x == index[0] else x)
  106:         expected = pd.Index([pd.NaT] + index[1:].tolist())
  107:         tm.assert_index_equal(result, expected)
  108: 
  109:     @pytest.mark.parametrize(
  110:         "mapper",
  111:         [
  112:             lambda values, index: {i: e for e, i in zip(values, index)},
  113:             lambda values, index: pd.Series(values, index, dtype=object),
  114:         ],
  115:     )
  116:     @pytest.mark.filterwarnings(r"ignore:PeriodDtype\[B\] is deprecated:FutureWarning")
  117:     def test_map_dictlike(self, mapper, simple_index):
  118:         index = simple_index
  119:         expected = index + index.freq
  120: 
  121:         # don't compare the freqs
  122:         if isinstance(expected, (pd.DatetimeIndex, pd.TimedeltaIndex)):
  123:             expected = expected._with_freq(None)
  124: 
  125:         result = index.map(mapper(expected, index))
  126:         tm.assert_index_equal(result, expected)
  127: 
  128:         expected = pd.Index([pd.NaT] + index[1:].tolist())
  129:         result = index.map(mapper(expected, index))
  130:         tm.assert_index_equal(result, expected)
  131: 
  132:         # empty map; these map to np.nan because we cannot know
  133:         # to re-infer things
  134:         expected = pd.Index([np.nan] * len(index))
  135:         result = index.map(mapper([], []))
  136:         tm.assert_index_equal(result, expected)
  137: 
  138:     def test_getitem_preserves_freq(self, simple_index):
  139:         index = simple_index
  140:         assert index.freq is not None
  141: 
  142:         result = index[:]
  143:         assert result.freq == index.freq
  144: 
  145:     def test_where_cast_str(self, simple_index):
  146:         index = simple_index
  147: 
  148:         mask = np.ones(len(index), dtype=bool)
  149:         mask[-1] = False
  150: 
  151:         result = index.where(mask, str(index[0]))
  152:         expected = index.where(mask, index[0])
  153:         tm.assert_index_equal(result, expected)
  154: 
  155:         result = index.where(mask, [str(index[0])])
  156:         tm.assert_index_equal(result, expected)
  157: 
  158:         expected = index.astype(object).where(mask, "foo")
  159:         result = index.where(mask, "foo")
  160:         tm.assert_index_equal(result, expected)
  161: 
  162:         result = index.where(mask, ["foo"])
  163:         tm.assert_index_equal(result, expected)
  164: 
  165:     @pytest.mark.parametrize("unit", ["ns", "us", "ms", "s"])
  166:     def test_diff(self, unit):
  167:         # GH 55080
  168:         dti = pd.to_datetime([10, 20, 30], unit=unit).as_unit(unit)
  169:         result = dti.diff(1)
  170:         expected = pd.to_timedelta([pd.NaT, 10, 10], unit=unit).as_unit(unit)
  171:         tm.assert_index_equal(result, expected)
