    1: import numpy as np
    2: import pytest
    3: 
    4: import pandas as pd
    5: from pandas import (
    6:     CategoricalIndex,
    7:     Index,
    8:     Series,
    9: )
   10: import pandas._testing as tm
   11: 
   12: 
   13: @pytest.mark.parametrize(
   14:     "data, categories",
   15:     [
   16:         (list("abcbca"), list("cab")),
   17:         (pd.interval_range(0, 3).repeat(3), pd.interval_range(0, 3)),
   18:     ],
   19:     ids=["string", "interval"],
   20: )
   21: def test_map_str(data, categories, ordered):
   22:     # GH 31202 - override base class since we want to maintain categorical/ordered
   23:     index = CategoricalIndex(data, categories=categories, ordered=ordered)
   24:     result = index.map(str)
   25:     expected = CategoricalIndex(
   26:         map(str, data), categories=map(str, categories), ordered=ordered
   27:     )
   28:     tm.assert_index_equal(result, expected)
   29: 
   30: 
   31: def test_map():
   32:     ci = CategoricalIndex(list("ABABC"), categories=list("CBA"), ordered=True)
   33:     result = ci.map(lambda x: x.lower())
   34:     exp = CategoricalIndex(list("ababc"), categories=list("cba"), ordered=True)
   35:     tm.assert_index_equal(result, exp)
   36: 
   37:     ci = CategoricalIndex(
   38:         list("ABABC"), categories=list("BAC"), ordered=False, name="XXX"
   39:     )
   40:     result = ci.map(lambda x: x.lower())
   41:     exp = CategoricalIndex(
   42:         list("ababc"), categories=list("bac"), ordered=False, name="XXX"
   43:     )
   44:     tm.assert_index_equal(result, exp)
   45: 
   46:     # GH 12766: Return an index not an array
   47:     tm.assert_index_equal(
   48:         ci.map(lambda x: 1), Index(np.array([1] * 5, dtype=np.int64), name="XXX")
   49:     )
   50: 
   51:     # change categories dtype
   52:     ci = CategoricalIndex(list("ABABC"), categories=list("BAC"), ordered=False)
   53: 
   54:     def f(x):
   55:         return {"A": 10, "B": 20, "C": 30}.get(x)
   56: 
   57:     result = ci.map(f)
   58:     exp = CategoricalIndex([10, 20, 10, 20, 30], categories=[20, 10, 30], ordered=False)
   59:     tm.assert_index_equal(result, exp)
   60: 
   61:     result = ci.map(Series([10, 20, 30], index=["A", "B", "C"]))
   62:     tm.assert_index_equal(result, exp)
   63: 
   64:     result = ci.map({"A": 10, "B": 20, "C": 30})
   65:     tm.assert_index_equal(result, exp)
   66: 
   67: 
   68: def test_map_with_categorical_series():
   69:     # GH 12756
   70:     a = Index([1, 2, 3, 4])
   71:     b = Series(["even", "odd", "even", "odd"], dtype="category")
   72:     c = Series(["even", "odd", "even", "odd"])
   73: 
   74:     exp = CategoricalIndex(["odd", "even", "odd", np.nan])
   75:     tm.assert_index_equal(a.map(b), exp)
   76:     exp = Index(["odd", "even", "odd", np.nan])
   77:     tm.assert_index_equal(a.map(c), exp)
   78: 
   79: 
   80: @pytest.mark.parametrize(
   81:     ("data", "f", "expected"),
   82:     (
   83:         ([1, 1, np.nan], pd.isna, CategoricalIndex([False, False, np.nan])),
   84:         ([1, 2, np.nan], pd.isna, Index([False, False, np.nan])),
   85:         ([1, 1, np.nan], {1: False}, CategoricalIndex([False, False, np.nan])),
   86:         ([1, 2, np.nan], {1: False, 2: False}, Index([False, False, np.nan])),
   87:         (
   88:             [1, 1, np.nan],
   89:             Series([False, False]),
   90:             CategoricalIndex([False, False, np.nan]),
   91:         ),
   92:         (
   93:             [1, 2, np.nan],
   94:             Series([False, False, False]),
   95:             Index([False, False, np.nan]),
   96:         ),
   97:     ),
   98: )
   99: def test_map_with_nan_ignore(data, f, expected):  # GH 24241
  100:     values = CategoricalIndex(data)
  101:     result = values.map(f, na_action="ignore")
  102:     tm.assert_index_equal(result, expected)
  103: 
  104: 
  105: @pytest.mark.parametrize(
  106:     ("data", "f", "expected"),
  107:     (
  108:         ([1, 1, np.nan], pd.isna, Index([False, False, True])),
  109:         ([1, 2, np.nan], pd.isna, Index([False, False, True])),
  110:         ([1, 1, np.nan], {1: False}, CategoricalIndex([False, False, np.nan])),
  111:         ([1, 2, np.nan], {1: False, 2: False}, Index([False, False, np.nan])),
  112:         (
  113:             [1, 1, np.nan],
  114:             Series([False, False]),
  115:             CategoricalIndex([False, False, np.nan]),
  116:         ),
  117:         (
  118:             [1, 2, np.nan],
  119:             Series([False, False, False]),
  120:             Index([False, False, np.nan]),
  121:         ),
  122:     ),
  123: )
  124: def test_map_with_nan_none(data, f, expected):  # GH 24241
  125:     values = CategoricalIndex(data)
  126:     result = values.map(f, na_action=None)
  127:     tm.assert_index_equal(result, expected)
  128: 
  129: 
  130: def test_map_with_dict_or_series():
  131:     orig_values = ["a", "B", 1, "a"]
  132:     new_values = ["one", 2, 3.0, "one"]
  133:     cur_index = CategoricalIndex(orig_values, name="XXX")
  134:     expected = CategoricalIndex(new_values, name="XXX", categories=[3.0, 2, "one"])
  135: 
  136:     mapper = Series(new_values[:-1], index=orig_values[:-1])
  137:     result = cur_index.map(mapper)
  138:     # Order of categories in result can be different
  139:     tm.assert_index_equal(result, expected)
  140: 
  141:     mapper = dict(zip(orig_values[:-1], new_values[:-1]))
  142:     result = cur_index.map(mapper)
  143:     # Order of categories in result can be different
  144:     tm.assert_index_equal(result, expected)
