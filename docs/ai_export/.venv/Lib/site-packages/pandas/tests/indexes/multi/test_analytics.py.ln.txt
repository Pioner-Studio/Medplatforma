    1: import numpy as np
    2: import pytest
    3: 
    4: import pandas as pd
    5: from pandas import (
    6:     Index,
    7:     MultiIndex,
    8:     date_range,
    9:     period_range,
   10: )
   11: import pandas._testing as tm
   12: 
   13: 
   14: def test_infer_objects(idx):
   15:     with pytest.raises(NotImplementedError, match="to_frame"):
   16:         idx.infer_objects()
   17: 
   18: 
   19: def test_shift(idx):
   20:     # GH8083 test the base class for shift
   21:     msg = (
   22:         "This method is only implemented for DatetimeIndex, PeriodIndex and "
   23:         "TimedeltaIndex; Got type MultiIndex"
   24:     )
   25:     with pytest.raises(NotImplementedError, match=msg):
   26:         idx.shift(1)
   27:     with pytest.raises(NotImplementedError, match=msg):
   28:         idx.shift(1, 2)
   29: 
   30: 
   31: def test_groupby(idx):
   32:     groups = idx.groupby(np.array([1, 1, 1, 2, 2, 2]))
   33:     labels = idx.tolist()
   34:     exp = {1: labels[:3], 2: labels[3:]}
   35:     tm.assert_dict_equal(groups, exp)
   36: 
   37:     # GH5620
   38:     groups = idx.groupby(idx)
   39:     exp = {key: [key] for key in idx}
   40:     tm.assert_dict_equal(groups, exp)
   41: 
   42: 
   43: def test_truncate_multiindex():
   44:     # GH 34564 for MultiIndex level names check
   45:     major_axis = Index(list(range(4)))
   46:     minor_axis = Index(list(range(2)))
   47: 
   48:     major_codes = np.array([0, 0, 1, 2, 3, 3])
   49:     minor_codes = np.array([0, 1, 0, 1, 0, 1])
   50: 
   51:     index = MultiIndex(
   52:         levels=[major_axis, minor_axis],
   53:         codes=[major_codes, minor_codes],
   54:         names=["L1", "L2"],
   55:     )
   56: 
   57:     result = index.truncate(before=1)
   58:     assert "foo" not in result.levels[0]
   59:     assert 1 in result.levels[0]
   60:     assert index.names == result.names
   61: 
   62:     result = index.truncate(after=1)
   63:     assert 2 not in result.levels[0]
   64:     assert 1 in result.levels[0]
   65:     assert index.names == result.names
   66: 
   67:     result = index.truncate(before=1, after=2)
   68:     assert len(result.levels[0]) == 2
   69:     assert index.names == result.names
   70: 
   71:     msg = "after < before"
   72:     with pytest.raises(ValueError, match=msg):
   73:         index.truncate(3, 1)
   74: 
   75: 
   76: # TODO: reshape
   77: 
   78: 
   79: def test_reorder_levels(idx):
   80:     # this blows up
   81:     with pytest.raises(IndexError, match="^Too many levels"):
   82:         idx.reorder_levels([2, 1, 0])
   83: 
   84: 
   85: def test_numpy_repeat():
   86:     reps = 2
   87:     numbers = [1, 2, 3]
   88:     names = np.array(["foo", "bar"])
   89: 
   90:     m = MultiIndex.from_product([numbers, names], names=names)
   91:     expected = MultiIndex.from_product([numbers, names.repeat(reps)], names=names)
   92:     tm.assert_index_equal(np.repeat(m, reps), expected)
   93: 
   94:     msg = "the 'axis' parameter is not supported"
   95:     with pytest.raises(ValueError, match=msg):
   96:         np.repeat(m, reps, axis=1)
   97: 
   98: 
   99: def test_append_mixed_dtypes():
  100:     # GH 13660
  101:     dti = date_range("2011-01-01", freq="ME", periods=3)
  102:     dti_tz = date_range("2011-01-01", freq="ME", periods=3, tz="US/Eastern")
  103:     pi = period_range("2011-01", freq="M", periods=3)
  104: 
  105:     mi = MultiIndex.from_arrays(
  106:         [[1, 2, 3], [1.1, np.nan, 3.3], ["a", "b", "c"], dti, dti_tz, pi]
  107:     )
  108:     assert mi.nlevels == 6
  109: 
  110:     res = mi.append(mi)
  111:     exp = MultiIndex.from_arrays(
  112:         [
  113:             [1, 2, 3, 1, 2, 3],
  114:             [1.1, np.nan, 3.3, 1.1, np.nan, 3.3],
  115:             ["a", "b", "c", "a", "b", "c"],
  116:             dti.append(dti),
  117:             dti_tz.append(dti_tz),
  118:             pi.append(pi),
  119:         ]
  120:     )
  121:     tm.assert_index_equal(res, exp)
  122: 
  123:     other = MultiIndex.from_arrays(
  124:         [
  125:             ["x", "y", "z"],
  126:             ["x", "y", "z"],
  127:             ["x", "y", "z"],
  128:             ["x", "y", "z"],
  129:             ["x", "y", "z"],
  130:             ["x", "y", "z"],
  131:         ]
  132:     )
  133: 
  134:     res = mi.append(other)
  135:     exp = MultiIndex.from_arrays(
  136:         [
  137:             [1, 2, 3, "x", "y", "z"],
  138:             [1.1, np.nan, 3.3, "x", "y", "z"],
  139:             ["a", "b", "c", "x", "y", "z"],
  140:             dti.append(Index(["x", "y", "z"])),
  141:             dti_tz.append(Index(["x", "y", "z"])),
  142:             pi.append(Index(["x", "y", "z"])),
  143:         ]
  144:     )
  145:     tm.assert_index_equal(res, exp)
  146: 
  147: 
  148: def test_iter(idx):
  149:     result = list(idx)
  150:     expected = [
  151:         ("foo", "one"),
  152:         ("foo", "two"),
  153:         ("bar", "one"),
  154:         ("baz", "two"),
  155:         ("qux", "one"),
  156:         ("qux", "two"),
  157:     ]
  158:     assert result == expected
  159: 
  160: 
  161: def test_sub(idx):
  162:     first = idx
  163: 
  164:     # - now raises (previously was set op difference)
  165:     msg = "cannot perform __sub__ with this index type: MultiIndex"
  166:     with pytest.raises(TypeError, match=msg):
  167:         first - idx[-3:]
  168:     with pytest.raises(TypeError, match=msg):
  169:         idx[-3:] - first
  170:     with pytest.raises(TypeError, match=msg):
  171:         idx[-3:] - first.tolist()
  172:     msg = "cannot perform __rsub__ with this index type: MultiIndex"
  173:     with pytest.raises(TypeError, match=msg):
  174:         first.tolist() - idx[-3:]
  175: 
  176: 
  177: def test_map(idx):
  178:     # callable
  179:     index = idx
  180: 
  181:     result = index.map(lambda x: x)
  182:     tm.assert_index_equal(result, index)
  183: 
  184: 
  185: @pytest.mark.parametrize(
  186:     "mapper",
  187:     [
  188:         lambda values, idx: {i: e for e, i in zip(values, idx)},
  189:         lambda values, idx: pd.Series(values, idx),
  190:     ],
  191: )
  192: def test_map_dictlike(idx, mapper):
  193:     identity = mapper(idx.values, idx)
  194: 
  195:     # we don't infer to uint64 dtype for a dict
  196:     if idx.dtype == np.uint64 and isinstance(identity, dict):
  197:         expected = idx.astype("int64")
  198:     else:
  199:         expected = idx
  200: 
  201:     result = idx.map(identity)
  202:     tm.assert_index_equal(result, expected)
  203: 
  204:     # empty mappable
  205:     expected = Index([np.nan] * len(idx))
  206:     result = idx.map(mapper(expected, idx))
  207:     tm.assert_index_equal(result, expected)
  208: 
  209: 
  210: @pytest.mark.parametrize(
  211:     "func",
  212:     [
  213:         np.exp,
  214:         np.exp2,
  215:         np.expm1,
  216:         np.log,
  217:         np.log2,
  218:         np.log10,
  219:         np.log1p,
  220:         np.sqrt,
  221:         np.sin,
  222:         np.cos,
  223:         np.tan,
  224:         np.arcsin,
  225:         np.arccos,
  226:         np.arctan,
  227:         np.sinh,
  228:         np.cosh,
  229:         np.tanh,
  230:         np.arcsinh,
  231:         np.arccosh,
  232:         np.arctanh,
  233:         np.deg2rad,
  234:         np.rad2deg,
  235:     ],
  236:     ids=lambda func: func.__name__,
  237: )
  238: def test_numpy_ufuncs(idx, func):
  239:     # test ufuncs of numpy. see:
  240:     # https://numpy.org/doc/stable/reference/ufuncs.html
  241: 
  242:     expected_exception = TypeError
  243:     msg = (
  244:         "loop of ufunc does not support argument 0 of type tuple which "
  245:         f"has no callable {func.__name__} method"
  246:     )
  247:     with pytest.raises(expected_exception, match=msg):
  248:         func(idx)
  249: 
  250: 
  251: @pytest.mark.parametrize(
  252:     "func",
  253:     [np.isfinite, np.isinf, np.isnan, np.signbit],
  254:     ids=lambda func: func.__name__,
  255: )
  256: def test_numpy_type_funcs(idx, func):
  257:     msg = (
  258:         f"ufunc '{func.__name__}' not supported for the input types, and the inputs "
  259:         "could not be safely coerced to any supported types according to "
  260:         "the casting rule ''safe''"
  261:     )
  262:     with pytest.raises(TypeError, match=msg):
  263:         func(idx)
