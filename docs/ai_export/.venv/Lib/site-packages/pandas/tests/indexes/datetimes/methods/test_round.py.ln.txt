    1: import pytest
    2: 
    3: from pandas._libs.tslibs import to_offset
    4: from pandas._libs.tslibs.offsets import INVALID_FREQ_ERR_MSG
    5: 
    6: from pandas import (
    7:     DatetimeIndex,
    8:     Timestamp,
    9:     date_range,
   10: )
   11: import pandas._testing as tm
   12: 
   13: 
   14: class TestDatetimeIndexRound:
   15:     def test_round_daily(self):
   16:         dti = date_range("20130101 09:10:11", periods=5)
   17:         result = dti.round("D")
   18:         expected = date_range("20130101", periods=5)
   19:         tm.assert_index_equal(result, expected)
   20: 
   21:         dti = dti.tz_localize("UTC").tz_convert("US/Eastern")
   22:         result = dti.round("D")
   23:         expected = date_range("20130101", periods=5).tz_localize("US/Eastern")
   24:         tm.assert_index_equal(result, expected)
   25: 
   26:         result = dti.round("s")
   27:         tm.assert_index_equal(result, dti)
   28: 
   29:     @pytest.mark.parametrize(
   30:         "freq, error_msg",
   31:         [
   32:             ("YE", "<YearEnd: month=12> is a non-fixed frequency"),
   33:             ("ME", "<MonthEnd> is a non-fixed frequency"),
   34:             ("foobar", "Invalid frequency: foobar"),
   35:         ],
   36:     )
   37:     def test_round_invalid(self, freq, error_msg):
   38:         dti = date_range("20130101 09:10:11", periods=5)
   39:         dti = dti.tz_localize("UTC").tz_convert("US/Eastern")
   40:         with pytest.raises(ValueError, match=error_msg):
   41:             dti.round(freq)
   42: 
   43:     def test_round(self, tz_naive_fixture, unit):
   44:         tz = tz_naive_fixture
   45:         rng = date_range(start="2016-01-01", periods=5, freq="30Min", tz=tz, unit=unit)
   46:         elt = rng[1]
   47: 
   48:         expected_rng = DatetimeIndex(
   49:             [
   50:                 Timestamp("2016-01-01 00:00:00", tz=tz),
   51:                 Timestamp("2016-01-01 00:00:00", tz=tz),
   52:                 Timestamp("2016-01-01 01:00:00", tz=tz),
   53:                 Timestamp("2016-01-01 02:00:00", tz=tz),
   54:                 Timestamp("2016-01-01 02:00:00", tz=tz),
   55:             ]
   56:         ).as_unit(unit)
   57:         expected_elt = expected_rng[1]
   58: 
   59:         result = rng.round(freq="h")
   60:         tm.assert_index_equal(result, expected_rng)
   61:         assert elt.round(freq="h") == expected_elt
   62: 
   63:         msg = INVALID_FREQ_ERR_MSG
   64:         with pytest.raises(ValueError, match=msg):
   65:             rng.round(freq="foo")
   66:         with pytest.raises(ValueError, match=msg):
   67:             elt.round(freq="foo")
   68: 
   69:         msg = "<MonthEnd> is a non-fixed frequency"
   70:         with pytest.raises(ValueError, match=msg):
   71:             rng.round(freq="ME")
   72:         with pytest.raises(ValueError, match=msg):
   73:             elt.round(freq="ME")
   74: 
   75:     def test_round2(self, tz_naive_fixture):
   76:         tz = tz_naive_fixture
   77:         # GH#14440 & GH#15578
   78:         index = DatetimeIndex(["2016-10-17 12:00:00.0015"], tz=tz).as_unit("ns")
   79:         result = index.round("ms")
   80:         expected = DatetimeIndex(["2016-10-17 12:00:00.002000"], tz=tz).as_unit("ns")
   81:         tm.assert_index_equal(result, expected)
   82: 
   83:         for freq in ["us", "ns"]:
   84:             tm.assert_index_equal(index, index.round(freq))
   85: 
   86:     def test_round3(self, tz_naive_fixture):
   87:         tz = tz_naive_fixture
   88:         index = DatetimeIndex(["2016-10-17 12:00:00.00149"], tz=tz).as_unit("ns")
   89:         result = index.round("ms")
   90:         expected = DatetimeIndex(["2016-10-17 12:00:00.001000"], tz=tz).as_unit("ns")
   91:         tm.assert_index_equal(result, expected)
   92: 
   93:     def test_round4(self, tz_naive_fixture):
   94:         index = DatetimeIndex(["2016-10-17 12:00:00.001501031"], dtype="M8[ns]")
   95:         result = index.round("10ns")
   96:         expected = DatetimeIndex(["2016-10-17 12:00:00.001501030"], dtype="M8[ns]")
   97:         tm.assert_index_equal(result, expected)
   98: 
   99:         ts = "2016-10-17 12:00:00.001501031"
  100:         dti = DatetimeIndex([ts], dtype="M8[ns]")
  101:         with tm.assert_produces_warning(False):
  102:             dti.round("1010ns")
  103: 
  104:     def test_no_rounding_occurs(self, tz_naive_fixture):
  105:         # GH 21262
  106:         tz = tz_naive_fixture
  107:         rng = date_range(start="2016-01-01", periods=5, freq="2Min", tz=tz)
  108: 
  109:         expected_rng = DatetimeIndex(
  110:             [
  111:                 Timestamp("2016-01-01 00:00:00", tz=tz),
  112:                 Timestamp("2016-01-01 00:02:00", tz=tz),
  113:                 Timestamp("2016-01-01 00:04:00", tz=tz),
  114:                 Timestamp("2016-01-01 00:06:00", tz=tz),
  115:                 Timestamp("2016-01-01 00:08:00", tz=tz),
  116:             ]
  117:         ).as_unit("ns")
  118: 
  119:         result = rng.round(freq="2min")
  120:         tm.assert_index_equal(result, expected_rng)
  121: 
  122:     @pytest.mark.parametrize(
  123:         "test_input, rounder, freq, expected",
  124:         [
  125:             (["2117-01-01 00:00:45"], "floor", "15s", ["2117-01-01 00:00:45"]),
  126:             (["2117-01-01 00:00:45"], "ceil", "15s", ["2117-01-01 00:00:45"]),
  127:             (
  128:                 ["2117-01-01 00:00:45.000000012"],
  129:                 "floor",
  130:                 "10ns",
  131:                 ["2117-01-01 00:00:45.000000010"],
  132:             ),
  133:             (
  134:                 ["1823-01-01 00:00:01.000000012"],
  135:                 "ceil",
  136:                 "10ns",
  137:                 ["1823-01-01 00:00:01.000000020"],
  138:             ),
  139:             (["1823-01-01 00:00:01"], "floor", "1s", ["1823-01-01 00:00:01"]),
  140:             (["1823-01-01 00:00:01"], "ceil", "1s", ["1823-01-01 00:00:01"]),
  141:             (["2018-01-01 00:15:00"], "ceil", "15min", ["2018-01-01 00:15:00"]),
  142:             (["2018-01-01 00:15:00"], "floor", "15min", ["2018-01-01 00:15:00"]),
  143:             (["1823-01-01 03:00:00"], "ceil", "3h", ["1823-01-01 03:00:00"]),
  144:             (["1823-01-01 03:00:00"], "floor", "3h", ["1823-01-01 03:00:00"]),
  145:             (
  146:                 ("NaT", "1823-01-01 00:00:01"),
  147:                 "floor",
  148:                 "1s",
  149:                 ("NaT", "1823-01-01 00:00:01"),
  150:             ),
  151:             (
  152:                 ("NaT", "1823-01-01 00:00:01"),
  153:                 "ceil",
  154:                 "1s",
  155:                 ("NaT", "1823-01-01 00:00:01"),
  156:             ),
  157:         ],
  158:     )
  159:     def test_ceil_floor_edge(self, test_input, rounder, freq, expected):
  160:         dt = DatetimeIndex(list(test_input))
  161:         func = getattr(dt, rounder)
  162:         result = func(freq)
  163:         expected = DatetimeIndex(list(expected))
  164:         assert expected.equals(result)
  165: 
  166:     @pytest.mark.parametrize(
  167:         "start, index_freq, periods",
  168:         [("2018-01-01", "12h", 25), ("2018-01-01 0:0:0.124999", "1ns", 1000)],
  169:     )
  170:     @pytest.mark.parametrize(
  171:         "round_freq",
  172:         [
  173:             "2ns",
  174:             "3ns",
  175:             "4ns",
  176:             "5ns",
  177:             "6ns",
  178:             "7ns",
  179:             "250ns",
  180:             "500ns",
  181:             "750ns",
  182:             "1us",
  183:             "19us",
  184:             "250us",
  185:             "500us",
  186:             "750us",
  187:             "1s",
  188:             "2s",
  189:             "3s",
  190:             "12h",
  191:             "1D",
  192:         ],
  193:     )
  194:     def test_round_int64(self, start, index_freq, periods, round_freq):
  195:         dt = date_range(start=start, freq=index_freq, periods=periods)
  196:         unit = to_offset(round_freq).nanos
  197: 
  198:         # test floor
  199:         result = dt.floor(round_freq)
  200:         diff = dt.asi8 - result.asi8
  201:         mod = result.asi8 % unit
  202:         assert (mod == 0).all(), f"floor not a {round_freq} multiple"
  203:         assert (0 <= diff).all() and (diff < unit).all(), "floor error"
  204: 
  205:         # test ceil
  206:         result = dt.ceil(round_freq)
  207:         diff = result.asi8 - dt.asi8
  208:         mod = result.asi8 % unit
  209:         assert (mod == 0).all(), f"ceil not a {round_freq} multiple"
  210:         assert (0 <= diff).all() and (diff < unit).all(), "ceil error"
  211: 
  212:         # test round
  213:         result = dt.round(round_freq)
  214:         diff = abs(result.asi8 - dt.asi8)
  215:         mod = result.asi8 % unit
  216:         assert (mod == 0).all(), f"round not a {round_freq} multiple"
  217:         assert (diff <= unit // 2).all(), "round error"
  218:         if unit % 2 == 0:
  219:             assert (
  220:                 result.asi8[diff == unit // 2] % 2 == 0
  221:             ).all(), "round half to even error"
