    1: from __future__ import annotations
    2: 
    3: from datetime import (
    4:     datetime,
    5:     timedelta,
    6:     timezone,
    7: )
    8: from functools import partial
    9: from operator import attrgetter
   10: 
   11: import dateutil
   12: import dateutil.tz
   13: from dateutil.tz import gettz
   14: import numpy as np
   15: import pytest
   16: import pytz
   17: 
   18: from pandas._libs.tslibs import (
   19:     OutOfBoundsDatetime,
   20:     astype_overflowsafe,
   21:     timezones,
   22: )
   23: 
   24: import pandas as pd
   25: from pandas import (
   26:     DatetimeIndex,
   27:     Index,
   28:     Timestamp,
   29:     date_range,
   30:     offsets,
   31:     to_datetime,
   32: )
   33: import pandas._testing as tm
   34: from pandas.core.arrays import period_array
   35: 
   36: 
   37: class TestDatetimeIndex:
   38:     def test_closed_deprecated(self):
   39:         # GH#52628
   40:         msg = "The 'closed' keyword"
   41:         with tm.assert_produces_warning(FutureWarning, match=msg):
   42:             DatetimeIndex([], closed=True)
   43: 
   44:     def test_normalize_deprecated(self):
   45:         # GH#52628
   46:         msg = "The 'normalize' keyword"
   47:         with tm.assert_produces_warning(FutureWarning, match=msg):
   48:             DatetimeIndex([], normalize=True)
   49: 
   50:     def test_from_dt64_unsupported_unit(self):
   51:         # GH#49292
   52:         val = np.datetime64(1, "D")
   53:         result = DatetimeIndex([val], tz="US/Pacific")
   54: 
   55:         expected = DatetimeIndex([val.astype("M8[s]")], tz="US/Pacific")
   56:         tm.assert_index_equal(result, expected)
   57: 
   58:     def test_explicit_tz_none(self):
   59:         # GH#48659
   60:         dti = date_range("2016-01-01", periods=10, tz="UTC")
   61: 
   62:         msg = "Passed data is timezone-aware, incompatible with 'tz=None'"
   63:         with pytest.raises(ValueError, match=msg):
   64:             DatetimeIndex(dti, tz=None)
   65: 
   66:         with pytest.raises(ValueError, match=msg):
   67:             DatetimeIndex(np.array(dti), tz=None)
   68: 
   69:         msg = "Cannot pass both a timezone-aware dtype and tz=None"
   70:         with pytest.raises(ValueError, match=msg):
   71:             DatetimeIndex([], dtype="M8[ns, UTC]", tz=None)
   72: 
   73:     def test_freq_validation_with_nat(self):
   74:         # GH#11587 make sure we get a useful error message when generate_range
   75:         #  raises
   76:         msg = (
   77:             "Inferred frequency None from passed values does not conform "
   78:             "to passed frequency D"
   79:         )
   80:         with pytest.raises(ValueError, match=msg):
   81:             DatetimeIndex([pd.NaT, Timestamp("2011-01-01")], freq="D")
   82:         with pytest.raises(ValueError, match=msg):
   83:             DatetimeIndex([pd.NaT, Timestamp("2011-01-01")._value], freq="D")
   84: 
   85:     # TODO: better place for tests shared by DTI/TDI?
   86:     @pytest.mark.parametrize(
   87:         "index",
   88:         [
   89:             date_range("2016-01-01", periods=5, tz="US/Pacific"),
   90:             pd.timedelta_range("1 Day", periods=5),
   91:         ],
   92:     )
   93:     def test_shallow_copy_inherits_array_freq(self, index):
   94:         # If we pass a DTA/TDA to shallow_copy and dont specify a freq,
   95:         #  we should inherit the array's freq, not our own.
   96:         array = index._data
   97: 
   98:         arr = array[[0, 3, 2, 4, 1]]
   99:         assert arr.freq is None
  100: 
  101:         result = index._shallow_copy(arr)
  102:         assert result.freq is None
  103: 
  104:     def test_categorical_preserves_tz(self):
  105:         # GH#18664 retain tz when going DTI-->Categorical-->DTI
  106:         dti = DatetimeIndex(
  107:             [pd.NaT, "2015-01-01", "1999-04-06 15:14:13", "2015-01-01"], tz="US/Eastern"
  108:         )
  109: 
  110:         for dtobj in [dti, dti._data]:
  111:             # works for DatetimeIndex or DatetimeArray
  112: 
  113:             ci = pd.CategoricalIndex(dtobj)
  114:             carr = pd.Categorical(dtobj)
  115:             cser = pd.Series(ci)
  116: 
  117:             for obj in [ci, carr, cser]:
  118:                 result = DatetimeIndex(obj)
  119:                 tm.assert_index_equal(result, dti)
  120: 
  121:     def test_dti_with_period_data_raises(self):
  122:         # GH#23675
  123:         data = pd.PeriodIndex(["2016Q1", "2016Q2"], freq="Q")
  124: 
  125:         with pytest.raises(TypeError, match="PeriodDtype data is invalid"):
  126:             DatetimeIndex(data)
  127: 
  128:         with pytest.raises(TypeError, match="PeriodDtype data is invalid"):
  129:             to_datetime(data)
  130: 
  131:         with pytest.raises(TypeError, match="PeriodDtype data is invalid"):
  132:             DatetimeIndex(period_array(data))
  133: 
  134:         with pytest.raises(TypeError, match="PeriodDtype data is invalid"):
  135:             to_datetime(period_array(data))
  136: 
  137:     def test_dti_with_timedelta64_data_raises(self):
  138:         # GH#23675 deprecated, enforrced in GH#29794
  139:         data = np.array([0], dtype="m8[ns]")
  140:         msg = r"timedelta64\[ns\] cannot be converted to datetime64"
  141:         with pytest.raises(TypeError, match=msg):
  142:             DatetimeIndex(data)
  143: 
  144:         with pytest.raises(TypeError, match=msg):
  145:             to_datetime(data)
  146: 
  147:         with pytest.raises(TypeError, match=msg):
  148:             DatetimeIndex(pd.TimedeltaIndex(data))
  149: 
  150:         with pytest.raises(TypeError, match=msg):
  151:             to_datetime(pd.TimedeltaIndex(data))
  152: 
  153:     def test_constructor_from_sparse_array(self):
  154:         # https://github.com/pandas-dev/pandas/issues/35843
  155:         values = [
  156:             Timestamp("2012-05-01T01:00:00.000000"),
  157:             Timestamp("2016-05-01T01:00:00.000000"),
  158:         ]
  159:         arr = pd.arrays.SparseArray(values)
  160:         result = Index(arr)
  161:         assert type(result) is Index
  162:         assert result.dtype == arr.dtype
  163: 
  164:     def test_construction_caching(self):
  165:         df = pd.DataFrame(
  166:             {
  167:                 "dt": date_range("20130101", periods=3),
  168:                 "dttz": date_range("20130101", periods=3, tz="US/Eastern"),
  169:                 "dt_with_null": [
  170:                     Timestamp("20130101"),
  171:                     pd.NaT,
  172:                     Timestamp("20130103"),
  173:                 ],
  174:                 "dtns": date_range("20130101", periods=3, freq="ns"),
  175:             }
  176:         )
  177:         assert df.dttz.dtype.tz.zone == "US/Eastern"
  178: 
  179:     @pytest.mark.parametrize(
  180:         "kwargs",
  181:         [{"tz": "dtype.tz"}, {"dtype": "dtype"}, {"dtype": "dtype", "tz": "dtype.tz"}],
  182:     )
  183:     def test_construction_with_alt(self, kwargs, tz_aware_fixture):
  184:         tz = tz_aware_fixture
  185:         i = date_range("20130101", periods=5, freq="h", tz=tz)
  186:         kwargs = {key: attrgetter(val)(i) for key, val in kwargs.items()}
  187:         result = DatetimeIndex(i, **kwargs)
  188:         tm.assert_index_equal(i, result)
  189: 
  190:     @pytest.mark.parametrize(
  191:         "kwargs",
  192:         [{"tz": "dtype.tz"}, {"dtype": "dtype"}, {"dtype": "dtype", "tz": "dtype.tz"}],
  193:     )
  194:     def test_construction_with_alt_tz_localize(self, kwargs, tz_aware_fixture):
  195:         tz = tz_aware_fixture
  196:         i = date_range("20130101", periods=5, freq="h", tz=tz)
  197:         i = i._with_freq(None)
  198:         kwargs = {key: attrgetter(val)(i) for key, val in kwargs.items()}
  199: 
  200:         if "tz" in kwargs:
  201:             result = DatetimeIndex(i.asi8, tz="UTC").tz_convert(kwargs["tz"])
  202: 
  203:             expected = DatetimeIndex(i, **kwargs)
  204:             tm.assert_index_equal(result, expected)
  205: 
  206:         # localize into the provided tz
  207:         i2 = DatetimeIndex(i.tz_localize(None).asi8, tz="UTC")
  208:         expected = i.tz_localize(None).tz_localize("UTC")
  209:         tm.assert_index_equal(i2, expected)
  210: 
  211:         # incompat tz/dtype
  212:         msg = "cannot supply both a tz and a dtype with a tz"
  213:         with pytest.raises(ValueError, match=msg):
  214:             DatetimeIndex(i.tz_localize(None).asi8, dtype=i.dtype, tz="US/Pacific")
  215: 
  216:     def test_construction_index_with_mixed_timezones(self):
  217:         # gh-11488: no tz results in DatetimeIndex
  218:         result = Index([Timestamp("2011-01-01"), Timestamp("2011-01-02")], name="idx")
  219:         exp = DatetimeIndex(
  220:             [Timestamp("2011-01-01"), Timestamp("2011-01-02")], name="idx"
  221:         )
  222:         tm.assert_index_equal(result, exp, exact=True)
  223:         assert isinstance(result, DatetimeIndex)
  224:         assert result.tz is None
  225: 
  226:         # same tz results in DatetimeIndex
  227:         result = Index(
  228:             [
  229:                 Timestamp("2011-01-01 10:00", tz="Asia/Tokyo"),
  230:                 Timestamp("2011-01-02 10:00", tz="Asia/Tokyo"),
  231:             ],
  232:             name="idx",
  233:         )
  234:         exp = DatetimeIndex(
  235:             [Timestamp("2011-01-01 10:00"), Timestamp("2011-01-02 10:00")],
  236:             tz="Asia/Tokyo",
  237:             name="idx",
  238:         )
  239:         tm.assert_index_equal(result, exp, exact=True)
  240:         assert isinstance(result, DatetimeIndex)
  241:         assert result.tz is not None
  242:         assert result.tz == exp.tz
  243: 
  244:         # same tz results in DatetimeIndex (DST)
  245:         result = Index(
  246:             [
  247:                 Timestamp("2011-01-01 10:00", tz="US/Eastern"),
  248:                 Timestamp("2011-08-01 10:00", tz="US/Eastern"),
  249:             ],
  250:             name="idx",
  251:         )
  252:         exp = DatetimeIndex(
  253:             [Timestamp("2011-01-01 10:00"), Timestamp("2011-08-01 10:00")],
  254:             tz="US/Eastern",
  255:             name="idx",
  256:         )
  257:         tm.assert_index_equal(result, exp, exact=True)
  258:         assert isinstance(result, DatetimeIndex)
  259:         assert result.tz is not None
  260:         assert result.tz == exp.tz
  261: 
  262:         # Different tz results in Index(dtype=object)
  263:         result = Index(
  264:             [
  265:                 Timestamp("2011-01-01 10:00"),
  266:                 Timestamp("2011-01-02 10:00", tz="US/Eastern"),
  267:             ],
  268:             name="idx",
  269:         )
  270:         exp = Index(
  271:             [
  272:                 Timestamp("2011-01-01 10:00"),
  273:                 Timestamp("2011-01-02 10:00", tz="US/Eastern"),
  274:             ],
  275:             dtype="object",
  276:             name="idx",
  277:         )
  278:         tm.assert_index_equal(result, exp, exact=True)
  279:         assert not isinstance(result, DatetimeIndex)
  280: 
  281:         result = Index(
  282:             [
  283:                 Timestamp("2011-01-01 10:00", tz="Asia/Tokyo"),
  284:                 Timestamp("2011-01-02 10:00", tz="US/Eastern"),
  285:             ],
  286:             name="idx",
  287:         )
  288:         exp = Index(
  289:             [
  290:                 Timestamp("2011-01-01 10:00", tz="Asia/Tokyo"),
  291:                 Timestamp("2011-01-02 10:00", tz="US/Eastern"),
  292:             ],
  293:             dtype="object",
  294:             name="idx",
  295:         )
  296:         tm.assert_index_equal(result, exp, exact=True)
  297:         assert not isinstance(result, DatetimeIndex)
  298: 
  299:         msg = "DatetimeIndex has mixed timezones"
  300:         msg_depr = "parsing datetimes with mixed time zones will raise an error"
  301:         with pytest.raises(TypeError, match=msg):
  302:             with tm.assert_produces_warning(FutureWarning, match=msg_depr):
  303:                 DatetimeIndex(["2013-11-02 22:00-05:00", "2013-11-03 22:00-06:00"])
  304: 
  305:         # length = 1
  306:         result = Index([Timestamp("2011-01-01")], name="idx")
  307:         exp = DatetimeIndex([Timestamp("2011-01-01")], name="idx")
  308:         tm.assert_index_equal(result, exp, exact=True)
  309:         assert isinstance(result, DatetimeIndex)
  310:         assert result.tz is None
  311: 
  312:         # length = 1 with tz
  313:         result = Index([Timestamp("2011-01-01 10:00", tz="Asia/Tokyo")], name="idx")
  314:         exp = DatetimeIndex(
  315:             [Timestamp("2011-01-01 10:00")], tz="Asia/Tokyo", name="idx"
  316:         )
  317:         tm.assert_index_equal(result, exp, exact=True)
  318:         assert isinstance(result, DatetimeIndex)
  319:         assert result.tz is not None
  320:         assert result.tz == exp.tz
  321: 
  322:     def test_construction_index_with_mixed_timezones_with_NaT(self):
  323:         # see gh-11488
  324:         result = Index(
  325:             [pd.NaT, Timestamp("2011-01-01"), pd.NaT, Timestamp("2011-01-02")],
  326:             name="idx",
  327:         )
  328:         exp = DatetimeIndex(
  329:             [pd.NaT, Timestamp("2011-01-01"), pd.NaT, Timestamp("2011-01-02")],
  330:             name="idx",
  331:         )
  332:         tm.assert_index_equal(result, exp, exact=True)
  333:         assert isinstance(result, DatetimeIndex)
  334:         assert result.tz is None
  335: 
  336:         # Same tz results in DatetimeIndex
  337:         result = Index(
  338:             [
  339:                 pd.NaT,
  340:                 Timestamp("2011-01-01 10:00", tz="Asia/Tokyo"),
  341:                 pd.NaT,
  342:                 Timestamp("2011-01-02 10:00", tz="Asia/Tokyo"),
  343:             ],
  344:             name="idx",
  345:         )
  346:         exp = DatetimeIndex(
  347:             [
  348:                 pd.NaT,
  349:                 Timestamp("2011-01-01 10:00"),
  350:                 pd.NaT,
  351:                 Timestamp("2011-01-02 10:00"),
  352:             ],
  353:             tz="Asia/Tokyo",
  354:             name="idx",
  355:         )
  356:         tm.assert_index_equal(result, exp, exact=True)
  357:         assert isinstance(result, DatetimeIndex)
  358:         assert result.tz is not None
  359:         assert result.tz == exp.tz
  360: 
  361:         # same tz results in DatetimeIndex (DST)
  362:         result = Index(
  363:             [
  364:                 Timestamp("2011-01-01 10:00", tz="US/Eastern"),
  365:                 pd.NaT,
  366:                 Timestamp("2011-08-01 10:00", tz="US/Eastern"),
  367:             ],
  368:             name="idx",
  369:         )
  370:         exp = DatetimeIndex(
  371:             [Timestamp("2011-01-01 10:00"), pd.NaT, Timestamp("2011-08-01 10:00")],
  372:             tz="US/Eastern",
  373:             name="idx",
  374:         )
  375:         tm.assert_index_equal(result, exp, exact=True)
  376:         assert isinstance(result, DatetimeIndex)
  377:         assert result.tz is not None
  378:         assert result.tz == exp.tz
  379: 
  380:         # different tz results in Index(dtype=object)
  381:         result = Index(
  382:             [
  383:                 pd.NaT,
  384:                 Timestamp("2011-01-01 10:00"),
  385:                 pd.NaT,
  386:                 Timestamp("2011-01-02 10:00", tz="US/Eastern"),
  387:             ],
  388:             name="idx",
  389:         )
  390:         exp = Index(
  391:             [
  392:                 pd.NaT,
  393:                 Timestamp("2011-01-01 10:00"),
  394:                 pd.NaT,
  395:                 Timestamp("2011-01-02 10:00", tz="US/Eastern"),
  396:             ],
  397:             dtype="object",
  398:             name="idx",
  399:         )
  400:         tm.assert_index_equal(result, exp, exact=True)
  401:         assert not isinstance(result, DatetimeIndex)
  402: 
  403:         result = Index(
  404:             [
  405:                 pd.NaT,
  406:                 Timestamp("2011-01-01 10:00", tz="Asia/Tokyo"),
  407:                 pd.NaT,
  408:                 Timestamp("2011-01-02 10:00", tz="US/Eastern"),
  409:             ],
  410:             name="idx",
  411:         )
  412:         exp = Index(
  413:             [
  414:                 pd.NaT,
  415:                 Timestamp("2011-01-01 10:00", tz="Asia/Tokyo"),
  416:                 pd.NaT,
  417:                 Timestamp("2011-01-02 10:00", tz="US/Eastern"),
  418:             ],
  419:             dtype="object",
  420:             name="idx",
  421:         )
  422:         tm.assert_index_equal(result, exp, exact=True)
  423:         assert not isinstance(result, DatetimeIndex)
  424: 
  425:         # all NaT
  426:         result = Index([pd.NaT, pd.NaT], name="idx")
  427:         exp = DatetimeIndex([pd.NaT, pd.NaT], name="idx")
  428:         tm.assert_index_equal(result, exp, exact=True)
  429:         assert isinstance(result, DatetimeIndex)
  430:         assert result.tz is None
  431: 
  432:     def test_construction_dti_with_mixed_timezones(self):
  433:         # GH 11488 (not changed, added explicit tests)
  434: 
  435:         # no tz results in DatetimeIndex
  436:         result = DatetimeIndex(
  437:             [Timestamp("2011-01-01"), Timestamp("2011-01-02")], name="idx"
  438:         )
  439:         exp = DatetimeIndex(
  440:             [Timestamp("2011-01-01"), Timestamp("2011-01-02")], name="idx"
  441:         )
  442:         tm.assert_index_equal(result, exp, exact=True)
  443:         assert isinstance(result, DatetimeIndex)
  444: 
  445:         # same tz results in DatetimeIndex
  446:         result = DatetimeIndex(
  447:             [
  448:                 Timestamp("2011-01-01 10:00", tz="Asia/Tokyo"),
  449:                 Timestamp("2011-01-02 10:00", tz="Asia/Tokyo"),
  450:             ],
  451:             name="idx",
  452:         )
  453:         exp = DatetimeIndex(
  454:             [Timestamp("2011-01-01 10:00"), Timestamp("2011-01-02 10:00")],
  455:             tz="Asia/Tokyo",
  456:             name="idx",
  457:         )
  458:         tm.assert_index_equal(result, exp, exact=True)
  459:         assert isinstance(result, DatetimeIndex)
  460: 
  461:         # same tz results in DatetimeIndex (DST)
  462:         result = DatetimeIndex(
  463:             [
  464:                 Timestamp("2011-01-01 10:00", tz="US/Eastern"),
  465:                 Timestamp("2011-08-01 10:00", tz="US/Eastern"),
  466:             ],
  467:             name="idx",
  468:         )
  469:         exp = DatetimeIndex(
  470:             [Timestamp("2011-01-01 10:00"), Timestamp("2011-08-01 10:00")],
  471:             tz="US/Eastern",
  472:             name="idx",
  473:         )
  474:         tm.assert_index_equal(result, exp, exact=True)
  475:         assert isinstance(result, DatetimeIndex)
  476: 
  477:         # tz mismatch affecting to tz-aware raises TypeError/ValueError
  478: 
  479:         msg = "cannot be converted to datetime64"
  480:         with pytest.raises(ValueError, match=msg):
  481:             DatetimeIndex(
  482:                 [
  483:                     Timestamp("2011-01-01 10:00", tz="Asia/Tokyo"),
  484:                     Timestamp("2011-01-02 10:00", tz="US/Eastern"),
  485:                 ],
  486:                 name="idx",
  487:             )
  488: 
  489:         # pre-2.0 this raised bc of awareness mismatch. in 2.0 with a tz#
  490:         #  specified we behave as if this was called pointwise, so
  491:         #  the naive Timestamp is treated as a wall time.
  492:         dti = DatetimeIndex(
  493:             [
  494:                 Timestamp("2011-01-01 10:00"),
  495:                 Timestamp("2011-01-02 10:00", tz="US/Eastern"),
  496:             ],
  497:             tz="Asia/Tokyo",
  498:             name="idx",
  499:         )
  500:         expected = DatetimeIndex(
  501:             [
  502:                 Timestamp("2011-01-01 10:00", tz="Asia/Tokyo"),
  503:                 Timestamp("2011-01-02 10:00", tz="US/Eastern").tz_convert("Asia/Tokyo"),
  504:             ],
  505:             tz="Asia/Tokyo",
  506:             name="idx",
  507:         )
  508:         tm.assert_index_equal(dti, expected)
  509: 
  510:         # pre-2.0 mixed-tz scalars raised even if a tz/dtype was specified.
  511:         #  as of 2.0 we successfully return the requested tz/dtype
  512:         dti = DatetimeIndex(
  513:             [
  514:                 Timestamp("2011-01-01 10:00", tz="Asia/Tokyo"),
  515:                 Timestamp("2011-01-02 10:00", tz="US/Eastern"),
  516:             ],
  517:             tz="US/Eastern",
  518:             name="idx",
  519:         )
  520:         expected = DatetimeIndex(
  521:             [
  522:                 Timestamp("2011-01-01 10:00", tz="Asia/Tokyo").tz_convert("US/Eastern"),
  523:                 Timestamp("2011-01-02 10:00", tz="US/Eastern"),
  524:             ],
  525:             tz="US/Eastern",
  526:             name="idx",
  527:         )
  528:         tm.assert_index_equal(dti, expected)
  529: 
  530:         # same thing but pass dtype instead of tz
  531:         dti = DatetimeIndex(
  532:             [
  533:                 Timestamp("2011-01-01 10:00", tz="Asia/Tokyo"),
  534:                 Timestamp("2011-01-02 10:00", tz="US/Eastern"),
  535:             ],
  536:             dtype="M8[ns, US/Eastern]",
  537:             name="idx",
  538:         )
  539:         tm.assert_index_equal(dti, expected)
  540: 
  541:     def test_construction_base_constructor(self):
  542:         arr = [Timestamp("2011-01-01"), pd.NaT, Timestamp("2011-01-03")]
  543:         tm.assert_index_equal(Index(arr), DatetimeIndex(arr))
  544:         tm.assert_index_equal(Index(np.array(arr)), DatetimeIndex(np.array(arr)))
  545: 
  546:         arr = [np.nan, pd.NaT, Timestamp("2011-01-03")]
  547:         tm.assert_index_equal(Index(arr), DatetimeIndex(arr))
  548:         tm.assert_index_equal(Index(np.array(arr)), DatetimeIndex(np.array(arr)))
  549: 
  550:     def test_construction_outofbounds(self):
  551:         # GH 13663
  552:         dates = [
  553:             datetime(3000, 1, 1),
  554:             datetime(4000, 1, 1),
  555:             datetime(5000, 1, 1),
  556:             datetime(6000, 1, 1),
  557:         ]
  558:         exp = Index(dates, dtype=object)
  559:         # coerces to object
  560:         tm.assert_index_equal(Index(dates), exp)
  561: 
  562:         msg = "^Out of bounds nanosecond timestamp: 3000-01-01 00:00:00, at position 0$"
  563:         with pytest.raises(OutOfBoundsDatetime, match=msg):
  564:             # can't create DatetimeIndex
  565:             DatetimeIndex(dates)
  566: 
  567:     @pytest.mark.parametrize("data", [["1400-01-01"], [datetime(1400, 1, 1)]])
  568:     def test_dti_date_out_of_range(self, data):
  569:         # GH#1475
  570:         msg = (
  571:             "^Out of bounds nanosecond timestamp: "
  572:             "1400-01-01( 00:00:00)?, at position 0$"
  573:         )
  574:         with pytest.raises(OutOfBoundsDatetime, match=msg):
  575:             DatetimeIndex(data)
  576: 
  577:     def test_construction_with_ndarray(self):
  578:         # GH 5152
  579:         dates = [datetime(2013, 10, 7), datetime(2013, 10, 8), datetime(2013, 10, 9)]
  580:         data = DatetimeIndex(dates, freq=offsets.BDay()).values
  581:         result = DatetimeIndex(data, freq=offsets.BDay())
  582:         expected = DatetimeIndex(["2013-10-07", "2013-10-08", "2013-10-09"], freq="B")
  583:         tm.assert_index_equal(result, expected)
  584: 
  585:     def test_integer_values_and_tz_interpreted_as_utc(self):
  586:         # GH-24559
  587:         val = np.datetime64("2000-01-01 00:00:00", "ns")
  588:         values = np.array([val.view("i8")])
  589: 
  590:         result = DatetimeIndex(values).tz_localize("US/Central")
  591: 
  592:         expected = DatetimeIndex(["2000-01-01T00:00:00"], dtype="M8[ns, US/Central]")
  593:         tm.assert_index_equal(result, expected)
  594: 
  595:         # but UTC is *not* deprecated.
  596:         with tm.assert_produces_warning(None):
  597:             result = DatetimeIndex(values, tz="UTC")
  598:         expected = DatetimeIndex(["2000-01-01T00:00:00"], dtype="M8[ns, UTC]")
  599:         tm.assert_index_equal(result, expected)
  600: 
  601:     def test_constructor_coverage(self):
  602:         msg = r"DatetimeIndex\(\.\.\.\) must be called with a collection"
  603:         with pytest.raises(TypeError, match=msg):
  604:             DatetimeIndex("1/1/2000")
  605: 
  606:         # generator expression
  607:         gen = (datetime(2000, 1, 1) + timedelta(i) for i in range(10))
  608:         result = DatetimeIndex(gen)
  609:         expected = DatetimeIndex(
  610:             [datetime(2000, 1, 1) + timedelta(i) for i in range(10)]
  611:         )
  612:         tm.assert_index_equal(result, expected)
  613: 
  614:         # NumPy string array
  615:         strings = np.array(["2000-01-01", "2000-01-02", "2000-01-03"])
  616:         result = DatetimeIndex(strings)
  617:         expected = DatetimeIndex(strings.astype("O"))
  618:         tm.assert_index_equal(result, expected)
  619: 
  620:         from_ints = DatetimeIndex(expected.asi8)
  621:         tm.assert_index_equal(from_ints, expected)
  622: 
  623:         # string with NaT
  624:         strings = np.array(["2000-01-01", "2000-01-02", "NaT"])
  625:         result = DatetimeIndex(strings)
  626:         expected = DatetimeIndex(strings.astype("O"))
  627:         tm.assert_index_equal(result, expected)
  628: 
  629:         from_ints = DatetimeIndex(expected.asi8)
  630:         tm.assert_index_equal(from_ints, expected)
  631: 
  632:         # non-conforming
  633:         msg = (
  634:             "Inferred frequency None from passed values does not conform "
  635:             "to passed frequency D"
  636:         )
  637:         with pytest.raises(ValueError, match=msg):
  638:             DatetimeIndex(["2000-01-01", "2000-01-02", "2000-01-04"], freq="D")
  639: 
  640:     @pytest.mark.parametrize("freq", ["YS", "W-SUN"])
  641:     def test_constructor_datetime64_tzformat(self, freq):
  642:         # see GH#6572: ISO 8601 format results in stdlib timezone object
  643:         idx = date_range(
  644:             "2013-01-01T00:00:00-05:00", "2016-01-01T23:59:59-05:00", freq=freq
  645:         )
  646:         expected = date_range(
  647:             "2013-01-01T00:00:00",
  648:             "2016-01-01T23:59:59",
  649:             freq=freq,
  650:             tz=timezone(timedelta(minutes=-300)),
  651:         )
  652:         tm.assert_index_equal(idx, expected)
  653:         # Unable to use `US/Eastern` because of DST
  654:         expected_i8 = date_range(
  655:             "2013-01-01T00:00:00", "2016-01-01T23:59:59", freq=freq, tz="America/Lima"
  656:         )
  657:         tm.assert_numpy_array_equal(idx.asi8, expected_i8.asi8)
  658: 
  659:         idx = date_range(
  660:             "2013-01-01T00:00:00+09:00", "2016-01-01T23:59:59+09:00", freq=freq
  661:         )
  662:         expected = date_range(
  663:             "2013-01-01T00:00:00",
  664:             "2016-01-01T23:59:59",
  665:             freq=freq,
  666:             tz=timezone(timedelta(minutes=540)),
  667:         )
  668:         tm.assert_index_equal(idx, expected)
  669:         expected_i8 = date_range(
  670:             "2013-01-01T00:00:00", "2016-01-01T23:59:59", freq=freq, tz="Asia/Tokyo"
  671:         )
  672:         tm.assert_numpy_array_equal(idx.asi8, expected_i8.asi8)
  673: 
  674:         # Non ISO 8601 format results in dateutil.tz.tzoffset
  675:         idx = date_range("2013/1/1 0:00:00-5:00", "2016/1/1 23:59:59-5:00", freq=freq)
  676:         expected = date_range(
  677:             "2013-01-01T00:00:00",
  678:             "2016-01-01T23:59:59",
  679:             freq=freq,
  680:             tz=timezone(timedelta(minutes=-300)),
  681:         )
  682:         tm.assert_index_equal(idx, expected)
  683:         # Unable to use `US/Eastern` because of DST
  684:         expected_i8 = date_range(
  685:             "2013-01-01T00:00:00", "2016-01-01T23:59:59", freq=freq, tz="America/Lima"
  686:         )
  687:         tm.assert_numpy_array_equal(idx.asi8, expected_i8.asi8)
  688: 
  689:         idx = date_range("2013/1/1 0:00:00+9:00", "2016/1/1 23:59:59+09:00", freq=freq)
  690:         expected = date_range(
  691:             "2013-01-01T00:00:00",
  692:             "2016-01-01T23:59:59",
  693:             freq=freq,
  694:             tz=timezone(timedelta(minutes=540)),
  695:         )
  696:         tm.assert_index_equal(idx, expected)
  697:         expected_i8 = date_range(
  698:             "2013-01-01T00:00:00", "2016-01-01T23:59:59", freq=freq, tz="Asia/Tokyo"
  699:         )
  700:         tm.assert_numpy_array_equal(idx.asi8, expected_i8.asi8)
  701: 
  702:     def test_constructor_dtype(self):
  703:         # passing a dtype with a tz should localize
  704:         idx = DatetimeIndex(
  705:             ["2013-01-01", "2013-01-02"], dtype="datetime64[ns, US/Eastern]"
  706:         )
  707:         expected = (
  708:             DatetimeIndex(["2013-01-01", "2013-01-02"])
  709:             .as_unit("ns")
  710:             .tz_localize("US/Eastern")
  711:         )
  712:         tm.assert_index_equal(idx, expected)
  713: 
  714:         idx = DatetimeIndex(["2013-01-01", "2013-01-02"], tz="US/Eastern").as_unit("ns")
  715:         tm.assert_index_equal(idx, expected)
  716: 
  717:     def test_constructor_dtype_tz_mismatch_raises(self):
  718:         # if we already have a tz and its not the same, then raise
  719:         idx = DatetimeIndex(
  720:             ["2013-01-01", "2013-01-02"], dtype="datetime64[ns, US/Eastern]"
  721:         )
  722: 
  723:         msg = (
  724:             "cannot supply both a tz and a timezone-naive dtype "
  725:             r"\(i\.e\. datetime64\[ns\]\)"
  726:         )
  727:         with pytest.raises(ValueError, match=msg):
  728:             DatetimeIndex(idx, dtype="datetime64[ns]")
  729: 
  730:         # this is effectively trying to convert tz's
  731:         msg = "data is already tz-aware US/Eastern, unable to set specified tz: CET"
  732:         with pytest.raises(TypeError, match=msg):
  733:             DatetimeIndex(idx, dtype="datetime64[ns, CET]")
  734:         msg = "cannot supply both a tz and a dtype with a tz"
  735:         with pytest.raises(ValueError, match=msg):
  736:             DatetimeIndex(idx, tz="CET", dtype="datetime64[ns, US/Eastern]")
  737: 
  738:         result = DatetimeIndex(idx, dtype="datetime64[ns, US/Eastern]")
  739:         tm.assert_index_equal(idx, result)
  740: 
  741:     @pytest.mark.parametrize("dtype", [object, np.int32, np.int64])
  742:     def test_constructor_invalid_dtype_raises(self, dtype):
  743:         # GH 23986
  744:         msg = "Unexpected value for 'dtype'"
  745:         with pytest.raises(ValueError, match=msg):
  746:             DatetimeIndex([1, 2], dtype=dtype)
  747: 
  748:     def test_000constructor_resolution(self):
  749:         # 2252
  750:         t1 = Timestamp((1352934390 * 1000000000) + 1000000 + 1000 + 1)
  751:         idx = DatetimeIndex([t1])
  752: 
  753:         assert idx.nanosecond[0] == t1.nanosecond
  754: 
  755:     def test_disallow_setting_tz(self):
  756:         # GH 3746
  757:         dti = DatetimeIndex(["2010"], tz="UTC")
  758:         msg = "Cannot directly set timezone"
  759:         with pytest.raises(AttributeError, match=msg):
  760:             dti.tz = pytz.timezone("US/Pacific")
  761: 
  762:     @pytest.mark.parametrize(
  763:         "tz",
  764:         [
  765:             None,
  766:             "America/Los_Angeles",
  767:             pytz.timezone("America/Los_Angeles"),
  768:             Timestamp("2000", tz="America/Los_Angeles").tz,
  769:         ],
  770:     )
  771:     def test_constructor_start_end_with_tz(self, tz):
  772:         # GH 18595
  773:         start = Timestamp("2013-01-01 06:00:00", tz="America/Los_Angeles")
  774:         end = Timestamp("2013-01-02 06:00:00", tz="America/Los_Angeles")
  775:         result = date_range(freq="D", start=start, end=end, tz=tz)
  776:         expected = DatetimeIndex(
  777:             ["2013-01-01 06:00:00", "2013-01-02 06:00:00"],
  778:             dtype="M8[ns, America/Los_Angeles]",
  779:             freq="D",
  780:         )
  781:         tm.assert_index_equal(result, expected)
  782:         # Especially assert that the timezone is consistent for pytz
  783:         assert pytz.timezone("America/Los_Angeles") is result.tz
  784: 
  785:     @pytest.mark.parametrize("tz", ["US/Pacific", "US/Eastern", "Asia/Tokyo"])
  786:     def test_constructor_with_non_normalized_pytz(self, tz):
  787:         # GH 18595
  788:         non_norm_tz = Timestamp("2010", tz=tz).tz
  789:         result = DatetimeIndex(["2010"], tz=non_norm_tz)
  790:         assert pytz.timezone(tz) is result.tz
  791: 
  792:     def test_constructor_timestamp_near_dst(self):
  793:         # GH 20854
  794:         ts = [
  795:             Timestamp("2016-10-30 03:00:00+0300", tz="Europe/Helsinki"),
  796:             Timestamp("2016-10-30 03:00:00+0200", tz="Europe/Helsinki"),
  797:         ]
  798:         result = DatetimeIndex(ts)
  799:         expected = DatetimeIndex([ts[0].to_pydatetime(), ts[1].to_pydatetime()])
  800:         tm.assert_index_equal(result, expected)
  801: 
  802:     @pytest.mark.parametrize("klass", [Index, DatetimeIndex])
  803:     @pytest.mark.parametrize("box", [np.array, partial(np.array, dtype=object), list])
  804:     @pytest.mark.parametrize(
  805:         "tz, dtype",
  806:         [("US/Pacific", "datetime64[ns, US/Pacific]"), (None, "datetime64[ns]")],
  807:     )
  808:     def test_constructor_with_int_tz(self, klass, box, tz, dtype):
  809:         # GH 20997, 20964
  810:         ts = Timestamp("2018-01-01", tz=tz).as_unit("ns")
  811:         result = klass(box([ts._value]), dtype=dtype)
  812:         expected = klass([ts])
  813:         assert result == expected
  814: 
  815:     def test_construction_int_rountrip(self, tz_naive_fixture):
  816:         # GH 12619, GH#24559
  817:         tz = tz_naive_fixture
  818: 
  819:         result = 1293858000000000000
  820:         expected = DatetimeIndex([result], tz=tz).asi8[0]
  821:         assert result == expected
  822: 
  823:     def test_construction_from_replaced_timestamps_with_dst(self):
  824:         # GH 18785
  825:         index = date_range(
  826:             Timestamp(2000, 12, 31),
  827:             Timestamp(2005, 12, 31),
  828:             freq="YE-DEC",
  829:             tz="Australia/Melbourne",
  830:         )
  831:         result = DatetimeIndex([x.replace(month=6, day=1) for x in index])
  832:         expected = DatetimeIndex(
  833:             [
  834:                 "2000-06-01 00:00:00",
  835:                 "2001-06-01 00:00:00",
  836:                 "2002-06-01 00:00:00",
  837:                 "2003-06-01 00:00:00",
  838:                 "2004-06-01 00:00:00",
  839:                 "2005-06-01 00:00:00",
  840:             ],
  841:             tz="Australia/Melbourne",
  842:         )
  843:         tm.assert_index_equal(result, expected)
  844: 
  845:     def test_construction_with_tz_and_tz_aware_dti(self):
  846:         # GH 23579
  847:         dti = date_range("2016-01-01", periods=3, tz="US/Central")
  848:         msg = "data is already tz-aware US/Central, unable to set specified tz"
  849:         with pytest.raises(TypeError, match=msg):
  850:             DatetimeIndex(dti, tz="Asia/Tokyo")
  851: 
  852:     def test_construction_with_nat_and_tzlocal(self):
  853:         tz = dateutil.tz.tzlocal()
  854:         result = DatetimeIndex(["2018", "NaT"], tz=tz)
  855:         expected = DatetimeIndex([Timestamp("2018", tz=tz), pd.NaT])
  856:         tm.assert_index_equal(result, expected)
  857: 
  858:     def test_constructor_with_ambiguous_keyword_arg(self):
  859:         # GH 35297
  860: 
  861:         expected = DatetimeIndex(
  862:             ["2020-11-01 01:00:00", "2020-11-02 01:00:00"],
  863:             dtype="datetime64[ns, America/New_York]",
  864:             freq="D",
  865:             ambiguous=False,
  866:         )
  867: 
  868:         # ambiguous keyword in start
  869:         timezone = "America/New_York"
  870:         start = Timestamp(year=2020, month=11, day=1, hour=1).tz_localize(
  871:             timezone, ambiguous=False
  872:         )
  873:         result = date_range(start=start, periods=2, ambiguous=False)
  874:         tm.assert_index_equal(result, expected)
  875: 
  876:         # ambiguous keyword in end
  877:         timezone = "America/New_York"
  878:         end = Timestamp(year=2020, month=11, day=2, hour=1).tz_localize(
  879:             timezone, ambiguous=False
  880:         )
  881:         result = date_range(end=end, periods=2, ambiguous=False)
  882:         tm.assert_index_equal(result, expected)
  883: 
  884:     def test_constructor_with_nonexistent_keyword_arg(self, warsaw):
  885:         # GH 35297
  886:         timezone = warsaw
  887: 
  888:         # nonexistent keyword in start
  889:         start = Timestamp("2015-03-29 02:30:00").tz_localize(
  890:             timezone, nonexistent="shift_forward"
  891:         )
  892:         result = date_range(start=start, periods=2, freq="h")
  893:         expected = DatetimeIndex(
  894:             [
  895:                 Timestamp("2015-03-29 03:00:00+02:00", tz=timezone),
  896:                 Timestamp("2015-03-29 04:00:00+02:00", tz=timezone),
  897:             ]
  898:         )
  899: 
  900:         tm.assert_index_equal(result, expected)
  901: 
  902:         # nonexistent keyword in end
  903:         end = start
  904:         result = date_range(end=end, periods=2, freq="h")
  905:         expected = DatetimeIndex(
  906:             [
  907:                 Timestamp("2015-03-29 01:00:00+01:00", tz=timezone),
  908:                 Timestamp("2015-03-29 03:00:00+02:00", tz=timezone),
  909:             ]
  910:         )
  911: 
  912:         tm.assert_index_equal(result, expected)
  913: 
  914:     def test_constructor_no_precision_raises(self):
  915:         # GH-24753, GH-24739
  916: 
  917:         msg = "with no precision is not allowed"
  918:         with pytest.raises(ValueError, match=msg):
  919:             DatetimeIndex(["2000"], dtype="datetime64")
  920: 
  921:         msg = "The 'datetime64' dtype has no unit. Please pass in"
  922:         with pytest.raises(ValueError, match=msg):
  923:             Index(["2000"], dtype="datetime64")
  924: 
  925:     def test_constructor_wrong_precision_raises(self):
  926:         dti = DatetimeIndex(["2000"], dtype="datetime64[us]")
  927:         assert dti.dtype == "M8[us]"
  928:         assert dti[0] == Timestamp(2000, 1, 1)
  929: 
  930:     def test_index_constructor_with_numpy_object_array_and_timestamp_tz_with_nan(self):
  931:         # GH 27011
  932:         result = Index(np.array([Timestamp("2019", tz="UTC"), np.nan], dtype=object))
  933:         expected = DatetimeIndex([Timestamp("2019", tz="UTC"), pd.NaT])
  934:         tm.assert_index_equal(result, expected)
  935: 
  936:     @pytest.mark.parametrize("tz", [pytz.timezone("US/Eastern"), gettz("US/Eastern")])
  937:     def test_dti_from_tzaware_datetime(self, tz):
  938:         d = [datetime(2012, 8, 19, tzinfo=tz)]
  939: 
  940:         index = DatetimeIndex(d)
  941:         assert timezones.tz_compare(index.tz, tz)
  942: 
  943:     @pytest.mark.parametrize("tzstr", ["US/Eastern", "dateutil/US/Eastern"])
  944:     def test_dti_tz_constructors(self, tzstr):
  945:         """Test different DatetimeIndex constructions with timezone
  946:         Follow-up of GH#4229
  947:         """
  948:         arr = ["11/10/2005 08:00:00", "11/10/2005 09:00:00"]
  949: 
  950:         idx1 = to_datetime(arr).tz_localize(tzstr)
  951:         idx2 = date_range(start="2005-11-10 08:00:00", freq="h", periods=2, tz=tzstr)
  952:         idx2 = idx2._with_freq(None)  # the others all have freq=None
  953:         idx3 = DatetimeIndex(arr, tz=tzstr)
  954:         idx4 = DatetimeIndex(np.array(arr), tz=tzstr)
  955: 
  956:         for other in [idx2, idx3, idx4]:
  957:             tm.assert_index_equal(idx1, other)
  958: 
  959:     def test_dti_construction_idempotent(self, unit):
  960:         rng = date_range(
  961:             "03/12/2012 00:00", periods=10, freq="W-FRI", tz="US/Eastern", unit=unit
  962:         )
  963:         rng2 = DatetimeIndex(data=rng, tz="US/Eastern")
  964:         tm.assert_index_equal(rng, rng2)
  965: 
  966:     @pytest.mark.parametrize("prefix", ["", "dateutil/"])
  967:     def test_dti_constructor_static_tzinfo(self, prefix):
  968:         # it works!
  969:         index = DatetimeIndex([datetime(2012, 1, 1)], tz=prefix + "EST")
  970:         index.hour
  971:         index[0]
  972: 
  973:     @pytest.mark.parametrize("tzstr", ["US/Eastern", "dateutil/US/Eastern"])
  974:     def test_dti_convert_datetime_list(self, tzstr):
  975:         dr = date_range("2012-06-02", periods=10, tz=tzstr, name="foo")
  976:         dr2 = DatetimeIndex(list(dr), name="foo", freq="D")
  977:         tm.assert_index_equal(dr, dr2)
  978: 
  979:     @pytest.mark.parametrize(
  980:         "tz",
  981:         [
  982:             pytz.timezone("US/Eastern"),
  983:             gettz("US/Eastern"),
  984:         ],
  985:     )
  986:     @pytest.mark.parametrize("use_str", [True, False])
  987:     @pytest.mark.parametrize("box_cls", [Timestamp, DatetimeIndex])
  988:     def test_dti_ambiguous_matches_timestamp(self, tz, use_str, box_cls, request):
  989:         # GH#47471 check that we get the same raising behavior in the DTI
  990:         # constructor and Timestamp constructor
  991:         dtstr = "2013-11-03 01:59:59.999999"
  992:         item = dtstr
  993:         if not use_str:
  994:             item = Timestamp(dtstr).to_pydatetime()
  995:         if box_cls is not Timestamp:
  996:             item = [item]
  997: 
  998:         if not use_str and isinstance(tz, dateutil.tz.tzfile):
  999:             # FIXME: The Timestamp constructor here behaves differently than all
 1000:             #  the other cases bc with dateutil/zoneinfo tzinfos we implicitly
 1001:             #  get fold=0. Having this raise is not important, but having the
 1002:             #  behavior be consistent across cases is.
 1003:             mark = pytest.mark.xfail(reason="We implicitly get fold=0.")
 1004:             request.applymarker(mark)
 1005: 
 1006:         with pytest.raises(pytz.AmbiguousTimeError, match=dtstr):
 1007:             box_cls(item, tz=tz)
 1008: 
 1009:     @pytest.mark.parametrize("tz", [None, "UTC", "US/Pacific"])
 1010:     def test_dti_constructor_with_non_nano_dtype(self, tz):
 1011:         # GH#55756, GH#54620
 1012:         ts = Timestamp("2999-01-01")
 1013:         dtype = "M8[us]"
 1014:         if tz is not None:
 1015:             dtype = f"M8[us, {tz}]"
 1016:         vals = [ts, "2999-01-02 03:04:05.678910", 2500]
 1017:         result = DatetimeIndex(vals, dtype=dtype)
 1018:         # The 2500 is interpreted as microseconds, consistent with what
 1019:         #  we would get if we created DatetimeIndexes from vals[:2] and vals[2:]
 1020:         #  and concated the results.
 1021:         pointwise = [
 1022:             vals[0].tz_localize(tz),
 1023:             Timestamp(vals[1], tz=tz),
 1024:             to_datetime(vals[2], unit="us", utc=True).tz_convert(tz),
 1025:         ]
 1026:         exp_vals = [x.as_unit("us").asm8 for x in pointwise]
 1027:         exp_arr = np.array(exp_vals, dtype="M8[us]")
 1028:         expected = DatetimeIndex(exp_arr, dtype="M8[us]")
 1029:         if tz is not None:
 1030:             expected = expected.tz_localize("UTC").tz_convert(tz)
 1031:         tm.assert_index_equal(result, expected)
 1032: 
 1033:         result2 = DatetimeIndex(np.array(vals, dtype=object), dtype=dtype)
 1034:         tm.assert_index_equal(result2, expected)
 1035: 
 1036:     def test_dti_constructor_with_non_nano_now_today(self):
 1037:         # GH#55756
 1038:         now = Timestamp.now()
 1039:         today = Timestamp.today()
 1040:         result = DatetimeIndex(["now", "today"], dtype="M8[s]")
 1041:         assert result.dtype == "M8[s]"
 1042: 
 1043:         # result may not exactly match [now, today] so we'll test it up to a tolerance.
 1044:         #  (it *may* match exactly due to rounding)
 1045:         tolerance = pd.Timedelta(microseconds=1)
 1046: 
 1047:         diff0 = result[0] - now.as_unit("s")
 1048:         assert diff0 >= pd.Timedelta(0)
 1049:         assert diff0 < tolerance
 1050: 
 1051:         diff1 = result[1] - today.as_unit("s")
 1052:         assert diff1 >= pd.Timedelta(0)
 1053:         assert diff1 < tolerance
 1054: 
 1055:     def test_dti_constructor_object_float_matches_float_dtype(self):
 1056:         # GH#55780
 1057:         arr = np.array([0, np.nan], dtype=np.float64)
 1058:         arr2 = arr.astype(object)
 1059: 
 1060:         dti1 = DatetimeIndex(arr, tz="CET")
 1061:         dti2 = DatetimeIndex(arr2, tz="CET")
 1062:         tm.assert_index_equal(dti1, dti2)
 1063: 
 1064:     @pytest.mark.parametrize("dtype", ["M8[us]", "M8[us, US/Pacific]"])
 1065:     def test_dti_constructor_with_dtype_object_int_matches_int_dtype(self, dtype):
 1066:         # Going through the object path should match the non-object path
 1067: 
 1068:         vals1 = np.arange(5, dtype="i8") * 1000
 1069:         vals1[0] = pd.NaT.value
 1070: 
 1071:         vals2 = vals1.astype(np.float64)
 1072:         vals2[0] = np.nan
 1073: 
 1074:         vals3 = vals1.astype(object)
 1075:         # change lib.infer_dtype(vals3) from "integer" so we go through
 1076:         #  array_to_datetime in _sequence_to_dt64
 1077:         vals3[0] = pd.NaT
 1078: 
 1079:         vals4 = vals2.astype(object)
 1080: 
 1081:         res1 = DatetimeIndex(vals1, dtype=dtype)
 1082:         res2 = DatetimeIndex(vals2, dtype=dtype)
 1083:         res3 = DatetimeIndex(vals3, dtype=dtype)
 1084:         res4 = DatetimeIndex(vals4, dtype=dtype)
 1085: 
 1086:         expected = DatetimeIndex(vals1.view("M8[us]"))
 1087:         if res1.tz is not None:
 1088:             expected = expected.tz_localize("UTC").tz_convert(res1.tz)
 1089:         tm.assert_index_equal(res1, expected)
 1090:         tm.assert_index_equal(res2, expected)
 1091:         tm.assert_index_equal(res3, expected)
 1092:         tm.assert_index_equal(res4, expected)
 1093: 
 1094: 
 1095: class TestTimeSeries:
 1096:     def test_dti_constructor_preserve_dti_freq(self):
 1097:         rng = date_range("1/1/2000", "1/2/2000", freq="5min")
 1098: 
 1099:         rng2 = DatetimeIndex(rng)
 1100:         assert rng.freq == rng2.freq
 1101: 
 1102:     def test_explicit_none_freq(self):
 1103:         # Explicitly passing freq=None is respected
 1104:         rng = date_range("1/1/2000", "1/2/2000", freq="5min")
 1105: 
 1106:         result = DatetimeIndex(rng, freq=None)
 1107:         assert result.freq is None
 1108: 
 1109:         result = DatetimeIndex(rng._data, freq=None)
 1110:         assert result.freq is None
 1111: 
 1112:     def test_dti_constructor_small_int(self, any_int_numpy_dtype):
 1113:         # see gh-13721
 1114:         exp = DatetimeIndex(
 1115:             [
 1116:                 "1970-01-01 00:00:00.00000000",
 1117:                 "1970-01-01 00:00:00.00000001",
 1118:                 "1970-01-01 00:00:00.00000002",
 1119:             ]
 1120:         )
 1121: 
 1122:         arr = np.array([0, 10, 20], dtype=any_int_numpy_dtype)
 1123:         tm.assert_index_equal(DatetimeIndex(arr), exp)
 1124: 
 1125:     def test_ctor_str_intraday(self):
 1126:         rng = DatetimeIndex(["1-1-2000 00:00:01"])
 1127:         assert rng[0].second == 1
 1128: 
 1129:     def test_index_cast_datetime64_other_units(self):
 1130:         arr = np.arange(0, 100, 10, dtype=np.int64).view("M8[D]")
 1131:         idx = Index(arr)
 1132: 
 1133:         assert (idx.values == astype_overflowsafe(arr, dtype=np.dtype("M8[ns]"))).all()
 1134: 
 1135:     def test_constructor_int64_nocopy(self):
 1136:         # GH#1624
 1137:         arr = np.arange(1000, dtype=np.int64)
 1138:         index = DatetimeIndex(arr)
 1139: 
 1140:         arr[50:100] = -1
 1141:         assert (index.asi8[50:100] == -1).all()
 1142: 
 1143:         arr = np.arange(1000, dtype=np.int64)
 1144:         index = DatetimeIndex(arr, copy=True)
 1145: 
 1146:         arr[50:100] = -1
 1147:         assert (index.asi8[50:100] != -1).all()
 1148: 
 1149:     @pytest.mark.parametrize(
 1150:         "freq",
 1151:         ["ME", "QE", "YE", "D", "B", "bh", "min", "s", "ms", "us", "h", "ns", "C"],
 1152:     )
 1153:     def test_from_freq_recreate_from_data(self, freq):
 1154:         org = date_range(start="2001/02/01 09:00", freq=freq, periods=1)
 1155:         idx = DatetimeIndex(org, freq=freq)
 1156:         tm.assert_index_equal(idx, org)
 1157: 
 1158:         org = date_range(
 1159:             start="2001/02/01 09:00", freq=freq, tz="US/Pacific", periods=1
 1160:         )
 1161:         idx = DatetimeIndex(org, freq=freq, tz="US/Pacific")
 1162:         tm.assert_index_equal(idx, org)
 1163: 
 1164:     def test_datetimeindex_constructor_misc(self):
 1165:         arr = ["1/1/2005", "1/2/2005", "Jn 3, 2005", "2005-01-04"]
 1166:         msg = r"(\(')?Unknown datetime string format(:', 'Jn 3, 2005'\))?"
 1167:         with pytest.raises(ValueError, match=msg):
 1168:             DatetimeIndex(arr)
 1169: 
 1170:         arr = ["1/1/2005", "1/2/2005", "1/3/2005", "2005-01-04"]
 1171:         idx1 = DatetimeIndex(arr)
 1172: 
 1173:         arr = [datetime(2005, 1, 1), "1/2/2005", "1/3/2005", "2005-01-04"]
 1174:         idx2 = DatetimeIndex(arr)
 1175: 
 1176:         arr = [Timestamp(datetime(2005, 1, 1)), "1/2/2005", "1/3/2005", "2005-01-04"]
 1177:         idx3 = DatetimeIndex(arr)
 1178: 
 1179:         arr = np.array(["1/1/2005", "1/2/2005", "1/3/2005", "2005-01-04"], dtype="O")
 1180:         idx4 = DatetimeIndex(arr)
 1181: 
 1182:         idx5 = DatetimeIndex(["12/05/2007", "25/01/2008"], dayfirst=True)
 1183:         idx6 = DatetimeIndex(
 1184:             ["2007/05/12", "2008/01/25"], dayfirst=False, yearfirst=True
 1185:         )
 1186:         tm.assert_index_equal(idx5, idx6)
 1187: 
 1188:         for other in [idx2, idx3, idx4]:
 1189:             assert (idx1.values == other.values).all()
 1190: 
 1191:     def test_dti_constructor_object_dtype_dayfirst_yearfirst_with_tz(self):
 1192:         # GH#55813
 1193:         val = "5/10/16"
 1194: 
 1195:         dfirst = Timestamp(2016, 10, 5, tz="US/Pacific")
 1196:         yfirst = Timestamp(2005, 10, 16, tz="US/Pacific")
 1197: 
 1198:         result1 = DatetimeIndex([val], tz="US/Pacific", dayfirst=True)
 1199:         expected1 = DatetimeIndex([dfirst])
 1200:         tm.assert_index_equal(result1, expected1)
 1201: 
 1202:         result2 = DatetimeIndex([val], tz="US/Pacific", yearfirst=True)
 1203:         expected2 = DatetimeIndex([yfirst])
 1204:         tm.assert_index_equal(result2, expected2)
