    1: import pytest
    2: 
    3: import pandas as pd
    4: from pandas import MultiIndex
    5: import pandas._testing as tm
    6: 
    7: 
    8: def check_level_names(index, names):
    9:     assert [level.name for level in index.levels] == list(names)
   10: 
   11: 
   12: def test_slice_keep_name():
   13:     x = MultiIndex.from_tuples([("a", "b"), (1, 2), ("c", "d")], names=["x", "y"])
   14:     assert x[1:].names == x.names
   15: 
   16: 
   17: def test_index_name_retained():
   18:     # GH9857
   19:     result = pd.DataFrame({"x": [1, 2, 6], "y": [2, 2, 8], "z": [-5, 0, 5]})
   20:     result = result.set_index("z")
   21:     result.loc[10] = [9, 10]
   22:     df_expected = pd.DataFrame(
   23:         {"x": [1, 2, 6, 9], "y": [2, 2, 8, 10], "z": [-5, 0, 5, 10]}
   24:     )
   25:     df_expected = df_expected.set_index("z")
   26:     tm.assert_frame_equal(result, df_expected)
   27: 
   28: 
   29: def test_changing_names(idx):
   30:     assert [level.name for level in idx.levels] == ["first", "second"]
   31: 
   32:     view = idx.view()
   33:     copy = idx.copy()
   34:     shallow_copy = idx._view()
   35: 
   36:     # changing names should not change level names on object
   37:     new_names = [name + "a" for name in idx.names]
   38:     idx.names = new_names
   39:     check_level_names(idx, ["firsta", "seconda"])
   40: 
   41:     # and not on copies
   42:     check_level_names(view, ["first", "second"])
   43:     check_level_names(copy, ["first", "second"])
   44:     check_level_names(shallow_copy, ["first", "second"])
   45: 
   46:     # and copies shouldn't change original
   47:     shallow_copy.names = [name + "c" for name in shallow_copy.names]
   48:     check_level_names(idx, ["firsta", "seconda"])
   49: 
   50: 
   51: def test_take_preserve_name(idx):
   52:     taken = idx.take([3, 0, 1])
   53:     assert taken.names == idx.names
   54: 
   55: 
   56: def test_copy_names():
   57:     # Check that adding a "names" parameter to the copy is honored
   58:     # GH14302
   59:     multi_idx = MultiIndex.from_tuples([(1, 2), (3, 4)], names=["MyName1", "MyName2"])
   60:     multi_idx1 = multi_idx.copy()
   61: 
   62:     assert multi_idx.equals(multi_idx1)
   63:     assert multi_idx.names == ["MyName1", "MyName2"]
   64:     assert multi_idx1.names == ["MyName1", "MyName2"]
   65: 
   66:     multi_idx2 = multi_idx.copy(names=["NewName1", "NewName2"])
   67: 
   68:     assert multi_idx.equals(multi_idx2)
   69:     assert multi_idx.names == ["MyName1", "MyName2"]
   70:     assert multi_idx2.names == ["NewName1", "NewName2"]
   71: 
   72:     multi_idx3 = multi_idx.copy(name=["NewName1", "NewName2"])
   73: 
   74:     assert multi_idx.equals(multi_idx3)
   75:     assert multi_idx.names == ["MyName1", "MyName2"]
   76:     assert multi_idx3.names == ["NewName1", "NewName2"]
   77: 
   78:     # gh-35592
   79:     with pytest.raises(ValueError, match="Length of new names must be 2, got 1"):
   80:         multi_idx.copy(names=["mario"])
   81: 
   82:     with pytest.raises(TypeError, match="MultiIndex.name must be a hashable type"):
   83:         multi_idx.copy(names=[["mario"], ["luigi"]])
   84: 
   85: 
   86: def test_names(idx):
   87:     # names are assigned in setup
   88:     assert idx.names == ["first", "second"]
   89:     level_names = [level.name for level in idx.levels]
   90:     assert level_names == idx.names
   91: 
   92:     # setting bad names on existing
   93:     index = idx
   94:     with pytest.raises(ValueError, match="^Length of names"):
   95:         setattr(index, "names", list(index.names) + ["third"])
   96:     with pytest.raises(ValueError, match="^Length of names"):
   97:         setattr(index, "names", [])
   98: 
   99:     # initializing with bad names (should always be equivalent)
  100:     major_axis, minor_axis = idx.levels
  101:     major_codes, minor_codes = idx.codes
  102:     with pytest.raises(ValueError, match="^Length of names"):
  103:         MultiIndex(
  104:             levels=[major_axis, minor_axis],
  105:             codes=[major_codes, minor_codes],
  106:             names=["first"],
  107:         )
  108:     with pytest.raises(ValueError, match="^Length of names"):
  109:         MultiIndex(
  110:             levels=[major_axis, minor_axis],
  111:             codes=[major_codes, minor_codes],
  112:             names=["first", "second", "third"],
  113:         )
  114: 
  115:     # names are assigned on index, but not transferred to the levels
  116:     index.names = ["a", "b"]
  117:     level_names = [level.name for level in index.levels]
  118:     assert level_names == ["a", "b"]
  119: 
  120: 
  121: def test_duplicate_level_names_access_raises(idx):
  122:     # GH19029
  123:     idx.names = ["foo", "foo"]
  124:     with pytest.raises(ValueError, match="name foo occurs multiple times"):
  125:         idx._get_level_number("foo")
  126: 
  127: 
  128: def test_get_names_from_levels():
  129:     idx = MultiIndex.from_product([["a"], [1, 2]], names=["a", "b"])
  130: 
  131:     assert idx.levels[0].name == "a"
  132:     assert idx.levels[1].name == "b"
  133: 
  134: 
  135: def test_setting_names_from_levels_raises():
  136:     idx = MultiIndex.from_product([["a"], [1, 2]], names=["a", "b"])
  137:     with pytest.raises(RuntimeError, match="set_names"):
  138:         idx.levels[0].name = "foo"
  139: 
  140:     with pytest.raises(RuntimeError, match="set_names"):
  141:         idx.levels[1].name = "foo"
  142: 
  143:     new = pd.Series(1, index=idx.levels[0])
  144:     with pytest.raises(RuntimeError, match="set_names"):
  145:         new.index.name = "bar"
  146: 
  147:     assert pd.Index._no_setting_name is False
  148:     assert pd.RangeIndex._no_setting_name is False
  149: 
  150: 
  151: @pytest.mark.parametrize("func", ["rename", "set_names"])
  152: @pytest.mark.parametrize(
  153:     "rename_dict, exp_names",
  154:     [
  155:         ({"x": "z"}, ["z", "y", "z"]),
  156:         ({"x": "z", "y": "x"}, ["z", "x", "z"]),
  157:         ({"y": "z"}, ["x", "z", "x"]),
  158:         ({}, ["x", "y", "x"]),
  159:         ({"z": "a"}, ["x", "y", "x"]),
  160:         ({"y": "z", "a": "b"}, ["x", "z", "x"]),
  161:     ],
  162: )
  163: def test_name_mi_with_dict_like_duplicate_names(func, rename_dict, exp_names):
  164:     # GH#20421
  165:     mi = MultiIndex.from_arrays([[1, 2], [3, 4], [5, 6]], names=["x", "y", "x"])
  166:     result = getattr(mi, func)(rename_dict)
  167:     expected = MultiIndex.from_arrays([[1, 2], [3, 4], [5, 6]], names=exp_names)
  168:     tm.assert_index_equal(result, expected)
  169: 
  170: 
  171: @pytest.mark.parametrize("func", ["rename", "set_names"])
  172: @pytest.mark.parametrize(
  173:     "rename_dict, exp_names",
  174:     [
  175:         ({"x": "z"}, ["z", "y"]),
  176:         ({"x": "z", "y": "x"}, ["z", "x"]),
  177:         ({"a": "z"}, ["x", "y"]),
  178:         ({}, ["x", "y"]),
  179:     ],
  180: )
  181: def test_name_mi_with_dict_like(func, rename_dict, exp_names):
  182:     # GH#20421
  183:     mi = MultiIndex.from_arrays([[1, 2], [3, 4]], names=["x", "y"])
  184:     result = getattr(mi, func)(rename_dict)
  185:     expected = MultiIndex.from_arrays([[1, 2], [3, 4]], names=exp_names)
  186:     tm.assert_index_equal(result, expected)
  187: 
  188: 
  189: def test_index_name_with_dict_like_raising():
  190:     # GH#20421
  191:     ix = pd.Index([1, 2])
  192:     msg = "Can only pass dict-like as `names` for MultiIndex."
  193:     with pytest.raises(TypeError, match=msg):
  194:         ix.set_names({"x": "z"})
  195: 
  196: 
  197: def test_multiindex_name_and_level_raising():
  198:     # GH#20421
  199:     mi = MultiIndex.from_arrays([[1, 2], [3, 4]], names=["x", "y"])
  200:     with pytest.raises(TypeError, match="Can not pass level for dictlike `names`."):
  201:         mi.set_names(names={"x": "z"}, level={"x": "z"})
