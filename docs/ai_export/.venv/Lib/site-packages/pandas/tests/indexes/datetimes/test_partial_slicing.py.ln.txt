    1: """ test partial slicing on Series/Frame """
    2: 
    3: from datetime import datetime
    4: 
    5: import numpy as np
    6: import pytest
    7: 
    8: from pandas import (
    9:     DataFrame,
   10:     DatetimeIndex,
   11:     Index,
   12:     MultiIndex,
   13:     Series,
   14:     Timedelta,
   15:     Timestamp,
   16:     date_range,
   17: )
   18: import pandas._testing as tm
   19: 
   20: 
   21: class TestSlicing:
   22:     def test_string_index_series_name_converted(self):
   23:         # GH#1644
   24:         df = DataFrame(
   25:             np.random.default_rng(2).standard_normal((10, 4)),
   26:             index=date_range("1/1/2000", periods=10),
   27:         )
   28: 
   29:         result = df.loc["1/3/2000"]
   30:         assert result.name == df.index[2]
   31: 
   32:         result = df.T["1/3/2000"]
   33:         assert result.name == df.index[2]
   34: 
   35:     def test_stringified_slice_with_tz(self):
   36:         # GH#2658
   37:         start = "2013-01-07"
   38:         idx = date_range(start=start, freq="1d", periods=10, tz="US/Eastern")
   39:         df = DataFrame(np.arange(10), index=idx)
   40:         df["2013-01-14 23:44:34.437768-05:00":]  # no exception here
   41: 
   42:     def test_return_type_doesnt_depend_on_monotonicity(self):
   43:         # GH#24892 we get Series back regardless of whether our DTI is monotonic
   44:         dti = date_range(start="2015-5-13 23:59:00", freq="min", periods=3)
   45:         ser = Series(range(3), index=dti)
   46: 
   47:         # non-monotonic index
   48:         ser2 = Series(range(3), index=[dti[1], dti[0], dti[2]])
   49: 
   50:         # key with resolution strictly lower than "min"
   51:         key = "2015-5-14 00"
   52: 
   53:         # monotonic increasing index
   54:         result = ser.loc[key]
   55:         expected = ser.iloc[1:]
   56:         tm.assert_series_equal(result, expected)
   57: 
   58:         # monotonic decreasing index
   59:         result = ser.iloc[::-1].loc[key]
   60:         expected = ser.iloc[::-1][:-1]
   61:         tm.assert_series_equal(result, expected)
   62: 
   63:         # non-monotonic index
   64:         result2 = ser2.loc[key]
   65:         expected2 = ser2.iloc[::2]
   66:         tm.assert_series_equal(result2, expected2)
   67: 
   68:     def test_return_type_doesnt_depend_on_monotonicity_higher_reso(self):
   69:         # GH#24892 we get Series back regardless of whether our DTI is monotonic
   70:         dti = date_range(start="2015-5-13 23:59:00", freq="min", periods=3)
   71:         ser = Series(range(3), index=dti)
   72: 
   73:         # non-monotonic index
   74:         ser2 = Series(range(3), index=[dti[1], dti[0], dti[2]])
   75: 
   76:         # key with resolution strictly *higher) than "min"
   77:         key = "2015-5-14 00:00:00"
   78: 
   79:         # monotonic increasing index
   80:         result = ser.loc[key]
   81:         assert result == 1
   82: 
   83:         # monotonic decreasing index
   84:         result = ser.iloc[::-1].loc[key]
   85:         assert result == 1
   86: 
   87:         # non-monotonic index
   88:         result2 = ser2.loc[key]
   89:         assert result2 == 0
   90: 
   91:     def test_monotone_DTI_indexing_bug(self):
   92:         # GH 19362
   93:         # Testing accessing the first element in a monotonic descending
   94:         # partial string indexing.
   95: 
   96:         df = DataFrame(list(range(5)))
   97:         date_list = [
   98:             "2018-01-02",
   99:             "2017-02-10",
  100:             "2016-03-10",
  101:             "2015-03-15",
  102:             "2014-03-16",
  103:         ]
  104:         date_index = DatetimeIndex(date_list)
  105:         df["date"] = date_index
  106:         expected = DataFrame({0: list(range(5)), "date": date_index})
  107:         tm.assert_frame_equal(df, expected)
  108: 
  109:         # We get a slice because df.index's resolution is hourly and we
  110:         #  are slicing with a daily-resolution string.  If both were daily,
  111:         #  we would get a single item back
  112:         dti = date_range("20170101 01:00:00", periods=3)
  113:         df = DataFrame({"A": [1, 2, 3]}, index=dti[::-1])
  114: 
  115:         expected = DataFrame({"A": 1}, index=dti[-1:][::-1])
  116:         result = df.loc["2017-01-03"]
  117:         tm.assert_frame_equal(result, expected)
  118: 
  119:         result2 = df.iloc[::-1].loc["2017-01-03"]
  120:         expected2 = expected.iloc[::-1]
  121:         tm.assert_frame_equal(result2, expected2)
  122: 
  123:     def test_slice_year(self):
  124:         dti = date_range(freq="B", start=datetime(2005, 1, 1), periods=500)
  125: 
  126:         s = Series(np.arange(len(dti)), index=dti)
  127:         result = s["2005"]
  128:         expected = s[s.index.year == 2005]
  129:         tm.assert_series_equal(result, expected)
  130: 
  131:         df = DataFrame(np.random.default_rng(2).random((len(dti), 5)), index=dti)
  132:         result = df.loc["2005"]
  133:         expected = df[df.index.year == 2005]
  134:         tm.assert_frame_equal(result, expected)
  135: 
  136:     @pytest.mark.parametrize(
  137:         "partial_dtime",
  138:         [
  139:             "2019",
  140:             "2019Q4",
  141:             "Dec 2019",
  142:             "2019-12-31",
  143:             "2019-12-31 23",
  144:             "2019-12-31 23:59",
  145:         ],
  146:     )
  147:     def test_slice_end_of_period_resolution(self, partial_dtime):
  148:         # GH#31064
  149:         dti = date_range("2019-12-31 23:59:55.999999999", periods=10, freq="s")
  150: 
  151:         ser = Series(range(10), index=dti)
  152:         result = ser[partial_dtime]
  153:         expected = ser.iloc[:5]
  154:         tm.assert_series_equal(result, expected)
  155: 
  156:     def test_slice_quarter(self):
  157:         dti = date_range(freq="D", start=datetime(2000, 6, 1), periods=500)
  158: 
  159:         s = Series(np.arange(len(dti)), index=dti)
  160:         assert len(s["2001Q1"]) == 90
  161: 
  162:         df = DataFrame(np.random.default_rng(2).random((len(dti), 5)), index=dti)
  163:         assert len(df.loc["1Q01"]) == 90
  164: 
  165:     def test_slice_month(self):
  166:         dti = date_range(freq="D", start=datetime(2005, 1, 1), periods=500)
  167:         s = Series(np.arange(len(dti)), index=dti)
  168:         assert len(s["2005-11"]) == 30
  169: 
  170:         df = DataFrame(np.random.default_rng(2).random((len(dti), 5)), index=dti)
  171:         assert len(df.loc["2005-11"]) == 30
  172: 
  173:         tm.assert_series_equal(s["2005-11"], s["11-2005"])
  174: 
  175:     def test_partial_slice(self):
  176:         rng = date_range(freq="D", start=datetime(2005, 1, 1), periods=500)
  177:         s = Series(np.arange(len(rng)), index=rng)
  178: 
  179:         result = s["2005-05":"2006-02"]
  180:         expected = s["20050501":"20060228"]
  181:         tm.assert_series_equal(result, expected)
  182: 
  183:         result = s["2005-05":]
  184:         expected = s["20050501":]
  185:         tm.assert_series_equal(result, expected)
  186: 
  187:         result = s[:"2006-02"]
  188:         expected = s[:"20060228"]
  189:         tm.assert_series_equal(result, expected)
  190: 
  191:         result = s["2005-1-1"]
  192:         assert result == s.iloc[0]
  193: 
  194:         with pytest.raises(KeyError, match=r"^'2004-12-31'$"):
  195:             s["2004-12-31"]
  196: 
  197:     def test_partial_slice_daily(self):
  198:         rng = date_range(freq="h", start=datetime(2005, 1, 31), periods=500)
  199:         s = Series(np.arange(len(rng)), index=rng)
  200: 
  201:         result = s["2005-1-31"]
  202:         tm.assert_series_equal(result, s.iloc[:24])
  203: 
  204:         with pytest.raises(KeyError, match=r"^'2004-12-31 00'$"):
  205:             s["2004-12-31 00"]
  206: 
  207:     def test_partial_slice_hourly(self):
  208:         rng = date_range(freq="min", start=datetime(2005, 1, 1, 20, 0, 0), periods=500)
  209:         s = Series(np.arange(len(rng)), index=rng)
  210: 
  211:         result = s["2005-1-1"]
  212:         tm.assert_series_equal(result, s.iloc[: 60 * 4])
  213: 
  214:         result = s["2005-1-1 20"]
  215:         tm.assert_series_equal(result, s.iloc[:60])
  216: 
  217:         assert s["2005-1-1 20:00"] == s.iloc[0]
  218:         with pytest.raises(KeyError, match=r"^'2004-12-31 00:15'$"):
  219:             s["2004-12-31 00:15"]
  220: 
  221:     def test_partial_slice_minutely(self):
  222:         rng = date_range(freq="s", start=datetime(2005, 1, 1, 23, 59, 0), periods=500)
  223:         s = Series(np.arange(len(rng)), index=rng)
  224: 
  225:         result = s["2005-1-1 23:59"]
  226:         tm.assert_series_equal(result, s.iloc[:60])
  227: 
  228:         result = s["2005-1-1"]
  229:         tm.assert_series_equal(result, s.iloc[:60])
  230: 
  231:         assert s[Timestamp("2005-1-1 23:59:00")] == s.iloc[0]
  232:         with pytest.raises(KeyError, match=r"^'2004-12-31 00:00:00'$"):
  233:             s["2004-12-31 00:00:00"]
  234: 
  235:     def test_partial_slice_second_precision(self):
  236:         rng = date_range(
  237:             start=datetime(2005, 1, 1, 0, 0, 59, microsecond=999990),
  238:             periods=20,
  239:             freq="us",
  240:         )
  241:         s = Series(np.arange(20), rng)
  242: 
  243:         tm.assert_series_equal(s["2005-1-1 00:00"], s.iloc[:10])
  244:         tm.assert_series_equal(s["2005-1-1 00:00:59"], s.iloc[:10])
  245: 
  246:         tm.assert_series_equal(s["2005-1-1 00:01"], s.iloc[10:])
  247:         tm.assert_series_equal(s["2005-1-1 00:01:00"], s.iloc[10:])
  248: 
  249:         assert s[Timestamp("2005-1-1 00:00:59.999990")] == s.iloc[0]
  250:         with pytest.raises(KeyError, match="2005-1-1 00:00:00"):
  251:             s["2005-1-1 00:00:00"]
  252: 
  253:     def test_partial_slicing_dataframe(self):
  254:         # GH14856
  255:         # Test various combinations of string slicing resolution vs.
  256:         # index resolution
  257:         # - If string resolution is less precise than index resolution,
  258:         # string is considered a slice
  259:         # - If string resolution is equal to or more precise than index
  260:         # resolution, string is considered an exact match
  261:         formats = [
  262:             "%Y",
  263:             "%Y-%m",
  264:             "%Y-%m-%d",
  265:             "%Y-%m-%d %H",
  266:             "%Y-%m-%d %H:%M",
  267:             "%Y-%m-%d %H:%M:%S",
  268:         ]
  269:         resolutions = ["year", "month", "day", "hour", "minute", "second"]
  270:         for rnum, resolution in enumerate(resolutions[2:], 2):
  271:             # we check only 'day', 'hour', 'minute' and 'second'
  272:             unit = Timedelta("1 " + resolution)
  273:             middate = datetime(2012, 1, 1, 0, 0, 0)
  274:             index = DatetimeIndex([middate - unit, middate, middate + unit])
  275:             values = [1, 2, 3]
  276:             df = DataFrame({"a": values}, index, dtype=np.int64)
  277:             assert df.index.resolution == resolution
  278: 
  279:             # Timestamp with the same resolution as index
  280:             # Should be exact match for Series (return scalar)
  281:             # and raise KeyError for Frame
  282:             for timestamp, expected in zip(index, values):
  283:                 ts_string = timestamp.strftime(formats[rnum])
  284:                 # make ts_string as precise as index
  285:                 result = df["a"][ts_string]
  286:                 assert isinstance(result, np.int64)
  287:                 assert result == expected
  288:                 msg = rf"^'{ts_string}'$"
  289:                 with pytest.raises(KeyError, match=msg):
  290:                     df[ts_string]
  291: 
  292:             # Timestamp with resolution less precise than index
  293:             for fmt in formats[:rnum]:
  294:                 for element, theslice in [[0, slice(None, 1)], [1, slice(1, None)]]:
  295:                     ts_string = index[element].strftime(fmt)
  296: 
  297:                     # Series should return slice
  298:                     result = df["a"][ts_string]
  299:                     expected = df["a"][theslice]
  300:                     tm.assert_series_equal(result, expected)
  301: 
  302:                     # pre-2.0 df[ts_string] was overloaded to interpret this
  303:                     #  as slicing along index
  304:                     with pytest.raises(KeyError, match=ts_string):
  305:                         df[ts_string]
  306: 
  307:             # Timestamp with resolution more precise than index
  308:             # Compatible with existing key
  309:             # Should return scalar for Series
  310:             # and raise KeyError for Frame
  311:             for fmt in formats[rnum + 1 :]:
  312:                 ts_string = index[1].strftime(fmt)
  313:                 result = df["a"][ts_string]
  314:                 assert isinstance(result, np.int64)
  315:                 assert result == 2
  316:                 msg = rf"^'{ts_string}'$"
  317:                 with pytest.raises(KeyError, match=msg):
  318:                     df[ts_string]
  319: 
  320:             # Not compatible with existing key
  321:             # Should raise KeyError
  322:             for fmt, res in list(zip(formats, resolutions))[rnum + 1 :]:
  323:                 ts = index[1] + Timedelta("1 " + res)
  324:                 ts_string = ts.strftime(fmt)
  325:                 msg = rf"^'{ts_string}'$"
  326:                 with pytest.raises(KeyError, match=msg):
  327:                     df["a"][ts_string]
  328:                 with pytest.raises(KeyError, match=msg):
  329:                     df[ts_string]
  330: 
  331:     def test_partial_slicing_with_multiindex(self):
  332:         # GH 4758
  333:         # partial string indexing with a multi-index buggy
  334:         df = DataFrame(
  335:             {
  336:                 "ACCOUNT": ["ACCT1", "ACCT1", "ACCT1", "ACCT2"],
  337:                 "TICKER": ["ABC", "MNP", "XYZ", "XYZ"],
  338:                 "val": [1, 2, 3, 4],
  339:             },
  340:             index=date_range("2013-06-19 09:30:00", periods=4, freq="5min"),
  341:         )
  342:         df_multi = df.set_index(["ACCOUNT", "TICKER"], append=True)
  343: 
  344:         expected = DataFrame(
  345:             [[1]], index=Index(["ABC"], name="TICKER"), columns=["val"]
  346:         )
  347:         result = df_multi.loc[("2013-06-19 09:30:00", "ACCT1")]
  348:         tm.assert_frame_equal(result, expected)
  349: 
  350:         expected = df_multi.loc[
  351:             (Timestamp("2013-06-19 09:30:00", tz=None), "ACCT1", "ABC")
  352:         ]
  353:         result = df_multi.loc[("2013-06-19 09:30:00", "ACCT1", "ABC")]
  354:         tm.assert_series_equal(result, expected)
  355: 
  356:         # partial string indexing on first level, scalar indexing on the other two
  357:         result = df_multi.loc[("2013-06-19", "ACCT1", "ABC")]
  358:         expected = df_multi.iloc[:1].droplevel([1, 2])
  359:         tm.assert_frame_equal(result, expected)
  360: 
  361:     def test_partial_slicing_with_multiindex_series(self):
  362:         # GH 4294
  363:         # partial slice on a series mi
  364:         ser = Series(
  365:             range(250),
  366:             index=MultiIndex.from_product(
  367:                 [date_range("2000-1-1", periods=50), range(5)]
  368:             ),
  369:         )
  370: 
  371:         s2 = ser[:-1].copy()
  372:         expected = s2["2000-1-4"]
  373:         result = s2[Timestamp("2000-1-4")]
  374:         tm.assert_series_equal(result, expected)
  375: 
  376:         result = ser[Timestamp("2000-1-4")]
  377:         expected = ser["2000-1-4"]
  378:         tm.assert_series_equal(result, expected)
  379: 
  380:         df2 = DataFrame(ser)
  381:         expected = df2.xs("2000-1-4")
  382:         result = df2.loc[Timestamp("2000-1-4")]
  383:         tm.assert_frame_equal(result, expected)
  384: 
  385:     def test_partial_slice_requires_monotonicity(self):
  386:         # Disallowed since 2.0 (GH 37819)
  387:         ser = Series(np.arange(10), date_range("2014-01-01", periods=10))
  388: 
  389:         nonmonotonic = ser.iloc[[3, 5, 4]]
  390:         timestamp = Timestamp("2014-01-10")
  391:         with pytest.raises(
  392:             KeyError, match="Value based partial slicing on non-monotonic"
  393:         ):
  394:             nonmonotonic["2014-01-10":]
  395: 
  396:         with pytest.raises(KeyError, match=r"Timestamp\('2014-01-10 00:00:00'\)"):
  397:             nonmonotonic[timestamp:]
  398: 
  399:         with pytest.raises(
  400:             KeyError, match="Value based partial slicing on non-monotonic"
  401:         ):
  402:             nonmonotonic.loc["2014-01-10":]
  403: 
  404:         with pytest.raises(KeyError, match=r"Timestamp\('2014-01-10 00:00:00'\)"):
  405:             nonmonotonic.loc[timestamp:]
  406: 
  407:     def test_loc_datetime_length_one(self):
  408:         # GH16071
  409:         df = DataFrame(
  410:             columns=["1"],
  411:             index=date_range("2016-10-01T00:00:00", "2016-10-01T23:59:59"),
  412:         )
  413:         result = df.loc[datetime(2016, 10, 1) :]
  414:         tm.assert_frame_equal(result, df)
  415: 
  416:         result = df.loc["2016-10-01T00:00:00":]
  417:         tm.assert_frame_equal(result, df)
  418: 
  419:     @pytest.mark.parametrize(
  420:         "start",
  421:         [
  422:             "2018-12-02 21:50:00+00:00",
  423:             Timestamp("2018-12-02 21:50:00+00:00"),
  424:             Timestamp("2018-12-02 21:50:00+00:00").to_pydatetime(),
  425:         ],
  426:     )
  427:     @pytest.mark.parametrize(
  428:         "end",
  429:         [
  430:             "2018-12-02 21:52:00+00:00",
  431:             Timestamp("2018-12-02 21:52:00+00:00"),
  432:             Timestamp("2018-12-02 21:52:00+00:00").to_pydatetime(),
  433:         ],
  434:     )
  435:     def test_getitem_with_datestring_with_UTC_offset(self, start, end):
  436:         # GH 24076
  437:         idx = date_range(
  438:             start="2018-12-02 14:50:00-07:00",
  439:             end="2018-12-02 14:50:00-07:00",
  440:             freq="1min",
  441:         )
  442:         df = DataFrame(1, index=idx, columns=["A"])
  443:         result = df[start:end]
  444:         expected = df.iloc[0:3, :]
  445:         tm.assert_frame_equal(result, expected)
  446: 
  447:         # GH 16785
  448:         start = str(start)
  449:         end = str(end)
  450:         with pytest.raises(ValueError, match="Both dates must"):
  451:             df[start : end[:-4] + "1:00"]
  452: 
  453:         with pytest.raises(ValueError, match="The index must be timezone"):
  454:             df = df.tz_localize(None)
  455:             df[start:end]
  456: 
  457:     def test_slice_reduce_to_series(self):
  458:         # GH 27516
  459:         df = DataFrame(
  460:             {"A": range(24)}, index=date_range("2000", periods=24, freq="ME")
  461:         )
  462:         expected = Series(
  463:             range(12), index=date_range("2000", periods=12, freq="ME"), name="A"
  464:         )
  465:         result = df.loc["2000", "A"]
  466:         tm.assert_series_equal(result, expected)
