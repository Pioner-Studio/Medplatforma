    1: from itertools import permutations
    2: import re
    3: 
    4: import numpy as np
    5: import pytest
    6: 
    7: import pandas as pd
    8: from pandas import (
    9:     Index,
   10:     Interval,
   11:     IntervalIndex,
   12:     Timedelta,
   13:     Timestamp,
   14:     date_range,
   15:     interval_range,
   16:     isna,
   17:     notna,
   18:     timedelta_range,
   19: )
   20: import pandas._testing as tm
   21: import pandas.core.common as com
   22: 
   23: 
   24: @pytest.fixture(params=[None, "foo"])
   25: def name(request):
   26:     return request.param
   27: 
   28: 
   29: class TestIntervalIndex:
   30:     index = IntervalIndex.from_arrays([0, 1], [1, 2])
   31: 
   32:     def create_index(self, closed="right"):
   33:         return IntervalIndex.from_breaks(range(11), closed=closed)
   34: 
   35:     def create_index_with_nan(self, closed="right"):
   36:         mask = [True, False] + [True] * 8
   37:         return IntervalIndex.from_arrays(
   38:             np.where(mask, np.arange(10), np.nan),
   39:             np.where(mask, np.arange(1, 11), np.nan),
   40:             closed=closed,
   41:         )
   42: 
   43:     def test_properties(self, closed):
   44:         index = self.create_index(closed=closed)
   45:         assert len(index) == 10
   46:         assert index.size == 10
   47:         assert index.shape == (10,)
   48: 
   49:         tm.assert_index_equal(index.left, Index(np.arange(10, dtype=np.int64)))
   50:         tm.assert_index_equal(index.right, Index(np.arange(1, 11, dtype=np.int64)))
   51:         tm.assert_index_equal(index.mid, Index(np.arange(0.5, 10.5, dtype=np.float64)))
   52: 
   53:         assert index.closed == closed
   54: 
   55:         ivs = [
   56:             Interval(left, right, closed)
   57:             for left, right in zip(range(10), range(1, 11))
   58:         ]
   59:         expected = np.array(ivs, dtype=object)
   60:         tm.assert_numpy_array_equal(np.asarray(index), expected)
   61: 
   62:         # with nans
   63:         index = self.create_index_with_nan(closed=closed)
   64:         assert len(index) == 10
   65:         assert index.size == 10
   66:         assert index.shape == (10,)
   67: 
   68:         expected_left = Index([0, np.nan, 2, 3, 4, 5, 6, 7, 8, 9])
   69:         expected_right = expected_left + 1
   70:         expected_mid = expected_left + 0.5
   71:         tm.assert_index_equal(index.left, expected_left)
   72:         tm.assert_index_equal(index.right, expected_right)
   73:         tm.assert_index_equal(index.mid, expected_mid)
   74: 
   75:         assert index.closed == closed
   76: 
   77:         ivs = [
   78:             Interval(left, right, closed) if notna(left) else np.nan
   79:             for left, right in zip(expected_left, expected_right)
   80:         ]
   81:         expected = np.array(ivs, dtype=object)
   82:         tm.assert_numpy_array_equal(np.asarray(index), expected)
   83: 
   84:     @pytest.mark.parametrize(
   85:         "breaks",
   86:         [
   87:             [1, 1, 2, 5, 15, 53, 217, 1014, 5335, 31240, 201608],
   88:             [-np.inf, -100, -10, 0.5, 1, 1.5, 3.8, 101, 202, np.inf],
   89:             date_range("2017-01-01", "2017-01-04"),
   90:             pytest.param(
   91:                 date_range("2017-01-01", "2017-01-04", unit="s"),
   92:                 marks=pytest.mark.xfail(reason="mismatched result unit"),
   93:             ),
   94:             pd.to_timedelta(["1ns", "2ms", "3s", "4min", "5h", "6D"]),
   95:         ],
   96:     )
   97:     def test_length(self, closed, breaks):
   98:         # GH 18789
   99:         index = IntervalIndex.from_breaks(breaks, closed=closed)
  100:         result = index.length
  101:         expected = Index(iv.length for iv in index)
  102:         tm.assert_index_equal(result, expected)
  103: 
  104:         # with NA
  105:         index = index.insert(1, np.nan)
  106:         result = index.length
  107:         expected = Index(iv.length if notna(iv) else iv for iv in index)
  108:         tm.assert_index_equal(result, expected)
  109: 
  110:     def test_with_nans(self, closed):
  111:         index = self.create_index(closed=closed)
  112:         assert index.hasnans is False
  113: 
  114:         result = index.isna()
  115:         expected = np.zeros(len(index), dtype=bool)
  116:         tm.assert_numpy_array_equal(result, expected)
  117: 
  118:         result = index.notna()
  119:         expected = np.ones(len(index), dtype=bool)
  120:         tm.assert_numpy_array_equal(result, expected)
  121: 
  122:         index = self.create_index_with_nan(closed=closed)
  123:         assert index.hasnans is True
  124: 
  125:         result = index.isna()
  126:         expected = np.array([False, True] + [False] * (len(index) - 2))
  127:         tm.assert_numpy_array_equal(result, expected)
  128: 
  129:         result = index.notna()
  130:         expected = np.array([True, False] + [True] * (len(index) - 2))
  131:         tm.assert_numpy_array_equal(result, expected)
  132: 
  133:     def test_copy(self, closed):
  134:         expected = self.create_index(closed=closed)
  135: 
  136:         result = expected.copy()
  137:         assert result.equals(expected)
  138: 
  139:         result = expected.copy(deep=True)
  140:         assert result.equals(expected)
  141:         assert result.left is not expected.left
  142: 
  143:     def test_ensure_copied_data(self, closed):
  144:         # exercise the copy flag in the constructor
  145: 
  146:         # not copying
  147:         index = self.create_index(closed=closed)
  148:         result = IntervalIndex(index, copy=False)
  149:         tm.assert_numpy_array_equal(
  150:             index.left.values, result.left.values, check_same="same"
  151:         )
  152:         tm.assert_numpy_array_equal(
  153:             index.right.values, result.right.values, check_same="same"
  154:         )
  155: 
  156:         # by-definition make a copy
  157:         result = IntervalIndex(np.array(index), copy=False)
  158:         tm.assert_numpy_array_equal(
  159:             index.left.values, result.left.values, check_same="copy"
  160:         )
  161:         tm.assert_numpy_array_equal(
  162:             index.right.values, result.right.values, check_same="copy"
  163:         )
  164: 
  165:     def test_delete(self, closed):
  166:         breaks = np.arange(1, 11, dtype=np.int64)
  167:         expected = IntervalIndex.from_breaks(breaks, closed=closed)
  168:         result = self.create_index(closed=closed).delete(0)
  169:         tm.assert_index_equal(result, expected)
  170: 
  171:     @pytest.mark.parametrize(
  172:         "data",
  173:         [
  174:             interval_range(0, periods=10, closed="neither"),
  175:             interval_range(1.7, periods=8, freq=2.5, closed="both"),
  176:             interval_range(Timestamp("20170101"), periods=12, closed="left"),
  177:             interval_range(Timedelta("1 day"), periods=6, closed="right"),
  178:         ],
  179:     )
  180:     def test_insert(self, data):
  181:         item = data[0]
  182:         idx_item = IntervalIndex([item])
  183: 
  184:         # start
  185:         expected = idx_item.append(data)
  186:         result = data.insert(0, item)
  187:         tm.assert_index_equal(result, expected)
  188: 
  189:         # end
  190:         expected = data.append(idx_item)
  191:         result = data.insert(len(data), item)
  192:         tm.assert_index_equal(result, expected)
  193: 
  194:         # mid
  195:         expected = data[:3].append(idx_item).append(data[3:])
  196:         result = data.insert(3, item)
  197:         tm.assert_index_equal(result, expected)
  198: 
  199:         # invalid type
  200:         res = data.insert(1, "foo")
  201:         expected = data.astype(object).insert(1, "foo")
  202:         tm.assert_index_equal(res, expected)
  203: 
  204:         msg = "can only insert Interval objects and NA into an IntervalArray"
  205:         with pytest.raises(TypeError, match=msg):
  206:             data._data.insert(1, "foo")
  207: 
  208:         # invalid closed
  209:         msg = "'value.closed' is 'left', expected 'right'."
  210:         for closed in {"left", "right", "both", "neither"} - {item.closed}:
  211:             msg = f"'value.closed' is '{closed}', expected '{item.closed}'."
  212:             bad_item = Interval(item.left, item.right, closed=closed)
  213:             res = data.insert(1, bad_item)
  214:             expected = data.astype(object).insert(1, bad_item)
  215:             tm.assert_index_equal(res, expected)
  216:             with pytest.raises(ValueError, match=msg):
  217:                 data._data.insert(1, bad_item)
  218: 
  219:         # GH 18295 (test missing)
  220:         na_idx = IntervalIndex([np.nan], closed=data.closed)
  221:         for na in [np.nan, None, pd.NA]:
  222:             expected = data[:1].append(na_idx).append(data[1:])
  223:             result = data.insert(1, na)
  224:             tm.assert_index_equal(result, expected)
  225: 
  226:         if data.left.dtype.kind not in ["m", "M"]:
  227:             # trying to insert pd.NaT into a numeric-dtyped Index should cast
  228:             expected = data.astype(object).insert(1, pd.NaT)
  229: 
  230:             msg = "can only insert Interval objects and NA into an IntervalArray"
  231:             with pytest.raises(TypeError, match=msg):
  232:                 data._data.insert(1, pd.NaT)
  233: 
  234:         result = data.insert(1, pd.NaT)
  235:         tm.assert_index_equal(result, expected)
  236: 
  237:     def test_is_unique_interval(self, closed):
  238:         """
  239:         Interval specific tests for is_unique in addition to base class tests
  240:         """
  241:         # unique overlapping - distinct endpoints
  242:         idx = IntervalIndex.from_tuples([(0, 1), (0.5, 1.5)], closed=closed)
  243:         assert idx.is_unique is True
  244: 
  245:         # unique overlapping - shared endpoints
  246:         idx = IntervalIndex.from_tuples([(1, 2), (1, 3), (2, 3)], closed=closed)
  247:         assert idx.is_unique is True
  248: 
  249:         # unique nested
  250:         idx = IntervalIndex.from_tuples([(-1, 1), (-2, 2)], closed=closed)
  251:         assert idx.is_unique is True
  252: 
  253:         # unique NaN
  254:         idx = IntervalIndex.from_tuples([(np.nan, np.nan)], closed=closed)
  255:         assert idx.is_unique is True
  256: 
  257:         # non-unique NaN
  258:         idx = IntervalIndex.from_tuples(
  259:             [(np.nan, np.nan), (np.nan, np.nan)], closed=closed
  260:         )
  261:         assert idx.is_unique is False
  262: 
  263:     def test_monotonic(self, closed):
  264:         # increasing non-overlapping
  265:         idx = IntervalIndex.from_tuples([(0, 1), (2, 3), (4, 5)], closed=closed)
  266:         assert idx.is_monotonic_increasing is True
  267:         assert idx._is_strictly_monotonic_increasing is True
  268:         assert idx.is_monotonic_decreasing is False
  269:         assert idx._is_strictly_monotonic_decreasing is False
  270: 
  271:         # decreasing non-overlapping
  272:         idx = IntervalIndex.from_tuples([(4, 5), (2, 3), (1, 2)], closed=closed)
  273:         assert idx.is_monotonic_increasing is False
  274:         assert idx._is_strictly_monotonic_increasing is False
  275:         assert idx.is_monotonic_decreasing is True
  276:         assert idx._is_strictly_monotonic_decreasing is True
  277: 
  278:         # unordered non-overlapping
  279:         idx = IntervalIndex.from_tuples([(0, 1), (4, 5), (2, 3)], closed=closed)
  280:         assert idx.is_monotonic_increasing is False
  281:         assert idx._is_strictly_monotonic_increasing is False
  282:         assert idx.is_monotonic_decreasing is False
  283:         assert idx._is_strictly_monotonic_decreasing is False
  284: 
  285:         # increasing overlapping
  286:         idx = IntervalIndex.from_tuples([(0, 2), (0.5, 2.5), (1, 3)], closed=closed)
  287:         assert idx.is_monotonic_increasing is True
  288:         assert idx._is_strictly_monotonic_increasing is True
  289:         assert idx.is_monotonic_decreasing is False
  290:         assert idx._is_strictly_monotonic_decreasing is False
  291: 
  292:         # decreasing overlapping
  293:         idx = IntervalIndex.from_tuples([(1, 3), (0.5, 2.5), (0, 2)], closed=closed)
  294:         assert idx.is_monotonic_increasing is False
  295:         assert idx._is_strictly_monotonic_increasing is False
  296:         assert idx.is_monotonic_decreasing is True
  297:         assert idx._is_strictly_monotonic_decreasing is True
  298: 
  299:         # unordered overlapping
  300:         idx = IntervalIndex.from_tuples([(0.5, 2.5), (0, 2), (1, 3)], closed=closed)
  301:         assert idx.is_monotonic_increasing is False
  302:         assert idx._is_strictly_monotonic_increasing is False
  303:         assert idx.is_monotonic_decreasing is False
  304:         assert idx._is_strictly_monotonic_decreasing is False
  305: 
  306:         # increasing overlapping shared endpoints
  307:         idx = IntervalIndex.from_tuples([(1, 2), (1, 3), (2, 3)], closed=closed)
  308:         assert idx.is_monotonic_increasing is True
  309:         assert idx._is_strictly_monotonic_increasing is True
  310:         assert idx.is_monotonic_decreasing is False
  311:         assert idx._is_strictly_monotonic_decreasing is False
  312: 
  313:         # decreasing overlapping shared endpoints
  314:         idx = IntervalIndex.from_tuples([(2, 3), (1, 3), (1, 2)], closed=closed)
  315:         assert idx.is_monotonic_increasing is False
  316:         assert idx._is_strictly_monotonic_increasing is False
  317:         assert idx.is_monotonic_decreasing is True
  318:         assert idx._is_strictly_monotonic_decreasing is True
  319: 
  320:         # stationary
  321:         idx = IntervalIndex.from_tuples([(0, 1), (0, 1)], closed=closed)
  322:         assert idx.is_monotonic_increasing is True
  323:         assert idx._is_strictly_monotonic_increasing is False
  324:         assert idx.is_monotonic_decreasing is True
  325:         assert idx._is_strictly_monotonic_decreasing is False
  326: 
  327:         # empty
  328:         idx = IntervalIndex([], closed=closed)
  329:         assert idx.is_monotonic_increasing is True
  330:         assert idx._is_strictly_monotonic_increasing is True
  331:         assert idx.is_monotonic_decreasing is True
  332:         assert idx._is_strictly_monotonic_decreasing is True
  333: 
  334:     def test_is_monotonic_with_nans(self):
  335:         # GH#41831
  336:         index = IntervalIndex([np.nan, np.nan])
  337: 
  338:         assert not index.is_monotonic_increasing
  339:         assert not index._is_strictly_monotonic_increasing
  340:         assert not index.is_monotonic_increasing
  341:         assert not index._is_strictly_monotonic_decreasing
  342:         assert not index.is_monotonic_decreasing
  343: 
  344:     @pytest.mark.parametrize(
  345:         "breaks",
  346:         [
  347:             date_range("20180101", periods=4),
  348:             date_range("20180101", periods=4, tz="US/Eastern"),
  349:             timedelta_range("0 days", periods=4),
  350:         ],
  351:         ids=lambda x: str(x.dtype),
  352:     )
  353:     def test_maybe_convert_i8(self, breaks):
  354:         # GH 20636
  355:         index = IntervalIndex.from_breaks(breaks)
  356: 
  357:         # intervalindex
  358:         result = index._maybe_convert_i8(index)
  359:         expected = IntervalIndex.from_breaks(breaks.asi8)
  360:         tm.assert_index_equal(result, expected)
  361: 
  362:         # interval
  363:         interval = Interval(breaks[0], breaks[1])
  364:         result = index._maybe_convert_i8(interval)
  365:         expected = Interval(breaks[0]._value, breaks[1]._value)
  366:         assert result == expected
  367: 
  368:         # datetimelike index
  369:         result = index._maybe_convert_i8(breaks)
  370:         expected = Index(breaks.asi8)
  371:         tm.assert_index_equal(result, expected)
  372: 
  373:         # datetimelike scalar
  374:         result = index._maybe_convert_i8(breaks[0])
  375:         expected = breaks[0]._value
  376:         assert result == expected
  377: 
  378:         # list-like of datetimelike scalars
  379:         result = index._maybe_convert_i8(list(breaks))
  380:         expected = Index(breaks.asi8)
  381:         tm.assert_index_equal(result, expected)
  382: 
  383:     @pytest.mark.parametrize(
  384:         "breaks",
  385:         [date_range("2018-01-01", periods=5), timedelta_range("0 days", periods=5)],
  386:     )
  387:     def test_maybe_convert_i8_nat(self, breaks):
  388:         # GH 20636
  389:         index = IntervalIndex.from_breaks(breaks)
  390: 
  391:         to_convert = breaks._constructor([pd.NaT] * 3).as_unit("ns")
  392:         expected = Index([np.nan] * 3, dtype=np.float64)
  393:         result = index._maybe_convert_i8(to_convert)
  394:         tm.assert_index_equal(result, expected)
  395: 
  396:         to_convert = to_convert.insert(0, breaks[0])
  397:         expected = expected.insert(0, float(breaks[0]._value))
  398:         result = index._maybe_convert_i8(to_convert)
  399:         tm.assert_index_equal(result, expected)
  400: 
  401:     @pytest.mark.parametrize(
  402:         "make_key",
  403:         [lambda breaks: breaks, list],
  404:         ids=["lambda", "list"],
  405:     )
  406:     def test_maybe_convert_i8_numeric(self, make_key, any_real_numpy_dtype):
  407:         # GH 20636
  408:         breaks = np.arange(5, dtype=any_real_numpy_dtype)
  409:         index = IntervalIndex.from_breaks(breaks)
  410:         key = make_key(breaks)
  411: 
  412:         result = index._maybe_convert_i8(key)
  413:         kind = breaks.dtype.kind
  414:         expected_dtype = {"i": np.int64, "u": np.uint64, "f": np.float64}[kind]
  415:         expected = Index(key, dtype=expected_dtype)
  416:         tm.assert_index_equal(result, expected)
  417: 
  418:     @pytest.mark.parametrize(
  419:         "make_key",
  420:         [
  421:             IntervalIndex.from_breaks,
  422:             lambda breaks: Interval(breaks[0], breaks[1]),
  423:             lambda breaks: breaks[0],
  424:         ],
  425:         ids=["IntervalIndex", "Interval", "scalar"],
  426:     )
  427:     def test_maybe_convert_i8_numeric_identical(self, make_key, any_real_numpy_dtype):
  428:         # GH 20636
  429:         breaks = np.arange(5, dtype=any_real_numpy_dtype)
  430:         index = IntervalIndex.from_breaks(breaks)
  431:         key = make_key(breaks)
  432: 
  433:         # test if _maybe_convert_i8 won't change key if an Interval or IntervalIndex
  434:         result = index._maybe_convert_i8(key)
  435:         assert result is key
  436: 
  437:     @pytest.mark.parametrize(
  438:         "breaks1, breaks2",
  439:         permutations(
  440:             [
  441:                 date_range("20180101", periods=4),
  442:                 date_range("20180101", periods=4, tz="US/Eastern"),
  443:                 timedelta_range("0 days", periods=4),
  444:             ],
  445:             2,
  446:         ),
  447:         ids=lambda x: str(x.dtype),
  448:     )
  449:     @pytest.mark.parametrize(
  450:         "make_key",
  451:         [
  452:             IntervalIndex.from_breaks,
  453:             lambda breaks: Interval(breaks[0], breaks[1]),
  454:             lambda breaks: breaks,
  455:             lambda breaks: breaks[0],
  456:             list,
  457:         ],
  458:         ids=["IntervalIndex", "Interval", "Index", "scalar", "list"],
  459:     )
  460:     def test_maybe_convert_i8_errors(self, breaks1, breaks2, make_key):
  461:         # GH 20636
  462:         index = IntervalIndex.from_breaks(breaks1)
  463:         key = make_key(breaks2)
  464: 
  465:         msg = (
  466:             f"Cannot index an IntervalIndex of subtype {breaks1.dtype} with "
  467:             f"values of dtype {breaks2.dtype}"
  468:         )
  469:         msg = re.escape(msg)
  470:         with pytest.raises(ValueError, match=msg):
  471:             index._maybe_convert_i8(key)
  472: 
  473:     def test_contains_method(self):
  474:         # can select values that are IN the range of a value
  475:         i = IntervalIndex.from_arrays([0, 1], [1, 2])
  476: 
  477:         expected = np.array([False, False], dtype="bool")
  478:         actual = i.contains(0)
  479:         tm.assert_numpy_array_equal(actual, expected)
  480:         actual = i.contains(3)
  481:         tm.assert_numpy_array_equal(actual, expected)
  482: 
  483:         expected = np.array([True, False], dtype="bool")
  484:         actual = i.contains(0.5)
  485:         tm.assert_numpy_array_equal(actual, expected)
  486:         actual = i.contains(1)
  487:         tm.assert_numpy_array_equal(actual, expected)
  488: 
  489:         # __contains__ not implemented for "interval in interval", follow
  490:         # that for the contains method for now
  491:         with pytest.raises(
  492:             NotImplementedError, match="contains not implemented for two"
  493:         ):
  494:             i.contains(Interval(0, 1))
  495: 
  496:     def test_dropna(self, closed):
  497:         expected = IntervalIndex.from_tuples([(0.0, 1.0), (1.0, 2.0)], closed=closed)
  498: 
  499:         ii = IntervalIndex.from_tuples([(0, 1), (1, 2), np.nan], closed=closed)
  500:         result = ii.dropna()
  501:         tm.assert_index_equal(result, expected)
  502: 
  503:         ii = IntervalIndex.from_arrays([0, 1, np.nan], [1, 2, np.nan], closed=closed)
  504:         result = ii.dropna()
  505:         tm.assert_index_equal(result, expected)
  506: 
  507:     def test_non_contiguous(self, closed):
  508:         index = IntervalIndex.from_tuples([(0, 1), (2, 3)], closed=closed)
  509:         target = [0.5, 1.5, 2.5]
  510:         actual = index.get_indexer(target)
  511:         expected = np.array([0, -1, 1], dtype="intp")
  512:         tm.assert_numpy_array_equal(actual, expected)
  513: 
  514:         assert 1.5 not in index
  515: 
  516:     def test_isin(self, closed):
  517:         index = self.create_index(closed=closed)
  518: 
  519:         expected = np.array([True] + [False] * (len(index) - 1))
  520:         result = index.isin(index[:1])
  521:         tm.assert_numpy_array_equal(result, expected)
  522: 
  523:         result = index.isin([index[0]])
  524:         tm.assert_numpy_array_equal(result, expected)
  525: 
  526:         other = IntervalIndex.from_breaks(np.arange(-2, 10), closed=closed)
  527:         expected = np.array([True] * (len(index) - 1) + [False])
  528:         result = index.isin(other)
  529:         tm.assert_numpy_array_equal(result, expected)
  530: 
  531:         result = index.isin(other.tolist())
  532:         tm.assert_numpy_array_equal(result, expected)
  533: 
  534:         for other_closed in ["right", "left", "both", "neither"]:
  535:             other = self.create_index(closed=other_closed)
  536:             expected = np.repeat(closed == other_closed, len(index))
  537:             result = index.isin(other)
  538:             tm.assert_numpy_array_equal(result, expected)
  539: 
  540:             result = index.isin(other.tolist())
  541:             tm.assert_numpy_array_equal(result, expected)
  542: 
  543:     def test_comparison(self):
  544:         actual = Interval(0, 1) < self.index
  545:         expected = np.array([False, True])
  546:         tm.assert_numpy_array_equal(actual, expected)
  547: 
  548:         actual = Interval(0.5, 1.5) < self.index
  549:         expected = np.array([False, True])
  550:         tm.assert_numpy_array_equal(actual, expected)
  551:         actual = self.index > Interval(0.5, 1.5)
  552:         tm.assert_numpy_array_equal(actual, expected)
  553: 
  554:         actual = self.index == self.index
  555:         expected = np.array([True, True])
  556:         tm.assert_numpy_array_equal(actual, expected)
  557:         actual = self.index <= self.index
  558:         tm.assert_numpy_array_equal(actual, expected)
  559:         actual = self.index >= self.index
  560:         tm.assert_numpy_array_equal(actual, expected)
  561: 
  562:         actual = self.index < self.index
  563:         expected = np.array([False, False])
  564:         tm.assert_numpy_array_equal(actual, expected)
  565:         actual = self.index > self.index
  566:         tm.assert_numpy_array_equal(actual, expected)
  567: 
  568:         actual = self.index == IntervalIndex.from_breaks([0, 1, 2], "left")
  569:         tm.assert_numpy_array_equal(actual, expected)
  570: 
  571:         actual = self.index == self.index.values
  572:         tm.assert_numpy_array_equal(actual, np.array([True, True]))
  573:         actual = self.index.values == self.index
  574:         tm.assert_numpy_array_equal(actual, np.array([True, True]))
  575:         actual = self.index <= self.index.values
  576:         tm.assert_numpy_array_equal(actual, np.array([True, True]))
  577:         actual = self.index != self.index.values
  578:         tm.assert_numpy_array_equal(actual, np.array([False, False]))
  579:         actual = self.index > self.index.values
  580:         tm.assert_numpy_array_equal(actual, np.array([False, False]))
  581:         actual = self.index.values > self.index
  582:         tm.assert_numpy_array_equal(actual, np.array([False, False]))
  583: 
  584:         # invalid comparisons
  585:         actual = self.index == 0
  586:         tm.assert_numpy_array_equal(actual, np.array([False, False]))
  587:         actual = self.index == self.index.left
  588:         tm.assert_numpy_array_equal(actual, np.array([False, False]))
  589: 
  590:         msg = "|".join(
  591:             [
  592:                 "not supported between instances of 'int' and '.*.Interval'",
  593:                 r"Invalid comparison between dtype=interval\[int64, right\] and ",
  594:             ]
  595:         )
  596:         with pytest.raises(TypeError, match=msg):
  597:             self.index > 0
  598:         with pytest.raises(TypeError, match=msg):
  599:             self.index <= 0
  600:         with pytest.raises(TypeError, match=msg):
  601:             self.index > np.arange(2)
  602: 
  603:         msg = "Lengths must match to compare"
  604:         with pytest.raises(ValueError, match=msg):
  605:             self.index > np.arange(3)
  606: 
  607:     def test_missing_values(self, closed):
  608:         idx = Index(
  609:             [np.nan, Interval(0, 1, closed=closed), Interval(1, 2, closed=closed)]
  610:         )
  611:         idx2 = IntervalIndex.from_arrays([np.nan, 0, 1], [np.nan, 1, 2], closed=closed)
  612:         assert idx.equals(idx2)
  613: 
  614:         msg = (
  615:             "missing values must be missing in the same location both left "
  616:             "and right sides"
  617:         )
  618:         with pytest.raises(ValueError, match=msg):
  619:             IntervalIndex.from_arrays(
  620:                 [np.nan, 0, 1], np.array([0, 1, 2]), closed=closed
  621:             )
  622: 
  623:         tm.assert_numpy_array_equal(isna(idx), np.array([True, False, False]))
  624: 
  625:     def test_sort_values(self, closed):
  626:         index = self.create_index(closed=closed)
  627: 
  628:         result = index.sort_values()
  629:         tm.assert_index_equal(result, index)
  630: 
  631:         result = index.sort_values(ascending=False)
  632:         tm.assert_index_equal(result, index[::-1])
  633: 
  634:         # with nan
  635:         index = IntervalIndex([Interval(1, 2), np.nan, Interval(0, 1)])
  636: 
  637:         result = index.sort_values()
  638:         expected = IntervalIndex([Interval(0, 1), Interval(1, 2), np.nan])
  639:         tm.assert_index_equal(result, expected)
  640: 
  641:         result = index.sort_values(ascending=False, na_position="first")
  642:         expected = IntervalIndex([np.nan, Interval(1, 2), Interval(0, 1)])
  643:         tm.assert_index_equal(result, expected)
  644: 
  645:     @pytest.mark.parametrize("tz", [None, "US/Eastern"])
  646:     def test_datetime(self, tz):
  647:         start = Timestamp("2000-01-01", tz=tz)
  648:         dates = date_range(start=start, periods=10)
  649:         index = IntervalIndex.from_breaks(dates)
  650: 
  651:         # test mid
  652:         start = Timestamp("2000-01-01T12:00", tz=tz)
  653:         expected = date_range(start=start, periods=9)
  654:         tm.assert_index_equal(index.mid, expected)
  655: 
  656:         # __contains__ doesn't check individual points
  657:         assert Timestamp("2000-01-01", tz=tz) not in index
  658:         assert Timestamp("2000-01-01T12", tz=tz) not in index
  659:         assert Timestamp("2000-01-02", tz=tz) not in index
  660:         iv_true = Interval(
  661:             Timestamp("2000-01-02", tz=tz), Timestamp("2000-01-03", tz=tz)
  662:         )
  663:         iv_false = Interval(
  664:             Timestamp("1999-12-31", tz=tz), Timestamp("2000-01-01", tz=tz)
  665:         )
  666:         assert iv_true in index
  667:         assert iv_false not in index
  668: 
  669:         # .contains does check individual points
  670:         assert not index.contains(Timestamp("2000-01-01", tz=tz)).any()
  671:         assert index.contains(Timestamp("2000-01-01T12", tz=tz)).any()
  672:         assert index.contains(Timestamp("2000-01-02", tz=tz)).any()
  673: 
  674:         # test get_indexer
  675:         start = Timestamp("1999-12-31T12:00", tz=tz)
  676:         target = date_range(start=start, periods=7, freq="12h")
  677:         actual = index.get_indexer(target)
  678:         expected = np.array([-1, -1, 0, 0, 1, 1, 2], dtype="intp")
  679:         tm.assert_numpy_array_equal(actual, expected)
  680: 
  681:         start = Timestamp("2000-01-08T18:00", tz=tz)
  682:         target = date_range(start=start, periods=7, freq="6h")
  683:         actual = index.get_indexer(target)
  684:         expected = np.array([7, 7, 8, 8, 8, 8, -1], dtype="intp")
  685:         tm.assert_numpy_array_equal(actual, expected)
  686: 
  687:     def test_append(self, closed):
  688:         index1 = IntervalIndex.from_arrays([0, 1], [1, 2], closed=closed)
  689:         index2 = IntervalIndex.from_arrays([1, 2], [2, 3], closed=closed)
  690: 
  691:         result = index1.append(index2)
  692:         expected = IntervalIndex.from_arrays([0, 1, 1, 2], [1, 2, 2, 3], closed=closed)
  693:         tm.assert_index_equal(result, expected)
  694: 
  695:         result = index1.append([index1, index2])
  696:         expected = IntervalIndex.from_arrays(
  697:             [0, 1, 0, 1, 1, 2], [1, 2, 1, 2, 2, 3], closed=closed
  698:         )
  699:         tm.assert_index_equal(result, expected)
  700: 
  701:         for other_closed in {"left", "right", "both", "neither"} - {closed}:
  702:             index_other_closed = IntervalIndex.from_arrays(
  703:                 [0, 1], [1, 2], closed=other_closed
  704:             )
  705:             result = index1.append(index_other_closed)
  706:             expected = index1.astype(object).append(index_other_closed.astype(object))
  707:             tm.assert_index_equal(result, expected)
  708: 
  709:     def test_is_non_overlapping_monotonic(self, closed):
  710:         # Should be True in all cases
  711:         tpls = [(0, 1), (2, 3), (4, 5), (6, 7)]
  712:         idx = IntervalIndex.from_tuples(tpls, closed=closed)
  713:         assert idx.is_non_overlapping_monotonic is True
  714: 
  715:         idx = IntervalIndex.from_tuples(tpls[::-1], closed=closed)
  716:         assert idx.is_non_overlapping_monotonic is True
  717: 
  718:         # Should be False in all cases (overlapping)
  719:         tpls = [(0, 2), (1, 3), (4, 5), (6, 7)]
  720:         idx = IntervalIndex.from_tuples(tpls, closed=closed)
  721:         assert idx.is_non_overlapping_monotonic is False
  722: 
  723:         idx = IntervalIndex.from_tuples(tpls[::-1], closed=closed)
  724:         assert idx.is_non_overlapping_monotonic is False
  725: 
  726:         # Should be False in all cases (non-monotonic)
  727:         tpls = [(0, 1), (2, 3), (6, 7), (4, 5)]
  728:         idx = IntervalIndex.from_tuples(tpls, closed=closed)
  729:         assert idx.is_non_overlapping_monotonic is False
  730: 
  731:         idx = IntervalIndex.from_tuples(tpls[::-1], closed=closed)
  732:         assert idx.is_non_overlapping_monotonic is False
  733: 
  734:         # Should be False for closed='both', otherwise True (GH16560)
  735:         if closed == "both":
  736:             idx = IntervalIndex.from_breaks(range(4), closed=closed)
  737:             assert idx.is_non_overlapping_monotonic is False
  738:         else:
  739:             idx = IntervalIndex.from_breaks(range(4), closed=closed)
  740:             assert idx.is_non_overlapping_monotonic is True
  741: 
  742:     @pytest.mark.parametrize(
  743:         "start, shift, na_value",
  744:         [
  745:             (0, 1, np.nan),
  746:             (Timestamp("2018-01-01"), Timedelta("1 day"), pd.NaT),
  747:             (Timedelta("0 days"), Timedelta("1 day"), pd.NaT),
  748:         ],
  749:     )
  750:     def test_is_overlapping(self, start, shift, na_value, closed):
  751:         # GH 23309
  752:         # see test_interval_tree.py for extensive tests; interface tests here
  753: 
  754:         # non-overlapping
  755:         tuples = [(start + n * shift, start + (n + 1) * shift) for n in (0, 2, 4)]
  756:         index = IntervalIndex.from_tuples(tuples, closed=closed)
  757:         assert index.is_overlapping is False
  758: 
  759:         # non-overlapping with NA
  760:         tuples = [(na_value, na_value)] + tuples + [(na_value, na_value)]
  761:         index = IntervalIndex.from_tuples(tuples, closed=closed)
  762:         assert index.is_overlapping is False
  763: 
  764:         # overlapping
  765:         tuples = [(start + n * shift, start + (n + 2) * shift) for n in range(3)]
  766:         index = IntervalIndex.from_tuples(tuples, closed=closed)
  767:         assert index.is_overlapping is True
  768: 
  769:         # overlapping with NA
  770:         tuples = [(na_value, na_value)] + tuples + [(na_value, na_value)]
  771:         index = IntervalIndex.from_tuples(tuples, closed=closed)
  772:         assert index.is_overlapping is True
  773: 
  774:         # common endpoints
  775:         tuples = [(start + n * shift, start + (n + 1) * shift) for n in range(3)]
  776:         index = IntervalIndex.from_tuples(tuples, closed=closed)
  777:         result = index.is_overlapping
  778:         expected = closed == "both"
  779:         assert result is expected
  780: 
  781:         # common endpoints with NA
  782:         tuples = [(na_value, na_value)] + tuples + [(na_value, na_value)]
  783:         index = IntervalIndex.from_tuples(tuples, closed=closed)
  784:         result = index.is_overlapping
  785:         assert result is expected
  786: 
  787:         # intervals with duplicate left values
  788:         a = [10, 15, 20, 25, 30, 35, 40, 45, 45, 50, 55, 60, 65, 70, 75, 80, 85]
  789:         b = [15, 20, 25, 30, 35, 40, 45, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90]
  790:         index = IntervalIndex.from_arrays(a, b, closed="right")
  791:         result = index.is_overlapping
  792:         assert result is False
  793: 
  794:     @pytest.mark.parametrize(
  795:         "tuples",
  796:         [
  797:             list(zip(range(10), range(1, 11))),
  798:             list(
  799:                 zip(
  800:                     date_range("20170101", periods=10),
  801:                     date_range("20170101", periods=10),
  802:                 )
  803:             ),
  804:             list(
  805:                 zip(
  806:                     timedelta_range("0 days", periods=10),
  807:                     timedelta_range("1 day", periods=10),
  808:                 )
  809:             ),
  810:         ],
  811:     )
  812:     def test_to_tuples(self, tuples):
  813:         # GH 18756
  814:         idx = IntervalIndex.from_tuples(tuples)
  815:         result = idx.to_tuples()
  816:         expected = Index(com.asarray_tuplesafe(tuples))
  817:         tm.assert_index_equal(result, expected)
  818: 
  819:     @pytest.mark.parametrize(
  820:         "tuples",
  821:         [
  822:             list(zip(range(10), range(1, 11))) + [np.nan],
  823:             list(
  824:                 zip(
  825:                     date_range("20170101", periods=10),
  826:                     date_range("20170101", periods=10),
  827:                 )
  828:             )
  829:             + [np.nan],
  830:             list(
  831:                 zip(
  832:                     timedelta_range("0 days", periods=10),
  833:                     timedelta_range("1 day", periods=10),
  834:                 )
  835:             )
  836:             + [np.nan],
  837:         ],
  838:     )
  839:     @pytest.mark.parametrize("na_tuple", [True, False])
  840:     def test_to_tuples_na(self, tuples, na_tuple):
  841:         # GH 18756
  842:         idx = IntervalIndex.from_tuples(tuples)
  843:         result = idx.to_tuples(na_tuple=na_tuple)
  844: 
  845:         # check the non-NA portion
  846:         expected_notna = Index(com.asarray_tuplesafe(tuples[:-1]))
  847:         result_notna = result[:-1]
  848:         tm.assert_index_equal(result_notna, expected_notna)
  849: 
  850:         # check the NA portion
  851:         result_na = result[-1]
  852:         if na_tuple:
  853:             assert isinstance(result_na, tuple)
  854:             assert len(result_na) == 2
  855:             assert all(isna(x) for x in result_na)
  856:         else:
  857:             assert isna(result_na)
  858: 
  859:     def test_nbytes(self):
  860:         # GH 19209
  861:         left = np.arange(0, 4, dtype="i8")
  862:         right = np.arange(1, 5, dtype="i8")
  863: 
  864:         result = IntervalIndex.from_arrays(left, right).nbytes
  865:         expected = 64  # 4 * 8 * 2
  866:         assert result == expected
  867: 
  868:     @pytest.mark.parametrize("new_closed", ["left", "right", "both", "neither"])
  869:     def test_set_closed(self, name, closed, new_closed):
  870:         # GH 21670
  871:         index = interval_range(0, 5, closed=closed, name=name)
  872:         result = index.set_closed(new_closed)
  873:         expected = interval_range(0, 5, closed=new_closed, name=name)
  874:         tm.assert_index_equal(result, expected)
  875: 
  876:     @pytest.mark.parametrize("bad_closed", ["foo", 10, "LEFT", True, False])
  877:     def test_set_closed_errors(self, bad_closed):
  878:         # GH 21670
  879:         index = interval_range(0, 5)
  880:         msg = f"invalid option for 'closed': {bad_closed}"
  881:         with pytest.raises(ValueError, match=msg):
  882:             index.set_closed(bad_closed)
  883: 
  884:     def test_is_all_dates(self):
  885:         # GH 23576
  886:         year_2017 = Interval(
  887:             Timestamp("2017-01-01 00:00:00"), Timestamp("2018-01-01 00:00:00")
  888:         )
  889:         year_2017_index = IntervalIndex([year_2017])
  890:         assert not year_2017_index._is_all_dates
  891: 
  892: 
  893: def test_dir():
  894:     # GH#27571 dir(interval_index) should not raise
  895:     index = IntervalIndex.from_arrays([0, 1], [1, 2])
  896:     result = dir(index)
  897:     assert "str" not in result
  898: 
  899: 
  900: def test_searchsorted_different_argument_classes(listlike_box):
  901:     # https://github.com/pandas-dev/pandas/issues/32762
  902:     values = IntervalIndex([Interval(0, 1), Interval(1, 2)])
  903:     result = values.searchsorted(listlike_box(values))
  904:     expected = np.array([0, 1], dtype=result.dtype)
  905:     tm.assert_numpy_array_equal(result, expected)
  906: 
  907:     result = values._data.searchsorted(listlike_box(values))
  908:     tm.assert_numpy_array_equal(result, expected)
  909: 
  910: 
  911: @pytest.mark.parametrize(
  912:     "arg", [[1, 2], ["a", "b"], [Timestamp("2020-01-01", tz="Europe/London")] * 2]
  913: )
  914: def test_searchsorted_invalid_argument(arg):
  915:     values = IntervalIndex([Interval(0, 1), Interval(1, 2)])
  916:     msg = "'<' not supported between instances of 'pandas._libs.interval.Interval' and "
  917:     with pytest.raises(TypeError, match=msg):
  918:         values.searchsorted(arg)
