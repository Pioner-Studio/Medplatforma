    1: from contextlib import nullcontext
    2: from datetime import (
    3:     datetime,
    4:     time,
    5: )
    6: import locale
    7: 
    8: import numpy as np
    9: import pytest
   10: 
   11: import pandas as pd
   12: from pandas import (
   13:     PeriodIndex,
   14:     Series,
   15: )
   16: import pandas._testing as tm
   17: 
   18: 
   19: def get_local_am_pm():
   20:     """Return the AM and PM strings returned by strftime in current locale."""
   21:     am_local = time(1).strftime("%p")
   22:     pm_local = time(13).strftime("%p")
   23:     return am_local, pm_local
   24: 
   25: 
   26: def test_get_values_for_csv():
   27:     index = PeriodIndex(["2017-01-01", "2017-01-02", "2017-01-03"], freq="D")
   28: 
   29:     # First, with no arguments.
   30:     expected = np.array(["2017-01-01", "2017-01-02", "2017-01-03"], dtype=object)
   31: 
   32:     result = index._get_values_for_csv()
   33:     tm.assert_numpy_array_equal(result, expected)
   34: 
   35:     # No NaN values, so na_rep has no effect
   36:     result = index._get_values_for_csv(na_rep="pandas")
   37:     tm.assert_numpy_array_equal(result, expected)
   38: 
   39:     # Make sure date formatting works
   40:     expected = np.array(["01-2017-01", "01-2017-02", "01-2017-03"], dtype=object)
   41: 
   42:     result = index._get_values_for_csv(date_format="%m-%Y-%d")
   43:     tm.assert_numpy_array_equal(result, expected)
   44: 
   45:     # NULL object handling should work
   46:     index = PeriodIndex(["2017-01-01", pd.NaT, "2017-01-03"], freq="D")
   47:     expected = np.array(["2017-01-01", "NaT", "2017-01-03"], dtype=object)
   48: 
   49:     result = index._get_values_for_csv(na_rep="NaT")
   50:     tm.assert_numpy_array_equal(result, expected)
   51: 
   52:     expected = np.array(["2017-01-01", "pandas", "2017-01-03"], dtype=object)
   53: 
   54:     result = index._get_values_for_csv(na_rep="pandas")
   55:     tm.assert_numpy_array_equal(result, expected)
   56: 
   57: 
   58: class TestPeriodIndexRendering:
   59:     def test_format_empty(self):
   60:         # GH#35712
   61:         empty_idx = PeriodIndex([], freq="Y")
   62:         msg = r"PeriodIndex\.format is deprecated"
   63:         with tm.assert_produces_warning(FutureWarning, match=msg):
   64:             assert empty_idx.format() == []
   65:         with tm.assert_produces_warning(FutureWarning, match=msg):
   66:             assert empty_idx.format(name=True) == [""]
   67: 
   68:     @pytest.mark.parametrize("method", ["__repr__", "__str__"])
   69:     def test_representation(self, method):
   70:         # GH#7601
   71:         idx1 = PeriodIndex([], freq="D")
   72:         idx2 = PeriodIndex(["2011-01-01"], freq="D")
   73:         idx3 = PeriodIndex(["2011-01-01", "2011-01-02"], freq="D")
   74:         idx4 = PeriodIndex(["2011-01-01", "2011-01-02", "2011-01-03"], freq="D")
   75:         idx5 = PeriodIndex(["2011", "2012", "2013"], freq="Y")
   76:         idx6 = PeriodIndex(["2011-01-01 09:00", "2012-02-01 10:00", "NaT"], freq="h")
   77:         idx7 = pd.period_range("2013Q1", periods=1, freq="Q")
   78:         idx8 = pd.period_range("2013Q1", periods=2, freq="Q")
   79:         idx9 = pd.period_range("2013Q1", periods=3, freq="Q")
   80:         idx10 = PeriodIndex(["2011-01-01", "2011-02-01"], freq="3D")
   81: 
   82:         exp1 = "PeriodIndex([], dtype='period[D]')"
   83: 
   84:         exp2 = "PeriodIndex(['2011-01-01'], dtype='period[D]')"
   85: 
   86:         exp3 = "PeriodIndex(['2011-01-01', '2011-01-02'], dtype='period[D]')"
   87: 
   88:         exp4 = (
   89:             "PeriodIndex(['2011-01-01', '2011-01-02', '2011-01-03'], "
   90:             "dtype='period[D]')"
   91:         )
   92: 
   93:         exp5 = "PeriodIndex(['2011', '2012', '2013'], dtype='period[Y-DEC]')"
   94: 
   95:         exp6 = (
   96:             "PeriodIndex(['2011-01-01 09:00', '2012-02-01 10:00', 'NaT'], "
   97:             "dtype='period[h]')"
   98:         )
   99: 
  100:         exp7 = "PeriodIndex(['2013Q1'], dtype='period[Q-DEC]')"
  101: 
  102:         exp8 = "PeriodIndex(['2013Q1', '2013Q2'], dtype='period[Q-DEC]')"
  103: 
  104:         exp9 = "PeriodIndex(['2013Q1', '2013Q2', '2013Q3'], dtype='period[Q-DEC]')"
  105: 
  106:         exp10 = "PeriodIndex(['2011-01-01', '2011-02-01'], dtype='period[3D]')"
  107: 
  108:         for idx, expected in zip(
  109:             [idx1, idx2, idx3, idx4, idx5, idx6, idx7, idx8, idx9, idx10],
  110:             [exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8, exp9, exp10],
  111:         ):
  112:             result = getattr(idx, method)()
  113:             assert result == expected
  114: 
  115:     # TODO: These are Series.__repr__ tests
  116:     def test_representation_to_series(self):
  117:         # GH#10971
  118:         idx1 = PeriodIndex([], freq="D")
  119:         idx2 = PeriodIndex(["2011-01-01"], freq="D")
  120:         idx3 = PeriodIndex(["2011-01-01", "2011-01-02"], freq="D")
  121:         idx4 = PeriodIndex(["2011-01-01", "2011-01-02", "2011-01-03"], freq="D")
  122:         idx5 = PeriodIndex(["2011", "2012", "2013"], freq="Y")
  123:         idx6 = PeriodIndex(["2011-01-01 09:00", "2012-02-01 10:00", "NaT"], freq="h")
  124: 
  125:         idx7 = pd.period_range("2013Q1", periods=1, freq="Q")
  126:         idx8 = pd.period_range("2013Q1", periods=2, freq="Q")
  127:         idx9 = pd.period_range("2013Q1", periods=3, freq="Q")
  128: 
  129:         exp1 = """Series([], dtype: period[D])"""
  130: 
  131:         exp2 = """0    2011-01-01
  132: dtype: period[D]"""
  133: 
  134:         exp3 = """0    2011-01-01
  135: 1    2011-01-02
  136: dtype: period[D]"""
  137: 
  138:         exp4 = """0    2011-01-01
  139: 1    2011-01-02
  140: 2    2011-01-03
  141: dtype: period[D]"""
  142: 
  143:         exp5 = """0    2011
  144: 1    2012
  145: 2    2013
  146: dtype: period[Y-DEC]"""
  147: 
  148:         exp6 = """0    2011-01-01 09:00
  149: 1    2012-02-01 10:00
  150: 2                 NaT
  151: dtype: period[h]"""
  152: 
  153:         exp7 = """0    2013Q1
  154: dtype: period[Q-DEC]"""
  155: 
  156:         exp8 = """0    2013Q1
  157: 1    2013Q2
  158: dtype: period[Q-DEC]"""
  159: 
  160:         exp9 = """0    2013Q1
  161: 1    2013Q2
  162: 2    2013Q3
  163: dtype: period[Q-DEC]"""
  164: 
  165:         for idx, expected in zip(
  166:             [idx1, idx2, idx3, idx4, idx5, idx6, idx7, idx8, idx9],
  167:             [exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8, exp9],
  168:         ):
  169:             result = repr(Series(idx))
  170:             assert result == expected
  171: 
  172:     def test_summary(self):
  173:         # GH#9116
  174:         idx1 = PeriodIndex([], freq="D")
  175:         idx2 = PeriodIndex(["2011-01-01"], freq="D")
  176:         idx3 = PeriodIndex(["2011-01-01", "2011-01-02"], freq="D")
  177:         idx4 = PeriodIndex(["2011-01-01", "2011-01-02", "2011-01-03"], freq="D")
  178:         idx5 = PeriodIndex(["2011", "2012", "2013"], freq="Y")
  179:         idx6 = PeriodIndex(["2011-01-01 09:00", "2012-02-01 10:00", "NaT"], freq="h")
  180: 
  181:         idx7 = pd.period_range("2013Q1", periods=1, freq="Q")
  182:         idx8 = pd.period_range("2013Q1", periods=2, freq="Q")
  183:         idx9 = pd.period_range("2013Q1", periods=3, freq="Q")
  184: 
  185:         exp1 = """PeriodIndex: 0 entries
  186: Freq: D"""
  187: 
  188:         exp2 = """PeriodIndex: 1 entries, 2011-01-01 to 2011-01-01
  189: Freq: D"""
  190: 
  191:         exp3 = """PeriodIndex: 2 entries, 2011-01-01 to 2011-01-02
  192: Freq: D"""
  193: 
  194:         exp4 = """PeriodIndex: 3 entries, 2011-01-01 to 2011-01-03
  195: Freq: D"""
  196: 
  197:         exp5 = """PeriodIndex: 3 entries, 2011 to 2013
  198: Freq: Y-DEC"""
  199: 
  200:         exp6 = """PeriodIndex: 3 entries, 2011-01-01 09:00 to NaT
  201: Freq: h"""
  202: 
  203:         exp7 = """PeriodIndex: 1 entries, 2013Q1 to 2013Q1
  204: Freq: Q-DEC"""
  205: 
  206:         exp8 = """PeriodIndex: 2 entries, 2013Q1 to 2013Q2
  207: Freq: Q-DEC"""
  208: 
  209:         exp9 = """PeriodIndex: 3 entries, 2013Q1 to 2013Q3
  210: Freq: Q-DEC"""
  211: 
  212:         for idx, expected in zip(
  213:             [idx1, idx2, idx3, idx4, idx5, idx6, idx7, idx8, idx9],
  214:             [exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8, exp9],
  215:         ):
  216:             result = idx._summary()
  217:             assert result == expected
  218: 
  219: 
  220: class TestPeriodIndexFormat:
  221:     def test_period_format_and_strftime_default(self):
  222:         per = PeriodIndex([datetime(2003, 1, 1, 12), None], freq="h")
  223: 
  224:         # Default formatting
  225:         msg = "PeriodIndex.format is deprecated"
  226:         with tm.assert_produces_warning(FutureWarning, match=msg):
  227:             formatted = per.format()
  228:         assert formatted[0] == "2003-01-01 12:00"  # default: minutes not shown
  229:         assert formatted[1] == "NaT"
  230:         # format is equivalent to strftime(None)...
  231:         assert formatted[0] == per.strftime(None)[0]
  232:         assert per.strftime(None)[1] is np.nan  # ...except for NaTs
  233: 
  234:         # Same test with nanoseconds freq
  235:         per = pd.period_range("2003-01-01 12:01:01.123456789", periods=2, freq="ns")
  236:         with tm.assert_produces_warning(FutureWarning, match=msg):
  237:             formatted = per.format()
  238:         assert (formatted == per.strftime(None)).all()
  239:         assert formatted[0] == "2003-01-01 12:01:01.123456789"
  240:         assert formatted[1] == "2003-01-01 12:01:01.123456790"
  241: 
  242:     def test_period_custom(self):
  243:         # GH#46252 custom formatting directives %l (ms) and %u (us)
  244:         msg = "PeriodIndex.format is deprecated"
  245: 
  246:         # 3 digits
  247:         per = pd.period_range("2003-01-01 12:01:01.123", periods=2, freq="ms")
  248:         with tm.assert_produces_warning(FutureWarning, match=msg):
  249:             formatted = per.format(date_format="%y %I:%M:%S (ms=%l us=%u ns=%n)")
  250:         assert formatted[0] == "03 12:01:01 (ms=123 us=123000 ns=123000000)"
  251:         assert formatted[1] == "03 12:01:01 (ms=124 us=124000 ns=124000000)"
  252: 
  253:         # 6 digits
  254:         per = pd.period_range("2003-01-01 12:01:01.123456", periods=2, freq="us")
  255:         with tm.assert_produces_warning(FutureWarning, match=msg):
  256:             formatted = per.format(date_format="%y %I:%M:%S (ms=%l us=%u ns=%n)")
  257:         assert formatted[0] == "03 12:01:01 (ms=123 us=123456 ns=123456000)"
  258:         assert formatted[1] == "03 12:01:01 (ms=123 us=123457 ns=123457000)"
  259: 
  260:         # 9 digits
  261:         per = pd.period_range("2003-01-01 12:01:01.123456789", periods=2, freq="ns")
  262:         with tm.assert_produces_warning(FutureWarning, match=msg):
  263:             formatted = per.format(date_format="%y %I:%M:%S (ms=%l us=%u ns=%n)")
  264:         assert formatted[0] == "03 12:01:01 (ms=123 us=123456 ns=123456789)"
  265:         assert formatted[1] == "03 12:01:01 (ms=123 us=123456 ns=123456790)"
  266: 
  267:     def test_period_tz(self):
  268:         # Formatting periods created from a datetime with timezone.
  269:         msg = r"PeriodIndex\.format is deprecated"
  270:         # This timestamp is in 2013 in Europe/Paris but is 2012 in UTC
  271:         dt = pd.to_datetime(["2013-01-01 00:00:00+01:00"], utc=True)
  272: 
  273:         # Converting to a period looses the timezone information
  274:         # Since tz is currently set as utc, we'll see 2012
  275:         with tm.assert_produces_warning(UserWarning, match="will drop timezone"):
  276:             per = dt.to_period(freq="h")
  277:         with tm.assert_produces_warning(FutureWarning, match=msg):
  278:             assert per.format()[0] == "2012-12-31 23:00"
  279: 
  280:         # If tz is currently set as paris before conversion, we'll see 2013
  281:         dt = dt.tz_convert("Europe/Paris")
  282:         with tm.assert_produces_warning(UserWarning, match="will drop timezone"):
  283:             per = dt.to_period(freq="h")
  284:         with tm.assert_produces_warning(FutureWarning, match=msg):
  285:             assert per.format()[0] == "2013-01-01 00:00"
  286: 
  287:     @pytest.mark.parametrize(
  288:         "locale_str",
  289:         [
  290:             pytest.param(None, id=str(locale.getlocale())),
  291:             "it_IT.utf8",
  292:             "it_IT",  # Note: encoding will be 'ISO8859-1'
  293:             "zh_CN.utf8",
  294:             "zh_CN",  # Note: encoding will be 'gb2312'
  295:         ],
  296:     )
  297:     def test_period_non_ascii_fmt(self, locale_str):
  298:         # GH#46468 non-ascii char in input format string leads to wrong output
  299: 
  300:         # Skip if locale cannot be set
  301:         if locale_str is not None and not tm.can_set_locale(locale_str, locale.LC_ALL):
  302:             pytest.skip(f"Skipping as locale '{locale_str}' cannot be set on host.")
  303: 
  304:         # Change locale temporarily for this test.
  305:         with tm.set_locale(locale_str, locale.LC_ALL) if locale_str else nullcontext():
  306:             # Scalar
  307:             per = pd.Period("2018-03-11 13:00", freq="h")
  308:             assert per.strftime("%y Г©") == "18 Г©"
  309: 
  310:             # Index
  311:             per = pd.period_range("2003-01-01 01:00:00", periods=2, freq="12h")
  312:             msg = "PeriodIndex.format is deprecated"
  313:             with tm.assert_produces_warning(FutureWarning, match=msg):
  314:                 formatted = per.format(date_format="%y Г©")
  315:             assert formatted[0] == "03 Г©"
  316:             assert formatted[1] == "03 Г©"
  317: 
  318:     @pytest.mark.parametrize(
  319:         "locale_str",
  320:         [
  321:             pytest.param(None, id=str(locale.getlocale())),
  322:             "it_IT.utf8",
  323:             "it_IT",  # Note: encoding will be 'ISO8859-1'
  324:             "zh_CN.utf8",
  325:             "zh_CN",  # Note: encoding will be 'gb2312'
  326:         ],
  327:     )
  328:     def test_period_custom_locale_directive(self, locale_str):
  329:         # GH#46319 locale-specific directive leads to non-utf8 c strftime char* result
  330: 
  331:         # Skip if locale cannot be set
  332:         if locale_str is not None and not tm.can_set_locale(locale_str, locale.LC_ALL):
  333:             pytest.skip(f"Skipping as locale '{locale_str}' cannot be set on host.")
  334: 
  335:         # Change locale temporarily for this test.
  336:         with tm.set_locale(locale_str, locale.LC_ALL) if locale_str else nullcontext():
  337:             # Get locale-specific reference
  338:             am_local, pm_local = get_local_am_pm()
  339: 
  340:             # Scalar
  341:             per = pd.Period("2018-03-11 13:00", freq="h")
  342:             assert per.strftime("%p") == pm_local
  343: 
  344:             # Index
  345:             per = pd.period_range("2003-01-01 01:00:00", periods=2, freq="12h")
  346:             msg = "PeriodIndex.format is deprecated"
  347:             with tm.assert_produces_warning(FutureWarning, match=msg):
  348:                 formatted = per.format(date_format="%y %I:%M:%S%p")
  349:             assert formatted[0] == f"03 01:00:00{am_local}"
  350:             assert formatted[1] == f"03 01:00:00{pm_local}"
