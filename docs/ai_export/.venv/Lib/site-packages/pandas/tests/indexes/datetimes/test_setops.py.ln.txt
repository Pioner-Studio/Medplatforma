    1: from datetime import (
    2:     datetime,
    3:     timezone,
    4: )
    5: 
    6: import numpy as np
    7: import pytest
    8: import pytz
    9: 
   10: import pandas.util._test_decorators as td
   11: 
   12: import pandas as pd
   13: from pandas import (
   14:     DataFrame,
   15:     DatetimeIndex,
   16:     Index,
   17:     Series,
   18:     Timestamp,
   19:     bdate_range,
   20:     date_range,
   21: )
   22: import pandas._testing as tm
   23: 
   24: from pandas.tseries.offsets import (
   25:     BMonthEnd,
   26:     Minute,
   27:     MonthEnd,
   28: )
   29: 
   30: START, END = datetime(2009, 1, 1), datetime(2010, 1, 1)
   31: 
   32: 
   33: class TestDatetimeIndexSetOps:
   34:     tz = [
   35:         None,
   36:         "UTC",
   37:         "Asia/Tokyo",
   38:         "US/Eastern",
   39:         "dateutil/Asia/Singapore",
   40:         "dateutil/US/Pacific",
   41:     ]
   42: 
   43:     # TODO: moved from test_datetimelike; dedup with version below
   44:     def test_union2(self, sort):
   45:         everything = date_range("2020-01-01", periods=10)
   46:         first = everything[:5]
   47:         second = everything[5:]
   48:         union = first.union(second, sort=sort)
   49:         tm.assert_index_equal(union, everything)
   50: 
   51:     @pytest.mark.parametrize("box", [np.array, Series, list])
   52:     def test_union3(self, sort, box):
   53:         everything = date_range("2020-01-01", periods=10)
   54:         first = everything[:5]
   55:         second = everything[5:]
   56: 
   57:         # GH 10149 support listlike inputs other than Index objects
   58:         expected = first.union(second, sort=sort)
   59:         case = box(second.values)
   60:         result = first.union(case, sort=sort)
   61:         tm.assert_index_equal(result, expected)
   62: 
   63:     @pytest.mark.parametrize("tz", tz)
   64:     def test_union(self, tz, sort):
   65:         rng1 = date_range("1/1/2000", freq="D", periods=5, tz=tz)
   66:         other1 = date_range("1/6/2000", freq="D", periods=5, tz=tz)
   67:         expected1 = date_range("1/1/2000", freq="D", periods=10, tz=tz)
   68:         expected1_notsorted = DatetimeIndex(list(other1) + list(rng1))
   69: 
   70:         rng2 = date_range("1/1/2000", freq="D", periods=5, tz=tz)
   71:         other2 = date_range("1/4/2000", freq="D", periods=5, tz=tz)
   72:         expected2 = date_range("1/1/2000", freq="D", periods=8, tz=tz)
   73:         expected2_notsorted = DatetimeIndex(list(other2) + list(rng2[:3]))
   74: 
   75:         rng3 = date_range("1/1/2000", freq="D", periods=5, tz=tz)
   76:         other3 = DatetimeIndex([], tz=tz).as_unit("ns")
   77:         expected3 = date_range("1/1/2000", freq="D", periods=5, tz=tz)
   78:         expected3_notsorted = rng3
   79: 
   80:         for rng, other, exp, exp_notsorted in [
   81:             (rng1, other1, expected1, expected1_notsorted),
   82:             (rng2, other2, expected2, expected2_notsorted),
   83:             (rng3, other3, expected3, expected3_notsorted),
   84:         ]:
   85:             result_union = rng.union(other, sort=sort)
   86:             tm.assert_index_equal(result_union, exp)
   87: 
   88:             result_union = other.union(rng, sort=sort)
   89:             if sort is None:
   90:                 tm.assert_index_equal(result_union, exp)
   91:             else:
   92:                 tm.assert_index_equal(result_union, exp_notsorted)
   93: 
   94:     def test_union_coverage(self, sort):
   95:         idx = DatetimeIndex(["2000-01-03", "2000-01-01", "2000-01-02"])
   96:         ordered = DatetimeIndex(idx.sort_values(), freq="infer")
   97:         result = ordered.union(idx, sort=sort)
   98:         tm.assert_index_equal(result, ordered)
   99: 
  100:         result = ordered[:0].union(ordered, sort=sort)
  101:         tm.assert_index_equal(result, ordered)
  102:         assert result.freq == ordered.freq
  103: 
  104:     def test_union_bug_1730(self, sort):
  105:         rng_a = date_range("1/1/2012", periods=4, freq="3h")
  106:         rng_b = date_range("1/1/2012", periods=4, freq="4h")
  107: 
  108:         result = rng_a.union(rng_b, sort=sort)
  109:         exp = list(rng_a) + list(rng_b[1:])
  110:         if sort is None:
  111:             exp = DatetimeIndex(sorted(exp))
  112:         else:
  113:             exp = DatetimeIndex(exp)
  114:         tm.assert_index_equal(result, exp)
  115: 
  116:     def test_union_bug_1745(self, sort):
  117:         left = DatetimeIndex(["2012-05-11 15:19:49.695000"])
  118:         right = DatetimeIndex(
  119:             [
  120:                 "2012-05-29 13:04:21.322000",
  121:                 "2012-05-11 15:27:24.873000",
  122:                 "2012-05-11 15:31:05.350000",
  123:             ]
  124:         )
  125: 
  126:         result = left.union(right, sort=sort)
  127:         exp = DatetimeIndex(
  128:             [
  129:                 "2012-05-11 15:19:49.695000",
  130:                 "2012-05-29 13:04:21.322000",
  131:                 "2012-05-11 15:27:24.873000",
  132:                 "2012-05-11 15:31:05.350000",
  133:             ]
  134:         )
  135:         if sort is None:
  136:             exp = exp.sort_values()
  137:         tm.assert_index_equal(result, exp)
  138: 
  139:     def test_union_bug_4564(self, sort):
  140:         from pandas import DateOffset
  141: 
  142:         left = date_range("2013-01-01", "2013-02-01")
  143:         right = left + DateOffset(minutes=15)
  144: 
  145:         result = left.union(right, sort=sort)
  146:         exp = list(left) + list(right)
  147:         if sort is None:
  148:             exp = DatetimeIndex(sorted(exp))
  149:         else:
  150:             exp = DatetimeIndex(exp)
  151:         tm.assert_index_equal(result, exp)
  152: 
  153:     def test_union_freq_both_none(self, sort):
  154:         # GH11086
  155:         expected = bdate_range("20150101", periods=10)
  156:         expected._data.freq = None
  157: 
  158:         result = expected.union(expected, sort=sort)
  159:         tm.assert_index_equal(result, expected)
  160:         assert result.freq is None
  161: 
  162:     def test_union_freq_infer(self):
  163:         # When taking the union of two DatetimeIndexes, we infer
  164:         #  a freq even if the arguments don't have freq.  This matches
  165:         #  TimedeltaIndex behavior.
  166:         dti = date_range("2016-01-01", periods=5)
  167:         left = dti[[0, 1, 3, 4]]
  168:         right = dti[[2, 3, 1]]
  169: 
  170:         assert left.freq is None
  171:         assert right.freq is None
  172: 
  173:         result = left.union(right)
  174:         tm.assert_index_equal(result, dti)
  175:         assert result.freq == "D"
  176: 
  177:     def test_union_dataframe_index(self):
  178:         rng1 = date_range("1/1/1999", "1/1/2012", freq="MS")
  179:         s1 = Series(np.random.default_rng(2).standard_normal(len(rng1)), rng1)
  180: 
  181:         rng2 = date_range("1/1/1980", "12/1/2001", freq="MS")
  182:         s2 = Series(np.random.default_rng(2).standard_normal(len(rng2)), rng2)
  183:         df = DataFrame({"s1": s1, "s2": s2})
  184: 
  185:         exp = date_range("1/1/1980", "1/1/2012", freq="MS")
  186:         tm.assert_index_equal(df.index, exp)
  187: 
  188:     def test_union_with_DatetimeIndex(self, sort):
  189:         i1 = Index(np.arange(0, 20, 2, dtype=np.int64))
  190:         i2 = date_range(start="2012-01-03 00:00:00", periods=10, freq="D")
  191:         # Works
  192:         i1.union(i2, sort=sort)
  193:         # Fails with "AttributeError: can't set attribute"
  194:         i2.union(i1, sort=sort)
  195: 
  196:     def test_union_same_timezone_different_units(self):
  197:         # GH 55238
  198:         idx1 = date_range("2000-01-01", periods=3, tz="UTC").as_unit("ms")
  199:         idx2 = date_range("2000-01-01", periods=3, tz="UTC").as_unit("us")
  200:         result = idx1.union(idx2)
  201:         expected = date_range("2000-01-01", periods=3, tz="UTC").as_unit("us")
  202:         tm.assert_index_equal(result, expected)
  203: 
  204:     # TODO: moved from test_datetimelike; de-duplicate with version below
  205:     def test_intersection2(self):
  206:         first = date_range("2020-01-01", periods=10)
  207:         second = first[5:]
  208:         intersect = first.intersection(second)
  209:         tm.assert_index_equal(intersect, second)
  210: 
  211:         # GH 10149
  212:         cases = [klass(second.values) for klass in [np.array, Series, list]]
  213:         for case in cases:
  214:             result = first.intersection(case)
  215:             tm.assert_index_equal(result, second)
  216: 
  217:         third = Index(["a", "b", "c"])
  218:         result = first.intersection(third)
  219:         expected = Index([], dtype=object)
  220:         tm.assert_index_equal(result, expected)
  221: 
  222:     @pytest.mark.parametrize(
  223:         "tz", [None, "Asia/Tokyo", "US/Eastern", "dateutil/US/Pacific"]
  224:     )
  225:     def test_intersection(self, tz, sort):
  226:         # GH 4690 (with tz)
  227:         base = date_range("6/1/2000", "6/30/2000", freq="D", name="idx")
  228: 
  229:         # if target has the same name, it is preserved
  230:         rng2 = date_range("5/15/2000", "6/20/2000", freq="D", name="idx")
  231:         expected2 = date_range("6/1/2000", "6/20/2000", freq="D", name="idx")
  232: 
  233:         # if target name is different, it will be reset
  234:         rng3 = date_range("5/15/2000", "6/20/2000", freq="D", name="other")
  235:         expected3 = date_range("6/1/2000", "6/20/2000", freq="D", name=None)
  236: 
  237:         rng4 = date_range("7/1/2000", "7/31/2000", freq="D", name="idx")
  238:         expected4 = DatetimeIndex([], freq="D", name="idx", dtype="M8[ns]")
  239: 
  240:         for rng, expected in [
  241:             (rng2, expected2),
  242:             (rng3, expected3),
  243:             (rng4, expected4),
  244:         ]:
  245:             result = base.intersection(rng)
  246:             tm.assert_index_equal(result, expected)
  247:             assert result.freq == expected.freq
  248: 
  249:         # non-monotonic
  250:         base = DatetimeIndex(
  251:             ["2011-01-05", "2011-01-04", "2011-01-02", "2011-01-03"], tz=tz, name="idx"
  252:         ).as_unit("ns")
  253: 
  254:         rng2 = DatetimeIndex(
  255:             ["2011-01-04", "2011-01-02", "2011-02-02", "2011-02-03"], tz=tz, name="idx"
  256:         ).as_unit("ns")
  257:         expected2 = DatetimeIndex(
  258:             ["2011-01-04", "2011-01-02"], tz=tz, name="idx"
  259:         ).as_unit("ns")
  260: 
  261:         rng3 = DatetimeIndex(
  262:             ["2011-01-04", "2011-01-02", "2011-02-02", "2011-02-03"],
  263:             tz=tz,
  264:             name="other",
  265:         ).as_unit("ns")
  266:         expected3 = DatetimeIndex(
  267:             ["2011-01-04", "2011-01-02"], tz=tz, name=None
  268:         ).as_unit("ns")
  269: 
  270:         # GH 7880
  271:         rng4 = date_range("7/1/2000", "7/31/2000", freq="D", tz=tz, name="idx")
  272:         expected4 = DatetimeIndex([], tz=tz, name="idx").as_unit("ns")
  273:         assert expected4.freq is None
  274: 
  275:         for rng, expected in [
  276:             (rng2, expected2),
  277:             (rng3, expected3),
  278:             (rng4, expected4),
  279:         ]:
  280:             result = base.intersection(rng, sort=sort)
  281:             if sort is None:
  282:                 expected = expected.sort_values()
  283:             tm.assert_index_equal(result, expected)
  284:             assert result.freq == expected.freq
  285: 
  286:     # parametrize over both anchored and non-anchored freqs, as they
  287:     #  have different code paths
  288:     @pytest.mark.parametrize("freq", ["min", "B"])
  289:     def test_intersection_empty(self, tz_aware_fixture, freq):
  290:         # empty same freq GH2129
  291:         tz = tz_aware_fixture
  292:         rng = date_range("6/1/2000", "6/15/2000", freq=freq, tz=tz)
  293:         result = rng[0:0].intersection(rng)
  294:         assert len(result) == 0
  295:         assert result.freq == rng.freq
  296: 
  297:         result = rng.intersection(rng[0:0])
  298:         assert len(result) == 0
  299:         assert result.freq == rng.freq
  300: 
  301:         # no overlap GH#33604
  302:         check_freq = freq != "min"  # We don't preserve freq on non-anchored offsets
  303:         result = rng[:3].intersection(rng[-3:])
  304:         tm.assert_index_equal(result, rng[:0])
  305:         if check_freq:
  306:             # We don't preserve freq on non-anchored offsets
  307:             assert result.freq == rng.freq
  308: 
  309:         # swapped left and right
  310:         result = rng[-3:].intersection(rng[:3])
  311:         tm.assert_index_equal(result, rng[:0])
  312:         if check_freq:
  313:             # We don't preserve freq on non-anchored offsets
  314:             assert result.freq == rng.freq
  315: 
  316:     def test_intersection_bug_1708(self):
  317:         from pandas import DateOffset
  318: 
  319:         index_1 = date_range("1/1/2012", periods=4, freq="12h")
  320:         index_2 = index_1 + DateOffset(hours=1)
  321: 
  322:         result = index_1.intersection(index_2)
  323:         assert len(result) == 0
  324: 
  325:     @pytest.mark.parametrize("tz", tz)
  326:     def test_difference(self, tz, sort):
  327:         rng_dates = ["1/2/2000", "1/3/2000", "1/1/2000", "1/4/2000", "1/5/2000"]
  328: 
  329:         rng1 = DatetimeIndex(rng_dates, tz=tz)
  330:         other1 = date_range("1/6/2000", freq="D", periods=5, tz=tz)
  331:         expected1 = DatetimeIndex(rng_dates, tz=tz)
  332: 
  333:         rng2 = DatetimeIndex(rng_dates, tz=tz)
  334:         other2 = date_range("1/4/2000", freq="D", periods=5, tz=tz)
  335:         expected2 = DatetimeIndex(rng_dates[:3], tz=tz)
  336: 
  337:         rng3 = DatetimeIndex(rng_dates, tz=tz)
  338:         other3 = DatetimeIndex([], tz=tz)
  339:         expected3 = DatetimeIndex(rng_dates, tz=tz)
  340: 
  341:         for rng, other, expected in [
  342:             (rng1, other1, expected1),
  343:             (rng2, other2, expected2),
  344:             (rng3, other3, expected3),
  345:         ]:
  346:             result_diff = rng.difference(other, sort)
  347:             if sort is None and len(other):
  348:                 # We dont sort (yet?) when empty GH#24959
  349:                 expected = expected.sort_values()
  350:             tm.assert_index_equal(result_diff, expected)
  351: 
  352:     def test_difference_freq(self, sort):
  353:         # GH14323: difference of DatetimeIndex should not preserve frequency
  354: 
  355:         index = date_range("20160920", "20160925", freq="D")
  356:         other = date_range("20160921", "20160924", freq="D")
  357:         expected = DatetimeIndex(["20160920", "20160925"], dtype="M8[ns]", freq=None)
  358:         idx_diff = index.difference(other, sort)
  359:         tm.assert_index_equal(idx_diff, expected)
  360:         tm.assert_attr_equal("freq", idx_diff, expected)
  361: 
  362:         # preserve frequency when the difference is a contiguous
  363:         # subset of the original range
  364:         other = date_range("20160922", "20160925", freq="D")
  365:         idx_diff = index.difference(other, sort)
  366:         expected = DatetimeIndex(["20160920", "20160921"], dtype="M8[ns]", freq="D")
  367:         tm.assert_index_equal(idx_diff, expected)
  368:         tm.assert_attr_equal("freq", idx_diff, expected)
  369: 
  370:     def test_datetimeindex_diff(self, sort):
  371:         dti1 = date_range(freq="QE-JAN", start=datetime(1997, 12, 31), periods=100)
  372:         dti2 = date_range(freq="QE-JAN", start=datetime(1997, 12, 31), periods=98)
  373:         assert len(dti1.difference(dti2, sort)) == 2
  374: 
  375:     @pytest.mark.parametrize("tz", [None, "Asia/Tokyo", "US/Eastern"])
  376:     def test_setops_preserve_freq(self, tz):
  377:         rng = date_range("1/1/2000", "1/1/2002", name="idx", tz=tz)
  378: 
  379:         result = rng[:50].union(rng[50:100])
  380:         assert result.name == rng.name
  381:         assert result.freq == rng.freq
  382:         assert result.tz == rng.tz
  383: 
  384:         result = rng[:50].union(rng[30:100])
  385:         assert result.name == rng.name
  386:         assert result.freq == rng.freq
  387:         assert result.tz == rng.tz
  388: 
  389:         result = rng[:50].union(rng[60:100])
  390:         assert result.name == rng.name
  391:         assert result.freq is None
  392:         assert result.tz == rng.tz
  393: 
  394:         result = rng[:50].intersection(rng[25:75])
  395:         assert result.name == rng.name
  396:         assert result.freqstr == "D"
  397:         assert result.tz == rng.tz
  398: 
  399:         nofreq = DatetimeIndex(list(rng[25:75]), name="other")
  400:         result = rng[:50].union(nofreq)
  401:         assert result.name is None
  402:         assert result.freq == rng.freq
  403:         assert result.tz == rng.tz
  404: 
  405:         result = rng[:50].intersection(nofreq)
  406:         assert result.name is None
  407:         assert result.freq == rng.freq
  408:         assert result.tz == rng.tz
  409: 
  410:     def test_intersection_non_tick_no_fastpath(self):
  411:         # GH#42104
  412:         dti = DatetimeIndex(
  413:             [
  414:                 "2018-12-31",
  415:                 "2019-03-31",
  416:                 "2019-06-30",
  417:                 "2019-09-30",
  418:                 "2019-12-31",
  419:                 "2020-03-31",
  420:             ],
  421:             freq="QE-DEC",
  422:         )
  423:         result = dti[::2].intersection(dti[1::2])
  424:         expected = dti[:0]
  425:         tm.assert_index_equal(result, expected)
  426: 
  427:     def test_dti_intersection(self):
  428:         rng = date_range("1/1/2011", periods=100, freq="h", tz="utc")
  429: 
  430:         left = rng[10:90][::-1]
  431:         right = rng[20:80][::-1]
  432: 
  433:         assert left.tz == rng.tz
  434:         result = left.intersection(right)
  435:         assert result.tz == left.tz
  436: 
  437:     # Note: not difference, as there is no symmetry requirement there
  438:     @pytest.mark.parametrize("setop", ["union", "intersection", "symmetric_difference"])
  439:     def test_dti_setop_aware(self, setop):
  440:         # non-overlapping
  441:         # GH#39328 as of 2.0 we cast these to UTC instead of object
  442:         rng = date_range("2012-11-15 00:00:00", periods=6, freq="h", tz="US/Central")
  443: 
  444:         rng2 = date_range("2012-11-15 12:00:00", periods=6, freq="h", tz="US/Eastern")
  445: 
  446:         result = getattr(rng, setop)(rng2)
  447: 
  448:         left = rng.tz_convert("UTC")
  449:         right = rng2.tz_convert("UTC")
  450:         expected = getattr(left, setop)(right)
  451:         tm.assert_index_equal(result, expected)
  452:         assert result.tz == left.tz
  453:         if len(result):
  454:             assert result[0].tz is timezone.utc
  455:             assert result[-1].tz is timezone.utc
  456: 
  457:     def test_dti_union_mixed(self):
  458:         # GH#21671
  459:         rng = DatetimeIndex([Timestamp("2011-01-01"), pd.NaT])
  460:         rng2 = DatetimeIndex(["2012-01-01", "2012-01-02"], tz="Asia/Tokyo")
  461:         result = rng.union(rng2)
  462:         expected = Index(
  463:             [
  464:                 Timestamp("2011-01-01"),
  465:                 pd.NaT,
  466:                 Timestamp("2012-01-01", tz="Asia/Tokyo"),
  467:                 Timestamp("2012-01-02", tz="Asia/Tokyo"),
  468:             ],
  469:             dtype=object,
  470:         )
  471:         tm.assert_index_equal(result, expected)
  472: 
  473: 
  474: class TestBusinessDatetimeIndex:
  475:     def test_union(self, sort):
  476:         rng = bdate_range(START, END)
  477:         # overlapping
  478:         left = rng[:10]
  479:         right = rng[5:10]
  480: 
  481:         the_union = left.union(right, sort=sort)
  482:         assert isinstance(the_union, DatetimeIndex)
  483: 
  484:         # non-overlapping, gap in middle
  485:         left = rng[:5]
  486:         right = rng[10:]
  487: 
  488:         the_union = left.union(right, sort=sort)
  489:         assert isinstance(the_union, Index)
  490: 
  491:         # non-overlapping, no gap
  492:         left = rng[:5]
  493:         right = rng[5:10]
  494: 
  495:         the_union = left.union(right, sort=sort)
  496:         assert isinstance(the_union, DatetimeIndex)
  497: 
  498:         # order does not matter
  499:         if sort is None:
  500:             tm.assert_index_equal(right.union(left, sort=sort), the_union)
  501:         else:
  502:             expected = DatetimeIndex(list(right) + list(left))
  503:             tm.assert_index_equal(right.union(left, sort=sort), expected)
  504: 
  505:         # overlapping, but different offset
  506:         rng = date_range(START, END, freq=BMonthEnd())
  507: 
  508:         the_union = rng.union(rng, sort=sort)
  509:         assert isinstance(the_union, DatetimeIndex)
  510: 
  511:     def test_union_not_cacheable(self, sort):
  512:         rng = date_range("1/1/2000", periods=50, freq=Minute())
  513:         rng1 = rng[10:]
  514:         rng2 = rng[:25]
  515:         the_union = rng1.union(rng2, sort=sort)
  516:         if sort is None:
  517:             tm.assert_index_equal(the_union, rng)
  518:         else:
  519:             expected = DatetimeIndex(list(rng[10:]) + list(rng[:10]))
  520:             tm.assert_index_equal(the_union, expected)
  521: 
  522:         rng1 = rng[10:]
  523:         rng2 = rng[15:35]
  524:         the_union = rng1.union(rng2, sort=sort)
  525:         expected = rng[10:]
  526:         tm.assert_index_equal(the_union, expected)
  527: 
  528:     def test_intersection(self):
  529:         rng = date_range("1/1/2000", periods=50, freq=Minute())
  530:         rng1 = rng[10:]
  531:         rng2 = rng[:25]
  532:         the_int = rng1.intersection(rng2)
  533:         expected = rng[10:25]
  534:         tm.assert_index_equal(the_int, expected)
  535:         assert isinstance(the_int, DatetimeIndex)
  536:         assert the_int.freq == rng.freq
  537: 
  538:         the_int = rng1.intersection(rng2)
  539:         tm.assert_index_equal(the_int, expected)
  540: 
  541:         # non-overlapping
  542:         the_int = rng[:10].intersection(rng[10:])
  543:         expected = DatetimeIndex([]).as_unit("ns")
  544:         tm.assert_index_equal(the_int, expected)
  545: 
  546:     def test_intersection_bug(self):
  547:         # GH #771
  548:         a = bdate_range("11/30/2011", "12/31/2011")
  549:         b = bdate_range("12/10/2011", "12/20/2011")
  550:         result = a.intersection(b)
  551:         tm.assert_index_equal(result, b)
  552:         assert result.freq == b.freq
  553: 
  554:     def test_intersection_list(self):
  555:         # GH#35876
  556:         # values is not an Index -> no name -> retain "a"
  557:         values = [Timestamp("2020-01-01"), Timestamp("2020-02-01")]
  558:         idx = DatetimeIndex(values, name="a")
  559:         res = idx.intersection(values)
  560:         tm.assert_index_equal(res, idx)
  561: 
  562:     def test_month_range_union_tz_pytz(self, sort):
  563:         tz = pytz.timezone("US/Eastern")
  564: 
  565:         early_start = datetime(2011, 1, 1)
  566:         early_end = datetime(2011, 3, 1)
  567: 
  568:         late_start = datetime(2011, 3, 1)
  569:         late_end = datetime(2011, 5, 1)
  570: 
  571:         early_dr = date_range(start=early_start, end=early_end, tz=tz, freq=MonthEnd())
  572:         late_dr = date_range(start=late_start, end=late_end, tz=tz, freq=MonthEnd())
  573: 
  574:         early_dr.union(late_dr, sort=sort)
  575: 
  576:     @td.skip_if_windows
  577:     def test_month_range_union_tz_dateutil(self, sort):
  578:         from pandas._libs.tslibs.timezones import dateutil_gettz
  579: 
  580:         tz = dateutil_gettz("US/Eastern")
  581: 
  582:         early_start = datetime(2011, 1, 1)
  583:         early_end = datetime(2011, 3, 1)
  584: 
  585:         late_start = datetime(2011, 3, 1)
  586:         late_end = datetime(2011, 5, 1)
  587: 
  588:         early_dr = date_range(start=early_start, end=early_end, tz=tz, freq=MonthEnd())
  589:         late_dr = date_range(start=late_start, end=late_end, tz=tz, freq=MonthEnd())
  590: 
  591:         early_dr.union(late_dr, sort=sort)
  592: 
  593:     @pytest.mark.parametrize("sort", [False, None])
  594:     def test_intersection_duplicates(self, sort):
  595:         # GH#38196
  596:         idx1 = Index(
  597:             [
  598:                 Timestamp("2019-12-13"),
  599:                 Timestamp("2019-12-12"),
  600:                 Timestamp("2019-12-12"),
  601:             ]
  602:         )
  603:         result = idx1.intersection(idx1, sort=sort)
  604:         expected = Index([Timestamp("2019-12-13"), Timestamp("2019-12-12")])
  605:         tm.assert_index_equal(result, expected)
  606: 
  607: 
  608: class TestCustomDatetimeIndex:
  609:     def test_union(self, sort):
  610:         # overlapping
  611:         rng = bdate_range(START, END, freq="C")
  612:         left = rng[:10]
  613:         right = rng[5:10]
  614: 
  615:         the_union = left.union(right, sort=sort)
  616:         assert isinstance(the_union, DatetimeIndex)
  617: 
  618:         # non-overlapping, gap in middle
  619:         left = rng[:5]
  620:         right = rng[10:]
  621: 
  622:         the_union = left.union(right, sort)
  623:         assert isinstance(the_union, Index)
  624: 
  625:         # non-overlapping, no gap
  626:         left = rng[:5]
  627:         right = rng[5:10]
  628: 
  629:         the_union = left.union(right, sort=sort)
  630:         assert isinstance(the_union, DatetimeIndex)
  631: 
  632:         # order does not matter
  633:         if sort is None:
  634:             tm.assert_index_equal(right.union(left, sort=sort), the_union)
  635: 
  636:         # overlapping, but different offset
  637:         rng = date_range(START, END, freq=BMonthEnd())
  638: 
  639:         the_union = rng.union(rng, sort=sort)
  640:         assert isinstance(the_union, DatetimeIndex)
  641: 
  642:     def test_intersection_bug(self):
  643:         # GH #771
  644:         a = bdate_range("11/30/2011", "12/31/2011", freq="C")
  645:         b = bdate_range("12/10/2011", "12/20/2011", freq="C")
  646:         result = a.intersection(b)
  647:         tm.assert_index_equal(result, b)
  648:         assert result.freq == b.freq
  649: 
  650:     @pytest.mark.parametrize(
  651:         "tz", [None, "UTC", "Europe/Berlin", pytz.FixedOffset(-60)]
  652:     )
  653:     def test_intersection_dst_transition(self, tz):
  654:         # GH 46702: Europe/Berlin has DST transition
  655:         idx1 = date_range("2020-03-27", periods=5, freq="D", tz=tz)
  656:         idx2 = date_range("2020-03-30", periods=5, freq="D", tz=tz)
  657:         result = idx1.intersection(idx2)
  658:         expected = date_range("2020-03-30", periods=2, freq="D", tz=tz)
  659:         tm.assert_index_equal(result, expected)
  660: 
  661:         # GH#45863 same problem for union
  662:         index1 = date_range("2021-10-28", periods=3, freq="D", tz="Europe/London")
  663:         index2 = date_range("2021-10-30", periods=4, freq="D", tz="Europe/London")
  664:         result = index1.union(index2)
  665:         expected = date_range("2021-10-28", periods=6, freq="D", tz="Europe/London")
  666:         tm.assert_index_equal(result, expected)
