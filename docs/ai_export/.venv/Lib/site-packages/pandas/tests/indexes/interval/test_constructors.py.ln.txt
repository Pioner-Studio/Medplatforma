    1: from functools import partial
    2: 
    3: import numpy as np
    4: import pytest
    5: 
    6: import pandas.util._test_decorators as td
    7: 
    8: from pandas.core.dtypes.common import is_unsigned_integer_dtype
    9: from pandas.core.dtypes.dtypes import IntervalDtype
   10: 
   11: from pandas import (
   12:     Categorical,
   13:     CategoricalDtype,
   14:     CategoricalIndex,
   15:     Index,
   16:     Interval,
   17:     IntervalIndex,
   18:     date_range,
   19:     notna,
   20:     period_range,
   21:     timedelta_range,
   22: )
   23: import pandas._testing as tm
   24: from pandas.core.arrays import IntervalArray
   25: import pandas.core.common as com
   26: 
   27: 
   28: @pytest.fixture(params=[None, "foo"])
   29: def name(request):
   30:     return request.param
   31: 
   32: 
   33: class ConstructorTests:
   34:     """
   35:     Common tests for all variations of IntervalIndex construction. Input data
   36:     to be supplied in breaks format, then converted by the subclass method
   37:     get_kwargs_from_breaks to the expected format.
   38:     """
   39: 
   40:     @pytest.fixture(
   41:         params=[
   42:             ([3, 14, 15, 92, 653], np.int64),
   43:             (np.arange(10, dtype="int64"), np.int64),
   44:             (Index(np.arange(-10, 11, dtype=np.int64)), np.int64),
   45:             (Index(np.arange(10, 31, dtype=np.uint64)), np.uint64),
   46:             (Index(np.arange(20, 30, 0.5), dtype=np.float64), np.float64),
   47:             (date_range("20180101", periods=10), "<M8[ns]"),
   48:             (
   49:                 date_range("20180101", periods=10, tz="US/Eastern"),
   50:                 "datetime64[ns, US/Eastern]",
   51:             ),
   52:             (timedelta_range("1 day", periods=10), "<m8[ns]"),
   53:         ]
   54:     )
   55:     def breaks_and_expected_subtype(self, request):
   56:         return request.param
   57: 
   58:     def test_constructor(self, constructor, breaks_and_expected_subtype, closed, name):
   59:         breaks, expected_subtype = breaks_and_expected_subtype
   60: 
   61:         result_kwargs = self.get_kwargs_from_breaks(breaks, closed)
   62: 
   63:         result = constructor(closed=closed, name=name, **result_kwargs)
   64: 
   65:         assert result.closed == closed
   66:         assert result.name == name
   67:         assert result.dtype.subtype == expected_subtype
   68:         tm.assert_index_equal(result.left, Index(breaks[:-1], dtype=expected_subtype))
   69:         tm.assert_index_equal(result.right, Index(breaks[1:], dtype=expected_subtype))
   70: 
   71:     @pytest.mark.parametrize(
   72:         "breaks, subtype",
   73:         [
   74:             (Index([0, 1, 2, 3, 4], dtype=np.int64), "float64"),
   75:             (Index([0, 1, 2, 3, 4], dtype=np.int64), "datetime64[ns]"),
   76:             (Index([0, 1, 2, 3, 4], dtype=np.int64), "timedelta64[ns]"),
   77:             (Index([0, 1, 2, 3, 4], dtype=np.float64), "int64"),
   78:             (date_range("2017-01-01", periods=5), "int64"),
   79:             (timedelta_range("1 day", periods=5), "int64"),
   80:         ],
   81:     )
   82:     def test_constructor_dtype(self, constructor, breaks, subtype):
   83:         # GH 19262: conversion via dtype parameter
   84:         expected_kwargs = self.get_kwargs_from_breaks(breaks.astype(subtype))
   85:         expected = constructor(**expected_kwargs)
   86: 
   87:         result_kwargs = self.get_kwargs_from_breaks(breaks)
   88:         iv_dtype = IntervalDtype(subtype, "right")
   89:         for dtype in (iv_dtype, str(iv_dtype)):
   90:             result = constructor(dtype=dtype, **result_kwargs)
   91:             tm.assert_index_equal(result, expected)
   92: 
   93:     @pytest.mark.parametrize(
   94:         "breaks",
   95:         [
   96:             Index([0, 1, 2, 3, 4], dtype=np.int64),
   97:             Index([0, 1, 2, 3, 4], dtype=np.uint64),
   98:             Index([0, 1, 2, 3, 4], dtype=np.float64),
   99:             date_range("2017-01-01", periods=5),
  100:             timedelta_range("1 day", periods=5),
  101:         ],
  102:     )
  103:     def test_constructor_pass_closed(self, constructor, breaks):
  104:         # not passing closed to IntervalDtype, but to IntervalArray constructor
  105:         iv_dtype = IntervalDtype(breaks.dtype)
  106: 
  107:         result_kwargs = self.get_kwargs_from_breaks(breaks)
  108: 
  109:         for dtype in (iv_dtype, str(iv_dtype)):
  110:             with tm.assert_produces_warning(None):
  111:                 result = constructor(dtype=dtype, closed="left", **result_kwargs)
  112:             assert result.dtype.closed == "left"
  113: 
  114:     @pytest.mark.parametrize("breaks", [[np.nan] * 2, [np.nan] * 4, [np.nan] * 50])
  115:     def test_constructor_nan(self, constructor, breaks, closed):
  116:         # GH 18421
  117:         result_kwargs = self.get_kwargs_from_breaks(breaks)
  118:         result = constructor(closed=closed, **result_kwargs)
  119: 
  120:         expected_subtype = np.float64
  121:         expected_values = np.array(breaks[:-1], dtype=object)
  122: 
  123:         assert result.closed == closed
  124:         assert result.dtype.subtype == expected_subtype
  125:         tm.assert_numpy_array_equal(np.array(result), expected_values)
  126: 
  127:     @pytest.mark.parametrize(
  128:         "breaks",
  129:         [
  130:             [],
  131:             np.array([], dtype="int64"),
  132:             np.array([], dtype="uint64"),
  133:             np.array([], dtype="float64"),
  134:             np.array([], dtype="datetime64[ns]"),
  135:             np.array([], dtype="timedelta64[ns]"),
  136:         ],
  137:     )
  138:     def test_constructor_empty(self, constructor, breaks, closed):
  139:         # GH 18421
  140:         result_kwargs = self.get_kwargs_from_breaks(breaks)
  141:         result = constructor(closed=closed, **result_kwargs)
  142: 
  143:         expected_values = np.array([], dtype=object)
  144:         expected_subtype = getattr(breaks, "dtype", np.int64)
  145: 
  146:         assert result.empty
  147:         assert result.closed == closed
  148:         assert result.dtype.subtype == expected_subtype
  149:         tm.assert_numpy_array_equal(np.array(result), expected_values)
  150: 
  151:     @pytest.mark.parametrize(
  152:         "breaks",
  153:         [
  154:             tuple("0123456789"),
  155:             list("abcdefghij"),
  156:             np.array(list("abcdefghij"), dtype=object),
  157:             np.array(list("abcdefghij"), dtype="<U1"),
  158:         ],
  159:     )
  160:     def test_constructor_string(self, constructor, breaks):
  161:         # GH 19016
  162:         msg = (
  163:             "category, object, and string subtypes are not supported "
  164:             "for IntervalIndex"
  165:         )
  166:         with pytest.raises(TypeError, match=msg):
  167:             constructor(**self.get_kwargs_from_breaks(breaks))
  168: 
  169:     @pytest.mark.parametrize("cat_constructor", [Categorical, CategoricalIndex])
  170:     def test_constructor_categorical_valid(self, constructor, cat_constructor):
  171:         # GH 21243/21253
  172: 
  173:         breaks = np.arange(10, dtype="int64")
  174:         expected = IntervalIndex.from_breaks(breaks)
  175: 
  176:         cat_breaks = cat_constructor(breaks)
  177:         result_kwargs = self.get_kwargs_from_breaks(cat_breaks)
  178:         result = constructor(**result_kwargs)
  179:         tm.assert_index_equal(result, expected)
  180: 
  181:     def test_generic_errors(self, constructor):
  182:         # filler input data to be used when supplying invalid kwargs
  183:         filler = self.get_kwargs_from_breaks(range(10))
  184: 
  185:         # invalid closed
  186:         msg = "closed must be one of 'right', 'left', 'both', 'neither'"
  187:         with pytest.raises(ValueError, match=msg):
  188:             constructor(closed="invalid", **filler)
  189: 
  190:         # unsupported dtype
  191:         msg = "dtype must be an IntervalDtype, got int64"
  192:         with pytest.raises(TypeError, match=msg):
  193:             constructor(dtype="int64", **filler)
  194: 
  195:         # invalid dtype
  196:         msg = "data type [\"']invalid[\"'] not understood"
  197:         with pytest.raises(TypeError, match=msg):
  198:             constructor(dtype="invalid", **filler)
  199: 
  200:         # no point in nesting periods in an IntervalIndex
  201:         periods = period_range("2000-01-01", periods=10)
  202:         periods_kwargs = self.get_kwargs_from_breaks(periods)
  203:         msg = "Period dtypes are not supported, use a PeriodIndex instead"
  204:         with pytest.raises(ValueError, match=msg):
  205:             constructor(**periods_kwargs)
  206: 
  207:         # decreasing values
  208:         decreasing_kwargs = self.get_kwargs_from_breaks(range(10, -1, -1))
  209:         msg = "left side of interval must be <= right side"
  210:         with pytest.raises(ValueError, match=msg):
  211:             constructor(**decreasing_kwargs)
  212: 
  213: 
  214: class TestFromArrays(ConstructorTests):
  215:     """Tests specific to IntervalIndex.from_arrays"""
  216: 
  217:     @pytest.fixture
  218:     def constructor(self):
  219:         return IntervalIndex.from_arrays
  220: 
  221:     def get_kwargs_from_breaks(self, breaks, closed="right"):
  222:         """
  223:         converts intervals in breaks format to a dictionary of kwargs to
  224:         specific to the format expected by IntervalIndex.from_arrays
  225:         """
  226:         return {"left": breaks[:-1], "right": breaks[1:]}
  227: 
  228:     def test_constructor_errors(self):
  229:         # GH 19016: categorical data
  230:         data = Categorical(list("01234abcde"), ordered=True)
  231:         msg = (
  232:             "category, object, and string subtypes are not supported "
  233:             "for IntervalIndex"
  234:         )
  235:         with pytest.raises(TypeError, match=msg):
  236:             IntervalIndex.from_arrays(data[:-1], data[1:])
  237: 
  238:         # unequal length
  239:         left = [0, 1, 2]
  240:         right = [2, 3]
  241:         msg = "left and right must have the same length"
  242:         with pytest.raises(ValueError, match=msg):
  243:             IntervalIndex.from_arrays(left, right)
  244: 
  245:     @pytest.mark.parametrize(
  246:         "left_subtype, right_subtype", [(np.int64, np.float64), (np.float64, np.int64)]
  247:     )
  248:     def test_mixed_float_int(self, left_subtype, right_subtype):
  249:         """mixed int/float left/right results in float for both sides"""
  250:         left = np.arange(9, dtype=left_subtype)
  251:         right = np.arange(1, 10, dtype=right_subtype)
  252:         result = IntervalIndex.from_arrays(left, right)
  253: 
  254:         expected_left = Index(left, dtype=np.float64)
  255:         expected_right = Index(right, dtype=np.float64)
  256:         expected_subtype = np.float64
  257: 
  258:         tm.assert_index_equal(result.left, expected_left)
  259:         tm.assert_index_equal(result.right, expected_right)
  260:         assert result.dtype.subtype == expected_subtype
  261: 
  262:     @pytest.mark.parametrize("interval_cls", [IntervalArray, IntervalIndex])
  263:     def test_from_arrays_mismatched_datetimelike_resos(self, interval_cls):
  264:         # GH#55714
  265:         left = date_range("2016-01-01", periods=3, unit="s")
  266:         right = date_range("2017-01-01", periods=3, unit="ms")
  267:         result = interval_cls.from_arrays(left, right)
  268:         expected = interval_cls.from_arrays(left.as_unit("ms"), right)
  269:         tm.assert_equal(result, expected)
  270: 
  271:         # td64
  272:         left2 = left - left[0]
  273:         right2 = right - left[0]
  274:         result2 = interval_cls.from_arrays(left2, right2)
  275:         expected2 = interval_cls.from_arrays(left2.as_unit("ms"), right2)
  276:         tm.assert_equal(result2, expected2)
  277: 
  278:         # dt64tz
  279:         left3 = left.tz_localize("UTC")
  280:         right3 = right.tz_localize("UTC")
  281:         result3 = interval_cls.from_arrays(left3, right3)
  282:         expected3 = interval_cls.from_arrays(left3.as_unit("ms"), right3)
  283:         tm.assert_equal(result3, expected3)
  284: 
  285: 
  286: class TestFromBreaks(ConstructorTests):
  287:     """Tests specific to IntervalIndex.from_breaks"""
  288: 
  289:     @pytest.fixture
  290:     def constructor(self):
  291:         return IntervalIndex.from_breaks
  292: 
  293:     def get_kwargs_from_breaks(self, breaks, closed="right"):
  294:         """
  295:         converts intervals in breaks format to a dictionary of kwargs to
  296:         specific to the format expected by IntervalIndex.from_breaks
  297:         """
  298:         return {"breaks": breaks}
  299: 
  300:     def test_constructor_errors(self):
  301:         # GH 19016: categorical data
  302:         data = Categorical(list("01234abcde"), ordered=True)
  303:         msg = (
  304:             "category, object, and string subtypes are not supported "
  305:             "for IntervalIndex"
  306:         )
  307:         with pytest.raises(TypeError, match=msg):
  308:             IntervalIndex.from_breaks(data)
  309: 
  310:     def test_length_one(self):
  311:         """breaks of length one produce an empty IntervalIndex"""
  312:         breaks = [0]
  313:         result = IntervalIndex.from_breaks(breaks)
  314:         expected = IntervalIndex.from_breaks([])
  315:         tm.assert_index_equal(result, expected)
  316: 
  317:     def test_left_right_dont_share_data(self):
  318:         # GH#36310
  319:         breaks = np.arange(5)
  320:         result = IntervalIndex.from_breaks(breaks)._data
  321:         assert result._left.base is None or result._left.base is not result._right.base
  322: 
  323: 
  324: class TestFromTuples(ConstructorTests):
  325:     """Tests specific to IntervalIndex.from_tuples"""
  326: 
  327:     @pytest.fixture
  328:     def constructor(self):
  329:         return IntervalIndex.from_tuples
  330: 
  331:     def get_kwargs_from_breaks(self, breaks, closed="right"):
  332:         """
  333:         converts intervals in breaks format to a dictionary of kwargs to
  334:         specific to the format expected by IntervalIndex.from_tuples
  335:         """
  336:         if is_unsigned_integer_dtype(breaks):
  337:             pytest.skip(f"{breaks.dtype} not relevant IntervalIndex.from_tuples tests")
  338: 
  339:         if len(breaks) == 0:
  340:             return {"data": breaks}
  341: 
  342:         tuples = list(zip(breaks[:-1], breaks[1:]))
  343:         if isinstance(breaks, (list, tuple)):
  344:             return {"data": tuples}
  345:         elif isinstance(getattr(breaks, "dtype", None), CategoricalDtype):
  346:             return {"data": breaks._constructor(tuples)}
  347:         return {"data": com.asarray_tuplesafe(tuples)}
  348: 
  349:     def test_constructor_errors(self):
  350:         # non-tuple
  351:         tuples = [(0, 1), 2, (3, 4)]
  352:         msg = "IntervalIndex.from_tuples received an invalid item, 2"
  353:         with pytest.raises(TypeError, match=msg.format(t=tuples)):
  354:             IntervalIndex.from_tuples(tuples)
  355: 
  356:         # too few/many items
  357:         tuples = [(0, 1), (2,), (3, 4)]
  358:         msg = "IntervalIndex.from_tuples requires tuples of length 2, got {t}"
  359:         with pytest.raises(ValueError, match=msg.format(t=tuples)):
  360:             IntervalIndex.from_tuples(tuples)
  361: 
  362:         tuples = [(0, 1), (2, 3, 4), (5, 6)]
  363:         with pytest.raises(ValueError, match=msg.format(t=tuples)):
  364:             IntervalIndex.from_tuples(tuples)
  365: 
  366:     def test_na_tuples(self):
  367:         # tuple (NA, NA) evaluates the same as NA as an element
  368:         na_tuple = [(0, 1), (np.nan, np.nan), (2, 3)]
  369:         idx_na_tuple = IntervalIndex.from_tuples(na_tuple)
  370:         idx_na_element = IntervalIndex.from_tuples([(0, 1), np.nan, (2, 3)])
  371:         tm.assert_index_equal(idx_na_tuple, idx_na_element)
  372: 
  373: 
  374: class TestClassConstructors(ConstructorTests):
  375:     """Tests specific to the IntervalIndex/Index constructors"""
  376: 
  377:     @pytest.fixture(
  378:         params=[IntervalIndex, partial(Index, dtype="interval")],
  379:         ids=["IntervalIndex", "Index"],
  380:     )
  381:     def klass(self, request):
  382:         # We use a separate fixture here to include Index.__new__ with dtype kwarg
  383:         return request.param
  384: 
  385:     @pytest.fixture
  386:     def constructor(self):
  387:         return IntervalIndex
  388: 
  389:     def get_kwargs_from_breaks(self, breaks, closed="right"):
  390:         """
  391:         converts intervals in breaks format to a dictionary of kwargs to
  392:         specific to the format expected by the IntervalIndex/Index constructors
  393:         """
  394:         if is_unsigned_integer_dtype(breaks):
  395:             pytest.skip(f"{breaks.dtype} not relevant for class constructor tests")
  396: 
  397:         if len(breaks) == 0:
  398:             return {"data": breaks}
  399: 
  400:         ivs = [
  401:             Interval(left, right, closed) if notna(left) else left
  402:             for left, right in zip(breaks[:-1], breaks[1:])
  403:         ]
  404: 
  405:         if isinstance(breaks, list):
  406:             return {"data": ivs}
  407:         elif isinstance(getattr(breaks, "dtype", None), CategoricalDtype):
  408:             return {"data": breaks._constructor(ivs)}
  409:         return {"data": np.array(ivs, dtype=object)}
  410: 
  411:     def test_generic_errors(self, constructor):
  412:         """
  413:         override the base class implementation since errors are handled
  414:         differently; checks unnecessary since caught at the Interval level
  415:         """
  416: 
  417:     def test_constructor_string(self):
  418:         # GH23013
  419:         # When forming the interval from breaks,
  420:         # the interval of strings is already forbidden.
  421:         pass
  422: 
  423:     def test_constructor_errors(self, klass):
  424:         # mismatched closed within intervals with no constructor override
  425:         ivs = [Interval(0, 1, closed="right"), Interval(2, 3, closed="left")]
  426:         msg = "intervals must all be closed on the same side"
  427:         with pytest.raises(ValueError, match=msg):
  428:             klass(ivs)
  429: 
  430:         # scalar
  431:         msg = (
  432:             r"(IntervalIndex|Index)\(...\) must be called with a collection of "
  433:             "some kind, 5 was passed"
  434:         )
  435:         with pytest.raises(TypeError, match=msg):
  436:             klass(5)
  437: 
  438:         # not an interval; dtype depends on 32bit/windows builds
  439:         msg = "type <class 'numpy.int(32|64)'> with value 0 is not an interval"
  440:         with pytest.raises(TypeError, match=msg):
  441:             klass([0, 1])
  442: 
  443:     @pytest.mark.parametrize(
  444:         "data, closed",
  445:         [
  446:             ([], "both"),
  447:             ([np.nan, np.nan], "neither"),
  448:             (
  449:                 [Interval(0, 3, closed="neither"), Interval(2, 5, closed="neither")],
  450:                 "left",
  451:             ),
  452:             (
  453:                 [Interval(0, 3, closed="left"), Interval(2, 5, closed="right")],
  454:                 "neither",
  455:             ),
  456:             (IntervalIndex.from_breaks(range(5), closed="both"), "right"),
  457:         ],
  458:     )
  459:     def test_override_inferred_closed(self, constructor, data, closed):
  460:         # GH 19370
  461:         if isinstance(data, IntervalIndex):
  462:             tuples = data.to_tuples()
  463:         else:
  464:             tuples = [(iv.left, iv.right) if notna(iv) else iv for iv in data]
  465:         expected = IntervalIndex.from_tuples(tuples, closed=closed)
  466:         result = constructor(data, closed=closed)
  467:         tm.assert_index_equal(result, expected)
  468: 
  469:     @pytest.mark.parametrize(
  470:         "values_constructor", [list, np.array, IntervalIndex, IntervalArray]
  471:     )
  472:     def test_index_object_dtype(self, values_constructor):
  473:         # Index(intervals, dtype=object) is an Index (not an IntervalIndex)
  474:         intervals = [Interval(0, 1), Interval(1, 2), Interval(2, 3)]
  475:         values = values_constructor(intervals)
  476:         result = Index(values, dtype=object)
  477: 
  478:         assert type(result) is Index
  479:         tm.assert_numpy_array_equal(result.values, np.array(values))
  480: 
  481:     def test_index_mixed_closed(self):
  482:         # GH27172
  483:         intervals = [
  484:             Interval(0, 1, closed="left"),
  485:             Interval(1, 2, closed="right"),
  486:             Interval(2, 3, closed="neither"),
  487:             Interval(3, 4, closed="both"),
  488:         ]
  489:         result = Index(intervals)
  490:         expected = Index(intervals, dtype=object)
  491:         tm.assert_index_equal(result, expected)
  492: 
  493: 
  494: @pytest.mark.parametrize("timezone", ["UTC", "US/Pacific", "GMT"])
  495: def test_interval_index_subtype(timezone, inclusive_endpoints_fixture):
  496:     # GH#46999
  497:     dates = date_range("2022", periods=3, tz=timezone)
  498:     dtype = f"interval[datetime64[ns, {timezone}], {inclusive_endpoints_fixture}]"
  499:     result = IntervalIndex.from_arrays(
  500:         ["2022-01-01", "2022-01-02"],
  501:         ["2022-01-02", "2022-01-03"],
  502:         closed=inclusive_endpoints_fixture,
  503:         dtype=dtype,
  504:     )
  505:     expected = IntervalIndex.from_arrays(
  506:         dates[:-1], dates[1:], closed=inclusive_endpoints_fixture
  507:     )
  508:     tm.assert_index_equal(result, expected)
  509: 
  510: 
  511: def test_dtype_closed_mismatch():
  512:     # GH#38394 closed specified in both dtype and IntervalIndex constructor
  513: 
  514:     dtype = IntervalDtype(np.int64, "left")
  515: 
  516:     msg = "closed keyword does not match dtype.closed"
  517:     with pytest.raises(ValueError, match=msg):
  518:         IntervalIndex([], dtype=dtype, closed="neither")
  519: 
  520:     with pytest.raises(ValueError, match=msg):
  521:         IntervalArray([], dtype=dtype, closed="neither")
  522: 
  523: 
  524: @pytest.mark.parametrize(
  525:     "dtype",
  526:     ["Float64", pytest.param("float64[pyarrow]", marks=td.skip_if_no("pyarrow"))],
  527: )
  528: def test_ea_dtype(dtype):
  529:     # GH#56765
  530:     bins = [(0.0, 0.4), (0.4, 0.6)]
  531:     interval_dtype = IntervalDtype(subtype=dtype, closed="left")
  532:     result = IntervalIndex.from_tuples(bins, closed="left", dtype=interval_dtype)
  533:     assert result.dtype == interval_dtype
  534:     expected = IntervalIndex.from_tuples(bins, closed="left").astype(interval_dtype)
  535:     tm.assert_index_equal(result, expected)
