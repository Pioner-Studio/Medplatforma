    1: import numpy as np
    2: import pytest
    3: 
    4: from pandas import (
    5:     DataFrame,
    6:     Index,
    7:     Interval,
    8:     MultiIndex,
    9:     Series,
   10:     StringDtype,
   11: )
   12: import pandas._testing as tm
   13: 
   14: 
   15: @pytest.mark.parametrize(
   16:     "other", [Index(["three", "one", "two"]), Index(["one"]), Index(["one", "three"])]
   17: )
   18: def test_join_level(idx, other, join_type):
   19:     join_index, lidx, ridx = other.join(
   20:         idx, how=join_type, level="second", return_indexers=True
   21:     )
   22: 
   23:     exp_level = other.join(idx.levels[1], how=join_type)
   24:     assert join_index.levels[0].equals(idx.levels[0])
   25:     assert join_index.levels[1].equals(exp_level)
   26: 
   27:     # pare down levels
   28:     mask = np.array([x[1] in exp_level for x in idx], dtype=bool)
   29:     exp_values = idx.values[mask]
   30:     tm.assert_numpy_array_equal(join_index.values, exp_values)
   31: 
   32:     if join_type in ("outer", "inner"):
   33:         join_index2, ridx2, lidx2 = idx.join(
   34:             other, how=join_type, level="second", return_indexers=True
   35:         )
   36: 
   37:         assert join_index.equals(join_index2)
   38:         tm.assert_numpy_array_equal(lidx, lidx2)
   39:         tm.assert_numpy_array_equal(ridx, ridx2)
   40:         tm.assert_numpy_array_equal(join_index2.values, exp_values)
   41: 
   42: 
   43: def test_join_level_corner_case(idx):
   44:     # some corner cases
   45:     index = Index(["three", "one", "two"])
   46:     result = index.join(idx, level="second")
   47:     assert isinstance(result, MultiIndex)
   48: 
   49:     with pytest.raises(TypeError, match="Join.*MultiIndex.*ambiguous"):
   50:         idx.join(idx, level=1)
   51: 
   52: 
   53: def test_join_self(idx, join_type):
   54:     result = idx.join(idx, how=join_type)
   55:     expected = idx
   56:     if join_type == "outer":
   57:         expected = expected.sort_values()
   58:     tm.assert_index_equal(result, expected)
   59: 
   60: 
   61: def test_join_multi():
   62:     # GH 10665
   63:     midx = MultiIndex.from_product([np.arange(4), np.arange(4)], names=["a", "b"])
   64:     idx = Index([1, 2, 5], name="b")
   65: 
   66:     # inner
   67:     jidx, lidx, ridx = midx.join(idx, how="inner", return_indexers=True)
   68:     exp_idx = MultiIndex.from_product([np.arange(4), [1, 2]], names=["a", "b"])
   69:     exp_lidx = np.array([1, 2, 5, 6, 9, 10, 13, 14], dtype=np.intp)
   70:     exp_ridx = np.array([0, 1, 0, 1, 0, 1, 0, 1], dtype=np.intp)
   71:     tm.assert_index_equal(jidx, exp_idx)
   72:     tm.assert_numpy_array_equal(lidx, exp_lidx)
   73:     tm.assert_numpy_array_equal(ridx, exp_ridx)
   74:     # flip
   75:     jidx, ridx, lidx = idx.join(midx, how="inner", return_indexers=True)
   76:     tm.assert_index_equal(jidx, exp_idx)
   77:     tm.assert_numpy_array_equal(lidx, exp_lidx)
   78:     tm.assert_numpy_array_equal(ridx, exp_ridx)
   79: 
   80:     # keep MultiIndex
   81:     jidx, lidx, ridx = midx.join(idx, how="left", return_indexers=True)
   82:     exp_ridx = np.array(
   83:         [-1, 0, 1, -1, -1, 0, 1, -1, -1, 0, 1, -1, -1, 0, 1, -1], dtype=np.intp
   84:     )
   85:     tm.assert_index_equal(jidx, midx)
   86:     assert lidx is None
   87:     tm.assert_numpy_array_equal(ridx, exp_ridx)
   88:     # flip
   89:     jidx, ridx, lidx = idx.join(midx, how="right", return_indexers=True)
   90:     tm.assert_index_equal(jidx, midx)
   91:     assert lidx is None
   92:     tm.assert_numpy_array_equal(ridx, exp_ridx)
   93: 
   94: 
   95: def test_join_multi_wrong_order():
   96:     # GH 25760
   97:     # GH 28956
   98: 
   99:     midx1 = MultiIndex.from_product([[1, 2], [3, 4]], names=["a", "b"])
  100:     midx2 = MultiIndex.from_product([[1, 2], [3, 4]], names=["b", "a"])
  101: 
  102:     join_idx, lidx, ridx = midx1.join(midx2, return_indexers=True)
  103: 
  104:     exp_ridx = np.array([-1, -1, -1, -1], dtype=np.intp)
  105: 
  106:     tm.assert_index_equal(midx1, join_idx)
  107:     assert lidx is None
  108:     tm.assert_numpy_array_equal(ridx, exp_ridx)
  109: 
  110: 
  111: def test_join_multi_return_indexers():
  112:     # GH 34074
  113: 
  114:     midx1 = MultiIndex.from_product([[1, 2], [3, 4], [5, 6]], names=["a", "b", "c"])
  115:     midx2 = MultiIndex.from_product([[1, 2], [3, 4]], names=["a", "b"])
  116: 
  117:     result = midx1.join(midx2, return_indexers=False)
  118:     tm.assert_index_equal(result, midx1)
  119: 
  120: 
  121: def test_join_overlapping_interval_level():
  122:     # GH 44096
  123:     idx_1 = MultiIndex.from_tuples(
  124:         [
  125:             (1, Interval(0.0, 1.0)),
  126:             (1, Interval(1.0, 2.0)),
  127:             (1, Interval(2.0, 5.0)),
  128:             (2, Interval(0.0, 1.0)),
  129:             (2, Interval(1.0, 3.0)),  # interval limit is here at 3.0, not at 2.0
  130:             (2, Interval(3.0, 5.0)),
  131:         ],
  132:         names=["num", "interval"],
  133:     )
  134: 
  135:     idx_2 = MultiIndex.from_tuples(
  136:         [
  137:             (1, Interval(2.0, 5.0)),
  138:             (1, Interval(0.0, 1.0)),
  139:             (1, Interval(1.0, 2.0)),
  140:             (2, Interval(3.0, 5.0)),
  141:             (2, Interval(0.0, 1.0)),
  142:             (2, Interval(1.0, 3.0)),
  143:         ],
  144:         names=["num", "interval"],
  145:     )
  146: 
  147:     expected = MultiIndex.from_tuples(
  148:         [
  149:             (1, Interval(0.0, 1.0)),
  150:             (1, Interval(1.0, 2.0)),
  151:             (1, Interval(2.0, 5.0)),
  152:             (2, Interval(0.0, 1.0)),
  153:             (2, Interval(1.0, 3.0)),
  154:             (2, Interval(3.0, 5.0)),
  155:         ],
  156:         names=["num", "interval"],
  157:     )
  158:     result = idx_1.join(idx_2, how="outer")
  159: 
  160:     tm.assert_index_equal(result, expected)
  161: 
  162: 
  163: def test_join_midx_ea():
  164:     # GH#49277
  165:     midx = MultiIndex.from_arrays(
  166:         [Series([1, 1, 3], dtype="Int64"), Series([1, 2, 3], dtype="Int64")],
  167:         names=["a", "b"],
  168:     )
  169:     midx2 = MultiIndex.from_arrays(
  170:         [Series([1], dtype="Int64"), Series([3], dtype="Int64")], names=["a", "c"]
  171:     )
  172:     result = midx.join(midx2, how="inner")
  173:     expected = MultiIndex.from_arrays(
  174:         [
  175:             Series([1, 1], dtype="Int64"),
  176:             Series([1, 2], dtype="Int64"),
  177:             Series([3, 3], dtype="Int64"),
  178:         ],
  179:         names=["a", "b", "c"],
  180:     )
  181:     tm.assert_index_equal(result, expected)
  182: 
  183: 
  184: def test_join_midx_string():
  185:     # GH#49277
  186:     midx = MultiIndex.from_arrays(
  187:         [
  188:             Series(["a", "a", "c"], dtype=StringDtype()),
  189:             Series(["a", "b", "c"], dtype=StringDtype()),
  190:         ],
  191:         names=["a", "b"],
  192:     )
  193:     midx2 = MultiIndex.from_arrays(
  194:         [Series(["a"], dtype=StringDtype()), Series(["c"], dtype=StringDtype())],
  195:         names=["a", "c"],
  196:     )
  197:     result = midx.join(midx2, how="inner")
  198:     expected = MultiIndex.from_arrays(
  199:         [
  200:             Series(["a", "a"], dtype=StringDtype()),
  201:             Series(["a", "b"], dtype=StringDtype()),
  202:             Series(["c", "c"], dtype=StringDtype()),
  203:         ],
  204:         names=["a", "b", "c"],
  205:     )
  206:     tm.assert_index_equal(result, expected)
  207: 
  208: 
  209: def test_join_multi_with_nan():
  210:     # GH29252
  211:     df1 = DataFrame(
  212:         data={"col1": [1.1, 1.2]},
  213:         index=MultiIndex.from_product([["A"], [1.0, 2.0]], names=["id1", "id2"]),
  214:     )
  215:     df2 = DataFrame(
  216:         data={"col2": [2.1, 2.2]},
  217:         index=MultiIndex.from_product([["A"], [np.nan, 2.0]], names=["id1", "id2"]),
  218:     )
  219:     result = df1.join(df2)
  220:     expected = DataFrame(
  221:         data={"col1": [1.1, 1.2], "col2": [np.nan, 2.2]},
  222:         index=MultiIndex.from_product([["A"], [1.0, 2.0]], names=["id1", "id2"]),
  223:     )
  224:     tm.assert_frame_equal(result, expected)
  225: 
  226: 
  227: @pytest.mark.parametrize("val", [0, 5])
  228: def test_join_dtypes(any_numeric_ea_dtype, val):
  229:     # GH#49830
  230:     midx = MultiIndex.from_arrays([Series([1, 2], dtype=any_numeric_ea_dtype), [3, 4]])
  231:     midx2 = MultiIndex.from_arrays(
  232:         [Series([1, val, val], dtype=any_numeric_ea_dtype), [3, 4, 4]]
  233:     )
  234:     result = midx.join(midx2, how="outer")
  235:     expected = MultiIndex.from_arrays(
  236:         [Series([val, val, 1, 2], dtype=any_numeric_ea_dtype), [4, 4, 3, 4]]
  237:     ).sort_values()
  238:     tm.assert_index_equal(result, expected)
  239: 
  240: 
  241: def test_join_dtypes_all_nan(any_numeric_ea_dtype):
  242:     # GH#49830
  243:     midx = MultiIndex.from_arrays(
  244:         [Series([1, 2], dtype=any_numeric_ea_dtype), [np.nan, np.nan]]
  245:     )
  246:     midx2 = MultiIndex.from_arrays(
  247:         [Series([1, 0, 0], dtype=any_numeric_ea_dtype), [np.nan, np.nan, np.nan]]
  248:     )
  249:     result = midx.join(midx2, how="outer")
  250:     expected = MultiIndex.from_arrays(
  251:         [
  252:             Series([0, 0, 1, 2], dtype=any_numeric_ea_dtype),
  253:             [np.nan, np.nan, np.nan, np.nan],
  254:         ]
  255:     )
  256:     tm.assert_index_equal(result, expected)
  257: 
  258: 
  259: def test_join_index_levels():
  260:     # GH#53093
  261:     midx = midx = MultiIndex.from_tuples([("a", "2019-02-01"), ("a", "2019-02-01")])
  262:     midx2 = MultiIndex.from_tuples([("a", "2019-01-31")])
  263:     result = midx.join(midx2, how="outer")
  264:     expected = MultiIndex.from_tuples(
  265:         [("a", "2019-01-31"), ("a", "2019-02-01"), ("a", "2019-02-01")]
  266:     )
  267:     tm.assert_index_equal(result.levels[1], expected.levels[1])
  268:     tm.assert_index_equal(result, expected)
