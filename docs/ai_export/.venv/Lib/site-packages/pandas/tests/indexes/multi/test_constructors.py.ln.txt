    1: from datetime import (
    2:     date,
    3:     datetime,
    4: )
    5: import itertools
    6: 
    7: import numpy as np
    8: import pytest
    9: 
   10: from pandas.core.dtypes.cast import construct_1d_object_array_from_listlike
   11: 
   12: import pandas as pd
   13: from pandas import (
   14:     Index,
   15:     MultiIndex,
   16:     Series,
   17:     Timestamp,
   18:     date_range,
   19: )
   20: import pandas._testing as tm
   21: 
   22: 
   23: def test_constructor_single_level():
   24:     result = MultiIndex(
   25:         levels=[["foo", "bar", "baz", "qux"]], codes=[[0, 1, 2, 3]], names=["first"]
   26:     )
   27:     assert isinstance(result, MultiIndex)
   28:     expected = Index(["foo", "bar", "baz", "qux"], name="first")
   29:     tm.assert_index_equal(result.levels[0], expected)
   30:     assert result.names == ["first"]
   31: 
   32: 
   33: def test_constructor_no_levels():
   34:     msg = "non-zero number of levels/codes"
   35:     with pytest.raises(ValueError, match=msg):
   36:         MultiIndex(levels=[], codes=[])
   37: 
   38:     msg = "Must pass both levels and codes"
   39:     with pytest.raises(TypeError, match=msg):
   40:         MultiIndex(levels=[])
   41:     with pytest.raises(TypeError, match=msg):
   42:         MultiIndex(codes=[])
   43: 
   44: 
   45: def test_constructor_nonhashable_names():
   46:     # GH 20527
   47:     levels = [[1, 2], ["one", "two"]]
   48:     codes = [[0, 0, 1, 1], [0, 1, 0, 1]]
   49:     names = (["foo"], ["bar"])
   50:     msg = r"MultiIndex\.name must be a hashable type"
   51:     with pytest.raises(TypeError, match=msg):
   52:         MultiIndex(levels=levels, codes=codes, names=names)
   53: 
   54:     # With .rename()
   55:     mi = MultiIndex(
   56:         levels=[[1, 2], ["one", "two"]],
   57:         codes=[[0, 0, 1, 1], [0, 1, 0, 1]],
   58:         names=("foo", "bar"),
   59:     )
   60:     renamed = [["fooo"], ["barr"]]
   61:     with pytest.raises(TypeError, match=msg):
   62:         mi.rename(names=renamed)
   63: 
   64:     # With .set_names()
   65:     with pytest.raises(TypeError, match=msg):
   66:         mi.set_names(names=renamed)
   67: 
   68: 
   69: def test_constructor_mismatched_codes_levels(idx):
   70:     codes = [np.array([1]), np.array([2]), np.array([3])]
   71:     levels = ["a"]
   72: 
   73:     msg = "Length of levels and codes must be the same"
   74:     with pytest.raises(ValueError, match=msg):
   75:         MultiIndex(levels=levels, codes=codes)
   76: 
   77:     length_error = (
   78:         r"On level 0, code max \(3\) >= length of level \(1\)\. "
   79:         "NOTE: this index is in an inconsistent state"
   80:     )
   81:     label_error = r"Unequal code lengths: \[4, 2\]"
   82:     code_value_error = r"On level 0, code value \(-2\) < -1"
   83: 
   84:     # important to check that it's looking at the right thing.
   85:     with pytest.raises(ValueError, match=length_error):
   86:         MultiIndex(levels=[["a"], ["b"]], codes=[[0, 1, 2, 3], [0, 3, 4, 1]])
   87: 
   88:     with pytest.raises(ValueError, match=label_error):
   89:         MultiIndex(levels=[["a"], ["b"]], codes=[[0, 0, 0, 0], [0, 0]])
   90: 
   91:     # external API
   92:     with pytest.raises(ValueError, match=length_error):
   93:         idx.copy().set_levels([["a"], ["b"]])
   94: 
   95:     with pytest.raises(ValueError, match=label_error):
   96:         idx.copy().set_codes([[0, 0, 0, 0], [0, 0]])
   97: 
   98:     # test set_codes with verify_integrity=False
   99:     # the setting should not raise any value error
  100:     idx.copy().set_codes(codes=[[0, 0, 0, 0], [0, 0]], verify_integrity=False)
  101: 
  102:     # code value smaller than -1
  103:     with pytest.raises(ValueError, match=code_value_error):
  104:         MultiIndex(levels=[["a"], ["b"]], codes=[[0, -2], [0, 0]])
  105: 
  106: 
  107: def test_na_levels():
  108:     # GH26408
  109:     # test if codes are re-assigned value -1 for levels
  110:     # with missing values (NaN, NaT, None)
  111:     result = MultiIndex(
  112:         levels=[[np.nan, None, pd.NaT, 128, 2]], codes=[[0, -1, 1, 2, 3, 4]]
  113:     )
  114:     expected = MultiIndex(
  115:         levels=[[np.nan, None, pd.NaT, 128, 2]], codes=[[-1, -1, -1, -1, 3, 4]]
  116:     )
  117:     tm.assert_index_equal(result, expected)
  118: 
  119:     result = MultiIndex(
  120:         levels=[[np.nan, "s", pd.NaT, 128, None]], codes=[[0, -1, 1, 2, 3, 4]]
  121:     )
  122:     expected = MultiIndex(
  123:         levels=[[np.nan, "s", pd.NaT, 128, None]], codes=[[-1, -1, 1, -1, 3, -1]]
  124:     )
  125:     tm.assert_index_equal(result, expected)
  126: 
  127:     # verify set_levels and set_codes
  128:     result = MultiIndex(
  129:         levels=[[1, 2, 3, 4, 5]], codes=[[0, -1, 1, 2, 3, 4]]
  130:     ).set_levels([[np.nan, "s", pd.NaT, 128, None]])
  131:     tm.assert_index_equal(result, expected)
  132: 
  133:     result = MultiIndex(
  134:         levels=[[np.nan, "s", pd.NaT, 128, None]], codes=[[1, 2, 2, 2, 2, 2]]
  135:     ).set_codes([[0, -1, 1, 2, 3, 4]])
  136:     tm.assert_index_equal(result, expected)
  137: 
  138: 
  139: def test_copy_in_constructor():
  140:     levels = np.array(["a", "b", "c"])
  141:     codes = np.array([1, 1, 2, 0, 0, 1, 1])
  142:     val = codes[0]
  143:     mi = MultiIndex(levels=[levels, levels], codes=[codes, codes], copy=True)
  144:     assert mi.codes[0][0] == val
  145:     codes[0] = 15
  146:     assert mi.codes[0][0] == val
  147:     val = levels[0]
  148:     levels[0] = "PANDA"
  149:     assert mi.levels[0][0] == val
  150: 
  151: 
  152: # ----------------------------------------------------------------------------
  153: # from_arrays
  154: # ----------------------------------------------------------------------------
  155: def test_from_arrays(idx):
  156:     arrays = [
  157:         np.asarray(lev).take(level_codes)
  158:         for lev, level_codes in zip(idx.levels, idx.codes)
  159:     ]
  160: 
  161:     # list of arrays as input
  162:     result = MultiIndex.from_arrays(arrays, names=idx.names)
  163:     tm.assert_index_equal(result, idx)
  164: 
  165:     # infer correctly
  166:     result = MultiIndex.from_arrays([[pd.NaT, Timestamp("20130101")], ["a", "b"]])
  167:     assert result.levels[0].equals(Index([Timestamp("20130101")]))
  168:     assert result.levels[1].equals(Index(["a", "b"]))
  169: 
  170: 
  171: def test_from_arrays_iterator(idx):
  172:     # GH 18434
  173:     arrays = [
  174:         np.asarray(lev).take(level_codes)
  175:         for lev, level_codes in zip(idx.levels, idx.codes)
  176:     ]
  177: 
  178:     # iterator as input
  179:     result = MultiIndex.from_arrays(iter(arrays), names=idx.names)
  180:     tm.assert_index_equal(result, idx)
  181: 
  182:     # invalid iterator input
  183:     msg = "Input must be a list / sequence of array-likes."
  184:     with pytest.raises(TypeError, match=msg):
  185:         MultiIndex.from_arrays(0)
  186: 
  187: 
  188: def test_from_arrays_tuples(idx):
  189:     arrays = tuple(
  190:         tuple(np.asarray(lev).take(level_codes))
  191:         for lev, level_codes in zip(idx.levels, idx.codes)
  192:     )
  193: 
  194:     # tuple of tuples as input
  195:     result = MultiIndex.from_arrays(arrays, names=idx.names)
  196:     tm.assert_index_equal(result, idx)
  197: 
  198: 
  199: @pytest.mark.parametrize(
  200:     ("idx1", "idx2"),
  201:     [
  202:         (
  203:             pd.period_range("2011-01-01", freq="D", periods=3),
  204:             pd.period_range("2015-01-01", freq="h", periods=3),
  205:         ),
  206:         (
  207:             date_range("2015-01-01 10:00", freq="D", periods=3, tz="US/Eastern"),
  208:             date_range("2015-01-01 10:00", freq="h", periods=3, tz="Asia/Tokyo"),
  209:         ),
  210:         (
  211:             pd.timedelta_range("1 days", freq="D", periods=3),
  212:             pd.timedelta_range("2 hours", freq="h", periods=3),
  213:         ),
  214:     ],
  215: )
  216: def test_from_arrays_index_series_period_datetimetz_and_timedelta(idx1, idx2):
  217:     result = MultiIndex.from_arrays([idx1, idx2])
  218:     tm.assert_index_equal(result.get_level_values(0), idx1)
  219:     tm.assert_index_equal(result.get_level_values(1), idx2)
  220: 
  221:     result2 = MultiIndex.from_arrays([Series(idx1), Series(idx2)])
  222:     tm.assert_index_equal(result2.get_level_values(0), idx1)
  223:     tm.assert_index_equal(result2.get_level_values(1), idx2)
  224: 
  225:     tm.assert_index_equal(result, result2)
  226: 
  227: 
  228: def test_from_arrays_index_datetimelike_mixed():
  229:     idx1 = date_range("2015-01-01 10:00", freq="D", periods=3, tz="US/Eastern")
  230:     idx2 = date_range("2015-01-01 10:00", freq="h", periods=3)
  231:     idx3 = pd.timedelta_range("1 days", freq="D", periods=3)
  232:     idx4 = pd.period_range("2011-01-01", freq="D", periods=3)
  233: 
  234:     result = MultiIndex.from_arrays([idx1, idx2, idx3, idx4])
  235:     tm.assert_index_equal(result.get_level_values(0), idx1)
  236:     tm.assert_index_equal(result.get_level_values(1), idx2)
  237:     tm.assert_index_equal(result.get_level_values(2), idx3)
  238:     tm.assert_index_equal(result.get_level_values(3), idx4)
  239: 
  240:     result2 = MultiIndex.from_arrays(
  241:         [Series(idx1), Series(idx2), Series(idx3), Series(idx4)]
  242:     )
  243:     tm.assert_index_equal(result2.get_level_values(0), idx1)
  244:     tm.assert_index_equal(result2.get_level_values(1), idx2)
  245:     tm.assert_index_equal(result2.get_level_values(2), idx3)
  246:     tm.assert_index_equal(result2.get_level_values(3), idx4)
  247: 
  248:     tm.assert_index_equal(result, result2)
  249: 
  250: 
  251: def test_from_arrays_index_series_categorical():
  252:     # GH13743
  253:     idx1 = pd.CategoricalIndex(list("abcaab"), categories=list("bac"), ordered=False)
  254:     idx2 = pd.CategoricalIndex(list("abcaab"), categories=list("bac"), ordered=True)
  255: 
  256:     result = MultiIndex.from_arrays([idx1, idx2])
  257:     tm.assert_index_equal(result.get_level_values(0), idx1)
  258:     tm.assert_index_equal(result.get_level_values(1), idx2)
  259: 
  260:     result2 = MultiIndex.from_arrays([Series(idx1), Series(idx2)])
  261:     tm.assert_index_equal(result2.get_level_values(0), idx1)
  262:     tm.assert_index_equal(result2.get_level_values(1), idx2)
  263: 
  264:     result3 = MultiIndex.from_arrays([idx1.values, idx2.values])
  265:     tm.assert_index_equal(result3.get_level_values(0), idx1)
  266:     tm.assert_index_equal(result3.get_level_values(1), idx2)
  267: 
  268: 
  269: def test_from_arrays_empty():
  270:     # 0 levels
  271:     msg = "Must pass non-zero number of levels/codes"
  272:     with pytest.raises(ValueError, match=msg):
  273:         MultiIndex.from_arrays(arrays=[])
  274: 
  275:     # 1 level
  276:     result = MultiIndex.from_arrays(arrays=[[]], names=["A"])
  277:     assert isinstance(result, MultiIndex)
  278:     expected = Index([], name="A")
  279:     tm.assert_index_equal(result.levels[0], expected)
  280:     assert result.names == ["A"]
  281: 
  282:     # N levels
  283:     for N in [2, 3]:
  284:         arrays = [[]] * N
  285:         names = list("ABC")[:N]
  286:         result = MultiIndex.from_arrays(arrays=arrays, names=names)
  287:         expected = MultiIndex(levels=[[]] * N, codes=[[]] * N, names=names)
  288:         tm.assert_index_equal(result, expected)
  289: 
  290: 
  291: @pytest.mark.parametrize(
  292:     "invalid_sequence_of_arrays",
  293:     [
  294:         1,
  295:         [1],
  296:         [1, 2],
  297:         [[1], 2],
  298:         [1, [2]],
  299:         "a",
  300:         ["a"],
  301:         ["a", "b"],
  302:         [["a"], "b"],
  303:         (1,),
  304:         (1, 2),
  305:         ([1], 2),
  306:         (1, [2]),
  307:         "a",
  308:         ("a",),
  309:         ("a", "b"),
  310:         (["a"], "b"),
  311:         [(1,), 2],
  312:         [1, (2,)],
  313:         [("a",), "b"],
  314:         ((1,), 2),
  315:         (1, (2,)),
  316:         (("a",), "b"),
  317:     ],
  318: )
  319: def test_from_arrays_invalid_input(invalid_sequence_of_arrays):
  320:     msg = "Input must be a list / sequence of array-likes"
  321:     with pytest.raises(TypeError, match=msg):
  322:         MultiIndex.from_arrays(arrays=invalid_sequence_of_arrays)
  323: 
  324: 
  325: @pytest.mark.parametrize(
  326:     "idx1, idx2", [([1, 2, 3], ["a", "b"]), ([], ["a", "b"]), ([1, 2, 3], [])]
  327: )
  328: def test_from_arrays_different_lengths(idx1, idx2):
  329:     # see gh-13599
  330:     msg = "^all arrays must be same length$"
  331:     with pytest.raises(ValueError, match=msg):
  332:         MultiIndex.from_arrays([idx1, idx2])
  333: 
  334: 
  335: def test_from_arrays_respects_none_names():
  336:     # GH27292
  337:     a = Series([1, 2, 3], name="foo")
  338:     b = Series(["a", "b", "c"], name="bar")
  339: 
  340:     result = MultiIndex.from_arrays([a, b], names=None)
  341:     expected = MultiIndex(
  342:         levels=[[1, 2, 3], ["a", "b", "c"]], codes=[[0, 1, 2], [0, 1, 2]], names=None
  343:     )
  344: 
  345:     tm.assert_index_equal(result, expected)
  346: 
  347: 
  348: # ----------------------------------------------------------------------------
  349: # from_tuples
  350: # ----------------------------------------------------------------------------
  351: def test_from_tuples():
  352:     msg = "Cannot infer number of levels from empty list"
  353:     with pytest.raises(TypeError, match=msg):
  354:         MultiIndex.from_tuples([])
  355: 
  356:     expected = MultiIndex(
  357:         levels=[[1, 3], [2, 4]], codes=[[0, 1], [0, 1]], names=["a", "b"]
  358:     )
  359: 
  360:     # input tuples
  361:     result = MultiIndex.from_tuples(((1, 2), (3, 4)), names=["a", "b"])
  362:     tm.assert_index_equal(result, expected)
  363: 
  364: 
  365: def test_from_tuples_iterator():
  366:     # GH 18434
  367:     # input iterator for tuples
  368:     expected = MultiIndex(
  369:         levels=[[1, 3], [2, 4]], codes=[[0, 1], [0, 1]], names=["a", "b"]
  370:     )
  371: 
  372:     result = MultiIndex.from_tuples(zip([1, 3], [2, 4]), names=["a", "b"])
  373:     tm.assert_index_equal(result, expected)
  374: 
  375:     # input non-iterables
  376:     msg = "Input must be a list / sequence of tuple-likes."
  377:     with pytest.raises(TypeError, match=msg):
  378:         MultiIndex.from_tuples(0)
  379: 
  380: 
  381: def test_from_tuples_empty():
  382:     # GH 16777
  383:     result = MultiIndex.from_tuples([], names=["a", "b"])
  384:     expected = MultiIndex.from_arrays(arrays=[[], []], names=["a", "b"])
  385:     tm.assert_index_equal(result, expected)
  386: 
  387: 
  388: def test_from_tuples_index_values(idx):
  389:     result = MultiIndex.from_tuples(idx)
  390:     assert (result.values == idx.values).all()
  391: 
  392: 
  393: def test_tuples_with_name_string():
  394:     # GH 15110 and GH 14848
  395: 
  396:     li = [(0, 0, 1), (0, 1, 0), (1, 0, 0)]
  397:     msg = "Names should be list-like for a MultiIndex"
  398:     with pytest.raises(ValueError, match=msg):
  399:         Index(li, name="abc")
  400:     with pytest.raises(ValueError, match=msg):
  401:         Index(li, name="a")
  402: 
  403: 
  404: def test_from_tuples_with_tuple_label():
  405:     # GH 15457
  406:     expected = pd.DataFrame(
  407:         [[2, 1, 2], [4, (1, 2), 3]], columns=["a", "b", "c"]
  408:     ).set_index(["a", "b"])
  409:     idx = MultiIndex.from_tuples([(2, 1), (4, (1, 2))], names=("a", "b"))
  410:     result = pd.DataFrame([2, 3], columns=["c"], index=idx)
  411:     tm.assert_frame_equal(expected, result)
  412: 
  413: 
  414: # ----------------------------------------------------------------------------
  415: # from_product
  416: # ----------------------------------------------------------------------------
  417: def test_from_product_empty_zero_levels():
  418:     # 0 levels
  419:     msg = "Must pass non-zero number of levels/codes"
  420:     with pytest.raises(ValueError, match=msg):
  421:         MultiIndex.from_product([])
  422: 
  423: 
  424: def test_from_product_empty_one_level():
  425:     result = MultiIndex.from_product([[]], names=["A"])
  426:     expected = Index([], name="A")
  427:     tm.assert_index_equal(result.levels[0], expected)
  428:     assert result.names == ["A"]
  429: 
  430: 
  431: @pytest.mark.parametrize(
  432:     "first, second", [([], []), (["foo", "bar", "baz"], []), ([], ["a", "b", "c"])]
  433: )
  434: def test_from_product_empty_two_levels(first, second):
  435:     names = ["A", "B"]
  436:     result = MultiIndex.from_product([first, second], names=names)
  437:     expected = MultiIndex(levels=[first, second], codes=[[], []], names=names)
  438:     tm.assert_index_equal(result, expected)
  439: 
  440: 
  441: @pytest.mark.parametrize("N", list(range(4)))
  442: def test_from_product_empty_three_levels(N):
  443:     # GH12258
  444:     names = ["A", "B", "C"]
  445:     lvl2 = list(range(N))
  446:     result = MultiIndex.from_product([[], lvl2, []], names=names)
  447:     expected = MultiIndex(levels=[[], lvl2, []], codes=[[], [], []], names=names)
  448:     tm.assert_index_equal(result, expected)
  449: 
  450: 
  451: @pytest.mark.parametrize(
  452:     "invalid_input", [1, [1], [1, 2], [[1], 2], "a", ["a"], ["a", "b"], [["a"], "b"]]
  453: )
  454: def test_from_product_invalid_input(invalid_input):
  455:     msg = r"Input must be a list / sequence of iterables|Input must be list-like"
  456:     with pytest.raises(TypeError, match=msg):
  457:         MultiIndex.from_product(iterables=invalid_input)
  458: 
  459: 
  460: def test_from_product_datetimeindex():
  461:     dt_index = date_range("2000-01-01", periods=2)
  462:     mi = MultiIndex.from_product([[1, 2], dt_index])
  463:     etalon = construct_1d_object_array_from_listlike(
  464:         [
  465:             (1, Timestamp("2000-01-01")),
  466:             (1, Timestamp("2000-01-02")),
  467:             (2, Timestamp("2000-01-01")),
  468:             (2, Timestamp("2000-01-02")),
  469:         ]
  470:     )
  471:     tm.assert_numpy_array_equal(mi.values, etalon)
  472: 
  473: 
  474: def test_from_product_rangeindex():
  475:     # RangeIndex is preserved by factorize, so preserved in levels
  476:     rng = Index(range(5))
  477:     other = ["a", "b"]
  478:     mi = MultiIndex.from_product([rng, other])
  479:     tm.assert_index_equal(mi._levels[0], rng, exact=True)
  480: 
  481: 
  482: @pytest.mark.parametrize("ordered", [False, True])
  483: @pytest.mark.parametrize("f", [lambda x: x, lambda x: Series(x), lambda x: x.values])
  484: def test_from_product_index_series_categorical(ordered, f):
  485:     # GH13743
  486:     first = ["foo", "bar"]
  487: 
  488:     idx = pd.CategoricalIndex(list("abcaab"), categories=list("bac"), ordered=ordered)
  489:     expected = pd.CategoricalIndex(
  490:         list("abcaab") + list("abcaab"), categories=list("bac"), ordered=ordered
  491:     )
  492: 
  493:     result = MultiIndex.from_product([first, f(idx)])
  494:     tm.assert_index_equal(result.get_level_values(1), expected)
  495: 
  496: 
  497: def test_from_product():
  498:     first = ["foo", "bar", "buz"]
  499:     second = ["a", "b", "c"]
  500:     names = ["first", "second"]
  501:     result = MultiIndex.from_product([first, second], names=names)
  502: 
  503:     tuples = [
  504:         ("foo", "a"),
  505:         ("foo", "b"),
  506:         ("foo", "c"),
  507:         ("bar", "a"),
  508:         ("bar", "b"),
  509:         ("bar", "c"),
  510:         ("buz", "a"),
  511:         ("buz", "b"),
  512:         ("buz", "c"),
  513:     ]
  514:     expected = MultiIndex.from_tuples(tuples, names=names)
  515: 
  516:     tm.assert_index_equal(result, expected)
  517: 
  518: 
  519: def test_from_product_iterator():
  520:     # GH 18434
  521:     first = ["foo", "bar", "buz"]
  522:     second = ["a", "b", "c"]
  523:     names = ["first", "second"]
  524:     tuples = [
  525:         ("foo", "a"),
  526:         ("foo", "b"),
  527:         ("foo", "c"),
  528:         ("bar", "a"),
  529:         ("bar", "b"),
  530:         ("bar", "c"),
  531:         ("buz", "a"),
  532:         ("buz", "b"),
  533:         ("buz", "c"),
  534:     ]
  535:     expected = MultiIndex.from_tuples(tuples, names=names)
  536: 
  537:     # iterator as input
  538:     result = MultiIndex.from_product(iter([first, second]), names=names)
  539:     tm.assert_index_equal(result, expected)
  540: 
  541:     # Invalid non-iterable input
  542:     msg = "Input must be a list / sequence of iterables."
  543:     with pytest.raises(TypeError, match=msg):
  544:         MultiIndex.from_product(0)
  545: 
  546: 
  547: @pytest.mark.parametrize(
  548:     "a, b, expected_names",
  549:     [
  550:         (
  551:             Series([1, 2, 3], name="foo"),
  552:             Series(["a", "b"], name="bar"),
  553:             ["foo", "bar"],
  554:         ),
  555:         (Series([1, 2, 3], name="foo"), ["a", "b"], ["foo", None]),
  556:         ([1, 2, 3], ["a", "b"], None),
  557:     ],
  558: )
  559: def test_from_product_infer_names(a, b, expected_names):
  560:     # GH27292
  561:     result = MultiIndex.from_product([a, b])
  562:     expected = MultiIndex(
  563:         levels=[[1, 2, 3], ["a", "b"]],
  564:         codes=[[0, 0, 1, 1, 2, 2], [0, 1, 0, 1, 0, 1]],
  565:         names=expected_names,
  566:     )
  567:     tm.assert_index_equal(result, expected)
  568: 
  569: 
  570: def test_from_product_respects_none_names():
  571:     # GH27292
  572:     a = Series([1, 2, 3], name="foo")
  573:     b = Series(["a", "b"], name="bar")
  574: 
  575:     result = MultiIndex.from_product([a, b], names=None)
  576:     expected = MultiIndex(
  577:         levels=[[1, 2, 3], ["a", "b"]],
  578:         codes=[[0, 0, 1, 1, 2, 2], [0, 1, 0, 1, 0, 1]],
  579:         names=None,
  580:     )
  581:     tm.assert_index_equal(result, expected)
  582: 
  583: 
  584: def test_from_product_readonly():
  585:     # GH#15286 passing read-only array to from_product
  586:     a = np.array(range(3))
  587:     b = ["a", "b"]
  588:     expected = MultiIndex.from_product([a, b])
  589: 
  590:     a.setflags(write=False)
  591:     result = MultiIndex.from_product([a, b])
  592:     tm.assert_index_equal(result, expected)
  593: 
  594: 
  595: def test_create_index_existing_name(idx):
  596:     # GH11193, when an existing index is passed, and a new name is not
  597:     # specified, the new index should inherit the previous object name
  598:     index = idx
  599:     index.names = ["foo", "bar"]
  600:     result = Index(index)
  601:     expected = Index(
  602:         Index(
  603:             [
  604:                 ("foo", "one"),
  605:                 ("foo", "two"),
  606:                 ("bar", "one"),
  607:                 ("baz", "two"),
  608:                 ("qux", "one"),
  609:                 ("qux", "two"),
  610:             ],
  611:             dtype="object",
  612:         )
  613:     )
  614:     tm.assert_index_equal(result, expected)
  615: 
  616:     result = Index(index, name="A")
  617:     expected = Index(
  618:         Index(
  619:             [
  620:                 ("foo", "one"),
  621:                 ("foo", "two"),
  622:                 ("bar", "one"),
  623:                 ("baz", "two"),
  624:                 ("qux", "one"),
  625:                 ("qux", "two"),
  626:             ],
  627:             dtype="object",
  628:         ),
  629:         name="A",
  630:     )
  631:     tm.assert_index_equal(result, expected)
  632: 
  633: 
  634: # ----------------------------------------------------------------------------
  635: # from_frame
  636: # ----------------------------------------------------------------------------
  637: def test_from_frame():
  638:     # GH 22420
  639:     df = pd.DataFrame(
  640:         [["a", "a"], ["a", "b"], ["b", "a"], ["b", "b"]], columns=["L1", "L2"]
  641:     )
  642:     expected = MultiIndex.from_tuples(
  643:         [("a", "a"), ("a", "b"), ("b", "a"), ("b", "b")], names=["L1", "L2"]
  644:     )
  645:     result = MultiIndex.from_frame(df)
  646:     tm.assert_index_equal(expected, result)
  647: 
  648: 
  649: def test_from_frame_missing_values_multiIndex():
  650:     # GH 39984
  651:     pa = pytest.importorskip("pyarrow")
  652: 
  653:     df = pd.DataFrame(
  654:         {
  655:             "a": Series([1, 2, None], dtype="Int64"),
  656:             "b": pd.Float64Dtype().__from_arrow__(pa.array([0.2, np.nan, None])),
  657:         }
  658:     )
  659:     multi_indexed = MultiIndex.from_frame(df)
  660:     expected = MultiIndex.from_arrays(
  661:         [
  662:             Series([1, 2, None]).astype("Int64"),
  663:             pd.Float64Dtype().__from_arrow__(pa.array([0.2, np.nan, None])),
  664:         ],
  665:         names=["a", "b"],
  666:     )
  667:     tm.assert_index_equal(multi_indexed, expected)
  668: 
  669: 
  670: @pytest.mark.parametrize(
  671:     "non_frame",
  672:     [
  673:         Series([1, 2, 3, 4]),
  674:         [1, 2, 3, 4],
  675:         [[1, 2], [3, 4], [5, 6]],
  676:         Index([1, 2, 3, 4]),
  677:         np.array([[1, 2], [3, 4], [5, 6]]),
  678:         27,
  679:     ],
  680: )
  681: def test_from_frame_error(non_frame):
  682:     # GH 22420
  683:     with pytest.raises(TypeError, match="Input must be a DataFrame"):
  684:         MultiIndex.from_frame(non_frame)
  685: 
  686: 
  687: def test_from_frame_dtype_fidelity():
  688:     # GH 22420
  689:     df = pd.DataFrame(
  690:         {
  691:             "dates": date_range("19910905", periods=6, tz="US/Eastern"),
  692:             "a": [1, 1, 1, 2, 2, 2],
  693:             "b": pd.Categorical(["a", "a", "b", "b", "c", "c"], ordered=True),
  694:             "c": ["x", "x", "y", "z", "x", "y"],
  695:         }
  696:     )
  697:     original_dtypes = df.dtypes.to_dict()
  698: 
  699:     expected_mi = MultiIndex.from_arrays(
  700:         [
  701:             date_range("19910905", periods=6, tz="US/Eastern"),
  702:             [1, 1, 1, 2, 2, 2],
  703:             pd.Categorical(["a", "a", "b", "b", "c", "c"], ordered=True),
  704:             ["x", "x", "y", "z", "x", "y"],
  705:         ],
  706:         names=["dates", "a", "b", "c"],
  707:     )
  708:     mi = MultiIndex.from_frame(df)
  709:     mi_dtypes = {name: mi.levels[i].dtype for i, name in enumerate(mi.names)}
  710: 
  711:     tm.assert_index_equal(expected_mi, mi)
  712:     assert original_dtypes == mi_dtypes
  713: 
  714: 
  715: @pytest.mark.parametrize(
  716:     "names_in,names_out", [(None, [("L1", "x"), ("L2", "y")]), (["x", "y"], ["x", "y"])]
  717: )
  718: def test_from_frame_valid_names(names_in, names_out):
  719:     # GH 22420
  720:     df = pd.DataFrame(
  721:         [["a", "a"], ["a", "b"], ["b", "a"], ["b", "b"]],
  722:         columns=MultiIndex.from_tuples([("L1", "x"), ("L2", "y")]),
  723:     )
  724:     mi = MultiIndex.from_frame(df, names=names_in)
  725:     assert mi.names == names_out
  726: 
  727: 
  728: @pytest.mark.parametrize(
  729:     "names,expected_error_msg",
  730:     [
  731:         ("bad_input", "Names should be list-like for a MultiIndex"),
  732:         (["a", "b", "c"], "Length of names must match number of levels in MultiIndex"),
  733:     ],
  734: )
  735: def test_from_frame_invalid_names(names, expected_error_msg):
  736:     # GH 22420
  737:     df = pd.DataFrame(
  738:         [["a", "a"], ["a", "b"], ["b", "a"], ["b", "b"]],
  739:         columns=MultiIndex.from_tuples([("L1", "x"), ("L2", "y")]),
  740:     )
  741:     with pytest.raises(ValueError, match=expected_error_msg):
  742:         MultiIndex.from_frame(df, names=names)
  743: 
  744: 
  745: def test_index_equal_empty_iterable():
  746:     # #16844
  747:     a = MultiIndex(levels=[[], []], codes=[[], []], names=["a", "b"])
  748:     b = MultiIndex.from_arrays(arrays=[[], []], names=["a", "b"])
  749:     tm.assert_index_equal(a, b)
  750: 
  751: 
  752: def test_raise_invalid_sortorder():
  753:     # Test that the MultiIndex constructor raise when a incorrect sortorder is given
  754:     # GH#28518
  755: 
  756:     levels = [[0, 1], [0, 1, 2]]
  757: 
  758:     # Correct sortorder
  759:     MultiIndex(
  760:         levels=levels, codes=[[0, 0, 0, 1, 1, 1], [0, 1, 2, 0, 1, 2]], sortorder=2
  761:     )
  762: 
  763:     with pytest.raises(ValueError, match=r".* sortorder 2 with lexsort_depth 1.*"):
  764:         MultiIndex(
  765:             levels=levels, codes=[[0, 0, 0, 1, 1, 1], [0, 1, 2, 0, 2, 1]], sortorder=2
  766:         )
  767: 
  768:     with pytest.raises(ValueError, match=r".* sortorder 1 with lexsort_depth 0.*"):
  769:         MultiIndex(
  770:             levels=levels, codes=[[0, 0, 1, 0, 1, 1], [0, 1, 0, 2, 2, 1]], sortorder=1
  771:         )
  772: 
  773: 
  774: def test_datetimeindex():
  775:     idx1 = pd.DatetimeIndex(
  776:         ["2013-04-01 9:00", "2013-04-02 9:00", "2013-04-03 9:00"] * 2, tz="Asia/Tokyo"
  777:     )
  778:     idx2 = date_range("2010/01/01", periods=6, freq="ME", tz="US/Eastern")
  779:     idx = MultiIndex.from_arrays([idx1, idx2])
  780: 
  781:     expected1 = pd.DatetimeIndex(
  782:         ["2013-04-01 9:00", "2013-04-02 9:00", "2013-04-03 9:00"], tz="Asia/Tokyo"
  783:     )
  784: 
  785:     tm.assert_index_equal(idx.levels[0], expected1)
  786:     tm.assert_index_equal(idx.levels[1], idx2)
  787: 
  788:     # from datetime combos
  789:     # GH 7888
  790:     date1 = np.datetime64("today")
  791:     date2 = datetime.today()
  792:     date3 = Timestamp.today()
  793: 
  794:     for d1, d2 in itertools.product([date1, date2, date3], [date1, date2, date3]):
  795:         index = MultiIndex.from_product([[d1], [d2]])
  796:         assert isinstance(index.levels[0], pd.DatetimeIndex)
  797:         assert isinstance(index.levels[1], pd.DatetimeIndex)
  798: 
  799:     # but NOT date objects, matching Index behavior
  800:     date4 = date.today()
  801:     index = MultiIndex.from_product([[date4], [date2]])
  802:     assert not isinstance(index.levels[0], pd.DatetimeIndex)
  803:     assert isinstance(index.levels[1], pd.DatetimeIndex)
  804: 
  805: 
  806: def test_constructor_with_tz():
  807:     index = pd.DatetimeIndex(
  808:         ["2013/01/01 09:00", "2013/01/02 09:00"], name="dt1", tz="US/Pacific"
  809:     )
  810:     columns = pd.DatetimeIndex(
  811:         ["2014/01/01 09:00", "2014/01/02 09:00"], name="dt2", tz="Asia/Tokyo"
  812:     )
  813: 
  814:     result = MultiIndex.from_arrays([index, columns])
  815: 
  816:     assert result.names == ["dt1", "dt2"]
  817:     tm.assert_index_equal(result.levels[0], index)
  818:     tm.assert_index_equal(result.levels[1], columns)
  819: 
  820:     result = MultiIndex.from_arrays([Series(index), Series(columns)])
  821: 
  822:     assert result.names == ["dt1", "dt2"]
  823:     tm.assert_index_equal(result.levels[0], index)
  824:     tm.assert_index_equal(result.levels[1], columns)
  825: 
  826: 
  827: def test_multiindex_inference_consistency():
  828:     # check that inference behavior matches the base class
  829: 
  830:     v = date.today()
  831: 
  832:     arr = [v, v]
  833: 
  834:     idx = Index(arr)
  835:     assert idx.dtype == object
  836: 
  837:     mi = MultiIndex.from_arrays([arr])
  838:     lev = mi.levels[0]
  839:     assert lev.dtype == object
  840: 
  841:     mi = MultiIndex.from_product([arr])
  842:     lev = mi.levels[0]
  843:     assert lev.dtype == object
  844: 
  845:     mi = MultiIndex.from_tuples([(x,) for x in arr])
  846:     lev = mi.levels[0]
  847:     assert lev.dtype == object
  848: 
  849: 
  850: def test_dtype_representation(using_infer_string):
  851:     # GH#46900
  852:     pmidx = MultiIndex.from_arrays([[1], ["a"]], names=[("a", "b"), ("c", "d")])
  853:     result = pmidx.dtypes
  854:     exp = "object" if not using_infer_string else "string"
  855:     expected = Series(
  856:         ["int64", exp],
  857:         index=MultiIndex.from_tuples([("a", "b"), ("c", "d")]),
  858:         dtype=object,
  859:     )
  860:     tm.assert_series_equal(result, expected)
