    1: """
    2: test date_range, bdate_range construction from the convenience range functions
    3: """
    4: 
    5: from datetime import (
    6:     datetime,
    7:     time,
    8:     timedelta,
    9: )
   10: import re
   11: 
   12: import numpy as np
   13: import pytest
   14: import pytz
   15: from pytz import timezone
   16: 
   17: from pandas._libs.tslibs import timezones
   18: from pandas._libs.tslibs.offsets import (
   19:     BDay,
   20:     CDay,
   21:     DateOffset,
   22:     MonthEnd,
   23:     prefix_mapping,
   24: )
   25: from pandas.errors import OutOfBoundsDatetime
   26: import pandas.util._test_decorators as td
   27: 
   28: import pandas as pd
   29: from pandas import (
   30:     DataFrame,
   31:     DatetimeIndex,
   32:     Series,
   33:     Timedelta,
   34:     Timestamp,
   35:     bdate_range,
   36:     date_range,
   37:     offsets,
   38: )
   39: import pandas._testing as tm
   40: from pandas.core.arrays.datetimes import _generate_range as generate_range
   41: from pandas.tests.indexes.datetimes.test_timezones import (
   42:     FixedOffset,
   43:     fixed_off_no_name,
   44: )
   45: 
   46: from pandas.tseries.holiday import USFederalHolidayCalendar
   47: 
   48: START, END = datetime(2009, 1, 1), datetime(2010, 1, 1)
   49: 
   50: 
   51: def _get_expected_range(
   52:     begin_to_match,
   53:     end_to_match,
   54:     both_range,
   55:     inclusive_endpoints,
   56: ):
   57:     """Helper to get expected range from a both inclusive range"""
   58:     left_match = begin_to_match == both_range[0]
   59:     right_match = end_to_match == both_range[-1]
   60: 
   61:     if inclusive_endpoints == "left" and right_match:
   62:         expected_range = both_range[:-1]
   63:     elif inclusive_endpoints == "right" and left_match:
   64:         expected_range = both_range[1:]
   65:     elif inclusive_endpoints == "neither" and left_match and right_match:
   66:         expected_range = both_range[1:-1]
   67:     elif inclusive_endpoints == "neither" and right_match:
   68:         expected_range = both_range[:-1]
   69:     elif inclusive_endpoints == "neither" and left_match:
   70:         expected_range = both_range[1:]
   71:     elif inclusive_endpoints == "both":
   72:         expected_range = both_range[:]
   73:     else:
   74:         expected_range = both_range[:]
   75: 
   76:     return expected_range
   77: 
   78: 
   79: class TestTimestampEquivDateRange:
   80:     # Older tests in TestTimeSeries constructed their `stamp` objects
   81:     # using `date_range` instead of the `Timestamp` constructor.
   82:     # TestTimestampEquivDateRange checks that these are equivalent in the
   83:     # pertinent cases.
   84: 
   85:     def test_date_range_timestamp_equiv(self):
   86:         rng = date_range("20090415", "20090519", tz="US/Eastern")
   87:         stamp = rng[0]
   88: 
   89:         ts = Timestamp("20090415", tz="US/Eastern")
   90:         assert ts == stamp
   91: 
   92:     def test_date_range_timestamp_equiv_dateutil(self):
   93:         rng = date_range("20090415", "20090519", tz="dateutil/US/Eastern")
   94:         stamp = rng[0]
   95: 
   96:         ts = Timestamp("20090415", tz="dateutil/US/Eastern")
   97:         assert ts == stamp
   98: 
   99:     def test_date_range_timestamp_equiv_explicit_pytz(self):
  100:         rng = date_range("20090415", "20090519", tz=pytz.timezone("US/Eastern"))
  101:         stamp = rng[0]
  102: 
  103:         ts = Timestamp("20090415", tz=pytz.timezone("US/Eastern"))
  104:         assert ts == stamp
  105: 
  106:     @td.skip_if_windows
  107:     def test_date_range_timestamp_equiv_explicit_dateutil(self):
  108:         from pandas._libs.tslibs.timezones import dateutil_gettz as gettz
  109: 
  110:         rng = date_range("20090415", "20090519", tz=gettz("US/Eastern"))
  111:         stamp = rng[0]
  112: 
  113:         ts = Timestamp("20090415", tz=gettz("US/Eastern"))
  114:         assert ts == stamp
  115: 
  116:     def test_date_range_timestamp_equiv_from_datetime_instance(self):
  117:         datetime_instance = datetime(2014, 3, 4)
  118:         # build a timestamp with a frequency, since then it supports
  119:         # addition/subtraction of integers
  120:         timestamp_instance = date_range(datetime_instance, periods=1, freq="D")[0]
  121: 
  122:         ts = Timestamp(datetime_instance)
  123:         assert ts == timestamp_instance
  124: 
  125:     def test_date_range_timestamp_equiv_preserve_frequency(self):
  126:         timestamp_instance = date_range("2014-03-05", periods=1, freq="D")[0]
  127:         ts = Timestamp("2014-03-05")
  128: 
  129:         assert timestamp_instance == ts
  130: 
  131: 
  132: class TestDateRanges:
  133:     def test_date_range_name(self):
  134:         idx = date_range(start="2000-01-01", periods=1, freq="YE", name="TEST")
  135:         assert idx.name == "TEST"
  136: 
  137:     def test_date_range_invalid_periods(self):
  138:         msg = "periods must be a number, got foo"
  139:         with pytest.raises(TypeError, match=msg):
  140:             date_range(start="1/1/2000", periods="foo", freq="D")
  141: 
  142:     def test_date_range_fractional_period(self):
  143:         msg = "Non-integer 'periods' in pd.date_range, pd.timedelta_range"
  144:         with tm.assert_produces_warning(FutureWarning, match=msg):
  145:             rng = date_range("1/1/2000", periods=10.5)
  146:         exp = date_range("1/1/2000", periods=10)
  147:         tm.assert_index_equal(rng, exp)
  148: 
  149:     @pytest.mark.parametrize(
  150:         "freq,freq_depr",
  151:         [
  152:             ("2ME", "2M"),
  153:             ("2SME", "2SM"),
  154:             ("2BQE", "2BQ"),
  155:             ("2BYE", "2BY"),
  156:         ],
  157:     )
  158:     def test_date_range_frequency_M_SM_BQ_BY_deprecated(self, freq, freq_depr):
  159:         # GH#52064
  160:         depr_msg = f"'{freq_depr[1:]}' is deprecated and will be removed "
  161:         f"in a future version, please use '{freq[1:]}' instead."
  162: 
  163:         expected = date_range("1/1/2000", periods=4, freq=freq)
  164:         with tm.assert_produces_warning(FutureWarning, match=depr_msg):
  165:             result = date_range("1/1/2000", periods=4, freq=freq_depr)
  166:         tm.assert_index_equal(result, expected)
  167: 
  168:     def test_date_range_tuple_freq_raises(self):
  169:         # GH#34703
  170:         edate = datetime(2000, 1, 1)
  171:         with pytest.raises(TypeError, match="pass as a string instead"):
  172:             date_range(end=edate, freq=("D", 5), periods=20)
  173: 
  174:     @pytest.mark.parametrize("freq", ["ns", "us", "ms", "min", "s", "h", "D"])
  175:     def test_date_range_edges(self, freq):
  176:         # GH#13672
  177:         td = Timedelta(f"1{freq}")
  178:         ts = Timestamp("1970-01-01")
  179: 
  180:         idx = date_range(
  181:             start=ts + td,
  182:             end=ts + 4 * td,
  183:             freq=freq,
  184:         )
  185:         exp = DatetimeIndex(
  186:             [ts + n * td for n in range(1, 5)],
  187:             dtype="M8[ns]",
  188:             freq=freq,
  189:         )
  190:         tm.assert_index_equal(idx, exp)
  191: 
  192:         # start after end
  193:         idx = date_range(
  194:             start=ts + 4 * td,
  195:             end=ts + td,
  196:             freq=freq,
  197:         )
  198:         exp = DatetimeIndex([], dtype="M8[ns]", freq=freq)
  199:         tm.assert_index_equal(idx, exp)
  200: 
  201:         # start matches end
  202:         idx = date_range(
  203:             start=ts + td,
  204:             end=ts + td,
  205:             freq=freq,
  206:         )
  207:         exp = DatetimeIndex([ts + td], dtype="M8[ns]", freq=freq)
  208:         tm.assert_index_equal(idx, exp)
  209: 
  210:     def test_date_range_near_implementation_bound(self):
  211:         # GH#???
  212:         freq = Timedelta(1)
  213: 
  214:         with pytest.raises(OutOfBoundsDatetime, match="Cannot generate range with"):
  215:             date_range(end=Timestamp.min, periods=2, freq=freq)
  216: 
  217:     def test_date_range_nat(self):
  218:         # GH#11587
  219:         msg = "Neither `start` nor `end` can be NaT"
  220:         with pytest.raises(ValueError, match=msg):
  221:             date_range(start="2016-01-01", end=pd.NaT, freq="D")
  222:         with pytest.raises(ValueError, match=msg):
  223:             date_range(start=pd.NaT, end="2016-01-01", freq="D")
  224: 
  225:     def test_date_range_multiplication_overflow(self):
  226:         # GH#24255
  227:         # check that overflows in calculating `addend = periods * stride`
  228:         #  are caught
  229:         with tm.assert_produces_warning(None):
  230:             # we should _not_ be seeing a overflow RuntimeWarning
  231:             dti = date_range(start="1677-09-22", periods=213503, freq="D")
  232: 
  233:         assert dti[0] == Timestamp("1677-09-22")
  234:         assert len(dti) == 213503
  235: 
  236:         msg = "Cannot generate range with"
  237:         with pytest.raises(OutOfBoundsDatetime, match=msg):
  238:             date_range("1969-05-04", periods=200000000, freq="30000D")
  239: 
  240:     def test_date_range_unsigned_overflow_handling(self):
  241:         # GH#24255
  242:         # case where `addend = periods * stride` overflows int64 bounds
  243:         #  but not uint64 bounds
  244:         dti = date_range(start="1677-09-22", end="2262-04-11", freq="D")
  245: 
  246:         dti2 = date_range(start=dti[0], periods=len(dti), freq="D")
  247:         assert dti2.equals(dti)
  248: 
  249:         dti3 = date_range(end=dti[-1], periods=len(dti), freq="D")
  250:         assert dti3.equals(dti)
  251: 
  252:     def test_date_range_int64_overflow_non_recoverable(self):
  253:         # GH#24255
  254:         # case with start later than 1970-01-01, overflow int64 but not uint64
  255:         msg = "Cannot generate range with"
  256:         with pytest.raises(OutOfBoundsDatetime, match=msg):
  257:             date_range(start="1970-02-01", periods=106752 * 24, freq="h")
  258: 
  259:         # case with end before 1970-01-01, overflow int64 but not uint64
  260:         with pytest.raises(OutOfBoundsDatetime, match=msg):
  261:             date_range(end="1969-11-14", periods=106752 * 24, freq="h")
  262: 
  263:     @pytest.mark.slow
  264:     @pytest.mark.parametrize(
  265:         "s_ts, e_ts", [("2262-02-23", "1969-11-14"), ("1970-02-01", "1677-10-22")]
  266:     )
  267:     def test_date_range_int64_overflow_stride_endpoint_different_signs(
  268:         self, s_ts, e_ts
  269:     ):
  270:         # cases where stride * periods overflow int64 and stride/endpoint
  271:         #  have different signs
  272:         start = Timestamp(s_ts)
  273:         end = Timestamp(e_ts)
  274: 
  275:         expected = date_range(start=start, end=end, freq="-1h")
  276:         assert expected[0] == start
  277:         assert expected[-1] == end
  278: 
  279:         dti = date_range(end=end, periods=len(expected), freq="-1h")
  280:         tm.assert_index_equal(dti, expected)
  281: 
  282:     def test_date_range_out_of_bounds(self):
  283:         # GH#14187
  284:         msg = "Cannot generate range"
  285:         with pytest.raises(OutOfBoundsDatetime, match=msg):
  286:             date_range("2016-01-01", periods=100000, freq="D")
  287:         with pytest.raises(OutOfBoundsDatetime, match=msg):
  288:             date_range(end="1763-10-12", periods=100000, freq="D")
  289: 
  290:     def test_date_range_gen_error(self):
  291:         rng = date_range("1/1/2000 00:00", "1/1/2000 00:18", freq="5min")
  292:         assert len(rng) == 4
  293: 
  294:     def test_date_range_normalize(self):
  295:         snap = datetime.today()
  296:         n = 50
  297: 
  298:         rng = date_range(snap, periods=n, normalize=False, freq="2D")
  299: 
  300:         offset = timedelta(2)
  301:         expected = DatetimeIndex(
  302:             [snap + i * offset for i in range(n)], dtype="M8[ns]", freq=offset
  303:         )
  304: 
  305:         tm.assert_index_equal(rng, expected)
  306: 
  307:         rng = date_range("1/1/2000 08:15", periods=n, normalize=False, freq="B")
  308:         the_time = time(8, 15)
  309:         for val in rng:
  310:             assert val.time() == the_time
  311: 
  312:     def test_date_range_ambiguous_arguments(self):
  313:         # #2538
  314:         start = datetime(2011, 1, 1, 5, 3, 40)
  315:         end = datetime(2011, 1, 1, 8, 9, 40)
  316: 
  317:         msg = (
  318:             "Of the four parameters: start, end, periods, and "
  319:             "freq, exactly three must be specified"
  320:         )
  321:         with pytest.raises(ValueError, match=msg):
  322:             date_range(start, end, periods=10, freq="s")
  323: 
  324:     def test_date_range_convenience_periods(self, unit):
  325:         # GH 20808
  326:         result = date_range("2018-04-24", "2018-04-27", periods=3, unit=unit)
  327:         expected = DatetimeIndex(
  328:             ["2018-04-24 00:00:00", "2018-04-25 12:00:00", "2018-04-27 00:00:00"],
  329:             dtype=f"M8[{unit}]",
  330:             freq=None,
  331:         )
  332: 
  333:         tm.assert_index_equal(result, expected)
  334: 
  335:         # Test if spacing remains linear if tz changes to dst in range
  336:         result = date_range(
  337:             "2018-04-01 01:00:00",
  338:             "2018-04-01 04:00:00",
  339:             tz="Australia/Sydney",
  340:             periods=3,
  341:             unit=unit,
  342:         )
  343:         expected = DatetimeIndex(
  344:             [
  345:                 Timestamp("2018-04-01 01:00:00+1100", tz="Australia/Sydney"),
  346:                 Timestamp("2018-04-01 02:00:00+1000", tz="Australia/Sydney"),
  347:                 Timestamp("2018-04-01 04:00:00+1000", tz="Australia/Sydney"),
  348:             ]
  349:         ).as_unit(unit)
  350:         tm.assert_index_equal(result, expected)
  351: 
  352:     def test_date_range_index_comparison(self):
  353:         rng = date_range("2011-01-01", periods=3, tz="US/Eastern")
  354:         df = Series(rng).to_frame()
  355:         arr = np.array([rng.to_list()]).T
  356:         arr2 = np.array([rng]).T
  357: 
  358:         with pytest.raises(ValueError, match="Unable to coerce to Series"):
  359:             rng == df
  360: 
  361:         with pytest.raises(ValueError, match="Unable to coerce to Series"):
  362:             df == rng
  363: 
  364:         expected = DataFrame([True, True, True])
  365: 
  366:         results = df == arr2
  367:         tm.assert_frame_equal(results, expected)
  368: 
  369:         expected = Series([True, True, True], name=0)
  370: 
  371:         results = df[0] == arr2[:, 0]
  372:         tm.assert_series_equal(results, expected)
  373: 
  374:         expected = np.array(
  375:             [[True, False, False], [False, True, False], [False, False, True]]
  376:         )
  377:         results = rng == arr
  378:         tm.assert_numpy_array_equal(results, expected)
  379: 
  380:     @pytest.mark.parametrize(
  381:         "start,end,result_tz",
  382:         [
  383:             ["20180101", "20180103", "US/Eastern"],
  384:             [datetime(2018, 1, 1), datetime(2018, 1, 3), "US/Eastern"],
  385:             [Timestamp("20180101"), Timestamp("20180103"), "US/Eastern"],
  386:             [
  387:                 Timestamp("20180101", tz="US/Eastern"),
  388:                 Timestamp("20180103", tz="US/Eastern"),
  389:                 "US/Eastern",
  390:             ],
  391:             [
  392:                 Timestamp("20180101", tz="US/Eastern"),
  393:                 Timestamp("20180103", tz="US/Eastern"),
  394:                 None,
  395:             ],
  396:         ],
  397:     )
  398:     def test_date_range_linspacing_tz(self, start, end, result_tz):
  399:         # GH 20983
  400:         result = date_range(start, end, periods=3, tz=result_tz)
  401:         expected = date_range("20180101", periods=3, freq="D", tz="US/Eastern")
  402:         tm.assert_index_equal(result, expected)
  403: 
  404:     def test_date_range_timedelta(self):
  405:         start = "2020-01-01"
  406:         end = "2020-01-11"
  407:         rng1 = date_range(start, end, freq="3D")
  408:         rng2 = date_range(start, end, freq=timedelta(days=3))
  409:         tm.assert_index_equal(rng1, rng2)
  410: 
  411:     def test_range_misspecified(self):
  412:         # GH #1095
  413:         msg = (
  414:             "Of the four parameters: start, end, periods, and "
  415:             "freq, exactly three must be specified"
  416:         )
  417: 
  418:         with pytest.raises(ValueError, match=msg):
  419:             date_range(start="1/1/2000")
  420: 
  421:         with pytest.raises(ValueError, match=msg):
  422:             date_range(end="1/1/2000")
  423: 
  424:         with pytest.raises(ValueError, match=msg):
  425:             date_range(periods=10)
  426: 
  427:         with pytest.raises(ValueError, match=msg):
  428:             date_range(start="1/1/2000", freq="h")
  429: 
  430:         with pytest.raises(ValueError, match=msg):
  431:             date_range(end="1/1/2000", freq="h")
  432: 
  433:         with pytest.raises(ValueError, match=msg):
  434:             date_range(periods=10, freq="h")
  435: 
  436:         with pytest.raises(ValueError, match=msg):
  437:             date_range()
  438: 
  439:     def test_compat_replace(self):
  440:         # https://github.com/statsmodels/statsmodels/issues/3349
  441:         # replace should take ints/longs for compat
  442:         result = date_range(Timestamp("1960-04-01 00:00:00"), periods=76, freq="QS-JAN")
  443:         assert len(result) == 76
  444: 
  445:     def test_catch_infinite_loop(self):
  446:         offset = offsets.DateOffset(minute=5)
  447:         # blow up, don't loop forever
  448:         msg = "Offset <DateOffset: minute=5> did not increment date"
  449:         with pytest.raises(ValueError, match=msg):
  450:             date_range(datetime(2011, 11, 11), datetime(2011, 11, 12), freq=offset)
  451: 
  452:     def test_construct_over_dst(self, unit):
  453:         # GH 20854
  454:         pre_dst = Timestamp("2010-11-07 01:00:00").tz_localize(
  455:             "US/Pacific", ambiguous=True
  456:         )
  457:         pst_dst = Timestamp("2010-11-07 01:00:00").tz_localize(
  458:             "US/Pacific", ambiguous=False
  459:         )
  460:         expect_data = [
  461:             Timestamp("2010-11-07 00:00:00", tz="US/Pacific"),
  462:             pre_dst,
  463:             pst_dst,
  464:         ]
  465:         expected = DatetimeIndex(expect_data, freq="h").as_unit(unit)
  466:         result = date_range(
  467:             start="2010-11-7", periods=3, freq="h", tz="US/Pacific", unit=unit
  468:         )
  469:         tm.assert_index_equal(result, expected)
  470: 
  471:     def test_construct_with_different_start_end_string_format(self, unit):
  472:         # GH 12064
  473:         result = date_range(
  474:             "2013-01-01 00:00:00+09:00",
  475:             "2013/01/01 02:00:00+09:00",
  476:             freq="h",
  477:             unit=unit,
  478:         )
  479:         expected = DatetimeIndex(
  480:             [
  481:                 Timestamp("2013-01-01 00:00:00+09:00"),
  482:                 Timestamp("2013-01-01 01:00:00+09:00"),
  483:                 Timestamp("2013-01-01 02:00:00+09:00"),
  484:             ],
  485:             freq="h",
  486:         ).as_unit(unit)
  487:         tm.assert_index_equal(result, expected)
  488: 
  489:     def test_error_with_zero_monthends(self):
  490:         msg = r"Offset <0 \* MonthEnds> did not increment date"
  491:         with pytest.raises(ValueError, match=msg):
  492:             date_range("1/1/2000", "1/1/2001", freq=MonthEnd(0))
  493: 
  494:     def test_range_bug(self, unit):
  495:         # GH #770
  496:         offset = DateOffset(months=3)
  497:         result = date_range("2011-1-1", "2012-1-31", freq=offset, unit=unit)
  498: 
  499:         start = datetime(2011, 1, 1)
  500:         expected = DatetimeIndex(
  501:             [start + i * offset for i in range(5)], dtype=f"M8[{unit}]", freq=offset
  502:         )
  503:         tm.assert_index_equal(result, expected)
  504: 
  505:     def test_range_tz_pytz(self):
  506:         # see gh-2906
  507:         tz = timezone("US/Eastern")
  508:         start = tz.localize(datetime(2011, 1, 1))
  509:         end = tz.localize(datetime(2011, 1, 3))
  510: 
  511:         dr = date_range(start=start, periods=3)
  512:         assert dr.tz.zone == tz.zone
  513:         assert dr[0] == start
  514:         assert dr[2] == end
  515: 
  516:         dr = date_range(end=end, periods=3)
  517:         assert dr.tz.zone == tz.zone
  518:         assert dr[0] == start
  519:         assert dr[2] == end
  520: 
  521:         dr = date_range(start=start, end=end)
  522:         assert dr.tz.zone == tz.zone
  523:         assert dr[0] == start
  524:         assert dr[2] == end
  525: 
  526:     @pytest.mark.parametrize(
  527:         "start, end",
  528:         [
  529:             [
  530:                 Timestamp(datetime(2014, 3, 6), tz="US/Eastern"),
  531:                 Timestamp(datetime(2014, 3, 12), tz="US/Eastern"),
  532:             ],
  533:             [
  534:                 Timestamp(datetime(2013, 11, 1), tz="US/Eastern"),
  535:                 Timestamp(datetime(2013, 11, 6), tz="US/Eastern"),
  536:             ],
  537:         ],
  538:     )
  539:     def test_range_tz_dst_straddle_pytz(self, start, end):
  540:         dr = date_range(start, end, freq="D")
  541:         assert dr[0] == start
  542:         assert dr[-1] == end
  543:         assert np.all(dr.hour == 0)
  544: 
  545:         dr = date_range(start, end, freq="D", tz="US/Eastern")
  546:         assert dr[0] == start
  547:         assert dr[-1] == end
  548:         assert np.all(dr.hour == 0)
  549: 
  550:         dr = date_range(
  551:             start.replace(tzinfo=None),
  552:             end.replace(tzinfo=None),
  553:             freq="D",
  554:             tz="US/Eastern",
  555:         )
  556:         assert dr[0] == start
  557:         assert dr[-1] == end
  558:         assert np.all(dr.hour == 0)
  559: 
  560:     def test_range_tz_dateutil(self):
  561:         # see gh-2906
  562: 
  563:         # Use maybe_get_tz to fix filename in tz under dateutil.
  564:         from pandas._libs.tslibs.timezones import maybe_get_tz
  565: 
  566:         tz = lambda x: maybe_get_tz("dateutil/" + x)
  567: 
  568:         start = datetime(2011, 1, 1, tzinfo=tz("US/Eastern"))
  569:         end = datetime(2011, 1, 3, tzinfo=tz("US/Eastern"))
  570: 
  571:         dr = date_range(start=start, periods=3)
  572:         assert dr.tz == tz("US/Eastern")
  573:         assert dr[0] == start
  574:         assert dr[2] == end
  575: 
  576:         dr = date_range(end=end, periods=3)
  577:         assert dr.tz == tz("US/Eastern")
  578:         assert dr[0] == start
  579:         assert dr[2] == end
  580: 
  581:         dr = date_range(start=start, end=end)
  582:         assert dr.tz == tz("US/Eastern")
  583:         assert dr[0] == start
  584:         assert dr[2] == end
  585: 
  586:     @pytest.mark.parametrize("freq", ["1D", "3D", "2ME", "7W", "3h", "YE"])
  587:     @pytest.mark.parametrize("tz", [None, "US/Eastern"])
  588:     def test_range_closed(self, freq, tz, inclusive_endpoints_fixture):
  589:         # GH#12409, GH#12684
  590: 
  591:         begin = Timestamp("2011/1/1", tz=tz)
  592:         end = Timestamp("2014/1/1", tz=tz)
  593: 
  594:         result_range = date_range(
  595:             begin, end, inclusive=inclusive_endpoints_fixture, freq=freq
  596:         )
  597:         both_range = date_range(begin, end, inclusive="both", freq=freq)
  598:         expected_range = _get_expected_range(
  599:             begin, end, both_range, inclusive_endpoints_fixture
  600:         )
  601: 
  602:         tm.assert_index_equal(expected_range, result_range)
  603: 
  604:     @pytest.mark.parametrize("freq", ["1D", "3D", "2ME", "7W", "3h", "YE"])
  605:     def test_range_with_tz_closed_with_tz_aware_start_end(
  606:         self, freq, inclusive_endpoints_fixture
  607:     ):
  608:         begin = Timestamp("2011/1/1")
  609:         end = Timestamp("2014/1/1")
  610:         begintz = Timestamp("2011/1/1", tz="US/Eastern")
  611:         endtz = Timestamp("2014/1/1", tz="US/Eastern")
  612: 
  613:         result_range = date_range(
  614:             begin,
  615:             end,
  616:             inclusive=inclusive_endpoints_fixture,
  617:             freq=freq,
  618:             tz="US/Eastern",
  619:         )
  620:         both_range = date_range(
  621:             begin, end, inclusive="both", freq=freq, tz="US/Eastern"
  622:         )
  623:         expected_range = _get_expected_range(
  624:             begintz,
  625:             endtz,
  626:             both_range,
  627:             inclusive_endpoints_fixture,
  628:         )
  629: 
  630:         tm.assert_index_equal(expected_range, result_range)
  631: 
  632:     def test_range_closed_boundary(self, inclusive_endpoints_fixture):
  633:         # GH#11804
  634:         right_boundary = date_range(
  635:             "2015-09-12",
  636:             "2015-12-01",
  637:             freq="QS-MAR",
  638:             inclusive=inclusive_endpoints_fixture,
  639:         )
  640:         left_boundary = date_range(
  641:             "2015-09-01",
  642:             "2015-09-12",
  643:             freq="QS-MAR",
  644:             inclusive=inclusive_endpoints_fixture,
  645:         )
  646:         both_boundary = date_range(
  647:             "2015-09-01",
  648:             "2015-12-01",
  649:             freq="QS-MAR",
  650:             inclusive=inclusive_endpoints_fixture,
  651:         )
  652:         neither_boundary = date_range(
  653:             "2015-09-11",
  654:             "2015-09-12",
  655:             freq="QS-MAR",
  656:             inclusive=inclusive_endpoints_fixture,
  657:         )
  658: 
  659:         expected_right = both_boundary
  660:         expected_left = both_boundary
  661:         expected_both = both_boundary
  662: 
  663:         if inclusive_endpoints_fixture == "right":
  664:             expected_left = both_boundary[1:]
  665:         elif inclusive_endpoints_fixture == "left":
  666:             expected_right = both_boundary[:-1]
  667:         elif inclusive_endpoints_fixture == "both":
  668:             expected_right = both_boundary[1:]
  669:             expected_left = both_boundary[:-1]
  670: 
  671:         expected_neither = both_boundary[1:-1]
  672: 
  673:         tm.assert_index_equal(right_boundary, expected_right)
  674:         tm.assert_index_equal(left_boundary, expected_left)
  675:         tm.assert_index_equal(both_boundary, expected_both)
  676:         tm.assert_index_equal(neither_boundary, expected_neither)
  677: 
  678:     def test_date_range_years_only(self, tz_naive_fixture):
  679:         tz = tz_naive_fixture
  680:         # GH#6961
  681:         rng1 = date_range("2014", "2015", freq="ME", tz=tz)
  682:         expected1 = date_range("2014-01-31", "2014-12-31", freq="ME", tz=tz)
  683:         tm.assert_index_equal(rng1, expected1)
  684: 
  685:         rng2 = date_range("2014", "2015", freq="MS", tz=tz)
  686:         expected2 = date_range("2014-01-01", "2015-01-01", freq="MS", tz=tz)
  687:         tm.assert_index_equal(rng2, expected2)
  688: 
  689:         rng3 = date_range("2014", "2020", freq="YE", tz=tz)
  690:         expected3 = date_range("2014-12-31", "2019-12-31", freq="YE", tz=tz)
  691:         tm.assert_index_equal(rng3, expected3)
  692: 
  693:         rng4 = date_range("2014", "2020", freq="YS", tz=tz)
  694:         expected4 = date_range("2014-01-01", "2020-01-01", freq="YS", tz=tz)
  695:         tm.assert_index_equal(rng4, expected4)
  696: 
  697:     def test_freq_divides_end_in_nanos(self):
  698:         # GH 10885
  699:         result_1 = date_range("2005-01-12 10:00", "2005-01-12 16:00", freq="345min")
  700:         result_2 = date_range("2005-01-13 10:00", "2005-01-13 16:00", freq="345min")
  701:         expected_1 = DatetimeIndex(
  702:             ["2005-01-12 10:00:00", "2005-01-12 15:45:00"],
  703:             dtype="datetime64[ns]",
  704:             freq="345min",
  705:             tz=None,
  706:         )
  707:         expected_2 = DatetimeIndex(
  708:             ["2005-01-13 10:00:00", "2005-01-13 15:45:00"],
  709:             dtype="datetime64[ns]",
  710:             freq="345min",
  711:             tz=None,
  712:         )
  713:         tm.assert_index_equal(result_1, expected_1)
  714:         tm.assert_index_equal(result_2, expected_2)
  715: 
  716:     def test_cached_range_bug(self):
  717:         rng = date_range("2010-09-01 05:00:00", periods=50, freq=DateOffset(hours=6))
  718:         assert len(rng) == 50
  719:         assert rng[0] == datetime(2010, 9, 1, 5)
  720: 
  721:     def test_timezone_comparison_bug(self):
  722:         # smoke test
  723:         start = Timestamp("20130220 10:00", tz="US/Eastern")
  724:         result = date_range(start, periods=2, tz="US/Eastern")
  725:         assert len(result) == 2
  726: 
  727:     def test_timezone_comparison_assert(self):
  728:         start = Timestamp("20130220 10:00", tz="US/Eastern")
  729:         msg = "Inferred time zone not equal to passed time zone"
  730:         with pytest.raises(AssertionError, match=msg):
  731:             date_range(start, periods=2, tz="Europe/Berlin")
  732: 
  733:     def test_negative_non_tick_frequency_descending_dates(self, tz_aware_fixture):
  734:         # GH 23270
  735:         tz = tz_aware_fixture
  736:         result = date_range(start="2011-06-01", end="2011-01-01", freq="-1MS", tz=tz)
  737:         expected = date_range(end="2011-06-01", start="2011-01-01", freq="1MS", tz=tz)[
  738:             ::-1
  739:         ]
  740:         tm.assert_index_equal(result, expected)
  741: 
  742:     def test_range_where_start_equal_end(self, inclusive_endpoints_fixture):
  743:         # GH 43394
  744:         start = "2021-09-02"
  745:         end = "2021-09-02"
  746:         result = date_range(
  747:             start=start, end=end, freq="D", inclusive=inclusive_endpoints_fixture
  748:         )
  749: 
  750:         both_range = date_range(start=start, end=end, freq="D", inclusive="both")
  751:         if inclusive_endpoints_fixture == "neither":
  752:             expected = both_range[1:-1]
  753:         elif inclusive_endpoints_fixture in ("left", "right", "both"):
  754:             expected = both_range[:]
  755: 
  756:         tm.assert_index_equal(result, expected)
  757: 
  758:     def test_freq_dateoffset_with_relateivedelta_nanos(self):
  759:         # GH 46877
  760:         freq = DateOffset(hours=10, days=57, nanoseconds=3)
  761:         result = date_range(end="1970-01-01 00:00:00", periods=10, freq=freq, name="a")
  762:         expected = DatetimeIndex(
  763:             [
  764:                 "1968-08-02T05:59:59.999999973",
  765:                 "1968-09-28T15:59:59.999999976",
  766:                 "1968-11-25T01:59:59.999999979",
  767:                 "1969-01-21T11:59:59.999999982",
  768:                 "1969-03-19T21:59:59.999999985",
  769:                 "1969-05-16T07:59:59.999999988",
  770:                 "1969-07-12T17:59:59.999999991",
  771:                 "1969-09-08T03:59:59.999999994",
  772:                 "1969-11-04T13:59:59.999999997",
  773:                 "1970-01-01T00:00:00.000000000",
  774:             ],
  775:             name="a",
  776:         )
  777:         tm.assert_index_equal(result, expected)
  778: 
  779:     @pytest.mark.parametrize(
  780:         "freq,freq_depr",
  781:         [
  782:             ("h", "H"),
  783:             ("2min", "2T"),
  784:             ("1s", "1S"),
  785:             ("2ms", "2L"),
  786:             ("1us", "1U"),
  787:             ("2ns", "2N"),
  788:         ],
  789:     )
  790:     def test_frequencies_H_T_S_L_U_N_deprecated(self, freq, freq_depr):
  791:         # GH#52536
  792:         freq_msg = re.split("[0-9]*", freq, maxsplit=1)[1]
  793:         freq_depr_msg = re.split("[0-9]*", freq_depr, maxsplit=1)[1]
  794:         msg = (
  795:             f"'{freq_depr_msg}' is deprecated and will be removed in a future version, "
  796:         )
  797:         f"please use '{freq_msg}' instead"
  798: 
  799:         expected = date_range("1/1/2000", periods=2, freq=freq)
  800:         with tm.assert_produces_warning(FutureWarning, match=msg):
  801:             result = date_range("1/1/2000", periods=2, freq=freq_depr)
  802:         tm.assert_index_equal(result, expected)
  803: 
  804:     @pytest.mark.parametrize(
  805:         "freq,freq_depr",
  806:         [
  807:             ("200YE", "200A"),
  808:             ("YE", "Y"),
  809:             ("2YE-MAY", "2A-MAY"),
  810:             ("YE-MAY", "Y-MAY"),
  811:         ],
  812:     )
  813:     def test_frequencies_A_deprecated_Y_renamed(self, freq, freq_depr):
  814:         # GH#9586, GH#54275
  815:         freq_msg = re.split("[0-9]*", freq, maxsplit=1)[1]
  816:         freq_depr_msg = re.split("[0-9]*", freq_depr, maxsplit=1)[1]
  817:         msg = f"'{freq_depr_msg}' is deprecated and will be removed "
  818:         f"in a future version, please use '{freq_msg}' instead."
  819: 
  820:         expected = date_range("1/1/2000", periods=2, freq=freq)
  821:         with tm.assert_produces_warning(FutureWarning, match=msg):
  822:             result = date_range("1/1/2000", periods=2, freq=freq_depr)
  823:         tm.assert_index_equal(result, expected)
  824: 
  825:     def test_to_offset_with_lowercase_deprecated_freq(self) -> None:
  826:         # https://github.com/pandas-dev/pandas/issues/56847
  827:         msg = (
  828:             "'m' is deprecated and will be removed in a future version, please use "
  829:             "'ME' instead."
  830:         )
  831:         with tm.assert_produces_warning(FutureWarning, match=msg):
  832:             result = date_range("2010-01-01", periods=2, freq="m")
  833:         expected = DatetimeIndex(["2010-01-31", "2010-02-28"], freq="ME")
  834:         tm.assert_index_equal(result, expected)
  835: 
  836:     def test_date_range_bday(self):
  837:         sdate = datetime(1999, 12, 25)
  838:         idx = date_range(start=sdate, freq="1B", periods=20)
  839:         assert len(idx) == 20
  840:         assert idx[0] == sdate + 0 * offsets.BDay()
  841:         assert idx.freq == "B"
  842: 
  843: 
  844: class TestDateRangeTZ:
  845:     """Tests for date_range with timezones"""
  846: 
  847:     def test_hongkong_tz_convert(self):
  848:         # GH#1673 smoke test
  849:         dr = date_range("2012-01-01", "2012-01-10", freq="D", tz="Hongkong")
  850: 
  851:         # it works!
  852:         dr.hour
  853: 
  854:     @pytest.mark.parametrize("tzstr", ["US/Eastern", "dateutil/US/Eastern"])
  855:     def test_date_range_span_dst_transition(self, tzstr):
  856:         # GH#1778
  857: 
  858:         # Standard -> Daylight Savings Time
  859:         dr = date_range("03/06/2012 00:00", periods=200, freq="W-FRI", tz="US/Eastern")
  860: 
  861:         assert (dr.hour == 0).all()
  862: 
  863:         dr = date_range("2012-11-02", periods=10, tz=tzstr)
  864:         result = dr.hour
  865:         expected = pd.Index([0] * 10, dtype="int32")
  866:         tm.assert_index_equal(result, expected)
  867: 
  868:     @pytest.mark.parametrize("tzstr", ["US/Eastern", "dateutil/US/Eastern"])
  869:     def test_date_range_timezone_str_argument(self, tzstr):
  870:         tz = timezones.maybe_get_tz(tzstr)
  871:         result = date_range("1/1/2000", periods=10, tz=tzstr)
  872:         expected = date_range("1/1/2000", periods=10, tz=tz)
  873: 
  874:         tm.assert_index_equal(result, expected)
  875: 
  876:     def test_date_range_with_fixed_tz(self):
  877:         off = FixedOffset(420, "+07:00")
  878:         start = datetime(2012, 3, 11, 5, 0, 0, tzinfo=off)
  879:         end = datetime(2012, 6, 11, 5, 0, 0, tzinfo=off)
  880:         rng = date_range(start=start, end=end)
  881:         assert off == rng.tz
  882: 
  883:         rng2 = date_range(start, periods=len(rng), tz=off)
  884:         tm.assert_index_equal(rng, rng2)
  885: 
  886:         rng3 = date_range("3/11/2012 05:00:00+07:00", "6/11/2012 05:00:00+07:00")
  887:         assert (rng.values == rng3.values).all()
  888: 
  889:     def test_date_range_with_fixedoffset_noname(self):
  890:         off = fixed_off_no_name
  891:         start = datetime(2012, 3, 11, 5, 0, 0, tzinfo=off)
  892:         end = datetime(2012, 6, 11, 5, 0, 0, tzinfo=off)
  893:         rng = date_range(start=start, end=end)
  894:         assert off == rng.tz
  895: 
  896:         idx = pd.Index([start, end])
  897:         assert off == idx.tz
  898: 
  899:     @pytest.mark.parametrize("tzstr", ["US/Eastern", "dateutil/US/Eastern"])
  900:     def test_date_range_with_tz(self, tzstr):
  901:         stamp = Timestamp("3/11/2012 05:00", tz=tzstr)
  902:         assert stamp.hour == 5
  903: 
  904:         rng = date_range("3/11/2012 04:00", periods=10, freq="h", tz=tzstr)
  905: 
  906:         assert stamp == rng[1]
  907: 
  908:     @pytest.mark.parametrize("tz", ["Europe/London", "dateutil/Europe/London"])
  909:     def test_date_range_ambiguous_endpoint(self, tz):
  910:         # construction with an ambiguous end-point
  911:         # GH#11626
  912: 
  913:         with pytest.raises(pytz.AmbiguousTimeError, match="Cannot infer dst time"):
  914:             date_range(
  915:                 "2013-10-26 23:00", "2013-10-27 01:00", tz="Europe/London", freq="h"
  916:             )
  917: 
  918:         times = date_range(
  919:             "2013-10-26 23:00", "2013-10-27 01:00", freq="h", tz=tz, ambiguous="infer"
  920:         )
  921:         assert times[0] == Timestamp("2013-10-26 23:00", tz=tz)
  922:         assert times[-1] == Timestamp("2013-10-27 01:00:00+0000", tz=tz)
  923: 
  924:     @pytest.mark.parametrize(
  925:         "tz, option, expected",
  926:         [
  927:             ["US/Pacific", "shift_forward", "2019-03-10 03:00"],
  928:             ["dateutil/US/Pacific", "shift_forward", "2019-03-10 03:00"],
  929:             ["US/Pacific", "shift_backward", "2019-03-10 01:00"],
  930:             ["dateutil/US/Pacific", "shift_backward", "2019-03-10 01:00"],
  931:             ["US/Pacific", timedelta(hours=1), "2019-03-10 03:00"],
  932:         ],
  933:     )
  934:     def test_date_range_nonexistent_endpoint(self, tz, option, expected):
  935:         # construction with an nonexistent end-point
  936: 
  937:         with pytest.raises(pytz.NonExistentTimeError, match="2019-03-10 02:00:00"):
  938:             date_range(
  939:                 "2019-03-10 00:00", "2019-03-10 02:00", tz="US/Pacific", freq="h"
  940:             )
  941: 
  942:         times = date_range(
  943:             "2019-03-10 00:00", "2019-03-10 02:00", freq="h", tz=tz, nonexistent=option
  944:         )
  945:         assert times[-1] == Timestamp(expected, tz=tz)
  946: 
  947: 
  948: class TestGenRangeGeneration:
  949:     @pytest.mark.parametrize(
  950:         "freqstr,offset",
  951:         [
  952:             ("B", BDay()),
  953:             ("C", CDay()),
  954:         ],
  955:     )
  956:     def test_generate(self, freqstr, offset):
  957:         rng1 = list(generate_range(START, END, periods=None, offset=offset, unit="ns"))
  958:         rng2 = list(generate_range(START, END, periods=None, offset=freqstr, unit="ns"))
  959:         assert rng1 == rng2
  960: 
  961:     def test_1(self):
  962:         rng = list(
  963:             generate_range(
  964:                 start=datetime(2009, 3, 25),
  965:                 end=None,
  966:                 periods=2,
  967:                 offset=BDay(),
  968:                 unit="ns",
  969:             )
  970:         )
  971:         expected = [datetime(2009, 3, 25), datetime(2009, 3, 26)]
  972:         assert rng == expected
  973: 
  974:     def test_2(self):
  975:         rng = list(
  976:             generate_range(
  977:                 start=datetime(2008, 1, 1),
  978:                 end=datetime(2008, 1, 3),
  979:                 periods=None,
  980:                 offset=BDay(),
  981:                 unit="ns",
  982:             )
  983:         )
  984:         expected = [datetime(2008, 1, 1), datetime(2008, 1, 2), datetime(2008, 1, 3)]
  985:         assert rng == expected
  986: 
  987:     def test_3(self):
  988:         rng = list(
  989:             generate_range(
  990:                 start=datetime(2008, 1, 5),
  991:                 end=datetime(2008, 1, 6),
  992:                 periods=None,
  993:                 offset=BDay(),
  994:                 unit="ns",
  995:             )
  996:         )
  997:         expected = []
  998:         assert rng == expected
  999: 
 1000:     def test_precision_finer_than_offset(self):
 1001:         # GH#9907
 1002:         result1 = date_range(
 1003:             start="2015-04-15 00:00:03", end="2016-04-22 00:00:00", freq="QE"
 1004:         )
 1005:         result2 = date_range(
 1006:             start="2015-04-15 00:00:03", end="2015-06-22 00:00:04", freq="W"
 1007:         )
 1008:         expected1_list = [
 1009:             "2015-06-30 00:00:03",
 1010:             "2015-09-30 00:00:03",
 1011:             "2015-12-31 00:00:03",
 1012:             "2016-03-31 00:00:03",
 1013:         ]
 1014:         expected2_list = [
 1015:             "2015-04-19 00:00:03",
 1016:             "2015-04-26 00:00:03",
 1017:             "2015-05-03 00:00:03",
 1018:             "2015-05-10 00:00:03",
 1019:             "2015-05-17 00:00:03",
 1020:             "2015-05-24 00:00:03",
 1021:             "2015-05-31 00:00:03",
 1022:             "2015-06-07 00:00:03",
 1023:             "2015-06-14 00:00:03",
 1024:             "2015-06-21 00:00:03",
 1025:         ]
 1026:         expected1 = DatetimeIndex(
 1027:             expected1_list, dtype="datetime64[ns]", freq="QE-DEC", tz=None
 1028:         )
 1029:         expected2 = DatetimeIndex(
 1030:             expected2_list, dtype="datetime64[ns]", freq="W-SUN", tz=None
 1031:         )
 1032:         tm.assert_index_equal(result1, expected1)
 1033:         tm.assert_index_equal(result2, expected2)
 1034: 
 1035:     dt1, dt2 = "2017-01-01", "2017-01-01"
 1036:     tz1, tz2 = "US/Eastern", "Europe/London"
 1037: 
 1038:     @pytest.mark.parametrize(
 1039:         "start,end",
 1040:         [
 1041:             (Timestamp(dt1, tz=tz1), Timestamp(dt2)),
 1042:             (Timestamp(dt1), Timestamp(dt2, tz=tz2)),
 1043:             (Timestamp(dt1, tz=tz1), Timestamp(dt2, tz=tz2)),
 1044:             (Timestamp(dt1, tz=tz2), Timestamp(dt2, tz=tz1)),
 1045:         ],
 1046:     )
 1047:     def test_mismatching_tz_raises_err(self, start, end):
 1048:         # issue 18488
 1049:         msg = "Start and end cannot both be tz-aware with different timezones"
 1050:         with pytest.raises(TypeError, match=msg):
 1051:             date_range(start, end)
 1052:         with pytest.raises(TypeError, match=msg):
 1053:             date_range(start, end, freq=BDay())
 1054: 
 1055: 
 1056: class TestBusinessDateRange:
 1057:     def test_constructor(self):
 1058:         bdate_range(START, END, freq=BDay())
 1059:         bdate_range(START, periods=20, freq=BDay())
 1060:         bdate_range(end=START, periods=20, freq=BDay())
 1061: 
 1062:         msg = "periods must be a number, got B"
 1063:         with pytest.raises(TypeError, match=msg):
 1064:             date_range("2011-1-1", "2012-1-1", "B")
 1065: 
 1066:         with pytest.raises(TypeError, match=msg):
 1067:             bdate_range("2011-1-1", "2012-1-1", "B")
 1068: 
 1069:         msg = "freq must be specified for bdate_range; use date_range instead"
 1070:         with pytest.raises(TypeError, match=msg):
 1071:             bdate_range(START, END, periods=10, freq=None)
 1072: 
 1073:     def test_misc(self):
 1074:         end = datetime(2009, 5, 13)
 1075:         dr = bdate_range(end=end, periods=20)
 1076:         firstDate = end - 19 * BDay()
 1077: 
 1078:         assert len(dr) == 20
 1079:         assert dr[0] == firstDate
 1080:         assert dr[-1] == end
 1081: 
 1082:     def test_date_parse_failure(self):
 1083:         badly_formed_date = "2007/100/1"
 1084: 
 1085:         msg = "Unknown datetime string format, unable to parse: 2007/100/1"
 1086:         with pytest.raises(ValueError, match=msg):
 1087:             Timestamp(badly_formed_date)
 1088: 
 1089:         with pytest.raises(ValueError, match=msg):
 1090:             bdate_range(start=badly_formed_date, periods=10)
 1091: 
 1092:         with pytest.raises(ValueError, match=msg):
 1093:             bdate_range(end=badly_formed_date, periods=10)
 1094: 
 1095:         with pytest.raises(ValueError, match=msg):
 1096:             bdate_range(badly_formed_date, badly_formed_date)
 1097: 
 1098:     def test_daterange_bug_456(self):
 1099:         # GH #456
 1100:         rng1 = bdate_range("12/5/2011", "12/5/2011")
 1101:         rng2 = bdate_range("12/2/2011", "12/5/2011")
 1102:         assert rng2._data.freq == BDay()
 1103: 
 1104:         result = rng1.union(rng2)
 1105:         assert isinstance(result, DatetimeIndex)
 1106: 
 1107:     @pytest.mark.parametrize("inclusive", ["left", "right", "neither", "both"])
 1108:     def test_bdays_and_open_boundaries(self, inclusive):
 1109:         # GH 6673
 1110:         start = "2018-07-21"  # Saturday
 1111:         end = "2018-07-29"  # Sunday
 1112:         result = date_range(start, end, freq="B", inclusive=inclusive)
 1113: 
 1114:         bday_start = "2018-07-23"  # Monday
 1115:         bday_end = "2018-07-27"  # Friday
 1116:         expected = date_range(bday_start, bday_end, freq="D")
 1117:         tm.assert_index_equal(result, expected)
 1118:         # Note: we do _not_ expect the freqs to match here
 1119: 
 1120:     def test_bday_near_overflow(self):
 1121:         # GH#24252 avoid doing unnecessary addition that _would_ overflow
 1122:         start = Timestamp.max.floor("D").to_pydatetime()
 1123:         rng = date_range(start, end=None, periods=1, freq="B")
 1124:         expected = DatetimeIndex([start], freq="B").as_unit("ns")
 1125:         tm.assert_index_equal(rng, expected)
 1126: 
 1127:     def test_bday_overflow_error(self):
 1128:         # GH#24252 check that we get OutOfBoundsDatetime and not OverflowError
 1129:         msg = "Out of bounds nanosecond timestamp"
 1130:         start = Timestamp.max.floor("D").to_pydatetime()
 1131:         with pytest.raises(OutOfBoundsDatetime, match=msg):
 1132:             date_range(start, periods=2, freq="B")
 1133: 
 1134: 
 1135: class TestCustomDateRange:
 1136:     def test_constructor(self):
 1137:         bdate_range(START, END, freq=CDay())
 1138:         bdate_range(START, periods=20, freq=CDay())
 1139:         bdate_range(end=START, periods=20, freq=CDay())
 1140: 
 1141:         msg = "periods must be a number, got C"
 1142:         with pytest.raises(TypeError, match=msg):
 1143:             date_range("2011-1-1", "2012-1-1", "C")
 1144: 
 1145:         with pytest.raises(TypeError, match=msg):
 1146:             bdate_range("2011-1-1", "2012-1-1", "C")
 1147: 
 1148:     def test_misc(self):
 1149:         end = datetime(2009, 5, 13)
 1150:         dr = bdate_range(end=end, periods=20, freq="C")
 1151:         firstDate = end - 19 * CDay()
 1152: 
 1153:         assert len(dr) == 20
 1154:         assert dr[0] == firstDate
 1155:         assert dr[-1] == end
 1156: 
 1157:     def test_daterange_bug_456(self):
 1158:         # GH #456
 1159:         rng1 = bdate_range("12/5/2011", "12/5/2011", freq="C")
 1160:         rng2 = bdate_range("12/2/2011", "12/5/2011", freq="C")
 1161:         assert rng2._data.freq == CDay()
 1162: 
 1163:         result = rng1.union(rng2)
 1164:         assert isinstance(result, DatetimeIndex)
 1165: 
 1166:     def test_cdaterange(self, unit):
 1167:         result = bdate_range("2013-05-01", periods=3, freq="C", unit=unit)
 1168:         expected = DatetimeIndex(
 1169:             ["2013-05-01", "2013-05-02", "2013-05-03"], dtype=f"M8[{unit}]", freq="C"
 1170:         )
 1171:         tm.assert_index_equal(result, expected)
 1172:         assert result.freq == expected.freq
 1173: 
 1174:     def test_cdaterange_weekmask(self, unit):
 1175:         result = bdate_range(
 1176:             "2013-05-01", periods=3, freq="C", weekmask="Sun Mon Tue Wed Thu", unit=unit
 1177:         )
 1178:         expected = DatetimeIndex(
 1179:             ["2013-05-01", "2013-05-02", "2013-05-05"],
 1180:             dtype=f"M8[{unit}]",
 1181:             freq=result.freq,
 1182:         )
 1183:         tm.assert_index_equal(result, expected)
 1184:         assert result.freq == expected.freq
 1185: 
 1186:         # raise with non-custom freq
 1187:         msg = (
 1188:             "a custom frequency string is required when holidays or "
 1189:             "weekmask are passed, got frequency B"
 1190:         )
 1191:         with pytest.raises(ValueError, match=msg):
 1192:             bdate_range("2013-05-01", periods=3, weekmask="Sun Mon Tue Wed Thu")
 1193: 
 1194:     def test_cdaterange_holidays(self, unit):
 1195:         result = bdate_range(
 1196:             "2013-05-01", periods=3, freq="C", holidays=["2013-05-01"], unit=unit
 1197:         )
 1198:         expected = DatetimeIndex(
 1199:             ["2013-05-02", "2013-05-03", "2013-05-06"],
 1200:             dtype=f"M8[{unit}]",
 1201:             freq=result.freq,
 1202:         )
 1203:         tm.assert_index_equal(result, expected)
 1204:         assert result.freq == expected.freq
 1205: 
 1206:         # raise with non-custom freq
 1207:         msg = (
 1208:             "a custom frequency string is required when holidays or "
 1209:             "weekmask are passed, got frequency B"
 1210:         )
 1211:         with pytest.raises(ValueError, match=msg):
 1212:             bdate_range("2013-05-01", periods=3, holidays=["2013-05-01"])
 1213: 
 1214:     def test_cdaterange_weekmask_and_holidays(self, unit):
 1215:         result = bdate_range(
 1216:             "2013-05-01",
 1217:             periods=3,
 1218:             freq="C",
 1219:             weekmask="Sun Mon Tue Wed Thu",
 1220:             holidays=["2013-05-01"],
 1221:             unit=unit,
 1222:         )
 1223:         expected = DatetimeIndex(
 1224:             ["2013-05-02", "2013-05-05", "2013-05-06"],
 1225:             dtype=f"M8[{unit}]",
 1226:             freq=result.freq,
 1227:         )
 1228:         tm.assert_index_equal(result, expected)
 1229:         assert result.freq == expected.freq
 1230: 
 1231:     def test_cdaterange_holidays_weekmask_requires_freqstr(self):
 1232:         # raise with non-custom freq
 1233:         msg = (
 1234:             "a custom frequency string is required when holidays or "
 1235:             "weekmask are passed, got frequency B"
 1236:         )
 1237:         with pytest.raises(ValueError, match=msg):
 1238:             bdate_range(
 1239:                 "2013-05-01",
 1240:                 periods=3,
 1241:                 weekmask="Sun Mon Tue Wed Thu",
 1242:                 holidays=["2013-05-01"],
 1243:             )
 1244: 
 1245:     @pytest.mark.parametrize(
 1246:         "freq", [freq for freq in prefix_mapping if freq.startswith("C")]
 1247:     )
 1248:     def test_all_custom_freq(self, freq):
 1249:         # should not raise
 1250:         bdate_range(
 1251:             START, END, freq=freq, weekmask="Mon Wed Fri", holidays=["2009-03-14"]
 1252:         )
 1253: 
 1254:         bad_freq = freq + "FOO"
 1255:         msg = f"invalid custom frequency string: {bad_freq}"
 1256:         with pytest.raises(ValueError, match=msg):
 1257:             bdate_range(START, END, freq=bad_freq)
 1258: 
 1259:     @pytest.mark.parametrize(
 1260:         "start_end",
 1261:         [
 1262:             ("2018-01-01T00:00:01.000Z", "2018-01-03T00:00:01.000Z"),
 1263:             ("2018-01-01T00:00:00.010Z", "2018-01-03T00:00:00.010Z"),
 1264:             ("2001-01-01T00:00:00.010Z", "2001-01-03T00:00:00.010Z"),
 1265:         ],
 1266:     )
 1267:     def test_range_with_millisecond_resolution(self, start_end):
 1268:         # https://github.com/pandas-dev/pandas/issues/24110
 1269:         start, end = start_end
 1270:         result = date_range(start=start, end=end, periods=2, inclusive="left")
 1271:         expected = DatetimeIndex([start], dtype="M8[ns, UTC]")
 1272:         tm.assert_index_equal(result, expected)
 1273: 
 1274:     @pytest.mark.parametrize(
 1275:         "start,period,expected",
 1276:         [
 1277:             ("2022-07-23 00:00:00+02:00", 1, ["2022-07-25 00:00:00+02:00"]),
 1278:             ("2022-07-22 00:00:00+02:00", 1, ["2022-07-22 00:00:00+02:00"]),
 1279:             (
 1280:                 "2022-07-22 00:00:00+02:00",
 1281:                 2,
 1282:                 ["2022-07-22 00:00:00+02:00", "2022-07-25 00:00:00+02:00"],
 1283:             ),
 1284:         ],
 1285:     )
 1286:     def test_range_with_timezone_and_custombusinessday(self, start, period, expected):
 1287:         # GH49441
 1288:         result = date_range(start=start, periods=period, freq="C")
 1289:         expected = DatetimeIndex(expected).as_unit("ns")
 1290:         tm.assert_index_equal(result, expected)
 1291: 
 1292: 
 1293: class TestDateRangeNonNano:
 1294:     def test_date_range_reso_validation(self):
 1295:         msg = "'unit' must be one of 's', 'ms', 'us', 'ns'"
 1296:         with pytest.raises(ValueError, match=msg):
 1297:             date_range("2016-01-01", "2016-03-04", periods=3, unit="h")
 1298: 
 1299:     def test_date_range_freq_higher_than_reso(self):
 1300:         # freq being higher-resolution than reso is a problem
 1301:         msg = "Use a lower freq or a higher unit instead"
 1302:         with pytest.raises(ValueError, match=msg):
 1303:             #    # TODO give a more useful or informative message?
 1304:             date_range("2016-01-01", "2016-01-02", freq="ns", unit="ms")
 1305: 
 1306:     def test_date_range_freq_matches_reso(self):
 1307:         # GH#49106 matching reso is OK
 1308:         dti = date_range("2016-01-01", "2016-01-01 00:00:01", freq="ms", unit="ms")
 1309:         rng = np.arange(1_451_606_400_000, 1_451_606_401_001, dtype=np.int64)
 1310:         expected = DatetimeIndex(rng.view("M8[ms]"), freq="ms")
 1311:         tm.assert_index_equal(dti, expected)
 1312: 
 1313:         dti = date_range("2016-01-01", "2016-01-01 00:00:01", freq="us", unit="us")
 1314:         rng = np.arange(1_451_606_400_000_000, 1_451_606_401_000_001, dtype=np.int64)
 1315:         expected = DatetimeIndex(rng.view("M8[us]"), freq="us")
 1316:         tm.assert_index_equal(dti, expected)
 1317: 
 1318:         dti = date_range("2016-01-01", "2016-01-01 00:00:00.001", freq="ns", unit="ns")
 1319:         rng = np.arange(
 1320:             1_451_606_400_000_000_000, 1_451_606_400_001_000_001, dtype=np.int64
 1321:         )
 1322:         expected = DatetimeIndex(rng.view("M8[ns]"), freq="ns")
 1323:         tm.assert_index_equal(dti, expected)
 1324: 
 1325:     def test_date_range_freq_lower_than_endpoints(self):
 1326:         start = Timestamp("2022-10-19 11:50:44.719781")
 1327:         end = Timestamp("2022-10-19 11:50:47.066458")
 1328: 
 1329:         # start and end cannot be cast to "s" unit without lossy rounding,
 1330:         #  so we do not allow this in date_range
 1331:         with pytest.raises(ValueError, match="Cannot losslessly convert units"):
 1332:             date_range(start, end, periods=3, unit="s")
 1333: 
 1334:         # but we can losslessly cast to "us"
 1335:         dti = date_range(start, end, periods=2, unit="us")
 1336:         rng = np.array(
 1337:             [start.as_unit("us")._value, end.as_unit("us")._value], dtype=np.int64
 1338:         )
 1339:         expected = DatetimeIndex(rng.view("M8[us]"))
 1340:         tm.assert_index_equal(dti, expected)
 1341: 
 1342:     def test_date_range_non_nano(self):
 1343:         start = np.datetime64("1066-10-14")  # Battle of Hastings
 1344:         end = np.datetime64("2305-07-13")  # Jean-Luc Picard's birthday
 1345: 
 1346:         dti = date_range(start, end, freq="D", unit="s")
 1347:         assert dti.freq == "D"
 1348:         assert dti.dtype == "M8[s]"
 1349: 
 1350:         exp = np.arange(
 1351:             start.astype("M8[s]").view("i8"),
 1352:             (end + 1).astype("M8[s]").view("i8"),
 1353:             24 * 3600,
 1354:         ).view("M8[s]")
 1355: 
 1356:         tm.assert_numpy_array_equal(dti.to_numpy(), exp)
 1357: 
 1358: 
 1359: class TestDateRangeNonTickFreq:
 1360:     # Tests revolving around less-common (non-Tick) `freq` keywords.
 1361: 
 1362:     def test_date_range_custom_business_month_begin(self, unit):
 1363:         hcal = USFederalHolidayCalendar()
 1364:         freq = offsets.CBMonthBegin(calendar=hcal)
 1365:         dti = date_range(start="20120101", end="20130101", freq=freq, unit=unit)
 1366:         assert all(freq.is_on_offset(x) for x in dti)
 1367: 
 1368:         expected = DatetimeIndex(
 1369:             [
 1370:                 "2012-01-03",
 1371:                 "2012-02-01",
 1372:                 "2012-03-01",
 1373:                 "2012-04-02",
 1374:                 "2012-05-01",
 1375:                 "2012-06-01",
 1376:                 "2012-07-02",
 1377:                 "2012-08-01",
 1378:                 "2012-09-04",
 1379:                 "2012-10-01",
 1380:                 "2012-11-01",
 1381:                 "2012-12-03",
 1382:             ],
 1383:             dtype=f"M8[{unit}]",
 1384:             freq=freq,
 1385:         )
 1386:         tm.assert_index_equal(dti, expected)
 1387: 
 1388:     def test_date_range_custom_business_month_end(self, unit):
 1389:         hcal = USFederalHolidayCalendar()
 1390:         freq = offsets.CBMonthEnd(calendar=hcal)
 1391:         dti = date_range(start="20120101", end="20130101", freq=freq, unit=unit)
 1392:         assert all(freq.is_on_offset(x) for x in dti)
 1393: 
 1394:         expected = DatetimeIndex(
 1395:             [
 1396:                 "2012-01-31",
 1397:                 "2012-02-29",
 1398:                 "2012-03-30",
 1399:                 "2012-04-30",
 1400:                 "2012-05-31",
 1401:                 "2012-06-29",
 1402:                 "2012-07-31",
 1403:                 "2012-08-31",
 1404:                 "2012-09-28",
 1405:                 "2012-10-31",
 1406:                 "2012-11-30",
 1407:                 "2012-12-31",
 1408:             ],
 1409:             dtype=f"M8[{unit}]",
 1410:             freq=freq,
 1411:         )
 1412:         tm.assert_index_equal(dti, expected)
 1413: 
 1414:     def test_date_range_with_custom_holidays(self, unit):
 1415:         # GH#30593
 1416:         freq = offsets.CustomBusinessHour(start="15:00", holidays=["2020-11-26"])
 1417:         result = date_range(start="2020-11-25 15:00", periods=4, freq=freq, unit=unit)
 1418:         expected = DatetimeIndex(
 1419:             [
 1420:                 "2020-11-25 15:00:00",
 1421:                 "2020-11-25 16:00:00",
 1422:                 "2020-11-27 15:00:00",
 1423:                 "2020-11-27 16:00:00",
 1424:             ],
 1425:             dtype=f"M8[{unit}]",
 1426:             freq=freq,
 1427:         )
 1428:         tm.assert_index_equal(result, expected)
 1429: 
 1430:     def test_date_range_businesshour(self, unit):
 1431:         idx = DatetimeIndex(
 1432:             [
 1433:                 "2014-07-04 09:00",
 1434:                 "2014-07-04 10:00",
 1435:                 "2014-07-04 11:00",
 1436:                 "2014-07-04 12:00",
 1437:                 "2014-07-04 13:00",
 1438:                 "2014-07-04 14:00",
 1439:                 "2014-07-04 15:00",
 1440:                 "2014-07-04 16:00",
 1441:             ],
 1442:             dtype=f"M8[{unit}]",
 1443:             freq="bh",
 1444:         )
 1445:         rng = date_range("2014-07-04 09:00", "2014-07-04 16:00", freq="bh", unit=unit)
 1446:         tm.assert_index_equal(idx, rng)
 1447: 
 1448:         idx = DatetimeIndex(
 1449:             ["2014-07-04 16:00", "2014-07-07 09:00"], dtype=f"M8[{unit}]", freq="bh"
 1450:         )
 1451:         rng = date_range("2014-07-04 16:00", "2014-07-07 09:00", freq="bh", unit=unit)
 1452:         tm.assert_index_equal(idx, rng)
 1453: 
 1454:         idx = DatetimeIndex(
 1455:             [
 1456:                 "2014-07-04 09:00",
 1457:                 "2014-07-04 10:00",
 1458:                 "2014-07-04 11:00",
 1459:                 "2014-07-04 12:00",
 1460:                 "2014-07-04 13:00",
 1461:                 "2014-07-04 14:00",
 1462:                 "2014-07-04 15:00",
 1463:                 "2014-07-04 16:00",
 1464:                 "2014-07-07 09:00",
 1465:                 "2014-07-07 10:00",
 1466:                 "2014-07-07 11:00",
 1467:                 "2014-07-07 12:00",
 1468:                 "2014-07-07 13:00",
 1469:                 "2014-07-07 14:00",
 1470:                 "2014-07-07 15:00",
 1471:                 "2014-07-07 16:00",
 1472:                 "2014-07-08 09:00",
 1473:                 "2014-07-08 10:00",
 1474:                 "2014-07-08 11:00",
 1475:                 "2014-07-08 12:00",
 1476:                 "2014-07-08 13:00",
 1477:                 "2014-07-08 14:00",
 1478:                 "2014-07-08 15:00",
 1479:                 "2014-07-08 16:00",
 1480:             ],
 1481:             dtype=f"M8[{unit}]",
 1482:             freq="bh",
 1483:         )
 1484:         rng = date_range("2014-07-04 09:00", "2014-07-08 16:00", freq="bh", unit=unit)
 1485:         tm.assert_index_equal(idx, rng)
 1486: 
 1487:     def test_date_range_business_hour2(self, unit):
 1488:         idx1 = date_range(
 1489:             start="2014-07-04 15:00", end="2014-07-08 10:00", freq="bh", unit=unit
 1490:         )
 1491:         idx2 = date_range(start="2014-07-04 15:00", periods=12, freq="bh", unit=unit)
 1492:         idx3 = date_range(end="2014-07-08 10:00", periods=12, freq="bh", unit=unit)
 1493:         expected = DatetimeIndex(
 1494:             [
 1495:                 "2014-07-04 15:00",
 1496:                 "2014-07-04 16:00",
 1497:                 "2014-07-07 09:00",
 1498:                 "2014-07-07 10:00",
 1499:                 "2014-07-07 11:00",
 1500:                 "2014-07-07 12:00",
 1501:                 "2014-07-07 13:00",
 1502:                 "2014-07-07 14:00",
 1503:                 "2014-07-07 15:00",
 1504:                 "2014-07-07 16:00",
 1505:                 "2014-07-08 09:00",
 1506:                 "2014-07-08 10:00",
 1507:             ],
 1508:             dtype=f"M8[{unit}]",
 1509:             freq="bh",
 1510:         )
 1511:         tm.assert_index_equal(idx1, expected)
 1512:         tm.assert_index_equal(idx2, expected)
 1513:         tm.assert_index_equal(idx3, expected)
 1514: 
 1515:         idx4 = date_range(
 1516:             start="2014-07-04 15:45", end="2014-07-08 10:45", freq="bh", unit=unit
 1517:         )
 1518:         idx5 = date_range(start="2014-07-04 15:45", periods=12, freq="bh", unit=unit)
 1519:         idx6 = date_range(end="2014-07-08 10:45", periods=12, freq="bh", unit=unit)
 1520: 
 1521:         expected2 = expected + Timedelta(minutes=45).as_unit(unit)
 1522:         expected2.freq = "bh"
 1523:         tm.assert_index_equal(idx4, expected2)
 1524:         tm.assert_index_equal(idx5, expected2)
 1525:         tm.assert_index_equal(idx6, expected2)
 1526: 
 1527:     def test_date_range_business_hour_short(self, unit):
 1528:         # GH#49835
 1529:         idx4 = date_range(start="2014-07-01 10:00", freq="bh", periods=1, unit=unit)
 1530:         expected4 = DatetimeIndex(["2014-07-01 10:00"], dtype=f"M8[{unit}]", freq="bh")
 1531:         tm.assert_index_equal(idx4, expected4)
 1532: 
 1533:     def test_date_range_year_start(self, unit):
 1534:         # see GH#9313
 1535:         rng = date_range("1/1/2013", "7/1/2017", freq="YS", unit=unit)
 1536:         exp = DatetimeIndex(
 1537:             ["2013-01-01", "2014-01-01", "2015-01-01", "2016-01-01", "2017-01-01"],
 1538:             dtype=f"M8[{unit}]",
 1539:             freq="YS",
 1540:         )
 1541:         tm.assert_index_equal(rng, exp)
 1542: 
 1543:     def test_date_range_year_end(self, unit):
 1544:         # see GH#9313
 1545:         rng = date_range("1/1/2013", "7/1/2017", freq="YE", unit=unit)
 1546:         exp = DatetimeIndex(
 1547:             ["2013-12-31", "2014-12-31", "2015-12-31", "2016-12-31"],
 1548:             dtype=f"M8[{unit}]",
 1549:             freq="YE",
 1550:         )
 1551:         tm.assert_index_equal(rng, exp)
 1552: 
 1553:     def test_date_range_negative_freq_year_end(self, unit):
 1554:         # GH#11018
 1555:         rng = date_range("2011-12-31", freq="-2YE", periods=3, unit=unit)
 1556:         exp = DatetimeIndex(
 1557:             ["2011-12-31", "2009-12-31", "2007-12-31"], dtype=f"M8[{unit}]", freq="-2YE"
 1558:         )
 1559:         tm.assert_index_equal(rng, exp)
 1560:         assert rng.freq == "-2YE"
 1561: 
 1562:     def test_date_range_business_year_end_year(self, unit):
 1563:         # see GH#9313
 1564:         rng = date_range("1/1/2013", "7/1/2017", freq="BYE", unit=unit)
 1565:         exp = DatetimeIndex(
 1566:             ["2013-12-31", "2014-12-31", "2015-12-31", "2016-12-30"],
 1567:             dtype=f"M8[{unit}]",
 1568:             freq="BYE",
 1569:         )
 1570:         tm.assert_index_equal(rng, exp)
 1571: 
 1572:     def test_date_range_bms(self, unit):
 1573:         # GH#1645
 1574:         result = date_range("1/1/2000", periods=10, freq="BMS", unit=unit)
 1575: 
 1576:         expected = DatetimeIndex(
 1577:             [
 1578:                 "2000-01-03",
 1579:                 "2000-02-01",
 1580:                 "2000-03-01",
 1581:                 "2000-04-03",
 1582:                 "2000-05-01",
 1583:                 "2000-06-01",
 1584:                 "2000-07-03",
 1585:                 "2000-08-01",
 1586:                 "2000-09-01",
 1587:                 "2000-10-02",
 1588:             ],
 1589:             dtype=f"M8[{unit}]",
 1590:             freq="BMS",
 1591:         )
 1592:         tm.assert_index_equal(result, expected)
 1593: 
 1594:     def test_date_range_semi_month_begin(self, unit):
 1595:         dates = [
 1596:             datetime(2007, 12, 15),
 1597:             datetime(2008, 1, 1),
 1598:             datetime(2008, 1, 15),
 1599:             datetime(2008, 2, 1),
 1600:             datetime(2008, 2, 15),
 1601:             datetime(2008, 3, 1),
 1602:             datetime(2008, 3, 15),
 1603:             datetime(2008, 4, 1),
 1604:             datetime(2008, 4, 15),
 1605:             datetime(2008, 5, 1),
 1606:             datetime(2008, 5, 15),
 1607:             datetime(2008, 6, 1),
 1608:             datetime(2008, 6, 15),
 1609:             datetime(2008, 7, 1),
 1610:             datetime(2008, 7, 15),
 1611:             datetime(2008, 8, 1),
 1612:             datetime(2008, 8, 15),
 1613:             datetime(2008, 9, 1),
 1614:             datetime(2008, 9, 15),
 1615:             datetime(2008, 10, 1),
 1616:             datetime(2008, 10, 15),
 1617:             datetime(2008, 11, 1),
 1618:             datetime(2008, 11, 15),
 1619:             datetime(2008, 12, 1),
 1620:             datetime(2008, 12, 15),
 1621:         ]
 1622:         # ensure generating a range with DatetimeIndex gives same result
 1623:         result = date_range(start=dates[0], end=dates[-1], freq="SMS", unit=unit)
 1624:         exp = DatetimeIndex(dates, dtype=f"M8[{unit}]", freq="SMS")
 1625:         tm.assert_index_equal(result, exp)
 1626: 
 1627:     def test_date_range_semi_month_end(self, unit):
 1628:         dates = [
 1629:             datetime(2007, 12, 31),
 1630:             datetime(2008, 1, 15),
 1631:             datetime(2008, 1, 31),
 1632:             datetime(2008, 2, 15),
 1633:             datetime(2008, 2, 29),
 1634:             datetime(2008, 3, 15),
 1635:             datetime(2008, 3, 31),
 1636:             datetime(2008, 4, 15),
 1637:             datetime(2008, 4, 30),
 1638:             datetime(2008, 5, 15),
 1639:             datetime(2008, 5, 31),
 1640:             datetime(2008, 6, 15),
 1641:             datetime(2008, 6, 30),
 1642:             datetime(2008, 7, 15),
 1643:             datetime(2008, 7, 31),
 1644:             datetime(2008, 8, 15),
 1645:             datetime(2008, 8, 31),
 1646:             datetime(2008, 9, 15),
 1647:             datetime(2008, 9, 30),
 1648:             datetime(2008, 10, 15),
 1649:             datetime(2008, 10, 31),
 1650:             datetime(2008, 11, 15),
 1651:             datetime(2008, 11, 30),
 1652:             datetime(2008, 12, 15),
 1653:             datetime(2008, 12, 31),
 1654:         ]
 1655:         # ensure generating a range with DatetimeIndex gives same result
 1656:         result = date_range(start=dates[0], end=dates[-1], freq="SME", unit=unit)
 1657:         exp = DatetimeIndex(dates, dtype=f"M8[{unit}]", freq="SME")
 1658:         tm.assert_index_equal(result, exp)
 1659: 
 1660:     def test_date_range_week_of_month(self, unit):
 1661:         # GH#20517
 1662:         # Note the start here is not on_offset for this freq
 1663:         result = date_range(start="20110101", periods=1, freq="WOM-1MON", unit=unit)
 1664:         expected = DatetimeIndex(["2011-01-03"], dtype=f"M8[{unit}]", freq="WOM-1MON")
 1665:         tm.assert_index_equal(result, expected)
 1666: 
 1667:         result2 = date_range(start="20110101", periods=2, freq="WOM-1MON", unit=unit)
 1668:         expected2 = DatetimeIndex(
 1669:             ["2011-01-03", "2011-02-07"], dtype=f"M8[{unit}]", freq="WOM-1MON"
 1670:         )
 1671:         tm.assert_index_equal(result2, expected2)
 1672: 
 1673:     def test_date_range_week_of_month2(self, unit):
 1674:         # GH#5115, GH#5348
 1675:         result = date_range("2013-1-1", periods=4, freq="WOM-1SAT", unit=unit)
 1676:         expected = DatetimeIndex(
 1677:             ["2013-01-05", "2013-02-02", "2013-03-02", "2013-04-06"],
 1678:             dtype=f"M8[{unit}]",
 1679:             freq="WOM-1SAT",
 1680:         )
 1681:         tm.assert_index_equal(result, expected)
 1682: 
 1683:     def test_date_range_negative_freq_month_end(self, unit):
 1684:         # GH#11018
 1685:         rng = date_range("2011-01-31", freq="-2ME", periods=3, unit=unit)
 1686:         exp = DatetimeIndex(
 1687:             ["2011-01-31", "2010-11-30", "2010-09-30"], dtype=f"M8[{unit}]", freq="-2ME"
 1688:         )
 1689:         tm.assert_index_equal(rng, exp)
 1690:         assert rng.freq == "-2ME"
 1691: 
 1692:     def test_date_range_fy5253(self, unit):
 1693:         freq = offsets.FY5253(startingMonth=1, weekday=3, variation="nearest")
 1694:         dti = date_range(
 1695:             start="2013-01-01",
 1696:             periods=2,
 1697:             freq=freq,
 1698:             unit=unit,
 1699:         )
 1700:         expected = DatetimeIndex(
 1701:             ["2013-01-31", "2014-01-30"], dtype=f"M8[{unit}]", freq=freq
 1702:         )
 1703: 
 1704:         tm.assert_index_equal(dti, expected)
 1705: 
 1706:     @pytest.mark.parametrize(
 1707:         "freqstr,offset",
 1708:         [
 1709:             ("QS", offsets.QuarterBegin(startingMonth=1)),
 1710:             ("BQE", offsets.BQuarterEnd(startingMonth=12)),
 1711:             ("W-SUN", offsets.Week(weekday=6)),
 1712:         ],
 1713:     )
 1714:     def test_date_range_freqstr_matches_offset(self, freqstr, offset):
 1715:         sdate = datetime(1999, 12, 25)
 1716:         edate = datetime(2000, 1, 1)
 1717: 
 1718:         idx1 = date_range(start=sdate, end=edate, freq=freqstr)
 1719:         idx2 = date_range(start=sdate, end=edate, freq=offset)
 1720:         assert len(idx1) == len(idx2)
 1721:         assert idx1.freq == idx2.freq
