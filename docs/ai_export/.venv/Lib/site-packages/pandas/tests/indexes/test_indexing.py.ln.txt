    1: """
    2: test_indexing tests the following Index methods:
    3:     __getitem__
    4:     get_loc
    5:     get_value
    6:     __contains__
    7:     take
    8:     where
    9:     get_indexer
   10:     get_indexer_for
   11:     slice_locs
   12:     asof_locs
   13: 
   14: The corresponding tests.indexes.[index_type].test_indexing files
   15: contain tests for the corresponding methods specific to those Index subclasses.
   16: """
   17: import numpy as np
   18: import pytest
   19: 
   20: from pandas.errors import InvalidIndexError
   21: 
   22: from pandas.core.dtypes.common import (
   23:     is_float_dtype,
   24:     is_scalar,
   25: )
   26: 
   27: from pandas import (
   28:     NA,
   29:     DatetimeIndex,
   30:     Index,
   31:     IntervalIndex,
   32:     MultiIndex,
   33:     NaT,
   34:     PeriodIndex,
   35:     TimedeltaIndex,
   36: )
   37: import pandas._testing as tm
   38: 
   39: 
   40: class TestTake:
   41:     def test_take_invalid_kwargs(self, index):
   42:         indices = [1, 2]
   43: 
   44:         msg = r"take\(\) got an unexpected keyword argument 'foo'"
   45:         with pytest.raises(TypeError, match=msg):
   46:             index.take(indices, foo=2)
   47: 
   48:         msg = "the 'out' parameter is not supported"
   49:         with pytest.raises(ValueError, match=msg):
   50:             index.take(indices, out=indices)
   51: 
   52:         msg = "the 'mode' parameter is not supported"
   53:         with pytest.raises(ValueError, match=msg):
   54:             index.take(indices, mode="clip")
   55: 
   56:     def test_take(self, index):
   57:         indexer = [4, 3, 0, 2]
   58:         if len(index) < 5:
   59:             pytest.skip("Test doesn't make sense since not enough elements")
   60: 
   61:         result = index.take(indexer)
   62:         expected = index[indexer]
   63:         assert result.equals(expected)
   64: 
   65:         if not isinstance(index, (DatetimeIndex, PeriodIndex, TimedeltaIndex)):
   66:             # GH 10791
   67:             msg = r"'(.*Index)' object has no attribute 'freq'"
   68:             with pytest.raises(AttributeError, match=msg):
   69:                 index.freq
   70: 
   71:     def test_take_indexer_type(self):
   72:         # GH#42875
   73:         integer_index = Index([0, 1, 2, 3])
   74:         scalar_index = 1
   75:         msg = "Expected indices to be array-like"
   76:         with pytest.raises(TypeError, match=msg):
   77:             integer_index.take(scalar_index)
   78: 
   79:     def test_take_minus1_without_fill(self, index):
   80:         # -1 does not get treated as NA unless allow_fill=True is passed
   81:         if len(index) == 0:
   82:             # Test is not applicable
   83:             pytest.skip("Test doesn't make sense for empty index")
   84: 
   85:         result = index.take([0, 0, -1])
   86: 
   87:         expected = index.take([0, 0, len(index) - 1])
   88:         tm.assert_index_equal(result, expected)
   89: 
   90: 
   91: class TestContains:
   92:     @pytest.mark.parametrize(
   93:         "index,val",
   94:         [
   95:             (Index([0, 1, 2]), 2),
   96:             (Index([0, 1, "2"]), "2"),
   97:             (Index([0, 1, 2, np.inf, 4]), 4),
   98:             (Index([0, 1, 2, np.nan, 4]), 4),
   99:             (Index([0, 1, 2, np.inf]), np.inf),
  100:             (Index([0, 1, 2, np.nan]), np.nan),
  101:         ],
  102:     )
  103:     def test_index_contains(self, index, val):
  104:         assert val in index
  105: 
  106:     @pytest.mark.parametrize(
  107:         "index,val",
  108:         [
  109:             (Index([0, 1, 2]), "2"),
  110:             (Index([0, 1, "2"]), 2),
  111:             (Index([0, 1, 2, np.inf]), 4),
  112:             (Index([0, 1, 2, np.nan]), 4),
  113:             (Index([0, 1, 2, np.inf]), np.nan),
  114:             (Index([0, 1, 2, np.nan]), np.inf),
  115:             # Checking if np.inf in int64 Index should not cause an OverflowError
  116:             # Related to GH 16957
  117:             (Index([0, 1, 2], dtype=np.int64), np.inf),
  118:             (Index([0, 1, 2], dtype=np.int64), np.nan),
  119:             (Index([0, 1, 2], dtype=np.uint64), np.inf),
  120:             (Index([0, 1, 2], dtype=np.uint64), np.nan),
  121:         ],
  122:     )
  123:     def test_index_not_contains(self, index, val):
  124:         assert val not in index
  125: 
  126:     @pytest.mark.parametrize(
  127:         "index,val", [(Index([0, 1, "2"]), 0), (Index([0, 1, "2"]), "2")]
  128:     )
  129:     def test_mixed_index_contains(self, index, val):
  130:         # GH#19860
  131:         assert val in index
  132: 
  133:     @pytest.mark.parametrize(
  134:         "index,val", [(Index([0, 1, "2"]), "1"), (Index([0, 1, "2"]), 2)]
  135:     )
  136:     def test_mixed_index_not_contains(self, index, val):
  137:         # GH#19860
  138:         assert val not in index
  139: 
  140:     def test_contains_with_float_index(self, any_real_numpy_dtype):
  141:         # GH#22085
  142:         dtype = any_real_numpy_dtype
  143:         data = [0, 1, 2, 3] if not is_float_dtype(dtype) else [0.1, 1.1, 2.2, 3.3]
  144:         index = Index(data, dtype=dtype)
  145: 
  146:         if not is_float_dtype(index.dtype):
  147:             assert 1.1 not in index
  148:             assert 1.0 in index
  149:             assert 1 in index
  150:         else:
  151:             assert 1.1 in index
  152:             assert 1.0 not in index
  153:             assert 1 not in index
  154: 
  155:     def test_contains_requires_hashable_raises(self, index):
  156:         if isinstance(index, MultiIndex):
  157:             return  # TODO: do we want this to raise?
  158: 
  159:         msg = "unhashable type: 'list'"
  160:         with pytest.raises(TypeError, match=msg):
  161:             [] in index
  162: 
  163:         msg = "|".join(
  164:             [
  165:                 r"unhashable type: 'dict'",
  166:                 r"must be real number, not dict",
  167:                 r"an integer is required",
  168:                 r"\{\}",
  169:                 r"pandas\._libs\.interval\.IntervalTree' is not iterable",
  170:             ]
  171:         )
  172:         with pytest.raises(TypeError, match=msg):
  173:             {} in index._engine
  174: 
  175: 
  176: class TestGetLoc:
  177:     def test_get_loc_non_hashable(self, index):
  178:         with pytest.raises(InvalidIndexError, match="[0, 1]"):
  179:             index.get_loc([0, 1])
  180: 
  181:     def test_get_loc_non_scalar_hashable(self, index):
  182:         # GH52877
  183:         from enum import Enum
  184: 
  185:         class E(Enum):
  186:             X1 = "x1"
  187: 
  188:         assert not is_scalar(E.X1)
  189: 
  190:         exc = KeyError
  191:         msg = "<E.X1: 'x1'>"
  192:         if isinstance(
  193:             index,
  194:             (
  195:                 DatetimeIndex,
  196:                 TimedeltaIndex,
  197:                 PeriodIndex,
  198:                 IntervalIndex,
  199:             ),
  200:         ):
  201:             # TODO: make these more consistent?
  202:             exc = InvalidIndexError
  203:             msg = "E.X1"
  204:         with pytest.raises(exc, match=msg):
  205:             index.get_loc(E.X1)
  206: 
  207:     def test_get_loc_generator(self, index):
  208:         exc = KeyError
  209:         if isinstance(
  210:             index,
  211:             (
  212:                 DatetimeIndex,
  213:                 TimedeltaIndex,
  214:                 PeriodIndex,
  215:                 IntervalIndex,
  216:                 MultiIndex,
  217:             ),
  218:         ):
  219:             # TODO: make these more consistent?
  220:             exc = InvalidIndexError
  221:         with pytest.raises(exc, match="generator object"):
  222:             # MultiIndex specifically checks for generator; others for scalar
  223:             index.get_loc(x for x in range(5))
  224: 
  225:     def test_get_loc_masked_duplicated_na(self):
  226:         # GH#48411
  227:         idx = Index([1, 2, NA, NA], dtype="Int64")
  228:         result = idx.get_loc(NA)
  229:         expected = np.array([False, False, True, True])
  230:         tm.assert_numpy_array_equal(result, expected)
  231: 
  232: 
  233: class TestGetIndexer:
  234:     def test_get_indexer_base(self, index):
  235:         if index._index_as_unique:
  236:             expected = np.arange(index.size, dtype=np.intp)
  237:             actual = index.get_indexer(index)
  238:             tm.assert_numpy_array_equal(expected, actual)
  239:         else:
  240:             msg = "Reindexing only valid with uniquely valued Index objects"
  241:             with pytest.raises(InvalidIndexError, match=msg):
  242:                 index.get_indexer(index)
  243: 
  244:         with pytest.raises(ValueError, match="Invalid fill method"):
  245:             index.get_indexer(index, method="invalid")
  246: 
  247:     def test_get_indexer_consistency(self, index):
  248:         # See GH#16819
  249: 
  250:         if index._index_as_unique:
  251:             indexer = index.get_indexer(index[0:2])
  252:             assert isinstance(indexer, np.ndarray)
  253:             assert indexer.dtype == np.intp
  254:         else:
  255:             msg = "Reindexing only valid with uniquely valued Index objects"
  256:             with pytest.raises(InvalidIndexError, match=msg):
  257:                 index.get_indexer(index[0:2])
  258: 
  259:         indexer, _ = index.get_indexer_non_unique(index[0:2])
  260:         assert isinstance(indexer, np.ndarray)
  261:         assert indexer.dtype == np.intp
  262: 
  263:     def test_get_indexer_masked_duplicated_na(self):
  264:         # GH#48411
  265:         idx = Index([1, 2, NA, NA], dtype="Int64")
  266:         result = idx.get_indexer_for(Index([1, NA], dtype="Int64"))
  267:         expected = np.array([0, 2, 3], dtype=result.dtype)
  268:         tm.assert_numpy_array_equal(result, expected)
  269: 
  270: 
  271: class TestConvertSliceIndexer:
  272:     def test_convert_almost_null_slice(self, index):
  273:         # slice with None at both ends, but not step
  274: 
  275:         key = slice(None, None, "foo")
  276: 
  277:         if isinstance(index, IntervalIndex):
  278:             msg = "label-based slicing with step!=1 is not supported for IntervalIndex"
  279:             with pytest.raises(ValueError, match=msg):
  280:                 index._convert_slice_indexer(key, "loc")
  281:         else:
  282:             msg = "'>=' not supported between instances of 'str' and 'int'"
  283:             with pytest.raises(TypeError, match=msg):
  284:                 index._convert_slice_indexer(key, "loc")
  285: 
  286: 
  287: class TestPutmask:
  288:     def test_putmask_with_wrong_mask(self, index):
  289:         # GH#18368
  290:         if not len(index):
  291:             pytest.skip("Test doesn't make sense for empty index")
  292: 
  293:         fill = index[0]
  294: 
  295:         msg = "putmask: mask and data must be the same size"
  296:         with pytest.raises(ValueError, match=msg):
  297:             index.putmask(np.ones(len(index) + 1, np.bool_), fill)
  298: 
  299:         with pytest.raises(ValueError, match=msg):
  300:             index.putmask(np.ones(len(index) - 1, np.bool_), fill)
  301: 
  302:         with pytest.raises(ValueError, match=msg):
  303:             index.putmask("foo", fill)
  304: 
  305: 
  306: @pytest.mark.parametrize(
  307:     "idx", [Index([1, 2, 3]), Index([0.1, 0.2, 0.3]), Index(["a", "b", "c"])]
  308: )
  309: def test_getitem_deprecated_float(idx):
  310:     # https://github.com/pandas-dev/pandas/issues/34191
  311: 
  312:     msg = "Indexing with a float is no longer supported"
  313:     with pytest.raises(IndexError, match=msg):
  314:         idx[1.0]
  315: 
  316: 
  317: @pytest.mark.parametrize(
  318:     "idx,target,expected",
  319:     [
  320:         ([np.nan, "var1", np.nan], [np.nan], np.array([0, 2], dtype=np.intp)),
  321:         (
  322:             [np.nan, "var1", np.nan],
  323:             [np.nan, "var1"],
  324:             np.array([0, 2, 1], dtype=np.intp),
  325:         ),
  326:         (
  327:             np.array([np.nan, "var1", np.nan], dtype=object),
  328:             [np.nan],
  329:             np.array([0, 2], dtype=np.intp),
  330:         ),
  331:         (
  332:             DatetimeIndex(["2020-08-05", NaT, NaT]),
  333:             [NaT],
  334:             np.array([1, 2], dtype=np.intp),
  335:         ),
  336:         (["a", "b", "a", np.nan], [np.nan], np.array([3], dtype=np.intp)),
  337:         (
  338:             np.array(["b", np.nan, float("NaN"), "b"], dtype=object),
  339:             Index([np.nan], dtype=object),
  340:             np.array([1, 2], dtype=np.intp),
  341:         ),
  342:     ],
  343: )
  344: def test_get_indexer_non_unique_multiple_nans(idx, target, expected):
  345:     # GH 35392
  346:     axis = Index(idx)
  347:     actual = axis.get_indexer_for(target)
  348:     tm.assert_numpy_array_equal(actual, expected)
  349: 
  350: 
  351: def test_get_indexer_non_unique_nans_in_object_dtype_target(nulls_fixture):
  352:     idx = Index([1.0, 2.0])
  353:     target = Index([1, nulls_fixture], dtype="object")
  354: 
  355:     result_idx, result_missing = idx.get_indexer_non_unique(target)
  356:     tm.assert_numpy_array_equal(result_idx, np.array([0, -1], dtype=np.intp))
  357:     tm.assert_numpy_array_equal(result_missing, np.array([1], dtype=np.intp))
